{"cell_type":{"3769296b":"code","f317bb19":"code","42134485":"code","565aa34d":"code","b8cad1d1":"code","ace5c421":"code","90a34522":"code","fccbf5cc":"code","8de5badb":"code","736e8380":"code","22bf5b2c":"code","f8490ddf":"code","5afea8d5":"code","2bf76da2":"code","ca67e0fd":"code","bf18353b":"code","d8745ad8":"code","8e7c76f2":"code","650c637a":"code","85788df5":"code","6a0cc288":"code","18947382":"code","144a5cbb":"code","f9e8ff7d":"code","98e2e920":"code","6d95c7c9":"code","cf42139e":"code","ed6740c3":"code","c98398da":"code","fc34b0ad":"code","84ff18bf":"code","f9da3961":"code","ecf435f8":"code","44c6501e":"code","2fe862a0":"code","65e14306":"markdown","ac00de5d":"markdown","abae3ee6":"markdown","bcc5cbd5":"markdown","9bf64f0e":"markdown","3210197c":"markdown","6aa9d440":"markdown","f5fb4ade":"markdown","80b757b6":"markdown","01ef8ece":"markdown","fe7c451b":"markdown","f65edb33":"markdown","412431cf":"markdown","da8d08ba":"markdown","39d5d553":"markdown","545141a9":"markdown","d91a5f65":"markdown","4d434ab3":"markdown","5c239e89":"markdown","25cd90eb":"markdown","96e25a62":"markdown","530f3d85":"markdown","ea50c94d":"markdown"},"source":{"3769296b":"import pandas as pd\nimport numpy as np\nimport matplotlib.pylab as plt\nimport json\nimport ast\nimport seaborn as sns\nimport os\n\nimport lightgbm as lgb\nfrom sklearn.model_selection import train_test_split\n\nfrom itertools import cycle\npd.set_option('max_columns', 50)\nplt.style.use('ggplot')\ncolor_pal = plt.rcParams['axes.prop_cycle'].by_key()['color']\ncolor_cycle = cycle(plt.rcParams['axes.prop_cycle'].by_key()['color'])","f317bb19":"!ls -GFlash --color ..\/input\/stanford-covid-vaccine\/","42134485":"!ls -GFlash --color ..\/input\/stanford-covid-vaccine\/bpps\/ | head","565aa34d":"!du -h ..\/input\/stanford-covid-vaccine\/bpps\/","b8cad1d1":"train = pd.read_json('..\/input\/stanford-covid-vaccine\/train.json',lines=True)\ntest = pd.read_json('..\/input\/stanford-covid-vaccine\/test.json', lines=True)\nss = pd.read_csv('..\/input\/stanford-covid-vaccine\/sample_submission.csv')\nprint(f'Train shape: {train.shape}, test shape: {test.shape}, sample submission shape: {ss.shape}')\n\nprint('========= train columns ==========')\nprint([c for c in train.columns])\n\nprint('========= test columns ==========')\nprint([c for c in test.columns])","ace5c421":"bpps_files = os.listdir('..\/input\/stanford-covid-vaccine\/bpps\/')\nexample_bpps = np.load(f'..\/input\/stanford-covid-vaccine\/bpps\/{bpps_files[0]}')\nprint('bpps file shape:', example_bpps.shape)","90a34522":"plt.style.use('default')\nfig, axs = plt.subplots(5, 5, figsize=(15, 15))\naxs = axs.flatten()\nfor i, f in enumerate(bpps_files):\n    if i == 25:\n        break\n    example_bpps = np.load(f'..\/input\/stanford-covid-vaccine\/bpps\/{f}')\n    axs[i].imshow(example_bpps)\n    axs[i].set_title(f)\nplt.tight_layout()\nplt.show()","fccbf5cc":"ss.head()","8de5badb":"train['reactivity'].head()","736e8380":"print('===== Example Train Reacivity ======')\nprint([round(r, 2) for r in train['reactivity'][0]])","22bf5b2c":"print('===== Example Train deg_Mg_pH10 value ======')\nprint([round(r, 2) for r in train['deg_Mg_pH10'][0]])","f8490ddf":"print('===== Example Train deg_Mg_50C value ======')\nprint([round(r, 2) for r in train['deg_Mg_50C'][0]])","5afea8d5":"plt.style.use('ggplot')\nfig, ax = plt.subplots(figsize=(10, 3))\nax = sns.distplot(train['signal_to_noise'])\nax.set_title('Signal to Noise feature (train)')\nplt.show()","2bf76da2":"test['seq_length'].value_counts() \\\n    .plot(kind='bar', figsize=(10, 4),\n          color=color_pal[4],\n         title='Sequence Length in public test set')\nplt.show()","ca67e0fd":"fig, axs = plt.subplots(3, 1,\n                        figsize=(10, 6),\n                        sharex=True)\naxs = axs.flatten()\ntrain['mean_reactivity'] = train['reactivity'].apply(lambda x: np.mean(x))\ntrain['mean_deg_Mg_pH10'] = train['deg_Mg_pH10'].apply(lambda x: np.mean(x))\ntrain['mean_deg_Mg_50C'] = train['deg_Mg_50C'].apply(lambda x: np.mean(x))\n\ntrain['mean_reactivity'] \\\n    .plot(kind='hist',\n          bins=50,\n          color=color_pal[0],\n          title='Distribution of Mean Reactivity in training set',\n         ax=axs[0])\ntrain['mean_deg_Mg_pH10'] \\\n    .plot(kind='hist',\n          bins=50,\n          ax=axs[1],\n          color=color_pal[4],\n          title='Distribution of Mean deg_Mg_pH10 in training set')\ntrain['mean_deg_Mg_50C'] \\\n    .plot(kind='hist',\n          bins=50,\n          ax=axs[2],\n          color=color_pal[3],\n          title='Distribution of Mean deg_Mg_50C in training set')\nplt.tight_layout()\nplt.show()","bf18353b":"mean_react = train['mean_reactivity'].mean()\nmean_deg_Mg_pH10 = train['mean_deg_Mg_pH10'].mean()\nmean_deg_Mg_50C = train['mean_deg_Mg_50C'].mean()\n\nss['reactivity'] = mean_react\nss['deg_Mg_pH10'] = mean_deg_Mg_pH10\nss['deg_Mg_50C'] = mean_deg_Mg_50C\n\nss.to_csv('submission.csv', index=False)\nss.head()","d8745ad8":"# Split the 68 Reactivity values each into it's own column\nfor n in range(68):\n    train[f'reactivity_{n}'] = train['reactivity'].apply(lambda x: x[n])\n    \nREACTIVITY_COLS = [r for r in train.columns if 'reactivity_' in r and 'error' not in r]\n\nax = train.set_index('id')[REACTIVITY_COLS] \\\n    .T \\\n    .plot(color='black',\n          alpha=0.01,\n          ylim=(-0.5, 5),\n          title='reactivity of training set',\n          figsize=(15, 5))\nax.get_legend().remove()","8e7c76f2":"for n in range(68):\n    train[f'deg_Mg_pH10_{n}'] = train['deg_Mg_pH10'].apply(lambda x: x[n])\n    \nDEG_MG_PH10_COLS = [r for r in train.columns if 'deg_Mg_pH10_' in r and 'error' not in r]\n\nax = train.set_index('id')[DEG_MG_PH10_COLS] \\\n    .T \\\n    .plot(color='c',\n          alpha=0.01,\n          ylim=(-0.5, 5),\n          title='Deg Mg Ph10 of training set',\n          figsize=(15, 5))\nax.get_legend().remove()","650c637a":"for n in range(68):\n    train[f'deg_Mg_50C_{n}'] = train['deg_Mg_50C'].apply(lambda x: x[n])\n    \nDEG_MG_50C_COLS = [r for r in train.columns if 'deg_Mg_50C_' in r and 'error' not in r]\n\nax = train.set_index('id')[DEG_MG_50C_COLS] \\\n    .T \\\n    .plot(color='m',\n          alpha=0.2,\n          ylim=(-2, 7),\n          title='Deg Mg 50C of training set',\n          figsize=(15, 5)\n         )\nax.get_legend().remove()","85788df5":"sns.pairplot(data=train,\n             vars=['mean_reactivity',\n                   'mean_deg_Mg_pH10',\n                    'mean_deg_Mg_50C'],\n            hue='SN_filter')\nplt.show()","6a0cc288":"# Expand Sequence Features\nfor n in range(107):\n    train[f'sequence_{n}'] = train['sequence'].apply(lambda x: x[n]).astype('category')\n    test[f'sequence_{n}'] = test['sequence'].apply(lambda x: x[n]).astype('category')\n\nSEQUENCE_COLS = [c for c in train.columns if 'sequence_' in c]\n\nfor target in ['reactivity','deg_Mg_pH10','deg_Mg_50C']:\n\n    X = train[SEQUENCE_COLS]\n    y = train[f'mean_{target}']\n    X_test = test[SEQUENCE_COLS]\n\n    X_train, X_val, y_train, y_val = train_test_split(X, y)\n\n    reg = lgb.LGBMRegressor(n_estimators=1000)\n    reg.fit(X_train, y_train,\n            eval_set=(X_val, y_val),\n           early_stopping_rounds=100,\n           verbose=100)\n\n    test[f'mean_{target}_pred'] = reg.predict(X_test)","18947382":"ss['id'] = 'id_' + ss['id_seqpos'].str.split('_', expand=True)[1]\n\n# Merge my predicted average values\nss_new = ss. \\\n    drop(['reactivity','deg_Mg_pH10','deg_Mg_50C'], axis=1) \\\n    .merge(test[['id',\n               'mean_reactivity_pred',\n               'mean_deg_Mg_pH10_pred',\n               'mean_deg_Mg_50C_pred']] \\\n               .rename(columns={'mean_reactivity_pred' : 'reactivity',\n                                'mean_deg_Mg_pH10_pred': 'deg_Mg_pH10',\n                                'mean_deg_Mg_50C_pred' : 'deg_Mg_50C'}\n                      ),\n         on='id',\n        validate='m:1')","144a5cbb":"TARGETS = ['reactivity','deg_Mg_pH10','deg_Mg_50C']\nfor i, t in enumerate(TARGETS):\n    ss_new[t].plot(kind='hist',\n                              figsize=(10, 3),\n                              bins=100,\n                              color=color_pal[i*3],\n                              title=f'Submission {t}')\n    plt.show()","f9e8ff7d":"ss_new.sample(10)","98e2e920":"# Make Submission\nss = pd.read_csv('..\/input\/stanford-covid-vaccine\/sample_submission.csv')\nss_new[ss.columns].to_csv('submission_lgbm_v1.csv', index=False)","6d95c7c9":"# Expand Sequence Features\nfor n in range(107):\n    train[f'structure_{n}'] = train['structure'].apply(lambda x: x[n]).astype('category')\n    test[f'structure_{n}'] = test['structure'].apply(lambda x: x[n]).astype('category')\n    train[f'predicted_loop_type_{n}'] = train['predicted_loop_type'].apply(lambda x: x[n]).astype('category')\n    test[f'predicted_loop_type_{n}'] = test['predicted_loop_type'].apply(lambda x: x[n]).astype('category')\n    train[f'sequence_{n}'] = train['sequence'].apply(lambda x: x[n]).astype('category')\n    test[f'sequence_{n}'] = test['sequence'].apply(lambda x: x[n]).astype('category')\n\nSEQUENCE_COLS = [c for c in train.columns if 'sequence_' in c]\nSTRUCTURE_COLS = [c for c in train.columns if 'structure_' in c]\nPLT_COLS = [c for c in train.columns if 'predicted_loop_type_' in c]\n\nfor target in ['reactivity','deg_Mg_pH10','deg_Mg_50C']:\n\n    X = train[SEQUENCE_COLS + STRUCTURE_COLS + PLT_COLS]\n    y = train[f'mean_{target}']\n    X_test = test[SEQUENCE_COLS + STRUCTURE_COLS + PLT_COLS]\n\n    X_train, X_val, y_train, y_val = train_test_split(X, y)\n\n    reg = lgb.LGBMRegressor(n_estimators=10000,\n                            learning_rate=0.001,\n                            feature_fraction=0.8)\n    reg.fit(X_train, y_train,\n            eval_set=(X_val, y_val),\n           early_stopping_rounds=100,\n           verbose=1000)\n\n    test[f'mean_{target}_pred'] = reg.predict(X_test)\n    \nss['id'] = 'id_' + ss['id_seqpos'].str.split('_', expand=True)[1]\n\n# Merge my predicted average values\nss_new = ss. \\\n    drop(['reactivity','deg_Mg_pH10','deg_Mg_50C'], axis=1) \\\n    .merge(test[['id',\n               'mean_reactivity_pred',\n               'mean_deg_Mg_pH10_pred',\n               'mean_deg_Mg_50C_pred']] \\\n               .rename(columns={'mean_reactivity_pred' : 'reactivity',\n                                'mean_deg_Mg_pH10_pred': 'deg_Mg_pH10',\n                                'mean_deg_Mg_50C_pred' : 'deg_Mg_50C'}\n                      ),\n         on='id',\n        validate='m:1')\n\nss = pd.read_csv('..\/input\/stanford-covid-vaccine\/sample_submission.csv')\nss_new[ss.columns].to_csv('submission.csv', index=False)\n\nTARGETS = ['reactivity','deg_Mg_pH10','deg_Mg_50C']\nfor i, t in enumerate(TARGETS):\n    ss_new[t].plot(kind='hist',\n                              figsize=(10, 3),\n                              bins=100,\n                              color=color_pal[i*3],\n                              title=f'Submission {t}')\n    plt.show()","cf42139e":"fig, axs = plt.subplots(5, 5, figsize=(12, 10))\naxs = axs.flatten()\ni = 0\nfor row in train.sample(25, random_state=42).iterrows():\n    myid = row[1]['id']\n    reactivity_array = row[1][REACTIVITY_COLS].values\n    sns.regplot(np.array(range(68)).reshape(-1, 1),\n                reactivity_array,\n                ax=axs[i],\n                color=next(color_cycle))\n    axs[i].set_title(myid)\n    i += 1\nfig.suptitle('Reactivity Array for 25 Train Examples with Regression Line',\n             fontsize=18,\n             y=1.02)\nplt.tight_layout()\nplt.show()","ed6740c3":"fig, axs = plt.subplots(5, 5,\n                        figsize=(12, 10),\n                       sharex=True)\naxs = axs.flatten()\ni = 0\nfor row in train.sample(25, random_state=42).iterrows():\n    myid = row[1]['id']\n    reactivity_array = row[1][DEG_MG_50C_COLS].values\n    sns.regplot(np.array(range(68)).reshape(-1, 1),\n                reactivity_array,\n                ax=axs[i],\n                color=next(color_cycle))\n    axs[i].set_title(myid)\n    i += 1\nfig.suptitle('\"DEG_MG_50C\" Array for 25 Train Examples with Regression Line',\n             fontsize=18,\n             y=1.02)\nplt.tight_layout()\nplt.show()","c98398da":"fig, axs = plt.subplots(5, 5, figsize=(12, 10))\naxs = axs.flatten()\ni = 0\nfor row in train.sample(25, random_state=42).iterrows():\n    myid = row[1]['id']\n    reactivity_array = row[1][DEG_MG_PH10_COLS].values\n    sns.regplot(np.array(range(68)).reshape(-1, 1),\n                reactivity_array,\n                ax=axs[i],\n                color=next(color_cycle))\n    axs[i].set_title(myid)\n    i += 1\nfig.suptitle('\"DEG_MG_PH10\" Array for 25 Train Examples with Regression Line',\n             fontsize=18,\n             y=1.02)\nplt.tight_layout()\nplt.show()","fc34b0ad":"import pandas as pd\nimport numpy as np\nimport json\nfrom tqdm.notebook import tqdm\nfrom sklearn.model_selection import train_test_split\nimport lightgbm as lgb\nimport matplotlib.pylab as plt\n\ndef expand_columns(df):\n    df = df.copy()\n    df = df.drop('index', axis=1)\n    max_seq_length = df['seq_length'].max()\n    SEQUENCE_COLS = []; STRUCTURE_COLS = []; PRED_LOOP_TYPE_COLS = []\n    for s in range(130):\n        df[f'sequence_{s}'] = df['sequence'].str[s]\n        df[f'structure_{s}'] = df['structure'].str[s]\n        df[f'predicted_loop_type_{s}'] = df['predicted_loop_type'].str[s]\n        SEQUENCE_COLS.append(f'sequence_{s}')\n        STRUCTURE_COLS.append(f'structure_{s}')\n    return df, SEQUENCE_COLS, STRUCTURE_COLS\n\ndef parse_sample_submission(ss):\n    ss = ss.copy()\n    ss['id'] = ss['id_seqpos'].str.split('_', expand=True)[1]\n    ss['seqpos'] = ss['id_seqpos'].str.split('_', expand=True)[2].astype('int')\n    return ss","84ff18bf":"def get_train_long(train):\n    dfs = []\n\n    def pad(feat, tolen):\n        padded = np.pad(feat,\n                        (0, tolen-len(feat)),\n                        mode='constant',\n                        constant_values=np.nan)\n        return padded\n\n    for d in tqdm(train.itertuples(), total=len(train)):\n        sequence = [s for s in d[3]]\n        seq_len = len(sequence)\n        structure = [s for s in d[4]]\n        predicted_loop_type = [s for s in d[5]]\n        reactivity_error = pad([s for s in d[10]], seq_len)\n        deg_error_Mg_pH10 = pad([s for s in d[11]], seq_len)\n        deg_error_pH10 = pad([s for s in d[12]], seq_len)\n        deg_error_Mg_50C = pad([s for s in d[13]], seq_len)\n        deg_error_50C = pad([s for s in d[14]], seq_len)\n\n        reactivity = pad([s for s in d[15]], seq_len)\n        deg_Mg_pH10 = pad([s for s in d[16]], seq_len)\n        deg_pH10 = pad([s for s in d[17]], seq_len)\n        deg_Mg_50C = pad([s for s in d[18]], seq_len)\n        deg_50C = pad([s for s in d[10]], seq_len)\n        myid = [d[2]] * len(sequence)\n        seqpos = [c for c in range(len(sequence))]\n        dfs.append(pd.DataFrame(np.array([myid,\n                                          seqpos,\n                                          sequence,\n                                          structure,\n                                          predicted_loop_type,\n                                          reactivity_error,\n                                          deg_error_Mg_pH10,\n                                          deg_error_pH10,\n                                          deg_error_Mg_50C,\n                                          deg_error_50C,\n                                          reactivity,\n                                          deg_Mg_pH10,\n                                          deg_pH10,\n                                          deg_Mg_50C,\n                                         ]).T))\n    train_long = pd.concat(dfs)\n\n    train_long.columns=['id',\n               'seqpos',\n               'sequence',\n               'structure',\n               'predicted_loop_type',\n               'reactivity_error',\n               'deg_error_Mg_pH10',\n               'deg_error_pH10',\n               'deg_error_Mg_50C',\n               'deg_error_50C',\n               'reactivity',\n               'deg_Mg_pH10',\n               'deg_pH10',\n               'deg_Mg_50C']\n\n    return train_long\n\n\ndef get_test_long(test):\n    dfs = []\n\n    def pad(feat, tolen):\n        padded = np.pad(feat,\n                        (0, tolen-len(feat)),\n                        mode='constant',\n                        constant_values=np.nan)\n        return padded\n\n    for d in tqdm(test.itertuples(), total=len(test)):\n        sequence = [s for s in d[3]]\n        seq_len = len(sequence)\n        structure = [s for s in d[4]]\n        predicted_loop_type = [s for s in d[5]]\n        myid = [d[2]] * len(sequence)\n        seqpos = [c for c in range(len(sequence))]\n        dfs.append(pd.DataFrame(np.array([myid,\n                                          seqpos,\n                                          sequence,\n                                          structure,\n                                          predicted_loop_type,\n                                         ]).T))\n    test_long = pd.concat(dfs)\n\n    test_long.columns=['id',\n               'seqpos',\n               'sequence',\n               'structure',\n               'predicted_loop_type']\n\n    return test_long\n\ndef add_long_features(df):\n    df = df.copy()\n    df['seqpos'] = df['seqpos'].astype('int')\n    df = df.merge(df.query('seqpos <= 106') \\\n                    .groupby('id')['sequence'] \\\n                      .value_counts() \\\n                      .unstack() \\\n                      .reset_index(),\n             how='left',\n             on=['id'],\n             validate='m:1'\n            )\n    \n    df = df.merge(df.query('seqpos <= 106') \\\n                  .groupby('id')['structure'] \\\n                      .value_counts() \\\n                      .unstack() \\\n                      .reset_index(),\n             how='left',\n             on=['id'],\n             validate='m:1'\n            )\n\n    df = df.merge(df.query('seqpos <= 106') \\\n                  .groupby('id')['predicted_loop_type'] \\\n                      .value_counts() \\\n                      .unstack() \\\n                      .reset_index(),\n             how='left',\n             on=['id'],\n             validate='m:1'\n            )\n    for shift in [-5, -4, -3, -2 -1, 1, 2, 3, 4, 5]:\n        for f in ['sequence','structure','predicted_loop_type']:\n            df[f'{f}_shift{shift}'] = df.groupby('id')[f].shift(shift)\n    return df","f9da3961":"def make_feature_types(df, features):\n    df = df.copy()\n    df = df.replace('nan', np.nan)\n    for f in features:\n        try:\n            df[f] = pd.to_numeric(df[f])\n        except ValueError:\n            df[f] = df[f].astype('category')\n    return df","ecf435f8":"train = pd.read_json('..\/input\/stanford-covid-vaccine\/train.json', lines=True)\ntest = pd.read_json('..\/input\/stanford-covid-vaccine\/test.json', lines=True)\nss = pd.read_csv('..\/input\/stanford-covid-vaccine\/sample_submission.csv')\n\ntrain_expanded, SEQUENCE_COLS, STRUCTURE_COLS = expand_columns(train)\ntest_expanded, SEQUENCE_COLS, STRUCTURE_COLS = expand_columns(test)\nss = parse_sample_submission(ss)\n\ntrain_long = get_train_long(train)\ntest_long = get_test_long(test)\n\ntrain_long = add_long_features(train_long)\ntest_long = add_long_features(test_long)\n\nFEATURES = ['seqpos',\n            'sequence',\n            'structure',\n            'predicted_loop_type',\n            'A', 'C', 'G', 'U', '(', ')', '.', 'B', 'E',\n            'H', 'I', 'M', 'S', 'X',\n            'sequence_shift-5', 'structure_shift-5',\n            'predicted_loop_type_shift-5', 'sequence_shift-4', 'structure_shift-4',\n            'predicted_loop_type_shift-4', 'sequence_shift-3', 'structure_shift-3',\n            'predicted_loop_type_shift-3', 'sequence_shift1', 'structure_shift1',\n            'predicted_loop_type_shift1', 'sequence_shift2', 'structure_shift2',\n            'predicted_loop_type_shift2', 'sequence_shift3', 'structure_shift3',\n            'predicted_loop_type_shift3', 'sequence_shift4', 'structure_shift4',\n            'predicted_loop_type_shift4', 'sequence_shift5', 'structure_shift5',\n            'predicted_loop_type_shift5']\n\ntrain_long = make_feature_types(train_long, FEATURES)\ntest_long = make_feature_types(test_long, FEATURES)\n\ntrain_ids, val_ids = train_test_split(train['id'].unique())\n\nTARGETS = ['reactivity','deg_Mg_pH10','deg_Mg_50C']\nfis = []\nfor t in TARGETS:\n    print(f'==== Running for target {t} ====')\n    X_train = train_long.dropna(subset=[t]).loc[train_long['id'].isin(train_ids)][FEATURES].copy()\n    y_train = train_long.dropna(subset=[t]).loc[train_long['id'].isin(train_ids)][t].copy()\n    X_val = train_long.dropna(subset=[t]).loc[train_long['id'].isin(val_ids)][FEATURES].copy()\n    y_val = train_long.dropna(subset=[t]).loc[train_long['id'].isin(val_ids)][t].copy()\n    X_test = test_long[FEATURES].copy()\n    y_train = pd.to_numeric(y_train)\n    y_val = pd.to_numeric(y_val)\n    \n    reg = lgb.LGBMRegressor(n_estimators=10000,\n                            learning_rate=0.01,\n                            importance_type='gain')\n    reg.fit(X_train, y_train,\n            eval_set=(X_val, y_val),\n           verbose=1000,\n           early_stopping_rounds=500)\n\n    fi_df = pd.DataFrame(index=FEATURES, \n                 data=reg.feature_importances_,\n                 columns=[f'importance_{t}'])\n    \n    fi_df.sort_values(f'importance_{t}') \\\n        .plot(kind='barh', figsize=(8, 15), title=t)\n    plt.show()\n    fis.append(fi_df)\n    \n    test_long[f'{t}_pred'] = reg.predict(X_test)","44c6501e":"test_long['id_seqpos'] = test_long['id'] + '_' + test_long['seqpos'].astype('str')\n\ntest_long['deg_pH10'] = 0\ntest_long['deg_50C'] = 0\ntest_long = test_long.rename(columns={'reactivity_pred':'reactivity',\n                          'deg_Mg_pH10_pred': 'deg_Mg_pH10',\n                          'deg_Mg_50C_pred': 'deg_Mg_50C'})\n\nss = pd.read_csv('..\/input\/stanford-covid-vaccine\/sample_submission.csv')\nassert test_long[ss.columns].shape == ss.shape\n\ntest_long[ss.columns].to_csv('submission.csv', index=False)","2fe862a0":"for t in TARGETS:\n    train_long[t].dropna().astype('float').plot(kind='hist', bins=50, figsize=(10, 3), title=t)\n    test_long[t].plot(kind='hist', bins=50, figsize=(10, 3), title=t)\n    plt.show()","65e14306":"## seq_length\n\nTrain data consists of only 107 sequence length. The test data contains mostly 130 sequence lengths.","ac00de5d":"# Improve Baseline by adding: **structure** and **predicted_loop_type** features [0.47520 LB]","abae3ee6":"# Relationship between targets\nColored by `SN_filter` although I'm not clear from the data description what this column represents.\n","bcc5cbd5":"## deg_Mg_50C column\n- deg_Mg_50C - (1x68 vector in train\/test, 1x91 in final scoring) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating with magnesium at high temperature (50 degrees Celsius).\n","9bf64f0e":"## deg_Mg_pH10 column\n\nWe are told:\n- deg_Mg_pH10 - (1x68 vector in train\/test, 1x91 in final scoring) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating with magnesium in high pH (pH 10).","3210197c":"# OpenVaccine: mRNA Vaccine Degradation Prediction\n\n<div>\n<img src=\"https:\/\/daslab.stanford.edu\/site_data\/news_img\/openvaccine_lores.png\" width=\"300\" height=\"100\"\/>\n<\/div>\n\nIn this competition, you will be predicting the degradation rates at various locations along RNA sequence.\n\nThere are multiple ground truth values provided in the training data. While the submission format requires all 5 to be predicted, only the following are scored: `reactivity`, `deg_Mg_pH10`, and `deg_Mg_50C`.","6aa9d440":"# Sample Submission\n\nLets quickly look at the sample submission format. Even though we submit for addional solumns, only three columns are scored: `reactivity`, `deg_Mg_pH10`, and `deg_Mg_50C`","f5fb4ade":"# Modeling approach. Fit Line for Reactivity?\nLets test and see what a regression line looks like for some example samples. Since we are only given 68 values in the training set and will predict 93 in the test, this might be a good idea for extending the trend beyond 93. ","80b757b6":"The bpps directory has a bunch of numpy data. It's about 670MB in size.","01ef8ece":"# reactivity column\n\nIn the data description we are told:\n- `reactivity` - (1x68 vector in train\/test, 1x91 in final scoring) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likely secondary structure of the RNA sample.\n","fe7c451b":"# Loading JSON Files","f65edb33":"## signal_to_noise feature","412431cf":"# Look at Numpy Data\n\nWe don't know much about the numpy data from the data description. We think they might be Base Pairing Probability Matrix files. According to [this paper abstract:](https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC3514005\/#:~:text=A%20base%2Dpairing%20probability%20matrix,structure%20prediction%20and%20motif%20search)\n\n*A base-pairing probability matrix (BPPM) stores the probabilities for every possible base pair in an RNA sequence and has been used in many algorithms in RNA informatics (e.g., RNA secondary structure prediction and motif search). In this study, we propose a novel algorithm to perform iterative updates of a given BPPM, satisfying marginal probability constraints that are (approximately) given by recently developed biochemical experiments, such as SHAPE, PAR, and FragSeq. The method is easily implemented and is applicable to common models for RNA secondary structures, such as energy-based or machine-learning\u2013based models. In this article, we focus mainly on the details of the algorithms, although preliminary computational experiments will also be presented.*\n\n","da8d08ba":"Lets plot this data for 25 examples.","39d5d553":"## Fill in predictions with the mean value\n","545141a9":"# Simple Baseline Using Simple LightGBM [0.47706 LB]\n\nThis model still predicts the same value for each id in the test set, but the predicted value is based off of the sequence data.","d91a5f65":"# Plot the Targets for Each Training Example\nFirst we need to split the list of 68 values for each target into their own columns. Then we can plot.","4d434ab3":"## Map mean predictions to test","5c239e89":"# Baseline Submission [0.47840 LB]\n## Predict the average value for each target column\nLets first calculate the average value for the target columns. And then create a 91 length vector as a baseline submission.","25cd90eb":"## Data Exploration\nLets take a look at the data. It's provided in json format.","96e25a62":"# Better LightGBM Model\n- Expanding for one row per prediction","530f3d85":"## Create Submission","ea50c94d":"## Plot Distribution of predictions vs. Training"}}