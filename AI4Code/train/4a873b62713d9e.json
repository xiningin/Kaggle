{"cell_type":{"711a45c4":"code","92e76c31":"code","1b6411c6":"code","0213db30":"code","b7ac42ef":"code","c0584793":"code","83082400":"code","1ac126b7":"code","31ac95af":"code","44a51e17":"code","e623b45f":"code","cc9a2c47":"code","5bf770bb":"code","1d082856":"code","1b81115a":"code","77c570be":"code","233c08a6":"code","da084ce5":"code","bea7d80a":"code","6b1b7969":"code","2d47fa47":"code","aba1b3d5":"code","b988a9af":"code","aec75396":"code","9c78e3b5":"code","7b75e501":"code","40cd0d7b":"code","f16bafe6":"code","98d397c7":"code","41a0a881":"code","28955bc8":"code","f23a14a4":"code","b65274ba":"code","f72433e6":"code","6332bcda":"code","35b17207":"code","07c8b4d5":"code","c5f3286c":"code","987ac8f8":"code","15997fc5":"code","8b62339c":"code","0c1fbfdf":"code","e6b5b831":"code","ede4c635":"code","9f0066f3":"code","3bbcd252":"code","dad5c83e":"code","20c2adc5":"markdown","a4d5fbe8":"markdown","7264bbf8":"markdown","c931dead":"markdown","ab849e1f":"markdown","0f4ecb41":"markdown","9d5529e2":"markdown","230dc14b":"markdown","b0c46d07":"markdown","d91cb87e":"markdown","38870388":"markdown","69ac850a":"markdown","e180f79d":"markdown","4fe72422":"markdown","d885fdd8":"markdown","a3a07350":"markdown","fb298a80":"markdown","a581e66b":"markdown","848c073a":"markdown","5d339e34":"markdown","2a01195b":"markdown","095b5148":"markdown","8f3286a7":"markdown","3146d972":"markdown","17f2aabc":"markdown","f55de7fe":"markdown","17c4bbec":"markdown","97844fbf":"markdown","0029415d":"markdown"},"source":{"711a45c4":"import pandas as pd\nimport lightgbm as lgb","92e76c31":"import os\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.model_selection import train_test_split\n\ntrain = pd.read_csv('\/kaggle\/input\/iris\/Iris.csv', index_col='Id')\ndataX = train[ train.columns[train.columns.str.contains('Cm$')] ]\ndatay = OrdinalEncoder().fit_transform(train[['Species']]).flatten().astype(int)\ntrainSet = lgb.Dataset(dataX, datay)","1b6411c6":"param = {'objective'       : 'multiclass',\n         'metric'          : 'multi_logloss',\n         'num_class'       : train['Species'].nunique(),\n         'num_leaves'      : 3,\n         'min_data_in_leaf': 36, \n         'learning_rate'   : .15,\n         'num_boost_round' : 30}\nmodel = lgb.train(param, trainSet)","0213db30":"def grabdict(tisdict, tree_index, split_index, depth, splits, leaves):\n# recursive function to unravel nested dictionaries\n    depth += 1\n    if 'split_index' in tisdict.keys():\n        tis = tisdict.copy()\n        del tis['left_child']\n        del tis['right_child']\n        tis['tree_index'] = tree_index\n        split_index = tis['split_index']\n        splits = pd.concat([splits, pd.DataFrame(tis, index=[len(splits)])])\n        splits, leaves = grabdict(tisdict['left_child'], tree_index, split_index, depth, splits, leaves)\n        splits, leaves = grabdict(tisdict['right_child'], tree_index, split_index, depth, splits, leaves)\n    else:\n        tis = tisdict.copy()\n        tis['tree_index'] = tree_index\n        tis['split_index'] = split_index\n        tis['depth'] = depth\n        leaves = pd.concat([leaves, pd.DataFrame(tis, index=[len(leaves)])])\n    return splits, leaves\n\ndef slimdf(df):   \n# just to condense the df and chop off redundant columns\n    common = {}\n    for col in df.columns:\n        if df[col].nunique()==1:\n            tt = df[col].unique()[0]\n            print('column {:>13s} = {:<4s} in all rows: reporting here; removed henceforth.'.format(col, str(tt)))\n            common[col] = tt\n            del df[col]\n    return df\n\ndef grabtrees(model):\n# wrapper function to call the two functions above\n    splits, leaves = pd.DataFrame(), pd.DataFrame()\n    tree_info = model.dump_model()['tree_info']\n    for tisdict in tree_info:\n        splits, leaves = grabdict(tisdict['tree_structure'], tisdict['tree_index'], 0, 0, splits, leaves)\n    leaves = leaves.merge(splits, left_on=['tree_index', 'split_index'], right_on=['tree_index', 'split_index'], how='left')\n    leaves = slimdf(leaves)\n    return tree_info, leaves\n\ntree_info, leaves = grabtrees(model)\nleaves   # all leaves in a single df - this is what we are after - the heart of this notebook","b7ac42ef":"# How many trees altogether?\nhow_many_trees = len(tree_info)\nassert how_many_trees == param['num_boost_round'] * param['num_class']\nhow_many_trees","c0584793":"leaves.describe()","83082400":"import matplotlib.pyplot as plt\ncols = leaves.select_dtypes(include='float').columns\nplt.figure(figsize=(20, 3))\nfor ncol, col in enumerate(cols):\n    plt.subplot(1, len(cols), 1+ncol)\n    plt.plot(leaves['tree_index'], leaves[col], '.')\n    plt.title(col); plt.grid(True); plt.xlabel('tree_index')","1ac126b7":"plt.figure(figsize=(20, 3))\nfor nleaf_index, leaf_index in enumerate(leaves['leaf_index'].unique()):\n    plt.subplot(1, leaves['leaf_index'].nunique(), 1+nleaf_index)\n    select = leaves['leaf_index']==leaf_index\n    plt.plot(leaves.loc[select, 'tree_index'], leaves.loc[select, 'leaf_value'], '.-')\n    plt.xlabel('tree_index')\n    plt.title(f'leaf_index={leaf_index}')\n    plt.grid(True)","31ac95af":"# our first tree\nleaves.loc[ leaves['tree_index']==0 ]","44a51e17":"tree_info[0]","e623b45f":"show_info = ['split_gain', 'internal_value', 'internal_weight', 'internal_count', 'leaf_weight', 'leaf_count', 'data_percentage']\nlgb.plot_tree(model, tree_index=0, show_info=show_info)\n# Here we find 1 split (square) and 2 leaves (oval). This is a tree in its simplest form. More complicated trees later.","cc9a2c47":"model.feature_name()[tree_info[0]['tree_structure']['split_feature']]","5bf770bb":"leaves.loc[ leaves['tree_index']==0 ][['threshold', 'split_gain', 'internal_value', 'internal_weight', 'internal_count']]\n# These values are characteristic of the split. Therefore shared in common by both leaves.","1d082856":"tree_info[0]['tree_structure']['threshold']","1b81115a":"tree_info[0]['tree_structure']['split_gain']","77c570be":"tree_info[0]['tree_structure']['internal_value']","233c08a6":"tree_info[0]['tree_structure']['internal_weight']","da084ce5":"tree_info[0]['tree_structure']['internal_count']","bea7d80a":"tree_info[0]['tree_structure']['internal_count'] \/ len(dataX) * 100","6b1b7969":"leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==0)]","2d47fa47":"tree_info[0]['tree_structure']['left_child']","aba1b3d5":"tree_info[0]['tree_structure']['left_child']['leaf_count'] \/ len(dataX) * 100","b988a9af":"(dataX['PetalLengthCm']<=3.15).sum(),   leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==0), 'leaf_count'].values","aec75396":"leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==1)]","9c78e3b5":"tree_info[0]['tree_structure']['right_child']","7b75e501":"tree_info[0]['tree_structure']['right_child']['leaf_count'] \/ len(dataX) * 100","40cd0d7b":"(dataX['PetalLengthCm']>3.15).sum(),   leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==1), 'leaf_count'].values","f16bafe6":"tree_info[0]['tree_structure']['internal_count'] == \\\ntree_info[0]['tree_structure']['left_child']['leaf_count'] + \\\ntree_info[0]['tree_structure']['right_child']['leaf_count']\n# Yes!","98d397c7":"leaves.loc[ leaves['tree_index'] == leaves['tree_index'].max() ]","41a0a881":"tree_info[-1]\n# See that num_leaves=3 so we rightly found 3 leaves in the previous cell","28955bc8":"lgb.plot_tree(model, tree_index=89, figsize=(10, 10), show_info=show_info)\n# Here we find 2 splits (square) and 3 leaves (oval).\n# Leaf count is 3, consistent with the output from the previous 2 cells.","f23a14a4":"leaves.loc[ (leaves['tree_index']==89) & (leaves['split_index']==0) ]","b65274ba":"leaves.loc[ (leaves['tree_index']==89) & (leaves['split_index']==1) ]","f72433e6":"sum((dataX['PetalWidthCm']<=1.35) & \\\n    (dataX['SepalWidthCm']<=3.05)),   leaves.loc[ (leaves['tree_index']==89) & (leaves['leaf_index']==0), 'leaf_count'].values","6332bcda":"sum(dataX['PetalWidthCm']>1.35),   leaves.loc[ (leaves['tree_index']==89) & (leaves['leaf_index']==1), 'leaf_count'].values","35b17207":"sum((dataX['PetalWidthCm']<=1.35) & \\\n    (dataX['SepalWidthCm']>3.05)),   leaves.loc[ (leaves['tree_index']==89) & (leaves['leaf_index']==2), 'leaf_count'].values","07c8b4d5":"param.update({'num_leaves'      : 50,  # set ridiculously high for demo purpose\n              'min_data_in_leaf': 2})  # letting our guard down for demo purpose\nmodel = lgb.train(param, trainSet)\ntree_info, leaves = grabtrees(model)\nleaves.sort_values(by='depth', ascending=False)","c5f3286c":"deepest_leaf = leaves.loc[leaves['depth'].argmax()]\ndeepest_leaf","987ac8f8":"tree_with_deepest_leaf = deepest_leaf['tree_index']\nleaves.loc[ leaves['tree_index']==tree_with_deepest_leaf ]","15997fc5":"lgb.plot_tree(model, tree_index=int(tree_with_deepest_leaf), figsize=(20, 15), show_info=show_info)\n# We count 36 ovals and 35 boxes","8b62339c":"len(leaves.loc[ leaves['tree_index']==tree_with_deepest_leaf ])\n# All good.","0c1fbfdf":"leaves.loc[ leaves['tree_index']==tree_with_deepest_leaf, 'split_index' ].max() + 1\n# Perfect tally.","e6b5b831":"leaves.sort_values(by='split_index', ascending=False)\n# No. \n# The deepest tree has depth=18 and max(split_index)=31. \n# The tree with most splits has depth=11 and max(split_index)=41.","ede4c635":"leaf_with_most_splits = leaves.loc[leaves['split_index'].argmax()]\ntree_with_most_splits = leaf_with_most_splits['tree_index']","9f0066f3":"lgb.plot_tree(model, tree_index=int(tree_with_most_splits), figsize=(20, 15), show_info=show_info)\n# We count 42 boxes and 43 ovals","3bbcd252":"leaves.loc[leaves['tree_index']==tree_with_most_splits, 'split_index'].max() + 1\n# Yes!","dad5c83e":"(leaves['tree_index']==tree_with_most_splits).sum()\n# Yes!","20c2adc5":"8.8 Does the number of ovals agree with the number of leaves on this tree?","a4d5fbe8":"### 8.5 Is the deepest tree the one with most splits?","7264bbf8":"# V O I L A\nNow we have 3 ways of looking into trees leaf-by-leaf: \n* leaves (Pandas DataFrame);\n* booster.dump_model()['tree_info'] (nested dictionary);\n* lgb.plot_tree (pictorial).","c931dead":"### 7.1 The 1st split (split_index=0)","ab849e1f":"# 0. Context\nLightgbm boosters, once trained, provide leaf-level details via *booster.dump_model()['tree_info']* in the form of a nested dictionary. Pandas DataFrames are easier to navigate than nested dictionaries; particularly as the depth and number of splits vary wildly from tree to tree. I find the process itself -- of exporting the trees to Pandas -- a learning opportunity of great fun. \n\n*trees_to_dataframe()* doesn't yet readily work, some background can be found in these links:\n* Output tree structure to dataframe https:\/\/github.com\/microsoft\/LightGBM\/issues\/2578\n* Output model to a pandas DataFrame https:\/\/github.com\/microsoft\/LightGBM\/pull\/2592\n* No trees_to_dataframe in the python package https:\/\/github.com\/microsoft\/LightGBM\/issues\/2959\n\nThis notebook connects *booster.dump_model()['tree_info']* output with *lgb.plot_tree* output.","0f4ecb41":"### 8.6 Let's plot the tree with the highest number of splits","9d5529e2":"# 6. Case study (*Tree* study, rather)","230dc14b":"# ======== TEAR OFF HERE ========\nRemainder of this notebook is optional. Just demos and examples.","b0c46d07":"# 1. Initiation rite\nInvocations we can't go on without.","d91cb87e":"### 7.3 The 1st leaf (leaf_index=0, count=36)","38870388":"### 6.2 The top leaf\n* Where does -0.880 come from?\n* Where do 22.667 weight, count: 51, 34.00% of data come from?","69ac850a":"### 6.3 The bottom leaf\n* Where does -1.211 come from?\n* Where edo 44.000 weight, count: 99, 66.00% of data come from?","e180f79d":"### 7.4 The 2nd leaf (leaf_index=1, count=72)","4fe72422":"# 5. Quick exploration","d885fdd8":"### 8.7 Does the number boxes agree with max(split_index)+1?","a3a07350":"### 8.1 Grab the deepest leaf of all","fb298a80":"### 8.4 Verify that total number of boxes = max(split_index) + 1\nWe need to plus one because split_index starts from zero.","a581e66b":"# 9. Sister notebooks: the Leaf-by-leaf series\nDecision trees: a leaf-by-leaf demo\n\nhttps:\/\/www.kaggle.com\/marychin\/decision-trees-a-leaf-by-leaf-demo\n\n**num_leaves** and **min_data_in_leaf**: a LightGBM demo\n\nhttps:\/\/www.kaggle.com\/marychin\/num-leaves-min-data-in-leaf-a-lightgbm-demo\n\nmin_sum_hessian: a LightGBM demo\n\nhttps:\/\/www.kaggle.com\/marychin\/min-sum-hessian-a-lightgbm-demo\n\nfeature_importances split vs gain: a demo\n\nhttps:\/\/www.kaggle.com\/marychin\/feature-importances-split-vs-gain-a-demo\n\n# 10. Cheers, Kagglers & Kaggle!\nTogether we democratise learning and skills.","848c073a":"# 8. Bump *num_leaves* up to something ridiculous","5d339e34":"### 7.2 The 2nd split (split_index=1)","2a01195b":"# 4. Fun part: put trees in Pandas DataFrame","095b5148":"### 8.3 Verify that total number of ovals = number of leaves","8f3286a7":"# 2. Toy data for training \nBorrowing data from https:\/\/www.kaggle.com\/uciml\/iris.\n*Replace next cell with your own data.*","3146d972":"# 7. Jump to our last tree","17f2aabc":"# 3. Toy model for tree-dumping\n*Replace next cell with your own model.*","f55de7fe":"### 7.5 The 3rd leaf (leaf_index=2, count=42)","17c4bbec":"* Do leaf counts add up to the count in the parent node?","97844fbf":"### 8.2 Plot our deepest tree yet","0029415d":"### 6.1 Inside the box\n* Where does PetalLengthCm come from?\n* Where does 3.150 come from?\n* Where do 72.794 gain, 0.000 value, 0.000 weight, count: 150, 100% of data come from?"}}