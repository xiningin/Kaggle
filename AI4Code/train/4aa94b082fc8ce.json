{"cell_type":{"b660b300":"code","5b500c4d":"code","09b60668":"code","5a12e11a":"code","0765b025":"code","9da6db82":"code","89a84b4c":"markdown","baf7ee3f":"markdown","2e6c705f":"markdown","b49456fc":"markdown"},"source":{"b660b300":"import numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline","5b500c4d":"class gridworld:\n    \n    def __init__(self):\n        self.dim = [5, 5]\n        self.pos_A = [0, 1]\n        self.rew_A = 10\n        self.trans_A = [4, 1]\n        self.pos_B = [0, 3]\n        self.rew_B = 5\n        self.trans_B = [2, 3]\n        # Define starting position\n        self.start = [4, 0]\n        self.s = self.start[:]\n        self.reward = 0\n            \n        # Step count\n        self.n = 0\n        self.action_space = [\"U\", \"L\", \"D\", \"R\"]\n        self.action_prob = [0.25, 0.25, 0.25, 0.25]\n    \n    # Show empty environment\n    def show_grid(self):\n        # print rows\n        for i in range(self.dim[0]):\n            print(\"-\" * (self.dim[0] * 5 + 1))\n            row = []\n            for j in range(self.dim[1]):\n                if i == self.pos_A[0] and j == self.pos_A[1]:\n                    row.append(\"| A \")\n                elif i == self.pos_B[0] and j == self.pos_B[1]:\n                    row.append(\"| B \")\n                elif i == self.trans_A[0] and j == self.trans_A[1]:\n                    row.append(\"| A'\")\n                elif i == self.trans_B[0] and j == self.trans_B[1]:\n                    row.append(\"| B'\")\n                elif i == self.start[0] and j == self.start[1]:\n                    row.append(\"| S \")\n                else:\n                    row.append(\"|   \")\n            row.append(\"|  \")\n            print(' '.join(row))\n        print(\"-\" * (self.dim[0] * 5 + 1))\n        \n    # Show state\n    def show_state(self):\n        # print rows\n        for i in range(self.dim[0]):\n            print(\"-\" * (self.dim[0] * 5 + 1))\n            row = []\n            for j in range(self.dim[1]):\n                if i == self.s[0] and j == self.s[1]:\n                    row.append(\"| X \")\n                elif i == self.pos_A[0] and j == self.pos_A[1]:\n                    row.append(\"| A \")\n                elif i == self.pos_B[0] and j == self.pos_B[1]:\n                    row.append(\"| B \")\n                elif i == self.trans_A[0] and j == self.trans_A[1]:\n                    row.append(\"| A'\")\n                elif i == self.trans_B[0] and j == self.trans_B[1]:\n                    row.append(\"| B'\")\n                else:\n                    row.append(\"|   \")\n            row.append(\"|  \")\n            print(' '.join(row))\n        print(\"-\" * (self.dim[0] * 5 + 1))\n        \n    # Give the agent an action\n    def action(self, a):\n        if a not in self.action_space:\n            return \"Error: Invalid action submission\"\n        # Check for special transition states\n        if self.s == self.pos_A:\n            self.s = self.trans_A[:]\n            self.reward = self.rew_A\n        elif self.s == self.pos_B:\n            self.s = self.trans_B[:]\n            self.reward = self.rew_B\n        # Move up\n        elif a == \"U\" and self.s[0] > 0:\n            self.s[0] -= 1\n            self.reward = 0\n        # Move left\n        elif a == \"L\" and self.s[1] > 0:\n            self.s[1] -= 1\n            self.reward = 0\n        # Move down\n        elif a == \"D\" and self.s[0] < self.dim[0] - 1:\n            self.s[0] += 1\n            self.reward = 0\n        # Move right\n        elif a == \"R\" and self.s[1] < self.dim[1] - 1:\n            self.s[1] += 1\n            self.reward = 0\n        else:\n            self.reward = -1\n        self.n += 1\n        return self.s, self.reward\n            \n    def reset(self):\n        self.s = self.start\n        self.reward = 0\n        self.n = 0","09b60668":"grid = gridworld()\ngrid.show_grid()","5a12e11a":"q = np.zeros((grid.dim[0], grid.dim[1], len(grid.action_space)))\ngamma = 0.9\ndelta = 1e-5\ndelta_t = 1\n\nwhile delta_t > delta:\n    q_old = q.copy()\n    for i in range(grid.dim[0]):\n        for j in range(grid.dim[1]):\n            for a in grid.action_space:\n                grid.s = [i, j]\n                s, r = grid.action(a)\n                a_index = grid.action_space.index(a)\n                q[i, j, a_index] = r + gamma * np.max(q_old[s[0], s[1]])\n    delta_t = np.sum(np.abs(q - q_old))\n    \nprint(np.max(q, axis=2).round(1))","0765b025":"def opt_policy(q, grid):\n    q_max = np.max(q, axis=2)\n    x = np.linspace(0, grid.dim[0] - 1, grid.dim[0]) + 0.5\n    y = np.linspace(grid.dim[1] - 1, 0, grid.dim[1]) + 0.5\n    X, Y = np.meshgrid(x, y)\n    zeros = np.zeros((grid.dim))\n    \n    fig = plt.figure(figsize=(12,8))\n    ax = plt.axes()\n    \n    for i, action in enumerate(grid.action_space):\n        q_star = np.zeros((5, 5))\n        for j in range(grid.dim[0]):\n            for k in reversed(range(grid.dim[1])):\n                if q[j, k, i] == q_max[j, k]:\n                    q_star[j, k] = 0.4\n        # Plot results\n        if action == \"U\":\n            # Vectors point in positive Y-direction\n            plt.quiver(X, Y, zeros, q_star, scale=1, units='xy')\n        elif action == \"L\":\n            # Vectors point in negative X-direction\n            plt.quiver(X, Y, -q_star, zeros, scale=1, units='xy')\n        elif action == \"D\":\n            # Vectors point in negative Y-direction\n            plt.quiver(X, Y, zeros, -q_star, scale=1, units='xy')\n        elif action == \"R\":\n            # Vectors point in positive X-direction\n            plt.quiver(X, Y, q_star, zeros, scale=1, units='xy')\n        \n    plt.xlim([0, grid.dim[0]])\n    plt.ylim([0, grid.dim[1]])\n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    plt.grid()\n    plt.show()","9da6db82":"opt_policy(q, grid)","89a84b4c":"# Environment setup","baf7ee3f":"# Main imports","2e6c705f":"# Plot results","b49456fc":"# Searching Q*"}}