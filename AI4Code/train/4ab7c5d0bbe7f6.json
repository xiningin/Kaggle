{"cell_type":{"f55a87f3":"code","ac5446bf":"code","735324e7":"code","4d9ff819":"code","5e35bae9":"code","3009571f":"code","9d369229":"code","d18dcac7":"code","e50f1289":"code","369c0f2a":"code","d3d774e5":"code","6e7618e9":"code","1ac7d30f":"code","c8bbb13f":"code","576eb450":"code","c490577a":"code","deddd1e4":"code","c57bc3aa":"code","e256cb5f":"code","a71c1626":"code","f3392a05":"code","152a72f2":"code","0886c622":"code","bf816d70":"code","2d072f97":"code","0990e450":"code","8a01aeee":"code","1623f47e":"code","50f17369":"code","e49af985":"code","6f2c7f8e":"code","493ed3b3":"code","40625af9":"code","793ebf84":"code","3585d6e5":"code","5bc88b4c":"code","ee156629":"code","4f4107b4":"code","73153cd1":"code","46277f5a":"code","2a19486f":"markdown"},"source":{"f55a87f3":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# for visualization\nfrom matplotlib import pyplot as plt\n# to include graphs inline within the frontends next to code\nimport seaborn as sns\n\n# preprocessing functions and evaluation models\nfrom sklearn.preprocessing import OneHotEncoder, MinMaxScaler, StandardScaler\nfrom sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV,RandomizedSearchCV\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom sklearn.dummy import DummyClassifier\n\n# machine learning models\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier,ExtraTreesClassifier\nfrom xgboost import XGBClassifier","ac5446bf":"train = pd.read_csv(\"\/kaggle\/input\/forest-data\/Forest_Cover_participants_Data\/train.csv\")\ntest = pd.read_csv(\"\/kaggle\/input\/forest-data\/Forest_Cover_participants_Data\/test.csv\")\nsub = pd.read_csv(\"\/kaggle\/input\/forest-data\/Forest_Cover_participants_Data\/sample_submission.csv\")","735324e7":"train.head()","4d9ff819":"test.head()","5e35bae9":"train = train.rename(columns={\n    \"Elevation(meters)\":\"Elevation\",\n    \"Aspect(degrees)\":\"Aspect\",\n    \"Slope(degrees)\":\"Slope\",\n    \"Horizontal_Distance_To_Hydrology(meters)\":\"Horizontal_Distance_To_Hydrology\",\n    \"Vertical_Distance_To_Hydrology(meters)\":\"Vertical_Distance_To_Hydrology\",\n    \"Horizontal_Distance_To_Roadways(meters)\":\"Horizontal_Distance_To_Roadways\",\n    \"Horizontal_Distance_To_Fire_Points(meters)\":\"Horizontal_Distance_To_Fire_Points\"\n    \n})\ntest = test.rename(columns={\n    \"Elevation(meters)\":\"Elevation\",\n    \"Aspect(degrees)\":\"Aspect\",\n    \"Slope(degrees)\":\"Slope\",\n    \"Horizontal_Distance_To_Hydrology(meters)\":\"Horizontal_Distance_To_Hydrology\",\n    \"Vertical_Distance_To_Hydrology(meters)\":\"Vertical_Distance_To_Hydrology\",\n    \"Horizontal_Distance_To_Roadways(meters)\":\"Horizontal_Distance_To_Roadways\",\n    \"Horizontal_Distance_To_Fire_Points(meters)\":\"Horizontal_Distance_To_Fire_Points\"\n    \n})","3009571f":"train.info()","9d369229":"train.isna().sum()","d18dcac7":"train.describe()","e50f1289":"train.nunique()","369c0f2a":"def outlier_function(df, col_name):\n    ''' this function detects first and third quartile and interquartile range for a given column of a dataframe\n    then calculates upper and lower limits to determine outliers conservatively\n    returns the number of lower and uper limit and number of outliers respectively\n    '''\n    first_quartile = np.percentile(np.array(df[col_name].tolist()), 25)\n    third_quartile = np.percentile(np.array(df[col_name].tolist()), 75)\n    IQR = third_quartile - first_quartile\n                      \n    upper_limit = third_quartile+(3*IQR)\n    lower_limit = first_quartile-(3*IQR)\n    outlier_count = 0\n                      \n    for value in df[col_name].tolist():\n        if (value < lower_limit) | (value > upper_limit):\n            outlier_count +=1\n    return lower_limit, upper_limit, outlier_count\n","d3d774e5":"# loop through all columns to see if there are any outliers\nfor i in train.columns:\n    if outlier_function(train, i)[2] > 0:\n        print(\"There are {} outliers in {}\".format(outlier_function(train, i)[2], i))\n\n","6e7618e9":"trees = train[(train['Horizontal_Distance_To_Fire_Points'] > outlier_function(train, 'Horizontal_Distance_To_Fire_Points')[0]) &\n              (train['Horizontal_Distance_To_Fire_Points'] < outlier_function(train, 'Horizontal_Distance_To_Fire_Points')[1])]\ntrees.shape\n","1ac7d30f":"size=10\nUni = []\nfor i in range(size+1,len(train.columns)-1):\n    Uni.append(pd.unique(train[train.columns[i]].values))","c8bbb13f":"Uni","576eb450":"\n\nplt.figure(figsize=(15,10))\nsns.countplot(train['Cover_Type'])\nplt.xlabel(\"Type of Cover\", fontsize=12)\nplt.ylabel(\"Rows Count\", fontsize=12)\nplt.show()\n\n","c490577a":"fig, axes = plt.subplots(nrows = 2,ncols = 5,figsize = (25,15))\ng= sns.FacetGrid(train, hue='Cover_Type',height=5)\n(g.map(sns.distplot,train.columns[1],ax=axes[0][0]))\n(g.map(sns.distplot, train.columns[2],ax=axes[0][1]))\n(g.map(sns.distplot, train.columns[3],ax=axes[0][2]))\n(g.map(sns.distplot, train.columns[4],ax=axes[0][3]))\n(g.map(sns.distplot, train.columns[5],ax=axes[0][4]))\n(g.map(sns.distplot, train.columns[6],ax=axes[1][0]))\n(g.map(sns.distplot, train.columns[7],ax=axes[1][1]))\n(g.map(sns.distplot, train.columns[8],ax=axes[1][2]))\n(g.map(sns.distplot, train.columns[9],ax=axes[1][3]))\n# (g.map(sns.distplot, train.columns[10],ax=axes[1][4]))\nplt.close(2)\nplt.legend()","deddd1e4":"#Convert dummy features back to categorical\nx = train.iloc[:,15:55]\ny = train.iloc[:,11:15]\ny = pd.DataFrame(y)\nx = pd.DataFrame(x)\ns2 = pd.Series(x.columns[np.where(x!=0)[1]])\ns3 = pd.Series(y.columns[np.where(y!=0)[1]])\ntrain['soil_type'] = s2\ntrain['Wilderness_Area'] = s3\ntrain.head()\n","c57bc3aa":"train.columns","e256cb5f":"df_viz = train.iloc[:, 0:15]\ndf_viz = df_viz.drop(['Wilderness_Area_1', 'Wilderness_Area_2', 'Wilderness_Area_3', \n                      'Wilderness_Area_4'], axis = 1)\ndf_viz.head()\n","a71c1626":"plt.figure(figsize=(15,10))\npd.crosstab(train.Wilderness_Area, train.Cover_Type).plot.bar(figsize=(10,10),stacked = True)\n\n","f3392a05":"corr = df_viz.corr()\n\n# plot the heatmap\nplt.figure(figsize=(14,12))\ncolormap = plt.cm.RdBu\nsns.heatmap(corr,linewidths=0.1, \n            square=False, cmap=colormap, linecolor='white', annot=True)\nplt.title('Pearson Correlation of Numeric Features', size=14)","152a72f2":"train.columns","0886c622":"train=trees","bf816d70":"def add_feature(data):   \n    data['Ele_minus_VDtHyd'] = data.Elevation-data.Vertical_Distance_To_Hydrology\n    data['Ele_plus_VDtHyd'] = data.Elevation+data.Vertical_Distance_To_Hydrology\n    data['Distanse_to_Hydrolody'] = (data['Horizontal_Distance_To_Hydrology']**2+data['Vertical_Distance_To_Hydrology']**2)**0.5\n    data['Hydro_plus_Fire'] = data['Horizontal_Distance_To_Hydrology']+data['Horizontal_Distance_To_Fire_Points']\n    data['Hydro_minus_Fire'] = data['Horizontal_Distance_To_Hydrology']-data['Horizontal_Distance_To_Fire_Points']\n    data['Hydro_plus_Road'] = data['Horizontal_Distance_To_Hydrology']+data['Horizontal_Distance_To_Roadways']\n    data['Hydro_minus_Road'] = data['Horizontal_Distance_To_Hydrology']-data['Horizontal_Distance_To_Roadways']\n    data['Fire_plus_Road'] = data['Horizontal_Distance_To_Fire_Points']+data['Horizontal_Distance_To_Roadways']\n    data['Fire_minus_Road'] = data['Horizontal_Distance_To_Fire_Points']-data['Horizontal_Distance_To_Roadways']\n    return data","2d072f97":"\n\ntrain = add_feature(train)\ntest = add_feature(test)\n\n","0990e450":"#X_train = train.drop(['Id','Cover_Type','soil_type','Wilderness_Area'], axis = 1)\nX_train = train.drop(['Cover_Type'], axis = 1)\ny_train = train.Cover_Type\n# X_test = test.drop(['Id'], axis = 1)","8a01aeee":"%%time \n\nlr_pipe = Pipeline(\n    steps = [\n        ('scaler', MinMaxScaler()),\n        ('classifier', LogisticRegression(solver='lbfgs', n_jobs=-1))\n    ]\n)\n\nlr_param_grid = {\n    'classifier__C': [1, 10, 100,1000],\n}\n\n\nnp.random.seed(1)\ngrid_search = GridSearchCV(lr_pipe, lr_param_grid, cv=5, refit='True')\ngrid_search.fit(X_train, y_train)\n\nprint(grid_search.best_score_)\nprint(grid_search.best_params_)","1623f47e":"%%time \n\nrf_pipe = Pipeline(\n    steps = [\n        ('classifier', RandomForestClassifier(n_estimators=500))\n    ]\n)\n\nparam_grid = {\n       'classifier__min_samples_leaf': [1,4,7],\n    'classifier__max_depth': [34,38,32],\n}\n\nnp.random.seed(1)\nrf_grid_search = GridSearchCV(rf_pipe, param_grid, cv=5, refit='True', n_jobs=-1)\nrf_grid_search.fit(X_train, y_train)\n\nprint(rf_grid_search.best_score_)\nprint(rf_grid_search.best_params_)","50f17369":"rf_model = rf_grid_search.best_estimator_\n\ncv_score = cross_val_score(rf_model, X_train, y_train, cv = 5)\nprint(cv_score)\nprint(\"Accuracy: %0.2f (+\/- %0.2f)\" % (cv_score.mean(), cv_score.std() * 2))","e49af985":"rf = rf_grid_search.best_estimator_.steps[0][1]","6f2c7f8e":"\n\nfeat_imp = rf.feature_importances_\nfeat_imp_df = pd.DataFrame({\n    'feature':X_train.columns,\n    'feat_imp':feat_imp\n})\n\nfeat_imp_df.sort_values(by='feat_imp', ascending=False).head(10)\n\n","493ed3b3":"\n\nsorted_feat_imp_df = feat_imp_df.sort_values(by='feat_imp', ascending=True)\nplt.figure(figsize=[6,6])\nplt.barh(sorted_feat_imp_df.feature[-20:], sorted_feat_imp_df.feat_imp[-20:])\nplt.show()\n\n","40625af9":"%%time \n\nxgd_pipe = Pipeline(\n    steps = [\n        ('classifier', XGBClassifier(n_estimators=50, subsample=0.5))\n    ]\n)\n\nparam_grid = {\n    'classifier__learning_rate' : [0.45],\n    'classifier__min_samples_split' : [8, 16, 32],\n    'classifier__min_samples_leaf' : [2],\n    'classifier__max_depth': [15]\n    \n}\n\nnp.random.seed(1)\nxgd_grid_search = GridSearchCV(xgd_pipe, param_grid, cv=5,\n                              refit='True', verbose = 10, n_jobs=-1)\nxgd_grid_search.fit(X_train, y_train)\n\nprint(xgd_grid_search.best_score_)\nprint(xgd_grid_search.best_params_)","793ebf84":"xgd_model = xgd_grid_search.best_estimator_\n\ncv_score = cross_val_score(xgd_model, X_train, y_train, cv = 5)\nprint(cv_score)\nprint(\"Accuracy: %0.2f (+\/- %0.2f)\" % (cv_score.mean(), cv_score.std() * 2))\n","3585d6e5":"%%time\n\n\nxrf_pipe = Pipeline(\n    steps = [\n        ('classifier', ExtraTreesClassifier(n_estimators=500,random_state=0, criterion = 'entropy'))\n    ]\n)\n\n\nxrf_param_grid = {\n    'classifier__min_samples_leaf': [1,4,7],\n    'classifier__max_depth': [34,38,32],\n}\n\nnp.random.seed(1)\nxrf_grid_search = GridSearchCV(xrf_pipe, xrf_param_grid, cv=5, refit='True', n_jobs=-1)\nxrf_grid_search.fit(X_train, y_train)\n\nprint(xrf_grid_search.best_score_)\nprint(xrf_grid_search.best_params_)\n\n","5bc88b4c":"xrf_model = xrf_grid_search.best_estimator_\n\ncv_score = cross_val_score(xrf_model, X_train, y_train, cv = 5)\nprint(cv_score)\nprint(\"Accuracy: %0.2f (+\/- %0.2f)\" % (cv_score.mean(), cv_score.std() * 2))\n","ee156629":"final_model = xrf_grid_search.best_estimator_.steps[0][1]\nfinal_model.fit(X_train, y_train)","4f4107b4":"y_pred = final_model.predict_proba(test)","73153cd1":"s=pd.DataFrame(y_pred)\ns[s<0.05]=0\ns[s>0.95]=1\ns = np.round(s,1)\nprint(s.head())","46277f5a":"s.to_csv(\"first_submission.csv\")","2a19486f":"The Distribution is not uniform in this case"}}