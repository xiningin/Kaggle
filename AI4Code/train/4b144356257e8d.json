{"cell_type":{"3fa4bde3":"code","d1270f45":"code","736955f5":"code","ccbe2475":"code","9328bab9":"markdown","1b4fb58f":"markdown"},"source":{"3fa4bde3":"from matplotlib.pyplot import axes, close, cm, figure, savefig, show, title\nfrom pydicom           import dcmread\nfrom os                import sep, listdir, walk\nfrom os.path           import join, normpath\nfrom pandas            import read_csv\nfrom re                import match\n","d1270f45":"# Study\n#\n# This class represents a study for one patient\n#\nclass Study:\n    # Series\n    #\n    # Each Study comprises several (in practic 4) Series\n    class Series:\n        def __init__(self,name):\n            self.name             = name\n            self.missing_images   = set()\n            self.dirpath          = None\n            self.image_plane      = None\n            self.description      = None\n            self.patient_position = None\n\n        # add_images\n        #\n        # Add a collection of images to Series\n\n        def add_images(self,dirpath,filenames):\n            def extract_digits(s):\n                m = match(r'\\D*(\\d+)\\D+',s)\n                if m:\n                    return int(m.group(1))\n\n            self.dirpath          = dirpath\n            seqs                  = sorted([extract_digits(name) for name in filenames])\n            self.N                = seqs[-1]\n            self.missing_images   = set([i for i in range(1,self.N) if i not in seqs])\n            dcim                  = dcmread(join(dirpath,filenames[0]))\n            self.image_plane      = self.get_image_plane(dcim.ImageOrientationPatient)\n            self.description      = dcim.SeriesDescription\n            self.patient_position = dcim.PatientPosition\n\n        # dcmread\n        #\n        # A generator to iterate through all the images.\n        #\n        # parameters:\n        #     stop_before_pixels    Used if we just want to analyze metadata\n\n        def dcmread(self, stop_before_pixels = False):\n            for i in range(1,len(self)+1):\n                if i not in self.missing_images:\n                    yield  dcmread(join(self.dirpath,f'Image-{i}.dcm'), stop_before_pixels = stop_before_pixels)\n\n        # get_image_plane\n        #\n        # Snarfed from https:\/\/www.kaggle.com\/davidbroberts\/determining-mr-image-planes\n        def get_image_plane(self,loc):\n            row_x = round(loc[0])\n            row_y = round(loc[1])\n            row_z = round(loc[2])\n            col_x = round(loc[3])\n            col_y = round(loc[4])\n            col_z = round(loc[5])\n\n            if row_x == 1 and row_y == 0 and col_x == 0 and col_y == 0:  return \"Coronal\"\n\n            if row_x == 0 and row_y == 1 and col_x == 0 and col_y == 0:  return \"Sagittal\"\n\n            if row_x == 1 and row_y == 0 and col_x == 0 and col_y == 1:  return \"Axial\"\n\n            return \"Unknown\"\n\n        def __len__(self):\n            return self.N\n\n        # image_files\n        #\n        # Generator for iterating through image files\n\n        def image_files(self):\n            for i in range(1,self.N+1):\n                if i not in self.missing_images:\n                    yield join(self.dirpath,f'Image-{i}.dcm')\n\n    def __init__(self,name,path):\n        self.series        = None\n        self.name          = name\n        for dirpath, dirnames, filenames in walk(path):\n            if self.series == None:\n                self.series = {series_name: Study.Series(series_name) for series_name in dirnames}\n            else:\n                path_components = normpath(dirpath).split(sep)\n                series = self.series[path_components[-1]]\n                series.add_images(dirpath,filenames)\n\n    def get_series(self):\n        for name in ['FLAIR', 'T1w', 'T1wCE', 'T2w']:\n            yield self.series[name]\n\n    def get_image_planes(self):\n        def get_image_plane(series):\n            path_name   = next(series.image_files())\n            dcim        = dcmread(path_name,stop_before_pixels=True)\n            return  series.get_image_plane(dcim.ImageOrientationPatient)\n        return [get_image_plane(series)  for series in self.series.values()]\n\n    def __str__(self):\n        return self.name\n\n# MRI_Dataset\n#\n# An MRI Dataset comprises sevral stidies, either test or training\n\nclass MRI_Dataset:\n    def __init__(self,path,folder):\n        self.studies = {name:Study(name,join(path,folder,name)) for name in listdir(join(path,folder))}\n\n    def get_studies(self):\n        for study in self.studies.values():\n            yield study\n\n# Labelled_MRI_Dataset\n#\n# A Labelled_MRI_Dataset is a MRI_Dataset accompanied by labels for training\n\nclass Labelled_MRI_Dataset(MRI_Dataset):\n\n    def __init__(self,path,folder,labels='train_labels.csv'):\n        super().__init__(path,folder)\n        self.labels = read_csv(join(path,labels),dtype={'BraTS21ID':str})","736955f5":"# get_values_from_meta\n#\n# Convert meta data (list of tuples of ASCII data) to a list of data\n# sequences, each being the time series for one datum\n\ndef get_values_from_meta(orbit):\n    return [[float(a) for a in p] for p in list(zip(*orbit))]\n\n# plot_orbit\n#\n# Show how the patient moves through the MRI instrument during one Study\n\ndef plot_orbit(study):\n    fig       = figure(figsize=(20,20))\n    ax        = axes(projection='3d')\n\n    for series in study.get_series():\n        orbit = []\n        sizes = []\n        for dcim in series.dcmread():\n            orbit.append(dcim.ImagePositionPatient)\n            sizes.append(10 if dcim.pixel_array.sum()> 0 else 1)\n        ax.scatter(*get_values_from_meta(orbit),\n                   label = f'{dcim.SeriesDescription}: {dcim.PatientPosition} {series.get_image_plane(dcim.ImageOrientationPatient)}',\n                   s     = sizes)\n\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n    title(dcim.PatientID)\n    ax.legend()\n    savefig(dcim.PatientID)\n    return fig\n","ccbe2475":"path = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification'\ntraining = Labelled_MRI_Dataset(path,'train')\nwith open('unique.csv','w') as out:\n    for study in training.get_studies():\n        image_planes = study.get_image_planes()\n        if len(set(image_planes))==1:\n            print (study, image_planes[0])\n            out.write(f'{study}, {image_planes[0]}\\n')\n            fig = plot_orbit(study)\n            close(fig)","9328bab9":"# Image Planes\n\nThis notebook finds studies whose series all share the same image plane. It produces two sets of output:\n1. A list of study IDs that have all 4 planes identical.\n1. For each study in the list, a plot of the \"orbit\" that each patient follows.\n\nSee also [David Roberts' notebook](https:\/\/www.kaggle.com\/davidbroberts\/rsna-brain-tumor-image-planes\/comments)\n\nI would expect orbits to be parallel if they are in the same plane, but this isn't always true, as shown here.![00098](https:\/\/www.kaggleusercontent.com\/kf\/68577251\/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..57ixQ1Ar7KBK3hwjvpxf7A.eXaHTiBHgAjhmlJfzGV_yZFc57CxYh9x8jwrKV8PhVFPMp160yNMvdbmOfvTTFr4dB_B52UQxWcQ_MGWgZk1m6qnL2q1qPxN5c01nbDRl5qvrlZO9adxgevdoOjESrbtYesSc_PO5uMEBjOptAG6prpsG8vnuRKMCDk0oGxSTHc3yeW_pIFAkBZRcy5soJQgNp9AWVPI-pttSRe9HH9sgnUpZcHHWcMAcLl9dajDF7-slro0drBiwaVWNEAWrfepex6kp_CZprCkcErJ5EwXOVOVp8kImBaMVnzpawnRYj5Wa-sbO3-H_GjUdUDh87ctB90_f-ct386ijCKb7hJiVPfyk2af3ipUD1UjrM7hucsGHXOGOHCAJrnk3lLusIqZtDscV0105EZZvnEZhTbnbF6KhV8EBH85ByqBG2BmunPaFUI4iIwY3IYjH7033_QH4en_CidOaF1qwmGUjzHMkxK8QBbGsvGvLtmpPpGUcFW9VxB4d7ZEztMgTs0rmbispIA4FEg2tAP-LOis3EQghR0-hx0tMFgb8QIG2_WV5jwp7q9vRCGc_a9ltdBarHkL6MdU6uW_71Yw5D5wNxBX_NIF4XckcnpdEmJzrwq0o36FBUCv4yqhh9ftITw3QWt0iXx5mDewobDhVzG-4ZtDQdwOg4OcqiY8-PI3VhaXnyM.TZpWwxtK40CvEfGYjqh_VQ\/00098.png)\n\n## A few useful imports","1b4fb58f":"## Classes to represent Studies and Datasets"}}