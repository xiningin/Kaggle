{"cell_type":{"fa38cae1":"code","360a49bc":"code","2af3bcde":"code","5b43bfe8":"code","2f8c272c":"code","798e2407":"code","b5223531":"code","33ab4daf":"code","0040d4bc":"code","7904014a":"code","ae387e3c":"code","b43adfb5":"code","e1e56c80":"code","c6b863db":"code","5fa7784f":"code","bc10bed7":"code","083a3a8d":"code","cd8e97cc":"code","d4ecd991":"code","247a7a4c":"code","791f1264":"markdown","09da2253":"markdown","d17256de":"markdown","07de1515":"markdown","07be4d0d":"markdown","91e9686b":"markdown","976da00b":"markdown","42e1d654":"markdown","b45a745c":"markdown","7e9045cb":"markdown","6929242e":"markdown","cf16d550":"markdown","ee48b981":"markdown","b3f08ebc":"markdown","0719f9a7":"markdown"},"source":{"fa38cae1":"import numpy as np","360a49bc":"# Univariate Array Creation \nlst = [1,2,6,10]\narray = np.array(lst)\ndisplay(lst)\n\n# Mulivariate Array Creation\nnested_lst = [[10,23,1],[20,11,6]]\narray_nested = np.array(nested_lst)\ndisplay(array_nested)\n\n# Transformation into array\ndata = ['1','2','3']\narray = np.asarray(data, dtype = np.float32 )\ndisplay(array)\n\n# Array with only ones creation\nones = np.ones((3,3))\ndisplay(ones)\n\n# Array with only zeroes creation\nzeros = np.zeros((3,3))\ndisplay(zeros)\n\n# Empty Array Creation\nempty = np.empty((3,3))\ndisplay(empty)\n\n# Emty_like\narray = np.arange(5)\nempty = np.empty_like(array)\ndisplay(empty)\n\n# Zeroes_like\narray = np.ones((2,2))\nzeroes = np.zeros_like(array)\ndisplay(zeroes)\n\n# Identity\nidentity = np.identity(3)\ndisplay(identity)\n\n# Eye\neye = np.eye(3,3)\ndisplay(eye)","2af3bcde":"# Initial 3D array\narr = np.random.randint(0,100,(3,4,3))\n\ndisplay(arr.ndim,\n        arr.shape,\n        arr.ravel(),\n        arr.reshape(3,-1,2))","5b43bfe8":"array = np.arange(10)\nprint('Original array:'+str(array))\n\n# Slicing Demonstration\ndisplay(array[5:])\ndisplay(array[5:8])\n\n# Important note!\narray_slice = array[1:4]\nprint('Original slice :'+str(array_slice))\narray_slice[1:] = 1000\nprint('Modified slice: '+str(array_slice))\n# Slice is not copy. All changes in the sice will affect original array\nprint('Original array:'+str(array))","2f8c272c":"# 2D Array\narr = np.array([[1,2,3],[4,5,6],[7,8,9]])\n\n# Simple Selection\nprint(arr[2])\nprint(arr[1,1])\nprint(arr[1][1])\nprint('\\n')\n\n# 2D Array Slicing \nprint(arr[1:,1:])\nprint('\\n')\nprint(arr[:,1:])","798e2407":"# 3D Array. It has dimension 2x2x3\narr = np.array( [ [[1,2,3],[4,5,6]],\n                [[7,8,9],[10,11,12]] ])\nprint(arr)\nprint(arr.shape)\nprint(arr[0][0][1])\nprint(arr[1][0][1])","b5223531":"names = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])\ndata = np.random.randn(names.shape[0],4)\n\nprint(names == 'Bob')\nprint('\\n')\ncondition = names == 'Bob'\n# Now, according to above condition we will select rows with True condition \nselection = data[condition]\nprint(selection)\nprint('\\n')\nnew_sel = selection[0,:] \nnew_sel = 0\nprint(new_sel)\nprint('\\n')\nprint('Original Slice: '+str(selection))","33ab4daf":"# Set values below zero to zero \ndata[data<0]= 0\ndata","0040d4bc":"arr = np.arange(32).reshape(8,4)\narr","7904014a":"# Rows Selection \n\nprint(arr[[0,2,4,6]])\nprint('\\n')\n\nprint(arr[ [1,5,7,2],[0,3,1,2] ]) \nprint('\\n')\n\nprint(arr[[1,5,7,2]][:,[0,3,1,2]])\nprint('\\n')\n\nprint(arr[np.ix_([1,5,7,2],[0,3,1,2])])","ae387e3c":"arr = np.arange(12).reshape(2,6)\nprint(arr)\nprint('\\n')\nprint(arr.T)","b43adfb5":"matrx_1 = np.arange(15).reshape(3,5)\nmatrx_2 = np.random.randn(5,3)\ndisplay(matrx_1)\ndisplay(matrx_2)","e1e56c80":"arr = np.arange(16).reshape((2,2,4))\narr","c6b863db":"# Arrays Creation \narr_1 = np.arange(8).reshape(2,4)\narr_2 = np.arange(30,38).reshape(2,4)\n\n# Concatenate along rows (axis = 0)\ncon_row_arr = np.concatenate([arr_1, arr_2])\n\n# Concatenate along columns (axis = 1)\ncon_col_arr = np.concatenate([arr_1, arr_2],axis=1)\n\n# vstack\nv_stacked_arr = np.vstack([arr_1, arr_2])\n\n# hstack \nh_stacked_arr = np.hstack([arr_1, arr_2])\n\n# dstack\nd_stacked_arr = np.dstack([arr_1, arr_2])\n\ndisplay(con_row_arr,con_col_arr,\n        v_stacked_arr,h_stacked_arr,d_stacked_arr)","5fa7784f":"# vsplit\nupper, lower = np.vsplit(v_stacked_arr,2)\nprint(f'Upper array is:\\n {upper}\\n Lower array is:\\n {lower}')\nprint('\\n')\n\n# hsplit\nleft, right = np.hsplit(v_stacked_arr,2)\nprint(f'Upper array is:\\n {left}\\n Lower array is:\\n {right}')\nprint('\\n')\n\n# Can split not only by a number but by necessary sequence\narr = np.arange(10).reshape(2,5)\nleft, centred, right = np.hsplit(arr,[2,4])\nprint(f'Left array is:\\n {left}\\n Centred array is:\\n{centred}\\n Right array is:\\n{right}')\nprint('\\n')\n\n# dsplit \ninner, outer = np.dsplit(d_stacked_arr,2)\nprint(f'Inner array is:\\n {inner}\\n Outer array is:\\n {outer}')","bc10bed7":"# Create a row vector from an array using reshape\narr = np.array([1,2,3])\nrow_vec = arr.reshape(1,3)\ndisplay(arr.shape,row_vec.shape)\n\n# Create a row vector from an array using new axis\nrow_vec = arr[np.newaxis,:]\ndisplay(row_vec.shape)\n\n# Create a column vector from an array \ncol_vec = arr.reshape(3,1)\ndisplay(col_vec.shape)\n\n# Create a column vector from an array  using new axis\ncol_vec = arr[:,np.newaxis]\ndisplay(col_vec.shape)","083a3a8d":"# Reduce\narr = np.arange(1,11)\nprint(np.multiply.reduce(arr))\n\n# accumulate\nprint(np.add.accumulate(arr))\n\n# sum, prod, cumsum, cumprod\ndisplay(np.sum(arr),\n        np.prod(arr),\n        np.cumsum(arr),\n        np.cumproduct(arr))","cd8e97cc":"arr_1 = np.arange(4)\narr_2 = np.arange(4)[:,np.newaxis]\nbrdcs_arr = arr_1 + arr_2\nprint(f'First array shape: {arr_1.shape}\\nSecond array shape:{arr_2.shape}'+'\\n'+\n      f'Broadcasting result:\\n{brdcs_arr}\\nFinal Shape:{brdcs_arr.shape}')","d4ecd991":"arr = np.random.randint(0,101,10)\n\nindx_1 = [5,4,0,1] # the first shape\nindx_2 = np.random.randint(0,6,(3,2)) # the second shape\n\ndisplay(arr[indx_1],arr[indx_2])","247a7a4c":"arr = np.random.randint(0,101,(3,4))\n# The first shape\nrows_1 = [0,2,1,2,0]\ncols_1 = [1,3,2,1,3]\n# The second shape\nrows_2 = np.random.randint(0,3,(3,3))\ncols_2 = np.random.randint(0,4,(3,3))\ndisplay(arr[rows_1,cols_1],arr[rows_2,cols_2])","791f1264":"### NumPy \nNumPy a library for high - productive scientific calculations and data analysis. It provides fast vector operations for data cleaning and reflowing, set selection, different transformations and others.\n\nKey element in NumPy is **ndarray object** which represents n - dimensional array. Ndarray is fast and flexible container for huge datasets storage. Arrays allows to execute different operations on whole data blocks as well as scalars. \n\n**Ndarray can store only one data type**\n\n### Array Creation\n- ```np.array( list )``` - creates a NumPy 1D array from a list\n- ```np.array( nested_list )``` - creates a multivariate array\n- ```np.arange( shape )``` - like range bur returns an array\n- ```np.linspace( interval )``` - returns evenly spaced numbers over a specified interval: start (inc) stop (inc) + step\n- ```np.asarray( data, dtype )``` transforms given data into ndarray object\n- ```np.full( shape , scalar)``` - creates an array with given shape filled with provided scalar value\n- ```np.zeros( shape )``` - creates an array with zeroes\n- ```np.ones ( shape )``` - creates an array with ones\n- ```np.emty ( shape )``` - creates an empty array, not necessearily zeroes\n- ```np.emty_like( arr )``` - takes another array,takes into account its dimension and creates an empty array with the dimension \n- ```np.ones_like( arr )``` - similar to np.emty_like ( )\n- ```np.eye( shape )``` - creates 2d array with one on the main diagonal \n- ```np.identity( shape )``` - creates 2d array with one on the main diagonal \n- ```arr[ np.newaxis, : ]``` - creates a row vector using 1D array\n- ```arr[ : , np.newaxis ]``` - creates a column vector using 1D array \n\n### Array Creation using Random\nThere are some differences between methods in this module which must be known\n- ```np.random.rand( shape )``` - random samples from Normal Distribution in range 0 (inc) - 1 (excl)\n- ```np.random.randint( shape )``` - random integers from low (inc), high (exc)\n- ```np.random.randn( shape )``` - random samples from Normal Distribution with mean = 0 and std = 1\n- ```np.random.normal( shape )``` - random samples from Normal Distribution where mean and std can be customized\n- ```np.random.random( shape )``` - similar to np.random.rand( )\n- ```np.random.choice( arr, size )``` - randomly selects samples from 1D array according to provided size\n\n### Array Data Types\n```dtype``` is a special object which contains necessary information of ndarray for data interpretation.\n\nEach array** can have **only one data type**\n\nAll available types can be obtained from the following command: **np.ctypes( )** - list all types\n- ```int8, uint8``` -   1byte, 8 digit postions (unsigned takes only positive values)\n- ```int16, uint16``` - 2 bytes, 16 digit postitions\n- ```int32, uint32``` - 4 bytes, 32 digit positions\n- ```int64, uint64``` - 8 bytes, 64 digit positions\n- ```float16``` - half - precision - floating - point\n- ```float32``` - one precision - floating point\n- ```float64``` - double precision - floating - point \n- ```float128``` - Extended precision floating point\n- ```complex64,128,256``` - complex numbers\n- ```bool``` - True\/False\n- ```string_``` - string type with fixed length \n- ```unicode_``` -unicode type for strings with fixed length \n\nSome methods:\n- ```arr.dtype``` - returns data type  \n- ```arr.astype( type )``` changes a type of an array\n\n### Array Indexation\n**1D Array** <br>\nBehaves like an ordinary list. Indexation is the same. All slicing of an array are **views**!!\n\n**Views are not copies, thus any changes in views changes original array. It is very important**\n- ```arr[ : : ]``` - only rows slicing \n\n**2d Array** <br>\nHas 2 dimensions 0 - axis (rows), 1 - axis (columns)\n- ```arr[ : :, : : ]``` - rows and columns slicing\n\n**3D Array**<br>\nHas 3 dimensions depth (how many arrays to choose), rows and columns\n- ```arr[ : :,: :, : : ]``` - depth, rows and columns slicing \n\nFor Multidimensional arrays number of axes is proportional to the dimension \n\n### Bool Indexation \nReturns a result accoridng to a provided condition. **Always returns a copy**. This method is also called boolean masks.\nIt is interresting but when we provide a statement, for example x < 3, NumPy interpretes it as np.less(x, 3). Thus, it operates **ufunctions** inside.\n\nOperators are: & (and) | (or) ^ (xor) ~ (not) and they operate seprate bits inside **each object** whereas and,or,xor operate on the whole object\n- ```arr[ condition ]``` \n- ```np.where( condition, val_1, val_2 )``` - substitute values according to specified condition. If True val_1, otherwise val_2\n- ```np.count_nonzero( condition )``` - can be used to count number of True statements. np.sum() is more preferable\n- ```np.all \/ any ( )``` - checks if all or any elements are True\n\n\n### Fancy Indexing \nThe main difference is that it takes an **array of indexes** and final shape will be equal to the shape of indexes array.\n**Always creates a new array**\n1D Array:\n- ```arr[ arr( indexes ) ]``` - selects elemetns according to provided array of indexes.\n2D Array:\n- ```arr[ arr( rows_idxs ), arr( columns_idxs ) ]``` - selects elements according to the following combination (row_idx,col_idx)...\nFancy Indexing can be combined with ordinary indexes\n- ```arr[ indx, arr( indxs ) ]``` - selects elements according to the following combination (indx, arr[0]), (indx,arr[1])...\n\n\n- ```arr[ [rows_idxs ] ] [:, [ cols_idxs ] ]``` - combination is different (row_1,col_1), (row_1,col_2)...\n- ```arr[ np.ix_( [ rows_idxs ], [ cols_idxs ] )]``` similar to above method\n\n### Array Dimension and Memory Methods \n- ```arr.shape``` - returns shape \n- ```arr.ndim``` - returns dimension of an array \n- ```arr.size``` - returns number of variables in an array\n- ```arr.T``` - transposes an array \n- ```arr.reshape( )``` - reshapes an array. If one of the axes equals **-1** then appropriate shape will be computed aoutomatically\n- ```arr.ravel( arr )``` - flattens an array of any dimension into 1D array\n- ```np.swapaxes( )``` - swaps two axes \n- ```arr.itemsize( )``` - returns how much **each array elemet** takes up memory in bytes\n- ```arr.nbytes( )``` - returns how much the whole array takes up memory in bytes\n\n### Array Cloning \/ Copying\n- ```np.copysign( signs )``` - copies signs from a provided array\n- ```np.repeat( arr, times )``` - returns 1D array from an array of any dimension where each element will be repeated according to times param \n- ```arr.copy( )``` - copies an array\n\n### Array Unification Methods\n- ```np.stack( arrays )``` - stacks several arrays into a big one \n- ```np.concatenate( [ arrays ], axis )``` concatenates several arrays\n- ```np.vstack( [ arrays ] )``` concatenates along columns (1 axis )\n- ```np.hstack( [ arrays ] )``` - concatenates along rows ( 0 axis )\n- ```np.dstack( [ arrays ] )``` - concatenates along depth or 3d axis ( 2 axis ) \n\n### Array Splitting Methods \n- ```np.split( arr, axis )``` - splits an array into multiple sub-arrays according to provided axis\n- ```np.hsplit( arr )``` - splits an array into multiple sub-arrays horizontally (column-wise, axis = 1) \n- ```np.vsplit( arr )``` - splits an array into multiple sub-arrays vertically (row-wise, axis = 0) \n- ```np.dsplit( arr )``` - splits an array into multiple sub-arrays along the 3d axis ( depth )\n\n### Array Values and Comparison\n- ```np.isin( )``` - checks if values from one array are presented in another (similar to ```np.in1d()```)\n- ```np.unique(arr)``` - returns only unique values, (parameter ```return_counts``` counts occurences of array values)\n\n### Array Sorting\n- ```arr.sort( )``` - sorted array\n- ```np.searchsorted( arr , values)``` - returns indexes of where elements should be inserted to maintain array order \n- ```np.sort( arr, axis )``` - sorts an array. It uses quicksort by default, complexity O[NlogN]. Axis = 0 sorts by columns\n- ```np.argsort( arr )``` - returns indexes of sorted array \n- ```np.partition( arr, val_indx )``` - read docum\n\n### Transpose\nIt changes the form of matrix\n- ```arr.T``` - transpose operation\n- ```arr.transpose()``` - transpose oeration\n- ```np.dot( mtrx_1, matrx_2 )``` - dot product of 2 matrices\n\n### Ufunctions\nCycles in Python are incredibly slow. This is due to the fact that data type of a result of any operation must be checked before saving. This leads to slowness. Luckily, NumPy arrays must have a certain data type when initializing and data is vectorized.\nVector operations in NumPy are realized by **universal functions ufunc**. \nThese functions executes element-wise operations, incredibly fast and can be applied to arrays of any dimension.\nThere are several types of **ufunctions** **unary** and **binary**\n\nMathematical operations such as: **+,-,*,\/,\/\/** are **binary** (element - wise)\n- ```np.add \/ substract \/ multiply \/ devide( arr, value, out )``` - out can be used to save the results in a created array instead of temporary, **it saves memory**\n- ```np.floor_divide( )``` - similart to a \/\/ b\n- ```np.maximum( x, y )``` - element - wise comparison between arrays\n- ```np.ufunc.reduce( arr )``` - reduces dimension by one, by applying ufunc along one axis (dim - 1)\n- ```np.ufunc.accumulate( arr)``` - accumulates the result of applying the ufunc to all elements\n- ```np.cumsum( arr )``` - returns the cumulative sum of the elements along a given axis\n- ```np.cumprod( arr )``` - returns the cumulative product of the elements along a given axis\n- ```np.ufunc.outer( arr_1, arr_2 )``` - applies an ufunc to all pairs (a, b)\n- ```np.ufunc.at(array, indecies, value)``` - applies an ufunc for an array according to provided elements (indecies)\n\nSimple **unary** operations: sign change (-x), raising to the power and % \n- ```np.negative( arr )``` - changes signs\n- ```np.power( arr, value or list_of_powers )``` - raises an array to the given power or list of powers\n- ```np.mod( arr )``` - similar to a % b\n- ```np.abs( )``` - returns absolute value\n- ```np.absolute( )``` - similar to np.abs\n- ```np.square( )``` - computes square of each element\n- ```np.sqrt( arr )``` - square root\n\n- ```np.sign( )``` - returns sign of each elemet\n- ```np.exp( arr )``` - exponent of x\n- ```np.2exp( arr )``` - e^2x\n- ```np.sin \/ cos \/ tan( arr )``` - computes trigonometric functions of an array\n- ```np.log, log10, log2, log1p``` - understandable \n- ```np.ceil( )``` - round operation. Next whole number\n- ```np.floor( )``` - round operation \n- ```np.rint( )``` - rounds till the closest int \n- ```np.isnan( )``` - checks NaN values \n\n### Aggregation Functions\n- ```arr.sum \/ prod \/ mean \/ median \/ std \/ var ( axis )``` - typical operations.**Axis determines how values will be aggregated** . **axis = 0  is columns**\n- ```arr.min \/ max ( )``` - returns max and min element of an array\n- ```arr.argmin \/ argmax ( )``` - returns an index of min or max element \n- ```np.percentile( )``` - computes quantiles of the elements\n\n!! In order to not include **NaN values** provide nan before any of above commands. For example, **arr.nansum**\n\n### Array Broadcasting\nBroadcastig allows to apply binary operations such as addition,division and so on to arrays of different shape. For example, we want to add two arrays with different shape arr_1 (3,0) and arr_2 (3,3). In this case, we can imagine that arr_1 transforms into arr (3,3) with the same values in each row and then being added. Actually, transformation is not happening, it is just a convinience for our brain.\n\nThere are rules which must be followed:\n- If ```dimension``` of two arrays is different, array with less dimension is being brodcasted with the same values to the equal shape\n- If ```shape``` of two arrays is not equal, axis with less dimension is being extended till it mathces dimension of another array.","09da2253":"2D","d17256de":"### Fancy Indexing ","07de1515":"### Array Splitting ","07be4d0d":"### Bool Indexation ","91e9686b":"2D Array","976da00b":"### Array Indexation \n1D Array","42e1d654":"### Fancy Indexing\n1D","b45a745c":"### Array Dimensions Methods ","7e9045cb":"### Array broadcasting ","6929242e":"3D Array","cf16d550":"### Ufunctions\nBinary functions","ee48b981":"### Transpose","b3f08ebc":"### Arrays Unification","0719f9a7":"### Array Creation"}}