{"cell_type":{"decd250b":"code","64b88d6a":"code","425f19b1":"code","2122b186":"code","486a6c91":"markdown"},"source":{"decd250b":"import torch\nimport torch.nn as nn","64b88d6a":"VGG_types = {\n    'VGG11' : [64, 'M', 128, 'M', 256, 256, 'M', 512,512, 'M',512,512,'M'],\n    'VGG13' : [64,64, 'M', 128, 128, 'M', 256, 256, 'M', 512,512, 'M', 512,512,'M'],\n    'VGG16' : [64,64, 'M', 128, 128, 'M', 256, 256,256, 'M', 512,512,512, 'M',512,512,512,'M'],\n    'VGG19' : [64,64, 'M', 128, 128, 'M', 256, 256,256,256, 'M', 512,512,512,512, 'M',512,512,512,512,'M']\n}\nclass VGGnet(nn.Module):\n    def __init__(self, model, in_channels=3, num_classes=10, init_weights=True):\n        super(VGGnet,self).__init__()\n        self.in_channels = in_channels\n\n        # create conv_layers corresponding to VGG type\n        self.conv_layers = self.create_conv_laters(VGG_types[model])\n\n        self.fcs = nn.Sequential(\n            nn.Linear(1536, 1536\/\/2),\n            nn.ReLU(),\n            nn.Dropout(),\n            nn.Linear(1536\/\/2, 1536\/\/2),\n            nn.ReLU(),\n            nn.Dropout(),\n            nn.Linear(1536\/\/2, num_classes),\n        )\n\n        # weight initialization\n        if init_weights:\n            self._initialize_weights()\n\n    def forward(self, x):\n        x = self.conv_layers(x)\n        x = x.view(x.size(0), -1)\n        x = self.fcs(x)\n        return x\n\n    # defint weight initialization function\n    def _initialize_weights(self):\n        for m in self.modules():\n            if isinstance(m, nn.Conv3d):\n                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n                if m.bias is not None:\n                    nn.init.constant_(m.bias, 0)\n            elif isinstance(m, nn.BatchNorm3d):\n                nn.init.constant_(m.weight, 1)\n                nn.init.constant_(m.bias, 0)\n            elif isinstance(m, nn.Linear):\n                nn.init.normal_(m.weight, 0, 0.01)\n                nn.init.constant_(m.bias, 0)\n    \n    # define a function to create conv layer taken the key of VGG_type dict \n    def create_conv_laters(self, architecture):\n        layers = []\n        in_channels = self.in_channels # 3\n\n        for x in architecture:\n            if type(x) == int: # int means conv layer\n                out_channels = x\n\n                layers += [nn.Conv3d(in_channels=in_channels, out_channels=out_channels,\n                                     kernel_size=(3,2,3), stride=(1,1,1), padding=(1,1,1)),\n                           nn.BatchNorm3d(x),\n                           nn.ReLU()]\n                in_channels = x\n            elif x == 'M':\n                layers += [nn.MaxPool3d(kernel_size=(2,2,2), stride=(2,2,2))]\n        \n        return nn.Sequential(*layers)","425f19b1":"# define device\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n\n# creat VGGnet object\n# Choose between 'VGG11', 'VGG13', 'VGG16', 'VGG19'\nmodel = VGGnet('VGG16', in_channels=1, num_classes=1, init_weights=True).to(device)\nprint(model)","2122b186":"ex = torch.rand(3,1,32,32,32).to(device)\nout = model(ex)\nprint(out.size())","486a6c91":"# 3D VGGNet for binary classification\n\n![image.png](attachment:71cba00c-0fc4-4924-8a56-8e49c16f1b97.png)"}}