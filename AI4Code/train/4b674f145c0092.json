{"cell_type":{"7b0edc3e":"code","30b372fe":"code","09435694":"code","b90ea3d3":"code","c4af3f15":"code","232d2658":"code","d087a59a":"code","5d85add0":"code","c1ecda72":"code","597c25d6":"code","f9387c1a":"code","7c8aba92":"code","3c409bbc":"code","af481751":"code","6aed5aad":"code","10d23b0e":"code","163ccfc5":"code","1ee2e997":"code","4b586367":"code","0de627d8":"code","00d8d206":"code","68c4915d":"code","89850b29":"code","9e66bdfd":"code","21b835ee":"code","b0b3ecc3":"code","127ad1b0":"code","550783e3":"code","08b69449":"code","f09b4e7c":"code","b587095f":"code","0825a1da":"code","72451200":"code","4fd5ab86":"code","1806b895":"code","a3a503cc":"code","07e63be6":"code","2aa087b8":"code","1ca25620":"code","16c5938d":"code","e4785e47":"code","abd43f81":"code","1aae951f":"markdown","423953a7":"markdown","7dfbcb52":"markdown","ceb81293":"markdown","26b7e0d4":"markdown","7f79eca4":"markdown","e0ec13db":"markdown","c846f7d1":"markdown","57520359":"markdown","5cab186e":"markdown"},"source":{"7b0edc3e":"import os\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Dropout, Bidirectional\nfrom tensorflow.keras.metrics import MeanSquaredError\nimport seaborn as sns\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler, RobustScaler\n\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 'large',\n          'figure.titlesize': 'large',\n          'figure.figsize': (11, 8),\n         'axes.labelsize': 'large',\n         'axes.titlesize':'large',\n         'xtick.labelsize':'large',\n         'ytick.labelsize':'large'}\npylab.rcParams.update(params)\n","30b372fe":"os.listdir('..\/input\/cryptocurrencypricehistory')","09435694":"ROOT_PATH = '..\/input\/cryptocurrencypricehistory'","b90ea3d3":"coin_dataframes = dict()\n\ndef date_format(date_str):\n    return pd.to_datetime(date_str)\n\n\nfor fn in os.listdir(ROOT_PATH):\n    coin_name = fn.split(\"_\")[1][:-4]\n    df = pd.read_csv(os.path.join(ROOT_PATH, fn), parse_dates=['Date'], dayfirst=True)\n    df['Date'] = df['Date'].dt.strftime('%Y-%m-%d')\n    df = df.set_index('Date', drop=True)\n    coin_dataframes[coin_name] = df.sort_values('Date')","c4af3f15":"coin_dataframes['Bitcoin'].tail()","232d2658":"for key, data in coin_dataframes.items():\n    print(f\"Coin {key} with data's length: {data.shape[0]}\")","d087a59a":"#We will drop coin with size < 2000\nkeys = [k for k, v in coin_dataframes.items() if v.shape[0] < 2000]\nfor x in keys:\n    del coin_dataframes[x]\n    \nfor key, data in coin_dataframes.items():\n    print(f\"Coin {key} with data's length: {data.shape[0]}\")","5d85add0":"#Get 2160 most recent records for each coin. For synchronizing training_set\n\nfor key, data in coin_dataframes.items():\n    coin_dataframes[key] = coin_dataframes[key][-2160:]\n    \nfor key, data in coin_dataframes.items():\n    print(f\"Coin {key} with data's length: {data.shape[0]}\")","c1ecda72":"#Detect missing value\n\nfor key in coin_dataframes.keys():\n    print(f\"Coin {key} with total nan values:\\n{coin_dataframes[key].isna().sum()} \")","597c25d6":"\n# Percent Change Closing Price Per Day for each Coin\nfor coin in coin_dataframes.keys():\n    coin_dataframes[coin]['ClosePctChg'] = coin_dataframes[coin]['Close'].pct_change().fillna(0)\n    \nfor coin in coin_dataframes.keys():\n    plt.plot(coin_dataframes[coin]['ClosePctChg'], label=coin)\nplt.legend(loc=2)\nplt.title('Daily Percent Change of Closing Price')\nplt.show()","f9387c1a":"# See their correlation\ndata = pd.DataFrame()\n\nfor k, v in coin_dataframes.items():\n    data[k] = v['ClosePctChg']\n\ncorrmat = data.corr()\n\ncorrmat","7c8aba92":"#Plot the corrmat\nsns.heatmap(corrmat, annot=True);","3c409bbc":"coin_dataframes['Litecoin'].describe()","af481751":"#Which features has most correlation with Ethereum Close Price\ncorrmat = coin_dataframes['Litecoin'].corr()\nsns.heatmap(corrmat, annot=True);","6aed5aad":"#Select best coins have most correlation with Ethereum Closing Price\ndataset = pd.DataFrame()\nfor k in coin_dataframes.keys():\n    if k in ['Litecoin', 'Bitcoin']:\n        for col in coin_dataframes[k].columns:\n            if col in ['Open', 'Close', 'High', 'Low']: \n                dataset[k+'_'+col] = coin_dataframes[k][col]\n        \ndataset.tail()","10d23b0e":"#Split train test\ntraining_set = dataset[:2000].copy()\ntest_set = dataset[2000:].copy()\n\ntraining_set.shape, test_set.shape","163ccfc5":"#Log transform data\nfor col in training_set.columns:\n    training_set.loc[:,col] = np.log1p(training_set[col])\n    test_set.loc[:, col] = np.log1p(test_set[col])\n\n#Scaling data\nscaler= MinMaxScaler(feature_range=(0,1))\ntraining_set = scaler.fit_transform(training_set)\ntest_set = scaler.transform(test_set)\n\n","1ee2e997":"target = 'Litecoin_Close'\ntarget_index = list(dataset.columns).index(target)\ntarget_index","4b586367":"# Create sequences input data\nX_train = []\ny_train = []\nwindow_size = 14\ntime_step_future = 7\n\nfor i in range(window_size, len(training_set)- time_step_future):\n    \n    #Make output data. There are three output, one is the yester day price, two is current_day price and three is closing price of time_step_future days later\n    #RNN is a bit slowly react to the trend of coin. So i let it looks up far more into future, for well adapted model.\n    t = []\n    t.append(training_set[i-1, target_index])\n    t.append(training_set[i, target_index])\n    t.append(training_set[i+time_step_future, target_index])\n    y_train.append(t)\n    \n    \n    #Create X train data\n    X_train.append(training_set[i-window_size:i, :])\n\n\n\nX_train, y_train = np.array(X_train), np.array(y_train)\nX_train.shape, y_train.shape\n\n        \n                ","0de627d8":"#Init rnn\nregressor = Sequential()\n\n#Adding first layer LSTM\nregressor.add(Bidirectional( LSTM(units=50, return_sequences=True, input_shape=(window_size,X_train.shape[2])) ) )\nregressor.add(Dropout(0.3))\n\n#Adding second layer LSTM\nregressor.add(LSTM(units=50, return_sequences=True)) \nregressor.add(Dropout(0.3))\n\n#Adding third layer LSTM\nregressor.add( LSTM(units=50) )\nregressor.add(Dropout(0.3))\n\n#Adding fourth layer LSTM\n#regressor.add(LSTM(units=86))\n#regressor.add(Dropout(0.2))\n\n#Adding fifth layers LSTM\n#regressor.add(LSTM(units = 64))\n#regressor.add(Dropout(0.2))\n\n#Adding output layers\nregressor.add(Dense(units=3, activation = 'relu'))\n\n#regressor.summary()","00d8d206":"#Complie RNN\nregressor.compile(optimizer='adam', loss='mean_squared_error')","68c4915d":"regressor.fit(x = X_train, y = y_train, epochs=120, batch_size=32)","89850b29":"X_train.shape","9e66bdfd":"def unscale_y(y_pred):\n    t = np.zeros(shape=(len(y_pred), X_train.shape[2]))\n    t[:, target_index] = y_pred\n    t = scaler.inverse_transform(t)[:, target_index]\n    t = np.expm1(t)\n    return t","21b835ee":"#Get predicted closing price on training set for three output, and unscale them\ny_pred = regressor.predict(X_train)\ny_pred_yesterday = unscale_y(y_pred[:,0])\ny_pred_current_day = unscale_y(y_pred[:,1])\ny_pred_next_week = unscale_y(y_pred[:,2])\n\ny_pred_next_week.shape, y_pred_yesterday.shape, y_pred_current_day.shape","b0b3ecc3":"#Get real closing price on training set\ny_real_yesterday = dataset[window_size-1:2000-time_step_future-1][target].values\ny_real_current_day = dataset[window_size:2000-time_step_future][target].values\ny_real_next_week = dataset[window_size+time_step_future:2000][target].values\n\ny_real_next_week.shape, y_real_yesterday.shape, y_real_current_day.shape\n","127ad1b0":"def make_plot_evaluation(y_real, y_pred, title):\n    # Visualising the results\n    plt.plot(y_real, color = 'red', label = 'Real  Closing Price')\n\n    plt.plot(y_pred, color = 'blue', label = 'Predict  Closing Price')\n\n    plt.title(title)\n    plt.xlabel('Time')\n    plt.ylabel('Closing Price')\n    plt.legend()\n    plt.show()","550783e3":"make_plot_evaluation(y_real_yesterday, y_pred_yesterday, 'Litecoin Yesterday Closing Price Evaluation')\nmake_plot_evaluation(y_real_current_day, y_pred_current_day, 'Litecoin Today Closing Price Evaluation')\nmake_plot_evaluation(y_real_next_week, y_pred_next_week, 'Litecoin Next Week Closing Price Evaluation')","08b69449":"test_set.shape","f09b4e7c":"#Generate test set\ninputs = dataset[dataset.shape[0] - test_set.shape[0] - window_size: ].values\ninputs = np.log1p(inputs)\ninputs = scaler.transform(inputs)","b587095f":"\n# Create sequences input data\nX_test = []\n\nfor i in range(window_size, len(inputs)-time_step_future):\n    X_test.append(inputs[i-window_size:i, :])\n\n\n\nX_test = np.array(X_test)\nX_test.shape","0825a1da":"#Get predicted values\ny_pred = regressor.predict(X_test)\ny_pred_yesterday = unscale_y(y_pred[:,0])\ny_pred_current_day = unscale_y(y_pred[:,1])\ny_pred_next_week = unscale_y(y_pred[:,2])\n#Get real values\ny_real_yesterday = dataset[2000-1:-time_step_future-1][target].values\ny_real_current_day = dataset[2000:-time_step_future][target].values\ny_real_next_week = dataset[time_step_future+2000: ][target].values\n\n# Visualising the results\nplt.plot(y_pred_current_day, color = 'green', label='Today pred closing price')\nplt.plot(y_pred_yesterday, color = 'yellow', label = 'Yesterday')\nplt.plot(y_pred_next_week, color = 'red', label = 'Next week')\nplt.plot(y_real_current_day, color = 'black', label ='Real today')\nplt.legend()\nplt.show()","72451200":"from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n\nprint(f\"Mean square error on test: {mean_squared_error(y_pred=y_pred_current_day, y_true=y_real_current_day)}\")\nprint(f\"Mean absolute error on test: {mean_absolute_error(y_pred=y_pred_current_day, y_true=y_real_current_day)}\")\nprint(f\"R2 score on test: {r2_score(y_pred=y_pred_current_day, y_true=y_real_current_day)}\")","4fd5ab86":"X_train.shape","1806b895":"import math\n#Create a predict function\ndef predict_closing_price(model, X):\n    X = np.reshape(X, (1, window_size, X_train.shape[2]))\n    y_pred = model.predict(X)\n    y_pred[:,0] = unscale_y(y_pred[:,0])\n    y_pred[:,1] = unscale_y(y_pred[:,1])\n    y_pred[:,2] = unscale_y(y_pred[:,2])\n    \n    return y_pred\n    \n#Create buy coin function\ndef buy_coin(price, number_coin):\n    global MY_POCKET\n    global COIN_I_HAVE\n    if number_coin == 0:\n        return \n    \n    MY_POCKET = MY_POCKET - price*number_coin\n    COIN_I_HAVE += number_coin\n    \n#Create a function to calculate total coin i can buy with percent loss of my pocket\ndef how_many_coin_buy(today_price, accpet_loss = 0.2):\n    if MY_POCKET*accpet_loss < today_price:\n        if MY_POCKET*0.5 >= today_price:\n             return MY_POCKET*0.5\/\/today_price\n        elif MY_POCKET >= today_price:\n            return 1\n        else: \n            return 0\n    else:\n        return MY_POCKET*accpet_loss\/\/today_price\n    \n    \n    \n#Create sell coin function\ndef sell_coin(closing_price, number_coin):\n    global MY_POCKET\n    global COIN_I_HAVE\n    MY_POCKET += closing_price*number_coin\n    COIN_I_HAVE -= number_coin\n\n    \n\n","a3a503cc":"SIMULATION_MARKET = dataset[2000-1:]\nSIMULATION_MARKET.shape","07e63be6":"MY_POCKET = 2000\nCOIN_I_HAVE = 0\ni = 1\n\ntotal_win, total_lose = 0,0\nlast_open_price_bought = 0\n\n#Create a report\nrow = 0\nreport = pd.DataFrame(columns = ['MoneyInPocket', 'CoinsInPocket', 'CoinsBuy', 'CoinsSell', 'PctChangeToday', 'Profit'], \n                      dtype = 'float64' )\n\nfor today in SIMULATION_MARKET.iterrows():\n    if (i >= X_test.shape[0]):\n        break \n    \n    print(f\"Day {i}:\")\n    tomorrow_closing_price = predict_closing_price(regressor, X_test[i])[:,1]\n    today_closing_price = predict_closing_price(regressor, X_test[i-1])[:,1]\n    diff_today_tomorrow = tomorrow_closing_price - today_closing_price\n    \n    pct_today_tomorrow = diff_today_tomorrow\/today_closing_price\n    \n    number_coins_buy, number_coins_sell = 0, 0\n    #If next day the price growing up, buy\n    if pct_today_tomorrow >= 0.0025:\n        number_coins_buy = how_many_coin_buy(accpet_loss=0.5, today_price=today[1][6])\n        buy_coin(number_coin=number_coins_buy, price=today[1][target_index])\n    \n    #If next day the price down, sell\n    if pct_today_tomorrow <= 0.0015:\n        number_coins_sell = math.ceil(0.7*COIN_I_HAVE)\n        sell_coin(number_coin=number_coins_sell, closing_price=today[1][target_index])\n    \n    #Make a report for today \n    report.loc[row, 'MoneyInPocket'] = MY_POCKET + COIN_I_HAVE * today[1][target_index]\n    report.loc[row, 'CoinsInPocket'] = COIN_I_HAVE\n    report.loc[row, 'CoinsBuy'] = number_coins_buy\n    report.loc[row, 'CoinsSell'] = number_coins_sell\n    report.loc[row, 'PctChangeToday'] = pct_today_tomorrow\n\n    \n    if i > 2:\n        profit = MY_POCKET + COIN_I_HAVE * today[1][target_index] - report.loc[row-1, 'MoneyInPocket']\n    else:\n        profit = 0\n        \n    if profit > 0:\n        print(f\"Win today total profit: {profit}\")\n    elif profit < 0:\n        print(f\"Lose today total loss: {profit}\")\n    \n    print(f\"Today decide to buy {number_coins_buy} and sell {number_coins_sell} coins. Coins remain in pocket {COIN_I_HAVE}\")\n        \n    report.loc[row, 'Profit'] = profit\n    \n    print(\"\")\n    row+=1\n    i+=1\n","2aa087b8":"report.describe()","1ca25620":"f, ax = plt.subplots(4, 1, sharex=True, figsize=(20,15))\n\n#Plot my pocket\nax[0].plot(report['MoneyInPocket'], color = 'blue')\nax[0].set_title('My pocket over time')\nax[0].set_xlabel('Time')\nax[0].set_ylabel('Money($)')\n\n#Plot loss each day\nax[1].plot(report['Profit'], color = 'red')\nax[1].set_title(\"Profit over time\")\nax[1].set_xlabel('Time')\nax[1].set_ylabel('Money($)')\n\n#Plot coins track sell and buy in each day\nax[2].plot(report['CoinsBuy'], color = 'red', label='Number of coin buy')\nax[2].plot(report['CoinsSell'], color = 'blue', label='Number of coin sell')\nax[2].plot(report['CoinsInPocket'], color = 'orange', label='Coins remian in pocket')\nax[2].set_title(\"Coins buy plus sell in each day\")\nax[2].set_xlabel('Time')\nax[2].set_ylabel('Total coins')\nax[2].legend()\n\n#Plot predicted value\nax[3].plot(y_pred_current_day, color = 'green', label = \"Predict price\")\nax[3].plot(y_real_current_day, color = 'red', label = \"Real price in makert\")\nax[3].set_title(\"Predict Litecoin closing over time\")\nax[3].set_xlabel('Time')\nax[3].set_ylabel('Closing Price')\nax[3].legend()\n\n\nplt.legend()\nplt.show()\n","16c5938d":"SIMULATION_MARKET.tail()","e4785e47":"print(f\"After 160 days, total coins remain in pocket {COIN_I_HAVE}, total profit is {MY_POCKET + COIN_I_HAVE*138.9856 - 2000}\")","abd43f81":"#Save model\nregressor.save('LiteCoinModel.h5')","1aae951f":"# Step 4: Building model","423953a7":"## Evalution on test_set","7dfbcb52":"# Step 1: Define Problem\nIn this notebook we are going to build a RNN model for predicting crypto currency.\n\nMy target is Litecoin Closing Price in the next day. I choose LiteCoin because it fit my pocket : )","ceb81293":"# Let run simulation of selling and buying coin with this model.\n\nLet say I invest 2000$ for this time. And after 160 days, how much money i will get, or i lose them all?","26b7e0d4":"Not bad with a simple custom strategy, which total profit is 13192$. With that money, some of us can share and buy some ice cream to eat this month.","7f79eca4":"### Fitting to training_set","e0ec13db":"I'm just playing with this, maybe it do not work quite well in real market. You should have to test it more for more trust able result. Please fell free to comment bellow if you find anything, or find any bug in my code. Thanks for reading!!","c846f7d1":"# Step 3: Preprocessing Data","57520359":"# Step 5: Evaluation model\n","5cab186e":"# Step 2: Data Understanding\nThe dataset we will use, was collected by Chennai, Tamil Nadu in Kaggle. You can get it from this link: https:\/\/www.kaggle.com\/sudalairajkumar\/cryptocurrencypricehistory\n\n## **Data Content**\nThe dataset has one csv file for each currency. Price history is available on a daily basis from April 28, 2013. This dataset has the historical price information of some of the top crypto currencies by market capitalization.\n\n- Date : date of observation\n- Open : Opening price on the given day\n- High : Highest price on the given day\n- Low : Lowest price on the given day\n- Close : Closing price on the given day\n- Volume : Volume of transactions on the given day\n- Market Cap : Market capitalization in USD"}}