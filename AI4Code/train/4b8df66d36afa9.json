{"cell_type":{"d0ec653e":"code","850d4b85":"code","357bc63e":"code","ab3606b7":"code","0cf7d4f5":"code","70da7148":"code","b94c26e3":"code","6951cf7e":"code","bd50cfae":"code","e8afc2db":"code","83f96d55":"code","7bb2af4a":"code","93556a7d":"code","94506f85":"code","1a05d16c":"code","bcf4dcbb":"code","6dacc9e6":"code","f3ce7e9e":"markdown","8f40ffa2":"markdown","8ab68bd7":"markdown","4c978423":"markdown","de9bc41c":"markdown","c7d5a63e":"markdown","56767c4a":"markdown","cf81b2de":"markdown","128bcf94":"markdown","3bd525ae":"markdown"},"source":{"d0ec653e":"import matplotlib.pyplot as plt\nimport random\nfrom random import choice\nfrom IPython.display import clear_output\nimport numpy as np\nimport pandas as pd","850d4b85":"class habitant():\n\n    def __init__(self, boundx, boundy):\n        # Zufallsstartbelegung mit Abstand 20 von Rand\n        self.x_value = random.randint(20,boundx-20) \n        self.y_value = random.randint(20,boundy-20)\n        # 0=susceptible 1=infected 2=recovered\n        self.condition = 0\n        self.infectticker = 0\n\n    \n    def move(self, boundx, boundy):\n        # F\u00fchrt Schritte aus, bis der Pfad die angegebene L\u00e4nge erreicht hat.\n            x_direction = choice([1, -1])\n            x_distance = choice([0, 1, 2, 3, 4])\n            x_step = x_direction * x_distance\n            y_direction = choice([1, -1])\n            y_distance = choice([0, 1, 2, 3, 4])\n            y_step = y_direction * y_distance\n            \n            # Berechnet den n\u00e4chsten x- und y-Wert.\n            self.x_value += x_step \n            self.y_value += y_step\n            \n            if self.x_value < 1 or self.x_value > boundx-1:\n                self.x_value -= x_step\n                \n            if self.y_value < 1 or self.y_value > boundy-1:\n                self.y_value -= y_step\n    \n    \n","357bc63e":"population = 100\ncountry_x = 100\ncountry_y = 100\ninitial_infected = 3\ntime_to_recover = 100\nsteps = 1000","ab3606b7":"%matplotlib inline\n\nperson = [habitant(country_x, country_y) for dummy in range(population)]\nfor b in range(initial_infected):\n    person[b].condition = 1\n\nhealthmatrix = np.zeros([country_x, country_y], dtype = int)\n\nsusceptibel_time = np.zeros([steps], dtype = int)\ninfected_time = np.zeros([steps], dtype = int)\nrecovered_time = np.zeros([steps], dtype = int)\ninfected = initial_infected\nsusceptibel = population-infected\nrecovered = 0\n\n\nfor i in range(steps):\n    for j in range (population):\n        xpos = person[j].x_value\n        ypos = person[j].y_value\n        person[j].move(country_x, country_y)\n        \n        if person[j].condition == 1:\n                person[j].infectticker += 1\n                \n        if person[j].condition == 1 and person[j].infectticker >= time_to_recover:\n                person[j].condition = 3\n                healthmatrix[xpos, ypos] = 0\n                recovered += 1\n                infected -= 1\n        \n        if person[j].condition == 1 :\n            healthmatrix[person[j].x_value, person[j].y_value] = 1\n            healthmatrix[xpos, ypos] = 0\n            \n        if person[j].condition == 0 and (healthmatrix[person[j].x_value, person[j].y_value] == 1 or healthmatrix[xpos, ypos] == 1):\n            person[j].condition = 1  \n            infected += 1\n            susceptibel -= 1\n            \n        if person[j].condition == 0 :\n            colour = \"green\"\n        elif person[j].condition == 1:\n            colour = \"red\"\n        else:\n            colour = \"blue\"\n        \n        fig_size = plt.rcParams[\"figure.figsize\"]\n        fig_size[0] = 12\n        fig_size[1] = 4\n        plt.rcParams[\"figure.figsize\"] = fig_size\n            \n        plt.axis( [0,country_x,0,country_y] ) \n        sub1 = plt.subplot(1, 2, 1)\n        sub1.scatter(person[j].x_value, person[j].y_value, c=colour, s=100)\n    \n    susceptibel_time[i] = susceptibel\n    infected_time[i] = infected\n    recovered_time[i] = recovered\n    \n    df = pd.DataFrame(susceptibel_time,columns=[\"susceptibel\"])\n    df['infected']=infected_time\n    df['recovered']=recovered_time\n    df['step'] = range(1, len(df) + 1)\n\n    sub2 = plt.subplot(1, 2, 2)\n    df.plot(ax=sub2, x = 'step', y = [\"infected\",\"recovered\",\"susceptibel\"],kind='line', title = 'course of infection', legend = False)\n    plt.gca().get_lines()[0].set_color(\"red\")\n    plt.gca().get_lines()[1].set_color(\"blue\")\n    plt.gca().get_lines()[2].set_color(\"green\")\n    \n    clear_output(wait=True)\n    plt.pause(0.01)\n    \nplt.show()\n    ","0cf7d4f5":"df.plot(x = 'step', y = [\"infected\",\"recovered\",\"susceptibel\"],kind='line', title = 'Number cases: red=Infected, green=susceptibel, blue=recovered ', legend = False)\nplt.gca().get_lines()[0].set_color(\"red\")\nplt.gca().get_lines()[1].set_color(\"blue\")\nplt.gca().get_lines()[2].set_color(\"green\")","70da7148":"df.head(5)","b94c26e3":"from scipy.integrate import odeint\nfrom scipy import integrate, optimize","6951cf7e":"def SIR_model(y,t,beta,gamma):\n    S, I, R = y\n    N = population\n    dS_dt = -1*beta*I*S\/N \n    \n    dI_dt = (beta*I*S\/N) - gamma*I\n    \n    if t > time_to_recover : \n        dR_dt = gamma*I\n    else : \n        dR_dt = 0\n    \n    return ([dS_dt, dI_dt, dR_dt])\n\ndef fit_odeint(x, beta, gamma):\n    return integrate.odeint(SIR_model, (S0, I0, R0), x, args=(beta, gamma))[:,1]","bd50cfae":"xdata = df.step\nydata = df.infected\nxdata = np.array(xdata, dtype=float)\nydata = np.array(ydata, dtype=float)\n\nS0 = population-initial_infected\nI0 = initial_infected\nR0 = 0\ny = S0, I0, R0\n\npopt, pcov = optimize.curve_fit(fit_odeint, xdata, ydata)\nfitted = fit_odeint(xdata, *popt)","e8afc2db":"plt.plot(xdata, ydata, 'o')\nplt.plot(xdata, fitted)\nplt.title(\"Fit of SIR model for Germany infected cases\")\nplt.ylabel(\"Population infected\")\nplt.xlabel(\"Days\")\nplt.show()\nprint(\"Optimal parameters: beta =\", popt[0], \" and gamma = \", popt[1])","83f96d55":"#defining initial conditions\n\nN = population\nS00 = population-initial_infected\nI00 = initial_infected\nR00 = 0.0\n#bta = 0.015   # as infection time is 100, multiply beta*100 to get Relication Rate (R0)\nbta = popt[0]\ngmma = popt[1]\n\nt = np.linspace(0,1000,1000)\n\nsol = odeint(SIR_model,[S00,I00,R00],t,args = (bta,gmma))\nsol = np.array(sol)","7bb2af4a":"#plotting results\n\nnew_susp=population-sol[:,1]-sol[:,2]\n\nplt.figure(figsize=(12,8))\nplt.plot(t, new_susp,label = \"S(t)\")\nplt.plot(t, sol[:,1],label = \"I(t)\")\nplt.plot(t, sol[:,2],label = \"R(t)\")\nplt.plot(t, infected_time,label = \"I(t) mdel\")\nplt.plot(t, susceptibel_time,label = \"S(t) mdel\")\nplt.plot(t, recovered_time,label = \"R(t) mdel\")\nplt.legend()\nplt.show()","93556a7d":"Rnull = bta*time_to_recover\nprint (Rnull)","94506f85":"def deriv(y, t, N, beta, gamma, delta):\n    S, E, I, R = y\n    dSdt = -beta * S * I \/ N\n    dEdt = beta * S * I \/ N - delta * E\n    dIdt = delta * E - gamma * I\n    dRdt = gamma * I\n    return dSdt, dEdt, dIdt, dRdt\n\n# calculate optimized beta and gamma (tbd)\ndef fit_odeint2(x, beta, gamma, delta):\n#    return integrate.odeint(SIR_model, (S0, I0, R0), x, args=(beta, gamma))[:,1]\n    return integrate.odeint(deriv, (S0, E0, I0, R0), x, args=(N, beta, gamma, delta))[:,1]","1a05d16c":"N = population\nbeta = 0.6  # infected person infects 1 other person per day\nD = 40.0 # infections lasts four days\ngamma = 1.0 \/ D\ndelta = 1.0 \/ 100.0  # incubation period of three days\n\n#D = time_to_recover\n#gamma = 1.0\/D\n\n\n# S0, I0, R0, E0 = 999, 1, 0, 0  # initial conditions: one infected, rest susceptible\nS0 = population-initial_infected\nI0 = 0.0\nR0 = 0.0\nE0 = initial_infected","bcf4dcbb":"t = np.linspace(0, 1000, 1000) # Grid of time points (in days)\ny0 = S0, E0, I0, R0 # Initial conditions vector\n\n# Integrate the SIR equations over the time grid, t.\nret = odeint(deriv, y0, t, args=(N, beta, gamma, delta))\nS, E, I, R = ret.T","6dacc9e6":"plt.figure(figsize=(12,8))\nplt.plot(t, S,label = \"S\")\nplt.plot(t, I,label = \"I\")\nplt.plot(t, R,label = \"R\")\nplt.plot(t, E,label = \"E\")\nplt.legend()\nplt.show()","f3ce7e9e":"## Verification SIR Model\n\n- finding the optimized parameters for the differantial equation by calculating a best fit curve for the infected data row  \n- use these optimized parameters to solve equations for SIR model and plot the resulting curves\n- calculate R0 (replication rate)\n","8f40ffa2":"## class habitant\n\nthis is the basic class for a citizen on the game of life playground. \nTwo methods for initializing the position and condition of a citizen and for the movement on each iteration","8ab68bd7":"![image.png](attachment:image.png)","4c978423":"SIR Model :\n![image.png](attachment:image.png)","de9bc41c":"## simulation \n\nAfter initialization we run through 2 for loops (iterations and change state for each citizen)","c7d5a63e":"## parameters \n- population : size of the population\n- country : size of the playground\n- initial_infected : start condition, number of infected citizens\n- time_to_recover : recovery time of infected person (in the period a citizen can infect others)\n- steps : number of iterations\n","56767c4a":"![image.png](attachment:image.png)","cf81b2de":"## SEIR Model\nhttps:\/\/towardsdatascience.com\/infectious-disease-modelling-beyond-the-basic-sir-model-216369c584c4\n\nSEIR model is only used here as an idea for extension of the \"game of life\" approach with generic numbers ","128bcf94":"# Game of life Covid19\n# Simulation of infectious deseases (e.g. Corona-Covid19)\n\nThe idea is to simulate the course of infection for a given population on a \"Game of Life\" based approach (the inventor of \"Game of life\" John Conway died on 11 April as a result of his Corona infection). \n\nBasic rules : \nEach \"citizen\" is moving randomly on a 2D grid and can have the condition \"susceptible\", \"infected\" and \"recovered\". An infected citizen can infect others when they meet on the same field on the grid. The condition \"infected\" is changed to \"recovered\" after a give number of iterations. \n\nYou can see the infection and recovery process in the population grid (change of colours) and also by the developing data curves in parallel\n\nValidation : \nWith the created course of infection we can validate the known SIR model for infectious deseases by comparing the curves of SIR and Game of Life simulations\n\n\n## Ideas for further development :\n- Refine the \"Game of life\" model, e.g. ages biased to infections, add fatality, exposed state (SEIR model) etc\n- Use SEIR or extended models for validation\n- Use barriers in the grid to simulate quarantine and compartment situations\n- performance optimizations\n- code optimizations\n...\n\n(the SIR and SEIR model code is taken from other public internet sources)","3bd525ae":"![image.png](attachment:image.png)"}}