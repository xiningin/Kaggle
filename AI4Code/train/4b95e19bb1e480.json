{"cell_type":{"64103986":"code","440a500d":"code","1ec470eb":"code","ba1bd64e":"code","c993b109":"code","08ee3e1b":"code","0918af9c":"code","14a54579":"code","bed10a30":"code","97ab9353":"code","cc6181a8":"code","3cd6883b":"code","32c8c30c":"code","b121842d":"code","d71a8988":"code","2b9d1813":"code","326ae86d":"code","e754a481":"code","4b18da5a":"code","5d0dd24f":"code","0c649da4":"code","e79180e3":"code","8c1d4bf5":"code","24d5e174":"code","926ef437":"code","03e2505d":"code","26b4eaa9":"code","1012cac4":"code","ff866e4a":"code","b9276181":"code","8eea957f":"code","fb3b2713":"code","3c910fac":"code","7f35f7dc":"code","d574d788":"code","34f24e77":"code","61f01b91":"code","c90ce8dd":"code","4eb0a0b4":"code","919bed18":"code","81356905":"code","8f2bd26a":"code","f8a82f87":"code","b051b137":"code","c09b32b8":"code","a9412757":"code","bd54f4aa":"code","c34a5af7":"code","c27b9f57":"code","e5aef52b":"code","1e91dbe0":"code","a1fe03f3":"code","f3d9e428":"code","1647f783":"code","9132433f":"code","4acff1d6":"code","49d52351":"code","d058d2f8":"code","151b0881":"code","399fd45b":"code","4fa507bc":"code","ad233938":"code","55f8dfbe":"code","58ef82ca":"code","6b23872a":"code","766dc154":"code","6f4a9a1a":"code","1831c6fa":"code","bbb05023":"code","d06b5389":"code","a507ea94":"code","a2676b22":"code","7171a97c":"code","599e59ba":"code","c093e5a9":"code","4ba20c8a":"markdown","89bf1621":"markdown","4f17d1b6":"markdown","8d7cfd14":"markdown","6ecc7b28":"markdown","6de26b5e":"markdown","cc4baed4":"markdown","85d7c1f7":"markdown","6d539b50":"markdown","cf88dbb1":"markdown","ef33eef4":"markdown","2a8111da":"markdown","986ee904":"markdown","efe2995b":"markdown","2597bc84":"markdown","e92cac16":"markdown","48b26850":"markdown","ecca02f2":"markdown","7fc9efde":"markdown","2f70595d":"markdown","c558d819":"markdown","da8cff34":"markdown","e420c3a5":"markdown","d75a1d3a":"markdown","c77e65bd":"markdown","25e7443d":"markdown","85b8ddfe":"markdown","0f4fe28d":"markdown","cc55febe":"markdown","0220e202":"markdown","697d96bf":"markdown","a27b6615":"markdown","29ec0510":"markdown","54129abe":"markdown","82014ba1":"markdown","b95a5d2a":"markdown","88980f53":"markdown","2815d205":"markdown","76ad7519":"markdown","e88b827c":"markdown","9eeca40d":"markdown","24bebb84":"markdown","8660e494":"markdown","35b6c7ae":"markdown","e625de69":"markdown","f5ff193a":"markdown","b8186e1b":"markdown","ed50d72e":"markdown","2dc995f1":"markdown","f927d8e9":"markdown","230b2287":"markdown","271c33b9":"markdown","e90d3aaf":"markdown","da088a0a":"markdown","95f9ad97":"markdown","3a020cc2":"markdown","c28d4020":"markdown","a5744ce8":"markdown","66eeaf01":"markdown","e80f47be":"markdown","c37a4305":"markdown","ce7d291a":"markdown","a01491af":"markdown","8adb7996":"markdown","9187eecb":"markdown","3cbbd04c":"markdown","bdf750e3":"markdown","706e4066":"markdown","11d39cf6":"markdown","df578fab":"markdown","94cb65eb":"markdown","fbe31d60":"markdown","21c3c38f":"markdown","c1da3936":"markdown","d7b4594d":"markdown","aaadc907":"markdown","29b5b901":"markdown","66ceda91":"markdown","794bb0c7":"markdown","fdaf8142":"markdown","f84eb026":"markdown","6d28c6f5":"markdown","515d32b9":"markdown","fc01c7ff":"markdown"},"source":{"64103986":"# Standard data analysis packages\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Working with geospatial data\nimport geopandas as gpd\nimport folium\nfrom shapely.ops import unary_union\nfrom sklearn.metrics.pairwise import haversine_distances\n\n# Webscraping and APIs\nimport requests\nfrom bs4 import BeautifulSoup as BS\n\n# Additional python packages\nimport json\nimport math\nimport ast\n\n%matplotlib inline","440a500d":"tennessee_tracts = gpd.read_file('..\/input\/nashville-food-deserts-data\/cb_2018_47_tract_500k.shp')","1ec470eb":"tennessee_tracts.head()","ba1bd64e":"# Save the first row POLYGON to a variable\nsingle_tract = tennessee_tracts.loc[0, 'geometry']\n\n# print the type of the object\nprint('object type: ',type(single_tract), '\\n')\n\n# print what is stored inside the object\nprint('object contents: ', single_tract)","c993b109":"tennessee_tracts.boundary.plot(figsize = (25, 5));","08ee3e1b":"# Select only Davidson County tracts (COUNTYFP == 037)\ndavidson_tracts = tennessee_tracts[tennessee_tracts['COUNTYFP']=='037'].reset_index(drop = True)","0918af9c":"davidson_tracts.head()","14a54579":"davidson_tracts.boundary.plot(figsize = (20, 20));","bed10a30":"davidson_county = gpd.read_file('..\/input\/nashville-food-deserts-data\/Davidson County Border (GIS).geojson')\ndavidson_county.boundary.plot(figsize = (20, 20));","97ab9353":"# modified from https:\/\/censusreporter.org\/data\/table\/?table=B17001&geo_ids=14000US47037016000,05000US47037,04000US47,01000US,140|05000US47037&primary_geo_id=14000US47037016000\npoverty_rates_davidson = pd.read_csv('..\/input\/nashville-food-deserts-data\/davidson_poverty_cleaned.csv', index_col = 0)\npoverty_rates_davidson.head()","cc6181a8":"# remove aggregation rows\npoverty_rates_davidson_tract = poverty_rates_davidson.drop([0, 1, 2])\npoverty_rates_davidson_tract.head()","3cd6883b":"poverty_rates_davidson_tract['pct_below_poverty_level'] = poverty_rates_davidson_tract['Income in the past 12 months below poverty level:']\/poverty_rates_davidson_tract['Total:']\npoverty_rates_davidson_tract.head()\n","32c8c30c":"poverty_rates_davidson_tract['GEOID'] = poverty_rates_davidson_tract['geoid'].str[7:]","b121842d":"davidson_tracts = davidson_tracts.merge(poverty_rates_davidson_tract[['GEOID', 'pct_below_poverty_level']],\n                                        how = 'left',\n                                        on = 'GEOID')\n\ndavidson_tracts['pct_below_poverty_level'] = davidson_tracts['pct_below_poverty_level'].fillna(np.median(davidson_tracts['pct_below_poverty_level']))","d71a8988":"davidson_tracts['above_20_pct'] = (davidson_tracts['pct_below_poverty_level'] >= 0.2).astype(int)","2b9d1813":"davidson_tracts.head()","326ae86d":"f, ax = plt.subplots(1, figsize=(25, 25))\nax = davidson_tracts.plot(ax=ax, column = 'above_20_pct', cmap='Set1', edgecolor = 'blue', alpha = 0.5)\nax = davidson_county.boundary.plot(ax=ax, color='blue');","e754a481":"davidson_service_districts = gpd.read_file('..\/input\/nashville-food-deserts-data\/Service Districts (GIS).geojson')\ndavidson_service_districts","4b18da5a":"f, ax = plt.subplots(1, figsize=(25, 25))\nax = davidson_tracts.plot(ax=ax, column = 'above_20_pct', cmap='Set1', edgecolor = 'blue', alpha = 0.5)\nax = davidson_county.boundary.plot(ax=ax, color='blue')\nax = davidson_service_districts[davidson_service_districts['name']=='Urban Services District'].plot(ax=ax, alpha = 0.4, edgecolor = 'black', linewidth = 3);","5d0dd24f":"urban_service_area = davidson_service_districts.loc[0, 'geometry']","0c649da4":"def check_urban_tract(row):\n    return (row['geometry'] - urban_service_area).area\/row['geometry'].area","e79180e3":"davidson_tracts['rural_ratio'] = davidson_tracts.apply(check_urban_tract, axis = 1) # axis = 1 means apply to rows\n\ndavidson_tracts['is_rural'] = (davidson_tracts['rural_ratio'] > 0.5).astype(int)","8c1d4bf5":"davidson_tracts.head()","24d5e174":"davidson_county_buffer_10 = gpd.GeoDataFrame(geometry = davidson_county['geometry'].buffer(0.14492753623188406))\ndavidson_county_buffer_10.plot();","926ef437":"davidson_county_buffer_1 = gpd.GeoDataFrame(geometry = davidson_county['geometry'].buffer(0.014492753623188406))\ndavidson_county_buffer_1.plot();","03e2505d":"stores_gdf = gpd.read_file('..\/input\/nashville-food-deserts-data\/google_api_stores_cleaned.shp')\nstores_gdf.head()","26b4eaa9":"supermarkets = stores_gdf[stores_gdf['types'].apply(lambda x: 'supermarket' in x)]","1012cac4":"supermarkets","ff866e4a":"non_dollar_supermarkets = supermarkets[~supermarkets['name'].str.contains('Dollar')]","b9276181":"f, ax = plt.subplots(1, figsize=(25, 25))\nax = davidson_tracts.plot(ax=ax, column = 'above_20_pct', categorical = True, cmap = 'Set1', edgecolor = '#377eb8', alpha = 0.5)\nax = davidson_county.boundary.plot(ax=ax, color='#377eb8')\nnon_dollar_supermarkets.plot(ax=ax, marker='o', color='#4e2853', markersize=15);","8eea957f":"url = 'https:\/\/www.picktnproducts.org\/listview\/farmers-market.html'","fb3b2713":"response = requests.get(url)","3c910fac":"soup = BS(response.content, 'lxml')","7f35f7dc":"markets_names_soup = soup.find('div', attrs = {'id': 'middle'})","d574d788":"markets_names_soup","34f24e77":"json.loads(markets_names_soup['data-middlejson'])","61f01b91":"mid_tn_farm_mark = pd.DataFrame(json.loads(markets_names_soup['data-middlejson']))\nmid_tn_farm_mark.head()","c90ce8dd":"mid_tn_farm_mark = gpd.GeoDataFrame(mid_tn_farm_mark,\n                                    geometry = gpd.points_from_xy(mid_tn_farm_mark['longitude'], mid_tn_farm_mark['latitude']))\n\nkeep_points_fm = []\nrural_only_fm = []\nfor ind, p in mid_tn_farm_mark['geometry'].iteritems():\n    if p.within(davidson_county_buffer_10.loc[0, 'geometry']):\n        keep_points_fm.append(ind)\n        if p.within(davidson_county_buffer_1.loc[0, 'geometry']):\n            rural_only_fm.append(0)\n        else:\n            rural_only_fm.append(1)\n\ndavidson_farm_mark = mid_tn_farm_mark.loc[keep_points_fm]\ndavidson_farm_mark['rural_only'] = rural_only_fm\n\ndavidson_farm_mark.head()","4eb0a0b4":"f, ax = plt.subplots(1, figsize=(25, 25))\nax = davidson_tracts.plot(ax=ax, column = 'above_20_pct', categorical = True, cmap = 'Set1', edgecolor = '#377eb8', alpha = 0.5)\nax = davidson_county.boundary.plot(ax=ax, color='#377eb8')\nax = non_dollar_supermarkets.plot(ax=ax, marker='o', color='#4e2853', markersize=15)\ndavidson_farm_mark.plot(ax=ax, marker='o', color='#dddd19', markersize=15);","919bed18":"urban_store_buffers = gpd.GeoDataFrame(geometry = non_dollar_supermarkets[non_dollar_supermarkets['rural_only']==0]['geometry'].buffer(0.014492753623188406))\n\n\nrural_store_buffers = gpd.GeoDataFrame(geometry = non_dollar_supermarkets['geometry'].buffer(0.14492753623188406))","81356905":"# Add in Farmers Markets data\n\nurban_store_buffers = urban_store_buffers.append(\n    gpd.GeoDataFrame(\n        geometry = davidson_farm_mark[davidson_farm_mark['rural_only']==0]['geometry'].buffer(0.014492753623188406)\n    ))\n\nrural_store_buffers = rural_store_buffers.append(\n    gpd.GeoDataFrame(\n        geometry = davidson_farm_mark['geometry'].buffer(0.14492753623188406)\n    ))","8f2bd26a":"f, ax = plt.subplots(1, figsize=(25, 25))\nax = davidson_tracts.plot(ax=ax, column = 'above_20_pct', categorical = True, cmap = 'Set1', edgecolor = '#377eb8', alpha = 0.5)\nax = davidson_county.boundary.plot(ax=ax, color='#377eb8')\nax = urban_store_buffers.plot(ax=ax, color = '#5f9ea0', alpha = 0.2)\nax = non_dollar_supermarkets.plot(ax=ax, marker='o', color='#4e2853', markersize=15)\ndavidson_farm_mark.plot(ax=ax, marker='o', color='#dddd19', markersize=15);","f8a82f87":"urban_store_buffers = unary_union(urban_store_buffers['geometry'])\nrural_store_buffers = unary_union(rural_store_buffers['geometry'])","b051b137":"def check_low_food_access(row):\n    if row['is_rural'] == 1:\n        return (row['geometry'] - rural_store_buffers).area\/row['geometry'].area\n    else:\n        return (row['geometry'] - urban_store_buffers).area\/row['geometry'].area","c09b32b8":"# check tract on row 2 of census tract df\ncheck_low_food_access(davidson_tracts.loc[1, :])","a9412757":"davidson_tracts['ratio_low_food_access'] = davidson_tracts.apply(check_low_food_access, axis = 1)\n\ndavidson_tracts['possible_food_desert'] = ((davidson_tracts['ratio_low_food_access'] > 0.33) & (davidson_tracts['above_20_pct'] == 1)).astype(int)","bd54f4aa":"davidson_tracts.head()","c34a5af7":"f, ax = plt.subplots(1, figsize=(25, 25))\nax = davidson_tracts.plot(ax=ax, column = 'possible_food_desert', categorical = True, cmap = 'Set1', edgecolor = '#377eb8', alpha = 0.5)\nax = davidson_county.boundary.plot(ax=ax, color='#377eb8')\nax = davidson_service_districts[davidson_service_districts['name']=='Urban Services District'].plot(ax=ax, alpha = 0.2, edgecolor = 'black', linewidth = 3)\nax = non_dollar_supermarkets.plot(ax=ax, marker='o', color='#4e2853', markersize=15)\ndavidson_farm_mark.plot(ax=ax, marker='o', color='#dddd19', markersize=15);","c27b9f57":"possible_food_deserts = unary_union(davidson_tracts[davidson_tracts['possible_food_desert']==1]['geometry'])\nnash_map = folium.Map(location =  [36.1612, -86.7775], zoom_start = 11)\nfolium.GeoJson(possible_food_deserts).add_to(nash_map)\nnash_map","e5aef52b":"# Find total geographic bounds of search area\n\nxmin,ymin,xmax,ymax = davidson_county_buffer_10.total_bounds","1e91dbe0":"# Find total geographic bounds of Davidson County\n\nxmin_d,ymin_d,xmax_d,ymax_d = davidson_county.total_bounds\n\n# Divide the length and width by 10 to get the increment between each grid point\n\nx_increment = (xmax_d-xmin_d)\/10\ny_increment = (ymax_d-ymin_d)\/10","a1fe03f3":"# determine x coordinate values for grid points\ngrid_x_boundaries = [xmin]\nnew_bound = xmin\nfor i in range(int((xmax-xmin)\/x_increment)+1):\n    new_bound = new_bound + x_increment\n    grid_x_boundaries.append(new_bound)\n    \n# determine x coordinate values for grid points\ngrid_y_boundaries = [ymin]\nnew_bound = ymin\nfor i in range(int((ymax-ymin)\/y_increment)+1):\n    new_bound = new_bound + y_increment\n    grid_y_boundaries.append(new_bound)","f3d9e428":"# get list of all lats and lons across all grid points\nlons = []\nlats = []\nfor left, right in zip(grid_x_boundaries[:-1], grid_x_boundaries[1:]):\n    for top, bottom in zip(grid_y_boundaries[:-1], grid_y_boundaries[1:]):\n        lats.append((top+bottom)\/2)\n        lons.append((left+right)\/2)\n        \n# Take each pair of longitude and latitude, combine them, and convert to point object\ngrid_points = gpd.points_from_xy(lons, lats)\n\n# put into geodataframe\ngrid_gdf = gpd.GeoDataFrame(geometry = grid_points)","1647f783":"grid_gdf.plot();","9132433f":"# Only keep points within the buffered Davidson county polygon\nkeep_points = []\nfor ind, p in grid_gdf['geometry'].iteritems():\n    if p.within(davidson_county_buffer_10.loc[0, 'geometry']) or p.within(davidson_county_buffer_10.loc[1, 'geometry']):\n        keep_points.append(ind)\n\ngrid_points_sub = grid_gdf.loc[keep_points].reset_index(drop=True)","4acff1d6":"base = davidson_county_buffer_10.plot(color='white', edgecolor='black')\n\ngrid_points_sub.plot(ax=base, marker='o', color='red', markersize=5);","49d52351":"# function adapted from https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.metrics.pairwise.haversine_distances.html\ndef dist_in_meters(point_1, point_2):\n    point_1 = [math.radians(l) for l in [point_1.y, point_1.x]]\n    point_2 = [math.radians(l) for l in [point_2.y, point_2.x]]\n    dist_array_m = haversine_distances([point_1, point_2])*6371000\n    return dist_array_m[0][1]","d058d2f8":"grid_point_radius = dist_in_meters(grid_points_sub.loc[1, 'geometry'], grid_points_sub.loc[2, 'geometry'])","151b0881":"grid_point_radius_mile = 3.0258050367212114828\/69\ngrid_points_sub_buffers = gpd.GeoDataFrame(geometry = grid_points_sub['geometry'].buffer(grid_point_radius_mile))\nf, ax = plt.subplots(1, figsize=(25, 25))\nax = davidson_tracts.boundary.plot(ax=ax, edgecolor = 'blue', color='blue', alpha = 0.15)\nax = davidson_county.boundary.plot(ax=ax, color='blue', alpha = 0.15)\nax = grid_points_sub_buffers.plot(ax=ax, color = '#ff7f00', alpha = 0.1)\ngrid_points_sub.plot(ax=ax, marker='o', color='#4e2853', markersize=5);","399fd45b":"all_types = ['bakery',\n             'convenience_store',\n             'department_store',\n             'drugstore',\n             'gas_station',\n             'grocery_or_supermarket',\n             'home_goods_store',\n             'supermarket',\n             'pharmacy']","4fa507bc":"# Modified from https:\/\/python.gotrained.com\/google-places-api-extracting-location-data-reviews\/\n\ndef search_places_by_coordinate(location, radius, types, api_key, sleep_sec = 2):\n    '''\n    Send request to nearbysearch Google Maps endpoint\n    \n    location: The lat and lng to search nearby, \"lat, lng\"\n    radius: The distance, in meters, to search around the location\n    types: List of business types to search for\n    api_key: Credentials provided by Google to authenticate use of the API\n    sleep_sec: Number of seconds to wait between individual requests to throttle and avoid quotas\n    '''\n    # This is the endpoint where the request will be sent\n    endpoint_url = \"https:\/\/maps.googleapis.com\/maps\/api\/place\/nearbysearch\/json\"\n    \n    places = [] # Where the responses will be saved\n    \n    # Formatting the request inputs\n    params = {\n        'location': location,\n        'radius': radius,\n        'types': types,\n        'key': api_key\n    }\n    \n    # Make the request to the endpoint with the associated parameters and save the output\n    res = requests.get(endpoint_url, params = params)\n    \n    # Read the contents of the response, which is a json, into a dictionary to make it easier to work with\n    results = json.loads(res.content)\n    \n    # Add the results to the any previous results\n    places.extend(results['results'])\n    \n    # Wait before the next request\n    time.sleep(sleep_sec)\n    \n    # If there are still more items available, the response will contain a next_page_token to pick up at the same spot\n    # As long as there is a next_page_token, keep making requests\n    while \"next_page_token\" in results:\n        params['pagetoken'] = results['next_page_token'],\n        res = requests.get(endpoint_url, params = params)\n        results = json.loads(res.content)\n        places.extend(results['results'])\n        time.sleep(sleep_sec)\n    \n    # Once there are no more next_page_tokens, return the full list of stores\n    return places","ad233938":"# creating output list in separate cell in case need to run for loop multiple times because of time out errors\nresponses = []","55f8dfbe":"# This one can take a while, run with caution\n\nfor ind_2, t in enumerate(all_types):\n    print(ind_2, t) # just to keep track of progress\n    # if ind_2 >= 1: # uncomment and tab below over if need to start later in all_types list\n    for ind, (lng, lat) in enumerate(list(zip(grid_points_sub['geometry'].x, grid_points_sub['geometry'].y))): # note that lat and lng are switched\n        print(ind, lat, lng) # again, to keep track of progress\n        # if ind >= 0: # uncomment and tab below if need to start later in grid df\n        location = '{}, {}'.format(lat, lng)\n        responses.append(search_places_by_coordinate(location, grid_point_radius, t, api_key))","58ef82ca":"stores_df = pd.read_csv('..\/input\/nashville-food-deserts-data\/google_api_stores_responses_9-4-20_2.csv')\nstores_df.head()","6b23872a":"stores_df['place_id'].value_counts()","766dc154":"stores_df = stores_df.drop_duplicates('place_id')","6f4a9a1a":"stores_df['place_id'].value_counts()","1831c6fa":"store_location_example = stores_df.loc[0, 'geometry']\nprint(store_location_example, '\\n')\nprint(type(store_location_example)) # Double check the data type","bbb05023":"store_location_example = ast.literal_eval(store_location_example)\nprint(type(store_location_example), '\\n')\nprint(store_location_example)","d06b5389":"lat_lng_example = store_location_example['location']\nprint(lat_lng_example, '\\n')\npd.Series(lat_lng_example)","a507ea94":"def extract_lat_lng_to_new_col(row):\n    geo = row['geometry']\n    geo = ast.literal_eval(geo)\n    lat_lng = geo['location']\n    lat_lng_s = pd.Series(lat_lng)\n    row = row.append(lat_lng_s)\n    return row","a2676b22":"# axis = 1 ensures we are applying the function to each row, not each column\nstores_df = stores_df.apply(extract_lat_lng_to_new_col, axis = 1)\nstores_df.head()","7171a97c":"stores_df = stores_df.rename(columns = {'geometry': 'geometry_google'})\n\nstores_gdf = gpd.GeoDataFrame(stores_df,\n                              geometry = gpd.points_from_xy(stores_df['lng'], # Creating the geometry column\n                                                            stores_df['lat']))# on the fly with points_from_xy()\n\nstores_gdf.head()","599e59ba":"keep_stores = []\nrural_only = []\nfor ind, p in stores_gdf['geometry'].iteritems(): # iteritems gives each index and value as a tuple\n    # select stores to keep\n    if p.within(davidson_county_buffer_10.loc[0, 'geometry']) or p.within(davidson_county_buffer_10.loc[1, 'geometry']):\n        keep_stores.append(ind)\n        # indicate if store is rural only or both\n        if p.within(davidson_county_buffer_1.loc[0, 'geometry']) or p.within(davidson_county_buffer_1.loc[1, 'geometry']):\n            rural_only.append(0)\n        else:\n            rural_only.append(1)\n\nstores_gdf = stores_gdf.loc[keep_stores]\nstores_gdf['rural_only'] = rural_only","c093e5a9":"stores_gdf.head()","4ba20c8a":"Since many stores will be returned I created a separate list to add all the responses so they will persist even if there is an issue with a request or there is an interruption for some reason. This will allow me to pick up where it left off","89bf1621":"There are indeed duplicates, likely due to a combination of stores having multiple store types and being in a place where the search areas overlap.\n\n#### To remove duplicates we can use the `.drop_duplicates()` method.\nIt will remove duplicate rows and it can be specified to only consider a subset of columns. In our case, we only need to pay attention to the `place_id` column.","4f17d1b6":"We can add these to our map as well","8d7cfd14":"#### In order to plot the stores on a map we need their lat and lng.\nThat is currently burried in the `geometry` column. Let's take the first row as an example and better understand the structure of the data:","6ecc7b28":"With that cleaning done, let's plot the supermarkets on the map and see where we stand now:","6de26b5e":"There are a number of useful columns, including the store `name` and `types`. Before we dive into that there's still a little more cleaning we need to do:\n1. Remove duplicates (since there is some overlap across the grid points)\n2. Extract the lat and lng for each of the stores\n3. Only keep stores that are inside our area(s) of interest","cc4baed4":"# According to our analysis, the highlighted areas are possible food deserts. How would you interpret the results?","85d7c1f7":"Now we can merge the data sets. We can do that by performing the `.merge()` method on one of the dfs. Below we are performing it on the `davidson_tracts` gdf and passing the `GEOID` and `pct_below_poverty_level` columns of the `poverty_rates_davidson_tract` df. We are telling it to do a `left` merge, which will keep everything from the first df, and line up everything that matches from the right df. Matching is determined by the contents of the `GEOID` column from each df. After that we are filling any missing values with the median value across all tracts in davidson county.","6d539b50":"# Identify possible food deserts\n\n### Now that we have a list of stores that sell fresh food, we can find the low income census tracts where at least a third is more than a mile (or 10 miles for rural tracts) away from them.\n\nTo address that we will add buffers around the stores that correspond to a 1 mile radius.\n\nThe buffers will be separate objects, so we will create a new gdf for them. Recall that we can approximate the number of degrees in a mile as: 1\/69 = 0.014492753623188406","cf88dbb1":"After this ran I flattened the response list and saved it off as a csv. Now we can import it again and continue using the data.","ef33eef4":"The website has all the information we need. In order to tell python to scrape the website, we first need to tell it where to go. That is called the endpoint url, which is the website itself.","2a8111da":"Let's expand this out to find all the possible food deserts in Davidson County. Recall our criteria for possible food deserts:\n1. Poverty level in a census tract is >= 20% (low income)\n2. At least 33% of the census tract is >1 mile from a fresh food source in urban areas or >10 miles for rural areas (low access)","986ee904":"We have read in the data and saved it to a variable called `tennessee_tracts`. This variable is a `GeoDataFrame` (gdf). The first thing to do with any data set is to explore it to get a better understanding of the data inside. We can start by looking at the first five rows using the `.head()` method.","efe2995b":"Here we only are showing the boundaries for each census tract in Tennessee. The plot size is increased so we can see more of the fine details.\n\nWe are only interested in Davidson County for this analysis, so we can subset the gdf to only include data from Davidson County by using some of the other columns.","2597bc84":"# What is a food desert?\n\nFood deserts are areas that have limited access to fresh food. A food deserts can worsen issues like obesity and diabetes and may disporportinately affect certain communities.\n\n## From the USDA website:  \n\n#### The area of a food desert is definied by the census tract\n\nhttps:\/\/www.ers.usda.gov\/data-products\/food-access-research-atlas\/documentation\/  \n\"Most measures and definitions take into account at least some of the following indicators of access:\n\n- Accessibility to sources of healthy food, as measured by distance to a store or by the number of stores in an area.\n- Individual-level resources that may affect accessibility, such as family income or vehicle availability.\n- Neighborhood-level indicators of resources, such as the average income of the neighborhood and the availability of public transportation.\"  \n\n\"This program defines a low-income census tract as any tract where:\n\n- The tract\u2019s poverty rate is 20 percent or greater; or\n- The tract\u2019s median family income is less than or equal to 80 percent of the State-wide median family income; or\n- The tract is in a metropolitan area and has a median family income less than or equal to 80 percent of the metropolitan area's median family income.\"  \n\n\"Three measures of food access based on distance to a supermarket are provided in the Atlas:\n\n- Low-income census tracts where a significant number (at least 500 people) or share (at least 33 percent) of the population is greater than \u00bd mile from the nearest supermarket, supercenter, or large grocery store for an urban area or greater than 10 miles for a rural area. Using this measure, an estimated 54.4 million people, or 17.7 percent of the U.S. population, live in tracts that are low-income and low access and are more than \u00bd mile or 10 miles from the nearest supermarket.\n- Low-income census tracts where a significant number (at least 500 people) or share (at least 33 percent) of the population is greater than 1.0 mile from the nearest supermarket, supercenter, or large grocery store for an urban area or greater than 10 miles for a rural area. This measure shows that an estimated 19 million people, or 6.2 percent of the U.S. population, live in low-income and low access tracts and are more than 1 mile or 10 miles from a supermarket.\n- Low-income census tracts where a significant number (at least 500 people) or share (at least 33 percent) of the population is greater than 1.0 mile from the nearest supermarket, supercenter, or large grocery store for an urban area or greater than 20 miles for a rural area. Under this measure, an estimated 17.3 million people, or 5.6 percent of the U.S. population, live in low-income and low access tracts and are more than 1 mile or 20 miles from a supermarket.\"","e92cac16":"We can check to see if there are actually duplicates by using the `.value_counts()` method","48b26850":"We will select a radius that is the distance between two adjacent points. This will cause some amount of overlap, but it will also maximize the chances a relevant store will be returned, if it is not retured from another point for some reason.","ecca02f2":"# 2. Poverty information\n### Now that we have the census tract boundaries, we can look at poverty rates across them. For that we will import poverty count data","7fc9efde":"Determining \"rural\" census tracts is difficult, since urban areas are determined by population level, and census tracts are drawn to have approximately equal population levels. Luckily, Davidson County has outlined the **Nashville Urban Services District**, so let's start by comparing the urban area with the census tracts:","2f70595d":"---","c558d819":"##### This cell will not run since no `api_key` is provided","da8cff34":"Let's start by importing the packages we are going to use to facilitate our analysis:","e420c3a5":"Since python is index base 0, to get the first row of the GDF we put `0` in the first position in the brackets. Additionally, since we wanted the \"geometry\" column, we put `'geometry'` in the second position in the brackets.","d75a1d3a":"Here we're taking just a part of the the strings in the `geoid` column, so that it lines up with the `GEOID` column from the `davidson_tracts` gdf","c77e65bd":"Here we are creating a new column that divides the number below the poverty level in the past 12 months by the total population","25e7443d":"# 4. Location of supermarkets and farmers markets\n\nFinding all the grocery stores that can be accessed by Davidson County residents is a little tough. There are a few curated lists, but they are behind a paywall and may be out of date. An alternative approach would be to use the Google Maps API to get the locations of Supermarkets and other stores.\n\nThis is a time consuming process and the setup is somewhat involved. For the sake of time we will just talk at a high level for finding stores using the Google Maps API. The code and explanation for performing the search is included at the bottom of this notebook.\n\nGenerally, the process for searching for relevant stores was:\n1. Segment the search area into multiple grid point searchs\n2. Iterate over all the search areas for all possible stores\n3. Clean and label data\n\nWe'll pick up with the cleaned output from the store search","85b8ddfe":"Looking at the `head` we can see that the first 3 rows seem to be aggregate data for the US, Tennessee, and Davidson County. Since we're only interested in the tract level data, we can remove those first 3 rows using the `.drop()` method:","0f4fe28d":"By converting the coordinate pairs to `point` objects, we can put them into a geodataframe and then we can easily perform a number of geographic calculations.","cc55febe":"Once we isolated the lat and lng, since they were in a `dictionary` we can convert it to a `Series` using `pd.Series()`. A single column or row in a DataFrame is a `Series`, and by converting the lat and lng to a `Series` we can easily attach it to another `Series`.","0220e202":"# Food Deserts in Davidson County\n\n### In this workshop we will cover:\n- Using `pandas` for working with data\n- Plotting and manipulating geospatial data\n- Subsetting, editting, filtering, aggregating, combining and analyzing data\n- Traversing complex objects\n- Writting functions and for loops\n- Accessing and parsing data through webscraping (and APIs)","697d96bf":"# 1. Census tract boundaries\nThe file we will be using is a shape file (`.shp`), which means there is geometry information as part of the file. We will see what this means in more detail a little later, but for now it means we will need to import the file with `geopandas` to preserve the geometry data. To do that we will use the `gpd.read_file()` function:","a27b6615":"Looks good! Let's keep going until we have the lat and lng. It looks like it's associated with the `location` key.","29ec0510":"For the census tract in row 2 of the census tract df, 38% is more than a mile from a fresh food source, indicating it has low food access.","54129abe":"### Now that we have the poverty rates for each tract, we can combine these data with our geographic data and visualize the tracts with >= 20% poverty.","82014ba1":"This is an intimidating mess but let's just look at the very beginning instead of trying to understand all of it at once. Inside the `div` there seems to be another attribute called `data-middlejson`. Since its called a json, let's see if we can pull out that piece and decode it as a json.","b95a5d2a":"We can see that all the points are within the search area. The reason there is an additional circle in the search area is because Davidson County has a part that is disconnected from the main area.\n\nNow that we have all the coordinate points we want to search nearby, we can figure out what an appropriate radius would be. The radius is measured in meters. Measuring distance with lat and lng is a little different since you need to take into consideration the curviture of the earth. To do that we can use the `haversine distance` formula.","88980f53":"#### To streamline our analysis we'll use these criteria for defining a food desert:\n1. Low income: Poverty level in a census tract is >= 20%\n2. Low access: At least 33% of the census tract is >1 mile from a fresh food source in urban areas or >10 miles for rural areas","2815d205":"We will not add buffers for a 10 mile radius since those will obscure much of the map. ","76ad7519":"We can see all the boundaries of all the census tracts together by applying the `.boundary.plot()` method to the `tennessee_tracts` GDF:","e88b827c":"#### Based on these criteria we need to know:\n1. Census tract boundaries\n2. Poverty information\n3. **Urban** or **rural** census tract\n4. Location of supermarkets and farmers markets\n\nWe can then combine these data to find the proportion of low-income census tracts that are too far away from sources of fresh food, resulting in a possible food desert.","9eeca40d":"Google Maps has many API endpoints, the one we'll use is the `nearbysearch` endpoint. For that we'll need to supply a **coordinate point**, a **radius**, and the **type** of store(s) to search for. The API does have limits so to make sure we are getting all the data we're expecting, we have to break the search down into smaller pieces. \n\nWe can add a grid to the expanded search area to break the search down into smaller pieces. We'll start by finding the absolute x and y boundaries of the search area:","24bebb84":"It turns out the value in the field is a string, even though it looks like a dictionary. It will be much easier to work with the data if it were a dictionary. Luckily there is a function that converts a string to the actual data type: `literal_eval()` from the `ast` package. Let's use that and verify the change happened as we expected:","8660e494":"To fully search for all stores across the entire county we would have to search each grid point for each store type. That will take a very long time. Additionally, it would require setting up an app on google to use for making the API requests. I've already run the code but we can walk through the steps for getting the data.\n\nThe function for actually making the API calls is here:","35b6c7ae":"Now we know how to pull out just the lat and lng from the `geometry` column. We can use those to create point objects and put it into a GeoDataFrame to plot all the store locations on a map. We can use `.apply()` again here. So let's make a custom function to extract the lat and lng, create a point object, and then add it to a new column.","e625de69":"We can see that some tracts are completely urban, others are completely rural, and some are in between. Our threshold of 0.5 seems to be working as expected.\n\nOne important thing to consider is where to search for grocery stores. In general this seems obvious, but we should also consider the (literal) edge cases. For residents living at the edges of Davidson County, a grocery store could be within a mile _outside_ of the county limits. Additionally, the definition of a food desert is different for urban vs. rural areas. Urban areas look for grocery stores within _1_ mile, while rural areas look for grocery stores within _10_ miles.\n\nSince there are rural tracts, we know we need to expand our search area to 10 miles around Davidson County, we can do that by creating a new GeoPandas object where a `buffer` is added around the county.\n\nGeopandas buffers are calculated based on the Coordinate Reference System (CRS) of the gdf. The one we are using has degrees as units. Using this conversion from the USGS (https:\/\/www.usgs.gov\/faqs\/how-much-distance-does-a-degree-minute-and-second-cover-your-maps?qt-news_science_products=0#qt-news_science_products): \"One degree of latitude equals approximately 364,000 feet (69 miles), one minute equals 6,068 feet (1.15 miles), and one-second equals 101 feet.\" We can approximate the number of degrees in a mile as: 1\/69 = 0.014492753623188406","f5ff193a":"Now that it is parsed and saved into the variable `soup` we can pull out the pieces we want. The top level pieces is the object with the `id` of `middle`","b8186e1b":"The tracts in **gray** are above 20% poverty, while the ones in **red** are below 20% poverty","ed50d72e":"In order to merge the two data sets we need to make sure they both have a column in common. We can accomplish this by extracting the census tract name from the `name` column in the poverty rates df.","2dc995f1":"We can see that Davidson County is entirely covered, as well 10 miles surrounding.","f927d8e9":"Let's get the outline of Davidson county as well","230b2287":"# Summary:\n\nIn this analysis we combined multiple data sources to identify possible food deserts in Davidson County. The critera we followed to identify a food desert were:\n\n1. Poverty level in a census tract is >= 20% (low income)\n2. At least 33% of the census tract is >1 mile from a fresh food source in urban areas or >10 miles for rural areas (low access)\n\nThe steps we took to evaluate these critera were:\n\n1. Use geographic data to define census tracts\n2. Use census data to determine poverty level in each census tract and highlight ones that were >= 20%\n3. Use the Nashville Urban Service area to separate urban and rural tracts\n4. Use data gathered from the Google Maps API to find supermarkets in and around Davidson County\n5. Use data scraped from https:\/\/www.picktnproducts.org\/ to find Farmers Markets in and around Davidson County\n6. Use geometric calculations to determine at least 33% of a census tract is >1 mile from a fresh food source\n7. Combine data to determine census tracts that are low income and have low access to fresh food to identify possible food deserts\n \n\n\n# Future directions:\n\nIdentifying food deserts is a complex problem with many factors to consider. Our analysis considered some, but not all factors that influence food deserts. Some additional factors to consider are:\n\n- Individual vehicle availability in census tracts\n- Public transportation in census tracts\n- How easy it is to walk to stores (existance of sidewalks, if the path follows side roads or main roads)\n- If stores are authorized to accept Supplemental Nutrition Assistance Program (SNAP) benefits\n- Percentage of different housing types, such as group quarters, which include \"dormitories, military bases, assisted living or skilled nursing facilities, and other large institutions\" (https:\/\/www.ers.usda.gov\/data-products\/food-access-research-atlas\/documentation)\n\nThere are also a number of ways we could improve on the analysis. These include:\n\n- Developing a method that more rigorously determines if a store sells fresh food and find additional sources of fresh food\n- Clearly defining urban vs. rural tracts\n- Use more updated data (will be possible when the current census data are available)\n\nLastly, there are many ways we can build on the current study:\n\n- Scale of food desert. Food deserts can be ranked based on different distance thresholds (0.5 mi from grocery store, 1 mi from grocery store, >1 mi from grocery store)\n- As mentioned previously, the impact of dollar stores on food deserts is an area of investigation. Analyzing any potential correlation between dollar stores, sources of fresh food, and food deserts could be very useful\n- Demographic breakdown for each census tract (age, sex, race) to determine if some populations are disproportionately affected\n- Investigate food deserts over time to see how they have shifted\n- Analyze the impact of programs aimed to address food security issues on food deserts","271c33b9":"### Now with grid points laid out across county we can figure out which types of stores to look for.\n\nGoogle Maps has a number of business types (https:\/\/developers.google.com\/places\/supported_types). Looking through them, all relevant store types are these:","e90d3aaf":"# 3. Urban or rural census tract\n\n### Now we know which tracts have above 20% poverty, we can find stores that sell fresh produce. But first we need to determine where to look so we'll start by categorizing tracts as urban or rural","da088a0a":"At this point we can start to see with more clarity where the food deserts actually are. To really nail it down, let's calculate the exact proportion of each census tract that is too far away from a fresh food source.\n\nThere are many ways we can accomplish this, but an easy way is to combine all the store buffers into a single shape, then check the proportion of each tract that overlaps with that shape. Since we are differentiating rural and urban tracts, let's also make different store buffers to check against.\n\nTo combine the buffer shapes, we can use the `unary_union()` function:","95f9ad97":"We can take the same approach as before to calculate amount of overlap.","3a020cc2":"To keep stores within our areas of interest we'll use a different approach from `.apply()`. This time we'll use `.iteritems()` and a for loop.\n\n`.iteritems()` will take each item in a `Series` and perform whatever is inside the for loop. Inside the for loop we are checking if a given point is inside the buffered Davidson County shape. Remember that the county shape actually has two parts that are not directly connected, so we have to check both parts. With that we can keep the stores inside our areas of interest.\n\nTo cut down on the number of dfs we have to work with, let's keep all the stores in the rural area, since the urban area is contained within there, and then add a column to indicate if the store is valid for only rural tracts or both","c28d4020":"Since we also have urban tracts at the edge of Davidson County, we can also create another variable that uses a 1 mile buffer","a5744ce8":"Since we are interested in if a tract is above 20% poverty, we can add a new column that indicates if a tract is above or below 20%","66eeaf01":"The points are forming a grid as we expected. You'll notice that the grid is a square, but our search area is not. Our next step is to keep only the points in our search area. ","e80f47be":"# Creating a search grid and using the Google Maps API to search for grocery stores","c37a4305":"Most of the columns are identifiers of some kind. The important column is the `geometry` column, which contains the information about the census tract boundaries. We can look more closely at the geometry of one census tract by _**slicing**_ the gdf to just the data we are interested in. We can do that using the `.loc[<row_index>, <column_index>]` method.","ce7d291a":"Success! We've managed to extract the farmers market data into a usable format. And there is also a `latitude` and `longitude` column! There are some rows that we won't need since they are outside of Davidson. We can't strictly rely on the `storeCounty` column, since there may be a Farmers Market that is just outside of Davidson but still within 10 miles. Let's add a point geometry column and then keep all the markets that are within it.","a01491af":"As we saw when we viewed the page source, html is messy and difficult to traverse. Luckly, there's a package for that. `BeautifulSoup` can take the html and parse it, making it easier for us to grab the pieces we want. In this case it is parsing using an `lxml` parser.","8adb7996":"Now with the url, we can make a `GET` request, which will go out and grab all the info off the site. ","9187eecb":"We can visualize the search area for each point on our map to make sure our entire search area is covered.","3cbbd04c":"Now that the lat and lng are in their own columns we can use the `gpd.points_from_xy()` function to make the `geometry` column that will be used to plot the store locations on the map. First let's change the name of the original `geometry` column so that there isn't any confusion. We can do that using the `.rename()` method again.","bdf750e3":"Here we are asking a question if the value in the `pct_below_poverty_level` is greater than 0.2. This will return a boolean (True\/False). Then the results are converted to integers, where `True` becomes `1` and `False` becomes `0`","706e4066":"Now we can proceed with setting up the search grid:","11d39cf6":"Now we have something we can work with! A list of dictionaries is something that pandas can easily parse. Let's try putting this into a DataFrame.","df578fab":"### Farmers Markets are places where fresh food is available but are often overlooked.\n`Pick Tennessee` luckily has a list of all the farmers markets. We can use webscraping to get that information and add it to our data. Let's start by taking a look at the `Pick Tennessee` website: https:\/\/www.picktnproducts.org\/listview\/farmers-market.html","94cb65eb":"Based on a little experimentation, a good spacing for the grid points is by dividing the total bounds for Davidson County itself by 10. So let's do that now:","fbe31d60":"Here we are again filtering our data, this time paying attention to the `name` column and identifying rows if the word `Dollar` is in the name. Since `name` contains only text objects, called _strings_ , we have to use a _string_ function to search within it. This is why we need to search the `name` column using the method `.str.contains()`. The `~` reverses the True\/False so the rows that originally returned False are kept, meaning we will keep everything that does not have `Dollar` in the name.","21c3c38f":"We only want the `Urban Services District`","c1da3936":"Above we are combining a few techniques. We are filtering the rows in `stores_df` based on the criteria inside the outer `[]`. We are `apply`ing the criteria to the contents of the `types` column. The `lambda` function is how we're determining which rows we want.\n\nA `lambda` function is an `anonomyous` function, meaning it is not given a name or saved to the environment, instead it is created and used on the fly. Since it is created on the fly, it tends to be more abstract. In this case the function takes one argument `x`, and checks to see if `'supermarket'` is in `x`. Though it isn't explicitally stated, the `lambda` function will return what ever the final output is, in this case a `True` or `False`. As before, we are applying this function to each row in the `types` column, so we will get back a `True` or `False` for each row in the df and keep only the `True` rows.","d7b4594d":"Looking at the columns we can see that the data show the `Total` population for a tract, as well as the number below the poverty line in the past 12 months, both over all and broken down by sex and age range. We can use the number below the poverty line and the total population to determine the percent below the poverty level for each tract:","aaadc907":"To systematically search the entire county for all store types I made a nested for loop that will search for each store type across all grid points and append the responses to the master list.","29b5b901":"Now we can see the duplicates have been removed","66ceda91":"## Now that we have our possible food deserts, let's overlay them on a map and see where they are located","794bb0c7":"From this we can see that the object type is indeed a `Polygon`, and when we `print` the contents we can see the full data stored in the object: coordinate pairs that indicate the corners of the tract outline.","fdaf8142":"We can see that only keeping rows that have a `type` of `'supermarket'`, greatly reduces the number of stores. Also, in general this seems to be filtering how we want it to filter (we can see many **Publix** stores), but we can also see things that maybe shouldn't be there (like **Dollar General**). \n\nThe influence of dollar stores on food deserts is an area if interest (https:\/\/www.cbsnews.com\/news\/dollar-stores-and-food-deserts-the-latest-struggle-between-main-street-and-corporate-america\/). Though some sources indicate that they do not sell fresh produce, the Dollar General website indicates that produce is available in their stores (https:\/\/www.dollargeneral.com\/catalogsearch\/result\/?q=produce) but there is no category for fresh foods (https:\/\/www.dollargeneral.com\/food.html).\n\nFor this analysis we will exclude dollar stores from _stores selling fresh food_. That means we will need to remove them from our list.","f84eb026":"The urban area roughly overlaps with census tracts but not fully. For this analysis let's say if at least 50% of the tract is in the urban area, then it is an urban tract.\n\nDetermining how much of a shape overlaps with another is actually relatively straightforward. We can first subtract the urban area from a given tract, which will leave us with the tract area _outside_ of the urban area. Then we can divide that value by the total area of the tract. That will give us the proportion of the tract that is **rural**. We will use the `.area` attribute to work with numeric values. Once we have the ratio, we can determine `True` or `False`, is the ratio greater than 0.5. If it is, then the tract is **rural**\n\nOne good approach to determine if each tract is urban or rural is the `.apply()` method. This method will take a function, and _apply_ it to each row. There is no pre-built function to check if a tract is urban or rural so let's make our own!","6d28c6f5":"What the above code is saying is take only rows from the `tennessee_tracts` gdf where the value in the `'COUNTYFP'` column is equal to `'037'`. Since we are only taking some of the rows from the middle, the labels for the rows will be off. `.reset_index(drop = True)` will remove the old labels and add back new ones that start at `0`\n\nLet's take a look at what we're left with:","515d32b9":"# But First:\n- Zoom orientation\n- https:\/\/www.kaggle.com\/raomahesh\/nashville-food-deserts","fc01c7ff":"Looking at the first few rows of `stores_gdf`, we can see a **Twice Daily** and a **Panera Bread**, which aren't actually what we want. Let's try and filter down our stores to just ones that are classified as `supermarket`s:"}}