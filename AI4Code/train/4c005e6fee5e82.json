{"cell_type":{"ccbee3d2":"code","6e0c040c":"code","3f4e7b29":"code","40ddad4c":"code","d3860bc7":"code","ad0a2b5e":"code","bc6f1598":"code","cb942326":"code","e750ee8c":"code","31daed8b":"code","364db27e":"code","16876918":"markdown","a0efe01f":"markdown","f60537d9":"markdown","131a9c50":"markdown","f233e7d5":"markdown","995cfd27":"markdown","a07deb3f":"markdown","9bcc99f4":"markdown","e72d4bfd":"markdown","819654dc":"markdown"},"source":{"ccbee3d2":"import numpy as np\nimport pandas as pd\nfrom google.cloud import bigquery\n\nclient = bigquery.Client()\nquery = \"\"\"\nSELECT from_address, \n    to_address\nFROM `bigquery-public-data.crypto_ethereum_classic.transactions` \nGROUP BY from_address, to_address\nORDER BY from_address ASC   \n    \n\"\"\"\ndf = client.query(query).to_dataframe()\ndf.describe()","6e0c040c":"df = df.dropna()\ndf.describe()","3f4e7b29":"!conda install --yes --override-channels -c ostrokach-forge -c pkgw-forge -c conda-forge gtk3 pygobject graph-tool","40ddad4c":"import graph_tool.all as gt\n\ng = gt.Graph(directed=True)\n\n# populate the graph with vertices and store their references in a dict that\n# uniquely maps each address to a vertex\nvertex_map = set(pd.concat([df['from_address'], df['to_address']], axis=0))\nnew_vertices = g.add_vertex(len(vertex_map))\nvertex_map = dict(zip(vertex_map, new_vertices))\n\n#add edges\ndef edge_map(e):\n    return (vertex_map[e[0]], vertex_map[e[1]])\nedge_list = map(edge_map, df[['from_address', 'to_address']].itertuples(index=False, name=None))\ng.add_edge_list(edge_list)","d3860bc7":"comp, hist = gt.label_components(g, directed=False) #outputs a histogram of the # of vertices belonging to each component\nprint(\"The graph has\", len(hist), \"components\")\nprint(\"the largest component has\", max(hist), \"vertices, %{:.2f} of the total.\".format(100*max(hist)\/len(g.get_vertices())))\nprint(\"the 2nd and 3rd largest components have {:d} and {:d} vertices respectively\".format(sorted(hist, reverse=True)[1], sorted(hist, reverse=True)[2]))","ad0a2b5e":"import random\nfrom tqdm import tqdm\nfrom multiprocessing import Pool\n\nsample_size = 10000\n\n#get those vertices that belong to the largest component\ncomp = gt.label_largest_component(g, directed=False)\nvertices_subset = [i for i, x in enumerate(comp) if x]\n\n#randomly select vertex pairs\nsource_samples = random.choices(vertices_subset, k=sample_size)\ntarget_samples = random.choices(vertices_subset, k=sample_size)\nsample_pairs = zip(source_samples, target_samples)\n\ndef get_shortest_distance(pair):\n    return gt.shortest_distance(g, pair[0], pair[1], directed=False)\npool = Pool(4)\ndistance_list = list(tqdm(pool.imap(get_shortest_distance, sample_pairs), total=sample_size))\npool.close()\npool.join()","bc6f1598":"import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10,5))\n# plt.yscale(\"log\")\n# plt.xscale(\"log\")\nplt.title('Histogram of Minimum Path Length Between Vertex Pairs')\nplt.xlabel('Shortest Path Length')\nplt.ylabel('Count')\n\nbins = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, np.inf]\nhist, _ = np.histogram(distance_list, bins)\n\nplt.xticks(range(len(bins)), bins[:-2] + ['{}+'.format(bins[-2])])\nplt.bar(range(len(hist)), hist, width=1)\nplt.show()","cb942326":"import datetime\nstart_time = datetime.datetime.now()\n\nclustering = gt.global_clustering(g)\nprint(\"computation time:\", datetime.datetime.now() - start_time)\nprint('The clustering coeficient of the transaction network is:', clustering[0])","e750ee8c":"import matplotlib.pyplot as plt\n\ndegrees = g.get_out_degrees(g.get_vertices())\nplt.figure(figsize=(15,5))\nplt.yscale(\"log\")\nplt.xscale(\"log\")\nplt.xlabel('Vertex Degree')\nplt.ylabel('Count')\n\nplt.hist(degrees, max(degrees))\n\nplt.show()","31daed8b":"comp, hist = gt.label_components(g, directed=True) # label strongly connected components\ncondensed_g, _, vcount, _, _, _ = gt.condensation_graph(g, comp) # generate a new graph from component labels\n\nprint(\"# of vertices in the original graph:\", len(g.get_vertices()))\nprint(\"# of strongly connected components in the original graph:\", len(hist))\nprint(\"# of vertices in the condensed graph:\", len(condensed_g.get_vertices()))","364db27e":"import datetime\n\nstart_time = datetime.datetime.now()\npos = gt.sfdp_layout(condensed_g, epsilon=2.0, pos=None, verbose=True)\nprint(\"computation time:\", datetime.datetime.now() - start_time)\ngt.graph_draw(condensed_g, pos=pos, output_size=(5000, 5000),vertex_size=1.0,  edge_pen_width=0.1)","16876918":"# Graph Visualization\nSince the graph is so large, it is wise to reduce the number of vertices that are to be drawn both to improve the readability of the visualization and to bring the down the computation time. \n\nWe will generate a condensed version of the graph by taking all vertices belonging to the same [strongly connected component](https:\/\/en.wikipedia.org\/wiki\/Strongly_connected_component) and replacing them with a single vertex. When done for each strongly connected component, the result is a graph that represents connections between communities of addresses as well as individual addresses.","a0efe01f":"Here is where we install graph-tool","f60537d9":"# Clustering Coeficient","131a9c50":"Next, we'll create the directed graph object.","f233e7d5":"# Introduction\n\nIn this kernel we will explore the interconnectedness of addresses on the Ethereum Classic blockchain when viewed as a directed graph where each vertex represents an address and edges connect addresses that have transacted. To achieve this, we will leverage the module [graph-tool](https:\/\/graph-tool.skewed.de\/), chosen for its performant C++ implementation and ability to visualize large graphs.\n","995cfd27":"First we'll investigate whether the graph is connected (ignoring directionality) and if not, the number of components.","a07deb3f":"In the next cell, we will generate a visualization of the condensed graph using the [SFDP layout algorithm](https:\/\/www.mathematica-journal.com\/issue\/v10i1\/graph_draw.html) which has $ O(V\\log V) $ time complexity with $V$ being the number of vertices.\n\n**The next cell takes a very long time to execute**","9bcc99f4":"We can see that there is a discrepancy between the to and from address columns, implying that there are `None` values present in the data. Without prior knowledge explaining the presence of these, the only choice is to drop them from the dataframe","e72d4bfd":"# Average smallest path length\n\nSince the graph is so large, it is computationally prohibitive to determine the average smallest path length by exhaustively finding the smallest path between each pair of vertices. Instead, we will take a Monte-Carlo approach to approximate the average smallest path length by selecting a random subset of vertex pairs. We'll only look in the largest connected component since it accounts for %98.77 of the vertices in the graph and we want to make sure a path exists between each vertex pair.\n\nHere we will view the graph as undirected and therefore consider each transaction as a relationship between vertices, regardless of direction.\n","819654dc":"# Degree Histogram\nGenerate a histogram of the vertex degrees present in the network."}}