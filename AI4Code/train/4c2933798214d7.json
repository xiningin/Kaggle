{"cell_type":{"d7ca8bdf":"code","3c6033ae":"code","19a90500":"code","dde4cd72":"code","1383399d":"code","d23dc3cf":"code","ffc99f3e":"code","073cde85":"code","c313567c":"code","cc6e2348":"code","2e91db27":"code","b6185612":"code","c1c53b3f":"code","0d7ae0a8":"code","d2d6449b":"code","593ad2a2":"code","8afd2c74":"code","21d59740":"code","b709e8d8":"code","c116713a":"code","26710eb0":"code","9a76fbe4":"code","38b0672e":"code","0aeebe57":"markdown","07cb168b":"markdown","fd7ec552":"markdown","1580ea76":"markdown","aa52432f":"markdown","31dc9578":"markdown","0a601e17":"markdown","e39696dc":"markdown","ee1d706a":"markdown","e54a8395":"markdown","dbc752d9":"markdown","6d76043e":"markdown","b503df23":"markdown","d8923d3d":"markdown"},"source":{"d7ca8bdf":"import time\nimport pandas as pd\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\nimport matplotlib.collections as mcoll\nfrom itertools import chain\nfrom itertools import combinations\nfrom itertools import permutations\nfrom itertools import product\nfrom sklearn.neighbors import NearestNeighbors","3c6033ae":"def initial():\n    df = pd.read_csv('..\/input\/traveling-santa-2018-prime-paths\/cities.csv')\n    df['Z'] = 1 + .1 * ~df['CityId'].apply(sp.isprime)\n    data = df[['X', 'Y', 'Z']].values\n    tour = np.loadtxt('..\/input\/traveling-santa-lkh-solution\/pure1502650.csv', \n                      skiprows=1, dtype=int)\n    return tour, data\n\ntour, data = initial()","19a90500":"data[:5]","dde4cd72":"tour[:5]","1383399d":"def distance(tour, data, pen=9):\n    xy, z = np.hsplit(data[tour], [2])\n    dist = np.hypot(*(xy[:-1] - xy[1:]).T)\n    dist[pen::10] *= z[:-1][pen::10].flat\n    return dist\n\ndist = distance(tour, data)\ndist","d23dc3cf":"distance(tour[3:9], data, pen = 9 - 3 % 10) == dist[3:8]","ffc99f3e":"f'Initial Score: {np.sum(dist):.2f}'","073cde85":"def candidates(data, opt, ext):\n    nns = NearestNeighbors(n_neighbors=opt + ext).fit(data[:, :2])\n    kne = nns.kneighbors(data[:, :2], return_distance=False)\n    np.random.shuffle(kne)\n    cand = set()\n    for i in kne:\n        for j in combinations(i[1:], opt - 1):\n            cand.add(tuple(sorted((i[0],) + j)))\n    return cand","c313567c":"list(candidates(data, opt=3, ext=0))[:5]","cc6e2348":"len(candidates(data, opt=2, ext=0))","2e91db27":"len(candidates(data, opt=2, ext=1))","b6185612":"def alternatives(tour, cuts, fil):\n    edges = [tuple(x) for x in np.split(tour, cuts)[1:-1]]\n    a, b = tour[cuts[0] - 1], tour[cuts[-1]]\n    alter = set()\n    for i in set(product(*zip(edges, [x[::-1] for x in edges]))):\n        for j in permutations(i):\n            if not fil or all(x != y for x, y in zip(edges, j)):\n                alter.add(tuple(chain((a,), *j, (b,))))\n    alter.discard(tuple(chain((a,), *edges, (b,))))\n    return alter","c1c53b3f":"# edges\ntour[2:5], tour[5:7]","0d7ae0a8":"# a, b\ntour[1] , tour[7]","d2d6449b":"alternatives(tour, cuts = [2,5,7], fil=False)","593ad2a2":"alternatives(tour, cuts = [2,5,7], fil=True)","8afd2c74":"def submit(tour):\n    np.savetxt('submission.csv', tour, fmt='%d', header='Path', comments='')","21d59740":"def kopt(opt, ext, fil):\n    tour, data = initial()\n    sequ = 1 + np.argsort(tour[1:])\n    dist = distance(tour, data)\n    print(f'opt:{opt} & ext:{ext} & fil:{fil} ...')\n    cand = candidates(data, opt, ext)\n    print(f' Initial Score:\\t{np.sum(dist):0.2f}')\n    for c in cand:\n        cuts = sorted(sequ[j] for j in c)\n        alter = alternatives(tour, cuts, fil)\n        if not alter:\n            continue\n        atour, pen = np.array(list(alter)), 9 - (cuts[0] - 1) % 10\n        adist = np.array([distance(x, data, pen) for x in atour])\n        if np.any(np.sum(adist, 1) < np.sum(dist[cuts[0] - 1:cuts[-1]])):\n            arg = np.argmin(np.sum(adist, 1))\n            dist[cuts[0] - 1:cuts[-1]] = adist[arg]\n            tour[cuts[0]:cuts[-1]] = atour[arg][1:-1]\n            sequ[atour[arg][1:-1]] = range(cuts[0], cuts[-1])\n    print(f' Final Score:\\t{np.sum(dist):0.2f}')\n    submit(tour)","b709e8d8":"t0 = time.time()\nkopt(opt=2, ext=0, fil=False)\nprint(f'Time:\\t{time.time()-t0:.2f}s')","c116713a":"t0 = time.time()\nkopt(opt=2, ext=1, fil=False)\nprint(f'Time:\\t{time.time()-t0:.2f}s')","26710eb0":"t0 = time.time()\nkopt(opt=3, ext=0, fil=False)\nprint(f'Time:\\t{time.time()-t0:.2f}s')","9a76fbe4":"t0 = time.time()\nkopt(opt=4, ext=0, fil=True)\nprint(f'Time:\\t{time.time()-t0:.2f}s')","38b0672e":"def graph():\n    tour, data = initial()\n    xy = data[tour][:, :2]\n    segm = np.hstack((xy[:-1], xy[1:])).reshape(-1, 2, 2)\n    lc = mcoll.LineCollection(segments=segm,\n                              array=np.linspace(0, 1, len(segm)),\n                              cmap=plt.get_cmap('Spectral'),\n                              lw=.9)\n    fig, ax = plt.subplots(figsize=(10,8))\n    fig.subplots_adjust(left=0, bottom=0, right=1, top=1)\n    ax.add_collection(lc)\n    ax.plot(*xy.T, lw=.3, c='black')\n    plt.show()\n    \ngraph()","0aeebe57":"To compute the initial score just sum it:","07cb168b":"**SUBMISSION**\n\nEasy.","fd7ec552":"**BUILDING ALTERNATIVE PATHS**\n\nTrying to speedup things, I've provided a filter to just considerate the alternatives that change every edge position (reverse or move). Note that to calculate the distances I need to include the previous and the last cities of the chunk -> (a, b).","1580ea76":"For example, considering cities in indexes (2, 5, 7):","aa52432f":"Some runs:","31dc9578":"**GENERATING CANDIDATES**\n\nI use NearestNeighbors from [scikit-learn](https:\/\/scikit-learn.org\/stable\/modules\/neighbors.html) to get a set of cities to play with:","0a601e17":"**K-OPT**\n\nUsing the previous functions here's the final one, it's really simple as you can see.  I check if there's any alternative that reduces the distance and if that's the case I take the minimun one and modify the tour and dist arrays.","e39696dc":"**LOADING CITIES & SUBMISSION**\n\nWhile loading the data,  I create a third dimension 'Z' to apply the penalty as fast as posible. As input I'm going to use a LKH solver solution provided by [Kostya Atarik](https:\/\/www.kaggle.com\/kostyaatarik\/traveling-santa-lkh-solution). (Thanks man)","ee1d706a":"**COST FUNCTION**\n\nCan be used to compute the whole tour or just tour chunks. I keep the result as an array because I will be changing the values of it during the process like the tour array. ","e54a8395":"When computing a tour chunk distance, the variable 'pen' goes from 0 to 9 depending on the relative position of the starting city in the tour, it's something like: \n\n    pen = 9 - index_of_starting_city_in_tour % 10\n\nSupose we want to compute the distances between cities in positions [3, 8] on tour, we can do this without computing the whole tour distance:\n\n*Note that between 6 cities there are 5 distances.","dbc752d9":"The 'ext' varible can be used to consider extra unique combinations:","6d76043e":"Hi everyone, \n\nI want to share with you a demo of the code I've been developing to improve some of the results published here. \nIt's a simple k-opt algorithm that works fast with k = 2, 3, 4... and maybe 5, up from that you have to be patient cause loops are huge.\n\nIt\u00b4s my first competition in kaggle and I feel like this was more like a \"hardware war\". As someone said in the discussion, in next editions would be nice to add more complexity to the problem and reduce the data amount. There's nothing I can do with my 8gb laptop... Anyway, here's the code.\n\nAny suggestions will be appreciated!\n\nThanks for reading.","b503df23":"**Bonus track: TOUR VISUALIZATION**\n\nA cool visualization to check your submission. You can use any of the colormaps from [matplotlib](https:\/\/matplotlib.org\/examples\/color\/colormaps_reference.html), just change 'Spectral' to whatever you want.","d8923d3d":"**IMPORTS**"}}