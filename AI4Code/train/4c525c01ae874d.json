{"cell_type":{"cbbe51c2":"code","bb32eec6":"code","6e7903ef":"code","c965a70b":"code","f66d1b3b":"code","20b043bb":"code","d228fb72":"code","1eb841a0":"code","c44de544":"code","a9c0424b":"code","d91b2933":"code","bf333ae2":"code","83f070a6":"code","a7b863a1":"code","edb38861":"code","f4c609c0":"code","0db40387":"code","8505b95c":"code","9cd24ef2":"code","1e8a76ac":"code","8d74c0ba":"code","760ce2a6":"code","7324be39":"code","a0f1976a":"code","bed8bfc0":"code","448590d9":"code","e984322e":"code","2238b42f":"code","b3520346":"code","926dfb3a":"code","c0965b29":"code","fa6a5183":"code","03f2fae3":"code","8346ba84":"code","2a1a0ce8":"code","49981859":"code","74df01c3":"code","dc73c448":"code","a56f55b5":"code","832449a3":"code","94ec9c51":"code","0141cf2b":"code","ef348890":"code","3f192188":"code","b733f8ca":"code","caede89d":"code","132c0256":"code","4501e3a2":"code","10f6012b":"code","b618dda2":"code","34d3e021":"code","a2087e4e":"code","cea43220":"code","8ec2b71f":"code","de9fae31":"code","a9544a29":"code","8caeb7d8":"code","81237b73":"code","dcad26fe":"code","9137d13d":"code","57be7fb2":"code","a1c1bc20":"code","e296511a":"code","08a32bde":"code","feb1bad0":"code","e2bbf428":"code","93e61fec":"code","19031c83":"code","31e40059":"code","23f94dcb":"markdown","4bf0ce74":"markdown","3a311458":"markdown","9529a1e3":"markdown","c69adf7c":"markdown","6546550d":"markdown","9f691c08":"markdown","d31977e0":"markdown","9dcca89e":"markdown","79861e90":"markdown","6377395d":"markdown","2497b93f":"markdown","bb1907c6":"markdown","5e3aeb3f":"markdown","f9283a56":"markdown","c476e9ff":"markdown","67afbef6":"markdown","9a9cc22d":"markdown","5f482795":"markdown","a4f06432":"markdown","acead852":"markdown","1992138e":"markdown","5890bbd1":"markdown","ff66a5e2":"markdown","ed1aeeeb":"markdown","bf6265b7":"markdown","10eabd60":"markdown","6503c8cf":"markdown","f40a5cdc":"markdown","1444dfc1":"markdown","7f62d361":"markdown","bb6bd7e4":"markdown","455dcc30":"markdown","9a61e786":"markdown","2900c822":"markdown","8df45ef4":"markdown","e3d4b4e7":"markdown","5ad5d718":"markdown","ae0f15f7":"markdown","1c706bbd":"markdown","41d0fa19":"markdown","b5d7d12e":"markdown","0fc21dd1":"markdown","1cf8a983":"markdown","0ab8f8be":"markdown","abd8229d":"markdown","ebc7fa7f":"markdown","712984ed":"markdown","9dc88ac0":"markdown"},"source":{"cbbe51c2":"pip install plotly==3.10.0","bb32eec6":"pip install pmdarima","6e7903ef":"pip install gluonts","c965a70b":"import matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom plotly import tools\nimport plotly.plotly as py\n\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport pandas as pd \nimport numpy as np\nimport requests\nimport io\nimport statsmodels.tsa.api as smt\nimport statsmodels as sm\nimport tensorflow as tf\nimport pmdarima as pm\nimport warnings\nimport xgboost as xgb\n\nimport lightgbm as lgb\nimport gluonts\nfrom math import sqrt\n\nimport shap\nwarnings.filterwarnings(\"ignore\") \n\nfrom statsmodels.tsa.ar_model import AutoReg\nfrom random import random\nfrom datetime import datetime\nfrom fbprophet import Prophet\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.graphics.tsaplots import plot_acf,plot_pacf\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.holtwinters import SimpleExpSmoothing, ExponentialSmoothing\nfrom sklearn import linear_model, svm\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error, make_scorer\nfrom sklearn.model_selection import cross_val_score, GridSearchCV\nfrom math import sqrt\nfrom xgboost import plot_importance, plot_tree\nfrom gluonts.model.deepar import DeepAREstimator\nfrom gluonts.mx.trainer import Trainer\nfrom gluonts.dataset.common import ListDataset\nfrom gluonts.evaluation.backtest import make_evaluation_predictions\nfrom itertools import islice\nfrom pylab import rcParams\n# progress bar\nfrom tqdm import tqdm, tqdm_notebook\nfrom bayes_opt import BayesianOptimization\nfrom scipy import stats\nfrom statsmodels.tsa.stattools import acf, pacf\nfrom statsmodels.tsa.arima_model import ARMA\nfrom statsmodels.tsa.arima.model import ARIMA\nimport gc","f66d1b3b":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","20b043bb":"bitcoin_data= pd.read_csv('\/kaggle\/input\/bitcoin-data\/btc_data_bi_hour.csv',parse_dates=['date','close time'])\nbitcoin_data['close time'] = pd.to_datetime(bitcoin_data['close time'], unit='ms')\nbitcoin_data.set_index('date',inplace=True)\nbitcoin_data.head() ","d228fb72":"bitcoin_data.drop('ignore',axis=1,inplace=True)","1eb841a0":"bitcoin_data.describe()","c44de544":"bitcoin_data.isna().sum()","a9c0424b":"values = bitcoin_data.values\ngroups = ['open', 'high', 'low', 'close', 'volume', 'quote asset volume', 'number of trades', 'taker buy base asset','taker buy quote asset volume']\ni = 1\nfig = plt.figure(figsize=(20, 50))\n# plot each column\nfor group in groups:\n    fig.add_subplot(len(groups), 1, i)\n    x=bitcoin_data.index\n    plt.plot(x,bitcoin_data[group])\n    plt.title(group, y=1, loc='right')\n    i += 1\n    \nplt.grid()    \nplt.show()","d91b2933":"plt.figure(num=None, figsize=(30, 10), dpi=80, facecolor='w', edgecolor='k')\nplt.title('btc price',fontsize=30)\n\nplt.plot(bitcoin_data.open)\nplt.savefig(\"\/kaggle\/working\/btcprice.png\")","bf333ae2":"rcParams['figure.figsize'] = 60, 40\nplt.figure(num=None, figsize=(50, 20), dpi=80, facecolor='w', edgecolor='k')\nseries = bitcoin_data['open']\nresult = seasonal_decompose(series, model='additive',freq=24)\nprint('to better observe the output check PNG files.')\nresult.plot()\nplt.savefig(\"\/kaggle\/working\/additive_seasonal_decomp.png\")\npass","83f070a6":"rcParams['figure.figsize'] = 60, 40\nplt.figure(num=None, figsize=(50, 20), dpi=80, facecolor='w', edgecolor='k')\nseries = bitcoin_data['open']\nresult = seasonal_decompose(series, model='multiplicative',freq=1440)\nprint('to better observe the output check PNG files.')\nresult.plot()\nplt.savefig(\"\/kaggle\/working\/multi_seasonal_decomp.png\")\npass","a7b863a1":"test_adfuller_result = adfuller(bitcoin_data.open)\ntest_adfuller_result","edb38861":"def moving_average_s(data,periode):\n    '''simple moving average'''\n    periode_rolling = data.rolling(window=periode).mean()\n    return periode_rolling","f4c609c0":"def get_rollling_dict(begin,end,step,data):\n    MA={}\n    for i in range(int(end\/step)):\n        steps=begin+i*step\n        MA['moving_avg_'+str(steps)+'_steps']=moving_average_s(data.open,steps)\n    return MA","0db40387":"begin,end,step,data=50,600,75,bitcoin_data","8505b95c":"MA=get_rollling_dict(begin,end,step,data)","9cd24ef2":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=bitcoin_data.index,\n        y=bitcoin_data.open,\n        mode='lines',\n        name ='Open Price'\n        \n))\n\nfor i in range(len(MA)):\n    steps=begin+i*step\n    list_rolling=MA['moving_avg_'+str(steps)+'_steps']\n    fig.add_trace(go.Scatter(\n        x=list_rolling.index,\n        y=list_rolling.loc[:],\n        mode='lines',\n        name ='moving_avg_'+str(steps)+'_steps'\n        \n))\n\n\nfig.show()","1e8a76ac":"begin,end,step,data=20,100,20,bitcoin_data","8d74c0ba":"MA=get_rollling_dict(begin,end,step,data)","760ce2a6":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=bitcoin_data.index,\n        y=bitcoin_data.open,\n        mode='lines',\n        name ='Open Price'\n        \n))\n\nfor i in range(len(MA)):\n    steps=begin+i*step\n    list_rolling=MA['moving_avg_'+str(steps)+'_steps']\n    fig.add_trace(go.Scatter(\n        x=list_rolling.index,\n        y=list_rolling.loc[:],\n        mode='lines',\n        name ='moving_avg_'+str(steps)+'_steps'\n        \n))\n\n\nfig.show()","7324be39":"def moving_average_e(data,periode):\n    '''exponentially moving average'''\n    periode_rolling = data.ewm(span=periode).mean()\n    return periode_rolling","a0f1976a":"def get_rollling_dict(begin,end,step,data):\n    MA={}\n    for i in range(int(end\/step)):\n        steps=begin+i*step\n        MA['moving_avg_'+str(steps)+'_steps']=moving_average_e(data.open,steps)\n    return MA","bed8bfc0":"begin,end,step,data=50,600,75,bitcoin_data","448590d9":"MA=get_rollling_dict(begin,end,step,data)","e984322e":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=bitcoin_data.index,\n        y=bitcoin_data.open,\n        mode='lines',\n        name ='Open Price'\n        \n))\n\nfor i in range(len(MA)):\n    steps=begin+i*step\n    list_rolling=MA['moving_avg_'+str(steps)+'_steps']\n    fig.add_trace(go.Scatter(\n        x=list_rolling.index,\n        y=list_rolling.loc[:],\n        mode='lines',\n        name ='moving_avg_'+str(steps)+'_steps'\n        \n))\n\n\nfig.show()","2238b42f":"begin,end,step,data=20,100,20,bitcoin_data","b3520346":"MA=get_rollling_dict(begin,end,step,data)","926dfb3a":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=bitcoin_data.index,\n        y=bitcoin_data.open,\n        mode='lines',\n        name ='Open Price'\n        \n))\n\nfor i in range(len(MA)):\n    steps=begin+i*step\n    list_rolling=MA['moving_avg_'+str(steps)+'_steps']\n    fig.add_trace(go.Scatter(\n        x=list_rolling.index,\n        y=list_rolling.loc[:],\n        mode='lines',\n        name ='moving_avg_'+str(steps)+'_steps'\n        \n))\n\n\nfig.show()","c0965b29":"bitcoin_data['open_log']=np.log(bitcoin_data.open)","fa6a5183":"prices_log=np.log(bitcoin_data.open)","03f2fae3":"rcParams['figure.figsize'] = 60, 40\nplt.figure(num=None, figsize=(50, 20), dpi=80, facecolor='w', edgecolor='k')\nseries = prices_log\nresult = seasonal_decompose(series, model='multiplicative',freq=1440)\nprint('to better observe the output check PNG files.')\nresult.plot()\nplt.savefig(\"\/kaggle\/working\/multi_seasonal_decomp_log.png\")\npass","8346ba84":"test_adfuller_result_log = adfuller(prices_log)\ntest_adfuller_result_log","2a1a0ce8":"def get_rollling_dict_log(begin,end,step,data):\n    MA_log={}\n    for i in range(int(end\/step)):\n        steps=begin+i*step\n        MA_log['moving_avg_log_'+str(steps)+'_steps']=moving_average_e(data.open_log,steps)\n    return MA_log","49981859":"begin,end,step,data=20,100,20,bitcoin_data","74df01c3":"MA_log=get_rollling_dict_log(begin,end,step,data)","dc73c448":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=bitcoin_data.index,\n        y=bitcoin_data.open_log,\n        mode='lines',\n        name ='Open Price'\n        \n))\n\nfor i in range(len(MA_log)):\n    steps=begin+i*step\n    list_rolling=MA_log['moving_avg_log_'+str(steps)+'_steps']\n    fig.add_trace(go.Scatter(\n        x=list_rolling.index,\n        y=list_rolling.loc[:],\n        mode='lines',\n        name ='moving_avg_log_'+str(steps)+'_steps'\n        \n))\n\n\nfig.show()","a56f55b5":"mv_20=moving_average_e(data.open_log,20)\nts_log_mv_20_diff=prices_log-mv_20","832449a3":"ts_log_mv_20_diff","94ec9c51":"def get_rollling_dict_log_diff_20(ts):\n    MA_log_diff_20={}\n    MA_log_diff_20['moving_avg_log_20_steps']=moving_average_e(ts.loc[:],20)\n    return MA_log_diff_20","0141cf2b":"MA_log_diff_20=get_rollling_dict_log_diff_20(ts_log_mv_20_diff)","ef348890":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=ts_log_mv_20_diff.index,\n        y=ts_log_mv_20_diff.loc[:],\n        mode='lines',\n        name ='Open Price log diff'\n        \n))\n\nsteps=begin+i*step\nlist_rolling=MA_log_diff_20['moving_avg_log_20_steps']\nfig.add_trace(go.Scatter(\n    x=list_rolling.index,\n    y=list_rolling.loc[:],\n    mode='lines',\n    name ='moving_avg_log_20_steps'\n        \n))\n\nfig.show()","3f192188":"test = adfuller(ts_log_mv_20_diff)\ntest","b733f8ca":"ts_log_mv_20_diff_shift=prices_log-prices_log.shift(1)","caede89d":"ts_log_mv_20_diff_shift.dropna(inplace = True)","132c0256":"test = adfuller(ts_log_mv_20_diff_shift)\ntest","4501e3a2":"ts_log_boxcox , lambda_ = stats.boxcox(prices_log)","10f6012b":"test = adfuller(ts_log_boxcox)\ntest","b618dda2":"#We split our dataset to be able to evaluate our models\n#resultDict and predictionDict are two Dictionaries to save models result\nresultsDict={}\npredictionsDict={}\n\nsplit_date ='2021-05-01'\nts_work_log_diff_mv20 = ts_log_mv_20_diff.copy()\n\n\ndf_training = ts_work_log_diff_mv20.loc[ts_work_log_diff_mv20.index <= split_date]\ndf_test = ts_work_log_diff_mv20.loc[ts_work_log_diff_mv20.index > split_date]\nprint(f\"{len(df_training)} hours of training data \\n {len(df_test)} hours of testing data \")\n\ndf_training.to_csv('\/kaggle\/working\/training.csv')\ndf_test.to_csv('\/kaggle\/working\/test.csv')","34d3e021":"df_training.values","a2087e4e":"%%time\nmodel =  SimpleExpSmoothing(ts_work_log_diff_mv20)  \nresults_ses = model.fit()\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index,\n        y=ts_work_log_diff_mv20.loc[:],\n        mode='lines',\n        name ='Real price'\n        \n))\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index,\n        y=results_ses.fittedvalues.loc[:],\n        mode='lines',\n        name ='Predicted price'\n        \n))\n\nfig.show()\n\nresultsDict['SES'] = mean_squared_error(ts_work_log_diff_mv20, results_ses.fittedvalues)\npredictionsDict['SES'] = results_ses.fittedvalues\n\nprint('MSE: %.6f'% mean_squared_error(ts_work_log_diff_mv20, results_ses.fittedvalues))","cea43220":"lag_acf = acf(ts_work_log_diff_mv20, nlags=50)","8ec2b71f":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        y=lag_acf,\n        mode='lines'      \n))\n\nfig.show()","de9fae31":"%%time\nmodel =  AutoReg(ts_work_log_diff_mv20,lags=17).fit()\nprint(model.summary())\nresult_AR=[]\nfor i in range(17,len(ts_work_log_diff_mv20)-1):\n    predictions=model.predict(start=i,end=i,dynamic=False)\n    result_AR = result_AR + [predictions]\nresult_AR=pd.concat(result_AR)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index,\n        y=ts_work_log_diff_mv20.loc[:],\n        mode='lines',\n        name ='Real price'\n        \n))\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index[18:],\n        y=result_AR,\n        mode='lines',\n        name ='Predicted price'\n        \n))\n\nfig.show()\n\n\nresultsDict['AR'] = mean_squared_error(ts_work_log_diff_mv20[18:], result_AR[:])\npredictionsDict['AR'] = result_AR\n\nprint('MSE: %.6f'% mean_squared_error(ts_work_log_diff_mv20[18:], result_AR[:]))","a9544a29":"lag_pacf = pacf(ts_work_log_diff_mv20, nlags=50, method='ols')","8caeb7d8":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        y=lag_pacf,\n        mode='lines'      \n))\n\nfig.show()","81237b73":"#%%time\n#model = ARMA(ts_work_log_diff_mv20, order=(17, 1, 2))  \n#results_ARMA = model.fit()  ","dcad26fe":"#fig = go.Figure()\n\n#fig.add_trace(go.Scatter(\n#        x=ts_work_log_diff_mv20.index,\n#        y=ts_work_log_diff_mv20.loc[:],\n#        mode='lines',\n#        name ='Real price'\n        \n#))\n\n#fig.add_trace(go.Scatter(\n#        x=ts_work_log_diff_mv20.index,\n#        y=results_ARMA.fittedvalues.loc[:],\n#        mode='lines',\n#        name ='Predicted price'\n        \n#))\n\n#fig.show()","9137d13d":"#resultsDict['ARMA'] = mean_squared_error(ts_work_log_diff_mv20, results_ARMA.fittedvalues)\n#predictionsDict['ARMA'] = results_ARMA.fittedvalues\n\n#print('MSE: %.6f'% mean_squared_error(ts_work_log_diff_mv20, results_ARMA.fittedvalues))","57be7fb2":"%%time\nmodel = ARIMA(ts_work_log_diff_mv20, order=(17, 1, 2))  \nresults_ARIMA = model.fit()","a1c1bc20":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index,\n        y=ts_work_log_diff_mv20.loc[:],\n        mode='lines',\n        name ='Real price'\n        \n))\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index,\n        y=results_ARIMA.fittedvalues.loc[:],\n        mode='lines',\n        name ='Predicted price'\n        \n))\n\nfig.show()\n\nresultsDict['ARIMA'] = mean_squared_error(ts_work_log_diff_mv20, results_ARIMA.fittedvalues)\npredictionsDict['ARIMA'] = results_ARIMA.fittedvalues\n\nprint('MSE: %.6f'% mean_squared_error(ts_work_log_diff_mv20, results_ARIMA.fittedvalues))","e296511a":"%%time\nautoModel = pm.auto_arima(ts_work_log_diff_mv20,start_p=1,start_q=1,max_p=20,max_q=3,d=1,\n                          trace=True, error_action='ignore', suppress_warnings=True,seasonal=False).fit(ts_work_log_diff_mv20)\n\n\nresults_auto_ARIMA=autoModel.predict(n_periods=len(ts_work_log_diff_mv20))\n\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index,\n        y=ts_work_log_diff_mv20[:],\n        mode='lines',\n        name ='Real price'\n        \n))\n\nfig.add_trace(go.Scatter(\n        x=ts_work_log_diff_mv20.index,\n        y=results_auto_ARIMA[:],\n        mode='lines',\n        name ='Predicted price'\n        \n))\n\nfig.show()\n\nresultsDict['auto_ARIMA'] = mean_squared_error(ts_work_log_diff_mv20, results_auto_ARIMA[:])\npredictionsDict['auto_ARIMA'] = results_auto_ARIMA[:]\n\nprint('MSE: %.6f'% mean_squared_error(ts_work_log_diff_mv20, results_auto_ARIMA[:]))","08a32bde":"ts_work_log_diff_mv20.index","feb1bad0":"df=pd.DataFrame()","e2bbf428":"df['ds']=df_training.index","93e61fec":"df['y']=df_training.values","19031c83":"%%time\nprophet = Prophet()\nprophet.fit(df)\nfuture=prophet.make_future_dataframe(periods=len(df_test),freq='h')\nresults_prophet=prophet.predict(future)\nresults_prophet.set_index('ds',inplace=True)\nresults_prophet=results_prophet.yhat[len(df_training):]\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n        x=df_test.index,\n        y=df_test[:],\n        mode='lines',\n        name ='Real price'\n        \n))\n\nfig.add_trace(go.Scatter(\n        x=df_test.index,\n        y=results_prophet[:],\n        mode='lines',\n        name ='Predicted price'\n        \n))\n\nfig.show()\n\n\nresultsDict['prophet'] = mean_squared_error(df_test[:], results_prophet[:])\npredictionsDict['prophet'] = results_prophet[:]\n\nprint('MSE: %.6f'% mean_squared_error(df_test[:], results_prophet[:]))","31e40059":"#to be continued","23f94dcb":"### Simple moving average:","4bf0ce74":"we will start with small steps between 20 and 100.","3a311458":"## Log Transformation","9529a1e3":"### Moving Average (MA)","c69adf7c":"To determine the order of the moving average, we plot it with the opening price with its iterative order over different ranges ","6546550d":"we will start with small steps between 20 and 100.","9f691c08":"we will start with an additive model :","d31977e0":"## Box_Cox transformation","9dcca89e":"ARIMA is an acronym that stands for AutoRegressive Integrated Moving Average. It is a generalization of the simpler AutoRegressive Moving Average and adds the notion of integration.\n\n* Number of AR (Auto-Regressive) terms (p): Autoregression. A model that uses the dependent relationship between an observation and some number of lagged observations.\n* Number of Differences (d): Integrated. The use of differencing of raw observations (e.g. subtracting an observation from an observation at the previous time step) in order to make the time series stationary.\n* Number of MA (Moving Average) terms (q): Moving Average. A model that uses the dependency between an observation and a residual error from a moving average model applied to lagged observations.","79861e90":"## Univariate-time-series-forecasting","6377395d":" The parts we can divide a time series into are: level, trend, seasonality and noise.","2497b93f":"# Forecasting a Time Series","bb1907c6":"### Exponentially moving average:","5e3aeb3f":"The lag value where the ACF chart crosses the upper confidence interval for the first time. If you notice closely, in this case p=17.","f9283a56":"The time series can be broken down into 2 models : Additive Model and Multiplicative Model.","c476e9ff":"To determine the value of 'p' .  \nAutocorrelation Function (ACF): It is a measure of the correlation between the the TS with a lagged version of itself. For instance at lag 5, ACF would compare series at time instant \u2018t1\u2019\u2026\u2019t2\u2019 with series at instant \u2018t1-5\u2019\u2026\u2019t2-5\u2019 (t1-5 and t2 being end points).","67afbef6":"we will start with big steps between 50 and 600.","9a9cc22d":"The autoregressive (AR) method models the next step in the sequence as a linear function of the observations at prior time steps. \n\nparams : p is the parameter associated with the auto-regressive aspect of the model, which incorporates past values i.e lags of dependent variable. For instance if p is 4, the predictors for x(t) will be x(t-1)\u2026.x(t-4).","5f482795":"We can see from our data that there are two bull run periods in 2018 and 2021.","a4f06432":"our p_value= 0.8033 > -2.56681 : our series is not stationary which is to be expected from the data plot.","acead852":"Autoregressive\u2013moving-average (ARMA) models provide a parsimonious description of a (weakly) stationary stochastic process in terms of two polynomials, one for the autoregression (AR) and the second for the moving average (MA).","1992138e":"our p_value=0.788984 : our series is not stationary which is to be expected from the data plot.","5890bbd1":"we will start with an multiplicative model :","ff66a5e2":"we\u2019ll take the log of the prices, then difference the log instead of just differencing the prices.","ed1aeeeb":"The term univariate implies that forecasting is based on a sample of time series observations of the exchange rate without taking into account the effect of the other variables such as prices and interest rates.","bf6265b7":"In this simpler case, it is easy to see a forward trend in the data. But its not very intuitive in presence of noise. So we can use some techniques to estimate or model this trend and then remove it from the series.","10eabd60":"## Load the dataset and quick preview","6503c8cf":"It is straightforward to observe that MA timeseries are much less noisy than the original price timeseries. However, this comes at a cost: MA timeseries lag the original price timeseries, which means that changes in the trend are only seen with a delay of L days.","f40a5cdc":"The Moving Average (MA) method models the next step in the sequence as the average of a window of observations at prior time steps. Parameters of the model:\n\n\nparams : q is size of the moving average part window of the model i.e. lagged forecast errors in prediction equation. For instance if q is 5, the predictors for x(t) will be e(t-1)\u2026.e(t-5) where e(i) is the difference between the moving average at ith instant and actual value. \n\n","1444dfc1":"### Combined Model Autoregressive Moving Average (ARMA) ","7f62d361":"we will start with big steps between 50 and 600.","bb6bd7e4":"## Combining Time Series Components","455dcc30":"Exponential smoothing is a rule of thumb technique for smoothing time series data using the exponential window function. Whereas in the simple moving average the past observations are weighted equally, exponential functions are used to assign exponentially decreasing weights over time.","9a61e786":"### Prophet\n\nProphet is a model released by [facebook](https:\/\/github.com\/facebook\/prophet). Is essentially a curve fitting approach, very similar in spirit to how BSTS models trend and seasonality, except that it uses generalized additive models instead of a state-space representation to describe each component.","2900c822":"An additive model : y(t) = Level + Trend + Seasonality + Noise  \nA multiplicative model : y(t) = Level * Trend * Seasonality * Noise","8df45ef4":"We can see that the mean and std variations have small variations with time. Also, the Dickey-Fuller test statistic is less than the 1% critical value, thus the TS is stationary with 99% confidence.","e3d4b4e7":"We will perform the Dickey-Fuller test to check the stationarity of our series","5ad5d718":"### Autoregressive (AR)","ae0f15f7":"### Single Exponential Smoothing (SES)","1c706bbd":"### Autoregressive integrated moving average (ARIMA) ","41d0fa19":"simple visualisation about our feature values","b5d7d12e":"## Log Transformation with shift","0fc21dd1":"Lets check each feature values","1cf8a983":"# Time series analysis ","0ab8f8be":"**Prepare data before modeling**","abd8229d":"This looks like a much better series. The rolling values appear to be varying slightly but there is no specific trend. Also, the test statistic is smaller than the 1% critical values so we can say with 99% confidence that this is a stationary series.","ebc7fa7f":"we will start with small steps between 20 and 100.","712984ed":"#### Auto ARIMA","9dc88ac0":"The lag value where the ACF chart crosses the upper confidence interval for the first time. If you notice closely, in this case q=2."}}