{"cell_type":{"725f2819":"code","45cf85ef":"code","fd3172b4":"code","1798c29c":"code","e8647469":"code","6d62dde3":"code","d643dabb":"code","145f1ef5":"code","e4dac8e3":"code","bfd8a27f":"code","f452822d":"code","956c1423":"code","5d61467d":"markdown"},"source":{"725f2819":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfrom skimage import io\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    #for filename in filenames:\n        #print(os.path.join(dirname, filename))\n!pip install efficientnet_pytorch torchtoolbox\nimport copy\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import Dataset, DataLoader, random_split\n#import torchtoolbox.transform as transforms\n\nimport torchvision\nfrom torchvision import datasets, models, transforms\n\nfrom sklearn.metrics import accuracy_score, roc_auc_score\nfrom sklearn.model_selection import StratifiedKFold, GroupKFold\nimport gc\nimport cv2\nimport time\nimport datetime\nimport warnings\nimport random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom tqdm import tqdm\n%matplotlib inline\n\nfrom PIL import Image\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")","45cf85ef":"def make_CNN(model_name, num_classes, resume_from = None):\n    # Initialize these variables which will be set in this if statement. Each of these\n    #   variables is model specific.\n    # The model (nn.Module) to return\n    model_ft = None\n    # The input image is expected to be (input_size, input_size)\n    input_size = 0\n    \n    # You may NOT use pretrained models!! \n    use_pretrained = False\n    \n    # By default, all parameters will be trained (useful when you're starting from scratch)\n    # Within this function you can set .requires_grad = False for various parameters, if you\n    # don't want to learn them\n\n    if model_name == \"resnet\":\n        \"\"\" Resnet18\n        \"\"\"\n        model_ft = models.resnet18(pretrained=use_pretrained)\n        num_ftrs = model_ft.fc.in_features\n        model_ft.fc = nn.Linear(num_ftrs, 1)\n        input_size = 224\n        \n    elif model_name == \"vgg16\":\n        \"\"\" VGG16_bn\n        \"\"\"\n        model_ft = models.vgg16_bn(pretrained=use_pretrained)\n        num_ftrs = model_ft.classifier[6].in_features\n        model_ft.classifier[6] = nn.Linear(num_ftrs, 1)\n        input_size = 224\n\n    elif model_name == \"squeezenet\":\n        \"\"\" Squeezenet\n        \"\"\"\n        model_ft = models.squeezenet1_0(pretrained=use_pretrained)\n        model_ft.classifier[1] = nn.Conv2d(512, 1, kernel_size=(1,1), stride=(1,1))\n        model_ft.num_classes = num_classes\n        input_size = 224\n\n    elif model_name == \"densenet\":\n        \"\"\" Densenet\n        \"\"\"\n        model_ft = models.densenet121(pretrained=use_pretrained)\n        num_ftrs = model_ft.classifier.in_features\n        model_ft.classifier = nn.Linear(num_ftrs, 1)\n        input_size = 224\n        \n    else:\n        raise Exception(\"Invalid model name!\")\n    \n    return model_ft, input_size","fd3172b4":"class Melanoma_Net(nn.Module):\n    \"\"\"\n    fc1: number of neurons in the hidden fully connected layer\n    \"\"\"\n    def __init__(self, cnn_model_name, num_classes, num_multimodal_features=9, fc1_out=32, resume_from=None):\n        #num_classes = 1\n        #num_multimodal_features= 9\n        super(Melanoma_Net, self).__init__()\n        self.cnn, self.input_size = make_CNN(cnn_model_name, num_classes)#models.vgg11(pretrained=False, progress = True)\n        #define output layers\n        self.fc1 = nn.Linear(num_classes + num_multimodal_features, fc1_out) #takes in input of CNN and multimodal input\n        self.fc2 = nn.Linear(fc1_out, num_classes)\n        if resume_from is not None:\n            print(\"Loading weights from %s\" % resume_from)\n            self.load_state_dict(torch.load(resume_from))\n        \n    def forward(self, image, data):\n        x1 = self.cnn(image)\n        #print(\"x1\", x1.shape)\n        x2 = data\n        #print(\"x2\", x2.shape)\n        #print(\"x1: \", x1, type(x1))\n        #print(\"x2: \", x2, type(x2))\n        #x = torch.cat((x1, x2), dim=1)  \n        x = torch.cat((x1.float(), x2.float()), dim=1) ### ???\n        #print(\"concat\", x.shape)\n        x = F.relu(self.fc1(x))\n        #print(\"relu\", x.shape)\n        x = self.fc2(x)\n        #print('forward output: ', x)\n        #print(\"fc2\", x.shape)\n        return x.double() ### ???","1798c29c":"class AdvancedHairAugmentation:\n    \"\"\"\n    Impose an image of a hair to the target image\n\n    Args:\n        hairs (int): maximum number of hairs to impose\n        hairs_folder (str): path to the folder with hairs images\n    \"\"\"\n\n    def __init__(self, hairs: int = 5, hairs_folder: str = \"\"):\n        self.hairs = hairs\n        self.hairs_folder = hairs_folder\n\n    def __call__(self, img_path):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to draw hairs on.\n\n        Returns:\n            PIL Image: Image with drawn hairs.\n        \"\"\"\n        img = cv2.imread(img_path)\n        n_hairs = random.randint(1, self.hairs)\n        \n        if not n_hairs:\n            return img\n        \n        height, width, _ = img.shape  # target image width and height\n        hair_images = [im for im in os.listdir(self.hairs_folder) if 'png' in im]\n        \n        for _ in range(n_hairs):\n            hair = cv2.imread(os.path.join(self.hairs_folder, random.choice(hair_images)))\n            hair = cv2.flip(hair, random.choice([-1, 0, 1]))\n            hair = cv2.rotate(hair, random.choice([0, 1, 2]))\n\n            h_height, h_width, _ = hair.shape  # hair image width and height\n            roi_ho = random.randint(0, img.shape[0] - hair.shape[0])\n            roi_wo = random.randint(0, img.shape[1] - hair.shape[1])\n            roi = img[roi_ho:roi_ho + h_height, roi_wo:roi_wo + h_width]\n\n            # Creating a mask and inverse mask\n            img2gray = cv2.cvtColor(hair, cv2.COLOR_BGR2GRAY)\n            ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)\n            mask_inv = cv2.bitwise_not(mask)\n\n            # Now black-out the area of hair in ROI\n            img_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)\n\n            # Take only region of hair from hair image.\n            hair_fg = cv2.bitwise_and(hair, hair, mask=mask)\n\n            # Put hair in ROI and modify the target image\n            dst = cv2.add(img_bg, hair_fg)\n\n            img[roi_ho:roi_ho + h_height, roi_wo:roi_wo + h_width] = dst\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)        \n        return img\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}(hairs={self.hairs}, hairs_folder=\"{self.hairs_folder}\")'","e8647469":"class MultimodalDataset(Dataset):\n    \"\"\"\n    Custom dataset definition\n    \"\"\"\n    def __init__(self, csv_path, img_path, mode='train', transform=None):\n        \"\"\"\n        \"\"\"\n        self.df = pd.read_csv(csv_path)\n        self.img_path = img_path\n        self.mode= mode\n        self.transform = transform\n        \n            \n    def __getitem__(self, index):\n        \"\"\"\n        \"\"\"\n        img_name = self.df.iloc[index][\"image_name\"] + \".jpg\"\n        img_path = os.path.join(self.img_path, img_name)\n        image = Image.open(img_path)\n\n        dtype = torch.cuda.FloatTensor if torch.cuda.is_available() else torch.FloatTensor # ???\n        \n        if self.mode == 'train':\n            if self.df.iloc[index][\"augmented\"]==1:\n                image = AdvancedHairAugmentation(hairs_folder=\"..\/input\/melanoma-hairs\")(img_path)\n                image = Image.fromarray(image, 'RGB')\n            else:  \n                image = image.convert(\"RGB\")\n                \n            image = np.asarray(image)\n            if self.transform is not None:\n                image = self.transform(image)\n            labels = torch.tensor(self.df.iloc[index][\"target\"], dtype = torch.float64)\n            \n            features = np.fromstring(self.df.iloc[index][\"features\"][1:-1], sep=\",\") #turns features into an array\n            features = torch.from_numpy(features.astype(\"float\")) #turns the features array into a vector\n            return image, features, labels\n            \n        elif self.mode == 'val':\n            image = np.asarray(image)\n            if self.transform is not None:\n                image = self.transform(image)\n            labels = torch.tensor(self.df.iloc[index][\"target\"], dtype = torch.float64)\n            \n            features = np.fromstring(self.df.iloc[index][\"features\"][1:-1], sep=\",\") #turns features into an array\n            features = torch.from_numpy(features.astype(\"float\")) #turns the features array into a vector\n            return image, features, labels\n        \n        else: #when self.mode=='test'\n            image = np.asarray(image)\n            if self.transform is not None:\n                image = self.transform(image)\n            return image, self.df.iloc[index][\"image_name\"]\n\n    def __len__(self):\n        return len(self.df)","6d62dde3":"image_path_dict = {'train': \"..\/input\/siim-isic-melanoma-classification\/jpeg\/train\",\n                  'val': \"..\/input\/siim-isic-melanoma-classification\/jpeg\/train\" ,\n                  'test': \"..\/input\/siim-isic-melanoma-classification\/jpeg\/test\"}","d643dabb":"def get_dataloaders(input_size, batch_size, augment=False, shuffle = True):\n    # How to transform the image when you are loading them.\n    # you'll likely want to mess with the transforms on the training set.\n    \n    # For now, we resize\/crop the image to the correct input size for our network,\n    # then convert it to a [C,H,W] tensor, then normalize it to values with a given mean\/stdev. These normalization constants\n    # are derived from aggregating lots of data and happen to produce better results.\n    data_transforms = {\n        'train': transforms.Compose([\n            transforms.ToPILImage(),\n            transforms.Resize(input_size),\n            transforms.CenterCrop(input_size),\n            #Add extra transformations for data augmentation\n            transforms.RandomApply([\n                transforms.RandomChoice([\n                    transforms.RandomAffine(degrees=20),\n                    transforms.RandomAffine(degrees=0,scale=(0.1, 0.15)),\n                    transforms.RandomAffine(degrees=0,translate=(0.2,0.2)),\n                    #transforms.RandomAffine(degrees=0,shear=0.15),\n                    transforms.RandomHorizontalFlip(p=1.0)\n                ] if augment else [transforms.RandomAffine(degrees=0)])#else do nothing\n            ], p=0.5),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5], [0.225])\n        ]),\n        'val': transforms.Compose([\n            transforms.ToPILImage(),\n            transforms.Resize(input_size),\n            transforms.CenterCrop(input_size),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5], [0.225])\n        ]),\n        'test': transforms.Compose([\n            transforms.ToPILImage(),\n            transforms.Resize(input_size),\n            transforms.CenterCrop(input_size),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5], [0.225])\n        ])\n    }\n    # Create training and validation datasets\n    data_subsets = {x: MultimodalDataset(csv_path=\"..\/input\/melanoma\/\" + x + \".csv\", \n                                         img_path = image_path_dict[x],\n                                         mode = x,\n                                         transform=data_transforms[x]) for x in data_transforms.keys()}\n    \n    # Create training and validation dataloaders\n    # Never shuffle the test set\n    dataloaders_dict = {x: DataLoader(data_subsets[x], batch_size=batch_size, shuffle=False if x != 'train' else shuffle, num_workers=4) for x in data_transforms.keys()}\n    return dataloaders_dict","145f1ef5":"def train_model(model, multimodal, dataloaders, criterion, optimizer, scheduler, model_name=str(datetime.datetime.now()), \n                save_dir = None, save_all_epochs=False, num_epochs=25):\n    '''\n    model: The NN to train\n    dataloaders: A dictionary containing at least the keys \n                 'train','val' that maps to Pytorch data loaders for the dataset\n    criterion: The Loss function\n    optimizer: The algorithm to update weights \n               (Variations on gradient descent)\n    num_epochs: How many epochs to train for\n    save_dir: Where to save the best model weights that are found, \n              as they are found. Will save to save_dir\/weights_best.pt\n              Using None will not write anything to disk\n    save_all_epochs: Whether to save weights for ALL epochs, not just the best\n                     validation error epoch. Will save to save_dir\/weights_e{#}.pt\n    '''\n    since = time.time()\n\n    val_acc_history = []\n    \n    best_model_wts = copy.deepcopy(model.state_dict())\n    best_acc = 0.0\n\n    for epoch in range(num_epochs):\n        print('Epoch {}\/{}'.format(epoch, num_epochs - 1))\n        print('-' * 10)\n\n        # Each epoch has a training and validation phase\n        for phase in ['train', 'val']:\n            if phase == 'train':\n                model.train()  # Set model to training mode\n            else:\n                model.eval()   # Set model to evaluate mode\n\n            running_loss = 0.0\n            running_corrects = 0\n\n            # Iterate over data.\n            # TQDM has nice progress bars\n            for inputs, features, labels in tqdm(dataloaders[phase]):\n                inputs = inputs.to(device)\n                features = features.to(device)\n                labels = labels.to(device)\n\n                # zero the parameter gradients\n                optimizer.zero_grad()\n\n                # forward\n                # track history if only in train\n                with torch.set_grad_enabled(phase == 'train'):\n                    # Get model outputs and calculate loss\n                    if multimodal:\n                        outputs = model(inputs, features)\n                    else:\n                        outputs = model(inputs).type(torch.float64)\n                    outputs = torch.squeeze(outputs)\n                    #print(\"model outputs: \", outputs, outputs.size())\n                    #print(\"model labels: \", labels.size())\n                    loss = criterion(outputs, labels)\n\n                    # torch.max outputs the maximum value, and its index\n                    # Since the input is batched, we take the max along axis 1\n                    # (the meaningful outputs)\n                    #print(\"outputs: \", outputs)\n                    #preds = torch.max(outputs, 1)\n                    preds = (outputs > 0).type(torch.float64)\n                    #_, preds = torch.max(outputs, 1)\n                    #print(\"new preds: \", preds, preds.shape)\n                    # backprop + optimize only if in training phase\n                    if phase == 'train':\n                        loss.backward()\n                        optimizer.step()\n\n                # statistics\n                #print(\"loss: \", loss.item())\n                #print(\"inputs: \", inputs.size(0), inputs.size())\n                \n                running_loss += loss.item() * inputs.size(0)\n                #print(\"running loss: \", running_loss)ZZ\n                running_corrects += torch.sum(preds == labels.data)\n                #print(\"running corrects: \", running_corrects)\n            \n            epoch_loss = running_loss \/ len(dataloaders[phase].dataset)\n            #is the accuracy calculated correctly?\n            #print(\"running_corrects: \", running_corrects.double(), running_corrects.size())\n            #print(\"dataloaders len: \", len(dataloaders[phase].dataset)) \n            #maybe dataloaders length * number of classes? Model must predict for all classes\n            \n            epoch_acc = 100* running_corrects.double() \/ (len(dataloaders[phase].dataset))  # *preds.shape[1]  WHAT IS THIS HUH????\n            epoch_acc = epoch_acc.item()\n\n            print('{} Loss: {:.4f} Acc: {:.4f}%'.format(phase, epoch_loss, epoch_acc))\n\n            # deep copy the model\n            if phase == 'val' and epoch_acc > best_acc:\n                best_acc = epoch_acc\n                best_model_wts = copy.deepcopy(model.state_dict())\n                torch.save(model.state_dict(), save_dir + \"\/{}_best_weights_1.pt\".format(model_name))\n            if phase == 'val':\n                val_acc_history.append(epoch_acc)\n        print()\n        scheduler.step()\n    time_elapsed = time.time() - since\n    print('Training complete in {:.0f}m {:.0f}s'.format(time_elapsed \/\/ 60, time_elapsed % 60))\n    print('Best Val Acc: {:4f}'.format(best_acc))\n\n    # load best model weights\n    model.load_state_dict(best_model_wts)\n    return model, val_acc_history","e4dac8e3":"def make_optimizer(model):\n    # Get all the parameters\n    params_to_update = model.parameters()\n    print(\"Params to learn:\")\n    for name, param in model.named_parameters():\n        if param.requires_grad == True:\n            print(\"\\t\",name)\n\n    # Use SGD\n    optimizer = optim.SGD(params_to_update, lr=0.01, momentum=0.9)\n    return optimizer\n\ndef get_loss(num_classes,device):\n    # Create an instance of the loss function\n    #set weights to account for unbalanced data.\n    #In expectation every category class contributes the same to the loss\n    \n    pos_weight = torch.tensor(np.ones(num_classes)) #### TODO for other class numbers\n    pos_weight = pos_weight.to(device)\n\n    criterion = nn.BCEWithLogitsLoss()\n    return criterion","bfd8a27f":"# Models to choose from [resnet, alexnet, vgg, squeezenet, densenet]\n# You can add your own, or modify these however you wish!\nmodel_name = \"vgg16\"\n\n# Number of classes in the dataset\nnum_classes = 1\n\n# Batch size for training (change depending on how much memory you have)\n# You should use a power of 2.\nbatch_size = 64\n\n# Shuffle the input data?\nshuffle_datasets = True\n\n# Number of epochs to train for \nnum_epochs = 50\n\n### IO\n# Path to a model file to use to start weights at\n#resume_from = \"\/home\/ubuntu\/6.867-xray-project\/weights\/data_aug_vgg.pt\"\nresume_from = None #None\n\n# Directory to save weights to\nsave_dir = \"weights\"\nos.makedirs(save_dir, exist_ok=True)\n\n# If True saves the weights for all epochs, else only saves the weight of best one\nsave_all_epochs = False\n\n#Enable multimodal\nmultimodal = True","f452822d":"gc.collect()","956c1423":"# Initialize the model for this run\nif multimodal:\n    model = Melanoma_Net(cnn_model_name = model_name, num_classes = num_classes, resume_from = resume_from)\n    input_size = model.input_size\nelse:\n    model, input_size = make_CNN(model_name=model_name,num_classes=num_classes, resume_from = resume_from)\n    \ndataloaders = get_dataloaders(input_size, batch_size, shuffle = shuffle_datasets)\ncriterion = get_loss(num_classes=num_classes,device=device)\n\n# Move the model to the gpu if needed\nmodel = model.to(device)\n\noptimizer = make_optimizer(model)\nscheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.1)\n#scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[5,10],gamma=0.1)\n# Train the model!\ntrained_model, validation_history = train_model(model=model, multimodal=multimodal,\n                                                dataloaders=dataloaders, criterion=criterion, optimizer=optimizer,\n            scheduler=scheduler, model_name=model_name, save_dir=save_dir, save_all_epochs=save_all_epochs, num_epochs=num_epochs)","5d61467d":"# Train!"}}