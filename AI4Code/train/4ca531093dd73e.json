{"cell_type":{"43a89bd7":"code","62d8d18d":"code","5ccc0d27":"code","a0e264a6":"code","12ca927c":"code","61541453":"code","f96d8dd8":"code","990df256":"code","c2176fc4":"code","b3285659":"code","f4550e44":"markdown","64c81d84":"markdown"},"source":{"43a89bd7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","62d8d18d":"import time\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n","5ccc0d27":"df = pd.read_csv('\/kaggle\/input\/single-cell-rna-seq-from-stoeckius-et-al-2017\/GSE100866_CD8_merged-RNA_umi.csv', index_col = 0)\n# The dataset is single cell rna seq from the Cite-seq paper. \n# Cells were classified by flow cytometry as low, medium, or high cd8 expression cells (columns), with rows corresponding to RNA counts. 1,774 cells in total by 11757 genes. \n# Stoeckius et al 2017.\n\ndf = df.T\ndf","a0e264a6":"X = df.values\nX.shape","12ca927c":"t0 = time.time()\ncorr_matr = np.corrcoef(X.T) # Hint - use numpy , pandas is MUCH SLOWER   (df.corr() )\nprint(time.time() - t0, 'seconds passed')\nprint(np.min(corr_matr ), 'minimal correlation' )\ncorr_matr_abs = np.abs( corr_matr )\nprint(np.mean(corr_matr_abs ), 'average absolute correlation' )\nprint(np.median(corr_matr_abs), 'median absolute correlation' )\nprint(np.min(corr_matr_abs ), 'min absolute correlation' )\nprint(np.std(corr_matr_abs ), 'std absolute correlation' )","61541453":"v = corr_matr.flatten()\nplt.figure(figsize=(14,8))\nt0 = time.time()\nplt.hist(v, bins = 50)\nplt.title('correlation coefficients distribution')\nplt.show()\nprint(time.time() - t0, 'seconds passed')\n\nprint(np.min(corr_matr ), 'minimal correlation' )\nprint(np.mean(corr_matr_abs ), 'average absolute correlation' )\nprint(np.median(corr_matr_abs), 'median absolute correlation' )\nprint(np.min(corr_matr_abs ), 'min absolute correlation' )\nprint(np.std(corr_matr_abs ), 'std absolute correlation' )\nfor t in [0.5,0.6, 0.7,0.8,0.9,0.95,0.97,0.98,.99]:\n    print( ((np.abs(v) < 0.99999999) & (np.abs(v) > t)).sum()\/2 , 'number of pairs correlated more than', t  )\nv.shape","f96d8dd8":"\n\nplt.figure(figsize=(14,8))\nt0 = time.time()\nsns.heatmap(corr_matr_abs).set_title('Correlation (abs) heatmap')\nprint(time.time() - t0, 'seconds passed')\n\n","990df256":"\n\nimport igraph\n\n","c2176fc4":"corr_matr_abs_bool = corr_matr_abs > 0.6\ncorr_matr_abs_bool = corr_matr_abs_bool# [:772 ,:772 ]\ncorr_matr_abs_bool = np.triu(corr_matr_abs_bool,1) # Take upper triangular part \ng = igraph.Graph().Adjacency(corr_matr_abs_bool.tolist())\ng.to_undirected(mode = 'collapse')\nprint( corr_matr_abs_bool.astype(int) )\n\nprint('Number of nodes ', g.vcount())\nprint('Number of edges ', g.ecount() )\nprint('Number of weakly connected compoenents', len( g.clusters(mode='WEAK')))\n\n\nprint('Sizes of connected components large than 5 nodes')\nc = 0\nfor t in list(g.clusters(mode='WEAK') ):\n    if len(t) <= 5: continue\n    c+=1 \n    print(len(t) )\nprint('count components large than 5 nodes:', c )\n    \nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['green' for v in g.vs]\n#visual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 2\nigraph.plot(g,bbox = (800,500), **visual_style )","b3285659":"\n\n# Plot the largest component separately \nfor t in list(g.clusters(mode='WEAK') ):\n    if len(t) <= 30: continue\n    print(t)\n    g2 = g.subgraph(t)\n    index_save = t.copy()\n    \nprint('Number of nodes ', g2.vcount())\nprint('Number of edges ', g2.ecount() )    \nprint(df.columns[index_save])    \nigraph.plot(g2,bbox = (800,200), **visual_style )\n\n","f4550e44":"# What is about ?\n\nAnalysis of genes correlations for Stoeckius et al 2017 single cell RNA sequences data - 1,774 cells in total by 11757 genes\n\nBased on:\n\nhttps:\/\/www.kaggle.com\/alexandervc\/correlation-analysis-scrnaseq-nestorova2016\n\nhttps:\/\/www.kaggle.com\/alexandervc\/moa-correlation-analysis-use-igraph","64c81d84":"\n# Analysis with graphs\n\nTake a correlation matrix and change it with threshold - if above - put 1, if below put 0. Construct a graph from it - nodes are connected if 1 in matrix. Look at that graph for several thresholds and see the pattern - there seems to be only one group of correlated features - all other stands separate.\n"}}