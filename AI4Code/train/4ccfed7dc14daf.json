{"cell_type":{"adc33d92":"code","3e3108a7":"code","edd6d910":"code","829efca3":"code","fc4658cb":"code","a9ac623a":"code","bf8ea51e":"code","e2cbfae3":"code","3cb7d869":"code","1cc39aad":"code","57a69021":"code","5e290419":"code","f7ec52d3":"code","c4c2a1a8":"code","34870c7a":"code","95ec4a88":"code","9d3ed580":"code","8dfb312e":"code","30d3e9c4":"code","1827da4c":"code","65496f99":"code","50c5a67e":"code","fe6a7278":"code","8e743945":"code","7f5cba63":"code","034ffbcf":"code","2e4e9ec2":"code","9e9d841e":"code","e034339f":"code","c242268b":"code","b62d25b9":"code","38e5d45c":"code","4fe36fc7":"code","0ba13e7b":"code","4c4561e5":"code","e88fc545":"code","50e33507":"code","1bc28b42":"code","8245b62e":"code","d9edfba3":"code","7096e7ef":"code","cdce747c":"code","ed18773f":"markdown","84587e0a":"markdown","2ff823fb":"markdown","284ad22e":"markdown","ef9f0fea":"markdown","37bf8051":"markdown","e0d8cb60":"markdown","09bb501f":"markdown","344a6ee3":"markdown","9d7bb573":"markdown","849ea570":"markdown","bb479e97":"markdown","2027ab51":"markdown","053943c9":"markdown","a8a667fb":"markdown","9c3a3546":"markdown","d7ba0861":"markdown","5be96b5b":"markdown","2ab242ee":"markdown","7eaaae47":"markdown","406b356d":"markdown","4fb22e8d":"markdown","d81e76a8":"markdown","c58b2ad5":"markdown","e3d4e079":"markdown","33187873":"markdown","e8b49815":"markdown","53ea5338":"markdown","7ebdc010":"markdown","43b5285f":"markdown","43741d96":"markdown","dd0f0624":"markdown","023c4ff9":"markdown","21d2831e":"markdown","3c55a6d8":"markdown","f3c9ea75":"markdown"},"source":{"adc33d92":"import networkx as nx\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv('..\/input\/bitcoin-otc-signed-weighted-network\/soc-sign-bitcoinotc.csv')\ndf[\"weight\"] = df[\"4\"]\n\n# For testing we're only going with first 100 rows to reduce computition cost\ndf_full = df\ndf = df.head(100)\n\nprint(df)","3e3108a7":"simple_graph = nx.from_pandas_edgelist(df,source=\"6\",target=\"2\",edge_attr='weight')","edd6d910":"# Simple Graph Version\nprint(nx.info(simple_graph))","829efca3":"nx.draw_networkx(simple_graph, with_labels = True)","fc4658cb":"# Directed Graph Version\ndirected_graph = nx.from_pandas_edgelist(df,source=\"6\",target=\"2\",edge_attr='weight',create_using=nx.DiGraph())\nprint(nx.info(directed_graph))","a9ac623a":"nx.draw_networkx(directed_graph, with_labels = True)","bf8ea51e":"labels = {e: directed_graph[e[0]][e[1]]['weight'] for e in directed_graph.edges}\n\npos = nx.spring_layout(directed_graph)\nnx.draw(directed_graph, pos, with_labels=True)\n\nnx.draw_networkx_edge_labels(directed_graph, pos, edge_labels=labels)\n\nplt.show()","e2cbfae3":"# Directed Graph Version\nmulti_graph = nx.from_pandas_edgelist(df,source=\"6\",target=\"2\",edge_attr='weight',create_using=nx.MultiGraph())\nprint(nx.info(multi_graph))","3cb7d869":"# For every node in graph\nG_only_paralell_from_multigraph = nx.DiGraph(directed=True)\n\nfor node in multi_graph.nodes(): \n    # We look for adjacent nodes\n    for adj_node in multi_graph[node]: \n        # If adjacent node has an edge to the first node\n        # Or our graph have several edges from the first to the adjacent node\n        if node in multi_graph[adj_node] or len(multi_graph[node][adj_node]) > 1: \n            G_only_paralell_from_multigraph.add_edge(node, adj_node)\n            \n            \nprint('Network of bi-directional connected nodes (parallel edge)')            \nnx.draw_networkx(G_only_paralell_from_multigraph, with_labels = True)            ","1cc39aad":"for e in directed_graph.nodes:\n    print('In-Degree of Node(',e,'):',directed_graph.in_degree(e))\n    print('Out-Degree of Node(',e,'):',directed_graph.out_degree(e))\n    print('Total Degree of Node(',e,'):',directed_graph.degree(e))\n    print('\\n\\n')","57a69021":"#  Cycle in directed-graph\nprint(nx.find_cycle(directed_graph, orientation=\"original\"))","5e290419":"#  Cycle in un-directed-graph\nprint(nx.find_cycle(simple_graph, orientation=\"original\"))","f7ec52d3":"# Check weather our simple graph is bipartite\nfrom networkx.algorithms import bipartite\nprint(bipartite.is_bipartite(simple_graph))","c4c2a1a8":"# Check weather our directed graph is bipartite\nfrom networkx.algorithms import bipartite\nprint(bipartite.is_bipartite(directed_graph))","34870c7a":"B = nx.Graph()\nB.add_nodes_from([1,2,3,4], bipartite=0) \nB.add_nodes_from(['a','b','c'], bipartite=1)\nB.add_edges_from([(1,'a'), (1,'b'), (2,'b'), (2,'c'), (3,'c'), (4,'a')])\n\n# Separate by group\nl, r = nx.bipartite.sets(B)\npos = {}\n\n# Update position for node from each group\npos.update((node, (1, index)) for index, node in enumerate(l))\npos.update((node, (2, index)) for index, node in enumerate(r))\n\nnx.draw(B, pos=pos)\nplt.show()","95ec4a88":"print('Simple Graph is connected? ',nx.is_connected(simple_graph))","9d3ed580":"print('Directed Graph is weekly connected? ',nx.is_weakly_connected(directed_graph))\nprint('Directed Graph is semi connected? ',nx.is_semiconnected(directed_graph))\nprint('Directed Graph is strongly connected? ',nx.is_strongly_connected(directed_graph))","8dfb312e":"# Finding clique in our simple graph\nlist(nx.enumerate_all_cliques(simple_graph))","30d3e9c4":"A = nx.adjacency_matrix(simple_graph)\nprint(A.todense())","1827da4c":"G = nx.Graph([(1, 5),(1,2),(2,3),(3,5)])\nnodes = ''\nfor e in G.nodes:\n    nodes+=str(e)+','\nprint('Nodes Are: [',nodes[0:7],']')    \n\nA = nx.adjacency_matrix(G)\nprint('Distance Matrix is: \\n',A.todense())","65496f99":"# Connected components of simple graph.\nprint('Simple graph as whole is a component as it is a complete\/connected graph\\n')\nprint(list(sorted(nx.connected_components(simple_graph), key = len, reverse=True)))","50c5a67e":"# Strongly Connected components of directed graph\nprint('Strongly Connected components of directed graph\\n')\nprint(list(sorted(nx.strongly_connected_components(directed_graph), key = len, reverse=True)))","fe6a7278":"import matplotlib.patches as mpatches\nimport numpy as np\n\ndf_ = df\nDG = simple_graph\n\n# build a lookup of review counts and average trust rating\nreview_counts = df_.groupby('2')['1289241911.72836'].count()\naverage_reviews = df_.groupby('2')['1289241911.72836'].mean()\n\ndef get_size(user_id, m=200, min=300):\n    s = review_counts.get(user_id)\n    if s is not None:\n        return min * s\n    else:\n        return min\n\ndef get_color(user_id):\n    s = average_reviews.get(user_id)\n    if s is None:\n        return 0.5\n    # need a scaling function to translate -10-10 to 0.0-1.0 for colors maps\n    return np.interp(s, (-10, 10), (0, 1))\n\nplt.figure(figsize=(14, 14)) \n\nuntrusted = mpatches.Patch(color='red', label='Un trusted')\ntrusted = mpatches.Patch(color='green', label='Average trusted')\nsize = mpatches.Patch(color='white', label='Node Size - Rating Count')\nedges = mpatches.Patch(color='white', label='Edge Length - Mistrust of Reviewing Node')\nplt.legend(handles=[trusted, untrusted, size, edges], loc='lower right')\n\npos = nx.spring_layout(directed_graph, k=0.25)\nsizes = [get_size(n) for n in DG]\ncolors = [get_color(n) for n in DG]\n\nnc = nx.draw_networkx_nodes(\n    DG, pos, nodelist=DG.nodes(), node_size=sizes, linewidths=2.0,\n    node_color=colors, cmap=plt.cm.RdYlGn, alpha=0.8\n)\nec = nx.draw_networkx_edges(DG, pos, arrows=True, alpha=0.08)\nax = plt.axis('off')\nplt.show()\n","8e743945":"for e in directed_graph.edges:\n    print('Direction of edge is from ',e[0],'->',e[1])","7f5cba63":"print('Clustring coefficent of Node 6:',nx.clustering(simple_graph,6))","034ffbcf":"print('Clustring coefficent of All nodes in graph:',nx.clustering(simple_graph))","2e4e9ec2":"all_cc = list(nx.clustering(simple_graph).values())\nprint('Average Clustering coefficent:',sum(all_cc)\/len(all_cc))","9e9d841e":"for e in simple_graph.nodes:\n    degree = simple_graph.degree(e)\n    degree = degree * (degree-1)\n    if degree == 0:        \n        degree = 1\n              \n    triangels = nx.triangles(simple_graph, e)\n    # Using formula\n    lcc = (2*triangels) \/ degree\n    print('Local Clustering coefficient of ',e,' is:',lcc)","e034339f":"shortest_paths = dict(nx.all_pairs_shortest_path_length(simple_graph))\nprint('Distance of Node 6 from every other node is:\\n')\nprint(shortest_paths[6])","c242268b":"print('Average distance of graph:',nx.average_shortest_path_length(simple_graph))","b62d25b9":"print('Center of simple graph is: ',nx.center(simple_graph))","38e5d45c":"print('Diameter of simple graph is: ',nx.diameter(simple_graph))","4fe36fc7":"print('Radius of simple graph is: ',nx.radius(simple_graph))","0ba13e7b":"print(sorted(list(nx.bfs_tree(simple_graph, source=6, depth_limit=3).edges())))","4c4561e5":"# Other methods of bfs\n# bfs_tree() , bfs_edges(), edge_bfs()","e88fc545":"print(sorted(list(nx.dfs_tree(simple_graph, source=6, depth_limit=3).edges())))","50e33507":"hubs,authorities = nx.hits(directed_graph, max_iter=20)\nprint('Hub Scores after 20 iterations \\n',hubs,'\\n\\n')\n\nprint('Authorities Scores after 20 iterations \\n',hubs)","1bc28b42":"rank = nx.pagerank(directed_graph, alpha=0.9)\nprint('Page Rank \\n\\n',rank)","8245b62e":"degree_values = [val for (node, val) in simple_graph.degree()]\nhistogram = [list(degree_values).count(i)\/float(nx.number_of_nodes(simple_graph)) for i in degree_values]\n\nplt.bar(degree_values,histogram)\nplt.xlabel('Degree')\nplt.ylabel('Fraction of Nodes')\nplt.show()","d9edfba3":"degree_values = [val for (node, val) in directed_graph.in_degree()]\nhistogram = [list(degree_values).count(i)\/float(nx.number_of_nodes(simple_graph)) for i in degree_values]\n\nplt.bar(degree_values,histogram)\nplt.xlabel('Degree')\nplt.ylabel('Fraction of Nodes')\nplt.show()","7096e7ef":"print(list(nx.preferential_attachment(simple_graph))) ","cdce747c":"G = nx.watts_strogatz_graph(n = 10, k = 4, p = 0.5) \npos = nx.circular_layout(G) \n  \nplt.figure(figsize = (12, 12)) \nnx.draw_networkx(G, pos) ","ed18773f":"# Distance\n**The distance between two vertices in a graph is the number of edges in a shortest path connecting them.**\n![](https:\/\/media.geeksforgeeks.org\/wp-content\/uploads\/minmEdges-1.png)","84587e0a":"# Center of Graph","2ff823fb":"# BFS (breadth first search)","284ad22e":"# Clustering Coefficent\n\n**A clustering coefficient is a measure of the degree to which nodes in a graph tend to cluster together**","ef9f0fea":"# MultiGraph\n\nA multigraph is a graph which is permitted to have multiple edges (also called parallel edges)\n![](data:image\/jpeg;base64,\/9j\/4AAQSkZJRgABAQAAAQABAAD\/2wCEAAkGBxAQEhAQEREWFhAVFxUXFhIWFRYWFhcXFREWFxcZFhYbHyggGBslHRUWITMhJikrLy4uFx8zOD8tOiotLi0BCgoKDQ0NFg8QFS0dHSUtNSstLS0rKzctLS01KzcrLTUtNysrKy0tLS0tLTItNS03NystNyssLS0tLS0tLS0rK\/\/AABEIAJIBWAMBIgACEQEDEQH\/xAAcAAEBAAIDAQEAAAAAAAAAAAAABQQGAQIHAwj\/xABJEAACAgEBBAQICQsDAgcAAAABAgADEQQFEiExBhNBUQcUIjJhcYGhFVJTYnORkrGzIzM0QnSClKKywdJjcpNU8ESEo8LD0+H\/xAAUAQEAAAAAAAAAAAAAAAAAAAAA\/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP\/aAAwDAQACEQMRAD8A9xiIgIiICInS0HdbGM4OM8s47fRAn6TpDo7rOpr1CNb5WFB87c87dPJsYOcZ5GU557sfZWvN2y3vqtHi72G7efTLSm9o7qh4vVVxNYZwAW8oKRnJzj0KAiIgIiICIiBr1PS3TC\/U6e6xKnquWpQzeeGppdWPxctbujPMr7JsM0LaWy9W3wzp10e8uufFd+\/VuBTo6aibQW3wqsrEAAk8eA4E71UuABnOABnvwIHeIiAiIgIiICJoPTTaBFurVLHBp06sS2rOlrqLCwq6KilrnJUA73k8ABzM3HYmoa3T6axzl3qrZjwGS1YJOBw5mBmxEQEREBETA2\/rHo02purTfsrqsdE+MyISB7SIGfE0no3rtX1+lD2l676XdxZdQxchVYW0LWAQmWwRyw693HaNVtEI3VpW9tmMlEx5IPIszEKvqzkwM6JPq2n5QS2p6ixwpbdKMewBlJAJ7AcZ7MyhAREQEREBERAREQEREBERAREQEm9Itt0aDT2arUNiqsDOBkkk4VVHaSSBKUgdOujS7T0d2jLlC26VfGcOpyuR2jvga\/0P8LGz9o2NThqLACy9cVAcKMthgcZA44Pp7ptZ2xvfmKLbfnBRWn27SoYelczynwX+CY0ahtXrLK36pra0qr3iC671bOxZRy4kY45weGJ6v8G2p+Z1LgfEtAuT6ziz+eANutbOKqU7i1jufaoQffOOo1x\/8RQPVpnPvN39pzv65ceRp37zv2VfUNx\/vnHj+qHPRk\/7Lqz9W9uwA02u\/wCpp\/hm\/wDunO5rgfzmncd3V2Ve\/ff7px8I6j\/orPbZRj24cx41rG5aatfpL8f0I0Dk6vVrktplYf6VwJPssVB74G3Kl4WrZSf9VCF\/5VzX\/NG5rWxl6K+\/CPafYSyD3GcDY+9+evus+bvCtfs1Bcj\/AHEwNU6Y+FjQbNtWgq99hUM3VFSqg8ssTgkjjgTb9gbZo11FWq07b1VgyDyIwcEEdhBBHsnjXhb8GS9fXq9LZVUl711NU4ZVVyN0Ou6p8nAy3DhxPHM9X6EdG12Zo6dGrl9zeLORjed2LMQOwZOAO4CBeiIgIiICIiBG1u09nDUV03W6fxvkiO1fWje7FB4jMrMyouSQqgegAAfcJ+VulPQfah2ldQaLLLbrLLEsAylimzJff5ADeXOTwyO8T9B6LYF9S1db1essVVy17MGDBQGKHDJzHDCKe89sCs239N+rZ1nZ+SR7vw1acfC5PmaXUOO\/cWv3Wsp90DaxX85pr0x3ILAfUai3D1gQ239KMb1hTPY6Oh+plECNZ0s1Y1TaYbJ1TIAn5UNTjLDJzl9wY9Dn2SydrsPO0moUd+7W\/urdifZJu1en+ytKM26ysH4qku32VBMpJ0g0rebbvHuRXc\/UoJgc\/D2n5MXTHbZTdWPtOgEy9LrarhmqxHHzGDfXiYfw0pHkU3ue4UsmfbZuj3zE1Wjs1B3jo6kI5WWsDavcQKuXssED7vTs7ZwfUFNPplbAe3drqzlsgFuGeJJx3kma\/wCB\/T2DZ6X26hrrNQ7XHLlwm9gBATxyABn0maP4bOiG0Gp091dluppq3zZWN49VkLhlUlnK4ByWZiPQMzN8DOzdo7OosN9fV13upSq\/erGcYyWAY1seA3WUZwOOeBD1vaFKvVYj+aVYH6uYPYRzzPnse5nood\/Pautm9ZQE++Yz0ai8blwSuk+ciOXdx2qWKqEU8jjJIPMSoBjgOUDmIiAiIgIiICIiAiIgIiICIiAiIgSejvmX\/tGo\/HaVpK6O+Zf+0aj8dpVgIiICIiAiIgap0jrW\/UIjjNdbUJjjgtfY2+D6QiJ9uW9g3M9Fe+c2Lmtz3vUxRj7SpPtki0ht5x+tr0H\/ABlKvvrMp7HOLNYmeC35A9FlFT\/1M8CpERAREQEROCYGs7QXL3a3t0zoiHsFageMfaFjj11IeybNI+xNOtujXe5ahHsf\/wAyWsI\/nx7JlbB1DW6bT2N57VoW\/wB26N735gZ8REDH1mhpuG7bUli9zqGHH1zIiICIiBO6Rfomr+hu\/CaZ9lasCrAFSMEEZBB5gjtmB0j\/AETV\/Q3fhNKMCXuWabzN6zT\/ABOLWVj5nbYvzeY7M8Fmdp9UlgUo6sGGRgjiAcH6jwn2mq7W6I51lW09Laa9WgKujEmm6tsbyOv6hOM7w7QCQcQNqiYmi1y2ZUgpavnVt5w9I7GU9jDh7ciZcBERAREQEREBERAREQEREBERAldHfMv\/AGjUfjtKsldHfMv\/AGjUfjtKsBERAREQEREDV6\/zFB79c7fa11p\/vKukGNXqfTVp29pa9f8A2CSqf0bTDu1ePs6ywf2lbT\/pmoP+hph\/6upP94FKIiAiIgJjbTfdpuPdW5+pDMmQOn1dzbO1wodluFLspXixKDeKgfOAK\/vQK2zaglNKDkqIo9QUCYvR1vyOPi2XqPUuosA9077ApsTS6ZLn37VqrFj\/ABnCDePtOZA8GGm1NeluGqua2zxrUgM3A7qXFO4ecyM\/78Db4iICIiAiIgTukf6Jq\/obvwmlGQunWt6jZ+utxkrRZgcTkspUcvSRM3o9rzqdLpryCGsrRiCMEMVGeHZxzAoREQMbW6JLQM5V14rYpw6n5p+8HIPbmY9OtethXqMAkgJcBityTgA8fIf5p4HsJ5CjMTXanThStz1hGyCrsoBB5gg84GRa+6rN3An6hNT6H65dsaca2+hlrdmFdNhzXuK2A26ODkkHiw5jhw5+Y+FLwha3R6k6HQ6jd06Kjb+FsLb653RYc5QZx35zx5Y9A8EXSVNRs3SJYBXZWvUqD5K2CnyQyE8GOAMgcj6xA2TV6JNIj36ddwIC70rwrdBxYBOStgEgjHEAHhLCsCARxB4gyVtbVCxX01LBrnUqd3j1asMF3I83AyQDzIwO3ELavShlSpdLTaKhrNNpfGN2s1EeNpVaACxYL59e9u+cPUYG5xEQEREBERAREQERECV0d8y\/9o1H47SrJXR3zL\/2jUfjtKsBERAREQEREDVxkVIp5rr2+ptW7j3OJU2b5Wo1r9zVV\/ZpFn\/zSXrDu22Vk8fG9NYB82xVX+qt5V2CMi+z5S+0\/YIqHuqECnERAREQE+Gur3q7FHMow+tSJ94gYexr+s0+ns+PVW32kB\/vPh0cx1AYcme1x6nvdh7jMfZOpFOjYnlphch9WnZ0H1qgPtmdsXSmnT6eo+claKfWEAPvzAzYiICIiAiIgTukX6Jq\/obvwmlGTukf6Jq\/obvwmlGAk6\/agLNVQBbcvnKGwlfd1rjO76sFvR2zF6Q0Nq0t0VdjVll\/KXIxVqgeICkEZdu7ljJPMA87F2bptl6WuhThE5uRl7LG5sQOLux7Bx7IH2+C2s46i5n\/ANNCaqx7FO837zEeiQ9vaFrqLa9mdVp2HFtYa03AAfLVSVO8cc2HAd+RiXOos1HG4FKeynPlP9KR2fMHtJzgdcDU4RQPFExkjlaVPmr2dWMcfjcuWchqOyvBhs2+hW1VBssZi\/WszpawOADYykElsb5U+aXIHACbvpdlaeqpNOlKChBha90FQB6D98zYgfKjTpWN1EVV7lAUfUJq13RTUELSmpRdIurXV7ppJtJGrGpasvv4wX3iGxkZAxwyduiAiIgIiICIiAiIgIiaz4Rukj7M0F2rrQNYN1UB80M7boLd4Gc4gUOjvmX\/ALRqPxmlaeC+CfwoaqzV+Kasdal7WurV1ZdHw1jYSsZZThuwkeqey\/D9XyWp\/hNT\/hAqxJXw\/V8lqf4TU\/4R8P1fJan+E1P+ECrElfD9XyWp\/hNT\/hHw\/V8lqf4TU\/4QKsSV8P1fJan+E1P+EfD9XyWp\/hNT\/hAjdNdR4tZp78ZDtWhHe9VheoD179g9s2PZOk6mmqonJRFBPe2PKPtOT7Z4X4XPCTqPGl0mnTcr071W5tqw72KA6ncsGVUZHYCeM9b8HvSNtp6GjVugSxt5XAzu7yMVJXPYcZ9HKBskREBERAREQNZ17YbUaTm19tJQdnV2jFv1Ci5vaO+bNPz90h8MLrtNbq9KjU6Y3VLvMwd1ZlDNnkp8jhwOAT3mey6HpGmpRbNJW9oYA73BEBK5wzN6+O6GgXIkvd1r8S1NXzQr3H7ZKf0w2ztQTk62wehK6AP5kY++BUialqeh976rxn4V1aruovVL1Sg7pJOcJu8c\/Fzw5mWDsy\/mNdd6mTTEe6oGBViTDRrB5t9TDuakgn95X4fVOBrdUn5zTBh8am0P9auEI9mYHfpH+iav6G78Jp9tp6s1JlRmxiErU8N525A+jmSewAmea+FXwmppafFtOm\/fctiP1isoqXd3TlTgsx3uGOHAzp0H6Z67bWHWmtH04Kuws3V3rOTopVt1t0MuSGxvNwOeAeg1WCgDT1DrdQfKfs8pzk2Wt+oCc8OJwMAHEOK6CLdRYHvbIQY7+aUVjJ9eMk9pxy6aTZuoC7vWLSuckUjrHJ7S11oO8T3lc+mZ+i2dVSSVXyz51jEu7et2ycejlA1vYGq120HubV6c6XSIzVppznrbip4tY\/yXcq+dx4kcDtyqAABwA5CcxAREQEREBERAREQEREBERATD2tsynV02ae9A9Ngwynt9R7COeZmTh84OOfZ64Gq9E\/B7s7Zlj3aao9awxvuxcqp5hc8v\/wAm1zz7otbpS+k33tO1t+zxhVZywYpZvjUKTwoHDdzw\/N7vZPQYCIiAiIgIiIGldP8AoXsrVB9drq2HU1lnsrLBjWgyQwHnYGfTNr2Xs+nTVV0UIEqQYVByA\/77Z5n08fT9VtpdW7jWYbxVd5wxp8XTd6lV51l+s3\/397hPVV5CBzERAREQEREDzPaXgq2Pqde7sbRaQL7NMpxWwd2G9ndyAWVuAYcuyb7fsfTvj8mFZQFV6ya3UAYAV0IYD0ZxNT6QtoxtOzxvUGlfEEIIvajOL795sqQSVGCO7M2Xopbc+j0r6jPXtUhfeGGyV5sOw98Dv8G3L+b1Vg7hYqWAe0gMfa046rXDlbp39dVifdY2fdKkQNR1B2941+TGi8U3V4ubN7exxIxx9h75ZVNeeb6dfT1dr+7fX75ViBLGh1R8\/V4+iqRP69+c\/AdTHNpst9FtjMn\/ABZCfyynEDVumPQPQ7UqrqtU1msk12VbqsmcZA4EYOBwx2TJ6G9EdLsqk0aYN5R3nscgu5xjiQAPYBMLpDqK\/Haq9Xe1Ok6h2T8q1KPaH8vfdSOKJulRn9Zjxxwu7AsVtNp2V7HU1qRZcMWsMcGsGB5RHHkIFCIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiJr9+27GbV9WaUq0pCu9xYB3NS2EbwIFSgOo3yG4k8OHEL85kdNqu1+lRRW1F1NlnWK5Y7yGvG7gYKEOeOZYgIiICIiAiIgIiICIiB1etTzAPI8RniOU7REBEThjiAnM1rS9IGeunVM9FenucLWljFXKtZhW3ycF2HEV7v63M440dPrL\/ABk0uqlDWbAy5ymHChHyfKLAkgjHmsMdsCpERA62VqwwwBHPBGeI5TtEQEREBERAREQEREBERAREQEREBERAREQEREBI2q6Po732JbZV167typuFXIQIGIdTh90BcjGRjOcDFmIEz4IHW6e0WOBRW1a1+RuMGC5LErvZ8heRHKUxEQEREBERAREQEREBERAREQE4M5iBCp6NVoAi229QtotWjKFFYPvhVJXfCBuO7vYHIcOEzNDs1qndzfY+8WJVxVjieHFUBwo4AZ5HtPGUYgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgf\/2Q==)","37bf8051":"# Average Distance","e0d8cb60":"# Radius (Opposite to diameter)\nThe radius of a graph is the minimum graph eccentricity of any graph vertex in a graph","09bb501f":"# Clique\nA clique is a subset of vertices of an undirected graph G such that every two distinct vertices in the clique are adjacent; that is, its induced subgraph is complete.\n![](https:\/\/iq.opengenus.org\/content\/images\/2019\/06\/clique.png)","344a6ee3":"# **Authorities & Hub Score**","9d7bb573":"# Bipartite \n**A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V**.","849ea570":"# Degrees","bb479e97":"# DFS (Depth first search)","2027ab51":"**Getting Graph info**\nGraph has 5.8k+ Nodes and 21k+ Edges","053943c9":"![](https:\/\/i.ibb.co\/pvsGVH6\/1.png)","a8a667fb":"# Showing graph according to trust level","9c3a3546":"**Getting only parallel edges of multigraph**","d7ba0861":"# **Edge Direction**","5be96b5b":"# Local Clustering Coefficent\nThe Local Clustering Coefficient algorithm computes the local clustering coefficient for each node in the graph. The local clustering coefficient Cn of a node n describes the likelihood that the neighbours of n are also connected. To compute Cn we use the number of triangles a node is a part of Tn, and the degree of the node dn. The formula to compute the local clustering coefficient is as follows:\n\n![](https:\/\/neo4j.com\/docs\/graph-data-science\/current\/images\/lcc_formula.svg)","2ab242ee":"# Degree Distribution","7eaaae47":"# Diameter\nThe diameter of a graph is the maximum eccentricity of any vertex in the graph. **That is, it is the greatest distance between any pair of vertices**","406b356d":"# Bipartitle Graph Example","4fb22e8d":"# **Downloading the dataset from stanfrod univeristy website**\nThis is who-trusts-whom network of people who trade using Bitcoin on a platform called Bitcoin OTC. Since Bitcoin users are anonymous, there is a need to maintain a record of users' reputation to prevent transactions with fraudulent and risky users. Members of Bitcoin OTC rate other members in a scale of -10 (total distrust) to +10 (total trust) in steps of 1. This is the first explicit weighted signed directed network available for research.","d81e76a8":"The HITS algorithm computes two numbers for a node. Authorities estimates the node value based on the incoming links. Hubs estimates the node value based on outgoing links.\n\n**Return HITS hubs and authorities values for nodes.**","c58b2ad5":"# Connected Graph","e3d4e079":"# For better understanding of distance matrix\nwe create a simple graph of only 5 nodes","33187873":"# SMALL WORLD MODEL\n\n**Small World Phenomenon is the study and notion that we are all connected via a small number of edges.**\n1. First create a ring over n nodes. Then each node in the ring is connected with its k nearest neighbors (k-1 neighbors if k is odd).\n2. Then shortcuts are created by replacing some edges as follows:\n3. for each edge u-v in the underlying \u201cn-ring with k nearest neighbors\u201d with probability p    replace it with a new edge u-w with uniformly random choice of existing node w.\n\n","e8b49815":"# Simple Graph Version","53ea5338":"# Cycles (Self-loop)","7ebdc010":"# Page Rank\n\nPageRank computes a ranking of the nodes in the graph G based on the structure of the incoming links. It was originally designed as an algorithm to rank web pages.","43b5285f":"**In degree distribution**","43741d96":"**Reading dataset using from_pandas_edgelist function**","dd0f0624":"# Distance matrix\n\nA distance matrix is a square matrix containing the distances, taken pairwise, between the elements of a set.\n\n![](https:\/\/encrypted-tbn0.gstatic.com\/images?q=tbn:ANd9GcQyk5FHwAhSAMNBAcFnbP62mrUxC4bkK3w8tg&usqp=CAU)","023c4ff9":"# Directed Weighted Graph","21d2831e":"# Connectivity in directed graph\nA directed graph is ***weakly connected*** if, and only if, the graph is connected when the \ndirection of the edge between nodes is ignored\nOur directed graph is weekly connected but not strongly connected\n\nA directed graph is called ***strongly connected*** if there is a path in each direction between each pair of vertices of the graph. That is, a path exists from the first vertex in the pair to the second, and another path exists from the second vertex to the first.","3c55a6d8":"# **Directed Graph Version**","f3c9ea75":"# Graph Components\n\nA component of an undirected graph is an induced subgraph in which any two vertices are connected to each other by paths,  \n* **And which is connected to no additional vertices in the rest of the graph**"}}