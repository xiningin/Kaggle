{"cell_type":{"da30af74":"code","3927be67":"code","f9f3b54c":"code","aa2410bd":"code","5f6fc76c":"code","5290a803":"code","98642ca4":"code","194b5e75":"code","f660e692":"code","217cede6":"code","ae137df0":"code","32330ab9":"code","38a30fad":"code","6a90a5cd":"code","ec2a374e":"code","4964e107":"code","6fef8de9":"code","c1f60964":"code","69e48046":"code","5ae4fe63":"code","c8a2684e":"code","5efe76ff":"code","8e897e0a":"markdown","8966dea8":"markdown","c8c933c2":"markdown","9306ae84":"markdown","ffe6b5f9":"markdown","5fc4920f":"markdown","3bc55f9c":"markdown","d1c14951":"markdown","502fb68c":"markdown"},"source":{"da30af74":"# Import numpy, pandas, and matplotlib using the standard aliases. \n# Import mpimg from matplotlib.image\n# Import train_test_split from sklearn\n# Import pickle. \n# Import tensorflow and all needed tools from tensorflow.keras. \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nimport pickle\n\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import *\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator","3927be67":"# Load the training data into a DataFrame named 'train'. \n# Print the shape of the resulting DataFrame. \n# You do not need the test data in this notebook. \ntrain = pd.read_csv(f'..\/input\/cifar10-mu\/train.csv')\n\nprint('Training Set Size:', train.shape)","f9f3b54c":"# Display the head of the train DataFrame. \ntrain.head()","aa2410bd":"# Display a DataFrame showing the proportion of observations with each \n# possible of the target variable (which is label). \n(train.label.value_counts() \/ len(train)).to_frame()\n","5f6fc76c":"train.info()","5290a803":"# Sample 16 images from the training set and display these along with their labels.\n# The images should be arranged in a 4x4 grid of subplots. \n# Please set the figure sizeto (6,6)\nsample = train.sample(n=16).reset_index()\n\nplt.figure(figsize=(6,6))\n\nfor i, row in sample.iterrows():\n\n    img = mpimg.imread(f'\/kaggle\/input\/cifar10-mu\/train_images\/{row.filename}')    \n    label = row.label\n    desc_labels = ['airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']\n    plt.subplot(4,4,i+1)\n    plt.imshow(img)\n    plt.text(0, -5, desc_labels[int(label)], color='k')\n        \n    plt.axis('off')\n\nplt.tight_layout()\nplt.show()","98642ca4":"# Split the dataframe train into two DataFrames named train_df and valid_df. \n# Use 20% of the data for the validation set. \n# Use stratified sampling so that the label proportions are preserved.\n# Set a random seed for the split. \ntrain_df, valid_df = train_test_split(train, test_size=0.2, random_state=1, stratify=train.label)\n\nprint(train_df.shape)\nprint(valid_df.shape)","194b5e75":"# Create image data generators for both the training set and the validation set. \n# Use the data generators to scale the pixel values by a factor of 1\/255. \ntrain_datagen = ImageDataGenerator(rescale=1\/255)\nvalid_datagen = ImageDataGenerator(rescale=1\/255)","f660e692":"# Complete the code for the data loaders below. \n\nBATCH_SIZE = 128\ntrain_path = '..\/input\/cifar10-mu\/train_images'\ntrain_df['label'] = train_df['label'].astype(str)\nvalid_df['label'] = valid_df['label'].astype(str)\ntrain_loader = train_datagen.flow_from_dataframe(\n    dataframe = train_df,\n    directory = train_path,\n    x_col = 'filename',\n    y_col = 'label',\n    batch_size = BATCH_SIZE,\n    seed = 1,\n    shuffle = True,\n    class_mode = 'categorical',\n    target_size = (32,32)\n)\n\nvalid_loader = train_datagen.flow_from_dataframe(\n    dataframe = valid_df,\n    directory = train_path,\n    x_col = 'filename',\n    y_col = 'label',\n    batch_size = BATCH_SIZE,\n    seed = 1,\n    shuffle = True,\n    class_mode = 'categorical',\n    target_size = (32,32)\n)","217cede6":"# Run this cell to determine the number of training and validation batches. \n\nTR_STEPS = len(train_loader)\nVA_STEPS = len(valid_loader)\n\nprint(TR_STEPS)\nprint(VA_STEPS)","ae137df0":"# Use this cell to construct a convolutional neural network model. \n# Your model should make use of each of the following layer types:\n#    Conv2D, MaxPooling2D, Dropout, BatchNormalization, Flatten, Dense\n# You can start by mimicking the architecture used in the \n# Aerial Cactus competetition, but you should explore different architectures\n# by adding more layers and\/or adding more nodes in individual layers\n\nnp.random.seed(1)\ntf.random.set_seed(1)\n\ncnn = Sequential([\n    Conv2D(32, (3,3), activation = 'relu', padding = 'same', input_shape=(32,32,3)),\n    Conv2D(32, (3,3), activation = 'relu', padding = 'same'),\n    Conv2D(32, (3,3), activation = 'relu', padding = 'same'),\n    MaxPooling2D(2,2),\n    Dropout(0.25),\n    BatchNormalization(),\n\n    Conv2D(64, (3,3), activation = 'relu', padding = 'same'),\n    Conv2D(64, (3,3), activation = 'relu', padding = 'same'),\n    Conv2D(64, (3,3), activation = 'relu', padding = 'same'),\n    MaxPooling2D(2,2),\n    Dropout(0.25),\n    BatchNormalization(),\n    \n    Conv2D(128, (3,3), activation = 'relu', padding = 'same'),\n    Conv2D(128, (3,3), activation = 'relu', padding = 'same'),\n    Conv2D(128, (3,3), activation = 'relu', padding = 'same'),\n    MaxPooling2D(2,2),\n    Dropout(0.5),\n    BatchNormalization(),\n    \n    Conv2D(256, (3,3), activation = 'relu', padding = 'same'),\n    Conv2D(256, (3,3), activation = 'relu', padding = 'same'),\n    Conv2D(256, (3,3), activation = 'relu', padding = 'same'),\n    MaxPooling2D(2,2),\n    Dropout(0.5),\n    BatchNormalization(),\n    Flatten(),\n    \n    Dense(128, activation='relu'),\n    Dropout(0.5),\n    Dense(64, activation='relu'),\n    Dropout(0.4),\n    Dense(32, activation='relu'),\n    Dropout(0.3),\n    BatchNormalization(),\n    Dense(10, activation='softmax')\n])\n\ncnn.summary()","32330ab9":"# Define an optimizer and select a learning rate. \n# Then compile the model. \nopt = tf.keras.optimizers.Adam(0.001)\ncnn.compile(loss='categorical_crossentropy', optimizer=opt, metrics=['accuracy'])","38a30fad":"%%time \n\nh1 = cnn.fit(\n    x = train_loader, \n    steps_per_epoch = TR_STEPS, \n    epochs = 30,\n    validation_data = valid_loader, \n    validation_steps = VA_STEPS, \n    verbose = 1\n)\n","6a90a5cd":"history = h1.history\nprint(history.keys())","ec2a374e":"epoch_range = range(1, len(history['loss'])+1)\n\nplt.figure(figsize=[14,4])\nplt.subplot(1,2,1)\nplt.plot(epoch_range, history['loss'], label='Training')\nplt.plot(epoch_range, history['val_loss'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Loss'); plt.title('Loss')\nplt.legend()\nplt.subplot(1,2,2)\nplt.plot(epoch_range, history['accuracy'], label='Training')\nplt.plot(epoch_range, history['val_accuracy'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Accuracy'); plt.title('Accuracy')\nplt.legend()\n\nplt.tight_layout()\nplt.show()","4964e107":"#Training Run 2\ntf.keras.backend.set_value(cnn.optimizer.learning_rate, 0.0001)\n","6fef8de9":"%%time \n\nh2 = cnn.fit(\n    x = train_loader, \n    steps_per_epoch = TR_STEPS, \n    epochs = 30,\n    validation_data = valid_loader, \n    validation_steps = VA_STEPS, \n    verbose = 1\n)","c1f60964":"for k in history.keys():\n    history[k] += h2.history[k]\n\nepoch_range = range(1, len(history['loss'])+1)\n\nplt.figure(figsize=[14,4])\nplt.subplot(1,2,1)\nplt.plot(epoch_range, history['loss'], label='Training')\nplt.plot(epoch_range, history['val_loss'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Loss'); plt.title('Loss')\nplt.legend()\nplt.subplot(1,2,2)\nplt.plot(epoch_range, history['accuracy'], label='Training')\nplt.plot(epoch_range, history['val_accuracy'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Accuracy'); plt.title('Accuracy')\nplt.legend()\n\nplt.legend()\nplt.tight_layout()\nplt.show()","69e48046":"#Training Run 3\ntf.keras.backend.set_value(cnn.optimizer.learning_rate, 0.00001)\n","5ae4fe63":"%%time \n\nh3 = cnn.fit(\n    x = train_loader, \n    steps_per_epoch = TR_STEPS, \n    epochs = 30,\n    validation_data = valid_loader, \n    validation_steps = VA_STEPS, \n    verbose = 1\n)","c8a2684e":"for k in history.keys():\n    history[k] += h3.history[k]\n\nepoch_range = range(1, len(history['loss'])+1)\n\nplt.figure(figsize=[14,4])\nplt.subplot(1,2,1)\nplt.plot(epoch_range, history['loss'], label='Training')\nplt.plot(epoch_range, history['val_loss'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Loss'); plt.title('Loss')\nplt.legend()\nplt.subplot(1,2,2)\nplt.plot(epoch_range, history['accuracy'], label='Training')\nplt.plot(epoch_range, history['val_accuracy'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Accuracy'); plt.title('Accuracy')\nplt.legend()\n\nplt.legend()\nplt.tight_layout()\nplt.show()","5efe76ff":"# When you are satisfied with the model you have found, \n# save the model and the combined history dictionary to files.\n# Download these filesto your local device and then upload them \n# as a Kaggle dataset. \ncnn.save('cifar10_model_v05.h5')\npickle.dump(history, open(f'cifar10_history_v05.pkl', 'wb'))","8e897e0a":"# Load Training DataFrame","8966dea8":"# Build Network","c8c933c2":"# Train Network","9306ae84":"# Data Generators","ffe6b5f9":"# Label Distribution","5fc4920f":"# Save Model and History","3bc55f9c":"# Import Packages","d1c14951":"# View Sample of Images","502fb68c":"# CIFAR 10 Image Classification\n\nMost of the code cells below include comments explaining the task to be performed in those cells. Please delete the comments and add code to perform those tasks. There are a few code cells in which code has already been provided for you. In some cases, you will need to complete this code.\n\n\u26a0 **NOTE:** You should make use of GPU acceleration in this notebook. \n\n"}}