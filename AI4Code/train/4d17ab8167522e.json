{"cell_type":{"b49a43ca":"code","4a66eb2e":"code","2fb03e34":"code","c049881c":"code","6b1b932f":"code","5bc47b23":"code","b9b122c9":"code","e6cc7ec5":"code","0072d8cd":"code","735c7ef2":"code","5766e8d9":"code","85c1b04b":"code","cb439dbd":"code","b3196048":"code","706d3c99":"code","bd33f9e3":"code","7374771d":"markdown"},"source":{"b49a43ca":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","4a66eb2e":"import random \nvalues =[]\ntarget = []\nfor i in range(500):\n    values.append(random.randint(1, 300))\n    target.append(0)\nfor i in range(300):\n    values.append(random.randint(1000, 2500))    \n    target.append(1)\nfor i in range(200):\n    values.append(random.randint(5000, 7500))    \n    target.append(2)    \nfor i in range(50):\n    values.append(random.randint(10000, 15000))    \n    target.append(3)\nfor i in range(50):\n    values.append(random.randint(20000, 25000))    \n    target.append(4)            \nfor i in range(50):\n    values.append(random.randint(35000, 40000))    \n    target.append(4)                ","2fb03e34":"df = pd.DataFrame()\ndf['values'] = values\ndf['target'] = target","c049881c":"import matplotlib.pyplot as plt\nplt.plot()\n\nplt.title('Dataset')\nplt.scatter(df.index, df['values'])\nplt.show()","6b1b932f":"from sklearn.cluster import KMeans\nfrom sklearn import metrics\nfrom scipy.spatial.distance import cdist\nimport numpy as np\n\ndistortions = []\ninertias = []\nmapping1 = {}\nmapping2 = {}\nK = range(1, 10)\nX = df['values'].values.reshape(-1,1)\nfor k in K:\n    # Building and fitting the model\n    kmeanModel = KMeans(n_clusters=k).fit(X)\n    kmeanModel.fit(X)\n \n    distortions.append(sum(np.min(cdist(X, kmeanModel.cluster_centers_,\n                                        'euclidean'), axis=1)) \/ X.shape[0])\n    inertias.append(kmeanModel.inertia_)\n \n    mapping1[k] = sum(np.min(cdist(X, kmeanModel.cluster_centers_,\n                                   'euclidean'), axis=1)) \/ X.shape[0]\n    mapping2[k] = kmeanModel.inertia_","5bc47b23":"for key, val in mapping1.items():\n    print(f'{key} : {val}')","b9b122c9":"plt.plot(K, distortions, 'bx-')\nplt.xlabel('Values of K')\nplt.ylabel('Distortion')\nplt.title('The Elbow Method using Distortion')\nplt.show()","e6cc7ec5":"for key, val in mapping2.items():\n    print(f'{key} : {val}')","0072d8cd":"plt.plot(K, inertias, 'bx-')\nplt.xlabel('Values of K')\nplt.ylabel('Inertia')\nplt.title('The Elbow Method using Inertia')\nplt.show()","735c7ef2":"temp = pd.DataFrame(distortions , columns=['distortions'])\ntemp['Diff'] = temp.diff()\ntemp['Diff'] = temp['Diff'].abs()\ntemp['k-value'] = K\n#temp = temp.dropna(axis = 0)\n\ntemp.head(10)","5766e8d9":"# temp['Diff 2'] = temp['Diff'].diff()\n# temp['Diff 2'] = temp['Diff 2'].abs()\n# temp.head(10)\ndiff_ratio = [np.nan ]\nfor index , row in temp.iterrows() :\n    if index > 0:\n        diff_ratio.append(row['Diff']\/distortions[index -1])\ntemp['Diff Slope'] = diff_ratio\ntemp.head(10)","85c1b04b":"#no_of_cluster = temp[temp['Diff 2'] ==temp['Diff 2'].max()]['k-value'].values[0] +1\nno_of_cluster = temp[temp['Diff Slope'] ==temp['Diff Slope'].max()]['k-value'].values[0]\nprint(no_of_cluster)","cb439dbd":"kmeanModel = KMeans(n_clusters=no_of_cluster).fit(X)\ncluster_no = kmeanModel.fit_predict(X)\nset(cluster_no)","b3196048":"df['Cluster'] = cluster_no\ndf['Cluster'].value_counts()","706d3c99":"df['Cluster'].value_counts(normalize=True)","bd33f9e3":"# We can classify cluster with less than 5 % threshold as anamolous\n","7374771d":"# Ideal number of cluster is where the slope does not decrease fast \n# distortions  is better than inertia \n"}}