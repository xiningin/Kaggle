{"cell_type":{"b1caf8da":"code","aa44c37c":"code","a139ece5":"code","ece4e7e2":"code","9a6748c4":"code","1be05d73":"code","3eafec6b":"code","a27b4364":"code","40bf0239":"code","e84f926b":"code","39481b3b":"code","dcac9340":"code","95439cee":"code","5a4099f0":"code","36554a63":"code","c5c62c04":"code","9de6c120":"code","ad4de34d":"code","23900b4e":"code","db786480":"code","dd7b2d1d":"markdown","d0d25973":"markdown"},"source":{"b1caf8da":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nfrom itertools import groupby\nimport matplotlib.pyplot as plt\n\nfrom sklearn.linear_model import LinearRegression\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","aa44c37c":"dtypes = {\n     'sessionTime' : \"float32\",\n     'frameIdentifier' : \"uint32\",\n     'pilot_index' : \"uint8\",\n     'worldPositionX' : \"float32\",\n     'worldPositionY' : \"float32\",\n     'worldPositionZ' : \"float32\",\n     'worldVelocityX' : \"float32\",\n     'worldVelocityY' : \"float32\",\n     'worldVelocityZ' : \"float32\",\n     'worldForwardDirX' : \"int32\",\n     'worldForwardDirY' : \"int32\",\n     'worldForwardDirZ' : \"int32\",\n     'worldRightDirX' : \"int32\",\n     'worldRightDirY' : \"int32\",\n     'worldRightDirZ' : \"int32\",\n     'gForceLateral' : \"float32\",\n     'gForceLongitudinal' : \"float32\",\n     'gForceVertical' : \"float32\",\n     'yaw' : \"float32\",\n     'pitch' : \"float32\",\n     'roll' : \"float32\",\n     'speed' : \"float32\",\n     'throttle' : \"float32\",\n     'steer' : \"float32\",\n     'brake' : \"float32\",\n     'clutch': \"uint8\",\n     'gear': \"uint8\",\n     'engineRPM' : \"uint32\",\n     'drs' : \"bool\",\n     'engineTemperature': \"uint8\",\n     'fuelMix': \"uint8\",\n     'pitLimiterStatus': \"bool\",\n     'fuelInTank' : \"float32\",\n     'fuelRemainingLaps' : \"float32\",\n     'ersStoreEnergy' : \"uint32\",\n     'ersDeployMode' : \"uint32\",\n     'ersHarvestedThisLapMGUK' : \"uint32\",\n     'ersHarvestedThisLapMGUH' : \"uint32\",\n     'ersDeployedThisLap' : \"uint32\",\n     'carPosition' : \"uint8\",\n     'currentLapTime' : \"float32\",\n     'currentLapNum' : \"uint8\",\n     'sector': \"uint8\",\n     'lapDistance' : \"float32\",\n     'totalDistance' : \"float32\",\n}\n\nfillnas = {\n    'clutch' : 0,\n    'gear' : 0,\n    'engineRPM': 0,\n    \"engineTemperature\" : 0,\n    \"fuelMix\": 1,\n    \"pitLimiterStatus\" : False,\n    \"ersStoreEnergy\" : 4e7,\n    \"ersDeployMode\" : 1,\n    \"ersHarvestedThisLapMGUK\" : 0,\n    \"ersHarvestedThisLapMGUH\" : 0,\n    \"ersDeployedThisLap\" : 0,\n    \"sector\" : 0\n}","a139ece5":"df = pd.read_csv(\"\/kaggle\/input\/f1-2020-race-data\/TelemetryData_3335673977098133433.csv\")","ece4e7e2":"for col, dtype in dtypes.items():\n    if col in fillnas:\n        df[col] = df[col].fillna(fillnas[col])\n    df[col] = df[col].astype(dtype)","9a6748c4":"df.head()","1be05d73":"df.info()","3eafec6b":"def remove_flashbacks(df, pilot=19):\n    df2 = df[df[\"pilot_index\"] == pilot]\n    frame, X = df2[\"frameIdentifier\"].values, df2[[\"worldPositionX\", \"worldPositionY\", \"worldPositionZ\"]].values\n    dist_sq = ((X[1:, :] - X[:-1, :])**2).sum(axis=1)\n    idx_frame_after_flashback = np.argwhere(dist_sq > 1000).flatten() + 1 # to add the frame 0 shifted for the distance computation\n    \n    number_flashback = idx_frame_after_flashback.shape[0]\n    pos_before_flashback = X[idx_frame_after_flashback-1]\n    pos_after_flashback = X[idx_frame_after_flashback]  # position after validateing the flashback\n    frames_before_flashback = frame[idx_frame_after_flashback-1]\n    frames_after_flashback = frame[idx_frame_after_flashback] # first frame after validating the flashback\n    \n    for i in range(number_flashback):\n        X_start = pos_after_flashback[i, :]\n        frame_start = frames_after_flashback[i]\n        idx_pos = idx_frame_after_flashback[i]\n        d = ((X[idx_pos-500:idx_pos] - X_start)**2).sum(axis=1)\n        start, stop = frame[idx_pos - 500 + np.argmin(d)], frame_start\n        df = df[(df[\"frameIdentifier\"] > stop) | (df[\"frameIdentifier\"] <= start)]\n        \n    return df","a27b4364":"df = remove_flashbacks(df, pilot=19)","40bf0239":"df_tyre = df[[\n    \"frameIdentifier\",\n    \"pilot_index\",\n    \"currentLapTime\",\n    \"currentLapNum\",\n    \"tyresSurfaceTemperature\",\n    \"tyresInnerTemperature\",\n    \"tyresPressure\",\n    \"fuelInTank\",\n    \"tyresWear\",\n    \"actualTyreCompound\",\n    \"tyresDamage\"\n]]","e84f926b":"df_tyre.head()","39481b3b":"wear = df_tyre[\"tyresDamage\"].str.split(\"\/\", expand=True).astype(\"float32\")\nwear.columns = [\"tyresDamage_FL\", \"tyresDamage_FR\", \"tyresDamage_RL\", \"tyresDamage_RR\"]\n\nsurface_temp = df_tyre[\"tyresSurfaceTemperature\"].str.split(\"\/\", expand=True).astype(\"float32\")\nsurface_temp.columns = [\"tyresSurfaceTemperature_FL\", \"tyresSurfaceTemperature_FR\", \"tyresSurfaceTemperature_RL\", \"tyresSurfaceTemperature_RR\"]\n\ninner_temp = df_tyre[\"tyresInnerTemperature\"].str.split(\"\/\", expand=True).astype(\"float32\")\ninner_temp.columns = [\"tyresInnerTemperature_FL\", \"tyresInnerTemperature_FR\", \"tyresInnerTemperature_RL\", \"tyresInnerTemperature_RR\"]\n\npressure = df_tyre[\"tyresPressure\"].str.split(\"\/\", expand=True).astype(\"float32\")\npressure.columns = [\"tyresPressure_FL\", \"tyresPressure_FR\", \"tyresPressure_RL\", \"tyresPressure_RR\"]\n\ndf_tyre = pd.concat([df_tyre[[\"frameIdentifier\", \"pilot_index\", \"currentLapTime\", \"fuelInTank\", \"actualTyreCompound\", \"currentLapNum\"]], wear, surface_temp, inner_temp, pressure], axis=1)","dcac9340":"light_df = df_tyre[df_tyre[\"pilot_index\"] == 19]\nsummary = light_df.groupby('currentLapNum').tail(1)\n\nplt.plot(summary['currentLapNum'], summary[\"tyresDamage_FR\"])\nplt.plot(summary['currentLapNum'], summary[\"tyresDamage_FL\"])\nplt.plot(summary['currentLapNum'], summary[\"tyresDamage_RR\"])\nplt.plot(summary['currentLapNum'], summary[\"tyresDamage_RL\"])\nplt.show()","95439cee":"wear = summary[[\"tyresDamage_FL\", \"tyresDamage_FR\", \"tyresDamage_RL\", \"tyresDamage_RR\"]].mean(axis=1).to_list()\ntyre = summary[\"actualTyreCompound\"].to_list()","5a4099f0":"wears = []\nbuffer = [wear[0]]\nfor c, prev, curr in zip(tyre[:-1], wear[:-1], wear[1:]):\n    if prev > curr:\n        wears.append((c, buffer))\n        buffer = [curr]\n    else:\n        buffer.append(curr)\nwears.append((c, buffer))","36554a63":"for c, w in wears:\n    plt.plot(range(1, len(w)+1), w, label=c)\n    plt.plot(range(1, len(w)+1), w, label=c)\nplt.show()","c5c62c04":"result = {\n    \"soft\" : [],\n    \"medium\" : [],\n    \"hard\" : [],\n}\n\nfor c, w in wears:\n    model = LinearRegression(fit_intercept=False)  # at lap 0, wear is 0 (no califications)\n    X = np.arange(1, len(w)+1).reshape(-1, 1)\n    y = np.array(w).reshape(-1, 1)\n    model.fit(X, y)\n    result[c].append(model.coef_[0][0])\n\nresult","9de6c120":"def get_wear_factor(df):\n    summary = df.groupby('currentLapNum').tail(1)\n    summary = summary[summary[\"currentLapTime\"] > 50]\n    \n    wear = summary[[\"tyresDamage_FL\", \"tyresDamage_FR\", \"tyresDamage_RL\", \"tyresDamage_RR\"]].mean(axis=1).to_list()\n    tyre = summary[\"actualTyreCompound\"].to_list()\n    \n    wears = []\n    buffer = [wear[0]]\n    for c, prev, curr in zip(tyre[:-1], wear[:-1], wear[1:]):\n        if prev > curr:\n            wears.append((c, buffer))\n            buffer = [curr]\n        else:\n            buffer.append(curr)\n    wears.append((c, buffer))\n    \n    result = {\n        \"soft\" : [],\n        \"medium\" : [],\n        \"hard\" : [],\n    }\n\n    for c, w in wears:\n        model = LinearRegression(fit_intercept=False)  # at lap 0, wear is 0 (no califications)\n        X = np.arange(1, len(w)+1).reshape(-1, 1)\n        y = np.array(w).reshape(-1, 1)\n        model.fit(X, y)\n        result[c].append(model.coef_[0][0])\n    \n    return result","ad4de34d":"all_pilots = df[\"pilot_index\"].unique()\nwear_per_driver = []\n\nfor pilot_id in all_pilots:\n    light_df = df_tyre[df_tyre[\"pilot_index\"] == pilot_id]\n    wear_per_driver.append(get_wear_factor(light_df))\n\nwear_per_driver","23900b4e":"agg_result = {\n    \"soft\" : [],\n    \"medium\" : [],\n    \"hard\" : [],\n}\n\nfor result in wear_per_driver:\n    for key, vals in result.items():\n        agg_result[key] += vals","db786480":"plt.figure(figsize=(20, 12))\nplt.boxplot([agg_result[\"soft\"], agg_result[\"medium\"], agg_result[\"hard\"]])\nplt.xticks([1, 2, 3], [\"soft\", \"medium\", \"hard\"])\nplt.ylabel(\"Wear per lap in %\")\nplt.title(\"Tyre Wear\")\nplt.show()","dd7b2d1d":"# Parsing tyre features","d0d25973":"# Refactor code"}}