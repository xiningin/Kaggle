{"cell_type":{"e913b3ea":"code","da32b3fe":"code","2e0f8116":"code","14c4bc98":"code","546bf1f7":"code","b764ec9d":"code","01b43fc2":"code","adc32495":"code","37839c83":"code","1242e612":"code","6e6203d1":"code","eaf098e7":"code","79148524":"code","55003040":"code","b0c0c007":"code","ef53a7ee":"code","7e1a464a":"code","e8adeb6c":"code","fe4564b6":"code","a84abde8":"code","94e3d319":"code","0c243172":"code","5ebd8f17":"code","9df379ac":"code","e4ccc1b9":"code","115a8e0e":"code","6d67aa98":"code","6a25ee3a":"code","6d1b773b":"code","65eb7937":"code","2ff62d0c":"code","2cc96b43":"code","beef58d9":"code","ccadbdac":"code","4eb33442":"code","a62543d6":"code","b0680535":"code","c70d9bdd":"code","ddebc8e7":"code","9d891551":"code","56cabeac":"code","4e7d68a3":"code","51f8d987":"code","46ebe005":"code","9dd499de":"markdown","949d57a8":"markdown","a72490b7":"markdown","4c9b1a43":"markdown","29fcfa2b":"markdown","2aff7755":"markdown","3b9e29ad":"markdown","0485cf06":"markdown","d29380fe":"markdown","fa81dab4":"markdown","e426bc4a":"markdown","1d012269":"markdown","5a423afa":"markdown","9d4c13f6":"markdown","202ca2d1":"markdown","4a8df5a0":"markdown","cadf973c":"markdown","3889dd61":"markdown","f5f5d636":"markdown","423c0081":"markdown","a2c5213a":"markdown","064d8df1":"markdown","a1df0a29":"markdown","9e5f3bc0":"markdown","049d9eb0":"markdown","d5185339":"markdown","e202debb":"markdown","02707d76":"markdown","9a8aeca0":"markdown","0dea0c31":"markdown","47a084a5":"markdown","24369ae5":"markdown","0871549b":"markdown","bc9a1fc2":"markdown","36f99de6":"markdown","9ab64d70":"markdown","779160ee":"markdown","329e02a8":"markdown","3ec1734b":"markdown"},"source":{"e913b3ea":"import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport scipy.stats as stats\nimport numpy as np\nimport ast\nimport folium\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        \nimport warnings\nwarnings.filterwarnings(\"ignore\")","da32b3fe":"#json file to use with folium\nstate_geo = \"\/kaggle\/input\/geo-data\/custom.geo.json\"","2e0f8116":"df = pd.read_csv(\"\/kaggle\/input\/krakow-ta-restaurans-data-raw\/TA_restaurants_curated.csv\")\ndf.head(1)","14c4bc98":"df.info()","546bf1f7":"df[\"Price Range\"].unique()","b764ec9d":"df.loc[0, \"Cuisine Style\"]","01b43fc2":"#Dropping the columns that I am not planning on using.\ndf.drop([\"Unnamed: 0\", \"Reviews\", \"URL_TA\", \"ID_TA\", \"Ranking\"], axis = 1, inplace = True)\n\n#Renaming columns for better view\ndf.rename(columns={\"Cuisine Style\" : \"Cuisine\", \n                   \"Price Range\": \"PriceRange\", \n                   \"Number of Reviews\" : \"numOfRevs\"}, inplace = True)\n\n#Replacing price range with ordinal values.\ndf.replace({\"$\": 1, \"$$ - $$$\": 2, \"$$$$\": 3}, inplace = True)\n\n#Dropping data with rating below 0.\ndf.drop(df[df.Rating < 0].index, inplace = True)\n\n#This function transforms Cuisine values into a string, for better processing\ndef transform(line):\n    try:\n        txt = \"\"\n        line = ast.literal_eval(line)\n        for i in range(len(line)):\n            if i != len(line)-1:\n                txt += line[i] + \",\"\n            else:\n                txt += line[i]\n    except:\n        txt = \"\"\n    return txt\n\n#Applying the function\ndf.Cuisine = df.Cuisine.apply(lambda x : transform(x))","adc32495":"df.head()","37839c83":"#Here, I created a dictionary to hold the all cuisine types.\n#I used it to fill some of the missing cuisine values, from the restaurant name.\n#If the restaurant has its cuisine type inside of its name, fill the missing value with it.\ncuisineDict = {}\nfor i in df.Cuisine:\n    arr = i.split(\",\")\n    for j in range(len(arr)):\n        if arr[j] in cuisineDict:\n            cuisineDict[arr[j]] += 1\n        else:\n            cuisineDict[arr[j]] = 1\n               \nfor i in cuisineDict:\n    df.loc[(df.Name.str.lower().str.contains(i.lower()) & (df.Cuisine == \"\")), \"Cuisine\"] = i","1242e612":"df[df.Cuisine != \"\"].count()[1] - 94176","6e6203d1":"#Dropping the missing Cuisine values\ndf.drop(df[df.Cuisine == \"\"].index, inplace = True)\n\n#I do not need the name column anymore\ndf.drop(\"Name\", axis = 1, inplace = True)","eaf098e7":"cuisineDict","79148524":"for i in [\"Mediterranean\", \"Central European\", \"Eastern European\", \"European\", \"Scandinavian\", \"Vegetarian Friendly\"]:\n    df.loc[df.Cuisine.str.contains((\",\" + i)), \"Cuisine\"] =  df.loc[df.Cuisine.str.contains((\",\" + i)), \"Cuisine\"].replace((\",\" + i), \"\", regex = True)\n    df.loc[df.Cuisine.str.contains((i + \",\")), \"Cuisine\"] =  df.loc[df.Cuisine.str.contains((i + \",\")), \"Cuisine\"].replace((i + \",\"), \"\", regex = True)\n    \n#Now I can just keep the first cuisine in the list\ndf.Cuisine = df.Cuisine.apply(lambda x : x.split(\",\")[0])","55003040":"df.info()","b0c0c007":"df.PriceRange.fillna(df.groupby([\"City\", \"Cuisine\"])[\"PriceRange\"].agg({pd.Series.mode}).values[0,0], inplace=True)\ndf.Rating.fillna(df.groupby([\"City\", \"Cuisine\", \"PriceRange\"])[\"Rating\"].agg({pd.Series.mode}).values[0,0], inplace=True)\ndf.numOfRevs.fillna(df.groupby([\"City\", \"Cuisine\", \"PriceRange\", \"Rating\"])[\"numOfRevs\"].agg({pd.Series.mean}).values[0,0], inplace=True)","ef53a7ee":"df.info()","7e1a464a":"#Creating a dictionary for each city as keys and their countries as values\ncountryDict = {\n    \"Amsterdam\"  : \"Netherlands\",\n    \"Athens\"     : \"Greece\",\n    \"Barcelona\"  : \"Spain\",\n    \"Madrid\"     : \"Spain\",\n    \"Berlin\"     : \"Germany\",\n    \"Hamburg\"    : \"Germany\",\n    \"Munich\"     : \"Germany\",\n    \"Bratislava\" : \"Slovakia\",\n    \"Brussels\"   : \"Belgium\",\n    \"Budapest\"   : \"Hungary\",\n    \"Copenhagen\" : \"Denmark\",\n    \"Dublin\"     : \"Ireland\",\n    \"Edinburgh\"  : \"United Kingdom\",\n    \"Geneva\"     : \"Italy\",\n    \"Milan\"      : \"Italy\",\n    \"Rome\"       : \"Italy\",\n    \"Helsinki\"   : \"Finland\",\n    \"Krakow\"     : \"Poland\",\n    \"Warsaw\"     : \"Poland\",\n    \"Lisbon\"     : \"Portugal\",\n    \"Oporto\"     : \"Portugal\",\n    \"Ljubljana\"  : \"Slovenia\",\n    \"London\"     : \"United Kingdom\",\n    \"Luxembourg\" : \"Luxembourg\",\n    \"Lyon\"       : \"France\",\n    \"Paris\"      : \"France\",\n    \"Oslo\"       : \"Norway\",\n    \"Prague\"     : \"Czech Republic\",\n    \"Stockholm\"  : \"Sweden\",\n    \"Vienna\"     : \"Austria\",\n    \"Zurich\"     : \"Switzerland\"\n}\n\ndf[\"Country\"] = [countryDict[i] for i in df.City]","e8adeb6c":"df.Country.value_counts()","fe4564b6":"#Here I created a dictionary to hold most common three cuisines for each country\n# with their average ratings, average price range and average number of reviews.\n# Also 4th index variable contains the average values for all the values except for the most common cuisine to use it for further analysis.\ncountryDF = {}\nfor i in df.Country.unique():\n    countryDF[i] = [] \nfor i in countryDF:\n    cuis1 = df[df.Country == i].groupby(['Country', \"Cuisine\"])[\"Cuisine\"].count().sort_values(ascending=False).reset_index(name=\"Count\").iloc[0,1]\n    cuis2 = df[df.Country == i].groupby(['Country', \"Cuisine\"])[\"Cuisine\"].count().sort_values(ascending=False).reset_index(name=\"Count\").iloc[1,1]\n    cuis3 = df[df.Country == i].groupby(['Country', \"Cuisine\"])[\"Cuisine\"].count().sort_values(ascending=False).reset_index(name=\"Count\").iloc[2,1]\n    rating1 = df[(df.Country == i) & (df.Cuisine == cuis1)].groupby(\"Cuisine\").mean().reset_index().iloc[0,1]\n    rating2 = df[(df.Country == i) & (df.Cuisine == cuis2)].groupby(\"Cuisine\").mean().reset_index().iloc[0,1]\n    rating3 = df[(df.Country == i) & (df.Cuisine == cuis3)].groupby(\"Cuisine\").mean().reset_index().iloc[0,1]\n    rating4 = df[(df.Country == i) & (df.Cuisine != cuis1)].mean()[0]\n    PriceRange1 = df[(df.Country == i) & (df.Cuisine == cuis1)].groupby(\"Cuisine\").mean().reset_index().iloc[0,2]\n    PriceRange2 = df[(df.Country == i) & (df.Cuisine == cuis2)].groupby(\"Cuisine\").mean().reset_index().iloc[0,2]\n    PriceRange3 = df[(df.Country == i) & (df.Cuisine == cuis3)].groupby(\"Cuisine\").mean().reset_index().iloc[0,2]\n    PriceRange4 = df[(df.Country == i) & (df.Cuisine != cuis1)].mean()[1]\n    numOfRevs1 = df[(df.Country == i) & (df.Cuisine == cuis1)].groupby(\"Cuisine\").mean().reset_index().iloc[0,3]\n    numOfRevs2 = df[(df.Country == i) & (df.Cuisine == cuis2)].groupby(\"Cuisine\").mean().reset_index().iloc[0,3]\n    numOfRevs3 = df[(df.Country == i) & (df.Cuisine == cuis3)].groupby(\"Cuisine\").mean().reset_index().iloc[0,3]\n    numOfRevs4 = df[(df.Country == i) & (df.Cuisine != cuis1)].mean()[2]\n    countryDF[i].append(cuis1)\n    countryDF[i].append(cuis2)\n    countryDF[i].append(cuis3)\n    countryDF[i].append(rating1)\n    countryDF[i].append(PriceRange1)\n    countryDF[i].append(numOfRevs1)\n    countryDF[i].append(rating2)\n    countryDF[i].append(PriceRange2)\n    countryDF[i].append(numOfRevs2)\n    countryDF[i].append(rating3)\n    countryDF[i].append(PriceRange3)\n    countryDF[i].append(numOfRevs3)\n    countryDF[i].append(rating4)\n    countryDF[i].append(PriceRange4)\n    countryDF[i].append(numOfRevs4)\n\n#This dictionary is for holding the the proportion of the most common three cuisines\nproportionCountry = {}\nfor i in df.Country.unique():\n    proportionCountry[i] = []\nfor i in proportionCountry:\n    dfdummy = df[df.Country == i].groupby([\"Country\",\"Cuisine\"])[\"Cuisine\"].count().to_frame(name = \"Count\").sort_values(by = \"Count\", ascending = False).reset_index()\n    prop1 = dfdummy.iloc[0,2] \/ dfdummy.Count.sum()\n    prop2 = dfdummy.iloc[1,2] \/ dfdummy.Count.sum()\n    prop3 = dfdummy.iloc[2,2] \/ dfdummy.Count.sum()\n    proportionCountry[i].append(float(format(prop1*100,\".0f\")))\n    proportionCountry[i].append(float(format(prop2*100,\".0f\")))\n    proportionCountry[i].append(float(format(prop3*100,\".0f\")))\n    \n#Dataframe for holding most common cuisine, average price range,rating and number of reviews.\ndf_Country = df.groupby(['Country']).agg({\"Cuisine\":pd.Series.mode, \"PriceRange\":pd.Series.mean, \"Rating\":pd.Series.mean, \"numOfRevs\": pd.Series.mean})\n\n#Creating a dataframe from the dictionary created before.\ndfco = pd.DataFrame.from_dict(countryDF, orient = \"index\").reset_index()\\\n.rename(columns={\"index\": \"Country\", 0 : \"1stCuisine\", 1 : \"2ndCuisine\", 2 : \"3rdCuisine\",\n                    3 : \"1stRating\", 4 : \"1stPrice\", 5 : \"1stReviews\",\n                    6 : \"2ndRating\", 7 : \"2ndPrice\", 8 : \"2ndReviews\",\n                    9 : \"3rdRating\", 10 : \"3rdPrice\", 11 : \"3rdReviews\",\n                    12 : \"RestRating\", 13 : \"RestPrice\", 14 : \"RestReviews\"})\n\n#another dataframe just for the proportions\ndfpco = pd.DataFrame.from_dict(proportionCountry, orient = \"index\").reset_index()\\\n.rename(columns = {\"index\" : \"Country\", 0 : \"1st%\", 1 : \"2nd%\", 2 : \"3rd%\"})\n\n#joining two dataframes\ndata2 = dfco.set_index('Country').join(dfpco.set_index('Country'))\n\n#finally creating a master dataframe\ncountryLocalization = data2.join(df_Country.reset_index().set_index(\"Country\"))\\\n.drop(columns = \"Cuisine\").rename(columns = {\"PriceRange\" : \"AveragePrice\", \"Rating\" : \"AverageRating\", \"numOfRevs\" : \"AverageReviews\"})\\\n.reset_index()","a84abde8":"countryLocalization","94e3d319":"#below, I renamed 1st most common things into locals, because\n#most of the countries has the 1st ones as locals\n#except for Germany, and belgium, which I manually did.\ncountryLocalization[\"LocalCuisine\"] = countryLocalization[\"1stCuisine\"]\ncountryLocalization[\"LocalPrice\"] = countryLocalization[\"1stPrice\"]\ncountryLocalization[\"LocalRating\"] = countryLocalization[\"1stRating\"]\ncountryLocalization[\"LocalReviews\"] = countryLocalization[\"1stReviews\"]\ncountryLocalization[\"Local%\"] = countryLocalization[\"1st%\"]\n\ncountryLocalization.loc[countryLocalization.Country == \"Germany\", \"LocalCuisine\"] = countryLocalization.loc[countryLocalization.Country == \"Germany\", \"2ndCuisine\"]\ncountryLocalization.loc[countryLocalization.Country == \"Germany\", \"LocalPrice\"] = countryLocalization.loc[countryLocalization.Country == \"Germany\", \"2ndPrice\"]\ncountryLocalization.loc[countryLocalization.Country == \"Germany\", \"LocalRating\"] = countryLocalization.loc[countryLocalization.Country == \"Germany\", \"2ndRating\"]\ncountryLocalization.loc[countryLocalization.Country == \"Germany\", \"LocalReviews\"] = countryLocalization.loc[countryLocalization.Country == \"Germany\", \"2ndReviews\"]\ncountryLocalization.loc[countryLocalization.Country == \"Germany\", \"Local%\"] = countryLocalization.loc[countryLocalization.Country == \"Germany\", \"2nd%\"]\n\ncountryLocalization.loc[countryLocalization.Country == \"Belgium\", \"LocalCuisine\"] = countryLocalization.loc[countryLocalization.Country == \"Belgium\", \"3rdCuisine\"]\ncountryLocalization.loc[countryLocalization.Country == \"Belgium\", \"LocalPrice\"] = countryLocalization.loc[countryLocalization.Country == \"Belgium\", \"3rdPrice\"]\ncountryLocalization.loc[countryLocalization.Country == \"Belgium\", \"LocalRating\"] = countryLocalization.loc[countryLocalization.Country == \"Belgium\", \"3rdRating\"]\ncountryLocalization.loc[countryLocalization.Country == \"Belgium\", \"LocalReviews\"] = countryLocalization.loc[countryLocalization.Country == \"Belgium\", \"3rdReviews\"]\ncountryLocalization.loc[countryLocalization.Country == \"Belgium\", \"Local%\"] = countryLocalization.loc[countryLocalization.Country == \"Belgium\", \"3rd%\"]\n\ncountryLocalization.loc[countryLocalization.Country == \"Norway\", \"LocalCuisine\"] = countryLocalization.loc[countryLocalization.Country == \"Norway\", \"2ndCuisine\"]\ncountryLocalization.loc[countryLocalization.Country == \"Norway\", \"LocalPrice\"] = countryLocalization.loc[countryLocalization.Country == \"Norway\", \"2ndPrice\"]\ncountryLocalization.loc[countryLocalization.Country == \"Norway\", \"LocalRating\"] = countryLocalization.loc[countryLocalization.Country == \"Norway\", \"2ndRating\"]\ncountryLocalization.loc[countryLocalization.Country == \"Norway\", \"LocalReviews\"] = countryLocalization.loc[countryLocalization.Country == \"Norway\", \"2ndReviews\"]\ncountryLocalization.loc[countryLocalization.Country == \"Norway\", \"Local%\"] = countryLocalization.loc[countryLocalization.Country == \"Norway\", \"2nd%\"]\n\n#Here, Other... represents stats for restaurants except for local cuisine.\nfor i,j in countryLocalization[[\"Country\", \"LocalCuisine\"]].values:\n    dfo = df[(df.Cuisine == j) & (df.Country != i)].groupby([\"Cuisine\"]).agg({\"PriceRange\":pd.Series.mean, \"Rating\":pd.Series.mean, \"numOfRevs\": pd.Series.mean})\n    countryLocalization.loc[countryLocalization.Country == i, \"OtherPrice\"] = dfo.iloc[0,0]\n    countryLocalization.loc[countryLocalization.Country == i, \"OtherRating\"] = dfo.iloc[0,1]\n    countryLocalization.loc[countryLocalization.Country == i, \"OtherReviews\"] = dfo.iloc[0,2]\n\n#Mean differences for further analysis\ncountryLocalization[\"PriceDifference\"] = countryLocalization.LocalPrice - countryLocalization.OtherPrice\ncountryLocalization[\"RatingDifference\"] = countryLocalization.LocalRating - countryLocalization.OtherRating\ncountryLocalization[\"ReviewDifference\"] = countryLocalization.LocalReviews - countryLocalization.OtherReviews    ","0c243172":"countryLocalization","5ebd8f17":"plt.figure(figsize = (15,6))\ndata = countryLocalization.loc[(countryLocalization.Country != 'Finland')&(countryLocalization.Country != 'Slovakia')&(countryLocalization.Country != 'Luxembourg'), :].sort_values(by = \"Local%\", ascending = True)\nbar = sns.barplot(data = data, x = \"Country\", y = \"Local%\", palette = \"YlOrBr\")\nplt.xticks(rotation = 90)\nfor p in bar.patches:\n    bar.annotate(format(p.get_height(), '.1f'), \n                   (p.get_x() + p.get_width() \/ 2., p.get_height()), \n                   ha = 'center', va = 'center', \n                   xytext = (0, 9), \n                   textcoords = 'offset points')\nplt.ylabel(\"Localization %\")\nplt.xlabel(None)\nplt.show()","9df379ac":"m = folium.Map(location=[51.216505, 9.879729],width=600, height=500, zoom_start=4,tiles = \"cartodbpositron\" )\n\nfolium.Choropleth(\n    geo_data=state_geo,\n    bins = 5,\n    name=\"choropleth\",\n    data = data,\n    columns=[\"Country\", \"Local%\"],\n    fill_color=\"YlOrBr\",\n    key_on = \"feature.properties.sovereignt\",\n    fill_opacity=0.8,\n    line_opacity=0.4,\n    nan_fill_opacity=0,\n    \n).add_to(m)\n\n\nfolium.LayerControl().add_to(m)\n\nm","e4ccc1b9":"plt.figure(figsize = (15,6))\ndata = countryLocalization.loc[(countryLocalization.Country != 'Finland')&(countryLocalization.Country != 'Slovakia')&(countryLocalization.Country != 'Luxembourg'), :].sort_values(by = \"LocalPrice\", ascending = True)\nbar = sns.barplot(data = data, x = \"Country\", y = \"LocalPrice\", palette = \"YlGnBu\")\nplt.xticks(rotation = 35)\nfor p in bar.patches:\n    bar.annotate(format(p.get_height(), '.1f'), \n                   (p.get_x() + p.get_width() \/ 2., p.get_height()), \n                   ha = 'center', va = 'center', \n                   xytext = (0, 9), \n                   textcoords = 'offset points')\nplt.axhline(y=data.AveragePrice.mean(), color='Black', linestyle='--')\nplt.ylim(1.4)\nplt.ylabel(\"Local Cuisine Price\")\nplt.xlabel(None)\nplt.show()","115a8e0e":"m = folium.Map(location=[51.216505, 9.879729],width=600, height=500, zoom_start=4,tiles = \"cartodbpositron\" )\n\nfolium.Choropleth(\n    geo_data=state_geo,\n    bins = 4,\n    name=\"choropleth\",\n    data = data,\n    columns=[\"Country\", \"LocalPrice\"],\n    fill_color=\"YlGnBu\",\n    key_on = \"feature.properties.sovereignt\",\n    fill_opacity=0.8,\n    line_opacity=0.4,\n    nan_fill_opacity=0\n).add_to(m)\n\nfolium.LayerControl().add_to(m)\n\nm","6d67aa98":"plt.figure(figsize = (15,6))\ndata = countryLocalization.loc[(countryLocalization.Country != 'Finland')&(countryLocalization.Country != 'Slovakia')&(countryLocalization.Country != 'Luxembourg'), :].sort_values(by = \"LocalRating\", ascending = True)\nbar = sns.barplot(data = data, x = \"Country\", y = \"LocalRating\", palette = \"YlOrRd\")\nplt.xticks(rotation = 35)\nfor p in bar.patches:\n    bar.annotate(format(p.get_height(), '.1f'), \n                   (p.get_x() + p.get_width() \/ 2., p.get_height()), \n                   ha = 'center', va = 'center', \n                   xytext = (0, 9), \n                   textcoords = 'offset points')\nplt.axhline(y=data.AverageRating.mean(), color='Black', linestyle='--')\nplt.ylim(3.5,4.4)\nplt.ylabel(\"Local Rating\")\nplt.xlabel(None)\nplt.show()","6a25ee3a":"m = folium.Map(location=[51.216505, 9.879729],width=600, height=500, zoom_start=4,tiles = \"cartodbpositron\" )\n\nfolium.Choropleth(\n    geo_data=state_geo,\n    bins = 4,\n    name=\"choropleth\",\n    data = data,\n    columns=[\"Country\", \"LocalRating\"],\n    fill_color=\"YlOrRd\",\n    key_on = \"feature.properties.sovereignt\",\n    fill_opacity=0.8,\n    line_opacity=0.4,\n    nan_fill_opacity=0\n).add_to(m)\n\nfolium.LayerControl().add_to(m)\n\nm","6d1b773b":"plt.figure(figsize = (15,6))\ndata = countryLocalization.loc[(countryLocalization.Country != 'Finland')&(countryLocalization.Country != 'Slovakia')&(countryLocalization.Country != 'Luxembourg'), :].sort_values(by = \"LocalReviews\", ascending = True)\nbar = sns.barplot(data = data, x = \"Country\", y = \"LocalReviews\", palette = \"Purples\")\nplt.xticks(rotation = 35)\nfor p in bar.patches:\n    bar.annotate(format(p.get_height(), '.1f'), \n                   (p.get_x() + p.get_width() \/ 2., p.get_height()), \n                   ha = 'center', va = 'center', \n                   xytext = (0, 9), \n                   textcoords = 'offset points')\nplt.axhline(y=data.AverageReviews.mean(), color='Black', linestyle='--')\nplt.ylabel(\"Local # of Reviews\")\nplt.xlabel(None)\nplt.show()","65eb7937":"m = folium.Map(location=[51.216505, 9.879729],width=600, height=500, zoom_start=4,tiles = \"cartodbpositron\" )\n\nfolium.Choropleth(\n    geo_data=state_geo,\n    bins = 7,\n    name=\"choropleth\",\n    data = data,\n    columns=[\"Country\", \"LocalReviews\"],\n    fill_color=\"Purples\",\n    key_on = \"feature.properties.sovereignt\",\n    fill_opacity=0.8,\n    line_opacity=0.4,\n    nan_fill_opacity=0\n).add_to(m)\n\nfolium.LayerControl().add_to(m)\n\nm","2ff62d0c":"plt.figure(figsize =(17,5))\nplt.subplot(1,2,1)\nsns.countplot(data = data, x = \"2ndCuisine\")\nplt.subplot(1,2,2)\nsns.countplot(data = data, x = \"3rdCuisine\")\nplt.show()","2cc96b43":"data = countryLocalization.loc[(countryLocalization.Country != 'Finland')&(countryLocalization.Country != 'Slovakia')&(countryLocalization.Country != 'Luxembourg'), :].sort_values(by = \"LocalRating\", ascending = True)\ndata[[\"Country\", \"LocalCuisine\", \"1stCuisine\",  \"2ndCuisine\", \"3rdCuisine\"]]","beef58d9":"plt.figure(figsize = (5,6))\nsns.boxplot(x = \"variable\", y = \"value\", showmeans = True, data=pd.melt(countryLocalization[[\"LocalPrice\", \"RestPrice\"]]))\nplt.xticks([0,1],[\"Local Cuisine\", \"The Rest\"])\nplt.ylabel(\"Price\")\nplt.xlabel(\"Cuisine\")\nplt.show()","ccadbdac":"tstat, p_twosided = stats.ttest_ind(countryLocalization.RestPrice,\n                              countryLocalization.LocalPrice)\nprint(\"P-value:\", format(p_twosided, \".5f\"))\nif p_twosided < 0.025:\n    print(\"Reject null hypotesis\")\nelse:\n    print(\"Cannot reject null hypotesis\")","4eb33442":"plt.figure(figsize = (5,6))\nsns.boxplot(x = \"variable\", y = \"value\", showmeans = True, data = pd.melt(countryLocalization[[\"LocalRating\", \"RestRating\"]]))\nplt.xticks([0,1],[\"Local Cuisine\", \"The Rest\"])\nplt.ylabel(\"Rating\")\nplt.xlabel(\"Cuisine\")\nplt.show()","a62543d6":"tstat, p_twosided = stats.ttest_ind(countryLocalization.RestRating, \n                              countryLocalization.LocalRating)\nprint(\"P-value:\", format(p_twosided, \".5f\"))\nif p_twosided < 0.025:\n    print(\"Reject null hypotesis\")\nelse:\n    print(\"Cannot reject null hypotesis\")","b0680535":"plt.figure(figsize = (5,6))\nsns.boxplot(x = \"variable\", y = \"value\", showmeans = True, data=pd.melt(countryLocalization[[\"LocalReviews\", \"RestReviews\"]]))\nplt.xticks([0,1],[\"Local Cuisine\", \"The Rest\"])\nplt.ylabel(\"# of Reviews\")\nplt.xlabel(\"Cuisine\")\nplt.show()","c70d9bdd":"tstat, p_twosided = stats.ttest_ind(countryLocalization.RestReviews, \n                                    countryLocalization.LocalReviews)\nprint(\"P-value:\", format(p_twosided, \".5f\"))\nif p_twosided < 0.025:\n    print(\"Reject null hypotesis\")\nelse:\n    print(\"Cannot reject null hypotesis\")","ddebc8e7":"m = folium.Map(location=[51.216505, 9.879729],width=600, height=500, zoom_start=4,tiles = \"cartodbpositron\" )\n\nfolium.Choropleth(\n    geo_data=state_geo,\n    bins = 8,\n    name=\"choropleth\",\n    data = data,\n    columns=[\"Country\", \"PriceDifference\"],\n    fill_color=\"RdBu\",\n    key_on = \"feature.properties.sovereignt\",\n    fill_opacity=0.8,\n    line_opacity=0.4,\n    nan_fill_opacity=0\n).add_to(m)\n\nfolium.LayerControl().add_to(m)\n\nm","9d891551":"m = folium.Map(location=[51.216505, 9.879729],width=600, height=500, zoom_start=4,tiles = \"cartodbpositron\" )\n\nfolium.Choropleth(\n    geo_data=state_geo,\n  bins = 8,\n    name=\"choropleth\",\n    data = data,\n    columns=[\"Country\", \"RatingDifference\"],\n    fill_color=\"RdBu\",\n    key_on = \"feature.properties.sovereignt\",\n    fill_opacity=0.8,\n    line_opacity=0.4,\n    nan_fill_opacity=0\n).add_to(m)\n\nfolium.LayerControl().add_to(m)\n\nm","56cabeac":"m = folium.Map(location=[51.216505, 9.879729],width=600, height=500, zoom_start=4,tiles = \"cartodbpositron\" )\n\nfolium.Choropleth(\n    geo_data=state_geo,\n    bins = 9,\n    name=\"choropleth\",\n    data = data,\n    columns=[\"Country\", \"ReviewDifference\"],\n    fill_color=\"RdBu\",\n    key_on = \"feature.properties.sovereignt\",\n    fill_opacity=0.8,\n    line_opacity=0.4,\n    nan_fill_opacity=0\n).add_to(m)\n\nfolium.LayerControl().add_to(m)\n\nm","4e7d68a3":"sns.jointplot(data = countryLocalization, x = \"AveragePrice\", y = \"AverageRating\", kind = \"reg\")","51f8d987":"sns.jointplot(data = countryLocalization, x = \"AveragePrice\", y = \"AverageReviews\", kind = \"reg\")","46ebe005":"plt.figure(figsize = (5,5))\nsns.heatmap(countryLocalization[[\"AveragePrice\", \"AverageRating\", \"AverageReviews\"]].corr(), cmap = \"YlGnBu\", square = True)\nplt.yticks(rotation = 0)","9dd499de":"Because my analysis is based on localization of restaurants in Europe, I eliminated some cuisines that represent regions or have high volume. **I am making the assumption of the first cuisine in the list represent the main cuisine that restaurant serves.** In general, the first and second element has regional cuisines, like French, Dutch, etc.","949d57a8":"That was quite a pandas usage :)\n\nFinally, printing my whole master dataframe. I am not going to use all the featrues but some of them was needed, as shown in previous cells.","a72490b7":"There seems to be no difference, so I do not have enough evidence to reject the null hypotesis. Two-sided 2-sample t-test with %95 significance results:","4c9b1a43":"Almost every country has their local cuisine as their most popular cuisine. Except for Germans, Belgians and Norwegians. Belgians apparently does not like their food, as their local food are the 3rd popular (and the rating above)","29fcfa2b":"### Making of the master DataFrame","2aff7755":"### Data Preparation","3b9e29ad":"#### 5. 2nd and 3rd Popular Cuisines","0485cf06":"In my final hypotesis, I am making comparison in terms of number of reviews, and obviously local restaurants have more rating. Test results are below.","d29380fe":"H0: There is no difference between local cuisines and other cuisines in terms of price\n\nHA: There is difference","fa81dab4":"Because I am investigating localization, my three hypoteses are on this subject. I am going to define them and show the results with numerical tests and visually.","e426bc4a":"H0: There is no difference between local cuisines and other cuisines in terms of rating.\n\nH1: There is difference.","1d012269":"#### 7. Local Differences with Other Countries","5a423afa":"While Belgium distinctively has low ratings, people in Slovenia seem to be happy with what they are paying for their own food.","9d4c13f6":"### Data Cleaning Missing Values Imputation","202ca2d1":"With %58, Italy has the most local restaurants.","4a8df5a0":"Our data is based on countries, so every point on these plots represent a country. There seems to be inverse relation with average price with average rating and average price with average number of reviews. Here, we can conclude that pricing has effect on the rating, higher the price, lower the rating. Also, higher the price, lower the number of reviews, that is maybe due to preference.","cadf973c":"#### 3. Ratings","3889dd61":"H0: There is no difference between local cuisines and other cuisines in terms of number of reviews.\n\nH1: There is difference.","f5f5d636":"Here map shows the localization rates, darker the color, higher the ratio. **There seems to be high localization in Mediterranean countries.** Central and northern Europe along with UK has low rates, whereas eastern has slightly higher rates.","423c0081":"I am using country for the analysis because it would be better to use for the localization analysis. Also, that way I can combine multiple cities in a country.","a2c5213a":"Well, test says the opposite!","064d8df1":"#### 6. Hypotesis Testing","a1df0a29":"The straight dashed line shows the all average prices along Europe, added for comparison. The 6 countries below average seems to have more weight compared to the rest.","9e5f3bc0":"Visually speaking, people in Europe seems to pay more for their own cuisines than the others. The code piece below is the two-sided 2-sample t-test with %95 significance","049d9eb0":"Looks like Europe is agreed on how they rate their own food, except for Belgium. \n\nOne comment on Greece I can make they have local food everywhere, the food is relatively cheap and seems like they are enjoying it by looking at the ratings.","d5185339":"I decided not to use **Slovakia, Finland and Luxembourg** for the analysis, because of their low volume and also there's no Finnish restaurants ","e202debb":"Finally I looked up for average number of reviews done on local restaurants, another metric that Italy is leading by far.","02707d76":"#### 1. Local Restaurants Ratio","9a8aeca0":"Now the dataframe looks better","0dea0c31":"#### 4. Reviews","47a084a5":"In this section, I will map the differences of price and rating between local countries and other countries. Calculations are made like Local minus Others.\n\nThis price difference map below shows that, Mediterranean-European cuisine is paid higher in other countries, so is Danish and Norwegian food.","24369ae5":"#### 8. Relationships within Average Values","0871549b":"#### 2. Prices","bc9a1fc2":"I managed to fill 6328 missing values!","36f99de6":"This time, we cannot see a Mediterranean similarity, but the similarity in Nordic countries persists, with, of course, Switzerland.","9ab64d70":"Below is the map of rating differences. Seems like everyone enjoying Belgian food except Belgians :) One insight after looking for these I got is in Belgium, the food preference is usually French, maybe I should have looked that way.","779160ee":"Here I imputed the missing values by groups. I followed **Price Range**, **Rating** and **number of reviews** order. Also used mode for the first two and mean for the latter.  That's because the ratings and price range has finite values.","329e02a8":"### Localization Analysis","3ec1734b":"Below, I renamed 1st most common things to locals, because most of the countries has the 1st ones as locals except for Germany, and Belgium, which I manually handled. **One other assumption is United Kingdom's local cuisine is \"Bar\".**"}}