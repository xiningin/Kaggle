{"cell_type":{"d8b661e2":"code","5080e28c":"code","bab8e4bc":"code","f58604ba":"code","f0145aa7":"code","ced22ad0":"code","29a8889c":"code","5b0870b4":"code","b2284078":"code","4223c7c0":"code","4fb477c4":"code","4efd7434":"code","71357807":"code","257e6810":"code","0f116efd":"code","6890c5aa":"code","adc6c0f0":"code","93533722":"code","346dafde":"code","07cd6ca3":"code","2619b305":"code","539cd542":"code","3043eb47":"code","5ed4c26a":"code","d97e99a0":"markdown","a5caff89":"markdown","449c505c":"markdown","f09b3cf1":"markdown","c4674564":"markdown","78db4fae":"markdown","2546e3fc":"markdown","9c9c9118":"markdown","aa2244e2":"markdown","8325ac14":"markdown","29f9c575":"markdown","791b17bd":"markdown","cc1259f6":"markdown","a767c368":"markdown","d92e05aa":"markdown","1155c9c8":"markdown","a99a6a37":"markdown","20430fd6":"markdown","8acacc74":"markdown","cac71cb5":"markdown","f38ac41c":"markdown","8e8d8fd2":"markdown","570e2a24":"markdown"},"source":{"d8b661e2":"![ -d \/kaggle\/input\/release-2021-v1\/augeropendata ] && [ ! -d augeropendata ] && ln -s \/kaggle\/input\/release-2021-v1\/augeropendata augeropendata  # kaggle specific linking dataset to augeropendata directory","5080e28c":"import json\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport zipfile\n\n# Jupyter\/ IPython formatting\nfrom IPython.display import Math, Latex, display","bab8e4bc":"# Default values for plots\nplt.rcParams[\"figure.figsize\"] = [14, 9] # figure width and height\nplt.rcParams[\"font.size\"] = 20","f58604ba":"# Data loading, encapsulated to make it less installation and OS dependant\nimport os.path\nfrom zipfile import ZipFile\ndef AugerOpen(fdir, file):\n    \"\"\"\n    Loads a file from the auger open data release. Can be either in the local directory,\n    in the parent directory or in the augeropendata directory.\n    File is identified by it directory *fdir* and filename *file* and can be found in the directory\n    or in a zip file.\n    \"\"\"\n    for loc in [\".\", \"..\", \"augeropendata\", \"data\"]:\n        fname = os.path.join(loc, fdir, file)\n        if os.path.isfile(fname):\n            return open(fname)\n        zname=os.path.join(loc, fdir + \".zip\")\n        if os.path.isfile(zname):\n            with ZipFile(zname) as myzip:\n                return myzip.open(os.path.join(fdir, file))\n    raise FileNotFoundError(os.path.join(fdir, file))","f0145aa7":"filename = 'Auger_071656066300.json' #select an event by file name\n\n# Interesting examples\n#filename = 'Auger_070137858700.json' # Highest energy event\n#filename = 'Auger_061856616000.json' # Highest multiplicity event\n#filename = 'Auger_182318542300.json' # Low energy event\n#filename = 'Auger_050035605500.json' # Low energy hybrid\n#filename = 'Auger_131525201200.json' # Hybrid with only 2 SD stations, triggered by FD\n#filename = 'Auger_051035232600.json' # Golden Hybrid event\n#filename = 'Auger_172657447200.json' # Golden Hybrid event at large distance from FD\n#filename = 'Auger_062636056300.json' # Low energy multi-eye event\n#filename = 'Auger_081847956000.json' # Highest energy multi-eye event\n\ndata=json.load(AugerOpen('data', filename))","ced22ad0":"#sdrec contains SD reconstruction parameters\nsdrec = pd.Series(dtype=object)\n\ntry:\n    sdrec  = pd.Series(data['sdrec'])\nexcept:\n    display(Latex(f'no sdrec data'))    \nelse:\n    display(Latex(f'sdrec columns:'))\n    display(Latex(f'{sdrec.index.values}'))","29a8889c":"# \n# Eyes contains the pixel traces\neyes = pd.DataFrame()\nfdrec = pd.DataFrame()\n\ntry:\n    fdrec = pd.DataFrame(data['fdrec'])\nexcept:\n    display(Latex(f'no FD rec data'))\nelse:\n    fdrec.set_index('id', inplace=True)\n    display(Latex(f'fdrec columns:'))\n    display(Latex(f'{fdrec.columns.values}'))\n    \ntry:\n    eyes = pd.DataFrame(data['eyes'])\nexcept:\n    display(Latex(f'no FD eye data'))\nelse:\n    eyes.set_index('id', inplace=True)\n    display(Latex(f'eyes columns:'))\n    display(Latex(f'{eyes.columns.values}'))\n\n        ","5b0870b4":"#these sections are present in all files\nmeta = pd.Series(data['meta'])\ndisplay(Latex(f'''meta columns:'''))\ndisplay(Latex(f'''{meta.index.values}'''))\n\ninfo = pd.Series(data['info'])\ndisplay(Latex(f'''info columns:'''))\ndisplay(Latex(f'''{info.index.values}'''))\n\nflags = pd.Series(data['flags'])\ndisplay(Latex(f'''flags columns:'''))\ndisplay(Latex(f'''{flags.index.values}'''))\n\n#stations contain the signal of the 3 pmts of the wcds and some related parameters\nstations = pd.DataFrame(data['stations'])\nstations.set_index('id', inplace=True)\ndisplay(Latex(f'''stations columns:'''))\ndisplay(Latex(f'''{stations.columns.values}'''))","b2284078":"display(meta)","4223c7c0":"display(info)","4fb477c4":"if (sdrec.empty == False):\n    display(sdrec) \nelse :\n    display(Latex(f'''no sd data'''))\n","4efd7434":"display(stations.head(3))","71357807":"if not fdrec.empty:\n    display(fdrec) \nelse :\n    display(Latex(f'''no FD data'''))\n","257e6810":"display(Latex(f'event id : {info.id}'))\ndisplay(Latex(f'event date : {info.date}'))\ndisplay(Latex(f'event gps : {info.gpstime}'))\ndisplay(Latex(f'N\u00b0 of stations : {len(stations)}'))\n\nif not sdrec.empty:\n    display(Latex(f'''N\u00b0 of recstations : {len(sdrec.recstations)} '''))\n    display(Latex(f'''recstations ids : {sdrec.recstations} '''))\nelse:\n    display(Latex(f'''N\u00b0 of recstations : 0 '''))\n    \nif not eyes.empty:\n    display(Latex(f'''N\u00b0 of eyes : { len(eyes)} '''))\n    display(Latex(f'''eye ids: {eyes.index.values} '''))\nelse:\n    display(Latex(f'''N\u00b0 of eyes : 0 '''))\n\n","0f116efd":"#select a station:\nwcd = stations.iloc[0] #select the first station \n\n#create a vector for the x-axis: 1 bin = 25 ns \nbinsize = 0.025 # 25 ns, in \u00b5s\ntime = [np.arange(len(wcd[f'pmt{i + 1}'])) * binsize for i in range(3)]\n\n#print the signal of pmt1\nplt.plot(time[0], wcd.pmt1)\nplt.title(f'Signal of PMT 1,  station {wcd[\"name\"]} (id = {wcd.name})') # cannot use wcd.name, this produces the 'id'.\nplt.xlabel('time [$\\mu s$]')\nplt.ylabel('signal [VEM]')\nplt.show()\n\n#print the signal of all pmts of the station\nfor i in range(3):\n    pmt = f'pmt{i + 1}'\n    plt.plot(time[i], wcd[pmt], label=pmt)\n\nplt.title(f'Signal of all PMTs of station {wcd[\"name\"]} (id = {wcd.name})')\nplt.xlabel('time [$\\mu s$]')\nplt.ylabel('signal [VEM]')\nplt.legend()\nplt.show()","6890c5aa":"binsize = 0.025\nfig, axs = plt.subplots(len(stations), 1, figsize=(10, 6*len(stations)))\n\nfor (station_id, station), ax in zip(stations.iterrows(), axs):\n    for pmt_idx, color in enumerate(['r', 'b', 'g']):\n        pmt = f'pmt{pmt_idx + 1}'\n        time = np.arange(len(station[pmt])) * binsize\n        try:\n            ax.plot(time, station[pmt], color, label=pmt)\n        except:\n            pass\n\n    ax.set_ylabel('Signal [VEM]')\n    ax.set_xlabel('Time [$\\mu $s]')\n    ax.legend(fontsize='x-small')\n    title = f'{station[\"name\"]} (id: {station_id})'\n    ax.set_title(title, fontsize=12)\n\n\nplt.subplots_adjust(hspace = .5)\nplt.show()\n","adc6c0f0":"#read stations positions in UTM coordinates system...\nmapSD = pd.read_csv(AugerOpen(\"auxiliary\", \"sdMap.csv\"), index_col='id')\n# ... and add to the stations\ntry:\n    stations = stations.join(mapSD, how='inner')\nexcept ValueError: # in case we are re-running this cell\n    pass","93533722":"selected = stations[stations.isSelected == 1]\nrandom = stations[stations.isSelected == 0]\n\nsize = 30 + selected.signal%100\n\nplt.figure(figsize=(10, 10))\nplt.scatter(mapSD.easting, mapSD.northing, s=20 , facecolors='none', edgecolors='grey',marker='o')\nplt.scatter(selected.easting, selected.northing, s=size, c=selected.t ,cmap='viridis' )\nplt.scatter(random.easting, random.northing, facecolors='none', edgecolors='black',marker='o')\n\nplt.xlim(439000, 510000)\nplt.ylim(6065000, 6140000)\nplt.xlabel('UTM Easting [m]')\nplt.ylabel('UTM Northing [m]')\nplt.show()","346dafde":"E0 = 477256.66         #Easting of the Auger-site center (longitude  69.25\u02da W)\nN0 = 6099203.68        #Northing of the Auger-site center (latitude 35.35\u02da S)\nA0 = 1400              #Altitude of the Auger-site center [m]\nalpha = 2.52e-3        #Rotation angle\nbeta = 6.03e-4         #Scaling factor\nR = 6368000           #Earth\u2019s radius\n\nstations['E'] = E0 + (1-beta)*stations.x - alpha*stations.y \nstations['N'] = N0 + (1-beta)*stations.y + alpha*stations.x\nstations['A'] = A0 + stations.z + (pow(stations.x,2) + pow(stations.y,2))\/2\/R\nstations['Delta E'] = stations.easting - stations.E\nstations['Delta N'] = stations.northing - stations.N\nstations['Delta A'] = stations.altitude - stations.A\n\npd.options.display.float_format = '{:.2f}'.format\ndisplay(stations[['easting', 'E', 'Delta E', 'northing', 'N', 'Delta N', 'altitude', 'A', 'Delta A']])","07cd6ca3":"try:\n    s1000     = sdrec.s1000\n    s1000err  = sdrec.ds1000\n    beta      = sdrec.beta\n    gamma     = sdrec.gamma\nexcept :\n    display(Latex('no sd data'))\nelse:\n\n    d = np.linspace(max(selected.spDistance.min()-100, 10), selected.spDistance.max(), 1000)\n    fit = s1000 * pow(d\/1000, beta) * pow((d+700)\/(1000+700), beta+gamma)\n\n    plt.errorbar(selected.spDistance, selected.signal, yerr=selected.dsignal, \n                 label=\"selected station\", marker='o', linestyle='none')\n    plt.errorbar(1000, s1000, yerr=s1000err, \n                 label=\"$S_{1000}$\", fmt='kD', linestyle='none')\n    plt.plot(d, fit, 'r', label=\"fit\", linestyle='--')\n    plt.xlabel(\"Distance from the core [m]\")\n    plt.ylabel(\"Signal [VEM]\")\n    plt.yscale('log')\n    plt.legend()\n    plt.show()\n","2619b305":"#load the pixels map\nmapPix = pd.read_csv(AugerOpen('auxiliary', 'fdPixelMap.csv'), index_col=['eye', 'pixel'])","539cd542":"#first eye (automatic selection)\neye_ID = None\n#or select the eye 1 = Los Leones , 2 = los Morados , 3 = Loma Amarilla,  4 = Coihueco\n#eye_ID = 2\n\ntry:\n    #select an eye\n    if eye_ID is None:\n        eye_ID = eyes.iloc[0].name\n    selEye = eyes.loc[eye_ID]\nexcept:\n    display(Latex(f'no fd data or wrong eye-id selection'))\nelse:\n    mapEye = mapPix.loc[eye_ID]\n    \n    eyeName = selEye[\"name\"]\n    pixel_fields = [\"pixelID\", \"pixelStatus\", \"pixelTime\", \"pixelCharge\"]\n    pixels = pd.DataFrame(dict(zip(pixel_fields, selEye[pixel_fields]))).join(mapEye, how=\"inner\", on=\"pixelID\")\n    #select good pixels: pixelStatus==4\n    good_pixels = pixels[pixels.pixelStatus==4] \n    bad_pixels = pixels[pixels.pixelStatus!=4] \n\n    #display(good_pixels)\n    tel_list = [6, 5, 4, 3, 2, 1] #choose the telescopes to plot\n    for tel_id in tel_list:\n        mapTel = mapEye[mapEye.tel == tel_id]\n        good = good_pixels[good_pixels.tel == tel_id]\n        bad = bad_pixels[bad_pixels.tel == tel_id]\n        color = good.pixelTime\n\n        plt.figure(figsize=(5, 5))\n        plt.scatter(mapTel.azimuth,mapTel.elevation , c='grey', marker='h', alpha=0.3, s=100)\n        plt.scatter(good.azimuth, good.elevation, marker='h', c=color , s=100)\n        plt.scatter(bad.azimuth, bad.elevation, marker='h', c='black', s=100)\n        plt.title(f'Eye: {eye_ID}, Telescope: {tel_id}')\n        plt.xlabel('azimuth [deg]', fontsize=16)\n        plt.ylabel('elevation [deg]', fontsize=16)\n        plt.show()","3043eb47":"if not eyes.empty:\n    fig, axs = plt.subplots(len(eyes), 1, figsize=(40, 10*len(eyes) - 4))\n    if len(eyes) > 1:\n        plt.subplots_adjust(hspace=0.3)\n    try:\n        axs[0]\n    except TypeError:\n        axs = np.array([axs])\n\n    for ax, (eye_ID, selEye) in zip(axs, eyes.iterrows()):\n        mapEye = mapPix.loc[eye_ID]\n\n        eyeName = selEye[\"name\"]\n        pixel_fields = [\"pixelID\", \"pixelStatus\", \"pixelTime\", \"pixelCharge\"]\n        pixels = pd.DataFrame(dict(zip(pixel_fields, selEye[pixel_fields]))).join(mapEye, how=\"inner\", on=\"pixelID\")\n\n        #select good pixels: pixelStatus==4\n        good_pixels = pixels[pixels.pixelStatus==4] \n        bad_pixels = pixels[pixels.pixelStatus!=4] \n\n        ax.set_title(selEye[\"name\"])\n        ax.scatter(mapEye.azimuth, mapEye.elevation , c='grey', marker='h', alpha=0.3, s=180)\n        ax.scatter(good_pixels.azimuth, good_pixels.elevation, marker='h', c=good_pixels.pixelTime, s=180)\n        ax.scatter(bad_pixels.azimuth, bad_pixels.elevation, marker='h', c='black', s=180)\n        ax.set_xlabel('azimuth [deg]',fontsize=20)\n        ax.set_ylabel('elevation [deg]',fontsize=20)\n        ax.set_xticks(np.arange(0, 181, 30))        \n        ax.set_yticks(np.arange(0, 31, 5))\n\n        clb = fig.colorbar(mpl.cm.ScalarMappable(mpl.colors.Normalize(good_pixels.pixelTime.min(), good_pixels.pixelTime.max())), ax=ax)\n        clb.set_label('time', fontsize=20)\n        \n\n\n    plt.subplots_adjust(hspace = .6)\n    plt.show()\nelse:\n    display(Latex(f'''no fd data or wrong eye-id selection'''))\n","5ed4c26a":"if not eyes.empty:\n    fig, axs = plt.subplots(len(eyes), 1, figsize=(15, 8*len(eyes)))\n    if len(eyes) > 1:\n        plt.subplots_adjust(hspace=0.5)\n    try:\n        axs[0]\n    except TypeError:\n        axs = np.array([axs])\n\n    for ax, (idx, eye) in zip(axs, eyes.join(fdrec, how='inner').iterrows()):\n        L = eye.uspL\n        R = eye.uspR\n        Xmax = eye.xmax\n        dEdXmax = eye.dEdXmax\n\n        atm_fields = [\"atmDepthProf\", \"energyDepositProf\", \"denergyDepositProf\"]\n        profile = pd.DataFrame(dict(zip(atm_fields, eye[atm_fields])))\n\n        fit = dEdXmax*pow(1 + R*(profile.atmDepthProf-Xmax)\/L, pow(R,-2)) * np.exp(-(profile.atmDepthProf-Xmax) \/ (R*L))\n        \n        ax.set_title(eye[\"name\"])\n        ax.set_xlim([100, 1400])\n        ax.errorbar(profile.atmDepthProf, profile.energyDepositProf, yerr=profile.denergyDepositProf, \n                    linestyle='', marker='o', alpha=0.3, markersize=3, linewidth=1)\n        ax.plot(profile.atmDepthProf, fit, label = 'fit')\n        ax.set_xlabel('Slant depth $[g\/cm^2]$' )\n        ax.set_ylabel('dE\/dX $[PeV\/(g\/cm^2)]$')\n        ax.legend()\n   \n    plt.show()\nelse:\n    display(Latex(f'no fd data'))\n","d97e99a0":"Read the array information and join into the station list...","a5caff89":"Plot the FD energy-deposited profiles and its fit function","449c505c":"Signals of all stations:","f09b3cf1":"Signals from a single detector station","c4674564":"Plot the station signals as a function of the distance from the core and superimpose the fit function using the parameters 'beta' and 'gamma': the so called 'lateral distribution function'\n$$\ns(r) = r^\\beta * \\Bigl(\\frac{d + 700}{1700}\\Bigr)^{\\beta + \\gamma}\n$$\nwith the distance $r$ in meters.","78db4fae":"## Load an event file from the zipped or unzipped folder using a json parser","2546e3fc":"## Plot data from the Fluorescence Detector","9c9c9118":"Convert and compare the station positions between the event and the detector map","aa2244e2":"![PierreAugerObservatoryLogo.jpg](attachment:PierreAugerObservatoryLogo.jpg)\n# Tutorial: How to read a json file\n\n<i>Notebook released together with the Pierre Auger Observatory Open Data release 2021 (<a href=\"https:\/\/doi.org\/10.5281\/zenodo.4487613\">DOI 10.5281\/zenodo.4487613<\/a>). More information at the <a href=\"https:\/\/www.auger.org\/opendata\/\">Auger open data website<\/a>.<\/i>","8325ac14":"## The signals as a function of the distance from the shower core","29f9c575":"This is the kaggle version of a Pierre Auger Observatory Open Data notebook. You can run it by clicking on \"Copy and Edit\" in the top right corner.","791b17bd":"Plot the whole trace","cc1259f6":"## Plot some date related to the Surface Detector","a767c368":"##### In the following,  a dataframe is created for each section of the event file.","d92e05aa":"## Plot the shower footprint","1155c9c8":"Start with traces in the camera","a99a6a37":"## Print the content of the dataframes:","20430fd6":"The aim of this notebook is to explore the content of an event file using python and to help in plotting pseudo-raw data.","8acacc74":"Load the pixel data","cac71cb5":"... and now plot the map with the stations from the event","f38ac41c":"Select an event from the list","8e8d8fd2":"## Import some standard python libraries that contain basic functions used along the notebook.","570e2a24":"##### Print some event information"}}