{"cell_type":{"cd142c1f":"code","19092fd0":"code","95723091":"code","cb54a2e8":"code","5e2307e6":"code","0fb36592":"code","9034b7b8":"code","e019206a":"code","a4928ad6":"code","4b61f8ee":"code","63d19b6d":"code","ea499f2d":"code","3db3d3f4":"code","7bc9e663":"code","1d65f1c6":"code","6fba12d0":"code","c2a04806":"code","9f02be88":"code","59b1b3fc":"code","66f19574":"code","9f7f2680":"code","bd128e53":"code","32d5afbd":"code","df5d972b":"code","106ebb38":"code","15013a35":"code","24714e55":"code","011bde3a":"code","5779533c":"code","02d8a744":"markdown","81c70648":"markdown","8dca4ca0":"markdown","bdf8b5b2":"markdown","360ddcc5":"markdown"},"source":{"cd142c1f":"import numpy as np\nimport lightgbm as lgbm\nfrom sklearn.model_selection import KFold,GroupKFold,StratifiedKFold\nfrom sklearn.metrics import roc_auc_score\nimport pandas as pd\nimport pandas as pd\npd.options.mode.chained_assignment = None  # default='warn'\nimport warnings\nwarnings.filterwarnings(\"ignore\")","19092fd0":"train = pd.read_csv(\"..\/input\/widsdatathon2021\/TrainingWiDS2021.csv\")\n\ntest = pd.read_csv(\"..\/input\/widsdatathon2021\/UnlabeledWiDS2021.csv\")\ndel train[\"Unnamed: 0\"],test[\"Unnamed: 0\"]\n","95723091":"train.shape,test.shape","cb54a2e8":"# Fill the missing cat columns\ncat_cols = train.select_dtypes(include=['object']).columns\ntrain[cat_cols] = train[cat_cols].fillna(\"missing\")\ntest[cat_cols] = test[cat_cols].fillna(\"missing\")\n\nfrom sklearn import preprocessing\nfor col in cat_cols:\n    print(col)\n    le = preprocessing.LabelEncoder()\n    le.fit(pd.concat([train[col],test[col]],axis=0).astype(\"str\"))\n    train[col] = le.transform(train[col])\n    test[col] = le.transform(test[col])\n","5e2307e6":"# Target encoding for apache_3j_diagnosis. Feature is being generated within the fold method.\n\ny = train[\"diabetes_mellitus\"]\nkf = KFold(n_splits=10, shuffle=True, random_state=1)\ngroups = train[\"hospital_id\"]\ngkf = GroupKFold(n_splits=10)\n\noof = np.zeros(len(train))\nscore_list = []\nfold = 1\ntest_preds = []\n\ncol = \"apache_3j_diagnosis\"\nfor train_index, test_index in gkf.split(train,groups = groups):\n\n    X_train, X_val = train.iloc[train_index], train.iloc[test_index]\n    y_train, y_val = y.iloc[train_index], y.iloc[test_index]\n    \n    print(X_train.shape,X_val.shape)\n    print(y_train.mean(),y_val.mean())\n    \n    map_ = X_train.groupby(col)[\"diabetes_mellitus\"].mean()\n    oof[test_index] = X_val[col].map(map_)   \n    fold+=1\n\ntrain[col+\"_te\"] = oof\nmap_ = train.groupby(col)[\"diabetes_mellitus\"].mean()\ntest[col+\"_te\"] = test[col].map(map_)\n","0fb36592":"test.head()","9034b7b8":"# Useful new features other than target encodings.\ndef new_features(df):\n    df[\"d1_glucose_max_min_diff\"] = df[\"d1_glucose_max\"] - df[\"d1_glucose_min\"]\n    df[\"d1_heartrate_max_min_diff\"] = df[\"d1_heartrate_max\"] - df[\"d1_heartrate_min\"]\n    df[\"d1_glucose_max_h1_diff\"] = df[\"d1_glucose_max\"] - df[\"h1_glucose_max\"]\n\n    return df\ntrain = new_features(train)\ntest = new_features(test)\n\n\nall_data = pd.concat([train,test],axis=0)\nall_data.shape\n\ncol = \"apache_3j_diagnosis\"\ncol2 = \"glucose_apache\"\nall_data[\"new_feature\"] = all_data[col2] - all_data.groupby([col])[col2].transform(\"mean\")\n\ntrain[\"new_feature\"] = all_data.iloc[:len(train)][\"new_feature\"]\ntest[\"new_feature\"] = all_data.iloc[len(train):][\"new_feature\"]","e019206a":"# partial dependency plot\ncol = \"d1_glucose_max_min_diff\"\ntrain.sort_values(col).reset_index(drop=True)[\"diabetes_mellitus\"].rolling(1000).mean().plot()","a4928ad6":"features = [col for col in train.columns if col not in [\"diabetes_mellitus\",\n                                                        \"istrain\",\n                                                        \"encounter_id\",\n                                                        \"hospital_id\",\n                                                        \"icu_id_te\",\n                                                        \"age_group\",\n                                                        \"new_feature5\",\n                                                        \"apache_3j_diagnosis_icu_id_te\",\n                                                       \"apache_2_diagnosis_icu_id_te\",\n                                                        \"hospital_admit_source_te\",\n                                                        \"age_group_3j_diagnosis_te\",\n                                                        \"d1_heartrate_max_te\"\n                                                        ,\"apache_3j_diagnosis_cat_te\",\n                                                       \"apache_3j_diagnosis_cat\",\"apache_4a_hospital_death_prob\",\"preds\"]]\n\nprint(len(features))\nfeatures[-10:]","4b61f8ee":"#First model with groupkfold grouped by hospital id. If you submit this part's submision, you'll get almost same CV-LB score.\n\ny = train[\"diabetes_mellitus\"]\nkf = KFold(n_splits=10, shuffle=True, random_state=1)\ngroups = train[\"hospital_id\"]\ngkf = GroupKFold(n_splits=10)\nskf = StratifiedKFold(n_splits=10, shuffle=True, random_state=1)\noof = np.zeros(len(train))\nscore_list = []\nfold = 1\ntest_preds = []\n\nfor train_index, test_index in gkf.split(train,groups = groups):\n\n    X_train, X_val = train.iloc[train_index], train.iloc[test_index]\n    y_train, y_val = y.iloc[train_index], y.iloc[test_index]\n    \n    \n    print(X_train.shape,X_val.shape)\n    print(y_train.mean(),y_val.mean())\n    \n\n    \n    y_pred_list = []\n    for seed in [1]:\n        dtrain = lgbm.Dataset(X_train[features], y_train,categorical_feature=[\"apache_2_diagnosis\"])\n        dvalid = lgbm.Dataset(X_val[features], y_val,categorical_feature=[\"apache_2_diagnosis\"])\n        print(seed)\n        params = {\"objective\": \"binary\",\n              \"metric\": \"auc\",\n              \"verbosity\": -1,\n              \"boosting_type\": \"gbdt\",\n              \"feature_fraction\":0.3,\n              \"num_leaves\": 50,\n              \"lambda_l1\":2,\n              \"lambda_l2\":2,\n              \"learning_rate\":0.01,\n              'min_child_samples': 0,\n                  \"scale_pos_weight\":1,\n              \"bagging_fraction\":0.9,\n              \"bagging_freq\":1}\n        params[\"seed\"] = seed\n        model = lgbm.train(params,\n                        dtrain,\n                        valid_sets=[dtrain, dvalid],\n                        verbose_eval=200,\n                        num_boost_round=100000,\n                        early_stopping_rounds=200\n                    )\n    \n        y_pred_list.append(model.predict(X_val[features]))\n        test_preds.append(model.predict(test[features]))\n        \n    \n    oof[test_index] = np.mean(y_pred_list,axis=0)    \n    score = roc_auc_score(y_val, oof[test_index])\n    score_list.append(score)\n    print(f\"AUC Fold-{fold} : {score}\")\n    print(\"***********\")\n    fold+=1\n\nnp.mean(score_list)","63d19b6d":"### print(score_list)\nprint(np.mean(score_list))\nprint(roc_auc_score(train[\"diabetes_mellitus\"], oof))","ea499f2d":"lgbm.plot_importance(model,max_num_features=20)","3db3d3f4":"test[\"diabetes_mellitus\"] = np.mean(test_preds,axis=0) \n\ntrain[\"preds\"] = oof\ntest[\"preds\"] = np.mean(test_preds,axis=0) ","7bc9e663":"#test[[\"encounter_id\",\"diabetes_mellitus\"]].to_csv(\"submission_8675_hid_gkfold_icu_as_numeric.csv\",index=False)","1d65f1c6":"# Regenerating same target encoding feature because Kfold method changes in 2nd model.\ny = train[\"diabetes_mellitus\"]\nkf = KFold(n_splits=10, shuffle=True, random_state=1)\n\noof = np.zeros(len(train))\nscore_list = []\nfold = 1\ntest_preds = []\n\ncol = \"apache_3j_diagnosis\"\nfor train_index, test_index in kf.split(train):\n\n    X_train, X_val = train.iloc[train_index], train.iloc[test_index]\n    y_train, y_val = y.iloc[train_index], y.iloc[test_index]\n    \n    print(X_train.shape,X_val.shape)\n    print(y_train.mean(),y_val.mean())\n    \n    map_ = X_train.groupby(col)[\"diabetes_mellitus\"].mean()\n    oof[test_index] = X_val[col].map(map_)   \n    fold+=1\n\ntrain[col+\"_te\"] = oof\nmap_ = train.groupby(col)[\"diabetes_mellitus\"].mean()\ntest[col+\"_te\"] = test[col].map(map_)\n","6fba12d0":"train.head()","c2a04806":"col = \"new_feature\"\ntrain.sort_values(col).reset_index(drop=True)[\"diabetes_mellitus\"].rolling(1000).mean().plot()","9f02be88":"features = [col for col in train.columns if col not in [\"diabetes_mellitus\",\"istrain\",\"encounter_id\",\"hospital_id\",\"icu_id_te\",\n                                                        \"age_group\",\"new_feature5\",\"apache_3j_diagnosis_icu_id_te\",\n                                                       \"apache_2_diagnosis_icu_id_te\",\"preds\",\"d1_heartrate_max_te\",\n                                                       \"apache_2_diagnosis_te\",\"new_feature_te\"]]\nlen(features)","59b1b3fc":"features[-5:]","66f19574":"#X = X.abs()\ny = train[\"diabetes_mellitus\"]\nkf = KFold(n_splits=10, shuffle=True, random_state=1)\noof = np.zeros(len(train))\nscore_list = []\nfold = 1\ntest_preds = []\n\n\nfor train_index, test_index in kf.split(train):\n\n    X_train, X_val = train.iloc[train_index], train.iloc[test_index]\n    y_train, y_val = y.iloc[train_index], y.iloc[test_index]\n    \n    \n    print(X_train.shape,X_val.shape)\n    print(y_train.mean(),y_val.mean())\n    \n    # Here adding psuedo labels coming from the first model.\n    zero_test = test[test.diabetes_mellitus < 0.2]\n    zero_test[\"diabetes_mellitus\"] = 0\n    one_test = test[test.diabetes_mellitus >= 0.7]\n    one_test[\"diabetes_mellitus\"] = 1\n    print(zero_test.shape,one_test.shape)\n    sub_test = pd.concat([one_test,zero_test],axis=0)\n    X_train = pd.concat([X_train,sub_test],axis=0)\n    y_train = pd.concat([y_train,sub_test[\"diabetes_mellitus\"]],axis=0)\n    print(X_train.shape,X_val.shape)\n    \n    \n    y_pred_list = []\n    for seed in [1]:\n        dtrain = lgbm.Dataset(X_train[features], y_train,categorical_feature=[\"icu_id\",\"apache_2_diagnosis\"])\n        dvalid = lgbm.Dataset(X_val[features], y_val,categorical_feature=[\"icu_id\",\"apache_2_diagnosis\"])\n        print(seed)\n        params = {\"objective\": \"binary\",\n              \"metric\": \"auc\",\n              \"verbosity\": -1,\n              \"boosting_type\": \"gbdt\",\n              \"feature_fraction\":0.3,\n              \"num_leaves\": 50,\n              \"lambda_l1\":2,\n              \"lambda_l2\":2,\n              \"learning_rate\":0.01,\n              'min_child_samples': 0,\n                  \"scale_pos_weight\":1,\n              \"bagging_fraction\":0.9,\n              \"bagging_freq\":1}\n        params[\"seed\"] = seed\n        model = lgbm.train(params,\n                        dtrain,\n                        valid_sets=[dtrain, dvalid],\n                        verbose_eval=200,\n                        num_boost_round=100000,\n                        early_stopping_rounds=200\n                    )\n    \n        y_pred_list.append(model.predict(X_val[features]))\n        test_preds.append(model.predict(test[features]))\n        \n    \n    oof[test_index] = np.mean(y_pred_list,axis=0)    \n    score = roc_auc_score(y_val, oof[test_index])\n    score_list.append(score)\n    print(f\"AUC Fold-{fold} : {score}\")\n    print(\"***********\")\n    fold+=1\n\nnp.mean(score_list)","9f7f2680":"print(score_list)\nprint(np.mean(score_list))\nprint(roc_auc_score(train[\"diabetes_mellitus\"], oof))\n","bd128e53":"test[\"diabetes_mellitus_2\"] = np.mean(test_preds,axis=0) ","32d5afbd":"test.head()","df5d972b":"sub = test[[\"encounter_id\",\"diabetes_mellitus\"]].copy()","106ebb38":"sub.diabetes_mellitus.hist(bins=100)","15013a35":"\nfilter_ = test.icu_id.isin(train.icu_id.unique())\nsub.loc[filter_,\"diabetes_mellitus\"] = test.loc[filter_,\"diabetes_mellitus\"]*0.2 + test.loc[filter_,\"diabetes_mellitus_2\"]*0.8","24714e55":"sub.diabetes_mellitus.hist(bins=100)","011bde3a":"sub.to_csv(\"postprocess_8678_8805_psuedo.csv\",index=False)","5779533c":"sub.to_csv(\"submission.csv\",index=False)","02d8a744":"## 2nd part: Modeling with standard KFold and using icu_ids as categorical features. ","81c70648":"## And one more improvement: I provided test set predictions coming from 1st model as psuedo labels to the second model. This trick also improved CV, Public LB and Private LB in a considerable amount.","8dca4ca0":"## 1st part: Modeling with group kfold grouped by hospitalids. This part's predictions will be used for non-overlaping icu_id part of the test data. Also this part's test predictions will be used as psuedo labels in 2nd model.","bdf8b5b2":"### Here I only touch test rows having overlapping icu_ids. The rows having new icu_ids have predictions coming from only the first model.","360ddcc5":"## I have two staged modeling. Since test dataset has both overlapping and non-overlapping icu_ids with train data, I found out that these parts act a bit differently. Therefore I build 1 model for non-overlapping icu_ids of the test data and 1 model for the overlapping icu_ids part. \n\n## For non-overlapping modeling, leaving icu_id column as numeric column is enough and more importantly applying groupkfold based on hospital ids were the key.\n\n## For overlapping icu_id modeling, treating icu_id column as categorical column and applying straightforward kfold was the key.\n\n## As final test predictions, for new (non-overlapping) icu_ids, I get predictions from the 1st model. But for overlapping icu_ids, final predictions are calculated as \n\n### final_pred = 0.8 * 2nd_model_prediction + 0.2 * 1st_model_prediction"}}