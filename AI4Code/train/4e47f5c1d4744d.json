{"cell_type":{"c314be9d":"code","a9e315d1":"code","4ae46089":"code","40912bc7":"code","719e9b60":"code","33f01294":"code","53549197":"code","fb6db2e5":"code","7814a3b9":"code","99bf6daf":"code","03216ea4":"code","50b55555":"markdown","ee6ac15a":"markdown","ed5826f4":"markdown","434b8dce":"markdown","7a3a5c9a":"markdown","d7ab89c8":"markdown","cbb248d1":"markdown","a805b2b9":"markdown","9afd0efe":"markdown","e1cc408e":"markdown","9da8ad38":"markdown","c56acbb6":"markdown","3ceef15b":"markdown","2b82108e":"markdown","a64b32a1":"markdown","88f4ae21":"markdown","4c88e4d9":"markdown","2e62bf7b":"markdown","e23723bf":"markdown","30a7fdf9":"markdown","57e15464":"markdown","7ce7f7f0":"markdown","d5834b65":"markdown","2a94910d":"markdown","f0f85ed1":"markdown","a4736cfc":"markdown"},"source":{"c314be9d":"from IPython.core.display import SVG\nfrom IPython.display import Image","a9e315d1":"# Reference: https:\/\/corporatefinanceinstitute.com\/resources\/careers\/soft-skills\/t-shaped-skills\/\nImage(filename='..\/input\/web-app-images\/t-shaped-skills-1.png', width = 300)","4ae46089":"SVG(filename='..\/input\/web-app-images\/pocoo_flask-official.svg')","40912bc7":"### app.py\n# from flask import Flask\n# app = Flask(__name__)\n# @app.route(\"\/\")\n# def hello():\n#     return \"Hello World!\"\n# if __name__ == \"__main__\":\n#     app.run(debug=True)","719e9b60":"### model.py\n# import pickle\n# import numpy as np\n# from sklearn.linear_model import LinearRegression\n# X = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])\n# y = np.dot(X, np.array([1, 2])) + 3\n# if __name__ == \"__main__\":\n#     reg = LinearRegression().fit(X, y)\n#     PIK = \"pickle.dat\"\n#         with open(PIK, 'wb') as f:\n#             pickle.dump(reg, f)","33f01294":"### app.py\n# import pickle\n# import model \/\/ imports model.py\n# if __name__ == \"__main__\":\n#     PIK = 'pickle.dat'\n#     with open(PIK, \"rb\") as f:\n#         loaded_agents = pickle.load(f)","53549197":"### app.py\n# if __name__ == \"__main__\":\n#     port = int(os.environ.get('PORT', 5000))\n#     app.run(host='0.0.0.0', port=port)","fb6db2e5":"SVG(filename='..\/input\/web-app-images\/docker-official.svg')","7814a3b9":"Image(filename='..\/input\/web-app-images\/docker_vm.png', width=700)","99bf6daf":"# FROM python:3\n\n# WORKDIR \/usr\/src\/app\n\n# COPY requirements.txt .\/\n# RUN pip install --no-cache-dir -r requirements.txt\n\n# COPY . .\n\n# CMD [ \"python\", \".\/app.py\" ]","03216ea4":"SVG(filename='..\/input\/web-app-images\/heroku-ar21.svg')","50b55555":"You may have heard of [Docker](https:\/\/www.docker.com), but perhaps are not too sure of how it works unless you are into DevOps. It is an important tool that came around in 2013. Since then, companies have been shifting their systems to incorporate Docker. The problem that Docker approaches is what is known as the [matrix from hell](https:\/\/crunchytechbytz.wordpress.com\/2018\/01\/23\/introduction-to-docker\/) for developers. Within a company, you may have various teams, softwares, hardwares, operating systems, etc. and all of these do not naturally work together. So moving things from development towards production has been an issue.\n\nAs people interested in data science, we have likely all already come across the issue of seeing some `code` on some website like StackOverflow, only to be disappointed by the fact that it will not work on our own local machine. Within dev teams, the saying is something like, \"But it works on my machine.\"","ee6ac15a":"Heroku is a popular cloud platform where you can share your app ideas with others. It supports multiple languages such as Ruby, PHP, Python, and others. An alternative is [Amazon Web Service (AWS)](https:\/\/aws.amazon.com), which performs a similar task.","ed5826f4":"# 7. Resources\n<a id=\"resources\"><\/a>\n<a href=\"#top\">Back to top<\/a>\n\nI noticed at the beginning that there were a variety of online resources to do what I have done here. However, none of them worked on their own. I had to piece together many bits of information until I get iteratively move from one step to the next. This may seem tiring and unnecessary, but it is a valuable learning experience. What is done here is transferrable to the future and will be helpful in having us improve our current set of skills in addition to showing us what we need to work on.\n\nBelow are some webpages that I had used in my journey to build, containerize, and deploy my web app:\n\n[Docker End to End, Krish Naik, YouTube](https:\/\/www.youtube.com\/playlist?list=PLZoTAELRMXVNKtpy0U_Mx9N26w8n0hIbs)\n\n[Docker for Data Scientists, Abhishek Thakur, YouTube](https:\/\/www.youtube.com\/watch?v=0qG_0CPQhpg)\n\n[Docker for Data Scientists - Simplify Your Workflow and Avoid Pitfalls | Jeff Fischer @ PyBay2018, Jeff Fischer, YouTube](https:\/\/www.youtube.com\/watch?v=V5uss9s5pv0)\n\n[Containerise your Python Flask using Docker and deploy it onto Heroku, Ashok, Medium](https:\/\/medium.com\/@ksashok\/containerise-your-python-flask-using-docker-and-deploy-it-onto-heroku-a0b48d025e43)\n\n[Dockerize Your Flask Application, Tasnuva Zaman\n, Medium](https:\/\/medium.com\/@tasnuva2606\/dockerize-flask-app-4998a378a6aa)\n\n[Machine Learning Model Serialization, Christopher Flynn, flynn.gg](https:\/\/flynn.gg\/blog\/machine-learning-model-serialization\/)\n\n[Docker Up and Running, Syndri Training, YouTube](https:\/\/www.youtube.com\/playlist?list=PLeZ5_LS4K5sDF8e_SAtFjCvROw6wwthle)\n\n[Productionize a Machine Learning model with Flask and Heroku, Chris I, Medium](https:\/\/towardsdatascience.com\/productionize-a-machine-learning-model-with-flask-and-heroku-8201260503d2)","434b8dce":"The `FROM python:3` creates the base image from Docker's official base images. This Dockerfile is the one provided by the [docs](https:\/\/hub.docker.com\/_\/python). It has Python 3 preinstalled so it is convenient for our purposes.\n\nThe `WORKDIR \/usr\/src\/app` command creates and sets the working directory to be located at `\/usr\/src\/app`. The interesting thing is that this is taking place within the Linux OS as the base image.\n\nThe `COPY requirements.txt .\/` I believe copies the `requirements.txt` from our local directory into the Linux OS directory.\n\nThe `RUN pip install --no-cache-dir -r requirements.txt` then does a pip install of all the libraries that are included within the requirements onto the Linux base image.\n\nThe `COPY . .` I believe just copies everything in the local directory into the Linux directory. Therefore, it is highly important that you are running `docker` in the command line within the correct directory. That is, your current project folder. (*Note: I actually created a separate folder project_name_2 that had only the necessary items and dockerize my app there*)\n\nThe `CMD [ \"python\", \".\/app.py\" ]` will tell the Linux OS to run `python .\/app.py` within the container's command line. This runs your Flask app within the Docker container.","7a3a5c9a":"If you check the getting started area within the [docs](https:\/\/docs.docker.com\/get-started\/), they have a nice intro into what containers are and how they work. The screenshot above shows how containers are more efficient than the approach of installing an independent virtual machine which takes up much more space. Containers on the other hand, are like processes running on your computer (some people call them small virtual machines). I felt that [Krish Naik](https:\/\/www.youtube.com\/watch?v=hTacGMfL8lc&list=PLZoTAELRMXVNKtpy0U_Mx9N26w8n0hIbs) gave a good explanation of it on his YouTube channel (*Note: he also demonstrates how to do what I am showing here*).\n\nBeyond Docker, there is another similar software called [Kubernetes](https:\/\/kubernetes.io) by Google. It does what Docker does, but also more complex tasks that Docker cannot do. It is useful in situations where it is needed.","d7ab89c8":"# 6. Heroku\n<a id=\"heroku\"><\/a>\n<a href=\"#top\">Back to top<\/a>","cbb248d1":"# 2. Setting up the File Directory\n<a id=\"dir\"><\/a>\n<a href=\"#top\">Back to top<\/a>\n\nA first step for any project is to set up a clean file directory. There are no concrete rules, but I will give an idea of how my own project directory is set up. A good idea also is to start familiarizing yourself with [bash](https:\/\/www.freecodecamp.org\/news\/basic-linux-commands-bash-tips-you-should-know\/) commands and also to move from Jupyter Notebooks to [Visual Studio Code (VS Code)](https:\/\/code.visualstudio.com). This does not imply abandoning notebooks altogether, simply that for more complicated projects, working in VS Code has its advantages.\n\nI am working on a Macbook, so I will demonstrate the process from the terminal.\n\n1. `cd Desktop\/projects\/`\n2. `mkdir project_name`\n3. `cd project_name`\n\nSo far, we have simply created a project folder within the `\/projects\/` folder located on the `\/Desktop\/`.\n\n4. `code .`\n\nNow, we have initialized a VS Code session within this directory (like starting a git with `git init`).\n\n5. `python3 -m venv env`\n6. `source env\/bin\/activate`\n\nSteps 5 and 6 involve creating a virtual environment. This makes a environment within the folder that does not include all the previously installed libraries. This is smart since it helps to have a saved list of all the current libraries and their versions (and only those).\n\n7. `pip install -U numpy scipy scikit-learn`\n8. `pip freeze > requirements.txt`\n\nIn step 7, we install some libraries, of course for a typical project we will require others also. Step 8 creates a text document within the directory that shows all the installed libraries and their current versions. This is also important for Docker which will be seen later. An issue is that this lists dependencies of installed libraries also, so there could be issues with that. A possibility is to manually add the libraries and the versions you install into a document, or do `pip freeze` and then remove the dependencies after. (*Note: I have had the experience already of a dependency causing an issue and having to remove it manually before things worked smoothly.*)\n\n9. `mkdir input src models notebooks`\n\nThis involves creating more file directories. This specific set of folders were actually learned from Abhishek Thakur's [new ML book](https:\/\/www.amazon.com\/gp\/product\/8269211508\/ref=ppx_yo_dt_b_asin_title_o01_s00?ie=UTF8&psc=1).\n\nThe resulting file tree can look something like this:\n`\n    - project_name\n        - env\n        - static\n            - css\n                - main.css\n        - templates\n            - index.html\n        - inputs\n            - train.csv\n            - test.csv\n        - src\n            - app.py\n            - model.py\n        - models\n            - pickle.dat\n        - notebooks\n            - eda.ipynb\n        - Dockerfile\n        - Procfile\n        - requirements.txt`\n\nThe `static` and `templates` folders and files are for the front end portion of the Flask app. A nice tutorial about them can be seen [here via FreeCodeCamp](https:\/\/www.youtube.com\/watch?v=Z1RJmh_OqeA). The `pickle.dat` is the saved model that is produced during training within `model.py`. While `app.py` is the file that runs Flask. The `Dockerfile` and `Procfile` are specific to getting the Docker and Heroku to work. They will explained later.","a805b2b9":"We all have different backgrounds and abilities. Both our education and experiences are different and this can lead us to developing a skill tree similar to what is seen above. We have knowledge of various disciplines, but our paths generally lead us to a [T-shaped skill](https:\/\/en.wikipedia.org\/wiki\/T-shaped_skills) tree, where we have expertise in one area while being weaker in others. Working on a web app as a data scientist reminds us of this. Most of us are likely capable of developing some ML project in Python which involves training a model and outputting a prediction, but then things seem to largely stop there.\n\nOur weakness in other fields such as front end web design, DevOps, etc., will quickly be made apparent. This does not mean that we should go back to school and spend months learning these important skills, but what we can do is learn enough so that we understand and know how to be practical when using them. In this kernel, we will go step-by-step getting a bit of insight into the different fields that will allow us to develop a simple web app, without becoming experts in these areas themselves.","9afd0efe":"The above code will open a webpage locally on your computer that outputs \"Hello World!\" One of the first things that are noticable is the `@app.route(\"\/\")` above the `hello()` function. This is called a *decorator*, and you can read more about it [here](https:\/\/realpython.com\/primer-on-python-decorators\/). Also, `if __name__ == \"__main__\":` can be used to check whether the current file is the main file being run or whether it is for example being imported into another main file. More detail about the process can be seen also within the [docs](https:\/\/flask.palletsprojects.com\/en\/1.1.x\/quickstart\/).","e1cc408e":"# 3. An ML Project Idea\n<a id=\"ml\"><\/a>\n<a href=\"#top\">Back to top<\/a>\n\nIt starts first with thinking of a ML tool that you believe is interesting and worth sharing. It can be something simple, or something quite elaborate. I was initially interested in doing some handwriting recognition to practice my PyTorch skills, but setting up a GUI seems quite difficult. There are packaged methods that can do this, but using them would involve abandoning Flask, which I do not want to do. A good alternative for those of us who are not specialized in front end work is [https:\/\/www.streamlit.io](https:\/\/www.streamlit.io), which simplifies the process of making web apps.\n\nInstead, I decided to make a video game out of a school project. The game is based on a reinforcement learning (RL) task, where the goal is to train an agent to complete a racetrack in as fast of a time as possible. It originally comes from a [Sutton and Barto textbook](https:\/\/web.stanford.edu\/class\/psych209\/Readings\/SuttonBartoIPRLBook2ndEd.pdf). The project involved three different RL algorithms: Value Iteration , Q-Learning , and SARSA.\n\nThe RL agents have learned to go from a starting area to a finishing area. There are some in-game physics that the agents must learn, where they learn to accelerate in an attempt to get to the end while avoiding crashes with barriers. There are two crash scenarios, if the agent hits the wall it resets to the nearest track location (soft reset) or it resets to the beginning of the track (hard reset). Furthermore, to add some non-determinism, there is a 20% chance that acceleration fails and so it in a given timestep its velocity will remain constant.\n\nThe simple web app game allows users to choose:\n1. Crash case: soft reset or hard reset\n2. Track type: L-shape, O-shape, or R-shape\n3. Car model: the agent trained through Value Iteration, Q-Learning, or SARSA\n4. Car number: A random seed for your driver\n\nAfter choosing, the agents will race and a new page will be loaded showing the time taken for each driver to finish, some basic race statistics, and a map of their paths taken.","9da8ad38":"## Deploying Your App Container\nI think for beginners, the following method is simplest. After creating an account on Heroku, you can create an app with some unique name in the format of app-name. After doing so, click on the app and go to the \"Deploy\" section. Then, from \"Deploy method,\" click on \"Container registry.\"\n\nThen you have the following steps:\n1. `heroku login`\n2. `docker ps`\n3. `heroku container:login`\n4. `heroku container:push web -a app-name`\n5. `heroku container:release web -a app-name`\n\nIn step 1, you are logging into Heroku via the CLI, which is convenient now since they have a browser page popup that allows you to login. In step 2, it is checking to make sure that your Docker image is currently running and functioning locally on your machine. This is why I mentioned to incude `-d` or `-detach` so that the app would keep running in the background while you have access still to the command line. In step 3, you are logging into Heroku's containers. Steps 4 and 5 have you push the Docker image and then release it. It is important that you are in the same directory as your running Docker image. Also, you need to add `-a` and the app name that you have just created on Heroku. You can open the page with `heroku open`.\n\nMy rather simple web app can be seen here: [https:\/\/racecar-app.herokuapp.com](https:\/\/racecar-app.herokuapp.com). It has a rather poor front end, something that I wish I had the time and energy for. However, it works and so I am happy with it. An important note that I will mention also is that I did this all on my machine, and it is quite certain that it will not work identically for many of you. It is a bit ironic, but I am trying to show others the general pathway towards going from an ML project, to a Flask app, to Docker, and then to Heroku. If you have done `heroku open`, it is likely that you have some error and your page is not working yet.\n\nSimilar to how we debug in our local machine, you can check error messages with `heroku logs --tail -a app-name`. I noticed that it can be hard to find a similar amount of online help through forums like we may normally be able to, given that there are much fewer people out there on Heroku than there are in general looking for basic Python help questions.","c56acbb6":"## Run Your Image as a Container\nNow, you need to run the image that you have built. The docs on Docker's website have the following example: `docker run --publish 8000:8080 --detach --name bb bulletinboard:1.0`\n\nThe line that I used is as follows: `docker run -p 8000:5000 -d app_name`\n\nYou can see the meaning of the tags in the Docker docs, but it is important to detach with `-d` or `-detach`. The reason is that otherwise you will be unable to use the command line without closing the image. The interesting part is `8000:5000`. This deals with the network configuration, which I think most of us are not experts on. My understanding is that there is a network bridge on our local machine and also within the container. We want to temporarily expose part of our network `8000` so that we can access our app through it. This allows us to go to `localhost:8000\/` to find our app. The `5000` refers to the exposed network port within the container. My understanding of this is not perfect though, so I can be mistaken in parts of this explanation.\n\nHere are some [useful commands](https:\/\/blog.baudson.de\/blog\/stop-and-remove-all-docker-containers-and-images) to handle Docker while you are trying to figure things out. Given that your app works locally after using Flask and also with it being Dockerized, we can move towards deployment via Heroku.","3ceef15b":"# Table of Contents\n<a id=\"top\"><\/a>\n\n1.\t[Working on Our T-shaped Skills](#T)\n2.\t[An ML Project Idea](#ml)\n3.  [Setting up the File Directory](#dir)\n4.  [Flask](#flask)\n5.\t[Docker](#docker)\n6.\t[Heroku](#heroku)\n7.  [Resources](#resources)","2b82108e":"# 5. Docker\n<a id=\"docker\"><\/a>\n<a href=\"#top\">Back to top<\/a>","a64b32a1":"This is not actually required in this simple case, but it shows what would be required if the model was more complex with custom classes. Another note is that if you are importing multiple models, the `reg` variable in `model.py` can actually be a list of saved models. This list can then be opened in `app.py` and the models can be unpacked from within that list.","88f4ae21":"## Build your Docker Image\nThe next step is to build your Docker image after creating the Dockerfile. The demo tutorial in the Docker docs have the following line: `docker build --tag bulletinboard:1.0 .`\n\nThe line that I used is as follows: `docker build -t app_name .`\n\nThe `-t` is the shorthand for `--tag`, and I believe by adding `:1.0` they are adding a sub-name to their app. Otherwise, the sub-name (or TAG) will be `\"latest\"`. If you type `docker images`, you should see it there.","4c88e4d9":"## Heroku Command Line Interface (CLI)\nIt also makes sense to learn a bit of [Heroku's CLI](https:\/\/devcenter.heroku.com\/articles\/heroku-cli) for convenience down the road. You will need to install it, along with setting up a free account. They allow up to five apps for free users, along with a bit of slowness when first loading the page if the app is not used frequently.","2e62bf7b":"## Procfile\n\nWith Heroku, it is also important to create a `Procfile`. It is simply a textfile with the following line in it: `web gunicorn app:app`\n\nYou will need to `pip install gunicorn`. The `app:app` I believe refer both to the name of your file `app.py` and the `app = Flask(__name__)` variable. I think this leads to some unclear code, but it is what I have seen on the internet and it is likely what is easy for beginners to copy and paste to get a basic Flask app working. Here is some more information from [Heroku's docs](https:\/\/devcenter.heroku.com\/articles\/procfile). (*Note: it is important to remember our specific niche of creating some ML project in Python and creating a web app via Flask, therefore the docs for Docker and Heroku do not always fit perfectly*)","e23723bf":"## Dockerfile\nThere are different ways to build a Dockerfile and the one below is certainly not the most optimal. However, I found that it was understandable and that it worked. The commands in all capital letters (e.g., FROM, WORKDIR, etc.) are the Docker commands. What is happening, is that we are taking a base image (i.e., some Linux OS) and building our own Python environment within it. So, it is like our entire app is contained within this Docker image.","30a7fdf9":"# 1. Working on Our T-shaped Skills\n<a id=\"T\"><\/a>\n<a href=\"#top\">Back to top<\/a>","57e15464":"The website for Flask describes it as such:\n\n\"Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. It began as a simple wrapper around Werkzeug and Jinja and has become one of the most popular Python web application frameworks.\"\n\nIt is a simple tool for creating web apps on Python, compared to a more complicated framework such as [Django](https:\/\/www.djangoproject.com) which can handle larger and more complex tasks. For this reason, Flask is chosen as the method for creating a web app. Within the web page, it is possible to improve the appearance with skills in HTML and CSS. My belief is that most Python programmers are not specialized in front end development, so it is fine also to leave the webpages quite simple. There are resources online for templates that can be used for free, and only simple knowledge of HTML is required to implement them.\n\nThe following is a simple \"Hello World!\" web app:","7ce7f7f0":"# 4. Flask\n<a id=\"flask\"><\/a>\n<a href=\"#top\">Back to top<\/a>","d5834b65":"## Getting the Right Host and Port Values\nAnother issue that I noticed is getting the port and host values to be correct. A first step is getting Flask to run locally without any issue. When going to a browser and entering `0.0.0.0:5000`, it should take you to your app's webpage. However, this is the network configuration for your local machine. It gets a bit more complicated when thinking about the network configuration after containerizing and deploying it on Heroku. My understanding is that the `port` needs to have a variable so that Heroku can find the app when it is live.\n\nBelow, the code tells Flask to use `port=5000` unless told otherwise by some environment variable named `PORT`.","2a94910d":"## Serializing your Model\n\nAn important lesson I learned is to serialize your model during training. It is not always required, for example I have seen when people create an ML model with sk-learn and everything is fine. With my RL model, I had created custom classes. These were also run in a separate `model.py` file. The issue is when using `pickle` to save a model, the class exists in a separate file and was serialized there too. So it is not as straightforward as doing `import model` in `app.py`.\n\nThe fix is to include `if __name__ == \"__main__\":` in both the `model.py` when the model is trained and in `app.py` when the pickled model is loaded. For example:","f0f85ed1":"## Dockerizing your Flask App\nAfter getting the Flask app to run locally on your machine, where you can navigate to some localhost and see your app working without errors, the next step is to containerize it. First you need to have [Docker installed](https:\/\/docs.docker.com\/get-started\/). The docs also have a [nice demo](https:\/\/docs.docker.com\/get-started\/part2\/) where you can use the Docker hub (similar to GitHub) to download some files to do the entire process of building a Docker image and running it locally.\n\nThe steps are as follows:\n1. Create a Dockerfile\n2. Build your Docker image\n3. Run your Docker image as a container","a4736cfc":"# Guide to Building a Web APP\n## ML tool $\\rightarrow$ Flask $\\rightarrow$ Docker $\\rightarrow$ Heroku\n\n**Motivation:** The goal of this kernel is to do an overview of how a simple web app can be produced. As a data scientist, it would make sense to create a simple web app that could demonstrate the capabilities of a certain machine learning (ML) tool that had been developed for some purpose. It starts with training an ML model, demonstrating it via a web page with Flask, containerizing it with Docker, and then deploying it on Heroku. After the ML training part, the rest is a bit intimidating for those of us without the related backgrounds. I will try to touch on them lightly.\n\n*Note: This guide is not comprehensive, but moreso as a set of notes to share some lessons recently learned in the path towards basic web app development.*"}}