{"cell_type":{"b1562c6b":"code","afe101b2":"code","3f935ead":"code","4f6eb753":"code","a5aa3acc":"code","a151b990":"code","a4c60d3d":"code","570fa77d":"code","fcc6f129":"code","9b3e6ff8":"code","1830fe27":"code","54146636":"code","96eae4ad":"code","34ce71e2":"code","8f7ed69d":"code","cda49c74":"code","caf7aaa1":"code","4cb016ed":"code","dbc5ef84":"code","9aeebc41":"code","3d6be89d":"code","b3c08c7c":"code","c62f7fba":"code","9bd4181e":"code","07dbdb74":"code","197617aa":"code","d50d39bb":"code","4fac1584":"code","8b61b397":"code","7220eaa0":"code","408163db":"code","53526a23":"code","d45b7c50":"code","b88a510d":"markdown","06db7ce0":"markdown","ff22c252":"markdown","48441ca8":"markdown","2f1d205f":"markdown","f5f7b595":"markdown","fdcd206a":"markdown"},"source":{"b1562c6b":"!pip install efficientnet_pytorch","afe101b2":"!pip install wtfml==0.0.2","3f935ead":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfrom PIL import Image\n\nfrom sklearn import model_selection\nfrom sklearn import metrics\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nimport torch.optim as optim\nimport efficientnet_pytorch\n\nimport albumentations as A\n\nfrom wtfml.utils import EarlyStopping\nfrom wtfml.engine import Engine\nfrom wtfml.data_loaders.image import ClassificationLoader\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# from wtfml.classification import ClassificationDataLoader\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","4f6eb753":"train_dir = '..\/input\/siic-isic-224x224-images\/train'\ntest_dir = '..\/input\/siic-isic-224x224-images\/test'","a5aa3acc":"t = os.listdir(train_dir)\n\nt1 = os.listdir(test_dir)\nprint(len(t),len(t1),len(t)+len(t1))","a151b990":"imgpath = '..\/input\/siic-isic-224x224-images\/test\/ISIC_0052060.png'\nimg = Image.open(imgpath)\nimg","a4c60d3d":"img2np = np.array(img)\nimg2np.shape","570fa77d":"ten = torch.from_numpy(img2np)\nten.shape","fcc6f129":"input_path = '..\/input\/siim-isic-melanoma-classification\/train.csv'\ndf = pd.read_csv(input_path)\ndf.head()","9b3e6ff8":"df['kfold'] = -1\ndf.head()","1830fe27":"df.sample(frac = 1).head()","54146636":"df = df.sample(frac = 1).reset_index(drop = True) #shuffling the data, and reset index\ndf.head()","96eae4ad":"y = df.target.values\nlen(y)","34ce71e2":"kf = model_selection.StratifiedKFold(n_splits=5)\nfor fold_,(train_idx, test_idx) in enumerate(kf.split(X=df,y=y)):\n    df.loc[test_idx,'kfold'] = fold_\ndf.to_csv('.\/train_folds.csv')","8f7ed69d":"ddf = pd.read_csv('.\/train_folds.csv')\nddf","cda49c74":"# fold is an integer for k-fold.val kfold is fold rest training\ndef train(fold):\n    training_data_path = train_dir\n    df = pd.read_csv('.\/train_folds.csv')\n    device = \"cuda\"\n    epochs = 50\n    train_bs = 32\n    valid_bs = 16\n    \n    df_train = df[df.kfold != fold].reset_index(drop=True)\n    df_valid = df[df.kfold == fold].reset_index(drop=True)\n    \n    # Normalize the images\n    mean = (0.485, 0.456, 0.406)\n    std = (0.229, 0.224, 0.225)\n    ","caf7aaa1":"# fold is an integer ie if fold == that no then val else train\ndef train(fold):\n    training_data_path = \"..\/input\/siic-isic-224x224-images\/train\/\"\n    df = pd.read_csv(\"\/kaggle\/working\/train_folds.csv\")\n    device = \"cuda\"\n    epochs = 50\n    train_bs = 32\n    valid_bs = 16\n\n    df_train = df[df.kfold != fold].reset_index(drop=True)\n    df_valid = df[df.kfold == fold].reset_index(drop=True)\n    \n    mean = (0.485, 0.456, 0.406)\n    std = (0.229, 0.224, 0.225)\n\n    ","4cb016ed":"# IMP for Stratified K-Folds\nfold = 0","dbc5ef84":"training_data_path = \"..\/input\/siic-isic-224x224-images\/train\/\"\ndf = pd.read_csv(\"\/kaggle\/working\/train_folds.csv\")\n\nmean = (0.485, 0.456, 0.406)\nstd = (0.229, 0.224, 0.225)\n    \ndf_train = df[df.kfold != fold].reset_index(drop=True)\ndf_valid = df[df.kfold == fold].reset_index(drop=True)","9aeebc41":"# df_train.image_name.values.tolist()\ndevice = \"cuda\"\nepochs = 50\ntrain_bs = 32\nvalid_bs = 16","3d6be89d":"#Train\ntraining_data_path = \"..\/input\/siic-isic-224x224-images\/train\/\"\n\ntrain_aug = A.Compose(\n        [\n            A.Normalize(mean, std, max_pixel_value=255.0, always_apply=True),\n            A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.1, rotate_limit=15),\n            A.Flip(p=0.5)  \n        ]          \n    )\n\ntrain_images = df_train.image_name.values.tolist()\ntrain_images = [os.path.join(training_data_path, i + '.png') for i in train_images]\ntrain_targets = df_train.target.values\n\n\ntrain_dataset = ClassificationLoader(\n    image_paths=train_images,\n    targets=train_targets,\n    resize=None,\n    augmentations=train_aug,\n)\n\ntrain_loader = torch.utils.data.DataLoader(\n        train_dataset, batch_size=train_bs, shuffle=True, num_workers=4)","b3c08c7c":"# Valid\nvalid_images = df_valid.image_name.values.tolist()\nvalid_images = [os.path.join(training_data_path, i + \".png\") for i in valid_images]\nvalid_targets = df_valid.target.values\n\nvalid_aug = A.Compose([\n    A.Normalize(mean, std, max_pixel_value=255.0, always_apply=True)\n])\n\nvalid_dataset = ClassificationLoader(\n    image_paths=valid_images,\n    targets=valid_targets,\n    resize=None,\n    augmentations=valid_aug,\n)\n\nvalid_loader = torch.utils.data.DataLoader(\n        valid_dataset, batch_size=valid_bs, shuffle=False, num_workers=4)","c62f7fba":"class EfficientNet(nn.Module):\n    def __init__(self):\n        super(EfficientNet, self).__init__()\n        self.base_model = efficientnet_pytorch.EfficientNet.from_pretrained(\n            'efficientnet-b4'\n        )\n        self.base_model._fc = nn.Linear(\n            in_features=1792, \n            out_features=1, \n            bias=True\n        )\n        \n    def forward(self, image, targets):\n        out = self.base_model(image)\n        loss = nn.BCEWithLogitsLoss()(out, targets.view(-1, 1).type_as(out))\n        return out, loss","9bd4181e":"model = EfficientNet()\nmodel.to(device)","07dbdb74":"# net = efficientnet_pytorch.EfficientNet.from_pretrained(\n#             'efficientnet-b4'\n#         )","197617aa":"device","d50d39bb":"# for param in net.parameters():\n#     param.requires_grad = False\n    \n# _fc = nn.Linear(1792,1)\n# net._fc = _fc","4fac1584":"optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)\nscheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(\n        optimizer,\n        patience=3,\n        threshold=0.001,\n        mode=\"max\"\n    )\n\nes = EarlyStopping(patience=5, mode=\"max\")","8b61b397":"epochs = 50\nfor epoch in range(epochs):\n        train_loss = Engine.train(train_loader, model, optimizer, device=device)\n        predictions, valid_loss = Engine.evaluate(\n            valid_loader, model, device=device\n        )\n        predictions = np.vstack((predictions)).ravel()\n        auc = metrics.roc_auc_score(valid_targets, predictions)\n        print(f\"Epoch = {epoch}, AUC = {auc}\")\n        scheduler.step(auc)\n\n        es(auc, model, model_path=f\"model_fold_{fold}.bin\")\n        if es.early_stop:\n            print(\"Early stopping\")\n            break","7220eaa0":"# torch.save\ntorch.save(model.state_dict(), '.\/modetor.pt')","408163db":"#Test\ndef predict(fold):\n    print(f\"Generating Predictions for saved model, fold = {fold+1}\")\n    test_data_path = \"\/kaggle\/input\/siic-isic-224x224-images\/test\"\n    df_test = pd.read_csv(\"\/kaggle\/input\/siim-isic-melanoma-classification\/test.csv\")\n    df_test.loc[:,'target'] = 0\n    \n    #model_path = \"f'\/kaggle\/working\/model_fold{fold}'\"\n    #model_path = '\/kaggle\/working\/model_fold0_epoch0.bin'\n    model_path = '.\/model_fold_0.bin'\n    \n    device = 'cuda'\n    \n    test_bs = 16\n    \n    mean = (0.485, 0.456, 0.406)\n    std = (0.229, 0.224, 0.225)\n    \n    test_aug = A.Compose(\n        [\n            A.Normalize(mean, std, max_pixel_value=255.0, always_apply=True,p=1.0)\n        ]\n    )\n    test_images_list = df_test.image_name.values.tolist()\n    test_images = [os.path.join(test_data_path,i + '.png') for i in test_images_list]\n    test_targets = df_test.target.values\n    \n    test_dataset = ClassificationLoader(\n        image_paths = test_images,\n        targets= test_targets,\n        resize = None,\n        augmentations = test_aug\n    )\n    \n    test_loader = torch.utils.data.DataLoader(\n        test_dataset,\n        batch_size = test_bs,\n        shuffle = False,\n        num_workers=4\n    )\n    #Earlier defined class for model\n    model = EfficientNet()\n    model.load_state_dict(torch.load(model_path))\n    model.to(device)\n    \n    predictions_op = Engine.predict(\n        test_loader,\n        model,\n        device\n    )\n    return np.vstack((predictions_op)).ravel()","53526a23":"# prediction\npred = predict(0)","d45b7c50":"predictions = pred\nsample = pd.read_csv(\"..\/input\/siim-isic-melanoma-classification\/sample_submission.csv\")\nsample.loc[:, \"target\"] = predictions\nsample.to_csv(\"submission.csv\", index=False)","b88a510d":"### Exploring Dataset","06db7ce0":"### References :\n* https:\/\/www.kaggle.com\/abhishek\/accelerator-power-hour-pytorch-tpu\n* https:\/\/www.kaggle.com\/kevin9000\/melanoma-beginner-cnn-using-pytorch\n* https:\/\/www.kaggle.com\/abhishek\/melanoma-detection-with-pytorch?scriptVersionId=35193166\n* https:\/\/www.kaggle.com\/nvnvashisth\/pytorch-efficientnet-b0-gpu\n* https:\/\/www.kaggle.com\/shebinscaria\/siim-isic-efficientnet-starter-code\n* https:\/\/www.youtube.com\/watch?v=QxJgKPdEBV4\n* https:\/\/www.youtube.com\/watch?v=WaCFd-vL4HA\n* https:\/\/towardsdatascience.com\/cuda-error-device-side-assert-triggered-c6ae1c8fa4c3","ff22c252":"## Model Training - Efficient Net","48441ca8":"Stratified K-Fold","2f1d205f":"## Custom Dataset","f5f7b595":"## Model Transfer Learning","fdcd206a":"## Create folds in dataset"}}