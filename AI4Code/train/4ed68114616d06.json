{"cell_type":{"9567ec91":"code","36358096":"code","4e63c678":"code","c92f39fc":"markdown"},"source":{"9567ec91":"import h5py  \nimport numpy as np\nimport requests\n\nfrom collections.abc import Sequence\nfrom IPython.display import display, Image\nfrom typing import List\nfrom PIL import Image\nfrom io import BytesIO\n\n_H5_FRAME_COUNT_ATTR = 'ANIMATION_FRAMES'\n_H5_ANIMATION_DELAY_MS_ATTR = 'ANIMATION_DELAY_MS'\n\n\ndef store_image_as_dataset(hf: h5py._hl.files.File, dataset_path: str,\n                           img: Image, animation_ms=50) -> None:\n  '''\n    Store an image at a dataset location in an open HDF5 file.  Images are\n    stored in RGBA format, and animated images will be stored as a series of\n    RGBA frames.\n\n    Parameters:\n        img (Image):The string which is to be reversed.\n\n    Returns:\n        reverse(str1):The string which gets reversed.   \n  '''\n  #data = np.asarray((img), dtype=\"uint8\")\n  if img.is_animated:\n    frame = np.array(img.convert('RGBA'))\n    data = np.zeros((img.n_frames,) + np.shape(frame), dtype='uint8')\n    for i in range(img.n_frames):\n      img.seek(i)\n      data[i] = np.array(img.convert('RGBA'))\n  else:\n    data = np.array(img.convert('RGBA'))\n\n  print(np.shape(data))\n  print(data.dtype)\n  ds = hf.create_dataset(dataset_path, data=data, dtype='uint8',\n                         compression='gzip', compression_opts=9)\n  ds.attrs['CLASS'] = 'IMAGE'\n  ds.attrs['IMAGE_VERSION'] = '1.2'\n  ds.attrs['IMAGE_SUBCLASS'] = 'IMAGE_TRUECOLOR'\n  ds.attrs['INTERLACE_MODE'] = 'INTERLACE_PIXEL'\n  if img.is_animated:\n    # Non-standard attributes for animation. Including the number of frames is\n    # redundant as it's also in the shape of the data, but we prefer to be\n    # explicit here.\n    ds.attrs[_H5_FRAME_COUNT_ATTR] = img.n_frames\n    ds.attrs[_H5_ANIMATION_DELAY_MS_ATTR] = animation_ms\n\ndef read_image_from_dataset(hf: h5py._hl.files.File , dataset_path: str) -> Image:\n  ds = hf[dataset_path]\n  frames = ds.attrs.get(_H5_FRAME_COUNT_ATTR, None)\n  if frames:\n    delay_ms = ds.attrs.get(_H5_ANIMATION_DELAY_MS_ATTR, 100)\n    print(f'Reading animated img {np.shape(ds[0])}')\n    frames = [ Image.fromarray(ds[i], 'RGBA') for i in range(frames) ]\n    return compose_frames(frames, delay_ms)\n  else:\n    return Image.fromarray(ds ,'RGBA')\n\ndef compose_frames(frames, delay_ms) -> Image:\n  # PIL doesn't seem to support inserting frames into an image outside of saving it, so we\n  # save the image into a buffer and then reload it.\n  in_memory = BytesIO()\n  frames[0].save(in_memory, format='png', append_images=frames[1:],\n                 save_all=True, duration=delay_ms, loop=0)\n  return Image.open(in_memory)","36358096":"def create_testframes(x:int, y:int, frames:int) -> Image:\n  return compose_frames([ create_testframe(x, y, i) for i in range(frames) ],\n                        50)\n\ndef create_testframe(x:int, y:int, t:int) -> Image:\n  data = np.zeros((x, y, 4), dtype='uint8')\n  for ix in range(x):\n    for iy in range(y):\n      data[ix][iy][0] = (32 * (ix \/ x) + 16 * (iy \/ y) + 4 * t) % 256\n      data[ix][iy][1] = (16 * (ix \/ x) + 32 * (iy \/ y) + 6 * t) % 256\n      data[ix][iy][2] = ((ix * iy) \/ (x * y)) % 256\n      data[ix][iy][3] = 64 + ((64 * (ix \/ x) + 32 * (iy \/ y) + 5 * t)) % 192\n  return Image.fromarray(data, 'RGBA')\n\n\nimg1 = create_testframes(100, 100, 200)\nimg1.save('sample.png', save_all=True)\nwith h5py.File('unwords.h5', 'w') as hf:\n  store_image_as_dataset(hf, 'Images\/Image', img1)\n  img2 = read_image_from_dataset(hf, 'Images\/Image')\n  img2.save('from_h5.png', save_all=True)","4e63c678":"!apt install -y h5utils\n!h5dump -H unwords.h5","c92f39fc":"# HDF5 files\nWorking with HDF5 files, I wanted a way to store animated images with transparency in an HDF5 dataset.  This code is intended to support GIF, PNG, WebP, and other PIL Images.\n\nThis implementation has limited support for animation timing.  You can specify a delay when saving the image, and the loaded image will be a looping version with the specified delay.  However, the main use case for this is lossless storage of the image data."}}