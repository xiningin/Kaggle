{"cell_type":{"fe1af70a":"code","03dc6a84":"code","49f61da6":"code","ba7d5f72":"code","0952e7a1":"code","2061b5d5":"code","f7b48bc2":"code","8a699690":"code","807065d9":"code","cf7cf6b9":"code","c47b077a":"code","fd1f0a32":"code","cdd79313":"code","338f22e6":"markdown","6d84320a":"markdown","43cc848d":"markdown","6ba1e4ae":"markdown","7ea0de84":"markdown"},"source":{"fe1af70a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","03dc6a84":"# setting some matplotlib defaults to make plots a bit nicer\nimport matplotlib\nmatplotlib.rcParams['font.family'] = \"sans-serif\"\nmatplotlib.rcParams['font.weight'] = \"light\"\nmatplotlib.rcParams['font.style'] = \"normal\"\nmatplotlib.rcParams['ytick.color'] = \"#434343\"\nmatplotlib.rcParams['xtick.color'] = \"#434343\"\nmatplotlib.rcParams['text.color'] = \"#434343\"\nmatplotlib.rcParams['axes.spines.left'] = False\nmatplotlib.rcParams['axes.spines.bottom'] = False\nmatplotlib.rcParams['axes.spines.top'] = False\nmatplotlib.rcParams['axes.spines.right'] = False\nmatplotlib.rcParams['axes.titleweight'] = 'semibold'\nmatplotlib.rcParams['axes.axisbelow'] = True\nmatplotlib.rcParams['xtick.bottom'] = False\nmatplotlib.rcParams['ytick.left'] = False\nmatplotlib.rcParams['grid.color'] = '#B5B6B8'\nmatplotlib.rcParams['grid.alpha'] = 0.5\nmatplotlib.rcParams['savefig.dpi'] = 300\n\npalette = ['#A45FD6', '#B5B6B8', '#ECECED' ]","49f61da6":"df = pd.read_csv(os.path.join(dirname, 'articles_data.csv'))","ba7d5f72":"df.head()","0952e7a1":"df.info()","2061b5d5":"# who puts out articles\nsource_dist = (df.groupby('source_name').agg(percentage=('source_id', 'count'))\/df.source_id.count()).sort_values('percentage')\ntop = source_dist.iloc[-1].name\ncolor = [{top:palette[0]}.get(x, palette[1]) for x in source_dist.index]\nsource_dist.percentage.plot(\n    kind = 'barh',\n    color=color\n)\n","f7b48bc2":"# Lets have a look at the engagement metrics and see what they all are.\nengagement_cols = [col for col in df.columns if 'engagement' in col]","8a699690":"# lets drop the rows that are missing engagement metrics.\nfor col in engagement_cols:\n    df = df[df[col].notnull()]\n","807065d9":"engagement_summary = df[engagement_cols].describe().T\nengagement_summary","cf7cf6b9":"# lets look at the distribution of the engagement kpis (trimming off the upper 25% to remove the extream ones.)\nfor col in engagement_cols:\n    f,ax = plt.subplots()\n    df[df[col]<engagement_summary.loc[col, '75%']][col].hist(color=palette[0])\n    ax.set_title(col.replace('_',' '), x=0, ha='left')\n","c47b077a":"correlations = (\n    df[engagement_cols]\n    # compute the correlations coeffes\n    .corr(method='spearman')\n    # convert the data into a long format so we can order the correlations\n    .reset_index()\n    .melt(\n        id_vars = 'index'\n    )\n    # drop the duplicates\n    .query('index > variable')\n    .sort_values('value', ascending=False)\n    .rename(columns = {'index':'col1', 'variable': 'col2'})\n    .reset_index(drop=True)\n)\ncorrelations","fd1f0a32":"x_col = correlations.loc[0, 'col1']\ny_col = correlations.loc[0, 'col2']\nax = df.plot(\n    x=x_col,\n    y=y_col,\n    kind='scatter',\n    color = palette[0]\n)\n# ax.set_xlim(0, engagement_summary.loc[x_col, '75%'])\n# ax.set_ylim(0, engagement_summary.loc[y_col, '75%'])\n","cdd79313":"df_top_reactions = df[df['engagement_reaction_count'] > engagement_summary.loc['engagement_reaction_count','75%']]\ndf_top_reactions = (\n    df_top_reactions\n    .groupby(['source_name'])\n    .agg(percentage_in_top_25=('source_id', 'count'))\n    .sort_values('percentage_in_top_25', ascending=False) \/ df_top_reactions.source_id.count()\n)\n\ndf_top_reactions = df_top_reactions.join(source_dist).assign(\n    difference_in_dist = lambda x: x['percentage_in_top_25'] - x['percentage']\n).sort_values('difference_in_dist')\n\nax = df_top_reactions.difference_in_dist.plot(\n    kind = 'barh',\n    color = ['red' if x<0 else 'green' for x in df_top_reactions.difference_in_dist],\n    width=0.85\n)\nax.set_title('Difference between source distribution \\nin top 25% and the general population', x=0, ha='left')","338f22e6":"# What are the common features of the articles with high reaction counts?","6d84320a":"In this sample The New York Times has a much higher percentage of articles in the top 25% of reactions than it's percentage of articles overall, indicating that the New York times has a much higher quality of tracffic. Reuters and the Irish Times have a much lower percentage of articles in the top 25% of reactions.","43cc848d":"Reaction count is a reasonable predictor for comment count.","6ba1e4ae":"# Investigating the correlations betweeen the engagement metrics.","7ea0de84":"The plugin metric has the weakest corelation with the other engagment metrics. The strongest correlation is between the comment and reaction counts."}}