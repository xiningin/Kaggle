{"cell_type":{"91f0c5b2":"code","89607851":"code","0351c92c":"code","5b2e377e":"code","218972b6":"code","e3534f17":"code","5bbf047f":"code","b499eda8":"code","7bb4514f":"code","f9d0f21c":"code","19589cd6":"code","ea65c604":"code","b12aae2f":"code","5e385085":"code","dfcb28dd":"code","77b92852":"code","c75c926c":"markdown","b1dd911e":"markdown","58ecca99":"markdown","dcff322a":"markdown","e4bbd14d":"markdown","bfd1df2e":"markdown","3002f596":"markdown","5cfc8150":"markdown","a1c22c8e":"markdown","63105925":"markdown","8af25ebc":"markdown","7d6628dc":"markdown"},"source":{"91f0c5b2":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport os\nimport matplotlib.pyplot as plt\nfrom IPython.display import Image\nfrom scipy.stats import pearsonr\nsns.set(style=\"white\", font_scale=1.2)","89607851":"Image(\"..\/input\/pictures\/top_directors.png\")","0351c92c":"Image(\"..\/input\/pictures\/top_actors.png\")","5b2e377e":"Image(\"..\/input\/pictures\/comparison_imdb_scores.png\")","218972b6":"Image(\"..\/input\/pictures\/comparison_gross_earnings.png\")","e3534f17":"Image(\"..\/input\/pictures\/comparison_fb_likes.png\")","5bbf047f":"Image(\"..\/input\/pictures\/distribution_of_gross_earnings.png\")","b499eda8":"Image(\"..\/input\/pictures\/heatmap.png\")","7bb4514f":"data = pd.read_csv(\"..\/input\/gdschackathon\/GDSChackathon.csv\")","f9d0f21c":"data.columns","19589cd6":"data.shape","ea65c604":"data.info()","b12aae2f":"data.head()","5e385085":"data.tail()","dfcb28dd":"def input_as_positive_int(prompt):\n    \"\"\"\n    this function checks input and converts it's to integer if it is higher than zero.\n    parameter: prompt\n    return: positive integer or error message\n    \"\"\"\n    while True:\n        try:\n            number = int(input(prompt))\n            if  number > 0:\n                return number\n            else:\n                print(\"\\nInvalid input! Please try again.\")\n        except:\n            print(\"\\nInvalid input! Please try again.\")","77b92852":"while True:\n    \n    print(\"\\nPlease select one of the following options:\\n-------------------------------------------\\n\\n\\t1. Most successful directors or actors \\n\\t2. Film comparison \\n\\t3. Analyse the distribution of gross earnings  \\n\\t4. Genre Analysis \\n\\t5. Earnings and IMDB scores \\n\\t6. Exit\")\n    option = input_as_positive_int(\"\\n---> \")\n    \n    if option == 1:\n\n        # MENU OPTION 1 - MOST SUCCESSFUL DIRECTORS OR ACTORS\n\n        print(\"\\ni. Top Directors\\nii. Top Actors\")\n        selection = input_as_positive_int(\"\\n---> \")\n\n        if selection == 1:\n\n            # ---------------------------------------------------------- #\n            # ----- DROPPING NULL VALUES IN \"director_name\" COLUMN ----- #\n            # ---------------------------------------------------------- #\n            data.dropna(subset=[\"director_name\"],inplace=True) # Delete rows if \"director_name\" is null.\n\n            # ---------------------------------------------------------- #\n            # ----- FILLING NULL VALUES WITH \"0\" IN \"gross\" COLUMN ----- #\n            # ---------------------------------------------------------- #\n            data.gross.fillna(float(0), inplace=True)\n\n            print(\"\\nPlease enter an integer value specifying the number of directors you want to return.\")\n            count = input_as_positive_int(\"The number of directors: \")\n\n            # Take \"director_name\" and \"gross\" columns and create new DataFrame.\n            sliced_data = data[[\"director_name\", \"gross\"]]\n\n            # Sort that DataFrame according to \"gross\" values. Reset indexes.\n            sorted_and_sliced_data = sliced_data.sort_values([\"gross\"], ascending=False).reset_index(drop=True) \n\n            top_directors = [] # Top Directors list\n            gross = [] # Gross film earnings list\n\n            length = len(sorted_and_sliced_data) # Number of rows in the DataFrame \n            j = 0 # to control the number of directors \n            for i in range(length):\n                if sorted_and_sliced_data[\"director_name\"][i] not in top_directors:\n                    top_directors.append(sorted_and_sliced_data[\"director_name\"][i])\n                    gross.append(sorted_and_sliced_data[\"gross\"][i])\n                    j += 1\n                    if j == count:\n                        break\n\n            # ---------------------------- #\n            # ----- PLOTTING RESULTS ----- #\n            # ---------------------------- #\n\n            fig, ax = plt.subplots(figsize=(15, 8))\n            ax.barh(top_directors, gross, 0.3, align=\"center\", color='black')\n            ax.set_yticklabels(top_directors, fontstyle=\"italic\", fontsize=18)\n            ax.invert_yaxis()  # labels read top-to-bottom\n            for i, v in enumerate(gross):\n                ax.text(v+0.50,i-0.20, str(v), color=\"red\", fontsize=14, ha=\"right\", va=\"baseline\", weight=600)\n            ax.grid(which='major', axis='x', linestyle='-')\n            ax.set_axisbelow(True)\n            ax.set_xlabel(\"Gross film earnings\", fontsize=16, ha='center')\n            ax.text(0, 1.2, \"Top Directors\", transform=ax.transAxes, size=24, weight=600, ha='left')\n            plt.setp(ax.get_xticklabels(), visible=False)\n            plt.box(False)\n            plt.show()\n\n        if selection == 2:\n\n            # ---------------------------------------------------------- #\n            # ----- DROPPING NULL VALUES IN \"actor_1_name\" COLUMN ----- #\n            # ---------------------------------------------------------- #\n            data.dropna(subset=[\"actor_1_name\"],inplace=True)\n\n            print(\"\\nPlease enter an integer value specifying the number of actors you want to return.\")\n            count = input_as_positive_int(\"The number of actors: \")\n\n            # Take \"actor_1_name\" and \"gross\" columns and create new DataFrame.\n            sliced_data = data[[\"actor_1_name\", \"gross\"]]\n\n            # Sort that DataFrame according to \"gross\" values. Reset indexes.\n            sorted_and_sliced_data = sliced_data.sort_values([\"gross\"], ascending=False).reset_index(drop=True) \n\n            top_actors = [] # Top Actors list\n            gross = [] # Gross film earnings list\n\n            length = len(sorted_and_sliced_data) # Number of rows in the DataFrame \n            j = 0 # to control the number of actors \n            for i in range(length):\n                if sorted_and_sliced_data[\"actor_1_name\"][i] not in top_actors:\n                    top_actors.append(sorted_and_sliced_data[\"actor_1_name\"][i])\n                    gross.append(sorted_and_sliced_data[\"gross\"][i])\n                    j += 1\n                    if j == count:\n                        break\n\n            # ---------------------------- #\n            # ----- PLOTTING RESULTS ----- #\n            # ---------------------------- #\n\n            fig, ax = plt.subplots(figsize=(15, 8))\n            ax.barh(top_actors, gross, 0.3, align=\"center\", color='black')\n            ax.set_yticklabels(top_actors, fontstyle=\"italic\", fontsize=18)\n            ax.invert_yaxis()  # labels read top-to-bottom\n            for i, v in enumerate(gross):\n                ax.text(v+0.50,i-0.20, str(v), color=\"red\", fontsize=14, ha=\"right\", va=\"baseline\", weight=600)\n            ax.grid(which='major', axis='x', linestyle='-')\n            ax.set_axisbelow(True)\n            ax.set_xlabel(\"Gross film earnings\", fontsize=16, ha='center')\n            ax.text(0, 1.2, \"Top Actors\", transform=ax.transAxes, size=24, weight=600, ha='left')\n            plt.setp(ax.get_xticklabels(), visible=False)\n            plt.box(False)\n            plt.show()\n\n    elif option == 2:\n\n        # MENU OPTION 2 - FILM COMPARISON\n\n        data.dropna(subset=[\"gross\"],inplace=True)\n\n        while True:\n            while True:\n                print(\"\\nPlease enter the name of first film: \")\n                movie_1 = input(\"(1): \")\n                if data.movie_title.isin([movie_1 + \"\\xa0\"]).any() == True:\n                    break\n                else:\n                    print(\"\\nThe movie name which you entered could not find in the dataset. Please try again.\")\n            while True:\n                print(\"\\nPlease enter the name of second film: \")\n                movie_2 = input(\"(2): \")\n                if data.movie_title.isin([movie_2 + \"\\xa0\"]).any() == True:\n                    break\n                else:\n                    (\"\\nThe movie name which you entered could not find in the dataset. Please try again.\")\n            if movie_1 != movie_2:\n                break\n            else:\n                print(\"\\nPlease check the movie names. You have entered same name for both first film and second film.\")\n\n        while True:  \n            print(\"\\nSelect the comparison parameter:\\n--------------------------------\\n\\n\\ti. IMDB Scores\\n\\tii. Gross Earning\\n\\tiii. Movie Facebook Like\")        \n            selection = input_as_positive_int(\"\\n---> \")\n\n            if selection == 1:\n\n                # Getting imdb_score values\n                imdb_score_1 = data[\"imdb_score\"][data[data['movie_title']== movie_1 + '\\xa0'].index.values.astype(int)[0]]\n                imdb_score_2 = data[\"imdb_score\"][data[data['movie_title']== movie_2 + '\\xa0'].index.values.astype(int)[0]]\n\n                # PLOTTING RESULTS \n                objects = (movie_1, movie_2)\n                y_pos = np.arange(len(objects))\n                results = [imdb_score_1, imdb_score_2]\n                plt.figure(figsize=(12,8))\n                plot = plt.bar(y_pos, results, align=\"center\", alpha=0.5)\n                for value in plot:\n                    height = value.get_height()\n                    plt.text(value.get_x() + value.get_width()\/2., 1.002*height, height, ha='center', va='bottom')\n                plt.xticks(y_pos, objects)\n                plt.ylabel(\"Imdb Score\")\n                plt.title(\"Comparison of \" + movie_1 + \" and \" + movie_2 + \" according to IMDB scores\")\n                plt.show()\n                break\n\n            elif selection == 2:\n\n                # Getting gross earning values\n                gross_1 = data[\"gross\"][data[data['movie_title']== movie_1 + '\\xa0'].index.values.astype(int)[0]]\n                gross_2 = data[\"gross\"][data[data['movie_title']== movie_2 + '\\xa0'].index.values.astype(int)[0]]\n\n                # PLOTTING RESULTS \n                objects = (movie_1, movie_2)\n                y_pos = np.arange(len(objects))\n                results = [gross_1, gross_2]\n                plt.figure(figsize=(12,8))\n                plot = plt.bar(y_pos, results, align=\"center\", alpha=0.5)\n                for value in plot:\n                    height = value.get_height()\n                    plt.text(value.get_x() + value.get_width()\/2., 1.002*height, height, ha='center', va='bottom')\n                plt.xticks(y_pos, objects)\n                plt.ylabel(\"Gross Earning\")\n                plt.title(\"Comparison of \" + movie_1 + \" and \" + movie_2 + \" according to gross earnings\")\n                plt.show()\n                break\n\n            elif selection == 3:\n\n                # Getting movie facebook likes values\n                fb_like_1 = data[\"movie_facebook_likes\"][data[data['movie_title']== movie_1 + '\\xa0'].index.values.astype(int)[0]]\n                fb_like_2 = data[\"movie_facebook_likes\"][data[data['movie_title']== movie_2 + '\\xa0'].index.values.astype(int)[0]]\n\n                # PLOTTING RESULTS \n                objects = (movie_1, movie_2)\n                y_pos = np.arange(len(objects))\n                results = [fb_like_1, fb_like_2]\n                plt.figure(figsize=(12,8))\n                plot = plt.bar(y_pos, results, align=\"center\", alpha=0.5)\n                for value in plot:\n                    height = value.get_height()\n                    plt.text(value.get_x() + value.get_width()\/2., 1.002*height, height, ha='center', va='bottom')\n                plt.xticks(y_pos, objects)\n                plt.ylabel(\"Movie Facebook Like\")\n                plt.title(\"Comparison of \" + movie_1 + \" and \" + movie_2 + \" according to movie facebook likes\")\n                plt.show()\n                break\n\n            else:\n\n                print(\"Invalid input! Please try again.\")\n\n    elif option == 3:\n\n        # MENU OPTION 3 - ANALYSE THE DISTRIBUTION OF GROSS EARNINGS\n\n        data.dropna(subset=[\"gross\"],inplace=True)\n\n        maximum_year = int(data.title_year.max())\n        minimum_year = int(data.title_year.min())\n\n        while True:    \n            print(\"\\nSelect the start year: \")\n            start_year = input_as_positive_int(\"-->\")\n            if (start_year <= maximum_year) and (minimum_year <= start_year):\n                break\n            else:\n                print(\"Invalid input! This data set includes films that made between 1927 and 2016. Please try again.\")\n\n\n        while True:\n            print(\"\\nSelect the end year: \")\n            end_year = input_as_positive_int(\"-->\")\n            if (end_year <= maximum_year) and (minimum_year <= end_year):\n                break\n            else:\n                print(\"Invalid input! This data set includes films that made between 1916 and 2016. Please try again.\")\n\n        # Take \"movie_title\" and \"imdb_score\" columns and create new DataFrame.\n        sliced_data = data[[\"title_year\", \"gross\"]]\n\n        result = [] # list of [year, min_gross, max_gross, average_gross]\n        year = []\n        for i in range(start_year ,end_year + 1):\n            mask = (sliced_data[\"title_year\"] == i)\n            filtered = sliced_data.loc[mask]\n            result.append([i, int(filtered.gross.min()), int(filtered.gross.max()), int(filtered.gross.mean())])\n            year.append(i)\n        result = pd.DataFrame(result, columns = [\"year\", \"min_gross\", \"max_gross\", \"mean_gross\"])      \n\n        min_y = int(data.gross.min())\n        max_y = int(data.gross.max())\n        # PLOTTING RESULTS \n        plt.figure(figsize=(15,8))\n        plt.yticks(np.arange(min_y, max_y, 100000000))\n        plt.xticks(np.arange(start_year, end_year+1, 1), rotation=90)\n        plt.plot(\"year\", \"min_gross\", data=result, marker='o', color='skyblue', linewidth=2, label=\"Minimum gross earnings\")\n        plt.plot(\"year\", \"max_gross\", data=result, marker='o', color='lightgreen', linewidth=2, label=\"Maximum gross earnings\")\n        plt.plot(\"year\", \"mean_gross\", data=result, marker='o', color='hotpink', linewidth=2, label=\"Average gross earnings\")\n        plt.title(\"THE DISTRIBUTION OF GROSS EARNINGS\"+ \"(\" + str(start_year) + \"-\" + str(end_year) + \")\")\n        plt.legend()\n        plt.show()\n\n    elif option == 4:\n\n        # MENU OPTION 4 - GENRE ANALYSIS\n        data.dropna(subset=[\"movie_title\"],inplace=True)\n        data.dropna(subset=[\"genres\"],inplace=True)\n        data.dropna(subset=[\"imdb_score\"],inplace=True)\n        data.reset_index()\n        \n        genres = [] \n        for i in range(data[\"genres\"].size):\n            for j in range(len(data[\"genres\"].str.split(\"|\")[i])):\n                if data[\"genres\"].str.split(\"|\")[i][j] not in genres:\n                    genres.append(data[\"genres\"].str.split(\"|\")[i][j])\n\n        print(\"GENRES: \")\n        print(\"-------\")\n        print(\"\\n\")\n        for i in genres:\n            print(i)\n\n        print(\"\\nEnter a genre to see mean IMDB score of all films within that genre:\")\n        genre = input(\"-->\")\n\n        sliced_data = data[[\"movie_title\", \"genres\", \"imdb_score\"]]\n        mask = (sliced_data.genres.str.contains(genre) == True)\n        filtered = sliced_data.loc[mask][[\"movie_title\", \"imdb_score\"]]\n        print(\"\\nThe mean IMDB score of all films within \" + genre + \" genre is\", round(filtered[\"imdb_score\"].mean(), 1))\n\n    elif option == 5:\n\n        # MENU OPTION 5 - EARNINGS AND IMDB SCORES\n\n        data.dropna(inplace=True)\n        print(data.corr()[\"imdb_score\"])\n        f,ax = plt.subplots(figsize = (20,20))\n        sns.heatmap(data.corr(),annot = True, linewidths = 0.5, fmt = \".1f\", ax = ax, cmap = \"Blues\")\n        plt.show()\n        sns.heatmap(data[[\"imdb_score\", \"gross\"]].corr(),annot = True, linewidths = 0.5, fmt = \".1f\", ax = ax, cmap = \"Blues\")\n        plt.show()\n\n    elif option == 6:\n\n        # MENU OPTION 6 - EXIT\n\n        break\n    \n    else:\n        print(\"\\nInvalid input! Please try again.\")","c75c926c":"**PROJECT SPECIFICATION:**\n------------\n\nThe objective of this project is to produce an application and report that allows the user to explore some of the most interesting aspects of IMDB dataset.","b1dd911e":"**1- A Graphical Representation of the Most Successful Directors and Actors**\n\nIn this option, director_name, actor_1_name and gross columns of dataset are used. \n\nWith the selection of Option  1, a selection menu with the options \"Top Directors\" and \"Top Actors\" opens. The user must enter 1 for listing top directors and 2 for listing top actors. The entered number is controlled with input_as_positive_int function. \n\nIn both options, the same\/similar operations were performed on the dataset to achieve the result.\n\nThe first step is dropping or replacing missing values with usage of Pandas's \"dropna\" or \"fillna\" method. Dropping is suitable for director_name and actor_1_name columns, but not for gross column. Thus, with the \"dropna\" command, the missing data in the director_name and actor_name_1 columns are deleted. With \"fillna\" command, the missing data in the gross column is filled with \"0\". \n\nAfter cleaning data, a new data frame(sorted_and_sliced_data) is created with director_name and gross columns or actor_name_1 and gross columns. After that data frame is sorted according to \"gross\" values and the indexes are reset. \n\nNumber of director names or actor names to be displayed is taked by user input. The entered number is controlled with input_as_positive_int function.\n\nThe number of data entered by the user is read from the data frame and kept in the created lists(top_actors, top_directors, gross).\n\nFinally, using top_directors\/top_actors and gross lists, the results are represented by a horizontal bar graph.\n\nExamples:","58ecca99":"**5- Relationship Between the IMDB Column and the Other Features**","dcff322a":"The above heatmap shows the correlation between all numerical data in dataset. ","e4bbd14d":"**2- Comparison of Two Films**\n\nIn this option, movie_title, imdb_scores, gross and movie_facebook_likes columns of dataset are used. \n\nWith the selection of Option  2, a selection menu with the options \"IMDB Scores\", \"Gross Earnings\" and \"Movie Facebook Like\" opens. The user must enter 1 for comparison by IMDB scores, 2 for comparison by gross earnings and 3 for comparison by movie Facebook likes. The entered number is controlled with input_as_positive_int function. \n\nIn both options, the same\/similar operations were performed on the dataset to achieve the result.\n\nThere are any missing values in movie_title, imdb_scores and movie_facebook_likes columns. Thus, with \"dropna\" command, the missing data in the gross column are deleted. \n\nAfter cleaning data step, it is checked whether the movie names entered by the user are in the dataset and whether the two movie names are different.\n\nIMDB scores\/Gross earnings\/Movie Facebook likes in the rows that match the movie names entered by the user are found, and they are assigned to a variable. \n\nFinally, these variables are represented by a bar plot.\n\nExamples:","bfd1df2e":"This project aims to make the user make certain choices from a menu and to discover the dataset according to the possible choices. The menu will be like that:\n\n    Please select one of the following options: \n\t1. Most successful directors or actors \n\t2. Film comparison \n\t3. Analyse the distribution of gross earnings  \n\t4. Genre Analysis \n\t5. Earnings and IMDB scores \n\t6. Exit\n\nThus, the data cleaning process does not need to be applied to all columns. The NaN values are rendering meaningless this project. Thus, dropping would not be a bad solution for this problem in that situation.","3002f596":"Correlation between IMDB scores and other numerical data:\n\n    num_critic_for_reviews       0.347886\n\n    duration                     0.366221\n\n    director_facebook_likes      0.192314\n\n    actor_3_facebook_likes       0.065544\n\n    actor_1_facebook_likes       0.093597\n\n    gross                        0.214740\n\n    num_voted_users              0.482430\n\n    cast_total_facebook_likes    0.106803\n\n    facenumber_in_poster        -0.065493\n\n    num_user_for_reviews         0.325003\n\n    budget                       0.029190\n\n    title_year                  -0.134982\n\n    actor_2_facebook_likes       0.102372\n\n    aspect_ratio                 0.029979\n\n    movie_facebook_likes         0.281155\n","5cfc8150":"**4- Calculation of the average IMDB score of all films of a specific genre entered by the user**\n\nIn this option, imdb_score, movie_title and genres columns are used.\n\nThe first step is dropping missing values with usage of Pandas's \"dropna\" method. With the \"dropna\" command, the missing data in the movie_title and genres and imdb_score columns are deleted. \n\nAfter that, all unique genres in the dataset are listed with a for loop. The user may choose an genre from that list and then program gives an output which includes the mean IMDB score of all films within that genre. \n\nAn example of output:\n\nGENRES:\n\nAction\n\nAdventure\n\nFantasy\n\nSci-Fi\n\nThriller\n\nDocumentary\n\nRomance\n\nAnimation\n\nComedy\n\nFamily\n\nMusical\n\nMystery\n\nWestern\n\nDrama\n\nHistory\n\nSport\n\nCrime\n\nHorror\n\nWar\n\nBiography\n\nMusic\n\nGame-Show\n\nReality-TV\n\nNews\n\nShort\n\nFilm-Noir\n\nEnter a genre to see mean IMDB score of all films within that genre:\n\n-->Horror\n\nThe mean IMDB score of all films within Horror genre is 5.8","a1c22c8e":"**DESCRIPTIONS OF OPTIONS**","63105925":"**ABSTRACT**\n-------------------\n\nThis project is to produce the desired output as a result of some operations on the data set in line with the choices made by the user from the drop-down menu.\n\n**MAIN MENU OPTIONS:**\n\n**Option 1 -** A graphical representation of the most successful directors and actors \n\n**Option 2 -** Comparison of two films according to their IMDB scores, gross earnings and movie Facebook likes\n\n**Option 3 -** Graphical representation of minimum gross earnings, maximum gross earnings, and average gross earnings for each year between specific years\n\n**Option 4 -** Calculation of the average IMDB score of all films of a specific genre entered by the user\n\n**Option 5 -** Generating graphs that will best help illustrate the relationship or lack of relationship between the IMDB column and the other features\n\n**Option 6 -** Exit\n\nThe user must enter 1,2,3,4,5 or 6 for selection. If the user selects an option 1-5 then program display the associated output and will subsequently display the main menu again. If the user selects option 6 the application exit. The entered number is controlled with input_as_positive_int function. A detailed description is made in the cell where this function is located.","8af25ebc":"**3- Graphical representation of some descriptive statistics of gross earnings for each year between specific years (minimum, maximum, and average)**\n\nIn this option, gross and title_year columns of dataset are used. \n\nUser entered start and end years are controlled with input_as_positive_int() function.\n\nA new data frame(result) is created with minimum, maximum, average gross earnings and years between user entered start year and end year. Minimum, maximum and average gross earnings are obtained with Pandas's min(), max() and mean() methods.\n\nFinally, the \"result\" data frame is represented with a bar graph. This bar graph shows the minimum, maximum, and average gross earnings of each year between the start and end years.\n\nExample:","7d6628dc":"**DATA OVERVIEW:**\n------------\n\nThe IMDB movie dataset hosted by Kaggle contains the details of over 5043 movies scraped from IMDB movie website. The dataset attempted to collect 28 features describing each movie."}}