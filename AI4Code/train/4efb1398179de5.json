{"cell_type":{"e5d4f435":"code","133105e2":"code","c7cd92fc":"code","65dae933":"code","7fea0310":"code","77e41a98":"code","a8cd4324":"code","71825750":"code","a434f35f":"code","f571a43f":"code","d5bc124d":"code","ffaa6df3":"code","bef16014":"code","fb51588f":"code","df57a812":"code","82366795":"code","12784cff":"code","09e765ef":"code","e892477e":"code","0f2447bf":"code","c2c78377":"code","3dc6f36f":"markdown","73e65dd2":"markdown","96e093da":"markdown","ec0bf952":"markdown","6fb6a849":"markdown","c06db4b0":"markdown"},"source":{"e5d4f435":"import math\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport gc\n\nimport lightgbm as lgb\n\nfrom scipy.stats import uniform\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split, RandomizedSearchCV, cross_val_score, KFold\nfrom sklearn import metrics\nfrom sklearn.metrics import roc_auc_score, plot_roc_curve","133105e2":"INT8_MIN = np.iinfo(np.int8).min\nINT8_MAX = np.iinfo(np.int8).max\nINT16_MIN = np.iinfo(np.int16).min\nINT16_MAX = np.iinfo(np.int16).max\nINT32_MIN = np.iinfo(np.int32).min\nINT32_MAX = np.iinfo(np.int32).max\n\nFLOAT16_MIN = np.finfo(np.float16).min\nFLOAT16_MAX = np.finfo(np.float16).max\nFLOAT32_MIN = np.finfo(np.float32).min\nFLOAT32_MAX = np.finfo(np.float32).max\n\n\ndef memory_usage(data, detail = 1):\n    if detail:\n        display(data.memory_usage())\n    memory = data.memory_usage().sum() \/ (1024 * 1024)\n    print('Memory usage : {0:.2f}MB'.format(memory))\n    return memory\n\n\ndef compress_dataset(data):\n    memory_before_compress = memory_usage(data, 0)\n    print()\n    print('=' * 50)\n    for col in data.columns:\n        col_dtype = data[col][:100].dtype\n\n        if col_dtype != 'object':\n            print('Name: {0:24s} Type: {1}'.format(col, col_dtype))\n            col_series = data[col]\n            col_min = col_series.min()\n            col_max = col_series.max()\n\n            if col_dtype == 'float64':\n                print(' variable min: {0:15s} max: {1:15s}'.format(str(np.round(col_min, 4)), str(np.round(col_max, 4))))\n                if (col_min > FLOAT16_MIN) and (col_max < FLOAT16_MAX):\n                    data[col] = data[col].astype(np.float16)\n                    print('  float16 min: {0:15s} max: {1:15s}'.format(str(FLOAT16_MIN), str(FLOAT16_MAX)))\n                    print('compress float64 --> float16')\n                elif (col_min > FLOAT32_MIN) and (col_max < FLOAT32_MAX):\n                    data[col] = data[col].astype(np.float32)\n                    print('  float32 min: {0:15s} max: {1:15s}'.format(str(FLOAT32_MIN), str(FLOAT32_MAX)))\n                    print('compress float64 --> float32')\n                else:\n                    pass\n                memory_after_compress = memory_usage(data, 0)\n                print('Compress Rate: [{0:.2%}]'.format((memory_before_compress-memory_after_compress) \/ memory_before_compress))\n                print('=' * 50)\n\n            if col_dtype == 'int64':\n                print(' variable min: {0:15s} max: {1:15s}'.format(str(col_min), str(col_max)))\n                type_flag = 64\n                if (col_min > INT8_MIN \/ 2) and (col_max < INT8_MAX \/ 2):\n                    type_flag = 8\n                    data[col] = data[col].astype(np.int8)\n                    print('     int8 min: {0:15s} max: {1:15s}'.format(str(INT8_MIN), str(INT8_MAX)))\n                elif (col_min > INT16_MIN) and (col_max < INT16_MAX):\n                    type_flag = 16\n                    data[col] = data[col].astype(np.int16)\n                    print('    int16 min: {0:15s} max: {1:15s}'.format(str(INT16_MIN), str(INT16_MAX)))\n                elif (col_min > INT32_MIN) and (col_max < INT32_MAX):\n                    type_flag = 32\n                    data[col] = data[col].astype(np.int32)\n                    print('    int32 min: {0:15s} max: {1:15s}'.format(str(INT32_MIN), str(INT32_MAX)))\n                    type_flag = 1\n                else:\n                    pass\n                memory_after_compress = memory_usage(data, 0)\n                print('Compress Rate: [{0:.2%}]'.format((memory_before_compress-memory_after_compress) \/ memory_before_compress))\n                if type_flag == 32:\n                    print('compress (int64) ==> (int32)')\n                elif type_flag == 16:\n                    print('compress (int64) ==> (int16)')\n                else:\n                    print('compress (int64) ==> (int8)')\n                print('=' * 50)\n\n    print()\n    memory_after_compress = memory_usage(data, 0)\n    print('Compress Rate: [{0:.2%}]'.format((memory_before_compress-memory_after_compress) \/ memory_before_compress))\n    \n    return data","c7cd92fc":"df_train = pd.read_csv('..\/input\/preparing-datasets\/train_prepared.csv')\ndf_train.head()","65dae933":"df_train = df_train.drop('Unnamed: 0', axis = 1)","7fea0310":"df_train.info()","77e41a98":"df_test = pd.read_csv('..\/input\/preparing-datasets\/test_prepared.csv')\ndf_test.head()","a8cd4324":"df_test = df_test.drop('Unnamed: 0', axis = 1)","71825750":"df_test.info()","a434f35f":"df_train = compress_dataset(df_train)","f571a43f":"df_test = compress_dataset(df_test)","d5bc124d":"feats = df_test.columns\n\nX = df_train[feats]\ny = df_train['target']","ffaa6df3":"X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = 0.3, \n                                                                random_state = 10, stratify = y)","bef16014":"%%time\n\nfit_params = dict(early_stopping_rounds = 200, eval_set = [(X_train, y_train), (X_validation, y_validation)], \n                  eval_metric = 'auc', verbose = 200)\n\nrs_params = dict(learning_rate = uniform(loc = 0.05, scale = 0.25), reg_lambda = [0, 20, 40, 60],\n                 n_estimators = [5000], max_depth = [5, 7, 10, 15], subsample = [0.6, 0.7, 0.8, 0.9],\n                colsample_bytree = [0.6, 0.7, 0.8, 0.9], reg_alpha = [0, 20, 40, 60])\n\n\nlgb = lgb.LGBMClassifier(random_state = 25, device = 'gpu')\nrs_lgb = RandomizedSearchCV(estimator = lgb, param_distributions = rs_params, scoring = 'roc_auc', \n                            cv = 5, n_iter = 8, random_state = 34)\nrs_lgb.fit(X_train, y_train, **fit_params)\npreds = rs_lgb.predict_proba(X_validation)[:, -1]","fb51588f":"rs_lgb.best_params_","df57a812":"model = rs_lgb.best_estimator_\nmodel","82366795":"plot_roc_curve(model, X_validation, y_validation)\nplt.plot([0, 1], '--y')\nplt.grid()","12784cff":"def check_model(model, n_splits = 3):\n    \n    scores= []\n    cv = KFold(n_splits = n_splits, shuffle = True)\n    \n    for train_idx, test_idx in cv.split(X):\n        X_train, y_train = X.iloc[train_idx], y.iloc[train_idx]\n        X_test, y_test = X.iloc[test_idx], y.iloc[test_idx]\n        model.fit(X_train, y_train, early_stopping_rounds = 200, verbose = 200, \n                  eval_set = [(X_train, y_train), (X_test, y_test)], eval_metric = 'auc')\n        preds = model.predict_proba(X_test)[:, -1]\n        score = roc_auc_score(y_test, preds)\n        scores.append(score)\n        \n    print('************************************')    \n    print(f'Mean AUCROC score:       {np.mean(scores)}')\n    print(f'Std AUCROC:              {np.std(scores)}')","09e765ef":"%%time\n\ncheck_model(model)","e892477e":"preds = model.predict_proba(df_test)[:, -1]","0f2447bf":"sub = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/sample_submission.csv')\nsub['target'] = preds\nsub.head()","c2c78377":"sub.to_csv('lgbm_0,856182.csv', index = False)","3dc6f36f":"## Submission","73e65dd2":"**Click to check my notebook and see how I prepared datasets ;)** \nhttps:\/\/www.kaggle.com\/christoforum\/preparing-datasets\/notebook","96e093da":"## Loading libraries","ec0bf952":"## LightGBM + RandomizedSearchCV","6fb6a849":"## Loading previously prepared datasets","c06db4b0":"## Releasing memory"}}