{"cell_type":{"a1cc58ef":"code","f86784f8":"code","67a047cf":"code","b82a60cd":"code","a78c646f":"code","fbed589c":"code","aacf5782":"code","87b90b5b":"code","f74f393a":"code","c950762d":"markdown","fe841f16":"markdown","7e318cbb":"markdown","652a2b42":"markdown","9bec4461":"markdown","b3bd373e":"markdown","e961cc44":"markdown","92a22a01":"markdown","6af4298d":"markdown","9c7e355d":"markdown","7cb9c865":"markdown","9bb521fa":"markdown","a97e0365":"markdown"},"source":{"a1cc58ef":"!pip install onnx\n#!pip install onnx_tf\n!pip install git+https:\/\/github.com\/onnx\/onnx-tensorflow\n\n'''\nThe onnx github is not very reliable about which version to use they switch between 1.X and 2.X throughout \nbut this was the most stable tf version and only works with the master branch of ONNX's GitHub\n'''\n!pip install tensorflow==2.2.0","f86784f8":"import io\nimport numpy as np\n\nfrom torch import nn\nimport torch.utils.model_zoo as model_zoo\nimport torch.onnx\n\nimport torch.nn as nn\nimport torch.nn.init as init\n\nimport tensorflow as tf\nimport onnx \nfrom onnx_tf.backend import prepare\n\nimport os\nimport warnings","67a047cf":"# Super Resolution model definition in PyTorch\nclass SuperResolutionNet(nn.Module):\n    def __init__(self, upscale_factor, inplace=False):\n        super(SuperResolutionNet, self).__init__()\n\n        self.relu = nn.ReLU(inplace=inplace)\n        self.conv1 = nn.Conv2d(1, 64, (5, 5), (1, 1), (2, 2))\n        self.conv2 = nn.Conv2d(64, 64, (3, 3), (1, 1), (1, 1))\n        self.conv3 = nn.Conv2d(64, 32, (3, 3), (1, 1), (1, 1))\n        self.conv4 = nn.Conv2d(32, upscale_factor ** 2, (3, 3), (1, 1), (1, 1))\n        self.pixel_shuffle = nn.PixelShuffle(upscale_factor)\n\n        self._initialize_weights()\n\n    def forward(self, x):\n        x = self.relu(self.conv1(x))\n        x = self.relu(self.conv2(x))\n        x = self.relu(self.conv3(x))\n        x = self.pixel_shuffle(self.conv4(x))\n        return x\n\n    def _initialize_weights(self):\n        init.orthogonal_(self.conv1.weight, init.calculate_gain('relu'))\n        init.orthogonal_(self.conv2.weight, init.calculate_gain('relu'))\n        init.orthogonal_(self.conv3.weight, init.calculate_gain('relu'))\n        init.orthogonal_(self.conv4.weight)\n\n# Creates am instance of the super-resolution model by using the above model definition.\ntorch_model = SuperResolutionNet(upscale_factor=3)","b82a60cd":"# Load pretrained model weights\nmodel_url = 'https:\/\/s3.amazonaws.com\/pytorch\/test_data\/export\/superres_epoch100-44c6958e.pth'\nbatch_size = 1    # just a random number\n\n# Initialize model with the pretrained weights\nmap_location = lambda storage, loc: storage\nif torch.cuda.is_available():\n    map_location = None\ntorch_model.load_state_dict(model_zoo.load_url(model_url, map_location=map_location))\n\n# Set the model to inference mode\ntorch_model.eval()","a78c646f":"# Input to the model\nx = torch.randn(batch_size, 1, 224, 224, requires_grad=True)\ntorch_out = torch_model(x)\n\n# Make directory to store outputs\nif not os.path.exists('output'):\n    os.makedirs('output')\n\n# Export the model\ntorch.onnx.export(torch_model,               # model being run\n                  x,                         # model input (or a tuple for multiple inputs)\n                  \".\/output\/super_resolution.onnx\",   # where to save the model (can be a file or file-like object)\n                  export_params=True,        # store the trained parameter weights inside the model file\n                  opset_version=10,          # the ONNX version to export the model to\n                  do_constant_folding=True,  # whether to execute constant folding for optimization\n                  verbose=True,              # Causes the exporter to print out a human-readable representation of the network\n                  input_names = ['input'],   # the model's input names\n                  output_names = ['output'], # the model's output names\n                  dynamic_axes={'input' : {0 : 'batch_size'},    # variable length axes\n                                'output' : {0 : 'batch_size'}})","fbed589c":"# Load the ONNX model\nonnx_model = onnx.load(\".\/output\/super_resolution.onnx\")\n\n# Check that the IR is well formed\nonnx.checker.check_model(onnx_model)\n\n# Print a human readable representation of the graph\nonnx.helper.printable_graph(onnx_model.graph)","aacf5782":"# Check TensorFlow version\nprint(tf.version.VERSION)\n\n# pip installing onnx_tf from its master branch on GitHub per its instructions for TensorFlow versions 2.X or higher\n# !pip install git+https:\/\/github.com\/onnx\/onnx-tensorflow ","87b90b5b":"# Ignore all the warning messages from tensorflow\nwarnings.filterwarnings(\"ignore\")\n\n# Import the ONNX model to Tensorflow\ntf_rep = prepare(onnx_model)\n\n# Export .pb file (\"model.pb\") to a folder titled output\ntf_rep.export_graph(\".\/output\/model.pb\")","f74f393a":"export_dir = '.\/output\/model.pb'\ntensorflow_model = tf.saved_model.load(\n    export_dir, tags=None)\ntensorflow_model","c950762d":"**Step 4: Input to the model and then export it**","fe841f16":"**Step 3: Load model weights, initialize them in the model, and set it to inference mode**","7e318cbb":"**Step 5: Load the exported PyTorch model into ONNX model and output a readable view of the graph**","652a2b42":"**Step 6: Make sure you are using the right TensorFlow (specifically 2.2.0)**\n- From the Onnx GitHub: \"Moreover, we require Tensorflow version == 2.2.0.\"\n- From comments on GitHub: \"pip install of regular onnx_tf right now still gives you the TF 1.x version of onnx-tf. In order to get the TF 2.2 version, you will need to do an install from source using the master branch, https:\/\/github.com\/onnx\/onnx-tensorflow#installation\" \n- This is true and you can see in Step 0 at the top pip installing regular onnx_tf is commented out and there is a pip install from the GitHub's master branch instead.","9bec4461":"**Step 2: Create a Super Resolution model in PyTorch**","b3bd373e":"Resources mainly used for this notebook:\n\nhttps:\/\/pytorch.org\/tutorials\/advanced\/super_resolution_with_onnxruntime.html\nhttps:\/\/github.com\/onnx\/tutorials\/blob\/master\/tutorials\/OnnxTensorflowImport.ipynb","e961cc44":"Test loading in the model.pb file from the output folder","92a22a01":"**Step 0: Install neccessary libraries**","6af4298d":"**Overview:**\n- The goal of this notebook is to show how to convert a model defined using PyTorch into the Open Neural Network Exchange (ONNX) format, and then import it into a TensorFlow model\n- The PyTorch model will be a small Super Resolution Deep Learning model\n  - This type of model is used as a way to increase the resolution of images\/videos and is widely used for image-processing\/video editing\n  - The model comes from a PyTorch example on their website\n  - It is also normally trained using example data, but because this notebook is for testing purposes, it is trained using downloaded pre-trained weights","9c7e355d":"**Step 1: Import Neccessary Modules**","7cb9c865":"**Step 7: Convert\/export the graph (onnx model) into a .pb file so TensorFlow can use it**\n\n","9bb521fa":"The resulting \"super_resolution.onnx\" is a binary protobuf file which contains both the network structure and parameters of the model that was exported (in this case, SuperResolutionNet)","a97e0365":"**Conclusion**\n- Now, tf_rep has been created which is a python class containing four members: graph, inputs, outputs, and tensor_dict\n- tf_rep has also exported to a folder titled \"output\", a .pb file titled \"model.pb\"\n  - A .pb file stands for protobuf and in TensorFlow, the protobuf file contains the graph definition as well as the weights of the model\n- This .pb file is all that is now needed to run this PyTorch defined Super Resolution model in TensorFlow"}}