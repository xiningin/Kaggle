{"cell_type":{"669b0d53":"code","9c97a90c":"code","25b5b4ae":"code","b7101ceb":"code","7c32ea16":"code","a5d3e419":"code","4192efb7":"code","4e8c997f":"code","d4813313":"code","a5c25eca":"code","0ecbbf8f":"markdown","0e72a538":"markdown","cf506918":"markdown","9ad77d0a":"markdown","c2b66ba4":"markdown","f2ec61bf":"markdown"},"source":{"669b0d53":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport random\nimport seaborn as sns\nimport numpy as np\nimport pandas as pd\nfrom numpy.random import default_rng\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9c97a90c":"card = np.zeros((5, 5))\ncard[2,2] = 1 # Freebie\ncard","25b5b4ae":"def check_card(card, corners=False):\n    rows, cols = card.shape\n    for row in range(rows):\n        if sum(card[row]) == rows:\n            return 1\n    for col in range(cols):\n        if sum(card[:,col]) == cols:\n            return 1\n    if sum(card.diagonal()) == 5:\n        return 1\n    if sum(np.flip(card, 0).diagonal()) == 5:\n        return 1\n    if corners:\n        if card[0,0] == 1 and \\\n        card[rows-1,0] == 1 and \\\n        card[0,cols-1] == 1 and \\\n        card[rows-1,cols-1] == 1:\n            return 1\n    return 0\n\ndef test_check_card():\n    rows, cols = (5, 5)\n    row_bingo = np.zeros((rows,cols))\n    col_bingo = np.zeros((rows,cols))\n\n    for col in range(cols):\n        row_bingo[0,col] = 1\n    for row in range(rows):\n        col_bingo[row,0] = 1\n\n    diag_bingo = np.diag([1, 1, 1, 1, 1])\n    diag_bingo2 = np.flip(diag_bingo, 0)\n\n    rows, cols = (5, 5)\n    corners_bingo = np.zeros((rows,cols))\n    corners_bingo[0,0] = 1\n    corners_bingo[rows-1,0] = 1\n    corners_bingo[0,cols-1] = 1\n    corners_bingo[rows-1,cols-1] = 1\n\n    display(row_bingo, col_bingo, diag_bingo, diag_bingo2, corners_bingo)\n\n    check_card(row_bingo)\n    check_card(col_bingo)\n    check_card(diag_bingo)\n    check_card(diag_bingo2)\n    check_card(corners_bingo, corners=True)","b7101ceb":"''' Generate cards\n\n| A    | B     | C     | D    | E     |\n| 1-15 | 16-30 | 31-45 | 46-60| 61-75 |\n\n'''\ndef gen_card():\n    card = np.zeros((5, 5))\n    card[2,2] = 1 # Freebie\n    A = random.sample(range(1,16),5)\n    B = random.sample(range(17,31),5)\n    C = random.sample(range(32,46),5)\n    D = random.sample(range(47,61),5)\n    E = random.sample(range(62,76),5)\n    card_mapping = np.c_[A,B,C,D,E]\n    return (card, card_mapping)\n\ncard, card_mapping = gen_card()\ndisplay(card)\ndisplay(card_mapping)","7c32ea16":"def play_round(num_of_cards):\n    draw_order = random.sample(range(1,76),75)\n    draw_count = 0\n    bingo = 0\n    cards = []\n    \n    for i in range(num_of_cards):\n        cards.append(gen_card())\n        \n    for draw in draw_order:\n        draw_count += 1\n        \n        for i in range(num_of_cards):\n            \n            if len(np.where(cards[i][1] == draw)[0]) == 1:\n                x = np.where(cards[i][1] == draw)[0][0]\n                y = np.where(cards[i][1] == draw)[1][0]\n                cards[i][0][x][y] = 1\n                #display(card)\n                #display(card_mapping)\n                if bingo == 0:\n                    bingo = check_card(cards[i][0], corners=False)\n        \n        if bingo == 1:\n            return draw_count\n        \n    return 0\n\nplay_round(num_of_cards = 8)","a5d3e419":"draw_count = pd.DataFrame()\nnum_of_cards = 8\nrounds = 1000\nfor i in range(rounds):\n    draw_count = draw_count.append({\"# of Draws\":play_round(num_of_cards = num_of_cards)}, ignore_index=True)","4192efb7":"sns.histplot(data=draw_count, bins=12)","4e8c997f":"ax = sns.boxplot(data=draw_count)\nax = sns.swarmplot(data=draw_count, color=\".25\")","d4813313":"draw_count.describe()","a5c25eca":"draw_count['count']=1\ndraw_count.groupby('# of Draws').sum()","0ecbbf8f":"![image.png](attachment:698dee99-b6cf-4e75-9d18-2b3c64cb1a25.png)\n","0e72a538":"Bingo features cards that are 5x5 matrices with the center square being a \"free\" space. To replicate it in Python, I used numpy for the framework. A '0' indicates that the square has not been called yet, and a '1' means that it has. \n\nHere is an example of a starting card in numpy:","cf506918":"Using this framework, its straightforward to determine if rows or columns have a bingo since we can just sum the rows and columns. Here are some helper functions for determining if a given card has a bingo or not. At the bar that I play at, some rounds count getting all four corners as a bingo so I included that as an optional parameter.","9ad77d0a":"Next I made a function to generate bingo cards. This maps the numbers of each card to the background numpy array that determines if the number has been called.","c2b66ba4":"Now that we have the game logic defined, we can simulate several rounds to determine the distribution of rounds it takes until there is a bingo called depending on the number of cards on any given round.","f2ec61bf":"Last function holds the games logic. It determines the number draw order at the beginning then generates cards and loops through the draws until there is a bungo. "}}