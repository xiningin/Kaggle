{"cell_type":{"a5ad26b4":"code","caa4cf31":"code","c03f87c3":"code","8a5d3133":"code","ab551b9c":"code","f76817d4":"code","83dfa436":"code","3932c776":"code","b5c2a079":"code","abcd8a47":"code","b00e3096":"code","7a0e368d":"code","20353340":"code","c2d21b1d":"code","b1dcb284":"code","d56ef048":"code","c0a0a7d6":"code","39d95f93":"code","f6c3b118":"code","51c621a2":"code","627f94a3":"code","606b2155":"code","ddb4d908":"markdown","e2fad7a9":"markdown","48d80aea":"markdown","31292cb6":"markdown","b8e4d120":"markdown","2815bab2":"markdown","ba651308":"markdown","74c7b2fb":"markdown","533a97ba":"markdown","eba83867":"markdown","dc348d99":"markdown"},"source":{"a5ad26b4":"import numpy as np # linear algebra\nimport pandas as pd # data processing","caa4cf31":"from keras.datasets import mnist","c03f87c3":"#Loading data from MNIST into train and test categories\n(train_images, train_labels), (test_images, test_labels) = mnist.load_data()","8a5d3133":"train_images.shape","ab551b9c":"#images are stored in 28*28 2D array with values from 0-255 \ntrain_images[1]","f76817d4":"import matplotlib.pyplot as plt\n\ndef plotImageData(img_data, label_data):\n    plt.figure(figsize=(16,16))\n    for index in range(0,16):\n        plt.subplot(4,4,index+1);\n        plt.imshow(img_data[index], cmap='bone')\n        plt.title(label_data[index])\n        plt.plot()\n    plt.suptitle('Training Dataset')\n    plt.show()\n    \nplotImageData(train_images, train_labels)","83dfa436":"from tensorflow import keras\nfrom keras import layers\nnetwork = keras.Sequential([\nlayers.Dense(512, activation='relu', input_shape=(28 * 28,)),\nlayers.Dense(10, activation='softmax')    \n])\n","3932c776":"network.compile(\n    optimizer='rmsprop',\n    loss='categorical_crossentropy',\n    metrics=['accuracy']\n)","b5c2a079":"test_images_copy = test_images\ntest_labels_copy = test_labels","abcd8a47":"train_images = train_images.reshape((60000, 28 * 28))\ntrain_images = train_images.astype('float32') \/ 255\ntest_images = test_images.reshape((10000, 28 * 28))\ntest_images = test_images.astype('float32') \/ 255","b00e3096":"# 2D matrix to 1D vector\ntrain_images.shape","7a0e368d":"from keras.utils import to_categorical\ntrain_labels = to_categorical(train_labels)\ntest_labels = to_categorical(test_labels)","20353340":"#Converting each label to a vector\ntrain_labels[0]","c2d21b1d":"history = network.fit(train_images, train_labels, epochs=5, batch_size=128)","b1dcb284":"test_loss, test_acc = network.evaluate(test_images, test_labels)\nprint(f'Test Accuracy: {test_acc*100: .5f}%')","d56ef048":"import pandas as pd\nhistory_df = pd.DataFrame(history.history)\nhistory_df.loc[:,['loss', 'accuracy']].plot()","c0a0a7d6":"predictions = network.predict(test_images)","39d95f93":"# Getting correctly classified indices in a list\ndef correctPredictionIndices(test_labels, predictions):\n    correctIndices = []\n    for index in range(len(test_labels)):\n        if len(correctIndices)>=16:\n            break\n        if test_labels[index] == predictions[index].argmax(axis=0):\n            correctIndices.append(index)\n    return correctIndices\n\n\ncorrectly_classified_indices = correctPredictionIndices(test_labels_copy, predictions)","f6c3b118":"# Getting incorrectly classified indices in a list\ndef incorrectPredictionIndices(test_labels, predictions):\n    incorrectIndices = []\n    for index in range(len(test_labels)):\n        if len(incorrectIndices)>=16:\n            break\n        if test_labels[index] != predictions[index].argmax(axis=0):\n            incorrectIndices.append(index)\n    return incorrectIndices\n\nincorrectly_classified_indices = incorrectPredictionIndices(test_labels_copy, predictions)","51c621a2":"def plotCorrectPrediction(img_data, label_data, predictions):\n    plt.figure(figsize=(16,16))\n    for index in correctly_classified_indices:\n        plt.subplot(4,4,index+1);\n        plt.imshow(img_data[index], cmap='bone')\n        plt.title(f'Actual: {label_data[index]} Prediction: {predictions[index].argmax(axis=0)}')\n        plt.plot()\n    plt.suptitle('Correctly classified')\n    plt.show()\n    \ndef plotInCorrectPrediction(img_data, label_data, predictions):\n    plt.figure(figsize=(16,16))\n    i=1\n    for index in incorrectly_classified_indices:\n        plt.subplot(4,4,i);\n        i+=1\n        plt.imshow(img_data[index], cmap='inferno')\n        plt.title(f'Actual: {label_data[index]} Prediction: {predictions[index].argmax(axis=0)}')\n        plt.plot()\n    plt.suptitle('Incorrectly classified images')\n    plt.show()","627f94a3":"plotCorrectPrediction(test_images_copy, test_labels_copy, predictions)","606b2155":"  plotInCorrectPrediction(test_images_copy, test_labels_copy, predictions)","ddb4d908":"Let's take a look at how each image is stored","e2fad7a9":"# Model Testing","48d80aea":"Encoding the label values. ","31292cb6":"# Preprocessing Data","b8e4d120":"*We will be using MNIST dataset, mostly used as 'Hello, World!' exercise in Deep Learning *","2815bab2":"# Model Fitting","ba651308":"Building a sequential neural network from Keras","74c7b2fb":"Constructing a 4x4 grid of plots for taking a better look at data","533a97ba":"*We can kind of see why the model classifies them incorrectly.*","eba83867":"# Model Making","dc348d99":"Before passing the data to our model, we need to process it in ways the model can efficietly work on.\nThus we are converting the 28*28 matrix to a single vector and scaling each pixel value from 0-255 to 0-1"}}