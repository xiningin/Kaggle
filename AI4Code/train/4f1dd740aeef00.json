{"cell_type":{"38f87aa4":"code","80ecaae2":"code","4d77228f":"code","ac736c36":"code","9f575744":"code","717545cf":"code","3009579d":"code","00d0ce8a":"code","9fc06d0b":"code","f5ec802f":"code","d6123a38":"code","a9f37420":"code","ce99c86b":"code","e9196eab":"code","03f4a5e7":"code","f82b9c8d":"code","59f95b5e":"code","d7299013":"markdown","9b60f233":"markdown","1bc65e81":"markdown","ef1005b2":"markdown","7cd20c1c":"markdown","f859b65e":"markdown","eb4318c7":"markdown","8264a1e9":"markdown","c33fda2b":"markdown"},"source":{"38f87aa4":"# Load Libraries\nimport os\nimport numpy as np\nimport pandas as pd \nimport cv2\nimport matplotlib.pyplot as plt\nfrom sklearn import svm\nfrom sklearn.decomposition import PCA\nfrom sklearn.metrics import accuracy_score\nfrom keras import layers\nfrom keras.layers import Input, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D\nfrom keras.layers import AveragePooling2D, MaxPooling2D, Dropout, GlobalMaxPooling2D, GlobalAveragePooling2D\nfrom keras.applications import vgg16\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.models import Model\nfrom keras.models import Sequential\n%matplotlib inline","80ecaae2":"# Load images\ndef load_im():\n    input_im, input_label = [], []\n    resize = (224, 224)\n    # Loop in folders\n    for dirname, _, filenames in os.walk('\/kaggle\/input\/pothole-detection-dataset'):\n        for filename in filenames:\n            photo_path = os.path.join(dirname, filename)\n            photo_class = dirname.split('\/')[-1]\n            try:\n                read_im = cv2.imread(photo_path)\n                input_im.append(cv2.resize(read_im, resize))\n                # potholes == 1\n                if photo_class == 'potholes':\n                    input_label.append(1)\n                # normal == 0\n                elif photo_class == 'normal':\n                    input_label.append(0)\n            except:\n                print(photo_path)\n    # return list of images and another list of correponding labels\n    return input_im, input_label\n\ninput_im, input_label = load_im()","4d77228f":"# Checking code: Print photo and class\nindex_set = np.random.choice(len(input_label), size = 5, replace = False)\nfor index in index_set:\n    # show images\n    plt.imshow(input_im[index])\n    plt.show()\n    # show label\n    print(input_label[index])","ac736c36":"# Train\/Test split\ndef train_test_split(test_prop, input_im, input_label):\n    # Random sampling of index\n    test_size = int(np.floor(test_prop * len(input_label)))\n    test_index = np.random.choice(len(input_label), size = test_size, replace = False)\n    # Split\n    train_x, test_x, train_y, test_y = np.delete(input_im, test_index, axis = 0), np.take(input_im, test_index, axis = 0), np.delete(input_label, test_index, axis = 0), np.take(input_label, test_index, axis = 0)\n    # Return train and test sets for both images and labels\n    return train_x, test_x, train_y, test_y, test_index\n\n# 80\/20 split for small data set\ntest_prop = 0.2\ntrain_x, test_x, train_y, test_y, test_index = train_test_split(test_prop, input_im, input_label)","9f575744":"def append_im(input_im, input_label, im_iterator):\n    input_label_n = input_label.copy()\n    input_im_n = input_im.copy()\n    for i in range(len(im_iterator)):\n        im = im_iterator[i]\n        im = im.astype('uint8')\n        im_lbl = [input_label[i]]\n        input_im_n = np.append(input_im_n, im, axis = 0)\n        input_label_n = np.append(input_label_n, im_lbl, axis = 0)\n    return input_im_n, input_label_n","717545cf":"# Flipping\nflip_data_generator = ImageDataGenerator(horizontal_flip = True)\nim_iterator = flip_data_generator.flow(train_x, batch_size = 1, shuffle = False)\ninput_im_n, input_label_n = append_im(train_x, train_y, im_iterator)\n\n# Rotation - 30 deg \n#rotate_data_generartor = ImageDataGenerator(rotation_range = 30)\n#im_iterator = rotate_data_generartor.flow(train_x, batch_size = 1, shuffle = False)\n#input_im_n, input_label_n = append_im(input_im_n, input_label_n, im_iterator)\n\n# Rotation - -30 deg \n#rotate_data_generartor = ImageDataGenerator(rotation_range = 330)\n#im_iterator = rotate_data_generartor.flow(train_x, batch_size = 1, shuffle = False)\n#input_im_n, input_label_n = append_im(input_im_n, input_label_n, im_iterator)","3009579d":"# Reshape\nnx, ny, nz = train_x.shape[1], train_x.shape[2], train_x.shape[3]\ntrain_x_nn, test_x_nn = input_im_n, test_x\ntrain_x = input_im_n.reshape((input_im_n.shape[0], nx * ny * nz)) \/ 255\ntest_x = test_x.reshape((test_x.shape[0], nx * ny * nz)) \/ 255\ntrain_y = input_label_n.reshape((input_label_n.shape[0], 1)) \ntest_y = test_y.reshape((test_y.shape[0], 1)) ","00d0ce8a":"# Dimensionality reduction - Full PCA\nim_pca = PCA()\nim_pca.fit(train_x)\nvariance_explained_list = im_pca.explained_variance_ratio_.cumsum()\nprint(variance_explained_list)","9fc06d0b":"test_x_pca = im_pca.transform(test_x)\ntrain_x_pca = im_pca.transform(train_x)","f5ec802f":"# Support vector machine with PCA\ndef svm_grid_search(C, kernel, train_x, train_y):\n    accuracy_score_list = []\n    \n    for c in C:\n        # Model training\n        svmClassifier = svm.SVC(C = c, kernel = kernel)\n        svmClassifier.fit(train_x, train_y.ravel())\n        # Prediction on test set\n        pred_y = svmClassifier.predict(train_x)\n        # Accuracy\n        accuracy = accuracy_score(train_y, pred_y)\n        accuracy_score_list.append(accuracy)\n        print('Regularization parameters: ', c, 'Accuracy', accuracy)\n    \n    max_accurarcy_id = accuracy_score_list.index(max(accuracy_score_list))\n    return C[max_accurarcy_id] \n\nC, kernel = [0.1 * i for i in range(1, 30)], 'rbf'\nopt_C = svm_grid_search(C, kernel, train_x_pca, train_y)","d6123a38":"# Test set\nsvmClassifier = svm.SVC(C = opt_C, kernel = kernel)\nsvmClassifier.fit(train_x_pca, train_y.ravel())\npred_y = svmClassifier.predict(test_x_pca)\naccuracy = accuracy_score(test_y, pred_y)\nprint(accuracy)","a9f37420":"# Logistic Regression\ndef Logistic():\n    logistic_model = Sequential()\n    logistic_model.add(Dense(1, activation = 'sigmoid'))\n    return logistic_model\n\n# Compile Model\nlogistic_model = Logistic()\nlogistic_model.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy'])","ce99c86b":"# Training Model\nlogistic_model.fit(train_x, train_y, batch_size = 32, epochs = 50, verbose = 1)","e9196eab":"# Test set\nprint(logistic_model.metrics_names)\nprint(logistic_model.evaluate(test_x, test_y, verbose = 0))","03f4a5e7":"# Convolutional Neural Network - Modified from AlexNet\ndef CNN():\n    CNN_model = Sequential()\n    \n    CNN_model.add(Conv2D(filters = 96, input_shape = (224, 224, 3), kernel_size = (11, 11), strides = (4, 4), padding = 'valid'))\n    CNN_model.add(Activation('relu'))\n    CNN_model.add(MaxPooling2D(pool_size = (2, 2), strides = (2, 2), padding = 'valid'))\n    \n    CNN_model.add(Conv2D(filters = 256,  kernel_size = (5, 5), strides = (1, 1), padding = 'valid'))\n    CNN_model.add(Activation('relu'))\n    CNN_model.add(MaxPooling2D(pool_size = (2, 2), strides = (2, 2), padding = 'valid'))\n    \n    CNN_model.add(Flatten())\n    CNN_model.add(Dense(512))\n    CNN_model.add(Activation('relu'))\n    \n    CNN_model.add(Dense(256))\n    CNN_model.add(Activation('relu'))\n    \n    CNN_model.add(Dense(1, activation = 'sigmoid'))\n    \n    return CNN_model\n\n# Compile Model\ncnn_model = CNN()\ncnn_model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy']) \n","f82b9c8d":"# Training Model\ncnn_model.fit(train_x_nn\/255, train_y, batch_size = 256, epochs = 50, verbose = 1)","59f95b5e":"print(cnn_model.metrics_names)\nprint(cnn_model.evaluate(test_x_nn\/255, test_y, verbose = 0))","d7299013":"### Preprocessing\n1. Import data\n2. Label data\n3. Split data","9b60f233":"### Logistic Classifier Performance\n**Test set accuracy: 81.6%**","1bc65e81":"### CNN Performance\n**Test set accuracy: 85.3%**","ef1005b2":"### Image augmentation\nApplied to training set only\n1. Horizontal Flipping\n2. Clockwise and Anti-clockwise Rotation by 30 degree","7cd20c1c":"### SVM with PCA performance\n**Model parameters:**\n\nRegularization parameters = 2.9\n\nKernel = Radial Basis Function\n\n\n**Test set accuracy: 88.2%**","f859b65e":"### Libraries","eb4318c7":"### Summary\n**Test set accuracy: PCA + SVM > CNN > Logistic classifier**\n\nTo improve performance, we can use a pretrained network \/ uncomment the remaining image augmentation (rotation) codes \/ scrape more data on the website.","8264a1e9":"### Machine learning models\n1. Support vector machine (SVM) - PCA-SVM\n2. Logistic regression - Baseline Model\n3. Convolutional neural network (CNN) - Modified from AlexNet","c33fda2b":" ### Dimensionality Reduction\nSince images are of high resolution, input matrix has a high column dimension. So, dimensionality reduction may be useful in this situation. Principal component analysis (PCA) will be employed."}}