{"cell_type":{"723aeb1a":"code","761ce738":"code","6e0b4cd4":"code","7de8625d":"code","f50aaa1d":"code","d93d5770":"code","3941b65f":"code","62ccb85b":"code","76be6a1d":"code","b54cb2cf":"code","8ec545a1":"code","7463d58a":"code","fb89e899":"code","4678ed25":"code","31f3c7c2":"code","bda4da49":"code","369d9069":"code","bf2dc720":"code","452cfc08":"code","9ad361ad":"code","cc2aba60":"code","e6c89140":"code","570f4e9d":"code","2a215832":"code","b8cfe78e":"code","c55a2aa3":"code","6d8423fe":"code","36fc638f":"code","61eb66b6":"code","54660057":"code","16911fa9":"code","883e5302":"code","e2c66370":"code","adc3ba0c":"code","22edab82":"code","17de66a5":"code","4c85a6cd":"code","a6f68fd6":"code","e4e20ea1":"code","0bd40cb9":"code","6bcdeccc":"code","7dfd47ff":"code","75e193eb":"code","b8364329":"code","4d0f387d":"code","15c62c14":"code","027eae18":"code","15afa84e":"code","e7cf604c":"code","2e5fd188":"code","8535e8f1":"code","d4bfc614":"code","d968a746":"code","a974fe3e":"code","5d56b2e6":"code","dbbb1917":"code","35fb2a86":"code","5c4c315d":"code","c57f8921":"code","e8680bcd":"code","f395ebcb":"code","8b1ae39c":"code","02c37f78":"code","65b3f3dc":"code","1b9d8bf7":"code","2781c9a0":"code","71ea3dde":"code","1f4f6840":"code","4fbc28d2":"code","fcd020c1":"code","699a8b1a":"code","5ff65afa":"code","da02ff6b":"code","b498c205":"code","5db76e48":"code","a5b70789":"code","529d20a6":"markdown","f1e36d95":"markdown","5437151e":"markdown","cefa52da":"markdown","1dde68bd":"markdown","13f5ba68":"markdown","af96f11b":"markdown","d90780ed":"markdown","ed5b06c7":"markdown","cf0faf76":"markdown","915daa5c":"markdown","88da898e":"markdown","eb21443e":"markdown","5b7908b0":"markdown","bb101fcb":"markdown","d2d122eb":"markdown","d51290f1":"markdown","182ed653":"markdown","a39c9ed3":"markdown","5c5b95c3":"markdown"},"source":{"723aeb1a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sklearn.preprocessing import Imputer #tool to replace missing value\nimport matplotlib.pyplot as plt #plotting charts\nimport seaborn as sns #plotting good-looking charts\nimport cufflinks as cf #plotting interative charts\nfrom plotly.offline import download_plotlyjs,init_notebook_mode,plot,iplot \ninit_notebook_mode(connected=True) #connect the javescript to the notebook\ncf.go_offline() #allow using cufflinks offline\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","761ce738":"#load data\ndf = pd.read_csv('..\/input\/googleplaystore.csv')\n#display the first 10 records\ndf.head(10)","6e0b4cd4":"#drop off irrelevant columns\ndf = df.drop(columns=['Last Updated', 'Android Ver','Content Rating'])","7de8625d":"#check out the type and counts for each attribute\ndf.info()","f50aaa1d":"#check out the nan value for each attribute\ndf.isna().sum()","d93d5770":"#print the list of column names\ndf.columns.values","3941b65f":"#find out the column with uncertain value \"Varies with device\"\nfor i in range(4,len(df.columns)):\n    print (df.columns.values[i] + \" \" + str(df[df[df.columns.values[i]] == 'Varies with device'][df.columns.values[i]].count()))\n    #print(df[df[df.columns.values[i]] == 'Varies with device'][df.columns.values[i]].count())\n#df[df['Size'] == 'Varies with device'].Size.count()","62ccb85b":"def CleanName(str):\n    \"This function will remove some special symbols from a string\"\n    str = str.replace('- ','')\n    str = str.replace('\u2013 ','')\n    str = str.replace('& ','')\n    str = str.replace(', ','')\n    return str","76be6a1d":"#create a new column with app names without special symbols\ndf['Clean_Name'] = df.App.apply(lambda x:CleanName(x))","b54cb2cf":"#double check if the function works\ndf.iloc[:5,10:11]","8ec545a1":"#create a attribute recording the number of words in an app name excluding special symbols\ndf['Name_Word_Counts'] = df.Clean_Name.str.count(' ')+1","7463d58a":"#double check the attribute 'Name_Word_Counts'\ndf.iloc[:5,10:]","fb89e899":"#create a attribute recording the number of characters in an app's name including special symbols\ndf['Name_Length'] = df[\"App\"].apply(lambda x: len(x))\ndf.iloc[:5,10:] #display attribute 'Name_Length'","4678ed25":"#display the unique values in Category\ndf[\"Category\"].unique()","31f3c7c2":"#Screen the stats for each category\ndf.groupby('Category').describe()","bda4da49":"#remove the outliner within Category of '1.9'\ndf = df[df.Category != '1.9']","369d9069":"#double check the number of records\ndf.shape","bf2dc720":"#display the stats of Rating by Category\ndf.groupby('Category').Rating.describe()","452cfc08":"#fill the missing values of Rating by the mean value of their corresponding app categories\ndf['Rating'] = df.groupby(\"Category\").Rating.transform(lambda x: x.fillna(x.mean()))","9ad361ad":"#Double check if any nan value still exist\ndf.Rating.isna().sum()","cc2aba60":"#double check the number of records\ndf.shape","e6c89140":"#convert attribute 'Reviews' type into integers\ndf[['Reviews']] = df[['Reviews']].astype(int)","570f4e9d":"#display the Reviews's stats and double check the data type\ndf['Reviews'].describe()","2a215832":"def SizeUnit(str):\n    \"This function helps to generate a new attribute which specifies the unit of an app's size\"\n    if str[-1] == 'M':\n        return 'M'\n    elif str[-1] == 'k':\n        return 'k'\n    elif str == 'Varies with device':\n        return 'Varies with device'","b8cfe78e":"#create a new attribute which specifies the unit of the app's sizes\ndf['Size_Unit'] = df.Size.apply(lambda x:SizeUnit(x))","c55a2aa3":"#double check if all situations got considered regarding app's sizes\ndf.Size_Unit.isna().sum()","6d8423fe":"#remove the unit sympol from \"Size\" attribute. Note: Now the uncertain value has been written as 'Varies with devic'\ndf['Size'] = df.Size.apply(lambda x:x[:-1])\ndf.Size.head()","36fc638f":"#replace the uncertain value \"Varies with devic\" by nan\ndf['Size'] = df['Size'].replace('Varies with devic', np.nan)\ndf.head()","61eb66b6":"#check out the number of nan\ndf['Size'].isna().sum()","54660057":"#check out the number of records which have uncertain size, which is consistent with the nan now.\ndf[df['Size_Unit'] == 'Varies with device'].Size_Unit.count()","16911fa9":"#convert the attribute \"Size\" into float type data\ndf[['Size']] = df[['Size']].astype(float)","883e5302":"#check out the stats of app's size by category, pick the optimal stat to replace nan\ndf.groupby('Category').Size.describe()","e2c66370":"#check out the number of records\ndf.shape[0]","adc3ba0c":"#change all value to the same scale. eg. some apps have size value in kb instead of MB\ndf['Size'] = np.where(df['Size_Unit'] == 'k', df['Size']\/1024, df['Size'])","22edab82":"#fill the missing values of Size by the median value of their corresponding app categories\ndf['Size'] = df.groupby(\"Category\").Size.transform(lambda x: x.fillna(x.median()))","17de66a5":"#check out if there's any missing value in attribute 'Size'\ndf.Size.isna().sum()","4c85a6cd":"#check out the stats of size\ndf.Size.describe()","a6f68fd6":"#display the first five rows of records\ndf.head()","e4e20ea1":"#check out number of distict values in attribute 'Intalls'\ndf.Installs.unique()","0bd40cb9":"#Check out the distribution of Installs\ndf.groupby('Installs').App.count()","6bcdeccc":"#create a dictionary to record Installs in ascending order\nINSTALL = {\n    0: '0',1: '0+', 2: '1+',3: '5+',4: '10+', 5: '50+',6: '100+',\n    7: '500+',8: '1,000+', 9: '5,000+',10: '10,000+',11: '50,000+', \n    12: '100,000+',13: '500,000+',14: '1,000,000+',15: '5,000,000+', \n    16: '10,000,000+',17: '50,000,000+',18: '100,000,000+', \n    19: '500,000,000+',20: '1,000,000,000+'\n}","7dfd47ff":"def NumInstalls(str):\n    \"find the key of a specifying value in a dictionary\"\n    for key, value in INSTALL.items():   \n        if value == str:\n            return key","75e193eb":"#create a new attribute to record installs in numerical value\ndf['Installs_Num'] = df.Installs.apply(lambda x:NumInstalls(x))","b8364329":"#check out if there's any nan value in this new attribute 'Installs_Num'\ndf.Installs_Num.isna().sum()","4d0f387d":"#plotting the histogram of installs\n\nfig, ax = plt.subplots(figsize=(12,8))\nax = sns.countplot(x=df['Installs_Num'])\n#plt.xticks(rotation=90)\nbars = INSTALL.values()\ny_pos = np.arange(len(bars))\n\n#rename the xticks with original categorical value\nplt.xticks(y_pos, bars, rotation=90, fontsize='13', horizontalalignment='center') \nplt.title(\"Histogram of Number of APP's Installs\", fontsize = '17')\nplt.ylabel('Frequency',fontsize = '14')\nplt.xlabel('Number of Installs',fontsize = '14')\n\nplt.show()","15c62c14":"#create a list with numerical value in terms of installs for future use\nCum_Count = [0, 1, 2, 5, 10, 50, 100, \n         500, 1000, 5000, 10000, 50000, \n         100000, 500000, 1000000, 5000000, \n         10000000, 50000000, 100000000, 500000000, \n         1000000000]","027eae18":"#create a table contains intall frequency and cumulative frequency for plotting purpose\ninstalls_cum = pd.DataFrame(data={'Install': df.groupby('Installs_Num').App.count().index, \n                                  'Freq': df.groupby('Installs_Num').App.count().values})\ninstalls_cum['CumFreq'] = installs_cum['Freq'].cumsum()\ninstalls_cum","15afa84e":"#plot the cumulative counts of intalls\nsns.set_style('dark')\nfig, ax = plt.subplots(figsize=(12,8))\nax = sns.lineplot(x=\"Install\", y=\"CumFreq\", linewidth = '2', color = 'orange', data=installs_cum)\n\nbars2 = ['0', '1', '2', '5', '10', '50', '100', \n         '500', '1,000', '5,000', '10,000', '50,000', \n         '100,000', '500,000', '1,000,000', '5,000,000', \n         '10,000,000', '50,000,000', '100,000,000', '500,000,000', \n         '1,000,000,000']\n\ny_pos = np.arange(len(bars2))\nplt.xticks(y_pos, bars2, rotation=90, fontsize='13', horizontalalignment='center')\nplt.title(\"Cumulative Counts of APP's Installs\", fontsize = '17')\nplt.ylabel('Cumulative Frequency',fontsize = '14')\nplt.xlabel('Number of Installs',fontsize = '14')\nax.grid(b=True, which='major')\n\nplt.show()","e7cf604c":"#test the function of ploty for intalls\ninstalls_cum.CumFreq.iplot()","2e5fd188":"#convert the attribute 'Price' into numerical value\ndf['Price'] = np.where(df['Price'] == '0', '$' + df['Price'], df['Price'])\ndf['Price'] = df.Price.apply(lambda x:x[1:]).astype('float')","8535e8f1":"#check if there's any nan in attrubute 'Price'\ndf.Price.isna().sum()","d4bfc614":"#check out the stats of attribtue 'Price'\ndf.Price.describe()","d968a746":"#check out the stats of attribtue 'Price' for paid apps only\ndf[df.Price > 0].Price.describe()","a974fe3e":"#create a pandas series recording number of counts for each genre\ngenre = df.groupby('Genres').App.count()\ngenre.head()","5d56b2e6":"#calculate the apps that belongs to multiple genres\nsum = 0\nfor i in range(len(genre)):\n    if ';' in genre.index[i]: #if a string contains ';'\n        sum += genre.values[i] #the number of count got added into sum\nprint(sum)        ","dbbb1917":"#calulate the percentage of records belonging to multiple genres\nsum\/df.shape[0]","35fb2a86":"#Keep only one genre for each app\ndf['Genres'] = df.Genres.apply(lambda x:x.split(';')[0])","5c4c315d":"#check out if there's any nan in attribute 'Genres'\ndf.Genres.isna().sum()","c57f8921":"#display the number of unique Genres\ndf.Genres.nunique()","e8680bcd":"#count number of 'Varies with device'\ndf[df['Current Ver'] == 'Varies with device'].App.count()","f395ebcb":"#replace the uncertain value 'Varies with device' with nan\ndf['Current Ver'] = df['Current Ver'].replace('Varies with device',np.nan)","8b1ae39c":"#double check number of nans\ndf['Current Ver'].isna().sum()","02c37f78":"#remain only the value before '.'\ndf['test'] = df['Current Ver'].astype('str').apply(lambda x:x.split('.')[0])\ndf.groupby('test').App.count().head(20)","65b3f3dc":"#delete irrelevant columns\ndel df['Current Ver']\ndel df['test']","1b9d8bf7":"#drop off irrelevant columns\ndf = df.drop(columns=['Clean_Name','Size_Unit'])","2781c9a0":"#display the first five records\ndf.head()","71ea3dde":"#check out if there's any nan\ndf.isna().sum()","1f4f6840":"#pull out the suspicious record\ndf[df.Type.isnull()]","4fbc28d2":"#check out what's the typical type for an app in Family type\ndf[df.Category == 'FAMILY'].groupby('Type').Type.count()","fcd020c1":"#assign 'Free' as this app's type based on mode\ndf['Type'] = df.Type.fillna(value='Free')\ndf.Type.isna().sum() #double check for nan","699a8b1a":"#display all the attribute's type\ndf.info()","5ff65afa":"#display all numerical value's stats\ndf.describe()","da02ff6b":"#check out the record with extreme big value in 'Price'\ndf[df.Price == 400]","b498c205":"#check out the record with extreme big value in 'Name_Length'\ndf[df.Name_Length == 194].Name_Word_Counts","5db76e48":"#check out the record with extreme big value in 'Name_Word_Counts'\ndf[df.Name_Word_Counts == 21].Name_Length","a5b70789":"#save the dataset after preprocessing as a new output csv file\ndf.to_csv('Clean_googleplaystore.csv')","529d20a6":"**1.10 Pre-Processing Wrap Up**","f1e36d95":"** 1.3 Pre-processing for the attribute \"Rating\"**","5437151e":"**1.7 Pre-Processing for the attribute \"Price\"**","cefa52da":"1. **1.2 Pre-processing for attribute \"Category\"**","1dde68bd":"**1. Data Pre-Processing**","13f5ba68":"Here, we use the median to replace all missing value, because the size's mean is very different from the median. The dataset is skewed significantly.","af96f11b":"**1.4 Pre-Processing for the attribute \"Reviews\"**","d90780ed":"Since the records having mutiple genres is less than 5% of the whole dataset , so we assume each app only belongs to one genre, the first one in the attribute, and we removed the second genre if there is one.","ed5b06c7":"**1.8 Pre-Processing for the attribute \"Genres\"**","cf0faf76":"Observed missing value in Rating, Type, Current Version","915daa5c":"Observed non-sense category \"1.9\" in the dataset, which has non-sense stats and only has one record, so I can simply remove it from the dataset.","88da898e":"These two records shall be normal, since their Name_Word_Counts is consistant with their Name_Length","eb21443e":"Since the attibute 'Current Version' has too many distict version name, which is no good for future EDA or Machine Learning Analysis. I decided to remove this attribtue from the dataset.","5b7908b0":"Identify one nan value in attribute 'Type'","bb101fcb":"**1.5 Pre-Processing for the attribute \"Size\"**","d2d122eb":"**1.6 Pre-Processing for the attribute \"Installs\"**","d51290f1":"Here, we use the mean to replace all missing value, because the ratings's mean is pretty much the same as the median. The dataset is not skewed significantly.","182ed653":"Observed \"Varies with device\" this uncertain value in attribute \"Size\" and \"Current Version\"","a39c9ed3":"**1.9 Pre-Processing for the attribute \"Current Version\"**","5c5b95c3":"**1.1 Pre-Processing ffor the attribute \" App\"**"}}