{"cell_type":{"fd9b5b17":"code","483efd35":"code","278ec99b":"code","495e7240":"code","3a61d204":"code","f2757d82":"code","f5935a2c":"code","926d2b6b":"code","fbdaa9dc":"markdown","80a39bca":"markdown"},"source":{"fd9b5b17":"import numpy as np\nimport pandas as pd\nimport wave, IPython\nfrom sklearn import *\nfrom scipy.io import wavfile\nimport gc; gc.enable()\n\ntrain = pd.read_csv('..\/input\/train_curated.csv')\ntrainn = pd.read_csv('..\/input\/train_noisy.csv')\ntest = pd.read_csv('..\/input\/sample_submission.csv')\ntrain.shape, trainn.shape, test.shape","483efd35":"train['path'] = train['fname'].map(lambda x: '..\/input\/train_curated\/'+x)\ntrainn['path'] = trainn['fname'].map(lambda x: '..\/input\/train_noisy\/'+x)\ntest['path'] = test['fname'].map(lambda x: '..\/input\/test\/'+x)\n\ntrain['noisy'] = 0; trainn['noisy'] = 1\ntrain = pd.concat((train, trainn), sort=False).reset_index(drop=True)\n\nlabels = [c for c in test.columns if c not in ['path','fname']]\ntrain = train[train['labels'].isin(labels)].reset_index(drop=True)\ntest = test[['path', 'fname']]\ntrain.shape, test.shape","278ec99b":"norm_labels = []\ncut = 100\nfor l in train.labels.unique():\n    norm_labels.append(train[train.labels == l][:cut])\ntrain = pd.concat(norm_labels, sort=False).sample(frac=1).reset_index(drop=True)\ntrain.shape","495e7240":"waves = \"\"\"3a5b14ee.wav 404712 423984\n7a9cf335.wav 501072 520344\nc421d4a2.wav 289080 308352\naa28de21.wav 231264 250536\n703ac398.wav 19272 38544\n3cbb9c24.wav 57813 77084\n7c20368d.wav 616672 635943\nc6cb06d9.wav 481775 501046\n7f0af3bb.wav 481775 501046\n76caa793.wav 385420 404691\n767b8f3a.wav 635943 655214\na98c3157.wav 231252 250523\n8ddb4c26.wav 0 19271\n3e1d0af4.wav 635943 655214\naca0ce49.wav 578130 597401\"\"\".split('\\n')\nwavesc = []\nfor w in waves:\n    w1, c1, c2 = w.split(' ')\n    c1 = int(c1); c2 = int(c2)\n    nrate, ndata = wavfile.read('..\/input\/train_noisy\/'+w1)\n    wavesc.append(ndata[c1:c2])\nwavesc = np.concatenate(wavesc)\nwavfile.write('one_step.wav', 44100, wavesc)\nIPython.display.display(IPython.display.Audio('one_step.wav'))","3a61d204":"def get_short_wave(w, size=1200):\n    rate, data = wavfile.read(w)\n    if len(data) > size:\n        return data[:size]\n    else:\n        print(int((size \/ len(data))+1), len(data))\n        return np.repeat(data, int((size \/ len(data))+1))[:size]","f2757d82":"train['nframes'] = train['path'].map(lambda x: wave.open(x).getnframes())\ntrain['short_wave'] = train['path'].map(lambda x: get_short_wave(x))\n\ntest['nframes'] = test['path'].map(lambda x: wave.open(x).getnframes())\ntest['short_wave'] = test['path'].map(lambda x: get_short_wave(x))","f5935a2c":"def features(df, col='short_wave'):\n    for agg in ['min', 'max', 'sum', 'median', 'mean', 'std', 'skew', 'kurtosis']:\n        df[col+agg] = df[col].map(lambda x: eval('pd.DataFrame(x).' + agg + '(axis=0)')[0])\n        df[col+'a'+agg] = df[col].map(lambda x: eval('pd.DataFrame(x).abs().' + agg + '(axis=0)')[0])\n        \n    df[col+'max_diff'] = df[col+'max'] - df[col+'mean']\n    df[col+'amax_diff'] = df[col+'amax'] - df[col+'amean']\n    \n    df[col+'min_diff'] = df[col+'mean'] - df[col+'min']\n    df[col+'amin_diff'] = df[col+'amean'] - df[col+'amin']\n    \n    df[col+'max_diff2'] = df[col+'max'] - df[col+'median']\n    df[col+'amax_diff2'] = df[col+'amax'] - df[col+'amedian']\n    \n    df[col+'min_diff2'] = df[col+'median'] - df[col+'min']\n    df[col+'amin_diff2'] = df[col+'amedian'] - df[col+'amin']\n    return df\n\ntrain = features(train).fillna(-999)\ntest = features(test).fillna(-999)\nprint(train.shape, test.shape)","926d2b6b":"col = [c for c in train.columns if c not in ['path','fname', 'noisy', 'labels', 'short_wave']]\nle = preprocessing.LabelEncoder()\ntrain['labels'] = le.fit_transform(train['labels'])\n\nclf1 = ensemble.ExtraTreesClassifier(n_jobs=-1, n_estimators=400, max_features=0.9, random_state=10)\nclf2 = ensemble.RandomForestClassifier(n_jobs=-1, n_estimators=400, max_features=0.9, random_state=9)\n\nsplit = 3000\nclf1.fit(train[col][:split], train['labels'][:split])\nclf2.fit(train[col][:split], train['labels'][:split])\ndef LOL_WRAP(y_true, y_score): return metrics.label_ranking_average_precision_score(y_true, y_score)\n\nprint('ETR LOL_WRAP', LOL_WRAP(pd.get_dummies(train['labels'])[split:], clf1.predict_proba(train[col][split:])))\nprint('RFR LOL_WRAP', LOL_WRAP(pd.get_dummies(train['labels'])[split:], clf2.predict_proba(train[col][split:])))\n\nclf1.fit(train[col], train['labels'])\nclf2.fit(train[col], train['labels'])\n\nsub = clf1.predict_proba(test[col])\nsub += clf2.predict_proba(test[col])\nsub \/= 2\n\nsub = pd.DataFrame(sub, columns=le.classes_)\nsub['fname'] = test['fname']\nmissing = [c for c in labels if c not in sub.columns]\nfor c in missing:\n    sub[c] = 0.0\nsub.to_csv('submission.csv', index=False)","fbdaa9dc":"**Bumblebee Radio **","80a39bca":"**Lets create some simple features**"}}