{"cell_type":{"847ef2c1":"code","ee1a8989":"code","cf4beb38":"markdown","38361108":"markdown","75372d6a":"markdown","80829473":"markdown","21cb5524":"markdown","5e38401d":"markdown"},"source":{"847ef2c1":"import numpy as np\nimport pandas\nimport matplotlib.pyplot as plt\n\ndata = pandas.read_csv(\"..\/input\/housesalesprediction\/kc_house_data.csv\")\n\"\"\"\n['id', 'date', 'price', 'bedrooms', 'bathrooms', 'sqft_living',\n'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',\n'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',\n'lat', 'long', 'sqft_living15', 'sqft_lot15']\n\"\"\"\ndata_sample = data[:5000]\n\nareas = data_sample[\"sqft_living\"] # can also be _lot or _above\nprices = data_sample[\"price\"]\n\n# some sane defaults\nweights = np.array([1000., 500.])\n\n\ndef calc_price(vars, in_weights):\n    b = np.ones([vars.shape[0], 1])\n    all_vars = np.append(vars, b, 1) # append 1 to have const multiplier\n    return np.dot(all_vars, in_weights)\n\ninputs = np.array(areas).reshape([-1, 1])\n\nprojected_price = calc_price(inputs, weights)\n\nplt.figure(figsize=(15,10))\n\nplt.plot(areas, prices, \".\")\nplt.plot(areas, projected_price)\n\ndef mse(a, b):\n    return np.sum(np.square(b - a))\/a.shape[0]\n\nprint(\"mse\", mse(prices, projected_price))\n\ndef mse_from_projected_weights(in_weights, plot=False):\n    projection = calc_price(inputs, in_weights)\n    if plot:\n        plt.plot(areas, projection)\n    return mse(prices, projection)\n\n\ndef grad(func, vars, offsets = None):\n    num_vars = vars.shape[0]\n    if offsets == None:\n        offsets = np.ones(num_vars)\n        \n    results = func(vars, True) # true to plot\n    print(f\" MSE: {results:e}\")\n    deltas = np.empty(num_vars)\n    for idx in range(num_vars):\n        vars2 = np.copy(vars)\n        vars2[idx] += offsets[idx]\n        results2 = func(vars2)\n        deltas[idx] = results - results2\n    return deltas\n\nprint(\"  w:\", weights)\ngrad_result = grad(mse_from_projected_weights, weights)\nprint(\"grad:\", grad_result)\n\nstep = [1e-8, 1e-8]\nstep = [4e-8, 1e-6] # this converges in even less steps\ncoarse_iters = 50\nfor idx in range(coarse_iters):\n    weights += grad_result * step\n    print(idx, \" w:\\t\", weights)\n    grad_result = grad(mse_from_projected_weights, weights)\n    print(\"grad:\", grad_result)\n\n\n#plt.plot(np.log(houses[\"price\"]), np.log(houses[\"sqft_above\"]), \"o\")\n\n","ee1a8989":"# almost the same\n\nimport numpy as np\nimport pandas\nimport matplotlib.pyplot as plt\nimport sklearn.preprocessing as pre\n\nnp.set_printoptions(precision=5)\nplt.figure(figsize=(12,8))\n\ndata = pandas.read_csv(\"..\/input\/housesalesprediction\/kc_house_data.csv\")\n\"\"\"\n['id', 'date', 'price', 'bedrooms', 'bathrooms', 'sqft_living',\n'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',\n'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',\n'lat', 'long', 'sqft_living15', 'sqft_lot15']\n\"\"\"\ndata_sample = data[:1000]\n\nvariables = data_sample[[\n    \"sqft_living\", # can also be _lot or _above\n    \"floors\",\n    \"bedrooms\",\n    \"sqft_living\",\n]].values\n\n\nscaler = pre.StandardScaler()\ninputs = scaler.fit_transform(variables)\n\npre_prices = data_sample[[\"price\"]].values\nscaler2 = pre.StandardScaler()\nprices = scaler2.fit_transform(pre_prices)\n\ndef calc_price(vars, in_weights):\n    b = np.ones([vars.shape[0], 1])\n    all_vars = np.append(vars, b, 1) # append 1 to have const multiplier\n    return np.dot(all_vars, in_weights)\n\n\n\ndef mse(a, b):\n    return np.sum(np.square(b - a))\/a.shape[0]\n\n\ndef mse_from_projected_weights(in_weights):\n    projection = calc_price(inputs, in_weights)\n    return mse(prices, projection)\n\n\ndef grad(func, vars, offsets):\n    num_vars = vars.shape[0]\n    results = func(vars)\n    #print(\"MSE:\\t\", np.format_float_scientific(results, 5))\n    \n    deltas = np.empty(num_vars)\n    for idx in range(num_vars):\n        vars2 = np.copy(vars)\n        vars2[idx] += offsets[idx]\n        results2 = func(vars2)\n        deltas[idx] = results2 - results\n    return deltas \/ offsets\n\n\nweights = np.array([1, -1, 1, -1, 1], dtype=np.float64)\nstep = np.ones(5) * 0.0001\niters = 80\n\nprint(\"W:\\t\", weights)\ngrad_result = grad(mse_from_projected_weights, weights, step)\n\nerrors = np.empty(iters)\n\nfor idx in range(iters):\n    weights -= grad_result * step\n    error = mse_from_projected_weights(weights)\n    print(idx, \"W:\\t\", error, '\\t', weights)\n    errors[idx] = error\n    grad_result = grad(mse_from_projected_weights, weights, step)\n\n\nplt.plot(errors)\n#plt.plot(np.log(houses[\"price\"]), np.log(houses[\"sqft_above\"]), \"o\")\n\n","cf4beb38":"\n### Regresi\u00f3n multivariable:\nConsidere ahora que existe m\u00e1s de una caracter\u00edstica para predecir el valor de la casa, ej. \u00e1rea, numero de habitaciones, a\u00f1os de construcci\u00f3n, etc. As\u00ed el modelo se convierte en:\n```\ny = A0 + A1 X1 + A2 X2 + ... + AnX\n```\n\n* \u00bfC\u00f3mo se plantear\u00eda la nueva funci\u00f3n de costo teniendo en cuenta el nuevo conjunto de datos? realice la implementaci\u00f3n\n* Aplique el gradiente descendente para ajustar el modelo a los datos. Considere hacer normalicaci\u00f3n de los datos.\n","38361108":"### Clasificaci\u00f3n con regresi\u00f3n log\u00edstica\nConsidere el escenario donde se quiere saber si un tumor es maligno o benigno. Se asume que dicha condici\u00f3nd epende del tama\u00f1o del tumor. Para este problema se considera que existen 2 clases, tumor maligno (identificada como y=1) y tumor benigno (identificada como y=0)\nen machine learning la herramienta m\u00e1s sencilla para generar un l \u00edmite o frontera de decisi\u00f3n (decision boundary) es la regresi\u00f3n log\u00edstica, cuyo modelo matem\u00e1tico es:\n```\np = 1 \/ (1+exp(x))\n```\n\ndonde p indica el grado de pertenencia (a veces probabilidad) de la observaci\u00f3n x a una categor\u00eda o clase, para el ejemplo mencionado tumor maligno o benigno.\n\n* c\u00f3mo se genera la funci\u00f3n de costo para esta aplicaci\u00f3n y de qu\u00e9 forma se puede incorporar en el algoritmo de gradiente descendente? implemente\n* Aplique el algoritmo de gradiente descendente para ajustar el modelo de clasificaci\u00f3n y eval\u00fae el desempe\u00f1o del modelo ajustado\n* \u00bfcomo se evalua dicho desempe\u00f1o?\n\nAutoevaluaci\u00f3n:\n---------------\n","75372d6a":"Actividad te\u00f3rica:\n------------------\n\n* Qu\u00e9 es Machine Learning?\n\nEs el estudio de algoritmos de computador que se mejoran autom\u00e1ticamente por medio de la experiencia. Usan un un modelo basado en _datos de entrenamiento_ para hacer predicciones o decisiones sin ser programado espec\u00edficamente para eso.\n\n\n* Cual es el objetivo principal del Machine Learning?\n\nEl machine learning busca que sea el mismo computador el que cree el algoritmo necesario para resolver un problema, ya que puede ser un problema tan complejo, que crear un algoritmo para resolver el problema puede ser demasiado desafiante para que un humano pueda desarrollarlo.\n\n* Qu\u00e9 diferencia y\/o relaci\u00f3n existe entre Machine Learning e Inteligencia Artificial?\n\nInteligencia artificial puede considerarse cualquier algoritmo que lleve a un computador a tomar decisiones \"inteligentes\" basadas en datos de entrada. Puede abarcar campos desde la gestion de procesos industriales hasta los videojuegos, pero generalmente representa comportamientos de inteligencia humana plasmados en algoritmos.\nMachine learning es un tipo de IA donde se busca que sea la misma m\u00e1quina la que llega a este \"conocimiento\" mediante un proceso de aprendizaje de la m\u00e1quina o \"entrenamiento\".\n\n* Explique \u00bfC\u00f3mo diferenciar una aplicaci\u00f3n de machine learning de una aplicaci\u00f3n de inteligencia artificial?\n\nLa diferencia particular del machine learning es que el algoritmo final es generado por la misma m\u00e1quina basado en observaciones. Basado en esto se puede identificar una aplicaci\u00f3n de machine learning si requiere de datos iniciales para ser entrenada. Adem\u00e1s de esto la aplicaci\u00f3n de machine learning se puede hacer mejor cada vez a medida que es usada y entrenada, mientras que otro tipo de inteligencia artificial va a generar los mismos resultados ante los mismos est\u00edmulos.\n\n\n* Mencione al menos 3 aplicaciones generales de machine learning\n\nSeguridad, en la deteccion de rostro por medio de grabaciones de camaras de seguridad\nBusqueda en linea, el sistemas de busqueda que manejan los navegadores\nProcesamiento de lenguage natural, como lo es Alexa y Siri que reconocen la voz y el idioma \n\n* Mencione y explique 3 aplicaciones de Machine Learning en ingenieria\n\nPrediccion de fallos en una maquinaria, esto ayuda a prevenir fallos graves y costosos, ademas de poder programar la reparacion de la maquinaria sin da\u00f1ar la productividad.\nAuto ajustes en una aplicacion, la aplicacion se ajusta a los gustos del usuario y le da opciones basado en los gustos, constumbres y\/o necesidades.\nAnalisis de imagenes de alta calidad, con este tipo de imagenes se le ense\u00f1a que tipo de imagenes se esta buscando.\n\n* Explique que relacion existe entre machine learning e ingenieria mecatronica?\n\nYa que \n\n* Mencione y explique 3 aplicaciones de machine learning en el escenario especifico de la ingenier\u00eda para la que se est\u00e1 formando\n\nPrediccion de fallos en una maquinaria, ya que con esto se puede programar detencion de la maquinaria y cambiar los implementos necesarios previniendo fallos graves y costosos.\nAnalisis de imagenes, por medio de grabaciones en la deteccion del rostro o por medio de una camara para emparejar las imagenes y hacer un espaciado 3D del entorno.\n \n* Para las aplicaciones mencionadas anteriormente, diga \u00bfQu\u00e9 estrategias diferentes a Machine Learning pueden ser usadas para resolver el problema?\n\nPara predicir un fallo solo es con las con las estadisticas de las piezas que contienen en el manual programando una mantenimiento para revisar el estado de la pieza\nEn el analisis de imagenes para la deteccion de rostros tocaria pausar el video y seleccionar la parte de la imagen donde se encuentre el rostro.\n\n* Investigue \u00bfQu\u00e9 es la regresi\u00f3n lineal? y \u00bfCu\u00e1l es su relaci\u00f3n y aplicaci\u00f3n con Machine learning?\n\nEs un modelo matem\u00e1tico para aproximar la relacion entre una variable dependiente y varias variables independientes.\n\nLa manera de lograr esto es partir de una funcion lineal (o cualquier funci\u00f3n), y mediante un proceso iterativo se busca que esta funci\u00f3n se vaya adaptando a un resultado, buscando reducir al m\u00e1ximo la diferencia entre la funci\u00f3n y los datos con los que se compara. Es decir, se busca minimizar la diferencia entre los datos reales y la funci\u00f3n lineal (o cualquier otra)\n\nPara lograr esto es conveniente tener una manera de medir esta _diferencia_. Esto se hace con una **funci\u00f3n de costo** que nos indique num\u00e9ricamente qu\u00e9 tan cerca de los datos reales est\u00e1 nuestra predicci\u00f3n. Una funci\u00f3n de costo popular es la funci\u00f3n del _error cuadr\u00e1tico medio_ mostrada a continuaci\u00f3n:\n```\nECM = 1\/n * sum( (prediccion_i - dato_i)^2 )\n```\n\nPara buscar la aproximaci\u00f3n \u00f3ptima (la que tenga el error m\u00ednimo) es necesario ajustar las influencias de las variables independientes sobre la predicci\u00f3n. Este proceso se hace de manera iterativa usando el concepto de descenso de gradiente.\n\nEl descenso de gradiente, de manera resumida, consiste en tomar dos predicciones A y B (con dos valores de influencia cercanos) y evaluar cu\u00e1l de las predicciones es m\u00e1s acertada (usando nuestra funci\u00f3n de costo). Luego de esto podemos ajustar las influencias del modelo en la direcci\u00f3n que tiende a reducirse el error de la predicci\u00f3n. De esta manera cada nuevo paso va reduciendo el error.\n\n* Investigue \u00bfQu\u00e9 es la regresi\u00f3n log\u00edstica? y \u00bfCu\u00e1l es su relaci\u00f3n y aplicaci\u00f3n con machine learning?\n\n","80829473":"![](http:\/\/)","21cb5524":"Taller: Conceptos b\u00e1sicos de Machine Learning\n=============================================\n* Andr\u00e9s Botero: 1201310\n* Carlos Guerrero: 1802524","5e38401d":"Actividad pr\u00e1ctica:\n-------------------\n\n### Regresi\u00f3n de una variable:\nConsidere el escenario de predecir el valor de una casa dependiendo del \u00e1rea. Adquiera o genere un dataset que represente el problema. Tomando como base la regresi\u00f3n lineal, se tiene que el valor de una casa es una funci\u00f3n del \u00e1rea\n```\ny = A0 + A1*x\n```\nDonde y es el valor predicho y x es el \u00e1rea en metros cuadrados, el modelo lineal tiene los par\u00e1metros A0 y A1, el problema de Machine learning es encontrar los valores de los par\u00e1metros A0 y A1 que adapten el modelo a los datos.\n\nEn Machine Learning el m\u00e9todo mas com\u00fanmente aplicado para estimar los par\u00e1metros de un modelo es el gradiente descendente, para ello se requiere dise\u00f1ar una funci\u00f3n de costo.\n* Plantee la funci\u00f3n de costo para el problema mencionado\n* Aplique el gradiente descendente para encontrar los par\u00e1metros del modelo. Considere hacer normalizaci\u00f3n de los datos.\n* \u00bfCu\u00e1l es el metodo id\u00f3neo con el que se normalizan los datos?\n\n"}}