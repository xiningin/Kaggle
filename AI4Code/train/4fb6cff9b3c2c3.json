{"cell_type":{"0addaa8e":"code","f088b025":"code","4ee13783":"code","62806603":"code","589a447d":"code","1f36c8b2":"code","89263492":"code","99853b60":"code","30927f16":"code","087d446b":"code","7f161fb4":"code","82a1fb7a":"code","ee292fc4":"code","af020061":"code","f5d85eb3":"code","ea6eab96":"code","e4178a0e":"code","947e6008":"code","b862589f":"code","78454683":"code","06153e90":"code","d04207fd":"code","9b1989f9":"code","3de2e2ab":"code","ca5cfab1":"code","fae62756":"code","334633ca":"code","a92f855d":"code","67e41166":"code","c01a09f5":"code","4e889087":"code","30009502":"code","6e9a457a":"code","23e070e6":"code","0b0c9e57":"code","bffe652c":"code","55d6321c":"code","530b5c42":"code","661e0b0b":"code","a87a7184":"code","f0fbd3ce":"markdown","4d4ea9dc":"markdown","4f3714c8":"markdown","bdc214dc":"markdown","73cc82b9":"markdown","a9905e83":"markdown","8d767759":"markdown","1b70aa5e":"markdown","bd560abe":"markdown","6458e6b2":"markdown","a920fa89":"markdown","3ee227ae":"markdown","20bab12c":"markdown","258464da":"markdown","8b344a6b":"markdown","d1c94dfb":"markdown","9bc09769":"markdown","3691d0c4":"markdown","4f04ddf3":"markdown","d1f51e1d":"markdown","caea1535":"markdown","b6ed45b0":"markdown","79933f22":"markdown","399715ab":"markdown"},"source":{"0addaa8e":"import os\nimport math\n\nimport json\nimport numpy as np\nimport scipy as sc\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport seaborn as sns\nfrom plotnine import *\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n\nimport folium\nimport folium.plugins\nimport branca.colormap as cm\n\nimport geopandas as gpd\n\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom IPython.core.display import HTML\nfrom IPython.display import clear_output\n\n\n# color pallette\nc = '#393e46' # confirmed - grey\nd = '#ff2e63' # death - red\nr = '#30e3ca' # recovered - cyan\ni = '#f8b400' # still infected - yellow\nmr = '#ed001c' # mortality rate - red2\nrr = '#0cf0af' # Recovery rate - cyan2\nsi = '#f8e300' # Still infected coverage - yellow2\nic = '#8698b5' # Infection coverage - grey2\n\ncdr = [c, d, r] \nidr = [i, d, r] \nrid = [r, i, d]\n\nvalid_case_columns = {'Deaths': d, 'Recovered': r, 'Still Infected': i,  'Confirmed': c}\nvalid_mortality_columns = {'Infection coverage': ic, 'Still infected coverage': si, 'Mortality rate': mr,  'Recovery rate': rr}\n\n# world boundries\nwd_geo_data_path = os.path.join('\/kaggle\/input\/python-folio-country-boundaries', \"world-countries.json\")\n# china boundaries\n# ch_geo_data_path = os.path.join('\/kaggle\/input\/china-regions-map', \"china-provinces.json\")\nch_geo_data_path = os.path.join('\/kaggle\/input\/china-province-geojson', \"gadm36_CHN_1.json\")","f088b025":"# *** utility functions ***\n\n# --- dataframe manipulation functions ----\ndef handle_age(df):\n    \"\"\"Extract correct age information from dataframe.\n\n    Args:\n        df (dataframe): Dataframe for extracting age information.\n\n    Returns:\n        numeric_age_bins_vc (dataframe): Bins of ages with corresponding frequency.\n    \"\"\"\n    # first,drop nan rows in age column\n    df_c = df.dropna(subset=['age'])\n    # then get numeric age values from string age column and convert them to int\n    numeric_age = pd.to_numeric(df_c['age'], errors='coerce').dropna().astype(np.int64)\n    # make numeric age values binning to ranges\n    highest_tenth = int(10 * math.ceil(float(max(numeric_age))\/10))\n    labels = [\"{0}-{1}\".format(i, i + 9) for i in range(0, highest_tenth, 10)]\n    numeric_age_bins = pd.cut(x=numeric_age, bins=range(0, highest_tenth+10, 10), right=False, labels=labels)\n    numeric_age_bins_vc = numeric_age_bins.value_counts()\n    # eliminate already processed values (age values succesfully converted to int)\n    unproceeed_ages = df_c[~df_c.index.isin(numeric_age.index)]['age'].value_counts()\n    for i, v in unproceeed_ages.items():\n        if i in numeric_age_bins_vc.index:\n            numeric_age_bins_vc.loc[i] += v\n\n    return numeric_age_bins_vc\n\ndef add_additional_cols(df, col_list=None):\n    \"\"\"Add additional predefined columns to given dataframe.\n\n    Args:\n        df (dataframe): Dataframe for applying trasnformation.\n        col_list (list): Subset of predefined columns for selection. If None, add all columns.\n\n    Returns:\n        df (dataframe): Modified dataframe after transformation.\n    \"\"\"\n    valid_col_list = []\n    if col_list is None or 'Still Infected' in col_list:\n        df['Still Infected'] = df['Confirmed'] - df['Deaths'] - df['Recovered']\n        valid_col_list.append('Still Infected')\n    if col_list is None or 'Infection coverage' in col_list:\n        df['Infection coverage'] = round((df['Confirmed'] \/ df['Population'])*1000000, 3)\n        valid_col_list.append('Infection coverage')\n    if col_list is None or 'Still infected coverage' in col_list:\n        df['Still infected coverage'] = round((df['Still Infected'] \/ df['Population'])*1000000, 3)\n        valid_col_list.append('Still infected coverage')\n    if col_list is None or 'Mortality rate' in col_list:\n        df['Mortality rate'] = round((df['Deaths'] \/ df['Confirmed'])*100, 3)\n        valid_col_list.append('Mortality rate')\n    if col_list is None or 'Recovery rate' in col_list:\n        df['Recovery rate'] = round((df['Recovered'] \/ df['Confirmed'])*100, 3)\n        valid_col_list.append('Recovery rate')\n    \n    if valid_col_list:\n        df[valid_col_list] = df[valid_col_list].fillna(0)\n\n    \n    return df\n\ndef transform_data(data, transform_type):\n    \"\"\"Apply given trasnformation to given data.\n\n    Args:\n        data (dataframe): Dataframe for applying trasnformation.\n        transform_type (string): Name of the trasnformation will be applied.\n\n    Returns:\n        - (dataframe): Trasnformed data.\n    \"\"\"\n    if transform_type == 'none':\n        return data\n    elif transform_type == 'ln':\n        return np.log10((data + 1))\n    elif transform_type == 'log10':\n        return np.log10((data + 1))\n    elif transform_type == 'square root':\n        return np.sqrt(data)\n    elif transform_type == 'cubic root':\n        return np.cbrt(data)\n    elif transform_type == 'boxcox':\n        return sc.stats.boxcox(data + 1)[0]\n    else:\n        raise ValueError('Unknown trasnformation argument has been given')\n\n# --- plotting functions ---\ndef find_factor_of(latest_df, full_df, column, factor, lower_threshold=0, limit=None):\n    \"\"\"Find the past record of given column that the latest record is a factor of this record.\n\n    Args:\n        latest_df (dataframe): Dataframe only includes latest records of countries.\n        full_df (dataframe): Dataframe includes all dates and countries.\n        column (string): Name of the column the processing on ex: 'Confirmed', 'Deaths'.\n        factor (float): A float given as a factor ex: 2, 3, 4.\n        lower_threshold (float): Minimum number of occurences at the latest date.\n        limit (int): Number of rows that return only n shortest span of countries.\n\n    Returns:\n        - (dataframe): Trasnformed data.\n    \"\"\"\n    def find_past_factor_date(df):\n        df = df[(0 < df[column]) & (df[column] <= float(df.loc[df['Date'].idxmax()][column]\/factor))]\n        return df.sort_values('Date', ascending=False).head(1)\n    \n    date_c_name, count_c_name, difference_c_name, factor_c_name = 'Date since', 'Count on this date',\\\n                                                                  'Number of days', 'Factor of'\n    factor_df = latest_df.copy()\n    factor_df = factor_df[factor_df[column] > max(factor-1, lower_threshold)]\n    full_df_valid_rows = full_df[full_df['Country\/Region'].isin(factor_df['Country\/Region'])].groupby(['Country\/Region', 'Date']).agg({column:sum}).reset_index()\n    factor_df = factor_df.set_index('Country\/Region', drop=True)\n    factor_df[[date_c_name, count_c_name]] = full_df_valid_rows.groupby(['Country\/Region']).apply(find_past_factor_date).set_index('Country\/Region', drop=True)\n    factor_df[difference_c_name] = (factor_df['Date'] - factor_df[date_c_name]).dt.days\n    factor_df[factor_c_name] = (factor_df[column] \/ factor_df[count_c_name]).round(2)\n    factor_df[date_c_name] = factor_df[date_c_name].dt.strftime('%Y-%m-%d')\n    factor_df = factor_df.sort_values([difference_c_name, factor_c_name], ascending=[True, False]).reset_index()\n    factor_df=factor_df.rename(columns={column: 'Count now'})\n    \n\n    if limit:\n        factor_df = factor_df.head(limit)\n    \n    return factor_df, date_c_name, count_c_name, difference_c_name, factor_c_name\n    \ndef display_tabular_df(df, columns=None, sort_col=None, cmap='Reds'):\n    \"\"\"Display dataframe in tabular format.\n\n    Args:\n        df (dataframe): Dataframe for creating choropleth layer.\n        columns (list): List of dataframe columns to select subset of them.\n        sort_col (string): Name of column rows will be sorted.\n        cmap (string): Name of color map will be used ing tabular form.\n\n    Returns:\n        No return values given.\n    \"\"\"\n    \n    if not df.empty:\n        if columns is None:\n            columns = df.columns\n        \n        temp = df[columns]\n        \n        if sort_col and sort_col in df.columns:\n            temp = temp.sort_values(sort_col, ascending=False)\n        \n        display(temp.style.background_gradient(cmap=cmap).hide_index() \\\n        .set_table_styles([{'selector': 'th', 'props': [('font-size', '10pt'),('border-style','solid'),('border-width','1px')]}, \n                           {'selector': 'td', 'props': [('font-size', '10pt'),('border-style','solid'),('border-width','1px')]}]))\n    else:\n        print('No country has been found.')\n\ndef plotly_bar_plot(df_list, x_column_dicts, y_columns, subplot_titles, title=None, rows=1, cols=2, height=1000, v_space=0.05, h_space=0.1, \n                    custom_data_list=None, is_stacked=True, transformation='log10'):\n    \"\"\"Create a plotly bar graph figure with subplots.\n\n    Args:\n        df_list (list): List of dataframes for creating each subplot.\n        x_column_dicts (list): List of dicts including column names of dataframe for each subplot with corresponding colorbrewer palette.\n        y_columns (list): List of columns for y-axis per subplot.\n        subplot_titles (list): List of titles one per subplot.\n        title (str): Figure title.\n        rows (int): Number of rows for making subplot.\n        cols (int): Number of columns for making subplot.\n        height (int): Height of complete figure.\n        v_space (float): Vertical spacing for subplots.\n        h_space (float): Horizontal spacing for subplots.\n        custom_data_list (list): List of dataframe used as custom data in subplots.\n        is_stacked (bool): Whether the bar subplots will be stacked.\n        transformation (str): Type of the transformation will be applied on x-axis.\n\n    Returns:\n        fig (Plotly figure): A Plotly figure includes several subplots.\n    \"\"\"\n    fig = make_subplots(rows=rows, cols=cols, shared_xaxes=False, subplot_titles=subplot_titles, vertical_spacing=v_space, horizontal_spacing=h_space)\n    \n    if custom_data_list is None:\n        custom_data_list = [None]*len(df_list)\n        \n    for index, (df, x_column_dict, y_column, custom_data) in enumerate(zip(df_list, x_column_dicts, y_columns, custom_data_list)):\n        if custom_data is None:\n            custom_data = df\n        \n        row_number = math.floor(index \/ cols) + 1\n        col_number = (index % cols) + 1\n        for col, color in x_column_dict.items():\n            transformed_data = transform_data(df[col], transformation)\n            fig.add_trace(go.Bar(x=transformed_data, \n                          y=df[y_column],\n                          text=[col] * len(transformed_data),\n                          name=f'{col}',\n                          marker_color=color,\n                          customdata=custom_data[col],\n                          hovertemplate='%{y}-%{text}: %{customdata}',\n                          orientation='h'), row=row_number, col=col_number)\n\n    layout = {\"showlegend\": True,'height': height}\n    if is_stacked:\n        layout['barmode'] = 'stack'\n    \n    if title:\n        layout['title'] = title\n    \n    fig.update_layout(layout)\n\n    return fig\n\ndef plotly_scatter_plot(df_list, x_columns, y_columns_list, subplot_titles, title=None, rows=1, cols=2, height=1000, v_space=0.05, h_space=0.1, custom_data_list=None, transformation='none'):\n    \"\"\"Create a plotly scatter graph figure with subplots.\n\n    Args:\n        df_list (list): List of dataframes for creating each subplot.\n        x_columns (list): List of columns for x-axis per subplot.\n        y_columns_list (list): List of lists including column names of dataframe for each subplot with corresponding colorbrewer palette.\n        subplot_titles (list): List of titles one per subplot.\n        title (str): Figure title.\n        rows (int): Number of rows for making subplot.\n        cols (int): Number of columns for making subplot.\n        height (int): Height of complete figure.\n        v_space (float): Vertical spacing for subplots.\n        h_space (float): Horizontal spacing for subplots.\n        custom_data_list (list): List of dataframe used as custom data in subplots.\n        transformation (str): Type of the transformation will be applied on x-axis.\n\n    Returns:\n        fig (Plotly figure): A Plotly figure includes several subplots.\n    \"\"\"\n    fig = make_subplots(rows=rows, cols=cols, shared_xaxes=False, subplot_titles=subplot_titles, vertical_spacing=v_space, horizontal_spacing=h_space)\n    \n    if custom_data_list is None:\n        custom_data_list = [None]*len(df_list)\n        \n    for index, (df, x_column, y_columns, custom_data) in enumerate(zip(df_list, x_columns, y_columns_list, custom_data_list)):\n        if custom_data is None:\n            custom_data = df\n        \n        row_number = math.floor(index \/ cols) + 1\n        col_number = (index % cols) + 1\n        for col in y_columns:\n            transformed_data = transform_data(df[col], transformation)\n            fig.add_trace(go.Scatter(x=df[x_column],\n                          y=transformed_data,\n                          text=[col] * len(transformed_data),\n                          name=f'{col}',\n                          marker=dict(color=df[col], coloraxis=\"coloraxis\"),\n                          customdata=custom_data[col],\n                          hovertemplate='%{x}-%{text}: %{customdata}',), row=row_number, col=col_number)\n\n    layout = {\"showlegend\": True,'height': height}\n    if title:\n        layout['title'] = title\n    \n    fig.update_layout(layout)\n\n    return fig\n\n\ndef plotly_graph(df, geojson_path=wd_geo_data_path, key_col_dict=None):\n    \"\"\"Create a plotly multilayer choropleth map.\n\n    Args:\n        df (dataframe): Dataframe for creating choropleth layer.\n        geojson_path (os.path): File path of related geojson file.\n        key_col_dict (dict): Dict including column names of dataframe for choropleth visualization with corresponding colorbrewer palette.\n\n    Returns:\n        base_map (Folium map): Modified map.\n    \"\"\"\n    # read geojson file for map\n    with open(geojson_path) as f:\n        geojson_file = json.load(f)\n    \n    # variables for map creation\n    fill_opacity = 0.7\n    \n    data, dropdown_list = [], []\n\n    for index, (col_name, palette) in enumerate(key_col_dict.items()):\n        data.append(go.Choroplethmapbox(geojson=geojson_file,\n                                        name=col_name,\n                                        locations=df['Country\/Region'],\n                                        featureidkey='properties.name',\n                                        z=np.log10(df[col_name]),\n                                        visible=False,\n                                        marker_opacity=fill_opacity,\n                                        text=df['Country\/Region'],\n                                        customdata=df[col_name],\n                                        hovertemplate='<br>Country: %{text}' +\n                                                      '<br>Cases: %{customdata}' +\n                                                      '<br>Log10 (cases): %{z}',\n                                        colorbar=dict(title=f'{col_name} cases (log10 scale)', tickprefix='10^'),\n                                        colorscale=palette\n                                            ))\n        visibility_pattern = [False] * (len(key_col_dict))\n        visibility_pattern[index] = True\n        dropdown_list.append(dict(\n                        args=['visible', visibility_pattern],\n                        label=f'{col_name} cases',\n                        method='restyle'\n                    ),)\n    \n    data[0]['visible'] = True\n    \n    layout=go.Layout(mapbox_style=\"carto-positron\",\n                     mapbox_zoom=1,\n                     width=1800,\n                     height=800)\n    \n    #dropdown code from https:\/\/plot.ly\/~empet\/15237\/choroplethmapbox-with-dropdown-menu\/#\/\n    layout.update(updatemenus=list([\n            dict(x=0.5, y=1,\n                xanchor=\"center\",\n                yanchor='bottom',\n                buttons=dropdown_list)]))\n    \n    # layout.update(margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\n    fig = go.Figure(data=data,layout=layout)\n    \n    return fig\n\ndef create_choropleth(base_map, data, key_col_name, merge_column, palette, transformation, is_active=False):\n    \"\"\"Helper function to create a folium choropleth layer and add to base map.\n\n    Args:\n        base_map (Folium map): Initial map.\n        data (dataframe): Dataframe for creating choropleth layer.\n        key_col_name (str): Name of the column will be used for coloring of this layer.\n        merge_column (str): Name of the column has been used for grouping the dataframe (country or province).\n        palette (str): Name of the colorbrewer palette.\n        transformation(string): In which transformation will be applied to data for visualization.\n        is_active (bool): Whether this layer will be shown initially.\n\n    Returns:\n        base_map (Folium map): Modified map.\n    \"\"\"\n    color_palette = getattr(cm.linear, palette)\n    # apply square root data normalization\n    transformed_data = transform_data(data[key_col_name], transformation)\n    colormap = color_palette.to_step(n=9, data=(transformed_data))    \n    colormap.caption = f\"{key_col_name} cases ({transformation})\"\n    \n    # styling options\n    style_function = lambda feature: {\"weight\":0.5, \n                                      'color':'black',\n                                      'fillColor':colormap(feature['properties'][key_col_name]), \n                                      'fillOpacity':0.5}\n    highlight_function = lambda x: {'fillColor': '#000000', \n                                    'color':'#000000', \n                                    'fillOpacity': 0.50, \n                                    'weight': 0.1}\n    geo_layer=folium.features.GeoJson(\n            data,\n            style_function=style_function,\n            name=f\"{key_col_name} cases\",\n            overlay=True,\n            show=is_active,\n            highlight_function=highlight_function,\n            tooltip=folium.features.GeoJsonTooltip(fields=[merge_column, key_col_name],\n                aliases=[f'{merge_column}',f\"{key_col_name} cases\"],\n                style=(\"background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;\"),\n                sticky=True\n            )\n        )\n    colormap.add_to(base_map)\n    base_map.add_child(geo_layer)\n    \n    return base_map\n\ndef marker_cluster_with_choropleth(data, marker_col_list, key_col_dict=None, geojson_path=wd_geo_data_path, \n                                   gdp_merge_column='Country\/Region', gpd_column='name', transformation='log10'):\n    \"\"\"Create a folium map with marker cluster and optional choropleth layers.\n\n    Args:\n        data (dataframe): Dataframe for creating vizualization.\n        key_col_dict (dict): Dict including column names of dataframe for choropleth visualization with corresponding colorbrewer palette.\n        marker_col_list (list): List of the columns used for marker points visualization.\n        geojson_path (os.path): File path of related geojson file.\n        gdp_merge_column(string): In which column of original dataframe will be used to merge with geopandas dataframe.\n        gpd_column(string): In which column of geopandas dataframe will be used for dataframe merge to get the geometry.\n        transformation(string): In which transformation will be applied to data for visualization.\n\n    Returns:\n        m (Folium map): Created map.\n    \"\"\"\n    # variables for map creation\n    radius_min = 5\n    radius_max = 100\n    weight = 1\n    fill_opacity = 0.5\n    color = 'red'\n    \n    # read related geopandas dataframe from path and select related columns\n    geopandas_df = gpd.read_file(geojson_path)[[gpd_column, 'geometry']]\n    #print(geopandas_df)\n    #print(data[gdp_merge_column])\n    \n    \n    # calculate center of the given map\n    x_map=geopandas_df.centroid.x.mean()\n    y_map=geopandas_df.centroid.y.mean()\n    \n    # set a base map\n    m = folium.Map(location=[x_map, y_map], zoom_start=2, tiles='CartoDB positron', control=False)\n    \n    # iterate over each key columns with palette to create choropleth layers if not none\n    # make active only one chropleth layer to avoid overlayying all layers\n    if key_col_dict is not None:\n        # groupby given dataframe by given merger column because choropleth layers give higher level of overview.\n        valid_col_list = list(key_col_dict.keys()) + [gdp_merge_column]\n        choropleth_df = data.groupby(gdp_merge_column)[valid_col_list].sum().reset_index()\n        # merge geopandas dataframe with original one to create full geopandas dataframe\n        choropleth_df = geopandas_df.merge(choropleth_df, right_on=gdp_merge_column, left_on=gpd_column)\n        is_active = True\n        for col_name, palette in key_col_dict.items():\n            m = create_choropleth(m, choropleth_df, col_name, gdp_merge_column, palette, transformation, is_active=is_active)\n            is_active = False\n    \n    # add marker cluster\n    marker_cluster = folium.plugins.MarkerCluster(name=f'{color} circle markers').add_to(m)\n    \n    # rename columns with special chars because named tuple not allows these kinds of col names\n    new_col_names = {'Country\/Region': 'cr_rg', 'Province\/State': 'pr_st', 'Still Infected': 'Still_Infected'}\n    marker_col_list = [new_col_names[col] if col in new_col_names and col in data.columns  else col for col in marker_col_list]\n    data = data.rename(columns=new_col_names)\n    \n    column_list = marker_col_list + [col for col in ['Lat', 'Long', 'cr_rg', 'pr_st'] if col in data.columns]\n    for row in data[column_list].itertuples(index=False):\n        popup_text = '<strong>City<\/strong>: ' + str(getattr(row, 'pr_st')).capitalize() + '<br>'\n        if gdp_merge_column == 'Country\/Region':\n            popup_text = ('<strong>Country<\/strong>: ' + str(getattr(row, 'cr_rg')).capitalize() + '<br>') + popup_text\n        \n        # default value for counting total incidents\n        total_incidents = 1\n        for info_column in marker_col_list:\n            val = getattr(row, info_column)\n            total_incidents += int(val)\n            popup_text += f'<strong>{info_column}<\/strong>: ' + str(val) + '<br>'\n        \n        radius = np.clip(np.sqrt(total_incidents),radius_min,radius_max)\n        folium.CircleMarker([getattr(row, 'Lat'), getattr(row, 'Long')],\n                            radius=radius,\n                            color=color,\n                            fill=True,\n                            fill_color=color,\n                            popup = (popup_text),\n                            fill_opacity=fill_opacity ).add_to(marker_cluster)\n    \n    folium.LayerControl().add_to(m)\n    m.keep_in_front(marker_cluster)\n    \n    return m","4ee13783":"covid_df_confirmed_timeline = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_confirmed.csv\")\ncovid_df_deaths_timeline = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_deaths.csv\")\n\ncovid_df_full = pd.read_csv('..\/input\/corona-virus-report\/covid_19_clean_complete.csv', parse_dates=['Date'])\ncovid_df_detailed = pd.read_csv('..\/input\/novel-corona-virus-2019-dataset\/COVID19_open_line_list.csv', \n                                parse_dates=['date_onset_symptoms', 'date_admission_hospital', 'date_confirmation', 'travel_history_dates'])\n# get datasets for population information\nworld_population = pd.read_csv('..\/input\/population-by-country-2020\/population_by_country_2020.csv')\nchina_prov_pop = pd.read_csv('..\/input\/china-provinces-population\/china_provinces_population.csv')","62806603":"# firstly replacing country names suitable for the merge with population dataset\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Mainland China\", \"China\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"US\", \"United States\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"UK\", \"United Kingdom\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Russian Federation\", \"Russia\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Korea, South\", \"South Korea\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Republic of Moldova\", \"Moldova\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Viet Nam\", \"Vietnam\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Taiwan\\*\", \"Taiwan\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Congo \\(Kinshasa\\)\", \"DR Congo\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Czechia\", \"Czech Republic (Czechia)\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Cote d'Ivoire\", \"C\u00f4te d'Ivoire\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Iran \\(Islamic Republic of\\)\", \"Iran\")\n# merge with population dataset\ncovid_df_full = covid_df_full.merge(world_population, how=\"left\", right_on='Country (or dependency)', left_on=\"Country\/Region\")\n# rename columns \ncovid_df_full = covid_df_full.rename(columns={'Population (2020)': 'Population'})\n# add missing countries population\ncountries={'Reunion': (859959, 35.9)}\nfor country, (pop, med_age) in countries.items():\n    covid_df_full.loc[covid_df_full['Country\/Region']== country, 'Population'] = pop\n    covid_df_full.loc[covid_df_full['Country\/Region']== country, 'Med. Age'] = med_age\n\n# then replace back or edit country names to match with country boundary dataset for creation of maps\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"United States\", \"United States of America\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"North Macedonia\", \"Macedonia\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Serbia\", \"Republic of Serbia\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Czech Republic \\(Czechia\\)\", \"Czech Republic\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"C\u00f4te d'Ivoire\", \"Ivory Coast\")\ncovid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"DR Congo\", \"Democratic Republic of the Congo\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(r'\\bCongo\\b', \"Republic of the Congo\")","589a447d":"# clean detailed dataframe\ncovid_df_detailed = covid_df_detailed.dropna(axis=0, how='all').dropna(axis=1, how='all')\ncovid_df_detailed[\"sex\"] = covid_df_detailed[\"sex\"].str.replace(\"male\", \"Male\")\ncovid_df_detailed[\"sex\"] = covid_df_detailed[\"sex\"].str.replace(\"female\", \"Female\")\ncovid_df_detailed[\"sex\"] = covid_df_detailed[\"sex\"].str.replace(\"feMale\", \"Female\")\ncovid_df_detailed[\"sex\"] = covid_df_detailed[\"sex\"].str.replace(\"FeMale\", \"Female\")\ncovid_df_detailed = covid_df_detailed[(covid_df_detailed[\"sex\"] == 'Male') | (covid_df_detailed[\"sex\"] == 'Female')]\n\n# select valid columns\nvalid_columns = ['Province\/State', 'Country\/Region', 'Lat', 'Long', 'Date', 'Confirmed', 'Deaths', 'Recovered', 'Population', 'Med. Age']\ncovid_df_full = covid_df_full[valid_columns]\n\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Mainland China\", \"China\")\n#  # rename some countries to match with word countries.json and our dataframe names\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"US\", \"United States of America\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"UK\", \"United Kingdom\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Russian Federation\", \"Russia\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Korea, South\", \"South Korea\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Serbia\", \"Republic of Serbia\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Republic of Moldova\", \"Moldova\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Taipei and environs\", \"Taiwan\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Viet Nam\", \"Vietnam\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"North Macedonia\", \"Macedonia\")\n# covid_df_full[\"Country\/Region\"] = covid_df_full[\"Country\/Region\"].str.replace(\"Iran \\(Islamic Republic of\\)\", \"Iran\")\n\n# create a column indicating the number of still infected people, and several rates\ncovid_df_full = add_additional_cols(covid_df_full, col_list=['Still Infected'])\n# filling missing values with NA and 0\ncovid_df_full[['Province\/State']] = covid_df_full[['Province\/State']].fillna('N\/A')\ncovid_df_full[['Confirmed', 'Deaths', 'Recovered']] = covid_df_full[['Confirmed', 'Deaths', 'Recovered']].fillna(0)\n\n# cases in the Diamond Princess cruise ship\ndiamond_ship = covid_df_full[covid_df_full['Country\/Region'] == 'Cruise Ship']\n# country based dataframe\ncovid_df = covid_df_full[covid_df_full['Country\/Region'] != 'Cruise Ship']\n# rest of world excluding china\nexl_china = covid_df[covid_df['Country\/Region']!='China']\n# china dataframe\nchina = covid_df[covid_df['Country\/Region']=='China']\n# merge with population dataset for china provinces and create columns\nvalid_columns = ['Province\/State', 'Country\/Region', 'Lat', 'Long', 'Date', 'Confirmed', 'Deaths', 'Recovered', 'Still Infected', 'Population']\nchina = china.drop(['Population'], axis=1)\nchina = china.merge(china_prov_pop, how=\"left\", right_on='PROVINCE NAME', left_on='Province\/State')\nchina = china.rename(columns={'POPULATION': 'Population'})[valid_columns]\nchina = add_additional_cols(china, col_list=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'])\n\n\n\n# dataframe for latest world situation\ncovid_df_latest = covid_df[covid_df['Date'] == max(covid_df['Date'])].reset_index()\n# dataframe for latest world situation excluding china\nexl_china_latest = covid_df_latest[covid_df_latest['Country\/Region']!='China']\n# dataframe for latest china situation (including regions)\nchina_latest = china[china['Date'] == max(china['Date'])].reset_index()\n\n# dataframe for countries\ncovid_df_latest_country = covid_df_latest.groupby(['Country\/Region', 'Population', 'Med. Age', 'Date'])['Confirmed', 'Deaths', 'Recovered', 'Still Infected'].sum().reset_index()\n# add extra columns\ncovid_df_latest_country = add_additional_cols(covid_df_latest_country, col_list=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'])\n# dataframe for countries excluding china\nexl_china_latest_country = covid_df_latest_country[covid_df_latest_country['Country\/Region']!='China']\n# dataframe for whole china province by province\nchina_latest_country = china_latest.groupby(['Province\/State', 'Population'])['Confirmed', 'Deaths', 'Recovered', 'Still Infected'].sum().reset_index()\nchina_latest_country = add_additional_cols(china_latest_country, col_list=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'])\nvalid_columns = ['Province\/State', 'Confirmed', 'Deaths', 'Recovered', 'Still Infected', 'Population', 'Infection coverage', \n                 'Still infected coverage', 'Mortality rate', 'Recovery rate']\nchina_latest_country = china_latest_country[valid_columns]","1f36c8b2":"# get overall results by date\noverall_df = covid_df_latest_country.groupby('Date')['Population', 'Confirmed', 'Deaths', 'Recovered', 'Still Infected'].sum().reset_index()\noverall_df = add_additional_cols(overall_df, col_list=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'])\noverall_df['Population'] = (round(overall_df['Population'].astype(float)\/1000000000, 3)).astype(str) + 'BB'\ndisplay_tabular_df(overall_df, cmap='Blues')","89263492":"# plot overall treemap\nmelted_df = covid_df_latest_country.melt(id_vars=\"Country\/Region\", value_vars=['Still Infected', 'Deaths', 'Recovered'])\nfig = px.treemap(melted_df, path=[\"variable\", \"Country\/Region\"], values=\"value\", height=600, \n                color='variable', color_discrete_sequence = [d, r, i])\nfig.show()","99853b60":"display(HTML('''<div class=\"flourish-embed flourish-chart\" data-src=\"story\/230085\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))","30927f16":"temp = covid_df_latest_country[covid_df_latest_country['Confirmed']==\n                               covid_df_latest_country['Deaths']+\n                               covid_df_latest_country['Recovered']]\ndisplay_tabular_df(temp, columns=['Country\/Region', 'Confirmed', 'Deaths', 'Still Infected', 'Recovered'], sort_col='Confirmed', cmap='Greens')","087d446b":"temp = covid_df_latest_country[covid_df_latest_country['Confirmed'] == covid_df_latest_country['Recovered']]\n\ndisplay_tabular_df(temp, columns=['Country\/Region', 'Confirmed', 'Recovered'], sort_col='Confirmed', cmap='Greens')","7f161fb4":"temp = covid_df_latest_country[covid_df_latest_country['Recovered'] == 0]\n\ndisplay_tabular_df(temp, columns=['Country\/Region', 'Confirmed', 'Deaths', 'Still Infected', 'Recovered'], sort_col='Confirmed')","82a1fb7a":"temp = covid_df_latest_country[covid_df_latest_country['Confirmed'] == covid_df_latest_country['Deaths']]\ndisplay_tabular_df(temp, columns=['Country\/Region', 'Confirmed', 'Deaths'], sort_col='Confirmed')","ee292fc4":"temp = covid_df_latest_country[(covid_df_latest_country['Confirmed'] != 0) &( covid_df_latest_country['Deaths'] == 0)]\ndisplay_tabular_df(temp, columns=['Country\/Region', 'Confirmed', 'Deaths', 'Recovered', 'Still Infected'], sort_col='Confirmed')","af020061":"df_spread = covid_df.groupby('Date')['Population', 'Confirmed', 'Deaths', 'Recovered', 'Still Infected'].sum().reset_index()\n\ndf_spread_rates = add_additional_cols(df_spread, col_list=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'])\ndf_spread_rates = df_spread_rates.melt(id_vars=\"Date\", value_vars=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'],\n                                       var_name='Case', value_name='Rate')\ndf_spread_cases = df_spread.melt(id_vars=\"Date\", value_vars=['Recovered', 'Deaths', 'Still Infected'],\n                                 var_name='Case', value_name='Count')\n\nfig = px.area(df_spread_cases, x=\"Date\", y=\"Count\", color='Case',\n              title='Cases over time in the world', \n              color_discrete_sequence = [r, d, i], log_y=True)\nfig.show()\n\n\nfig = px.line(df_spread_rates, x=\"Date\", y=\"Rate\", color='Case', \n             title='Rates over time in the world', color_discrete_sequence = [ic, si, mr, rr], log_y=True)\nfig.show()\n\ndf_spread_country_line = covid_df.groupby(['Date', 'Country\/Region'])['Confirmed'].sum().reset_index().sort_values('Confirmed', ascending=False)\nfig = px.line(df_spread_country_line, x=\"Date\", y=\"Confirmed\", color='Country\/Region', title='Confirmed cases in the world', height=600)\nfig.show()","f5d85eb3":"spread = covid_df_full[covid_df_full['Confirmed'] > 0].groupby('Date')['Country\/Region'].nunique()\nspread = pd.DataFrame(spread).reset_index()\n\nfig = px.line(spread, x='Date', y='Country\/Region',\n              title='Number of Countries\/Regions the pandemic spread over time',\n            )\nfig.update_traces(textposition='top center')\nfig.show()","ea6eab96":"temp = covid_df_full.groupby(['Country\/Region', 'Date'])['Confirmed', 'Deaths', 'Recovered']\ntemp = temp.sum().diff().reset_index()\n\nmask = temp['Country\/Region'] != temp['Country\/Region'].shift(1)\n\ntemp.loc[mask, 'Confirmed'] = np.nan\ntemp.loc[mask, 'Deaths'] = np.nan\ntemp.loc[mask, 'Recovered'] = np.nan\n\nfig = px.bar(temp, x=\"Date\", y=\"Confirmed\", color='Country\/Region',title='New cases over time')\nfig.show()","e4178a0e":"lower_threshold=1000\nfactor_df, date_c_name, count_c_name, difference_c_name, factor_c_name = find_factor_of(covid_df_latest_country, covid_df_full, 'Confirmed', 2, lower_threshold=lower_threshold, limit=10)\nfig = px.bar(factor_df, x=difference_c_name, y='Country\/Region', color='Country\/Region', labels = {difference_c_name:'Number of days'}, \n             text=factor_c_name, title=f'Number of days a country at least doubled its confirmed case (Confirmed cases > {lower_threshold})',\n             hover_data=['Date since', 'Count on this date', 'Count now'],\n             orientation='h')\nfig.update_traces(textposition='outside')\nfig.show()","947e6008":"display(HTML('''<div class=\"flourish-embed flourish-chart\" data-src=\"story\/230114\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))\n","b862589f":"lower_threshold=10\n\nfactor_df, date_c_name, count_c_name, difference_c_name, factor_c_name = find_factor_of(covid_df_latest_country, covid_df_full, 'Deaths', 2, lower_threshold=lower_threshold, limit=10)\nfig = px.bar(factor_df, x=difference_c_name, y='Country\/Region', color='Country\/Region', labels = {difference_c_name:'Number of days'}, \n             text=factor_c_name, title=f'Number of days a country at least doubled its death case (Death cases > {lower_threshold})',\n             hover_data=['Date since', 'Count on this date', 'Count now'],\n             orientation='h')\nfig.update_traces(textposition='outside')\nfig.show()","78454683":"lower_threshold=1000\n\nfactor_df, date_c_name, count_c_name, difference_c_name, factor_c_name = find_factor_of(covid_df_latest_country, covid_df_full, 'Recovered', 2, lower_threshold=lower_threshold, limit=10)\nfig = px.bar(factor_df, x=difference_c_name, y='Country\/Region', color='Country\/Region', labels = {difference_c_name:'Number of days'}, \n             text=factor_c_name, title=f'Number of days a country at least doubled its recovered case (Recovered cases > {lower_threshold})',\n             hover_data=['Date since', 'Count on this date', 'Count now'],\n             orientation='h')\nfig.update_traces(textposition='outside')\nfig.show()","06153e90":"key_column_dict = {'Confirmed': 'YlGnBu_09', 'Deaths': 'YlOrRd_09', 'Recovered': 'BuGn_09', 'Still Infected': 'PuBu_09' }\nmarker_cluster_with_choropleth(covid_df_latest, ['Deaths', 'Recovered', 'Still Infected'], key_col_dict=key_column_dict, transformation='square root')","d04207fd":"key_column_dict = {'Confirmed': 'ice', 'Deaths': 'oryel', 'Recovered': 'mint', 'Still Infected': 'ylorbr' }\nfig = plotly_graph(covid_df_latest_country, key_col_dict=key_column_dict)\nfig.show()","9b1989f9":"display(HTML('''<div class=\"flourish-embed flourish-table\" data-src=\"story\/230195\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))\n","3de2e2ab":"df_spread_world = covid_df_full.groupby(['Date', 'Country\/Region'])['Confirmed', 'Deaths', 'Recovered'].max().reset_index()\ndf_spread_world['Date'] = df_spread_world['Date'].dt.strftime('%m\/%d\/%Y')\ndf_spread_world['size'] = (df_spread_world['Confirmed'] + df_spread_world['Deaths'] + df_spread_world['Recovered']).pow(0.3)\n\nfig = px.scatter_geo(df_spread_world, locations=\"Country\/Region\", locationmode='country names', \n                     color='Confirmed', size='size', hover_data=['Confirmed', 'Deaths', 'Recovered'], \n                     range_color= [0, max(df_spread_world['Deaths']) + 2], \n                     projection=\"natural earth\", animation_frame=\"Date\", \n                     title='Death cases over time in the world')\nfig.update(layout_coloraxis_showscale=False)\nfig.show()","ca5cfab1":"sorted_death_case = covid_df_latest_country.sort_values('Deaths', ascending=False).head(20)\nfig=px.pie(sorted_death_case, \"Country\/Region\", \"Deaths\", hover_data=['Confirmed'], title=\"Top 20 countries by number of deaths\")\nfig.update_traces(textposition='inside', textinfo='percent+label')\nfig.show()","fae62756":"sorted_confirmed_cases = covid_df_latest_country.sort_values('Confirmed', ascending=True)\nsorted_confirmed_cases = sorted_confirmed_cases[sorted_confirmed_cases['Population'] > 1000000]\nsorted_mortality_rate = sorted_confirmed_cases[sorted_confirmed_cases['Mortality rate'] > 0].sort_values('Mortality rate', ascending=True)\n\nrows, cols = 2, 1\nmain_title = 'Countries sorted by different features (population > 1M)'\ntitles = ('Confirmed cases', \"Mortality rate \")\ndf_list = [sorted_confirmed_cases, sorted_mortality_rate]\nplotly_bar_plot(df_list, [valid_case_columns, valid_mortality_columns], ['Country\/Region']*len(df_list), \n                titles, title=main_title, rows=rows, cols=cols, is_stacked=True, height=1500, v_space=0.05, h_space=0.2).show()","334633ca":"sorted_confirmed_cases = covid_df_latest_country.sort_values('Confirmed', ascending=True)\nsorted_confirmed_cases = sorted_confirmed_cases[sorted_confirmed_cases['Population'] > 1000000]\nsorted_recovery_rate = sorted_confirmed_cases[sorted_confirmed_cases['Recovery rate'] > 0].sort_values('Recovery rate', ascending=True)\nsorted_infection_coverage = sorted_confirmed_cases[sorted_confirmed_cases['Infection coverage'] > 0].sort_values('Infection coverage', ascending=True)\n\nrows, cols = 2, 1\n# main_title = 'Countries sorted by different features (population > 1M)'\ntitles = (\"Infection coverage\", \"Recovery rate\")\nplotly_bar_plot([sorted_infection_coverage, sorted_recovery_rate], \n                [valid_mortality_columns, valid_mortality_columns], ['Country\/Region']*len(titles), \n                titles, title=None, rows=rows, cols=cols, is_stacked=True, height=1500, v_space=0.05, h_space=0.2).show()","a92f855d":"sorted_death_case = covid_df_latest_country.sort_values('Deaths', ascending=False).head(10)[::-1]\nplotly_bar_plot([sorted_death_case], [valid_case_columns], ['Country\/Region'], [('Top 10 countries by deaths')], rows=1, cols=1 , height=500, is_stacked=True).show()","67e41166":"# get top n most confirmed cases\ntop_n_country = 10\nsorted_confirmed_case = covid_df_latest_country.sort_values('Confirmed', ascending=False).head(10)[:top_n_country]\n# exclude china and get other country names\ncountries = sorted_confirmed_case[sorted_confirmed_case['Country\/Region'] != 'China']['Country\/Region']\ntemp = covid_df_full[covid_df_full['Country\/Region'].isin(countries)].groupby(['Date', 'Country\/Region'])['Confirmed'] \\\n       .sum().reset_index().sort_values(by=['Date', 'Country\/Region'])\n\ndf_list, subtitle_list = [], []\nfor index, country in enumerate(countries.tolist()):\n    df_list.append(temp[temp['Country\/Region']==country])\n    subtitle_list.append(f'{index+1}.{country}')\n\nrows, cols = 5, 2\nplotly_scatter_plot(df_list, ['Date']*top_n_country, [['Confirmed']]*top_n_country, \n                    subtitle_list, title=f'Top {top_n_country} countries by confirmed cases (excl. China)', \n                    rows=rows, cols=cols, v_space=0.05, h_space=0.1, height=1500)\n","c01a09f5":"# get top n most death cases\ntop_n_country = 10\nsorted_death_case = covid_df_latest_country.sort_values('Deaths', ascending=False).head(10)[:top_n_country]\n# exclude china and get other country names\ncountries = sorted_death_case[sorted_death_case['Country\/Region'] != 'China']['Country\/Region']\ntemp = covid_df_full[covid_df_full['Country\/Region'].isin(countries)].groupby(['Date', 'Country\/Region'])['Deaths'] \\\n       .sum().reset_index().sort_values(by=['Date', 'Country\/Region'])\n\ndf_list, subtitle_list = [], []\nfor index, country in enumerate(countries.tolist()):\n    df_list.append(temp[temp['Country\/Region']==country])\n    subtitle_list.append(f'{index+1}.{country}')\n\n\nrows, cols = 5, 2\nplotly_scatter_plot(df_list, ['Date']*top_n_country, [['Deaths']]*top_n_country, \n                    subtitle_list, title=f'Top {top_n_country} countries by death cases (excl. China)', \n                    rows=rows, cols=cols, v_space=0.05, h_space=0.1, height=1500)\n","4e889087":"sorted_confirmed_case = covid_df_latest_country.sort_values('Confirmed', ascending=False).head(10)\n\ntemp = covid_df_full[covid_df_full['Country\/Region'].isin(sorted_confirmed_case['Country\/Region'])] \\\n        .groupby(['Date', 'Country\/Region']) \\\n        ['Confirmed', 'Deaths', 'Recovered', 'Still Infected'] \\\n        .sum().reset_index().sort_values('Date', ascending=True)\ntemp['Date'] = temp['Date'].dt.strftime('%m\/%d\/%Y')\n\nfig = px.line(temp, x=\"Confirmed\", y=\"Deaths\", color='Country\/Region',animation_frame=\"Date\",\n              title='Confirmed - Death cases for top 10 countries over time', text='Country\/Region', \n              range_x=[min(temp[\"Confirmed\"]+1), max(temp[\"Confirmed\"]+50000)], \n              range_y=[min(temp[\"Deaths\"]+1), max(temp[\"Deaths\"]+5000)], log_x=True, log_y=True)\nfig.update_traces(textposition='top center')\nfig.show()","30009502":"def from_china_or_not(row):\n    if row['Country\/Region']=='China':\n        return 'From China'\n    else:\n        return 'Outside China'\n    \ntemp = covid_df_full.copy()\ntemp['Region'] = temp.apply(from_china_or_not, axis=1)\ntemp = temp.groupby(['Region', 'Date'])['Confirmed', 'Deaths', 'Recovered']\ntemp = temp.sum().diff().reset_index()\nmask = temp['Region'] != temp['Region'].shift(1)\ntemp.loc[mask, 'Confirmed'] = np.nan\ntemp.loc[mask, 'Deaths'] = np.nan\ntemp.loc[mask, 'Recovered'] = np.nan\n\nfig = px.bar(temp, x='Date', y='Confirmed', color='Region', barmode='group', \n             text='Confirmed', title='New confirmed cases over time (China vs Row)', color_discrete_sequence= [c, d, r])\nfig.update_traces(textposition='outside')\nfig.show()","6e9a457a":"# create a updated csv file for world data to upload it to flourish\ncovid_df_confirmed_timeline_country = covid_df_confirmed_timeline.drop(['Lat', 'Long', 'Province\/State'], axis=1)\ncovid_df_confirmed_timeline_country = covid_df_confirmed_timeline_country.groupby('Country\/Region').sum().reset_index()\ncovid_df_confirmed_timeline_country.to_csv('ts_covid_19_confirmed_country.csv')\n\ncovid_df_deaths_timeline_country = covid_df_deaths_timeline.drop(['Lat', 'Long', 'Province\/State'], axis=1)\ncovid_df_deaths_timeline_country = covid_df_deaths_timeline_country.groupby('Country\/Region').sum().reset_index()\ncovid_df_deaths_timeline_country.to_csv('ts_covid_19_deaths_country.csv')\n\ncase_lower_limit = 1000\nvalid_countries = covid_df_latest_country[covid_df_latest_country['Confirmed'] > case_lower_limit]['Country\/Region']\ncovid_df_mr_timeline_country = covid_df_full[covid_df_full['Country\/Region'].isin(valid_countries)].groupby(['Country\/Region', 'Date'])['Confirmed', 'Deaths'].sum().reset_index()\ncovid_df_mr_timeline_country = add_additional_cols(covid_df_mr_timeline_country, col_list=['Mortality rate'])\ncovid_df_mr_timeline_country = covid_df_mr_timeline_country[['Country\/Region', 'Date', 'Mortality rate']].pivot(index='Country\/Region', columns='Date', values='Mortality rate')\ncovid_df_mr_timeline_country.to_csv('ts_covid_19_mr_country.csv')\n\n\n# create a updated csv file for China to upload it to flourish\ncovid_df_confirmed_timeline_country = covid_df_confirmed_timeline[covid_df_confirmed_timeline['Country\/Region'] == 'China'].drop(['Lat', 'Long', 'Country\/Region'], axis=1)\ncovid_df_confirmed_timeline_country = covid_df_confirmed_timeline_country.groupby('Province\/State').sum().reset_index()\ncovid_df_confirmed_timeline_country.to_csv('ts_covid_19_confirmed_china.csv')\n\ncovid_df_deaths_timeline_china = covid_df_deaths_timeline[covid_df_confirmed_timeline['Country\/Region'] == 'China'].drop(['Lat', 'Long', 'Country\/Region'], axis=1)\ncovid_df_deaths_timeline_china = covid_df_deaths_timeline_china.groupby('Province\/State').sum().reset_index()\ncovid_df_deaths_timeline_china.to_csv('ts_covid_19_deaths_china.csv')","23e070e6":"display(HTML('''<div class=\"flourish-embed flourish-bar-chart-race\" data-src=\"visualisation\/1587078\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))\ndisplay(HTML('''<div class=\"flourish-embed flourish-bar-chart-race\" data-src=\"visualisation\/1591912\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))\ndisplay(HTML('''<div class=\"flourish-embed flourish-bar-chart-race\" data-src=\"visualisation\/1794123\" data-url=\"https:\/\/flo.uri.sh\/visualisation\/1794123\/embed\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))\ndisplay(HTML('''<div class=\"flourish-embed flourish-bar-chart-race\" data-src=\"visualisation\/1592295\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))\ndisplay(HTML('''<div class=\"flourish-embed flourish-bar-chart-race\" data-src=\"visualisation\/1592323\"><script src=\"https:\/\/public.flourish.studio\/resources\/embed.js\"><\/script><\/div>'''))","0b0c9e57":"key_column_dict = {'Confirmed': 'YlGnBu_09'}\nmarker_cluster_with_choropleth(china_latest.reset_index(), ['Confirmed', 'Deaths', 'Recovered', 'Still Infected'], key_col_dict=key_column_dict, \n                               geojson_path=ch_geo_data_path, gdp_merge_column='Province\/State', gpd_column='NAME_1', transformation='square root')","bffe652c":"sorted_china_cases = china_latest_country.sort_values('Confirmed', ascending=True).reset_index()\nsorted_china_mortality_rate = china_latest_country.sort_values('Mortality rate', ascending=True).reset_index()\n\nrows, cols = 2, 1\nmain_title = 'China sorted by different features'\ntitles = ('Confirmed cases', 'Mortality rate')\ndf_list = [sorted_china_cases, sorted_china_mortality_rate]\nplotly_bar_plot(df_list, [valid_case_columns, valid_mortality_columns], ['Province\/State']*len(df_list), titles, is_stacked=True, title=main_title, rows=rows, cols=cols).show()","55d6321c":"df_spread = china.groupby('Date')['Population', 'Confirmed', 'Deaths', 'Recovered', 'Still Infected'].sum().reset_index()\n\ndf_spread_rates = add_additional_cols(df_spread, col_list=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'])\ndf_spread_rates = df_spread_rates.melt(id_vars=\"Date\", value_vars=['Infection coverage', 'Still infected coverage', 'Mortality rate', 'Recovery rate'],\n                                       var_name='Case', value_name='Rate')\ndf_spread_cases = df_spread.melt(id_vars=\"Date\", value_vars=['Recovered', 'Deaths', 'Still Infected'],\n                                 var_name='Case', value_name='Count')\n\nfig = px.line(df_spread_cases, x=\"Date\", y=\"Count\", color='Case',\n              title='Cases over time in China', \n              color_discrete_sequence = [r, d, i], log_y=True)\nfig.show()\n\n\nfig = px.line(df_spread_rates, x=\"Date\", y=\"Rate\", color='Case',\n             title='Rates over time in China', color_discrete_sequence = [ic, si, mr, rr], log_y=True)\nfig.show()\n\ndf_spread_country_line = china.groupby(['Date', 'Province\/State'])['Confirmed'].sum().reset_index().sort_values('Confirmed', ascending=False)\nfig = px.line(df_spread_country_line, x=\"Date\", y=\"Confirmed\", color='Province\/State', title='Confirmed cases in China provinces', height=600, log_y=True)\nfig.show()","530b5c42":"sex_distr = covid_df_detailed['sex'].value_counts()\nfig = px.pie(sex_distr,sex_distr.index, sex_distr, title=\"Gender distribution on confirmed cases globally\")\nfig.update_traces(textposition='inside', textinfo='percent+label')\n\nfig.show()","661e0b0b":"age_distr = handle_age(covid_df_detailed)\nfig = px.pie(age_distr, age_distr.index, age_distr, title=\"Age distribution on confirmed cases globally\")\nfig.update_traces(textposition='inside', textinfo='percent+label')\n\nfig.show()","a87a7184":"out = covid_df_detailed['symptoms'].str.split('[,;]\\s+', expand=True).stack()\nout[out.str.contains('fever', case=False, na=False)] = 'fever'\n# out[out.str.contains('sore throat', case=False, na=False)] = 'sore throat'\n# out[out.str.contains('fatigue', case=False, na=False)] = 'fatigue'\nvc = out.str.lower().value_counts().loc[lambda x : x>1] \nfig = px.pie(vc, vc.index, vc, title=\"Symptom distribution on confirmed cases globally\")\nfig.update_traces(textposition='inside', textinfo='percent+label')\n\nfig.show()","f0fbd3ce":"Several new columns has been created. Here is the explanations:\n* **Infection coverage**: The number of all confirmed cases per 1 million people. Higher value means a country has been effected more from the plague.\n* **Still infected coverage**: The number of still infected cases per 1 million people. Higher value means more people from a country has still being infected.\n* **Mortality rate**: The percentage of death cases on all confirmed cases. Higher value means more people from a country has been dead.\n* **Recovery rate**: The percentage of recovered cases on all confirmed cases. Higher value means more people from a country has been revived.","4d4ea9dc":"In the figure below, CFR rate is basically the same with mortality rate. For more details: https:\/\/ourworldindata.org\/coronavirus#the-covid-19-pandemic","4f3714c8":"**Data wrangling**","bdc214dc":"# Situation of countries","73cc82b9":"In the figure below, top 10 countries that doubled their given (confirmed, deaths, revived etc.) cases in shortest amount of days have been depicted. Number of days indicates the number of days a country at least doubled its given case and factor indicates the ratio between latest number of given cases and the latest date the confirmed cases doubled since. Therefore, fewer number of days show a worse result incase of the contagion of pandemic if given case is either confirmed or death.","a9905e83":"# Overall summary of the pandemic","8d767759":"### Countries with %0 recovery rate (no cases recovered)","1b70aa5e":"![Coronavirus-CFR-by-health-condition-in-China.png](attachment:Coronavirus-CFR-by-health-condition-in-China.png)","bd560abe":"### Countries with %100 mortality rate (all cases died)","6458e6b2":"# References\n* https:\/\/www.kaggle.com\/imdevskp\/covid-19-analysis-visualization-comparisons\/#data\n* https:\/\/www.kaggle.com\/parulpandey\/wuhan-coronavirus-a-geographical-analysis\/#data","a920fa89":"All values given in this analysis is cumulative count, meaning the number includes all instances from the beginning of the plague until the date given. For example, China has around 80k confirmed cases on 2020-04-04, meaning around 80k confirmed cases recorded from the beginning to this date in total.","3ee227ae":"### Added columns","20bab12c":"Firstly, lets check **countries with different aspects**. You can check region based confirmed cases per country by clicking red bubles. You can change layer of the map by using right-top layer control menu.","258464da":"### Note that, on individual level, our data is highly incomplete and biased for the moment the analysis has been made.","8b344a6b":"### Countries with %0 still infected coverage (no still infected cases)","d1c94dfb":"# Situation of China","9bc09769":"# Inspection of the pandemic on individual level","3691d0c4":"### Confirmed, Deaths, Recovered, and Still Infected cases by countries","4f04ddf3":"### Countries with %100 recovery rate (all cases recovered)","d1f51e1d":"You can edit the race bar graphs below using the following links.\n* Confirmed cases: https:\/\/public.flourish.studio\/visualisation\/1587078\/\n* Death cases: https:\/\/public.flourish.studio\/visualisation\/1591912\/\n* Mortality rate: \n* China confirmed cases: https:\/\/public.flourish.studio\/visualisation\/1592295\/\n* China death cases: https:\/\/public.flourish.studio\/visualisation\/1592323\/","caea1535":"### Countries with %0 mortality rate (no cases died)","b6ed45b0":"![COVID-CFR-by-age.png](attachment:COVID-CFR-by-age.png)","79933f22":"### Overview of the pandemic","399715ab":"# <span style=\"color:blue\">Please upvote the kernel if you like, it will really be appreciated.<\/span>"}}