{"cell_type":{"e3bf91aa":"code","7fbf7b66":"code","310a7d34":"code","8414e75f":"code","dcc2eac5":"code","8dd4cae2":"code","caaea1a2":"code","3921a64f":"code","8a2c2cf7":"code","cab47209":"code","c7a725a5":"code","5320611e":"code","8eb37e69":"code","a83598fb":"code","31c2ff3d":"code","d1b2668e":"code","4fba08dc":"code","2b43f1e4":"code","9fb7cf72":"code","8e3f52bd":"code","9affbaa0":"code","1854e5e7":"code","e0164f63":"code","c17cc637":"code","a0dfab8b":"code","418ccc05":"code","18c09961":"code","d5d31958":"code","c2ef779a":"code","564c2771":"code","9880aa55":"code","e5dce180":"code","a5f8bf3c":"code","b589f142":"code","6513a844":"code","1298f7b6":"code","942753e7":"code","35807085":"code","666b1254":"code","81b11e34":"code","c2912f2c":"code","58b31d4b":"code","c4dd4a38":"code","4472bc21":"code","0a68db84":"code","46bfdd3f":"code","456fc264":"code","dc648dd5":"code","ef7885b2":"code","4ce50ecc":"code","4a1ed79b":"code","67cdc75f":"code","ea77edfa":"code","d06bf061":"code","68db95fd":"code","a61dbb13":"code","fb31f489":"markdown","5359fdb2":"markdown","e46f1c69":"markdown","bfc65941":"markdown","bb2ea468":"markdown","ee048860":"markdown"},"source":{"e3bf91aa":"import time\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom prettytable import PrettyTable\nfrom mlxtend.preprocessing import TransactionEncoder\nfrom mlxtend.frequent_patterns import apriori, association_rules, fpgrowth, fpmax","7fbf7b66":"groceries = pd.read_csv(\"..\/input\/groceries-dataset\/Groceries_dataset.csv\")","310a7d34":"groceries.head()","8414e75f":"groceries.groupby(['Member_number', 'Date'], as_index=False).agg({'itemDescription': list})","dcc2eac5":"groceries['itemDescription'].unique().shape","8dd4cae2":"all_transactions = [transaction[1]['itemDescription'].tolist() for transaction in list(groceries.groupby(['Member_number', 'Date']))]","caaea1a2":"len(all_transactions)","3921a64f":"all_transactions[0:10]","8a2c2cf7":"trans_encoder = TransactionEncoder() # Instanciate the encoder\ntrans_encoder_matrix = trans_encoder.fit(all_transactions).transform(all_transactions)\ntrans_encoder_matrix = pd.DataFrame(trans_encoder_matrix, columns=trans_encoder.columns_)","cab47209":"trans_encoder_matrix.head()","c7a725a5":"rule_items = apriori(trans_encoder_matrix, min_support=0.0001, use_colnames=True, max_len=2)\n\nrules = association_rules(rule_items, metric=\"lift\", min_threshold=1)\n\nrules.sort_values('lift', ascending=False)","5320611e":"rule_items","8eb37e69":"def perform_rule_calculation(transact_items_matrix, rule_type=\"fpgrowth\", min_support=0.001):\n    \"\"\"\n    desc: this function performs the association rule calculation \n    @params:\n        - transact_items_matrix: the transaction X Items matrix\n        - rule_type: \n                    - apriori or Growth algorithms (default=\"fpgrowth\")\n                    \n        - min_support: minimum support threshold value (default = 0.001)\n        \n    @returns:\n        - the matrix containing 3 columns:\n            - support: support values for each combination of items\n            - itemsets: the combination of items\n            - number_of_items: the number of items in each combination of items\n            \n        - the excution time for the corresponding algorithm\n        \n    \"\"\"\n    start_time = 0\n    total_execution = 0\n    \n    if(not rule_type==\"fpgrowth\"):\n        start_time = time.time()\n        rule_items = apriori(transact_items_matrix, \n                       min_support=min_support, \n                       use_colnames=True)\n        total_execution = time.time() - start_time\n        print(\"Computed Apriori!\")\n        \n    else:\n        start_time = time.time()\n        rule_items = fpgrowth(transact_items_matrix, \n                       min_support=min_support, \n                       use_colnames=True)\n        total_execution = time.time() - start_time\n        print(\"Computed Fp Growth!\")\n    \n    rule_items['number_of_items'] = rule_items['itemsets'].apply(lambda x: len(x))\n    \n    return rule_items, total_execution\n\ndef compute_association_rule(rule_matrix, metric=\"lift\", min_thresh=1):\n    \"\"\"\n    @desc: Compute the final association rule\n    @params:\n        - rule_matrix: the corresponding algorithms matrix\n        - metric: the metric to be used (default is lift)\n        - min_thresh: the minimum threshold (default is 1)\n        \n    @returns:\n        - rules: all the information for each transaction satisfying the given metric & threshold\n    \"\"\"\n    rules = association_rules(rule_matrix, \n                              metric=metric, \n                              min_threshold=min_thresh)\n    \n    return rules\n\ndef plot_metrics_relationship(rule_matrix, col1, col2):\n    \"\"\"\n    desc: shows the relationship between the two input columns \n    @params:\n        - rule_matrix: the matrix containing the result of a rule (apriori or Fp Growth)\n        - col1: first column\n        - col2: second column\n    \"\"\"\n    fit = np.polyfit(rule_matrix[col1], rule_matrix[col2], 1)\n    fit_funt = np.poly1d(fit)\n    plt.plot(rule_matrix[col1], rule_matrix[col2], 'yo', rule_matrix[col1], \n    fit_funt(rule_matrix[col1]))\n    plt.xlabel(col1)\n    plt.ylabel(col2)\n    plt.title('{} vs {}'.format(col1, col2))\n    \ndef compare_time_exec(algo1=list, alg2=list):\n    \"\"\"\n    @desc: shows the execution time between two algorithms\n    @params:\n        - algo1: list containing the description of first algorithm, where\n            \n        - algo2: list containing the description of second algorithm, where\n    \"\"\"\n    \n    execution_times = [algo1[1], algo2[1]]\n    algo_names = (algo1[0], algo2[0])\n    y=np.arange(len(algo_names))\n    \n    plt.bar(y,execution_times,color=['orange', 'blue'])\n    plt.xticks(y,algo_names)\n    plt.xlabel('Algorithms')\n    plt.ylabel('Time')\n    plt.title(\"Execution Time (seconds) Comparison\")\n    plt.show()","a83598fb":"fpgrowth_matrix, fp_growth_exec_time = perform_rule_calculation(trans_encoder_matrix)\nprint(\"Fp Growth execution took: {} seconds\".format(fp_growth_exec_time))","31c2ff3d":"fpgrowth_matrix.head()","d1b2668e":"fp_growth_rule_lift = compute_association_rule(fpgrowth_matrix)","4fba08dc":"fp_growth_rule_lift.head()","2b43f1e4":"plot_metrics_relationship(fp_growth_rule_lift, col1='lift', col2='confidence')","9fb7cf72":"fp_growth_rule = compute_association_rule(fpgrowth_matrix, metric=\"confidence\", min_thresh=0.2)\nfp_growth_rule.head()","8e3f52bd":"apriori_matrix, apriori_exec_time = perform_rule_calculation(trans_encoder_matrix, rule_type=\"apriori\")\nprint(\"Apriori Execution took: {} seconds\".format(apriori_exec_time))","9affbaa0":"apriori_matrix.head()","1854e5e7":"apriori_rule_lift = compute_association_rule(apriori_matrix)\napriori_rule_lift","e0164f63":"apriori_rule_lift['confidence'] == (apriori_rule_lift['support'] \/ apriori_rule_lift['antecedent support'])","c17cc637":"plot_metrics_relationship(apriori_rule_lift, col1='lift', col2='confidence')","a0dfab8b":"plot_metrics_relationship(apriori_rule_lift, col1='lift', col2='conviction')","418ccc05":"apripri_rule = compute_association_rule(apriori_matrix, metric=\"confidence\", min_thresh=0.2)\napripri_rule.head()","18c09961":"fp_growth_rule_lift.sort_values('lift')","d5d31958":"apriori_rule_lift.sort_values('lift')","c2ef779a":"apriori_rule_lift['antecedents']#.str.replace(\"(\", \"\", regex=True)#split(\"\")","564c2771":"!pip install pyECLAT","9880aa55":"operations = groceries.groupby(['Member_number', 'Date'], as_index=False).agg({'itemDescription': lambda x: \"; \".join(list(x))})['itemDescription'].str.split('; ',expand=True)\noperations","e5dce180":"from pyECLAT import ECLAT\n\neclat_instance = ECLAT(data=operations, verbose=True)","a5f8bf3c":"#eclat_instance","b589f142":"get_ECLAT_indexes, get_ECLAT_supports = eclat_instance.fit(min_support=0.001,\n                                                           min_combination=1,\n                                                           max_combination=1,\n                                                           separator=', ',\n                                                           verbose=True)","6513a844":"[f\"({i})\" for i in list(get_ECLAT_supports.keys())]","1298f7b6":"sup = pd.DataFrame({\n'support': list(get_ECLAT_supports.values()),\n'itemsets': [f\"({i})\" for i in list(get_ECLAT_supports.keys())]\n})\n\nrules = association_rules(sup, metric=\"lift\", min_threshold=1, support_only=True)\n\nrules","942753e7":"sup","35807085":"eclat_instance","666b1254":"## ARC","81b11e34":"!pip install pyarc","c2912f2c":"from pyarc import CBA\nfrom pyarc.data_structures import TransactionDB\nfrom pyarc.qcba.data_structures import QuantitativeDataFrame\nimport pandas as pd\nfrom pyarc.qcba import QCBA","58b31d4b":"from pyarc.qcba.data_structures import (\n    IntervalReader,\n    Interval,\n    QuantitativeDataFrame,\n    QuantitativeCAR\n)","c4dd4a38":"interval_reader = IntervalReader()\n\ninterval_reader.closed_bracket = \"\", \"NULL\"\ninterval_reader.open_bracket = \"NULL\", \"\"\ninterval_reader.infinity_symbol = \"inf\", \"inf\"\ninterval_reader.members_separator = \"_to_\"\n\ninterval_reader.compile_reader()\n\nQuantitativeCAR.interval_reader = interval_reader","4472bc21":"estate = pd.read_csv(\"..\/input\/kyiv-real-estate\/class_flat.csv\").select_dtypes(exclude=['int', 'float'])\nestate = estate.drop(columns = ['description', 'city', 'address'])\nestate['bad_proposal'] = pd.read_csv(\"..\/input\/kyiv-real-estate\/class_flat.csv\")['bad_proposal']\nestate.head()","0a68db84":"txns_train = TransactionDB.from_DataFrame(estate)\ntxns_train[0]","46bfdd3f":"CBA(support=0.01, confidence=0.01, algorithm=\"m2\")\ncba.fit(txns_train)\ncba.rule_model_accuracy(txns_train)","456fc264":"cba.clf.rules","dc648dd5":"set(cba.predict_probability(txns_train))","ef7885b2":"from sklearn.metrics import roc_auc_score\n\nroc_auc_score(estate['bad_proposal'], 1-np.array(cba.predict_probability(txns_train)))","4ce50ecc":"print(\"CBA accuracy:\", cba.rule_model_accuracy(txns_train))","4a1ed79b":"!pip install Cython pycspade","67cdc75f":"from pycspade.helpers import spade, print_result","ea77edfa":"positions_dict = {i:j for j, i in enumerate(groceries['itemDescription'].unique())}","d06bf061":"all_transactions_num = [[positions_dict[j] for j in i] for i in all_transactions]","68db95fd":"with open(\"trans.txt\", \"w\") as f:\n    f.write(\"\\n\".join([\" \".join(str(i)) for i in all_transactions_num]))","a61dbb13":"data = [[j,j, i] for j, i in enumerate(all_transactions_num)]\n\nresult = spade(data=data, support=0.001)\nprint_result(result)","fb31f489":"## ECLAT","5359fdb2":"## Fp Growph Algorithm","e46f1c69":"## CBA","bfc65941":"## Apriori","bb2ea468":"## Brute force","ee048860":"## cspade"}}