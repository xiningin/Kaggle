{"cell_type":{"3ff1c157":"code","4d684349":"code","d34206b6":"code","3883f6dc":"code","ff1eeaf7":"code","6c437232":"code","c736c287":"code","dcd9365a":"code","566eed04":"code","da99fd25":"code","32a75336":"code","fda90f43":"code","17638971":"code","3a00695d":"code","e0ec6af5":"code","759d26c7":"code","4429e7f8":"code","47d8234a":"code","364885c4":"code","d06d36d4":"code","34f83d30":"code","a762487a":"code","0f8e5b83":"markdown","4d90f5fb":"markdown","b605829b":"markdown","651d6016":"markdown","cc033d7e":"markdown","13d98185":"markdown","9605a85a":"markdown","3475c003":"markdown","d429bdbd":"markdown","7c5ef6c7":"markdown","b6a084c2":"markdown","6603a9c0":"markdown","73d9cba7":"markdown","f2cb693f":"markdown","6f978e90":"markdown","e0aade4c":"markdown","e0de7171":"markdown","c7c53ef3":"markdown","6b371333":"markdown","7a354b87":"markdown"},"source":{"3ff1c157":"import warnings\nimport datetime\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom sklearn import metrics\nfrom sklearn import linear_model\nfrom sklearn.preprocessing import PolynomialFeatures\n\nfrom bokeh.layouts import row\nfrom bokeh.transform import transform\nfrom bokeh.palettes import Viridis3, Viridis256\nfrom bokeh.plotting import figure, output_notebook, show\nfrom bokeh.models import BasicTicker, ColorBar, LinearColorMapper, ColumnDataSource, PrintfTickFormatter","4d684349":"output_notebook()\nwarnings.filterwarnings(\"ignore\")","d34206b6":"x_prediction = 'consumption_beer'\nx_column = [x_prediction]\nisweekend = { 0:\"n\", 1:\"y\" }\ndayofweek = {0:'mon', 1:'tues', 2:'weds', 3:'thurs', 4:'fri', 5:'sat', 6:'sun'}\nholidaylist = {\n    datetime.date(2015, 1, 1).ctime() : \"y\",\n    datetime.date(2015,2, 16).ctime() : \"y\",\n    datetime.date(2015,2, 17).ctime() : \"y\",\n    datetime.date(2015,4, 3).ctime() : \"y\",\n    datetime.date(2015,4, 21).ctime() : \"y\",\n    datetime.date(2015,5, 1).ctime() : \"y\",\n    datetime.date(2015,6, 4).ctime() : \"y\",\n    datetime.date(2015,9, 7).ctime() : \"y\",\n    datetime.date(2015,10, 12).ctime() : \"y\",\n    datetime.date(2015,11, 2).ctime() : \"y\",\n    datetime.date(2015,11, 15).ctime() : \"y\",\n    datetime.date(2015,12, 25).ctime() : \"y\"\n}","3883f6dc":"##Check if date is a holiday and return 'Y' if true\ndef get_holiday(date):\n  return holidaylist.get(date.ctime(), \"n\")\n\n##Convert a day of week in label of week\ndef get_weekday(date):\n    return dayofweek.get(date.dayofweek, \"not\")\n\n##Check if date is a weekend and return Y if true\ndef get_weekend(end):\n    return isweekend.get(end, \"n\")","ff1eeaf7":"##Hot Encoding to transforme data in columns\ndef hot_enconding(df, columnname, functoapply, prefix = None, orderref=None, drop=False):\n    columnref = columnname\n    if not drop:\n        columnname = columnname + '_'\n\n    df[columnname] = df[columnref].apply(functoapply)\n    hot_encoded = pd.get_dummies(df[columnname], prefix=prefix)\n\n    if prefix == None:\n        prefix = \"\"\n    else:\n        prefix = prefix + \"_\"\n\n    if orderref != None:\n        hot_encoded = hot_encoded[[prefix + x for x in orderref.values()]]\n\n    df = df.drop(columnname, axis=1)\n    df = df.join(hot_encoded)\n\n    return df","6c437232":"##Build a regressin polynomial model\ndef build_regression(df, xc, yc):\n    x_ind = np.array(df[xc])\n    y_dep = np.array(df[yc])\n\n    poly = PolynomialFeatures(degree=2)\n    x_ = poly.fit_transform(x_ind)\n    clf = linear_model.LinearRegression()\n    clf.fit(x_, y_dep)\n\n    return clf, poly","c736c287":"##Split csv data in two dataframes, train and test \ndef train_test_split(df, test_size=0.2):\n    split_row = len(df) - int(test_size * len(df))\n    train_data = df.iloc[:split_row]\n    test_data = df.iloc[split_row:]\n\n    return train_data, test_data","dcd9365a":"##Test a model\ndef test_regression(df_test, df_train, yc, xc):\n    nmcolumnpred = 'consumption_pred_beer'\n    nmcolumnreal = 'consumption_beer'\n    reg, poly = build_regression(df_train, yc, xc)\n    df_test[nmcolumnpred] = -1.0\n\n    for i in range(len(df_test)):\n        arr = [np.array(df_test[yc].iloc[i])]\n        predict = poly.fit_transform(arr)\n        res_predict = reg.predict(predict)\n        index = test.index.values[i]\n        df_test.at[index, nmcolumnpred] = res_predict\n\n    real = df_test[nmcolumnreal]\n    predict = df_test[nmcolumnpred]\n    df_test.drop(nmcolumnpred, axis=1, inplace=True)\n\n    return np.sqrt(metrics.mean_squared_error(real.values, predict.values)), real, predict  ","566eed04":"##Test all features combination until find the best rmse\ndef test_all_combination_rmse(y_column, test_comb, df_train, df_test):\n    print(datetime.datetime.now().ctime())\n    minor = 100000\n    best_comp = []\n    count_test = 1\n\n    for L in range(0, len(test_comb)+1):\n        for subset in itertools.combinations(test_comb, L):\n            count_test += 1\n            if count_test % 1000 == 0:\n                print(\"Quantidade de teste:\" + str(count_test) + \" Menor valor do RMSE: \" + str(minor))\n\n            x_columns = np.array(subset)\n            if len(y_columns) > 0:\n                mrse, r, p = test_regression(df_test, df_train, x_columns, y_column)\n                if  mrse < minor:\n                    minor = mrse\n                    best_comp = x_columns\n\n    print(datetime.datetime.now().ctime())\n    return best_comp","da99fd25":"def line_plot(line1, line2=None, label1=None, label2=None, color1=\"blue\", color2=\"red\", title=\"\", p = None):\n    x1 = line1.index.values\n    y1 = line1.values\n\n    if p == None:\n        p = figure(plot_width=1200, plot_height=400)\n        p.title.text = title\n\n    p.legend.click_policy=\"hide\"\n    p.legend.location = \"top_left\"\n\n    p.line(x1, y1, line_width=1.5, line_color=color1, legend=label1)\n\n    if line2 is not None:\n        y2 = line2.values\n        x2 = line2.index.values\n        p.line(x2, y2, line_width=1.5, line_color=color2, legend=label2)\n\n    return p\n\ndef plot_correlation(data, title=\"Correlation plot\"):\n    df = data.corr()\n    df.index.name = 'AllColumns1'\n    df.columns.name = 'AllColumns2'\n\n    df = df.stack().rename(\"value\").reset_index()\n\n    mapper = LinearColorMapper(palette=Viridis256, low=df.value.min(), high=df.value.max())\n\n    TOOLS = \"\"\n    p = figure(\n        tools=TOOLS,\n        plot_width=700,\n        plot_height=550,\n        # plot_width=500,\n        # plot_height=390,\n        title=title,\n        x_range=list(df.AllColumns1.drop_duplicates()),\n        y_range=list(df.AllColumns2.drop_duplicates()),\n        toolbar_location=\"right\",\n        x_axis_location=\"below\")\n\n    p.xaxis.major_label_orientation = np.pi\/8\n    p.yaxis.major_label_orientation = np.pi\/8\n\n    p.rect(\n        x=\"AllColumns1\",\n        y=\"AllColumns2\",\n        width=1,\n        height=1,\n        source=ColumnDataSource(df),\n        line_color=None,\n        fill_color=transform('value', mapper))\n\n    color_bar = ColorBar(color_mapper=mapper, location=(0, 0), ticker=BasicTicker(desired_num_ticks=10))\n\n    p.add_layout(color_bar, 'right')\n\n    return p","32a75336":"##Load data from CSV and prepare all instances\ndef load_data():\n    path=\"..\/input\/beer-consumption-sao-paulo\/Consumo_cerveja.csv\"\n    df_HE = pd.read_csv(path, parse_dates=['Data'], decimal=\",\", thousands=\".\")\n    df_HE.dropna(how='all', inplace=True)\n    df_HE.rename(columns={\n        'Data': 'date', \n        'Temperatura Media (C)':'avg_temperature',\n        'Temperatura Minima (C)': 'min_temperature', \n        'Temperatura Maxima (C)':'max_temperature',\n        'Precipitacao (mm)':'precipitation', \n        'Final de Semana':'weekend', \n        'Consumo de cerveja (litros)': 'consumption_beer'\n        }, inplace=True)\n\n    df_not_HE = df_HE.copy()\n\n    df_HE = hot_enconding(df_HE, 'date', get_weekday, None, dayofweek)\n    df_HE = hot_enconding(df_HE, 'date', get_holiday, \"hld\", None, True)\n    df_HE = hot_enconding(df_HE, 'weekend', get_weekend, \"wkd\", isweekend, True)\n    \n    df_not_HE['weekday'] = pd.Categorical(df_not_HE['date'].apply(get_weekday)).codes\n    df_not_HE['holiday'] = pd.Categorical(df_not_HE['date'].apply(get_holiday)).codes\n    df_not_HE['weekend'] = pd.Categorical(df_not_HE['weekend'].apply(get_weekend)).codes\n\n    df_not_HE.drop('date', axis=1, inplace=True)\n\n    return df_HE, df_not_HE","fda90f43":"##Two dataframes, first with hot encoding and second without hot encoding\ndf_consumption_HE, df_consumption_NotHE = load_data()","17638971":"#Split on dataframe with hot encoding\ntrain, test = train_test_split(df_consumption_HE, 0.2)\n\n#Split the dataframe without hot enconding\ntrain2, test2 = train_test_split(df_consumption_NotHE, 0.2)","3a00695d":"#Testing for get best features combinations. This execution takes 1 hour\n# test_combination = ['avg_temperature', 'min_temperature', 'max_temperature', 'precipitation', 'mon', 'tues', 'weds', 'thurs', 'fri', 'sat', 'sun', 'hld_n', 'hld_y', 'wkd_n', 'wkd_y']\n# print(test_all_combination_rmse(x_column, test_combination, train, test))","e0ec6af5":"##Heatmap for feature with best RMSE\ncolumns = ['avg_temperature', 'max_temperature', 'precipitation', 'mon', 'tues', 'weds', 'sun', 'hld_n', 'hld_y', 'wkd_y', 'consumption_beer']\np1 = plot_correlation(df_consumption_HE[columns], title=\"RMSE better return feature correlation\");\n\n##Heatmap for all features\ncolumns = ['avg_temperature', 'min_temperature', 'max_temperature', 'precipitation', 'mon', 'tues', 'weds', 'thurs', 'fri', 'sat', 'sun', 'hld_y', 'hld_n', 'wkd_y', 'wkd_n', 'consumption_beer']\np2 = plot_correlation(df_consumption_HE[columns], title=\"Correlation of all features\");\n\nshow(row(p1, p2))","759d26c7":"##Heatmap for all features of the data without hot enconding\ncolumns = ['avg_temperature', 'min_temperature', 'max_temperature', 'precipitation', 'weekend', 'consumption_beer', 'weekday', 'holiday']\np1 = plot_correlation(df_consumption_NotHE[columns], title=\"Correlation of all using data without hot enconding features\");\n\nshow(p1)","4429e7f8":"##Show chart of the all data, splited and for training\nline_plotted = line_plot(line1=train[x_prediction], line2=test[x_prediction], label1=\"Alvos\", label2=\"Teste\", color1=Viridis256[128], color2=Viridis256[255], title=\"Consumption Beer [Training and Test]\")\nshow(line_plotted)","47d8234a":"##Test all columns \ny_columns = ['avg_temperature', 'min_temperature', 'max_temperature', 'precipitation', 'mon', 'tues', 'weds', 'thurs', 'fri', 'sat', 'sun', 'hld_y', 'hld_n', 'wkd_y', 'wkd_n']\nrmse_all, sr, sp = test_regression(test, train, y_columns, x_column)\nline_plotted = line_plot(line1=sr, line2=sp, label1=\"Targets\", label2=\"Test [Full]\", color1=Viridis256[0], color2=Viridis256[255], title=\"Consumption Beer [Polynomial Regression]\")\n\n##Test best features\ny_columns = ['avg_temperature', 'max_temperature', 'precipitation', 'mon', 'tues', 'weds', 'sun', 'hld_n', 'hld_y', 'wkd_y']\nrmse_best_feature, sr, sp = test_regression(test, train, y_columns, x_column)\nline_plotted = line_plot(line1=sp, label1=\"Test [Best Features]\", color1=Viridis256[128], p=line_plotted)","364885c4":"y_columns = ['avg_temperature', 'min_temperature', 'max_temperature', 'precipitation', 'weekend', 'weekday', 'holiday']\nrmse_not_he, sr, sp = test_regression(test2, train2, y_columns, x_column)\nline_plotted = line_plot(line1=sp, label1=\"Test [Without Hot Enconded Features]\", color1=\"red\", p=line_plotted)\n\n#y_columns = ['avg_temperature', 'max_temperature', 'precipitation', 'weekend']\ny_columns = ['avg_temperature', 'min_temperature', 'max_temperature', 'weekend']\nrmse_best_not_he, sr, sp = test_regression(test2, train2, y_columns, x_column)\nline_plotted = line_plot(line1=sp, label1=\"Test [Without Hot Enconded Features With Best Correlations]\", color1=\"blue\", p=line_plotted)","d06d36d4":"##RMSE Bar chart\nlabels = ['All Feature', 'Best Feature', 'All Feature (Not Hot Encoding)', 'Best Feature (Not Hot Encoding)']\n\nrmse_bar = figure(x_range=labels, plot_width=1200, plot_height=400, title=\"RMSE\")\nrmse_bar.vbar(x=labels, top=[rmse_all, rmse_best_feature, rmse_not_he, rmse_best_not_he], fill_color=[Viridis256[255], Viridis256[128], 'red', 'blue'], line_color=None, width=0.9)\n\nrmse_bar.xgrid.grid_line_color = None\nrmse_bar.y_range.start = 0","34f83d30":"show(line_plotted)\nshow(rmse_bar)","a762487a":"print(rmse_best_feature)","0f8e5b83":"**Montagem das barra para o gr\u00e1fico em barras do RMSEs retornado em cadas teste**","4d90f5fb":"**Teste as combina\u00e7\u00f5es para as features listadas**\n>* Observa\u00e7\u00e3o: Como poucas features tem uma boa correla\u00e7\u00e3o com o consumo de cerveja, ent\u00e3o a op\u00e7\u00e3o foi testar tudo, at\u00e9 achar o conjundo de features com melhor desempenho. Essa fun\u00e7\u00e3o \u00e9 executada em 1 e 20 minutos no Google Coolab.\n>* Retorno => ['avg_temperature', 'max_temperature', 'precipitation', 'mon', 'tues', 'weds', 'sun', 'hld_n', 'hld_y', 'wkd_y', 'consumption_beer']","b605829b":"**Fun\u00e7\u00e3o para one hot encoding**\n>Hot Enconding e a transforma\u00e7\u00e3o de dados categoricos em colunas. Exemplo, se aplicamos hot enconding numa feature de sexo, onde h\u00e1 F, M ou ND, ap\u00f3s aplicado existir\u00e1 3 colunas F, M, ND onde somente uma das colunas haver\u00e1 a marca\u00e7\u00e3o com 1 e o restante com o valor 0\n>Parametros da fun\u00e7\u00e3o:\n>>1. **df** \u00e9 o dataframe a ser tratado\n>>2. **columnname** \u00e9 a coluna de refer\u00eancia para o hot enconding\n>>3. **functoapply** \u00e9 a fun\u00e7\u00e3o de aplica\u00e7\u00e3o para obten\u00e7\u00e3o dos novos dados\n>>4. **prefix** \u00e9 o prefixo das novas colunas\n>>5. **orderref** \u00e9 a ordem que as colunas criadas por hot enconding v\u00e3o assumir no dataframe\n>>6. **drop** \u00e9 o indicativo para exclus\u00e3o da coluna usada para gera\u00e7\u00e3o de hot enconding","651d6016":"**Carrega os dataframes**","cc033d7e":"**Montagem da linha para o gr\u00e1ficos para os teste do dataset com as melheores features e com todas**","13d98185":"**Fun\u00e7\u00f5es para plotagem de gr\u00e1ficos utilizando o Bokeh como lib de renderiza\u00e7\u00e3o**","9605a85a":"**Fun\u00e7\u00e3o para carregamento do csv de consumo de cerveja**\n>Retornos:\n>>Essa fun\u00e7\u00e3o retorna dois dataframes, o primeiro e com aplica\u00e7\u00e3o de hot encoding e o segundo sem hot enconding. A op\u00e7\u00e3o por dois \u00e9 justamente para testar a hip\u00f3tese dos efeitos do hot enconding sobre a desempenho do modelo.","3475c003":"**Exibi\u00e7\u00e3o de gr\u00e1fico do compartamento do consumo de cerveja para as amostras de treinamento e teste**","d429bdbd":"**Exibi\u00e7\u00e3o das linhas e das barras em dois graficos**\n>Observa\u00e7\u00e3o: O gr\u00e1ficos tem suas label clic\u00e1veis, desse modo pode esconder ou exibir certas linhas.","7c5ef6c7":"**Fun\u00e7\u00e3o para testar o modelo com a amostra de teste**\n>Como se trata de dados em sequ\u00eancia temporal, ent\u00e3o n\u00e3o h\u00e1 a necessidade de obter amostra estratificada, na verdade por se tratar desse tipo \u00e9 interessante treinar o modelo com dados antigos e testa-lo com as inst\u00e2ncias mais recentes.","b6a084c2":"**Separa amostrar para treino e teste de ambos os datasets, com e sem hot enconding**","6603a9c0":"**Montagem das linhas para gr\u00e1ficos para os teste do dataset sem hot enconding para todas e as melhores features**","73d9cba7":"**Fun\u00e7\u00e3o para separar amostras para treinamento e teste**\n>Como se trata de dados em sequ\u00eancia temporal, ent\u00e3o n\u00e3o h\u00e1 a necessidade de obter amostra estratificada, na verdade por se tratar desse tipo \u00e9 interessante treinar o modelo com dados antigos e testa-lo com as inst\u00e2ncias mais recentes","f2cb693f":"**Cria\u00e7\u00e3o de mapa de calor para as features do dataframe sem hot enconding**","6f978e90":"**Preparar o notebook para as sa\u00eddas do bokeh e suprimir os warnings.**","e0aade4c":"**Fun\u00e7\u00f5es b\u00e1sicas para aplicar as colunas do dataframe para obte\u00e7\u00e3o de outras features**\n>Sendo:\n>>1. get_holiday retorna 'Y' para as datas de feriado nacional.\n>>2. get_weekday retorna o dia da semana correspondente.\n>>3. get_weekend retorna 'Y' para os dias de s\u00e1bada e domingo e 'N' para o restante.","e0de7171":"**Criar vari\u00e1veis para a feature engineering e marcando a vari\u00e1vel dependente**","c7c53ef3":"**Fun\u00e7\u00e3o que de fato treina o modelo**\n>Parametros da fun\u00e7\u00e3o:\n>>1. **df** \u00e9 o dataframe a ser tratado\n>>2. **xc** conjunto de features preditoras\n>>3. **yc** coluna para previs\u00e3o","6b371333":"**Fun\u00e7\u00e3o para descobrir a melhor combina\u00e7\u00e3o de feature dado um conjunto se utilizando do RMSE como medida de desempenho**\n>Parametros:\n>>1. **y_column** coluna a ser prevista\n>>2. **test_comb** conjunto de features a serem combinada\n>>3. **df_train** dataframe com as amostras de treinamento\n>>4. **df_test** dataframe com as amostras de teste","7a354b87":"**Cria\u00e7\u00e3o de mapa de calor com todas e as melhores features**"}}