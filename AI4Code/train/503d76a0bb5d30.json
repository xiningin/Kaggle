{"cell_type":{"2b1d8c13":"code","f8a43d6c":"code","1f4b14bf":"code","cb8e8272":"code","00e99ba3":"code","bdb4b537":"code","5b959771":"code","fba28720":"code","2b655149":"code","7e962246":"code","e7a64800":"code","c2515b37":"code","ee50fc7c":"code","e1e893c5":"code","a6a97a15":"code","a903b088":"code","997b00c3":"code","f9468991":"code","e9a34d25":"code","68390162":"code","d3a14f82":"code","b3432202":"code","f3eced3b":"code","1ca51790":"code","c8656995":"code","31fe5223":"code","beb6fcfc":"code","4d6d4af6":"code","32e28e6a":"code","d19bb608":"code","5618e98b":"code","4b307a46":"code","cc6d9a4c":"code","cedf958a":"code","8b4bb58e":"code","639b9b41":"code","9a561e76":"code","a65bcae8":"code","626f3a22":"code","734cdfc6":"code","79e6e56e":"code","20324094":"code","5334cfaf":"code","f90df350":"code","6ec7ae7e":"code","42762fc3":"code","00438e17":"code","0cba291d":"code","a5c550e2":"code","f10cb47f":"code","30c06dce":"code","d082bcc1":"code","5774fd34":"code","690909ef":"code","d1303460":"code","bdd69712":"code","db9851d7":"code","262da19e":"code","1f49c3c8":"code","63a76ce2":"code","89481a02":"code","7d3a1251":"code","d67a434b":"code","c88df3eb":"code","f3e5bd66":"code","1a7889d1":"code","7e4c3ffa":"code","ddc21fb7":"code","e5654d3c":"code","987d59e2":"code","5bec5421":"code","e2000a9f":"code","52efcf35":"code","9a2bc629":"code","12b9f3bb":"code","13d16a1a":"code","a4980b1e":"markdown","c1c1885e":"markdown","51c157e4":"markdown"},"source":{"2b1d8c13":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f8a43d6c":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns ","1f4b14bf":"\nloan = pd.read_excel(\"..\/input\/loan-approval-analysis\/Loan Data\/loan.xlsx\")\nloan.info()","cb8e8272":"# let's look at the first few rows of the df\nloan.head()","00e99ba3":"\nloan.columns","bdb4b537":"#missing values in each column\nloan.isnull().sum()","5b959771":"# percentage of missing values in each column\nround(loan.isnull().sum()\/len(loan.index), 2)*100","fba28720":"# removing the columns having more than 90% missing values\nmissing_columns = loan.columns[100*(loan.isnull().sum()\/len(loan.index)) > 90]\nprint(missing_columns)","2b655149":"loan = loan.drop(missing_columns, axis=1)\nprint(loan.shape)\n","7e962246":"# summarise number of missing values again\n100*(loan.isnull().sum()\/len(loan.index))","e7a64800":"# tow columns have 32 and 64% of mising values \nloan.loc[:, ['desc', 'mths_since_last_delinq']].head()","c2515b37":"# this 2 columns are added after created after the loan approved\nloan = loan.drop(['desc', 'mths_since_last_delinq'], axis=1)","ee50fc7c":"# summarise number of missing values again\n100*(loan.isnull().sum()\/len(loan.index))","e1e893c5":"# missing values in rows\nloan.isnull().sum(axis=1)","a6a97a15":"# checking whether some rows have more than 5 missing values\nlen(loan[loan.isnull().sum(axis=1) > 5].index)","a903b088":"loan.info()","997b00c3":"# The column int_rate is character type, let's convert it to float\nloan['int_rate'] = loan['int_rate'].astype(str).str.split()\n","f9468991":"# checking the data types\nloan.info()","e9a34d25":"# also, lets extract the numeric part from the variable employment length\n\n# first, let's drop the missing values from the column (otherwise the regex code below throws error)\nloan = loan[~loan['emp_length'].isnull()]\n\n# using regular expression to extract numeric values from the string\nimport re\nloan['emp_length'] = loan['emp_length'].apply(lambda x: re.findall('\\d+', str(x))[0])\n\n# convert to numeric\nloan['emp_length'] = loan['emp_length'].apply(lambda x: pd.to_numeric(x))","68390162":"# looking at type of the columns again\nloan.info()","d3a14f82":"behaviour_var =  [\n  \"delinq_2yrs\",\n  \"earliest_cr_line\",\n  \"inq_last_6mths\",\n  \"open_acc\",\n  \"pub_rec\",\n  \"revol_bal\",\n  \"revol_util\",\n  \"total_acc\",\n  \"out_prncp\",\n  \"out_prncp_inv\",\n  \"total_pymnt\",\n  \"total_pymnt_inv\",\n  \"total_rec_prncp\",\n  \"total_rec_int\",\n  \"total_rec_late_fee\",\n  \"recoveries\",\n  \"collection_recovery_fee\",\n  \"last_pymnt_d\",\n  \"last_pymnt_amnt\",\n  \"last_credit_pull_d\",\n  \"application_type\"]\nbehaviour_var","b3432202":"# let's now remove the behaviour variables from analysis\ndf = loan.drop(behaviour_var, axis=1)\ndf.info()","f3eced3b":"# also, we will not be able to use the variables zip code, address, state etc.\n# the variable 'title' is derived from the variable 'purpose'\n# thus let get rid of all these variables as well\n\ndf = df.drop(['title', 'url', 'zip_code', 'addr_state'], axis=1)","1ca51790":"df['loan_status'] = df['loan_status'].astype('category')\ndf['loan_status'].value_counts()","c8656995":"# filtering only fully paid or charged-off\ndf = df[df['loan_status'] != 'Current']\ndf['loan_status'] = df['loan_status'].apply(lambda x: 0 if x=='Fully Paid' else 1)\n\n# converting loan_status to integer type\ndf['loan_status'] = df['loan_status'].apply(lambda x: pd.to_numeric(x))\n\n# summarising the values\ndf['loan_status'].value_counts()","31fe5223":"# default rate\nround(np.mean(df['loan_status']), 2)","beb6fcfc":"# plotting default rates across grade of the loan\nsns.barplot(x='grade', y='loan_status', data=df)\nplt.show()","4d6d4af6":"# lets define a function to plot loan_status across categorical variables\ndef plot_cat(cat_var):\n    sns.barplot(x=cat_var, y='loan_status', data=df)\n    plt.show()\n    ","32e28e6a":"# compare default rates across grade of loan\nplot_cat('grade')","d19bb608":"# term: 60 months loans default more than 36 months loans\nplot_cat('term')","5618e98b":"# sub-grade: as expected - A1 is better than A2 better than A3 and so on \nplt.figure(figsize=(16, 6))\nplot_cat('sub_grade')","4b307a46":"# home ownership: not a great discriminator\nplot_cat('home_ownership')","cc6d9a4c":"# verification_status: surprisingly, verified loans default more than not verifiedb\nplot_cat('verification_status')","cedf958a":"# purpose: small business loans defualt the most, then renewable energy and education\nplt.figure(figsize=(16, 6))\nplot_cat('purpose')","8b4bb58e":"# let's also observe the distribution of loans across years\n# first lets convert the year column into datetime and then extract year and month from it\ndf['issue_d'].head()","639b9b41":"# extracting month and year from issue_date\ndf['month'] = df['issue_d'].apply(lambda x: x.month)\ndf['year'] = df['issue_d'].apply(lambda x: x.year)\n","9a561e76":"# let's first observe the number of loans granted across years\ndf.groupby('year').year.count()","a65bcae8":"# number of loans across months\ndf.groupby('month').month.count()","626f3a22":"# lets compare the default rates across years\n# the default rate had suddenly increased in 2011, inspite of reducing from 2008 till 2010\nplot_cat('year')","734cdfc6":"# comparing default rates across months: not much variation across months\nplt.figure(figsize=(16, 6))\nplot_cat('month')","79e6e56e":"# loan amount: the median loan amount is around 10,000\nsns.distplot(df['loan_amnt'])\nplt.show()","20324094":"# binning loan amount\ndef loan_amount(n):\n    if n < 5000:\n        return 'low'\n    elif n >=5000 and n < 15000:\n        return 'medium'\n    elif n >= 15000 and n < 25000:\n        return 'high'\n    else:\n        return 'very high'\n        \ndf['loan_amnt'] = df['loan_amnt'].apply(lambda x: loan_amount(x))\n","5334cfaf":"df['loan_amnt'].value_counts()","f90df350":"# let's compare the default rates across loan amount type\n# higher the loan amount, higher the default rate\nplot_cat('loan_amnt')","6ec7ae7e":"# let's also convert funded amount invested to bins\ndf['funded_amnt_inv'] = df['funded_amnt_inv'].apply(lambda x: loan_amount(x))","42762fc3":"# funded amount invested\nplot_cat('funded_amnt_inv')","00438e17":"# lets also convert interest rate to low, medium, high\n# binning loan amount\ndef int_rate(n):\n    if len(n) <= 10:\n        return 'low'\n    elif len(n) > 10 and len(n) <=15:\n        return 'medium'\n    else:\n        return 'high'\n    \n    \ndf['int_rate'] = df['int_rate'].apply(lambda x: int_rate(x))","0cba291d":"# comparing default rates across rates of interest\n# high interest rates default more, as expected\nplot_cat('int_rate')","a5c550e2":"# debt to income ratio\ndef dti(n):\n    if n <= 10:\n        return 'low'\n    elif n > 10 and n <=20:\n        return 'medium'\n    else:\n        return 'high'\n    \n\ndf['dti'] = df['dti'].apply(lambda x: dti(x))","f10cb47f":"# comparing default rates across debt to income ratio\n# high dti translates into higher default rates, as expected\nplot_cat('dti')","30c06dce":"# comparing default rates across debt to income ratio\n# high dti translates into higher default rates, as expected\nplot_cat('dti')","d082bcc1":"plot_cat('funded_amnt')\n","5774fd34":"# installment\ndef installment(n):\n    if n <= 200:\n        return 'low'\n    elif n > 200 and n <=400:\n        return 'medium'\n    elif n > 400 and n <=600:\n        return 'high'\n    else:\n        return 'very high'\n    \ndf['installment'] = df['installment'].apply(lambda x: installment(x))","690909ef":"# comparing default rates across installment\n# the higher the installment amount, the higher the default rate\nplot_cat('installment')","d1303460":"# annual income\ndef annual_income(n):\n    if n <= 50000:\n        return 'low'\n    elif n > 50000 and n <=100000:\n        return 'medium'\n    elif n > 100000 and n <=150000:\n        return 'high'\n    else:\n        return 'very high'\n\ndf['annual_inc'] = df['annual_inc'].apply(lambda x: annual_income(x))","bdd69712":"# annual income and default rate\n# lower the annual income, higher the default rate\nplot_cat('annual_inc')","db9851d7":"# employment length\n# first, let's drop the missing value observations in emp length\ndf = df[~df['emp_length'].isnull()]\n\n# binning the variable\ndef emp_length(n):\n    if n <= 1:\n        return 'fresher'\n    elif n > 1 and n <=3:\n        return 'junior'\n    elif n > 3 and n <=7:\n        return 'senior'\n    else:\n        return 'expert'\n\ndf['emp_length'] = df['emp_length'].apply(lambda x: emp_length(x))","262da19e":"# emp_length and default rate\n# not much of a predictor of default\nplot_cat('emp_length')","1f49c3c8":"# purpose: small business loans defualt the most, then renewable energy and education\nplt.figure(figsize=(16, 6))\nplot_cat('purpose')","63a76ce2":"# lets first look at the number of loans for each type (purpose) of the loan\n# most loans are debt consolidation (to repay otehr debts), then credit card, major purchase etc.\nplt.figure(figsize=(16, 6))\nsns.countplot(x='purpose', data=df)\nplt.show()","89481a02":"# filtering the df for the 4 types of loans mentioned above\nmain_purposes = [\"credit_card\",\"debt_consolidation\",\"home_improvement\",\"major_purchase\"]\ndf = df[df['purpose'].isin(main_purposes)]\ndf['purpose'].value_counts()","7d3a1251":"# plotting number of loans by purpose \nsns.countplot(x=df['purpose'])\nplt.show()","d67a434b":"# let's now compare the default rates across two types of categorical variables\n# purpose of loan (constant) and another categorical variable (which changes)\n\nplt.figure(figsize=[10, 6])\nsns.barplot(x='term', y=\"loan_status\", hue='purpose', data=df)\nplt.show()\n","c88df3eb":"# lets write a function which takes a categorical variable and plots the default rate\n# segmented by purpose \n\ndef plot_segmented(cat_var):\n    plt.figure(figsize=(10, 6))\n    sns.barplot(x=cat_var, y='loan_status', hue='purpose', data=df)\n    plt.show()\n\n    \nplot_segmented('term')","f3e5bd66":"# grade of loan\nplot_segmented('grade')","1a7889d1":"# home ownership\nplot_segmented('home_ownership')","7e4c3ffa":"# year\nplot_segmented('year')","ddc21fb7":"# emp_length\nplot_segmented('emp_length')","e5654d3c":"# loan_amnt: same trend across loan purposes\nplot_segmented('loan_amnt')","987d59e2":"# interest rate\nplot_segmented('int_rate')","5bec5421":"# installment\nplot_segmented('installment')","e2000a9f":"# debt to income ratio\nplot_segmented('dti')","52efcf35":"# annual income\nplot_segmented('annual_inc')","9a2bc629":"# variation of default rate across annual_inc\ndf.groupby('annual_inc').loan_status.mean().sort_values(ascending=False)","12b9f3bb":"# one can write a function which takes in a categorical variable and computed the average \n# default rate across the categories\n# It can also compute the 'difference between the highest and the lowest default rate' across the \n# categories, which is a decent metric indicating the effect of the varaible on default rate\n\ndef diff_rate(cat_var):\n    default_rates = df.groupby(cat_var).loan_status.mean().sort_values(ascending=False)\n    return (round(default_rates, 2), round(default_rates[0] - default_rates[-1], 2))\n\ndefault_rates, diff = diff_rate('annual_inc')\nprint(default_rates) \nprint(diff)\n","13d16a1a":"# filtering all the object type variables\ndf_categorical = df.loc[:, df.dtypes == object]\ndf_categorical['loan_status'] = df['loan_status']\n\n# Now, for each variable, we can compute the incremental diff in default rates\nprint([i for i in df.columns])","a4980b1e":"The overall default rate is about 14%.","c1c1885e":"Let's first visualise the average default rates across categorical variables.","51c157e4":"The objective is to identify predictors of default so that at the time of loan application, we can use those variables for approval\/rejection of the loan"}}