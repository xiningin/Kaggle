{"cell_type":{"f31afcd3":"code","bfbb5143":"code","3ea4c3e8":"code","9b44eed3":"code","e35b5c86":"code","7f7c363a":"code","2fe271ea":"code","7d944ac0":"code","b40c5801":"code","0f15e9b3":"code","56d76f9a":"code","716b9685":"code","78f222f2":"code","324e81e2":"code","3ec7f440":"code","a1ec3663":"code","bc36dadb":"code","0810c150":"code","ce673d59":"code","f7860817":"code","8da890ba":"code","893540a4":"code","71c8a227":"code","8fe5bdd2":"code","16c4892b":"code","3057fe57":"code","a35d2fed":"code","dab0e94e":"code","c267fc11":"code","a350a03c":"code","fb56ca86":"code","fb89f8e9":"code","cc7fd180":"code","a584c6e0":"code","ff354e27":"code","d044b6a9":"code","f4161a5d":"code","bdf67f87":"code","b58e50e3":"markdown"},"source":{"f31afcd3":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/carvana-image-masking-challenge\" directory.\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","bfbb5143":"os.listdir()","3ea4c3e8":"from subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))","9b44eed3":"# Load all the necessary libraries\nimport numpy as np \nimport gzip\nimport os \nfrom os.path import basename\nimport glob\nimport time \nimport cv2\nimport pandas as pd \nimport random\nfrom PIL import Image\nfrom scipy import ndimage\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom scipy.misc import imresize\nfrom skimage.transform import resize\n\nfrom sklearn.model_selection import train_test_split\nfrom keras.models import Model \nfrom keras.layers import Input, merge, Conv2D, MaxPooling2D, UpSampling2D, Concatenate\nfrom keras.optimizers import Adam, SGD \nfrom keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping\nfrom keras.preprocessing.image import array_to_img, img_to_array, load_img, ImageDataGenerator\nfrom keras import backend as K\n\nK.set_image_dim_ordering('th') # Theano dimension ordering in this code\n","e35b5c86":"INPUT_PATH='..\/input\/'\nprint(os.getcwd())\ndims=[128,128]\nimg_rows=dims[0]\nimg_cols=dims[1]\ntrain=sorted(glob.glob(INPUT_PATH+'train\/*.jpg'))\nmasks=sorted(glob.glob(INPUT_PATH+'train_masks\/*.gif'))\ntest=sorted(glob.glob(INPUT_PATH+'test\/*.jpg'))\nprint('Number of training images: ', len(train), 'Number of corresponding masks: ', len(masks), 'Number of test images: ', len(test))\n\nmeta=pd.read_csv(INPUT_PATH+'metadata.csv')\nmask_df=pd.read_csv(INPUT_PATH+'train_masks.csv')\nids_train=mask_df['img'].map(lambda s: s.split('_')[0]).unique()\nprint('Length of ids_train ', len(ids_train))","7f7c363a":"mask_df.head()","2fe271ea":"image = cv2.imread(INPUT_PATH+\"train\/00087a6bd4dc_01.jpg\")\nplt.imshow(image)\nplt.show()","7d944ac0":"img = Image.open(INPUT_PATH+'train_masks\/00087a6bd4dc_01_mask.gif').convert('RGB')\nplt.imshow(img)\nplt.show()","b40c5801":"img2mask=np.array(img)\nprint(img2mask.shape)\nprint(image.shape)","0f15e9b3":"masked_img=cv2.bitwise_and(image,img2mask)\nplt.imshow(masked_img)","56d76f9a":"masked_gray=cv2.cvtColor(masked_img,cv2.COLOR_BGR2GRAY)\nplt.imshow(masked_gray, cmap='gray')","716b9685":"masked_gray.shape","78f222f2":"#cv2.imshow('masked_gray',masked_gray)\n#cv2.waitKey(0)\n#cv2.destroyAllWindows()","324e81e2":"smooth = 1.\ndef dice_coef(y_true, y_pred):\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection=K.sum(y_true_f * y_pred_f)\n    return(2. * intersection + smooth) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n\ndef dice_coef_mp(y_true, y_pred):\n    y_true_f=y_true.flatten()\n    y_pred_f=y_pred.flatten()\n    intersection = np.sum(y_true_f*y_pred_f)\n    return(2. * intersection + smooth)\/(np.sum(y_pred_f) + mp.sum(y_pred_f) + smooth)\n\ndef dice_coef_loss(y_true, y_pred):\n    return -dice_coef(y_true, y_pred)","3ec7f440":"def get_layer(inputs, pixel, pool=True):\n    conv = Conv2D(pixel, (3, 3), padding=\"same\", activation='relu')(inputs)\n    conv = Conv2D(pixel, (3 ,3), padding=\"same\", activation='relu')(conv)\n    if pool:\n        pool = MaxPooling2D(pool_size=(2, 2))(conv)\n    else:\n        pool = None\n    return conv, pool","a1ec3663":"def get_unet():\n    inputs = Input((3,img_rows, img_cols))\n    conv1 = Conv2D(32, (3, 3), padding=\"same\", activation='relu')(inputs)    \n    conv1 = Conv2D(32, (3, 3), padding=\"same\", activation='relu')(conv1)\n    pool1 = MaxPooling2D(pool_size=(2, 2))(conv1)\n\n    conv2 = Conv2D(64, (3, 3), padding=\"same\", activation='relu')(pool1)\n    conv2 = Conv2D(64, (3, 3), padding=\"same\", activation='relu')(conv2)    \n    pool2 = MaxPooling2D(pool_size=(2, 2))(conv2)\n\n    conv3 = Conv2D(128, (3, 3), padding=\"same\", activation='relu')(pool2)\n    conv3 = Conv2D(128, (3, 3), padding=\"same\", activation='relu')(conv3)\n    pool3 = MaxPooling2D(pool_size=(2, 2))(conv3)\n\n    conv4 = Conv2D(256, (3, 3), padding=\"same\", activation='relu')(pool3)\n    conv4 = Conv2D(256, (3, 3), padding=\"same\", activation='relu')(conv4)\n    pool4 = MaxPooling2D(pool_size=(2, 2))(conv4)\n\n    conv5 = Conv2D(512, (3, 3), padding=\"same\", activation='relu')(pool4)\n    conv5 = Conv2D(512, (3, 3), padding=\"same\", activation='relu')(conv5)\n\n    up6 = Concatenate(axis=1)([UpSampling2D(size=(2, 2))(conv5), conv4])\n    #      Concatenate(axis=3)([residual, upconv])\n    conv6 = Conv2D(256, (3, 3), padding=\"same\", activation='relu')(up6)\n    conv6 = Conv2D(256, (3, 3), padding=\"same\", activation='relu')(conv6)\n\n    up7 = Concatenate(axis=1)([UpSampling2D(size=(2, 2))(conv6), conv3])\n    conv7 = Conv2D(128, (3, 3), padding=\"same\", activation='relu')(up7)\n    conv7 = Conv2D(128, (3, 3), padding=\"same\", activation='relu')(conv7)\n\n    up8 = Concatenate(axis=1)([UpSampling2D(size=(2, 2))(conv7), conv2])\n    conv8 = Conv2D(64, (3, 3), padding=\"same\", activation='relu')(up8)\n    conv8 = Conv2D(64, (3, 3), padding=\"same\", activation='relu')(conv8)\n\n    up9 = Concatenate(axis=1)([UpSampling2D(size=(2, 2))(conv8), conv1])\n    conv9 = Conv2D(32, (3, 3), padding=\"same\", activation='relu')(up9)\n    conv9 = Conv2D(32, (3, 3), padding=\"same\", activation='relu')(conv9)\n\n    conv10 = Conv2D(1, (1, 1), activation='sigmoid')(conv9)   #9\n\n    model = Model(inputs=inputs, outputs=conv10)\n    #      `Model(inputs=\/input_19, outputs=sigmoid.0)`\n\n    #model.compile(optimizer=Adam(lr=1.0e-5), loss=dice_coef_loss, metrics=[dice_coef])  #LUNA16\n    model.compile(optimizer=Adam(5e-4), loss='binary_crossentropy', metrics=[dice_coef]) #ecobill\n\n    return model","bc36dadb":"#split the train se into train and validation\ntrain_images, validation_images = train_test_split(train, train_size=0.8, test_size=0.2)\nprint('Split into training set with ', len(train_images), ' images anf validation set with ', len(validation_images), ' images')","0810c150":"#utility function to convert greyscale inages to rgb\ndef grey2rgb(img):\n    new_img = []\n    for i in range(img.shape[0]):\n        for j in range(img.shape[1]):\n            new_img.append(list(img[i][j])*3)\n    new_img = np.array(new_img).reshape(img.shape[0], img.shape[1], 3)\n    return new_img\n\n#generator that we will use to read data from the directory\ndef data_gen_small(data_dir, masks, images, batch_size, dims):\n    \"\"\" \n    data_dir: where the actual images are kept\n    mask_dir: where the actual masks are kept \n    images: the filenames of the images wi want to generate batches from \n    batch_size: self explanatory\n    dims: the dimensions in which wi want to rescale our images\n    \n    Image.resize(size, resample=0)\n    \n    Returns a resized copy of this image.\n    Parameters: \n    \n    size - The requested size in pixels, as a 2-tuple: (width, height).\n    resample - An optional resampling filter. This can be one of PIL.Image.NEAREST,\n    PIL.Image.BOX, PIL.Image.HAMMING, PIL.Image.BICUBIC or PIL.Image.LANCZOS\n    If omitted, or if the image has mode \"1\" or \"P\", it is set PIL.Image.NEAREST\n    \"\"\"\n    while True:\n        if batch_size==1:\n            ix=np.array([0])\n        else:\n            ix=np.random.choice(np.arange(len(images)), batch_size)\n        \n        imgs = []\n        labels = []\n        for i in ix:\n            # images\n            #print(images[i])\n            if batch_size==1:\n                original_img = cv2.imread(images)\n            else:\n                original_img = cv2.imread(images[i])\n            \n            resized_img = imresize(original_img, dims + [3]) #this looks like TensorFlow ordering\n            array_img = resized_img\/255\n            array_img = array_img.swapaxes(0, 2)\n            imgs.append(array_img)\n            #imgs is a numpy array with dim: (batch size X 128 X 128 3)\n            #print('shape of imgs ', array_img.shape)\n            # masks\n            try:\n                mask_filename = basename(images[i])\n                no_extension = os.path.splitext(mask_filename)[0]\n                correct_mask = INPUT_PATH + 'train_masks\/' + no_extension + '_mask.gif'\n                original_mask = Image.open(correct_mask).convert('L')\n                data = np.asarray(original_mask, dtype=\"int32\")\n                resized_mask = imresize(original_mask, dims+[3])\n                array_mask = resized_mask \/ 255\n                labels.append(array_mask)\n            except Exception as e:\n                labels=None\n            \n        imgs = np.array(imgs)\n        labels = np.array(labels)\n        try:\n            relabel = labels.reshape(-1, dims[0], dims[1], 1)\n            relabel = relabel.swapaxes(1, 3)\n        except Exception as e:\n            relabel=labels\n        yield imgs, relabel","ce673d59":"train_gen = data_gen_small(INPUT_PATH + 'train\/', masks, train_images, 2, dims) \nimg, msk = next(train_gen)\nprint('Size of batch: ', len(img))\nprint('shape of img ', img.shape, 'number dimensions: ', img[0].ndim)\nprint('shape of msk ', msk.shape, 'number dimensions: ', msk[0].ndim)\nnewshape = img[0].swapaxes(0,2)\nplt.imshow(newshape)\nplt.show()\n\n#try resize up \n\nresized_img = imresize(img[0], [1280, 1918]+[3])\nprint('resized up: ', resized_img.shape)\nnewshape = resized_img.swapaxes(0,1)\nprint('resized swapaxes: ', newshape.shape)\nprint('resized swapaxes shape[-1]: ', newshape.shape[-1])\n\nplt.imshow(newshape)\nplt.show()\n\nnewshape = msk.swapaxes(1,3)\nprint(newshape.shape)\nplt.imshow(grey2rgb(newshape[0]), alpha=0.5)\nplt.show()","f7860817":"# create an instance of a validation generator:\nvalidation_gen = data_gen_small(INPUT_PATH + 'train\/', masks, validation_images, 4, dims) ","8da890ba":"# define and compile the model\nmodel = get_unet()\nmodel.summary()","893540a4":"# fit the model and check dice_coef on validation data as end of each epoch\nmodel.fit_generator(train_gen, steps_per_epoch=50, epochs=35, validation_data=validation_gen, validation_steps=50)","71c8a227":"img, msk = next(validation_gen)\nprint(img.shape)\npredicted_mask = model.predict(img)\npredicted_mask.shape","8fe5bdd2":"newshape = predicted_mask.swapaxes(1,3)\nprint('newshape shape ', newshape.shape)\ngrey = grey2rgb(newshape[3])\nprint('grey shape ', grey.shape)\nplt.imshow(grey, alpha = 0.5)\nplt.show()","16c4892b":"newshape = img[3].swapaxes(0,2)\nplt.imshow(newshape)\nplt.show()","3057fe57":"validation_test = data_gen_small(INPUT_PATH + 'test\/', masks, test, 4, dims) \nimg_tst, msk_tst = next(validation_test)\nprint(img_tst.shape)\npredicted_mask_tst = model.predict(img_tst)\npredicted_mask_tst.shape","a35d2fed":"newshape_tst = predicted_mask_tst.swapaxes(1,3)\nprint('newshape shape ', newshape_tst.shape)\ngrey_tst = grey2rgb(newshape_tst[3])\nprint('grey shape ', grey_tst.shape)\nplt.imshow(grey_tst, alpha = 0.5)\nplt.show()","dab0e94e":"newshape_tst = img_tst[3].swapaxes(0,2)\nprint(newshape_tst.shape)\nplt.imshow(newshape_tst)\nplt.show()","c267fc11":"newshape_tst = predicted_mask_tst.swapaxes(1,3)\nprint('newshape shape ', newshape_tst.shape)\ngrey_tst = grey2rgb(newshape_tst[3])\nprint('grey shape ', grey_tst.shape)\nplt.imshow(grey_tst, alpha = 0.5)\nplt.show()","a350a03c":"'''def rle_encode(mask_image):\n    pixels = mask_image.flatten()\n    # We avoid issues with '1' at the start or end (at the corners of \n    # the original image) by setting those pixels to '0' explicitly.\n    # We do not expect these to be non-zero for an accurate mask, \n    # so this should not harm the score.\n    pixels[0] = 0\n    pixels[-1] = 0\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 2\n    runs[1::2] = runs[1::2] - runs[:-1:2]\n    return runs'''\ndef rle (img):\n    '''\n    img: numpy array, 1 - mask, 0 - background\n    Returns run length as string formated\n    '''\n    bytes = np.where(img.flatten()==1)[0]\n    runs = []\n    prev = -2\n    for b in bytes:\n        if (b>prev+1): runs.extend((b+1, 0))\n        runs[-1] += 1\n        prev = b\n    \n    return ' '.join([str(i) for i in runs])","fb56ca86":"from tqdm import tqdm_notebook as tqdm","fb89f8e9":"df=pd.DataFrame(columns=['img','rle_mask'])","cc7fd180":"'''def par_predict(tst_img):\n    validation_test = data_gen_small(INPUT_PATH + 'test\/', 'masks', tst_img, 1, dims)\n    img_tst, msk_tst = next(validation_test)\n    predicted_mask_tst = model.predict(img_tst)\n    \n    newshape_tst = predicted_mask_tst.swapaxes(1,3)\n    grey_tst = grey2rgb(newshape_tst[0])\n    gray_tst = np.array(grey_tst*255, dtype='uint8')\n    gray_tst[gray_tst>128]=1\n    gray_tst[gray_tst<=128]=0\n    \n    mask=rle_encode(gray_tst)\n    file=tst_img.split('\/')[-1]\n    df.loc[len(df)]=[file, mask]\n'''","a584c6e0":"'''def par_predict(img_num):\n    validation_test = data_gen_small(INPUT_PATH + 'test\/', 'masks', test[img_num], 1, dims)\n    img_tst, msk_tst = next(validation_test)\n    predicted_mask_tst = model.predict(img_tst)\n    \n    newshape_tst = predicted_mask_tst.swapaxes(1,3)\n    grey_tst = grey2rgb(newshape_tst[0])\n    gray_tst = np.array(grey_tst*255, dtype='uint8')\n    gray_tst[gray_tst<=128]=0\n    gray_tst[gray_tst>128]=1\n    \n    #mask=rle_encode(gray_tst)\n    #print(gray_tst[gray_tst==1])\n    mask=rle(gray_tst)\n    file=test[img_num].split('\/')[-1]\n    return [file, mask]'''\n","ff354e27":"'''for i in tqdm(test, total=len(test)):\n    validation_test = data_gen_small(INPUT_PATH + 'test\/', masks, i, 1, dims)\n    img_tst, msk_tst = next(validation_test)\n    predicted_mask_tst = model.predict(img_tst)\n    \n    newshape_tst = predicted_mask_tst.swapaxes(1,3)\n    grey_tst = grey2rgb(newshape_tst[0])\n    gray_tst = np.array(grey_tst*255, dtype='uint8')\n    gray_tst[gray_tst>128]=1\n    gray_tst[gray_tst<=128]=0\n    \n    mask=rle_encode(gray_tst)\n    file=i.split('\/')[-1]\n    df.loc[len(df)]=[file, mask]'''\n\n'''#Parallel(n_jobs=num_cores)(par_predict(i) for i in tqdm(test, total=len(test)))\n#b=0\nln=len(test)\n#ln=int(ln\/4)\n#ln=10 #testing the rle file\nst=len(df)\nprint('Number images going to be processed: {}'.format(ln))\n#pbar = tqdm(total = ln+1)\nfor i in tqdm(range(st,ln)):\n    df.loc[len(df)]=par_predict(i)\n    if i % 1000 == 0:\n        df.to_csv('csv_to_submit.csv', index = False)\n#pbar.close()\ndf.to_csv('csv_to_submit.csv', index = False)\n'''","d044b6a9":"'''# import the modules we'll need\nfrom IPython.display import HTML\nimport pandas as pd\nimport numpy as np\nimport base64\n\n# function that takes in a dataframe and creates a text link to  \n# download it (will only work for files < 2MB or so)\ndef create_download_link(df, title = \"Download CSV file\", filename = \"data.csv\"):  \n    csv = df.to_csv()\n    b64 = base64.b64encode(csv.encode())\n    payload = b64.decode()\n    html = '<a download=\"{filename}\" href=\"data:text\/csv;base64,{payload}\" target=\"_blank\">{title}<\/a>'\n    html = html.format(payload=payload,title=title,filename=filename)\n    return HTML(html)\n\n# create a random sample dataframe\n#df = pd.DataFrame(np.random.randn(50, 4), columns=list('ABCD'))\n\n# create a link to download the dataframe\ncreate_download_link(df)\n\n# \u2193 \u2193 \u2193  Yay, download link! \u2193 \u2193 \u2193 '''","f4161a5d":"'''\nFast inplementation of Run-Length Encoding algorithm\nTakes only 200 seconds to process 5635 mask files\n'''\n\nimport numpy as np\nfrom PIL import Image\nimport os\n\n\ndef rle_encoding(x):\n    '''\n    x: numpy array of shape (height, width), 1 - mask, 0 - background\n    Returns run length as list\n    '''\n    dots = np.where(x.T.flatten()==1)[0] # .T sets Fortran order down-then-right\n    run_lengths = []\n    prev = -2\n    for b in dots:\n        if (b>prev+1): run_lengths.extend((b+1, 0))\n        run_lengths[-1] += 1\n        prev = b\n    return run_lengths","bdf67f87":"conv = lambda l: ' '.join(map(str, l)) # list -> string\n#N = 100     # process first N masks\nN = len(test)\nfor i in tqdm(range(N)):\n    m=test[i]\n    validation_test = data_gen_small(INPUT_PATH + 'test\/', 'masks', m, 1, dims)\n    img_tst, msk_tst = next(validation_test)\n    predicted_mask_tst = model.predict(img_tst)\n    newshape_tst = predicted_mask_tst.swapaxes(1,3)\n    grey_tst = grey2rgb(newshape_tst[0])\n    encoding=conv(rle_encoding(grey_tst))\n    file=m.split('\/')[-1]\n    df.loc[len(df)]=[file,encoding]\n    \n#check output\n'''conv = lambda l: ' '.join(map(str, l)) # list -> string\nsubject, img = 1, 1\nprint('\\n{},{},{}'.format(subject, img, conv(encodings)))\n'''\ndf.to_csv('csv_to_submit.csv', index = False)\n'''print(len(df))\nprint(df)\nprint('The End')'''\n\n# train_masks.csv:\n#print('1,1,168153 9 168570 15 168984 22 169401 26 169818 30 170236 34 170654 36 171072 39 171489 42 171907 44 172325 46 172742 50 173159 53 173578 54 173997 55 174416 56 174834 58 175252 60 175670 62 176088 64 176507 65 176926 66 177345 66 177764 67 178183 67 178601 69 179020 70 179438 71 179857 71 180276 71 180694 73 181113 73 181532 73 181945 2 181950 75 182365 79 182785 79 183205 78 183625 78 184045 77 184465 76 184885 75 185305 75 185725 74 186145 73 186565 72 186985 71 187405 71 187825 70 188245 69 188665 68 189085 68 189506 66 189926 65 190346 63 190766 63 191186 62 191606 62 192026 61 192446 60 192866 59 193286 59 193706 58 194126 57 194546 56 194966 55 195387 53 195807 53 196227 51 196647 50 197067 50 197487 48 197907 47 198328 45 198749 42 199169 40 199589 39 200010 35 200431 33 200853 29 201274 27 201697 20 202120 15 202544 6')\n","b58e50e3":"**Prediction on the unseen data set**"}}