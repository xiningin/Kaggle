{"cell_type":{"06cd23c3":"code","b55a6c0f":"code","9d1ba6e8":"code","5408f584":"code","4ce23e47":"code","f40afbd1":"code","359fef95":"code","f974b305":"code","79436eff":"code","cb3279bc":"code","21df4cf1":"code","de78876c":"code","03bbf568":"code","e206c1d2":"code","617cbe30":"code","6b430f59":"code","a49584a8":"code","dd29a234":"code","25801342":"code","391f16f3":"code","59a4e71d":"code","8f25a783":"code","4d256803":"code","d235f4cc":"code","c7d6014b":"code","4f5c6680":"code","81181f10":"code","00a7ef32":"code","93875c77":"code","4f5deb3c":"markdown","57faa22e":"markdown","ac15b099":"markdown","5f93bae6":"markdown","70eb549c":"markdown","536f386c":"markdown","5282d697":"markdown","b7d29fcc":"markdown","ed1e55d0":"markdown","da3e6363":"markdown","8bd5b036":"markdown","d7dcc232":"markdown","f00ace25":"markdown","ba1b8906":"markdown","5e6f845c":"markdown","3e9159f5":"markdown","b7a226b0":"markdown","4971884d":"markdown","42263da0":"markdown","8b9dc3f6":"markdown","e23bdd34":"markdown","221fb6cb":"markdown","b8907ef5":"markdown","2fc8b251":"markdown"},"source":{"06cd23c3":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nfrom plotly.offline import plot, iplot, init_notebook_mode\nimport plotly.graph_objs as go\ninit_notebook_mode(connected=True)\n%matplotlib inline\n\ndata = pd.read_csv('..\/input\/gufhtugu-publications-dataset-challenge\/GP Orders - 5.csv')\ndata.head()","b55a6c0f":"data = data.rename({\"Order Number\": \"Order_Number\", \"Order Status\": \"Order_Status\", \"Book Name\":\"Book_Name\",\n                    \"Order Date & Time\": \"Order_Date\", \"City (Billing)\": \"City\", \n                    \"Payment Method\": \"Payment_Method\", \"Total items\": \"Total_Items\", \n                    \"Total weight (grams)\": \"Total_Weight\" }, axis = 1)\ndata.info()","9d1ba6e8":"# Checking whether the Order_Numbers are duplicated or not. \n# If duplicates are present, then delete the duplicates\ndata.Order_Number.value_counts()","5408f584":"# dropping the nan values in the data\ndata = data.dropna()\ndata.info()","4ce23e47":"print(data.Order_Status.value_counts())\nprint()\n\n# Plotting the Order Status Frequency \npx.histogram(data, x = data.Order_Status, width = 400, height = 400, title='Order Status Frequency')","f40afbd1":"# Since the book names were separated by \" \/ \" that is why I used split method to get name of all the books separately\nbook_data = data.Book_Name.apply(lambda x: str(x).split('\/'))\n# Storing the list of lists book names in a list 'books' \nbooks = [item for sublist in book_data for item in sublist]\n# creating a new dataframe 'df' for ease in plotting the books sold\ndf = pd.DataFrame(data = books, columns = ['Books_Sold'])\n# Only storing the top 10 most selling books of all times and converting the result into a datafram\nbook_chart = df.Books_Sold.value_counts().nlargest(10).to_frame()\n# Printing the most sold book name and its number of times it was sold\nprint(book_chart.head(1))\nprint()\n# plotting 10 top selling books of all time\npx.bar(book_chart, y = book_chart.Books_Sold, x = book_chart.index, title = 'Most Selling Books')","359fef95":"# The column 'Order_Date' had both time and date, for ease in data manipulation made new columns for both Time and Date\n# \"Order_Date\" column had date and time separated by empty space, hence splitted the data and stored in respectice columns\ndata['Time'] = data.Order_Date.apply(lambda x: str(x).split(' ')[1])\ndata['Date'] = data.Order_Date.apply(lambda x: str(x).split(' ')[0])\ndata.head()","f974b305":"# Converting time into mins by getting the hours by splitting and multiplying it by 60 \n# and then adding it with the minutes to get the total minutes\nmins = data.Time.apply(lambda x: int(x.split(\":\")[0])*60 + int(x.split(\":\")[1]))\n# cutting the Mins into 4 parts so that the each time can manipulated with a time range of 6 hours\npd.cut(mins, bins = 4)","79436eff":"# Creating a new column Mins\ndata['Mins'] = mins\n# if the number of mins are lesser than 360 i.e Time is from 00:00 to 05:59 store it as 0\ndata.loc[data['Mins'] < 360, 'Mins'] = 0\n# if the number of mins are lesser than 720 and greater than equal to 360 \n# i.e Time is from 06:00 to 11:59 store it as 1\ndata.loc[(data['Mins'] >= 360) & (data['Mins'] < 720), 'Mins'] = 1 \n# if the number of mins are lesser than 1080 and greater than equal to 720\n# i.e Time is from 12:00 to 17:59 store it as 2\ndata.loc[(data['Mins'] >= 720) & (data['Mins'] < 1080), 'Mins'] = 2 \n# if the number of mins are  greater than equal to 1080\n#i.e Time is from 18:00 to 23:59 store it as 3\ndata.loc[(data['Mins'] >= 1080), 'Mins'] = 3\n# Checking in which time frame most orders are placed\ndata.Mins.value_counts()\n# plotting the number of orders placed within different time frames\npx.histogram(data, x = data.Mins, width = 400, height = 400, title='Order Status Frequency By Time')\n# Most Orders are placed between 6 PM to 12 AM, with number of orders = 7010","cb3279bc":"a = data.loc[data.Mins == 0].Order_Status.value_counts().to_frame()\nb = data.loc[data.Mins == 1].Order_Status.value_counts().to_frame()\nc = data.loc[data.Mins == 2].Order_Status.value_counts().to_frame()\nd = data.loc[data.Mins == 3].Order_Status.value_counts().to_frame()","21df4cf1":"print('Ratio of Order Status from 12 AM to 6 AM:')\n# Plotting the Order Status for orders placed between 12 AM to 6 AM\n# normalizing the value_counts to see the percentage of each variable\nprint(data.loc[data.Mins == 0].Order_Status.value_counts(normalize = True)*100)\npx.bar(a, y = a.Order_Status, x = a.index, title = 'Order Status from 12 AM to 6 AM', height = 400, width = 400)","de78876c":"print('Ratio of Order Status from 6 AM to 12 PM:')\n# Plotting the Order Status for orders placed between 12 AM to 6 AM\n# normalizing the value_counts to see the percentage of each variable\nprint(data.loc[data.Mins == 1].Order_Status.value_counts(normalize = True)*100)\npx.bar(b, y = b.Order_Status, x = b.index, title = 'Order Status from 6 AM to 12 PM', height = 400, width = 400 )","03bbf568":"print('Ratio of Order Status from 12 PM to 6 PM:')\nprint(data.loc[data.Mins == 2].Order_Status.value_counts(normalize = True)*100)\npx.bar(c, y = c.Order_Status, x = c.index, title = 'Order Status from 12 PM to 6 PM', height = 400, width = 400 )","e206c1d2":"print('Ratio of Order Status from 6 PM to 12 AM:')\nprint(data.loc[data.Mins == 1].Order_Status.value_counts(normalize = True)*100)\npx.bar(d, y = d.Order_Status, x = d.index, title = 'Order Status from 6 PM to 12 AM', height = 400, width = 400 )","617cbe30":"# Since the data contained names of cities in different cases, hence converted the all the data to lower case\ndata.City = data.City.apply(lambda x: str(x).lower())\ndata.City = data.City.replace(\"khi\", \"karachi\")\ndata.City = data.City.replace(\"fsd\", \"faisalabad\")\ndata.City = data.City.replace(\"isb\", \"islamabad\")\ndata.City = data.City.replace(\"lhr\", \"lahore\")\ndata.City = data.City.replace('lahire', 'lahore')\n# top 30 cities with most sales\ncities = data.City.value_counts().nlargest(30).to_frame()\n# list of top cities\ntop_cities = list(cities.index)\ncities = cities.rename({'City': 'Sales'}, axis = 1)\n# plotting the top cities by sales\npx.bar(cities, x = cities.index, y = cities.Sales)","6b430f59":"df = pd.DataFrame()\n# Creating a new dataframe for visualizing the top 30 cities order statuses\ndf['Order_Status'] = data[data.City.isin(top_cities)].Order_Status\ndf['City'] = data[data.City.isin(top_cities)].City\ndf['Time'] = data[data.City.isin(top_cities)].Mins\ndf['Date'] = data[data.City.isin(top_cities)].Date","a49584a8":"# creating a pivot table with index city, column Order status and populating the table with Time\npt = pd.pivot_table(df, values = 'Time', index = 'City', columns = 'Order_Status', aggfunc = 'count', fill_value=0)\n# creating a column for finding out the ratio of 'Completed' (Order Status) orders \npt['Completion_Rate'] = pt.Completed \/ (pt.Completed + pt.Canceled + pt.Cancelled)\npt = pt.sort_values(by = 'Completion_Rate', ascending = False)","dd29a234":"px.bar(pt, y = pt.Completion_Rate, x = pt.index, title = 'Order Completion of top 30 cities')","25801342":"pt = pd.pivot_table(data, values = 'City', index = 'Mins', columns = 'Order_Status', aggfunc = 'count', fill_value=0)\npt['Completion_Rate'] = pt.Completed \/ (pt.Completed + pt.Canceled + pt.Cancelled)\npt = pt.sort_values(by = 'Completion_Rate', ascending = False)\npx.bar(pt, y = pt.Completion_Rate, x = pt.index, title = 'Order Completion for Different Time Ranges')","391f16f3":"pt = pd.pivot_table(data, values = 'City', index = 'Date', columns = 'Order_Status', aggfunc = 'count', fill_value=0)\npt['Completion_Rate'] = pt.Completed \/ (pt.Completed + pt.Canceled + pt.Cancelled)\npt = pt.sort_values(by = 'Completion_Rate', ascending = False)\npx.bar(pt, y = pt.Completion_Rate, x = pt.index, title = 'Order Completion for Different Dates')","59a4e71d":"# splitting the Date column for getting the months and days of each date\nmonthly = data.Date.apply(lambda x: x.split(\"\/\")[0])\ndaily = data.Date.apply(lambda x: x.split(\"\/\")[1])\ndata['Month'] = monthly\ndata['Day'] = daily","8f25a783":"# Visualizing the month with most sales\npt = pd.pivot_table(data, values = 'Order_Number', index = 'Month', aggfunc = 'count')\\\n              .sort_values(by = 'Order_Number', ascending = False)\npx.bar(pt, y = pt.Order_Number, x = pt.index, title = 'Number of Orders Placed in Different Months')\n              ","4d256803":"pt = pd.pivot_table(data, values = 'Order_Number', index = 'Day', aggfunc = 'count').sort_values(by = 'Order_Number', ascending = False)\npx.bar(pt, y = pt.Order_Number, x = pt.index, title = 'Number of Orders Placed in Different Days')","d235f4cc":"# Creating a new pred_table\npred_table = data[['Date', 'Order_Number', 'Order_Status']]\n# converting the Date column values to datetime and copying the data in the pred_table.Date\npred_table['Date'] = pd.to_datetime(data.Date.iloc[:])\n# Grouping the pred_table with Date and calculating the number of orders placed within each date\npred_table = pred_table.groupby('Date')['Order_Number'].count().reset_index()\npred_table","c7d6014b":"from fbprophet import Prophet\nsales_pred = Prophet(interval_width = 0.95)\n# renaming the columns, since fbpropher requires each column to be used to be renamed as ds and y\nsales = pred_table.rename(columns={'Date': 'ds', 'Order_Number': 'y'})\n# fitting the model\nsales_pred.fit(sales)\n\n# forecasting the number of sales for the next 12 Months\nsales_forecast = sales_pred.make_future_dataframe(periods=12, freq='MS')\nsales_forecast = sales_pred.predict(sales_forecast)\n\n# visualizing the predictions\nplt.figure(figsize=(12, 6))\nsales_pred.plot(sales_forecast, xlabel = 'Date', ylabel = 'Sales')\nplt.title('Book Sales')","4f5c6680":"data.head()","81181f10":"data.Payment_Method.value_counts()","00a7ef32":"# Since Cash on delivery was repeated\ndata.Payment_Method = data.Payment_Method.replace('Cash on Delivery (COD)', 'Cash on delivery')\npx.histogram(data, x = 'Payment_Method', width = 600, height = 400, title = 'Frequency of Payment Method')","93875c77":"a = sns.countplot(x = 'Order_Status', data = data[data.Payment_Method == 'Cash on delivery'])\na.set_title('Order Status for Cash on Delivery')\nplt.figure()\na = sns.countplot(x = 'Order_Status', data = data[data.Payment_Method == 'EasyPaisa'])\na.set_title('Order Status for EasyPaisa')\nplt.figure()\na = sns.countplot(x = 'Order_Status', data = data[data.Payment_Method == 'JazzCash'])\na.set_title('Order Status for JazzCash')\nplt.figure()\na = sns.countplot(x = 'Order_Status', data = data[data.Payment_Method == 'BankTransfer'])\na.set_title('Order Status for BankTransfer')","4f5deb3c":"Most number of orders are placed in January with least orders placed in February","57faa22e":"Most number of orders are placed on 9th Day of the month and least orders are placed in the 19th day of the month","ac15b099":"## Visualizing Days with most sales","5f93bae6":"## Visualizing Months with most sales","70eb549c":"## Data Preprocessing","536f386c":"## Order Completion Ratio by Different Dates","5282d697":"Since most of the people rely on getting things delivered first and then pay accordingly, hence the mode which was used most frequently for delivery is Cash on Delivery mode.","b7d29fcc":"## Visualizing Orders Status Frequency by Time ","ed1e55d0":"## Time Series Forecasting for predicting the number of orders","da3e6363":"Hence the City with Most Order Completion Rate is Dera Ghazi Khan","8bd5b036":"## FB Prophet Library for predicting the sales for the next whole year","d7dcc232":"### Order Completion Ratio by Time","f00ace25":"## Order Status Frequency","ba1b8906":"#Copying and Practicing Guftagu Dataset Analysis Kernel","5e6f845c":"Converting Time Column into Categorical Variable for ease in manipulation","3e9159f5":"## Most Selling Books","b7a226b0":"## Identifying Cities with most orders","4971884d":"From above graph we can determine the order placed on 19\/11\/2019 had least completion rate with 0.5","42263da0":"Renaming the columns for ease in accessing the data","8b9dc3f6":"### Result: The Book Sales are expected to grow within each month, with the number of sales crossing 300 per day after one year\nThe confidence interval upto 12 months remains constant","e23bdd34":"## Order Completion Ratio with Time Ranges","221fb6cb":"The Rate of Completion of Orders are Maximum for orders placed between 12 AM to 6 AM.","b8907ef5":"Converting each time frame into a separate dataframe for analyzing the order statuses within every time frame","2fc8b251":"### Visualizing Order Completion Ratio for Cities with most sales"}}