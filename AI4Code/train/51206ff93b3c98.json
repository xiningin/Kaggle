{"cell_type":{"351573c2":"code","858e70d0":"code","040d249e":"code","25b10d21":"code","02d7da53":"code","30c45d41":"code","1362a810":"code","495c378d":"code","ce491d56":"code","f0b8e9d2":"code","9ba62cdf":"code","deab4ea9":"code","a2514654":"code","c8593da4":"code","03dbc63e":"code","8adc840e":"code","cdb21025":"code","73ed4d4b":"code","0b87e7fe":"code","7a71c3c1":"code","842d9c8b":"code","f8e41662":"code","7a4a6f6e":"code","f5406ac7":"code","1ec62929":"code","c1a510bd":"code","788eaa50":"code","3b73d2cf":"code","fb34e798":"code","dc974a3d":"code","f1bb6427":"code","f1598749":"code","87d8593e":"code","4815a6a9":"code","6774c3a6":"code","4aa18927":"code","dfd377ff":"code","e7540135":"code","fa93f146":"code","e40aae3c":"code","0efd4989":"code","db8e843f":"code","478b9d9e":"markdown","b6aa5426":"markdown","80db06ce":"markdown","e85bf08a":"markdown","28c25dc9":"markdown","2a222537":"markdown","929b6a29":"markdown","62fa2829":"markdown","130c9602":"markdown","e437db06":"markdown","001b700f":"markdown","07b0ba79":"markdown","bdc79730":"markdown","1c89571b":"markdown","56c273e7":"markdown","5663355c":"markdown","444e88c7":"markdown","4fe4d932":"markdown","e45bba2e":"markdown","2e79e271":"markdown","61a3c774":"markdown","7e9e38be":"markdown","1f5ec2b2":"markdown","f0894c77":"markdown","de9b3a0d":"markdown","dc217da9":"markdown","e9a42593":"markdown","b13eecd8":"markdown","09fcb932":"markdown","87ffb7c8":"markdown","e9dfca67":"markdown"},"source":{"351573c2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns  \nimport matplotlib.pyplot as plt\nfrom sklearn import datasets\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.metrics import accuracy_score\n#importing all the required ML packages\nfrom sklearn.linear_model import LogisticRegression #logistic regression\nfrom sklearn import svm #support vector Machine\nfrom sklearn.ensemble import RandomForestClassifier #Random Forest\nfrom sklearn.neighbors import KNeighborsClassifier #KNN\nfrom sklearn.naive_bayes import GaussianNB #Naive bayes\nfrom sklearn.tree import DecisionTreeClassifier #Decision Tree\nfrom sklearn.model_selection import train_test_split #training and testing data split\nfrom sklearn import metrics #accuracy measure\nfrom sklearn.metrics import confusion_matrix #for confusion matrix\nfrom mpl_toolkits.mplot3d import Axes3D\n# plotly\nimport plotly.plotly as py\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.graph_objs as go\n\n# word cloud library\nfrom wordcloud import WordCloud\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","858e70d0":"data = pd.read_csv(\"..\/input\/Pokemon.csv\", index_col=0)\ndata.head(10)","040d249e":"data.tail(10)","25b10d21":"data.shape","02d7da53":"data.columns","30c45d41":" \ndata = data.rename(columns={\"#\":\"index\", \"Type 1\":\"Type1\",\"Type 2\":\"Type2\",\n                           \"HP\":\"HP\", \"Sp. Atk\": \"Special_Attack\",\n                           \"Sp. Def\":\"Special_Defense\"})\ndata.info()","1362a810":"#some values in TYPE2 are empty and thus they have to be filled or deleted\ndata['Type2'].fillna(data['Type1'], inplace=True) \n#fill NaN values in Type2 with corresponding values of Type\ndata.head()","495c378d":"#let see the correlation between features:\n\nf,ax = plt.subplots(figsize=(15, 15))\nsns.heatmap(data.corr(), annot=True, linewidths=.5, fmt= '.1f',ax=ax ,cmap=\"Blues\")\nplt.show()\n","ce491d56":"fig, axarr = plt.subplots(3, 2, figsize=(13, 13))\n#ax = plt.subplot2grid((3,2),(0,0), rowspan=1, colspan=1, fig=None) also could be used\n\n# Histogram of HP\nsns.distplot(data['HP'], hist=True, kde=False, bins=50, color = 'blue', \n             hist_kws={'edgecolor':'black'}, ax=axarr[0][0], axlabel='HP')\n\n# Histogram of Attack\nsns.distplot(data['Attack'], hist=True, kde=False, bins=50, color = 'blue', \n             hist_kws={'edgecolor':'black'},ax=axarr[0][1], axlabel='Attack' )\n\n# Histogram of Defense\nsns.distplot(data['Defense'], hist=True, kde=False, bins=50, color = 'blue', \n             hist_kws={'edgecolor':'black'}, ax=axarr[1][0], axlabel='Defense')\n\n# Histogram of Special Attack\nsns.distplot(data['Special_Attack'], hist=True, kde=False, bins=50, color = 'blue', \n             hist_kws={'edgecolor':'black'}, ax=axarr[1][1], axlabel='Special Attack')\n\n#Histogram of Special Defense\nsns.distplot(data['Special_Defense'], hist=True, kde=False, bins=50, color = 'blue', \n             hist_kws={'edgecolor':'black'}, ax=axarr[2][0], axlabel='Special Defense')\n\n# Histogram of Speed\nsns.distplot(data['Speed'], hist=True, kde=False, bins=50, color = 'blue', \n             hist_kws={'edgecolor':'black'}, ax=axarr[2][1], axlabel='Speed')\n\nplt.show()","f0b8e9d2":"# Histogram of Total\n\nsns.distplot(data['Total'], hist=True, kde=False, bins=50, color = 'purple', \n             hist_kws={'edgecolor':'black'}, axlabel='Total')\nplt.axvline(data['Total'].mean(),linestyle='dashed',color='yellow') #line on average of Total\n\nfigsize=(5, 5)\n\nplt.show()","9ba62cdf":"%matplotlib inline\nplt.rcParams['figure.figsize']=10,10  #to adjust the plot size\n\ndf = data.drop(['Total', 'Generation', 'Legendary'], axis=1)\nsns.boxplot(data=df) \n\nplt.show()","deab4ea9":"# Density Plot\nsns.kdeplot(data.Attack, data.Defense)\nplt.show()","a2514654":"#prepare data frame\nNdf = data.iloc[:50,:]\n\n# Creating trace1\ntrace1 = go.Scatter(y = Ndf.Attack,\n                    x = Ndf.index,\n                    mode = \"lines+markers\",\n                    name = \"Attack\",\n                    marker = dict(color = 'blue'))\n# Creating trace2\ntrace2 = go.Scatter(y = Ndf.Defense,\n                    x = Ndf.index,\n                    mode = \"lines\",\n                    name = \"Defence\",\n                    marker = dict(color = 'red'))\n\ndataS = [trace1, trace2]\nlayout = dict(title = 'Attack and Defense of the pokemons',\n              xaxis= dict(title= 'Index',ticklen= 5,zeroline= False)\n             )\nfig = dict(data = dataS, layout = None)\niplot(fig)","c8593da4":"x2011 = data.Type1[data.Generation == 1]\nplt.subplots(figsize=(8,8))\nwordcloud = WordCloud(\n                          background_color='white',\n                          width=400,\n                          height=300\n                         ).generate(\" \".join(x2011))\nplt.imshow(wordcloud)\nplt.axis('off')\nplt.savefig('graph.png')\n\nplt.show()","03dbc63e":"# create trace 1 that is 3d scatter\ntrace1 = go.Scatter3d(\n                    y = Ndf.Attack,\n                    x = Ndf.Defense,\n                    z = Ndf.index,\n                    mode = \"markers\",\n                    name = \"Attack\",\n                    marker=dict(size=10,color='rgb(255,0,0)'))\n\nData = [trace1]\nlayout = go.Layout(\n    margin=dict(\n        l=0,\n        r=0,\n        b=0,\n        t=0  \n    )\n    \n)\nfig = go.Figure(data=Data, layout=layout)\n\niplot(fig)","8adc840e":"# Joint Distribution Plot\nsns.jointplot(x='Attack', y='Defense', data=data)\nplt.show()","cdb21025":"#let's compare the Attack and Defense stats\n\nsns.lmplot(x='Attack', y='Defense', data=data, size=4, aspect=2, fit_reg=True, \n           hue='Generation')\nplt.show()\n","73ed4d4b":"data.groupby(['Generation']).size().reset_index(name='counts')\n#data.groupby(['Generation']).size()","0b87e7fe":"sns.set(style=\"darkgrid\")\nsns.set_context(font_scale =20)\nsns.countplot(x='Generation',data=data,saturation=0.75,palette=\"Blues_d\", hue='Legendary')\nplt.xlabel('Generation', fontsize=15) \nplt.ylabel('Number', fontsize=15) \nplt.title('Number of the pokemons around different generations', fontsize=15)\n\nplt.show()","7a71c3c1":"DType=data.groupby(['Generation','Type1']).count().reset_index()\nDType=DType[['Generation','Type1','Total']]\nDType=DType.pivot('Generation','Type1','Total')\nDType[['Water','Fire','Grass','Dragon','Normal','Rock','Flying','Electric']].plot(marker='*')\nfig=plt.gcf()\nfig.set_size_inches(7,5)\n\nDType=data.groupby(['Generation','Type2']).count().reset_index()\nDType=DType[['Generation','Type2','Total']]\nDType=DType.pivot('Generation','Type2','Total')\nDType[['Water','Fire','Grass','Dragon','Normal','Rock','Flying','Electric']].plot(marker='*')\nfig=plt.gcf()\nfig.set_size_inches(7,5)\n\nplt.show()","842d9c8b":"plt.subplots(figsize = (15,5))\nplt.title('Strongest Genaration')\nsns.violinplot(x='Generation',data=data, y = \"Total\")\nplt.show()","f8e41662":"print('The unique  pokemon types are: ','\\n',data['Type1'].unique(),'\\n','\\n') #unique types of column\nprint('The number of unique types are: ''\\n',data['Type1'].nunique()) #count of unique values \n","7a4a6f6e":"gdf = data.groupby(by=['Type1', 'Type2']).agg(['max','min']).head(10)\ngdf","f5406ac7":"data.groupby(['Type1']).size().reset_index(name='counts')","1ec62929":"plt.subplots(figsize=(10,15))\nax = data['Type1'].value_counts().sort_values(ascending=True).plot.barh(width=.9,\n                                                    color=sns.color_palette('inferno',40))\nax.set_xlabel('count')\nax.set_ylabel('types')\nplt.title(\"Number of various pokemon\/type1\",loc='left', fontsize=16)\n\nplt.show()","c1a510bd":"data.groupby(['Type2']).size().reset_index(name='counts')","788eaa50":"#Lets plot both together in 2 rows 1 cols\n#first row, first col\nax1 = plt.subplot2grid((2,1),(0,0))\nlabels = 'Water', 'Normal', 'Grass', 'Bug', 'Psychic', 'Fire', 'Electric', 'Rock', 'Other'\nsizes = [112, 98, 70, 69, 57, 52, 44, 44, 175]\nexplode = (0, 0, 0.0, 0, 0, 0, 0, 0, 0.1)  # explode the last slice \nplt.pie(sizes, explode=explode, labels=labels,autopct='%1.1f%%', shadow=True, startangle=90, \n        colors=sns.cubehelix_palette(8, start=.5, rot=-.75), \n        labeldistance=1.1, rotatelabels = False)\n\nplt.axis('equal')\nplt.title(\"Distribution of various pokemon\/type1\",loc='left', fontsize=16)\nplt.plot()\nfig=plt.gcf()\nfig.set_size_inches(12,12)\n\n\n#Second row first column\nax1 = plt.subplot2grid((2,1), (1, 0))\n\nlabels = 'Water', 'Normal', 'Grass', 'Bug', 'Psychic', 'Fire', 'Electric', 'Rock', 'Other'\nsizes = [73, 65, 58, 20, 71, 40, 33, 23,286]\nexplode2 = (0, 0, 0, 0, 0.1, 0, 0, 0, 0)\nplt.pie(sizes, labels=labels,explode=explode2,autopct='%1.1f%%', shadow=True, startangle=90, \n        colors=sns.cubehelix_palette(8, start=.5, rot=-.75), \n        labeldistance=1.1, rotatelabels = False)\n\nplt.axis('equal')\nplt.title(\"Distribution of various pokemon\/type2\",loc='right', fontsize=16)\nplt.plot()\nfig=plt.gcf()\nfig.set_size_inches(12,12)\nplt.show()","3b73d2cf":"\nplt.subplots(figsize = (15,3))\nplt.title('Attack by Type1')\nsns.violinplot(x = \"Type1\", y = \"Attack\",data = data)\nplt.ylim(-100,250)\n\nplt.subplots(figsize = (15,3))\nplt.title('Attack by Type2')\nsns.violinplot(x = \"Type2\", y = \"Attack\",data = data)\nplt.ylim(-100,250)\nplt.show()","fb34e798":"# Melt DataFrame\n#Let's melt all 6 of the stat columns into one\n#The new Stat column indicates the original stats (HP, Attack, Defense, Sp. Attack...)\nTD_data = data.drop(['Total', 'Generation','Legendary'], axis=1)\nM_df = pd.melt(TD_data, \n                    id_vars=[\"Name\", \"Type1\", \"Type2\"], # Variables to keep\n                    var_name=\"Stat\") # Name of melted variable\nM_df.head()","dc974a3d":"# M_df Swarmplot \nplt.figure(figsize=(15,5))\nsns.swarmplot(x='Stat', y='value', data=M_df, hue='Type1', palette=sns.color_palette(\"coolwarm\", 18)\n              , split=True)\n# 4. Adjust the y-axis\nplt.ylim(0, 260)\n# 5. Place legend to the right\nplt.legend(bbox_to_anchor=(1, 1), loc=2)\nplt.show()","f1bb6427":"#Psychic Vs Poison\nfire=data[(data['Type1']=='Psychic') | ((data['Type2'])==\"Psychic\")] #fire contains all fire pokemons\nwater=data[(data['Type1']=='Poison') | ((data['Type2'])==\"Poison\")]  #all water pokemins\nplt.scatter(fire.Attack.head(50),fire.Defense.head(50),color='Y',label='Psychic',marker=\"*\",s=50) \nplt.scatter(water.Attack.head(50),water.Defense.head(50),color='G',label=\"Poison\",s=25)\nplt.xlabel(\"Attack\")\nplt.ylabel(\"Defense\")\nplt.legend()\nplt.plot()\nfig=plt.gcf()  #get the current figure using .gcf()\nfig.set_size_inches(12,6) #set the size for the figure\nplt.show()","f1598749":"#we'll build a model with only a some featuresthat are int type\n#We select multiple features\n#Speed is prediction Target = y\npokemon_features = ['HP', 'Attack', 'Defense', \n                    'Special_Attack', 'Special_Defense','Generation']\nDatatoModel = data[pokemon_features].reindex()\nDatatoModel.head()","87d8593e":"from sklearn.tree import DecisionTreeRegressor\ny = data['Speed']  #prediction target\n# Define model. Specify a number for random_state to ensure same results each run\nModelData = DecisionTreeRegressor(random_state=1)\n\n# Fit model\nModelData.fit(DatatoModel, y) ","4815a6a9":"print(\"Making predictions for the following 5 pokemon:\")\nprint(DatatoModel.head())\nprint(\"The predictions are\")\nprint(ModelData.predict(DatatoModel.head()))","6774c3a6":"data.groupby('Legendary').apply(np.mean)","4aa18927":"plt.figure(figsize=(12,6))\nsns.distplot(data[data['Legendary']==False].Total, color=\"red\", label=\"False\" )\nsns.distplot(data[data['Legendary']==True].Total, color=\"skyblue\", label=\"True\")\nlegend = [True, False]\nplt.legend(bbox_to_anchor=(1, 1), loc=2)\nplt.show()","dfd377ff":"%matplotlib inline\n\nsns.boxplot(x='Legendary', y='Total', data=data)\nplt.show()","e7540135":"data['Legendary'].value_counts()","fa93f146":"sns.countplot(x='Legendary', data = data, palette = 'hls')\nplt.show()","e40aae3c":"NewData = data.copy()\nNewData['Legendary'].replace([True,False],[1,0],inplace=True)\nNewData['Legendary'].tail(10)","0efd4989":"#we'll build a model with the data that categorical features droped.\n#We select multiple features\n\nfeatures = ['HP', 'Attack', 'Defense', \n                    'Special_Attack', 'Special_Defense','Generation','Legendary']\nLegModData = NewData[features].reindex()\nLegModData.head()","db8e843f":"#LegModData['Legendary'] = LegModData_target\n\ndecisiontree = DecisionTreeClassifier() # defining  new object\ntrain = LegModData[50:]   # seperated the first 50 rows are as test rest as train dataset\ntest = LegModData[:50]\n\nx_train = LegModData.drop('Legendary', axis=1) # x_train as legendary state droped\ny_train = LegModData['Legendary']  # y_train is the legendary value\n\nx_test = test.drop('Legendary', axis=1) # same thing for test dataset\ny_test = test['Legendary']\n\ndecisiontree.fit(x_train, y_train) # model decisiontree fit to x_train, y_train values\n\npred = decisiontree.predict(x_test) # make prediction to the model about x_test and keep in pred \n\nprint(\"accuracy:\", accuracy_score(y_test, pred)) #to test the accuracy of the model","478b9d9e":"> **Pok\u00e9mon is short for the original Japanese title of Pocket Monsters. **","b6aa5426":">___________________________________________\n>\n>We used the model to the Speed values.\n>\n> We already have Speed values. But we made predictions for the first 5 rows of the training data to see how the predict function works and it worked perfectly.\n>\n>___________________________________________","80db06ce":"> **let's see Pok\u00e9mon's combat stats in a box plot:**","e85bf08a":">-----------------\n>\n>\n>**PREDICTIVE MODELING** \n>\n>\n>We have gained some insights from the visualisation of data. Now let's see if we can accurately predict some of the features' values\n>\n>The steps to building and using a model are:\n>\n> * **Define:** What type of model will it be? \n> * **Fit:** Capture patterns from provided data. \n> * **Predict**: Use the model to predict.\n> * **Evaluate:** Determine how accurate the model's predictions are.\n>...","28c25dc9":"Let's see both distribution of various pokemon around Type1\/Type2 in Pie Plot","2a222537":"**LET'S ANALYSE THE DATA BY TAK\u0130NG \"GENERATION\" FEATURE INTO CONSIDERATION**","929b6a29":"> ![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/9\/98\/International_Pok%C3%A9mon_logo.svg\/2000px-International_Pok%C3%A9mon_logo.svg.png)\n","62fa2829":"> There isn't so much correlated feaures that can be considered important.\n>\n> 'Special Attack' and 'Special Defense' is correlated with being legendary with 0.4 ratio\n> 'Speed' and 'Attack' are correlated with 0.5 ratio.\n>\n> The highest we can see is the correlation between Sp.Atk and the Total","130c9602":"Let's rename the features to not have problem later.","e437db06":"Linear regration line for Generation2 has biggest slope and lowest slope is of generation5 . We can say that the highest defense in the same point of attack is of Generation2\n\nGeneration 1 and 3 has similar Defence & Attack relation. ","001b700f":">------------------ \n>Wordcloud plot of Type1 pokemons in Generation1","07b0ba79":"Generation 3 has more Legendary Pok\u00e9mon.\n\n\n\n","bdc79730":">_______________________\n>\n#    We now have a fitted model that we can use to make predictions\n>\n>************","1c89571b":"**CONCLUTION**\n>\n>It is a fun dataset to deal with. It has a lot to do with. It is possible to do these analyses for each specific type or generation separately. We see that different generations have different characteristics and values. Also, Type1 and Type2 is an important distinction to get different results.  Lastly, we can say that legendary pokemon have superiority over not legendary ones by power. \n>\n>\n>----------------------","56c273e7":"x stands for Defence\ny for Attack \nz for Index number of the pokemon","5663355c":"This shows that Psychic type pokemons have a better defence than Poison type pokemons but have lower attact.","444e88c7":"> As it is expected;\n>\n> \n>\n>*  Defence & Special Defence distrubution are quite similar.\n >\n>* Speed distrubution is close to Special Attack and Attack distributions.","4fe4d932":"While 'Steel' type of pokemons have bigger value of defence, 'Normal' has lowest values of Defense.\nWe can compare the stats of types by this plot easily.","e45bba2e":">-------------------- \n>\n>Let's see the relation of Defense & Attack by seing them in different plots.","2e79e271":">---------------------------\n>\n>3D Scatter Plot","61a3c774":"Interactive Line Charts:","7e9e38be":"**Let's see the distribution of the HP, Attack, Defense, Special Attack, Special Defense, and Speed, Total stats.**","1f5ec2b2":"We need to reduce the categorical features for a better modelling.","f0894c77":"**LET'S ANALYSE THE DATA BY TAK\u0130NG \"TYPE\" 1 AND \"TYPE2\" FEATURES INTO CONSIDERATION**","de9b3a0d":"Violinplot plots according to the density of a region. This means that the parts of the plot where the width is thicker denotes a region with higher density points whereas regions with thinner area show less densely populated points.\n>-\n>\n**For Type 1:**\n>\n>It is shown that the Psychic type pokemons have an edge over the other types as they have a higher attacks compared to the other types. Also since the fire pokemons have lower range of values, but higher attacks, they can be preferred over the grass and water types for attacking.\n>\n**For Type2:**\n>\n> It is shown that the Psychic and Fighting type pokemons have an edge over the other types as they have a higher attacks compared to the other types. \n> Also since the rock pokemons have lower range of values, but higher attacks, they can be preferred over the grass and water types for attacking.","dc217da9":"Let's fit a Logistic Regression  algorithm that is used to predict the probability of a categorical dependent variable. In logistic regression, the dependent variable is a binary variable that contains data coded as 1 (yes, success, etc.) or 0 (no, failure, etc.). In our data legendary is a categorical dependent variable.","e9a42593":">**RESULT **\n>\n>Pokemons had the highest numbers in the 1st Generation. However, the number has decreased in 2nd generation. It has increased again in 4th and 5th generation. At the end it has the lowest number in generation 6.\n>\n> Water pokemons has the highest numbers in the 1st Generation. However the number has decreased with passing generations. Similarly Grass type pokemons showed an increase in their numbers till generation 5.  The number of Type2 Grass Pokemons has been steadily increasing. The same is the case for the Dragon Type Pokemons.\n>\n> About Generations:\n> As we can see from the plot and also know from the video games there are 6 generation of pokemons relased in different times.\n> * Generation 1 includes Pokemon 1-151\n> * Generation 2 includes Pokemon 152-251\n> * Generation 3 includes Pokemon 252-386\n> * Generation 4 includes Pokemon 387-493\n> * Generation 5 includes Pokemon 494-649\n> * Generation 6 includes Pokemon 650-721\n>\n>\n> **And the last violinplot shows that generation 3 is the strongest generation.**\n>\n>...","b13eecd8":"> \n>As we see there are 721 pokemon. However 800 rows are in data set. That is because some of the pokemons have versions with different feature values because of evolving in different levels.\n>\n>For instance, \n>Venusaur is a dual-type Grass\/Poison Pok\u00e9mon introduced in Generation I. \n>It evolves from Ivysaur starting at level 32. It is the final form of Bulbasaur. It can Mega Evolve into Mega Venusaur using the Venusaurite.\n>\n>These pairs are indexed with same number","09fcb932":">** LET'S TRY ANOTHER MODEL**","87ffb7c8":"We see that, althought the boundaries are not clearly seperated legandary True and False , around 650 is like a natural break point. ","e9dfca67":"**Let's select data for modeling**"}}