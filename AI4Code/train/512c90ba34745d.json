{"cell_type":{"f406cd9e":"code","ddf65d1c":"code","2d9a1761":"code","11becb27":"code","09580ce0":"code","3943b029":"code","1937e3b4":"code","e708ca84":"code","6bd99cc1":"code","47c6220c":"code","0f3250db":"code","1709d4d6":"code","70573316":"code","d3b0889c":"code","14bbfdb9":"code","92badd7e":"markdown","a3b99c01":"markdown","66d81d4d":"markdown","d08453cc":"markdown","ee7f1b70":"markdown","8f7401ad":"markdown","f239c574":"markdown","b2830ce1":"markdown","e456ec6e":"markdown","83186d89":"markdown","4f178de0":"markdown"},"source":{"f406cd9e":"import cudf\nimport cupy\nimport xgboost as xgb\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n%matplotlib inline\nsns.set_style(\"whitegrid\")","ddf65d1c":"data = cudf.read_csv(\"\/kaggle\/input\/creditcardfraud\/creditcard.csv\")\ndata['Class'] = data['Class'].astype('float32')\ndata.head()","2d9a1761":"print(\"Number of missing values:\")\ndata.isnull().sum().sum()","11becb27":"count_classes = data['Class'].value_counts(sort=True)\ncount_classes","09580ce0":"fraud = data[data['Class']==1]\nnormal = data[data['Class']==0]\n\nprint(f\"Shape of Fraudulant transactions: {fraud.shape}\")\nprint(f\"Shape of Non-Fraudulant transactions: {normal.shape}\")","3943b029":"a_fraud = fraud.Amount.describe().to_frame().transpose()\na_normal = normal.Amount.describe().to_frame().transpose()\namount = cudf.concat([a_fraud,a_normal],axis=0)\namount.index = ['fraud','normal']\nprint(\"Amount: fraud vs normal\")\namount","1937e3b4":"t_fraud = fraud.Time.describe().to_frame().transpose()\nt_normal = normal.Time.describe().to_frame().transpose()\ntime = cudf.concat([t_fraud,t_normal],axis=0)\ntime.index = ['fraud','normal']\nprint(\"Time: fraud vs normal\")\ntime","e708ca84":"# plot the time feature\nplt.figure(figsize=(10,8))\n\nplt.subplot(2, 2, 1)\nplt.title('Time Distribution (Seconds)')\n\nsns.distplot(data['Time'].values.get(), color='blue');\n\n#plot the amount feature\nplt.subplot(2, 2, 2)\nplt.title('Distribution of Amount')\nsns.distplot(data['Amount'].values.get(),color='blue');","6bd99cc1":"# data[data.Class == 0].Time.hist(bins=35, color='blue', alpha=0.6)\nplt.figure(figsize=(12, 10))\n\nplt.subplot(2, 2, 1)\ndata[data.Class == 1].Time.to_pandas().hist(bins=35, color='blue', alpha=0.6, label=\"Fraudulant Transaction\")\nplt.legend()\n\nplt.subplot(2, 2, 2)\ndata[data.Class == 0].Time.to_pandas().hist(bins=35, color='blue', alpha=0.6, label=\"Non Fraudulant Transaction\")\nplt.legend()","47c6220c":"from cuml.model_selection import train_test_split\nfrom cuml.preprocessing import StandardScaler\n\nscalar = StandardScaler()\n\nX = data.drop('Class', axis=1)\ny = data.Class\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, \n                                                    test_size=0.3, random_state=42)\ny_train.mean(), y_test.mean()","0f3250db":"print(f\"TRAINING: X_train: {X_train.shape}, y_train: {y_train.shape}\\n{'_'*55}\")\nprint(f\"TESTING: X_test: {X_test.shape}, y_test: {y_test.shape}\")","1709d4d6":"max_depth = 10\nnum_trees = 300\n\nparams = {\n            'eta':0.1,\n            'objective': 'binary:logistic',\n            'eval_metric': 'error',\n            'tree_method': 'gpu_hist',\n            'max_depth': max_depth,\n            'predictor': 'gpu_predictor'\n        }","70573316":"dtrain = xgb.DMatrix(data=X_train, label=y_train)\ndtest = xgb.DMatrix(data=X_test, label=y_test)\nwatchlist = [(dtrain, 'train'), (dtest, 'test')] \n\nbst = xgb.train(params, dtrain=dtrain,\n    num_boost_round=num_trees,evals=watchlist,\n    verbose_eval=100)","d3b0889c":"max_depth = 3\nnum_trees = 50\n\nparams = {\n            'eta':0.1,\n            'objective': 'binary:logistic',\n            'eval_metric': 'error',\n            'tree_method': 'gpu_hist',\n            'max_depth': max_depth,\n            'predictor': 'gpu_predictor'\n        }","14bbfdb9":"dtrain = xgb.DMatrix(data=X_train, label=y_train)\ndtest = xgb.DMatrix(data=X_test, label=y_test)\nwatchlist = [(dtrain, 'train'), (dtest, 'test')] \n\nbst = xgb.train(params, dtrain=dtrain,\n    num_boost_round=num_trees,evals=watchlist,\n    verbose_eval=10)","92badd7e":"# XGB Training","a3b99c01":"### The only non-transformed variables to work with are:\n- `Time`\n- `Amount`\n- `Class` (1: fraud, 0: not_fraud)","66d81d4d":"# 2. Exploratory Data Analysis\n","d08453cc":"Notice how imbalanced is our original dataset! Most of the transactions are non-fraud. If we use this dataframe as the base for our predictive models and analysis we might get a lot of errors and our algorithms will probably overfit since it will \"assume\" that most transactions are not fraud. But we don't want our model to assume, we want our model to detect patterns that give signs of fraud!","ee7f1b70":"How different are the amount of money used in different transaction classes?","8f7401ad":"#### Model 2 (small): \n- `max_depth = 3`\n- `num_trees = 50`","f239c574":"# 3. Data Pre-processing\n\n`Time` and `Amount` should be scaled as the other columns.","b2830ce1":"Do fraudulent transactions occur more often during certain time frame ?","e456ec6e":"By seeing the distributions we can have an idea how skewed are these features, we can also see further distributions of the other features. There are techniques that can help the distributions be less skewed which will be implemented in this notebook in the future.\n\nDoesn't seem like the time of transaction really matters here as per above observation.\nNow let us take a sample of the dataset for out modelling and prediction","83186d89":"#### Model 1 (big): \n- `max_depth = 10`\n- `num_trees = 300`","4f178de0":"#### In this notebook, we show a full GPU pipleline from ETL to XGB training. We compare two xgboost models with different depth and number of trees. The notebook is adapted from [FARES SAYAH's wonderful notebook](https:\/\/www.kaggle.com\/faressayah\/credit-card-fraud-detection-anns-vs-xgboost). "}}