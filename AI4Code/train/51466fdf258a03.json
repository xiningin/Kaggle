{"cell_type":{"f7127cbc":"code","08e43301":"code","6072a25c":"code","36708c35":"code","ddd6ad46":"code","7d7ef0b1":"code","212fbe28":"code","da8bef88":"code","9317b3c6":"code","adfc55cc":"code","c0afe27d":"code","7ee76d31":"code","59a9ae45":"code","cff3b71d":"code","f5b1e2a0":"code","b3246642":"code","d0719bb8":"code","dc7d981b":"code","9475a340":"code","256cb1f0":"code","1254cd51":"code","f1a61617":"code","db6dd4fe":"code","84b4f825":"code","758a9a8f":"code","b4f92cf5":"code","b2f4aa61":"code","1429b5de":"code","b7225356":"code","4cfc9cfc":"code","8324bb98":"code","ab11a264":"code","3269a44d":"code","aa1ba9f5":"code","d093d2df":"code","26ded942":"code","620adb0e":"code","81ba7e65":"code","6da85946":"code","2b997e0d":"code","37daeccc":"code","6aec4ebc":"code","12ea5e54":"code","a444438c":"code","9629c6b0":"code","e51a2892":"code","2f62c259":"code","4918c1e0":"code","6361c6fc":"code","cc08ac5f":"code","6cf625f8":"code","5b18eef0":"code","52675173":"code","1f2ad67b":"code","31fbafe7":"code","7d80797d":"code","3399d4a8":"code","143e4b5d":"code","c45c8332":"markdown","3611d0f3":"markdown","015e29a0":"markdown","085d6ddd":"markdown","31f449cc":"markdown","cc870191":"markdown","ef5436ec":"markdown"},"source":{"f7127cbc":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","08e43301":"# standard imports\nimport numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport tensorflow as tf","6072a25c":"labels_csv = pd.read_csv('\/kaggle\/input\/dog-breed-identification\/labels.csv')\nlabels_csv.head()","36708c35":"labels_csv.describe()","ddd6ad46":"labels_csv['breed'].value_counts().plot.bar(figsize=(20,12));","7d7ef0b1":"#median number of image in each class.\nlabels_csv['breed'].value_counts().median()","212fbe28":"#viewing any image from the train data.\nfrom IPython.display import Image\nImage('\/kaggle\/input\/dog-breed-identification\/train\/0a0c223352985ec154fd604d7ddceabd.jpg')","da8bef88":"filenames = ['\/kaggle\/input\/dog-breed-identification\/train\/' + fname + '.jpg' for fname in labels_csv['id']]\nfilenames[:5]","9317b3c6":"# Check wheather the the number of files matches number of actual images.\nif len(os.listdir('\/kaggle\/input\/dog-breed-identification\/train\/')) == len(filenames):\n    print('Number of file matches number of actual images!')\nelse:\n    print('Number of file doesnot matches number of actual images!!')","adfc55cc":"#visualizing images according to their index.\nImage(filenames[900])","c0afe27d":"#finding the name of the above displayed dog.\nlabels_csv['breed'][900]","7ee76d31":"labels = labels_csv['breed']\nlabels = np.array(labels)\nlabels","59a9ae45":"#Check wheather the number of labels matches the number of filenames.\nif len(labels) == len(filenames):\n    print('Number of labels matches the number of filenames.')\nelse:\n    print('Number of labels doesnot matches the number of filenames')","cff3b71d":"#Finding the unique labels values\nunique_breed = np.unique(labels) \nunique_breed","f5b1e2a0":"#Turn single label into an array of boolean.\nprint(labels[0])\nlabels[0] == unique_breed","b3246642":"#Turning every label into an array of boolean\nboolean_labels = [labels == unique_breed for labels in labels]\nboolean_labels[:2]","d0719bb8":"# Turining boolean arrays into integers.\nprint(labels[0])   #orginal index\nprint(np.where(unique_breed==labels[0]))    #index where labels occurs.\nprint(boolean_labels[0].argmax())     #index where label occurs in boolean array\nprint(boolean_labels[0].astype(int))   #there will be a 1 where sample label occurs","dc7d981b":"# setup x and y variables.\nX = filenames\ny = boolean_labels","9475a340":"# First starting with ~1000 images because we have lots of data to train for the very first attempt\n\n#set number of images to set for the experiment.\nNUM_IMAGES = 1000 #@param {type:\"slider\",min:1000,max:10000}","256cb1f0":"#let's split our data into train and validation.\nfrom sklearn.model_selection import train_test_split\n\n#spliting into training and validation of total size NUM_IMAGES.\n\nX_train,X_val,y_train,y_val = train_test_split(X[:NUM_IMAGES],\n                                                y[:NUM_IMAGES],\n                                                test_size=0.2,\n                                                random_state=42)\nlen(X_train),len(X_val),len(y_train),len(y_val)","1254cd51":"X_train[:5],y_train[:5]","f1a61617":"# converting images to numpy array\n\nfrom matplotlib.pyplot import imread\nimage = imread(filenames[42])\nimage.shape","db6dd4fe":"image","84b4f825":"#lets conver them into tensor\ntf.constant(image)[:2]","758a9a8f":"# Making a function to preprocess the data\n\n# Define image size\nIMG_SIZE = 224\n\ndef process_image(image_path):\n  \"\"\"\n  Takes an image file path and turns it into a Tensor.\n  \"\"\"\n  # Read in image file\n  image = tf.io.read_file(image_path)\n  # Turn the jpeg image into numerical Tensor with 3 colour channels (Red, Green, Blue)\n  image = tf.image.decode_jpeg(image, channels=3)\n  # Convert the colour channel values from 0-225 values to 0-1 values\n  image = tf.image.convert_image_dtype(image, tf.float32)\n  # Resize the image to our desired size (224, 244)\n  image = tf.image.resize(image, size=[IMG_SIZE, IMG_SIZE])\n  return image","b4f92cf5":"# Create a simple function to return a tuple (image, label)\ndef get_image_label(image_path, label):\n  \"\"\"\n  Takes an image file path name and the associated label,\n  processes the image and returns a tuple of (image, label).\n  \"\"\"\n  image = process_image(image_path)\n  return image, label","b2f4aa61":"# Define the batch size, 32 is a good default\nBATCH_SIZE = 32\n\n# Create a function to turn data into batches\ndef create_data_batches(x, y=None, batch_size=BATCH_SIZE, valid_data=False, test_data=False):\n  \"\"\"\n  Creates batches of data out of image (x) and label (y) pairs.\n  Shuffles the data if it's training data but doesn't shuffle it if it's validation data.\n  Also accepts test data as input (no labels).\n  \"\"\"\n  # If the data is a test dataset, we probably don't have labels\n  if test_data:\n    print(\"Creating test data batches...\")\n    data = tf.data.Dataset.from_tensor_slices((tf.constant(x))) # only filepaths\n    data_batch = data.map(process_image).batch(BATCH_SIZE)\n    return data_batch\n  \n  # If the data if a valid dataset, we don't need to shuffle it\n  elif valid_data:\n    print(\"Creating validation data batches...\")\n    data = tf.data.Dataset.from_tensor_slices((tf.constant(x), # filepaths\n                                               tf.constant(y))) # labels\n    data_batch = data.map(get_image_label).batch(BATCH_SIZE)\n    return data_batch\n\n  else:\n    # If the data is a training dataset, we shuffle it\n    print(\"Creating training data batches...\")\n    # Turn filepaths and labels into Tensors\n    data = tf.data.Dataset.from_tensor_slices((tf.constant(x), # filepaths\n                                              tf.constant(y))) # labels\n    \n    # Shuffling pathnames and labels before mapping image processor function is faster than shuffling images\n    data = data.shuffle(buffer_size=len(x))\n\n    # Create (image, label) tuples (this also turns the image path into a preprocessed image)\n    data = data.map(get_image_label)\n\n    # Turn the data into batches\n    data_batch = data.batch(BATCH_SIZE)\n  return data_batch","1429b5de":"# Create training and validation data batches\ntrain_data = create_data_batches(X_train, y_train)\nval_data = create_data_batches(X_val, y_val, valid_data=True)","b7225356":"# Check out the different attributes of our data batches\ntrain_data.element_spec, val_data.element_spec","4cfc9cfc":"# Setting up input shape to the model\nINPUT_SHAPE = [BATCH_SIZE, IMG_SIZE, IMG_SIZE, 3] # batch, height, width, colour channels\n\n# Setting up output shape of the model\nOUTPUT_SHAPE = len(unique_breed) # number of unique labels","8324bb98":"INPUT_SHAPE","ab11a264":"from tensorflow import keras\npretrained_base = keras.applications.MobileNetV2(\n    input_shape = (224,224,3),\n    include_top=False, weights='imagenet'\n)\n\npretrained_base.trainable = False","3269a44d":"from tensorflow.keras import layers\n\nmodel = keras.Sequential([\n    pretrained_base,\n    #layers.Flatten(),\n    #layers.Dense(120, activation='softmax'),\n])","aa1ba9f5":"# Compile the model\nmodel.compile(\n      loss=tf.keras.losses.CategoricalCrossentropy(), # Our model wants to reduce this (how wrong its guesses are)\n      optimizer=tf.keras.optimizers.Adam(), # A friend telling our model how to improve its guesses\n      metrics=[\"accuracy\"] # We'd like this to go up\n  )","d093d2df":"# Check details of model\nmodel.summary()","26ded942":"# early_stopping = tf.keras.callbacks.EarlyStopping(\n#     patience=5,\n#     min_delta=0.01,\n#     restore_best_weights=True,\n#     )","620adb0e":"#history =  model.fit(\n#             x=train_data,\n#             epochs=10,\n#             validation_data=val_data,\n#             validation_freq=1, # check validation metrics every epoch\n#             verbose=1,\n#             callbacks=[early_stopping])","81ba7e65":"#history_df = pd.DataFrame(history.history)\n#history_df.loc[:, ['loss', 'val_loss']].plot();","6da85946":"#history_df.loc[:, ['accuracy', 'val_accuracy']].plot();","2b997e0d":"predictions = model.predict(val_data, verbose=1) # verbose shows us how long there is to go\npredictions","37daeccc":"top_5_classes_index = np.argsort(predictions)[0 , ::-1][:5]+1\n\nprint(top_5_classes_index)\n\ntop_5_classes = labels[top_5_classes_index]\nprint(top_5_classes)","6aec4ebc":"labels.shape","12ea5e54":"# First prediction\n# print(predictions[0])\n# print(f\"Max value (probability of prediction): {np.max(predictions[0])}\") # the max probability value predicted by the model\n# print(f\"Sum: {np.sum(predictions[0])}\") # because we used softmax activation in our model, this will be close to 1\n# print(f\"Max index: {np.argmax(predictions[0])}\") # the index of where the max value in predictions[0] occurs\n# print(f\"Predicted label: {unique_breed[np.argmax(predictions[0])]}\") # the predicted label","a444438c":"# Turn prediction probabilities into their respective label (easier to understand)\ndef get_pred_label(prediction_probabilities):\n  \"\"\"\n  Turns an array of prediction probabilities into a label.\n  \"\"\"\n  return labels[np.argmax(prediction_probabilities)]\n\n# Get a predicted label based on an array of prediction probabilities\npred_label = get_pred_label(predictions[0])\npred_label","9629c6b0":"# Create a function to unbatch a batched dataset\ndef unbatchify(data):\n  \"\"\"\n  Takes a batched dataset of (image, label) Tensors and returns separate arrays\n  of images and labels.\n  \"\"\"\n  images = []\n  labels = []\n  # Loop through unbatched data\n  for image, label in data.unbatch().as_numpy_iterator():\n    images.append(image)\n    labels.append(unique_breed[np.argmax(label)])\n  return images, labels\n\n# Unbatchify the validation data\nval_images, val_labels = unbatchify(val_data)\nval_images[0], val_labels[0]","e51a2892":"def plot_pred(prediction_probabilities, labels, images, n=1):\n  \"\"\"\n  View the prediction, ground truth label and image for sample n.\n  \"\"\"\n  pred_prob, true_label, image = prediction_probabilities[n], labels[n], images[n]\n  \n  # Get the pred label\n  pred_label = get_pred_label(pred_prob)\n  \n  # Plot image & remove ticks\n  plt.imshow(image)\n  plt.xticks([])\n  plt.yticks([])\n\n  # Change the color of the title depending on if the prediction is right or wrong\n  if pred_label == true_label:\n    color = \"green\"\n  else:\n    color = \"red\"\n\n  plt.title(\"{} {:2.0f}% ({})\".format(pred_label,\n                                      np.max(pred_prob)*100,\n                                      true_label),\n                                      color=color)","2f62c259":"# View an example prediction, original image and truth label\nplot_pred(prediction_probabilities=predictions,\n          labels=val_labels,\n          images=val_images)","4918c1e0":"plot_pred(prediction_probabilities=predictions,\n          labels=val_labels,\n          images=val_images, n=2)","6361c6fc":"plot_pred(prediction_probabilities=predictions,\n          labels=val_labels,\n          images=val_images, n=3)","cc08ac5f":"plot_pred(prediction_probabilities=predictions,\n          labels=val_labels,\n          images=val_images, n=42)","6cf625f8":"print(f\"Predicted label: {labels[np.argmax(predictions[0])]}\") # the predicted label","5b18eef0":"predictions.shape","52675173":"pred_labels=[]\nfor i in range(200): \n    pred_labels.append(get_pred_label(predictions[i]))","1f2ad67b":"true_labels=[]\nfor i in range(200): \n    true_labels.append(labels[i])","31fbafe7":"from sklearn.metrics import classification_report\n\nprint(classification_report(true_labels, pred_labels))","7d80797d":"from sklearn.metrics import accuracy_score\naccuracy_score(true_labels, pred_labels)","3399d4a8":"from sklearn.metrics import confusion_matrix\nconfusion_matrix(true_labels, pred_labels)","143e4b5d":"pred_labels=[]\nfor i in range(200): \n    pred_labels.append(get_pred_label(predictions[i]))\ny_test=val_labels\ny_pred=pred_labels\n#importing confusion matrix\nfrom sklearn.metrics import confusion_matrix\nconfusion = confusion_matrix(val_labels, pred_labels)\nprint('Confusion Matrix\\n')\nprint(confusion)\n\n#importing accuracy_score, precision_score, recall_score, f1_score\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nprint('\\nAccuracy: {:.2f}\\n'.format(accuracy_score(y_test, y_pred)))\n\nprint('Micro Precision: {:.2f}'.format(precision_score(y_test, y_pred, average='micro')))\nprint('Micro Recall: {:.2f}'.format(recall_score(y_test, y_pred, average='micro')))\nprint('Micro F1-score: {:.2f}\\n'.format(f1_score(y_test, y_pred, average='micro')))\n\nprint('Macro Precision: {:.2f}'.format(precision_score(y_test, y_pred, average='macro')))\nprint('Macro Recall: {:.2f}'.format(recall_score(y_test, y_pred, average='macro')))\nprint('Macro F1-score: {:.2f}\\n'.format(f1_score(y_test, y_pred, average='macro')))\n\nprint('Weighted Precision: {:.2f}'.format(precision_score(y_test, y_pred, average='weighted')))\nprint('Weighted Recall: {:.2f}'.format(recall_score(y_test, y_pred, average='weighted')))\nprint('Weighted F1-score: {:.2f}'.format(f1_score(y_test, y_pred, average='weighted')))\n\nfrom sklearn.metrics import classification_report\nprint('\\nClassification Report\\n')\nprint(classification_report(y_test, y_pred))","c45c8332":"# Creating our own validation set","3611d0f3":"\n# Turning our data into batches\n\nWhy turn our data into batches?\n\nWe are trying to fit the 10000+ data images. They all might not fit into memory.\n\nSo,that's why we use 32(this is batch size) images at a time. we can change the batch size whenever we need.\n\nIn order to use the tensorflow effective we need to convert the images into tuple tensor which looks like (image,labels)\n","015e29a0":"# Getting images and their labels","085d6ddd":"# Creating and training a model.\n\nNow our data is ready now lets model our data.\n\nBefore we build a model, there are a few things we need to define:\n\n    The input shape (images, in the form of Tensors) to our model.\n    The output shape (image labels, in the form of Tensors) of our model.\n\n","31f449cc":"# Get a look at labels","cc870191":"# Preprocessing Images\nTurning images into tensors\n\nLet's write a function to preprocess the image. The function will do the following tasks.\n\n    The function will take an image filepath as input.\n    Use the tensorflow to read the file and save it to the variable.\n    Turn our variable (.jpg) into tensors.\n    Normalize our image(convert color channel from 0-255 to 0-1).|\n    Resize the image.\n    Return the modified variable.\n","ef5436ec":"# Turning our data into numbers"}}