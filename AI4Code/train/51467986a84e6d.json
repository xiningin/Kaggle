{"cell_type":{"ff7f0c06":"code","225ea3eb":"code","d1b75dc2":"code","0ab681bc":"code","1135252b":"code","62f4c9db":"code","c51b59e2":"code","d542b335":"code","2b5f73af":"code","1d7fde11":"code","92f3673c":"code","7b16bd23":"code","8b66a775":"code","5aa4eff8":"code","9cb85216":"code","45f62ddc":"code","37d8430b":"code","4ffeb0e1":"code","9ec5c4a0":"code","30182ab4":"code","290067eb":"code","9f62af81":"code","c26a9df0":"code","e722d097":"code","fec0b90d":"code","5baa4e65":"code","413508cd":"code","61cb88f9":"code","d508ee7c":"code","10d4d9c3":"code","46c7bb89":"code","9363f174":"code","77179b56":"code","3fa8ed6b":"code","05fab442":"code","7dff1832":"code","2256f937":"code","5ff0b7ec":"code","f81aefdc":"code","c1c525b2":"code","7dc77830":"code","ce0c6428":"code","0cdf5660":"code","1d727c95":"code","816f8e32":"code","7491e1b4":"code","37f1576e":"code","b8463ca8":"code","ba09f100":"code","51d53a73":"code","5a1a4a6f":"code","43f6679b":"code","4b543c88":"code","1a0c3818":"code","bdfc1cb2":"code","8a5e1f1d":"code","1e00e9a9":"code","528abead":"code","f6df7871":"code","89ae4e74":"code","b000a886":"code","9eb02553":"code","e09c4dce":"code","48fcb193":"code","f659f434":"markdown","60393a82":"markdown","29567ec8":"markdown","fff62e36":"markdown","4d4f8f7f":"markdown","792725e9":"markdown","7d840c1d":"markdown","745af2e5":"markdown","b99dc8b1":"markdown","6e485b84":"markdown","e1dd7d5a":"markdown","1247c8bd":"markdown","ab3ce5a4":"markdown","d41a9f70":"markdown","2133eaf2":"markdown","6c7ca14f":"markdown","6ca3b537":"markdown","09dd8141":"markdown","f84edc81":"markdown","aeb98607":"markdown","88817a4e":"markdown","c23db79b":"markdown","160aef93":"markdown","b0f57a0f":"markdown","7d5ee335":"markdown","6c0db742":"markdown","d5bfe21d":"markdown","5eb8b6ec":"markdown","ffd2cf14":"markdown","3c23ca72":"markdown","a23ab172":"markdown","9dd50d5c":"markdown","3ebf84cb":"markdown","ac1f2e1d":"markdown","f1167bbd":"markdown","4f3a9c51":"markdown","ccc22dbd":"markdown","bbdd46ff":"markdown","5f89df24":"markdown","734ba974":"markdown","f2380fe4":"markdown","95d36a1b":"markdown","c2521a33":"markdown","6911406a":"markdown","42bca815":"markdown","36b12481":"markdown","826664ef":"markdown","4712db17":"markdown","15b3da51":"markdown","faf491a9":"markdown","f7ee2f1a":"markdown","d716b99f":"markdown","24418db2":"markdown","f55385a2":"markdown","01e19c8a":"markdown","6b60ef1a":"markdown","de9bb036":"markdown","3eedf6c0":"markdown","15d58d69":"markdown","d686eccc":"markdown","fcfbed84":"markdown","0903ae98":"markdown"},"source":{"ff7f0c06":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nimport re #regex applies a regular expression to a string and returns the matching substrings. \nimport matplotlib.pyplot as plt\nimport seaborn as sns \nimport nltk \nfrom sklearn import feature_extraction, model_selection, naive_bayes, pipeline, manifold, preprocessing\nimport nltk.corpus\nfrom nltk.corpus import stopwords\nfrom nltk.tokenize import BlanklineTokenizer\nfrom nltk.tokenize import TweetTokenizer\nnltk.download('punkt')\nnltk.download('wordnet')\nnltk.download('stopwords')\nfrom nltk.stem import WordNetLemmatizer\nimport string\nfrom nltk.util import ngrams\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom collections import defaultdict\nfrom collections import  Counter\nplt.style.use('ggplot')\nstop=set(stopwords.words('english'))\nimport re\nimport scikitplot as skplt\nfrom nltk.tokenize import word_tokenize\nimport gensim\nfrom keras.preprocessing.text import Tokenizer\nfrom keras.preprocessing.sequence import pad_sequences\nfrom tqdm import tqdm\nfrom keras.models import Sequential\nfrom keras.layers import Embedding,LSTM,Dense,SpatialDropout1D\nfrom keras.initializers import Constant\nfrom sklearn.model_selection import train_test_split\nfrom keras.optimizers import Adam\nfrom nltk.stem import PorterStemmer \nfrom nltk.tokenize import word_tokenize\nfrom wordcloud import WordCloud\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nimport pickle\nfrom multiprocessing import Pool","225ea3eb":"train_data = pd.read_csv('..\/input\/nlp-getting-started\/train.csv')\ntest_data  = pd.read_csv('..\/input\/nlp-getting-started\/test.csv')\n","d1b75dc2":"train_data.head(10)","0ab681bc":"print('There are {} rows and {} columns in train'.format(train_data.shape[0],train_data.shape[1]))\nprint('There are {} rows and {} columns in train'.format(test_data.shape[0],test_data.shape[1]))","1135252b":"train_data.dtypes","62f4c9db":"#Let's display one the tweets existed in the text column \ntrain_data['text'][11]","c51b59e2":"x=train_data.target.value_counts()\nsns.barplot(x.index,x)\nplt.gca().set_ylabel('samples')","d542b335":"fig,(ax1,ax2)=plt.subplots(1,2,figsize=(10,5))\ntweet_len=train_data[train_data['target']==1]['text'].str.len()\nax1.hist(tweet_len,color='blue')\nax1.set_title('disaster tweets')\ntweet_len=train_data[train_data['target']==0]['text'].str.len()\nax2.hist(tweet_len,color='CRIMSON')\nax2.set_title('Not disaster tweets')\nfig.suptitle('Characters in tweets')\nplt.show()","2b5f73af":"fig,(ax1,ax2)=plt.subplots(1,2,figsize=(10,5))\ntweet_len=train_data[train_data['target']==1]['text'].str.split().map(lambda x: len(x))\nax1.hist(tweet_len,color='blue')\nax1.set_title('disaster tweets')\ntweet_len=train_data[train_data['target']==0]['text'].str.split().map(lambda x: len(x))\nax2.hist(tweet_len,color='CRIMSON')\nax2.set_title('Not disaster tweets')\nfig.suptitle('Words in a tweet')\nplt.show()\n","1d7fde11":"fig,(ax1,ax2)=plt.subplots(1,2,figsize=(10,5))\nword=train_data[train_data['target']==1]['text'].str.split().apply(lambda x : [len(i) for i in x])\nsns.distplot(word.map(lambda x: np.mean(x)),ax=ax1,color='red')\nax1.set_title('disaster')\nword=train_data[train_data['target']==0]['text'].str.split().apply(lambda x : [len(i) for i in x])\nsns.distplot(word.map(lambda x: np.mean(x)),ax=ax2,color='green')\nax2.set_title('Not disaster')\nfig.suptitle('Average word length in each tweet')","92f3673c":"corpus=[]\n    \nfor x in train_data['text'].str.split():\n    for i in x:\n        corpus.append(i)\n","7b16bd23":"#corpus\n#the output is hidden.","8b66a775":"dic=defaultdict(int)\ndic=defaultdict(int)\nfor word in corpus:\n    if word not in stop:\n        dic[word]+=1\n\ntop=sorted(dic.items(), key=lambda x:x[1],reverse=True)[:30] \n    \n\n\nx,y=zip(*top)\nplt.rcParams[\"figure.figsize\"] = (20,10)\nplt.bar(x,y , color ='red')","5aa4eff8":"from nltk.corpus import stopwords\nstop = stopwords.words('english')\ndic=defaultdict(int)\nfor word in corpus:\n    if word in stop:\n        dic[word]+=1\n\ntop=sorted(dic.items(), key=lambda x:x[1],reverse=True)[:30] \n    \n\n\nx,y=zip(*top)\nplt.rcParams[\"figure.figsize\"] = (20,10)\n#There is also this workaround in case you want to change the size without using the figure environment.\n#So in case you are using plt.plot() for example, you can set a tuple with width and height.\nplt.bar(x,y , color ='green')","9cb85216":"plt.figure(figsize=(10,5))\nimport string\ndic=defaultdict(int)\nspecial = string.punctuation\nfor i in (corpus):\n    if i in special:\n        dic[i]+=1\n      \nx,y=zip(*dic.items())\nplt.barh(x,y ,color = 'purple')","45f62ddc":"from collections import Counter\n\nwords = train_data[train_data.target==0].text.apply(lambda x: [word.lower() for word in x.split()])\nh_words = Counter()\n\nfor text_ in words:\n    h_words.update(text_)\n    \nprint(h_words.most_common(50))","37d8430b":"words = train_data[train_data.target==1].text.apply(lambda x: [word.lower() for word in x.split()])\nh_words = Counter()\n\nfor text_ in words:\n    h_words.update(text_)\n    \nprint(h_words.most_common(50))","4ffeb0e1":"missing_cols = ['keyword', 'location']\n\nfig, axes = plt.subplots(ncols=2, figsize=(17, 4), dpi=100)\n\nsns.barplot(x=train_data[missing_cols].isnull().sum().index, y=train_data[missing_cols].isnull().sum().values, ax=axes[0])\nsns.barplot(x=train_data[missing_cols].isnull().sum().index, y=train_data[missing_cols].isnull().sum().values, ax=axes[1])\n\naxes[0].set_ylabel('Missing Value Count', size=15, labelpad=20)\naxes[0].tick_params(axis='x', labelsize=15)\naxes[0].tick_params(axis='y', labelsize=15)\naxes[1].tick_params(axis='x', labelsize=15)\naxes[1].tick_params(axis='y', labelsize=15)\n\naxes[0].set_title('Training Set', fontsize=13)\naxes[1].set_title('Test Set', fontsize=13)\n\nplt.show()\n\n\nfor df in [train_data, test_data]:\n    for col in ['keyword','location']:\n        df[col] = df[col].fillna(f'no_{col}')\n","9ec5c4a0":"print(f'Number of unique values in keyword = {train_data[\"keyword\"].nunique()} (Training) - {test_data[\"keyword\"].nunique()} (Test)')\nprint(f'Number of unique values in location = {train_data[\"location\"].nunique()} (Training) - {test_data[\"location\"].nunique()} (Test)')","30182ab4":"train_data['target_mean'] = train_data.groupby('keyword')['target'].transform('mean')\n\nfig = plt.figure(figsize=(8, 72), dpi=100)\n\nsns.countplot(y=train_data.sort_values(by='target_mean', ascending=False)['keyword'],\n              hue=train_data.sort_values(by='target_mean', ascending=False)['target'])\n\nplt.tick_params(axis='x', labelsize=15)\nplt.tick_params(axis='y', labelsize=12)\nplt.legend(loc=1)\nplt.title('Target Distribution in Keywords')\n\nplt.show()\n\ntrain_data.drop(columns=['target_mean'], inplace=True)\n","290067eb":"def  clean_text(df, text_field, new_text_field_name):\n    df[new_text_field_name] = df[text_field].str.lower() #Convert strings in the Series\/Index to lowercase.\n    \n    # remove numbers\n    df[new_text_field_name] = df[new_text_field_name].apply(lambda elem: re.sub(r\"\\d+\", \"\", elem))\n    #remove url\n    df[new_text_field_name] = df[new_text_field_name].apply(lambda elem: re.sub(r\"https?:\/\/\\S+|www\\.\\S+\", \"\", elem))\n    #remove HTML tags\n    df[new_text_field_name] = df[new_text_field_name].apply(lambda elem: re.sub(r\"<.*?>\", \"\", elem))\n    #remove emojis \n    df[new_text_field_name] = df[new_text_field_name].apply(lambda elem: re.sub(r\"[\"\n                           u\"\\U0001F600-\\U0001F64F\"  # emoticons\n                           u\"\\U0001F300-\\U0001F5FF\"  # symbols & pictographs\n                           u\"\\U0001F680-\\U0001F6FF\"  # transport & map symbols\n                           u\"\\U0001F1E0-\\U0001F1FF\"  # flags (iOS)\n                           u\"\\U00002702-\\U000027B0\"\n                           u\"\\U000024C2-\\U0001F251\"\n                           \"]+\", \"\", elem))\n    return df\ndata_clean = clean_text(train_data, 'text', 'text_clean')\ndata_clean_test = clean_text(test_data,'text', 'text_clean')\ndata_clean.head()","9f62af81":"from nltk.corpus import stopwords\nstop = stopwords.words('english')\ndata_clean['text_clean'] = data_clean['text_clean'].apply(lambda x: ' '.join([word for word in x.split() if word not in (stop)]))\ndata_clean.head()","c26a9df0":"\nfrom nltk.tokenize import sent_tokenize, word_tokenize\ndata_clean['text_tokens'] = data_clean['text_clean'].apply(lambda x: word_tokenize(x))\ndata_clean.head()","e722d097":"#Stemming\nimport nltk\nfrom nltk.stem.porter import PorterStemmer\nporter_stemmer  = PorterStemmer()\ntext = \"studies studying cries cry\"\ntokenization = nltk.word_tokenize(text)\nfor w in tokenization:\n    print(\"Stemming for {} is {}\".format(w,porter_stemmer.stem(w)))  ","fec0b90d":"#Lemmatization\nimport nltk\nfrom nltk.stem import \tWordNetLemmatizer\nwordnet_lemmatizer = WordNetLemmatizer()\ntext = \"studies studying cries cry\"\ntokenization = nltk.word_tokenize(text)\nfor w in tokenization:\n\tprint(\"Lemma for {} is {}\".format(w, wordnet_lemmatizer.lemmatize(w)))  ","5baa4e65":"from nltk.stem import PorterStemmer \nfrom nltk.tokenize import word_tokenize\ndef word_stemmer(text):\n    stem_text = [PorterStemmer().stem(i) for i in text]\n    return stem_text\ndata_clean['text_clean_tokens'] = data_clean['text_tokens'].apply(lambda x: word_stemmer(x))\ndata_clean.head()","413508cd":"\nfrom nltk.stem import WordNetLemmatizer\ndef word_lemmatizer(text):\n    lem_text = [WordNetLemmatizer().lemmatize(i) for i in text]\n    return lem_text\ndata_clean['text_clean_tokens'] = data_clean['text_tokens'].apply(lambda x: word_lemmatizer(x))\ndata_clean.head()","61cb88f9":"\"\"\"!pip3 install pyspellchecker==20.2.2\nfrom spellchecker import SpellChecker\n\nspell = SpellChecker()\ndef correct_spellings(text):\n    corrected_text = []\n    misspelled_words = spell.unknown(text.split())\n    for word in text.split():\n        if word in misspelled_words:\n            corrected_text.append(spell.correction(word))\n        else:\n            corrected_text.append(word)\n    return \" \".join(corrected_text)\n\ndata_clean['text_clean'] = data_clean['text_clean'].apply(lambda x: correct_spellings(x))\"\"\" ","d508ee7c":"X_train, X_test, Y_train, Y_test = train_test_split(data_clean['text_clean'], \n                   \n                                                    data_clean['target'], \n                                                    test_size = 0.2,\n                                                    random_state = 10)","10d4d9c3":"print(X_train.shape)\nprint(X_test.shape)\nprint(Y_train.shape)\nprint(Y_test.shape)","46c7bb89":"vectorizer = CountVectorizer(analyzer='word', ngram_range=(1, 1))\nvectorized = vectorizer.fit_transform(X_train)\npd.DataFrame(vectorized.toarray(), \n            index=['sentence '+str(i) \n                   for i in range(1, 1+len(X_train))],\n            columns=vectorizer.get_feature_names())","9363f174":"#Only alphabet, contains at least 3 letters\nvectorizer = CountVectorizer(analyzer='word', \n                              token_pattern=r'\\b[a-zA-Z]{3,}\\b',  \n                              ngram_range=(1, 1))\nvectorized = vectorizer.fit_transform(X_train)\npd.DataFrame(vectorized.toarray(), \n             index=['sentence '+str(i) \n                    for i in range(1, 1+len(X_train))],\n             columns=vectorizer.get_feature_names())","77179b56":"vectorizer = CountVectorizer(analyzer='word', \n                              token_pattern=r'\\b[a-zA-Z]{3,}\\b',  \n                              ngram_range=(2, 2))  # only bigrams\nvectorized = vectorizer.fit_transform(X_train)\npd.DataFrame(vectorized.toarray(), \n             index=['sentence '+str(i) \n                    for i in range(1, 1+len(X_train))],\n             columns=vectorizer.get_feature_names())","3fa8ed6b":"# consider both unigrams and bigrams, occur at least twice\nvectorizer = CountVectorizer(analyzer='word', \n                              token_pattern=r'\\b[a-zA-Z]{3,}\\b',  \n                              ngram_range=(1, 2),                                             min_df = 2)  \nvectorized = vectorizer.fit_transform(X_train)\npd.DataFrame(vectorized.toarray(), \n             index=['sentence '+str(i) \n                    for i in range(1, 1+len(X_train))],\n             columns=vectorizer.get_feature_names())","05fab442":"from sklearn.feature_extraction.text import (CountVectorizer, \n                                             TfidfVectorizer,\n                                             TfidfTransformer)\nvectorizer = CountVectorizer(analyzer='word', \n                              token_pattern=r'\\b[a-zA-Z]{3,}\\b',  \n                              ngram_range=(1, 1) \n                              )  \ncount_vectorized = vectorizer.fit_transform(X_train)\ntfidf = TfidfTransformer(smooth_idf=True, use_idf=True)\ntrain_features = tfidf.fit_transform(count_vectorized).toarray()\n\npd.DataFrame(train_features, \n             index=['sentence '+str(i) \n                    for i in range(1, 1+len(X_train))],\n             columns=vectorizer.get_feature_names())","7dff1832":"# Convert a collection of text documents to a matrix of token counts\ntfidf = feature_extraction.text.TfidfVectorizer(encoding='utf-8',\n                       ngram_range=(1,1),\n                       max_features=5000,\n                       norm='l2',\n                       sublinear_tf=True)","2256f937":"train_features = tfidf.fit_transform(X_train).toarray()","5ff0b7ec":"print(train_features[1])\nprint(train_features.shape)","f81aefdc":"pd.DataFrame(train_features, \n             index=['sentence '+str(i) \n                    for i in range(1, 1+len(X_train))],\n             columns=tfidf.get_feature_names())","c1c525b2":"dic_vocabulary = tfidf.vocabulary_","7dc77830":"word = \"forest\"\ndic_vocabulary[word]\n#If the word exists in the vocabulary, \n#this command prints a number N, \n#meaning that the Nth feature of the matrix is that word.","ce0c6428":"test_features = tfidf.transform(X_test).toarray()\nprint(test_features.shape)","0cdf5660":"train_labels = Y_train\ntest_labels = Y_test","1d727c95":"\"\"\"from sklearn import feature_selection \ny = data_clean['target']\nX_names = tfidf.get_feature_names()\np_value_limit = 0.95\ndtf_features = pd.DataFrame()\nfor cat in np.unique(y):\n    chi2, p = feature_selection.chi2(X_train, y==cat)\n    dtf_features = dtf_features.append(pd.DataFrame(\n                   {\"feature\":X_names, \"score\":1-p, \"y\":cat}))\n    dtf_features = dtf_features.sort_values([\"y\",\"score\"], \n                    ascending=[True,False])\n    dtf_features = dtf_features[dtf_features[\"score\"]>p_value_limit]\nX_names = dtf_features[\"feature\"].unique().tolist()\nlen(X_names)\"\"\"","816f8e32":"import pandas as pd\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.metrics import classification_report, confusion_matrix, accuracy_score","7491e1b4":"mnb_classifier = MultinomialNB()","37f1576e":"mnb_classifier.fit(train_features,train_labels)","b8463ca8":"mnb_prediction = mnb_classifier.predict(test_features)","ba09f100":"training_accuracy = accuracy_score(train_labels, mnb_classifier.predict(train_features))\nprint(training_accuracy)","51d53a73":"testing_accuracy = accuracy_score(test_labels, mnb_prediction)\nprint(testing_accuracy)","5a1a4a6f":"print(classification_report(test_labels, mnb_prediction))","43f6679b":"conf_matrix = confusion_matrix(test_labels, mnb_prediction)\nprint(conf_matrix)","4b543c88":"import seaborn as sns\nsns.heatmap(conf_matrix\/np.sum(conf_matrix),annot=True, fmt='.2%', cmap='Blues')","1a0c3818":"#from sklearn.neighbors import KNeighborsClassifier\n#knn = KNeighborsClassifier().fit(train_features, train_labels)","bdfc1cb2":"#predicts = knn.predict((test_features))\n#print(classification_report(test_labels, predicts)) ","8a5e1f1d":"test_vectorizer =tfidf.transform( data_clean_test['text_clean']).toarray()","1e00e9a9":"test_vectorizer.shape","528abead":"final_predictions = mnb_classifier.predict(test_vectorizer)","f6df7871":"final_predictions","89ae4e74":"submission_df = pd.DataFrame()","b000a886":"submission_df['id'] = data_clean_test['id']\nsubmission_df['target'] = final_predictions","9eb02553":"submission_df","e09c4dce":"submission_df['target'].value_counts()","48fcb193":"submission = submission_df.to_csv('Result.csv',index = False)","f659f434":"2. Cardinality and Target Distribution\n\nLocations are not automatically generated, they are user inputs. That's why location is very dirty and there are too many unique values in it. It shouldn't be used as a feature.\n\nFortunately, there is signal in keyword because some of those words can only be used in one context. Keywords have very different tweet counts and target means. keyword can be used as a feature by itself or as a word added to the text. Every single keyword in training set exists in test set. If training and test set are from the same sample, it is also possible to use target encoding on keyword.","60393a82":"Tokenization is the process of tokenizing or splitting a string, text into a list of tokens. One can think of token as parts like a word is a token in a sentence, and a sentence is a token in a paragraph","29567ec8":"\n<a id=\"1\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Introduction  <\/center><\/h2>","fff62e36":"**The regular expression**\n\nabove is meant to find any four digits at the beginning of a string, which suffices for our case. The above is a raw string (meaning that a backslash is no longer an escape character), which is standard practice with regular expressions.\nregex = r'^(\\d{4})'\n","4d4f8f7f":"Number of characters in tweets","792725e9":"<a id=\"4.2\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Tokenizing  <\/center><\/h2>","7d840c1d":"In order to know the position of a certain word, we can look it up in the vocabulary:","745af2e5":"In details about each target ","b99dc8b1":"Consider only unigrams\/bigrams\/\u2026 tokens\n* ngram-range=(1, 1): unigram only\n* ngram-range=(2, 2): bigrams only\n* ngram-range=(1, 2): both unigrams and bigrams","6e485b84":"The distribution of both seems to be almost same.120 t0 140 characters in a tweet are the most common among both.","e1dd7d5a":"<a id=\"3.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> Target variable distribution <\/b><\/font>","1247c8bd":"Consider only certain pattern\nWe can also specify the desired pattern for our token using token_pattern argument. In the following example, we will only consider tokens consists of at least 3 alphabets.","ab3ce5a4":"<a id=\"2.2\"><\/a>\n<font color=\"blue\" size=+2.5><b> Import Dataset <\/b><\/font>\n","d41a9f70":"First,we will do very basic analysis,that is character level,word level and sentence level analysis.","2133eaf2":"<a id=\"5.0\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Feature Extraction : tf-idf <\/center><\/h2>","6c7ca14f":"**Number of words in a tweet**","6ca3b537":" Tfidftransformer ","09dd8141":"<a id=\"4.5\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Splitting the data <\/center><\/h2>","f84edc81":"**TfidfTransformer v.s. Tfidfvectorizer**\n\n\nBoth TfidfTransformer and Tfidfvectorizer modules can convert a collection of raw documents to a matrix of TF-IDF features. However,","aeb98607":"<a id=\"4.1\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Removing Stop words <\/center><\/h2>","88817a4e":"<a id=\"2.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> Import Libraries <\/b><\/font>","c23db79b":"<font color=\"black\" size=+1.5><b>CountVectorizer<\/b><\/font>\n\nCountVectorizer converts a collection of text documents to a matrix of token counts: the occurrences of tokens in each document. This implementation produces a sparse representation of the counts.","160aef93":"**Frequencies**\nNow we want to count the frequency of each word in our corpus.","b0f57a0f":"#Hashtag analysis\n#Small analysis done on the hashtags, to check it's possible discriminator #capability for this task.","7d5ee335":"# Visualizing scikit model performance","6c0db742":"<a id=\"5.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> reduce the matrix dimensionality <\/b><\/font>","d5bfe21d":" in order to reduce the dimensionality of our matrix ! [Feature matrix shape: Number of documents x Length of vocabulary ] we can carry out some Feature Selection, the process of selecting a subset of relevant variables. I will proceed as follows:\n\ntreat each category as binary (for example, the \u201cTech\u201d category is 1 for the Tech news and 0 for the others);\nperform a Chi-Square test to determine whether a feature and the (binary) target are independent;\nkeep only the features with a certain p-value from the Chi-Square test.","5eb8b6ec":"Let's take a look to the punctuations in our tweets : ","ffd2cf14":"Tfidfvectorizer","3c23ca72":"<h2 class=\"list-group-item list-group-item-action active\"  data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\" > <center>Objective  <\/center><\/h2>\n\nGoals of this kernel are the following:\n- Basic Exploratory Data Analysis.\n- Beginners guide to clean the dataset.\n- Feature Analysis & extraction \n- Modelling and ecvaluation metrics \n- submitting the results ","a23ab172":"<font size=\"+3\" color=Green><b> <center><u>Text classification step by step<\/u><\/center><\/b><\/font>","9dd50d5c":"<a id=\"4.4\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Lemmatization  <\/center><\/h2>","3ebf84cb":"![image.png](attachment:image.png)","ac1f2e1d":"<a id=\"2\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Load and Check Data  <\/center><\/h2>","f1167bbd":"**What are Stop words?**\n\n\nStop Words: A stop word is a commonly used word (such as \u201cthe\u201d, \u201ca\u201d, \u201can\u201d, \u201cin\u201d) that a search engine has been programmed to ignore, both when indexing entries for searching and when retrieving them as the result of a search query.\n\nWe would not want these words to take up space in our database, or taking up valuable processing time. For this, we can remove them easily, by storing a list of words that you consider to stop words. NLTK(Natural Language Toolkit) in python has a list of stopwords stored in 16 different languages. You can find them in the nltk_data directory. home\/pratima\/nltk_data\/corpora\/stopwords is the directory address.(Do not forget to change your home directory name)","4f3a9c51":"Note that for each sentence in the corpus, the position of the tokens (words in our case) is completely ignored. When constructing this bag-of-words representation, the default configuration tokenize the string by extracting words of at least 2 alphanumeric characters (punctuation is completely ignored and always treated as a token separator)","ccc22dbd":"<a id=\"3.2\"><\/a>\n<font color=\"blue\" size=+2.5><b> Explaratory analysis of tweets <\/b><\/font>","bbdd46ff":"![image.png](attachment:image.png)","5f89df24":"<a id=\"5.2\"><\/a>\n<font color=\"blue\" size=+2.5><b> Model : Multinomial NB <\/b><\/font>","734ba974":"**Keyword and Location**","f2380fe4":"<font color=\"green\" size=+1.5><b>**Why is Lemmatization better than Stemming?**\nStemming algorithm works by cutting the suffix from the word. In a broader sense cuts either the beginning or end of the word.\n\nOn the contrary, Lemmatization is a more powerful operation, and it takes into consideration morphological analysis of the words. It returns the lemma which is the base form of all its inflectional forms. In-depth linguistic knowledge is required to create dictionaries and look for the proper form of the word. Stemming is a general operation while lemmatization is an intelligent operation where the proper form will be looked in the dictionary. Hence, lemmatization helps in forming better machine learning features.<\/b><\/font>\n<font color=\"red\" size=+1.5><b>    \nIf you look stemming for studies and studying, output is same (studi) but lemmatizer provides different lemma for both tokens study for studies and studying for studying. So when we need to make feature set to train machine, it would be great if lemmatization is preferred. <\/b><\/font>","95d36a1b":"1. ***Missing Values***\n\nBoth training and test set have same ratio of missing values in keyword and location.\n\n0.8% of keyword is missing in both training and test set\n33% of location is missing in both training and test set\nSince missing value ratios between training and test set are too close, they are most probably taken from the same sample. Missing values in those features are filled with no_keyword and no_location respectively.","c2521a33":"<a id=\"5.0\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Model training <\/center><\/h2>","6911406a":"![image.png](attachment:image.png)","42bca815":"There are more tweets with class 0 ( No disaster) than class 1 ( disaster tweets)","36b12481":"<a id=\"4.3\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Stemming  <\/center><\/h2>","826664ef":"**Consider only tokens with certain frequency**\n\n\nWe can also make the vectorizer to ignore terms that have a document frequency strictly lower than a specified threshold by setting min_df = threshold or max_df = threshold for higher frequency terms.","4712db17":"<font color=\"black\" size=+1.5><b> Vectorization is the general process of turning a collection of text documents into numerical feature vectors. This specific strategy (tokenization, counting and normalization) is called the Bag of Words or \u201cBag of n-grams\u201d representation. Documents are described by word occurrences while completely ignoring the relative position information of the words in the document. <\/b><\/font>","15b3da51":"Note 1000, be, is, of are removed from the original feature space.","faf491a9":"<a id=\"4.9\"><\/a>\n<font color=\"blue\" size=+2.5><b> Bag of words <\/b><\/font>","f7ee2f1a":"<a id=\"1.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> About Data<\/b><\/font>\n<br\/>\n<br\/>\n* **What files do I need?**\n\nYou'll need train.csv, test.csv and sample_submission.csv.\n\n* **What should I expect the data format to be?**\n\nEach sample in the train and test set has the following information:\n\n1. The text of a tweet\n2. A keyword from that tweet (although this may be blank!)\n3. The location the tweet was sent from (may also be blank)\n\n*** What am I predicting?**\n\nYou are predicting whether a given tweet is about a real disaster or not. If so, predict a 1. If not, predict a 0.\n\n* **Files**\n\n1. train.csv - the training set\n2. test.csv - the test set\n3. sample_submission.csv - a sample submission file in the correct format\n\n## The columns in this dataset are:\n\n* id - a unique identifier for each tweet\n* text - the text of the tweet\n* location - the location the tweet was sent from (may be blank)\n* keyword - a particular keyword from the tweet (may be blank)\n* target - in train.csv only, this denotes whether a tweet is about a real disaster (1) or not (0)\n\n\n","d716b99f":"<font size='5' color='Black'> WORK IN PROGRESS ...<\/font>","24418db2":"<a id=\"3.3\"><\/a>\n<font color=\"blue\" size=+2.5><b> Explaratory analysis of Other Variables <\/b><\/font>","f55385a2":"Natural Language Processing (NLP) is a subfield of computer science, artificial intelligence, information engineering, and human-computer interaction. This field focuses on how to program computers to process and analyze large amounts of natural language data. It is difficult to perform as the process of reading and understanding languages is far more complex than it seems at first glance.","01e19c8a":"<a id=\"3\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Exploratory Data Analysis <\/center><\/h2>","6b60ef1a":"# Fitting the Test data for submission","de9bb036":"![image.png](attachment:image.png)","3eedf6c0":"<a id=\"top\"><\/a>\n<div class=\"list-group\" id=\"list-tab\" role=\"tablist\">\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center> Table of content <\/center><\/h2>\n\n<font color=\"blue\" size=+1><b>Introduction<\/b><\/font>\n* [About Data ](#1.1)\n    \n<font color=\"blue\" size=+1><b> Load and Check Data <\/b><\/font>\n* [Importing Library](#2.1)\n* [Load Dataset](#2.2)\n\n<font color=\"blue\" size=+1><b> Exploratory Data Analysis <\/b><\/font>\n* [Target variable distribution](#3.1)\n* [Explaratory analysis of tweets](#3.2)    \n* [Explaratory analysis of Other Variables](#3.3)   \n\n\n<font color=\"blue\" size=+1><b> Data Preparation <\/b><\/font>\n    \n* [Data cleaning ](#4.0)\n        \n* [Removing STOP words ](#4.1)\n           \n* [Tokonezing](#4.2)\n        \n* [Stemming](#4.3)\n        \n* [Lemmatization](#4.4)\n        \n* [Splitting the data](#4.5)\n    \n<font color=\"blue\" size=+1><b> Feature Extraction <\/b><\/font>\n* [Bag of words](#4.9)\n* [Tf-idf Vectorizer](#5.0)\n* [reduce the dimensionality of the Matrix](#5.1)\n    \n    \n<font color=\"blue\" size=+1><b> Model Training <\/b><\/font>\n    \n* [MultinomialNB ](#5.2)\n\n\n","15d58d69":"1. With Tfidftransformer you will systematically compute word counts using CountVectorizer and then compute the Inverse Document Frequency (IDF) values and only then compute the TF-IDF scores.\n2. With Tfidfvectorizer on the contrary, you will do all three steps at once. Under the hood, it computes the word counts, IDF values, and TF-IDF scores all using the same data set.","d686eccc":"**Average word length in a tweet**","fcfbed84":"Before we begin with anything else,let's check the class distribution.There are only two classes 0 and 1.","0903ae98":"\n<font size='5' color='red'>  if you liked this kernel,please upvote it <3 <\/font>\n    \n\n"}}