{"cell_type":{"fc4c8fe9":"code","de9ab19f":"code","c3876a93":"code","b0abcb4a":"code","f2c5488d":"code","d92c0e91":"code","694e7552":"code","82677ca6":"code","b5065f8a":"code","5a07765c":"code","4bb65da2":"code","b392f6a5":"code","a9efab1f":"code","d416a8ad":"code","3e65311a":"code","250af68c":"code","fff10132":"code","8dff0ee8":"code","9201b665":"code","5ce8edd6":"code","178b839a":"code","89be7a39":"code","ba8c94e6":"code","e2c047b0":"code","c6347ecb":"code","3551b991":"code","d88847d4":"code","d27f01a5":"code","c43b80cb":"code","6f030aee":"code","ec2c9e3b":"code","7c889812":"code","e01f3756":"code","cdcd52c1":"code","d3f03e3a":"code","d85dd7d0":"code","22d43a12":"code","b7947578":"code","13a5238f":"code","e841e0d8":"code","ffc40324":"code","8a165261":"code","52908e5a":"code","ebd40a75":"code","fefd0bc4":"code","fc2c075a":"markdown","0cfcdc21":"markdown","e54ed910":"markdown","0a3eb973":"markdown","f53cff16":"markdown","0146c1ea":"markdown","76a6e701":"markdown","ac5f3422":"markdown","fa83b563":"markdown","c5d2e3b8":"markdown","04ee44ec":"markdown","5998c8fd":"markdown","1283abec":"markdown","117056f8":"markdown","c257909e":"markdown","368b064a":"markdown","3a141d41":"markdown","7fe6b298":"markdown","d9cb9326":"markdown","ea6740be":"markdown","4ecf3949":"markdown"},"source":{"fc4c8fe9":"import pandas as pd\nimport numpy as np","de9ab19f":"data = pd.read_csv(\"\/kaggle\/input\/star-type-classification\/Stars.csv\")\ndata","c3876a93":"import seaborn as sns\nimport matplotlib.pyplot as plt","b0abcb4a":"for col in data.columns:\n    plt.title(f'Histplot of {col}')\n    sns.histplot(data[col])\n    plt.show()","f2c5488d":"for col in data.columns.drop(\"Type\"):\n    plt.figure(figsize=(20,10))\n    plt.title(f'Lineplot of Type VS {col}')\n    sns.lineplot(x=\"Type\", y=col, data=data)\n    plt.show()","d92c0e91":"data_copy = data.copy()","694e7552":"data.isnull().sum()","82677ca6":"from sklearn.preprocessing import LabelEncoder","b5065f8a":"le = LabelEncoder()\n\ncat_cols = data.select_dtypes(object)\n\nfor col in cat_cols:\n    data[col] = le.fit_transform(data[col])","5a07765c":"from sklearn.preprocessing import KBinsDiscretizer","4bb65da2":"cols_to_bin = ['Temperature', 'L', 'R', 'A_M']","b392f6a5":"optimal_bins = np.round(1 + np.log2(len(data)))\noptimal_bins = int(optimal_bins)\noptimal_bins","a9efab1f":"binner = KBinsDiscretizer(n_bins=optimal_bins, encode='ordinal')\n\nfor col in cols_to_bin:\n    data[col+'_Binned'] = binner.fit_transform(data[col].values.reshape(-1,1)).astype('int64')    ","d416a8ad":"corr = data.corr()\nplt.figure(figsize=(10,10))\nsns.heatmap(corr, annot=True)\nplt.show()","3e65311a":"for col in ['Temperature', 'L', 'R', 'A_M']:\n    temp = data.groupby('Type')[col].agg(['mean'])\n    temp.columns = ['Mean_'+col]\n    \n    data = pd.merge(data,temp,on='Type',how='left')","250af68c":"for col in data.columns.drop('Type'):\n    data[col] = (data[col]-data[col].mean() ) \/ data[col].std()","fff10132":"sns.countplot(data['Type'])","8dff0ee8":"from sklearn.model_selection import train_test_split","9201b665":"X, y = data.drop('Type', axis=1), data['Type']","5ce8edd6":"x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=56)","178b839a":"x_train_, x_val, y_train_, y_val = train_test_split(x_train, y_train, test_size=0.2, random_state=56)","89be7a39":"from sklearn.ensemble import ExtraTreesClassifier, GradientBoostingClassifier, RandomForestClassifier, AdaBoostClassifier\nfrom xgboost import XGBClassifier\nfrom lightgbm import LGBMClassifier\nfrom sklearn.tree import DecisionTreeClassifier, ExtraTreeClassifier\nfrom sklearn.linear_model import SGDClassifier\nfrom catboost import CatBoostClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.svm import SVC","ba8c94e6":"from sklearn.metrics import mean_squared_error, classification_report, accuracy_score","e2c047b0":"def model_selection(x_train_, x_val, y_train_, y_val, model):\n  model = model()\n  model.fit(x_train_, y_train_)\n\n  pred = model.predict(x_val)\n\n  acc = accuracy_score(y_val, pred)\n  error = np.sqrt(mean_squared_error(y_val, pred))\n  report = classification_report(y_val, pred)\n  train_score = model.score(x_train_, y_train_)\n  val_score = model.score(x_val, y_val)\n\n  print('Acc :', acc*100)\n  print('\\n')\n  print('Error:', error)\n  print('\\n')\n  print('Classification report:', report)\n  print('\\n')\n  print('Train Score:', train_score*100)\n  print('\\n')\n  print('Val Score:', val_score*100)\n  print('\\n')\n  print('Is overfitting:', True if train_score>val_score else False)\n  print('\\n')\n  print('Overfitting by:',train_score*100-val_score*100)","c6347ecb":"extratrees = model_selection(x_train_, x_val, y_train_, y_val, ExtraTreesClassifier)\nextratrees","3551b991":"gradient = model_selection(x_train_, x_val, y_train_, y_val, GradientBoostingClassifier)\ngradient","d88847d4":"randomforest = model_selection(x_train_, x_val, y_train_, y_val, RandomForestClassifier)\nrandomforest","d27f01a5":"ada = model_selection(x_train_, x_val, y_train_, y_val, AdaBoostClassifier)\nada","c43b80cb":"xgb = model_selection(x_train_, x_val, y_train_, y_val, XGBClassifier)\nxgb","6f030aee":"lgbm = model_selection(x_train_, x_val, y_train_, y_val, LGBMClassifier)\nlgbm","ec2c9e3b":"tree = model_selection(x_train_, x_val, y_train_, y_val, DecisionTreeClassifier)\ntree","7c889812":"extratree = model_selection(x_train_, x_val, y_train_, y_val, ExtraTreeClassifier)\nextratree","e01f3756":"catboost = model_selection(x_train_, x_val, y_train_, y_val, CatBoostClassifier)\ncatboost","cdcd52c1":"sgd = model_selection(x_train_, x_val, y_train_, y_val, SGDClassifier)\nsgd","d3f03e3a":"nb = model_selection(x_train_, x_val, y_train_, y_val, GaussianNB)\nnb","d85dd7d0":"svc = model_selection(x_train_, x_val, y_train_, y_val, SVC)\nsvc","22d43a12":"import random","b7947578":"model_ = ['ExtraTrees', 'GradientBoosting', 'RandomForest', 'XGB', 'LGBM', 'DecisionTree', 'ExtraTree',\n         'CatBoost', 'NB']","13a5238f":"random.choice(model_)","e841e0d8":"model = GradientBoostingClassifier()\nmodel.fit(x_train, y_train)","ffc40324":"pred = model.predict(x_test)\npred","8a165261":"sns.countplot(pred)","52908e5a":"acc = accuracy_score(y_test, pred)\nacc*100","ebd40a75":"error = np.sqrt(mean_squared_error(y_test, pred))\nerror","fefd0bc4":"overfitting_by = model.score(x_train, y_train)*100 - model.score(x_test, y_test)*100\noverfitting_by","fc2c075a":"**I will choose GradientBoostingClassifier**","0cfcdc21":"# Target imbalance?","e54ed910":"# Predictions","0a3eb973":"# **Loading the dataset**","f53cff16":"# Feature correlation","0146c1ea":"# Splitting data into training and testing sets","76a6e701":"# Encoding categorical data to numeric data","ac5f3422":"**first lets find the optimal number of bins using a formula**","fa83b563":"# Model Selection","c5d2e3b8":"# Data EDA","04ee44ec":"**Most of the models gave an acc of 100% so I will choose a random model using python's random module**","5998c8fd":"# Data Processing","1283abec":"# Feature scaling","117056f8":"# Model Building and Training","c257909e":"# Saving a copy of the dataset","368b064a":"# Splitting training data into training and validation sets","3a141d41":"# Creating new features","7fe6b298":"# Metrics Check","d9cb9326":"**null values?**","ea6740be":"# **If you like the notebook please upvote it :D**","4ecf3949":"# Binning continuous features"}}