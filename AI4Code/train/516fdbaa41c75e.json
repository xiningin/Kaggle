{"cell_type":{"bcdde097":"code","973724c8":"code","f6aab1c8":"code","19940d60":"code","1f538a0e":"code","c745731d":"code","7a1a6d32":"code","4ce90d24":"code","c4a2f9b0":"code","b1ee1ad7":"code","e5e9d3ff":"code","f77c50a9":"code","cb41f421":"code","1e10452b":"code","fc1be9a6":"code","fd3bc6c6":"code","9ebd269e":"code","a983a5bf":"code","b41b0493":"code","fa803e5d":"code","ca2b79a3":"code","0cecda77":"code","e4820a16":"code","4c3d858e":"code","0ec8bd50":"code","885c6993":"code","7fc5dc14":"code","1feaa80d":"code","1d8e2785":"code","789d8240":"code","7b1fc216":"code","8b9806ba":"code","688a3eba":"code","a3050df4":"code","161c2fef":"code","57c79541":"code","7e31372e":"code","c99130f2":"code","2696bc2c":"code","2c6a6540":"code","bd005e58":"code","073b032e":"code","b3f46b4b":"code","cfdc1cea":"code","88e38353":"code","a72b8f74":"code","ccc45cf0":"code","4735ac6a":"code","9b4a1012":"code","011c07dd":"code","4abc239b":"code","511f6bc6":"code","277b2296":"code","7a59bfc8":"code","0e175d89":"code","760b697a":"code","d0562652":"code","18a2e946":"markdown","19d371b9":"markdown","419c5506":"markdown","00506b2f":"markdown","ce4e9180":"markdown","38b83d10":"markdown","9e692418":"markdown","a5080d45":"markdown","f20e0e23":"markdown","92f97a99":"markdown","6b91796b":"markdown"},"source":{"bcdde097":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","973724c8":"def initgrid():\n    matrix = np.random.randint(2, size=(10, 10))                                  #creating a 10 by 10 matrix abd filling it with \n    sum = np.sum(matrix)                                                          #sum up all values in matrix\n    if sum == 50:                                                                 #making sure that the original matrix has 50 oil, 50 water\n        return matrix\n    else:\n        return initgrid()                                                           #else rerun function\ndummy_matrix = initgrid()\ndummy_matrix","f6aab1c8":"matrix_initial = np.zeros((12, 12))\nmatrix_initial","19940d60":"np.arange(100).reshape((10, 10))","1f538a0e":"L = 10\n#next\nfor i in range(L):\n    if i < L-1:\n        print(i+1)\n    else:\n        print(0)\nprint('------boundary--------')\n#prec\nfor i in range(L):\n    if i >= 1:\n        print(i-1)\n    else:\n        print(0)","c745731d":"#next\nfor i in range(L):\n    if i < L-1:\n        print(i+1)\n    else:\n        print(0)\nprint('------boundary--------')\n#prec\nfor i in range(L):\n    if i >= 1:\n        print(i-1)\n    else:\n        print(0)","7a1a6d32":"def initgrid(box,ratio):\n    matrix = np.random.randint(2, size=(box, box))                                  #creating a 10 by 10 matrix abd filling it with \n    sum = np.sum(matrix)                                                          #sum up all values in matrix\n    if sum == box**2*ratio:                                                                 #making sure that the original matrix has 50 oil, 50 water\n        return matrix\n    else:\n        return initgrid(box,ratio)\n    \nbox,ratio = 10,0.5\n    \ndummy_matrix = initgrid(box,ratio)\ndummy_matrix","4ce90d24":"def next_(i):\n    if i < box-1:\n        return i+1\n    else:\n        return 0\n\ndef prec(i):\n    if i >= 1:\n        return i-1\n    else:\n        return 9","c4a2f9b0":"#Energy Interaction\nfor i in range(box):\n    print('--------------------')\n    for j in range(box):\n        print(\"Start\",(i,j),\":Right:\",(next_(i),j), ',Left:',(prec(i),j), ',Up:',(i,prec(j)), ',Down:', (i,next_(j)))","b1ee1ad7":"#Density: Diagonal Interaction\nfor i in range(box):\n    print('--------------------')\n    for j in range(box):\n        print(\"Start\",(i,j),\":Left-Down:\",(prec(i),next_(j)), ',Left-Up:',(prec(i),prec(j)), ',Right-Up:',(next_(i),prec(j)), ',Right-Down:', (next_(i),next_(j)))","e5e9d3ff":"import random\n\nfor i in range(100):\n    counter = random.randint(0,1)\n    dummy_list = [random.randint(0,1) for i in range(4)]\n    \n    print(counter, dummy_list, abs(4*counter - sum(dummy_list)))","f77c50a9":"import random\nfrom collections import Counter\n\ndef state_to_density(dummy_matrix):\n    density_state = []\n    for i in range(box):\n        for j in range(box):\n            density = dummy_matrix[i,j] + dummy_matrix[next_(i),j] + dummy_matrix[prec(i),j] + dummy_matrix[i,prec(j)] + dummy_matrix[i,next_(j)] + dummy_matrix[prec(i),next_(j)] + dummy_matrix[prec(i),prec(j)] + dummy_matrix[next_(i),prec(j)] + dummy_matrix[next_(i),next_(j)]\n            density_state.append(density)\n    return pd.DataFrame.from_dict(Counter(density_state), orient='index')","cb41f421":"def state_to_energy(dummy_matrix):\n    energy_state = np.zeros((10,10))\n    for i in range(box):\n        for j in range(box):\n            energy_state[i,j] = abs(4*dummy_matrix[i,j] - (dummy_matrix[next_(i),j] + dummy_matrix[prec(i),j] + dummy_matrix[i,prec(j)] + dummy_matrix[i,next_(j)])) \n    return energy_state","1e10452b":"dummy_matrix","fc1be9a6":"energy_state = state_to_energy(dummy_matrix)\nenergy_state","fd3bc6c6":"def local_energy(dummy_matrix,i,j):\n    return abs(4*dummy_matrix[i,j] - (dummy_matrix[next_(i),j] + dummy_matrix[prec(i),j] + dummy_matrix[i,prec(j)] + dummy_matrix[i,next_(j)]))\n\n#Put Boltzmann Criteria\n\ndef swap(matrix_1):\n    #Creating 2 random row and column for swapping\n    rdm1 = random.randint(0,9)\n    rdm2 = random.randint(0,9)\n    rdm3 = random.randint(0,9)\n    rdm4 = random.randint(0,9)\n  \n    #Creating 2 random row and column for swapping  \n    if matrix_1[rdm1,rdm2] != matrix_1[rdm3,rdm4]:\n        \n        def debug_1():\n            print('Element 1:', (rdm1,rdm2),'Element 2:',(rdm3,rdm4))\n            print('Initial Value 1:', matrix_1[rdm1,rdm2],'Initial Value 2:',matrix_1[rdm3,rdm4])\n            print('Initial 1:', local_energy(matrix_1,rdm1,rdm2),'Element 2:',local_energy(matrix_1,rdm3,rdm4))\n            print(matrix_1)\n            print('-------------------------')\n        #debug_1()\n        start = local_energy(matrix_1,rdm1,rdm2) + local_energy(matrix_1,rdm3,rdm4)\n        \n        store = matrix_1[rdm3,rdm4]\n        matrix_1[rdm3,rdm4] = matrix_1[rdm1,rdm2]\n        matrix_1[rdm1,rdm2] = store\n        \n        def debug_2():\n            print(matrix_1)\n            print('Final Value 1:', matrix_1[rdm1,rdm2],'Final Value 2:',matrix_1[rdm3,rdm4])            \n            print('Final 1:', local_energy(matrix_1,rdm1,rdm2),'Final 2:',local_energy(matrix_1,rdm3,rdm4))\n        \n        end = local_energy(matrix_1,rdm1,rdm2) + local_energy(matrix_1,rdm3,rdm4)\n        #debug_2()    \n        \n        local_dif = 2*(end-start)\n        return local_dif, matrix_1\n  \n    #Creating 2 random row and column for swapping\n    else:\n        return swap(matrix_1)\n    \ndummy_new_state = swap(dummy_matrix)","9ebd269e":"dummy_new_state","a983a5bf":"energy_new_state = state_to_energy(dummy_new_state[1])\nenergy_new_state","b41b0493":"energy_state.sum(), energy_new_state.sum()","fa803e5d":"counter = 0\nwhile counter < 1000:\n    counter += 100    \n    print(counter)","ca2b79a3":"energy_diff = []\ndensity_pandas = []\n\nfrom tqdm import tqdm\nfor i in tqdm(range(1000)):\n    dummy_new_state = swap(dummy_new_state[1])\n    \n    energy_diff.append(dummy_new_state[0]+energy_state.sum())\n    density_pandas.append(state_to_density(dummy_new_state[1]))\ndensity_table = pd.concat(density_pandas,axis=1)\ndensity_table.columns = [i+1 for i in range(1000)]\ndensity_table = density_table.transpose()\ndensity_table","0cecda77":"import matplotlib.pyplot as plt\nnrow,ncol=2,5\nsize = 4\n\nfig, axes = plt.subplots(nrow, ncol,figsize=(ncol*size,nrow*size))\n\ncount=0\nfor r in range(nrow):\n    for c in range(ncol):\n        density_table[count].plot(ax=axes[r,c])\n        axes[r,c].title.set_text('Density: '+str(count))\n        count += 1","e4820a16":"df = pd.DataFrame(np.asarray(energy_diff), columns=['Col1'])\ndf.boxplot(column=['Col1'])","4c3d858e":"dummy_matrix = initgrid(box,ratio)-1\/2\ndummy_matrix","0ec8bd50":"J, h = 1, 1\ndef local_hamiltonian(dummy_matrix,i,j):\n    sum_spin = dummy_matrix[i,j] + dummy_matrix[next_(i),j] + dummy_matrix[prec(i),j] + dummy_matrix[i,prec(j)] + dummy_matrix[i,next_(j)]\n    spin_interaction = dummy_matrix[i,j]*(dummy_matrix[next_(i),j] + dummy_matrix[prec(i),j] + dummy_matrix[i,prec(j)] + dummy_matrix[i,next_(j)])\n    return -J*spin_interaction + h*sum_spin\n","885c6993":"from IPython.display import YouTubeVideo\nYouTubeVideo('rN7g4gzO2sk', width=600, height=350)","7fc5dc14":"#Creating random model of spin-up and spin-down","1feaa80d":"import numpy as np\n\ndef random_spin_field(N, M):\n    return np.random.choice([-1\/2, 1\/2], size=(N, M))\n\nrandom_spin_field(10, 10)","1d8e2785":"#Create image visualization by converting (-1\/2,1\/2) to (0,255), (-0.5+1.5=)","789d8240":"# pip install pillow\nfrom PIL import Image\n\ndef display_spin_field(field):\n    return Image.fromarray(np.uint8((field*2 + 1) * 0.5 * 255))  # 0 ... 255\n\ndisplay_spin_field(random_spin_field(10, 10))","7b1fc216":"def ising_step(field, beta=0.1):\n    N, M = field.shape\n    for n_offset in range(2):\n        for m_offset in range(2):\n            for n in range(n_offset, N, 2):\n                for m in range(m_offset, M, 2):\n                    _ising_update(field, n, m, beta)\n    return field\n\ndef _ising_update(field, n, m, beta):\n    total = 0\n    N, M = field.shape\n    for i in range(n-1, n+2):\n        for j in range(m-1, m+2):\n            if i == n and j == m:\n                continue\n            total += field[i % N, j % M]\n    dE = 2 * field[n, m] * total\n    if dE <= 0:\n        field[n, m] *= -1\n    elif np.exp(-dE * beta) > np.random.rand():\n        field[n, m] *= -1","8b9806ba":"display_spin_field(ising_step(random_spin_field(200, 200)))","688a3eba":"from ipywidgets import interact\nfrom tqdm import tqdm\n\ndef display_ising_sequence(images):\n    def _show(frame=(0, len(images) - 1)):\n        return display_spin_field(images[frame])\n    return interact(_show)\n\nimages = [random_spin_field(200, 200)]\nfor i in tqdm(range(1000)):\n    images.append(ising_step(images[-1].copy()))\ndisplay_ising_sequence(images);","a3050df4":"def initgrid(box,ratio):\n    matrix = np.random.randint(2, size=(box, box))                                  #creating a 10 by 10 matrix abd filling it with \n    sum = np.sum(matrix)                                                          #sum up all values in matrix\n    if sum == box**2*ratio:                                                                 #making sure that the original matrix has 50 oil, 50 water\n        return matrix\n    else:\n        return initgrid(box,ratio)\n    \nbox,ratio = 200,0.5\n    \ndummy_matrix = initgrid(box,ratio)\ndummy_matrix","161c2fef":"def display_regular_field(field):\n    return Image.fromarray(np.uint8(field * 255))  # 0 ... 255\n\ndisplay_regular_field(dummy_matrix)","57c79541":"def display_regular_sequence(images):\n    def _show(frame=(0, len(images) - 1)):\n        return display_regular_field(images[frame])\n    return interact(_show)\n\nimages = [dummy_matrix]\nfor i in tqdm(range(1000)):\n    images.append(ising_step(images[-1].copy()))\ndisplay_regular_sequence(images);","7e31372e":"def ising_step(field, beta=0.1):\n    N, M = field.shape\n    for n_offset in range(2):\n        for m_offset in range(2):\n            for n in range(n_offset, N, 2):\n                for m in range(m_offset, M, 2):\n                    _ising_update(field, n, m, beta)\n    return field\n\ndef _ising_update(field, n, m, beta):\n    total = 0\n    N, M = field.shape\n    for i in range(n-1, n+2):\n        for j in range(m-1, m+2):\n            if i == n and j == m:\n                continue\n            total += field[i % N, j % M]\n    dE = 2 * field[n, m] * total\n    if dE <= 0:\n        field[n, m] *= -1\n    elif np.exp(-dE * beta) > np.random.rand():\n        field[n, m] *= -1","c99130f2":"def random_spin_field(N, M):\n    return np.random.choice([0, 1], size=(N, M))\ninitial_regular = random_spin_field(10, 10)\ninitial_regular","2696bc2c":"from PIL import Image\n\ndef display_spin_field(field):\n    return Image.fromarray(np.uint8(field * 255))  # 0 ... 255\n\ndisplay_spin_field(random_spin_field(400, 400))","2c6a6540":"# 2. Creating initial steps of the Ising Model\ndef ising_step(field, beta=2):\n    N, M = field.shape\n    for n_offset in range(2):\n        for m_offset in range(2):\n            for n in range(n_offset, N, 2):\n                for m in range(m_offset, M, 2):\n                    _ising_update(field, n, m, beta)\n    return field\n\n# 2. Creating initial steps of the Ising Model\ndef _ising_update(field, n, m, beta):\n    total = 0\n    N, M = field.shape\n    for i in range(n-1, n+2):\n        for j in range(m-1, m+2):\n            if i == n and j == m:\n                continue\n            total += field[i % N, j % M]\n    dE = 2 * field[n, m] * total\n    if dE <= 0:\n        field[n, m] *= -1\n    elif np.exp(-dE * beta) > np.random.rand():\n        field[n, m] *= -1","bd005e58":"initial_regular","073b032e":"import random\ndef swap(matrix_1):\n    #Creating 2 random row and column for swapping\n    rdm1 = random.randint(0,9)\n    rdm2 = random.randint(0,9)\n    rdm3 = random.randint(0,9)\n    rdm4 = random.randint(0,9)\n  \n    #Creating 2 random row and column for swapping  \n    if matrix_1[rdm1,rdm2] != matrix_1[rdm3,rdm4]:\n        \n        print(rdm1,rdm2)\n        print(rdm3,rdm4)\n        # Getting initial local energy\n        # start = local_energy(matrix_1,rdm1,rdm2) + local_energy(matrix_1,rdm3,rdm4)\n        \n        #debug_1()\n        \n        # Swapping positions\n        store = matrix_1[rdm3,rdm4]\n        matrix_1[rdm3,rdm4] = matrix_1[rdm1,rdm2]\n        matrix_1[rdm1,rdm2] = store\n        # Getting final local energy\n        # end = local_energy(matrix_1,rdm1,rdm2) + local_energy(matrix_1,rdm3,rdm4)\n        #debug_2()    \n        # local_dif = 2*(end-start)\n        \n        \n        return matrix_1 #, local_dif\n  \n    #Creating 2 random row and column for swapping\n    else:\n        return swap(matrix_1)","b3f46b4b":"start = initial_regular\nstart","cfdc1cea":"swap(initial_regular)","88e38353":"swap(initial_regular)","a72b8f74":"end = initial_regular\nend","ccc45cf0":"start == end","4735ac6a":"box = 200\ndef next_(i):\n    if i < box-1:\n        return i+1\n    else:\n        return 0\n\ndef prec(i):\n    if i >= 1:\n        return i-1\n    else:\n        return box-1","9b4a1012":"def swap_(matrix_1,beta=0.5):\n    #Creating 2 random row and column for swapping\n    rdm1 = random.randint(0,9)\n    rdm2 = random.randint(0,9)\n    rdm3 = random.randint(0,9)\n    rdm4 = random.randint(0,9)\n  \n    #Creating 2 random row and column for swapping  \n    if matrix_1[rdm1,rdm2] != matrix_1[rdm3,rdm4]:\n        total = 0\n        \n        Ei_1 = abs(4*matrix_1[rdm1,rdm2] - (matrix_1[next_(rdm1),rdm2] + matrix_1[prec(rdm1),rdm2] + matrix_1[rdm1,prec(rdm2)] + matrix_1[rdm1,next_(rdm2)]))\n        Ei_2 = abs(4*matrix_1[rdm3,rdm4] - (matrix_1[next_(rdm3),rdm4] + matrix_1[prec(rdm3),rdm4] + matrix_1[rdm3,prec(rdm4)] + matrix_1[rdm3,next_(rdm4)]))\n        Ei = 2 * (Ei_1+Ei_2)\n        \n        Ef_1 = abs(4*matrix_1[rdm3,rdm4] - (matrix_1[next_(rdm1),rdm2] + matrix_1[prec(rdm1),rdm2] + matrix_1[rdm1,prec(rdm2)] + matrix_1[rdm1,next_(rdm2)]))\n        Ef_2 = abs(4*matrix_1[rdm1,rdm2] - (matrix_1[next_(rdm3),rdm4] + matrix_1[prec(rdm3),rdm4] + matrix_1[rdm3,prec(rdm4)] + matrix_1[rdm3,next_(rdm4)]))\n        Ef = 2 * (Ef_1+Ef_2)\n        \n        dE = Ef-Ei\n        \n        if dE <= 0 or np.exp(-dE * beta) > np.random.rand():\n            #print(rdm1,rdm2)\n            #print(rdm3,rdm4)\n            \n            store = matrix_1[rdm3,rdm4]\n            matrix_1[rdm3,rdm4] = matrix_1[rdm1,rdm2]\n            matrix_1[rdm1,rdm2] = store\n\n            return matrix_1\n        \n        else:\n            return swap_(matrix_1,beta=0.5)\n    else:\n        return swap_(matrix_1,beta=0.5)","011c07dd":"start = initial_regular\nstart","4abc239b":"swap_(initial_regular)","511f6bc6":"swap_(initial_regular)","277b2296":"end = initial_regular\nend","7a59bfc8":"start == end","0e175d89":"from ipywidgets import interact\n\ndef display_ising_sequence(images):\n    def _show(frame=(0, len(images) - 1)):\n        return display_spin_field(images[frame])\n    return interact(_show)","760b697a":"from tqdm import tqdm\n\nimages = [random_spin_field(200, 200)]\nfor i in tqdm(range(1000)):\n    images.append(swap_(images[-1].copy()))\ndisplay_ising_sequence(images);","d0562652":"from tqdm import tqdm\nfor i in tqdm(range(1000)):\n    dummy_new_state = swap(dummy_new_state[1])\n    \n    energy_diff.append(dummy_new_state[0]+energy_state.sum())\n    density_pandas.append(state_to_density(dummy_new_state[1]))\ndensity_table = pd.concat(density_pandas,axis=1)\ndensity_table.columns = [i+1 for i in range(1000)]\ndensity_table = density_table.transpose()\ndensity_table","18a2e946":"from tqdm import trange\nfrom time import sleep\n\n\nfor i in trange(50, 100):\n    sleep(0.05)","19d371b9":"1. Regular Model","419c5506":"from tqdm.auto import tqdm, trange\nfrom time import sleep\n\nbar = trange(10)\nfor i in bar:\n    # Print using tqdm class method .write()\n    sleep(0.1)\n    if not (i % 3):\n        tqdm.write(\"Done task %i\" % i)\n    # Can also use bar.write()","00506b2f":"1. Create initial stage","ce4e9180":"s","38b83d10":"energy_diff = []\nfrom tqdm import tqdm\n\ncounter,runs = 0, 1000\npbar = tqdm(total = runs+1)\nwhile counter < 1000:\n    sleep(0.1)\n    dummy_new_state = swap(dummy_new_state[1])\n    energy_diff.append(dummy_new_state[0]+energy_state.sum())\n    counter += 1\npbar.close()\nenergy_diff","9e692418":"Energy State","a5080d45":"from tqdm import tqdm\n\npbar = tqdm(total=1000)\nfor i in range(10):\n    pbar.update(10)\npbar.close()","f20e0e23":"Ising Model","92f97a99":"**29\/08\/2020 Approach. Ising Model with Visualization**\n* Youtube, Quantum Machine Learning - 09 - Classical Ising Model, https:\/\/www.youtube.com\/watch?v=Wy9YoEYv-fA&t=1s\n* Youtube, Optimization with Cython: Ising Models (Part 1), https:\/\/www.youtube.com\/watch?v=rN7g4gzO2sk\n* Github Documentation, from Youtube video above, http:\/\/jakevdp.github.io\/blog\/2017\/12\/11\/live-coding-cython-ising-model\/","6b91796b":"**29\/08\/2020 Approach. Regular Model with Visualization**\n"}}