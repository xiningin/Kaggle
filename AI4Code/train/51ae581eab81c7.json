{"cell_type":{"123faf7a":"code","069f445c":"code","6941df60":"code","c2dbf8ee":"code","d827f8b1":"code","b682d6dc":"code","f4f98453":"code","10d201da":"code","49d7d527":"code","8bbb3b0d":"code","a8ffd837":"code","85ac11a2":"code","14cd8e17":"code","e8c40f16":"code","1d017fcf":"code","a8d4ac8a":"code","e1c8bf60":"code","6c119ea0":"code","d6cd97f7":"code","378d7d29":"code","5044eccd":"code","fdbfeb55":"code","be271b92":"code","ef90a8ae":"code","0408a7f3":"code","d67ad5d6":"code","91609d0a":"code","b8701f1e":"code","ac549a94":"code","17e46bf1":"code","57204c3a":"code","5328f1bc":"code","8cf793b0":"code","f30a65ff":"code","d0c843c0":"code","60b23040":"code","db9eb1aa":"code","e6a4f1cf":"markdown","8efc1e85":"markdown","66d4afb3":"markdown","2670c107":"markdown","fb56ebbf":"markdown","ae3af46d":"markdown","f519b369":"markdown","e278ab13":"markdown","17e33b84":"markdown","687ff7d1":"markdown","ef164d25":"markdown","6334f0a9":"markdown","5c3cecc8":"markdown","4b6134be":"markdown","ccf63a05":"markdown","ae20d4cd":"markdown","543ebb20":"markdown","aa84b713":"markdown","0c09dd9e":"markdown","1e0e6bdc":"markdown","f3c884a1":"markdown","2c55c0d4":"markdown"},"source":{"123faf7a":"import numpy as np\nimport matplotlib.pyplot as plt\n\nimport scipy\nfrom scipy import signal","069f445c":"t = np.arange(0, 11)\nx = (0.85) ** t","6941df60":"plt.figure(figsize = (10,8)) # set the size of figure\n\n# 1. Plotting Analog Signal\nplt.subplot(2, 2, 1)\nplt.title('Analog Signal', fontsize=20)\n\nplt.plot(t, x, linewidth=3, label='x(t) = (0.85)^t')\nplt.xlabel('t' , fontsize=15)\nplt.ylabel('amplitude', fontsize=15)\nplt.legend(loc='upper right')\n\n# 2. Sampling and Plotting of Sampled signal\nplt.subplot(2, 2, 2)\nplt.title('Sampling', fontsize=20)\nplt.plot(t, x, linewidth=3, label='x(t) = (0.85)^t')\nn = t\n\nmarkerline, stemlines, baseline = plt.stem(n, x, label='x(n) = (0.85)^n')\nplt.setp(stemlines, 'linewidth', 3)\nplt.xlabel('n' , fontsize = 15)\nplt.ylabel('amplitude', fontsize = 15)\nplt.legend(loc='upper right')\n\n# 3. Quantization\nplt.subplot(2, 2, 3)\nplt.title('Quantization', fontsize = 20)\n\nplt.plot(t, x, linewidth =3)\nmarkerline, stemlines, baseline=plt.stem(n,x)\nplt.setp(stemlines, 'linewidth', 3)\nplt.xlabel('n', fontsize = 15)\nplt.ylabel('Range of Quantizer', fontsize=15)\n\nplt.axhline(y = 0.1, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.2, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.3, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.4, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.5, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.6, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.7, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.8, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.9, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 1.0, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\n\nplt.subplot(2, 2, 4)\nplt.title('Quantized Signal', fontsize = 20)\nxq = np.around(x,1)\nmarkerline, stemlines, baseline = plt.stem(n,xq)\nplt.setp(stemlines, 'linewidth', 3) \nplt.xlabel('n', fontsize = 15)\nplt.ylabel('Range of Quantizer', fontsize=15)\n\nplt.axhline(y = 0.1, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.2, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.3, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.4, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.5, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.6, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.7, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.8, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 0.9, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\nplt.axhline(y = 1.0, xmin = 0, xmax = 10, color = 'r', linewidth = 3.0)\n\nplt.tight_layout()","c2dbf8ee":"impulse = signal.unit_impulse(10, 'mid')\nshifted_impulse = signal.unit_impulse(7, 2)\n\n# Sine wave\nt = np.linspace(0, 10, 100)\namp = 5 # Amplitude\nf = 50\nx = amp * np.sin(2 * np.pi * f * t)\n\n# Exponential Signal\nx_ = amp * np.exp(-t)","d827f8b1":"plt.figure(figsize=(10, 8))\n\nplt.subplot(2, 2, 1)\nplt.plot(np.arange(-5, 5), impulse, linewidth=3, label='Unit impulse function')\nplt.ylim(-0.01,1)\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 2)\nplt.plot(shifted_impulse, linewidth=3, label='Shifted Unit impulse function')\n\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 3)\nplt.plot(t, x, linewidth=3, label='Sine wave')\n\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 4)\nplt.plot(t, x_, linewidth=3, label='Exponential Signal')\n\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.tight_layout()","b682d6dc":"# Sine wave\nn = np.linspace(0, 10, 100)\namp = 5 # Amplitude\nf = 50\nx = amp * np.sin(2 * np.pi * f * n)\n\n# Exponential Signal\nx_ = amp * np.exp(-n)","f4f98453":"plt.figure(figsize=(12, 8))\n\nplt.subplot(2, 2, 1)\nplt.stem(n, x, 'yo', label='Sine wave')\n\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 2)\nplt.stem(n, x_, 'yo', label='Exponential Signal')\n\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')","10d201da":"f = 20 # Hz\nt = np.linspace(0, 0.5, 200)\nx1 = np.sin(2 * np.pi * f * t)\n\ns_rate = 35 # Hz. Here the sampling frequency is less than the requirement of sampling theorem\n\nT = 1 \/ s_rate\nn = np.arange(0, 0.5 \/ T)\nnT = n * T\nx2 = np.sin(2 * np.pi * f * nT) # Since for sampling t = nT.","49d7d527":"print(len(t))\nprint(len(nT))","8bbb3b0d":"plt.figure(figsize=(10, 8))\nplt.suptitle(\"Sampling a Sine Wave of Fmax=20Hz with fs=35Hz\", fontsize=20)\n\nplt.subplot(2, 2, 1)\nplt.plot(t, x1, linewidth=3, label='SineWave of frequency 20 Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 2)\nplt.plot(nT, x2, 'ro', label='Sample marks after resampling at fs=35Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 3)\nplt.stem(nT, x2, 'm', label='Sample after resampling at fs=35Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 4)\nplt.plot(nT, x2, 'g-', label='Reconstructed Sine Wave')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.tight_layout()","a8ffd837":"f = 20 # Hz\nt = np.linspace(0, 0.5, 200)\nx1 = np.sin(2 * np.pi * f * t)\n\ns_rate = 50 # Hz. Here the sampling frequency is less than the requirement of sampling theorem\n\nT = 1 \/ s_rate\nn = np.arange(0, 0.5 \/ T)\nnT = n * T\nx2 = np.sin(2 * np.pi * f * nT) # Since for sampling t = nT.","85ac11a2":"plt.figure(figsize=(10, 8))\nplt.suptitle(\"Sampling a Sine Wave of Fmax=20Hz with fs=50Hz\", fontsize=20)\n\nplt.subplot(2, 2, 1)\nplt.plot(t, x1, linewidth=3, label='SineWave of frequency 20 Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 2)\nplt.plot(nT, x2, 'ro', label='Sample marks after resampling at fs=50Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 3)\nplt.stem(nT, x2, 'm', label='Sample after resampling at fs=50Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 4)\nplt.plot(nT, x2, 'g-', label='Reconstructed Sine Wave')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.tight_layout()","14cd8e17":"f = 20 # Hz\nt = np.linspace(0, 0.5, 200)\nx1 = np.sin(2 * np.pi * f * t)\n\ns_rate = 100 # Hz. Here the sampling frequency is less than the requirement of sampling theorem\n\nT = 1 \/ s_rate\nn = np.arange(0, 0.5 \/ T)\nnT = n * T\nx2 = np.sin(2 * np.pi * f * nT) # Since for sampling t = nT.","e8c40f16":"plt.figure(figsize=(10, 8))\nplt.suptitle(\"Sampling a Sine Wave of Fmax=20Hz with fs=100Hz\", fontsize=20)\n\nplt.subplot(2, 2, 1)\nplt.plot(t, x1, linewidth=3, label='SineWave of frequency 20 Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 2)\nplt.plot(nT, x2, 'ro', label='Sample marks after resampling at fs=100Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 3)\nplt.stem(nT, x2, 'm', label='Sample after resampling at fs=100Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 4)\nplt.plot(nT, x2, 'g-', label='Reconstructed Sine Wave')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.tight_layout()","1d017fcf":"t = np.linspace(0, 0.5, 200)\nx1 = 2 * np.sin(2 * np.pi * 10 * t) + np.sin(2 * np.pi * 20 * t)\n\ns_rate = 100 # Hz. Here the sampling frequency is less than the requirement of sampling theorem\n\nT = 1 \/ s_rate\nn = np.arange(0, 0.5 \/ T)\nnT = n * T\nx2 = 2 * np.sin(2 * np.pi * 10 * nT) + np.sin(2 * np.pi * 20 * nT) # Since for sampling t = nT.","a8d4ac8a":"plt.figure(figsize=(10, 8))\nplt.suptitle(\"Sampling a Two Sine Wave of Fmax=20Hz with fs=100Hz\", fontsize=20)\n\nplt.subplot(2, 2, 1)\nplt.plot(t, x1, linewidth=3, label='SineWave of frequency 20 Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 2)\nplt.plot(nT, x2, 'ro', label='Sample marks after resampling at fs=100Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 3)\nplt.stem(nT, x2, 'm', label='Sample after resampling at fs=100Hz')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.subplot(2, 2, 4)\nplt.plot(nT, x2, 'g-', label='Reconstructed Sine Wave')\nplt.xlabel('time.', fontsize=15)\nplt.ylabel('Amplitude', fontsize=15)\nplt.legend(fontsize=10, loc='upper right')\n\nplt.tight_layout()","e1c8bf60":"# Define domain\ndx = 0.001\nL = np.pi\nx = L * np.arange(-1 + dx, 1 + dx, dx)\nn = len(x)\nnquart = int(np.floor(n \/ 4))","6c119ea0":"# Define hat function\nf = np.zeros_like(x)\nf[nquart:2*nquart] = (4 \/ n) * np.arange(1, nquart + 1)\nf[2*nquart:3*nquart] = np.ones(nquart) - (4 \/ n) * np.arange(0, nquart)","d6cd97f7":"fig, ax = plt.subplots()\nax.plot(x, f, '-', color='k', linewidth=2)","378d7d29":"# # Define domain\n# dx = 0.001\n# L = np.pi\n# x = L * np.arange(-1 + dx, 1 + dx, dx)\n# n = len(x)\n# nquart = int(np.floor(n \/ 4))\n\n# # Define hat function\n# f = np.zeros_like(x)\n# f[nquart:2*nquart] = (4 \/ n) * np.arange(1, nquart + 1)\n# f[2*nquart:3*nquart] = np.ones(nquart) - (4 \/ n) * np.arange(0, nquart)\n\n# fig, ax = plt.subplots()\n# ax.plot(x, f, '-', color='k', linewidth=2)\n\n# # Compute Fourier Series\n\n# A0 = np.sum(f * np.ones_like(x)) * dx\n# fFS = A0 \/ 2\n\n# A = np.zeros(20)\n# B = np.zeros(20)\n# for k in range(20):\n#     A[k] = np.sum(f * np.cos(np.pi * (k + 1) * x\/L)) * dx\n#     B[k] = np.sum(f * np.sin(np.pi * (k + 1) * x\/L)) * dx\n#     fFs = fFS + A[k] * np.cos((k + 1) * np.pi * x \/ L) + B[k] * np.sin((k + 1) * np.pi * x \/ L)\n#     ax.plot(x, fFS, '-')","5044eccd":"dx = 0.01\nL = 2 * np.pi\nx = np.arange(0, L + dx, dx)\nn = len(x)\nnquart = int(np.floor(n \/ 4))\n\nf = np.zeros_like(x)\nf[nquart:3 * nquart] = 1\n\nA0 = np.sum(f * np.ones_like(x)) * dx * 2 \/ L\nfFS = A0 \/ 2 * np.ones_like(f)\n\nfor k in range(1, 101):\n    Ak = np.sum(f * np.cos(2 * np.pi * k * x \/ L)) * dx * 2 \/ L\n    Bk = np.sum(f * np.sin(2 * np.pi * k * x \/ L)) * dx * 2 \/ L    \n    fFS = fFS + Ak * np.cos(2 * k * np.pi * x \/ L) + Bk * np.sin(2 * k * np.pi * x \/ L)\n    \nplt.plot(x, f, color='k', linewidth=2)\nplt.plot(x, fFS, '-', color='r', linewidth=1.5)\nplt.title('Gibbs Phenomena')\nplt.show()","fdbfeb55":"# j, k = np.meshgrid(np.arange(n), np.arange(n))\n# dft = np.power(w, j * k)\n# dft = np.real(dft)\n\n# plt.imshow(dft)","be271b92":"plt.rcParams['figure.figsize'] = [10,6]","ef90a8ae":"# Create synthetic signal\ndt = 0.001\nt = np.arange(0, 1, dt)\nsignal = np.sin(2 * np.pi * 50 * t) + np.sin(2 * np.pi * 120 * t) # Sum of 2 Sequencies\nsignal_clean = signal\nsignal = signal + 2.5 * np.random.randn(len(t)) # Add some noise\nmin_signal, max_signal = signal.min(), signal.max()","0408a7f3":"plt.plot(t, signal, color='c', linewidth=1.5, label='Noisy')\nplt.plot(t, signal_clean, color='k', linewidth=2, label='Clean')\nplt.xlim(t[0], t[-1])\nplt.xlabel('t axis')\nplt.ylabel('Vals')\nplt.legend()","d67ad5d6":"# Compute the Fast Fourier Transform (FFT)\n\nn = len(t)\nfhat = np.fft.fft(signal, n)                 # Compute the FFT\npsd = fhat * np.conj(fhat) \/ n          \nfreq = (1 \/ (dt * n)) * np.arange(n)    # frequency array\nidxs_half = np.arange(1, np.floor(n \/ 2), dtype=np.int32)  # first half index","91609d0a":"fig, axs = plt.subplots(2, 1)\n\nplt.sca(axs[0])\nplt.plot(t, signal, color='c', linewidth=1.5, label='Noisy')\nplt.plot(t, signal_clean, color='k', linewidth=2, label='Clean')\nplt.xlim(t[0], t[-1])\nplt.xlabel('t axis')\nplt.ylabel('Vals')\nplt.legend()\n\nplt.sca(axs[1])\nplt.plot(freq[idxs_half], psd[idxs_half], color='c', linewidth=2, label='PSD Noisy')\nplt.xlim(freq[idxs_half[0]], freq[idxs_half[-1]])\nplt.xlabel('t axis')\nplt.ylabel('Vals')\nplt.legend()\n\nplt.tight_layout()","b8701f1e":"threshold = 100\npsd_idxs = psd > threshold # array of 0 and 1\npsd_clean = psd * psd_idxs # zero out all the unnecessary powers\nfhat_clean = psd_idxs * fhat # used to retreive the signal\n\nsignal_filtered = np.fft.ifft(fhat_clean) # inverse fourier transform","ac549a94":"fig, axs = plt.subplots(4, 1)\n\nplt.sca(axs[0])\nplt.plot(t, signal, color='b', linewidth=0.5, label='Noisy')\nplt.plot(t, signal_clean, color='r', linewidth=1, label='Clean')\nplt.ylim(min_signal, max_signal)\nplt.xlabel('t axis')\nplt.ylabel('Vals')\nplt.legend()\n\nplt.sca(axs[1])\nplt.plot(freq[idxs_half], np.abs(psd[idxs_half]), color='b', linewidth=0.5, label='PSD noisy')\nplt.xlabel('Frequencies in Hz')\nplt.ylabel('Amplitude')\nplt.legend()\n\nplt.sca(axs[2])\nplt.plot(freq[idxs_half], np.abs(psd_clean[idxs_half]), color='r', linewidth=1, label='PSD clean')\nplt.xlabel('Frequencies in Hz')\nplt.ylabel('Amplitude')\nplt.legend()\n\nplt.sca(axs[3])\nplt.plot(t, signal_filtered, color='r', linewidth=1, label='Clean Signal Retrieved')\nplt.xlim(t[0], t[-1])\nplt.ylim(min_signal, max_signal)\nplt.xlabel('t axis')\nplt.ylabel('Vals')\nplt.legend()\n\nplt.tight_layout()","17e46bf1":"plt.plot(freq[idxs_half], np.abs(psd_clean[idxs_half]), color='r', linewidth=1, label='PSD clean')\nplt.xlabel('Frequencies in Hz')\nplt.ylabel('Amplitude')\nplt.legend()","57204c3a":"n = 64\nL = 30\ndx = L \/ n\nx = np.arange(-L\/2, L\/2, dx, dtype='complex_')\nf = np.cos(x) * np.exp(-np.power(x, 2) \/ 25) # Function\ndf = -(np.sin(x) * np.exp(-np.power(x, 2) \/ 25) + (2 \/ 25) * x * f) # Derivative","5328f1bc":"# Approximate derivative using finite differences\ndfFD = np.zeros(len(df), dtype='complex_')\nfor kappa in range(len(df) - 1):\n    dfFD[kappa] = (f[kappa+1] - f[kappa]) \/ dx\n    \ndfFD[-1] = dfFD[-2]","8cf793b0":"# Derivative using FFT (spectral derivative)\nfhat = np.fft.fft(f)\nkappa = (2 * np.pi \/ L) * np.arange(-n\/2, n\/2)\nkappa = np.fft.fftshift(kappa) # Re-order fft frequencies\ndfhat = kappa * fhat * (1j)\ndfFFT = np.real(np.fft.ifft(dfhat))","f30a65ff":"plt.plot(x, df.real, color='k', linewidth=2, label='True Derivative')\nplt.plot(x, dfFD.real, '--', color='b', linewidth=0.5, label='Finite Diff.')\nplt.plot(x, dfFFT.real, '--', color='c', linewidth=0.5, label='FFT Derivative')\nplt.legend()","d0c843c0":"dt = 0.001\nt = np.arange(0, 2, dt)\nf0 = 50\nf1 = 250\nt1 = 2\nx = np.cos(2 * np.pi * t * (f1 - f0) * np.power(t, 2) \/ (3 * t1 **2))\n\nfs = 1 \/ dt\n\nplt.specgram(x, NFFT=128, Fs=1\/dt, noverlap=120, cmap='jet_r')\nplt.colorbar()","60b23040":"import librosa\n\n","db9eb1aa":"import tensorflow as tf\nimport timeit\n\nprint(\"seconds (lower is better):\")\nprint(f\"Tensorflow {tf.__version__}\", timeit.timeit('X = tf.signal.rfft(x)', setup='import tensorflow as tf; x = tf.random.normal([50000, 512])', number=10))\nprint(\"Numpy: \", timeit.timeit('X = numpy.fft.rfft(x)', setup='import numpy.fft; import tensorflow as tf; x = tf.random.normal([50000, 512])', number=10))\nprint(\"Jax: \", timeit.timeit('jnp.fft.rfft(x).block_until_ready()', setup='import jax.numpy as jnp; import tensorflow as tf; x = tf.random.normal([50000, 512]).numpy()', number=10))\nprint(\"Scipy: \", timeit.timeit('scipy.fft.rfft(x)', setup='import scipy; import tensorflow as tf; x = tf.random.normal([50000, 512]).numpy()', number=10))\nprint(\"Scipy (parallelization): \", timeit.timeit('scipy.fft.rfft(x, workers=-1)', setup='import scipy; import tensorflow as tf; x = tf.random.normal([50000, 512]).numpy()', number=10))\n","e6a4f1cf":"We created our signal by summing two sine functions with different frequencies (50Hz and 120Hz). Then we created an array of random noise and stacked that noise onto the signal.","8efc1e85":"# Sampling Frequency greater than twice the maximum frequency (fs > 5fmax - `100Hz`) ","66d4afb3":"# Signal Reconstruction\n\nIn signal processing, reconstruction usually means the determination of an original continuous signal from a sequence of equally spaced samples.\n\n- `Shannon Nyquist Sampling Theorem`: A function containing no frequency higher than wHz, is completely determined by sampling at 2wHz\n\n# Nyquist sampling theorem\n\nThe Nyquist sampling theorem states that \"The sampling frequency fs should be greater or equal than twice the maximum frequency of the signal (continuous time signal) to be sampled\".\n\nIf Fmax is the maximum frequency of the signal then according to sampling theorem: fs >= 2Fmax\n\nSampling theorem is very important if we want to reconstruct the signal after sampling.","2670c107":"# Sampling and Reconstruction of sum of two sine waves","fb56ebbf":"## References:\n- [Frequency Domain - DeepAI](https:\/\/deepai.org\/machine-learning-glossary-and-terms\/frequency-domain)\n\n- [Fourier Transforms With scipy.fft: Python Signal Processing](https:\/\/realpython.com\/python-scipy-fft\/)\n\n- https:\/\/www.earthinversion.com\/techniques\/signal-denoising-using-fast-fourier-transform\/","ae3af46d":"# Signal Processing\n\n> - Signal Processing is the field of science which involves the manipulation of signal from time domain to frequency and vice versa, smoothing the signal, separating the noise from signal i.e filtering, extracting information from the signal.\n\n> - Signals exist in nature are continuous signal. Continuous-time (or analog) signals exist for the continuous interval (t1, t2) can range from $-\\infty$ to $+\\infty$\n\n# Basics of signal processing system\n\n> - Since computer needs digital signals for processing, therefore, in order to use an analog signal on a computer it must be digitized with an analog-to-digital converter. Thus, there is a need for an interface between the analog signal and the digital signal processor.\n\n![fig2-an-introduction-to-digital-signal-processing.jpg](attachment:9aeed073-37e3-4eee-821b-15d4c65c12ad.jpg)\n\n[Source](https:\/\/www.allaboutcircuits.com\/technical-articles\/an-introduction-to-digital-signal-processing\/)\n\n# Analog to Digital Convertion of Signals\n\n![Analog-to- Digital Conversion_PCM.jpg](attachment:4ef314bf-82ff-430c-ab67-9112a7be2a70.jpg)\n\n[Source](http:\/\/www.myreadingroom.co.in\/notes-and-studymaterial\/68-dcn\/732-analog-to-digital-conversion-techniques.html)\n\n- **Sampling**: sampling is the reduction of a continuous-time signal to a discrete-time signal. A common example is the conversion of a sound wave (a continuous signal) to a sequence of samples (a discrete-time signal)\n\n- **Quantization**: quantization is the process of mapping input values from large set (often continuous set) to output values in a (countable) smaller set, often with a finite number of elements. Rouding and Truncation are typical examples of quantization processes.\n\n- **Encoding**: After each sample is quantized and the number of bits per sample is decided, each sample can be changed to an nb-bit code word. The number of bits for each sample is determined from the number of quantization levels. If the number of quantization levels is `L`, the number of bits is `nb=log2.L`","f519b369":"# What is a Frequency Domain?\n\nThe frequency domain refers to the analytic space in which mathematical functions or signals are conveyed in terms of frequency, rather than time. For example, where a time-domain graph may display changes over time, a frequency-domain graph displays how much of the signal is present among each given frequency band. It is possible, however, to convert the information from a time-domain to a frequency-domain. An example of such transformation is a Fourier transfrom. The Fourier transform converts the time function into a set of sine waves that represent different frequencies. The frequency-domain representation of a signal is known as the spectrum of frequency components.\n\n# How does the Frequency Domain work?\nThe Frequency domain works by allowing a representation of the qualitative behavior of a system, as well as characteristics of the way the system response to changes in bandwidth, gain, phase shift, harmonics, ets. A displine in which the frequency domain is used for graphical representation is in music. Often audio producers and engineers display an audio signal within a frequency domain in order to better understand the shape and character of an audio signal.\n\n![rtaImage.gif](attachment:e710c566-eb61-4d30-8ccd-38482f973aa9.gif)\n\n[source](https:\/\/knowledge.ni.com\/KnowledgeArticleDetails?id=kA03q000000YGJ7CAO&l=en-US)","e278ab13":"# Discrete Signals","17e33b84":"# Spectral Derivative","687ff7d1":"# Denoising Data with FFT\n\n- Perform Fast Fourier Transform\n- Filter out the noise\n- Visualization the results\n- Real data denoising using power threshold\n- Obspy based filter\n\nThe Fourier Serie for an arbitrary function of time $f(t)$ defined over the interval $((-T\/2 < t < T\/2 ))$ is:\n\n\n$$f(t) = a_0 + \\sum_{n=1}^{\\infty} a_n cos(\\frac{2n\\pi t}{T}) + \\sum_{n=1}^{\\infty} b_n sin(\\frac{2n\\pi t}{T})$$\n\nIn the above equation, we can see that the $cos(\\frac{2n\\pi t}{T})$ and $sin(\\frac{2n\\pi t}{T})$ are periodic with period $\\frac{T}{n}$ or frequency $\\frac{n}{T}$. Here, the larger values of n correspond to shorter periods, or higher frequencies.\n\nIn this part, we will use Fourier analysis to filter with the assumption that noise is overlapping the signals in the time domain but are not so overlapping in the frequency domain.","ef164d25":"# Sine wave","6334f0a9":"# Unit Impulse Signal","5c3cecc8":"# Spectrogram (Gabor Transform)\n\n- A spectrogram is like a photograph or image of a signal\n- A spectrogram plot time in Y-axis and frequencies in X-axis.\n- A spectrogram also conveys the signal strength using the colors - brighter the color the higher the energy of the signal.\n- A spectrogram explains how the signal strength is distributed in every frequency found in the signal.\n\n---\nMeasuring the frequency and amplitude of the signals can be considered the main motive of the spectrogram. For visualising signals into an image, we use a spectrogram that plots the time in the x-axis and frequency in the y-axis and, for more detailed information, amplitude in the z-axis. Also, it can be on different colors where the density of colors can be considered the signal's strength. Finally, it gives you an overview of the signal where it explains how the strength of the signal is distributed in different frequencies.\n\nSo the amplitude and the frequency of the signal are the two main components of any spectrogram. \n\n- Frequency: Mathematically, frequency is the number of waves passing through a fixed point in a single time unit or the number of cycles performed by a body in a single time when it is in a periodic motion.\n\n- Amplitude: Amplitude can be defined as the greatest distance travelled by a moving body in a periodic motion in a single time unit or the highest distance of the wave on dips down or rising from its flat surface.\n\n![image-293.png](attachment:ed058a90-b382-4c76-a1c4-7c64a7579138.png)\n\n[source](https:\/\/lightcat-files.s3.amazonaws.com\/problem_images\/af49016fd63588d9-1593714092882.jpg)\n\nThe mathematics behind the spectrogram is based on the Gabor transform. We use the Gabor transform to compute the spectrogram. Gabor transform is the special case of the short-time Fourier transform used to extract the sinusoidal frequency and phase content of a signal in its particular section. ","4b6134be":"# Filter out the noise\n\nIn the above plot, we can see that the two frequencies from our original signal is standing out. Now, we can create a filter that can remove all frequencies with amplitude less than our threshold.","ccf63a05":"# Fourier Transforms\n\nThe Fourier transform is a powerful tool for analyzing signals and is used in everything from audio processing to image processing to image compression. \n\nFourier analysis is a field that studies how a mathematical function can be decomposed into a series of simpler trigonometric functions. The Fourier transform is a tool from this field for decomposing a function into its component frequencies. In other words, the Fourier transform is tool that allows you to take a signal and see the power of each frequency in it. Take a look at the important terms in that sentence:\n- A signal is information that changes over time. For example, audio, video, and voltage traces are all examples of signals.\n- A frequency is the speed at which something repeats. For example, clocks ticks at a frequency of one herts (Hz), or one repetition per second.\n- Power, in this case, just means the strength of each frequency.\n\nThe following image is a visual demonstration of frequency and power on some sine waves:\n\n![freqpower2.png](attachment:b38398b9-58f3-4502-89e8-4029bd91358e.png)\n\nThe peaks of the high-frequency sine wave are closer together than those of the low-frequency sine wave since they repeat more frequently. The low-power sine wave has smaller peaks than the other two sine waves.\n\n# Why Would You Need the Fourier Transform?\n\nThe Fourier transform is useful in many applications. Image compression uses a variant of the Fourier tranform to remove the high-frequency components of images. Speech recognition uses the Fourier transform and related transforms to recover the spoken words from raw audio.\n\nIn general, you need the Fourier transform if you need to look at the frequencies in a signal. If working with a signal in the time domain is difficult, then using the Fourier transform to move it into the frequency domain is worth trying.","ae20d4cd":"# Perform Fast Fourier Transform","543ebb20":"# Sampling & Reconstruction","aa84b713":"Numpy's `fft.fft` function returns the one-dimentional discrete Fourier Transform with the efficient Fast Fourier Transform (FFT) algorithm. The output of the function is complex and we multiplied it with its conjugate to obtain the power spectrum of the noisy signal. We created the array of frequencies using the sampling interval (`dt`) and the number of samples (`n`).","0c09dd9e":"# The Discrete Fourier Transform (DFT)\n\nThe discrete Fourier transform (DFT) converts a finite sequence of equally-spaced samples of a function into a same-length sequence of equally-spaced samples of the discrete-time Fourier transform (DTFT), which is a complex-valued function of frequency. The interval at which the DTFT is sampled is the reciprocal of the duration of the input sequence.","1e0e6bdc":"# Continuous Signal","f3c884a1":"# Sampling Frequency greater than twice the maximum frequency (fs > 2fmax - `50Hz`) ","2c55c0d4":"# Gibbs Phenomena"}}