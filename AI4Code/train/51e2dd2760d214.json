{"cell_type":{"5e8a806e":"code","9ac5403f":"code","8fbfd597":"code","38d9b08a":"code","10693c39":"code","32611136":"code","fb9df889":"code","ab3bf8b2":"code","5792857c":"code","49066c55":"code","8df97000":"code","7dd2c94a":"code","ea14d8c1":"code","cb98980c":"code","9a8f254b":"code","8c38c246":"code","03728ed9":"code","86f4492a":"code","20962313":"code","93577622":"code","517adf9f":"code","1861c43d":"code","e00b1c23":"code","48d47115":"code","7e967768":"code","4cf4ab43":"code","d7af1940":"code","1f1ba9af":"markdown","dfe12ce0":"markdown","0e134af2":"markdown","018c3979":"markdown","81c29658":"markdown","cd5c268a":"markdown","d6a3dc6f":"markdown","5f019893":"markdown","dc9710da":"markdown","c050d5e5":"markdown","2967f0d6":"markdown","f4dcb611":"markdown","b3e1952a":"markdown","6ea1511c":"markdown","08df5692":"markdown","e9919846":"markdown","1672c0ab":"markdown","2d4cb90b":"markdown","0ee43784":"markdown","f1094c1f":"markdown","fe67885f":"markdown"},"source":{"5e8a806e":"import os\nimport glob\nimport re\nimport math\nimport numpy as np\nimport pandas as pd\nfrom tqdm.notebook import tqdm\nimport cv2\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pydicom as dicom\nfrom pydicom.pixel_data_handlers.util import apply_voi_lut\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau","9ac5403f":"data_directory = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/'","8fbfd597":"train_df = pd.read_csv(data_directory+\"train_labels.csv\")\ntrain_df['BraTS21ID5'] = [format(x, '05d') for x in train_df.BraTS21ID]\ntrain_df.head(3)","38d9b08a":"test = pd.read_csv(\n    data_directory+'sample_submission.csv')\n\ntest['BraTS21ID5'] = [format(x, '05d') for x in test.BraTS21ID]\ntest.head(3)","10693c39":"IMAGE_SIZE = 240\nSCALE = .8\nNUM_IMAGES = 64\nMRI_TYPE = \"FLAIR\"","32611136":"def load_dicom_image(\n    path,\n    img_size=IMAGE_SIZE,\n    scale=SCALE):\n    '''\n    This function allows you to load a DCIM type image \n    and apply preprocessing steps such as crop, resize \n    and denoising filter to it.\n    ****************************************************\n    PARAMETERS\n    ****************************************************\n    - path : String\n        Path to the DCIM image file to load.\n    - img_size : Integer\n        Image size desired for resizing.\n    - scale : Float\n        Desired scale for the cropped image\n    - prep : Bool\n        True for a full preprocessing with\n        denoising.\n    '''\n    # Load single image\n    img = dicom.read_file(path).pixel_array\n    # Crop image\n    center_x, center_y = img.shape[1] \/ 2, img.shape[0] \/ 2\n    width_scaled, height_scaled = img.shape[1] * scale, img.shape[0] * scale\n    left_x, right_x = center_x - width_scaled \/ 2, center_x + width_scaled \/ 2\n    top_y, bottom_y = center_y - height_scaled \/ 2, center_y + height_scaled \/ 2\n    img = img[int(top_y):int(bottom_y), int(left_x):int(right_x)]\n    # Resize image\n    img = cv2.resize(img, (img_size, img_size))\n    \n    # Convert in 3D array\n    img = np.repeat(img[..., np.newaxis], 3, -1)\n    \n    return img","fb9df889":"sample_img = dicom.read_file(\n    data_directory+\"train\/00046\/FLAIR\/Image-90.dcm\").pixel_array\npreproc_img = load_dicom_image(data_directory+\"train\/00046\/FLAIR\/Image-90.dcm\")\n\n\nfig = plt.figure(figsize=(12,8))\nax1 = plt.subplot(1,2,1)\nax1.imshow(sample_img, cmap=\"gray\")\nax1.set_title(f\"Original image shape = {sample_img.shape}\")\nax2 = plt.subplot(1,2,2)\nax2.imshow(preproc_img[:,:,0], cmap=\"gray\")\nax2.set_title(f\"Preproc image shape = {preproc_img.shape}\")\nplt.show()","ab3bf8b2":"def load_dicom_images_3d(\n    scan_id, \n    num_imgs=NUM_IMAGES, \n    img_size=IMAGE_SIZE, \n    mri_type=MRI_TYPE, \n    split=\"train\"):\n    '''\n    This function allows loading an ordered sequence \n    of x preprocessed images starting from the central \n    image of each folder.\n    ****************************************************\n    PARAMETERS\n    ****************************************************\n    - scan_id : String\n        ID of the patient to load.\n    - num_imgs : Integer\n        Number of desired images of the \n        sequence.\n    - img_size : Integer\n        Image size desired for resizing.\n    - scale : Float\n        Desired scale for the cropped image\n    - mri_type : String\n        Type of scan to load (FLAIR, T1w, \n        T1wCE, T2).\n    - split : String\n        Type of split desired : Train or Test\n    '''\n    files = sorted(glob.glob(f\"{data_directory}{split}\/{scan_id}\/{mri_type}\/*.dcm\"), \n               key=lambda var:[int(x) if x.isdigit() else x for x in re.findall(r'[^0-9]|[0-9]+', var)])\n\n    middle = len(files)\/\/2\n    num_imgs2 = num_imgs\/\/2\n    p1 = max(0, middle - num_imgs2)\n    p2 = min(len(files), middle + num_imgs2)\n    img3d = np.stack([load_dicom_image(f) for f in files[p1:p2]]) \n    if img3d.shape[0] < num_imgs:\n        n_zero = np.zeros((num_imgs - img3d.shape[0], img_size, img_size, 3))\n        img3d = np.concatenate((img3d,  n_zero), axis = 0)\n            \n    return img3d","5792857c":"sample_seq = load_dicom_images_3d(\"00046\")\nprint(\"Shape of the sequence is:\", sample_seq.shape)\nprint(\"Dimension of the 15th image in sequence is:\", sample_seq[15].shape)\nfig = plt.figure(figsize=(5,5))\nplt.imshow(np.squeeze(sample_seq[15][:,:,0]), cmap=\"gray\")\nplt.show()","49066c55":"base_resnet = keras.applications.ResNet50(\n    weights=None,\n    #weights=\"imagenet\",\n    pooling='avg',\n    input_shape=(IMAGE_SIZE, IMAGE_SIZE, 3),\n    include_top=False)\n\n\"\"\"base_resnet.save_weights(\n    'base_resnet_imagenet.h5')\"\"\"\nbase_resnet.load_weights(\n    '..\/input\/resnet-imagenet-weights\/base_resnet_imagenet.h5')","8df97000":"base_resnet.trainable = False","7dd2c94a":"train = train_df[['BraTS21ID5','MGMT_value']]\nX_train = train['BraTS21ID5'].values\ny_train = train['MGMT_value'].values","ea14d8c1":"listMatrix = []\nfor i, patient in enumerate(tqdm(X_train)):\n    listVectors = []\n    sequence = load_dicom_images_3d(scan_id=str(patient),mri_type=MRI_TYPE)\n    for j in range(len(sequence)):\n        img = sequence[j]\n        img = np.expand_dims(img, axis=0)\n        img = tf.keras.applications.resnet50.preprocess_input(img)\n        img_vector = base_resnet.predict(img)\n        listVectors.append(np.array(img_vector))\n    \n    PatientMatrix = np.stack(listVectors)\n    listMatrix.append(PatientMatrix)","cb98980c":"print(f\"Number of patient matrix: {len(listMatrix)}\")\nprint(f\"Patient matrix shape: {listMatrix[0].shape}\")","9a8f254b":"np.array(listMatrix, dtype=object).shape","8c38c246":"model_input_dim = listMatrix[0].shape[2]","03728ed9":"def get_sequence_model():\n    '''Define the LSTM architecture'''\n    model = keras.models.Sequential()\n    model.add(keras.layers.LSTM(100, input_shape=(NUM_IMAGES, model_input_dim), return_sequences=True))\n    model.add(keras.layers.Dropout(0.2))\n    model.add(keras.layers.Dense(100, activation='relu'))\n    model.add(keras.layers.Dense(1, activation='sigmoid'))\n    return model","86f4492a":"from sklearn.model_selection import KFold\n\ninputs = np.array(listMatrix)\ntargets = np.array(y_train).astype('float32').reshape((-1,1))\n\nnum_folds = 5\n\n# Define the K-fold Cross Validator\nkfold = KFold(n_splits=num_folds, shuffle=True)\n\n# K-fold Cross Validation model evaluation\nhistory = {}\nfold_no = 1\nfor train_df, valid_df in kfold.split(inputs, targets):\n    \n    train_dataset = tf.data.Dataset.from_tensor_slices((inputs[train_df], targets[train_df]))\n    valid_dataset = tf.data.Dataset.from_tensor_slices((inputs[valid_df], targets[valid_df]))\n    \n    model = get_sequence_model()\n    model.compile(loss='binary_crossentropy', \n                  optimizer='adam', \n                  metrics='accuracy')\n    \n    # Define callbacks.\n    model_save = ModelCheckpoint(f'Brain_lstm_kfold_{fold_no}.h5', \n                                 save_best_only = True, \n                                 monitor = 'val_accuracy', \n                                 mode = 'max', verbose = 1)\n    early_stop = EarlyStopping(monitor = 'val_accuracy', \n                               patience = 25, mode = 'max', verbose = 1,\n                               restore_best_weights = True)\n    \n    print('------------------------------------------------------------------------')\n    print(f'Training for fold {fold_no} ...')\n    \n    epochs = 200\n    history[fold_no] = model.fit(\n        train_dataset,\n        validation_data=valid_dataset, \n        epochs=epochs, \n        batch_size=32,\n        callbacks = [model_save, early_stop])\n    \n    # Increase fold number\n    fold_no += 1","20962313":"fig, ax = plt.subplots(1, 2, figsize=(20, 7))\nax = ax.ravel()\n\nfor fold in history:\n    for i, metric in enumerate([\"accuracy\",\"loss\"]):\n        ax[i].plot(history[fold].history[metric], label=\"train \"+str(fold))\n        ax[i].plot(history[fold].history[\"val_\" + metric], linestyle=\"dotted\", label=\"val \"+str(fold))\n        ax[i].set_title(\"Model {}\".format(metric))\n        ax[i].set_xlabel(\"epochs\")\n        ax[i].set_ylabel(metric)\n        ax[i].legend()","93577622":"kfold_results = pd.DataFrame(columns=[\"Fold\",\"Mean_Loss\",\"Mean_Accuracy\"])\nkey = []\nmean_loss = []\nmean_acc = []\nfor fold in history:\n    key.append(fold), \n    mean_loss.append(np.mean(history[fold].history[\"val_loss\"]))\n    mean_acc.append(np.mean(history[fold].history[\"val_accuracy\"]))\n\nkfold_results[\"Fold\"] = key\nkfold_results[\"Mean_Loss\"] = mean_loss\nkfold_results[\"Mean_Accuracy\"] = mean_acc\nkfold_results[\"Rank_Ratio\"] = (kfold_results[\"Mean_Loss\"] - kfold_results[\"Mean_Accuracy\"])\nkfold_results = kfold_results.sort_values(\"Rank_Ratio\", ascending=True)\nkfold_results","517adf9f":"best_kfold_model = '.\/Brain_lstm_kfold_' + str(kfold_results.Fold.values[0]) + '.h5'\nprint(f\"The best select model is {best_kfold_model}\")","1861c43d":"X_test = test['BraTS21ID5'].values\ntest_listMatrix = []\nfor i, patient in enumerate(tqdm(X_test)):\n    test_listVectors = []\n    test_sequence = load_dicom_images_3d(scan_id=str(patient),mri_type=MRI_TYPE,split=\"test\")\n    for j in range(len(test_sequence)):\n        img = test_sequence[j]\n        img = np.expand_dims(img, axis=0)\n        img = tf.keras.applications.resnet50.preprocess_input(img)\n        img_vector = base_resnet.predict(img)\n        test_listVectors.append(np.array(img_vector))\n    \n    test_PatientMatrix = np.stack(test_listVectors)\n    test_listMatrix.append(test_PatientMatrix)","e00b1c23":"print(f\"Number of test patient matrix: {len(test_listMatrix)}\")\nprint(f\"Test patient matrix shape: {test_listMatrix[0].shape}\")","48d47115":"test_dataset = tf.data.Dataset.from_tensor_slices(test_listMatrix)\nlen(test_dataset)","7e967768":"final_model = keras.models.load_model(best_kfold_model)\npredict = final_model.predict(test_dataset)\nprint(predict.shape)","4cf4ab43":"predict = predict[:,0,0]\nfinal_predict = []\nfor i in range(len(test_listMatrix)):\n    i+=1\n    final_predict.append(round(predict[((i-1)*NUM_IMAGES):(NUM_IMAGES*i)].mean(),3))\nsubmission = test[[\"BraTS21ID\",\"MGMT_value\"]]\nsubmission[\"MGMT_value\"] = final_predict\nsubmission.to_csv('submission.csv',index=False)\nsubmission.head(5)","d7af1940":"plt.figure(figsize=(8, 8))\nplt.hist(submission[\"MGMT_value\"])\nplt.title(\"Predicted probabilites distribution on test set\", \n          fontsize=18, color=\"#0b0a2d\")\nplt.show()","1f1ba9af":"# <span style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\" id=\"section_3\">Load pre-trained ResNet50 model<\/span>\n\nTo carry out the Transfer Learning on each image of the sequence, we will load a pre-trained model thanks to `Keras.applications` with the pre-trained weights on **ImageNet**.      \nAs the notebook must be without Internet for the competition, the weights are loaded separately and imported from a specially created Dataset *(..\/input\/resnet-imagenet-weights)*.\n\nHere we will chrger the **ResNet50 model**, knowing that other models have been tested such as ResNet50 and Xception.","dfe12ce0":"We will now train this LSTM model on the matrices compiled for each patient using the Transfer Learning ResNet50.\n\nAn EarlyStopping is set up and the best model will be saved.","0e134af2":"## <span style=\"color:#3c99dc; font-size:18px; text-transform: uppercase; font-weight:bold\" id=\"section_1_1\">Load single image<\/span>","018c3979":"<h1 style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\">Sommaire<\/h1>\n\n1. [Load data](#section_1)      \n2. [Image preprocessing](#section_2)      \n3. [Load pre-trained ResNet50 model](#section_3)      \n4. [Create a matrix of vectors base on ResNet50 for each patient sequence](#section_4)     \n5. [Apply LSTM for classification with Kfold](#section_5)      \n6. [Predict on test set with best model](#section_6)","81c29658":"First, we have to load the usefull Python libraries :","cd5c268a":"Let us now look at the shapes of the matrices obtained following the application of this Learning Transfer:","d6a3dc6f":"<span style=\"color:red; font-size:18px\">Don't forget to **upvote** if this Notebook helped you!<\/span>","5f019893":"# <span style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\" id=\"section_5\">Apply LSTM for classification<\/span>\n\nRecurrent neural networks (RNNs) are widely used in artificial intelligence when a temporal notion is involved in the data.\n\nLSTM is a complex and very powerful algorithm which will allow in our case to take into account the past elements of our sequence of images.","dc9710da":"## <span style=\"color:#3c99dc; font-size:18px; text-transform: uppercase; font-weight:bold\" id=\"section_1_2\">Load sequence of 64 preprocessed images<\/span>\n\nAs we saw **in the EDA part of the previous [Notebook](https:\/\/www.kaggle.com\/michaelfumery\/brain-tumor-3d-multimodal-cnn-all-mri-type)**, we are going to load the image sequence starting from the central image in order to avoid completely black images. We will then take the same number of images on each side of this central image.","c050d5e5":"We can check the result of these different preprocessing steps on a random patient:","2967f0d6":"**We will apply this process for just one type of MRI scans (here is T1w type)** for each patient. Each patient will therefore have 24 images for treatment.","f4dcb611":"# <span style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\" id=\"section_2\">Image preprocessing<\/span>\n\nFor each patient, we will carry out a pre-processing of the images by applying these different modifications:\n- Load an ordered sequence of 64 MRI scan\n- Crop images to reduce black borders\n- Resize image for pre-train model\n- Apply denoising filter\n- Convert each image in **3D array**","b3e1952a":"![brain_baner](http:\/\/www.mf-data-science.fr\/images\/projects\/brain_baner.jpg)","6ea1511c":"Now let's look at the results of this training:","08df5692":"# <span style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\" id=\"section_4\">Create a matrix of vectors base on ResNet50 for each patient sequence<\/span>\n\nFor this part of Transfer Learning, we will not train the ResNet50 model but only perform the prediction for each image of the sequence of each patient.     \nWe will thus obtain, for each image, a matrix of the model weights that we will integrate into a list to recreate the patient sequence.     \nFinally, we are going to create a global matrix which will group together the sequences of x ResNet50.predict matrices for all the patients.\n\nLet's look at the pseudo-code:\n```Python\n# Transfert Learning\nlistMatrix = []\nfor person in persons:\n    listVectors = []\n    for image in person.images:\n        img = preprocess(image)\n        vector = baseModel.predict(img)\n        listVectors.append(vector)\n\n    PatientMatrix = np.stack(listVectors)\n    listMatrix.append(PatientMatrix)\n```","e9919846":"# <span style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\" id=\"section_6\">Predict on test set with best model<\/span>\n\nWe will now create the ResNet50 matrices for the test set and make the predictions on the test patients.","1672c0ab":"Here again we can test the loading of a sequence of preprocessed images for a patient:","2d4cb90b":"**This Notebook is the extension of the tests of a CNN 3D model on all MRI types developed in a first Notebook *(with EDA)* :**\n\n<span style=\"font-size:18px\">[\ud83e\udde0Brain Tumor 3D Multimodal CNN - All MRI Type](https:\/\/www.kaggle.com\/michaelfumery\/brain-tumor-3d-multimodal-cnn-all-mri-type\/)<\/span>\n\n<h1 style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\">Context<\/h1>\n\nThe goal of this competition, initiated by the **Radiological Society of North America *(RSNA)*** in partnership with the **Medical Image Computing and Computer Assisted Intervention Society *(the MICCAI Society)*** is to predict the methylation of the **MGMT promoter**, which is an important gene biomarker for treatment of brain tumors.\n\nThese predictions will be based on a database of **MRI *(magnetic resonance imaging)*** scans of several hundred patients.\n\n<h1 style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\">Data<\/h1>\n\nEach independent case has a dedicated folder identified by a five-digit number. Within each of these \u201ccase\u201d folders, there are four sub-folders, each of them corresponding to each of the structural multi-parametric MRI (mpMRI) scans, in DICOM format. The exact mpMRI scans included are:\n\n- Fluid Attenuated Inversion Recovery (FLAIR)\n- T1-weighted pre-contrast (T1w)\n- T1-weighted post-contrast (T1Gd)\n- T2-weighted (T2)\n\n| ![brain_baner](http:\/\/www.mf-data-science.fr\/images\/projects\/brain_tumor_types.png) | \n|:--:| \n| *Examples of the four MR sequence types included in this work* |\n\n<h1 style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\">Acknowledgement<\/h1>\n\nThis Notebook is inspired from *Ammar Alhaj Ali* work :\n- [\ud83e\udde0Brain Tumor 3D [Training]](https:\/\/www.kaggle.com\/ammarnassanalhajali\/brain-tumor-3d-training)\n- [\ud83e\udde0Brain Tumor 3D [Inference]](https:\/\/www.kaggle.com\/ammarnassanalhajali\/brain-tumor-3d-inference)","0ee43784":"# <span style=\"color:#0b0a2d; font-size:24px; text-transform: uppercase; font-weight:bold\" id=\"section_1\">Load data<\/span>\n\nWe will first load the anotated training data files:","f1094c1f":"and the test data :","fe67885f":"We are also going to **fix all the layers of the model** so that they are not re-trained for the detection of features. The classification layer is also not loaded (`include_top = False`)."}}