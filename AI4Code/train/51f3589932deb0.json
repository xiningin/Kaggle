{"cell_type":{"d9731ad0":"code","a79ae61f":"code","49d615d2":"code","b7fb292c":"code","df17e418":"code","6921c94a":"code","e2de96f2":"code","cd33df97":"markdown","32639df0":"markdown","866d6204":"markdown"},"source":{"d9731ad0":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.experimental import enable_iterative_imputer\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.linear_model import LogisticRegression, LinearRegression\nfrom sklearn.pipeline import make_pipeline, make_union\nfrom sklearn.impute import SimpleImputer, IterativeImputer\nfrom sklearn.metrics import roc_auc_score, roc_curve\nfrom sklearn.preprocessing import PolynomialFeatures, StandardScaler, FunctionTransformer\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.neighbors import KNeighborsRegressor\n","a79ae61f":"train_df = pd.read_csv('..\/input\/song-popularity-prediction\/train.csv')\ntest_df = pd.read_csv('..\/input\/song-popularity-prediction\/test.csv')\ntrain_df[:3]","49d615d2":"train_df.describe()","b7fb292c":"features = [f for f in train_df.columns if f != 'song_popularity']\nfeatures.remove('id')\nfeatures.remove('time_signature')\nfeatures.remove('audio_mode')\n\noof = pd.Series(index=train_df.index, name='oof', dtype='float64')\nauc_list, test_pred_list = [], []\nkf = StratifiedKFold(5, shuffle=True, random_state=1)\nfor fold, (train_idx, val_idx) in enumerate(kf.split(train_df, train_df.song_popularity)):\n    X_tr = train_df.iloc[train_idx]\n    X_va = train_df.iloc[val_idx]\n    y_tr = X_tr.song_popularity\n    y_va = X_va.song_popularity\n\n    # Train\n    model = make_pipeline(IterativeImputer(KNeighborsRegressor(n_neighbors=7), max_iter=20),\n                          ColumnTransformer([('1', FunctionTransformer(lambda X, y=None: np.hstack([X, np.log(X-18000),\n                                                                                                    np.minimum(161275, X)])), \n                                              [features.index('song_duration_ms')]),\n                                             ('2', FunctionTransformer(lambda X, y=None: (X - X.min()) ** 1.2),\n                                              [features.index('acousticness')]),\n                                             ('3', FunctionTransformer(lambda X, y=None: np.hstack([(X - X.min()) ** 7,\n                                                                                                    np.minimum(0.31, X)])),\n                                              [features.index('danceability')]),\n                                             ('4', FunctionTransformer(lambda X, y=None: (X - X.min()) ** 7),\n                                              [features.index('energy')]),\n                                             ('5', FunctionTransformer(lambda X, y=None: np.hstack([X, np.log(X+0.1)])),\n                                              [features.index('instrumentalness')]),\n                                             ('6', FunctionTransformer(lambda X, y=None: X ** 4),\n                                              [features.index('key')]),\n                                             ('7', FunctionTransformer(lambda X, y=None: (X - X.min()) ** 0.9),\n                                              [features.index('liveness')]),\n                                             ('8', FunctionTransformer(lambda X, y=None: np.hstack([X, np.log(X-0.015)])),\n                                              [features.index('speechiness')]),\n                                             ('9', FunctionTransformer(lambda X, y=None: (X - X.min()) ** 0.6),\n                                              [features.index('tempo')]),\n                                             ('A', FunctionTransformer(lambda X, y=None: (X - X.min()) ** 0.3), \n                                              [features.index('audio_valence')]),\n                                             ('B', FunctionTransformer(lambda X, y=None: np.minimum(-21, X)), \n                                              [features.index('loudness')]),\n                                            ], remainder='passthrough'),\n                          PolynomialFeatures(2, include_bias=False),\n                          StandardScaler(), \n                          LinearRegression()\n                         )\n    model.fit(X_tr[features], y_tr)\n\n    # Validate\n    if model.steps[-1][0] != 'logisticregression':\n        y_pred = model.predict(X_va[features])\n    else:\n        y_pred = model.decision_function(X_va[features])\n    score = roc_auc_score(y_va, y_pred)\n    print(f\"Fold {fold} AUC: {score:.5f}\")\n    auc_list.append(score)\n    oof.iloc[val_idx] = y_pred.ravel()\n\n    # Predict for the submission\n    if model.steps[-1][0] != 'logisticregression':\n        test_pred_list.append(model.predict(test_df[features]))\n    else:\n        test_pred_list.append(model.decision_function(test_df[features]))\n\navg_auc = sum(auc_list) \/ len(auc_list)\nprint(f\"Average AUC:             {avg_auc:.5f}\") # 0.56944","df17e418":"# Plot the roc curve for the last fold\nplt.figure(figsize=(8, 8))\nfpr, tpr, _ = roc_curve(y_va, y_pred)\nplt.plot(fpr, tpr, color='r', lw=2)\nplt.plot([0, 1], [0, 1], color=\"navy\", lw=1, linestyle=\"--\")\nplt.gca().set_aspect('equal')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.0])\nplt.xlabel(\"False Positive Rate\")\nplt.ylabel(\"True Positive Rate\")\nplt.title(\"Receiver operating characteristic\")\nplt.show()\n","6921c94a":"# Create submission file\ntest_df['song_popularity'] = sum(test_pred_list) \/ len(test_pred_list)\ntest_df[['id', 'song_popularity']].to_csv('submission_ensemble.csv', index=False)\ntest_df[['id', 'song_popularity']].head()","e2de96f2":"# Retrain the model on the whole training data\nmodel.fit(train_df[features], train_df.song_popularity)\ntest_df['song_popularity'] = model.predict(test_df[features])\ntest_df[['id', 'song_popularity']].to_csv('submission_retrained.csv', index=False)\ntest_df[['id', 'song_popularity']].head()\n","cd33df97":"# The pipeline\n\nOur pipeline consists of the following steps:\n- We start by eliminating the useless features `time_signature` and `audio_mode`.\n- We impute the missing values using `IterativeImputer`.\n- We transform most features with a nonlinearity.\n- We add all products of two features using `PolynomialFeatures`.\n- We scale all inputs using `StandardScaler`.\n- Finally we feed this input to `LinearRegression`.","32639df0":"# Retraining\n\nWe retrain the model on the whole data to see how the predictions differ from the ensemble of the five cross-validation models.","866d6204":"# Linear Regression for Song Popularity Prediction\n\nThis short notebook shows:\n- How to predict song popularity with linear regression\n- Which features to eliminate\n- How to transform the remaining features\n- How to easily impute missing values\n- How to add polynomial features\n- How to do correctly cross-validate the model\n- How to plot the roc curve, which defines the auc score\n\nRelease notes:\n- V2: better feature engineering, roc curve plot\n- V3: feature engineering\n- V4: IterativeImputer"}}