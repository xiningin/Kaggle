{"cell_type":{"fc5651d6":"code","cd16d89a":"code","bae13fec":"code","06f31ca0":"code","6e64309d":"code","6b3d7dd4":"code","09064741":"code","a15a1a82":"code","a945a5e0":"code","ec78d3d9":"code","a94e8bd1":"code","7fadcccb":"code","b833ecca":"code","0f2ced2d":"code","9def2a9d":"code","fc57cf9c":"code","548a136f":"code","21436050":"code","13e9e87d":"code","a4178ed8":"code","6bf9bb4f":"code","e8ed50ce":"code","66724f66":"code","d3841448":"code","89aff3e9":"code","d5cdc49d":"code","0a0dc6ce":"code","2387e784":"code","0a414548":"code","af0db4fb":"code","37801077":"code","4bb80f40":"code","212ae528":"code","ed0e0dbc":"code","57cd7632":"code","9fe7f966":"code","57c7e2a1":"code","f8f09325":"code","a1a34dad":"code","f97feb38":"code","db16656a":"code","3bba8582":"code","cd4fc94a":"code","cb7fe7d0":"code","00b79ccc":"code","7dc7a02c":"code","b3803ffa":"code","485818c1":"code","0a1adfba":"code","a85a4e8d":"code","04999da0":"code","30c66db9":"code","8798a36f":"code","3ac4792a":"code","a0729451":"code","e50030cd":"markdown","a5afe51a":"markdown","bb599f91":"markdown","cdf2df76":"markdown","c1248cd4":"markdown","9b324ccf":"markdown","3e7a93ae":"markdown","1e48cade":"markdown","a699c0eb":"markdown","5e6c6df3":"markdown","85a72ec9":"markdown","e8cd66f2":"markdown","3af33287":"markdown","d5918a6f":"markdown","aaec389f":"markdown","7a0965bc":"markdown","7a78a00c":"markdown","963823b1":"markdown","2b2bfa77":"markdown","4b4b98e5":"markdown","ce866bb6":"markdown","987445ac":"markdown","3e12195e":"markdown","4d93f2f6":"markdown","a8a3c37f":"markdown","549d4a92":"markdown"},"source":{"fc5651d6":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom sklearn.svm import LinearSVC, SVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom catboost import CatBoostClassifier\n\nfrom sklearn.metrics import confusion_matrix, plot_confusion_matrix\nfrom sklearn.model_selection import train_test_split\n\nfrom numpy import hstack\nfrom sklearn.datasets import make_classification\n# from sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\n# from sklearn.svm import SVC\nfrom sklearn.naive_bayes import GaussianNB\n\nfrom sklearn import linear_model\nfrom sklearn.linear_model import SGDClassifier\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","cd16d89a":"train_data = pd.read_csv(\"\/kaggle\/input\/mymusicalprefrences\/train.csv\").set_index(\"Id\", drop=True)\ntest_data = pd.read_csv(\"\/kaggle\/input\/mymusicalprefrences\/test.csv\")\n\ndf_train = train_data.copy(deep=True) # before df\ndf_test = pd.read_csv(\"\/kaggle\/input\/mymusicalprefrences\/test.csv\").set_index(\"Id\", drop=True)\n\ndf = pd.concat([df_train, df_test], axis=0)\n\ntrain_data.head(5)","bae13fec":"# df = train_data.copy(deep=True)\n\nfeature = \"Artists\"\n# df[feature] = df[feature].replace(np.nan,\"N\/A\")\n# print(set(df[feature].values))\ndd = df[feature].value_counts(dropna=False)\n# print(dd[dd > 2])\n# df[feature].value_counts(normalize=True) * 100 # percentage of values in column\nprint(dd)","06f31ca0":"def many_to_several(feature, min_percent):\n    # create dict from all df\n    genres_dict = {}\n    for obj in df[feature]:\n        genres = [\"other\"]\n        if '|' in obj:\n            genres = obj.split(\"|\")\n        else:\n            genres[0] = obj\n        for genre in genres:\n            genre = special_for_labels(genre, feature)\n            genres_dict[genre] = genres_dict.setdefault(genre, 0) + 1\n\n    # write percent instead amount\n    all_gen = 0\n    for key,value in genres_dict.items():\n        all_gen = all_gen + value\n    for key,value in genres_dict.items():\n        genres_dict[key] = (value\/all_gen)*100.0\n        \n\n    # print all keys and values\n#     for key,value in dict(sorted(genres_dict.items(), key=lambda item: item[1])).items():\n#         print(key + \": \" + \"\\t\" + str(value))\n    \n    \n    genres_mas = []\n    for key,value in genres_dict.items():\n        if value > min_percent:\n            genres_mas.append(key)\n            \n    # print list before checking train and test df    \n#     print(genres_mas)\n#     print(\"\\n\")\n    \n    genres_dict_tr = {}\n    for obj in df_train[feature]:\n        genres = [\"other\"]\n        if '|' in obj:\n            genres = obj.split(\"|\")\n        else:\n            genres[0] = obj\n        for genre in genres:\n            genre = special_for_labels(genre, feature)\n            genres_dict_tr[genre] = genres_dict_tr.setdefault(genre, 0) + 1\n\n    genres_mas_tr = []        \n    for key,value in genres_dict_tr.items():\n            genres_mas_tr.append(key)\n\n    genres_dict_ts = {}\n    for obj in df_test[feature]:\n        genres = [\"other\"]\n        if '|' in obj:\n            genres = obj.split(\"|\")\n        else:\n            genres[0] = obj\n        for genre in genres:\n            genre = special_for_labels(genre, feature)\n            genres_dict_ts[genre] = genres_dict_ts.setdefault(genre, 0) + 1\n\n    genres_mas_ts = []\n    for key,value in genres_dict_ts.items():\n            genres_mas_ts.append(key)\n\n\n    for genre in genres_mas:\n        if genre not in genres_mas_tr or genre not in genres_mas_ts:\n            genres_mas.pop(genres_mas.index(genre))\n\n#     print(genres_mas)\n    \n    return genres_mas","6e64309d":"def special_for_labels(genre, feature):\n    if \" \" in genre and feature == \"Labels\":\n        genre = genre.split(\" \")\n        if genre[0] == \"The\":\n            genre = genre[0] + \" \" + genre[1]\n        elif genre[0] == \"A\":\n            genre = genre[1]\n        else:\n            genre = genre[0]\n    return genre","6b3d7dd4":"feature = \"Artists_Genres\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\n\ngenres_mas = many_to_several(\"Artists_Genres\", 4.9)","09064741":"feature = \"Labels\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\n\nlabel_mas = many_to_several(\"Labels\", 1)\n# label_mas = many_to_several(\"Labels\", 0.5)","a15a1a82":"feature = \"Artists\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\n\nartists_mas = many_to_several(\"Artists\", 1.4)","a945a5e0":"feature = \"Album\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\n\nalbum_mas = many_to_several(\"Album\", 0.8)","ec78d3d9":"df.rename(columns = {'Vocal ' : 'Vocal'}, inplace = True)\ndf_train.rename(columns = {'Vocal ' : 'Vocal'}, inplace = True)\ndf_test.rename(columns = {'Vocal ' : 'Vocal'}, inplace = True)\n\nfeature = \"Vocal\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\n\n# vocal_mas = many_to_several(\"Vocal\", 1)","a94e8bd1":"def modif_column_string(feature, lfun):#, df_train, df_test):\n    df_train[feature] = df_train[feature].replace(np.nan,\"other\")\n    df_train[feature] = df_train[feature].map(lambda obj: lfun(obj))\n    df_test[feature] = df_test[feature].replace(np.nan,\"other\")\n    df_test[feature] = df_test[feature].map(lambda obj: lfun(obj))","7fadcccb":"def modif_column_float(feature, lfun):#, df_train, df_test):\n    new_feature = feature + \"_Classes\"\n    \n    df_train[new_feature] = df_train[feature].replace(np.nan, df[feature].mean())\n    df_train[new_feature] = df_train[new_feature].map(lambda obj: lfun(obj))\n    df_test[new_feature] = df_test[feature].replace(np.nan, df[feature].mean())\n    df_test[new_feature] = df_test[new_feature].map(lambda obj: lfun(obj))","b833ecca":"def ret_bounds(value, bounds_l, bounds_r, parts, rets):\n    for part in range(0, len(parts), 1):\n        patch = (bounds_r[part] - bounds_l[part])\/parts[part]\n        for i in range(0, parts[part], 1):\n            if value > bounds_l[part] and value <= bounds_l[part]+patch:\n                return rets[part] + \"_\" + str(i)\n            else:\n                bounds_l[part] = bounds_l[part] + patch\n    return \"other\"","0f2ced2d":"def happiness_to_classes(num):\n    bounds_l = [0.0, 100\/3, 200\/3]\n    bounds_r = [100\/3, 200\/3, 100]\n    parts = [1,2,1]\n#     bounds_l = [0.0, 100\/3, 200\/3]\n#     bounds_r = [100\/3, 200\/3, 100]\n#     parts = [3,5,3]\n    rets = [\"bad\",\"so_so\",\"good\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","9def2a9d":"modif_column_float(feature=\"Happiness\", lfun=happiness_to_classes)\ndf_test[\"Happiness_Classes\"].value_counts()","fc57cf9c":"def dancebility_to_classes(num):\n#     bounds_l = [0.0, 40.0, 61.47, 72.4, 81.6]\n#     bounds_r = [40.0, 61.47, 72.4, 81.6, 100]\n#     parts = [1,3,3,2,1]\n    bounds_l = [0.0, 40.0, 61.47, 72.4, 81.6]\n    bounds_r = [40.0, 61.47, 72.4, 81.6, 100]\n    parts = [1,2,2,2,1]\n    rets = [\"pancake\",\"wormy\",\"slicy\",\"wiggly\",\"dance_revolution\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","548a136f":"modif_column_float(feature=\"Dancebility\", lfun=dancebility_to_classes)\ndf_train[\"Dancebility_Classes\"].value_counts(normalize=True) * 100","21436050":"def energy_to_classes(num):\n    if num <= 40.0:\n        return \"1\"\n    elif num > 40.0 and num <= 60.0:\n        return \"2\"\n    elif num > 60.0 and num <= 80.0:\n        return \"3\"\n    elif num > 80.0:\n        return \"4\"\n#     bounds_l = [0.0, 61.47, 81.6]\n#     bounds_r = [61.47, 81.6, 100]\n#     parts = [1,2,1]\n#     rets = [\"1\",\"2\",\"3\",\"4\"]\n#     return ret_bounds(num, bounds_l, bounds_r, parts, rets)","13e9e87d":"modif_column_float(feature=\"Energy\", lfun=energy_to_classes)\ndf_train[\"Energy_Classes\"].value_counts(normalize=True) * 100","a4178ed8":"def country_diffraction(obj):\n    countries = [\"other\"]\n    if '|' in obj:\n        countries = obj.split(\"|\")\n    else:\n        countries[0] = obj\n        \n    for country in countries:\n        if country == \"USA\" or country == \"RUS\" or country == \"GB\":\n            return country\n    return \"other\"","6bf9bb4f":"modif_column_string(feature=\"Country\", lfun=country_diffraction)\ndf_test[\"Country\"].value_counts()","e8ed50ce":"def key_diffraction(obj):\n    return obj[0]","66724f66":"modif_column_string(feature=\"Key\", lfun=key_diffraction)\ndf_test[\"Key\"].value_counts()","d3841448":"def artists_genres_diffraction(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n    \n    temp = 0\n    final_genre = \"\"\n    for ar_ge in artists_genres_split:\n        if ar_ge in genres_mas:\n            return ar_ge\n            \n    if final_genre == \"\":\n        return \"other\"\n    else:\n        return final_genre\n\n#     labels_mas_1 = many_to_several(\"Artists_Genres\", 1.2)\n#     labels_mas_2 = many_to_several(\"Artists_Genres\", 0.6)\n#     labels_mas_2 = labels_mas_2[len(labels_mas_1)-1:]\n#     labels_mas_3 = many_to_several(\"Artists_Genres\", 0.3)\n#     labels_mas_3 = labels_mas_3[len(labels_mas_1)+len(labels_mas_2)-1:]\n    \n#     for ar_ge in artists_genres_split:\n#         if ar_ge in labels_mas_1:\n#             return \"1\"\n#         if ar_ge in labels_mas_2:\n#             return \"2\"\n#         if ar_ge in labels_mas_3:\n#             return \"3\"\n            \n#     return \"4\"","89aff3e9":"# df_art = pd.concat([df, df_test], axis=0)\n\n# genres_dict = {}\n# for obj in df_art[\"Artists_Genres\"]:\n#     genres = [\"other\"]\n#     if '|' in obj:\n#         genres = obj.split(\"|\")\n#     else:\n#         genres[0] = obj\n#     for genre in genres:\n#         genres_dict[genre] = genres_dict.setdefault(genre, 0) + 1\n        \n# gd_tr = {}\n# for obj in df[\"Artists_Genres\"]:\n#     genres = [\"other\"]\n#     if '|' in obj:\n#         genres = obj.split(\"|\")\n#     else:\n#         genres[0] = obj\n#     for genre in genres:\n#         gd_tr[genre] = gd_tr.setdefault(genre, 0) + 1\n        \n# gd_ts = {}\n# for obj in df_test[\"Artists_Genres\"]:\n#     genres = [\"other\"]\n#     if '|' in obj:\n#         genres = obj.split(\"|\")\n#     else:\n#         genres[0] = obj\n#     for genre in genres:\n#         gd_ts[genre] = gd_ts.setdefault(genre, 0) + 1","d5cdc49d":"# items = []\n# for key,value in genres_dict.items():\n#     if value < 30 or ((key not in gd_tr.keys()) or (key not in gd_ts.keys())):\n#         items.append(key)\n        \n# for item in items:\n#     genres_dict.pop(item)\n#     genres_dict[\"other\"] = genres_dict.setdefault(\"other\", 0) + 0\n    \n# print(genres_dict)","0a0dc6ce":"modif_column_string(feature=\"Artists_Genres\", lfun=artists_genres_diffraction)\ndf_train[\"Artists_Genres\"].value_counts()","2387e784":"df_test[\"Artists_Genres\"].value_counts()","0a414548":"def year_to_classes(num):\n    if num <= 2005.0:\n        return \"old\"\n    elif num > 2005.0 and num <= 2009.0:\n        return \"old_middle\"\n    elif num > 2009.0 and num <= 2013.0:\n        return \"old_middle\"\n    elif num > 2013.0 and num <= 2015.0:\n        return \"new_1\"\n    elif num > 2015.0 and num <= 2017.0:\n        return \"new_2\"\n    elif num > 2017.0 and num <= 2019.0:\n        return \"new_3\"\n    elif num > 2019.0:\n        return \"new_4\"","af0db4fb":"modif_column_float(feature=\"Release_year\", lfun=year_to_classes)\ndf_test[\"Release_year_Classes\"].value_counts(normalize=True) * 100","37801077":"def duration_to_classes(num):\n    bounds_l = [100000.0, 170000.0, 240000.0, 300000.0, 350000.0]\n    bounds_r = [170000.0, 240000.0, 300000.0, 350000.0, 1000000.0]\n    parts = [1,4,3,1,1]\n    rets = [\"low\",\"not_so_low\",\"middle\",\"not_so_high\",\"high\"]\n##     bounds_l = [100000.0, 170000.0, 240000.0, 300000.0]\n##     bounds_r = [170000.0, 240000.0, 300000.0, 1000000.0]\n##     parts = [1,4,3,1]\n##     rets = [\"low\",\"not_so_low\",\"middle\",\"high\"]\n#     bounds_l = [100000.0, 170000.0, 240000.0, 300000.0, 350000.0]\n#     bounds_r = [170000.0, 240000.0, 300000.0, 350000.0, 750000.0]\n#     parts = [2,4,4,3,1]\n#     rets = [\"low\",\"not_so_low\",\"middle\",\"not_so_high\",\"high\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","4bb80f40":"modif_column_float(feature=\"Duration\", lfun=duration_to_classes)\ndf_test[\"Duration_Classes\"].value_counts(normalize=True) * 100","212ae528":"def bpm_to_classes(num):\n    bounds_l = [0.0, 100.0, 125.2]\n    bounds_r = [100.0, 125.2, 200.0]\n    parts = [1,2,2]\n    rets = [\"low\",\"middle\",\"high\"]\n#     bounds_l = [0.0, 75.0, 100.0, 125.2, 143.95, 158.0]\n#     bounds_r = [75.0, 100.0, 125.2, 143.95, 158.0, 200.0]\n#     parts = [1,3,3,2,1,1]\n#     rets = [\"low\", \"not_low\",\"middle\", \"not_high\", \"nnh\",\"high\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","ed0e0dbc":"modif_column_float(feature=\"BPM\", lfun=bpm_to_classes)\ndf_test[\"BPM_Classes\"].value_counts()","57cd7632":"def labels_to_classes(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n        \n    labels_mas_1 = many_to_several(\"Labels\", 1.5)\n    labels_mas_2 = many_to_several(\"Labels\", 1)\n    labels_mas_2 = labels_mas_2[len(labels_mas_1)-1:]\n    labels_mas_3 = many_to_several(\"Labels\", 0.7)\n    labels_mas_3 = labels_mas_3[len(labels_mas_1)+len(labels_mas_2)-1:]\n\n#     labels_mas_1 = many_to_several(\"Labels\", 2)\n#     labels_mas_2 = many_to_several(\"Labels\", 1.5)\n#     labels_mas_2 = labels_mas_2[len(labels_mas_1)-1:]\n#     labels_mas_3 = many_to_several(\"Labels\", 1)\n#     labels_mas_3 = labels_mas_3[len(labels_mas_1)+len(labels_mas_2)-1:]\n    \n#     res = \"\"\n#     for ar_ge in artists_genres_split:\n#         if ar_ge in labels_mas_3:\n#             if (ar_ge in labels_mas_2) and (ar_ge not in labels_mas_3):\n#                 if (ar_ge in labels_mas_1) and (ar_ge not in labels_mas_3) and (ar_ge not in labels_mas_2):\n#                     res = \"1\"\n#                 else:\n#                     res = \"2\"\n#             else:\n#                 res = \"3\"\n#         else:\n#             res =\"4\"\n    for ar_ge in artists_genres_split:\n        if ar_ge in labels_mas_1:\n            return \"1\"\n        if ar_ge in labels_mas_2:\n            return \"2\"\n        if ar_ge in labels_mas_3:\n            return \"3\"\n            \n    return \"4\"\n#     return res","9fe7f966":"modif_column_string(feature=\"Labels\", lfun=labels_to_classes)\ndf_test[\"Labels\"].value_counts()","57c7e2a1":"def artists_to_classes(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n    \n#     temp = 0\n#     final_genre = \"\"\n#     for ar_ge in artists_genres_split:\n#         if ar_ge in artists_mas:\n#             return ar_ge\n            \n#     if final_genre == \"\":\n#         return \"other\"\n#     else:\n#         return final_genre\n\n    labels_mas_1 = many_to_several(\"Artists\", 1.4)\n    labels_mas_2 = many_to_several(\"Artists\", 1)\n    labels_mas_2 = labels_mas_2[len(labels_mas_1)-1:]\n    labels_mas_3 = many_to_several(\"Artists\", 0.7)\n    labels_mas_3 = labels_mas_3[len(labels_mas_1)+len(labels_mas_2)-1:]\n    \n    for ar_ge in artists_genres_split:\n        if ar_ge in labels_mas_1:\n            return \"1\"\n        if ar_ge in labels_mas_2:\n            return \"2\"\n        if ar_ge in labels_mas_3:\n            return \"3\"\n   \n    return \"4\"","f8f09325":"modif_column_string(feature=\"Artists\", lfun=artists_to_classes)\ndf_test[\"Artists\"].value_counts()","a1a34dad":"def album_to_classes(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n        \n    labels_mas_1 = many_to_several(\"Album\", 0.7)\n    labels_mas_2 = many_to_several(\"Album\", 0.5)\n    labels_mas_2 = labels_mas_2[len(labels_mas_1)-1:]\n    labels_mas_3 = many_to_several(\"Album\", 0.3)\n    labels_mas_3 = labels_mas_3[len(labels_mas_1)+len(labels_mas_2)-1:]\n    \n    for ar_ge in artists_genres_split:\n        if ar_ge in labels_mas_1:\n            return \"1\"\n        if ar_ge in labels_mas_2:\n            return \"2\"\n        if ar_ge in labels_mas_3:\n            return \"3\"\n        \n#     for ar_ge in artists_genres_split:\n#         if ar_ge in album_mas:\n#             return ar_ge     \n    return \"4\"","f97feb38":"modif_column_string(feature=\"Album\", lfun=album_to_classes)\ndf_test[\"Album\"].value_counts()","db16656a":"def vocal_to_classes(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n        \n    for ar_ge in artists_genres_split:\n        if ar_ge == \"N\/A\" or ar_ge == \"N\":\n            ar_ge = \"M\"\n        return ar_ge     \n    return \"M\"","3bba8582":"modif_column_string(feature=\"Vocal\", lfun=vocal_to_classes)\ndf_test[\"Vocal\"].value_counts()","cd4fc94a":"df_train[\"Vocal\"].value_counts()","cb7fe7d0":"# Agreed features\n\nfeatures = [\n            \"Happiness_Classes\",\n            \"Dancebility_Classes\",\n            \"Energy_Classes\",\n            \"Country\",\n            \"Key\",\n            \"Artists_Genres\",\n            \"Release_year_Classes\",\n            \"Duration_Classes\",\n            \"BPM_Classes\",\n            \"Labels\",\n            \"Artists\",\n#             \"Version\",\n            \"Album\",\n#             \"Vocal\"\n           ]\n\n# Accuracy is dropping if we use Labels, Artists, Version, Album","00b79ccc":"y = df_train[\"Category\"]\n\nX = pd.get_dummies(df_train[features])\nX_test_compet = pd.get_dummies(df_test[features])","7dc7a02c":"df_test.columns","b3803ffa":"def get_models():\n    models = list()\n#     models.append(('lr', LogisticRegression()))\n#     models.append(('knn', KNeighborsClassifier()))\n#     models.append(('cart', DecisionTreeClassifier()))\n    models.append(('svm', SVC(probability=True,class_weight='balanced')))\n    models.append(('rfc', RandomForestClassifier(n_estimators=100, max_depth=10, random_state=1)))\n    models.append(('cart', linear_model.Lasso(alpha=0.1)))\n    models.append(('sgd', SGDClassifier(loss=\"hinge\", penalty=\"l2\", max_iter=1000)))\n#     models.append(('bayes', GaussianNB()))\n    return models","485818c1":"# fit the blending ensemble\ndef fit_ensemble(models, X_train, X_val, y_train, y_val):\n    # fit all models on the training set and predict on hold out set\n    meta_X = list()\n    for name, model in models:\n        model.fit(X_train, y_train)\n        yhat = model.predict(X_val)\n        yhat = yhat.reshape(len(yhat), 1)\n#         yhat = model.predict_proba(X_val)\n        meta_X.append(yhat)\n    # create 2d array from predictions, each set is an input feature\n    meta_X = hstack(meta_X)\n    # define blending model\n    blender = LogisticRegression()\n    # fit on predictions from base models\n    blender.fit(meta_X, y_val)\n    return blender","0a1adfba":"# make a prediction with the blending ensemble\ndef predict_ensemble(models, blender, X_test):\n    # make predictions with base models\n    meta_X = list()\n    for name, model in models:\n        yhat = model.predict(X_test)\n        yhat = yhat.reshape(len(yhat), 1)\n#         yhat = model.predict_proba(X_test)\n        meta_X.append(yhat)\n    # create 2d array from predictions, each set is an input feature\n    meta_X = hstack(meta_X)\n    # predict\n    return blender.predict(meta_X)","a85a4e8d":"X_train_full, X_test, y_train_full, y_test = train_test_split(X, y, test_size=0.5, random_state=1)\n# split training set into train and validation sets\nX_train, X_val, y_train, y_val = train_test_split(X_train_full, y_train_full, test_size=0.33, random_state=1)\n# summarize data split\n# print('Train: %s, Val: %s, Test: %s' % (X_train.shape, X_val.shape, X_test.shape))\n# create the base models\nmodels = get_models()\n# train the blending ensemble\nblender = fit_ensemble(models, X_train, X_val, y_train, y_val)\n# make predictions on test set\nyhat = predict_ensemble(models, blender, X_test)\nscore = accuracy_score(y_test, yhat)\nprint('Blending Accuracy: %.3f' % score)","04999da0":"model = RandomForestClassifier(n_estimators=100, max_depth=10, random_state=1)\n# model = RandomForestClassifier(n_estimators=600, max_depth=120, random_state=0)\n# model = SVC()\n# model = CatBoostClassifier()\n\n# model.fit(X, y)\n# predictions = model.predict(X_test)\n\npredictions =  predict_ensemble(models, blender, X_test_compet)\n\noutput = pd.DataFrame({'Id': test_data.Id, 'Category': predictions})\noutput.to_csv('submission.csv', index=False)","30c66db9":"X_train, Xtest, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=0)","8798a36f":"model.fit(X_train, y_train)\npredictions = model.predict(Xtest)\n\nCM = confusion_matrix(y_test,predictions)\nCM","3ac4792a":"plot_confusion_matrix(model, Xtest, y_test)","a0729451":"ACC = (CM[0][0]+CM[1][1])\/((CM[0][0]+CM[0][1])+(CM[1][0]+CM[1][1]))\nACC","e50030cd":"# **Some preparation for columns transmutation**\n---","a5afe51a":"For the each one feature we create function to transform to value we need","bb599f91":"# **DataFrame creation**","cdf2df76":"## 7 - Release year","c1248cd4":"Next method is needed for getting name of part which **float value** is locate by lists of left and right bounds, number of parts for every pair of bounds and whats for return for each part","9b324ccf":"Some methods, which we use to transmutate colums to use at model fitting.","3e7a93ae":"## 3 - Energy","1e48cade":"To check results we construct confusion matrix","a699c0eb":"## 5 - Key","5e6c6df3":"## 2 - Dancebility","85a72ec9":"## 8 - Duration","e8cd66f2":"# **Model**","3af33287":"---","d5918a6f":"## 4 - Country","aaec389f":"Final stage: fit model with features we created","7a0965bc":"## 1 - Happiness","7a78a00c":"## 6 - Artists Genres","963823b1":"Now we transmutate data with *many_to_several* function from \"Artists_Genres\", \"Labels\", \"Artists\" and \"Album\" to get lists of words that can be that columns.","2b2bfa77":"# Work with some string data\n---","4b4b98e5":"For processing string values to get only several features for class we use *many_to_several* function which take values separeted by \"|\" (and whitespace for column \"Labels\") and return list of that values which amount more than our value. Also in that function values are checked to be at test dataframe and train dataframe at the same time.","ce866bb6":"# **Start**\n---\nLet's create some dataframes to work:\n* df_train - dataframe for training\n* df_test - dataframe for testing\n* df - dataframe that combines df_train and df_test","987445ac":"## 12 - Album","3e12195e":"## 9 - BMP","4d93f2f6":"Also we calculate **accuracy**","a8a3c37f":"## 11 - Artists","549d4a92":"## 10 - Labels"}}