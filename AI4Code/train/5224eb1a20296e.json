{"cell_type":{"f7ce6b86":"code","57ebe7d5":"code","e895cebc":"code","2a81ae06":"code","e58e570c":"code","fd7568ba":"code","a2e37bf4":"code","88907c12":"code","6c24299f":"code","c57b5944":"code","ba0f96fa":"code","91c5fd9d":"code","e9e74816":"code","80643a12":"code","090bd9fb":"code","4886c305":"code","39d9a1a8":"code","b847a7c4":"code","fbb2ea51":"code","f80905a6":"code","71b1ae2d":"code","edc39224":"code","af19a9b2":"code","1aa5e93d":"code","21ea56c6":"code","aca99bce":"code","1bcfc185":"code","b4a2fa0f":"code","5d9de9cb":"code","c819958e":"code","e43f5970":"code","359379a9":"code","b3d36e7c":"code","5bd4dd43":"code","88e85da7":"code","8c29e827":"code","84c074cf":"code","7a5bf19b":"code","1388f5eb":"code","98575832":"code","5abb4871":"code","b0ed3c48":"markdown","399c86ee":"markdown","ddeb683b":"markdown","f7964621":"markdown","958b99b6":"markdown","3a0cd421":"markdown","ce7b1750":"markdown"},"source":{"f7ce6b86":"import numpy as np\nimport pandas as pd","57ebe7d5":"data = pd.read_csv(\"..\/input\/ipl-ball-by-ball-data\/all_matches.csv\")","e895cebc":"data.head().T","2a81ae06":"data.shape\n ","e58e570c":"data.season.unique()","fd7568ba":"data.season.replace({'2007\/08':'2008' , '2009\/10':'2010', '2020\/21':'2020'}, inplace = True)","a2e37bf4":"data.season = data.season.astype('str')  \n# some values in season column like 2012,2013,2014,2015 are of int type, converting them into string","88907c12":"data.fillna(0, inplace=True)       # Replacing missing values by 0 (wides, no balls etc)","6c24299f":"data = data.query('season != \"2021\"') # Discarding the matches of 2021 edition","c57b5944":"data.head().T","ba0f96fa":"unwanted_columns = [\"other_wicket_type\", \"other_player_dismissed\"]\ndata.drop(columns = unwanted_columns,inplace=True)","91c5fd9d":"data.head()","e9e74816":"players = pd.DataFrame(columns=[\"Name\", \"Team\"])","80643a12":"striker_battingteam = data.drop_duplicates(['striker', 'batting_team'])[[\"striker\",\"batting_team\"]]\nnonstriker_battingteam = data.drop_duplicates(['non_striker', 'batting_team'])[[\"non_striker\",\"batting_team\"]]\nbowler_bowlingteam = data.drop_duplicates(['bowler', 'bowling_team'])[['bowler', 'bowling_team']]","090bd9fb":"striker_battingteam.columns = [\"name\", \"team\"]\nstriker_battingteam","4886c305":"nonstriker_battingteam.columns = [\"name\", \"team\"]\nnonstriker_battingteam","39d9a1a8":"bowler_bowlingteam.columns = ['name', 'team']\nbowler_bowlingteam","b847a7c4":"players = pd.concat([striker_battingteam,nonstriker_battingteam,bowler_bowlingteam], axis=0).drop_duplicates()","fbb2ea51":"players.shape","f80905a6":"players[players['team']==\"Chennai Super Kings\"]","71b1ae2d":"players[players['name']==\"Yuvraj Singh\"]","edc39224":"grouped_data = data.set_index(['match_id','innings'])","af19a9b2":"grouped_data.head(5)","1aa5e93d":"def count_matches_seasons(p_name:str , t_name:str, grouped_data) -> int :\n    \n    \"\"\" Given the player name and team name, this function calculates the no. of matches\n        played and the seasons in which the player for that respective team\"\"\"\n    \n    temp1 = grouped_data.query(f'batting_team==\"{t_name}\"')\n    bat = temp1.query(f'striker==\"{p_name}\" or non_striker==\"{p_name}\"')\n    temp2 = grouped_data.query(f'bowling_team==\"{t_name}\"')\n    bowl = temp2.query(f'bowler==\"{p_name}\"')                           \n\n    temp = pd.concat([bat,bowl],axis=0).drop_duplicates()\n    \n    season = temp.season.unique()\n    \n    match_inn = temp.index.unique().to_list()\n\n    if 1 in np.unique(match_inn) and 2 in np.unique(match_inn):\n        n_matches = len(np.unique(match_inn)) - 2\n    elif 1 in np.unique(match_inn) and 2 not in np.unique(match_inn):\n         n_matches = len(np.unique(match_inn)) - 1\n    elif 2 in np.unique(match_inn) and 1 not in np.unique(match_inn):\n         n_matches = len(np.unique(match_inn)) - 1        \n    \n    return n_matches, season\n\n","21ea56c6":"def add_batting_stats(players: pd.DataFrame, grouped_data):\n    import warnings\n    warnings.filterwarnings('ignore')  # to ignore the warnings, if any\n    runs = []\n    highest_score = []\n    fifties = []\n    hundreds = []\n    balls = []\n    dismissals = []\n    notouts = []\n    average = []\n    strike_rate = []\n    matches = []\n    innings = []\n    fours = []\n    sixes = []\n    seasons = []\n    for p_name,t_name in zip(players.name.values, players.team.values):\n        \n            # Current player's batting data for current team \n            temp = grouped_data.query(f'striker==\"{p_name}\" and batting_team==\"{t_name}\"')  \n            \n            # his total runs\n            total  = temp[\"runs_off_bat\"].sum(axis=0)  \n            \n            #total balls faced\n            balls_played = temp.query('noballs==0 and wides==0').shape[0] \n            \n            # list of indices of all matches in which he batted\n            innings_played = np.array(temp.index.unique()) \n            \n             # no. of innings he played\n            n_innings = len(innings_played)\n            \n            # no. of times the player got out\n            outs = np.count_nonzero(temp[\"player_dismissed\"]==p_name) \n            \n            # no. of times player remained not out\n            not_outs = n_innings - outs  \n            \n            # Total matches played\n            n_matches, season = count_matches_seasons(p_name, t_name, grouped_data)\n            \n            inning_score = []  # list that contains each inning's score of batsman\n            for inn in innings_played:\n                score = temp.loc[inn,:].runs_off_bat.sum() # runs in a particular match\n                inning_score.append(score)\n            inning_score = np.array(inning_score) # converting to numpy array\n            \n            # counting no. of half centuries scored\n            fifty = np.count_nonzero(inning_score>=50) \n            \n            # counting no. of centuries scored\n            hundred = np.count_nonzero(inning_score>=100) \n            \n            fifty -= hundred # subtracting the intersection part of hundreds and fifties\n                             #  (100s should not be counted as half centuries as well as centuries)\n            \n            \n            # calculating career batting average of the player \n            try:\n                avg = total \/ outs \n            except:\n                avg = \"-\"\n            \n            # calculating career strike rate of the player\n            try:\n                rate = (total \/ balls_played) * 100  \n            except:\n                rate = 0.0\n            \n            # Finding Highest Score\n            try:\n                h_score = np.max(inning_score)\n            except:\n                h_score = 0\n            \n            # No. of fours    \n            try:\n                n_fours = np.count_nonzero(temp[\"runs_off_bat\"]==4)\n            except:\n                n_fours = 0\n            \n            # No. of sixes\n            try:\n                n_sixes = np.count_nonzero(temp[\"runs_off_bat\"]==6)\n            except:\n                n_sixes = 0\n                \n            matches.append(n_matches)\n            seasons.append(season)\n            innings.append(n_innings)\n            runs.append(total)\n            balls.append(balls_played)\n            highest_score.append(h_score) \n            fifties.append(fifty)\n            hundreds.append(hundred)\n            fours.append(n_fours)\n            sixes.append(n_sixes)\n            dismissals.append(outs)\n            average.append(avg)\n            strike_rate.append(rate)\n        \n    players[\"matches\"] = matches\n    players[\"seasons\"] = seasons\n    players[\"innings\"] = innings\n    players['runs'] = runs\n    players['balls'] = balls\n    players['highest score'] = highest_score\n    players['50s'] = fifties\n    players['100s'] = hundreds\n    players['4s'] = fours\n    players['6s'] = sixes\n    players['outs'] = dismissals\n    players['average'] = average\n    players['strike rate'] = strike_rate\n    players['not outs'] = players['innings'] - players['outs']\n    players.fillna(0,inplace=True)\n    return players\n","aca99bce":"players = add_batting_stats(players, grouped_data)","1bcfc185":"players.head(20)","b4a2fa0f":"players[players.name==\"V Kohli\"].seasons.values","5d9de9cb":"data.wicket_type.unique()","c819958e":"def add_bowling_stats(players: pd.DataFrame, grouped_data:pd.DataFrame)->pd.DataFrame:\n    \n    \"\"\" This fuctions takes two dataframes i.e the original grouped dataframe 'grouped_data' and \n         the customized one that needs to be updated 'players' \"\"\"\n    \n    import warnings\n    warnings.filterwarnings('ignore')\n    wickets = []\n    three_wicket = []\n    five_wicket = []\n    runs_conceeded = [] \n    overs = []\n    economy = []\n    b_average = []\n    best_figures = []\n    \n    # selecting only wicket deliveries\n    temp_1 = grouped_data.query('wicket_type != 0')\n    \n    # excluding wicket_types wherein the wicket credit do not goes to the bowler\n    temp_1 = temp_1.query('wicket_type != \"run out\" and wicket_type != \"obstructing the field\"')\n    \n    # Looping over player&team\n    for p_name,t_name in zip(players.name.values, players.team.values): \n        \n        # General query which selects all rows where bowler & bowling team matches are current pair\n        D = grouped_data.query(f'bowler==\"{p_name}\" and bowling_team==\"{t_name}\"')\n        \n        # query on temp1, d1 stores deliveries where wicket was credited to current player \n        #  while playing for current team.\n        d1 = temp_1.query(f'bowler==\"{p_name}\" and bowling_team==\"{t_name}\"') \n        \n        # query on D, d2 stores all legal deliveries bowled by current bowler while playing \n        # for current team\n        d2 = D.query('wides==0 and noballs==0') \n        \n        # Total no. of overs bowled by current player while playing for current team\n        n_overs =  (d2.shape[0] \/\/ 6) + ((d2.shape[0] % 6)\/10)  \n        \n        # Total no.s of wickets taken by current player while playing for current team\n        n_wickets = d1.shape[0]\n        \n        # k stores no. of wickets taken by in a particular match-inning by current bowler bowled while \n        # playing for current team\n        k = d1.index.value_counts().values\n        \n        # Total runs conceeded\n        conceeded = np.sum(D[\"runs_off_bat\"],axis=0) + np.sum(D[\"extras\"],axis=0)\n        \n        # Over-all economy or carrer economy of the current player while playing for current team\n        eco = np.round(conceeded \/ n_overs , 2)\n        \n        \n        # Calculating career bowling average of the current player while playing for current team\n        if n_wickets==0:\n            avg=0  # avoiding divide by zero\n        else:\n            avg = conceeded \/ n_wickets\n        \n        # indices of all matches-inning when the bowler bowled\n        innings = np.unique(d1.index)\n        \n        # initializing a list that will store the figures (wicket\/runs conceeded) for each mattch-inning\n        figures = []\n        \n        for inn in innings: # Looping over each match-inning\n            if isinstance(d1.loc[inn,:], pd.DataFrame):\n                inn_wk = d1.loc[inn,:].shape[0]\n            else:\n                inn_wk = 1     # if only one wicket is taken by bowler in current match-inn, the query \n                               # returns a Pd.Series and for that shape[0] will be no. of columns\n            \n            # runs conceeded in current innings\n            inn_run = np.sum(D.loc[inn,:][\"runs_off_bat\"],axis=0) + np.sum(D.loc[inn,:][\"extras\"],axis=0)\n            \n            #appending the figures if current inning in the main list we store figures for all innings\n            figures.append((inn_wk, inn_run))\n            figures.sort(key = lambda i:i[1])\n        # Selecting best figure from the 'figures' list i.e most wickets in a single match-innings\n        try:\n            best_fig = max(figures, key = lambda i : i[0])\n        except:\n            best_fig = 0\n            \n        overs.append(n_overs)\n        wickets.append(n_wickets)\n        runs_conceeded.append(conceeded)\n        b_average.append(avg)\n        economy.append(eco)\n        three_wicket.append(np.count_nonzero(k==3))\n        five_wicket.append(np.count_nonzero(k==5))\n        best_figures.append(best_fig)\n\n    players['Overs'] = overs\n    players['wickets'] = wickets    \n    players['run conceeded'] = runs_conceeded\n    players['bowling avg'] = b_average\n    players['economy'] = economy\n    players['3W'] = three_wicket\n    players['5W'] = five_wicket\n    players['best figure'] = best_figures\n    players.fillna(0,inplace=True)\n    return players","e43f5970":"players = add_bowling_stats(players, grouped_data)","359379a9":"players.query('name==\"RA Jadeja\"').T","b3d36e7c":"players.query(f'name==\"Yuvraj Singh\"').T","5bd4dd43":"cols = players.columns.values","88e85da7":"cols ","8c29e827":"cols = ['name', 'team', 'matches', 'seasons','innings', 'runs', 'balls',\n        '4s', '6s','50s', '100s','highest score', 'outs','not outs', 'average',\n       'strike rate',  'Overs', 'wickets', 'run conceeded',\n       'bowling avg', 'economy', '3W', '5W', 'best figure']","84c074cf":"players = players.reindex(cols, axis=1)\nplayers.rename(columns={'average':\"batting avg\", \"Overs\":\"Overs bowled\", \"innings\":\"bat innings\"}, inplace=True)","7a5bf19b":"players.head(10).T","1388f5eb":"players['bowling avg'].replace({np.inf:'--'}, inplace=True)","98575832":"players.head(10).T","5abb4871":"players.index = range(players.shape[0])\nplayers.head(10)","b0ed3c48":"#  Multi-indexing on match_id & innings","399c86ee":"# Organising Bowling Records","ddeb683b":" The 'players' dataframe is available as dataset in csv format as \"**IPL DATASET - Individual Player Records**\".\n\nLeverage it to boost your analytical skills by performing *Data Analysis* and drawing innovative insights from it.\nGood Luck, Happy Learning !","f7964621":"# Organizing Batting Records","958b99b6":"# ----------------------------------------","3a0cd421":"## WWoooaaahhhh, we have successfully derived a new dataset.\n","ce7b1750":"# creating 'players' dataset initially with name & team"}}