{"cell_type":{"c239a69a":"code","3983c297":"code","f0709ed2":"code","6631732b":"code","9afb0ee4":"code","32f1a6ef":"code","f78f6776":"code","a597a834":"code","edc6eb2d":"code","47247e16":"code","4d28212c":"code","6ee3175c":"code","2433c796":"code","5e657080":"code","0bf3d228":"code","899464e6":"code","bde660c5":"code","0eeeb668":"code","2f036046":"code","a39e204a":"code","49794377":"code","b28bd474":"markdown","b77ca7c5":"markdown","820c65d7":"markdown","32db1022":"markdown","5b006af9":"markdown","bca94f36":"markdown","d7380927":"markdown","73212c9d":"markdown","0eb54af4":"markdown","631d8df7":"markdown","75e1a3b7":"markdown","5dff6ba0":"markdown","19108e32":"markdown","88e763d8":"markdown"},"source":{"c239a69a":"%matplotlib inline\nfrom fastai.learner import *","3983c297":"# Here we generate some fake data\ndef lin(a,b,x): return a*x+b\n\ndef gen_fake_data(n, a, b):\n    x = s = np.random.uniform(0,1,n) \n    y = lin(a,b,x) + 0.1 * np.random.normal(0,3,n)\n    return x, y\n\nx, y = gen_fake_data(50, 3., 8.)","f0709ed2":"plt.scatter(x,y, s=8); plt.xlabel(\"x\"); plt.ylabel(\"y\"); ","6631732b":"def mse(y_hat, y): return ((y_hat - y) ** 2).mean()","9afb0ee4":"y_hat = lin(10,5,x)\nmse(y_hat, y)","32f1a6ef":"def mse_loss(a, b, x, y): return mse(lin(a,b,x), y)","f78f6776":"mse_loss(10, 5, x, y)","a597a834":"# generate some more data\nx, y = gen_fake_data(10000, 3., 8.)\nx.shape, y.shape","edc6eb2d":"x,y = V(x),V(y)","47247e16":"# Create random weights a and b, and wrap them in Variables.\na = V(np.random.randn(1), requires_grad=True)\nb = V(np.random.randn(1), requires_grad=True)\na,b","4d28212c":"learning_rate = 1e-3\nfor t in range(10000):\n    # Forward pass: compute predicted y using operations on Variables\n    loss = mse_loss(a,b,x,y)\n    if t % 1000 == 0: print(loss.data[0])\n    \n    # Computes the gradient of loss with respect to all Variables with requires_grad=True.\n    # After this call a.grad and b.grad will be Variables holding the gradient\n    # of the loss with respect to a and b respectively\n    loss.backward()\n    \n    # Update a and b using gradient descent; a.data and b.data are Tensors,\n    # a.grad and b.grad are Variables and a.grad.data and b.grad.data are Tensors\n    a.data -= learning_rate * a.grad.data\n    b.data -= learning_rate * b.grad.data\n    \n    # Zero the gradients\n    a.grad.data.zero_()\n    b.grad.data.zero_()    ","6ee3175c":"def gen_fake_data2(n, a, b):\n    x = s = np.random.uniform(0,1,n) \n    y = lin(a,b,x) + 0.1 * np.random.normal(0,3,n)\n    return x, np.where(y>10, 1, 0).astype(np.float32)","2433c796":"x,y = gen_fake_data2(10000, 3., 8.)\nx,y = V(x),V(y)","5e657080":"def nll(y_hat, y):\n    y_hat = torch.clamp(y_hat, 1e-5, 1-1e-5)\n    return (y*y_hat.log() + (1-y)*(1-y_hat).log()).mean()","0bf3d228":"a = V(np.random.randn(1), requires_grad=True)\nb = V(np.random.randn(1), requires_grad=True)","899464e6":"learning_rate = 1e-2\nfor t in range(3000):\n    p = (-lin(a,b,x)).exp()\n    y_hat = 1\/(1+p)\n    loss = nll(y_hat,y)\n    if t % 1000 == 0:\n        print(loss.data[0], np.mean(to_np(y)==(to_np(y_hat)>0.5)))\n#         print(y_hat)\n    \n    loss.backward()\n    a.data -= learning_rate * a.grad.data\n    b.data -= learning_rate * b.grad.data\n    a.grad.data.zero_()\n    b.grad.data.zero_()    ","bde660c5":"from matplotlib import rcParams, animation, rc\nfrom ipywidgets import interact, interactive, fixed\nfrom ipywidgets.widgets import *\nrc('animation', html='jshtml')\nrcParams['figure.figsize'] = 3, 3\nrcParams['animation.writer'] = 'html'","0eeeb668":"x, y = gen_fake_data(50, 3., 8.)","2f036046":"a_guess,b_guess = -1., 1.\nmse_loss(a_guess, b_guess, x, y)","a39e204a":"lr=0.01\ndef upd():\n    global a_guess, b_guess\n    y_pred = lin(a_guess, b_guess, x)\n    dydb = 2 * (y_pred - y)\n    dyda = x*dydb\n    a_guess -= lr*dyda.mean()\n    b_guess -= lr*dydb.mean()","49794377":"fig = plt.figure(dpi=100, figsize=(5, 4))\nplt.scatter(x,y)\nline, = plt.plot(x,lin(a_guess,b_guess,x))\nplt.close()\n\ndef animate(i):\n    line.set_ydata(lin(a_guess,b_guess,x))\n    for i in range(30): upd()\n    return line,\n\nani = animation.FuncAnimation(fig, animate, np.arange(0, 20), interval=100)\nani","b28bd474":"You want to find **parameters** (weights) $a$ and $b$ such that you minimize the *error* between the points and the line $a\\cdot x + b$. Note that here $a$ and $b$ are unknown. For a regression problem the most common *error function* or *loss function* is the **mean squared error**. ","b77ca7c5":"So far we have specified the *model* (linear regression) and the *evaluation criteria* (or *loss function*). Now we need to handle *optimization*; that is, how do we find the best values for $a$ and $b$? How do we find the best *fitting* linear regression.","820c65d7":"Suppose we believe $a = 10$ and $b = 5$ then we can compute `y_hat` which is our *prediction* and then compute our error.","32db1022":"For a fixed dataset $x$ and $y$ `mse_loss(a,b)` is a function of $a$ and $b$. We would like to find the values of $a$ and $b$ that minimize that function.\n\n**Gradient descent** is an algorithm that minimizes functions. Given a function defined by a set of parameters, gradient descent starts with an initial set of parameter values and iteratively moves toward a set of parameter values that minimize the function. This iterative minimization is achieved by taking steps in the negative direction of the function gradient.\n\nHere is gradient descent implemented in [PyTorch](http:\/\/pytorch.org\/).","5b006af9":"# Gradient Descent","bca94f36":"# Gradient Descent - Classification","d7380927":"Nearly all of deep learning is powered by one very important algorithm: **stochastic gradient descent (SGD)**. SGD can be seeing as an approximation of **gradient descent** (GD). In GD you have to run through *all* the samples in your training set to do a single itaration. In SGD you use *only one* or *a subset*  of training samples to do the update for a parameter in a particular iteration. The subset use in every iteration is called a **batch** or **minibatch**.","73212c9d":"The goal of linear regression is to fit a line to a set of points.","0eb54af4":"In this part of the lecture we explain Stochastic Gradient Descent (SGD) which is an **optimization** method commonly used in neural networks. We will illustrate the concepts with concrete examples.","631d8df7":"# Gradient descent with numpy","75e1a3b7":"For a fixed dataset $x$ and $y$ `mse_loss(a,b)` is a function of $a$ and $b$. We would like to find the values of $a$ and $b$ that minimize that function.\n\n**Gradient descent** is an algorithm that minimizes functions. Given a function defined by a set of parameters, gradient descent starts with an initial set of parameter values and iteratively moves toward a set of parameter values that minimize the function. This iterative minimization is achieved by taking steps in the negative direction of the function gradient.\n\nHere is gradient descent implemented in [PyTorch](http:\/\/pytorch.org\/).","5dff6ba0":"# Table of Contents\n <p><div class=\"lev1 toc-item\"><a href=\"#Linear-Regression-problem\" data-toc-modified-id=\"Linear-Regression-problem-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;<\/span>Linear Regression problem<\/a><\/div><div class=\"lev1 toc-item\"><a href=\"#Gradient-Descent\" data-toc-modified-id=\"Gradient-Descent-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;<\/span>Gradient Descent<\/a><\/div><div class=\"lev1 toc-item\"><a href=\"#Gradient-Descent---Classification\" data-toc-modified-id=\"Gradient-Descent---Classification-3\"><span class=\"toc-item-num\">3&nbsp;&nbsp;<\/span>Gradient Descent - Classification<\/a><\/div><div class=\"lev1 toc-item\"><a href=\"#Gradient-descent-with-numpy\" data-toc-modified-id=\"Gradient-descent-with-numpy-4\"><span class=\"toc-item-num\">4&nbsp;&nbsp;<\/span>Gradient descent with numpy<\/a><\/div>","19108e32":"#  Linear Regression problem","88e763d8":"Nearly all of deep learning is powered by one very important algorithm: **stochastic gradient descent (SGD)**. SGD can be seeing as an approximation of **gradient descent** (GD). In GD you have to run through *all* the samples in your training set to do a single itaration. In SGD you use *only one* or *a subset*  of training samples to do the update for a parameter in a particular iteration. The subset use in every iteration is called a **batch** or **minibatch**."}}