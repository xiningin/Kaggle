{"cell_type":{"4579c982":"code","b0bdc13b":"code","af1f1858":"code","ba75f565":"code","50ff4091":"code","602e16c8":"code","987395b5":"code","b37234af":"code","82ccc8ec":"code","3bbfe565":"code","a1cbfae9":"code","6b74ca17":"code","c78e2116":"code","6ed1af64":"code","7fcd169b":"code","d5e11a91":"code","81c6115d":"code","15cad2b6":"code","fceabc51":"code","5e27a23c":"code","cefc0fd0":"code","9ee9ac14":"code","3787dede":"code","bb365cfa":"code","db74f557":"code","73a41b1d":"code","a7713ed3":"code","6b7bb4cf":"code","641c9217":"code","e8bb847e":"code","23b6b766":"code","e528dea8":"code","2d136051":"code","e67b004f":"code","daa38366":"code","6c2aeaef":"code","374631db":"code","94197f42":"code","6e961d28":"code","d4f43d19":"code","537266a9":"code","32ac494a":"code","299dac49":"code","4e4a4f82":"code","5f1a1965":"code","2784061c":"markdown","e3ba4094":"markdown","1e70c463":"markdown","a3d381a2":"markdown","25a2a94f":"markdown","c79d680b":"markdown","efb77ed2":"markdown","1e369725":"markdown","24fbb7e0":"markdown","6bcd9948":"markdown","005981b2":"markdown"},"source":{"4579c982":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nimport re\nimport pickle\n\nfrom plotly.offline import init_notebook_mode, iplot\nimport plotly.graph_objs as go\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nplt.style.use('fivethirtyeight')\nplt.rcParams['figure.figsize'] = [18, 8]","b0bdc13b":"df = pd.read_csv('\/kaggle\/input\/womens-ecommerce-clothing-reviews\/Womens Clothing E-Commerce Reviews.csv')\ndf.drop('Unnamed: 0', axis=1, inplace=True)\ndf.drop_duplicates(inplace=True)\n\nprint(\"DataFrame shape:\", df.shape)","af1f1858":"df.head()","ba75f565":"print(\"Clothing ID nunique: {}\".format(df['Clothing ID'].nunique()))","50ff4091":"sns.distplot(df['Age']).set_title(\n                            'Age Distribution', fontsize=20, weight='bold');","602e16c8":"division_count = df['Division Name'].value_counts()\n\npie1 = go.Pie(labels=division_count.index,\n              values=division_count.values,\n              hole=0.5)\n\nlayout1 = go.Layout(title='Division Name', font=dict(size=18), legend=dict(orientation='h'))\n\nfig1 = go.Figure(data=[pie1], layout=layout1)\npy.iplot(fig1)","987395b5":"departement_count = df['Department Name'].value_counts()\n\nsns.barplot(x=departement_count.values,\n            y=departement_count.index,\n            palette='magma').set_title('Departemen Name', fontsize=20);","b37234af":"sns.heatmap(pd.crosstab(df['Class Name'], df['Division Name']),\n            annot=True, linewidths=.5, fmt='g', cmap='Reds',\n            cbar=False);","82ccc8ec":"splot1 = sns.countplot(df['Recommended IND'])\n\nfor p in splot1.patches:\n    splot1.annotate(format(p.get_height() \/ df.shape[0] * 100, '.1f'),\n                    (p.get_x() + p.get_width() \/ 2., p.get_height()),\n                    rotation=0, ha='center', va='bottom', xytext=(0, 10), textcoords='offset points')\n\nplt.xlabel(None)\nplt.title('Recommend or not? (in percentage)')\nplt.grid(False)\nplt.show()","3bbfe565":"rating_count = df.Rating.value_counts()\n\nsns.barplot(y=rating_count.values,\n            x=rating_count.index, palette='Set1').set_title('Rating', fontsize=20);","a1cbfae9":"rating_4_and_5 = round(df[(df['Rating'] == 5) | (df['Rating'] == 4)].shape[0] \/ df.shape[0] * 100, 2)\nrating_1_and_2 = round(df[(df['Rating'] == 1) | (df['Rating'] == 2)].shape[0] \/ df.shape[0] * 100, 2)\n\nprint(\"There are {}% users who give 4 or 5 stars rating\".format(rating_4_and_5))\nprint('')\nprint(\"There are {}% users who give 1 or 2 stars rating\".format(rating_1_and_2))","6b74ca17":"df[(df['Rating'] == 5) | (df['Rating'] == 4)]['Recommended IND'].value_counts()","c78e2116":"df[(df['Rating'] == 1) | (df['Rating'] == 2)]['Recommended IND'].value_counts()","6ed1af64":"departement_recommended = df.groupby('Department Name')['Recommended IND'].value_counts(normalize=True).rename('Percentage').mul(100).round(2).reset_index()\n\nsns.barplot(x='Department Name', y='Percentage', hue='Recommended IND', data=departement_recommended);","7fcd169b":"departement_ratings = df.groupby('Department Name')['Rating'].value_counts(normalize=True).rename('Rating Percentage').mul(100).round(2).reset_index()\n\nsns.barplot(x='Department Name', y='Rating Percentage', hue='Rating', data=departement_ratings, palette='Set1');","d5e11a91":"pd.set_option('max_colwidth', 300)\ndf.dropna(subset=['Review Text'], inplace=True)","81c6115d":"from nltk.sentiment.vader import SentimentIntensityAnalyzer\n\nsentiment_analyzer = SentimentIntensityAnalyzer()\n\ndf['Polarity Score'] = df['Review Text'].apply(lambda x: sentiment_analyzer.polarity_scores(x)['compound'])  # compound (aggregated score)","15cad2b6":"def sentiment_analyst(polarity_score):\n    if polarity_score >= 0.05:\n        return 'Positive'\n    elif polarity_score <= -0.05:\n        return 'Negative'\n    else:\n        return 'Neutral'\n\ndf['Sentiment'] = df['Polarity Score'].apply(sentiment_analyst)","fceabc51":"sentiment_recommended = df.groupby('Sentiment')['Recommended IND'].value_counts(normalize=True).rename('Recommend Percentage').mul(100).round(2).reset_index()\n\nsns.barplot(x='Sentiment', y='Recommend Percentage', hue='Recommended IND', data=sentiment_recommended);","5e27a23c":"df[(df['Sentiment'] == 'Negative') & (df['Recommended IND'] == 1)]['Rating'].value_counts()","cefc0fd0":"def clean_text(tweet):\n    tweet = tweet.lower()\n    tweet = re.sub(r'\\n', ' ', tweet)\n    tweet = re.sub(r'bc', 'because', tweet)\n    tweet = re.sub(r\"he's\", \"he is\", tweet)\n    tweet = re.sub(r\"there's\", \"there is\", tweet)\n    tweet = re.sub(r\"we're\", \"we are\", tweet)\n    tweet = re.sub(r\"that's\", \"that is\", tweet)\n    tweet = re.sub(r\"won't\", \"will not\", tweet)\n    tweet = re.sub(r\"they're\", \"they are\", tweet)\n    tweet = re.sub(r\"can't\", \"cannot\", tweet)\n    tweet = re.sub(r\"wasn't\", \"was not\", tweet)\n    tweet = re.sub(r\"aren't\", \"are not\", tweet)\n    tweet = re.sub(r\"isn't\", \"is not\", tweet)\n    tweet = re.sub(r\"what's\", \"what is\", tweet)\n    tweet = re.sub(r\"haven't\", \"have not\", tweet)\n    tweet = re.sub(r\"hasn't\", \"has not\", tweet)\n    tweet = re.sub(r\"there's\", \"there is\", tweet)\n    tweet = re.sub(r\"he's\", \"he is\", tweet)\n    tweet = re.sub(r\"it's\", \"it is\", tweet)\n    tweet = re.sub(r\"you're\", \"you are\", tweet)\n    tweet = re.sub(r\"i'm\", \"i am\", tweet)\n    tweet = re.sub(r\"shouldn't\", \"should not\", tweet)\n    tweet = re.sub(r\"wouldn't\", \"would not\", tweet)\n    tweet = re.sub(r\"isn't\", \"is not\", tweet)\n    tweet = re.sub(r\"here's\", \"here is\", tweet)\n    tweet = re.sub(r\"you've\", \"you have\", tweet)\n    tweet = re.sub(r\"we're\", \"we are\", tweet)\n    tweet = re.sub(r\"what's\", \"what is\", tweet)\n    tweet = re.sub(r\"couldn't\", \"could not\", tweet)\n    tweet = re.sub(r\"we've\", \"we have\", tweet)\n    tweet = re.sub(r\"who's\", \"who is\", tweet)\n    tweet = re.sub(r\"y'all\", \"you all\", tweet)\n    tweet = re.sub(r\"would've\", \"would have\", tweet)\n    tweet = re.sub(r\"it'll\", \"it will\", tweet)\n    tweet = re.sub(r\"we'll\", \"we will\", tweet)\n    tweet = re.sub(r\"we've\", \"we have\", tweet)\n    tweet = re.sub(r\"he'll\", \"he will\", tweet)\n    tweet = re.sub(r\"weren't\", \"were not\", tweet)\n    tweet = re.sub(r\"didn't\", \"did not\", tweet)\n    tweet = re.sub(r\"they'll\", \"they will\", tweet)\n    tweet = re.sub(r\"they'd\", \"they would\", tweet)\n    tweet = re.sub(r\"don't\", \"do not\", tweet)\n    tweet = re.sub(r\"they've\", \"they have\", tweet)\n    tweet = re.sub(r\"i'd\", \"i would\", tweet)\n    tweet = re.sub(r\"should've\", \"should have\", tweet)\n    tweet = re.sub(r\"where's\", \"where is\", tweet)\n    tweet = re.sub(r\"we'd\", \"we would\", tweet)\n    tweet = re.sub(r\"i'll\", \"i will\", tweet)\n    tweet = re.sub(r\"weren't\", \"were not\", tweet)\n    tweet = re.sub(r\"they're\", \"they are\", tweet)\n    tweet = re.sub(r\"let's\", \"let us\", tweet)\n    \n    tokenizer = tweet.split()\n    words = [word for word in tokenizer if word.isalpha()]\n    return ' '.join(words)\n\ndf['Review Text'] = df['Review Text'].apply(clean_text)","9ee9ac14":"import tensorflow as tf\nfrom tensorflow.keras.preprocessing.text import Tokenizer\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\n\nprint('Using Tensorflow version:', tf.__version__)","3787dede":"sns.distplot(df['Review Text'].apply(len));","bb365cfa":"print(\"Max Len:\", max(map(len, df['Review Text'])))\nprint(\"I'll use 200 for max padding length\")","db74f557":"tokenizer = Tokenizer()\ntokenizer.fit_on_texts(df['Review Text'])\n\nvocab_size = len(tokenizer.word_index)\nprint('Vocabulary size:', vocab_size)","73a41b1d":"sequences = tokenizer.texts_to_sequences(df['Review Text'])\npadded_seq = pad_sequences(sequences, maxlen=200, padding='post', truncating='post')","a7713ed3":"GLOVE_EMBEDDING_PATH = '\/kaggle\/input\/pickled-glove840b300d-for-10sec-loading\/glove.840B.300d.pkl'\n\ndef load_embeddings(path):\n    with open(path,'rb') as f:\n        emb_arr = pickle.load(f)\n    return emb_arr\n\ndef build_matrix(word_index, path):\n    embedding_index = load_embeddings(path)\n    embedding_matrix = np.zeros((len(word_index) + 1, 300))\n    unknown_words = []\n    \n    for word, i in word_index.items():\n        try:\n            embedding_matrix[i] = embedding_index[word]\n        except KeyError:\n            unknown_words.append(word)\n    return embedding_matrix, unknown_words","6b7bb4cf":"glove_matrix, unknown_words_glove = build_matrix(tokenizer.word_index, GLOVE_EMBEDDING_PATH)\nprint('number unknown words (glove): ', len(unknown_words_glove))","641c9217":"from tensorflow.keras.models import Sequential, load_model, Model\nfrom tensorflow.keras.layers import Embedding, Bidirectional, LSTM, Dropout, Dense, GlobalMaxPooling1D, Input\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.callbacks import ModelCheckpoint","e8bb847e":"# first model\nmodel1 = Sequential()\n\nembeddings = Embedding(vocab_size+1, 300, weights=[glove_matrix], input_length=200, trainable=False)\n\nmodel1.add(embeddings)\nmodel1.add(Bidirectional(LSTM(64, return_sequences=True, dropout=0.5, recurrent_dropout=0.5)))\nmodel1.add(GlobalMaxPooling1D())\nmodel1.add(Dense(1, activation='sigmoid')) # remember to use sigmoid for 1\/0, not SOFTMAX!!\n\nmodel1.summary()","23b6b766":"optimizer = Adam(0.001)\n\nmodel1.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=['accuracy'])","e528dea8":"checkpoint1 = ModelCheckpoint('weights1.h5', save_best_only=True, monitor='val_accuracy', mode='max')","2d136051":"from sklearn.model_selection import train_test_split\n\nX = padded_seq\ny = df['Recommended IND'].values\n\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, stratify=y, random_state=2020)\n\nX_train.shape, X_val.shape, y_train.shape, y_val.shape","e67b004f":"history1 = model1.fit(X_train, y_train, batch_size=64, epochs=5, validation_data=(X_val, y_val), callbacks=[checkpoint1], verbose=1)","daa38366":"# Get training and test loss histories\ntraining_loss = history1.history['loss']\ntest_loss = history1.history['val_loss']\n\n# Create count of the number of epochs\nepoch_count = range(1, len(training_loss) + 1)\n\n# Visualize loss history\nplt.plot(epoch_count, training_loss, 'r--')\nplt.plot(epoch_count, test_loss, 'b-')\nplt.legend(['Training Loss', 'Test Loss'])\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.show()","6c2aeaef":"!wget --quiet https:\/\/raw.githubusercontent.com\/tensorflow\/models\/master\/official\/nlp\/bert\/tokenization.py","374631db":"import tokenization\nimport tensorflow_hub as hub","94197f42":"def bert_encode(texts, tokenizer, max_len=512):\n    all_tokens = []\n    all_masks = []\n    all_segments = []\n    \n    for text in texts:\n        text = tokenizer.tokenize(text)\n            \n        text = text[:max_len-2]\n        input_sequence = [\"[CLS]\"] + text + [\"[SEP]\"]\n        pad_len = max_len - len(input_sequence)\n        \n        tokens = tokenizer.convert_tokens_to_ids(input_sequence)\n        tokens += [0] * pad_len\n        pad_masks = [1] * len(input_sequence) + [0] * pad_len\n        segment_ids = [0] * max_len\n        \n        all_tokens.append(tokens)\n        all_masks.append(pad_masks)\n        all_segments.append(segment_ids)\n    \n    return np.array(all_tokens), np.array(all_masks), np.array(all_segments)","6e961d28":"def build_model(bert_layer, max_len=512):\n    input_word_ids = Input(shape=(max_len,), dtype=tf.int32, name=\"input_word_ids\")\n    input_mask = Input(shape=(max_len,), dtype=tf.int32, name=\"input_mask\")\n    segment_ids = Input(shape=(max_len,), dtype=tf.int32, name=\"segment_ids\")\n\n    _, sequence_output = bert_layer([input_word_ids, input_mask, segment_ids])\n    clf_output = sequence_output[:, 0, :]\n    out = Dense(1, activation='sigmoid')(clf_output)  # remember to use sigmoid for 1\/0, not SOFTMAX..\n    \n    model = Model(inputs=[input_word_ids, input_mask, segment_ids], outputs=out)\n    model.compile(Adam(lr=2e-5), loss='binary_crossentropy', metrics=['accuracy'])  # 0.00002 - 0.00005\n    \n    return model","d4f43d19":"%%time\nmodule_url = \"https:\/\/tfhub.dev\/tensorflow\/bert_en_uncased_L-12_H-768_A-12\/1\"\nbert_layer = hub.KerasLayer(module_url, trainable=True)","537266a9":"vocab_file = bert_layer.resolved_object.vocab_file.asset_path.numpy()\ndo_lower_case = bert_layer.resolved_object.do_lower_case.numpy()\ntokenizer = tokenization.FullTokenizer(vocab_file, do_lower_case)","32ac494a":"X_train_bert = bert_encode(df['Review Text'], tokenizer, max_len=200)\n\ny_train = df['Recommended IND'].values","299dac49":"model2 = build_model(bert_layer, max_len=200)\n\nmodel2.summary()","4e4a4f82":"checkpoint2 = ModelCheckpoint('weights2.h5', monitor='val_loss', save_best_only=True)\n\nhistory2 = model2.fit(\n            X_train_bert, y_train,\n            validation_split=0.2,\n            epochs=3,\n            batch_size=32, callbacks=[checkpoint2])","5f1a1965":"# Get training and test loss histories\ntraining_loss2 = history2.history['loss']\ntest_loss2 = history2.history['val_loss']\n\n# Create count of the number of epochs\nepoch_count = range(1, len(training_loss2) + 1)\n\n# Visualize loss history\nplt.plot(epoch_count, training_loss2, 'r--')\nplt.plot(epoch_count, test_loss2, 'b-')\nplt.legend(['Training Loss', 'Test Loss'])\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.show()","2784061c":"> ### All departement have the same pattern about being recommended (or not), the rating comparison also have similar pattern","e3ba4094":"> ### There's something interesting, a lot of negative reviews still recommended, why?","1e70c463":"Overfitting, but get better val loss & accuracy","a3d381a2":"### Let's dig more deeper","25a2a94f":"## Try BERT","c79d680b":"* Perhaps because this product still got high rating, despite the sentiment review is negative\n\n> ### We can use rating as an indicator whether this clothing will be recommended or not (already mention above)","efb77ed2":"* Clothing ID: Integer Categorical variable that refers to the specific piece being reviewed.\n* Age: Positive Integer variable of the reviewers age.\n* Title: String variable for the title of the review.\n* Review Text: String variable for the review body.\n* Rating: Positive Ordinal Integer variable for the product score granted by the customer from 1 Worst, to 5 Best.\n* Recommended IND: Binary variable stating where the customer recommends the product where 1 is recommended, 0 is not recommended.\n* Positive Feedback Count: Positive Integer documenting the number of other customers who found this review positive.\n* Division Name: Categorical name of the product high level division.\n* Department Name: Categorical name of the product department name.\n* Class Name: Categorical name of the product class name.","1e369725":"### First, let's analyze review text length, then decice max_len for padding","24fbb7e0":"* It's obvious, clothes that get 4 or 5 stars rating will be recommended\n* On the contrary, chothes that get 1 or 2 stars rating mostly won't be recommended\n\n> ### We can use rating as an indicator whether this clothing will be recommended or not","6bcd9948":"## Deep Learning for being recommended (or not) prediction based on text reviews\n\n1. LSTM with GloVe\n1. Bert (better)","005981b2":"## Try Sentiment Analysis"}}