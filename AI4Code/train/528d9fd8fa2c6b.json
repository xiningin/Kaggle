{"cell_type":{"6402769c":"code","dcfd2cf0":"code","9801e381":"code","b2c0f0fc":"code","12c6b211":"code","db56d542":"code","d6b1f3d7":"code","d3ec4941":"code","2e93d8c8":"code","24d2b2cc":"code","7dc18cd3":"code","5b81ae55":"code","e2132708":"code","0a28df73":"code","2a4831de":"code","9d142dbc":"code","c9cc0c68":"code","e485f353":"code","8e169bab":"code","402837ec":"code","0e975159":"code","fb8d918e":"code","d948a10e":"code","7646df5a":"code","cf34cd24":"code","05b2869a":"markdown","1ba92b1a":"markdown","3a0e5a19":"markdown","630e48f6":"markdown","d0a802cd":"markdown","5a62e649":"markdown","5b03ff30":"markdown","fe1502c9":"markdown","a3557ae8":"markdown","270426bc":"markdown"},"source":{"6402769c":"import numpy as np\nimport pandas as pd\nfrom fractions import Fraction\nimport gc","dcfd2cf0":"train = pd.read_csv('..\/input\/train.csv')","9801e381":"train.drop(['first_active_month','feature_1','feature_2','feature_3'],axis=1, inplace=True)\ntrain.set_index(['card_id'],inplace=True)\ntrain['target_original'] = 2**train['target']\ntrain.head()","b2c0f0fc":"def calcRatio(df, column, precision):\n    limit = 10\n    \n    frac = 'fraction'\n    dfrac = 'decimal'\n    diff = 'diff'\n    \n    df[frac] = df[column].apply(lambda x: Fraction(x).limit_denominator(limit))\n    df[dfrac] = df[frac]*1.\n    df[diff] = abs(df[column]-df[dfrac])\n    mask = df[diff] > precision\n    \n    while len(df[mask]) > 0:\n        limit = limit*10\n        df.loc[mask, frac] = df[mask][column].apply(lambda x: Fraction(x).limit_denominator(limit))\n        df[diff] = abs(df[column]-df[frac]*1.)\n        mask = df[diff] > precision \n\n    df[dfrac] = df[frac]*1.\n    df['numerator']=df[frac].apply(lambda x: x.numerator)\n    df['denominator']=df[frac].apply(lambda x: x.denominator)","12c6b211":"calcRatio(train, 'target_original', 10**(-6))","db56d542":"train.sort_values(['numerator','denominator'], inplace=True)\ntrain[train.fraction!=0][2400:2450]","d6b1f3d7":"train.sort_values(['denominator'], inplace=True)\ntrain[train.fraction!=0][2400:2450]","d3ec4941":"calcRatio(train, 'target_original', 10**(-3))","2e93d8c8":"train.sort_values(['card_id'], inplace=True)\ntrain[(train.fraction!=0)&(train['diff']<(10**(-7)))]","24d2b2cc":"def reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df\n","7dc18cd3":"usecols = ['authorized_flag','card_id','installments','merchant_id']","5b81ae55":"hist_xfer = pd.read_csv('..\/input\/historical_transactions.csv', usecols=usecols )\nhist_xfer['new']=0\nhist_xfer = reduce_mem_usage(hist_xfer, True)\nnew_xfer = pd.read_csv('..\/input\/new_merchant_transactions.csv', usecols=usecols)\nnew_xfer['new']=1\nnew_xfer = reduce_mem_usage(new_xfer, True)","e2132708":"xfer = pd.concat([new_xfer,hist_xfer])\ndel new_xfer, hist_xfer\ngc.collect()","0a28df73":"xfer.reset_index(drop=True)\nxfer['authorized_flag'] = xfer['authorized_flag'].map({'Y': 1, 'N': 0}).astype(np.int16)","2a4831de":"xfer['auth_new']=xfer['authorized_flag']*xfer['new']\nxfer['auth_hist']=abs(xfer['authorized_flag']*(xfer['new']-1))\nxfer.head()","9d142dbc":"aggs= {'installments': ['sum'],\n       'authorized_flag': ['sum'],\n       'merchant_id': ['nunique', 'count'],\n       'auth_new': ['sum'],\n       'auth_hist': ['sum']\n}","c9cc0c68":"df = xfer.groupby('card_id').agg(aggs)\ndf.columns = df.columns.map('_'.join)\ndf['max'] = df[['installments_sum', 'merchant_id_count']].max(axis=1)\ndf.head()","e485f353":"train = train.join(df, on='card_id')","8e169bab":"calcRatio(train, 'target_original', 10**(-6))\ntrain.sort_values(['denominator'], inplace=True)","402837ec":"display_col=['target','target_original','fraction','decimal','numerator','denominator','auth_new_sum','auth_hist_sum']\nmask = (train['denominator'] == train['auth_new_sum']) & (train['diff']<10**(-4)) & (train['fraction']!=0)\ntrain[mask][display_col].head(10)","0e975159":"train[mask][display_col].tail(10)","fb8d918e":"print(len(train[mask]))","d948a10e":"mask = (train['numerator'] == train['auth_new_sum'])  &  (train['diff']<10**(-4)) &(train['fraction']!=0)\ntrain[mask][display_col].head(10)","7646df5a":"train[mask][display_col].tail(10)","cf34cd24":"print(len(train[mask]))","05b2869a":"I hope this may lead to more insights and can be used for postprocessing.","1ba92b1a":"There are some matches, but mostly for denominator == 1 similar situation for numerator","3a0e5a19":"Now lets figure out fraction values which were used to calculate original target values.","630e48f6":"As it turnes out some of the original target values in target_original column are really close to ratios like 2\/5, 8\/9 etc.\n\nThe function below will calculate the smallest fraction which comes close enough to original target value whith a given numerical precision","d0a802cd":"# Converting target values to fractions\n\nFollowing the insights from this awesome kernel \n[https:\/\/www.kaggle.com\/raddar\/towards-de-anonymizing-the-data-some-insights](http:\/\/) \n\nI wrote this small kernel which will automatically try to convert all target values from train data into rational fractions with a given precision.\n","5a62e649":"Lets check if there are some matches for denominator and authorized new transactions","5b03ff30":"There was a hypothesis that some of the denominator\/numerator values may match a number of authorized transactions from new\/historical data. Lets check it. I'll import these data and join with above fractionized target set","fe1502c9":"But even if there would have been more matches: a fraction 1\/3 could have been calculated by 10\/33, 20\/60. Looks like these matches of numerator and number of auth transactions happened just by coincidence","a3557ae8":"As was explained in original above kernel, all target values in train data set were actually transformed using log2 function. \n\nThe original values can be obtained by applying 2^target backtransformation","270426bc":"As you can see below lots of original target values at the lower end can be matched pretty well by fractions with small denominator. I exclude the outliers where ratio = 0 and list some values just to get an impression how many target values can be matched pretty well by fractions with low denominator.\n\nColumn 'decimal' contains decimal value of determined fraction and 'diff' the difference to original target value"}}