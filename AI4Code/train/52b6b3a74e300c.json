{"cell_type":{"53addd7c":"code","28e86d0f":"code","40ebd713":"code","688e5881":"code","33ed9424":"code","0db7e5f5":"code","2d47af14":"code","8773a4bd":"code","59c7387b":"code","25e47c51":"code","2d92a7c0":"code","f815e249":"code","7cf62335":"code","1157f0cb":"code","b293bc9b":"code","83d5afd6":"code","e87ad76d":"code","88935555":"markdown","200d9ad3":"markdown","aafd9d58":"markdown","eb45036c":"markdown","96e0199a":"markdown","2835813b":"markdown","4a09c652":"markdown","be1b3430":"markdown","1a48bdec":"markdown","1e37122a":"markdown","2907aca3":"markdown","81283cb0":"markdown","c42392d6":"markdown","af9efddb":"markdown","e92436a3":"markdown"},"source":{"53addd7c":"# import packages\nimport pandas as pd\nimport numpy as np\nnp.set_printoptions(precision=3)  # the precision to print","28e86d0f":"\n# global parameter\nn = 6  # the number of pages\nd = 0.15  # damping (decay) factor\nT = 2  # the number of iteration epochs, try to set it from 1 to 1000 and see the difference in results\n\n# A1. Initialize the PageRank of every node with a value of 1\/n\nPR = np.ones(n)\/n\n\n# A2. For each iteration, update the PageRank of every node in the graph\nfor i_t in range(T):\n    \n    # for the pages 1: it can only be reached through random walk\n    rand = 1 \/ n\n    PR[0] = d * rand\n    \n    # for other pages: they can be reached through either random walk or inter-page links\n    for i in range(1, n):\n\n        # A2.1 Sum up the proportional rank from all of its in-neighbors\n        i_prop = PR[i-1] \/ 1\n\n        # A2.2 the probability of randomly walking out the links\n        rand\n\n        # A2.3 Update the PageRank with the weighted sum of proportional rank and random walk\n        PR[i] = d * rand + (1-d) * i_prop\n    print(PR)\n# normalize PR when there is terminal point    \nPR \/= PR.sum()\n\n# print current pr\nprint(f'The original PR:\\n{PR}')","40ebd713":"# Your code of Practice 1\n\n# global parameter\nn = None  # the number of pages\nd = 0.15  # damping (decay) factor\nT = 10  # the number of iteration epochs, try to set it from 1 to 1000 and see the difference in results\n\n# A1. Initialize the PageRank of every node with a value of 1\/n\nPR = None\n\n# A2. For each iteration, update the PageRank of every node in the graph\n\n    \n# for each pages: they can be reached through either random walk or inter-page links\n    \n\n# A2.1 Sum up the proportional rank from all of its in-neighbors\n        \n\n# A2.2 Calculate the probability of randomly walking out the links\n        \n\n# A2.3 Update the PageRank with the weighted sum of proportional rank and random walk\n       \n\n# print current pr\nprint(f'The original PR:\\n{PR}')","688e5881":"# global parameters\nn = 6\n\n# initialize adjacency matrix\nM = np.zeros([n, n])\n# add links of page 1 -> 2\nM[0, 1] = 1\n# add links of page 2 -> 3\nM[1, 2] = 1\n# add links of page 3 -> 4\nM[2, 3] = 1\n# add links of page 4 -> 5\nM[3, 4] = 1\n# add links of page 5 -> 6\nM[4, 5] = 1\n# add links of page 6 -> all\nM[5, :] = 1\n# show the matrix\nprint(M)","33ed9424":"# by row sum of M (aggregate the second dimension: column)\nM\nprint(f'row sum of M:\\n {M_rowsum}')\n\n# transition matrix\nP = M \/ M_rowsum\nprint(f'transition matrix of M:\\n {P}')","0db7e5f5":"# the probability of random walk (damping factor)\nd = 0.15\n\n# the probability of being reached if random walk\nrand = 1 \/ n\n\n# the expected transition matrix\nP_hat = P * (1 - d) + rand * d\n\nprint(f'the expected transition matrix:\\n {P_hat}')","2d47af14":"# times to product\nT = 10  # try from 1 to 1000 to see when the current PR converges\n\n# intialize PR\nPR = np.ones([1, n])\/n  # you can try to initialize with different non-zero value\n\n# for each iteration\nfor i_t in range(T):\n    \n    # iterate a transition: multiply PR by P_hat\n    PR = np.matmul(PR, P_hat)\n\n# print the results of PR\nprint(PR)","8773a4bd":"# Your code for Practice 2\nPR = None\n\nprint(PR)","59c7387b":"# initialize adjacent matrix\nN = 10\nM = np.zeros([N,N])\nprint(M)","25e47c51":"# read a file\noutlinks = pd.read_csv('..\/input\/pagedata\/Demo10\/1', header=None)\nprint(f'pd.DataFrame format: \\n{outlinks}')\nprint(f'np.array format: \\n{outlinks.values}')","2d92a7c0":"# update the adjacent matrix for the i page\ni = 1\nM[i-1,outlinks.values-1] = 1\nprint(M)","f815e249":"# loop values\npage_id = np.arange(1, 10+1)\nprint(f'page_id: {page_id}')","7cf62335":"# for loop\nfor i in page_id:\n    print(f'reading outlinks of the page {i}')\n    try:\n        outlinks = pd.read_csv(f'..\/input\/pagedata\/Demo10\/{i}').values\n        M[i-1, outlinks - 1] = 1\n    except:\n        print(f'no outlinks from page {i}')\n        M[i-1,:] = 1\n        continue\nprint(M)","1157f0cb":"# transition matrix\nM_sum = M.sum(1, keepdims=True)\nprint(f'outlink sum: \\n{M_sum}')\nP = M \/ M_sum\nprint(f'transition matrix: \\n{P}')","b293bc9b":"# the probability of random walk (damping factor)\nd = 0.15\n\n# the probability of being reached if random walk\nrand = 1 \/ N\n\n# the expected transition matrix\nP_hat = P * (1 - d) + rand * d\n\nprint(f'the expected transition matrix:\\n {P_hat}')","83d5afd6":"# calculating page rank\nimport time\nt0 = time.time()\n\n# times to product\nT = 10  # try from 1 to 1000 to see when the current PR converges\n\n# intialize PR\nPR = np.ones([1, N])\/N  # you can try to initialize with different non-zero value\n\n# for each iteration\nfor i_t in range(T):\n    \n    # iterate a transition: multiply PR by P_hat\n    PR = np.matmul(PR, P_hat)\n\n# print the results of PR\nprint(PR)\n\nt1 = time.time()\nt_run = t1 - t0\nprint(f'using time: {t_run}')","e87ad76d":"# Your code","88935555":"## Python Implementation Demo 1\n\n### Problem Description\n\nConsider 6 website with links shown below:\n\n![image.png](attachment:f8a3fd56-cf1c-44bd-b9e4-0f9017111ba0.png)\n\nThen, assume the damping factor $d$ as 0.15, i.e., calculating the page rank value for each site","200d9ad3":"## Python Code: linear algebra method\n\n- We can use linear algebra to solve the problem. The key point is to describe the adjacency matrix among the pages. \n\n- Taking the example of Demo 1, we create a $n \\times n$ matrix M, where $M(i,j)$=1 denotes that there is a connect from $i$ to $j$. \n\n![image.png](attachment:8442e361-bf57-467e-996d-917449eb1554.png)!\n\n- Notice that, if a page is the terminal page (page 6), we can treat it as a random walk point, which is connected to all nodes including itself.\n\n- Then, the adjacency matrix is given by","aafd9d58":"## Extension: other method of PR\n\nFor example, we can directly calculate the eigenvalue of transition matrix, which exactly equals to the final PR value. Because\n$$\\lambda \\hat P = \\lambda,$$\naccording to the definition of $\\lambda$. And the equation is exactly the condition of final PR value.\nSee stochastic process for details if you are interested in the machanism. ","eb45036c":"However, there is a probability $d$ of random walk. Thus, the expected transition matrix $\\hat P$ is the weighted average of $P$ and random walk probability:","96e0199a":"### Python Code: Direct Iteration Method","2835813b":"The normalized PR is consistent with [official results](https:\/\/towardsdatascience.com\/pagerank-3c568a7d2332):\n\n![image.png](attachment:bd3add02-b9e1-46d4-9ec5-afbdb8d5da6c.png)!","4a09c652":"Finally, we can calculate the page rank value through matrix product","be1b3430":"## Try Demo100 to 10000, and count your time","1a48bdec":"## Practice answers\n\nThe official results of the normalized PR of Practice 1 and 2 is given by\n\n![image.png](attachment:c3af64f5-2ef5-4e79-889b-36b48a10c496.png)!","1e37122a":"# PageRank: Link Analysis Explanation and Python Implementation\n\n## Introduction\n\n- We will briefly explain the PageRank algorithm and walkthrough the whole Python Implementation. \n\n- The best part of PageRank is it\u2019s query-independent. \n\n- We don\u2019t need a root set to start the algorithm. And the key point of PageRank is to calculate the ranks based on the **proportional rank passed around the sites**.\n","2907aca3":"## Practice 2: using real data to score the pages","81283cb0":"### Practice 2\n\nTry to use the linear algebra method to calculate the PR value of the problem given in Practice 1.","c42392d6":"### Practice 1\n\nTry to code and solve the PR of the following structure with direct iteration method:\n\n![image.png](attachment:a0d1356b-94d1-4193-96e3-f76ac2aa1eba.png)!","af9efddb":"Then, we can use adjacency matrix to calculate the transition probability matrix $P$, which is the row-wise normalized adjacency matrix. $P(i,j)$ denotes the probability of the transition from $i$ to $j$.","e92436a3":"## PageRank Equation\n\nThe iteration equation of the page rank value of $i$ is given by\n\n![image.png](attachment:f95f64c5-4727-406e-96ca-b4465c6f27e8.png)\n\nwhere the damping factor $d=D$, $\\frac{d}{n}$ denotes random walk score, $OutputDegree(P_j)$ denote how many pages are linked as children pages for the page $j$.\n\n"}}