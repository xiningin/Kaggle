{"cell_type":{"3228bf09":"code","3032c60b":"code","f4c3f5dc":"code","278b93df":"code","bc2dff56":"code","933dfa86":"code","f9a2fbc0":"code","f3fc502b":"code","74daba7f":"code","8029df65":"code","255ad3c9":"code","84a290a8":"code","1f54ffdd":"code","4383726e":"markdown","724e45e0":"markdown","c0fd9509":"markdown","62d5b062":"markdown","f65627c8":"markdown","56f83552":"markdown"},"source":{"3228bf09":"import numpy as np\nimport pandas as pd \nimport skimage\nimport os \nimport random\n\nimport matplotlib.pyplot as plt\nfrom sklearn.utils import shuffle\nfrom sklearn.model_selection import train_test_split\n\nfrom tensorflow.keras.layers import Conv2D,MaxPooling2D,BatchNormalization,Flatten,Dense\nfrom tensorflow.keras.models import Sequential,Model\nfrom tensorflow.keras.callbacks import EarlyStopping , ReduceLROnPlateau\nfrom keras.layers import GaussianNoise","3032c60b":"train_data = pd.read_csv('..\/input\/digit-recognizer\/train.csv')\ntest_data = pd.read_csv('..\/input\/digit-recognizer\/test.csv')\n","f4c3f5dc":"label_index_list = [None]*10\n\nfor i, label in enumerate(train_data.get('label')):\n    if label_index_list[label]:\n        label_index_list[label].append(i)\n    else:\n        label_index_list[label] = [i]\ntrain_data.pop('label')\n","278b93df":"X = train_data.to_numpy()\nX =  X.reshape((X.shape[0],28,28,1))\nrandom_indexes = [i for i in range(20997)]\nrandom.shuffle(random_indexes)\nnew_X = [None] * 20997\ny = [None] * 20997 \n\nfor i in range(len(label_index_list)):\n    indexes = label_index_list[i]\n    for j in range(1, len(indexes), 2):\n        new_image = []\n        ind1, ind2 = indexes[j-1], indexes[j]\n        for k in range(len(X[0])):\n            new_image.append(np.append(X[ind1][k], X[ind2][k]))\n        index = random_indexes.pop()\n        new_X[index] = np.array(new_image)\n        y[index] = i\n\ny = np.array(y)\ny = y.reshape((y.shape[0],1))\nX = np.array(new_X)  \n\nX = X.reshape(X.shape[0], 28, 56, 1)\n\nX = X.astype(\"float32\")\nX = X\/255.0\ny = y.astype(\"float32\")\n\nprint(f\"train data and label have shape = {X.shape} , {y.shape} respectively.\")\n","bc2dff56":"fig = plt.figure(figsize=(10,10))\ncount=0\nfor i in range(4):\n    for j in range(4):\n        plt.subplot(4,4,count+1);\n        plt.title(f\" digit : {int(y[count][0])}\")\n        plt.imshow(X[count]);\n        \n        count+=1;","933dfa86":"X_train,X_valid,y_train,y_valid = train_test_split(X, y, test_size=0.1, random_state=42)\n","f9a2fbc0":"\nfig = plt.figure(figsize=(10,10))\nplt.subplot(1,2,1);\nplt.imshow(X[0]);\nplt.title(\"normal image\")\nplt.subplot(1,2,2);\nplt.imshow(X[0]);\ngimg = skimage.util.random_noise(X[0], mode=\"gaussian\")\nplt.title(\"gaussian noise\")\nplt.imshow(gimg)","f3fc502b":"model=Sequential()\n\nmodel.add(GaussianNoise(0.01, input_shape=(28,56,1)))\nmodel.add(Conv2D(filters=64, kernel_size = (3,3), activation=\"relu\", input_shape=(28,56,1)))\nmodel.add(Conv2D(filters=64, kernel_size = (3,3), activation=\"relu\",padding=\"same\"))\n\nmodel.add(MaxPooling2D(pool_size=(2,2)))\nmodel.add(BatchNormalization())\nmodel.add(Conv2D(filters=128, kernel_size = (3,3), activation=\"relu\"))\nmodel.add(Conv2D(filters=128, kernel_size = (3,3), activation=\"relu\",padding=\"same\"))\n\nmodel.add(MaxPooling2D(pool_size=(2,2)))\nmodel.add(BatchNormalization())    \nmodel.add(Conv2D(filters=256, kernel_size = (3,3), activation=\"relu\"))\n    \nmodel.add(MaxPooling2D(pool_size=(2,2)))\n    \nmodel.add(Flatten())\nmodel.add(BatchNormalization())\nmodel.add(Dense(512,activation=\"relu\"))\n    \nmodel.add(Dense(10,activation=\"softmax\"))\n    \nmodel.compile(loss=\"sparse_categorical_crossentropy\", optimizer=\"adam\", metrics=[\"accuracy\"])\n","74daba7f":"earlystopper = EarlyStopping(patience=5,restore_best_weights=True)\nreduce_learing_rate = ReduceLROnPlateau(patience=1)\ncallback_list = [earlystopper,reduce_learing_rate]","8029df65":"model.fit(X_train,y_train,validation_split=0.1,epochs=4,batch_size=64,callbacks=callback_list)","255ad3c9":"predictions = model.predict(X_valid)\npredictions = np.argmax(predictions,axis=1)\nprint(predictions)","84a290a8":"fig = plt.figure(figsize=(10,10))\ncount_map = dict()\n\nfor pred in predictions:\n    if pred not in count_map:\n        count_map[pred] = 1\n    else:\n        count_map[pred]+= 1\n        \nprint(count_map)\n\ncount=0\nfor i in range(4):\n    for j in range(4):\n        plt.subplot(4,4,count+1);\n        plt.imshow(X_valid[count]);\n        plt.title(f\"predicted digit : {predictions[count]}\")\n        plt.tight_layout()\n        count+=1;","1f54ffdd":"hits = []\nfor i,pred in enumerate(predictions):\n    if pred == y_valid[i]:\n        hits.append(1)\n    else:\n        hits.append(0)\n\nsm = sum(hits)\nacc = sm\/len(predictions)\n\nprint(\"The validation accuracy of 2 digit recognition was \", round(acc,4)*100, \"%\")","4383726e":"### visualizinf the prediction","724e45e0":"# Data Extraction and Preprocessing","c0fd9509":"## Competetion : Digit Recognizer\n## Dataset : MNIST Digit dataset\n## Description : A competetion to predict the digit from the input image","62d5b062":"# Build and Train Model","f65627c8":"# Making Predictions and submitting to kaggle","56f83552":"# Importing Required libraries"}}