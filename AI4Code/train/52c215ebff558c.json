{"cell_type":{"1e986150":"code","cde4cc97":"code","9cbad030":"code","edc515e2":"code","cf39c028":"code","2c27215b":"code","c38eda29":"code","c3ccfa44":"code","a77d28d8":"code","a72835f9":"code","9681c0a2":"code","529b3bbd":"code","69b14a8a":"code","f0e126eb":"code","e5ce70e1":"code","5bb9b9af":"code","902c00c0":"code","3883494f":"code","5c643b6e":"code","3c8fa652":"code","adf31289":"code","3992025c":"code","595d83e8":"code","98d06731":"markdown","4fcc065b":"markdown","a2c5f3b5":"markdown","33b937ca":"markdown","5473ced2":"markdown","d20db4b2":"markdown","df96093f":"markdown","5151c187":"markdown","fe97a377":"markdown","7df06ef5":"markdown","ebc0fc3d":"markdown","de784062":"markdown","1ccf59f8":"markdown","4daf879b":"markdown","33e01e36":"markdown","378ce6ed":"markdown"},"source":{"1e986150":"import pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport torch # pytorch for deep learning\nimport torch.nn as nn # For neural networks\nimport torch.nn.functional as F # for activation functions like relu\nimport torch.optim as optim # calling the optimizer that update the weights\nfrom torch.utils.data import DataLoader, Dataset # for load and manage datasets\nfrom sklearn.feature_extraction.text import CountVectorizer # for Bag Of Words represntation\nimport os # for interact with the operating system ","cde4cc97":"# check if CUDA is available\ntrain_on_gpu = torch.cuda.is_available()\n\nif not train_on_gpu:\n    print('CUDA is not available.  Training on CPU ...')\nelse:\n    print('CUDA is available!  Training on GPU ...')","9cbad030":"# get the data\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","edc515e2":"train_data = pd.read_csv(\"\/kaggle\/input\/twitgen_train_201906011956.csv\")\ntrain_data.head()","cf39c028":"train_data.info()\n# 34146 entries and no null values in all columns","2c27215b":"train_data = train_data[[\"text\",\"male\"]]\ntrain_data.head(3)\n# we got the text and male columns only","c38eda29":"train_data[\"male\"] = train_data[\"male\"].astype(int)\ntrain_data.head()","c3ccfa44":"# split the data into train_x and train_y\ntrain_x = train_data[\"text\"]; train_y = train_data[\"male\"]","a77d28d8":"class Sequences(Dataset):\n    def __init__(self, data_x,data_y):\n        # Init the bag of words\n        self.vectorizer = CountVectorizer(stop_words='english', max_df=0.99, min_df=0.005)\n        # transform the data to BoW\n        self.sequences = self.vectorizer.fit_transform(data_x.to_list())\n        self.labels = data_y.to_list()\n        self.token2idx = self.vectorizer.vocabulary_\n        self.idx2token = {idx: token for token, idx in self.token2idx.items()}\n        \n    def __getitem__(self, i):\n        return self.sequences[i, :].toarray(), self.labels[i]\n    \n    def __len__(self):\n        return self.sequences.shape[0]","a72835f9":"dataset = Sequences(train_x, train_y)\ntrain_loader = DataLoader(dataset, batch_size=4200)\n# print The shape of BoW\nprint(dataset[4][0].shape)","9681c0a2":"class BagOfWordsClassifier(nn.Module):\n    def __init__(self, vocab_size, hidden1, hidden2, hidden3):\n        super(BagOfWordsClassifier, self).__init__()\n        self.fc1 = nn.Linear(vocab_size, hidden1)\n        self.fc2 = nn.Linear(hidden1, hidden2)\n        self.fc3 = nn.Linear(hidden2, hidden3)\n        self.fc4 = nn.Linear(hidden3, 1) # 1 because we just have one predict male or not\n    \n    \n    def forward(self, inputs):\n        x = F.relu(self.fc1(inputs.squeeze(1).float()))\n        x = F.relu(self.fc2(x))\n        x = F.relu(self.fc3(x))\n        return self.fc4(x)","529b3bbd":"# pass the vocab size and nodes numbers of each hidden layer\nmodel = BagOfWordsClassifier(len(dataset.token2idx), 256,128, 64)\nmodel","69b14a8a":"# criterion for tells us how wrong the model\ncriterion = nn.BCEWithLogitsLoss()\n# optimizer to update the wieghts and learn \noptimizer = optim.Adam( model.parameters(), lr=0.001) ","f0e126eb":"# check if the device has GPU or not\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\ndevice","e5ce70e1":"if train_on_gpu:\n    # if the device has GPU run the model on GPU\n    model.cuda()\n    # start training\nmodel.train()\ntrain_losses = []\nfor epoch in range(10): # 10 epochs feel free to change \n    losses = []\n    total = 0\n    for inputs, target in train_loader:\n        # clean the old gradient\n        model.zero_grad()\n        if train_on_gpu: # if the device has GPU pass inputs and targets to it\n            inputs, target = inputs.cuda() , target.cuda()\n        # forward the data inputs\n        output = model(inputs)\n        # calculate how wrong the model\n        loss = criterion(output.squeeze(), target.float())\n        # go back then ....\n        loss.backward()\n        # update the weights\n        optimizer.step()\n\n        # calculate the train loss\n        losses.append(loss.item())\n        total += 1\n    # after finish one epoch sum the loss of each batch and divide on the total\n    epoch_loss = sum(losses) \/ total\n    train_losses.append(epoch_loss)\n\n    print(f'Epoch #{epoch + 1}\\tTrain Loss: {epoch_loss:.3f}')","5bb9b9af":"def predict_gender(text):\n    # get the model back into cpu\n    model.cpu()\n    # evaluate the model\n    model.eval()\n    # we don't need the grad in test so we stop it by no_grad\n    with torch.no_grad():\n        # convert the test or the new tweet into BoW \n        test_vector = torch.LongTensor(dataset.vectorizer.transform([text]).toarray())\n        # now pass the text into the model to predict\n        output = model(test_vector)\n        # our problem is binary so we'll use sigmoid to get the prediction\n        prediction = torch.sigmoid(output).item()\n\n        if prediction > 0.5:\n            return \"male\"\n        else:\n            return \"female\"","902c00c0":"test_data = pd.read_csv(\"\/kaggle\/input\/twitgen_test_201906011956.csv\")\ntest_data.head()","3883494f":"# convert True values to male and False values to True \ntest_data[\"male\"] [test_data[\"male\"] == True] = \"male\"\ntest_data[\"male\"] [test_data[\"male\"] == False] = \"female\"","5c643b6e":"test_x = test_data[\"text\"]\ntest_y = test_data[\"male\"]","3c8fa652":"def predict_from_test(text, label):\n    if predict_gender(text) == label:\n        print(predict_gender(text) , \" Correct predict\")\n    else:\n        print(predict_gender(text) , \" Wrong predict\")","adf31289":"# time to test\nfrom random import randint\nnum = randint(0,6000)\nprint(test_x[num])\npredict_from_test(test_x[num],test_y[num])","3992025c":"t2 = \"How u get such a discount on espresso shots????\"\npredict_gender(t2)","595d83e8":"t3 = \"I had the same thing in my trends.For a moment I thought it is a new feature where I can post to other's \u201cTwitter moments\u201d\"\npredict_gender(t3)","98d06731":"## Convert the data of male column to 1 if male and 0 if female ","4fcc065b":"**BoW means** your raw input like that `\"The big dog make you shoked\"` then the BoW will make it like that\n\n`[The, big, dog, make, you, shoked]`","a2c5f3b5":"## Build the model","33b937ca":"## Let's build the function that predict the gender","5473ced2":"We got 3 files train, valid and test for now we need to read the train data","d20db4b2":"Make Sure there is no null values","df96093f":"## Build function that tells us our prediction is correct or wrong","5151c187":" We just need the `text` as inputs and `male` as target so we don't need the other columns","fe97a377":"**At the end : ** This model for is not perfect it needs more data, data-preprocessing and tarining epochs to get high accuracy","7df06ef5":"### I copied this tweet from male","ebc0fc3d":" we are lucky the male column is boolean and in python if we convert the boolean value into integer the `True` become 1 and `False` become 0","de784062":"Apply gradient descent","1ccf59f8":"### I copied this tweet from female","4daf879b":"# Read test data","33e01e36":"## Bag Of Words Representation","378ce6ed":"## Split the data into test_x and test_y"}}