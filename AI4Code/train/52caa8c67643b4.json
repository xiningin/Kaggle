{"cell_type":{"13d5dadd":"code","69bdfdff":"code","3f1acbfb":"code","b235f513":"code","9acfe6ef":"code","08dc86f7":"code","0f20bf81":"code","4227b24e":"code","1e9e17b9":"code","230283b9":"code","0e60be44":"code","96a0255e":"code","ce1a9c11":"code","ed1bd4b0":"code","9a38afcc":"code","83cb9f31":"code","663d29b9":"code","0df4915d":"code","0a6dceed":"markdown","20fe27e3":"markdown"},"source":{"13d5dadd":"!pip install -U git+https:\/\/github.com\/qubvel\/efficientnet","69bdfdff":"CLASSES = ['pink primrose',    'hard-leaved pocket orchid', 'canterbury bells', 'sweet pea',     'wild geranium',     'tiger lily',           'moon orchid',              'bird of paradise', 'monkshood',        'globe thistle',         # 00 - 09\n           'snapdragon',       \"colt's foot\",               'king protea',      'spear thistle', 'yellow iris',       'globe-flower',         'purple coneflower',        'peruvian lily',    'balloon flower',   'giant white arum lily', # 10 - 19\n           'fire lily',        'pincushion flower',         'fritillary',       'red ginger',    'grape hyacinth',    'corn poppy',           'prince of wales feathers', 'stemless gentian', 'artichoke',        'sweet william',         # 20 - 29\n           'carnation',        'garden phlox',              'love in the mist', 'cosmos',        'alpine sea holly',  'ruby-lipped cattleya', 'cape flower',              'great masterwort', 'siam tulip',       'lenten rose',           # 30 - 39\n           'barberton daisy',  'daffodil',                  'sword lily',       'poinsettia',    'bolero deep blue',  'wallflower',           'marigold',                 'buttercup',        'daisy',            'common dandelion',      # 40 - 49\n           'petunia',          'wild pansy',                'primula',          'sunflower',     'lilac hibiscus',    'bishop of llandaff',   'gaura',                    'geranium',         'orange dahlia',    'pink-yellow dahlia',    # 50 - 59\n           'cautleya spicata', 'japanese anemone',          'black-eyed susan', 'silverbush',    'californian poppy', 'osteospermum',         'spring crocus',            'iris',             'windflower',       'tree poppy',            # 60 - 69\n           'gazania',          'azalea',                    'water lily',       'rose',          'thorn apple',       'morning glory',        'passion flower',           'lotus',            'toad lily',        'anthurium',             # 70 - 79\n           'frangipani',       'clematis',                  'hibiscus',         'columbine',     'desert-rose',       'tree mallow',          'magnolia',                 'cyclamen ',        'watercress',       'canna lily',            # 80 - 89\n           'hippeastrum ',     'bee balm',                  'pink quill',       'foxglove',      'bougainvillea',     'camellia',             'mallow',                   'mexican petunia',  'bromelia',         'blanket flower',        # 90 - 99\n           'trumpet creeper',  'blackberry lily',           'common tulip',     'wild rose']","3f1acbfb":"import math\nimport os, re\nimport numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom math import cos, floor, pi\nimport efficientnet.tfkeras as efn\nfrom kaggle_datasets import KaggleDatasets\nfrom sklearn.metrics import f1_score, accuracy_score, roc_auc_score\n\nAUTO = tf.data.experimental.AUTOTUNE\nprint('Tensorflow version : {}'.format(tf.__version__))","b235f513":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print('Running on TPU : {}'.format(tpu.master()))\nexcept ValueError:\n    tpu = None\n\nif tpu:\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nelse:\n    strategy = tf.distribute.get_strategy()\n\nprint(\"Replicas : {}\".format(strategy.num_replicas_in_sync))","9acfe6ef":"main_dir = '..\/input\/flower-ensemble'\npretrain_path = [\n    os.path.join(main_dir, 'EFN7_fold1.hdf5'),\n]","08dc86f7":"GCS_DS_PATH = KaggleDatasets().get_gcs_path('flower-classification-with-tpus')\nGCS_PATH = os.path.join(GCS_DS_PATH, 'tfrecords-jpeg-512x512')\n\nTEST_FNS = tf.io.gfile.glob(os.path.join(GCS_PATH, 'test\/*.tfrec'))\n\nNUM_TEST_IMAGES = np.sum([int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) for filename in TEST_FNS])\n\n\nIMG_DIM = (512, 512)\nCLASSES_NUM = len(CLASSES)\nBATCH_SIZE = 16 * strategy.num_replicas_in_sync\n\n\nParams = {'weights' : 'noisy-student',\n          'input_shape' : (*IMG_DIM, 3),\n          'include_top' : False}","0f20bf81":"class Dataset:\n    \n    def __init__(self,\n                 filenames,\n                 data_len,\n                 image_shape,\n                 classes,\n                 mode,\n                 batch_size=BATCH_SIZE,\n                 ):\n        \n        self.filenames = filenames\n        self.data_len = data_len\n        self.image_shape = image_shape\n        self.batch_size = batch_size\n        self.classes = classes\n        self.mode = mode\n\n        \n    def get_dataset(self, order=False, drop_remainder=True):\n        \n        data_options = tf.data.Options()\n        if not order:\n            data_options.experimental_deterministic = False\n        \n        ds = tf.data.TFRecordDataset(self.filenames, num_parallel_reads=AUTO)\n        ds = ds.with_options(data_options)\n        ds = ds.map(self._read_labeled_tfrecord if self.mode != 'test' else self._read_unlabeled_tfrecord, num_parallel_calls=AUTO)\n        ds = ds.batch(self.batch_size, drop_remainder=drop_remainder) \n        ds = ds.prefetch(AUTO)\n        \n        return ds\n    \n    def _decoded_image(self, image_data):\n        image = tf.image.decode_jpeg(image_data, channels=3)\n        image = tf.reshape(image, [*self.image_shape, 3])\n\n        return tf.cast(image, tf.float32) \/ 255.0\n    \n    def _read_labeled_tfrecord(self, example):\n        Labeled_tfrec_format = {\n            \"image\" : tf.io.FixedLenFeature([], tf.string),\n            \"class\" : tf.io.FixedLenFeature([], tf.int64)\n        }\n        \n        example = tf.io.parse_single_example(example, Labeled_tfrec_format)\n        image = self._decoded_image(example['image'])\n        label = example['class']\n        \n        return image, label\n\n    def _read_unlabeled_tfrecord(self, example):\n        Unlabeled_tfrec_format = {\n            \"image\" : tf.io.FixedLenFeature([], tf.string),\n            \"id\" : tf.io.FixedLenFeature([], tf.string)\n        }\n        \n        example = tf.io.parse_single_example(example, Unlabeled_tfrec_format)\n        image = self._decoded_image(example['image'])\n        id_num = example['id']\n        return image, id_num","4227b24e":"def build_model(base_model):\n    x = tf.keras.layers.GlobalAveragePooling2D()(base_model.output)\n    output = tf.keras.layers.Dense(units=CLASSES_NUM, activation='softmax')(x)\n    return tf.keras.models.Model(inputs=[base_model.input], outputs=[output])","1e9e17b9":"with strategy.scope():\n    \n    \n    base_model = efn.EfficientNetB7(**Params)\n    model = build_model(base_model)\n    print('Load pretrain weights')\n    model.load_weights(pretrain_path[0])\n","230283b9":"test_ds = Dataset(filenames=TEST_FNS,\n                   data_len=NUM_TEST_IMAGES,\n                   image_shape=IMG_DIM,\n                   classes=CLASSES_NUM,\n                   mode='test',\n                   batch_size=BATCH_SIZE,\n                   ).get_dataset(order=True, drop_remainder=False)\n\ntest_image_ds = test_ds.map(lambda image, id_num : image)","0e60be44":"prediction = model.predict(test_image_ds)\nprediction_max = np.max(prediction, axis=1)\nprediction = np.argmax(prediction, axis=-1)\n\ntest_id_ds = test_ds.map(lambda image, id_num : id_num)\ntest_ids = next(iter(test_id_ds.unbatch().batch(NUM_TEST_IMAGES))).numpy().astype('U')","96a0255e":"!mkdir \/kaggle\/working\/Flower_PesudoLabeling_tfrec","ce1a9c11":"PesudoLabeling_ds = Dataset(filenames=TEST_FNS,\n                            data_len=NUM_TEST_IMAGES,\n                            image_shape=IMG_DIM,\n                            classes=CLASSES_NUM,\n                            mode='test',\n                            batch_size=1,\n                            ).get_dataset(order=True, drop_remainder=False)\n\nPesudoLabeling_image_ds = PesudoLabeling_ds.map(lambda image, id_num : image)\n\nbest_record_file_num = 320\ntarget_path = '\/kaggle\/working\/Flower_PesudoLabeling_tfrec\/'\nrecord_file_num=0\nnum=0\nPL_num = 0\nrecord_filename = (\"PL_%.3d.tfrec\" % record_file_num)\n\nwriter = tf.io.TFRecordWriter(target_path + record_filename)","ed1bd4b0":"for idx, test_image in enumerate(PesudoLabeling_image_ds):\n    pm = prediction_max[idx]\n    label = prediction[idx]\n    \n    if pm >= 0.99:\n        PL_num += 1\n        num += 1\n        if num > best_record_file_num:\n            num = 1\n            record_file_num += 1\n            record_filename = (\"PL_%.3d.tfrec\" % record_file_num)\n            writer = tf.io.TFRecordWriter(target_path + record_filename)\n        test_image = tf.squeeze(test_image, axis=0)\n        test_image = tf.cast(test_image * 255.0, tf.uint8)\n        test_image = tf.image.encode_jpeg(test_image, optimize_size=True, chroma_downsampling=False)\n        example = tf.train.Example(features=tf.train.Features(feature={\n                    \"image\": tf.train.Feature(bytes_list=tf.train.BytesList(value=[test_image.numpy()])),\n                    \"class\": tf.train.Feature(int64_list=tf.train.Int64List(value=[label]))}))\n        writer.write(example.SerializeToString())\n\nwriter.close()\n\nprint('Total PL nums : {}'.format(PL_num))","9a38afcc":"os.listdir(target_path)","83cb9f31":"!apt install zip","663d29b9":"cd \/kaggle\/working\/Flower_PesudoLabeling_tfrec","0df4915d":"!zip -r -m -1 -q \/kaggle\/working\/Flower_PesudoLabeling_tfrec.zip *","0a6dceed":"# Pesudo Labeling\nWhat is pesudo labeling? In a very simple explanation, we use pretrain model to predict the testing data(without label), then take the high confidence predicted label as **pesudo label**. After that, we can re-train the model with original training dataset and the testing data with **pesudo label**. Although it is a very simple way to increase your training dataset, but we should aware that pesudo labeling might cause serious overfitting. <br \/>\n\nIn this notebook, I use a model train with original flower dataset and use the this model to predict the testing dataset. Then filter out the prediction with accuracy lower than 0.99 and write the testing images with high confidence into tfrec format. Thus we can use these data to retrain our new model. <br \/>\n\n## Reminder:\n\nBy the way, I already tried this method two days ago, and it didn't improve my score. But it is still hard to tell that pesudo labeling will be helpful in this competiton or not, this just my quick trial result.","20fe27e3":"![%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202020-03-08%20%E4%B8%8B%E5%8D%888.47.57.png](attachment:%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202020-03-08%20%E4%B8%8B%E5%8D%888.47.57.png)"}}