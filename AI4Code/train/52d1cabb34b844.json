{"cell_type":{"2562bdc9":"code","0da10639":"code","e3234458":"code","d653725d":"code","9211d94a":"code","3f76fdf9":"code","151a90cf":"code","d61c2583":"code","3e950774":"code","a36ba70a":"code","5c46fdd0":"code","59b59482":"code","719f18c2":"code","74526845":"code","93a67d00":"code","ab086ab2":"code","54a74e23":"code","52251f68":"code","c0e9b9ac":"code","fbda7104":"code","013a3c23":"code","5ae801c7":"code","f7b3dfd3":"code","611f5ea8":"code","e0a3d2f4":"markdown","d363ce95":"markdown","b3ce7f0e":"markdown","0cb18086":"markdown","16193ae4":"markdown","3439abbf":"markdown","46309f1d":"markdown","4f70a163":"markdown","660b3cd1":"markdown","c7adbf10":"markdown","b0a55138":"markdown","9166bd4a":"markdown","d20c4e4c":"markdown","c0a59265":"markdown","da2acdd3":"markdown","c8a5309c":"markdown","00ff2e0a":"markdown","4711d0a8":"markdown","648837d4":"markdown","4415cd79":"markdown","3199d511":"markdown","9e9d34c9":"markdown","0cbfc6c9":"markdown","df01cec3":"markdown","df0e76b7":"markdown","3968c51b":"markdown"},"source":{"2562bdc9":"import matplotlib.pyplot as plt # Biblioteca para graficar\n#instrucci\u00f3n para graficar de manera directa\n%matplotlib inline  ","0da10639":"def es_par(numero):\n    if n\u00famero % 2 == 0:\n        return True\n    else:\n        return False","e3234458":"def es_par(numero):\n    pasos = 0\n    pasos += 1\n    if numero % 2 == 0:\n        pasos += 1\n        return True, pasos\n    else:\n        pasos += 1\n        return False, pasos","d653725d":"def graficar (lista_n, funcion):\n    cantidad_pasos = []\n    for n in lista_n:\n        resultado, pasos = funcion(n)\n        cantidad_pasos.append(pasos)\n    print (lista_n)\n    print (cantidad_pasos)\n    fig, ax = plt.subplots()\n    ax.plot(lista_n, cantidad_pasos)\n    ax.set(xlabel='n', ylabel='Cantidad Pasos',\n           title='Cantidad de Pasos Vs n')\n    ax.grid()","9211d94a":"lista_n = (0,1,10,50,100,500,1000,3000,10000,100000)\ngraficar (lista_n, es_par)","3f76fdf9":"def es_primo(n):\n    resultado = True \n    if n < 2:\n        resultado = False\n    i = 2\n    while i < n:\n        if n % i == 0:\n            resultado = False\n        i += 1\n    return resultado","151a90cf":"es_primo(10)","d61c2583":"def es_primo(n):\n    pasos = 0\n    pasos += 1\n    resultado = True\n    pasos += 1\n    if n < 2:\n        pasos += 1\n        resultado = False\n    pasos += 1\n    i = 2\n    pasos += 1\n    while i < n:\n        pasos += 1\n        if n % i == 0:\n            pasos += 1\n            resultado = False\n        pasos += 1\n        i += 1\n    pasos += 1        \n    return resultado, pasos","3e950774":"n = 10\nes_primo(n)","a36ba70a":"2 * n + 1 + 2 ","5c46fdd0":"lista_n = (0, 1) #(0,1,10,23,50,85,87,100,500,1000,3000,10000,100000)\ngraficar (lista_n, es_primo)","59b59482":"# R\/\ndef ordernar(L):\n    L2 = []\n    ########\n    # Algor\u00edtmo para ordenar la lista \n    ########\n    \n    return L2","719f18c2":"# R\/\ndef ordernar(L):\n    pasos = 0\n    L2 = []\n    ########\n    # Algor\u00edtmo para ordenar la lista \n    ########\n    pass\n    # Debe retornar la cantidad de pasos\n    return L2, pasos\n\ndef generar_lista_aleatoria(n):\n    L = []\n    ####\n    # Algor\u00edtmo para generar una lista aleatoria con n n\u00fameros enteros entre 0 y n-1.\n    ####\n    return L\n\ndef ordenar_lista_aleatoria(n):\n    L = generar_lista_aleatoria(n)\n    return ordernar(L)\n","74526845":"# R\/\nimport random\nrandom.seed(20200620)\n\nlista_n = (0,1) #(0,1,10,23,50,85,87,100,500,1000,3000,10000,100000)\ngraficar (lista_n, ordenar_lista_aleatoria)\n","93a67d00":"# R\/\ndef buscar(L, x):\n    indice = None\n    ####\n    # Algoritmo\n    ####\n    return indice","ab086ab2":"# R\/\ndef buscar(L, x):\n    pasos = 0\n    pasos += 1\n    indice = None\n    ####\n    # Algoritmo\n    ####\n    pasos += 1\n    return indice, pasos","54a74e23":"L = [ 6, 4, 7, 2, 5 ]\nbuscar (L, 9)","52251f68":"def buscar_lista_aleatoria(n):\n    L = generar_lista_aleatoria(n)\n    x = len(L) + 1\n    return buscar(L, x)","c0e9b9ac":"lista_n = (0,1) #(0,1,10,23,50,85,87,100,500,1000,3000,10000,100000)\ngraficar (lista_n, buscar_lista_aleatoria)","fbda7104":"# R\/\ndef buscar_ordenada(L, x):\n    indice = None\n    ####\n    # Algoritmo\n    ####\n    return indice\n","013a3c23":"# Con conteo de pasos\ndef buscar_ordenada(L, x):\n    pasos = 0\n    pasos += 1\n    indice = None\n    ####\n    # Algoritmo\n    ####\n    pasos += 1\n    return indice, pasos","5ae801c7":"L = [ 2, 4, 5, 6, 7 ]\nbuscar_ordenada (L, 9)","f7b3dfd3":"def buscar_ordenada_lista_aleatoria(n):\n    L = generar_lista_aleatoria(n)\n    L, pasos = ordernar(L)\n    x = len(L) + 1\n    indice, pasos_busqueda = buscar_ordenada(L, x)\n    return indice, pasos_busqueda \n","611f5ea8":"lista_n = (0,1) #(0,1,10,23,50,85,87,100,500,1000,3000,10000,100000)\ngraficar (lista_n, buscar_ordenada_lista_aleatoria)","e0a3d2f4":"En la funci\u00f3n anterior, el interprete hace 2 pasos para poder determinar que un n\u00famero es par o no, el primero es la validaci\u00f3n:\n```python\nif numero % 2 == 0:\n```\ny el segundo el retorno del resultado\n\n```python\n    return True\n```\n\u00f3 \n```python \n    return False\n```\nDependiendo de cual sea.\n\nPara analizar si la cantidad de pasos depende de el valor de `n`, podemos realizar una modificaci\u00f3n a la funci\u00f3n `es_par`, para que retorne la cantidad de pasos ejecutados.","d363ce95":"# Complejidad de Algor\u00edtmos\n\nInicialmente debemos pensar en para que se hace un programa y en la mayor\u00eda de los casos se realiza para resolver un problema, es decir, plantear una soluci\u00f3n a una situaci\u00f3n que se presenta en el mundo real.\n\nCasi todos los problemas tienen al menos una soluci\u00f3n, y esos que tienen soluci\u00f3n la mayor\u00eda no solo tiene una, sino que tiene varias.\n\nSer\u00eda muy eg\u00f3latra para un desarrollador afirmar que siempre ha desarrollado la mejor soluci\u00f3n posible a un problema en part\u00edcular.\n\nEl objetivo de esta sesi\u00f3n es tener claro que existe un m\u00e9todo para poder establecer que tan eficiente es un algor\u00edtmo en particular y si justifica revisarlo para mejorarlo o no.\n\nLa complejidad algor\u00edtmica nos permite determinar el comportamiento de un algor\u00edtmo en t\u00e9rminos de tiempo de ejecuci\u00f3n, llamada *complejidad temporal* y de memoria requerida, llamada *complejidad espacial*, estos dos aspectos pueden definir si un algor\u00edtmo es eficiente o no, o si uno es mejor que otro.\n\nB\u00e1sicamente, ordenar 10 registros toma menos tiempo que ordenar 1.000 o 10.000.\n\nPor lo que la complejidad se define en funci\u00f3n de la cantidad de elementos.\n","b3ce7f0e":"**Ejercicio 7.7.** \u00bfCu\u00e1l es la Complejidad del algor\u00edtmo?","0cb18086":"**Ejercicio 7.2.** Modifique la funci\u00f3n del ejercicio **7.1** para que retorne la cantidad de pasos realiza el compilador para realizar el ordenamiento.","16193ae4":"El peor caso de ejecuci\u00f3n es cuando el elemento a buscar no se encuentra en la lista, por lo tanto vamos a probar la ejecuci\u00f3n de nuestro algoritmo con un n\u00famero que sabemos que no va a estar en la lista.","3439abbf":"R\/","46309f1d":"## Complejidad Temporal\n\nEs la funci\u00f3n definida en t\u00e9rminos de n, donde n puede ser la cantidad de elementos a recorrer o el valor num\u00e9rico que se pasa por par\u00e1metro.\n","4f70a163":"R\/","660b3cd1":"Se observa en general que hay una relaci\u00f3n directa entre el valor de n y la cantidad de pasos realizados, la funci\u00f3n es parecida a una funci\u00f3n lineal.\n\n$P(n) = A.x + B$ donde A ser\u00eda la pendiente de la funci\u00f3n y B ser\u00eda una constante.","c7adbf10":"**Ejercicio 7.3.** Realice una tabla con los valores arrojados para una lista de entrada con 1 elemento, 10 elementos, 50 elementos, 100 elementos, 500 elementos, 1.000 elementos, 3.000 elementos, 10.000 elementos y 100.000 elementos (utilice la biblioteca `random` para generar los datos).","b0a55138":"Modificamos la funci\u00f3n para contar los pasos como se hizo con la funci\u00f3n `es_par`.","9166bd4a":"## Notaci\u00f3n\n\nEn los ejemplos anteriores, encontramos una relaci\u00f3n visual entre el valor de n y la cantidad de pasos; es decir, por la forma de la gr\u00e1fica afirmamos cual es la funci\u00f3n que m\u00e1s se parece al resultado.\n\nPara simplificar ese proceso se define la funci\u00f3n Orden, para indicar la complejidad.\n\nCuando la funci\u00f3n de $P(n) = C$, donde C es una constante num\u00e9rica, se define que la complejidad del argor\u00edmo es de Orden constante, representada por $O(1)$\n\nSi la funci\u00f3n de $P(n)$, est\u00e1 definida de la forma $P(n) = An + B$, se dice que el argor\u00edtmo es de Orden lineal y se representa $O(n)$.\n\nSi la funci\u00f3n de $P(n)$, est\u00e1 definida de la forma $P(n) = An^2 + Bn + C$, se dice que el argor\u00edtmo es de Orden cuadr\u00e1tico y se representa $O(n^2)$.\n\nEn general la tabla de complejidades m\u00e1s comunes, ordenadas de m\u00e1s eficiente a menos eficiente es la siguiente:\n\n![tabla_complejidades.png](attachment:tabla_complejidades.png)","d20c4e4c":"R\/","c0a59265":"Supongamos que se desea c\u00e1lcular si un n\u00famero es par o no","da2acdd3":"## Mejorar el rendimiento del c\u00f3digo\n\nEl objetivo de ser conciente de la complejidad del argoritmo desarrollado y buscar mejorar la complejidad del mismo.  Hay varias estrategias para hacerlo y varias t\u00e9cnicas para lograr algoritmos eficientes para resolver ciertos problemas para conocerlas se requiere conocimientos previos de ciencias de la computaci\u00f3n que se salen del alcance del curso.  \n\nUtilizando procesos sencillos podemos mejorar un algoritmo.","c8a5309c":"Si n > 1:\n\n$ P(n) = 2 ( n - 2 ) + 5 + m $, m es la cantidad de divisores de n \n\n$ P(n) = 2n - 4 + 5 + m $\n\n$ P(n) = 2n + 1 + m $\n\nEn Conclusi\u00f3n, siendo `m` la cantidad de divisores de `n` \n\n$P(n) = \\left\\{ \\begin{array}{lcc}\n             6 &   si  & n \\leq 1 \\\\\n             \\\\ 2n + 1 + m &  si & n \\gt 1\n             \\end{array}\n   \\right.\n$  ","00ff2e0a":"**Ejercicio 7.9.** Realice una versi\u00f3n de la soluci\u00f3n sabiendo que la lista est\u00e1 ordenada.","4711d0a8":"**Ejercicio 7.1** Desarrolle una funci\u00f3n (sin usar el m\u00e9todo `sort`) que reciba una lista de n\u00fameros por par\u00e1metro y retorne la lista ordenada.","648837d4":"La complejidad temporal se trata de contar la cantidad de instrucciones necesarias para que el algor\u00edmo funcione.","4415cd79":"Creamos una lista de valores para ejecutar la funci\u00f3n as\u00ed determinar cuantos pasos se ejecutaron en cada una de las iteraciones.","3199d511":"**Ejercicio 7.4.** Determine con la notaci\u00f3n de Orden cual es la complejidad del la funci\u00f3n `es_par`, la funci\u00f3n `es_primo` y la funci\u00f3n `ordenar`","9e9d34c9":"**Ejercicio 7.8.** Si sabemos que la lista est\u00e1 ordenada, como podemos mejorar el algoritmo para encontrar el elemento?","0cbfc6c9":"Analicemos otro sencillo problema, una funci\u00f3n que retorne si un n\u00famero es primo o no.","df01cec3":"**Ejercicio 7.5.** Soponga que se tiene un lista de `n` n\u00fameros y se requiere encontrar en que posici\u00f3n se encuentra un elemento `x`.","df0e76b7":"**Ejercicio 7.6.** Modifique la funci\u00f3n `buscar` para que cuente los pasos y los retorne como en los ejercicios anteriores.","3968c51b":"Se observa que la cantidad de pasos de la funci\u00f3n siempre es 2 y no crece ni disminuye con un valor diferente de n. Si consideramos `n` como el valor que se env\u00eda por par\u00e1metro, podemos afirmar que la cantidad de pasos (Funci\u00f3n P) en t\u00e9rminos de n, siempre ser\u00e1 2.\n\n$P(n) = 2$"}}