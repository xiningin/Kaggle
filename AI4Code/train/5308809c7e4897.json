{"cell_type":{"bac761ce":"code","742ac663":"code","8835e346":"code","cee98a82":"code","ddbae66a":"code","48aafd70":"code","749aed1c":"code","c6fa2507":"code","9effdd9b":"code","6ef7d798":"markdown","abc143cc":"markdown"},"source":{"bac761ce":"import gc\nimport math\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\npd.set_option('mode.chained_assignment', None)","742ac663":"train = pd.read_csv('..\/input\/train.csv')","8835e346":"structures = pd.read_csv('..\/input\/structures.csv')","cee98a82":"train.head()","ddbae66a":"structures.head()","48aafd70":"rawimagedata = {}\nsizesofmatrices = {}\n\nfor k,groupdf in tqdm((structures.groupby('molecule_name'))):\n    # I am just mapping the atom types to numerics as an example feel free to one hot encode them\n    groupdf.atom =  groupdf.atom.map({'H': 1, 'C': 2, 'N':3,'O':4,'F':5})\n    inputimage = groupdf.merge(groupdf,on=['molecule_name'],how='outer')\n    #Fermi Contact seems to love r^-3!\n    inputimage['recipdistancecubed'] = 1\/np.sqrt((inputimage.x_x-inputimage.x_y)**2+\n                                                 (inputimage.y_x-inputimage.y_y)**2+\n                                                 (inputimage.z_x-inputimage.z_y)**2)**3\n    inputimage.recipdistancecubed = inputimage.recipdistancecubed.replace(np.inf,0)\n    sizesofmatrices[k] = int(math.sqrt(inputimage.shape[0]))\n    rawimagedata[k] = inputimage[['atom_x','atom_y','recipdistancecubed']].values.reshape(sizesofmatrices[k],sizesofmatrices[k],3)\n    break","749aed1c":"targetimages = {}\nfor k,groupdf in tqdm((train.groupby('molecule_name'))):\n\n    outputimage = pd.DataFrame({'molecule_name':k,'atom_index':np.arange(sizesofmatrices[k])})\n    outputimage = outputimage.merge(outputimage,on=['molecule_name'],how='outer')\n    outputimage = outputimage.merge(groupdf,\n                                    left_on=['molecule_name','atom_index_x','atom_index_y'],\n                                    right_on=['molecule_name','atom_index_0','atom_index_1'],how='left')\n    outputimage = outputimage.merge(groupdf,\n                                    left_on=['molecule_name','atom_index_x','atom_index_y'],\n                                    right_on=['molecule_name','atom_index_1','atom_index_0'],how='left')\n    outputimage['sc'] = outputimage.scalar_coupling_constant_x.fillna(0)+outputimage.scalar_coupling_constant_y.fillna(0)\n    targetimages[k] = outputimage[['sc']].values.reshape(sizesofmatrices[k],sizesofmatrices[k])\n    break","c6fa2507":"rawimagedata['dsgdb9nsd_000001']","9effdd9b":"targetimages['dsgdb9nsd_000001']","6ef7d798":"Note the output target matrix is symmetric so you will get better results averaging (x,y) with (y,x)","abc143cc":"Let us convert the problem into a standard Neural Network Image problem whereby we take an input image and produce an output image - have a look at the many kaggle comptetions that use RLE or run length encoding!\n\nThe idea here is to create \"images\" for every molecule\n\nWe will then create a target output \"image\" for each molecule and you should then train your favourite NN to reproduce the output target images\n\nOnce you have done that, you can grab the actual scalar coupling constants by just looking up there values from the 2d matrix output from your neural network\n\n(As these matrices are symmetric you should average over (x,y) and (y,x) indices)\n\nNote I am producing the smallest possible matrices to save memory - it will be up to you to create a generator to expand them to 29 by 29.\n\nGood Luck"}}