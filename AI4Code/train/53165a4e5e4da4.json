{"cell_type":{"9615d3cb":"code","c9eb087d":"code","00b7e9ef":"code","b7a4715e":"code","2b183dea":"code","3892bf28":"code","2438bd9c":"code","637ee5a2":"code","9ae4e278":"code","7970ad1a":"code","b66d01ec":"code","30d24902":"code","24abadb8":"code","e72e5662":"code","0bbe4b4f":"code","d33172f4":"code","732b8741":"code","4c97e480":"code","5817e70c":"code","2e01a2c4":"code","421de1c7":"code","0e1a9ae8":"code","7392f0f8":"code","efe67a69":"code","5e51a7e9":"code","cd765be6":"code","e37bb5e4":"code","81417a45":"code","fe29cbb4":"code","d85c92ca":"code","392c6618":"code","0be0c859":"code","b4a540d7":"code","dd737672":"code","d5cd0e96":"code","46035b42":"code","ea8b9342":"code","a63972bd":"code","9774aee3":"code","4318e7d7":"code","a5260747":"code","fdbe5296":"code","026ab4af":"code","3925ad9b":"code","f05e0a76":"code","a0e707f5":"code","5372309e":"code","7cc4f357":"code","3060b424":"code","2acea873":"code","6ee89b3b":"code","c8d197d3":"code","8dc903ac":"code","2d8481a4":"code","1ce7a208":"code","842a4c7a":"code","6e904224":"code","b41985a4":"code","491102d2":"code","8631b732":"code","bf8cb155":"code","48dfc4b6":"code","0f508f63":"code","82babc2c":"code","e5040596":"code","e4a829f7":"code","a2a65c37":"code","f101c3cd":"code","a7489251":"code","d061ae1d":"code","1729f069":"code","9243421e":"code","4c3fb364":"code","84d46064":"code","d0a31e6c":"code","c81e7334":"code","509f3859":"code","1bccecd1":"code","4ec86746":"code","27f53377":"code","818611a0":"code","15d6d474":"code","338a7787":"code","01ee8462":"code","719ad1ec":"code","9f4d9012":"code","59702dce":"code","a655ffa9":"code","6a92da9a":"code","5f113530":"code","546ab948":"code","40108359":"code","9f429619":"code","82b2bdf3":"code","0d66e4dd":"code","df5b0212":"code","e2b15a5e":"code","dfa7c1a3":"code","e041b7f2":"code","993672d7":"code","95607f63":"code","9fbab52d":"code","7cca5935":"code","36d21b54":"code","91c7902b":"code","70e6f72d":"code","b047c44c":"code","adac2beb":"code","0f591650":"code","08f70e2a":"code","1cd8996d":"code","3dbe0b1d":"code","f802501b":"code","9943e401":"code","f12a0f72":"code","5e1a83e8":"code","3c559931":"code","29a504e7":"code","5fb6626b":"code","a80005e6":"code","40b025fa":"code","11744623":"code","b75296b7":"code","c82e581b":"code","a95b5d3f":"code","13b4a458":"code","f97b2305":"code","17a0956e":"code","88cd72f5":"code","d2f012dd":"code","38738433":"code","d74e304b":"code","ce3a2b3c":"code","10664d84":"code","55047372":"code","67c04c52":"code","3ae3dfbd":"code","50433735":"code","f4216fe2":"code","b35a2a51":"code","4df16ac4":"code","32cd77cb":"code","ca7f5a81":"code","e0252380":"code","a2b0e760":"code","53f12adf":"code","5be17100":"code","ca905074":"code","95fee54d":"code","18725ef6":"code","52f47c27":"code","0441e1a1":"code","2c8ce26a":"code","289792e8":"code","0ada9ed8":"code","398d49e7":"code","7c9d7b44":"code","99c80978":"code","d693c0ba":"code","9ab1f4c9":"code","5d701151":"code","22605865":"code","b6cb4af9":"code","70c4909e":"code","b5513709":"code","0642adbb":"code","b96d6015":"code","71a8d1ef":"code","1efe708e":"code","5af72ebb":"markdown","91283b75":"markdown","34e91304":"markdown","d64cd4bb":"markdown","95e5e676":"markdown","fcafe560":"markdown","e1263f2d":"markdown","692dd525":"markdown","f781f61e":"markdown","2fd44ee7":"markdown","f7105e62":"markdown","74a8b9fb":"markdown","35e2492e":"markdown","647cb269":"markdown","e9f99419":"markdown","f86e1f51":"markdown","202d4dad":"markdown","c72eab66":"markdown","98bfd945":"markdown","77926d73":"markdown","f0274b4b":"markdown","bcb58a84":"markdown","4ca00597":"markdown","6dd68f5c":"markdown","afed0b61":"markdown","36d114a0":"markdown","283650aa":"markdown","f1c0c472":"markdown","073f3579":"markdown","ac2b5743":"markdown","995d19ab":"markdown","45849b9d":"markdown","c794aa65":"markdown","fd771ddb":"markdown","388bbe6f":"markdown","be84745a":"markdown","e39b1bf9":"markdown","74ed6cc3":"markdown","a0eb8cd1":"markdown","00fd9592":"markdown","bc583dac":"markdown","98f3f1b6":"markdown","8a9787a1":"markdown","db3324c4":"markdown","453d6cfb":"markdown","eb5a8266":"markdown","690a35c1":"markdown","53619e56":"markdown","b1dc6b49":"markdown","30b0b277":"markdown","988a22ed":"markdown","12fd5563":"markdown","e42367ae":"markdown","39067073":"markdown","0353dfe5":"markdown","6eba1722":"markdown","bcd2794f":"markdown","6d39990d":"markdown","e2916f00":"markdown","c958b11c":"markdown","3ada1fc7":"markdown","0cbc2fd0":"markdown","d283f0c4":"markdown","5e87d3b4":"markdown","1c7ebecf":"markdown","e8e6c882":"markdown","3a04eb6f":"markdown","08273a7b":"markdown","4ea72a4d":"markdown","10f99611":"markdown","1b2e2148":"markdown","92babf34":"markdown","0b967289":"markdown","75fb6ad4":"markdown","505c68cf":"markdown","07beb87c":"markdown","2602d11a":"markdown","d8665fd9":"markdown","0ff5d179":"markdown","e898b628":"markdown","4183a519":"markdown","7b96466b":"markdown","a37ec0c1":"markdown","24d7c4b8":"markdown","1b286bcc":"markdown","f076df66":"markdown","d560ea79":"markdown","5b48da41":"markdown","49d2948b":"markdown","603e71f8":"markdown","79c2dba1":"markdown","20dfc9fe":"markdown","36d4e046":"markdown","5aac1fc5":"markdown","61279318":"markdown","5da8904a":"markdown","0c929238":"markdown","27613a58":"markdown","7650f66c":"markdown","a6ce3c2b":"markdown","22b2bd19":"markdown","cf083169":"markdown","ea77af6a":"markdown","2e17433d":"markdown","7d69e28b":"markdown","4e05781e":"markdown","0cc82675":"markdown","f70b7f0b":"markdown","02e6dcaf":"markdown","90fff3f2":"markdown","cb10a45c":"markdown","12b11668":"markdown","c2e66e9a":"markdown","b545c38e":"markdown","f23eedd4":"markdown","400c2af2":"markdown"},"source":{"9615d3cb":"from numpy import *","c9eb087d":"import matplotlib.pyplot as plt\n%matplotlib inline","00b7e9ef":"# a vector: the argument to the array function is a Python list\nv = array([1,2,3,4])\n\nv","b7a4715e":"# a matrix: the argument to the array function is a nested Python list\nM = array([[1, 2], [3, 4]])\n\nM","2b183dea":"type(v), type(M)","3892bf28":"v.shape","2438bd9c":"M.shape","637ee5a2":"M.size","9ae4e278":"shape(M)","7970ad1a":"size(M)","b66d01ec":"M.dtype","30d24902":"M[0,0] = \"hello\"","24abadb8":"M = array([[1, 2], [3, 4]], dtype=complex)\n\nM","e72e5662":"# create a range\nx = arange(0, 10, 1) # arguments: start, stop, step\n\nx","0bbe4b4f":"x = arange(-1, 1, 0.1)\n\nx","d33172f4":"# using linspace, both end points ARE included\nlinspace(0, 10, 25)","732b8741":"logspace(0, 10, 10, base=e)","4c97e480":"x, y = mgrid[0:5, 0:5] # similar to meshgrid in MATLAB","5817e70c":"x","2e01a2c4":"y","421de1c7":"from numpy import random","0e1a9ae8":"# uniform random numbers in [0,1]\nrandom.rand(5,5)","7392f0f8":"# standard normal distributed random numbers\nrandom.randn(5,5)","efe67a69":"# a diagonal matrix\ndiag([1,2,3])","5e51a7e9":"# diagonal with offset from the main diagonal\ndiag([1,2,3], k=1) ","cd765be6":"zeros((3,3))","e37bb5e4":"ones((3,3))","81417a45":"#Download input file\n!wget https:\/\/git.ecdf.ed.ac.uk\/digital-skills\/python-data-science\/raw\/72f7777a4a3ced24f2d75ffc77533b9d3abc4c57\/data\/stockholm_td_adj.dat","fe29cbb4":"data = genfromtxt('.\/stockholm_td_adj.dat.1')","d85c92ca":"data.shape","392c6618":"fig, ax = plt.subplots(figsize=(14,4))\nax.plot(data[:,0]+data[:,1]\/12.0+data[:,2]\/365, data[:,5])\nax.axis('tight')\nax.set_title('tempeatures in Stockholm')\nax.set_xlabel('year')\nax.set_ylabel('temperature (C)');","0be0c859":"M = random.rand(3,3)\n\nM","b4a540d7":"savetxt(\"random-matrix.csv\", M)","dd737672":"!cat random-matrix.csv","d5cd0e96":"savetxt(\"random-matrix.csv\", M, fmt='%.5f') # fmt specifies the format\n\n!cat random-matrix.csv","46035b42":"save(\"random-matrix.npy\", M)\n\n!file random-matrix.npy","ea8b9342":"load(\"random-matrix.npy\")","a63972bd":"M.itemsize # bytes per element","9774aee3":"M.nbytes # number of bytes","4318e7d7":"M.ndim # number of dimensions","a5260747":"# v is a vector, and has only one dimension, taking one index\nv[0]","fdbe5296":"# M is a matrix, or a 2 dimensional array, taking two indices \nM[1,1]","026ab4af":"M","3925ad9b":"M[1]","f05e0a76":"M[1,:] # row 1","a0e707f5":"M[:,1] # column 1","5372309e":"M[0,0] = 1","7cc4f357":"M","3060b424":"# also works for rows and columns\nM[1,:] = 0\nM[:,2] = -1","2acea873":"M","6ee89b3b":"A = array([1,2,3,4,5])\nA","c8d197d3":"A[1:3]","8dc903ac":"A[1:3] = [-2,-3]\n\nA","2d8481a4":"A[::] # lower, upper, step all take the default values","1ce7a208":"A[::2] # step is 2, lower and upper defaults to the beginning and end of the array","842a4c7a":"A[:3] # first three elements","6e904224":"A[3:] # elements from index 3","b41985a4":"A = array([1,2,3,4,5])","491102d2":"A[-1] # the last element in the array","8631b732":"A[-3:] # the last three elements","bf8cb155":"A = array([[n+m*10 for n in range(5)] for m in range(5)])\n\nA","48dfc4b6":"# a block from the original array\nA[1:4, 1:4]","0f508f63":"# strides\nA[::2, ::2]","82babc2c":"row_indices = [1, 2, 3]\nA[row_indices]","e5040596":"col_indices = [1, 2, -1] # remember, index -1 means the last element\nA[row_indices, col_indices]","e4a829f7":"B = array([n for n in range(5)])\nB","a2a65c37":"row_mask = array([True, False, True, False, False])\nB[row_mask]","f101c3cd":"# same thing\nrow_mask = array([1,0,1,0,0], dtype=bool)\nB[row_mask]","a7489251":"x = arange(0, 10, 0.5)\nx","d061ae1d":"mask = (5 < x) * (x < 7.5)\nmask","1729f069":"x[mask]","9243421e":"indices = where(mask)\n\nindices","4c3fb364":"x[indices] # this indexing is equivalent to the fancy indexing x[mask]","84d46064":"diag(A)","d0a31e6c":"diag(A, -1)","c81e7334":"v2 = arange(-3,3)\nv2","509f3859":"row_indices = [1, 3, 5]\nv2[row_indices] # fancy indexing","1bccecd1":"v2.take(row_indices)","4ec86746":"take([-3, -2, -1,  0,  1,  2], row_indices)","27f53377":"which = [1, 0, 1, 0]\nchoices = [[-2,-2,-2,-2], [5,5,5,5]]\n\nchoose(which, choices)","818611a0":"v1 = arange(0, 5)","15d6d474":"v1 * 2","338a7787":"v1 + 2","01ee8462":"A * 2, A + 2","719ad1ec":"A * A","9f4d9012":"v1 * v1","59702dce":"A.shape, v1.shape","a655ffa9":"A * v1","6a92da9a":"dot(A, A)","5f113530":"dot(A, v1)","546ab948":"dot(v1, v1)","40108359":"M = matrix(A)\nv = matrix(v1).T # make it a column vector","9f429619":"v","82b2bdf3":"M * M","0d66e4dd":"M * v","df5b0212":"# inner product\nv.T * v","e2b15a5e":"# with matrix objects, standard matrix algebra applies\nv + M*v","dfa7c1a3":"v = matrix([1,2,3,4,5,6]).T","e041b7f2":"shape(M), shape(v)","993672d7":"C = matrix([[1j, 2j], [3j, 4j]])\nC","95607f63":"conjugate(C)","9fbab52d":"C.H","7cca5935":"real(C) # same as: C.real","36d21b54":"imag(C) # same as: C.imag","91c7902b":"angle(C+1) # heads up MATLAB Users, angle is used instead of arg","70e6f72d":"abs(C)","b047c44c":"linalg.inv(C) # equivalent to C.I ","adac2beb":"C.I * C","0f591650":"linalg.det(C)","08f70e2a":"linalg.det(C.I)","1cd8996d":"# reminder, the tempeature dataset is stored in the data variable:\nshape(data)","3dbe0b1d":"# the temperature data is in column 3\nmean(data[:,3])","f802501b":"std(data[:,3]), var(data[:,3])","9943e401":"# lowest daily average temperature\ndata[:,3].min()","f12a0f72":"# highest daily average temperature\ndata[:,3].max()","5e1a83e8":"d = arange(0, 10)\nd","3c559931":"# sum up all elements\nsum(d)","29a504e7":"# product of all elements\nprod(d+1)","5fb6626b":"# cummulative sum\ncumsum(d)","a80005e6":"# cummulative product\ncumprod(d+1)","40b025fa":"# same as: diag(A).sum()\ntrace(A)","11744623":"!head -n 3 stockholm_td_adj.dat.1","b75296b7":"unique(data[:,1]) # the month column takes values from 1 to 12","c82e581b":"mask_feb = data[:,1] == 2","a95b5d3f":"# the temperature data is in column 3\nmean(data[mask_feb,3])","13b4a458":"months = arange(1,13)\nmonthly_mean = [mean(data[data[:,1] == month, 3]) for month in months]\n\nfig, ax = plt.subplots()\nax.bar(months, monthly_mean)\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Monthly average temperature\");","f97b2305":"m = random.rand(3,3)\nm","17a0956e":"# global max\nm.max()","88cd72f5":"# max in each column\nm.max(axis=0)","d2f012dd":"# max in each row\nm.max(axis=1)","38738433":"A","d74e304b":"n, m = A.shape","ce3a2b3c":"B = A.reshape((1,n*m))\nB","10664d84":"B[0,0:5] = 5 # modify the array\n\nB","55047372":"A # and the original variable is also changed. B is only a different view of the same data","67c04c52":"B = A.flatten()\n\nB","3ae3dfbd":"B[0:5] = 10\n\nB","50433735":"A # now A has not changed, because B's data is a copy of A's, not refering to the same data","f4216fe2":"v = array([1,2,3])","b35a2a51":"shape(v)","4df16ac4":"# make a column matrix of the vector v\nv[:, newaxis]","32cd77cb":"# column matrix\nv[:,newaxis].shape","ca7f5a81":"# row matrix\nv[newaxis,:].shape","e0252380":"a = array([[1, 2], [3, 4]])","a2b0e760":"# repeat each element 3 times\nrepeat(a, 3)","53f12adf":"# tile the matrix 3 times \ntile(a, 3)","5be17100":"b = array([[5, 6]])","ca905074":"concatenate((a, b), axis=0)","95fee54d":"concatenate((a, b.T), axis=1)","18725ef6":"vstack((a,b))","52f47c27":"hstack((a,b.T))","0441e1a1":"A = array([[1, 2], [3, 4]])\n\nA","2c8ce26a":"# now B is referring to the same array data as A \nB = A ","289792e8":"# changing B affects A\nB[0,0] = 10\n\nB","0ada9ed8":"A","398d49e7":"B = copy(A)","7c9d7b44":"# now, if we modify B, A is not affected\nB[0,0] = -5\n\nB","99c80978":"A","d693c0ba":"v = array([1,2,3,4])\n\nfor element in v:\n    print(element)","9ab1f4c9":"M = array([[1,2], [3,4]])\n\nfor row in M:\n    print(\"row\", row)\n    \n    for element in row:\n        print(element)","5d701151":"for row_idx, row in enumerate(M):\n    print(\"row_idx\", row_idx, \"row\", row)\n    \n    for col_idx, element in enumerate(row):\n        print(\"col_idx\", col_idx, \"element\", element)\n       \n        # update the matrix M: square each element\n        M[row_idx, col_idx] = element ** 2","22605865":"# each element in M is now squared\nM","b6cb4af9":"M","70c4909e":"if (M > 5).any():\n    print(\"at least one element in M is larger than 5\")\nelse:\n    print(\"no element in M is larger than 5\")","b5513709":"if (M > 5).all():\n    print(\"all elements in M are larger than 5\")\nelse:\n    print(\"all elements in M are not larger than 5\")","0642adbb":"M.dtype","b96d6015":"M2 = M.astype(float)\n\nM2","71a8d1ef":"M2.dtype","1efe708e":"M3 = M.astype(bool)\n\nM3","5af72ebb":"## Further reading","91283b75":"### mgrid\n\nThe `mgrid()` function is used to get a dense multi-dimensional 'meshgrid'.","34e91304":"If we try to add, subtract or multiply objects with incomplatible shapes we get an error:","d64cd4bb":"### Numpy's native file format","95e5e676":"Generally, we want to avoid iterating over the elements of arrays whenever we can (at all costs). The reason is that in a interpreted language like Python (or MATLAB), iterations are really slow compared to vectorized operations. \n\nHowever, sometimes iterations are unavoidable. For such cases, the Python `for` loop is the most convenient way to iterate over an array:","fcafe560":"### diag","e1263f2d":"Alternatively, we can cast the array objects to the type `matrix`. This changes the behavior of the standard arithmetic operators `+, -, *` to use matrix algebra.","692dd525":"We can also use the function `flatten` to make a higher-dimensional array into a vector. But this function create a copy of the data.","f781f61e":"## Reshaping, resizing and stacking arrays","2fd44ee7":"### hstack and vstack\n\nWith `hstack` you can appened data horizontally. \n\nWith `vstack` you can appened data vertically","f7105e62":"Common data types that can be used with `dtype` are: `int`, `float`, `complex`, `bool`, `object`, etc.\n\nWe can also explicitly define the bit size of the data types, for example: `int64`, `int16`, `float128`, `complex128`.","74a8b9fb":"When functions such as `min`, `max`, etc. are applied to a multidimensional arrays, it is sometimes useful to apply the calculation to the entire array, and sometimes only on a row or column basis. Using the `axis` argument we can specify how these functions should behave: ","35e2492e":"#### min and max","647cb269":"There are a number of ways to initialize new numpy arrays, for example from\n\n* a Python list or tuples\n* using functions that are dedicated to generating numpy arrays, such as `arange`, `linspace`, etc.\n* reading data from files","e9f99419":"To use `numpy` you need to import the module.","f86e1f51":"Index slicing is the technical name for the syntax `M[lower:upper:step]` to extract part of an array:\n\nRead more about index slicing in python here: https:\/\/www.w3schools.com\/python\/numpy_array_slicing.asp\n","202d4dad":"Vectorizing code is the key to writing efficient numerical calculation with Python\/Numpy. That means that as much as possible of a program should be formulated in terms of matrix and vector operations, like matrix-matrix multiplication.","c72eab66":"When using arrays in conditions,for example `if` statements and other boolean expressions, one needs to use `any` or `all`, which requires that any or all elements in the array evalutes to `True`:","98bfd945":"We can omit any of the three parameters in `M[lower:upper:step]`:","77926d73":"## Linear algebra","f0274b4b":"#### mean","bcb58a84":"Since Numpy arrays are *statically typed*, the type of an array does not change once created. But we can explicitly cast an array of some type to another using the `astype` functions (see also the similar `asarray` function). This always create a new array of new type:","4ca00597":"## Copy and \"deep copy\"","6dd68f5c":"### What is NumPy?\n\nNumPy is a Python library used for working with arrays. It also has functions for working in domain of linear algebra, fourier transform, and matrices. NumPy was created in 2005 by Travis Oliphant. It is an open source project and you can use it freely.\n\n**NumPy stands for Numerical Python.**","afed0b61":"### Matrix algebra","36d114a0":"If we multiply arrays with compatible shapes, we get an element-wise multiplication of each row:","283650aa":"## Using arrays in conditions","f1c0c472":"Constructs an array by picking elements from several arrays:","073f3579":"### choose","ac2b5743":"### zeros and ones\n\n`np.zeros` Python function is used to create a matrix full of zeroes. `np.zeros()` in Python can be used when you initialize the weights during the first iteration in TensorFlow and other statistic tasks.\n\n`np.ones()` function is used to create a matrix full of ones. `numpy.ones()` in Python can be used when you initialize the weights during the first iteration in TensorFlow and other statistic tasks.","995d19ab":"### Computations on subsets of arrays","45849b9d":"### Element-wise array-array operations","c794aa65":"Above we have used the `.T` to transpose the matrix object `v`. We could also have used the `transpose` function to accomplish the same thing. \n\nOther mathematical functions that transform matrix objects are:","fd771ddb":"### Array\/Matrix transformations","388bbe6f":"## More properties of the numpy arrays","be84745a":"The `take` function is similar to fancy indexing described above:","e39b1bf9":"The dataformat is: year, month, day, daily average temperature, low, high, location.\n\nIf we are interested in the average temperature only in a particular month, say February, then we can create a index mask and use it to select only the data for that month using:","74ed6cc3":"### Using array-generating functions","a0eb8cd1":"### where","00fd9592":"With `newaxis`, we can insert new dimensions in an array, for example converting a vector to a column or row matrix:","bc583dac":"The `v` and `M` objects are both of the type `ndarray` that the `numpy` module provides.","98f3f1b6":"## Functions for extracting data from arrays and creating arrays","8a9787a1":"### Calculations with higher-dimensional data","db3324c4":"Using function `repeat`, `tile`, `vstack`, `hstack`, and `concatenate` we can create larger vectors and matrices from smaller ones:","453d6cfb":"Fancy indexing is the name for when an array or list is used in-place of an index: ","eb5a8266":"#### Inverse","690a35c1":"When we need to iterate over each element of an array and modify its elements, it is convenient to use the `enumerate` function to obtain both the element and its index in the `for` loop: ","53619e56":"## Stacking and repeating arrays","b1dc6b49":"The daily mean temperature in Stockholm over the last 200 years has been about 6.2 C.","30b0b277":"The difference between the `v` and `M` arrays is only their shapes. We can get information about the shape of an array by using the `ndarray.shape` property.","988a22ed":"### Comma-separated values (CSV)","12fd5563":"# Numpy -  multidimensional data arrays","e42367ae":"#### Determinant","39067073":"### diag\n\nExtract a diagonal or construct a diagonal array.","0353dfe5":"### take","6eba1722":"In the `numpy` package the terminology used for vectors, matrices and higher-dimensional data sets is *array*. \n\n","bcd2794f":"### Matrix computations","6d39990d":"We can index elements in an array using square brackets and indices:","e2916f00":"The index mask can be converted to position index using the `where` function","c958b11c":"#### sum, prod, and trace","3ada1fc7":"For larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in `numpy` that generate arrays of different forms. Some of the more common are:","0cbc2fd0":"This feature is very useful to conditionally select elements from an array, using for example comparison operators:","d283f0c4":"With these tools we have very powerful data processing capabilities at our disposal. For example, to extract the average monthly average temperatures for each month of the year only takes a few lines of code: ","5e87d3b4":"#### standard deviations and variance","1c7ebecf":"What about matrix mutiplication? There are two ways. We can either use the `dot` function, which applies a matrix-matrix, matrix-vector, or inner vector multiplication to its two arguments: ","e8e6c882":"### From lists","3a04eb6f":"Array slices are *mutable*: if they are assigned a new value the original array from which the slice was extracted is modified:","08273a7b":"To achieve high performance, assignments in Python usually do not copy the underlaying objects. This is important for example when objects are passed between functions, to avoid an excessive amount of memory copying when it is not necessary (technical term: pass by reference). ","4ea72a4d":"### Choosing NumPy: The Benefits\n\nSince you already know Python, you may be asking yourself if you really have to learn a whole new paradigm to do data science. Python\u2019s for loops are awesome! Reading and writing CSV files can be done with traditional code. However, there are some convincing arguments for learning a new paradigm.\n\n### Here are the top four benefits that NumPy can bring to your code:\n\n**More speed:** NumPy uses algorithms written in C that complete in nanoseconds rather than seconds.\n\n**Fewer loops:** NumPy helps you to reduce loops and keep from getting tangled up in iteration indices.\n\n**Clearer code:** Without loops, your code will look more like the equations you\u2019re trying to calculate.\n\n**Better quality:** There are thousands of contributors working to keep NumPy fast, friendly, and bug free.\n\nBecause of these benefits, NumPy is the de facto standard for multidimensional arrays in Python data science, and many of the most popular libraries are built on top of it. Learning NumPy is a great way to set down a solid foundation as you expand your knowledge into more specific areas of data science.","10f99611":"### concatenate","1b2e2148":"Many other functions and methods in the `array` and `matrix` classes accept the same (optional) `axis` keyword argument.","92babf34":"### Data processing","0b967289":"## Introduction","75fb6ad4":"If we want, we can explicitly define the type of the array data when we create it, using the `dtype` keyword argument: ","505c68cf":"### tile and repeat","07beb87c":"We can also use index masks: If the index mask is an Numpy array of data type `bool`, then an element is selected (True) or not (False) depending on the value of the index mask at the position of each element: ","2602d11a":"### random data\n\nNumPy offers the `random` module to work with random numbers. The random module's `rand()` method returns a random float between 0 and 1.","d8665fd9":"We can extract the real and imaginary parts of complex-valued arrays using `real` and `imag`:","0ff5d179":"### Scalar-array operations","e898b628":"Useful when storing and reading back numpy array data. Use the functions `numpy.save` and `numpy.load`:","4183a519":"When we add, subtract, multiply and divide arrays with each other, the default behaviour is **element-wise** operations:","7b96466b":"## Iterating over array elements","a37ec0c1":"We can use the usual arithmetic operators to multiply, add, subtract, and divide arrays with scalar numbers.","24d7c4b8":"## Type casting","1b286bcc":"Often it is useful to store datasets in Numpy arrays. Numpy provides a number of functions to calculate statistics of datasets in arrays. \n\nFor example, let's calculate some properties from the Stockholm temperature dataset used above.","f076df66":"But `take` also works on lists and other objects:","d560ea79":"Equivalently, we can use the function `numpy.shape` and `numpy.size`","5b48da41":"If we want to avoid this behavior, so that when we get a new completely independent object `B` copied from `A`, then we need to do a so-called \"deep copy\" using the function `copy`:","49d2948b":"We can assign new values to elements in an array using indexing:","603e71f8":"## Manipulating arrays","79c2dba1":"## Creating `numpy` arrays","20dfc9fe":"### arange\n\n`arange()` is one of the array creation routines based on numerical ranges. It creates an instance of ndarray with evenly spaced values and returns the reference to it.","36d4e046":"### Fancy indexing","5aac1fc5":"The shape of an Numpy array can be modified without copying the underlaying data, which makes it a fast operation even for large arrays.","61279318":"Index slicing works exactly the same way for multidimensional arrays:","5da8904a":"A very common file format for data files is comma-separated values (CSV), or related formats such as TSV (tab-separated values). To read data from such files into Numpy arrays we can use the `numpy.genfromtxt` function. For example, ","0c929238":"* http:\/\/numpy.scipy.org\n* http:\/\/scipy.org\/Tentative_NumPy_Tutorial\n* http:\/\/scipy.org\/NumPy_for_Matlab_Users - A Numpy guide for MATLAB users.","27613a58":"We can compute with subsets of the data in an array using indexing, fancy indexing, and the other methods of extracting data from an array (described above).\n\nFor example, let's go back to the temperature dataset:","7650f66c":"See also the related functions: `inner`, `outer`, `cross`, `kron`, `tensordot`. Try for example `help(kron)`.","a6ce3c2b":"For example, to create new vector and matrix arrays from Python lists we can use the `numpy.array` function.","22b2bd19":"### linspace and logspace\n\n**Linspace:** Linspace gives evenly spaced samples.\n\n**LogSpace:** LogSpace returns even spaced numbers on a log scale. Logspace has the same parameters as np.linspace.","cf083169":"Import matplotlib for visualizing numpy arrays.","ea77af6a":"## Adding a new dimension: newaxis","2e17433d":"Or the complex argument and absolute value","7d69e28b":"## File I\/O","4e05781e":"Using `numpy.savetxt` we can store a Numpy array to a file in CSV format:","0cc82675":"If we omit an index of a multidimensional array it returns the whole row (or, in general, a N-1 dimensional array) ","f70b7f0b":"Negative indices counts from the end of the array (positive index from the begining):","02e6dcaf":"Hermitian conjugate: transpose + conjugate","90fff3f2":"### Indexing","cb10a45c":"The same thing can be achieved with using `:` instead of an index: ","12b11668":"### Index slicing","c2e66e9a":"With the diag function we can also extract the diagonal and subdiagonals of an array:","b545c38e":"So far the `numpy.ndarray` looks awefully much like a Python list (or nested list). Why not simply use Python lists for computations instead of creating a new array type? \n\nThere are several reasons:\n\n* Python lists are very general. They can contain any kind of object. They are dynamically typed. They do not support mathematical functions such as matrix and dot multiplications, etc. Implementing such functions for Python lists would not be very efficient because of the dynamic typing.\n* Numpy arrays are **statically typed** and **homogeneous**. The type of the elements is determined when the array is created.\n* Numpy arrays are memory efficient.\n* Because of the static typing, fast implementation of mathematical functions such as multiplication and addition of `numpy` arrays can be implemented in a compiled language (C and Fortran is used).\n\nUsing the `dtype` (data type) property of an `ndarray`, we can see what type the data of an array has:","f23eedd4":"We get an error if we try to assign a value of the wrong type to an element in a numpy array:","400c2af2":"The number of elements in the array is available through the `ndarray.size` property:"}}