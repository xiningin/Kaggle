{"cell_type":{"266bd000":"code","1e8f77ad":"code","3ee82b91":"code","f446d136":"code","fa95da90":"code","2085daba":"markdown","4a548519":"markdown","844ea34e":"markdown","ae3e471a":"markdown","a928def8":"markdown"},"source":{"266bd000":"from kaggle_environments import make, evaluate\nfrom matplotlib import pyplot as plt\nfrom difflib import SequenceMatcher\nfrom tqdm import tqdm\nimport random\nimport numpy as np","1e8f77ad":"%%writefile genetics.py\nimport random\nfrom difflib import SequenceMatcher\n\nclass Genetics:\n    '''\n        Implementation of Genetics Algorithm\n    '''\n    class Individual:\n        def __init__(self, string, fitness=0):\n            self.string = string\n            self.fitness = fitness\n\n    def __init__(self, size, num_generations=150, population_size=900, mutation_rate=0.01):\n        self.alphabet = \"012\"\n        self.target = ''.join(random.choices(self.alphabet,k=size))\n        self.num_generations = num_generations\n        self.population_size = population_size\n        self.str_len = len(self.target)\n        self.mutation_rate = mutation_rate\n      \n    def generate_population(self):\n        pop_fit = []\n        pop = self.spawn_population(size=self.population_size, length=self.str_len)\n        done = False\n        for gen in range(self.num_generations):\n            pop, avg_fit = self.evaluate_population(pop, self.target)\n            pop_fit.append(avg_fit)\n            new_pop = self.next_generation(pop, \\\n                size=self.population_size, length=self.str_len, mut_rate=self.mutation_rate)\n            pop = new_pop\n            for x in pop: \n                if x.string == self.target: \n                    done = True\n            if done:\n                break\n        return pop\n    \n    def similar(self, a, b):\n        return SequenceMatcher(None, a, b).ratio()\n    \n    def spawn_population(self, length=26,size=100):\n        pop = []\n        for i in range(size):\n            string = ''.join(random.choices(self.alphabet,k=length))\n            individual = self.Individual(string)\n            pop.append(individual)\n        return pop\n    \n    def recombine(self, p1_, p2_):\n        p1 = p1_.string\n        p2 = p2_.string\n        child1 = []\n        child2 = []\n        cross_pt = random.randint(0,len(p1))\n        child1.extend(p1[0:cross_pt])\n        child1.extend(p2[cross_pt:])\n        child2.extend(p2[0:cross_pt])\n        child2.extend(p1[cross_pt:])\n        c1 = self.Individual(''.join(child1))\n        c2 = self.Individual(''.join(child2))\n        return c1, c2\n\n    def mutate(self, x, mut_rate=0.01):\n        new_x_ = []\n        for char in x.string:\n            if random.random() < mut_rate:\n                new_x_.extend(random.choices(self.alphabet,k=1))\n            else:\n                new_x_.append(char)\n        new_x = self.Individual(''.join(new_x_))\n        return new_x\n    \n    def evaluate_population(self, pop, target):\n        avg_fit = 0\n        for i in range(len(pop)):\n            fit = self.similar(pop[i].string, target)\n            pop[i].fitness = fit\n            avg_fit += fit\n        avg_fit \/= len(pop)\n        return pop, avg_fit\n\n    def next_generation(self, pop, size=100, length=26, mut_rate=0.3):\n        new_pop = []\n        while len(new_pop) < size:\n            parents = random.choices(pop,k=2, weights=[x.fitness for x in pop])\n            offspring_ = self.recombine(parents[0],parents[1])\n            child1 = self.mutate(offspring_[0], mut_rate=mut_rate)\n            child2 = self.mutate(offspring_[1], mut_rate=mut_rate)\n            offspring = [child1, child2]\n            new_pop.extend(offspring)\n        return new_pop","3ee82b91":"%%writefile genetics_choice.py\n\nfrom genetics import Genetics\nfrom random import randrange\n\ndef genetics_choice(observation, configuration):\n    genetics = Genetics(size=1, num_generations=10, population_size=10)\n    pop = genetics.generate_population()\n    return int((pop[0].string)[0])","f446d136":"env = make(\n    \"rps\", \n    configuration={\n        \"episodeSteps\": 10\n    }\n)\n","fa95da90":"env.run(\n    [\"genetics_choice.py\", \"genetics_choice.py\"]\n)\n\nenv.render(mode=\"ipython\", width=500, height=400)","2085daba":"<h3 align=center style=\"color:black; background:#FBE338; border:0\">Implementation<\/h3>","4a548519":"<h3 align=center style=\"color:black; background:#FBE338; border:0\">Run two genetics algorithms against each other<\/h3>","844ea34e":"<div>\nIn computer science and operations research, a genetic algorithm (GA) is a metaheuristic inspired by the process of natural selection that belongs to the larger class of evolutionary algorithms (EA).<br> Genetic algorithms are commonly used to generate high-quality solutions to optimization and search problems by relying on biologically inspired operators such as mutation, crossover and selection.\n<\/div>\n    \nReference: [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/Genetic_algorithm)","ae3e471a":"<div>\n    <img src=\"https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/22838\/logos\/header.png?t=2020-11-02-21-55-44\" width=\"100%\"\/>\n<\/div>","a928def8":"<h3 align=center style=\"color:black; background:#FBE338; border:0\">Definition<\/h3>"}}