{"cell_type":{"b0f16e9b":"code","9e3636a2":"code","2e53817c":"code","a4a5c8cc":"code","30fbf0a2":"code","974397b4":"code","97a98787":"code","0981c165":"code","626284e5":"code","5ef07ce4":"code","a173e318":"code","4b925d76":"code","91ac78fb":"code","c4c731ba":"code","0a2186b9":"code","7720022c":"code","f0b2ae1f":"code","8c9f240d":"code","8985e1a5":"code","a7689edd":"code","b5a0924f":"code","7ac54389":"code","7ee60652":"code","eb131447":"code","8ecd3d26":"code","cfc5136f":"code","5914ee03":"code","55808b36":"code","b016ae58":"code","f7380bec":"code","8bfb0e27":"code","2d086866":"code","c0315b1b":"code","c6f3e471":"code","1163064f":"markdown","6ba045ad":"markdown","8fec826b":"markdown","4ce9b942":"markdown","c3039ed1":"markdown","85e54cae":"markdown","395498b4":"markdown","ecf2b4b3":"markdown","69107501":"markdown","76b2ce1d":"markdown","80a8b729":"markdown","3a62ccd5":"markdown","6ce706f2":"markdown","479db8a3":"markdown","5e4e88a1":"markdown"},"source":{"b0f16e9b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9e3636a2":"import string # library used to deal with some text data\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns # data visualization library\npd.set_option('display.max_columns', 100) # Setting pandas to display a N number of columns\npd.set_option('display.max_rows', 10) # Setting pandas to display a N number rows\npd.set_option('display.width', 1000) # Setting pandas dataframe display width to N\nfrom scipy import stats # statistical library\nfrom statsmodels.stats.weightstats import ztest # statistical library for hypothesis testing\nimport plotly.graph_objs as go # interactive plotting library\nimport plotly.express as px # interactive plotting library\nfrom itertools import cycle # used for cycling colors at plotly graphs\nimport matplotlib.pyplot as plt # plotting library\nimport pandas_profiling # library for automatic EDA\n%pip install autoviz # installing and importing autoviz, another library for automatic data visualization\nfrom autoviz.AutoViz_Class import AutoViz_Class\nfrom IPython.display import display # display from IPython.display\nfrom itertools import cycle # function used for cycling over values\n%pip install ppscore # installing ppscore, library used to check non-linear relationships between our variables\nimport ppscore as pps # importing ppscore\nimport datetime #importing datetime","2e53817c":"df = pd.read_csv('\/kaggle\/input\/google-play-store-apps\/googleplaystore.csv')","a4a5c8cc":"df","30fbf0a2":"df.info()","974397b4":"df.drop('Current Ver', axis = 1, inplace = True)\ndf.drop('Android Ver', axis = 1, inplace = True)","97a98787":"df['Reviews'].unique()","0981c165":"df['Size'].unique()","626284e5":"df['Installs'].unique()","5ef07ce4":"df[df['Installs']=='Free']","a173e318":"df.drop(10472,inplace=True)","4b925d76":"df['Size'] = df['Size'].apply(lambda x: str(x).replace('Varies with device', 'NaN') if 'Varies with device' in str(x) else x)\ndf['Size'] = df['Size'].apply(lambda x: str(x).replace('M', '') if 'M' in str(x) else x)\ndf['Size'] = df['Size'].apply(lambda x: str(x).replace(',', '') if 'M' in str(x) else x)\ndf['Size'] = df['Size'].apply(lambda x: float(str(x).replace('k', '')) \/ 1000 if 'k' in str(x) else x)\ndf['Size'] = df['Size'].apply(lambda x: float(x))\n\ndf['Installs'] = df['Installs'].apply(lambda x: x.replace('+', '') if '+' in str(x) else x)\ndf['Installs'] = df['Installs'].apply(lambda x: x.replace(',', '') if ',' in str(x) else x)\ndf['Installs'] = df['Installs'].apply(lambda x: int(x))\n\ndf['Reviews'] = df['Reviews'].apply(lambda x: int(x))","91ac78fb":"df","c4c731ba":"df['Year_Updated'] = df['Last Updated'].apply(lambda x: str(x).replace(',','').split()[2])\ndf['Year_Updated'] = df['Year_Updated'].apply(lambda x: int(x))\n\ndf['Month_Updated'] = df['Last Updated'].apply(lambda x: str(x).replace(',','').split()[0])\n\ndf['Day_Updated'] = df['Last Updated'].apply(lambda x: datetime.datetime.strptime(x, '%B %d, %Y').strftime('%a'))","0a2186b9":"df.drop('Last Updated', axis = 1, inplace = True)","7720022c":"df","f0b2ae1f":"df[df['App'].duplicated() == True]","8c9f240d":"df.drop_duplicates(subset=['App'],keep='last',inplace=True)","8985e1a5":"sns.heatmap(df.isnull(),yticklabels=False,cbar=False,cmap='viridis')","a7689edd":"df['Miss_Rating'] = df['Rating'].isnull()\ndf['Miss_Size'] = df['Size'].isnull()","b5a0924f":"df","7ac54389":"matrix_df = pps.matrix(df)[['x', 'y', 'ppscore']].pivot(columns='x', index='y', values='ppscore')\nmatrix_df = matrix_df.apply(lambda x: round(x, 2))\n\nsns.heatmap(matrix_df, vmin=0, vmax=1, cmap=\"Blues\", linewidths=0.75, annot=True)","7ee60652":"df.drop('Genres', axis = 1, inplace = True)\ndf.drop('Miss_Rating', axis = 1, inplace = True)\ndf.drop('Miss_Size', axis = 1, inplace = True)\ndf['Size'].fillna(value=df['Size'].mean(),inplace=True)\ndf.dropna(inplace=True)","eb131447":"df=pd.get_dummies(df, columns=['Type'])\ndf.drop('Price', axis = 1, inplace = True)\ndf.drop('Type_Paid', axis = 1, inplace = True)","8ecd3d26":"df","cfc5136f":"df.set_index('App',inplace=True)\nreport = pandas_profiling.ProfileReport(df)\ndisplay(report)","5914ee03":"plt.figure(figsize=(20,10))\nsns.countplot(x='Installs',data=df)\nplt.title(\"Distribution of Install\", size=18)\nplt.xticks(rotation=90)","55808b36":"df['Install_r'] = pd.cut(df.Installs,bins=[0,10000,100000,1000000,10000000,1000000000],labels=['1-10000','10001-100000','100001-1000000','1000001-10000000','>100000000'])\ndf.drop('Installs', axis = 1, inplace = True)","b016ae58":"df","f7380bec":"report = pandas_profiling.ProfileReport(df)\ndisplay(report)","8bfb0e27":"col=list(df.columns)\ncol.remove('Reviews')\ncol.remove('Size')\n\nfor col_name in col:\n   \n    if col_name == 'Month_Updated':\n        plt.figure(figsize=(7,4))\n        order_x = ['January','February','March','April','May','June','July','August','September','October','November','December' ]\n        plt.title(\"Distribution of \"+col_name, size=18)\n        sns.countplot(df[col_name],order=order_x)\n        plt.xticks(rotation=90)\n        fig.show()\n    elif col_name == 'Day_Updated':\n        plt.figure(figsize=(7,4))\n        order_x = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun' ]\n        plt.title(\"Distribution of \"+col_name, size=18)\n        sns.countplot(df[col_name],order=order_x)\n        plt.xticks(rotation=90)\n        fig.show()\n    else:\n        plt.figure(figsize=(7,4))\n        plt.title(\"Distribution of \"+col_name, size=18)\n        sns.countplot(df[col_name])\n        plt.xticks(rotation=90)\n        fig.show()\n        ","2d086866":"plt.figure(figsize=(50,20))\nsns.catplot(x='Category',y='Rating',data=df,kind='box',height=10,showmeans=True)\nplt.title(\"Rating of each category\", size=18)\nplt.xticks(rotation=90)","c0315b1b":"sns.barplot(x='Type_Free',y='Rating',data=df)\nplt.title(\"Average Rating by Charging Scheme\", size=18)\n\ndist_a = df[['Rating','Type_Free']][df['Type_Free']==1]\ndist_b = df[['Rating','Type_Free']][df['Type_Free']==0]\n\n# Z-test: Checking if the distribution means (Rating of free app vs Rating of paid app) are statistically different\nt_stat, p_value = ztest(dist_a, dist_b)\nprint(\"----- Z Test Results -----\")\nprint(\"T stat. = \" + str(t_stat))\nprint(\"P value = \" + str(p_value)) # P-value is less than 0.05\n\nprint(\"\")\n\n# T-test: Checking if the distribution means (Rating of free app vs Rating of paid app) are statistically different\nt_stat_2, p_value_2 = stats.ttest_ind(dist_a, dist_b)\nprint(\"----- T Test Results -----\")\nprint(\"T stat. = \" + str(t_stat_2))\nprint(\"P value = \" + str(p_value_2)) # P-value is less than 0.05","c6f3e471":"cat_con_rate = df.pivot_table(values='Rating',index='Category',columns='Content Rating')\nplt.figure(figsize=(20,10))\nsns.heatmap(cat_con_rate)","1163064f":"Now, we can look into the report. There are few observations from the report:\n\n1. There are in total 33 categories of app.   Almost 40% of apps fall into family, game and tools.\n\n2. Apps gain 4.17 rating on average.  More than 75% of apps is rated more than 4.\n\n3. No. of reviews from users is skewed.  Over half of apps receive more than 3,010 reviews from users.  75-th percentile is 43,720 and 95-th percentile is around 820,000.  The maximum number of reviews received is over 78 million.\n\n4. The average size of apps is 21.6MB with 75% of apps smaller than 27MB.  The apps with largest size is 100MB and they come from different category.  The smallest app is an app called 'Essential Resources' in category of 'LIBRARY AND DEMO' with size of 0.0085MB.\n\n5. Around 34% of apps has less than or equal to 10,000 installation.  More than 75% the apps has 1M installation or less.  The share of apps with installation between 10,001 and 100,000 is around the same as apps with between 1M+ and 10M installation.  Only 5.3% of apps reach user base of more than 100M installation. This huge user base can be a cash cow if we can make them active and create a sustainable revenue generation model.\n\n6. More than half of the apps were recently updated in 2018 and were updated in the middle of the week (Tue-Thur).  It makes sense if we conside normal working cycle of a developer.  Also, there will be less inconvenience caused if updated is released in the middle of the week when utilization rate is lower.  Around 55% of the update occured before and during summer holidays (June-August).  \n\n7. 92.7% of the apps are free.\n\n8. 84.4% of apps are for Everyone (including those for Everyone 10+). 11.1% of apps are for 13+ teens.  Only 4 apps are for adults 18+ (2 comics apps and 1 sports app) or unrated (1 map app).","6ba045ad":"Obviously, this row is wrongly inputted.  We will remove this row.  And at the same time, we will transform Size and Installs.","8fec826b":"The next step is to check whether there is any duplicated entry in the dataset.  If yes, we are going to drop them.","4ce9b942":"It seems that Current Ver and Andriod Ver are not going to give up much information in the analysis process.  Moreover, Last Updated captures some of the information on upgrading and compatibility.  Therefore, we will drop Current Ver and Andriod Ver.","c3039ed1":"# **1. Explore data structure**\n\nFirst, let's look at how the data looks like.","85e54cae":"When we look into Install, it has a very strange distribution.  While I am not quite sure whether there is any problem for the data, let's assume there is not problem and collapse range of installations into 5 sub-group for further analysis: '1-10000','10001-100000','100001-1000000','1000001-10000000','>100000000'","395498b4":"We have completed most of the data cleaning task.  Let's move to the next section.","ecf2b4b3":"# **2. EDA** *(To be further updated, WIP)*\n\nFirst, let's look at how the data looks like by using pandas profiling.","69107501":"For Size, we will convert M into k and change the data format into float.  For Installs, we will remove + and change data into float.  We also notice that there is Free entry for Installs which is unusual.  Let's investigate.","76b2ce1d":"This project utilizes the data scraped from the Google Play Store to analyse how different features affect rating of apps.  The data consists of 10,841 entries and 12 columns of features.\n\nApp: Application name\n\nCategory: Category the app belongs to\n\nRating: Overall user rating of the app\n\nReview: Number of user review for the app\n\nSize: Size of the app\n\nInstalls: Number of user download\/installs for the app\n\nType: Paid or Free\n\nPrice: Price of the app\n\nContent Rating: Age group the app is targeted at (Everyone \/ Children \/ Mature 21+ \/ Adult)\n\nGenres: An app can belong to multiple genres (apart from its main category)\n\nLast Updated: Last updated of the app\n\nCurrent Ver: Current ver of the app\n\nAndroid Ver: Android ver the app compatible with\n\n\nThis project will be made up of 3 parts.\n1. Explore data structure\n2. EDA\n3. Model Training and Evaluation\n\nThe objective of this project: Find out insight for marketing strategy of apps","80a8b729":"For Last Updated, while we are not sure how it could be related to rating of the app, let's convert the format of date into format that allows easier analysis.  I will break the date into day of week, month and year.","3a62ccd5":"Another observation is the presentation of Size, Installs and Reviews. It would be more convenient and informative if we could convert them into numbers. Let's have a closer look at this two columns.","6ce706f2":"The next step is to check whether there is any missing data in the dataset.  We can use heatmap of seaborn to visualize the existence of missing data.","479db8a3":"There are missing data for Rating and Size.  Before deciding how to handle these missing data, we need to see whether these data are missing at random or not.  We will create two columns indicating whether missing data exists for Rating and Size.  And then we will look at into the Predictive Power Score of features.  It may give us some hints on univariate correlation between two features.","5e4e88a1":"There are few observations here:\n\n1. Category and Genres have very strong univariate relationship in either direction.  It makes sense because genres representing sub-category of the apps that belong to.  Maybe we just keep Category in our analysis for simplicity.\n\n2. We can predict Content Rating from Category and Genres to some extent.  It makes sense because some categories\/genres are restricted to particular group of users only.\n\n3. We can perfectly predict Type from Price.  If Price is 0, of course it implies Type will be Free.  We will drop Price in our further analysis as we are not going to examine impact of marginal change on Price.  Also, we will create a dummy variable, Type_Free, for easier analysis.\n\n4. Missing data of Rating appears not to be at random.  Installs and Review have certain extent of uniavriate relation with missing of data.  Apps with only few installations and few reviews are usually less likely to be rated.  These apps are simply not visible to the market. In such case, we will simply drop rows with missing rate instead of filling them with mean.\n\n5. Missing data of Size has weak univariate relations with other features.  We will fill the missing data with mean.\n\n6. Rating seems to be hard to predict with features we have.  We may want to rethink how we want to approach the market.  Whether we want to gain high rating or to reach huge number of audience by maximizing installation.  Of course, it depends on business strategy and your revenue model.  Install is denfitely an interesting feature to study in later section."}}