{"cell_type":{"f7620863":"code","3a5da612":"code","ad48b803":"code","e3c03430":"code","a325ea0d":"code","d2de6306":"code","926a66ae":"code","c3ca5d94":"code","451dc8ce":"code","6fc97f7d":"code","2db3a81c":"code","d46a99ce":"markdown","64775b9d":"markdown","bbcfa08f":"markdown","bc897e29":"markdown"},"source":{"f7620863":"import tensorflow as tf","3a5da612":"(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()","ad48b803":"from matplotlib import pyplot as plt","e3c03430":"image_index = 7777 # You may select anything up to 60,000\nprint(y_train[image_index]) # The label is 8","a325ea0d":"x_train.shape","d2de6306":"# Reshaping the array to 4-dims so that it can work with the Keras API\nx_train = x_train.reshape(x_train.shape[0], 28, 28, 1)\nx_test = x_test.reshape(x_test.shape[0], 28, 28, 1)\ninput_shape = (28, 28, 1)\n# Making sure that the values are float so that we can get decimal points after division\nx_train = x_train.astype('float32')\nx_test = x_test.astype('float32')\n# Normalizing the RGB codes by dividing it to the max RGB value.\nx_train \/= 255\nx_test \/= 255\nprint('x_train shape:', x_train.shape)\nprint('Number of images in x_train', x_train.shape[0])\nprint('Number of images in x_test', x_test.shape[0])","926a66ae":"# Importing the required Keras modules containing model and layers\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Conv2D, Dropout, Flatten, MaxPooling2D","c3ca5d94":"# Creating a Sequential Model and adding the layers\nmodel = Sequential()\nmodel.add(Conv2D(28, kernel_size=(3,3), input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Flatten()) # Flattening the 2D arrays for fully connected layers\nmodel.add(Dense(128, activation=tf.nn.relu))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(10,activation=tf.nn.softmax))","451dc8ce":"model.compile(optimizer='adam',loss='sparse_categorical_crossentropy',metrics=['accuracy'])\nmodel.fit(x=x_train,y=y_train, epochs=12)","6fc97f7d":"model.evaluate(x_test, y_test)","2db3a81c":"image_index = 4444\nplt.imshow(x_test[image_index].reshape(28, 28),cmap='Greys')\npred = model.predict(x_test[image_index].reshape(1, 28, 28, 1))\nprint(pred.argmax())","d46a99ce":"# Load the Dataset","64775b9d":"# Thanks","bbcfa08f":"# Preprocess the data","bc897e29":"Handwriting Recognition using Keras:\n\nThis kernal will focus on trying to build a neural network that can correctly identify handwritten digits. The MNIST database of handwritten digits is a widely used dataset for tutorials into deep learning. The image data is in the form of 28 x 28 grayscale pixels (784 pixels overall) along with labels for the correct identification of that image. The training set has 60K samples while the test set had 10K samples. Here are some examples of the data we are working with:\n\n![Mnist Dataset](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/2\/27\/MnistExamples.png)\n\nLearning how to code artificial neural networks is hard, especially if you are a curious high school student with limited resources and experience. But we can utilize specialized packages such as Keras to make our lives much easier. With its high level framework, programming neural networks have never been easier with Keras! Unlike Tensorflow (another package used by Google) you don't have to manually code the linear algebra and the required activation functions and optimizers.\n\nThis specific neural network will take in an input of 784 pixels of the image into the hidden layer of 512 neurons that will output into 10 neurons (one for each digit). Note that the layout of the network is not exactly specific, but rather random, as you can have as many hidden layers as you want with varied amount of neurons in each layer.\n\n\n![CNN](http:\/\/intelligency.org\/images\/cnn.png)\n"}}