{"cell_type":{"a367bb1e":"code","02928619":"code","f89ac9bb":"code","f0a2e137":"code","96b81216":"code","7468cd06":"code","6f08288b":"code","b547f6f8":"code","2a789866":"code","17b42bd2":"code","cc2e3748":"code","f1c2cf89":"code","8429cd2a":"code","54939553":"code","75e855aa":"code","ef1d9a36":"code","777bf01d":"code","c52f92a2":"code","9075c959":"code","70a69040":"markdown","ae75a30e":"markdown","f6b58b7c":"markdown","0902c5ab":"markdown","02ee836f":"markdown","95e06744":"markdown","085ef1b0":"markdown","51a8f315":"markdown","a3371dce":"markdown","0655ea77":"markdown","556f840a":"markdown","a574d17a":"markdown","268a8915":"markdown","f6bc984a":"markdown","c6a0aeee":"markdown","98bb412f":"markdown"},"source":{"a367bb1e":"import _pickle as pickle\nimport sys\nimport numpy as np\n\ndef parse_playlist_get_info(in_line, playlist_dic, song_dic):\n#     name, tags, playlist_id, subscribed_count = None,None,None,None\n    contents = in_line.strip().split('\\t')\n    try:\n        name, tags, playlist_id, subscribed_count = contents[0].split(\"##\")\n        playlist_dic[playlist_id] = name\n        for song in contents[1:]:\n            try:\n                song_id, song_name, artist, popularity = song.split(\"::\")\n                song_dic[song_id] = song_name+\"\\t\"+artist\n#                 \n            except:\n#                 print(\"song format error\")\n#                 print(song+\"\\n\")\n                pass\n\n    except:\n#         print(contents[0])\n        pass\n\ndef parse_file(in_file):\n    #playlist id: playlist name\n    playlist_dic = {}\n    #song id: song name\n    song_dic = {}\n    for line in open(in_file):\n        parse_playlist_get_info(line, playlist_dic, song_dic)\n    return playlist_dic, song_dic\n","02928619":"dic = parse_file('\/kaggle\/input\/music-playlists-txt-file-16mb\/popular.playlist')\nplaylist_dic=dic[0]\nsong_dic = dic[1]","f89ac9bb":"# playlist_dic","f0a2e137":"# song_dic","96b81216":"import multiprocessing\nimport gensim\nimport sys\n\ndef parse_playlist_get_sequence(in_line, playlist_sequence):\n    song_sequence = []\n    contents = in_line.strip().split('\\t')\n    # parse playlist info\n\n    counter1=0\n    counter2=0\n    for song in contents[1:]: #0playlist, rest:song\n        \n        counter1+=1\n        try:\n            song_id, song_name, artist, popularity = song.split(\"::\")\n            song_sequence.append(song_id)\n        except:\n            counter2+=1\n            #print(\"song format error\",counter1,counter2)\n            #print(song+\"\\n\")\n    playlist_sequence.append(song_sequence)\n\n\ndef train_song2vec(in_file):\n    #playlist[songs]\n    playlist_sequence = []\n    #traverse all playlist\n    for line in open(in_file):\n        parse_playlist_get_sequence(line, playlist_sequence)\n#         break\n    #word2vec\n    cores = multiprocessing.cpu_count()\n    print(\"using all \"+str(cores)+\" cores\")\n    print(\"Training word2vec model...\")\n    model = gensim.models.Word2Vec(sentences=playlist_sequence, size=50, min_count=1, window=7, workers=cores)\n    return model","7468cd06":"song_sequence_file = '\/kaggle\/input\/music-playlists-txt-file-16mb\/popular.playlist'\nmodel_song = train_song2vec(song_sequence_file)","6f08288b":"#Randomly pick up one song\nsong_id = list(song_dic.keys())[1542]\nresult_song_list = model_song.most_similar(song_id,topn=15)\n#print(song_id, song_dic[song_id])\nprint(\"\\nRecommend song name and Similarity:\" )\nfor song in result_song_list:\n    print(\"\\t\", song_dic[song[0]], song[1])\nprint (\"\\n\")","b547f6f8":"#coding: utf-8\nfrom gensim.models.doc2vec import TaggedDocument\nimport multiprocessing\nimport gensim\nimport sys\n\ndef parse_playlist_get_sequence2(in_line, playlist_sequence, playlist_list):\n    \n    song_sequence = []\n    contents = in_line.strip().split('\\t')\n\n    counter1=0\n    counter2=0\n    for song in contents[1:]: #0playlist, rest:song\n        \n        counter1+=1\n        try:\n            song_id, song_name, artist, popularity = song.split(\"::\")\n            song_sequence.append(song_id)\n        except:\n            counter2+=1\n            #print(\"song format error\",counter1,counter2)\n            #print(song+\"\\n\")\n    playlist_sequence.append(song_sequence)\n    #save playlist name\n    playlist_list.append(contents[0].split('##')[1])\n\ndef train_song2vec2(in_file):\n    #[playlist[songlist]]\n    playlist_sequence = []\n    #playlist name list\n    playlist_list=[]\n    #traverse all playlists\n    for line in open(in_file,encoding=\"utf-8\"):\n        parse_playlist_get_sequence2(line, playlist_sequence,playlist_list)\n#         break\n    #doc2vec\n    playlist_sequence_tagged = [TaggedDocument(doc, [i]) for i, doc in enumerate(playlist_sequence)]\n    cores = multiprocessing.cpu_count()\n    print(\"using all \"+str(cores)+\" cores\")\n    print(\"Training word2vec model...\")\n    model = gensim.models.Doc2Vec(documents=playlist_sequence_tagged, size=50, min_count=2, window=7, workers=cores)\n    return model,playlist_sequence_tagged,playlist_list","2a789866":"song_sequence_file = '\/kaggle\/input\/music-playlists-txt-file-16mb\/popular.playlist'\n\nmodel_playlist=train_song2vec2(song_sequence_file)[0]\nplaylist_sequence_tagged=train_song2vec2(song_sequence_file)[1]\nplaylist_list=train_song2vec2(song_sequence_file)[2]","17b42bd2":"#Randomly select a playlist\nplaylist_songs=playlist_sequence_tagged[1][0]","cc2e3748":"playlist_vector = model_playlist.infer_vector(playlist_songs,steps=20, alpha=0.025)\nresult_playlist_list=model_playlist.docvecs.most_similar([playlist_vector])\nprint(\"\\nRecommend playlist name and Similarity:\" )\nfor playlist in result_playlist_list:\n    print(\"\\t\", playlist_list[playlist[0]], playlist[1])\nprint (\"\\n\")","f1c2cf89":"playlist_dic_reverse = {}\nfor playlist_id in playlist_dic:\n    #print(playlist_id,playlist_dic[playlist_id])\n    playlist_dic_reverse[playlist_dic[playlist_id]] = playlist_id","8429cd2a":"import json\nimport sys\n\n\ndef is_null(s): \n    return len(s.split(\",\"))>=2\n\ndef parse_song_info(song_info):\n    try:\n        song_id, name, artist, popularity = song_info.split(\"::\")\n#         print('song info : ', song_id)\n        return \",\".join([song_id,\"1.0\"])\n    except Exception as e:\n        # print('song error:',e,song_info)\n        return \"\"\n\ndef parse_playlist_line(in_line):\n    try:\n        contents = in_line.strip().split('\\t')\n        name, tags, playlist_id, subscribed_count = contents[0].split(\"##\")\n        songs_info = map(lambda x:playlist_id+\",\"+parse_song_info(x), contents[1:])      \n        songs_info = filter(is_null, songs_info)\n        info = \"\\n\".join(songs_info)\n        return info\n    except Exception as e:\n        # print('play:',e)\n        return False\n\n\n\ndef parse_file(in_file, out_file):\n    out = open(out_file, 'w')\n    for line in open(in_file):\n        result = parse_playlist_line(line)\n        if(result):\n            out.write(str(result.strip())+\"\\n\")\n            pass\n\n    out.close()","54939553":"parse_file('..\/input\/music-playlists-txt-file-16mb\/popular.playlist','.\/popular_music_suprise_format.csv')","75e855aa":"import pandas as pd\ntrain_df = pd.read_csv('.\/popular_music_suprise_format.csv',sep=',',names=['user_id','item_id','rating'])\ntrain_df.dropna(inplace=True)   \ntrain_df['user_id'] = train_df['user_id'].astype(str)\ntrain_df['item_id'] = train_df['item_id'].astype(int).astype(str)\n\ntrain_df","ef1d9a36":"#load data to trainset\nimport os\nimport io\nimport surprise\nfrom surprise import Reader, Dataset\nfrom surprise import KNNBaseline\nfrom surprise import Dataset\n\n\ntrainset = surprise.Dataset.load_from_df(train_df, reader=surprise.Reader(rating_scale=(0,1))).build_full_trainset()","777bf01d":"playlist_name = list(playlist_dic_reverse.keys())[1]\nplaylist_id = playlist_dic_reverse[playlist_name]","c52f92a2":"algo = KNNBaseline()\nalgo.fit(trainset)\nplaylist_inner_id = algo.trainset.to_inner_uid(playlist_id)\nplaylist_neighbors = algo.get_neighbors(playlist_inner_id, k=10)\n\n#get raw_uid of neighbors\nplaylist_neighbors = (algo.trainset.to_raw_uid(inner_id)\n                       for inner_id in playlist_neighbors)\n#get name of neighbors\nplaylist_neighbors = (playlist_dic[playlist_id]\n                       for playlist_id in playlist_neighbors)\n","9075c959":"print(\"the 10 most similar playlists with\", playlist_name, \"are\uff1a\\n\")\n\nfor playlist in playlist_neighbors:\n    print(playlist)","70a69040":"Pick up one playlist name and get its ID","ae75a30e":"Recommended result with similarity","f6b58b7c":"Get a reversed dictionary of playlist_dic","0902c5ab":"Word2vec model training","02ee836f":"Output recommendation","95e06744":"convert data format to movielens<span style=\"color:CornflowerBlue\">(user item rating)<\/span> which is matched with Surprise","085ef1b0":"Recommended result with similarity","51a8f315":"## Data description\nThe given data is a txt file, has a format like below:\n\nPlaylist name##playlist category##playlist id##favorate count\\tSong id::Song name::Artist::popularity\\tSong id::Song name::Artist::popularity\\tSong id::Song name::Artist::popularity\\tSong id::Song name::Artist::popularity\\n\nPlaylist name##playlist category##playlist id##favorate count\\tSong id::Song name::Artist::popularity\\tSong id::Song name::Artist::popularity\\tSong id::Song name::Artist::popularity\\tSong id::Song name::Artist::popularity\\n","a3371dce":"### Data preprocessing(get 2 dictionary)\nsongid:songname and playlistid:playlistname dictionary","0655ea77":"### Doc2vec: generate 10 nearest playlists from a given playlist","556f840a":"## Word2vec + Doc2vec\n### <span style=\"color:CornflowerBlue\">Basic idea: consider each playlist as sentence made up by songs (which is considered as words), then calculate the similarity to find the N(10)-nearest songs or playlists as recommended result<\/span>","a574d17a":"## Scikit Surprise","268a8915":"# Introduction\nIn this notebook, two ways of music recommendation by Collaborative Filtering algorithm are demonstrated. Gensim Word2vec+Doc2vec, and Scikit Surprise.\n\n**Overview**\n\n**Word2vec and Doc2vec**\n* [Word2vec](#Word2vec:-generate-10-nearest-songs-from-a-given-song)<br>\n* [Doc2vec](#Doc2vec:-generate-10-nearest-playlists-from-a-given-playlist)<br>\n\n**Scikit Surprise**\n* [Scikit Surprise](#Scikit-Surprise)<br>\n\n","f6bc984a":"### Data preprocessing:\n","c6a0aeee":"Training with KNNbaseline (Collaborative Filtering)","98bb412f":"### Word2vec: generate 10 nearest songs from a given song"}}