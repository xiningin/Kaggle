{"cell_type":{"3511772c":"code","61e6ab3b":"code","2bdd51b5":"code","a0729ac3":"code","929afcc7":"markdown","ff938167":"markdown","033242ca":"markdown","ce0d3277":"markdown","49ebd510":"markdown","ab00db31":"markdown","4765fb5d":"markdown","fd70887f":"markdown","ed373b5a":"markdown","1a0c5ba5":"markdown","ad0c5df1":"markdown"},"source":{"3511772c":"import numpy as np\nimport time\na=np.loadtxt('..\/input\/coding2\/stream_data.txt',dtype='uint8')\nw_s=1000\nt_begin=0\nbegin=time.time()\nx1=a[t_begin:t_begin+w_s]\nx1_all=x1.sum()\nend=time.time()\nprint(\"The number of 1-bits is \\\"{}\\\",time is \\\"{}\\\"s\\n\".format(x1_all,end-begin))\nprint(\"Size of x1 is \\\"{}\\\"\".format(len(x1)))","61e6ab3b":"x_time=[]\nx_size=[]\nfor i in range(w_s):\n    if(x1[i]==1):\n        x_time.append(i)\n        x_size.append(1)\n        if(len(x_size)>2):\n            y=True\n            while(y):\n                y=False\n                for j in reversed(range(len(x_size)-2)):\n                    if(x_size[j]==x_size[j+1]&x_size[j+1]==x_size[j+2]):\n                        y=True\n                        x_size[j]*=2\n                        del x_time[j+1]\n                        del x_size[j+1]\nbegin=time.time()\nx_all=np.sum(x_size[1:])+int(x_size[0]\/2+0.5)\nend=time.time()\nprint(\"The number of 1-bits is \\\"{}\\\",time is \\\"{}\\\"s\\n\".format(x_all,end-begin))\nprint(\"Size of x1 is \\\"{}\\\"\".format(len(x_size)))","2bdd51b5":"data=(np.loadtxt(\"..\/input\/coding2\/docs_for_lsh.csv\",delimiter=',',skiprows=1,usecols=range(1,201)))\ndef f1(Sig):\n    cols=Sig.shape[0]\n    for i in range(cols):\n        if Sig[i]==0:\n            return False\n        return True\ndef f2(data,num=50):\n    [rows,cols]=data.shape\n    Sig=np.zeros([num,cols],dtype=int)\n    z=np.zeros([num,cols],dtype=int)\n    for j in range(num):\n        while(f1(Sig[j,:])==False):\n            temp1=np.random.randint(rows)\n            for i in range(cols):\n                if data[temp1,i]==1:\n                    Sig[j,i]=1\n                if Sig[j,i]==0:\n                    z[j,i]+=1\n    return z\nresult=f2(data,36)","a0729ac3":"from sklearn import metrics\ndef f3(result,q):\n    x={}\n    h_m=np.zeros([1,q])\n    for i in range(q):\n        h_m[0,i]=pow(2,i)\n    [rows,cols]=result.shape\n    for i in range(0,rows,q):\n        w1=i\/q\n        x[w1]={}\n        for j in range(cols):\n            w2=h_m.dot(result[i:i+q,j])[0]\n            if w2 not in x[w1]:\n                x[w1][w2]=[j]\n            elif j not in x[w1][w2]:\n                x[w1][w2].append(j)\n    return x\nh_x=f3(result,4)\ns=np.zeros(1000000)\nfor x in h_x.values():\n    for w,val in x.items():\n        if 0 in val:\n            for i in range(len(val)):\n                s[val[i]]+=1\ns[0]=0\nresult2=np.argsort(-s)[0:30]\nprint(result2)\nfor i in result2:\n    print(metrics.jaccard_score(data[:,i],data[:,0]))","929afcc7":"### Your task","ff938167":"DGIM is an efficient algorithm in processing large streams. When it's infeasible to store the flowing binary stream, DGIM can estimate the number of 1-bits in the window. In this coding, you're given the *stream_data.txt* (binary stream), and you need to implement the DGIM algorithm to count the number of 1-bits. Write code and ask the problems below.","033242ca":"Problem: For document 0 (the one with id '0'), list the **30** most similar document ids (except document 0 itself). You can valid your results with the [sklearn.metrics.jaccard_score()](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.metrics.jaccard_score.html) function.\n\nTips: You can adjust your parameters to hash the documents with similarity *s > 0.8* into the same bucket.","ce0d3277":"* > # EE226 - Coding 2\n## Streaming algorithm & Locality Sensitive Hashing","49ebd510":"The locality sensitive hashing (LSH) algorithm is efficient in near-duplicate document detection. In this coding, you're given the *docs_for_lsh.csv*, where the documents are processed into set of k-shingles (k = 8, 9, 10). *docs_for_lsh.csv* contains 201 columns, where column 'doc_id' represents the unique id of each document, and from column '0' to column '199', each column represents a unique shingle. If a document contains a shingle ordered with **i**, then the corresponding row will have value 1 in column **'i'**, otherwise it's 0. You need to implement the LSH algorithm and ask the problems below.","ab00db31":"2. Write a function that accurately counts the number of 1-bits in the current window, and compare the difference between its running time and space and the DGIM algorithm.","4765fb5d":"### Your task","fd70887f":"### Streaming: DGIM","ed373b5a":"1. Set the window size to 1000, and count the number of 1-bits in the current window.","1a0c5ba5":"### Locality Sensitive Hashing","ad0c5df1":"Use minhash algoirthm to create signature of each document, and find 'the most similar' documents under Jaccard similarity. \nParameters you need to determine:\n1) Length of signature (number of distinct minhash functions) *n*. Recommanded value: n > 20.\n\n2) Number of bands that divide the signature matrix *b*. Recommanded value: b > n \/\/ 10."}}