{"cell_type":{"d208f913":"code","04e52ff9":"code","19441b39":"code","7425542c":"code","83aa6be6":"code","c30bc06e":"code","90913c1b":"code","4fbb5e52":"code","24fda08f":"code","f1dd9f0d":"code","e7167e1a":"code","6ca3053e":"code","ebbdda4f":"code","3a59fbcd":"code","e181fc74":"code","1903ef69":"code","c29f879e":"code","54c90300":"code","e012924d":"code","67bfae53":"code","ae861d62":"code","b6398563":"code","3ed29026":"code","4e842ad1":"code","f5767d6f":"code","3facecec":"code","214c2fb1":"code","824242e8":"code","4926e86e":"code","8b244e11":"code","1e5292a1":"code","fd13329c":"code","2d8afc2d":"code","284cba6a":"code","763a4358":"code","4f4f4fdd":"code","b48317ef":"code","ee2800a6":"code","fe009835":"code","5faaf10a":"code","9809f59f":"code","b0c8eda6":"code","7780a4a9":"code","f20fd10c":"code","37eef0f0":"code","c98e55f3":"code","b037b95e":"code","42bfc4da":"code","5b0a5206":"code","f188dc28":"markdown","d3aa9b61":"markdown","56266d43":"markdown","cbefa838":"markdown","f4156cb3":"markdown","af2335a3":"markdown","b5a4620c":"markdown","a5602582":"markdown","1a32c5fd":"markdown","b7f99495":"markdown","c2f4d161":"markdown","af8ad964":"markdown","fca27512":"markdown","e7aee09e":"markdown","857e9ffe":"markdown","41aab231":"markdown","38d43c32":"markdown","67530e27":"markdown","d1cd1006":"markdown","7b03f688":"markdown","1da7fddd":"markdown","79c6124f":"markdown","89280165":"markdown","fa01f9ef":"markdown","4b0fc34c":"markdown","180caf3e":"markdown","b46615da":"markdown","65ce549d":"markdown","cbbe59cb":"markdown","5ea95b1e":"markdown","4cb09edc":"markdown"},"source":{"d208f913":"path = '\/kaggle\/input\/movielens-small-dataset\/ml-latest-small\/ml-latest-small\/'","04e52ff9":"# import libraties\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Reading ratings file\nratings = pd.read_csv(path + 'ratings.csv', encoding='latin-1')","19441b39":"ratings.head()","7425542c":"from sklearn.model_selection import train_test_split\ntrain, test = train_test_split(ratings, test_size=0.30, random_state=31)","83aa6be6":"print(train.shape)\nprint(test.shape)","c30bc06e":"# pivot ratings into movie features\ndf_movie_features = train.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n).fillna(0)","90913c1b":"df_movie_features.head()","4fbb5e52":"dummy_train = train.copy()\ndummy_test = test.copy()","24fda08f":"dummy_train['rating'] = dummy_train['rating'].apply(lambda x: 0 if x>=1 else 1)\ndummy_test['rating'] = dummy_test['rating'].apply(lambda x: 1 if x>=1 else 0)","f1dd9f0d":"# The movies not rated by user is marked as 1 for prediction. \ndummy_train = dummy_train.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n).fillna(1)\n\n# The movies not rated by user is marked as 0 for evaluation. \ndummy_test = dummy_test.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n).fillna(0)","e7167e1a":"dummy_train.head()","6ca3053e":"dummy_test.head()","ebbdda4f":"from sklearn.metrics.pairwise import pairwise_distances\n\n# User Similarity Matrix\nuser_correlation = 1 - pairwise_distances(df_movie_features, metric='cosine')\nuser_correlation[np.isnan(user_correlation)] = 0\nprint(user_correlation)","3a59fbcd":"user_correlation.shape","e181fc74":"movie_features = train.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n)","1903ef69":"movie_features.head()","c29f879e":"mean = np.nanmean(movie_features, axis=1)\ndf_subtracted = (movie_features.T-mean).T","54c90300":"df_subtracted.head()","e012924d":"from sklearn.metrics.pairwise import pairwise_distances\n\n# User Similarity Matrix\nuser_correlation = 1 - pairwise_distances(df_subtracted.fillna(0), metric='cosine')\nuser_correlation[np.isnan(user_correlation)] = 0\nprint(user_correlation)","67bfae53":"user_correlation[user_correlation<0]=0\nuser_correlation","ae861d62":"user_predicted_ratings = np.dot(user_correlation, movie_features.fillna(0))\nuser_predicted_ratings","b6398563":"user_predicted_ratings.shape","3ed29026":"user_final_rating = np.multiply(user_predicted_ratings,dummy_train)\nuser_final_rating.head()","4e842ad1":"user_final_rating.iloc[1].sort_values(ascending=False)[0:5]","f5767d6f":"movie_features = train.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n).T\n\nmovie_features.head()","3facecec":"mean = np.nanmean(movie_features, axis=1)\ndf_subtracted = (movie_features.T-mean).T","214c2fb1":"df_subtracted.head()","824242e8":"from sklearn.metrics.pairwise import pairwise_distances\n\n# User Similarity Matrix\nitem_correlation = 1 - pairwise_distances(df_subtracted.fillna(0), metric='cosine')\nitem_correlation[np.isnan(item_correlation)] = 0\nprint(item_correlation)","4926e86e":"item_correlation[item_correlation<0]=0\nitem_correlation","8b244e11":"item_predicted_ratings = np.dot((movie_features.fillna(0).T),item_correlation)\nitem_predicted_ratings","1e5292a1":"item_predicted_ratings.shape","fd13329c":"dummy_train.shape","2d8afc2d":"item_final_rating = np.multiply(item_predicted_ratings,dummy_train)\nitem_final_rating.head()","284cba6a":"item_final_rating.iloc[1].sort_values(ascending=False)[0:5]","763a4358":"test_movie_features = test.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n)\nmean = np.nanmean(test_movie_features, axis=1)\ntest_df_subtracted = (test_movie_features.T-mean).T\n\n# User Similarity Matrix\ntest_user_correlation = 1 - pairwise_distances(test_df_subtracted.fillna(0), metric='cosine')\ntest_user_correlation[np.isnan(test_user_correlation)] = 0\nprint(test_user_correlation)","4f4f4fdd":"test_user_correlation[test_user_correlation<0]=0\ntest_user_predicted_ratings = np.dot(test_user_correlation, test_movie_features.fillna(0))\ntest_user_predicted_ratings","b48317ef":"test_user_final_rating = np.multiply(test_user_predicted_ratings,dummy_test)","ee2800a6":"test_user_final_rating.head()","fe009835":"from sklearn.preprocessing import MinMaxScaler\nfrom numpy import *\n\nX  = test_user_final_rating.copy() \nX = X[X>0]\n\nscaler = MinMaxScaler(feature_range=(1, 5))\nprint(scaler.fit(X))\ny = (scaler.transform(X))\n\nprint(y)","5faaf10a":"test_ = test.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n)","9809f59f":"# Finding total non-NaN value\ntotal_non_nan = np.count_nonzero(~np.isnan(y))","b0c8eda6":"rmse = (sum(sum((test_ - y )**2))\/total_non_nan)**0.5\nprint(rmse)","7780a4a9":"test_movie_features = test.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n).T\n\nmean = np.nanmean(test_movie_features, axis=1)\ntest_df_subtracted = (test_movie_features.T-mean).T\n\ntest_item_correlation = 1 - pairwise_distances(test_df_subtracted.fillna(0), metric='cosine')\ntest_item_correlation[np.isnan(test_item_correlation)] = 0\ntest_item_correlation[test_item_correlation<0]=0","f20fd10c":"test_item_correlation.shape","37eef0f0":"test_movie_features.shape","c98e55f3":"test_item_predicted_ratings = (np.dot(test_item_correlation, test_movie_features.fillna(0))).T\ntest_item_final_rating = np.multiply(test_item_predicted_ratings,dummy_test)\ntest_item_final_rating.head()","b037b95e":"test_ = test.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n)","42bfc4da":"from sklearn.preprocessing import MinMaxScaler\nfrom numpy import *\n\nX  = test_item_final_rating.copy() \nX = X[X>0]\n\nscaler = MinMaxScaler(feature_range=(1, 5))\nprint(scaler.fit(X))\ny = (scaler.transform(X))\n\n\ntest_ = test.pivot(\n    index='userId',\n    columns='movieId',\n    values='rating'\n)\n\n# Finding total non-NaN value\ntotal_non_nan = np.count_nonzero(~np.isnan(y))","5b0a5206":"rmse = (sum(sum((test_ - y )**2))\/total_non_nan)**0.5\nprint(rmse)","f188dc28":"### Finding the top 5 recommendation for the user 1 ","d3aa9b61":"### Filtering the rating only for the movies not rated by the user for recommendation","56266d43":"Since we are interested only in the movies not rated by the user, we will ignore the movies rated by the user by making it zero. ","cbefa838":"## Prediction","f4156cb3":"Doing the prediction for the users which are positively related with other users, and not the users which are negatively related as we are interested in the users which are more similar to the current users. So, ignoring the correlation for values less than 0. ","af2335a3":"### Calculating the RMSE for only the movies rated by user. For  RMSE, normalising the rating to (1,5) range. ","b5a4620c":"# Recommendation System Notebook\n- User based recommendation\n- User based prediction\n- Item based recommendation\n- Item based prediction\n- Evaluation","a5602582":"### Top 5 prediction for the user -1","1a32c5fd":"Finding the cosine similarity. Note that since the data is normalised, both the cosine metric and correlation metric will give the same value. ","b7f99495":"### Copy train and test dataset\nThese dataset will be used for prediction and evaluation. \n- Dummy train will be used later for prediction of the movies which has not been rated by the user. To ignore the movies rated by the user, we will mark it as 0 during prediction. The movies not rated by user is marked as 1 for prediction. \n- Dummy test will be used for evaluation. To evaluate, we will only make prediction on the movies rated by the user. So, this is marked as 1. This is just opposite of dummy_train","c2f4d161":"## Using User Similarity","af8ad964":"## Dividing the dataset into train and test","fca27512":"# Item Based Similarity","e7aee09e":"Filtering the correlation only for which the value is greater than 0. (Positively correlated)","857e9ffe":"Thank-you","41aab231":"### Finding cosine similarity","38d43c32":"# User Similarity Matrix","67530e27":"# Evaluation","d1cd1006":"# Prediction","7b03f688":"## Using Cosine Similarity","1da7fddd":"Normalising the movie rating for each movie","79c6124f":"### Doing prediction for the movies rated by the user","89280165":"### Here, not removing the NaN values and calculating the mean only for the movies rated by the user","fa01f9ef":"### Normalising the rating of the movie for each user aroung 0 mean","4b0fc34c":"Rating predicted by the user (for movies rated as well as not rated) is the weighted sum of correlation with the movie rating (as present in the rating dataset). ","180caf3e":"Taking the transpose of the rating matrix to normalize the rating around the mean for different movie ID. In the user based similarity, we had taken mean for each user intead of each movie. ","b46615da":"### Finding RMSE","65ce549d":"## Using Item similarity","cbbe59cb":"## Using adjusted Cosine ","5ea95b1e":"Using Correlation","4cb09edc":"Evaluation will we same as you have seen above for the prediction. The only difference being, you will evaluate for the movie already rated by the user insead of predicting it for the movie not rated by the user. "}}