{"cell_type":{"61d0b3b8":"code","6b04b5b7":"code","c445f961":"code","f01c5dfa":"code","8f180b6c":"code","9b9f36fd":"code","64043347":"code","b566ef32":"code","46b0097e":"code","268dbed1":"code","906415c0":"code","e941f09f":"code","41e46cd4":"code","c6cc1d71":"markdown","ebd389d3":"markdown"},"source":{"61d0b3b8":"# load libraries\nimport numpy as np  # linear algebra\nimport pandas as pd # general data functionality","6b04b5b7":"print('Preparing training data...')\n\n# import training data\ndata_types_dict = {\n    'row_id': 'int64',\n    'timestamp': 'int64',\n    'user_id': 'int32',\n    'content_id': 'int16',\n    'content_type_id': 'int8',\n    'task_container_id': 'int16',\n    'user_answer': 'int8',\n    'answered_correctly': 'int8',\n    'prior_question_elapsed_time': 'float16',\n    'prior_question_had_explanation': 'boolean'\n}\n\nData = pd.read_csv('..\/input\/riiid-test-answer-prediction\/train.csv', \n                   nrows=10**6,\n                   dtype = data_types_dict)","c445f961":"Data_questions = pd.read_csv('\/kaggle\/input\/riiid-test-answer-prediction\/example_test.csv', \n                   nrows=10**3)\nData_questions.head()","f01c5dfa":"# create content group prior means\n# (https:\/\/www.kaggle.com\/lgreig\/simple-lgbm-baseline)\n# I have created this based on the entire training sample and import\n#     a saved copy of it now to save time\nresults_c = pd.read_csv('..\/input\/riid-questions-priorscsv\/question_priors.csv')\nansered_correctly_unconditional = results_c['answered_correctly_content'].mean()","8f180b6c":"# Create data regarding questions\n# (https:\/\/www.kaggle.com\/jsylas\/riiid-lgbm-starter)\nData_questions = pd.read_csv('\/kaggle\/input\/riiid-test-answer-prediction\/questions.csv',\n                             usecols=[0,1,3,4],\n                             dtype={'question_id': 'int16','part': 'int8','bundle_id': 'int8','tags': 'str'})\n\ntag = Data_questions[\"tags\"].str.split(\" \", n = 10, expand = True) \ntag.columns = ['tags1','tags2','tags3','tags4','tags5','tags6']\n\nData_questions =  pd.concat([Data_questions,tag],axis=1)\nData_questions['tags1'] = pd.to_numeric(Data_questions['tags1'], errors='coerce')\nData_questions['tags2'] = pd.to_numeric(Data_questions['tags2'], errors='coerce')\nData_questions['tags3'] = pd.to_numeric(Data_questions['tags3'], errors='coerce')\nData_questions['tags4'] = pd.to_numeric(Data_questions['tags4'], errors='coerce')\nData_questions['tags5'] = pd.to_numeric(Data_questions['tags5'], errors='coerce')\nData_questions['tags6'] = pd.to_numeric(Data_questions['tags6'], errors='coerce')\n\nData_questions['tags1'].fillna(0, inplace = True)\nData_questions['tags2'].fillna(0, inplace = True)\nData_questions['tags3'].fillna(0, inplace = True)\nData_questions['tags4'].fillna(0, inplace = True)\nData_questions['tags5'].fillna(0, inplace = True)\nData_questions['tags6'].fillna(0, inplace = True)\n\nData_questions.drop(['tags'], axis =1, inplace = True)","9b9f36fd":"# merge data together\nData = Data.merge(results_c, on = 'content_id', how = 'left')\nData = Data.merge(Data_questions, how = 'left', left_on = 'content_id', right_on = 'question_id')","64043347":"# remove invalid 'answered_correctly' entries and keep only questions\nData = Data[Data['answered_correctly'] != -1]\nData = Data[Data['content_type_id'] == 0]\n\n# impute missing values  \nData['prior_question_had_explanation'].fillna(False, inplace = True)\nData = Data.replace([np.inf, -np.inf], np.nan)\nData['prior_question_elapsed_time'].fillna(0, inplace = True)\n\n# drop unwanted columns \nData.drop(['user_id', 'row_id', 'user_answer', 'question_id', 'task_container_id',\n           'content_id', 'content_type_id'], \n          axis = 1, inplace = True)\n\n# cast variables as factors (keep code in case needed)\nData['prior_question_had_explanation'] = Data['prior_question_had_explanation'].astype(int)","b566ef32":"# Create vector or Y\n# store correct answers for later\nlabels = np.array(Data['answered_correctly'])\n\n# Create matrix of regressors\n# store regressors\nData = Data.drop('answered_correctly', axis = 1)\n# store regressor names\nfeature_list = list(Data.columns)# Convert to numpy array\n# cast regressors as numpy array for scikit learn\nData = np.array(Data)","46b0097e":"# Using Skicit-learn to split data into training and testing sets\nfrom sklearn.model_selection import train_test_split \n\n# Split the data into training and testing sets\ntrain_features, test_features, train_labels, test_labels = train_test_split(Data, \n                                                                            labels, \n                                                                            test_size = 0.25, \n                                                                            random_state = 42)","268dbed1":"print('Fitting the model...')\n\n# Import the model we are using\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, VotingClassifier\nfrom sklearn.neural_network import MLPClassifier\n\n# instantiate the random forest classifier\nmodel_rf = RandomForestClassifier(n_estimators = 10,\n                                  max_depth = 3,\n                                  random_state =1)\n\n# instantiate the random forest classifier\nmodel_gbm = GradientBoostingClassifier(n_estimators = 10,\n                                       max_depth = 1,\n                                       random_state =1)\n\nmodel_nn = MLPClassifier(hidden_layer_sizes = [50,25],\n                         random_state=1)\n\n# package classifiers together in voting machine\nmodel_voting = VotingClassifier(estimators=[('rf',  model_rf), \n                                            ('gbm', model_gbm),\n                                            ('nn',  model_nn)], \n                                voting = 'soft',\n                                n_jobs = 4)\n\n# fit the voting machine\nmodel_voting_fit = model_voting.fit(Data, labels)","906415c0":"from sklearn.metrics import roc_auc_score\n\n# Evaluate the fit of the models \n# predictions  \npredictions = model_voting_fit.predict(test_features)\n# calcualte AUC\nroc_auc_score(predictions, test_labels)","e941f09f":"print('Submitting official predictions...')\n\nimport riiideducation\nenv = riiideducation.make_env()","41e46cd4":"iter_test = env.iter_test()\n\nfor (test_df, sample_prediction_df) in iter_test:\n    \n    # Merge in extra features\n    test_df = test_df.merge(results_c, on = 'content_id', how = 'left')\n    test_df = test_df.merge(Data_questions, how = 'left', left_on = 'content_id', right_on = 'question_id')\n   \n    # Data cleaning\n    ## impute missing values  \n    test_df['prior_question_had_explanation'].fillna(False, inplace = True)\n    test_df['prior_question_elapsed_time'].fillna(0, inplace = True)\n    with pd.option_context('mode.use_inf_as_na', True):\n        test_df = test_df.dropna(subset = ['prior_question_elapsed_time'], how = 'all')\n\n    \n    test_df['answered_correctly_content'].fillna(ansered_correctly_unconditional, inplace = True)\n    \n    test_df['bundle_id'].fillna(0, inplace = True)\n    test_df['part'].fillna(0, inplace = True)\n    test_df['tags1'].fillna(0, inplace = True)\n    test_df['tags2'].fillna(0, inplace = True)\n    test_df['tags3'].fillna(0, inplace = True)\n    test_df['tags4'].fillna(0, inplace = True)\n    test_df['tags5'].fillna(0, inplace = True)\n    test_df['tags6'].fillna(0, inplace = True)\n    \n    ## drop unwanted columns \n    row_id = test_df['row_id']\n    content_type_id = test_df['content_type_id']\n    test_df = test_df[feature_list]\n\n    ## cast variables as factors\n    test_df['prior_question_had_explanation'] = test_df['prior_question_had_explanation'].astype(int)\n\n    # Make predictions\n    test_df['answered_correctly'] = model_voting_fit.predict_proba(test_df)[:,1]\n    test_df['row_id'] = row_id\n    test_df['content_type_id'] = content_type_id\n    \n    # Submit predictions\n    env.predict(test_df.loc[test_df['content_type_id'] == 0, ['row_id', 'answered_correctly']])","c6cc1d71":"## Prepare training data","ebd389d3":"## Fit the model"}}