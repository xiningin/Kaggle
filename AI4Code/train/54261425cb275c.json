{"cell_type":{"e4149a10":"code","d5911e21":"code","9b7d674a":"code","1cc93e5c":"code","b25b80bc":"code","d2564dd9":"code","58961e28":"code","2b685562":"code","abb9a556":"code","d57d76b2":"code","bca4bbfc":"code","09688202":"code","f3b4fd03":"code","01f05a50":"code","6d58d4ac":"code","06823cb4":"code","1759ddaf":"code","62635646":"markdown","5f4d9f06":"markdown","9dc1e1dd":"markdown","13d16082":"markdown","d8d57214":"markdown","212e6314":"markdown","c5423f6b":"markdown","c32c953b":"markdown","7528043d":"markdown"},"source":{"e4149a10":"import os\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport json\nfrom tensorflow.keras.layers import Input, Conv2D, Flatten, Dense, Conv2DTranspose, Reshape, Lambda, Activation, BatchNormalization, LeakyReLU, Dropout, ZeroPadding2D, UpSampling2D\nfrom tensorflow.keras.models import Model, Sequential\nfrom tensorflow.keras import backend as K\nfrom tensorflow.keras.optimizers import Adam, RMSprop\nfrom tensorflow.keras.callbacks import ModelCheckpoint \nfrom tensorflow.keras.utils import plot_model\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.initializers import RandomNormal\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator, load_img, save_img, img_to_array\nfrom functools import partial","d5911e21":"class WGAN():\n    def __init__(self\n        , input_dim\n        , critic_conv_filters\n        , critic_conv_kernel_size\n        , critic_conv_strides\n        , critic_batch_norm_momentum\n        , critic_activation\n        , critic_dropout_rate\n        , critic_learning_rate\n        , generator_initial_dense_layer_size\n        , generator_upsample\n        , generator_conv_filters\n        , generator_conv_kernel_size\n        , generator_conv_strides\n        , generator_batch_norm_momentum\n        , generator_activation\n        , generator_dropout_rate\n        , generator_learning_rate\n        , optimiser\n        , z_dim\n        ):\n\n        self.name = 'gan'\n\n        self.input_dim = input_dim\n        self.critic_conv_filters = critic_conv_filters\n        self.critic_conv_kernel_size = critic_conv_kernel_size\n        self.critic_conv_strides = critic_conv_strides\n        self.critic_batch_norm_momentum = critic_batch_norm_momentum\n        self.critic_activation = critic_activation\n        self.critic_dropout_rate = critic_dropout_rate\n        self.critic_learning_rate = critic_learning_rate\n\n        self.generator_initial_dense_layer_size = generator_initial_dense_layer_size\n        self.generator_upsample = generator_upsample\n        self.generator_conv_filters = generator_conv_filters\n        self.generator_conv_kernel_size = generator_conv_kernel_size\n        self.generator_conv_strides = generator_conv_strides\n        self.generator_batch_norm_momentum = generator_batch_norm_momentum\n        self.generator_activation = generator_activation\n        self.generator_dropout_rate = generator_dropout_rate\n        self.generator_learning_rate = generator_learning_rate\n        \n        self.optimiser = optimiser\n\n        self.z_dim = z_dim\n\n        \n\n        self.n_layers_critic = len(critic_conv_filters)\n        self.n_layers_generator = len(generator_conv_filters)\n\n        self.weight_init = RandomNormal(mean=0., stddev=0.02)\n\n        self.d_losses = []\n        self.g_losses = []\n\n        self.epoch = 0\n\n    \n        self._build_critic()\n        self._build_generator()\n\n        self._build_adversarial()\n\n    def wasserstein(self, y_true, y_pred):\n        return - K.mean(y_true * y_pred)\n\n    def get_activation(self, activation):\n        if activation == 'leaky_relu':\n            layer = LeakyReLU(alpha = 0.2)\n        else:\n            layer = Activation(activation)\n        return layer\n\n    def _build_critic(self):\n\n        ### THE critic\n        critic_input = Input(shape=self.input_dim, name='critic_input')\n\n        x = critic_input\n\n        for i in range(self.n_layers_critic):\n\n            x = Conv2D(\n                filters = self.critic_conv_filters[i]\n                , kernel_size = self.critic_conv_kernel_size[i]\n                , strides = self.critic_conv_strides[i]\n                , padding = 'same'\n                , name = 'critic_conv_' + str(i)\n                , kernel_initializer = self.weight_init\n                )(x)\n\n            if self.critic_batch_norm_momentum and i > 0:\n                x = BatchNormalization(momentum = self.critic_batch_norm_momentum)(x)\n\n            x = self.get_activation(self.critic_activation)(x)\n\n            if self.critic_dropout_rate:\n                x = Dropout(rate = self.critic_dropout_rate)(x)\n\n        x = Flatten()(x)\n\n        critic_output = Dense(1, activation=None\n        , kernel_initializer = self.weight_init\n        )(x)\n\n        self.critic = Model(critic_input, critic_output)\n\n\n\n    def _build_generator(self):\n\n        ### THE generator\n\n        generator_input = Input(shape=(self.z_dim,), name='generator_input')\n\n        x = generator_input\n\n        x = Dense(np.prod(self.generator_initial_dense_layer_size)\n        ,kernel_initializer = self.weight_init\n        )(x)\n\n        \n        if self.generator_batch_norm_momentum:\n            x = BatchNormalization(momentum = self.generator_batch_norm_momentum)(x)\n\n        x = self.get_activation(self.generator_activation)(x)\n\n        x = Reshape(self.generator_initial_dense_layer_size)(x)\n\n        if self.generator_dropout_rate:\n            x = Dropout(rate = self.generator_dropout_rate)(x)\n\n        for i in range(self.n_layers_generator):\n\n            if self.generator_upsample[i] == 2:\n                x = UpSampling2D()(x)\n                x = Conv2D(\n                filters = self.generator_conv_filters[i]\n                , kernel_size = self.generator_conv_kernel_size[i]\n                , padding = 'same'\n                , name = 'generator_conv_' + str(i)\n                , kernel_initializer = self.weight_init\n                )(x)\n            else:\n\n                x = Conv2DTranspose(\n                    filters = self.generator_conv_filters[i]\n                    , kernel_size = self.generator_conv_kernel_size[i]\n                    , padding = 'same'\n                    , strides = self.generator_conv_strides[i]\n                    , name = 'generator_conv_' + str(i)\n                    , kernel_initializer = self.weight_init\n                    )(x)\n\n            if i < self.n_layers_generator - 1:\n\n                if self.generator_batch_norm_momentum:\n                    x = BatchNormalization(momentum = self.generator_batch_norm_momentum)(x)\n\n                x = self.get_activation(self.generator_activation)(x)\n            \n            else:\n                x = Activation('tanh')(x)\n\n\n        generator_output = x\n\n        self.generator = Model(generator_input, generator_output)\n\n\n    def get_opti(self, lr):\n        if self.optimiser == 'adam':\n            opti = Adam(lr=lr, beta_1=0.5)\n        elif self.optimiser == 'rmsprop':\n            opti = RMSprop(lr=lr)\n        else:\n            opti = Adam(lr=lr)\n\n        return opti\n\n    def set_trainable(self, m, val):\n        m.trainable = val\n        for l in m.layers:\n            l.trainable = val\n\n\n    def _build_adversarial(self):\n        \n        ### COMPILE critic\n\n        self.critic.compile(\n            optimizer=self.get_opti(self.critic_learning_rate) \n            , loss = self.wasserstein\n        )\n        \n        ### COMPILE THE FULL GAN\n\n        self.set_trainable(self.critic, False)\n\n        model_input = Input(shape=(self.z_dim,), name='model_input')\n        model_output = self.critic(self.generator(model_input))\n        self.model = Model(model_input, model_output)\n        \n        self.model.compile(\n            optimizer=self.get_opti(self.generator_learning_rate)\n            , loss=self.wasserstein\n            )\n\n        self.set_trainable(self.critic, True)\n\n\n\n    \n    def train_critic(self, x_train, batch_size, clip_threshold, using_generator):\n\n        valid = np.ones((batch_size,1))\n        fake = -np.ones((batch_size,1))\n\n        if using_generator:\n            true_imgs = next(x_train)[0]\n            if true_imgs.shape[0] != batch_size:\n                true_imgs = next(x_train)[0]\n        else:\n            idx = np.random.randint(0, x_train.shape[0], batch_size)\n            true_imgs = x_train[idx]\n        \n        \n        noise = np.random.normal(0, 1, (batch_size, self.z_dim))\n        gen_imgs = self.generator.predict(noise)\n\n        d_loss_real =   self.critic.train_on_batch(true_imgs, valid)\n        d_loss_fake =   self.critic.train_on_batch(gen_imgs, fake)\n        d_loss = 0.5 * (d_loss_real + d_loss_fake)\n\n        for l in self.critic.layers:\n            weights = l.get_weights()\n            weights = [np.clip(w, -clip_threshold, clip_threshold) for w in weights]\n            l.set_weights(weights)\n\n        return [d_loss, d_loss_real, d_loss_fake]\n\n    def train_generator(self, batch_size):\n        valid = np.ones((batch_size,1))\n        noise = np.random.normal(0, 1, (batch_size, self.z_dim))\n        return self.model.train_on_batch(noise, valid)\n\n\n    def train(self, x_train, batch_size, epochs, run_folder, print_every_n_batches = 10\n        , n_critic = 5\n        , clip_threshold = 0.01\n        , using_generator = False):\n\n        for epoch in range(self.epoch, self.epoch + epochs):\n\n            for _ in range(n_critic):\n                d_loss = self.train_critic(x_train, batch_size, clip_threshold, using_generator)\n\n            g_loss = self.train_generator(batch_size)\n               \n            # Plot the progress\n            \n            self.d_losses.append(d_loss)\n            self.g_losses.append(g_loss)\n\n            # If at save interval => save generated image samples\n            if epoch % print_every_n_batches == 0:\n                print (\"%d [D loss: (%.3f)(R %.3f, F %.3f)]  [G loss: %.3f] \" % (epoch, d_loss[0], d_loss[1], d_loss[2], g_loss))\n                self.sample_images(run_folder)\n                self.model.save_weights(os.path.join(run_folder, 'weights\/weights.h5'))\n                self.save_model(run_folder)\n            \n            self.epoch+=1\n\n    def sample_images(self, run_folder):\n        r, c = 5, 5\n        noise = np.random.normal(0, 1, (r * c, self.z_dim))\n        gen_imgs = self.generator.predict(noise)\n\n        #Rescale images 0 - 1\n\n        gen_imgs = 0.5 * (gen_imgs + 1)\n        gen_imgs = np.clip(gen_imgs, 0, 1)\n\n        fig, axs = plt.subplots(r, c, figsize=(15,15))\n        cnt = 0\n\n        for i in range(r):\n            for j in range(c):\n                axs[i,j].imshow(np.squeeze(gen_imgs[cnt, :,:,:]), cmap = 'gray_r')\n                axs[i,j].axis('off')\n                cnt += 1\n        fig.savefig(os.path.join(run_folder, \"sample_%d.png\" % self.epoch))\n        plt.close()\n\n    def plot_model(self, run_folder):\n        plot_model(self.model, to_file=os.path.join(run_folder ,'viz\/model.png'), show_shapes = True, show_layer_names = True)\n        plot_model(self.critic, to_file=os.path.join(run_folder ,'viz\/critic.png'), show_shapes = True, show_layer_names = True)\n        plot_model(self.generator, to_file=os.path.join(run_folder ,'viz\/generator.png'), show_shapes = True, show_layer_names = True)\n\n\n\n            \n    def save(self, folder):\n\n            with open(os.path.join(folder, 'params.pkl'), 'wb') as f:\n                pickle.dump([\n                    self.input_dim\n                    , self.critic_conv_filters\n                    , self.critic_conv_kernel_size\n                    , self.critic_conv_strides\n                    , self.critic_batch_norm_momentum\n                    , self.critic_activation\n                    , self.critic_dropout_rate\n                    , self.critic_learning_rate\n                    , self.generator_initial_dense_layer_size\n                    , self.generator_upsample\n                    , self.generator_conv_filters\n                    , self.generator_conv_kernel_size\n                    , self.generator_conv_strides\n                    , self.generator_batch_norm_momentum\n                    , self.generator_activation\n                    , self.generator_dropout_rate\n                    , self.generator_learning_rate\n                    , self.optimiser\n                    , self.z_dim\n                    ], f)\n\n            self.plot_model(folder)\n\n    def save_model(self, run_folder):\n        self.model.save(os.path.join(run_folder, 'model.h5'))\n        self.critic.save(os.path.join(run_folder, 'critic.h5'))\n        self.generator.save(os.path.join(run_folder, 'generator.h5'))\n\n    def load_weights(self, filepath):\n        self.model.load_weights(filepath)","9b7d674a":"batch_size = 100\nimage_width = 32","1cc93e5c":"(x_train, y_train), (x_test, y_test) = mnist.load_data()","b25b80bc":"indices = np.random.choice(x_train.shape[0], 5000)\nx_train = x_train[indices]\ny_train = y_train[indices]\nx_train.shape, y_train.shape","d2564dd9":"x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)","58961e28":"images = []\nfor i in range(x_train.shape[0]):\n  images.append(tf.image.resize(x_train[i, :, :], [image_width, image_width]))\nimages = np.array(images)","2b685562":"data_gen = ImageDataGenerator(preprocessing_function=lambda x: (x.astype('float32') - 127.5) \/ 127.5)\ndataset = data_gen.flow(\n    x= images,\n    y = y_train,\n    batch_size = batch_size, \n    shuffle = True\n)","abb9a556":"plt.imshow(dataset[0][0][0].reshape(image_width, image_width))","d57d76b2":"gan = WGAN(input_dim = (image_width,image_width,1)\n            , critic_conv_filters = [image_width,image_width * 2,image_width * 4,image_width * 4]\n            , critic_conv_kernel_size = [5, 5, 5, 5]\n            , critic_conv_strides = [2, 2, 2, 1]\n            , critic_batch_norm_momentum = None\n            , critic_activation = 'leaky_relu'\n            , critic_dropout_rate = None\n            , critic_learning_rate = 0.00005\n            , generator_initial_dense_layer_size = (4, 4, image_width * 4)\n            , generator_upsample = [2,2, 2,1]\n            , generator_conv_filters = [image_width * 4,image_width * 2,image_width,1]\n            , generator_conv_kernel_size = [5, 5, 5, 5]\n            , generator_conv_strides = [1, 1, 1 ,1]\n            , generator_batch_norm_momentum = 0.8\n            , generator_activation = 'leaky_relu'\n            , generator_dropout_rate = None\n            , generator_learning_rate = 0.00005\n            , optimiser = 'rmsprop'\n            , z_dim = 100\n            )","bca4bbfc":"run_folder = \"out\"\nif not os.path.exists(run_folder):\n    os.makedirs(run_folder)\n    os.makedirs(os.path.join(run_folder, \"images\"))\n    os.makedirs(os.path.join(run_folder, \"weights\"))\n    os.makedirs(os.path.join(run_folder, \"viz\"))","09688202":"gan.critic.summary()","f3b4fd03":"gan.generator.summary()","01f05a50":"epochs = 5000\nprint_every_batches = 100","6d58d4ac":"gan.train(     \n    dataset\n    , batch_size = batch_size\n    , epochs = epochs\n    , run_folder = run_folder\n    , print_every_n_batches = print_every_batches\n    , using_generator = True\n)","06823cb4":"fig = plt.figure()\nplt.plot([x[0] for x in gan.d_losses], color='black', linewidth=0.25)\n\nplt.plot([x[1] for x in gan.d_losses], color='green', linewidth=0.25)\nplt.plot([x[2] for x in gan.d_losses], color='red', linewidth=0.25)\nplt.plot(gan.g_losses, color='orange', linewidth=0.25)\n\nplt.xlabel('batch', fontsize=18)\nplt.ylabel('loss', fontsize=16)\nplt.show()","1759ddaf":"row_count, column_count = 5, 5\nnoise = np.random.normal(0, 1, (row_count * column_count, gan.z_dim))\ngen_imgs = gan.generator.predict(noise)\ngen_imgs = 0.5 * (gen_imgs + 1)\nfig, axs = plt.subplots(row_count, column_count, figsize=(10,10))\nfor i in range(row_count):\n    for j in range(column_count):\n        axs[i,j].imshow(np.squeeze(gen_imgs[i * row_count + j, :,:,:]), cmap = 'gray_r')\n        axs[i,j].axis('off')\nplt.show()","62635646":"## Building the Model","5f4d9f06":"## Displaying random image","9dc1e1dd":"## Utilities","13d16082":"## Ploting performance during training","d8d57214":"## Generating images\nNow we use our trained model to generate some images.","212e6314":"## Training the Model","c5423f6b":"## Importing Packages","c32c953b":"## Conclusions\nThis images looks not bad, if we train more times and use higher resolution images, It can be more realistic.","7528043d":"## Loading the data\nNow we load the mnist data and resize it to 32 * 32. In order to speed up the training, I will only choose 5000 images."}}