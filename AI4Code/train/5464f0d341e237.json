{"cell_type":{"c970b978":"code","6f4af851":"code","f6d5589b":"code","11fbdd9b":"code","a12ea5a9":"code","b1b0d319":"code","e3bab701":"code","a4cb7f94":"code","a49c6e6f":"code","16dcca20":"code","3ebfefed":"code","5bdd415a":"code","f1c23d83":"code","bc0081f2":"code","080a5632":"code","86a1b9ac":"code","38620a1d":"code","92091cda":"code","76af5305":"code","bb76042d":"code","3aec2f05":"code","88c659aa":"code","e2528f8a":"code","1c894497":"code","416088fd":"code","ed642b78":"code","efdbe5b6":"code","f0f570ca":"code","0fe09bd0":"code","4c962d38":"code","71cea4a7":"code","5e255bde":"markdown","c37c1402":"markdown","20ec21c5":"markdown","661317ba":"markdown","fb319f60":"markdown","4e23f470":"markdown"},"source":{"c970b978":"import numpy as np \nimport pandas as pd \nfrom sklearn.model_selection import train_test_split , GridSearchCV\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import classification_report , confusion_matrix\nfrom sklearn.datasets import fetch_lfw_people\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA","6f4af851":"lwf_people = fetch_lfw_people(min_faces_per_person=70 , resize=0.4 )","f6d5589b":"samples , h ,w =  lwf_people.images.shape\nprint(samples)\nprint(h,w,h*w)\nprint(h\/0.6,w\/0.6,h*w\/0.36)\nprint('original size = (94,62) = 5828')","11fbdd9b":"lwf_people.data.shape","a12ea5a9":"X = lwf_people.data\nn_features = X.shape[1]","b1b0d319":"y=lwf_people.target\ntarget_names = lwf_people.target_names\nn_class = target_names.shape[0]","e3bab701":"print(target_names)","a4cb7f94":"print(\"Total dataset size:\")\nprint(\"n_samples: %d\" % samples)\nprint(\"n_features: %d\" % n_features)\nprint(\"n_classes: %d\" % n_class)","a49c6e6f":"dfy = pd.Series(y)\ndfy.value_counts()","16dcca20":"u, s, vh = np.linalg.svd(X.T)","3ebfefed":"plt.plot(s)\nplt.grid()","5bdd415a":"plt.plot(s[:100])\nplt.grid()","f1c23d83":"u[:,0]@u[:,2]","bc0081f2":"import matplotlib.pyplot as plt\nfig, axs = plt.subplots(10, 15, figsize=(20, 20))\n# print(axs)\nii = 0 \nfor axr in axs:\n    for ax in axr:\n        ax.imshow(u[:,ii].reshape(h,w), cmap = 'gray')\n        ax.grid(True)\n        ii = ii+1","080a5632":"import matplotlib.pyplot as plt\nfig, axs = plt.subplots(10, 2, figsize=(10, 40))\n# print(axs)\nii = 0 \nindx = np.where(y == 0)[0]\ncoeff = []\nfor axr in axs:\n    im_num = 0\n    for ax in axr:\n        imag_tmp = np.zeros(u[:,0].shape)\n        coeff_tmp = []\n        for tmp in range(150):\n            coeff_tmp.append(X[indx[ii],:]@u[:,tmp])\n            imag_tmp = imag_tmp + X[indx[ii],:]@u[:,tmp]*u[:,tmp]\n        coeff.append(coeff_tmp)\n        imag_tmp =     np.concatenate((X[indx[ii],:], imag_tmp), axis=0)\n        ax.imshow(imag_tmp.reshape(2*h,w), cmap = 'gray')\n#         if im_num == 0:\n#             ax.imshow(imag_tmp.reshape(h,w), cmap = 'gray')\n#         else:\n#             ax.imshow(X[indx[ii],:].reshape(h,w), cmap = 'gray')\n        ax.grid(True)\n        ii = ii+1\n        im_num = im_num + 1","86a1b9ac":"tmp = np.array(coeff) - np.array(coeff).mean(axis = 1,keepdims=True)\ntmp = tmp\/np.abs(tmp).max(axis = 1,keepdims=True)\nplt.plot(np.abs(tmp)[:,2:50].T)\nplt.grid()\nplt.show()","38620a1d":"import matplotlib.pyplot as plt\nfig, axs = plt.subplots(10, 2, figsize=(10, 40))\n# print(axs)\nii = 0 \nindx = np.where(y == 1)[0]\ncoeff = []\nfor axr in axs:\n    im_num = 0\n    for ax in axr:\n        imag_tmp = np.zeros(u[:,0].shape)\n        coeff_tmp = []\n        for tmp in range(150):\n            coeff_tmp.append(X[indx[ii],:]@u[:,tmp])\n            imag_tmp = imag_tmp + X[indx[ii],:]@u[:,tmp]*u[:,tmp]\n        coeff.append(coeff_tmp)\n        imag_tmp =     np.concatenate((X[indx[ii],:], imag_tmp), axis=0)\n        ax.imshow(imag_tmp.reshape(2*h,w), cmap = 'gray')\n#         if im_num == 0:\n#             ax.imshow(imag_tmp.reshape(h,w), cmap = 'gray')\n#         else:\n#             ax.imshow(X[indx[ii],:].reshape(h,w), cmap = 'gray')\n        ax.grid(True)\n        ii = ii+1\n        im_num = im_num + 1","92091cda":"tmp = np.array(coeff) - np.array(coeff).mean(axis = 1,keepdims=True)\ntmp = tmp\/np.abs(tmp).max(axis = 1,keepdims=True)\nplt.plot(np.abs(tmp)[:,2:50].T)\nplt.grid()\nplt.show()","76af5305":"X_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.25, random_state=42)","bb76042d":"dfy = pd.Series(y_test)\ndfy.value_counts()","3aec2f05":"import time\n# Compute a PCA (eigenfaces) on the face dataset (treated as unlabeled\n# dataset): unsupervised feature extraction \/ dimensionality reduction\nn_components = 150\n\nprint(\"Extracting the top %d eigenfaces from %d faces\"% (n_components, X_train.shape[0]))\nt0 = time.time()\npca = PCA(n_components=n_components, svd_solver='randomized',whiten=True).fit(X_train)\nprint(\"done in %0.3fs\" % (time.time() - t0))","88c659aa":"pca.components_.shape","e2528f8a":"eigenfaces = pca.components_.reshape((n_components , h,w))","1c894497":"eigenfaces.shape","416088fd":"import matplotlib.pyplot as plt\nfig, axs = plt.subplots(10, 15, figsize=(20, 20))\n# print(axs)\nii = 0 \nfor axr in axs:\n    for ax in axr:\n        ax.imshow(eigenfaces[ii,:,:], cmap = 'gray')\n        ax.grid(True)\n        ii = ii+1","ed642b78":"print(\"Projecting the input data on the eigenfaces orthonormal basis\")\nt0 = time.time()\nX_train_pca = pca.transform(X_train)\nX_test_pca = pca.transform(X_test)\nprint(\"done in %0.3fs\" % (time.time() - t0))","efdbe5b6":"X_train_pca.shape","f0f570ca":"X_test_pca.shape","0fe09bd0":"indx = np.where(y == 5)[0]\nX_train_pca[indx[:5]][:,:5]","4c962d38":"# Train a SVM classification model\n\nprint(\"Fitting the classifier to the training set\")\nt0 = time.time()\n# param_grid = {'C': [1e3, 5e3, 1e4, 5e4, 1e5],\n#               'gamma': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.1], }\nparam_grid = {'C': [1e3, 5e3],\n              'gamma': [0.001, 0.005, 0.01], }\nclf = GridSearchCV(SVC(kernel='rbf', class_weight='balanced'),\n                   param_grid, cv=5, iid=False)\nclf = clf.fit(X_train_pca, y_train)\nprint(\"done in %0.3fs\" % (time.time() - t0))\nprint(\"Best estimator found by grid search:\")\nprint(clf.best_estimator_)","71cea4a7":"# Quantitative evaluation of the model quality on the test set\n\nprint(\"Predicting people's names on the test set\")\nt0 = time.time()\ny_pred = clf.predict(X_test_pca)\nprint(\"done in %0.3fs\" % (time.time() - t0))\n\nprint(classification_report(y_test, y_pred, target_names=target_names))\nprint(confusion_matrix(y_test, y_pred, labels=range(n_class)))\n","5e255bde":"# Dataset is imbalance.\nWe might need to do something about it but for this SVD example, we just want to show eigenfaces.","c37c1402":"This is similar to CNN but we extract the feature using SVD (PCA).  \nCNN uses backpropagation to update each convolutional layer.  \nhttps:\/\/developer.nvidia.com\/discover\/convolutional-neural-network  \n<img src=\"https:\/\/developer.nvidia.com\/sites\/default\/files\/pictures\/2018\/convolutional_neural_network.png\" alt=\" \" width = \"500\" >","20ec21c5":"# Train using SVM  \nhttps:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.svm.SVC.html  \nSVC is a kind of SVM.  \nhttps:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.model_selection.GridSearchCV.html  \nGridSearchCV search for a best parameters.  \nclf = GridSearchCV(SVC(kernel='rbf', class_weight='balanced'),\n                   param_grid, cv=5, iid=False)  ","661317ba":"precision: TP\/(TP+TN)  \ncompute for data in Column for each class only.  \n","fb319f60":"# Load faces  \nhttps:\/\/scikit-learn.org\/stable\/datasets\/real_world.html#labeled-faces-in-the-wild-dataset \n> min_faces_per_personint, default=None  \n\nThe extracted dataset will only retain pictures of people that have at least min_faces_per_person different pictures.  \n\n> resizefloat, default=0.5  \n\nRatio used to resize the each face picture.\n\n","4e23f470":"# Orthogonal\nu[:,ii] are orthogonal.  \n`u[:,ii]@u[:,jj] = 0`  "}}