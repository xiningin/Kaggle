{"cell_type":{"31feafe0":"code","3fb03692":"code","997889fb":"code","62e8c685":"code","3c1fdcc9":"code","4168f7a3":"code","38335548":"code","e5165428":"code","b713164c":"code","444c7b45":"code","02ac9d83":"code","56fa3d64":"code","54e5813d":"code","69f20e4b":"code","d1d522fa":"code","38062250":"markdown"},"source":{"31feafe0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport matplotlib.cm as cm\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","3fb03692":"# Carregar dados de treino e teste\ntrain_data = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\ntest_data = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\n\nprint(train_data.head())","997889fb":"# recompor dados de treino e teste\nX_train = train_data.drop('label',axis=1)\nX_train = X_train.values\nX_train = X_train.astype('float32')","62e8c685":"# r\u00f3tulos de dados \ny_train = train_data['label']\ny_train = y_train.values\ny_train = y_train.astype('float32')\nX_test = test_data.astype('float32')\n\nprint(\"Dados de treino com %d exemplos.\" % len(X_train))\nprint(\"Dados de teste com %d exemplos.\" % len(X_test))","3c1fdcc9":"# Transformando a imagem 2d em um numpy array (imagem 28*28 = 784 pixels)\nX_train = X_train.reshape(42000, 28, 28, 1)\nX_test = X_test.values.reshape(28000, 28, 28, 1)\n\n# Normalizando para valores entre 0 e 1\nX_train = X_train.astype('float32')\nX_train \/= 255\n\nX_test = X_test.astype('float32')\nX_test \/= 255\n\nprint(X_train.shape)\nprint(X_test.shape)\n","4168f7a3":"# Visualizar a quantidade de exemplos de cada d\u00edgito\nimport seaborn as sns\nsns.set_theme(style=\"darkgrid\")\nsns.countplot(x='label', data=train_data)","38335548":"from keras.utils import np_utils\nfrom sklearn.model_selection import train_test_split\n\n# Separar dados de treino e valida\u00e7\u00e3o\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size = 0.1, random_state=37)\n\ny_train = np_utils.to_categorical(y_train, 10)\ny_val = np_utils.to_categorical(y_val, 10)\n\ninput_shape = X_train.shape[1:]\ninput_shape","e5165428":"from keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Activation, Conv2D, MaxPooling2D\nfrom keras.optimizers import RMSprop\n\nmodel = Sequential()\n# Conv2D: Camada com kernels (filtros) que percorrem a imagem extraindo caracter\u00edsitcas (mapas de caracte\u00edsticas)\nmodel.add(Conv2D(20, kernel_size=(4, 4),\n                 activation='relu',\n                 input_shape=(28,28,1)))\n# MaxPooling2D: Camada que reduz a dimensionalidade dos mapas de caracter\u00edsticas 2D\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(40, kernel_size=(3,3), activation='relu'))\n# Flatten: Camada que transforma um mapa de caracter\u00edsticas 2D num vetor para classficador final\nmodel.add(Flatten())\n# Dense: Camada totalmente conectada com 50 neur\u00f4nios\nmodel.add(Dense(50))\n# Activation: Camada onde podemos definir a fun\u00e7\u00e3o de ativa\u00e7\u00e3o. No caso, 'relu'\nmodel.add(Activation('relu'))\n# Dropout: Camada que treino descarta aleatoriamente um percentual de conex\u00f5es com o intuito de reduzir overfiting\nmodel.add(Dropout(0.15))\n# Dense: Camada totalmente conectada com 10 neur\u00f4nios\nmodel.add(Dense(10))  # quantidade de categorias\n# Activation: Camada onde podemos definir a fun\u00e7\u00e3o de ativa\u00e7\u00e3o. No caso, 'softmax'\nmodel.add(Activation('softmax'))\nmodel.summary()","b713164c":"# Modelo compilado com:\n# - loss: fun\u00e7\u00e3o de \"perda\" crossentropy usada quando se tem duas ou mais classes\n# - optimizer: Algoritmo RMSprop\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy'])\n\nmodel.summary()\n\nprint(\"input shape \",model.input_shape)\nprint(\"output shape \",model.output_shape)","444c7b45":"batch_size = 128\nnb_epoch = 20\nhistory = model.fit(X_train, y_train, epochs=nb_epoch, batch_size=batch_size, validation_data=(X_val,y_val),verbose=1)","02ac9d83":"fig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","56fa3d64":"score = model.evaluate(X_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","54e5813d":"import itertools\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","69f20e4b":"import numpy as np\nfrom sklearn.metrics import classification_report, confusion_matrix\n\n# Classificando toda base de teste\ny_pred = np.argmax(model.predict(X_val), axis=-1)\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Confution Matrix\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","d1d522fa":"\n\n# Gerando sa\u00edda para dataset de teste\n\n#Carrega dataset de teste\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Qtde de testes: {}\".format(len(test)))\n# Bota no formato numpy e normaliza\nx_test = test.values.reshape(len(test),28,28,1)\nx_test = x_test.astype('float32')\nx_test \/= 255\n\n# Faz classifica\u00e7\u00e3o para dataset de teste\ny_pred = np.argmax(model.predict(x_test), axis=-1)\n\n# Verficando algum exemplo\ni = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Previsto: {}'.format(y_pred[i]))\n\n# Botando no formato de sa\u00edda (competi\u00e7\u00e3o Kaggle)\nresults = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(submission.head(10))\n#Salvando Arquivo\nsubmission.to_csv(\"cnn_mnist_v1.csv\",index=False)","38062250":"# Bibliotecas e Dados"}}