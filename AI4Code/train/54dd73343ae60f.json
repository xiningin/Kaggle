{"cell_type":{"dce7c3b2":"code","33e8d3a4":"code","0fd77188":"code","3945caaa":"code","b895940e":"code","feca63ad":"code","7eeffe06":"code","e21b8569":"code","2ecb149d":"code","33fe5f7a":"code","b70c530e":"code","243bfba2":"markdown","4b6aed9e":"markdown","6b415e07":"markdown","f65106f7":"markdown","ffcd227b":"markdown","e9566d84":"markdown","54eac508":"markdown","ce59bf4b":"markdown","f061e9b7":"markdown","83a4f63f":"markdown","5dc1d775":"markdown","58347c50":"markdown"},"source":{"dce7c3b2":"!pip install recordlinkage --quiet\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport recordlinkage\n\nimport warnings\nwarnings.filterwarnings('ignore')","33e8d3a4":"from recordlinkage.datasets import load_febrl4\n\ndfA, dfB, true_links = load_febrl4(return_links=True)\nprint(\"Dataset A\")\ndisplay(dfA.sort_index().head())\nprint(\"Dataset B\")\ndisplay(dfB.sort_index().head())","0fd77188":"from recordlinkage.preprocessing import phonetic\n\n# Example\nprint(\"\\nNote how all four katies are soundex'd to the same value...\")\nkaties = pd.Series([\"Katy\", \"Kaytee\", \"Katie\", \"Katee\"])\nphonetic_katies = phonetic(katies, \"soundex\")\n\nfor i in range(4):\n    print(katies[i] + \" --> \" + phonetic_katies[i])\n\n# Add a phonetic version of the first and last names to the two datasets\ndfA[\"phonetic_given_name\"] = phonetic(dfA[\"given_name\"], \"soundex\")\ndfB[\"phonetic_given_name\"] = phonetic(dfB[\"given_name\"], \"soundex\")\ndfA[\"phonetic_surname\"] = phonetic(dfA[\"surname\"], \"soundex\")\ndfB[\"phonetic_surname\"] = phonetic(dfB[\"surname\"], \"soundex\")\n\n# I'm also adding \"initials\"\ndfA[\"initials\"] = (dfA[\"given_name\"].str[0]  + dfA[\"surname\"].str[0])\ndfB[\"initials\"] = (dfB[\"given_name\"].str[0]  + dfB[\"surname\"].str[0])\n\n# Cast the social security number to a \"numeric\"\ndfA['soc_sec_id']= pd.to_numeric(dfA['soc_sec_id'])\ndfB['soc_sec_id']= pd.to_numeric(dfB['soc_sec_id'])\n\n# Print out examples of new columsn in dataframe A, these are the new columns...\nprint(\"\\n\\nAfter doing the same thing to our actual dataset...\")\ndisplay(dfA[[\"given_name\", \"phonetic_given_name\", \"surname\", \"phonetic_surname\", \"initials\", \"soc_sec_id\"]].head())","3945caaa":"indexer = recordlinkage.Index()\nindexer.block('initials')\ncandidate_links = indexer.index(dfA, dfB)\n\nprint(candidate_links)","b895940e":"compare = recordlinkage.Compare()\n\ncompare.exact('phonetic_given_name', 'phonetic_given_name', label=\"phonetic_given_name\")\ncompare.exact('phonetic_surname', 'phonetic_surname', label='phonetic_surname')\ncompare.string('given_name', 'given_name', method='jarowinkler', label=\"given_name\")\ncompare.string('surname', 'surname', method='jarowinkler', label=\"surname\")\ncompare.string('suburb', 'suburb', method='jarowinkler', label=\"suburb\")\ncompare.string('state', 'state', method='jarowinkler', label=\"state\")\ncompare.string('address_1', 'address_1', method='jarowinkler', label=\"address_1\")\ncompare.numeric(\"soc_sec_id\",\"soc_sec_id\", label=\"soc_sec_id\")\n\nfeatures = compare.compute(candidate_links, dfA, dfB)\nfeatures","feca63ad":"# Try all scores 0 to 7 in order to see the effect on precision and recall...\nfor i in range(8):\n    matches = features[features.sum(axis=1) > i]\n    pre = recordlinkage.precision(true_links, matches)\n    rcl = recordlinkage.recall(true_links, matches)\n    print(\"when score is \" + str(i) + \" precision is \" + str(pre) + \" and recall is \" + str(rcl))","7eeffe06":"clasifier = recordlinkage.SVMClassifier()\nclasifier.fit(features, true_links)\npredictions = clasifier.predict(features)\n\nprint(\"precision: \" + str(recordlinkage.precision(true_links, predictions)))\nprint(\"recall: \" + str(recordlinkage.recall(true_links, predictions)))","e21b8569":"print(\"Number of false positives: \" + str(recordlinkage.false_positives(true_links, predictions)))\n\nfalse_positives = predictions.difference(true_links)\nfalse_positives","2ecb149d":"fp_from_dfA = false_positives[0][0]\nfp_from_dfB = false_positives[0][1]\n\ndisplay(dfA[dfA.index == fp_from_dfA])\ndisplay(dfB[dfB.index == fp_from_dfB])","33fe5f7a":"print(\"Number of false negatives: \" + str(recordlinkage.false_negatives(true_links, predictions)))\n\nfalse_negatives = true_links.difference(predictions)\nfalse_negatives","b70c530e":"fn_from_dfA = false_negatives[0][0]\nfn_from_dfB = false_negatives[0][1]\n\ndisplay(dfA[dfA.index == fn_from_dfA])\ndisplay(dfB[dfB.index == fn_from_dfB])","243bfba2":"It might seem really unperformant to have blocked away over a fifth of the matches (and in this case it is but I had a point to make!) - it all comes down to which you value more: finding all the matches OR making sure the matches you do find are correct. You can infer how the appetite for each might change as the number of records and number of matches varies (e.g. imagine if we had two sets of 1 million records with only 1000 matches between the two)\n\nBetween tuning each step of the RL algorithm and making decisions regarding precision and recall, there's a lot of scope for tuning and optimisation but hopefully this gives you an idea of what's involved.","4b6aed9e":"So that gets us some of the way, but there are numerous problems with the above approach;\n\n* It relies on a human to pick the score, generally you never want to be doing this in classification problems.\n* It doesn't take into account nuances and interactions between the features. What if it just so happens that high similarity between `given_name` and `suburb` are the absolute best measure of something being a match? just adding up the values and scoring them does not capture this.\n\n# A Better Way\n\nWhenever you find yourself wanting to offload manual choices or surface hidden insights, the answer is almost always to introduce a machine learning algorithm into the mix. In this case, given our data is already just an array of numeric values representing similarity, we can just slot it straight into any machine learning algorithm.\n\nHere I am arbitrarily just using a Support Vector Machine (because they usually perform really well on classification problems) but I could just use any ML classifier to achieve the same result;","6b415e07":"Out of the 100,000 candidate pairs, having only 3 false positives is absolutely amazing! We can see that one of the false positives is that it believes `rec1546` and `rec3587` are matches. If we take a look at those records, we can see why it might have made this mistake...","f65106f7":"Finally let's take a look at the false negatives. This is where the algorithm *should* have found a match, but didn't. \n\nWe would expect there to be quite a few of these because we would have lost a load in our blocking stage (where we discounted everyone that didn't have the same initials). We could decrease these by doing some less aggressive blocking, but let's just go with it for now to see why some of these exist...","ffcd227b":"# Preprocess\n\nFirst you gotta clean your data.\n\nNormally this step would be a *lot* of work, but in this case the Febrl4 dataset is already pretty clean and does not require any of the basic preprocessing that would usually be performed when doing any kind of data science. I am going to do a few things though.\n\nFirstly I am going to do is add a *phonetic* version of the name using the soundex method. This will account for any data entry issues that may have happened and also help accomodate for some of the typos. As you can see from the example below, the objective of soundex is to normalise words that sound the same into the same string.\n\nI'm also going to add an \"initials\" column and cast the social security number to a `numeric` rather than a `string`.","e9566d84":"It was not able to match `rec-1003` with its duplicate counterpart, and if we take a look at that record you can see that the person who entered the data put the persons given name and surnames the wrong way round - this record never therefore got a chance to be matched because it would have been discounted in the blocking stage (because the initials did not match).","54eac508":"The purpose of this notebook is to describe the process of record linkage, which is one method of finding duplicates between two datasets. \n\nThere are two main types of record linkage;\n\n* Deterministic Record Linkage\n* Probabalistic Record Linkage\n\nDeterministic Record Linkage simply involves doing matches and joins on data to find duplicates. If you can get away with doing that, great, go with that. It's much, much easier... however in the real world it seldom performs well due to the high level of inaccuracy that exists in data.\n\nProbabalistic Record Linkage, on the other hand, aims to calculate the probability that two records are a match and then use techniques such as machine learning to classify and find matches automatically.\n\nThis notebook is a step by step guide of how to do probabalistic record linkage using an existing python library (although in principle you could do this without that library, it's much easier to demonstrate this way!).","ce59bf4b":"With zero tuning and without doing any of the usual kinds of due dilligence for machine learning (e.g. test\/train split) we **still** achieve a higher precision and recall than we did with the standard \"scoring\" model from above - and for all we know, it might not even be possible to achieve scores this high with the simple method. Awesome!\n\nAlso note that whilst `SVM` is a supervised machine learning altorithm, you can apply unsupervised algorithms to the same problem (if, for example, you don't have any labelled data).\n\nSo what about the records it got wrong? Let's take a look at some false positives first...","f061e9b7":"# Indexing\/Blocking\n\nThe next step is to pick \"candidate pairs\" from across our dataset - pairs that could potentially be matches. Now we *could* just pair off every single record against every other record, however this would give us big O squared complexity which is extremely wasteful when we know there are nowhere near that many matches.\n\nWhat people normally do is pick some kind of \"rule\" to determine something as being eligable to be paired (known as \"blocking\"). This is somewhere else that you can tune the algorithm - if you're too loose on your blocking rules then you don't save any time, but if you get too aggressive then you end up discounting too many valid pairs.\n\nYou can get pretty creative with how you block, but in this case I am going to block on the \"initials\" column I added in the last step. What you end up with is a pandas **multiindex** showing each candidate pair, each of which is a potential match because they both had the same initials.\n\nIn my case, this is just over 100,000 candidate pairs.\n","83a4f63f":"# Comparisons\n\nNow we've got our candidate pairs the objective is, for each one, to measure the difference between each of the record's features to determine how \"similar\" each feature is. \n\nThis is also somewhere where you can also get creative and do lots of tuning - in this case I'm using something called the \"jarowinkler\" algorithm on all the strings, exact-matches on the phonetic fields I added and a measure of how far away a number is from another number for the social security ID.\n\nIn all cases we end up with, for each feature, a number between 0 and 1 indicating how similar the features are to one another.","5dc1d775":"# Grab a Dataset\n\nFor this example I'm using a dataset called \"Febrl4\". This consists of two sets of 5000 identical records... however the records, whilst all duplicates, are *not* identical. You can see from the small sample below, for example, that the street number of Rachel Dent's record is different in the two datasets, and on Hayden Stapley's record the number is missing completely.\n\nYou can also expect to see typos and other inaccuracies throughout the datasets. The objective therefore is to automatically find as many of the matches as possible based purely on the features (a.k.a. columns) in each record.\n\nThe Febrl4 dataset also includes labels (called \"true_links\" below) which tell you which records should match with which, and you can also infer the matches from the IDs (e.g. **rec-0-org** and **rec-0-org-dub** are matches). Obviously we won't be using either of these to find the matches though :P ","58347c50":"# Classification\n\nFinal step is to classify each candidate pair into either a \"match\" or \"not a match\". There is a really easy way of doing this, which is to simply choose an arbitrary score and add up the values in the comparison above. Any candidate pair that beats your score counts as a match. \n\nWe can evaluate performance using two metrics: Precision and Recall.\n\n* **Precision**: Of the matches it found, how many were right?\n* **Recall**: How many matches did it miss?\n\nIn the snippet below, I try scores that include whole numbers from 0 to 7. You can see the effect this has on precision and recall values - as your score gets higher, your precision increases (i.e. you are getting less false positives) however your recall decreases (i.e. you are not finding all the matches that exist - bear in mind that we already will have lost some of the matches back in the blocking stage). \n\nThis battle between precision and recall is extremely common in data science and finding the sweet-spot here is left up to you. Remember also that these scores *could* include fractions - from the below results we can probably predict that the optimal score is somewhere between 6 and 7."}}