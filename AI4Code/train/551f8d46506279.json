{"cell_type":{"62039779":"code","5c6e5aa6":"code","4dcd4ff8":"code","db8383a9":"code","a9ddeee7":"code","8a71df11":"code","fa6e094d":"code","1a29bbb9":"code","66298b9c":"code","c160808d":"code","f6616df7":"code","f82a64b2":"code","f1cb746e":"code","7355b7fb":"code","1e27f6d0":"code","01d8e0fc":"code","ba9247cc":"code","7594ad61":"code","7abfb2c3":"code","c5438eb9":"code","b4e5acec":"code","68347803":"code","b10c7607":"markdown"},"source":{"62039779":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","5c6e5aa6":"import matplotlib.pyplot as plt\nimport seaborn as sns","4dcd4ff8":"import pandas as pd\ndata = pd.read_csv(\"\/kaggle\/input\/creditcard-master-iuma\/creditcard.csv\")\n\ndata.head()","db8383a9":"data.columns","a9ddeee7":"data.groupby('Class').Class.count()","8a71df11":"sns.countplot('Class',data=data)\nplt.show()","fa6e094d":"from sklearn.preprocessing import StandardScaler\n\ndata['normAmount'] = StandardScaler().fit_transform(data['Amount'].values.reshape(-1, 1))\ndata = data.drop(['Time', 'Amount'], axis=1)\ndata.columns","1a29bbb9":"from imblearn.over_sampling import SMOTE","66298b9c":"from sklearn.model_selection import train_test_split\n\nX = data.drop('Class', axis = 1)\ny = data.Class\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)\n\n","c160808d":"print(\"X_train dataset: \", X_train.shape)\nprint(\"y_train dataset: \", y_train.shape)\nprint(\"X_test dataset: \", X_test.shape)\nprint(\"y_test dataset: \", y_test.shape)","f6616df7":"print(\"Antes de OverSampling, cuenta de '1': {}\".format(sum(y_train==1)))\nprint(\"Antes de OverSampling, cuenta de '0': {} \\n\".format(sum(y_train==0)))","f82a64b2":"sm = SMOTE(random_state=2)","f1cb746e":"X_train_res, y_train_res = sm.fit_sample(X_train, y_train.ravel())\n","7355b7fb":"print('Despu\u00e9s de OverSampling, train_X: {}'.format(X_train_res.shape))\nprint('Despu\u00e9s de OverSampling, train_y: {} \\n'.format(y_train_res.shape))\n\nprint(\"Despu\u00e9s de OverSampling, cuenta de '1': {}\".format(sum(y_train_res==1)))\nprint(\"Despu\u00e9s de OverSampling, cuenta de '0': {}\".format(sum(y_train_res==0)))","1e27f6d0":"from sklearn.model_selection import GridSearchCV\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, precision_recall_curve, auc, roc_auc_score, roc_curve, recall_score, classification_report\n\nparameters = {\n    'C': np.linspace(1, 10, 10)\n             }\nlr = LogisticRegression()\nclf = GridSearchCV(lr, parameters, cv=5, verbose=5, n_jobs=-1)\nclf.fit(X_train_res, y_train_res.ravel())","01d8e0fc":"clf.best_params_","ba9247cc":"lr1 = LogisticRegression(C=4,penalty='l1', solver='warn', verbose=5)\nlr1.fit(X_train_res, y_train_res.ravel())","7594ad61":"import itertools\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    Esta funci\u00f3n plotea la matriz de confusi\u00f3n, \n    se normaliza con normalize = True\n    .\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=0)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        #print(\"Normalized confusion matrix\")\n    else:\n        1#print('Confusion matrix, without normalization')\n\n    #print(cm)\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('etiqueta verdadera')\n    plt.xlabel('etiqueta predicha')","7abfb2c3":"y_train_pre = lr1.predict(X_train)\n\ncnf_matrix_tra = confusion_matrix(y_train, y_train_pre)\n\nprint(\"Recall para el dataset de train: {}%\".format(100*cnf_matrix_tra[1,1]\/(cnf_matrix_tra[1,0]+cnf_matrix_tra[1,1])))\n\n\nclass_names = [0,1]\nplt.figure()\nplot_confusion_matrix(cnf_matrix_tra , classes=class_names, title='matriz de confusi\u00f3n')\nplt.show()","c5438eb9":"y_pre = lr1.predict(X_test)\n\ncnf_matrix = confusion_matrix(y_test, y_pre)\n\nprint(\"Recall para el dataset de test: {}%\".format(100*cnf_matrix[1,1]\/(cnf_matrix[1,0]+cnf_matrix[1,1])))\n#print(\"m\u00e9trica de precisi\u00f3n para el dataset de test: {}%\".format(100*cnf_matrix[0,0]\/(cnf_matrix[0,0]+cnf_matrix[1,0])))\n# Plot non-normalized confusion matrix\nclass_names = [0,1]\nplt.figure()\nplot_confusion_matrix(cnf_matrix , classes=class_names, title='matriz de confusi\u00f3n')\nplt.show()","b4e5acec":"tmp = lr1.fit(X_train_res, y_train_res.ravel())","68347803":"y_pred_sample_score = tmp.decision_function(X_test)\n\n\nfpr, tpr, thresholds = roc_curve(y_test, y_pred_sample_score)\n\nroc_auc = auc(fpr,tpr)\n\n# Plot ROC\nplt.title('ROC Receiver Operating Characteristic')\nplt.plot(fpr, tpr, 'b',label='AUC = %0.3f'% roc_auc)\nplt.legend(loc='lower right')\nplt.plot([0,1],[0,1],'r--')\nplt.xlim([-0.1,1.0])\nplt.ylim([-0.1,1.01])\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')\nplt.show()","b10c7607":"Normalizamos el atributo 'Amount'"}}