{"cell_type":{"de9ac887":"code","bc699753":"code","495310cc":"code","b924d836":"code","ff134d36":"code","aaaf1856":"code","e5db3edb":"code","0de27a81":"code","35d324fc":"code","96822d05":"code","d2005aa7":"markdown","4d597ef1":"markdown","04f99e83":"markdown","6d2ea3eb":"markdown","f7e095e1":"markdown","40642126":"markdown","977aff83":"markdown","a802229e":"markdown","6b192f53":"markdown","a5d4e919":"markdown","101a4c81":"markdown","35ccd61e":"markdown","83e9d0ca":"markdown","14ea7fbc":"markdown","5e585de2":"markdown","612b14b8":"markdown"},"source":{"de9ac887":"\n\ngame_grid = [\n    [\"l\", \"v\", \"l\", \" \", \" \"],\n    [\"l\", \"a\", \"v\", \" \", \" \"],\n    [\"v\", \"v\", \"a\", \" \", \" \"],\n    [\"a\", \"a\", \"l\", \" \", \" \"]\n]\n\ngame_grid = [\n    [\"azul\", \"lara\", \"verm\", \"rosa\", \"lara\", \"\", \"\"],\n    [\"verd\", \"rosa\", \"azul\", \"verd\", \"verm\", \"\", \"\"],\n    [\"lara\", \"rosa\", \"verm\", \"verm\", \"verd\", \"\", \"\"],\n    [\"verd\", \"lara\", \"rosa\", \"azul\", \"azul\", \"\", \"\"]\n]\n\ngame_grid = [\n    [\"marr\", \"rosa\", \"cinz\", \"azuE\", \"lara\", \"amar\", \"azuE\", \"rosa\", \"verd\", \"roxo\", \"verE\", \"amar\", \"\", \"\"],\n    [\"cinz\", \"verd\", \"verd\", \"verm\", \"amar\", \"verC\", \"verC\", \"roxo\", \"verC\", \"cinz\", \"roxo\", \"verm\", \"\", \"\"],\n    [\"lara\", \"azul\", \"lara\", \"marr\", \"azuE\", \"lara\", \"verC\", \"verE\", \"verE\", \"marr\", \"cinz\", \"verm\", \"\", \"\"],\n    [\"marr\", \"roxo\", \"verm\", \"rosa\", \"verE\", \"azuE\", \"azul\", \"verd\", \"amar\", \"azul\", \"azul\", \"rosa\", \"\", \"\"]\n]","bc699753":"def transpose(arr):\n    return [[arr[j][i] for j in range(len(arr))] for i in range(len(arr[0]))]\n\ngame_grid = transpose(game_grid)","495310cc":"def is_grid_valid(grid):\n    def test_tubes_have_length_four(g):\n        return all([len(test_tube) == 4 for test_tube in g])\n    \n    def have_four_each_color(g):\n        concat_g = []\n        for test_tube in g:\n            concat_g += test_tube\n            \n        colors = [ball.strip() if ball != None else \"\" for ball in concat_g]\n        valid_colors = []\n        for color in set(colors):\n            if bool(color):\n                if colors.count(color) != 4:\n                    print(color, colors.count(color))\n                valid_colors.append(colors.count(color) == 4)\n        \n        return all(valid_colors)\n    \n    def have_correct_distinct_colors(g):\n        concat_g = []\n        for test_tube in g:\n            concat_g += test_tube\n        \n        valid_colors = [ball for ball in set(concat_g) if ball != None]\n        \n        return sum([bool(ball.strip()) for ball in valid_colors]) < len(g)\n            \n    return all([test_tubes_have_length_four(grid),\n                have_four_each_color(grid),\n                have_correct_distinct_colors(grid)])\n\nis_grid_valid(game_grid)","b924d836":"def print_grid(grid, move = None, first_line_test_tubes=0):\n    biggest_word = max([max([len(ball) if ball != None else 0 for ball in line]) for line in grid])\n    space_char = \" \"\n    blank_char = \"\"\n    grid_bottom = \"\u203e\"\n    left_move_char = \"<\"\n    right_move_char = \">\"\n    \n    test_tube_width = biggest_word + 6\n    \n    grid_rows = []\n    \n    if first_line_test_tubes:\n        grid_rows.append(grid[:first_line_test_tubes])\n        grid_rows.append(grid[first_line_test_tubes:])\n    else:\n        grid_rows.append(grid)\n        \n    for grid_row_idx, grid_row in enumerate(grid_rows):\n        #Print the top of the test tube\n        for test_tube in range(len(grid_row)):\n            print(f\" __{space_char.center(biggest_word)}__ \", end=\"\")\n        print()\n\n        #Print the rows\n        for row_index in range(len(grid_row[0])):\n            for test_tube in grid_row:\n                ball = test_tube[row_index]\n                ball_char = ball if ball else \" \"\n                print(\"  |\" + f\"{ball_char.center(biggest_word)}\" + \"|  \", end=\"\")\n            print()\n\n        #Print the bottom\n        for test_tube in range(len(grid_row)):\n            print(f\"   {blank_char.center(biggest_word, grid_bottom)}   \", end=\"\")\n        print()\n\n        #Numbers the test tubes\n        for test_tube_idx in range(len(grid_row)):\n            test_tube_num = first_line_test_tubes * grid_row_idx + test_tube_idx + 1\n            print(f\"   {str(test_tube_num).center(biggest_word)}   \", end=\"\")\n        print()\n\n        #Print the move\n        if (move != None and ball != None) and (move[0] != move[1]):\n            min_move, max_move = min(move), max(move)\n\n            fill_char = right_move_char if move[0] < move[1] else left_move_char\n            \n            for test_tube_idx in range(len(grid_row)):\n                test_tube_num = first_line_test_tubes * grid_row_idx + test_tube_idx\n    \n                #The start of the move\n                if min_move == test_tube_num:\n                    print(space_char * (test_tube_width - (test_tube_width \/\/ 2)), end=\"\")\n                    print(fill_char * (test_tube_width \/\/ 2), end=\"\")\n                #The end of the move\n                elif max_move == test_tube_num:\n                    print(fill_char * (test_tube_width \/\/ 2), end=\"\")\n                    print(space_char * (test_tube_width - (test_tube_width \/\/ 2)), end=\"\")\n                #Empty spaces befores the first move\n                elif min_move > test_tube_num:\n                    print(space_char * test_tube_width, end=\"\")\n                #Fill char\n                elif max_move >= test_tube_num and min_move <= test_tube_num:\n                    print(fill_char * test_tube_width, end=\"\")\n\n        print()\n        \n    if (move != None and ball != None) and (move[0] != move[1]):\n        print(f\"Move: {move[0] + 1} to: {move[1] + 1}\".center(max([len(row) for row in grid_rows]) * test_tube_width))\n                \n    print(grid_bottom * max([len(row) for row in grid_rows]) * test_tube_width)\n#Test the print\nprint_grid(game_grid, [1, 12], first_line_test_tubes=7)","ff134d36":"def clean_grid(grid):\n    return [[None if ball in [\"\", \" \"] else ball for ball in line] for line in grid]","aaaf1856":"def make_move(grid, move_from, move_to):\n    if move_from == move_to:\n        return None\n    \n    def get_last_ball(test_tube):\n        for idx,ball in enumerate(test_tube):\n            if ball:\n                return idx,ball\n        return None, None\n            \n    def get_empty_slot(test_tube):\n        for idx in range(len(test_tube) - 1, -1, -1):\n            if test_tube[idx] == None:\n                return idx\n        return None\n    \n    def is_move_redudant(test_tube_from, test_tube_to, from_ball):\n        colors_test_tube_from = [i for i in test_tube_from if i != None]\n        colors_test_tube_to = [i for i in test_tube_to if i != None]\n        \n        #If both test tubes have one color\n        if len(set(colors_test_tube_from)) == 1 and len(set(colors_test_tube_to)) == 1:\n            #Is redudant if the moved test tube have more balls than the to test tube\n            if len(colors_test_tube_from) > len(colors_test_tube_to):\n                return True\n            return False\n        \n        #If the from test tube is have one color\n        elif len(set(colors_test_tube_from)) == 1:\n            #Is redudant if the to test tube is empty\n            if not all(test_tube_to):\n                return True\n            return False\n        return False\n            \n    \n    #Check if the test tube index is valid, then copy\n    try:\n        from_test_tube = grid[move_from].copy()\n        to_test_tube = grid[move_to].copy()\n    except:\n        return None\n    \n    from_idx, from_ball = get_last_ball(from_test_tube)\n    if not is_move_redudant(from_test_tube, to_test_tube, from_ball):    \n        _, to_ball = get_last_ball(to_test_tube)\n        empty_slot = get_empty_slot(to_test_tube)\n\n        if from_ball and empty_slot != None and (from_ball == to_ball or to_ball == None):\n            from_test_tube[from_idx] = None\n            to_test_tube[empty_slot] = from_ball\n        else:\n            return None\n\n        new_grid = grid[:]\n        new_grid[move_from], new_grid[move_to] = from_test_tube, to_test_tube\n\n        return new_grid\n    return None","e5db3edb":"def check_victory(grid):\n    return all([len(set(test_tube)) == 1 for test_tube in grid])","0de27a81":"def solve_grid(grid, min_moves=False):\n    grid_history = [clean_grid(grid)]\n    moves = []\n    \n    all_grid_states = []\n    total_trys = 0\n        \n    def iter_over_grid(level = 0):\n        nonlocal grid_history\n        nonlocal moves\n        \n        nonlocal all_grid_states\n        nonlocal total_trys\n        \n        for test_tube_from_idx in range(len(grid_history[level])):\n            for test_tube_to_idx in range(len(grid_history[level])):\n                if check_victory(grid_history[-1]):\n                    return\n                \n                grid_history = grid_history[:level + 1]\n                moves = moves[:level + 1]\n                \n                grid_move = make_move(grid_history[level], test_tube_from_idx, test_tube_to_idx)\n\n                if grid_move and grid_move not in all_grid_states:\n                    #Resets the grid_state everything the first level changes\n                    if level == 0:\n                        all_grid_states = []\n                        \n                    moves.append([test_tube_from_idx, test_tube_to_idx])\n                    grid_history.append(grid_move)\n                    all_grid_states.append(grid_move)\n                    iter_over_grid(level + 1)\n        return\n    \n    iter_over_grid()\n                \n    return grid_history, moves","35d324fc":"%%time\ngrid_history, moves = solve_grid(game_grid)","96822d05":"for idx_grid, grid_h in enumerate(grid_history):\n    if idx_grid < len(moves) - 1:\n        print(\"Move number \", idx_grid + 1, moves[idx_grid + 1])\n        print_grid(grid_h, moves[idx_grid + 1], first_line_test_tubes=7)\n    else:\n        print_grid(grid_h, first_line_test_tubes=7)","d2005aa7":"### The function","4d597ef1":"### Printing the result","04f99e83":"### Grid print function\nIt takes:\n* The grid\n* The move as [idx_from, idx_to] (optional)\n* The number of test tubes on the first row (optional)","6d2ea3eb":"### Validating the grid\nThe grid needs to be valid to run the algorithm. A valid grid have:\n* The number of balls with the same color is 4\n* The length of the test tube is aways 4\n* The number of diferent colors must be less than the number of test tubes - 1","f7e095e1":"# Next Steps\nAlthought it's a litle slow, the algorith runs fine. The next steps can be:\n   * Improve execution time\n   * Find others redudant moves\n   * Build a html versions using JS with a user interface.","40642126":"# The Project\nFor the project I want to use pure python\n","977aff83":"## The Objective\nThe main objective of the project is to automatize the game to get a solution to the puzzle.\n* It will be capable to print the grid.\n* It will show all moves to the solution.\n* Optionally it will print the grid in every move","a802229e":"## Function\nFor the solve algorithm it will check for two states on the grid:\n* If a move is possible\n* If the grid is solved\n\nThe make_move, only makes a move if:\n* The move is possible\n* The move is not redundant\n    * If the move is from a test tube with only one color to a empty or less single color test tube\n    * If the move is from a single ball test tube to a empty test tube\n* Before making a move, try to see the best move for the ball","6b192f53":"## Setting the grid\nThe grid can be setted by a 2 dimensional array, Nones, empty string or spaces can be used for empty spaces on a test tube\nThe following are test grids.","a5d4e919":"## The main recursion loop\nThe algorithm will be based on a recursion loop, where it scans the grid for possible moves, makes that move and them call it self.","101a4c81":"## Cleaning empty strings\nAll the empty strings, representing missing balls must be replaced with None","35ccd61e":"# The algorithm\n","83e9d0ca":"### Excuting the function with a test grid","14ea7fbc":"# Ball Sort puzzle Solver\nMy girlfriend sometimes get really adicted to some bad games, to the point to spend weeks with the same bad game.\nHere I'm gonna try to make a solver to her last game, [the ball sort puzzle](https:\/\/play.google.com\/store\/apps\/details?id=com.GMA.Ball.Sort.Puzzle&hl=pt_BR&gl=US). Here follow the rules:\n* In the game we have some tubes filled with balls of diferent colors.\n* As dificult rizes, the number of test tubes and number of colors is increased.\n* Each test tube aways have four colors (Have to confirm that).\n* The number of colors is aways equals to (test tubes - 1), by that the total number of balls is (test tubes - 1) * 4.\n* The grid of test tubes aways start with one of the test tubes filled and others full of balls of random colors\n* The objective of the game is to sort the balls by their colors.\n* One ball can be moved from one test tube to another by this conditions:\n    * The test tube must have at least one space available\n    * The last ball of the reciever test tube must have the same color as the ball being moved\n    * Empty test tube can recieve any ball.\n\n","5e585de2":"### Transpose function\nFor better management of the grid during the algorithm we make a tranpose function.","612b14b8":"### Checking for victory\nThe following function checks if the grid is a victorious grid"}}