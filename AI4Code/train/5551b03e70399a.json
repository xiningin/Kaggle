{"cell_type":{"9c1c203e":"code","afa3efe7":"code","293cc8bb":"code","8a874bfa":"code","7d7e7431":"code","3e798c6e":"code","169e5416":"code","e69d1ac5":"code","927b7dae":"code","fcbe80aa":"code","6c6b0162":"code","466d6881":"code","2e948e14":"code","87c12002":"code","d362c805":"code","0c597927":"code","5e4306af":"code","52bd8492":"code","01c05869":"markdown"},"source":{"9c1c203e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\ndata_history = [] #do not refresh this unless you want to delete the history pf parameters\n\n# Any results you write to the current directory are saved as output.","afa3efe7":"epochs_custom = 2","293cc8bb":"import numpy\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pandas import read_csv\nimport math\nfrom tensorflow import keras\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom tensorflow.keras.layers import LSTM\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error","8a874bfa":"# convert an array of values into a dataset matrix\ndef create_dataset(dataset, look_back=1):\n\tdataX, dataY = [], []\n\tfor i in range(len(dataset)-look_back-1):\n\t\ta = dataset[i:(i+look_back), 0]\n\t\tdataX.append(a)\n\t\tdataY.append(dataset[i + look_back, 0])\n\treturn numpy.array(dataX), numpy.array(dataY)","7d7e7431":"# fix random seed for reproducibility\nnumpy.random.seed(7)\n# load the dataset\ndataframe = read_csv(\"..\/input\/1_MIN_ALL.txt\", index_col=0, sep = ' ')\ndataframe['Vol'] = dataframe['Vol'].str.replace(\"'\", '')\ndataframe = dataframe.tail(50000)\ndataframe.head()","3e798c6e":"dataframe = dataframe[['Close']]\ndataframe = dataframe.reset_index(drop = True)\ndataset = dataframe.values\ndataset = dataset.astype('float32')","169e5416":"# normalize the dataset\nscaler = MinMaxScaler(feature_range=(0, 1))\ndataset = scaler.fit_transform(dataset)\n# split into train and test sets\ntrain_size = int(len(dataset) * 0.67)\ntest_size = len(dataset) - train_size\ntrain, test = dataset[0:train_size,:], dataset[train_size:len(dataset),:]","e69d1ac5":"# reshape into X=t and Y=t+1\nlook_back = 1\ntrainX, trainY = create_dataset(train, look_back)\ntestX, testY = create_dataset(test, look_back)\n\n# reshape input to be [samples, time steps, features]\ntrainX = numpy.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))\ntestX = numpy.reshape(testX, (testX.shape[0], 1, testX.shape[1]))","927b7dae":"# create and fit the LSTM network\nmodel = Sequential()\nmodel.add(LSTM(4, input_shape=(1, look_back)))\nmodel.add(Dense(1))\nmodel.compile(loss='mean_squared_error', optimizer='adam')\nmodel.fit(trainX, trainY, epochs=epochs_custom, batch_size=1, verbose=2)","fcbe80aa":"# make predictions\ntrainPredict = model.predict(trainX)\ntestPredict = model.predict(testX)","6c6b0162":"# invert predictions\ntrainPredict = scaler.inverse_transform(trainPredict)\ntrainY = scaler.inverse_transform([trainY])\ntestPredict = scaler.inverse_transform(testPredict)\ntestY = scaler.inverse_transform([testY])","466d6881":"\n# calculate root mean squared error\ntrainScore = math.sqrt(mean_squared_error(1000*(trainY[0]), 1000*trainPredict[:,0]))\nprint('Train Score: %.2f RMSE' % (trainScore))\ntestScore = math.sqrt(mean_squared_error(1000*testY[0], 1000*testPredict[:,0]))\nprint('Test Score: %.2f RMSE' % (testScore))","2e948e14":"\n# shift train predictions for plotting\ntrainPredictPlot = numpy.empty_like(dataset)\ntrainPredictPlot[:, :] = numpy.nan\ntrainPredictPlot[look_back:len(trainPredict)+look_back, :] = trainPredict\n# shift test predictions for plotting\ntestPredictPlot = numpy.empty_like(dataset)\ntestPredictPlot[:, :] = numpy.nan\ntestPredictPlot[len(trainPredict)+(look_back*2)+1:len(dataset)-1, :] = testPredict\n# plot baseline and predicZtions\nplt.plot(scaler.inverse_transform(dataset))\nplt.plot(trainPredictPlot)\nplt.plot(testPredictPlot)\nplt.show()","87c12002":"print(model.summary())","d362c805":"Predictions = []\nReal = []\nresult = []\nerror= []\n\nfor i in range(0,len(testPredict)):\n    if scaler.inverse_transform(testX[i])[0][look_back - 1] - testPredict[i] < 0:\n        Predictions.append('Sell')\n    else:\n        Predictions.append('Buy')\n    \n    if scaler.inverse_transform(testX[i])[0][look_back - 1] - testY[0][i] < 0:\n        Real.append('Sell')\n    else:\n        Real.append('Buy')\n    \n    if Predictions[i] == Real[i]:\n        result.append(True)\n    else:\n        result.append(False)\n    \n    error.append(math.sqrt((scaler.inverse_transform(testX[i])[0][look_back - 1] - testPredict[i])*\n            (scaler.inverse_transform(testX[i])[0][look_back - 1] - testPredict[i])))","0c597927":"freq = pd.DataFrame({'col':result})\nfreq.describe()","5e4306af":"mse = pd.DataFrame({'col':error})\nmse.describe()","52bd8492":"accuracy = freq.describe()['col'][3]\/freq.describe()['col'][0]\ndata_history.append([accuracy,epochs_custom,look_back,testScore,trainScore,mse.describe()['col'][3]])\ndf = pd.DataFrame(data_history,columns=['accuracy','epochs','look_back','trainScore','testScore','mse'])\ndf","01c05869":" <h1 style=\"color: blue;\"> Evaluating the model in action <\/h1>\n \nWe create two lists, <strong>Predictions <\/strong> and<strong> Real <\/strong>, Real<\/strong> contains <strong>Sell<\/strong> if we should have gone short on the postion and<strong> Buy<\/strong> if we should have gone Long, same for the list<strong> Real<\/strong> but with our predictions.\n\nThe dataframe <strong>result<\/strong> contains binaries, <strong>True<\/strong> if we predict the same as what we should have done and <strong>False<\/[](http:\/\/)strong> if we missed.\n\nFinally <strong> accuracy <\/strong> tells us the ratio of good predictions over all predictions. "}}