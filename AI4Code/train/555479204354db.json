{"cell_type":{"fb6540a5":"code","90b234aa":"code","da68dd28":"code","a52003dd":"code","998e8b7c":"code","c40b4e2c":"code","8c18d27f":"code","402afc7f":"code","cde1ca51":"code","a336ba19":"code","befdc6b0":"code","d0137d09":"code","36974257":"markdown","472311e8":"markdown"},"source":{"fb6540a5":"!pip install -U torch\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport os\nfrom glob import glob\nimport json\nfrom kaggle_environments import make\nfrom kaggle_environments.envs.halite.helpers import *\nfrom tqdm.notebook import tqdm\nimport random\nimport torch\nimport torch.nn as nn\nprint(torch.__version__)","90b234aa":"infos = sorted(glob(r\"\/kaggle\/input\/halite-top-games-2\/*\/*_info.json\"))\ngames = []\nfor info in infos:\n    log = json.load(open(info, 'r'))\n    for agent in log['agents']:\n        if agent['submissionId'] == 16647790:\n            games.append(info[:-10] + info[-5:])\n            break\ngames[:10]","da68dd28":"def get_pos(s):\n    return (s \/\/ 21, s % 21)\nprint(get_pos(22))\n\ndef dry_move(pos, d):\n    if type(pos) is int:\n        pos = get_pos(pos)\n    if d == \"NORTH\":\n        pos = ((pos[0] - 1) % 21, pos[1] % 21)\n    elif d == \"SOUTH\":\n        pos = ((pos[0] + 1) % 21, pos[1] % 21)\n    elif d == \"EAST\":\n        pos = (pos[0] % 21, (pos[1] + 1) % 21)\n    elif d == \"WEST\":\n        pos = (pos[0] % 21, (pos[1] - 1) % 21)\n    return pos\nprint(dry_move(22, \"NORTH\"))","a52003dd":"# clear directory\nimport shutil\nif os.path.isdir(\".\/data\"):\n    shutil.rmtree(\".\/data\")\nos.mkdir(\".\/data\")\n\ndata = []\n# preprocess input & output\nfor game in tqdm(games):\n    log = json.load(open(game, 'r'))\n    info = json.load(open(game[:-5] + \"_info.json\", 'r'))\n    \n    # if more than one mzotkiew, continue\n    if np.sum([x['submissionId'] == 16647790 for x in info['agents']]) > 1:\n        continue\n    \n    playerId = np.argmax([x['submissionId'] == 16647790 for x in info['agents']])\n    for steplog in log['steps']:\n        if steplog[playerId]['action'] is None:\n            continue\n        # retrieve data\n        obs = steplog[0]['observation']\n        bank = obs['players'][playerId][0]\n        shipCnt = len(obs['players'][playerId][2])\n        totalShipCnt = 0\n        for player in obs['players']:\n            totalShipCnt += len(player[2])\n        step = obs['step']\n        haliteMean = sum(obs['halite']) \/ len(obs['halite'])\n        \n        # isBlocked\n        if len(obs['players'][playerId][1]) != 1: # workaround\n            continue\n        if step >= len(log['steps']) - 1:\n            continue\n        \n        shipyardPos = get_pos(list(obs['players'][playerId][1].values())[0])\n        isBlocked = 0\n        actions = log['steps'][step + 1][playerId]['action'] # future action\n        for k, v in obs['players'][playerId][2].items(): # all ships\n            nextPos = dry_move(v[0], actions[k]) if k in actions else get_pos(v[0])\n            if nextPos == shipyardPos:\n                isBlocked = 1\n                \n        # label\n        label = \"SPAWN\" in log['steps'][step + 1][playerId]['action'].values()\n        \n        # save data to memory\n        data.append(torch.tensor([bank, totalShipCnt, shipCnt, step, haliteMean, isBlocked, label]))\n\ndata = torch.stack(data)\nprint(data[:, 5].sum())","998e8b7c":"model = nn.Sequential(\n    nn.Linear(6, 4),\n    nn.ReLU(),\n    nn.Linear(4, 4),\n    nn.ReLU(),\n    nn.Linear(4, 1),\n)","c40b4e2c":"def test(testSet, verbose=False):\n    testLoader = torch.utils.data.DataLoader(testSet, batch_size=32)\n    tp, tn, fp, fn = 0, 0, 0, 0\n    for x, label in testLoader:\n        y = model(x).squeeze()\n        tp += torch.sum(np.logical_and(y > 0, label == 1)).item()\n        tn += torch.sum(np.logical_and(y < 0, label == 0)).item()\n        fp += torch.sum(np.logical_and(y > 0, label == 0)).item()\n        fn += torch.sum(np.logical_and(y < 0, label == 1)).item()\n    tp \/= len(testSet)\n    tn \/= len(testSet)\n    fp \/= len(testSet)\n    fn \/= len(testSet)\n    if verbose:\n        print(tp, fp, tn, fn)\n    return (tp + tn) \/ (tp + tn + fp + fn)","8c18d27f":"# get mean, std\nX, Y = data[:, :6], data[:, 6]\nX = (X - X.mean(0)) \/ X.std(0)\nprint(X.shape, Y.shape)","402afc7f":"trainSet, testSet = torch.utils.data.random_split(torch.utils.data.TensorDataset(X, Y), [len(X) - len(X) \/\/ 5, len(X) \/\/ 5])","cde1ca51":"trainLoader = torch.utils.data.DataLoader(trainSet, batch_size=32)\nlossFn = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([5]))\noptimizer = torch.optim.RMSprop(model.parameters(), lr=0.0001) # I trained many times with decreasing lr\n    \n# train\nepochs = 100\nfor epoch in tqdm(range(epochs)):\n    runningLoss = 0.\n    for x, label in trainLoader:\n        y = model(x).squeeze()\n        loss = lossFn(y, label)\n        loss.backward()\n        optimizer.step()\n        optimizer.zero_grad()\n        \n        runningLoss += loss.item()\n    if epoch % (epochs \/\/ 10) == 0:\n        print(f\"epoch{epoch + 1}\/{epochs}, loss={runningLoss}, train_acc={test(trainSet)}, test_acc={test(testSet)}\")","a336ba19":"test(testSet, True)","befdc6b0":"sns.scatterplot(x=range(100), y=model(testSet[:100][0]).detach().numpy().squeeze())","d0137d09":"for param in model.parameters():\n    print(param.detach().numpy())","36974257":"# Prepare data from mzotkiew","472311e8":"# Train"}}