{"cell_type":{"5b85bfb2":"code","8f647f08":"code","8bef6c89":"code","ca119685":"code","ac9c9640":"code","494b58a2":"code","e7c4f659":"code","a1cabcb4":"code","8db94006":"code","2bb7e142":"code","72c0ee8b":"code","d4abb0fb":"code","3f1c6e8c":"code","484cf8e2":"code","ce9db793":"code","80a9f311":"code","519e448a":"code","a8bf435f":"code","08604728":"code","f0e2064f":"code","5c9a3bd0":"code","b864798b":"code","94181750":"code","6d74cae1":"code","78e31e5f":"code","4b15e6e3":"code","631c48cc":"code","9a0b80f1":"code","411caaab":"code","cefaa4f8":"code","53575a2d":"code","9f42d005":"code","b1f05266":"code","0a0a4c0e":"code","354fd8ca":"code","182786de":"code","e84ccf91":"code","1ed8f8f6":"code","2ebc88b6":"code","2334b093":"code","7e4fceb2":"code","39df4825":"code","8559e8e9":"code","b1e6ca50":"code","f708bcd9":"code","2e2cb3dd":"code","b20d8ce4":"code","44043cd3":"code","795e1286":"code","3c68880d":"code","1f6efc68":"code","a839dd56":"code","8559008c":"code","afc70cd8":"code","785ad5b0":"code","b65943cc":"code","5717b748":"code","95ef5804":"code","9afc461c":"code","e67afa93":"code","6dd137a3":"code","c11c0984":"code","847e4ca2":"code","c9c3d7de":"code","1dc49421":"code","a77b37d0":"code","863ede28":"code","84bd0ebe":"code","d07e5df7":"code","2835bafd":"code","a4e51f53":"code","3e8b1586":"code","a301d3f6":"code","5a9b22f1":"code","316f2824":"code","6227ecf9":"code","83de7ff1":"code","f0fbdb52":"code","b0b532c7":"code","7d21e915":"code","78250512":"code","cda88261":"code","68236f3b":"code","893affde":"code","bc292867":"code","6372f117":"code","ea9cc4a9":"code","99a636b3":"code","672bd791":"code","fadae386":"code","c8427419":"code","f377f4ed":"code","c748d61d":"markdown","f63984e0":"markdown","b0888aa4":"markdown","49c9a2ec":"markdown","56f9db61":"markdown","22ed87f2":"markdown","ff5eb8c7":"markdown","c854ca02":"markdown","010fc2c1":"markdown","7e009692":"markdown","b60e7b61":"markdown","a8214a65":"markdown","4f3a00b8":"markdown","b9861b6e":"markdown","e0144077":"markdown","8ffb69c2":"markdown","7dfe1e2b":"markdown","d9aec59c":"markdown","8ea4a690":"markdown","dbe5f5f7":"markdown","511475c1":"markdown","be995ea8":"markdown","d171dffb":"markdown","a3d7f518":"markdown","d19d7f01":"markdown","a1063bab":"markdown","17fa1f6e":"markdown","0e986676":"markdown","75a04eab":"markdown","f0ec86ed":"markdown","1af108d1":"markdown","9acd2e12":"markdown","3a89636b":"markdown","981f7f9f":"markdown","ce9a3cb3":"markdown","3786b699":"markdown","f6656166":"markdown","2fa3179a":"markdown","710a4bfc":"markdown","e017c318":"markdown","6c2cdb2c":"markdown","cc883ac1":"markdown","9557d7e3":"markdown","4e54128c":"markdown","6df7faad":"markdown","4b039300":"markdown","0728d071":"markdown","5a563fde":"markdown","17949433":"markdown","4a3ccdf0":"markdown","22671f3f":"markdown","88b4e8ed":"markdown","e6c7614b":"markdown","f7e06fae":"markdown","f006d2ee":"markdown","c817b020":"markdown","c9cc98a5":"markdown","6f6494c3":"markdown","4031bf7a":"markdown","44c0d1ba":"markdown","b9e415ca":"markdown","ab1c71be":"markdown","7a4a54f0":"markdown","ee715445":"markdown","03bf848c":"markdown","d50186ac":"markdown","fde17995":"markdown","ef2f51c1":"markdown","2ba8143d":"markdown","e28119f8":"markdown","22bb1511":"markdown","21caeef8":"markdown","7ee704e1":"markdown","a867eca2":"markdown","0d6b3b0d":"markdown","53c6165a":"markdown","607fbdc9":"markdown","8256a682":"markdown","dab12907":"markdown","27f48c71":"markdown","9d8abbe0":"markdown","7ed2f55f":"markdown","64d4645b":"markdown","c2c3b005":"markdown","43352480":"markdown","7febf4cd":"markdown","fe478af6":"markdown","9e09d1da":"markdown","aa162248":"markdown","26171b27":"markdown","7fd1d593":"markdown","4ffe4d02":"markdown","2eee0deb":"markdown","25e94084":"markdown","436d9251":"markdown","37b15320":"markdown","d090efa5":"markdown"},"source":{"5b85bfb2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8f647f08":"from IPython.display import HTML\nHTML(\"\"\"<iframe width=\"560\" height=\"315\" src=\"https:\/\/www.youtube.com\/embed\/pPN8d0E3900\" frameborder=\"0\" allowfullscreen><\/iframe>\"\"\")","8bef6c89":"HTML(\"\"\"<iframe width=\"560\" height=\"315\" src=\"https:\/\/www.youtube.com\/embed\/2Kawrd5szHE\" frameborder=\"0\" allowfullscreen><\/iframe>\"\"\")","ca119685":"from __future__ import division, print_function, unicode_literals","ac9c9640":"%matplotlib inline\nimport matplotlib\nimport matplotlib.pyplot as plt","494b58a2":"import tensorflow as tf\nprint(tf.__version__)","e7c4f659":"#tf.reset_default_graph()\nfrom tensorflow.python.framework import ops\nops.reset_default_graph()","a1cabcb4":"np.random.seed(42)\n#tf.set_random_seed(42)\ntf.random.set_seed(45)","8db94006":"#from tensorflow.examples.tutorials.mnist import input_data\n#mnist = input_data.read_data_sets(\"\/tmp\/data\/\")","2bb7e142":"from tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.utils import to_categorical\n# mnist = mnist.load_data()\n(X_train, Y_train), (X_test, Y_test) = mnist.load_data()\nX_train = X_train.reshape(-1, 28, 28, 1).astype('float32') \/ 255.\nX_test = X_test.reshape(-1, 28, 28, 1).astype('float32') \/ 255.\n#Y_train = to_categorical(Y_train.astype('float32'))\n#Y_test = to_categorical(Y_test.astype('float32'))","72c0ee8b":"X_train.shape","d4abb0fb":"n_samples = 5\n\nplt.figure(figsize=(n_samples * 2, 3))\nfor index in range(n_samples):\n    plt.subplot(1, n_samples, index + 1)\n    sample_image = X_train[index].reshape(28, 28)\n    plt.imshow(sample_image, cmap=\"binary\")\n    plt.axis(\"off\")\n\nplt.show()","3f1c6e8c":"Y_train[:n_samples]","484cf8e2":"#X = tf.placeholder(shape=[None, 28, 28, 1], dtype=tf.float32, name=\"X\") # original not working\ntf.compat.v1.disable_eager_execution()\nX = tf.compat.v1.placeholder(shape=[None, 28, 28, 1], dtype=tf.float32, name=\"X\")","ce9db793":"caps1_n_maps = 32\ncaps1_n_caps = caps1_n_maps * 6 * 6  # 1152 primary capsules\ncaps1_n_dims = 8","80a9f311":"conv1_params = {\n    \"filters\": 256,\n    \"kernel_size\": 9,\n    \"strides\": 1,\n    \"padding\": \"valid\",\n    \"activation\": tf.nn.relu,\n}\n\nconv2_params = {\n    \"filters\": caps1_n_maps * caps1_n_dims, # 256 convolutional filters\n    \"kernel_size\": 9,\n    \"strides\": 2,\n    \"padding\": \"valid\",\n    \"activation\": tf.nn.relu\n}","519e448a":"conv1 = tf.compat.v1.layers.conv2d(X, name=\"conv1\", **conv1_params)\nconv2 = tf.compat.v1.layers.conv2d(conv1, name=\"conv2\", **conv2_params)","a8bf435f":"caps1_raw = tf.reshape(conv2, [-1, caps1_n_caps, caps1_n_dims],\n                       name=\"caps1_raw\")","08604728":"def squash(s, axis=-1, epsilon=1e-7, name=None):\n    #with tf.name_scope(name, default_name=\"squash\"):\n    with tf.name_scope(name):\n        #squared_norm = tf.reduce_sum(tf.square(s), axis=axis,\n        #                             keep_dims=True)\n        squared_norm = tf.reduce_sum(tf.square(s), axis=axis,\n                                     keepdims=True)\n        safe_norm = tf.sqrt(squared_norm + epsilon)\n        squash_factor = squared_norm \/ (1. + squared_norm)\n        unit_vector = s \/ safe_norm\n        return squash_factor * unit_vector","f0e2064f":"caps1_output = squash(caps1_raw, name=\"caps1_output\")","5c9a3bd0":"caps2_n_caps = 10\ncaps2_n_dims = 16","b864798b":"init_sigma = 0.1\n\n#W_init = tf.random_normal(\nW_init = tf.random.normal(\n    shape=(1, caps1_n_caps, caps2_n_caps, caps2_n_dims, caps1_n_dims),\n    stddev=init_sigma, dtype=tf.float32, name=\"W_init\")\nW = tf.Variable(W_init, name=\"W\")","94181750":"batch_size = tf.shape(X)[0]\nW_tiled = tf.tile(W, [batch_size, 1, 1, 1, 1], name=\"W_tiled\")","6d74cae1":"caps1_output_expanded = tf.expand_dims(caps1_output, -1,\n                                       name=\"caps1_output_expanded\")\ncaps1_output_tile = tf.expand_dims(caps1_output_expanded, 2,\n                                   name=\"caps1_output_tile\")\ncaps1_output_tiled = tf.tile(caps1_output_tile, [1, 1, caps2_n_caps, 1, 1],\n                             name=\"caps1_output_tiled\")","78e31e5f":"W_tiled","4b15e6e3":"caps2_predicted = tf.matmul(W_tiled, caps1_output_tiled,\n                            name=\"caps2_predicted\")","631c48cc":"caps2_predicted","9a0b80f1":"raw_weights = tf.zeros([batch_size, caps1_n_caps, caps2_n_caps, 1, 1],\n                       dtype=np.float32, name=\"raw_weights\")","411caaab":"routing_weights = tf.nn.softmax(raw_weights, name=\"routing_weights\")","cefaa4f8":"weighted_predictions = tf.multiply(routing_weights, caps2_predicted,\n                                   name=\"weighted_predictions\")\nweighted_sum = tf.reduce_sum(weighted_predictions, axis=1, keepdims=True,\n                             name=\"weighted_sum\")","53575a2d":"caps2_output_round_1 = squash(weighted_sum, axis=-2,\n                              name=\"caps2_output_round_1\")","9f42d005":"caps2_output_round_1","b1f05266":"caps2_predicted","0a0a4c0e":"caps2_output_round_1","354fd8ca":"caps2_output_round_1_tiled = tf.tile(\n    caps2_output_round_1, [1, caps1_n_caps, 1, 1, 1],\n    name=\"caps2_output_round_1_tiled\")","182786de":"agreement = tf.matmul(caps2_predicted, caps2_output_round_1_tiled,\n                      transpose_a=True, name=\"agreement\")","e84ccf91":"raw_weights_round_2 = tf.add(raw_weights, agreement,\n                             name=\"raw_weights_round_2\")","1ed8f8f6":"routing_weights_round_2 = tf.nn.softmax(raw_weights_round_2,\n                                        name=\"routing_weights_round_2\")\nweighted_predictions_round_2 = tf.multiply(routing_weights_round_2,\n                                           caps2_predicted,\n                                           name=\"weighted_predictions_round_2\")\nweighted_sum_round_2 = tf.reduce_sum(weighted_predictions_round_2,\n                                     axis=1, keepdims=True,\n                                     name=\"weighted_sum_round_2\")\ncaps2_output_round_2 = squash(weighted_sum_round_2,\n                              axis=-2,\n                              name=\"caps2_output_round_2\")","2ebc88b6":"caps2_output = caps2_output_round_2","2334b093":"def condition(input, counter):\n    return tf.less(counter, 100)\n\ndef loop_body(input, counter):\n    output = tf.add(input, tf.square(counter))\n    return output, tf.add(counter, 1)\n\nwith tf.name_scope(\"compute_sum_of_squares\"):\n    counter = tf.constant(1)\n    sum_of_squares = tf.constant(0)\n\n    result = tf.while_loop(condition, loop_body, [sum_of_squares, counter])\n    \n\nwith tf.compat.v1.Session() as sess:\n    print(sess.run(result))","7e4fceb2":"sum([i**2 for i in range(1, 100 + 1)])","39df4825":"def safe_norm(s, axis=-1, epsilon=1e-7, keep_dims=False, name=None):\n    with tf.name_scope(name):\n        squared_norm = tf.reduce_sum(tf.square(s), axis=axis,\n                                     keepdims=keep_dims)\n        return tf.sqrt(squared_norm + epsilon)","8559e8e9":"y_proba = safe_norm(caps2_output, axis=-2, name=\"y_proba\")","b1e6ca50":"y_proba_argmax = tf.argmax(y_proba, axis=2, name=\"y_proba\")","f708bcd9":"y_proba_argmax","2e2cb3dd":"y_pred = tf.squeeze(y_proba_argmax, axis=[1,2], name=\"y_pred\")","b20d8ce4":"y_pred","44043cd3":"y = tf.compat.v1.placeholder(shape=[None], dtype=tf.int64, name=\"y\")","795e1286":"m_plus = 0.9\nm_minus = 0.1\nlambda_ = 0.5","3c68880d":"T = tf.one_hot(y, depth=caps2_n_caps, name=\"T\")","1f6efc68":"with tf.compat.v1.Session():\n    print(T.eval(feed_dict={y: np.array([0, 1, 2, 3, 9])}))","a839dd56":"caps2_output","8559008c":"caps2_output_norm = safe_norm(caps2_output, axis=-2, keep_dims=True,\n                              name=\"caps2_output_norm\")","afc70cd8":"present_error_raw = tf.square(tf.maximum(0., m_plus - caps2_output_norm),\n                              name=\"present_error_raw\")\npresent_error = tf.reshape(present_error_raw, shape=(-1, 10),\n                           name=\"present_error\")","785ad5b0":"absent_error_raw = tf.square(tf.maximum(0., caps2_output_norm - m_minus),\n                             name=\"absent_error_raw\")\nabsent_error = tf.reshape(absent_error_raw, shape=(-1, 10),\n                          name=\"absent_error\")","b65943cc":"L = tf.add(T * present_error, lambda_ * (1.0 - T) * absent_error,\n           name=\"L\")","5717b748":"margin_loss = tf.reduce_mean(tf.reduce_sum(L, axis=1), name=\"margin_loss\")","95ef5804":"mask_with_labels = tf.compat.v1.placeholder_with_default(False, shape=(),\n                                               name=\"mask_with_labels\")","9afc461c":"reconstruction_targets = tf.cond(mask_with_labels, # condition\n                                 lambda: y,        # if True\n                                 lambda: y_pred,   # if False\n                                 name=\"reconstruction_targets\")","e67afa93":"reconstruction_mask = tf.one_hot(reconstruction_targets,\n                                 depth=caps2_n_caps,\n                                 name=\"reconstruction_mask\")","6dd137a3":"reconstruction_mask","c11c0984":"caps2_output","847e4ca2":"reconstruction_mask_reshaped = tf.reshape(\n    reconstruction_mask, [-1, 1, caps2_n_caps, 1, 1],\n    name=\"reconstruction_mask_reshaped\")","c9c3d7de":"caps2_output_masked = tf.multiply(\n    caps2_output, reconstruction_mask_reshaped,\n    name=\"caps2_output_masked\")","1dc49421":"caps2_output_masked","a77b37d0":"decoder_input = tf.reshape(caps2_output_masked,\n                           [-1, caps2_n_caps * caps2_n_dims],\n                           name=\"decoder_input\")","863ede28":"n_hidden1 = 512\nn_hidden2 = 1024\nn_output = 28 * 28","84bd0ebe":"with tf.name_scope(\"decoder\"):\n    hidden1 = tf.compat.v1.layers.dense(decoder_input, n_hidden1,\n                              activation=tf.nn.relu,\n                                        name=\"hidden1\")\n    hidden2 = tf.compat.v1.layers.dense(hidden1, n_hidden2,\n                                        activation=tf.nn.relu,\n                                        name=\"hidden2\")\n    decoder_output = tf.compat.v1.layers.dense(hidden2, n_output,\n                                               activation=tf.nn.sigmoid,\n                                               name=\"decoder_output\")","d07e5df7":"X_flat = tf.reshape(X, [-1, n_output], name=\"X_flat\")\nsquared_difference = tf.square(X_flat - decoder_output,\n                               name=\"squared_difference\")\nreconstruction_loss = tf.reduce_mean(squared_difference,\n                                    name=\"reconstruction_loss\")","2835bafd":"alpha = 0.0005\n\nloss = tf.add(margin_loss, alpha * reconstruction_loss, name=\"loss\")","a4e51f53":"correct = tf.equal(y, y_pred, name=\"correct\")\naccuracy = tf.reduce_mean(tf.cast(correct, tf.float32), name=\"accuracy\")","3e8b1586":"optimizer = tf.compat.v1.train.AdamOptimizer()\ntraining_op = optimizer.minimize(loss, name=\"training_op\")","a301d3f6":"init = tf.compat.v1.global_variables_initializer()\nsaver = tf.compat.v1.train.Saver()","5a9b22f1":"len(X_train)","316f2824":"X_train[0:0+50]","6227ecf9":"from sklearn.model_selection import train_test_split\nX_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size=0.08, random_state=42)","83de7ff1":"len(X_train)","f0fbdb52":"len(X_val)","b0b532c7":"#y_train[c0:c0+batch_size]\nX_val.shape\n","7d21e915":"Y_val.shape","78250512":"n_epochs = 10\nbatch_size = 50\nrestore_checkpoint = True\n\nn_iterations_per_epoch = len(X_train) \/\/ batch_size\nn_iterations_validation = len(X_val) \/\/ batch_size\nbest_loss_val = np.infty\ncheckpoint_path = \".\/my_capsule_network\"\n\nwith tf.compat.v1.Session() as sess:\n    if restore_checkpoint and tf.compat.v1.train.checkpoint_exists(checkpoint_path):\n        saver.restore(sess, checkpoint_path)\n    else:\n        init.run()\n\n    for epoch in range(n_epochs):\n        b0 = 0\n        c0 = 0\n        for iteration in range(1, n_iterations_per_epoch + 1):\n            X_batch, y_batch = X_train[b0:b0+batch_size], Y_train[b0:b0+batch_size]\n            # Run the training operation and measure the loss:\n            _, loss_train = sess.run(\n                [training_op, loss],\n                feed_dict={X: X_batch.reshape([-1, 28, 28, 1]),\n                           y: y_batch,\n                           mask_with_labels: True})\n            print(\"\\rIteration: {}\/{} ({:.1f}%)  Loss: {:.5f}\".format(\n                      iteration, n_iterations_per_epoch,\n                      iteration * 100 \/ n_iterations_per_epoch,\n                      loss_train),\n                  end=\"\")\n            b0+=batch_size\n\n        # At the end of each epoch,\n        # measure the validation loss and accuracy:\n        loss_vals = []\n        acc_vals = []\n        for iteration in range(1, n_iterations_validation + 1):\n            X_batch, y_batch = X_val[c0:c0+batch_size], Y_val[c0:c0+batch_size]\n            loss_val, acc_val = sess.run(\n                    [loss, accuracy],\n                    feed_dict={X: X_batch.reshape([-1, 28, 28, 1]),\n                               y: y_batch})\n            loss_vals.append(loss_val)\n            acc_vals.append(acc_val)\n            print(\"\\rEvaluating the model: {}\/{} ({:.1f}%) {}\".format(\n                      iteration, n_iterations_validation,\n                      iteration * 100 \/ n_iterations_validation, c0),\n                  end=\" \" * 10)\n            c0+=batch_size\n        loss_val = np.mean(loss_vals)\n        acc_val = np.mean(acc_vals)\n        print(\"\\rEpoch: {}  Val accuracy: {:.4f}%  Loss: {:.6f}{}\".format(\n            epoch + 1, acc_val * 100, loss_val,\n            \" (improved)\" if loss_val < best_loss_val else \"\"))\n\n        # And save the model if it improved:\n        if loss_val < best_loss_val:\n            save_path = saver.save(sess, checkpoint_path)\n            best_loss_val = loss_val","cda88261":"b0 = 0\nn_iterations_test = len(X_test) \/\/ batch_size\n\nwith tf.compat.v1.Session() as sess:\n    saver.restore(sess, checkpoint_path)\n\n    loss_tests = []\n    acc_tests = []\n    for iteration in range(1, n_iterations_test + 1):\n        X_batch, y_batch = X_test[b0:b0+batch_size], Y_test[b0:b0+batch_size]\n        loss_test, acc_test = sess.run(\n                [loss, accuracy],\n                feed_dict={X: X_batch.reshape([-1, 28, 28, 1]),\n                           y: y_batch})\n        loss_tests.append(loss_test)\n        acc_tests.append(acc_test)\n        print(\"\\rEvaluating the model: {}\/{} ({:.1f}%)\".format(\n                  iteration, n_iterations_test,\n                  iteration * 100 \/ n_iterations_test),\n              end=\" \" * 10)\n        b0+=batch_size\n    loss_test = np.mean(loss_tests)\n    acc_test = np.mean(acc_tests)\n    print(\"\\rFinal test accuracy: {:.4f}%  Loss: {:.6f}\".format(\n        acc_test * 100, loss_test))","68236f3b":"n_samples = 5\n\nsample_images = X_test[:n_samples].reshape([-1, 28, 28, 1])\n\nwith tf.compat.v1.Session() as sess:\n    saver.restore(sess, checkpoint_path)\n    caps2_output_value, decoder_output_value, y_pred_value = sess.run(\n            [caps2_output, decoder_output, y_pred],\n            feed_dict={X: sample_images,\n                       y: np.array([], dtype=np.int64)})","893affde":"sample_images.shape","bc292867":"decoder_output_value.reshape([-1, 28, 28]).shape\n#reconstructions.shape","6372f117":"sample_images = sample_images.reshape(-1, 28, 28)\nreconstructions = decoder_output_value.reshape([-1, 28, 28])\n\nplt.figure(figsize=(n_samples * 2, 3))\nfor index in range(n_samples):\n    plt.subplot(1, n_samples, index + 1)\n    plt.imshow(sample_images[index], cmap=\"binary\")\n    plt.title(\"Label:\" + str(Y_test[index]))\n    plt.axis(\"off\")\n\nplt.show()\n\nplt.figure(figsize=(n_samples * 2, 3))\nfor index in range(n_samples):\n    plt.subplot(1, n_samples, index + 1)\n    plt.title(\"Predicted:\" + str(y_pred_value[index]))\n    plt.imshow(reconstructions[index], cmap=\"binary\")\n    plt.axis(\"off\")\n    \nplt.show()","ea9cc4a9":"caps2_output_value.shape","99a636b3":"def tweak_pose_parameters(output_vectors, min=-0.5, max=0.5, n_steps=11):\n    steps = np.linspace(min, max, n_steps) # -0.25, -0.15, ..., +0.25\n    pose_parameters = np.arange(caps2_n_dims) # 0, 1, ..., 15\n    tweaks = np.zeros([caps2_n_dims, n_steps, 1, 1, 1, caps2_n_dims, 1])\n    tweaks[pose_parameters, :, 0, 0, 0, pose_parameters, 0] = steps\n    output_vectors_expanded = output_vectors[np.newaxis, np.newaxis]\n    return tweaks + output_vectors_expanded","672bd791":"n_steps = 11\n\ntweaked_vectors = tweak_pose_parameters(caps2_output_value, n_steps=n_steps)\ntweaked_vectors_reshaped = tweaked_vectors.reshape(\n    [-1, 1, caps2_n_caps, caps2_n_dims, 1])","fadae386":"tweak_labels = np.tile(Y_test[:n_samples], caps2_n_dims * n_steps)\n\nwith tf.compat.v1.Session() as sess:\n    saver.restore(sess, checkpoint_path)\n    decoder_output_value = sess.run(\n            decoder_output,\n            feed_dict={caps2_output: tweaked_vectors_reshaped,\n                       mask_with_labels: True,\n                       y: tweak_labels})","c8427419":"tweak_reconstructions = decoder_output_value.reshape(\n        [caps2_n_dims, n_steps, n_samples, 28, 28])","f377f4ed":"for dim in range(3):\n    print(\"Tweaking output dimension #{}\".format(dim))\n    plt.figure(figsize=(n_steps \/ 1.2, n_samples \/ 1.5))\n    for row in range(n_samples):\n        for col in range(n_steps):\n            plt.subplot(n_samples, n_steps, row * n_steps + col + 1)\n            plt.imshow(tweak_reconstructions[dim, col, row], cmap=\"binary\")\n            plt.axis(\"off\")\n    plt.show()","c748d61d":"\n\nNote that the tf.cond() function expects the if-True and if-False tensors to be passed via functions: these functions will be called just once during the graph construction phase (not during the execution phase), similar to tf.while_loop(). This allows TensorFlow to add the necessary operations to handle the conditional evaluation of the if-True or if-False tensors. However, in our case, the tensors y and y_pred are already created by the time we call tf.cond(), so unfortunately TensorFlow will consider both y and y_pred to be dependencies of the reconstruction_targets tensor. The reconstruction_targets tensor will end up with the correct value, but:\n\n1. whenever we evaluate a tensor that depends on reconstruction_targets, the y_pred tensor will be evaluated (even if mask_with_layers is True). This is not a big deal because computing y_pred adds no computing overhead during training, since we need it anyway to compute the margin loss. And during testing, if we are doing classification, we won't need reconstructions, so reconstruction_targets won't be evaluated at all.\n1. we will always need to feed a value for the y placeholder (even if mask_with_layers is False). This is a bit annoying, but we can pass an empty array, because TensorFlow won't use it anyway (it just does not know it yet when it checks for dependencies).\n\nNow that we have the reconstruction targets, let's create the reconstruction mask. It should be equal to 1.0 for the target class, and 0.0 for the other classes, for each instance. For this we can just use the tf.one_hot() function:\n","f63984e0":"\n\nLet's check the shape of reconstruction_mask:\n","b0888aa4":"We can now update the raw routing weights $b_{i,j}$ by simply adding the scalar product $\\hat{\\mathbf{u}}_{j|i} \\cdot \\mathbf{v}_j$ we just computed: $b_{i,j} \\gets b_{i,j} + \\hat{\\mathbf{u}}_{j|i} \\cdot \\mathbf{v}_j$ (see Procedure 1, step 7, in the paper).","49c9a2ec":"And now let's look at the shape of caps2_output_round_1, which holds 10 outputs vectors of 16D each, for each instance:","56f9db61":"\n\nIn the code above, we created different operations in the TensorFlow graph for each round of the routing by agreement algorithm. In other words, it's a static loop.\n\nSure, instead of copy\/pasting the code several times, we could have written a for loop in Python, but this would not change the fact that the graph would end up containing different operations for each routing iteration. It's actually okay since we generally want less than 5 routing iterations, so the graph won't grow too big.\n\nHowever, you may prefer to implement the routing loop within the TensorFlow graph itself rather than using a Python for loop. To do this, you would need to use TensorFlow's tf.while_loop() function. This way, all routing iterations would reuse the same operations in the graph, it would be a dynamic loop.\n\nFor example, here is how to build a small loop that computes the sum of squares from 1 to 100:\n","22ed87f2":"# Capsule Networks (CapsNets)","ff5eb8c7":"First, we will need a placeholder for the labels:","c854ca02":"Now let's use tf.cond() to define the reconstruction targets as the labels y if mask_with_labels is True, or y_pred otherwise.","010fc2c1":"Note: since we used a kernel size of 9 and no padding (for some reason, that's what \"valid\" means), the image shrunk by 9-1=8 pixels after each convolutional layer (28\u00d728 to 20\u00d720, then 20\u00d720 to 12\u00d712), and since we used a stride of 2 in the second convolutional layer, the image size was divided by 2. This is how we end up with 6\u00d76 feature maps.","7e009692":"# Decoder","b60e7b61":"That's it! On to the second array, now. As discussed earlier, we need to create an array of shape (batch size, 1152, 10, 8, 1), containing the output of the first layer capsules, repeated 10 times (once per digit, along the third dimension, which is axis=2). The caps1_output array has a shape of (batch size, 1152, 8), so we first need to expand it twice, to get an array of shape (batch size, 1152, 1, 8, 1), then we can repeat it 10 times along the third dimension:","a8214a65":"## Compute the Predicted Output Vectors\n\n\nThe digit capsule layer contains 10 capsules (one for each digit) of 16 dimensions each:\n","4f3a00b8":"At last! We can apply the mask:","b9861b6e":"Great! We have the output of the first capsule layer. It wasn't too hard, was it? However, computing the next layer is where the fun really begins.","e0144077":"# Primary Capsules\nThe first layer will be composed of 32 maps of 6\u00d76 capsules each, where each capsule will output an 8D activation vector:","8ffb69c2":"Need to split test in validation!","7dfe1e2b":"To compute the output of the digit capsules, we must first compute the predicted output vectors (one for each primary \/ digit capsule pair). Then we can run the routing by agreement algorithm.","d9aec59c":"We are ready to compute the loss for each instance and each digit:","8ea4a690":"## Final Loss\nThe final loss is the sum of the margin loss and the reconstruction loss (scaled down by a factor of 0.0005 to ensure the margin loss dominates training):","dbe5f5f7":"Let's check the shape of the first array:","511475c1":"A small example should make it clear what this does:","be995ea8":"Now let's feed these tweaked output vectors to the decoder and get the reconstructions it produces:","d171dffb":"To predict the class of each instance, we can just select the one with the highest estimated probability. To do this, let's start by finding its index using tf.argmax():","a3d7f518":"And... we're done with the construction phase! Please take a moment to celebrate. :)","d19d7f01":"Now let's compute the norm of the output vector for each output capsule and each instance. First, let's verify the shape of caps2_output:","a1063bab":"To get these shapes to match, we just need to tile the caps2_output_round_1 array 1152 times (once per primary capsule) along the second dimension:","17fa1f6e":"## Estimated Class Probabilities (Length)\n\nThe lengths of the output vectors represent the class probabilities, so we could just use tf.norm() to compute them, but as we saw when discussing the squash function, it would be risky, so instead let's create our own safe_norm() function:\n","0e986676":"# Imports","75a04eab":"Import matplotlib to plot pretty figures:","f0ec86ed":"!!! Insert a Figure Here!!!","1af108d1":"Now let's build a Capsule Network to classify these images. Here's the overall architecture, enjoy the ASCII art! ;-) Note: for readability, I left out two arrows: Labels \u2192 Mask, and Input Images \u2192 Reconstruction Loss.\n \n\n                            Loss\n                              \u2191\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      Labels \u2192 Margin Loss      Reconstruction Loss\n                    \u2191                   \u2191\n                  Length             Decoder\n                    \u2191                   \u2191 \n             Digit Capsules \u2500\u2500\u2500\u2500Mask\u2500\u2500\u2500\u2500\u2518\n               \u2196\u2191\u2197 \u2196\u2191\u2197 \u2196\u2191\u2197\n             Primary Capsules\n                    \u2191      \n               Input Images\n\n\nWe are going to build the graph starting from the bottom layer, and gradually move up, left side first. Let's go!","9acd2e12":"\n\nLet's create a function that will tweak each of the 16 pose parameters (dimensions) in all output vectors. Each tweaked output vector will be identical to the original output vector, except that one of its pose parameters will be incremented by a value varying from -0.5 to 0.5. By default there will be 11 steps (-0.5, -0.4, ..., +0.4, +0.5). This function will return an array of shape (tweaked pose parameters=16, steps=11, batch size=5, 1, 10, 16, 1):\n","3a89636b":"# Final Touches\n## Accuracy\nTo measure our model's accuracy, we need to count the number of instances that are properly classified. For this, we can simply compare y and y_pred, convert the boolean value to a float32 (0.0 for False, 1.0 for True), and compute the mean over all the instances:\n","981f7f9f":"Mmh, its shape is (batch size, 1, 10, 16, 1). We want to multiply it by the reconstruction_mask, but the shape of the reconstruction_mask is (batch size, 10). We must reshape it to (batch size, 1, 10, 1, 1) to make multiplication possible:","ce9a3cb3":"Now we can create the first array by repeating W once per instance:","3786b699":"## Training Operations\n\nThe paper mentions that the authors used the Adam optimizer with TensorFlow's default parameters:\n","f6656166":"# Predictions\n\nNow let's make some predictions! We first fix a few images from the test set, then we start a session, restore the trained model, evaluate caps2_output to get the capsule network's output vectors, decoder_output to get the reconstructions, and y_pred to get the class predictions:\n","2fa3179a":"Yes! Now, to get all the predicted output vectors $\\hat{\\mathbf{u}}_{j|i}$, we just need to multiply these two arrays using tf.matmul(), as explained earlier:","710a4bfc":"\n\nFor each capsule $i$ in the first layer, we want to predict the output of every capsule $j$ in the second layer. For this, we will need a transformation matrix $\\mathbf{W}_{i,j}$ (one for each pair of capsules ($i$, $j$)), then we can compute the predicted output $\\hat{\\mathbf{u}}_{j|i} = \\mathbf{W}_{i,j} \\, \\mathbf{u}_i$ (equation (2)-right in the paper). Since we want to transform an 8D vector into a 16D vector, each transformation matrix $\\mathbf{W}_{i,j}$ must have a shape of (16, 8).\n\nTo compute $\\hat{\\mathbf{u}}_{j|i}$ for every pair of capsules ($i$, $j$), we will use a nice feature of the tf.matmul() function: you probably know that it lets you multiply two matrices, but you may not know that it also lets you multiply higher dimensional arrays. It treats the arrays as arrays of matrices, and it performs itemwise matrix multiplication. For example, suppose you have two 4D arrays, each containing a 2\u00d73 grid of matrices. The first contains matrices $\\mathbf{A}, \\mathbf{B}, \\mathbf{C}, \\mathbf{D}, \\mathbf{E}, \\mathbf{F}$ and the second contains matrices $\\mathbf{G}, \\mathbf{H}, \\mathbf{I}, \\mathbf{J}, \\mathbf{K}, \\mathbf{L}$. If you multiply these two 4D arrays using the tf.matmul() function, this is what you get:\n\n$\\pmatrix{ \\mathbf{A} & \\mathbf{B} & \\mathbf{C} \\\\ \\mathbf{D} & \\mathbf{E} & \\mathbf{F} } \\times \\pmatrix{ \\mathbf{G} & \\mathbf{H} & \\mathbf{I} \\\\ \\mathbf{J} & \\mathbf{K} & \\mathbf{L} } = \\pmatrix{ \\mathbf{AG} & \\mathbf{BH} & \\mathbf{CI} \\\\ \\mathbf{DJ} & \\mathbf{EK} & \\mathbf{FL} }$\n","e017c318":"\nTraining\n\nTraining our capsule network is pretty standard. For simplicity, we won't do any fancy hyperparameter tuning, dropout or anything, we will just run the training operation over and over again, displaying the loss, and at the end of each epoch, measure the accuracy on the validation set, display it, and save the model if the validation loss is the lowest seen found so far (this is a basic way to implement early stopping, without actually stopping). Hopefully the code should be self-explanatory, but here are a few details to note:\n\n* if a checkpoint file exists, it will be restored (this makes it possible to interrupt training, then restart it later from the last checkpoint),\n* we must not forget to feed mask_with_labels=True during training,\n* during testing, we let mask_with_labels default to False (but we still feed the labels since they are required to compute the accuracy),\n* the images loaded via mnist.train.next_batch() are represented as float32 arrays of shape [784], but the input placeholder X expects a float32 array of shape [28, 28, 1], so we must reshape the images before we feed them to our model,\n* we evaluate the model's loss and accuracy on the full validation set (5,000 instances). To view progress and support systems that don't have a lot of RAM, the code evaluates the loss and accuracy on one batch at a time, and computes the mean loss and mean accuracy at the end.\n\nWarning: if you don't have a GPU, training will take a very long time (at least a few hours). With a GPU, it should take just a few minutes per epoch (e.g., 6 minutes on an NVidia GeForce GTX 1080Ti).\n","6c2cdb2c":"# Reconstruction\n\nNow let's add a decoder network on top of the capsule network. It is a regular 3-layer fully connected neural network which will learn to reconstruct the input images based on the output of the capsule network. This will force the capsule network to preserve all the information required to reconstruct the digits, across the whole network. This constraint regularizes the model: it reduces the risk of overfitting the training set, and it helps generalize to new digits.\n\n## Mask\n\nThe paper mentions that during training, instead of sending all the outputs of the capsule network to the decoder network, we must send only the output vector of the capsule that corresponds to the target digit. All the other output vectors must be masked out. At inference time, we must mask all output vectors except for the longest one, i.e., the one that corresponds to the predicted digit. You can see this in the paper's figure 2 (at 18:15 in the video): all output vectors are masked out, except for the reconstruction target's output vector.\n\nWe need a placeholder to tell TensorFlow whether we want to mask the output vectors based on the labels (True) or on the predictions (False, the default):\n","cc883ac1":"# Evaluation","9557d7e3":"## Reconstruction Loss\n\n\nNow let's compute the reconstruction loss. It is just the squared difference between the input image and the reconstructed image:\n","4e54128c":"Now let's build the decoder. It's quite simple: two dense (fully connected) ReLU layers followed by a dense output sigmoid layer:","6df7faad":"# Conclusion\u00b6\n\nI tried to make the code in this notebook as flat and linear as possible, to make it easier to follow, but of course in practice you would want to wrap the code in nice reusable functions and classes. For example, you could try implementing your own PrimaryCapsuleLayer, and DenseRoutingCapsuleLayer classes, with parameters for the number of capsules, the number of routing iterations, whether to use a dynamic loop or a static loop, and so on. For an example a modular implementation of Capsule Networks based on TensorFlow, take a look at the CapsNet-TensorFlow project.\n\nThat's all for today, I hope you enjoyed this notebook!\n","4b039300":"To compute their outputs, we first apply two regular convolutional layers:","0728d071":"# Digit Capsules","5a563fde":"## Reproducibility\n\nLet's reset the default graph, in case you re-run this notebook without restarting the kernel:","17949433":"This is the [Aur\u00e9lien G\u00e9ron's](https:\/\/github.com\/ageron\/handson-ml\/blob\/master\/extra_capsnets.ipynb) implementation with aditional comments and some modifications that I've done due to tensorflow and imports versions. I implemented the code using graph mode. In a future version I will update to use eager mode.\n\nBased on the paper: [Dynamic Routing Between Capsules](https:\/\/arxiv.org\/abs\/1710.09829), by Sara Sabour, Nicholas Frosst and Geoffrey E. Hinton (NIPS 2017).\n\nInspired in part from Huadong Liao's implementation: [CapsNet-TensorFlow.](https:\/\/github.com\/naturomics\/CapsNet-Tensorflow)","4a3ccdf0":"Let's compute all the tweaked output vectors and reshape the result to (parameters\u00d7steps\u00d7instances, 1, 10, 16, 1) so we can feed the array to the decoder:","22671f3f":"First let's initialize the raw routing weights $b_{i,j}$ to zero:","88b4e8ed":"Note1: [check in this link why I disabled eager execution](https:\/\/stackoverflow.com\/questions\/56561734\/runtimeerror-tf-placeholder-is-not-compatible-with-eager-execution) <br>\nNote2: [What tf.compat means](https:\/\/stackoverflow.com\/questions\/60406140\/attributeerror-module-tensorflow-has-no-attribute-layers)","e6c7614b":"# Input Images\nLet's start by creating a placeholder for the input images (28\u00d728 pixels, 1 color channel = grayscale).","f7e06fae":"\n\nThat's what we wanted: for each instance, we now have the index of the longest output vector. Let's get rid of the last two dimensions by using tf.squeeze() which removes dimensions of size 1. This gives us the capsule network's predicted class for each instance:\n","f006d2ee":"\n\nLet's compare this to the shape of caps2_output:\n","c817b020":"Perfect, for each instance in the batch (we don't know the batch size yet, hence the \"?\") and for each pair of first and second layer capsules (1152\u00d710) we have a 16D predicted output column vector (16\u00d71). We're ready to apply the routing by agreement algorithm!","c9cc98a5":"[This video](https:\/\/youtu.be\/pPN8d0E3900) explain the key ideas behind Capsule Networks:","6f6494c3":"Now let's apply this function to get the output $\\mathbf{u}_i$ of each primary capsules $i$ :","4031bf7a":"Let's look at what these hand-written digit images look like:","44c0d1ba":"\n\nTo support both Python 2 and Python 3:\n","b9e415ca":"\n\nLet's set the random seeds so that this notebook always produces the same output:\n","ab1c71be":"## Round 1","7a4a54f0":"\n\nINFO:tensorflow:Restoring parameters from .\/my_capsule_network\n\nNote: we feed y with an empty array, but TensorFlow will not use it, as explained earlier.\n\nAnd now let's plot the images and their labels, followed by the corresponding reconstructions and predictions:\n","ee715445":"Lastly, let's plot all the reconstructions, for the first 3 output dimensions, for each tweaking step (column) and each digit (row):","03bf848c":"Joke aside, apart from reducing the graph size, using a dynamic loop instead of a static loop can help reduce how much GPU RAM you use (if you are using a GPU). Indeed, if you set swap_memory=True when calling the tf.while_loop() function, TensorFlow will automatically check GPU RAM usage at each loop iteration, and it will take care of swapping memory between the GPU and the CPU when needed. Since CPU memory is much cheaper and abundant than GPU RAM, this can really make a big difference.","d50186ac":"\n# Interpreting the Output Vectors\n\nLet's tweak the output vectors to see what their pose parameters represent.\n\nFirst, let's check the shape of the cap2_output_value NumPy array:\n","fde17995":"Next, we reshape the output to get a bunch of 8D vectors representing the outputs of the primary capsules. The output of conv2 is an array containing 32\u00d78=256 feature maps for each instance, where each feature map is 6\u00d76. So the shape of this output is (batch size, 6, 6, 256). We want to chop the 256 into 32 vectors of 8 dimensions each. We could do this by reshaping to (batch size, 6, 6, 32, 8). However, since this first capsule layer will be fully connected to the next capsule layer, we can simply flatten the 6\u00d76 grids. This means we just need to reshape to (batch size, 6\u00d76\u00d732, 8).","ef2f51c1":"One last reshape operation to flatten the decoder's inputs:","2ba8143d":"Now let's compute $\\max(0, m^{+} - \\|\\mathbf{v}_k\\|)^2$, and reshape the result to get a simple matrix of shape (batch size, 10):","e28119f8":"# Load MNIST","22bb1511":"\n\nLet's check the shape:\n","21caeef8":"\n\nOkay, we are now ready to define the training operations, starting with the losses.\n","7ee704e1":"\n\nGood! We have ten 16D output vectors for each instance, as expected.\n## Round 2\n\nFirst, let's measure how close each predicted vector $\\hat{\\mathbf{u}}_{j|i}$ is to the actual output vector $\\mathbf{v}_j$ by computing their scalar product $\\hat{\\mathbf{u}}_{j|i} \\cdot \\mathbf{v}_j$.\n\nQuick math reminder: if $\\vec{a}$ and $\\vec{b}$ are two vectors of equal length, and $\\mathbf{a}$ and $\\mathbf{b}$ are their corresponding column vectors (i.e., matrices with a single column), then $\\mathbf{a}^T \\mathbf{b}$ (i.e., the matrix multiplication of the transpose of $\\mathbf{a}$, and $\\mathbf{b}$) is a 1\u00d71 matrix containing the scalar product of the two vectors $\\vec{a}\\cdot\\vec{b}$. In Machine Learning, we generally represent vectors as column vectors, so when we talk about computing the scalar product $\\hat{\\mathbf{u}}_{j|i} \\cdot \\mathbf{v}_j$, this actually means computing ${\\hat{\\mathbf{u}}_{j|i}}^T \\mathbf{v}_j$.\n\nSince we need to compute the scalar product $\\hat{\\mathbf{u}}_{j|i} \\cdot \\mathbf{v}_j$ for each instance, and for each pair of first and second level capsules $(i, j)$, we will once again take advantage of the fact that tf.matmul() can multiply many matrices simultaneously. This will require playing around with tf.tile() to get all dimensions to match (except for the last 2), just like we did earlier. So let's look at the shape of caps2_predicted, which holds all the predicted output vectors $\\hat{\\mathbf{u}}_{j|i}$ for each instance and each pair of capsules:\n","a867eca2":"\n\nThere are a couple important details to note here:\n\nTo perform elementwise matrix multiplication (also called the Hadamard product, noted $\\circ$), we use the tf.multiply() function. It requires routing_weights and caps2_predicted to have the same rank, which is why we added two extra dimensions of size 1 to routing_weights, earlier.\n\nThe shape of routing_weights is (batch size, 1152, 10, 1, 1) while the shape of caps2_predicted is (batch size, 1152, 10, 16, 1). Since they don't match on the fourth dimension (1 vs 16), tf.multiply() automatically broadcasts the routing_weights 16 times along that dimension. If you are not familiar with broadcasting, a simple example might help:\n\n$ \\pmatrix{1 & 2 & 3 \\\\ 4 & 5 & 6} \\circ \\pmatrix{10 & 100 & 1000} = \\pmatrix{1 & 2 & 3 \\\\ 4 & 5 & 6} \\circ \\pmatrix{10 & 100 & 1000 \\\\ 10 & 100 & 1000} = \\pmatrix{10 & 200 & 3000 \\\\ 40 & 500 & 6000} $\n\nAnd finally, let's apply the squash function to get the outputs of the second layer capsules at the end of the first iteration of the routing by agreement algorithm, $\\mathbf{v}_j = \\operatorname{squash}(\\mathbf{s}_j)$ :\n","0d6b3b0d":"And these are the corresponding labels:","53c6165a":"First, let's apply the softmax function to compute the routing weights, $\\mathbf{c}_{i} = \\operatorname{softmax}(\\mathbf{b}_i)$ (equation (3) in the paper):","607fbdc9":"Since y will contain the digit classes, from 0 to 9, to get $T_k$ for every instance and every class, we can just use the tf.one_hot() function:","8256a682":"# Margin loss\n\nThe paper uses a special margin loss to make it possible to detect two or more different digits in each image:\n\n$ L_k = T_k \\max(0, m^{+} - \\|\\mathbf{v}_k\\|)^2 + \\lambda (1 - T_k) \\max(0, \\|\\mathbf{v}_k\\| - m^{-})^2$\n\n$T_k$ is equal to 1 if the digit of class $k$ is present, or 0 otherwise.\nIn the paper, $m^{+} = 0.9$, $m^{-} = 0.1$ and $\\lambda = 0.5$.\nNote that there was an error in the video (at 15:47): the max operations are squared, not the norms. Sorry about that.\n\n","dab12907":"[This video](https:\/\/youtu.be\/2Kawrd5szHE) presents the main difficulties of this notebook:","27f48c71":"The rest of round 2 is the same as in round 1:","9d8abbe0":"## Static or Dynamic Loop?","7ed2f55f":"And now we are ready to call tf.matmul() (note that we must tell it to transpose the matrices in the first array, to get ${\\hat{\\mathbf{u}}_{j|i}}^T$ instead of $\\hat{\\mathbf{u}}_{j|i}$):","64d4645b":"We could go on for a few more rounds, by repeating exactly the same steps as in round 2, but to keep things short, we will stop here:","c2c3b005":"The 16D output vectors are in the second to last dimension, so let's use the safe_norm() function with axis=-2:","43352480":"# Introduction","7febf4cd":"INFO:tensorflow:Restoring parameters from .\/my_capsule_network\n\nLet's reshape the decoder's output so we can easily iterate on the output dimension, the tweak steps, and the instances:\n","fe478af6":"We will see why we need the last two dimensions of size 1 in a minute.","9e09d1da":"Let's look at the shape of y_proba_argmax:","aa162248":"Now we can sum the digit losses for each instance ($L_0 + L_1 + \\cdots + L_9$), and compute the mean over all instances. This gives us the final margin loss:","26171b27":"Now we need to squash these vectors. Let's define the squash() function, based on equation (1) from the paper:\n\n$\\operatorname{squash}(\\mathbf{s}) = \\dfrac{\\|\\mathbf{s}\\|^2}{1 + \\|\\mathbf{s}\\|^2} \\dfrac{\\mathbf{s}}{\\|\\mathbf{s}\\|}$\n\nThe squash() function will squash all vectors in the given array, along the given axis (by default, the last axis).\n\nCaution, a nasty bug is waiting to bite you: the derivative of $\\|\\mathbf{s}\\|$ is undefined when $\\|\\mathbf{s}\\|=0$, so we can't just use tf.norm(), or else it will blow up during training: if a vector is zero, the gradients will be nan, so when the optimizer updates the variables, they will also become nan, and from then on you will be stuck in nan land. The solution is to implement the norm manually by computing the square root of the sum of squares plus a tiny epsilon value: $\\|\\mathbf{s}\\| \\approx \\sqrt{\\sum\\limits_i{{s_i}^2}\\,\\,+ \\epsilon}$.","7fd1d593":"Now let's compute the weighted sum of all the predicted output vectors for each second-layer capsule, $\\mathbf{s}_j = \\sum\\limits_{i}{c_{i,j}\\hat{\\mathbf{u}}_{j|i}}$ (equation (2)-left in the paper):","4ffe4d02":"# Labels","2eee0deb":"Next let's compute $\\max(0, \\|\\mathbf{v}_k\\| - m^{-})^2$ and reshape it:","25e94084":"# Routing by agreement","436d9251":"As you can see, the tf.while_loop() function expects the loop condition and body to be provided via two functions. These functions will be called only once by TensorFlow, during the graph construction phase, not while executing the graph. The tf.while_loop() function stitches together the graph fragments created by condition() and loop_body() with some additional operations to create the loop.\n\nAlso note that during training, TensorFlow will automagically handle backpropogation through the loop, so you don't need to worry about that.\n\nOf course, we could have used this one-liner instead! ;-)","37b15320":"We can apply this function to compute $\\hat{\\mathbf{u}}_{j|i}$ for every pair of capsules ($i$, $j$) like this (recall that there are 6\u00d76\u00d732=1152 capsules in the first layer, and 10 in the second layer):\n\n$\\pmatrix{ \\mathbf{W}{1,1} & \\mathbf{W}{1,2} & \\cdots & \\mathbf{W}{1,10} \\ \\mathbf{W}{2,1} & \\mathbf{W}{2,2} & \\cdots & \\mathbf{W}{2,10} \\ \\vdots & \\vdots & \\ddots & \\vdots \\ \\mathbf{W}{1152,1} & \\mathbf{W}{1152,2} & \\cdots & \\mathbf{W}_{1152,10} } \\times \\pmatrix{ \\mathbf{u}_1 & \\mathbf{u}_1 & \\cdots & \\mathbf{u}_1 \\ \\mathbf{u}_2 & \\mathbf{u}_2 & \\cdots & \\mathbf{u}2 \\ \\vdots & \\vdots & \\ddots & \\vdots \\ \\mathbf{u}{1152} & \\mathbf{u}{1152} & \\cdots & \\mathbf{u}{1152}}$\n\n$\\pmatrix{ \\hat{\\mathbf{u}}{1|1} & \\hat{\\mathbf{u}}{2|1} & \\cdots & \\hat{\\mathbf{u}}{10|1} \\ \\hat{\\mathbf{u}}{1|2} & \\hat{\\mathbf{u}}{2|2} & \\cdots & \\hat{\\mathbf{u}}{10|2} \\ \\vdots & \\vdots & \\ddots & \\vdots \\ \\hat{\\mathbf{u}}{1|1152} & \\hat{\\mathbf{u}}{2|1152} & \\cdots & \\hat{\\mathbf{u}}_{10|1152} }$\n\nThe shape of the first array is (1152, 10, 16, 8), and the shape of the second array is (1152, 10, 8, 1). Note that the second array must contain 10 identical copies of the vectors $\\mathbf{u}_1$ to $\\mathbf{u}_{1152}$. To create this array, we will use the handy tf.tile() function, which lets you create an array containing many copies of a base array, tiled in any way you want.\n\nOh, wait a second! We forgot one dimension: batch size. Say we feed 50 images to the capsule network, it will make predictions for these 50 images simultaneously. So the shape of the first array must be (50, 1152, 10, 16, 8), and the shape of the second array must be (50, 1152, 10, 8, 1). The first layer capsules actually already output predictions for all 50 images, so the second array will be fine, but for the first array, we will need to use tf.tile() to have 50 copies of the transformation matrices.\n\nOkay, let's start by creating a trainable variable of shape (1, 1152, 10, 16, 8) that will hold all the transformation matrices. The first dimension of size 1 will make this array easy to tile. We initialize this variable randomly using a normal distribution with a standard deviation to 0.1.","d090efa5":"## Init and Saver\n\nAnd let's add the usual variable initializer, as well as a Saver:\n"}}