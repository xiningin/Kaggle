{"cell_type":{"df0b7d8b":"code","c005b19b":"code","e33d3a25":"code","898f0ac9":"code","98bf6d3a":"code","1b71a975":"code","8d29ac96":"code","6a56aec6":"code","632b76b3":"code","84399f89":"code","787c0bc4":"code","574dae2f":"code","09484442":"markdown","9fd27f70":"markdown","3adbd85b":"markdown","fd9f6534":"markdown","9856b1fb":"markdown"},"source":{"df0b7d8b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom scipy import optimize\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set() \n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","c005b19b":"df = pd.read_csv(\"..\/input\/database.csv\")\ndf = df.drop([3378,7512,20650]) #Drop error data","e33d3a25":"df.describe()","898f0ac9":"plt.hist(df[\"Magnitude\"],log=True)","98bf6d3a":"df_japan = df.query('25 < Latitude < 50 and 125 < Longitude < 150')\ndf_japan = df_japan.reset_index(drop=True)\ndf_japan[\"Date_Time\"] = pd.to_datetime(df_japan[\"Date\"]+\" \"+df_japan[\"Time\"], format = \"%m\/%d\/%Y %H:%M:%S\")","1b71a975":"df_japan.describe()","8d29ac96":"plt.hist(df_japan[\"Magnitude\"],log=True)\n#Magnitude 9.1 is Tohoku Earthquake(2011)","6a56aec6":"###########\n#calc \u03bb(t)#\n###########\ndef ramda(param,Tmax,Mc,Ti,Mi,T):\n    a,c,p,k,mu=np.exp(param)\n    return mu+((T>Ti)*k*np.exp(a*(Mi - Mc))\/((T>Ti)*(T - Ti) + c)**p).sum()\n\n####################################\n#calc Transformed Time:\u039b(t)=\u222b\u03bb(t)dt#\n####################################\ndef transformed_time(param,Tmax,Mc,Ti,Mi,T):\n    a,c,p,k,mu=np.exp(param)    \n    if abs(p-1)<0.001:\n        N = mu*T + ((T>=Ti)*k*np.exp(a*(Mi - Mc))* \\\n                    ( (np.log((T>=Ti)*(T - Ti)+ c)**1-np.log(c)**1) \\\n                     +(np.log((T>=Ti)*(T - Ti)+ c)**2-np.log(c)**2)*(1-p)**1\/2 \\\n                     +(np.log((T>=Ti)*(T - Ti)+ c)**3-np.log(c)**3)*(1-p)**2\/6 \\\n                   )).sum() #using Taylor series at p=1\n    else:\n        N = mu*T + ((T>=Ti)*k*np.exp(a*(Mi - Mc))*(((T>=Ti)*(T - Ti) + c)**(1-p)-c**(1-p))\/(1-p)).sum()\n    return N\n\n######################################################\n#calc AIC(=-2*loglikelyhood + 2*Number of Parameters)#\n######################################################\ndef calc_aic(param,Tmax,Mc,Ti,Mi):\n    a,c,p,k,mu=np.exp(param)\n    if abs(p-1)<0.001:\n        LogL = np.array([np.log(mu+((t>Ti)*k*np.exp(a*(Mi - Mc))\/((t>Ti)*(t - Ti) + c)**p).sum()) for t in Ti]).sum() \\\n                   - mu*Tmax - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))* \\\n                   ( (np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**1-np.log(c)**1) \\\n                    +(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**2-np.log(c)**2)*(1-p)**1\/2 \\\n                    +(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**3-np.log(c)**3)*(1-p)**2\/6 \\\n                   )).sum()\n    else:\n        LogL = np.array([np.log(mu+((t>Ti)*k*np.exp(a*(Mi - Mc))\/((t>Ti)*(t - Ti) + c)**p).sum()) for t in Ti]).sum() \\\n                   - mu*Tmax - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))*(((Tmax>=Ti)*(Tmax - Ti) + c)**(1-p)-c**(1-p))\/(1-p)).sum()\n    return -2*LogL+2*5\n\n######################\n#calc gradient of AIC#\n######################\ndef calc_grad(param,Tmax,Mc,Ti,Mi):\n    a,c,p,k,mu=np.exp(param)\n    grad=np.zeros(5)\n    \n    #\u2202\/\u2202x\u03a3log\u03bb(t,x)\n    for i, t in enumerate(Ti):\n        ramda=mu+((t>Ti)*k*np.exp(a*(Mi - Mc))\/((t>Ti)*(t - Ti) + c)**p).sum()\n        grad[0]+=((t>Ti)*k*np.exp(a*(Mi - Mc))*(Mi - Mc)                      \/((t>Ti)*(t - Ti) + c)**p    ).sum()\/ramda\n        grad[1]+=((t>Ti)*k*np.exp(a*(Mi - Mc))*(-p)                           \/((t>Ti)*(t - Ti) + c)**(p+1)).sum()\/ramda\n        grad[2]+=((t>Ti)*k*np.exp(a*(Mi - Mc))*np.log(1\/((t>Ti)*(t - Ti) + c))\/((t>Ti)*(t - Ti) + c)**p    ).sum()\/ramda\n        grad[3]+=((t>Ti)*1*np.exp(a*(Mi - Mc))                                \/((t>Ti)*(t - Ti) + c)**p    ).sum()\/ramda\n        grad[4]+= 1\/ramda\n    \n    #\u2202\/\u2202x\u222b\u03bb(t,t)dt\n    if abs(p-1)<0.001:\n        grad[0]+= - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))*(Mi - Mc)* \\\n                       (    (np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**1-np.log(c)**1) \\\n                           +(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**2-np.log(c)**2)*(1-p)**1\/2 \\\n                           +(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**3-np.log(c)**3)*(1-p)**2\/6 \\\n                       )).sum() \n        grad[1]+= - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))*(((Tmax>=Ti)*(Tmax - Ti) + c)**(0-p)-c**(0-p))).sum()\n        grad[2]+= - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))* \\\n                       (   -(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**2-np.log(c)**2)\/2 \\\n                           -(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**3-np.log(c)**3)*(1-p)\/3 \\\n                           -(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**4-np.log(c)**4)*(1-p)**2\/8 \\\n                       )).sum()\n        grad[3]+= - ((Tmax>=Ti)*np.exp(a*(Mi - Mc))* \\\n                       (    (np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**1-np.log(c)**1) \\\n                           +(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**2-np.log(c)**2)*(1-p)**1\/2 \\\n                           +(np.log((Tmax>=Ti)*(Tmax - Ti)+ c)**3-np.log(c)**3)*(1-p)**2\/6 \\\n                       )).sum()\n        grad[4]+= - Tmax\n\n    else:\n        dp=0.001\n        pp0=(((Tmax>=Ti)*(Tmax - Ti) + c)**(1-p+dp\/2)-c**(1-p+dp\/2))\/(1-p+dp\/2)\n        pp1=(((Tmax>=Ti)*(Tmax - Ti) + c)**(1-p-dp\/2)-c**(1-p-dp\/2))\/(1-p-dp\/2)\n        pp = (pp1-pp0)\/dp\n        \n        grad[0]+= - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))*(Mi - Mc)*(((Tmax>=Ti)*(Tmax - Ti) + c)**(1-p)-c**(1-p))\/(1-p)).sum()\n        grad[1]+= - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))*1        *(((Tmax>=Ti)*(Tmax - Ti) + c)**(0-p)-c**(0-p)      )).sum()\n        grad[2]+= - ((Tmax>=Ti)*k*np.exp(a*(Mi - Mc))*pp                                                            ).sum()\n        grad[3]+= - ((Tmax>=Ti)*1*np.exp(a*(Mi - Mc))*1        *(((Tmax>=Ti)*(Tmax - Ti) + c)**(1-p)-c**(1-p))\/(1-p)).sum()\n        grad[4]+= - Tmax\n\n    return -2*grad*np.exp(param) #\u2202f(x)\/\u2202(log(x))=\u2202f(x)\/\u2202x*x","632b76b3":"#Prepare input data\nMi=df_japan[\"Magnitude\"].values\nTi=Mi*0\nfor i,t in enumerate(df_japan[\"Date_Time\"]):\n    Ti[i] = (t-df_japan[\"Date_Time\"][0]).total_seconds()\/60\/60\/24\n\nMc=5.5 #cut off magnitude\nTmax=Ti.max()\n\n#initial values\na,c,p,k,mu=1.0, 0.1, 1.1, 0.1, 0.1\nparam_initial=np.array([a,c,p,k,mu])","84399f89":"log_param_initial=np.log(param_initial) #log-param\nargs=(Tmax,Mc,Ti,Mi)\n\nlog_param_fitted=optimize.fmin_bfgs(calc_aic, log_param_initial, fprime=calc_grad, args=(Tmax,Mc,Ti,Mi),gtol=0.0001)\nparam_fitted = np.exp(log_param_fitted)\n\nprint(\"a,c,p,k,mu=\",param_fitted)","787c0bc4":"#Plot \u03bb(t)\ntmp=[ramda(log_param_fitted,Tmax,Mc,Ti,Mi,t) for t in np.arange(0,Tmax,0.1)]\nfig, ax = plt.subplots(figsize=(15,5))\nx = np.arange(0,Tmax,0.1)\ny = np.log(tmp)\nax.set_xlabel(\"Time(days)\")\nax.set_ylabel(\"log(\u03bb(t))\")\nax.plot(x, y,linewidth = 0.2)\nplt.show() ","574dae2f":"#Plot Transformed Time\ntmp=[transformed_time(log_param_fitted,Tmax,Mc,Ti,Mi,t) for t in Ti]\nfig, ax = plt.subplots(figsize=(10,10)) \nx = np.arange(1, 2092)\ny = tmp[1:2092]\nax.set_xlabel(\"Number of Earthquakes\")\nax.set_ylabel(\"Transformed Time\")\nax.plot(x, y)\nax.plot(x, x)\nplt.show()","09484442":"**Fitting ETAS model**","9fd27f70":"**Inplement ETAS model by using Numpy**  \nETAS parameters are positive. So I use log-transformed parameters to ignore constraint condition.","3adbd85b":"**Prepare input data and give initial values for ETAS parameters**","fd9f6534":"**Introduction**  \nTo analyze an earthquake sequence(occurrence date and magnitude), Epidemic Type Aftershock Sequence(ETAS) model(e.g., Ogata, 1988, 1999) is useful.  \nETAS model is a point process model, including the Omori-Utsu law and branching process in which every earthquake has some ability to generate its own aftershocks.   \nTherefore, the seismicity rate at time t is given by summing the effects of all prior earthquakes and background seismicity rate \u03bcas,  \n![40623_2015_630050419_Equ1.gif](attachment:40623_2015_630050419_Equ1.gif)\nwhere c and p are parameters in the Omori-Utsu law, K and \u03b1 control the aftershock productivity by a mainshock and its magnitude sensitivity, respectively. These five parameters, \u03bc, c, p, K,and \u03b1, are determined by Maximum Likelihood Estimation(MLE).  \n\nIn ETAS model, the log likelihood can be expressed as follows:  \n![40623_2015_630050419_Equ2.gif](attachment:40623_2015_630050419_Equ2.gif)\n\n**Reference**  \nOgata, Y., Statistical models for earthquake occurrences and residual analysis for point processes, J. Am. Stat. Assoc, 83, 9\u201327, 1988. 10.1080\/01621459.1988.10478560  \nOgata, Y., Detection of precursory relative quiescence before great earthquakes through a statistical model, J. Geophys. Res, 97, 19845\u201319871, 1992. 10.1029\/92JB00708  \n[Okutani, T., and S. Ide (2011), Statistic analysis of swarm activities around the Boso Peninsula, Japan: Slow slip events beneath Tokyo Bay?,Earth Planets Space, 63, 419\u2013426.](https:\/\/link.springer.com\/article\/10.5047\/eps.2011.02.010)","9856b1fb":"**Plot \u03bb(t) and Transformed Time**"}}