{"cell_type":{"f45baa73":"code","5caf9bc2":"code","29827b04":"code","1d52666d":"code","ceaba7d6":"code","5042b904":"code","257fa67d":"code","511525cb":"code","5830edc8":"code","df649319":"code","529fee4e":"code","9388d6b5":"code","419dbc6a":"code","106b932e":"code","fe6da03e":"code","0545dc97":"code","cc89bfb0":"code","9cf276a0":"code","89c90215":"code","e6a0ee99":"code","c7b78dae":"code","fea3a71d":"code","c024cdcf":"code","431cb6a3":"code","70b4ed7c":"code","4a4550d0":"code","520a4ce2":"code","b094c00d":"code","bae9ab4c":"code","ba8b0a6b":"code","680954f9":"code","0714c6a0":"code","e317ea8d":"code","a22bce4f":"code","568c5bb3":"code","f5540e87":"code","a9248ca7":"code","048e35cf":"code","e3097084":"code","6e45e419":"markdown","e0dcce9a":"markdown","11338905":"markdown","15c2fba2":"markdown","9bc19c79":"markdown","cd2042b3":"markdown","414b8c16":"markdown","815aff0c":"markdown","4360df93":"markdown","2a42493f":"markdown","2ff9900a":"markdown","69f0d52d":"markdown","65da9529":"markdown","a4cca96f":"markdown","bc9663eb":"markdown","f5edf707":"markdown","50cc167b":"markdown","9d7f0fb8":"markdown","b034e584":"markdown","58bdbb80":"markdown","fceccaab":"markdown","9e0cd1f3":"markdown","2f2e6cf4":"markdown","069634cc":"markdown","935bf63e":"markdown","11f7fc5d":"markdown","63d6b903":"markdown","d6e65161":"markdown"},"source":{"f45baa73":"import pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.model_selection import StratifiedKFold, cross_val_score\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\nfrom sklearn.linear_model import LinearRegression, LogisticRegression, BayesianRidge, ARDRegression, PoissonRegressor\nfrom sklearn.ensemble import ExtraTreesRegressor, RandomForestRegressor, StackingRegressor\nfrom sklearn.svm import SVR\nfrom sklearn.neural_network import MLPRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.preprocessing import MinMaxScaler,StandardScaler\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.experimental import enable_hist_gradient_boosting \nfrom sklearn.ensemble import HistGradientBoostingRegressor\n\nimport scipy.optimize\n\nfrom xgboost import XGBRegressor\n\nfrom tqdm import tqdm","5caf9bc2":"x = np.linspace(1,7,7)\n\ny_true = np.array([5, 4, 8, 6, 5, 4, 5])\nm1 =     np.array([7, 3, 9, 5, 6, 3, 3.5])\nm2 =     np.array([4, 5, 8, 7, 2, 5, 6])","29827b04":"df = pd.DataFrame(np.array([x, m1, m2, y_true]).T, columns = ['x', 'm1', 'm2', 'y_true']).melt('x')\ndf.columns = ['x', 'Values', 'y']","1d52666d":"fig = sns.lmplot(x = 'x', y= 'y', data = df, hue='Values', palette=[\"b\", \"g\", \"orange\"], fit_reg=False )\nfig.axes[0,0].plot(x, m1, linestyle='dotted', color = 'b')\nfig.axes[0,0].plot(x, m2, linestyle='dotted', color = 'g')\nfig.axes[0,0].plot(x, y_true, linewidth = 2, color = 'orange')\n\nplt.xlim([0, 8])\nplt.ylim([0, 10])\nplt.show()","ceaba7d6":"m1_res = y_true - m1\nm2_res = y_true - m2\n\ndf_res = pd.DataFrame(np.array([x, m1_res, m2_res]).T, columns = ['x', 'm1_res', 'm2_res']).melt('x')\ndf_res.columns = ['x', 'Residuals', 'y']","5042b904":"fig = sns.lmplot(x = 'x', y= 'y', data = df_res, hue='Residuals', palette=[\"b\", \"g\", \"orange\"], fit_reg=False )\nfig.axes[0,0].plot(x, m1_res, linestyle='dotted', color = 'b')\nfig.axes[0,0].plot(x, m2_res, linestyle='dotted', color = 'g')\nfig.axes[0,0].plot(x, np.zeros(7), linewidth = 2, color = 'orange')\n\nplt.xlim([0, 8])\nplt.ylim([-5, 5])\nplt.show()","257fa67d":"print(f'Model #1. mean: {m1_res.mean(): .4f}, var: {m1_res.var(): .4f}')\nprint(f'Model #2. mean: {m2_res.mean(): .4f}, var: {m2_res.var(): .4f}')\n","511525cb":"ens = (m1+m2)\/2\n\ndf = pd.DataFrame(np.array([x, m1, m2, ens, y_true]).T, columns = ['x', 'm1', 'm2', 'ens', 'y_true']).melt('x')\ndf.columns = ['x', 'Values', 'y']\n","5830edc8":"fig = sns.lmplot(x = 'x', y= 'y', data = df, hue='Values', palette=[\"b\", \"g\", \"black\", \"orange\"], fit_reg=False )\nfig.axes[0,0].plot(x, m1, linestyle='dotted', color = 'b')\nfig.axes[0,0].plot(x, m2, linestyle='dotted', color = 'g')\nfig.axes[0,0].plot(x, ens, color = 'black')\nfig.axes[0,0].plot(x, y_true, linewidth = 2, color = 'orange')\n\nplt.xlim([0, 8])\nplt.ylim([0, 10])\nplt.show()","df649319":"ens_res = y_true - ens\n\ndf_res = pd.DataFrame(np.array([x, m1_res, m2_res, ens_res]).T, columns = ['x', 'm1_res', 'm2_res', 'ens_res']).melt('x')\ndf_res.columns = ['x', 'Residuals', 'y']","529fee4e":"fig = sns.lmplot(x = 'x', y= 'y', data = df_res, hue='Residuals', palette=[\"b\", \"g\", \"black\", \"orange\"], fit_reg=False )\nfig.axes[0,0].plot(x, m1_res, linestyle='dotted', color = 'b')\nfig.axes[0,0].plot(x, m2_res, linestyle='dotted', color = 'g')\nfig.axes[0,0].plot(x, ens_res, color = 'black')\nfig.axes[0,0].plot(x, np.zeros(7), linewidth = 2, color = 'orange')\n\nplt.xlim([0, 8])\nplt.ylim([-5, 5])\nplt.show()","9388d6b5":"print(f'Ensemble. mean: {ens_res.mean(): .4f}, var: {ens_res.var(): .4f}')","419dbc6a":"# generate weights for w1\nweight_m1 = np.linspace(0, 1, 30)\n\nens_mean = np.zeros(30)\nens_var = np.zeros(30)\n\nfor i, w1 in enumerate(weight_m1):\n    # build ensemble for different weights\n    ens = m1*w1 + m2*(1-w1)\n    ens_res = y_true - ens\n    \n    # keep track of mean and var of the differently weighted ensembles\n    ens_mean[i] = ens_res.mean()\n    ens_var[i] = ens_res.var()","106b932e":"# plot var vs mean\n\nfig = plt.figure()\nax = plt.subplot()\nplt.scatter(ens_var, ens_mean)\nax.set_xlabel('Variance')\nax.set_ylabel('Mean')\nplt.show()","fe6da03e":"fun = lambda w: (y_true-np.matmul(w, preds)).var()","0545dc97":"# w.sum() = 1  <=> 0 = w.sum()-1\ncons = ({'type': 'eq', 'fun': lambda w: w.sum()-1})","cc89bfb0":"bnds = ((0,None),\n        (0,None),\n        (0,None),\n        (0,None),\n        (0,None))","9cf276a0":"# predictions of Model1 and Model 2\npreds = np.array([m1, m2])\n\n# init weights\nw_init = np.ones(preds.shape[0])\/preds.shape[0]\n\n# run optimization\nres = scipy.optimize.minimize(fun, w_init, method='SLSQP',  constraints=cons) #,bounds=bnds\n\n# get optimal weights\nw_calc = res.x\n\n\nprint(f'Calculated weights: {w_calc}')","89c90215":"ens_ex1 = np.matmul(w_calc, preds)\nens_ex1_res=y_true-ens_ex1\n\nprint(f'Ensemble Ex1. mean: {ens_ex1_res.mean(): .4f}, var: {ens_ex1_res.var(): .4f}')","e6a0ee99":"## following https:\/\/en.wikipedia.org\/wiki\/Modern_portfolio_theory\n\n# Predictions of Model 1 and Model 2\npreds = np.array([m1,m2])\n# Residuals of Model 1 and Model 2\npreds_res = np.array([m1_res, m2_res])\n\n# handle residuals like asset returns\nR = np.array(preds_res.mean(axis=1))\n# factor by which R is considered during optimization. turned off for our example\nq = 0 #-1\n\n# covariance matrix of model residuals\nCM = np.cov(preds_res)\n\n# optimization function\nfun = lambda w: np.matmul(np.matmul(w.T,CM),w) - q * np.matmul(R,w)\n\n# constraint: weights must sum up to 1.0\ncons = ({'type': 'eq', 'fun': lambda x: x.sum()-1})","c7b78dae":"# init weights\nw_init = np.ones(preds.shape[0])\/preds.shape[0]\n\n# run optimization\nres = scipy.optimize.minimize(fun, w_init, method='SLSQP',  constraints=cons) #,bounds=bnds\n\n# get optimal weights\nw_calc = res.x\n\nprint(f'Calculated weights: {w_calc}')","fea3a71d":"ens_ex2 = np.matmul(w_calc, preds)\nens_ex2_res=y_true-ens_ex2\nens_ex2_res.mean(), ens_ex2_res.var()","c024cdcf":"DEBUG = False\n\nif DEBUG:\n    N_SPLITS = 3\nelse:\n    N_SPLITS = 7\nSEED = 2021","431cb6a3":"# load and shuffle\ntest = pd.read_csv('..\/input\/tabular-playground-series-aug-2021\/test.csv')\n\ntrain = pd.read_csv('..\/input\/tabular-playground-series-aug-2021\/train.csv').sample(frac=1.0, random_state = SEED).reset_index(drop=True)\n\nif DEBUG:\n    train = train.head(5000)\n\ntrain['fold_crit'] = train.loss\ntrain.loc[train.loss>=39, 'fold_crit']=39\n","70b4ed7c":"target = 'loss'\nfold_crit = 'fold_crit'\nfeatures = list(set(train.columns)-set(['id','kfold','loss','fold_crit']+[target]))","4a4550d0":"# apply abhisheks splitting technique\nskf = StratifiedKFold(n_splits = N_SPLITS, random_state = None, shuffle = False)\n\ntrain.kfold = -1\n\nfor f, (train_idx, valid_idx) in enumerate(skf.split(X = train, y = train[fold_crit].values)):\n    \n    train.loc[valid_idx,'kfold'] = f\n\ntrain.groupby('kfold')[target].count()","520a4ce2":"# define models\nmodels = {\n    'LinReg': LinearRegression(n_jobs=-1),\n    'HGB': HistGradientBoostingRegressor(),\n    'XGB': XGBRegressor(tree_method = 'gpu_hist', reg_lambda= 6, reg_alpha= 10, n_jobs=-1),\n    'KNN': KNeighborsRegressor(100, n_jobs=-1),\n    'BayesRidge': BayesianRidge(),\n    'ExtraTrees': ExtraTreesRegressor(max_depth=2, n_jobs=-1),\n    'Poisson': Pipeline(steps=[('scale', StandardScaler()),\n                ('pois', PoissonRegressor(max_iter=100))])    \n}\n\n","b094c00d":"#for (k, model) in models.items():\n#    scores = cross_val_score(model, train[features], train[target], n_jobs=-1, cv=skf, scoring='neg_root_mean_squared_error')\n#    print(f'{k}:\\t {-scores.mean():0.5f} (+\/- {scores.std():0.5f}) rmse')","bae9ab4c":"for (m_name, m) in models.items():\n    print(f'# Model:{m_name}\\n')\n    train[m_name + '_oof'] = 0\n    test[m_name] = 0\n    \n    y_oof = np.zeros(train.shape[0])\n    \n    for f in range(N_SPLITS):\n\n        train_df = train[train['kfold'] != f]\n        valid_df = train[train['kfold'] == f]\n        \n        m.fit(train_df[features], train_df[target])\n        \n        oof_preds = m.predict(valid_df[features])\n        y_oof[valid_df.index] = oof_preds\n        print(f'Fold {f} rmse: {mean_squared_error(valid_df[target], oof_preds, squared = False):0.5f}')\n        \n        test[m_name] += m.predict(test[features]) \/ N_SPLITS\n    \n    train[m_name + '_oof'] = y_oof\n    \n    print(f\"\\nTotal rmse: {mean_squared_error(train[target], train[m_name + '_oof'], squared = False):0.5f}\\n\")\n\n\noof_cols = [m_name + '_oof' for m_name in models.keys()]\n\nprint(f\"# ALL Mean ensemble rmse: {mean_squared_error(train[target], train[oof_cols].mean(axis=1), squared = False):0.5f}\\n\")        ","ba8b0a6b":"test","680954f9":"\noof_cols = [m_name + '_oof' for m_name in models.keys()]\n\noofs = train[oof_cols]\n\noof_diffs = oofs.copy()\nfor c in oof_cols:\n    oof_diffs[c] = oofs[c]-train[target]\n    oof_diffs[c] = oof_diffs[c]#**2\n\nsns.heatmap(oof_diffs.corr())","0714c6a0":"# Do some manual equaly wheighted ensemblings and export.\n\nsubmission = pd.read_csv('..\/input\/tabular-playground-series-aug-2021\/sample_submission.csv')\nsubmission['loss']=test[models.keys()].mean(axis=1)\n\nsubmission.to_csv('submission_ALL.csv',index=False)\nprint('CV: ALL equaly weighted:',mean_squared_error(train[target], train[[m_name + '_oof' for m_name in models.keys()]].mean(axis=1), squared = False))\n\nsubmission['loss']=test[['XGB']].mean(axis=1)\n\nsubmission.to_csv('submission_xgb.csv',index=False)\nprint('CV: XGB only:',mean_squared_error(train[target], train[['XGB_oof']].mean(axis=1), squared = False))\n\nsubmission['loss']=test[['HGB']].mean(axis=1)\n\nsubmission.to_csv('submission_hgb.csv',index=False)\nprint('CV: HGB only:',mean_squared_error(train[target], train[['HGB_oof']].mean(axis=1), squared = False))\n\nsubmission['loss']=test[['LinReg', 'XGB']].mean(axis=1)\n\nsubmission.to_csv('submission_xgb_lin.csv',index=False)\nprint('CV: XGB and LinReg (50:50):',mean_squared_error(train[target], train[['LinReg_oof', 'XGB_oof']].mean(axis=1), squared = False))\n\nsubmission['loss']=test[['KNN', 'XGB']].mean(axis=1)\n\nsubmission.to_csv('submission_xgb_knn.csv',index=False)\nprint('CV: XGB and KNN (50:50):',mean_squared_error(train[target], train[['KNN_oof', 'XGB_oof']].mean(axis=1), squared = False))\n","e317ea8d":"oof_diffs.var(), oof_diffs.mean()","a22bce4f":"oof_diffs.hist(figsize=(15,15),bins=20)","568c5bb3":"R = oof_diffs.mean().values\nCM = oof_diffs.cov().values\n\nq=0\n\n# Var technique\nfun_ex1 = lambda w: (train[target]-np.matmul(oofs.values, w)).var()\n# Cov technique\nfun_ex2 = lambda w: np.matmul(np.matmul(w.T,CM),w) - q * np.matmul(R,w)\n\ncons = ({'type': 'eq', 'fun': lambda x: x.sum()-1})\n\nbnds = ((0,None),\n        (0,None),\n        (0,None),\n        (0,None),\n        (0,None))","f5540e87":"# Example 1\n\nw_init = np.ones((len(models)))\/len(models)\n\nres = scipy.optimize.minimize(fun_ex1, w_init, method='SLSQP',  constraints=cons) #,bounds=bnds\n\nw_calc = res.x","a9248ca7":"submission['loss']=(test[models.keys()]*w_calc).sum(axis=1)\n\nsubmission.to_csv('submission_ex1_w_calc.csv',index=False)\n\nprint('CV: Ex1 calc weights:',mean_squared_error(train[target], (train[[m_name + '_oof' for m_name in models.keys()]]*w_calc).sum(axis=1), squared = False))","048e35cf":"# Example 2\n\nw_init = np.ones((len(models)))\/len(models)\n\nres = scipy.optimize.minimize(fun_ex2, w_init, method='SLSQP',  constraints=cons) #,bounds=bnds\n\nw_calc = res.x","e3097084":"submission['loss']=(test[models.keys()]*w_calc).sum(axis=1)\n\nsubmission.to_csv('submission_ex2_w_calc.csv',index=False)\n\nprint('CV: Ex2 calc weights:',mean_squared_error(train[target], (train[[m_name + '_oof' for m_name in models.keys()]]*w_calc).sum(axis=1), squared = False))","6e45e419":"Fit models and save oof predictions.","e0dcce9a":"If you want, you can also set bounds, so that the weights want be negative.\n\nI don't. I like the idea of going *short* with a model. And negative weights really increase the results of TPS predictions in chapter 4. ","11338905":"These are the histograms of the residuals:","15c2fba2":"Let's a look at the correlation heatmap.","9bc19c79":"Now, we are all set to retrieve the optimal weights. ","cd2042b3":"# 5. Results\n\nThese are the scores of the different ensembles:\n\n|Ensemble|     CV|public LB|\n|--------|-------|---------|\n|HGB only|7.86477|7.90117|\n|All weights eq.|7.88080|7.92183|\n|XGB and KNN (50:50)| 7.89481| 7.91603|\n|Ex1 (Var)| 7.85613|7.88876|\n|Ex2 (Cov)| 7.85613|7.88876|","414b8c16":"We also define a constraint so that the `w.sum() == 0`:","815aff0c":"XGB and KNN are most diverse, so I export a 50:50 ensemble. I'll also export an equally weighted ensemble of all models and HGB only because it is the best single model.","4360df93":"We con compare the results with the first ensemble 50:50 split. \nWith the calculated weights we could further reduce the variance of the model (0.2219 -> 0.2157). But unfortunately the mean increased a bit (0.0357 -> 0.0380).\n\nWe see the trade off between mean and variance and have to decide if we prefer a more stable model or take some risk for better results.","2a42493f":"# Model allocation\n\nIn this notebook I experiment with two ensembling strategies.\n\nThere are many ways to combine different models to improve predictions. A common technique for regression tasks is taking a weighted average of the model predictions (`y_pred = (m1(x)*w1 + ... + mn(x)*wn) \/ n`). Another common technique is building a meta model, that is trained on the models' outputs.\n\nThe first chapter starts with a simple linear combination of two models. And we explore with an simple example, why ensembling actually works. These insights will lead, in the second chapter, to the first technique on how to choose weights for a linear ensemble by using residual variance. In the third chapter an alternative for the weight selection is examined. This second technique is inspired by portfolio theory (a theory to combine financial assets). In the fourth chapter the two techniques are applied and compared on the  [Tabular Playground Series (TPS) - Aug 2021](https:\/\/www.kaggle.com\/c\/tabular-playground-series-aug-2021) competition. Finaly cross validation (CV) and leaderboard (LB) Scores are listed in the fith chapter.\n\n> Note: For the ease of explanation we make some simplifying assumptions, such as equal distribution of the data, same distribution on unseen data, ... (just think of a vanilla world).","2ff9900a":"The ensemble line is closer to the true values. It also looks smoother then m1 and m2.","69f0d52d":"Now we build a simple linear ensemble of the two models like `ens = 0.5 * m1 + 0.5 m2`.","65da9529":"The weights are the same as in the first technique. That really surprised me. And I run a couple of examples with different models. But the weights were only slightly different between the two techniques.","a4cca96f":"If we had to choose one of the models, which one would we prefer? \nModel 2 does better on the first data point and perfect on the third, but it contains an outlier the 5th data point.\n\nLet's look at the mean and the variance of the residuals.","bc9663eb":"# 4. Ensembling TPS Aug 2021\n\nNow that we have to techniques to ensemble, let's try them on the [TPS August 2021](https:\/\/www.kaggle.com\/c\/tabular-playground-series-aug-2021\/overview) data.\n\nWe do a 7 kfold split and calculate the residuals on the out-of-fold-predictions, that are used for validation. We train 7 regression models with different architecture so we get some diversity.","f5edf707":"Finally, we apply the two techniques to calculate the ensembling weights.","50cc167b":"In the residual chart we can see that the ensemble does a bit worse for x=3 compared to Model 2. But it also decreases the residuals for the outliers (points 1, 5, 7).\n\nLet's check the stats:","9d7f0fb8":"With the previous 50:50 split the variance seems almost at the lowest point. So we only get a reduction of the mean below 0.0357 if we allow the ensemble to have more variance, hence take more risk.","b034e584":"# 3. Portfolio theory for ensembling","58bdbb80":"On the long run Model2 has an average residual of 0. Model 1 carries along a residual of 0.0714. So on average Model 2 seams to do better. \n\nBut Model 2 also has a higher variance. That implies we have a great chance to do a great prediction (e.g. x=3) but we also have high risk to screw the prediction (e.g. x=5). \n","fceccaab":"Next we inspect the variance and mean of the residuals. Means are close to 0, as expected.","9e0cd1f3":"We dramatically reduced the variance, hence reduced the risk\/chance. The mean value is now in between Model 1 and Model 2.\n\nFinally let's play around with the model weights in the ensemble and check how mean and variance change.","2f2e6cf4":"In finance different assets are often combined in a portfolio. There are many criteria for the asset selection\/allocation. One of them is by choosing a risk strategy. In 1952 the economist Harry Markowitz defined a *Portfolio Selection* strategy which built the foundation of many portfolio strategies to come. There is a great summary on [Wikipidia](https:\/\/en.wikipedia.org\/wiki\/Modern_portfolio_theory), but the original paper can also be found with a google search.\n\n\nSo, what it is all about. Let's assume we are living in an easy, plain vanilla world. We want to build a portfolio that yields high return with low risk. That's not easy. If we only buy stocks of our favorite fruit grower, a rainy summer would result in a low return. Wouldn't it be smart to also buy stocks of a raincoat producer, just in case. But what if the summer was sunny, then we would have rather invested the entire money in fruits instead of raincoats. It's clearly a trade off. Either we lower the risk of loosing money in a rainy summer and invest in both (fruits and raincoats). Or we take the risk investing all money in fruits to maybe gain more money. And if we lower the risk, in which raincoat producer should we invest? The one with the bumpy stock price or the one with a steady, but slowly growing stock price.\n\nNow, we already see the first similarities between our ensemble example above and the Portfolio Theory. Risk can be measured through variance and a good return of our ensemble is results in a low expected residual.\n\nBut there is even more in Portfolio Theory. It also takes dependencies between assets into account. If the summer is sunny the fruit price goes up and the raincoat price goes down, they are somewhat negative correlated. \n\nSince we expect the average residual of our fitted models to be close to 0 and we build a linear model, we can expect our ensemble average residual also to be close to 0. Therefore, we focus on optimizing the portfolio variance, which can be boiled down to `Var_p = w'*Cov*w`. The covariance measures the dependency between combined models and also considers the variance.\n\n> What data can we actually use? In the financial example *returns* are the increase or decrease of an asset price (p\/p_t-1), hence we are looking on returns for a certain period of time. In ML we can take our **out-of-fold** (oof) predictions and calculate the residuals from the train targets to build a dataset.\n\n> Can we do this despite we are looking at a time-series in the financial example? Yes, in this *basic* portfolio theory we don't take time dependencies into account. But it's important to keep the same order for the different asset returns for correlation\/covariance calculation. We want to compare the residual of model 1 and 2 for always the same data item.\n\nThe optimization function for the second ensemble technique is:","069634cc":"Run the optimization.","935bf63e":"To get a better intuition on how good the two models fit the ground truth, we plot the residuals `y_true(x)-m(x)`.","11f7fc5d":"# 1. Why ensembling works\n\nSuppose there are two fitted regression models and they predict values like shown in the first chart.","63d6b903":"Let's see how the calculated weights perform.","d6e65161":"# 2. Weights by residual variance\n\nSince the Model 1 and Model 2 are well fitted, their average residuals are pretty close to 0. So let's focus on reducing our variance to avoid surprises on later later predictions.\n\nWe now solve for the optimal weights that minimizes the variance of the residual of our ensemble with this function:"}}