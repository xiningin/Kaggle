{"cell_type":{"66ecd0eb":"code","e6960572":"code","3d6f096a":"code","9bcfcc32":"code","185a7d66":"code","13a1f5f5":"code","e635f48b":"code","51e8c7be":"code","3b19e63e":"code","a8097418":"code","89f67bab":"code","2ad8c41b":"code","2d292275":"code","b4afd38e":"markdown","3bdbd4b3":"markdown","1563c4d3":"markdown","af96ae9c":"markdown"},"source":{"66ecd0eb":"import sys\nsys.path.append('..\/input\/timm-pytorch-image-models\/pytorch-image-models-master')\nsys.path.append('..\/input\/pytorch-optimizers\/')","e6960572":"import os\nimport gc\nimport cv2\nimport copy\nimport time\nimport yaml\nimport random\nimport shutil\nimport warnings\nimport subprocess\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom glob import glob as glob_file\nfrom tqdm import tqdm\nfrom PIL import Image, ImageDraw\nfrom shutil import copyfile\nfrom IPython.core.display import Video, display\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split, KFold, GroupKFold, StratifiedKFold\n\nimport timm\nimport torch\nfrom fastai.vision.all import *\n\nwarnings.simplefilter('ignore')\npd.set_option(\"max_columns\", 150)\npd.set_option('display.max_rows', 150)","3d6f096a":"# https:\/\/github.com\/rwightman\/pytorch-image-models\/blob\/master\/results\/results-imagenet.csv\n# timm.list_models(pretrained=True)","9bcfcc32":"CFG = {\n    \"save_prev\"     : [True, [\"petfinder_*.pth\"]],\n    \"seed\"          : 42,\n    'device'        : \"cuda:0\" if torch.cuda.is_available() else \"cpu\",\n    \"input_img\"     : '..\/input\/petfinder-pawpularity-score\/train\/',\n    \"input_path\"    : '..\/input\/petfinder-smogn-dataset\/train_drop_duplicated.csv',\n    \"output_path\"   : '.\/',\n    \"pretrain\"      : \"..\/input\/petfinder-fastai-semisupervised-models\/petfinder_swin_binary_ss_fastai_smogn_4.pth\",\n    \"save_name\"     : \"petfinder_swin_binary_fastai_ss_smogn\",\n    \"model\"         : \"swin_large_patch4_window7_224_in22k\",\n    \"loss\"          : \"binary\",\n    \"size\"          : 224,\n    \"fold\"          : 4,\n    \"batch_size\"    : 32,\n    \"epochs\"        : 5,\n    \"n_data\"        : None,  # Batch * step\n    \"mixup_ratio\"   : 0,\n    \"lr\"            : 1e-6,\n    \"accum_iter\"    : 2,\n    'early_stopping': 3,\n    'verbose_step'  : 1,\n    \"num_workers\"   : 4\n}\n\nCFG","185a7d66":"def get_img(path):\n    im_bgr = cv2.imread(path)\n    im_rgb = im_bgr[:, :, ::-1]\n    return im_rgb\n\ndef sigmoid(a):\n    return 1 \/ (1 + np.exp(-a))\n\ndef softmax(x):\n    max = np.max(x,axis=1,keepdims=True)\n    e_x = np.exp(x - max)\n    sum = np.sum(e_x,axis=1,keepdims=True)\n    return e_x \/ sum \n\ndef seed_everything(seed = 42):\n    '''Sets the seed of the entire notebook so results are the same every time we run.\n    This is for REPRODUCIBILITY.'''\n    np.random.seed(seed)\n    random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    # When running on the CuDNN backend, two further options must be set\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n    # Set a fixed value for the hash seed\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    \nseed_everything(CFG[\"seed\"])","13a1f5f5":"if CFG['save_prev'][0]:\n    for file_pattern in CFG['save_prev'][1]:\n        for f in glob_file(f\"..\/input\/petfinder-fastai-models-pseudolabel-2\/{file_pattern}\"):\n            filename = os.path.basename(f)\n            print(filename)\n            !cp {f} .\/{filename}","e635f48b":"df_train = pd.read_csv(CFG['input_path'])\ndf_train[\"path\"] = [f\"{CFG['input_img']}{i}.jpg\" for i in df_train.Id]\ndf_train[\"Pawclass\"] = df_train.Pawpularity \/ 100\n\nnum_bins = int(np.ceil(2*((len(df_train))**(1.\/3))))\ndf_train['bins'] = pd.cut(df_train['Pawclass'], bins=num_bins, labels=False)\n\nmeta_features = [c for c in df_train.columns if c not in [\"Id\",\"path\", \"Pawpularity\",\"Pawclass\",\"bins\"]]\n\nprint(meta_features)\nprint(df_train.shape)\ndf_train.head(2)","51e8c7be":"kfold = StratifiedKFold(n_splits=CFG['fold'], random_state=CFG[\"seed\"], shuffle=True)\ndf_train[\"fold\"] = 0\nfor i, (_, train_index) in enumerate(kfold.split(df_train.index, df_train['bins'])):\n    df_train.loc[train_index, \"fold\"] = i\ndf_train['fold'] = df_train['fold'].astype('int')\n\ndf_train.fold.value_counts()","3b19e63e":"df_train.Pawpularity.hist(bins=100)","a8097418":"def prepare_dataloader(df, fold):\n    df = df.copy()\n    df['is_valid'] = (df['fold'] == fold)\n    \n    label_col  = \"Pawclass\" if CFG[\"loss\"] == \"binary\" else \"Pawpularity\"\n    dataloader = ImageDataLoaders.from_df(\n        df,\n        valid_col='is_valid',\n        seed=CFG[\"seed\"],\n        fn_col='path',\n        label_col=label_col,\n        y_block=RegressionBlock,\n        bs=CFG['batch_size'],\n        n=CFG[\"n_data\"],\n        shuffle=True,\n        num_workers=CFG['num_workers'],\n        item_tfms=Resize(CFG['size']),\n        batch_tfms=setup_aug_tfms([Brightness(), Contrast(), Hue(), Saturation()])\n    )\n    return dataloader\n\ndef petfinder_rmse(input,target):\n    return 100*torch.sqrt(F.mse_loss(F.sigmoid(input.flatten()), target))","89f67bab":"class Model(nn.Module):\n    def __init__(self, model_name, pretrained=True):\n        super().__init__()\n        self.model = timm.create_model(model_name, pretrained=pretrained, in_chans=3)\n        self.n_features = self.model.classifier.in_features\n        self.model.classifier = nn.Linear(self.n_features, 1)\n\n    def forward(self, x):\n        output = self.model(x)\n        return output\n\nclass SwinModel(nn.Module):\n    def __init__(self, model_name, pretrained=True):\n        super().__init__()\n        self.model   = timm.create_model(model_name, pretrained=pretrained, num_classes=0, in_chans=3)\n        num_features = self.model.num_features\n        self.linear  = nn.Linear(num_features, 1)\n\n    def forward(self, x):\n        x = self.model(x)\n        output = self.linear(x)\n        return output\n\ndef get_learner(df, fold):\n    dataloader = prepare_dataloader(df, fold)\n    if CFG['pretrain'] is None:\n        model = SwinModel(CFG[\"model\"], pretrained=True)\n    else:\n        model = SwinModel(CFG[\"model\"], pretrained=False)\n        model.load_state_dict(torch.load(CFG['pretrain']))\n    learner = Learner(\n        dataloader,\n        model,\n        loss_func=BCEWithLogitsLossFlat(),\n        metrics=AccumMetric(petfinder_rmse)).to_fp16()\n    return learner","2ad8c41b":"# Ref: https:\/\/fastai1.fast.ai\/callbacks.lr_finder.html\n# get_learner(df_train, fold=0).lr_find(end_lr=3e-2)\n# SuggestedLRs(valley=3.307316728751175e-05) with pretrained on external data\n# SuggestedLRs(valley=2.2654900021734647e-05)","2d292275":"all_preds = []\n\nfor fold in range(CFG[\"fold\"]):\n    learn = get_learner(df_train, fold)\n    learn.fit_one_cycle(\n        CFG[\"epochs\"],\n        CFG[\"lr\"],\n        cbs=[SaveModelCallback(),\n             EarlyStoppingCallback(monitor='petfinder_rmse',\n                                   comp=np.less,\n                                   patience=CFG['early_stopping'])]\n    )\n    shutil.move(\".\/models\/model.pth\", f\"{CFG['output_path']}{CFG['save_name']}_{fold}.pth\")\n    \n    del learn\n    torch.cuda.empty_cache()\n    gc.collect()\n    \n!rm -rf .\/models","b4afd38e":"# Run training","3bdbd4b3":"# Define model","1563c4d3":"# Configuration","af96ae9c":"# Load data"}}