{"cell_type":{"824e362a":"code","ba4ed99c":"code","d3b8f50c":"code","fd3cb937":"code","939da8eb":"code","345ec4d0":"code","b57b55fb":"code","7e50b840":"code","4231182a":"code","16da4610":"code","3b52a0cc":"code","0ae897f0":"code","2d619e51":"code","0acddf30":"code","91f374ec":"code","967b1bdf":"code","55460718":"code","1847f698":"code","913b688c":"code","3d183e7c":"code","f46a3179":"code","c336ca18":"code","1f0d7109":"code","9436a342":"code","97633f9a":"code","6f23cbc9":"code","9c87f447":"code","3fa91f3c":"code","1515d730":"code","c4f9e48f":"code","7557611e":"code","b872e692":"code","1595ff0a":"code","eb7de76b":"code","04956f2b":"code","c62205df":"code","542c0519":"code","67a3185e":"code","5b788fb8":"code","3126651d":"code","e07c7c4c":"markdown","08bf4bcd":"markdown","734dafea":"markdown","20dd961f":"markdown","df1bbc77":"markdown","8727d9d5":"markdown","372764d6":"markdown"},"source":{"824e362a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    dataFiles=[]\n    for filename in filenames:\n        dataFiles.append(os.path.join(dirname, filename))\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ba4ed99c":"dataFiles\n","d3b8f50c":"df1=pd.read_csv(dataFiles[0])\ndf2=pd.read_csv(dataFiles[1])\ndf3=pd.read_csv(dataFiles[2])","fd3cb937":"df3.describe()","939da8eb":"df3.head()\n","345ec4d0":"# print(df1.head)\nprint(df1.describe)","b57b55fb":"df1.describe()","7e50b840":"df2.describe()","4231182a":"df2.head()","16da4610":"group=df2['comic'].groupby(df2['hero']).transform('count')\ndf2['NO_OF_Comics'] = group\n# df2=df2.drop(['appeared'],axis=1)\ndf2","3b52a0cc":"df20=df2.groupby(by=\"hero\").count()\nprint(df20.columns)\ndf20=df20.drop(['NO_OF_Comics'],axis=1)\ndf20['hero']=df20.index","0ae897f0":"import seaborn as sns\nimport matplotlib.pyplot as plt","2d619e51":"print(type(df2))\nprint(type(df20))\ndf20.columns","0acddf30":"df20=df20[df20['comic']>800]\ndf20.describe()","91f374ec":"ax=sns.barplot(x = 'comic',\n            y = 'hero',\n            data = df20)\nplt.title('Top Super Heros Of MArvel based on num of apearances in the comics')\nsns.set(rc = {'figure.figsize':(5,5)})\nax.set(xlabel='No OF Comics They appeared in', ylabel='SuperHero')\n ","967b1bdf":"df21=df20[df20['comic']>1000]\n\ndf21","55460718":" \nax=sns.barplot(x = 'hero',y = 'comic',data = df21)\n\n","1847f698":"sns.set_palette(\"hls\", 3)\nsns.set_style(style='white')\n\nax=sns.barplot(x = 'hero',y = 'comic',data = df21)\n\n\nplt.title('Top Super Heros Of MArvel based on num of apearances in the comics')\nax.set(xlabel='No OF Comics They appeared in', ylabel='SuperHero')\nplt.figure(figsize = (3,4))\n\n\n\n# \/for index, row in df21.iterrows():\n#     ax.text(row['comic'],,row['comic'], color='black', ha=\"center\")","913b688c":"pip install pyvis # we use pyvis library to visualise a network","3d183e7c":"from pyvis.network import Network\nnet = Network()","f46a3179":"df3.columns","c336ca18":"group=df3['hero2'].groupby(df3['hero1']).transform('count')\ndf3['edge_length'] = group\n# df31=df3.drop(['NO_OF_Comics'],axis=1)\n# df2=df2.drop(['appeared'],axis=1)\ndf3.columns\ndf3","1f0d7109":"df3=df3.drop_duplicates()\ndf3","9436a342":"hero1=df3[\"hero1\"].tolist()\nhero2=df3[\"hero2\"].tolist()","97633f9a":"s=set(hero1).union(set(hero2))\ns=list(s)\nlen(s)","6f23cbc9":"net.add_nodes(s)","9c87f447":"df3.describe()","3fa91f3c":"df30=df3[:1000]\ndf30","1515d730":"df30=df3[df3[\"edge_length\"]==1]\ndf30.describe()","c4f9e48f":"# marvel_net=Network(height='750px', width='100%', bgcolor='#222222', font_color='white',notebook=True)\n# sources = df30[\"hero1\"]\n# targets = df30[\"hero2\"]\n# weights = df30[\"edge_length\"]\n\n# edge_data = zip(sources, targets, weights)\n\n# for e in edge_data:\n#     src = e[0]\n#     dst = e[1]\n#     w = e[2]\n\n#     marvel_net.add_node(src, src, title=src,color='#3da831')\n#     marvel_net.add_node(dst, dst, title=dst,color='#3155a8')\n#     marvel_net.add_edge(src, dst, value=w)\n\n# neighbor_map = marvel_net.get_adj_list()\n# # marvel_net.enable_physics(True)\n# marvel_net.show_buttons(filter_=['physics'])\n# marvel_net.show(\"marvel_net.html\")","7557611e":"df3","b872e692":"df3","1595ff0a":"list_nodes=list(set(list(df3[\"hero1\"])+list(df3[\"hero2\"])))\nlen(list_nodes)","eb7de76b":"list_nodes.index(\"CAPTAIN AMERICA\")","04956f2b":"list_series=pd.Series(list_nodes)\ndf31=list_series.to_frame(name=\"hero\")\ndf31[\"index\"]=df31.index\n","c62205df":"df31","542c0519":"def convert_nodes(x):\n    i=list_nodes.index(x)\n    return i","67a3185e":"df32=df3[[\"hero1\",\"hero2\"]]\ndf32=df32.applymap(convert_nodes)\ndf32.describe()","5b788fb8":"df32.astype(int)","3126651d":"# Python3 code for printing shortest path between\n# two vertices of unweighted graph\n  \n# utility function to form edge between two vertices\n# source and dest\ndef add_edge(adj, src, dest):\n \n    adj[src].append(dest);\n    adj[dest].append(src);\n  \n\n# of each vertex in array p\n# and its distance from source in array d\ndef BFS(adj, src, dest, v, pred, dist):\n \n    # a queue to maintain queue of vertices whose\n    # adjacency list is to be scanned as per normal\n    # DFS algorithm\n    queue = []\n  \n    # boolean array visited[] which stores the\n    # information whether ith vertex is reached\n    # at least once in the Breadth first search\n    visited = [False for i in range(v)];\n  \n    # initially all vertices are unvisited\n    # so v[i] for all i is false\n    # and as no path is yet constructed\n    # dist[i] for all i set to infinity\n    for i in range(v):\n \n        dist[i] = 1000000\n        pred[i] = -1;\n     \n    # now source is first to be visited and\n    # distance from source to itself should be 0\n    visited[src] = True;\n    dist[src] = 0;\n    queue.append(src);\n  \n    # standard BFS algorithm\n    while (len(queue) != 0):\n        u = queue[0];\n        queue.pop(0);\n        for i in range(len(adj[u])):\n         \n            if (visited[adj[u][i]] == False):\n                visited[adj[u][i]] = True;\n                dist[adj[u][i]] = dist[u] + 1;\n                pred[adj[u][i]] = u;\n                queue.append(adj[u][i]);\n  \n                # We stop BFS when we find\n                # destination.\n                if (adj[u][i] == dest):\n                    return True;\n  \n    return False;\n  \n# utility function to print the shortest distance\n# between source vertex and destination vertex\ndef printShortestDistance(adj, s, dest, v):\n     \n    # predecessor[i] array stores predecessor of\n    # i and distance array stores distance of i\n    # from s\n    pred=[0 for i in range(v)]\n    dist=[0 for i in range(v)];\n  \n    if (BFS(adj, s, dest, v, pred, dist) == False):\n        print(\"Given source and destination are not connected\")\n  \n    # vector path stores the shortest path\n    path = []\n    crawl = dest;\n    crawl = dest;\n    path.append(crawl);\n     \n    while (pred[crawl] != -1):\n        path.append(pred[crawl]);\n        crawl = pred[crawl];\n     \n  \n    # distance from source is in distance array\n    print(\"Shortest path length is : \" + str(dist[dest]), end = '')\n  \n    # printing path from source to destination\n    print(\"\\nPath is : : \")\n    \n    \n     \n    for i in range(len(path)-1, -1, -1):\n        print(path[i], end=' ')\n        print(list_nodes[path[i]])\n         \n# Driver program to test above functions\nif __name__=='__main__':\n     \n    # no. of vertices\n    v =6426 ;\n  \n    # array of vectors is used to store the graph\n    # in the form of an adjacency list\n    adj = [[] for i in range(v)];\n  \n    # Creating graph given in the above diagram.\n    # add_edge function takes adjacency list, source\n    # and destination vertex as argument and forms\n    # an edge between them.\n    for i,j  in zip(df32[\"hero1\"],df32[\"hero2\"]):\n        add_edge(adj,i,j)\n   \n#     s=input(\"Enter the source Charecter\")\n#     d=input(\"Enter the destination Charecter\")\n#     s=list_nodes.index(s)\n#     d=list_nodes.index(d)\n    s=20\n    d=1000\n    printShortestDistance(adj, s, d, v);\n ","e07c7c4c":"# now the above scipt will show the connection of a comic charecter with other marvel charecter , if it is directly linked or , through whihc chaerter are they linked","08bf4bcd":"### Removing Duplicates ","734dafea":"# Visualising Marvel Hero-Hero Relationship\n","20dd961f":"### Making list of nodes to give input","df1bbc77":"# Editing the Plot","8727d9d5":"### Prepring nodes and edges for the graph","372764d6":"# TOP THREE SUPER HEROS BAR PLOT"}}