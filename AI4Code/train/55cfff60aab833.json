{"cell_type":{"cefef0be":"code","5b2abc66":"code","13bec23c":"code","01e1c552":"code","17dad385":"code","75d4e0c2":"code","eab3930f":"code","01e5f5d1":"code","a3863017":"code","770fc68f":"code","b837e5d4":"code","eb223656":"code","e9766a5e":"code","8d305e25":"code","541b167d":"code","8492f114":"code","7fd52e17":"code","cfb4c833":"code","bf2a80db":"code","bb748639":"code","ff978ed6":"code","ab12ca32":"code","7c0115f5":"code","6c7cffc1":"code","eb9a17f0":"code","5eca89e0":"markdown"},"source":{"cefef0be":"#This kernel applies the fastAI libraries to the well-known MNIST dataset.  \n#There are a gazillion other descriptions of what MNIST is so I will not spend time giving an explanation here","5b2abc66":"#standard imports\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nprint(os.listdir(\"..\/input\")) #look for the files we'll be using\n","13bec23c":"#we'll be using fastAI for this project\nfrom fastai import *\nfrom fastai.vision import *","01e1c552":"#load the training data\ndf_train = pd.read_csv('..\/input\/train.csv')\ndf_train['fn'] = df_train.index\ndf_train.head()","17dad385":"#df_train.head() just shows 0's for the pixel values  so let's find a spot where they're not zero\ndf_train.iloc[0,185:193]","75d4e0c2":"class PixelImageItemList(ImageList):\n    def open(self,fn):\n        regex = re.compile(r'\\d+')\n        fn = re.findall(regex,fn)\n        df = self.inner_df[self.inner_df.fn.values == int(fn[0])]\n        df_fn = df[df.fn.values == int(fn[0])]\n        img_pixel = df_fn.drop(labels=['label','fn'],axis=1).values\n        img_pixel = img_pixel.reshape(28,28)\n        img_pixel = np.stack((img_pixel,)*3,axis=-1)\n        return vision.Image(pil2tensor(img_pixel,np.float32).div_(255))","eab3930f":"#reshape each 784 line of ints into 28x28xRGB images using PixelImageItemList.  \n#Random_split will take 20% of the data to use for validation\n#label contains the *value* that the image is supposed to represent\nsrc = (PixelImageItemList.from_df(df_train,'.',cols='fn')\n      .split_by_rand_pct()\n      .label_from_df(cols='label'))","01e5f5d1":"#make sure our src looks like it's of the right shape and that we have both training and validation sets.\nsrc","a3863017":"#Add transforms to the data since people will write numbers larger vs. smaller and at slight differnt angles of rotation\n#do_flip=false means that people *don't* write their numbers backwards!\ntfms = get_transforms(max_rotate=15., max_zoom=1.2, max_lighting=0, max_warp=0, do_flip=False)\ndata = ImageDataBunch.create_from_ll(src, ds_tfms=tfms)","770fc68f":"#hey, now we have images that look like real numbers!\ndata.show_batch(rows=3, figsize=(6,6))","b837e5d4":"#standard resnet model.  Initially we'll leave the model frozen and just train the last couple of layers\nlearn = cnn_learner(data,models.resnet50,metrics=accuracy)","eb223656":"#find the best learning rate (look for a nice steep downards slope)\nlearn.lr_find()\nlearn.recorder.plot()","e9766a5e":"#Now let's do some learning!\n#Weight decay helps avoid overfitting by taking into account the sum of the activation parameters within the \n#loss function, and therefore helps minimize the overall model complexity\nlearn.fit_one_cycle(6,slice(1e-2), wd=.1)","8d305e25":"learn.save('50-stage-1')","541b167d":"#learn.load('50-stage-1')","8492f114":"#OK, now we'll unfreeze and train the whole model\nlearn.unfreeze()\nlearn.lr_find()\nlearn.recorder.plot()","7fd52e17":"learn.fit_one_cycle(9,slice(2e-3,2e-5), wd=.1)","cfb4c833":"#99.6% accuracy is a pretty good result so let's save results and move on.\nlearn.save('50-stage-2')","bf2a80db":"#Out of interest, let's see where our model messed up...\ninterp = ClassificationInterpretation.from_learner(learn)\ninterp.plot_top_losses(9,figsize=(6,6))","bb748639":"#OK, we're done building our model.  Let's run agains the Kaggle test set and see how we do.\n#Load in the test data\ndf_test = pd.read_csv('..\/input\/test.csv')\ndf_test['label'] = 0\ndf_test['fn'] = df_test.index\ndf_test.head()","ff978ed6":"#Run our predictions\nlearn.data.add_test(PixelImageItemList.from_df(df_test, path='.', cols='fn'))\ntest_pred, test_y, test_loss = learn.get_preds(ds_type=DatasetType.Test, with_loss=True)\ntest_result = torch.argmax(test_pred,dim=1)\nresult = test_result.numpy()","ab12ca32":"#Check that the predictions is of the right length and width (e.g. number of posible values)\ntest_pred.shape","7c0115f5":"#Values look OK (e.g. range from 0-0)\nresult","6c7cffc1":"#create a CSV file to submit\nfinal = pd.Series(result,name='Label')\nsubmission = pd.concat([pd.Series(range(1,28001),name='ImageId'),final],axis=1)\nsubmission.to_csv('submission.csv',index=False)","eb9a17f0":"#Cross my fingers and submit1\n!head submission.csv","5eca89e0":"Borrowed this next class from https:\/\/www.kaggle.com\/heye0507\/fastai-1-0-with-customized-itemlist.  Thank you @Dreamdragon.  He has a good description of how it works there, so check that out."}}