{"cell_type":{"221d29fe":"code","078c2603":"code","773433fb":"code","05272ec7":"code","6f4c0a3f":"code","f9e007ae":"code","e0a6aebe":"code","55e4d945":"code","66f275a8":"code","faa2779d":"code","92ad50a2":"code","5d24cc31":"code","cff0caf3":"code","28a90115":"code","50172982":"code","3d81d5b8":"code","0203bee0":"code","ecb24993":"code","877c73fe":"code","6b1eb107":"code","a014d3f9":"code","4de3a5bc":"code","f3f916be":"code","d1bb69c7":"code","b1a83814":"code","b8a68c71":"code","405eaeaa":"code","983114a8":"code","9161fd69":"code","2bd1befb":"code","49f89adf":"code","d72c9bdd":"code","51998ffc":"code","c21a5994":"code","01fca7d2":"code","0726f4f0":"code","32c68d64":"code","88c95827":"code","4337d68e":"code","3d3770df":"code","6f15c68a":"code","38e9d091":"code","b5d5f608":"code","4030691d":"code","eb8f335e":"code","073a1fa9":"code","5ad2210c":"code","9d3d8ee8":"code","995be744":"code","bbea4327":"code","ef48996d":"code","11ba1360":"code","81696d9d":"code","84484e5d":"code","5e398f03":"code","94723418":"code","2ec1ccea":"code","71cf0b40":"code","d51a14f8":"code","c705969b":"markdown","c9aae9c0":"markdown","f44ce9ca":"markdown","6fa48e10":"markdown","9c1b7959":"markdown","95e4e435":"markdown","f26d94eb":"markdown","afddfa9f":"markdown","539e060b":"markdown","18e185fc":"markdown","02fc9d8a":"markdown","72face94":"markdown","7eb0f9c5":"markdown","40ce0ef5":"markdown","647a0093":"markdown","d013a14a":"markdown","6f43a994":"markdown","7f9ed80d":"markdown","88fd34e6":"markdown","56755747":"markdown","6a69908e":"markdown","0eb7f212":"markdown","5ae11923":"markdown","ec6e5b85":"markdown","f163b33c":"markdown","f9112ead":"markdown","88d1c961":"markdown","063b2ae3":"markdown","c49d8529":"markdown","3932536f":"markdown","5fe4fa3d":"markdown","b1149c29":"markdown","4d7672ce":"markdown","556bbe20":"markdown","f936f98e":"markdown","f7eec91b":"markdown","f37ca7c1":"markdown","7345e3e4":"markdown","a7a414c4":"markdown","7493d76b":"markdown","918e9617":"markdown","6e7b995a":"markdown","59f7fb34":"markdown","a1027c49":"markdown","e9b16026":"markdown","9f364303":"markdown","71b0c4e6":"markdown","fa7820ca":"markdown"},"source":{"221d29fe":"# instaling the rdkit for molecule manipulation and visualization\n!conda install -y -c rdkit rdkit","078c2603":"# Installing mordred for molecular descriptors\n\n!conda install -y -c rdkit -y -c mordred-descriptor mordred","773433fb":"! pip install molml","05272ec7":"import os\nimport rdkit\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split, KFold\nfrom sklearn.preprocessing import MinMaxScaler\nfrom rdkit import Chem  # To extract information of the molecules\nfrom rdkit.Chem import Draw  # To draw the molecules\nfrom mordred import Calculator, descriptors  # To calculate descriptors\nfrom molml.features import CoulombMatrix  # To calculate the coulomb matrix\nfrom tensorflow import keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout\nfrom keras.callbacks import ReduceLROnPlateau","6f4c0a3f":"# Checking the number of XYZ files\ndirectory = '\/kaggle\/input\/qm9dataset\/'\nlen(os.listdir(directory))","f9e007ae":"# Reading a file for visualization\nfile = os.listdir(directory)[0]\nwith open(directory+file, 'r') as f:\n    content = f.readlines()\n\nfor line in content:\n    print(line)","e0a6aebe":"smile_example = Chem.MolFromSmiles(content[17 + 3].split()[0])\nsmile_example","55e4d945":"def read_xyz(path):\n    \"\"\"\n    Reads the xyz files in the directory on 'path'\n    Input\n    path: the path to the folder to be read\n    \n    Output\n    atoms: list with the characters representing the atoms of a molecule\n    coordinates: list with the cartesian coordinates of each atom\n    smile: list with the SMILE representation of a molecule\n    prop: list with the scalar properties\n    \"\"\"\n    atoms = []\n    coordinates = []\n\n    with open(path, 'r') as file:\n        lines = file.readlines()\n        n_atoms = int(lines[0])  # the number of atoms\n        smile = lines[n_atoms + 3].split()[0]  # smiles string\n        prop = lines[1].split()[2:]  # scalar properties\n        \n        # to retrieve each atmos and its cartesian coordenates\n        for atom in lines[2:n_atoms + 2]:\n            line = atom.split()\n            # which atom\n            atoms.append(line[0])\n\n            # its coordinate\n            # Some properties have '*^' indicading exponentiation \n            try:\n                coordinates.append(\n                    (float(line[1]),\n                     float(line[2]),\n                     float(line[3]))\n                    )\n            except:\n                coordinates.append(\n                    (float(line[1].replace('*^', 'e')),\n                     float(line[2].replace('*^', 'e')),\n                     float(line[3].replace('*^', 'e')))\n                    )\n                    \n    return atoms, coordinates, smile, prop","66f275a8":"# Reads the xyz files and return the properties, smiles and coordinates\ndata = []\nsmiles = []\nproperties = []\nfor file in os.listdir(directory):\n    path = os.path.join(directory, file)\n    atoms, coordinates, smile, prop = read_xyz(path)\n    data.append((atoms, coordinates)) # A tuple with the atoms and its coordinates \n    smiles.append(smile) # The SMILES representation\n    properties.append(prop) # The molecules properties","faa2779d":"properties_names = ['A', 'B', 'C', 'mu', 'alfa', 'homo', 'lumo', 'gap', 'R\u00b2', 'zpve', 'U0', 'U', 'H', 'G', 'Cv']\ndf = pd.DataFrame(properties, columns = properties_names).astype('float32')\ndf['smiles'] = smiles\ndf.head()","92ad50a2":"# Reading each molecule by its SMILES string\ndf['mol'] = df['smiles'].apply(lambda x: Chem.MolFromSmiles(x))","5d24cc31":"# Checking if there are None values\ndf['mol'].isnull().sum()","cff0caf3":"# Reads and prints the 20 first molecules\nmol = df['mol'][:20]\n\nDraw.MolsToGridImage(mol, molsPerRow=5, useSVG=True, legends=list(df['smiles'][:20].values))","28a90115":"df['mol'][0].GetNumAtoms()","50172982":"data[0]","3d81d5b8":"df['mol'] = df['mol'].apply(lambda x: Chem.AddHs(x))","0203bee0":"# Now checking the number of atoms of the first molecule\ndf['mol'][0].GetNumAtoms()","ecb24993":"df['num_of_atoms'] = df['mol'].apply(lambda x: x.GetNumAtoms())\ndf['num_of_heavy_atoms'] = df['mol'].apply(lambda x: x.GetNumHeavyAtoms())","877c73fe":"df.head()","6b1eb107":"def canonize(mol):\n    return Chem.MolToSmiles(Chem.MolFromSmiles(mol), isomericSmiles=True, canonical=True)\n\ncanon_smile = []\nfor molecule in smiles:\n    canon_smile.append(canonize(molecule))\n    \ndf['canon_smiles'] = canon_smile","a014d3f9":"df.head()","4de3a5bc":"Chem.MolFromSmiles('O=C1OCC1C#N')","f3f916be":"Chem.MolFromSmiles('N#CC1COC1=O')","d1bb69c7":"df['canon_smiles'][df['canon_smiles'].duplicated()]","b1a83814":"df[df['canon_smiles'] == 'COc1cnccn1']","b8a68c71":"Chem.MolFromSmiles('COC1=CN=CC=N1')","405eaeaa":"Chem.MolFromSmiles('COC1=NC=CN=C1')","983114a8":"# Index of the duplicated rows\nind = df.index[df['canon_smiles'].duplicated()]\ndf = df.drop(ind)","9161fd69":"df['mol'] = df['canon_smiles'].apply(lambda x: Chem.MolFromSmiles(x))","2bd1befb":"plt.figure(figsize=(12, 18))\nplot_counter = 1\nfor prop in df.iloc[:,:15].columns:\n    plt.subplot(int(np.ceil(len(df.iloc[:,:15].columns)\/2)), 3, plot_counter)\n    plt.hist(df.iloc[:,:15][prop], edgecolor='k')\n    plt.title(prop)\n    plot_counter += 1\nplt.tight_layout()\nplt.show()","49f89adf":"df.describe()","d72c9bdd":"# Checking for unusual values\ndf[df['A'] > 100]","51998ffc":"df = df.drop([9492, 31832])","c21a5994":"plt.figure(figsize=(12, 18))\nplot_counter = 1\nfor prop in df.iloc[:,:15].columns:\n    plt.subplot(int(np.ceil(len(df.iloc[:,:15].columns)\/2)), 3, plot_counter)\n    plt.hist(df.iloc[:,:15][prop], edgecolor='k')\n    plt.title(prop)\n    plot_counter += 1\nplt.tight_layout()\nplt.show()","01fca7d2":"# Saving the final dataframe\ndf.to_csv('qm9.csv')","0726f4f0":"df['num_of_atoms'].value_counts(sort=False).plot.bar(figsize=(10,6), \n                                                     title=\"Frequency of molecules according to their number of atoms\", \n                                                     xlabel='Number of atoms',\n                                                     ylabel='Absolute frequency',\n                                                     rot=0,\n                                                     edgecolor='k')\nplt.show()","32c68d64":"plt.figure(figsize=(14,20))\nplot_counter = 1\nfor prop in df.iloc[:,:15].columns:\n    plt.subplot(int(np.ceil(len(df.iloc[:,:15].columns)\/2)), 3, plot_counter)\n    plt.scatter(df['num_of_atoms'], df[prop], s=40, alpha=0.5)\n    \n    for atom in np.unique(df['num_of_atoms']):\n        plt.scatter(atom, df[prop][df['num_of_atoms'] == atom].mean(), c='k', label='Mean')\n        \n    # Dictionaries can't have duplicated keys\n    # This prevents repeated legend entries\n    handles, labels = plt.gca().get_legend_handles_labels()\n    by_label = dict(zip(labels, handles))\n    plt.legend(by_label.values(), by_label.keys())\n    \n    plt.title(prop)\n    plot_counter = plot_counter + 1\n    \nplt.suptitle('Number of atoms', x=.5, y=0.35, ha='center', size=16) \nplt.tight_layout()\nplt.show()","88c95827":"df['num_of_heavy_atoms'].value_counts(sort=False).plot.bar(figsize=(10,6), \n                                                     title=\"Frequency of molecules according to their number of atoms\", \n                                                     xlabel='Number of heavy atoms',\n                                                     ylabel='Absolute frequency',\n                                                     rot=0,\n                                                     edgecolor='k')\nplt.show()","4337d68e":"plt.figure(figsize=(14,14))\nplot_counter = 1\nfor prop in df.iloc[:,:15].columns:\n    plt.subplot(int(np.ceil(len(df.iloc[:,:15].columns)\/2)), 3, plot_counter)\n    plt.scatter(df['num_of_heavy_atoms'], df[prop], s=40, alpha=0.5)\n    \n    for atom in np.unique(df['num_of_heavy_atoms']):\n        plt.scatter(atom, df[prop][df['num_of_heavy_atoms'] == atom].mean(), c='k', label='Mean')\n        \n    # Dictionaries can't have duplicated keys\n    # This prevents repeated legend entries\n    handles, labels = plt.gca().get_legend_handles_labels()\n    by_label = dict(zip(labels, handles))\n    plt.legend(by_label.values(), by_label.keys())\n    \n    plt.title(prop)\n    plot_counter = plot_counter + 1\n    \nplt.suptitle('Number of heavy atoms', x=.5, y=0.35, ha='center', size=16) \nplt.tight_layout()\nplt.show()","3d3770df":"# Using only the molecules with 19 atoms\ncalc = Calculator(descriptors, ignore_3D=True)\ndf_desc = calc.pandas(df['mol'][df['num_of_atoms']==19])\n\n# Saving the resulting file \ndf_desc.to_csv('descriptors.csv')","6f15c68a":"df_desc.info()","38e9d091":"df_desc.loc[:, df_desc.dtypes == np.object]","b5d5f608":"df_desc = df_desc.select_dtypes(include=np.number).astype('float32')","4030691d":"# Removing columns with variance = 0\ndf_desc = df_desc.loc[:, df_desc.var() > 0.0]","eb8f335e":"# Normalizing the descriptors\ndf_descN = pd.DataFrame(MinMaxScaler().fit_transform(df_desc), columns = df_desc.columns)","073a1fa9":"# Selecting the initial properties for molecules with only 19 atoms\ndf_19 = df[df['num_of_atoms']==19]","5ad2210c":"df_19.head()","9d3d8ee8":"np.shape(df_descN)","995be744":"# Testing with the \"mu\" (dipole moment) property\nx_train, x_test, y_train, y_test = train_test_split(df_descN, df_19['mu'], \n                                                    test_size=0.2, random_state=42)","bbea4327":"def neural_model(x, y, x_test, y_test, neurons):\n    \"\"\"\n    Neural network model\n    \n    Inputs\n    x: descriptors values for training and validation\n    y: properties values for training and validation\n    x_test: descriptors values for test\n    y_test: properties values for test\n    \n    \n    Outputs\n    model: trained neural network model\n    score: a list with the score values for each fold\n    \"\"\"\n    np.random.seed(1)\n    score = []\n    kfold = KFold(n_splits=5, shuffle=True)\n    \n    model = Sequential()\n    model.add(Dense(neurons, input_dim=x.shape[1], activation='relu'))\n    model.add(Dense(neurons, activation='relu'))\n    model.add(Dense(1, activation='linear'))\n\n    opt = keras.optimizers.Adam(learning_rate=0.001)\n    model.compile(loss='mean_squared_error',\n                  optimizer=opt,\n                  metrics=['mean_absolute_error'])\n\n    rlrop = ReduceLROnPlateau(monitor='val_loss', factor=0.01, patience=10)\n        \n    for train, validation in kfold.split(x, y):\n\n        model.fit(x.iloc[train], y.iloc[train], \n                      epochs=100,\n                      batch_size=128,\n                      callbacks=[rlrop],\n                      verbose=0,\n                      validation_data=(x.iloc[validation], y.iloc[validation]))\n\n        score.append(model.evaluate(x_test, y_test))\n    \n    return model, score","ef48996d":"model, score = neural_model(x_train, y_train, x_test, y_test, neurons=64)","11ba1360":"print(f'mse: {np.mean(score):.3f} \\u00B1 {np.std(score):.3f} ')","81696d9d":"# Selecting the molecules with 19 atoms in the \"data\" object\ndata19 = []\nfor i in range(len(data)):\n    if len(data[i][0]) == 19:\n        data19.append(data[i])","84484e5d":"# Eigenvalues of the coloumb matrix\nfeat = CoulombMatrix(eigen=True, sort=True)\nfeat.fit(data19)\n\ncm = feat.transform(data19)\ndf_cm = pd.DataFrame(cm)\ndf_cm.head()","5e398f03":"np.shape(df_cm)","94723418":"df_cm = pd.DataFrame(MinMaxScaler().fit_transform(df_cm))\ndf_cm.head()","2ec1ccea":"x_train, x_test, y_train, y_test = train_test_split(df_cm, df_19['mu'], \n                                                    test_size=0.2, random_state=42)","71cf0b40":"model2, score2 = neural_model(x_train, y_train, x_test, y_test, neurons=64)","d51a14f8":"print(f'mse: {np.mean(score2):.3f} \\u00B1 {np.std(score2):.3f} ')","c705969b":"The frequency of the molecules according to the number of atoms loosely follows a normal distribution, with molecules containing 17, 18 and 19 atoms being predominant. Each of these cluster could probably be used for further machine learning model benchmark, as an alternative for using the whole dataset. ","c9aae9c0":"### 3. Data wrangling and exploratory data analysis - Ensuring SMILES validity and better understanding the dataset","f44ce9ca":"Now, the property predictions can be done in a very straightforward way. Such task will be performed by a simple mlp network with two hidden layers and the same number of neurons on each layer. The number of neurons can be set when calling the ```neural_model``` function. The k-fold cross validation method, with k=5, will also be used to reduce the chances of overfitting. Lastly, the mean squared error will be evaluated for each fold and its mean will represent the accuracy of the model.","6fa48e10":"### 2. Projects' outline\nThe goal of this project is to use machine learning algorithms to predict molecular properties and thus identify possible relationships between the properties of a molecule and its structure.\nAs such, there are two main steps that need to be performed:\n1. **Ensure SMILES validity**: \"SMILES\" stands for simplified molecular-input line-entry system and they describe the structure of chemical specie using short ASCII strings [4]. A common example of a SMILES representation is the one of the benzene molecule: 'c1ccccc1', where 'c' represents the atom of carbon and the number 1 the beginning and end of a cyclic structure, as can be seen in Figure 1. <br><br>\n**Figure 1** - The benzene molecule\n![236.png](attachment:236.png)\nSome of the most important information of a molecule can be extracted based on its SMILES representation by using a number of different python packages. Thus, it's import to ensure that they are both valid, i.e., contain only valid characters, and unique, meaning that each molecule must have a unique representation. This requires a detailed **data wrangling** process.","9c1b7959":"Now, let's check if there are duplicated canonical SMILES. ","95e4e435":"**3.2.3 What is the distribution of heavy atoms in each molecule?**","f26d94eb":"**3.2 Exploratory data analysis**\n\nThe following question will allow a better understanding of the qm9 dataset properties as a whole.\n1. What are the main clusters according to the atomic number?\n2. How are the properties distributed in these clusters?\n3. What is the distribution of heavy atoms in each molecule?\n4. How are the properties distributed according to the number of heavy atoms?\n5. What molecular descriptors can be used to represent the molecules?\n6. What type of molecular descriptors yelds the best property prediction?","afddfa9f":"# QM9 - Quantum chemistry structures and properties of 134 kilo molecules","539e060b":"Properties' values are indeed the same and drawing the molecules actually helps to understand the reason. The only difference between the molecules are the placements of the nitrogen atoms. Such difference had no impact on the molecules's properties and, as such, they will be dropped from the dataframe.","18e185fc":"First, let's read the entire qm9 dataset.","02fc9d8a":"**3.2.2 How are the properties distributed in these clusters?**","72face94":"Rotational constant A seems to have some outliers, as the maximum value is much greater than the mean. Although rotational constants B and C also seem to also have outliers, values of these properties can [hugely vary](http:\/\/www.colby.edu\/chemistry\/PChem\/scripts\/ABC.html), going from 11 GHz (Rotational constant A) for the ozone molecule, to as high as 816.68 GHz (Rotational constant C) for the water molecule.","7eb0f9c5":"The molecules now have the right number of atomic especies. Thus, the total number of atoms and the total number of heavy atoms can be extracted as follows.","40ce0ef5":"Indeed, the molecules with ID 9492 and 31832 have values for the rotational constant A that are far above the mean value for such property. They will be dropped. As explained above, even though some values of the rotational constants seem to be outliers, they are within a reasonable range of values and, therefore, will be left untoched. ","647a0093":"**3.2.1 What is the frequency of molecules according to their atomic number?**","d013a14a":"There are a huge number of columns which are failed attempts to generate a descriptor. They will be deleted and there rest will be set as float32.","6f43a994":"**Table 1** - XYZ-like file format for molecular structure and properties.\n\n| Line      | Content                                                                           |\n|-----------|-----------------------------------------------------------------------------------|\n| 1         | Number of atoms n                                                                 |\n| 2         | Scalar properties                                                                 |\n| 3,...,n+2 | Element type, coordinate (x, y, z in A), Mulliken partial charges (in e) on atoms |\n| n+3       | Harmonic vibrational frequencies (3n-5 or 3n-6 in cm-1)                           |\n| n+4       | SMILES strings from GDB-17 and from B3LYP relaxation                              |\n| n+5       | InChI string for Corina and B3LYP geometries                                      |","7f9ed80d":"**3.2.5 What molecular descriptors can be used to represent the molecules?**","88fd34e6":"The atoms and its order matchs its SMILES string, except the hidrogen atoms, which were not accounted. One workaround it's just to use the RDKit to count the number of hidrogen atoms and incorporate it in each molecule object as follows.","56755747":"The data wrangling process ends here. It was somehow easier than first expected as the dataset was well structured from the beginning. Further analysis are welcomed to ensure that the python packages employed to read, extract and manipulate the data did in fact work as planned and all the information up until this point is valid and can be used to make properties prediction.","6a69908e":"The overall behavior of the properties when considering only the heavy atoms of a molecule follows, to some extent, the same behavior as seen before. Some properties' values grows with the number of heavy atoms, while some decrease and some appears to remain somewhat constant.","0eb7f212":"Notice that the SMILES representation does not shows the hidrogen atoms, as they are implied by the rest of the molecules. However, counting the number of atoms using RDKit will return the wrong number of atoms. For example, let's consider just the first molecule.","5ae11923":"Surprisingly, all molecules were successfully read by the RDKIT package. As a first approach, this may not represent an issue, but for future developments it would be important to check if this result is solid. Let's now visualize some of the molecules.","ec6e5b85":"There are 133885 XYZ archives, each containing information about a specific molecule.","f163b33c":"The easiest way to check for inconsistencies in the SMILES representation of a molecule is to simply read it using RDKit. Should the representation presents an error, the [RDKIT should be unable to properly read its content](https:\/\/www.rdkit.org\/docs\/GettingStartedInPython.html), therefore returning a None value.","f9112ead":"**3.2.6 What type of molecular descriptors yelds the best property prediction?**","88d1c961":"Now, it is important to create a canonical SMILE representation for each molecule. Finding a canonical ordering of the atoms in a molecule is a prerequisite for generating a unique representation of the molecule [6]. Luckily, the RDKit has a module that does the job in a quite straightforward way. One only needs to read the SMILES representation of the molecule using the module ```Chem.MolFromSmiles```, as done before, and then transform it back again on SMILES representation using the module ```Chem.MolToSmiles```, ensuring that the parameters ```isomericSmiles``` and ```canonical``` are both set to be True.","063b2ae3":"The properties and the SMILES strings will be organized in dataframe. The ```data``` object contains the atoms and its cartesian coordinates for each molecule and they will be later used for the calculations of the coulomb matrix.","c49d8529":"The qm9 dataset is public available and its raw content can be download in [this link](https:\/\/figshare.com\/collections\/Quantum_chemistry_structures_and_properties_of_134_kilo_molecules\/978904).","3932536f":"**Table 2** - Calculated properties. Properties are stored in the order given by the first column.\n\n| No. | Property | Unit      | Description                             |\n|-----|----------|-----------|-----------------------------------------|\n| 1   | tag      | -         | \u2018gdb9\u2019 string to facilitate extraction  |\n| 2   | i        | -         | Consecutive, 1-based integer identifier |\n| 3   | A        | GHz       | Rotational constant                     |\n| 4   | B        | GHz       | Rotational constant                     |\n| 5   | C        | GHz       | Rotational constant                     |\n| 6   | \u03bc        | D         | Dipole moment                           |\n| 7   | \u03b1        | a\u00b3        | Isotropic polarizability                |\n| 8   | homo     | Ha        | Energy of HOMO                          |\n| 9   | lumo     | Ha        | Energy of LUMO                          |\n| 10  | gap      | Ha        | Gap (lumo \u2212 homo)                       |\n| 11  | R\u00b2       | Ha        | Electronic spatial extent               |\n| 12  | zpve     | Ha        | Zero point vibrational energy           |\n| 13  | Uo       | Ha        | Internal energy at 0 K                  |\n| 14  | U        | Ha        | Internal energy at 298.15 K             |\n| 15  | H        | Ha        | Enthalpy at 298.15 K                    |\n| 16  | G        | Ha        | Free energy at 298.15 K                 |\n| 17  | Cv       | cal\/mol K | Heat capacity at 298.15 K               |","5fe4fa3d":"2. **Use a suitable molecule representation**: Machine learning algorithms can speed up the process of identifying molecule's properties or even designing novel molecules with desirable properties [5]. This can have enormous consequences on many fields, such as the development of new materials for batteries and solar panels, or the sinthesis of new and more reliable drugs. However, to achieve such goal it's important to use a molecule representation that capture most of its inate properties and can also be easily fed to a machine learning. There are a number of different representantions and the the most common are shown in Figure 2.\n\n**Figure 2** - Different representations of a molecule\n![Captura%20de%20tela%20de%202020-12-04%2017-58-06.png](attachment:Captura%20de%20tela%20de%202020-12-04%2017-58-06.png)\n\nTwo representations were chosen: **molecule descriptors** and the **coulomb matrix**, each of which will be discussed later.","b1149c29":"There are 87 repeated canonical SMILES. This means that there are different SMILES strings representing the same molecule. To ensure it, let's visualize a few of these molecules and its properties.","4d7672ce":"The diagonal elements can be seen as the interaction of an atom with itself and are essentially a polynomial fit of the atomic energies to the nuclear charge $Z_{i}$. The off-diagonal elements represent the Coulomb repulsion between nuclei $i$ and $j$. Using the package ```molml```, it's quite straightforward to retrieve such descriptor. However, instead of using the whole Coloumb Matrix, only the eigenvalues will be retrieved.","556bbe20":"As a final step in the data wrangling process, properties outliers will be evaluated.","f936f98e":"Now, a new mol object will be created taking into account the canonical SMILES representation, as a way to ensure that subsequent procedures will be performed using a correct and unique representation. ","f7eec91b":"**3.2.4 How are the properties distributed according to the number of heavy atoms?**","f37ca7c1":"# Refer\u00eancias\n\n[1] R. Ramakrishnan, P. O. Dral, M. Rupp, O. A. von Lilienfeld, Quantum chemistry structures and properties of 134 kilo molecules, *Scientific Data 1*, 140022, 2014.<br>\n[2] Gilmer, J., et al. Neural message passing for quantum chemistry. *ICML17: Proceedings of the 34th International Conference on Machine Learning*, 70, 1263\u20131272, 2017.<br>\n[3] Chen, C., et al. Graph Networks as a Universal Machine Learning Framework for Molecules and Crystals. *Chemistry of Materials*, 31, 3564-3572, 2019.<br>\n[4] https:\/\/en.wikipedia.org\/wiki\/Simplified_molecular-input_line-entry_system<br>\n[5] Lengeling, B. S.; Guzik, A. A. Inverse molecular design using machine learning: Generative models for matter engineering. *Science*, 361, 360 - 365, 2018.<br>\n[6] Schneider, N.; Sayle, R. A.; Landrum, A. Get Your Atoms in Order\u2014An Open-Source Implementation of a Novel and Robust Molecular Canonicalization Algorithm. *Journal of Chemical Information and Modeling*, 55, 2111-2120, 2015.<br>\n[7] Chandrasekaran, B., et al. Computer-Aided Prediction of Pharmacokinetic (ADMET) Properties. *Dosage From Design Parameters - Volume II*. Advances in Pharmaceutical Product Development and Research, 731-755, 2018. <br>\n[8] Pinheiro, G. A. Machine Learning Prediction of Nine Molecular Properties Based on\nthe SMILES Representation of the QM9 Quantum-Chemistry Dataset. *The Journal of Physical Chemistry A*, 124 (47), 9854-9866, 2020. <br>\n[9] Rupp, M., et al. Fast and Accurate Modeling of Molecular Atomization Energies with Machine Learning. *PHYSICAL REVIEW LETTERS*, 108, 2012.","7345e3e4":"### 1. Description of the dataset\nThe qm9 dataset holds information on the energetic, electronic and thermodynamic properties of 134 kilo molecules composed of carbon, hidrogen, oxigen, nitrogen and phosphorus atoms [1]. Information on the atomic cartesian coordinates for each molecule is also presented and they are all stored in a plain text format known as XYZ. Such dataset is often used for training and test of machine learning models, specially those who seek to identify relationships between the structure and the properties of a molecule [2,3]. More information of the qm9 content can be seen on tables 1 and 2.","a7a414c4":"As a first approach, this result is reasonable and can be comparable with values achieved in other works [8]. To evaluate the property predictions using other approach, the Coloumb Matrix will be calculated next. The Coulomb Matrix is a simple global descriptor which mimics the electrostatic interaction between nuclei [9]. It is calculated with the equation below.\n\n\\begin{equation}\n  M_{ij} =\n    \\begin{cases}\n      0.5Z_{i}^{2.4} ~ ~ ~\\text{for i=j}\\\\\n      \\frac{Z_{i}Z_{j}}{R_{ij}} ~ ~ ~\\text{for i} \\neq \\text{j}\\\\\n    \\end{cases}       \n\\end{equation}","7493d76b":"It is possible to note small changes on the SMILES ordering for some molecules. Now, it's important to look for duplicates in the canonical SMILES representation. The standard SMILES representations allows for different representations of the same molecule depending on the chosed starting atom. For example, let's take a look into a molecule with a rather easy representation.  ","918e9617":"Molecule descriptors can be thought of as a mathematical representations of molecules' properties that are generated by algorithms. The numerical values of such descriptors are used to quantitatively describe the physical and chemical information of the molecules [7]. They can be divided as experimental measurements and theoretical molecular descriptors, which are derived from a symbolic representation of the molecule. Hence the importance to ensure SMILES valid and uniqueness. In this sense, the properties of the molecules from the qm9 dataset can be seen as descriptors. Thus, we will be using properties calculated from the SMILES strings to predict known properties of the qm9 molecules. However, due to memory issues, only the molecules with 19 atoms will be considered at first for the descriptors calculation.","6e7b995a":"There are some very interesting results:\n* zpve ([zero-point vibrational energy](https:\/\/www.britannica.com\/science\/zero-point-energy)): It represents the lowest possible energy a quantum system may have. Thus, it makes sense that the more atoms a molecule has, the more its vibrational energy would be. However, it's interesting to note that the relationship between this property and the number of atoms is almost linear.\n* Cv ([heat capacity](https:\/\/www.britannica.com\/science\/heat-capacity) at 298.15 K): It's the amount of heat per unit mass that is required to raise the temperature by 1\u00b0C. Its value also grows with the number of atoms in a molecule in almost a linear fashion.\n* Uo, U, H and G (internal energy at 0 K, internal energy at 298.15 K, enthalpy at 298.15 K, free energy at 298.15 K): They all follow the same behavior and visually, it could be argue that their values are virtually the same, as can also be seen on the histogram presented earlier.\n\nIt's also important to note two things. First, the variance of the properties seems to decrease the more atoms a molecule has. This could result in better properties predictions. However, this can be a simple consequence of the fact that molecules with 20 atoms or more are far more rare in the dataset. Second, using molecules with only a specific number of atoms might not be representative when using machine learning algorithms for property predictions, as the values of some properties can greatly vary with the total number of atoms. ","59f7fb34":"The majority of molecules have 9 heavy atoms in its composition. If later analysis prove to be problematic due to atoms with lower number of heavy atoms, it might be safe to just exclude such molecules.","a1027c49":"Using the same parameters set for the previous calculations, it's evident that using the molecules descriptors, other than the Coloumb Matrix, the results are considerably better. Perhaps it's just a matter of the sheer number of descriptors, 1069, in comparison with the 19 eigenvalues extracted from the Coloumb Matrix. This greater dimensionality may allow the neural network to learn better relationship between the descriptors and the desired properties, thus yeilding better predictions.","e9b16026":"Information about what each row represents can be seen in Table 1. To further reach the goal of this project, not all information of the XYZ files is needed. Only the scalar properties, the atoms and its cartesian coordenates and the SMILES representation will be extracted. Using RDKit, it is easy to graph a molecule by its SMILES string, as can be seeing below.","9f364303":"It returns 9, which is the exact number of molecules seeing in its SMILES representation: OC1CCCC(=O)C1=O, where the number 1 represents the beginning and the end of rind bound structures. However, the total number of atoms in this molecule is 17, as can be seen in the \"data\" object that contains the atoms of a molecule and its coordinates. ","71b0c4e6":"From its SMILES representation, O=C1OCC1C#N, it's possible to infer that the atom of oxygen with two bonds (O=) at the bottom of the image was the starting point. The edges of the graph represents an atom of carbon unless it is specified otherwise. The next atom is, therefore, an atom of carbon, forming the sequence O=C. The counting then goes left to the next oxygen atom, followed by the carbon atom at the top and the carbon at the right edge of square graph. Finally, the last carbon is bounded with the nitrogen atom, forming the SMILES representation O=COCCC#N, where the symbol # represents a triple bound between two atoms. The only missing symbol is the number 1. The numbers on a SMILES string represents a ring structure. Thus, the ring structure starts at the first counted carbon atom (O=C1) and finishes in the carbon at the right edge of the square graph, which produces the O=C1OCC1C#N SMILES.<br>\nNow, one can set the starting point on each and every atom of this molecule and still get a valid representation. Starting at the nitrogen atom, an analogous SMILES would be N#CC1COC1=O, as can be seem below. The molecule is still the same, just flipped 90 degrees horizontally.","fa7820ca":"**3.1 - Data wrangling**\n\n\nHere, the qm9 dataset will be further explored to ensure not only the SMILES validity, but also to better describe and understand the properties and features of each molecule. The first step is to install the required libraries:\n* **RDKit** - The RDKit is a collection of cheminformatics and machine-learning software written in C++ and Python which is mainly used for extracting informations of a molecule based on its SMILES representation;\n* **mordred** - It's a molecule descriptor calculator. The mordred can be used to calculated 1613 descriptors. A molecule descriptor can ultimately be viewed as a numerical representation of molecules' properties that are generated by algorithms. Thus, they can be used as input in a machine learning model.\n* **molml** - A [library](https:\/\/pypi.org\/project\/molml\/) to interface molecules and machine learning. The goal of this library is to be a simple way to convert molecules into a vector representation for later use with libraries such as scikit-learn."}}