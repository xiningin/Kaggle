{"cell_type":{"42c3b3cb":"code","91f135f6":"code","1415a2aa":"code","1a17a86b":"code","08526446":"code","52bb6352":"code","1a25f1ea":"code","5d3e7592":"code","b31877e9":"code","355063a1":"code","33652d18":"code","12a6715c":"code","eaad0b37":"code","473aacff":"code","6d2376e1":"code","b25717b3":"code","6d8854f5":"code","f9e911b8":"code","781864ee":"code","ca7c1850":"code","ac5cc788":"code","17b3bf18":"code","490757b2":"code","54d1ee3a":"code","a66190c2":"code","1bcc49ef":"code","9e6d7ec9":"code","4abe1f60":"code","85b7e91e":"code","43a2705a":"code","2400b615":"code","1652ce54":"code","93150384":"code","d6f524ca":"code","e754ff63":"markdown","3a0d18ac":"markdown","905bf7bf":"markdown","ca225c73":"markdown","5bbe339a":"markdown","1b3f6c83":"markdown","f2dea420":"markdown","c3463fc2":"markdown","4ca5a0a1":"markdown","cefea0de":"markdown","0e914a8f":"markdown","698f7d19":"markdown","b78396db":"markdown","172c4442":"markdown","dfb2024a":"markdown","6cfc4155":"markdown","e298407d":"markdown","f2ac2a3e":"markdown","b61ec68c":"markdown","900e7889":"markdown","8320ab00":"markdown","05dbef21":"markdown","99a9fc56":"markdown","73976f01":"markdown","3db67bce":"markdown","45d5d668":"markdown","205c2900":"markdown","70a484eb":"markdown","af0c14f9":"markdown","368e5fb4":"markdown","256f1e57":"markdown","0764c921":"markdown","9a472369":"markdown","b2d8996c":"markdown","40eff700":"markdown","8c0fd02f":"markdown","53acaa0b":"markdown","503e613b":"markdown","990b48b9":"markdown","da6d22a0":"markdown","5e7a6ce6":"markdown","47e6c5d7":"markdown","25309060":"markdown","46db6941":"markdown","513ac19d":"markdown","55fafa38":"markdown","196d31a2":"markdown","f0027f5c":"markdown","6a571019":"markdown","2f40966f":"markdown","b0f456b5":"markdown","d202433b":"markdown","9241990c":"markdown","f3c0533b":"markdown","91c470ed":"markdown","7533301a":"markdown","2d51439f":"markdown"},"source":{"42c3b3cb":"from sklearn.ensemble import RandomForestClassifier\nimport pandas as pd","91f135f6":"# Alguns computadores precisam disso para mostrar os gr\u00e1ficos\n%matplotlib inline","1415a2aa":"df = pd.read_csv('..\/input\/train.csv')","1a17a86b":"kaggle_sub = pd.read_csv('..\/input\/test.csv')  # Optei por usar o nome de vari\u00e1vel kaggle_sub, para diferenciar de outra vari\u00e1vel chamada test que criei mais a frente","08526446":"df.shape","52bb6352":"df = df.append(kaggle_sub, sort=False)  # O sort=False, serve para retirar um Warning do pandas","1a25f1ea":"df.shape","5d3e7592":"#df['Surname'] = df['Name'].str.split(',').str[0]","b31877e9":"#df['Title'] = df['Name'].str.split(',').str[1].str.split().str[0]  ","355063a1":"df['Cabin'][27:32]","33652d18":"#df['Cabin Len'] = df.Cabin.str.split().str.len()","12a6715c":"#df['Cabin Letter'] = df['Cabin'].str[0]","eaad0b37":"#df['Family_Size'] = df['SibSp'] + df['Parch']","473aacff":"df[df['Name'].str.contains('Andersson,')]","6d2376e1":"#df['Fare Per Person'] = df['Fare'] \/ (df['Family_Size'] + 1)","b25717b3":"#df['Number of Ticket Uses'] = df.groupby('Ticket', as_index=False)['Ticket'].transform(lambda s: s.count())","6d8854f5":"#df['Average Fare per Person'] = df['Fare'] \/ df['Number of Ticket Uses'] ","f9e911b8":"for col in df.columns:  # Loop usado para avaliar todas as colunas\n    if df[col].dtype == 'object':  # No pandas, 'object' \u00e9 usado para tudo que n\u00e3o \u00e9 datetime ou n\u00famero, e em 99.9% dos usos de caso mais comuns vai ser relativo a texto.\n        df[col] = df[col].astype('category')  # Transforma texto em categoria\n        df[col] = df[col].cat.codes  # Salva apenas os n\u00fameros que correspondiam aos c\u00f3digos de cada categoria","781864ee":"df.fillna(-1, inplace=True)","ca7c1850":"kaggle_sub = df.iloc[891:].copy()\ndf = df.iloc[:891].copy()","ac5cc788":"from sklearn.model_selection import train_test_split","17b3bf18":"train, test = train_test_split(df, test_size=0.2, random_state=42)","490757b2":"rf = RandomForestClassifier(n_estimators=100, min_samples_leaf=2, max_features=.5, random_state=42)","54d1ee3a":"remove = ['Survived', 'PassengerId', 'Name']   # Optei por retiras as colunas PassengerId e Name porque n\u00e3o h\u00e1 motivo para elas terem fator preditivo\nfeats = [col for col in df.columns if col not in remove]  # Crio a lista de colunas que ser\u00e3o usadas","a66190c2":"rf.fit(train[feats], train['Survived'])","1bcc49ef":"preds_train = rf.predict(train[feats])","9e6d7ec9":"preds = rf.predict(test[feats])","4abe1f60":"from sklearn.metrics import accuracy_score","85b7e91e":"accuracy_score(train['Survived'], preds_train)","43a2705a":"accuracy_score(test['Survived'], preds)","2400b615":"rf = RandomForestClassifier(n_estimators=100, min_samples_leaf=3, max_features=.5, random_state=42)","1652ce54":"rf.fit(df[feats],df['Survived'])","93150384":"preds_kaggle = rf.predict(kaggle_sub[feats])","d6f524ca":"submission = pd.DataFrame({ 'PassengerId': kaggle_sub['PassengerId'],\n                            'Survived': preds_kaggle }, dtype=int)\nsubmission.to_csv(\"submission.csv\",index=False)","e754ff63":"Vamos voltar os dados para os duas vari\u00e1veis originais, `df` e `kaggle_sub`:","3a0d18ac":"O test.csv cont\u00e9m apenas as colunas que iremos usar para fazer as previs\u00f5es. **N\u00e3o** cont\u00e9m a resposta de quem sobreviveu ou n\u00e3o, quem tem essa resposta \u00e9 o Kaggle.\n\nPor esse motivo chamaremos esse arquivo de `kaggle_sub`, j\u00e1 que o conjunto de dados que ser\u00e1 submetido ao Kaggle.\n\nA \u00fanica fun\u00e7\u00e3o desses dados \u00e9 servir de insumo para fazermos as previs\u00f5es que ser\u00e3o enviadas ao Kaggle (que \u00e9 a \u00faltima parte deste caderno).","905bf7bf":"Basta dividimos o pre\u00e7o do Ticket, que \u00e9 a coluna `fare`, pela coluna `Number of Ticket Uses`:","ca225c73":"### Avaliando o Desempenho do Modelo","5bbe339a":"Temos 891 linhas e 12 colunas:","1b3f6c83":"Podemos verificar o tamanho do novo objeto `df`:","f2dea420":"### Selecionando as Colunas que Ser\u00e3o Analisadas","c3463fc2":"Uma forma mais robusta de calcularmos o pre\u00e7o do Ticket individual, \u00e9 calculando quantas pessoas usaram um mesmo Ticket, e depois fazer o pre\u00e7o do Ticket dividido pelo n\u00famero de pessoas.\n\nPara isso vamos criar uma nova coluna que contabilize quantas pessoas usaram um mesmo ticket:","4ca5a0a1":"Outra poss\u00edvel an\u00e1lise \u00e9 saber qual a letra da cabine. Cada letra correspondia a uma regi\u00e3o no navio, o que pode ter sido de grande import\u00e2ncia para as probabilidades de sobreviv\u00eancia.","cefea0de":"Uma hip\u00f3tese \u00e9 que pessoas com certos sobrenomes tenham sido favorecidas ou desfavorecidas no processo de sele\u00e7\u00e3o de sobreviventes, j\u00e1 que isso pode conter uma s\u00e9rie de informa\u00e7\u00f5es sociais e econ\u00f4micas sobre essas pessoas.","0e914a8f":"Treino o modelo com todos os dados do `df`:","698f7d19":"## Lendo os arquivos train.csv e test.csv:","b78396db":"### Criando o RandomForestClassifier","172c4442":"Avalio o desempenho do treino:","dfb2024a":"### Treinando o Modelo","6cfc4155":"A coluna `Fare` n\u00e3o nos diz em m\u00e9dia quanto cada pessoa pagou pelo ticket, apenas quanto custou aquele ticket no total, independentemente se 1 ou 10 pessoas usaram ele.\n\nE como uma pessoa que paga 30 por um ticket provavelmente tem um poder aquisitivo maior do que uma fam\u00edlia de 6 pessoas que paga 30 por um ticket (equivale a um custo de 5 por pessoa), isso pode acabar sendo relevante para o nosso modelo.\n\n\u00c9 poss\u00edvel fazermos uma aproxima\u00e7\u00e3o calculadando o `Fare` dividido pelo `Family_Size` (coluna constru\u00edda artificialmente por n\u00f3s)","e298407d":"Este passo \u00e9 importante para podermos fazer a codifi\u00e7\u00e3o de texto para n\u00fameros e mantermos os mesmos c\u00f3digos identificadores para os dois conjuntos de dados (`df` e `kaggle_sub`):\n\n","f2ac2a3e":"Fa\u00e7o as previs\u00f5es do conjunto `test`:","b61ec68c":"Vamos importar o `train_test_split` do `sklearn` para podermos dividir o nosso `df` em treino e teste:","900e7889":"Importo o `accuracy_score` para avaliarmos o desempenho do nosso modelo:","8320ab00":"Crio as previs\u00f5es no conjunto de dados `kaggle_sub`:","05dbef21":"Crio um arquivo chamado `Submission.csv` com as submiss\u00f5es para serem enviadas ao Kaggle.","99a9fc56":"## Juntando os nossos 2 arquivos em um \u00fanico DataFrame","73976f01":"### Ticket por Membro da Fam\u00edlia","3db67bce":"Vamos dividir o nosso `df` em treino e teste, usando 20% (0.2) dos dados para teste, e setando um estado aleat\u00f3rio fixo para podermos replicar os resultados em outras itera\u00e7\u00f5es:","45d5d668":"### T\u00edtulos:","205c2900":"### Tamanho da Fam\u00edlia","70a484eb":"Alguns nomes possuem algum tipo de t\u00edtulo junto, como `Rev`, `Mr`, `Master`. Existe uma hip\u00f3tese de que pessoas com t\u00edtulos de nobreza tenham uma maior chance de sobreviver. Para isso podemos usar o comando abaixo para manipular o texto e separar apenas o t\u00edtulo:","af0c14f9":"Fa\u00e7o as previs\u00f5es do conjunto `traina`:","368e5fb4":"Tirei algumas ideias de features deste site:\n    \nhttps:\/\/triangleinequality.wordpress.com\/2013\/09\/08\/basic-feature-engineering-with-the-titanic-data\/ ","256f1e57":"### Calculando Custo M\u00e9dio por Ticket","0764c921":"### Cabines:","9a472369":"Se observarmos abaixo as pessoas do mesmo sobrenome, no caso `Andersson`, veremos que tem v\u00e1rias pessoas pessoas com o mesmo ticket, e o mesmo pre\u00e7o pago pelo ticket (que \u00e9 a coluna `Fare`).","b2d8996c":"Verificando o tamanho do `df`:","40eff700":"Abaixo seguem algumas possibilidades de colunas novas a serem criadas a partir do conjunto original de dados.\n\nOptei por deixar o c\u00f3digo desta parte todo comentado, porque o ideal seja que isso seja executado em um segundo passo da an\u00e1lise, logo ap\u00f3s ter um modelo funcionando para poder comparar se as novas colunas de fato melhoram o desempenho.\n\nSe for a primeira vez rodando o c\u00f3digo, pode pular at\u00e9 chegar em **Pr\u00e9-processamento de Dados**.","8c0fd02f":"Temos 1309 linhas e as mesmas 12 colunas que t\u00ednhamos anteriormente. O nosso agrupamento de `DataFrames` deu certo!","53acaa0b":"## Criando Novas Colunas (Feature Engineering) \n## *(V\u00e1 direto para Pr\u00e9-Processamento de Dados caso esse seja o primeiro contato com o caderno)*","503e613b":"## Pr\u00e9-processamento de Dados","990b48b9":"Vamos substituir os valores em branco por `-1` (com RandomForest funciona bem substituir os valores em branco por um valor menor que a m\u00ednima ou maior que a m\u00e1xima dos seus dados):","da6d22a0":"Vamos criar o nosso objeto de `RandomForestClassifier`: (note que nesse caso se trata de uma Classifica\u00e7\u00e3o para dizer se a pessoa sobreviveu ou n\u00e3o, por isso o uso do Classifier em vez do Regressor que foi utilizado pelo Jeremy no fastai)","5e7a6ce6":"### Sobrenomes:","47e6c5d7":"# Criando o Arquivo de Submiss\u00e3o ao Kaggle","25309060":"Vamos selecionar as colunas as quais vamos alimentar o nosso modelo:","46db6941":"### Criando os Conjuntos de Treino e Teste","513ac19d":"Vamos imprimir as linhas 27 a 31 do DataFrame em rela\u00e7\u00e3o a coluna `Cabin`:","55fafa38":"Como podemos ver acima, temos 2 tipos diferentes de linhas, a linha 27 que cont\u00e9m 3 cabines, e a linha 31 que cont\u00e9m 1 cabine. A vari\u00e1vel a seguir serve para criar uma nova vari\u00e1vel com a contagem do total de cabines a fim de avaliar se isso tem alguma relev\u00e2ncia:","196d31a2":"Segundo o site do Kaggle, a coluna `SibSp` corresponde a quantidade de irm\u00e3os ou esposos a bordo, e a coluna `Parch` corresponde a quantidade de pais e filhos a bordo. Tudo isso em rela\u00e7\u00e3o a pessoa a qual corresponde a linha.\n\nUma hip\u00f3tese \u00e9 o tamanho da fam\u00edlia influencia nas chances de sobreviv\u00eancia porque pode fazer com que uma pessoa v\u00e1 atr\u00e1s de outras pessoas, ou que um grupo de pessoas consiga exercer press\u00e3o para priorizar o salvamento de uma crian\u00e7a ou mulher da fam\u00edlia.\n\nMesmo sem criar uma nova coluna, essa informa\u00e7\u00e3o j\u00e1 est\u00e1 dispon\u00edvel por meio das colunas `SibSp` e `Parch`,  mas \u00e9 poss\u00edvel que o nosso modelo encontra formas mais f\u00e1ceis de generalizar com uma coluna contendo a soma de `SibSp` e `Parch`, que \u00e9 o teste que iremos fazer.","f0027f5c":"Avalio o desempenho do teste:","6a571019":"### Fazendo as previs\u00f5es do Modelo:","2f40966f":"### Calculando Quantas Pessoas Usam um Mesmo Ticket","b0f456b5":"### Restaurando os DataFrames Originais","d202433b":"Crio uma nova RandomForest para alimentar com os dados de treino e teste, para fazer previs\u00f5es no `kaggle_sub` e em seguida enviar ao Kaggle.","9241990c":"## Preparando o MatPlotLib","f3c0533b":"## Fazendo as importa\u00e7\u00f5es necess\u00e1rias","91c470ed":"Primeiro, vamos transformas as colunas que s\u00e3o texto em n\u00famero:","7533301a":"O train.csv cont\u00e9m as colunas que iremos usar para fazer as previs\u00f5es, e tamb\u00e9m a resposta de quem sobreviveu ou n\u00e3o.","2d51439f":"Treino o `RandomForestClassifier`:"}}