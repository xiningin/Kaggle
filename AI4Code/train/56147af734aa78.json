{"cell_type":{"e86ae95b":"code","55a31cfa":"code","b0e36239":"code","cad78c97":"code","d01f51ee":"code","f3820682":"code","0a2ad11e":"code","8b92be6b":"code","bdcb690e":"code","ac862652":"code","c0b7765b":"markdown","e745365e":"markdown","e38d8a4a":"markdown"},"source":{"e86ae95b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","55a31cfa":"!pip install qiskit","b0e36239":"# creating the necessary imports\n\nimport numpy as np\nfrom qiskit import *\nfrom qiskit.circuit import Parameter\nfrom math import radians","cad78c97":"\n# Defining the ideal circuit to generate Bell State: |01> + |10>\n\ntheta = Parameter('param1')\n\nqc = QuantumCircuit(2, 2)\nstate1 = [1,0]\nstate2 = [0,1]\nqc.initialize(state1, 0)\nqc.initialize(state2, 1)\nqc.barrier()\nqc.ry(theta, 0)\nqc.barrier()\nqc.cx(0, 1)\nqc.barrier()\nqc.measure(0, 0)\nqc.measure(1, 1)","d01f51ee":"# drawing the circuit\nqc.draw()","f3820682":"\n# defining the function to execute the given number of shots on quantum simulator \n\ndef execute_circuit(angle,shots):\n    '''\n        Parameters: angle - the initial random angle given as input\n                    shots - number of shots to be executed on simulator\n        Returns   : dictionary of possible states after execution with their respective counts\n    '''\n    rad = radians(angle) # conversion to degrees\n    job = execute(qc, backend = Aer.get_backend('qasm_simulator'),shots = shots , parameter_binds=[{theta: rad}])\n    counts = job.result().get_counts()\n    return counts","0a2ad11e":"\ndef costfunction(prob_avg_01,prob_avg_10):\n    '''\n         Parameters: prob_avg_01 - average probability of getting the state 01 on measurement\n                     prob_avg_10 - average probability of getting the state 10 on measurement\n         Returns   : Mean Squared Error of the probabilities as a value to be improved with optimization techniques\n    '''\n    return pow((prob_avg_01 - prob_avg_10),2)","8b92be6b":"def costfunction_NAG(prob_avg_01,prob_avg_10,gama,V_t):\n    '''\n         Parameters: prob_avg_01 - average probability of getting the state 01 on measurement\n                     prob_avg_10 - average probability of getting the state 10 on measurement\n                     gama        - constant value parameter for Nesterov Accelerated Gradient\n                     V_t         - using \u03b3V(t\u22121) in cost function for modifying the weights so that \u03b8\u2212\u03b3V(t\u22121) tells us the future location\n         Returns   : Mean Squared Error of the probabilities as a value to be improved with optimization techniques\n    '''\n    return pow((prob_avg_01 - prob_avg_10 - gama*V_t),2)","bdcb690e":"init_angle = 120        # in degrees\nno_of_shots = [1,10,100,1000]\nlearn_rates = [0.03,0.19,0.9,2]   # increasing learn rates for lesser time for convergence to optimum\n\nfor i in no_of_shots:\n    print(\"Measurement counts for initial angle: \",str(init_angle),\" and shots: \",str(i),\"\\t\",str(execute_circuit(init_angle,i)))","ac862652":"# classical gradient descent optimization step: \u03b8=\u03b8\u2212\u03b1\u22c5\u2207J(\u03b8)\n#-----------------------------------------------\n# learning_rate = 0.00001\nmax_i = 1000\ninit_angle = 120\n\nfor k,shots in enumerate(no_of_shots):\n    learning_rate = learn_rates[k]\n    angle = init_angle\n    for i in range(max_i):\n        counts = execute_circuit(angle,shots)\n    \n        try:\n            prob_avg_01 = counts['01']\/shots\n        \n        except:\n            prob_avg_01 = 0\n    \n        try:\n            prob_avg_10 = counts['10']\/shots\n        except:\n            prob_avg_10 = 0\n         \n        angle = angle - learning_rate*(costfunction(prob_avg_01,prob_avg_10))\n    print(\"Optimized parameter 'angle' in degrees: \",str(angle),\" ; initial parameters, angle:\",str(init_angle),\" and shots: \",str(shots),\"\\t\",\"Resultant state counts: \",str(counts))","c0b7765b":"### Custom NAG Optimizer gives us the bell states :)","e745365e":"### If you like the notebook, do put in an Upvote \u2b50\n### Open to discussions on the work!","e38d8a4a":"# This notebook implements the famous Quantum Bell State \ud83d\udcab\n## using qiskit, IBM's quantum computing framework and a custom optimizer"}}