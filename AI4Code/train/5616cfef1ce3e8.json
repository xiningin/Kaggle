{"cell_type":{"f5351d84":"code","dbaeafe9":"code","6bdbd910":"code","a7fb52f5":"code","98181315":"code","32a6f4cb":"code","55fc199d":"code","aa51af5c":"code","a31e0474":"code","fe389555":"code","c39d45ea":"code","16fd7506":"code","988bed6b":"code","f0524670":"code","7824247e":"code","c784ff50":"code","2279fb9a":"code","c3937c34":"code","4bdfae01":"code","fd46b664":"code","f6be67e6":"code","0491a35b":"code","dda18e42":"code","741419a2":"code","373a3d3b":"code","d1b1dcee":"code","be51bbd5":"code","842de100":"code","5594b016":"code","acd2a6f5":"code","57e7418d":"code","af70ab99":"code","40e7b882":"code","86f9ab4b":"code","7056fb70":"code","43d9f6e0":"code","08369e7c":"code","e4d3a630":"code","c4df90e3":"code","29a10316":"code","2df5f337":"code","d01a8a99":"code","e3eecc89":"code","06862197":"code","c329e0a1":"code","ddbb8876":"code","f35e2558":"code","d94ef712":"code","0666bd9b":"code","5ea114db":"code","03d3ea4e":"code","79350f12":"code","08c9bfcc":"code","0e5f2692":"code","a0cf715f":"code","48eb6f84":"code","14ecf43d":"code","6b190880":"code","34cc64c5":"code","b08a8ab4":"code","c1dc4e6e":"code","e446c99e":"code","d310fae3":"code","c17e5a0c":"code","039b3224":"code","77fea9b1":"code","b4e2a0bd":"code","8040d0a5":"code","af59ce7a":"code","c51a61c0":"code","822b94b8":"code","c66fc7b7":"code","3e0ec15d":"code","9950d6fb":"code","eef055b8":"code","bcfd3719":"code","30da81ba":"code","dd435d63":"code","0d7577b0":"code","dba54317":"code","f88e187e":"code","63d05239":"code","070a0f57":"code","04f30a63":"code","063e53fc":"code","048f6318":"code","00b678ff":"code","57a00d27":"code","06f701a1":"code","648ebad6":"code","d3d3ec3e":"code","a6e6273d":"code","3572d709":"code","e3862786":"code","f9ad1daa":"code","47a4a565":"code","383e1776":"code","0f55ad06":"code","1399ac42":"code","6321c2fc":"code","e2d35b81":"code","054e8346":"code","86c652ff":"code","62964d45":"code","5cb7b07a":"code","aad2672a":"code","64c068d1":"code","734fd903":"code","771be43d":"code","16e8e2d4":"code","42d3d1b8":"code","f1d741c3":"code","599aa415":"code","29b6065d":"code","ba049c4b":"code","5f900b0d":"code","b5b94e4a":"code","f629e105":"code","c28c1c15":"code","a45cce09":"code","60d90746":"code","253d7a66":"code","59d82171":"code","97ff588e":"code","863fba31":"code","0abf118d":"code","c85e7626":"code","235fad16":"code","b20485e7":"code","e8892ad2":"code","4f1ac5fd":"code","d006e1dc":"code","04bb1526":"code","9ba70244":"code","b763355f":"code","e898585d":"code","f0612a9b":"code","7a2d7a5d":"code","f529e2c5":"code","5738f30a":"code","5e34e441":"markdown","4008382c":"markdown","32c6af98":"markdown","50e2062c":"markdown","42589508":"markdown","8023e092":"markdown","e3589abb":"markdown","b3bbc67b":"markdown","489be431":"markdown","7119da7d":"markdown","a7a44975":"markdown","c665026b":"markdown","e7662800":"markdown","4ffb7022":"markdown","3c9a1284":"markdown","377f5435":"markdown","bf68c139":"markdown","dcd37efc":"markdown","59f9e9b0":"markdown","28d26f5a":"markdown","51b72036":"markdown","88837ac0":"markdown","2cff28c3":"markdown","886fc67c":"markdown","74cd488d":"markdown","0f7f5d0f":"markdown","9f82bd6a":"markdown","4b91570c":"markdown","2818d949":"markdown","43812193":"markdown","0de710a7":"markdown","41b888bb":"markdown","e6cd5b2c":"markdown","61f4d9fa":"markdown","c3ee17d5":"markdown","bb3d67a6":"markdown","445bcffa":"markdown","1b31bd53":"markdown","9a8e9e4b":"markdown","f3bee324":"markdown","7a744044":"markdown","a1f4d40e":"markdown","3708c9a6":"markdown","f06ab253":"markdown","0eecf3c4":"markdown","fb97df45":"markdown","4522a30b":"markdown","c4c45cee":"markdown","1205c5e1":"markdown","6dd35398":"markdown","e622a9cc":"markdown","35d77e64":"markdown","af2052ad":"markdown","da339bf2":"markdown","0e1b0c5a":"markdown","705974aa":"markdown","3e2c8c38":"markdown","66c26162":"markdown","38ca1bc7":"markdown","b627811e":"markdown","94afe203":"markdown","9fcfec62":"markdown","df691535":"markdown","9aeab1ae":"markdown","206a9f76":"markdown","429ad30d":"markdown","59b14c24":"markdown","80157fb1":"markdown","4b199d12":"markdown","72ba65b2":"markdown","87e3bd7b":"markdown","1cb7b2b8":"markdown","a8b06e5f":"markdown","b6caed20":"markdown","43cebd6e":"markdown","ec051e3c":"markdown","2e97aab4":"markdown","244d9fac":"markdown","f692566b":"markdown","3f0a0acd":"markdown","da97612e":"markdown","1648fbda":"markdown","b043fdd2":"markdown","9625b4d3":"markdown","9a67bf5d":"markdown","2adc17f3":"markdown","d0c7d469":"markdown","9b8541b7":"markdown","be59c5be":"markdown","9815aa64":"markdown","da5ff5d0":"markdown","8ca805ca":"markdown","53c61281":"markdown","d55e3723":"markdown","da67e5ef":"markdown","43418cb9":"markdown","729d5ea2":"markdown","7ac302c4":"markdown","59cd80da":"markdown","ccaf8cbe":"markdown","69b861ab":"markdown","b1b63ac1":"markdown","c420dffb":"markdown","9c5df844":"markdown","d59a40eb":"markdown","4092286f":"markdown","453e62d6":"markdown","4156c09e":"markdown","4b3ffb4b":"markdown","771c677f":"markdown","6819f148":"markdown"},"source":{"f5351d84":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns","dbaeafe9":"train = pd.read_csv('\/kaggle\/input\/house-prices-advanced-regression-techniques\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/house-prices-advanced-regression-techniques\/test.csv')\n#train = pd.read_csv('.\/train.csv')\n#test = pd.read_csv('.\/test.csv')","6bdbd910":"corr_matrix = train.corr()[['SalePrice']].sort_values(by = ['SalePrice'], ascending = False).drop(['SalePrice'])\ncorr_matrix.style.background_gradient(cmap = 'coolwarm').set_precision(2)","a7fb52f5":"missing = pd.concat([train.isna().sum().sort_values(ascending = False), train.dtypes], axis=1, keys=['Total', 'Type'])\nmissing[missing['Total'] > 0]","98181315":"train.describe().transpose()","32a6f4cb":"sns.boxplot(data = train['LotFrontage'], orient = 'h')","55fc199d":"train['LotFrontage'].sort_values(ascending = False)","aa51af5c":"sns.boxplot(data = train['LotArea'], orient = 'h')","a31e0474":"train['LotArea'].sort_values(ascending = False)","fe389555":"sns.boxplot(data = train['MasVnrArea'], orient = 'h')","c39d45ea":"train['MasVnrArea'].sort_values(ascending = False)","16fd7506":"sns.boxplot(data = train['BsmtFinSF1'], orient = 'h')","988bed6b":"train['BsmtFinSF1'].sort_values(ascending = False)","f0524670":"sns.boxplot(data = train['BsmtFinSF2'], orient = 'h')","7824247e":"train['BsmtFinSF2'].sort_values(ascending = False)","c784ff50":"sns.boxplot(data = train['BsmtUnfSF'], orient = 'h')","2279fb9a":"sns.boxplot(data = train['TotalBsmtSF'], orient = 'h')","c3937c34":"train['TotalBsmtSF'].sort_values(ascending = False)","4bdfae01":"sns.boxplot(data = train['1stFlrSF'], orient = 'h')","fd46b664":"train['1stFlrSF'].sort_values(ascending = False)","f6be67e6":"sns.boxplot(data = train['2ndFlrSF'], orient = 'h')","0491a35b":"sns.boxplot(data = train['LowQualFinSF'], orient = 'h')","dda18e42":"sns.boxplot(data = train['GrLivArea'], orient = 'h')","741419a2":"train['GrLivArea'].sort_values(ascending = False)","373a3d3b":"sns.boxplot(data = train['BsmtFullBath'], orient = 'h')","d1b1dcee":"train['BsmtFullBath'].sort_values(ascending = False)","be51bbd5":"sns.boxplot(data = train['BsmtHalfBath'], orient = 'h')","842de100":"sns.boxplot(data = train['FullBath'], orient = 'h')","5594b016":"sns.boxplot(data = train['HalfBath'], orient = 'h')","acd2a6f5":"sns.boxplot(data = train['BedroomAbvGr'], orient = 'h')","57e7418d":"train['BedroomAbvGr'].sort_values(ascending = False)","af70ab99":"sns.boxplot(data = train['KitchenAbvGr'], orient = 'h')","40e7b882":"sns.boxplot(data = train['TotRmsAbvGrd'], orient = 'h')","86f9ab4b":"sns.boxplot(data = train['Fireplaces'], orient = 'h')","7056fb70":"train['Fireplaces'].sort_values(ascending = False)","43d9f6e0":"sns.boxplot(data = train['GarageArea'], orient = 'h')","08369e7c":"sns.boxplot(data = train['WoodDeckSF'], orient = 'h')","e4d3a630":"train['WoodDeckSF'].sort_values(ascending = False)","c4df90e3":"sns.boxplot(data = train['OpenPorchSF'], orient = 'h')","29a10316":"train['OpenPorchSF'].sort_values(ascending = False)","2df5f337":"sns.boxplot(data = train['EnclosedPorch'], orient = 'h')","d01a8a99":"train['EnclosedPorch'].sort_values(ascending = False)","e3eecc89":"sns.boxplot(data = train['3SsnPorch'], orient = 'h')","06862197":"train['3SsnPorch'].sort_values(ascending = False)","c329e0a1":"sns.boxplot(data = train['ScreenPorch'], orient = 'h')","ddbb8876":"train['ScreenPorch'].sort_values(ascending = False)","f35e2558":"train['MSSubClass'].value_counts()","d94ef712":"corr_matrix.loc[['MSSubClass']]","0666bd9b":"train = train.drop('MSSubClass', 1)","5ea114db":"train['MSZoning'].value_counts()","03d3ea4e":"msz = train.groupby('MSZoning', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nmsz['normalized'] = (msz['SalePrice'] - msz['SalePrice'].min()) \/ (msz['SalePrice'].max() - msz['SalePrice'].min()).round(3)\ntrain['MSZoning'] = train['MSZoning'].apply(lambda x: msz.loc[msz['MSZoning'] == x, 'normalized'].item())\ntrain['MSZoning'] = train['MSZoning'].astype(float)","79350f12":"train.corr()[['SalePrice']].sort_values(by = ['SalePrice'], ascending = False).drop(['SalePrice']).loc[['MSZoning']]","08c9bfcc":"train['LotFrontage'].skew()","0e5f2692":"train['LotFrontage'].hist()","a0cf715f":"train['LotFrontage'].fillna(train['LotFrontage'].mean(), inplace = True)","48eb6f84":"train['LotArea'].value_counts()","14ecf43d":"train['Street'].value_counts()","6b190880":"train = train.drop('Street', 1)","34cc64c5":"train['Alley'].fillna(0, inplace = True)\ntrain['Alley'] = train['Alley'].replace('Grvl', '1', regex = True)\ntrain['Alley'] = train['Alley'].replace('Pave', '1', regex = True)\ntrain['Alley'] = train['Alley'].astype(int)","b08a8ab4":"lshp = train.groupby('LotShape', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nlshp['normalized'] = (lshp['SalePrice'] - lshp['SalePrice'].min()) \/ (lshp['SalePrice'].max() - lshp['SalePrice'].min()).round(3)\ntrain['LotShape'] = train['LotShape'].apply(lambda x: lshp.loc[lshp['LotShape'] == x, 'normalized'].item())\ntrain['LotShape'] = train['LotShape'].astype(float)","c1dc4e6e":"lctr = train.groupby('LandContour', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nlctr['normalized'] = (lctr['SalePrice'] - lctr['SalePrice'].min()) \/ (lctr['SalePrice'].max() - lctr['SalePrice'].min()).round(3)\ntrain['LandContour'] = train['LandContour'].apply(lambda x: lctr.loc[lctr['LandContour'] == x, 'normalized'].item())\ntrain['LandContour'] = train['LandContour'].astype(float)","e446c99e":"train['Utilities'].value_counts()","d310fae3":"train = train.drop('Utilities', 1)","c17e5a0c":"lcfg = train.groupby('LotConfig', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nlcfg['normalized'] = (lcfg['SalePrice'] - lcfg['SalePrice'].min()) \/ (lcfg['SalePrice'].max() - lcfg['SalePrice'].min()).round(3)\ntrain['LotConfig'] = train['LotConfig'].apply(lambda x: lcfg.loc[lcfg['LotConfig'] == x, 'normalized'].item())\ntrain['LotConfig'] = train['LotConfig'].astype(float)","039b3224":"lslp = train.groupby('LandSlope', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nlslp['normalized'] = (lslp['SalePrice'] - lslp['SalePrice'].min()) \/ (lslp['SalePrice'].max() - lslp['SalePrice'].min()).round(3)\ntrain['LandSlope'] = train['LandSlope'].apply(lambda x: lslp.loc[lslp['LandSlope'] == x, 'normalized'].item())\ntrain['LandSlope'] = train['LandSlope'].astype(float)","77fea9b1":"ngbh = train.groupby('Neighborhood', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nngbh['normalized'] = (ngbh['SalePrice'] - ngbh['SalePrice'].min()) \/ (ngbh['SalePrice'].max() - ngbh['SalePrice'].min()).round(3)\ntrain['Neighborhood'] = train['Neighborhood'].apply(lambda x: ngbh.loc[ngbh['Neighborhood'] == x, 'normalized'].item())\ntrain['Neighborhood'] = train['Neighborhood'].astype(float)","b4e2a0bd":"cond1 = train.groupby('Condition1', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\ncond1['normalized'] = (cond1['SalePrice'] - cond1['SalePrice'].min()) \/ (cond1['SalePrice'].max() - cond1['SalePrice'].min()).round(3)\ntrain['Condition1'] = train['Condition1'].apply(lambda x: cond1.loc[cond1['Condition1'] == x, 'normalized'].item())\ntrain['Condition1'] = train['Condition1'].astype(float)\ntrain = train.drop('Condition2', 1)","8040d0a5":"bldg = train.groupby('BldgType', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nbldg['normalized'] = (bldg['SalePrice'] - bldg['SalePrice'].min()) \/ (bldg['SalePrice'].max() - bldg['SalePrice'].min()).round(3)\ntrain['BldgType'] = train['BldgType'].apply(lambda x: bldg.loc[bldg['BldgType'] == x, 'normalized'].item())\ntrain['BldgType'] = train['BldgType'].astype(float)","af59ce7a":"hstl = train.groupby('HouseStyle', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nhstl['normalized'] = (hstl['SalePrice'] - hstl['SalePrice'].min()) \/ (hstl['SalePrice'].max() - hstl['SalePrice'].min()).round(3)\ntrain['HouseStyle'] = train['HouseStyle'].apply(lambda x: hstl.loc[hstl['HouseStyle'] == x, 'normalized'].item())\ntrain['HouseStyle'] = train['HouseStyle'].astype(float)","c51a61c0":"train.groupby('OverallQual', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)","822b94b8":"train.groupby('OverallCond', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)","c66fc7b7":"with pd.option_context('display.max_columns', None): \n    display(train[train['YearBuilt'].isin([1872])])","3e0ec15d":"train_year_sp = train.groupby('YearBuilt', as_index = False)['SalePrice'].mean().sort_values(by = 'YearBuilt')\nax = train_year_sp[['SalePrice']].plot(kind = 'line',\n                                       title = 'Impact of construction year on sale price',\n                                       figsize = (19,5),\n                                       legend = True,\n                                       fontsize = 12)\nax.set_xlabel('YearBuilt', fontsize=12)\nax.set_ylabel('SalePrice', fontsize=12)\nax.set_xticks(range(len(train_year_sp)))\nax.set_xticklabels(train_year_sp['YearBuilt'])\nplt.xticks(rotation = 90)\nplt.show()","9950d6fb":"train_year_rem_sp = train.groupby('YearRemodAdd', as_index = False)['SalePrice'].mean().sort_values(by = 'YearRemodAdd')\nax = train_year_rem_sp[['SalePrice']].plot(kind = 'line',\n                                                   title = 'Impact of renovation year on sale price',\n                                                   figsize = (19,5),\n                                                   legend = True,\n                                                   fontsize = 12)\nax.set_xlabel('YearRemodAdd', fontsize=12)\nax.set_ylabel('SalePrice', fontsize=12)\nax.set_xticks(range(len(train_year_rem_sp)))\nax.set_xticklabels(train_year_rem_sp['YearRemodAdd'])\nplt.xticks(rotation=90)\nplt.show()","eef055b8":"rfst = train.groupby('RoofStyle', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nrfst['normalized'] = (rfst['SalePrice'] - rfst['SalePrice'].min()) \/ (rfst['SalePrice'].max() - rfst['SalePrice'].min()).round(3)\ntrain['RoofStyle'] = train['RoofStyle'].apply(lambda x: rfst.loc[rfst['RoofStyle'] == x, 'normalized'].item())\ntrain['RoofStyle'] = train['RoofStyle'].astype(float)","bcfd3719":"rfmt = train.groupby('RoofMatl', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nrfmt['normalized'] = (rfmt['SalePrice'] - rfmt['SalePrice'].min()) \/ (rfmt['SalePrice'].max() - rfmt['SalePrice'].min()).round(3)\ntrain['RoofMatl'] = train['RoofMatl'].apply(lambda x: rfmt.loc[rfmt['RoofMatl'] == x, 'normalized'].item())\ntrain['RoofMatl'] = train['RoofMatl'].astype(float)","30da81ba":"ext1 = train.groupby('Exterior1st', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\next1['normalized'] = (ext1['SalePrice'] - ext1['SalePrice'].min()) \/ (ext1['SalePrice'].max() - ext1['SalePrice'].min()).round(3)\ntrain['Exterior1st'] = train['Exterior1st'].apply(lambda x: ext1.loc[ext1['Exterior1st'] == x, 'normalized'].item())\ntrain['Exterior1st'] = train['Exterior1st'].astype(float)","dd435d63":"ext2 = train.groupby('Exterior2nd', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\next2['normalized'] = (ext2['SalePrice'] - ext2['SalePrice'].min()) \/ (ext2['SalePrice'].max() - ext2['SalePrice'].min()).round(3)\ntrain['Exterior2nd'] = train['Exterior2nd'].apply(lambda x: ext2.loc[ext2['Exterior2nd'] == x, 'normalized'].item())\ntrain['Exterior2nd'] = train['Exterior2nd'].astype(float)","0d7577b0":"train['MasVnrType'].fillna('None', inplace = True)\nmvtp = train.groupby('MasVnrType', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nmvtp['normalized'] = (mvtp['SalePrice'] - mvtp['SalePrice'].min()) \/ (mvtp['SalePrice'].max() - mvtp['SalePrice'].min()).round(3)\ntrain['MasVnrType'] = train['MasVnrType'].apply(lambda x: mvtp.loc[mvtp['MasVnrType'] == x, 'normalized'].item())\ntrain['MasVnrType'] = train['MasVnrType'].astype(float)","dba54317":"value = train[train['SalePrice'].between(train[train['MasVnrArea'].isna()]['SalePrice'].mean() - 1000, train[train['MasVnrArea'].isna()]['SalePrice'].mean() + 1000)]['MasVnrArea'].mean()\ntrain['MasVnrArea'].fillna(value, inplace = True)","f88e187e":"exql = train.groupby('ExterQual', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nexql['normalized'] = (exql['SalePrice'] - exql['SalePrice'].min()) \/ (exql['SalePrice'].max() - exql['SalePrice'].min()).round(3)\ntrain['ExterQual'] = train['ExterQual'].apply(lambda x: exql.loc[exql['ExterQual'] == x, 'normalized'].item())\ntrain['ExterQual'] = train['ExterQual'].astype(float)","63d05239":"excn = train.groupby('ExterCond', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nexcn['normalized'] = (excn['SalePrice'] - excn['SalePrice'].min()) \/ (excn['SalePrice'].max() - excn['SalePrice'].min()).round(3)\ntrain['ExterCond'] = train['ExterCond'].apply(lambda x: excn.loc[excn['ExterCond'] == x, 'normalized'].item())\ntrain['ExterCond'] = train['ExterCond'].astype(float)","070a0f57":"fndt = train.groupby('Foundation', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nfndt['normalized'] = (fndt['SalePrice'] - fndt['SalePrice'].min()) \/ (fndt['SalePrice'].max() - fndt['SalePrice'].min()).round(3)\ntrain['Foundation'] = train['Foundation'].apply(lambda x: fndt.loc[fndt['Foundation'] == x, 'normalized'].item())\ntrain['Foundation'] = train['Foundation'].astype(float)","04f30a63":"bsmt_cols = ['BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinSF1', 'BsmtFinType2', 'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF']\ntrain[train['BsmtExposure'].isna()][bsmt_cols]","063e53fc":"for col in bsmt_cols:\n    train[col].fillna('None', inplace = True)","048f6318":"bsqu = train.groupby('BsmtQual', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nbsqu['normalized'] = (bsqu['SalePrice'] - bsqu['SalePrice'].min()) \/ (bsqu['SalePrice'].max() - bsqu['SalePrice'].min()).round(3)\ntrain['BsmtQual'] = train['BsmtQual'].apply(lambda x: bsqu.loc[bsqu['BsmtQual'] == x, 'normalized'].item())\ntrain['BsmtQual'] = train['BsmtQual'].astype(float)","00b678ff":"bscn = train.groupby('BsmtCond', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nbscn['normalized'] = (bscn['SalePrice'] - bscn['SalePrice'].min()) \/ (bscn['SalePrice'].max() - bscn['SalePrice'].min()).round(3)\ntrain['BsmtCond'] = train['BsmtCond'].apply(lambda x: bscn.loc[bscn['BsmtCond'] == x, 'normalized'].item())\ntrain['BsmtCond'] = train['BsmtCond'].astype(float)","57a00d27":"bsxp = train.groupby('BsmtExposure', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nbsxp['normalized'] = (bsxp['SalePrice'] - bsxp['SalePrice'].min()) \/ (bsxp['SalePrice'].max() - bsxp['SalePrice'].min()).round(3)\ntrain['BsmtExposure'] = train['BsmtExposure'].apply(lambda x: bsxp.loc[bsxp['BsmtExposure'] == x, 'normalized'].item())\ntrain['BsmtExposure'] = train['BsmtExposure'].astype(float)","06f701a1":"bsf1 = train.groupby('BsmtFinType1', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nbsf1['normalized'] = (bsf1['SalePrice'] - bsf1['SalePrice'].min()) \/ (bsf1['SalePrice'].max() - bsf1['SalePrice'].min()).round(3)\ntrain['BsmtFinType1'] = train['BsmtFinType1'].apply(lambda x: bsf1.loc[bsf1['BsmtFinType1'] == x, 'normalized'].item())\ntrain['BsmtFinType1'] = train['BsmtFinType1'].astype(float)","648ebad6":"bsf2 = train.groupby('BsmtFinType2', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nbsf2['normalized'] = (bsf2['SalePrice'] - bsf2['SalePrice'].min()) \/ (bsf2['SalePrice'].max() - bsf2['SalePrice'].min()).round(3)\ntrain['BsmtFinType2'] = train['BsmtFinType2'].apply(lambda x: bsf2.loc[bsf2['BsmtFinType2'] == x, 'normalized'].item())\ntrain['BsmtFinType2'] = train['BsmtFinType2'].astype(float)","d3d3ec3e":"heat = train.groupby('Heating', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nheat['normalized'] = (heat['SalePrice'] - heat['SalePrice'].min()) \/ (heat['SalePrice'].max() - heat['SalePrice'].min()).round(3)\ntrain['Heating'] = train['Heating'].apply(lambda x: heat.loc[heat['Heating'] == x, 'normalized'].item())\ntrain['Heating'] = train['Heating'].astype(float)","a6e6273d":"htqc = train.groupby('HeatingQC', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nhtqc['normalized'] = (htqc['SalePrice'] - htqc['SalePrice'].min()) \/ (htqc['SalePrice'].max() - htqc['SalePrice'].min()).round(3)\ntrain['HeatingQC'] = train['HeatingQC'].apply(lambda x: htqc.loc[htqc['HeatingQC'] == x, 'normalized'].item())\ntrain['HeatingQC'] = train['HeatingQC'].astype(float)","3572d709":"train['CentralAir'] = train['CentralAir'].replace('Y', '1', regex = True)\ntrain['CentralAir'] = train['CentralAir'].replace('N', '0', regex = True)\ntrain['CentralAir'] = train['CentralAir'].astype(int)","e3862786":"train['Electrical'].fillna('None', inplace = True)\nelec = train.groupby('Electrical', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nelec['normalized'] = (elec['SalePrice'] - elec['SalePrice'].min()) \/ (elec['SalePrice'].max() - elec['SalePrice'].min()).round(3)\ntrain['Electrical'] = train['Electrical'].apply(lambda x: elec.loc[elec['Electrical'] == x, 'normalized'].item())\ntrain['Electrical'] = train['Electrical'].astype(float)","f9ad1daa":"train[['1stFlrSF', '2ndFlrSF', 'LowQualFinSF', 'GrLivArea', 'BsmtFullBath', 'BsmtHalfBath', 'FullBath', 'HalfBath', 'BedroomAbvGr', 'KitchenAbvGr', 'TotRmsAbvGrd']].describe()","47a4a565":"kchq = train.groupby('KitchenQual', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nkchq['normalized'] = (kchq['SalePrice'] - kchq['SalePrice'].min()) \/ (kchq['SalePrice'].max() - kchq['SalePrice'].min()).round(3)\ntrain['KitchenQual'] = train['KitchenQual'].apply(lambda x: kchq.loc[kchq['KitchenQual'] == x, 'normalized'].item())\ntrain['KitchenQual'] = train['KitchenQual'].astype(float)","383e1776":"func = train.groupby('Functional', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nfunc['normalized'] = (func['SalePrice'] - func['SalePrice'].min()) \/ (func['SalePrice'].max() - func['SalePrice'].min()).round(3)\ntrain['Functional'] = train['Functional'].apply(lambda x: func.loc[func['Functional'] == x, 'normalized'].item())\ntrain['Functional'] = train['Functional'].astype(float)","0f55ad06":"train['Fireplaces'].value_counts()","1399ac42":"train['FireplaceQu'].fillna('None', inplace = True)\nfrpq = train.groupby('FireplaceQu', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nfrpq['normalized'] = (frpq['SalePrice'] - frpq['SalePrice'].min()) \/ (frpq['SalePrice'].max() - frpq['SalePrice'].min()).round(3)\ntrain['FireplaceQu'] = train['FireplaceQu'].apply(lambda x: frpq.loc[frpq['FireplaceQu'] == x, 'normalized'].item())\ntrain['FireplaceQu'] = train['FireplaceQu'].astype(float)","6321c2fc":"garage_cols = [col for col in train if col.startswith('Garage')]\ntrain[train['GarageType'].isna()][garage_cols]['GarageArea'].sum()","e2d35b81":"for col in garage_cols:\n    train[col].fillna('None', inplace = True)\ntrain['GarageYrBlt'] = train['GarageYrBlt'].replace('None', 0, regex = True)\ntrain['GarageCars'] = train['GarageCars'].replace('None', 0, regex = True)\ntrain['GarageArea'] = train['GarageArea'].replace('None', 0, regex = True)","054e8346":"grtp = train.groupby('GarageType', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\ngrtp['normalized'] = (grtp['SalePrice'] - grtp['SalePrice'].min()) \/ (grtp['SalePrice'].max() - grtp['SalePrice'].min()).round(3)\ntrain['GarageType'] = train['GarageType'].apply(lambda x: grtp.loc[grtp['GarageType'] == x, 'normalized'].item())\ntrain['GarageType'] = train['GarageType'].astype(float)","86c652ff":"train_year_grg_blt = train.groupby('GarageYrBlt', as_index = False)['SalePrice'].mean().sort_values(by = 'GarageYrBlt')\nax = train_year_grg_blt[['SalePrice']].plot(kind = 'line',\n                                                   title = 'Impact of garage construction year on sale price',\n                                                   figsize = (19,5),\n                                                   legend = True,\n                                                   fontsize = 12)\nax.set_xlabel('GarageYrBlt', fontsize=12)\nax.set_ylabel('SalePrice', fontsize=12)\nax.set_xticks(range(len(train_year_grg_blt)))\nax.set_xticklabels(train_year_grg_blt['GarageYrBlt'])\nplt.xticks(rotation=90)\nplt.show()","62964d45":"grfn = train.groupby('GarageFinish', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\ngrfn['normalized'] = (grfn['SalePrice'] - grfn['SalePrice'].min()) \/ (grfn['SalePrice'].max() - grfn['SalePrice'].min()).round(3)\ntrain['GarageFinish'] = train['GarageFinish'].apply(lambda x: grfn.loc[grfn['GarageFinish'] == x, 'normalized'].item())\ntrain['GarageFinish'] = train['GarageFinish'].astype(float)","5cb7b07a":"grqu = train.groupby('GarageQual', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\ngrqu['normalized'] = (grqu['SalePrice'] - grqu['SalePrice'].min()) \/ (grqu['SalePrice'].max() - grqu['SalePrice'].min()).round(3)\ntrain['GarageQual'] = train['GarageQual'].apply(lambda x: grqu.loc[grqu['GarageQual'] == x, 'normalized'].item())\ntrain['GarageQual'] = train['GarageQual'].astype(float)","aad2672a":"grcn = train.groupby('GarageCond', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\ngrcn['normalized'] = (grcn['SalePrice'] - grcn['SalePrice'].min()) \/ (grcn['SalePrice'].max() - grcn['SalePrice'].min()).round(3)\ntrain['GarageCond'] = train['GarageCond'].apply(lambda x: grcn.loc[grcn['GarageCond'] == x, 'normalized'].item())\ntrain['GarageCond'] = train['GarageCond'].astype(float)","64c068d1":"pvdr = train.groupby('PavedDrive', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\npvdr['normalized'] = (pvdr['SalePrice'] - pvdr['SalePrice'].min()) \/ (pvdr['SalePrice'].max() - pvdr['SalePrice'].min()).round(3)\ntrain['PavedDrive'] = train['PavedDrive'].apply(lambda x: pvdr.loc[pvdr['PavedDrive'] == x, 'normalized'].item())\ntrain['PavedDrive'] = train['PavedDrive'].astype(float)","734fd903":"train[['WoodDeckSF', 'OpenPorchSF', 'EnclosedPorch', '3SsnPorch', 'ScreenPorch', 'PoolArea']].describe()","771be43d":"train['PoolQC'].value_counts()","16e8e2d4":"train['PoolArea'].value_counts()","42d3d1b8":"train['PoolQC'].fillna('None', inplace = True)\nplqc = train.groupby('PoolQC', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nplqc['normalized'] = (plqc['SalePrice'] - plqc['SalePrice'].min()) \/ (plqc['SalePrice'].max() - plqc['SalePrice'].min()).round(3)\ntrain['PoolQC'] = train['PoolQC'].apply(lambda x: plqc.loc[plqc['PoolQC'] == x, 'normalized'].item())\ntrain['PoolQC'] = train['PoolQC'].astype(float)","f1d741c3":"train['Fence'].fillna('None', inplace = True)\nfenc = train.groupby('Fence', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nfenc['normalized'] = (fenc['SalePrice'] - fenc['SalePrice'].min()) \/ (fenc['SalePrice'].max() - fenc['SalePrice'].min()).round(3)\ntrain['Fence'] = train['Fence'].apply(lambda x: fenc.loc[fenc['Fence'] == x, 'normalized'].item())\ntrain['Fence'] = train['Fence'].astype(float)","599aa415":"train['MiscFeature'].fillna('None', inplace = True)\nmisc = train.groupby('MiscFeature', as_index = False)['SalePrice'].mean().sort_values(by = 'SalePrice', ascending = False)\nmisc['normalized'] = (misc['SalePrice'] - misc['SalePrice'].min()) \/ (misc['SalePrice'].max() - misc['SalePrice'].min()).round(3)\ntrain['MiscFeature'] = train['MiscFeature'].apply(lambda x: misc.loc[misc['MiscFeature'] == x, 'normalized'].item())\ntrain['MiscFeature'] = train['MiscFeature'].astype(float)","29b6065d":"train_misc_val = train.groupby('MiscVal', as_index = False)['SalePrice'].mean().sort_values(by = 'MiscVal')\nax = train_misc_val[['SalePrice']].plot(kind = 'line',\n                                                   title = 'Impact of value of miscellaneous feature on sale price',\n                                                   figsize = (19,5),\n                                                   legend = True,\n                                                   fontsize = 12)\nax.set_xlabel('MiscVal', fontsize=12)\nax.set_ylabel('SalePrice', fontsize=12)\nax.set_xticks(range(len(train_misc_val)))\nax.set_xticklabels(train_misc_val['MiscVal'])\nplt.xticks(rotation=90)\nplt.show()","ba049c4b":"train = train.drop(['MoSold', 'YrSold', 'SaleType', 'SaleCondition'], 1)","5f900b0d":"train['OldPrice'] = train['SalePrice']\ntrain['SalePrice'] = train['OldPrice'] - train['MiscVal']\n\ntrain = train.drop(['OldPrice'], 1)","b5b94e4a":"corr_matrix = train.corr()[['SalePrice']].sort_values(by = ['SalePrice'], ascending = False) #Do not drop SalePrice this time!\ncorr_matrix[corr_matrix['SalePrice'] > 0.4].style.background_gradient(cmap = 'coolwarm').set_precision(2)","f629e105":"sns.boxplot(data = train['LotFrontage'], orient = 'h')","c28c1c15":"train['LotFrontage'].sort_values(ascending = False)","a45cce09":"sns.boxplot(data = train['LotArea'], orient = 'h')","60d90746":"train['LotArea'].sort_values(ascending = False)","253d7a66":"test = test.drop('MSSubClass', 1)\ntest = test.drop('Street', 1)\ntest = test.drop('Utilities', 1)\ntest = test.drop('Condition2', 1)\ntest = test.drop(['MoSold', 'YrSold', 'SaleType', 'SaleCondition'], 1)\n\ntest['LotFrontage'].fillna(train['LotFrontage'].mean(), inplace = True)\ntest['Alley'].fillna(0, inplace = True)\ntest['MasVnrType'].fillna('None', inplace = True)\ntest['MasVnrArea'].fillna(value, inplace = True)\nfor col in bsmt_cols:\n    test[col].fillna('None', inplace = True)\nfor col in garage_cols:\n    test[col].fillna('None', inplace = True)\ntest['Electrical'].fillna('None', inplace = True)\ntest['FireplaceQu'].fillna('None', inplace = True)\ntest['PoolQC'].fillna('None', inplace = True)\ntest['Fence'].fillna('None', inplace = True)\ntest['MiscFeature'].fillna('None', inplace = True)","59d82171":"missing_test = pd.concat([test.isna().sum().sort_values(ascending = False), test.dtypes], axis=1, keys=['Total', 'Type'])\nmissing_test[missing_test['Total'] > 0]","97ff588e":"test['MSZoning'].fillna('RL', inplace = True)\ntest['BsmtFullBath'].fillna('0.0', inplace = True)\ntest['Functional'].fillna('Typ', inplace = True)\ntest['BsmtHalfBath'].fillna('0.0', inplace = True)\ntest['KitchenQual'].fillna('TA', inplace = True)\ntest['Exterior1st'].fillna('VinylSd', inplace = True)\ntest['Exterior2nd'].fillna('VinylSd', inplace = True)","863fba31":"test['MSZoning'] = test['MSZoning'].apply(lambda x: msz.loc[msz['MSZoning'] == x, 'normalized'].item())\ntest['MSZoning'] = test['MSZoning'].astype(float)\ntest['Alley'] = test['Alley'].replace('Grvl', '1', regex = True)\ntest['Alley'] = test['Alley'].replace('Pave', '1', regex = True)\ntest['Alley'] = test['Alley'].astype(int)\ntest['LotShape'] = test['LotShape'].apply(lambda x: lshp.loc[lshp['LotShape'] == x, 'normalized'].item())\ntest['LotShape'] = test['LotShape'].astype(float)\ntest['LandContour'] = test['LandContour'].apply(lambda x: lctr.loc[lctr['LandContour'] == x, 'normalized'].item())\ntest['LandContour'] = test['LandContour'].astype(float)\ntest['LotConfig'] = test['LotConfig'].apply(lambda x: lcfg.loc[lcfg['LotConfig'] == x, 'normalized'].item())\ntest['LotConfig'] = test['LotConfig'].astype(float)\ntest['LandSlope'] = test['LandSlope'].apply(lambda x: lslp.loc[lslp['LandSlope'] == x, 'normalized'].item())\ntest['LandSlope'] = test['LandSlope'].astype(float)\ntest['Neighborhood'] = test['Neighborhood'].apply(lambda x: ngbh.loc[ngbh['Neighborhood'] == x, 'normalized'].item())\ntest['Neighborhood'] = test['Neighborhood'].astype(float)\ntest['Condition1'] = test['Condition1'].apply(lambda x: cond1.loc[cond1['Condition1'] == x, 'normalized'].item())\ntest['Condition1'] = test['Condition1'].astype(float)\ntest['BldgType'] = test['BldgType'].apply(lambda x: bldg.loc[bldg['BldgType'] == x, 'normalized'].item())\ntest['BldgType'] = test['BldgType'].astype(float)\ntest['HouseStyle'] = test['HouseStyle'].apply(lambda x: hstl.loc[hstl['HouseStyle'] == x, 'normalized'].item())\ntest['HouseStyle'] = test['HouseStyle'].astype(float)\ntest['RoofStyle'] = test['RoofStyle'].apply(lambda x: rfst.loc[rfst['RoofStyle'] == x, 'normalized'].item())\ntest['RoofStyle'] = test['RoofStyle'].astype(float)\ntest['RoofMatl'] = test['RoofMatl'].apply(lambda x: rfmt.loc[rfmt['RoofMatl'] == x, 'normalized'].item())\ntest['RoofMatl'] = test['RoofMatl'].astype(float)\ntest['Exterior1st'] = test['Exterior1st'].apply(lambda x: ext1.loc[ext1['Exterior1st'] == x, 'normalized'].item())\ntest['Exterior1st'] = test['Exterior1st'].astype(float)\ntest['Exterior2nd'] = test['Exterior2nd'].apply(lambda x: ext2.loc[ext2['Exterior2nd'] == x, 'normalized'].item())\ntest['Exterior2nd'] = test['Exterior2nd'].astype(float)\ntest['MasVnrType'] = test['MasVnrType'].apply(lambda x: mvtp.loc[mvtp['MasVnrType'] == x, 'normalized'].item())\ntest['MasVnrType'] = test['MasVnrType'].astype(float)\ntest['ExterQual'] = test['ExterQual'].apply(lambda x: exql.loc[exql['ExterQual'] == x, 'normalized'].item())\ntest['ExterQual'] = test['ExterQual'].astype(float)\ntest['ExterCond'] = test['ExterCond'].apply(lambda x: excn.loc[excn['ExterCond'] == x, 'normalized'].item())\ntest['ExterCond'] = test['ExterCond'].astype(float)\ntest['Foundation'] = test['Foundation'].apply(lambda x: fndt.loc[fndt['Foundation'] == x, 'normalized'].item())\ntest['Foundation'] = test['Foundation'].astype(float)\ntest['BsmtQual'] = test['BsmtQual'].apply(lambda x: bsqu.loc[bsqu['BsmtQual'] == x, 'normalized'].item())\ntest['BsmtQual'] = test['BsmtQual'].astype(float)\ntest['BsmtCond'] = test['BsmtCond'].apply(lambda x: bscn.loc[bscn['BsmtCond'] == x, 'normalized'].item())\ntest['BsmtCond'] = test['BsmtCond'].astype(float)\ntest['BsmtExposure'] = test['BsmtExposure'].apply(lambda x: bsxp.loc[bsxp['BsmtExposure'] == x, 'normalized'].item())\ntest['BsmtExposure'] = test['BsmtExposure'].astype(float)\ntest['BsmtFinType1'] = test['BsmtFinType1'].apply(lambda x: bsf1.loc[bsf1['BsmtFinType1'] == x, 'normalized'].item())\ntest['BsmtFinType1'] = test['BsmtFinType1'].astype(float)\ntest['BsmtFinType2'] = test['BsmtFinType2'].apply(lambda x: bsf2.loc[bsf2['BsmtFinType2'] == x, 'normalized'].item())\ntest['BsmtFinType2'] = test['BsmtFinType2'].astype(float)\ntest['Heating'] = test['Heating'].apply(lambda x: heat.loc[heat['Heating'] == x, 'normalized'].item())\ntest['Heating'] = test['Heating'].astype(float)\ntest['HeatingQC'] = test['HeatingQC'].apply(lambda x: htqc.loc[htqc['HeatingQC'] == x, 'normalized'].item())\ntest['HeatingQC'] = test['HeatingQC'].astype(float)\ntest['CentralAir'] = test['CentralAir'].replace('Y', '1', regex = True)\ntest['CentralAir'] = test['CentralAir'].replace('N', '0', regex = True)\ntest['CentralAir'] = test['CentralAir'].astype(int)\ntest['Electrical'] = test['Electrical'].apply(lambda x: elec.loc[elec['Electrical'] == x, 'normalized'].item())\ntest['Electrical'] = test['Electrical'].astype(float)\ntest['KitchenQual'] = test['KitchenQual'].apply(lambda x: kchq.loc[kchq['KitchenQual'] == x, 'normalized'].item())\ntest['KitchenQual'] = test['KitchenQual'].astype(float)\ntest['Functional'] = test['Functional'].apply(lambda x: func.loc[func['Functional'] == x, 'normalized'].item())\ntest['Functional'] = test['Functional'].astype(float)\ntest['FireplaceQu'] = test['FireplaceQu'].apply(lambda x: frpq.loc[frpq['FireplaceQu'] == x, 'normalized'].item())\ntest['FireplaceQu'] = test['FireplaceQu'].astype(float)\ntest['GarageYrBlt'] = test['GarageYrBlt'].replace('None', 0, regex = True)\ntest['GarageCars'] = test['GarageCars'].replace('None', 0, regex = True)\ntest['GarageArea'] = test['GarageArea'].replace('None', 0, regex = True)\ntest['GarageType'] = test['GarageType'].apply(lambda x: grtp.loc[grtp['GarageType'] == x, 'normalized'].item())\ntest['GarageType'] = test['GarageType'].astype(float)\ntest['GarageFinish'] = test['GarageFinish'].apply(lambda x: grfn.loc[grfn['GarageFinish'] == x, 'normalized'].item())\ntest['GarageFinish'] = test['GarageFinish'].astype(float)\ntest['GarageQual'] = test['GarageQual'].apply(lambda x: grqu.loc[grqu['GarageQual'] == x, 'normalized'].item())\ntest['GarageQual'] = test['GarageQual'].astype(float)\ntest['GarageCond'] = test['GarageCond'].apply(lambda x: grcn.loc[grcn['GarageCond'] == x, 'normalized'].item())\ntest['GarageCond'] = test['GarageCond'].astype(float)\ntest['PavedDrive'] = test['PavedDrive'].apply(lambda x: pvdr.loc[pvdr['PavedDrive'] == x, 'normalized'].item())\ntest['PavedDrive'] = test['PavedDrive'].astype(float)\ntest['PoolQC'] = test['PoolQC'].apply(lambda x: plqc.loc[plqc['PoolQC'] == x, 'normalized'].item())\ntest['PoolQC'] = test['PoolQC'].astype(float)\ntest['Fence'] = test['Fence'].apply(lambda x: fenc.loc[fenc['Fence'] == x, 'normalized'].item())\ntest['Fence'] = test['Fence'].astype(float)\ntest['MiscFeature'] = test['MiscFeature'].apply(lambda x: misc.loc[misc['MiscFeature'] == x, 'normalized'].item())\ntest['MiscFeature'] = test['MiscFeature'].astype(float)\n\ntest = test.replace('None', 0, regex = True)","0abf118d":"train = train.drop([934, 1298, 313, 335, 249, 706, 297, 1169, 322, 523, 1182, 691, 738, 635, 1328, 495, 583, 197])","c85e7626":"import optuna\nimport catboost as cb\n\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import StratifiedKFold","235fad16":"X = train.drop(columns = ['SalePrice'])\nY = train['SalePrice']\nX_train, X_validation, y_train, y_validation = train_test_split(X, Y, train_size = 0.75, random_state = 42)\nX_test = test","b20485e7":"def objective(trial):\n    X = train.drop(columns = ['SalePrice'])\n    Y = train['SalePrice']\n    X_train, X_validation, y_train, y_validation = train_test_split(X, Y, train_size = 0.75, random_state = 42)\n\n    param = {\n        'objective': trial.suggest_categorical('objective', ['RMSE']),\n        'colsample_bylevel': trial.suggest_float('colsample_bylevel', 0.8, 0.9),\n        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1),\n        'l2_leaf_reg': trial.suggest_int('l2_leaf_reg', 1, 3),\n        'depth': trial.suggest_int('depth', 3, 5),\n        #'boosting_type': trial.suggest_categorical('boosting_type', ['Ordered', 'Plain']),\n        #'bootstrap_type': trial.suggest_categorical('bootstrap_type', ['Bayesian', 'Bernoulli', 'MVS']),\n        'used_ram_limit': '15gb',\n    }\n\n    #if param['bootstrap_type'] == 'Bayesian':\n    #    param['bagging_temperature'] = trial.suggest_float('bagging_temperature', 0, 10)\n    #elif param['bootstrap_type'] == 'Bernoulli':\n    #    param['subsample'] = trial.suggest_float('subsample', 0.1, 1)\n\n    gbm = cb.CatBoostRegressor(**param)\n\n    gbm.fit(X_train, y_train, eval_set = [(X_validation, y_validation)], verbose = 0, early_stopping_rounds = 100)\n\n    preds = gbm.predict(X_validation)\n    pred_labels = np.rint(preds)\n    accuracy = mean_absolute_error(y_validation, pred_labels)\n    return accuracy\n\n\nif __name__ == '__main__':\n    study = optuna.create_study(direction = 'minimize')\n    study.optimize(objective,\n                   #n_trials = 250,\n                   timeout = 8*3600)\n\n    print('Number of finished trials: {}'.format(len(study.trials)))\n\n    print('Best trial:')\n    trial = study.best_trial\n\n    print('  Value: {}'.format(trial.value))\n\n    print('  Params: ')\n    for key, value in trial.params.items():\n        print('    {}: {}'.format(key, value))","e8892ad2":"optuna.visualization.plot_optimization_history(study)","4f1ac5fd":"optuna.visualization.plot_slice(study)","d006e1dc":"#optuna.visualization.plot_param_importances(study)","04bb1526":"optuna.visualization.plot_edf(study)","9ba70244":"model = cb.CatBoostRegressor(random_seed = 42,\n                             logging_level = 'Silent',\n                             **study.best_trial.params)","b763355f":"'''\ntest_preds = None\ncols = list(train.columns)\ncols.remove('SalePrice')\n\nn_splits = 10\nkf = StratifiedKFold(n_splits = n_splits, shuffle = True, random_state = 42)\nfor fold, (tr_index , val_index) in enumerate(kf.split(X.values, Y.values)):\n\n    print(\"-\" * 50)\n    print(f\"Fold {fold + 1}\")\n    \n    x_train, x_val = X.values[tr_index], X.values[val_index]\n    y_train, y_val = Y.values[tr_index], Y.values[val_index]\n        \n    eval_set = [(x_val, y_val)]\n    \n    model = cb.CatBoostRegressor(random_seed = 42,\n                             logging_level = 'Silent',\n                             **study.best_trial.params)\n    model.fit(x_train, y_train,\n              eval_set = eval_set, verbose = 0)\n    \n    train_preds = model.predict(x_train)    \n    val_preds = model.predict(x_val)\n    \n    print('RMSE => {}'.format(mean_absolute_error(y_val, val_preds)))\n    \n    if test_preds is None:\n        test_preds = model.predict(test[cols].values)\n    else:\n        test_preds += model.predict(test[cols].values)\n\nprint(\"-\" * 50)\ntest_preds \/= n_splits\n'''","e898585d":"model.fit(X_train,\n          y_train,\n          eval_set = (X_validation, y_validation))","f0612a9b":"prediction = model.predict(X_test)","7a2d7a5d":"#submission = pd.DataFrame(test_preds)\nsubmission = pd.DataFrame(prediction)\nsubmission['Id'] = test['Id']\nsubmission = submission.rename(columns = {0: 'SalePrice'})","f529e2c5":"submission.to_csv('submission.csv', index = False)","5738f30a":"trials = study.trials_dataframe()\ntrials.to_csv('trials.csv', index = False)","5e34e441":"### Alley: Type of alley access to property","4008382c":"### BsmtQual: Evaluates the height of the basement","32c6af98":"### Next columns are numeric\n\n* WoodDeckSF: Wood deck area in square feet\n* OpenPorchSF: Open porch area in square feet\n* EnclosedPorch: Enclosed porch area in square feet\n* 3SsnPorch: Three season porch area in square feet\n* ScreenPorch: Screen porch area in square feet\n* PoolArea: Pool area in square feet","50e2062c":"### Correlation, first look","42589508":"### Exterior2nd: Exterior covering on house (if more than one material)","8023e092":"### GarageYrBlt: Year garage was built\nLet's plot","e3589abb":"Correlation with price is negative. Most of the values are in categories 20 (1-STORY 1946 & NEWER ALL STYLES), 50 (1-1\/2 STORY FINISHED ALL AGES) and 60 (2-STORY 1946 & NEWER). This column seems useless - we have year in another. So, I will delete it.","b3bbc67b":"### YearRemodAdd: Remodel date (same as construction date if no remodeling or additions)","489be431":"### ExterCond: Evaluates the present condition of the material on the exterior","7119da7d":"99.999999999% are the same. No impact on price, I think. Drop it.","a7a44975":"### Other basement columns\n* BsmtFinSF1: Type 1 finished square feet\n* BsmtFinSF2: Type 2 finished square feet\n* BsmtUnfSF: Unfinished square feet of basement area\n* TotalBsmtSF: Total square feet of basement area\nThese are numeric, nothing to replace","c665026b":"### BsmtFinType1: Rating of basement finished area","e7662800":"This time the scale is negatively correlated with price. I think there are some houses in more prestigious area, but in poorer condition - they still cost more.","4ffb7022":"##### <span style=\"color:red\">1298<\/span> again","3c9a1284":"### YearBuilt: Original construction date","377f5435":"Here's a tricky way to choose value for NaNs.","bf68c139":"#### KFold made my score worse.","dcd37efc":"### Street: Type of road access to property","59f9e9b0":"Yes, still the same.","28d26f5a":"### KitchenQual: Kitchen quality","51b72036":"### BsmtFinType2: Rating of basement finished area (if multiple types)","88837ac0":"##### <span style=\"color:red\">1298<\/span>","2cff28c3":"### GarageCond: Garage condition","886fc67c":"### LotArea: Lot size in square feet","74cd488d":"### Utilities: Type of utilities available","0f7f5d0f":"### CentralAir: Central air conditioning\nThis has 2 values - Y and N. Change to 1 and 0 respectively.","9f82bd6a":"# Models. CatBoost + Optuna.\n\nhttps:\/\/github.com\/optuna\/optuna-examples\/blob\/main\/catboost\/catboost_simple.py","4b91570c":"### MiscVal: $Value of miscellaneous feature","2818d949":"### The same tranformations with test\n\n#### First let's drop columns and fill all missing as it train","43812193":"Ok, I will do it only once, just to show the changes.","0de710a7":"### Identifying and removing outliers\n\nI will do it before any data transfomation, because at this stage there are less numeric values. But drop the respective rows only after the transformation - there can be distinct categories in test and train data, so dropping some values before data normalization can cause errors.","41b888bb":"# Save trials","e6cd5b2c":"##### <span style=\"color:red\">1298, 523, 1182, 691<\/span>","61f4d9fa":"### LandSlope: Slope of property","c3ee17d5":"### ExterQual: Evaluates the quality of the material on the exterior ","bb3d67a6":"Got some missing values here. I will use mean to fill them.","445bcffa":"Ok. No garage - no problem, fill with None, change some to numeric.","1b31bd53":"I will not drop any columns with missing values for now, first look at the data and try to fill them some way.","9a8e9e4b":"### Heating: Type of heating","f3bee324":"The oldest property in Ames (which present in this dataset) was built in 1872. The city itself [was founded in 1864](https:\/\/en.wikipedia.org\/wiki\/Ames,_Iowa#History). Well, this lot can be of special interest for buyers. Let's look at it.","7a744044":"##### <span style=\"color:red\">313, 335, 249, 706<\/span>","a1f4d40e":"### Basement column's group","3708c9a6":"##### <span style=\"color:red\">635<\/span>","f06ab253":"# Submission","0eecf3c4":"### Foundation: Type of foundation","fb97df45":"### BldgType: Type of dwelling","4522a30b":"### OverallQual: Rates the overall material and finish of the house","c4c45cee":"### MiscFeature: Miscellaneous feature not covered in other categories","1205c5e1":"##### <span style=\"color:red\">322<\/span>","6dd35398":"No missing values, no corrupted data. I will not touch them.","e622a9cc":"So these 38 missing values are from **No Basement** group.","35d77e64":"##### <span style=\"color:red\">1328, 495, 583<\/span>","af2052ad":"No correlation at all.","da339bf2":"### Electrical: Electrical system\nThere's one missing value in this column","0e1b0c5a":"### HeatingQC: Heating quality and condition","705974aa":"### Neighborhood: Physical locations within Ames city limits","3e2c8c38":"### RoofMatl: Roof material","66c26162":"Nothing to do here.","38ca1bc7":"Just a few values, they make little impact on results. Change them all to the most popular values in respective columns.","b627811e":"### Fireplaces: Number of fireplaces","94afe203":"### LotShape: General shape of property","9fcfec62":"### OverallCond: Rates the overall condition of the house","df691535":"### Exterior1st: Exterior covering on house","9aeab1ae":"##### <span style=\"color:red\">197<\/span>","206a9f76":"##### <span style=\"color:red\">297, 1169<\/span>","429ad30d":"### LotFrontage: Linear feet of street connected to propert","59b14c24":"Due to small amount of missing (8 rows) I will fill them with normalized value and hope it would work well in my future model.","80157fb1":"### Now I want to look, what happened to outliers after the transformation, are there still the same rows?","4b199d12":"This one is extremely skewed (99.6% and 0.4%), no way to improve it. I will drop this column, because it can have nop impact on the price at all.","72ba65b2":"### GarageQual: Garage quality","87e3bd7b":"### Here the outliers will be removed\n\n934, 1298, 313, 335, 249, 706, 297, 1169, 322, 523, 1182, 691, 738, 635, 1328, 495, 583, 197","1cb7b2b8":"### BsmtCond: Evaluates the general condition of the basement","a8b06e5f":"A lot of missing values (1369 out of 1460). But I will transform this one other way. The presence of alley will be encoded as 1, the absence as 0.","b6caed20":"# Load libraries and data","43cebd6e":"### Condition1: Proximity to various conditions. Condition2: Proximity to various conditions (if more than one is present)","ec051e3c":"This one looks strange. 12.2% of all renovations happened in 1950. Maybe this is the first year when such activities were fixed?","2e97aab4":"### Correlation of transformed data","244d9fac":"### GarageType: Garage location","f692566b":"### PavedDrive: Paved driveway","3f0a0acd":"And the impact of year on sale price","da97612e":"##### This sorting shows that rows <span style=\"color:red\">934 and 1298<\/span> contain outliers. I can't remove them now - tried already, this action causes an error in normalization **test** data. So I only remember this rows and see if I can work with them later, after normalization step.","1648fbda":"The same peaks as on construction year's plot.","b043fdd2":"Both construction and renovation years have several outliers. I will work with them in the next version of my notebook. This time just ignore them.\n\n### RoofStyle: Type of roof","9625b4d3":"No data about correlation - it can be estimated only for numeric values. So, let's make transformation. This column is about density. The less - the better, I think.\n\n##### This is first of large group of columns in my data processing there I apply these steps :\n* group data by categories\n* estimate the mean price for each category\n* normalize mean prices\n* set these normalized values as new names of categories\n* change their type to float - this step allows to estimate correlation\n\n##### Code goes here:","9a67bf5d":"#### So, my outliers are:\n934, 1298, 313, 335, 249, 706, 297, 1169, 322, 523, 1182, 691, 738, 635, 1328, 495, 583, 197","2adc17f3":"### MasVnrArea: Masonry veneer area in square feet","d0c7d469":"Ok. More quality - higher the price is.","9b8541b7":"Just like the previous section (and the next, **Condition2**) this one reflect the property's location. And 99% of **Condition2** are **Norm**. I will drop this column.","be59c5be":"### HouseStyle: Style of dwelling","9815aa64":"### BsmtExposure: Refers to walkout or garden level walls","da5ff5d0":"##### <span style=\"color:red\">738<\/span>\n##### the only one lot with 3 baths","8ca805ca":"### PoolQC: Pool quality","53c61281":"### GarageFinish","d55e3723":"### Fence: Fence quality","da67e5ef":"# EDA, missing values and data tuning\n\n#### I will make all the transformation of data by hand in order to better understand and improve control over it. \n\n### Missing values","43418cb9":"### LotConfig: Lot configuration","729d5ea2":"Let's just check if the impact of quality on the price is appropriate","7ac302c4":"### MSZoning: Identifies the general zoning classification of the sale.","59cd80da":"Are there any missing data left?","ccaf8cbe":"### And the last four\n\n* MoSold: Month Sold (MM)\n* YrSold: Year Sold (YYYY)\n* SaleType: Type of sale\n* SaleCondition: Condition of sale\n\nI'm not sure that this data is of any importance, so drop it for now.","69b861ab":"And now?","b1b63ac1":"### Next columns are numeric\n\n* 1stFlrSF: First Floor square feet \n* 2ndFlrSF: Second floor square feet\n* LowQualFinSF: Low quality finished square feet (all floors)\n* GrLivArea: Above grade (ground) living area square feet\n* BsmtFullBath: Basement full bathrooms\n* BsmtHalfBath: Basement half bathrooms\n* FullBath: Full bathrooms above grade\n* HalfBath: Half baths above grade\n* BedroomAbvGr: Bedrooms above grade (does NOT include basement bedrooms)\n* KitchenAbvGr: Kitchens above grade\n* TotRmsAbvGrd: Total rooms above grade (does not include bathrooms)\n\n**KitchenAbvGr** and **BedroomAbvGr** - these two are given as **Kitchen** and **Bedroom** in **description.txt**","c420dffb":"* Noticed, that **Exterior1st** and **Exterior2nd** have a difference - Cement Board is called **CemntBd** and **CmentBd** respectively.\n* One other thing - has the order of 1st and 2nd any influence? What if we change their order, will the price change be significant?\n\n### MasVnrType: Masonry veneer type","9c5df844":"These two are appropriate. Fill missing with None.","d59a40eb":"### Modify Sale Price\n\n#### My previous public score with this model was 0.15280, I want to see if it changes somehow.","4092286f":"### FireplaceQu: Fireplace quality\nThis one has 690 missing values. Just the same as amount of property with 0 fireplaces. Change them to None.","453e62d6":"### Functional: Home functionality (Assume typical unless deductions are warranted)","4156c09e":"##### <span style=\"color:red\">1298<\/span>","4b3ffb4b":"### MSSubClass: Identifies the type of dwelling involved in the sale.","771c677f":"### LandContour: Flatness of the property","6819f148":"### Here comes the Garage group"}}