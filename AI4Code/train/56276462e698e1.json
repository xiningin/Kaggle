{"cell_type":{"b934b251":"code","5a0a6b34":"code","c240d3be":"code","5732e345":"code","dd45c8a8":"code","35dba348":"code","cc697bc2":"code","b4fac71a":"code","b5c410d7":"code","b746e318":"code","a40edea7":"code","a41fee01":"code","a520d300":"code","66f5095e":"code","73d7a970":"code","2bc5722b":"code","540a3f71":"code","704b40d9":"code","768b9bea":"code","fc8a91c0":"code","0a730237":"code","8dad2107":"code","458c63e1":"code","a57ae28c":"code","c75a3f0e":"code","3c6aff2e":"code","5a8c529e":"code","ace5e521":"code","405cefd9":"code","91537189":"code","f78a0f57":"code","c0cd48f6":"code","402dbf88":"code","14e8e7dc":"code","7177cc99":"code","4086d4b6":"code","d35f51d0":"code","acc368c2":"code","332d611f":"code","d93d63a6":"code","61050077":"code","24d05b90":"code","a7a78de3":"code","c80c2b30":"code","fda0f6dc":"code","4a3243b7":"code","87c56f59":"code","27eefaa1":"code","d3d51849":"code","70d07751":"code","c3cd9241":"code","00264a89":"code","c4b25215":"code","88ace8c7":"code","c12e3b77":"code","720da64b":"code","d7e4cf91":"code","84e2dae9":"code","9aa3ac1f":"code","d5700bae":"code","bd8c9a78":"code","295a7be3":"code","3d874299":"code","a4267db7":"code","b70fa399":"code","84d26b18":"code","a5e974b0":"code","2628dc26":"code","8d660b4f":"code","9409c213":"code","fd85534f":"code","2e7fa98b":"code","69e3281c":"code","6c7a6d91":"code","77a04ddf":"code","f5f4b16d":"code","e0130cc7":"code","445cd0f5":"code","93b44a77":"code","093fa84e":"code","61c786ec":"code","c49035db":"code","28dd9305":"code","6f6febdf":"code","81f25cc7":"code","0db07aa4":"code","b4b69054":"code","7c3c35d6":"code","a43981fc":"code","f034ec19":"code","43532c5d":"markdown","6e14f4bb":"markdown","ced0d96f":"markdown","f93bf49c":"markdown","55ce6632":"markdown","98e611d5":"markdown","9354147a":"markdown","26e82a4e":"markdown","9f9b381b":"markdown","d75d8ea8":"markdown","67f1b0f4":"markdown","6b4f7f25":"markdown","74c2da4b":"markdown","09733c24":"markdown","a1cd9af1":"markdown","479c8648":"markdown","358f9ff4":"markdown","983c9047":"markdown","e3c028a5":"markdown","1e116795":"markdown","6610405c":"markdown","7e8cc49f":"markdown","7bc33051":"markdown","fc479359":"markdown","84583566":"markdown","4aa5d6cf":"markdown","c7140d60":"markdown","7a93bc4e":"markdown","c86bbf92":"markdown","7b885d26":"markdown","7f98866d":"markdown","6a41af3c":"markdown","7697b606":"markdown","925c230a":"markdown","002c4efe":"markdown","5d96bdf3":"markdown","eaf81b5b":"markdown","8d8bcae1":"markdown","2e89ad0f":"markdown","6d14dafa":"markdown","233dae31":"markdown","32b6d2f6":"markdown","77c6bc85":"markdown","196522bf":"markdown","56b98e65":"markdown","09648831":"markdown","273b82e7":"markdown","661c0060":"markdown","b6e08e2e":"markdown","4a77ba42":"markdown","9e7738f3":"markdown","c528f116":"markdown","d082204a":"markdown","dad545f3":"markdown","185d0b82":"markdown","ce98731a":"markdown","193f6648":"markdown","7fa866bc":"markdown","d7b8de7c":"markdown","1ca310a0":"markdown","eb3b1f73":"markdown","ab94f844":"markdown","6ee8816c":"markdown","99282424":"markdown","0bea0fcc":"markdown","91612e31":"markdown","0eae7b50":"markdown","3e35473a":"markdown","bf3396d9":"markdown","625adffc":"markdown","de753fac":"markdown","a259edf9":"markdown","b7665319":"markdown"},"source":{"b934b251":"import numpy as np # lineer cebir i\u015flemleri i\u00e7in\nimport scipy as sp\nimport pandas as pd # verinin organizasyonu i\u00e7in\n\n#Grafik \u00e7izdirme k\u00fct\u00fcphanesi\nimport matplotlib.pyplot as plt\n#Pratik grafik \u00e7izdirme k\u00fct\u00fcphanesi\nimport seaborn as sns\n\n#Makine \u00f6\u011frenmesi modelinin performans de\u011ferlendirmesi i\u00e7in gerekli\n#fonksiyonlar\nfrom sklearn import metrics\n\nfrom sklearn.model_selection import train_test_split\n\nimport os #Sistem \nimport warnings #uyar\u0131lar\nprint(os.listdir(\"..\/input\"))\nwarnings.filterwarnings(\"ignore\")","5a0a6b34":"arr1=list([1,2.0, 'karakter'])\nprint(arr1)","c240d3be":"print(\"D\u00f6n\u00fc\u015f\u00fcmden \u00f6nce veri yap\u0131s\u0131n\u0131n t\u00fcr\u00fc:\",type(arr1))\narr1=np.array(arr1)\nprint(\"D\u00f6n\u00fc\u015f\u00fcmden sonra veri yap\u0131s\u0131n\u0131n t\u00fcr\u00fc:\",type(arr1))","5732e345":"arr2=np.array([1,2,3,4])\nprint(\"Veri yap\u0131s\u0131n\u0131n t\u00fcr\u00fc:\",type(arr2))\narr2=list(arr2)\nprint(\"Veri yap\u0131s\u0131n\u0131n t\u00fcr\u00fc:\",type(arr2))","dd45c8a8":"def get_public_attributes(aclass):\n    #liste tan\u0131mlan\u0131yor\n    public_attributes=[]\n    \n    #dir \u00f6n tan\u0131ml\u0131 olarak Python i\u00e7erisinde yer alan bir fonksiyondur. \n    #parametre olarak ald\u0131\u011f\u0131 nesnenin ge\u00e7erli \u00f6zelliklerine(attributes) d\u00f6ner.\n    attributes=dir(aclass)\n    \n    #\u00f6zellik listesi i\u00e7erisindeki herbir \u00f6zellik al\u0131n\u0131yor\n    for attribute in attributes:\n        \n        #\u00f6n\u00fcnde iki alt\u00e7izgi(__) olmayan \u00f6zellik isimleri kontrol ediliyor\n        if \"__\" not in attribute:\n            #\u00f6n\u00fcnde iki alt\u00e7izgi(__) olmayan \u00f6zellik isimleri ekleniyor\n            public_attributes.append(attribute)\n            \n    \n    #Elde edilen \u00f6zellikler listesine geri d\u00f6n\u00fcl\u00fcyor\n    return public_attributes","35dba348":"list_public_attributes=get_public_attributes(list)\nprint(\"Pyton dizisinin sahip oldu\u011fu d\u0131\u015fa a\u00e7\u0131k \u00f6zelliklerin say\u0131s\u0131:\",len(list_public_attributes))\nprint(\"Pyton dizisinin sahip oldu\u011fu d\u0131\u015fa a\u00e7\u0131k \u00f6zellikler:\\n\",list_public_attributes)\nprint()\nndarray_public_attributes=get_public_attributes(np.array([]))\nprint(\"Numpy dizisinin sahip oldu\u011fu d\u0131\u015fa a\u00e7\u0131k \u00f6zellikler say\u0131s\u0131:\",len(ndarray_public_attributes))\nprint(\"Numpy dizisinin sahip oldu\u011fu d\u0131\u015fa a\u00e7\u0131k \u00f6zellikler:\\n\",ndarray_public_attributes)\n","cc697bc2":"print(list.append.__doc__)\nprint(help(list.append))","b4fac71a":"def attributes_functionality(object_name, attributes):\n    for attribute in attributes:\n        full_name=object_name+\".\"+attribute+\".__doc__\"\n        print(eval(full_name))\n        print(\"*\"*90)","b5c410d7":"attributes_functionality('list', list_public_attributes)","b746e318":"attributes_functionality('np.ndarray', ndarray_public_attributes)","a40edea7":"#t\u00fcm de\u011fi\u015fkenler int tipinde oldu\u011fu i\u00e7in dtype int64 olacakt\u0131r.\n#ndarray dizisinde varsay\u0131lan tam say\u0131 tipi int64't\u00fcr\narr1=np.array([1,2,3,4])\nprint(\"{} dizisinin\".format(arr1))\nprint(\"de\u011fi\u015fken tipi:{}\\n\u015fekli:{}\\n\".format(arr1.dtype, arr1.shape))\n\n#t\u00fcm de\u011fi\u015fkenler noktal\u0131 say\u0131 tipinde oldu\u011fu i\u00e7in dtype float64 olacakt\u0131r.\n#ndarray dizisinde varsay\u0131lan noktal\u0131 say\u0131 tipi float64't\u00fcr\narr2=np.array([1., 2., 3., 4.])\nprint(\"{} dizisinin\".format(arr2))\nprint(\"de\u011fi\u015fken tipi:{}\\n\u015fekli:{}\\n\".format(arr2.dtype, arr2.shape))\n\n#De\u011fi\u015fkenlerden \u00fc\u00e7\u00fc tam say\u0131 ve biri noktal\u0131 say\u0131 oldu\u011fu i\u00e7in dtype float64 olacakt\u0131r\n#float64, int64'ten daha kapsal\u0131 oldu\u011fu i\u00e7in dtype float64 olmu\u015ftur\narr3=np.array([1, 2, 3, 4.])\nprint(\"{} dizisinin\".format(arr3))\nprint(\"de\u011fi\u015fken tipi:{}\\n\u015fekli:{}\\n\".format(arr3.dtype, arr3.shape))\n\n#ndarray dizisinin de\u011fi\u015fen tipini kendimiz belirleyebiriz.\n#Dizideki t\u00fcm de\u011fi\u015fkenler -128 ile 127 aras\u0131nda oldu\u011fu i\u00e7in int8 yeterli olacakt\u0131r\narr4=np.array([1,2,3,4], dtype=np.int8)\nprint(\"{} dizisinin\".format(arr4))\nprint(\"de\u011fi\u015fken tipi:{}\\n\u015fekli:{}\".format(arr4.dtype, arr4.shape)) ","a41fee01":"d1=4\nd2=5\nd3=3\narr=np.zeros((d1, d2,d3),dtype=np.int32)\nprint(\"dizinin \u015fekli:\",arr.shape)\nprint(\"dizinin ka\u00e7 boyutlu oldu\u011fu:\",arr.ndim)\nprint(\"dizinin ka\u00e7 boyutlu oldu\u011fu:\",len(arr.shape))","a520d300":"arr_arange=np.arange(10)\nprint(\"varsay\u0131lan dtype:\",arr_arange.dtype)\nprint(arr_arange, end=\"\\n\\n\")\n\narr_empty=np.empty((3,3))\nprint(\"varsay\u0131lan dtype:\",arr_empty.dtype)\nprint(arr_empty, end=\"\\n\\n\")\n\narr_zeros=np.zeros((3,3))\nprint(\"varsay\u0131lan dtype:\",arr_zeros.dtype)\nprint(arr_zeros, end=\"\\n\\n\")\n\narr_ones=np.ones((3,3))\nprint(\"varsay\u0131lan dtype:\",arr_ones.dtype)\nprint(arr_ones, end=\"\\n\\n\")\n\nany_number=24\narr_any=np.ones((3,3))*any_number\nprint(\"varsay\u0131lan dtype:\",arr_any.dtype)\nprint(arr_any)","66f5095e":"empty_zeros=np.vstack(([arr_empty,arr_zeros]))\nprint(empty_zeros, end=\"\\n\\n\")\n\nones_any=np.hstack(([arr_ones, arr_any]))\nprint(ones_any)","73d7a970":"arr_arange=np.arange(0,20,3)\ni=3\nprint(arr_arange)\nprint(\"arr_arange[{}]:{}\".format(i, arr_arange[i]), end=\"\\n\\n\")\n\ni, j= 3,2\narr_nd=np.array([[1,2,3],\n                    [4,5,6],\n                    [7,8,9],\n                    [10, 11, 12]])\nprint(arr_nd)\nprint(\"arr_nd[{}][{}]:{}\".format(i, j, arr_nd[i][j]))\nprint(\"arr_nd[{},{}]:{}\".format(i, j, arr_nd[i,j]))","2bc5722b":"i, j=-3, -2\nprint(arr_arange)\nprint(\"arr_arange[{}]:{}\".format(i, arr_arange[i]), end=\"\\n\\n\")\n\narr_nd=np.array([[1,2,3],\n                    [4,5,6],\n                    [7,8,9],\n                    [10, 11, 12]])\nprint(arr_nd)\nprint(\"arr_nd[{}][{}]:{}\".format(i, j, arr_nd[i][j]))\nprint(\"arr_nd[{},{}]:{}\".format(i, j, arr_nd[i,j]))","540a3f71":"\nrow=0\ncol=2\nprint(arr_nd, end=\"\\n\\n\")\nprint(\"{}. sat\u0131r, arr_nd[{}]:{}\".format(row+1,row,  arr_nd[row]), end=\"\\n\\n\")\nprint(\"{}. sat\u0131r, arr_nd[{},]:{}\".format(row+1,row,  arr_nd[row,]), end=\"\\n\\n\")\nprint(\"{}. s\u00fct\u00fcn, arr_nd[:,{}]:{}\".format(col+1,col,  arr_nd[:,col]), end=\"\\n\\n\")","704b40d9":"import random\n#20 uzunlu\u011funda bir ndarray dizisi olu\u015fturuluyor\n#dizinin elemanlar\u0131 0 ile 19 aras\u0131ndaki de\u011ferlerden olu\u015fmaktad\u0131r.\narr=np.arange(20)\n#random.shuffle(arr)\n\n#dizi t\u00fcm elemanlar al\u0131n\u0131yor\narr_part=arr[:]\nprint(\"{:<10}:{}\".format(\"arr\",arr))\nprint(\"{:<10}:{}\".format(\"arr[:]\",arr_part),end=\"\\n\\n\")\n\nstart=4\nstop=19\n#4. ve 18. indeks aras\u0131ndaki elemanlar al\u0131n\u0131yor\narr_part=arr[start:stop]\nprint(\"{:<10}:{}\".format(\"arr\",arr))\nprint(\"{:<10}:{}\".format(\"arr[{}:{}]\".format(start,stop),arr_part),end=\"\\n\\n\")\n\nstart=4\nstop=-1\n#4. indeksten sonuncu elemana kadar olan elemanlar al\u0131n\u0131yor\narr_part=arr[start:stop]\nprint(\"{:<10}:{}\".format(\"arr\",arr))\nprint(\"{:<10}:{}\".format(\"arr[{}:{}]\".format(start,stop),arr_part),end=\"\\n\\n\")\n\n#4. indekste sonraki elemanlar al\u0131n\u0131yor\narr_part=arr[start:]\nprint(\"{:<10}:{}\".format(\"arr\",arr))\nprint(\"{:<10}:{}\".format(\"arr[{}:]\".format(start),arr_part),end=\"\\n\\n\")\n\n#dizi sondan ba\u015fa olacak \u015fekilde al\u0131n\u0131yor,yani ters d\u00f6nd\u00fcr\u00fcl\u00fcyor.\narr_part=arr[::-1]\nprint(\"{:<10}:{}\".format(\"arr\",arr))\nprint(\"{:<10}:{}\".format(\"arr[::-1]\",arr_part),end=\"\\n\\n\")\n\nstart=4\nstop=19\nstep=2\n#4. ve 18. indeks aras\u0131ndaki elemanlar al\u0131n\u0131yor\narr_part=arr[start:stop:step]\nprint(\"{:<11}:{}\".format(\"arr\",arr))\nprint(\"{:<10}:{}\".format(\"arr[{}:{}:{}]\".format(start,stop,step),\n                         arr_part),end=\"\\n\\n\")","768b9bea":"#yeni bir dizi olu\u015fturuluyor\narr=np.arange(20)\n#Dizi 4X5 bir matrisi d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcyor\n#reshape(yeniden \u015fekillendirmeyi) bir sonraki b\u00f6l\u00fcmde inceleyece\u011fiz\narr=arr.reshape(4,5) # veya arr=np.reshape(arr, (4,5))\n\nprint(\"orijinal arr:\\n\",arr, end=\"\\n\\n\")\n\nn=1\nprint(\"{}.sat\u0131r: {}\".format(n, arr[n]), end=\"\\n\\n\")\nprint(\"{}.s\u00fct\u00fcn: {}\".format(n, arr[:,n]), end=\"\\n\\n\")\n\nrow=3\ncol=4\narr_sub=arr[:row,:col]#\u00fc\u00e7 sat\u0131r al, d\u00f6rt s\u00fct\u00fcn al\nprint(\"{}:\\n{}\".format(\"arr[:{},:{}]\".format(row, col),arr_sub), end=\"\\n\\n\")\nstep=2\narr_sub=arr[:,::2]#t\u00fcm sat\u0131rlar\u0131 al, s\u00fct\u00fcnlar 2 atlamal\u0131 al \nprint(\"{}:\\n{}\".format(\"arr[:,::{}]\".format(step),arr_sub), end=\"\\n\\n\")\n\narr_sub=arr[::-1,::-1]#Matrisi ters d\u00f6nder\nprint(\"{}:\\n{}\".format(\"arr[::-1,::-1]\",arr_sub), end=\"\\n\\n\")","fc8a91c0":"#Bir boyutlu bir dizi olu\u015fturuluyor\narr1=np.arange(12)\n\n#yeni bir alt dizi elde ediliyor.\narr1_sub=arr1[1:10:2]\nprint(\"Alt Dizide De\u011fi\u015fiklik Yapmadan \u00d6nce\")\nprint(\"arr1    :\",arr1)\nprint(\"arr1_sub:\",arr1_sub, end=\"\\n\"*2)\n\narr1_sub[:]=255\nprint(\"Alt Dizide De\u011fi\u015fiklik Yapt\u0131ktan Sonra\")\nprint(\"arr1    :\",arr1)\nprint(\"arr1_sub:\",arr1_sub)","0a730237":"#Bir boyutlu bir dizi olu\u015fturuluyor\narr1=np.arange(12)\n\n#yeni bir alt dizi orijinal diziden ba\u011f\u0131ms\u0131z olarak elde ediliyor.\n#arr1_sub=arr1[1:10:2].copy() #1. y\u00f6ntem\narr1_sub=np.copy(arr1[1:10:2]) #2. y\u00f6ntem\nprint(\"Alt Dizide De\u011fi\u015fiklik Yapmadan \u00d6nce\")\nprint(\"arr1    :\",arr1)\nprint(\"arr1_sub:\",arr1_sub, end=\"\\n\"*2)\n\narr1_sub[:]=255\nprint(\"Alt Dizide De\u011fi\u015fiklik Yapt\u0131ktan Sonra\")\nprint(\"arr1    :\",arr1)\nprint(\"arr1_sub:\",arr1_sub)","8dad2107":"arr=np.arange(24)\n\narr_default=arr.reshape((6,4))# varsay\u0131lan olarak order=\"C\"\narr_C=arr.reshape((6,4), order='C')\narr_F=arr.reshape((6,4), order=\"F\")\n\nprint(\"arr:\",arr, end=\"\\n\\n\")\nprint(\"arr.reshape((6,4)):\\n\",arr_default,end=\"\\n\\n\")\nprint(\"arr.reshape((6,4), order='C'):\\n\",arr_C,end=\"\\n\\n\")\nprint(\"arr.reshape((6,4), order='F'):\\n\",arr_F,end=\"\\n\\n\")\n","458c63e1":"arr_F.reshape((24))","a57ae28c":"arr_F.reshape((24), order='F')","c75a3f0e":"arr_C.reshape((24))","3c6aff2e":"#24 -->2x3x4 d\u00f6n\u00fc\u015f\u00fcm\narr_3B=arr.reshape((2,3,4))\n\n#2x3x4 --> 12x2 d\u00f6n\u00fc\u015f\u00fcm\narr_2B=arr_3B.reshape((12,2))\n\nprint(\"arr:\",arr, end=\"\\n\\n\")\nprint(\"24 -->2x3x4 d\u00f6n\u00fc\u015f\u00fcm:\\n\",arr_3B, end=\"\\n\\n\")\nprint(\"2x3x4 --> 12x2 d\u00f6n\u00fc\u015f\u00fcm:\\n\",arr_2B, end=\"\\n\\n\")","5a8c529e":"arr1=np.ones((4), dtype=np.int32)\narr2=np.arange(4)\narr3=np.ones((4,4),dtype=np.int32)\n\nprint(\"arr1:\",arr1)\nprint(\"arr2:\",arr2)\n#Burada farkl\u0131 bir durum yok, e\u015fit boyutlara sahip iki vekt\u00f6r \n#toplan\u0131yor. \nprint(\"arr1+arr2:\",arr1+arr2, end=\"\\n\\n\")#\n\nprint(\"arr:\",arr1)\nprint(\"arr+2:\",arr1+2, end=\"\\n\\n\")\n\nprint(\"arr3:\\n\",arr3)\nprint(\"arr3+4:\\n\",arr3+4, end=\"\\n\\n\")","ace5e521":"arr4=np.arange(4).reshape((4,1))\nprint('arr4:', arr4)\narr5 =arr4.reshape(-1)\nprint('arr5:', arr5)\nprint('arr5.shape', arr5.shape)\narr6 =arr5.reshape((arr5.shape[0], 1))\nprint('arr6:',  arr6)\n\n#sat\u0131r vekt\u00f6rle matris toplan\u0131yor\nprint(\"arr3+arr2:\\n\",arr3+arr2, end=\"\\n\\n\")\n\n#s\u00fct\u00fcn vekt\u00f6rle matris toplan\u0131yor\nprint(\"arr3+arr4:\\n\",arr3+arr4)","405cefd9":"arr = np.arange(20).reshape(4,5)\nprint(arr)\nprint()\narr1 = arr.reshape(4, 5, 1)\nprint(arr1)\nprint()\nprint(arr1[0])","91537189":"row_vector=np.array([1,2,3,4])\ncol_vector=np.array([[1],[2],[3],[4]])\nprint(\"sat\u0131r vekt\u00f6r:\",row_vector)\nprint(\"s\u00fct\u00fcn vekt\u00f6r:\",col_vector)","f78a0f57":"#sat\u0131r vekt\u00f6r\u00fc s\u00fct\u00fcn vekt\u00f6r\u00fcne d\u00f6n\u00fc\u015ft\u00fcr\u00fcyor\n#D\u00f6n\u00fc\u015f\u00fcm yap\u0131l\u0131rken sat\u0131r vekt\u00f6rle s\u00fct\u00fcn vekt\u00f6r\u00fcn uzunluklar\u0131n\u0131n e\u015fit oldu\u011fundan emin olunmal\u0131d\u0131r.\n#Vekt\u00f6r\u00fc uzunluklar\u0131n\u0131n e\u015fit oldu\u011funu garantilemek i\u00e7in shape \u00f6zelli\u011fi kullan\u0131lm\u0131\u015ft\u0131r.\nprint(row_vector.reshape((row_vector.shape[0],1)))","c0cd48f6":"#s\u00fct\u00fcn vekt\u00f6r\u00fc sat\u0131r vekt\u00f6r\u00fcne d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcyor.\n#D\u00f6n\u00fc\u015f\u00fcm yap\u0131l\u0131rken s\u00fct\u00fcn vekt\u00f6rle sat\u0131r vekt\u00f6r\u00fcn uzunluklar\u0131n\u0131n e\u015fit oldu\u011funda emin olunmal\u0131d\u0131r.\n#Vekt\u00f6r\u00fc uzunluklar\u0131n\u0131n e\u015fit oldu\u011funu garantilemek i\u00e7in shape \u00f6zelli\u011fi kullan\u0131lm\u0131\u015ft\u0131r.\nprint(col_vector.reshape(col_vector.shape[0]))","402dbf88":"a=np.array([2, 4, 6, 8])\nb=np.array([1, 2, 3, 4])\n\nprint(\"a  :\",a)\nprint(\"b  :\",b)\nprint(\"a+b:\",a+b, end=\"\\n\\n\")\n\nprint(\"a  :\",a)\nprint(\"b  :\",b)\nprint(\"a-b:\",a-b, end=\"\\n\\n\")\n\nprint(\"a  :\",a)\nprint(\"b  :\",b)\nprint(\"a*b:\",a*b, end=\"\\n\\n\")\n\nprint(\"a  :\",a)\nprint(\"b  :\",b)\nprint(\"a\/b:\",a\/b, end=\"\\n\\n\")\n\nprint(\"a  :\",a)\nprint(\"b  :\",b)\nprint(\"a**b:\",a**b, end=\"\\n\\n\")\n\nprint(\"a  :\",a)\nprint(\"b  :\",b)\nprint(\"a%b:\",a%b, end=\"\\n\\n\")","14e8e7dc":"a=np.array([3, 11, 7])\ns=3\n\nprint(\"a   :\", a)\nprint(\"s   :\", s)\nprint(\"a+s :\", a+s, end=\"\\n\\n\")\n\nprint(\"a   :\", a)\nprint(\"s   :\", s)\nprint(\"a-s :\", a-s, end=\"\\n\\n\")\n\nprint(\"a   :\", a)\nprint(\"s   :\", s)\nprint(\"a*s :\", a*s, end=\"\\n\\n\")\n\nprint(\"a   :\", a)\nprint(\"s   :\", s)\nprint(\"a\/s :\", a\/s, end=\"\\n\\n\")\n\nprint(\"a   :\", a)\nprint(\"s   :\", s)\nprint(\"a**s :\", a**s, end=\"\\n\\n\")\n\nprint(\"a   :\", a)\nprint(\"s   :\", s)\nprint(\"a%s :\", a%s, end=\"\\n\\n\")","7177cc99":"a=np.array([1, 5, 3])\nb=np.array([2, 6, 1])\n\nc=a*b\na_dot_b= np.sum(c)\n\nprint(\"a   :\", a)\nprint(\"b   :\", b)\nprint(\"a.b :\", a_dot_b)","4086d4b6":"a_dot_b=a.dot(b)\nprint(\"a   :\", a)\nprint(\"b   :\", b)\nprint(\"a.b :\", a_dot_b)","d35f51d0":"a=np.array([1,-2,4,-5,1,-8,7,-2])\nl1=np.sum(np.absolute(a))\nl2=np.sqrt(np.sum(a**2))\nmax_norm=np.max(np.abs(a))\nmin_norm=np.min(np.abs(a))\nfrobenius_norm=np.sqrt(np.sum(a**2))\n\nprint(\"a       :\",a)\nprint(\"l1 norm :\",l1.astype(np.float32))\nprint(\"l2 norm :{:.2f}\".format(l2))\nprint(\"max norm:\", max_norm.astype(np.float32))\nprint(\"min norm:\", min_norm.astype(np.float32))\nprint(\"Frobenious norm:{:.2f}\".format(frobenius_norm))","acc368c2":"import math\nl1=np.linalg.norm(a, ord=1)\nl2=np.linalg.norm(a, ord=2)\nmax_norm=np.linalg.norm(a, ord=math.inf)\nmin_norm=np.linalg.norm(a, ord=-math.inf)\nfrobenius_norm=np.linalg.norm(a, ord=None)\n\nprint(\"a       :\",a)\nprint(\"l1 norm :\",l1)\nprint(\"l2 norm :{:.2f}\".format(l2))\nprint(\"max norm:\", max_norm)\nprint(\"min norm:\",min_norm)\nprint(\"Frobenius norm:{:.2f}\".format(frobenius_norm))","332d611f":"#S\u0131f\u0131rdan matris olu\u015fturuluyor.\n#\u0130ki boyutlu bir liste ndarray dizisine d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcyor\nA=np.array([[1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]])\n\n#Bir boyutlu dizi olu\u015fturluyor\nb=np.arange(1,13)\n#Dizi matrise d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcyor\nB=b.reshape(3,4)\n\n#T\u00fcm elemanlar\u0131 0 olan matris olu\u015fturuluyor\nC=np.zeros((3,4), dtype=np.int32)\n\n#T\u00fcm elemanlar\u0131n 1 olan matris olu\u015fturuluyor\nD=np.ones((3,4), dtype=np.int32)\n\n#T\u00fcm elemanlar\u0131 istenen say\u0131dan olu\u015fan matris olu\u015fturulor\nnumber=6\nE=np.ones((3, 4), dtype=np.int32)*number\n\nprint(\"A:\\n\", A, end=\"\\n\\n\")\n\nprint(\"b:\",b)\nprint(\"b.reshape(3,4):\\n\", B, end=\"\\n\\n\")\n\nprint(\"np.zeros((3,4), dtype=np.int32):\\n\", C, end=\"\\n\\n\")\n\nprint(\"np.ones((3,4), dtype=np.int32):\\n\", D, end=\"\\n\\n\")\n\nprint(\"np.ones((3, 4), dtype=np.int32)*{}:\\n\".format(number), E, end=\"\\n\\n\")","d93d63a6":"#[0,1) aras\u0131dan rasgele noktal\u0131 de\u011ferler i\u00e7eren matris olu\u015fturuluyor\nF=np.random.rand(3,4)\n\n#istenen aral\u0131kta rasgele tam say\u0131 de\u011ferler i\u00e7eren matris olu\u015fturuluyor\nG=np.random.randint(low=0,high=100,size=(3,4))\n\n#istenen aral\u0131kta rasgele noktal\u0131 de\u011fer i\u00e7eren matris olu\u015fturuluyor\nH=np.random.uniform(low=0, high=100, size=(3,4))\n\nprint(\"np.random.rand(3,4):\\n\",F, end=\"\\n\\n\")\nprint(\"np.random.randint(low=0,high=100,size=(3,4)):\\n\",G, end=\"\\n\\n\")\nprint(\"np.random.uniform(low=0, high=100, size=(3,4)):\\n\",H, end=\"\\n\\n\")","61050077":"A=np.random.randint(low=2, high=10,size=(2,3))\nB=np.ones((2,3),dtype=np.int32)*2\n\nprint(\"A:\\n\",A,end=\"\\n\\n\")\nprint(\"B:\\n\",B,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A+B:\\n\",A+B,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A-B:\\n\",A-B,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A*B:\\n\",A*B,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A\/B:\\n\",A\/B,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A^B:\\n\",A**B,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A%B:\\n\",A%B,end=\"\\n\\n\")","24d05b90":"A=np.random.randint(low=2, high=10,size=(2,3))\ns=np.random.randint(1,5)\n\nprint(\"A:\\n\",A,end=\"\\n\")\nprint(\"s:\",s,end=\"\\n\")\nprint(\"=\"*80)\n\nprint(\"A+s:\\n\",A+s,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A-s:\\n\",A-s,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A*s:\\n\",A*s,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A\/s:\\n\",A\/s,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A^s:\\n\",A**s,end=\"\\n\\n\")\nprint(\"=\"*80)\n\nprint(\"A%s:\\n\",A%s,end=\"\\n\\n\")","a7a78de3":"def dot_product(first_matris, second_matris):\n    C=[]\n    C_row=[]\n\n    #Birinci matrisin sat\u0131rlar\u0131 al\u0131n\u0131yor\n    for row in first_matris:\n        \n        #\u0130kinci matrisin s\u00fct\u00fcnlar\u0131 al\u0131n\u0131yor\n        for col in second_matris.T:# T matrisin transpozu al\u0131n\u0131yor\n            #Birinci matrisin ilgili sat\u0131r\u0131yla ikinci matrisin t\u00fcm s\u00fct\u00fcnlar\u0131\n            #\u00e7arp\u0131larak sonu\u00e7 matrisin sat\u0131rlar\u0131 elde ediliyor\n            C_row.append(row.dot(col))\n        \n        #Sat\u0131rlar sonu\u00e7 matrisine ekleniyor\n        C.append(C_row)\n        #Bir sonraki sat\u0131r i\u00e7in sat\u0131r s\u0131f\u0131rlan\u0131yor\n        C_row=[]\n\n    return np.array(C)","c80c2b30":"A=np.random.randint(low=0, high=3,size=(2,3))\nB=np.random.randint(low=0, high=3, size=(3,4))\n\nC=dot_product(A,B)\n\nprint(\"A:\\n\",A, end=\"\\n\\n\")\nprint(\"B:\\n\",B, end=\"\\n\")\nprint(\"=\"*80)\nprint(\"A.B:\\n\",C)","fda0f6dc":"C=A.dot(B)\nprint(C)","4a3243b7":"\"\"\"\nKare matrisler sat\u0131r ve s\u00fct\u00fcnlar\u0131 e\u015fit \nmatrislerdir. \n\"\"\"\nn=5\nA=np.arange(n*n).reshape((n,n))\nprint(A)","87c56f59":"n=4\nS=np.zeros((n,n),dtype=np.int32)\n\n#Rasgele de\u011fer i\u00e7eren simetrik matris olu\u015fturuluyor\nfor i in range(n):\n    for j in range(0, n-i):\n        S[i,j]=np.random.randint(1,5)\n        S[n-j-1,n-i-1]=S[i,j]\nprint(S)","27eefaa1":"n=4\nLT=np.zeros((n,n),dtype=np.int32)\n\n#Rasgele de\u011fer i\u00e7eren alt \u00fc\u00e7gensel matris olu\u015fturuluyor\nfor i in range(n):\n    for j in range(n):\n            if j<=i:\n                LT[i,j]=np.random.randint(1,5)\nprint(LT)","d3d51849":"n=4\nUT=np.zeros((n,n),dtype=np.int32)\n\n#Rasgele de\u011fer i\u00e7eren \u00fcst \u00fc\u00e7gensel matris olu\u015fturuluyor\nfor i in range(n):\n    for j in range(n):\n            if j>=i:\n                UT[i,j]=np.random.randint(1,5)\nprint(UT)","70d07751":"n=4\nm=6\nDM=np.zeros((n,m),dtype=np.int32)\n\n#Rasgele de\u011fer i\u00e7eren k\u00f6\u015fegen matris olu\u015fturuluyor\n#K\u00f6\u015fegen matrislerin kare matris olma zorunlulu\u011fu yoktur\n#Dikd\u00f6rtgen matrislerde k\u00f6\u015fegen k\u0131sa kenar\u0131n uzunlu\u011fu kadard\u0131r\nfor i in range(n):\n    for j in range(m):\n            if j==i:\n                DM[i,j]=np.random.randint(1,5)\nprint(DM)","c3cd9241":"n=4\n\nI=np.zeros((n,n),dtype=np.int32)\n\n#Birim matris, k\u00f6\u015fegeni 1 olan kare matristir. \nfor i in range(n):\n    I[i,i]=1\nprint(I)","00264a89":"#Alt \u00fc\u00e7gensel matris\nLT=np.tril(A)\n\nprint(\"A:\\n\",A, end=\"\\n\\n\")\nprint(\"A alt \u00fc\u00e7gen matrisi\\n\",LT)","c4b25215":"#\u00dcst \u00fc\u00e7gensel matris\nUT=np.triu(A)\n\nprint(\"A:\\n\",A, end=\"\\n\\n\")\nprint(\"A alt \u00fc\u00e7gen matrisi\\n\",UT)","88ace8c7":"diagonal=np.diag(A)\nA_diagonal=np.diag(diagonal)\n\nprint(\"A:\\n\",A,end=\"\\n\\n\")\nprint(\"A k\u00f6\u015fegeni:\\n\",diagonal, end=\"\\n\\n\")\nprint(\"K\u00f6\u015fegenden olu\u015fturulan matris:\\n\",A_diagonal)","c12e3b77":"#Birim matris\nn=3\nI=np.identity(n)\nprint(I)","720da64b":"A=np.arange(15).reshape((3,5))\n\nA_T=np.zeros((A.shape[1],A.shape[0]), dtype=np.int32)\n\nfor i, row in enumerate(A):\n    A_T[:,i]=row\n\nprint(\"A:\\n\",A, end=\"\\n\\n\")\nprint(\"A transpozu:\\n\",A_T)","d7e4cf91":"from numpy.random import RandomState\nrnd=RandomState(42)\nn=4\nA=np.zeros((n,n))\nfor i in range(n):\n    for j in range(n):\n            A[i,j]=rnd.randint(0,3)\n\nA_inv=np.linalg.inv(A)\nprint(\"A:\\n\",A,end=\"\\n\\n\")\nprint(\"A matrisin tersi A^-1:\\n\",A_inv,end=\"\\n\\n\")\nprint(\"A matrisinin tersiyle \u00e7arp\u0131m\u0131 A.A^-1:\\n\",A.dot(A_inv))","84e2dae9":"n=4\nA=np.arange(n*n).reshape((n,n))\n\n#A_trace=np.sum(np.diag(A))\nA_trace=np.trace(A)\nprint(\"A:\",A, end=\"\\n\\n\")\nprint(\"A matrisinin izi:\",A_trace)","9aa3ac1f":"rnd=RandomState(24)\nn=4\nA=np.zeros((n,n))\nfor i in range(n):\n    for j in range(n):\n            A[i,j]=rnd.randint(0,3)\n\nA_det=np.linalg.det(A)           \nprint(\"A:\\n\",A,end=\"\\n\\n\")\nprint(\"A matrisinin determinant\u0131:\",A_det)","d5700bae":"print(np.linalg.matrix_rank(A))","bd8c9a78":"n=4\nA=np.arange(n*n).reshape((n,n))\nprint(np.linalg.matrix_rank(A))","295a7be3":"A=np.arange(1,17).reshape(4,4)\n\n\nP, L, U=sp.linalg.lu(A)\nprint(\"A:\\n\",A,end=\"\\n\\n\")\nprint(\"P:\\n\",P, end=\"\\n\\n\")\nprint(\"L:\\n\",L,end=\"\\n\\n\")\nprint(\"U:\\n\",U, end=\"\\n\\n\")\nprint(\"L.U.P:\\n\",P.dot(L).dot(U))","3d874299":"A=A.reshape((8,2))\nQ, R =sp.linalg.qr(A)\n\nprint(\"A:\\n\",A,end=\"\\n\\n\")\nprint(\"Q:\\n\",Q, end=\"\\n\\n\")\nprint(\"R:\\n\",R,end=\"\\n\\n\")\nprint(\"Q.R:\\n\",Q.dot(R))","a4267db7":"#Cholesky ayr\u0131\u015f\u0131m\u0131na uygun matris elde etmenin kendimce\n#kolay yolu oldu\u011fu i\u00e7in pozitif tan\u0131ml\u0131 matrisi a\u015fa\u011f\u0131daki gibi elde ettim.\n#Pozitif tan\u0131ml\u0131 matrisler benim elde etti\u011fimden \u00e7ok daha detayl\u0131 yap\u0131ya sahiptirler.\n\nn=4\nS=np.zeros((n,n), dtype=np.uint32)\n\nkosegen=np.random.randint(1,4)\nother=np.random.randint(1,4)\n\nwhile kosegen==other:\n    other=np.random.randint(1,4)\n\nfor i in range(n):\n    for j in range(n):\n        if i ==j:\n            S[i,j]=kosegen\n        else:\n            S[i,j]=other\n            S[j,i]=other","b70fa399":"L=np.linalg.cholesky(S)","84d26b18":"print(\"S:\\n\",S,end=\"\\n\\n\")\nprint(\"L:\\n\",L,end=\"\\n\\n\")\nprint(\"L.L^T:\\n\",L.dot(L.T))\n","a5e974b0":"n=3\nA=np.zeros((n,n),dtype=np.int32)\nfor i in range(n):\n    for j in range(n):\n        A[i,j]=np.random.randint(1,10)\n\negienvalues, egienvectors=np.linalg.eig(A)\n\nprint(\"\u00d6z de\u011ferler:\\n\",egienvalues,end=\"\\n\\n\")\nprint(\"\u00d6z vekt\u00f6rler matrisi:\\n\",egienvectors, end=\"\\n\\n\")\nfor i, egienvector in enumerate(egienvectors.T):\n    print(\"{}. \u00f6z vekt\u00f6r:{}\".format(i+1,egienvector))","2628dc26":"n=1\nprint(\"egienvectors[:,{}]*egienvalues[{}]:{}\".format(\n    n,\n    n,\n    egienvectors[:,n]*egienvalues[n])\n     )\nprint(\"A.dot(egienvectors[:,{}])        :{}\".format(n,A.dot(egienvectors[:,n])))","8d660b4f":"LAMBDA=np.diag(egienvalues)\nprint(\"A:\\n\",A,end=\"\\n\\n\")\nprint(\"Q:\\n\",egienvectors,end=\"\\n\\n\")\nprint(\"LAMBDA:\\n\",LAMBDA,end=\"\\n\\n\")\nprint(\"Q^-1:\\n\",np.linalg.inv(egienvectors),end=\"\\n\\n\")\nprint(\"Q.LAMBDA.Q^-1:\\n\",egienvectors.dot(LAMBDA).dot(np.linalg.inv(egienvectors)))","9409c213":"n=3\nm=4\nA=np.zeros((n,m),dtype=np.int32)\nfor i in range(n):\n    for j in range(m):\n        A[i,j]=np.random.randint(1,10)\n\n#scipy k\u00fct\u00fcphanesindeki svd fonksiyonunu kullanarak SVD \n#bile\u015fenlerini elde ediliyor\nU, singular_value, V=sp.linalg.svd(A)\n\nrow, col=A.shape\nlesser=min(row,col)\nSIGMA=np.zeros((row, col))\n\n#SIGMA kare matris olmad\u0131\u011f\u0131 i\u00e7in k\u00f6\u015fegen matrisi\n#bu \u015fekilde olu\u015fturuyoruz\nSIGMA[:lesser, :lesser]=np.diag(singular_value)\n\n\nprint(\"A:\\n\",A, end=\"\\n\\n\")\nprint(\"U:\\n\",U, end=\"\\n\\n\")\nprint(\"SIGMA:\\n\",SIGMA,end=\"\\n\\n\")\nprint(\"V:\\n\",V, end=\"\\n\\n\")\nprint(U.dot(SIGMA.dot(V)))","fd85534f":"iris=pd.read_csv(\"..\/input\/iris\/Iris.csv\")","2e7fa98b":"iris.head()","69e3281c":"sns.countplot(iris['Species'])","6c7a6d91":"dataset=iris[iris['Species']!=\"Iris-virginica\"]\nsns.countplot(dataset['Species'])","77a04ddf":"dataset['Species']=dataset.Species.map({'Iris-setosa':-1,\n              'Iris-versicolor':1})","f5f4b16d":"X=dataset.drop([\"Id\",\"Species\"],  axis=1)\ny=dataset['Species']\n\nprint(\"X.shape:\",X.shape)\nprint(\"y.shape:\",y.shape)","e0130cc7":"X_train, X_test, y_train, y_test=train_test_split(X.values, \n                                                  y.values, \n                                                  stratify=y, \n                                                  test_size=0.4,\n                                                 random_state=42) ","445cd0f5":"class Perceptron:\n    \n    \n    def __init__(self, learning_rate, number_of_iterations, classes):\n        self.learning_rate=learning_rate\n        self.number_of_iterations=number_of_iterations\n        self.w=None\n        self.errors=[]\n        if len(classes)!=2:\n            raise ValueError(\"Number of class should be 2\")\n        else:\n            self.class1=classes[0]\n            self.class2=classes[1]\n            self.thres=sum(classes)\/len(classes)\n            print(\"class1:\",self.class1)\n            print(\"class2:\",self.class2)\n            print(\"thres:\",self.thres)\n    \n    def _get_error(self, update):\n        if update==0.0:\n            return 0\n        return 1\n    \n    def fit(self, X_train, y_train):\n        feature_size=X_train.shape[1]\n        self.w=np.zeros(1+feature_size)\n        \n        for i in range(self.number_of_iterations):\n            error=0\n            \n            for xi, yi in zip(X_train, y_train):\n                update=self.learning_rate*(yi-self.predict(xi))\n                self.w[1:]=self.w[1:]+update*xi\n                self.w[0]=self.w[0]+update\n                error=error+ self._get_error(update)\n            \n            self.errors.append(error)\n        \n    def net_input(self, X):\n        \n        net=np.dot(X, self.w[1:])+self.w[0]\n        return net\n    \n    def predict(self, X):\n        pred=self.step(X)\n        return pred\n    \n    def step(self,X):\n        return np.where(self.net_input(X)>=self.thres, self.class1, self.class2)\n","93b44a77":"perceptron=Perceptron(learning_rate=0.01, number_of_iterations=10, classes=[1,-1])\n\nperceptron.fit(X_train, y_train)\ny_pred=perceptron.predict(X_test)","093fa84e":"def performance_metrics(y_true, y_pred,\n            accuracy=True, confusion_matrix=True, classification_report=True):\n    if accuracy:\n        print(\"Ba\u015far\u0131 oran\u0131(%):\",metrics.accuracy_score(y_true, y_pred)*100,end=\"\\n\\n\")\n    if confusion_matrix:\n        print(\"Kar\u0131\u015f\u0131kl\u0131k Matrisi:\\n\",\n              metrics.confusion_matrix(y_true, y_pred),end=\"\\n\\n\")\n   \n    if classification_report:\n        print(\"S\u0131n\u0131fland\u0131rma Raporu:\\n\",\n              metrics.classification_report(y_true, y_pred),end=\"\\n\\n\")","61c786ec":"performance_metrics(y_true=y_test, y_pred=y_pred)","c49035db":"fig, ax=plt.subplots(1,2,figsize=(12,6))\nsns.swarmplot(data=dataset,\n              x=\"SepalLengthCm\", \n              y=\"SepalWidthCm\", \n              hue=\"Species\", \n              ax=ax[0])\nsns.swarmplot(data=dataset,\n              x=\"PetalLengthCm\", \n              y=\"PetalWidthCm\", \n              hue=\"Species\", \n              ax=ax[1])","28dd9305":"\nX_and = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])\n\ny_and = np.array([[0], [0], [0], [1]])\ny_and=np.array([0, 0, 0, 1])\n\nperceptron=Perceptron(learning_rate=0.01, number_of_iterations=20, classes=[1,0])\n\nperceptron.fit(X_and, y_and)\ny_pred=perceptron.predict(X_and)\n\nprint(\"\\n\\nAND \u0130\u00e7in Perceptron Modelinin S\u0131n\u0131fland\u0131rma Performans\u0131\\n\")\nperformance_metrics(y_true=y_and, y_pred=y_pred)","6f6febdf":"X_or = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])\n\ny_or = np.array([[0], [1], [1], [1]])\n\nperceptron=Perceptron(learning_rate=0.01, number_of_iterations=20, classes=[1,0])\n\nperceptron.fit(X_or, y_or)\ny_pred=perceptron.predict(X_or)\n\nprint(\"\\n\\nOR \u0130\u00e7in Perceptron Modelinin S\u0131n\u0131fland\u0131rma Performans\u0131\\n\")\nperformance_metrics(y_true=y_or, y_pred=y_pred)","81f25cc7":"X_xor = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])\n\ny_xor = np.array([[0], [1], [1], [0]])\n\nperceptron=Perceptron(learning_rate=0.01, number_of_iterations=20, classes=[1,0])\n\nperceptron.fit(X_xor, y_xor)\ny_pred=perceptron.predict(X_xor)\n\nprint(\"\\n\\nXOR \u0130\u00e7in Perceptron Modelinin S\u0131n\u0131fland\u0131rma Performans\u0131\\n\")\nperformance_metrics(y_true=y_xor, y_pred=y_pred)","0db07aa4":"fig, axarr=plt.subplots(nrows=1, ncols=3, figsize=(15,4))\n\n#AND grafi\u011fi \u00e7izdiriliyor\naxarr[0].scatter(x=X_and[:,0], y=X_and[:,1], color=['green', 'green', 'green', 'red'] )\naxarr[0].plot([0,1],[1.2,0.5])\n\n#OR grafi\u011fi \u00e7izdiriliyor\naxarr[1].scatter(x=X_or[:,0], y=X_or[:,1], color=['green', 'red', 'red', 'red'] )\naxarr[1].plot([0,1],[0.5,-0.2])\n\n#XOR grafi\u011fi \u00e7izdiriliyor\naxarr[2].scatter(x=X_xor[:,0], y=X_xor[:,1], color=['green', 'red', 'red', 'green'] )\naxarr[2].plot([0,1],[0.5,0.5])\n\nfor ax, title in zip(axarr.flatten(),['AND', 'OR', 'XOR']):\n    ax.set_xticks([0,1])\n    ax.set_yticks([0,1])\n    ax.set_title(title)\nplt.show()","b4b69054":"class MyPCA():\n    def __init__(self, n):\n        self.number_of_component=n\n    \n    def fit(self, X):\n        self.M=np.mean(X.T,axis=1)\n        \n        C=X-self.M\n        \n        V=np.cov(C.T)\n        \n        self.eigen_values, self.eigen_vectors=np.linalg.eig(V)\n        \n        self.__calculate_explained_variance()\n        \n        self.__construct_projection_matrix()\n    \n    def transform(self, X):\n        C=X-self.M\n        X_new=self.projection_matrix.T.dot(C.T)\n        return X_new.T\n    \n    def fit_transform(self,X):\n        self.fit(X)\n        return self.transform(X)\n    \n    def __construct_projection_matrix(self):\n        eigen_pairs=self.__get_eigen_pairs()\n        \n        \n        n_eigen_pairs=eigen_pairs[:self.number_of_component]\n        \n        sorted_eigen_vectors=[eigen_pair[1][:,np.newaxis] for eigen_pair in n_eigen_pairs]\n        \n        self.projection_matrix=np.hstack(sorted_eigen_vectors)\n    \n    def __get_eigen_pairs(self):\n        eigen_pairs=list()\n        for i in range(len(self.eigen_values)):\n            eigen_pairs.append((np.abs(self.eigen_values[i]),self.eigen_vectors[:,i]))\n        \n        eigen_pairs.sort(key=lambda k:k[0], reverse=True)\n        \n        return eigen_pairs\n    \n    def __calculate_explained_variance(self):\n        sum_of_eigen_values=sum(self.eigen_values)\n        \n        self.variance_=[(eigen_value\/sum_of_eigen_values) for eigen_value in self.eigen_values]\n        \n        self.explained_variance_=np.cumsum(self.variance_)\n        ","7c3c35d6":"A=np.arange(1,13).reshape(4,3)","a43981fc":"my_pca=MyPCA(n=2)\nmy_pca.fit(A)\nP=my_pca.transform(A)\n\nprint(A)\nprint(\"P:\\n\",P)\nprint(my_pca.eigen_vectors)","f034ec19":"from sklearn.decomposition import PCA\npca=PCA(n_components=2)\npca.fit(A)\nP=pca.transform(A)\n\nprint(A)\nprint(\"P:\\n\",P)\nprint(pca.components_)","43532c5d":"Yukar\u0131daki grafiklerde AND, OR ve XOR mant\u0131ksal kap\u0131lar\u0131n\u0131n grafikleri vard\u0131r. Grafiklerdeki ye\u015fil noktalar 0 de\u011ferini ve k\u0131rm\u0131z\u0131 noktalar 1 de\u011ferini g\u00f6stermektedir.  AND ve OR kap\u0131lar\u0131n\u0131n \u00fcretti\u011fi \u00e7\u0131kt\u0131lar\u0131 bir do\u011fruyla ayr\u0131labilirken, XOR kap\u0131s\u0131n\u0131n \u00fcretti\u011fi \u00e7\u0131kt\u0131rlar bir do\u011fruyla ayr\u0131lamamaktad\u0131r. ","6e14f4bb":"\u0130ki vekt\u00f6r aras\u0131nda aritmetik i\u015flemler yap\u0131labildi\u011fi gibi bir vekt\u00f6rle bir skaler aras\u0131nda da aritmetik i\u015flemler yap\u0131labiilir. \n\na ve s a\u015fa\u011f\u0131daki gibi tan\u0131mlanan vekt\u00f6r ve skaler olsun:\n* a=(a1, a2, a3)\n* s=reel say\u0131\n\na ve s aras\u0131ndaki aritmetik i\u015flemler a\u015fa\u011f\u0131daki gibi tan\u0131mlan\u0131r:\n* a+s=(a1+s, a2+s, a3+s)\n* a- s=(a1-s, a2-s, a3-s)\n* a*s=(a1*s, a2*s, a3*s)\n* a\/s=(a1\/s, a2\/s, a3\/s)\n* a^s=(a1^s, a2^s, a3^s)\n* a%s=(a1%s, a2%s, a3%s)","ced0d96f":"<a class=\"anchor\" id=\"3.2.\"><\/a>**3.2. Matrislerde Aritmetik \u0130\u015flemler** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nE\u015fit \u00f6l\u00e7\u00fclerde iki matris aras\u0131nda, vekt\u00f6rlerde oldu\u011fu gibi,  i\u015flemler ger\u00e7ekle\u015ftirilebilir. Aritmetik i\u015flem yap\u0131lacak iki matrisin \u00f6l\u00e7\u00fcleri e\u015fit olmas\u0131 gerekir. \u0130ki e\u015fit \u00f6l\u00e7\u00fclerdeki matris aras\u0131ndaki aritmetik i\u015flemler, ayn\u0131 konumdaki matris \u00f6gelerine uygulanarak ger\u00e7ekle\u015ftirilir.\n\nA ve B a\u015fa\u011f\u0131daki gibi tan\u0131mlanm\u0131\u015f iki matris olsun:\n* A=((a11, a12, a13),(a21, a22, a23))\n* B=((b11, b12, b13),(b21, b22, b23))\n\n\u0130ki matris aras\u0131nda ger\u00e7ekle\u015ftirilebilecek aritmetik i\u015flemler: +, -, * ,  \/, ** , %\n\nBu iki vekt\u00f6r aras\u0131ndaki aritmetik i\u015flemler a\u015fa\u011f\u0131daki gibi ger\u00e7ekle\u015ftirilir:\n* Toplama    : A+B=((a11+b11, a12+b12, a13+b13),(a21+b21, a22+b22, a23+b23))\n* \u00c7\u0131karma    : A-B=((a11-b11, a12-b12, a13-b13),(a21-b21, a22-b22, a23-b23))\n* \u00c7arpma     : A*B=((a1*b11, a12*b12, a13*b13),(a21*b21, a22*b22, a23*b23))\n* B\u00f6lme        : A\/B=((a11\/b11, a12\/b12, a13\/b13),(a21\/b21, a22\/b22, a23\/b23))\n* \u00dcst alma   : A^B=((a11^b11, a12^b12, a13^b13),(a21^b21, a22^b22, a23^b23))\n* Mod alma : A%B=((a11%b11, a12%b12, a13%b13),(a21%b21, a22%b22, a23%b23))","f93bf49c":"<a class=\"anchor\" id=\"1.5.\"><\/a>**1.5. ndarray Dizilerini \u00dcst \u00dcste ve Yan Yana Eklemek** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nNumpy var olan ndarray dizilerinden yeni diziler t\u00fcretmek i\u00e7in bir\u00e7ok fonksiyona sahiptir. Bunlardan \u00f6ne \u00e7\u0131kanlar **vstack** ve **hstack** fonksiyonlar\u0131d\u0131r. **vstack** var olan dizileri \u00fcst \u00fcste birle\u015ftirmeye yararken, **hstack** fonksiyonu var olan dizileri yan yana birle\u015ftirmeye yarar. **vstack** kullan\u0131larak birle\u015ftirilecek dizilerin geni\u015fliklerinin e\u015fit olmas\u0131 ve **hstack** kullan\u0131larak birle\u015ftirilecek dizilerin y\u00fcksekliklerinin e\u015fit olmas\u0131 gerekir.  Bu fonksiyonlar g\u00f6r\u00fcnt\u00fcleri birle\u015ftirerek galeri olu\u015fturmada olduk\u00e7a kullan\u0131\u015fl\u0131d\u0131r. Bu konudaki \u00f6rne\u011fe [Face Detection with OpenCV](https:\/\/www.kaggle.com\/serkanpeldek\/face-detection-with-opencv) \u00e7al\u0131\u015fmas\u0131nda g\u00f6rebilirsiniz. ","55ce6632":"<a class=\"anchor\" id=\"5.1.3.\"><\/a>**5.1.3. Perceptron Modelinin Iris Veri Seti \u00dczerinde Kullan\u0131lmas\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nOlu\u015fturdu\u011fumuz Perceptron s\u0131n\u0131f\u0131n\u0131 iris veri seti \u00fczerinde kullanal\u0131m. \u0130lk \u00f6nce Perceptron nesnesi olu\u015fturulur. Daha sonra fit fonksiyonuna e\u011fitim k\u00fcmeleri verilerek e\u011fitim a\u015famas\u0131 ger\u00e7ekle\u015ftirilir. Son olarak predict fonksiyonu kullan\u0131larak test k\u00fcmesinin s\u0131n\u0131fland\u0131rmas\u0131 yap\u0131l\u0131r. ","98e611d5":"<a class=\"anchor\" id=\"1.7.\"><\/a>**1.7. ndarray Dizilerinin Dilimlenmesi** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nBir \u00f6nceki b\u00f6l\u00fcmde python listelerinde ve  numpy dizilerinde indeks mant\u0131\u011f\u0131n\u0131 g\u00f6rd\u00fck. Bu b\u00f6l\u00fcmde bir boyutlu ve iki boyutlu dizilerin dilimlenmesini g\u00f6rece\u011fiz. Daha \u00f6nce C++ tabanl\u0131 dillere a\u015f\u0131na olanlar Python dizilerinin dilimlenmesinde zorluk ya\u015fayabiliyor. Ancak dizilerin dilimlenmesi bir\u00e7ok kolayl\u0131\u011f\u0131 sa\u011flayan bir i\u015flev. Python ile yaz\u0131lan, hemen hemen t\u00fcm kodlarda dizilerin dilimlenmesini g\u00f6rmek m\u00fcmk\u00fcn. \n\nDizilerin dilimlenmesi dizinin bir b\u00f6l\u00fcm\u00fcn\u00fc elde etme i\u015flemidir. Bu i\u015flem dizinin elde edilecek k\u0131sm\u0131n\u0131n ba\u015flang\u0131\u00e7 ve biti\u015f indekslerini belirtmekle ger\u00e7ekle\u015ftirilir. \n\n<a class=\"anchor\" id=\"1.7.1.\"><\/a>**1.7.1. Bir Boyutlu ndarray Dizilerinin Dilimlenmesi** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nDizilerin dilimlenmesine bir boyutlu dizilerden ba\u015flayal\u0131m. Bir boyutlu dizilerde dizi dilimle basit\u00e7e \u015f\u00f6yle ger\u00e7ekle\u015ftirilir:\n\ndizi_dilimi=dizi[**ba\u015flang\u0131\u00e7**:**biti\u015f**]\n\nYukar\u0131daki dilimleme i\u015fleminde dizinin **ba\u015flang\u0131\u00e7** indeksiyle **biti\u015f-1** indeksindeki t\u00fcm de\u011ferler **dizi_dilimi** de\u011fi\u015fkeni atan\u0131r. **dizi_dilimi** de\u011fi\u015fkeni **dizi** de\u011fi\u015fkeniyle ayn\u0131 ayn\u0131 t\u00fcrde bir dizi olur.\n\nDizi dilimlemeye ad\u0131m uzunlu\u011fu eklemek de m\u00fcmk\u00fcnd\u00fcr. Bunun i\u00e7in ba\u015flang\u0131\u00e7 ve biti\u015f indekslerine ad\u0131m uzunlu\u011fu eklemek yeterli olacakt\u0131r. Bu i\u015flem basit\u00e7e \u015f\u00f6yle ger\u00e7ekle\u015ftirilir:\n\ndizi_dilimi=dizi[**ba\u015flang\u0131\u00e7**:**biti\u015f**:**ad\u0131m uzunlu\u011fu**]\n\nA\u015fa\u011f\u0131daki kod b\u00f6l\u00fcmde bir boyutlu dizilerin dilimlenmesine ait \u00f6rnekler yer almaktad\u0131r. Yap\u0131lan \u00f6rneklerde eksi(-) indeksleme \u00f6zelli\u011fi de kullan\u0131lm\u0131\u015ft\u0131r. ","9354147a":"<a class=\"anchor\" id=\"1.4.\"><\/a>**1.4. ndarray Olu\u015fturmak \u0130\u00e7in Kullan\u0131labilecek \u00d6n Tan\u0131ml\u0131 Fonksiyonlar** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nNumpy, istenilen de\u011fiken t\u00fcr\u00fcne ve array \u015fekline sahip diziler olu\u015fturmada kullan\u0131labilecek fonksiyonlara sahiptir; **arange()**,  **empty(), zeros(), ones()**.  arange() d\u0131\u015f\u0131ndaki t\u00fcm fonksiyonlar 1 ve daha fazla boyutta dizi olu\u015fturmak i\u00e7in kullan\u0131labilir. arange() fonksiyonu, sadece tek boyutlu diziler olu\u015fturmak i\u00e7in kullan\u0131labilir.","26e82a4e":"<a class=\"anchor\" id=\"1.9.\"><\/a>**1.9. Farkl\u0131 Boyutlarda\/\u015eekillerde ndarray Dizilerde Aritmetik \u0130\u015flemler** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nFarkl\u0131 boyutta dizilerle toplama, \u00e7\u0131karma yap\u0131lamaz. Daha genel bir tan\u0131mla; herhangi bir aritmetik i\u015flem yap\u0131lamaz.  Bu s\u0131n\u0131rlamayla ba\u015fa \u00e7\u0131kman\u0131n yolu k\u00fc\u00e7\u00fck boyuttaki diziyi b\u00fcy\u00fck boyuttaki dizinin \u00f6l\u00e7\u00fclerine getirmektedir. Bunu i\u00e7in k\u00fc\u00e7\u00fck boyuttaki dizi \u00e7o\u011falt\u0131l\u0131r. Bu i\u015fleme **broadcasting** ad\u0131 verilir ve Numpy bu i\u015flemleri kolayl\u0131kla yapmam\u0131za olanak sa\u011flar.","9f9b381b":"[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n# <a class=\"anchor\" id=\"1.\"><\/a>**1. NUMPY** \n\nNumpy, Python makine \u00f6\u011frenmesi k\u00fct\u00fcphanelerinin temelini olu\u015fturur. Makine \u00f6\u011frenimi modellerinin kulland\u0131\u011f\u0131 vekt\u00f6r, matris ve tensor gibi veri yap\u0131lar\u0131 \u00fczerinde verimli i\u015flemler yapmaya imkan sunar. Bu b\u00f6l\u00fcmde makine \u00f6\u011frenmesi modelleriyle \u00e7al\u0131\u015f\u0131l\u0131rken s\u0131k\u00e7a kullan\u0131lan Numpy ile vekt\u00f6r, matris ve diziler \u00fczerinde i\u015flemlerin nas\u0131l yap\u0131ld\u0131\u011f\u0131 anlat\u0131lacakt\u0131r. ","d75d8ea8":"Numpy, bilimsel ve numerik uygulamalar i\u00e7in kullan\u0131labilen ve cebirsel i\u015flemler yapmaya olanak sa\u011flayan bir Python k\u00fct\u00fcphanesidir. Numpy'daki ana veri yap\u0131s\u0131 N-boyutlu dizidir ve k\u0131sace **ndarray** olarak adland\u0131r\u0131l\u0131r. \n\nPython'da 'list' tipindeki bir veri yap\u0131s\u0131 kolayl\u0131kla 'ndarray' tipindeki bir veri yap\u0131s\u0131na d\u00f6n\u00fc\u015ft\u00fcr\u00fclebilir. ","67f1b0f4":"<a class=\"anchor\" id=\"2.3.\"><\/a>**2.3. Nokta \u00c7arp\u0131m\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nBir \u00f6nceki b\u00f6l\u00fcmde anlat\u0131lan vekt\u00f6rel aritmetik i\u015flemler normal aritmetik i\u015flemlerden pek farkl\u0131 de\u011fildi. Aritmetik i\u015flemler ayn\u0131 konumdaki vekt\u00f6r \u00f6gelerine uygulanarak ger\u00e7ekler\u015ftiriliyordu. Nokta \u00e7arp\u0131m\u0131 normal aritmetik i\u015flemlerden farkl\u0131 hesaplama yoluna sahiptir.\n\nNokta \u00e7arp\u0131m\u0131 e\u015fit uzunluktaki iki vekt\u00f6r\u00fcn ayn\u0131 konumdaki \u00f6gelerinin \u00e7arp\u0131m\u0131 ve \u00e7arp\u0131m sonu\u00e7lar\u0131n\u0131n toplam\u0131yla ger\u00e7ekle\u015ftirilir. \u0130ki vekt\u00f6r\u00fcn nokta \u00e7arp\u0131mlar\u0131n\u0131n sonucu bir skaler de\u011ferdir. \n\na ve b a\u015fa\u011f\u0131daki gibi tan\u0131mlanm\u0131\u015f iki vekt\u00f6r olsun:\n* a=(a1, a2, a3)\n* b= (b1, b2, b3)\n\nBu iki vekt\u00f6r aras\u0131ndaki nokta \u00e7arp\u0131m\u0131 a\u015fa\u011f\u0131daki gibi ger\u00e7ekle\u015ftirilir:\n* a.b=(a1*b1 + a2*b2 + a3*b3)\n","6b4f7f25":"[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n# <a class=\"anchor\" id=\"3.\"><\/a>**3. MATR\u0130SLER** \n\nMatrisler lineer cebirin temel elemanlardan biridir. Matrisler, vekt\u00f6rleri de kapsam\u0131na alan bir konudur. Vekt\u00f6rler bir sat\u0131r ve birden fazla s\u00fct\u00fcndan(sat\u0131r vekt\u00f6r) veya bir s\u00fct\u00fcn ve birden fazla sat\u0131rdan(s\u00fct\u00fcn vekt\u00f6r) olu\u015fabilirken, matrisler birden fazla sat\u0131r ve s\u00fct\u00fcn i\u00e7erebilir. \n\nVekt\u00f6rleri temsil etmek i\u00e7in k\u00fc\u00e7\u00fck harf sembolleri tercih edilirken, matrisler i\u00e7in b\u00fcy\u00fck harf sembolleri kullan\u0131l\u0131r. \n\n* A=((a11, a12, a13, a14),(a21, a22, a23, a24), (a31, a32, a33, a34))\n\nA matrisi \u00fc\u00e7 sat\u0131r ve d\u00f6rt s\u00fct\u00fcndan olu\u015fmaktad\u0131r. Matrisin \u00fc\u00e7\u00fcnc\u00fc sat\u0131r ve ikinci s\u00fct\u00fcdaki eleman\u0131n indekslenmesi a32 bi\u00e7iminde yap\u0131l\u0131r. ","74c2da4b":"**Matris Transpozu**\n\nBir matrisin transpozu sat\u0131r ve s\u00fct\u00fcnlar\u0131n yer de\u011fi\u015ftirilmesiyle elde edilir ve matris sembol\u00fcn\u00fcn \u00fcst\u00fcne T harfi getirilerek temsil edilir. \u00d6rne\u011fin A matrisinin transpouzu A^T bi\u00e7iminde g\u00f6sterilir. ","09733c24":"<a class=\"anchor\" id=\"4.\"><\/a>**4. MATR\u0130S AYRI\u015eIMI(MATRIX DECOMPOSITION)** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nMatrisi \u00e7arpanlar\u0131na ay\u0131rma(Matrix Factorization) olarak da bilinen matris ayr\u0131\u015f\u0131m\u0131, bir matrisi basit bile\u015fenlerine ay\u0131rma i\u015flemidir. Matris ayr\u0131\u015f\u0131m\u0131, matrisi basit bile\u015fenlerine ay\u0131rarak lineer denklemlerin \u00e7\u00f6z\u00fcmlenmesi, matris tersinin bulunmas\u0131, matris determinant\u0131n\u0131n bulunmas\u0131 v.b. karma\u015f\u0131k matris i\u015flemlerinin daha kolay yap\u0131lmas\u0131na olanak sa\u011flar. \n\nOrijinal matris \u00fczerinde yap\u0131lmas\u0131 gereken karma\u015f\u0131k matris i\u015flemleri, matris ayr\u0131\u015f\u0131m\u0131yla elde edilen basit bile\u015fenler \u00fczerinde yap\u0131l\u0131r. \u00d6rne\u011fin 24 say\u0131s\u0131n\u0131 4x6 bi\u00e7iminde ifade etmek bir ayr\u0131\u015ft\u0131rma(\u00e7arpanlar\u0131na ay\u0131rma) i\u015flemidir. Ayn\u0131 ayr\u0131\u015ft\u0131rma i\u015fleminin matrisler \u00fczerinde tekrarl\u0131 say\u0131sal i\u015flemlerin ger\u00e7ekle\u015ftirilmesiyle elde edilir. \n\nMatrislerin ayr\u0131\u015ft\u0131r\u0131lmas\u0131 i\u00e7in gerli\u015ftirilmi\u015f bir\u00e7ok y\u00f6ntem vard\u0131r. Bu \u00e7al\u0131\u015fmada farkl\u0131 ayr\u0131\u015ft\u0131rma y\u00f6ntemlerinin Python ile ger\u00e7ekle\u015ftirilmesini g\u00f6rece\u011fiz:\n\n* LU Ayr\u0131\u015f\u0131m\u0131\n* QR Ayr\u0131\u015f\u0131m\u0131\n* Cholesky Ayr\u0131\u015f\u0131m\u0131\n* \u00d6z Ayr\u0131\u015f\u0131m-\u00d6zvekt\u00f6r ve \u00d6zde\u011fer(Eigenvector and Eigenvalue) Ayr\u0131\u015f\u0131m\u0131\n* Tekil De\u011fer Ayr\u0131\u015f\u0131m\u0131(Singular Value Decomposition)","a1cd9af1":"ndarray diziler aras\u0131 \u015fekil d\u00f6n\u00fc\u015f\u00fcmleri, sadece bir ve iki boyutlu diziler aras\u0131nda s\u0131n\u0131rl\u0131 de\u011fildir. Farkl\u0131 boyutlar aras\u0131nda \u015fekil d\u00f6n\u00fc\u015f\u00fcmleri ger\u00e7ekle\u015ftirilebilir. A\u015fa\u011f\u0131daki \u00f6rneklerde bu t\u00fcr d\u00f6n\u00fc\u015f\u00fcmler vard\u0131r.","479c8648":"<a class=\"anchor\" id=\"3.3.\"><\/a>**3.3. Matris \u00c7arp\u0131m\u0131(Matris Nokta \u00c7arp\u0131m\u0131) ** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n\u0130ki matrisin nokta \u00e7arp\u0131mlar\u0131, buraya kadar g\u00f6rd\u00fc\u011f\u00fcm\u00fcz cebirsel i\u015flemlerden biraz daha karma\u015f\u0131kt\u0131r. \u0130ki matrsin nokta \u00e7arp\u0131mlar\u0131n\u0131n g\u00f6sterimi;\n* C=A.B\n\n\n\u0130ki matris aras\u0131nda nokta \u00e7arp\u0131m\u0131 yap\u0131labilmesi i\u00e7in a\u015fa\u011f\u0131da \u015fart\u0131 sa\u011flamas\u0131 gerekir:\n* A ve B iki matris olmak \u00fczere; A.B yap\u0131labilmesi i\u00e7in birinci matrisin s\u00fct\u00fcn say\u0131s\u0131yla ikinci matrisin sat\u0131r say\u0131lar\u0131n\u0131n e\u015fit olmas\u0131 gerekir. \n\n\u00d6rne\u011fin A matrisinin sat\u0131r ve s\u00fct\u00fcn say\u0131s\u0131 (3,4) olsun. A matrisyle \u00e7arp\u0131lacak B matrisinin \u00f6l\u00e7\u00fcleri \u015f\u00f6yle olabilir; (4, her hangi bir tam say\u0131).\n\nA.B nokta \u00e7arp\u0131m\u0131 sonucu elde edilecek C matrisinin boyutu \u015f\u00f6yledir:Birinci matrisin sat\u0131r say\u0131s\u0131 kadar sat\u0131ra ve ikinci matrisin s\u00fct\u00fcn say\u0131s\u0131 kadar s\u00fctuna sahiptir. \n\n\u00d6rne\u011fin; A.shape=(4,6) ve B.shape=(6,9) olmak \u00fczere C=A.B i\u00e7in C.shape=(4,9) olacakt\u0131r. \n\n\u0130ki matrisin nokta \u00e7arp\u0131m\u0131 \u015f\u00f6yle ger\u00e7ekle\u015ftirilir: Birinci matrisin sat\u0131rlar\u0131yla ikinci matrisin s\u00fct\u00fcnlar\u0131 aras\u0131nda vekt\u00f6rel nokta \u00e7arp\u0131m\u0131yla elde edilen skaler de\u011ferlerle sonu\u00e7 matrisi olu\u015fturulur. ","358f9ff4":"<a class=\"anchor\" id=\"3.1.\"><\/a>**3.1. Numpy \u0130le Matris Olu\u015fturma** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nNumpy ile matris olu\u015fturman\u0131n bir \u00e7ok yolu vard\u0131r. Var olan bir tek boyutlu bir dizi matrise d\u00f6n\u00fc\u015ft\u00fcr\u00fclebilir veya yeni bir matris olu\u015fturulabilir.  \n\n[1.4. ndarray Olu\u015fturmak \u0130\u00e7in Kullan\u0131labilecek \u00d6n Tan\u0131ml\u0131 Fonksiyonlar](#1.4.) ba\u015fl\u0131kl\u0131 b\u00f6l\u00fcmde ndarray olu\u015fturmak i\u00e7in kullan\u0131labilecek fonksiyonlar anlat\u0131lm\u0131\u015ft\u0131r. Bu b\u00f6l\u00fcm\u00fcdeki fonksiyonlar kullan\u0131larak yeni bir matris olu\u015fturulabilir. \n\n[1.8. ndarray Dizilerinin Yeniden \u015eekillendirilmesi](#1.8.) ba\u015fl\u0131kl\u0131 b\u00f6l\u00fcmde var olan ndarray dizileri matrise d\u00f6n\u00fc\u015ft\u00fcrmek i\u00e7in kullan\u0131labilecek **reshape** fonksiyonu anlat\u0131lm\u0131\u015ft\u0131r. reshape fonksiyonu kullan\u0131larak bir boyutlu diziler matrise d\u00f6n\u00fc\u015ft\u00fcr\u00fclebilir. ","983c9047":"<a class=\"anchor\" id=\"5.1.\"><\/a>**5.1. Perceptron** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nMcCullock ve Pitts'in siniri ve Rosenblatt'\u0131n perceptron modelinin ard\u0131ndaki t\u00fcm fikir, beyindeki tek bir n\u00f6ronun nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 taklit etmek i\u00e7in indirgemeci bir yakla\u015f\u0131m kullanmakt\u0131r: ya ate\u015f eder ya da etmez. \n\nX ve y s\u0131ras\u0131yla veri matrisi ve \u00e7\u0131kt\u0131 vekt\u00f6r\u00fc olsun. Veri matrisi ve \u00e7\u0131kt\u0131 vek\u00f6t\u00fcr\u00fcn\u00fcn bir k\u0131sm\u0131 e\u011fitim, di\u011fer k\u0131sm\u0131 test i\u00e7in kullan\u0131lacakt\u0131r. E\u011fitim ve test k\u00fcmeleri \u015f\u00f6yle ayr\u0131ls\u0131n X_train, X_test, y_train, y_test.\n\nRosenblatt'\u0131n ba\u015flang\u0131\u00e7 perceptron kural\u0131na g\u00f6re perceptron modelinin e\u011fitimi a\u015fa\u011f\u0131daki ad\u0131mlarla \u00f6zetlenebilir:\n\n* A\u011f\u0131rl\u0131k vekt\u00f6r\u00fc W rasgele de\u011ferler ile doldurulur\n* \u00d6\u011frenme oran\u0131n\u0131 belirlenir \n* X_train e\u011fitim k\u00fcmesindeki her bir e\u011fitim \u00f6rne\u011fi xi i\u00e7in a\u015fa\u011f\u0131daki ad\u0131mlar ger\u00e7ekle\u015ftirilir:\n* * \u00c7\u0131kt\u0131 y_pred vekt\u00f6r\u00fcn\u00fc hesapla\n* * A\u011f\u0131rl\u0131k vekt\u00f6r\u00fcn\u00fc y_pred ve y_test vekt\u00f6rlerini dikkate alarak g\u00fcncelle\n\nE\u011fitim a\u015famas\u0131 tamamland\u0131ktan sonra elde edilen a\u011f\u0131rl\u0131k vekt\u00f6r\u00fc test veri k\u00fcmesinin s\u0131n\u0131fland\u0131r\u0131lmas\u0131nda kullan\u0131l\u0131r. S\u0131n\u0131fland\u0131rma i\u015flemi X_test veri setindeki herbir \u00f6rnek i\u00e7in a\u015fa\u011f\u0131da yer alan fonksiyondaki gibi tan\u0131mlana bilir:\n\nf(xi_test)=\n* e\u011fer xi_test.W>0 ise ait oldu\u011fu s\u0131n\u0131f 1'dir\n* de\u011fil ise ait oldu\u011fu s\u0131n\u0131f 0'd\u0131r. ","e3c028a5":"<a class=\"anchor\" id=\"2.1.\"><\/a>**2.1. Numpy \u0130le Vekt\u00f6r Olu\u015fturma** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nBir vekt\u00f6r\u00fcn g\u00f6sterimi \u015f\u00f6yledir:\n* a=(a1, a2, a3, ..., an)\n\nNumpy'\u0131n temel veri yap\u0131s\u0131 olan ndarray, \u00e7ok boyutlu dizi olu\u015fturmak i\u00e7in kullan\u0131\u015fl\u0131d\u0131r. Vekt\u00f6r olu\u015fturuken, basit\u00e7e bir boyutlu bir dizi olu\u015fturulur. Olu\u015fturulan bu bir boyutlu dizi, vekt\u00f6r\u00fcn t\u00fcr\u00fcne g\u00f6re s\u00fct\u00fcn vekt\u00f6r\u00fc veya sat\u0131r vekt\u00f6r\u00fc olabilir.","1e116795":"Orijinal diziden ba\u011f\u0131ms\u0131z bir dizi elde etmenin iki y\u00f6ntemi vard\u0131r. A\u015fa\u011f\u0131daki \u00f6rnekleri inceleyerek bunu anlayabiliriz.","6610405c":"<a class=\"anchor\" id=\"1.7.3.\"><\/a>**1.7. 3. \u00d6nemli Hat\u0131rlatma: Dizi Dilimlerken Kopya Alma** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nPytohn list dizilerini ve numpy ndarray dizilerini dilimlerken dikkat etmemiz gereken \u00f6nemli bir ayr\u0131nt\u0131 vard\u0131r. Diziler dilimlenirken orijinal diziyle ba\u011flar\u0131n\u0131 koparmazlar!(C\u00fcmle biraz h\u00fcz\u00fcnl\u00fc oldu ama anlad\u0131n\u0131z siz onu). Yani elde edilen yeni dizinin de\u011ferlerinde yap\u0131lacak de\u011fi\u015fiklikler orijinla diziyi etkiler. A\u015fa\u011f\u0131daki \u00f6rnekleri inceleyerek bunu daha iyi anlayabiliriz.","7e8cc49f":"[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n# <a class=\"anchor\" id=\"5.\"><\/a>**5. YAPAY S\u0130N\u0130R A\u011eLAR: PERCEPTRON, ADALINE** \n\nYapay sinir a\u011flar\u0131 insan beyninin \u00e7al\u0131\u015fmas\u0131n\u0131 modellemek i\u00e7in yap\u0131lan \u00e7al\u0131\u015fmalar\u0131n sonucunda ortaya \u00e7\u0131km\u0131\u015f bir \u00f6\u011frenme modelidir. McCullock  ve Pitts yapay sinir a\u011flar\u0131 \u00fczerine yapt\u0131klar\u0131 ilk \u00e7al\u0131\u015fmada sinir(neuron) kavram\u0131n\u0131 tan\u0131tm\u0131\u015flard\u0131r(McCullock  ve Pitts, 1943).  \n\nSinirler, beyinde kimyasal ve elektriksel sinyallerin i\u015flenmesi ve iletilmesinde yer alan birbiriyle ba\u011flant\u0131l\u0131 sinir h\u00fccreleridir. McCullock ve Pitts, b\u00f6yle bir sinir h\u00fccresini, ikili \u00e7\u0131kt\u0131larla basit bir mant\u0131k kap\u0131s\u0131 olarak tan\u0131mlad\u0131lar: Birden fazla sinyal dendritlere ula\u015f\u0131r, daha sonra h\u00fccre g\u00f6vdesine entegre edilir ve e\u011fer birikmi\u015f sinyal belirli bir e\u015fi\u011fi a\u015farsa, akson taraf\u0131ndan ge\u00e7irilecek bir \u00e7\u0131k\u0131\u015f sinyali \u00fcretilir(Raschka, 2015).\n\nMcCullock ve Pitts'in \u00f6nerdikleri sinir kavram\u0131n\u0131 temel alan Rosenblatt, perceptron \u00f6\u011frenme kurallar\u0131n\u0131 geli\u015ftirmi\u015ftir(Rosenblatt, 1957). Perceptron kural\u0131 ile Rosenblatt, bir n\u00f6ronun ate\u015f al\u0131p almad\u0131\u011f\u0131na karar vermek i\u00e7in girdi \u00f6zellikleriyle \u00e7arp\u0131lan optimal a\u011f\u0131rl\u0131k katsay\u0131lar\u0131n\u0131 otomatik olarak \u00f6\u011frenecek bir algoritma \u00f6nermi\u015ftir. Denetimli \u00f6\u011frenme ve s\u0131n\u0131fland\u0131rma ba\u011flam\u0131nda, b\u00f6yle bir algoritma, bir \u00f6rne\u011fin bir s\u0131n\u0131fa m\u0131 yoksa di\u011ferine mi ait oldu\u011funu tahmin etmek i\u00e7in kullan\u0131labilir(Raschka, 2015). ","7bc33051":"<a class=\"anchor\" id=\"2.2.\"><\/a>**2.2. Vekt\u00f6rlerde Aritmetik \u0130\u015flemler** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n\u0130ki vekt\u00f6r aras\u0131nda temel aritmetik i\u015flemler ger\u00e7ekle\u015ftirilebilir. Yani iki vekt\u00f6r\u00fc toplayabilir, \u00e7\u0131kartabilir, \u00e7arpabilir ve b\u00f6lebiliriz. Aritmetik i\u015flem yap\u0131lacak iki vekt\u00f6r\u00fcn uzunluklar\u0131n\u0131n e\u015fit olmas\u0131 gerekir. \u0130ki vekt\u00f6r aras\u0131ndaki aritmetik i\u015flemler, ayn\u0131 konumdaki vekt\u00f6r \u00f6gelerine uygulanarak ger\u00e7ekler\u015ftirilir.\n\na ve b a\u015fa\u011f\u0131daki gibi tan\u0131mlanm\u0131\u015f iki vekt\u00f6r olsun:\n* a=(a1, a2, a3)\n* b= (b1, b2, b3)\n\n\u0130ki vekt\u00f6r aras\u0131ndak ger\u00e7ekle\u015ftirilebilecek aritmetik i\u015flemler: +, -, * ,  \/, ** , %\n\nBu iki vekt\u00f6r aras\u0131ndaki aritmetik i\u015flemler a\u015fa\u011f\u0131daki gibi ger\u00e7ekle\u015ftirilir:\n* Toplama    : a+b=(a1+b1, a2+b2, a3+b3):\n* \u00c7\u0131karma    : a-b=(a1-b1, a2-b2, a3-b3)\n* \u00c7arpma     : a*b=(a1*b1, a2*b2, a3*b3)\n* B\u00f6lme        : a\/b=(a1\/b1, a2\/b2, a3\/b3)\n* \u00dcst alma   : a^b=(a1^b1, a2^b2, a3^b3)\n* Mod alma : a%b=(a1%b1, a2%b2, a3%b3)\n","fc479359":"<a class=\"anchor\" id=\"4.1.\"><\/a>**4.1. LU Ayr\u0131\u015f\u0131m\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nLU ayr\u0131\u015ft\u0131rma y\u00f6ntemi Turing Makinelerinin mucidi Alan Turing taraf\u0131nda geli\u015ftirilmi\u015ftir. Y\u00f6ntemin ad\u0131 Lower(L) ve Upper(U) kelimelerinin ba\u015f harfleriyle olu\u015fturulmu\u015ftur.  LU y\u00f6ntemi kare matrisi alt \u00fc\u00e7gensel ve \u00fcst \u00fc\u00e7gensel iki matrise ayr\u0131\u015ft\u0131r\u0131r. Bu iki matrisin \u00e7arp\u0131m\u0131 orijinal matrisi verir. Bir A matrisi i\u00e7in LU ayr\u0131\u015f\u0131m\u0131 \u015f\u00f6yle g\u00f6sterilir:\n* A=L.U\n\nA matrisi \u00fczerinde Gauss Eleme Y\u00f6ntemi uygulanarak \u00fcst \u00fc\u00e7gensel matris ve k\u00f6\u015fegeni 1 olan alt \u00fc\u00e7gensel matris elde edilir. \n\nBaz\u0131 matrislerin LU ayr\u0131\u015f\u0131m\u0131 ger\u00e7ekle\u015ftirilemeyebilir. Bu nedenle t\u00fcm kare matrisler \u00fczerinde \u00e7al\u0131\u015fabilir versiyonu geli\u015ftirilmi\u015ftir. Bu versiyona g\u00f6re  LU matrisi sat\u0131rlar\u0131 tekrardan s\u0131ralayan ve k\u0131smi d\u00f6nd\u00fcrme matrisi olarak adland\u0131r\u0131lan P matrisiyle \u00e7arp\u0131l\u0131r. Bu ayr\u0131\u015f\u0131ma g\u00f6re A matrisi a\u015fa\u011f\u0131daki gibi g\u00f6sterilir:\n* A=L.U.P\n\nBilimsel Python k\u00fct\u00fcphanesi olan scipy'da LU ayr\u0131\u015f\u0131m\u0131n\u0131 ger\u00e7ekle\u015ftirecek fonksiyon vard\u0131r.","84583566":"\u0130ki boyutlu dizilerde istenen sat\u0131r veya s\u00fct\u00fcndaki elemanlar\u0131n hepsine ula\u015fmak m\u00fcmk\u00fcnd\u00fcr. Ancak bu t\u00fcr indekslemenin bir sonraki b\u00f6l\u00fcmde anlat\u0131lacak dilimleme oldu\u011funu bilmek gerekir. ","4aa5d6cf":"<a class=\"anchor\" id=\"4.5.\"><\/a>**4.5. Tekil De\u011fer Ayr\u0131\u015f\u0131m\u0131(Singular Value Decomposition(SVD))** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nTekil De\u011fer Ayr\u015f\u0131m\u0131 (SVD), matris ayr\u0131\u015f\u0131m\u0131 y\u00f6ntemlerinden en yayg\u0131n kullan\u0131lan\u0131d\u0131r. \u00d6z Ayr\u0131\u015f\u0131m y\u00f6ntemi sadece kare matrsilerin ayr\u0131\u015ft\u0131r\u0131lmas\u0131nda kullan\u0131labilirken SVD dikd\u00f6rtgen matrislerin ayr\u0131\u015ft\u0131r\u0131lmas\u0131nda da kullan\u0131labilir. \n\nBir A matrisi i\u00e7in SVD ayr\u0131\u015f\u0131m\u0131 a\u015fa\u011f\u0131daki gibi g\u00f6sterilir:\n* A=U.SIGMA.V^T \n\nE\u015fitlikte A nxm ebatlar\u0131nda dikd\u00f6rtgen matris, U mxm ebatlar\u0131nda kare matris, SIGMA mxn k\u00f6\u015fegen matris ve V^T nxn ebatlar\u0131nda kare matrisdir. \n\nSIGMA k\u00f6\u015fegen matrisi A matrisinin tekil de\u011ferlerini k\u00f6\u015fegeninde tutar. U matrisi A matrisinin sol-tekil de\u011ferlerini tutar. V matrisi A matrisinin sa\u011f-tekil de\u011ferlerini tutar. T\u00fcm kare ve dikd\u00f6rtgen matrislerin tekil de\u011fer ayr\u0131\u015f\u0131m\u0131 yap\u0131labilir. Ancak baz\u0131 karma\u015f\u0131k say\u0131 ve noktal\u0131 say\u0131 s\u0131n\u0131rlamalar\u0131ndan dolay\u0131 hata olu\u015fabilir. \n\nSVD d\u00f6n\u00fc\u015f\u00fcm\u00fcn\u00fc ve daha sonras\u0131nda orijinal matris d\u00f6n\u00fc\u015f\u00fcm\u00fcn\u00fc Python k\u00fct\u00fcphanelerini kullanarak ger\u00e7ekle\u015ftirebiliriz.","c7140d60":"Numpy, nokta \u00e7arp\u0131m\u0131n\u0131 yapam fonksiyona sahiptir.","7a93bc4e":"**Not:** \u00c7al\u0131\u015fma hen\u00fcz tamamlanmam\u0131\u015ft\u0131r. Ancak yorum ve oylamaya a\u00e7\u0131kt\u0131r. Tamamlanan k\u0131sm\u0131n faydal\u0131 olaca\u011f\u0131n\u0131 d\u00fc\u015f\u00fcnd\u00fc\u011f\u00fcm i\u00e7in yay\u0131mlamaya karar verdim. Yorumlarda yap\u0131lacak isteklere g\u00f6re yeni konular ekleyebilir veya var olan konular\u0131 yeniden d\u00fczenleyebilirim. Yorumlar\u0131n\u0131z merakla bekliyorum. \u00c7al\u0131\u015fmay\u0131 be\u011fenirseniz oylamay\u0131 unutmay\u0131n l\u00fctfen! ","c86bbf92":"Rasgele de\u011ferlerden olu\u015fan matrisler olu\u015fturulabilir","7b885d26":"Birr matris ve skaler aras\u0131nda aritmetik i\u015flemler ger\u00e7ekle\u015ftirilebilir. \n\nA ve s a\u015fa\u011f\u0131daki gibi tan\u0131mlanm\u0131\u015f iki matris olsun:\n* A=((a11, a12, a13),(a21, a22, a23))\n* s=skaler\n\nBir matris ve skaler aras\u0131nda ger\u00e7ekle\u015ftirilebilecek aritmetik i\u015flemler: +, -, * ,  \/, ** , %\n\nBu iki vekt\u00f6r aras\u0131ndaki aritmetik i\u015flemler a\u015fa\u011f\u0131daki gibi ger\u00e7ekle\u015ftirilir:\n* Toplama    : A+s=((a11+s, a12+s, a13+s),(a21+s, a22+s, a23+s))\n* \u00c7\u0131karma    : A-s=(a11-s, a12-s, a13-s),(a21-s, a22-s, a23-s))\n* \u00c7arpma     : A*s=(a11*s, a12*s, a13*s),(a21*s, a22*s, a23*s))\n* B\u00f6lme        : A\/s=(a11\/s, a12\/s, a13\/s),(a21\/s, a22\/s, a23\/s))\n* \u00dcst alma   : A^s=(a11^s, a12^s, a13^s),(a21^s, a22^s, a23^s))\n* Mod alma : A%s=(a11%s, a12%s, a13%s),(a21%s, a22%s, a23%s))","7f98866d":"<a class=\"anchor\" id=\"1.7.2.\"><\/a>**1.7. 2. \u0130ki Boyutlu ndarray Dizilerinin Dilimlenmesi** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n\u0130ki boyutlu dizilerin dilimlenmesi, bir boyutlu dizilerin dilimlenmesine benzemektedir. \u0130ki boyutlu diziler dilimlenirken sat\u0131r ve s\u00fct\u00fcn i\u00e7in ayr\u0131 indeks ba\u015flang\u0131\u00e7 ve biti\u015fi de\u011ferlerinin tan\u0131mlanmas\u0131 gerekir.","6a41af3c":"<a class=\"anchor\" id=\"2.4.\"><\/a>**2.4. Vekt\u00f6r Normlar\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nVekt\u00f6r normu, vekt\u00f6r\u00fcn uzunlu\u011fu veya b\u00fcy\u00fckl\u00fc\u011f\u00fc olarak tan\u0131mlan\u0131r. Vekt\u00f6r\u00fcn b\u00fcy\u00fckl\u00fc\u011f\u00fc farkl\u0131 y\u00f6ntemlerle hesaplanabilir. Bunlardan en bilinenleri:\n\n* L1 norm: Vekt\u00f6rdeki t\u00fcm \u00f6gelerin mutlak de\u011fer toplamlar\u0131d\u0131r.\n* L2 norm: Vekt\u00f6rdeki t\u00fcm \u00f6gelerin kare toplamlar\u0131n\u0131n karak\u00f6k\u00fcd\u00fcr. \n* Max norm: Vekt\u00f6rdeki mutlak de\u011feri en b\u00fcy\u00fck de\u011ferdir. \n* Min norm: Vekt\u00f6rdeki mutlak de\u011feri en k\u00fc\u00e7\u00fck de\u011ferdir.\n* Frobenius norm: Vekt\u00f6rler i\u00e7in L2 normla ayn\u0131d\u0131r","7697b606":"<a class=\"anchor\" id=\"3.5.\"><\/a>**3.5. Matris \u0130\u015flemleri: Transpozu, Tersi, \u0130zi, Determinant\u0131, Rank ** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nMatrisler, lineer denklemleri \u00e7\u00f6z\u00fcmlemek, g\u00f6r\u00fcnt\u00fcler \u00fczerinde i\u015flemler yapmak, veri boyutunu azaltmak, makine \u00f6\u011frenmesi modellerinin ger\u00e7ekle\u015ftirilmes vb., birinden farkl\u0131 ama\u00e7lar i\u00e7in kullan\u0131labilir. Bu b\u00f6l\u00fcmde en \u00e7ok bilinen matris i\u015flemleri anlat\u0131lacakt\u0131r. \n","925c230a":"Iris veri setinde \u00fc\u00e7 tane hedef s\u0131n\u0131f vard\u0131r;setosa, versicolor ve virginica. Perceptron algoritmas\u0131 iki s\u0131n\u0131f s\u0131n\u0131fland\u0131r\u0131c\u0131s\u0131 oldu\u011fu i\u00e7in iris veri setindeki sadece iki s\u0131n\u0131f kullan\u0131lacakt\u0131r. \n\n**Uyar\u0131:** Perceptron, SVM, Logistic Regression vb. bir \u00e7ok makine \u00f6\u011frenmesi modeli iki s\u0131n\u0131f s\u0131n\u0131fland\u0131r\u0131c\u0131lard\u0131r. \u0130kili s\u0131n\u0131f s\u0131n\u0131fland\u0131r\u0131c\u0131lar\u0131 \u00e7oklu s\u0131n\u0131f s\u0131n\u0131fland\u0131r\u0131c\u0131s\u0131 olarak kullanmak i\u00e7in One vs Rest, One vs One gibi y\u00f6ntemler kullan\u0131l\u0131r. Sklearn k\u00fct\u00fcphanesinden yer alan Perceptron algoritmas\u0131 \u00e7oklu s\u0131n\u0131flar\u0131n s\u0131n\u0131fland\u0131rmada kullan\u0131lmas\u0131 bahsi ge\u00e7en y\u00f6ntemlerle ger\u00e7ekle\u015ftirilir. ","002c4efe":"My_PCA ve PCA s\u0131n\u0131flar\u0131 noktolama fark\u0131yla ayn\u0131 sonu\u00e7lar\u0131 vermi\u015ftir.  ","5d96bdf3":"Numpy iki matris \u00e7arp\u0131m\u0131 ger\u00e7ekle\u015ftirecek haz\u0131r fonksiyona sahiptir. ","eaf81b5b":"list ve ndarray nesnelerinde yer alan t\u00fcm \u00f6zelliklerin ne i\u015f yapt\u0131\u011f\u0131n\u0131 a\u015fa\u011f\u0131daki fonksiyonu kullanarak \u00f6\u011frenelim. _ _ doc _ _ de\u011fi\u015fkeni daha sade bir \u00e7\u0131kt\u0131 verdi\u011fi i\u00e7in onu kullanal\u0131m. \n\n**\u00d6nemli Not:** A\u015fa\u011f\u0131daki fonksiyonda Python k\u00fct\u00fcphanesinde \u00f6n tan\u0131ml\u0131 olarak yer alan **eval()** fonksiyonu kullan\u0131lm\u0131\u015ft\u0131r. **eval()** \u00e7ok dikkatli kullan\u0131lmas\u0131 gereken bir foksiyondur. **eval()** fonksiyonun dikkatli kullan\u0131m\u0131 hakk\u0131nda detayl\u0131 bilgiye [1](http:\/\/lybniz2.sourceforge.net\/safeeval.html) ve [2](https:\/\/belgeler.yazbel.com\/python-istihza\/input.html#eval-ve-exec-fonksiyonlari) ba\u011flant\u0131lar\u0131ndan ula\u015fabilirsiniz. ","8d8bcae1":"<a class=\"anchor\" id=\"1.1.\"><\/a>**1.1. Numpy'da Diziler** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nDiziler birden fazla de\u011fi\u015fkeni ayn\u0131 isim alt\u0131nda tutulmas\u0131n\u0131 sa\u011flayan veri yap\u0131s\u0131d\u0131r. C++, C# ve Java gibi **statik  yaz\u0131l\u0131rl\u0131(statically-typed)** dillerde dizi i\u00e7erisinde tutulan t\u00fcm de\u011fi\u015fkenler ayn\u0131 veri tipine sahip olmas\u0131  gerekir. Python dinamik yaz\u0131l\u0131rl\u0131(dynamically-typed) bir dil oldu\u011fu i\u00e7in dizi i\u00e7erisinde tutulan t\u00fcm de\u011fi\u015fkenlerin ayn\u0131 veri tipinde olma zorunlulu\u011fu yoktur. \n\n**Python'da diziler i\u00e7in kullan\u0131lan isimlerdirme; 'list' s\u00f6zc\u00fc\u011f\u00fcd\u00fcr. **","2e89ad0f":"<a class=\"anchor\" id=\"3.4.\"><\/a>**3.4. Kare, Simetri, \u00dc\u00e7gensel, K\u00f6\u015fegen, Birim ve Dikgen Matrisler ** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nLineer cebirde baz\u0131 matrisler di\u011ferlerinden daha fazla kar\u015f\u0131m\u0131za \u00e7\u0131kmaktad\u0131r. Bu b\u00f6l\u00fcmde Kare, Simetri, \u00dc\u00e7gensel, K\u00f6\u015fegen, Birim ve Dikgen  matris t\u00fcrlerini g\u00f6rece\u011fiz. Bu matris t\u00fcrleri makine \u00f6\u011frenmesi y\u00f6ntemlerinde s\u0131kl\u0131kla kar\u015f\u0131m\u0131za \u00e7\u0131kmaktad\u0131r. \n\n* **Kare Matris:** Sat\u0131r ve s\u00fct\u00fcn say\u0131s\u0131 e\u015fit matrislerdir.\n* **Simetrik Matris:** K\u00f6\u015fegenin alt\u0131ndaki \u00fc\u00e7genlerin e\u015fit oldu\u011fu kare matrislerdir\n* **\u00dc\u00e7gensel** matrisler ikiye ayr\u0131l\u0131r: \n* * **Alt \u00dc\u00e7gensel Matris:** K\u00f6\u015fegen ve alt\u0131 s\u0131f\u0131rdan fakl\u0131 de\u011fer i\u00e7eren matrislerdir.\n* * **\u00dcst \u00dc\u00e7gensel Matris:** K\u00f6\u015fegen ve \u00fcst\u00fc s\u0131f\u0131rdan farkl\u0131 de\u011fer i\u00e7eren matrislerdir.\n* **K\u00f6\u015fegen Matris:** K\u00f6\u015fegen d\u0131\u015f\u0131ndaki t\u00fcm de\u011ferleri s\u0131f\u0131r olan matrislerdir.\n* **Birim Matris:** K\u00f6\u015fegen de\u011ferleri 1 olan k\u00f6\u015fegen matrislerdir.\n* **Dikgen Matris**: Transpozu ile \u00e7arp\u0131m\u0131 birim matris olan matrislerdir. \n","6d14dafa":"\u0130ki boyutlu diziyi tek boyutlu diziye d\u00f6n\u00fc\u015ft\u00fcr\u00fclebilir.  A\u015fa\u011f\u0131daki \u00f6rnekleri inceleyerek 'C' ve 'F' stil \u015fekillendirmeleri anlamaya \u00e7al\u0131\u015f\u0131n\u0131z. ","233dae31":"<a class=\"anchor\" id=\"4.4.\"><\/a>**4.4. \u00d6z Ayr\u0131\u015f\u0131m-\u00d6zvekt\u00f6r ve \u00d6zde\u011fer(Eigenvector and Eigenvalue) Ayr\u0131\u015f\u0131m\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nMatris ayr\u0131\u015f\u0131mlar\u0131ndan belkide en \u00e7ok bilineni \u00d6z Ayr\u0131\u015f\u0131m yakla\u015f\u0131m\u0131d\u0131r. Bu yakla\u015f\u0131mda kare matris \u00f6z de\u011fer ve \u00f6z vekt\u00f6rlerine ayr\u0131\u015ft\u0131r\u0131l\u0131r. \n\nBir kare matrisin \u00f6z de\u011fer ve \u00f6z vekt\u00f6rleri a\u015fa\u011f\u0131daki e\u015fitli\u011fi sa\u011flamas\u0131 gerekir:\n* A.v=lamda.v\n\nDenklemde A kare matris, v \u00f6z vekt\u00f6r ve lambda \u00f6z de\u011fere kar\u015f\u0131l\u0131k gelir. \n\n\u00d6z ayr\u0131\u015f\u0131m y\u00f6nteminde orijinal matrisin herbir boyutu i\u00e7in bir \u00f6z vekt\u00f6r ve bir \u00f6z de\u011fer hesaplan\u0131r. Bir A matrisi \u00f6z vekt\u00f6rler ve \u00f6z de\u011ferlerin \u00e7arp\u0131m\u0131 olarak g\u00f6sterilebilir:\n* A=Q.LAMBDA.Q^-1\n\nDenklemde Q \u00f6z vekt\u00f6rleri tutan matris, LAMBDA \u00f6z de\u011ferleri tutan k\u00f6\u015fegen matris ve Q^-1 \u00f6z vekt\u00f6rleri tutan matrisin tersidir.\n\n\u00d6z de\u011fer ve \u00f6z vekt\u00f6rlerin numpy ile nas\u0131l hesapland\u0131\u011f\u0131n\u0131 g\u00f6relim:","32b6d2f6":"<a class=\"anchor\" id=\"1.2.\"><\/a>**1.2. Python Dizi(list) vs Numpy Dizi(ndarray)** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nPython'da dizi i\u015flemleri i\u00e7in kullan\u0131lan list nesnesi varken neden Numpy dizisi olan ndarray nesnesine ihtiya\u00e7 duyulur? Bu soruya basit\u00e7e \u015f\u00f6yle cevap  verebiliriz:\nPython dizisiyle yap\u0131labilen t\u00fcm i\u015flemler numpy dizisiyle yap\u0131labilir; ayr\u0131ca numpy dizisi bir\u00e7ok ek fonskiyona sahiptir. \n\nDaha detayl\u0131ca cevap vermek gerekirse; numpy dizisi Python dizisine g\u00f6re yap\u0131sal avantajlara sahiptir. Bu avantajlar \u00fc\u00e7 ba\u015fl\u0131kta toplanabilir:\n\n* **Boyut** - Numpy ndarray veri yap\u0131lar\u0131 daha az yer kaplar\n* **Performans** -  Numpy ndarray dizisi Python listelerinden daha h\u0131zl\u0131d\u0131r\n* **Fonksiyonellik** - NumPy, optimize edilmi\u015f cebirsel i\u015flemler k\u00fct\u00fcphanelerine sahiptir.\n\nA\u015fa\u011f\u0131da tan\u0131mlanan fonksiyonu kullanarak Python dizisi ve numpy dizinin sahip olduklar\u0131 d\u0131\u015fa a\u00e7\u0131k \u00f6zellikleri(public attributes) g\u00f6relim.\n\n**D\u0131\u015fa a\u00e7\u0131k \u00f6zellikler**, nesne y\u00f6nemli programlamayla u\u011fra\u015fanlar\u0131n a\u015f\u0131na oldu\u011fu bir kavramd\u0131r. Bu konuda detayl\u0131 bilgiye [buradan](https:\/\/belgeler.yazbel.com\/python-istihza\/) ula\u015fabilirsiniz. \nBasitce a\u00e7\u0131klamak gerekirse: **D\u0131\u015fa a\u00e7\u0131k \u00f6zellikler** nesnenin eri\u015filebilen metot ve de\u011fi\u015fkenlerine verilen add\u0131r. ","77c6bc85":"Veri matris X ve \u00e7\u0131kt\u0131 vekt\u00f6r\u00fc y'yi veri setini kullanarak olu\u015ftural\u0131m.","196522bf":"Matris t\u00fcrlerini numpy k\u00fct\u00fcphanesindeki haz\u0131r fonksiyonlar\u0131 kullanarak da elde edebiliriz. ","56b98e65":"<a class=\"anchor\" id=\"0.\"><\/a>**\u0130\u00e7indekiler**\n<center>Part I<\/center>\n* [1. NUMPY](#1.)\n* * [1.1. Numpy'da Diziler](#1.1.)\n* * [1.2. Python Dizi(list) vs Numpy Dizi(ndarray)](#1.2.)\n* * [1.3. Numpy Dizilerinin De\u011fi\u015fken Tipi, \u015eekli ve Boyutu](#1.3.)\n* * [1.4. ndarray Olu\u015fturmak \u0130\u00e7in Kullan\u0131labilecek \u00d6n Tan\u0131ml\u0131 Fonksiyonlar](#1.4.)\n* * [1.5. ndarray Dizilerini \u00dcst \u00dcste ve Yan Yana Ekleme](#1.5.)\n* * [1.6. ndarray Dizilerinde \u0130ndeks](#1.6.)\n* * [1.7. ndarray Dizilerinin Dilimlenmesi](#1.7.)\n* * * [1.7.1. Bir Boyutlu ndarray Dizilerinin Dilimlenmesi](#1.7.1.)\n* * * [1.7.2. \u0130ki Boyutlu ndarray Dizilerinin Dilimlenmesi](#1.7.2.)\n* * * [1.7. 3. \u00d6nemli Hat\u0131rlatma: Dizi Dilimlerken Kopya Alma](#1.7.3.)\n* * [1.8. ndarray Dizilerinin Yeniden \u015eekillendirilmesi](#1.8.)\n* * [1.9. Farkl\u0131 Boyutlarda\/\u015eekillerde ndarray Dizilerde Aritmetik \u0130\u015flemler](#1.9.)\n*  [2. VEKT\u00d6RLER](#2.)\n* * [2.1. Numpy \u0130le Vekt\u00f6r Olu\u015fturma](#2.1.)\n* * [2.2. Vekt\u00f6rlerde Aritmetik \u0130\u015flemler](#2.2.)\n* * [2.3. Nokta \u00c7arp\u0131m\u0131](#2.3.)\n* * [2.4. Vekt\u00f6r Normlar\u0131](#2.4.)\n*  [3. MATR\u0130SLER](#3.)\n* * [3.1. Numpy \u0130le Matris Olu\u015fturma](#3.1.)\n* * [3.2. Matrislerde Aritmetik \u0130\u015flemler](#3.2.)\n* * [3.3. Matris \u00c7arp\u0131m\u0131(Matris Nokta \u00c7arp\u0131m\u0131)](#3.3.)\n* * [3.4. Kare, Simetri, \u00dc\u00e7gensel, K\u00f6\u015fegen, Birim ve Dikgen Matrisler](#3.4.)\n* * [3.5. Matris \u0130\u015flemleri: Transpozu, Tersi, \u0130zi, Determinant\u0131, Rank](#3.5.)\n*  [4. MATR\u0130S AYRI\u015eIMI(MATRIX DECOMPOSITION)](#4.)\n* * [4.1. LU Ayr\u0131\u015f\u0131m\u0131](#4.1.)\n* * [4.2. QR Ayr\u0131\u015f\u0131m\u0131](#4.2.)\n* * [4.3. Cholesky Ayr\u0131\u015f\u0131m\u0131](#4.3.)\n* * [4.4. \u00d6z Ayr\u0131\u015f\u0131m-\u00d6zvekt\u00f6r ve \u00d6zde\u011fer(Eigenvector and Eigenvalue) Ayr\u0131\u015f\u0131m\u0131](#4.4.)\n* * [4.5. Tekil De\u011fer Ayr\u0131\u015f\u0131m\u0131(Singular Value Decomposition(SVD))](#4.5.)\n\n<center>Part II<\/center>\n*  [5. YAPAY S\u0130N\u0130R A\u011eLARI: PERCEPTRON, ADALINE](#5.)\n* * [5.1. Perceptron](#5.1.)\n* * * [5.1.1. Veri Setinin Perceptron \u0130\u00e7in Haz\u0131rlanmas\u0131](#5.1.1.)\n* * * [5.1.2. Perceptron class](#5.1.2.)\n* * * [5.1.3. Perceptron Modelinin Iris Veri Seti \u00dczerinde Kullan\u0131lmas\u0131](#5.1.3.)\n* * * [5.1.4. Perceptron Algoritmas\u0131n\u0131n Yorumlanmas\u0131](#5.1.4.)\n* * * [5.1.5. Perceptron Modelinin AND, OR, XOR Mant\u0131ksal Operat\u00f6rleri \u00c7\u0131kt\u0131lar\u0131n\u0131n Tahmininde Kullan\u0131lmas\u0131](#5.1.5.)\n* [6. TEMEL B\u0130LE\u015eEN ANAL\u0130Z\u0130-PRINCIPAL COMPONENT ANALYSIS(PCA)](#6.)\n* * [6.1. PCA Y\u00f6nteminin S\u0131f\u0131rdan Kodlanmas\u0131](#6.1.)\n* * [6.2 Yap\u0131lan PCA Kodlamas\u0131n\u0131n Test Edilmesi](#6.2.)","09648831":"\u00d6z vekt\u00f6r ve \u00f6z de\u011ferlerine ayr\u0131\u015ft\u0131r\u0131lan matris yeniden elde edilebilir. ","273b82e7":"**Matri Rank\u0131**\n\nKare matrisin determinant\u0131 en b\u00fcy\u00fck alt kare matrisin boyutuna e\u015fitir. ","661c0060":"Bir \u00f6z vekt\u00f6r\u00fcn ait oldu\u011fu matrisin sa\u011flamas\u0131 yap\u0131labilir. Bunu sa\u011flamas\u0131n\u0131 yapmak i\u00e7in i'ninci \u00f6z vekt\u00f6rle i'ninci \u00f6z de\u011fer \u00e7arp\u0131m\u0131yla orijinal matris ve i'ninci \u00f6z vekt\u00f6r\u00fcn \u00e7arp\u0131mlar\u0131 sonucu ayn\u0131 olmal\u0131d\u0131r. ","b6e08e2e":"**ndarray** dizilerinde Python **list** dizilerinde oldu\u011fu gibi negatif indeksleme yap\u0131labilir. -1 say\u0131s\u0131, dizinin sonundaki eleman\u0131 g\u00f6sterir ve negatif say\u0131 de\u011feri artt\u0131k\u00e7a dizinin ba\u015flang\u0131c\u0131na do\u011fru yakla\u015f\u0131r.","4a77ba42":"<a class=\"anchor\" id=\"5.1.4.\"><\/a>**5.1.4. Perceptron Algoritmas\u0131n\u0131n Yorumlanmas\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nSonu\u00e7lar Perceptron algoritmas\u0131n\u0131n kusursuz oldu\u011funu g\u00f6steriyor! Ger\u00e7ekten \u00f6yle mi? Bu sorunun yan\u0131t\u0131n\u0131 bulmaya \u00e7al\u0131\u015fal\u0131m.\n\nPerceptron algoritmas\u0131 linear bir s\u0131n\u0131fland\u0131r\u0131c\u0131d\u0131r. Lineer olarak ayr\u0131labilen veri setleri \u00fczerinde iyi sonu\u00e7lar verir. Lineer olarak ay\u0131rlabilmek nedir? E\u011fer iki s\u0131n\u0131f\u0131 ay\u0131rmak i\u00e7in bir **do\u011fru par\u00e7as\u0131** yetiyorsa bu s\u0131n\u0131flar lineer olarak ayr\u0131\u015ft\u0131r\u0131labilir olarak kabul edilir.  Kullan\u0131lan veri setindeki setosa ve versicolor s\u0131n\u0131flar\u0131 birbirinden tek bir do\u011fru par\u00e7as\u0131yla ayr\u0131\u015ft\u0131r\u0131labiliyor. Bunu i\u00e7in a\u015fa\u011f\u0131daki grafi\u011fi incelemek yeterli olacakt\u0131r. ","9e7738f3":"Biraz daha ilgin\u00e7 \u00f6rnekler g\u00f6relim","c528f116":"Perceptron s\u0131n\u0131fland\u0131rma performans\u0131 AND ve OR mant\u0131ksal operat\u00f6rlerinin \u00e7\u0131kt\u0131lar\u0131n\u0131n tahmininde iyi sonu\u00e7 verirken  XOR mant\u0131ksal operat\u00f6r\u00fcn\u00fcn \u00e7\u0131kat\u0131lar\u0131n\u0131n tahmininde k\u00f6t\u00fc sonu\u00e7 vermi\u015ftir. Bunun nedeni AND ve OR \u00e7\u0131kt\u0131lar\u0131 bir do\u011fru par\u00e7as\u0131yla ayr\u0131labilirken, XOR \u00e7\u0131kt\u0131lar\u0131 bir do\u011fruyla ayr\u0131lamamaktad\u0131r. \n\nA\u015fa\u011f\u0131daki \u015fekillerde AND ve OR \u00e7\u0131kt\u0131lar\u0131n\u0131n  do\u011fru par\u00e7as\u0131yla ayr\u0131labildi\u011fi ve XOR \u00e7\u0131kt\u0131lar\u0131n\u0131n do\u011fru par\u00e7as\u0131yla ayr\u0131lamad\u0131\u011f\u0131 g\u00f6r\u00fcl\u00fcyor. ","d082204a":"Kullanaca\u011f\u0131m\u0131z veri setini e\u011fitim ve test veri seti olarak ayr\u0131\u015ft\u0131ral\u0131m.","dad545f3":"<a class=\"anchor\" id=\"1.8.\"><\/a>**1.8. ndarray Dizilerinin Yeniden \u015eekillendirilmesi** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nndarray dizilerinin yeniden \u015fekillendirilmesi makine \u00f6\u011frenmesi uygulamalar\u0131nda s\u0131kl\u0131kla kar\u015f\u0131la\u015f\u0131lan bir durumdur.  Numpy ndarray dizilerinin yeniden \u015fekillendirilmesi **reshape()** fonksiyonu kullan\u0131l\u0131r. Fonksiyon bir parametre; yeni \u015fekil ve \u015fekillendirme stili. Fonksiyon al\u0131nan parametreye g\u00f6re diziyi \u015fekillendirir.\n\nndarray dizileri \u015fekillendirilirken \u00f6nceki \u015fekille yeni \u015fekil \u00f6l\u00e7\u00fcleri aras\u0131nda uyum olmas\u0131 gerekir. \u00d6rne\u011fin uzunlu\u011fu 12 olan bir dizi 3x4, 4x3, 6x2, 2x6 matrislerine d\u00f6n\u00fc\u015ft\u00fcr\u00fclebilirken 3x3, 5x2, 4x4 gibi matrislere d\u00f6n\u00fc\u015ft\u00fcr\u00fclemez. ndarray dizisinin eleman say\u0131s\u0131 \u015fekillendirmeden \u00f6nce ve sonra ayn\u0131 olmas\u0131na dikkat edilmelidir.\n\n\u015eekillendirmede dikkate edilmesi gereken bir di\u011fer durum; \u015fekillendirmenin C stil mi, yoksa F stil mi olaca\u011f\u0131d\u0131r. \n\n* **C** stil \u015fekillendirmede \u00f6ncelikle sat\u0131rlar\u0131n okunmas\u0131\/yaz\u0131lmas\u0131 ger\u00e7ekle\u015ftirilir.\n* **F** stil \u015fekillendirmede \u00f6ncellikle s\u00fct\u00fcnlar\u0131n okunmas\u0131\/yaz\u0131lmas\u0131 ger\u00e7ekle\u015ftirilir\n\nreshape fonksiyonunun **order** parametresi varsay\u0131lan olarak '**C' **stildir. \n","185d0b82":"<a class=\"anchor\" id=\"6.2.\"><\/a>**6.2 Yap\u0131lan PCA Kodlamas\u0131n\u0131n Test Edilmesi** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nBir matrsi \u00fczerinde, kodlamas\u0131 My_PCA s\u0131n\u0131f\u0131n\u0131 ve sklearn k\u00fct\u00fcphanesinde yer alan PCA s\u0131n\u0131f\u0131n\u0131 kar\u015f\u0131la\u015ft\u0131ral\u0131m. ","ce98731a":"**Matris Tersi**\n\nBir matrisin tersi; kendisiyle \u00e7arp\u0131ld\u0131\u011f\u0131nda birim matris sonucu verecek matris bulma i\u015flemidir ve matris sembol\u00fcn\u00fcn \u00fczerinde -1 koyularak g\u00f6sterilir. \u00d6rne\u011fin A matrisinin tersi A^-1 bi\u00e7iminde g\u00f6sterilir. \n\n* A.A^-1=I\n\n**Matris tersi bulma i\u015flemi sadece kare matrisler \u00fczerinde ger\u00e7ekle\u015ftirilebilir. **","193f6648":"Yukar\u0131daki ekran \u00e7\u0131kt\u0131s\u0131nda g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi list nesnesine ait 11  \u00f6zellik varken ndarray nesnesine ait 71 \u00f6zellik vard\u0131r. 'list' nesnesinde yer alan \u00f6zelliklerle diziler \u00fczerinde ekleme, \u00e7\u0131karma, araya ekleme v.b. gibi temel i\u015flemler yap\u0131labilir. 'ndarray' nesnesinde diziler \u00fczerinde temel i\u015flemler yapman\u0131n yan\u0131nda lineer cebirsel i\u015flemleri de yap\u0131labilmektedir. \n\nNesneler i\u00e7ersinde yer alan \u00f6zellikleri ne i\u015fe yarad\u0131klar\u0131n\u0131 \u00f6n tan\u0131ml\u0131 olarak Python k\u00fct\u00fcphanesinde yer alan **help()** fonksiyonunu kullanarak ger\u00e7ekle\u015ftirelebiliriz veya \u00f6zelli\u011fin _ _ doc _ _ de\u011fi\u015fkenini kullan\u0131lanabiliriz. ","7fa866bc":"**Matris \u0130zi**\n\nKare matrisin k\u00f6\u015fegeninde yer alan de\u011ferlerin toplam\u0131 matrisin izi olarak tan\u0131mlan\u0131r","d7b8de7c":"S\u0131f\u0131rdan bir ndarray olu\u015fturulabilir  ve 'ndarray' veri yap\u0131s\u0131, 'list' veri yap\u0131s\u0131 t\u00fcr\u00fcne d\u00f6n\u00fc\u015ft\u00fcr\u00fclebilr. ","1ca310a0":"<a class=\"anchor\" id=\"1.6.\"><\/a>**1.6. ndarray Dizilerinde \u0130ndeks ** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nPython list ve ndarray dizileri C++, Java, C# v.b., dillerde oldu\u011fu gibi s\u0131f\u0131rla ba\u015flayan indekslemeye sahiptir. \nTek boyutlu dizilerin elemanlar\u0131na ula\u015fmak i\u00e7in indeks numaras\u0131n\u0131 yazmak yeterlidir. \u00f6rnek: dizi[3]. \u0130ki boyutlu dizilerin elemanlar\u0131na ula\u015fman\u0131n iki fark indeks kullan\u0131m\u0131 vard\u0131r. \u00d6rnek: dizi[2][1], dizi[2,1] ","eb3b1f73":"<a class=\"anchor\" id=\"4.3.\"><\/a>**4.3. Cholesky Ayr\u0131\u015f\u0131m\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n\n\nCholesky ayr\u0131\u015f\u0131m\u0131 pozitif tan\u0131ml\u0131 matrisler \u00fczerinde ger\u00e7ekle\u015ftirilebilir. Bir A matrisi i\u00e7in Cholesky ayr\u0131\u015f\u0131m\u0131 a\u015fa\u011f\u0131daki gibi tan\u0131mlan\u0131r:\n\n* A=L.L^T veya A=U.U^T\n\n\nL, alt \u00fc\u00e7gensel matris ve L^T alt \u00fc\u00e7gensel matrisin transpozudur. Benzer tan\u0131mla U, \u00fcst \u00fc\u00e7gensel matris ve U^T \u00fcst \u00fc\u00e7gensel matrisin transpozudur. Pozitif tan\u0131ml\u0131 matrislerde Cholesky ayr\u0131\u015f\u0131m\u0131 LU ayr\u0131\u015f\u0131m\u0131ndan neredeyse iki kat daha verimlidir. ","ab94f844":"Bu \u00e7al\u0131\u015fman\u0131n amac\u0131, makine \u00f6\u011frenmesinde \u00f6nemli bir yeri olan **lineer cebiri** hem teorik hem de pratik a\u00e7\u0131dan ele almakt\u0131r. \u00c7al\u0131\u015fma kapsam\u0131nda konular a\u015fa\u011f\u0131daki ba\u015fl\u0131klar alt\u0131nda anlat\u0131lacakt\u0131r:\n\n* Part I\n* * Numpy\n* * Vekt\u00f6rler\n* * Matrisler\n* * Matris Ayr\u0131\u015f\u0131m\u0131\n* Part II\n* * Boyut Azaltma\n* * Yapay Sinir A\u011flar\u0131: Perceptron, Adaline\n* * Lineer Regresyon\n","6ee8816c":"Numpy lineer cebir k\u00fct\u00fcphanesinde vekt\u00f6r normunu hesaplayan foksiyon vard\u0131r. Fonksiyon hakk\u0131nda detayl\u0131 bilgiye [numpy.lingalg.norm](https:\/\/docs.scipy.org\/doc\/numpy-1.15.1\/reference\/generated\/numpy.linalg.norm.html) ba\u011flant\u0131s\u0131ndan ula\u015fabilirsiniz. ","99282424":"<a class=\"anchor\" id=\"6.1.\"><\/a>**6.1. PCA Y\u00f6nteminin S\u0131f\u0131rdan Kodlanmas\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nYukar\u0131da algoritmik ad\u0131mlar\u0131 verilen PCA y\u00f6nteminin kodlamas\u0131n\u0131 ger\u00e7ekle\u015ftirelim. \u00c7o\u011fu makine \u00f6\u011frenmesi modelinde oldu\u011fu gibi PCA y\u00f6nteminin ger\u00e7ekle\u015ftirilmesi i\u00e7in matris i\u015flemleri ve istatiksel hesaplamalar yap\u0131l\u0131r.\n\nPCA y\u00f6nteminin kodlamas\u0131 i\u00e7in s\u0131n\u0131f kullan\u0131lacakt\u0131r. S\u0131n\u0131f **fit()**, **transform()** ve **fit_transform()** temel fonksiyonlar\u0131n\u0131 ve __construct_projection_matrix() ve __get_eigen_pairs() yard\u0131mc\u0131 fonksiyonlar\u0131n\u0131 i\u00e7erecektir.\n","0bea0fcc":"<a class=\"anchor\" id=\"5.1.5.\"><\/a>**5.1.5. Perceptron Modelinin AND, OR, XOR Mant\u0131ksal Operat\u00f6rleri \u00c7\u0131kt\u0131lar\u0131n\u0131n Tahmininde Kullan\u0131lmas\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nYukar\u0131daki grafilerde de g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi iki \u00f6zellik i\u00e7in s\u0131n\u0131flar\u0131n bir birinden ayr\u0131\u015ft\u0131r\u0131lmas\u0131 tek bir do\u011fruyla ger\u00e7ekle\u015ftirilebilir. \n\nLineer s\u0131n\u0131fland\u0131r\u0131c\u0131lar tek bir do\u011fruyla ayr\u0131lamayan veri setleri \u00fczerinde iyi sonu\u00e7lar vermezler. Bunu g\u00f6stermek i\u00e7in en \u00e7ok kullan\u0131lan veri; OR, AND ve XOR do\u011fruluk tablolar\u0131d\u0131r. OR ve AND do\u011fruluk tablolar\u0131ndaki 0 ve 1 s\u0131n\u0131flar\u0131 lineer olarak ayr\u0131labilirken, XOR do\u011fruluk tablosundaki s\u0131n\u0131flar lineer olarak ayr\u0131lamazlar. ","91612e31":"<a class=\"anchor\" id=\"1.3.\"><\/a>**1.3. Numpy Dizilerinin De\u011fi\u015fken Tipi, \u015eekli ve Boyutu** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nNumpy ndarray dizilerinin tuttu\u011fu de\u011fi\u015fken tipi ve \u015feklini \u00f6\u011frenmeye \u00e7o\u011fu zaman ihtiya\u00e7 duyar\u0131z. ndarray nesnesinin tuttu\u011fu de\u011fi\u015fken tipini dtype \u00f6zelli\u011fiyle ve \u015fekline shape \u00f6zelli\u011fiyle \u00f6\u011frenilebilir.","0eae7b50":"<a class=\"anchor\" id=\"4.2.\"><\/a>**4.2. QR Ayr\u0131\u015f\u0131m\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nQR ayr\u0131\u015f\u0131m\u0131 bir matrisi ortogonal(Q) ve \u00fcst \u00fc\u00e7gensel(R) matrise ayr\u0131\u015ft\u0131r\u0131r. QR ayr\u0131\u015f\u0131m\u0131nda ayr\u0131\u015ft\u0131r\u0131lacak matrsin kare matris olmas\u0131 zorunlulu\u011fu yoktur. \n","3e35473a":"[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n# <a class=\"anchor\" id=\"2.\"><\/a>**2. VEKT\u00d6RLER**  \n\nVekt\u00f6rler lineer cebirin temel bile\u015fenlerinden biridir. Say\u0131lar tek bir de\u011fer tutabilirken, vekt\u00f6rler birden fazla say\u0131 de\u011ferini tutabilir. Vekt\u00f6rler basit\u00e7e; bir say\u0131 listesi olarak d\u00fc\u015f\u00fcn\u00fc\u015f\u00fcn\u00fclebilir. Say\u0131lar bir nesneyi, kavram\u0131 v.b., tek bir y\u00f6n\u00fcyle tan\u0131mlayabilir. Vekt\u00f6rler ise gerekli t\u00fcm y\u00f6nleriyle tan\u0131mlayabilir. \n\n\u00d6rne\u011fin insan ya\u015f\u0131n\u0131 tan\u0131mlamak i\u00e7in tek bir say\u0131 yetelidir; 24 ya\u015f\u0131nda. Ancak, koordinat d\u00fczleminde bir konumu belirtmek i\u00e7in iki de\u011fi\u015fkene ihtiya\u00e7 duyulur; (x=3,y=7) konumunda. Ayn\u0131 \u015feyi tan\u0131mlayan bu iki de\u011fi\u015fken vekt\u00f6r\u00fcn \u00f6geleri olarak ele al\u0131n\u0131r. Vekt\u00f6rlerin sahip olaca\u011f\u0131 \u00f6ge say\u0131s\u0131nda bir s\u0131n\u0131rlama yoktur. \n\nMakine \u00f6\u011frenmesinde vekt\u00f6rler s\u0131kl\u0131kla kullan\u0131l\u0131r. Hatta makine \u00f6\u011frenmesinin olmazsa olmazlar\u0131ndand\u0131r. G\u00f6zetimli makine \u00f6\u011frenmesinde \u00f6rnekler iki k\u0131sma ayr\u0131l\u0131r; veri ve hedef. Veri \u00f6rne\u011fin niceliklerini tutarken hedef \u00f6rne\u011fin \u00e7\u0131kt\u0131s\u0131n\u0131 tutar. T\u00fcm veri setinin tan\u0131mlanmas\u0131 (X, y) bi\u00e7iminde g\u00f6sterilir. **X** veri setindeki \u00f6rneklere ait veri vekt\u00f6rlerin t\u00fcm\u00fcn\u00fc temsil eder ve **veri** **matrisi** olarak adland\u0131r\u0131l\u0131r. **y** veri setindeki \u00f6rneklere ait \u00e7\u0131kt\u0131lar\u0131n t\u00fcm\u00fcn\u00fc temsil eder ve **\u00e7\u0131kt\u0131** **vekt\u00f6r\u00fc** olarak adland\u0131r\u0131l\u0131r. Veri k\u00fcmesinin i'ninci \u00f6rne\u011fi xi ve yi \u015fekliden g\u00f6sterilir. xi n uzunlu\u011fa sahip vekt\u00f6r ve yi skaler olarak kabul edilir. \n\nT\u00fcm makine \u00f6\u011frenme modelleri veri setinin temsili i\u00e7in matris ve vekt\u00f6rleri kullan\u0131rken t\u00fcm makine \u00f6\u011frenmesi modelleri e\u011fitim ve test a\u015famas\u0131nda matris ve vekt\u00f6rel i\u015flemler kullanmayabilir. Ancak, en bilinen ve kabul g\u00f6rm\u00fc\u015f makine \u00f6\u011frenme modelleri e\u011fitim ve test a\u015famas\u0131nda matris ve vekt\u00f6rel i\u015flemler kullan\u0131r. Bu modellerden en bilinenleri; yapay sinir a\u011flar, destek vekt\u00f6r makineleri ve  logistik regresyondur.\n\n\u00c7al\u0131\u015fman\u0131n bu b\u00f6l\u00fcm\u00fcnde temel vekt\u00f6rel i\u015flemleri ve bunlar\u0131n numy ndarray dizileri kullan\u0131larak ger\u00e7ekle\u015ftirilmesini g\u00f6rece\u011fiz.","bf3396d9":"<a class=\"anchor\" id=\"5.1.2.\"><\/a>**5.1.2. Perceptron class** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nPerceptron class kodlamas\u0131 sklearn k\u00fct\u00fcphanesinde yer alan s\u0131n\u0131fland\u0131r\u0131c\u0131lar gibi fit ve predict fonksiyonlar\u0131na sahip olacakt\u0131r. **fit** fonksiyonu modeli e\u011fitim veri seti \u00fczerinde e\u011fitmek i\u00e7in, **predict** fonksiyonu e\u011fitilen modelde test veri seti \u00fczerinde tahmin yapmak i\u00e7in kullan\u0131lacakt\u0131r. \n\n**net_input** fonksiyonu \u00f6zellik verk\u00f6t\u00fcyle a\u011f\u0131rl\u0131k vekt\u00f6r\u00fcn\u00fcn nokta \u00e7arp\u0131m\u0131n\u0131 hesaplamaktad\u0131r. **get_error** fonkisyonu tahminin hatal\u0131 olup olmad\u0131\u011f\u0131n\u0131 kontrol etmektedir. **step()** fonksiyonu s\u0131n\u0131f tahmininde bulunmaktad\u0131r. ","625adffc":"**Matris Determinant\u0131**\n\nDeterminant, kare matrisin hacmini temsil etmek i\u00e7in kullan\u0131l\u0131r ve matris sembol\u00fcn\u00fcn soluna ve sa\u011f\u0131na \u00e7izgi ekleyerek g\u00f6sterilir. \u00d6rne\u011fin A matrisinin determinant\u0131 |A| bi\u00e7iminde g\u00f6sterilir. ","de753fac":"[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\n# <a class=\"anchor\" id=\"6.\"><\/a>**6. TEMEL B\u0130LE\u015eEN ANAL\u0130Z\u0130-PRINCIPAL COMPONENT ANALYSIS(PCA)**  \n\nTemel Bile\u015fen Analizi, \u0130ngilizce ad\u0131n\u0131n k\u0131saltmas\u0131yla PCA veri boyutu azaltmak i\u00e7in kullan\u0131lan g\u00f6zetimsiz \u00f6\u011frenme y\u00f6ntemidir. Y\u00f6ntem basit lineer cebirsel ve istatiksel i\u015flemlerle projeksiyon(yans\u0131ma) matrisi hesaplan\u0131r. Projeksiyon \u00f6zellik vekt\u00f6r\u00fcn\u00fc ayn\u0131 veya daha az boyutta ba\u015fka bir \u00f6zellik vekt\u00f6r\u00fcne d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Yeni \u00f6zellik vekt\u00f6r\u00fcn\u00fcn elemanlar\u0131 s\u0131ras\u0131yla birinci, ikinci, \u00fc\u00e7\u00fcnc\u00fc, ... temel bile\u015fen olarak adland\u0131r\u0131l\u0131r. Bile\u015fenlerin veriyi temsil etme kapasiteleri temel bile\u015fen numaras\u0131 artt\u0131k\u00e7a azal\u0131r. Yani; veriyi temsil etme kapasitesi en y\u00fcksek bile\u015fen birinci temel bile\u015fendir. \n\nPCA i\u015flemleri A matrisine uyguland\u0131\u011f\u0131nda projeksiyon matrisi ad\u0131 verilen B matrisi elde edilir:\n* B=PCA(A)\n\nPCA i\u015flemlerinin birinci ad\u0131m\u0131 A matrisi s\u00fct\u00fcnlar\u0131n\u0131n ortalamas\u0131n\u0131 bulmakt\u0131r:\n* M=Mean(A)\n\nDe\u011ferleri merkezle\u015ftirmek i\u00e7in herbir s\u00fct\u00fcn kendi ortalama de\u011feriyle \u00e7\u0131kart\u0131l\u0131r:\n* C= A-M\n\nDe\u011ferleri merkezle\u015ftirilen C matrisinin kovaryans matirisi hesaplan\u0131r:\n* V=cov(C)\n\nKovaryans matrisinin \u00f6zde\u011fer ve \u00f6zvekt\u00f6r matrisleri hesaplan\u0131r:\n* \u00f6zde\u011ferler, \u00f6zvekt\u00f6rler=eig(V)\n\nEn b\u00fcy\u00fck \u00f6zde\u011ferlere kar\u015f\u0131l\u0131k gelen \u00f6zvekt\u00f6rlerin b\u00fcy\u00fckten k\u00fc\u00e7\u00fc\u011fe s\u0131ralamas\u0131 yap\u0131l\u0131r\n\n\u0130stenen temel bile\u015fen say\u0131s\u0131 kadar \u00f6zvekt\u00f6r kullan\u0131larak projeksiyon matrisi olu\u015fturulur\n\nProjeksiyon matrisi kullan\u0131larak \u00f6zellik vekt\u00f6r\u00fcn\u00fcn boyutu azalt\u0131l\u0131r","a259edf9":"Varolan bir **ndarray** dizisinin boyutunu **ndim** \u00f6zelli\u011fiyle \u00f6\u011frenebilir. **shape** \u00f6zelli\u011finin sonucunu inceleyerek de dizinin boyutu \u00f6\u011frenilebilir.  **shape** \u00f6zelli\u011fi dizinin varolan boyutlar\u0131n\u0131n de\u011ferini **tuple** olarak verir. tuple'daki eleman say\u0131s\u0131 bulunarak dizinin ka\u00e7 boyutlu oldu\u011fu \u00f6\u011frenilebilir. ","b7665319":"<a class=\"anchor\" id=\"5.1.1.\"><\/a>**5.1.1. Veri Setinin Perceptron \u0130\u00e7in Haz\u0131rlanmas\u0131** <=====>[\u0130\u00e7indekiler Men\u00fcs\u00fcne Git](#0.)\n\nBasit\u00e7e anlatmaya \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z perceptron \u00f6\u011frenme modelinin kodlamas\u0131n\u0131 ger\u00e7ekle\u015ftirmeden \u00f6nce kullanaca\u011f\u0131m\u0131z Iris veri setini Perceptron modeline haz\u0131r hale getirelim."}}