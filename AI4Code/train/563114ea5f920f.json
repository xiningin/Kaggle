{"cell_type":{"073b3acf":"code","6c225e6a":"code","e1371bcf":"code","1a7bc3ac":"code","cc7ded3b":"markdown","ed33b14e":"markdown","87948e8d":"markdown"},"source":{"073b3acf":"#https:\/\/www.kaggle.com\/golubev\/c-stochastic-product-search-65ns","6c225e6a":"%%writefile main.cpp\n#include <array>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <atomic>\n#include <random>\n#include <string.h>\nusing namespace std;\n#include <chrono>\nusing namespace std::chrono;\n\nint N_JOBS = 4;\nint END_TIME = 10;\/\/in minutes\n\nauto START_TIME = high_resolution_clock::now();\nconstexpr array<uint8_t, 15> DISTRIBUTION{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 5};  \/\/ You can setup how many families you need for swaps and what best choice use for each family\n\/\/ {2, 5} it's mean the first random family will brute force for choices 1-2 and the second random family will brute force for choices 1-5\n\nconstexpr int MAX_OCCUPANCY = 300;\nconstexpr int MIN_OCCUPANCY = 125;\nconstexpr int BEST_N = 10;\narray<uint8_t, 5000> n_people;\narray<array<uint8_t, 10>, 5000> choices;\narray<array<uint16_t, 10>, 5000> PCOSTM;\narray<array<double, 176>, 176> ACOSTM;\n\nstruct Index {\n    Index(array<uint8_t, 5000> assigned_days_) : assigned_days(assigned_days_)  {\n        setup();\n    }\n    array<uint8_t, 5000> assigned_days;\n    array<uint16_t, 100> daily_occupancy_{};\n    int preference_cost_ = 0;\n    void setup() {\n        preference_cost_ = 0;\n        daily_occupancy_.fill(0);\n        for (int j = 0; j < assigned_days.size(); ++j) {\n            daily_occupancy_[choices[j][assigned_days[j]]] += n_people[j];\n            preference_cost_ += PCOSTM[j][assigned_days[j]];\n        }\n    }\n    double calc(const array<uint16_t, 5000>& indices, const array<uint8_t, DISTRIBUTION.size()>& change) {\n        double accounting_penalty = 0.0;\n        auto daily_occupancy = daily_occupancy_;\n        int preference_cost = preference_cost_;\n        for (int i = 0; i < DISTRIBUTION.size(); ++i) {\n            int j = indices[i];\n            daily_occupancy[choices[j][assigned_days[j]]] -= n_people[j];\n            daily_occupancy[choices[j][       change[i]]] += n_people[j];\n            \n            preference_cost += PCOSTM[j][change[i]] - PCOSTM[j][assigned_days[j]];\n        }\n\n        for (auto occupancy : daily_occupancy)\n            if (occupancy < MIN_OCCUPANCY)\n                return 1e12*(MIN_OCCUPANCY-occupancy);\n            else if (occupancy > MAX_OCCUPANCY)\n                return 1e12*(occupancy - MAX_OCCUPANCY);\n\n        for (int day = 0; day < 99; ++day)\n            accounting_penalty += ACOSTM[daily_occupancy[day]-125][daily_occupancy[day+1]-125];\n\n        accounting_penalty += ACOSTM[daily_occupancy[99]-125][daily_occupancy[99]-125];\n        return preference_cost + accounting_penalty;\n    }\n    void reindex(const array<uint16_t, DISTRIBUTION.size()>& indices, const array<uint8_t, DISTRIBUTION.size()>& change) {\n        for (int i = 0; i < DISTRIBUTION.size(); ++i) {\n            assigned_days[indices[i]] = change[i];\n        }\n        setup();\n    }\n};\n\nstatic std::atomic<bool> flag(false);\nstatic Index global_index({});\n\nbool time_exit_fn(){\n    return duration_cast<minutes>(high_resolution_clock::now()-START_TIME).count() < END_TIME;\n}\n\nvoid init_data() {\n    ifstream in(\"..\/input\/santa-workshop-tour-2019\/family_data.csv\");\n    \n    assert(in && \"family_data.csv\");\n    string header;\n    int n,x;\n    char comma;\n    getline(in, header);\n    for (int j = 0; j < choices.size(); ++j) {\n        in >> x >> comma;\n        for (int i = 0; i < 10; ++i) {\n            in >> x >> comma;\n            choices[j][i] = x-1;\n        }\n        in >> n;\n        n_people[j] = n;\n    }\n    array<int, 10> pc{0, 50, 50, 100, 200, 200, 300, 300, 400, 500};\n    array<int, 10> pn{0,  0,  9,   9,   9,  18,  18,  36,  36, 235};\n    for (int j = 0; j < PCOSTM.size(); ++j)\n        for (int i = 0; i < 10; ++i)\n            PCOSTM[j][i] = pc[i] + pn[i] * n_people[j];\n    \n    for (int i = 0; i < 176; ++i)\n        for (int j = 0; j < 176; ++j)\n            ACOSTM[i][j] = i * pow(i+125, 0.5 + abs(i-j) \/ 50.0) \/ 400.0;\n}\narray<uint8_t, 5000> read_submission(string filename) {\n    ifstream in(filename);\n    assert(in && \"submission.csv\");\n    array<uint8_t, 5000> assigned_day{};\n    string header;\n    int id, x;\n    char comma;\n    getline(in, header);\n    for (int j = 0; j < choices.size(); ++j) {\n        in >> id >> comma >> x;\n        assigned_day[j] = x-1;\n        auto it = find(begin(choices[j]), end(choices[j]), assigned_day[j]);\n        if (it != end(choices[j]))\n            assigned_day[j] = distance(begin(choices[j]), it);\n    }\n    return assigned_day;\n}\n\n\ndouble calc(const array<uint8_t, 5000>& assigned_days, bool print=false) {\n    int preference_cost = 0;\n    double accounting_penalty = 0.0;\n    array<uint16_t, 100> daily_occupancy{};\n    for (int j = 0; j < assigned_days.size(); ++j) {\n        preference_cost += PCOSTM[j][assigned_days[j]];\n        daily_occupancy[choices[j][assigned_days[j]]] += n_people[j];\n    }\n    for (auto occupancy : daily_occupancy)\n        if (occupancy < MIN_OCCUPANCY)\n            return 1e12*(MIN_OCCUPANCY-occupancy);\n        else if (occupancy > MAX_OCCUPANCY)\n            return 1e12*(occupancy - MAX_OCCUPANCY);\n\n    for (int day = 0; day < 99; ++day)\n        accounting_penalty += ACOSTM[daily_occupancy[day]-125][daily_occupancy[day+1]-125];\n\n    accounting_penalty += ACOSTM[daily_occupancy[99]-125][daily_occupancy[99]-125];\n    if (print) {\n        cout << preference_cost << \" \" << accounting_penalty << \" \" << preference_cost+accounting_penalty << endl;\n    }\n    return preference_cost + accounting_penalty;\n}\n\nvoid save_sub(const array<uint8_t, 5000>& assigned_day) {\n    ofstream out(\"submission.csv\");\n    out << \"family_id,assigned_day\" << endl;\n    for (int i = 0; i < assigned_day.size(); ++i)\n        out << i << \",\" << choices[i][assigned_day[i]]+1 << endl;\n}\n        \nconst vector<array<uint8_t, DISTRIBUTION.size()>> changes = []() {\n    vector<array<uint8_t, DISTRIBUTION.size()>> arr;\n    array<uint8_t, DISTRIBUTION.size()> tmp{};\n    for (int i = 0; true; ++i) {\n        arr.push_back(tmp);\n        tmp[0] += 1;\n        for (int j = 0; j < DISTRIBUTION.size(); ++j)\n            if (tmp[j] >= DISTRIBUTION[j]) {\n                if (j >= DISTRIBUTION.size()-1)\n                    return arr;\n                tmp[j] = 0;\n                ++tmp[j+1];\n            }\n    }\n    return arr;\n}();\n\n\/\/template<class ExitFunction>\nvoid stochastic_product_search(Index index) { \/\/ 15'360'000it\/s  65ns\/it  0.065\u00b5s\/it\n    double best_local_score = calc(index.assigned_days);\n    thread_local std::mt19937 gen(std::random_device{}());\n    uniform_int_distribution<> dis(0, 4999);\n    array<uint16_t, 5000> indices;\n    iota(begin(indices), end(indices), 0);\n    array<uint16_t, DISTRIBUTION.size()> best_indices{};\n    array<uint8_t, DISTRIBUTION.size()> best_change{};\n    for (;time_exit_fn();) {\n        bool found_better = false;\n        for (int k = 0; k < BEST_N; ++k) {\n            for (int i = 0; i < DISTRIBUTION.size(); ++i) \/\/random swap\n                swap(indices[i], indices[dis(gen)]);\n            for (const auto& change : changes) {\n                auto score = index.calc(indices, change);\n                if (score < best_local_score) {\n                    found_better = true;\n                    best_local_score = score;\n                    best_change = change;\n                    copy_n(begin(indices), DISTRIBUTION.size(), begin(best_indices));\n                }\n            }\n        }\n\n        if (flag.load() == true){\n            return;\n        }\n\n        if (found_better && flag.load() == false) { \/\/ reindex from N best if found better\n            flag = true;\n\n            index.reindex(best_indices, best_change);\n            global_index = index;\n            return;\n        }\n    }\n}\n\n\nint main() {\n    init_data();\n    auto assigned_day = read_submission(\"..\/input\/submission-710934\/submission.csv\");\n\n    Index index(assigned_day);\n    global_index = index;\n    calc(index.assigned_days, true);\n\n    for(;time_exit_fn();){\n\n        std::thread threads[N_JOBS];\n        for(int i = 0; i < N_JOBS; i++){\n            threads[i] = std::thread(stochastic_product_search, index);\n        }\n        for(int i = 0; i < N_JOBS; i++){\n            threads[i].join();\n        }\n\n        auto best_score = calc(global_index.assigned_days, true);\n        save_sub(global_index.assigned_days);\n\n        flag = false;\n        index = global_index;      \n    }\n\n\n    return 0;\n}\n","e1371bcf":"!g++ -pthread -lpthread -O3 -std=c++17 -o main main.cpp","1a7bc3ac":"!.\/main","cc7ded3b":"**Run**","ed33b14e":"**Compile**","87948e8d":"**C++ code:**"}}