{"cell_type":{"e50d3a74":"code","9a7c96f5":"code","69f3f54b":"code","bb324b83":"code","8637ea90":"code","f4b6fc07":"code","36d97521":"code","96e55d18":"code","b90fddc6":"code","de0077d7":"code","168ed36d":"code","fbc33924":"code","4ed7b2c1":"code","0545978d":"code","a3f9967d":"code","6cb425a2":"code","3ae61359":"code","bb7fee30":"code","4bf60268":"markdown","3eb11603":"markdown","eadc39e3":"markdown","00ab74ed":"markdown","50eebbe7":"markdown"},"source":{"e50d3a74":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import AgglomerativeClustering\nfrom sklearn.cluster import KMeans\nfrom scipy.cluster import hierarchy\n\n# Mute the sklearn and IPython warnings\nimport warnings\nwarnings.filterwarnings('ignore', module='sklearn')\npd.options.display.float_format = '{:.2f}'.format","9a7c96f5":"data = pd.DataFrame(pd.read_csv('\/kaggle\/input\/nyse\/fundamentals.csv', sep=','))\ndata.head()","69f3f54b":"data.isnull().sum()","bb324b83":"plt.figure(figsize = (15, 3))\ndt = data.sort_values(by = 'Net Income', ascending=False).head(50)\nsns.set_context(\"notebook\")\n\nsns.barplot(x = dt['Ticker Symbol'], y =data['Net Income'], palette=(\"spring\"), ci=None)","8637ea90":"data.drop(['Unnamed: 0', 'Ticker Symbol', 'Period Ending'],axis = 1, inplace=True)\ndata.dropna(axis=1,inplace=True)\ndata.isnull().sum().all() == 0","f4b6fc07":"data.dtypes.all() == 'float64' # all floats except Ticker Symbol","36d97521":"data['Net Income'] = data['Net Income'].apply(lambda x : 1 if x > 0 else 0)","96e55d18":"data['Net Income'].value_counts()","b90fddc6":"log_columns = data.skew().sort_values(ascending=False)\nlog_columns = log_columns.loc[log_columns > 0.75]\n\nlog_columns","de0077d7":"# The log transformations\nfor col in log_columns.index:\n    data[col] = np.log1p(data[col])","168ed36d":"data.dropna(axis=1,inplace=True)","fbc33924":"sc = StandardScaler()\nfeature_columns = [x for x in data.columns if x not in 'Net Income']\nfor col in feature_columns:\n    data[col] = sc.fit_transform(data[[col]])\n\ndata.head(4)","4ed7b2c1":"km = KMeans(n_clusters=2, random_state=42)\nkm = km.fit(data[feature_columns])\n\ndata['kmeans'] = km.predict(data[feature_columns])\n(data[['Net Income','kmeans']]\n .groupby(['kmeans','Net Income'])\n .size()\n .to_frame()\n .rename(columns={0:'number'}))","0545978d":"for linkage in ['complete', 'ward']:\n    ag = AgglomerativeClustering(n_clusters=2, linkage=linkage, compute_full_tree=True)\n    ag = ag.fit(data[feature_columns])\n    data[str('agglom_'+linkage)] = ag.fit_predict(data[feature_columns])","a3f9967d":"(data[['Net Income','agglom_ward']]\n .groupby(['Net Income','agglom_ward'])\n .size()\n .to_frame()\n .rename(columns={0:'number'}))","6cb425a2":"(data[['Net Income','agglom_complete']]\n     .groupby(['Net Income','agglom_complete'])\n     .size()\n     .to_frame()\n     .rename(columns={0:'number'}))","3ae61359":"# Comparing AgglomerativeClustering with KMeans\n(data[['Net Income','agglom_complete', 'agglom_ward','kmeans']]\n .groupby(['Net Income', 'agglom_complete', 'agglom_ward', 'kmeans'])\n .size()\n .to_frame()\n .rename(columns={0:'number'}))","bb7fee30":"Z = hierarchy.linkage(ag.children_, method='ward')\n\nfig, ax = plt.subplots(figsize=(15,5))\n\n\nhierarchy.set_link_color_palette(['purple', 'orange'])\n\nden = hierarchy.dendrogram(Z, orientation='top', \n                           p=30, truncate_mode='lastp',\n                           show_leaf_counts=True, ax=ax,\n                           above_threshold_color='cyan')","4bf60268":"## Agglomerative Clustering","3eb11603":"# Train models\n\n- Fit a **K-means clustering** model with two clusters and \n- Fit 2 **Agglomerative clustering** models with two clusters (ward-link and complete-link clustering)\n- Compare the results to those obtained by K-means with regards to wine color by reporting the number of red and white observations in each cluster for both K-means and agglomerative clustering.\n- Visualize the **dendrogram** produced by agglomerative clustering\n\n## K-means","eadc39e3":"# Summary\n\nThe dataset for this project originates from from [Nasdaq Financials](https:\/\/www.nasdaq.com\/market-activity\/stocks\/ndaq\/financials) and we will only use fundamentals.csv containing New York Stock Exchange historical metrics extracted from annual SEC 10K fillings (2012-2016).\n\nIn this project, we will focus on **clustering** and apply unsupervised learning techniques to find the best candidate algorithm that accurately predicts wether a company has net profit or net loss.\nTo do that, we will transform **Net Income** column into a binary representation of whether or not a company made profit, where **0** represents **loss** and **1** represents **profit**.\n\nWhy do we use net income?\n\n**Net income** indicates a company's profit after all of its expenses have been deducted from revenues. This number appears on a company's income statement and is also an indicator of a company's profitability.\n\n# Exploratory Data Analysis","00ab74ed":"# Results\nComparing the results shows that I am able to predict profit better than loss which is what I expected given that we have more data for companies with profit(1: 1679 vs 0: 102). The best algorithm for predicting loss is the **Complete-link Agglomerative Clustering** model and for predicting profit **KMeans Clustering** seems to be the best candidate althought **Ward-link Agglomerative Clustering** achieved nearly the same result.","50eebbe7":"# Feature Transformation\n\n- Drop **Unnamed: 0**, **Ticker Symbol** and **Period Ending** column as they don't carry any information.\n- Drop columns with missing values.\n- Make sure all the columns are continuous which is what we need for K-means clustering.\n- Transform **Net Income** into a binary column\n- Ensure the data is scaled and normally distributed"}}