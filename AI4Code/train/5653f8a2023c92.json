{"cell_type":{"2ddee77c":"code","51d924af":"code","30553203":"code","9eef2b84":"code","c3486830":"code","dc70bda0":"code","7c9847f4":"code","8d1f2b0d":"markdown","2ae95dc9":"markdown","48066962":"markdown","d116b323":"markdown","83c36943":"markdown","3028ca6c":"markdown","ce8d1a3f":"markdown","bf6ac535":"markdown"},"source":{"2ddee77c":"#import some standard libraries\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport scipy as sp # for generalized eigenproblem\nimport scipy.signal as signal\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.decomposition import PCA","51d924af":"def DyCA(data, eig_threshold = 0.98):\n    \"Given data of the form (time, sensors) returns the DyCA projection and projected data with eigenvalue threshold eig_threshold\"\n    derivative_data = np.gradient(data,axis=0,edge_order=1) #get the derivative of the data\n    time_length = data.shape[0] #for time averaging\n    #construct the correlation matrices\n    C0 = np.matmul(data.transpose(), data) \/ time_length \n    C1 = np.matmul(derivative_data.transpose(), data) \/ time_length    \n    C2 = np.matmul(derivative_data.transpose(), derivative_data) \/ time_length   \n    #solve generalized eigenproblem\n    eigvalues, eigvectors = sp.linalg.eig(np.matmul(np.matmul(C1,np.linalg.inv(C0)),np.transpose(C1)), C2)\n    eigvectors = eigvectors[:,np.array(eigvalues > eig_threshold) &  np.array(eigvalues <= 1)] # eigenvalues > 1 are artifacts of singularity of C0\n    if eigvectors.shape[1] > 0:\n        C3 = np.matmul(np.linalg.inv(C1), C2)\n        proj_mat = np.concatenate((eigvectors, np.apply_along_axis(lambda x: np.matmul(C3,x), 0, eigvectors)),axis=1)\n    else:\n        raise ValueError('No generalized eigenvalue fulfills threshold!')        \n    return proj_mat, np.matmul(data,proj_mat)","30553203":"eeg_data = pd.read_csv(\"..\/input\/seizure.csv\")[[\"F12\",\"FT10\",\"TP10\",\"F8\",\"T8\",\"P8\",\"O2\",\"FP2\",\"F$\",\"C4\",\"P4\",\"Fz\",\"Cz\",\"Pz\",\"F11\",\"FT9\",\"TP9\",\"F7\",\"T7\",\"P7\",\"O1\",\"FP1\",\"F3\",\"C3\",\"P3\"]]\neeg_data.plot(legend=None);","9eef2b84":"pca = PCA(n_components=4)\npca.fit(eeg_data)\npca_eeg = pca.transform(eeg_data)\n#plot projected time-series\nplt.figure(1);\nplt.plot(pca_eeg);\n#plot in sections of the 4D phase space\nfig = plt.figure(figsize=(15,14))\nax = fig.add_subplot(2, 2, 1, projection='3d')\nax.plot(pca_eeg[:,0], pca_eeg[:,1], pca_eeg[:,2])\nax = fig.add_subplot(2, 2, 2, projection='3d')\nax.plot(pca_eeg[:,0], pca_eeg[:,1], pca_eeg[:,3])\nax = fig.add_subplot(2, 2, 3, projection='3d')\nax.plot(pca_eeg[:,1], pca_eeg[:,2], pca_eeg[:,3])\nax = fig.add_subplot(2, 2, 4, projection='3d')\nax.plot(pca_eeg[:,0], pca_eeg[:,2], pca_eeg[:,3])\nplt.show();","c3486830":"proj, proj_eeg = DyCA(eeg_data, eig_threshold=0.9)\n#plot projected time-series\nplt.figure(1);\nplt.plot(proj_eeg);\n#plot in sections of the 4D phase space\nfig = plt.figure(figsize=(15,14))\nax = fig.add_subplot(2, 2, 1, projection='3d')\nax.plot(proj_eeg[:,0], proj_eeg[:,1], proj_eeg[:,2])\nax = fig.add_subplot(2, 2, 2, projection='3d')\nax.plot(proj_eeg[:,0], proj_eeg[:,1], proj_eeg[:,3])\nax = fig.add_subplot(2, 2, 3, projection='3d')\nax.plot(proj_eeg[:,1], proj_eeg[:,2], proj_eeg[:,3])\nax = fig.add_subplot(2, 2, 4, projection='3d')\nax.plot(proj_eeg[:,0], proj_eeg[:,2], proj_eeg[:,3])\nplt.show();","dc70bda0":"def visualizeProjection(proj, fig,sub1,sub2,nsub):\n    # some parameters\n    N = 500             # number of points for interpolation\n    xy_center = [3,4]   # center of the plot\n    radius = 3.5          # radius    \n    #eeg electrode dictionary\n    eeg_dict = { \"FP1\" : [2,7.75], \"FP2\" : [4, 7.75], \"F11\" : [-0.5,5.75], \"F7\" : [0.75,5.75], \"F3\" : [1.75,5.75], \"Fz\" : [3,5.75], \"F$\" : [4.25,5.75], \"F8\" : [5.25,5.75], \"F12\" : [6.5,5.75],\"FT9\" : [-1,4.75], \"FT10\" : [7,4.75], \"T7\" : [0.5,3.75] , \"T8\" : [5.5,3.75], \"C3\" : [1.75,3.75] , \"Cz\" : [3,3.75], \"C4\" : [4.25,3.75], \"TP9\" : [-1,2.75], \"TP10\" : [7,2.75],\"P7\" : [0.5,1.75], \"P4\" : [4.25,1.75], \"P3\" : [1.75,1.75], \"Pz\" : [3,1.75], \"P8\" : [5.25,1.75],\"O1\" : [2,0.25], \"O2\" :[4,0.25] }\n    electrodes = [\"F12\",\"FT10\",\"TP10\",\"F8\",\"T8\",\"P8\",\"O2\",\"FP2\",\"F$\",\"C4\",\"P4\",\"Fz\",\"Cz\",\"Pz\",\"F11\",\"FT9\",\"TP9\",\"F7\",\"T7\",\"P7\",\"O1\",\"FP1\",\"F3\",\"C3\",\"P3\"]\n    x,y = [],[]\n    for i in electrodes:\n        x.append(eeg_dict[i][0])\n        y.append(eeg_dict[i][1])    \n\n    projData = np.asfarray(proj,float)   \n    z = projData    \n    xi = np.linspace(-8, 16, N)\n    yi = np.linspace(-8, 16, N)\n    zi = sp.interpolate.griddata((x, y), z, (xi[None,:], yi[:,None]), method='cubic')    \n    dr = xi[1] - xi[0]\n    for i in range(N):\n        for j in range(N):\n            r = np.sqrt((xi[i] - xy_center[0])**2 + (yi[j] - xy_center[1])**2)\n            if (r - dr\/2) > radius:\n                zi[j,i] = \"nan\"    \n    # make figure\n    ax = fig.add_subplot(sub1,sub2,nsub, aspect = 1)            \n    # use different number of levels for the fill and the lines\n    CS = ax.contourf(xi, yi, zi, 60, cmap = plt.cm.jet, zorder = 1)#,levels=np.linspace(-220, 170, 100),)            \n    # draw a circle\n    # change the linewidth to hide the \n    circle = mpl.patches.Circle(xy = xy_center, radius = radius, edgecolor = \"k\", facecolor = \"none\")\n    ax.add_patch(circle)            \n    # make the axis invisible \n    for loc, spine in ax.spines.items():\n        # use ax.spines.items() in Python 3\n        spine.set_linewidth(0)                \n    # remove the ticks\n    ax.set_xticks([])\n    ax.set_yticks([])\n    # add two ears\n    circle = mpl.patches.Ellipse(xy = [-0.5,4], width = 1, height = 2.0, angle = 0, edgecolor = \"k\", facecolor = \"w\", zorder = 0)\n    ax.add_patch(circle)\n    circle = mpl.patches.Ellipse(xy = [6.5,4], width = 1, height = 2.0, angle = 0, edgecolor = \"k\", facecolor = \"w\", zorder = 0)\n    ax.add_patch(circle)            \n    # set axes limits\n    ax.set_xlim(-2.5, 8.5)\n    ax.set_ylim(-0.5, 8.5)\n       ","7c9847f4":"fig = plt.figure(figsize=(15,14))\nvisualizeProjection(proj[:,0],fig,1,4,1)\nvisualizeProjection(proj[:,1],fig,1,4,2)\nvisualizeProjection(proj[:,2],fig,1,4,3)\nvisualizeProjection(proj[:,3],fig,1,4,4)\n\nfig = plt.figure(figsize=(15,14))\nvisualizeProjection(pca.components_[0,:],fig,1,4,1)\nvisualizeProjection(pca.components_[1,:],fig,1,4,2)\nvisualizeProjection(pca.components_[2,:],fig,1,4,3)\nvisualizeProjection(pca.components_[3,:],fig,1,4,4)","8d1f2b0d":"DyCA is based on the solution of the generalized eigenvalue problem\n$$C_1 C_0^{-1} C_1^\\top u = \\lambda C_2 u$$\nwhere $C_0$ is the correlation matrix of the signal with itself, $C_1$ the correlation matrix of the signal with its derivative, and $C_2$ the correlation matrix of the derivative of the data with itself. The eigenvectors $u$ to eigenvalues approximately $1$ and their $C_1^{-1} C_2 u$ counterpart form the space where to project onto.  The implementation is straightforward using NumPy and SciPy.","2ae95dc9":"Next we plot the projections. First the projection of DyCA then of PCA (this is slow).","48066962":"After implementing the method we import EEG data of an epileptic seizure. The data is measured by 25 electrodes using the 10-20-system. \n","d116b323":"The projected trajectory somehow looks deterministic but you can't really get the dynamical structure from this. Now we try DyCA.","83c36943":"To have a benchmark we use PCA to reduce to dimensionality of the EEG data and investigate it's structure in phase-space.","3028ca6c":"**Dynamical Component Analysis (DyCA)**\n\nIn this notebook I will explain how one can use DyCA for the dimensionality reduction of high-dimensional deterministic time-series. This method can be used as an alternative to PCA for feature extraction of deterministic time-series. \nThe paper, which introduced DyCA can be found on ArXiv: https:\/\/arxiv.org\/abs\/1807.10629 \nWe start by implementing a DyCA function. Then we apply the DyCA to a EEG dataset containing an epileptic seizure.\nBut first things first. Let's import some standard libraries. ","ce8d1a3f":"We obtain a much nicer trajectory, from which one can infer that this system contains a [Shilnikov bifurcation](http:\/\/www.scholarpedia.org\/article\/Shilnikov_bifurcation) as this trajectory resembles a homoclinic orbit of a saddle-node. Next step is that we compare the visualization of the projection. That is, we generate a plot, which visualize the share of each electrode to the projection by interpolating a heat map over the scalp.  We implement this as a function.","bf6ac535":"As one can see the projection of PCA has a much simpler structure, while DyCA has more interacting patterns, which most likely resembles the actual situation more realistic.  "}}