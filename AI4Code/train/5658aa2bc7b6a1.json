{"cell_type":{"b75d8234":"code","c564b1fa":"code","22351abc":"code","461e45f8":"code","eef8e880":"code","208c4e53":"code","db23bc81":"code","cf9e8707":"code","bd0a8196":"code","fb90b223":"code","a9092737":"code","a61c4151":"code","653c7c29":"code","4c5e7c31":"code","96def492":"code","d9c48088":"code","a1f14d73":"code","a07cba2f":"code","a6a946ef":"code","6be3d111":"markdown","4a7000af":"markdown","354b833c":"markdown","713f95ff":"markdown","0ff0c3dc":"markdown","999c342e":"markdown"},"source":{"b75d8234":"import numpy as np # linear algebr\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt \nimport seaborn as sns \nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.decomposition import PCA \nfrom sklearn.cluster import KMeans \nfrom sklearn.manifold import TSNE\nimport warnings \nwarnings.simplefilter(\"ignore\")\nwarnings.filterwarnings(\"ignore\")\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c564b1fa":"train = pd.read_csv(\"..\/input\/traintest-data\/train.csv\/train.csv\")\ntest = pd.read_csv(\"..\/input\/traintest-data\/test.csv\/test.csv\")\ntrain.head()","22351abc":"print(train.shape)\nprint(test.shape)\nprint(train.columns)\nprint(test.columns)\nprint(train.info())\nprint(train.describe().transpose())\nprint(\"\\n\",train.isnull().sum())","461e45f8":"def time_step(x):\n    if x < 1.0:\n        return 0\n    elif x < 1.5:\n        return 1\n    else:\n        return 2\ntrain[\"log_u_in\"] = np.log1p(train.u_in)\ntest[\"log_u_in\"] = np.log1p(test.u_in)\n\ntrain[\"time_step_class\"] = train.time_step.apply(time_step)\ntest[\"time_step_class\"] = test.time_step.apply(time_step)\n\npivot = train.pivot_table(index=\"breath_id\", columns=\"time_step_class\", values=\"log_u_in\", fill_value=0, aggfunc=\"mean\")\npivot_test = test.pivot_table(index=\"breath_id\", columns=\"time_step_class\", values=\"log_u_in\", fill_value=0, aggfunc=\"mean\")\n\npivot.head()","eef8e880":"pca = PCA(n_components=2, random_state=42)\npca.fit(pivot)\nplt.figure(figsize=(12,8),dpi=60)\nplt.plot(pca.explained_variance_ratio_.cumsum())\nplt.grid()\nplt.xlabel(\"n_components\")\nplt.ylabel(\"explained_variance_ratio_\")\nplt.xticks([0, 1])\nplt.show()","208c4e53":"train_pca = pca.transform(pivot)\ntest_pca = pca.transform(pivot_test)\n\ntrain_pca = pd.DataFrame(train_pca, columns=[\"c\"+str(c) for c in range(2)], index=pivot.index)\ntest_pca = pd.DataFrame(test_pca, columns=[\"c\"+str(c) for c in range(2)], index=pivot_test.index)\n\ntrain_pca.head()","db23bc81":"plt.figure(figsize=(12,8),dpi=60)\nsns.scatterplot(data=train_pca, x=\"c0\", y=\"c1\")\nplt.show()","cf9e8707":"km = KMeans(n_clusters=3, \n            random_state=42,\n            max_iter=100,\n            init=\"k-means++\", \n            tol=0.0001)\ny_km = km.fit_predict(train_pca)\ny_km_test = km.predict(test_pca)","bd0a8196":"from sklearn.metrics import silhouette_samples\nfrom matplotlib import cm\n\ncluster_labels = np.unique(y_km)\nn_clusters=cluster_labels.shape[0]    \n\nsilhouette_vals = silhouette_samples(train_pca, y_km, metric='euclidean')  \ny_ax_lower, y_ax_upper= 0,0\nyticks = []\n\nfor i,c in enumerate(cluster_labels):\n        c_silhouette_vals = silhouette_vals[y_km==c]   \n        c_silhouette_vals.sort()\n        y_ax_upper += len(c_silhouette_vals)              \n        color = cm.jet(float(i)\/n_clusters)              \n        plt.barh(range(y_ax_lower,y_ax_upper),            \n                         c_silhouette_vals,               \n                         height=1.0,                      \n                         edgecolor='none',                \n                         color=color)                     \n        yticks.append((y_ax_lower+y_ax_upper)\/2)          \n        y_ax_lower += len(c_silhouette_vals)              \n\nsilhouette_avg = np.mean(silhouette_vals)                 \nplt.axvline(silhouette_avg,color=\"red\",linestyle=\"--\")     \nplt.yticks(yticks,cluster_labels + 1)                     \nplt.ylabel('Cluster')\nplt.xlabel('silhouette coefficient')\nplt.show()","fb90b223":"\ntrain_pca[\"cluster\"] = y_km\ntest_pca[\"cluster\"] = y_km_test\n\ncenter = km.cluster_centers_\nplt.figure(figsize=(12,8),dpi=60)\nsns.scatterplot(data=train_pca, x=\"c0\", y=\"c1\", hue=\"cluster\")\nplt.plot(center[0, 0], center[0, 1], \"bo\", c=\"r\")\nplt.plot(center[1, 0], center[1, 1], \"bo\", c=\"r\")\nplt.plot(center[2, 0], center[2, 1], \"bo\", c=\"r\")\nplt.show()","a9092737":"train_pca[\"cluster\"] = train_pca.cluster.apply(lambda x: 0 if x == 2 else 1)\ntest_pca[\"cluster\"] = test_pca.cluster.apply(lambda x: 0 if x == 2 else 1)\nplt.figure(figsize=(12,8),dpi=60)\nsns.scatterplot(data=train_pca, x=\"c0\", y=\"c1\", hue=\"cluster\")\nplt.show()","a61c4151":"train_pca[\"breath_id\"] = train_pca.index \ntrain_pca.drop([\"c0\", \"c1\"], axis=1, inplace=True)\ntrain_pca = train_pca.reset_index(drop=True)\ntrain = pd.merge(train, train_pca, how=\"left\", on=\"breath_id\")\n\ntest_pca[\"breath_id\"] = test_pca.index \ntest_pca.drop([\"c0\", \"c1\"], axis=1, inplace=True)\ntest_pca = test_pca.reset_index(drop=True)\ntest = pd.merge(test, test_pca, how=\"left\", on=\"breath_id\")\n\n# helper \ndef find_cluster_r_c(df):\n    fig, ax = plt.subplots(2, 2, figsize=(15, 6))\n    for c in range(2):\n        for r_c in range(2):\n            x = df.loc[df.cluster == c, \"R\" if r_c == 0 else \"C\" ]\n            sns.countplot(x, ax=ax[c][r_c])\n            ax[c][r_c].set_title(f\"Cluster={c}\")\n    plt.tight_layout()\n\ndef find_cluster_transition(df, is_train=True):\n    fig, ax = plt.subplots(2, 5, figsize=(15, 6))\n    for c in range(2):\n        x = df.loc[df.cluster == c]\n        breath = x.breath_id.unique()\n        for n in range(5):\n            if is_train:\n                xx = x.loc[x.breath_id == breath[n], [\"time_step\", \"u_in\", \"u_out\", \"pressure\"]]\n            else:\n                xx = x.loc[x.breath_id == breath[n], [\"time_step\", \"u_in\", \"u_out\"]]\n            xx.set_index(\"time_step\").plot(ax=ax[c][n])\n            ax[c][n].set_title(f\"breath_id={breath[n]}\")\n            ax[c][n].set_xticks([])\n            \n            if n == 0:\n                ax[c][n].set_ylabel(f\"Cluster={c}\")\n    plt.tight_layout()\n            ","653c7c29":"sns.countplot(train.cluster)","4c5e7c31":"sns.countplot(test.cluster)\n","96def492":"find_cluster_r_c(train)\n","d9c48088":"find_cluster_r_c(test)","a1f14d73":"find_cluster_transition(train)","a07cba2f":"find_cluster_transition(test, False)","a6a946ef":"train.drop([\"time_step_class\", \"log_u_in\"], axis=1, inplace=True)\ntest.drop([\"time_step_class\", \"log_u_in\"], axis=1, inplace=True)\n\ntrain.to_csv(\"train.csv\", index=False)\ntest.to_csv(\"test.csv\", index=False)","6be3d111":"# Import both train and test data","4a7000af":"# Performing Clustering on the above dataset and perform silhouette method to get the number of clusters","354b833c":"# Visualising with Scatterplot","713f95ff":"# Please Upvote if you like the notebook","0ff0c3dc":"# Data Preprocessing","999c342e":"# Applying dimensionality reduction algorithm to reduce the number of dimensions,which can be done by using PCA which is termed as a unsupervised machine level algorithm \n\n**Process includes \n\n1.Standardise the data(scales should be similar)\n\n2.Build a Correclation matrix(To find the relationship among the variables)\n\n3.Obtain Eigen Values and Eigen Vectors\n\n4.Break into directions(Eigen Vectors) and Magnitude(Eigen Values)\n\n5.Sort Eigen values in descending order.\n\n6.Dropping less informative pairs.\n\n7.Tranforming data into KK dimentional features.**"}}