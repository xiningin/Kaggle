{"cell_type":{"43d7334c":"code","3d1efdcd":"code","486048b7":"code","3981afd3":"code","16534a54":"code","5bef4f08":"code","8e8b84ca":"code","f0d5cdf8":"code","40d556a3":"code","7e8f297f":"code","027ec88f":"code","3e1605c6":"code","d36388c0":"code","d08af1f7":"code","90257016":"code","ca349b5e":"code","82158b37":"code","1bbdf8c8":"code","312995d2":"code","ce04f4aa":"code","d15b26b2":"code","39c3b1e4":"code","adc4003a":"code","0830aa1d":"code","6fe7068b":"code","c5763cb2":"code","48da0fb5":"code","aec1aa6f":"code","fccc1473":"code","b68e6902":"code","524455ac":"code","b7482fc3":"code","9050452d":"code","b5d6c0ce":"code","2ed97325":"code","2d7bf2b8":"code","d7d3afbf":"code","d27e4a9a":"code","d33540eb":"code","3f60b009":"code","be88e126":"code","6e04b22d":"code","ae252f59":"code","f8b0c024":"code","25743098":"code","f1c0a587":"code","82b8acc0":"code","de1aace5":"code","e858a921":"code","8ff3ea2c":"code","73221084":"code","0f6f5b77":"code","2bc430fb":"code","b85586eb":"code","11f21787":"code","c88abd67":"code","c0d6c03b":"code","fe2f2905":"code","17f9d2d5":"code","d3cb40df":"code","b2bf8023":"code","e48328d4":"code","4cd5f21c":"code","5df60b4e":"code","6610c5a6":"code","d4f1bf97":"code","4c630ea3":"code","ab455fe7":"code","979b9039":"code","422bbb72":"code","1da92eea":"code","5bb66385":"code","c31b964e":"code","aefff421":"code","b54b32c0":"code","1672951c":"code","baa59555":"code","7dde06ab":"code","ae0c02de":"code","52dbdcf5":"code","4bb689ee":"code","06e0e45c":"code","729e4ec6":"code","61926c2f":"code","765adfb2":"code","6f2b3904":"code","e2051776":"code","c7f38cad":"code","1471a170":"code","c4a4da58":"code","8df4118f":"code","105f568f":"code","7b045bea":"code","11af5fe9":"code","22e7f903":"code","4344ff9c":"code","88ea8e45":"code","71fd0bdb":"code","5dde454c":"code","533851f8":"code","3e933613":"markdown","e7e43163":"markdown","71d3c1f5":"markdown","764c3c6f":"markdown","499f3929":"markdown","789a27b9":"markdown","2e0314db":"markdown","22ec0340":"markdown","f925e2c0":"markdown","ef1f21ac":"markdown","39fa7914":"markdown","4e380407":"markdown","c7eb5edb":"markdown","3a281725":"markdown","20e70e00":"markdown","76b5501c":"markdown","b6e2fdf1":"markdown","6088043e":"markdown","9ae948f8":"markdown","9c214855":"markdown","5598db23":"markdown","903f8fe7":"markdown","2fc9ee4a":"markdown","0f1d1ade":"markdown","1e4fa114":"markdown","5f141e4a":"markdown","b505b39a":"markdown","34194ae5":"markdown","85e9c456":"markdown","8f2c77e7":"markdown","01c052a3":"markdown","3636a146":"markdown","079bcf31":"markdown","ad488fd6":"markdown","b8542cbf":"markdown","74eb6f99":"markdown","bb455ef3":"markdown","3fec6f3b":"markdown","fa11654b":"markdown","4f11ad0e":"markdown","a3d1cfd7":"markdown"},"source":{"43d7334c":"country_main = 'Ukraine'\nrolling_window = False","3d1efdcd":"# Comparing data for the last 2 weeks\nnum_end = 427 if not rolling_window else 0","486048b7":"!pip install openpyxl","3981afd3":"import os\nimport io\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport openpyxl\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n\nfrom PIL import Image\nfrom IPython.display import FileLink\n\nfrom datetime import date, timedelta, datetime\nfrom fbprophet import Prophet\nfrom fbprophet.make_holidays import make_holidays_df\nfrom fbprophet.diagnostics import cross_validation, performance_metrics\nfrom fbprophet.plot import plot_cross_validation_metric\nimport holidays\nfrom collections import Counter\nimport pycountry\n\nfrom sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error\n\nimport warnings\nwarnings.simplefilter('ignore')\n\n# Thanks to https:\/\/github.com\/facebook\/prophet\/issues\/223\n# Turn off pystan warnings\nwarnings.simplefilter(\"ignore\", DeprecationWarning)\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\n# Turn off fbprophet stdout logger\nimport logging\nlogging.getLogger('fbprophet').setLevel(logging.ERROR)","16534a54":"# Thanks to https:\/\/api-covid19.rnbo.gov.ua\/\n# https:\/\/api-covid19.rnbo.gov.ua\/charts\/main-data?mode=ukraine\nprint(f'Download confirmed daily data from RNBO of Ukraine')\nmyfile = requests.get('https:\/\/api-covid19.rnbo.gov.ua\/charts\/main-data?mode=ukraine')\nopen('data', 'wb').write(myfile.content)\ndata = pd.read_json('data')\ndata","5bef4f08":"data['n_confirmed'] = data['confirmed'].diff()\n# A new wave from 6 July\ndata = data[166:].reset_index(drop=True)\n\n# Data from Autumn 2021\n#data = data[579:].reset_index(drop=True)\ndata","8e8b84ca":"# Delete the last zero value\n#data = data[:-1]\ndata['n_confirmed'] = data['n_confirmed'].astype('int')\ndata.tail(3)","f0d5cdf8":"data['n_confirmed'].plot()","40d556a3":"df2 = data[['dates','n_confirmed']].dropna()\ndf2 = df2[df2['n_confirmed'] > 0].reset_index(drop=True)\ndf2['n_confirmed'].plot()","7e8f297f":"if rolling_window:\n    df2['n_confirmed'] = df2['n_confirmed'].rolling(7).mean()\n    df2['n_confirmed'].plot()","027ec88f":"# As in my original notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning\ndf2.columns = ['Date', 'Confirmed']\ndf2['Country'] = 'Ukraine'","3e1605c6":"df2.tail(8)","d36388c0":"date_now = None","d08af1f7":"# The new data (probable value)\nn = len(df2)\ndf2.loc[n, 'Date'] = '2021-11-09'\ndf2.loc[n, 'Confirmed'] = 18988\ndf2.loc[n, 'Country'] = 'Ukraine'\ndate_now = '09.11.2021'","90257016":"if date_now is None:\n    date_now = date.today().strftime(\"%d.%m.%Y\")\ndate_now","ca349b5e":"latest_date = df2['Date'].max()\nlatest_date","82158b37":"df2.tail(5)","1bbdf8c8":"def cut_df(date0: str, \n           df:pd.DataFrame(), \n           col: str):\n    # Deletes all rows of dataframe df with df[col] < date0\n    format0 = '%Y-%m-%d'\n    df_temp = df.copy()\n    df_temp['col_dt'] = pd.to_datetime(df_temp[col], format=format0, errors='coerce')\n    date0_dt = datetime.strptime(date0, format0)\n    df_temp = df_temp[df_temp['col_dt'] >= date0_dt]\n    \n    return df_temp","312995d2":"# Thanks to dataset https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries\nholidays_df = pd.read_csv('..\/input\/covid19-holidays-of-countries\/holidays_df_of_70_countries_for_covid_19_2021.csv')\nholidays_df[holidays_df['country'] == country_main]","ce04f4aa":"holidays_df_code_countries = holidays_df['code'].unique()\nholidays_df_code_countries","d15b26b2":"# From notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef dict_code_countries_with_holidays(list_name_countries: list,\n                                      holidays_df: pd.DataFrame()):\n        \n    \"\"\"\n    Defines a dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    in the dataset \"COVID-19: Holidays of countries\" \n    \n    Returns: \n    - countries: dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    - holidays_df_identificated: DataFrame with holidays data for countries from dictionary 'countries'\n    \n    Args: \n    - list_name_countries: list of the name of countries (name or common_name or official_name or alha2 or alpha3 codes from ISO 3166)\n    - holidays_df: DataFrame with holidays \"COVID-19: Holidays of countries\"\n    \"\"\"\n    \n    import pycountry\n    \n    # Identification of countries for which there are names according to ISO\n    countries = {}\n    dataset_all_countries = list(holidays_df['code'].unique())\n    list_name_countries_identificated = []\n    list_name_countries_not_identificated = []\n    for country in list_name_countries:\n        try: \n            country_id = pycountry.countries.get(alpha_2=country)\n            if country_id.alpha_2 in dataset_all_countries:\n                countries[country] = country_id.alpha_2\n        except AttributeError:\n            try: \n                country_id = pycountry.countries.get(name=country)\n                if country_id.alpha_2 in dataset_all_countries:\n                    countries[country] = country_id.alpha_2\n            except AttributeError:\n                try: \n                    country_id = pycountry.countries.get(official_name=country)\n                    if country_id.alpha_2 in dataset_all_countries:\n                        countries[country] = country_id.alpha_2\n                except AttributeError:\n                    try: \n                        country_id = pycountry.countries.get(common_name=country)\n                        if country_id.alpha_2 in dataset_all_countries:\n                            countries[country] = country_id.alpha_2\n                    except AttributeError:\n                        try: \n                            country_id = pycountry.countries.get(alpha_3=country)\n                            if country_id.alpha_2 in dataset_all_countries:\n                                countries[country] = country_id.alpha_2\n                        except AttributeError:\n                            list_name_countries_not_identificated.append(country)\n    holidays_df_identificated = holidays_df[holidays_df['code'].isin(countries.values())]\n    \n    print(f'Thus, the dataset has holidays in {len(countries)} countries from your list with {len(list_name_countries)} countries')\n#     if len(countries) == len(dataset_all_countries):\n#         print('All available in this dataset holiday data is used')\n#     else:\n#         print(\"Holidays are available in the dataset for such countries (if there are countries from your list, then it's recommended making changes to the list)\")\n#         print(np.array(holidays_df[~holidays_df['code'].isin(countries.values())].country_official_name.unique()))\n        \n    return countries, holidays_df_identificated.reset_index(drop=True)","39c3b1e4":"countries_dict, holidays_df_base = dict_code_countries_with_holidays([country_main],holidays_df)\ncountries_dict","adc4003a":"holidays_df_base['type'] = 'holiday'\nholidays_df = holidays_df_base.copy()\nholidays_df","0830aa1d":"# From https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef adaption_df_to_holidays_df_for_prophet(df, col, countries_dict):\n    # Adaptation the dataframe df (by column=col) to holidays_df by list of countries in dictionary countries_dict\n    \n    # Filter df for countries which there are in the dataset with holidays\n    df = df[df[col].isin(list(countries_dict.keys()))].reset_index(drop=True)\n    \n    # Add alpha_2 (code from ISO 3166) for each country\n    df['iso_alpha'] = None\n    for key, value in countries_dict.items():\n        df.loc[df[col] == key, 'iso_alpha'] = value    \n    \n    return df","6fe7068b":"df2 = adaption_df_to_holidays_df_for_prophet(df2, 'Country', countries_dict)\ndf2.columns = ['Date', 'Confirmed', 'Country', 'iso_alpha']\ndf2","c5763cb2":"country_iso_alpha = df2.loc[0,'iso_alpha']\ncountry_iso_alpha","48da0fb5":"def aux_holidays_df_generator(holidays_df, dates_list, name, source, window_size, shift7=True):\n    # Add dates from dates_list with anomalies of various kinds to the holiday dataset holidays_df\n    # name - the name of the anomaly\n    # source - the source of the primary information used for processing\n    \n    last_row = len(holidays_df)\n    if shift7:\n        holidays_dates = holidays_df['ds_holidays'].tolist()\n    else: holidays_dates = holidays_df['ds'].tolist()\n    common_dates = list(set(holidays_dates).intersection(set(dates_list)))\n    dates_list = list(set(dates_list).difference(set(common_dates)))\n        \n    for i in range(len(dates_list)):\n        holidays_df = holidays_df.append([holidays_df.loc[last_row-1,:]], ignore_index=True)\n        ds_dt = datetime.strptime(dates_list[i], '%Y-%m-%d')\n        holidays_df.loc[last_row+i, 'ds_holidays'] = dates_list[i]\n        holidays_df.loc[last_row+i, 'holiday'] = name\n        holidays_df.loc[last_row+i, 'source'] = source\n        holidays_df.loc[last_row+i, 'lower_window'] = -window_size\n        holidays_df.loc[last_row+i, 'upper_window'] = window_size\n    \n        # Type of holidays or pseudo-holidays\n        if name == 'the weakening of quarantine':\n            holidays_df.loc[last_row+i, 'type'] = 'SI'\n        elif name == 'Very comfortable conditions for rest':\n            holidays_df.loc[last_row+i, 'type'] = 'meteo'\n        elif name == 'Holidays as days of less efficient work of laboratories':\n            holidays_df.loc[last_row+i, 'type'] = 'lab'\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=2)).strftime('%Y-%m-%d')\n        elif name == 'Weekend quarantine as holidays':\n            holidays_df.loc[last_row+i, 'type'] = 'weekend'\n            \n        if shift7:\n            # Make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=7)).strftime('%Y-%m-%d')\n        else:\n            # Don't make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = ds_dt.strftime('%Y-%m-%d')\n                    \n    return holidays_df.sort_values(by=['ds'])","aec1aa6f":"def plot_with_anomalies(df, cols_y_list, cols_y_list_name, dates_x, col_anomalies, val_anomal, log_y=False):\n    # Draws a plot with title - the features cols_y_list (y) and dates_x (x) from the dataframe df\n    # and with vertical lines in the date with col_anomalies == 1 \n    # with the length between the minimum and maximum of feature cols_y_list[0]\n    # with log_y = False or True\n    # cols_y_list - dictionary of the names of cols from cols_y_list (keys - name of feature, value - it's name for the plot legend), \n    # name of cols_y_list[0] is the title of the all plot\n    \n    fig = px.line(df, x=dates_x, y=cols_y_list[0], title=cols_y_list_name[cols_y_list[0]], log_y=log_y, template='gridon',width=700, height=800)\n    y_max = df[cols_y_list[0]].max()\n    for i in range(len(cols_y_list)-1):\n        fig.add_trace(go.Scatter(x=df[dates_x], y=df[cols_y_list[i+1]], mode='lines', name=cols_y_list_name[cols_y_list[i+1]]))\n        max_i = df[cols_y_list[i+1]].max()\n        y_max = max_i if max_i > y_max else y_max\n    \n    anomal_dates_list = df[df[col_anomalies] == val_anomal][dates_x].tolist()\n    y_min = min(df[cols_y_list[0]].min(),0)\n    for i in range(len(anomal_dates_list)):\n        anomal_date = anomal_dates_list[i]\n        fig.add_shape(dict(type=\"line\", x0=anomal_date, y0=y_min, x1=anomal_date, y1=y_max, line=dict(color=\"red\", width=1)))\n    fig.show()","fccc1473":"# Thank to https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data\ndata = pd.read_csv(f\"https:\/\/storage.googleapis.com\/covid19-open-data\/v2\/UA\/main.csv\")","b68e6902":"data['stringency_index_jump'] = 0\nfor i in range(len(data)-1):\n    if (data.loc[i+1,'stringency_index'] is not None) and (data.loc[i,'stringency_index'] is not None) and \\\n    (data.loc[i+1,'stringency_index'] < data.loc[i,'stringency_index']):\n        data.loc[i+1, 'stringency_index_jump'] = 1\nsource_gov = 'https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker'\ndates_gov_list = data[data['stringency_index_jump'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_gov_list, 'the weakening of quarantine', source_gov, 2)\nplot_with_anomalies(data, [\"stringency_index\"], {\"stringency_index\" : \"Stringency index and dates of the weakening of quarantine in \" + country_main}, 'date', 'stringency_index_jump', 1)","524455ac":"data.columns.tolist()","b7482fc3":"data['rest_comfort'] = 0\ndata.loc[(data['average_temperature'] >= data['average_temperature'].quantile(.95)) & (data['rainfall'] <= data['rainfall'].quantile(.05)), 'rest_comfort'] = 1\ndates_weather_list = data[data['rest_comfort'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_weather_list, 'Very comfortable conditions for rest', 'https:\/\/www.ncei.noaa.gov\/', 2)\nplot_with_anomalies(data, [\"average_temperature\", \"rainfall\"], {\"average_temperature\" : \"Average temperature over time in \" + country_main, \"rainfall\" : \"rainfall\"}, 'date', 'rest_comfort', 1)","9050452d":"df2.info()","b5d6c0ce":"holidays_dates = holidays_df_base['ds_holidays'].tolist()\nholidays_dates","2ed97325":"# Weekdays during which few tests were performed (less than 20 thousand per day) - an additional anomaly \nholidays_dates += ['2021-01-04', '2021-01-08']","2d7bf2b8":"# Weekends near the holidays in Ukraine - an additional anomaly \nholidays_dates += ['2020-04-20', '2021-05-11', '2021-06-08', '2021-06-29',\n                   '2021-01-08', '2021-05-03', '2021-05-03', '2021-05-10', \n                   '2021-06-21', '2021-08-23', '2021-10-15', '2021-12-27']","d7d3afbf":"data['holidays_date'] = 0\nholidays_df = aux_holidays_df_generator(holidays_df, holidays_dates, 'Holidays as days of less efficient work of laboratories', \n                                        'https:\/\/github.com\/dr-prodigy\/python-holidays', 0, False)","d27e4a9a":"holidays_weekend_quarantine = ['2020-11-14', '2020-11-15',\n                               '2020-11-21', '2020-11-22',\n                               '2020-11-28', '2020-11-29']","d33540eb":"holidays_lockdown = ['2021-01-08', '2021-01-09','2021-01-10','2021-01-11','2021-01-12',\n                     '2021-01-13', '2021-01-14','2021-01-15','2021-01-16','2021-01-17',\n                     '2021-01-18', '2021-01-19','2021-01-20','2021-01-21','2021-01-22',\n                     '2021-01-23', '2021-01-24']","3f60b009":"data['holidays_date'] = 0\nholidays_df = aux_holidays_df_generator(holidays_df, holidays_weekend_quarantine + holidays_lockdown, \n                                        'Weekend quarantine as holidays', \n                                        'https:\/\/www.kmu.gov.ua\/', 0, False)","be88e126":"holidays_df = cut_df(df2.loc[0, 'Date'], holidays_df, 'ds')\nholidays_df","6e04b22d":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases in \" + country_main, \n              log_y=False,template='gridon',width=700, height=600)\nfig.show()","ae252f59":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases (logarithmic scale) in \" + country_main, \n              log_y=True,template='gridon',width=700, height=600)\nfig.show()","f8b0c024":"df2['holiday'] = 0\nholidays_df_dates = holidays_df['ds'].tolist()\ndf2.loc[df2['Date'].isin(holidays_df_dates), 'holiday'] = 1\nplot_with_anomalies(df2, [\"Confirmed\"], {\"Confirmed\" : \"Confirmed cases and holidays data in \" + country_main}, 'Date', 'holiday', 1)\ndf2 = df2.drop(columns=['holiday'])","25743098":"holidays_df_dates","f1c0a587":"df2.describe()","82b8acc0":"df2.head()","de1aace5":"df2.tail()","e858a921":"# For stage 1 of tuning\nchangepoint_prior_scale_initial_level = 0.3\nweekly_season_reg_coef = 0.5\nlower_window_list = [0, -1, -2, -3] # must be exactly 4 values (identical allowed)\nupper_window_list = [0, 1, 2, 3] # must be exactly 4 values (identical allowed)\nprior_scale_list = [1, 10, 15, 20] # must be exactly 4 values (identical allowed)\nholidays_adaptive = ['holiday', 'SI', 'meteo'] # holidays with adaptive window\n\n# For stage 2 of tuning\nseveral_days_period = 620       # Period of the first big wave in Ukraine\ndelta_wave_period = 180         # Period of the wave of Delta in Ukraine (probably)\nseveral_days_season_reg_coef = 2\nseveral_days_short_period = 4\nseveral_days_short_days_fourier_order = 10\nseveral_days_short_days_season_reg_coef = 0.5\nchangepoint_prior_scale_list = [0.1, 0.15, 0.3, 0.5] # must be exactly 4 values (identical allowed)\nweekly_fourier_order_list = [7, 8, 9, 10] # must be exactly 4 values (identical allowed), \nseveral_days_fourier_order_list = [4, 5, 6, 8] # must be exactly 4 values (identical allowed)\n# 0 in fourier_order lists means the absence of this component\n\n# Check length of lists\nif (len(lower_window_list) != 4) or (len(upper_window_list) != 4) or \\\n   (len(prior_scale_list) != 4) or (len(weekly_fourier_order_list) != 4) or (len(several_days_fourier_order_list) != 4):\n    print('Number of data is wrong!')","8ff3ea2c":"df2 = df2.drop(columns = ['Country', 'iso_alpha'])\ndf2.columns = ['ds','y']\ndf2.tail(14)","73221084":"days_to_forecast = 100 # in future (after training data) - to Jan 2022\ndays_to_forecast_for_evalution = 14 # on the latest training data - for model training\nfirst_forecasted_date = sorted(list(set(df2['ds'].values)))[-days_to_forecast_for_evalution]\nend_forecasted_date = (datetime.strptime(df2['ds'].max(), \"%Y-%m-%d\")+timedelta(days = days_to_forecast)).strftime(\"%Y-%m-%d\")\nfirst_data_date = df2['ds'].min()\n\nprint('The first date of data for modeling is: ' + first_data_date)\nprint('The first date to perform forecasts for evaluation is: ' + first_forecasted_date)\nprint('The end date to perform forecasts in future for is: ' + end_forecasted_date)","0f6f5b77":"def convert10_base4(n):\n    # convert decimal to base 4\n    alphabet = \"0123\"\n    if n < 4:\n        return alphabet[n]\n    else:\n        return (convert10_base4(n \/\/ 4) + alphabet[n % 4]).format('4f')","2bc430fb":"def export_plot_to_tiff(plot, fig_name):\n    DPI = 100 # this value controls the quality of final image\n    fig_name = \"{}.tiff\".format(fig_name)\n    buf = io.BytesIO()\n    try:\n        plot.figure.savefig(buf, format=\"png\", dpi=DPI)\n    except AttributeError:\n        plot.savefig(buf, format=\"png\", dpi=DPI)\n    else:\n        print(\"Function supports only objects that have savefig() method.\")\n        return\n    buf.seek(0)\n    im = Image.open(buf)\n    im.save(fig_name)\n    im.save(buf, format=\"tiff\")\n    buf.close()\n    return FileLink(fig_name)","b85586eb":"def export_df_to_excel(df, sheet_name):\n    sheet_name = \"{}.xlsx\".format(sheet_name)\n    with pd.ExcelWriter(sheet_name, engine='openpyxl', date_format='yyyy-mm-dd') as writer:\n        df.to_excel(writer, index=False)\n    return FileLink(sheet_name)","11f21787":"def export_forecast_to_excel(df, sheet_name):\n    df.ds = df.ds.apply(lambda row: row.strftime(\"%Y-%m-%d\"))\n    df.rename(columns={\n        \"ds\": \"\u0414\u0430\u0442\u0430\",\n        \"yhat_lower\": \"\u041d\u0438\u0436\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat\": \"\u041f\u0440\u043e\u0433\u043d\u043e\u0437\u043e\u0432\u0430\u043d\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat_upper\":  \"\u0412\u0435\u0440\u0445\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\"\n    }, inplace=True)\n    return export_df_to_excel(df, sheet_name)","c88abd67":"first_eval_index = len(df2)-days_to_forecast_for_evalution\nsecond_eval_index = len(df2)\ny_real = df2.tail(days_to_forecast_for_evalution)['y']\ny_real_sum = df2.tail(days_to_forecast_for_evalution)['y'].sum()\ncountry_df_val = df2.copy()\ncountry_df_val['ds'] = pd.to_datetime(country_df_val['ds'])\ncountry_df_val = country_df_val[(country_df_val['ds'] >= pd.to_datetime(first_forecasted_date))]\ncountry_df_val","c0d6c03b":"def eval_error(forecast_df, title):\n    # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n    forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n    result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n    result_val_df = result_df.merge(country_df_val, on=['ds'])\n    result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat'].round()).abs()\n    return (result_val_df['rel_diff'].sum())*100\/y_real_sum\n    #relative_error = sum(result_val_df['rel_diff'].values)*100\/y_real_sum\n    #return (forecast_df[first_eval_index:second_eval_index]['yhat'].sum())*100\/y_real_sum\n    #return mean_absolute_error(y_real, forecast_df[first_eval_index:second_eval_index]['yhat'])","fe2f2905":"def make_forecasts(country_df, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date):\n    \n    def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='additive'):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False,\n                        holidays=holidays_df, changepoint_range=1, \n                        changepoint_prior_scale = changepoint_prior_scale_initial_level,\n                        seasonality_mode = mode_main)\n        model.add_seasonality(name='weekly', period=7, fourier_order=8, mode = 'additive', \n                              prior_scale = changepoint_prior_scale_initial_level\/weekly_season_reg_coef)\n        model.add_seasonality(name='several_days', period=several_days_period, fourier_order=5, mode = 'additive', prior_scale = 0.3)\n        model.add_seasonality(name='delta_wave', period=delta_wave_period, fourier_order=5, mode = 'additive', prior_scale = 0.3)        \n        \n        model.fit(df)\n        future = model.make_future_dataframe(periods=forecast_days)\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'additive_terms','additive_terms_lower', 'additive_terms_upper', 'weekly', 'weekly_lower', 'weekly_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'additive_terms','additive_terms_lower', 'additive_terms_upper', 'weekly',\n              'weekly_lower', 'weekly_upper']\n    \n    mode_main_list = ['additive'] # take only this mode\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode', 'n_h', 'err', 'err_h', 'prior_scale', 'how_less, %'])\n    \n    country_holidays_df = holidays_df[holidays_df['code'] == country_iso_alpha][['ds', 'holiday', 'lower_window', 'upper_window', 'prior_scale', 'type']].reset_index(drop=True)\n    country_dfs = []            \n\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    #country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    n = 64 # number of combination of parameters lower_window \/ upper_window \/ prior_scale\n    for k in range(len(mode_main_list)):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main_list[k])\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, 'without holidays')\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            lower_window_i = lower_window_list[int(parameters_iter[0])]\n            upper_window_i = upper_window_list[int(parameters_iter[1])]\n            prior_scale_i = prior_scale_list[int(parameters_iter[2])]\n            country_holidays_df.loc[country_holidays_df['type'].isin(holidays_adaptive), 'lower_window'] = lower_window_i\n            country_holidays_df.loc[country_holidays_df['type'].isin(holidays_adaptive), 'upper_window'] = upper_window_i\n            country_holidays_df.loc[country_holidays_df['type'].isin(holidays_adaptive), 'prior_scale'] = prior_scale_i\n            country_holidays_df.loc[country_holidays_df['type'] == 'lab', 'upper_window'] = upper_window_i\n            number_holidays = len(country_holidays_df[(country_holidays_df['ds'] > first_data_date) & (country_holidays_df['ds'] < end_forecasted_date)])\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, days_to_forecast_for_evalution, country_holidays_df, \n                                                                           mode_main=mode_main_list[k])\n\n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = int(round(forecast_df.tail(1)['yhat'].values[0]))\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = int(round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0))\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode'] = mode_main_list[k]\n            results.loc[i+n*k,'n_h'] = number_holidays\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'lower_window'] = lower_window_i\n            results.loc[i+n*k,'upper_window'] = upper_window_i\n            results.loc[i+n*k,'prior_scale'] = prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',len(mode_main_list)*n-1,':  lower_window =', lower_window_i, 'upper_window =',upper_window_i, 'prior_scale =', prior_scale_i)\n            print('mse_error_holidays =',relative_error_holidays, 'mse_error_holidays_min =',relative_error_holidays_min, '\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_main_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min, 'with lower_window =', str(lower_window_best),\n              ' upper_window =', str(upper_window_best), ' prior_scale =', str(prior_scale_best))\n        print('The error of model without holidays is', relative_error, '\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, days_to_forecast, mode_main=mode_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_main_list[k])\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, days_to_forecast, holidays_df,\n                                                                             mode_main=mode_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n    return forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","17f9d2d5":"%%time\nforecast_holidays_dfs, relative_errors_holidays, \\\n            forecast_future_dfs, results = make_forecasts(df2, holidays_df, \n                                                          days_to_forecast, \n                                                          days_to_forecast_for_evalution, \n                                                          first_forecasted_date)","d3cb40df":"forecast_future_dfs.head(3)","b2bf8023":"forecast_holidays_dfs.head(3)","e48328d4":"# Visualization or results\nprint(f'5D plot of Prophet model parameters and COVID-19 error of forecasting to {str(days_to_forecast_for_evalution)} days')","4cd5f21c":"# Determination of the best parameters\nresults['err_h'] = results['err_h'].astype('float')\nresults['lower_window'] = results['lower_window'].astype('int')\nresults['upper_window'] = results['upper_window'].astype('int')\nresults_m = results[results['mode'] == 'additive']","5df60b4e":"# Interactive plot with results of parameters tuning\nfig = px.scatter_3d(results_m, x='lower_window', y='upper_window', z='err_h',\n                     color='prior_scale', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for additive mode')\nfig.update(layout=dict(title=dict(x=0.5)))","6610c5a6":"#display(results_a.nsmallest(5, 'err_h'))\ndisplay(results_m.nsmallest(5, 'err_h'))","d4f1bf97":"# The smallest error:\nbest_result = results.nsmallest(1, 'err_h').reset_index(drop=True)\nlower_window_opt = best_result.lower_window[0]\nupper_window_opt = best_result.upper_window[0]\nprior_scale_opt = best_result['prior_scale'][0]\nmode_opt = best_result['mode'][0]","4c630ea3":"print(f\"Thus, for {country_main} the optimal parameters of Prophet model that gave an error = {best_result['err_h'][0]} are:\")\nprint(\"* lower_window =\", lower_window_opt)\nprint(\"* upper_window =\", upper_window_opt)\nprint(\"* prior_scale =\", prior_scale_opt)\nprint(\"* mode_opt =\", mode_opt)","ab455fe7":"holidays_df.loc[holidays_df['type'].isin(holidays_adaptive), 'lower_window'] = lower_window_opt\nholidays_df.loc[holidays_df['type'].isin(holidays_adaptive), 'upper_window'] = upper_window_opt\nholidays_df.loc[holidays_df['type'].isin(holidays_adaptive), 'prior_scale'] = prior_scale_opt\nholidays_df.loc[holidays_df['type'] == 'lab', 'upper_window'] = upper_window_opt","979b9039":"holidays_df","422bbb72":"# The smallest error:\ndisplay(best_result)","1da92eea":"def make_forecasts_stage2(country_df, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date,\n                          mode_main='additive'):\n    \n    def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='additive', \n                                  weekly_fourier_order=10, several_days_fourier_order=10,\n                                  changepoint_prior_scale = changepoint_prior_scale_initial_level, \n                                  mode_seasonality = 'additive'):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, interval_width=0.8,\n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale_initial_level,\n                        seasonality_mode = mode_main)\n        if weekly_fourier_order > 0:\n            model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale_initial_level\/weekly_season_reg_coef)\n        if several_days_fourier_order > 0:\n            model.add_seasonality(name='several_days', period=several_days_period,\n                                  fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale_initial_level\/several_days_season_reg_coef)\n            model.add_seasonality(name='delta_wave', period=delta_wave_period,\n                                  fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale_initial_level\/several_days_season_reg_coef)\n        model.add_seasonality(name='four_days', period=several_days_short_period, fourier_order=several_days_short_days_fourier_order, \n                              mode = 'additive', prior_scale = several_days_short_days_season_reg_coef)\n        \n        model.fit(df)\n        future = model.make_future_dataframe(periods=forecast_days)\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    \n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'additive_terms','additive_terms_lower', 'additive_terms_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'additive_terms','additive_terms_lower', 'additive_terms_upper']\n    #mode_seasonality_list = ['additive', 'multiplicative']\n    mode_seasonality_list = ['additive'] # take only this mode\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode_s', 'err', 'err_h', 'weekly_fn', 'several_days_fn', 'ch_p_s_fn', 'how_less, %'])\n    \n    country_dfs = []\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    #country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    n = 64 # number of combination of parameters weekly_fourier_order \/ several_days_fourier_order\n    relative_error_min = 100\n    for k in range(len(mode_seasonality_list)):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                     mode_seasonality = mode_seasonality_list[k])\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, 'without holidays')\n        #mode_seasonality_w_best = mode_seasonality_list[1] if relative_error < relative_error_min else mode_seasonality_list[0]\n        mode_seasonality_w_best = mode_seasonality_list[0]\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            weekly_fourier_order_i = weekly_fourier_order_list[int(parameters_iter[0])]\n            several_days_fourier_order_i = several_days_fourier_order_list[int(parameters_iter[1])]\n            changepoint_prior_scale_i = changepoint_prior_scale_list[int(parameters_iter[2])]\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, days_to_forecast_for_evalution, \n                                                                           holidays_df, mode_main=mode_main,\n                                                                           weekly_fourier_order = weekly_fourier_order_i, \n                                                                           several_days_fourier_order = several_days_fourier_order_i,\n                                                                           changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                           mode_seasonality = mode_seasonality_list[k])\n            \n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = int(round(forecast_df.tail(1)['yhat'].values[0]))\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = int(round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0))\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode_s'] = mode_seasonality_list[k]\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'weekly_fn'] = weekly_fourier_order_i\n            results.loc[i+n*k,'several_days_fn'] = several_days_fourier_order_i\n            results.loc[i+n*k,'ch_p_s_fn'] = changepoint_prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',len(mode_seasonality_list)*n-1,':  weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n                  'changepoint_prior_scale =', changepoint_prior_scale_i)\n            print('relative_error_holidays =',relative_error_holidays, 'relative_error_holidays_min =',relative_error_holidays_min, '\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_seasonality_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min,\n              'weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n              'changepoint_prior_scale =', changepoint_prior_scale_i)\n        print('The error of model without holidays is', relative_error, '\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                                             mode_seasonality = mode_seasonality_w_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_seasonality_w_best)\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, days_to_forecast_for_evalution, \n                                                                             holidays_df, mode_main=mode_main,\n                                                                             weekly_fourier_order = weekly_fourier_order_best, \n                                                                             several_days_fourier_order = several_days_fourier_order_best,\n                                                                             changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                             mode_seasonality = mode_seasonality_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_seasonality_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n    return forecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","5bb66385":"%%time\nforecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results = make_forecasts_stage2(df2, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date, mode_main=mode_opt)","c31b964e":"results.to_csv('results.csv', index=False)","aefff421":"results","b54b32c0":"# Visualization or results\nprint(f'3D plot of Prophet model parameters and COVID-19 error of forecasting to {str(days_to_forecast_for_evalution)} days')","1672951c":"# Determination of the best parameters\nresults['err_h'] = results['err_h'].astype('float')\nresults['weekly_fn'] = results['weekly_fn'].astype('int')\nresults['several_days_fn'] = results['several_days_fn'].astype('int')\nresults_m = results[results['mode_s'] == 'additive']","baa59555":"# Interactive plot with results of parameters tuning - additive\nfig = px.scatter_3d(results_m, x='weekly_fn', y='several_days_fn', z='err_h',\n                    color='ch_p_s_fn', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for additive mode')\nfig.update(layout=dict(title=dict(x=0.5)))","7dde06ab":"#display(results_a.nsmallest(5, 'err_h'))\ndisplay(results_m.nsmallest(5, 'err_h'))","ae0c02de":"# The smallest error:\nbest_result2 = results.nsmallest(1, 'err_h').reset_index(drop=True)\nweekly_fourier_order_opt = best_result2.weekly_fn[0]\nseveral_days_fourier_order_opt = best_result2.several_days_fn[0]\nmode_seasonality_opt = mode_seasonality_weekly_opt = mode_seasonality_several_days_opt = best_result2['mode_s'][0]\nchangepoint_prior_scale_opt = best_result2['ch_p_s_fn'][0]\nweekly_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/weekly_season_reg_coef\nseveral_days_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/several_days_season_reg_coef","52dbdcf5":"# The smallest error:\ndisplay(best_result2)","4bb689ee":"best_result_all = round(best_result2.err_h[0], 2)\nprint(f\"Thus, for {country_main} the optimal 12 parameters of Prophet model that gave an error = {best_result_all}% are:\")\nprint(\"* lower_window =\", lower_window_opt)\nprint(\"* upper_window =\", upper_window_opt)\nprint(\"* prior_scale =\", prior_scale_opt)\nprint(\"* changepoint_prior_scale =\", changepoint_prior_scale_opt)\nprint(\"* mode_opt =\", mode_opt)\nprint(\"* weekly_fourier_order =\", weekly_fourier_order_opt)\nprint(\"* mode_seasonality_weekly =\", mode_seasonality_weekly_opt)\nprint(\"* weekly_seasonality_prior_scale =\", weekly_seasonality_prior_scale_opt)\nprint(\"* several_days_fourier_order = delta_wave_fourier_order =\", several_days_fourier_order_opt)\nprint(\"* mode_seasonality_several_days = mode_seasonality_delta_wave =\", mode_seasonality_several_days_opt)\nprint(\"* several_days_seasonality_prior_scale = delta_wave_seasonality_prior_scale =\", several_days_seasonality_prior_scale_opt)","06e0e45c":"def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='additive', \n                               weekly_fourier_order=10, several_days_fourier_order=10, \n                               changepoint_prior_scale = changepoint_prior_scale_initial_level, \n                               mode_seasonality = 'additive'):\n    # Optimal Prophet model training and forecasting\n\n    model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, interval_width=0.8,\n                    holidays=holidays_df, changepoint_range=1, \n                    changepoint_prior_scale = changepoint_prior_scale,\n                    seasonality_mode = mode_main)\n    if weekly_fourier_order > 0:\n        model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n    if several_days_fourier_order > 0:\n        model.add_seasonality(name='several_days', period=several_days_period,\n                              fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n        model.add_seasonality(name='delta_wave', period=delta_wave_period,\n                                  fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale_initial_level\/several_days_season_reg_coef)\n    model.add_seasonality(name='four_days', period=several_days_short_period, fourier_order=several_days_short_days_fourier_order, \n                          mode = 'additive', prior_scale = several_days_short_days_season_reg_coef)\n    \n    model.fit(df)\n    future = model.make_future_dataframe(periods=forecast_days)\n    forecast = model.predict(future)\n    \n    # Make values integer, and replace negative values with zero\n    feature_all = ['yhat_lower', 'yhat', 'yhat_upper']\n    forecast[feature_all] = forecast[feature_all].round().astype('int')\n    for feature in feature_all:\n        forecast.loc[forecast[feature] < 0, feature] = 0\n    \n    return model, forecast","729e4ec6":"model_future_opt, forecast_future_opt = model_training_forecasting(df2, days_to_forecast, holidays_df, mode_main=mode_opt,\n                                                                   weekly_fourier_order = weekly_fourier_order_opt, \n                                                                   several_days_fourier_order = several_days_fourier_order_opt,\n                                                                   changepoint_prior_scale = changepoint_prior_scale_opt,\n                                                                   mode_seasonality = mode_seasonality_opt)","61926c2f":"fig_opt = model_future_opt.plot(forecast_future_opt)\nexport_plot_to_tiff(fig_opt, 'fig_forecast_future_opt_all')","765adfb2":"fig_opt_components = model_future_opt.plot_components(forecast_future_opt)\nexport_plot_to_tiff(fig_opt_components, 'fig_forecast_future_opt_components_all')","6f2b3904":"forecast_future_opt_future = forecast_future_opt[['ds', 'yhat_lower', 'yhat', 'yhat_upper']]\nforecast_future_opt_future_days = forecast_future_opt_future.tail(days_to_forecast)\nforecast_future_opt_future_days","e2051776":"forecast_future_opt_future_len=len(forecast_future_opt_future)\nforecast_future_opt_future[len(df2)-days_to_forecast_for_evalution:len(df2)][['ds', 'yhat']]","c7f38cad":"df2.tail(days_to_forecast_for_evalution)","1471a170":"y_val = forecast_future_opt_future[len(df2)-days_to_forecast_for_evalution:len(df2)]['yhat']\ny = df2.tail(days_to_forecast_for_evalution)['y']\nprint(f\"r2_score - {r2_score(y, y_val)}, mean_absolute_error - {mean_absolute_error(y, y_val)}, root_mean_squared_error - {(mean_squared_error(y, y_val))**(.5)}\")","c4a4da58":"export_forecast_to_excel(forecast_future_opt_future_days, 'forecast_future_opt_future_14_days')","8df4118f":"forecast_future_opt_future.to_csv('forecast_future_opt_future.csv', index=False)\nbest_result2.to_csv('best_result2.csv', index=False)\nholidays_df.to_csv('holidays_df_all.csv', index=False)","105f568f":"prev_df_files = ['..\/input\/covid19-in-ukraine-daily-data\/12.10.2021 - n_confirmed cases forecast for 2 weeks by opt_Prophet_model from 2020-07-06.csv']\ndates_prev = [\"12.10.2021\"]\ncolors = ['r', 'brown', 'navy', 'r', 'g', 'yellow', 'magenta', 'gold']    # except for c='#0072B2', 'gray', 'k'","7b045bea":"def prev_df_reading(df_file_list, dates_prev):\n    # Take data with previous forecasts\n    \n    prev_df = []\n    for i in range(len(df_file_list)):\n        prev_df_i = pd.read_csv(df_file_list[i])\n        if dates_prev[i] == \"14.09.2021\":\n            prev_df_i = prev_df_i[98:]\n        print(f\"Forecast at {dates_prev[i]}:\")\n        display(prev_df_i.tail(3))\n        prev_df.append(prev_df_i)\n    \n    return prev_df","11af5fe9":"prev_df = prev_df_reading(prev_df_files, dates_prev)","22e7f903":"forecast_future_opt_future.tail(days_to_forecast)","4344ff9c":"def comparing_plot(df_new, prev_df, dates_prev, df, num, name_plot_start):\n    # Drawing plots for comparison of previous forecasts in English and Ukranian languages\n    \n    if rolling_window:\n        for df_old in prev_df:\n            df_old['yhat'] = df_old['yhat'].rolling(7).mean()\n    \n    if num > 0:\n        df_new = df_new[num:]\n        for i in range(len(prev_df)):\n            prev_df[i] = prev_df[i][num:]\n        df = df[num:]\n            \n    def plot_lang(prev_df, labels_list, name_plot):\n        # Drawing plot for comparison of previous forecasts in given language\n        \n        fig = plt.figure(facecolor='w', figsize=(16,8))\n\n        for i in range(len(prev_df)):\n            # Old forecast\n            df_old = prev_df[i]\n            t_old = pd.to_datetime(df_old['ds'].tolist())\n            plt.plot(t_old, df_old['yhat'], ls='-', c=colors[i], label = labels_list[i+1])\n            if not rolling_window:\n                plt.fill_between(t_old, df_old['yhat_lower'], df_old['yhat_upper'], color=colors[i], alpha=0.2)\n\n        # New forecast\n        t_new = pd.to_datetime(df_new['ds'].tolist())\n        plt.plot(t_new, df_new['yhat'], ls='-', c='#0072B2', label = labels_list[0])\n        if not rolling_window:\n            plt.fill_between(t_new, df_new['yhat_lower'], df_new['yhat_upper'], color='#0072B2', alpha=0.2)\n        \n        # Observation data\n        t = pd.to_datetime(df['ds'].tolist())\n        plt.scatter(t, df['y'], c='k', label = labels_list[-1])\n\n        plt.legend(loc='best')\n        plt.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n        fig.tight_layout()\n        \n        export_plot_to_tiff(fig, name_plot)\n    \n    \n    # Prepare dates for plots\n    date_today = date_now\n    forecast_today_en = f\"Forecast at {date_today}\"\n    forecast_today_ua = f\"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 {date_today}\"\n    labels_list_en = [forecast_today_en]\n    labels_list_ua = [forecast_today_ua]\n    for dates in dates_prev:\n        labels_list_en.append(f\"Forecast at {dates}\")\n        labels_list_ua.append(f\"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 {dates}\")\n    labels_list_en.append(\"Official data\")\n    labels_list_ua.append(\"\u0414\u0430\u043d\u0456 \u0420\u041d\u0411\u041e \u0423\u043a\u0440\u0430\u0457\u043d\u0438\")\n    \n    # English version\n    plot_lang(prev_df, labels_list_en, name_plot_start + 'forecast_today_all_en')\n    \n    # Ukranian version\n    plot_lang(prev_df, labels_list_ua, name_plot_start + 'forecast_today_all_ua')","88ea8e45":"def comparing_plot2(df_new, prev_df, dates_prev, df, num, name_plot_start):\n    # Drawing plots for comparison of previous forecasts in English and Ukranian languages\n    \n    if rolling_window:\n        for df_old in prev_df:\n            df_old['yhat'] = df_old['yhat'].rolling(7).mean()\n    \n    if num > 0:\n        df_new = df_new[num:]\n        df = df[num:]\n            \n    def plot_lang(prev_df, labels_list, name_plot):\n        # Drawing plot for comparison of previous forecasts in given language\n        \n        fig = plt.figure(facecolor='w', figsize=(16,8))\n\n        for i in range(len(prev_df)):\n            # Old forecast\n            df_old = prev_df[i]\n            \n            if dates_prev[i] == \"12.10.2021\":\n                num_start = num_end\n            else: num_start = 14\n                \n            t_old = pd.to_datetime(df_old['ds'][num_start:].tolist())\n            plt.plot(t_old, df_old['yhat'][num_start:], ls='-', c=colors[i], label = labels_list[i+1])\n            if not rolling_window:\n                plt.fill_between(t_old, df_old['yhat_lower'][num_start:], df_old['yhat_upper'][num_start:], color=colors[i], alpha=0.2)\n\n        # New forecast\n        t_new = pd.to_datetime(df_new['ds'].tolist())\n        plt.plot(t_new, df_new['yhat'], ls='-', c='#0072B2', label = labels_list[0])\n        if not rolling_window:\n            plt.fill_between(t_new, df_new['yhat_lower'], df_new['yhat_upper'], color='#0072B2', alpha=0.2)\n        \n        # Observation data\n        t = pd.to_datetime(df['ds'].tolist())\n        plt.scatter(t, df['y'], c='k', label = labels_list[-1])\n\n        plt.legend(loc='best')\n        plt.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n        fig.tight_layout()\n        \n        export_plot_to_tiff(fig, name_plot)\n    \n    \n    # Prepare dates for plots\n    date_today = date_now\n    forecast_today_en = f\"Forecast at {date_today}\"\n    forecast_today_ua = f\"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 {date_today}\"\n    labels_list_en = [forecast_today_en]\n    labels_list_ua = [forecast_today_ua]\n    for dates in dates_prev:\n        labels_list_en.append(f\"Forecast at {dates}\")\n        labels_list_ua.append(f\"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 {dates}\")\n    labels_list_en.append(\"Official data\")\n    labels_list_ua.append(\"\u0414\u0430\u043d\u0456 \u0420\u041d\u0411\u041e \u0423\u043a\u0440\u0430\u0457\u043d\u0438\")\n    \n    # English version\n    plot_lang(prev_df, labels_list_en, name_plot_start + 'forecast_today_all_en')\n    \n    # Ukranian version\n    plot_lang(prev_df, labels_list_ua, name_plot_start + 'forecast_today_all_ua')","71fd0bdb":"# Comparing for all data\ncomparing_plot(forecast_future_opt_future, prev_df.copy(), dates_prev, df2, 0, 'All_')","5dde454c":"# Comparing data for the last 2 weeks\nnum_end = 413 if not rolling_window else 0\n#num_end = 364 if not rolling_window else 0\n#num_end = 49 if not rolling_window else 0\ncomparing_plot2(forecast_future_opt_future, prev_df, dates_prev, df2, num_end, 'Last_2_weeks_')","533851f8":"print(f\"Thus, for {country_main} the optimal Prophet model has the forecasting errors:\")\nprint(f\"- r2_score - {round(r2_score(y, y_val),2)} (the best value - 1.0)\")\n#print(f\"- MSE (mean_absolute_error) - {int(round(mean_absolute_error(y, y_val),0))} cases\")\n#print(f\"- RMSE (root_mean_squared_error) - {int(round((mean_squared_error(y, y_val))**(.5), 0))} cases\")\nprint(f\"- the main error (WAPE - relative error) = {best_result_all} % (the best value - 0.0 %).\")","3e933613":"### 3.2.4. Weekend quarantine as holidays<a class=\"anchor\" id=\"3.2.4\"><\/a>\n\n[Back to Table of Contents](#0.1)","e7e43163":"## 6. Prediction <a class=\"anchor\" id=\"6\"><\/a>\n\n[Back to Table of Contents](#0.1)","71d3c1f5":"#### Thanks to [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","764c3c6f":"### 3.2.3. Holidays as days of less efficient work of laboratories <a class=\"anchor\" id=\"3.2.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","499f3929":"### Thank to dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries)","789a27b9":"## 1. Import libraries<a class=\"anchor\" id=\"1\"><\/a>\n\n[Back to Table of Contents](#0.1)","2e0314db":"## Earliest Cases","22ec0340":"<a class=\"anchor\" id=\"0.1\"><\/a>\n## Table of Contents\n\n1. [Import libraries](#1)\n1. [Download data](#2)\n1. [Selection data with holidays](#3)\n    - [Holidays with a shift](#3.1)\n    - [Additional dates of anomalies as holidays](#3.2)    \n        - [The weakening of quarantine](#3.2.1)\n        - [Very comfortable conditions for rest](#3.2.2)\n        - [Holidays as days of less efficient work of laboratories](#3.2.3)\n        - [Weekend quarantine as holidays](#3.2.4)        \n1. [EDA](#4)\n    - [Plots - Confirmed cases over time](#4.1)\n    - [Statistics](#4.2)\n    - [Set initial values for tuning](#4.3)\n1. [Tuning Prophet model and holidays parameters](#5)\n    - [Stage 1 - Tuning holiday parameters](#5.1)\n        - [Model training, forecasting and evaluation](#5.1.1)\n        - [Results visualization](#5.1.2)\n    - [Stage 2 - Tuning seasonality parameters](#5.2)\n        - [Model training, forecasting and evaluation](#5.2.1)\n        - [Results visualization](#5.2.2)\n    - [Results of all tuning](#5.3)\n1. [Prediction](#6)\n1. [Comparison with previous forecasts](#7)","f925e2c0":"## 5.1. Stage 1 - Tuning holiday parameters<a class=\"anchor\" id=\"5.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","ef1f21ac":"### Calculation of forecasting errors","39fa7914":"## 5.1.2. Results visualization<a class=\"anchor\" id=\"5.1.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","4e380407":"## 7. Comparison with previous forecasts <a class=\"anchor\" id=\"7\"><\/a>\n\n\n[Back to Table of Contents](#0.1)","c7eb5edb":"## Latest Cases","3a281725":"## 5.3. Results of all tuning<a class=\"anchor\" id=\"5.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","20e70e00":"#### Thanks to:\n* [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data)\n* [NOAA](https:\/\/www.ncei.noaa.gov\/)","76b5501c":"# Acknowledgements\n\n### Datasets:\n- my dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data) - it is recommended to follow the updates\n- official data of Ukraine (https:\/\/covid19.rnbo.gov.ua\/)\n- dataset [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (including dataset [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker) and dataset [NOAA](https:\/\/www.ncei.noaa.gov\/)) : @article{Wahltinez2020,author = \"Oscar Wahltinez and Matt Lee and Anthony Erlinger and Mayank Daswani and Pranali Yawalkar and Kevin Murphy and Michael Brenner\", year = 2020, title = \"COVID-19 Open-Data: curating a fine-grained, global-scale data repository for SARS-CoV-2\", note = \"Work in progress\",  url = {https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data},} \n- my dataset with holidays data [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) - it is recommended to follow the updates\n\n### Notebooks:\n- notebook [COVID in UA: Prophet with 4, Nd seasonality](https:\/\/www.kaggle.com\/vbmokin\/covid-in-ua-prophet-with-4-nd-seasonality)\n- notebook [COVID-19-in-Ukraine: Prophet & holidays tuning](https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning)\n- notebook [COVID-19 Novel Coronavirus EDA & Forecasting Cases](https:\/\/www.kaggle.com\/khoongweihao\/covid-19-novel-coronavirus-eda-forecasting-cases) from [@Wei Hao Khoong](https:\/\/www.kaggle.com\/khoongweihao)\n\n### Libraries from GitHub:\n- https:\/\/facebook.github.io\/prophet\/\n- https:\/\/facebook.github.io\/prophet\/docs\/\n- https:\/\/github.com\/facebook\/prophet\n- https:\/\/github.com\/dr-prodigy\/python-holidays","b6e2fdf1":"### 3.2.2. Very comfortable conditions for rest <a class=\"anchor\" id=\"3.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","6088043e":"I hope you find this notebook useful and enjoyable.","9ae948f8":"## 5.2.1. Model training, forecasting and evaluation<a class=\"anchor\" id=\"5.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","9c214855":"## 4. EDA<a class=\"anchor\" id=\"4\"><\/a>\n\n[Back to Table of Contents](#0.1)","5598db23":"## Describe statistics","903f8fe7":"#### Thanks to [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker)","2fc9ee4a":"Import libraries","0f1d1ade":"<a class=\"anchor\" id=\"0\"><\/a>\n# COVID-19 in Ukraine: long-term forecast with the Prophet for several months in the future","1e4fa114":"## 3. Selection data with holidays<a class=\"anchor\" id=\"3\"><\/a>\n\n[Back to Table of Contents](#0.1)","5f141e4a":"## 3.1. Holidays with a shift<a class=\"anchor\" id=\"3.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","b505b39a":"## 4.1. Plots - Confirmed cases over time<a class=\"anchor\" id=\"4.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","34194ae5":"## 2. Download data<a class=\"anchor\" id=\"2\"><\/a>\n\n[Back to Table of Contents](#0.1)","85e9c456":"#### Thanks to https:\/\/api-covid19.rnbo.gov.ua\/","8f2c77e7":"## [Go to Top](#0)","01c052a3":"## 5.2.2. Results visualization<a class=\"anchor\" id=\"5.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","3636a146":"## 5.2. Stage 2 - Tuning seasonality parameters<a class=\"anchor\" id=\"5.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","079bcf31":"## 3.2. Additional dates of anomalies as holidays<a class=\"anchor\" id=\"3.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","ad488fd6":"### We will select only the last wave: from the August","b8542cbf":"## 4.3. Set initial values for tuning<a class=\"anchor\" id=\"4.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","74eb6f99":"## 5. Tuning Prophet model and holidays parameters<a class=\"anchor\" id=\"5\"><\/a>\n\n[Back to Table of Contents](#0.1)","bb455ef3":"### 3.2.1. The weakening of quarantine<a class=\"anchor\" id=\"3.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","3fec6f3b":"# Dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","fa11654b":"## 5.1.1. Model training, forecasting and evaluation<a class=\"anchor\" id=\"5.1.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","4f11ad0e":"## 4.2. Statistics<a class=\"anchor\" id=\"4.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","a3d1cfd7":"Your comments and feedback are most welcome."}}