{"cell_type":{"9db67289":"code","6bb134db":"code","f5d7c21a":"code","d78f6f28":"code","c3d5aaef":"code","b4c34122":"code","77ad8318":"code","9a3685be":"code","14416eb4":"code","15d24cf8":"code","870b110a":"code","89ef04ac":"code","d97fc209":"code","5e95eb83":"code","00894f89":"code","634918e7":"code","935f8779":"code","2d497bb2":"code","951768cd":"code","b66338aa":"code","ed5ad5ad":"code","61cc93f4":"code","882bfbf8":"code","22378e59":"code","4e1741b5":"code","ff45b9a9":"code","7a8de3f3":"code","c4f4a3ae":"code","0c4dfcf4":"code","ef94415d":"code","65431ca4":"code","5ad6d4be":"code","40c70c84":"code","a8c24635":"code","ef6aa016":"code","8ba53e2c":"code","58c6a2fc":"code","24fb3533":"code","7411c050":"code","69d002e3":"markdown","345f18d5":"markdown","d8438490":"markdown","7fcfa60b":"markdown","500eadc0":"markdown","8153d08e":"markdown","08b613c7":"markdown","1f33a92e":"markdown","586d4001":"markdown","4fb22290":"markdown","4ee6093b":"markdown"},"source":{"9db67289":"UPDATE = True","6bb134db":"import os\nimport urllib\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom pandas.plotting import register_matplotlib_converters\nfrom itertools import cycle\nregister_matplotlib_converters()","f5d7c21a":"# data from https:\/\/data.humdata.org\/dataset\/novel-coronavirus-2019-ncov-cases\nURL_confirmed = 'https:\/\/bit.ly\/3c7gjoh'\nURL_deaths = 'https:\/\/bit.ly\/39VZqeu'\nURL_recovered = 'https:\/\/bit.ly\/2UR4pca'\nLOAD_DIR = '\/kaggle\/working\/loaded'\n\ndef fetch_covid_data(url, fname, load_dir=LOAD_DIR):\n    load_to = os.path.join(LOAD_DIR, fname)\n    urllib.request.urlretrieve(url, load_to)\n\nif UPDATE:\n    if not os.path.exists(LOAD_DIR):\n        os.mkdir(LOAD_DIR)\n    fetch_covid_data(url=URL_confirmed, fname='confirmed.csv')\n    fetch_covid_data(url=URL_deaths, fname='deaths.csv')\n    fetch_covid_data(url=URL_recovered, fname='recovered.csv')\n\nCONFIRMED_PATH = '\/kaggle\/working\/loaded\/confirmed.csv'\nRECOVERED_PATH = '\/kaggle\/working\/loaded\/recovered.csv'\nDEATHS_PATH = '\/kaggle\/working\/loaded\/deaths.csv'","d78f6f28":"expected_no_nan = ['Country\/Region', 'Lat', 'Long', 'Date', 'Value']","c3d5aaef":"confirmed = pd.read_csv(CONFIRMED_PATH)\nconfirmed.head()","b4c34122":"assert confirmed[expected_no_nan].isna().sum().sum() == 0\nprint('RAW:')\nconfirmed.info()","77ad8318":"# All the cleaning stuff\nconfirmed.drop(0, axis=0, inplace=True)\nconfirmed.columns = ['Province', 'Country', 'Lat', 'Long', 'Date', 'Confirmed', \n                     'ISO', 'Region_Code', 'Sub_Region_Code', 'Intermediate_Region_Code']\nfill_values = dict(Region_Code=-1,\n                   Sub_Region_Code=-1,\n                   Intermediate_Region_Code=-1,\n                   ISO='unknown',\n                   Province='unknown')\nconfirmed.fillna(fill_values, downcast=True, inplace=True)\n\ndtype = dict(Province=\"object\",\n             Country=\"object\",\n             Lat=\"float\",\n             Long='float',\n             Date='datetime64',\n             Confirmed='int', \n             ISO='object',\n             Region_Code='int',\n             Sub_Region_Code='int',\n             Intermediate_Region_Code='int')\nconfirmed = confirmed.astype(dtype)","9a3685be":"assert confirmed.isna().sum().sum() == 0\nprint('AFTER CLEANING:')\nconfirmed.info()","14416eb4":"confirmed.head()","15d24cf8":"deaths = pd.read_csv(DEATHS_PATH)\ndeaths.head()","870b110a":"assert deaths[expected_no_nan].isna().sum().sum() == 0\nprint('RAW:')\ndeaths.info()","89ef04ac":"# All the cleaning stuff\ndeaths.drop(0, axis=0, inplace=True)\ndeaths.columns = ['Province', 'Country', 'Lat', 'Long', 'Date', 'Deaths', \n                  'ISO', 'Region_Code', 'Sub_Region_Code', 'Intermediate_Region_Code']\nfill_values = dict(Region_Code=-1,\n                   Sub_Region_Code=-1,\n                   Intermediate_Region_Code=-1,\n                   ISO='unknown',\n                   Province='unknown')\ndeaths.fillna(fill_values, downcast=True, inplace=True)\n\ndtype = dict(Province=\"object\",\n             Country=\"object\",\n             Lat=\"float\",\n             Long='float',\n             Date='datetime64',\n             Deaths='int', \n             ISO='object',\n             Region_Code='int',\n             Sub_Region_Code='int',\n             Intermediate_Region_Code='int')\ndeaths = deaths.astype(dtype)","d97fc209":"assert deaths.isna().sum().sum() == 0\nprint('AFTER CLEANING:')\ndeaths.info()","5e95eb83":"deaths.head()","00894f89":"recovered = pd.read_csv(RECOVERED_PATH)\nrecovered.head()","634918e7":"assert recovered[expected_no_nan].isna().sum().sum() == 0\nprint('RAW:')\nrecovered.info()","935f8779":"# All the cleaning stuff\nrecovered.drop(0, axis=0, inplace=True)\nrecovered.columns = ['Province', 'Country', 'Lat', 'Long', 'Date', 'Recovered', \n                  'ISO', 'Region_Code', 'Sub_Region_Code', 'Intermediate_Region_Code']\nfill_values = dict(Region_Code=-1,\n                   Sub_Region_Code=-1,\n                   Intermediate_Region_Code=-1,\n                   ISO='unknown',\n                   Province='unknown')\nrecovered.fillna(fill_values, downcast=True, inplace=True)\n\ndtype = dict(Province=\"object\",\n             Country=\"object\",\n             Lat=\"float\",\n             Long='float',\n             Date='datetime64',\n             Recovered='int', \n             ISO='object',\n             Region_Code='int',\n             Sub_Region_Code='int',\n             Intermediate_Region_Code='int')\nrecovered = recovered.astype(dtype)","2d497bb2":"assert recovered.isna().sum().sum() == 0\nprint('AFTER CLEANING:')\nrecovered.info()","951768cd":"recovered.head()","b66338aa":"assert confirmed.shape == deaths.shape and confirmed.shape >= recovered.shape\nprint('confirmed dataset shape:', confirmed.shape)\nprint('deaths dataset shape:', deaths.shape)\nprint('recovered dataset shape:', recovered.shape)","ed5ad5ad":"on = ['Province', 'Country', 'Lat', 'Long', 'Date', 'ISO', \n      'Region_Code', 'Sub_Region_Code', 'Intermediate_Region_Code']\ncovid19 = pd.merge(confirmed, deaths, on=on, how='inner', validate='1:1')\ncovid19 = pd.merge(covid19, recovered, on=on, how='left', validate='1:1')\ncovid19['Recovered'].fillna(0, downcast='int', inplace=True)\n\ncovid19.head()","61cc93f4":"assert covid19.isna().sum().sum() == 0\nprint('THREE SETS MERGED:')\ncovid19.info()","882bfbf8":"LOAD_DIR = \"preprocessed\"\nFILE_NAME = 'covid19.csv'\nPATH = os.path.join(LOAD_DIR, FILE_NAME)\n\n\nif UPDATE:\n    if not os.path.exists(LOAD_DIR):\n        os.mkdir(LOAD_DIR) \n    covid19.to_csv(PATH, index=False)","22378e59":"# ignore regions and aggregate by country\nvalues = ['Confirmed', 'Deaths', 'Recovered', 'Lat', 'Long']\naggfunc=dict(Confirmed='sum',\n             Deaths='sum',\n             Recovered='sum',\n             Lat='last',  # select most infected\n             Long='last') # select most infected\n# to get lat and long of most infected country regions \n\ncovid19_sorted_confirmed = covid19.sort_values('Recovered') \n\n# this made equal number of records for each country within time range\ncovid19_agg = covid19_sorted_confirmed.pivot_table(values=values, \n                                                   index='Country', \n                                                   columns='Date', \n                                                   aggfunc=aggfunc).stack().reset_index()\n\ncovid19_agg_sorted = covid19_agg.sort_values([\"Country\", \"Date\"])\n\n\n# extract new data\ndef max_num_or_zero(x):\n    return np.max(np.c_[x, np.zeros(x.shape)], axis=1)\n\ndef growth(x):\n    increase = x.values[1:] - x.values[:-1]\n    only_nonnegative = max_num_or_zero(increase)\n    return np.r_[0, only_nonnegative]\n\n# for plotly's plots\ncovid19_agg_sorted['Date_animation'] = covid19_agg_sorted[\"Date\"].astype('str')\n# extract growth from cumulative data\ncovid19_agg_sorted['ConfirmedDelta'] = covid19_agg_sorted.groupby(['Country'])[\"Confirmed\"].transform(growth)\ncovid19_agg_sorted['RecoveredDelta'] = covid19_agg_sorted.groupby(['Country'])[\"Recovered\"].transform(growth)\ncovid19_agg_sorted['DeathsDelta'] = covid19_agg_sorted.groupby(['Country'])[\"Deaths\"].transform(growth)\n\n# select important rows for future research\ncovid19_final = covid19_agg_sorted[['Country', 'Lat', 'Long', \n                                    'Confirmed', 'ConfirmedDelta', \n                                    'Deaths', 'DeathsDelta', \n                                    'Recovered', 'RecoveredDelta', \n                                    'Date', 'Date_animation']].copy()\n\n\n# check whether aggregation was correct\nOK = True\n\nn_records = covid19_final.shape[0]\nn_unique_dates = pd.unique(covid19_final[\"Date\"]).size\nn_unique_countries = pd.unique(covid19_final[\"Country\"]).size\n\ntry:\n    assert n_records == n_unique_countries * n_unique_dates, \"aggregation issue\"\nexcept AssertionError as e:\n    print(e)\n    print('records:', n_records)\n    print('must be: ', n_unique_countries * n_unique_dates,)\n    OK = False\nelse:\n    print('records:', n_records)\n    print('countries:', n_unique_countries)\n    \n\n# date of first records within countries\nf = covid19_final.groupby('Country')['Date'].min().unique()\n# date of last records within countries\nt = covid19_final.groupby('Country')['Date'].max().unique()\n# period length\nc = covid19_final.groupby('Country')['Date'].count().unique()\n\ntry:\n    assert len(f) == 1 and len(t) == 1 and c == (t[0] - f[0]) \/ np.timedelta64(1, 'D') + 1, \"aggregation issue\"\nexcept AssertionError as e:\n    print(e)\n    print('unique min dates:', f)\n    print('unique max dates:', t)\n    print('period length:', c)\n    OK = False\nelse:\n    print('period length:', c[0])\n    print('start', np.datetime64(f[0], 'D'))\n    print('end:', np.datetime64(t[0], 'D'))\n\n\nif not OK:\n    exit()\n    \nprint()\ncovid19_final.info()\nprint()\nprint(\"OK\" if OK else \"ERROR\")","4e1741b5":"covid19_final.head()","ff45b9a9":"covid = covid19_final.copy()","7a8de3f3":"# declare useful functionality\n\ncumsum_cols = ['Confirmed', 'Deaths', 'Recovered']\ndelta_cols = ['ConfirmedDelta', 'DeathsDelta', 'RecoveredDelta']\npretty_print = {\n    'Confirmed': 'Total Confirmed',\n    'Deaths': 'Total Deaths',\n    'Recovered': 'Total Recovered',\n    'ConfirmedDelta': 'New Confirmed',\n    'DeathsDelta': 'New Deaths',\n    'RecoveredDelta': 'New Recovered'}\nrolling_kw = dict(window=7,\n                  win_type='gaussian',\n                  center=True,\n                  min_periods=1)\nstd = 1\n    \n\ndef get_countries(frame):\n    \"\"\"Return a list of (unique) countries in 'frame'\"\"\"\n    return frame['Country'].unique()\n\n\n\ndef get_countries_atleast(frame, atleast=10000, col='Confirmed'):\n    \"\"\"Return list of countries that have at least 'atleast' number of confirmed cases\"\"\"\n    lr = last_records(frame)\n    return lr.loc[lr[col] >= atleast, 'Country'].values\n\n\n\ndef omit_not_important_countries(frame, n_important=5, col='Confirmed'):\n    n_countries = len(get_countries(frame))\n    cols = delta_cols + cumsum_cols + [\"Country\", 'Date']\n    frame_important = countries_top(frame, \n                                    n_important, \n                                    col=col)[cols]\n    frame_unimportant = countries_top(frame, \n                                      n_countries-n_important, \n                                      col=col, \n                                      top_is_largest=False)[cols]\n    frame_unimportant = frame_unimportant.groupby('Date')[cumsum_cols+delta_cols].sum().reset_index()\n    frame_unimportant['Country'] = 'Others'\n    return pd.concat([frame_important, frame_unimportant], sort=True)\n    \n    \n    \ndef describe_country(frame, country, cols=delta_cols):\n    \"\"\"Return a frame of the growth statistics of a given country\"\"\"\n    frame = frame.query(f\"Country == '{country}'\")\n    describe = frame.describe()\n    return describe[cols]\n\n\n\ndef last_records(frame, return_date=False):\n    \"\"\"Return only last records ia a frame\"\"\"\n    date = frame[\"Date\"]\n    last_date = max(date)\n    if return_date:\n        return frame[date == last_date], last_date\n    return frame[date == last_date]\n\n\n\ndef countries_top(frame, n=5, col='Confirmed', top_is_largest=True):\n    \"\"\"Return all of the records of countries that are top infected\"\"\"\n    if n == -1:\n        n = len(get_countries(frame))\n    lr = last_records(frame)\n    lr_srt = lr.sort_values(col)\n    if top_is_largest:\n        countries_top = lr_srt[-n:]['Country']\n    else:\n        countries_top = lr_srt[:n]['Country']\n    return frame.query(\"Country in @countries_top\")\n\n\n\ndef world_wide(frame):\n    \"\"\"Aggregate statistics across countries by date\"\"\"\n    cols = delta_cols + cumsum_cols\n    return frame.groupby('Date')[cols].sum().reset_index()\n\n    \n    \ndef plot_growth(frame, country=None, rolling=True):\n    \"\"\"\n    Plot two figures. Left one is time vs total cases.\n    Right one is total vs growth. There are two options:\n    1) supply the whole dataframe and pass a country to plot statistics about\n    2) supply global records (e.g. frame provided by world_wide function) and omit country\n    Return figure with two axes\n    \"\"\"\n    def plot_time_vs_total(frame, rolling=True, ax=None):\n        ax = ax or plt.gca()\n           \n        x = frame['Date']\n        ycols = cumsum_cols\n        ys = [frame[col] for col in ycols]\n        \n        for y, label in zip(ys, ycols):\n            if rolling:\n                y = y.rolling(3, win_type='gaussian', center=True).mean(std=1).dropna()\n            sns.lineplot(x=x, y=y, label=label, ax=ax)\n   \n        ax.set_ylim(0)\n        ax.set_xlabel('')\n        ax.set_ylabel('Total number of cases')\n        ax.tick_params(axis='x', labelrotation=-30) \n    \n    def plot_total_vs_growth(frame, rolling=True, ax=None):\n        ax = ax or plt.gca()\n        \n        frame = frame.set_index('Date')[cumsum_cols+delta_cols]\n        frame = frame.resample('7D', label='right').aggregate({'Confirmed': 'last',\n                                                               'Deaths': 'last',\n                                                               'Recovered': 'last',\n                                                               'ConfirmedDelta': 'sum',\n                                                               'RecoveredDelta': 'sum',\n                                                               'DeathsDelta': 'sum'})\n        frame = frame[:-1]\n        \n        xcols = cumsum_cols\n        ycols = delta_cols\n        xs = [frame[col] for col in xcols]\n        ys = [frame[col] for col in ycols]\n\n        for x, y, label in zip(xs, ys, xcols):\n#             if rolling:\n#                 y = y.rolling(**rolling_kw).mean(std=std)\n#                 x = x.rolling(**rolling_kw).mean(std=std)\n            sns.lineplot(x=x+1, y=y+1, label=label, ax=ax)\n                   \n        ax.set_xscale('log')\n        ax.set_yscale('log')\n        m = max(ax.get_ylim()[1], ax.get_xlim()[1])\n        l = min(ax.get_ylim()[0], ax.get_xlim()[0])\n        ax.set_xlim(l, m)\n        ax.set_ylim(l, m)\n        ax.set_xlabel('Total number of cases')\n        ax.set_ylabel('Number of new cases')\n        ax.set_aspect('equal', adjustable='box')\n        \n    \n    fig, [axl, axr] = plt.subplots(1, 2, \n                                   figsize=(18, 8))\n    if country is not None:\n        fig.suptitle(country, x=0.51, y=0.97, color='0.1')\n        frame = frame.query(f\"Country == '{country}'\")\n    plot_time_vs_total(frame, rolling, axl)\n    plot_total_vs_growth(frame, rolling, axr)\n    return fig\n\n\n\ndef plot_growth_country_wise(frame, thumb_frac=0.04):\n    \"\"\"\n    Plot three figures total vs growth (figures related to Confirmed, Deaths and Recovered)\n    Return a list containing 3 figures with 1 axes\n    \"\"\"\n    figs = []\n    for colx, coly in zip(cumsum_cols, delta_cols):\n        fig, ax = plt.subplots(figsize=(16, 16))\n        figs.append(fig)\n        \n        lr = last_records(frame)\n        X_last = lr[[colx, coly]].values\n        X_last_log = np.log(X_last + 1)\n        \n        min_dist_2 = (thumb_frac * max(X_last_log.max(0) - X_last_log.min(0)))**2\n        shown_images = np.array([[0, 0]])\n\n        for country in get_countries(frame):\n            country_data = frame.loc[frame['Country'] == country, [colx, coly]]\n            \n            X = (country_data.rolling(7, center=True).mean().dropna() + 1).values\n            last_X = X[-1]\n            last_Xlog = np.log(last_X + 1)\n            dist = np.sum((last_Xlog - shown_images)**2, 1)\n        \n            if np.min(dist) >= min_dist_2:\n                shown_images = np.vstack([shown_images, last_Xlog])\n                ax.text(last_X[[0]], last_X[[1]], country, fontsize=10)\n            ax.plot(X[:, 0], X[:, 1], color='black', alpha=0.3, linewidth=0.5)                \n            ax.scatter(last_X[[0]], last_X[[1]], color='red', alpha=0.3)\n\n        ax.set_xlabel(pretty_print[colx], fontsize=18)\n        ax.set_ylabel(pretty_print[coly], fontsize=18)\n        ax.set_aspect('equal')\n        ax.set_xscale(\"log\")\n        ax.set_yscale(\"log\")\n        ax.set_xlim(1)\n        ax.set_ylim(1)\n    return figs\n\n\n\ndef plot_pie(frame, title_date=None, n_countries=None, order='Confirmed'):\n    \"\"\"\n    Plot three pie charts to show percentage of Confirmed, Deaths and \n    Recovered cases across countries (percentage relative to a global situation). \n    n_countries specifies number of most infected countries to show on a pie. \n    Countries that are not in top will be aggregated in 'Others' piece. \n    \"\"\"\n    countries = last_records(frame).sort_values(order, ascending=False)['Country']\n    colors = cycle(px.colors.qualitative.Plotly)\n    color_map = {}\n    for country in countries:\n        color_map.update({country: next(colors)})\n    color_map.update({'Others': '#d9d9d9'})\n    \n    for col in cumsum_cols:\n        frame = last_records(frame)\n        if n_countries is not None:\n            frame = omit_not_important_countries(frame, n_important=n_countries, col=col)\n        \n        fig = px.pie(frame,  \n                     values=col, \n                     names='Country', \n                     color='Country',\n                     color_discrete_map=color_map,\n                     hole=.3)\n        fig.update_traces(textposition='inside', textinfo='percent+label')\n        fig.update_layout(annotations=[dict(text=col,\n                                            x=0.5, \n                                            y=0.5,\n                                            font_size=18,\n                                            showarrow=False)],\n                          margin = dict(t=50, l=10, r=10, b=10))\n        fig.update_layout(title={\n            'text': title_date.strftime('%d %B %Y'),\n            'y':0.96,\n            'x':0.42,\n            'xanchor': 'center',\n            'yanchor': 'top'})\n        fig.show()\n#       fig.write_image(f\"{col}.png\")\n\n\n\ndef plot_bar(frame, n_countries=5, title_date=None, include_others=False):\n    \"\"\"\n    Plot bars for top n_countries infected countries.\n    For each country there are 3 bars relative to Confirmed, Deaths and Recovered.\n    \"\"\"\n    frame = last_records(frame)\n    if include_others:\n        frame = omit_not_important_countries(frame, n_important=n_countries)\n    else:\n        frame = countries_top(frame, n_countries)    \n    frame = frame.sort_values(['Confirmed'], ascending=False)\n    fig = go.Figure(data=[\n        go.Bar(name='Confirmed', x=frame['Country'], y=frame['Confirmed']),\n        go.Bar(name='Deaths', x=frame['Country'], y=frame['Deaths']),\n        go.Bar(name='Recovered', x=frame['Country'], y=frame['Recovered'])\n    ])\n\n    fig.update_layout(\n        template='seaborn',\n        yaxis_title=\"Number of people\", \n        width=800, \n        height=500)\n    \n    if title_date:\n         fig.update_layout(title={\n             'text': title_date.strftime('%d %B %Y'),\n             'y':0.88,\n             'x':0.5,\n             'xanchor': 'center',\n             'yanchor': 'top'})\n    fig.show()\n    \n\ndef plot_choropleth(frame, animation=False):\n    if not animation:\n        frame = last_records(frame)\n        \n    fig = px.choropleth(frame,\n                        locations=\"Country\",\n                        locationmode='country names',\n                        color=\"Confirmed\",\n                        color_continuous_scale=\"Sunsetdark\", \n                        projection=\"natural earth\", \n                        animation_frame=\"Date_animation\" if animation else None,\n                        width=800,\n                        height=600)\n    fig.update(layout_coloraxis_showscale=False)\n    \n    text = \"COVID-19 Growth Animation\" if animation else actual_date.strftime('%d %B %Y') \n    fig.update_layout(title={\n                     'text': text,\n                     'y':0.98 if animation else 0.9,\n                     'x':0.5,\n                     'xanchor': 'center',\n                     'yanchor': 'top'},\n                      margin=dict(t=0, l=0, r=0, b=0))\n    fig.show()\n\n    \ndef plot_scatter_geo(frame, animation=False):\n    if not animation:\n        frame = last_records(frame)\n    fig = px.scatter_geo(frame, \n                         lat=\"Lat\", \n                         lon='Long',\n                         size=np.sqrt(frame['Confirmed']),\n                         hover_name=\"Country\",\n                         hover_data=[\"Confirmed\"],\n                         animation_frame=\"Date_animation\" if animation else None,\n                         projection=\"natural earth\",\n                         width=800,\n                         height=600)\n    \n    text = \"COVID-19 Growth Animation\" if animation else actual_date.strftime('%d %B %Y') \n    fig.update_layout(title={\n                     'text': text,\n                     'y':0.98 if animation else 0.9,\n                     'x':0.5,\n                     'xanchor': 'center',\n                     'yanchor': 'top'},\n                      margin=dict(t=10, l=0, r=0, b=0))\n    fig.show()\n    \n    \ndef plot_growth_rate(frame):\n    \"\"\"frame: expect global data\"\"\"\n    frame = frame.set_index('Date')[delta_cols]\n    frame = frame.resample('7D', label='right').sum()\n    frame = frame[:-1]\n    frame = frame.pct_change(1).dropna()\n    \n    ax = frame.plot(figsize=(16, 10))\n    \n    ax.set_xlim(frame.index.min())\n    ticks_format = mpl.ticker.PercentFormatter(xmax=1)\n    ax.yaxis.set_major_formatter(ticks_format)\n    ax.set_xlabel('')\n    ax.set_ylabel('Weekly Growth Rate (Compared to previous week)')\n    ax.legend()\n    \n\ndef plot_global_bar(frame, title_date=None):\n    \"\"\"frame: expect summarize data\"\"\"\n    fig = px.bar(x=frame, y=frame.index, orientation='h')\n    fig.update_layout(\n        template='seaborn',\n        yaxis_title=\"\", \n        xaxis_title=\"Total number of cases\",\n        title={\n         'text': title_date.strftime('%d %B %Y'),\n         'x':0.5,\n         'xanchor': 'center',\n         'yanchor': 'top'})\n    fig.show()\n    \n    \ndef plot_ts_country_wise(frame):      \n    for col in cumsum_cols:\n        fig = px.line(frame, x=\"Date\", y=col, line_group='Country')\n        fig.update_layout(margin=dict(t=0, l=0, r=0, b=0))\n        fig.show()\n        \n\ndef plot_confirmed_vs_deaths(frame, title_date=None):\n    \"\"\"frame: expect actual information\"\"\"\n    fig = px.scatter(frame, \n                     x=\"Confirmed\",\n                     y=\"Deaths\", \n                     hover_name='Country',\n                     log_x=True,\n                     log_y=True)\n    fig.update_layout(title={\n        'text': title_date.strftime('%d %B %Y'),\n        'y':0.96,\n        'x':0.5,\n        'xanchor': 'center',\n        'yanchor': 'top'})\n    fig.show()\n   \n\nrc = {\n    'grid.color': '.8',\n\n    'axes.grid': True,\n    'axes.edgecolor': '.9',\n    'axes.titlesize': 22,\n    'axes.labelsize': 20,\n    'axes.labelcolor': '0.1',\n\n    'figure.titlesize': 22,\n\n    'legend.fontsize': 16,\n\n    'lines.linewidth': 3,\n    'lines.markersize': 10,\n \n    'xtick.direction': 'in',\n    'xtick.labelsize': 16,\n    'xtick.color': '0.1',\n    'xtick.major.size': 5,\n    'xtick.major.width': 3,\n    'xtick.minor.size': 4,\n    'xtick.minor.width': 1,\n\n    'ytick.direction': 'in',\n    'ytick.labelsize': 16,\n    'ytick.color': '0.1',\n    'ytick.major.size': 5,\n    'ytick.major.width': 3,\n    'ytick.minor.size': 4,\n    'ytick.minor.width': 1,\n}\n# plt.rcParams\n# mpl.rcParams.update(rc)","c4f4a3ae":"# define useful data patterns\ncovid_global = world_wide(covid)\ncovid_actual, actual_date = last_records(covid, return_date=True)\ncovid_top5 = countries_top(covid, 5)\ncovid_actual_top5 = countries_top(covid_actual, 5)\ncovid_summarize = covid_actual[cumsum_cols].sum().sort_values()","0c4dfcf4":"covid.describe()[delta_cols]","ef94415d":"plot_global_bar(covid_summarize, title_date=actual_date)","65431ca4":"with mpl.rc_context(rc=rc):\n    fig = plot_growth(covid_global)\n    fig.suptitle('COVID-19 Global Growth', x=0.51, y=0.97, color='0.1')","5ad6d4be":"with sns.plotting_context('talk'), sns.axes_style('darkgrid'):\n    plot_growth_rate(covid_global)","40c70c84":"plot_bar(covid, title_date=actual_date, include_others=True)","a8c24635":"plot_choropleth(covid, animation=False)","ef6aa016":"plot_pie(covid, title_date=actual_date, n_countries=10)","8ba53e2c":"plot_ts_country_wise(covid)","58c6a2fc":"with sns.axes_style('whitegrid'):\n    plot_growth_country_wise(covid)","24fb3533":"plot_confirmed_vs_deaths(covid_actual, title_date=actual_date)","7411c050":"plot_scatter_geo(covid, animation=True)","69d002e3":"# <a name=\"id2\"><\/a>**Extract and modify data**","345f18d5":"**Clean confirmed dataset**","d8438490":"# <a name=\"id1\"><\/a>**Download data**","7fcfa60b":"* [Download data](#id1)  \n* [Prepare data](#id4)  \n* [Extract and modify data](#id2)  \n* [Prepare functionality](#id3)  \n* [Explore and visualize data](#id5)","500eadc0":"**Clean recovered dataset**","8153d08e":"**Clean deaths dataset**","08b613c7":"# <a name=\"id4\"><\/a>Prepare data","1f33a92e":"**Load data**","586d4001":"# <a name=\"id5\"><\/a> **Explore and visualize data**","4fb22290":"**Merge datasets**","4ee6093b":"# <a name=\"id3\"><\/a>**Prepare functionality**"}}