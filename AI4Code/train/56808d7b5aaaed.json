{"cell_type":{"f14465f7":"code","b5b1e689":"code","3249f23d":"code","cfa4df4c":"code","e6ab25c2":"code","95222b89":"code","f9522a93":"code","e2a8a572":"code","80d5ff65":"code","264ca838":"code","d0ebc1aa":"code","39ed8705":"code","9db9e311":"code","d575ab16":"code","bec77035":"code","88dde170":"code","cd326fb3":"code","3a02ed15":"code","1fc20b38":"code","57168ebf":"code","8c9d94bc":"code","7c96dc0d":"code","9f93012d":"markdown","b12099dc":"markdown","37de4568":"markdown","90f37aef":"markdown","72fa53ab":"markdown","f3d384be":"markdown","0a1917f2":"markdown","2e7a8e24":"markdown","3214f9ec":"markdown","befd1e81":"markdown","cad21a26":"markdown","443502e1":"markdown","b8f56841":"markdown","6219f433":"markdown","5534de3a":"markdown","4a4ca73d":"markdown","ac14eecd":"markdown","9daeb747":"markdown","8491d878":"markdown","0e712346":"markdown","aa7d4e13":"markdown","0d5ecf34":"markdown"},"source":{"f14465f7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b5b1e689":"import torch \nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport time\nimport torch.utils.data\nimport torch.optim as optim","3249f23d":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nprint(\"Device : \", device  )","cfa4df4c":"def read_images(path, num_img):\n    array = np.zeros([num_img, 64*32])\n    i = 0\n    for img in os.listdir(path):\n        img_path = path + \"\/\" + img\n        img = Image.open(img_path, mode = \"r\")\n        data = np.asarray(img, dtype = \"uint8\")\n        data = data.flatten()\n        array[i,:] = data\n        i += 1\n    return array","e6ab25c2":"test_path = \"\/kaggle\/input\/lsi-far-infrared-pedestrian-dataset\/LSIFIR\/Classification\/Test\"\ntrain_path = \"\/kaggle\/input\/lsi-far-infrared-pedestrian-dataset\/LSIFIR\/Classification\/Train\"\n\ntrain_negative_path = train_path + \"\/neg\"\nnum_train_negative_img = 43390\ntrain_positive_path = train_path + \"\/pos\"\nnum_train_positive_img = 10208\n\ntest_negative_path = test_path + \"\/neg\"\nnum_test_negative_img = 22050\ntest_positive_path = test_path + \"\/pos\"\nnum_test_positive_img = 5944\n","95222b89":"train_negative_array = read_images(train_negative_path, num_train_negative_img) \nx_train_negative_tensor = torch.from_numpy(train_negative_array)\nprint(\"x_train_negative_tensor:\", x_train_negative_tensor.size())\ny_train_negative_tensor = torch.zeros(num_train_negative_img, dtype = torch.long)\nprint(\"y_train_negatice_tensor:\", y_train_negative_tensor.size())\n","f9522a93":"train_positive_array = read_images(train_positive_path, num_train_positive_img) \nx_train_positive_tensor = torch.from_numpy(train_positive_array)\nprint(\"x_train_positive_tensor:\", x_train_positive_tensor.size())\ny_train_positive_tensor = torch.ones(num_train_positive_img, dtype = torch.long)\nprint(\"y_train_positive_tensor:\", y_train_positive_tensor.size())\n\n","e2a8a572":"x_train = torch.cat((x_train_negative_tensor,x_train_positive_tensor),0)\ny_train = torch.cat((y_train_negative_tensor,y_train_positive_tensor),0)\nprint(\"x_train: \",x_train.size())\nprint(\"y_train: \",y_train.size())","80d5ff65":"test_negative_array = read_images(test_negative_path,num_test_negative_img)\nx_test_negative_tensor = torch.from_numpy(test_negative_array[:20855,:])\nprint(\"x_test_negative_tensor: \",x_test_negative_tensor.size())\ny_test_negative_tensor = torch.zeros(20855,dtype = torch.long)\nprint(\"y_test_negative_tensor: \",y_test_negative_tensor.size())\n","264ca838":"test_positive_array = read_images(test_positive_path,num_test_positive_img)\nx_test_positive_tensor = torch.from_numpy(test_positive_array)\nprint(\"x_test_positive_tensor: \",x_test_positive_tensor.size())\ny_test_positive_tensor = torch.zeros(num_test_positive_img,dtype = torch.long)\nprint(\"y_test_positive_tensor: \",y_test_positive_tensor.size())\n","d0ebc1aa":"x_test = torch.cat((x_test_negative_tensor, x_test_positive_tensor), 0)\ny_test = torch.cat((y_test_negative_tensor, y_test_positive_tensor), 0)\nprint(\"x_test: \",x_test.size())\nprint(\"y_test: \",y_test.size())","39ed8705":"plt.imshow(x_train[43876,:].reshape(64,32),cmap = \"gray\")\nplt.axis(\"off\")\nplt.legend()\nplt.show()","9db9e311":"num_epochs = 1000\nnum_classes = 2\nbatch_size = 8933\nlearning_rate = 0.00001","d575ab16":"\n class Net(nn.Module):\n    \n    def __init__(self):\n        super(Net,self).__init__()\n        #The layers which are used in model\n\n        self.conv1 = nn.Conv2d(1,10,5)\n        self.pool = nn.MaxPool2d(2,2)\n        self.conv2 = nn.Conv2d(10,16,5)\n        \n        self.fc1 = nn.Linear(16*13*5,520)\n        self.fc2 = nn.Linear(520,130)\n        self.fc3 = nn.Linear(130,num_classes)\n\n    def forward(self, x):\n        # Firstly, the input process with conv1. \n        # Then relu activation function.\n        # Finally, the output of activation layer procces with maxpooling, pool1.\n        x = self.pool(F.relu((self.conv1(x))))\n        \n        # After, first convolutional block,the output of it process with conv2 layer.\n        # Then, It process with activaliton layer, relu. \n        # Finally, It process with maxpooling, pool1. \n        x = self.pool(F.relu(self.conv2(x)))\n        \n        #Flatten\n        x = x.view(-1,16*13*5)\n        \n        #Fully Connected Layers\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x","bec77035":"train = torch.utils.data.TensorDataset(x_train, y_train)\n","88dde170":"trainloader = torch.utils.data.DataLoader(train, batch_size = batch_size, shuffle = True )","cd326fb3":"test = torch.utils.data.TensorDataset(x_test, y_test)","3a02ed15":"testloader = torch.utils.data.DataLoader(test, batch_size = batch_size, shuffle = False )\n","1fc20b38":"net = Net().to(device)\n","57168ebf":"criterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(net.parameters(),lr = learning_rate,momentum = 0.8)","8c9d94bc":"start = time.time()\n\ntrain_acc = []\ntest_acc = []\nloss_list = []\nuse_gpu = True\n\nfor epoch in range(num_epochs):\n    for i, data in enumerate(trainloader, 0):\n        \n        inputs, labels = data\n        inputs = inputs.view(batch_size, 1, 64, 32) # reshape\n        inputs = inputs.float() # float\n        \n        # use gpu\n        if use_gpu:\n            if torch.cuda.is_available():\n                inputs, labels = inputs.to(device), labels.to(device)\n                \n        # zero gradient\n        optimizer.zero_grad()\n        \n        # forward\n        outputs = net(inputs)\n        \n        # loss\n        loss = criterion(outputs, labels)\n        \n        # back\n        loss.backward()\n        \n        # update weights\n        optimizer.step()\n    \n    # test\n    print(\"Epoch Number : \", epoch)\n    correct = 0\n    total = 0\n    with torch.no_grad():\n        for data in testloader:\n            images, labels= data\n            \n            images = images.view(batch_size,1,64,32)\n            images = images.float()\n            \n            # gpu\n            if use_gpu:\n                if torch.cuda.is_available():\n                    images, labels = images.to(device), labels.to(device)\n            \n            outputs = net(images)\n            \n            _, predicted = torch.max(outputs.data,1)\n            \n            total += labels.size(0)\n            correct += (predicted == labels).sum().item()\n        \n    acc1 = 100*correct\/total\n    print(\"accuracy test: \",acc1)\n    test_acc.append(acc1)\n\n    # train\n    correct = 0\n    total = 0\n    with torch.no_grad():\n        for data in trainloader:\n            images, labels= data\n            \n            images = images.view(batch_size,1,64,32)\n            images = images.float()\n            \n            # gpu\n            if use_gpu:\n                if torch.cuda.is_available():\n                    images, labels = images.to(device), labels.to(device)\n            \n            outputs = net(images)\n            \n            _, predicted = torch.max(outputs.data,1)\n            \n            total += labels.size(0)\n            correct += (predicted == labels).sum().item()\n        \n    acc2 = 100*correct\/total\n    print(\"accuracy train: \",acc2)\n    train_acc.append(acc2)\n\n    \nprint(\"**************\")\nprint(\"Train Is Done\")\nprint(\"**************\")\nend = time.time()\ntotal_time = (end-start)\/60\nprint(\"Process Time : \",total_time)","7c96dc0d":"fig, ax1 = plt.subplots()\n\nplt.plot(loss_list,label = \"Loss\",color = \"black\")\n\nax2 = ax1.twinx()\n\nax2.plot(np.array(test_acc)\/100,label = \"Test Acc\",color=\"green\")\nax2.plot(np.array(train_acc)\/100,label = \"Train Acc\",color= \"red\")\nax1.legend()\nax2.legend()\nax1.set_xlabel('Epoch')\nfig.tight_layout()\nplt.title(\"Loss vs Test Accuracy\")\nplt.show()","9f93012d":"**Needed Libraries**","b12099dc":"**Initialize Model**","37de4568":"# Implementing CNN Model","90f37aef":"**Concat x_train and y_train Data**","72fa53ab":"**Concat x_test and y_test Data**","f3d384be":"**Train Our Network**","0a1917f2":"**Arranging Train Data for Needed Format to Process**","2e7a8e24":"**Read Train Negative**","3214f9ec":"**Concat Test**","befd1e81":"**Read Test Positive**","cad21a26":"**Defining Hyperparameters** ","443502e1":"**Concat Train**","b8f56841":"**Initializing Our Model, MyNet**","6219f433":"# Visualize Data","5534de3a":"**Read Test Negative**","4a4ca73d":"**Device Configuration to Use GPU**\n\n> Note : This codes can be used to check that your computer use its CPU or GPU.","ac14eecd":"**Initializing Loss and Optimizer**","9daeb747":"**Read Train Positive**","8491d878":"# Visualization of Results","0e712346":"**Arranging Train Data for Needed Format to Process**","aa7d4e13":"# Preparing Tests and Trains Data to Process them with Model","0d5ecf34":"# Compiling and Fitting Our CNN Model"}}