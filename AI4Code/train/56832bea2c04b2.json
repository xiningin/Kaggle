{"cell_type":{"0fddd301":"code","fd671519":"code","885aa846":"code","5998f23c":"code","d15bd673":"code","9026cbfc":"code","fa7cb349":"code","bf185373":"code","8aea99e7":"code","18c28d75":"code","b690e0e8":"code","d1247e27":"code","fcfd5434":"code","2a5a6b84":"code","9c6bee88":"code","85b90de8":"code","81dd262a":"code","1991f78e":"code","6ae48d4f":"code","123c082a":"markdown","27ad7dc4":"markdown","db90f1c3":"markdown","c81e2b98":"markdown","610c7bca":"markdown","ba23e2d0":"markdown","e0cb31e8":"markdown","2407dcb2":"markdown","30628de8":"markdown","ed5b8f0f":"markdown","5e1ffb08":"markdown","671af3e5":"markdown"},"source":{"0fddd301":"# Import everything\nimport tensorflow as tf\nfrom skimage.transform import warp, AffineTransform\nimport matplotlib.pyplot as plt\nfrom ipywidgets import interact, interactive, IntSlider, ToggleButtons\n!pip install mrcfile\nimport mrcfile\nimport numpy as np\n","fd671519":"# Helper funtions\ndef interactVol(vol, title, axis = 2):\n  if axis == 0:\n    vol = np.transpose(vol, [1,2,0])\n  def explore_3d(layer):\n      plt.figure(figsize=(10,5))\n      channel = 1\n      plt.imshow(vol[:,:,layer], cmap = 'gray')\n      plt.title(title, fontsize = 10)\n      plt.axis(False)\n  interact(explore_3d, layer=(0, vol.shape[2]-1))\n\ndef resizeVol(vol, resize_shape):\n  resized = np.zeros(resize_shape)\n  for i in range(vol.shape[2]):\n    resized[:,:,i] = tf.image.resize(vol[:,:,i], resize_shape[:2]),\n  return resized\n\ndef get_RandomAffine(img_shape, rotation = 0.01, translate = (0.01,0.01), shear = 0.01, scale = (1.02, 1.02)):\n  rotation = (np.random.uniform()*2-1)*rotation\n  translate = ((np.random.uniform()*2-1)*translate[0]*img_shape[1], (np.random.uniform()*2-1)*translate[1]*img_shape[0])\n  shear = (np.random.uniform()*2-1)*shear\n  scale = ((np.random.uniform()*2-1)*(scale[0]-1) + 1, (np.random.uniform()*2-1)*(scale[0]-1) + 1)\n  tform = AffineTransform(scale = scale, translation = translate, shear = shear, rotation = rotation)\n  return tform\n\ndef getWarpedTiltSeries(tilt_series, sequence_axis = 2, scaled_tform = None):\n  if sequence_axis == 2:\n\n    mis_aligned = np.zeros((tilt_series.shape[0],tilt_series.shape[1],1))\n  else:\n    mis_aligned = np.zeros((1,)+(tilt_series.shape[1],tilt_series.shape[2]))\n  tform_array = np.zeros((6, tilt_series.shape[2]))\n  for i in range(tilt_series.shape[sequence_axis]):\n    temp_image = np.take(tilt_series, i, axis=sequence_axis)\n    temp_tform = get_RandomAffine(img_shape = temp_image.shape)\n    temp_tform = temp_tform.params\n    if scaled_tform != None:\n      temp_tform[0,0] = temp_tform[0,0] - 1\n      temp_tform[1,1] = temp_tform[1,1] - 1\n      temp_tform[0,2] = temp_tform[0,2]\/0.02\/tilt_series.shape[0]\n      temp_tform[1,2] = temp_tform[1,2]\/0.02\/tilt_series.shape[0]\n    temp_warped = warp(temp_image, temp_tform)\n    temp_warped = np.expand_dims(temp_warped, sequence_axis)\n    mis_aligned = np.concatenate([mis_aligned, temp_warped], axis=sequence_axis)\n    tform_array[:,i] = np.reshape(temp_tform[:2,:], (6,))\n  return np.take(mis_aligned, indices=range(1, mis_aligned.shape[sequence_axis]), axis=sequence_axis), tform_array\n\ndef warpback(mis_aligned, tform_array):\n  warp_back = np.zeros(mis_aligned.shape)\n  for i in range(mis_aligned.shape[2]):\n      warp_back[:,:,i] = warp(mis_aligned[:,:,i], np.linalg.inv(tform_array[:,:,i]))\n  return warp_back\n\ndef custom_mae(y_true, y_pred):\n  mae = tf.math.reduce_mean(tf.math.abs(y_true[:2,:,:] - y_pred[:2,:,:]))\n  return mae\ndef addback001(tform, shape):\n  full_tform = np.zeros((3,3))\n  full_tform[:2,:] = tform\n  full_tform[2,:] = [0, 0, 1]\n  return full_tform\n\ndef plot_col(data, axis, num, title):\n    indices = np.floor(np.linspace(0, data.shape[axis]-1, num))\n    plt.figure(figsize=(20,7))\n    for i in range(num):\n        plt.subplot(1,num,i+1)\n        plt.imshow(np.take(data, indices[i], axis=axis), cmap='gray')\n        plt.title(f'{title} {int(indices[i]+1)}\/{data.shape[axis]}')\n        plt.axis(False)\n","885aa846":"!wget \"https:\/\/github.com\/XiaoleiChu\/Titl-seris-Augmentation\/raw\/main\/brain_mri_proj_128.mrc\"\n\nwith mrcfile.open(\"brain_mri_proj_128.mrc\") as projmrc:\n  proj_volume = projmrc.data\nprojmrc.close()\nproj_volume = np.array(proj_volume)","5998f23c":"# Recommend to use interactive visualization\n# interactVol(proj_volume, axis = 2, title=\"Brain MRI scanning projection stack\")\n\nplot_col(proj_volume, 2, 6, \"projection\" )","d15bd673":"# Split training and test sets\ntrain_proj = proj_volume[:,:,:-20]\ntest_proj = proj_volume[:,:,-20:]\ntrain_proj.shape, test_proj.shape","9026cbfc":"# Normalize and transpose the data\nMAX_INTENSITY = np.max(proj_volume)\ntrain_proj = np.transpose(train_proj, [2,0,1]) \/ MAX_INTENSITY\ntest_proj = np.transpose(test_proj, [2,0,1]) \/ MAX_INTENSITY","fa7cb349":"# Make sequence (X) and labels(Y) split from train tilt-series\nWINDOW_SIZE = 7\nHORIZON = 1\n\ndef make_sequence_label(vol, window_size, horizon):\n  i = 0\n  sequence_data = np.zeros((1,)+(window_size,vol.shape[1],vol.shape[2]))\n  label_data = np.zeros((1,) + (vol.shape[1],vol.shape[2]))\n\n  for _ in range(window_size, vol.shape[0]):\n    sequence = np.expand_dims(vol[i:i+WINDOW_SIZE,:,:], axis=0)\n    sequence_data = np.concatenate([sequence_data, sequence], axis=0)\n\n    label = np.expand_dims(vol[i+WINDOW_SIZE,:,:], 0)\n    label_data = np.concatenate([label_data, label], axis=0)\n    i+=1\n  return sequence_data[1:], label_data[1:]","bf185373":"train_sequence, train_label = make_sequence_label(train_proj, window_size=WINDOW_SIZE, horizon=HORIZON)\ntest_sequence, test_label = make_sequence_label(test_proj, window_size=WINDOW_SIZE, horizon=HORIZON)\ntrain_sequence.shape, train_label.shape, test_sequence.shape, test_label.shape","8aea99e7":"## Create a modified random warping function which takes sequence and label as tuples and returns warped sequence and unchanged label\ndef getWarpedTiltSeries_forTuple(tilt_series):\n  mis_aligned = np.zeros((1,)+(tilt_series.shape[1],tilt_series.shape[2]))\n  tform_array = np.zeros((6, tilt_series.shape[2]))\n  for i in range(tilt_series.shape[0]):\n    temp_image = np.take(tilt_series, i, axis=0)\n    temp_tform = get_RandomAffine(img_shape = temp_image.shape)\n    temp_tform = temp_tform.params\n    temp_warped = warp(temp_image, temp_tform)\n    temp_warped = np.expand_dims(temp_warped, 0)\n    mis_aligned = np.concatenate([mis_aligned, temp_warped], axis=0)\n  mis_aligned = np.take(mis_aligned, indices=range(1, mis_aligned.shape[0]), axis=0)\n  return mis_aligned\ndef tf_function_warping(inputs):\n  y = tf.numpy_function(getWarpedTiltSeries_forTuple,[inputs], tf.float64)\n  return y","18c28d75":"## Create performace dataset\n# train_sequence_dataset = tf.data.Dataset.from_tensor_slices(train_sequence)\n# train_sequence_dataset = train_sequence_dataset.map(tf_function_warping, num_parallel_calls=tf.data.AUTOTUNE)\n# train_label_dataset = tf.data.Dataset.from_tensor_slices(train_label)\n# train_dataset = tf.data.Dataset.zip((train_sequence_dataset, train_label_dataset))\n# train_dataset = train_dataset.batch(1).prefetch(tf.data.AUTOTUNE)\n\ntrain_sequence_dataset = tf.data.Dataset.from_tensor_slices(train_sequence)\ntrain_label_dataset = tf.data.Dataset.from_tensor_slices(train_label)\ntrain_dataset = tf.data.Dataset.zip((train_sequence_dataset, train_label_dataset))\ntrain_dataset = train_dataset.batch(1).prefetch(tf.data.AUTOTUNE)\n\ntest_sequence_dataset = tf.data.Dataset.from_tensor_slices(test_sequence)\ntest_label_dataset = tf.data.Dataset.from_tensor_slices(test_label)\ntest_dataset = tf.data.Dataset.zip((test_sequence_dataset, test_label_dataset))\ntest_dataset = test_dataset.batch(1)","b690e0e8":"train_dataset, test_dataset","d1247e27":"from tensorflow.python.keras.layers.normalization.batch_normalization import BatchNormalization\n# Model building\nimport tensorflow.keras.layers as layers\n\nmodel_0 = tf.keras.Sequential([\n                               layers.Input(shape=(7,128,128)),\n                               layers.Reshape((7,128,128,1)),\n                               layers.Bidirectional(\n                                   layers.ConvLSTM2D(filters=72,\n                                        kernel_size=(3,3),\n                                        data_format='channels_last',\n                                        return_sequences= False,\n                                        padding = 'same')),\n#                                layers.BatchNormalization(), #I'm not sure why adding this layer will freeze GD, Running on Colab is fine.\n                               tf.keras.layers.Dense(64, activation='relu'),\n                               tf.keras.layers.Dense(1, activation='relu')\n\n], name=\"model_0_ConvLSTM2D\")\nmodel_0.summary()","fcfd5434":"model_0.compile(loss = tf.keras.losses.mae,\n        optimizer = tf.keras.optimizers.Adam(),\n        metrics = tf.keras.metrics.MSE)\n\ncheckpoint_func = tf.keras.callbacks.ModelCheckpoint(\"model_3_as2_add_batchNorm\/model_0.ckpt\",\n                                                     monitor='val_loss',\n                                                     verbose=0,\n                                                     save_best_only=True,\n                                                     save_weights_only = \"True\")\n\nhistory_0 = model_0.fit(train_dataset,\n             validation_data = test_dataset,\n             epochs = 100,\n             verbose = 1,\n             callbacks=[checkpoint_func,\n                  tf.keras.callbacks.ReduceLROnPlateau(patience=20,\n                                    factor = 0.2,\n                                     monitor = \"val_loss\",\n                                     verbose = 1)])","2a5a6b84":"import pandas as pd\npd.DataFrame(history_0.history)[[\"loss\",\"val_loss\"]].plot()","9c6bee88":"# model_0.load_weights('\/content\/model_3_as2_add_batchNorm\/model_0.ckpt')\npred = model_0.predict(test_dataset)","85b90de8":"# interactVol(test_label, axis=0,title=\"Test ground truth\")\n# interactVol(tf.squeeze(pred), axis=0, title = \"Model predictions\")\nplot_col(test_label, 0, 6, \"Test label\")\nplot_col(tf.squeeze(pred), 0, 6, \"Model predictions\")\n","81dd262a":"\nlast_sequence = train_proj[-7:, :, :] #Take the last 7 sequences as the starting sequence, to predict the first proj in test set.\ndef continous_prediction(model, beginning_sequence, num_of_predictions):\n  last_sequence = beginning_sequence\n  init_shape = (1, beginning_sequence.shape[1], beginning_sequence.shape[2])\n  preds_list = np.zeros(init_shape)\n  for i in range(num_of_predictions):\n    preds = model.predict(tf.expand_dims(last_sequence, 0))\n    preds = np.reshape(tf.squeeze(preds), init_shape)\n    preds_list = np.concatenate([preds_list, preds], axis=0)\n    new_sequence = np.concatenate([last_sequence, preds], axis = 0)\n    last_sequence = new_sequence[1:]\n  return preds_list[1:]\n\n","1991f78e":"prediction_20 = continous_prediction(model_0, last_sequence, 20)","6ae48d4f":"# interactVol(prediction_20, axis = 0, title=\"Continous prediction\")\nplot_col(prediction_20, 0, 6, \"continous prediction\" )\nplot_col(test_proj, 0, 6, \"test_projection\")","123c082a":"## What about use the predction as input to predict further into later suquence","27ad7dc4":"## Visualize predicitons","db90f1c3":"## Compile and fitting model\nGPU environment suggested.","c81e2b98":"## Visualize the dataset","610c7bca":"### We see it does not work well. The prediction error accumulates as we use more predictions as inputs.","ba23e2d0":"### Split projections into train and test sets","e0cb31e8":"## Define some helper functions","2407dcb2":"Here we create the tf.dataset","30628de8":"## Model building\nNow we build a simple ConvLSTM2D model to predict the next projection from a sequence of 7 projections","ed5b8f0f":"# Titlt-Series Augmentation via ConvLSTM Neural Networks\nAuthor: Xiaolei Chu @UCDavis\n\nThis notebook takes a brain mri projection tilt series (100 projections) and splits them into a 80-projection trainning set and 20-projection test set. The goal is to build a neural net work which takes a consecutive N-projection sequence and predict the next sequence. The application could be to augment limited-angle projection stack so it may improve final 3D reconstruction resolution.\n\nThe current input\/output set up:\n* Window size = 7, horizon = 1, stride = 1","5e1ffb08":"Next we will take the training set and make inputs and labels. Here a window_size = 7 and horizon = 1 is used. ","671af3e5":"## Read in the projection file"}}