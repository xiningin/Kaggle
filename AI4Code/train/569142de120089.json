{"cell_type":{"3591a4c8":"code","041da831":"code","4915fcb1":"code","0d1cf96c":"code","376ea2be":"code","373de672":"code","961298c5":"code","6bccd25e":"code","0404ab2e":"code","8ab4a889":"code","2348245a":"code","a69b6ac4":"code","1d5d765b":"code","e9156c94":"code","b652d6cc":"code","14820f78":"code","c7c29814":"code","3088810e":"code","ac680c53":"code","fb9b08f3":"code","e4d9bc6b":"code","8bef7d3b":"code","cdf75a08":"code","2f45e6cf":"code","3a729570":"code","9109e0c5":"markdown","871d8f47":"markdown","53f64d51":"markdown","16381f5e":"markdown","043556d7":"markdown","34a9ca94":"markdown","928fc359":"markdown","e2d19521":"markdown","62a1df6b":"markdown","7398701d":"markdown"},"source":{"3591a4c8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","041da831":"from sklearn.cluster import KMeans,AgglomerativeClustering\nfrom sklearn.metrics import silhouette_score","4915fcb1":"data=pd.read_csv(\"\/kaggle\/input\/unsupervised-learning-on-country-data\/Country-data.csv\")\ndata.head()","0d1cf96c":"data.shape","376ea2be":"data.isna().sum()","373de672":"data.drop_duplicates(inplace=True)","961298c5":"fig,axs=plt.subplots(3,3,figsize=(20,13))\ncol=['child_mort', 'exports', 'health', 'imports', 'income','inflation', 'life_expec', 'total_fer', 'gdpp']\nax=axs.flatten()\nfor i,j in enumerate(col):\n    sns.boxplot(x=data[j],ax=ax[i],color='red')","6bccd25e":"sns.pairplot(data,corner=True)","0404ab2e":"plt.figure(figsize=(15,15))\nsns.heatmap(data.corr(),annot=True,square=True)","8ab4a889":"data1=data.drop('country',axis=1)","2348245a":"from sklearn.preprocessing import StandardScaler\ns=StandardScaler()\ndata1=s.fit_transform(data1);","a69b6ac4":"#Elbow plot\nfrom sklearn.cluster import KMeans\ninertia=[]\nfor i in range(1,10):\n    k=KMeans(i)\n    k.fit(data1)\n    inertia.append(k.inertia_)\nplt.plot(range(1,10),inertia,marker='o')","1d5d765b":"#From elbow plot, k=3,4 are good because of large difference errors...to decide one in these two, we go for silhouette_score\nscore=[]\nplt.figure(figsize=(10,10))\nfor i in range(2,10):\n    k=KMeans(i)\n    k.fit(data1)\n    score.append(np.round(silhouette_score(data1,k.labels_),2))\nplt.plot(range(2,10),score)","e9156c94":"#k=4 is giving high silhouette score than k=3...even though k=5 is giving high silhouette_score, the no. of clusters should not be high, so we go for k=4.\nk=KMeans(4,random_state=42)\nk.fit(data1)\ndata['k_labels']=k.labels_","b652d6cc":"from sklearn.cluster import AgglomerativeClustering","14820f78":"score=[]\nfor i in range(2,10):\n    a=AgglomerativeClustering(i)\n    a.fit(data1)\n    score.append(np.round(silhouette_score(data1,a.labels_),2))\nplt.plot(range(2,10),score)","c7c29814":"#k=2 gives good silhouette score\na=AgglomerativeClustering(2)\na.fit(data1)\ndata['hier_labels']=a.labels_","3088810e":"data.head()","ac680c53":"data.drop('hier_labels',axis=1).groupby(['k_labels','country']).mean()","fb9b08f3":"def func(x):\n    if x==0:\n        return 'Help needed priority-1' \n    elif x==1:\n        return 'Help needed priority-2'\n    elif x==2:\n        return 'Help needed priority-3'\n    else:\n        return 'No Help needed'\ndata['k_labels']=data['k_labels'].map(lambda x: func(x))","e4d9bc6b":"data.drop('k_labels',axis=1).groupby(['hier_labels','country']).mean()","8bef7d3b":"def func(x):\n    if x==0:\n        return 'Help needed'\n    else:\n        return 'No Help needed'\ndata['hier_labels']=data['hier_labels'].map(lambda x: func(x))","cdf75a08":"data.head(20)","2f45e6cf":"print('Based on K-Means clustering, the countries which need Help the most(on priority-1) are:')\ndata.loc[data['k_labels']=='Help needed priority-1']['country'].to_list()","3a729570":"print('Based on Hierarchial clustering, the countries which need Help are:')\ndata.loc[data['hier_labels']=='Help needed']['country'].to_list()","9109e0c5":"### Replacing labels with 'Help needed' or 'not'","871d8f47":"# EDA\n### Univariate Analysis","53f64d51":"### Hierarchial Clustering","16381f5e":"### Correlation","043556d7":"# Data Modelling","34a9ca94":"### K-Means","928fc359":"# Data Preparation for modelling","e2d19521":"# Data Cleaning","62a1df6b":"## Output","7398701d":"### Bivariate Analysis"}}