{"cell_type":{"20686c83":"code","4bf0e56c":"code","f365014d":"code","1f7e9c0e":"code","8b07679e":"code","856cad86":"code","fe1024d1":"code","d082ab84":"code","2d128b67":"code","dbd0e551":"code","a3b9fe50":"code","df0ef4f2":"code","d706b7ea":"code","0bc440d9":"code","02fe617b":"code","590d769f":"code","c70eba0f":"code","97e6adbf":"code","4f1f0a85":"code","6137580f":"code","b0641213":"code","f869dc4e":"code","d8956980":"markdown","96309dc6":"markdown","4669ca24":"markdown","bd846464":"markdown","86e69ec4":"markdown","17169962":"markdown","daa6d9e4":"markdown","224c9175":"markdown","5bcf62b6":"markdown","e08aae84":"markdown","06b7e72a":"markdown","54470f12":"markdown"},"source":{"20686c83":"### TODO:\n# 1. Do feature engineering on group level instead of user level\n# 2. Separate data between first person mode and free for all mode\n# 3. Eliminate cheaters and anomalies\n# 4. Develop prediction funcgion\n#    - Final ranking per match can be determined using this formula -> 100\/maxPlace, as ranking interval","4bf0e56c":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport xgboost\nfrom matplotlib import pyplot as plt","f365014d":"### Read training data\ntrain = pd.read_csv('..\/input\/train_V2.csv')","1f7e9c0e":"train.columns","8b07679e":"train.head(5)","856cad86":"from pylab import rcParams\nrcParams['figure.figsize'] = 10, 8","fe1024d1":"matchTypes = train.groupby('matchId')['matchType'].first().value_counts()","d082ab84":"matchTypes.index","2d128b67":"fig, ax = plt.subplots()\nax.bar(np.arange(len(matchTypes.index)),matchTypes.values,align='center')\nax.set_xticks(np.arange(len(matchTypes.index)))\nax.set_xticklabels(matchTypes.index,rotation=70)\nplt.title(\"Match type queue distribution\")\nplt.show()\n","dbd0e551":"### Inspect a match data\nmatchA_df = train[train.matchId == 'a10357fd1a4a91']","a3b9fe50":"### Inspect a group\nmatchA_df[matchA_df.groupId == '654c638629b8fc']","df0ef4f2":"### select groupIds in a match\nplayerGroups = matchA_df[['Id','groupId']]","d706b7ea":"### Number of players per group\nplayerCountGroup = playerGroups.groupby('groupId',as_index=False).agg({'Id':'count'}).sort_values('Id').rename(columns={\"Id\":\"players\"}).reset_index(drop=True)","0bc440d9":"playerCountGroup","02fe617b":"### Total players in this match\nprint(\"Total players: {}\".format(playerCountGroup.players.sum()))\nprint(\"Total groups: {}\".format(playerCountGroup.groupId.count()))","590d769f":"### Notice the percentage ranking\nmatchA_df[['winPlacePerc']].drop_duplicates().sort_values('winPlacePerc').reset_index(drop=True)","c70eba0f":"### The increment of winPlacePerc is retrieved using:\nprint((100\/float(26))\/100)","97e6adbf":"### Generate group level features    \n\ndef generate_group_level_features(dataset,feature_columns=['kills','assists','boosts']):\n    features = dataset[[\"matchId\",\"groupId\",*feature_columns]].reset_index(drop=True)\n    matchGroups = features[[\"matchId\",\"groupId\"]].drop_duplicates().reset_index(drop=True)\n    \n    ### predefined basic statistic operations\n    _stats = ['max','min','sum','mean','std']\n    \n    ### calculate group level features\n    for f in feature_columns:\n        for s in _stats:\n            new_field = '{s}_{f}'.format(s=s,f=f)\n            print(new_field)\n            matchGroups = pd.merge(matchGroups,\n                features.groupby([\"matchId\",\"groupId\"],as_index=False)\\\n                .agg({f:s}).rename(columns={f:new_field}).fillna(0)[[\"matchId\",\"groupId\",new_field]].drop_duplicates(),\n                on=['matchId','groupId'],how='inner'\n            )\n            \n    return matchGroups.reset_index(drop=True)","4f1f0a85":"### sample of group level features\n#generate_group_level_features(matchA_df)","6137580f":"import time\ns = time.time()\ngroupLevelFeatures_train = generate_group_level_features(train)\ne = time.time()\nprint(\"elapsed {}s\".format(e-s))","b0641213":"groupLevelFeatures_train.to_csv(\"groupLevelFeatures_train.csv\",index=False)","f869dc4e":"# dummy\n# a = pd.DataFrame(data=[{\"a\":1,\"b\":2},{\"a\":3,\"b\":6}])\n\n# for i,r in a.iterrows():\n#     print(r['a'])\n\n# def dum(x):\n#     x['c'] = x['a'] + x['b']\n#     return x\n\n# a = a.apply(lambda x: dum(x),1)\n\n# a.iloc[0]['c'] = 12\n\n# a","d8956980":"### 4. Prediction Functions","96309dc6":"Because the ranking is spread based on the number of groups in one match, group level features need to be generated!","4669ca24":"### 2. Separate Game Modes data","bd846464":"(TODO) <br>\nBecause how dynamic a winPlacePerc value can be, custom prediction function needs to be developed","86e69ec4":"There are 26 placements which actually correspond to the number of groups. The interval could be retrieved using:","17169962":"### 3. Eliminate Anomalies","daa6d9e4":"Features need to be generated on a group level. Below is the explanation. Let's inspect data for matchId **a10357fd1a4a91**","224c9175":"### 1. Group Level Inspection and Feature Engineering","5bcf62b6":"(TODO) <br>\nThere are several game modes \/ match types in PUBG <br>\nhttps:\/\/pubg.gamepedia.com\/Game_Modes <br>\nPatterns might differ for example between First Person Mode and Third Person Mode even though the players are on solo queue game.","e08aae84":"Various number of players in a group may exist in one match. Player queuing solo will be in a group with only 1 member.","06b7e72a":"Now notice the distribution of placement ranking which we would like to predict","54470f12":"(TODO) <br>\nThere are already existing kernel out there mentioning anomalies or cheaters in PUBG matches. <br>\nWe need to adopt some of them."}}