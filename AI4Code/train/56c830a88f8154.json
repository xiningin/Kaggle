{"cell_type":{"03476dbd":"code","d2c03607":"code","2a72afc0":"code","383dddbf":"code","431cf642":"code","d8bda45f":"code","a86423f4":"code","7823689f":"code","88864a04":"code","3f15bfd6":"code","23a04e9b":"code","3df0aae4":"code","5583f4bc":"code","a0938371":"code","5b287d80":"markdown","6f836597":"markdown","244d8c7f":"markdown","1f5147b7":"markdown","67c54bc5":"markdown","5f444f66":"markdown","218f4b0c":"markdown","2a43abdd":"markdown","9d164891":"markdown","82e8d7d2":"markdown"},"source":{"03476dbd":"!pip install pytorch-tabnet","d2c03607":"#===========================================================\n# Library\n#===========================================================\nimport os\nimport gc\nfrom logging import getLogger, INFO, StreamHandler, FileHandler, Formatter\nfrom contextlib import contextmanager\nimport time\nimport glob\n\nimport numpy as np\nimport pandas as pd\nimport scipy as sp\nimport random\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom functools import partial\n\nfrom sklearn.model_selection import StratifiedKFold, GroupKFold, KFold\nfrom sklearn import preprocessing\nimport category_encoders as ce\nfrom sklearn.metrics import mean_squared_error\n\nimport torch\nfrom sklearn.preprocessing import LabelEncoder\n\nimport pandas as pd\nimport numpy as np\nnp.random.seed(0)\n\nfrom pytorch_tabnet.tab_model import TabNetRegressor ##Import Tabnet \n\n\n\nfrom pathlib import Path\n\nimport lightgbm as lgb\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","2a72afc0":"os.listdir('..\/input\/indoor-location-navigation\/')","383dddbf":"#===========================================================\n# Utils\n#===========================================================\ndef get_logger(filename='log'):\n    logger = getLogger(__name__)\n    logger.setLevel(INFO)\n    handler1 = StreamHandler()\n    handler1.setFormatter(Formatter(\"%(message)s\"))\n    handler2 = FileHandler(filename=f\"{filename}.log\")\n    handler2.setFormatter(Formatter(\"%(message)s\"))\n    logger.addHandler(handler1)\n    logger.addHandler(handler2)\n    return logger\n\nlogger = get_logger()\n\n\n@contextmanager\ndef timer(name):\n    t0 = time.time()\n    yield\n    logger.info(f'[{name}] done in {time.time() - t0:.0f} s')\n\n\ndef seed_everything(seed=777):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n\n    \ndef load_df(path, df_name, debug=False):\n    if path.split('.')[-1]=='csv':\n        df = pd.read_csv(path)\n        if debug:\n            df = pd.read_csv(path, nrows=1000)\n    elif path.split('.')[-1]=='pkl':\n        df = pd.read_pickle(path)\n    if logger==None:\n        print(f\"{df_name} shape \/ {df.shape} \")\n    else:\n        logger.info(f\"{df_name} shape \/ {df.shape} \")\n    return df","431cf642":"#===========================================================\n# Config\n#===========================================================\nOUTPUT_DICT = ''\n\nID = 'Id'\nTARGET_COLS = ['x', 'y', 'f']\nSEED = 42\nseed_everything(seed=SEED)\n\nN_FOLD = 3","d8bda45f":"sample_submission = pd.read_csv('..\/input\/indoor-location-navigation\/sample_submission.csv')","a86423f4":"# the metric used in this competition\ndef comp_metric(y_pred, y_true):\n    xhat = y_pred[:, 0]\n    yhat = y_pred[:, 1]\n    fhat = y_pred[:, 2]\n    x = y_true[:, 0]\n    y = y_true[:, 1]\n    f = y_true[:, 2]\n    intermediate = np.sqrt(np.power(xhat - x,2) + np.power(yhat-y,2)) + 15 * np.abs(fhat-f)\n    return intermediate.sum()\/xhat.shape[0]","7823689f":"def my_loss_fn(y_pred, y_true):\n    xhat = y_pred[:, 0]\n    yhat = y_pred[:, 1]\n    fhat = y_pred[:, 2]\n    x = y_true[:, 0]\n    y = y_true[:, 1]\n    f = y_true[:, 2]\n    intermediate = torch.sqrt(torch.pow(xhat - x,2) + torch.pow(yhat-y,2)) + 15 * torch.absolute(fhat-f)\n    return torch.mean(intermediate)","88864a04":"#===========================================================\n# model\n#===========================================================\ndef run_single_tabnet(clf,train_df, test_df, folds, features, target, fold_num=0, categorical=[]):\n    \n    trn_idx = folds[folds.fold != fold_num].index\n    val_idx = folds[folds.fold == fold_num].index\n    logger.info(f'len(trn_idx) : {len(trn_idx)}')\n    logger.info(f'len(val_idx) : {len(val_idx)}')\n    X_train= train_df.iloc[trn_idx][features].values ###Converted this into Numpy array because TabNet will give error otherwise .\n    y_train=target.iloc[trn_idx].values\n    X_valid = train_df.iloc[val_idx][features].values\n    y_valid= target.iloc[val_idx].values\n\n    oof = np.zeros((len(train_df), target.shape[-1]))\n    predictions = np.zeros((len(test_df), target.shape[-1]))\n    \n\n    clf.fit(\n                X_train=X_train, y_train=y_train, ##Train features and train targets\n                eval_set=[(X_valid, y_valid)],\n                loss_fn = my_loss_fn,\n                weights =0,#0 for no balancing,1 for automated balancing,dict for custom weights per class\n                max_epochs=1000,##Maximum number of epochs during training , Default 1000. I used 10\n                patience=70, ##Number of consecutive non improving epoch before early stopping , Default 50\n                batch_size=1024, ##Training batch size\n                virtual_batch_size=128 )##Batch size for Ghost Batch Normalization (virtual_batch_size < batch_size)\n\n    oof[val_idx.tolist()] = clf.predict(train_df.iloc[val_idx][features].values)\n\n    fold_importance_df = pd.DataFrame()\n    fold_importance_df[\"Feature\"] = features\n    fold_importance_df[\"importance\"] = clf.feature_importances_\n    fold_importance_df[\"fold\"] = fold_num\n\n    predictions += clf.predict(test_df[features].values)\n    \n    # RMSE\n    logger.info(\"fold{} RMSE score: {:<8.5f}\".format(fold_num, np.sqrt(mean_squared_error(target.loc[val_idx], oof[val_idx.tolist()]))))\n    \n    return oof, predictions, fold_importance_df\n\n\ndef run_kfold_tabnet(clf,train, test, folds, features, target, n_fold=5, categorical=[]):\n    \n    logger.info(f\"================================= {n_fold}fold TabNet =================================\")\n    \n    oof = np.zeros((len(train), target.shape[-1]))\n    predictions = np.zeros((len(test), target.shape[-1]))\n    feature_importance_df = pd.DataFrame()\n\n    for fold_ in range(n_fold):\n        print(\"Fold {}\".format(fold_))\n        _oof, _predictions, fold_importance_df = run_single_tabnet(clf,train,\n                                                                     test,\n                                                                     folds,\n                                                                     features,\n                                                                     target,\n                                                                     fold_num=fold_,\n                                                                     categorical=categorical)\n        feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n        oof += _oof\n        predictions += _predictions \/ n_fold\n\n    # RMSE\n    logger.info(\"CV RMSE score: {:<8.5f}\".format(np.sqrt(mean_squared_error(target, oof))))\n\n    logger.info(f\"=========================================================================================\")\n    \n    return feature_importance_df, predictions, oof\n\n    \ndef show_feature_importance(feature_importance_df, sitename):\n    cols = (feature_importance_df[[\"Feature\", \"importance\"]]\n            .groupby(\"Feature\")\n            .mean()\n            .sort_values(by=\"importance\", ascending=False)[:50].index)\n    best_features = feature_importance_df.loc[feature_importance_df.Feature.isin(cols)]\n\n    plt.figure(figsize=(8, 16))\n    sns.barplot(x=\"importance\", y=\"Feature\", data=best_features.sort_values(by=\"importance\", ascending=False))\n    plt.title('Features importance (averaged\/folds)')\n    plt.tight_layout()\n    plt.savefig(OUTPUT_DICT+f'feature_importance_{sitename}.png')\n    plt.show()","3f15bfd6":"# prediction_dict = {}\n# oof_dict = {}\n\n# # for TARGET in TARGET_COLS: ## I think this model will work for multiple targets altogether , let me try that later\n\n# logger.info(f'### TABNET for {TARGET_COLS} ###')\n\n# target = train[TARGET_COLS]\n# test[TARGET] = np.nan\n\n# # features\n# cat_features = []\n# num_features = [c for c in test.columns if (test.dtypes[c] != 'object') & (c not in cat_features)]\n# features = num_features + cat_features\n# drop_features = [ID] + TARGET_COLS\n# features = [c for c in features if c not in drop_features]\n\n# if cat_features:\n#     ce_oe = ce.OrdinalEncoder(cols=cat_features, handle_unknown='impute')\n#     ce_oe.fit(train)\n#     train = ce_oe.transform(train)\n#     test = ce_oe.transform(test)\n\n# cat_idxs = [ i for i, f in enumerate(features) if f in cat_features]\n\n# cat_dims = [ categorical_dims[f] for i, f in enumerate(features) if f in cat_features]    \n\n# clf = TabNetRegressor(\n#                     n_d = 16,##Width of the decision prediction layer. Bigger values gives more capacity to the model with the risk of overfitting. Values typically range from 8 to 64.\n#                     n_a = 16,##Width of the attention embedding for each mask. According to the paper n_d=n_a is usually a good choice. (default=8)\n#                     n_steps = 3,##Number of steps in the architecture (usually between 3 and 10)\n#                     gamma =1.3,##This is the coefficient for feature reusage in the masks. A value close to 1 will make mask selection least correlated between layers. Values range from 1.0 to 2.0.\n#                     cat_idxs=cat_idxs, ##List of categorical features indices.\n#                     cat_dims=cat_dims,\n#                     cat_emb_dim =1, ##List of embeddings size for each categorical features. (default =1)\n#                     n_independent =2,##Number of independent Gated Linear Units layers at each step. Usual values range from 1 to 5.\n#                     n_shared =2,##Number of shared Gated Linear Units at each step Usual values range from 1 to 5\n#                     epsilon  = 1e-15,##Should be left untouched.\n#                     seed  =0,##Random seed for reproducibility\n#                     momentum = 0.02, ##Momentum for batch normalization, typically ranges from 0.01 to 0.4 (default=0.02)\n# #                         lr = 0.01, ##Initial learning rate used for training. As mentionned in the original paper, a large initial learning of 0.02 with decay is a good option.\n#                     clip_value =None,\n#                     lambda_sparse =1e-3,##This is the extra sparsity loss coefficient as proposed in the original paper. The bigger this coefficient is, the sparser your model will be in terms of feature selection. Depending on the difficulty of your problem, reducing this value could help.\n#                     optimizer_fn =torch.optim.Adam, ## Optimizer\n#                     scheduler_fn = None, #torch.optim.lr_scheduler.ReduceLROnPlateau, ## LR scheduler \n#                     scheduler_params = None,#{\"mode\":'min', \"factor\":0.1, \"patience\":10, \"verbose\":\"False\"}, ## LR scheduler parameters dictionary\n#                     verbose =1,\n#                     device_name = 'auto' ## Auto or 'gpu' ## I have no GPU\n\n#                     )    \n\n# feature_importance_df, predictions, oof = run_kfold_tabnet(clf,train, test, folds, features, target, \n#                                                              n_fold=N_FOLD, categorical=cat_features)\n\n# prediction_dict = predictions\n# oof_dict = oof\n\n# show_feature_importance(feature_importance_df, TARGET)","23a04e9b":"# get our train and test files\nfeature_dir = '..\/input\/generate-wifi-features-5-times-faster\/'\n\ntrain_files = sorted(glob.glob(os.path.join(feature_dir, '*_train.csv')))\ntest_files = sorted(glob.glob(os.path.join(feature_dir, '*_test.csv')))\nssubm = pd.read_csv('..\/input\/indoor-location-navigation\/sample_submission.csv', index_col=0)","3df0aae4":"subm_predictions = list()\n\nfor e, train_file in enumerate(train_files):\n    train = pd.read_csv(train_file).reset_index().rename(columns={'index':'Id'})\n    train = train.sample(frac=1, random_state=10)\n    train['Id'] = range(0,len(train))\n    train = train.set_index('Id')\n    train = train.reset_index()\n    \n    test = pd.read_csv(test_files[e]).reset_index().rename(columns={'index':'Id'})\n    \n    \n#     # Comment this to train using all data\n#     train_size = int(len(train) * 0.8)\n#     # --- Data Validation ---\n#     # Valid features + targets\n#     local_valid = train.iloc[train_size:, :]\n#     # Train features + targets\n#     train = train.iloc[:train_size, :]\n\n     \n    \n    folds = train[[ID]+TARGET_COLS].copy()\n    Fold = KFold(n_splits=N_FOLD, shuffle=True, random_state=SEED)\n    for n, (train_index, val_index) in enumerate(Fold.split(folds, folds[TARGET_COLS])):\n        folds.loc[val_index, 'fold'] = int(n)\n    folds['fold'] = folds['fold'].astype(int)\n    folds.head()\n\n    prediction_dict = {}\n    oof_dict = {}\n\n    # for TARGET in TARGET_COLS: ## I think this model will work for multiple targets altogether , let me try that later\n    site = train_file.split('\/')[-1].split('_')[0]\n    logger.info(f'### TABNET for {TARGET_COLS} of site {e}: {site} ###')\n\n    target = train[TARGET_COLS]\n    test[TARGET_COLS] = np.nan\n\n    # features\n    cat_features = []\n    num_features = [c for c in test.columns if (test.dtypes[c] != 'object') & (c not in cat_features)]\n    features = num_features + cat_features\n    drop_features = [ID] + TARGET_COLS\n    features = [c for c in features if c not in drop_features]\n\n    if cat_features:\n        ce_oe = ce.OrdinalEncoder(cols=cat_features, handle_unknown='impute')\n        ce_oe.fit(train)\n        train = ce_oe.transform(train)\n        test = ce_oe.transform(test)\n\n    cat_idxs = [ i for i, f in enumerate(features) if f in cat_features]\n\n    cat_dims = [ categorical_dims[f] for i, f in enumerate(features) if f in cat_features]    \n\n    clf = TabNetRegressor(\n                        n_d = 32,##Width of the decision prediction layer. Bigger values gives more capacity to the model with the risk of overfitting. Values typically range from 8 to 64.\n                        n_a = 32,##Width of the attention embedding for each mask. According to the paper n_d=n_a is usually a good choice. (default=8)\n                        n_steps = 3,##Number of steps in the architecture (usually between 3 and 10)\n                        gamma =1.3,##This is the coefficient for feature reusage in the masks. A value close to 1 will make mask selection least correlated between layers. Values range from 1.0 to 2.0.\n                        cat_idxs=cat_idxs, ##List of categorical features indices.\n                        cat_dims=cat_dims,\n                        cat_emb_dim =1, ##List of embeddings size for each categorical features. (default =1)\n                        n_independent =2,##Number of independent Gated Linear Units layers at each step. Usual values range from 1 to 5.\n                        n_shared =2,##Number of shared Gated Linear Units at each step Usual values range from 1 to 5\n                        epsilon  = 1e-15,##Should be left untouched.\n                        seed  =42,##Random seed for reproducibility\n                        momentum = 0.02, ##Momentum for batch normalization, typically ranges from 0.01 to 0.4 (default=0.02)\n                        optimizer_params = dict(lr=0.01),##Initial learning rate used for training. As mentionned in the original paper, a large initial learning of 0.02 with decay is a good option.\n                        clip_value =None,\n                        lambda_sparse =1e-5,##This is the extra sparsity loss coefficient as proposed in the original paper. The bigger this coefficient is, the sparser your model will be in terms of feature selection. Depending on the difficulty of your problem, reducing this value could help.\n                        optimizer_fn =torch.optim.Adam, ## Optimizer\n                        scheduler_fn = None, #torch.optim.lr_scheduler.ReduceLROnPlateau, ## LR scheduler \n                        scheduler_params = None,#{\"mode\":'min', \"factor\":0.1, \"patience\":10, \"verbose\":\"False\"}, ## LR scheduler parameters dictionary\n                        verbose =1,\n                        device_name = 'cuda' ## Auto or 'gpu' ## I have no GPU\n\n                        )    \n\n    feature_importance_df, prediction_dict, oof_dict = run_kfold_tabnet(clf,train, test, folds, features, target, \n                                                                 n_fold=N_FOLD, categorical=cat_features)\n\n    \n    \n    test_predsx = prediction_dict[:, 0]\n    test_predsy = prediction_dict[:, 1]\n    test_predsf = prediction_dict[:, 2]\n    \n    test_preds = pd.DataFrame(np.stack((test_predsf, test_predsx, test_predsy))).T\n    test_preds.columns = ssubm.columns\n    test_preds.index = test[\"site_path_timestamp\"]\n    test_preds[\"floor\"] = test_preds[\"floor\"].astype(int)\n    subm_predictions.append(test_preds)\n    \n    # save tabnet model\n    saving_path_name = f\"tabnet_model_test_{e}\"\n    saved_filepath = clf.save_model(saving_path_name)\n    \n    score = comp_metric(oof_dict, train[['x', 'y', 'f']].to_numpy())\n    logger.info(f'Local OOF Score site {e}: {score}')\n    \n#     local_valid_score = comp_metric(clf.predict(local_valid.drop(columns = [ID] + TARGET_COLS + ['path']).to_numpy()), local_valid[['x', 'y', 'f']].to_numpy())\n#     logger.info(f'Local Valid Score site {e}: {local_valid_score}')\n    \n#     show_feature_importance(feature_importance_df, site)","5583f4bc":"# generate prediction file \nall_preds = pd.concat(subm_predictions)\nall_preds = all_preds.reindex(ssubm.index)\nall_preds.to_csv('submission.csv')","a0938371":"last_subm = pd.read_csv('..\/input\/lightgdm-baseline-wifi-features\/submission.csv')\nlast_subm.head(30)","5b287d80":"# Training","6f836597":"# Config","244d8c7f":"## MODEL","1f5147b7":"# Submission","67c54bc5":"## Installation","5f444f66":"# Utils","218f4b0c":"### As per TabNet Paper , TabNet has three specialities : \n    a) Unlike tree-based methods, TabNet inputs raw tabular data\n    b)TabNet uses sequential a\u0088ention \n    c) Trained using Gradient -Descent Based Optimizations\n![image.png](attachment:image.png)","2a43abdd":"# Library","9d164891":"### TabNet, a novel deep learning architecture for tabular learning. TabNet uses a sequential attention mechanism to choose a subset of semantically meaningful features to process at each decision step.TabNet uses canonical DNNs to act as decision trees .\n![image.png](attachment:image.png)\n\n\n### Above represented encoder decoder architecture for TabNet. \n#### (a) TabNet encoder for classification or regression, composed of a feature transformer, an attentive transformer and feature masking at each decision step. A split block divides the processed representation into two, to be used by the attentive transformer of the subsequent step as well as for constructing the overall output. At each decision step, the feature selection mask can provide interpretable information about the model\u2019s functionality, and the masks can be aggregated to obtain global feature important attribution. (b) TabNet decoder, composed of a feature transformer block at each step. (c) A feature transformer block example \u2013 4-layer network is shown, where 2 of the blocks are shared across all decision steps and 2 are decision step-dependent. Each layer is composed of a fully-connected (FC) layer, BN and GLU nonlinearity. (d) An attentive transformer block example \u2013 a single layer mapping is modulated with a prior scale information which aggregates how much each feature has been used before the current decision step. Normalization of the coefficients is done using sparsemax for sparse selection of the most salient features at each decision step. (Collected from Original Paper)\n","82e8d7d2":"# Data Loading"}}