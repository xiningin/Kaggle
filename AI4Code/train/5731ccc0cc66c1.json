{"cell_type":{"e6cec991":"code","70131ba8":"code","935cba80":"code","dc891e09":"code","fabbbcc8":"code","7f83d984":"code","22c7c122":"code","10a4df2e":"markdown","078d3469":"markdown","a2b6bbcd":"markdown","a778977f":"markdown","73932ead":"markdown","da2ea526":"markdown","a435c0b0":"markdown"},"source":{"e6cec991":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport cv2\nfrom pathlib import Path\nimport os\n","70131ba8":"dataset_path = \"..\/input\/captcha-version-2-images\/\"\ndirec = Path(dataset_path)\nfilepaths = list(direc.glob(r'**\/*.png'))\nLabels = list(map(lambda x: os.path.split(os.path.split(x)[-1])[1],filepaths))\n\nprint (\"number of images \",len(filepaths))","935cba80":"import matplotlib.pyplot as plt\n\nf,a = plt.subplots(nrows=2, ncols=4, figsize=(13, 7),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\nfor i, ax in enumerate(a.flat):\n    ax.imshow(plt.imread(filepaths[i],0))\n    ax.set_title(Labels[i])\n    \nplt.tight_layout()\nplt.show()","dc891e09":"print (\"original image histogram\")\nimage = plt.imread(filepaths[0],0) * 255.0\nplt.hist(image.ravel(),255,[0,255]); \nplt.show()\n\nsmallest = np.amin(image)\nbiggest = np.amax(image)\nprint(\"min pixel \",smallest,\" max pixel \",biggest)","fabbbcc8":"import cv2 as cv\nprint (str(filepaths[0]))\n# Load the image\nimage = cv.imread(str(filepaths[0]), cv.IMREAD_COLOR)","7f83d984":"src = image.copy()\n# Check if image is loaded fine\nif src is None:\n    print ('Error opening image: ' + filepaths[0])\n\n# Show source image\nplt.imshow( src)\nplt.show()\n# [load_image]\n# [gray]\n# Transform source image to gray if it is not already\nif len(src.shape) != 2:\n    gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)\nelse:\n    gray = src\n    \n    \ngray = cv2.GaussianBlur(gray,(3,3),0) # This is best effective when noise is gaussian\nplt.imshow(gray)\nplt.show()    \n\n\n# [gray]\n# [bin]\n# Apply adaptiveThreshold at the bitwise_not of gray, notice the ~ symbol\ngray = cv.bitwise_not(gray)\nbw = cv.adaptiveThreshold(gray, 255, cv.ADAPTIVE_THRESH_MEAN_C, \\\n                            cv.THRESH_BINARY, 15, -2)\n# Show binary image\nplt.imshow( bw)\nplt.show()\n\n\n# [bin]\n# [init]\n# Create the images that will use to extract the horizontal and vertical lines\nhorizontal = np.copy(bw)\nvertical = np.copy(bw)\n# [init]\n# [horiz]\n# Specify size on horizontal axis\ncols = horizontal.shape[1]\nhorizontal_size = cols \/\/ 30\n# Create structure element for extracting horizontal lines through morphology operations\nhorizontalStructure = cv.getStructuringElement(cv.MORPH_RECT, (50, 1))\n# Apply morphology operations\nhorizontal = cv.erode(horizontal, horizontalStructure)\nhorizontal = cv.dilate(horizontal, horizontalStructure)\n# Show extracted horizontal lines\nplt.imshow( horizontal)\nplt.show()\n# [horiz]\n# [vert]\n# Specify size on vertical axis\nrows = vertical.shape[0]\nverticalsize = rows \/\/ 30\n# Create structure element for extracting vertical lines through morphology operations\nverticalStructure = cv.getStructuringElement(cv.MORPH_RECT, (1, verticalsize))\n# Apply morphology operations\nvertical = cv.erode(vertical, verticalStructure)\nvertical = cv.dilate(vertical, verticalStructure)\n# Show extracted vertical lines\nplt.imshow( vertical)\nplt.show()\n# [vert]\n# [smooth]\n# Inverse vertical image\nvertical = cv.bitwise_not(vertical)\nplt.imshow( vertical)\nplt.show()\n'''\nExtract edges and smooth image according to the logic\n1. extract edges\n2. dilate(edges)\n3. src.copyTo(smooth)\n4. blur smooth img\n5. smooth.copyTo(src, edges)\n'''\n# Step 1\nedges = cv.adaptiveThreshold(vertical, 255, cv.ADAPTIVE_THRESH_MEAN_C, \\\n                            cv.THRESH_BINARY, 3, -2)\nplt.imshow( edges)\nplt.show()\n# Step 2\nkernel = np.ones((2, 2), np.uint8)\nedges = cv.dilate(edges, kernel)\nplt.imshow( edges)\nplt.show()# Step 3\nsmooth = np.copy(vertical)\n# Step 4\nsmooth = cv.blur(smooth, (2, 2))\n# Step 5\n(rows, cols) = np.where(edges != 0)\nvertical[rows, cols] = smooth[rows, cols]\n# Show final result\nplt.imshow( vertical)\nplt.show()\n# [smooth]\n","22c7c122":"\n\ngblur = cv2.GaussianBlur(image,(3,3),0) # This is best effective when noise is gaussian\nplt.imshow(gblur)\nplt.show()\n\ngblur = gblur*255\n\n_,thresh = cv2.threshold(gblur,127,255,cv2.THRESH_BINARY)\nplt.imshow(thresh)\nplt.show()\n\n\n    \ndst = cv.Canny(gblur, 50, 200, None, 3)\n\n# Copy edges to the images that will display the results in BGR\ncdst = cv.cvtColor(dst, cv.COLOR_GRAY2BGR)\ncdstP = np.copy(cdst)\n\nlines = cv.HoughLines(dst, 1, np.pi \/ 180, 150, None, 0, 0)\n\nif lines is not None:\n    for i in range(0, len(lines)):\n        rho = lines[i][0][0]\n        theta = lines[i][0][1]\n        a = math.cos(theta)\n        b = math.sin(theta)\n        x0 = a * rho\n        y0 = b * rho\n        pt1 = (int(x0 + 1000*(-b)), int(y0 + 1000*(a)))\n        pt2 = (int(x0 - 1000*(-b)), int(y0 - 1000*(a)))\n        cv.line(cdst, pt1, pt2, (0,0,255), 3, cv.LINE_AA)\n\n\nlinesP = cv.HoughLinesP(dst, 1, np.pi \/ 180, 50, None, 50, 10)\n\nif linesP is not None:\n    for i in range(0, len(linesP)):\n        l = linesP[i][0]\n        cv.line(cdstP, (l[0], l[1]), (l[2], l[3]), (0,0,0), 1, cv.LINE_AA)\n        \n\n        \nplt.imshow(gblur)\nplt.show()\nplt.imshow(cdst)\nplt.show()\nplt.imshow(cdstP)\nplt.show()\n\n","10a4df2e":"## Colors Histogram","078d3469":"## Remove noise and threshold image","a2b6bbcd":"## Hough","a778977f":"## Trying removing vertical lines","73932ead":"## Read Data","da2ea526":"# Preprocess The Data","a435c0b0":"## Visualize Data"}}