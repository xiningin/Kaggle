{"cell_type":{"6b9f74a7":"code","26786b3d":"code","4839abb0":"code","2338259e":"code","aaf03759":"code","2452d3d8":"code","83447f8d":"code","8eaa856f":"code","e561c5a7":"code","ac99bf11":"code","98fde01b":"code","806d2dae":"code","3c1be7c5":"code","f17de9a3":"code","9a8aa1ca":"code","043e2314":"code","47770756":"code","14663616":"code","c5b5b103":"code","940e5230":"code","b76d487e":"markdown","d7adb213":"markdown","a5ae3b2b":"markdown","e44fd1d0":"markdown","f7b05a97":"markdown","2760d1ef":"markdown","e2158e95":"markdown","847f2541":"markdown","6a7ae810":"markdown","2cc0e89a":"markdown","ca263b17":"markdown","871fc9ae":"markdown"},"source":{"6b9f74a7":"# Bibliotecas necess\u00e1rias\n# Manipula\u00e7\u00e3o de dados\nimport pandas as pd\n# Redes Neurais\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\nfrom tensorflow.keras.optimizers import RMSprop\n# Plotagem\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# Avalia\u00e7\u00e3o de dados\nfrom sklearn.metrics import classification_report, confusion_matrix\n","26786b3d":"# Lendo o dataset\ntrain = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\n\n#Uma alternativa seria ler os dados do pr\u00f3prio Keras\n#(x_train, y_train), (x_test, y_test) = mnist.load_data()\n","4839abb0":"# Analisando o dataset\nprint(\"Quantidade de elementos de treino: {}\". format(len(train)))\nprint(train.head())","2338259e":"# Separando x_train e y_train\nY = train[\"label\"]\nX = train.drop(labels = [\"label\"],axis = 1)\nprint(X.head())\n# Em formato array de imagens 28 x 28\n#x = X.values.reshape(-1,28,28,1)\n#print(x[0])","aaf03759":"print(X.shape)","2452d3d8":"# Plotando a saida\nplt.imshow(X.values[3].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Label: {}'.format(Y[3]))","83447f8d":"# Transformando a imagem 2d em um array (imagem 28*28)\nx = X.values.reshape(42000, 28, 28, 1)\n\n#Normalizando para valores entre 0 e 1\nx = x.astype('float32')\nx \/= 255\n\n#print(x[0])","8eaa856f":"# Ajustando o formato da saida\nnum_classes = 10\n\n# Convertendo para um vetor de saida com 10 dimensoes\n# ex. 8 => [0,0,0,0,0,0,0,0,1,0]\ny = keras.utils.to_categorical(Y, num_classes)\nprint(y[0])","e561c5a7":"# Separando uma parte para treino (90%) e outra para valida\u00e7\u00e3o (10%)\nfrom sklearn.model_selection import train_test_split\nx_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.1, random_state=5)\nprint('Quantidade de treino: {}'.format(len(x_train)))\nprint('Quantidade de valida\u00e7\u00e3o: {}'.format(len(x_val)))","ac99bf11":"# Criando o modelo sequencial\nmodel = Sequential()\nmodel.add(Conv2D(20, kernel_size=(3, 3),\n                 activation='relu',\n                 input_shape=(28,28,1)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(40, kernel_size=(3,3), activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dense(50, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(num_classes, activation='softmax'))\nmodel.summary()","98fde01b":"# Compilando o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy'])","806d2dae":"# Treinando com parte dos dados\nbatch_size = 32\nepochs = 20\n\n#Salvando o melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n]\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    callbacks = callbacks_list,\n                    verbose=1,\n                    validation_data=(x_val, y_val))","3c1be7c5":"#Resultado do teinamento\n\nfig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","f17de9a3":"from tensorflow.keras.models import load_model\n# Load the best saved model\nmodel = load_model('model.h5')","9a8aa1ca":"# Testando a acuracia e perda\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","043e2314":"# Testando uma entrada qualquer\nprint(y_train[10])\nprint(model.predict(x_train[10].reshape((1,28,28,1))))\nprint(model.predict_classes(x_train[10].reshape((1,28,28,1))))","47770756":"import itertools\n\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","14663616":"# Vendo alguns reports\n# Usando sklearn\nimport numpy as np\n\n# Classificando toda base de teste\ny_pred = model.predict_classes(x_val)\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Confution Matrix\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","c5b5b103":"# Gerando sa\u00edda para dataset de teste\n\n#Carrega dataset de teste\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Quantidade de testes: {}\".format(len(test)))\n# Bota no formato numpy e normaliza\nx_test = test.values.reshape(len(test),28,28,1)\nx_test = x_test.astype('float32')\nx_test \/= 255\n\n# Fazendo a classifica\u00e7\u00e3o para dataset de teste\ny_pred = model.predict_classes(x_test)\n\n# Testando um exemplo\ni = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Valor previsto: {}'.format(y_pred[i]))\nprint(\" \")\n\n# Botando no formato de sa\u00edda\nresults = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(submission.head(10))\n#Salvando arquivo de saida dos testes\nsubmission.to_csv(\"output_test.csv\",index=False)","940e5230":"#Introduzindo ruido na imagem\nimport numpy as np\nmean = 0.\nstddev = 0.2\ni=0\nnoise = np.random.normal(mean, stddev, (4200, 28, 28,1))\nx_te = x_val + noise\nx_te = np.clip(x_te, 0., 1.)\n\ny_pred = model.predict_classes(x_te)\nplt.imshow(x_te.reshape(4200, 28,28)[1], cmap=plt.cm.binary)\nplt.show()\nprint('Valor previsto: {}'.format(y_pred[1]))\n\n# Saida do teste\nscore = model.evaluate(x_te, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","b76d487e":"# **2. Importando bibliotecas e explorando dados** <a class=\"anchor\" id=\"2\"><\/a>","d7adb213":"# **4. Avalia\u00e7\u00e3o do modelo** <a class=\"anchor\" id=\"4\"><\/a>","a5ae3b2b":"# **Tabela de conte\u00fados**\n\n<a id = 'max 10'><\/a>\n\n1. [Introdu\u00e7\u00e3o](#1)\n  * Resumo\n\n\n2. [Importando bibliotecas e explorando dados](#2)\n  * Importa\u00e7\u00e3o das bibliotecas\n  * Resumo das fun\u00e7\u00f5es das bibliotecas\n  * Leitura dos dados \n  * Analise do dataset\n  * Saida de imagem\n  * Resultado de treino e valida\u00e7\u00e3o\n\n\n3. [Cria\u00e7\u00e3o e treinamento do modelo](#3)\n   * Cria\u00e7\u00e3o do modelo Sequencial\n   * Compilando o modelo\n   * Treinando parte dos dados e salvando melhor modelo\n   * Resultado do treinamento\n   * Teste de acuracia e perda\n   * Teste com uma entrada qualquer\n   \n   \n4. [Avalia\u00e7\u00e3o do modelo](#4)\n   * Plotagem gr\u00e1fico da matriz confus\u00e3o\n   \n   \n5. [Gerando saida dos testes](#5)\n   * Classifica\u00e7\u00e3o dos testes de saida\n   * Salvamento dos dados de saida\n   \n   \n6. [Teste extra de imagem com ru\u00eddo](#6)\n   * Introdu\u00e7\u00e3o de ruido na imagem e saida\n  \n","e44fd1d0":"O intuito dessa atividade \u00e9 aplicar os conhecimentos teoricos vistos em aula e de forma pratica usando um exemplo selecionado pelo grupo em um dataset de reconhecimento de escrita manual com digitos.\nEstamos aplicando conceitos de Deep Learning, CNN usando a biblioteca como Keras\/Tensor Flow para redes neurais e Sklearn para avalia\u00e7\u00e3o dos dados.","f7b05a97":"**Resumo:**\n\nO exemplo aqui desenvolvido tem como objetivo apresentar conceitos iniciais de implementa\u00e7\u00e3o de redes neurais com Python e Tensor Flow\/Keras. Esse exemplo apresenta um modelo de Rede Neural Convolucional (CNN) b\u00e1sico que pode ser expandido mudando o n\u00famero de neur\u00f4nios e camadas. Em adapta\u00e7\u00f5es mais avan\u00e7adas, pode-se estudar possibilidade de otimiza\u00e7\u00e3o de hyperpar\u00e2metros e outras t\u00e9cnincas como aumento de dados.\n\nN\u00e3o \u00e9 nosso objetivo desenvolver e otimizar o modelo de classifica\u00e7\u00e3o. O exemplo tem objetivo meramente acad\u00eamico.","2760d1ef":"# Reconhecimento de digitos usando Deep Learning\n\n![image](https:\/\/ichi.pro\/assets\/images\/max\/400\/1*Mw20mFOOjS0fE1j2Tiz02A.jpeg)\n\n","e2158e95":"# **1. Introdu\u00e7\u00e3o** <a class=\"anchor\" id=\"1\"><\/a>","847f2541":"Aplicando o ru\u00eddo se \u00e9 possivel perceber que a acuracia dos exemplos de valida\u00e7\u00e3o decai se comparada aos resultados de imagens sem o ru\u00eddo, por\u00e9m obtem resultados melhores se comparados a outras abordagens como do modelo de MLP cl\u00e1ssico, o que v\u00e1lida a robustez da aplica\u00e7\u00e3o do modelo CNN que faz uma melhor captura de padr\u00f5es e regi\u00f5es de pixels.","6a7ae810":"# **6. Teste extra de imagem com ru\u00eddo** <a class=\"anchor\" id=\"6\"><\/a>","2cc0e89a":"# **3. Cria\u00e7\u00e3o e treinamento do modelo** <a class=\"anchor\" id=\"3\"><\/a>","ca263b17":"# **5. Gerando saida dos testes** <a class=\"anchor\" id=\"5\"><\/a>","871fc9ae":"### Resumo das fun\u00e7\u00f5es das bibliotecas\n* Sequential: Modelo Keras vai adicionando camadas\n* Conv2D: Camada com filtros que percorrem a imagem extraindo caracter\u00edsitcas (mapas de caracte\u00edsticas)\n* MaxPooling2D: Camada que reduz a dimensionalidade dos mapas de caracter\u00edsticas 2D\n* Flatten: Camada que transforma um mapa de caracter\u00edsticas 2D num vetor para classficador final\n* Dense: Camada onde todas as entradas est\u00e3o conectadas em cada neur\u00f4nio\n* Dropout: Camada usada durante o treino e descarta aleatoriamente um percentual de conex\u00f5es (reduz overfitting)"}}