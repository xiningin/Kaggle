{"cell_type":{"5123ed52":"code","d9c003f3":"code","4919fca5":"code","e70bb9b5":"code","561846dd":"code","ec1e5284":"code","248eb969":"code","8f5ed468":"code","83568d34":"code","a7ac7522":"code","79267be3":"code","139128fb":"code","4f12eb8d":"code","a7a7bc13":"code","940e19d0":"code","cb9bebb3":"code","eca375bc":"code","a25f1c49":"code","ef31aaac":"code","fce6ccb6":"code","0c4a8434":"code","9ac86fda":"code","ae2145c8":"code","3e46f2ef":"code","3a8381c0":"code","6af3e4a2":"code","91ee10ee":"code","42119948":"code","57f6d7b2":"code","e3d36054":"code","6693a161":"code","e649e3ea":"code","b1987373":"code","86c56aa1":"code","296bc206":"code","73ee8821":"code","599b26eb":"code","0fa22745":"code","c4531d3c":"code","f4c8d6ba":"code","5d6ee4ee":"code","40f8623f":"code","e2590756":"code","7a3aec40":"code","f0f94cbd":"code","6fe9a845":"code","9ec8ca67":"code","dc305482":"code","fe6a7bf7":"code","3164bfde":"markdown","456d6211":"markdown","fcf84893":"markdown","5183bdc4":"markdown","db6ac205":"markdown","c0479bb9":"markdown","51f4e15a":"markdown","8ea0842a":"markdown","36f8c935":"markdown","68ed0c6a":"markdown","41da4457":"markdown","28dab93d":"markdown","d56e02f2":"markdown","59229a83":"markdown","ba656cb8":"markdown"},"source":{"5123ed52":"import numpy as np\nimport pandas as pd\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\n\ndef proc_fare_testonly(inputdf):\n    \"\"\"\n    Filling in the single missing value with the median of the Fare of the same Pclass\n    \"\"\"\n    df = inputdf.copy()\n    df['Fare'] = df['Fare'].fillna(8.05)\n    return df\n\ndef proc_cabin(traindf, testdf):\n    \"\"\"\n    Extract first letter from Cabin column as 'deck' indicator\n    Move most luxerious T cabin as A, as it is a single one.\n    \"\"\"\n    traindf = traindf.copy()\n    testdf = testdf.copy()\n    for df in [traindf, testdf]:\n        df['deck'] = 'N'\n        df.loc[~df.Cabin.isna(), 'deck'] = df.loc[~df.Cabin.isna(), 'Cabin'].apply(lambda x: list([y[0] for y in x.split()])[0])\n        df.loc[df.deck=='T', 'deck'] = 'A'\n    return traindf, testdf\n\ndef proc_embarked_trainonly(inputdf):\n    \"\"\"\n    There are two missing Embarked values in the train set. Filled it in with S as tickets before and after \n    were also from Southampton (by ticket number)\n    \"\"\"\n    df = inputdf.copy()\n    df.loc[[829, 61], 'Embarked'] = 'S'\n    return df\n\ndef proc_age_combined(traindf, testdf):\n    \"\"\"\n    Fill in missing ages with median of the same Pclass+Sex groups\n    \"\"\"\n    traindf = traindf.copy()\n    testdf = testdf.copy()\n    df1 = traindf[['Sex', 'Pclass', 'Age']].copy()\n    df2 = testdf[['Sex', 'Pclass', 'Age']].copy()\n    df1['source'] = 'train'\n    df2['source'] = 'test'\n    combined = pd.concat([df1, df2]).reset_index(drop=True)\n    combined['Age'] = combined.groupby(['Sex', 'Pclass'])['Age'].apply(lambda group: group.fillna(group.median()))\n    traindf['Age'] = combined.loc[combined.source=='train', 'Age'].values\n    testdf['Age']  = combined.loc[combined.source=='test', 'Age'].values\n    return traindf, testdf\n\ndef proc_tickets(inputdf):\n    \"\"\"\n    Split ticket number and prefix\n    \"\"\"\n    df = inputdf.copy()\n    ticketSplit = df.Ticket.apply(lambda x: x.split()).values\n    df['ticketnumber'] = pd.array([int(x[-1]) if x[-1].isdigit() else None for x in ticketSplit], dtype=pd.Int64Dtype())\n    df['ticketprefix'] = [np.nan if len(x)==1 else ' '.join(x[:len(x)-1]) for x in ticketSplit]\n    return df\n\ndef proc_names(inputdf):\n    df = inputdf.copy()\n    df['title'] = df.Name.str.split().apply(lambda x: [y for y in x if y[-1] =='.'][0])\n    df['buyersurname'] = df.Name.apply(lambda x: x.split(',')[0])\n    df['surname'] = df.buyersurname # by default it is the same person\n    df['maidenname'] = None\n    \n    boughtForOthers = df.loc[(df.Name.str.contains('\\(')) & ~(df.Name.str.contains('\\\"'))] # bought for others\n    # first the none wifes:\n    names = boughtForOthers.loc[boughtForOthers.title !='Mrs.'].Name.apply(lambda x: x.split('(')[1].split(')')[0].split()[-1])\n    df.loc[names.index, 'surname'] = names\n    # now the maiden names of the wifes (this is not perfect and there are some errors)\n    names = boughtForOthers.loc[boughtForOthers.title =='Mrs.'].Name.apply(lambda x: x.split('(')[1].split(')')[0])\n    names = names.loc[names.apply(lambda x: len(x.split())>1)]\n    df.loc[names.index, 'maidenname'] = names\n    return df\n\n\ndef importDataset():\n    train = pd.read_csv('\/kaggle\/input\/titanic\/train.csv')\n    test = pd.read_csv('\/kaggle\/input\/titanic\/test.csv')\n    \n    train = proc_names(train)\n    test = proc_names(test)\n    \n    train = proc_tickets(train)\n    test = proc_tickets(test)\n    \n    train, test = proc_age_combined(train, test)\n    train, test = proc_cabin(train, test)\n    \n    train = proc_embarked_trainonly(train)\n    test = proc_fare_testonly(test)\n    return train, test\n\ntrain, test = importDataset()","d9c003f3":"test['Survived'] = None\ntest['source'] = 'test'\ntrain['source'] = 'train'\ncombined = pd.concat([train, test]).copy()","4919fca5":"combined.title.unique()","e70bb9b5":"combined['married'] = 'unknown'\ncombined.loc[(combined.title=='Mrs.') | (combined.title=='Countess.') | (combined.title=='Lady.'), 'married'] = 'yes'\ncombined.loc[(combined.title=='Miss.') | (combined.title=='Master.') | (combined.title=='Mlle.'), 'married'] = 'no'","561846dd":"_ = sns.countplot(x='married', hue='Survived', data=combined)","ec1e5284":"combined['title'] = combined['title'].replace(['Mlle.', 'Ms.'], 'Miss.')\ncombined['title'] = combined['title'].replace(['Mme.', 'Countess.', 'Lady.', 'Dona.'], 'Mrs.')\ncombined['title'] = combined['title'].replace(['Don.', 'Rev.', 'Dr.', 'Major.', 'Sir.', 'Col.', 'Capt.', 'Jonkheer.'], 'Other')\n","248eb969":"_ = sns.countplot(x='title', hue='Survived', data=combined)","8f5ed468":"combined['Age'] = pd.qcut(combined['Age'], 10)","83568d34":"_ = sns.countplot(x='Age', hue='Survived', data=combined)","a7ac7522":"combined['Fare'] = pd.qcut(combined['Fare'], 10)","79267be3":"_ = sns.countplot(x='Fare', hue='Survived', data=combined)","139128fb":"combined['familysize'] = combined['Parch'] + combined['SibSp']\n\nsns.countplot(x='familysize', hue='Survived', data=combined)","4f12eb8d":"combined['family'] = 'alone'\ncombined.loc[(combined.familysize > 0) & (combined.familysize < 4), 'family'] = 'small'\ncombined.loc[(combined.familysize > 4), 'family'] = 'large'\n\n_ = sns.countplot(x='family', hue='Survived', data=combined)","a7a7bc13":"combined['surnamefrequency'] = combined['surname'].map(combined['surname'].value_counts())","940e19d0":"_ = sns.countplot(x='surnamefrequency', hue='Survived', data=combined)","cb9bebb3":"combined['surnamefreq'] = 'alone'\ncombined.loc[(combined.surnamefrequency > 1) & (combined.surnamefrequency <= 4), 'surnamefreq'] = 'small'\ncombined.loc[(combined.surnamefrequency > 4), 'surnamefreq'] = 'large'\n\n_ = sns.countplot(x='surnamefreq', hue='Survived', data=combined)","eca375bc":"combined['ticketfrequency'] = combined['ticketnumber'].map(combined['ticketnumber'].value_counts())","a25f1c49":"_ = sns.countplot(x='ticketfrequency', hue='Survived', data=combined)","ef31aaac":"combined['ticketfreq'] = 'single'\ncombined.loc[(combined.ticketfrequency > 1) & (combined.ticketfrequency <= 4), 'ticketfreq'] = 'small'\n# combined.loc[(combined.ticketfrequency > 1) & (combined.ticketfrequency <= 2), 'ticketfreq'] = 'small'\n# combined.loc[(combined.ticketfrequency > 2) & (combined.ticketfrequency <= 4), 'ticketfreq'] = 'medium'\ncombined.loc[(combined.ticketfrequency > 4), 'ticketfreq'] = 'large'\n\n_ = sns.countplot(x='ticketfreq', hue='Survived', data=combined)","fce6ccb6":"_ = sns.countplot(x='deck', hue='Survived', data=combined)","0c4a8434":"combined.deck.value_counts()","9ac86fda":"combined.loc[combined.deck=='G', 'deck'] = 'F'","ae2145c8":"combined.to_csv('Titanic_raw_processed.csv', index=False)","3e46f2ef":"# df = combined[['Survived', 'Pclass', 'Sex', 'Age', 'Fare','Embarked', 'title', 'deck',\n#        'source', 'married', 'family', \n#        'surnamefreq', 'ticketfreq']].copy()","3a8381c0":"# from sklearn.preprocessing import LabelEncoder, OneHotEncoder","6af3e4a2":"# selectedfeatures = ['Sex', 'Age', 'Fare','Embarked', 'title', 'deck', 'married', 'family', 'surnamefreq', 'ticketfreq']\n\n# for feature in selectedfeatures:        \n#     df[feature] = LabelEncoder().fit_transform(df[feature])\n","91ee10ee":"# df","42119948":"# selectedfeatures = ['Pclass', 'Sex', 'Embarked', 'title', 'deck', 'married', 'family', 'surnamefreq', 'ticketfreq']\n# encoded = []\n\n# for feature in selectedfeatures:\n#     encode = OneHotEncoder().fit_transform(df[feature].values.reshape(-1, 1)).toarray()\n#     n = df[feature].nunique()\n#     cols = ['{}_{}'.format(feature, n) for n in range(1, n + 1)]\n#     encodeddf = pd.DataFrame(encode, columns=cols)\n#     encodeddf.index = df.index\n#     encoded.append(encodeddf)\n\n# final = pd.concat([df[['Survived', 'source']], *encoded], axis=1)\n","57f6d7b2":"# final","e3d36054":"# train = final.loc[final.source=='train'].drop('source', axis=1).copy()\n# test = final.loc[final.source=='test'].drop(['source', 'Survived'], axis=1).copy()","6693a161":"final = combined[['Survived', 'Pclass', 'Sex', 'Age', 'Fare','Embarked', 'title', 'deck',\n       'source', 'married', 'family', \n       'surnamefreq', 'ticketfreq']].copy()","e649e3ea":"from sklearn.preprocessing import LabelEncoder, OneHotEncoder\nselectedfeatures = ['Age', 'Fare']\n\nfor feature in selectedfeatures:        \n    final[feature] = LabelEncoder().fit_transform(final[feature])","b1987373":"train = final.loc[final.source=='train'].drop('source', axis=1).copy()\ntest = final.loc[final.source=='test'].drop(['source', 'Survived'], axis=1).copy()","86c56aa1":"from catboost import CatBoostClassifier, Pool\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nfrom catboost import Pool, CatBoostClassifier, cv\n","296bc206":"target = train.Survived.values\ntrain = train.drop('Survived', axis=1)","73ee8821":"categoryFeatureIdx = np.where(train.dtypes != float)[0]","599b26eb":"target = target.astype(np.uint8)\nxtrain, xtest, ytrain, ytest = train_test_split(train, target, train_size=.85, random_state=42)","0fa22745":"model = CatBoostClassifier(eval_metric='Accuracy',use_best_model=True, random_seed=42, loss_function='Logloss')","c4531d3c":"model.fit(xtrain, ytrain, cat_features=categoryFeatureIdx, eval_set=(xtest,ytest), )","f4c8d6ba":"cv_data = cv(Pool(train,target,cat_features=categoryFeatureIdx), model.get_params(), fold_count=10)","5d6ee4ee":"print('the best cv accuracy is :{}'.format(np.max(cv_data[\"test-Accuracy-mean\"])))","40f8623f":"print('the test accuracy is :{:.6f}'.format(accuracy_score(ytest,model.predict(xtest))))","e2590756":"cv_data","7a3aec40":"print('the test accuracy is :{:.6f}'.format(accuracy_score(ytest,model.predict(xtest))))","f0f94cbd":"model2 = CatBoostClassifier(eval_metric='Accuracy',use_best_model=False, random_seed=42, loss_function='Logloss', iterations=2000)","6fe9a845":"model2.fit(train, target, cat_features=categoryFeatureIdx)","9ec8ca67":"print('the test accuracy is :{:.6f}'.format(accuracy_score(ytest,model2.predict(xtest))))","dc305482":"pred = model2.predict(test)\npred = pred.astype(np.int)\nsubmission = combined.loc[combined.source=='test', ['PassengerId',]].copy()\nsubmission['Survived'] = pred","fe6a7bf7":"submission.to_csv('titanic_submission.csv', index=False)","3164bfde":"I am not sure how to properly split these, but the G deck only has 5 instances, and therefore, I will combine them with F, which is relatively close to the g deck","456d6211":"## Ticket frequency","fcf84893":"## Age and Fare binning","5183bdc4":"Interestingly, you had a higher chance with you bought a small bunch of tickets (2-4 tickets)","db6ac205":"This are a bit too many groups. Let divide them in three groups: Alone, Small family, Large family","c0479bb9":"## Deck","51f4e15a":"The groups will be divided in 10 quantile bins","8ea0842a":"## Model","36f8c935":"## Family size\nParch is a count of parents and children; SibSp are the amount of siblings+spouses on board. Together they form the family size:","68ed0c6a":"## Married and grouping titles","41da4457":"Surname frequency is similar to family size, but has some different results. Not sure, which one is better","28dab93d":"## convert to numeric and One-hot encode","d56e02f2":"Same as with the previous two, a slightly different result.","59229a83":"## Surname frequency","ba656cb8":"## Create train\/test from final"}}