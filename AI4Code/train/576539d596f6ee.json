{"cell_type":{"bd2feca5":"code","9af932a0":"code","655f2139":"code","4380d6ba":"code","0694e9ee":"code","f4230bd5":"code","c78b7370":"code","d9f77203":"code","c98ac7e7":"code","13159d55":"code","656d2c02":"markdown","521f9808":"markdown","841ba5f3":"markdown","b0cf834c":"markdown","ff063026":"markdown","6e89f7ff":"markdown","6a657c48":"markdown","4bc221eb":"markdown"},"source":{"bd2feca5":"###################################################\n#-----importing library---------------------------\n###################################################\nimport pandas as pd\nimport numpy as np\nimport time\nimport copy","9af932a0":"###################################################\n#-----importing Data-----------------------\n###################################################\nTasks_Vms_Cost=pd.read_excel(\"..\/input\/cloudsimdata\/CloudSim Data.xlsx\",sheet_name=\"Cost\",index_col =[0])\nTasks_Vms_Reliability=pd.read_excel(\"..\/input\/cloudsimdata\/CloudSim Data.xlsx\",sheet_name=\"Reliability\",index_col =[0])","655f2139":"Tasks_Vms_Cost","4380d6ba":"Tasks_Vms_Reliability","0694e9ee":"###################################################\n#-----Initialization settings-----------------------\n###################################################\n\n#-----Scientific workflow & Cloud -----------------\nnum_task=100           # number of Tasks\nnum_vm=40              # number of virtual machines\n#-----Genetic Algorithm Paramaters ----------------\npopulation_size= 100\nnum_iteration=500\ncrossover_rate= 0.8\nmutation_rate= 0.3\nmutation_selection_rate= 0.4\nnum_mutation_jobs=round(num_task*mutation_selection_rate)","f4230bd5":"# speed up the data search\nTask_Vm_Cost=[list(map(float, Tasks_Vms_Cost.iloc[i])) for i in range(num_task)]\nTask_Vm_Reliability=[list(map(float,Tasks_Vms_Reliability.iloc[i])) for i in range(num_task)]\nstart_time = time.time()","c78b7370":"###################################################\n#-----Non-dominated sorting function---------------\n###################################################\n\ndef non_dominated_sorting(population_size,chroms_obj_record):\n    s,n={},{}\n    front,rank={},{}\n    front[0]=[]     \n    for p in range(population_size*2):\n        s[p]=[]\n        n[p]=0\n        for q in range(population_size*2):\n            \n            if ((chroms_obj_record[p][0]>chroms_obj_record[q][0] and chroms_obj_record[p][1]<chroms_obj_record[q][1]) \n            or (chroms_obj_record[p][0]>=chroms_obj_record[q][0] and chroms_obj_record[p][1]<chroms_obj_record[q][1])\n            or (chroms_obj_record[p][0]>chroms_obj_record[q][0] and chroms_obj_record[p][1]<=chroms_obj_record[q][1])):\n                if q not in s[p]:\n                    s[p].append(q)\n            elif ((chroms_obj_record[p][0]<chroms_obj_record[q][0] and chroms_obj_record[p][1]>chroms_obj_record[q][1]) \n            or (chroms_obj_record[p][0]<=chroms_obj_record[q][0] and chroms_obj_record[p][1]>chroms_obj_record[q][1])\n            or (chroms_obj_record[p][0]<chroms_obj_record[q][0] and chroms_obj_record[p][1]>=chroms_obj_record[q][1])):\n                n[p]=n[p]+1\n        if n[p]==0:\n            rank[p]=0\n            if p not in front[0]:\n                front[0].append(p)\n    \n    i=0\n    while (front[i]!=[]):\n        Q=[]\n        for p in front[i]:\n            for q in s[p]:\n                n[q]=n[q]-1\n                if n[q]==0:\n                    rank[q]=i+1\n                    if q not in Q:\n                        Q.append(q)\n        i=i+1\n        front[i]=Q\n                \n    del front[len(front)-1]\n    return front\n\n###################################################\n#-----Calculate crowding distance function---------\n###################################################\n\ndef calculate_crowding_distance(front,chroms_obj_record):\n    \n    distance={m:0 for m in front}\n    for o in range(2):\n        obj={m:chroms_obj_record[m][o] for m in front}\n        sorted_keys=sorted(obj, key=obj.get)\n        distance[sorted_keys[0]]=distance[sorted_keys[len(front)-1]]=999999999999\n        for i in range(1,len(front)-1):\n            if len(set(obj.values()))==1:\n                distance[sorted_keys[i]]=distance[sorted_keys[i]]\n            else:\n                distance[sorted_keys[i]]=distance[sorted_keys[i]]+(obj[sorted_keys[i+1]]-obj[sorted_keys[i-1]])\/(obj[sorted_keys[len(front)-1]]-obj[sorted_keys[0]])\n            \n    return distance  \n\n###################################################\n#-----Selection------------------------------------\n###################################################\ndef selection(population_size,front,chroms_obj_record,total_chromosome):   \n    N=0\n    new_pop=[]\n    while N < population_size:\n        for i in range(len(front)):\n            N=N+len(front[i])\n            if N > population_size:\n                distance=calculate_crowding_distance(front[i],chroms_obj_record)\n                sorted_cdf=sorted(distance, key=distance.get)\n                sorted_cdf.reverse()\n                for j in sorted_cdf:\n                    if len(new_pop)==population_size:\n                        break                \n                    new_pop.append(j)              \n                break\n            else:\n                new_pop.extend(front[i])\n    \n    population_list=[]\n    for n in new_pop:\n        population_list.append(total_chromosome[n])\n    \n    return population_list,new_pop","d9f77203":"###################################################\n#-----Main-----------------------------------------\n###################################################\n\n\n###################################################\n#-----Generate initial population------------------\n###################################################\nbest_list,best_obj=[],[]\npopulation_list=[]\nfor i in range(population_size):\n    #print('i=',i)\n    nxm_random_num=list(np.random.permutation(num_task)) # generate a random permutation of 0 to num_job*num_mc-1\n    population_list.append(nxm_random_num) # add to the population_list\n    for j in range(num_task):\n        population_list[i][j]=population_list[i][j]%num_vm # convert to job number format, every job appears m times\n\n        \nfor n in range(num_iteration):         \n    ###################################################\n    #-----Crossover------------------------------------\n    ###################################################\n    parent_list=copy.deepcopy(population_list)\n    offspring_list=[]\n    S=list(np.random.permutation(population_size)) # generate a random sequence to select the parent chromosome to crossover\n    \n    for m in range(int(population_size\/2)):\n        \n        parent_1= population_list[S[2*m]][:]\n        parent_2= population_list[S[2*m+1]][:]\n        child_1=parent_1[:]\n        child_2=parent_2[:]\n        \n        cutpoint=list(np.random.choice(num_task, 2, replace=False))\n        cutpoint.sort()\n    \n        child_1[cutpoint[0]:cutpoint[1]]=parent_2[cutpoint[0]:cutpoint[1]]\n        child_2[cutpoint[0]:cutpoint[1]]=parent_1[cutpoint[0]:cutpoint[1]]\n        \n        offspring_list.extend((child_1,child_2))\n\n    ###################################################\n    #-----Mutation-------------------------------------\n    ###################################################\n    for m in range(len(offspring_list)):\n        mutation_prob=np.random.rand()\n        if mutation_rate <= mutation_prob:\n            m_chg=list(np.random.choice(num_task, num_mutation_jobs, replace=False)) # chooses the position to mutation\n            t_value_last=offspring_list[m][m_chg[0]] # save the value which is on the first mutation position\n            for i in range(num_mutation_jobs-1):\n                offspring_list[m][m_chg[i]]=offspring_list[m][m_chg[i+1]] # displacement\n            \n            offspring_list[m][m_chg[num_mutation_jobs-1]]=t_value_last\n                \n    ###################################################\n    #-----Fitness valuse ------------------------------\n    ###################################################               \n    total_chromosome=copy.deepcopy(parent_list)+copy.deepcopy(offspring_list)\n    chroms_obj_record={} \n    for m in range(population_size*2):\n        gen_c=0\n        gen_r=1\n        for nn in range(num_task):\n            gen_c +=Task_Vm_Cost[nn][total_chromosome[m][nn]]\n            gen_r *=Task_Vm_Reliability[nn][total_chromosome[m][nn]]\n        chroms_obj_record[m]=[gen_r,gen_c]\n        \n    ###################################################\n    #-----Non-dominated sorting -----------------------\n    ################################################### \n    front=non_dominated_sorting(population_size,chroms_obj_record)\n    \n    ###################################################\n    #-----Selection -----------------------------------\n    ###################################################         \n    population_list,new_pop=selection(population_size,front,chroms_obj_record,total_chromosome)\n    new_pop_obj=[chroms_obj_record[k] for k in new_pop] \n    \n    ###################################################\n    #-----Comparison ----------------------------------\n    ################################################### \n    if n==0:\n        best_list=copy.deepcopy(population_list)\n        best_obj=copy.deepcopy(new_pop_obj)\n    else:            \n        total_list=copy.deepcopy(population_list)+copy.deepcopy(best_list)\n        total_obj=copy.deepcopy(new_pop_obj)+copy.deepcopy(best_obj)\n        \n        now_best_front=non_dominated_sorting(population_size,total_obj)\n        best_list,best_pop=selection(population_size,now_best_front,total_obj,total_list)\n        best_obj=[total_obj[k] for k in best_pop]\n###################################################\n#-----Results ------------------------------------\n###################################################\nprint('-----Results -----------------------------')\nprint(\"One chromosome(1x100)=\",best_list[0])\nprint(\"[Reliability,Cost]=\",best_obj[0])\nprint(\"------------------------------------------\")\nprint('The elapsed time:%s'% (time.time() - start_time))","c98ac7e7":"###################################################\n#-----Generate 1000 random chromosome --------------\n###################################################\ndata_list=[]\nfor i in range(2000):\n    nxm_random_num=list(np.random.permutation(num_task))\n    data_list.append(nxm_random_num) \n    for j in range(num_task):\n        data_list[i][j]=data_list[i][j]%num_vm \n        \n    '''--------fitness value(calculate  makespan and TWET)-------------'''\ndata_obj_record={} \nfor m in range(1000):\n    gen_c=0\n    gen_r=1\n    #for i in total_chromosome[m]:\n    for nn in range(num_task):\n        gen_c +=Task_Vm_Cost[nn][data_list[m][nn]]\n        gen_r *=Task_Vm_Reliability[nn][data_list[m][nn]]\n    data_obj_record[m]=[gen_r,gen_c]  \n\ndata_obj_list=[data_obj_record[k] for k in data_obj_record]\n","13159d55":"###################################################\n#-----Pareto optimal of Reliability and Cost ------\n###################################################\n\nimport matplotlib.pyplot as plt\na = np.array(best_obj)\nb = np.array(data_obj_list)\nplt.figure(figsize=(8,6))\nplt.xlabel('Reliability', fontsize=15)\nplt.ylabel('Cost', fontsize=15)\nplt.title(\"Pareto optimal of Reliability and Cost.\")\nplt.scatter(b[:,0], b[:,1], s=15)\nplt.scatter(a[:,0], a[:,1], c='red', s=15)","656d2c02":"### The reliability matrix\nThe reliability of VM(j) when carry out task(i)","521f9808":"### Chromosome\n* Each individual or chromosome is represented as a vector of length equal to the number of tasks(1x100). \n* The values specified in this vector are in the range (1, number of virtual machines(40))\n* The value corresponding to each position in the vector represents the VM to which task T is allocated. ","841ba5f3":"## Optimizing the Reliability and Cost for Scientific Workflows Using NSGA-II\n\n\n***Ammar Alhaj Ali***\n\n*Faculty of Applied Informatics, Tomas Bata University in Zlin, Zlin, Czech Republic*\n\n### Abstract:\n* **Propose:**Build a multi-objective scheduling problem optimization model,in which the cost and reliability to execute scientific workflows are considered.\n* **Methodology:**multi-objective optimization based on Pareto optimal method. NSGA-II is used to solve the model.\n* **Simulation**:We build cloud with 40 VMs and used scientific workflow with 100 tasks, then created two matrices(100x40) for the cost and reliability .\n\n\n","b0cf834c":"### The cost matrix \nThe cost of task(i) on VM(j) ","ff063026":"### Pareto optimal of Reliability and Cost\nWe got Pareto optimal front as shown in the next figure (Red points) after executing 500 generations.","6e89f7ff":"**Note:** We generated 2000 random solutions (Blue points) and added them to the chart to compare with the final generation.","6a657c48":"### Initialization settings","4bc221eb":"### References:\n1. Jiang, Zengqiang, and Zuo Le. \"Study on multi-objective flexible job-shop scheduling problem considering energy consumption.\" Journal of Industrial Engineering and Management (JIEM) 7, no. 3 (2014): 589-604.\n2. Subashini, G., and M. C. Bhuvaneswari. \"Comparison of multi-objective evolutionary approaches for task scheduling in distributed computing systems.\" Sadhana 37, no. 6 (2012): 675-694.\n3. Nidhiry, N. M., and R. Saravanan. \"Scheduling optimization of a flexible manufacturing system using a modified NSGA-II algorithm.\" Advances in Production Engineering & Management 9, no. 3 (2014): 139-151.\n4. https:\/\/github.com\/wurmen\/Genetic-Algorithm-for-Job-Shop-Scheduling-and-NSGA-II"}}