{"cell_type":{"fafed411":"code","436d39dd":"code","e22682c8":"code","1878d41b":"code","9e5dd34a":"code","5ae96f0b":"code","5a8c93e8":"code","a079b20c":"code","41126a02":"code","2eae9214":"code","aebc5240":"code","182ddc4e":"code","6a31039d":"code","85cf39ba":"code","4cece5c0":"markdown","5a721789":"markdown","dcbd7e75":"markdown","a69b6ef8":"markdown","eb648ff4":"markdown","62ca6616":"markdown","bce2595d":"markdown","eeb19f7c":"markdown"},"source":{"fafed411":"! swapon -s\n! dd if=\/dev\/zero of=\/swapfile bs=1024 count=1024k\n! mkswap \/swapfile\n! swapon \/swapfile","436d39dd":"import numpy as np \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport fnmatch\nfrom glob import glob\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nfrom tensorflow.keras.utils import to_categorical\nimport cv2\nfrom sklearn.model_selection import train_test_split\nfrom IPython.display import Image\nfrom sklearn.metrics import confusion_matrix\nnp.random.seed(1)\ntf.random.set_random_seed(11)","e22682c8":"imagePatches = glob('..\/input\/chest_xray\/chest_xray\/**\/**\/*.jpeg', recursive=True)","1878d41b":"pattern_normal = '*NORMAL*'\npattern_bacteria = '*_bacteria_*'\npattern_virus = '*_virus_*'\n\nnormal = fnmatch.filter(imagePatches, pattern_normal)\nbacteria = fnmatch.filter(imagePatches, pattern_bacteria)\nvirus = fnmatch.filter(imagePatches, pattern_virus)\nx = []\ny = []\nfor img in imagePatches:\n    full_size_image = cv2.imread(img, cv2.IMREAD_GRAYSCALE)\n    im = cv2.resize(full_size_image, (224, 224), interpolation=cv2.INTER_CUBIC)\n    x.append(im)\n    if img in normal:\n        y.append(0)\n    elif img in bacteria:\n        y.append(1)\n    elif img in virus:\n        y.append(2)\n    else:\n        #break\n        print('no class')\nx = np.array(x)\ny = np.array(y)","9e5dd34a":"x_train, x_valid, y_train, y_valid = train_test_split(x, y, test_size = 0.2, random_state = 1)\ny_train = to_categorical(y_train, num_classes = 3)\ny_valid = to_categorical(y_valid, num_classes = 3)\ndel x, y","5ae96f0b":"x_train=x_train.reshape((x_train.shape[0], 224, 224,1))\/255\nx_valid=x_valid.reshape((x_valid.shape[0], 224, 224,1))\/255\nx_train.shape,x_valid.shape","5a8c93e8":"def translate_label(inp):\n    if inp[0]==1:\n        return 'normal'\n    elif inp[1]==1:\n        return 'bacteria'\n    else:\n        return 'virus'\ndef translate_predicted_label(inp):\n    maxim=np.argmax(inp)\n    if maxim==0:\n        return 'normal'\n    elif maxim==1:\n        return 'bacteria'\n    else:\n        return 'virus'","a079b20c":"w,h=6,6\nf, ax = plt.subplots(h,w, figsize=(65,65))\nfor i in range(h):\n    for j in range(w):\n        ax[i][j].imshow(np.squeeze(x_valid[i*w+j].astype('float32')), cmap='gray')\n        ax[i][j].set_title(translate_label(y_valid[i*w+j]))\nplt.show()","41126a02":"class MyBlock(tf.keras.Model):\n    def __init__(self, filters,pooling=True,batchnorm=True,dropout=None, **kwargs):\n        super(MyBlock, self).__init__(**kwargs)\n        self.dropout=dropout\n        self.pooling=pooling\n        self.batchnorm=batchnorm\n        self.convlayer7_0=layers.Conv2D(filters,(7,7),padding='same',activation='relu')\n        self.convlayer7_1=layers.Conv2D(filters,(7,7),padding='same',activation='relu') \n        self.convlayer5_0=layers.Conv2D(filters,(5,5),padding='same',activation='relu')\n        self.convlayer5_1=layers.Conv2D(filters,(5,5),padding='same',activation='relu')    \n#         self.convlayer3_0=layers.Conv2D(filters,(3,3),padding='same',activation='relu')\n#         self.convlayer3_1=layers.Conv2D(filters,(3,3),padding='same',activation='relu') \n#         self.convlayer1_0=layers.Conv2D(int(filters\/2),(1,1),padding='same',activation='relu')\n#         self.convlayer1_1=layers.Conv2D(int(filters\/2),(1,1),padding='same',activation='relu') \n        self.poolinglayer=layers.MaxPool2D(2)\n        self.batchnormlayer=layers.BatchNormalization()\n        self.concnetratelayer=layers.Concatenate()\n        if self.dropout is not None:\n            self.dropoutlayer=layers.Dropout(self.dropout)\n    \n    def call(self, input_tensor, training=False):\n        x=input_tensor\n#         x1=self.convlayer1_0(x)\n#         x1=self.convlayer1_1(x1)       \n#         x3=self.convlayer3_0(x)\n#         x3=self.convlayer3_1(x3) \n        x5=self.convlayer5_0(x)\n        x5=self.convlayer5_1(x5)\n        x7=self.convlayer7_0(x)\n        x7=self.convlayer7_1(x7)\n        x=self.concnetratelayer([x5,x7])\n        if self.dropout is not None:\n            x=self.dropoutlayer(x)\n        if self.batchnorm:\n            x=self.batchnormlayer(x)\n        if self.pooling:\n            x=self.poolinglayer(x)\n        return x","2eae9214":"def get_model():\n    model=tf.keras.Sequential()\n    model.add(layers.InputLayer(input_shape=(224, 224, 1)))\n    model.add(MyBlock(32))\n    model.add(MyBlock(64))\n    model.add(MyBlock(64))\n    model.add(MyBlock(128,dropout=0.1))\n    model.add(MyBlock(128,dropout=0.3))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(512,activation='relu'))\n    model.add(layers.Dropout(0.2))\n    model.add(layers.Dense(512,activation='relu'))\n    model.add(layers.Dense(3,activation='softmax'))\n    model.compile(optimizer='Adam', loss = 'categorical_crossentropy', metrics=['accuracy'])\n    tf.keras.utils.plot_model(model, 'model.png',show_shapes=True)  \n    return model\n \n\nmodel=get_model()\nmodel.summary()\nImage('model.png')","aebc5240":"callbacks = [\n  tf.keras.callbacks.EarlyStopping(patience=5, monitor='val_loss',restore_best_weights=True),\n]\nmodel.fit(x_train,y_train,epochs=50,batch_size=64,shuffle=True,validation_data=(x_valid,y_valid),callbacks=callbacks)","182ddc4e":"model.evaluate(x_valid,y_valid)","6a31039d":"\nw,h=6,6\nf, ax = plt.subplots(h,w, figsize=(65,65))\nfor i in range(h):\n    for  j in range(w):\n        ax[i][j].imshow(np.squeeze(x_valid[i*w+j].astype('float32')), cmap='gray')\n        ax[i][j].set_title(\"True: \"+translate_label(y_valid[i*w+j])+\" .Predicted: \"+translate_predicted_label(model.predict(np.asarray([x_valid[i*h+j]]))))\nplt.show()","85cf39ba":"sns.heatmap(\n    confusion_matrix(np.argmax(y_valid,axis=1),np.argmax(model.predict(x_valid),axis=1)),\n    xticklabels=[\"normal\", \"bacteria\", \"virus\"],\n    yticklabels=[\"normal\", \"bacteria\", \"virus\"],\n    square=True,annot=True\n)","4cece5c0":"## Evaluate and Visualize model outputs","5a721789":"## Table of contents\n* [Imports](#Imports)\n* [Import data](#Import-Data)\n* [Normalize Data](#Normalize-Data)\n* [Visualize Data](#Visualize-Data)\n* [Building model](#Building-model)\n* [Training model](#Training-model)\n* [Evaluate and Visualize model outputs](#Evaluate-and-Visualize-model-outputs)","dcbd7e75":"## Training model","a69b6ef8":"## Normalize Data","eb648ff4":"## Imports","62ca6616":"## Visualize Data","bce2595d":"## Import Data","eeb19f7c":"## Building model"}}