{"cell_type":{"ac029966":"code","b1b2b2e1":"code","18705153":"code","d6ad64fa":"code","c4ed0de3":"code","ac16f141":"code","a028231c":"code","ddf93e19":"code","4b166fe8":"code","99029e5b":"code","856f3547":"code","ded91093":"code","2ab2b404":"code","fb303e70":"code","b2e94ea7":"code","97c250ea":"code","6232e6c7":"code","63cfecd3":"code","9a76bb0c":"code","66e0659c":"code","77bec50f":"code","a4b56f36":"code","04cbfbc5":"code","8193d37c":"code","50e6a63e":"code","e4652ed5":"code","474a3904":"code","8be711e4":"code","d52e23c1":"code","12a344af":"code","8768a2da":"code","1b167df8":"code","507bea74":"code","5df319c1":"code","58208b95":"code","e140803a":"code","fec0d30a":"code","3b699e05":"code","fd6e1ab0":"code","268c0b60":"markdown","f20cea06":"markdown","6b0c8fb7":"markdown","a2a4a102":"markdown","b3ad209a":"markdown","f249658e":"markdown","c7818a04":"markdown","2d7dea93":"markdown"},"source":{"ac029966":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sklearn\nimport sys\nfrom sklearn.datasets import load_boston\nimport torch\nimport torch.nn as nn\nfrom sklearn.preprocessing import StandardScaler\nimport math\nimport torch.nn.functional as F\nfrom sklearn.metrics import precision_score","b1b2b2e1":"df = pd.read_csv('..\/input\/mobile-price-classification\/train.csv')","18705153":"df = df.sort_values(by=['price_range'])","d6ad64fa":"df.head()","c4ed0de3":"df.shape","ac16f141":"df['Res'] = df['px_height']*df['px_width']","a028231c":"X = df.drop(['px_height','px_width'],1)","ddf93e19":"y = df['price_range']","4b166fe8":"X.head()","99029e5b":"y.value_counts()","856f3547":"pd.options.display.float_format = '{:,.2f}'.format\ncorr_matrix = X.corr()\ncorr_matrix\nplt.figure(figsize=(12,8))\nsns.heatmap(corr_matrix, annot=True, cmap='YlGnBu')\nplt.show()","ded91093":"\nx = df[['battery_power','ram']]\n\nY = y.values\nplt.scatter(x.values[:,0],x.values[:,1],c=Y)\nplt.xlabel('Ram')\nplt.ylabel('Battery')\nplt.title('Price Range Distrubtion')","2ab2b404":"X = X[['ram','battery_power','Res']]","fb303e70":"X = X.to_numpy()","b2e94ea7":"y = y.to_numpy().reshape(-1,1)","97c250ea":"plt.scatter(X[:,0],X[:,1], c=y)\nplt.xlabel('Ram')\nplt.ylabel('Battery Power')\nplt.title('Result Distribution')","6232e6c7":"class Model(nn.Module):\n\n  def __init__(self,in_features=3,h1=8,h2=9,out_features=4):\n    # how many layers?\n    super().__init__()\n    \n    self.fc1 = nn.Linear(in_features,h1)\n    self.fc2 = nn.BatchNorm1d(h1)\n    self.fc3 = nn.Linear(h1,h2)\n    self.fc4 = nn.BatchNorm1d(h2)\n    self.out = nn.Linear(h2,out_features)\n\n   \n    \n  def forward(self,x):\n    \n    x = F.relu(self.fc1(x))\n    x = F.relu(self.fc2(x))\n    x = F.relu(self.fc3(x))\n    x = F.relu(self.fc4(x))\n    x = self.out(x)\n    return x","63cfecd3":"model = Model()","9a76bb0c":"model","66e0659c":"X_train = torch.FloatTensor(X)","77bec50f":"y_train = torch.LongTensor(y).reshape(-1)","a4b56f36":"criterion = nn.CrossEntropyLoss()\n\noptimizer = torch.optim.Adam(model.parameters(),lr=0.001)","04cbfbc5":"epochs = 2000\nlosses = []\n\nfor i in range(epochs):\n\n  # forward and get a prediction\n  y_pred = model.forward(X_train)\n  # calculate loss\/error\n  loss = criterion(y_pred,y_train)\n  losses.append(loss)\n  if i%100==0:\n    print('Epoch: {} and Loss: {}'.format(i,loss))\n  #Backpropagation\n  optimizer.zero_grad()\n  loss.backward()\n  optimizer.step()","8193d37c":"y_item_2 = []\nfor i in range(2000):\n  y_item_2.append(y_pred[i].argmax())","50e6a63e":"y_item_2 = np.array(y_item_2)","e4652ed5":"correct = 0\nfor i in range(2000):\n  if y_item_2[i]==y_train[i]:\n    correct = correct + 1\nprint('Accuracy: {}'.format(correct*100\/2000))","474a3904":"plt.plot(range(epochs),losses)\nplt.ylabel('Loss')\nplt.xlabel('Epoch')","8be711e4":"df_2 = pd.read_csv('..\/input\/mobile-price-classification\/test.csv')","d52e23c1":"df_2['Res'] = df_2['px_height']*df_2['px_width']","12a344af":"X_val = df_2[['ram','battery_power','Res']]","8768a2da":"X_val = X_val.to_numpy()","1b167df8":"X_test = torch.FloatTensor(X_val)","507bea74":"# TO EVALUATE THE ENTIRE TEST SET\nwith torch.no_grad():\n    y_pred_2 = model.forward(X_test)\n    \n","5df319c1":"from sklearn.svm import SVC\nfrom mlxtend.plotting import plot_decision_regions","58208b95":"y_item = []\nfor i in range(1000):\n  y_item.append(y_pred_2[i].argmax())","e140803a":"y_item = np.array(y_item)","fec0d30a":"X_test_plot = X_test[:,[0,1]]","3b699e05":"svm = SVC(C=0.5, kernel='linear')\nsvm.fit(X_test_plot, y_item)","fd6e1ab0":"plot_decision_regions(X_test_plot.numpy(), y_item, clf=svm, legend=2)\nplt.xlabel('RAM')\nplt.ylabel('Battery Power')\nplt.title('Decision Boundary')\nplt.show()","268c0b60":"## Evaluation on test data","f20cea06":"## Test data Classification","6b0c8fb7":"## Importing libraries","a2a4a102":"## Checking accuracy","b3ad209a":"## Checking loss","f249658e":"## Data Preperation","c7818a04":"## Correlation","2d7dea93":"<a href=\"https:\/\/colab.research.google.com\/github\/euguroglu\/Machine-Learning-Projects\/blob\/master\/Pytorch_Mobile_phone_price_classification.ipynb\" target=\"_parent\"><img src=\"https:\/\/colab.research.google.com\/assets\/colab-badge.svg\" alt=\"Open In Colab\"\/><\/a>"}}