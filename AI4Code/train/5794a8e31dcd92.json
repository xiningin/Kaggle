{"cell_type":{"19327540":"code","edd16bfb":"code","9b74b8a4":"code","32904f3e":"code","57be6ba9":"code","f7e60a9f":"code","c7534b66":"code","7959ada2":"code","e5661b20":"code","37f5a2d0":"code","2935f9ba":"code","068912cb":"code","2b4a50c0":"code","0f224584":"code","ea8b7fc0":"code","255132f6":"markdown","3f9eea31":"markdown","3e2b1db0":"markdown","e57926ee":"markdown","589e2580":"markdown","b2afa237":"markdown","e7dc0a58":"markdown","50e9ee2d":"markdown","b1ab9d7f":"markdown"},"source":{"19327540":"!pip install 'kaggle-environments>=0.1.6'","edd16bfb":"import os\nimport sys\nimport inspect\nimport numpy as np\nfrom kaggle_environments import evaluate, make, utils","9b74b8a4":"env = make('connectx', debug=True)","32904f3e":"# https:\/\/towardsdatascience.com\/creating-the-perfect-connect-four-ai-bot-c165115557b0\n# https:\/\/github.com\/denkspuren\/BitboardC4\/blob\/master\/BitboardDesign.md\n\ndef agent(obs, config):\n    from random import choice\n    import numpy as np\n    \n    MARK_A = obs.mark\n    MARK_B = 3 - MARK_A\n    \n    ROWS = config.rows\n    COLS = config.columns\n    INAROW = config.inarow\n    \n    MOVE_ORDER = [3, 2, 4, 1, 5, 0, 6]\n    \n    TOP_MASK  = int(('1'+'0'*ROWS)*COLS, 2)  # 283691315109952\n    GRID_MASK = int(('0'+'1'*ROWS)*COLS, 2)  # 279258638311359\n        \n    def get_bitmap(obs):\n        board = np.asarray(obs.board).reshape(ROWS, COLS)\n        board = np.insert(board, 0, 0, axis=0)\n        board = np.flip(np.flipud(board).flatten(order='F'))\n\n        str_bitboard = ''.join(map(str, np.int8(board==MARK_A).tolist()))\n        str_bitmask = ''.join(map(str, np.int8(board!=0).tolist()))\n        return int(str_bitboard, 2), int(str_bitmask, 2)\n\n    def is_win(bitboard):\n        for direction in [1, 7, 6, 8]:  # | - \\ \/ \n            bb = bitboard & (bitboard >> direction)\n            if (bb & (bb >> (2 * direction))) != 0: \n                return True\n        return False\n    \n    def play(bitboard, bitmask, c):\n        xboard = bitboard ^ bitmask\n        xmask = bitmask | (bitmask + (1 << (c * COLS)))        \n        xboard = xboard ^ xmask\n        return xboard, xmask\n\n    def play_to_win(bitboard, bitmask, c):\n        xboard, xmask = play(bitboard, bitmask, c)        \n        if is_win(xboard): \n            return True\n        return False\n    \n    def valid_moves(bitmask):\n        moves = []\n        for c in MOVE_ORDER:\n            xmask = bitmask | (bitmask + (1 << (c * COLS)))\n            if (TOP_MASK & xmask) == 0:\n                moves.append(c)\n        return moves\n        \n    def count_ones(bitboard, bitmask):\n        zeros = (~bitmask) & GRID_MASK\n        count = 0\n        for d1 in [1, 7, 6, 8]:  # | - \\ \/ \n            d2 = 2 * d1\n            d3 = 3 * d1\n            bb = ((bitboard & (zeros >> d1) & (zeros >> d2) & (zeros >> d3)) | \n                  (zeros & (bitboard >> d1) & (zeros >> d2) & (zeros >> d3)) | \n                  (zeros & (zeros >> d1) & (bitboard >> d2) & (zeros >> d3)) | \n                  (zeros & (zeros >> d1) & (zeros >> d2) & (bitboard >> d3)))           \n            count += bin(bb).count('1')\n        return count\n        \n    def count_twos(bitboard, bitmask):\n        zeros = (~bitmask) & GRID_MASK\n        count = 0\n        for d1 in [1, 7, 6, 8]:  # | - \\ \/ \n            d2 = 2 * d1\n            d3 = 3 * d1\n            bb = ((bitboard & (bitboard >> d1) & (zeros >> d2) & (zeros >> d3)) | \n                  (bitboard & (zeros >> d1) & (bitboard >> d2) & (zeros >> d3)) | \n                  (bitboard & (zeros >> d1) & (zeros >> d2) & (bitboard >> d3)) | \n                  (zeros & (bitboard >> d1) & (bitboard >> d2) & (zeros >> d3)) | \n                  (zeros & (bitboard >> d1) & (zeros >> d2) & (bitboard >> d3)) | \n                  (zeros & (zeros >> d1) & (bitboard >> d2) & (bitboard >> d3)))              \n            count += bin(bb).count('1')\n        return count\n\n    def count_threes(bitboard, bitmask):\n        zeros = (~bitmask) & GRID_MASK\n        count = 0\n        for d1 in [1, 7, 6, 8]:  # | - \\ \/ \n            d2 = 2 * d1\n            d3 = 3 * d1\n            bb = ((bitboard & (bitboard >> d1) & (bitboard >> d2) & (zeros >> d3)) | \n                  (bitboard & (bitboard >> d1) & (zeros >> d2) & (bitboard >> d3)) | \n                  (bitboard & (zeros >> d1) & (bitboard >> d2) & (bitboard >> d3)) | \n                  (zeros & (bitboard >> d1) & (bitboard >> d2) & (bitboard >> d3)))            \n            count += bin(bb).count('1')\n        return count\n            \n    def heuristic(bitboard, bitmask, c):\n        aboard, xmask = play(bitboard, bitmask, c)\n        a1 = count_ones(aboard, xmask)\n        a2 = count_twos(aboard, xmask)\n        a3 = count_threes(aboard, xmask)\n        \n        bboard, xmask = play(bitboard ^ bitmask, bitmask, c)\n        b1 = count_ones(bboard, xmask)\n        b2 = count_twos(bboard, xmask)\n        b3 = count_threes(bboard, xmask)\n                \n        score = 160 * a3 + 160 * b3 + 40 * a2 + 40 * b2 + 10 * a1 + 10 * b1\n        return score\n        \n    def act(obs):        \n        bitboard, bitmask = get_bitmap(obs)\n        \n        # start in the middle\n        if bitmask == 0: \n            return COLS\/\/2  \n\n        good_moves = valid_moves(bitmask)\n        \n        # play the only option\n        if len(good_moves) == 1:\n            return good_moves[0]  \n        \n        # play to win if you can\n        for c in good_moves:\n            if play_to_win(bitboard, bitmask, c):\n                return c  \n            \n        # avoid setting up a win\n        bad_moves = set()\n        for c in good_moves:\n            xboard, xmask = play(bitboard, bitmask, c)\n            xboard_b = xboard ^ xmask\n            next_moves = valid_moves(xmask)\n            for cx in next_moves:\n                if play_to_win(xboard_b, xmask, cx):\n                    bad_moves.add(c)  \n        good_moves = list(set(good_moves) - bad_moves)\n        \n        # block a win if you can\n        bitboard_b = bitboard ^ bitmask\n        for c in good_moves:\n            if play_to_win(bitboard_b, bitmask, c):\n                return c  \n            \n        # play a heuristic move if you can\n        best_score = -float('inf')\n        best_moves = []\n        for c in good_moves:\n            score = heuristic(bitboard, bitmask, c)   \n            \n            if score > best_score:\n                best_score = score\n                best_moves = [c]\n            elif score == best_score:\n                best_moves.append(c)\n                \n        if best_moves:\n            return choice(best_moves)\n        \n        # random fallback\n        return choice(valid_moves(bitmask))  \n    \n    return act(obs)","57be6ba9":"# https:\/\/www.kaggle.com\/hubcity\/a-more-useful-negamax-opponent-connectx\n\ndef negarand(obs, config):\n    from random import random\n    from kaggle_environments import make\n    \n    env = make('connectx')    \n    if random() < 0.2:\n        return env.agents.random(obs, config)\n    return env.agents.negamax(obs, config)","f7e60a9f":"config = env.configuration\nobs = env.train([None, 'random']).reset()\nobs.mark = 2\nboard = np.asarray([[0, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0, 0]])\nobs.board = board.flatten().tolist()","c7534b66":"# %%timeit -r5 -n5\nmove = agent(obs, config)","7959ada2":"# %%timeit -r5 -n5\nmove = negarand(obs, config)","e5661b20":"# %%timeit -r5 -n5\nmove = env.agents.negamax(obs, config)","37f5a2d0":"env.reset()\nenv.run([agent, agent])\nenv.render(mode='ipython', width=500, height=450)","2935f9ba":"def mean_reward(rewards):\n    return sum(r[0] for r in rewards) \/ sum(r[0] + r[1] for r in rewards)","068912cb":"rewards = evaluate('connectx', [agent, 'random'], num_episodes=100)\nprint('Agent v Random:', mean_reward(rewards))\n\nrewards = evaluate('connectx', ['random', agent], num_episodes=100)\nprint('Random v Agent:', mean_reward(rewards))","2b4a50c0":"rewards = evaluate('connectx', [agent, 'negamax'], num_episodes=100)\nprint('Agent v NegaMax:', mean_reward(rewards))\n\nrewards = evaluate('connectx', ['negamax', agent], num_episodes=100)\nprint('NegaMax v Agent:', mean_reward(rewards))","0f224584":"rewards = evaluate('connectx', [agent, negarand], num_episodes=100)\nprint('Agent v NegaRand:', mean_reward(rewards))\n\nrewards = evaluate('connectx', [negarand, agent], num_episodes=100)\nprint('NegaRand v Agent:', mean_reward(rewards))","ea8b7fc0":"# https:\/\/www.kaggle.com\/ajeffries\/connectx-getting-started\n\nwith open('submission.py', 'w') as file:\n    file.write(inspect.getsource(agent))\n\nout = sys.stdout\nsubmission = utils.read_file('\/kaggle\/working\/submission.py')\nagent = utils.get_last_callable(submission)\nsys.stdout = out\n\nenv = make('connectx', debug=True)\nenv.run([agent, agent])\nprint('Success!' if env.state[0].status == env.state[1].status == 'DONE' else 'Failed...')","255132f6":"# The Matrix","3f9eea31":"<img \nstyle=\"float: left;\" \nsrc=\"https:\/\/cdn.pixabay.com\/photo\/2016\/11\/05\/08\/23\/matrix-1799661_960_720.jpg\"\nwidth=\"500\" \nheight=\"345\" \n\/>","3e2b1db0":"# The Agent","e57926ee":"<img \nstyle=\"float: left;\" \nsrc=\"https:\/\/media1.tenor.com\/images\/f525bbd20ba17de5c99d8a8443527db0\/tenor.gif\" \nwidth=\"500\" \nheight=\"230\" \n\/>","589e2580":"# Speed","b2afa237":"# Evaluation\n<img \nstyle=\"float: left;\" \nsrc=\"https:\/\/vignette.wikia.nocookie.net\/matrix\/images\/7\/71\/Agent_Smith_Clone.jpg\" \nwidth=\"400\" \nheight=\"300\" \n\/>","e7dc0a58":"# References<br\/>\nhttps:\/\/towardsdatascience.com\/creating-the-perfect-connect-four-ai-bot-c165115557b0<br\/>\nhttps:\/\/github.com\/denkspuren\/BitboardC4\/blob\/master\/BitboardDesign.md<br\/>\nhttps:\/\/www.kaggle.com\/hubcity\/a-more-useful-negamax-opponent-connectx<br\/>\nhttps:\/\/www.kaggle.com\/ajeffries\/connectx-getting-started<br\/>","50e9ee2d":"# The Opponent","b1ab9d7f":"# Validation"}}