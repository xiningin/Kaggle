{"cell_type":{"9feb17a3":"code","2620d3ea":"code","6c29d2a3":"code","fe4e63f3":"code","68da00c0":"code","54aa74ab":"code","111e6481":"code","63dc185e":"code","b3a2a429":"code","b72201b2":"code","30d3939b":"code","d56886ef":"code","d77e8f2d":"code","a66d5cee":"code","2fac08ab":"code","3fe9b2be":"code","4b7eb68e":"code","d9c61489":"code","d470df82":"code","e3e8ba78":"code","4e86941e":"code","3b8099c2":"code","982f76a9":"code","69a7976c":"code","d15dda9a":"code","2209df92":"code","d8150f4b":"code","b9bb50d1":"code","6520a467":"markdown","97b57d31":"markdown","e39db1ac":"markdown","8185d01e":"markdown","8ac891ef":"markdown","e118ee4d":"markdown","8fec4252":"markdown","eac9cc4d":"markdown","1b98f8f6":"markdown","cbf9b8a8":"markdown","e132d0ee":"markdown","5b5e25c5":"markdown","57f00431":"markdown","75cfa27e":"markdown","1f1d421e":"markdown","5cecdab6":"markdown","e82d432c":"markdown","e625727f":"markdown","6d2de745":"markdown","92b1e51a":"markdown","1e71a207":"markdown","babb7197":"markdown","1ef5ed29":"markdown","2bebc8ea":"markdown","5243ab51":"markdown","1f706f56":"markdown","0df9141f":"markdown","4c51a4bd":"markdown","83e5df96":"markdown"},"source":{"9feb17a3":"# <- Hier links klicken zum ausf\u00fchren\n###############\n## AUFGABE 0 ## \n###############  \n\n# 1. F\u00fchre diese Codezelle aus, damit die externen libraries geladen werden\n\n\nimport numpy as np # lineare algebra\nimport pandas as pd # daten verarbeitung, CSV file I\/O (e.g. pd.read_csv)\n\n","2620d3ea":"# <- Hier links klicken zum ausf\u00fchren\n###############\n## AUFGABE 1 ## \n###############  \n# 1. Lies den Code und die Kommentare aufmerksam durch und f\u00fchre ihn aus (oben links neben dieser Zelle auf den Startbutton klicken)\n# 2. Schaue dir den output (unterhalb dieser Zelle) an. Wieviele Kalendertage wurden generiert?\n# 3. \u00c4ndere den Wert der Variable anzahl_kalendertage auf 20 und f\u00fchre die Zelle erneut aus. Ver\u00e4ndert sich der output so, wie erwartet?\n# 4. \u00c4ndere den Wert der Variable erster_kalendertag zu deinem Geburtsdatum. Achte darauf die Anf\u00fchrungsstriche zu behalten und schaue dir das Format des Texts genau an. \n#    Ver\u00e4ndert sich der output so, wie erwartet?\n\n\n# die variable anzahl_kalendertage enth\u00e4lt eine Ganzzahl (int) die angibt, wieviele Kalendertage generiert werden\nanzahl_kalendertage = 10\n# die variable erster_kalendertag enth\u00e4lt einen Text (string) welcher angibt, bei welchem Kalendertag die generierte Liste anfangen soll\nerster_kalendertag = \"2013-01-25\"\n# die Variable kalendertage_liste enth\u00e4lt einen array (also eine liste) mit zehn Daten (01.01.2013 - 10.01.2013)\nkalendertage_liste = pd.date_range(erster_kalendertag, periods=anzahl_kalendertage)\n\n# durch das aufschreiben von kalendertage_liste ohne weiteren Befehl, wird der zugewiesene Wert unter der Zelle ausgegeben\nkalendertage_liste\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\nanzahl_kalendertage = 20\nerster_kalendertag = \"1993-03-21\"\nkalendertage_liste = pd.date_range(erster_kalendertag, periods=anzahl_kalendertage)\nkalendertage_liste\n","6c29d2a3":"# <- Hier links klicken zum ausf\u00fchren\n###############\n## AUFGABE 2 ## \n############### \n# 1. Lies den Code und die Kommentare aufmerksam durch und f\u00fchre ihn aus (oben links neben dieser Zelle auf den Startbutton klicken)\n# 2. Wieso gibt es keinen output unter dieser Zelle? Schaue dir die letzte Zeile der vorigen Zelle an.\n#    Was musst du tippen, damit ein output f\u00fcr diese Zelle generiert wird?\n\n# den variablennamen unseres dataframes legen wir als df fest\ndf = pd.DataFrame(np.random.randn(anzahl_kalendertage, 4), index=kalendertage_liste, columns=list(\"ABCD\"))\n\n# f\u00fcr sp\u00e4ter f\u00fcgen wir einen NaN-wert ein. NaN ist ein genormter Platzhalter f\u00fcr fehlende Werte\ndf.iat[3,2] = np.nan\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\ndf\n# ODER\ndf.head()\n","fe4e63f3":"###############\n## AUFGABE 3 ## \n############### \n# 1. Lies den Code und die Kommentare aufmerksam durch und f\u00fchre ihn aus (oben links neben dieser Zelle auf den Startbutton klicken)\n#    Was wird unter dieser Zelle ausgegeben?\n# 2. Wie unterscheidet es sich von der Ausgabe der vorigen Zelle?\n\n# Funktionen k\u00f6nnen an Objekte gebunden und damit objektspezifisch sein. \n# Erst nennen wir den Variablennamen unseres Dataframes: df\n# Dann folgt ein punkt '.'\n# Dann der Name der Objektspezifischenfunktion: head()\n# head() ist also eine Funktion, die wir auf einem Dataframe aufrufen k\u00f6nnen\ndf.head()\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n","68da00c0":"###############\n## AUFGABE 4 ## \n############### \n# 1. Teste, ob die Zeile mit dem fehlenden Wert gel\u00f6scht wurde (Tipp: schaue dir den Code aus Aufgabe 3 an)\n\n# Der Befehl zum L\u00f6schen aller Zeilen mit fehlenden Daten ist 'df.dropna()'\ndf = df.dropna()\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\ndf\n# ODER\ndf.head()\n","54aa74ab":"###############\n## AUFGABE 5 ## \n############### \n# 1. Sortiere den dataframe nach Spalte \"A\"\n# 2. Lass dir das Ergebnis anzeigen und pr\u00fcfe, ob es funktioniert hat.\n# 3. Mit dem Parameter \"ascending=True\" bzw \"ascending=False\" kannst du die Sortierreihenfolge \u00e4ndern. Probieres es aus, indem du innerhalb der Klammern hinter \"by='B'\" ein Komma einf\u00fcgst und dann den ascending-parameter spezifizierst.\n#    (Tipp: schau bei Aufgabe 1 in Zeile 17, um die korrekte Schreibweise bei mehreren Parametern zu verstehen)\n\n# Beachte, dass wir unserem df die neu sortierte Version zuweisen m\u00fcssen. Ansonsten wird die Ver\u00e4nderung nicht gespeichert.\ndf = df.sort_values(by='B')\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ndf = df.sort_values(by='A')\n\n# 2.\ndf = df.sort_values(by='A', ascending=False)\n\ndf\n","111e6481":"######################\n## AUFGABE 6 Teil 1 ## \n######################\n# 1. Waehle aus unserem dataframe die ersten 3 Zeilen aus\n#    (Tipp: nutze den iloc Befehl und ersetze 'v' und 'w' durch die entsprechenden Werte. Anstelle von 'x:y' l\u00e4sst du nur ':' stehen)\n\n\n# zuerst sortieren wir den dataframe wieder nach dem index (in unserem Fall die Kalenderdaten)\ndf = df.sort_index()\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ndf = df.iloc[0:3,:]\n\ndf.head()\n","63dc185e":"######################\n## AUFGABE 6 Teil 2 ## \n######################\n# 2. Waehle aus unserem dataframe die Spalte \"A\" aus\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 2.\ndf = df.loc[:, [\"A\"]]\n\ndf.head()","b3a2a429":"###############\n## AUFGABE 7 ## \n############### \n# 1. F\u00fchre diese Codezelle aus\n\n# importiert operating system (OS) Funktionalit\u00e4ten und erm\u00f6glicht uns damit in Ordnern zu navigieren und auf Dateien zuzugreifen\nimport os\n\n# die folgende Schleife druckt uns alle Datensaetze aus, auf welche wir in diesem Notebook Zugriff haben\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","b72201b2":"###############\n## AUFGABE 8 ## \n###############\n# 1. Verschaffe dir einen \u00dcberblick \u00fcber den Datensatz:\n#    A. Welche Spaltennamen gibt es?\n#    B. Was ist der Index der Zeilen?\n#    C. Gibt es fehlende Werte (NaN)?\n# 2. Versuche dir die Werte ab dem Jahr 2000 anzeigen zu lassen\n#    (Tipp: Wenn du dir nur einen \u00dcberblick \u00fcber die Daten verschaffen willst und sie dabei nicht ver\u00e4ndern m\u00f6chtest, kann du die Zuweisung weglassen.)\n#           Konkret bedeutet dies, dass du zum Beispiel statt 'df = df.iloc[2000:2020,:]' nur 'df.iloc[2000:2020, :]' eingibst\n\n\n# Mit dem 'read_csv()' Befehl von pandas k\u00f6nnen wir die Daten aus der .csv-Datei einem dataframe zuordnen. Da es jetzt um richtige Daten und nicht mehr unseren \u00dcbungsdataframe geht,\n# nutzen wir sprechende Namen f\u00fcr unsere Variablen. Also jetzt 'temperaturen' statt 'df'\ntemperaturen = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalTemperatures.csv', index_col='dt')\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ntemperaturen.head()\n# ODER\ntemperaturen\n\n# 2.\ntemperaturen.iloc[3000:3020, :]\n# ODER\ntemperaturen.loc[\"2000-01-01\":\"2001-01-01\"]","30d3939b":"###############\n## AUFGABE 9 ## \n############### \n# 1. Lade den Datensatz, der die Temperaturen nach L\u00e4ndern aufgeteilt auflistet\n#    (Tipp: scrolle hoch und schaue, wie die verschiedenen Datens\u00e4tze hei\u00dfen (Output von Aufgabe 7). Lade dann den korrekten Datensatz und nenne den dataframe 'temperaturen_laender')\n#    (HINWEIS: Verzichte unbedingt darauf die Kalenderdaten als Indexspalte zu verwenden. Lasse also 'index_col='dt'' weg.)\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ntemperaturen_laender = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalLandTemperaturesByCountry.csv')\n\n","d56886ef":"################\n## AUFGABE 10 ## \n################ \n# 1. lege eine for-Schleife an, die \u00fcber die 'laender_liste' iteriert und den Befehl:\n#    'temperaturen_laender_bereinigt = temperaturen_laender_bereinigt[temperaturen_laender_bereinigt.Country != land]'\n#    auf alle L\u00e4nder anwendet\n#    (Tipp: in python kannst du sehr leicht \u00fcber Listen iterieren)\n# 2. L\u00f6sche alle Zeilen in denen es fehlende Werte gibt.\n\n# Daten aus einem Dataframe zu l\u00f6schen ist nicht so ganz straight forward... Wir l\u00f6sen das ganze indem wir dem bereinigten dataframe alle Zeilen zuweisen in denen \n# der Wert in der Spalte 'Country' nicht gleich 'Denmark' ist (!= stellt die logische Bedingung \"nicht gleich\" dar).\ntemperaturen_laender_bereinigt = temperaturen_laender\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt[temperaturen_laender_bereinigt.Country != 'Denmark']\n\n# Allerding gibt es noch weitere L\u00e4nder, die wir entfernen m\u00f6chten. Um die obere Codezeile nicht mehrfach neu tippen zu m\u00fcssen, legen wir eine Liste an und f\u00fchren\n# den gleichen Befehl f\u00fcr jedes Element in der Liste mehrfach aus.\n# Liste der L\u00e4nder die aus dem Datensatz gel\u00f6scht werden sollen:\nlaender_liste = ['Denmark', 'Antarctica', 'France', 'Europe', 'Netherlands', 'United Kingdom', 'Africa', 'South America']\n\n# In Python kann man sehr leicht \u00fcber Listen iterieren. 'land' ist dabei einfach nur eine Variable, welche in jedem Durchlauf der Schleife den aktuellen String aus der Liste beinhaltet. \n# Im ersten Durchlauf also land = 'Denmark'; im zweiten Durchauf land = 'Antarctica'; im dritten Durchlauf land = 'France'...\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\nfor land in laender_liste:\n    temperaturen_laender_bereinigt = temperaturen_laender_bereinigt[temperaturen_laender_bereinigt.Country != land]\n    \n# 2.\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt.dropna()","d77e8f2d":"################\n## AUFGABE 11 ## \n################ \n# 1. Lies dir den Code und die Kommentare durch und f\u00fchre die Zelle aus\n\n# Jetzt m\u00fcssen wir noch die L\u00e4ndernamen mit '(Europe)' durch die k\u00fcrzeren Pendents ersetzen. Erst legen wir die Listen an mit den alten und neuen L\u00e4ndernamen\nlange_str = ['Denmark (Europe)', 'France (Europe)', 'Netherlands (Europe)', 'United Kingdom (Europe)']\nkurze_str = ['Denmark', 'France', 'Netherlands', 'United Kingdom']\n\n# Das Ersetzen geht sehr einfach mit dem 'replace()' Befehl\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt.replace(lange_str, kurze_str)\n\n# Weil das sp\u00e4ter noch praktisch wird, f\u00fcgen wir jetzt noch eine Spalte hinzu, in welcher lediglich die Jahre stehen:\nyears = pd.DatetimeIndex(temperaturen_laender_bereinigt['dt']).year\ntemperaturen_laender_bereinigt.insert(1, 'Year', years)","a66d5cee":"################\n## AUFGABE 12 ## \n################ \n# 1. Pr\u00fcfe mit dem bereits gelernten, ob die Ver\u00e4nderung des Datensatzes funktioniert hat.\n#    (Tipp: passe 'df.loc[df['column_name'] == some_value]' so an, dass dir Zeilen angezeigt wuerden, in denen einer der gel\u00f6schten Werte (zum Beispiel 'Denmark (Europe)') stuende)\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\ntemperaturen_laender_bereinigt.head()\n\ntemperaturen_laender_bereinigt.loc[temperaturen_laender_bereinigt['Country'] == 'Denmark (Europe)']","2fac08ab":"################\n## AUFGABE 13 ## \n################\n# 1. Lies dir den Code und die Kommentare durch und f\u00fchre die Zelle aus\n# 2. Teste was passiert, wenn du die den Schritt 'reset_index()' auskommentierst und du die Zelle erneut ausf\u00fchrst.\n#    (Tipp: Achte besonders auf die Spalten Bezeichnungen)\n# 3. Sortiere den dataframe mal nach Jahren oder der durchschnittlichen Messunsicherheit. Welche Information k\u00f6nnen wir aus der eigentlich unsinnigen\n#    Variable 'Durchschnittsjahr' im Bezug auf unseren Datensatz lesen?\n\n# Als n\u00e4chstes nutzen wir die groupby funktion von pandas. Mit dieser k\u00f6nnen wir Untergruppen erzeugen und auf diese mathematische Operationen anwenden.\n# So l\u00e4sst sich mit einer einzelnen Codezeile \u00fcber den kompletten dataframe die Durchschnittstemperatur jedes Landes berechnen\ntemp_laender_durchschnitt = temperaturen_laender_bereinigt.groupby(by='Country').mean()\n# danach m\u00fcssen wir die Funktion reset_index() aufrufen.\ntemp_laender_durchschnitt = temp_laender_durchschnitt.reset_index()\n# und wir sortieren unseren Dataframe aufsteigend nach Temperatur\ntemp_laender_durchschnitt = temp_laender_durchschnitt.sort_values('AverageTemperature', ascending=True)\n\ntemp_laender_durchschnitt\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# Sortierung nach Jahren\ntemp_laender_durchschnitt = temp_laender_durchschnitt.sort_values('Year', ascending=True)\n\n#Sortierung nach der durchschnittlichen Messunsicherheit\ntemp_laender_durchschnitt = temp_laender_durchschnitt.sort_values('AverageTemperatureUncertainty', ascending=False)\n\n\n# Dataframe ausgeben\ntemp_laender_durchschnitt.head(20)\n\n\n\n","3fe9b2be":"################\n## AUFGABE 14 ## \n################\n# 1. Lies dir den Code und die Kommentare durch und f\u00fchre die Zelle aus\n# 2. Schau dir die verschiedenen Optionen in der Dokumentation von plotly an:\n#    https:\/\/plotly.com\/python-api-reference\/generated\/plotly.express.choropleth\n# 3. Schalte Seen ein und f\u00e4rbe sie blau\n# 4. \u00c4ndere die variable 'color_continuous_scale' schaue f\u00fcr verf\u00fcgbare Optionen auf:\n#    https:\/\/plotly.com\/python\/builtin-colorscales\/\n#    Welche Option k\u00f6nnte sich f\u00fcr die Darstellung von Temperaturen eignen?\n\n\n\n# Jetzt wird endlich geplottet!!! Fangen wir mal mit einer Weltkugel an, die man sch\u00f6n rumdrehen kann.\n# Als plotting library nutzen wir plotly. Es gibt auch alternativen, allerdings hat plotly neuerdings\n# das sehr angenehme plotly.express interface, welches das Erstellen von plots stark vereinfacht.\nimport plotly.express as px\n\n# das gaengige Kuerzel fuer plots ist 'fig'. Diesem weisen wir jetzt mit dem Befehl 'px.choropleth()' eine Choroplethenkarte zu.\n# Daf\u00fcr m\u00fcssen wir ein paar dinge spezifizieren:\n# Welche Daten sollen f\u00fcr die Karte genutzt werden? Wir m\u00f6chten nat\u00fcrlich unseren sorgsam vorbereiteten Dataframe nutzen.\n# Das spezifizieren an der ersten Stelle.\n# Als n\u00e4chstes legen wir mit keywordargumenten (kwargs) fest, welche Spalten f\u00fcr welche Funktionen genutzt werden sollen:\n# locations = 'Country' legt fest, dass aus der Countryspalte die L\u00e4ndernamen f\u00fcr die raeumliche Zuordnung genutzt werden\n# locationmode='country names' legt fest, dass zur raeumlichen Zuordnung Laendernamen genutzt werden\n# color='AverageTemperature'legt fest, dass die Durchschnittstemperaturen die Farbe f\u00fcr das jeweilige Land definieren\n# color_continuous_scale= 'temps', legt eine sinnvolle Farbskala fest. F\u00fcr andere Anwendungsf\u00e4lle stehen verschiedene Farbskalen zur verfuegung\nfig = px.choropleth(temp_laender_durchschnitt, locations='Country',\n                    locationmode='country names', color='AverageTemperature',\n                    color_continuous_scale= 'magma', hover_name='Country', \n                    title = 'Globale Temperatur')\n\n# Als naechstes nehmen wir noch ein paar Aenderungen an unserer Karte vor. daf\u00fcr nutzen wir den Befehl 'fig.update_geos()'\n# projection_type=\"orthographic\" legt fest, dass die Karte auf einen Globus gemappt wird\n# die weiteren kwargs haben Boolean-Werte, die die jeweilige Funktion ein oder ausschalten\nfig.update_geos(projection_type=\"orthographic\", showocean=True, showlakes=False, showcountries=True, lataxis_showgrid=True, lonaxis_showgrid=True)\n\n# Jetzt passen wir noch die H\u00f6he an, um den Globus etwas gr\u00f6\u00dfer darzustellen und passen die R\u00e4nder rechts, oben, links und unten an\n# height=700 passt die H\u00f6he an\n# margin={\"r\":0,\"t\":50,\"l\":0,\"b\":20} passt die R\u00e4nder an (r=right, t=top, l=left, b=bottom)\nfig.update_layout(height=700, margin={\"r\":0,\"t\":50,\"l\":0,\"b\":20})\n\n# Und als letztes m\u00f6chten wir nat\u00fcrlich das Ergebnis ausgeben:\nfig.show() # <- AUSKOMMENTIEREN, WENN NICHT BEIDE PLOTS ANGEZEIGT WERDEN SOLLEN\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\nfig = px.choropleth(temp_laender_durchschnitt, locations='Country',\n                    locationmode='country names', color='AverageTemperature',\n                    color_continuous_scale='temps', hover_name='Country', \n                    title = 'Globale Temperatur')\n\nfig.update_geos(projection_type=\"orthographic\", showocean=True, showlakes=True, lakecolor='blue', showcountries=True, lataxis_showgrid=True, lonaxis_showgrid=True)\n\nfig.update_layout(height=700, margin={\"r\":0,\"t\":50,\"l\":0,\"b\":20})\n\nfig.show()\n","4b7eb68e":"################\n## AUFGABE 15 ## \n################\n# Um ungewollte Datenver\u00e4nderungen zu vermeiden laden wir die Daten neu und f\u00fchren die Bearbeitungsschritte erneut durch.\n# 1. Lade wieder die csv Datei mit den Daten f\u00fcr einzelne L\u00e4nder (Tipp: Schau dir Aufgabe 9 erneut an)\n# 2. Loesche wieder die Daten von sogenannten Kolonialstaaten (Tipp: Schau dir den Code aus Aufgabe 10 an)\n# 3. Loesche NaN Werte (Tipp: 'dropna()')\n# 4. Ersetze die langen L\u00e4ndernamen mit den kurzen (Tipp: Schau dir den Code aus Aufgabe 11 an)\n# 5. Fuege eine 'Year'-Spalte hinzu, welche nur die Jahreszahlen beinhaltet (Tipp: Schau dir den Code aus Aufgabe 11 an)\n# 6. Berechne den Durchschnittstemperaturwert pro Land (Tipp: Schau dir den Code aus Aufgabe 13 an)\n# 7. Setz den index des dataframes mit '.reset_index()' zur\u00fcck (Tipp: schau dir den Code aus Aufgabe 13 an)\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ntemperaturen_laender = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalLandTemperaturesByCountry.csv')\n\n\n# 2.\ntemperaturen_laender_bereinigt = temperaturen_laender\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt[temperaturen_laender_bereinigt.Country != 'Denmark']\n\nlaender_liste = ['Denmark', 'Antarctica', 'France', 'Europe', 'Netherlands', 'United Kingdom', 'Africa', 'South America']\n\nfor land in laender_liste:\n    temperaturen_laender_bereinigt = temperaturen_laender_bereinigt[temperaturen_laender_bereinigt.Country != land]\n    \n    \n# 3.\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt.dropna()\n\n\n# 4.\nlange_str = ['Denmark (Europe)', 'France (Europe)', 'Netherlands (Europe)', 'United Kingdom (Europe)']\nkurze_str = ['Denmark', 'France', 'Netherlands', 'United Kingdom']\n\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt.replace(lange_str, kurze_str)\n\n\n# 5.\nyears = pd.DatetimeIndex(temperaturen_laender_bereinigt['dt']).year\ntemperaturen_laender_bereinigt.insert(1, 'Year', years)\n\n\n# 6. & 7.\ntemp_laender_durchschnitt = temperaturen_laender_bereinigt.groupby(by='Country').mean()\ntemp_laender_durchschnitt = temp_laender_durchschnitt.reset_index()\n","d9c61489":"################\n## AUFGABE 16 ## \n################\n# Diesmal ein barplot, wieder mit plotly express\n# 1. Lies dir den Code und die Kommentare durch und f\u00fchre die Zelle aus\n# Du solltest ein Grafik sehen. Allerdings sollte diese im aktuellen Zustand wenig hilfreich sein.\n# Das wollen wir \u00e4ndern\n# 2. Um intuitiver zu verstehen, welche Temperaturen die Balken darstellen k\u00f6nnen wir,\n#    wie bei der Choroplethenkarte die kwargs 'color=' und 'color_continuous_scale=' hinzufuegen\n# 3. Damit alle Laender angezeigt werden, nutzen wir 'fig.update_layout()' und spezifizieren die Werte 'height' und 'width'.\n#    Teste, ab welchen Werten links alle Laender angezeigt werden\n#    (Tipp: in Aufgabe 14 haben wir schon einmal die Hoehe des plots veraendert)\n# 4. Jetzt sollte die Grafik schon leichter verstaendlich sein, allerdings waere es gut,\n#    Wenn das Balkendiagramm nach Temperaturen geordnet waere. Fuege als vor dem Erstellen des plots\n#    Code ein, welcher den Dataframe nach Durchschnittstemperatur sortiert.\n#    (Tipp: schau dir nochmal das Ende von Aufgabe 13 an)\n\n\n# px.bar() funktioniert prinzipiell wie px.choropleth(), ben\u00f6tigt allerdings weniger Befehle\n# Als erstes wird wieder der dataframe angegeben, der genutzt werden soll.\n# Danach die Spalte, welche die Daten f\u00fcr die X-Achse liefern soll\n# Danach die Spalte, welche die Daten f\u00fcr die Y-Achse liefern soll\n# Fuer bessere Lesbarkeit waehlen wir horizontale Balken (orientation='h')\nfig = px.bar(temp_laender_durchschnitt, x='AverageTemperature', y='Country', orientation='h')\n# Damit alle Laender angezeigt werden, ver\u00e4ndern wir die Werte 'height' und 'width'\nfig.show() # <- AUSKOMMENTIEREN, WENN NICHT BEIDE PLOTS ANGEZEIGT WERDEN SOLLEN\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 4.\ntemp_laender_durchschnitt = temp_laender_durchschnitt.sort_values('AverageTemperature', ascending=True)\n\n\n# 2.\nfig = px.bar(temp_laender_durchschnitt, x='AverageTemperature', y='Country', \n             orientation='h', color='AverageTemperature', color_continuous_scale='temps')\n\n\n# 3.\nfig.update_layout(height=4000, width=800)\nfig.show()\n\n\n\n","d470df82":"################\n## AUFGABE 17 ## \n################\n# Um ungewollte Datenver\u00e4nderungen zu vermeiden laden wir die Daten neu und f\u00fchren die Bearbeitungsschritte erneut durch.\n# Dazu wiederholen wir die Schritte aus Aufgabe 15. Allerdings gruppieren wir unsere Daten diesmal nach 'Country' und 'Year'\n# Dann berechnen wir f\u00fcr jedes Jahr in jedem Jahr die Durchschnittstemperatur und nennen den dataframe deswegen:\n# 'temperaturen_laender_Jahresdurchschnitt'\n# Und sortieren sie aufsteigend nach Jahr\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ntemperaturen_laender = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalLandTemperaturesByCountry.csv')\n\n\n# 2.\ntemperaturen_laender_bereinigt = temperaturen_laender\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt[temperaturen_laender_bereinigt.Country != 'Denmark']\n\nlaender_liste = ['Denmark', 'Antarctica', 'France', 'Europe', 'Netherlands', 'United Kingdom', 'Africa', 'South America']\n\nfor land in laender_liste:\n    temperaturen_laender_bereinigt = temperaturen_laender_bereinigt[temperaturen_laender_bereinigt.Country != land]\n    \n    \n# 3.\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt.dropna()\n\n\n# 4.\nlange_str = ['Denmark (Europe)', 'France (Europe)', 'Netherlands (Europe)', 'United Kingdom (Europe)']\nkurze_str = ['Denmark', 'France', 'Netherlands', 'United Kingdom']\n\ntemperaturen_laender_bereinigt = temperaturen_laender_bereinigt.replace(lange_str, kurze_str)\n\n\n# 5.\nyears = pd.DatetimeIndex(temperaturen_laender_bereinigt['dt']).year\ntemperaturen_laender_bereinigt.insert(1, 'Year', years)\n\n\n# 6. & 7.\ntemperaturen_laender_Jahresdurchschnitt = temperaturen_laender_bereinigt.groupby(by=['Country', 'Year']).mean()\ntemperaturen_laender_Jahresdurchschnitt = temperaturen_laender_Jahresdurchschnitt.reset_index()\n\n\n# Nach Jahr sortieren\ntemperaturen_laender_Jahresdurchschnitt = temperaturen_laender_Jahresdurchschnitt.sort_values('Year', ascending=True)","e3e8ba78":"################\n## AUFGABE 18 ##\n################\n# Wieso haben wir die Daten in Aufgabe 17 nach Land und Jahr gruppiert?\n# Weil mit zwei weiteren kwargs ein Globus erstellt werden, der die zeitliche Entwicklung der Temperaturen\n# in den Laendern darstellen kann.\n# Nutze daf\u00fcr den Code aus Aufgabe 14 und eraenze die kwargs: \n# animation_frame='Year'\n# animation_group='Country'\n# Und denk dran den korrekten Dataframe anzugeben\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n\nimport plotly.express as px\n\nfig = px.choropleth(temperaturen_laender_Jahresdurchschnitt, locations='Country',\n                    locationmode='country names', color='AverageTemperature',\n                    color_continuous_scale='temps', hover_name='Country', \n                    animation_frame='Year', animation_group='Country',\n                    title = 'Globale Temperatur', range_color=[temperaturen_laender_Jahresdurchschnitt['AverageTemperature'].min(), temperaturen_laender_Jahresdurchschnitt['AverageTemperature'].max()])\nfig.update_geos(projection_type=\"orthographic\", showocean = True, showlakes=False, showcountries=True, lataxis_showgrid=True, lonaxis_showgrid=True)\nfig.update_layout(height=700, margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\nfig.show()","4e86941e":"################\n## AUFGABE 19 ## \n################\n# Leider konnte man bisher mit der Weltkarte schlecht sehen, ob die Temperatur generell zugenommen hat.\n# Allerdings kann man, sehr gut den JAhreszeitenverlauf erkennen, wenn man die Durchschnittstemperatur pro Monat plottet\n# Daf\u00fcr laden wir wieder den Datensatz 'GlobalLandTemperaturesByCountry.csv' in einen Dataframe.\n# Allerdings nutzen wir diesmal die Datumsspalte 'dt' als index indem wir beim pd.read_csv() das Keywordargument 'index_col='dt'' nutzen\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\ntemperaturen_laender = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalLandTemperaturesByCountry.csv', index_col='dt')\n\ntemperaturen_laender","3b8099c2":"################\n## AUFGABE 20 ## \n################\n# 1. Sortiere den Dataframe nach Datum\n# 2. w\u00e4hle mit 'df.loc[]' die Zeilen ab '1980-01-01' aus\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\ntemperaturen_laender = temperaturen_laender.sort_values('dt', ascending=True)\n\ntemperaturen_laender = temperaturen_laender.loc['1980-01-01':, :]\n\ntemperaturen_laender\n\n","982f76a9":"################\n## AUFGABE 21 ## \n################\n# 1. Nutze zur Animation den Code aus Aufgabe 18\n# 2. Als 'animation_frame' m\u00fcssen wir diesmal den index des dataframes nutzen\n#    (Tipp: df.index gibt die indizes als Liste aus)\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\nimport plotly.express as px\n\nimport plotly.graph_objs as go\n\n\nfig = px.choropleth(temperaturen_laender,locations='Country',\n                    locationmode='country names', animation_frame=temperaturen_laender.index,\n                    animation_group='Country',color='AverageTemperature',\n                    color_continuous_scale= 'temps' , hover_name='Country', \n                    title = 'Globale Temperaturen nach Monat')\n\nfig.update_geos(projection_type=\"orthographic\", showocean = True, showlakes=False, showcountries=True, lataxis_showgrid=True, lonaxis_showgrid=True)\n\ndf = pd.DataFrame(np.array([[1, 2, 3], [1,2,3], [0,0,0]]),\n                   columns=['val', 'lon', 'lat'])\n\nfig.update_traces(mode=\"text\",text=df[\"val\"], lat=df[\"lat\"], lon=df[\"lon\"], selector=dict(type='scattergeo'))\n\nfig.update_layout(height=700, margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\n\nfig.show()","69a7976c":"################\n## AUFGABE 22 ## \n################\n# 1. Lies dir den Code und die Kommentare durch und f\u00fchre die Zelle aus\n\n# Der output l\u00e4sst sich sogar als .html-Dokument speichern, falls du mal etwas exportieren m\u00f6chtest:\n# Nach dem Ausf\u00fchren der Zelle findest du die Datei oben rechts im Outputordner\n# Diesen musst du wahrscheinlich kurz aktualisieren\nfig.write_html(\"..\/working\/file.html\")\n","d15dda9a":"################\n## AUFGABE 23 ## \n################\n# 1. Lade die 'GlobalTemperatures.csv' in den dataframe 'temperaturen_global'\n# 2. Fuege wieder die Spalte nur mit Jahreszahlen ein\n# 3. Gruppiere die Daten nach Jahr und berechne den Durchschnitt pro Jahr\n# 4. Als letztes, setze noch den Index zurueck\n\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ntemperaturen_global = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalTemperatures.csv')\n\n\n# 2.\nyears = pd.DatetimeIndex(temperaturen_global['dt']).year\ntemperaturen_global.insert(1, 'Year', years)\n\n\n# 3.\ntemperaturen_global = temperaturen_global.groupby(by='Year').mean()\n\n\n# 4.\ntemperaturen_global = temperaturen_global.reset_index()\n\ntemperaturen_global","2209df92":"################\n## AUFGABE 24 ## \n################\n# Orientiere dich an Aufgabe 16 in welcher du das barplot erstellt hast:\n# 1. erstelle mit 'px.line()' ein Liniendiagramm. Dafuer musst du folgende kwargs spezifizieren:\n#    Als datenquelle wollen wir unseren dataframe 'temperaturen_global' nutzen\n#    Auf die x-Achse sollen die Jahre geplottet werden (\"Year\")\n#    Auf die y-Achse sollen die Durchschnittstemperaturen an Land geplottet werden (\"LandAverageTemperature\")\n#    Lege einen Titel f\u00fcr das Liniendiagramm an\n# 2. Lasse das Liniendiagram anzeigen\n\nimport plotly.express as px\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\nfig = px.line(temperaturen_global, x=\"Year\", y=\"LandAverageTemperature\", title='Globale Durchschnittstemperatur')\n\n\n# 2.\nfig.show()\n","d8150f4b":"################\n## AUFGABE 25 ## \n################\n# Bisher haben wir mit plotly.express gearbeitet, welches uns sehr sehr viel Arbeit abnimmt.\n# Allerdings kann man mit dem Verzicht auf das interface 'plotly.express' noch komplexere Aufgaben loesen\n# Wenn wir direkt die plotly.graph_objs library nutzen k\u00f6nnen wir in unserem Liniendiagramm die\n# Messungenauigkeit visualisieren. Brauchen dafuer allerdings mehr code.\n# Versuche mal den Code unten zu verstehen \n# Wenn du testen willst, ob du etwas richtig verstanden hast, kannst du den Code mal abaendern\n# und die Zelle erneut ausf\u00fchren.\n# Zum Beispiel kannst du Breite der Linie veraendern. Oder die Farbe der Fuellflaeche aendern\n\nimport plotly.graph_objs as go\n\n# Diese Zeile ist identisch mit der aus Aufgabe 24. Ist nur daf\u00fcr da,\n# damit die Figur beim Ausfuehren der Zelle neue angelegt wird.\n# Ansonsten w\u00fcrde mit add_trace nur jedesmal eine weitere Linie\n# zum oben angelegten Liniendiagramm hinzugef\u00fcgt werden\nfig = px.line(temperaturen_global, x=\"Year\", y=\"LandAverageTemperature\", title='Globale Durchschnittstemperatur')\n\nfig.add_trace(go.Scatter(\n        # hiermiet weisen wir der Linie einen Namen zu\n        name='Obere Messunsicherheitsgrenze',\n        # hiermit legen wir fest, dass weiterhin die Jahre als x-Koordinate genutzt werden\n        x=temperaturen_global['Year'],\n        # Als y-Koordinate wollen wir die Jahresdurchschnittstemperatur\n        # mit der Messungenauigkeit addieren\n        # Es handelt sich ja um die obere Grenze\n        y=temperaturen_global['LandAverageTemperature']+temperaturen_global['LandAverageTemperatureUncertainty'],\n        # Da wir eine Linie plotten wollen, nutzen wir den 'lines' Modus\n        mode='lines',\n        # Aus aethetischen Gruenden legen wir fest, dass die Linie nicht sichtbar sein soll\n        # das loesen wir, indem wir die Breite der Linie auf 0 festlegen\n        line=dict(width=0),\n        # Und die Linie soll nicht in unserer Legende auftauchen\n        showlegend=False\n    ))\nfig.add_trace(go.Scatter(\n        name='Untere Messunsicherheitsgrenze',\n        x=temperaturen_global['Year'],\n        y=temperaturen_global['LandAverageTemperature']-temperaturen_global['LandAverageTemperatureUncertainty'],\n        line=dict(width=0),\n        mode='lines',\n        # Jetzt legen wir noch fest, dass der Bereich zwischen der vorigen und dieser Linie\n        # mit einer Farbe gef\u00fcllt werden soll\n        fill='tonexty',\n        # und welche Farbe das sein soll\n        fillcolor='rgba(255, 0, 0, 0.1)',\n        showlegend=False\n    ))\n\nfig.show()","b9bb50d1":"################\n## AUFGABE 26 ## \n################\n# Manchmal kann es helfen einen laengeren Zeitraum zu waehlen ueber den man die \n# Temperaturen mittelt. Das hilft, die Veraenderung deutlicher hervozuheben.\n# Orientiere dich fuer die folgenden Schritte an Aufgabe 23\n# 1. Lade die 'GlobalTemperatures.csv' in den dataframe 'temperaturen_global'\n# 2. Fuege wieder die Spalte nur mit Jahreszahlen ein\n# 3. Gruppiere die Daten nach Jahr und berechne den Durchschnitt pro Jahr\n# 4. Setze den Index zurueck\n# 5. Mit df['Spaltenname'].rolling(10).mean() kann man \u00fcber den Datensatz iterieren\n#    und den Durchschnitt der letzten Jahre berechnen. Veraendere den eben genannten\n#    Befehl so, dass ueber den gerade angelegten dataframe und die sie Spalte\n#    'LandAverageTemperature' iteriert wird. Weise den output der Variable\n#    'zehn_jahres_durchschnitt' zu.\n#    (Tipp: orientiere dich an der Schreibweise aus Schritt 3.)\n# 6. Fuege die Daten einer neuen Spalte im dataframe zu. Nenne die Spalte 'ZehnJahresMittel'\n#    (Tipp: Orientiere dich an der Schreibweise aus Schritt 2.)\n# 7. Orientiere dich an Aufgabe 24 und lege mit px.line() ein Liniendiagramm an.\n#    Als Daten nutzt du den gerade angelegten dataframe 'temperaturen_global'\n#    Als x-Werte nutzt du wieder die Jahre.\n#    Als y-Werte nutzt du die neu angelegte Spalte mit den gemittelten Temperaturen\n\n# Teste ruhig mal, inwiefern sich das Diagramm veraendert, wenn du statt einem 10 Jahresmittel\n# hoehere oder niedrigere Werte w\u00e4hlst.\n\n\n# UNTERHALB AUFGABENLOESUNG EINGEBEN\n####################################\n\n# 1.\ntemperaturen_global = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalTemperatures.csv')\n\n\n# 2.\nyears = pd.DatetimeIndex(temperaturen_global['dt']).year\ntemperaturen_global.insert(1, 'Year', years)\n\n\n# 3.\ntemperaturen_global = temperaturen_global.groupby(by='Year').mean()\n\n\n# 4.\ntemperaturen_global = temperaturen_global.reset_index()\n\n\n# 5.\nzehn_jahres_durchschnitt = temperaturen_global['LandAverageTemperature'].rolling(10).mean()\n\n\n# 6.\ntemperaturen_global.insert(1, 'ZehnJahresMittel', zehn_jahres_durchschnitt)\n\n\n# 7.\nfig = px.line(temperaturen_global, x=\"Year\", y=\"ZehnJahresMittel\", title='Globale Durchschnittstemperatur 10-Jahres Mittel')\n\nfig.write_html(\"..\/working\/file.html\")\n\nfig.show()\n\n","6520a467":"Schau dir in ruhe den Globus an.\n\nWirken die Daten realistisch auf dich?\n\nFallen dir vielleicht Ungereimtheiten auf?\n\nWelche L\u00e4nder fehlen? Welche haben komische Werte?","97b57d31":"# Daten laden","e39db1ac":"Jetzt haben wir also eine Liste mit Kalendertagen generiert, die wir als Indizes nutzen k\u00f6nnen. Als n\u00e4chstes brauchen wir noch mehr Daten, um unseren Dataframe zu f\u00fcllen. Daf\u00fcr generieren wir Zufallszahlen und legen die Spalten \"A\", \"B\", \"C\" und \"D\" an:","8185d01e":"Zum Test laden wir mal den ersten Datensatz und schauen in die Daten:","8ac891ef":"# Balkendiagramm mit Durchschnittstemperaturen erstellen","e118ee4d":"# Liniendiagramm","8fec4252":"\nWeitere gute Grundlagentutorials auf Englisch findest du hier:\n\n[https:\/\/www.w3schools.com\/python](https:\/\/www.w3schools.com\/python)\n","eac9cc4d":"## Liniendigram mit Darstellung der Messungenauigkeit","1b98f8f6":"Erstmal wollen wir auf dem L\u00e4nderbasierten Datensatz arbeiten. Daf\u00fcr m\u00fcssen wir deinen neuen dataframe anlegen, der die Daten der .csv-Datei 'GlobalLandTemperaturesByCountry.csv' beinhaltet","cbf9b8a8":"### Bestimmte Daten ausw\u00e4hlen:\n","e132d0ee":"# Einf\u00fchrung in Pandas","5b5e25c5":"# Jahreszeiten Weltkugel","57f00431":"### Werte sortieren","75cfa27e":"Nachdem wir die Vorarbeit geleistet haben, kommen wir jetzt endlich zu den vielen Funktionen die uns pandas bietet. Mit diesen k\u00f6nnen wir die Daten anschauen und \u00c4nderungen vornehmen. Zuerst schauen wir uns die verschiedenen Funktionen zum anschauen der Daten an:","1f1d421e":"Als erstes erstellen wir einen kleinen dataframe (df) in pandas um uns mit den Grundfunktionen vertraut zu machen. Daf\u00fcr generieren wir zuerst eine Liste mit Daten (Kalendertagen):\n\n","5cecdab6":"Jetzt bist du am Ende der festgelegten Aufgaben angekommen...\n\nWenn du magst kannst du jetzt kreativ werden. Als n\u00e4chstest k\u00f6nntest du zum Beispiel...\n\n...versuchen die Temperaturdaten einer Stadt zu plotten. Bamberg ist leider nicht im Datensatz 'GlobalLandTemperaturesByCity.csv'\nAllerdings gibt es 'Nuremberg' und 'Munich'. Wenn du fragen hast, oder eine kleine Hilfestellung w\u00fcnschst, wende dich an uns.  \n...versuchen die Daten mehrerer L\u00e4nder in ein Liniendigramm zu plotten, sodass man sie vergleichen kann.  \n...versuchen die Messungenauigkeit im 10-Jahres-Mittel-Diagramm anzuzeigen.  \n...versuchen den Bereich der X-Achse so anzupassen, dass die Linie direkt am linken Rand beginnt.  \n...versuchen Daten zu CO2 in der Atmosph\u00e4re bei Kaggle zu finden und ebenfalls ins Liniendiagramm zu plotten.  \n...versuchen die Anzahl an Waldfeuern in den USA zusammen mit der Temperatur in den USA zu plotten.  \n...versuchen eine Choroplethenkarte mit Coronadaten zu erstellen (Vielleicht ein kleiner Stimmungsdaempfer)\n...was komplett eigenes ueberlegen und versuchen umzusetzen.  \n\n\nCO2 & GHG  \nhttps:\/\/www.kaggle.com\/srikantsahu\/co2-and-ghg-emission-data\n\n\nWILDFIRES  \nhttps:\/\/www.kaggle.com\/rtatman\/188-million-us-wildfires  \nhttps:\/\/www.kaggle.com\/kkhandekar\/total-wildfires-acres-affected-1983-2020\n\n\nCOVID  \nhttps:\/\/www.kaggle.com\/gpreda\/covid-world-vaccination-progress  \nhttps:\/\/www.kaggle.com\/atilamadai\/covid19 <- time_series_covid19_confirmed_global.csv(1.05 MB)\n\n","e82d432c":"### NaN Werte l\u00f6schen\nBei gro\u00dfen Datens\u00e4tzen kommt es h\u00e4ufig vor, dass einzelne Daten fehlen. Das kann bei der weiteren Verarbeitung unsch\u00f6n werden und zu Fehlern f\u00fchren. Es gibt verschiedene Wege damit umzugehen. Wir begn\u00fcgen uns bei unserem Klimadatensatz damit, die Zeilen mit fehlenden Daten zu l\u00f6schen:","e625727f":"Sp\u00e4ter werden wir auch sehen, dass das sortieren von Daten ebenfalls wichtig ist. Daf\u00fcr gibt es bei Pandas den Befehl df.sort_values(). Innerhalb der Klammern kann spezifiziert werden, nach welcher Spalte die Daten sortiert werden sollen:","6d2de745":"In unserem Datensatz sind ein paar L\u00e4nder, welche wir entfernen wollen. Das liegt daran, dass diese doppelt vorhanden sind und Daten aus Kolonialzeiten beinhalten.","92b1e51a":"**Und jetzt gehts los:**\n\nPython verf\u00fcgt \u00fcber eine F\u00fclle an externen libraries, die komplexe Funktionalit\u00e4ten bereitstellen und uns das Leben leichter machen:\n","1e71a207":"Jetzt kann man auch gut erkennen, dass die globale Durchschnittstemperatur seit circa 1980 stetig zuzunehmen scheint","babb7197":"# Weltkugel mit Durchschnittstemperaturen","1ef5ed29":"Jenachdem, wie vertraut du generell mit Programmierung, Python und Englisch bist, kannst du auch versuchen dir mit der plotly Dokumentation zu helfen.\n\nDiese findest du unter:\n[https:\/\/plotly.com\/python-api-reference\/](https:\/\/plotly.com\/python-api-reference\/)\n\nKann aber wirklich ein hartes Brett sein, sich durch die Dokumentation zu fuchsen.\nFrag also lieber, bevor du an der Un\u00fcbersichtlichkeit verzweifelst","2bebc8ea":"Bisher konnte man zwar viele spannende Sachen erkennen und vorallem sehen, dass die Daten plausibel erscheinen, \nallerdings war es mit den bisherigen Darstellungsm\u00f6glichkeiten noch nicht m\u00f6glich einen Anstieg der Temperatur visuell darzustellen.\n\nDaf\u00fcr greifen wir jetzt auf die globalen Daten und das gute alte Liniendiagramm zur\u00fcck!","5243ab51":"## Liniendiagram mit dem Temperaturmittel \u00fcber die letzten 10 Jahre","1f706f56":"Zum Ausw\u00e4hlen von Ausschnitten aus einem dataframe gibt es verschiedene M\u00f6glichkeiten:\n\n`df.iloc[v:w, x:y]` w\u00e4hlt Zeilen und Spalten anhand ihrer Position im dataframe aus\n\n`df.loc[:, [\"B\",\"C\"]]` w\u00e4hlt Zeilen und Spalten anhand ihrer Spaltennamen aus","0df9141f":"# Interaktive Weltkugel mit zeitlichem Temperaturverlauf","4c51a4bd":"# Datavisualization  mit Klimadaten","83e5df96":"Wieso bleiben zu Beginn so viele Laender grau?"}}