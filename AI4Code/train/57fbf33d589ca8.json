{"cell_type":{"d6de1e89":"code","0e84cd55":"code","752fbc56":"code","7ad03d6b":"code","38ac0d45":"code","50ec0b18":"code","4b9a45f2":"code","1282a030":"code","45ffe7f7":"code","11489880":"code","5e399b2c":"code","d32790ad":"code","e7e60188":"code","6fab1318":"code","bf1e6b2c":"code","66e883fe":"code","91de6377":"code","e408c2c0":"code","25815a8a":"code","57805ee8":"code","387bd73c":"code","2bcd5c6c":"code","ef6650fa":"code","e58fdf96":"code","ff41e251":"code","f681cc7a":"code","0128c248":"code","7e252a61":"code","79484fc9":"code","407fd293":"code","8d7a5062":"code","77a36764":"code","3b0414da":"code","29807dcd":"code","f350aa35":"code","54f52307":"code","cd54acb2":"code","70b22d1d":"code","2206688a":"code","0eeef327":"code","938f821a":"code","58885980":"code","3a31c99d":"code","1416417f":"code","99ba68b8":"code","452909fc":"code","f41cc9cf":"code","0c68061b":"code","74fe3d04":"code","0764088c":"code","7fd37582":"code","eae6a870":"code","f242b488":"markdown","b3c3c51b":"markdown","365e4877":"markdown","6d90e998":"markdown","933ea517":"markdown","56559b72":"markdown","3e4c1118":"markdown","fdcff7fb":"markdown","a556e439":"markdown","94457f21":"markdown","a3e036cf":"markdown","3183169f":"markdown","172e4f0e":"markdown","ed4a4383":"markdown","eb8847ee":"markdown","a9c98bdc":"markdown","822d2849":"markdown","73f36f2d":"markdown","e80cb2f8":"markdown","2dc470d0":"markdown","0e1696e8":"markdown","9152cb5d":"markdown","6a244c5f":"markdown"},"source":{"d6de1e89":"%reset -f\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os","0e84cd55":"from imblearn.over_sampling import SMOTE, ADASYN","752fbc56":"from sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import  OneHotEncoder as ohe\nfrom sklearn.preprocessing import StandardScaler as ss\nfrom sklearn.compose import ColumnTransformer as ct","7ad03d6b":"from xgboost.sklearn import XGBClassifier\nfrom sklearn.metrics import precision_recall_fscore_support","38ac0d45":"from sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import average_precision_score\nimport sklearn.metrics as metrics\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import auc, roc_curve","50ec0b18":"#os.chdir(\"F:\\\\Practice\\\\Machine Learning and Deep Learning\\\\Classes\\\\Assignment\\\\Kaggle\\\\4th\")","4b9a45f2":"#os.listdir()\n","1282a030":"#ccf=pd.read_csv(\"creditcardfraud.zip\")\nccf = pd.read_csv(\"..\/input\/creditcard.csv\")","45ffe7f7":"ccf.head(3)","11489880":"ccf.info()","5e399b2c":"ccf.describe()","d32790ad":"ccf.shape","e7e60188":"ccf.columns.values","6fab1318":"ccf.dtypes.value_counts()","bf1e6b2c":"plt.style.use('ggplot')\n\nf, ax = plt.subplots(figsize=(11, 15))\n\nax.set_facecolor('#fafafa')\nax.set(xlim=(-5, 5))\nplt.ylabel('Variables')\nplt.title(\"Overview Data Set\")\nax = sns.boxplot(data = ccf.drop(columns=['Amount', 'Class', 'Time']), \n  orient = 'h', \n  palette = 'Set2')","66e883fe":"f, (ax1, ax2) = plt.subplots(1,2,figsize =( 18, 8))\ncorr = ccf.corr()\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\nsns.heatmap((ccf.loc[ccf['Class'] ==1]).corr(), vmax = .8, square=True, ax = ax1, cmap = 'afmhot', mask=mask);\nax1.set_title('Fraud')\nsns.heatmap((ccf.loc[ccf['Class'] ==0]).corr(), vmax = .8, square=True, ax = ax2, cmap = 'YlGnBu', mask=mask);\nax2.set_title('Normal')\nplt.show()","91de6377":"sns.countplot(x='Class', data=ccf)","e408c2c0":"(ccf.isnull()).apply(sum, axis = 0)","25815a8a":"y = ccf.iloc[:,30]\nX = ccf.iloc[:,0:30]","57805ee8":"X.shape","387bd73c":"X.columns","2bcd5c6c":"y.head()","ef6650fa":"X_trans = ss().fit_transform(X)\nX_trans.shape","e58fdf96":"X_train, X_test, y_train, y_test =   train_test_split(X_trans,\n                                                      y,\n                                                      test_size = 0.3,\n                                                      stratify = y\n                                                      )","ff41e251":"X_train.shape","f681cc7a":"xg = XGBClassifier(learning_rate=0.5,\n                   reg_alpha= 5,\n                   reg_lambda= 0.1\n                   )","0128c248":"sm = SMOTE(random_state=42)\nX_res, y_res = sm.fit_sample(X_train, y_train)","7e252a61":"X_res.shape","79484fc9":"y_res.shape","407fd293":"xg_res = xg.fit(X_res, y_res)","8d7a5062":"y_pred_xg_res = xg_res.predict(X_test)\ny_pred_xg_res","77a36764":"y_pred_xg_res_prob = xg_res.predict_proba(X_test)\ny_pred_xg_res_prob","3b0414da":"print ('Accuracy using XGB and SMOTE',accuracy_score(y_test,y_pred_xg_res))","29807dcd":"confusion_matrix(y_test,y_pred_xg_res)","f350aa35":"fpr_xg_res, tpr_xg_res, thresholds = roc_curve(y_test,\n                                 y_pred_xg_res_prob[: , 1],\n                                 pos_label= 1\n                                 )","54f52307":"p_xg_res,r_xg_res,f_xg_res,_ = precision_recall_fscore_support(y_test,y_pred_xg_res)","cd54acb2":"p_xg_res,r_xg_res,f_xg_res","70b22d1d":"print ('AUC using XGB and SMOTE',auc(fpr_xg_res,tpr_xg_res))","2206688a":"fig = plt.figure(figsize=(12,10)) \nax = fig.add_subplot(111)\nax.plot([0, 1], [0, 1], ls=\"--\")   \nax.set_xlabel('False Positive Rate')  \nax.set_ylabel('True Positive Rate')\nax.set_title('ROC curve for XGB and SMOTE')\nax.set_xlim([0.0, 1.0])\nax.set_ylim([0.0, 1.0])\nax.plot(fpr_xg_res, tpr_xg_res, label = \"xgb\")\nax.legend(loc=\"lower right\")\nplt.show()","0eeef327":"ad = ADASYN(random_state=42)\nX_ada, y_ada = sm.fit_sample(X_train, y_train)","938f821a":"X_ada.shape","58885980":"y_ada.shape","3a31c99d":"xg_ada = xg.fit(X_ada, y_ada)","1416417f":"y_pred_xg_ada = xg_ada.predict(X_test)\ny_pred_xg_ada","99ba68b8":"y_pred_xg_ada_prob = xg_ada.predict_proba(X_test)\ny_pred_xg_ada_prob","452909fc":"print ('Accuracy using XGB and ADASYN',accuracy_score(y_test,y_pred_xg_ada))","f41cc9cf":"confusion_matrix(y_test,y_pred_xg_ada)","0c68061b":"fpr_xg_ada, tpr_xg_ada, thresholds = roc_curve(y_test,\n                                 y_pred_xg_ada_prob[: , 1],\n                                 pos_label= 1\n                                 )","74fe3d04":"p_xg_ada,r_xg_ada,f_xg_ada,_ = precision_recall_fscore_support(y_test,y_pred_xg_ada)","0764088c":"p_xg_ada,r_xg_ada,f_xg_ada","7fd37582":"print ('AUC using XGB and ADASYN',auc(fpr_xg_ada,tpr_xg_ada))","eae6a870":"fig = plt.figure(figsize=(12,10))        \nax = fig.add_subplot(111)\nax.plot([0, 1], [0, 1], ls=\"--\")\nax.set_xlabel('False Positive Rate')\nax.set_ylabel('True Positive Rate')\nax.set_title('ROC curve for XGB and ADASYN')\nax.set_xlim([0.0, 1.0])\nax.set_ylim([0.0, 1.0])\nax.plot(fpr_xg_ada, tpr_xg_ada, label = \"xgb\")\nax.legend(loc=\"lower right\")\nplt.show()","f242b488":"As we can below the X_res and y_res are having same number of rows, that means we have balanced the data","b3c3c51b":"Precion, Recall and F1 Score","365e4877":"Predict","6d90e998":"Processing data","933ea517":"SMOTE-Balancing the data","56559b72":"ADASYN-Balancing the data","3e4c1118":"Load libraries","fdcff7fb":"XGB Classifier","a556e439":"Explore data","94457f21":"for ROC graphs & metrics","a3e036cf":"Import SMOTE AND ADASYN to balance the dataset","3183169f":"Fit the data","172e4f0e":"Finding the Missing Value's","ed4a4383":"Confusion Matrix","eb8847ee":"Separation into target\/predictors","a9c98bdc":"Split data into train\/test","822d2849":"Call Modeling module, we will be using XBG for modeling.","73f36f2d":"Fit and transform","e80cb2f8":"Read data","2dc470d0":"Correlation matrix","0e1696e8":"Ploting","9152cb5d":"Accuracy","6a244c5f":"ROC Curve"}}