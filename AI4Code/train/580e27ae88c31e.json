{"cell_type":{"44b531c7":"code","1d4ddd93":"code","85b06dcf":"code","4364e73d":"code","139c0cca":"code","5ea47673":"code","9924ac11":"code","f3b16f2c":"code","14dcadb1":"code","264cb082":"code","ab8c2648":"code","caaf808d":"code","7f175d21":"code","6d8e589c":"code","98338bf0":"code","41b4dd52":"code","22da2ed8":"code","2ea8595b":"code","f5d0f19a":"code","4a21c348":"code","f526bd93":"code","9099a855":"markdown","b957d5bf":"markdown","71fbccbc":"markdown","532dce96":"markdown","1c4f14e7":"markdown","74122564":"markdown","a5968e21":"markdown","6e274a83":"markdown","3791dd9e":"markdown","7639beeb":"markdown","07266c85":"markdown","2f781d1b":"markdown","00d604c8":"markdown","f97f58d8":"markdown","ee483eb6":"markdown","028ae76f":"markdown","bdd5bb1e":"markdown","6b9ea5e9":"markdown","6638b924":"markdown","01a3ddb0":"markdown","4b6034f7":"markdown","f0542011":"markdown","8cdb0ee3":"markdown","37637b6d":"markdown","d19c925e":"markdown","02040fd1":"markdown"},"source":{"44b531c7":"import math\nimport random\n\nimport numpy as np \nimport pandas as pd\nimport seaborn as sns\n\nimport matplotlib.pyplot as plt\nimport plotly.figure_factory as ff\nimport plotly.express as px\n\nimport statistics\nfrom collections import Counter\n\n%matplotlib inline","1d4ddd93":"def logistic (R, x0, N, png_counter):    \n    x = x0\n    x_list = [x0]\n    for i in range(N-1):      \n        x = R * x * (1. - x)\n        x_list.append(x)\n        \n    plt.style.use('seaborn-whitegrid')\n    plt.figure(figsize=(16, 6), facecolor='lightgray')\n    plt.xlabel('The number of iterations')\n    plt.ylabel('The value of x')\n    plt.title(f'\\nLogistic Equation\\n\\nR={R}  |  x0={x0}\\n')\n    plt.plot(x_list, 'o:r')\n    plt.show()\n\n    if (png_counter != 0):\n        plt.savefig(f'logistic_equation_{png_counter}.png')","85b06dcf":"logistic(2, 0.5, 30, 101)","4364e73d":"logistic(2, 0.2, 30, 102)","139c0cca":"logistic(2, 0.99, 30, 103)","5ea47673":"logistic(2.5, 0.6, 30, 104)","9924ac11":"logistic(2.5, 0.5, 30, 105)","f3b16f2c":"logistic(2.5, 0.7, 30, 105)","14dcadb1":"logistic(3.1, 0.5, 90, 106)","264cb082":"logistic(3.1, 0.4, 90, 107)","ab8c2648":"logistic(3.1, 0.85, 90, 108)","caaf808d":"logistic(3.45, 0.30, 90, 109)","7f175d21":"logistic(3.555, 0.30, 90, 110)","6d8e589c":"logistic(4.0, 0.30, 120, 201)","98338bf0":"logistic(4.0, 0.3000000001, 120, 202)","41b4dd52":"R = 4.0\nN = 120\n\nx0_a = 0.3\nx0_b = 0.3000000001\nx_list_a = [x0_a]\nx_list_b = [x0_b]\n\nx_a = x0_a\nx_b = x0_b\nfor i in range(N-1):   \n    x_a = R * x_a * (1. - x_a)\n    x_b = R * x_b * (1. - x_b)\n    \n    x_list_a.append(x_a)\n    x_list_b.append(x_b)\n\nhist_data = [x_list_b, x_list_a]  \ngroup_labels = ['x0 = 0.3000000001', 'x0 = 0.3']   \nfig = ff.create_distplot(hist_data, group_labels, bin_size=.2, show_hist=False, show_rug=False) \nfig.show()","22da2ed8":"R_list = np.linspace(2.0, 4.0, 1000)\nx0 = 0.3\nN = 500\n\ndef logis(r):\n    x_list = [x0]    \n    for i in range(N-1):\n        x_list.append(r * x_list[-1] * (1 - x_list[-1]))\n    return x_list[400:]\n\nx_select = []\nR_select = []\nfor r in R_list:\n    x_select.append(logis(r))\n    R_select.append([r] * 100) \n    \nx_select = np.array(x_select).ravel()\nR_select = np.array(R_select).ravel()\n\nplt.style.use('seaborn-whitegrid')\nplt.figure(figsize=(16, 6), facecolor='lightgray')\nplt.xlabel('The value of R')\nplt.ylabel('The value of x')\nplt.title(f'\\nThe bifurcation diagram of the Logistic Equation\\n\\n2.0 < R < 4.0  |  x0=0.3\\n')\nplt.scatter(R_select, x_select, color='red', s=0.1)\nplt.savefig('bifurcation_diagram.png')\nplt.show()","2ea8595b":"feigenbaum = pd.DataFrame()\nfeigenbaum['Period'] = [2, 4, 8, 16, 32, 64, 128, 256]\nfeigenbaum['Bifurcation parameter']= [3, 3.4494897, 3.5440903, 3.5644073, 3.5687594, 3.5696916, 3.5698913, 3.5699340]\nfeigenbaum['Ratio'] = ['N', 'N', 4.7514, 4.6562, 4.6683, 4.6686, 4.6692, 4.6694]\nfeigenbaum","f5d0f19a":"R_list = np.linspace(2.0, 4.0, 20000)\nx0 = 0.3\nN = 1200\n\ndef logis(r):\n    x_list = [x0]    \n    for i in range(N-1):\n        x_list.append(r * x_list[-1] * (1 - x_list[-1]))\n    return x_list[200:]\n\nnon_repetitive = [] \nfor r in R_list:\n    non_repetitive.append(len(Counter(logis(r))))\n    \nplt.style.use('seaborn-whitegrid')\nplt.figure(figsize=(16, 6), facecolor='lightgray')\nplt.xlabel('The value of R')\nplt.ylabel('Counter non-repetitive numbers')\nplt.title(f'\\nCounter non-repetitive numbers\\n\\n2.0 < R < 4.0  |  x0=0.3\\n')\nplt.scatter(R_list, non_repetitive, color='red', s=3)\nplt.savefig('non_repetitive_numbers.png')\nplt.show()   ","4a21c348":"R_list = [2.8, 3.0, 3.2, 3.4494897, 3.5, 3.5440903, 3.55, 3.5644073, 3.566, 3.5687594 ,3.569, 3.5696916, 3.5697, 4.0]\nx0 = 0.3\nN = 10001000\n\ndef logis(r):\n    x_list = [x0]    \n    for i in range(N-1):\n        x_list.append(r * x_list[-1] * (1 - x_list[-1]))\n    return x_list[10000000:]\nresults= pd.DataFrame()\n\nfor r in R_list:\n    results[f'R={r}'] = logis(r)\n    non_repetitive = len(Counter(logis(r))) \n    print(f'When R={r} the number of non-repetitive numbers is equal to:  {non_repetitive}')\n    print('::' * 38)\n    \nprint('\\n\\nTable of all results:')\nprint('='* 22 , '\\n')\ndisplay(results)\ndisplay(results.describe().transpose())","f526bd93":"R_list = np.linspace(2.0, 4.0, 20000)\nx0 = 0.3\nN = 1200\n\ndef logis(r):\n    x_list = [x0]    \n    for i in range(N-1):\n        x_list.append(r * x_list[-1] * (1 - x_list[-1]))\n    return x_list[200:]\n\nvariances_list = [] \nfor r in R_list:\n    variances_list.append(statistics.variance(logis(r)))\n    \nplt.style.use('seaborn-whitegrid')\nplt.figure(figsize=(16, 6), facecolor='lightgray')\nplt.xlabel('The value of R')\nplt.ylabel('The variance of the results list')\nplt.title(f'\\nThe variance of the results list\\n\\n2.0 < R < 4.0  |  x0=0.3\\n')\nplt.scatter(R_list, variances_list, color='red', s=0.5)\nplt.savefig('results_variance.png')\nplt.show()   ","9099a855":"# <span style=\"color:darkgray;\">PLAN - 1<\/span>\n\n# [Logistic Equation](https:\/\/mathworld.wolfram.com\/LogisticEquation.html)\n\nThe logistic equation (sometimes called the Verhulst model or logistic growth curve) is a model of population growth first published by Pierre Verhulst (1845, 1847). The model is continuous in time, but a modification of the continuous equation to a discrete quadratic recurrence equation known as the logistic map is also widely used.\n\n\\begin{align*}\n\\frac{d_x}{d_t}&= Rx (1 - x)\\\\\n\\\\x_{t+1}&= Rx_t (1 - x_t)\n\\end{align*}\n\nThe first few iterations of the logistic map:\n\n\\begin{align*}\nx_1&= Rx_0(1-x_0)\\\\\nx_2&= R^2(1-x_0)x_0(1-Rx_0+Rx_0^2)\\\\\nx_3&= R^3(1-x_0)x_0(1-Rx_0+Rx_0^2)\u00d7(1-R^2x_0+R^2x_0^2+R^3x_0^2-2R^3x_0^3+R^3x_0^4)\\\\\n\\end{align*}\n\n\n\nWe use the above equation a lot in this notebook and our favorite ranges for **x0** and **R** are as follows:\n\n*  The value of **x0** is between **zero** and **one**.\n\n*  The value of **R** is between **two** and **four**.\n\n* Obviously, in the above ranges, the results for the **\"new x\"** will still be between **zero** and **one**. So the next repetitions can continue and it is good for us.\n\nWhen the value of R changes between two and four, the behavior of this equation is very interesting. If R = 4, the results of this equation become chaotic, and with the slightest change in the value of x0, we see a very large change in the result. In this case, the results of this equation are practically unpredictable. In other words, a completely definite equation produces random results.\n\n","b957d5bf":"# The bifurcation diagram of the Logistic Equation \n\n* We want to change the value of R between 2 and 4 and plot all the results in one graph. (1000 different values for R)\n\n* Increase the number of iterations to 500 times. But we only draw the last hundred iterations. (The first 400 iterations are an opportunity to converge)","71fbccbc":"<div class=\"alert alert-success\">  \n<\/div>","532dce96":"<div>\n    <h2 align=\"center\">Astonishments of<\/h2> \n    <h1 align=\"center\">Logistic equation & Feigenbaum constant<\/h1>            \n    <h4 align=\"center\">By: Somayyeh Gholami & Mehran Kazeminia<\/h4>\n<\/div>","1c4f14e7":"The diagram above shows that with the first 200 iterations, convergence does not occur in many places. Even in many places, every 1,000 of our results are different. Of course, you have already noticed that, for example, when \"R = 4.0\", there is chaos, and it is obvious that every 1000 results are different. But is there chaos just because of 1,000 different results?\n\nThe fact is that, If the initial number of repetitions becomes too large (for example, one or ten million repetitions), many of these points will converge. But some of them will still have 1000 different results. In addition, we have already explained the location of the bifurcation of the main diagram, and by looking closely at the diagram above, it is clear that convergence did not occur exactly within these points.\n\n## Selected Points\n\nNext, we increase the initial iterations to ten million times, but only the bifurcated points of the equation (as well as their midpoints). We will see that the bifurcated points of the equation will still not converge. That is, for example, at the point \"R = 3.0\", which is the first bifurcation point of the equation, we will have 1000 different results, while all 1000 results for the previous points are exactly the same, and 1000 results for the next points have only two different values (Period = 2). Even if you consider the initial number of 100 million iterations for the point \"R = 3.0\", it will still not converge and 1000 different results will be obtained.\n\nOf course, the 1000 results obtained at the point \"R = 3.0\" are very little different from each other, and apparently there is no chaos like the point \"R = 4.0\". However, it is very likely that this equation is also used for very, very large numbers, and this problem should not be forgotten. For this reason, **we think this is another wonder of Logistic Equation**.\n","74122564":"<div class=\"alert alert-success\">  \n<\/div>","a5968e21":"#### If R = 2, after a few iterations, the result will be 0.5. (Fixed Point)","6e274a83":"#### If we give only a very very small change in the value of x0, the result is completely different and unpredictable.","3791dd9e":"<div class=\"alert alert-success\">  \n<\/div>","7639beeb":"<div class=\"alert alert-success\">  \n<\/div>","07266c85":"<div class=\"alert alert-success\">  \n<\/div>","2f781d1b":"## Histogram Graph","00d604c8":"# Another astonishments of the Logistic Equation\n\nThe Feigenbaum constant is very important for understanding **complex natural systems** and has many applications in various sciences. For this reason, we want to do these calculations once again with our own computer model or high accuracy. We will see that the logistic equation has **other surprises**.\n\n* For more accuracy, this time we will try 20,000 different values for R. Again, all of these values are between 2 and 4.\n\n* Increase the number of iterations to 1200 times. But we only draw the last a thousand iterations. (The first 200 iterations are an opportunity to converge)\n\n* So we have 20,000 different values for R. First we want to do a thousand iterations for the first value of R. This way, in the beginning, we get a thousand results for the value of x. Then we count the number of different types of these 1000 results. For example, if all are equal, the number 1 (Fixed Point), if there are two types of numbers, the number 2 (Period=2) or if all the results are different, the number 1000 ($Period\\rightarrow \\infty$) is the result of the calculations of this step. The calculations for the first value of R are completed and fortunately only 19999 is left :) \n\n* All 20,000 results are plotted in the diagram below.\n","f97f58d8":"#### The \"Logistics Equation\" seems extremely simple and completely deterministic. \n\n#### But as you can see, if \"R = 4.0\" the results are very random and even \"Logistic Equation\" is used to generate random numbers.","ee483eb6":"## Variance\n\nTo complete this description, we draw **the variance of all the answer lists** in a diagram. We also want to make it easy for everyone to review and compare the code of this notebook. (But if the execution speed is low, you can use Numpy or Pandas to draw this diagram, for example.)","028ae76f":"# Summary & Conclusion\n\n* The \"Logistic Equation\" seems extremely simple and completely deterministic: \n\\begin{align*}\n\\\\x_{t+1}&= Rx_t (1 - x_t)\n\\end{align*}\n\n* But for example, when R = 4, in successive iterations, all the results of this equation are different. That is, it actually generates random numbers.\n\n* When R = 4, chaos occurs. Even with the slightest change in x0, the next results are new random numbers.\n\n* \"Logistic Equation\" has many applications in the study of natural systems and especially to better understand complex natural systems. Note, of course, that \"Logistic Equation\" is not the only equation that is sometimes in  chaos, but it may be the most famous.\n\n* In this notebook, we introduced another astonishment. That is, we proved that exactly at the points of the bifurcation, all the results in successive repetitions are different, and the period is so-called infinite. Of course, the difference in numbers is not large and may not be considered complete chaos. However, if in a calculation, very large coefficients are multiplied by the results, the final results can be very different in successive iterations. This means that these small differences can cause problems.\n\n#### Good Luck.","bdd5bb1e":"#### If R = 4, the results will be chaotic. ($Period\\rightarrow \\infty$)\n","6b9ea5e9":"#### If R = 2.5, after a few iterations, the result will be 0.6. (Fixed Point)","6638b924":"#### If the value of \"R\" is between 3.55 and 3.56, after a few iterations, eight results are obtained alternately. (Period=8)","01a3ddb0":"#### If the value of \"R\" is between 3.4 and 3.5, after a few iterations, four results are obtained alternately. (Period=4)","4b6034f7":"<div class=\"alert alert-success\">  \n<\/div>","f0542011":"#### If R = 3.1, after a few iterations, two results are obtained alternately. (Period=2)","8cdb0ee3":"<div class=\"alert alert-success\">  \n<\/div>","37637b6d":"<div class=\"alert alert-success\">  \n<\/div>","d19c925e":"<div class=\"alert alert-success\">\n    <h3 align=\"center\">Chaos in the results of \"Logistic Equation\"<\/h3>\n<\/div>","02040fd1":"# <span style=\"color:darkgray;\">PLAN - 2<\/span>\n\n# [Feigenbaum Constant](https:\/\/mathworld.wolfram.com\/FeigenbaumConstant.html)\n\nThe Feigenbaum constant delta is a universal constant for functions approaching chaos via period doubling. It was discovered by Feigenbaum in 1975 (Feigenbaum 1979) while studying the fixed points of the iterated function.\n\nThe first Feigenbaum constant \u03b4 is the limiting ratio of each bifurcation interval to the next between every period doubling, of a one-parameter map.\n\n30 decimal places : **\u03b4 = 4.669201609102990671853203820466**\n\n**The results of Feigenbaum calculations, which almost correspond to the diagram above, are as follows:**"}}