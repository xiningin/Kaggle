{"cell_type":{"6fa06ae9":"code","18161d5e":"code","107b5898":"code","01ef1722":"code","ec6e53a0":"code","7949a501":"code","08e86c1d":"code","4633e2f1":"code","14050852":"code","aa469176":"code","5955e4ec":"code","07b6dccf":"code","10f0e70c":"code","2886d7e8":"code","627a1ca8":"code","729c39f0":"code","29656378":"code","138aab22":"code","1da0ccf5":"code","4ee9d307":"code","45d87b43":"code","c3e617e5":"code","a0fb0fb4":"code","bf801fc6":"code","ec354070":"code","567e6bf9":"code","9a33d167":"code","6edd100a":"code","6a0ba2fb":"code","d922ee14":"code","4f486ea2":"code","a2eab20b":"code","866c81dd":"code","f2d8d3cb":"code","3e84eb81":"code","ae4e2f88":"code","e703ad64":"code","6cc8cb56":"code","b866c89e":"code","418c7fe7":"code","075b2fd4":"code","900406af":"code","629a3f2c":"code","9b42307d":"code","f20384f6":"code","a5bd5cf2":"code","3831e19e":"code","368c2677":"code","764fb5ff":"code","7554d381":"code","7cc9fe45":"code","1020a6a3":"code","e39c6837":"code","101743e9":"code","07f6afb9":"code","a47d91fb":"code","0ea352d6":"code","6494d00e":"code","ada8ad14":"code","a55a7941":"code","62dd11bd":"code","6d579f46":"code","c3c1408e":"code","8d07fae9":"code","ec0d9c80":"code","280c48b2":"code","9a950583":"code","910948a5":"code","1c8ff5d7":"markdown","052c9bc2":"markdown","bbef0c6e":"markdown","a26fe6f5":"markdown","02f62d23":"markdown","6bc26fd4":"markdown","c65f4ec4":"markdown","afe1df39":"markdown","4f75c15b":"markdown","eca760e3":"markdown","cd1ac033":"markdown","5c2d3b95":"markdown"},"source":{"6fa06ae9":"import sys\n!git clone --quiet https:\/\/github.com\/yabhi0807\/libml1.git \/kaggle\/tmp\/fastai # This is my repo with all the fastai(updated) libraries \nsys.path.append('\/kaggle\/tmp\/fastai')\n!mkdir \/kaggle\/tmp\/data\/\n!ln -s \/kaggle\/tmp\/* \/kaggle\/working\/","18161d5e":"# This will take a minute to run\n!wget --quiet -O \/kaggle\/tmp\/fastai\/weights.tgz http:\/\/files.fast.ai\/models\/weights.tgz\n!tar xvfz \/kaggle\/tmp\/fastai\/weights.tgz -C \/kaggle\/tmp\/fastai\n!rm -rf \/kaggle\/tmp\/fastai\/weights.tgz","107b5898":"!mkdir \/kaggle\/tmp\/data\/dogbreed\n!cp -r ..\/input\/dog-breed-identification\/* \/kaggle\/tmp\/data\/dogbreed\n!ls \/kaggle\/tmp\/data\/dogbreed\/","01ef1722":"%reload_ext autoreload\n%autoreload 2\n%matplotlib inline","ec6e53a0":"from fastai.imports import *\nfrom fastai.torch_imports import *\nfrom fastai.transforms import *\nfrom fastai.conv_learner import *\nfrom fastai.model import *\nfrom fastai.dataset import *\nfrom fastai.sgdr import *\nfrom fastai.plots import *","7949a501":"# torch.cuda.set_device(0)","08e86c1d":"PATH = \"\/kaggle\/tmp\/data\/dogbreed\/\"\nsz = 224\narch = resnext101_64\nbs = 40","4633e2f1":"label_csv = f'{PATH}labels.csv'\nn = len(list(open(label_csv))) - 1 # header is not counted (-1)\nval_idxs = get_cv_idxs(n) # random 20% data for validation set","14050852":"n","aa469176":"len(val_idxs)","5955e4ec":"!ls {PATH}","07b6dccf":"label_df = pd.read_csv(label_csv)","10f0e70c":"label_df.head()","2886d7e8":"len(label_df['breed'].unique())","627a1ca8":"label_df.pivot_table(index=\"breed\", aggfunc=len).sort_values('id', ascending=False)","729c39f0":"tfms = tfms_from_model(arch, sz, aug_tfms=transforms_side_on, max_zoom=1.1)\ndata = ImageClassifierData.from_csv(PATH, 'train', f'{PATH}labels.csv', test_name='test', # we need to specify where the test set is if you want to submit to Kaggle competitions\n                                   val_idxs=val_idxs, suffix='.jpg', tfms=tfms, bs=bs)","29656378":"fn = PATH + data.trn_ds.fnames[0]; fn","138aab22":"img = PIL.Image.open(fn); img","1da0ccf5":"img.size","4ee9d307":"size_d = {k: PIL.Image.open(PATH + k).size for k in data.trn_ds.fnames}","45d87b43":"row_sz, col_sz = list(zip(*size_d.values()))","c3e617e5":"row_sz = np.array(row_sz); col_sz = np.array(col_sz)","a0fb0fb4":"row_sz[:5]","bf801fc6":"plt.hist(row_sz);","ec354070":"plt.hist(row_sz[row_sz < 1000])","567e6bf9":"plt.hist(col_sz);","9a33d167":"plt.hist(col_sz[col_sz < 1000])","6edd100a":"len(data.trn_ds), len(data.test_ds)","6a0ba2fb":"len(data.classes), data.classes[:6]","d922ee14":"def get_data(sz, bs): # sz: image size, bs: batch size\n    tfms = tfms_from_model(arch, sz, aug_tfms=transforms_side_on, max_zoom=1.1)\n    data = ImageClassifierData.from_csv(PATH, 'train', f'{PATH}labels.csv', test_name='test',\n                                       val_idxs=val_idxs, suffix='.jpg', tfms=tfms, bs=bs)\n    \n    # http:\/\/forums.fast.ai\/t\/how-to-train-on-the-full-dataset-using-imageclassifierdata-from-csv\/7761\/13\n    # http:\/\/forums.fast.ai\/t\/how-to-train-on-the-full-dataset-using-imageclassifierdata-from-csv\/7761\/37\n    return data if sz > 300 else data.resize(340, 'tmp') # Reading the jpgs and resizing is slow for big images, so resizing them all to 340 first saves time\n\n#Source:   \n#    def resize(self, targ, new_path):\n#        new_ds = []\n#        dls = [self.trn_dl,self.val_dl,self.fix_dl,self.aug_dl]\n#        if self.test_dl: dls += [self.test_dl, self.test_aug_dl]\n#        else: dls += [None,None]\n#        t = tqdm_notebook(dls)\n#        for dl in t: new_ds.append(self.resized(dl, targ, new_path))\n#        t.close()\n#        return self.__class__(new_ds[0].path, new_ds, self.bs, self.num_workers, self.classes)\n#File:      fastai\/dataset.py","4f486ea2":"data = get_data(sz, bs)","a2eab20b":"!ls \/kaggle\/tmp\/fastai\/weights\/","866c81dd":"learn = ConvLearner.pretrained(arch, data, precompute=True)","f2d8d3cb":"learn.fit(1e-2, 5)","3e84eb81":"from sklearn import metrics","ae4e2f88":"data = get_data(sz, bs)","e703ad64":"learn = ConvLearner.pretrained(arch, data, precompute=True, ps=0.5)","6cc8cb56":"learn.fit(1e-2, 2)","b866c89e":"learn.precompute = False","418c7fe7":"learn.fit(1e-2, 5, cycle_len=1)","075b2fd4":"learn.save('224_pre')","900406af":"learn.load('224_pre')","629a3f2c":"# Starting training on small images for a few epochs, then switching to bigger images, and continuing training is an amazingly effective way to avoid overfitting.\n\n# http:\/\/forums.fast.ai\/t\/planet-classification-challenge\/7824\/96\n# set_data doesn\u2019t change the model at all. It just gives it new data to train with.\nlearn.set_data(get_data(299, bs)) \nlearn.freeze()\n\n#Source:   \n#    def set_data(self, data, precompute=False):\n#        super().set_data(data)\n#        if precompute:\n#            self.unfreeze()\n#            self.save_fc1()\n#            self.freeze()\n#            self.precompute = True\n#        else:\n#            self.freeze()\n#File:      fastai\/conv_learner.py","9b42307d":"# learn.summary() # uncommnet to see the complete model summary of all layers","f20384f6":"learn.fit(1e-2, 1, cycle_len=1)","a5bd5cf2":"# When you are under fitting, it means cycle_len=1 is too short (learning rate is getting reset before it had the chance to zoom in properly).\n# learn.fit(1e-2, 3, cycle_len=1, cycle_mult=2) # 1+2+4 = 7 epochs (Uncommnet for better accuracy)","3831e19e":"log_preds, y = learn.TTA() # (5, 2044, 120), (2044,)\nprobs = np.mean(np.exp(log_preds),0)\naccuracy_np(probs, y), metrics.log_loss(y, probs)","368c2677":"len(data.val_ds.y), data.val_ds.y[:5]","764fb5ff":"learn.save('299_pre')","7554d381":"learn.load('299_pre')","7cc9fe45":"# learn.fit(1e-2, 1, cycle_len=2) # 1+1 = 2 epochs","1020a6a3":"# learn.save('299_pre')","e39c6837":"# log_preds, y = learn.TTA()\n# probs = np.mean(np.exp(log_preds),0)\n# accuracy_np(probs, y), metrics.log_loss(y, probs)","101743e9":"# data.classes","07f6afb9":"# data.test_ds.fnames","a47d91fb":"log_preds, y = learn.TTA(is_test=True) # use test dataset rather than validation dataset\nprobs = np.mean(np.exp(log_preds),0)\n#accuracy_np(probs, y), metrcs.log_loss(y, probs) # This does not make sense since test dataset has no labels","0ea352d6":"probs.shape # (n_images, n_classes)","6494d00e":"df = pd.DataFrame(probs)\ndf.columns = data.classes","ada8ad14":"df.insert(0, 'id', [o[5:-4] for o in data.test_ds.fnames])","a55a7941":"df.head()","62dd11bd":"SUBM = f'{PATH}\/subm\/'\nos.makedirs(SUBM, exist_ok=True)\ndf.to_csv(f'{SUBM}subm.gz', compression='gzip', index=False)","6d579f46":"FileLink(f'{SUBM}subm.gz')","c3c1408e":"!cp data\/dogbreed\/subm\/* .\/","8d07fae9":"fn = data.val_ds.fnames[0]\nfn","ec0d9c80":"Image.open(PATH + fn).resize((150, 150))","280c48b2":"# Method 1.\ntrn_tfms, val_tfms = tfms_from_model(arch, sz)\nds = FilesIndexArrayDataset([fn], np.array([0]), val_tfms, PATH)\ndl = DataLoader(ds)\npreds = learn.predict_dl(dl)\nnp.argmax(preds)","9a950583":"learn.data.classes[np.argmax(preds)]","910948a5":"# Method 2.\ntrn_tfms, val_tfms = tfms_from_model(arch, sz)\nim = val_tfms(open_image(PATH + fn)) # open_image() returns numpy.ndarray\npreds = learn.predict_array(im[None]) # we can only predict minbatch\nnp.argmax(preds)","1c8ff5d7":"### Download the weights","052c9bc2":"### Precompute","bbef0c6e":"Validation loss is much lower than training loss. This is a sign of underfitting. Cycle_len=1 may be too short. Let's set cycle_mult=2 to find better parameter.","a26fe6f5":"## Individual prediction","02f62d23":"# Dogs breeds","6bc26fd4":"This dataset is so similar to ImageNet dataset. Training convolution layers doesn't help much. We are not going to unfreeze.","c65f4ec4":"## Increase size","afe1df39":"## Create submission","4f75c15b":"Training loss and validation loss are getting closer and smaller. We are on right track.","eca760e3":"### Augment","cd1ac033":"## Initial exploration","5c2d3b95":"## Initial model"}}