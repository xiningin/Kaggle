{"cell_type":{"6dd11054":"code","2d089600":"code","b6069b30":"code","191d04a5":"code","e0ce0a3e":"code","4bb9bea0":"code","47288749":"code","3c97469d":"code","7a278e4e":"code","101925af":"markdown","6215ab66":"markdown","37f5270c":"markdown","9daa5f8f":"markdown","f38ba837":"markdown","dddddaf5":"markdown","d1e3516f":"markdown"},"source":{"6dd11054":"!conda install gdcm -c conda-forge -y","2d089600":"from pathlib import Path\nfrom tqdm import tqdm\nimport pydicom\nfrom pydicom.pixel_data_handlers.util import apply_voi_lut\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntrain_dir = Path('\/kaggle\/input\/siim-covid19-detection\/train')\nfilenames = sorted(train_dir.glob('**\/*.dcm'))","b6069b30":"def is_lut_available(ds):\n    '''\n    Original from pydicom\/util.py (apply_voi_lut)\n    '''\n    valid_voi = False\n    if 'VOILUTSequence' in ds:\n        ds.VOILUTSequence = cast(List[\"Dataset\"], ds.VOILUTSequence)\n        valid_voi = None not in [\n            ds.VOILUTSequence[0].get('LUTDescriptor', None),\n            ds.VOILUTSequence[0].get('LUTData', None)\n        ]\n    valid_windowing = None not in [\n        ds.get('WindowCenter', None),\n        ds.get('WindowWidth', None)\n    ]\n    return valid_voi or valid_windowing\n\nany_lut_available = False\nfor filename in tqdm(filenames):\n    dcm = pydicom.dcmread(filename, stop_before_pixels=True)\n    any_lut_available |= is_lut_available(dcm)\n\nprint('At least one lut is available.' if any_lut_available else 'There is no lut available.')","191d04a5":"N = 10\nIMAGE_SIZE = 128\n\ndef resize(img):\n    return cv2.resize(img, (IMAGE_SIZE, IMAGE_SIZE))\n\ndef read_xray(path, voi_lut = True, fix_monochrome = True):\n    # Original from: https:\/\/www.kaggle.com\/raddar\/convert-dicom-to-np-array-the-correct-way\n    dicom = pydicom.read_file(path)\n    # VOI LUT (if available by DICOM device) is used to transform raw DICOM data to \"human-friendly\" view\n    if voi_lut:\n        data = apply_voi_lut(dicom.pixel_array, dicom)\n    else:\n        data = dicom.pixel_array\n\n    # depending on this value, X-ray may look inverted - fix that:\n    if fix_monochrome and dicom.PhotometricInterpretation == \"MONOCHROME1\":\n        data = np.amax(data) - data\n        \n    data = data - np.min(data)\n    data = data \/ np.max(data)\n    data = (data * 255).astype(np.uint8)\n        \n    return data","e0ce0a3e":"imgs = np.stack([resize(read_xray(filename)) for filename in tqdm(filenames[:N**2])])\ntile = np.concatenate(np.concatenate(imgs.reshape((N, N, IMAGE_SIZE, IMAGE_SIZE)), axis=1), axis=1)\nplt.figure(figsize=(20, 20))\nplt.imshow(tile, cmap='gray')","4bb9bea0":"import seaborn as sns\ndark_bright_filenames = ['1e96d5eb4c91\/703a9f4c4ffb\/7f1924880cf8.dcm', '1e96d5eb4c91\/3928035a1e6d\/3d12cb6aad8b.dcm', '1a53a4506f10\/db8d01dc5e4f\/95bf5f4f6153.dcm', '047b450939fd\/76eb6433f31d\/cc54237ef4db.dcm']\n\nfor filename in dark_bright_filenames:\n    dcm = pydicom.dcmread(train_dir \/ filename)\n    pixel_array = dcm.pixel_array\n    print(filename)\n    print('min, max =',pixel_array.min(), pixel_array.max())\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1,2,1)\n    plt.imshow(read_xray(train_dir \/ filename), cmap='gray')\n    plt.subplot(1,2,2)\n    sns.histplot(pixel_array.ravel())\n    plt.show()\n","47288749":"def robust_read_xray(path, voi_lut = True, fix_monochrome = True):\n    # Original from: https:\/\/www.kaggle.com\/raddar\/convert-dicom-to-np-array-the-correct-way\n    dicom = pydicom.read_file(path)\n\n    # VOI LUT (if available by DICOM device) is used to transform raw DICOM data to \"human-friendly\" view\n    if voi_lut:\n        data = apply_voi_lut(dicom.pixel_array, dicom)\n    else:\n        data = dicom.pixel_array\n    \n    # depending on this value, X-ray may look inverted - fix that:\n    if fix_monochrome and dicom.PhotometricInterpretation == \"MONOCHROME1\":\n        data = np.amax(data) - data\n        \n    q1,q2,q3 = np.quantile(data, [.25,.5,.75])\n    iqr = q3 - q1\n    multiplier = 2\n    mask = ((q2 - multiplier * iqr) < data) & (data < (q2 + multiplier * iqr))\n    p = .001\n    data = data.astype(np.float32) - np.quantile(data[mask], p)\n    data = data \/ np.quantile(data[mask], 1-p)\n    data = np.clip(data, 0, 1)\n    return data","3c97469d":"imgs = np.stack([resize(robust_read_xray(filename)) for filename in tqdm(filenames[:N**2])])\ntile = np.concatenate(np.concatenate(imgs.reshape((N,N,IMAGE_SIZE, IMAGE_SIZE)), axis=1), axis=1)\nplt.figure(figsize=(20,20))\nplt.imshow(tile, cmap='gray')","7a278e4e":"for filename in dark_bright_filenames:\n    print(filename)\n    plt.subplot(1,2,1)\n    plt.imshow(read_xray(train_dir \/ filename), cmap='gray')\n    plt.title('min-max')\n    plt.subplot(1,2,2)\n    plt.imshow(robust_read_xray(train_dir \/ filename), cmap='gray')\n    plt.title('robust')\n    plt.show()","101925af":"So I can't rely on lookup tables or pre-defined windows.\n\n## Min-max normalization","6215ab66":"There maybe better method or parameters (multiplier and p in read_xray_robust) for the pixel_array normalization.","37f5270c":"## Side by side comparison","9daa5f8f":"## Is lookup table or windowing available at all?","f38ba837":"There are quite a few too dark\/bright images.\n\n## Too dark\/bright images\nI picked up some samples of too dark\/bright images for the inspection","dddddaf5":"Apparently, these images contain some outliers in pixel values.\n\n## Robust pixel_array scaling\nThe basic idea here is to exclude outlier pixels in the scaling process.","d1e3516f":"I've noticed that some of the min-max normalized images are too dark or too bright with low-contrast.  \nIn this notebook, I tried to find better method to normalize pixel_arrays."}}