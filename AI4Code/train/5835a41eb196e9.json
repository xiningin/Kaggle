{"cell_type":{"0e6dc5af":"code","622bffe1":"code","778ca3f8":"code","ac7345d9":"code","78991b6b":"code","a3fa058c":"code","dd805d03":"code","5af38953":"code","8696a83f":"code","41c09215":"code","17d45fae":"code","6495a0ef":"code","1b84c002":"code","1909cff6":"code","03cebf9e":"code","332ea276":"code","54161748":"code","fad79269":"code","e87b21e8":"code","51f8b67f":"code","fabcfb0d":"code","3fd078fb":"code","8a809cc3":"markdown","a6baf898":"markdown","22cba1e3":"markdown","a78721b3":"markdown","598c1f14":"markdown","1ba043b7":"markdown","87dd049e":"markdown","d4c20db0":"markdown","89279e1f":"markdown","c26461c9":"markdown","e8167aa3":"markdown","6efbc919":"markdown","9fcd436a":"markdown","a4d817b3":"markdown","1299a0a8":"markdown","c86c7a9e":"markdown","713ed6c7":"markdown"},"source":{"0e6dc5af":"import pandas as pd\nimport plotly.express as px\nimport math\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nimport plotly.graph_objects as go\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import LSTM, Dense, Dropout\nfrom tensorflow.keras.callbacks import ModelCheckpoint, TensorBoard\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nfrom collections import deque\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport random\nimport time\nimport os","622bffe1":"virusdata = \"\/kaggle\/input\/novel-corona-virus-2019-dataset\/2019_nCoV_data.csv\"\n","778ca3f8":"virus_data = pd.read_csv(virusdata)","ac7345d9":"virus_data","78991b6b":"import plotly.graph_objects as go\ngrouped_multiple = virus_data.groupby(['Date']).agg({'Confirmed': ['sum']})\ngrouped_multiple.columns = ['Confirmed ALL']\ngrouped_multiple = grouped_multiple.reset_index()\nfig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Confirmed ALL'],\n                         mode='lines+markers',\n                         name='Deaths',\n                         line=dict(color='orange', width=2)))\nfig.show()","a3fa058c":"china_vs_rest = virus_data.copy()\nchina_vs_rest.loc[china_vs_rest.Country == 'Mainland China', 'Country'] = \"China\"\nchina_vs_rest.loc[china_vs_rest.Country != 'China', 'Country'] = \"Not China\"\nchina_vs_rest = china_vs_rest.groupby(['Date', 'Country']).agg({'Confirmed': ['sum']})\nchina_vs_rest.columns = ['Confirmed ALL']\nchina_vs_rest = china_vs_rest.reset_index()\nfig = px.line(china_vs_rest, x=\"Date\", y=\"Confirmed ALL\", color=\"Country\",\n              line_group=\"Country\", hover_name=\"Country\")\nfig.update_layout(template='plotly_dark')\nfig.show()","dd805d03":"china_vs_rest = virus_data.copy()\nchina_vs_rest = china_vs_rest[china_vs_rest.Country != 'Mainland China']\nchina_vs_rest = china_vs_rest[china_vs_rest.Country != 'China']\nchina_vs_rest = china_vs_rest.groupby(['Date', 'Country']).agg({'Confirmed': ['sum']})\nchina_vs_rest.columns = ['Confirmed ALL']\nchina_vs_rest = china_vs_rest.reset_index()\nfig = px.line(china_vs_rest, x=\"Date\", y=\"Confirmed ALL\", color=\"Country\",\n              line_group=\"Country\", hover_name=\"Country\")\nfig.update_layout(template='plotly_dark')\nfig.show()","5af38953":"grouped_multiple = virus_data.groupby(['Date']).agg({'Deaths': ['sum'],'Recovered': ['sum']})\ngrouped_multiple.columns = ['Deaths ALL','Recovered ALL']\ngrouped_multiple = grouped_multiple.reset_index()\n\nfig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Deaths ALL'],\n                         mode='lines+markers',\n                         name='Deaths',\n                         line=dict(color='red', width=2)))\n\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Recovered ALL'],\n                         mode='lines+markers',\n                         name='Recovered',\n                         line=dict(color='green', width=2)))\nfig.show()","8696a83f":"grouped_multiple = virus_data.groupby(['Date']).agg({'Deaths': ['sum'],'Recovered': ['sum']})\ngrouped_multiple.columns = ['Deaths_ALL','Recovered_ALL']\ngrouped_multiple = grouped_multiple.reset_index()\n\ngrouped_multiple['Deaths_ALL_%'] = grouped_multiple.apply(lambda row: (row.Deaths_ALL*100)\/\/\n                                               (row.Deaths_ALL + row.Recovered_ALL) \n                                               if row.Deaths_ALL  else 0, axis=1)\n\ngrouped_multiple['Recovered_ALL_%'] = grouped_multiple.apply(lambda row: (row.Recovered_ALL*100)\/\/\n                                               (row.Deaths_ALL + row.Recovered_ALL) \n                                               if row.Deaths_ALL  else 0, axis=1)\n\n\nfig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Deaths_ALL_%'],\n                         mode='lines+markers',\n                         name='Deaths',\n                         line=dict(color='red', width=2)))\n\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Recovered_ALL_%'],\n                         mode='lines+markers',\n                         name='Recovered',\n                         line=dict(color='green', width=2)))\nfig.show()","41c09215":"grouped_multiple = virus_data.groupby(['Date']).agg({'Deaths': ['sum'],'Recovered': ['sum'], 'Confirmed': ['sum']})\ngrouped_multiple.columns = ['Deaths_ALL','Recovered_ALL', 'All']\ngrouped_multiple = grouped_multiple.reset_index()\ngrouped_multiple['Deaths_Revocered'] = grouped_multiple.apply(lambda row: row.Deaths_ALL + row.Recovered_ALL, axis=1)\n\nfig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Deaths_ALL'],\n                         mode='lines+markers',\n                         name='Deaths',\n                         line=dict(color='red', width=2)))\n\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Recovered_ALL'],\n                         mode='lines+markers',\n                         name='Recovered',\n                         line=dict(color='green', width=2)))\n\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['All'],\n                         mode='lines+markers',\n                         name='All',\n                         line=dict(color='orange', width=2)))\n\nfig.add_trace(go.Scatter(x=grouped_multiple['Date'], \n                         y=grouped_multiple['Deaths_Revocered'],\n                         mode='lines+markers',\n                         name='Deaths + Recovered',\n                         line=dict(color='white', width=2)))\n\nfig.show()","17d45fae":"grouped_multiple = virus_data.groupby(['Date']).agg({'Deaths': ['sum'],'Recovered': ['sum'], 'Confirmed': ['sum']})\ngrouped_multiple.columns = ['Deaths_ALL','Recovered_ALL', 'All']\ngrouped_multiple = grouped_multiple.reset_index()\ngrouped_multiple['Deaths_Revocered'] = grouped_multiple.apply(lambda row: row.Deaths_ALL + row.Recovered_ALL, axis=1)\ngrouped_multiple","6495a0ef":"grouped_multiple['infections_perc'] = grouped_multiple['All'].pct_change(1)\ngrouped_multiple['recovered_perc'] = grouped_multiple['Recovered_ALL'].pct_change(1)\ngrouped_multiple['death_perc'] = grouped_multiple['Deaths_ALL'].pct_change(1)\ngrouped_multiple = grouped_multiple.replace([np.inf, -np.inf], np.nan)\nmain_df=grouped_multiple.fillna(0)\nmain_df","1b84c002":"fig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=main_df['Date'], \n                         y=main_df['infections_perc'],\n                         mode='lines+markers',\n                         name='infections_perc',\n                         line=dict(color='orange', width=2)))\nfig.add_trace(go.Scatter(x=main_df['Date'], \n                         y=main_df['recovered_perc'],\n                         mode='lines+markers',\n                         name='recovered_perc',\n                         line=dict(color='green', width=2)))\nfig.add_trace(go.Scatter(x=main_df['Date'], \n                         y=main_df['death_perc'],\n                         mode='lines+markers',\n                         name='death_perc',\n                         line=dict(color='red', width=2)))\nfig.show()","1909cff6":"def IncreaseData(dflist):\n    \n    NewList=[]\n    add_this=0\n    for split_value in dflist:\n        increment_by = int((split_value-add_this)\/\/24)\n        for new_val in range(24):\n            add_this=increment_by+add_this\n            NewList.append(add_this)\n    return NewList\n\ninc_total = IncreaseData(grouped_multiple['All'])\ninc_death = IncreaseData(grouped_multiple['Deaths_ALL'])\ninc_rec = IncreaseData(grouped_multiple['Recovered_ALL'])\ndf = pd.DataFrame(list(zip(inc_total, inc_death, inc_rec)), \n               columns =['inc_total', 'inc_death', 'inc_rec']) \ndf","03cebf9e":"fig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=df.index, \n                         y=df['inc_total'],\n                         mode='lines',\n                         name='inc_total',\n                         line=dict(color='orange', width=2)))\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=df.index, \n                         y=df['inc_rec'],\n                         mode='lines',\n                         name='inc_rec',\n                         line=dict(color='green', width=2)))\nfig.add_trace(go.Scatter(x=df.index, \n                         y=df['inc_death'],\n                         mode='lines',\n                         name='inc_death',\n                         line=dict(color='red', width=2)))\n\nfig.show()","332ea276":"inc_total_perc = df['inc_total'].pct_change(1)\ninc_death_perc = df['inc_death'].pct_change(1)\ninc_rec_perc = df['inc_rec'].pct_change(1)\ndff = pd.DataFrame(list(zip(inc_total_perc, inc_death_perc, inc_rec_perc)), \n              columns =['inc_total_perc', 'inc_death_perc', 'inc_rec_perc']) \ndff=dff.replace([np.inf, -np.inf], np.nan)\ndff=dff.fillna(0)\ndff","54161748":"class TrainLSTM():\n    def create_dataset(self, dataset, look_back=1, column = 0):\n        dataX, dataY = [], []\n        for i in range(len(dataset)-look_back-1):\n            a = dataset[i:(i+look_back), column]\n            dataX.append(a)\n            dataY.append(dataset[i + look_back, column])\n        return np.array(dataX), np.array(dataY)\n\n    def TrainModel(self, dframe, column):\n        df = dframe.values\n        df = df.astype('float32')\n        train_size = int(len(df) * 0.90)\n        test_size = len(df) - train_size\n        Train, Validate = df[0:train_size,:], df[train_size:len(df),:]\n        look_back = 24\n        trainX, trainY = self.create_dataset(Train, look_back, column)\n        testX, testY = self.create_dataset(Validate, look_back, column)\n        trainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))\n        testX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))\n        model = Sequential()\n        model.add(LSTM(4, input_shape=(1, look_back)))\n        model.add(Dense(1))\n        model.compile(loss='mean_squared_error', optimizer='adam')\n        model.fit(trainX, trainY, epochs=300, batch_size=1, verbose=2)\n        self.trainPredict = model.predict(trainX)\n        self.testPredict = model.predict(testX)\n        trainScore = math.sqrt(mean_squared_error(trainY, self.trainPredict[:,0]))\n        print('Train Score: %.2f RMSE' % (trainScore))\n        testScore = math.sqrt(mean_squared_error(testY, self.testPredict[:,0]))\n        print('Test Score: %.2f RMSE' % (testScore))\n        Model_Prediciton_Resolved=[]\n        lastDT=testX[0][0]\n        print(lastDT)\n        for i in range(168):\n            predi = model.predict(np.array([[lastDT]]))\n            Model_Prediciton_Resolved.append(predi[0][0])\n            lastDT = lastDT[:-1]\n            lastDT = np.append(predi, lastDT)\n\n        return Model_Prediciton_Resolved","fad79269":"NeuralNets = TrainLSTM()\nresult_total = NeuralNets.TrainModel(dff,0)\nresult_death = NeuralNets.TrainModel(dff,1)\nresult_rec = NeuralNets.TrainModel(dff,2)","e87b21e8":"fig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=list(range(len(result_total))), \n                         y=result_total,\n                         mode='lines+markers',\n                         name='result_total',\n                         line=dict(color='orange', width=2)))\nfig.add_trace(go.Scatter(x=list(range(len(result_death))), \n                         y=result_death,\n                         mode='lines+markers',\n                         name='result_death',\n                         line=dict(color='red', width=2)))\nfig.add_trace(go.Scatter(x=list(range(len(result_rec))), \n                         y=result_rec,\n                         mode='lines+markers',\n                         name='result_rec',\n                         line=dict(color='green', width=2)))\nfig.show()","51f8b67f":"def FinalChartCalc(df,startVal):\n    finalist=[]\n    start=startVal\n    for item in df:\n        percent = start*item\n        start = start+percent\n        finalist.append(start)\n    return finalist","fabcfb0d":"growth_total = FinalChartCalc(result_total,1)\ngrowth_death =FinalChartCalc(result_death,1)\ngrowth_rec =FinalChartCalc(result_rec,1)\nfig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=list(range(len(growth_total))), \n                         y=growth_total,\n                         mode='lines+markers',\n                         name='result_total',\n                         line=dict(color='orange', width=2)))\nfig.add_trace(go.Scatter(x=list(range(len(growth_death))), \n                         y=growth_death,\n                         mode='lines+markers',\n                         name='growth_death',\n                         line=dict(color='red', width=2)))\nfig.add_trace(go.Scatter(x=list(range(len(growth_rec))), \n                         y=growth_rec,\n                         mode='lines+markers',\n                         name='growth_rec',\n                         line=dict(color='green', width=2)))\nfig.show()\n","3fd078fb":"real_total = FinalChartCalc(result_total,df['inc_total'].tail(1).values[0])\nreal_death = FinalChartCalc(result_death, df['inc_death'].tail(1).values[0])\nreal_rec = FinalChartCalc(result_rec, df['inc_rec'].tail(1).values[0])\nfig = go.Figure()\nfig.update_layout(template='plotly_dark')\nfig.add_trace(go.Scatter(x=list(range(len(real_total))), \n                         y=real_total,\n                         mode='lines+markers',\n                         name='real_total',\n                         line=dict(color='orange', width=2)))\nfig.add_trace(go.Scatter(x=list(range(len(real_rec))), \n                         y=real_rec,\n                         mode='lines+markers',\n                         name='real_rec',\n                         line=dict(color='green', width=2)))\nfig.add_trace(go.Scatter(x=list(range(len(real_death))), \n                         y=real_death,\n                         mode='lines+markers',\n                         name='real_death',\n                         line=dict(color='red', width=2)))\n\nfig.show()","8a809cc3":"# SUM ALL","a6baf898":"# LOAD dataset","22cba1e3":"# Not China infections","a78721b3":"# What are we going to predict?","598c1f14":"### All infections vs (recovery + deaths)","1ba043b7":"### Deaths and healings","87dd049e":"#show on chart","d4c20db0":"# Class for LSTM training","89279e1f":"### Confirmed infections","c26461c9":"# Growth compare next 7 days","e8167aa3":"# IMPORTS","6efbc919":"# Real values predict 7 days.","9fcd436a":"# Calculate % Returns","a4d817b3":"# % rate deaths to recovery","1299a0a8":"# Europe vs China ALL","c86c7a9e":"# Train model for total infections prediction","713ed6c7":"# Not enough data for model training!\n### Split this data for more samples"}}