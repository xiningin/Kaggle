{"cell_type":{"c6525ee1":"code","b86c7e76":"code","918d1b86":"code","9f53ddcb":"code","89294bc4":"markdown","bac028c9":"markdown"},"source":{"c6525ee1":"# import numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython import display\n\nimport sympy as sy\nfrom sympy.abc import x, y  # folosim x si y ca simboluri matematice\n\n\n# (1) calculam un \"bounding box\", care sa includa toate punctele de intersectie:\n# pentru a-l calcula este nevoie sa gasim toate punctele de intersectie:\ndef intersection_points(equations):\n    \n    #functie pentru a intersecta 2 drepte:\n    def intersect(d1, d2):\n        # d se afla rezolvand sistemul\n        a1, b1, c1 = d1\n        a2, b2, c2 = d2\n        solution = sy.solve([a1 * x + b1 * y + c1, a2 * x + b2 * y + c2], dict=True)[0]\n        if not solution[x] or not solution[y]:\n            return None\n        else:\n            return solution[x], solution[y]\n\n    points = []\n    for d1 in equations:\n        for d2 in equations:\n            intersection = None\n            if d1 != d2:\n                intersection = intersect(d1, d2)\n            if intersection is not None:\n                points.append(intersection)\n    return points\ndef bounding_box(equations):\n    intersections = intersection_points(equations)\n    first_x, first_y = intersections[0]\n    xmin, xmax = first_x, first_x\n    ymin, ymax = first_y, first_y\n    for x, y in intersections[1:]:\n        if x < xmin:\n            xmin = x\n        elif x > xmax:\n            xmax = x;\n        if y < ymin:\n            ymin = y\n        elif y > ymax:\n            ymax = y\n    return (xmin, xmax), (ymin, ymax)\n\n\n# pentru a realiza desenul de la (2)\n# Aplicatiai ecuatiei in punctul x:\ndef calc_y(equation, x):\n    a, b, c = equation\n    # if ax + by + c == 0, then y is (-c - ax) \/ b\n    y = (-c - a*x) \/ b\n    return y\n# Cream un semiplan pentru reprezentarea programului:\ndef create_semiplane(equation, xlim, ylim):\n    a, b, c = equation\n    if a == b and b == 0:\n        raise ValueError(f'Constrangerea {equation} nu are coeficienti pentru x si y!')\n    if a == 0:  # by + c == 0, deci y = -c \/ b\n        # folosim xlim care este egal cu [xmin, xmax]\n        direction = 'up' if b > 0 else 'down'\n        return (xlim, [-c \/ b, -c \/ b], direction)\n    if b == 0:  # ax + c == 0, deci x = -c \/ a\n        # folosim ylim care este egal cu [ymin, ymax]\n        direction = 'right' if a > 0 else 'left'\n        return ([-c \/ a, -c \/ a], ylim, direction)\n    # a si b sunt ambele nenegative => calculam ordonatele pt xmin, xmax\n    direction = 'up' if b > 0 else 'down'\n    return (xlim, [calc_y(equation, xlim[0]), calc_y(equation, xlim[1])], direction)\n\n# desenam semiplane hasurate:\nfrom matplotlib.patches import Polygon\ndef poligon_de_hasurat(inequation, color, hatch):\n    # inequation is ([xmin, xmax], [applied_xmin, applied_xmax], direction)\n    P1, P2, direction = inequation\n    P1, P2 = (P1[0], P2[0]), (P1[1], P2[1])\n    # hasuram din dreapta (xmin, applied_xmin)-() in directia direction:\n    puncte = [P1, P2]\n    if direction == 'right':\n        puncte.append([P2[0] + 20, P2[1]])\n        puncte.append([P1[0] + 20, P1[1]])\n    elif direction == 'left':\n        puncte.append([P2[0] - 20, P2[1]])\n        puncte.append([P1[0] - 20, P1[1]])\n    elif direction == 'up':\n        puncte.append([P2[0], P2[1] + 20])\n        puncte.append([P1[0], P1[1] + 20])\n    elif direction == 'down':\n        puncte.append([P2[0], P2[1] - 20])\n        puncte.append([P1[0], P1[1] - 20])\n    return Polygon(puncte, closed=True, fill=False, color=color, hatch=hatch)\ndef draw_semiplane(ax, semiplane, color, hatch):\n    P0 = semiplane[0]  # x0, x1\n    P1 = semiplane[1]  # y0, y1\n    ax.plot(P0, P1, linewidth=3, color=color)\n    ax.add_patch(poligon_de_hasurat(semiplane, color, hatch=hatch))\n\n    \n# (1) cream figura si calculam un bounding box pentru program\n\n# cream figura:\nfig, ax = plt.subplots(1, 1)\n\n# introducem datele:\n# Sample objective Function: Minimise 225x + 200y\nc = (225, 200)\n# Constraints: y \u2265 25; x \u2265 40; x + y \u2264 150 (*)\nconstraints = [\n    (0, 1, -25),  # triplet (a,b,c) cu a*x + b*y + c >= 0\n    (1, 0, -40),\n    (-1, -1, 150)]\n\n# Gasim un bounding box care contine toate intersectiile de puncte dintre drepte:\nbound = bounding_box(constraints)\nxlim, ylim = bound\n\n# (2) Cream un desen pentru a vizualiza toate semiplanele:\n# desenam dreptele:\nsemiplanes = [create_semiplane(c, xlim, ylim) for c in constraints]\n# print(xlim, ylim)\n# print(semiplanes)\n# adaugam o culoare si un tip de hasurare fiecarui semiplan:\ncolors, hatches = {}, {}\nall_colors = ['blue', 'orange', 'green', 'red', 'purple', 'brown', 'pink', 'gray', 'olive', 'cyan']\nall_hatches = ['-', '+', 'x', '\\\\', '*', 'o', 'O', '.', '\/', '|']\nfor i, semiplane in enumerate(semiplanes):\n    colors[i] = all_colors[i % len(all_colors)]\n    hatches[i] = all_hatches[i % len(all_hatches)]\n    \nfor i, semiplane in enumerate(semiplanes):\n    draw_semiplane(ax, semiplane, colors[i], hatches[i])\n\nintersectii = intersection_points(constraints)\n\n\nfor i in intersectii:\n    plt.scatter(i[0], i[1], marker='o', color='black', linewidth=.1, zorder=5)\n\nprint('In aceasta celula de cod am exemplificat cum se suprapun semiplanurile si cum am ales un bounding box pentru reprezentarea grafica, indiferent de datele problemei.')\nprint(f'Am obtinut urmatoarele planuri, care contin [x1, x2], [y1, y2] si directia planului: {semiplanes}')\nplt.show()\n# dupa rularea acestei celule, putem observa un exemplu de program liniar bounded,\n# adica am obtinut o regiune fezabila (care respecta conditiile necesare) finita, cuprinsa intre cele trei linii colorate si determinata de cele 3 puncte.\n#   Deoarece cele 3 semiplanuri determina o suprafata convexa finita, solutia este unul dintre varfurile acesteia\n#   Celelalte cazuri posibile sunt:\n#    * sa obtinem un fascicul de drepte, iar intersectia cu Ox sau Oy a uneia dintre drepte sa fie solutia.\n#     Acest lucru se intampla deoarece in toate programele liniare avem x \u0219i y >= 0\n#    * sa obtinem o suprafata infinita spre Ox, Oy, sau ambele. In acest caz, se poate ca maximul sau miniml sa fie nedeterminate (plus sau minus infinit),\n#     sau sa se gaseasca la intersectia a doua semiplanuri care marginesc inferior suprafata fezabila.\n\n# Pentru a rezolva complet un program, este nevoie sa calculam suprafata fezabila si sa gasim varful (daca este finita)\n# sau dreapta care intersecteaza Ox sau Oy","b86c7e76":"class FeasibleRegion(object):\n    \n    bound = None\n    xlim, ylim = None, None\n    \n    def __init__(self, objective, equations):\n        '''\n        ecuatiile sunt de tipul (a,b,c) cu ax+by+c>=0.\n        In __init__ initializam obiectul prin a transforma ecuatiile intr-un bounding box, si ecuatii de semiplane ca in celula anterioara de cod\n        '''\n        self.objective = objective\n        self.equations = equations.copy()\n        \n        # calculam bounding box-ul, \n        self.bound = bounding_box(constraints)\n        self.xlim, self.ylim = bound\n        \n        # calculam semiplanurile\n        self.semiplanes = []\n        for eq in equations:\n            self.semiplanes.append(create_semiplane(eq, xlim, ylim))\n        \n    \n    #functie care intersecteaza doua dintre ecuatiile stocate in obiect\n    def intersect_equations(self, index1, index2):\n        # creaza o lista de perechi de indici, care marcheaza care ecuatii (si semiplane, \n        #   deoarece self.equations[i] corespunde lui self.semiplanes[i]) au puncte comune\n        a1, b1, c1 = self.equations[index1]\n        a2, b2, c2 = self.equations[index2]\n        solution = sy.solve([a1 * x + b1 * y + c1, a2 * x + b2 * y + c2], dict=True)[0]\n        if not solution[x] or not solution[y]:\n            return None\n        else:\n            return solution[x], solution[y]\n    def get_all_intersections(self):\n        intersections = []\n        for i1 in range(len(self.equations)):\n            for i2 in range(i1 + 1, len(self.equations)):\n                intersection = self.intersect_equations(i1, i2)\n                if intersection:\n                    intersections.append((i1, i2, intersection))\n        return intersections\n    def is_point_feasible_for_equation(self, point, index):\n        x, y = point\n        a, b, c = self.equations[index]\n        # cazurile sunt:\n        applied = a * x + b * y + c;\n        # este pe dreapta semiplanului:\n        #   sau este in interiorul regiunei fezabile a semiplanului:\n        eps = .001\n        if abs(applied) >= eps:\n            return True\n        else:\n            return False\n    \n    def _get_looser_semiplane(self, i1, i2):\n        # equation[i1] and equations[i2] must denote parallel lines. We keep the looser constraint!\n        a1, b1, c1 = self.equations[i1]\n        a2, b2, c2 = self.equations[i2]\n        if a1 != a2 or b1 != b2:\n            return None\n        dir1 = self.semiplanes[i1][-1]\n        dir2 = self.semiplanes[i2][-1]\n        if dir1 != dir2:\n            return None\n        if a1 == 0 and b1 == 0:\n            raise ValueError(f\"Planes {self.semiplanes[i1]}, {self.semiplanes[i2]}has both x and y coeficients equal to zero\")\n        if a1 == 0: # horizontal lines\n            # b1 * y >= -c1  and  b2 * y >= -c2\n            return i1 if -c1 \/ b1 > -c2 \/ b2 else i2\n        if b1 == 0:\n            # a1 * x >= -c1  and  a2 * x >= -c2\n            return i1 if -c1 \/ a1 > -c2 \/ a2 else i2\n        # both a1 and b1 are non-zero\n        x0 = self.xlim[0]\n        y0 = (-a1 * x0 - c1) \/ b1   # a1 * x + b1 * y + c1 == 0   means that   y=(-a1 * x - c1) \/ b1\n        applied = a2 * x0 + b2 * y0 + c2\n        return i1 if applied >= 0 else i2\n            \n       \n    def compute_region(self):\n        # remove parallel semiplanes, and also the equations to keep index-correlation TODO use dicts so you don't modify in two places!\n        to_delete = []\n        for i1, plane1 in enumerate(self.semiplanes):\n            for i2, plane2 in enumerate(self.semiplanes):\n                if i1 == i2:\n                    continue\n                looser_semiplane = self._get_looser_semiplane(i1, i2)\n                if looser_semiplane:    \n                    to_delete.append(looser_semiplane)\n        for i in to_delete:\n            del self.equations[i]\n            del self.semiplanes[i]\n        # pentru a calcula regiunea, calculam toate punctele de intersectie (perechi de indici i1, i2)\n        intersections = self.get_all_intersections()\n        # remove extra points\n        index = 0\n        while index < len(intersections):\n            i, j, point = intersections[index]\n            # este punctul point in fezabil? (conform equations[i] \u0219i equations[j], este. Urmeaza testate si celelalte ecuatii)\n            is_point_feasible = True\n            for k in range(len(self.semiplanes)):\n                if i == k or j == k:\n                    continue\n                if not self.is_point_feasible_for_equation(point, k):\n                    is_point_feasible = False\n            print(point, is_point_feasible)\n            if not is_point_feasible:\n                # remove the point\n                del intersections[index]\n            else:\n                index += 1\n        print(intersections)\n        # TODO coalesce the remaining points into 1 component\n        rect = []\n        adjacent = {}\n        for i, j, _ in intersections:\n            if not adjacent.get(i):\n                adjacent[i] = [j]\n            else:\n                adjacent[i].append(j)\n        print(adjacent)\n        # start with first index:\n        i = min(list(adjacent.keys()))\n        queue = [i]\n        rectangle = [(i, None, None)]\n        print(f'Queue is {queue}')\n        while queue:\n            # for each node, find the intersecting points\n            curr = queue.pop()\n            print(f'Popped {curr}. Queue becomes {queue}.')\n            # TODO when getting the adjacent planes, start creating the rect\n            for i in adjacent.get(i, []):\n                queue.append(i)\n            print(f'Now queue is {queue}')\n            \n            \n\n# introducem datele:\n# Sample objective Function: Minimise 225x + 200y\nc = (225, 200)\n# Constraints: y \u2265 25; x \u2265 40; x + y \u2264 150 (*)\nconstraints = [\n    (0, 1, -25),  # triplet (a,b,c) cu a*x + b*y + c >= 0\n    (1, 0, -40),\n    (-1, -1, 150)]\nregion = FeasibleRegion(c, constraints)\nregion.compute_region()\n","918d1b86":"import re\n\n# Vom rezolva problema folosind aceiasi metoda ca de la examen\n\n# (1) Aducem la forma standard\nnext_s_index = 1\ndef parse_constraint(string):\n    # returneaza un triplet (a,b,c) pentru forma standard (ax+by+c>=0)\n    # variables are of type x1, x2, x3 ..\n    triples = re.findall(r'(-|\\+)?\\s*(\\d*)(\\s*\\*\\s*)?(x\\d+)', string)\n#     print(triples)\n    coefs = { triple[3]: (-1 if triple[0] == '-' else 1) * (1 if triple[1] == '' else int(triple[1])) for triple in triples }\n    sign = re.search('(>=)|(<=)|(==)|(=)', string)\n    if not sign:\n        return None\n    else:\n        rhs = re.search('\\d+', string[sign.end():])\n        sign = sign.group(0)\n    if not rhs:\n        return None\n    rhs = int(rhs.group(0))\n    # negam inegalitatea, daca partea dreapta a constrangerii este negativa\n    if rhs >= 0:\n        coefs['rhs'] = rhs\n    else:  # negam:\n        coefs = {var: -coef for var, coef in coefs.items()}\n        coefs['rhs'] = -rhs;\n    # scapam de inegalitate:\n    global next_s_index\n    if sign == '>=':  # '=' or '=='\n        coefs[f's{next_s_index}'] = 1\n        next_s_index += 1\n    elif sign == '<=':\n        coefs[f's{next_s_index}'] = -1\n        next_s_index += 1\n    return coefs\ndef parse_objective(string):\n    triples = re.findall(r'(-|\\+)?\\s*(\\d*)(\\s*\\*\\s*)?(x\\d+)', string)\n    coefs = {\n        triple[3]: (-1 if triple[0] == '-' else 1) * (1 if triple[1] == '' else int(triple[1])) for triple in triples}\n    return coefs\n\n\n# algoritmul simplex pentru minimizarea unei functii:\ndef minimize(constraints_strings, objective_string):\n    constraints = [parse_constraint(c) for c in constraints_strings]\n    objective = parse_objective(objective_string)\n\n    # print(constraints)\n    # print()\n    # print(objective)\n\n    #gasim sau adaugam variabilele pentru o baza:\n    variables = set(list(objective.keys()))\n    objective_variables = list(objective.keys())\n    basic_variables = {}\n    for i1, c1 in enumerate(constraints):\n        # verificam daca avem o variabila de baza in constrangere\n        for var in c1.keys():\n            is_basic = True\n            for i2, c2 in enumerate(constraints):\n                if i1 != i2 and c2.get(var):\n                    is_basic = False\n                    break\n            if is_basic and c1[var] == 1:\n                basic_variables[i1] = var\n        # adaugam variabilele la lista tuturor variabilelor\n        variables.update(c1.keys())\n    variables -= {'rhs'}\n    \n    for i in range(len(constraints)):\n        if not basic_variables.get(i):  # nu avem variabila de baza pt constrangere:\n            global next_s_index\n            basic_variables[i] = f's{next_s_index}'\n            constraints[i][f's{next_s_index}'] = 1  # adaugam variabila artificiala\n            objective[f's{next_s_index}'] = '-M'  # deoarece minimizam\n            next_s_index += 1\n\n    print('Am ales variabilele pentru baza:')\n    for i, constraint in enumerate(constraints):\n        print('Pentru constrangerea', constraint)\n        print('\\tam ales variabila de baza', basic_variables[i])\n    print()\n    print(f'Functia obiectiv devine {objective}')\n    \n    # adaugam constrangerea -objective + new_slack_variable = 0\n    # construim tabelul simplex:\n    \n    print()\n    print(f'Variabilele initiale are functiei obiectiv sunt {objective_variables}; Variabilele de baza sunt {list(basic_variables.values())}; Restul variabilelor sunt {variables - set(objective_variables) - set(basic_variables.values())}')\n    \n\n# exemplu cu initializari in loc de citire de la tastatura:\nlast_s_index = 1\nconstraints = [\n    ' x1 - 2*x2 + x3 >= 0',\n    '-x1        + x3 <= 3',\n    '-x1        + x3 == 5',\n]\nobjective = '22*x1 + x2 + 3*x3'\nminimize(constraints, objective)","9f53ddcb":"# !!! Ruleaza tema 3, dar cu citirea de la tastatura.\n# !!! Este nevoie rularea celulei precedente !!!\n\nprint('''HELP:\n\nIntroduceti constrangeri de urmatoarele tipuri:\n    \n     x1 - 2*x2 + x3 >= 0 (inegalitate <=)\n    -x1        + x3 <= 3 (inegalitate >=)\n           -x2 + x3 = -2 (egalitate)\n\nApoi introduceti functia obiectiv, sub acceasi forma (cu '*' pentru orice inmultire)\n''')\nnum = int(input('Numarul constrangerilor: '))\nc = []\nfor i in range(num):\n    constraint = parse_constraint(input(f'Constrangerea {i + 1}: '))\n    print(constraint)\n    c.append(constraint)\nprint(c)\nz = parse_objective(input(\"Introduceti functia obiectiv:\"))","89294bc4":"# Tema 1 - rezolvarea grafica a unui program liniar printintersectii de semiplane","bac028c9":"# Tema 3 - Simplex standard"}}