{"cell_type":{"626ff734":"code","c92b3588":"code","955b9429":"code","5623906b":"code","b1f6e0a9":"code","5fc33ecc":"code","07e02205":"code","6867cd96":"code","5eba4cdf":"code","8004f367":"code","495681a9":"code","45906b89":"code","09d02048":"code","e4f0b85a":"code","03975297":"code","53630dce":"code","09664e67":"code","0feae946":"markdown","d6d30181":"markdown","5ca77209":"markdown","6e4ac6e6":"markdown","cd38fd04":"markdown","00e3cc11":"markdown"},"source":{"626ff734":"import pathlib\n\nimport torch\nimport torch.utils.data\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport numpy as np\nimport pandas as pd\n\nimport PIL.Image\n# import albumentations.pytorch\nimport albumentations as A\nimport cv2\nimport matplotlib.pyplot as plt\n\nfrom tqdm.notebook import tqdm\nfrom typing import List, Tuple\n\nIMAGE_SIZE = 320  # (2021\/09\/24 5:00AM) Updated.\nBATCH_SIZE = 120\n\n# MODEL_FILE = pathlib.Path('..\/input\/google-landmark-2021-validation\/model.pth')\nMODEL_FILE = pathlib.Path('..\/input\/config1\/config1.pth')\nTRAIN_LABEL_FILE = pathlib.Path('train.csv')\nTRAIN_IMAGE_DIR = pathlib.Path('..\/input\/landmark-recognition-2021\/train')\nVALID_LABEL_FILE = pathlib.Path('valid.csv')\nVALID_IMAGE_DIR = pathlib.Path('..\/input\/google-landmark-2021-validation\/valid')\nTEST_LABEL_FILE = pathlib.Path('..\/input\/landmark-recognition-2021\/sample_submission.csv')\nTEST_IMAGE_DIR = pathlib.Path('..\/input\/landmark-recognition-2021\/test')\ntorch.cuda.empty_cache()","c92b3588":"train_df = pd.read_csv('..\/input\/landmark-recognition-2021\/train.csv')\n\nif len(train_df) == 1580470:# submission use all the training images\n    records = {}\n\n    for image_id, landmark_id in train_df.values:\n        if landmark_id in records:\n            records[landmark_id].append(image_id)\n        else:\n            records[landmark_id] = [image_id]\n        \n    image_ids = []\n    landmark_ids = []\n\n    for landmark_id, img_ids in records.items():\n        num = min(len(img_ids), 2)# maxium two images\n        image_ids.extend(records[landmark_id][:num])\n        landmark_ids.extend([landmark_id] * num)\n\n    train_df = pd.DataFrame({'id': image_ids, 'landmark_id': landmark_ids})\n# train_df = train_df.iloc[:512,]\ntrain_df.to_csv(TRAIN_LABEL_FILE, index=False)\ntrain_df","955b9429":"valid_df = pd.read_csv('..\/input\/google-landmark-2021-validation\/valid.csv')\nvalid_df = valid_df[valid_df['landmark_id'] == -1].reset_index(drop=True)\n# valid_df = valid_df.iloc[:512,]\nvalid_df = valid_df.iloc[:72000,]\nvalid_df.to_csv(VALID_LABEL_FILE, index=False)\nvalid_df","5623906b":"# train_df = train_df.iloc[:1024,]\n# valid_df = valid_df.iloc[:1024,]","b1f6e0a9":"aug1 = A.Compose([ A.SmallestMaxSize(512, interpolation=cv2.INTER_CUBIC),A.CenterCrop(height=448,width=448,p=1.)])\naug2 = A.Compose([ A.SmallestMaxSize(512, interpolation=cv2.INTER_CUBIC),A.CenterCrop(height=448,width=448,p=1.)])\naug4 = A.Compose([ A.LongestMaxSize(512,p=1),A.PadIfNeeded(512, 512, border_mode=cv2.BORDER_CONSTANT,p=1),A.CenterCrop(p=1.0, height=448, width=448)])\n# aug4 = A.Compose([ A.SmallestMaxSize(512, interpolation=cv2.INTER_CUBIC),A.CenterCrop(height=448,width=448,p=1.)])\naug7 = A.Compose([A.Resize(height=544,width=672,p=1.),A.CenterCrop(height=448,width=512,p=1.)])\nauglist = [aug1,aug2,aug4,aug7]","5fc33ecc":"class Dataset(torch.utils.data.Dataset):\n    def __init__(self, label_file: pathlib.Path, image_dir: pathlib.Path, aug) -> None:\n        super().__init__()\n        self.files = [\n            image_dir \/ n[0] \/ n[1] \/ n[2] \/ f'{n}.jpg'\n            for n in pd.read_csv(label_file)['id'].values]\n        \n#         self.transformer = albumentations.Compose([\n#             albumentations.SmallestMaxSize(IMAGE_SIZE, interpolation=cv2.INTER_CUBIC),\n#             albumentations.CenterCrop(IMAGE_SIZE, IMAGE_SIZE),\n#             albumentations.Normalize(),\n#             albumentations.pytorch.ToTensorV2(),\n#         ])\n        self.transformer = aug\n\n    def __len__(self) -> int:\n        return len(self.files)\n\n    def __getitem__(self, index: int) -> Tuple[str, torch.Tensor]:\n        path = self.files[index]\n        image = PIL.Image.open(self.files[index])\n#         image = self.transformer(image=np.array(image))['image']\n        \n        image = self.transformer(image=np.array(image,dtype=np.uint8))['image']\n        image = image.astype(np.float32) \n    #normalization\n        mean = np.array([123.675, 116.28 , 103.53 ], dtype=np.float32)\n        std = np.array([58.395   , 57.120, 57.375   ], dtype=np.float32)\n        image = image.astype(np.float32)\n        image -= mean\n        image *= np.reciprocal(std, dtype=np.float32)\n        \n        image = torch.from_numpy(image.transpose((2, 0, 1)))\n\n        return path.name[:-4], image","07e02205":"@torch.no_grad()\ndef get_features(\n    model: nn.Module,\n    label_file: pathlib.Path,\n    image_dir: pathlib.Path, aug\n) -> Tuple[List[str], torch.Tensor]:\n    loader = torch.utils.data.DataLoader(\n        Dataset(label_file, image_dir,aug),\n        batch_size=BATCH_SIZE, shuffle=False, num_workers=2)\n\n    model = model.cuda()\n    model.eval()\n    \n    all_names = []\n    all_features = []\n\n    for names, images in tqdm(loader, desc=image_dir.name):\n        images = images.cuda()\n        features = model(images)\n        all_features.append(features)\n        all_names.extend(names)\n\n    return all_names, F.normalize(torch.cat(all_features, dim=0))","6867cd96":"def get_similarity(model: nn.Module,aug)-> Tuple[List[str], List[str]]:\n    # features\n    train_names, train_features = get_features(\n        model, TRAIN_LABEL_FILE, TRAIN_IMAGE_DIR,aug)    \n    _, valid_features = get_features(\n        model, VALID_LABEL_FILE, VALID_IMAGE_DIR,aug)\n    test_names, test_features = get_features(\n        model, TEST_LABEL_FILE, TEST_IMAGE_DIR,aug)\n    EMBEDDING_SIZE = 512\n    # penalties\n    train_penalties_list = []\n    for i in range(0, train_features.shape[0], EMBEDDING_SIZE):\n        x = torch.mm(train_features[i:i + EMBEDDING_SIZE], valid_features.T)\n        x = torch.topk(x, k=5)[0].mean(dim=1)\n        train_penalties_list.append(x)\n    train_penalties = torch.cat(train_penalties_list, dim=0)\n\n    test_penalties_list = []\n    for i in range(0, test_features.shape[0], EMBEDDING_SIZE):\n        x = torch.mm(test_features[i:i + EMBEDDING_SIZE], valid_features.T)\n        x = torch.topk(x, k=10)[0].mean(dim=1)\n        test_penalties_list.append(x)\n    test_penalties = torch.cat(test_penalties_list, dim=0)\n\n    # neighbors\n    submit_ids = []\n    submit_landmark_ids = []\n    submit_confidences = []\n    \n    train_df = pd.read_csv(TRAIN_LABEL_FILE)\n    idmap = {n: v for n, v in train_df.values}\n\n    for i in range(0, test_features.shape[0], EMBEDDING_SIZE):\n        x = torch.mm(test_features[i:i + EMBEDDING_SIZE], train_features.T)\n        x -= train_penalties[None, :]\n        values, indexes = torch.topk(x, k=3)\n        \n        submit_ids.extend(test_names[i:i + EMBEDDING_SIZE])\n\n        for idxs, vals, penalty in zip(indexes, values, test_penalties[i:i + EMBEDDING_SIZE]):\n            scores = {}\n            for idx, val in zip(idxs, vals):\n                landmark_id = idmap[train_names[idx]]\n                if landmark_id in scores:\n                    scores[landmark_id] += float(val)\n                else:\n                    scores[landmark_id] = float(val)\n                    \n            landmark_id, confidence = max(\n                [(k, v) for k, v in scores.items()], key=lambda x: x[1])\n            submit_landmark_ids.append(landmark_id)\n            submit_confidences.append(confidence - penalty)\n\n    # standardize confidence values\n    max_conf = max(submit_confidences)\n    min_conf = min(submit_confidences)\n    submit_confidences = [\n        (v - min_conf) \/ (max_conf - min_conf) for v in submit_confidences]\n    \n    # make values for 'landmark' column\n    submit_landmarks = [\n        f'{i} {c:.8f}' for i, c in zip(submit_landmark_ids, submit_confidences)]\n    \n    return submit_ids, submit_landmarks","5eba4cdf":"@torch.no_grad()\ndef get_features_ensemble(\n    modellist,\n    label_file: pathlib.Path,\n    image_dir: pathlib.Path, auglist\n) -> Tuple[List[str], torch.Tensor]:\n\n    n = []\n    f = []\n    for idx,model in enumerate(modellist):\n        \n        loader = torch.utils.data.DataLoader(\n        Dataset(label_file, image_dir,auglist[idx]),\n        batch_size=BATCH_SIZE, shuffle=False, num_workers=2)\n        model = model.cuda()\n        model.eval()\n        all_names = []\n        all_features = []\n\n        for names, images in tqdm(loader, desc=image_dir.name):\n            images = images.cuda()\n            features = model(images).detach().cpu().numpy().astype(np.float32)\n            all_features.append(features)\n            all_names.extend(names)\n        n.append(all_names)\n#         f.append(torch.cat(all_features, dim=0))\n        f.append(np.concatenate(all_features, axis=0))\n        torch.cuda.empty_cache()\n#     return all_names, F.normalize(torch.cat(all_features, dim=0))\n    return n[0],F.normalize(torch.from_numpy(np.concatenate(f, axis=1)).to('cuda:0'))","8004f367":"def get_similarity_ensemble(modellist,auglist)-> Tuple[List[str], List[str]]:\n    # features\n    train_names, train_features = get_features_ensemble(\n        modellist, TRAIN_LABEL_FILE, TRAIN_IMAGE_DIR,auglist)    \n    _, valid_features = get_features_ensemble(\n         modellist, VALID_LABEL_FILE, VALID_IMAGE_DIR,auglist)\n    test_names, test_features = get_features_ensemble(\n        modellist, TEST_LABEL_FILE, TEST_IMAGE_DIR,auglist)\n    EMBEDDING_SIZE = 512*4\n    # penalties\n    train_penalties_list = []\n    for i in range(0, train_features.shape[0], EMBEDDING_SIZE):\n        x = torch.mm(train_features[i:i + EMBEDDING_SIZE], valid_features.T)\n        x = torch.topk(x, k=5)[0].mean(dim=1)\n        train_penalties_list.append(x)\n    train_penalties = torch.cat(train_penalties_list, dim=0)\n\n    test_penalties_list = []\n    for i in range(0, test_features.shape[0], EMBEDDING_SIZE):\n        x = torch.mm(test_features[i:i + EMBEDDING_SIZE], valid_features.T)\n        x = torch.topk(x, k=10)[0].mean(dim=1)\n        test_penalties_list.append(x)\n    test_penalties = torch.cat(test_penalties_list, dim=0)\n\n    # neighbors\n    submit_ids = []\n    submit_landmark_ids = []\n    submit_confidences = []\n    \n    train_df = pd.read_csv(TRAIN_LABEL_FILE)\n    idmap = {n: v for n, v in train_df.values}\n\n    for i in range(0, test_features.shape[0], EMBEDDING_SIZE):\n        x = torch.mm(test_features[i:i + EMBEDDING_SIZE], train_features.T)\n        x -= train_penalties[None, :]\n        values, indexes = torch.topk(x, k=3)\n        \n        submit_ids.extend(test_names[i:i + EMBEDDING_SIZE])\n\n        for idxs, vals, penalty in zip(indexes, values, test_penalties[i:i + EMBEDDING_SIZE]):\n            scores = {}\n            for idx, val in zip(idxs, vals):\n                landmark_id = idmap[train_names[idx]]\n                if landmark_id in scores:\n                    scores[landmark_id] += float(val)\n                else:\n                    scores[landmark_id] = float(val)\n                    \n            landmark_id, confidence = max(\n                [(k, v) for k, v in scores.items()], key=lambda x: x[1])\n            submit_landmark_ids.append(landmark_id)\n            submit_confidences.append(confidence - penalty)\n\n    # standardize confidence values\n    max_conf = max(submit_confidences)\n    min_conf = min(submit_confidences)\n    submit_confidences = [\n        (v - min_conf) \/ (max_conf - min_conf) for v in submit_confidences]\n    \n    # make values for 'landmark' column\n    submit_landmarks = [\n        f'{i} {c:.8f}' for i, c in zip(submit_landmark_ids, submit_confidences)]\n    \n    return submit_ids, submit_landmarks","495681a9":"import importlib\nfrom types import SimpleNamespace\nimport argparse","45906b89":"pip install ..\/input\/config1\/timm-0.4.12-py3-none-any.whl","09d02048":"#from pytorchcv.model_provider import get_model as ptcv_get_model\nimport timm\nfrom torch import nn\n\nimport math\nimport torch\nfrom torch.nn import functional as F\nfrom torch.nn.parameter import Parameter\n\nclass ArcMarginProduct(nn.Module):\n    def __init__(self, in_features, out_features):\n        super().__init__()\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.reset_parameters()\n\n    def reset_parameters(self):\n        nn.init.xavier_uniform_(self.weight)\n        # stdv = 1. \/ math.sqrt(self.weight.size(1))\n        # self.weight.data.uniform_(-stdv, stdv)\n\n    def forward(self, features):\n        cosine = F.linear(F.normalize(features), F.normalize(self.weight))\n        return cosine\n\ndef gem(x, p=3, eps=1e-6):\n    return F.avg_pool2d(x.clamp(min=eps).pow(p), (x.size(-2), x.size(-1))).pow(1.\/p)\n\nclass GeM(nn.Module):\n    def __init__(self, p=3, eps=1e-6, p_trainable=True):\n        super(GeM,self).__init__()\n        if p_trainable:\n            self.p = Parameter(torch.ones(1)*p)\n        else:\n            self.p = p\n        self.eps = eps\n\n    def forward(self, x):\n        return gem(x, p=self.p, eps=self.eps)       \n    def __repr__(self):\n        if type(self.p)==int:\n            return self.__class__.__name__ + '(' + 'p=' + '{:.4f}'.format(self.p) + ', ' + 'eps=' + str(self.eps) + ')'\n        return self.__class__.__name__ + '(' + 'p=' + '{:.4f}'.format(self.p.data.tolist()[0]) + ', ' + 'eps=' + str(self.eps) + ')'\n\n    \nclass Backbone(nn.Module):\n\n    \n    def __init__(self, name='resnet18', pretrained=True,checkpoint_path=''):\n        super(Backbone, self).__init__()\n\n        self.net = timm.create_model(name, pretrained=pretrained,checkpoint_path=checkpoint_path)\n        \n        if 'regnet' in name:\n            self.out_features = self.net.head.fc.in_features\n        elif 'csp' in name:\n            self.out_features = self.net.head.fc.in_features\n        elif 'res' in name: #works also for resnest\n            self.out_features = self.net.fc.in_features\n        elif 'efficientnet' in name:\n            self.out_features = self.net.classifier.in_features\n        elif 'densenet' in name:\n            self.out_features = self.net.classifier.in_features\n        elif 'senet' in name:\n            self.out_features = self.net.fc.in_features\n        elif 'inception' in name:\n            self.out_features = self.net.last_linear.in_features\n\n        else:\n            self.out_features = self.net.classifier.in_features\n\n    def forward(self, x):\n        x = self.net.forward_features(x)\n\n        return x\n\n    \nclass Net(nn.Module):\n    def __init__(self, args, pretrained=False):\n        super(Net, self).__init__()\n        \n        self.args = args\n        self.backbone = Backbone(args.backbone, pretrained=pretrained,checkpoint_path=args.checkpoint_path)\n        \n        if args.pool == \"gem\":\n            self.global_pool = GeM(p_trainable=args.p_trainable)\n        elif args.pool == \"identity\":\n            self.global_pool = torch.nn.Identity()\n        else:\n            self.global_pool = nn.AdaptiveAvgPool2d(1)\n\n        self.embedding_size = args.embedding_size        \n        \n        # https:\/\/www.groundai.com\/project\/arcface-additive-angular-margin-loss-for-deep-face-recognition\n        if args.neck == \"option-D\":\n            self.neck = nn.Sequential(\n                nn.Linear(self.backbone.out_features, self.embedding_size, bias=True),\n                nn.BatchNorm1d(self.embedding_size),\n                torch.nn.PReLU()\n            )\n        elif args.neck == \"option-F\":\n            self.neck = nn.Sequential(\n                nn.Dropout(0.3),\n                nn.Linear(self.backbone.out_features, self.embedding_size, bias=True),\n                nn.BatchNorm1d(self.embedding_size),\n                torch.nn.PReLU()\n            )\n        else:\n            self.neck = nn.Sequential(\n                nn.Linear(self.backbone.out_features, self.embedding_size, bias=False),\n                nn.BatchNorm1d(self.embedding_size),\n            )\n            \n        self.head = ArcMarginProduct(self.embedding_size, args.n_classes)\n        \n        if args.pretrained_weights is not None:\n            self.load_state_dict(torch.load(args.pretrained_weights, map_location='cpu'), strict=False)\n            print('weights loaded from',args.pretrained_weights)\n\n    # def forward(self, input_dict, get_embeddings=False, get_attentions=False):\n\n    #     x = input_dict['input']\n    #     # print(\"input\",x)\n    #     x = self.backbone(x)\n    #     # print(\"after backbone\",x)\n    #     x = self.global_pool(x)\n    #     x = x[:,:,0,0]\n    #     # print(\"after pool\",x)\n    #     x = self.neck(x)\n    #     # print(\"embedding\",x)\n    #     logits = self.head(x)\n        \n    #     if get_embeddings:\n    #         return {'logits': logits, 'embeddings': x}\n    #     else:\n    #         return {'logits': logits}\n    \n    def forward(self, image):\n\n        x = image\n        x = self.backbone(x)\n        x = self.global_pool(x)\n        x = x[:,:,0,0]\n        x = self.neck(x)\n    \n        return x","e4f0b85a":"modelnames=['config1','config2','config4','config7']\nmodellist = []\nfor name in modelnames:\n    MODEL_PATH = pathlib.Path(\"..\/input\/config1\/\"+f\"{name}.pth\")\n    m = torch.load(str(MODEL_PATH))\n    modellist.append(m)","03975297":"submit_ids, submit_landmarks = get_similarity_ensemble(modellist,auglist)\nsubmit_df = pd.DataFrame({'id': submit_ids, 'landmarks': submit_landmarks})\nsubmit_df.to_csv('submission.csv', index=False)","53630dce":"# model = torch.load(str(MODEL_FILE))\n\n# submit_ids, submit_landmarks = get_similarity(model,aug1)\n# submit_df = pd.DataFrame({'id': submit_ids, 'landmarks': submit_landmarks})\n# submit_df.to_csv('submission.csv', index=False)","09664e67":"submit_df = pd.read_csv('submission.csv')\nsubmit_df['landmark_id'] = submit_df['landmarks'].apply(lambda x: int(x.split()[0]))\nsubmit_df['confidence'] = submit_df['landmarks'].apply(lambda x: float(x.split()[1]))\ntrain_df = pd.read_csv(TRAIN_LABEL_FILE)\n\ndef get_image(path, name):\n    img = PIL.Image.open(path \/ name[0] \/ name[1] \/ name[2] \/ f'{name}.jpg')\n    if img.width > img.height:\n        img = img.resize((256, round(img.height \/ img.width * 256)))\n        new_img = PIL.Image.new(img.mode, (256, 256), (0, 0, 0))\n        new_img.paste(img, (0, (256 - img.height) \/\/ 2))\n    else:\n        img = img.resize((round(img.width \/ img.height * 256), 256))\n        new_img = PIL.Image.new(img.mode, (256, 256), (0, 0, 0))\n        new_img.paste(img, ((256 - img.width) \/\/ 2, 2))\n    return np.array(new_img)\n\nrows = 10\nfig = plt.figure(figsize=(15, 4 * rows))\nfor r in range(rows):\n    for c in range(3):\n        i = r * 3 + c\n        test_name, _, label, conf = submit_df.iloc[i].values\n        test_image = get_image(TEST_IMAGE_DIR, test_name)\n        train_name = train_df.query(f'landmark_id == {label}').iloc[0]['id']\n        train_image = get_image(TRAIN_IMAGE_DIR, train_name)\n        image = np.concatenate([test_image, train_image], axis=1)\n    \n        ax = fig.add_subplot(rows, 3, i + 1)        \n        ax.set_title(f'Label={label}, Confidence={conf:.2f}')\n        ax.axis('off')\n        ax.imshow(image)\nfig.tight_layout()","0feae946":"### Check the submission\n\nFollowing code shows the inference results. Each figure shows a test image (LEFT), the estimated landmark image (RIGHT), landmark ID and confidence (TITLE).","d6d30181":"### List of non-landmark images\n(This code is added at 2021\/09\/20 1:00AM GMT)","5ca77209":"### Elimination of public training images\n(This code is updated at 2021\/09\/24 5:00AM GMT)\n\nIn order to reduce the processing time, only a subset of public training images are used for the feature extraction at saving the code.\nAt the submission, all private trainig images are used.","6e4ac6e6":"### Class and Functions for feature extraction","cd38fd04":"# Similarity-based Inference and submission code\n\n[Ver.6] FIX BUG: Label file `valid.csv` which is used as a list of non-landmark images has contained landmark image files. The landmark entries are removed from `valid.csv` (2021\/09\/20 1:00AM GMT).  \n[Ver.9] UPDATE: All private training images are used for the feature extraction (2021\/09\/24 5:00AM GMT).  \n[Ver.9] UPDATE: Input image size is changed to 320x320 (2021\/09\/24 5:00AM GMT).  \n[Ver.10] UPDATE: Label file `valid.csv` is updated (2021\/09\/24 6:40AM GMT).\n\n### What is this code?\n\nThis code estimates landmark IDs and confidences based on feature similarity. The features are extracted from train, validation and test images by using a inference model that has a ResNet-34 as the backbone CNN. The train images includes only landmark images, but validation images includes many non-landmark images. A confidence of a test image is calculated from the similarity with landmark images, and a penalty is derived from the similarity with non-landmark images.\n\nThe estimation algorithm is the same as in the following paper:\n\nSupporting large-scale image recognition with out-of-domain samples  \nChristof Henkel, Philipp Singer  \nhttps:\/\/arxiv.org\/abs\/2010.01650\n\n### ~~Notice~~\n\n~~Because of making this as a published code, this implementation compromises on the performance as follows:~~\n\n~~1. Only 311,511 training images are used in order to reduce processing time. If all training images are used, the performance will be better. Image features can be saved as feature files by feature extraction of training and validation images before inference. If the feature files are created before inference, features of all training images can be used in a short processing time.~~  \n~~2. Because of processing time reduction, input image size is small (224x224). It is well known that bigger input images improves the performance.~~","00e3cc11":"### Inference and Submission"}}