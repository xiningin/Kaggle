{"cell_type":{"d356b640":"code","d0139f9f":"code","033387c4":"code","ef977cbe":"code","b0a6b23e":"code","7fd14a1f":"code","f74d3d64":"code","18f391b8":"code","f877881b":"code","6ba0416e":"code","4d8ee624":"code","c690e562":"code","026f63d2":"code","830ee986":"code","12472db0":"code","a57a5096":"code","56d16a53":"code","264aa3a3":"code","3d2a5e91":"code","f7aa49a6":"code","ef62f7fe":"code","c5f14320":"code","d7daf04e":"code","fed1fcfd":"code","aa33d6d0":"code","b2052cdd":"code","054a080f":"code","54ece6dd":"code","495e5ed2":"code","ca8b23b4":"code","eb28432e":"code","5b7d674d":"code","3bbba368":"code","a67cc3f0":"code","69c4c6ad":"code","dbae7e68":"code","a6108d40":"code","07c6d513":"code","6eb411b6":"code","4b121084":"markdown","88bc77f0":"markdown","55c9bfe9":"markdown","13d241e1":"markdown","b3d890c3":"markdown","4cd81cb5":"markdown","f31a4281":"markdown","ee10499b":"markdown","2f357497":"markdown","fcb5ae91":"markdown","dad15e95":"markdown","56235b72":"markdown","d2c6049c":"markdown","0c86b47b":"markdown","0222fd7b":"markdown","0d2e6193":"markdown","c52c2692":"markdown","324e15aa":"markdown","b374c55e":"markdown","933a5eeb":"markdown","9562eb50":"markdown","0b08b89b":"markdown","c4909890":"markdown","ffc0494a":"markdown","16975025":"markdown","3c549e36":"markdown","88287651":"markdown","21624860":"markdown","dde6b49b":"markdown","d0ea862b":"markdown","0d03eb6d":"markdown","57bb31e1":"markdown","8213f2af":"markdown","d6659a7d":"markdown","fbcf2137":"markdown","9c2d66a7":"markdown","d76f994b":"markdown","c637d0f6":"markdown","c899fc8b":"markdown","7ced8cd9":"markdown","403f85b0":"markdown","625f5084":"markdown","c9659d45":"markdown","eff2ce5e":"markdown","e8753bff":"markdown","43c3d802":"markdown","7f8c88bf":"markdown","a1203287":"markdown","c7ab5a2d":"markdown","b2fcfa10":"markdown","2a09a2a0":"markdown","3ef3e17a":"markdown","cabf9b85":"markdown","8093ce7d":"markdown","85357b21":"markdown","b6473058":"markdown","9b01616c":"markdown"},"source":{"d356b640":"from IPython import display\ndisplay.Image(\"https:\/\/raw.githubusercontent.com\/Masterx-AI\/Project_Ad_Budget_Estimation_\/main\/0-ad1%20(1).jpg\")","d0139f9f":"#Importing the basic librarires\n\nimport math\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom IPython.display import display\n\n#from brokenaxes import brokenaxes\nfrom statsmodels.formula import api\nfrom sklearn.feature_selection import RFE\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom statsmodels.stats.outliers_influence import variance_inflation_factor\n\nfrom sklearn.decomposition import PCA\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error\n\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [10,6]\n\nimport warnings \nwarnings.filterwarnings('ignore')","033387c4":"#Importing the dataset\n\ndf = pd.read_csv('..\/input\/advertising-sales-dataset\/Advertising Budget and Sales.csv', index_col=0, names=['TV','Radio','Newspaper','Sales'], skiprows=1)\n\n#df.drop([''], axis=1, inplace=True)\ndisplay(df.head())\n\ntarget = 'Sales'\nfeatures = [i for i in df.columns if i not in [target]]\n\noriginal_df = df.copy(deep=True)\n\nprint('\\n\\033[1mInference:\\033[0m The Datset consists of {} features & {} samples.'.format(df.shape[1], df.shape[0]))","ef977cbe":"#Checking the dtypes of all the columns\n\ndf.info()","b0a6b23e":"#Checking number of unique rows in each feature\n\ndf.nunique().sort_values()","7fd14a1f":"#Checking number of unique rows in each feature\n\nnu = df[features].nunique().sort_values()\nnf = []; cf = []; nnf = 0; ncf = 0; #numerical & categorical features\n\nfor i in range(df[features].shape[1]):\n    if nu.values[i]<=16:cf.append(nu.index[i])\n    else: nf.append(nu.index[i])\n\nprint('\\n\\033[1mInference:\\033[0m The Datset has {} numerical & {} categorical features.'.format(len(nf),len(cf)))","f74d3d64":"#Checking the stats of all the columns\n\ndisplay(df.describe())","18f391b8":"#Let us first analyze the distribution of the target variable\n\nplt.figure(figsize=[8,4])\nsns.distplot(df[target], color='g',hist_kws=dict(edgecolor=\"black\", linewidth=2), bins=30)\nplt.title('Target Variable Distribution - Median Value of Homes ($1Ms)')\nplt.show()","f877881b":"#Visualising the categorical features \n\nprint('\\033[1mVisualising Categorical Features:'.center(100))\n\nn=3\nplt.figure(figsize=[15,3*math.ceil(len(cf)\/n)])\n\nfor i in range(len(cf)):\n    if df[cf[i]].nunique()<=8:\n        plt.subplot(math.ceil(len(cf)\/n),n,i+1)\n        sns.countplot(df[cf[i]])\n    else:\n        plt.subplot(3,1,i-3)\n        sns.countplot(df[cf[i]])\n        \nplt.tight_layout()\nplt.show()","6ba0416e":"#Visualising the numeric features \n\nprint('\\033[1mNumeric Features Distribution'.center(130))\n\nn=3\n\nplt.figure(figsize=[15,3*math.ceil(len(nf)\/n)])\nfor i in range(len(nf)):\n    plt.subplot(math.ceil(len(nf)\/3),n,i+1)\n    sns.distplot(df[nf[i]],hist_kws=dict(edgecolor=\"black\", linewidth=2), bins=10, color=list(np.random.randint([255,255,255])\/255))\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=[15,3*math.ceil(len(nf)\/n)])\nfor i in range(len(nf)):\n    plt.subplot(math.ceil(len(nf)\/3),n,i+1)\n    df.boxplot(nf[i])\nplt.tight_layout()\nplt.show()","4d8ee624":"#Understanding the relationship between all the features\n\ng = sns.pairplot(df)\nplt.title('Pairplots for all the Feature')\ng.map_upper(sns.kdeplot, levels=4, color=\".2\")\nplt.show()","c690e562":"#Removal of any Duplicate rows (if any)\n\ncounter = 0\nrs,cs = original_df.shape\n\ndf.drop_duplicates(inplace=True)\n\nif df.shape==(rs,cs):\n    print('\\n\\033[1mInference:\\033[0m The dataset doesn\\'t have any duplicates')\nelse:\n    print(f'\\n\\033[1mInference:\\033[0m Number of duplicates dropped\/fixed ---> {rs-df.shape[0]}')","026f63d2":"#Check for empty elements\n\nnvc = pd.DataFrame(df.isnull().sum().sort_values(), columns=['Total Null Values'])\nnvc['Percentage'] = round(nvc['Total Null Values']\/df.shape[0],3)*100\nprint(nvc)","830ee986":"#Converting categorical Columns to Numeric\n\ndf1 = df.copy()\ndf3 = df1.copy()\n\n# ecc = nvc[nvc['Percentage']!=0].index.values\n# fcc = [i for i in cf if i not in ecc]\n# #One-Hot Binay Encoding\n# oh=True\n# dm=True\n# for i in fcc:\n#     #print(i)\n#     if df3[i].nunique()==2:\n#         if oh==True: print(\"\\033[1mOne-Hot Encoding on features:\\033[0m\")\n#         print(i);oh=False\n#         df3[i]=pd.get_dummies(df3[i], drop_first=True, prefix=str(i))\n#     if (df3[i].nunique()>2 and df3[i].nunique()<17):\n#         if dm==True: print(\"\\n\\033[1mDummy Encoding on features:\\033[0m\")\n#         print(i);dm=False\n#         df3 = pd.concat([df3.drop([i], axis=1), pd.DataFrame(pd.get_dummies(df3[i], drop_first=True, prefix=str(i)))],axis=1)\n        \n# df3.shape","12472db0":"# for x in [i for i in ecc if i in cf]:\n#     a = df3[x]\n#     b=[]; c=[]\n\n#     df4 = df3.copy()\n#     df4.drop(ecc, axis=1, inplace=True)\n#     df4\n\n#     for i,e in enumerate(a):\n#         if e!=e:\n#             b.append(i)\n#         else:\n#             c.append(i)\n\n#     RF = RandomForestClassifier()\n#     RF.fit(df4.loc[c],a[c])\n#     d = RF.predict(df4.loc[b])\n\n#     f=0\n#     for i,e in enumerate(df3[x]):\n#         if e!=e:\n#             df3.loc[i,x] = d[f]\n#             f+=1\n# df1 = df3.copy()\n# df1","a57a5096":"# #Converting categorical Columns to Numeric\n\n# df3 = df.copy()\n\n# gcc = nvc[nvc['Percentage']!=0].index.values\n# hcc = [i for i in cf if i not in gcc]\n\n# #One-Hot Binay Encoding\n# oh=True\n# dm=True\n# for i in hcc:\n#     #print(i)\n#     if df3[i].nunique()==2:\n#         if oh==True: print(\"\\033[1mOne-Hot Encoding on features:\\033[0m\")\n#         print(i);oh=False\n#         df3[i]=pd.get_dummies(df3[i], drop_first=True, prefix=str(i))\n#     if (df3[i].nunique()>2 and df3[i].nunique()<17):\n#         if dm==True: print(\"\\n\\033[1mDummy Encoding on features:\\033[0m\")\n#         print(i);dm=False\n#         df3 = pd.concat([df3.drop([i], axis=1), pd.DataFrame(pd.get_dummies(df3[i], drop_first=True, prefix=str(i)))],axis=1)\n# df3.shape","56d16a53":"# for x in gcc:\n#     a = df3[x]\n#     b=[]; c=[]\n\n#     df4 = df3.copy()\n#     df4.drop([x], axis=1, inplace=True)\n    \n#     for i,e in enumerate(a):\n#         if e!=e:\n#             b.append(i)\n#         else:\n#             c.append(i)\n        \n#     LR = LinearRegression()\n#     LR.fit(df4.loc[c],a[c])\n#     d = LR.predict(df4.loc[b])\n        \n#     f=0\n#     for i,e in enumerate(df3[x]):\n#         if e!=e:\n#             df3.loc[i,x] = d[f]\n#             f+=1\n# df3","264aa3a3":"#Removal of outlier:\n\ndf1 = df3.copy()\n\n#features1 = [i for i in features if i not in ['CHAS','RAD']]\nfeatures1 = nf\n\nfor i in features1:\n    Q1 = df1[i].quantile(0.25)\n    Q3 = df1[i].quantile(0.75)\n    IQR = Q3 - Q1\n    df1 = df1[df1[i] <= (Q3+(1.5*IQR))]\n    df1 = df1[df1[i] >= (Q1-(1.5*IQR))]\n    df1 = df1.reset_index(drop=True)\ndisplay(df1.head())\nprint('\\n\\033[1mInference:\\033[0m\\nBefore removal of outliers, The dataset had {} samples.'.format(df3.shape[0]))\nprint('After removal of outliers, The dataset now has {} samples.'.format(df1.shape[0]))","3d2a5e91":"#Final Dataset size after performing Preprocessing\n\ndf = df1.copy()\ndf.columns=[i.replace('-','_') for i in df.columns]\n\nplt.title('Final Dataset')\nplt.pie([df.shape[0], original_df.shape[0]-df.shape[0]], radius = 1, labels=['Retained','Dropped'], counterclock=False, \n        autopct='%1.1f%%', pctdistance=0.9, explode=[0,0], shadow=True)\nplt.pie([df.shape[0]], labels=['100%'], labeldistance=-0, radius=0.78)\nplt.show()\n\nprint(f'\\n\\033[1mInference:\\033[0m After the cleanup process, {original_df.shape[0]-df.shape[0]} samples were dropped, \\\nwhile retaining {round(100 - (df.shape[0]*100\/(original_df.shape[0])),2)}% of the data.')","f7aa49a6":"#Splitting the data intro training & testing sets\n\nm=[]\nfor i in df.columns.values:\n    m.append(i.replace(' ','_'))\n    \ndf.columns = m\nX = df.drop([target],axis=1)\nY = df[target]\nTrain_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y, train_size=0.8, test_size=0.2, random_state=100)\nTrain_X.reset_index(drop=True,inplace=True)\n\nprint('Original set  ---> ',X.shape,Y.shape,'\\nTraining set  ---> ',Train_X.shape,Train_Y.shape,'\\nTesting set   ---> ', Test_X.shape,'', Test_Y.shape)","ef62f7fe":"#Feature Scaling (Standardization)\n\nstd = StandardScaler()\n\nprint('\\033[1mStandardardization on Training set'.center(120))\nTrain_X_std = std.fit_transform(Train_X)\nTrain_X_std = pd.DataFrame(Train_X_std, columns=X.columns)\ndisplay(Train_X_std.describe())\n\nprint('\\n','\\033[1mStandardardization on Testing set'.center(120))\nTest_X_std = std.transform(Test_X)\nTest_X_std = pd.DataFrame(Test_X_std, columns=X.columns)\ndisplay(Test_X_std.describe())","c5f14320":"#Checking the correlation\n\nprint('\\033[1mCorrelation Matrix'.center(55))\nplt.figure(figsize=[8,5])\nsns.heatmap(df.corr(), annot=True, vmin=-1, vmax=1, center=0) #cmap='BuGn'\nplt.show()","d7daf04e":"#Testing a Linear Regression model with statsmodels\n\nTrain_xy = pd.concat([Train_X_std,Train_Y.reset_index(drop=True)],axis=1)\na = Train_xy.columns.values\n\nAPI = api.ols(formula='{} ~ {}'.format(target,' + '.join(i for i in Train_X.columns)), data=Train_xy).fit()\n#print(API.conf_int())\n#print(API.pvalues)\nAPI.summary()","fed1fcfd":"from sklearn.preprocessing import PolynomialFeatures\nTrr=[]; Tss=[]; n=3\norder=['ord-'+str(i) for i in range(2,n)]\n#Trd = pd.DataFrame(np.zeros((10,n-2)), columns=order)\n#Tsd = pd.DataFrame(np.zeros((10,n-2)), columns=order)\n\nDROP=[];b=[]\n\nfor i in range(len(Train_X_std.columns)):\n    vif = pd.DataFrame()\n    X = Train_X_std.drop(DROP,axis=1)\n    vif['Features'] = X.columns\n    vif['VIF'] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]\n    vif['VIF'] = round(vif['VIF'], 2)\n    vif = vif.sort_values(by = \"VIF\", ascending = False)\n    vif.reset_index(drop=True, inplace=True)\n    if vif.loc[0][1]>1:\n        DROP.append(vif.loc[0][0])\n        LR = LinearRegression()\n        LR.fit(Train_X_std.drop(DROP,axis=1), Train_Y)\n\n        pred1 = LR.predict(Train_X_std.drop(DROP,axis=1))\n        pred2 = LR.predict(Test_X_std.drop(DROP,axis=1))\n        \n        Trr.append(np.sqrt(mean_squared_error(Train_Y, pred1)))\n        Tss.append(np.sqrt(mean_squared_error(Test_Y, pred2)))\n\n        #Trd.loc[i,'ord-'+str(k)] = round(np.sqrt(mean_squared_error(Train_Y, pred1)),2)\n        #Tsd.loc[i,'ord-'+str(k)] = round(np.sqrt(mean_squared_error(Test_Y, pred2)),2)\n        \nprint('Dropped Features --> ',DROP)\n#plt.plot(b)\n#plt.show()\n#print(API.summary())\n\n# plt.figure(figsize=[20,4])\n# plt.subplot(1,3,1)\n# sns.heatmap(Trd.loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max())\n# plt.title('Train RMSE')\n# plt.subplot(1,3,2)\n# sns.heatmap(Tsd.loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max()+10)\n# plt.title('Test RMSE')\n# plt.subplot(1,3,3)\n# sns.heatmap((Trd+Tsd).loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max()+25)\n# plt.title('Total RMSE')\n# plt.show()\n\nplt.plot(Trr, label='Train RMSE')\nplt.plot(Tss, label='Test RMSE')\n#plt.ylim([19.75,20.75])\nplt.legend()\nplt.grid()\nplt.show()","aa33d6d0":"from sklearn.preprocessing import PolynomialFeatures\nTrr=[]; Tss=[]; n=3\norder=['ord-'+str(i) for i in range(2,n)]\nTrd = pd.DataFrame(np.zeros((10,n-2)), columns=order)\nTsd = pd.DataFrame(np.zeros((10,n-2)), columns=order)\n\nm=df.shape[1]-2\nfor i in range(m):\n    lm = LinearRegression()\n    #lm.fit(Train_X_std, Train_Y)\n\n    rfe = RFE(lm,n_features_to_select=Train_X_std.shape[1]-i)             # running RFE\n    rfe = rfe.fit(Train_X_std, Train_Y)\n    \n    #print(Train_X_std.shape[1]-i)\n\n    #Train_xy = pd.concat([Train_X_std[Train_X.columns[rfe.support_]],Train_Y.reset_index(drop=True)],axis=1)\n    #a = Train_xy.columns.values.tolist()\n    #a.remove(target)\n\n    #API = api.ols(formula='{} ~ {}'.format(target,' + '.join(i for i in a)), data=Train_xy).fit()\n    #DROP.append(vif.loc[0][0])\n    LR = LinearRegression()\n    LR.fit(Train_X_std.loc[:,rfe.support_], Train_Y)\n    \n    #print(Train_X_std.loc[:,rfe.support_].columns)\n\n    pred1 = LR.predict(Train_X_std.loc[:,rfe.support_])\n    pred2 = LR.predict(Test_X_std.loc[:,rfe.support_])\n\n    Trr.append(np.sqrt(mean_squared_error(Train_Y, pred1)))\n    Tss.append(np.sqrt(mean_squared_error(Test_Y, pred2)))\n\n# plt.figure(figsize=[20,4])\n# plt.subplot(1,3,1)\n# sns.heatmap(Trd.loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max())\n# plt.title('Train RMSE')\n# plt.subplot(1,3,2)\n# sns.heatmap(Tsd.loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max()+10)\n# plt.title('Test RMSE')\n# plt.subplot(1,3,3)\n# sns.heatmap((Trd+Tsd).loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max()+25)\n# plt.title('Total RMSE')\n# plt.show()\n\nplt.plot(Trr, label='Train RMSE')\nplt.plot(Tss, label='Test RMSE')\n#plt.ylim([19.75,20.75])\nplt.legend()\nplt.grid()\nplt.show()","b2052cdd":"from sklearn.decomposition import PCA\n\npca = PCA().fit(Train_X_std)\n\nfig, ax = plt.subplots(figsize=(8,6))\nx_values = range(1, pca.n_components_+1)\nax.bar(x_values, pca.explained_variance_ratio_, lw=2, label='Explained Variance')\nax.plot(x_values, np.cumsum(pca.explained_variance_ratio_), lw=2, label='Cumulative Explained Variance', color='red')\nplt.plot([0,pca.n_components_+1],[0.9,0.9],'g--')\nax.set_title('Explained variance of components')\nax.set_xlabel('Principal Component')\nax.set_ylabel('Explained Variance')\nplt.legend()\nplt.grid()\nplt.show()","054a080f":"from sklearn.decomposition import PCA\nfrom sklearn.preprocessing import PolynomialFeatures\nTrr=[]; Tss=[]; n=3\norder=['ord-'+str(i) for i in range(2,n)]\nTrd = pd.DataFrame(np.zeros((10,n-2)), columns=order)\nTsd = pd.DataFrame(np.zeros((10,n-2)), columns=order)\nm=df.shape[1]-1\n\nfor i in range(m):\n    pca = PCA(n_components=Train_X_std.shape[1]-i)\n    Train_X_std_pca = pca.fit_transform(Train_X_std)\n    Test_X_std_pca = pca.fit_transform(Test_X_std)\n    \n    LR = LinearRegression()\n    LR.fit(Train_X_std_pca, Train_Y)\n\n    pred1 = LR.predict(Train_X_std_pca)\n    pred2 = LR.predict(Test_X_std_pca)\n\n    Trr.append(round(np.sqrt(mean_squared_error(Train_Y, pred1)),2))\n    Tss.append(round(np.sqrt(mean_squared_error(Test_Y, pred2)),2))\n\n# plt.figure(figsize=[20,4.5])\n# plt.subplot(1,3,1)\n# sns.heatmap(Trd.loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max())\n# plt.title('Train RMSE')\n# plt.subplot(1,3,2)\n# sns.heatmap(Tsd.loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max()+10)\n# plt.title('Test RMSE')\n# plt.subplot(1,3,3)\n# sns.heatmap((Trd+Tsd).loc[:6], cmap='BuGn', annot=True, vmin=0, vmax=Trd.max().max()+25)\n# plt.title('Total RMSE')\n# plt.show()\n\nplt.plot(Trr, label='Train RMSE')\nplt.plot(Tss, label='Test RMSE')\n#plt.ylim([19.5,20.75])\nplt.legend()\nplt.grid()\nplt.show()","54ece6dd":"# #Shortlisting the selected Features (with RFE)\n\n# lm = LinearRegression()\n# rfe = RFE(lm,n_features_to_select=2)             # running RFE\n# rfe = rfe.fit(Train_X_std, Train_Y)\n\n# LR = LinearRegression()\n# LR.fit(Train_X_std.loc[:,rfe.support_], Train_Y)\n\n# #print(Train_X_std.loc[:,rfe.support_].columns)\n\n# pred1 = LR.predict(Train_X_std.loc[:,rfe.support_])\n# pred2 = LR.predict(Test_X_std.loc[:,rfe.support_])\n\n# print(mean_squared_error(Train_Y, pred1))\n# print(mean_squared_error(Test_Y, pred2))\n\n# Train_X_std = Train_X_std.loc[:,rfe.support_]\n# Test_X_std = Test_X_std.loc[:,rfe.support_]","495e5ed2":"#Let us first define a function to evaluate our models\n\nModel_Evaluation_Comparison_Matrix = pd.DataFrame(np.zeros([5,8]), columns=['Train-R2','Test-R2','Train-RSS','Test-RSS',\n                                                                            'Train-MSE','Test-MSE','Train-RMSE','Test-RMSE'])\nrc=np.random.choice(Train_X_std.columns,2)\ndef Evaluate(n, pred1,pred2):\n    #Plotting predicted predicteds alongside the actual datapoints \n    plt.figure(figsize=[15,6])\n    for e,i in enumerate(rc):\n        plt.subplot(2,3,e+1)\n        plt.scatter(y=Train_Y, x=Train_X_std[i], label='Actual')\n        plt.scatter(y=pred1, x=Train_X_std[i], label='Prediction')\n        plt.legend()\n    plt.show()\n\n    #Evaluating the Multiple Linear Regression Model\n\n    print('\\n\\n{}Training Set Metrics{}'.format('-'*20, '-'*20))\n    print('\\nR2-Score on Training set --->',round(r2_score(Train_Y, pred1),20))\n    print('Residual Sum of Squares (RSS) on Training set  --->',round(np.sum(np.square(Train_Y-pred1)),20))\n    print('Mean Squared Error (MSE) on Training set       --->',round(mean_squared_error(Train_Y, pred1),20))\n    print('Root Mean Squared Error (RMSE) on Training set --->',round(np.sqrt(mean_squared_error(Train_Y, pred1)),20))\n\n    print('\\n{}Testing Set Metrics{}'.format('-'*20, '-'*20))\n    print('\\nR2-Score on Testing set --->',round(r2_score(Test_Y, pred2),20))\n    print('Residual Sum of Squares (RSS) on Training set  --->',round(np.sum(np.square(Test_Y-pred2)),20))\n    print('Mean Squared Error (MSE) on Training set       --->',round(mean_squared_error(Test_Y, pred2),20))\n    print('Root Mean Squared Error (RMSE) on Training set --->',round(np.sqrt(mean_squared_error(Test_Y, pred2)),20))\n    print('\\n{}Residual Plots{}'.format('-'*20, '-'*20))\n    \n    Model_Evaluation_Comparison_Matrix.loc[n,'Train-R2']  = round(r2_score(Train_Y, pred1),20)\n    Model_Evaluation_Comparison_Matrix.loc[n,'Test-R2']   = round(r2_score(Test_Y, pred2),20)\n    Model_Evaluation_Comparison_Matrix.loc[n,'Train-RSS'] = round(np.sum(np.square(Train_Y-pred1)),20)\n    Model_Evaluation_Comparison_Matrix.loc[n,'Test-RSS']  = round(np.sum(np.square(Test_Y-pred2)),20)\n    Model_Evaluation_Comparison_Matrix.loc[n,'Train-MSE'] = round(mean_squared_error(Train_Y, pred1),20)\n    Model_Evaluation_Comparison_Matrix.loc[n,'Test-MSE']  = round(mean_squared_error(Test_Y, pred2),20)\n    Model_Evaluation_Comparison_Matrix.loc[n,'Train-RMSE']= round(np.sqrt(mean_squared_error(Train_Y, pred1)),20)\n    Model_Evaluation_Comparison_Matrix.loc[n,'Test-RMSE'] = round(np.sqrt(mean_squared_error(Test_Y, pred2)),20)\n\n    # Plotting y_test and y_pred to understand the spread.\n    plt.figure(figsize=[15,4])\n\n    plt.subplot(1,2,1)\n    sns.distplot((Train_Y - pred1))\n    plt.title('Error Terms')          \n    plt.xlabel('Errors') \n\n    plt.subplot(1,2,2)\n    plt.scatter(Train_Y,pred1)\n    plt.plot([Train_Y.min(),Train_Y.max()],[Train_Y.min(),Train_Y.max()], 'r--')\n    plt.title('Test vs Prediction')         \n    plt.xlabel('y_test')                       \n    plt.ylabel('y_pred')                       \n    plt.show()","ca8b23b4":"#Linear Regression\n\nMLR = LinearRegression().fit(Train_X_std,Train_Y)\npred1 = MLR.predict(Train_X_std)\npred2 = MLR.predict(Test_X_std)\n\nprint('{}{}\\033[1m Evaluating Multiple Linear Regression Model \\033[0m{}{}\\n'.format('<'*3,'-'*20,'-'*20,'>'*3))\nprint('The Coeffecient of the Regresion Model was found to be ',MLR.coef_)\nprint('The Intercept of the Regresion Model was found to be ',MLR.intercept_)\n\nEvaluate(0, pred1, pred2)","eb28432e":"#Creating a Ridge Regression model\n\nRLR = Ridge().fit(Train_X_std,Train_Y)\npred1 = RLR.predict(Train_X_std)\npred2 = RLR.predict(Test_X_std)\n\nprint('{}{}\\033[1m Evaluating Ridge Regression Model \\033[0m{}{}\\n'.format('<'*3,'-'*20,'-'*20,'>'*3))\nprint('The Coeffecient of the Regresion Model was found to be ',MLR.coef_)\nprint('The Intercept of the Regresion Model was found to be ',MLR.intercept_)\n\nEvaluate(1, pred1, pred2)","5b7d674d":"#Creating a Ridge Regression model\n\nLLR = Lasso().fit(Train_X_std,Train_Y)\npred1 = LLR.predict(Train_X_std)\npred2 = LLR.predict(Test_X_std)\n\nprint('{}{}\\033[1m Evaluating Lasso Regression Model \\033[0m{}{}\\n'.format('<'*3,'-'*20,'-'*20,'>'*3))\nprint('The Coeffecient of the Regresion Model was found to be ',MLR.coef_)\nprint('The Intercept of the Regresion Model was found to be ',MLR.intercept_)\n\nEvaluate(2, pred1, pred2)","3bbba368":"#Creating a ElasticNet Regression model\n\nENR = ElasticNet().fit(Train_X_std,Train_Y)\npred1 = ENR.predict(Train_X_std)\npred2 = ENR.predict(Test_X_std)\n\nprint('{}{}\\033[1m Evaluating Elastic-Net Regression Model \\033[0m{}{}\\n'.format('<'*3,'-'*20,'-'*20,'>'*3))\nprint('The Coeffecient of the Regresion Model was found to be ',MLR.coef_)\nprint('The Intercept of the Regresion Model was found to be ',MLR.intercept_)\n\nEvaluate(3, pred1, pred2)","a67cc3f0":"#Checking polynomial regression performance on various degrees\n\nTrr=[]; Tss=[]\nn_degree=6\n\nfor i in range(2,n_degree):\n    #print(f'{i} Degree')\n    poly_reg = PolynomialFeatures(degree=i)\n    X_poly = poly_reg.fit_transform(Train_X_std)\n    X_poly1 = poly_reg.fit_transform(Test_X_std)\n    LR = LinearRegression()\n    LR.fit(X_poly, Train_Y)\n    \n    pred1 = LR.predict(X_poly)\n    Trr.append(np.sqrt(mean_squared_error(Train_Y, pred1)))\n    \n    pred2 = LR.predict(X_poly1)\n    Tss.append(np.sqrt(mean_squared_error(Test_Y, pred2)))\n\nplt.figure(figsize=[15,6])\nplt.subplot(1,2,1)\nplt.plot(range(2,n_degree),Trr, label='Training')\nplt.plot(range(2,n_degree),Tss, label='Testing')\n#plt.plot([1,4],[1,4],'b--')\nplt.title('Polynomial Regression Fit')\n#plt.ylim([0,5])\nplt.xlabel('Degree')\nplt.ylabel('RMSE')\nplt.grid()\nplt.legend()\n#plt.xticks()\n\nplt.subplot(1,2,2)\nplt.plot(range(2,n_degree),Trr, label='Training')\nplt.plot(range(2,n_degree),Tss, label='Testing')\nplt.title('Polynomial Regression Fit')\nplt.ylim([0.25,1])\nplt.xlabel('Degree')\nplt.ylabel('RMSE')\nplt.grid()\nplt.legend()\n#plt.xticks()\nplt.show()","69c4c6ad":"#Using the 2rd Order Polynomial Regression model (degree=3)\n\npoly_reg = PolynomialFeatures(degree=2)\nX_poly = poly_reg.fit_transform(Train_X_std)\nX_poly1 = poly_reg.fit_transform(Test_X_std)\nPR = LinearRegression()\nPR.fit(X_poly, Train_Y)\n\npred1 = PR.predict(X_poly)\npred2 = PR.predict(X_poly1)\n\nprint('{}{}\\033[1m Evaluating Polynomial Regression Model \\033[0m{}{}\\n'.format('<'*3,'-'*20,'-'*20,'>'*3))\nprint('The Coeffecient of the Regresion Model was found to be ',MLR.coef_)\nprint('The Intercept of the Regresion Model was found to be ',MLR.intercept_)\n\nEvaluate(4, pred1, pred2)","dbae7e68":"# Regression Models Results Evaluation\n\nEMC = Model_Evaluation_Comparison_Matrix.copy()\nEMC.index = ['Multiple Linear Regression (MLR)','Ridge Linear Regression (RLR)','Lasso Linear Regression (LLR)','Elastic-Net Regression (ENR)','Polynomial Regression (PNR)']\nEMC","a6108d40":"# R2-Scores Comparison for different Regression Models\n\nR2 = round(EMC['Train-R2'].sort_values(ascending=True),4)\nplt.hlines(y=R2.index, xmin=0, xmax=R2.values)\nplt.plot(R2.values, R2.index,'o')\nplt.title('R2-Scores Comparison for various Regression Models')\nplt.xlabel('R2-Score')\n#plt.ylabel('Regression Models')\nfor i, v in enumerate(R2):\n    plt.text(v+0.02, i-0.05, str(v*100), color='blue')\nplt.xlim([0,1.1])\nplt.show()","07c6d513":"# Root Mean SquaredError Comparison for different Regression Models\n\ncc = Model_Evaluation_Comparison_Matrix.columns.values\ns=5\n#baxes = brokenaxes(ylims=((0,4),(524,532)))\n#baxes.bar(np.arange(s), Model_Evaluation_Comparison_Matrix[cc[-2]].values, width=0.3, label='RMSE (Training)')\n#baxes.bar(np.arange(s)+0.3, Model_Evaluation_Comparison_Matrix[cc[-1]].values, width=0.3, label='RMSE (Testing)')\n# for index, value in enumerate(Model_Evaluation_Comparison_Matrix[cc[-2]].values):\n#     plt.text(round(value,2), index, str(round(value,2)))\n# for index, value in enumerate(Model_Evaluation_Comparison_Matrix[cc[-1]].values):\n#     plt.text(round(value,2), index, str(round(value,2)))\nplt.bar(np.arange(5), Model_Evaluation_Comparison_Matrix[cc[6]].values, width=0.3, label='RMSE (Training)')\nplt.bar(np.arange(5)+0.3, Model_Evaluation_Comparison_Matrix[cc[7]].values, width=0.3, label='RMSE (Testing)')\nplt.xticks(np.arange(5),EMC.index, rotation =35)\nplt.legend()\n#plt.ylim([0,10])\nplt.show()","6eb411b6":"#<<<--------------------------------------------THE END------------------------------------------------>>>","4b121084":"<img src=\"lasso.png\" style=\"width: 500px;float: left;\"\/>","88bc77f0":"# <center> Stractegic Plan of Action:","55c9bfe9":"**We aim to solve the problem statement by creating a plan of action, Here are some of the necessary steps:**\n1. Data Exploration\n2. Exploratory Data Analysis (EDA)\n3. Data Pre-processing\n4. Data Manipulation\n5. Feature Selection\/Extraction\n6. Predictive Modelling\n7. Project Outcomes & Conclusion","13d241e1":"## 5a. Manual Method - VIF","b3d890c3":"## 6c. Lasso Regression Model","4cd81cb5":"---","f31a4281":"# <center>1. Data Exploration","ee10499b":"## 6a. Multiple Linear Regression(MLR)","2f357497":"### Description:\nThe advertising dataset captures the sales revenue generated with respect to advertisement costs across multiple channels like radio, tv, and newspapers. \n\nIt is required to understand the impact of ad budgets on the overall sales.\n\n### Acknowledgement: \nThe dataset is taken from Kaggle\n\n### Objective:\n- Understand the Dataset & cleanup (if required).\n- Build Regression models to predict the sales w.r.t a single & multiple features.\n- Also evaluate the models & compare their respective scores like R2, RMSE, etc.","fcb5ae91":"# <center> 5. Feature Selection\/Extraction","dad15e95":"**Inference:** There seem to be some outliers. let us fix these in the upcoming section...","56235b72":"---","d2c6049c":"## 6d. Elastic-Net Regression","0c86b47b":"---","0222fd7b":"**Inference:**The Target Variable seems to be be normally distributed, averaging around $12(units)","0d2e6193":"<img src=\"mr.png\" style=\"width: 600px;float: left;\"\/>","c52c2692":"---","324e15aa":"**Approach:** \nWe can fix these multicollinearity with two techniques:\n1. Manual Method - Variance Inflation Factor (VIF)\n2. Automatic Method - Recursive Feature Elimination (RFE)\n3. Feature Elmination using PCA Decomposition","b374c55e":"---","933a5eeb":"**Inference:** We can notice that some features have linear relationship, let us futher analyze the detect multicollinearity.","9562eb50":"# <center> 6. Predictive Modelling","0b08b89b":" ---","c4909890":"---","ffc0494a":"**Inference:** There are no categorical features in the dataset.","16975025":"## 6b. Ridge Regression Model","3c549e36":"---","88287651":"# <center> 4. Data Manipulation","21624860":"---","dde6b49b":"**Inference:** The stats seem to be fine, let us do further analysis on the Dataset","d0ea862b":"---","0d03eb6d":"---","57bb31e1":"---","8213f2af":"**Inference:**\\\nLesser the RMSE, better the model! Also, provided the model should have close proximity with the training & testing scores. For this problem, it is can be said that polynomial regressions are the best choice to go with.","d6659a7d":"### Here are some of the key outcomes of the project:\n- The Dataset was quiet small with just 200 samples & after preprocessing 1% of the datasamples were dropped. \n- Visualising the distribution of data & their relationships, helped us to get some insights on the feature-set.\n- The features had high multicollinearity, hence in Feature Extraction step, we shortlisted the appropriate features with VIF Technique.\n- Testing multiple algorithms with default hyperparamters gave us some understanding for various models performance on this specific dataset.\n- While, Polynomial Regression (Order-2) was the best choise, yet it is safe to use multiple regression algorithm, as their scores were quiet comparable & also they're more generalisable.","fbcf2137":"<img src=\"ridge.png\" style=\"width: 500px;float: left;\"\/>","9c2d66a7":"**Inference:** We can choose 2nd order polynomial regression as it gives the optimal training & testing scores...","d76f994b":"---","c637d0f6":"## 6e. Polynomial Regression Model","c899fc8b":"---","7ced8cd9":"# <center> 3. Data Preprocessing","403f85b0":"## 5b. Automatic Method - RFE","625f5084":"# <center> 2. Exploratory Data Analysis (EDA)","c9659d45":"# <center> 7. Project Outcomes & Conclusions","eff2ce5e":"<img src=\"en.png\" style=\"width: 500px;float: left;\"\/>","e8753bff":"**Inference:** The datset doesn't have any inconsistant values.","43c3d802":"---","7f8c88bf":"<img src=\"pn.png\" style=\"width: 500px;float: left;\"\/>","a1203287":"#### Inference:\nIt can be seen that the performance of the modelsis quiet comparable unpon dropping features using VIF, RFE & PCA Techniques. Comparing the RMSE plots, the optimal values were found for dropping most  features using manual RFE Technique.","c7ab5a2d":"**Inference:** From the above plot, it is clear that the polynomial regresion models have the highest explainability power  to understand the dataset.","b2fcfa10":"---","2a09a2a0":"---","3ef3e17a":"**Inference:** There seems to be strong multi-correlation between the features. Let us try to fix these...","cabf9b85":"### 6f. Comparing the Evaluation Metics of the Models","8093ce7d":"---","85357b21":"**Objective:** Let us now try building multiple regression models & compare their evaluation metrics to choose the best fit model both training and testing sets...","b6473058":"# <center> \u2605 Machine Learning Project - Ad Budget Estimation \u2605\n#### <center> ***Domain: Marketing***","9b01616c":"## 5c. Feature Elmination using PCA Decomposition"}}