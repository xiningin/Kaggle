{"cell_type":{"61b0b12d":"code","8dab6420":"code","75a08dac":"code","f8ded8fb":"code","42587287":"code","4d366464":"code","3d6706d4":"code","560a5d1e":"code","9e577e23":"code","2fbd65aa":"code","8bc7eaaf":"markdown","0e2d810a":"markdown"},"source":{"61b0b12d":"import os\nimport numpy as np \nimport pandas as pd\nimport cv2\nimport skimage.io\nfrom skimage.transform import resize, rescale\n\nfrom multiprocessing import Pool\n\nfrom tqdm.notebook import tqdm\nimport matplotlib.pyplot as plot","8dab6420":"# https:\/\/www.kaggle.com\/c\/prostate-cancer-grade-assessment\/discussion\/145618\ndef crop_white(image: np.ndarray) -> np.ndarray:\n    assert image.shape[2] == 3\n    assert image.dtype == np.uint8\n    ys, = (image.min((1, 2)) != 255).nonzero()\n    xs, = (image.min(0).min(1) != 255).nonzero()\n    if len(xs) == 0 or len(ys) == 0:\n        return image\n    return image[ys.min():ys.max() + 1, xs.min():xs.max() + 1]","75a08dac":"def crop_white_with_mask(image: np.ndarray, mask: np.ndarray) -> (np.ndarray, np.ndarray):\n    assert image.shape[2] == 3\n    assert image.dtype == np.uint8\n    ys, = (image.min((1, 2)) != 255).nonzero()\n    xs, = (image.min(0).min(1) != 255).nonzero()\n    if len(xs) == 0 or len(ys) == 0:\n        return image, mask\n    return image[ys.min():ys.max() + 1, xs.min():xs.max() + 1], mask[ys.min():ys.max() + 1, xs.min():xs.max() + 1]","f8ded8fb":"train_labels = pd.read_csv('\/kaggle\/input\/prostate-cancer-grade-assessment\/train.csv')","42587287":"train_labels.head()","4d366464":"data_dir = '\/kaggle\/input\/prostate-cancer-grade-assessment\/train_images\/'\nmask_dir = '\/kaggle\/input\/prostate-cancer-grade-assessment\/train_label_masks\/'","3d6706d4":"save_dir = \"\/kaggle\/train_images\/\"\nsave_mask_dir = '\/kaggle\/train_label_masks\/'\nos.makedirs(save_dir, exist_ok=True)\nos.makedirs(save_mask_dir, exist_ok=True)","560a5d1e":"#for img_id in train_labels.image_id:\ndef crop_white_save(img_id):\n    load_path = data_dir + img_id + '.tiff'\n    save_path = save_dir + img_id + '.png'\n    load_path_mask = mask_dir + img_id + '_mask.tiff'\n    save_path_mask = save_mask_dir + img_id + '_mask.png'\n    \n    biopsy = skimage.io.MultiImage(load_path)\n    if os.path.exists(load_path_mask):\n        biopsy_mask = skimage.io.MultiImage(load_path_mask)\n        # out = cv2.resize(biopsy[-1], (biopsy[-1].shape[1] \/\/ 4, biopsy[-1].shape[0] \/\/ 4))\n        out, mask_out = crop_white_with_mask(biopsy[-1],biopsy_mask[-1])\n        cv2.imwrite(save_path, out)\n        cv2.imwrite(save_path_mask, mask_out)\n        return 1\n    else:\n        out = crop_white(biopsy[-1])\n        cv2.imwrite(save_path, out)\n        return 0","9e577e23":"with Pool(processes=4) as pool:\n    has_mask = list(\n        tqdm(pool.imap(crop_white_save, list(train_labels.image_id)), total = len(train_labels.image_id))\n    )\nprint('%d \/ %d has mask.'%(sum(has_mask),len(has_mask)))","2fbd65aa":"!tar -czf train_images.tar.gz ..\/train_images\/*.png\n!tar -czf train_label_masks.tar.gz ..\/train_label_masks\/*.png","8bc7eaaf":"## Start here","0e2d810a":"## Load dataframe"}}