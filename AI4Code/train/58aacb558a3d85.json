{"cell_type":{"2f35d0aa":"code","daf4b0bd":"code","cabd8664":"code","1fb68416":"code","2c9f45aa":"code","fbbe1e9a":"code","b5c11eba":"code","ba59b951":"code","417fca06":"code","5668b3fa":"code","3c7ac7a3":"code","3f017116":"code","91006339":"code","31be49b5":"code","8687a95e":"code","6a3f58f6":"code","49726f37":"code","3c4ca910":"code","546d7854":"code","778fbdd9":"code","8d071ced":"code","24e815de":"code","aa7e167b":"code","bb4d6d54":"code","c213e694":"code","0a4e47f2":"code","f813bad7":"code","796010a4":"code","2d0c5e28":"code","bf91f244":"code","e7914192":"code","5c682a5d":"code","ae932b5d":"code","405053b1":"code","3548733c":"markdown","0f18b136":"markdown","fcc983a4":"markdown","14616b99":"markdown","0765ac3a":"markdown","43516cf3":"markdown","29a59f87":"markdown","c3092b6a":"markdown","35ab621f":"markdown","48333ed0":"markdown","db65e5e4":"markdown","cd642064":"markdown"},"source":{"2f35d0aa":"conda install basemap","daf4b0bd":"%matplotlib inline\nfrom enum import Enum\nimport imageio\nfrom IPython.display import HTML\nfrom itertools import chain\nimport math\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport numpy as np\nimport os\nimport pandas as pd\nfrom PIL import Image\nfrom random import *\nfrom sklearn.cluster import KMeans\nfrom statistics import mean","cabd8664":"def draw_map(m, scale=1.5):\n    # draw a shaded-relief image\n    m.shadedrelief(scale=scale)\n    \n    #latitudes and longitudes are returned as a dictionary\n    lats = m.drawparallels(np.linspace(-90, 90, 13))\n    lons = m.drawmeridians(np.linspace(-180, 180, 13))\n    \n    #keys contain the plt.Line2D instances\n    lat_lines = chain(*(tup[1][0] for tup in lats.items()))\n    lon_lines = chain(*(tup[1][0] for tup in lons.items()))\n    all_lines = chain(lat_lines, lon_lines)\n    \n    # cycle through these lines and set the desired style\n    for line in all_lines:\n        line.set(linestyle='-', alpha=0.3, color='w')","1fb68416":"data=pd.read_csv('..\/input\/glodapv2-ocean-data\/GLODAPv2 Merged Master File.csv')\ndata","2c9f45aa":"\nz_list=list(data[\"phtsinsitutp\"])\nzeta = list(data[\"tco2\"])\nx_lis=list(data[\"longitude\"])\ny_lis=list(data[\"latitude\"])\ninput_data={'phtsinsituetp':z_list,'tco2':zeta,'longitude':x_lis,'latitude':y_lis}","fbbe1e9a":"data=''\nfor i in range(0,15259):\n    data += str(str(input_data['longitude'][i])+\" \"+str(input_data['latitude'][i])+\"; \")\nunused=np.array(np.mat(data[:-2]))\ntco2 = np.array(input_data['tco2'])","b5c11eba":"model = KMeans(n_clusters=381)\nmodel.fit(unused)","ba59b951":"model.cluster_centers_","417fca06":"label=np.array(model.labels_)","5668b3fa":"sse = []\nfor K in range(100, 1000, 100):\n    model = KMeans(n_clusters=K)\n    model.fit(unused)\n    sse.append(model.inertia_)","3c7ac7a3":"plt.plot(range(100, 1000, 100), sse)","3f017116":"fig = plt.figure(figsize=(8, 6), edgecolor='w')\nm = Basemap(projection='moll', lon_0=0, lat_0=0)\nu_labels = np.unique(label)\nm.drawmapboundary(fill_color='#76a6cc')\nm.fillcontinents(color='white',lake_color='#76a6cc')\nm.drawcoastlines()\n\n#plotting the results:\nfor i in u_labels:\n    x, y = m(unused[label == i , 0] , unused[label == i , 1])\n    m.scatter(x, y , label = i)\nplt.show()","91006339":"set = randint(0,381)","31be49b5":"\nfig = plt.figure(figsize=(8, 6), edgecolor='w')\nm = Basemap(projection='moll', lon_0=0, lat_0=0)\nm.drawmapboundary(fill_color='#76a6cc')\nm.fillcontinents(color='white',lake_color='#76a6cc')\nm.drawcoastlines()\nx, y = m(unused[label==set, 0], unused[label==set, 1])\nm.scatter(x, y, marker='o', color=\"r\")\n\n\nplt.savefig('plot.png')\nplt.show()","8687a95e":"show_animation = True","6a3f58f6":"class RobotType(Enum):\n    circle = 0\n    rectangle = 1","49726f37":"class Config:\n\n\n    def __init__(self):\n        # robot parameter\n        self.max_speed = 2.0 # [m\/s]\n        self.min_speed = -2.0  # [m\/s]\n        self.max_yaw_rate = 40.0 * math.pi \/ 180.0  # [rad\/s]\n        self.max_accel = 0.2  # [m\/ss]\n        self.max_delta_yaw_rate = 40.0 * math.pi \/ 180.0  # [rad\/ss]\n        self.v_resolution = 0.01  # [m\/s]\n        self.yaw_rate_resolution = 0.1 * math.pi \/ 180.0  # [rad\/s]\n        self.dt = 0.1  # [s] Time tick for motion prediction\n        self.predict_time = 3.0  # [s]\n        self.to_goal_cost_gain = 0.15\n        self.speed_cost_gain = 1.0\n        self.obstacle_cost_gain = 1.0\n        self.robot_stuck_flag_cons = 0.05  # constant to prevent the robot from getting stuck\n        self.robot_type = RobotType.circle\n\n        # if robot_type == RobotType.circle\n        # Also used to check if goal is reached in both types\n        self.robot_radius = 10.0  # [m] for collision check\n\n        # if robot_type == RobotType.rectangle\n        self.robot_width = 0.5  # [m] for collision check\n        self.robot_length = 1.2  # [m] for collision check\n        # obstacles [x(m) y(m), ....]\n        self.ob = np.column_stack((np.random.randint(-180,high=180, size=50), np.random.randint(-90,high=90, size=50)))\n\n\n    @property\n    def robot_type(self):\n        return self._robot_type\n\n    @robot_type.setter\n    def robot_type(self, value):\n        if not isinstance(value, RobotType):\n            raise TypeError(\"robot_type must be an instance of RobotType\")\n        self._robot_type = value\n\n\nconfig = Config()","3c4ca910":"def dwa_control(x, config, goal, ob):\n\n    dw = calc_dynamic_window(x, config)\n\n    u, trajectory = calc_control_and_trajectory(x, dw, config, goal, ob)\n\n    return u, trajectory","546d7854":"def motion(x, u, dt):\n\n\n    x[2] += u[1] * dt\n    x[0] += u[0] * math.cos(x[2]) * dt\n    x[1] += u[0] * math.sin(x[2]) * dt\n    x[3] = u[0]\n    x[4] = u[1]\n\n    return x","778fbdd9":"def calc_dynamic_window(x, config):\n\n\n    # Dynamic window from robot specification\n    Vs = [config.min_speed, config.max_speed,\n          -config.max_yaw_rate, config.max_yaw_rate]\n\n    # Dynamic window from motion model\n    Vd = [x[3] - config.max_accel * config.dt,\n          x[3] + config.max_accel * config.dt,\n          x[4] - config.max_delta_yaw_rate * config.dt,\n          x[4] + config.max_delta_yaw_rate * config.dt]\n\n    #  [v_min, v_max, yaw_rate_min, yaw_rate_max]\n    dw = [max(Vs[0], Vd[0]), min(Vs[1], Vd[1]),\n          max(Vs[2], Vd[2]), min(Vs[3], Vd[3])]\n\n    return dw","8d071ced":"def predict_trajectory(x_init, v, y, config):\n\n\n    x = np.array(x_init)\n    trajectory = np.array(x)\n    time = 0\n    while time <= config.predict_time:\n        x = motion(x, [v, y], config.dt)\n        trajectory = np.vstack((trajectory, x))\n        time += config.dt\n\n    return trajectory","24e815de":"def calc_control_and_trajectory(x, dw, config, goal, ob):\n    x_init = x[:]\n    min_cost = float(\"inf\")\n    best_u = [0.0, 0.0]\n    best_trajectory = np.array([x])\n\n    # evaluate all trajectory with sampled input in dynamic window\n    for v in np.arange(dw[0], dw[1], config.v_resolution):\n        for y in np.arange(dw[2], dw[3], config.yaw_rate_resolution):\n\n            trajectory = predict_trajectory(x_init, v, y, config)\n            # calc cost\n            to_goal_cost = config.to_goal_cost_gain * calc_to_goal_cost(trajectory, goal)\n            speed_cost = config.speed_cost_gain * (config.max_speed - trajectory[-1, 3])\n            ob_cost = config.obstacle_cost_gain * calc_obstacle_cost(trajectory, ob, config)\n\n            final_cost = to_goal_cost + speed_cost + ob_cost\n\n            # search minimum trajectory\n            if min_cost >= final_cost:\n                min_cost = final_cost\n                best_u = [v, y]\n                best_trajectory = trajectory\n                if abs(best_u[0]) < config.robot_stuck_flag_cons \\\n                        and abs(x[3]) < config.robot_stuck_flag_cons:\n                    # to ensure the robot do not get stuck in\n                    # best v=0 m\/s (in front of an obstacle) and\n                    # best omega=0 rad\/s (heading to the goal with\n                    # angle difference of 0)\n                    best_u[1] = -config.max_delta_yaw_rate\n    return best_u, best_trajectory","aa7e167b":"def calc_obstacle_cost(trajectory, ob, config):\n\n    ox = ob[:, 0]\n    oy = ob[:, 1]\n    dx = trajectory[:, 0] - ox[:, None]\n    dy = trajectory[:, 1] - oy[:, None]\n    r = np.hypot(dx, dy)\n\n    if config.robot_type == RobotType.rectangle:\n        yaw = trajectory[:, 2]\n        rot = np.array([[np.cos(yaw), -np.sin(yaw)], [np.sin(yaw), np.cos(yaw)]])\n        rot = np.transpose(rot, [2, 0, 1])\n        local_ob = ob[:, None] - trajectory[:, 0:2]\n        local_ob = local_ob.reshape(-1, local_ob.shape[-1])\n        local_ob = np.array([local_ob @ x for x in rot])\n        local_ob = local_ob.reshape(-1, local_ob.shape[-1])\n        upper_check = local_ob[:, 0] <= config.robot_length \/ 2\n        right_check = local_ob[:, 1] <= config.robot_width \/ 2\n        bottom_check = local_ob[:, 0] >= -config.robot_length \/ 2\n        left_check = local_ob[:, 1] >= -config.robot_width \/ 2\n        if (np.logical_and(np.logical_and(upper_check, right_check),\n                           np.logical_and(bottom_check, left_check))).any():\n            return float(\"Inf\")\n    elif config.robot_type == RobotType.circle:\n        if np.array(r <= config.robot_radius).any():\n            return float(\"Inf\")\n\n    min_r = np.min(r)\n    return 1.0 \/ min_r  # OK","bb4d6d54":"def calc_to_goal_cost(trajectory, goal):\n\n    dx = goal[0] - trajectory[-1, 0]\n    dy = goal[1] - trajectory[-1, 1]\n    error_angle = math.atan2(dy, dx)\n    cost_angle = error_angle - trajectory[-1, 2]\n    cost = abs(math.atan2(math.sin(cost_angle), math.cos(cost_angle)))\n\n    return cost","c213e694":"def plot_robot(x, y, yaw, config):  # pragma: no cover\n    if config.robot_type == RobotType.rectangle:\n        outline = np.array([[-config.robot_length \/ 2, config.robot_length \/ 2,\n                             (config.robot_length \/ 2), -config.robot_length \/ 2,\n                             -config.robot_length \/ 2],\n                            [config.robot_width \/ 2, config.robot_width \/ 2,\n                             - config.robot_width \/ 2, -config.robot_width \/ 2,\n                             config.robot_width \/ 2]])\n        Rot1 = np.array([[math.cos(yaw), math.sin(yaw)],\n                         [-math.sin(yaw), math.cos(yaw)]])\n        outline = (outline.T.dot(Rot1)).T\n        outline[0, :] += x\n        outline[1, :] += y\n        plt.plot(np.array(outline[0, :]).flatten(),\n                 np.array(outline[1, :]).flatten(), \"-k\")\n    elif config.robot_type == RobotType.circle:\n        circle = plt.Circle((x, y), config.robot_radius, color=\"b\")\n        plt.gcf().gca().add_artist(circle)\n        out_x, out_y = (np.array([x, y]) +\n                        np.array([np.cos(yaw), np.sin(yaw)]) * config.robot_radius)\n        plt.plot([x, out_x], [y, out_y], marker=\"_\",color=\"g\")","0a4e47f2":"def plot_arrow(x, y, yaw, length=5, width=1):  # pragma: no cover\n    plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw),\n              head_length=width, head_width=width)\n    plt.plot(x, y)","f813bad7":"def predict_PHB_yield(tco2):\n    return (tco2*2.15225*10**11)\/1461000","796010a4":"directory = \"Pictures\"\nparent_dir='\/kaggle\/working\/'\npath = os.path.join(parent_dir, directory)\nos.mkdir(path)\nnames=[]","2d0c5e28":"def main(initial, goal_x, goal_y, n_pts, robot_type=RobotType.circle):\n    print(\" start!!\")\n    PHB_yield=0\n    num=0\n    \n    for i in range(n_pts):\n        # initial state [x(m), y(m), yaw(rad), v(m\/s), omega(rad\/s)]\n        x = np.array([initial[0], initial[1], math.pi \/ 12.0, 0.0, 0.0])\n        # goal position [x(m), y(m)]\n        goal = np.array([goal_x[i], goal_y[i]])\n\n        # input [forward speed, yaw_rate]\n\n        config.robot_type = robot_type\n        trajectory = np.array(x)\n        ob = config.ob\n        while True:\n            u, predicted_trajectory = dwa_control(x, config, goal, ob)\n            x = motion(x, u, config.dt)  # simulate robot\n            final_trajectory = np.vstack((trajectory, x))  # store state history\n            #previous = np.vstack(initial)\n           \n\n            \n            if show_animation:\n                plt.plot(predicted_trajectory[:, 0], predicted_trajectory[:, 1],\"-g\")\n                plt.plot(x[0], x[1],\"xr\")\n                plt.plot(goal_x, goal_y, \"xb\")\n                #plt.plot(previous[:, 0], previous[:, 1], \"Dg\")\n                plt.plot(ob[:, 0], ob[:, 1], \"ok\")\n                plt.plot(final_trajectory[:, 0], final_trajectory[:, 1],\"-r\")\n                plot_robot(x[0], x[1], x[2], config)\n                plot_arrow(x[0], x[1], x[2])\n                plt.axis(\"equal\")\n                plt.grid(True)\n                plt.xlabel('Degrees of Longitude')\n                plt.ylabel('Degrees of Latitude')\n                plt.savefig('Pictures\/plot_{}'.format(num))\n                \n                plt.pause(1)\n                \n            # check reaching goal\n            dist_to_goal = math.hypot(x[0] - goal[0], x[1] - goal[1])\n            names.append(Image.open('\/kaggle\/working\/Pictures\/plot_{}.png'.format(num)))\n            \n            num+=1\n            if dist_to_goal <= config.robot_radius:\n                PHB_yield+=predict_PHB_yield(tco2[x_lis.index(goal[0])])\n                print(f\"Target Reached!!\\n{PHB_yield} kg of PHB produced over the course of the trip\")\n                initial=goal\n                break\n\n    print(\"Done\")\n    \n    plt.show()","bf91f244":"if __name__ == '__main__':\n    main([randint(\n        math.floor(np.amin(unused[label==set], axis=0)[0]), \n        math.ceil(np.amax(unused[label==set], axis=0)[0])), randint(\n        math.floor(np.amin(unused[label==set], axis=0)[1]),\n        math.ceil(np.amax(unused[label==set], axis=0)[1]))],unused[label==0, 0],unused[label==0, 1],1, robot_type=RobotType.circle)","e7914192":"names[0].save('output.gif', save_all=True, append_images=names)","5c682a5d":"gif_original = 'output.gif'\ngif_speed_up = 'out.gif'\n\ngif = imageio.mimread(gif_original, memtest=False)\n\nimageio.mimsave(gif_speed_up, gif, fps=1200)","ae932b5d":"#Cleanup\nfor directory,_,filenames in os.walk(path):\n    for filename in filenames:\n        os.remove(os.path.join(path,filename))\nos.rmdir(path)\nos.remove('output.gif')","405053b1":"HTML('<img src=\".\/out.gif\" \/>')","3548733c":"***\n# Part 3: K-Means Clustering","0f18b136":"***\n# Part 2: Data Preprocessing\/Manipulation","fcc983a4":"*Faster than reality","14616b99":"\n# **Simulation of Light-Driven Renewable Biochemical Synthesis Using Quantum Dot-Bacteria Nanobiohybrids for Use in an Ocean Carbon Capture System**\n\nThis simulation uses a representation of a member of a fleet of autonomous underwater vehicles or AUVs. Each AUV travels around the ocean and uses the nano organisms from the [2019 Journal of American Chemical Society by researchers from the University of Colorado Boulder and the University of Nottingham](https:\/\/pubs.acs.org\/doi\/10.1021\/jacs.9b02549) to perform carbon capture and combat ocean acidification. This notebook displays how the AUVs will navigate the ocean using a dynamic window approach.\n* **","0765ac3a":"In this part, I used K Means Clustering to form 381 regions from the 15,260 points scattered across the ocean.","43516cf3":"# Part 1: Importing Required Libraries","29a59f87":"***\n# Part 5: Output","c3092b6a":"***\n# PART 4: Machine Learning Path Optimization w\/ Dynamic WIndow Approach (DWA)","35ab621f":"In this part, I used a dynamic window approach to effectively navigate the ocean.","48333ed0":"In this part, I created a function to draw the geographic projections. In addition, I read in the data from the CSV file and store it in lists.","db65e5e4":"# **Citations**\n\n* Olsen, A., R. M. Key, S. van Heuven, S. K. Lauvset, A. Velo, X. Lin, C. Schirnick, A. Kozyr, T. Tanhua, M. Hoppema, S. Jutterstr\u00f6m, R. Steinfeldt, E. Jeansson, M. Ishii, F. F. P\u00e9rez and T. Suzuki. The Global Ocean Data Analysis Project version 2 (GLODAPv2) - an internally consistent data product for the world ocean, Earth System Science Data, 8, 297-323, 2016.<br> https:\/\/doi:10.5194\/essd-8-297-2016\n* J. Am. Chem. Soc. 2019, 141, 26, 10272\u201310282<br> Publication Date: June 7, 2019<br> https:\/\/doi.org\/10.1021\/jacs.9b02549<br> **Copyright \u00a9 2019 American Chemical Society**","cd642064":"In this part, I installed and imported the required libraries for this notebook.\n\n**Libraries:**\n\n* **enum:** This library is used to create enumerations, or a set of unique constants. In this notebook,  it is used to specify the robot type, circle or square. That determinses how the AUV is represented in the animation and how it moves.\n\n* **imageio:** This library provides an easy interface to read and write a wide range of image data. In this notebook, it is used to speed up the gif of the simulation for viewer convenience.\n\n* **IPython:**  This library has a wide array of uses. In this notebook, it is used to display the gif animation of the AUV.\n\n* **itertools:** This library is used to create iterators for efficient looping. In this notebook, it is used for drawing the map.\n\n* **math:** This library is used for performing mathematical functions. In this notebook, it is used for calculations relating to the navigation of the AUV using the dynamic window approach.\n\n* **matplotlib:** This library is used for plotting. In this notebook, it is used for all the graphs.\n\n* **mpl_toolkits:** This library is used as an extension to the capabilities of matplotlib. In this notebook, it is used for the geographic map with the Basemap library.\n\n* **numpy:** This library is ubiquitous in most data science projects. It provides a useful data structure, arrays. In this notebook, it is used for storage of data in arrays and manipulating those arrays.\n\n* **os:** This library provides functions to interact with the operating system. In this notebook, it is used to delete the pictures used to make the animation at the end.\n\n* **pandas:** This library is used for data manipulation and analysis. It is also common in many data science projects. In this notebook, it is used to read data from the dataset's csv file.\n\n* **Pillow(PIL):** This library is an image manipulation like imageio. In this notebook, it is used to compile the pictures from the simulation into a gif.\n\n* **random:** This library is used for pseudo-random number generation. This library is pseudo-random because  it uses a mathematical formula, Mersenne Twister, to generate numbers that appear random. In this notebook, it is used for randomly selecting a sample set to perform the simulation on. It is also used to create random obstacles in the simulation.\n\n* **scikit-learn(sklearn):** This library is used for machine learning because it has various classification, regression and clustering algorithms. In this notebook, it is used to perform K Means Clustering to create sample sets for the simulation."}}