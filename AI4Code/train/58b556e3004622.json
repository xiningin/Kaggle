{"cell_type":{"55876536":"code","96db2d26":"code","a01b3fb3":"code","7046d87a":"code","ffbf7735":"code","20c6b8b0":"code","419f73c9":"code","edda3a03":"code","392e408d":"code","f551121e":"code","96f02266":"code","2e18e54e":"code","2fba3c11":"code","e6866203":"code","67e43be9":"code","89a9dfba":"code","b60a7ed0":"code","12345d7d":"code","31ac0970":"code","956cafb6":"code","7d5286bd":"code","c3223b45":"markdown","1ab5d2c3":"markdown"},"source":{"55876536":"# import das bibliotecas\n\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(2018)\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\n\nimport keras\nfrom keras import regularizers\nfrom keras.applications.resnet50 import ResNet50\nfrom keras.models import Model\nfrom keras.layers import Dense, Dropout, Flatten\n\nimport os\nfrom tqdm import tqdm\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nimport cv2\nfrom keras.preprocessing.image import ImageDataGenerator","96db2d26":"df_train = pd.read_csv('..\/input\/dog-breed-identification\/labels.csv') # file with the names of the images and its breed for training\ndf_test = pd.read_csv('..\/input\/dog-breed-identification\/sample_submission.csv') ## file with with the name of the images for testing","a01b3fb3":"df_train.head()","7046d87a":"df_test.head()","ffbf7735":"targets_series = pd.Series(df_train['breed'])\none_hot = pd.get_dummies(targets_series, sparse = True)","20c6b8b0":"one_hot_labels = np.asarray(one_hot)","419f73c9":"im_size = 197  # tamanho da entrada","edda3a03":"x_train = []\ny_train = []\nx_test = []","392e408d":"# fazendo a leitura dos dados de treino\n\ni = 0 \nfor f, breed in tqdm(df_train.values):\n    img = cv2.imread('..\/input\/dog-breed-identification\/train\/{}.jpg'.format(f))\n    x_train.append(cv2.resize(img, (im_size, im_size)))\n    label = one_hot_labels[i]\n    y_train.append(label)\n    i += 1","f551121e":"del df_train # deletando pra economizar espa\u00e7o","96f02266":"# fazendo a leitura dos dados de treino\n\nfor f in tqdm(df_test['id'].values):\n    img = cv2.imread('..\/input\/dog-breed-identification\/test\/{}.jpg'.format(f))\n    x_test.append(cv2.resize(img, (im_size, im_size)))","2e18e54e":"# Criando uma vari\u00e1vel para saber a quantidade classes que temos no dataset\nnum_class = 120","2fba3c11":"X_train, X_valid, Y_train, Y_valid = train_test_split(x_train, y_train, shuffle=True,  test_size=0.2, random_state=1)","e6866203":"del x_train, y_train","67e43be9":"datagen = ImageDataGenerator(width_shift_range=0.2,\n                            height_shift_range=0.2,\n                            zoom_range=0.2,\n                            rotation_range=30,\n                            vertical_flip=False,\n                            horizontal_flip=True)\n\n\ndatagen.fit(X_train)","89a9dfba":"def create_my_model(optimizer):\n    base_model = ResNet50(weights=\"..\/input\/keras-pretrained-models\/resnet50_weights_tf_dim_ordering_tf_kernels_notop.h5\",include_top=False, input_shape=(im_size, im_size, 3))\n    dropout = base_model.output\n    dropout = Dropout(0.5)(dropout)\n    model_with_dropout = Model(inputs=base_model.input, outputs=dropout)\n    \n    x = base_model.output\n    x = Flatten()(x)\n    predictions = Dense(num_class, activation='softmax',\n                        kernel_regularizer=regularizers.l2(0.0015),\n                        activity_regularizer=regularizers.l1(0.0015))(x)\n    \n    \n    \n    my_model = Model(inputs=base_model.input, outputs=predictions)\n    \n#     for layer in my_model.layers:\n#         layer.treinable = False\n    \n    my_model.compile(optimizer=optimizer,\n              loss='categorical_crossentropy', \n              metrics=['accuracy'])\n    return my_model\n","b60a7ed0":"def gerar_grafico(historia, titulo):\n    plt.plot(historia.history['acc'])\n    plt.plot(historia.history['val_acc'])\n    plt.title('Acur\u00e1cia ' + titulo)\n    plt.ylabel('Acur\u00e1cia')\n    plt.xlabel('\u00c9pocas')\n    plt.legend(['treino', 'valida\u00e7\u00e3o'], loc='upper left')\n    plt.show()\n    plt.plot(historia.history['loss'])\n    plt.plot(historia.history['val_loss'])\n    plt.title('Loss ' + titulo)\n    plt.ylabel('Loss')\n    plt.xlabel('\u00c9pocas')\n    plt.legend(['treino', 'valida\u00e7\u00e3o'], loc='upper left')\n    plt.show()","12345d7d":"train_generator = datagen.flow(np.array(X_train), np.array(Y_train), \n                               batch_size=32) ","31ac0970":"model_rmsprop_com_regularizador = create_my_model(optimizer='rmsprop')\nmodel_sgd_com_regularizador = create_my_model(optimizer='sgd')","956cafb6":"history_rmsprop_com_regularizador = model_rmsprop_com_regularizador.fit_generator(\n    train_generator,\n    epochs=10, steps_per_epoch=len(X_train) \/ 18, #len(X_train) \/ 18,\n    validation_data=(np.array(X_train), np.array(Y_train)), validation_steps=len(X_valid) \/ 18)\n\npreds = model_rmsprop_com_regularizador.predict(np.array(x_test), verbose=1)\n\ngerar_grafico(history_rmsprop_com_regularizador, \n              \"ResNet50 with RMSprop\")\n\nsub = pd.DataFrame(preds)\ncol_names = one_hot.columns.values\nsub.columns = col_names\nsub.insert(0, 'id', df_test['id'])\nsub.head(5)\n\nsub.to_csv(\"predictions_resnet50_rmsprop.csv\")\n\nmodel_rmsprop_com_regularizador.save('resnet50_rmsprop.h5')","7d5286bd":"history_sgd_com_regularizador = model_sgd_com_regularizador.fit_generator(\n    train_generator,\n    epochs=10, steps_per_epoch=len(X_train) \/ 18, #len(X_train) \/ 18,\n    validation_data=(np.array(X_train), np.array(Y_train)), validation_steps=len(X_valid) \/ 18)\n\npreds = model_sgd_com_regularizador.predict(np.array(x_test), verbose=1)\n\ngerar_grafico(history_sgd_com_regularizador, \n              \"ResNet50 com SGD, data augmentation e Regularizador\")\n\nsub = pd.DataFrame(preds)\ncol_names = one_hot.columns.values\nsub.columns = col_names\nsub.insert(0, 'id', df_test['id'])\nsub.head(5)\n\nsub.to_csv(\"output_sgd_v2_com_data_augmentation_e_regularizador.csv\")\n\nmodel_sgd_com_regularizador.save('sgd_v2_com_data_augmentation_e_regularizador.h5')","c3223b45":"#### Francisco Igor da Silva Lima - 507536\n\nPara executar o notebook \u00e9 necess\u00e1rio ter uma conta no kaggle e fazer o fork do mesmo\n\nO desafio escolhido \u00e9 Dog Breed Identification, que consiste em descobrir qual \u00e9 ra\u00e7a de cachorro, ou seja \u00e9 um problema de classifica\u00e7\u00e3o multi-classe, s\u00e3o em torno de 120 classes","1ab5d2c3":"### Sobre a arquitetura\n\nA rede escolhida \u00e9 a [ResNet50](https:\/\/arxiv.org\/abs\/1512.03385), ela foi escolhida por ser uma rede bastante conhecida pela comunidade academica, e por ser bem posicionada no desafio do [ImageNet](https:\/\/www.image-net.org\/).\n\nFoi tamb\u00e9m utilizada Data augmentation, para aumentar a quantidade de imagens, al\u00e9m de comparar dois otimizadores, o [RMSProp](https:\/\/keras.io\/api\/optimizers\/rmsprop\/) e o [SGD](https:\/\/keras.io\/api\/optimizers\/sgd\/), e um dropout de 50% na \u00faltima camada.\n\nOs resultados com RMSProp foram p\u00e9ssimos, a acur\u00e1cia n\u00e3o chegou a apenas 0.05, e um loss de 7.1323, o que \u00e9 altissimo. Enquanto com SGD obtivemos resultados mais satisfat\u00f3rios, como uma acur\u00e1cia de 0.9727 e um [loss](https:\/\/keras.io\/api\/losses\/probabilistic_losses\/#categoricalcrossentropy-class) de apenas 0.5652, o que \u00e9 um valor alto para loss, mas bem melhor que usando RMSProp."}}