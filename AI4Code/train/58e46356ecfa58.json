{"cell_type":{"b83dfe08":"code","a504fea2":"code","85c101a2":"code","33ca2f57":"code","d9a74337":"code","09a8fd9a":"code","0cec90a6":"code","cc3857f1":"code","64900152":"code","651ac0c6":"code","66709773":"code","28f9aeee":"code","598396cb":"code","b0e68df3":"code","3779edc8":"code","2c1fbcc5":"code","6b186e1d":"code","402305f9":"code","54d143bb":"code","0c7b0218":"code","0bcf5a2f":"markdown","d56d6029":"markdown","81f2acd1":"markdown","71d08694":"markdown"},"source":{"b83dfe08":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a504fea2":"!python -m pip install snap-stanford","85c101a2":"import snap","33ca2f57":"G1 = snap.LoadEdgeList(snap.PNGraph, '\/kaggle\/input\/wiki-vote\/wiki-Vote.txt', 0, 1)","d9a74337":"G2 = snap.LoadEdgeList(snap.PNGraph, \"\/kaggle\/input\/hw0cs224w\/stackoverflow-Java.txt\", 0, 1)","09a8fd9a":"G1.GetNodes()","0cec90a6":"self_looped = 0\nfor edge in G1.Edges():\n    if edge.GetSrcNId() == edge.GetDstNId():\n        self_looped += 1\nself_looped","cc3857f1":"directed = 0\nfor edge in G1.Edges():\n    if edge.GetSrcNId() != edge.GetDstNId():\n        directed += 1\ndirected","64900152":"undirected = 0\ncache = set()\nfor edge in G1.Edges():\n    from_, to = edge.GetSrcNId(), edge.GetDstNId()\n    if (to, from_) in cache:\n        undirected += 1\n    else:\n        cache.add((from_, to))\nundirected","651ac0c6":"reciprocated = 0\ncache = set()\nfor edge in G1.Edges():\n    from_, to = edge.GetSrcNId(), edge.GetDstNId()\n    if (to, from_) in cache and to != from_:\n        reciprocated += 1\n    else:\n        cache.add((from_, to))\nreciprocated","66709773":"zod = 0\nfor node in G1.Nodes():\n    if node.GetOutDeg() == 0:\n        zod += 1\nzod","28f9aeee":"zid = 0\nfor node in G1.Nodes():\n    if node.GetInDeg() == 0:\n        zid += 1\nzid","598396cb":"mt10 = 0\nfor node in G1.Nodes():\n    if node.GetOutDeg() > 10:\n        mt10 += 1\nmt10","b0e68df3":"lt10 = 0\nfor node in G1.Nodes():\n    if node.GetInDeg() < 10:\n        lt10 += 1\nlt10","3779edc8":"from collections import defaultdict\n\nfrom matplotlib import pyplot as plt\n\ncount_out_degrees = defaultdict(int)\n\nfor node in G1.Nodes():\n    count_out_degrees[node.GetOutDeg()] += 1\n\n\nn_data = np.array(sorted(list(count_out_degrees.items())))\n\nn_data = n_data[n_data[:, 0] != 0]\n\nlogx = np.log10(n_data[:, 0])\nlogy = np.log10(n_data[:, 1])\n             \nplt.scatter(logx, logy, s=7);","2c1fbcc5":"a, b = np.polyfit(logx, logy, 1)\n\nplt.plot(logx, np.log10((10**logy - (a * 10**logx + b)) ** 2));","6b186e1d":"Components = snap.TCnComV()\nsnap.GetWccs(G2, Components)\nComponents.Len()","402305f9":"max_component = snap.GetMxWcc(G2)\nedges = max_component.GetEdges()\nnodes = max_component.GetNodes()\n\nprint('Nodes in max weakly connected component:', nodes)\nprint('And edges:', edges)","54d143bb":"TOP = 3\n\nPRankH = snap.TIntFltH()\n\nsnap.GetPageRank(G2, PRankH)\n\nd = {k: PRankH[k] for k in PRankH}\n\nfor i in range(TOP):\n    id_ = max(d, key=lambda x: d[x])\n    print('id of ',i + 1, 'central node is', id_)\n    del d[id_]","0c7b0218":"NIdHubH = snap.TIntFltH()\nNIdAuthH = snap.TIntFltH()\nsnap.GetHits(G2, NIdHubH, NIdAuthH)\n\ndHub = {k: NIdHubH[k] for k in NIdHubH}\ndAuth = {k: NIdAuthH[k] for k in NIdAuthH}\n\nfor i in range(TOP):\n    id_Hub = max(dHub, key=lambda x: dHub[x])\n    id_Auth = max(dAuth, key=lambda x: dAuth[x])\n    print('id of ', i + 1, 'hub node is', id_Hub)\n    print('id of ', i + 1, 'auth node is', id_Auth)\n    del dHub[id_Hub]\n    del dAuth[id_Auth]","0bcf5a2f":"## Second chapter","d56d6029":"## First chapter","81f2acd1":"## Third chapter","71d08694":"This is a 0 hw for sc224w stanford course"}}