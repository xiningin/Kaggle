{"cell_type":{"f2464fe9":"code","2b0577d6":"code","5139c78f":"code","c4b595f7":"code","e3a83b31":"code","a78165d8":"code","c84d5e5f":"code","5e849e6d":"code","50fe6603":"code","2bdc650c":"code","261bfce2":"code","7e073ab3":"code","0e2aadf5":"code","84eac5c3":"code","063e51af":"code","2802b239":"code","095f3f76":"code","4b021021":"code","039fbc3d":"code","c03c4fc0":"code","0640a730":"code","3509974d":"markdown","bdf14cd5":"markdown","adaa7311":"markdown","37e69c5d":"markdown","91852097":"markdown","2ecc11a7":"markdown","b859a05e":"markdown","b324d914":"markdown","1e370580":"markdown","82292bc6":"markdown","fd0d0aeb":"markdown","ffac2c65":"markdown","d13a0081":"markdown","87c7ccc2":"markdown"},"source":{"f2464fe9":"import os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom functools import reduce","2b0577d6":"# 1. Define key functions to read and transform the data.\n\ndef symbol_to_path(symbol, base_dir=\"..\/input\/multiple-stocks\/\"):\n    '''Return VSV file path given ticker symbol'''\n    \n    return os.path.join(base_dir,\"{}.csv\".format(str(symbol)))\n\ndef get_data(symbols, dates):\n    '''Read stock data (adjusted close) for given symbols from CSV files'''\n    df = pd.DataFrame(index=dates)\n    \n    # Grant that the SPY ticket appear in the dataframe.\n    if 'SPY' not in symbols:\n        symbols.insert(0, 'SPY')\n        \n    \n    # Iterate for each symbol to get the data.\n    for symbol in symbols:\n        \n        # Read CSV that contains historical data of the ticket.\n        df_temp = pd.read_csv(symbol_to_path(symbol),index_col='Date', \n                              parse_dates=True, usecols=['Date','Adj Close'],\n                              na_values = ['nan'])\n    \n        df_temp = df_temp.rename(columns={'Adj Close':symbol})  # Rename columns to avoid overlap\n        df = df.join(df_temp, how='left') # Join ticket's dataframe.\n        df = df.dropna() #Drop nan values\n        \n    return df\n\ndef plot_data(df, title, y_label):\n    \n    ax = df.plot(title=title, fontsize=10)\n    ax.set_xlabel(\"Date\")\n    ax.set_ylabel(y_label)\n    plt.show()\n\ndef plot_selected(df, columns, start_index, end_index):\n    \n    ''' Plot the desired columns over index values in the given range '''\n    df = normalize_data(df.loc[start_index:end_index,columns])\n    return df, plot_data(df, \"Multiple Stock Chart\", \"Price\")\n\ndef normalize_data(df):\n    \n    ''' Normalize stock prices using the first row of the dataframe '''\n    return df \/ df.iloc[0]\n    \ndef test_run():\n    \n    # Define a date range\n    dates = pd.date_range('2020-01-01','2021-01-15')\n    \n    # Choose stock symbols to read\n    symbols = ['GOOG','IBM', 'GLD']\n    \n    # Get stock data\n    df = get_data(symbols, dates)\n    \n    # Get dataframe and chart that compares the selected stocks for the specific period\n    df_selected, stock_chart = plot_selected(df, ['SPY', 'IBM','GOOG','GLD'], '2020-12-01', '2021-01-14')\n    \n    # Print dataframe for selected stocks and specific period.\n    print(\"Selected Stocks\")\n    print(df_selected)\n    \n    # Show stock chart for selected stocks and specific period.\n    stock_chart\n    \n    #Compute global statistics for each stock\n    print(\"\\nStock's mean \\n\")\n    print(df_selected.mean())\n    \n    print(\"\\nStock's Standar deviation \\n\")\n    print(df_selected.std())\n    \n    \n    \n    ","5139c78f":"# 2. Execute routine to read the stock's historical data.\nif __name__ == \"__main__\":\n    test_run()\n    ","c4b595f7":"def get_bollinger_bands(rm_stock, rstd_stock):\n    \n    upper_band = rm_stock + rstd_stock * 2\n    lower_band = rm_stock - rstd_stock * 2\n    return upper_band, lower_band\n\n\ndef test_run():\n    # Read data\n    dates = pd.date_range('2012-01-01','2012-12-31')\n    symbols = ['SPY']\n    df = get_data(symbols, dates)\n    \n    # Plot SPY data, retain matplotlib axis object\n    ax = df['SPY'].plot(title=\"SPY rolling mean\", label='SPY')\n    \n    # Compute rolling mean and standar deviation using a 3 day window\n    rm_SPY = df['SPY'].rolling(3).mean()\n    rstd_SPY = df['SPY'].rolling(3).std()\n    \n    # Add rolling mean to same plot\n    rm_SPY.plot(label='Rolling mean', ax=ax)\n    \n    # Add axis lables and legend\n    ax.set_xlabel(\"Date\")\n    ax.set_ylabel(\"Price\")\n    ax.legend(loc='upper left')\n    plt.show()\n    \n    # Compute Bollinger Bands\n    \n    # Compute upper and lower bands\n    print(get_bollinger_bands(rm_SPY, rstd_SPY))\n    upper_band, lower_band = get_bollinger_bands(rm_SPY, rstd_SPY)\n    \n    # Plot raw SPY values, rolling mean and Bollinger Bands\n    ax = df['SPY'].plot(title='Bollinger Bands', label='SPY')\n    rm_SPY.plot(label='Rolling mean', ax=ax)\n    upper_band.plot(label='upper band', ax=ax)\n    lower_band.plot(label='lower band', ax=ax)\n    \n    # Add axis labels and legends\n    ax.set_xlabel(\"Date\")\n    ax.set_ylabel(\"Price\")\n    ax.legend(loc='upper left')\n    plt.show()\n    ","e3a83b31":"if __name__ == \"__main__\":\n    test_run()","a78165d8":"def compute_comulative_returns(df):\n    '''Compute and return comulative returns between two dates'''\n    \n\n    price_start = df.iloc[0]\n    price_end = df.iloc[-1]\n    print(price_start, price_end)\n    comulative_returns = (df.iloc[-1] \/ df.iloc[0]) - 1\n    return comulative_returns\n\ndef compute_daily_returns(df):\n    '''Compute and return the daily returns values.'''\n    \n    daily_returns = df.copy()\n    #daily_returns.iloc[1:] = (df.iloc[1:] \/ df.iloc[:-1].values) - 1\n    daily_returns = (df\/ df.shift(1)) - 1\n    daily_returns.iloc[0,:] = 0\n    return daily_returns\n\ndef test_run():\n    \n    # Read data\n    dates = pd.date_range('2012-07-01','2012-07-31')\n    symbols = ['SPY','GOOG']\n    df = get_data(symbols, dates)\n    plot_data(df, \"Stock Prices\", \"Price\")\n    \n    # Compute daily returns\n    daily_returns = compute_daily_returns(df)\n    plot_data(daily_returns, title=\"Daily returns\", y_label=\"Daily returns\")\n    \n    #compute comulative returns\n    comulative_returns = compute_comulative_returns(df)\n    print(comulative_returns)","c84d5e5f":"if __name__ == \"__main__\":\n    test_run()","5e849e6d":"def evaluate_date(date, value, start_date, end_date):\n    \n    print('date', date)\n    if (date > start_date) & (date <= end_date):\n        return np.nan\n    else:\n        return value\n\n\ndef create_incomplete_df(df, symbols, missing_dates):\n    '''Create missing data from historical data'''\n    \n    #create a list where store dataframes with missing data for each stock\n\n    ls_new_df = []\n    \n    #Create missing data for each stock: md = range of missing date, s=symbol (stock)\n    \n    for md in missing_dates:\n        for s in symbols:\n            df_temp = df[s]\n            mask = (df_temp.index > md[0]) & (df_temp.index <= md[1])    \n            df_temp[mask] = np.nan\n            ls_new_df.append(df)\n        \n    #Create incomplete dataframe and return it\n    \n    df_incomplete = pd.concat(ls_new_df)\n    return df_incomplete\n\ndef test_run(missing_dates):\n    \n    dates = pd.date_range('2005-12-31','2009-12-07')\n    symbols = ['SPY','GOOG']\n    df_historical = get_data(symbols, dates)\n    \n    print(\"Plot with historical data\")\n    plot_data(df_historical, \"Stock Historical Prices\", \"Price\")\n    \n    df_incomplete = create_incomplete_df(df_historical, symbols, missing_dates)\n    \n    print(\"Plot with incomplete data\")\n    plot_data(df_incomplete, \"Stock Prices Incomplete\", \"Price\")\n    \n    df_complete = df_incomplete.fillna(method='ffill')\n    \n    print(\"Plot with completa data using fillna\")\n    plot_data(df_complete, \"Stock Prices Complete\", \"Price\")","50fe6603":"missing_dates = [['2006-07-01','2006-07-31'],['2007-05-01','2007-07-31'],['2008-02-01','2008-09-30']]\n\nif __name__ == \"__main__\":\n    test_run(missing_dates)","2bdc650c":"def test_run():\n    \n    \n    #Read data and plot stock prices.\n    dates = pd.date_range('2009-01-01','2012-12-31')\n    symbols = ['SPY','XOM']\n    df = get_data(symbols, dates)\n    plot_data(df, \"Stock Prices\", \"Price\")\n    \n    #calculate daily returns and plot it\n    daily_returns = compute_daily_returns(df)\n    plot_data(daily_returns, \"Daily Returns\", \"Returns\")\n    \n    #Get mean and standard deviation\n    mean = daily_returns.mean()\n    print(\"mean:\\n\", mean)\n    std = daily_returns.std()\n    print(\"std:\\n\", std)\n    kurtosis = daily_returns.kurtosis()\n    print(\"Kurtosis:\\n\", kurtosis)\n    \n    \n    #create an histogram of daily returns with 20 bins\n    daily_returns['SPY'].hist(bins=20, label=\"SPY\")\n    daily_returns['XOM'].hist(bins=20, label=\"XOM\")\n    plt.legend(loc='upper right')\n    plt.title(\"Compare Histogram's Stocks\")\n    plt.xlabel(\"Daily returns\")\n    plt.ylabel(\"Frecuency\")\n  \n    #Plot mean and standard deviation\n    \n    plt.axvline(mean[0], color='w', linestyle='dashed', linewidth=2)\n    plt.axvline(std[0], color='b', linestyle='dashed', linewidth=2)\n    plt.axvline(-std[0], color='b', linestyle='dashed', linewidth=2)\n    \n    plt.axvline(mean[1], color='w', linestyle='dashed', linewidth=2)\n    plt.axvline(std[1], color='orange', linestyle='dashed', linewidth=2)\n    plt.axvline(-std[1], color='orange', linestyle='dashed', linewidth=2)\n\n    plt.show()\n    ","261bfce2":"if __name__ == \"__main__\":\n    test_run()\n    ","7e073ab3":"def test_run():\n    \n    #Read data and plot stock prices.\n    dates = pd.date_range('2009-01-01','2012-12-31')\n    symbols = ['SPY','XOM', 'GLD']\n    df = get_data(symbols, dates)\n    plot_data(df, \"Stock Prices\", \"Price\")\n    \n    #calculate daily returns and plot it\n    daily_returns = compute_daily_returns(df)\n    plot_data(daily_returns, \"Daily Returns\", \"Returns\")\n    \n    # Scatterplot SPY vs XOM\n    \n    daily_returns.plot(kind='scatter', x='SPY', y='XOM')\n    beta_XOM, alpha_XOM = np.polyfit(daily_returns['SPY'], daily_returns['XOM'],1) #calculate sloop\n    plt.plot(daily_returns['SPY'], beta_XOM * daily_returns['SPY'] + alpha_XOM, '-', color='r')\n    print(\"beta_xom:\",beta_XOM, \"alpha_xom:\", alpha_XOM)\n    plt.show()\n    \n    # Scatterplot SPY vs GLD\n    \n    daily_returns.plot(kind='scatter', x='SPY', y='GLD')\n    beta_GLD, alpha_GLD = np.polyfit(daily_returns['SPY'], daily_returns['GLD'],1) #calculate sloop\n    plt.plot(daily_returns['SPY'], beta_GLD * daily_returns['SPY'] + alpha_GLD, '-', color='r')\n    print(\"beta_gld:\",beta_GLD, \"alpha_gld:\", alpha_GLD)\n    plt.show()\n    \n    # Calculate correlation coefficient\n    print('Correlations:\\n')\n    print(daily_returns.corr(method='pearson'))\n    ","0e2aadf5":"if __name__ == \"__main__\":\n    test_run()","84eac5c3":"import math\n\nreturns = 0.001 - 0.0002\navg_daily_returns = (returns \/ 60)\nk = math.sqrt(252)\nstd_daily_ret = 0.001\n\nk * returns \/ std_daily_ret","063e51af":"'''Minimize an objective function using Scipy'''\nimport scipy.optimize as spo","2802b239":"'''Finding the minima in convex problems'''\n\ndef f(X):\n    '''Given a scalar X, return some value (a real number)'''\n    Y = (X - 1.5)**2 + 0.5\n    print(f\"X = {X}, Y = {Y}\")\n    return Y\n\ndef test_run():\n    Xguess = 2.0\n    min_result = spo.minimize(f, Xguess, method=\"SLSQP\", options={'disp': True})\n    print(\"Minima found at: \")\n    print(f\"X = {min_result.x}, Y = {min_result.fun}\")\n    \n    #Plot function values, mark minima\n    Xplot = np.linspace(0.5, 2.5, 21)\n    Yplot = f(Xplot)\n    plt.plot(Xplot,Yplot)\n    plt.plot(min_result.x, min_result.fun,'ro')\n    plt.title(\"Minima of an objective function\")\n    plt.show()","095f3f76":"if __name__ == \"__main__\":\n    test_run()","4b021021":"'''Fit a line to a given set of data points using optimization'''\n\ndef error(line, data): #error function\n    '''Compute error between given line model and observed data\n    \n    Parameters\n    ..........\n    \n    line: tuple\/list\/array (C0, C1) where C0 is slope and C1 is y-intercepted\n    data: 2D array where each row is a point (x,y)\n    \n    Returns error as a single real value.\n    \n    '''\n    # Metric: Sum of squared Y-axis differences\n    err = np.sum((data[:,1]- (line[0] * data[:,0] +line[1]))** 2)\n    return err\n\ndef fit_line(data, error_func):\n    '''Fit a line to given data, using a supplied error function\n    \n    Parameters\n    ..........\n    \n    data: 2D array where each row is a point (X0, Y)\n    error_func: Function that computes the error between a line and observed data\n    \n    Returns line that minimizes the error function\n    \n    '''\n    \n    #Generate initial guess for line model\n    \n    l = np.float32([0, np.mean(data[:,1])]) # slope = 0, intercept = mean(y values)\n    # Plot initial guess (Optional)\n    \n    X_ends = np.float32([-5, 5])\n    plt.plot(X_ends, l[0] * X_ends + l[1], 'm--', linewidth=2.0, label=\"Initial guess\")\n    \n    # Call optimizer to minimeze error function\n    result = spo.minimize(error_func, l, args=(data,), method='SLSQP', options={'disp':True})\n    return result.x\n\ndef test_run():\n    \n    #Define original line\n    l_orig = np.float32([4,2])\n    print(f\"Orginal line: C0 {l_orig[0]}, C1 = {l_orig[1]}\")\n    Xorig = np.linspace(0, 10, 21)\n    Yorig = l_orig[0] * Xorig + l_orig[1]\n    plt.plot(Xorig, Yorig, 'b--', linewidth=2.0, label=\"Original line\")\n    \n    # Generate noisy data points\n    noise_sigma = 3.0\n    noise = np.random.normal(0, noise_sigma, Yorig.shape)\n    data = np.asarray([Xorig, Yorig + noise]).T\n    plt.plot(data[:,0], data[:,1],'go', label=\"Data points\")\n    \n    #Try to fit a line in this data\n    l_fit = fit_line(data, error)\n    print(f\"Fitted line: C0 = {l_fit[0]}, C1 = {l_fit[1]}\")\n    plt.plot(data[:,0], l_fit[0] * data[:,0] + l_fit[1], 'r--', linewidth=2.0, label=\"Fitted Line\")\n    plt.legend()\n    plt.show()\n    ","039fbc3d":"if __name__ == \"__main__\":\n    test_run()","c03c4fc0":"def error_poly(C, data):\n    '''Compute error between given polynomial and observed data\n    \n    Parameters\n    ..........\n    C: numpy.poly1d object or equivalent array representing polynomial coefficients\n    data: 2D array where each row is a point (x,y)\n    \n    Returns error as a single real value\n    \n    '''\n    # Metric: Sum of squared Y-axix differences\n    err = np.sum((data[:,1] - np.polyval(C, data[:,0]))**2)\n    return err\n\ndef fit_poly(data, error_func, degree=3):\n    '''Fit a polynomial to given data, using supplied error function.\n    \n    Parameters\n    ..........\n    \n    data: 2d array where each row is a point (x, y)\n    error_func: function that computes the error between a polynomial and observed data.\n    \n    returns polynomial that minimizes the error function\n    \n    '''\n    \n    Cguess = np.poly1d(np.ones(degree+1, dtype=np.float32))\n    \n    # Plot initial guess (optional)\n    \n    x = np.linspace(-5, 5, 21)\n    plt.plot(x, np.polyval(Cguess, x), 'm--', linewidth=2.0, label=\"Initial guess\")\n    \n    # Call optimizer to minimize error function\n    result = spo.minimize(error_func, Cguess, args=(data,), method='SLSQP', options={'disp':True})\n    return np.poly1d(result.x) #convert optimal result into a polynomial object and return it.\n    \ndef test_run():\n    \n    #Define original line\n    l_orig = np.float32([4,2])\n    print(f\"Orginal line: C0 {l_orig[0]}, C1 = {l_orig[1]}\")\n    Xorig = np.linspace(0, 10, 21)\n    Yorig = np.polyval(np.poly1d(np.ones(3+1, dtype=np.float32)), Xorig)\n    plt.plot(Xorig, Yorig, 'b--', linewidth=2.0, label=\"Original line\")\n    \n    # Generate noisy data points\n    noise_sigma = 5.0\n    noise = np.random.normal(0, noise_sigma, Yorig.shape)\n    data = np.asarray([Xorig, Yorig + noise]).T\n    plt.plot(data[:,0], data[:,1],'go', label=\"Data points\")\n    \n    #Try to fit a line in this data\n    l_fit = fit_poly(data, error_poly)\n    print(l_fit)\n    print(f\"Fitted polynomial: C0 = {l_fit[0]}, C1 = {l_fit[1]}\")\n    plt.plot(data[:,0], np.polyval(l_fit, data[:,0]), 'r--', linewidth=2.0, label=\"Fitted Line\")\n    plt.legend()\n    plt.show()","0640a730":"if __name__ == \"__main__\":\n    test_run()","3509974d":"# Rolling Statistics","bdf14cd5":"# Portfolio optimizations\n\nGiven a set of assets and a period of time, find an allocation of\nfunds to assets that maximizes performance.\n\nWhat's performance?\n\nChose from a number of metrics like: Cumulative return, volatility or risk, Sharpe (risk adjusted return)\n\nThe metric that is commonly used is comulative return, but it's not\nthe best for risk mitigation.\n\n## Framing the problem\n\na. Provide a function to minimize f(x)\nb. Provide an initiai guess for X\nc. Call the optimizer\n\nX = allocations\nf = Sharp ratio (But, as a better sharp ratio need to be positive\nand greater, to find the minimum, we need to use sharp ratio in\nthis negative form). Sharpe_ratio X-1\n\n## Ranges and constrains\n\na. Ranges: Limits on values for X between 0 and 1\nb, Constraints: Properties of X that must be \"True\".\n","adaa7311":"## daily portfolio value","37e69c5d":"## sharpe ratio\nRisk adjustment return","91852097":"# Sharpe ratio and other porfolio statistics\n\nA portfolio is allocate founds to a set of stocks. \nThis notebook follow a buy-and-hold strategy where we\ninvest in a set of stocks with a certain allocation and then observe how thinks moving forward. We'll asume the allocation\nsum to 1.0","2ecc11a7":" ## Linear problems","b859a05e":"# Incomplete data","b324d914":"# Histograms\n\nUse histograms to analice the frequency of the daily returns for one or more stocks, and compare it, and identify if its returns have a similar behaviour","1e370580":"# Context\n\nThis notebook shows how to read various CSV that contains stock's historical data; after reading it, we will create a common dataframe that contains all stocks to do a comparative analysis.","82292bc6":"# Scatterplots\n\nUse Scatterplots to compare the variation's returns of the stocks and identify correlations between them.","fd0d0aeb":"# Optimizers\n\nAlgorithms that can do:\n\n- Find minimum values of functions\n- Build parameterized models based on data\n- Refine allocations to stock's in portfolios\n\nTo use an optimizer we need:\n\n- Provide a function to minimize\n- Provide an initial guess\n- Call the optimizer","ffac2c65":"## portfolio statistics","d13a0081":"## Polynomials problems","87c7ccc2":"## Convex problems"}}