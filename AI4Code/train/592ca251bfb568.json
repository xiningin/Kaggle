{"cell_type":{"0c7f606d":"code","51abd21c":"code","d12d6141":"code","089dc91b":"code","1bfea941":"code","5ad58b2e":"code","997ad884":"code","68d0cfd6":"code","d801b1ab":"code","a4c709f7":"code","2cebcf76":"code","a1117052":"code","58f41717":"code","1e15c753":"code","7e7f2678":"code","2276826f":"code","986b35e0":"code","5ad67b38":"code","476d01bc":"code","eb688826":"code","f4b06dab":"markdown","8e124055":"markdown","b789e945":"markdown","652691d2":"markdown","79750583":"markdown","3d0dc128":"markdown","18eb0643":"markdown","8dd73ce4":"markdown","879ffc68":"markdown","5c934ae4":"markdown","ed6d8b2c":"markdown","5d9a3e4a":"markdown","79164ef8":"markdown","7bc00a40":"markdown"},"source":{"0c7f606d":"# Input dos plugins essenciais\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input do local dos dados\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","51abd21c":"import re\nimport xgboost as xgb\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\n\nfrom sklearn import tree\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom IPython.display import Image as PImage\nfrom subprocess import check_call\nfrom PIL import Image, ImageDraw, ImageFont\nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import plot_roc_curve\nfrom yellowbrick.classifier import ROCAUC\nimport matplotlib.font_manager","d12d6141":"# Loading the data\ntrain = pd.read_csv('\/kaggle\/input\/desafio-falconi-ii\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/desafio-falconi-ii\/test.csv')\n\n# Store our client IDs for easy access\nClientId = test['client_id']","089dc91b":"train.head()","1bfea941":"train.drop('client_id', axis=1, inplace=True)\ntrain.drop('country', axis=1, inplace=True)\ntrain.drop('state', axis=1, inplace=True)\ntrain.drop('zip_code', axis=1, inplace=True)\ntrain.drop('latitude', axis=1, inplace=True)\ntrain.drop('longitude', axis=1, inplace=True)\ntrain.drop('lat_long', axis=1, inplace=True)\ntrain.drop('total_charges', axis=1, inplace=True)\ntrain.info()","5ad58b2e":"test.drop('country', axis=1, inplace=True)\ntest.drop('state', axis=1, inplace=True)\ntest.drop('zip_code', axis=1, inplace=True)\ntest.drop('latitude', axis=1, inplace=True)\ntest.drop('longitude', axis=1, inplace=True)\ntest.drop('lat_long', axis=1, inplace=True)\ntest.drop('total_charges', axis=1, inplace=True)\ntest.info()","997ad884":"train = train[['cltv', 'contract', 'paperless_billing', 'payment_method',\n       'monthly_charges', 'tenure_months', 'tech_support',\n       'tv_streaming', 'phone_service', 'multiple_lines', 'online_security',\n       'online_backup', 'device_protection', 'movies_streaming',\n       'internet_service', 'gender', 'dependents', 'senior_citizen', 'partner','churn']]\n\nnumeric = ['cltv','monthly_charges', 'tenure_months']\n\ncategorical = ['contract', 'paperless_billing', 'payment_method','tech_support',\n       'tv_streaming', 'phone_service', 'multiple_lines', 'online_security',\n       'online_backup', 'device_protection', 'movies_streaming',\n       'internet_service', 'gender', 'dependents', 'senior_citizen', 'partner']\n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.preprocessing import MinMaxScaler, OneHotEncoder\n\nscaler = MinMaxScaler()\n\ntrain[numeric] = scaler.fit_transform(train[numeric])\n\nencoder = OneHotEncoder(sparse=False)\nnew_columns = encoder.fit_transform(train[categorical])\nnew_columns = pd.DataFrame(new_columns, columns=encoder.get_feature_names())\n\ntrain = train.drop(columns=categorical).join(new_columns)\ntrain.head()","68d0cfd6":"test = test[['client_id','cltv', 'contract', 'paperless_billing', 'payment_method',\n       'monthly_charges', 'tenure_months', 'tech_support',\n       'tv_streaming', 'phone_service', 'multiple_lines', 'online_security',\n       'online_backup', 'device_protection', 'movies_streaming',\n       'internet_service', 'gender', 'dependents', 'senior_citizen', 'partner']]\n\nnumeric = ['cltv','monthly_charges', 'tenure_months']\n\ncategorical = ['contract', 'paperless_billing', 'payment_method','tech_support',\n       'tv_streaming', 'phone_service', 'multiple_lines', 'online_security',\n       'online_backup', 'device_protection', 'movies_streaming',\n       'internet_service', 'gender', 'dependents', 'senior_citizen', 'partner']\n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.preprocessing import MinMaxScaler, OneHotEncoder\n\nscaler = MinMaxScaler()\n\ntest[numeric] = scaler.fit_transform(test[numeric])\n\nencoder = OneHotEncoder(sparse=False)\nnew_columns = encoder.fit_transform(test[categorical])\nnew_columns = pd.DataFrame(new_columns, columns=encoder.get_feature_names())\n\ntest = test.drop(columns=categorical).join(new_columns)\ntest.head()","d801b1ab":"colormap = plt.cm.RdYlGn\nplt.figure(figsize=(12,12))\nplt.title('Correla\u00e7\u00e3o entre as Vari\u00e1veis do Modelo', y=1.05, size=15)\nsns.heatmap(train.astype(float).corr(),linewidths=0.1,vmax=1.0, square=True, cmap=colormap, linecolor='white', annot=False)","a4c709f7":"test.drop('x5_No', axis=1, inplace=True)\ntest.drop('x5_Yes', axis=1, inplace=True)\ntest.drop('x6_No', axis=1, inplace=True)\ntest.drop('x6_No phone service', axis=1, inplace=True)\ntest.drop('x6_Yes', axis=1, inplace=True)\ntest.drop('x8_Yes', axis=1, inplace=True)\ntest.drop('x9_Yes', axis=1, inplace=True)\ntest.drop('x10_Yes', axis=1, inplace=True)\ntest.drop('x12_Male', axis=1, inplace=True)\ntest.drop('x12_Female', axis=1, inplace=True)\ntest.drop('cltv', axis=1, inplace=True)\n\ntrain.drop('x5_No', axis=1, inplace=True)\ntrain.drop('x5_Yes', axis=1, inplace=True)\ntrain.drop('x6_No', axis=1, inplace=True)\ntrain.drop('x6_No phone service', axis=1, inplace=True)\ntrain.drop('x6_Yes', axis=1, inplace=True)\ntrain.drop('x8_Yes', axis=1, inplace=True)\ntrain.drop('x9_Yes', axis=1, inplace=True)\ntrain.drop('x10_Yes', axis=1, inplace=True)\ntrain.drop('x12_Male', axis=1, inplace=True)\ntrain.drop('x12_Female', axis=1, inplace=True)\ntrain.drop('cltv', axis=1, inplace=True)\n\nfull_data = [train, test]","2cebcf76":"def get_gini_impurity(churn_count, total_count):\n    churn_prob = churn_count\/total_count\n    not_churn_prob = (1 - churn_prob)\n    random_observation_churn_prob = churn_prob\n    random_observation_not_churn_prob = (1 - random_observation_churn_prob)\n    mislabelling_churn_prob = not_churn_prob * random_observation_churn_prob\n    mislabelling_not_churn_prob = churn_prob * random_observation_not_churn_prob\n    gini_impurity = mislabelling_churn_prob + mislabelling_not_churn_prob\n    return gini_impurity","a1117052":"# Gini Impurity of starting node\ngini_impurity_starting_node = get_gini_impurity(342, 891)\ngini_impurity_starting_node","58f41717":"cv = KFold(n_splits=8) #N\u00famero de quebras da \u00e1rvore\naccuracies = list()\nmax_attributes = len(list(test))\ndepth_range = range(1, 11)\n\n\nfor depth in depth_range:\n    fold_accuracy = []\n    tree_model = tree.DecisionTreeClassifier(max_depth = depth)\n    for train_fold, valid_fold in cv.split(train):\n        f_train = train.loc[train_fold]\n        f_valid = train.loc[valid_fold] \n\n        model = tree_model.fit(X = f_train.drop(['churn'], axis=1), y = f_train[\"churn\"])\n        valid_acc = model.score(X = f_valid.drop(['churn'], axis=1), y = f_valid[\"churn\"])\n        fold_accuracy.append(valid_acc)\n\n    avg = sum(fold_accuracy)\/len(fold_accuracy)\n    accuracies.append(avg)\n\n    \ndf = pd.DataFrame({\"Max Depth\": depth_range, \"Average Accuracy\": accuracies})\ndf = df[[\"Max Depth\", \"Average Accuracy\"]]\nprint(df.to_string(index=False))","1e15c753":"test.set_index('client_id', inplace=True)\n\ny_train = train['churn']\nx_train = train.drop(['churn'], axis=1).values \nx_test = test.values\n\ndecision_tree = tree.DecisionTreeClassifier(criterion='gini', splitter='best', max_depth=7)\ndecision_tree.fit(x_train, y_train)\ny_pred = decision_tree.predict_proba(x_test)[:,1]\nproba = y_pred\n\nwith open(\"tree1.dot\", 'w') as f:\n     f = tree.export_graphviz(decision_tree,\n                              out_file=f,\n                              max_depth = 8,\n                              impurity = True,\n                              feature_names = list(train.drop(['churn'], axis=1)),\n                              class_names = ['churn', 'not_churn'],\n                              rounded = True,\n                              filled= True )\n        \ncheck_call(['dot','-Tpng','tree1.dot','-o','tree1.png'])\n\n\nimg = Image.open(\"tree1.png\")\ndraw = ImageDraw.Draw(img)\nfont = ImageFont.truetype('\/usr\/share\/fonts\/truetype\/dejavu\/DejaVuSerif-Bold.ttf', 26)\ndraw.text((10, 0),'Decision Tree',(0,0,0),font=font)\nimg.save('sample-out.png')\nPImage(\"sample-out.png\")\n\n# Code to check available fonts and respective paths\n# import matplotlib.font_manager\n# matplotlib.font_manager.findSystemFonts(fontpaths=None, fontext='ttf')","7e7f2678":"acc_decision_tree = round(decision_tree.score(x_train, y_train) * 100, 2)\nacc_decision_tree","2276826f":"y_pred_train = decision_tree.predict_proba(x_train)\nproba_train = y_pred_train\nX = x_train\ny = train.churn\n\nvisualizer = ROCAUC(model, classes=[0, 1], title=\"ROC Curves for Decision Tree\")\nvisualizer.fit(X, y)\nvisualizer.score(X, y)\nvisualizer.show();","986b35e0":"test.reset_index()[['client_id']]","5ad67b38":"df = pd.DataFrame(test)\ndf['predict_probability'] = proba","476d01bc":"test.reset_index()[['client_id','predict_probability']]","eb688826":"test[['predict_probability']].to_csv('notebook_decision_tree_v4.csv')","f4b06dab":"> Carregando os dados:","8e124055":"> Removendo vari\u00e1veis sem correla\u00e7\u00e3o forte (negativa ou positiva)\n\n","b789e945":"> Avalia\u00e7\u00e3o da acuracidade da \u00c1rvore calculada com diferentes n\u00edveis de quebra, de 1 em diante. Pela tabela resultante, quatro quebras na \u00e1rvore \u00e9 o n\u00famero ideal pois traz maior acuracidade. Vale testar com 6 quebras, se mant\u00e9m a l\u00f3gica e se melhora ROC-AUC na base de teste.","652691d2":"> Chamando as bibliotecas e fun\u00e7\u00f5es utilizadas a seguir:","79750583":"> Removendo as colunas que n\u00e3o ser\u00e3o utilizadas no modelo (escolhidas a partir do entendimento do problema), tanto da base de treino quanto de teste. Client_id permanece na base de teste, pois ser\u00e1 o identificador na sa\u00edda para submiss\u00e3o.","3d0dc128":"> Visualiza\u00e7\u00e3o da Curva ROC-AUC:","18eb0643":"> Prepara\u00e7\u00e3o da base para envio, recuperando client_id que estava no \u00edndice e salvando o .csv.","8dd73ce4":"> Defini\u00e7\u00e3o da fun\u00e7\u00e3o de Gini Index, para c\u00e1lculo dos desdobramentos da \u00c1rvore e compara\u00e7\u00e3o da acur\u00e1cia.","879ffc68":"> Mapa de calor de Correla\u00e7\u00e3o de Pearson para identificar se alguma vari\u00e1vel pode n\u00e3o ser inclu\u00edda no modelo (removendo vari\u00e1veis ):","5c934ae4":"> Gera\u00e7\u00e3o da \u00e1rvore com os dados de probabilidade, al\u00e9m da vis\u00e3o em imagem.","ed6d8b2c":"> Convertendo as colunas categ\u00f3ricas em 0 e 1 (bin\u00e1rias) para que a \u00c1rvore de Decis\u00e3o possa rodar, tanto da base de treino quanto da base de teste:","5d9a3e4a":"> Visualizando os dados de treino:","79164ef8":"> Primeira tentativa de rodar a t\u00e9cnica de **\u00c1rvore de Decis\u00e3o** usando Python para prever o churn da empresa de telefonia. *N\u00e3o \u00e9 o modelo que utilizamos at\u00e9 o momento para obter os 0.91 de ROC-AUC, mas um esfor\u00e7o para aprender a usar o notebook com outras ferramentas e n\u00e3o somente o Knime.*","7bc00a40":"> Visualiza\u00e7\u00e3o da acuracidade atingida:"}}