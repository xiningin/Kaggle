{"cell_type":{"9521c71c":"code","bb7bf8e7":"code","fa1c6ab7":"code","445b60c3":"code","be17215e":"code","ce6140de":"code","6ac2c4f1":"code","42ef3811":"markdown","e46b4c41":"markdown","b29fda2c":"markdown","79855f1d":"markdown","d128f348":"markdown","57ea0e84":"markdown","77d080b2":"markdown","f3cea8df":"markdown","7b9a66bc":"markdown","62d9ca8c":"markdown","165c2caf":"markdown","ba9e1b2c":"markdown"},"source":{"9521c71c":"# load up requirements\nimport pandas as pd\nimport tensorflow as tf\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# load data\ndata = pd.read_csv('..\/input\/Iris.csv')","bb7bf8e7":"# Pairplot of the data\ng = sns.pairplot(data, hue='Species')\n","fa1c6ab7":"# Subset and Normalize\n\ncol_names = [\"SepalLengthCm\", \"SepalWidthCm\", \"PetalLengthCm\", \"PetalWidthCm\"]\nmy_data = data[col_names]\n\n# Normalize data\nfrom sklearn import preprocessing\n\ndef norm(data):\n  min_max_scaler = preprocessing.MinMaxScaler()\n  norm_data = min_max_scaler.fit_transform(data)\n  df_normalized = pd.DataFrame(norm_data)\n  return df_normalized\n\ntesting_data = norm(my_data)\n","445b60c3":"# Code Ripped from TensorFlow docs. Hacked for correctness.\n\n\ndef input_fn():\n  return tf.train.limit_epochs(\n      tf.convert_to_tensor(tf.cast(testing_data, tf.float32)), num_epochs=1)\n\nnum_clusters = 3\nkmeans = tf.contrib.factorization.KMeansClustering(\n    num_clusters=num_clusters, use_mini_batch=False)\n\n# train\nnum_iterations = 10\nprevious_centers = None\nfor _ in range(num_iterations):\n  kmeans.train(input_fn)\n  cluster_centers = kmeans.cluster_centers()\n  if previous_centers is not None:\n    print('delta:', cluster_centers - previous_centers)\n  previous_centers = cluster_centers\n  print('score:', kmeans.score(input_fn))\nprint('cluster centers:', cluster_centers)\n\n# map the input points to their clusters\ncluster_indices = list(kmeans.predict_cluster_index(input_fn))\nfor i, point in enumerate(testing_data):\n  cluster_index = cluster_indices[i]\n  center = cluster_centers[cluster_index]\n  print('point:', point, 'is in cluster', cluster_index, 'centered at', center)","be17215e":"# Plot Species Clusters\n\ntesting_data['cluster_index'] = cluster_indices\n\n# Get our column names back\ntesting_data.columns = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width', 'cluster_index']\n\nk = sns.pairplot(testing_data, hue=\"cluster_index\", hue_order=[1,2,0], vars=['sepal_length', 'sepal_width', 'petal_length', 'petal_width'])\nk.fig.suptitle(\"K-Means Species Identification\", y=1.0)","ce6140de":"# Custom Evaluation\n\n# 0 -> Virginica , 1 -> Setosa, 2 -> Versicolor\n\n# Extract cluster_index column\nclus = testing_data['cluster_index']\n\n# Replace cluster index with species\nclus = clus.replace([0,1,2], ['Iris-virginica', 'Iris-setosa', 'Iris-versicolor'])\n\n# Extract species from original set\nspecies = data['Species']\n\n# Compare\nmy_bools = species == clus\nerr = sum(my_bools == False)\n\nprint(\"K-Means clustering incorrectly labeled \" + str(err) + \" out of \" + str(len(clus)) + \" flowers as the wrong species.\\n\")\nprint(\"Success rate: \" + str(100-err\/len(clus) * 100) + \"%\")\n","6ac2c4f1":"# More visualization\nimport itertools\n\nfinal = pd.DataFrame.copy(testing_data)\n\n\nfinal['species'] = clus\nfinal['right'] = my_bools\n\ng = sns.pairplot(final, hue=\"right\", palette=[\"red\", \"green\"],vars=['sepal_length', 'sepal_width', 'petal_length', 'petal_width'] )\ng.fig.suptitle(\"Incorrectly Identified Flowers from the K-Means Model\", y=1.0)\n\n  \n ","42ef3811":"# Taking a look at the data\nUsing Seaborn's `pairplot` routine, we can see what the data looks like. I also used the `Species` column to label the species identifiers within the dataset as different colored points within the scatter plots.","e46b4c41":"This evaluation routine reports a success rate of 88%.\n\n# Plotting the errors\nWe can use the `True` and `False` values from the comparison above (stored in `my_bools`) to color the errors in prediction.","b29fda2c":"# Plotting the Results\n\n* Create a new column within `testing_data` called `cluster_index` that contains the identified cluster (the predicted species) from each row.\n* Make sure the `testing_data` contains the proper column names. Somewhere, the column names were lost.\n\n* Call Seaborn's pairplot routine with some special instructions.\n* Use `testing_data`\n* Color the species by information in `cluster_index`\n* Set `hue_order` to the same colors used in the EDA. \n* Plot only the columns used as factors. ( Leaves out `cluster_index` in the pairplot).\n* Give it a proper title.","79855f1d":"### Remarks\n* Upon visual inspection, K-Means correctly identified species. \n* Even in the `sepal_width` and `sepal_width` entanglement, K-Means was correct to an extent.","d128f348":"## Abstract\nI built a working Machine Learning model using Tensorflow and Pandas in the Python language. Using the standard Iris dataset from Kaggle, I copied the data without species information to a new dataset. Utilizing  Tensorflow's K-Means implementation, I created a species identification model through clustering. Using a custom evaluation routine, the process reported an 88% success rate of the model. The cluster errors are shown plotted within the data.\n\n## Introduction\nAccording to the dataset description, the Iris dataset is a collection of measurements on Iris flowers used in a paper by R.A. Fisher as an example of Taxonomic classification of species by measurement. Three species are present within the dataset: Iris-virginica, Iris-setosa, and Iris-versicolor. The goal of this experiment is to discover the success rate of the K-Means Clustering algorithm in correctly identifying the species from measurements.","57ea0e84":"# Species Identification in Iris Flowers Through K-Means Clustering","77d080b2":"# Loading up our tools and our Dataset","f3cea8df":"We can see a few remarkable features of the data.\n* One of the species, *Iris-setosa*, is easily separated from the rest of the dataset.\n*  However, two of the species, *Iris-virginica* and *Iris-setosa*, are clustered together.\n*  In the case of plotting `SepalLengthCm` versus `SepalWidthCm`, the two species' measurements are intangled together.","7b9a66bc":"# Lets try K-Means on four features\n* `col_names` is a list containing the columns names of the features we will use for K-Means prediction.\n* `my_data` is a copy of the Iris dataset subsetted by the column predictors of interest.\n*  The data is normalized, or brought within the same scale, through routines contained in the `sklearn` `preprocessing` package (Scikit-Learn).\n* The function norm() is defined, which performs the normalization on the data through a `MinMaxScaler` object from `preprocessing`.\n* The `testing_data` variable is pointed towards the normed data.","62d9ca8c":"## K-means Code\n### Variables\n* `num_clusters` - The number of clusters (species) to predict.\n* `kmeans` - A tensorflow `KMeansClustering` object through which the computation is performed.\n* `num_iterations` - The number of iterations. As K-Means iterates through the data, the cluster center calculation becomes more precise.\n* `previous_centers` -  A container for the centers calculated from the previous iteration. Initialized with `None`.\n* `cluster_indices` -  Used for mapping the feature point to the cluster index (0, 1, or 2).\n\n### Routines\n* `input_fn()` - Converts `testing_data` to a Tensforflow tensor object and limits the number of epochs per iteration.\n\nNote: Produces quite a bit of output.","165c2caf":"# Evaluation Routine\nI decided to use a custom routine in evaluating the correct species identification. Due to the fact that I have all the original species information, I can compare it to the new information provided by the K-Means algorithm, and determine the percentage of clusters which are correctly mapped to the original species information.\n\n## How it works.\n* Store the `cluster_index` from `testing_data` into a new variable called `clus` \n* Replace cluster index values (0,1, and 2) with the Species names. Note that the index -> species name mapping is a permutation.\n* Extract the species names from the data. Store it in `species`.\n* Create a boolean array of comparisons between `species` and `clus` built on equivalence.\n* `err` is a sum of the number of incorrect identifications.\n* The error rate is `err\/len(clus) * 100` so the success rate is 100 minus the error rate.\n* Print it out.","ba9e1b2c":"We will use the following libraries to help with the analysis.\n* Pandas - a library which contains the DataFrame object. The DataFrame object is used for reading data, storing it, and manipulating it efficiently.\n* Tensorflow - a Google library which contains Machine Learning routines. The K-Means implementation is coded within this library.\n* Seaborn and Myplotlib - Data Visualization libraries.\n* Numpy - Pandas is built on top of Numpy, which is part of the Python Scientific Computing collection of libraries."}}