{"cell_type":{"d5d07846":"code","ce3d5e64":"code","59808436":"code","8f3c54f1":"code","5e2145b3":"code","979725db":"code","e279695f":"code","f6610c2c":"code","2c5aa84a":"code","2c2dc1a7":"code","4200e01a":"code","e15c0980":"code","6d990bfb":"code","030a07cb":"code","2d32c839":"code","a7e4a0b1":"code","c31724da":"code","e3b065b6":"code","7a4b05f5":"code","961836d0":"code","82f1ba93":"code","cf1d7a7b":"code","7df2865a":"code","ac8e6c01":"code","70986a88":"code","f2b713a5":"code","c2f0bdd1":"markdown","697eaa28":"markdown","025b2b9b":"markdown"},"source":{"d5d07846":"!pip install fastai==2.5.1 -qqq\n!pip install timm -qqq","ce3d5e64":"from sklearn.model_selection import train_test_split\nimport sklearn.metrics as skm\nfrom sklearn import preprocessing\nimport numpy as np\nfrom pathlib import Path\nimport pandas as pd","59808436":"def create_df(input_dir,is_test=False):\n    #input_dir = Path('..\/input\/intel-image-classification\/seg_train\/seg_train')\n    files = input_dir.rglob('*.jpg')\n    input=pd.DataFrame(files,columns =['a'])\n    input['a']=input['a'].astype(str)\n    df=input['a'].str.split('\/',expand=True)\n    final=input.join(df)[['a',5]]\n    final.columns=('file_path','label')\n    if is_test:\n        final['split']='test'\n    else:\n        final['split']='train'\n    return final","8f3c54f1":"train=create_df(input_dir= Path('..\/input\/intel-image-classification\/seg_train\/seg_train'))\ntrain.head()","5e2145b3":"test=create_df(input_dir= Path('..\/input\/intel-image-classification\/seg_test\/seg_test'),is_test=True)\ntest.head()","979725db":"final_df=pd.concat([train, test], axis=0)","e279695f":"le = preprocessing.LabelEncoder()\nle.fit(final_df['label'])\nfinal_df['label_enc']=le.transform(final_df['label'])\nfinal_df.head()","f6610c2c":"NUM_CLASSES=final_df['label_enc'].max()+1\ntarget_strings = le.inverse_transform(np.arange(NUM_CLASSES))\ntarget_strings","2c5aa84a":"train_df,valid_df= train_test_split(final_df[final_df.split=='train'], test_size=0.20, random_state=42, stratify=final_df[final_df.split=='train']['label'])\ntrain_df.reset_index(inplace = True)\nvalid_df.reset_index(inplace = True)","2c2dc1a7":"test_df=final_df[final_df.split=='test']","4200e01a":"import torch\nfrom torch import nn\nfrom torch import sigmoid\nfrom torch.nn import functional as F\nfrom torch.utils.data import TensorDataset, DataLoader, Dataset\n\nimport cv2\nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2\nfrom copy import deepcopy\n\nfrom fastai.vision.all import *","e15c0980":"class CustomImageDataset(Dataset):\n    def __init__(self, data_frame, transform=None):\n        self.img_labels = data_frame['label_enc']\n        self.img_path = data_frame['file_path']\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.img_labels)\n\n    def __getitem__(self, idx):\n        image = cv2.imread(self.img_path.iloc[idx])\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        label = self.img_labels.iloc[idx].astype(np.long)\n        if self.transform is not None:\n            image = self.transform(image=image)[\"image\"]\n        return image, label","6d990bfb":"train_transform = A.Compose(\n    [\n        A.SmallestMaxSize(max_size=256),\n        A.ShiftScaleRotate(shift_limit=0.05, scale_limit=0.05, rotate_limit=15, p=0.5),\n        A.RandomCrop(height=224, width=224),\n        A.RGBShift(r_shift_limit=15, g_shift_limit=15, b_shift_limit=15, p=0.5),\n        A.RandomBrightnessContrast(p=0.5),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\n\nval_transform = A.Compose(\n    [\n        A.SmallestMaxSize(max_size=256),\n        A.CenterCrop(height=224, width=224),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ])","030a07cb":"train_data = CustomImageDataset(data_frame=train_df,transform=train_transform)\nvalid_data = CustomImageDataset(data_frame=valid_df,transform=val_transform)\ntest_data = CustomImageDataset(data_frame=test_df,transform=val_transform)\n\ntrainloader = DataLoader(train_data, batch_size=32, shuffle=True)\nvalidloader = DataLoader(valid_data, batch_size=256, shuffle=False)\ntestloader = DataLoader(test_data, batch_size=256, shuffle=False)","2d32c839":"def visualize_augmentations(dataset, idx=0, samples=10, cols=5):\n    dataset = deepcopy(dataset)\n    dataset.transform = A.Compose([t for t in dataset.transform if not isinstance(t, (A.Normalize, ToTensorV2))])\n    rows = samples \/\/ cols\n    figure, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(12, 6))\n    for i in range(samples):\n        image, _ = dataset[idx]\n        ax.ravel()[i].imshow(image)\n        ax.ravel()[i].set_axis_off()\n    plt.tight_layout()\n    plt.show()","a7e4a0b1":"random.seed(42)\nvisualize_augmentations(train_data)","c31724da":"import timm\ntimm.list_models('efficientnet_b*')","e3b065b6":"#https:\/\/discuss.pytorch.org\/t\/partial-transfer-learning-efficientnet\/109689\/2\ndef get_model(model_name):\n    model = timm.create_model(model_name, pretrained=True)\n    model.reset_classifier(NUM_CLASSES)\n    return model\n\nmodel = get_model('efficientnet_b0')\nfor name, _ in model.named_children():\n    print(name)\n\nfor param in model.parameters():\n    param.requires_grad_(False)\n\nblocks_to_retrain = 1\ncount = 0\nfor name, block in model.blocks.named_children():\n    if count >= (len(model.blocks) - blocks_to_retrain):\n        print(f'Unfreeze block {name}')\n        for pname, params in block.named_parameters():\n            if 'bn' not in pname:\n                params.requires_grad = True\n    else:\n        print(f'Keep block {name} frozen')\n    count += 1\n\n\nfor name, child in model.named_children():\n    if name in [ 'conv_head', 'act2', 'global_pool', 'classifier']:\n        print(f'Unfreeze block {name}')\n        for params in child.parameters():\n            params.requires_grad == True\n","7a4b05f5":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel.to(device);","961836d0":"data = DataLoaders(trainloader, validloader)\nlearn = Learner(data, \n                model, \n                loss_func=CrossEntropyLossFlat(), \n                opt_func=Adam, \n                metrics=accuracy)","82f1ba93":"learn.fit(2)","cf1d7a7b":"learn.save('myModel', with_opt=False)","7df2865a":"def predict(model, dataloader, n_class, device):\n    model.eval()\n    model.to(device)\n    preds = np.zeros([0, n_class])\n    for data, _ in dataloader:\n        data = data.to(device)\n        with torch.no_grad():\n            y_pred = model(data).detach()\n        y_pred = y_pred.cpu().numpy()\n        preds = np.concatenate([preds, y_pred])\n    return preds","ac8e6c01":"test_preds = predict(model, testloader, n_class=NUM_CLASSES, device=device)","70986a88":"pred_label = np.argmax(test_preds, axis=1)\ntrue_label=test_df['label_enc'].to_numpy()","f2b713a5":"test_acc = skm.accuracy_score(true_label, pred_label)\n\nprint(f'test acc: {test_acc}')\nprint('\\nConfusion Matrix: \\n')\nprint(skm.confusion_matrix(true_label, pred_label))\nprint('\\nClassification Report:\\n')\nprint(skm.classification_report(true_label, pred_label, target_names=target_strings))","c2f0bdd1":"# Format Inputs","697eaa28":"# Check Prediction","025b2b9b":"# Pytorch - Datasets, Dataloaders, Model and training loop "}}