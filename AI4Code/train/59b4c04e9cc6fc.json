{"cell_type":{"195e39a7":"code","39714a4f":"code","c3e39ee1":"code","f7f40ad7":"code","f014e1d7":"code","d1f875cd":"code","c0cdb718":"code","38cbc6c3":"code","56c84ed3":"code","713914a9":"code","c89ea35f":"code","8ed224b6":"code","695696d6":"code","e336e3e8":"code","d0918e16":"code","8700a461":"code","b448ee26":"code","2527b199":"code","14a299f9":"code","d3939076":"code","611838a6":"code","4c0c836e":"code","abbf4acb":"code","03bf0a87":"code","7d719f34":"code","b7bf3253":"code","3a452e3a":"code","0e0c4c6c":"code","b58a294e":"code","bad869b1":"code","8cc9ed51":"code","1d41e268":"code","da5d1189":"code","2f4ee221":"code","0f9fd279":"code","376403d1":"code","e96f8ead":"code","302af769":"code","5cf4ba4e":"code","f71f414b":"code","1272af20":"code","f850593c":"code","1cd5ff58":"code","9b335ff7":"markdown","ff0a09c4":"markdown","481cddc8":"markdown","e93c653e":"markdown","1237915b":"markdown","a8441009":"markdown","6d7a5def":"markdown","288dded4":"markdown","6d707a41":"markdown","4dfda221":"markdown","e1a016b5":"markdown","2c2d4167":"markdown","cdb0c99a":"markdown","bf02c7bb":"markdown","a824e590":"markdown","671a9c82":"markdown","e9f9e54d":"markdown","838d1532":"markdown","aeb1c5f7":"markdown","8b678c07":"markdown","b6a76025":"markdown","1e597628":"markdown","832d8278":"markdown","cac878a8":"markdown","651ca56e":"markdown","a7c53e3e":"markdown","7551d4de":"markdown","84803ef1":"markdown","2904493e":"markdown","04df425d":"markdown"},"source":{"195e39a7":"import numpy as np \nimport pandas as pd \nimport seaborn as sns\nimport matplotlib.pyplot as plt \nimport plotly.express as px\nimport plotly.graph_objects as go\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nnp.random.seed(123)","39714a4f":"Id1=np.random.randint(-2,3,1000)\nId2=np.random.randint(-2,3,1000)","c3e39ee1":"startD1=1\nstartD2=1","f7f40ad7":"def rule1(s1, s2, move1, move2, Border1=[0,1000], Border2=[0,1000]):\n    \n    path1=[]\n    path2=[]\n    \n    for i, m1 in enumerate(move1):\n        s1=s1+m1\n        if s1 <= Border1[0] or s1 >= Border1[1]:\n            s1=s1-m1\n        \n        m2=move2[i]\n        s2=s2+m2\n        if s2 <= Border2[0] or s2 >= Border2[1]:\n            s2=s2-m2  \n            \n        path1.append(s1)    \n        path2.append(s2)    \n            \n    return path1, path2","f014e1d7":"p1, p2 = rule1(startD1, startD2, Id1, Id2)","d1f875cd":"s=sns.JointGrid(x=p1, y=p2, height=12, ratio=5, palette=\"viridis\")\ns.plot_joint(sns.scatterplot, s=40, alpha=0.9)\ns.plot_marginals(sns.kdeplot, cut=0)\nax = plt.gca()","c0cdb718":"p1, p2 = rule1(50, 50, Id1, Id2)","38cbc6c3":"s=sns.JointGrid(x=p1, y=p2, height=12, ratio=5, palette=\"viridis\")\ns.plot_joint(sns.scatterplot, s=40, alpha=0.9)\ns.plot_marginals(sns.kdeplot, cut=0)\nax = plt.gca()","56c84ed3":"def rule2(s1, s2, move1, move2, store1, showDist: bool, Border1=[0,1000], Border2=[0,1000], purview=5, gravity=1.1):\n    \n    path1=[]\n    path2=[]\n    \n    for i, m1 in enumerate(move1):\n        s1=s1+m1\n        if s1 <= Border1[0] or s1 >= Border1[1]:\n            s1=s1-m1\n        \n        m2=move2[i]\n        s2=s2+m2\n        if s2 <= Border2[0] or s2 >= Border2[1]:\n            s2=s2-m2 \n            \n        distanceToStore = ((s1-store1[0])**2+(s2-store1[1])**2)**0.5\n            \n        if distanceToStore <= purview:\n            if showDist==True:\n                print(distanceToStore)\n            s1 = s1 - np.sign(s1-store1[0]) * gravity\n            s2 = s2 - np.sign(s2-store1[1]) * gravity\n            \n        path1.append(s1)    \n        path2.append(s2)    \n            \n    return path1, path2","713914a9":"startD1=550\nstartD2=420\n\nstore=[540,420]\np1, p2 = rule2(startD1, startD2, Id1, Id2, store, showDist=False)\n\np1.insert(0, startD1)\np2.insert(0, startD2)\n\np=pd.DataFrame({\"p1\": p1,\"p2\": p2}, index=None)\n\np[\"state\"]=[\"start\" if i == 0 else \"move\" for i in range(len(p1))]\np[\"state\"]=[\"end\" if i == len(p1)-1 else p.loc[i,\"state\"] for i, v in enumerate(p1)]","c89ea35f":"s=sns.JointGrid(x=\"p1\", y=\"p2\", data=p, height=12, ratio=5, palette=\"viridis\")\ns.plot_joint(sns.scatterplot, hue=p.state)\ns.plot_marginals(sns.kdeplot, cut=0)\ns.refline(x=store[0], y=store[1])\ns.plot_joint(sns.kdeplot, color=\"r\", zorder=0, levels=4)\nax = plt.gca()","8ed224b6":"def rule3(s1, s2, move1, move2, store1, store2, Border1=[0,1000], Border2=[0,1000], purview=5, gravity=0.5):\n    \n    path1=[]\n    path2=[]\n    \n    for i, m1 in enumerate(move1):\n        s1=s1+m1\n        if s1 <= Border1[0] or s1 >= Border1[1]:\n            s1=s1-m1\n        \n        m2=move2[i]\n        s2=s2+m2\n        if s2 <= Border2[0] or s2 >= Border2[1]:\n            s2=s2-m2 \n            \n        distanceToStore1 = ((s1-store1[0])**2+(s2-store1[1])**2)**0.5\n            \n        if distanceToStore1 <= purview:\n            s1 = s1 - np.sign(s1-store1[0]) * gravity\n            s2 = s2 - np.sign(s2-store1[1]) * gravity\n            \n        distanceToStore2 = ((s1-store2[0])**2+(s2-store2[1])**2)**0.5\n            \n        if distanceToStore2 <= purview:\n            s1 = s1 - np.sign(s1-store2[0]) * gravity \n            s2 = s2 - np.sign(s2-store2[1]) * gravity \n            \n        path1.append(s1)    \n        path2.append(s2)    \n            \n    return path1, path2","695696d6":"startD1=550\nstartD2=420\n\nstore1=[540,420]\nstore2=[525,435]\n\np1, p2 = rule3(startD1, startD2, Id1, Id2, store1, store2, purview=5, gravity=1.1)\n\np1.insert(0, startD1)\np2.insert(0, startD2)\n\np=pd.DataFrame({\"p1\": p1,\"p2\": p2}, index=None)\n\np[\"state\"]=[\"start\" if i == 0 else \"move\" for i in range(len(p1))]\np[\"state\"]=[\"end\" if i == len(p1)-1 else p.loc[i,\"state\"] for i, v in enumerate(p1)]\np[\"size\"]=[1 if i != \"move\" else 0.2 for i in p.state.values]","e336e3e8":"p.reset_index(inplace=True)\nfig=px.scatter(\n    p, x=\"p1\", y=\"p2\", animation_frame=\"index\",\n    labels={\"index\": \"Time Step\", \"p1\": \"Position 1\", \"p2\": \"Position 2\"},\n    hover_data={\"index\": True, \"p1\": True, \"p2\": True, \"size\": False},\n    size=\"size\",\n    hover_name=\"state\",\n    size_max=55, range_x=[510,570], range_y=[380,460]\n)\nfig.add_trace(go.Scatter(\n    x=[540, 525],\n    y=[420, 435],\n    mode='markers',\n    marker=dict(size=[125, 125],\n                color=[2, 2])\n))\nfig.add_shape(type=\"rect\",\n    x0=539.5, y0=419, x1=540.5, y1=421,\n    line=dict(\n        color=\"RoyalBlue\",\n        width=2,\n    ),\n    fillcolor=\"Black\",\n)\nfig.add_shape(\n    type=\"rect\",\n    x0=524.5, y0=434, x1=525.5, y1=436,\n    line=dict(\n        color=\"RoyalBlue\",\n        width=2,\n    ),\n    fillcolor=\"Black\",\n)\nfig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30\nfig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 5\nfig.update_traces(showlegend=False)\n\nfig.show()","d0918e16":"startD1=550\nstartD2=420\n\nstore1=[540,440]\nstore2=[525,435]\n\np1, p2 = rule3(startD1, startD2, Id1, Id2, store1, store2, purview=5, gravity=1.1)\n\np1.insert(0, startD1)\np2.insert(0, startD2)\n\np=pd.DataFrame({\"p1\": p1,\"p2\": p2}, index=None)\n\np[\"state\"]=[\"start\" if i == 0 else \"move\" for i in range(len(p1))]\np[\"state\"]=[\"end\" if i == len(p1)-1 else p.loc[i,\"state\"] for i, v in enumerate(p1)]\np[\"size\"]=[1 if i != \"move\" else 0.2 for i in p.state.values]","8700a461":"p.reset_index(inplace=True)\nfig=px.scatter(\n    p, x=\"p1\", y=\"p2\", animation_frame=\"index\",\n    labels={\"index\": \"Time Step\", \"p1\": \"Position 1\", \"p2\": \"Position 2\"},\n    hover_data={\"index\": True, \"p1\": True, \"p2\": True, \"size\": False},\n    size=\"size\",\n    hover_name=\"state\",\n    size_max=55, range_x=[510,570], range_y=[380,460]\n)\nfig.add_trace(go.Scatter(\n    x=[540, 525],\n    y=[440, 435],\n    mode='markers',\n    marker=dict(size=[125, 125],\n                color=[2, 2])\n))\nfig.add_shape(type=\"rect\",\n    x0=539.5, y0=439, x1=540.5, y1=441,\n    line=dict(\n        color=\"RoyalBlue\",\n        width=2,\n    ),\n    fillcolor=\"Black\",\n)\nfig.add_shape(\n    type=\"rect\",\n    x0=524.5, y0=434, x1=525.5, y1=436,\n    line=dict(\n        color=\"RoyalBlue\",\n        width=2,\n    ),\n    fillcolor=\"Black\",\n)\nfig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30\nfig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 5\nfig.update_traces(showlegend=False)\nfig.show()","b448ee26":"def rule4(s1, s2, move1, move2, bankrupt, Border1=[0,1000], Border2=[0,1000], purview=5, gravity=0.5, revenue=1.5, costs=0.00, EarnArea=0.5, **storeLocations):\n    \n    for i in range(1,len(storeLocations)+1):\n        globals()[f\"path{i}\"]=[]\n    \n    for i in range(1,len(storeLocations)+1):\n        globals()[f\"earn{i}\"]=[]\n    \n    for i, m1 in enumerate(move1):\n        s1=s1+m1\n        if s1 <= Border1[0] or s1 >= Border1[1]:\n            s1=s1-m1\n        \n        m2=move2[i]\n        s2=s2+m2\n        if s2 <= Border2[0] or s2 >= Border2[1]:\n            s2=s2-m2 \n        \n        for i in range(1,len(storeLocations)+1): \n            if bankrupt[i-1] != f\"store{i}\":   \n                globals()[f\"distanceToStore{i}\"] = ((s1-storeLocations[f\"store{i}\"][0])**2+(s2-storeLocations[f\"store{i}\"][1])**2)**0.5\n                if globals()[f\"distanceToStore{i}\"] <= purview:\n                    s1 = s1 - np.sign(s1-storeLocations[f\"store{i}\"][0]) * gravity\n                    s2 = s2 - np.sign(s2-storeLocations[f\"store{i}\"][1]) * gravity\n\n                if globals()[f\"distanceToStore{i}\"] <= purview * EarnArea:\n                    globals()[f\"e{i}\"]=revenue-costs\n                else:\n                    globals()[f\"e{i}\"]=-costs            \n        \n        path1.append(s1)    \n        path2.append(s2)   \n        \n        for i in range(1,len(storeLocations)+1):\n            if bankrupt[i-1] != f\"store{i}\":\n                globals()[f\"earn{i}\"].append(globals()[f\"e{i}\"]) \n            else:\n                globals()[f\"earn{i}\"].append(0)\n                \n    return path1, path2, [globals()[f\"earn{i}\"] for i in range(1,len(storeLocations)+1)]","2527b199":"startD1=550\nstartD2=420\n\nstores={\"store1\":[540,420], \"store2\":[530,440]}\n\np1, p2, earningsStore = rule4(startD1, startD2, Id1, Id2, bankrupt=[None,None], **stores, purview=5, gravity=1.1)\n\nStore1=pd.DataFrame({\"earnings\": earningsStore[0]}, index=None)\nStore1[\"Cumulated\"]=Store1.earnings.cumsum()\nStore1[\"Store\"]=\"Store 1\"\nStore2=pd.DataFrame({\"earnings\": earningsStore[1]}, index=None)\nStore2[\"Cumulated\"]=Store2.earnings.cumsum()\nStore2[\"Store\"]=\"Store 2\"\n\nearnings=pd.concat([Store1, Store2])","14a299f9":"fig = px.area(earnings, facet_col=\"Store\", facet_col_wrap=2, labels={\"index\": \"Time Step\"})\nfig.show()","d3939076":"startD1=550\nstartD2=420\n\nstores={\"store1\":[540,420], \"store2\":[536,424]}\n\np1, p2, earningsStore = rule4(startD1, startD2, Id1, Id2, bankrupt=[None,None], **stores, purview=5, gravity=1.1)\n\nStore1=pd.DataFrame({\"earnings\": earningsStore[0]}, index=None)\nStore1[\"Cumulated\"]=Store1.earnings.cumsum()\nStore1[\"Store\"]=\"Store 1\"\nStore2=pd.DataFrame({\"earnings\": earningsStore[1]}, index=None)\nStore2[\"Cumulated\"]=Store2.earnings.cumsum()\nStore2[\"Store\"]=\"Store 2\"\n\nearnings=pd.concat([Store1, Store2])","611838a6":"fig = px.area(earnings, facet_col=\"Store\", facet_col_wrap=2, labels={\"index\": \"Time Step\"})\nfig.show()","4c0c836e":"NoCustomers=1000\n\nbnkrpt=[None,None]\n\nrevAfterCustomer1=[]\nrevAfterCustomer2=[]\n\nfor k in range(NoCustomers):\n    \n    np.random.seed(123+k)\n    \n    Id1=np.random.randint(-2,3,1000)\n    Id2=np.random.randint(-2,3,1000)\n    \n    startD1=np.random.randint(low=1, high=999, size=1)[0]\n    startD2=np.random.randint(low=1, high=999, size=1)[0]\n\n    stores={\"store1\":[540,420], \"store2\":[200,200]}\n    p1, p2, EarningsStore = rule4(startD1, startD2, Id1, Id2, purview=5, gravity=1.1, costs=0.0005, **stores, bankrupt=bnkrpt)\n    \n    if k == 0:\n        EarningsStore1=np.array(EarningsStore[0])\n        EarningsStore2=np.array(EarningsStore[1])\n    else:\n        EarningsStore1=EarningsStore1+np.array(EarningsStore[0])\n        EarningsStore2=EarningsStore2+np.array(EarningsStore[1])\n    \n    Store1=pd.DataFrame({\"earnings\": EarningsStore1}, index=None)\n    Store1[\"total_earnings\"] = Store1.earnings.cumsum()\n    Store1[\"store\"]=\"Store 1\"\n    \n    Store2=pd.DataFrame({\"earnings\": EarningsStore2}, index=None)\n    Store2[\"total_earnings\"] = Store2.earnings.cumsum()\n    Store2[\"store\"]=\"Store 2\"\n    \n    bankruptStore1From=NoCustomers-1\n    if Store1.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[0] != \"store1\" and k>NoCustomers*0.75:\n            bankruptStore1From=k\n            brS1=bankruptStore1From\n            print(\"store 1 bankrupt after\", bankruptStore1From, \"customers\")\n        bnkrpt[0] = \"store1\"  \n    \n    bankruptStore2From=NoCustomers-1\n    if Store2.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[1] != \"store2\" and k>NoCustomers*0.75:\n            bankruptStore2From=k\n            brS2=bankruptStore2From\n            print(\"store 2 bankrupt after\", bankruptStore2From, \"customers\")\n        bnkrpt[1] = \"store2\"  \n        \n    revAfterCustomer1.append(Store1.total_earnings[NoCustomers-1])\n    revAfterCustomer2.append(Store2.total_earnings[NoCustomers-1])  \n\nearnings=pd.concat([Store1, Store2])\n\nrevAfterCustomer=revAfterCustomer1+revAfterCustomer2\nRevByCustomer=pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                            \"store\": [1]*NoCustomers+[2]*NoCustomers\n                           }, index=None)","abbf4acb":"fig = px.area(earnings[[\"store\", \"earnings\", \"total_earnings\"]], facet_col=\"store\", facet_col_wrap=2, title= \"store 2 bankrupt after \" + str(brS2) + \" customers\", labels={\"index\": \"Time Step\"})\nfig.show()","03bf0a87":"RevByCustomer.set_index(pd.Index(list(range(1000))+list(range(1000))), drop=True, inplace=True)\nfig = px.area(RevByCustomer[[\"store\", \"EarningsByCustomers\"]], facet_col=\"store\",  facet_col_wrap=2, labels={\"value\": \"Earnings by Customers\", \"index\": \"Customer\"})\nfig.add_vline(x=brS2, line_width=3, line_dash=\"dash\", line_color=\"red\", col=2, annotation_text=\"bankrupt\", annotation_position=\"top left\")\nfig.update_traces(showlegend=False)\nfig.show()","7d719f34":"NoCustomers=1000\n\nbnkrpt=[None,None]\n\nrevAfterCustomer1=[]\nrevAfterCustomer2=[]\n\nfor k in range(NoCustomers):\n    \n    np.random.seed(123+k)\n    \n    Id1=np.random.randint(-2,3,1000)\n    Id2=np.random.randint(-2,3,1000)\n    \n    startD1=np.random.randint(low=1, high=999, size=1)[0]\n    startD2=np.random.randint(low=1, high=999, size=1)[0]\n\n    stores={\"store1\":[540,420], \"store2\":[500,400]}\n    p1, p2, EarningsStore = rule4(startD1, startD2, Id1, Id2, purview=5, gravity=1.1, costs=0.0005, **stores, bankrupt=bnkrpt)\n    \n    if k == 0:\n        EarningsStore1=np.array(EarningsStore[0])\n        EarningsStore2=np.array(EarningsStore[1]) \n    else:\n        EarningsStore1=EarningsStore1+np.array(EarningsStore[0])\n        EarningsStore2=EarningsStore2+np.array(EarningsStore[1])\n    \n    Store1=pd.DataFrame({\"earnings\": EarningsStore1}, index=None)\n    Store1[\"total_earnings\"] = Store1.earnings.cumsum()\n    Store1[\"store\"]=\"Store 1\"\n    \n    Store2=pd.DataFrame({\"earnings\": EarningsStore2}, index=None)\n    Store2[\"total_earnings\"] = Store2.earnings.cumsum()\n    Store2[\"store\"]=\"Store 2\"\n    \n    bankruptStore1From=NoCustomers-1\n    if Store1.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[0] != \"store1\" and k>NoCustomers*0.75:\n            bankruptStore1From=k\n            brS1=bankruptStore1From\n            print(\"store 1 bankrupt after\", bankruptStore1From, \"customers\")\n        bnkrpt[0] = \"store1\"  \n    \n    bankruptStore2From=NoCustomers-1\n    if Store2.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[1] != \"store2\" and k>NoCustomers*0.75:\n            bankruptStore2From=k\n            brS2=bankruptStore2From\n            print(\"store 2 bankrupt after\", bankruptStore2From, \"customers\")\n        bnkrpt[1] = \"store2\"  \n        \n    revAfterCustomer1.append(Store1.total_earnings[NoCustomers-1])\n    revAfterCustomer2.append(Store2.total_earnings[NoCustomers-1])  \n\nearnings=pd.concat([Store1, Store2])\n\nrevAfterCustomer=revAfterCustomer1+revAfterCustomer2\nRevByCustomer=pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                            \"store\": [1]*NoCustomers+[2]*NoCustomers\n                           }, index=None)","b7bf3253":"fig = px.area(earnings[[\"store\", \"earnings\", \"total_earnings\"]], facet_col=\"store\", facet_col_wrap=2, labels={\"index\": \"Time Step\"})\n\nfig.show()","3a452e3a":"RevByCustomer.set_index(pd.Index(list(range(1000))+list(range(1000))), drop=True, inplace=True)\nfig = px.area(RevByCustomer[[\"store\", \"EarningsByCustomers\"]], facet_col=\"store\",  facet_col_wrap=2, labels={\"value\": \"Earnings by Customers\", \"index\": \"Customer\"})\nfig.add_vline(x=brS1, line_width=3, line_dash=\"dash\", line_color=\"red\", col=1, annotation_text=\"bankrupt\", annotation_position=\"top left\")\nfig.update_traces(showlegend=False)\nfig.show()","0e0c4c6c":"NoCustomers=1000\n\nbnkrpt=[None, None, None, None]\n\nrevAfterCustomer1=[]\nrevAfterCustomer2=[]\nrevAfterCustomer3=[]\nrevAfterCustomer4=[]\n\nfor k in range(NoCustomers):\n    \n    np.random.seed(123+k)\n    \n    Id1=np.random.randint(-2,3,1000)\n    Id2=np.random.randint(-2,3,1000)\n    \n    startD1=np.random.randint(low=1, high=999, size=1)[0]\n    startD2=np.random.randint(low=1, high=999, size=1)[0]\n\n    stores={\"store1\":[540,420], \"store2\":[530,410], \"store3\":[520,430], \"store4\":[100,100]}\n    p1, p2, EarningsStore = rule4(startD1, startD2, Id1, Id2, purview=5, gravity=1.1, costs=0.0005, **stores, bankrupt=bnkrpt)\n    \n    if k == 0:\n        EarningsStore1=np.array(EarningsStore[0])\n        EarningsStore2=np.array(EarningsStore[1])\n        EarningsStore3=np.array(EarningsStore[2]) \n        EarningsStore4=np.array(EarningsStore[3])\n    else:\n        EarningsStore1=EarningsStore1+np.array(EarningsStore[0])\n        EarningsStore2=EarningsStore2+np.array(EarningsStore[1])\n        EarningsStore3=EarningsStore3+np.array(EarningsStore[2])\n        EarningsStore4=EarningsStore4+np.array(EarningsStore[3])\n    \n    Store1=pd.DataFrame({\"earnings\": EarningsStore1}, index=None)\n    Store1[\"total_earnings\"] = Store1.earnings.cumsum()\n    Store1[\"store\"]=\"Store 1\"\n    \n    Store2=pd.DataFrame({\"earnings\": EarningsStore2}, index=None)\n    Store2[\"total_earnings\"] = Store2.earnings.cumsum()\n    Store2[\"store\"]=\"Store 2\"\n    \n    Store3=pd.DataFrame({\"earnings\": EarningsStore3}, index=None)\n    Store3[\"total_earnings\"] = Store3.earnings.cumsum()\n    Store3[\"store\"]=\"Store 3\"\n    \n    Store4=pd.DataFrame({\"earnings\": EarningsStore4}, index=None)\n    Store4[\"total_earnings\"] = Store4.earnings.cumsum()\n    Store4[\"store\"]=\"Store 4\"\n    \n    bankruptStore1From=NoCustomers-1\n    if Store1.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[0] != \"store1\" and k>NoCustomers*0.75:\n            bankruptStore1From=k\n            brS1=bankruptStore1From\n            print(\"Store 1 bankrupt after\", bankruptStore1From, \"customers\")\n        bnkrpt[0] = \"store1\"  \n        \n    bankruptStore2From=NoCustomers-1\n    if Store2.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[1] != \"store2\" and k>NoCustomers*0.75:\n            bankruptStore2From=k\n            brS2=bankruptStore2From\n            print(\"Store 2 bankrupt after\", bankruptStore2From, \"customers\")\n        bnkrpt[1] = \"store2\"  \n        \n    bankruptStore3From=NoCustomers-1\n    if Store3.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[2] != \"store3\" and k>NoCustomers*0.75:\n            bankruptStore3From=k\n            brS3=bankruptStore3From\n            print(\"Store 3 bankrupt after\", bankruptStore3From, \"customers\")\n        bnkrpt[2] = \"store3\"  \n        \n    bankruptStore4From=NoCustomers-1\n    if Store4.total_earnings[NoCustomers-1] < 0 and k > NoCustomers*0.75:\n        if bnkrpt[3] != \"store4\" and k>NoCustomers*0.75:\n            bankruptStore4From=k\n            brS4=bankruptStore4From\n            print(\"Store 4 bankrupt after\", bankruptStore4From, \"customers\")\n        bnkrpt[3] = \"store4\"  \n        \n    revAfterCustomer1.append(Store1.total_earnings[NoCustomers-1])\n    revAfterCustomer2.append(Store2.total_earnings[NoCustomers-1])  \n    revAfterCustomer3.append(Store3.total_earnings[NoCustomers-1])\n    revAfterCustomer4.append(Store4.total_earnings[NoCustomers-1])\n\nearnings=pd.concat([Store1, Store2, Store3, Store4])\nrevAfterCustomer=revAfterCustomer1+revAfterCustomer2+revAfterCustomer3+revAfterCustomer4\nearnings[\"EarningsByCustomers\"]=revAfterCustomer","b58a294e":"fig = px.area(earnings[[\"store\", \"earnings\", \"total_earnings\"]], facet_col=\"store\", facet_col_wrap=2, labels={\"index\": \"Time Step\"})\nfig.show()","bad869b1":"fig = px.area(earnings[[\"store\", \"EarningsByCustomers\"]], facet_col=\"store\", facet_col_wrap=2, labels={\"value\": \"Earnings by Customers\", \"index\": \"Customer\"})\nfig.add_vline(x=brS3, line_width=3, line_dash=\"dash\", line_color=\"red\", col=1, row=1, annotation_text=\"bankrupt\", annotation_position=\"top left\")\nfig.update_traces(showlegend=False)\nfig.show()","8cc9ed51":"NoCustomers=10000\n\nfor l in range(9):\n    \n    bnkrpt=[None, None, None, None]\n    \n    revAfterCustomer=[]\n\n    revAfterCustomer1=[]\n    revAfterCustomer2=[]\n    revAfterCustomer3=[]\n    revAfterCustomer4=[]\n    \n    s4Location=100+l*50\n\n    for k in range(NoCustomers):\n\n        np.random.seed(123+k)\n\n        Id1=np.random.randint(-2,3,1000)\n        Id2=np.random.randint(-2,3,1000)\n\n        startD1=np.random.randint(low=1, high=999, size=1)[0]\n        startD2=np.random.randint(low=1, high=999, size=1)[0]\n\n        stores={\"store1\": [520,490], \"store2\": [510,520], \"store3\": [500,480], \"store4\": [s4Location, s4Location]}\n        p1, p2, EarningsStore = rule4(startD1, startD2, Id1, Id2, purview=10, EarnArea=0.25, gravity=1.1, costs=0.0005, **stores, bankrupt=bnkrpt)\n\n  \n        if k == 0:\n            EarningsStore1=np.array(EarningsStore[0])\n            EarningsStore2=np.array(EarningsStore[1])\n            EarningsStore3=np.array(EarningsStore[2])\n            EarningsStore4=np.array(EarningsStore[3])  \n        else:\n            EarningsStore1=EarningsStore1+np.array(EarningsStore[0])\n            EarningsStore2=EarningsStore2+np.array(EarningsStore[1])\n            EarningsStore3=EarningsStore3+np.array(EarningsStore[2])\n            EarningsStore4=EarningsStore4+np.array(EarningsStore[3])\n\n        Store1=pd.DataFrame({\"earnings\": EarningsStore1}, index=None)\n        Store1[\"total_earnings\"] = Store1.earnings.cumsum()\n        Store1[\"store\"]=\"Store 1\"\n\n        Store2=pd.DataFrame({\"earnings\": EarningsStore2}, index=None)\n        Store2[\"total_earnings\"] = Store2.earnings.cumsum()\n        Store2[\"store\"]=\"Store 2\"\n\n        Store3=pd.DataFrame({\"earnings\": EarningsStore3}, index=None)\n        Store3[\"total_earnings\"] = Store3.earnings.cumsum()\n        Store3[\"store\"]=\"Store 3\"\n\n        Store4=pd.DataFrame({\"earnings\": EarningsStore4}, index=None)\n        Store4[\"total_earnings\"] = Store4.earnings.cumsum()\n        Store4[\"store\"]=\"Store 4\"\n\n        bankruptStore1From=NoCustomers-1\n        if Store1.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[0] != \"store1\":\n                bankruptStore1From=k\n                print(\"Store 1 bankrupt after\", bankruptStore1From, \"customers\")\n            bnkrpt[0] = \"store1\"  \n\n        bankruptStore2From=NoCustomers-1\n        if Store2.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[1] != \"store2\":\n                bankruptStore2From=k\n                print(\"Store 2 bankrupt after\", bankruptStore2From, \"customers\")\n            bnkrpt[1] = \"store2\"  \n\n        bankruptStore3From=NoCustomers-1\n        if Store3.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[2] != \"store3\":\n                bankruptStore3From=k\n                print(\"Store 3 bankrupt after\", bankruptStore3From, \"customers\")\n            bnkrpt[2] = \"store3\"  \n\n        bankruptStore4From=NoCustomers-1\n        if Store4.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[3] != \"store4\":\n                bankruptStore4From=k\n                print(\"Store 4 bankrupt after\", bankruptStore4From, \"customers\")\n            bnkrpt[3] = \"store4\"  \n\n        revAfterCustomer1.append(Store1.total_earnings[999])\n        revAfterCustomer2.append(Store2.total_earnings[999])  \n        revAfterCustomer3.append(Store3.total_earnings[999])\n        revAfterCustomer4.append(Store4.total_earnings[999])\n    \n    if l==0:\n        earnings=pd.concat([Store1, Store2, Store3, Store4])\n        earnings[\"locationStore4\"]=s4Location\n        revAfterCustomer=revAfterCustomer1+revAfterCustomer2+revAfterCustomer3+revAfterCustomer4\n        RevByCustomer=pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                                    \"locationStore4\": s4Location, \n                                    \"store\": [1]*NoCustomers+[2]*NoCustomers+[3]*NoCustomers+[4]*NoCustomers\n                                   }, index=None)\n    else:\n        earningsTMP=pd.concat([Store1, Store2, Store3, Store4])\n        earningsTMP[\"locationStore4\"]=s4Location\n        earnings=pd.concat([earnings, earningsTMP])\n        revAfterCustomer=revAfterCustomer+revAfterCustomer1+revAfterCustomer2+revAfterCustomer3+revAfterCustomer4\n        RevByCustomer=pd.concat([RevByCustomer ,pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                                                              \"locationStore4\": s4Location,\n                                                              \"store\": [1]*NoCustomers+[2]*NoCustomers+[3]*NoCustomers+[4]*NoCustomers\n                                                             }, index=None)])","1d41e268":"RevByCustomer=RevByCustomer.loc[RevByCustomer.index.isin([NoCustomers-1,NoCustomers*2-1,NoCustomers*3-1,NoCustomers*4-1]),:]\nRevByCustomer.set_index(\"locationStore4\", drop=True, inplace=True)","da5d1189":"for l in range(9):\n    s4Location=100+l*50\n    df=earnings.loc[earnings.locationStore4 == s4Location]\n    fig = px.area(df[[\"store\", \"earnings\", \"total_earnings\"]], facet_col=\"store\", facet_col_wrap=2, title=\"Store Location \"+str(s4Location)+\" \"+str(s4Location), labels={\"index\": \"Time Step\"})\n\n    fig.show()","2f4ee221":"fig = px.area(RevByCustomer[[\"store\", \"EarningsByCustomers\"]], facet_col=\"store\", facet_col_wrap=2, labels={\"value\": \"Earnings by Customers\", \"index\": \"Customer\"})\nfig.update_traces(showlegend=False)\nfig.show()","0f9fd279":"def rule5(s1, s2, move1, move2, bankrupt, Border1=[0,1000], Border2=[0,1000], \n          purview=10, gravity=0.5, revenue=1.5, costs=0.00, EarnArea=0.25, bdgt=200, **storeLocations):\n    \n    for i in range(1,len(storeLocations)+1):\n        globals()[f\"path{i}\"]=[]\n    \n    for i in range(1,len(storeLocations)+1):\n        globals()[f\"earn{i}\"]=[]\n    \n    for i, m1 in enumerate(move1):\n        s1=s1+m1\n        if s1 <= Border1[0] or s1 >= Border1[1]:\n            s1=s1-m1\n        \n        m2=move2[i]\n        s2=s2+m2\n        if s2 <= Border2[0] or s2 >= Border2[1]:\n            s2=s2-m2 \n        \n        for i in range(1,len(storeLocations)+1): \n            if bankrupt[i-1] != f\"store{i}\":   \n                globals()[f\"distanceToStore{i}\"] = ((s1-storeLocations[f\"store{i}\"][0])**2+(s2-storeLocations[f\"store{i}\"][1])**2)**0.5\n                if globals()[f\"distanceToStore{i}\"] <= purview:\n                    s1 = s1 - np.sign(s1-storeLocations[f\"store{i}\"][0]) * gravity\n                    s2 = s2 - np.sign(s2-storeLocations[f\"store{i}\"][1]) * gravity\n\n                if globals()[f\"distanceToStore{i}\"] <= purview * EarnArea and bdgt > 0:\n                    globals()[f\"e{i}\"]=revenue-costs\n                    bdgt -= 1\n                else:\n                    globals()[f\"e{i}\"]=-costs            \n        \n        path1.append(s1)    \n        path2.append(s2)   \n        \n        for i in range(1,len(storeLocations)+1):\n            if bankrupt[i-1] != f\"store{i}\":\n                globals()[f\"earn{i}\"].append(globals()[f\"e{i}\"]) \n            else:\n                globals()[f\"earn{i}\"].append(0)\n                \n    return path1, path2, [globals()[f\"earn{i}\"] for i in range(1,len(storeLocations)+1)]","376403d1":"NoCustomers=10000\n\nfor l in range(9):\n    \n    bnkrpt=[None, None, None, None]\n    \n    revAfterCustomer=[]\n\n    revAfterCustomer1=[]\n    revAfterCustomer2=[]\n    revAfterCustomer3=[]\n    revAfterCustomer4=[]\n    \n    s4Location=100+l*50\n\n    for k in range(NoCustomers):\n\n        np.random.seed(123+k)\n\n        Id1=np.random.randint(-2,3,1000)\n        Id2=np.random.randint(-2,3,1000)\n\n        startD1=np.random.randint(low=1, high=999, size=1)[0]\n        startD2=np.random.randint(low=1, high=999, size=1)[0]\n\n        stores={\"store1\": [520,490], \"store2\": [510,520], \"store3\": [500,480], \"store4\": [s4Location, s4Location]}\n        p1, p2, EarningsStore = rule5(startD1, startD2, Id1, Id2, gravity=1.1, costs=0.0005, **stores, bankrupt=bnkrpt)\n\n        if k == 0:\n            EarningsStore1=np.array(EarningsStore[0])\n            EarningsStore2=np.array(EarningsStore[1])\n            EarningsStore3=np.array(EarningsStore[2])\n            EarningsStore4=np.array(EarningsStore[3])\n        else:\n            EarningsStore1=EarningsStore1+np.array(EarningsStore[0])\n            EarningsStore2=EarningsStore2+np.array(EarningsStore[1])\n            EarningsStore3=EarningsStore3+np.array(EarningsStore[2])\n            EarningsStore4=EarningsStore4+np.array(EarningsStore[3])\n\n        Store1=pd.DataFrame({\"earnings\": EarningsStore1}, index=None)\n        Store1[\"total_earnings\"] = Store1.earnings.cumsum()\n        Store1[\"store\"]=\"Store 1\"\n\n        Store2=pd.DataFrame({\"earnings\": EarningsStore2}, index=None)\n        Store2[\"total_earnings\"] = Store2.earnings.cumsum()\n        Store2[\"store\"]=\"Store 2\"\n\n        Store3=pd.DataFrame({\"earnings\": EarningsStore3}, index=None)\n        Store3[\"total_earnings\"] = Store3.earnings.cumsum()\n        Store3[\"store\"]=\"Store 3\"\n\n        Store4=pd.DataFrame({\"earnings\": EarningsStore4}, index=None)\n        Store4[\"total_earnings\"] = Store4.earnings.cumsum()\n        Store4[\"store\"]=\"Store 4\"\n\n        bankruptStore1From=NoCustomers-1\n        if Store1.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[0] != \"store1\":\n                bankruptStore1From=k\n                print(\"Store 1 bankrupt after\", bankruptStore1From, \"customers\")\n            bnkrpt[0] = \"store1\"  \n\n        bankruptStore2From=NoCustomers-1\n        if Store2.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[1] != \"store2\":\n                bankruptStore2From=k\n                print(\"Store 2 bankrupt after\", bankruptStore2From, \"customers\")\n            bnkrpt[1] = \"store2\"  \n\n        bankruptStore3From=NoCustomers-1\n        if Store3.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[2] != \"store3\":\n                bankruptStore3From=k\n                print(\"Store 3 bankrupt after\", bankruptStore3From, \"customers\")\n            bnkrpt[2] = \"store3\"  \n\n        bankruptStore4From=NoCustomers-1\n        if Store4.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[3] != \"store4\":\n                bankruptStore4From=k\n                print(\"Store 4 bankrupt after\", bankruptStore4From, \"customers\")\n            bnkrpt[3] = \"store4\"  \n\n        revAfterCustomer1.append(Store1.total_earnings[999])\n        revAfterCustomer2.append(Store2.total_earnings[999])  \n        revAfterCustomer3.append(Store3.total_earnings[999])\n        revAfterCustomer4.append(Store4.total_earnings[999])\n    \n    if l==0:\n        earnings=pd.concat([Store1, Store2, Store3, Store4])\n        earnings[\"locationStore4\"]=s4Location\n        revAfterCustomer=revAfterCustomer1+revAfterCustomer2+revAfterCustomer3+revAfterCustomer4\n        RevByCustomer=pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                                    \"locationStore4\": s4Location, \n                                    \"store\": [1]*NoCustomers+[2]*NoCustomers+[3]*NoCustomers+[4]*NoCustomers\n                                   }, index=None)\n    else:\n        earningsTMP=pd.concat([Store1, Store2, Store3, Store4])\n        earningsTMP[\"locationStore4\"]=s4Location\n        earnings=pd.concat([earnings, earningsTMP])\n        revAfterCustomer=revAfterCustomer+revAfterCustomer1+revAfterCustomer2+revAfterCustomer3+revAfterCustomer4\n        RevByCustomer=pd.concat([RevByCustomer ,pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                                                              \"locationStore4\": s4Location,\n                                                              \"store\": [1]*NoCustomers+[2]*NoCustomers+[3]*NoCustomers+[4]*NoCustomers\n                                                             }, index=None)])","e96f8ead":"RevByCustomer=RevByCustomer.loc[RevByCustomer.index.isin([NoCustomers-1,NoCustomers*2-1,NoCustomers*3-1,NoCustomers*4-1]),:]\nRevByCustomer.set_index(\"locationStore4\", drop=True, inplace=True)","302af769":"for l in range(9):\n    s4Location=100+l*50\n    df=earnings.loc[earnings.locationStore4 == s4Location]\n    fig = px.area(df[[\"store\", \"earnings\", \"total_earnings\"]], facet_col=\"store\", facet_col_wrap=2, title=\"Store Location \"+str(s4Location)+\" \"+str(s4Location), labels={\"index\": \"Time Step\"})\n\n    fig.show()","5cf4ba4e":"fig = px.area(RevByCustomer[[\"store\", \"EarningsByCustomers\"]], facet_col=\"store\", facet_col_wrap=2, labels={\"value\": \"Earnings by Customers\", \"index\": \"Customer\"})\nfig.update_traces(showlegend=False)\nfig.show()","f71f414b":"NoCustomers=10000\n\nfor l in range(9):\n    \n    bnkrpt=[None, None, None, None]\n    \n    revAfterCustomer=[]\n\n    revAfterCustomer1=[]\n    revAfterCustomer2=[]\n    revAfterCustomer3=[]\n    revAfterCustomer4=[]\n    \n    s4Location=100+l*50\n\n    for k in range(NoCustomers):\n\n        np.random.seed(123+k)\n\n        Id1=np.random.randint(-2,3,1000)\n        Id2=np.random.randint(-2,3,1000)\n\n        startD1=np.random.randint(low=350, high=650, size=1)[0]\n        startD2=np.random.randint(low=350, high=650, size=1)[0]\n\n        stores={\"store1\": [520,490], \"store2\": [510,520], \"store3\": [500,480], \"store4\": [s4Location, s4Location]}\n        p1, p2, EarningsStore = rule5(startD1, startD2, Id1, Id2, gravity=1.1, costs=0.0005, **stores, bankrupt=bnkrpt)\n\n        if k == 0:\n            EarningsStore1=np.array(EarningsStore[0])\n            EarningsStore2=np.array(EarningsStore[1])\n            EarningsStore3=np.array(EarningsStore[2])\n            EarningsStore4=np.array(EarningsStore[3])\n        else:\n            EarningsStore1=EarningsStore1+np.array(EarningsStore[0])\n            EarningsStore2=EarningsStore2+np.array(EarningsStore[1])\n            EarningsStore3=EarningsStore3+np.array(EarningsStore[2])\n            EarningsStore4=EarningsStore4+np.array(EarningsStore[3])\n\n        Store1=pd.DataFrame({\"earnings\": EarningsStore1}, index=None)\n        Store1[\"total_earnings\"] = Store1.earnings.cumsum()\n        Store1[\"store\"]=\"Store 1\"\n\n        Store2=pd.DataFrame({\"earnings\": EarningsStore2}, index=None)\n        Store2[\"total_earnings\"] = Store2.earnings.cumsum()\n        Store2[\"store\"]=\"Store 2\"\n\n        Store3=pd.DataFrame({\"earnings\": EarningsStore3}, index=None)\n        Store3[\"total_earnings\"] = Store3.earnings.cumsum()\n        Store3[\"store\"]=\"Store 3\"\n\n        Store4=pd.DataFrame({\"earnings\": EarningsStore4}, index=None)\n        Store4[\"total_earnings\"] = Store4.earnings.cumsum()\n        Store4[\"store\"]=\"Store 4\"\n\n        bankruptStore1From=NoCustomers-1\n        if Store1.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[0] != \"store1\":\n                bankruptStore1From=k\n                print(\"Store 1 bankrupt after\", bankruptStore1From, \"customers\")\n            bnkrpt[0] = \"store1\"  \n\n        bankruptStore2From=NoCustomers-1\n        if Store2.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[1] != \"store2\":\n                bankruptStore2From=k\n                print(\"Store 2 bankrupt after\", bankruptStore2From, \"customers\")\n            bnkrpt[1] = \"store2\"  \n\n        bankruptStore3From=NoCustomers-1\n        if Store3.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[2] != \"store3\":\n                bankruptStore3From=k\n                print(\"Store 3 bankrupt after\", bankruptStore3From, \"customers\")\n            bnkrpt[2] = \"store3\"  \n\n        bankruptStore4From=NoCustomers-1\n        if Store4.total_earnings[999] < 0 and k > int(NoCustomers*0.75):\n            if bnkrpt[3] != \"store4\":\n                bankruptStore4From=k\n                print(\"Store 4 bankrupt after\", bankruptStore4From, \"customers\")\n            bnkrpt[3] = \"store4\"  \n\n        revAfterCustomer1.append(Store1.total_earnings[999])\n        revAfterCustomer2.append(Store2.total_earnings[999])  \n        revAfterCustomer3.append(Store3.total_earnings[999])\n        revAfterCustomer4.append(Store4.total_earnings[999])\n    \n    if l==0:\n        earnings=pd.concat([Store1, Store2, Store3, Store4])\n        earnings[\"locationStore4\"]=s4Location\n        revAfterCustomer=revAfterCustomer1+revAfterCustomer2+revAfterCustomer3+revAfterCustomer4\n        RevByCustomer=pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                                    \"locationStore4\": s4Location, \n                                    \"store\": [1]*NoCustomers+[2]*NoCustomers+[3]*NoCustomers+[4]*NoCustomers\n                                   }, index=None)\n    else:\n        earningsTMP=pd.concat([Store1, Store2, Store3, Store4])\n        earningsTMP[\"locationStore4\"]=s4Location\n        earnings=pd.concat([earnings, earningsTMP])\n        revAfterCustomer=revAfterCustomer+revAfterCustomer1+revAfterCustomer2+revAfterCustomer3+revAfterCustomer4\n        RevByCustomer=pd.concat([RevByCustomer ,pd.DataFrame({\"EarningsByCustomers\": revAfterCustomer, \n                                                              \"locationStore4\": s4Location,\n                                                              \"store\": [1]*NoCustomers+[2]*NoCustomers+[3]*NoCustomers+[4]*NoCustomers\n                                                             }, index=None)])","1272af20":"RevByCustomer=RevByCustomer.loc[RevByCustomer.index.isin([NoCustomers-1,NoCustomers*2-1,NoCustomers*3-1,NoCustomers*4-1]),:]\nRevByCustomer.set_index(\"locationStore4\", drop=True, inplace=True)","f850593c":"for l in range(9):\n    s4Location=100+l*50\n    df=earnings.loc[earnings.locationStore4 == s4Location]\n    fig = px.area(df[[\"store\", \"earnings\", \"total_earnings\"]], facet_col=\"store\", facet_col_wrap=2, title=\"Store Location \"+str(s4Location)+\" \"+str(s4Location), labels={\"index\": \"Time Step\"})\n\n    fig.show()","1cd5ff58":"fig = px.area(RevByCustomer[[\"store\", \"EarningsByCustomers\"]], facet_col=\"store\", facet_col_wrap=2, labels={\"value\": \"Earnings by Customers\", \"index\": \"Customer\"})\nfig.update_traces(showlegend=False)\nfig.show()","9b335ff7":"# Rule 4\n\nFor rule 4, we expand the possible applications. We can include as many stores as we want here. In addition, we define the area in which the store also earns money, because this is logically different from your sphere of influence. Only within this area EarnArea the store also earns money here first 0.5 in the radius.\n\nFor each unit of time the customer spends in the store, the store earns 1.5 monetary units. Costs per time unit are not taken into account at first.\n\nIn addition, we introduce another parameter where the store can also go bankrupt. This will become important later. In the case of insolvency, the turnover, the costs per timestep, and gravity is set to zero.\n\nAdditional assumptions are:\n\n8. every customer has an infinite amount of money. \n9. every customer has an unlimited saturation quantity.","ff0a09c4":"Despite the same conditions as in rule 1, the agent is now mainly in the area of the store. The start and end points, on the other hand, show that the customer neither started nor ended in the store.\n\nAs already mentioned, unlike Hotelling, we want to consider more than one dimension. In addition, it should not be the case that a customer always goes straight to the first best store. So it should be possible that customers:\n\n* Not go to any store\n* Go to only one store\n* Pass by a store, although they have seen it and then go to another store.\n* Go to all stores.\n\nThese conditions give the simulation a more credible basis than Hotelling's theory.\n\n## Rule 3\n\nIn Rule 3, we just add another shop.","481cddc8":"One of the stores in the metropolitan area has gone bankrupt. The others did not.","e93c653e":"# Location dependency \n\nIn the following analysis, we vary the location where Store 4 is located. We start far away and get closer and closer to the urban center.\n\nTo get representative results we increase the number of customers.","1237915b":"# Rule 1\n\nThere is a small blur here, but it will be cleared up in a moment.\n\nThe rule includes the following:\n\n1. An individual moves randomly through space. This assumption is of course overturned later.\n2. The space in which an individual moves is limited. Here 1000x1000.\n3. If an individual approaches the edge, it will turn around.\n4. The greatest speed which an individual can reach is, since we are now in a two-dimensional space on the way to the simplification no more two but $$\\small \\sqrt{2^{2}+2^{2}}\\thickapprox2.828 $$","a8441009":"It is clear to see that at least as soon as the fourth store gets too close, a change in the situation occurs. This already happens about 100 distance units before the store really enters the center. You can clearly see that Stores 4 is snatching away some of the customers. however, the local stores are not really interested in this. Why? Because there is enough money and the customers are just throwing it around. As soon as a customer enters the store, he spends money in any case. Therefore, it makes sense to remove the condition 8 and introduce a budget parameter \"bdgt\".","6d7a5def":"Of course, we need a starting position.","288dded4":"# Introduction\n\nIn this study, we will build an agent-based simulation through which we will test whether Hotelling is also plausible for two dimensions.\n\nTo do this, we will need to make some assumptions. Why? Well, if we made no assumptions, we would have to try to recreate the world one-to-one. This would not be a simplification and would not allow a controlled situation in which we want to isolate certain effects, e.g. the profit development of stores.\n\nIn simulations we proceed model-based. A model is a simplification of reality. The simplification is brought about by assumptions. \n\nFor example, if you want to simulate how an animal behaves while foraging for food, you only have to make relevant assumptions about the situation and the actors. For example, it would be important to include the weather or the time that has elapsed since the last meal. Assumptions about economics and politics, for example, are irrelevant here - if we wanted to recreate the whole world, of course they wouldn't be.\n\nFirst, we start very simple. We assume that an individual (i.e. a customer in our case) moves across a surface. The movement is random. In this case up to two units forward or backward thus [-2,-1,0,1,2]. Additionally, we assume that the position is measured 1000 times in total. So 2 is the highest speed an individual can reach and zero is the lowest - There is a small blur here, but it will be cleared up in a moment. The sign indicates the direction. Since we have two directions in two-dimensional space, we simply create two random variables.","6d707a41":"Budget dependence also shows a similar picture. The closer another business is located to the urban center, the less remains for everyone in the end. Why is that? Hotelling's theory shows that businesses often locate next to each other. In the simulation, this seems to be a disadvantage. There are several reasons for this:\n\n1. In the simulation, customers are indifferent as to where they spend their money. This assumption is identical in Hotelling, but in this case it leads to the fact that a customer spends all his money in one and the same store, so that there is nothing left for the other stores. In the simulation without budget, this behavior was more likely due to a customer being drawn to one store and staying there. The budget restriction therefore has more of an effect on customers who go from one store to the next and spend part of their money in one store and the other part in the other store.\n\n2. The number of customers who enter a store at all is limited. Not every customer enters the first store.\n\n# City center\n\nWe have now created a model that can replicate the behavior of customers and the resulting financial consequences for local stores. Now we will make another important assumption - the existence of a city center. We no longer assume that customers will randomly move around the 1000x1000 area until they see a store that appeals to them. From now on, we will send the customers directly to shopping in and around the city center, which is what real walk-in customers would do. Let's see what happens.\n\nIn doing so, we use:\n\n`np.random.randint(low=350, high=650, size=1)`\n\nEverything else remains the same.","4dfda221":"Now let's take a look at how revenues develop when the stores are close to each other but one is not in the sphere of influence of the other. Both generate revenue, the first more than the second. You can clearly see that at some point the customer leaves the first store and goes to the other.","e1a016b5":"To show how the agent behaves now, let's look at the frame interactively. Just click on Start and you will see the path the agent takes. The blue rectangles represent the store and the spheres around it their purview. The purple circle is the movement of the agent. The purple circle is thick at the start, thin during the movement and thick again at the end.","2c2d4167":"Why do we start at random motion and why does that make any sense? After all, we are talking about customers here, i.e. people.\n\nOne of the most important facts in economics is that people respond to incentives and to constraints. The first rule simply assumes that there are no incentives. You could say our agent has no senses, is full, and just walks around. Like a retarded blind and deaf hamster on drugs.\n\nThere is already one restriction. The size of the cage imprisons our agent.","cdb0c99a":"The following graph shows the profit a store has left at the end of the period, depending on where Store 1 is located.","bf02c7bb":"Stores are located in the immediate vicinity.","a824e590":"Different market forms exist. Monopoly, oligopoly and polypoly. In a monopoly, the company can simply maximize its profit given the demand, since there is no competition. However, as soon as other players enter the market (if this is possible), the companies optimize given a demand that is satisfied not only by one, but now by several companies. Mathematically, it is easy to prove that when the number of players converges to infinity, the individual players can no longer exercise market power. Although there are approaches here to regain market power through marketing measures. \n\nIn this notebook we turn to a particular problem area in economics, the \"Hotelling Oligopoly\". Hotelling (1929) was able to show that companies located on the same street can optimize their profits by moving as close as possible to the competition in terms of location. Why is that? Imagine a street with two stores. Suppose the stores are far apart. Customers can come from anywhere. Each store generates sales. In the following diagram you can see how the situation looks like.\n\n![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/c\/cc\/Iceseller1.PNG)\n<p style=\"font-size : 12px\"><em>extract Wikipedia<\/em><\/p>\n\nIf one of the stores were to move closer to the other, it would intercept more customers coming from the opposite direction before the competition did. Therefore, both move as close as possible to each other, as both want to maximize profits. This is why you often see competing stores right next to each other on the same street.  \n\n![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/3\/32\/Iceseller4.PNG)\n<p style=\"font-size : 12px\"><em>extract Wikipedia<\/em><\/p>\n\nHotelling has studied the above behavior for a one-dimensional space. That is, a street along which one can walk. But our world is three-dimensional. We will assume a two-dimensional world for simplification. Stores can be on top of each other, but it is already possible to walk around stores in a two-dimensional space, which is not possible in a one-dimensional space. If you want to get to the back store on a street, you have to pass the front store. In two-dimensional space, however, you could bypass the first store and go directly to the second.\n\nIn this study, we will build an agent-based simulation through which we will test whether Hotelling is also plausible for two dimensions.\n\nTo do this, we will need to make some assumptions. Why? Well, if we made no assumptions, we would have to try to recreate the world one-to-one. This would not be a simplification and would not allow a controlled situation in which we want to isolate certain effects, e.g. the profit development of stores.","671a9c82":"You can clearly see that the agent is first attracted to the first store, then to the second store.\n\n","e9f9e54d":"Here there are now two possibilities of representation. \n1. By time steps. It is assumed that the customers all run around at the same time in the 1000x1000 area. \n2. According to customers. Here it is assumed that the customers come one after the other. After each customer we look at the profit, i.e. the turnover minus the costs. In this case it is also possible to include the possible insolvency of a store with the given function.\n\nThe insolvency is introduced by the \"bnkrpt\". Further assumptions from now on are:\n\n10. The customers come one after the other. Customers therefore do not interact with each other.\n11. Each store has a financial buffer, so that it does not go bankrupt directly as soon as the profit becomes negative. (We assume that bankruptcy can only occur after 75% of the customers have a negative profit).","838d1532":"Now that customers know that there is a city center and spend most of their time in this area, the result does not really change. Store 4 goes out of business if it is too far from the city center because of fledgling customers, but if it is closer, its sales increase to the detriment of the other stores. If it gets too close to the others, this is bad for everyone. \n\n# Conclusion\n\nWe can conclude that it makes sense to open a store close to the competitors in an urban center, but not too close to the competition. ","aeb1c5f7":"In the following graphic we additionally see a start and an end point. ","8b678c07":"As you can see it depends on where the agent starts from.","b6a76025":"When they locate next to each other, they take away each other's clientele.","1e597628":"# 1000 Customers\n\nNow we are going one step further and using the option of insolvency. Insolvency is caused by overindebtedness. For this, we assume that small costs are incurred per time step.","832d8278":"Here you can see that the customer first notices the first store, but moves on and enters the second store. He then leaves the second store once and returns again.","cac878a8":"As can be seen, the agent moves randomly. He is only confined by the boundary. So it is not quite right to talk only about coincidence. In a second experiment, with the same seed, we set the starting points further away from the boundary","651ca56e":"# Rule 2\n\nPeople respond to incentives. Now we will turn the retarded hamster into an individual who responds to incentives, just as a person would do when shopping. That is, when one sees a nice store one feels attracted and eventually enters the store, buys something, and moves on.\n\nThe assumptions are now additional:\n\n5. Stores have an attraction to customers who are nearby - with respect to euclidean distance. Practically, this could be signs that draw attention to the store or beautifully decorated store windows. We call the perimeter that is opened up by such marketing measures the sphere of influence (purview=radius of influence).\n6. There is no Internet.\n7. A second important parameter is the strength with which the stores attract customers. Depending on how tempting an offer is, a customer moves in the appropriate direction or loses interest (gravity).\n","a7c53e3e":"This plot now shows how much revenue each customer leaves there of course minus the costs - hence the negative slope after each customer. You can clearly see that not so many customers even come into the visual range of the stores.\n\n# The first competitive situation\n\nNext, let's check if our simulation is capable of simulating a competitive situation. The question is. \"What happens if we place the stores very close to each other?\"","7551d4de":"As can be easily seen, the second store does not manage to generate enough sales to cover its costs. In this graph, it was assumed that the customers appear simultaneously in and not sequentially. Therefore, it is of course not possible to show when the stores are insolvent. Again, to explain. The customers come one after the other and are 1000 time units in the 1000x1000 area.","84803ef1":"# Rule 5\n\nInserting the budget is easy, because we simply say that once the budget is used up, the store stops making money from each customer. \n\nAssumption 8 is changed:\n\n8. Each customer has the same budget (bdgt) that he can consume.\n\nHere we give each customer a budget of 200.","2904493e":"In the following analysis, we start in the middle of the area of 1000x1000 in order to initially have fewer restrictions due to the boundaries.","04df425d":"So the tide may be turning. When the stores were very far apart, Store 2 went bankrupt first. When the two stores are right next to each other, it's Store 1. Why is that? There are two reasons:\n\n1. the stores are snatching customers away from each other, as visible in the animations.\n2. it depends on where the most customers are walking around.\n\nThe distribution of customers will be discussed later. Point one is intentional.\n\n# Four Stores\n\nNow we perform the same analysis again, but this time with four stores, three of which are in the same location and one of which is further away.\n\nThree stores are located close to each other and one is far away."}}