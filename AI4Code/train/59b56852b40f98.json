{"cell_type":{"6f72e4ea":"code","d9442474":"code","a45be2ca":"code","15f4fff2":"code","c89cbb42":"code","5fbd3b9a":"code","ba15f7a3":"code","54209ec5":"code","45bd47c1":"code","5836bb9f":"code","3e83a521":"code","2ef6dbfb":"markdown","fc42cbae":"markdown"},"source":{"6f72e4ea":"################################################################\n# Required Modules and Libraries\n################################################################\n\n!pip install openpyxl\nimport numpy as np\nimport pandas as pd\nimport datetime as dt\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import MinMaxScaler\nfrom yellowbrick.cluster import KElbowVisualizer\n\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)","d9442474":"################################################################\n# Preparing and Understanding of Data Set\n################################################################\n\ndf = pd.read_excel(\"..\/input\/online-retail-ii-x\/online_retail_II.xlsx\")\n\ndef check_df(dataframe, head=5):\n    print(\"################ Shape #####################\")\n    print(dataframe.shape)\n    print(\"################ Types #####################\")\n    print(dataframe.dtypes)\n    print(\"################ Head ######################\")\n    print(dataframe.head(head))\n    print(\"################ Tail ######################\")\n    print(dataframe.tail(head))\n    print(\"################ NA ########################\")\n    print(dataframe.isnull().sum())\n    print(\"################ Describe ##################\")\n    print(dataframe.describe().T)\ncheck_df(df)\n","a45be2ca":"################################################################\n# RFM\n################################################################\n\n# Let's do the operations related to RFM. create_RFM function will help about it.\n\ndef create_RFM(dataframe):\n    dataframe[\"Total_Price\"] = dataframe[\"Price\"] * dataframe[\"Quantity\"]\n    dataframe.dropna(inplace=True)\n    dataframe = dataframe[~dataframe[\"Invoice\"].str.contains(\"C\", na=False)]\n\n    # Defining the date of analysis\n    dataframe[\"InvoiceDate\"].max()\n    today_date = dt.datetime(2011, 12, 11)\n\n    # Defining RFM metrics\n    rfm = dataframe.groupby('Customer ID').agg(\n        {'InvoiceDate': lambda InvoiceDate: (today_date - InvoiceDate.max()).days,\n         'Invoice': lambda Invoice: Invoice.nunique(),\n         'Total_Price': lambda Total_Price: Total_Price.sum()})\n\n    rfm.columns = [\"recency\", \"frequency\", \"monetary\"]\n    rfm[rfm[\"monetary\"] > 0]  # Monetary value should be over then 0\n\n    # Defining RFM scores\n    rfm[\"recency_score\"] = pd.qcut(rfm[\"recency\"], 5, labels=[5, 4, 3, 2, 1])\n    rfm[\"frequency_score\"] = pd.qcut(rfm[\"frequency\"].rank(method=\"first\"), 5, labels=[1, 2, 3, 4, 5])\n    rfm[\"monetary_score\"] = pd.qcut(rfm[\"monetary\"], 5, labels=[1, 2, 3, 4, 5])\n    rfm[\"RFM_SCORE\"] = (rfm[\"recency_score\"].astype(str) + rfm[\"frequency_score\"].astype(str))\n\n    # Creating segments with Regex\n    seg_map = {\n        r'[1-2][1-2]': 'hibernating',\n        r'[1-2][3-4]': 'at_Risk',\n        r'[1-2]5': 'cant_loose',\n        r'3[1-2]': 'about_to_sleep',\n        r'33': 'need_attention',\n        r'[3-4][4-5]': 'loyal_customers',\n        r'41': 'promising',\n        r'51': 'new_customers',\n        r'[4-5][2-3]': 'potential_loyalists',\n        r'5[4-5]': 'champions'\n    }\n\n    rfm[\"segment\"] = rfm[\"RFM_SCORE\"].replace(seg_map, regex=True)\n    rfm[[\"segment\", \"recency\", \"frequency\", \"monetary\"]].groupby(\"segment\").agg(\n        [\"mean\", \"count\"])  # Describe of segments\n\n    return rfm\n\ncreate_RFM(df).head(10)\n\n","15f4fff2":"rfm_new = create_RFM(df)\nrfm_new[[\"segment\", \"recency\", \"frequency\", \"monetary\"]].groupby(\"segment\").agg(\n        [\"mean\", \"count\"])","c89cbb42":"drop_cols = [\"recency_score\", \"frequency_score\", \"monetary_score\", \"RFM_SCORE\"]\nrfm_final = rfm_new.drop(drop_cols, axis=1)\nrfm_final.head()\n","5fbd3b9a":"################################################################\n# K-Means\n################################################################\n\ndrop_cols = [\"segment\"]\ndf_k = rfm_final.drop(drop_cols, axis=1)\ndf_k.head()\n\nsc = MinMaxScaler((0, 1))\ndf_k = sc.fit_transform(df_k)\n\n\nkmeans = KMeans(n_clusters=5)   # The number of clusters is determined by the user.\nk_fit = kmeans.fit(df_k)\n\nk_fit.n_clusters                # Total Number of Clusters\nk_fit.cluster_centers_          # Centers of clusters\nk_fit.labels_                   # Labels of created classes\nk_fit.inertia_                  # Total Error","ba15f7a3":"################################\n# Defining Optimum Size of Cluster\n################################\n\ntype(df_k)  # Type of df_k is Numpy array. Let's convert into pandas dataframe so that we can use later.\ndf_k = pd.DataFrame(df_k)\n\nkmeans = KMeans()\nelbow = KElbowVisualizer(kmeans, k=(2, 20))\nelbow.fit(df_k)\nelbow.show()","54209ec5":"elbow.elbow_value_ # As seen above the graph optimum cluster number is 6.","45bd47c1":"################################\n# Creating Final Cluster\n################################\n\nkmeans = KMeans(n_clusters=elbow.elbow_value_).fit(df_k) # final model\nkumeler = kmeans.labels_\n\ndf_k = rfm_final.drop(drop_cols, axis=1)        # Let's get back rfm_final as df_k\n\npd.DataFrame({\"Customer ID\": df_k.index, \"Kumeler\": kumeler})\n\ndf_k[\"cluster_no\"] = kumeler                    # Let's assign kmeans.labels_ as cluster_no to df_k\n\ndf_k[\"cluster_no\"] = df_k[\"cluster_no\"] + 1     # Cluster_no numbers will start from 1.\n\ndf_k.head()                                     # Let's see the df_k that we expected.","5836bb9f":"a = df_k.reset_index()\ndrop_cols = [\"recency\",  \"frequency\", \"monetary\"]\na = a.drop(drop_cols, axis=1)\nb = rfm_final.reset_index()\na.head()\nb.head()\n\nab = pd.merge(a, b, on=\"Customer ID\")   # Let's merge two dataframes on \"Customer ID\" as ab\n\nab.head()\n","3e83a521":"describes = [\"count\",\"mean\", \"min\", \"max\", \"sum\"]\n\nab.groupby([\"cluster_no\", \"segment\"]).agg({\"recency\": describes,\n                                         \"frequency\": describes,\n                                         \"monetary\": describes})\n\nresult = ab.groupby([\"cluster_no\", \"segment\"]).agg({\"recency\": describes,\n                                         \"frequency\": describes,\n                                         \"monetary\": describes})\nresult\n\n","2ef6dbfb":"As a result, first of all, RFM analysis was performed and customers were classified. After that, the customers who were also segmented by the K-Means model were divided into six clusters. Looking at the result table above, it can be seen that the best cluster in parallel with the results of the RFM analysis is the cluster \"5\", and this cluster is the champions cluster consisting of 13 customers. Similarly, the second best cluster is cluster \"1\", and the average recency value is 388 days. Finally, it is seen that the worst cluster is cluster \"2\" with an average recency of 599 days and that this cluster consists of at_risk, hibernating, cant loose customers in parallel with RFM analysis.","fc42cbae":"\n# *CUSTOMER SEGMANTATION with K-Means & RFM *         \n\n**Business Problem**\n\n\nRule-based customer segmentation method with RFM, and  one of\nmachine learning model which is  K-Means for customer segmentation is expected to compare.\n\n**Story of Dataset**\n\nThe data set called Online Retail II is an online sale based in the UK sales of the store\nfrom 01\/12\/2009 to 9\/12\/2011. Souvenirs are included in the product catalog of this company.\nThe vast majority of the company's customers are corporate customers.\n\n**Variables**\n\n* Invoicename: Invoice number (If this code starts with C, it means that order has been canceled.)\n* Stock Code: Product code (Its a unique trick for a product.)\n* Description: Product name\n* InvoiceDate: Invoice date\n* Unit Price: Fetura price\n* Customer ID: Unique customer number\n* Country: Country name"}}