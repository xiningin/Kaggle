{"cell_type":{"1cb833ac":"code","80a85d50":"code","4e806ee0":"code","9756f959":"code","b55d3baa":"code","c9e8aa0b":"code","fef904e0":"code","324bccce":"code","b0b946f3":"code","2b77375d":"code","84560a2f":"code","64bb2db4":"code","e7d38280":"code","d28640e2":"code","08c1362d":"code","97e7449b":"code","cae282c8":"code","cdb6b06e":"code","9342a69f":"code","7046ec52":"code","63994603":"code","fd0051c9":"code","9ce1ba44":"code","8caaaeec":"code","a4564b29":"code","d9f64c23":"code","5863ad0e":"code","c9aaf456":"code","3c2a5f11":"code","5ec21e8c":"code","59c24e92":"code","35ba48f4":"code","c4372013":"code","47432de4":"code","dd00745f":"code","7b20ceb2":"code","1de64294":"code","de4c6be4":"code","259cac6a":"code","adcde008":"code","b0125be7":"code","94d9293d":"code","814caabe":"code","4f14f80c":"code","8188d49d":"code","e28f8e10":"code","cbbd7c90":"code","99265524":"code","835b09e9":"code","d9690a99":"code","8e7f8e21":"code","2983f469":"code","4da784af":"code","b4f512fa":"code","81c9e056":"code","93aadad9":"code","26db338f":"code","95b80763":"code","6f56bdac":"code","5914a739":"code","02f84f9e":"markdown","b1bd8eb0":"markdown","f45d28e2":"markdown","601f9f15":"markdown","a1194908":"markdown","0c3991d6":"markdown","78271c68":"markdown","113d57bb":"markdown","c03832e5":"markdown","258c466b":"markdown","2529526b":"markdown","a63160c9":"markdown","f80737e0":"markdown","2d1eb203":"markdown","bcf47ce0":"markdown","0d9202fd":"markdown","ccc1b10c":"markdown","4ff6c8cf":"markdown","399e5306":"markdown","bb8ba990":"markdown","c0f513d6":"markdown","40f3ad1c":"markdown","2af01d58":"markdown","c096843c":"markdown","19dbf747":"markdown","7e32a5e4":"markdown","02701590":"markdown","1e65be6c":"markdown"},"source":{"1cb833ac":"from IPython.core.display import display, HTML, Javascript\n\ndef nb():\n    styles = open(\"..\/input\/intermediate-notebooks-data\/custom_pink.css\", \"r\").read()\n    return HTML(\"<style>\"+styles+\"<\/style>\")\nnb()","80a85d50":"!pip install pywaffle\n!pip install pycomp\n\nimport numpy as np \nimport pandas as pd \nimport os\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotly.graph_objects as go\nimport plotly.express as px\nimport cudf\nimport cuml\nimport shap\nimport xgboost\n\nfrom pywaffle import Waffle\nfrom pycomp.viz.insights import *\n\nfrom cuml.preprocessing.TargetEncoder import TargetEncoder\nfrom cuml.linear_model import Ridge\nfrom cuml.svm import SVR\nfrom cuml.neighbors import KNeighborsClassifier\nfrom cuml.metrics import accuracy_score,roc_auc_score as ras\nfrom cuml.preprocessing.model_selection import train_test_split\n\nfrom lightgbm import LGBMClassifier\n\nfrom sklearn.metrics import roc_auc_score,roc_curve,auc\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import roc_curve, precision_recall_curve\nfrom scipy import interp\n\nimport warnings\nimport time\nwarnings.filterwarnings(\"ignore\")","4e806ee0":"!nvidia-smi","9756f959":"!nvcc --version","b55d3baa":"def custom_palette(custom_colors):\n    customPalette = sns.set_palette(sns.color_palette(custom_colors))\n    sns.palplot(sns.color_palette(custom_colors),size=0.8)\n    plt.tick_params(axis='both', labelsize=0, length = 0)","c9e8aa0b":"#defining colour palette\nred = [\"#4f000b\",\"#720026\",\"#ce4257\",\"#ff7f51\",\"#ff9b54\"]\nbo = [\"#6930c3\",\"#5e60ce\",\"#0096c7\",\"#48cae4\",\"#ade8f4\",\"#ff7f51\",\"#ff9b54\",\"#ffbf69\"]\npink = [\"#aa4465\",\"#dd2d4a\",\"#f26a8d\",\"#f49cbb\",\"#ffcbf2\",\"#e2afff\",\"#ff86c8\",\"#ffa3a5\",\"#ffbf81\",\"#e9b827\",\"#f9e576\"]\ncustom_palette(pink)","fef904e0":"#set context to customize and style plots\nsns.set_context(\"poster\", font_scale = 0.6, rc={\"grid.linewidth\": 0.4})\n\n#set font family\nsns.set_style({'font.family':'serif'})","324bccce":"#reading csv files\ntrain_df =  pd.read_csv(\"..\/input\/widsdatathon2021\/TrainingWiDS2021.csv\")\ntest_df = pd.read_csv(\"..\/input\/widsdatathon2021\/UnlabeledWiDS2021.csv\")\ndata_dictionary = pd.read_csv(\"..\/input\/widsdatathon2021\/DataDictionaryWiDS2021.csv\")","b0b946f3":"fig = go.Figure(data=[go.Table(\n    header=dict(values=list(data_dictionary.columns),\n                fill_color=pink[2],\n                line_color='black',\n                align='center'),\n    cells=dict(values=[data_dictionary.Category,data_dictionary['Variable Name'],data_dictionary['Unit of Measure'],data_dictionary['Data Type'],data_dictionary['Description'],data_dictionary['Example']],\n               fill_color=pink[4],\n               line_color='black',\n               align='left'))\n])\n\nfig.show()","2b77375d":"train_df.head(10)","84560a2f":"train_df = train_df.drop(columns=['Unnamed: 0'])\ntest_df = test_df.drop(columns=['Unnamed: 0'])","64bb2db4":"train_df.describe().T.style","e7d38280":"missing_count = train_df.isna().sum()\nmissing_df = (pd.concat([missing_count.rename('Missing count'),\n                     missing_count.div(len(train_df))\n                          .rename('Missing ratio')],axis = 1)\n             .loc[missing_count.ne(0)])\n\n#color the background of cells in a dataframe depending on the value of the data in each column \nmissing_df.style.background_gradient(cmap=\"cool\")","d28640e2":"dt_i=[]\ndt_fl=[]\ndt_o=[]\n\n#making a list of columns depending on the datatype\nfor col in train_df.columns:\n    x=train_df[col].dtype\n    if x=='int64':\n        dt_i.append(col)\n    elif x=='float64':\n        dt_fl.append(col)\n    else:\n        dt_o.append(col)","08c1362d":"gender_count = train_df[\"gender\"].value_counts()\ngender_df = pd.DataFrame (gender_count)\ngender_df['percent'] = (gender_df['gender'] \/gender_df['gender'].sum()) * 100\n\nfig = plt.figure(\n    FigureClass=Waffle, \n    rows=5,\n    columns=10,\n    values=gender_df['percent'],\n    colors = (pink[-1], pink[-2]),\n    title={'label': 'Gender Distribution', 'loc': 'center','color':red[0],'size':20},\n    labels=[f\"{k} ({'{:.2f}'.format(v)}%)\" for k, v in zip(gender_df.index, gender_df.percent)],\n    legend={'loc': 'upper left', 'bbox_to_anchor': (1,1)},\n    icons = ['male','female'],\n    icon_legend=True,\n    font_size=35, \n    figsize=(10, 8)\n)\n\nfig.set_facecolor('#fffff0')\nplt.show()","97e7449b":"fig, ax  = plt.subplots(figsize=(16, 8))\nfig.suptitle('Ethnicity Distribution', size = 20, color = red[0])\nexplode = (0.05, 0.05, 0.05, 0.05, 0.3, 0.5)\nlabels = [\"Caucasian\",\"African American\",\"Other\/Unknown\",\"Hispanic\",\"Asian\",\"Native American\"]\nsizes = train_df[\"ethnicity\"].value_counts()\nax.pie(sizes, explode=explode, colors=bo, startangle=60, labels=labels,autopct='%1.0f%%', pctdistance=0.7)\nax.add_artist(plt.Circle((0,0),0.4,fc='white'))\nplt.show()","cae282c8":"plt.figure(figsize = (16,8))\nplt.title('Hospital Admit Source', size = 20, color = red[0])\nsns.countplot(y ='hospital_admit_source', data = train_df,palette=bo);","cdb6b06e":"plt.figure(figsize = (16,8))\nplt.title('ICU Admit Source', size = 20, color = red[0])\nsns.countplot(y ='icu_admit_source', data = train_df,palette=bo[3:]); ","9342a69f":"fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))\nfig.suptitle('ICU Type and Stay Type Distribution', size = 20, color = red[0])\naxs = [ax1, ax2]\n\nexplode = (0.05, 0.05,0.05, 0.05,0.05, 0.05,0.05, 0.05)\nlabels = ['Med-Surg ICU', 'CCU-CTICU', 'MICU','Neuro ICU', 'Cardiac ICU', 'SICU','CSICU','CTICU']\nsizes = train_df['icu_type'].value_counts()\nax1.pie(sizes, explode=explode, colors=pink[1:], startangle=60, labels=labels,autopct='%1.0f%%', pctdistance=0.6)\nax1.add_artist(plt.Circle((0,0),0.4,fc='white'))\n\nexplode = (0.05, 0.05, 0.3)\nlabels = ['admit','transfer', 'readmit']\nsizes = train_df['icu_stay_type'].value_counts()\nax2.pie(sizes, explode=explode, colors=bo[2:], startangle=60, labels=labels,autopct='%1.1f%%', pctdistance=0.9)\nax2.add_artist(plt.Circle((0,0),0.4,fc='white'))\n\nplt.show()","7046ec52":"def hist(col,title):\n    \n    plt.figure(figsize = (10,8))\n    \n    ax = sns.distplot(col,kde=False);\n    \n    values = np.array([patch.get_height() for patch in ax.patches])\n    \n    #normalizing the values to get a range of colours\n    norm = plt.Normalize(values.min(), values.max())\n    \n    #range of colours from colourmap-rainbow\n    colors = plt.cm.rainbow(norm(values))\n    \n    #set colour for each patch\n    for patch, color in zip(ax.patches, colors):\n        patch.set_color(color)\n\n    plt.title(title, size = 20, color = red[0])","63994603":"hist(train_df['age'],'Distribution of Age')","fd0051c9":"hist(train_df['height'],'Distribution of Height')","9ce1ba44":"hist(train_df['weight'],'Distribution of Weight')","8caaaeec":"fig, ax = plt.subplots(1,1, figsize=(20, 10))\nax = sns.distplot(train_df['bmi'], kde=False);\nvalues = np.array([patch.get_height() for patch in ax.patches])\nnorm = plt.Normalize(values.min(), values.max())\ncolors = plt.cm.rainbow(norm(values))\nfor patch, color in zip(ax.patches, colors):\n        patch.set_color(color)\n\n#colours for different bmi categories\nspan_color =  ['#00a8e8','#25a18e','#fb8500','#ef476f']\n\n#range of values for different bmi categories\nspan_range = [[0,18], [19,25], [26,30], [31,70]]\n\nfor idx, span_title in enumerate(['Underweight', 'Normal', 'Overweight', 'Obese']):\n    ax.annotate(span_title,\n                    xy=(sum(span_range[idx])\/2 ,1000),\n                    xytext=(0,470), textcoords='offset points',\n                    va=\"center\", ha=\"center\",\n                    color=\"w\", fontsize=10, fontweight='bold',\n                    size=12,\n                    bbox=dict(boxstyle='sawtooth', pad=0.1, color=span_color[idx], alpha=0.8))\n    ax.axvspan(span_range[idx][0]-0.4,span_range[idx][1]+0.4,  color=span_color[idx], alpha=0.2)\nplt.title(\"Distribution of BMI\", size = 20, color = red[0])\nplt.show()","a4564b29":"plot = sns.catplot(\"diabetes_mellitus\", col=\"elective_surgery\",data=train_df,kind=\"count\", height=6,aspect=.7,palette=bo[2:]);\nplot.fig.suptitle(\"Elective surgery and Diabetes Mellitus\", size = 20, color = red[0], y=1.05);","d9f64c23":"plot = sns.catplot(\"diabetes_mellitus\", col=\"readmission_status\", data=train_df,kind=\"count\", height=6,aspect=.7,palette=red[2:])\nplot.fig.suptitle(\"Readmission Status and Diabetes Mellitus\", size = 20, color = red[0], y=1.05);","5863ad0e":"plot = sns.catplot(\"diabetes_mellitus\", col=\"apache_post_operative\", data=train_df,kind=\"count\", height=6,aspect=.7,palette=bo[1:]);\nplot.fig.suptitle(\"APACHE post operative and Diabetes Mellitus\", size = 20, color = red[0], y=1.05);","c9aaf456":"plot_countplot(df=train_df, col='arf_apache', hue='diabetes_mellitus', palette=\"Pastel2\",\n                   title='arf_apache and diabetes mellitus')","3c2a5f11":"plot_countplot(df=train_df, col='intubated_apache', hue='diabetes_mellitus', palette=\"Pastel1\",\n                   title='intubated_apache and diabetes mellitus')","5ec21e8c":"d_map = {1: 'Diabetic', 0: 'Not Diabetic'}\nplot_double_donut_chart(df=train_df, col1='ventilated_apache', col2='diabetes_mellitus', label_names_col1=d_map, \n                        colors1=['pink', 'hotpink'], colors2=['lightskyblue','dodgerblue'],\n                        title=\"ventilated_apache and diabetes mellitus\")","59c24e92":"plot_donut_chart(df=train_df, col='diabetes_mellitus', label_names=d_map, colors=[pink[5],pink[2]],\n                 title='Target Value Distribution')","35ba48f4":"def plot_pie(col,cin) :\n    diabetes_yes = train_df[(train_df['diabetes_mellitus'] != 0)]\n    diabetes_no = train_df[(train_df['diabetes_mellitus'] == 0)]\n    \n    trace1 = go.Pie(values  = diabetes_yes[col].value_counts().values.tolist(),\n                    labels  = diabetes_yes[col].value_counts().keys().tolist(),\n                    textfont=dict(size=13), opacity = 0.7,\n                    hole = 0.7, \n                    hoverinfo = \"label+percent+name\",\n                    domain  = dict(x = [.0,.48]),\n                    name    = \"Diabetic\",\n                    marker  = dict(colors = pink[cin:], line = dict(width = 1.5)))\n    trace2 = go.Pie(values  = diabetes_no[col].value_counts().values.tolist(),\n                    labels  = diabetes_no[col].value_counts().keys().tolist(),\n                    textfont=dict(size=13), opacity = 0.7,\n                    hole = 0.7,\n                    hoverinfo = \"label+percent+name\",\n                    marker  = dict(line = dict(width = 1.5)),\n                    domain  = dict(x = [.52,1]),\n                    name    = \"Not Diabetic\" )\n\n    layout = go.Layout(dict(title = col + \" and diabetes mellitus\",title_x=0.5,title_font_color=red[0]),\n                       annotations = [ dict(text = \"Diabetic\",\n                                                font = dict(size = 13),\n                                                showarrow = False,\n                                                x = .22, y = -0.1),\n                                       dict(text = \"Not Diabetic\",\n                                                font = dict(size = 13),\n                                                showarrow = False,\n                                                x = .8,y = -.1)])\n\n    fig  = go.Figure(data = [trace1,trace2],layout = layout)\n    \n    fig.update_layout(legend=dict(  yanchor=\"top\",\n                                    y=0.99,\n                                    xanchor=\"left\",\n                                    x=0.01))\n    \n    fig.show()","c4372013":"s = dt_i[9:-1] \ncin = 2\nfor i in s: \n    plot_pie(i,cin)\n    cin+=1","47432de4":"dt_fl.append(\"diabetes_mellitus\")\n\n#correlation between features\ntrain_df[np.intersect1d(train_df.columns, dt_fl)].corr().style.background_gradient(cmap='Oranges')","dd00745f":"dt_fl.remove(\"diabetes_mellitus\")\ndt_i.remove(\"diabetes_mellitus\")","7b20ceb2":"train_df = cudf.DataFrame.from_pandas(train_df)\ntest_df = cudf.DataFrame.from_pandas(test_df)","1de64294":"train_df[dt_o].isna().sum()","de4c6be4":"train_df[dt_o] = train_df[dt_o].fillna(\"\")\ntrain_df[dt_o].isna().sum()","259cac6a":"test_df[dt_o].isna().sum()","adcde008":"test_df[dt_o] = test_df[dt_o].fillna(\"\")\ntest_df[dt_o].isna().sum()","b0125be7":"train_df[dt_i] = train_df[dt_i].fillna(value=0)\ntest_df[dt_i] = test_df[dt_i].fillna(value=0)\n\ntrain_df[dt_fl] = train_df[dt_fl].fillna(value=0)\ntest_df[dt_fl] = test_df[dt_fl].fillna(value=0)","94d9293d":"%%time\nSMOOTH = 0.001\nSPLIT = 'interleaved'\nFOLDS = 5\n\nencoder = TargetEncoder(n_folds=FOLDS, smooth=SMOOTH, split_method=SPLIT)","814caabe":"ID_col = ['encounter_id','hospital_id','icu_id']\ntrain_df = train_df.drop(columns=ID_col)\ntest_df = test_df.drop(columns=ID_col)","4f14f80c":"%%time\nX = train_df.drop([\"diabetes_mellitus\"],axis=1)\ny = train_df[\"diabetes_mellitus\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, \n                                                    shuffle=False, stratify=y)\nfor col in dt_o:\n    X_train[col] = encoder.fit_transform(X_train[col],y_train)\n    X_test[col] = encoder.transform(X_test[col])\n    test_df[col] = encoder.transform(test_df[col])","8188d49d":"def training(model, X_train, y_train, X_test, y_test, model_name):\n    t1 = time.time()\n    \n    model.fit(X_train, y_train)\n    predicts = model.predict(X_test)\n    roc = ras(y_test, predicts)\n    \n    t2 = time.time()\n    training_time = t2-t1 \n    \n    print(\"\\t\\t\\t--- Model:\", model_name,\"---\")\n    print(\"ROC: \", roc,\"\\t\\t\\t\",\"Training time:\",training_time,\"\\n\")","e28f8e10":"#cuml-ridge \nridge = Ridge(fit_intercept = True, normalize = False,solver = \"eig\")\n\n#cuml-support vector regression\nsvr = SVR(kernel='rbf', gamma='scale', C=1, epsilon=0.3)\n\n#cuml-KNeighborsClassifier\nknc =  KNeighborsClassifier(n_neighbors=3)\n\nm = [ridge,svr,knc]\nmn = [\"Ridge\",\"SVR\",\"K Neighbors Classifier\"]\n\nfor i in range(0,len(m)):\n    training(model=m[i], X_train=X_train, y_train=y_train, X_test=X_test,y_test=y_test, model_name=mn[i])","cbbd7c90":"Xtrain_pd = X_train.to_pandas()\nytrain_pd = y_train.to_pandas()\n\nXtest_pd = X_test.to_pandas()\nytest_pd = y_test.to_pandas()","99265524":"dtrain = xgboost.DMatrix(X_train,y_train)\ndval   = xgboost.DMatrix(X_test, y_test)\ndtest  = xgboost.DMatrix(test_df)\n\nparams1 = {'tree_method' : 'gpu_hist','max_depth' : 7,'max_leaves' : 15,'objective' : 'binary:logistic','grow_policy' : 'lossguide','predictor':'gpu_predictor','eta' : 0.7,'eval_metric':'auc'}\nevallist = [(dval, 'validation'), (dtrain, 'train')]\nnum_round=50","835b09e9":"%%time\n\nmodel1 = xgboost.train(params1, dtrain,num_round,evallist)\n\npredicts = model1.predict(xgboost.DMatrix(X_test))\nroc = ras(y_test, predicts)\nroc","d9690a99":"cu_score = accuracy_score(y_test, predicts)\ncu_score","8e7f8e21":"preds1 = model1.predict(xgboost.DMatrix(test_df))","2983f469":"%%time\n\nmodel2 = LGBMClassifier(**{'learning_rate': 0.05,\n                    'max_depth': 3,\n                    'reg_alpha': 1,\n                    'reg_lambda': 1,\n                    'objective': 'binary',\n                    'metric': 'auc',\n                    'n_jobs': -1,\n                    'n_estimators' : 5000,\n                    'feature_fraction_seed': 42,\n                    'bagging_seed': 42,\n                    'boosting_type': 'gbdt',\n                    'is_unbalance': True,\n                    'boost_from_average': False})\n\nplt.rcParams['figure.figsize']=(10,8)\n    \ntprs = []\naucs = []\nroc_aucs = []\nmean_tpr = []\nmean_fpr = []\n\nX_c = pd.concat([Xtrain_pd, Xtest_pd])\ny_c = pd.concat([ytrain_pd, ytest_pd])\n\noof = np.zeros(len(X_c))\nmean_fpr = np.linspace(0,1,100)\n\ni = 1\n\nfolds = StratifiedKFold(n_splits=3, shuffle=True, random_state=2021)\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(X_c,y_c)):\n    print('-- Fold:', fold_,'--' )\n    model2 = model2.fit(X_c.iloc[trn_idx], y_c.iloc[trn_idx], categorical_feature=dt_o, eval_set=[(X_c.iloc[trn_idx],y_c.iloc[trn_idx]),(X_c.iloc[val_idx], y_c.iloc[val_idx])],\n                          eval_metric = 'auc',\n                          early_stopping_rounds = 100,verbose=250)\n        \n    oof[val_idx] =  model2.predict_proba(X_c.iloc[val_idx])[:,1]\n        \n    f = plt.figure(1)\n    fpr, tpr, t = roc_curve(y_c[val_idx], oof[val_idx])\n    tprs.append(interp(mean_fpr, fpr, tpr))\n    roc_auc = auc(fpr, tpr)\n    aucs.append(roc_auc)\n    plt.plot(fpr, tpr, lw=2, alpha=0.5, label='ROC fold %d (AUC = %0.4f)' % (i,roc_auc))\n    roc_aucs.append(roc_auc_score(y_c[val_idx], oof[val_idx]))\n    i+=1\n\nprint('\\nCV ROC        : {0:.4f}, std: {1:.4f}.'.format(np.mean(roc_aucs), np.std(roc_aucs)))\n\nplt.plot([0,1],[0,1],linestyle = '--',lw = 2,color = 'grey')\nmean_tpr = np.mean(tprs, axis=0)\nmean_auc = auc(mean_fpr, mean_tpr)\nplt.plot(mean_fpr, mean_tpr, color='blue',\n             label=r'Mean ROC (AUC = %0.4f)' % ((mean_auc)),lw=2, alpha=1)\nplt.grid(b=True, which='major', color='grey', linewidth=0.4)\nplt.xlabel('False Positive Rate', fontsize=12)\nplt.ylabel('True Positive Rate', fontsize=12)\nplt.title('ROC by folds', fontsize=18)\nplt.legend(loc=\"lower right\")\nplt.show()","4da784af":"preds2 = model2.predict_proba(test_df.to_pandas())[:,1]\npreds2","b4f512fa":"preds3 = ridge.predict(test_df).to_array()\npreds3","81c9e056":"def feature_imp(model):\n    explainer = shap.TreeExplainer(model1)\n    shap_values = explainer.shap_values(Xtest_pd)\n    \n    #summary plots\n    shap.summary_plot(shap_values, Xtest_pd, plot_type=\"bar\",color=pink[5])\n\n    shap.summary_plot(shap_values, Xtest_pd)\n    \n    #dependence plots\n    shap.dependence_plot(\"d1_glucose_max\", shap_values, Xtest_pd)\n\n    shap.dependence_plot(\"bmi\", shap_values, Xtest_pd)\n\n    shap.dependence_plot(\"age\", shap_values, Xtest_pd)\n\n    shap.dependence_plot(\"glucose_apache\", shap_values, Xtest_pd)","93aadad9":"%%time\nfeature_imp(model1)","26db338f":"#blending predictions from various models\nblended_preds = 0.7*preds2 + 0.2*preds1 + 0.1*preds3","95b80763":"encounter_IDs = cudf.read_csv(\"..\/input\/widsdatathon2021\/UnlabeledWiDS2021.csv\")[[\"encounter_id\"]].values","6f56bdac":"df_sub = {'encounter_id': encounter_IDs, 'diabetes_mellitus': blended_preds}\ndf_predictions = cudf.DataFrame(df_sub).set_index(['encounter_id'])\ndf_predictions.head(10)","5914a739":"df_predictions.to_csv('\/kaggle\/working\/Predictions_blended.csv')","02f84f9e":"<p><mark>\nUsed a library called PyWaffle for the following viz \ud83c\udfa8\n<\/mark><\/p>\n\n[Documentation](https:\/\/github.com\/gyli\/PyWaffle)","b1bd8eb0":"<p><mark>Now let's see the descriptive statistics for this dataframe.<\/mark><\/p>","f45d28e2":"<img src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/e\/e9\/Body_mass_index_chart.svg\/1200px-Body_mass_index_chart.svg.png\">\n\nUsing values from the above [image](https:\/\/en.wikipedia.org\/wiki\/Overweight) as a point of reference for specifying bmi range.","601f9f15":"<p><mark>Let's take a look at the training data!<\/mark><\/p>","a1194908":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Categorical columns<\/center><\/h3>\n<\/div>","0c3991d6":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Creating the submission file<\/center><\/h3>\n<\/div>","78271c68":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>XGBoost Model<\/center><\/h3>\n<\/div>","113d57bb":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Feature Importance: XGB<\/center><\/h3>\n<\/div>","c03832e5":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Importing Libraries\ud83d\udcda<\/center><\/h3>\n<\/div>","258c466b":"<p><mark>\nAPACHE (acute physiology and chronic health evaluation) severity-of-illness classification system is a measure for describing groups of intensive care unit (ICU) patients and evaluating their care. \n<\/mark><\/p>","2529526b":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Target encoding<\/center><\/h3>\n<\/div>","a63160c9":"<div>\n    <img src=\"https:\/\/i.imgur.com\/pl3FhXV.png\">\n<\/div>","f80737e0":"<center><img src=\"https:\/\/lightgbm.readthedocs.io\/en\/latest\/_images\/LightGBM_logo_black_text.svg\" height=250 width=250><\/center>","2d1eb203":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Modeling<\/center><\/h3>\n<\/div>","bcf47ce0":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Data Dictionary<\/center><\/h3>\n    <h4><center>Supplemental information about the data<\/center><\/h4>\n<\/div>","0d9202fd":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>LightGBM Model<\/center><\/h3>\n<\/div>","ccc1b10c":"<p><mark>We can drop the Unnamed:0 column.<\/mark><\/p>","4ff6c8cf":"<p><mark>There seems to be a mismatch in the number of values per column, we definitely have many missing values.<\/mark><\/p>\n","399e5306":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Handling missing values<\/center><\/h3>\n<\/div>","bb8ba990":"<p><mark>\nEncounter ID, Hospital ID and ICU ID are unique identifiers associated with a patient unit stay, the hospital they were admitted in and the ICU number respectively. Since these are specifically created for the sole purpose of identification, these needn't be included for the model creation. <br><br>\nElective surgery in people with uncontrolled diabetes should preferably be scheduled after acceptable glycemic control has been achieved. We can see a significant drop in the following graph.\n<\/mark><\/p>","c0f513d6":"<div style=\"background-color:#fae1dd;\">\n    <center><img src=\"https:\/\/i.imgur.com\/Kbl1z3a.gif\"><\/center>\n    <br><br>\n    <h3><center>Diabetes Mellitus Prediction<\/center><\/h3>\n    <center><img src=\"https:\/\/2018.igem.org\/wiki\/images\/f\/f8\/T--HAFS--Project_Description_pt1.gif\"><\/center>\n<\/div>","40f3ad1c":"* 1 represents post operative\n* 0 represents non operative","2af01d58":"<p><mark>We need to analyse the distribution of values before we fill in the missing values.<\/mark><\/p>","c096843c":"<div style=\"background-color:#fae1dd; color:black;\">\n    <h3><center>Numerical columns<\/center><\/h3>\n<\/div>","19dbf747":"<center><img src=\"https:\/\/www.dataapplab.com\/wp-content\/uploads\/2017\/08\/xgboost.png\" height=250 width=250><\/center>","7e32a5e4":"<p><mark>\nReducing readmission rates of diabetic patients has the potential to greatly reduce health care costs while simultaneously improving care. \n<\/mark><\/p>","02701590":"<p><mark>\nUsed a new library called PyComp for the following viz \ud83c\udfa8\n<\/mark><\/p>\n\n[Documentation](https:\/\/pypi.org\/project\/pycomp\/)","1e65be6c":"Inspiration:\n- [Custom Jupyter Notebook Theme with plain CSS](https:\/\/medium.com\/@formigone\/my-first-custom-theme-for-jupyter-notebook-a9c1e69efdfe) \ud83c\udfa8\n- [Simple Matplotlib & Visualization Tips \ud83d\udca1](https:\/\/www.kaggle.com\/subinium\/simple-matplotlib-visualization-tips)\n\nIllustrations tools:\n- [Canva](https:\/\/www.canva.com\/en_gb\/) \ud83d\udd8c\ufe0f\n- [Storyset](https:\/\/storyset.com\/) \ud83d\uddbc\ufe0f"}}