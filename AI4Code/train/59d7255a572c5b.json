{"cell_type":{"c6f720de":"code","bd52c333":"code","e42c3eb4":"code","17396a1b":"code","f9e0fe1a":"code","416ba95c":"code","f3b16253":"code","32afdafc":"code","14d40fe5":"code","9ee20c9f":"code","ccf4d54f":"code","5d2590d7":"code","a9bbb928":"code","2ff30494":"code","050b837b":"code","f0a7bf5b":"code","9934dcdc":"code","e6427d5c":"code","19dc13b7":"code","1621d2b6":"code","71675a28":"code","d488bc2e":"code","f9279b07":"code","539a6953":"code","0752f8df":"code","5088d2ff":"code","3a5a483b":"code","db3c8718":"code","d456fcaf":"code","4e515b3c":"code","112e4488":"code","6a00b666":"code","7d7f30c8":"code","1d5a6bf4":"code","1ed33caa":"code","e5fc51cd":"code","4257ca3c":"code","f08f92d1":"code","648dd325":"markdown","3a981580":"markdown","5ffb9b9e":"markdown","91250655":"markdown","ff2131a8":"markdown","e7342e68":"markdown","20bba883":"markdown","13454ef0":"markdown","15be2ed4":"markdown","f3b1494f":"markdown","5aff6d53":"markdown","91eff872":"markdown","b47b51e4":"markdown","51f91f6d":"markdown","d08ffbe5":"markdown","e72ce343":"markdown","f4f119f1":"markdown","79754fd4":"markdown","54665915":"markdown","24eeec5e":"markdown","31e15cb6":"markdown","b16f9c3b":"markdown","a125f01c":"markdown","d5d93cf7":"markdown","debd6c27":"markdown"},"source":{"c6f720de":"# pandas\r\nimport pandas as pd \r\n\r\n# matplotlib\r\nimport matplotlib.pyplot as plt \r\nplt.style.use( 'ggplot')\r\n\r\n# seaborn\r\nimport seaborn as sns\r\n# numpy\r\nimport numpy as np \r\n\r\n# sklearn\r\nfrom sklearn.linear_model import LogisticRegression\r\nfrom sklearn.svm import SVC\r\nfrom sklearn.ensemble import RandomForestClassifier\r\nfrom xgboost import XGBClassifier\r\nfrom sklearn.metrics import confusion_matrix\r\n\r\nimport warnings\r\nwarnings.filterwarnings('ignore')\r\n","bd52c333":"import logging\r\nlogger = logging.getLogger()\r\nfhandler = logging.FileHandler(filename='test.log', mode='a')\r\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\nfhandler.setFormatter(formatter)\r\nlogger.addHandler(fhandler)\r\nlogger.setLevel(logging.DEBUG)","e42c3eb4":"data = pd.read_csv('..\/input\/mushroom-classification\/mushrooms.csv')\r\nlogging.debug(\"Print Shape of Dataset {} \".format(data.head()))","17396a1b":"for i in data.columns:\r\n    print(i,data[i].unique())","f9e0fe1a":"data.columns\r\nlogging.debug(\"Columns In our Dataset {}:\".format(data.columns))","416ba95c":"data.info()\r\nlogging.debug(\"Check data types of Columns {}\".format(data.info()))","f3b16253":"data.isnull().sum()\r\nlogging.debug(\"Check for NULL Values {}\".format(data.isnull().sum()))","32afdafc":"plt.figure(figsize=(8,6))\r\ncap_shapes = data['cap-shape'].value_counts().tolist()\r\nshape_names = ['convex','flat','knobbed','bell','sunken','conical']\r\ncolors = ['brown','lightcoral','darkorange','lime','navy','red']\r\nplt.bar(shape_names,cap_shapes,color = colors);\r\nplt.xlabel('Mushrooms Cap Shape');\r\nplt.ylabel(\"Count\");\r\nplt.title(\"Count of Mushrooms Cap shape\");\r\nlogging.debug(\"Barchart for Mushrooms Cap Shape\")","14d40fe5":"plt.figure(figsize=(9,6))\r\ncap_color = data['cap-color'].value_counts().tolist()\r\ncolor_name = ['brown', 'gray','red','yellow','white','buff','pink','cinnamon','purple','green']\r\ncolors = ['brown','gray','red','yellow','mistyrose','tomato','pink','violet','purple','green']\r\nplt.bar(color_name,cap_color,color = colors);\r\nplt.ylabel('Counts');\r\nplt.xlabel(\"Mushroom Cap Color\");\r\nplt.title(\"Mushrooms Cap Color\");\r\nlogging.debug(\"Barchart for Mushrooms Cap Color\")","9ee20c9f":"edible_mushrooms = data[data['class'] == 'e']['cap-color'].value_counts().tolist()[:-2]\r\nnon_edible_mushrooms = data[data['class'] == 'p']['cap-color'].value_counts().tolist()\r\ncolor_name = ['brown', 'gray','red','yellow','white','buff','pink','cinnamon']","ccf4d54f":"fig, ax = plt.subplots(figsize=(12,7))\r\nindex = np.arange(8)\r\nbar_width = 0.35\r\nedible_bars = ax.bar(index, edible_mushrooms, bar_width,color='b',label='edible')\r\npoison_bars = ax.bar(index+bar_width,non_edible_mushrooms ,bar_width, color='r',label='poisonous')\r\nplt.xticks(index + bar_width, tuple(color_name));\r\nplt.title(\"Edible and Poisonous Mushrooms based on Cap Color\",{'fontsize':25})\r\nplt.xlabel(\"Cap Color\");\r\nplt.ylabel(\"Count\")\r\nplt.legend();\r\nlogging.debug(\"Barchart for edible and poisonous mushrooms based on Cap Color\")","5d2590d7":"plt.figure(figsize=(9,6))\r\nodor_val = data['odor'].value_counts().tolist()\r\nodors = ['no smell','foul','spicy','fishy','anise','alomond','punget','creosote','musty']\r\nclrs = ['magenta','deeppink','cyan','gold','crimson','chocolate','springgreen','blue','red']\r\nplt.bar(odors,odor_val,color = clrs);\r\nplt.xlabel('Mushrooms Odor');\r\nplt.ylabel(\"Count\");\r\nplt.title(\"Distribution of mushrooms based on odor\",{'fontsize':20});\r\nlogging.debug(\"Distribution of mushrooms based on Color\")","a9bbb928":"plt.figure(figsize=(8,8))\r\npopulations = data.population.value_counts().tolist()\r\nlabels = ['several','solitary','scattered','numerous','abundent','clustered']\r\nexplode =  (0, 0.1, 0, 0, 0, 0)\r\nplt.pie(populations,labels=labels,startangle=150,explode=explode,autopct='%1.1f%%');\r\nplt.title('Mushrooms Population',{'fontsize':25})\r\nplt.legend(bbox_to_anchor=(1.2,1),loc=\"upper right\",fontsize=14);\r\nlogging.debug(\"Piechart for Mushrooms Population\")","2ff30494":"data[data['class'] == 'p']['population'].value_counts()","050b837b":"plt.figure(figsize=(8,7))\r\nplt.pie(data[data['class'] == 'p']['population'].value_counts().tolist(),\r\n        autopct='%1.1f%%',\r\n        labels = ['several','solitary','scattered','numerous'],\r\n        colors=['gold','cyan','royalblue','hotpink'],\r\n        explode = (0,0,0,0.55)\r\n        );\r\nplt.title('Distribution of poisounous mushrooms based on population',{'fontsize':25});\r\nplt.legend(bbox_to_anchor=(1.2,1),loc=\"upper right\",fontsize=15);","f0a7bf5b":"plt.figure(figsize=(8,7))\r\nplt.pie(data[data['class'] == 'e']['population'].value_counts().tolist(),\r\n        autopct='%1.1f%%',\r\n        labels = ['several','solitary','scattered','numerous','abundent','clustered'],\r\n        colors=['lightcoral','orange','lime','deepskyblue','yellow','pink']\r\n        );\r\nplt.title('Distribution of edible mushrooms based on population',{'fontsize':25});\r\nplt.legend(bbox_to_anchor=(1.2,1),loc=\"upper right\",fontsize=13);","9934dcdc":"plt.figure(figsize=(8,6))\r\nhabitats = data['habitat'].value_counts().tolist()\r\nhabitats_names = ['woods','grasses','paths','leaves','urban','meadows','waste']\r\ncolors = ['orange','lime','deepskyblue','magenta','crimson','blue','red']\r\nplt.title(\"Mushrooms based on Habitat\",{'fontsize':25});\r\nplt.bar(habitats_names,habitats,color = colors);","e6427d5c":"data.head()","19dc13b7":"from sklearn.preprocessing import LabelEncoder\r\nencoder = LabelEncoder()\r\nlogging.debug(\"Import LabelEncoder and create object.\")","1621d2b6":"X = data.drop('class',axis=1)\r\ny = data['class']\r\nlogging.debug(\"Split data int dependent(y) and Independent features(X)\")","71675a28":"def func(df):\r\n    if df == 'p':\r\n        return 1\r\n    else:\r\n        return 0\r\ny = y.apply(func)\r\nlogging.debug(\"Function for dependent feature to convert categorical values to numeric values(If class is p set to 1 and for e set 0)\")","d488bc2e":"objList = X.select_dtypes(include = \"object\").columns","f9279b07":"for feat in objList:\r\n    X[feat] = encoder.fit_transform(X[feat])\r\nlogging.debug(\"Concert categorical features into numeric.\")","539a6953":"for i in data.columns:\r\n    print(i,\":\",data[i].unique())","0752f8df":"for i in X.columns:\r\n    print(i,\":\",X[i].unique())","5088d2ff":"from sklearn.model_selection import train_test_split\r\nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=43)\r\nlogging.debug(\"Split data into train data and test data(validation set).\")","3a5a483b":"models = {\r\n    SVC(kernel='rbf',C= 1.0,gamma=0.8):'Support Vector Machine',\r\n    RandomForestClassifier(max_depth=8,n_estimators=120):'Random Forest',\r\n    XGBClassifier(eval_metric  = 'error',booster='gbtree'):'XGBClassifier'\r\n}\r\nfor m in models.keys():\r\n    m.fit(X_train,y_train)\r\nlogging.debug(\"Create models and fit model based on train data and test data.\")","db3c8718":"for model,name in models.items():\r\n     print(f\"Accuracy Score for {name} is : \",model.score(X_test,y_test)*100,\"%\")\r\n     logging.debug(\"Accuracy of Each model\")\r\n     logging.debug(\"Accuracy Score for {} is {}%\".format(name,model.score(X_test,y_test)*100))","d456fcaf":"plt.figure(figsize=(9,7))\r\nxgboost = XGBClassifier(eval_metric  = 'error',booster='gbtree')\r\nxgboost.fit(X_train,y_train)\r\nfeature_imp1 = xgboost.feature_importances_\r\nsns.barplot(x=feature_imp1, y=X.columns)\r\n# Add labels to your graph\r\nplt.xlabel('Feature Importance Score')\r\nplt.ylabel('Features')\r\nplt.title(\"Visualizing Important Features For XGBClassifier\",{'fontsize':25})\r\nplt.show();\r\nfeature_dict = {k:v for (k,v) in zip(X.columns,feature_imp1)}\r\nlogging.debug(\"Feature Importance for Random Forest : {}\".format(feature_dict))","4e515b3c":"mush_df = X.copy()","112e4488":"new_X = mush_df.drop(['cap-shape','gill-attachment','gill-spacing','veil-type', 'veil-color','stalk-surface-above-ring','ring-number',\r\n       'ring-type'],axis=1)","6a00b666":"new_X.columns","7d7f30c8":"new_Xtrain,new_Xtest,new_ytrain,new_ytest = train_test_split(new_X,y,test_size=0.2,random_state=43)","1d5a6bf4":"models = {\r\n    SVC(kernel='rbf',C= 1.0,gamma=0.8):'Support Vector Machine',\r\n    RandomForestClassifier():'Random Forest',\r\n    XGBClassifier(eval_metric  = 'error',booster='gbtree'):'XGBClassifier'\r\n}\r\nfor m in models.keys():\r\n    m.fit(new_Xtrain,new_ytrain)\r\nfor model,name in models.items():\r\n     print(f\"Accuracy Score for {name} is : \",model.score(new_Xtest,new_ytest)*100,\"%\")","1ed33caa":"class_names = [0,1]\r\nfig,ax = plt.subplots()\r\ntick_marks = np.arange(len(class_names))\r\nplt.xticks(tick_marks,class_names)\r\nplt.yticks(tick_marks,class_names)\r\n\r\n\r\nfor model,name in models.items():\r\n    y_pred = model.predict(new_Xtest)\r\n    cnf_matrix = confusion_matrix(new_ytest,y_pred)\r\n    sns.heatmap(pd.DataFrame(cnf_matrix), annot = True, cmap = 'YlGn',\r\n            fmt = 'g')\r\n    ax.xaxis.set_label_position('top')\r\n    plt.tight_layout()\r\n    plt.title(f'Heat Map for {name}', {'fontsize':20})\r\n    plt.ylabel('Actual label')\r\n    plt.xlabel('Predicted label')\r\n    plt.show()","e5fc51cd":"forest = RandomForestClassifier()\r\nforest.fit(new_Xtrain,new_ytrain)","4257ca3c":"y_pred = forest.predict(new_Xtest)","f08f92d1":"from sklearn.metrics import f1_score\r\nprint(f1_score(y_test,y_pred))","648dd325":"## Edible mushrooms based on population","3a981580":"# Models","5ffb9b9e":"## No of Mushrooms are edible and poisonous based on cap color","91250655":"## Distribution of poisounous mushrooms based on population","ff2131a8":"# F1 Score\r\n## The F1 Score is the 2*((precision*recall)\/(precision+recall))","e7342e68":"# Data Visualization","20bba883":"## Check for NULL Values","13454ef0":"# Data Preprocessing","15be2ed4":"with open('E:\\DataScienceProjects\/mushroom.sav','rb') as f:\r\n    mp = pickle.load(f)","f3b1494f":"## Check accuracy after removing some features.","5aff6d53":"# Save Model","91eff872":"## Dependent and Independent Features","b47b51e4":"## To get a good prediction, divide the data into training and testing data, it is because as the name suggests you will train few data points and test few data points, and keep on doing that unless you get good results.\r\n","51f91f6d":"## To determine how well a model is performing, we often validate its performance on new unseen instances that were not available to the model during training","d08ffbe5":"## Barchart for Mushorroms cap shapes","e72ce343":"## Habitat","f4f119f1":"## We can see here that many features are not very mush important to makepredictions so we remove them","79754fd4":"## Mushrooms Cap Color","54665915":"# Read Data","24eeec5e":"# Exploratory Data Analysis (or EDA)","31e15cb6":"## XGBOOST Classifier","b16f9c3b":"<!-- ### cap-shape: bell=b,conical=c,convex=x,flat=f, knobbed=k,sunken=s\r\n\r\ncap-surface: fibrous=f,grooves=g,scaly=y,smooth=s\r\n\r\ncap-color: brown=n,buff=b,cinnamon=c,gray=g,green=r,pink=p,purple=u,red=e,white=w,yellow=y\r\n\r\nbruises: bruises=t,no=f\r\n\r\nodor: almond=a,anise=l,creosote=c,fishy=y,foul=f,musty=m,none=n,pungent=p,spicy=s\r\n\r\ngill-attachment: attached=a,descending=d,free=f,notched=n\r\n\r\ngill-spacing: close=c,crowded=w,distant=d\r\n\r\ngill-size: broad=b,narrow=n\r\n\r\ngill-color: black=k,brown=n,buff=b,chocolate=h,gray=g, green=r,orange=o,pink=p,purple=u,red=e,white=w,yellow=y\r\n\r\nstalk-shape: enlarging=e,tapering=t\r\n\r\nstalk-root: bulbous=b,club=c,cup=u,equal=e,rhizomorphs=z,rooted=r,missing=?\r\n\r\nstalk-surface-above-ring: fibrous=f,scaly=y,silky=k,smooth=s\r\n\r\nstalk-surface-below-ring: fibrous=f,scaly=y,silky=k,smooth=s\r\n\r\nstalk-color-above-ring: brown=n,buff=b,cinnamon=c,gray=g,orange=o,pink=p,red=e,white=w,yellow=y\r\n\r\nstalk-color-below-ring: brown=n,buff=b,cinnamon=c,gray=g,orange=o,pink=p,red=e,white=w,yellow=y\r\n\r\nveil-type: partial=p,universal=u\r\n\r\nveil-color: brown=n,orange=o,white=w,yellow=y\r\n\r\nring-number: none=n,one=o,two=t\r\n\r\nring-type: cobwebby=c,evanescent=e,flaring=f,large=l,none=n,pendant=p,sheathing=s,zone=z\r\n\r\nspore-print-color: black=k,brown=n,buff=b,chocolate=h,green=r,orange=o,purple=u,white=w,yellow=y\r\n\r\npopulation: abundant=a,clustered=c,numerous=n,scattered=s,several=v,solitary=y\r\n\r\nhabitat: grasses=g,leaves=l,meadows=m,paths=p,urban=u,waste=w,woods=d  -->","a125f01c":"# iNterpret","d5d93cf7":"# Feature Importance","debd6c27":"## Plot Heatmaps for all models"}}