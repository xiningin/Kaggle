{"cell_type":{"208241b3":"code","1852c720":"code","94b3eea7":"code","0daf48cd":"code","ef5ed21e":"code","83449e8a":"code","f2fc0685":"code","fdd95140":"code","4e4003be":"code","b9ef2fbe":"code","89317712":"code","2b95a639":"code","0928ade2":"code","a20ff550":"code","8ce300ea":"code","ae094c4d":"code","8e59cab3":"code","23da2ac3":"code","f35679f0":"code","5810698a":"code","2ab721d2":"code","95c6f5e5":"code","0ec43f37":"code","1912fd34":"code","f61ed084":"code","d5867560":"code","29caa81c":"code","033fe5be":"markdown","871a13b7":"markdown","9dd82940":"markdown","d29d2a3c":"markdown","46306c83":"markdown","f4f6266b":"markdown","e2c0bd38":"markdown","da08f69e":"markdown","da62c1ab":"markdown","da57c87a":"markdown","9ae679eb":"markdown","d19c1056":"markdown","e0bd49fe":"markdown","c29e9b5e":"markdown","474b94fc":"markdown","15f479fb":"markdown","391acb05":"markdown","f2d9d772":"markdown","225e2561":"markdown","b814c931":"markdown","d56e4a8b":"markdown","3506f985":"markdown","ea548aac":"markdown","bd390644":"markdown","e803e070":"markdown","7d4ecd0d":"markdown","85113827":"markdown","28ee181a":"markdown"},"source":{"208241b3":"import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.spatial.distance import jaccard\n\nimport pydensecrf.densecrf as dcrf\nfrom pydensecrf.utils import unary_from_labels, create_pairwise_bilateral, unary_from_softmax, create_pairwise_gaussian","1852c720":"ls ..\/input -a","94b3eea7":"%matplotlib inline","0daf48cd":"H = W = 96","ef5ed21e":"def iou(y_true, y_pred):\n    y_true = y_true.flatten()\n    y_pred = y_pred.flatten()\n    \n    return(1 - jaccard(y_true, y_pred))","83449e8a":"images = np.load('..\/input\/validation-set\/x.npy')\ntrue_masks = np.load('..\/input\/validation-set\/y.npy')[..., 0]\nmask_probabilities = np.load('..\/input\/validation-set\/preds_valid.npy')[..., 0]","f2fc0685":"ix = np.random.randint(images.shape[0])\nix = 87\nimg = images[ix, ..., 0]\nmask = true_masks[ix]\nmask_proba = mask_probabilities[ix]\nmask_probas = np.rollaxis(np.stack([1 - mask_proba, mask_proba], axis = 2), 2, 0)","fdd95140":"threshold = 0.69\nmask_pred = np.int32(mask_proba > threshold)","4e4003be":"f, (ax1, ax2) = plt.subplots(2, 2, sharey=True,sharex=True)\n# ax1.set_aspect('equal')\nax1[0].imshow(img, cmap='seismic'); ax1[0].axis('off'); ax1[0].set_title('Input Image')\nax1[1].imshow(mask); ax1[1].axis('off'); ax1[1].set_title('Ground Truth')\nax2[0].imshow(mask_proba); ax2[0].axis('off'); ax2[0].set_title('Mask Probabilities')\nax2[1].imshow(mask_pred); ax2[1].axis('off'); ax2[1].set_title('Mask Prediction')\n# plt.subplots_adjust(wspace=0.8)\nplt.show()","b9ef2fbe":"initial_iou = iou(mask, mask_pred)","89317712":"d_l = dcrf.DenseCRF2D(H, W, 2)\nd_p = dcrf.DenseCRF2D(H, W, 2)","2b95a639":"U_from_labels = unary_from_labels(mask_pred, 2, gt_prob=0.7, zero_unsure=False)\nU_from_proba = unary_from_softmax(mask_probas)","0928ade2":"d_l.setUnaryEnergy(U_from_labels)\nd_p.setUnaryEnergy(U_from_proba)","a20ff550":"Q_l = d_l.inference(10)\nQ_p = d_p.inference(10)","8ce300ea":"map_l = np.argmax(Q_l, axis=0).reshape((H, W))\nmap_p = np.argmax(Q_p, axis=0).reshape((H, W))","ae094c4d":"f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\nax1.imshow(U_from_labels.reshape((2, H,W))[0]); ax1.axis('off'); ax1.set_title('Unary from labels')\nax2.imshow(map_l); ax2.axis('off'); ax2.set_title('MAP from labels');","8e59cab3":"iou(mask, map_l) - initial_iou","23da2ac3":"f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\nax1.imshow(U_from_proba.reshape((2, H,W))[0]); ax1.axis('off'); ax1.set_title('Unary from proba')\nax2.imshow(map_p); ax2.axis('off'); ax2.set_title('MAP from proba');","f35679f0":"iou(mask, map_p) - initial_iou","5810698a":"pairwise_bilateral = create_pairwise_bilateral(sdims=(5, 5), schan=(0.01,), img=np.expand_dims(img, -1), chdim=2)","2ab721d2":"d_l = dcrf.DenseCRF2D(H, W, 2)\nd_p = dcrf.DenseCRF2D(H, W, 2)","95c6f5e5":"d_l.setUnaryEnergy(U_from_labels)\nd_l.addPairwiseEnergy(pairwise_bilateral, compat=10)\n\nd_p.setUnaryEnergy(U_from_proba)\nd_p.addPairwiseEnergy(pairwise_bilateral, compat=10)","0ec43f37":"def run_inference(d):\n    Q, tmp1, tmp2 = d.startInference()\n    for _ in range(2):\n        d.stepInference(Q, tmp1, tmp2)\n    kl1 = d.klDivergence(Q) \/ (H*W)\n    map_soln1 = np.argmax(Q, axis=0).reshape((H,W))\n\n    for _ in range(8):\n        d.stepInference(Q, tmp1, tmp2)\n    kl2 = d.klDivergence(Q) \/ (H*W)\n    map_soln2 = np.argmax(Q, axis=0).reshape((H,W))\n\n    for _ in range(16):\n        d.stepInference(Q, tmp1, tmp2)\n    kl3 = d.klDivergence(Q) \/ (H*W)\n    map_soln3 = np.argmax(Q, axis=0).reshape((H,W))\n    return(map_soln1, kl1, map_soln2, kl2, map_soln3, kl3)","1912fd34":"map_soln1, kl1, map_soln2, kl2, map_soln3, kl3 = run_inference(d_l)\n\nimg_en = pairwise_bilateral.reshape((-1, H, W))  # Reshape just for plotting\nplt.figure(figsize=(15,5))\nplt.subplot(1,3,1); plt.imshow(map_soln1);\nplt.title('MAP Solution with DenseCRF\\n(2 steps, KL={:.2f})'.format(kl1)); plt.axis('off');\nplt.subplot(1,3,2); plt.imshow(map_soln2);\nplt.title('MAP Solution with DenseCRF\\n(8 steps, KL={:.2f})'.format(kl2)); plt.axis('off');\nplt.subplot(1,3,3); plt.imshow(map_soln3);\nplt.title('MAP Solution with DenseCRF\\n(16 steps, KL={:.2f})'.format(kl3)); plt.axis('off');","f61ed084":"iou(mask, map_soln3) - initial_iou","d5867560":"map_soln1, kl1, map_soln2, kl2, map_soln3, kl3 = run_inference(d_p)\n\nimg_en = pairwise_bilateral.reshape((-1, H, W))  # Reshape just for plotting\nplt.figure(figsize=(15,5))\nplt.subplot(1,3,1); plt.imshow(map_soln1);\nplt.title('MAP Solution with DenseCRF\\n(2 steps, KL={:.2f})'.format(kl1)); plt.axis('off');\nplt.subplot(1,3,2); plt.imshow(map_soln2);\nplt.title('MAP Solution with DenseCRF\\n(8 steps, KL={:.2f})'.format(kl2)); plt.axis('off');\nplt.subplot(1,3,3); plt.imshow(map_soln3);\nplt.title('MAP Solution with DenseCRF\\n(16 steps, KL={:.2f})'.format(kl3)); plt.axis('off');","29caa81c":"iou(mask, map_soln3) - initial_iou","033fe5be":"`x` is a numpy array of shape (batch_size, H, W).\n\nIt is the images for a specific batch.\n\n\n\n`y` is a numpy array of shape (batch_size, H, W, 1).\n\nIt is the ground truth masks for a specific batch.\n\n\n\n`preds_valid` is a numpy array of shape (batch_size, H, W, 1).\n\nIt is the result of the U-net model for a specific batch, given as probabilities.","871a13b7":"Change in IOU","9dd82940":"Using the code from thepydensecrf repo, we can do the inference in steps to track intermediate solutions as well as the KL-divergence which indicates how well we have converged.","d29d2a3c":"The summary is based on individually analyzing images. A more automated approach that considers all images should be used.\n\nThe convergence of the basic CRF model should be explored similarly to what is done with the pairwise bilateral model.\n\nThe hyperparameters of the pairwise bilateral term may not be optimal.\n\nA pairwise gaussian term should be explored along with its hyperparameters.\n\nFinally, the gt_prop (which used when creating the unary from labels) parameter may need to be tuned. It is interpreted as our confidence in the predicted mask, so it should be different for each image. I don't think it would be worth the effort to use a bayesian U-net model just for this parameter, especially when the unary from softmax performs much better already.","46306c83":"### Unary from labels","f4f6266b":"Inspect the unary and MAP from probabilities:","e2c0bd38":"# Run inference with only the unary","da08f69e":"# Summary","da62c1ab":"Change in IOU","da57c87a":"### Add bilateral term\n\nThe bilateral term makes the assumption that pixels with either a similar color or a similar location are likely to belong to the same class.\n\nThe sdims parameter defines the strenght of the location bilateral and the schan parameter defines the strength of the image content bilateral.","9ae679eb":"The pairwise bilateral term usually degrades the final binary mask.\n\nCreating the unary from the probabilities usually gives a better final binary mask than creating the unary from the predicted mask.","d19c1056":"### Run inference with the pairwise bilateral term","e0bd49fe":"Inspect the unary and MAP from labels:","c29e9b5e":"A random image is selected.","474b94fc":"This is more of a baseline test. This method does not account for a pixel's neighbors.","15f479fb":"Change in IOU","391acb05":"The whole point of DenseCRFs is to use some form of content to smooth out predictions. This is done via \"pairwise\" terms, which encode relationships between elements.","f2d9d772":"I built the unary both from the mask probabilities and the mask predictions.","225e2561":"Find the folder name","b814c931":"### Unary from proba","d56e4a8b":"I define a simple IOU function to compare the results of the basic model with the different CRF models.\n\nTODO: The jaccard function currently gives a RuntimeError when the mask is empty. Solution: preset the 'random' image...","3506f985":"# Futher work","ea548aac":"Change in IOU","bd390644":"The threshold is determined after training by iterating over multiple thresholds and calculating the mean precision over the given IOU thresholds for all validation images. This calculation is done in the training kernel.","e803e070":"During training, I downsampled the images slightly to fit in the U-net. I believe the number of labels should be two: 0 - background, 1 - salt. Also both class probabilies need to be used (i.e. mask_probabilities and 1 - mask_probabilities.","7d4ecd0d":"# Construct the CRF","85113827":"# Read in the data, masks, and predicted masks","28ee181a":"# Pairwise terms"}}