{"cell_type":{"80c7b7dd":"code","90979aec":"code","022f783b":"code","7e24a830":"markdown","311b38b8":"markdown","cadcaa33":"markdown","9ec14caf":"markdown","7886fbc0":"markdown","57cd2dd2":"markdown","7e0c4cfe":"markdown","c7ba80d6":"markdown","e05519ca":"markdown"},"source":{"80c7b7dd":"import warnings\nwarnings.filterwarnings('ignore')\nimport pandas as pd\nimport itertools\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport datetime as dt\nfrom datetime import timedelta\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error,r2_score\nfrom fbprophet import Prophet\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.ar_model import AR\nfrom statsmodels.tsa.arima_model import ARMA\nfrom statsmodels.tsa.arima.model import ARIMA\nstd=StandardScaler()\nfrom statsmodels.tools.eval_measures import rmse\nfrom sklearn.preprocessing import MinMaxScaler\nfrom keras.preprocessing.sequence import TimeseriesGenerator\nfrom keras.models import Sequential\nfrom keras.layers import Dense,LSTM\nfrom pmdarima import auto_arima\nfrom statsmodels.tsa.statespace.varmax import VARMAX, VARMAXResults","90979aec":"pip install pmdarima","022f783b":"d1=str(input('Enter dataset file name : '))\nd2=str(input('Enter format of the file \"csv\" or \"excel\" : ' ))\nprint('\\n')\nif d2=='csv':\n    d1=d1+'.csv'\n    d3=pd.read_csv(d1)\nelif d2=='excel':\n    d1=d1+'.xlsx'\n    d3=pd.read_excel(d1)\ns1=str(input('Enter the column name of the date : '))\nprint('\\n')\nd5=pd.read_excel('Dateformats.xlsx')\ndisplay(HTML(d5.to_html()))\nprint('\\n')\ns2=str(input('Enter the format of the'+' '+s1+' '+'from the above tabel (e.g %d-%Y-%m): ' ))\nprint('\\n')\ns3=int(input('Enter the number of features you want to forecast ? : '))\nif s3==1:\n    s4=str(input('Enter the name of the feature you want to forecast on : '))\n    print('\\n')\n    d3[s1]=pd.to_datetime(d3[s1], format=s2, infer_datetime_format=True)\n    \n#Code to remove special characters and null values in the forecasting feature\n    list1=[]\n    list3=[]\n    for i in range(len(d3[s4])):\n        try:\n            list1.append(int(d3[s4][i]))\n        \n        except:\n            list3.append(i)\n            continue\n    for i in range(len(list3)):\n        n2=d3[s4][list3[i]]\n        d3[s4].replace(n2,np.nan,inplace=True)\n    for i in range(len(d3)):\n        d3[s4].fillna(d3[s4].median(),inplace=True)\n    d3[s4]=d3[s4].astype(int)\n\n    s5=str(input('Do you want to forecast'+' '+s4+' '+'on any category in the features (eg:- country(India)) or want to forecast'+' '+s4+' '+'on whole (Yes\/No) : '))\n    print('\\n')\n    if s5=='No':\n        datewise=d3.groupby([s1]).agg({s4:'sum'})\n    elif s5=='Yes':\n        s6=str(input('Enter the feature name from which who want to pick the category (eg:- country): '))\n        s7=str(input('Ente the category name from'+' '+s6+' '+'to forecast'+' '+s4+' '+'  : '))\n        s8=d3[d3[s6]==s7]\n        datewise=s8.groupby([s1]).agg({s4:'sum'})\n        \n        \n    #ARIMA\n    datewise= datewise.astype('float32')\n    model_train=datewise.iloc[:int(datewise.shape[0]*0.95)]\n    valid=datewise.iloc[int(datewise.shape[0]*0.95):]\n    n11=pd.infer_freq(datewise.index, warn=True)\n    list9=[]\n    model_arima= auto_arima(model_train[s4],trace=True, error_action='ignore', start_p=1,start_q=1,max_p=3,max_q=3,\n                   suppress_warnings=True,stepwise=False,seasonal=False)\n    model_arima.fit(model_train\n                [s4])\n    prediction_arima=model_arima.predict(len(valid))\n    print(\"Root Mean Square Error for ARIMA Model: \",np.sqrt(mean_squared_error(list(valid[s4]),(prediction_arima))))\n    list9.append(np.sqrt(mean_squared_error(list(valid[s4]),(prediction_arima))))\n    print('\\n')\n    t=int(input('Enter number of days to forecast ? :'))\n    m1=model_arima.order\n    model = ARIMA(datewise[s4],order=m1)\n    results = model.fit()\n    s=t-1\n    forecast_arima = results.predict(len(datewise),len(datewise)+t,typ='levels').rename(s4)\n\n\n\n\n    #FB PROPHET   \n    datewise1=datewise.reset_index()\n    datewise1.rename(columns={s1: 'ds',s4: 'y'},inplace=True)\n    train=datewise1.iloc[:int(datewise1.shape[0]*0.95)]\n    valid=datewise1.iloc[int(datewise1.shape[0]*0.95):]\n    m=Prophet(weekly_seasonality=True)\n    m.fit(train)\n    future=m.make_future_dataframe(periods=len(valid),freq=n11)\n    forecast=m.predict(future)\n    predictions=forecast.tail(len(valid))['yhat']\n    print('\\n')\n    print(\"Root Mean Squared Error for Prophet Model: \",rmse(valid['y'],predictions))\n    print('\\n')\n    list9.append(rmse(valid['y'],predictions))\n    m=Prophet(weekly_seasonality=True)\n    m.fit(datewise1)\n    future=m.make_future_dataframe(periods=t,freq=n11)\n    forecast=m.predict(future)\n    forecast_prophet=forecast[['ds','yhat']].tail(t)\n\n\n    #LSTM\n\n\n    train=datewise.iloc[:int(datewise.shape[0]*0.95)]\n    test=datewise.iloc[int(datewise.shape[0]*0.95):]\n    scaler=MinMaxScaler()\n    scaler.fit(train)\n    scaled_train=scaler.transform(train)\n    scaled_test=scaler.transform(test)\n    n_input=len(test)\n    n_features=1\n    generator=TimeseriesGenerator(scaled_train,scaled_train,length=n_input,batch_size=1)\n    model=Sequential()\n    model.add(LSTM(150,activation='relu',input_shape=(n_input,n_features)))\n    model.add(Dense(1))\n    model.compile(optimizer='adam',loss='mse')\n    model.fit_generator(generator,epochs=30)\n    first_eval_batch=scaled_train[-n_input:]\n    test_predictions=[]\n    first_eval_batch=scaled_train[-n_input:]\n    current_batch=first_eval_batch.reshape((1,n_input,n_features))\n    for i in range(len(test)):\n        current_pred=model.predict(current_batch)[0]\n        test_predictions.append(current_pred)\n        current_batch=np.append(current_batch[:,1:,:],[[current_pred]],axis=1)\n    true_predictions=scaler.inverse_transform(test_predictions)\n    test['predictions']=true_predictions\n    list9.append(rmse(test[s4],test['predictions']))\n    print('\\n')\n    print(\"Root Mean Square Error for LSTM Model: \", rmse(test[s4],test['predictions']))\n    print('\\n')\n    train=datewise\n    scaler.fit(train)\n    train=scaler.transform(train)\n    n_input=len(test)\n    n_features=1\n    generator=TimeseriesGenerator(train,train,length=n_input,batch_size=1)\n    model.fit_generator(generator,epochs=30)\n    test_predictions=[]\n    first_eval_batch=train[-n_input:]\n    current_batch=first_eval_batch.reshape((1,n_input,n_features))\n    for i in range(t):\n        current_pred=model.predict(current_batch)[0]\n        test_predictions.append(current_pred)\n        current_batch=np.append(current_batch[:,1:,:],[[current_pred]],axis=1)\n    from pandas.tseries.offsets import DateOffset\n    add_dates=[datewise.index[-1]+DateOffset(months=x) for x in range(0,t+1)]\n    future_dates=pd.DataFrame(index=add_dates[1:],columns=datewise.columns)\n    df_predict=pd.DataFrame(scaler.inverse_transform(test_predictions),index=future_dates[-t:].index,columns=[s4])\n    d_proj=df_predict\n    d_proj.reset_index(drop=True, inplace=True)\n    forecast_prophet.reset_index(drop=True, inplace=True) \n    d1=pd.DataFrame(forecast_prophet['ds'])\n    lstm=pd.concat([d1,d_proj],axis=1)\n\n\n    # Choosing best model\n    print('\\n')\n    t=str(t)\n    print('Forecasted Data of '+s4+' feature for '+t+ ' days : ' )\n    print('\\n')\n    small=float('inf')\n    for i in range(len(list9)):\n        if list9[i]<small:\n            small=list9[i]\n    no=list9.index(small)\n    if no==0:\n        forecast_arima=pd.DataFrame(forecast_arima)\n        forecast_arima.reset_index(drop=True, inplace=True)\n        d18=pd.DataFrame(forecast_prophet['ds'])\n        d18.reset_index(drop=True, inplace=True)\n        forecast_arima=pd.concat([d18,forecast_arima],axis=1)\n        forecast_arima.rename(columns={'ds':s1},inplace=True)\n        forecast_data=forecast_arima\n        forecast_data1 = forecast_data.set_index(s1)\n        forecast_data1\n        #print(forecast_data1)\n    \n    elif no==1:\n        forecast_prophet.rename(columns={'ds':s1,'yhat':s4},inplace=True)\n        forecast_data=forecast_prophet\n        forecast_data1 = forecast_data.set_index(s1)\n           \n    \n    elif no==2:\n        lstm.rename(columns={'ds':s1},inplace=True)\n        forecast_data=lstm\n        forecast_data1 = forecast_data.set_index(s1)\n\n    print(forecast_data1)\n\n    fig,ax=plt.subplots(nrows=1, ncols=1)\n    ax.plot(datewise[s4],label=\"Original Data\")\n    ax.plot(forecast_data1[s4],label=\"Forecasted Data\")\n    ax.legend()\n    ax.set_xlabel(\"Date\")\n    ax.set_ylabel(s4)\n    ax.set_title(s4)\n    plt.xticks(rotation=90)\n    plt.show()\n    \n    \n    \n    \n    \n#VARMAX    \n    \nif s3>1:\n    \n    s4=str(input('Enter the features to forecast : '))\n    n2=s4\n    n4=n2.split()\n    n5=n2.split()\n    s5=str(input('Do you want to forecast'+' '+s4+' '+'on any category in the features (eg:- country(India)) or want to forecast'+' '+s4+' '+'on whole (Yes\/No) : '))\n    print('\\n')\n    if s5=='No':\n        datewise=d3.groupby([s1]).agg({n4[0]:'sum'})\n        n4.pop(0)\n        for i in range(len(n4)):\n            d3i=d3.groupby([s1]).agg({n4[i]:'sum'})\n            datewise=pd.concat([datewise,d3i],axis=1)\n    elif s5=='Yes':\n        s6=str(input('Enter the feature name from which who want to pick the category (eg:- country): '))\n        s7=str(input('Ente the category name from'+' '+s6+' '+'to forecast'+' '+s4+' '+'  : '))\n        s8=d3[d3[s6]==s7]\n        datewise=s8.groupby([s1]).agg({n4[0]:'sum'})\n        n4.pop(0)\n        for i in range(len(n4)):\n            d3i=s8.groupby([s1]).agg({n4[i]:'sum'})\n            datewise=pd.concat([datewise,d3i],axis=1)\n    list1=[]\n    list2=[]\n    list3=[]\n    list4=[]\n    for i in range(len(n5)):\n        model_arima= auto_arima(datewise[n5[i]],trace=True, error_action='ignore', start_p=1,start_q=1,max_p=3,max_q=3,\n                       suppress_warnings=True,stepwise=False,seasonal=False)\n        list1.append(model_arima.order)\n\n    for i in range(len(list1)):\n        list2.append(list1[i][0])\n        list3.append(list1[i][1])\n        list4.append(list1[i][2])\n    list2.sort(reverse=True)\n    p=list2[0]\n    list3.sort(reverse=True)\n    d=list3[0]\n    list4.sort(reverse=True)\n    q=list4[0]\n    if d<1:\n        df_transformed = datewise \n    elif d==1:\n        df_transformed = datewise.diff()\n        df_transformed = df_transformed.dropna()\n    elif d>1:\n        df_transformed = datewise.diff().diff()\n        df_transformed = df_transformed.dropna()\n    nobs=12\n    train, test = df_transformed[0:-nobs], df_transformed[-nobs:]\n    model = VARMAX(train, order=(p,q), trend='c')\n    results = model.fit(maxiter=100, disp=False)\n    results.summary()\n    df_forecast = results.forecast(nobs)\n    \n    for i in range(len(n5)):\n        j='1d'\n        df_forecast[n5[i]+j] = (datewise[n5[i]].iloc[-nobs-1]-datewise[n5[i]].iloc[-nobs-2]) + df_forecast[n5[i]].cumsum()\n        df_forecast[n5[i]+'forecasteed'] = datewise[n5[i]].iloc[-nobs-1] + df_forecast[n5[i]].cumsum()\n    list89=df_forecast.columns\n    list98=[]\n    for i in range(len(list89)):\n        if list89[i][-11:]=='forecasteed':\n            list98.append(list89[i])\n    d_new=pd.concat([datewise.iloc[-12:],df_forecast[list98]],axis=1)\n    for i in range(len(n5)):\n        RMSE = rmse(datewise[n5[i]][-nobs:], df_forecast[list98[i]])\n        print('Root Mean Square Error for ' + n5[i] +':' , RMSE)\n    model = VARMAX(df_transformed, order=(p,q), trend='c')\n    results = model.fit(maxiter=100, disp=False)\n    results.summary()\n    t=int(input('Enter number of days to forecast ? :'))\n    df_forecast = results.forecast(t)\n    for i in range(len(n5)):\n        j='2d'\n        df_forecast[n5[i]+j] = (datewise[n5[i]].iloc[-t-1]-datewise[n5[i]].iloc[-t-2]) + df_forecast[n5[i]].cumsum()\n        df_forecast[n5[i]+'forecasteed1'] = datewise[n5[i]].iloc[-t-1] + df_forecast[n5[i]].cumsum()\n    list89=df_forecast.columns\n    list98=[]\n    for i in range(len(list89)):\n        if list89[i][-12:]=='forecasteed1':\n            list98.append(list89[i])\n    forecast_data1=df_forecast[list98]\n    print(forecast_data1)\n    df_forecast.reset_index(inplace=True)\n    df_forecast.rename(columns={'index':s1},inplace=True)\n    df_forecast.set_index(s1,inplace=True)\n    fig,b=plt.subplots(len(n5),2,figsize=(15,5))\n    for i in range(len(n5)):\n        datewise[n5[i]].plot(kind='line',ax=b[i][0],title=n5[i])\n        df_forecast[list98[i]].plot(kind='line',ax=b[i][1],title='Forecasted data of '+n5[i],COLOR='orange')\n        fig.tight_layout(pad=2.0)\n    plt.show()","7e24a830":"### Time-series forecasting is one of the most common and important tasks in business analytics. The goal of time series modeling is to predict future performance from past behavior \u2013 such as sales, stock market, energy demand, weather & many more.","311b38b8":"# To get flask deployed code and HTML templates please go through the below github repository.\nhttps:\/\/github.com\/SivaKrishna-1996\/Time-Series-Algorithms\/tree\/master\/Automated%20Time%20Series%20Predictions","cadcaa33":"# **** Automated Time series forecasting code ****","9ec14caf":"# Time Series Automation (Univariate Forecasting)\n\n### Time Series Automation integrates best practices in time series modeling as it automatically detects nonstationarity data, non-seasonality data and transforms to seasonal and stationary data. Besides methods like ARIMA and Facebook Prophet, this time series automation also includes advanced time series models (LSTM) that help to achieve forecasting data with the least RMSE score.\n\n# Time Series Automation (Multivariate Forecasting)\n\n### Time series Automation is also capable of handling multivariate forecasting through the VARMAX model. If the variables in the time series influence each other, this Automated Time series model is able to predict the series with past values of itself along with other series in the system. It is pretty much mandatory to observe that all the variables (time series) in the data are interchangeably causing each other (Following Granger\u2019s Causality Test) before using VARMAX. If not, the VARMAX Automated model may forecast with higher RMSE scores which lead to bad forecasting results.","7886fbc0":"# Please go through the below blog and you will understand how to use this AUTO ML product. You can upload your own time series data set and check the forecasted results.\n# Link to upload data set is given at the end of the blog & you can see the forecasted results.\n# https:\/\/beingdatum.com\/profilegrid_blogs\/automated-time-series-forecasting\/","57cd2dd2":"   ![ats-modeling-1024x292.png](attachment:ats-modeling-1024x292.png)","7e0c4cfe":"![8dfe2275-a3bf-411b-ad37-9a011c7ca538.jpg](attachment:8dfe2275-a3bf-411b-ad37-9a011c7ca538.jpg)","c7ba80d6":"# Automated Time Series Forecasting Working Flow:\n![Picture1.png](attachment:Picture1.png)","e05519ca":"### Manually doing time series modeling can be a complex and laborious process because many historical events can impact the current predictions, and finding the most influential signals is difficult. So, automating all these things will reduce human effort, time, and also able to get quick predictions."}}