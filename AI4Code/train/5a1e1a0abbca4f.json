{"cell_type":{"c945da20":"code","993392a2":"code","8e856eea":"code","81978a10":"code","052a172d":"code","2d1c32b1":"code","7a148d8e":"code","681be701":"code","60866fab":"code","acafbd7f":"code","a2040cdf":"code","368fbb6f":"code","8bd2e679":"code","20fade04":"code","de9cb747":"code","43dbe9b9":"code","b4675681":"code","bc531e68":"code","5fc622ca":"code","76463eca":"code","18594e67":"code","aa281bf8":"markdown","e80c5c36":"markdown","e531b76f":"markdown","d71f6911":"markdown","f866242b":"markdown","d20efa16":"markdown","7ce5fbed":"markdown","e542ad22":"markdown","b4207a60":"markdown","2a25873a":"markdown"},"source":{"c945da20":"import pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport plotly.io as pio\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nimport calendar\nimport plotly.figure_factory as ff\n\npio.templates.default = 'simple_white'","993392a2":"dir_in = '..\/datos\/datos_originales\/'\nfile1_in = 'olist_orders_dataset.csv'\nfile2_in = 'olist_customers_dataset.csv'\nfile3_in = 'olist_geolocation_dataset.csv'\nfile4_in = 'olist_order_reviews_dataset.csv'","8e856eea":"df_orders = pd.read_csv(os.path.join(dir_in, file1_in), sep = ',')\ndf_customers = pd.read_csv(os.path.join(dir_in, file2_in), sep = ',')\ndf_geoloc = pd.read_csv(os.path.join(dir_in, file3_in), sep = ',')\ndf_reviews = pd.read_csv(os.path.join(dir_in, file4_in), sep = ',')\n\nfechas = ['order_estimated_delivery_date', 'order_delivered_customer_date', 'order_delivered_carrier_date', 'order_approved_at',\n          'order_purchase_timestamp']\ndf_orders[fechas] = df_orders[fechas].apply(pd.to_datetime)\nfechas_review = ['review_creation_date', 'review_answer_timestamp']\ndf_reviews[fechas_review] = df_reviews[fechas_review].apply(pd.to_datetime)\n\ndf_orders.loc[df_orders.order_delivered_customer_date.isnull(), 'order_delivered_customer_date'] = \\\ndf_orders.loc[df_orders.order_delivered_customer_date.isnull(), 'order_estimated_delivery_date']\n\ndf_customers.customer_zip_code_prefix = df_customers.customer_zip_code_prefix.astype(str)\ndf_geoloc.geolocation_zip_code_prefix = df_geoloc.geolocation_zip_code_prefix.astype(str)","81978a10":"from datetime import date, datetime\n\nY = 2000 \nseasons = [('winter', (date(Y,  1,  1),  date(Y,  3, 20))),\n           ('spring', (date(Y,  3, 21),  date(Y,  6, 20))),\n           ('summer', (date(Y,  6, 21),  date(Y,  9, 22))),\n           ('autumn', (date(Y,  9, 23),  date(Y, 12, 20))),\n           ('winter', (date(Y, 12, 21),  date(Y, 12, 31)))]\n\ndef get_season(now):\n    if isinstance(now, datetime):\n        now = now.date()\n    now = now.replace(year=Y)\n    return next(season for season, (start, end) in seasons\n                if start <= now <= end)","052a172d":"df_graph1 = df_orders[['order_purchase_timestamp']]\n\ndf_graph1_final = df_graph1.pivot_table(index = df_graph1.order_purchase_timestamp.dt.month, \n                      columns = df_graph1.order_purchase_timestamp.dt.year, aggfunc = 'count')","2d1c32b1":"df_graph1_final.columns = df_graph1_final.columns.get_level_values(0)\ndf_graph1_final.columns = ['2016', '2017', '2018']\ndf_graph1_final.index = df_graph1_final.index.rename('month')\ndf_intermedio = df_graph1_final.reset_index()\ndf_intermedio.month = df_intermedio.month.apply(lambda x: calendar.month_abbr[x])\ndf_final = df_intermedio.set_index('month').drop('2016', axis = 1)\ndf_final = df_final.T\ndf_final.head()","7a148d8e":"def df_to_plotly(df):\n    return {'z': df.values.tolist(),\n            'x': df.columns.tolist(),\n            'y': df.index.tolist()}\n\ndf_plotly = df_to_plotly(df_final)","681be701":"fig = go.Figure(data=go.Heatmap(\n                   z=df_plotly['z'],\n                   x=df_plotly['x'],\n                   y=df_plotly['y'], \n                   colorscale = 'blues',\n                   hoverongaps = False))\n\nfig.update_layout(\n    title_text = 'Orders per year and month',\n    title_x = 0.5,\n    xaxis_title = 'Year',\n    yaxis_title = 'Month'\n)\n\nfig.add_annotation(\n    x = 10.5,\n    y = 1,\n    showarrow = False,\n    text = 'Missing data',\n    font = dict(\n        family = 'Courier New, monospace',\n        size = 14,\n        color = 'black'\n    ),\n    bordercolor = \"#c7c7c7\",\n    borderwidth = 2,\n    borderpad = 4,\n    bgcolor = \"#ff7f0e\",\n    opacity = 0.8\n)\n\nfig.add_annotation(\n        x='Oct',\n        y=1,\n        xref=\"x\",\n        yref=\"y\",\n        text=\"Data insertion error\",\n        showarrow=True,\n        font=dict(\n            family=\"Courier New, monospace\",\n            size=10,\n            color=\"black\"\n            ),\n        align=\"right\",\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=2,\n        arrowcolor=\"#636363\",\n        ax=20,\n        ay=-100,\n        bordercolor=\"#c7c7c7\",\n        borderwidth=2,\n        borderpad=4,\n        bgcolor=\"#ff7f0e\",\n        opacity=0.8\n        )\n\nfig.show()","60866fab":"df_graph2 = df_orders[['order_delivered_customer_date', 'order_estimated_delivery_date']]\ndf_graph2['season'] = df_graph2.order_estimated_delivery_date.apply(get_season)\ndf_graph2['time_difference'] = df_graph2.order_delivered_customer_date - df_graph2.order_estimated_delivery_date\ndf_graph2['time_difference_float'] = df_graph2.time_difference.dt.days + df_graph2.time_difference.dt.seconds \/ 86400\ndf_graph2.head()","acafbd7f":"fig2 = px.histogram(\n    df_graph2,\n    x = 'time_difference_float',\n    nbins = 100,\n    facet_col = 'season',\n    facet_col_wrap = 2,\n    labels = dict(time_difference_float =  'Time difference (days)')\n)\n\nfig2.update_layout(\n    title_text = 'Time difference between estimated and actual delivery date',\n    title_x = 0.5\n)\n\nfig2.update_xaxes(\n    ticks = 'outside',\n    tickwidth = 2,\n    tickcolor = '#52d6d3',\n    tickangle = 45,\n    nticks = 20,\n    tickfont = dict(\n        family = 'Courier new, monospace',\n        size = 13\n    )\n)\n\n\nfor annotation in fig2.layout.annotations:\n    annotation.text = annotation.text.split(\"=\")[1]\nfig2.add_annotation(\n    x = 0.01,\n    y = 0.95,\n    xref = 'paper',\n    yref = 'paper',\n    showarrow = False,\n    text = 'Fast deliveries',\n    font = dict(\n        family = 'Courier New, monospace',\n        size = 13,\n        color = 'black'\n    ),\n    bordercolor = \"#c7c7c7\",\n    borderwidth = 2,\n    borderpad = 4,\n    bgcolor = \"#00a260\",\n    opacity = 0.8\n)\n\nfig2.add_annotation(\n    x = 0.99,\n    y = 0.95,\n    xref = 'paper',\n    yref = 'paper',\n    showarrow = False,\n    text = 'Slow deliveries',\n    font = dict(\n        family = 'Courier New, monospace',\n        size = 13,\n        color = 'black'\n    ),\n    bordercolor = \"#c7c7c7\",\n    borderwidth = 2,\n    borderpad = 4,\n    bgcolor = \"#00a260\",\n    opacity = 0.8\n)\n\nfig2.add_vline(x=0, line_width=1, line_dash=\"dash\", line_color=\"black\")\n\n","a2040cdf":"df_graph3 = df_orders[['order_purchase_timestamp', 'order_approved_at']]\ndf_graph3.head()\ndf_graph3['season'] = df_graph3.order_purchase_timestamp.apply(get_season)\ndf_graph3['time_difference'] = df_graph3.order_approved_at - df_graph3.order_purchase_timestamp\ndf_graph3['time_difference_float'] = df_graph3.time_difference.dt.days + df_graph3.time_difference.dt.seconds \/ 86400\ndf_graph3 = df_graph3[df_graph3.time_difference_float < 180]\ndf_graph3.head()","368fbb6f":"fig3 = px.histogram(\n    df_graph3,\n    x = 'time_difference_float',\n    nbins = 100,\n    facet_col = 'season',\n    facet_col_wrap = 2,\n    labels = dict(time_difference_float =  'Time difference (days)')\n)\n\nfig3.update_layout(\n    title_text = 'Order validation time',\n    title_x = 0.5\n)\n\nfig3.update_xaxes(\n    ticks = 'outside',\n    tickwidth = 2,\n    tickcolor = '#52d6d3',\n    tickangle = 45,\n    nticks = 20,\n    tickfont = dict(\n        family = 'Courier new, monospace',\n        size = 13\n    )\n)\n\n\nfor annotation in fig3.layout.annotations:\n    annotation.text = annotation.text.split(\"=\")[1]\n    \nfig3.add_annotation(\n        x=10,\n        y=5e3,\n        xref=\"x\",\n        yref=\"y\",\n        text=\"Recommended filter\",\n        showarrow=True,\n        font=dict(\n            family=\"Courier New, monospace\",\n            size=10,\n            color=\"#ffffff\"\n            ),\n        align=\"right\",\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=2,\n        arrowcolor=\"#636363\",\n        ax=70,\n        ay=-30,\n        bordercolor=\"#c7c7c7\",\n        borderwidth=2,\n        borderpad=4,\n        bgcolor=\"#ff7f0e\",\n        opacity=0.8\n        )\nfig3.add_vline(x=10, line_width=1, line_dash=\"dash\", line_color=\"black\")","8bd2e679":"df_graph4 = df_orders.merge(df_customers, on = 'customer_id', how = 'inner')\ndf_graph4.drop('customer_id', axis = 1, inplace = True)\n\ncust_clas = df_graph4.groupby('customer_unique_id').size().value_counts().reset_index()\\\n.rename(columns = {'index': 'n_compras', 0: 'frecuencia'})\n\nconditions = [\n    cust_clas.n_compras == 1,\n    cust_clas.n_compras == 2\n]\ncategory = ['1 compra', '2 compras']\ncust_clas['category'] = np.select(conditions, category, default = '3 o m\u00e1s compras')\n\ndf_graph4_prefinal = df_graph4.groupby('customer_unique_id').size().reset_index()\\\n.rename(columns = {0: 'n_compras'}).merge(cust_clas, on = 'n_compras').drop('frecuencia', axis = 1)\\\n.merge(df_graph4, on = 'customer_unique_id', how = 'inner')\n\ndf_graph4_final = df_graph4_prefinal.groupby([df_graph4_prefinal.order_purchase_timestamp.dt.month,\n                                            df_graph4_prefinal.category])\\\n.agg({'n_compras': 'sum'})","20fade04":"df_graph4_final = df_graph4_final.reset_index().rename(columns = {'order_purchase_timestamp': 'month'})\ndf_graph4_final.month = df_graph4_final.month.map({1: 'Enero', 2: 'Febrero', 3: 'Marzo', 4: 'Abril',\n                                                  5: 'Mayo', 6: 'Junio', 7: 'Julio', 8: 'Agosto',\n                                                  9: 'Septiembre', 10: 'Octubre', 11: 'Noviembre',\n                                                  12: 'Diciembre'})","de9cb747":"fig4 = px.line(df_graph4_final, x = 'month', y = 'n_compras', color = 'category',\n             labels = dict(n_compras = 'Frecuencia', month = 'Mes',\n                          category = 'Compras de los clientes'))\n\nfig4.update_layout(\n    title_text = 'Evoluci\u00f3n de compras por tipo de comprador',\n    title_x = 0.5\n)\n\nfig4.add_annotation(\n    x = 1.28,\n    y = 0.7,\n    xref = 'paper',\n    yref = 'paper',\n    showarrow = False,\n    text = 'Si desea eliminar<br>alguna l\u00ednea del<br>gr\u00e1fico simplemente<br>seleccione la<br>l\u00ednea a eliminar<br>en la leyenda.',\n    font = dict(\n        family = 'Courier New, monospace',\n        size = 13,\n        color = 'black'\n    ),\n    bordercolor = \"#c7c7c7\",\n    borderwidth = 2,\n    borderpad = 4,\n    opacity = 0.8\n)\nfig4.show()","43dbe9b9":"df_graph5 = df_reviews.drop(['review_comment_title', 'review_comment_message'], axis = 1)\nconditions = [\n    (df_graph5.review_score == 1) | (df_graph5.review_score == 2),\n    (df_graph5.review_score == 3) | (df_graph5.review_score == 4),\n]\ncategory = ['1-2', '3-4']\ndf_graph5['discrete_review'] = np.select(conditions, category, default = '5')\n\ndf_graph5_final = df_graph5.groupby([df_graph5.review_answer_timestamp.dt.month, \n                                     'discrete_review']).size().reset_index()\n\ndf_graph5_final.rename(columns = {0: 'n_reviews'}, inplace = True)\ndf_graph5_final = df_graph5_final.rename(columns = {'review_answer_timestamp': 'month'})\ndf_graph5_final.month = df_graph5_final.month.map({1: 'Enero', 2: 'Febrero', 3: 'Marzo', 4: 'Abril',\n                                                  5: 'Mayo', 6: 'Junio', 7: 'Julio', 8: 'Agosto',\n                                                  9: 'Septiembre', 10: 'Octubre', 11: 'Noviembre',\n                                                  12: 'Diciembre'})\ndf_graph5_final.head()","b4675681":"fig5 = px.line(df_graph5_final, x = 'month', y = 'n_reviews', color = 'discrete_review',\n             labels = dict(n_reviews = 'Frecuencia', month = 'Mes',\n                          discrete_review = 'Puntuaci\u00f3n de la review'))\nfig5.add_annotation(\n    x = 1.28,\n    y = 0.7,\n    xref = 'paper',\n    yref = 'paper',\n    showarrow = False,\n    text = 'Si desea eliminar<br>alguna l\u00ednea del<br>gr\u00e1fico simplemente<br>seleccione la<br>l\u00ednea a eliminar<br>en la leyenda.',\n    font = dict(\n        family = 'Courier New, monospace',\n        size = 13,\n        color = 'black'\n    ),\n    bordercolor = \"#c7c7c7\",\n    borderwidth = 2,\n    borderpad = 4,\n    opacity = 0.8\n)\nfig5.show()","bc531e68":"df_geoloc.drop_duplicates(subset = ['geolocation_zip_code_prefix', 'geolocation_city', \n                                    'geolocation_state'], inplace = True)\ndf_geoloc = df_geoloc[~df_geoloc['geolocation_city'].str.contains(r'[^\\x00-\\x7F]+')]\n\ndf_graph6 = df_orders.merge(df_customers, on = 'customer_id', how = 'inner')\\\n.merge(df_geoloc, left_on = 'customer_zip_code_prefix', right_on = 'geolocation_zip_code_prefix',\n      how = 'inner')","5fc622ca":"df_graph6_map = df_graph6.groupby('customer_state').size().reset_index()\ndf_graph6_map.rename(columns = {0: 'n_compras'}, inplace = True)\n\npruebita = df_graph6_map[df_graph6_map.n_compras <= 3211]","76463eca":"import geojson\nimport pandas as pd\nimport plotly.graph_objects as go\n\nwith open(\"brazil_geo.json\", \"r\", encoding=\"utf-8\") as f:\n    geometry = geojson.load(f)\n\nfig6 = go.Figure([\n    go.Choropleth(\n        geojson = geometry,\n        locations = pruebita[\"customer_state\"],\n        z = pruebita[\"n_compras\"]\n)])\n\nfig6.update_geos(\n    fitbounds=\"locations\",\n    resolution=50,\n    visible=False,\n    showframe=False,\n    projection={\"type\": \"mercator\"},\n)\n\nfig6.update_layout(\n    title_text = 'Mapa de calor por estados de los pedidos em Brasil',\n    title_x = 0.5\n)\n\nfig6.add_annotation(\n    x = 0.1,\n    y = 1.1,\n    xref = 'paper',\n    yref = 'paper',\n    showarrow = False,\n    text = 'Los estados de Brasil faltantes de este gr\u00e1fico han sido<br>deliberadamente eliminados por tratarse de outliers,<br>en caso de querer ver el mapa al completo fijarse en el siguiente gr\u00e1fico.',\n    font = dict(\n        family = 'Courier New, monospace',\n        size = 13,\n        color = 'black'\n    ),\n    bordercolor = \"#c7c7c7\",\n    borderwidth = 2,\n    borderpad = 4,\n    opacity = 0.8\n)","18594e67":"fig7 = go.Figure([\n    go.Choropleth(\n        geojson = geometry,\n        locations = df_graph6_map[\"customer_state\"],\n        z = df_graph6_map[\"n_compras\"]\n)])\n\nfig7.update_layout(\n    title_text = 'Mapa de calor por estados de los pedidos en Brasil',\n    title_x = 0.5\n)\n\nfig7.update_geos(\n    fitbounds=\"locations\",\n    resolution=50,\n    visible=False,\n    showframe=False,\n    projection={\"type\": \"mercator\"},\n)","aa281bf8":"### Histogramas ","e80c5c36":"## Carga de datos ","e531b76f":"### Mapa de calor ","d71f6911":"## Mapas ","f866242b":"## Graficos ","d20efa16":"# Metadatos \n\n#### Orders\nEste es el dataset central en el que se recoge la informaci\u00f3n sobre los pedidos.\n- Order_id: identificador \u00fanico del pedido.\n- Customer_id: esta es la llave que coincide con el dataset de clientes. Cada pedido tiene asignado un \u00fanico customer_id (entiendo que es el que paga).\n- Order_status: referencia al estado del pedido, si se ha entregado, si est\u00e1 en ello...\n- Order_purchase_timestamp: indica la fecha en la que se ha realizado la compra.\n- Order_approved_at: indica la fecha  en la que el pago fue aprovado por la tienda.\n- Order_delivered_carrier_date: indica la fecha en la que el producto fue entregado a la empresa log\u00edstica encargada de llev\u00e1rselo al cliente final.\n- Order_delivered_customer_date: indica la fecha en la que el producto fue entregado al cliente.\n- Order_estimated_delivery_date: indica la fecha de entrega aproximada que fue comunicada al cliente a la hora de realizar la compra.  \n#### Order reviews\nEste dataset contiene informaci\u00f3n sobre las reviews que los clientes dan sobre el producto\/servicio. En el momento en el que un cliente realiza un pedido en Olist, esto es comunicado a un vendedor para que pueda satisfacer esa orden. En el momento en el que el cliente recibe el producto o en el momento en el que la fecha estimada de env\u00edo caduca, el cliente recibe por email una encuesta de satisfacci\u00f3n en la que puede puntuar la experiencia de compra y adem\u00e1s dejar comentarios adicionales.\n\n- Review_id: identificador \u00fanico de la review.\n- Order_id: identificador \u00fanico del pedido.\n- Review_score: nota que el cliente da del proceso de compra. El rango es 1-5 siendo 5 lo mejor.\n- Review_comment_title: t\u00edtulo del comentario (algo as\u00ed como el asunto entiendo) que el cliente ha dejado. Est\u00e1 en portugu\u00e9s.\n- Review_comment_message: contenido del comentario dejado por el cliente. Est\u00e1 en portugu\u00e9s.\n- Review_creation_date: fecha en la que se le entrega al cliente la encuesta de satisfacci\u00f3n.\n- Review_answer_timestamp: fecha en la que el cliente responde a la encuesta\n#### Geolocalitation\nEste dataset contiene informaci\u00f3n sobre el c\u00f3digo ZIP de los vendedores y la latitud y longitud exacta de estos.\n- Geolocalitation_zip_code_preffix: 5 primeros d\u00edgitos del c\u00f3digo ZIP.\n- Geolocalitation_lat: latitud.\n- Geolocalitation_lng: longitud. \n- Geolocalitation_city: nombre de la ciudad.\n- Geolocalitation_state: estado.\n#### Customers\nEste dataset contiene informaci\u00f3n sobre los clientes y su localizaci\u00f3n. En el sistema utilizado para la creaci\u00f3n de estos datos, cada pedido tiene asignado un \u00fanico id de cliente, lo que implica que si un cliente realiza varios pedidos este tendr\u00e1 diferentes identificadores en cada uno de ellos. La variable 'customer_unique_id' de esta tabla es la que contiene el verdadero identificador \u00fanico de cada cliente.\n- Customer_id: identificador de cliente que coincide con el dataset de los pedidos (el 6).\n- Customer_unique_id: identificador \u00fanico del cliente.\n- Customer_zip_code_preffix: primeros 5 d\u00edgitos del c\u00f3digo ZIP del cliente.\n- Customer_city: nombre de la ciudad del cliente.\n- Customer_state: estado del cliente.\n\nTodas las fechas tienen el mismo formato y es %Y-%m-%d %H:%M:%S","7ce5fbed":"## Funci\u00f3n para obtener la estaci\u00f3n","e542ad22":"## Ficheros y rutas de entrada\/salida ","b4207a60":"## Gr\u00e1ficos de l\u00edneas ","2a25873a":"## Librer\u00edas "}}