{"cell_type":{"6550e182":"code","5840471c":"code","09b1db50":"code","fb98afc0":"code","50a526a8":"code","ed0fde1c":"code","94448930":"code","dac98f9e":"code","84f4825e":"code","74df3c87":"code","4e0daa5b":"code","09a048fc":"code","b47af3ef":"code","601997f2":"code","293a0cfc":"code","83902a20":"code","2a34cd9c":"code","7c9c4cfc":"code","95bd5c9c":"code","ec910e7e":"code","807fbf9e":"code","fe1e762d":"code","0dffeafa":"code","c4d085fc":"code","2ccc822d":"code","2fa98116":"code","9cb2c170":"code","91ed220a":"code","d7491ad9":"code","ed11a1d7":"code","b0a460d7":"code","2260bdb3":"code","d8a92046":"code","7277ff8b":"code","70669e0e":"code","20ff7e04":"code","2cad2c14":"code","dd91761f":"code","306e6879":"code","7da9661a":"code","a0934451":"code","c81f8a9e":"code","0d05f26a":"code","3bd2ef9c":"code","5db5b936":"code","97783928":"code","282fbfe1":"code","be8fc799":"code","74a4bc75":"code","3faa7942":"code","7ed96aa2":"code","3ee1afd1":"code","f8132686":"code","32264f91":"code","691cf166":"code","54788662":"code","e1199fba":"code","b170ef87":"code","b1e84975":"code","abc9b82c":"code","13f39285":"code","d2c0f0a6":"code","4780e233":"code","292d985f":"code","8b2eb31b":"code","76595237":"code","872d1584":"code","dc57e8bd":"code","d531bf82":"code","f13bc654":"code","c94cc227":"code","3bc6bc73":"code","5b010be3":"code","204fd77f":"code","303fa4ec":"code","97af0e03":"code","582df33b":"code","78915f50":"code","d39ca716":"markdown","bd366f21":"markdown","4ca8fa23":"markdown","59bc4a79":"markdown","cf8b1227":"markdown","4b842963":"markdown","7ec9b935":"markdown","d3603bcf":"markdown","bc8f1739":"markdown","8d34eb29":"markdown","9f756489":"markdown","f3a107a3":"markdown","2e48afb3":"markdown","1fb6a499":"markdown","a7341e5d":"markdown","4fdccb70":"markdown","e48657da":"markdown","38caefe0":"markdown","702913df":"markdown","1918d483":"markdown","a5cdac24":"markdown","f064fc79":"markdown","55dfb17b":"markdown","8a4b8999":"markdown","e56650fb":"markdown","bdcf25a4":"markdown","f2b94f98":"markdown","00188a1b":"markdown","41d632bc":"markdown","a8749789":"markdown","f04163a5":"markdown","a35b2389":"markdown","d91e8417":"markdown","6d410e15":"markdown","a855b014":"markdown","d33f153a":"markdown","8e43fc1d":"markdown","ce67453b":"markdown","fa8a4bb9":"markdown","930932e8":"markdown","4ec44d9d":"markdown","df18e1f3":"markdown","be77dd19":"markdown","97cb60e6":"markdown","c17de313":"markdown","511e2148":"markdown","e416da85":"markdown","21d36840":"markdown","309a23ae":"markdown","fd6c6685":"markdown","628ddb57":"markdown","e367a03b":"markdown","4b41c221":"markdown","43e53701":"markdown","b46fa650":"markdown","25148544":"markdown","90f87e21":"markdown","99d16f3b":"markdown","9229a033":"markdown","33a1bb0a":"markdown","d95d41ea":"markdown","12f17c23":"markdown","05ccd3f2":"markdown","2732ff17":"markdown","558c3384":"markdown","1bbe5984":"markdown","ae91e0c2":"markdown","1a941102":"markdown","cb28b066":"markdown","91cb2be1":"markdown","f6162fac":"markdown","61465869":"markdown","b275f1e8":"markdown","77993632":"markdown","6031f0c0":"markdown","67fb4ca1":"markdown"},"source":{"6550e182":"!conda install -c conda-forge gdcm -y","5840471c":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport pydicom\nimport scipy.ndimage\nimport gdcm\n\nimport glob\n\nfrom skimage import measure \nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\nfrom skimage.morphology import disk, opening, closing\nfrom tqdm import tqdm\n\nfrom IPython.display import HTML\nfrom PIL import Image\n\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\n\nfrom os import listdir, mkdir","09b1db50":"listdir(\"..\/input\/\")","fb98afc0":"#basepath = \"..\/input\/osic-pulmonary-fibrosis-progression\/\"\n\n# or if you were taking part in RSNA pulmonary embolism detection:\nbasepath = \"..\/input\/rsna-str-pulmonary-embolism-detection\/\"","50a526a8":"train = pd.read_csv(basepath + \"train.csv\")\ntest = pd.read_csv(basepath + \"test.csv\")","ed0fde1c":"train.shape","94448930":"train.head()","dac98f9e":"if basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":\n    train[\"dcm_path\"] = basepath + \"train\/\" + train.Patient + \"\/\"\nelif basepath == \"..\/input\/rsna-str-pulmonary-embolism-detection\/\":\n    train[\"dcm_path\"] = basepath + \"train\/\" + train.StudyInstanceUID + \"\/\" + train.SeriesInstanceUID \nelse:\n    train[\"dcm_path\"] = basepath + \"train\/\" + train.StudyInstanceUID + \"\/\" ","84f4825e":"def load_scans(dcm_path):\n    if basepath == \"..\/input\/rsna-str-pulmonary-embolism-detection\/\":\n        # We sort by ImagePositionPatient (z-coordinate) or by SliceLocation\n        slices = [pydicom.dcmread(dcm_path + \"\/\" + file) for file in listdir(dcm_path)]\n        slices.sort(key = lambda x: float(x.ImagePositionPatient[2]))\n    else: #basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":    \n        # This competition shows missing values in ImagePosition,\n        # this is why we are sorting by filename number\n        files = listdir(dcm_path)\n        file_nums = [np.int(file.split(\".\")[0]) for file in files]\n        sorted_file_nums = np.sort(file_nums)[::-1]\n        slices = [pydicom.dcmread(dcm_path + \"\/\" + str(file_num) + \".dcm\" ) for file_num in sorted_file_nums]\n    return slices","74df3c87":"example = train.dcm_path.values[0]\nscans = load_scans(example)","4e0daa5b":"example","09a048fc":"scans[0]","b47af3ef":"HTML('<iframe width=\"600\" height=\"400\" src=\"https:\/\/www.youtube.com\/embed\/KZld-5W99cI\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>')","601997f2":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nfor n in range(10):\n    image = scans[n].pixel_array.flatten()\n    rescaled_image = image * scans[n].RescaleSlope + scans[n].RescaleIntercept\n    sns.distplot(image.flatten(), ax=ax[0]);\n    sns.distplot(rescaled_image.flatten(), ax=ax[1])\nax[0].set_title(\"Raw pixel array distributions for 10 examples\")\nax[1].set_title(\"HU unit distributions for 10 examples\");","293a0cfc":"def set_outside_scanner_to_air(raw_pixelarrays):\n    # in OSIC we find outside-scanner-regions with raw-values of -2000. \n    # Let's threshold between air (0) and this default (-2000) using -1000\n    raw_pixelarrays[raw_pixelarrays <= -1000] = 0\n    return raw_pixelarrays","83902a20":"def transform_to_hu(slices):\n    images = np.stack([file.pixel_array for file in slices])\n    images = images.astype(np.int16)\n\n    images = set_outside_scanner_to_air(images)\n    \n    # convert to HU\n    for n in range(len(slices)):\n        \n        intercept = slices[n].RescaleIntercept\n        slope = slices[n].RescaleSlope\n        \n        if slope != 1:\n            images[n] = slope * images[n].astype(np.float64)\n            images[n] = images[n].astype(np.int16)\n            \n        images[n] += np.int16(intercept)\n    \n    return np.array(images, dtype=np.int16)","2a34cd9c":"hu_scans = transform_to_hu(scans)","7c9c4cfc":"fig, ax = plt.subplots(1,4,figsize=(20,3))\nax[0].set_title(\"Original CT-scan\")\nax[0].imshow(scans[0].pixel_array, cmap=\"bone\")\nax[1].set_title(\"Pixelarray distribution\");\nsns.distplot(scans[0].pixel_array.flatten(), ax=ax[1]);\n\nax[2].set_title(\"CT-scan in HU\")\nax[2].imshow(hu_scans[0], cmap=\"bone\")\nax[3].set_title(\"HU values distribution\");\nsns.distplot(hu_scans[0].flatten(), ax=ax[3]);\n\nfor m in [0,2]:\n    ax[m].grid(False)","95bd5c9c":"N = 1000","ec910e7e":"def get_window_value(feature):\n    if type(feature) == pydicom.multival.MultiValue:\n        return np.int(feature[0])\n    else:\n        return np.int(feature)\n\npixelspacing_r = []\npixelspacing_c = []\nslice_thicknesses = []\npatient_id = []\npatient_pth = []\nrow_values = []\ncolumn_values = []\nwindow_widths = []\nwindow_levels = []\n\nif basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":\n    patients = train.Patient.unique()[0:N]\nelse:\n    patients = train.SeriesInstanceUID.unique()[0:N]\n\nfor patient in patients:\n    patient_id.append(patient)\n    if basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":\n        path = train[train.Patient == patient].dcm_path.values[0]\n    else:\n        path = train[train.SeriesInstanceUID == patient].dcm_path.values[0]\n    example_dcm = listdir(path)[0]\n    patient_pth.append(path)\n    dataset = pydicom.dcmread(path + \"\/\" + example_dcm)\n    \n    window_widths.append(get_window_value(dataset.WindowWidth))\n    window_levels.append(get_window_value(dataset.WindowCenter))\n    \n    spacing = dataset.PixelSpacing\n    slice_thicknesses.append(dataset.SliceThickness)\n    \n    row_values.append(dataset.Rows)\n    column_values.append(dataset.Columns)\n    pixelspacing_r.append(spacing[0])\n    pixelspacing_c.append(spacing[1])\n    \nscan_properties = pd.DataFrame(data=patient_id, columns=[\"patient\"])\nscan_properties.loc[:, \"rows\"] = row_values\nscan_properties.loc[:, \"columns\"] = column_values\nscan_properties.loc[:, \"area\"] = scan_properties[\"rows\"] * scan_properties[\"columns\"]\nscan_properties.loc[:, \"pixelspacing_r\"] = pixelspacing_r\nscan_properties.loc[:, \"pixelspacing_c\"] = pixelspacing_c\nscan_properties.loc[:, \"pixelspacing_area\"] = scan_properties.pixelspacing_r * scan_properties.pixelspacing_c\nscan_properties.loc[:, \"slice_thickness\"] = slice_thicknesses\nscan_properties.loc[:, \"patient_pth\"] = patient_pth\nscan_properties.loc[:, \"window_width\"] = window_widths\nscan_properties.loc[:, \"window_level\"] = window_levels\nscan_properties.head()","807fbf9e":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(pixelspacing_r, ax=ax[0], color=\"Limegreen\", kde=False)\nax[0].set_title(\"Pixel spacing distribution \\n in row direction \")\nax[0].set_ylabel(\"Counts in train\")\nax[0].set_xlabel(\"mm\")\nsns.distplot(pixelspacing_c, ax=ax[1], color=\"Mediumseagreen\", kde=False)\nax[1].set_title(\"Pixel spacing distribution \\n in column direction\");\nax[1].set_ylabel(\"Counts in train\");\nax[1].set_xlabel(\"mm\");","fe1e762d":"counts = scan_properties.groupby([\"rows\", \"columns\"]).size()\ncounts = counts.unstack()\ncounts.fillna(0, inplace=True)\n\n\nfig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(slice_thicknesses, color=\"orangered\", kde=False, ax=ax[0])\nax[0].set_title(\"Slice thicknesses of all patients\");\nax[0].set_xlabel(\"Slice thickness in mm\")\nax[0].set_ylabel(\"Counts in train\");\n\nfor n in counts.index.values:\n    for m in counts.columns.values:\n        ax[1].scatter(n, m, s=counts.loc[n,m], c=\"midnightblue\")\nax[1].set_xlabel(\"rows\")\nax[1].set_ylabel(\"columns\")\nax[1].set_title(\"Pixel area of ct-scan per patient\");","0dffeafa":"scan_properties[\"r_distance\"] = scan_properties.pixelspacing_r * scan_properties.rows\nscan_properties[\"c_distance\"] = scan_properties.pixelspacing_c * scan_properties[\"columns\"]\nscan_properties[\"area_cm2\"] = 0.1* scan_properties[\"r_distance\"] * 0.1*scan_properties[\"c_distance\"]\nscan_properties[\"slice_volume_cm3\"] = 0.1*scan_properties.slice_thickness * scan_properties.area_cm2","c4d085fc":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(scan_properties.area_cm2, ax=ax[0], color=\"purple\")\nsns.distplot(scan_properties.slice_volume_cm3, ax=ax[1], color=\"magenta\")\nax[0].set_title(\"CT-slice area in $cm^{2}$\")\nax[1].set_title(\"CT-slice volume in $cm^{3}$\")\nax[0].set_xlabel(\"$cm^{2}$\")\nax[1].set_xlabel(\"$cm^{3}$\");","2ccc822d":"max_path = scan_properties[\n    scan_properties.area_cm2 == scan_properties.area_cm2.max()].patient_pth.values[0]\nmin_path = scan_properties[\n    scan_properties.area_cm2 == scan_properties.area_cm2.min()].patient_pth.values[0]\n\nmin_scans = load_scans(min_path)\nmin_hu_scans = transform_to_hu(min_scans)\n\nmax_scans = load_scans(max_path)\nmax_hu_scans = transform_to_hu(max_scans)\n\nbackground_water_hu_scans = max_hu_scans.copy()","2fa98116":"def set_manual_window(hu_image, custom_center, custom_width):\n    w_image = hu_image.copy()\n    min_value = custom_center - (custom_width\/2)\n    max_value = custom_center + (custom_width\/2)\n    w_image[w_image < min_value] = min_value\n    w_image[w_image > max_value] = max_value\n    return w_image","9cb2c170":"fig, ax = plt.subplots(1,2,figsize=(20,10))\nax[0].imshow(set_manual_window(min_hu_scans[np.int(len(min_hu_scans)\/2)], -700, 255), cmap=\"YlGnBu\")\nax[1].imshow(set_manual_window(max_hu_scans[np.int(len(max_hu_scans)\/2)], -700, 255), cmap=\"YlGnBu\");\nax[0].set_title(\"CT-scan with small slice area\")\nax[1].set_title(\"CT-scan with large slice area\");\nfor n in range(2):\n    ax[n].axis(\"off\")","91ed220a":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(max_hu_scans[np.int(len(max_hu_scans)\/2)].flatten(), kde=False, ax=ax[1])\nax[1].set_title(\"Large area image\")\nsns.distplot(min_hu_scans[np.int(len(min_hu_scans)\/2)].flatten(), kde=False, ax=ax[0])\nax[0].set_title(\"Small area image\")\nax[0].set_xlabel(\"HU values\")\nax[1].set_xlabel(\"HU values\");","d7491ad9":"max_path = scan_properties[\n    scan_properties.slice_volume_cm3 == scan_properties.slice_volume_cm3.max()].patient_pth.values[0]\nmin_path = scan_properties[\n    scan_properties.slice_volume_cm3 == scan_properties.slice_volume_cm3.min()].patient_pth.values[0]\n\nmin_scans = load_scans(min_path)\nmin_hu_scans = transform_to_hu(min_scans)\n\nmax_scans = load_scans(max_path)\nmax_hu_scans = transform_to_hu(max_scans)","ed11a1d7":"fig, ax = plt.subplots(1,2,figsize=(20,10))\nax[0].imshow(set_manual_window(min_hu_scans[np.int(len(min_hu_scans)\/2)], -700, 255), cmap=\"YlGnBu\")\nax[1].imshow(set_manual_window(max_hu_scans[np.int(len(max_hu_scans)\/2)], -700, 255), cmap=\"YlGnBu\");\nax[0].set_title(\"CT-scan with small slice volume\")\nax[1].set_title(\"CT-scan with large slice volume\");\nfor n in range(2):\n    ax[n].axis(\"off\")","b0a460d7":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(max_hu_scans[np.int(len(max_hu_scans)\/2)].flatten(), kde=False, ax=ax[1])\nax[1].set_title(\"Large slice volume\")\nsns.distplot(min_hu_scans[np.int(len(min_hu_scans)\/2)].flatten(), kde=False, ax=ax[0])\nax[0].set_title(\"Small slice volume\")\nax[0].set_xlabel(\"HU values\")\nax[1].set_xlabel(\"HU values\");","2260bdb3":"def plot_3d(image, threshold=700, color=\"navy\"):\n    \n    # Position the scan upright, \n    # so the head of the patient would be at the top facing the camera\n    p = image.transpose(2,1,0)\n    \n    verts, faces,_,_ = measure.marching_cubes_lewiner(p, threshold)\n\n    fig = plt.figure(figsize=(10, 10))\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Fancy indexing: `verts[faces]` to generate a collection of triangles\n    mesh = Poly3DCollection(verts[faces], alpha=0.2)\n    mesh.set_facecolor(color)\n    ax.add_collection3d(mesh)\n\n    ax.set_xlim(0, p.shape[0])\n    ax.set_ylim(0, p.shape[1])\n    ax.set_zlim(0, p.shape[2])\n\n    plt.show()","d8a92046":"plot_3d(max_hu_scans)","7277ff8b":"old_distribution = max_hu_scans.flatten()","70669e0e":"example = train.dcm_path.values[0]\nscans = load_scans(example)\nhu_scans = transform_to_hu(scans)","20ff7e04":"plot_3d(hu_scans)","2cad2c14":"plt.figure(figsize=(20,5))\nsns.distplot(old_distribution, label=\"weak 3d plot\", kde=False)\nsns.distplot(hu_scans.flatten(), label=\"strong 3d plot\", kde=False)\nplt.title(\"HU value distribution\")\nplt.legend();","dd91761f":"print(len(max_hu_scans), len(hu_scans))","306e6879":"def resample(image, scan, new_spacing=[1,1,1]):\n    # Determine current pixel spacing\n    spacing = np.array([scan[0].SliceThickness] + list(scan[0].PixelSpacing), dtype=np.float32)\n    \n    resize_factor = spacing \/ new_spacing\n    new_shape = np.round(image.shape * resize_factor)\n    \n    # recompute the resize factor and spacing such that we match the rounded new shape above\n    rounded_resize_factor = new_shape \/ image.shape\n    rounded_new_spacing = spacing \/ rounded_resize_factor\n    \n    # zoom with resize factor\n    image = scipy.ndimage.interpolation.zoom(image, rounded_resize_factor, mode='nearest')\n    \n    return image, rounded_new_spacing","7da9661a":"img_resampled, spacing = resample(max_hu_scans, scans, [1,1,1])\nprint(\"Shape before resampling\\t\", max_hu_scans.shape)\nprint(\"Shape after resampling\\t\", img_resampled.shape)","a0934451":"plot_3d(img_resampled)","c81f8a9e":"def largest_label_volume(im, bg=-1):\n    vals, counts = np.unique(im, return_counts=True)\n\n    counts = counts[vals != bg]\n    vals = vals[vals != bg]\n\n    if len(counts) > 0:\n        return vals[np.argmax(counts)]\n    else:\n        return None\n    \ndef fill_lungs(binary_image):\n    image = binary_image.copy()\n    # For every slice we determine the largest solid structure\n    for i, axial_slice in enumerate(image):\n        axial_slice = axial_slice - 1\n        labeling = measure.label(axial_slice)\n        l_max = largest_label_volume(labeling, bg=0)\n\n        if l_max is not None: #This slice contains some lung\n            image[i][labeling != l_max] = 1\n    return image\n","0d05f26a":"def segment_lung_mask(image):\n    segmented = np.zeros(image.shape)   \n    \n    for n in range(image.shape[0]):\n        binary_image = np.array(image[n] > -320, dtype=np.int8)+1\n        labels = measure.label(binary_image)\n        \n        bad_labels = np.unique([labels[0,:], labels[-1,:], labels[:,0], labels[:,-1]])\n        for bad_label in bad_labels:\n            binary_image[labels == bad_label] = 2\n    \n        #We have a lot of remaining small signals outside of the lungs that need to be removed. \n        #In our competition closing is superior to fill_lungs \n        selem = disk(2)\n        binary_image = opening(binary_image, selem)\n    \n        binary_image -= 1 #Make the image actual binary\n        binary_image = 1-binary_image # Invert it, lungs are now 1\n        \n        segmented[n] = binary_image.copy() * image[n]\n    \n    return segmented","3bd2ef9c":"plt.figure(figsize=(20,5))\nsns.distplot(hu_scans[20], kde=False)\nplt.title(\"Example HU value distribution\");\nplt.xlabel(\"HU-value\")\nplt.ylabel(\"count\")","5db5b936":"binary_image = np.array((hu_scans[20]>-320), dtype=np.int8) + 1\nnp.unique(binary_image)","97783928":"labels = measure.label(binary_image)\n\nbad_labels = np.unique([labels[0,:], labels[-1,:], labels[:,0], labels[:,-1]])","282fbfe1":"binary_image_2 = binary_image.copy()\nfor bad_label in bad_labels:\n    binary_image_2[labels == bad_label] = 2","be8fc799":"fig, ax = plt.subplots(1,3,figsize=(20,7))\nax[0].imshow(binary_image, cmap=\"binary\", interpolation='nearest')\nax[1].imshow(labels, cmap=\"jet\", interpolation='nearest')\nax[2].imshow(binary_image_2, cmap=\"binary\", interpolation='nearest')\n\nax[0].set_title(\"Binary image\")\nax[1].set_title(\"Labelled image\");\nax[2].set_title(\"Binary image - background removed\");","74a4bc75":"selem = disk(2)\nclosed_binary_2 = closing(binary_image_2, selem)\n\nclosed_binary_2 -= 1 #Make the image actual binary\nclosed_binary_2 = 1-closed_binary_2 # Invert it, lungs are now 1","3faa7942":"filled_lungs_binary = fill_lungs(binary_image_2)","7ed96aa2":"air_pocket_binary = closed_binary_2.copy()\n# Remove other air pockets insided body\nlabels_2 = measure.label(air_pocket_binary, background=0)\nl_max = largest_label_volume(labels_2, bg=0)\nif l_max is not None: # There are air pockets\n    air_pocket_binary[labels_2 != l_max] = 0","3ee1afd1":"fig, ax = plt.subplots(1,3,figsize=(20,7))\n\nax[0].imshow(closed_binary_2, cmap=\"binary\", interpolation='nearest')\nax[1].imshow(filled_lungs_binary, cmap=\"binary\", interpolation='nearest')\nax[2].imshow(air_pocket_binary, cmap=\"binary\", interpolation='nearest')\n\n\nax[0].set_title(\"Morphological closing\");\nax[1].set_title(\"Guidos filling lung structures\");\nax[2].set_title(\"Guidos air pocket removal\");","f8132686":"segmented = segment_lung_mask(np.array([hu_scans[20]]))\n\nfig, ax = plt.subplots(1,2,figsize=(20,10))\nax[0].imshow(set_manual_window(hu_scans[20], -700, 255), cmap=\"Blues_r\")\nax[1].imshow(set_manual_window(segmented[0], -700, 255), cmap=\"Blues_r\");","32264f91":"segmented_lungs = segment_lung_mask(hu_scans)","691cf166":"fig, ax = plt.subplots(6,5, figsize=(20,20))\nfor n in range(6):\n    for m in range(5):\n        ax[n,m].imshow(set_manual_window(segmented_lungs[(n+1)*5+m], -700, 255), cmap=\"Blues_r\")","54788662":"plot_3d(segmented_lungs, threshold=-600)","e1199fba":"image_sizes = scan_properties.groupby([\"rows\", \"columns\"]).size().sort_values(ascending=False)\nimage_sizes","b170ef87":"plt.figure(figsize=(8,8))\nfor n in counts.index.values:\n    for m in counts.columns.values:\n        plt.scatter(n, m, s=counts.loc[n,m], c=\"dodgerblue\", alpha=0.7)\nplt.xlabel(\"rows\")\nplt.ylabel(\"columns\")\nplt.title(\"Pixel area of ct-scan per patient\");\nplt.plot(np.arange(0,1400), '-.', c=\"purple\", label=\"squared\")\nplt.plot(888 * np.ones(1400), '-.', c=\"crimson\", label=\"888 rows\");\nplt.legend();","b1e84975":"class ImageObserver:\n    \n    def __init__(self, scan_properties, batch_size):\n        self.scan_properties = scan_properties\n        self.batch_size = batch_size\n    \n    def select_group(self, group=(512,512)):\n        self.group = group\n        self.name = \"rows {}, columns {}\".format(group[0], group[1])\n        self.batch_shape = (self.batch_size, group[0], group[1])\n        self.selection = self.scan_properties[\n            (self.scan_properties[\"rows\"]==group[0]) & (self.scan_properties[\"columns\"]==group[1])\n        ].copy()\n        self.patient_pths = self.selection.patient_pth.unique()\n    \n    \n    def get_loader(self):\n        \n        idx=0\n        images = np.zeros(self.batch_shape)\n        \n        for path in self.patient_pths:\n            \n            scans = load_scans(path)\n            hu_scans = transform_to_hu(scans)\n            images[idx,:,:] = hu_scans[0]\n            \n            idx += 1\n            if idx == self.batch_shape[0]:\n                yield images\n                images = np.zeros(self.batch_shape)\n                idx = 0\n        if idx > 0:\n            yield images","abc9b82c":"my_choice = image_sizes.index.values[0]\nprint(my_choice)\nto_display = 4","13f39285":"observer = ImageObserver(scan_properties, to_display)\nobserver.select_group(my_choice)\nobserver_iterator = observer.get_loader()","d2c0f0a6":"images = next(observer_iterator)","4780e233":"fig, ax = plt.subplots(1,to_display,figsize=(20,5))\n\n\nfor m in range(to_display):\n    image = images[m]\n    ax[m].imshow(set_manual_window(image, -500, 1000), cmap=\"YlGnBu\")\n    ax[m].set_title(observer.name)","292d985f":"scan_properties.shape","8b2eb31b":"scan_properties.head(1)","76595237":"def resize_scan(scan, new_shape):\n    # read slice as 32 bit signed integers\n    img = Image.fromarray(scan, mode=\"I\")\n    # do the resizing\n    img = img.resize(new_shape, resample=Image.LANCZOS)\n    # convert back to 16 bit integers\n    resized_scan = np.array(img, dtype=np.int16)\n    return resized_scan","872d1584":"def crop_scan(scan):\n    img = Image.fromarray(scan, mode=\"I\")\n    \n    left = (scan.shape[0]-512)\/2\n    right = (scan.shape[0]+512)\/2\n    top = (scan.shape[1]-512)\/2\n    bottom = (scan.shape[1]+512)\/2\n\n    img = img.crop((left, top, right, bottom))\n    # convert back to 16 bit integers\n    cropped_scan = np.array(img, dtype=np.int16)\n    return cropped_scan","dc57e8bd":"def crop_and_resize(scan, new_shape):\n    img = Image.fromarray(scan, mode=\"I\")\n    \n    left = (scan.shape[0]-512)\/2\n    right = (scan.shape[0]+512)\/2\n    top = (scan.shape[1]-512)\/2\n    bottom = (scan.shape[1]+512)\/2\n    \n    img = img.crop((left, top, right, bottom))\n    img = img.resize(new_shape, resample=Image.LANCZOS)\n    \n    cropped_resized_scan = np.array(img, dtype=np.int16)\n    return cropped_resized_scan","d531bf82":"def preprocess_to_hu_scans(scan_properties, my_shape, output_dir):\n    \n    for i, patient in enumerate(tqdm(scan_properties.patient.values)):\n        pth = scan_properties.loc[scan_properties.patient==patient].patient_pth.values[0]\n        scans = load_scans(pth)\n        hu_scans = transform_to_hu(scans) \n        prepared_scans = np.zeros((hu_scans.shape[0], my_shape[0], my_shape[1]), dtype=np.int16)\n        \n        # if squared:\n        if hu_scans.shape[1] == hu_scans.shape[2]:\n            \n            # if size is as desired\n            if hu_scans.shape[1] == my_shape[0]:\n                continue\n            # else resize:\n            else:\n               # as we have not converted to jpeg to keep all information, we need to do a workaround\n                hu_scans = hu_scans.astype(np.int32)\n                for s in range(hu_scans.shape[0]): \n                    prepared_scans[s] = resize_scan(hu_scans[s,:,:], my_shape)\n\n        # if non-squared - do a center crop to 512, 512 and then resize to desired shape\n        else:\n            hu_scans = hu_scans.astype(np.int32)\n            for s in range(hu_scans.shape[0]):\n                # if desired shape is 512x512:\n                if my_shape[0]==512:\n                    prepared_scans[s] = crop_scan(hu_scans[s,:,:])\n                else:\n                    prepared_scans[s] = crop_and_resize(hu_scans[s,:,:], my_shape)\n                \n        # save the prepared scans of patient:\n        np.save(output_dir + \"\/\" + patient + '_hu_scans', prepared_scans)","f13bc654":"generate_512_512 = False\n\nif generate_512_512:\n    output_dir = \"scans_512x512\"\n    mkdir(output_dir)\n    my_shape = (512, 512)\n    preprocess_to_hu_scans(scan_properties, my_shape, output_dir)","c94cc227":"generate_224_224 = False\n\nif generate_224_224:\n    output_dir = \"scans_224x224\"\n    mkdir(output_dir)\n    my_shape = (224, 224)\n    preprocess_to_hu_scans(scan_properties, my_shape, output_dir)","3bc6bc73":"generate_128_128 = False\n\nif generate_128_128:\n    output_dir = \"scans_128x128\"\n    mkdir(output_dir)\n    my_shape = (128, 128)\n    preprocess_to_hu_scans(scan_properties, my_shape, output_dir)","5b010be3":"generate_64_64 = False\n\nif generate_64_64:\n    output_dir = \"scans_64x64\"\n    mkdir(output_dir)\n    my_shape = (64, 64)\n    preprocess_to_hu_scans(scan_properties, my_shape, output_dir)","204fd77f":"dcm_file = pydicom.dcmread(\n    \"..\/input\/siim-covid19-detection\/train\/00086460a852\/9e8302230c91\/65761e66de9f.dcm\"\n)\n\ndcm_file","303fa4ec":"basepath = \"..\/input\/siim-covid19-detection\/\"","97af0e03":"train = pd.read_csv(\"..\/input\/siim-covid19-detection\/train_image_level.csv\")\ntrain.loc[:, \"SOPInstanceUID\"] = train.id.str.split(\"_\", expand=True).loc[:, 0]\ntrain.head()","582df33b":"path = \"..\/input\/siim-covid19-detection\/train\/\"\ntrain.loc[:, \"file_count\"] = 0\nfor study_id in train.StudyInstanceUID.unique():\n    num_files = 0\n    for filepath in glob.glob(path + study_id + \"\/*\/*.dcm\"):\n        train.loc[train.StudyInstanceUID==study_id, \"file_count\"] = num_files\n        num_files += 1\n\ntrain.loc[:, \"num_files\"] = train.StudyInstanceUID.map(\n    train.groupby(\"StudyInstanceUID\").file_count.max())","78915f50":"fig, ax = plt.subplots(1,1,figsize=(20,5))\nsns.countplot(train.num_files, ax=ax, palette=\"Reds_r\")\nax.set_xlabel(\"Number of dicom files per patient\")\nax.set_ylabel(\"Counts in train\");\nax.set_title(\"Train\");","d39ca716":"Ok, there are a few more cases with two dicom images and a few patients with more than 2! We should keep this in mind!","bd366f21":"## Generating non-segmented, original raw image data <a class=\"anchor\" id=\"non_segmented_original\"><\/a>\n\nhttps:\/\/www.kaggle.com\/allunia\/osic-pulmonary-fibrosis-progression-huscans","4ca8fa23":"## Transforming to Hounsfield Units <a class=\"anchor\" id=\"hunits\"><\/a>","59bc4a79":"Hmm I can't see a great difference. Perhaps the one with the large slice volume looks a bit more blurred. But as above there is an outside-scanner region that was set to the walue of water (HU value of 0) instead of air.","cf8b1227":"Ok great. Now all raw values per slice are scaled to H-units.","4b842963":"I built this solution upon Guidos that did not work well in this competition. Here is code I won't use but I kept it to show by example why I found it not helpful:","7ec9b935":"### Slice thickness and pixel area\n\nThe slice thickness tells us how much distance is covered in Z-direction by one slice. Let's plot the distribution of it as well. Furthermore the pixel_array of raw values covers a specific area given by row and column values. Let's take a look at it as well: ","d3603bcf":"If you haven't worked with dicom so far, I can recommend this video. If you like to speed up, start at 7 min:","bc8f1739":"## Number of rows and columns","8d34eb29":"## Physical area & slice volume covered by a single ct-scan","9f756489":"Let's take a look at the first dicom file of our example patient:","f3a107a3":"## Resampling the voxel size","2e48afb3":"# Working with dicom files <a class=\"anchor\" id=\"dicom\"><\/a>","1fb6a499":"# Prepare to start <a class=\"anchor\" id=\"prepare\"><\/a>","a7341e5d":"## Pixelspacing","4fdccb70":"### Understanding the segmentation step by step:","e48657da":"There is a lot of further interesting information:\n\n* The **PatientID** and the **PatientName**. Perhaps we can't say that each patient has its own study-id... what if there were more than one ct-scans on differents days per patient?! What if a patient has more than one study id?\n* As the other EDAs show: One can see the **body parts examined and the gender**!\n\n* The pixel spacing! (I miss the slice thickness... hmm)\n* The number of rows and columns\n* The photometric interpretation (:-O What's that?!)\n\n... and a lot more stuff I don't know at the moment like the private creator part. Nonetheless we can already explore a bit more details! :-)\n","38caefe0":"Compare to above this one looks far better. Let's plot the distributions. Perhaps we can understand what's going wrong by taking a look at them:","702913df":"### Insights\n\nBrowse through the different groups and you will find out for OSIC that...\n\n* The large squared image sizes often show resolutions higher than with 512 rows and 512 columns. Here resizing to the two major groups (512, 512) or (768, 768) makes sense.\n* In the non-squared cases a center crops should work best as they only have more background values but still belong to the major groups in the inside-scanner-region.","1918d483":"Now we can set all labelled regions of the binary image that correspond to these corner-labels to the \"not-lung\"-value 2:","a5cdac24":"The result of these steps looks as follows:","f064fc79":"TODO!","55dfb17b":"First of all we are separating between \"potentially lung\" with values smaller or equal to 320. Why 320? I just kept the value of Guidos old notebook. Try out your own values if you like. ;-) Before you do so, you make like to take a look at the hu_value distribution again:","8a4b8999":"### Smallest and largest CT-slice volume","e56650fb":"And here is how it looks like if we mask the original image with the segmented binary lungs in our 2D example:","bdcf25a4":"* Very thin slices allow more details to be shown. On the other hand thick slices contain less noise but are more prone to artifacts. Hmm... I'm very excited to see some examples here as well. \n* Even though it is common to have 512x512 pixel size areas, we can see that this is not always true!! We can find a lot of exceptions and even one or a few very large pixel areas (1300x1300)!!! (OSIC)\n* Proper preprocessing of these scans might be very important... we have to check it.","f2b94f98":"Have to rework this part for RSNA!","00188a1b":"For OSIC it's interesting that we have two different kind of patterns. In the RSNA competition all training images are of shape 512, 512. So you don't need to explore the image sizes further. But perhaps it's still useful to browse through the images to gain ideas for good augmentations.","41d632bc":"This is now the segmentation function I am using:","a8749789":"Now, we know some important quantities to compute the physical distance covered by a ct-scan!","f04163a5":"Hmm","a35b2389":"If you like try to improve the segmentation and play with your own ideas and concepts! :-) I like to create two datasets - one with segmentation already done and one without. So you can decide on your own if you like to build a custom augmentation that performs the segmentation on the fly when loading your batches.","d91e8417":"## Loading CT-scans per patient <a class=\"anchor\" id=\"ct_scans\"><\/a>\n\n* To load the full 3D-scan we need to order the single dicom files\/slices by the ImagePosition: ","6d410e15":"Ok, we are not really sure yet that each patient has only 1 dicom file. So let's count them!","a855b014":"And with his air-pocket removal:","d33f153a":"### Insights\n\n* Taking a look at one slice of a scan with smallest and largest slice area, we can see that the large one has a lot of useless region covered. We could crop it.\n* Strange... in the second image with the large area the outside region of the scanner tube is not set to the value of air but rather to some value in the middle of the range -1000 to 1000.","8e43fc1d":"Just run the following cell again, to observe the next batch of images:","ce67453b":"Let's compare with Guidos fill-lungs method:","fa8a4bb9":"You can see that this looks quite different to this one:","930932e8":"Ohoh! We have some images with extreme large sliche areas and volumes! I think it's time to do some EDA regarding these features! ","4ec44d9d":"Such kind of obvious patterns are always worth to take a look at. Perhaps we can find some kind of rule that allows us to create a good resizing strategy. Here is a small observer that allows you to browse through the files by just running the code cell again:","df18e1f3":"## Number of files per patient","be77dd19":"## Peek at the dicom-file <a class=\"anchor\" id=\"covid19-dicom-peek\"><\/a>\n\n* When browsing through the dictionaries of this competition compared to the other both we can see that **there seems to be only 1 dicom-file per patient**! Consequently we can't build something like a 3D reconstruction of the chest. \n* But nonetheless there are a lot of further informations and methods from above we may like to use.\n\n\nLet's take a look at a single dcm-file:","97cb60e6":"Lungs have values of 1 as well as air backgrounds. In contrast water-like default backgrounds and many other organic tissues or fluids have values of 2. As we only like to segment the lungs, we need to remove the background. In the case of air and air-like default values we need to do set their values manually to 2. We can do so by labelling connected regions in the binary image and extracting the labels of each region that corresponds to the corners or edges of the 2D image slice:","c17de313":"### Pixelspacing\n\n* The pixelspacing attribute you can find in the dicom files is an important one. It tells us how much physical distance is covered by one pixel. You can see that there are only 2 values that describe the x- and y-direction in the plane of a transversal slice. \n* For one patient this pixelspacing is usually the same for all slices.\n* But between patients the pixelspacing can differ due to personal or institutional preferences of doctors and the clinic and it also depends on the scanner type. Consequently if you compare two images in the size of the lungs it does not automatically mean that the bigger one is really larger in the physical size of the organ!\n\nLet's explore the distributions of the patients pixelspacing widths and heights of this competition:","511e2148":"For some examples we can see that there are raw values at -2000. They correspond to images with a circular boundary within the image. The \"outside\" of this circle value is often set to -2000 (or in other competitions I found also -3000) by default.","e416da85":"I'm not sure if it's really important to do this resampling, because we can already do a lot with augmentations. We can resize, crop, blur and shift intensities. Also the background-problem with outside scanner regions set to water HU-values can be solved. For this reason I don't like to do the resampling. ;-) Perhaps you like to do it. For this purpose I leave the code from Guidos notebook: ","21d36840":"## The voxel size <a class=\"anchor\" id=\"voxel\"><\/a>\n\nThe voxel stands for the 3D-pixel that is given in a CT-scan. As far as I know it is spanned by the 2d-plane of the pixelspacing attribute in x- and y-direction and the slice thickness in z-direction.","309a23ae":"# References <a class=\"anchor\" id=\"references\"><\/a>","fd6c6685":"The plot_3d works well in the Data Science Bowl 2017 but in our case the results are not so well. It depends on the threshold but so far I don't know why our reconstructions often look blurred or show tube regions as well. :-(","628ddb57":"### Insights\n\n1. The first image shows the raw binary. In this case we find air as background and we need to set it to the \"not-lung\" value of 2.\n2. For this purpose we label all connected regions in the binary image. There are many different labelled regions but the only ones we are interested in are the 4 corner regions at (0,0), (0,500), (500,0) and (500,500).\n3. Knowing the related labels help us to manually set the background to the value 2 (black).\n4. In the end we can see that the lungs are white (1) but we still find a lot of remaining signals that correspond to body tissue that we still need to remove.","e367a03b":"The least we can do is to resize and crop all those images that don't have a shape of (512,512) and to transform their values to Hounsfield units. Furthermore we can create smaller images by resizing to a desired shape. As far as I know this is not that easy as it sounds as we won't use common Image dtypes but rather original HU values without converting them. Most image preprocessing packages I found can't easily deal with numpy arrays. For this reason I used a workaround:\n\n* I changed the dytpe of my hu-transformed numpy-array scans to Int32\n* This way I can pass them to PILs Image class using fromarray with mode=\"I\"\n* Then I can use the resize and crop method of this package\n* After that the array turns back to Int16 as I like to reduce memory cost\n\nHmm... still feels not good and I'm also a bit confused. You can see that dicom can also be covered with most common Image preprocessing packages this way:\n\n* https:\/\/www.kaggle.com\/onealbao\/dicom-to-jpeg-conversion-kernel\n\nI still need to read about converting dicom or \"how to loose or not loose information\"! ;-)","4b41c221":"We can see that the values really vary a lot from patient to patient! As they are given in mm and ct-scans usually cover 512 row and column values... **oh wait! we need to check this!** ... we can compute the minimum and maximum distance that is covered by the images:","43e53701":"### Final solution","b46fa650":"## CT-scan slice area and volume - EDA <a class=\"anchor\" id=\"scan_eda\"><\/a>","25148544":"176 different patients in train!","90f87e21":"### Adding further information\n\n1. The CT-scan captures information about the radiodensity of an object or tissue exposed to x-rays. A transversal slice of a scan is reconstructed after taking measurements from several different directions.\n2. We need to transform to Hounsfield units as the spectral composition of the x-rays depends on the measurement settings like acquisition parameters and tube voltage. By normalizing to values of water and air (water has HU 0 and air -1000) the images of different measurements are becoming comparable.\n3. A ct-scanner yields roughly 4000 grey values that can't be captured by our eyes. This is why windowing is performed. This way the image is displayed in a HU range that suites most to the region of interest. ","99d16f3b":"## Data Science Bowl 2017 - Preprocessing Tutorial by Guido Zuidhof <a class=\"anchor\" id=\"bowl_2017\"><\/a>\n\nOnce upon a time there was a data science bowl about lung cancer detection that had a fantastic preprocessing tutorial: https:\/\/www.kaggle.com\/gzuidhof\/full-preprocessing-tutorial ;-)\n\n* My notebook heavily uses the concepts and code snippets of this notebook by Guido Zuidhof. \n* With my work I like to bring back his ideas to following pulmonary competitions based on CT-scans and I like to add a few more explanations while writing it. \n* Furthermore I hope that I can help to generate a dataset in the end that contains the preprocessed data to feed into your models.\n\nHave fun! :-)","9229a033":"Looks the same as the max_hu_scans above!","33a1bb0a":"With -320 we are separating between lungs (-700) \/air (-1000) and tissue with values close to water (0).","d95d41ea":"### Smallest and larges CT-slice area","12f17c23":"Just to speed up the computation, I have selected N patients to consider. Use N = train.shape[0] to do this for all patients in the dataset:","05ccd3f2":"## 3D-reconstruction of CT-scans <a class=\"anchor\" id=\"reconstruction\"><\/a>","2732ff17":"I think we need to understand the marching_cubes_lewiner algorithm to understand why the plot sometimes works nice and sometimes not. But I think this is not really important for the competition itself. At the moment I don't like to spend more time on that topic. Perhaps it's more important to keep in mind that the overall distributions can be different.","558c3384":"To remove the signals we can use morphological closing. If you like play with the disk value. It must be large enough to cancel the body signals but small enough to keep enough details inside the lungs:","1bbe5984":"# SIIM-FISABIO-RSNA COVID-19 Detection competition <a class=\"anchor\" id=\"siim-covid-19\"><\/a>","ae91e0c2":"And we can also check how it looks in the 3D case:","1a941102":"## Tissue segmentation <a class=\"anchor\" id=\"segmentation\"><\/a>","cb28b066":"Let's load the csv-files:","91cb2be1":"Before starting, let's plot the pixelarray distribution of some dicom files to get an impression of the raw data:","f6162fac":"Interesting that we still have some signals outside of the lungs:","61465869":"# Generating a dataset for preprocessed files <a class=\"anchor\" id=\"datagenerator\"><\/a>\n\n\n## Dealing with different image-scan sizes <a class=\"anchor\" id=\"image_sizes\"><\/a>\n\nTo generate the data, we should take a look again at the different images sizes: For OSIC we have two major size groups and some minor outliers. For example we could manually resize or crop the outliers and find a strategy for the two major groups. Let's take a look at the sizes again:","b275f1e8":"## Papers <a class=\"anchor\" id=\"papers\"><\/a>\n\nTo understand what and why we are doing these concepts here, I started to read a few papers:\n\n* [Intrinsic dependencies of CT radiomic features on voxel size and number of gray levels](https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC5462462\/)","77993632":"## Table of contents\n\n\n1. [References](#references)\n    * [Data Science Bowl 2017 - Preprocessing Tutorial by Guido Zuidhof](#bowl_2017)\n    * [Papers](#papers)\n2. [Prepare to start](#prepare)\n3. [Working with dicom files](#dicom)\n    * [Loading CT-scans per patient](#ct_scans)\n    * [Transforming to Hounsfield Units](#hunits)\n    * [The voxel size](#voxel)\n    * [CT-scan slice area and volume - EDA](#scan_eda)\n    * [3D-reconstruction of CT-scans](#reconstruction)\n    * [Tissue segmentation](#segmentation)\n4. [Generating a dataset for preprocessed files](#datagenerator)\n    * [Link to public dataset](https:\/\/www.kaggle.com\/allunia\/osic-pulmonary-fibrosis-progression-huscans)\n5. [SIIM-FISABIO-RSNA COVID-19 Detection competition](#siim-covid-19)\n    * [Peek at the dicom-file](#covid19-dicom-peek)","6031f0c0":"* For the OSIC example we can find: Ihh... it was set to water by default in the large image... why?! That's bad! We need to find some strategy to deal with this problem. It's not good that we sometimes have \"water\"-like outside regions and sometimes \"air\"-like regions.","67fb4ca1":"### Insights\n\n* The morphological closing worked better than Guidos method. But we are often missing a lot of information inside the lungs just to remove these body signals. There is definitely room for improvements! ;-)\n* In contrast the fill-lung method has troubles with the remaining singals of the body and yields not what we like to obtain.\n* Furthermore the air-pocket removal does also not work well.\n\nProbably I'm having some kind of bug. Can't imagine that Guidos methods didn't work at all?! For this reason I just stayed with the simplest solution of morphological closing."}}