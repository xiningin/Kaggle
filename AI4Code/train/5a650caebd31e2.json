{"cell_type":{"4756b6e0":"code","a0f4f482":"code","20e08cba":"code","17448eda":"code","47780faf":"code","733f9728":"code","b24ed0a2":"code","aa700c66":"code","5cdf88da":"code","2582127f":"code","87430dc1":"code","27cb6682":"code","0aed35d8":"markdown","9b5f2ee2":"markdown","3c982f5a":"markdown","cff55f55":"markdown","9d970f43":"markdown","5ca5deca":"markdown","c762cee0":"markdown","ec7833c0":"markdown","beabf4a0":"markdown","257f085a":"markdown","3d087bfe":"markdown","6095f59c":"markdown","5c33965e":"markdown","c8decf67":"markdown","394f6f30":"markdown","4c77350f":"markdown"},"source":{"4756b6e0":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import csr_matrix\nfrom sklearn.neighbors import NearestNeighbors\nfrom fuzzywuzzy import process","a0f4f482":"movie=pd.read_csv('..\/input\/movielens-20m-dataset\/movie.csv')\nrating=pd.read_csv('..\/input\/movielens-20m-dataset\/rating.csv')\ntag=pd.read_csv('..\/input\/movielens-20m-dataset\/tag.csv')","20e08cba":"movie.head()","17448eda":"movie['year'] = movie.title.str.extract('(\\(\\d\\d\\d\\d\\))',expand=False)\n#Removing the parentheses\nmovie['year'] = movie.year.str.extract('(\\d\\d\\d\\d)',expand=False)","47780faf":"#Removing the years from the 'title' column\nmovie['title'] = movie.title.str.replace('(\\(\\d\\d\\d\\d\\))', '')\n#Applying the strip function to get rid of any ending whitespace characters that may have appeared\nmovie['title'] = movie['title'].str.strip()\nmovie.head()","733f9728":"rating.groupby('movieId').rating.mean()\nrating.head()","b24ed0a2":"df=movie.join(rating,lsuffix='N', rsuffix='K')\ndf","aa700c66":"df=df.drop(['movieIdK','genres','year','timestamp'],axis=1)","5cdf88da":"# There will be lot of nan value in our new dataframe as it is highly unlikely that that ours users have seen almost all movies.\nmovie_users=df.pivot(index='movieIdN', columns='userId',values='rating').fillna(0)\nmatrix_movies_users=csr_matrix(movie_users.values)\nprint(matrix_movies_users)","2582127f":"knn= NearestNeighbors(metric='cosine', algorithm='brute', n_neighbors=10)","87430dc1":"knn.fit(matrix_movies_users)","27cb6682":"def recommender(movie_name, data,model, n_recommendations ):\n    model.fit(data)\n    idx=process.extractOne(movie_name, df['title'])[2]\n    print('Movie Selected:-',df['title'][idx], 'Index: ',idx)\n    print('Searching for recommendations.....')\n    distances, indices=model.kneighbors(data[idx], n_neighbors=n_recommendations)\n    for i in indices:\n        print(df['title'][i].where(i!=idx))\n    \nrecommender('jumanji', matrix_movies_users, knn,5)","0aed35d8":"# **Results**\n\nItem-item collaborative filtering had less error than user-user collaborative filtering. In addition, its less-dynamic model was computed less often and stored in a smaller matrix, so item-item system performance was better than user-user systems.**","9b5f2ee2":"let's have a look at our dataset","3c982f5a":"**Fitting the model**","cff55f55":"We have to make a matrix with these columns for our model.","9d970f43":"Let's remove unnessesary columns.","5ca5deca":"**Method**\n\nFirst, the system executes a model-building stage by finding the similarity between all pairs of items. This similarity function can take many forms, such as correlation between ratings or cosine of those rating vectors. As in user-user systems, similarity functions can use normalized ratings (correcting, for instance, for each user's average rating).\n\nSecond, the system executes a recommendation stage. It uses the most similar items to a user's already-rated items to generate a list of recommendations. Usually this calculation is a weighted sum or linear regression. This form of recommendation is analogous to \"people who rate item X highly, like you, also tend to rate item Y highly, and you haven't rated item Y yet, so you should try it\".**","c762cee0":"First clean our dataset a bit by clearing year from title column and generating year column.","ec7833c0":"# MOVIE RECOMMENDATION SYSTEM\n\n![disney.jpg](attachment:disney.jpg)","beabf4a0":"Now join the two data sets as we require user ID , movie rating, and name of all the movies for our model.","257f085a":"We gonna use NearestNeighbors for computing similarities between the ratings rated by other users on same movie.\nThere are different metric in knn like Euclidean Distance,Manhattan Distance,Minkowski Distance,Cosine Similarity.In this we will use cosine similarity as our metric.","3d087bfe":"**Importing the dataset**","6095f59c":"**Item-based collaborative filtering**\n\nItem-item collaborative filtering, or item-based, or item-to-item, is a form of collaborative filtering for recommender systems based on the similarity between items calculated using people's ratings of those items. Item-item collaborative filtering was invented and used by Amazon.com in 1998.It was first published in an academic conference in 2001.\n\nEarlier collaborative filtering systems based on rating similarity between users (known as user-user collaborative filtering) had several problems:\n\nsystems performed poorly when they had many items but comparatively few ratings\ncomputing similarities between all pairs of users was expensive\nuser profiles changed quickly and the entire system model had to be recomputed\nItem-item models resolve these problems in systems that have more users than items. Item-item models use rating distributions per item, not per user. With more users than items, each item tends to have more ratings than each user, so an item's average rating usually doesn't change quickly. This leads to more stable rating distributions in the model, so the model doesn't have to be rebuilt as often. When users consume and then rate an item, that item's similar items are picked from the existing system model and added to the user's recommendations.","5c33965e":"**So let's get started**","c8decf67":"# **When Else Can Collaborative Filtering Be Used?**\n\nCollaborative filtering works around the interactions that users have with items. These interactions can help find patterns that the data about the items or users itself can\u2019t. Here are some points that can help you decide if collaborative filtering can be used:\n\n-Collaborative filtering doesn\u2019t require features about the items or users to be known. It is suited for a set of different types of items, for example, a supermarket\u2019s inventory where items of various categories can be added. In a set of similar items such as that of a bookstore, though, known features like writers and genres can be useful and might benefit from content-based or hybrid approaches.\n\n-Collaborative filtering can help recommenders to not overspecialize in a user\u2019s profile and recommend items that are completely different from what they have seen before. If you want your recommender to not suggest a pair of sneakers to someone who just bought another similar pair of sneakers, then try to add collaborative filtering to your recommender spell.\n\nAlthough collaborative Filtering is very commonly used in recommenders, some of the challenges that are faced while using it are the following:\n\n-Collaborative filtering can lead to some problems like cold start for new items that are added to the list. Until someone rates them, they don\u2019t get recommended.\n\n-Data sparsity can affect the quality of user-based recommenders and also add to the cold start problem mentioned above.\n\n-Scaling can be a challenge for growing datasets as the complexity can become too large. Item-based recommenders are faster than user-based when the dataset is large.\n\n-With a straightforward implementation, you might observe that the recommendations tend to be already popular, and the items from the long tail section might get ignored.\n\nWith every type of recommender algorithm having its own list of pros and cons, it\u2019s usually a hybrid recommender that comes to the rescue. The benefits of multiple algorithms working together or in a pipeline can help you set up more accurate recommenders. In fact, the solution of the winner of the Netflix prize was also a complex mix of multiple algorithms.","394f6f30":"In this notebook,I have made a basic movie recommendation system using item based Collaborative Filtering.\n\nCollaborative filtering is a technique that can filter out items that a user might like on the basis of reactions by similar users.\nIt works by searching a large group of people and finding a smaller set of users with tastes similar to a particular user. It looks at the items they like and combines them to create a ranked list of suggestions.","4c77350f":"Now let's make our recommendation function.In this I have used a function from library named as fuzzywuzzy ,it solves the problem of finding the movies with mis-spells and regardless of its letter in lower case or upper case."}}