{"cell_type":{"47d7a60a":"code","d25098ca":"code","830e4585":"code","d75ce422":"code","7486477c":"code","b081995a":"code","83019586":"code","187162c9":"code","92ae364e":"code","dbcd290f":"code","3d67c57f":"code","931938e2":"code","a31a1722":"code","91f915b7":"code","2bbb3401":"code","c49ff615":"code","c0ed7f0a":"code","5db2ec1d":"code","7964021a":"code","9c49f9c0":"code","ffb154d4":"code","3123c088":"code","01017199":"code","39b26068":"markdown","6b8cc827":"markdown","4f580bcf":"markdown","67211aee":"markdown","03f68151":"markdown","23129814":"markdown","a6bd37b8":"markdown","9e936c9c":"markdown","d9676220":"markdown"},"source":{"47d7a60a":"import pandas as pd\nimport numpy as np\nfrom pathlib import Path\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport time\nfrom tqdm import tqdm_notebook\nimport os\nimport collections","d25098ca":"PATH_TO_DATA = Path('\/kaggle\/input\/mlcourse-dota2-win-prediction')","830e4585":"target = pd.read_csv(PATH_TO_DATA \/'train_targets.csv', index_col='match_id_hash')\ntrain_initial = pd.read_csv(PATH_TO_DATA \/'train_features.csv', index_col='match_id_hash')\ntest_initial = pd.read_csv(PATH_TO_DATA \/'test_features.csv', index_col='match_id_hash')\n\ntarget['radiant_win'] = target['radiant_win'].map({False: 0, True: 1})","d75ce422":"MATCH_FEATURES = [\n    ('game_time', lambda m: m['game_time']),\n    ('game_mode', lambda m: m['game_mode']),\n    ('lobby_type', lambda m: m['lobby_type']),\n    ('objectives_len', lambda m: len(m['objectives'])),\n    ('chat_len', lambda m: len(m['chat'])),\n]\n\nPLAYER_FIELDS = [\n    'hero_id',\n    \n    'kills',\n    'deaths',\n    'assists',\n    'denies',\n    \n    'gold',\n    'lh',\n    'xp',\n    'health',\n    'max_health',\n    'max_mana',\n    'level',\n\n    'x',\n    'y',\n    \n    'stuns',\n    'creeps_stacked',\n    'camps_stacked',\n    'rune_pickups',\n    'firstblood_claimed',\n    'teamfight_participation',\n    'towers_killed',\n    'roshans_killed',\n    'obs_placed',\n    'sen_placed',\n\n]\n\n\ndef extract_features_csv(match):\n    row = [\n        ('match_id_hash', match['match_id_hash']),\n    ]\n    \n    for field, f in MATCH_FEATURES:\n        row.append((field, f(match)))\n        \n    for slot, player in enumerate(match['players']):\n        if slot < 5:\n            player_name = 'r%d' % (slot + 1)\n        else:\n            player_name = 'd%d' % (slot - 4)\n\n        for field in PLAYER_FIELDS:\n            column_name = '%s_%s' % (player_name, field)\n            row.append((column_name, player[field]))\n        \n        for field in ['ability_upgrades']:\n            column_name = '%s_%s' % (player_name, field)\n            row.append((column_name, len(player[field])))\n        \n        for field in ['damage', 'damage_taken']:\n            column_name = '%s_%s' % (player_name, field)\n            row.append((column_name, sum(list(player[field].values()))))\n        \n        row.append( (f'{player_name}_items', list(map(lambda x: x['id'][5:], player['hero_inventory'])) ) ) # return the list of items\n            \n    return collections.OrderedDict(row)","7486477c":"try:\n    import ujson as json\nexcept ModuleNotFoundError:\n    import json\n    print ('Please install ujson to read JSON objects faster')\n    \ntry:\n    from tqdm import tqdm_notebook\nexcept ModuleNotFoundError:\n    tqdm_notebook = lambda x: x\n    print ('Please install tqdm to track progress with Python loops')\n\ndef read_matches(matches_file):\n    \n    MATCHES_COUNT = {\n        'test_matches.jsonl': 10000,\n        'train_matches.jsonl': 39675,\n    }\n    _, filename = os.path.split(matches_file)\n    total_matches = MATCHES_COUNT.get(filename)\n    \n    with open(matches_file) as fin:\n        for line in tqdm_notebook(fin, total=total_matches):\n            yield json.loads(line)","b081995a":"df_new_features = []\ndf_new_features_test = []","83019586":"for match in read_matches(os.path.join(PATH_TO_DATA, 'train_matches.jsonl')):\n    match_id_hash = match['match_id_hash']\n    features = extract_features_csv(match)\n    df_new_features.append(features)","187162c9":"for match in read_matches(os.path.join(PATH_TO_DATA, 'test_matches.jsonl')):\n    match_id_hash = match['match_id_hash']\n    features = extract_features_csv(match)\n    df_new_features_test.append(features)","92ae364e":"train_extracted = pd.DataFrame.from_records(df_new_features).set_index('match_id_hash')\ntest_extracted = pd.DataFrame.from_records(df_new_features_test).set_index('match_id_hash')","dbcd290f":"def add_new_features(df_features, matches_file):\n    \n    # Process raw data and add new features\n    for match in read_matches(matches_file):\n        match_id_hash = match['match_id_hash']\n\n        # Counting ruined towers for both teams\n        radiant_tower_kills = 0\n        dire_tower_kills = 0\n        radiant_baracks_kills = 0\n        dire_baracks_kills = 0\n        radiant_aegis = 0\n        dire_aegis = 0\n        for objective in match['objectives']:\n            if objective['type'] == 'CHAT_MESSAGE_TOWER_KILL': # feature presented in yorko's kernel as well, usefulness of this feature is obvious\n                if objective['team'] == 2:\n                    radiant_tower_kills += 1\n                if objective['team'] == 3:\n                    dire_tower_kills += 1\n            if objective['type'] == 'CHAT_MESSAGE_TOWER_DENY': # tower deny is some kind of extension of tower_kill feature (pay attention, if the team denies their tower - the enemy gets +1 tower kill)\n                if objective['player_slot'] in [128, 129, 130, 131, 132]:\n                    radiant_tower_kills += 1\n                if objective['player_slot'] in [0,1,2,3,4]:\n                    dire_tower_kills += 1\n            if objective['type'] == 'CHAT_MESSAGE_BARRACKS_KILL': # barracks situated nearly opposite team's base, which means that barrack kills may be potentially very strong feature \n                                                                    #(be attentive, this time keys are in string format)\n                if objective['key'] in ['1','2','4','8','16','32']:\n                    radiant_baracks_kills += 1\n                if objective['key'] in ['64','128','256','512','1024','2048']:\n                    dire_baracks_kills += 1\n            if objective['type'] == 'CHAT_MESSAGE_AEGIS': # aegis grants an extra life, roshan drops it each time he dies (so may be correlated with roshan feature)\n                if objective['player_slot'] in [0,1,2,3,4]:\n                    radiant_aegis += 1\n                if objective['player_slot'] in [128, 129, 130, 131, 132]: \n                    dire_aegis += 1\n                \n        \n        r_chat = 0\n        d_chat = 0\n        r_memb_chat = []\n        d_memb_chat = []\n        for chat in match['chat']:\n            if chat['player_slot'] in [0,1,2,3,4]:\n                r_chat += 1\n                r_memb_chat.append(chat['player_slot'])\n            if chat['player_slot'] in [128, 129, 130, 131, 132]: \n                d_chat += 1\n                d_memb_chat.append(chat['player_slot'])\n        \n        # Write new features\n        df_features.loc[match_id_hash, 'radiant_tower_kills'] = radiant_tower_kills\n        df_features.loc[match_id_hash, 'dire_tower_kills'] = dire_tower_kills\n        df_features.loc[match_id_hash, 'diff_tower_kills'] = radiant_tower_kills - dire_tower_kills\n        \n        df_features.loc[match_id_hash, 'radiant_baracks_kills'] = radiant_baracks_kills\n        df_features.loc[match_id_hash, 'dire_baracks_kills'] = dire_baracks_kills\n        df_features.loc[match_id_hash, 'diff_baracks_kills'] = radiant_baracks_kills - dire_baracks_kills\n        \n        df_features.loc[match_id_hash, 'radiant_aegis'] = radiant_aegis\n        df_features.loc[match_id_hash, 'dire_aegis'] = dire_aegis\n        df_features.loc[match_id_hash, 'diff_aegis'] = radiant_aegis - dire_aegis\n        \n        df_features.loc[match_id_hash, 'radiant_chat_len'] = r_chat\n        df_features.loc[match_id_hash, 'dire_chat_len'] = d_chat\n        df_features.loc[match_id_hash, 'diff_chat_len'] = r_chat - d_chat # return chat length for each team, not the common one as in initial dataset\n        \n        df_features.loc[match_id_hash, 'radiant_chat_memb'] = len(np.unique(r_memb_chat))\n        df_features.loc[match_id_hash, 'dire_chat_memb'] = len(np.unique(d_memb_chat))\n        df_features.loc[match_id_hash, 'diff_chat_memb'] = len(np.unique(r_memb_chat)) - len(np.unique(d_memb_chat)) # return the number of team members, who participate in chatting","3d67c57f":"add_new_features(train_extracted, \n                 os.path.join(PATH_TO_DATA, \n                              'train_matches.jsonl'))\nadd_new_features(test_extracted, \n                 os.path.join(PATH_TO_DATA, \n                              'test_matches.jsonl'))","931938e2":"# function creates damage features as well as difference between damage given and taken for each player\ndef add_damage(df):\n    for team in 'r', 'd':\n        players = [f'{team}{i}' for i in range(1, 6)]\n        for player in players:\n            df[f'{player}_dam_diff'] = df[f'{player}_damage'] - df[f'{player}_damage_taken']\n    df.drop(df.filter(like = 'damage').columns, axis = 1, inplace = True)\n    return df","a31a1722":"add_damage(train_extracted)\nadd_damage(test_extracted);","91f915b7":"[x for x in list(train_extracted.columns) if x not in list(train_initial.columns)]","2bbb3401":"train_extracted[[x for x in list(train_extracted.columns) if x not in list(train_initial.columns)]].head()","c49ff615":"train_extracted.to_pickle('train_extracted.pkl')\ntest_extracted.to_pickle('test_extracted.pkl')\ntarget.to_pickle('target.pkl')","c0ed7f0a":"from sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import ShuffleSplit, KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.ensemble import RandomForestClassifier\n\ncv = ShuffleSplit(n_splits=5, test_size=0.3, random_state=17)\nmodel_rf = RandomForestClassifier(n_estimators=100, n_jobs=4,\n                                   min_samples_leaf=3, random_state=17)","5db2ec1d":"X_initial = train_initial.values\nX_extracted = train_extracted[[x for x in list(train_extracted.columns) if x not in list(train_extracted.filter(like = 'item').columns)]].values\ny = target['radiant_win'].values","7964021a":"%%time\ncv_scores_rf_initial = cross_val_score(model_rf, X_initial, y, cv=cv, \n                                scoring='roc_auc', n_jobs=-1)","9c49f9c0":"%%time\ncv_scores_rf_extracted = cross_val_score(model_rf, X_extracted, y, cv=cv, \n                                scoring='roc_auc', n_jobs=-1)","ffb154d4":"# That's perfectly results of yorko's initial RF model\ncv_scores_rf_initial","3123c088":"cv_scores_rf_extracted","01017199":"cv_scores_rf_extracted > cv_scores_rf_initial","39b26068":"Let's see which features were added comparing to initial dataset, created by organizers.","6b8cc827":"# <center> Dota 2 winner prediction competition\n\n##### <center> By Artur Kolishenko (@payonear)\n     \n<center> <img src='https:\/\/whyigame.files.wordpress.com\/2015\/05\/dota2header.jpg?w=1163&h=364&crop=1.jpeg'>\n","4f580bcf":"## Save dataset\nLet's save our datasets to pickle format to use it easily in future.","67211aee":"### Structure\n1. [Data description](#Data-description)\n2. [Data extraction of selected features](#Data-extraction-of-selected-features)\n3. [Save dataset](#Save-dataset)\n4. [RF model comparing to initial datasets](#RF-model-comparing-to-initial-datasets)","03f68151":"## Data extraction of selected features\nIn this kernel extraction of some useful features presented. The base code for data extraction was taken from Yorko's starter kernel. [DOTA 2 win prediction - Random Forest starter](https:\/\/www.kaggle.com\/kashnitsky\/dota-2-win-prediction-random-forest-starter).","23129814":"Not bad for the beginning, especially considering the fact, that results presented are before features preprocessing. It's just raw data set. To see next step with EDA and FE visit another my kernel: [EDA with Gini coefficient & FE on extended dataset](https:\/\/www.kaggle.com\/karthur10\/eda-with-gini-coefficient-fe-on-extended-dataset). If it was useful please upvote.**","a6bd37b8":"As can be seen items contain list of all player's purchases. This features will be useful in the future after processing. By now it's proposed to ignore them to not spoil analysis.","9e936c9c":"## RF model comparing to initial datasets\nLet's try to build RF model to see whether any progress in score appears because of additional features.","d9676220":"## Data description\n\nWe have the following files:\n\n- `train_matches.jsonl`, `test_matches.jsonl`: full \"raw\" training data \n- `train_features.csv`, `test_features.csv`: features created by organizers\n- `train_targets.csv`: results of training games (including the winner)"}}