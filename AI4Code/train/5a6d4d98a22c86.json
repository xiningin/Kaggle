{"cell_type":{"cf8b01cb":"code","34b353c0":"code","a7f1e9fc":"code","76d60f1f":"code","328f5899":"code","012c4568":"code","e5137e6e":"code","cc8c1b0d":"code","50fa3b3b":"code","032a29c3":"code","d3ccb75d":"code","7355e46f":"code","57e4ea4a":"code","696e819f":"code","6de7a571":"code","162cdf4f":"code","ec396c23":"code","2646da0e":"code","9fbc903b":"code","4c9b6ae8":"code","a1054020":"code","c1dfc94b":"code","75366656":"code","140c801b":"code","1f5d5a01":"code","14f76332":"code","74efdad6":"code","c2dcc114":"code","9d90eaeb":"code","783b02bd":"code","91ec026a":"code","839318ed":"code","dc32006f":"code","6e26ff05":"code","a4f3c613":"code","eef9254e":"code","da94751c":"code","6335c813":"code","3e53839e":"code","5ab8ce6b":"code","0a80c1ed":"code","dc3b6c86":"code","da1a746b":"code","8ffc7bc2":"code","bf561f06":"code","580e36b9":"code","c055484b":"code","96b6a2c3":"code","8012e4d2":"code","faa24d32":"code","b06c0685":"code","86fe5e69":"code","82b25d8e":"code","03170abe":"code","737ec8fa":"code","7461bcd2":"code","66b43879":"code","9a8fa5a4":"code","889f700a":"code","2ba39a4c":"code","1f329dee":"code","cdedac88":"code","2f702166":"code","a9945591":"code","ec42ffc0":"code","4188bd07":"code","2e0125c0":"code","e2e61313":"code","aa8d5926":"code","25362b96":"code","763ed8b8":"code","e1250195":"code","f8273332":"code","e5815c35":"code","d1615a87":"code","0b84080f":"code","2b4c591a":"code","fd122971":"code","3c8727c9":"code","0c569cac":"code","13d4daf7":"code","246eae00":"code","ce9d1d2d":"code","6addec8b":"code","977e6c4a":"code","5a52f6c8":"code","2cde0906":"code","9ac10a02":"code","b2a61b09":"code","47ad71a0":"code","d344f83a":"code","a31a3e33":"code","b848bba3":"code","689eac90":"code","c3af5054":"code","7c117062":"code","44b70d67":"code","aa11e1b4":"code","b69a779f":"code","ee4ef3d8":"code","e29a35c7":"code","5bd0d3ed":"code","e3204c99":"code","a2a174a2":"code","350981b0":"code","097dbfa0":"code","a80b0b05":"code","55266ad8":"code","9f50364c":"code","ce0398a7":"code","5af69911":"code","765cbffc":"code","398825e0":"markdown","fbdc6fe5":"markdown","cb4b8ba9":"markdown","bf42c559":"markdown","ed361fd4":"markdown","e4a7389d":"markdown","a3aeabc2":"markdown","fd7e7d4c":"markdown","8129c35d":"markdown","cafac326":"markdown","287252e8":"markdown","b8a02add":"markdown","bf547922":"markdown","36da4b99":"markdown","1768d5e8":"markdown","4dbedc53":"markdown","42e33a6b":"markdown","f4f596cb":"markdown","78830e09":"markdown","3bc96b2b":"markdown","58e91378":"markdown","c8d27aa7":"markdown","c983e994":"markdown","1abbb2db":"markdown","b61385ab":"markdown","819830b4":"markdown","eb4d63cb":"markdown","29d31143":"markdown","2cc5ec15":"markdown","f2906f4d":"markdown","46946c12":"markdown","d8a0ed3d":"markdown","a07923c3":"markdown","b69d6fee":"markdown","6db1d168":"markdown","56ee9210":"markdown","b02b12e7":"markdown","4fa850e1":"markdown","4522c179":"markdown","434d4720":"markdown","eef215c1":"markdown","31e9de09":"markdown","05994a97":"markdown","205f7663":"markdown","fadd676d":"markdown","d78ca6fe":"markdown","5e59010e":"markdown","7e8313ed":"markdown","9fefb30e":"markdown","721180b9":"markdown","702ee0c5":"markdown","15707854":"markdown","eb7eb0a3":"markdown","629356f3":"markdown","35f53106":"markdown","ed19fd96":"markdown","16810b6e":"markdown","f19e6282":"markdown","576cd08b":"markdown","be9c443c":"markdown","c796669b":"markdown","52d882a5":"markdown","f4f01804":"markdown","11a50568":"markdown","ec2e7e43":"markdown","5aef667e":"markdown","401e57c1":"markdown","edf17283":"markdown","2de10afb":"markdown","26a0cf82":"markdown","67c8e6b5":"markdown","88e2bddb":"markdown","a57dfd9d":"markdown","b719223c":"markdown","65878e96":"markdown","400648fd":"markdown","3ffbde91":"markdown","e1ff0508":"markdown","bc2b9863":"markdown"},"source":{"cf8b01cb":"import seaborn as sns\nimport matplotlib.pyplot as plt\nplt.style.use('fivethirtyeight')\nimport pandas as pd\nfrom datetime import datetime\nimport numpy as np\nfrom matplotlib import rcParams\nimport statsmodels.api as sm\nfrom statsmodels.tsa.stattools import adfuller\nimport plotly.express as px\nfrom mplfinance.original_flavor import candlestick_ohlc\nimport ta\nfrom matplotlib.pylab import date2num\n%matplotlib inline\npd.options.display.max_columns = None\nimport warnings\nwarnings.filterwarnings(\"ignore\")","34b353c0":"# Check data\npath ='..\/input\/nifty-per-minute-data-2008-20111212\/nifty2012.txt'\ndf = pd.read_csv(path, sep='\\t', delimiter = \",\", header=None)\ndf.columns = ['Symbol', 'Date','Time', 'Open', 'High','Low','Close']\ndf['Datetime'] = pd.to_datetime(df['Date'].apply(str)+' '+df['Time'])\ndf.index= df.Datetime\ndf.drop(['Date','Time','Datetime'],axis=1,inplace=True)\ndf.head()","a7f1e9fc":"def load_data(path):\n    df = pd.read_csv(path, sep='\\t', delimiter = \",\", header=None)\n    df.columns = ['Symbol', 'Date','Time', 'Open', 'High','Low','Close']\n    df['Datetime'] = pd.to_datetime(df['Date'].apply(str)+' '+df['Time'])\n    df.index= df.Datetime\n    df.drop(['Symbol','Date','Time','Datetime'],axis=1,inplace=True)\n    return df\ndef load_data2(path):\n    df = pd.read_csv(path, sep='\\t', delimiter = \",\", header=None)\n    df.columns = ['Symbol', 'Date','Time', 'Open', 'High','Low','Close','OI']\n    df['Datetime'] = pd.to_datetime(df['Date'].apply(str)+' '+df['Time'])\n    df.index= df.Datetime\n    df.drop(['Symbol','Date','Time','Datetime','OI'],axis=1,inplace=True)\n    return df\ndef load_data3(path):\n    df = pd.read_csv(path, sep='\\t', delimiter = \",\", header=None)\n    df.columns = ['Symbol', 'Date','Time', 'Open', 'High','Low','Close','Volume','OI']\n    df['Datetime'] = pd.to_datetime(df['Date'].apply(str)+' '+df['Time'])\n    df.index= df.Datetime\n    df.drop(['Symbol','Date','Time','Datetime','OI','Volume'],axis=1,inplace=True)\n    return df\n\npath2008 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty08-10.txt'\nnifty08_10 = load_data(path2008)\n\npath2011 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2011.txt'\nnifty_2011 = load_data(path2011)\npath2012 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2012.txt'\nnifty_2012 = load_data(path2012)\n\npath2013 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2013.txt'\nnifty_2013 = load_data(path2013)\npath2_2013 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2_2013.txt'\nnifty2_2013 = load_data2(path2_2013)\n\npath2014 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2014.txt'\nnifty_2014 = load_data2(path2014)\n\npath2015 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2015.txt'\nnifty2_2015 = load_data(path2015)  #month from march\npath2_2015 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2_2015.txt'\nnifty_2015 = load_data2(path2_2015) #from jan\npath3_2015 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty3_2015.txt'\nnifty3_2015 = load_data3(path3_2015)    #last months\n\npath2016 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2016.txt'\nnifty_2016 = load_data3(path2016)    #jan to july\npath2_2016 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2_2016.txt'\nnifty2_2016 = load_data(path2_2016)    #july to december\n\npath2017 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2017.txt'\nnifty_2017 = load_data2(path2017)\n\npath2018 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2018.txt'\nnifty_2018 = load_data2(path2018)\npath2_2018 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2_2018.txt'\nnifty2_2018 = load_data3(path2_2018)\n\npath2019 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2019.txt'\nnifty_2019 = load_data3(path2019)\n\npath2020 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2020.txt'\nnifty_2020 = load_data3(path2020)\n\npath2021 = '..\/input\/nifty-per-minute-data-2008-20111212\/nifty2021.txt'\nnifty_2021 = load_data3(path2021)","76d60f1f":"all = ['nifty08_10','nifty_2011','nifty_2012','nifty_2013','nifty2_2013','nifty_2014','nifty2_2015',\n       'nifty_2015','nifty3_2015','nifty_2016','nifty2_2016','nifty_2017','nifty_2018',\n       'nifty2_2018','nifty_2019','nifty_2020','nifty_2021']\nnifty_2011 = nifty08_10.append(nifty_2011)\ndata22 = nifty_2011.append(nifty_2012)\ndata22 = data22.append(nifty_2013)\ndata22 = data22.append(nifty2_2013)\ndata22 = data22.append(nifty_2014)\ndata22 = data22.append(nifty2_2015)\ndata22 = data22.append(nifty_2015)\ndata22 = data22.append(nifty3_2015)\ndata22 = data22.append(nifty_2016)\ndata22 = data22.append(nifty_2017)\ndata22 = data22.append(nifty_2018)\ndata22 = data22.append(nifty2_2018)\ndata22 = data22.append(nifty_2019)\ndata22 = data22.append(nifty_2020)\ndata22 = data22.append(nifty_2021)\nnifty_data = data22.copy()\nnifty_data.head(2)","328f5899":"nifty_data.tail(2)","012c4568":"def OHLC_resample(df,freq):\n    sample = df.copy()\n    d = pd.DataFrame(index = sample.resample(freq).last().dropna().index)\n    d[\"Open\"] = sample.resample(freq).first().dropna().Open\n    d[\"High\"] = sample.resample(freq).max().dropna().High\n    d[\"Low\"] = sample.resample(freq).min().dropna().Low\n    d[\"Close\"] = sample.resample(freq).last().dropna().Close\n    return d\n\ndf = OHLC_resample(nifty_data,freq='15min')\ndf.head()","e5137e6e":"# 15min sample will save us a lot of memory rather than 1min samples.\nnifty_data.info(), df.info()","cc8c1b0d":"# Let's downsample the datatypes from float64 to float32 to save some memory and faster operations.\ndef downcast(df):\n    float_cols = [c for c in df if df[c].dtype == \"float64\"]\n    df[float_cols] = df[float_cols].astype(np.float32)\n    return df\n\ndf = downcast(df)\nprint(df.info())","50fa3b3b":"df.loc['2010':'2021'].plot(figsize=(20,9))\nplt.title('Nifty Movement')","032a29c3":"plt.figure(figsize=(16,8))\ndf.Low.loc['2012'].plot()\nplt.title('Nifty Movement')","d3ccb75d":"df2 =df.loc['2012-10']\ny = df2['Low']\nsize= len(y)\nremoved_outliers = y.between(y.quantile(.008), y.quantile(.992))\n\nprint(str(y[removed_outliers].size) + \"\/\" + str(size) + \" data points remain.\") \n\ny[removed_outliers].plot()","7355e46f":"df['Low'].loc['2012-10'] = y[removed_outliers]","57e4ea4a":"df3 =df.loc['2012-10']\ny = df3['Open']\nsize= len(y)\nremoved_outliers = y.between(y.quantile(.008), y.quantile(.992))\n\nprint(str(y[removed_outliers].size) + \"\/\" + str(size) + \" data points remain.\") \n\ny[removed_outliers].plot()","696e819f":"df['Open'].loc['2012-10'] = y[removed_outliers]","6de7a571":"plt.figure(figsize=(16,8))\ndf.Open.loc['2012'].plot()\nplt.title('Nifty Movement')","162cdf4f":"# 27 observations for 1 day when we resample the data for 15min frame.\ndef bollinger_band(df):\n    \n    df1 = df.Close.to_frame()\n    df[\"ma7\"] = df1.iloc[:,0].rolling(189).mean()       # 7 days moving average\n    df['ma30'] = df1.iloc[:,0].rolling(810).mean()      # 30 days moving average\n    df1[\"std7\"] = df1.iloc[:,0].rolling(189).std()       # 7 days standard deviation\n    df1[\"std30\"] = df1.iloc[:,0].rolling(810).std()       # 30 days standard deviation\n    \n    df[\"upper_band7\"] = df.ma7 + (df1.std7 * 2) \n    df[\"lower_band7\"] = df.ma7 - (df1.std7 * 2) \n    df[\"upper_band30\"] = df.ma30 + (df1.std30 * 2) \n    df[\"lower_band30\"] = df.ma30 - (df1.std30 * 2) \n    return df","ec396c23":"df = bollinger_band(df)\ndf.head(3)","2646da0e":"def macd(df,\n         fast,\n         slow,\n         signal):\n    \n    df1 = df.Close.to_frame()\n    df[\"ema_fast\"] = df1.iloc[:,0].ewm(span=fast,min_periods=fast).mean()   #12 days\n    df[\"ema_slow\"] = df1.iloc[:,0].ewm(span=slow,min_periods=slow).mean()   #26 days\n    df[\"macd\"] = df.ema_fast - df.ema_slow\n    df[\"signal\"] = df[\"macd\"].ewm(span=signal,min_periods=signal).mean()   #9 days\n    \n    return df\ndf = macd(df,324, 702, 243)   #27 observations in a day, so 324 for 12 days, 702 for 26days, 243 for 9 days.","9fbc903b":"from ta.momentum import AwesomeOscillatorIndicator,KAMAIndicator, ROCIndicator,RSIIndicator,StochRSIIndicator, TSIIndicator, WilliamsRIndicator\n","4c9b6ae8":"#135 for 5 days, 908 for 34 days\nsample = AwesomeOscillatorIndicator(df.High, df.Low, 135, 908, False)\ndf['AOI'] = sample.awesome_oscillator()\n#sample2 = AwesomeOscillatorIndicator(df.High, df.Low, 5, 34, False)\n#data['AOI2'] = sample2.awesome_oscillator()\n","a1054020":"sample = KAMAIndicator(df.Close, 10, 10, 30, False)   #10 days \ndf['KAMA_FAST'] = sample.kama()\nsample2 = KAMAIndicator(df.Close, 10, 50, 30 , False)   # 50 days\ndf['KAMA_SLOW'] = sample2.kama()","c1dfc94b":"sample = ROCIndicator(df.Close, 324, False)  #12*27 =324 12days  \ndf['ROC'] = sample.roc()","75366656":"sample = RSIIndicator(df.Close, 14, False)  # 14days relative strength index \ndf['RSI'] = sample.rsi()","140c801b":"sample = StochRSIIndicator(df.Close, 378,81,81, False)  #window 14days , smooth_window 3days\ndf['STOCH_RSI'] = sample.stochrsi()\ndf['STOCH_RSI3'] = sample.stochrsi_k()\nsample2 = StochRSIIndicator(df.Close, 378, 270, 270, False)\ndf['STOCH_RSI10'] = sample2.stochrsi_k()","1f5d5a01":"sample = TSIIndicator(df.Close, 675,351, False)  \ndf['TSI_SLOW'] = sample.tsi()\nsample2 = TSIIndicator(df.Close, 25,13, False)  \ndf['TSI_FAST'] = sample2.tsi()\n","14f76332":"sample = WilliamsRIndicator(df.High, df.Low, df.Close, 378, False)  #14days\ndf['WRI_SLOW'] = sample.williams_r()\nsample2 = WilliamsRIndicator(df.High, df.Low, df.Close, 14, False)  #14days\ndf['WRI_FAST'] = sample2.williams_r()\ndf.sample(2)","74efdad6":"from ta.volatility import AverageTrueRange, DonchianChannel","c2dcc114":"sample = AverageTrueRange(df.High, df.Low, df.Close, 378, False)  #14days\ndf['ATR'] = sample.average_true_range()\nsample2 = AverageTrueRange(df.High, df.Low, df.Close, 14, False)  #14days\ndf['ATR2'] = sample2.average_true_range()","9d90eaeb":"sample = DonchianChannel(df.High, df.Low, df.Close, 540,0, False)  #window 20 days\ndf['DC_HB'] = sample.donchian_channel_hband()   # DC High Band\ndf['DC_LB'] = sample.donchian_channel_lband()   # DC Low Band\ndf['DC_MB'] = sample.donchian_channel_mband()   # DC Middle Band\ndf.sample(2)","783b02bd":"from ta.trend import AroonIndicator, ADXIndicator","91ec026a":"sample = AroonIndicator(df.Close, 675, False)  #25days\ndf['AI_D'] = sample.aroon_down()\ndf['AI_I'] = sample.aroon_indicator()\ndf['AI_U'] = sample.aroon_up()\ndf.sample(2)","839318ed":"df = downcast(df)  #all datatypes to float32\ndf.dropna(inplace=True)","dc32006f":"df.RSI.loc['2016'].plot(figsize = (20,7))\n\nupper_thresh = 80\nlower_thresh = 20\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\n\nplt.title(\"RSI calculated on NIFTY Close prices\")\nplt.ylabel(\"RSI value\")\nplt.xlabel(\"date\")\nplt.show()","6e26ff05":"df[['Close','ma7','upper_band7','lower_band7']].loc['2017-01':'2017-02'].plot(figsize=(22,10))\nplt.title(\"Bollinger Bands on NIFTY Close prices(7 days)\", fontsize=20)\nplt.ylabel(\"Nifty Price\", fontsize=18)\nplt.xlabel(\"Date\", fontsize=18)\nplt.show()","a4f3c613":"df[['Close','ma30','upper_band30','lower_band30']].loc['2018'].plot(figsize=(22,10))\nplt.title(\"Bollinger Bands on NIFTY Close prices(30 days)\", fontsize=20)\nplt.ylabel(\"Nifty Price\", fontsize=18)\nplt.xlabel(\"Date\", fontsize=18)\nplt.show()","eef9254e":"fig = plt.figure(figsize = (18,10))\nax1, ax2 = fig.subplots(2, 1)\nax1.plot(df.loc['2013'][['macd','signal']])\nax2.plot(df.Close.loc['2013'])","da94751c":"df.AOI.loc['2012':'2016'].plot(figsize=(16,8))\nupper_thresh = 300\nlower_thresh = -200\nzero_cross = 0\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(zero_cross, 0, 1,c = \"black\",linestyle='--')\nplt.title(\"AOI vs NIFTY Close prices\", fontsize=20)\nplt.show()","6335c813":"data = df[['Open', 'High','Low','Close','KAMA_FAST','KAMA_SLOW']].loc['2018-02':'2018-08'].copy()\nfig = plt.figure(figsize=(22,16))\nax_candle = fig.add_axes((0, 0.72, 1, 0.32))\nax_candle.xaxis_date()\nohlc = []\nfor date, row in data.iterrows():\n    openp, highp, lowp, closep = row[:4]\n    ohlc.append([date2num(date), openp, highp, lowp, closep])\n    \nax_candle.plot(data.index, data[\"KAMA_FAST\"], label=\"KAMA Fast(10days)\")\nax_candle.plot(data.index, data[\"KAMA_SLOW\"], label=\"KAMA Slow(50days)\")\ncandlestick_ohlc(ax_candle, ohlc, colorup=\"g\", colordown=\"r\", width=0.8)\nax_candle.legend()","3e53839e":"df.ROC.loc['2013':'2014'].plot(figsize=(16,7))\nupper_thresh = 6\nlower_thresh = -5\nzero_cross = 0\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(zero_cross, 0, 1,c = \"black\",linestyle='--')\nplt.show()","5ab8ce6b":"df[['STOCH_RSI']].loc['2013'].plot(figsize=(15,6))\nupper_thresh = 0.8\nlower_thresh = 0.2\n\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.show()","0a80c1ed":"df[['STOCH_RSI3']].loc['2013'].plot(figsize=(15,6))\nupper_thresh = 0.8\nlower_thresh = 0.2\n\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.show()","dc3b6c86":"df[['STOCH_RSI10']].loc['2013'].plot(figsize=(15,6))\nupper_thresh = 0.8\nlower_thresh = 0.2\n\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.show()","da1a746b":"df[['TSI_SLOW']].plot(figsize=(16,7))\nupper_thresh = 9\nlower_thresh = -6\n\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.show()","8ffc7bc2":"df['TSI_FAST'].loc['2016'].plot(figsize=(16,7))\nupper_thresh = 40\nlower_thresh = -40\n\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.show()","bf561f06":"df[['WRI_SLOW']].loc['2017':'2018'].plot(figsize=(16,7))\nupper_thresh = -20\nlower_thresh = -80\n\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.show()","580e36b9":"df[['WRI_FAST']].loc['2017-01':'2017-02'].plot(figsize=(16,7))\nupper_thresh = -20\nlower_thresh = -80\n\n\nplt.axhline(upper_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.axhline(lower_thresh, 0, 1,c = \"red\",linestyle='--')\nplt.show()","c055484b":"fig = plt.figure(figsize = (18,12))\nax1, ax2, ax3 = fig.subplots(3, 1)\nax1.plot(df.loc['2013'][['ATR']])\nax2.plot(df.loc['2013'][['ATR2']])\nax3.plot(df.Close.loc['2013'])","96b6a2c3":"data = df.loc['2017-01':'2017-05'].copy()","8012e4d2":"fig = plt.figure(figsize=(22,18))\nax_candle = fig.add_axes((0, 0.72, 1, 0.32))\nax_candle.xaxis_date()\nohlc = []\nfor date, row in data.iterrows():\n    openp, highp, lowp, closep = row[:4]\n    ohlc.append([date2num(date), openp, highp, lowp, closep])\n    \nax_candle.plot(data.index, data[\"DC_LB\"], label=\"DC Lower Band\")\nax_candle.plot(data.index, data[\"DC_HB\"], label=\"DC Higher Band\")\nax_candle.plot(data.index, data[\"ma30\"], label=\"Moving Average 30days\")\ncandlestick_ohlc(ax_candle, ohlc, colorup=\"g\", colordown=\"r\", width=0.8)\nax_candle.legend()","faa24d32":"fig = plt.figure(figsize=(22,18))\nax_candle = fig.add_axes((0, 0.72, 1, 0.32))\nax_aroon = fig.add_axes((0, 0.48, 1, 0.2), sharex=ax_candle)\n    \n# Format x-axis ticks as dates\nax_candle.xaxis_date()\n    \n# Get nested list of date, open, high, low and close prices\nohlc = []\nfor date, row in data.iterrows():\n    openp, highp, lowp, closep = row[:4]\n    ohlc.append([date2num(date), openp, highp, lowp, closep])\n \n # Plot candlestick chart\nax_candle.plot(data.index, data[\"ma30\"], label=\"MA30\")\ncandlestick_ohlc(ax_candle, ohlc, colorup=\"g\", colordown=\"r\", width=0.8)\nax_candle.legend()\n    \n# Plot Aroon\nax_aroon.plot(data.index, data[\"AI_U\"], label=\"Aroon Up\")\nax_aroon.plot(data.index, data[\"AI_D\"], label=\"Aroon Down\")\nax_aroon.legend()","b06c0685":"\ndef plot_chart(data, n):\n    \n    # Filter number of observations to plot\n    data = data.iloc[-n:]\n    \n    # Create figure and set axes for subplots\n    fig = plt.figure()\n    fig.set_size_inches((20, 16))\n    ax_candle = fig.add_axes((0, 0.72, 1, 0.32))\n    ax_macd = fig.add_axes((0, 0.48, 1, 0.2), sharex=ax_candle)\n    ax_rsi = fig.add_axes((0, 0.24, 1, 0.2), sharex=ax_candle)\n    \n    # Format x-axis ticks as dates\n    ax_candle.xaxis_date()\n    \n    # Get nested list of date, open, high, low and close prices\n    ohlc = []\n    for date, row in data.iterrows():\n        openp, highp, lowp, closep = row[:4]\n        ohlc.append([date2num(date), openp, highp, lowp, closep])\n \n    # Plot candlestick chart\n    ax_candle.plot(data.index, data[\"ma7\"], label=\"MA7\")\n    ax_candle.plot(data.index, data[\"ma30\"], label=\"MA30\")\n    candlestick_ohlc(ax_candle, ohlc, colorup=\"g\", colordown=\"r\", width=0.8)\n    ax_candle.legend()\n    \n    # Plot MACD\n    ax_macd.plot(data.index, data[\"macd\"], label=\"macd\")\n    #ax_macd.bar(data.index, data[\"macd_hist\"] * 3, label=\"hist\")\n    ax_macd.plot(data.index, data[\"signal\"], label=\"signal\")\n    ax_macd.legend()\n    \n    # Plot RSI\n    # Above 70% = overbought, below 30% = oversold\n    ax_rsi.set_ylabel(\"(%)\")\n    ax_rsi.plot(data.index, [70] * len(data.index), label=\"overbought\")\n    ax_rsi.plot(data.index, [30] * len(data.index), label=\"oversold\")\n    ax_rsi.plot(data.index, data[\"RSI\"], label=\"rsi\")\n    ax_rsi.legend()\n    \n    plt.show()","86fe5e69":"def Indicators_resample(df,freq):\n    sample = df.copy()\n    d = pd.DataFrame(index = sample.resample(freq).last().dropna().index)\n    d[\"Open\"] = sample.resample(freq).first().dropna().Open\n    d[\"High\"] = sample.resample(freq).max().dropna().High\n    d[\"Low\"] = sample.resample(freq).min().dropna().Low\n    d[\"Close\"] = sample.resample(freq).last().dropna().Close\n    d[\"macd\"] = sample.resample(freq).last().dropna().macd\n    d[\"RSI\"] = sample.resample(freq).last().dropna().RSI\n    d[\"signal\"] = sample.resample(freq).last().dropna().signal\n    d[\"ma7\"] = sample.resample(freq).last().dropna().ma7\n    d[\"ma30\"] = sample.resample(freq).last().dropna().ma30\n    return d\ndaily = Indicators_resample(df,'1D')\nplot_chart(daily, 200)","82b25d8e":"df_1day = OHLC_resample(nifty_data,freq='D')\ndf.to_csv('features_15min.csv')\ndf_1day.to_csv('features_daily.csv')","03170abe":"def RSI_backtest(df, rsi_long_start, rsi_short_start):\n    sample = df.copy()\n    \n    # constant variables \n    entry_time = []\n    exit_time = []\n    trade_side = []\n    rsi_value = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    # temp variables\n    trade_taken = False\n    target = 0\n    stop = 0\n\n    for index,datetime in enumerate(sample.index):\n        # current data variables \n        current_datetime = datetime\n        rsi = sample.iloc[index].loc[\"RSI\"]\n        close = sample.iloc[index].loc['Close']\n        upper_band30 = sample.iloc[index].loc['upper_band30']\n        lower_band30 = sample.iloc[index].loc['lower_band30']\n        \n        # if any trade is not taken and rsi value is between your set RSI levels, dont look for new trades \n        if (rsi > rsi_long_start) and (rsi < rsi_short_start) and (trade_taken == False):\n            continue\n            \n        elif ((rsi >= rsi_short_start) and (trade_taken == False)):  # cheking for fresh short trade stop\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n            \n            entry_time.append(current_datetime)  # appending trade details\n            rsi_value.append(rsi)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):    # cheking for short trade stop\n\n            trade_taken = False\n            exit_time.append(current_datetime)   # appending trade details\n            exit_price.append(close)\n\n        elif (trade_taken == \"short_entered\") and (close < short_target):  # cheking for short trade target \n\n            trade_taken = False\n            exit_time.append(current_datetime)   # appending trade details\n            exit_price.append(close)\n\n        elif ((rsi < rsi_long_start) and (trade_taken == False)):     # cheking for fresh long trade \n\n            trade_taken = \"long_entered\"\n            long_target = close*1.06\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)    # appending trade details\n            rsi_value.append(rsi)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close < long_stop):   # checking for long trade stop \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n        \n        elif (trade_taken == \"long_entered\") and (close > long_target):         # checking for long trade target \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n\n        # if last data entry and we are still holding a trade then sqaure off the trade \n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n        \n        \n    # creating a trade sheet out of all recorded trades details \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"rsi_value\":rsi_value,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    trade_sheet[\"pnl\"] = 0   # calculating pnl from trade sheet\n\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]\n    return trade_sheet","737ec8fa":"data = df.loc['2011':'2018'].copy()\ndata.dropna(inplace=True)\nrsi_test = RSI_backtest(data, 15, 90)","7461bcd2":"rsi_test.sample(5)","66b43879":"rsi_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(16,8))\nplt.title(\"Nifty Trades Profits with RSI Indicator\")\nplt.show()","9a8fa5a4":"def MACD_backtest(df):\n    \n    sample = df.copy()\n    \n    # constant variables \n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n\n    target_price = []\n    stop_price = []\n\n    # temp variables\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    # running backtest only on test data \n    for index,datetime in enumerate(sample.index):\n\n\n        # current data variables \n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        macd = sample.iloc[index].loc[\"macd\"]\n        signal = sample.iloc[index].loc[\"signal\"]\n        ma30 = sample.iloc[index].loc['ma30']\n        \n        # if any trade is not taken and adf value not below a desired thresh dont look for new trades \n        #if (clo > thresh) and (trade_taken == False):\n          #  continue\n\n\n        # cheking for fresh short trade stop\n        if ((macd < signal) and (trade_taken == False)):\n\n            trade_taken = \"short_entered\"\n            short_target = close*0.96\n            short_stop = close*1.02\n\n            # appending trade details\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n\n\n        # cheking for short trade stop\n        elif (trade_taken == \"short_entered\") and ((macd > signal) or (close < short_target)):\n\n            trade_taken = False\n\n            # appending trade details\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n\n        # cheking for short trade target \n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n\n            trade_taken = False\n\n            # appending trade details\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n\n        # cheking for fresh long trade \n        elif ((macd >= signal) and (trade_taken == False)):\n\n            trade_taken = \"long_entered\"\n            long_target = close*1.04\n            long_stop = close*0.98\n\n            # appending trade details\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n\n        # checking for long trade stop \n        elif (trade_taken == \"long_entered\") and ((macd < signal) or (close > long_target)): \n\n            trade_taken = False\n\n            # appending trade details\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n\n        # checking for long trade target \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n\n            trade_taken = False\n\n            # appending trade details\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n\n\n\n        # if last data entry and we are still holding a trade then sqaure off the trade \n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n\n            trade_taken = False\n\n            # appending trade details\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n    \n    # creating a trade sheet out of all recorded trades details \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    \n   \n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]\n    \n    return trade_sheet","889f700a":"data = df.loc['2017':'2021'].copy()\ndata.dropna(inplace=True)\nmacd_test = MACD_backtest(data)","2ba39a4c":"macd_test.sample(5)","1f329dee":"macd_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades Profits with MACD Indicator\")\nplt.show()","cdedac88":"def AOI_backtest(df,upper_thresh,lower_thresh):\n    sample = df.copy()\n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        AOI = sample.iloc[index].loc[\"AOI\"]\n        \n        if (AOI > lower_thresh) and (AOI < upper_thresh) and (trade_taken == False):\n            continue\n            \n        if ((upper_thresh < AOI) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and (close < short_target):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif ((lower_thresh >= AOI) and (trade_taken == False)):\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close > long_target): \n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n    \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]    \n    return trade_sheet","2f702166":"data = df.loc['2013':'2020'].copy()\ndata.dropna(inplace=True)\nAOI_test = AOI_backtest(data,300,-200)","a9945591":"AOI_test.sample(5)","ec42ffc0":"AOI_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with AOI Indicator\")\nplt.show()","4188bd07":"def KAMA_backtest(df):\n    sample = df.copy()\n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        KAMA_FAST = sample.iloc[index].loc[\"KAMA_FAST\"]\n        KAMA_SLOW = sample.iloc[index].loc['KAMA_SLOW']\n        \n       # if (AOI > lower_thresh) and (AOI < upper_thresh) and (trade_taken == False):\n       #     continue\n            \n        if ((KAMA_FAST < KAMA_SLOW) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and (close < short_target):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif ((KAMA_FAST >= KAMA_SLOW) and (trade_taken == False)):\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.98\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close > long_target): \n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n    \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]    \n    return trade_sheet","2e0125c0":"data = df.loc['2016':'2021'].copy()\ndata.dropna(inplace=True)\nKAMA_test = KAMA_backtest(data)","e2e61313":"KAMA_test.sample(5)","aa8d5926":"KAMA_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with KAMA Indicator\")\nplt.show()","25362b96":"def ROC_backtest(df,upper_thresh,lower_thresh):\n    sample = df.copy()\n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        ROC = sample.iloc[index].loc[\"ROC\"]\n        \n        if (ROC > lower_thresh) and (ROC < upper_thresh) and (trade_taken == False):\n            continue\n            \n        if ((upper_thresh < ROC) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and (close < short_target):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif ((lower_thresh >= ROC) and (trade_taken == False)):\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close > long_target): \n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n    \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]    \n    return trade_sheet","763ed8b8":"data = df.loc['2010':'2021'].copy()\ndata.dropna(inplace=True)\nROC_test = ROC_backtest(data,7,-5.5)","e1250195":"ROC_test.sample(5)","f8273332":"ROC_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with ROC Indicator\")\nplt.show()","e5815c35":"def Stoch_backtest(df,upper_thresh,lower_thresh,stoch):\n    sample = df.copy()\n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        SRSI = sample.iloc[index].loc[stoch]\n        \n        if (SRSI > lower_thresh) and (SRSI < upper_thresh) and (trade_taken == False):\n            continue\n            \n        if ((upper_thresh < SRSI) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and (close < short_target):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif ((lower_thresh >= SRSI) and (trade_taken == False)):\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close > long_target): \n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n    \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]    \n    return trade_sheet","d1615a87":"data = df.loc['2010':'2021'].copy()\ndata.dropna(inplace=True)\nStoch3_test = Stoch_backtest(data,0.8,0.2,'STOCH_RSI3')","0b84080f":"Stoch3_test.sample(5)","2b4c591a":"Stoch3_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with Stoch RSI\")\nplt.show()","fd122971":"data = df.loc['2010':'2021'].copy()\ndata.dropna(inplace=True)\nStoch10_test = Stoch_backtest(data,0.8,0.2,'STOCH_RSI10')\nStoch10_test.sample(5)","3c8727c9":"Stoch10_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with Stoch RSI(slow)\")\nplt.show()","0c569cac":"def WRI_backtest(df,upper_thresh,lower_thresh,wri):\n    sample = df.copy()\n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        WRI = sample.iloc[index].loc[wri]\n        \n        if (WRI > lower_thresh) and (WRI < upper_thresh) and (trade_taken == False):\n            continue\n            \n        if ((upper_thresh < WRI) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and (close < short_target):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif ((lower_thresh >= WRI) and (trade_taken == False)):\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close > long_target): \n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n    \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]    \n    return trade_sheet","13d4daf7":"data = df.loc['2010':'2021'].copy()\ndata.dropna(inplace=True)\nwri_fast_test = WRI_backtest(data,-20,-80,'WRI_FAST')\nwri_fast_test.sample(5)","246eae00":"wri_fast_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with Williams R (Fast)\")\nplt.show()","ce9d1d2d":"wri_slow_test = WRI_backtest(data,-20,-80,'WRI_SLOW')\nwri_slow_test.sample(5)","6addec8b":"wri_slow_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with Williams R (Slow) \")\nplt.show()","977e6c4a":"def ATR_backtest(df,atr):\n    sample = df.copy()\n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        ATR = sample.iloc[index].loc[atr]\n            \n        if ((ATR >= close) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and (close < short_target):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif ((ATR < close) and (trade_taken == False)):\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close > long_target): \n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n    \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]    \n    return trade_sheet","5a52f6c8":"atr_test = ATR_backtest(data,'ATR')\natr_test.sample(5)","2cde0906":"atr_test.set_index(\"entry_time\").pnl.resample(\"M\").sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with (Average True Range)\")\nplt.show()","9ac10a02":"def Aroon_backtest(df):\n    sample = df.copy()\n    entry_time = []\n    exit_time = []\n\n    trade_side = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    trade_taken = False\n    target = 0\n    stop = 0\n    \n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        close = sample.iloc[index].loc[\"Close\"]\n        aroon_up = sample.iloc[index].loc['AI_U']\n        aroon_down = sample.iloc[index].loc['AI_D']\n            \n        if ((aroon_down >= aroon_up) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop =   close*1.015\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and (close < short_target):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif ((aroon_down < aroon_up) and (trade_taken == False)):\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close > long_target): \n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and (close < long_stop):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n\n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n    \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    # calculating pnl from trade sheet\n    trade_sheet[\"pnl\"] = 0\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]    \n    return trade_sheet","b2a61b09":"aroon_test = Aroon_backtest(data)\naroon_test.sample(5)","47ad71a0":"aroon_test.set_index('entry_time').pnl.resample('M').sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with Aroon Indicator\")\nplt.show()","d344f83a":"X = df.drop('Close',axis=1)\ny = df.Close\nX.head(2)","a31a3e33":"from sklearn.model_selection import train_test_split\nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size = 0.1,random_state = 0)\n","b848bba3":"from sklearn.tree import DecisionTreeRegressor\n\nmodel = DecisionTreeRegressor(max_depth=4)\nmodel = model.fit(X_train, y_train)\npred = model.predict(X_test)","689eac90":"from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error\nprint(r2_score(y_test, pred))\nprint(mean_absolute_error(y_test,pred))","c3af5054":"feat_importances = pd.Series(model.feature_importances_, index=X_train.columns)\nfeat_importances.nlargest(5).plot(kind='barh')","7c117062":"from graphviz import Source\nfrom sklearn import tree\nSource( tree.export_graphviz(model, out_file=None, feature_names=X.columns))","44b70d67":"### Without Open, High, Close, Low\nX_train = X_train.drop(['Open','High','Low'],axis=1)\nX_test = X_test.drop(['Open','High','Low'],axis=1)\nmodel2 = DecisionTreeRegressor(max_depth=8)\nmodel2 = model2.fit(X_train,y_train)\npred2 = model2.predict(X_test)\nprint(r2_score(y_test,pred2))","aa11e1b4":"print(mean_absolute_error(y_test,pred2))","b69a779f":"feat_importances = pd.Series(model2.feature_importances_, index=X_train.columns)\nfeat_importances.nlargest(5).plot(kind='barh')","ee4ef3d8":"Source( tree.export_graphviz(model2, out_file=None, feature_names=X_train.columns))","e29a35c7":"from sklearn.linear_model import Lasso\nmodel3 = Lasso(alpha=0.1)\nmodel3 = model3.fit(X_train,y_train)\npred3 = model3.predict(X_test)\nprint(r2_score(y_test,pred3))","5bd0d3ed":"print(mean_absolute_error(y_test,pred3))\n","e3204c99":"importance = model3.coef_\n# summarize feature importance\nfor i,v in enumerate(importance):\n    print(X_train.columns[i] + ' Score: %.5f' % v)\n# plot feature importance\nfeat_importances = pd.Series(importance, index=X_train.columns)\nfeat_importances.plot(kind='barh',figsize=(16,10))","a2a174a2":"def RSI_KAMA_backtest(df,rsi_upper, rsi_lower):\n    sample = df.copy()\n    \n    # constant variables \n    entry_time = []\n    exit_time = []\n    trade_side = []\n    rsi_value = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    # temp variables\n    trade_taken = False\n    target = 0\n    stop = 0\n\n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        rsi = sample.iloc[index].loc[\"RSI\"]\n        close = sample.iloc[index].loc['Close']\n        kama_fast = sample.iloc[index].loc['KAMA_FAST']\n        kama_slow = sample.iloc[index].loc['KAMA_SLOW']\n        \n        # if any trade is not taken and rsi value is between your set RSI levels, dont look for new trades \n        if (rsi > rsi_lower) and (rsi < rsi_upper) and (trade_taken == False):\n            continue\n            \n        elif (((kama_slow >= kama_fast) and (rsi > rsi_upper)) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n            \n            entry_time.append(current_datetime) \n            rsi_value.append(rsi)\n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):  \n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n\n        elif (trade_taken == \"short_entered\") and (close < short_target): \n\n            trade_taken = False\n            exit_time.append(current_datetime) \n            exit_price.append(close)\n\n        elif (((rsi < rsi_lower) and (kama_fast > kama_slow)) and (trade_taken == False)):    \n\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)  \n            rsi_value.append(rsi)\n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close < long_stop): \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n        \n        elif (trade_taken == \"long_entered\") and (close > long_target):    \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n\n        # if last data entry and we are still holding a trade then sqaure off the trade \n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n        \n        \n    # creating a trade sheet out of all recorded trades details \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"rsi_value\":rsi_value,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    trade_sheet[\"pnl\"] = 0  \n\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]\n    return trade_sheet","350981b0":"rsi_kama_test = RSI_KAMA_backtest(df,80,20)\nrsi_kama_test.sample(5)","097dbfa0":"rsi_kama_test.set_index('entry_time').pnl.resample('M').sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with RSI + KAMA Indicator\")\nplt.show()","a80b0b05":"def MACD_KAMA_backtest(df):\n    sample = df.copy()\n    \n    # constant variables \n    entry_time = []\n    exit_time = []\n    trade_side = []\n    rsi_value = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    # temp variables\n    trade_taken = False\n    target = 0\n    stop = 0\n\n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        macd = sample.iloc[index].loc[\"macd\"]\n        signal = sample.iloc[index].loc[\"signal\"]\n        close = sample.iloc[index].loc['Close']\n        kama_fast = sample.iloc[index].loc['KAMA_FAST']\n        kama_slow = sample.iloc[index].loc['KAMA_SLOW']\n        \n       # if (rsi > rsi_lower) and (rsi < rsi_upper) and (trade_taken == False):\n        #    continue\n            \n        if (((kama_slow >= kama_fast) and (signal > macd)) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n            \n            entry_time.append(current_datetime) \n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):  \n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n\n        elif (trade_taken == \"short_entered\") and (close < short_target): \n\n            trade_taken = False\n            exit_time.append(current_datetime) \n            exit_price.append(close)\n            \n        elif (trade_taken == \"short_entered\") and ((kama_slow < kama_fast) and (signal < macd)): \n\n            trade_taken = False\n            exit_time.append(current_datetime) \n            exit_price.append(close)\n\n        elif (((signal < macd) and (kama_slow < kama_fast)) and (trade_taken == False)):    \n\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.975\n\n            entry_time.append(current_datetime)  \n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close < long_stop): \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n        \n        elif (trade_taken == \"long_entered\") and (close > long_target):    \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n            \n        elif (trade_taken == \"long_entered\") and ((signal > macd) and (kama_slow > kama_fast)):    \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n\n        # if last data entry and we are still holding a trade then sqaure off the trade \n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n        \n        \n    # creating a trade sheet out of all recorded trades details \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    trade_sheet[\"pnl\"] = 0  \n\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]\n    return trade_sheet","55266ad8":"macd_kama_test = MACD_KAMA_backtest(df)\nmacd_kama_test.sample(5)","9f50364c":"macd_kama_test.set_index('entry_time').pnl.resample('M').sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with MACD + KAMA Indicator\")\nplt.show()","ce0398a7":"def ATR_MACD_KAMA_backtest(df):\n    sample = df.copy()\n    \n    # constant variables \n    entry_time = []\n    exit_time = []\n    trade_side = []\n    rsi_value = []\n    entry_price = []\n    exit_price = []\n    target_price = []\n    stop_price = []\n\n    # temp variables\n    trade_taken = False\n    target = 0\n    stop = 0\n\n    for index,datetime in enumerate(sample.index):\n        current_datetime = datetime\n        macd = sample.iloc[index].loc[\"macd\"]\n        signal = sample.iloc[index].loc[\"signal\"]\n        close = sample.iloc[index].loc['Close']\n        atr = sample.iloc[index].loc['ATR']\n        kama_fast = sample.iloc[index].loc['KAMA_FAST']\n        kama_slow = sample.iloc[index].loc['KAMA_SLOW']\n        \n       # if (rsi > rsi_lower) and (rsi < rsi_upper) and (trade_taken == False):\n        #    continue\n            \n        if ((kama_slow >= kama_fast) and (signal > macd) and (atr > close) and (trade_taken == False)):\n            trade_taken = \"short_entered\"\n            short_target = close*0.97\n            short_stop = close*1.015\n            \n            entry_time.append(current_datetime) \n            trade_side.append(\"short\")\n            entry_price.append(close)\n            target_price.append(short_target)\n            stop_price.append(short_stop)\n\n        elif (trade_taken == \"short_entered\") and (close > short_stop):  \n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n\n        elif (trade_taken == \"short_entered\") and (close < short_target): \n\n            trade_taken = False\n            exit_time.append(current_datetime) \n            exit_price.append(close)  \n            \n        elif (trade_taken == \"short_entered\") and ((kama_slow < kama_fast) and (signal < macd) and (atr < close)): \n\n            trade_taken = False\n            exit_time.append(current_datetime) \n            exit_price.append(close)\n\n        elif ((signal < macd) and (kama_slow < kama_fast) and (atr < close) and (trade_taken == False)):    \n\n            trade_taken = \"long_entered\"\n            long_target = close*1.05\n            long_stop = close*0.98\n\n            entry_time.append(current_datetime)  \n            trade_side.append(\"long\")\n            entry_price.append(close)\n            target_price.append(long_target)\n            stop_price.append(long_stop)\n\n        elif (trade_taken == \"long_entered\") and (close < long_stop): \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n        \n        elif (trade_taken == \"long_entered\") and (close > long_target):    \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)   \n            \n        elif (trade_taken == \"long_entered\") and ((signal > macd) and (kama_slow > kama_fast) and (atr > close)):    \n\n            trade_taken = False\n            exit_time.append(current_datetime)  \n            exit_price.append(close)\n\n        # if last data entry and we are still holding a trade then sqaure off the trade \n        elif (index == (len(sample) - 1)) and (trade_taken != False):\n\n            trade_taken = False\n            exit_time.append(current_datetime)\n            exit_price.append(close)\n        \n        \n    # creating a trade sheet out of all recorded trades details \n    trade_sheet = pd.DataFrame({\"entry_time\":entry_time,\n                               \"exit_time\":exit_time,\n                               \"trade_side\":trade_side,\n                               \"entry_price\":entry_price,\n                               \"exit_price\":exit_price,\n                               \"target_price\":target_price,\n                               \"stop_price\":stop_price})\n\n    trade_sheet[\"pnl\"] = 0  \n\n    con_1 = trade_sheet.trade_side == \"short\"\n    con_2 = trade_sheet.trade_side == \"long\"\n    trade_sheet.loc[con_1,\"pnl\"] = trade_sheet.loc[con_1,\"entry_price\"] - trade_sheet.loc[con_1,\"exit_price\"]\n    trade_sheet.loc[con_2,\"pnl\"] = trade_sheet.loc[con_2,\"exit_price\"] - trade_sheet.loc[con_2,\"entry_price\"]\n    return trade_sheet","5af69911":"atr_macd_kama_test = ATR_MACD_KAMA_backtest(df)\natr_macd_kama_test.sample(5)","765cbffc":"atr_macd_kama_test.set_index('entry_time').pnl.resample('M').sum().cumsum().plot(figsize=(14,7))\nplt.title(\"Nifty Trades with ATR + MACD + KAMA\")\nplt.show()","398825e0":"Below 20 is the over sold area where we should look to buy and above 80 is overbought area where we should look to short.\nWe can see we will get few but profitable trading opportunities if we trade by solely on RSI index. We can also tweek the Threshold values to trade more.","fbdc6fe5":"# Trading Models Nifty with best Indicators\n\nAs of 2021, there are 20 Million traders in India who trade actively on Nifty and Bank Nifty Index. Though this number is very small when compared to the population of India but the number of people opening trading accounts every month is on a all time high and this number is expected to increase rapidly over the next coming years as India is on a high growth trajectory.\n\nEvery trader has it's own principles, targets, stop losses and indicators to buy and sell stocks. Majority of the people let their emotions make trade for them. But there are still traders who are strict with their trading rules and they buy\/sell strictly according to those indicators. You might have read about RSI index (when the stocks are over bought and over sold) , MACD Crossover indicators, Moving Averages and others. But do we know which indicators have given the best returns over the last 10 years? Are you confident about which indicator to stick with? Are there any combination of indicators which can give even better returns than the tried and test RSI and MACD? Which indicators worked well during the pandemic? Well, these are the questions i'll try to solve in this project.\n\nThe motive of this project is to make my own customized models based on historical data from which I can initiate trades with more confidence and informed decisions. Obviously there will be exceptions like the covid pandemic which led to market crumbling down to multiple years low and then making a new all time high in the same year.\n\nLet's jump right into the project and try to find answers to all the above questions!!\n\n\n## Introduction\n\n\nIn this notebook, we have extracted the nifty minute wise data from 2008 to 2021 and then we made various indicators. Next we will check the significance of these filters and finally we will make trading decisions based on the best indicators, we will also make trading models based on combinations of these indicators.\nIn the end, we will select the model which will give the best results(Trading profits) on the test data.\n\n### Steps:\n\n1) **Load Data:**\nWe had all the data in txt format and that too month wise, so I cleaned the data in txt format and arranged them year wise and here we extracted all the data and combined them together to make our main dataframe.\n\n2) **Data Cleaning and Downcast:**\nChecked if there are any extreme outliers and removed only the extreme visible outliers.\n\n3) **Feature Generation (Indicators):**\nWe made 2 indicators manually and for the rest of the indicators we used the pre built technical analysis library to capture these indicator values.\n\n4) **Trades on Indicators individually:**\nFor each Indicator we created, we made a rule based model based on the 15min close prices of Nifty and we calculated the total profit or loss if we make trades based on those Indicators alone.\n\n5) **Checking Important Features:**\nTo get an intiution about the important features, and to make combinations of those Indicators, we checked which were the important filters on a decision tree.\n\n6) **Trades on combination of Indicators:**\nWe created some combinations of different indicators and checked the total profit made on trades.\n","cb4b8ba9":"## Load Data \nLoad and convert text data to dataframe.","bf42c559":"It looks like there are some outliers in 2012-2013. Let's check.","ed361fd4":"The lower the Aroon Up, the weaker the uptrend and the stronger the downtrend, and vice versa. The main assumption underlying this indicator is that a stock's price will close regularly at new highs during an uptrend, and regularly make new lows in a downtrend.\n\nCrossovers can signal entry or exit points. Up crossing above Down can be a signal to buy. Down crossing below Up may be a signal to sell.\n\nWhen both indicators are below 50 it can signal that the price is consolidating. New highs or lows are not being created. Traders can watch for breakouts as well as the next Aroon crossover to signal which direction price is going.\n\n\n","e4a7389d":"The ROC is prone to whipsaws, especially around the zero line. Therefore, this signal is generally not used for trading purposes, but rather to simply alert traders that a trend change may be underway.\n\nOverbought and oversold levels are also used. These levels are not fixed, but will vary by the asset being traded. Traders look to see what ROC values resulted in price reversals in the past. Often traders will find both positive and negative values where the price reversed with some regularity. When the ROC reaches these extreme readings again, traders will be on high alert and watch for the price to start reversing to confirm the ROC signal. With the ROC signal in place, and the price reversing to confirm the ROC signal, a trade may be considered.\n\nOne potential problem with using the ROC indicator is that its calculation gives equal weight to the most recent price and the price from n periods ago, despite the fact that some technical analysts consider more recent price action to be of more importance in determining likely future price movement.","a3aeabc2":"Above we can see trades on various indicators and combinations of Indicators but the best results were shown by KAMA indicator and William's R indicator individually.\nYou can make your own indicators and combination of Indicators and try tweaking the thresholds to get more profitable trades and find which combinations work best for you.","fd7e7d4c":"### Volatility Indicators\n","8129c35d":"### Awesome Oscillator\nIt is a 34-period simple moving average, plotted through the central points of the bars (H+L)\/2, and subtracted from the 5-period simple moving average, graphed across the central points of the bars (H+L)\/2.\n\nMEDIAN PRICE = (HIGH+LOW)\/2\n\nAO = SMA(MEDIAN PRICE, 5)-SMA(MEDIAN PRICE, 34)\n\nwhere\n\nSMA \u2014 Simple Moving Average.\n\n https:\/\/www.ifcm.co.uk\/ntx-indicators\/awesome-oscillator","cafac326":"A StochRSI reading above 0.8 is considered overbought, while a reading below 0.2 is considered oversold. On the zero to 100 scale, above 80 is overbought, and below 20 is oversold.\nOverbought doesn't necessarily mean the price will reverse lower, just like oversold doesn't mean the price will reverse higher. Rather the overbought and oversold conditions simply alert traders that the RSI is near the extremes of its recent readings.\n\nWhen the StochRSI is above 0.50, the security may be seen as trending higher and vice versa when it's below 0.50.\n\nOne downside to using the StochRSI is that it tends to be quite volatile, rapidly moving from high to low. Smoothing the StochRSI may help in this regard. Some traders will take a moving average of the StochRSI to reduce the volatility and make the indicator more useful. For example, a 10-day simple moving average of the StochRSI can produce an indicator that's much smoother and more stable.","287252e8":"### RSI VS CLOSE PRICE","b8a02add":"### Trade with MACD + KAMA","bf547922":"### True strength index (TSI)\n\nShows both trend direction and overbought\/oversold conditions.\n\nhttps:\/\/school.stockcharts.com\/doku.php?id=technical_indicators:true_strength_index","36da4b99":"When the indicator is between -20 and zero the price is overbought, or near the high of its recent price range. When the indicator is between -80 and -100 the price is oversold, or far from the high of its recent range.\n\nDuring an uptrend, traders can watch for the indicator to move below -80. When the price starts moving up, and the indicator moves back above -80, it could signal that the uptrend in price is starting again.\n\nThe same concept could be used to find short trades in a downtrend. When the indicator is above -20, watch for the price to start falling along with the Williams %R moving back below -20 to signal a potential continuation of the downtrend.\n\nTraders can also watch for momentum failures. During a strong uptrend, the price will often reach -20 or above. If the indicator falls, and then can't get back above -20 before falling again, that signals that the upward price momentum is in trouble and a bigger price decline could follow.\n\nThe same concept applies to a downtrend. Readings of -80 or lower are often reached. When the indicator can no longer reach those low levels before moving higher it could indicate the price is going to head higher.","1768d5e8":"### Kaufman\u2019s Adaptive Moving Average (KAMA)\n\nMoving average designed to account for market noise or volatility. KAMA will closely follow prices when the price swings are relatively small and the noise is low. KAMA will adjust when the price swings widen and follow prices from a greater distance. This trend-following indicator can be used to identify the overall trend, time turning points and filter price movements.\n\nhttps:\/\/www.tradingview.com\/ideas\/kama\/","4dbedc53":"MACD indicator alone is giving us some decent profits, we'll check later combinations of MACD with other indicators.\nBefore the pandemic, profit for an entire lot = 75*5000 = 375,000 (based alone on macd indicator)","42e33a6b":"As you can see from the chart above, many traders will watch for a short-term moving average (blue line) to cross above a longer-term moving average (red line) and use this to signal increasing upward momentum. This bullish crossover suggests that the price has recently been rising at a faster rate than it has in the past, so it is a common technical buy sign. Conversely, a short-term moving average crossing below a longer-term average is used to illustrate that the asset's price has been moving downward at a faster rate and that it may be a good time to sell.","f4f596cb":"### Trade with KAMA Indicators","78830e09":"The above graphs shows that Stochastic RSI over 10 days gives us better results that S RSI over 3 days. But we didn't get good profits after 2019 and profits declined significantly during pandemic.","3bc96b2b":"**Average True Range (ATR)**\n\nThe indicator provide an indication of the degree of price volatility. Strong moves, in either direction, are often accompanied by large ranges, or large True Ranges.\n\nhttp:\/\/stockcharts.com\/school\/doku.php?id=chart_school:technical_indicators:average_true_range_atr\n\nThe most common trading approach involving moving averages is to assume that the trend is positive if the average has a positive slope, and the price trades above it, with the opposite conditions applying for a negative trend. When using moving averages to determine the direction of the trend, it\u2019s often done long term, using the 200-period moving average.\n\nYou may also use two moving averages in conjunction to create a cross over signals. One of the most well-known examples involves a crossover by the 50-period moving average over the 200-period moving average, which is called a golden cross.\n","58e91378":"Could this be an outlier? We don't know but let's remove it any way for better functioning of our model.\nOpen and Low both shows this oulier.","c8d27aa7":"### Trades with ATR","c983e994":"**Similarly we can make other indicator combinations.\nYou can make your own indicators, make different combinations, with different thresholds\/targets\/stop loss and comment below which combinations worked best for you!**\n\n**You can take the idea from the indicators I created above. I have also attached links and references in the notebook for better understanding.**\n\n**Additional**\n\nIf you are an enthusiast investor looking for smart trading opportunities.You can invest in upcoming crypto currency similar to bitcoin. You can go install Pi network and Bee Network apps. Both are crypto currencies in their 2nd phase, you can mine the coins for a few months until their user base reaches 1Billion. Both currencies are expected to launch by the end of this year.\nAlso using it is very simple, just open the app everyday and click a button, the coins will get mined for 24 hours. Investment is 5 seconds of time every day and the returns could be 1000 times if it get even 1\/10 value of bitcoin. The investment can take years to show returns but definetly worth trying when it is free of cost.\n\nAlso you will need an invite code to start mining, here's mine you can use - adamnayy (same invite code for both apps). Good luck and happy investing!","1abbb2db":"### ROC Indicator\n\nThe ROC calculation compares the current price with the price \u201cn\u201d periods ago. The plot forms an oscillator that fluctuates above and below the zero line as the Rate-of-Change moves from positive to negative. As a momentum oscillator, ROC signals include centerline crossovers, divergences and overbought-oversold readings. \n\nhttps:\/\/school.stockcharts.com\/doku.php?id=technical_indicators:rate_of_change_roc_and_momentum","b61385ab":"### MACD Indicator\n\nMoving Average Convergence\/Divergence is useful for identifying trend direction and momentum. It uses one line for moving price average and compares it with another. And you\u2019ll find this technical indicator with different time frames. When the lines cross, that can signal a buying or selling opportunity, depending on whether it climbs above or drops below.\n\n","819830b4":"If we trade purely on the basis of RSI index, we will have a cumsum profit of around 2800 at the end of 2018, \nif we trade an entire lot of nifty index (75) , then we would have made a profit of 2,10,000 bucks. Amazing! \nLet's check other Indicators now.","eb4d63cb":"## Trades with Indicators\n\n### Trade with RSI Indicator","29d31143":"Most of our indicators performed better after 2016-2017 because that's when the real bull market started for Nifty index, before that the momentum was slow but now India is attracting a lot of investors due to it's constant high earnings growth and potential to grow further.","2cc5ec15":"In the above graph, we don't see any significant dip during 2016 because the general trend of nifty was upward throughout both years, where as in 2020 we see a significant dip when the market crashed unexpectedly due to the covid crisis.","f2906f4d":"### Trade with ATR + MACD + KAMA","46946c12":"We can take the above important features and make a trading model based on a combinations of these features and check the profits we can get from trades.","d8a0ed3d":"### Stochastic RSI\n\nThe StochRSI oscillator was developed to take advantage of both momentum indicators in order to create a more sensitive indicator that is attuned to a specific security\u2019s historical performance rather than a generalized analysis of price change.\n\nhttps:\/\/school.stockcharts.com\/doku.php?id=technical_indicators:stochrsi https:\/\/www.investopedia.com\/terms\/s\/stochrsi.asp","a07923c3":"The above graph shows that Average True Range is a very good indicator.\nSince the price of Nifty was around 6000-7000, and we are showing profits with trade on 1 quantity, this shows that the profit of 9000 at the end of 2021 is more than 100% return over a periods of 10 years based on ATR Indicator only. Obviously there will be trading charges but again trading on Nifty futures index would have given us 9000*75 = 675,000 Profit over a period of 10 years.","b69d6fee":"### Trade with MACD Indicator","6db1d168":"The above graph shows that ROC Indicator performs horribly during the pandamic, as the market hit new lows everyday and it gave long calls everyday only to trigger stop loss the next morning.","56ee9210":"## Import Libraries","b02b12e7":"From above it is clear that Williams R slow performs better than fast moving indicator. The performance decreased significantly during pandemic.","4fa850e1":"## Data Visualization","4522c179":"### MACD VS Close Price","434d4720":"We don't have the complete data of volume and OI, so we will drop those features as of now.","eef215c1":"The above graph shows that the AOI indicator was working fine before the Pandemic, during the pandamic, the price moved sharply downwards in 2 months and then recovered quickly in the next 6 months.","31e9de09":"### TSI(True Strength Indicator) vs Close Price","05994a97":"### Aroon Indicator","205f7663":"### KAMA Indicator Vs Nifty Movement","fadd676d":"### Trend Indicators","d78ca6fe":"## Feature Engineering - Indicators ","5e59010e":"Now, we have the nifty data minute wise from 2010 to 2021.\n\nWe also have the minute wise data of BankNifty but we will first try to make a model based solely on Nifty Historical prices and check our trading performance. Later we can add the bank features to our model and check if it improves our model performance.","7e8313ed":"### StochRSI vs Close Price","9fefb30e":"Mark extreme TSI levels, on the asset being traded, to see where overbought and oversold is. Being oversold doesn't necessarily mean it is time to buy, and when an asset is overbought it doesn't necessarily mean it is time to sell. Traders will typically watch for other signals to trigger a trade decision. For example, they may wait for the price or TSI to start dropping before selling in overbought territory.","721180b9":"## Modeling to check Feature Importance","702ee0c5":"When the price of the asset breaks below the lower band of the Bollinger Bands\u00ae, prices have perhaps fallen too much and are due to bounce. On the other hand, when price breaks above the upper band, the market is perhaps overbought and due for a pullback.\n\nUsing the bands as overbought\/oversold indicators relies on the concept of mean reversion of the price. Mean reversion assumes that, if the price deviates substantially from the mean or average, it eventually reverts back to the mean price.\n\nIn range-bound markets, mean reversion strategies can work well, as prices travel between the two bands like a bouncing ball. However, Bollinger Bands\u00ae don't always give accurate buy and sell signals. During a strong trend, for example, the trader runs the risk of placing trades on the wrong side of the move because the indicator can flash overbought or oversold signals too soon.\n\nTo help remedy this, a trader can look at the overall direction of price and then only take trade signals that align the trader with the trend. For example, if the trend is down, only take short positions when the upper band is tagged. The lower band can still be used as an exit if desired, but a new long position is not opened since that would mean going against the trend. ","15707854":"When AO crosses above the Zero Line, short term momentum is now rising faster than the long term momentum. This can present a bullish buying opportunity.\n\nWhen AO crosses below the Zero Line, short term momentum is now falling faster then the long term momentum. This can present a bearish selling opportunity.\n\nAO (momentum) can be used in some instances to generate quality signals but much like with any signal generating indicator, it should be used with caution. Truly understanding the setups and avoiding false signals is something that the best traders learn through experience over time. That being said, the Awesome Indicator produces quality information and may be a valuable technical analysis tool for many analysts or traders.","eb7eb0a3":"### Trade with Stoch RSI","629356f3":"## Indicators from Technical Analysis Library in Python\n\nNow we will use the technical analysis library in Python to create all the other indicators.\n\nhttps:\/\/therobusttrader.com\/best-trend-following-indicators\/ You can read more about indicators here.\n\n### Momentum Indicators\n\nhttps:\/\/technical-analysis-library-in-python.readthedocs.io\/en\/latest\/ta.html#momentum-indicators\n","35f53106":"### Removing Outliers\nTo avoid loss of information, we won't remove outliers from all the data. We will remove outliers from only the 10th month of 2012 and then merge it back to the main dataframe.","ed19fd96":"### Trades with AOI (Awesome Oscillator Indicator)","16810b6e":"### Trades with ROC Indicator","f19e6282":"Well, the most common approach is to regard a breakout above the upper band as a positive signal, and a breakout below the lower band as a signal to go short.\n\nThere are several ways that you can go about to exit a trade following a breakout trade. Here follow three of the most commonly used approaches:\n\n**Trailing stops** \u2013 Some traders will insist that the best way to catch the trend that follows a breakout, is to use a trailing stop that trails the price. This way you attempt to milk the trend for as long as possible and try to catch the bigger moves of the market. With the help of a trailing stop consisting of a moving average, we can manage to stay in the trend until its end.\n\n**Time Exit**- You may also use a simple time exit that will get you out of the market after a specific number of bars. While being an incredibly simple exit, this is something that works extremely well in some cases.\n\nI recommend that you try to get an idea about the average duration of a trend in your market, and then use that measure to find out when it usually is time to get out of a trade. It doesn\u2019t need to be very exact, the important thing is that you have some estimation of how long a trend tends to persist in your market!\n\n**Stop Loss and Profit Target**- This is another common approach that we can use, and simply means that we place a stop loss and a profit target. Then our exit will be determined by which one of the two levels that\u2019s hit first.","576cd08b":"### Williams %R\n\nReadings from 0 to -20 are considered overbought. Readings from -80 to -100 are considered oversold.\n\n%R = (Highest High - Close)\/(Highest High - Lowest Low) * -100\n\nLowest Low = lowest low for the look-back period Highest High = highest high for the look-back period %R is multiplied by -100 correct the inversion and move the decimal.\n\nhttps:\/\/school.stockcharts.com\/doku.php?id=technical_indicators:williams_r\n\nThe Williams %R oscillates from 0 to -100. When the indicator produces readings from 0 to -20, this indicates overbought market conditions. When readings are -80 to -100, it indicates oversold market conditions.","be9c443c":"### ATR (Average True Range) vs Close Price","c796669b":"### Trade with Aroon Indicator","52d882a5":"**Donchian Channel**\n\nhttps:\/\/www.investopedia.com\/terms\/d\/donchianchannels.asp\n\nThe indicator itself is very simple, and consists of a lower and an upper band, which are made up of the 20-bar high, and the 20-bar low.\n\nAs soon as the market breaks out above the upper band, or below the lower band, it\u2019s interpreted as a signal to enter a position in the direction of the breakout.\n\nHowever, of course, this is just the basic setup, and to turn it into a working trading strategy, you\u2019ll have to add more filters and conditions to get rid of a lot of false signals.","f4f01804":"### Bollinger Band VS Close Price","11a50568":"### AOI (Awesome Oscillator Indicator) VS Close Price","ec2e7e43":"### Trade with KAMA + RSI","5aef667e":"### WRI (Williams R Indicator) vs Close Price","401e57c1":"\n\n### Bollinger Band\n\n\nBollinger Bands help answer whether an asset\u2019s price is high or low on a relative basis. These are chart overlay bands that use a moving average and past volatility. To determine how far apart the bands are, this technical analysis tool uses standard deviation.","edf17283":"### DC (Donchian Channel) on Close Price","2de10afb":"### Downcast datatypes","26a0cf82":"### Trade with Williams R","67c8e6b5":"The logic behind these signals is that whenever a price closes more than an ATR above the most recent close a change in volatility has occurred. Taking a long position is betting that the stock will follow through in the upward direction.\n\nThere are two main limitations to using the ATR indicator. The first is that ATR is a subjective measure, meaning that it is open to interpretation. There is no single ATR value that will tell you with any certainty that a trend is about to reverse or not. Instead, ATR readings should always be compared against earlier readings to get a feel of a trend's strength or weakness.\n\nSecond, ATR only measures volatility and not the direction of an asset's price. This can sometimes result in mixed signals, particularly when markets are experiencing pivots or when trends are at turning points. For instance, a sudden increase in the ATR following a large move counter to the prevailing trend may lead some traders to think the ATR is confirming the old trend; however, this may not actually be the case.","88e2bddb":"The combination of Macd + Kama Indicator performed amazing especially during the market crash due to pandemic.\n\nAlmost around 9000 profit during the last months of 2020, if we traded in nifty futures based on the above model, our profit would have been 9000*75 = 6,75,000 INR \n","a57dfd9d":"### Relative Strength Index (RSI)\n\nCompares the magnitude of recent gains and losses over a specified time period to measure speed and change of price movements of a security. It is primarily used to attempt to identify overbought or oversold conditions in the trading of an asset.\n\nhttps:\/\/www.investopedia.com\/terms\/r\/rsi.asp","b719223c":"**Aroon Indicator**\n\nWell, Aroon consists of two separate parts, which are \u201cAron-Up\u201d, and \u201cAroon-Down\u201d.\n\nAroon-up measures the number of bars since the last 25-bar high, while Aroon down measures the number of bars since the last 25-bar low.\n\nWhile the logic might seem similar to what\u2019s used in other momentum indicators, such as stochastics, Aroon remains special because it not only takes into account the actual position of the close relative to the previous highs and lows, but also the time that has passed.\n\nIdentify when trends are likely to change direction.\n\nAroon Up = ((N - Days Since N-day High) \/ N) x 100 Aroon Down = ((N - Days Since N-day Low) \/ N) x 100 Aroon Indicator = Aroon Up - Aroon Down\n\nhttps:\/\/www.investopedia.com\/terms\/a\/aroon.asp\n\n**Interpretation**\n\nWhen interpreting the indicator, you generally say that there are three stages to an emerging signal:\n\nThe first stage is when Aroon Up is above Aroon down. Bearing the original definition of the indicator in mind, this shows us that highs have been more recent than lows.\nIn the second stage, the Aroon-up line should move up above 50, while the Aroon-down line should move below 50.\nThe final stage occurs when Arron-up goes up to 100, indicating that a new high has been made, while Arron-down remains on very low levels.","65878e96":"While making other predictors\/indicators we will again get NaNs, if we keep on deleting NaN's after making every indicator, our data will shrink in size. So we will drop all the NaNs once all the indicators are created.","400648fd":"### ROC VS Close Price","3ffbde91":"Wow, surprisingly this lesser known Indicator has shown better results over the last 5 years than the classic MACD and RSI. \n\nProfit for one lot, 75*8000 = 600,000 (6lakhs rupees)","e1ff0508":"### Data Visualization and Removing Outliers","bc2b9863":"One of the uses of Kaufman\u2019s Adaptive Moving Average is to identify the general trend of current market price action. Basically, when the KAMA indicator line is moving lower, it indicates the existence of a downtrend. On the other hand, when the KAMA line is moving higher, it shows an uptrend. As compared to the Simple Moving Average, the KAMA indicator is less likely to generate false signals that may cause a trader to incur losses.\n\nKaufman\u2019s Adaptive Moving Average can also be used to spot the beginning of new trends and pinpoint trend reversal points. One way to do this is by plotting two KAMA lines on a chart \u2013 one with a more short-term moving average and another with a longer-term moving average. When a faster KAMA line crosses above a slower KAMA line, this indicates a change from a downtrend to an uptrend. The trader can take a long position and close the trade when the faster MA line crosses back to beneath the slower MA line. Trading signals can also be derived by the movement of market price in relation to Kaufman\u2019s Adaptive Moving Average. If price crosses from below to above the KAMA line, that is a bullish (buy) signal. Conversely, price falling from above the KAMA line to below it is a bearish (sell) signal."}}