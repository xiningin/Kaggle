{"cell_type":{"5c790073":"code","32831161":"code","b82d2400":"code","977de67b":"code","d7626a57":"code","bdac9341":"code","9ffc1332":"code","4211c3c1":"code","ef7019f3":"code","978bf8b2":"code","96e8d00c":"code","907c5ae7":"code","db930972":"code","0a0ec086":"code","cb8bf8a4":"code","9aa072a0":"code","cddf0573":"code","16687294":"code","5aea017b":"code","f3d3f113":"code","14f92601":"code","fb0ad9f1":"code","f427e109":"code","cc044763":"code","da7d54fe":"code","4cfdb524":"code","4f2c6de3":"code","ebee6e5f":"code","02403297":"code","c4cc9b24":"code","b274181c":"code","21224665":"code","90358083":"code","5743254d":"code","14820043":"code","ed502e6d":"code","480fd6b8":"code","6f069a4a":"code","d9742bdb":"code","8a960915":"code","2d2e503d":"code","4ad1ce56":"code","21393c5c":"code","fc9fd3ec":"code","0bb946be":"code","ac2d0987":"code","ec405ef2":"code","13c441b6":"code","44616ebc":"code","49a8ad3d":"code","92cb2c59":"code","677175fd":"code","2c5d0b6a":"code","6218aac6":"markdown","e83c81b9":"markdown","256ed4dd":"markdown","efb2a997":"markdown","c585a90d":"markdown","089b56ed":"markdown","aabfeb77":"markdown","ba4a7fb5":"markdown","5f5d4c4f":"markdown","b9aef2da":"markdown","32e125fe":"markdown","3f680b40":"markdown","d0a9d211":"markdown","ae815bfd":"markdown","a758cd70":"markdown","b65ab7e0":"markdown","2e9989db":"markdown","f014016e":"markdown","cc2f834d":"markdown","71c39a2d":"markdown","893df02f":"markdown","23059f3e":"markdown","32906d5f":"markdown","5c8c8adb":"markdown","ef052f56":"markdown","43a7a61e":"markdown","51c9122f":"markdown","2e38a210":"markdown","63bd3463":"markdown","ee475b33":"markdown","7b54a00a":"markdown","662a0393":"markdown","36d81ce8":"markdown","50b2f09e":"markdown","01a6c9e2":"markdown","ae18a5b5":"markdown","c835a07f":"markdown","9880bba7":"markdown","4a10f114":"markdown"},"source":{"5c790073":"# Import libraries\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\n# To ignore warning messages\nimport warnings\nwarnings.filterwarnings('ignore')","32831161":"# Adult dataset path\nadult_dataset_path = \"..\/input\/adult_dataset.csv\"\n\n# Function for loading adult dataset\ndef load_adult_data(adult_path=adult_dataset_path):\n    csv_path = os.path.join(adult_path)\n    return pd.read_csv(csv_path)","b82d2400":"# Calling load adult function and assigning to a new variable df\ndf = load_adult_data()\n# load top 3 rows values from adult dataset\ndf.head(3)","977de67b":"print (\"Rows     : \" ,df.shape[0])\nprint (\"Columns  : \" ,df.shape[1])\nprint (\"\\nFeatures : \\n\" ,df.columns.tolist())\nprint (\"\\nMissing values :  \", df.isnull().sum().values.sum())\nprint (\"\\nUnique values :  \\n\",df.nunique())","d7626a57":"# Let's understand the type of values present in each column of our adult dataframe 'df'.\ndf.info()","bdac9341":"# Numerical feature of summary\/description \ndf.describe()","9ffc1332":"# pull top 5 row values to understand the data and how it's look like\ndf.head()","4211c3c1":"# checking \"?\" total values present in particular 'workclass' feature\ndf_check_missing_workclass = (df['workclass']=='?').sum()\ndf_check_missing_workclass","ef7019f3":"# checking \"?\" total values present in particular 'occupation' feature\ndf_check_missing_occupation = (df['occupation']=='?').sum()\ndf_check_missing_occupation","978bf8b2":"# checking \"?\" values, how many are there in the whole dataset\ndf_missing = (df=='?').sum()\ndf_missing","96e8d00c":"percent_missing = (df=='?').sum() * 100\/len(df)\npercent_missing","907c5ae7":"# Let's find total number of rows which doesn't contain any missing value as '?'\ndf.apply(lambda x: x !='?',axis=1).sum()","db930972":"# dropping the rows having missing values in workclass\ndf = df[df['workclass'] !='?']\ndf.head()","0a0ec086":"# select all categorical variables\ndf_categorical = df.select_dtypes(include=['object'])\n\n# checking whether any other column contains '?' value\ndf_categorical.apply(lambda x: x=='?',axis=1).sum()","cb8bf8a4":"# dropping the \"?\"s from occupation and native.country\ndf = df[df['occupation'] !='?']\ndf = df[df['native.country'] !='?']","9aa072a0":"# check the dataset whether cleaned or not?\ndf.info()","cddf0573":"from sklearn import preprocessing\n\n# encode categorical variables using label Encoder\n\n# select all categorical variables\ndf_categorical = df.select_dtypes(include=['object'])\ndf_categorical.head()","16687294":"# apply label encoder to df_categorical\nle = preprocessing.LabelEncoder()\ndf_categorical = df_categorical.apply(le.fit_transform)\ndf_categorical.head()","5aea017b":"# Next, Concatenate df_categorical dataframe with original df (dataframe)\n\n# first, Drop earlier duplicate columns which had categorical values\ndf = df.drop(df_categorical.columns,axis=1)\ndf = pd.concat([df,df_categorical],axis=1)\ndf.head()","f3d3f113":"# look at column type\ndf.info()","14f92601":"# convert target variable income to categorical\ndf['income'] = df['income'].astype('category')","fb0ad9f1":"# check df info again whether everything is in right format or not\ndf.info()","f427e109":"# Importing train_test_split\nfrom sklearn.model_selection import train_test_split","cc044763":"# Putting independent variables\/features to X\nX = df.drop('income',axis=1)\n\n# Putting response\/dependent variable\/feature to y\ny = df['income']","da7d54fe":"X.head(3)","4cfdb524":"y.head(3)","4f2c6de3":"# Splitting the data into train and test\nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.30,random_state=99)\n\nX_train.head()","ebee6e5f":"# Importing decision tree classifier from sklearn library\nfrom sklearn.tree import DecisionTreeClassifier\n\n# Fitting the decision tree with default hyperparameters, apart from\n# max_depth which is 5 so that we can plot and read the tree.\ndt_default = DecisionTreeClassifier(max_depth=5)\ndt_default.fit(X_train,y_train)","02403297":"# Let's check the evaluation metrics of our default model\n\n# Importing classification report and confusion matrix from sklearn metrics\nfrom sklearn.metrics import classification_report,confusion_matrix,accuracy_score\n\n# making predictions\ny_pred_default = dt_default.predict(X_test)\n\n# Printing classifier report after prediction\nprint(classification_report(y_test,y_pred_default))","c4cc9b24":"# Printing confusion matrix and accuracy\nprint(confusion_matrix(y_test,y_pred_default))\nprint(accuracy_score(y_test,y_pred_default))","b274181c":"!pip install pydotplus","21224665":"# Importing required packages for visualization\nfrom IPython.display import Image  \nfrom sklearn.externals.six import StringIO  \nfrom sklearn.tree import export_graphviz\nimport pydotplus,graphviz\n\n# Putting features\nfeatures = list(df.columns[1:])\nfeatures","90358083":"# If you're on windows:\n# Specifing path for dot file.\n# import os\n# os.environ[\"PATH\"] += os.pathsep + 'C:\/Program Files (x86)\/graphviz-2.38\/release\/bin\/'","5743254d":"# plotting tree with max_depth=3\ndot_data = StringIO()  \nexport_graphviz(dt_default, out_file=dot_data,\n                feature_names=features, filled=True,rounded=True)\n\ngraph = pydotplus.graph_from_dot_data(dot_data.getvalue())  \nImage(graph.create_png())","14820043":"# GridSearchCV to find optimal max_depth\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import GridSearchCV\n\n\n# specify number of folds for k-fold CV\nn_folds = 5\n\n# parameters to build the model on\nparameters = {'max_depth': range(1, 40)}\n\n# instantiate the model\ndtree = DecisionTreeClassifier(criterion = \"gini\", \n                               random_state = 100)\n\n# fit tree on training data\ntree = GridSearchCV(dtree, parameters, \n                    cv=n_folds, \n                   scoring=\"accuracy\")\ntree.fit(X_train, y_train)","ed502e6d":"# scores of GridSearch CV\nscores = tree.cv_results_\npd.DataFrame(scores).head()","480fd6b8":"\"\"\"\n# plotting accuracies with max_depth\nplt.figure()\nplt.plot(scores[\"param_max_depth\"], \n         scores[\"mean_train_score\"], \n         label=\"training accuracy\")\nplt.plot(scores[\"param_max_depth\"], \n         scores[\"mean_test_score\"], \n         label=\"test accuracy\")\nplt.xlabel(\"max_depth\")\nplt.ylabel(\"Accuracy\")\nplt.legend()\nplt.show()\n\"\"\"","6f069a4a":"# GridSearchCV to find optimal max_depth\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import GridSearchCV\n\n\n# specify number of folds for k-fold CV\nn_folds = 5\n\n# parameters to build the model on\nparameters = {'min_samples_leaf': range(5, 200, 20)}\n\n# instantiate the model\ndtree = DecisionTreeClassifier(criterion = \"gini\", \n                               random_state = 100)\n\n# fit tree on training data\ntree = GridSearchCV(dtree, parameters, \n                    cv=n_folds, \n                   scoring=\"accuracy\")\ntree.fit(X_train, y_train)","d9742bdb":"# scores of GridSearch CV\nscores = tree.cv_results_\npd.DataFrame(scores).head()","8a960915":"\"\"\"\n# plotting accuracies with min_samples_leaf\nplt.figure()\nplt.plot(scores[\"param_min_samples_leaf\"], \n         scores[\"mean_train_score\"], \n         label=\"training accuracy\")\nplt.plot(scores[\"param_min_samples_leaf\"], \n         scores[\"mean_test_score\"], \n         label=\"test accuracy\")\nplt.xlabel(\"min_samples_leaf\")\nplt.ylabel(\"Accuracy\")\nplt.legend()\nplt.show()\n\"\"\"","2d2e503d":"# GridSearchCV to find optimal min_samples_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import GridSearchCV\n\n\n# specify number of folds for k-fold CV\nn_folds = 5\n\n# parameters to build the model on\nparameters = {'min_samples_split': range(5, 200, 20)}\n\n# instantiate the model\ndtree = DecisionTreeClassifier(criterion = \"gini\", \n                               random_state = 100)\n\n# fit tree on training data\ntree = GridSearchCV(dtree, parameters, \n                    cv=n_folds, \n                   scoring=\"accuracy\")\ntree.fit(X_train, y_train)","4ad1ce56":"# scores of GridSearch CV\nscores = tree.cv_results_\npd.DataFrame(scores).head()","21393c5c":"\"\"\"\n# plotting accuracies with min_samples_leaf\nplt.figure()\nplt.plot(scores[\"param_min_samples_split\"], \n         scores[\"mean_train_score\"], \n         label=\"training accuracy\")\nplt.plot(scores[\"param_min_samples_split\"], \n         scores[\"mean_test_score\"], \n         label=\"test accuracy\")\nplt.xlabel(\"min_samples_split\")\nplt.ylabel(\"Accuracy\")\nplt.legend()\nplt.show()\n\"\"\"","fc9fd3ec":"# Create the parameter grid \nparam_grid = {\n    'max_depth': range(5, 15, 5),\n    'min_samples_leaf': range(50, 150, 50),\n    'min_samples_split': range(50, 150, 50),\n    'criterion': [\"entropy\", \"gini\"]\n}\n\nn_folds = 5\n\n# Instantiate the grid search model\ndtree = DecisionTreeClassifier()\ngrid_search = GridSearchCV(estimator = dtree, param_grid = param_grid, \n                          cv = n_folds, verbose = 1)\n\n# Fit the grid search to the data\ngrid_search.fit(X_train,y_train)","0bb946be":"# cv results\ncv_results = pd.DataFrame(grid_search.cv_results_)\ncv_results","ac2d0987":"# printing the optimal accuracy score and hyperparameters\nprint(\"best accuracy\", grid_search.best_score_)\nprint(grid_search.best_estimator_)","ec405ef2":"# model with optimal hyperparameters\nclf_gini = DecisionTreeClassifier(criterion = \"gini\", \n                                  random_state = 100,\n                                  max_depth=10, \n                                  min_samples_leaf=50,\n                                  min_samples_split=50)\nclf_gini.fit(X_train, y_train)","13c441b6":"# accuracy score\nclf_gini.score(X_test,y_test)","44616ebc":"# plotting the tree\ndot_data = StringIO()  \nexport_graphviz(clf_gini, out_file=dot_data,feature_names=features,filled=True,rounded=True)\n\ngraph = pydotplus.graph_from_dot_data(dot_data.getvalue())  \nImage(graph.create_png())","49a8ad3d":"# tree with max_depth = 3\nclf_gini = DecisionTreeClassifier(criterion = \"gini\", \n                                  random_state = 100,\n                                  max_depth=3, \n                                  min_samples_leaf=50,\n                                  min_samples_split=50)\nclf_gini.fit(X_train, y_train)\n\n# score\nprint(clf_gini.score(X_test,y_test))","92cb2c59":"# plotting tree with max_depth=3\ndot_data = StringIO()  \nexport_graphviz(clf_gini, out_file=dot_data,feature_names=features,filled=True,rounded=True)\n\ngraph = pydotplus.graph_from_dot_data(dot_data.getvalue())  \nImage(graph.create_png())","677175fd":"# classification metrics\nfrom sklearn.metrics import classification_report,confusion_matrix\ny_pred = clf_gini.predict(X_test)\nprint(classification_report(y_test, y_pred))","2c5d0b6a":"# confusion matrix\nprint(confusion_matrix(y_test,y_pred))","6218aac6":"## Data Preparation\n\nThere are a number of preprocessing steps we need to do before building the model. \n\nFirstly, note that we have both categorical and numeric features as predictors. In previous models such as linear and logistic regression, we had created **dummy variables** for categorical variables, since those models (being mathematical equations) can  process only numeric variables.\n\nAll that is not required in decision trees, since they can process categorical variables easily. However, we still need to **encode the categorical variables** into a standard format so that sklearn can understand them and build the tree. We'll do that using the ```LabelEncoder()``` class, which comes with ```sklearn.preprocessing```. \n\nYou can read the documentation of ```LabelEncoder``` <a href=\"http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.preprocessing.LabelEncoder.html\">here<\/a>.\n","e83c81b9":"## Data Analysis : EDA(Exploratory Data Analysis)","256ed4dd":"- The info() method : Used to get a quick description of the data, in particular the total number of rows,columns and each attribute's type and number of non-null values...etc","efb2a997":"**- Now all the categorical columns are successfully encoded. Let's build the model.**","c585a90d":"The default tree is quite complex, and we need to simplify it by tuning the hyperparameters. \n\nFirst, let's understand the parameters in a decision tree. You can read this in the documentation using ```help(DecisionTreeClassifier)```.\n\n\n- **criterion** (Gini\/IG or entropy): It defines the function to measure the quality of a split. Sklearn supports \u201cgini\u201d criteria for Gini Index & \u201centropy\u201d for Information Gain. By default, it takes the value \u201cgini\u201d.\n- **splitter**: It defines the strategy to choose the split at each node. Supports \u201cbest\u201d value to choose the best split & \u201crandom\u201d to choose the best random split. By default, it takes \u201cbest\u201d value.\n- **max_features**: It defines the no. of features to consider when looking for the best split. We can input integer, float, string & None value.\n    - If an integer is inputted then it considers that value as max features at each split.\n    - If float value is taken then it shows the percentage of features at each split.\n    - If \u201cauto\u201d or \u201csqrt\u201d is taken then max_features=sqrt(n_features).\n    - If \u201clog2\u201d is taken then max_features= log2(n_features).\n    - If None, then max_features=n_features. By default, it takes \u201cNone\u201d value.\n- **max_depth**: The max_depth parameter denotes maximum depth of the tree. It can take any integer value or None. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples. By default, it takes \u201cNone\u201d value.\n- **min_samples_split**: This tells above the minimum no. of samples reqd. to split an internal node. If an integer value is taken then consider min_samples_split as the minimum no. If float, then it shows percentage. By default, it takes \u201c2\u201d value.\n- **min_samples_leaf**: The minimum number of samples required to be at a leaf node. If an integer value is taken then consider - -min_samples_leaf as the minimum no. If float, then it shows percentage. By default, it takes \u201c1\u201d value.\n- **max_leaf_nodes**: It defines the maximum number of possible leaf nodes. If None then it takes an unlimited number of leaf nodes. By default, it takes \u201cNone\u201d value.\n- **min_impurity_split**: It defines the threshold for early stopping tree growth. A node will split if its impurity is above the threshold otherwise it is a leaf.<br>\n\n","089b56ed":"** check \"?\" values, how many are there in the whole dataset**","aabfeb77":"### Plotting the Decision Tree\n\nTo visualise decision trees in python, you need to install certain external libraries. You can read about the process in detail here: http:\/\/scikit-learn.org\/stable\/modules\/tree.html\n\nWe need the ```graphviz``` library to plot a tree.","ba4a7fb5":"# Prediction Income: Using Decision Tree Algorithm\n\n**```Use Case:```**\n\nIn this case study, we will build a decision tree to predict the income of a given population, which is labelled as <=$50K and >$50K. The attributes (predictors) are age, working class type, marital status, gender, race etc.\n\n\nIn the following sections, we'll:\n- clean and prepare the data, \n- build a decision tree with default hyperparameters, \n- understand all the hyperparameters that we can tune, and finally\n- choose the optimal hyperparameters using grid search cross-validation.\n","5f5d4c4f":"## Loading,Understanding and Cleaning Data\n\n** Loading required python packages for data analysis,visualization and model prediction **","b9aef2da":"### Next, Since here we have income as target\/predicted variable we can see it's showing integer though we need to figure out  labelled as <=50\ud835\udc3e \ud835\udc4e\ud835\udc5b\ud835\udc51 >50K and >50K as categorical.\n\n- Let's convert target class\/variable int32 to categorical( labelled as <=50\ud835\udc3e\ud835\udc4e\ud835\udc5b\ud835\udc51>50Kand>50K)","32e125fe":"#### Please Upvote! If you really find this notebook is useful! Thanks,Happy learning!","3f680b40":"### Tuning min_samples_split\n\nThe hyperparameter **min_samples_split** is the minimum no. of samples required to split an internal node. Its default value is 2, which means that even if a node is having 2 samples it can be furthur divided into leaf nodes.","d0a9d211":"- Thus, the columns **occupation and native.country** contain some **\"?\"s**. Let's get rid of them.","ae815bfd":"## Grid Search to Find Optimal Hyperparameters\n\n- We can now use GridSearchCV to find multiple optimal hyperparameters together. Note that this time, we'll also specify the criterion (gini\/entropy or IG).\n","a758cd70":"- You can see that this tree is too complex to understand. Let's try reducing the max_depth and see how the tree looks.","b65ab7e0":"- There are 1836 rows with missing values, which is about 5% of the total data. We choose to simply drop these rows.","2e9989db":"### More to come. Stay tuned.!","f014016e":"**find out percentage of \"?\" value present across the dataset**","cc2f834d":"### Tuning min_samples_leaf\n\nThe hyperparameter **min_samples_leaf** indicates the minimum number of samples required to be at a leaf.<br>\n\nSo if the values of min_samples_leaf is less, say 5, then the will be constructed even if a leaf has 5, 6 etc. observations (and is likely to overfit).<br>\n\nLet's see what will be the optimum value for min_samples_leaf.","71c39a2d":"- Now let's visualize how train and test score changes with max_depth.","893df02f":"**Pulling total missing value \"?\" present in \"Occupation\" feature **","23059f3e":"## Work in Progress...","32906d5f":"### Tuning max_depth\n\nLet's first try to find the optimum values for max_depth and understand how the value of max_depth affects the decision tree.\n\nHere, we are creating a dataframe with max_depth in range 1 to 80 and checking the accuracy score corresponding to each max_depth. \n\nTo reiterate, a grid search scheme consists of:\n\n    - an estimator (classifier such as SVC() or decision tree)\n    - a parameter space\n    - a method for searching or sampling candidates (optional) \n    - a cross-validation scheme, and\n    - a score function (accuracy, roc_auc etc.)","5c8c8adb":"**Pulling total missing value \"?\" present in \"workclass\" feature **","ef052f56":"- Let's see whether any other columns contain a \"?\". Since \"?\" is a string, we can apply this check only on the categorical columns.","43a7a61e":"### Hyperparameter Tuning","51c9122f":"- Let's get insight of the dataset little bit more and understand them. how they are distributed? ","2e38a210":"## Data Overview","63bd3463":"In order to add missing packages that are available in pip add a single cell at the beginning of your kernel with just this line:\n\n!pip install my-package\n\nFor this to work you have to enable temporarily internet access for your kernel. It is important that you check the availability of the package in pip. Execute one time that cell and after it finishes disable internet access if not required. The rest of cells in your kernel will have access to the package from now on.\n\nAn example kernel that uses this approach you will find it here","ee475b33":"- Apply label encoder to df_categorical","7b54a00a":"### Analysis on Categorical features\/columns is they contain any missing value as'?'","662a0393":"## Model Building and Evaluation\n\n**```Let's first build a decision tree with default hyperparameters. Then we'll use cross-validation to tune them.```**","36d81ce8":"**Note**:<br>\nPython requires library pydot and an external software graphviz to visualize the decision tree. If you are on wondows, you'll need to specify the path for the pydot library to access dot file from graphviz.\n\nPlease read the downloadable instructions to install graphviz. For Mac users, one way is to:\n- Install the python graphviz module: ```pip install graphviz```\n- Then install the Graphviz software on Mac, you do this using homebrew:\n    - Install homebrew: https:\/\/docs.brew.sh\/Installation\n    - ```brew install graphviz```","50b2f09e":"## Loading Adult dataset to Predict Income","01a6c9e2":"- You can observe that the columns **workclass** and **occupation** consist of **missing values which are represented as '?' in the  dataframe.**\n\n- On looking a bit more closely, you will also find that whenever workclass is having a missing value, occupation is also missing in that row. Let's check how may rows are missing.","ae18a5b5":"- Let's look at the other fields. describe() method shows a summary of the numerical attributes(numerical columns)","c835a07f":"\n- Now we have a clean dataframe which is ready for model building.\n- Next, let's get ride of dummy variable. where ever having categorical value convert those into dummy variable. let's do some data preprocessing","9880bba7":"**Running the model with best parameters obtained from grid search.**","4a10f114":"### Let's Contenate df_categorical with master\/original dataframe df"}}