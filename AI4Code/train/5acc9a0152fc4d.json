{"cell_type":{"7bf54f9b":"code","cc8c27c7":"code","d50bce59":"code","e82c993a":"code","880caa54":"code","0cd4178f":"code","1e883809":"code","1f9b3194":"code","81f01b2d":"code","e38121e1":"code","79a530e4":"code","d613866b":"code","6829933b":"code","48188fac":"code","3a23dfd6":"code","3f896afd":"code","b21d048a":"code","c68630a3":"code","eaef6204":"code","80decb73":"markdown","1a93e72e":"markdown","7cee8c82":"markdown","d940f4b2":"markdown","d168a60f":"markdown","6363cc26":"markdown","4d456200":"markdown","77a0edb5":"markdown","d5691b1d":"markdown","6709ca3d":"markdown","0ea40f5c":"markdown","d7e8a04d":"markdown"},"source":{"7bf54f9b":"import random\nimport numpy as np\n\nfrom learntools.core import binder\nbinder.bind(globals())\nfrom learntools.game_ai.ex1 import *","cc8c27c7":"from kaggle_environments import make, evaluate, utils\nenv = make(\"connectx\", debug=True)\nprint(list(env.agents))","d50bce59":"env.run([\"random\", \"random\"])\nenv.render(mode=\"ipython\")","e82c993a":"# This function takes two agents, and makes them play 100 games against each other\n# Each agent gets 50 games where it gets to make the first move\n# It calculates the percentage of games won by agent1 and agent2\n\ndef get_win_percentages(agent1, agent2, n_rounds):\n    # Use default Connect Four setup\n    config = {'rows': 6, 'columns': 7, 'inarow': 4}\n    # Agent 1 goes first (roughly) half the time          \n    outcomes = evaluate(\"connectx\", [agent1, agent2], config, [], n_rounds\/\/2)\n    # Agent 2 goes first (roughly) half the time      \n    outcomes += [[b,a] for [a,b] in evaluate(\"connectx\", [agent2, agent1], config, [], n_rounds-n_rounds\/\/2)]\n    print(\"Agent 1 Win Percentage:\", np.round(outcomes.count([1,-1])\/len(outcomes), 2))\n    print(\"Agent 2 Win Percentage:\", np.round(outcomes.count([-1,1])\/len(outcomes), 2))\n    print(\"Number of Invalid Plays by Agent 1:\", outcomes.count([None, 0]))\n    print(\"Number of Invalid Plays by Agent 2:\", outcomes.count([0, None]))","880caa54":"# This file will write our agent functions to output\n\nimport inspect\nimport os\n\ndef write_agent_to_file(function, file):\n    with open(file, \"a\" if os.path.exists(file) else \"w\") as f:\n        f.write(inspect.getsource(function))\n        print(function, \"written to\", file)","0cd4178f":"# Selects random valid column\ndef agent_random(obs, config):\n    valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]\n    return random.choice(valid_moves)","1e883809":"def agent_smart(obs, config):\n    \n    ################################\n    # Imports and helper functions #\n    ################################\n    \n    import numpy as np\n    import random\n\n    # Gets board at next step if agent drops piece in selected column\n    def drop_piece(grid, col, piece, config):\n        next_grid = grid.copy()\n        for row in range(config.rows-1, -1, -1):\n            if next_grid[row][col] == 0:\n                break\n        next_grid[row][col] = piece\n        return next_grid\n\n    # Returns True if dropping piece in column results in game win\n    def check_winning_move(obs, config, col, piece):\n        # Convert the board to a 2D grid\n        grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n        next_grid = drop_piece(grid, col, piece, config)\n        # horizontal\n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(next_grid[row,col:col+config.inarow])\n                if window.count(piece) == config.inarow:\n                    return True\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(next_grid[row:row+config.inarow,col])\n                if window.count(piece) == config.inarow:\n                    return True\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(next_grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if window.count(piece) == config.inarow:\n                    return True\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(next_grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if window.count(piece) == config.inarow:\n                    return True\n        return False\n    \n    #########################\n    # Agent makes selection #\n    #########################\n    \n    valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark):\n            return col\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark%2+1):\n            return col\n    return random.choice(valid_moves)","1f9b3194":"# Agents play one game round\nenv.run([agent_smart, agent_random])\n\n# Show the game\nenv.render(mode=\"ipython\")","81f01b2d":"get_win_percentages(agent1=agent_smart, agent2=agent_random, n_rounds=100)","e38121e1":"def agent_lookahead(obs, config):\n    \n    ################################\n    # Imports and helper functions #\n    ################################\n    \n    import numpy as np\n    import random\n    \n    A = 1e10\n    B = 1e4\n    C = 1e2\n    D = -1\n    E = -1e6\n    \n    # Calculates score if agent drops piece in selected column\n    def score_move(grid, col, mark, config):\n        next_grid = drop_piece(grid, col, mark, config)\n        score = get_heuristic(next_grid, col, mark, config)\n        return score\n\n    # Helper function for score_move: gets board at next step if agent drops piece in selected column\n    def drop_piece(grid, col, mark, config):\n        next_grid = grid.copy()\n        for row in range(config.rows-1, -1, -1):\n            if next_grid[row][col] == 0:\n                break\n        next_grid[row][col] = mark\n        return next_grid\n\n    # Helper function for score_move: calculates value of heuristic for grid    \n    def get_heuristic(grid, col, mark, config):\n        num_twos = count_windows(grid, 2, mark, config)\n        num_threes = count_windows(grid, 3, mark, config)\n        num_fours = count_windows(grid, 4, mark, config)\n        num_twos_opp = count_windows(grid, 2, mark%2+1, config)\n        num_threes_opp = count_windows(grid, 3, mark%2+1, config)\n        score = A*num_fours + B*num_threes + C*num_twos + D*num_twos_opp + E*num_threes_opp\n        return score\n\n    # Helper function for get_heuristic: checks if window satisfies heuristic conditions\n    def check_window(window, num_discs, piece, config):\n        return (window.count(piece) == num_discs and window.count(0) == config.inarow-num_discs)\n    \n    # Helper function for get_heuristic: counts number of windows satisfying specified heuristic conditions\n    def count_windows(grid, num_discs, piece, config):\n        num_windows = 0\n        # horizontal\n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[row, col:col+config.inarow])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(grid[row:row+config.inarow, col])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        return num_windows\n    \n    #########################\n    # Agent makes selection #\n    #########################\n    \n    # Get list of valid moves\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next turn\n    scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)","79a530e4":"# Agents play one game round\nenv.run([agent_lookahead, agent_smart])\n\n# Show the game\nenv.render(mode=\"ipython\")","d613866b":"get_win_percentages(agent1=agent_lookahead, agent2=agent_smart, n_rounds=100)","6829933b":"def agent_minimax(obs, config):\n    \n    ################################\n    # Imports and helper functions #\n    ################################\n    \n    import numpy as np\n    import random\n    \n    # How deep to make the game tree: higher values take longer to run!\n    N_STEPS = 3\n    \n    A = 1e10\n    B = 1e4\n    C = 1e2\n    D = -1\n    E = -1e6\n    \n    # Gets board at next step if agent drops piece in selected column\n    def drop_piece(grid, col, mark, config):\n        next_grid = grid.copy()\n        for row in range(config.rows-1, -1, -1):\n            if next_grid[row][col] == 0:\n                break\n        next_grid[row][col] = mark\n        return next_grid\n\n    # Helper function for get_heuristic: checks if window satisfies heuristic conditions\n    def check_window(window, num_discs, piece, config):\n        return (window.count(piece) == num_discs and window.count(0) == config.inarow-num_discs)\n    \n    # Helper function for get_heuristic: counts number of windows satisfying specified heuristic conditions\n    def count_windows(grid, num_discs, piece, config):\n        num_windows = 0\n        # horizontal\n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[row, col:col+config.inarow])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(grid[row:row+config.inarow, col])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        return num_windows\n    \n    # Helper function for score_move: calculates value of heuristic for grid    \n    def get_heuristic(grid, mark, config):\n        num_twos = count_windows(grid, 2, mark, config)\n        num_threes = count_windows(grid, 3, mark, config)\n        num_fours = count_windows(grid, 4, mark, config)\n        num_twos_opp = count_windows(grid, 2, mark%2+1, config)\n        num_threes_opp = count_windows(grid, 3, mark%2+1, config)\n        score = A*num_fours + B*num_threes + C*num_twos + D*num_twos_opp + E*num_threes_opp\n        return score\n    \n    # Uses minimax to calculate value of dropping piece in selected column\n    def score_move(grid, col, mark, config, nsteps):\n        next_grid = drop_piece(grid, col, mark, config)\n        score = minimax(next_grid, nsteps-1, False, mark, config)\n        return score\n    \n    # Helper function for minimax: checks if agent or opponent has four in a row in the window\n    def is_terminal_window(window, config):\n        return window.count(1) == config.inarow or window.count(2) == config.inarow\n    \n    # Helper function for minimax: checks if game has ended\n    def is_terminal_node(grid, config):\n        # Check for draw \n        if list(grid[0, :]).count(0) == 0:\n            return True\n        # Check for win: horizontal, vertical, or diagonal\n        # horizontal \n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[row, col:col+config.inarow])\n                if is_terminal_window(window, config):\n                    return True\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(grid[row:row+config.inarow, col])\n                if is_terminal_window(window, config):\n                    return True\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if is_terminal_window(window, config):\n                    return True\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if is_terminal_window(window, config):\n                    return True\n        return False\n\n    # Minimax implementation\n    def minimax(node, depth, maximizingPlayer, mark, config):\n        is_terminal = is_terminal_node(node, config)\n        valid_moves = [c for c in range(config.columns) if node[0][c] == 0]\n        if depth == 0 or is_terminal:\n            return get_heuristic(node, mark, config)\n        if maximizingPlayer:\n            value = -np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark, config)\n                value = max(value, minimax(child, depth-1, False, mark, config))\n            return value\n        else:\n            value = np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark%2+1, config)\n                value = min(value, minimax(child, depth-1, True, mark, config))\n            return value\n    \n    #########################\n    # Agent makes selection #\n    #########################\n    \n    # If agent gets first move, put marker in middle column\n    #if sum(obs.board) == 0:\n        #return 3\n    # Get list of valid moves\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)","48188fac":"def agent_alphabeta(obs, config):\n\n    ################################\n    # Imports and helper functions #\n    ################################\n    \n    import numpy as np\n    import random\n\n    # Helper function for is_terminal_node: checks if agent or opponent has four in a row in the window\n    def is_terminal_window(window, config):\n        return window.count(1) == config.inarow or window.count(2) == config.inarow\n\n    # Helper function for minimax_alphabeta: checks if game has ended\n    def is_terminal_node(grid, config):\n        # Check for draw\n        # The list method would be faster.\n        #valid_moves = [c for c in range(config.columns) if grid[0][c] == 0]\n        #if len(valid_moves) == 0:\n        if list(grid[0, :]).count(0) == 0:\n            return True\n        # Check for win: horizontal, vertical, or diagonal\n        # horizontal \n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[row, col:col+config.inarow])\n                if is_terminal_window(window, config):\n                    return True\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(grid[row:row+config.inarow, col])\n                if is_terminal_window(window, config):\n                    return True\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if is_terminal_window(window, config):\n                    return True\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if is_terminal_window(window, config):\n                    return True\n        return False\n\n    # Helper function for count_windows: checks if window satisfies heuristic conditions\n    def check_window(window, num_discs, piece, config):\n        return (window.count(piece) == num_discs and window.count(0) == config.inarow-num_discs)\n\n    # Helper function for get_heuristic: counts number of windows satisfying specified heuristic conditions\n    def count_windows(grid, num_discs, piece, config):\n        num_windows = 0\n        # horizontal\n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[row, col:col+config.inarow])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(grid[row:row+config.inarow, col])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        return num_windows\n\n    # Helper function for minimax: calculates value of heuristic for grid\n    def get_heuristic(grid, mark, config):\n        num_threes = count_windows(grid, 3, mark, config)\n        num_fours = count_windows(grid, 4, mark, config)\n        num_threes_opp = count_windows(grid, 3, mark%2+1, config)\n        num_fours_opp = count_windows(grid, 4, mark%2+1, config)\n        return num_threes - 1e2*num_threes_opp - 1e4*num_fours_opp + 1e6*num_fours\n\n    # Gets board at next step if agent drops piece in selected column\n    def drop_piece(grid, col, mark, config):\n        next_grid = grid.copy()\n        for row in range(config.rows-1, -1, -1):\n            if next_grid[row][col] == 0:\n                break\n        next_grid[row][col] = mark\n        return next_grid\n\n    # Minimax implementation: recursive!!!\n    # https:\/\/en.wikipedia.org\/wiki\/Alpha%E2%80%93beta_pruning#Pseudocode\n    #def minimax_alphabeta(node, depth, alpha, beta, maximizingPlayer, mark, config):\n    def minimax_alphabeta(node, depth, alpha, beta, maximizingPlayer, mark, config, columns_centered): # columns_centered\n        if depth == 0 or is_terminal_node(node, config):\n            return get_heuristic(node, mark, config)\n        #valid_moves = [c for c in range(config.columns) if node[0][c] == 0]\n        valid_moves = [c for c in columns_centered if node[0][c] == 0] # columns_centered\n        if maximizingPlayer:\n            value = -np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark, config)\n                #value = max(value, minimax_alphabeta(child, depth-1, alpha, beta, False, mark, config))\n                value = max(value, minimax_alphabeta(child, depth-1, alpha, beta, False, mark, config, columns_centered)) # columns_centered\n                alpha = max(alpha, value) # the minimum score that the maximizing player (i.e., the \"alpha\" player) is assured of\n                if alpha >= beta: #\n                    break # beta cutoff\n            return value\n        else:\n            value = np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark%2+1, config)\n                #value = min(value, minimax_alphabeta(child, depth-1, alpha, beta, True, mark, config))\n                value = min(value, minimax_alphabeta(child, depth-1, alpha, beta, True, mark, config, columns_centered)) # columns_centered\n                beta = min(beta, value) # the maximum score that the minimizing player (i.e. the \"beta\" player) is assured of\n                if beta <= alpha: #\n                    break # alpha cutoff\n            return value\n\n    # Uses minimax to calculate value of dropping piece in selected column\n    #def score_move(grid, col, mark, config, nsteps):\n    def score_move(grid, col, mark, config, nsteps, columns_centered): # columns_centered\n        #return minimax_alphabeta(grid, nsteps, -np.Inf, np.Inf, True, mark, config)        # no need to create next_grid here. minimax_alphabeta() will do that.\n        # but this method of calculating next_grid is faster!\n        next_grid = drop_piece(grid, col, mark, config)\n        #return minimax_alphabeta(next_grid, nsteps-1, -np.Inf, np.Inf, False, mark, config)\n        return minimax_alphabeta(next_grid, nsteps-1, -np.Inf, np.Inf, False, mark, config, columns_centered) # columns_centered\n\n\n    #########################\n    # Agent makes selection #\n    #########################\n\n    # How deep to make the game tree: higher values take longer to run!\n    N_STEPS = 2\n\n    # Get list of valid moves\n    #valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # columns more center would get higher heuristics. This could be useful in pruning.\n    #columns = [c for c in range(config.columns)] # error in v17 why?\n    columns = [c for c in range(config.columns) if obs.board[c] == 0]\n    dist_from_center = {c: abs(c-(config.columns-1)\/2) for c in columns}\n    columns_centered = [k for k, v in sorted(dist_from_center.items(), key=lambda item: item[1])]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    #scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    scores = dict(zip(columns_centered, [score_move(grid, col, obs.mark, config, N_STEPS, columns_centered) for col in columns_centered])) # columns_centered\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)","3a23dfd6":"# Agents play one game round\nenv.run([agent_alphabeta, agent_alphabeta])\n\n# Show the game\nenv.render(mode=\"ipython\")","3f896afd":"get_win_percentages(agent1=agent_alphabeta, agent2=agent_lookahead, n_rounds=2)","b21d048a":"write_agent_to_file(agent_alphabeta, \"submission.py\")","c68630a3":"import sys\nout = sys.stdout\nsubmission = utils.read_file(\"\/kaggle\/working\/submission.py\")\nagent = utils.get_last_callable(submission)\nsys.stdout = out\n\nenv = make(\"connectx\", debug=True)\nenv.run([agent_alphabeta, agent_alphabeta])\nprint(\"Success!\" if env.state[0].status == env.state[1].status == \"DONE\" else \"Failed...\")","eaef6204":"env.play([None, agent_minimax], width=500, height=450)","80decb73":"# The ConnectX environment\n\nLet's load in the ConnectX environment from kaggle_environments, take a little look at it and make two agents play against each other. The code below also shows two 'pre-build' agents available in the environment - random and negamax.","1a93e72e":"Let's see agent_smart play against agent_random.","7cee8c82":"# Agent Smart\n\nThe first challenge is to build an agent using some simple rules that can beat Agent Random. A good place to start is an agent that takes a winning move if it's available and blocks the winning move of an opponent if it's available. And when no winning moves are available, just plays randomly.\n\nFor submission purposes, the function for an agent has to be fully self-contained. So inside the agent_smart function, we'll define a couple of sub-functions. The first, drop_piece, builds a view of what the board will look like if we drop a marker into a certain column. The second, check_winning_move, will check to see if dropping a marker in a certain column will win the game, either for our agent or it's opponent.","d940f4b2":"# Helper Functions","d168a60f":"I've found that using agent_minimax seems to work well but fails when I try to submit it. This is because there's a rule in the game where your agent is disqualified if it takes longer than 5 seconds to make a move.\n\nSo, I'll use a minimax alphabeta agent instead, which is a little quicker. And, importantly, it only seems to be able to satisfy the 5 second rule if N is 2. Once you go to 3 or over, it takes too long.","6363cc26":"Agent smart wins 96 games out of 100 against agent_random. That's good, now agent_smart will be our bechmark for even better agents.\n\nThere are lots more complicated rules we could come up with for agent_smart to make it even better. For example, we might tell it to look to make a connect 3 if it's available or block the connect 3 of an opponent. Well, actually that makes the agent worse. It looks to build connect 3s that can never become connect 4s and so wastes turns. We need an agent that's capable of looking ahead of the move that it's making and instead of making lots of explicit rules, let's use heuristics to let our agent know what kind of moves and situations will be to it's advantage.","4d456200":"# Agent Random\n\nNext, let's define a random agent, similar to the pre-build one that comes with ConnectX. All this agent does is create a list of valid moves i.e which columns is it possible to put a marker in. From this list of valid columns, it chooses one at random.","77a0edb5":"# Agent_minimax\n\nLookahead playes reasonably well but if you watch a few of it's games, you start to see patterns of weakness - it will often give a smart opponent an easy opportunity to fill in the gap in a connect 4. It does this because it doesn't look further ahead than the next move. We need an agent that can look more than one move ahead.\n\nThe minimax algorithm looks multiple steps ahead and builds pictures of potential gameboards and scores them with heuristics. It assumes that the opponent will then make the optimal move, based on the heuristic. Our agent gets to make another move and it again evaulates the next gameboard. This can go on, based on how many steps we want to look ahead.\n\nIt's called minimax because our agent wants to maximise the score and we assume our opponent will try to minimize it. The agent will make decisions based on getting the maximum possible score.","d5691b1d":"# Introduction\n\nMuch like Agent 007's chances of dying as he's tied to a table with a spinning blade slowly but surely making its way towards his crotch, our 'random' agent has little to no chance of connecting 4 against a smart agent or human player. But it's a good place to start. In this notebook, I'll create a few agents and then use them as benchmarks against smarter and more complex agents to see if I can build an agent that's actually capable fo beating a human, or at least acheiving a good place on the leaderboard.","6709ca3d":"We can make two agents play each other with the code.","0ea40f5c":"Now let's see how many times agent_smart beats agent_random in 100 games.","d7e8a04d":"# Agent_lookahead\n\nNext we'll define an agent that looks one move ahead, at every possible move and assigns a score (heuristic) to each possible new configuration of the game board. It will then take the move that gives the best score. The three scenarios we will give scores to are\n\n* **A:** The agent has four discs in a row (the agent won),\n* **B:** The agent filled three spots, and the remaining spot is empty (the agent wins if it fills in the empty spot).\n* **C:** The agent filled two spots, and the remaining two spots are empty (the agent wins if it fills in the empty two spots).\n* **D:** The opponent filled two spots, and the remaining two spots are empty (the opponent wins by filling in the empty two spots).\n* **E:** The opponent filled three spots, and the remaining spot is empty (the opponent wins by filling in the empty spot)."}}