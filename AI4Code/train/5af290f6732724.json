{"cell_type":{"f235f3ce":"code","d9c7cc54":"code","81b94175":"code","cbfe7dde":"code","e548bf8b":"code","feb88ef3":"code","f827577d":"code","0e18937d":"code","008bfeb6":"code","973a4af1":"code","d2f08ed0":"code","1b670339":"code","0cebee17":"markdown","05a67f84":"markdown","e47ba2ed":"markdown","7746a74d":"markdown","e32e1729":"markdown","0ead8c88":"markdown","eb4603a2":"markdown","3359ab95":"markdown","d8379615":"markdown","bb59e680":"markdown"},"source":{"f235f3ce":"import os\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom pathlib import Path \nfrom collections import Counter\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers","d9c7cc54":"!curl -LO https:\/\/github.com\/AakashKumarNain\/CaptchaCracker\/raw\/master\/captcha_images_v2.zip\n!unzip -qq captcha_images_v2.zip","81b94175":"# Path to the data directory\ndata_dir = Path(\".\/captcha_images_v2\/\")\n\n# Get list of all the images\nimages = sorted(list(map(str, list(data_dir.glob(\"*.png\")))))\nlabels = [img.split(os.path.sep)[-1].split(\".png\")[0] for img in images]\ncharacters = set(char for label in labels for char in label)\n\nprint(f\"Number of images found: {len(images)}\")\nprint(f\"Number of labels found: {len(labels)}\")\nprint(f\"Number of unique characters: {len(characters)}\")\nprint(f\"Characters present: {characters}\")","cbfe7dde":"# Batch size for training and validation\nbatch_size = 16\n\n# Desired image dimensions\nimg_width = 200\nimg_height = 50\n\n# Factor by which the image is going to be downsampled by the convolutional blocks.\n# We will be using two convolution blocks and each block will have a pooling layer\n# which downsample the features by a factor of 2.\n# Hence total downsampling factor would be 4.\ndownsample_factor = 4\n\n# Maximum length of any captcha in the dataset\nmax_length = max([len(label) for label in labels])","e548bf8b":"# Mapping characters to integers\nchar_to_num = layers.experimental.preprocessing.StringLookup(\n    vocabulary=list(characters), num_oov_indices=0, mask_token=None\n)\n\n# Mapping integers back to original characters\nnum_to_char = layers.experimental.preprocessing.StringLookup(\n    vocabulary=char_to_num.get_vocabulary(), mask_token=None, invert=True\n)\n\n\ndef split_data(images, labels, train_size=0.9, shuffle=True):\n    # 1. Get the total size of the dataset\n    size = len(images)\n    # 2. Make an indices array and shuffle it, if required\n    indices = np.arange(size)\n    if shuffle:\n        np.random.shuffle(indices)\n    # 3. Get the size of training samples\n    train_samples = int(size * train_size)\n    # 4. Split data into training and validation sets\n    x_train, y_train = images[indices[:train_samples]], labels[indices[:train_samples]]\n    x_valid, y_valid = images[indices[train_samples:]], labels[indices[train_samples:]] \n    return x_train, x_valid, y_train, y_valid\n\ndef encode_single_sample(img_path, label):\n    # 1. Read image\n    img = tf.io.read_file(img_path)\n    # 2. Decode and convert to grayscale\n    img = tf.io.decode_png(img, channels=1)\n    # 3. Convert to float32 in [0, 1] range\n    img = tf.image.convert_image_dtype(img, tf.float32)\n    # 4. Resize to the desired size\n    img = tf.image.resize(img, [img_height, img_width])\n    # 5. Transpose the image because we want the time\n    # dimension to correspond to the width of the image.\n    img = tf.transpose(img, perm=[1, 0, 2])\n    # 6. Map the characters in label to numbers\n    label = char_to_num(tf.strings.unicode_split(label, input_encoding=\"UTF-8\"))\n    # 7. Return a dict as our model is expecting two inputs\n    return {\"image\": img, \"label\": label}","feb88ef3":"# Splitting data into training and validation sets\nX_train, X_valid, y_train, y_valid = split_data(np.array(images), np.array(labels))\n\nprint(f\"X_Train shape: {X_train.shape}\")\nprint(f\"y_Train shape: {y_train.shape}\")\nprint(f\"X_valid shape: {X_valid.shape}\")\nprint(f\"y_valid shape: {y_valid.shape}\")","f827577d":"train_dataset = tf.data.Dataset.from_tensor_slices((X_train, y_train))\ntrain_dataset = (\n    train_dataset.map(\n        encode_single_sample, num_parallel_calls=tf.data.experimental.AUTOTUNE\n    )\n    .batch(batch_size)\n    .prefetch(buffer_size=tf.data.experimental.AUTOTUNE)\n)\n\nvalidation_dataset = tf.data.Dataset.from_tensor_slices((X_valid, y_valid))\nvalidation_dataset = (\n    validation_dataset.map(\n        encode_single_sample, num_parallel_calls=tf.data.experimental.AUTOTUNE\n    )\n    .batch(batch_size)\n    .prefetch(buffer_size=tf.data.experimental.AUTOTUNE)\n)","0e18937d":"_, ax = plt.subplots(4, 4, figsize=(10, 5))\nfor batch in train_dataset.take(1):\n    images = batch[\"image\"]\n    labels = batch[\"label\"]\n    for i in range(16):\n        img = (images[i] * 255).numpy().astype(\"uint8\")\n        label = tf.strings.reduce_join(num_to_char(labels[i])).numpy().decode(\"utf-8\")\n        ax[i \/\/ 4, i % 4].imshow(img[:, :, 0].T, cmap=\"gray\")\n        ax[i \/\/ 4, i % 4].set_title(label)\n        ax[i \/\/ 4, i % 4].axis(\"off\")\nplt.show()","008bfeb6":"class CTCLayer(layers.Layer):\n    def __init__(self, name=None):\n        super().__init__(name=name)\n        self.loss_fn = keras.backend.ctc_batch_cost\n        \n    def call(self, y_true, y_pred):\n        # Compute the training-time loss value and add it\n        # to the layer using `self.add_loss()`.\n        batch_len = tf.cast(tf.shape(y_true)[0], dtype=\"int64\")\n        input_length = tf.cast(tf.shape(y_pred)[1], dtype=\"int64\")\n        label_length = tf.cast(tf.shape(y_true)[1], dtype=\"int64\")\n        \n        input_length = input_length * tf.ones(shape=(batch_len, 1), dtype=\"int64\")\n        label_length = label_length * tf.ones(shape=(batch_len, 1), dtype=\"int64\")\n        \n        loss = self.loss_fn(y_true, y_pred, input_length, label_length)\n        self.add_loss(loss)\n        \n        # At test, just return the computed predictions\n        return y_pred\n    \ndef build_model():\n    # Inputs the model\n    input_img = layers.Input(\n        shape=(img_width, img_height, 1), name=\"image\", dtype=\"float32\"\n    )\n    labels = layers.Input(name=\"label\", shape=(None,), dtype=\"float32\")\n    \n    # First conv block\n    x = layers.Conv2D(32, (3, 3), activation=\"relu\", kernel_initializer=\"he_normal\", padding=\"same\", name=\"Conv1\")(input_img)\n    x = layers.MaxPooling2D((2, 2), name=\"pool1\")(x)\n    \n    # Second conv block\n    x = layers.Conv2D(64, (3, 3), activation=\"relu\", kernel_initializer=\"he_normal\", padding=\"same\", name=\"Conv2\")(x)\n    x = layers.MaxPooling2D((2, 2), name=\"pool2\")(x)\n    \n    # We have used two max pool with pool size and strides 2.\n    # Hence, downsampled feature maps are 4x smaller.\n    # The number of filters in the last layer is 64. \n    # Reshape accordingly before passing the output to the RNN part of the model\n    new_shape = ((img_width \/\/ 4), (img_height \/\/ 4) * 64)\n    x = layers.Reshape(target_shape=new_shape, name=\"reshape\")(x)\n    x = layers.Dense(64, activation=\"relu\", name=\"dense1\")(x)\n    x = layers.Dropout(0.2)(x)\n    \n    # RNNs\n    x = layers.Bidirectional(layers.LSTM(128, return_sequences=True, dropout=0.25))(x)\n    x = layers.Bidirectional(layers.LSTM(64, return_sequences=True, dropout=0.25))(x)\n    \n    # Output layer\n    x = layers.Dense(len(characters) + 1, activation=\"softmax\", name=\"dense2\")(x)\n    \n    # Add CTC layer for calculating CTC loss at each step\n    output = CTCLayer(name=\"ctc_loss\")(labels, x)\n    \n    # Define the model \n    model = keras.models.Model(\n        inputs=[input_img, labels], outputs=output, name=\"ocr_model_v1\"\n    )\n    # Optimizer\n    opt = keras.optimizers.Adam()\n    # Compile the model and return\n    model.compile(optimizer=opt)\n    return model","973a4af1":"# Get the model\n\nmodel = build_model()\nmodel.summary()","d2f08ed0":"epochs = 100\nearly_stopping_patience = 10\n\n# Add early stopping\nearly_stopping = keras.callbacks.EarlyStopping(\n    monitor=\"val_loss\", patience=early_stopping_patience, restore_best_weights=True\n)\n\n# Train the model\nhistory = model.fit(\n    train_dataset, \n    validation_data=validation_dataset,\n    epochs=epochs,\n    callbacks=[early_stopping]\n)","1b670339":"# Get the prediction model by extracting layers till the output layer\nprediction_model = keras.models.Model(\n    model.get_layer(name=\"image\").input, model.get_layer(name=\"dense2\").output\n)\nprediction_model.summary()\n\n# A utility function to decode the output of the network\ndef decode_batch_predictions(pred):\n    input_len = np.ones(pred.shape[0]) * pred.shape[1]\n    # Use greedy search. For complex tasks, you can use beam search\n    results = keras.backend.ctc_decode(pred, input_length=input_len, greedy=True)[0][0][:, : max_length]\n    # Iterate over the results and get back the text\n    output_text = []\n    for res in results:\n        res = tf.strings.reduce_join(num_to_char(res)).numpy().decode(\"utf-8\")\n        output_text.append(res)\n    return output_text\n\n# Let's check results on some validation samples\nfor batch in validation_dataset.take(1):\n    batch_images = batch[\"image\"]\n    batch_labels = batch[\"label\"]\n    \n    preds = prediction_model.predict(batch_images)\n    pred_texts = decode_batch_predictions(preds)\n    \n    orig_texts = []\n    for label in batch_labels:\n        label = tf.strings.reduce_join(num_to_char(label)).numpy().decode(\"utf-8\")\n        orig_texts.append(label)\n        \n    _, ax = plt.subplots(4, 4, figsize=(15, 5))\n    for i in range(len(pred_texts)):\n        img = (batch_images[i, :, :, 0] * 255).numpy().astype(np.uint8)\n        img = img.T\n        title = f\"Prediction: {pred_texts[i]}\"\n        ax[i \/\/ 4, i % 4].imshow(img, cmap=\"gray\")\n        ax[i \/\/ 4, i % 4].set_title(title)\n        ax[i \/\/ 4, i % 4].axis(\"off\")        \nplt.show()","0cebee17":"# Load the data: Captcha Images","05a67f84":"# OCR model for reading Captchas\n\nThis notebook demonstrates a simple OCR model built with the Functional API. Apart from combining CNN and RNN, it also illustrates how you can intantiate a new layer and use it as an \"Endpoint layer\" for implementing CTC loss. ","e47ba2ed":"# Setup","7746a74d":"# Inference","e32e1729":"# Training","0ead8c88":"# Model","eb4603a2":"# Visualize the data","3359ab95":"The dataset contains `1040` captcha files as `png` images. The label for each sample is a string, the name of the file (minus the file extension). We will map each character in the string to an integer for training the model. Similarly, we will need to map the predictions of the model back to strings. ","d8379615":"# Preprocessing","bb59e680":"# Create dataset objects"}}