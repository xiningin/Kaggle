{"cell_type":{"6c2af228":"code","250af529":"code","47fd79d0":"code","fe295473":"code","b2ee8bb4":"code","d0514457":"code","dd039311":"code","45800b03":"code","0ba095c1":"code","8afe883b":"code","a0ffaabc":"code","43f55ab1":"code","73bf6fd2":"code","caf2fd74":"code","8b9e5d15":"code","7eccfd1e":"code","a5fd9ecc":"code","d4403de5":"code","79b3a1a9":"code","bb8d67fc":"code","61ba5afd":"code","7044a1bf":"code","4a1e395a":"code","7fa5ea26":"code","a136d053":"code","a07682ec":"code","668a4905":"code","14d5643d":"code","9f455f25":"code","3a424d9b":"code","137d4c80":"code","53d33b5b":"code","7a838e9c":"code","19e33d60":"code","9fdf7e4d":"code","b6a2b797":"code","04e864fc":"code","06df0bd7":"code","9127551a":"markdown","2fca5633":"markdown","eae53e50":"markdown","25228c8f":"markdown","65c11b18":"markdown","29fe458e":"markdown","013049d5":"markdown","ffec0f01":"markdown","136751ba":"markdown","c201f7b3":"markdown","be051b97":"markdown","d5408650":"markdown","39211e15":"markdown","7ebecb4c":"markdown","d39e0a5c":"markdown","2ed50891":"markdown","a9f9674a":"markdown","0c39db9f":"markdown","587e6674":"markdown","ceb1a1f9":"markdown","f25b7c33":"markdown","5e47599a":"markdown","7d7403e9":"markdown","7c714876":"markdown","9eb5de0d":"markdown","83cbcd4f":"markdown","35d1a1a9":"markdown","4433d9a1":"markdown","538b4b83":"markdown","419bf781":"markdown","c5f4a00d":"markdown","95f30c60":"markdown","99ebc329":"markdown","dfa92148":"markdown","be30d300":"markdown","5d89b4cc":"markdown","47b6254e":"markdown","d28d6ee9":"markdown","1c1528c8":"markdown","bebeafae":"markdown","e4c63389":"markdown"},"source":{"6c2af228":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.style.use('seaborn')","250af529":"data = [\n    {'price': 850000, 'rooms': 4, 'neighborhood': 'Queen Anne'},\n    {'price': 700000, 'rooms': 3, 'neighborhood': 'Fremont'},\n    {'price': 650000, 'rooms': 3, 'neighborhood': 'Wallingford'},\n    {'price': 600000, 'rooms': 2, 'neighborhood': 'Fremont'}\n]","47fd79d0":"{'Queen Anne': 1, 'Fremont': 2, 'Wallingford': 3};","fe295473":"from sklearn.feature_extraction import DictVectorizer\nvec = DictVectorizer(sparse=False, dtype=int)\nvec.fit_transform(data)","b2ee8bb4":"vec.get_feature_names()","d0514457":"import pandas as pd\npd.DataFrame(vec.fit_transform(data),\n             columns=vec.get_feature_names())","dd039311":"vec = DictVectorizer(sparse=True, dtype=int)\nvec.fit_transform(data)","45800b03":"sample = ['problem of evil',\n          'evil queen',\n          'horizon problem']","0ba095c1":"from sklearn.feature_extraction.text import CountVectorizer\n\nvec = CountVectorizer()\nX = vec.fit_transform(sample)\nX","8afe883b":"import pandas as pd\npd.DataFrame(X.toarray(), columns=vec.get_feature_names())","a0ffaabc":"from sklearn.feature_extraction.text import TfidfVectorizer\nvec = TfidfVectorizer()\nX = vec.fit_transform(sample)\npd.DataFrame(X.toarray(), columns=vec.get_feature_names())","43f55ab1":"from sklearn.datasets import fetch_20newsgroups","73bf6fd2":"categories = ['talk.religion.misc', 'soc.religion.christian',\n              'sci.space', 'comp.graphics']\ntrain = fetch_20newsgroups(subset='train', categories=categories)\ntest = fetch_20newsgroups(subset='test', categories=categories)","caf2fd74":"print(train.data[5])","8b9e5d15":"train.target[:5]","7eccfd1e":"train.target_names","a5fd9ecc":"from sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.pipeline import make_pipeline\n\nmodel = make_pipeline(TfidfVectorizer(), MultinomialNB())","d4403de5":"model.fit(train.data, train.target)\nlabels = model.predict(test.data)","79b3a1a9":"from sklearn.metrics import confusion_matrix\nimport seaborn as sns\n\nmat = confusion_matrix(test.target, labels)\nsns.heatmap(mat.T, square=True, annot=True, fmt='d', cbar=False, cmap='Blues',\n            xticklabels=train.target_names, yticklabels=train.target_names)\nplt.xlabel('true label')\nplt.ylabel('predicted label');","bb8d67fc":"def predict_category(s, train=train, model=model):\n    pred = model.predict([s])\n    return train.target_names[pred[0]]","61ba5afd":"predict_category('sending a payload to the ISS')","7044a1bf":"predict_category('discussing islam vs atheism')","4a1e395a":"predict_category('determining the screen resolution')","7fa5ea26":"from skimage import data, color, feature\nimport skimage.data\n\nimage = color.rgb2gray(data.chelsea())\nhog_vec, hog_vis = feature.hog(image, visualize=True)\n\nfig, ax = plt.subplots(1, 2, figsize=(12, 6),\n                       subplot_kw=dict(xticks=[], yticks=[]))\nax[0].imshow(image, cmap='gray')\nax[0].set_title('input image')\n\nax[1].imshow(hog_vis, cmap='binary')\nax[1].set_title('visualization of HOG features');","a136d053":"from sklearn.datasets import fetch_lfw_people\nfaces = fetch_lfw_people()\npositive_patches = faces.images\npositive_patches.shape","a07682ec":"from skimage import data, transform\n\nimgs_to_use = ['camera', 'text', 'coins', 'moon',\n               'page', 'clock', 'immunohistochemistry',\n               'chelsea', 'coffee', 'hubble_deep_field']\nimages = [color.rgb2gray(getattr(data, name)())\n          for name in imgs_to_use]","668a4905":"from sklearn.feature_extraction.image import PatchExtractor\n\ndef extract_patches(img, N, scale=1.0, patch_size=positive_patches[0].shape):\n    extracted_patch_size = tuple((scale * np.array(patch_size)).astype(int))\n    extractor = PatchExtractor(patch_size=extracted_patch_size,\n                               max_patches=N, random_state=0)\n    patches = extractor.transform(img[np.newaxis])\n    if scale != 1:\n        patches = np.array([transform.resize(patch, patch_size, mode='constant')\n                            for patch in patches])\n    return patches\n\nnegative_patches = np.vstack([extract_patches(im, 1000, scale)\n                              for im in images for scale in [0.5, 1.0, 2.0]])\nnegative_patches.shape","14d5643d":"fig, ax = plt.subplots(6, 10)\nfor i, axi in enumerate(ax.flat):\n    axi.imshow(negative_patches[500 * i], cmap='gray')\n    axi.axis('off')","9f455f25":"from itertools import chain\nX_train = np.array([feature.hog(im)\n                    for im in chain(positive_patches,\n                                    negative_patches)])\ny_train = np.zeros(X_train.shape[0])\ny_train[:positive_patches.shape[0]] = 1","3a424d9b":"X_train.shape","137d4c80":"from sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import cross_val_score\n\ncross_val_score(GaussianNB(), X_train, y_train)","53d33b5b":"from sklearn.svm import LinearSVC\nfrom sklearn.model_selection import GridSearchCV\ngrid = GridSearchCV(LinearSVC(), {'C': [1.0, 2.0, 4.0, 8.0]})\ngrid.fit(X_train, y_train)\ngrid.best_score_","7a838e9c":"grid.best_params_","19e33d60":"model = grid.best_estimator_\nmodel.fit(X_train, y_train)","9fdf7e4d":"test_image = skimage.data.astronaut()\ntest_image = skimage.color.rgb2gray(test_image)\ntest_image = skimage.transform.rescale(test_image, 0.5, mode='constant')\ntest_image = test_image[:160, 40:180]\n\nplt.imshow(test_image, cmap='gray')\nplt.axis('off');","b6a2b797":"def sliding_window(img, patch_size=positive_patches[0].shape,\n                   istep=2, jstep=2, scale=1.0):\n    Ni, Nj = (int(scale * s) for s in patch_size)\n    for i in range(0, img.shape[0] - Ni, istep):\n        for j in range(0, img.shape[1] - Ni, jstep):\n            patch = img[i:i + Ni, j:j + Nj]\n            if scale != 1:\n                patch = transform.resize(patch, patch_size)\n            yield (i, j), patch\n            \nindices, patches = zip(*sliding_window(test_image))\npatches_hog = np.array([feature.hog(patch)\n                        for patch in patches])\npatches_hog.shape","04e864fc":"labels = model.predict(patches_hog)\nlabels.sum()","06df0bd7":"fig, ax = plt.subplots()\nax.imshow(test_image, cmap='gray')\nax.axis('off')\n\nNi, Nj = positive_patches[0].shape\nindices = np.array(indices)\n\nfor i, j in indices[labels == 1]:\n    ax.add_patch(plt.Rectangle((j, i), Nj, Ni, edgecolor='red',\n                               alpha=0.3, lw=2, facecolor='none'))","9127551a":"Remember that this is nothing more sophisticated than a simple probability model for the (weighted) frequency of each word in the string; nevertheless, the result is striking.\nEven a very naive algorithm, when used carefully and trained on a large set of high-dimensional data, can be surprisingly effective.","2fca5633":"## 1. Obtain a Set of Positive Training Samples\n\nLet's start by finding some positive training samples that show a variety of faces.\nWe have one easy set of data to work with\u2014-the Labeled Faces in the Wild dataset, which can be downloaded by scikit-learn:","eae53e50":"## 4. Training a Support Vector Machine\n\nNext, we use the tools we have been exploring in this Oriole to create a classifier of thumbnail patches.\nFor such a high-dimensional binary classification task, a linear support vector machine is a good choice.\nWe will use scikit-learn's ``LinearSVC``, because in comparison to ``SVC``, it often has better scaling for a large number of samples.\n\nFirst, though, let's use a simple Gaussian naive Bayes classifier to get a quick baseline:","25228c8f":"The target is a set of numbers encoding which newsgroup the messages belong to:","65c11b18":"We are left with 43,000 training samples in 1,215 dimensions, and we now have our data in a form that we can feed into scikit-learn!","29fe458e":"# Text Features\n\nAnother common need in feature engineering is to convert text to a set of representative numerical values.\nFor example, most automatic mining of social media data relies on some form of encoding the text as numbers.\nOne of the simplest methods of encoding data is by *word counts*: you take each snippet of text, count the occurrences of each word within it, and put the results in a table.\n\nFor example, consider the following set of three phrases:","013049d5":"Let's take a look at classifying some text based on this approach.\n\nWe'll use the *20 newsgroups* dataset, available from the web via scikit-learn's dataset tools:","ffec0f01":"## HOG in Action: A Simple Face Detector\n\nUsing these HOG features, we can build up a simple facial detection algorithm with any scikit-learn estimator; here we will use a linear support vector machine (refer back to _Machine Learning with Scikit-Learn: Support Vector Machines_ if you need a refresher on this).\nThe steps are as follows:\n\n1. Obtain a set of image thumbnails of faces to constitute \"positive\" training samples.\n2. Obtain a set of image thumbnails of non-faces to constitute \"negative\" training samples.\n3. Extract HOG features from these training samples.\n4. Train a linear SVM classifier on these samples.\n5. For an \"unknown\" image, pass a sliding window across the image, using the model to evaluate whether that window contains a face or not.\n6. If detections overlap, combine them into a single window.\n\nLet's go through these steps and try it out.","136751ba":"Many (though not yet all) of the scikit-learn estimators accept such sparse inputs when fitting and evaluating models. ``sklearn.preprocessing.OneHotEncoder`` and ``sklearn.feature_extraction.FeatureHasher`` are two additional tools that scikit-learn includes to support this type of encoding.","c201f7b3":"Let's evaluate this with a confusion matrix:","be051b97":"More interestingly, we can now use this classifier to predict, given some phrase, what general topic the phrase might be referring to.\n\nWe'll use the following quick convenience function:","d5408650":"Next, let's create a window that iterates over patches of this image, and compute HOG features for each patch:","39211e15":"All of the detected patches overlap and found the face in the image!\nNot bad for a few lines of Python.","7ebecb4c":"For a vectorization of this data based on word count, we could construct a column representing the word \"problem,\" the word \"evil,\" the word \"horizon,\" and so on.\nWhile doing this by hand would be possible, the tedium can be avoided by using scikit-learn's ``CountVectorizer``:","d39e0a5c":"We see that on our training data, even a simple naive Bayes algorithm gets us upward of 90% accuracy.\nLet's try the support vector machine, with a grid search over a few choices of the C parameter:","2ed50891":"We can now fit the model to the training data, and predict the labels of the test data:","a9f9674a":"We'll start with the standard imports:","0c39db9f":"## Caveats and Improvements\n\nIf you dig a bit deeper into the preceding code and examples, you'll see that we still have a bit of work before we can claim a production-ready face detector.\nThere are several issues with what we've done, and several improvements that could be made. In particular:\n\n### Our training set, especially for negative features, is not very complete\n\nThe central issue is that there are many face-like textures that are not in the training set, and so our current model is very prone to false positives.\nYou can see this if you try out the above algorithm on the *full* astronaut image: the current model leads to many false detections in other regions of the image.\n\nWe might imagine addressing this by adding a wider variety of images to the negative training set, and this would probably yield some improvement.\nAnother way to address this is to use a more directed approach, such as *hard negative mining*.\nIn hard negative mining, we take a new set of images that our classifier has not seen, find all the patches representing false positives, and explicitly add them as negative instances in the training set before retraining the classifier.\n\n###  Our current pipeline searches at only one scale\n\nAs currently written, our algorithm will miss faces that are not approximately 62\u00d747 pixels.\nThis can be straightforwardly addressed by using sliding windows of a variety of sizes, and resizing each patch with ``skimage.transform.resize`` before feeding it into the model.\nIn fact, the ``sliding_window()`` utility used here is already built with this in mind.\n\n###  We should combine overlapped detection patches\n\nFor a production-ready pipeline, we would prefer not to have 30 detections of the same face, but to somehow reduce overlapping groups of detections down to a single detection.\nThis could be done via an unsupervised clustering approach (mean shift clustering is one good candidate for this), or via a procedural approach like *non-maximum suppression*, an algorithm common in machine vision.\n\n###  The pipeline should be streamlined\n\nOnce we address these issues, it would also be nice to create a more streamlined pipeline for ingesting training images and predicting sliding-window outputs.\nThis is where Python as a data science tool really shines: with a bit of work, we can take our prototype code and package it with a well-designed object-oriented API that gives the user the ability to easily use it.\nI will leave this as a proverbial \"exercise for the reader.\"\n\n###  More recent advances: deep learning\n\nFinally, I should add that HOG and other procedural feature extraction methods for images are no longer state-of-the-art techniques.\nInstead, many modern object detection pipelines use variants of deep neural networks: one way to think of neural networks is that they are an estimator that determines optimal feature extraction strategies from the data, rather than relying on the intuition of the user.\nAn intro to these deep neural net methods is conceptually (and computationally!) beyond the scope of this notebook, although open tools like Google's <a href=\"https:\/\/www.tensorflow.org\/\" target=\"_blank\">TensorFlow<\/a> have recently made deep learning approaches much more accessible than they once were.","587e6674":"There is one clear disadvantage of this approach: if your category has many possible values, this can *greatly* increase the size of your dataset.\nHowever, because the encoded data contains mostly zeros, a sparse output can be a very efficient solution:","ceb1a1f9":"## 5. Find Faces in a New Image\n\nNow that we have this model in place, let's grab a new image and see how the model does.\nWe will use one portion of the astronaut image for simplicity (see a discussion of this below in \"Caveats and Improvements,\" and run a sliding window over it and evaluate each patch:","f25b7c33":"The data consist of the full text content of messages posted to early internet newsgroups. For example:","5e47599a":"You might be tempted to encode this data with a straightforward numerical mapping:","7d7403e9":"In this notebook, we will discuss a few specific examples of engineering features for use in machine learning algorithms, including:\n\n- One-hot encoding for categorical data\n- Frequency-based encoding for textual data\n- Histogram-of-gradient (HOG) features for image data\n\nIn each of these, I will give a brief example of applying these features to a dataset in the course of a machine learning algorithm.\n\nAt the end of this notebook, you will:\n- Understand several common approaches to feature engineering\n- Gain exposure to more examples of Scikit-learn\u2019s API applied to real-world datasets","7c714876":"This ``fit`` step finds our best estimator for detecting the presence of a face in a small image thumbnail.","9eb5de0d":"We see that out of nearly 2,000 patches, we have found 30 detections.\nLet's use the information we have about these patches to show where they lie on our test image, drawing them as rectangles:","83cbcd4f":"## 3. Combine Sets and Extract HOG Features\n\nNow that we have these positive samples and negative samples, we can combine them and compute HOG features.\nThis step takes a little while, because the HOG features involve a nontrivial computation for each image:","35d1a1a9":"# Summary\n\nIn this notebook we've taken a look at a few approaches to *feature engineering*, the process of taking raw data and turning it into the ``n_samples`` x ``n_features`` matrix that we need in order to model the data with scikit-learn. Feature engineering can range from simple (mapping categories to binary columns) to complex (specific operations on images to find gradients and other useful features). This lesson showed a few examples to illustrate how this might be done in practice.","4433d9a1":"Let's use the ``TfidfVectorizer`` and put it in a pipeline with a ``MultinomialNB`` classifier:","538b4b83":"The result is a sparse matrix recording the number of times each word appears; it is easier to inspect if we convert this to a ``DataFrame`` with labeled columns:","419bf781":"# Categorical Features\n\nOne common type of non-numerical data is *categorical* data.\nFor example, imagine you are exploring some data on housing prices, and along with numerical features like \"price\" and \"rooms\", you also have \"neighborhood\" information.\nFor example, your data might look something like this:","c5f4a00d":"There are some issues with this approach, however: the raw word counts lead to features that put too much weight on words that appear very frequently, and this can be suboptimal in some classification algorithms.\nOne approach to fix this is known as *term frequency-inverse document frequency* (*TF\u2013IDF*), which weights the word counts by a measure of how often they appear in the documents.\nThe syntax for computing these features is similar to the previous example:","95f30c60":"We now have 30,000 suitable image patches that do not contain faces.\nLet's take a look at a few of them to get an idea of what they look like:","99ebc329":"Let's take the best estimator and retrain it on the full dataset:","dfa92148":"Notice that the neighborhood column has been expanded into three separate columns, representing the three neighborhood labels, and that each row has a 1 in the column associated with its neighborhood.\nWith these categorical features thus encoded, you can proceed as normal with fitting a scikit-learn model.\n\nTo see the meaning of each column, you can inspect the feature names:","be30d300":"It turns out that this is not generally a useful approach in scikit-learn: the package's models make the fundamental assumption that numerical features reflect algebraic quantities.\nThus, such a mapping would imply, for example, that *Queen Anne < Fremont < Wallingford*, or even that *Wallingford - Queen Anne = Fremont*, which (niche demographic jokes aside) does not make much sense.\n\nIn this case, one proven technique is to use *one-hot encoding*, which effectively creates extra columns indicating the presence or absence of a category with a value of 1 or 0, respectively.\nWhen your data comes as a list of dictionaries, scikit-learn's ``DictVectorizer`` will do this for you:","5d89b4cc":"Our hope is that these would sufficiently cover the space of non-faces that our algorithm is likely to see.","47b6254e":"Finally, we can take these HOG-featured patches and use our model to evaluate whether each patch contains a face:","d28d6ee9":"## Example: Text Classification","1c1528c8":"This gives us a sample of 13,000 face images to use for training.","bebeafae":"# Image Features\n\nWe've seen an approach to image classification that relies on the pixels themselves as features.\nThe problem is that the relationships between pixels are often more meaningful: for example, lines and gradients tell us much more about the content of the image, and are much more robust to lighting levels and other incidental differences between images.\n\nFor more complicated tasks involving images, it can be useful to derive other features that are more informative.\nThere are many approaches to this, but the one we'll demo here is known as *histograms of gradients* (HOG).\nHOG involves the following steps:\n\n1. Optionally prenormalize images. This leads to features that resist dependence on variations in illumination.\n2. Convolve the image with two filters that are sensitive to horizontal and vertical brightness gradients. These capture edge, contour, and texture information.\n3. Subdivide the image into cells of a predetermined size, and compute a histogram of the gradient orientations within each cell.\n4. Normalize the histograms in each cell by comparing to the block of neighboring cells. This further suppresses the effect of illumination across the image.\n5. Construct a one-dimensional feature vector from the information in each cell.\n\nA fast HOG extractor is built into the scikit-image project, and we can try it out relatively quickly and visualize the oriented gradients within each cell:","e4c63389":"## 2. Obtain a Set of Negative Training Samples\n\nNext, we need a set of similarly sized thumbnails that *do not* have a face in them.\nOne way to do this is to take any corpus of input images and extract thumbnails from them at a variety of scales.\nHere we can use some of the images shipped with scikit-image, along with scikit-learn's ``PatchExtractor``:"}}