{"cell_type":{"5ced33cf":"code","5dba71b3":"code","618e84cf":"code","542f08fd":"code","0100ee74":"code","419c919b":"code","bcb0037f":"code","efcf29d8":"code","d6798f60":"code","e53a1b2c":"code","e39c2e49":"code","825d64e8":"code","48f0d203":"code","d2653dee":"code","04d41f62":"code","d498e5e9":"code","bd573812":"code","99ee692e":"code","8614f177":"code","9b9566d0":"code","dfe8479f":"code","fff20657":"code","24b5cba5":"code","f2fa3ba7":"code","ce4ea335":"code","50cc5ee9":"code","bf09e91b":"code","e1407b90":"code","c32c5b4f":"code","62e2d4b1":"markdown","8da30361":"markdown","5fae9c5a":"markdown","1f4ca527":"markdown"},"source":{"5ced33cf":"import numpy as np\nimport pandas as pd\nimport tensorflow as tf","5dba71b3":"dataframe = pd.read_csv('http:\/\/storage.googleapis.com\/download.tensorflow.org\/data\/ecg.csv', header=None)\nraw_data = dataframe.values\ndataframe.head()","618e84cf":"dataframe.shape","542f08fd":"from sklearn.model_selection import train_test_split\nlabels = raw_data[:, -1]\n\ndata = raw_data[:, 0:-1]\n\ntrain_data, test_data, train_labels, test_labels = train_test_split(\n    data, labels, test_size=0.2, random_state=21\n)","0100ee74":"min_val = tf.reduce_min(train_data)\nmax_val = tf.reduce_max(train_data)\n\ntrain_data = (train_data - min_val) \/ (max_val - min_val)\ntest_data = (test_data - min_val) \/ (max_val - min_val)\n\ntrain_data = tf.cast(train_data, tf.float32)\ntest_data = tf.cast(test_data, tf.float32)","419c919b":"train_labels = train_labels.astype(bool)\ntest_labels = test_labels.astype(bool)\n\nnormal_train_data = train_data[train_labels]\nnormal_test_data = test_data[test_labels]\n\nanomalous_train_data = train_data[~train_labels]\nanomalous_test_data = test_data[~test_labels]","bcb0037f":"import matplotlib.pyplot as plt\n\nplt.grid()\nplt.plot(np.arange(140), normal_train_data[0])\nplt.title(\"A Normal ECG\")\nplt.show()","efcf29d8":"plt.grid()\nplt.plot(np.arange(140), anomalous_train_data[0])\nplt.title(\"An Anomalous ECG\")\nplt.show()","d6798f60":"from tensorflow.keras.models import Model\nfrom tensorflow.keras import layers, losses\n\nclass AnomalyDetector(Model):\n    def __init__(self):\n        super(AnomalyDetector, self).__init__()\n        self.encoder = tf.keras.Sequential([\n          layers.Dense(32, activation=\"relu\"),\n          layers.Dense(16, activation=\"relu\"),\n          layers.Dense(8, activation=\"relu\")])\n\n        self.decoder = tf.keras.Sequential([\n          layers.Dense(16, activation=\"relu\"),\n          layers.Dense(32, activation=\"relu\"),\n          layers.Dense(140, activation=\"sigmoid\")])\n\n    def call(self, x):\n        encoded = self.encoder(x)\n        decoded = self.decoder(encoded)\n        return decoded","e53a1b2c":"autoencoder = AnomalyDetector()\nautoencoder.compile(optimizer='adam', loss='mae')","e39c2e49":"history = autoencoder.fit(normal_train_data, normal_train_data, \n          epochs=20, \n          batch_size=512,\n          validation_data=(test_data, test_data),\n          shuffle=True)","825d64e8":"plt.plot(history.history[\"loss\"], label=\"Training Loss\")\nplt.plot(history.history[\"val_loss\"], label=\"Validation Loss\")\nplt.legend()","48f0d203":"encoded_data = autoencoder.encoder(normal_test_data).numpy()\ndecoded_data = autoencoder.decoder(encoded_data).numpy()\n\nplt.plot(normal_test_data[0], 'b')\nplt.plot(decoded_data[0], 'r')\nplt.fill_between(np.arange(140), decoded_data[0], normal_test_data[0], color='lightcoral')\nplt.legend(labels=[\"Input\", \"Reconstruction\", \"Error\"])\nplt.show()","d2653dee":"encoded_data = autoencoder.encoder(anomalous_test_data).numpy()\ndecoded_data = autoencoder.decoder(encoded_data).numpy()\n\nplt.plot(anomalous_test_data[0], 'b')\nplt.plot(decoded_data[0], 'r')\nplt.fill_between(np.arange(140), decoded_data[0], anomalous_test_data[0], color='lightcoral')\nplt.legend(labels=[\"Input\", \"Reconstruction\", \"Error\"])\nplt.show()","04d41f62":"reconstructions = autoencoder.predict(normal_train_data)\ntrain_loss = tf.keras.losses.mae(reconstructions, normal_train_data)\n\nplt.hist(train_loss[None,:], bins=50)\nplt.xlabel(\"Train loss\")\nplt.ylabel(\"No of examples\")\nplt.show()","d498e5e9":"threshold = np.mean(train_loss) + np.std(train_loss)\nprint(\"Threshold: \", threshold)","bd573812":"reconstructions = autoencoder.predict(anomalous_test_data)\ntest_loss = tf.keras.losses.mae(reconstructions, anomalous_test_data)\n\nplt.hist(test_loss[None, :], bins=50)\nplt.xlabel(\"Test loss\")\nplt.ylabel(\"No of examples\")\nplt.show()","99ee692e":"def predict(model, data, threshold):\n    reconstructions = model(data)\n    loss = tf.keras.losses.mae(reconstructions, data)\n    return tf.math.less(loss, threshold)\n\ndef print_stats(predictions, labels):\n    print(\"Accuracy = {}\".format(accuracy_score(labels, predictions)))\n    print(\"Precision = {}\".format(precision_score(labels, predictions)))\n    print(\"Recall = {}\".format(recall_score(labels, predictions)))\n    print(\"F1 = {}\".format(f1_score(labels, predictions)))","8614f177":"from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\n\nreconstructions = autoencoder(test_data)\nloss = tf.keras.losses.mae(reconstructions, test_data)\npreds = tf.math.less(loss, threshold)\nprint_stats(preds, test_labels)","9b9566d0":"from optuna import Trial\nimport gc\nimport optuna\n\ndef objective(trial):\n    reconstructions = autoencoder(test_data)\n    loss = tf.keras.losses.mae(reconstructions, test_data)\n    tresh = trial.suggest_float(\"treshold\", 0, 2)\n    preds_opt = tf.math.less(loss, tresh)\n    metric = f1_score(test_labels, preds_opt)\n    return metric","dfe8479f":"study = optuna.create_study(\n    direction=\"maximize\",\n)\nstudy.optimize(objective, n_trials=200)","fff20657":"new_treshhold = study.best_params['treshold']\nnew_preds = tf.math.less(loss, new_treshhold)\nprint_stats(new_preds, test_labels)","24b5cba5":"pd.Series(train_labels).value_counts(1)","f2fa3ba7":"from tensorflow.keras.layers import LSTM, Bidirectional\ndef build_lstm_model(data):\n    \n    sequence_input = layers.Input(shape=(data.shape[1], 1,), dtype='float32')\n    \n    x = Bidirectional(LSTM(64, return_sequences=False))(sequence_input)    \n    x = layers.Dense(32, activation='elu')(x)\n    \n    out = layers.Dense(1, activation='sigmoid', name='output')(x)\n    \n    model = Model(inputs=sequence_input, outputs=out)\n    model.compile(loss='binary_crossentropy',\n                  optimizer=tf.keras.optimizers.Adam(lr=3e-5),\n                  metrics=tf.keras.metrics.AUC(name='roc-auc'))\n    \n    return model","ce4ea335":"rnn_train = np.reshape(train_data, (train_data.shape[0], train_data.shape[1], 1))\nrnn_test = np.reshape(test_data, (test_data.shape[0], test_data.shape[1], 1))\nrnn_train.shape","50cc5ee9":"rnn = build_lstm_model(rnn_train)\nrnn.summary()","bf09e91b":"history = rnn.fit(rnn_train, train_labels, \n          epochs=20, \n          batch_size=512,\n          validation_data=(rnn_test, test_labels),\n          shuffle=True)","e1407b90":"rnn_preds = rnn.predict(rnn_test, verbose=1).flatten()\nrnn_preds.shape","c32c5b4f":"new_rnn_preds = (rnn_preds>0.579).astype(int)\nprint_stats(new_rnn_preds, test_labels)","62e2d4b1":"# Part 1","8da30361":"# Part 2","5fae9c5a":"# Part 4","1f4ca527":"# Part 3"}}