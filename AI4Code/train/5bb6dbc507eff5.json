{"cell_type":{"f9aad3d5":"code","ff4f778b":"code","5d437d47":"code","c2bac82b":"code","6a261d15":"code","875a7716":"code","6ff7bbb8":"code","0a83f858":"code","e140f203":"code","c8eb9347":"code","bb826fc1":"code","50902fc8":"code","b7c2eb05":"markdown","1218a846":"markdown","c455e893":"markdown","aabbc28f":"markdown","f792ec18":"markdown","1420476c":"markdown","b5ee441c":"markdown","2733ce58":"markdown","1358c805":"markdown","95976001":"markdown","e806804d":"markdown","f566b5c2":"markdown","4a982104":"markdown","cf99bb4a":"markdown","89096d0c":"markdown","866fd1ce":"markdown","5b7b9d1e":"markdown","df456582":"markdown","e7fde561":"markdown","3e1cd2a4":"markdown"},"source":{"f9aad3d5":"print(\"Hello World\")","ff4f778b":"print('Hello World')\nprint(\"Hello World\")","5d437d47":"# this is a comment, it will be ignored by the computer\nprint(\"Comments are very useful!\")","c2bac82b":"# store a short string or DNA sequence in the variable my_dna\nmy_dna = \"ATGCGTA\"\n\n# store a short DNA sequence in the variable my_dna\nmy_dna = \"ATGCGTA\"\n\n# now print the DNA sequence\nprint(my_dna)\nprint(\"==========================\")\n\n# change the value of my_dna\nmy_dna = \"TGGTCCA\"\n\n# store a short DNA sequence in the variable banana\nbanana = \"ATGCGTA\"\n\n# now print the DNA sequence\nprint(banana)\nprint(\"==========================\")","6a261d15":"# store a number in a variable\napple = 4\nbanana = 5\ntotal_amount = 20\n\n# calculate total of 1 apple and 1 banana\nsum_of_ab = apple + banana\nprint(\"1 apple + 1 banana = \" + str(sum_of_ab)) # str allows us to print\nprint(\"==================================\")\n\n# calculate cost of 3 apples\ncost_3a = 3*apple\nprint(\"3 apples = \" + str(cost_3a)) \nprint(\"==================================\")\n\n# calculate how many bananas you can buy with the total money given\nnum_of_b = total_amount\/banana\nprint(\"Number of bananas we can buy: \" + str(num_of_b))\nprint(\"==================================\")","875a7716":"## -------------------------------------------------------------------\n\n## STRING CONCATENTATION\n\n## adding strings together and printing\nmy_dna = \"AATT\" + \"GGCC\"\nprint(my_dna)\nprint(\"==========================\")\n\nupstream = \"AAA\"\nmy_dna = upstream + \"ATGC\"\n# my_dna is now \"AAAATGC\"\nprint(my_dna)\nprint(\"==========================\")\n\nupstream = \"AAA\"\ndownstream = \"GGG\"\nmy_dna = upstream + \"ATGC\" + downstream\n# my_dna is now \"AAAATGCGGG\"\nprint(my_dna)\nprint(\"==========================\")\n\n## -------------------------------------------------------------------\n\n# CHANGING CASE\n\n# store the DNA sequence in a variable\nmy_dna = \"ATGCGAGT\"\n\n# calculate the length of the sequence and store it in a variable\ndna_length = len(my_dna) # 8\n\n# print a message telling us the DNA sequence length\nprint(\"The length of the DNA sequence is \" + str(dna_length)) #str() converts the number into a string for printing\nprint(\"==========================\")\n\n# alternatively\nprint(str(len(my_dna))) #used in more complex programs\nprint(\"==========================\")\n\n# --------------------------------------------------------------\n\nnumber = 3 + int('4') #int() converts string to number\n# number is now 7\nprint(number)\nprint(\"==========================\")\n\n\n# --------------------------------------------------------------\n\nmy_dna = \"ATGC\" #atgc\n\n# print the variable\nprint(\"before: \" + my_dna)\n\n# run the lower method and store the result\nlowercase_dna = my_dna.lower() #lower() method changes case; only works on strings\n\n# print the variable again\nprint(\"after: \" + lowercase_dna)\nprint(\"==========================\")\n\n\n# --------------------------------------------------------------------------\n\n# REPLACEMENT\n\nprotein = \"vlspadktnv\"\n\n# replace valine with tyrosine\nprint(protein.replace(\"v\", \"y\"))\n\n# we can replace more than one character\nprint(protein.replace(\"vls\", \"ymt\"))\n\n# the original variable is not affected\nprint(protein)\nprint(\"==========================\")\n\n\n# ------------------------------------------------------\n\n# EXTRACTING PART OF A STRING\n\n# The positions of a string start from 0 (i.e DNA has the letter 'D' at index 0, 'N' at index 1, etc.)\n\nprotein = \"vlspadktnv\"\n\n# print positions three to five\nprint(protein[3:5])\n\n# positions start at zero, not one\nprint(protein[:6])\n\n# if we miss out the last number, it goes to the end of the string\nprint(protein[2:])\n\nprotein = \"vlspadktnv\"\nfirst_residue = protein[2] #uses index 2 of the string\nprint(first_residue)\nprint(\"==========================\")\n\n\n# ------------------------------------------------------\n\n## SUBSTRINGS\n\nprotein = \"vlspadktnv\"\n# count amino acid residues\n# count() counts the occurance of object defined in the string\nvaline_count = protein.count('v')\nlsp_count = protein.count('lsp')\ntryptophan_count = protein.count('w')\n\n# now print the counts\nprint(\"valines: \" + str(valine_count))\nprint(\"lsp: \" + str(lsp_count))\nprint(\"tryptophans: \" + str(tryptophan_count))\n\n\n# find the number of time each substring appears\nprotein = \"vlspadktnv\" \nprint(str(protein.find('p'))) \nprint(str(protein.find('kt'))) \nprint(str(protein.find('w')))\nprint(\"==========================\")","6ff7bbb8":"# CREATING LISTS AND RETRIEVING ELEMENTS \n\n# create lists\nshopping_list = [\"Banana\", \"Apple\", \"Cookie\"] # string list\nages = [10, 24, 32] # number lists\n# can be different type of lists\n\n# each item in list is called an element and has an index\nshopping_list = [\"Banana\", \"Apple\", \"Cookie\"]\nages = [10, 24, 32]\nprint(shopping_list[2]) #list[index] finds what value is at index\nfirst_age = ages[2] \n\n# use the index() method to find an index \nshopping_list = [\"Banana\", \"Apple\", \"Cookie\"]\nitem_index = shopping_list.index(\"Apple\")\n# chimp_index is now 1\n\n# index can't be negative \n\nbrands = [\"Thrifty\",\"Baskin Robbins\", \"Ben and Jerry's\", \"Blue Bell\", \"Bonnie Doon\", \"Breyer's\"]\nbottom_brands = brands[2:5] # index 2 to index 5 is printed\n# lower ranks are class, order and family\n\nshopping_list = [\"Banana\", \"Apple\", \"Cookie\"]\nprint(shopping_list)\nshopping_list.append(\"Ice Cream\") # adds item to the end of the list\nprint(shopping_list)\n\n# WORKING WITH LIST ELEMENTS\n\nshopping_list = [\"Banana\", \"Apple\", \"Cookie\"]\nprint(\"There are \" + str(len(shopping_list)) + \" items\")\nshopping_list.append(\"Ice Cream\")\nprint(\"Now there are \" + str(len(shopping_list)) + \" items\") \n\n# adding lists\nshopping_list = [\"Banana\", \"Apple\", \"Cookie\"]\nnew_items = [\"Ice Cream\", \"Pear\"]\ncombined = shopping_list + new_items\n\nprint(str(len(shopping_list)) + \" items\")\nprint(str(len(new_items)) + \" new items\")\nprint(str(len(combined)) + \" total items\")\n\nbrands = [\"Thrifty\",\"Baskin Robbins\", \"Ben and Jerry's\", \"Blue Bell\", \"Bonnie Doon\", \"Breyer's\"]\nprint(\"at the start : \" + str(brands))\n \nbrands.reverse() # reverses lists\nprint(\"after reversing : \" + str(brands))\n\nbrands.sort() # sorts list in alphabetical order\nprint(\"after sorting : \" + str(brands))\n\n# WRITING A LOOP\nshopping_list = [\"Banana\", \"Apple\", \"Cookie\"]\n\nprint(shopping_list[0] + \" is an item\")\nprint(shopping_list[1] + \" is an item\")\nprint(shopping_list[2] + \" is an item\")\n\n# for loop to do the same thing as above ^\nfor item in shopping_list:\n    print(item + \" is an item\")\n    \n# USING A STRING AS A LIST\n\n# iterating through a string as represented by a list\nname = \"python\"\nfor character in name:\n    print(\"one character is \" + character)\n\n    \nnames = \"john,bob,melinda,william\"\nspecies = names.split(\",\") #',' = delimeter, whenever it sees the delimeter, it splits the string\nprint(str(species))\n\n## range loops\nfor i in range(5):\n    print(\"Doing important work. i =\", i)\n\nfor i in range(3, 8):\n    print(\"Doing important work. i =\", i)\n    \nfor i in range(2, 14, 4):\n    print(\"Doing important work. i =\", i)\n    \n#while loops\ni = 0\nwhile i < 10:\n    print(i, end=' ')\n    i += 1 # increase the value of i by 1","0a83f858":"## IF STATEMENTS\n\nhappiness_level = 125\nif happiness_level > 100: # condition definition\n    print(\"person is happy\") # what happens if the condition is true?\n    \nnames = ['Yash', 'William', 'Maria', 'Annie', 'Andrew', 'Chris'] \nfor name in names: # checks every element in the list\n    if name.startswith('A'): # checks for if it starts with an 'a'\n        print(name) # what to do if it starts with an 'a'\n        \n# ELSE STATEMENTS\n        \nhappiness_level = 125\nif happiness_level > 100: # condition\n    print(\"person is happy\") # what happens if code is true\nelse: # if all the 'if' conditions fail, result to this code\n    print(\"person isn't happy\") # what happens if code is true\n    \nnames = ['Yash', 'William', 'Maria', 'Annie', 'Andrew', 'Chris'] \n\nfor name in names: # checks through every element of the list\n    if name.startswith('a'): # check if starts with an 'a'\n        print(name + \"\\n\") # what happens if it starts with an 'a'\n    else: # if none of the 'if' conditions work\n        print(name + \"\\n\")  # what happens if else activates\n    \n# ELIF STATEMENTS\n\nfor name in names:\n    if name.startswith('a'): # if condition (main condition)\n        print(name + \"\\n\")\n    elif name.startswith('b'): # alternate conditions if previous conditions don't work\n        print(name + \"\\n\")\n    elif name.startswith('c'):\n        print(name + \"\\n\")\n    elif name.startswith('d'):\n        print(name + \"\\n\")\n    elif name.startswith('e'):\n        print(name + \"\\n\")\n    else: # if all conditions don't work (default)\n        print(name + \"\\n\")\n    \n# WHILE LOOPS\n\ncount = 0\nwhile count<10: # iterates till this condtion is false (while it is true)\n    print(count)\n    count = count + 1 # increases the count value to make it eventually false\n\n# COMPLEX CONDITIONS\n\n# nested if statements\nnames = ['Yash', 'William', 'Maria', 'Annie', 'Andrew', 'Chris'] \nfor name in names:\n    if name.startswith('a'):\n        if name.endswith('3'): # if elements that start with a end with 3\n            print(name)\n            \n# and conditions\nnames = ['Yash', 'William', 'Maria', 'Annie', 'Andrew', 'Chris'] \nfor name in names:\n    if name.startswith('a') and name.endswith('3'): # checks if both conditions are true\n        print(name)\n\n# or conditions\nnames = ['Yash', 'William', 'Maria', 'Annie', 'Andrew', 'Chris'] \nfor name in names:\n    if name.startswith('a') or name.startswith('b'): # checks if either condition is true\n        print(name)\n\n# compound conditional expressions\nnames = ['Yash', 'William', 'Maria', 'Annie', 'Andrew', 'Chris'] \nfor name in names:\n    if (name.startswith('a') or name.startswith('b')) and name.endswith('4'): \n        print(name)\n\nnames = ['Yash', 'William', 'Maria', 'Annie', 'Andrew', 'Chris'] \nfor name in names:\n    if name.startswith('a') and not name.endswith('6'): # not = opposite condition\n        print(name)\n\n# and = both conditions true; or = 1 of the conditions true; not = opposite condition","e140f203":"import Bio # this is how you import a module","c8eb9347":"#Biopython EXAMPLE\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport Bio\nfrom Bio.Seq import Seq\nfrom Bio.SeqUtils import GC\nDNA = Seq(\"AGTACACTGGTT\")\nprint(DNA)\nprint(DNA + \" - Sequence\")\nprint(DNA.complement() + \" - Complement\")\nprint(DNA.reverse_complement() + \" - Reverse Complement\")\nprint(len(DNA))\nprint(\"First Letter: \" + DNA[0])\nprint(\"Third Letter: \" + DNA[2])\nprint(\"Last Letter: \" + DNA[-1])\nprint(DNA.count(\"AC\"))\nDNAcount = (DNA.count(\"A\")\/len(DNA))\nprint(DNAcount*100)\nprint(\"GC% Percent:\\t\" + str(GC(DNA)))\nmRNA = DNA.transcribe()\nprint(mRNA)\nprotein = mRNA.translate()\nprint(protein)","bb826fc1":"# DEFINING FUNCTION\n\ndef get_at_content(dna): # defining function\n    length = len(dna) \n    a_count = dna.upper().count('A')\n    t_count = dna.upper().count('T') \n    at_content = (a_count + t_count) \/ length \n    return round(at_content, 2) \n\nmy_at_content = get_at_content(\"ATGCGCGATCGATCGAATCG\") # get_at_content(dna) is how you call a function\nprint(str(my_at_content))\nprint(get_at_content(\"ATGCATGCAACTGTAGC\"))\nprint(get_at_content(\"aactgtagctagctagcagcgta\"))\n\n\ndef get_at_content(dna, sig_figs): # defining function with multiple parameters (arguments required to create function)\n    length = len(dna) \n    a_count = dna.upper().count('A') \n    t_count = dna.upper().count('T') \n    at_content = (a_count + t_count) \/ length \n    return round(at_content, sig_figs) \n\ntest_dna = \"ATGCATGCAACTGTAGC\"\nprint(get_at_content(test_dna, 1)) # calling functions w a DNA strand and rounding sig figures\nprint(get_at_content(test_dna, 2))\nprint(get_at_content(test_dna, 3))\n\n# ENCAPSULATION\n# Encapsulation just means dividing up a complex program into little bits which we can work on independently. \n\n# Functions don't have to always take an argument\ndef get_a_number(): # basic example\n    return 42\n\n# UNCOMMENT BELOW DURING DEMO\n# def get_at_content(): #harder example of function that doesn't take in arguments\n#     dna = \"ACTGATGCTAGCTA\"\n#     length = len(dna) \n#     a_count = dna.upper().count('A') \n#     t_count = dna.upper().count('T') \n#     at_content = (a_count + t_count) \/ length \n#     return round(at_content, 2)\n\n## You can call functions with \"keywords\" - usually used to show what each parameter is used for and mean\nget_at_content(dna=\"ATCGTGACTCG\", sig_figs=2)\n\n# Functions can start off with defaults\ndef get_at_content(dna, sig_figs=2):\u2776\n    length = len(dna) \n    a_count = dna.upper().count('A') \n    t_count = dna.upper().count('T') \n    at_content = (a_count + t_count) \/ length \n    return round(at_content, sig_figs)\n\n# any call of this function until changed\/redefined will default to 2 sig figs\n\n## TESTING FUNCTIONS\nassert get_at_content(\"ATGC\") == 0.5\n## Assertions allow us to check if the function is actually working\n# assert <function call> == <expected output>\n\n# test suites\nassert get_at_content(\"A\") == 1\nassert get_at_content(\"G\") == 0\nassert get_at_content(\"ATGC\") == 0.5\nassert get_at_content(\"AGG\") == 0.33\nassert get_at_content(\"AGG\", 1) == 0.3\nassert get_at_content(\"AGG\", 5) == 0.33333\n\n","50902fc8":"# CREATING DICTIONARIES\n\nenzymes = { 'EcoRI':r'GAATTC','AvaII':r'GG(A|T)CC', 'BisI':r'GC[ATGC]GC' }\n\n# usually written something like this\nenzymes = { \n    'EcoRI' : r'GAATTC', \n    'AvaII' : r'GG(A|T)CC', \n    'BisI'  : r'GC[ATGC]GC' \n}\n\nprint(enzymes['BisI']) # allows you to print value associated with this key\n\n## BUILDING DICTIONARIES\n\nenzymes = {} # creates empty dictionary\nenzymes['EcoRI'] = r'GAATTC' # adds a value (GAATTC) at a new key (EcoRI)\nenzymes['BisI'] =  r'GC[ATGC]GC'\n\n# removes the EcoRI enzyme from the dictionary using the key\nenzymes.pop('EcoRI') # purpose of pop() method\n\n## ITERATING OVER DICTIONARY\n\nfor e in enzymes:\n    print(e)\n\n# creating dictionary through iteration\ndna = \"AATGATGAACGAC\" \nbases = ['A','T','G','C'] \nall_counts = {} \nfor base1 in bases: \n    for base2 in bases: \n        dinucleotide = base1 + base2 \n        count = dna.count(dinucleotide) \n        if count > 0: \n            all_counts[dinucleotide] = count\n\nprint(all_counts.keys()) # prints out all keys in a dictionary\n\nfor dinucleotide in all_counts.keys(): # iterates through keys\/entire dictionary\n    if all_counts.get(dinucleotide) == 2:\n        print(dinucleotide)\n        \nfor dinucleotide in sorted(all_counts.keys()): # sorted() sorts dictionary before processing it\n    if all_counts.get(dinucleotide) == 2:\n        print(dinucleotide)\n\n# iterating over full items\nfor key, value in my_dict.items(): # iterate giving you key and value\n    # do something with key and value \n      \nprint(all_counts.get('AT')) # gets value of key","b7c2eb05":"# Functions\n\nSimplifies code by allowing certain items to be run and typed out more simply.","1218a846":"# String Manipulation\nWork with strings to manipulate and change them to how you like them!","c455e893":"# MODULES IN PYTHON\n\nImporting libraries allow you to apply different syntax to simplify things for certain applications, such as Biopython.","aabbc28f":"print() is the name of a function, which tells Python what to do. In this case, the print() function is telling Python to print a message on the Console. We will talk more about functions later\n\n\"Hello World\" is the argument. This is what is going to get printed out. The arguments tell Python what we need to do more specifically.\n\nQuotes are important because they define the data type that the print function takes in or strings. Strings are words essentially. ","f792ec18":"## Comments","1420476c":"# Variables\/Math Operations\n* Variables = places or keywords that can be accessed that hold some form of data (string\/words, int\/numbers)\n* Strings are essentially just words as seen above\n    * Many things you can do to manipulate and add strings\n* Integers = numbers that you can manipulate\n  ","b5ee441c":"### Why Are Comments Important?\n\n* Provides explanation of code \n* Makes documenting easier\n    * Reminds to update documentation\n* Gives you hints about the purpose of code","2733ce58":"# Conditional Statements\n\nBiology detects and classifies using computational decisions expressed by conditionals","1358c805":"# Table of Contents\/What are We Going to Go Over\n\n1. Printing Text\/Comments\n2. Variables\/Math Operations\n3. String Manipulation\n4. Iteration\/Lists\n5. Conditionals\n6. Imports\/Libraries\n7. Introduction to Biopython\n8. Functions\n9. Dictionaries\/Lists","95976001":"## Printing Messages to Screen","e806804d":"[Truth tables](https:\/\/i.ytimg.com\/vi\/o8vXoW-HTeA\/maxresdefault.jpg) are really good at figuring out logic needed for certain programs.","f566b5c2":"## Why Python\n\n* Used in a lot of biology\n    * Data analysis (lots of data in biology)\n    * Image Analysis (detecting diseases using images, etc)\n* Growing popularity in industry\n* Common programming language\n* Can be applied in mostly any medium\n* Good language to jump into programming with\n    * Consistent syntax \n    * Good set of libraries\n    * One of the most readable languages\n    ","4a982104":"**Be careful of indentation errors!**","cf99bb4a":"# Iteration\/Lists\n\n## Why?\n\nLoops allow iteration through data to access","89096d0c":"## What will You Need for Camp for Python?\n\nJust a [Kaggle](http:\/\/kaggle.com) account!","866fd1ce":"# Printing and Manipulating Text","5b7b9d1e":"# Introduction to Biopython\n","df456582":"**Be careful about what you are typing. Otherwise, you will get errors.**","e7fde561":"# Dictionaries\n\nAllows you to categorize and associate different values and keys to each other. Allows for paired data.\n\nA key is associated to a value, similar to how an index is associated to a value. However, the key is customizable and not set by Python.","3e1cd2a4":"## Why do We Care about Text?\n\nWhile traditional programming deals a lot with different data types, such as numbers, booleans, and more, biological programming often deals with text. However, biological programming also does deal with numbers and other types of data."}}