{"cell_type":{"6278a7cd":"code","50fb3795":"code","76c703df":"code","f44f89b7":"code","4b679756":"code","fbdf5ed2":"code","e6a435e5":"code","3c6d7a25":"code","fc4ae973":"code","cd028334":"markdown","f4a0c20c":"markdown","e488a16d":"markdown","799b394b":"markdown","3c9b94a8":"markdown","bb6f7224":"markdown","45f530da":"markdown","6447284a":"markdown","4173cb93":"markdown"},"source":{"6278a7cd":"import numpy as np\nimport pandas as pd\nimport math\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets.samples_generator import make_blobs\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import MinMaxScaler","50fb3795":"random_int = np.random.randint(1,200)\nmax_samples = 300\nrand_center = np.random.randint(1,30)\nrand_box = np.random.randint(8,20)\n\nX, y = make_blobs(n_samples=max_samples, \n                  centers=rand_center, \n                  cluster_std=1,\n                  center_box=(-(rand_box),rand_box),\n                  random_state=random_int)\n\nplt.scatter(X[:,0], X[:,1])\nprint(X.shape)\nprint(y.shape)","76c703df":"wcss = []\nmax_iteration = 300\ndf = pd.DataFrame(X)\nmax_range = 15\nK = range(1, max_range)\n\npoints = []\nfor i in K: \n    kmeans = KMeans(n_clusters=i, \n                    init='k-means++', \n                    max_iter=max_iteration,\n                    n_init=10, \n                    random_state=random_int)\n    kmeans.fit(df)\n    wcss.append(kmeans.inertia_)\n    point = {'x': i, 'y': kmeans.inertia_}\n    points.append(point)\n    \n    \nplt.plot(K, wcss,'bx-')\nplt.title('TRAINING MODEL')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\n\nplt.show()","f44f89b7":"plt.plot(K, wcss,'bx-')\nfirst_to_last = [points[0],points[max_range-2]]\ndf_ftl = pd.DataFrame(first_to_last)\nplt.plot([K[0],K[13]],[wcss[0],wcss[13]], 'ro-')\nplt.title('Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')","4b679756":"#thank you https:\/\/www.youtube.com\/watch?v=IEBsrUQ4eMc for the help\ndef calc_distance_from_line(x1,y1,a,b,c):\n    distance = abs((a*x1+b*y1+c)) \/ (math.sqrt(a*a+b*b))\n    return distance","fbdf5ed2":"a = wcss[0] - wcss[max_range-2]\nb = K[max_range-2] - K[0]\nc1 = K[0] * wcss[max_range-2]\nc2 = K[max_range-2] * wcss[0]\nc = c1-c2\n\na,b,c","e6a435e5":"distance_from_line = []\nfor k in range(max_range-1):\n    distance_from_line.append(\n        calc_distance_from_line(K[k],wcss[k],a,b,c))\n\nplt.title('Elbow Method reverse curve')\nplt.xlabel('Number of clusters')\nplt.ylabel('Distance')\nplt.plot(K,distance_from_line)","3c6d7a25":"plt.plot(K,distance_from_line)\n\nnum_cluster = distance_from_line.index(max(distance_from_line))+1\n\nplt.title('Elbow Method reverse curve')\nplt.xlabel('Number of clusters')\nplt.ylabel('Distance')\nplt.plot([num_cluster,num_cluster],[distance_from_line[0],max(distance_from_line)], 'ro-')","fc4ae973":"num_cluster = distance_from_line.index(max(distance_from_line))+1\nmax_iteration = 300\nkmeans = KMeans(n_clusters=num_cluster, \n                init='k-means++',\n                max_iter=max_iteration, \n                n_init=10, \n                random_state=random_int)\n\npred_y = kmeans.fit_predict(X)\ncategories = np.array([1,2,3,4])\nplt.scatter(X[:,0], X[:,1], s=20, c=pred_y)\nplt.scatter(kmeans.cluster_centers_[:, 0], \n            kmeans.cluster_centers_[:, 1], s=300, c='red')\nplt.show()","cd028334":"You can see the different groupings by color in the graphic. The k central points are represented by the red dots in the graphic.","f4a0c20c":"<h3>Prints a graph of the distances between each point and the line and finds its vertex.<\/h3>","e488a16d":"<h3>model training and data curve printing<\/h3>","799b394b":"<h3>creation of random coordinates to add data to our dataframe<\/h3>","3c9b94a8":"<h3>calculates the distance between each point on the curve and the line separating the first and the last point <\/h3>","bb6f7224":"<h3>IMPORT<\/h3>","45f530da":"Hello, here is a basic example of a kmeans algorithm using the elbow technique to find the value of k. \nA certain number of values will be randomly generated and the algorithm will be used to find the most \nefficients way to regroup them.","6447284a":"<h3>uses pattern prediction to separate the group by that number of points and assigns a different color for each subgroup<\/h3>","4173cb93":"<h3>Searching for the bend in the curve to evaluate the optimal number of points needed to cover each area equitably<\/h3>"}}