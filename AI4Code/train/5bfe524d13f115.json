{"cell_type":{"b787bda0":"code","a9e6100c":"code","19228c11":"code","14c3f076":"code","c5b2dca3":"code","9f481d4d":"code","cef7871b":"code","bc0d0347":"code","44fc9128":"code","9c8d948f":"code","c4c3829e":"code","6de00510":"markdown","8b5182cb":"markdown","b0830be4":"markdown","204f6138":"markdown"},"source":{"b787bda0":"%matplotlib inline\n\n# Imports\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nimport tensorflow as tf","a9e6100c":"class SVR(object):\n    def __init__(self, epsilon=0.5):\n        self.epsilon = epsilon\n        \n    def fit(self, X, y, epochs=100, learning_rate=0.1):\n        self.sess = tf.Session()\n        \n        feature_len = X.shape[-1] if len(X.shape) > 1 else 1\n        \n        if len(X.shape) == 1:\n            X = X.reshape(-1, 1)\n        if len(y.shape) == 1:\n            y = y.reshape(-1, 1)\n        \n        self.X = tf.placeholder(dtype=tf.float32, shape=(None, feature_len))\n        self.y = tf.placeholder(dtype=tf.float32, shape=(None, 1))\n        \n        self.W = tf.Variable(tf.random_normal(shape=(feature_len, 1)))\n        self.b = tf.Variable(tf.random_normal(shape=(1,)))\n        \n        self.y_pred = tf.matmul(self.X, self.W) + self.b\n        \n        #self.loss = tf.reduce_mean(tf.square(self.y - self.y_pred))\n        #self.loss = tf.reduce_mean(tf.cond(self.y_pred - self.y < self.epsilon, lambda: 0, lambda: 1))\n        \n        # Second part of following equation, loss is a function of how much the error exceeds a defined value, epsilon\n        # Error lower than epsilon = no penalty.\n        self.loss = tf.norm(self.W)\/2 + tf.reduce_mean(tf.maximum(0., tf.abs(self.y_pred - self.y) - self.epsilon))\n#         self.loss = tf.reduce_mean(tf.maximum(0., tf.abs(self.y_pred - self.y) - self.epsilon))\n        \n        opt = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)\n        opt_op = opt.minimize(self.loss)\n\n        self.sess.run(tf.global_variables_initializer())\n        \n        for i in range(epochs):\n            loss = self.sess.run(\n                self.loss, \n                {\n                    self.X: X,\n                    self.y: y\n                }\n            )\n            print(\"{}\/{}: loss: {}\".format(i + 1, epochs, loss))\n            \n            self.sess.run(\n                opt_op, \n                {\n                    self.X: X,\n                    self.y: y\n                }\n            )\n            \n        return self\n            \n    def predict(self, X, y=None):\n        if len(X.shape) == 1:\n            X = X.reshape(-1, 1)\n            \n        y_pred = self.sess.run(\n            self.y_pred, \n            {\n                self.X: X \n            }\n        )\n        return y_pred","19228c11":"x = np.linspace(start=0, stop=5, num=20)","14c3f076":"x","c5b2dca3":"m = 2\nc = 1","9f481d4d":"y = m * x + c","cef7871b":"y += np.random.normal(size=(len(y),))","bc0d0347":"plt.plot(x, y, \"x\")","44fc9128":"model = SVR(epsilon=0.2)","9c8d948f":"model.fit(x, y)","c4c3829e":"plt.plot(\n    x, y, \"x\",\n    x, model.predict(x), \"-\"\n)\nplt.legend([\"actual\", \"prediction\"])","6de00510":"Generate sample data","8b5182cb":"### Sample usage","b0830be4":"### Implementation","204f6138":"Instantiate and fit model"}}