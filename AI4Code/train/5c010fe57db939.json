{"cell_type":{"065e90af":"code","c67b8631":"code","27f65caa":"code","8d5c5337":"code","c60c993f":"code","5ea74ae3":"code","fdd972c9":"code","34585a55":"code","1d4e00a0":"code","43797935":"code","58f692eb":"code","79bd4930":"code","28a495e2":"code","8c6c0840":"code","53f34b74":"code","1901a4e9":"code","90a68b25":"code","35abb5b2":"code","1b1e3c96":"markdown","756a6eba":"markdown","0ed5dfed":"markdown","d278ce38":"markdown","9350fea1":"markdown","a2a8e1eb":"markdown"},"source":{"065e90af":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))      ","c67b8631":"import pandas as pd\nimport numpy as np\nfrom sklearn.feature_selection import chi2\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_extraction import text\n#from sklearn.svm import LinearSVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import f1_score\nimport matplotlib.pyplot as plt","27f65caa":"cols_to_use = [0,1] \nevents = pd.read_excel(\"..\/input\/eventdata\/Event.xlsx\",usecols= cols_to_use)\ntarget_names = events.Type.unique().tolist()\n","8d5c5337":"events['category_id'] = events['Type'].factorize()[0]","c60c993f":"category_id_df = events[['Type', 'category_id']].drop_duplicates().sort_values('category_id')\ncategory_to_id = dict(category_id_df.values)\nid_to_category = dict(category_id_df[['category_id', 'Type']].values)","5ea74ae3":"\nmy_stops = text.ENGLISH_STOP_WORDS.difference([\"AI\", \"ai\"])\n\ntfidf = TfidfVectorizer(sublinear_tf=True, min_df=2, norm='l2', encoding='latin-1', ngram_range=(1, 2), stop_words= my_stops, token_pattern = r\"(?u)c\\+{2}|\\b\\w+\\b\")\nfeatures = tfidf.fit_transform(events.Events.values)\nlabels = events.Type\nfeatures.shape","fdd972c9":"N = 2\nfor Product, category_id in sorted(category_to_id.items()):\n    features_chi2 = chi2(features, labels == category_id)\n    indices = np.argsort(features_chi2[0])\n    feature_names = np.array(tfidf.get_feature_names())[indices]\n    unigrams = [v for v in feature_names if len(v.split(' ')) == 1]\n    bigrams = [v for v in feature_names if len(v.split(' ')) == 2]\n    print(\"# '{}':\".format(Product))\n    print(\"  . Most correlated unigrams:\\n. {}\".format('\\n. '.join(unigrams[-N:])))\n    print(\"  . Most correlated bigrams:\\n. {}\".format('\\n. '.join(bigrams[-N:])))\n","34585a55":"model = RandomForestClassifier()\n\nX_train, X_test, y_train, y_test, indices_train, indices_test = train_test_split(features, labels, events.index, test_size=0.01, random_state=0)","1d4e00a0":"model.fit(X_train, y_train)\ny_pred = model.predict(X_test)","43797935":"model.score(X_train , y_train)","58f692eb":"model = RandomForestClassifier()\n\nmodel.fit(features, labels)\n","79bd4930":"print(\"Confusion matrix is\\n\",confusion_matrix(y_test,y_pred))\nprint(\"Classification report is\\n\",classification_report(y_test,y_pred))","28a495e2":"N = 2\nfor Product, category_id in sorted(category_to_id.items()):\n    indices = np.argsort(model.coef_[category_id])\n    feature_names = np.array(tfidf.get_feature_names())[indices]\n    unigrams = [v for v in reversed(feature_names) if len(v.split(' ')) == 1][:N]\n    bigrams = [v for v in reversed(feature_names) if len(v.split(' ')) == 2][:N]\n    print(\"# '{}':\".format(Product))\n    print(\"  . Top unigrams:\\n       . {}\".format('\\n       . '.join(unigrams)))\n    print(\"  . Top bigrams:\\n       . {}\".format('\\n       . '.join(bigrams)))","8c6c0840":"def get_query(event_dom, event_type, employees):\n    return employees.query(\"Domain == '\" + event_dom + \"' and (Event1 == '\" + event_type +\"' or Event2 == '\" + event_type + \"')\")\n","53f34b74":"def predict(events, employees):\n        recommendations = []\n        pred = model.predict(tfidf.transform(events))  \n        for text, predicted in zip(events, pred):\n            print('\"{}\"'.format(text))\n            print(\"  - Predicted as: '{}'\".format(predicted))\n            print(\"\")\n        for prediction in pred.tolist():\n            domain, event_type = prediction.split(\".\")\n            if domain == 'Artificial_Intelligence':\n                recommend_to = get_query('Artificial Intelligence', event_type, employees)\n                \n            elif domain == 'WebDev':\n                recommend_to = get_query('Web Development', event_type, employees)\n                \n            elif domain == 'Mobile_Applications':\n                recommend_to = get_query('Mobile Applications', event_type, employees)\n                \n            elif domain == 'ML':\n                recommend_to = get_query('Machine Learning', event_type, employees)\n                \n            elif domain == 'CC':\n                recommend_to = get_query('Cloud Computing', event_type, employees)\n                \n            elif domain == 'Higher_Education':\n                recommend_to = get_query('Higher Education', event_type, employees)\n                \n            elif domain == 'DevOps':\n                recommend_to = get_query('Development Processes', event_type, employees)\n                \n            elif domain == 'Software_Architecture':\n                recommend_to = get_query('Software Architecture', event_type, employees)\n                \n            elif domain == 'Data_Science':\n                recommend_to = get_query('Data Science', event_type, employees)\n                \n            elif domain == 'Cpp':\n                recommend_to = get_query('C++', event_type, employees)\n                \n            elif domain == 'None':\n                recommend_to = employees.query(\"Event1 == '\" + event_type + \"' or Event2 == '\" + event_type + \"'\")\n                \n            else:\n                recommend_to = get_query(domain, event_type, employees)\n                \n            recommendations.append(\", \".join(recommend_to['Name'].values))\n            \n        return recommendations","1901a4e9":"\ndef make_predictions():\n    employees = pd.read_csv(\"..\/input\/nknknkn\/CCMLEmployeeData (1).csv\")\n    to_pred_events = pd.read_csv('..\/input\/event-recommendation\/Eventsrecommended.csv', encoding= 'unicode_escape')\n    recommendations = predict(to_pred_events.Events, employees)\n    to_pred_events['Employees'] = recommendations\n    to_pred_events.to_excel('output.xlsx', index=False)\n","90a68b25":"make_predictions()","35abb5b2":"pip install ipynb-py-convert","1b1e3c96":"**Used Random forest package of sklearn to bring more accuracy without overfitting..!!**","756a6eba":"# Importing dataset","0ed5dfed":"# Importing Library for reading xlxs and csv","d278ce38":"# Data preprocessing..!!","9350fea1":"# Data modelling","a2a8e1eb":"**We got 99.7% accuracy which is very good**"}}