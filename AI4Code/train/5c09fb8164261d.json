{"cell_type":{"3f529401":"code","ea08583d":"code","ad032f8c":"code","cf6621cb":"code","ed98aed4":"code","628abba2":"code","79a5f3e0":"code","beaed2b0":"code","1206dfcb":"code","b900c1b6":"code","2b804b69":"code","605f6531":"code","e5aa94b2":"code","f752e182":"code","2b4c55aa":"code","403154ab":"code","3dfe09c4":"code","e325256c":"code","6d2d3086":"code","696f3c43":"code","01dc07f0":"code","619808f4":"code","cc3f1b18":"code","4878e28d":"code","83debe89":"code","0e0dbfff":"code","646c39df":"code","00ddce5a":"code","d000ed40":"code","9ea5bfd4":"code","ef83f727":"code","61f435bd":"code","fcccfb37":"code","0276be2c":"markdown","86b9d66a":"markdown","03338ff0":"markdown","a1246cf6":"markdown","6ff95368":"markdown","1842c3c0":"markdown","2e2d7564":"markdown","2eb7064e":"markdown","b64d9db8":"markdown","44c09cab":"markdown","cde66785":"markdown","34e34510":"markdown","6ae97ea7":"markdown","9beeb7be":"markdown","8965c865":"markdown","54768727":"markdown","a4d8e12b":"markdown","ca4aca65":"markdown","709f9ad0":"markdown"},"source":{"3f529401":"#just numpy for this one\n\nimport numpy as np\nimport matplotlib.pyplot as plt","ea08583d":"plt.rcParams[\"figure.figsize\"] = (10,5)","ad032f8c":"#import qlc color scheme\nqlcGreens = ['#001a1a',\n            '#003333',\n            '#004d4d',\n            '#006666',\n            '#008080',\n            '#009999',\n            '#00b3b3',\n            '#00cccc',\n            '#00e6e6',\n            '#00ffff',\n            '#1affff',\n            '#33ffff',\n            '#4dffff',\n            '#66ffff',\n            '#80ffff',\n            '#99ffff',\n            '#b3ffff',\n            '#ccffff',\n            '#e6ffff',\n            '#ffffff']","cf6621cb":"sat0 = [0,1]\nsat1 = [1,1]\nsat2 = [2,1]\nsat3 = [2,0]\n\nsats = np.array([sat0,sat1, sat2, sat3])\nsats","ed98aed4":"truth = np.array([1,0])\n\npseudorange0 = np.sqrt(2) \npseudorange1 = 1 \npseudorange2 = np.sqrt(2) \npseudorange3 = 1 \npseudoranges = np.array([pseudorange0,pseudorange1,pseudorange2, pseudorange3])\npseudoranges","628abba2":"def viz_problem(sats, prs, truth, estimate):\n     \n    figure, axes = plt.subplots()\n    \n    plt.scatter(sats[:,0], sats[:,1]) \n    \n    plt.xlim(-3, 3)\n    plt.ylim(-3, 3)\n    \n    for i in range(len(sats)):\n    \n        thisSat = sats[i]\n        sat_range = plt.Circle( (thisSat[0], thisSat[1] ) , prs[i],\n                               color = qlcGreens[i],\n                               alpha = .2                          \n                              )\n        plt.annotate('Sat ' + str(i), # this is the text\n                 (thisSat[0], thisSat[1]), # this is the point to label\n                 textcoords=\"offset points\", # how to position the text\n                 xytext=(0,10), # distance from text to points (x,y)\n                 ha='center')\n              \n        axes.add_artist( sat_range )  \n       \n    plt.plot(truth[0],truth[1],'rX', markersize=16)     \n    \n    plt.annotate('True Location', # this is the text\n                 (truth[0],truth[1]), # this is the point to label\n                 textcoords=\"offset points\", # how to position the text\n                 xytext=(-5,0), # distance from text to points (x,y)\n                 color='red',\n                 ha='right')\n    \n    \n    if estimate is None:\n        pass\n    else:\n        plt.plot(estimate[0],estimate[1],'b*', markersize=12)     \n    \n        plt.annotate('Estimate', # this is the text\n                 (estimate[0],estimate[1]), # this is the point to label\n                 textcoords=\"offset points\", # how to position the text\n                 xytext=(5,-1), # distance from text to points (x,y)\n                 color='blue',    \n                 ha='left')\n     \n    axes.set_aspect( 1 )\n    plt.title( 'Current State of Iteration' )  \n    plt.show()\n    return ","79a5f3e0":"viz_problem(sats, pseudoranges, truth, None)\n","beaed2b0":"sat_average = sats.mean(axis=0)\n#init = np.array([1.05,-.14])\n#init = estimate","1206dfcb":"sat_average","b900c1b6":"viz_problem(sats, pseudoranges, truth, sat_average)","2b804b69":"estimate = sat_average","605f6531":"\n\ntheorange0 = np.sqrt((estimate[0] - sat0[0])**2 + (estimate[1] - sat0[1])**2) \ntheorange1 = np.sqrt((estimate[0] - sat1[0])**2 + (estimate[1] - sat1[1])**2) \ntheorange2 = np.sqrt((estimate[0] - sat2[0])**2 + (estimate[1] - sat2[1])**2) \ntheorange3 = np.sqrt((estimate[0] - sat3[0])**2 + (estimate[1] - sat3[1])**2) \ntheoranges = np.array([theorange0,theorange1,theorange2, theorange3])\ntheoranges","e5aa94b2":"residuals = pseudoranges - theoranges\nresiduals","f752e182":"G_unnorm = sats - estimate\nG_unnorm","2b4c55aa":"norm = np.linalg.norm(G_unnorm)\nnorm","403154ab":"G_norm = G_unnorm \/ norm\nG_norm","3dfe09c4":"G_norm_trans = np.transpose(G_norm)\nG_norm_trans","e325256c":"GtG = G_norm_trans @ G_norm\nGtG","6d2d3086":"GtGinv = np.linalg.inv(GtG)\nGtGinv","696f3c43":"trans_matrix = GtGinv @ G_norm_trans\ntrans_matrix","01dc07f0":"correction = trans_matrix @ residuals\ncorrection","619808f4":"np.linalg.norm(correction)","cc3f1b18":"estimate = estimate - correction\nestimate","4878e28d":"distance_from_true = np.sqrt((truth[0]-estimate[0])**2 + (truth[1] - estimate[1])**2)\ndistance_from_true","83debe89":"distance_from_true_sat_average = np.sqrt((truth[0]-sat_average[0])**2 + (truth[1]-sat_average[1])**2)\ndistance_from_true_sat_average","0e0dbfff":"viz_problem(sats, pseudoranges, truth, estimate)","646c39df":"theorange0 = np.sqrt((estimate[0] - sat0[0])**2 + (estimate[1] - sat0[1])**2) \ntheorange1 = np.sqrt((estimate[0] - sat1[0])**2 + (estimate[1] - sat1[1])**2) \ntheorange2 = np.sqrt((estimate[0] - sat2[0])**2 + (estimate[1] - sat2[1])**2) \ntheorange3 = np.sqrt((estimate[0] - sat3[0])**2 + (estimate[1] - sat3[1])**2) \ntheoranges = np.array([theorange0,theorange1,theorange2, theorange3])\n\n\nresiduals = pseudoranges - theoranges\n\nG_unnorm = sats - estimate\nnorm = np.linalg.norm(G_unnorm)\n\nG_norm_trans = np.transpose(G_norm)\nG_norm = G_unnorm \/ norm\n\nGtG = G_norm_trans @ G_norm\nGtGinv = np.linalg.inv(GtG)\n\ntrans_matrix = GtGinv @ G_norm_trans\ncorrection = trans_matrix @ residuals\n\nestimate = estimate - correction\nestimate","00ddce5a":"distance_from_true = np.sqrt((truth[0]-estimate[0])**2 + (truth[1] - estimate[1])**2)\ndistance_from_true","d000ed40":"viz_problem(sats, pseudoranges, truth, estimate)","9ea5bfd4":"distance_from_true = np.sqrt((truth[0]-estimate[0])**2 + (truth[1] - estimate[1])**2)\ndistance_from_true","ef83f727":"theorange0 = np.sqrt((estimate[0] - sat0[0])**2 + (estimate[1] - sat0[1])**2) \ntheorange1 = np.sqrt((estimate[0] - sat1[0])**2 + (estimate[1] - sat1[1])**2) \ntheorange2 = np.sqrt((estimate[0] - sat2[0])**2 + (estimate[1] - sat2[1])**2) \ntheorange3 = np.sqrt((estimate[0] - sat3[0])**2 + (estimate[1] - sat3[1])**2) \ntheoranges = np.array([theorange0,theorange1,theorange2, theorange3])\n\n\nresiduals = pseudoranges - theoranges\n\nG_unnorm = sats - estimate\nnorm = np.linalg.norm(G_unnorm)\n\nG_norm_trans = np.transpose(G_norm)\nG_norm = G_unnorm \/ norm\n\nGtG = G_norm_trans @ G_norm\nGtGinv = np.linalg.inv(GtG)\n\ntrans_matrix = GtGinv @ G_norm_trans\ncorrection = trans_matrix @ residuals\n\nestimate = estimate - correction\nestimate","61f435bd":"viz_problem(sats, pseudoranges, truth, estimate)","fcccfb37":"distance_from_true = np.sqrt((truth[0]-estimate[0])**2 + (truth[1] - estimate[1])**2)\ndistance_from_true","0276be2c":"So, we got closer, but if we visualize it, we will see that we overshot.","86b9d66a":"\n\nWith an initial estimate, we know calculate the theoretical ranges, that is, the ranges if our guess was true.\n\nAs we will be taking difference, we calculate the residuals, that is the actual measurement versus the theoretical\/assumed ranges\n","03338ff0":"# 3.0 Setup","a1246cf6":"Let's set up a very simple problem.\n- We live in two dimensional space\n- we have 4 satelittles, located below (there will be a visual at the end of the section)\n- The transmission times are all simultaneous and we have no clock bias or anything fun like that","6ff95368":"## 1.1 Sources, inspirations, and credits","1842c3c0":"So, what do you notice? \n\nThe algoirthm is pointing us in the right direction, however, we seem to keep overshooting the target. Thus we seem to be destined to flip flop around.\n\nWhat's the fix?\n\nThink about what we do in other machine learning tasks, particularly when we are using gradient decent. Maybe this algorithm \"learns\" too fast? ","2e2d7564":"So, if this were perfectly specified, that is, with our 2 dimension we had only 2 satellites, we could just take the inverse of G.\n\nHowever, we will find that we will have more satellites than dimensions (which is good since in the real world we won't have such perfect estimates). \n\nThus, we create an invertible matrix by front multiplying G by its transpose, which I will call GtG","2eb7064e":"From the lessons, we know we will need to calculate the design\/geometry matrix.\n\nThis is G in the Stanford Lecture and A in the Caltech document.\n\nG is the Satellite positions less our estimate, normalized.\nWe normalize because we only want the direction\n\nWe will do this in a few steps to be very clear.\n","b64d9db8":"\n- The GPS device is located at (1,0)\n\n- The distance from each satellite to the truth is the pseudorange","44c09cab":"# 2.0 Imports","cde66785":"A kludgy graph to visualize the problem","34e34510":"## 4.2 Iteration 2 using latest estimate","6ae97ea7":"Inspirations:\n- [Caltech GPS Basics](http:\/\/web.gps.caltech.edu\/classes\/ge111\/Docs\/GPSbasics.pdf)\n- [2D trilateration GIS stackexchange thread](https:\/\/gis.stackexchange.com\/questions\/40660\/trilateration-algorithm-for-n-amount-of-points)\n- [Stanford GPS course on youtube](https:\/\/www.youtube.com\/watch?v=-hnkDQIZ8kY)\n    \n\nCredits:\nAuthor(s) - Jon Mayes, [Quantum Logik Consulting](https:\/\/quantumlogik.com)","9beeb7be":"# 1.0 Introduction","8965c865":"## 4.3 Iteration 3","54768727":"This is an iterative method. Let's run this again with the new estimate\n\nWe will include the entire process in one cell for \"brevity\"","a4d8e12b":"The algorithm described in the sources above is an iterative one. That is, we need to create a guess, then the algorithm will point us in the direction in the true location.\n\nAs an initial guess, we will take the average of the satellites and label it with a blue star","ca4aca65":"# 4.0 Iterations","709f9ad0":"## 4.1 Initial guess"}}