{"cell_type":{"39fd6655":"code","e9ac02fc":"code","b2fc6c61":"code","050480d2":"code","f877a3f9":"code","39cd754c":"markdown"},"source":{"39fd6655":"import pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport os\nprint(os.listdir(\"..\/input\/\"))\n# Any results you write to the current directory are saved as output.","e9ac02fc":"# load and deal with data \ndef read_Data():\n    data = pd.read_csv(\"..\/input\/dataset_group.csv\",header=None)\n    return data\n\ndef aprior_data(data):\n    basket = []\n    for id in data[1].unique():\n        a = [data[2][i] for i, j in enumerate(data[1]) if j == id]\n        basket.append(a)\n    return basket\n\ndata = read_Data()\nbasket = aprior_data(data)","b2fc6c61":"# Create Aprior Association Model \ndef create_C1(basket):\n    C1 = set()\n    for t in basket:\n        for item in t:\n            item_set = frozenset([item])\n            C1.add(item_set)\n    return C1\n\n\ndef is_apriori(Ck_item, Lksub1):\n    for item in Ck_item:\n        sub_Ck = Ck_item - frozenset([item])\n        if sub_Ck not in Lksub1:\n            return False\n    return True\n\n\ndef create_Ck(Lksub1, k):\n    Ck = set()\n    len_Lksub1 = len(Lksub1)\n    list_Lksub1 = list(Lksub1)\n    for i in range(len_Lksub1):\n        for j in range(1, len_Lksub1):\n            l1 = list(list_Lksub1[i])\n            l2 = list(list_Lksub1[j])\n            l1.sort()\n            l2.sort()\n            if l1[0:k-2] == l2[0:k-2]:\n                Ck_item = list_Lksub1[i] | list_Lksub1[j]\n                # pruning\n                if is_apriori(Ck_item, Lksub1):\n                    Ck.add(Ck_item)\n    return Ck\n\n\ndef generate_Lk_by_Ck(data_set, Ck, min_support, support_data):\n    Lk = set()\n    item_count = {}\n    for t in data_set:\n        for item in Ck:\n            if item.issubset(t):\n                if item not in item_count:\n                    item_count[item] = 1\n                else:\n                    item_count[item] += 1\n    t_num = float(len(data_set))\n    for item in item_count:\n        if (item_count[item] \/ t_num) >= min_support:\n            Lk.add(item)\n            support_data[item] = item_count[item] \/ t_num\n    return Lk\n\n\ndef generate_L(basket, k, min_support):\n    #k=3, min_support=0.2\n    support_data = {}\n    C1 = create_C1(basket)\n    L1 = generate_Lk_by_Ck(basket, C1, min_support, support_data)\n    Lksub1 = L1.copy()\n    L = []\n    L.append(Lksub1)\n    for i in range(2, k+1):\n        Ci = create_Ck(Lksub1, i)\n        Li = generate_Lk_by_Ck(basket, Ci, min_support, support_data)\n        Lksub1 = Li.copy()\n        L.append(Lksub1)\n    return L, support_data\n\nL, support_data = generate_L(basket, k=3, min_support=0.2)\nprint(\"supports of relative commodities\")\nfor i in support_data:\n    if len(list(i))==2:\n        print(list(i),\"=====>\",support_data[i])","050480d2":"def generate_big_rules(L, support_data, min_conf):\n    big_rule_list = []\n    sub_set_list = []\n    for i in range(0, len(L)):\n        for freq_set in L[i]:\n            for sub_set in sub_set_list:\n                if sub_set.issubset(freq_set):\n                    conf = support_data[freq_set] \/ support_data[freq_set - sub_set]\n                    big_rule = (freq_set - sub_set, sub_set, conf)\n                    if conf >= min_conf and big_rule not in big_rule_list:\n                        # print freq_set-sub_set, \" => \", sub_set, \"conf: \", conf\n                        big_rule_list.append(big_rule)\n            sub_set_list.append(freq_set)\n    return big_rule_list\nbig_rules_list = generate_big_rules(L, support_data, min_conf=0.7)\nrelation = []\nfor item in big_rules_list:\n    a = [list(item[0])[0],list(item[1])[0],item[2]]\n    relation.append(a)\nrelations = pd.DataFrame(relation)\nrelations = relations.sort_values(by=2 , ascending=False)\nprint(relations)","f877a3f9":"def graph(C1,big_rule_list):\n    # \u7ed3\u70b9\n    node = []\n    for item in C1:\n        node.extend(list(item))\n    # \u5173\u7cfb\n    relation = []\n    size = []\n    for item in big_rule_list:\n        a = (list(item[0])[0], list(item[1])[0], item[2])\n        size.append((item[2]*100-70)**3)\n        relation.append(a)\n    DG = nx.Graph()\n    DG.add_nodes_from(node)\n    DG.add_weighted_edges_from(relation)\n    nx.draw(DG,pos = nx.spring_layout(DG),with_labels=True,node_size=size)\n    plt.show()\nC1 = create_C1(basket)\ngraph(C1, big_rules_list)","39cd754c":"The degree of association as following"}}