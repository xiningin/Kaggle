{"cell_type":{"e70f495f":"code","294a791b":"code","b70d2271":"code","84de49bd":"code","da6f4a5c":"code","8949ca0a":"code","3a26370b":"code","0084b8d6":"code","b6fe8c1e":"code","dfa17425":"code","b71b9e7e":"code","8776b8d3":"code","be769b45":"code","1d1462dc":"markdown","fede07ff":"markdown","bf5c80f6":"markdown","eb9fc040":"markdown","0fc2ce4d":"markdown","6b85ee81":"markdown","c125cbda":"markdown","3e14287b":"markdown","f0898c0f":"markdown","db7425bb":"markdown","11a12786":"markdown","65f690ea":"markdown","ddfc50c3":"markdown","e565dc44":"markdown","1a9efd38":"markdown","f5ace54a":"markdown","37734707":"markdown","aba70fb0":"markdown"},"source":{"e70f495f":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sklearn.metrics.pairwise import linear_kernel #to generate the similarity matrices\nimport scipy.sparse #to process\/handle the sparse matrices\nimport warnings #to ignore the warnings\n\nwarnings.filterwarnings(\"ignore\")\n\n# Input data files are available in the read-only \"..\/input\/\" directory\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","294a791b":"#importing the datasets\naction_df = pd.read_csv(\"\/kaggle\/input\/imdb-movies-dataset\/datasets\/action_df.csv\")\nanimation_df = pd.read_csv(\"\/kaggle\/input\/imdb-movies-dataset\/datasets\/animation_df.csv\")\ncomedy_df = pd.read_csv(\"\/kaggle\/input\/imdb-movies-dataset\/datasets\/comedy_df.csv\")\nallMovies_df = pd.read_csv(\"\/kaggle\/input\/imdb-movies-dataset\/datasets\/all_df.csv\")","b70d2271":"action_df.info()","84de49bd":"animation_df.info()","da6f4a5c":"comedy_df.info()","8949ca0a":"allMovies_df.info()","3a26370b":"action_sm = scipy.sparse.load_npz(\"\/kaggle\/input\/imdb-movies-dataset\/sparse_matrices\/action_sm.npz\")\nanimation_sm = scipy.sparse.load_npz(\"\/kaggle\/input\/imdb-movies-dataset\/sparse_matrices\/animation_sm.npz\")\ncomedy_sm = scipy.sparse.load_npz(\"\/kaggle\/input\/imdb-movies-dataset\/sparse_matrices\/comedy_sm.npz\")","0084b8d6":"action_simmat = linear_kernel(action_sm, action_sm)\nanimation_simmat = linear_kernel(animation_sm, animation_sm)\ncomedy_simmat = linear_kernel(comedy_sm, comedy_sm)","b6fe8c1e":"def give_recommendations(df, sim_mat, mov_name):\n    movie = df[df.original_title == mov_name].index[0]\n    index_recomm = sim_mat[movie].argsort(axis=0)[-11:-1]\n    \n    print(\"Original Description: \",df.description[movie],\"\\n\")\n\n    for i in np.flipud(index_recomm):\n        print(\"Score: \",sim_mat[movie][i],\"\\t Title: \",df.original_title[i])\n        print(\"IMDb Title ID: \",df.imdb_title_id[i])\n        print(df.description[i],\"\\n\")","dfa17425":"give_recommendations(action_df, action_simmat, 'Singham') #let's try with an Indian Movie: Singham","b71b9e7e":"give_recommendations(animation_df, animation_simmat, 'Frozen') #Everyone knows about Frozen, right!","8776b8d3":"give_recommendations(comedy_df, comedy_simmat, 'Phir Hera Pheri') #The classic, the source of all memes.","be769b45":"hera_pheri = comedy_df[(comedy_df.original_title == 'Hera Pheri') & (comedy_df.year == '2000')]\nhera_pheri = hera_pheri.reset_index()\nprint(\"Plot of Hera Pheri(2000) : \", hera_pheri['description'][0])","1d1462dc":"We can use the available sparse matrices to make a Movie Recommendation system, based on content-based filtering, with ease. Let's move on step by step.","fede07ff":"Now, most people would doubt the credibility of the recommender, as it hasn't predicted ***Hera Pheri*** here. Well guys, remember the plot?","bf5c80f6":"## Importing Libraries and Datasets","eb9fc040":"74889 movies, with much less null values.","0fc2ce4d":"**Great!**\n\nSo here's the way to implement these datasets using content-based filtering for getting genre-wise recommendations. I hoped you liked it, *Please upvote if you did :)*\n\n\nLooking forward to your awesome implementations.","6b85ee81":"Now, let's see the recommendations.","c125cbda":"## Applying Content-Based Filtering","3e14287b":"Since the story is quite different and *content-based filtering* is completely dependant upon the description\/ plot, therefore we don't get Hera Pheri as our recommendation.","f0898c0f":"Well, the recommendations look good...considering the plot of the movie.","db7425bb":"## *Thank you !* ","11a12786":"Since we already have sparse matrices which have been collected after applying Tf-idf on each dataset, with specifications (analyzer='word', ngram_range=(1,3), stopwords='english'), we can directly import these .npz files and proceed with generating the similarity matrix.\n\n<br>\nAccording to me, using the technique TF-IDF (term frequency \u2013 inverse document frequency) to find out \u2018How important is a word in it\u2019s corresponding document\u2019 is much more efficient. The product of term frequency and inverse document frequency for each word acts up as a score of it\u2019s importance.\n\n**Term Frequency** tells us the probability of a word occurring in a document (i.e. number of times the word occur\/total number of words in a document).\n<br>\n**Inverse Document Frequency** of a word in a given document corpus(dataset) is the logarithmic ratio of the total number of documents to the number of documents int which the word occurs. In our case, the description of each podcast is a document and the collection of all the descriptions is the document corpus.","65f690ea":"Now we can calculate the similarity between the podcasts on the basis of their tf-idf scores or values( received as a sparse matrix) using an appropriate kernel method, such that the words with closer scores tend to have a similar type of value and this value changes(either increases or decreases) as the difference between the tf-idf scores increases or decreases. These values will be stored in a separate dataframe, this would be our Recommender DataFrame.\n\nHere, we use the Linear Kernel, which is based on the cosine-similarity of the elements. For the linear_kernel method, closer the value is to 1, for given 2 data-points, more similar are the data-points.\n\nThe liner_kernel function returns a ***numpy.ndarray*** which has similarity scores of each movie, compared with every other movie in the dataframe.","ddfc50c3":"Loading the .npz files *(sparse matrices)* for **Genres: *Action, Animation*** and ***Comedy***. ","e565dc44":"As we can see the datasets are quite clean, considering for using content-based filtering. \n<br>\nThe Comedy dataset is quite huge, compared to Animation and Action Dataset, with a total of 25200 movies. Let's see the information about the allMovies dataset","1a9efd38":"**Defining a generic function for getting the top 10 recommendations.**","f5ace54a":"Let's consider **Genre: *Action***, **Genre: *Animation*** and **Genre: *Comedy*** as examples. Also the one with all the movies for experimentation.","37734707":"Now, let's try out for Animation.","aba70fb0":"Claculating the similarity matrices of the above sparse matrices."}}