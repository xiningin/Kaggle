{"cell_type":{"fe73b8f8":"code","6260dfbf":"code","2126be3c":"code","176d647b":"code","22541c7d":"code","c5c1285e":"code","16ba872d":"code","1ba4cb3c":"code","b66cacdb":"code","581392d1":"code","b995cde5":"code","1929954e":"code","bed45584":"code","9c46fb88":"code","859c7164":"code","2eaf3b0f":"code","b8d48bcc":"code","e752e992":"code","501e2841":"code","8d1a42b4":"code","279c95d7":"code","dda3d953":"code","c21b4d1a":"code","0cf19666":"code","727de9af":"code","bca46dad":"code","09062de2":"code","fac34b0a":"code","69825121":"code","ea4b9f98":"code","3cb1912b":"code","58372338":"markdown","38196a78":"markdown","9b55d5e0":"markdown","0b7dc361":"markdown","14e85177":"markdown","04622615":"markdown","5a78e0d7":"markdown","8f2d89d9":"markdown","5708f3a1":"markdown","df7942ca":"markdown","e19070c9":"markdown","7be3647c":"markdown","41131393":"markdown","09fcd177":"markdown","ac96b31d":"markdown","efaae98a":"markdown","c0120f93":"markdown","583e851d":"markdown","acfdce57":"markdown","8f652ae5":"markdown","b6dd60ce":"markdown","8b226893":"markdown","ce432c62":"markdown","53bfbf9e":"markdown","11b177cd":"markdown","c7e45391":"markdown","323625e9":"markdown","552b1645":"markdown","ed29c058":"markdown","45c79ed1":"markdown","71392bf4":"markdown","32aa6634":"markdown","855709ce":"markdown","c3f6512f":"markdown","e4279743":"markdown","e73dc6df":"markdown","e4a21361":"markdown","c70017df":"markdown"},"source":{"fe73b8f8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\n# Word embedding imports.\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import linear_kernel\n\n# Default imports.\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Visualization imports.\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Graphing import.\nimport networkx as nx\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","6260dfbf":"def process_dates(df):\n    \"\"\"Processes date information into a Series of tuples where the format is (month, year). \"\"\"\n    \n    MONTH_INTS = {'January':  1, 'February':  2, 'March':      3, \n                  'April':    4, 'May':       5, 'June':       6, \n                  'July':     7, 'August':    8, 'September':  9, \n                  'October': 10, 'November': 11, 'December':  12,\n    }\n    \n    date_values = []\n    for value_ls in list(df['date_added']):\n        if (len(value_ls) == 2):\n            # Re-joins 'Not Specified' back into a single string.\n            value = ' '.join(value_ls)\n        elif (len(value_ls) == 3):\n            # Converts date into a tuple of ints (month, year).\n            value = (int(MONTH_INTS[value_ls[0]]), int(value_ls[2]),)\n        elif (len(value_ls) == 4):\n            # Converts date into a tuple of ints (month, year).\n            value = (int(MONTH_INTS[value_ls[1]]), int(value_ls[3]))\n            \n        date_values.append(value)\n\n    return pd.Series(date_values)","2126be3c":"def value_counter(df, keyword):\n    \"\"\"Processes the specified column into a Series of unique value counts. \"\"\"\n    \n    values = []\n    for value_ls in list(df[keyword]):\n        for value in value_ls:\n            values.append(value)\n\n    return pd.Series(values)","176d647b":"class Recommender():\n    def __init__(self, df):\n        \"\"\"Initializes and executes TF-IDF. \"\"\"\n        \n        # Save pointer to the specified dataframe.\n        self.df = df\n        \n        # Removing stopwords.\n        tfidf = TfidfVectorizer(stop_words='english')\n\n        # Construct the required TF-IDF matrix by fitting and transforming the data.\n        tfidf_matrix = tfidf.fit_transform(df['description'])\n\n        # Compute the cosine similarity matrix.\n        self.cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\n\n        # Construct a Series of indexes for their respective content titles.\n        self.indices = pd.Series(df.index, index=df['title'])\n        \n    def get_recommendation(self, title):\n        \"\"\"Recommends content using TF-IDF. \"\"\"\n        \n        idx = self.indices[title]\n\n        # Get the pairwsie similarity scores of all content with the specified content.\n        sim_scores = list(enumerate(self.cosine_sim[idx]))\n\n        # Sort the content based on the similarity scores.\n        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n        # Get the scores of the 10 most similar content.\n        sim_scores = sim_scores[1:11]\n\n        # Get the content indices.\n        movie_indices = [i[0] for i in sim_scores]\n\n        # Return the top 10 most similar content.\n        return self.df['title'].iloc[movie_indices]","22541c7d":"def create_graph(df):\n    \"\"\"Constructs a NetworkX graph given a dataset. \"\"\"\n    \n    # Attributes to ignore.\n    ELEMENTS_IGNORE = ['date_added', 'release_year', 'rating', 'duration', 'description']\n    \n    NODE_LABELS = {1: 'DIRECTOR', 2: 'ACTOR\/ACTRESS', 3: 'COUNTRY', 8: 'CATEGORY'}\n    EDGE_LABELS = {1: 'directed_by', 2: 'acted_in', 3: 'produced_in', 8: 'listed_in'}\n    \n    NODE_COLORS = {1: 'yellow', 2: 'red', 3: 'green', 8: 'orange'}\n    \n    def helper(index, element, title_node):\n        \"\"\"Adds the element to the graph, if needed, and adds edge to the title node. \"\"\"\n        \n        # Checks if the specified element is already in the graph.\n        if (element not in G):\n            # Adds the element node to the graph.\n            G.add_node(element, label=NODE_LABELS[index])\n            colors.append(NODE_COLORS[index])\n\n        # Adds edge from the element node to the title node.\n        G.add_edge(element, title_node, label=EDGE_LABELS[index])\n    \n    \n    \n    G = nx.Graph()\n    colors = []\n\n    # Iterates each row within the dataframe as (int(index), pd.Series(row)).\n    for i, row in df.iterrows():\n        row.reset_index(drop=True, inplace=True)\n        \n        title_node = None\n        # Iterates over each attribute within the row as (int(index), Generic(element)).\n        for j, element in row.items():\n            # If the current element is the title, it is added to the graph and then moves on to the next element.\n            if (j == 0):\n                G.add_node(element, label='TITLE')\n                colors.append('blue')\n                title_node = element\n                continue\n       \n            # Checks whether to ignore the specified element.\n            if (df.columns.values.tolist()[j] in ELEMENTS_IGNORE):\n                continue\n            \n            # If the specified element has inner elements, they're iterated over as well.\n            if isinstance(element, list):\n                for inner_element in element:\n                   # Adds the inner elements to the graph.\n                   helper(j, inner_element, title_node)\n            else:\n                # adds the element to the graph.\n                helper(j, element, title_node)\n\n    return G, colors\n","c5c1285e":"# Import dataset.\ndf = pd.read_csv('..\/input\/netflix-shows\/netflix_titles.csv')\n\ndf.head()","16ba872d":"print(df.isna().sum())","1ba4cb3c":"# Remove show_id, redundant.\ndf = df.drop('show_id', axis=1)\n\n# Replace NaN values.\ndf = df.replace(np.nan, 'Not Specified')\n\n##### Splits strings into list of respective values.\n\ndf['director'] = df['director'].str.split(pat=',')\ndf['cast'] = df['cast'].str.split(pat=',')\n\n# Assigns the first element in each list as the 'country'.\ndf['country'] = df['country'].apply(lambda x: x.split(',')[0])\n\n# Converts the date into a list...\ndf['date_added'] = df['date_added'].str.split(pat='[,\\s]\\s*')\ndf['date_added'] = process_dates(df)\n\ndf['listed_in'] = df['listed_in'].str.split(pat='[,]\\s*')","b66cacdb":"df.head()","581392d1":"### TV show dataset.\ndf_tv_show = df[df['type'] == 'TV Show'].drop('type', axis=1)\n# Parses 'X Seasons' into an integer.\ndf_tv_show['duration'] = df_tv_show['duration'].apply(lambda x: x.split()[0]).astype(int)\n# Reset index.\ndf_tv_show.reset_index(drop=True, inplace=True)\n\n### Movie dataset.\ndf_movie = df[df['type'] == 'Movie'].drop('type', axis=1)\n# Parses 'X min' into an integer.\ndf_movie['duration'] = df_movie['duration'].apply(lambda x: x.split()[0]).astype(int)\n# Reset index.\ndf_movie.reset_index(drop=True, inplace=True)","b995cde5":"df_movie.head()","1929954e":"df_tv_show.head()","bed45584":"plt.figure(figsize=(5, 8))\n\nax = sns.countplot(x='type', data=df)\n\nax.set_title('Content Type vs. Count')\nax.set_xlabel('Type')\nax.set_ylabel('Count')\n\nplt.show()","9c46fb88":"print(f\"List of Production Counties:\\n{np.sort(df['country'].unique())}\")\n\n##### Graphing\nplt.figure(figsize=(16, 8))\nplt.xticks(rotation=45)\n\nax = sns.countplot(x='country', hue='type', data=df, order=df['country'].value_counts().index[:10])\n\nax.set_title('Production Country vs. Count')\nax.set_xlabel('Country')\nax.set_ylabel('Count')\nax.legend(loc='upper right')\n\nplt.show()","859c7164":"# This import registers the 3D projection, but is otherwise unused.\nfrom mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import\n\nprint('Date Added by Count:')\nprint(df['date_added'].value_counts()[:10])\n\n##### Graphing\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig = plt.figure(figsize=(16, 16))\nax = fig.add_subplot(111, projection='3d')\n\ndf_temp = df.drop(df[df['date_added'] == 'Not Specified'].index)\n\nx = df_temp.date_added.map(lambda a: a[0])\ny = df_temp.date_added.map(lambda a: a[1])\n\nhist, xedges, yedges = np.histogram2d(x, y, bins=[12, 12], range=[[0, 13], [2010, 2021]])\n\n# Construct arrays for the anchor positions of the 16 bars.\nxpos, ypos = np.meshgrid(xedges[:-1] + 0.25, yedges[:-1] + 0.25, indexing=\"ij\")\nxpos = xpos.ravel()\nypos = ypos.ravel()\nzpos = 0\n\n# Construct arrays with the dimensions for the 16 bars.\ndx = dy = 0.5 * np.ones_like(zpos)\ndz = hist.ravel()\n\nax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')\n\nax.set_title('Date Added vs. Count')\nax.set_xlabel('Month')\nax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(integer=True))\nax.set_ylabel('Year')\nax.set_zlabel('Count')\n\nplt.show()","2eaf3b0f":"print(f\"List of Release Years:\\n{np.sort(df['release_year'].unique())}\")\n\n##### Graphing\nplt.figure(figsize=(16, 8))\nplt.legend(loc='upper left')\nplt.xticks(rotation=45)\n\nax = sns.countplot(x='release_year', hue='type', data=df, order=np.sort(df['release_year'].unique())[-50:])\n\nax.set_title('Release Year vs. Count')\nax.set_xlabel('Release Year')\nax.set_ylabel('Count')\nax.legend(loc='upper left')\n\nplt.show()","b8d48bcc":"RATING_ORDER = [\n    'Not Specified', 'NR'  , 'TV-Y' , 'TV-Y7', 'TV-Y7-FV', \n    'G'            , 'TV-G', 'PG'   , 'TV-PG', 'PG-13'   , \n    'TV-14'        , 'R'   , 'TV-MA', 'NC-17', 'UR'      ,\n]\n\n##### Graphing\nplt.figure(figsize=(16, 8))\nplt.legend(loc='upper left')\n\nax = sns.countplot(x='rating', hue='type', data=df, order=RATING_ORDER)\n\nax.set_title('Content Rating vs. Count')\nax.set_xlabel('Content Rating')\nax.set_ylabel('Count')\nax.legend(loc='upper left')\n\nplt.show()","e752e992":"print(f\"Not specified : {value_counter(df_movie, 'director').value_counts()[0]}\")\n\n##### Graphing\nplt.figure(figsize=(16, 8))\n\nmovie_director = value_counter(df_movie, 'director')\nax = sns.countplot(y=movie_director, order=movie_director.value_counts().index[1:26])\n\nax.set_title('Top Featured Movie Directors')\nax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(integer=True))\nax.set_xlabel('Count')\nax.set_ylabel('Name')\n\nplt.show()","501e2841":"plt.figure(figsize=(16, 8))\n\nax = sns.histplot(df_movie['duration'], kde=True)\n\nax.set_title('Movie Duration vs. Count')\nax.set_xlabel('Duration (min.)')\nax.set_ylabel('Count')\n\nplt.show()","8d1a42b4":"plt.figure(figsize=(16, 8))\n\nmovie_genres = value_counter(df_movie, 'listed_in')\nax = sns.countplot(y=movie_genres, order=np.sort(movie_genres.unique()))\n\nax.set_title('Count vs. Movie Categories')\nax.set_xlabel('Count')\nax.set_ylabel('Category')\n\nplt.show()","279c95d7":"print(f\"Not specified : {value_counter(df_movie, 'cast').value_counts()[0]}\")\n\n##### Graphing\nplt.figure(figsize=(16, 8))\n\nmovie_cast = value_counter(df_movie, 'cast')\nax = sns.countplot(y=movie_cast, order=movie_cast.value_counts().index[1:26])\n\nax.set_title('Top Featured Movie Actors\/Actresses')\nax.set_xlabel('Count')\nax.set_ylabel('Name')\n\nplt.show()","dda3d953":"# Generates a dataframe consisting of N random rows.\ndf_temp = df_movie.sample(n=100).reset_index(drop=True)\n\ndf_temp","c21b4d1a":"# Creates the graph and colormap.\ngraph, c = create_graph(df_temp)\n\n##### Graphing\nplt.figure(figsize=(16, 16))\n\nnx.draw(graph, with_labels=False, node_color=c)\nplt.show()","0cf19666":"print(f\"Not specified : {value_counter(df_tv_show, 'director').value_counts()[0]}\")\n\n##### Graphing\nplt.figure(figsize=(16, 8))\n\ntv_show_director = value_counter(df_tv_show, 'director')\nax = sns.countplot(y=tv_show_director, order=tv_show_director.value_counts().index[1:26])\n\nax.set_title('Top Featured TV Show Directors')\nax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(integer=True))\nax.set_xlabel('Count')\nax.set_ylabel('Name')\n\nplt.show()","727de9af":"plt.figure(figsize=(16, 8))\n\nax = sns.countplot(x='duration', data=df_tv_show, order=np.sort(df_tv_show['duration'].unique()))\n\nax.set_title('TV Show Duration vs. Count')\nax.set_xlabel('Duration (Seasons)')\nax.set_ylabel('Count')\n\nplt.show()","bca46dad":"plt.figure(figsize=(16, 8))\n\ntv_show_genres = value_counter(df_tv_show, 'listed_in')\nax = sns.countplot(y=tv_show_genres, order=np.sort(tv_show_genres.unique()))\n\nax.set_title('Count vs. TV Show Categories')\nax.set_xlabel('Count')\nax.set_ylabel('Category')\n\nplt.show()","09062de2":"print(f\"Not specified : {value_counter(df_tv_show, 'cast').value_counts()[0]}\")\n\n##### Graphing\nplt.figure(figsize=(16, 8))\n\ntv_show_cast = value_counter(df_tv_show, 'cast')\nax = sns.countplot(y=tv_show_cast, order=tv_show_cast.value_counts().index[1:26])\n\nax.set_title('Top Featured TV Show Actors\/Actresses')\nax.set_xlabel('Count')\nax.set_ylabel('Name')\n\nplt.show()","fac34b0a":"# Generates a dataframe consisting of N random rows.\ndf_temp = df_tv_show.sample(n=100).reset_index(drop=True)\n\ndf_temp","69825121":"# Creates the graph and colormap.\ngraph, c = create_graph(df_temp)\n\n##### Graphing\nplt.figure(figsize=(16, 16))\n\nnx.draw(graph, with_labels=False, node_color=c)\nplt.show()","ea4b9f98":"movie_recommender = Recommender(df_movie)\n\nprint(movie_recommender.get_recommendation(\"21\"))","3cb1912b":"tv_show_recommender = Recommender(df_tv_show)\n\nprint(tv_show_recommender.get_recommendation(\"Stranger Things\"))","58372338":"### Categories (Listed In)","38196a78":"### Content Type","9b55d5e0":"### Director","0b7dc361":"A majority of TV shows are only one season; this is most likely due to the popularity filter that determines what shows are renewed for another season.\nMost shows usually don't make it past a first season, especially Netflix originals.","14e85177":"### Graph","04622615":"### Content Rating","5a78e0d7":"## TF-IDF\n\nUsing the Term Frequency Inverse Document Frequency (TF-IDF) technique, it's possible to convert the content description into a vector.\nThis is useful because we can use cosine similarity (analogous to the dot product) to determine the 'closest' content.","8f2d89d9":"The holiday season of a given year (October - December) is when the most content is added to Netflix.","5708f3a1":"A majority of actors\/actresses are of Japanese descent, most likely due to the small number of voice actors in Japanese animation.","df7942ca":"A quick summary of the columns:\n\n* `type` - Categorizes the content as a 'Movie' or 'TV Show'\n* `title` - The title of the content (unique?)\n* `director` - The individual(s) who directed the content\n* `cast` - The individual(s) who acted in the content\n* `country` - The country\/countries the content was produced in\n* `date_added` - The year the content was added to Netflix\n* `release_year` - The release year of the content\n* `rating` - The content rating\n* `duration` - The length of the content; minutes for movies and seasons for TV shows\n* `listed_in` - The categories the content is listed in\n* `description` - The description of the content\n\nIt's nice that the provided data looks like it can be used to model relationships between content and (hopefully) allow for a more robust recommender system.","e19070c9":"# Citations\n\n1.  https:\/\/www.kaggle.com\/niharika41298\/netflix-visualizations-recommendation-eda#Recommendation-System-(Content-Based)\n2.  http:\/\/tfidf.com\/\n3.  https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.feature_extraction.text.TfidfVectorizer.html\n4.  https:\/\/www.geeksforgeeks.org\/understanding-tf-idf-term-frequency-inverse-document-frequency\/\n5.  https:\/\/en.wikipedia.org\/wiki\/Cosine_similarity\n6.  https:\/\/www.kaggle.com\/yclaudel\/recommendation-engine-with-networkx\n7.  https:\/\/networkx.org\/documentation\/stable\/tutorial.html\n8.  https:\/\/en.wikipedia.org\/wiki\/Adamic\/Adar_index\n9.  https:\/\/neo4j.com\/docs\/graph-algorithms\/current\/labs-algorithms\/adamic-adar\/","7be3647c":"## TV Show Dataset","41131393":"***WORK IN PROGRESS***","09fcd177":"### Production Country","ac96b31d":"The distribution shows that the target demographic of Netflix is adolescents and adults.","efaae98a":"### Graph","c0120f93":"### Movie","583e851d":"### Date Added","acfdce57":"## Deep Learning(?)","8f652ae5":"Quite a few values are missing, noticeably for: `director`, `cast`, and `country`.\n\nMy hypothesis for the `director` column is that values are missing most likely due to TV shows not having a single director to list.\n\nHowever, it is surprising to see that a decent amount of rows don't possess a `cast` column value, \nbecause this infers that whomever listed the product does not have any idea of what actors\/actresses is in it.\nThat's a little weird, but let's stick with it for now.\n\nLastly, I'm not really sure what to think about the missing values from the `country` column.","b6dd60ce":"A majority of the actors\/actresses are of Indian descent, most likely due to the size of movie production in India.","8b226893":"### Cast","ce432c62":"# Data Cleanse\n\nSome of the columns contain a single string where the values are separated by commas.\nThese need to be parsed to allow for manipulating these values later.\n\nThough for `countries`, only the first country within the string is kept to simplify things.\nThis causes a bit of information loss, but I don't think it's significant for the recommender system.\n\nThe cleansing process is described fairly well within the comments.","53bfbf9e":"# Analysis","11b177cd":"### Cast","c7e45391":"## Movie and TV Show Dataset","323625e9":"### Director","552b1645":"### Categories (Listed In)","ed29c058":"## Movie Dataset","45c79ed1":"The distribution is almost Poissonic... must investigate further.","71392bf4":"# Recommender System","32aa6634":"### Duration","855709ce":"As mentioned, the `type` column categorizes the content as a 'Movie' or a 'TV Show'.\nThe types possess similar attributes, as well as differing attributes.\nSo I think it would be best to create a 'Movie' dataframe and a 'TV Show' dataframe when analyzing type-specific attributes.","c3f6512f":"# Functions","e4279743":"### Release Year","e73dc6df":"# Quick Look\n\nLet's import the dataset and see what data is missing.","e4a21361":"### Duration","c70017df":"### TV Show"}}