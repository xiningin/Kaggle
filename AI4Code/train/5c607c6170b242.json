{"cell_type":{"4dd28316":"code","a47535f1":"code","bf3f9286":"code","5f58b4f3":"code","65802055":"code","9979aeed":"code","c18186d0":"code","2dbc65f2":"code","d068b6c1":"code","c588dfbe":"code","c7f61179":"code","c6738f30":"code","1a1d7143":"code","b88188b5":"code","ee6b9441":"code","beb37e67":"code","6c825dd1":"code","924d8967":"code","2682b240":"code","75b55a6b":"code","84aa2a67":"code","3d4368a6":"code","7717900b":"code","feb582f5":"code","acd3a9dd":"code","966a010c":"code","40990851":"code","3580ba9f":"code","d977de44":"code","519e1dff":"code","fc681220":"code","d0cfcc29":"code","37c52572":"code","0fe02d03":"code","6ee7964a":"code","244e6a4e":"code","1f256de0":"code","5ee70bfd":"code","72dd198e":"code","fa7da89f":"code","b7bc389a":"code","ec6f7861":"code","2fe7268f":"code","e0ea9008":"code","dd441f50":"code","1ac04c04":"code","8c274957":"code","6ebd5e4f":"code","d0f622e2":"code","e0f396f0":"markdown","58e25709":"markdown","edfee7af":"markdown","5826c057":"markdown","74169c9e":"markdown","eff9159f":"markdown","6eae4b0a":"markdown","3110dba4":"markdown","b985676f":"markdown","44d0d0cd":"markdown","c5e8c10f":"markdown","d0e6f70f":"markdown","7e758c70":"markdown","3282b502":"markdown","0fae9b6a":"markdown","9af74d4e":"markdown","3c212cf6":"markdown"},"source":{"4dd28316":"# some necessary imports\nimport string\nimport numpy as np\nimport pandas as pd\nfrom sklearn import preprocessing, linear_model, metrics\nfrom sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer\nfrom sklearn.linear_model import LogisticRegression\n\nfrom sklearn.model_selection import train_test_split, StratifiedKFold, GridSearchCV\nfrom sklearn.metrics import accuracy_score\nimport seaborn as sns\ncolor = sns.color_palette()\nfrom matplotlib import pyplot as plt\n# using plotly since it's very clear to interpret, though seems complicated to code \nfrom plotly import subplots\nimport plotly.graph_objs as go\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)","a47535f1":"train_df = pd.read_csv('..\/input\/spam-text-message-classification\/SPAM text message 20170820 - Data.csv')\ntrain_df.head()","bf3f9286":"train_df['Category'].unique() ","5f58b4f3":"y = [1 if el == 'spam' else 0 for el in train_df['Category']]","65802055":"train_df.info() ","9979aeed":"train_texts, valid_texts, train_y, valid_y = \\\n        train_test_split(train_df['Message'], train_df['Category'], random_state=5, train_size=.75)","c18186d0":"trgt_counts = train_df['Category'].value_counts()\ntrace = go.Bar(\n    x=trgt_counts.index, \n    y = trgt_counts.values,\n    marker=dict(\n        color=trgt_counts.values,\n        colorscale='Picnic',\n        reversescale=True\n    ),\n)\nlayout = go.Layout(\n    title='Target Count',\n    font=dict(size=18),\n    width = 400, \n    height =500,\n)\ndata=[trace]\nfig=go.Figure(data=data,layout=layout)\npy.iplot(fig,filename='TargetCount')","2dbc65f2":"from wordcloud import STOPWORDS # no need to use nltk here\nfrom collections import defaultdict\n\n\ndef generate_ngrams(text, n_gram = 1):\n    token = [token for token in text.lower().split(' ') if token != '' if token not in STOPWORDS]\n    ngrams = zip(*[token[i:] for i in range(n_gram)])\n    return [' '.join(ngram) for ngram in ngrams]","d068b6c1":"# custom function for horizontal bar chart showing n-gram distribution\ndef horizontal_bar_chart(df, color):\n    trace = go.Bar(\n        y = df['word'].values[::-1],\n        x = df['wordcount'].values[::-1],\n        showlegend=False,\n        orientation='h',\n        marker=dict(color=color),\n    )\n    return trace\n\n\ndef get_bar_chart(df, ngram = 1, color = 'blue'):\n    freq_dict = defaultdict(int)\n    for sent in df:\n        for word in generate_ngrams(sent, ngram):\n            freq_dict[word] += 1\n    fd_sorted = pd.DataFrame(sorted(freq_dict.items(),key=lambda x:x[1])[::-1])\n    fd_sorted.columns = ['word','wordcount']\n    return horizontal_bar_chart(fd_sorted.head(50), color)\n\n\ndef create_two_subplots(trace0, \n                        trace1, \n                        subplot_titles = ['Freq words of ham mes','Freq words of spam mes'],\n                        title = 'Count spam plots', \n                        filename = 'Word_count_plots'\n                       ):\n    fig = subplots.make_subplots(rows=1,cols=2, vertical_spacing=0.01,\n                         subplot_titles = subplot_titles)\n    fig.append_trace(trace0,1,1)\n    fig.append_trace(trace1,1,2)\n    fig['layout'].update(height=1000, width=900,paper_bgcolor='rgb(233,233,233)',title = title)\n    py.iplot(fig, filename)","c588dfbe":"train1_df = train_texts[train_y== 'spam']\ntrain0_df = train_texts[train_y == 'ham']\n\n# get the bar chart for ham messages\ntrace0 = get_bar_chart(train0_df, 1, 'blue')\n\n# get the bar chart for spam messages\ntrace1 = get_bar_chart(train1_df, 1, 'red')\n\n#create two subplots\nsub_tit = ['Freq words of ham mes', 'Freq words of spam mes']\ntit= 'Word_count_plots'\ncreate_two_subplots(trace0, trace1, sub_tit, tit)","c7f61179":"# get the bar chart for ham messages\ntrace0 = get_bar_chart(train0_df, 2, 'green')\n\n# get the bar chart for spam messages\ntrace1 = get_bar_chart(train1_df, 2, 'yellow')\n\n#create two subplots\nsub_tit = ['Bigram freq of ham mes', 'Bigram freq of spam mes']\ntit= 'Bigram_count_plots'\ncreate_two_subplots(trace0, trace1, sub_tit, tit)","c6738f30":"# get the bar chart for ham messages\ntrace0 = get_bar_chart(train0_df, 3, 'brown')\n\n# get the bar chart for spam messages\ntrace1 = get_bar_chart(train1_df, 3, 'orange')\n\n#create two subplots\nsub_tit = ['Trigram freq of ham mes', 'Trigram freq of spam mes']\ntit= 'Trigram'\ncreate_two_subplots(trace0, trace1, sub_tit, tit)","1a1d7143":"train_texts = train_texts.to_frame('message')\nvalid_texts=valid_texts.to_frame('message')\n\ntrain_texts['label'] = train_y\nvalid_texts['label'] = valid_y","b88188b5":"# creating some extra features for better prediction accuracy\n\ntrain_texts['num_words'] = train_texts['message'].apply(lambda x: len(str(x).split()))\nvalid_texts['num_words'] = valid_texts['message'].apply(lambda x: len(str(x).split()))\n\ntrain_texts['num_unique_words'] = train_texts['message'].apply(lambda x: len(set(str(x).split())))  # for each mess\nvalid_texts['num_unique_words'] = valid_texts['message'].apply(lambda x: len(set(str(x).split())))\n\ntrain_texts['num_chars'] = train_texts['message'].apply(lambda x: len(str(x))) # for each mess\nvalid_texts['num_chars'] = valid_texts['message'].apply(lambda x: len(str(x)))\n\ntrain_texts['num_stopwords'] = train_texts['message'].apply(lambda x: len([w for w in str(x).lower().split() if w in STOPWORDS]))\nvalid_texts['num_stopwords'] = valid_texts['message'].apply(lambda x: len([w for w in str(x).lower().split() if w in STOPWORDS]))\n\ntrain_texts['num_punctuations'] = train_texts['message'].apply(lambda x: len([p for p in str(x) if p in string.punctuation]))\nvalid_texts['num_punctuations'] = valid_texts['message'].apply(lambda x: len([p for p in str(x) if p in string.punctuation]))\n\ntrain_texts['num_words_upper'] = train_texts['message'].apply(lambda x: len([u for u in str(x) if u.isupper()]))\nvalid_texts['num_words_upper'] = valid_texts['message'].apply(lambda x: len([u for u in str(x) if u.isupper()]))\n\ntrain_texts['num_words_title'] = train_texts['message'].apply(lambda x: len([t for t in str(x) if t.istitle()]))\nvalid_texts['num_words_title'] = valid_texts['message'].apply(lambda x: len([t for t in str(x) if t.istitle()]))\n\ntrain_texts['mean_word_len'] = train_texts['message'].apply(lambda x: np.mean([len(w) for w in str(x).split()]))\nvalid_texts['mean_word_len'] = valid_texts['message'].apply(lambda x: np.mean([len(w) for w in str(x).split()]))","ee6b9441":"# Truncate some extreme values for better visuals ##\ntrain_texts['num_words'].loc[train_texts['num_words']>60] = 60\ntrain_texts['num_punctuations'].loc[train_texts['num_punctuations']>10] = 10\ntrain_texts['num_chars'].loc[train_texts['num_chars']>350] = 350\n\nf, axes = plt.subplots(3, 1, figsize=(10,20))\nsns.boxplot(x='label', y='num_words', data=train_texts,ax=axes[0])\naxes[0].set_xlabel('Label', fontsize=12)\naxes[0].set_title('Number of words in each class', fontsize=15)\n\nsns.boxplot(x='label', y='num_chars', data=train_texts,ax=axes[1])\naxes[1].set_xlabel('Label', fontsize=12)\naxes[1].set_title('Number of characters in each class', fontsize=15)\n\nsns.boxplot(x='label', y='num_punctuations', data=train_texts,ax=axes[2])\naxes[2].set_xlabel('Label', fontsize=12)\naxes[2].set_title('Number of punctuations in each class', fontsize=15)\nf.savefig('distributions.pdf', bbox_inches='tight')","beb37e67":"# get the tfidf vectors \ntfidf_vec = TfidfVectorizer(stop_words ='english', ngram_range=(1,3))\ntfidf_vec.fit_transform(train_texts['message'].values.tolist() + valid_texts['message'].values.tolist())\ntrain_tfidf = tfidf_vec.transform(train_texts['message'].values.tolist())\nvalid_tfidf = tfidf_vec.transform(valid_texts['message'].values.tolist())","6c825dd1":"train_tfidf.shape","924d8967":"import scipy\ntrain_matrix = scipy.sparse.hstack([train_tfidf, train_texts.drop(['message', 'label'], axis = 1)]) # concatenate our features to tfidf features\nvalid_matrix = scipy.sparse.hstack([valid_tfidf, valid_texts.drop(['message', 'label'], axis =1)])","2682b240":"f1s = list(); accuracies = list(); rocs = list()","75b55a6b":"train_y = [1 if x == 'spam' else 0 for x in train_y]\nvalid_y = [1 if x == 'spam' else 0 for x in valid_y]","84aa2a67":"from sklearn import naive_bayes\nfrom sklearn.metrics import roc_auc_score as roc\nfrom sklearn.metrics import accuracy_score as accuracy\n\nnb = naive_bayes.GaussianNB()\nnb.fit(train_matrix.toarray(), train_y)\nnp_preds = nb.predict(valid_matrix.toarray())","3d4368a6":"f1s.append(metrics.f1_score(valid_y, np_preds) )\naccuracies.append(accuracy(valid_y, np_preds))\nrocs.append(roc(valid_y, np_preds))","7717900b":"print(\"F_1 score is {}\".format(f1s[-1]) )\nprint(\"Accuracy is {}\".format(accuracies[-1]) ) \nprint(\"ROC-AUC score is {}\".format(rocs[-1]) )","feb582f5":"from sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.preprocessing import Normalizer","acd3a9dd":"knn = KNeighborsClassifier(n_neighbors=15)\nknn.fit(train_matrix, train_y)\nknn_preds = knn.predict(valid_matrix)","966a010c":"f1s.append(metrics.f1_score(valid_y, knn_preds) )\naccuracies.append(accuracy(valid_y, knn_preds))\nrocs.append(roc(valid_y, knn_preds))","40990851":"print(\"F_1 score is {}\".format(f1s[-1]) )\nprint(\"Accuracy is {}\".format(accuracies[-1]) )\nprint(\"ROC-AUC score is {}\".format(rocs[-1]) )","3580ba9f":"from sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score as accuracy\nfrom seaborn import heatmap","d977de44":"est = LogisticRegression()\nparam_grid = {'C' : np.arange(1, 10, 1), \n              'solver' : ['liblinear', 'newton-cg', 'sag'], \n             'penalty' : ['l1', 'l2']}\ngrid_search = GridSearchCV(est, param_grid, n_jobs = -1, cv=5, verbose = 0)\ngrid_search.fit(train_tfidf, train_y)","519e1dff":"grid_search.best_params_","fc681220":"logit = LogisticRegression(C = 9, penalty = 'l1', solver = 'liblinear')\nlogit.fit(train_tfidf, train_y)\nlogit_preds = logit.predict(valid_tfidf)","d0cfcc29":"f1s.append(metrics.f1_score(valid_y, logit_preds) )\naccuracies.append(accuracy(valid_y, logit_preds))\nrocs.append(roc(valid_y, logit_preds))","37c52572":"print(\"F_1 score is {}\".format(f1s[-1]) )\nprint(\"Accuracy is {}\".format(accuracies[-1]) )\nprint(\"ROC-AUC score is {}\".format(rocs[-1]) )","0fe02d03":"heatmap(confusion_matrix(valid_y, logit_preds) , annot= True, fmt = 'd', cmap=\"YlGnBu\")\nNone","6ee7964a":"est = LogisticRegression()\nparam_grid = {'C' : np.arange(1, 10, 1), \n              'solver' : ['liblinear', 'newton-cg', 'sag'], \n             'penalty' : ['l1', 'l2']}\ngrid_search = GridSearchCV(est, param_grid, n_jobs = -1, cv=5, verbose = 0)\ngrid_search.fit(train_matrix, train_y)","244e6a4e":"grid_search.best_params_","1f256de0":"logit_ext = LogisticRegression(C = 9, penalty = 'l1', solver = 'liblinear')\nlogit_ext.fit(train_matrix, train_y)\nlogit_ext_preds = logit_ext.predict(valid_matrix)","5ee70bfd":"f1s.append(metrics.f1_score(valid_y, logit_ext_preds) )\naccuracies.append(accuracy(valid_y, logit_ext_preds))\nrocs.append(roc(valid_y, logit_ext_preds))","72dd198e":"print(\"F_1 score is {}\".format(f1s[-1]) )\nprint(\"Accuracy is {}\".format(accuracies[-1]) ) \nprint(\"ROC-AUC score is {}\".format(rocs[-1]) )","fa7da89f":"heatmap(confusion_matrix(valid_y, logit_ext_preds) , annot= True, fmt = 'd', cmap=\"YlGnBu\")\nNone","b7bc389a":"from sklearn.svm import SVC\nsvm = SVC()\nparams = {'C': np.arange(1, 12, 1), \"degree\" : np.arange(3, 7, 1)}\ngrid = GridSearchCV(svm, params, n_jobs = -1, cv = 5)\ngrid.fit(train_matrix, train_y)","ec6f7861":"grid.best_params_","2fe7268f":"svm = SVC(C = 10)\nsvm.fit(train_matrix, train_y)\nsvm_preds = svm.predict(valid_matrix)","e0ea9008":"f1s.append(metrics.f1_score(valid_y, svm_preds) )\naccuracies.append(accuracy(valid_y, svm_preds))\nrocs.append(roc(valid_y, svm_preds))","dd441f50":"print(\"F_1 score is {}\".format(f1s[-1]) ) \nprint(\"Accuracy is {}\".format(accuracies[-1]) ) \nprint(\"ROC-AUC score is {}\".format(rocs[-1]) )","1ac04c04":"methods = ['bayesian', 'knn', 'logit', 'logit-ext', 'svm']\nf1s_s = pd.Series(f1s, index = methods)\naccuracies_s = pd.Series(accuracies, index = methods)\nrocs_s = pd.Series(rocs, index = methods)","8c274957":"# Create a bar for the F_1 metric\ntrace0 = go.Bar(\n    x=f1s_s.index, y=f1s_s, name=\"F_1\"\n)\n\n# Create a bar for the accuracies\ntrace1 = go.Bar(\n    x=accuracies_s.index,\n    y=accuracies_s,\n    name=\"Accuracy\",\n)\n\ntrace2 = go.Bar(\n    x=rocs_s.index,\n    y=rocs_s,\n    name=\"ROC-AUC\",\n)\n\ndata = [trace0, trace1, trace2]\nlayout = {\"title\": \"Comparison of methods on metrics distribution\"}\n\n# Create a `Figure` and plot it\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig, show_link=False)","6ebd5e4f":"import eli5\neli5.show_weights(logit, vec=tfidf_vec, top = 50, feature_filter=lambda x: x != '<BIAS>')","d0f622e2":"eli5.show_weights(logit_ext, vec=tfidf_vec, top=50, feature_filter=lambda x: x != '<BIAS>')","e0f396f0":"First we'll look at ngrams distributions:","58e25709":"Now we'll take ```eli5``` library for showing weights of our best model. Therefore we'll be able to interpret it and see impact of most weightful n-grams for classificating sample as a \"spam\" or \"ham\"","edfee7af":"Now we'll analyse ngrams and co-occurences","5826c057":"We'll from the graph we can see that dataset is not balanced","74169c9e":"# Logreg with extended matrix:","eff9159f":"Using eli-5 we can see that the biggest weights for spam class is words like \"claim\", \"awarded\", \"reply\", \"service\" - it makes sence since we always get messages, where we were awarded or had service. While for the ham messages most the haviest words describing sms chatting with friends. ","6eae4b0a":"So in trigrams distribution we clearly can see specific template for spam messages: \"prizes guaranteed\" etc. While for ham messages we can see friendly speech specific for messengers.","3110dba4":"### Clearly we see that logit-ext method is best for hacking this case","b985676f":"There are no missed value so we don't need to handle it","44d0d0cd":"On boxplots we can see, that distributions for 'ham' and 'spam' messages differ a lot. Thus, it will definitely make our model better (we have unique and specific features for each class)","c5e8c10f":"Let's look at the boxplots to make sure we've build some specific features for each class:","d0e6f70f":"# Logistic Regression approach\nBegin with only tf-idf features, later we'll do it for extended matrix for quality comparison.","7e758c70":"# kNN classifier","3282b502":"Since we have texts we can do feature engineering and make extra-features for improving our model. \n\nWe'll make features num of words, num of unique words, num of chars, num of stopwords, punctuations, num of punctuations, num of upper words, num title words and mean of words length","0fae9b6a":"# Naive Bayesian estimator from ```sklearn```","9af74d4e":"Creating lists for metrics:","3c212cf6":"# SVM approach"}}