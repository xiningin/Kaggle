{"cell_type":{"0ec86750":"code","a397948f":"code","dddf1301":"code","667bfaae":"code","f7756602":"code","af0556f0":"code","b97f90f1":"code","036978ae":"code","0b75bb06":"code","e7aa1920":"code","08a4237b":"code","9d5b7971":"code","1bbf10fe":"code","5a93e90e":"code","f23e733b":"code","94bc2205":"code","9773bce7":"code","b5bd7f76":"code","303aa9ae":"code","5ade6fa7":"code","8a2bfc9f":"code","e2ba9455":"code","4c6b03e1":"markdown","b3a7a211":"markdown","ea2c603d":"markdown","abd5c713":"markdown","228f2143":"markdown","cd11a072":"markdown","2c6ae6e4":"markdown","97aa52bb":"markdown","8dd8385b":"markdown","cb6ff57f":"markdown","4e4d93ec":"markdown","b498f17a":"markdown","eff210e8":"markdown","4b96fea8":"markdown","1558c368":"markdown","3d15ecd0":"markdown","baaf9290":"markdown","0fa6ee96":"markdown","80c582b4":"markdown","b8233ae2":"markdown","1f56bbb9":"markdown","53942e46":"markdown","8a1e0bdc":"markdown","4fc7f893":"markdown","43ade9a1":"markdown","1fd63bbd":"markdown"},"source":{"0ec86750":"# Dataset manipulation modules\r\nimport numpy as np\r\nimport pandas as pd\r\n\r\n# Iteration and naming tools\r\nimport re\r\nfrom itertools import compress, product\r\n\r\n# Plot tools\r\nimport matplotlib.pyplot as plt\r\nimport seaborn as sns\r\n\r\n# P-values, Z-scores calculation tools, stats tools\r\nimport scipy\r\n\r\n# Linear Regression tools\r\nimport statsmodels.api as sm\r\n\r\n# Error calculation\r\nimport tensorflow as tf\r\n\r\n# Ignoring warnings\r\nimport warnings\r\nwarnings.filterwarnings(\"ignore\")\r\n\r\n# train\/ test split\r\nfrom sklearn.model_selection import train_test_split\r\n\r\n# Fourier\r\nfrom numpy.fft import *\r\n","a397948f":"df = pd.read_csv(\"..\/input\/calculated-aqi-caaqm-central-university-hyd\/Raw_DATA.csv\")\r\n\r\n# Removing the columns that are not useful\r\ndf.drop([\"To Date\"], axis=1, inplace=True)\r\n\r\n# Renaming Date column\r\ndf.rename({\"From Date\":\"Date\"}, axis=1, inplace=True)\r\n\r\n# Changing date column into datetime object\r\ndf['Date'] = pd.to_datetime(df['Date'], dayfirst= True)\r\n\r\n# changing columns to numeric values\r\nfor element in df.columns[1:]:\r\n    df[element]= pd.to_numeric(df[element], errors='coerce')","dddf1301":"# Sub-Index calculation functions (as per Indian Air Quality Standards)\r\n\r\n# PM2.5\r\ndef SI_PM_25(x):\r\n    SI = 0\r\n    \r\n    if pd.isna(x):\r\n        SI = x\r\n    elif x<=30: \r\n        SI = x*50\/30 \r\n    elif x>30 and x<=60:\r\n        SI = 50+((x-30)*50\/30) \r\n    elif x>60 and x<=90:\r\n        SI = 100+((x-60)*100\/30) \r\n    elif x>90 and x<=120:\r\n        SI = 200+((x-90)*100\/30)\r\n    elif x>120 and x<=250:\r\n        SI = 300+((x-120)*100\/130)\r\n    elif x>250:\r\n        SI = 400+((x-250)*100\/130)\r\n    else:\r\n        SI = x\r\n    \r\n    return SI\r\n\r\n# PM10\r\ndef SI_PM_10(x):\r\n    SI =0\r\n    \r\n    if pd.isna(x):\r\n        SI = x\r\n    elif x<=50 :\r\n        SI = x\r\n    elif x>50 and x<=100:\r\n        SI= x\r\n    elif x>100 and x<=250:\r\n        SI = 100+((x-100)*100\/150)\r\n    elif x>250 and x<=350:\r\n        SI = 200+(x-250)\r\n    elif x>350 and x<=430:\r\n        SI = 300+((x-350)*100\/80)\r\n    elif x>430:\r\n        SI = 400+((x-430)*100\/80)\r\n    else:\r\n        SI = x\r\n    \r\n    return SI\r\n\r\n# NO2\r\ndef SI_NO2(x):\r\n    SI =0\r\n    \r\n    if pd.isna(x):\r\n        SI = x\r\n    elif x<=40:\r\n        SI = x*50\/40\r\n    elif x>40 and x<=80:\r\n        SI = 50+((x-40)*50\/40)\r\n    elif x>80 and x<=180:\r\n        SI = 100+((x-80)*100\/100)\r\n    elif x>180 and x<=280:\r\n        SI = 200+((x-180)*100\/100)\r\n    elif x>280 and x<=400:\r\n        SI = 300+((x-280)*100\/120)\r\n    elif x>400:\r\n        SI = 400+((x-400)*100\/120)\r\n    else:\r\n        SI = x\r\n    \r\n    return SI\r\n\r\n# NH3\r\ndef SI_NH3(x):\r\n    SI=0\r\n    \r\n    if pd.isna(x):\r\n        SI = x\r\n    elif x<=200:\r\n        SI = x*50\/200\r\n    elif x>200 and x<=400:\r\n        SI = 50+((x-200)*50\/200)\r\n    elif x>400 and x<=800:\r\n        SI = 100+((x-400)*100\/400)\r\n    elif x>800 and x<=1200:\r\n        SI = 200+((x-800)*100\/400)\r\n    elif x>1200 and x<=1800:\r\n        SI = 300+((x-1200)*100\/600)\r\n    elif x>1800:\r\n        SI = 400+((x-1800)*100\/600)\r\n    else:\r\n        SI = x\r\n    \r\n    return SI\r\n\r\n# SO2\r\ndef SI_SO2(x):\r\n    SI=0\r\n    \r\n    if pd.isna(x):\r\n        SI = x\r\n    elif x<=40:\r\n        SI = x*50\/40\r\n    elif x>40 and x<=80:\r\n        SI = 50+((x-40)*50\/40)\r\n    elif x>80 and x<=380:\r\n        SI = 100+((x-80)*100\/300)\r\n    elif x>380 and x<=800:\r\n        SI = 200+((x-380)*100\/420)\r\n    elif x>800 and x<=1600:\r\n        SI = 300+((x-800)*100\/800)\r\n    elif x>1600:\r\n        SI =400+((x-1600)*100\/800)\r\n    else:\r\n        SI = x\r\n    \r\n    return SI\r\n\r\n# CO\r\ndef SI_CO(x):\r\n    SI=0\r\n    \r\n    if pd.isna(x):\r\n        SI = x\r\n    elif x<=1:\r\n        SI = x*50\/1\r\n    elif x>1 and x<=2:\r\n        SI = 50+((x-1)*50\/1) \r\n    elif x>2 and x<=10:\r\n        SI = 100+((x-2)*100\/8) \r\n    elif x>10 and x<=17:\r\n        SI = 200+((x-10)*100\/7)\r\n    elif x>17 and x<=34:\r\n        SI = 300+((x-17)*100\/17)\r\n    elif x>34:\r\n        SI = 400+((x-34)*100\/17)\r\n    else:\r\n        SI = x\r\n    \r\n    return SI\r\n\r\n# OZONE\r\ndef SI_OZONE(x):\r\n    SI=0\r\n    \r\n    if pd.isna(x):\r\n        SI = x\r\n    elif x<=50:\r\n        SI = x*50\/50 \r\n    elif x>50 and x<=100:\r\n        SI = 50+((x-50)*50\/50)\r\n    elif x>100 and x<=168:\r\n        SI = 100+((x-100)*100\/68)\r\n    elif x>168 and x<=208:\r\n        SI = 200+((x-168)*100\/40)\r\n    elif x>208 and x<=748:\r\n        SI = 300+((x-208)*100\/539)\r\n    elif x>748:\r\n        SI = 400+((x-400)*100\/539)\r\n    else:\r\n        SI = x\r\n    \r\n    return SI","667bfaae":"# Initiating a Dataframe with dates\r\nsubIndex = pd.DataFrame(df['Date'])\r\n\r\n# Calculating Sub-Indices using functions defined in above code block.\r\nsubIndex['PM2.5 SI'] = df[\"PM2.5\"].apply(SI_PM_25)\r\nsubIndex['PM10 SI'] = df[\"PM10\"].apply(SI_PM_10)\r\nsubIndex['NO2 SI'] = df[\"NO2\"].apply(SI_NO2)\r\nsubIndex['NH3 SI'] = df[\"NH3\"].apply(SI_NH3)\r\nsubIndex['SO2 SI'] = df[\"SO2\"].apply(SI_SO2)\r\nsubIndex['CO SI'] = df[\"CO\"].apply(SI_CO)\r\nsubIndex['Ozone SI'] = df[\"Ozone\"].apply(SI_OZONE)","f7756602":"# AQI is calculated as per Indian AQI calculation standards\r\n\r\n# Initiating Dataframe with Dates\r\naqi = pd.DataFrame(df['Date'])\r\n\r\n# creating an empty AQI row to fill in\r\nNan = np.nan\r\naqi['AQI']=Nan\r\n\r\n# iterating through rows # calculating AQI\r\nfor ind in subIndex.index:\r\n\r\n    # checking either one of PM2.5 or PM10 is available\r\n    while pd.notna(subIndex['PM2.5 SI'][ind]) or pd.notna(subIndex['PM10 SI'][ind]):\r\n\r\n        p_list = [subIndex['PM2.5 SI'][ind], subIndex['PM10 SI'][ind], subIndex['NO2 SI'][ind], subIndex['NH3 SI'][ind], subIndex['SO2 SI'][ind], subIndex['CO SI'][ind],subIndex['Ozone SI'][ind]]\r\n\r\n        # Check_list of bool of available pollutant values in each index or date\r\n        Check_list = list(pd.notna(p_list))\r\n\r\n        # checksum of available Pollutant values is used in if statement\r\n        if sum(Check_list) >=3:\r\n            \r\n            # compresSub-Indexng the list of pollutants to remove Nan to remove uncertainities \r\n            aqi['AQI'][ind]= max(list(compress(p_list, Check_list)))\r\n\r\n        break","af0556f0":"# converting subIndex to set freq of days for resampling\r\ndf = df.set_index('Date').asfreq('D', method=\"ffill\")\r\n\r\n# converting subIndex to set freq of days for resampling\r\nsubIndex = subIndex.set_index('Date').asfreq('D', method=\"ffill\")\r\n\r\n# converting AQI to set freq of days for resampling\r\naqi = aqi.set_index('Date').asfreq('D', method=\"ffill\")\r\n\r\n\r\ndf_list = [df, subIndex, aqi]\r\n\r\n# Dropping year 2017 Data as it is inconsistent with other years.\r\nfor itr in df_list:\r\n    index = itr.loc[\"2017\"].index\r\n    itr.drop(index, inplace=True)\r\n","b97f90f1":"# removing outliers in AQI data to perform regression\r\naqi = aqi.dropna()\r\nz_scores = scipy.stats.zscore(aqi)\r\nabs_z_scores = np.abs(z_scores)\r\nfiltered_entries = (abs_z_scores<3).all(axis=1)\r\naqi = aqi[filtered_entries]","036978ae":"t = np.arange(0, len(aqi))\r\np = np.polyfit(t, aqi.AQI.values, 1)\r\ny = p[0]*t+p[1]\r\n\r\nplt.plot(t,y)","0b75bb06":"# Define Signal\r\nsignal = aqi.AQI.values\r\n\r\nfreq, PSD = scipy.signal.periodogram(signal)\r\n\r\nplt.plot(freq[:10], PSD[:10]) # checking the lower frequencies","e7aa1920":"periodogram = pd.DataFrame({\"Period\": (1\/freq), \"Power Spectral Density\": PSD}).round(2)\r\n\r\nperiodogram[:10]","08a4237b":"train, test = train_test_split(aqi, test_size=0.1, shuffle=False)\r\n\r\nprint(\"Train data shape: \",train.shape)\r\nprint(\"Test data shape: \", test.shape)","9d5b7971":"x = train.AQI.values\r\n\r\ndef fourierExtrapolation(x, n_predict):\r\n    n = x.size\r\n    \r\n    n_harm = 20                     # number of harmonics in model\r\n    \r\n    t = np.arange(0, n)\r\n    p = np.polyfit(t, x, 1)         # find linear trend in x\r\n    \r\n    x_notrend = x - p[0] * t        # detrended x\r\n    \r\n    x_freqdom = fft(x_notrend)  # detrended x in frequency domain\r\n    f = fftfreq(n)              # frequencies\r\n    \r\n    indexes = list(range(n))\r\n    # sort indexes by frequency, lower -> higher\r\n    indexes.sort(key = lambda i: np.absolute(f[i]))\r\n \r\n    t = np.arange(0, n + n_predict)\r\n    restored_sig = np.zeros(t.size)\r\n    \r\n    for i in indexes[:1 + n_harm * 2]:\r\n        ampli = np.absolute(x_freqdom[i]) \/ n   # amplitude\r\n        phase = np.angle(x_freqdom[i])          # phase\r\n        restored_sig += ampli * np.cos(2 * np.pi * f[i] * t + phase)\r\n    \r\n    return restored_sig + p[0] * t\r\n\r\nexog = fourierExtrapolation(x, len(test))\r\n\r\nprint(\"Shape of Exogenous Regressor (Fourier Extraction) for seasonality: \", exog.shape)","1bbf10fe":"train['exog']= exog[:len(train)]\r\ntest['exog']= exog[len(train):]","5a93e90e":"# Initial approximation of parameters using Autocorrelation and Partial Autocorrelation Plots\r\nplt.figure(figsize=(15,7))\r\n\r\nax = plt.subplot(211)\r\nax.set_xlabel(\"Lag\")\r\nsm.graphics.tsa.plot_acf(train.AQI, lags=20, ax=ax)\r\n\r\nax = plt.subplot(212)\r\nax.set_xlabel(\"Lag\")\r\nsm.graphics.tsa.plot_pacf(train.AQI, lags=20, ax=ax)\r\n\r\nplt.suptitle(\"ACF and PACF of AQI Data\")\r\nplt.tight_layout()\r\nplt.show()","f23e733b":"# Initial approximation of parameters\r\nQs = range(0,2) # = 0,1\r\nqs = range(0,2)\r\nPs = range(0,2)\r\nps = range(0,2)\r\nD=0\r\nd=0\r\n\r\nparameters = product(ps, qs, Ps, Qs)\r\nparameters_list = list(parameters)\r\nlen(parameters_list)\r\n\r\n\r\ndef bestmodel(parameters_list, df):\r\n    # Model Selection\r\n    results = []\r\n    best_aic = float(\"inf\")\r\n    warnings.filterwarnings('ignore')\r\n\r\n    for param in parameters_list:\r\n        \r\n        try:\r\n            model=sm.tsa.statespace.SARIMAX(df.AQI, exog=df.exog,order=(param[0], d, param[1]), \r\n                                            seasonal_order=(param[2], D, param[3], 7), enforce_stationarity=False).fit(disp=-1)\r\n        except ValueError:\r\n            print('wrong parameters:', param)\r\n            continue\r\n\r\n        aic = model.aic\r\n\r\n        if aic < best_aic:\r\n            best_model = model\r\n            best_aic = aic\r\n            best_param = param\r\n        \r\n        results.append([param, model.aic])\r\n    return results, best_model\r\n\r\nresults, best_model = bestmodel(parameters_list, train)","94bc2205":"# Best Models\r\nresult_table = pd.DataFrame(results)\r\nresult_table.columns = ['parameters (p,q,P,Q)', 'aic']\r\nprint(result_table.sort_values(by = 'aic', ascending=True).head())\r\nprint(best_model.summary())","9773bce7":"best_model.plot_diagnostics(figsize=(18, 8))\r\nplt.show()","b5bd7f76":"fig, ax = plt.subplots(figsize=(15, 5))\r\n\r\n# Plot the data (here we are subsetting it to get a better look at the forecasts)\r\naqi.plot(ax=ax)\r\n\r\n# Construct the forecasts\r\nfcast = best_model.get_forecast(len(test), exog= test.exog).summary_frame()\r\nfcast.index = test.index\r\nfcast['mean'].plot(ax=ax, style='k--')\r\nax.fill_between(fcast.index, fcast['mean_ci_lower'], fcast['mean_ci_upper'], color='k', alpha=0.1)\r\n\r\nplt.title(\"ARIMA with fourier terms FORECAST\")\r\nplt.legend([\"True Value\", \"ARIMA Prediction\"])\r\nplt.xlabel(\"DATE\")\r\nplt.ylabel(\"AQI Value\")","303aa9ae":"true_values = test.AQI.values\r\npred_values = fcast['mean'].values\r\n\r\nmae_a= tf.keras.metrics.mean_absolute_error(y_pred=pred_values, y_true=true_values).numpy()\r\nrmse_a = tf.sqrt(tf.losses.mean_squared_error(y_pred=pred_values, y_true=true_values)).numpy()\r\nprint(\"MAE: \",mae_a)\r\nprint(\"RMSE: \",rmse_a)","5ade6fa7":"fig, ax = plt.subplots(figsize=(15, 5))\r\naqi.plot(ax=ax)\r\nplt.plot(train.exog)\r\nplt.plot(test.exog)\r\nplt.legend([\"True Value\", \"Fourier Series used for Training\", \"Predicted Fourier Terms\"])\r\nplt.title(\"FOURIER Forecast\")","8a2bfc9f":"true_values = test.AQI.values\r\npred_values = test.exog.values\r\n\r\nmae_f = tf.keras.metrics.mean_absolute_error(y_pred=pred_values, y_true=true_values).numpy()\r\nrmse_f= tf.sqrt(tf.losses.mean_squared_error(y_pred=pred_values, y_true=true_values)).numpy()\r\nprint(\"MAE: \",mae_f)\r\nprint(\"RMSE: \",rmse_f)","e2ba9455":"mae = [mae_a, mae_f]\r\nrmse = [rmse_a, rmse_f]\r\n\r\nprint(\"DATAFRAME WITH RESPECTIVE ERRORS\")\r\npd.DataFrame({\"MAE\": mae, \"RMSE\": rmse}, index=[\"ARIMA WITH FOURIER\", \"FOURIER\"])","4c6b03e1":"## Fourier Extrapolation","b3a7a211":"## AQI Calculation","ea2c603d":"## SI Calculation","abd5c713":"## Trend","228f2143":"## Changing Index and removing Year 2017","cd11a072":"# Libraries","2c6ae6e4":"## Conclusion","97aa52bb":"## Removing Outliers","8dd8385b":"# DATA ANALYSIS","cb6ff57f":"# SARIMA with Fourier terms","4e4d93ec":"### Best Model","b498f17a":"**SARIMA DOESN'T WORK BETTER FOR LONGER SEASONAL PERIODS. SO, WE TRIED MODELING WITH FOURIER TERMS AS EXOGENOUS REGRESSORS. BUT, THE FOURIER FORECAST HAS SLIGHTLY BETTER MAE AND RMSE THAN SARIMA.**\r\n\r\n**BUT, IF WE USE MONTHLY MEAN AS A DATA POINT AND USE 12 MONTHS AS A SEASONALITY THEN WE CAN GET BETTER MONTHLY PREDICTION.**\r\n\r\n**SINCE, WE NEED DAILY PREDICTION, WE TOOK THIS APPROACH OF USING FOURIER TERMS AS A SEASONAL PARAMETERS.**\r\n\r\n**EVEN THOUGH, SARIMA HASN'T GIVEN BETTER PREDICTIONS THAN FOURIER. BY INCREASING DATA POINTS, WE CAN ACHIEVE BETTER ACCURACY IN SARIMA.**","eff210e8":"# AIR QUALITY INDEX CALCULATION","4b96fea8":"### Forecast","1558c368":"## SARIMA","3d15ecd0":"## Fourier Forecast","baaf9290":"## Train-Test Split","0fa6ee96":"After fitting the data to 1 degree polynomial which is basically a linear equation, we obtained coefficients and plotted a graph.\r\nFrom the graph, we can conclude that the overall trend is decreasing as per time.","80c582b4":"SARIMA can't handle large seasonality periods like 300, 600. So, we extrapolate the seasonality using fourier transform and use it as an exogenous regressor for SARIMA model.\r\nSince, We will be using fourier extrapolation as regressor, we use 7 as seasonality for SARIMA","b8233ae2":"### Error","1f56bbb9":"### Error","53942e46":"## Seasonality","8a1e0bdc":"# Dataset","4fc7f893":"## SI functions","43ade9a1":"PACF has a significance till the 1st lag but after that it is insignificant.\r\nThen, A best model should be selected using AIC(Akita Information Criteria) criteria.","1fd63bbd":"By checking spectral density related to each period, we can say that there is a seasonality in the data. The densities related to periods 307, 410, 1230 are higher."}}