{"cell_type":{"04af550b":"code","01307d4a":"code","0c428a79":"code","2ef6c1c8":"code","07bfe6a7":"code","45879bd6":"code","42c38695":"code","183a0fc7":"code","6b30c26e":"code","9adaee08":"code","3d4c15a5":"code","769aa36e":"code","bcb96b29":"code","bd6edb95":"code","21082c0a":"code","3dd4f7f1":"code","fc0793a5":"code","a0207a86":"code","15cddc8a":"code","1eb3caff":"code","f0d0b1b7":"markdown","c162cb88":"markdown","e3e7882a":"markdown","56c7484c":"markdown","ed7ba2eb":"markdown","3c486118":"markdown","93504ddb":"markdown","04c0bfed":"markdown","50069db6":"markdown","8987862a":"markdown","07f3e278":"markdown","d102bb4b":"markdown","22d722af":"markdown","b56f13de":"markdown","b1fdf4b5":"markdown","930d8fe4":"markdown","6bc002f2":"markdown","54ad1549":"markdown","7eb66575":"markdown","256e7a97":"markdown","b9c9a227":"markdown","38be6bef":"markdown","188fdb89":"markdown"},"source":{"04af550b":"# List available input files\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        ","01307d4a":"import pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Read .TSV files from I'TIS\ndf_15T = pd.read_csv('\/kaggle\/input\/dielectricpropertiesmr\/15T.tsv', delimiter='\\t')\ndf_30T = pd.read_csv('\/kaggle\/input\/dielectricpropertiesmr\/30T.tsv', delimiter='\\t')\ndf_70T = pd.read_csv('\/kaggle\/input\/dielectricpropertiesmr\/70T.tsv', delimiter='\\t')\n\n# Print example (7.0T) dataframe:\nprint('Dielectrical properties at 7T')\nprint(df_70T)\n\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","0c428a79":"import math\nimport numpy as np # linear algebra\n\ndef calc_wavelength(rel_perm, tesla):\n    wavelength_air = 300e6 \/ (42.58e6 * tesla)\n    if rel_perm == 0:\n        return np.NaN\n    wavelength_relative = wavelength_air \/ math.sqrt(rel_perm)\n    \n    return wavelength_relative\ndf_15T['Wavelength (m)'] = df_15T.apply(lambda row: calc_wavelength(row['Permittivity'], 1.5), axis=1)\ndf_30T['Wavelength (m)'] = df_30T.apply(lambda row: calc_wavelength(row['Permittivity'], 3.0), axis=1)\ndf_70T['Wavelength (m)'] = df_70T.apply(lambda row: calc_wavelength(row['Permittivity'], 7.0), axis=1)\n\n# Print example (7.0T) dataframe:\nprint('Dielectrical properties at 7T')\nprint(df_70T)\n","2ef6c1c8":"print('1.5 Tesla')\ndf_15T.loc[df_15T['Tissue'].str.contains('Brain')]","07bfe6a7":"print('3.0 Tesla')\ndf_30T.loc[df_30T['Tissue'].str.contains('Brain')]","45879bd6":"print('7.0 Tesla')\ndf_70T.loc[df_70T['Tissue'].str.contains('Brain')]","42c38695":"import scipy.io\nimport numpy.ma as ma\nimport matplotlib.pyplot as plt\n\n# Load matlab file\nB1cal_matlab = scipy.io.loadmat('\/kaggle\/input\/b1cal-3t\/B1cal_3T.mat')\nB1 = B1cal_matlab['B1']\nmask = B1cal_matlab['mask']\n\n# Determine number of channels\ntx_channels = np.shape(B1)[-1]\n\n# Mask the B1 maps and create sensitivity maps\nmask_full = np.repeat(mask[..., np.newaxis], tx_channels, axis=2)\nB1m = ma.masked_array(B1, mask=np.logical_not(mask_full))\n\n# Determine global plotting window\nvmin = np.percentile(np.abs(B1m), 1)\nvmax = np.percentile(np.abs(B1m), 99)\n\n# Create the grid figure\nfig, axis = plt.subplots(2, tx_channels, sharex=True, sharey=True)\nfig.set_size_inches(24, 4)\n\n# Loop over channels\nfor chan in range(tx_channels):\n    # Show B1 intensity\n    im0 = axis[0, chan].imshow(np.abs(B1m[:, :, chan]), vmin=vmin, vmax=vmax)\n    axis[0, chan].set_title('Chan #' + str(chan+1))\n    # Show B1 phase with cyclic colormap\n    im1 = axis[1, chan].imshow(np.angle(B1m[:, :, chan]), vmin=-np.pi, vmax=np.pi, cmap='twilight_shifted')\n\n# Label the axis\naxis[0, 0].set_ylabel('B1 amplitude')\naxis[1, 0].set_ylabel('B1 phase')\n\n# Show the colorbar\nfig.colorbar(im0, ax=axis[0, :], shrink=0.8)\nfig.colorbar(im1, ax=axis[1, :], shrink=0.8)\nfig.show()\n","183a0fc7":"# Sum over the channel dimension\nB1m_sum = np.sum(B1m, axis=2)\n\n# Determine global plotting window again\nvmin = np.percentile(np.abs(B1m_sum), 1)\nvmax = np.percentile(np.abs(B1m_sum), 99)\n\n# Create new figure\nfig, axis = plt.subplots(1, 2, sharey=True)\nfig.set_size_inches(8, 4)\n\n# Plot B1 amplitude\nim0 = axis[0].imshow(np.abs(B1m_sum), vmin=vmin, vmax=vmax)\naxis[0].set_title('B1 amplitude at 0\u00b0')\n\n# Plot B1 phase\nim1 = axis[1].imshow(np.angle(B1m_sum), vmin=-np.pi, vmax=np.pi, cmap='twilight_shifted')\naxis[1].set_title('B1 phase at 0\u00b0')\n\n# Show the colorbar\nfig.colorbar(im0, ax=axis[0], shrink=0.55)\nfig.colorbar(im1, ax=axis[1], shrink=0.55)\nfig.show()","6b30c26e":"# Create a copy of the matrix, we will overwrite the data but preserve the mask\nB1m_CP = B1m.copy()\n\n# Create CP phase offsets by spacing the channels evenly around a full rotation\nCP_shim = np.linspace(0, 2*np.pi, tx_channels, endpoint=False)\n\n# Apply the phase shift\nfor chan in range(tx_channels):\n    B1m_CP[..., chan] = B1m[..., chan] * np.exp(1j * CP_shim[chan])\n\n# Calculate the resulting total B1 field\nB1m_CP_sum = np.sum(B1m_CP, axis=2)\n\n\n# Plot shim settings per channels\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\nch_names = ['Ch1', 'Ch2', 'Ch3', 'Ch4', 'Ch5', 'Ch6', 'Ch7', 'Ch8']\nax.bar(ch_names, CP_shim\/np.pi*180)\nax.set_title('Channel offsets for center shim')\nax.set_ylabel('Angle (degrees)')\n\n# Determine global plotting window again\nvmin = np.percentile(np.abs(B1m_CP_sum), 1)\nvmax = np.percentile(np.abs(B1m_CP_sum), 99)\n\n# Create new figure\nfig, axis = plt.subplots(1, 2, sharey=True)\nfig.set_size_inches(8, 4)\n\n# Plot B1 amplitude\nim0 = axis[0].imshow(np.abs(B1m_CP_sum), vmin=vmin, vmax=vmax)\naxis[0].set_title('B1 amplitude at CP')\n\n# Plot B1 phase\nim1 = axis[1].imshow(np.angle(B1m_CP_sum), vmin=-np.pi, vmax=np.pi, cmap='twilight_shifted')\naxis[1].set_title('B1 phase at CP')\n\n# Show the colorbar\nfig.colorbar(im0, ax=axis[0], shrink=0.55)\nfig.colorbar(im1, ax=axis[1], shrink=0.55)\nfig.show()","9adaee08":"#import scipy.stats\n#scipy.stats.variation\n\nB1m_cv = np.abs(B1m_sum).std() \/ np.abs(B1m_sum).mean()\nB1m_CP_cv = np.abs(B1m_CP_sum).std() \/ np.abs(B1m_CP_sum).mean()\n\nprint('CV 0deg: ' + str(round(B1m_cv, 2)))\nprint('CV CP: ' + str(round(B1m_CP_cv, 2)))","3d4c15a5":"# Create a copy of the matrix, we will overwrite the data but preserve the mask\nB1m_cshim = B1m.copy()\n\n# Calc center coordinate\ncenterx = math.floor(np.shape(B1)[0] \/ 2)\ncentery = math.floor(np.shape(B1)[1] \/ 2)\n\n# Create array to save shim\ncenter_shim_degrees = np.ndarray(tx_channels)\n\n# Apply phase shift to 0deg in center\nfor chan in range(tx_channels):\n    center_shim_degrees[chan] = -np.angle(B1m[centerx, centery, chan]) \/ (2*np.pi) * 360\n    B1m_cshim[..., chan] = B1m[..., chan] * np.exp(-1j * np.angle(B1m[centerx, centery, chan]))\n    #print(np.angle(B1_center_shim[centerx, centery, chan]))\n    \n# Plot shim settings per channels\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\nch_names = ['Ch1', 'Ch2', 'Ch3', 'Ch4', 'Ch5', 'Ch6', 'Ch7', 'Ch8']\nax.bar(ch_names, center_shim_degrees)\nax.set_title('Channel offsets for center shim')\nax.set_ylabel('Angle (degrees)')","769aa36e":"# Calc resulting fields\nB1m_cshim_sum = np.sum(B1m_cshim, axis=2)\n    \n# Determine global plotting window again\nvmin = np.percentile(np.abs(B1m_cshim_sum), 1)\nvmax = np.percentile(np.abs(B1m_cshim_sum), 99)\n\n# Create new figure\nfig, axis = plt.subplots(1, 2, sharey=True)\nfig.set_size_inches(8, 4)\n\n# Plot B1 amplitude\nim0 = axis[0].imshow(np.abs(B1m_cshim_sum), vmin=vmin, vmax=vmax)\naxis[0].set_title('B1 amplitude at center shim')\n\n# Plot B1 phase\nim1 = axis[1].imshow(np.angle(B1m_cshim_sum), vmin=-np.pi, vmax=np.pi, cmap='twilight_shifted')\naxis[1].set_title('B1 phase at center shim')\n\n# Show the colorbar\nfig.colorbar(im0, ax=axis[0], shrink=0.55)\nfig.colorbar(im1, ax=axis[1], shrink=0.55)\nfig.show()\n\n\n# B1 strength in center\nprint('B1 center 0deg: ' + str(np.abs(B1m_sum[centerx, centery])))\nprint('B1 center CP: ' + str(np.abs(B1m_CP_sum[centerx, centery])))\nprint('B1 center cshim: ' + str(np.abs(B1m_cshim_sum[centerx, centery])))\n\n# B1 strength in center, relative to 0deg\nprint('B1% center 0deg: 100.0%')\nprint('B1% center CP: ' + str( round(np.abs(B1m_CP_sum[centerx, centery])\/np.abs(B1m_sum[centerx, centery])*100) ) + '%')\nprint('B1% center cshim: ' + str( round(np.abs(B1m_cshim_sum[centerx, centery])\/np.abs(B1m_sum[centerx, centery])*100) ) + '%')\n\n# Calc CV of new center shimset\nB1m_cshim_cv = np.abs(B1m_cshim).std() \/ np.abs(B1m_cshim).mean()\nprint('CV center shim: ' + str(round(B1m_cshim_cv, 2)))","bcb96b29":"from scipy.optimize import minimize, least_squares\n\n# Define the costfunction that will be minimized\ndef costfunc(shims, B1_masked, exp_goal = 2):\n    # Apply shims\n    B1sens = B1_masked.copy()\n    for chan in range(len(shims)):\n        B1sens[..., chan] = B1sens[..., chan] * np.exp(1j * shims[chan])\n        \n    # Calculate cost function\n    B1shim = np.abs(np.sum(B1sens, axis=2))\n    cost = B1shim.std() \/ (B1shim.mean()**exp_goal)\n\n    return cost\n\n# Create phase bounds\nbounds = [(0, 2*np.pi) for i in range(8)]  \n\n# Perform actual optimization of the RF fields\n# Make an educated guess and start with CP shim\nres = minimize(costfunc, CP_shim, args=(B1m), method='trust-constr', bounds=bounds, options={'disp': True, 'maxiter':1e3, 'xtol':1e-4})\n\n# Center phases around 0\nshim_avg = res.x.mean()\nshim = res.x - shim_avg\n","bd6edb95":"# Plot shim settings per channels\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\nch_names = ['Ch1', 'Ch2', 'Ch3', 'Ch4', 'Ch5', 'Ch6', 'Ch7', 'Ch8']\nax.bar(ch_names, shim\/np.pi*180)\nax.set_title('Channel offsets for center shim')\nax.set_ylabel('Angle (degrees)')\n\n\n# Create a copy of the matrix, we will overwrite the data but preserve the mask\nB1m_shim = B1m.copy()\n\n# Apply shim\nfor chan in range(tx_channels):\n    B1m_shim[..., chan] = B1m[..., chan] * np.exp(1j * res.x[chan])\n\n# Calc resulting fields\nB1m_shim_sum = np.sum(B1m_shim, axis=2)\n\n\n# Determine global plotting window again\nvmin = np.percentile(np.abs(B1m_shim_sum), 1)\nvmax = np.percentile(np.abs(B1m_shim_sum), 99)\n\n# Create new figure\nfig, axis = plt.subplots(1, 2, sharey=True)\nfig.set_size_inches(8, 4)\n\n# Plot B1 amplitude\nim0 = axis[0].imshow(np.abs(B1m_shim_sum), vmin=vmin, vmax=vmax)\naxis[0].set_title('B1 amplitude at optimised shim')\n\n# Plot B1 phase\nim1 = axis[1].imshow(np.angle(B1m_shim_sum), vmin=-np.pi, vmax=np.pi, cmap='twilight_shifted')\naxis[1].set_title('B1 phase at optimised shim')\n\n# Show the colorbar\nfig.colorbar(im0, ax=axis[0], shrink=0.55)\nfig.colorbar(im1, ax=axis[1], shrink=0.55)\nfig.show()\n\n\n# B1 strength in center\nprint('B1 in center full shim: ' + str(np.abs(B1m_shim_sum[centerx, centery])))\n\n# B1 strength in center, relative to 0deg\nprint('B1% in center full shim: ' + str( round(np.abs(B1m_shim_sum[centerx, centery])\/np.abs(B1m_sum[centerx, centery])*100) ) + '%')\n\n# Calc CV of new center shimset\nB1_res_cv = B1m_shim_sum.std() \/ B1m_shim_sum.mean()\nprint('CV center shim: ' + str(round(B1_res_cv, 2)))","21082c0a":"import seaborn as sns\n\n# Create new figure\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\n\n# Plot the full optimized shim\nsns.distplot(np.abs(B1m_shim_sum).compressed(), hist=True, kde=True, \n             bins=50, color = 'darkblue', label='Optimized shim',\n             hist_kws={'edgecolor':'black'},\n             kde_kws={'linewidth': 4}, ax=ax)\n\n# Plot the CP shim\nsns.distplot(np.abs(B1m_CP_sum).compressed(), hist=True, kde=True, \n             bins=50, color = 'darkgreen', label='CP (quadrature)',\n             hist_kws={'edgecolor':'black'},\n             kde_kws={'linewidth': 4}, ax=ax)\n\n# Plot the center voxel shim\nsns.distplot(np.abs(B1m_cshim_sum).compressed(), hist=True, kde=True, \n             bins=50, color = 'darkred', label='Center shim',\n             hist_kws={'edgecolor':'black'},\n             kde_kws={'linewidth': 4}, ax=ax)\n\n# Add some labels\nax.set_title('B1 density profile (and histogram) for different shims')\nax.set_ylabel('Amount of binned voxels')\nax.set_xlabel('B1 (au.)')\n\n# Show the legend\nplt.legend()\nplt.show()","3dd4f7f1":"# Create new figure\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\n\n\nfor exp_goal in np.arange(0.5,9.5,1):\n    \n    # Perform optimization of the RF fields, but now also provide the exp_goal\n    res = minimize(costfunc, CP_shim, args=(B1m, exp_goal), method='trust-constr', bounds=bounds, options={'disp': True, 'maxiter':1e3, 'xtol':1e-4})\n\n    # Calc resulting fields\n    B1m_expshim = B1m.copy()\n    for chan in range(tx_channels):\n        B1m_expshim[..., chan] = B1m[..., chan] * np.exp(1j * res.x[chan])\n    B1m_expshim_sum = np.sum(B1m_expshim, axis=2)\n\n    # Plot the optimized shim\n    sns.distplot(np.abs(B1m_expshim_sum).compressed(), hist=True, kde=True, \n                 bins=50, label='exp_goal= ' + str(exp_goal),\n                 hist_kws={'edgecolor':'black'},\n                 kde_kws={'linewidth': 4}, ax=ax)\n\n# Add some labels\nax.set_title('B1 density profile (and histogram) for different shims')\nax.set_ylabel('Amount of binned voxels')\nax.set_xlabel('B1 (au.)')\n\n# Show the legend\nplt.legend()\nplt.show()","fc0793a5":"# Define the MLS costfunction that will be minimized\ndef MLS_costfunc(shims, B1_masked, B1_target = 1e-6):\n    # Apply shims\n    B1sens = B1_masked.copy()\n    for chan in range(len(shims)):\n        B1sens[..., chan] = B1sens[..., chan] * np.exp(1j * shims[chan])\n        \n    # Calculate cost function\n    B1shim = np.abs(np.sum(B1sens, axis=2))\n    cost = ((B1shim-B1_target)**2).sum()\n\n    return cost\n\n# Perform actual optimization of the RF fields\n# Make an educated guess and start with CP shim\nres = minimize(MLS_costfunc, CP_shim, args=(B1m), method='trust-constr', bounds=bounds, options={'disp': True, 'maxiter':1e3, 'xtol':1e-20, 'gtol': 1e-20,})\n\n\n# Center phases around 0\nshim_avg = res.x.mean()\nshim = res.x - shim_avg\n\n# Plot shim settings per channels\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\nch_names = ['Ch1', 'Ch2', 'Ch3', 'Ch4', 'Ch5', 'Ch6', 'Ch7', 'Ch8']\nax.bar(ch_names, shim\/np.pi*180)\nax.set_title('Channel offsets for MLS shim')\nax.set_ylabel('Angle (degrees)')\nplt.show()","a0207a86":"# Calc resulting fields\nB1m_MLSshim = B1m.copy()\nfor chan in range(tx_channels):\n    B1m_MLSshim[..., chan] = B1m[..., chan] * np.exp(1j * res.x[chan])\nB1m_MLSshim_sum = np.sum(B1m_MLSshim, axis=2)\n\n\n# Create new figure\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\n\n# Plot the MLS shim\nsns.distplot(np.abs(B1m_MLSshim_sum).compressed(), hist=True, kde=True, \n             bins=50, label='MLS shim',\n             hist_kws={'edgecolor':'black'},\n             kde_kws={'linewidth': 4}, ax=ax)\n\n# Plot the modified CV shim\nsns.distplot(np.abs(B1m_shim_sum).compressed(), hist=True, kde=True, \n             bins=50, label='Modified CV shim',\n             hist_kws={'edgecolor':'black'},\n             kde_kws={'linewidth': 4}, ax=ax)\n\n# Add some labels\nax.set_title('B1 density profile (and histogram) for different shims')\nax.set_ylabel('Amount of binned voxels')\nax.set_xlabel('B1 (au.)')\n\n# Show the legend\nplt.legend()\nplt.show()","15cddc8a":"# Perform MLS optimization of the RF fields, with slightly raised B1_target\nres = minimize(MLS_costfunc, CP_shim, args=(B1m, 1.05e-6), method='trust-constr', bounds=bounds, options={'disp': True, 'maxiter':1e3, 'xtol':1e-20, 'gtol': 1e-20,})\n\n# Calc resulting fields\nB1m_MLS2shim = B1m.copy()\nfor chan in range(tx_channels):\n    B1m_MLS2shim[..., chan] = B1m[..., chan] * np.exp(1j * res.x[chan])\nB1m_MLS2shim_sum = np.sum(B1m_MLS2shim, axis=2)\n\n# Create new figure\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\n\n# Plot the MLS shim\nsns.distplot(np.abs(B1m_MLS2shim_sum).compressed(), hist=True, kde=True, \n             bins=50, label='MLS shim',\n             hist_kws={'edgecolor':'black'},\n             kde_kws={'linewidth': 4}, ax=ax)\n\n# Plot the modified CV shim\nsns.distplot(np.abs(B1m_shim_sum).compressed(), hist=True, kde=True, \n             bins=50, label='Modified CV shim',\n             hist_kws={'edgecolor':'black'},\n             kde_kws={'linewidth': 4}, ax=ax)\n\n# Add some labels\nax.set_title('B1 density profile (and histogram) for different shims')\nax.set_ylabel('Amount of binned voxels')\nax.set_xlabel('B1 (au.)')\n\n# Show the legend\nplt.legend()\nplt.show()\n\n\n\n# Determine global plotting window again\nvmin = np.percentile(np.abs(B1m_shim_sum), 1)\nvmax = np.percentile(np.abs(B1m_shim_sum), 99)\n\n# Create new figure\nfig, axis = plt.subplots(1, 2, sharey=True)\nfig.set_size_inches(8, 4)\n\n# Plot B1 amplitude MLS shim\nim0 = axis[0].imshow(np.abs(B1m_MLS2shim_sum), vmin=vmin, vmax=vmax)\naxis[0].set_title('B1 MLS shim')\n\n# Plot B1 amplitude modified CV shim\nim1 = axis[1].imshow(np.abs(B1m_shim_sum), vmin=vmin, vmax=vmax)\naxis[1].set_title('B1 modified CV shim')\n\n# Show the colorbar\nfig.colorbar(im0, ax=axis[0], shrink=0.55)\nfig.colorbar(im1, ax=axis[1], shrink=0.55)\nfig.show()\n","1eb3caff":"# Create new figure\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\n\n\nfor B1_target in np.arange(0.8e-6,1.25e-6,0.05e-6):\n    \n    # Perform MLS optimization of the RF fields, but now provide the B1_target\n    res = minimize(MLS_costfunc, CP_shim, args=(B1m, B1_target), method='trust-constr', bounds=bounds, options={'disp': True, 'maxiter':1e3, 'xtol':1e-20, 'gtol': 1e-20,})\n\n    # Calc resulting fields\n    B1m_MLStshim = B1m.copy()\n    for chan in range(tx_channels):\n        B1m_MLStshim[..., chan] = B1m[..., chan] * np.exp(1j * res.x[chan])\n    B1m_MLStshim_sum = np.sum(B1m_MLStshim, axis=2)\n\n\n    # Plot the optimized shim\n    sns.distplot(np.abs(B1m_MLStshim_sum).compressed(), hist=False, kde=True, \n                 bins=50, label=f'B1_target= {B1_target:.2E}',\n                 hist_kws={'edgecolor':'black'},\n                 kde_kws={'linewidth': 4}, ax=ax)\n\n# Add some labels\nax.set_title('B1 density profile (and histogram) for different shims')\nax.set_ylabel('Amount of binned voxels')\nax.set_xlabel('B1 (au.)')\n\n# Show the legend\nplt.legend()\nplt.show()","f0d0b1b7":"To calculate the B1 field all 8 transmit channels would produce, we simply need to add the complex fields.","c162cb88":"The resulting B1 field can now also be computed by summing over the 8 channels again. Due to the scaling it seems like the the center is worse than the CP shim, but printing the absolute values show that it is actually beter. Just for fun we can also compute the CV measure of homogeneity.","e3e7882a":"Since the wavelength in brain is asked for specifically, we can print those out for each fieldstrength:","56c7484c":"----\n### b)\n> Load the simulated B1+ fields from B1cal_3T.mat and plot the B1+ amplitude and phase from each of the transmit channels (for example using the Matlab functions subplot and imagesc).\n> Construct the total B1+ field when driving the array with equal phases and amplitudes and plot the B1+ amplitude of the total field.\n> Determine the relative inhomogeneity of the B1+ amplitude by dividing the standard deviation with its mean value, also known as coefficient of variation (CV).\n> Compare the results with those obtained when driving the transmit array in CP1+ mode.\n\n\nFirstly we load the previsously uploaded Matlab file `B1cal_3T.mat`, then we plot induvidual RF fields. Often the first channels phase is used as reference and thus set to 0, but I'm personally not a fan of that technique (from experience I know it can only mess with calculations in areas with low B1 and imperfect phase measurements).","ed7ba2eb":"# RF shimming - Advanced MRI Assignment\n\nNote: This is deliverable of a TU Delft Advanced MRI course assignment.\n\n### Description\nThe radiofrequency (RF) wavelength in tissue shrinks to dimensions that are comparable with the human body from B0~3 T and higher. This gives rise to wave-interferences in the B1+ field which degrade the MR excitation uniformity and can introduce severe artifacts in MR images. One can improve these interferences by using multiple independent transmit coils, or transmit arrays, each driven with an independent RF amplitude and phase to optimize the total B1+ distribution. In this assignment you will implement such an algorithm and combine B1+ fields of an 8-channel 3T body coil.\n\n----\n### a)\n\n> Compute the RF wavelength in brain tissue when B0 = 1.5T, 3T and 7T.\n> The dielectric properties can be obtained through the I\u2019TIS foundation at https:\/\/itis.swiss\/virtual-> population\/tissueproperties\/database\/dielectric-properties\/. How does permittivity influence RF fields in the\n> human body? And electrical conductivity?\n\n\nSince the I'TIS website lists dielectric properties for specific frequencies, we first need to convert the fieldstrength to the Larmor frequency using the following formula:\n\\\\[ f_{0}  =  \u03b3*B_{0} \\\\]\nWhere \\\\( \u03b3 \\\\) is the gyromagnetic ratio which is for proton \\\\( \\gamma = 42.58 \\\\) (MHz\/T)\n\nUsing this formula the following frequencies are found:\n| \\\\(B_0\\\\) | \\\\( f_{Larmor}\\\\) (MHz) |\n| ---- | ----- |\n| 1.5T | 63.87 | \n| 3.0T | 127.74 |\n| 7.0T | 298.06 |\n(The table does not work in Kaggle.. Double click me to view source)\n\nThese frequencies are entered on the I'TIS site and used to generate dielectric property lists for the 3 fieldstrengths. The properties have been exported using the 'Export' button and uploaded as `.TSV` to this notebook.","3c486118":"----\n### c)\n> Determine the phase of each of the B1+ fields in the center of the configuration.\n> Use this information to constructively interfere all of the channels in this location.\n> Plot the combined B1+ amplitude and evaluate the field inhomogeneity.\n> Plot the obtained complex RF shim vector in the complex plane (for example using the Matlab function plot).\n\nFirstly we take the phase of the center voxel and use the multiplication by \\\\( e^{-i\\theta} \\\\) to set the phase to zero, so that a summation of all channels will be constructive in the center. The resulting phase offsets are plotted below:\n","93504ddb":"### MLS\n\nSince I've deviated from the original optimalisation algorithm, MLS, let's compare how that impacted the RF shim. Since it seems the B1 maps were scaled to be exactly \\\\(1\\times10^{-6}\\\\) everywhere when shimmed correctly, the sometimes difficult task of picking the `B1_target` is quite easy in this case.","04c0bfed":"To drive these 8Tx elements in CP mode, we need to offset the phase of each element by 360\/8=45 degrees. The easiest way to apply such phase offsets is to multiply by \\\\( e^{i\\theta} \\\\). After the phase shift we can calculate the resulting field by addition again and plot the resulting field:","50069db6":"That parameter is more complex to choose! I even had to turn of the histogram to properly show the B1 densities...\n\nIn practice, I would still prefer our introduced (modified CV) shim since it's `exp_goal` parameter is easier to tweak.","8987862a":"----\n### d)\n> Implement the MLS algorithm as described in the paper of Homann et al., without SAR constraints and in a Matrix format (Ax = b).\n> Determine the RF shim (amplitude and phase) which optimizes the homogeneity of the B1+ distribution.\n> Plot the combined B1+ amplitude and evaluate the relative B1+ field inhomogeneity in terms of the CV value.\n\nHaving implemented and tested various shimming techniques and algorithmes before, including a MLS shim, I'm going to deviate from the course slightly and tweak the shimming algorithm... :)\n\n(If I find the time before the deadline, I'll show a comparison with MLS from Homann et al. - which I did!)\n\nIn practice, we've found `(min{ std(RF(Mask))\/mean(RF(Mask))^Exponent_Goal }` to be a more robust and better alogrithm. MLS requires a target B1, which is a parameter that is difficult to tweak between B1 efficiency and homogeneity. The `Exponent_Goal` variable offers a more robustly tweakable and consistant tradeoff. \n\n","07f3e278":"Awesome! We're now done, let's look at the results!","d102bb4b":"It probably took a bit longer to run, but the impact of the parameter is visible in the B1 density graph. By setting the `Exponent_Goal` closer to 0, the B1 effeciency will be lower but the field will be more homogenous. By setting the `Exponent_Goal` higher, B1 peak power is prefered at the cost of uniformity. The paramater is easily tweakable since it tends to have a broad range in which it will converge to a specific shimset.","22d722af":"Wow, that was extremely easy to optimize - did not expect that... Appereantly this problem is very suitable for a MLS solver!\n\nNow let's see if we can spot the difference with our own shimming algorithm:","b56f13de":"# The End!","b1fdf4b5":"Great! Now the 2 optimalisation techniques are performing really similar. But this required manual cherry-picking of the `B1_target` and that is not a realistic clinical usage possibilty. Let's see how sensitive the `B1_target` is:","930d8fe4":" These `.TSV` files are loaded into a pandas dataframe and used for further processing:","6bc002f2":"------\n## Bonus stuff\n\n### Exponent_Goal\nPreviously, I've stated that `Exponent_Goal` in the minimisation target is a nicely tweakable parameter. Let's see what is does! Below the effect of the variable is shown by optimising an shimset for 8 different values:","54ad1549":"Looking at the plotted B1 amplitude and phase, the shimming seems to be successfull.\n\nThe CV is the lowest we have seen sofar, although it could be lowered by jointly optimizing the RF amplitudes and not just the phases. The B1 strength in the center is not as high as our previous shim on that point, but that is expected.\n\nTo gain a better insight into the effects of different RF shims (or even excitations in general), I prefer to look at the B1 density profile:","7eb66575":"Now the wavelenght can be computed using the following formula: \\\\(\\lambda_{tissue} = \\frac{\\lambda_{air}}{\\sqrt{\\epsilon_r}}\\\\), where \\\\(\\lambda_{air} = \\frac{c}{f} \\\\).\n\nFrom this formula we can conclude that the conductivity has no impact on the wavelength. The relationship between the wavelength and permitivity is simple and can be used to calculate for all tissues in the I'TIS database:","256e7a97":"In the above density profiles the effect of the different shimming techniques is clearly visible. A small peak translates into a homogenious field and the average B1 is good measure of the efficiency of the RF excitation.\n\nThe optimisation in the center resulted a broad peak and thus not very homogenious excitation, but could still be prefered to the optimised shim when the peak B1 in the smaller center region is prefered. The choice of shimset is dependant on the usage of the RF pulse.","b9c9a227":"The difference is, as expected, small - but definitifly noticable. Our modified algorithm produced both a slightly narrower B1 density peak a higher average, resulting in both better homogeneity and efficiency!\n\nBut what if we could force the MLS algorithm to optimize for a higher `B1_target` and thus efficiency? Let's see how that works out:","38be6bef":"----\n### e)\n> Propose three alternative strategies based on literature to further improve excitation uniformity.\n\nI could probably talk for a day about this topic, but I'm guessing that's not entirely desired here... One of the best overviews of the common strategies is the review by [Padermo et al: Parallel transmission for ultrahigh-field imaging](https:\/\/www.researchgate.net\/profile\/Arian_Beqiri\/publication\/277025178_Parallel_transmission_for_ultrahigh-field_imaging_Parallel_Transmission_for_Ultrahigh-Field_Imaging\/links\/595f4eceaca2728c11592198\/Parallel-transmission-for-ultrahigh-field-imaging-Parallel-Transmission-for-Ultrahigh-Field-Imaging.pdf). Even though it starting to get older, being from 2015, it is still very worthwile to read. During my internship at the Spinoza Centre, I've read it _a lot..._\n\n\nTo answer the question; uniformity can be improved by adding more **dimensions** to the optimalisation process. The most obvious dimension would be adding more transmit channels and thus more phases, but that benefit quickly tapers of and requires more hardware. The common 2 solutions are:\n1. Split up RF pulses in the time domain. In this way, multiple complimentary shimsets can be used. Shimsets could be swapped between readouts, but for certain pulses also during the RF excitation itself.\n2. Start using the gradients that are in a MRI anyway. K-space does not only exist for the readout-regime, but also in the transmit-world. By transmitting offcenter in transmit K-space, certain tissue can be made insensitve to B1. The insensitivity can be used to greatly enhance the uniformity, but will always result in lower efficiencies.\n\nCombing these 2 is also possible to produce exponentially more dimensions that can be optimized for and this is what is commonly refered as 'RF pulse design'. Many different types of pulses have been created. Personally, I have implemented an Kt-point pulse. Such a Kt-point pulse splits up a rectangular non-selective pulse and performs both RF shimming and offcentre K-space excitation optimisation for each subpulse: \n![](https:\/\/i.ibb.co\/Xsmr8Cy\/Screenshot-from-2020-06-05-13-44-45.png)\n\nThe performance of these types of tailored pulses is great, but they require the collection of prescans per subject and then the intensive computations on those prescans. This can easily take up 15min+ and can sometimes be a complex process, which reduces the usability of such pulses. The up and comming solution to this problem is making such pulses 'Universal', by calculating one pulse which is not exactly perfect for a induvidual, but almost perfect for everyone. The usability of such a pulse is as high as regular unshimmed pulses, while still performing great:\n![](https:\/\/i.ibb.co\/RQhQFvw\/Screenshot-from-2020-06-05-13-52-30.png)\n","188fdb89":"As a very simple quantifiable measure, we will compute the compute the coefficient of variation (CV). As expected from the improved images above, the CV is lower for CP mode."}}