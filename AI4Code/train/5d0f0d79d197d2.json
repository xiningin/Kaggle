{"cell_type":{"f44e6e74":"code","dcc67458":"code","db9c12d4":"code","a40fb9cc":"code","0acc511f":"code","0b8e3b67":"code","21f93e7e":"code","dddc4aec":"code","2b02b933":"code","f9434d8a":"code","37a14b88":"code","7a8472fd":"code","8421246e":"code","c5745a61":"code","43024d39":"code","57b9183f":"code","5615d8ff":"code","a19023f9":"code","1096f0f3":"code","ce4f02b5":"code","af18ba47":"code","b7002407":"code","e3a20d44":"code","917ccfee":"code","d402a525":"code","51407b77":"code","a633ed81":"code","a8d2b0dd":"code","d6017afc":"code","3a745b9d":"code","77a446be":"code","6bd32d82":"code","cacaca43":"code","33ef60fa":"code","e855bc9d":"code","09e6db46":"code","90d5ea1e":"code","ef4d0c88":"code","5da8978d":"code","b579531d":"code","28030767":"code","e4d8ff40":"code","5907b67a":"code","a4b5bd28":"code","60731d8e":"code","edd1e3de":"code","a320bb2a":"code","cd44f91e":"code","cdc3746f":"code","42ccec0b":"code","f1f64357":"code","08c95ce0":"code","c9247565":"code","cc434138":"code","364763ab":"code","59187a5d":"code","9b691977":"code","07f5145d":"code","d800f709":"code","d8f29534":"code","e61c7a74":"code","711b6167":"code","aafb162e":"code","009022c6":"code","37b5a783":"markdown","86eec5e9":"markdown","8ba55512":"markdown","c01d509c":"markdown","30a59d9e":"markdown","1843ec11":"markdown","924e8cf1":"markdown","6e52ce62":"markdown","3e8f1f5d":"markdown","65227be4":"markdown","fc869a01":"markdown","e8821822":"markdown","7450914d":"markdown","ac4d6ffc":"markdown"},"source":{"f44e6e74":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns","dcc67458":"app = pd.read_csv(\"..\/input\/credit-card-approval-prediction\/application_record.csv\")\ncrecord = pd.read_csv(\"..\/input\/credit-card-approval-prediction\/credit_record.csv\")","db9c12d4":"app.info()","a40fb9cc":"crecord.info()","0acc511f":"app['ID'].nunique() # the total rows are 438,557. This means it has duplicates","0b8e3b67":"crecord['ID'].nunique() \n# this has around 43,000 unique rows as there are repeating entries for different monthly values and status.","21f93e7e":"len(set(crecord['ID']).intersection(set(app['ID']))) # checking to see how many records match in two datasets","dddc4aec":"sns.heatmap(app.isnull()) # checking for null values. Seems like occupation_type has many","2b02b933":"sns.heatmap(crecord.isnull()) # checking for null values. All good here!","f9434d8a":"app = app.drop_duplicates('ID', keep='last') \n# we identified that there are some duplicates in this dataset\n# we will be deleting those duplicates and will keep the last entry of the ID if its repeated.","37a14b88":"app.drop('OCCUPATION_TYPE', axis=1, inplace=True) \n#we identified earlier that occupation_type has many missing values\n# we will drop this column","7a8472fd":"ot = pd.DataFrame(app.dtypes =='object').reset_index()\nobject_type = ot[ot[0] == True]['index']\nobject_type\n#we are filtering the columns that have non numeric values to see if they are useful","8421246e":"num_type = pd.DataFrame(app.dtypes != 'object').reset_index().rename(columns =  {0:'yes\/no'})\nnum_type = num_type[num_type['yes\/no'] ==True]['index']\n#HAVE CREATED SEPARATE LIST FOR NUMERIC TYPE INCASE IT WILL BE NEEDED IN FURTHER ANALYSIS\n# IT IS NEEDED IN FURTHER ANALYSIS","c5745a61":"a = app[object_type]['CODE_GENDER'].value_counts()\nb = app[object_type]['FLAG_OWN_CAR'].value_counts()\nc = app[object_type]['FLAG_OWN_REALTY'].value_counts()\nd = app[object_type]['NAME_INCOME_TYPE'].value_counts()\ne = app[object_type]['NAME_EDUCATION_TYPE'].value_counts()\nf = app[object_type]['NAME_FAMILY_STATUS'].value_counts()\ng = app[object_type]['NAME_HOUSING_TYPE'].value_counts()\n\nprint( a,\"\\n\",b,'\\n', c, '\\n', d, '\\n', e, '\\n', f, '\\n', g)\n\n#this is just to see what each column is. \n#It seems that all of them are important since there is very fine classifcation in each column.\n# their effectiveness cannot be judged at this moment so we convert all of them to numeric values.","43024d39":"app.head(10)","57b9183f":"from sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\nfor x in app:\n    if app[x].dtypes=='object':\n        app[x] = le.fit_transform(app[x])\n# we have transformed all the non numeric data columns into data columns\n# this method applies 0,1.. classification to different value types.","5615d8ff":"app.head(10)","a19023f9":"app[num_type].head()\n# We will look at numeric columns and see if there is anything that needs to be changed. ","1096f0f3":"fig, ax= plt.subplots(nrows= 3, ncols = 3, figsize= (14,6))\n\nsns.scatterplot(x='ID', y='CNT_CHILDREN', data=app, ax=ax[0][0], color= 'orange')\nsns.scatterplot(x='ID', y='AMT_INCOME_TOTAL', data=app, ax=ax[0][1], color='orange')\nsns.scatterplot(x='ID', y='CNT_FAM_MEMBERS', data=app, ax=ax[0][2], color= 'orange')\n\nsns.scatterplot(x='ID', y='DAYS_EMPLOYED', data=app, ax=ax[1][0])\nsns.scatterplot(x='ID', y='FLAG_MOBIL', data=app, ax=ax[1][1])\nsns.scatterplot(x='ID', y='FLAG_WORK_PHONE', data=app, ax=ax[1][2])\nsns.scatterplot(x='ID', y='FLAG_PHONE', data=app, ax=ax[2][0])\nsns.scatterplot(x='ID', y='FLAG_EMAIL', data=app, ax=ax[2][1])\nsns.scatterplot(x='ID', y='DAYS_BIRTH', data=app, ax=ax[2][2])","ce4f02b5":"# FOR CNT_CHILDREN COLUMN\nq_hi = app['CNT_CHILDREN'].quantile(0.999)\nq_low = app['CNT_CHILDREN'].quantile(0.001)\napp = app[(app['CNT_CHILDREN']>q_low) & (app['CNT_CHILDREN']<q_hi)]","af18ba47":"# FOR AMT_INCOME_TOTAL COLUMN\nq_hi = app['AMT_INCOME_TOTAL'].quantile(0.999)\nq_low = app['AMT_INCOME_TOTAL'].quantile(0.001)\napp= app[(app['AMT_INCOME_TOTAL']>q_low) & (app['AMT_INCOME_TOTAL']<q_hi)]","b7002407":"#FOR CNT_FAM_MEMBERS COLUMN\nq_hi = app['CNT_FAM_MEMBERS'].quantile(0.999)\nq_low = app['CNT_FAM_MEMBERS'].quantile(0.001)\napp= app[(app['CNT_FAM_MEMBERS']>q_low) & (app['CNT_FAM_MEMBERS']<q_hi)]","e3a20d44":"fig, ax= plt.subplots(nrows= 3, ncols = 3, figsize= (14,6))\n\nsns.scatterplot(x='ID', y='CNT_CHILDREN', data=app, ax=ax[0][0], color= 'orange')\nsns.scatterplot(x='ID', y='AMT_INCOME_TOTAL', data=app, ax=ax[0][1], color='orange')\nsns.scatterplot(x='ID', y='CNT_FAM_MEMBERS', data=app, ax=ax[0][2], color= 'orange')\n\nsns.scatterplot(x='ID', y='DAYS_EMPLOYED', data=app, ax=ax[1][0])\nsns.scatterplot(x='ID', y='FLAG_MOBIL', data=app, ax=ax[1][1])\nsns.scatterplot(x='ID', y='FLAG_WORK_PHONE', data=app, ax=ax[1][2])\nsns.scatterplot(x='ID', y='FLAG_PHONE', data=app, ax=ax[2][0])\nsns.scatterplot(x='ID', y='FLAG_EMAIL', data=app, ax=ax[2][1])\nsns.scatterplot(x='ID', y='DAYS_BIRTH', data=app, ax=ax[2][2])","917ccfee":"crecord['Months from today'] = crecord['MONTHS_BALANCE']*-1\ncrecord = crecord.sort_values(['ID','Months from today'], ascending=True)\ncrecord.head(10)\n# we calculated months from today column to see how much old is the month\n# we also sort the data according to ID and Months from today columns. ","d402a525":"crecord['STATUS'].value_counts() \n# performed a value count on status to see how many values exist of each type","51407b77":"crecord['STATUS'].replace({'C': 0, 'X' : 0}, inplace=True)\ncrecord['STATUS'] = crecord['STATUS'].astype('int')\ncrecord['STATUS'] = crecord['STATUS'].apply(lambda x:1 if x >= 2 else 0)\n# replace the value C and X with 0 as it is the same type\n# 1,2,3,4,5 are classified as 1 because they are the same type\n# these will be our labels\/prediction results for our model","a633ed81":"crecord['STATUS'].value_counts(normalize=True) \n# there is a problem here\n# the data is oversampled for the labels\n# 0 are 99%\n# 1 are only 1% in the whole dataset\n# we will need to address the oversampling issue in order to make sense of our analysis\n# this will be done after when we combine both the datasets\n# so first we will join the datasets","a8d2b0dd":"crecordgb = crecord.groupby('ID').agg(max).reset_index()\ncrecordgb.head() \n#we are grouping the data in crecord by ID so that we can join it with app","d6017afc":"df = app.join(crecordgb.set_index('ID'), on='ID', how='inner')\ndf.drop(['Months from today', 'MONTHS_BALANCE'], axis=1, inplace=True)\ndf.head()\n# no that this is joined, we will solve over sampling issue","3a745b9d":"df.info() # checking for number of rows. \n# there are 9516 rows.","77a446be":"X = df.iloc[:,1:-1] # X value contains all the variables except labels\ny = df.iloc[:,-1] # these are the labels","6bd32d82":"y","cacaca43":"X","33ef60fa":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.3)\n# we create the test train split first","e855bc9d":"from sklearn.preprocessing import StandardScaler\nss = StandardScaler()\nX_scaled = pd.DataFrame(ss.fit_transform(X_train), columns=X_train.columns)\nX_test_scaled = pd.DataFrame(ss.transform(X_test), columns=X_test.columns)\n# we have now fit and transform the data into a scaler for accurate reading and results.","09e6db46":"from imblearn.over_sampling import SMOTE\noversample = SMOTE()\nX_balanced, y_balanced = oversample.fit_resample(X_scaled, y_train)\nX_test_balanced, y_test_balanced = oversample.fit_resample(X_test_scaled, y_test)\n# we have addressed the issue of oversampling here","90d5ea1e":"y_train.value_counts()","ef4d0c88":"y_balanced.value_counts()","5da8978d":"y_test.value_counts()","b579531d":"y_test_balanced.value_counts()","28030767":"\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom xgboost import XGBClassifier\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.model_selection import validation_curve\nfrom scipy.stats import randint\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom sklearn.metrics import classification_report, confusion_matrix\n# !pip install pydotplus\n# import pydotplus\nfrom IPython.display import Image\nfrom sklearn.model_selection import learning_curve \nfrom sklearn.metrics import make_scorer\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import GridSearchCV\n\n","e4d8ff40":"# %%time\n# knn1 = KNeighborsClassifier(n_neighbors=2)\n# model = knn1.fit(X_balanced, y_balanced)\n# prediction = knn1.predict(X_test_balanced)","5907b67a":"\n# print(classification_report(y_test_balanced, prediction))","a4b5bd28":"# %%time\n# knn2 = KNeighborsClassifier(n_neighbors=4000)\n# model = knn2.fit(X_balanced, y_balanced)\n# prediction = knn2.predict(X_test_balanced)","60731d8e":"\n# print(classification_report(y_test_balanced, prediction))","edd1e3de":"%%time\n\n\nparam_dist = {\"n_neighbors\": randint(1, 50),\n              \"p\": randint(1, 5)}\nknn = KNeighborsClassifier(n_jobs=-1)\nknn_cv = RandomizedSearchCV(knn, param_dist, cv=3)\nknn_cv.fit(X_balanced,y_balanced)\nprint(\"Tuned Decision Tree Parameters: {}\".format(knn_cv.best_params_))\nprint(\"Best score is {}\".format(knn_cv.best_score_))","a320bb2a":"%%time\nprediction = knn_cv.predict(X_test_balanced)","cd44f91e":"%%time\n\nprint(confusion_matrix(y_test_balanced, prediction))\nprint(classification_report(y_test_balanced, prediction))","cdc3746f":"def plot_learning_curve(estimator):\n    sizes, training_scores, testing_scores , fit_times, _= learning_curve(estimator, X_balanced, y_balanced, cv=3, scoring='accuracy', n_jobs=-1, train_sizes=np.linspace(0.01, 1.0, 100), return_times=True) \n    # Mean and Standard Deviation of training scores \n    mean_training = np.mean(training_scores, axis=1) \n    Standard_Deviation_training = np.std(training_scores, axis=1) \n\n    # Mean and Standard Deviation of testing scores \n    mean_testing = np.mean(testing_scores, axis=1) \n    Standard_Deviation_testing = np.std(testing_scores, axis=1) \n    \n    fit_times_mean = np.mean(fit_times, axis=1)\n    fit_times_std = np.std(fit_times, axis=1)\n    \n    _, axes = plt.subplots(1, 2, figsize=(20, 5))\n\n    # dotted blue line is for training scores and green line is for cross-validation score \n    axes[0].plot(sizes, mean_training, '--', color=\"b\",  label=\"Training score\") \n    axes[0].plot(sizes, mean_testing, color=\"g\", label=\"Cross-validation score\") \n\n    # Drawing plot \n#     plt.title(\"LEARNING CURVE FOR MLP Classifier\") \n    axes[0].set_title(\"LEARNING CURVE FOR KNN Classifier\")\n    axes[0].set_xlabel(\"Training Set Size\"), axes[0].set_ylabel(\"Accuracy Score\"), axes[0].legend(loc=\"best\") \n    \n    axes[1].grid()\n#     axes[1].plot(fit_times_mean, mean_testing, 'o-')\n#     axes[1].set_xlabel(\"fit_times\")\n#     axes[1].set_ylabel(\"Score\")\n\n    axes[1].plot(sizes, fit_times_mean, 'o-')\n    axes[1].set_xlabel(\"Training Set Size\")\n    axes[1].set_ylabel(\"fit_times\")\n    axes[1].set_title(\"Performance of the model\")\n    \n    \n    return plt","42ccec0b":"%%time\nplot_learning_curve(knn_cv.best_estimator_)","f1f64357":"def plot_validation_curve(param, param_range,estimator):\n#     param_range = np.arange(1, 41, 2)\n    train_scores, test_scores = validation_curve(estimator, X_balanced, y_balanced, param_name=param, cv=10, param_range=param_range,n_jobs=-1, scoring=\"accuracy\")\n\n    train_scores_mean = np.mean(train_scores, axis=1)\n    train_scores_std = np.std(train_scores, axis=1)\n    test_scores_mean = np.mean(test_scores, axis=1)\n    test_scores_std = np.std(test_scores, axis=1)\n    plt.title(\"Validation Curve with KNN\")\n    plt.xlabel(param)\n    plt.ylabel(\"Score\")\n    plt.ylim(0.0, 1.1)\n    plt.plot(param_range, train_scores_mean, label=\"Training score\",\n                 color=\"r\")\n    plt.plot(param_range, test_scores_mean, label=\"Cross-validation score\",\n                 color=\"g\")\n\n    plt.legend(loc=\"best\")\n    param_range = np.arange(1, param_range.max(), 2)\n#     plt.xticks(param_range)\n    plt.show()","08c95ce0":"%%time\nparam_range = np.arange(1, 10, 1)\nparam_name=\"n_neighbors\"\nplot_validation_curve(param_name,param_range,knn_cv.best_estimator_)","c9247565":"%%time\nknn_cv.best_params_['n_neighbors'] = 1\nknn_iter1=KNeighborsClassifier(n_jobs=-1)\nknn_iter1.set_params(**knn_cv.best_params_)\nmodel = knn_iter1.fit(X_balanced, y_balanced)\nprediction = knn_iter1.predict(X_test_balanced)\nprint(confusion_matrix(y_test_balanced, prediction))\nprint(classification_report(y_test_balanced, prediction))","cc434138":"%%time\nknn_cv.best_params_['n_neighbors'] = 10\nknn_iter1=KNeighborsClassifier(n_jobs=-1)\nknn_iter1.set_params(**knn_cv.best_params_)\nmodel = knn_iter1.fit(X_balanced, y_balanced)\nprediction = knn_iter1.predict(X_test_balanced)\nprint(confusion_matrix(y_test_balanced, prediction))\nprint(classification_report(y_test_balanced, prediction))","364763ab":"%%time\nknn_cv.best_params_['n_neighbors'] = 5\nknn_iter1=KNeighborsClassifier(n_jobs=-1)\nknn_iter1.set_params(**knn_cv.best_params_)\nmodel = knn_iter1.fit(X_balanced, y_balanced)\nprediction = knn_iter1.predict(X_test_balanced)\nprint(confusion_matrix(y_test_balanced, prediction))\nprint(classification_report(y_test_balanced, prediction))","59187a5d":"%%time\nplot_learning_curve(knn_iter1)","9b691977":"%%time\nparam_range = np.arange(0, 6, 1)\nparam_name=\"p\"\nplot_validation_curve(param_name,param_range,knn_cv.best_estimator_)","07f5145d":"%%time\nknn_cv.best_params_['p'] = 3\nknn_iter2=KNeighborsClassifier(n_jobs=-1)\nknn_iter2.set_params(**knn_cv.best_params_)\nmodel = knn_iter2.fit(X_balanced, y_balanced)\nprediction = knn_iter2.predict(X_test_balanced)\nprint(confusion_matrix(y_test_balanced, prediction))\nprint(classification_report(y_test_balanced, prediction))","d800f709":"%%time\nknn_cv.best_params_['p'] = 5\nknn_iter2=KNeighborsClassifier(n_jobs=-1)\nknn_iter2.set_params(**knn_cv.best_params_)\nmodel = knn_iter2.fit(X_balanced, y_balanced)\nprediction = knn_iter2.predict(X_test_balanced)\nprint(confusion_matrix(y_test_balanced, prediction))\nprint(classification_report(y_test_balanced, prediction))","d8f29534":"%%time\nknn_cv.best_params_['p'] = 1.1\nknn_iter2=KNeighborsClassifier(n_jobs=-1)\nknn_iter2.set_params(**knn_cv.best_params_)\n","e61c7a74":"%%time\nmodel = knn_iter2.fit(X_balanced, y_balanced)\n","711b6167":"%%time\nprediction = knn_iter2.predict(X_test_balanced)","aafb162e":"\nprint(confusion_matrix(y_test_balanced, prediction))\nprint(classification_report(y_test_balanced, prediction))","009022c6":"%%time\nplot_learning_curve(knn_iter2)","37b5a783":"* Using different methods to understand data\n* data is complex and both dataset need some kind of transformation before analysis\n* datasets are indivudally dealt with and then eventually compiled using joins","86eec5e9":"# Credit Card Prediction Analysis!","8ba55512":"# Importing Libraries","c01d509c":"<img src=\"data:image\/jpeg;base64,\/9j\/4AAQSkZJRgABAQAAAQABAAD\/2wCEAAkGBxAQEA8PEBAPDw8QDw8QDw4PDw8PEA8QFhEWFhURFRUYHiggGBolHRUVITEhJSkrLi4uFx8zODMsOSgtLisBCgoKDg0OFxAQGi0lHx0tLS0tLy0tLS0tLS0rLS8tLS0tLS0uLS0tLS0rLS0tLS8tLS0tLS0tLS0tKy0tLS0tLf\/AABEIALIBGwMBIgACEQEDEQH\/xAAcAAADAAIDAQAAAAAAAAAAAAAAAQIDBgQFBwj\/xABFEAACAgIABAQEBAALBAoDAAABAgADBBEFEiExBhNBURQiYXEHMoGRFSMzUlNygpKTsdEkQoOhVFVjc3Sis8HS4RclNP\/EABkBAQEBAQEBAAAAAAAAAAAAAAECAAMEBf\/EAC0RAQEAAgAEBQIEBwAAAAAAAAABAhEDEiExBBMUUfAiQWFxodEyM4GRscHx\/9oADAMBAAIRAxEAPwDJ+Jf4gXvfZh4djU00s1dttZK2XWA6YBh1VQdjp36+k81scsSWJYnuWJJP3JhY5YlidliWJ9yTsmTPNbt9jDCYTUEIQgsQhLppZzyorOx7Kilm\/YTMiMTnrwiwfyr4+P8A9\/fWGP8AYTmf\/wAsyrg4i\/ymdzH1XGxL7f2a01iOhzR1wtI9TLGQ30P6TslXhg7vxN\/6tOFVv97GmRTwj1HFx9jgH\/SbR57+LrBle4\/aZFyF+o+4nc0YPBbOgzs\/FJ9cnEqtUfc0tOfkfhzktV8Rg343EqevWh+W3p3HIem\/pzb+kORvUa7\/AKtbVwexBlCdcykEggggkEEEEEHRBHoZaOR2Jk6d5xHPlCcRMg+ujMyXg9wR\/wA5NjpM4zShJRgexlgQdYYlARAShBcgEoRCUILglRRiCoYjEI4KghHCCk8oiKy4opsYTJMzmY2T2jK53FjMkmUwmMmU5V2\/A\/EuVhurU2tyg\/NS7FqnHsV9PuOs9y4Lx6nJx6shWCCxdlGYbVgSGU\/YgifOpMz08QtRQq2MqjegCQBs7nXDO4vD4nwuPF1Z0rX4GE9B8C8Lox+H5fG76kvektXh1WdaxYCF5yPU87AfQA6lSbcs8+WbaH8LZy8\/lW8mt8\/lvya9+bWpinfUeLOJm8WrmXta7coQuTSS\/wAoTyfyAde2uk2fiP4eYteSuCmfZZnWVo1VBq3okku9rgaVAoLa2GbX1G3W+ybxOX+J51Mi2NrkDNyt0KAnTb9x6ze8v8PVFef5T5nm4QXkbIpSunNbR5lpGge40Ds7JEzYXgrFx+IcPwr8i9852qyLEqrrONWqsbPKYk8xJFbDY+h11m5aPOxabkeHsyprEfFuRqahdaOTfl1EkCxtbAHyt3\/mn2nWz1fxpztXxbiBy8iqizMr4f8ADUCsjIqr5K36t67a\/oCN60ZyuKeF8B8zhPCVR1NNBycgKtai+vWibXX5jYWrA6ejN9I8qJx+m786PMOG+H8zJUvRjW2VjvZoV1f33IU\/vDinAMzFCtkY9lSP+WwhWrY+wdCV39Nzv\/xS4wb82zFX5cTDIoqoXS1hlA525R03vp9AvTuZtHgPFazw\/nV3darbbK8VW1oMQiIF\/wCN2+u5pJvSrxMpjMr93lePQ9jBK0exz2RFLsf0E9A8H8Vq4HXk2X2C3MvVVXh9LiwVcu9Pe67VW69gSQB+g7bK4Bw2riePwkHNfz6ibFqvWmpDyO4LhAC5ITt6DXfc64fh3VWOIZB82+ii56cPGSyupshgQp57T0CqxK9NH5CfpNMbOycuJjnNZdr+rRmS\/MuvuVDZY7vdbyAALzMWPf06npOGBN18T8OXh1WJfiWNRZl0lcrENteT5LhQSAxBOtsR19ppYkV6OHeabnYwJYEQlgSXaQwJlRyJAliDpOjMt3uP2mZWBnFAlCTp1xzrlCVMCOZlVx9pLtjlKuMRCUBJdJBHDUeplQQhCBKIxxRSRiMckxTSMxPX7ftMskxRlNuMTJ3OS67mA1GVK4ZY2Oom0eHPFooxMjh2TScjCv2xVHFV1TkglkYjR6gHR9R9dTV4TtLp4MsZlNVsGDxDh2PbTbXj5txrvqt3k3ULoI4bSrWuiSQBtiRrfTc5qeN3XjD8WWrYc6OOzdfK8la+UMB0Pyg71NShNup8uXu2ji+VSllefRjZaF8qrKU5ORU9Stz+eEVUXem1scx\/L2HrO9X8QMMcR\/hP4LIbIakVlWyKyiHQXdYC72R06n7Abmm8U4w16V18gRa+XXzcx6U11ADoNLqsHXXqT19JwsTI8tucAFgDyE6IR\/R9HoSO4366PpHmT5Us6tq4z4rLY+JhNjtW+Jmtk5Qdh\/H3eazupGvl+Zm7\/SZeL+MXt4gOMYlVyNStVdq3FLKgGBVa\/kGwG0\/c9+2pqnEcw32tcwCs4TmA7FlRVLfTZUnX1nI4Txd8bXKqOpfmtR9lb05dCtwPQbYjXXZB9Jtt5ck7fL3d5x3i3DMnJsyLsXiFN7OfiKKb8byWtXo3zMvMuyOupzD4yuL4L\/C+TwvDdbKcOltK\/IWRC9rfmYPv+63QkbmjsxJJJ2xJJJ7knuZ2GVxQ2Y9OOa1C0fybgnmG+Y2b9+ZmB+mvqZuY+VOkbJgeNkTi9\/FbKHs8xStdIsUGvaIgJYjR+VWH9qOrxlVdhX4GdRbZVbk25KW49iJajPcbiCHBU\/MzdfY9vWaYBKAhzVXk4\/PwcjL8kv8A7PW9VYAAFjiyxj6szAAb+gAHSYwIgJYEmu8gAmQCICWBJXIAJQgBKAguQwJQgJQEFwCUIARgQXIpTqZFaYxKEK6Y2xljmNWlgya6y7OKOKBIxQJiikGKERMU0jEYbiMU0jFAmTFO3SQhCdnzBCEumpnZUUbZ3VEX3ZmCqP3Ii29IhN6p\/DS4gc2VSra6qKncA+wbmG\/2ED+HOmKNxHHRl1tWpZT1GweryuSuPqOH7tFjm9t+G4AJ\/hPGOgTyrSSzaHYDzOp+k5v\/AOIrv+nVfb4Z\/wD5zclb1HD9\/wDLzgShNk8WeDbeHLW73V3LY5rBRWQhgvN1BJ6aB9fSa4BJs07YZTKbhiWBEBLAkukAEsCAEsCC5ABKEAJQEFyGBKAiAlAQq5DAlCAEYElchgShEBGJlyGI4AQgoQBhJgWZW3AzCDMgO5tKmWzMmOTMwJiMIjFNIxEwMkxRQTJ3AxRS6aEITq+cJzuA\/wD9eH6\/7Xi9B1J\/j0nBnYeHiBmYRPYZmIT9hekZ3Tn\/AA17fZZ\/2d3+E0xcOyz5l50y\/NX+YFT\/ACYna25lX84fs3+k6mplezIKnY5qx6jr5YnofHdsudobJ0B1J9hITigIBCXEEbB8tu06fLcqj\/1G\/wAjIxOLV8ifOPyr6H2ExdF+LORz42N8rjWUfzqV3\/Ev2nmYE9C\/EnLWzGo5W3rJ69\/6J558BOGfd9Xwv8uGBLAiAlgTnXqkMCWBEBKAg6SGBKEAJQEFSACUBEBKAguQwJQiEoQXIBKEWo4KEIopiZMRiiMw2DGjdfvJMkmYbciIxKdiEHTZbiMDJMU0EySYzJiikYtwMmKLXUwhCdXgE5vA7QmXiOx0qZeKzH2UXISf0AnChEWbmn002\/Y\/pvrOouW1bLSKXdW5CGDIOyAEaJE8ETMuAAF1wA6AC2wAD2ABljOu\/pr\/APGs\/wBZ08x4\/R33e0Zy3FXAx7NlWA+arvr7ziGp1VflbYVQeh76nkgzbv6a7\/Fs\/wBZQzLv6a7\/ABbP9YeYr0d925ePXPw9Ct0Y3lgp6EqK2BOvbbAfrNKAjZyx2xZj7sSx\/cxgTnld3b2cHh8mPKYEsCICUBIeiGBKAiEsQXABKAgBKAguACUBEJUFQCUBCOC4IoRTEREx7kkzAExEwJkkzJBMkwJkkxTaz1HpKMx1dv1lGDpOwMmBkmItBkmMyTFFoiihFO3VQhCdHhECQO5A+51GBNp8CPytnuLhjleH2EZBVn8o+fT82gCT7dB6xgyuptq6EHsQfsdy5sPibiVd1WMnn\/GZFbXG3M8g0brbl5KeoDNohjsj\/e0Jh8LAbzt\/9U8R7+\/k95jL03XTgShEhB7aP26zYvBmLu57yalXEqa4Nc6V1eefkoVmboNuQf7Bk9128s26FZRYDuQPudTvvGGEEvW5TWa8usZANTrZWLD0uRWXoQLA3b0InJ8A59yZuPStjLVbaTZX05X\/AItu+\/sP2m110ef6OaNbUg9iD9pYmfMz7shhZdY1rhQvM2t6766fczs+Hr\/+vzz6+dg9f7VsNOm9SWunlCcrgw\/2nE\/8Vjf+sk23LxktbiOZSoVRjcQpyqh2qvX8tqj+Y6jf0YMISbOXE5brTSgI9xMOh+xm6Kg\/hvHGhotisB00V+GUk\/boTCTa8s+X+1v9mnCUDIp\/Kv8AVH+U3e7A+KxOH0qAHqrpdmHf4e26yuxj\/VKVn9YSbVxOJMNb+7SwY53\/AI0vSy6iytQlb4WOyKBrSbflH7amvwymrpfDz5sZl7nJhEYKBiMDETEbImImBMkmZOwTIJjJjrGz9ojuzr0AERgTJJg6gySYzJMyKRiMDFFFEUIRDq4QjAnR4jE5GNkvWLAjFRbWa7ANfPWWBKn9VB\/SYQJQEx0YE5nDc+7HfzaLDXZysnMArbVvzLpgRo69pxAJYEFacziHErshla6zzGUcqnkrTQ3vWlAEivIcVvUGIrdkd0AHzMgYKSe\/Tmbp9ZhAlgQ2uYzszNku1aVFia62dq0IGkL659evXlHT6SsPJep1trYpYh2jjW1OiN9fuZhEoCG1yGBM9eQ4R6wxFdhRnTppim+Un7bP7zEJQEF6VS5RldTpkZWVvVWUgg\/oQJyK861fOK2MPiFZb9drVY7YMPv\/AJzjgRiG1csvcxOyTjmUKxSL3FYTywPl5hX\/ADA+uYL6a3qddHNvSrjL3hicuviV665bWXVLY41ofxLEk1\/bZM4kUNqsl7st+Q78nOxbkRa03r5UX8qj6DZmGERmbpDkwMRmBGIwMkxGwZJhuSTMnZzOi6EmpNdT3lkwrpjjrqRMkwJiJmakYoExRRQYoGSzAdTFNMmcdsrr0Gx77mK64t9B7TFKkccuJ7FqUBEJYEpxAEsCICWBBUhgSwIgJYEFyACWBEBLAguQCUIAShBcgEoQAlCCoBKEUcFwxHCEyhuTCLcwOSTAmImYbImImBkkxGwZO4ExTJImZaq\/U\/oI66\/U\/tLMLV44\/egyTGZJMyqURgTFuKaRMUCZxrcn0X9\/9IyOeWUndlttC\/f2nDssLdT\/APQkkwlSaefLO0oQMJSFgSgIgJYE1MMCWBEBLkrkAEsCLp7iVse8FSGBKAiBHuP3lAj3Ey5DAlARAygRBchgRgRAj6ShBWjjijgoRQ2ItzMDFDcksPpMDJkmLmiLD3ikGSYFh7ylXf0H+cw1tAG+0zJXr7ygAO0CYbdJjoGIwMUC7HhXD6LiFsza8Vie1tNjJ37+YDofrqd14m8B34OP8UbqrqwyK3IrIVDkKrdSdjZA\/WakZ7FRcc3w5YfzWJh2rr1NmPvl\/U8in9Z1wkyln3eLxPEz4WWOUvS3V7POvCXhW3iT2rXYtS1KrM7ozDbEgKACOvysf0nO4d4EsyMvLw68qothirzbfKfkL2c3yAc3ccpm6+EwvCuCPmWLqx62ymU9CzMoFNf3I5B92MwfgxURhZWZadvk5Vtj2H\/eCD5m\/vGydMeHOm3k4vi8\/ruN6TpPzec0+DcrIz8jAoZLTjMBdfpq6U7d+53vYA6k8pm0n8F7uXfx9XNr8vwr8u\/63mf+05X4PeJqHsza7WWvIy8psqsuQPNDj+TB\/nL7evN09Zg8d+Cs\/He\/iGJl5Fy8z22J5ti30qSWPKQdOg9uhAHrGYzW3PPi8TzOW5a\/p3ebYvDbLclcSrT2PeaUI2FYhiOff83QJ+02\/wASfhhkYWLbltk1XCoIWrSp1YguqkglvTe\/0nY\/ghwTzMi7OcfJQpqqJ\/pXHzMPsnT\/AIk3rA4mvF8HidY1rzMzEX6qE\/i2\/UEGOOMs6txePljnqdprb54MIDfqNH1HsfaE5vWzgSwJsHjjw8+DmWoVPk2O1mO+vlZCd8u\/dd6I+3vOgAhehwsyksMCbR4A5RfksxChOH5bh\/LS7kKhSHCN0Yj2M1kCWhI7EjY0dHWx7TS6qssebGx6LhcXxrBm3oWq8nDwa7Mv4PGNj2nJKtcKN8g2GAPXeh26Cdh5GreJNXTYSKeFmq3ExsW6zJBNnNkpWw5AGHQ+3L7zyxSeo2dHuN9\/vMqWuOzMNDXRiOntHnc\/Te1+dP2b2mcMfHyrbvianbiKoD8FgnI5fhEIV63IRB038v09zOR\/GfwfhtXVlM1mLaztjYWHbUXNj9bHf5l\/s+k88Lse5J676knrrW5a2sBoMwHsGIH7Q51+nekZvltRdUoFrpwiiwYXw9C9WqXeSlo+dmXuR079Nw475bU51SAXPVhY5GJ8PQnlc1dZOVXYPnfl3sjp+aecBzvezvsDs717RhjvezvWt7O9a1qa8RsfC611+fP6vSPESOL0QVZQp+KwNk4eKuJymyrYFo+c7J9e5JHadd4nps+HzmyqkrKZwXAY011O1fmNzqvKAWTkCnZ3NLNznoXY\/dj6doncnqSSfckmFz2vDw1x117N14ZRkfDYQwqaLa7Uv+Na2ut62tDMCt7HqqhNa6iZeEcIqOEMRmxRk5tVuRWrsRer7HwqoNfkPl2E9f8Ae9ZogcgEAkBvzAHo33HrA2HYOzsa0dnY121NzfgbwL9r99\/9ei4ZQ000cvmWfwMlvwDY9AF7kOCwtPz+YNbK69BrfWY7KHKIttSfwd\/A1VjWtTWAuR5G1dbNc3Pza6A+s898w7B2djsdnYkvYSACSQOwJJAjzo9N17t18FYVeRhZOM4QPlZK0V2EDdbjHe1SD3A3V\/zmw5HltZkWUVPoYGMahjY9F12vjLVDIj\/KSVA3v037TygOR2JHXfQkdff7wW1h2Zh010JHT2+00z1NDPw1yyt33+f6ej8LwRk152NejpZlZVVNVmTRVRdWVxPNUla\/lXrUe3fY9zOZlitrcl6KnA\/g7CNQxcei60D4y5eZEs+UkqBvfpv6Ty8Fu5Zt73+Y99a3uWtjDszDproSOntN5k9j6PK3e\/nT9npjYoSziDpTYHajhbhMfFxrMlWY2B+apvkVzrba9NTicNsVUc3vZitbxRKvMuw8U2cpxUIS1D8tanp1XfcH1M89FrDZDMCe5DEE\/f3ku5Pck7Ozsk7Otbh5n4KnhOmt+32c\/wASLy5eSPJ+H1c+qBrVY30A10169OnWdaTG7knZJJ9ydzBZeB9ftI716p9OMl+zKZisuA\/0E41l5P0HsJhJjMXLLi+zLZkE9ug+neer\/gbnh6c3DbryutwU9ili8jD7bQf3p5CZVdrL1VmQnoSrFSR+k6YXlu3k4+F4uNxteq\/jjxoKMfh6HQAGRcB2Cja1L+4Y\/wBkTu7gcDwzr8thwde2rsjv+u7P+U8NsdmO2ZmPuxLH9zLsyLGHK1ljL0+VnYr07dCZXP1tcfT\/AE4477Xf5vQuDfhUcvDxclMoVPfUtj12VeYq83VeUqwI6a6Hc37Iy04PwwVZWScu5a3rq5+tuRY2+WpVJJIGwOpOgOs8Aoy7a+ldttQPUiu16wT7nlImOy1mbnZmZ\/57MzP\/AHj1mmUnaDLgZZ36sun5PoDhfw\/AuEY65IOlVBcEHOz329XUA63rZH2WPwH4h4Xe9uPw6j4YhRbYgoroVxsLzfKep7TwC3IdujO7jvpnZhv36mTXaynasynttWKnXt0j5iL4Tcu71rs\/FuD8Pn5tPomTbyj2Vm51H91hOpmQB7HAHPZY5AA+Z3duwA9SfSe4eGfw4oTEoGUu8jlLW60dMzFuXfroED9ITG3s658WcKTmbb4pxa7MS8WVpYAhYB0VwGHYgH1nzbYPmP3P+ccI8Vy8D2pCUIQnF9GLjEITLillCEILihHCEFQ4QhMQYjCEzJMRhCYJMzV9oQhTh3VJMIQdCMmEJk1xco9dempxzCE6R5eJ3QZJhCU5lCEJhRCEJgUUcJmKOEJmet\/ghiVkX2mus2qdLYUUuoPcBu4nrUIT04dnyPE\/zK\/\/2Q==\">\n\n# Context\n\nCredit score cards are a common risk control method in the financial industry. It uses personal information and data submitted by credit card applicants to predict the probability of future defaults and credit card borrowings. The bank is able to decide whether to issue a credit card to the applicant. Credit scores can objectively quantify the magnitude of risk.\n\nGenerally speaking, credit score cards are based on historical data. Once encountering large economic fluctuations. Past models may lose their original predictive power. Logistic model is a common method for credit scoring. Because Logistic is suitable for binary classification tasks and can calculate the coefficients of each feature. In order to facilitate understanding and operation, the score card will multiply the logistic regression coefficient by a certain value (such as 100) and round it.\n \nAt present, with the development of machine learning algorithms. More predictive methods such as Boosting, Random Forest, and Support Vector Machines have been introduced into credit card scoring. However, these methods often do not have good transparency. It may be difficult to provide customers and regulators with a reason for rejection or acceptance.\n \n\n\n# Task\nBuild a machine learning model to predict if an applicant is 'good' or 'bad' client, different from other tasks, the definition of 'good' or 'bad' is not given. You should use some techique, such as vintage analysis to construct you label.\n\n# Following main steps were used:\n* Fill missing values with mode\n* Find correlation between features\n* Oversample data set\n* Use scaling (StandardScaler)\n* Do ramdomizedSearchCV to select initialized parameters\n* Plot learning curves over multiple iterations\n* Plot validation curves over multiple iterations\n\n","30a59d9e":"# Extracting data using two data sources","1843ec11":"* We need to remove these outliers to make sure they do not affect our model results. \n* We will now remove these outliers. ","924e8cf1":"* We notice in the value counts above that label types are now balanced\n* the problem of oversampling is solved now\n* we will now implement different models to see which one performs the best","6e52ce62":"There are outliers in 3 columns.\n1. CNT_CHILDREN\n2. AMT_INCOME_TOTAL\n3. CNT_FAM_MEMBERS","3e8f1f5d":"# iteration 2","65227be4":"df.info() # checking for number of rows. \n# there are 9516 rows.","fc869a01":"# randomized search","e8821822":"source: https:\/\/www.kaggle.com\/umerkk12\/credit-card-predictive-analysis","7450914d":"Source:https:\/\/www.geeksforgeeks.org\/using-learning-curves-ml\/\n# Learning curve: iteration 1","ac4d6ffc":"# Algorithms code start below\n"}}