{"cell_type":{"23d4098a":"code","e6f19f33":"code","14217c79":"code","b7f4b488":"code","b7aa6b48":"code","e396c39d":"code","512e62b0":"code","dd5d26e1":"code","3648c4b3":"code","ee0551c0":"code","83d35fcb":"code","2b5937d0":"code","e4122565":"code","b6f74258":"code","a9ac0b4a":"code","3ceabfa6":"code","073106c1":"code","d6425aae":"code","b48f9e57":"code","c2ca5d86":"code","e6ec5f92":"code","29fb1870":"code","2d288667":"code","0bea1712":"code","593b4879":"code","6b9b0570":"code","736bf457":"code","10c0c147":"code","c92cefa8":"code","82f17702":"markdown","4aa10bf7":"markdown","c97b6ae8":"markdown","2a7c791f":"markdown","f3541bb5":"markdown","bfdbc480":"markdown","21031f50":"markdown","05505ba2":"markdown","9157e545":"markdown","4e5e68b5":"markdown","5c328bfd":"markdown","2c0970e0":"markdown","bed1f547":"markdown","1b4026b4":"markdown","d204a1e5":"markdown","bba32b8a":"markdown","c3627642":"markdown","db1b2386":"markdown","8e6b3174":"markdown","0d37c072":"markdown","43815f24":"markdown","95ee3bd4":"markdown"},"source":{"23d4098a":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\npd.set_option('display.max_columns', None)\nplt.rcParams['figure.figsize'] = (12,6)","e6f19f33":"data = pd.read_csv(\"\/kaggle\/input\/phishing-dataset-for-machine-learning\/Phishing_Legitimate_full.csv\")","14217c79":"float_cols = data.select_dtypes('float64').columns\nfor c in float_cols:\n    data[c] = data[c].astype('float32')\n    \nint_cols = data.select_dtypes('int64').columns\nfor c in int_cols:\n    data[c] = data[c].astype('int32')\n    \ndata.info()","b7f4b488":"data.rename(columns={'CLASS_LABEL': 'labels'}, inplace=True)","b7aa6b48":"data.sample(5)","e396c39d":"data.describe()","512e62b0":"data['labels'].value_counts().plot(kind='bar')","dd5d26e1":"def corr_heatmap(data, idx_s, idx_e):\n    y = data['labels']\n    temp = data.iloc[:, idx_s:idx_e]\n    if 'id' in temp.columns:\n        del temp['id']\n    temp['labels'] = y\n    sns.heatmap(temp.corr(), annot=True, fmt='.2f')\n    plt.show()","3648c4b3":"corr_heatmap(data, 0, 10)","ee0551c0":"corr_heatmap(data, 10, 20)","83d35fcb":"corr_heatmap(data, 20, 30)","2b5937d0":"corr_heatmap(data, 30, 40)","e4122565":"corr_heatmap(data, 40, 50)","b6f74258":"from sklearn.feature_selection import mutual_info_classif","a9ac0b4a":"X = data.drop(['id', 'labels'], axis=1)\ny = data['labels']","3ceabfa6":"discrete_features = X.dtypes == int","073106c1":"mi_scores = mutual_info_classif(X, y, discrete_features=discrete_features)\nmi_scores = pd.Series(mi_scores, name='MI Scores', index=X.columns)\nmi_scores = mi_scores.sort_values(ascending=False)\nmi_scores","d6425aae":"def plot_mi_scores(scores):\n    scores = scores.sort_values(ascending=True)\n    width = np.arange(len(scores))\n    ticks = list(scores.index)\n    plt.barh(width, scores)\n    plt.yticks(width, ticks)\n    plt.title(\"MI Scores\")\n    \nplt.figure(dpi=100, figsize=(12,12))\nplot_mi_scores(mi_scores)","b48f9e57":"from sklearn.linear_model import LogisticRegression\nfrom cuml.ensemble import RandomForestClassifier as cuRfc\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score","c2ca5d86":"def train_logistic(data, top_n):\n    top_n_features = mi_scores.sort_values(ascending=False).head(top_n).index.tolist()\n    X = data[top_n_features]\n    y = data['labels']\n    \n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True)\n    \n    lr = LogisticRegression(max_iter=10000)\n    lr.fit(X_train, y_train)\n    \n    y_pred = lr.predict(X_test)\n    \n    precision = precision_score(y_test, y_pred)\n    recall = recall_score(y_test, y_pred)\n    f1 = f1_score(y_test, y_pred)\n    accuracy = accuracy_score(y_test, y_pred)\n    \n    return precision, recall, f1, accuracy","e6ec5f92":"arr = []\nfor i in range(20,51,1):\n    precision, recall, f1, accuracy = train_logistic(data, i)\n    print(\"Performance for Logistic Model with Top {} features is precision : {}, recall : {}, f1 score : {}, accuracy : {}\".format(i, precision, recall, f1, accuracy))\n    arr.append([i, precision, recall, f1, accuracy])","29fb1870":"df = pd.DataFrame(arr, columns=['num_of_features', 'precision', 'recall', 'f1_score', 'accuracy'])\ndf","2d288667":"sns.lineplot(x='num_of_features', y='precision', data=df, label='Precision Score')\nsns.lineplot(x='num_of_features', y='recall', data=df, label='Recall Score')\nsns.lineplot(x='num_of_features', y='f1_score', data=df, label='F1 Score')\nsns.lineplot(x='num_of_features', y='accuracy', data=df, label='Acc Score')","0bea1712":"def train_rfc(data, top_n):\n    top_n_features = mi_scores.sort_values(ascending=False).head(top_n).index.tolist()\n    X = data[top_n_features]\n    y = data['labels']\n    \n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True)\n    \n    rfc = cuRfc(n_estimators=500, \n                split_criterion=1,  \n                max_depth=32, \n                max_leaves=-1,\n                max_features=1.0,\n                n_bins=128)\n    \n    rfc.fit(X_train, y_train)\n    \n    y_pred = rfc.predict(X_test, predict_model='CPU')\n    \n    precision = precision_score(y_test, y_pred)\n    recall = recall_score(y_test, y_pred)\n    f1 = f1_score(y_test, y_pred)\n    accuracy = accuracy_score(y_test, y_pred)\n    \n    return precision, recall, f1, accuracy","593b4879":"arr = []\nfor i in range(20,51,1):\n    precision, recall, f1, accuracy = train_rfc(data, i)\n    print(\"Performance for RFC Model with Top {} features is precision : {}, recall : {}, f1 score : {}, accuracy : {}\".format(i, precision, recall, f1, accuracy))\n    arr.append([i, precision, recall, f1, accuracy])","6b9b0570":"df = pd.DataFrame(arr, columns=['num_of_features', 'precision', 'recall', 'f1_score', 'accuracy'])\ndf.head()","736bf457":"sns.lineplot(x='num_of_features', y='precision', data=df, label='Precision Score')\nsns.lineplot(x='num_of_features', y='recall', data=df, label='Recall Score')\nsns.lineplot(x='num_of_features', y='f1_score', data=df, label='F1 Score')\nsns.lineplot(x='num_of_features', y='accuracy', data=df, label='Acc Score')","10c0c147":"top_n_features = mi_scores.sort_values(ascending=False).head(32).index.tolist()\nX = data[top_n_features]\ny = data['labels']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True)\n\nrfc = cuRfc(n_estimators=500, \n            split_criterion=1,  \n            max_depth=32, \n            max_leaves=-1,\n            max_features=1.0,\n            n_bins=128)\n\nrfc.fit(X_train, y_train)\n\ny_pred = rfc.predict(X_test, predict_model='CPU')\n\nprecision = precision_score(y_test, y_pred)\nrecall = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\naccuracy = accuracy_score(y_test, y_pred)\n\nprint(\"Performance for RFC Model with Top {} features is precision : {}, recall : {}, f1 score : {}, accuracy : {}\".format(27, precision, recall, f1, accuracy))","c92cefa8":"from sklearn.metrics import classification_report\n\nprint(classification_report(y_test, y_pred))","82f17702":"# Visualize Random Forest Performance\n\nOur goal is to beat logistic regression baseline which is\n\n* accuracy = 0.947162\n* precision = 0.957468\n* recall = 0.952287\n* f1_score = 0.9515\n\nSo by visualizing the figure below, we can conclude that the best number of features for this model would be 32, one less than logistic regression, the reason why I chose 32 is because that is the number of features that allowed the model to perform the best across all the evaluation metric","4aa10bf7":"# Columns 30 to 40\n\nWell here we have a few features that are linearly correlated to our dep variable\n\n* InsecureForms shows that as the value is higher so the probability of being a phising site\n* PctNullSelfRedirectHyperlinks shows the same positive correlation as InsecureForms\n* FequentDomainNameMismatch shows that it has medium linear correlation in positive direction\n* SubmitInfoToEmail seems to indicate that sites that ask users to submit their details to emails seems to be more high probability for phising","c97b6ae8":"# Train logistic models\n\nThis method is to perform a repetative training process using logistic regression model, the purpose for this is to find the optimal number of features that can be used to find the best fitted model without adjusting much of the hyperparameters, hence the idea here is to go with Data-Centric training, basically the method takes number of top N features to be used for training the model and all the evaluation metrics are returned for evaluation purpose","2a7c791f":"# Predicting Phishing Web Page Using Machine Learning\n\nPhishing is a method of trying to gather personal information using deceptive e-mails and websites.\n\nIn this notebook, we will read the data and look at what are the features that can give us information on what are the attributes of a phishing website","f3541bb5":"# Summary Statistics\n\nBy using the describe method, we can see some of the columns have high variance and some have smaller variance, this is due to the fact that some of the column have bigger values and bigger ranges","bfdbc480":"# Visualize Logistic Reg Performance\n\nAs we can see, the model had ups and downs during the training as more number of features were added, as our target is to maximize all the metrics we have to find the number of features that gives us the best of all metrics, from the figure below, we can see that recall is constantly performing good but our model tend to have problem with precision score, hence to choose the best N of features, we have to pick the area where all the metrics are performing and based on the figure I would say its around 39 features","21031f50":"Here the loop will be starting from 20 as we will start training with top 20 features up to all 50 features to find optimal number of features needed for this problem","05505ba2":"# Final Random Forest Model\n\nLets train the final random forest model based on the optimal N number of features","9157e545":"# Convert data \n\nIn this phase we will convert float64 and int64 data to type 32, by doing this we can save the memory usage and we can prepare the data for using with CuML later for training purpose\n\nAs we can see the data has 10k rows and 50 columns including labels","4e5e68b5":"# Columsn 40 to 50\n\nThe only column in this group that has some correlation with labels is PctExtNullSelfRedirectHyperlinksRT and it has negative effect towards labels which could mean that when the number of percent of null self redirect hyperlinks occur hence the probabiliy of phising increases","5c328bfd":"# Balance\/Imbalanced Data\n\nThe data is balanced for non-phising and phising label","2c0970e0":"# First 10 columns\n\nBy looking at the first 10 columns against labels, we can concluded that non of the features have strong correlation with the labels, however, NumDash has some significant negative effect towards the labels, which could mean if there is less number of dash then it is more likely to be phising site","bed1f547":"# Columns 10 to 20\n\nThere are no strong or even medium level strength correlation features with labels","1b4026b4":"# Training Random Forest Classifier on GPU\n\nIt is the same method as logistic reg, the only diff is that we are now using random forest classifier for training and trying to beat the logistic baseline","d204a1e5":"# Loading the data\n\nWe will start by loading the provided csv data using pandas read_csv method","bba32b8a":"# Prediction\n\nWe will first use logistic regression as for baseline, then try to beat the baseline using random forest classifer\n\nOur evaluation metrics will be accuracy, precision, recall and f1 score\n\nBelow we import all the required modules","c3627642":"# View the data\n\nLets look at random 5 rows from the dataset, it seems like we have mix of ranged data, some column have smaller range compared to others","db1b2386":"# Mutual Info\n\nWe will use mutual info classifier to find non linear and linear correlation betweem the features and labels","8e6b3174":"# Performance\n\nThe model is now capable of predicting at up to 98% accuracy and also precision and recall, this shows the model has high confidence in predicting phishing or non-phishing site","0d37c072":"Here we process the scores and we can see that now mutual info is showing a bit different list from spearman corr","43815f24":"# Columns 20 to 30\n\nStill no strong correlation feature","95ee3bd4":"# Spearman Correlation\n\nBy looking the spearman correlation, we can find which features are linearly correlated in terms of predicting if a site is phising or not"}}