{"cell_type":{"5eadac02":"code","3efe03de":"code","9c38d939":"code","9c3ffd04":"code","6a4b360f":"code","ef887a97":"code","0012f550":"code","a8b111d3":"code","e6eb4cc3":"code","8f89fc07":"code","b4bab3fc":"code","8faf2f0f":"code","12412c4b":"code","4a94bf21":"code","ccf5d265":"code","3be88f83":"code","45c1c640":"code","6501e972":"code","9aa626bc":"code","30295568":"code","1fe3999a":"code","3edb7070":"code","2b982b15":"code","6ffe6350":"code","7da2dde2":"code","38d50661":"code","c23ede51":"code","e7692f2d":"code","a690acd4":"code","4519c391":"code","cdce62a5":"code","2716321e":"code","24047760":"code","f5e7e922":"code","07769e0e":"code","5981cba7":"code","acdc33ad":"code","165be426":"code","0ed11899":"code","4e6f13dd":"code","a8921c82":"code","bc79d2e6":"code","8d33ca90":"code","752e9e03":"code","88d8d06c":"code","df432bd6":"code","57bc788f":"code","2630fb18":"code","58f68b37":"code","e7bed145":"code","d1f0537e":"code","83944f4e":"code","a331019a":"code","09d545ec":"code","4e36e302":"code","98658ca5":"code","ae0c4917":"code","7dd2f70d":"code","aea137f2":"code","374d0dec":"code","25bb3cdb":"code","cda835bd":"code","7077ca8d":"code","b9955fa3":"code","9c218f99":"code","df565c29":"code","6629a2f3":"code","ad9b9d17":"code","89cd2091":"code","9f4c7e31":"code","90821902":"code","bc0f59a4":"code","954a146a":"code","7c51f63b":"code","c2235ed9":"code","47a3dcc5":"code","2681c22e":"code","04f81405":"code","2212d836":"code","b18c2e12":"code","12568122":"code","c3dbcd8a":"code","5a342729":"code","e69a8a4e":"code","c8e9013f":"code","129f125b":"code","100d4b5f":"code","564daae0":"markdown","e0a89309":"markdown","9f4382e1":"markdown","28c3a911":"markdown","101e515c":"markdown","c3c86689":"markdown","57060473":"markdown","e7eecc76":"markdown","943d9109":"markdown","cff418a4":"markdown","1a2b87e5":"markdown","4a48b235":"markdown","a013320f":"markdown","f8e56368":"markdown","d37c6088":"markdown","7f9d12c1":"markdown","94a3bab1":"markdown","1ba635a4":"markdown","a61cd841":"markdown","527a59d4":"markdown","9d113d2f":"markdown","0578363c":"markdown","cfdbc42a":"markdown","9fa12438":"markdown","e5e88f87":"markdown","e6b77ea3":"markdown","e35e80d6":"markdown","fa7a0718":"markdown","531c4be8":"markdown"},"source":{"5eadac02":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport array","3efe03de":"plt.style.use('seaborn')","9c38d939":"train=pd.read_csv(\"https:\/\/raw.githubusercontent.com\/overtunned\/DataScience\/main\/train.csv\")\ntest = pd.read_csv(\"https:\/\/raw.githubusercontent.com\/overtunned\/DataScience\/main\/test.csv\")","9c3ffd04":"train.head()","6a4b360f":"train.shape","ef887a97":"train.info()","0012f550":"train.describe()","a8b111d3":"pd.unique(train[\"price_range\"])","e6eb4cc3":"train.isnull().sum() #checking for null values","8f89fc07":"sns.countplot(x=train[\"price_range\"]) #checking for imbalance","b4bab3fc":"train.corr()","8faf2f0f":"plt.figure(figsize=(20,15))\nsns.heatmap(train.corr(),annot = True)","12412c4b":"fig = plt.figure(figsize=(15,30))\nfor i, col in enumerate(train.columns):\n    ax=plt.subplot(7,3,i+1)\n    train[col].hist(ax=ax)","4a94bf21":"fig, ax = plt.subplots(figsize=(10,8))\nsns.boxenplot(x=\"price_range\",y=\"battery_power\", data=train,ax = ax)","ccf5d265":"fig, ax = plt.subplots(figsize=(10,8))\nsns.boxplot(x=train['price_range'],y=train['px_height'],ax=ax);","3be88f83":"fig, ax = plt.subplots(figsize=(10,8))\nsns.boxplot(x=train['price_range'],y=train['px_width'],ax=ax);","45c1c640":"fig, ax = plt.subplots(figsize=(10,8))\nsns.boxplot(x=train['price_range'],y=train['px_width'],ax=ax);","6501e972":"fig, ax = plt.subplots(figsize=(10,8))\nsns.boxplot(x=train['price_range'],y=train['ram'],ax=ax, showfliers= False)","9aa626bc":"sns.pointplot(x=train['price_range'],y=train['fc'])","30295568":"sns.pointplot(x=train['price_range'],y=train['pc'])","1fe3999a":"sns.catplot(x=\"price_range\",y=\"battery_power\", data=train, kind=\"boxen\")","3edb7070":"sns.catplot(x='price_range',col='three_g',hue ='four_g',data = train, kind ='count')","2b982b15":"sns.pointplot(y=\"int_memory\", x=\"price_range\", data=train)","6ffe6350":"# temp=pd.DataFrame(train[train.columns[:6]])\n# temp['price_range']=train['price_range']\n# sns.pairplot(temp,hue='price_range')","7da2dde2":"# train1 = train[~((train['ram'] < 1400) & (train['price_range'] == 2))]\n# train1 = train1[~((train1['ram'] > 1650) & (train1['price_range'] == 0))]","38d50661":"ram_price=train[[ 'price_range', 'ram',]]\nram_price=ram_price[(ram_price['price_range'] == 1) | (ram_price['price_range']== 2) ]\nram_price","c23ede51":"ram_price.hist(by='price_range')","e7692f2d":"price1=ram_price['ram'] [ram_price['price_range'] == 1]\nprice1","a690acd4":"price2=ram_price['ram'] [ram_price['price_range'] == 2]\nprice2","4519c391":"price2.hist(histtype='stepfilled', alpha=.5, bins=20)\nprice1.hist(histtype='stepfilled', alpha=.5, color=sns.desaturate(\"red\", 1))\nplt.xlabel('Ram',fontsize=15)\nplt.ylabel('Price Range',fontsize=15)\nplt.show()","cdce62a5":"means_table = ram_price.groupby('price_range').mean()\nmeans_table","2716321e":"def meandiff(df, attr):\n    means_table = df.groupby('price_range').mean()\n    return (means_table[attr].iloc[0]- means_table[attr].iloc[1])","24047760":"ob_diff = meandiff(ram_price, 'ram')\nob_diff","f5e7e922":"shuffled = ram_price.sample(1000,replace = False)\nshuffled_ram = shuffled['ram']\noriginal_and_shuffled= ram_price.assign(shuffled_ram=shuffled_ram.values )\ndifference = meandiff(original_and_shuffled, 'shuffled_ram')\ndifference","07769e0e":"differences = np.zeros(5000)\nfor i in np.arange(len(differences)):\n    shuffled = ram_price.sample(1000,replace = False)\n    shuffled_ram = shuffled['ram']\n    original_and_shuffled= ram_price.assign(shuffled_ram=shuffled_ram.values )\n    difference = meandiff(original_and_shuffled, 'shuffled_ram')\n    differences[i] = difference\ndifferences_df = pd.DataFrame(differences)\ndifferences_df","5981cba7":"differences_df.hist()\nplt.title('Prediction Under Null Hypotheses');\nplt.xlabel('Differences between Group Averages',fontsize=15)\nplt.ylabel('Units',fontsize=15);\nprint('Observed Difference:', ob_diff)\nplt.axvline(ob_diff, color='red');","acdc33ad":"p_value=np.count_nonzero(differences <= ob_diff)\/differences.size","165be426":"if p_value < 0.05: \n    print(\" we are rejecting null hypothesis\")\nelse:\n    print(\"we are accepting null hypothesis\")","0ed11899":"from scipy import stats","4e6f13dd":"s_A = train[train['price_range']==1]\ns_A=s_A['ram']\ns_A.mean()","a8921c82":"s_B = train[train['price_range']==2]\ns_B=s_B['ram']\ns_B.mean()","bc79d2e6":"ttest,p_value=stats.ttest_ind(s_A,s_B)","8d33ca90":"if p_value < 0.05: \n    print(\" we are rejecting null hypothesis\")\nelse:\n    print(\"we are accepting null hypothesis\")","752e9e03":"# separating the attributes into categorical and numerical for scaling and making a new dataframe for prediction.\nnum=['battery_power',\n     'clock_speed',\n     'fc',\n     'int_memory',\n     'mobile_wt', \n     'n_cores',\n     'm_dep',\n     'pc', \n     'px_height',\n     'px_width', \n     'ram', \n     'sc_h', \n     'sc_w', \n     'talk_time']\n\n\ncat=['blue',\n     'dual_sim',\n     'four_g',\n     'three_g', \n     'touch_screen',\n     'wifi']","88d8d06c":"from sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import r2_score\nimport statsmodels.api as sm","df432bd6":"scaler_train = MinMaxScaler()\ntrain1=train.copy(deep=True)\ntrain1[num]=scaler_train.fit_transform(train1[num])\n# X=train1.drop('price_range',axis=1)\nX=train1[['battery_power','px_height','px_width','ram']]\ny=train1['price_range']","57bc788f":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=101)","2630fb18":"from sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.decomposition import PCA\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import KFold, RepeatedKFold, RepeatedStratifiedKFold, cross_val_score\nfrom sklearn.metrics import roc_auc_score, roc_curve, confusion_matrix, classification_report,auc","58f68b37":"linreg=LinearRegression()\nlinreg.fit(X_train,y_train)\nlinreg.score(X_train,y_train)","e7bed145":"linreg.score(X_test,y_test)","d1f0537e":"print(\"The linear model is: Y = {:.3} + {:.3}X\".format(linreg.intercept_, linreg.coef_[0]))\nprint(\"The linear model intercept is {}\".format(linreg.intercept_))\nprint(\"The linear model coefficent is {}\".format(linreg.coef_))","83944f4e":"linreg_coef = pd.Series(index = X_train.columns, data = np.abs(linreg.coef_))\nn_features = (linreg_coef>0).sum()\nprint(f'{n_features} features with reduction of {(1-n_features\/len(linreg_coef))*100:2.2f}%')\nlinreg_coef.sort_values().plot(kind = 'bar', figsize = (13,5));","a331019a":"from sklearn.svm import SVR","09d545ec":"svr = SVR(kernel='linear')\nsvr.fit(X_train,y_train)\nsvr.score(X_train,y_train)","4e36e302":"svr_coef = pd.Series(index = X_train.columns, data = np.abs(svr.coef_[0]))\nn_features = (svr_coef>0).sum()\nprint(f'{n_features} features with reduction of {(1-n_features\/len(svr_coef))*100:2.2f}%')\nsvr_coef.sort_values().plot(kind = 'bar', figsize = (13,5));","98658ca5":"X = X_test\nX = sm.add_constant(X)\nest=sm.OLS(y_test, X)\nest = est.fit()\nest.summary()","ae0c4917":"from sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.preprocessing import label_binarize\n\ndef roc_plot(clf, X, y, fn):\n    y1 = label_binarize(y, classes=[0, 1, 2, 3])\n    n_classes = y1.shape[1]\n\n    X_train, X_test, y_train, y_test = train_test_split(X, y1, test_size=.5,random_state=0)\n\n    classifier = OneVsRestClassifier(clf).fit(X_train, y_train)\n    \n    if fn==1:\n        y_pred= classifier.decision_function(X_test)\n    elif fn==2:\n        y_pred= classifier.predict(X_test)\n\n    fpr = dict()\n    tpr = dict()\n    thrhld=dict()\n    roc_auc = dict()\n\n    for i in range(n_classes):\n        fpr[i], tpr[i], thrhld[i] = roc_curve(y_test[:, i], y_pred[:, i])\n        roc_auc[i] = auc(fpr[i], tpr[i])\n\n    plt.figure()\n    lw = 2\n    fig = plt.figure(figsize=(15,15))\n    for i in range(n_classes):\n        ax=plt.subplot(2,2,i+1)\n        ax.plot(fpr[i], tpr[i], color='darkorange',\n                 lw=lw, label='ROC curve (area = %0.6f)' % roc_auc[i])\n        ax.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')\n        ax.set_xlabel('False Positive Rate')\n        ax.set_ylabel('True Positive Rate')\n        ax.set_title(f'ROC {i}')\n        ax.legend(loc=\"lower right\")","7dd2f70d":"def kfoldcv(model,X,y):\n    cv = KFold(n_splits=10,shuffle=True, random_state=1)\n    n_scores = cross_val_score(model, X, y, scoring='accuracy', cv=cv, n_jobs=-1)\n    print(\"{:.3} accuracy with a standard deviation of {:.3}\" .format(n_scores.mean(), n_scores.std()))","aea137f2":"from sklearn.preprocessing import StandardScaler\n\nstd_scaler=StandardScaler()\ntrain2=train.copy(deep=True)\ntrain2[num]=std_scaler.fit_transform(train2[num])\n# X=train2.drop('price_range',axis=1)\nX=train2[['battery_power','px_height','px_width','ram']]\ny=train2['price_range']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=101)","374d0dec":"from sklearn.linear_model import LogisticRegression","25bb3cdb":"lm=LogisticRegression()\nlm.fit(X_train,y_train)\nlm.score(X_test,y_test)","cda835bd":"y_pred=lm.predict(X_test)\nconfusion_matrix(y_test,y_pred)\nsns.heatmap(confusion_matrix(y_test,y_pred), annot=True,fmt='.3g')","7077ca8d":"kfoldcv(lm,X_train,y_train)","b9955fa3":"print(classification_report(y_pred, y_test))","9c218f99":"roc_plot(lm, X, y, 1)","df565c29":"steps = [('pca', PCA(n_components=3)), ('lm', LogisticRegression())]\nmodel = Pipeline(steps=steps)\nmodel.fit(X_train, y_train)\nmodel.score(X_test,y_test)","6629a2f3":"y_pred=model.predict(X_test)\nconfusion_matrix(y_test,y_pred)\nsns.heatmap(confusion_matrix(y_test,y_pred), annot=True,fmt='.3g')","ad9b9d17":"kfoldcv(model,X_train,y_train)","89cd2091":"print(classification_report(y_pred, y_test))","9f4c7e31":"roc_plot(model, X, y, 1)","90821902":"y_prob = model.predict_proba(X_test)\nroc_auc_ovo = roc_auc_score(y_test, y_prob, multi_class=\"ovo\")\n\nroc_auc_ovr = roc_auc_score(y_test, y_prob, multi_class=\"ovr\")\n\nprint(\"One-vs-One ROC AUC scores:\\n{:.6f}\"\n      .format(roc_auc_ovo))\nprint()\nprint(\"One-vs-Rest ROC AUC scores:\\n{:.6f}\"\n      .format(roc_auc_ovr))","bc0f59a4":"from sklearn.neighbors import KNeighborsClassifier","954a146a":"params_knn = {'n_neighbors' : [3, 5, 7, 9, 11, 13, 15]}\n\nknn = KNeighborsClassifier()\nknn_classifier = GridSearchCV(knn, params_knn, cv=10, n_jobs=-1)\nknn_classifier.fit(X_train, y_train)\n\nprint(f'Optimal neighbors: {knn_classifier.best_params_[\"n_neighbors\"]}')\nprint(f'Best score: {knn_classifier.best_score_}')","7c51f63b":"knn_model = KNeighborsClassifier(n_neighbors=knn_classifier.best_params_[\"n_neighbors\"])\nknn_model.fit(X_train, y_train)\ny_pred=knn_model.predict(X_test)\nconfusion_matrix(y_test,y_pred)\nsns.heatmap(confusion_matrix(y_test,y_pred), annot=True,fmt='.3g')","c2235ed9":"steps = [('pca', PCA(n_components=3)), \n         ('knn', KNeighborsClassifier(n_neighbors=knn_classifier.best_params_[\"n_neighbors\"]))]\nmodel = Pipeline(steps=steps)\nmodel.fit(X_train, y_train)\ny_pred=model.predict(X_test)\nconfusion_matrix(y_test,y_pred)\nsns.heatmap(confusion_matrix(y_test,y_pred), annot=True,fmt='.3g')\nmodel.score(X_test,y_test)","47a3dcc5":"print(classification_report(y_pred, y_test))","2681c22e":"roc_plot(knn_model, X, y, 2)","04f81405":"from sklearn.svm import SVC","2212d836":"svm_clf = SVC(kernel='rbf', C=1).fit(X_train, y_train)\nsvm_clf.score(X_test, y_test)","b18c2e12":"y_pred=svm_clf.predict(X_test)\nconfusion_matrix(y_test,y_pred)\nsns.heatmap(confusion_matrix(y_test,y_pred), annot=True,fmt='.3g')","12568122":"print(classification_report(y_pred, y_test))","c3dbcd8a":"roc_plot(svm_clf, X, y, 1)","5a342729":"from sklearn.naive_bayes import GaussianNB","e69a8a4e":"nbg_model = GaussianNB()\nnbg_model.fit(X_train, y_train)\nnbg_model.score(X_test, y_test)","c8e9013f":"y_pred = nbg_model.predict(X_test)\nconfusion_matrix(y_test,y_pred)\nsns.heatmap(confusion_matrix(y_test,y_pred), annot=True,fmt='.3g')","129f125b":"print(classification_report(y_pred, y_test))","100d4b5f":"roc_plot(nbg_model, X, y,2)","564daae0":"There are 1000 rows in the population, so drawing 1000 rows without replacement.","e0a89309":"### KNN","9f4382e1":"### Naive Bayes","28c3a911":"- We can observe a increase in the battery capacity of the phones.","101e515c":"### Logistic Regression","c3c86689":"- We can observe that as the price increases the front camera megapixel also increases but the very high cost phones seems to reduce the front camera megapixels.","57060473":"## EDA","e7eecc76":"### Student's t-Test\n- We are going to take the population ram of the dataset to t-test","943d9109":"- From the distribution we can observe that the phones that have a price range of 1 is slightly to the left.\n- The ram of phones whose price range is 1 seems lower than the phones in the price range 2.","cff418a4":"we observe that\n* ram has a high positive correlation with price.\n* battery power, pixel height and pixel width shows a positive correlation.","1a2b87e5":"On the basis of mobile specification data we are going to predict the price range of the device.","4a48b235":"- Hyposthesis ($H_0$): There is no difference in the ram\n- Alternate Hypothesis ($H_1$) : There is a significant difference","a013320f":"Study into other attributes","f8e56368":"## Pre-processing","d37c6088":"## Regression","7f9d12c1":"## Classification","94a3bab1":"- WE can observe higher megapixel back camera as the price of the device increases","1ba635a4":"**USE**:\n\n- This kind of prediction will help companies estimate price of mobiles to give tough competion to other mobile manufacturer\n- Also it will be usefull for Consumers to verify that they are paying best price for a mobile.","a61cd841":"### Support Vector Regression","527a59d4":"We are going to stimulate the null hypothesis by taking random samples from the population.","9d113d2f":"# Mobile Price Prediction","0578363c":"We can observe that \n* if the phones have 3g then it has 4g\n* nearly half the phones have both 3g and 4g ","cfdbc42a":"## Hypothesis Testing","9fa12438":"## Support Vector Classifier","e5e88f87":"The p-value is less than 0.05 hence we reject the null hypothesis.","e6b77ea3":"further study into the correlated attributes","e35e80d6":"### Linear Regression","fa7a0718":"We can observe that the distribution is centered around 0. So we have to accept our null hypothesis since there is significant difference between the ram of phones in the price range of 1 and 2.","531c4be8":"#### Dataset Description\n- id: ID\n- battery_power: Total energy a battery can store in one time measured in mAh\n- blue: Has bluetooth or not\n- clock_speed: speed at which microprocessor executes instructions\n- dual_sim: Has dual sim support or not\n- fc: Front Camera mega pixels\n- four_g: Has 4G or not\n- int_memory: Internal Memory in Gigabytes\n- m_dep: Mobile Depth in cm\n- mobile_wt: Weight of mobile phone\n- n_cores: Number of cores of processor\n- pc: Primary Camera mega pixels\n- px_height: Pixel Resolution Height\n- px_width: Pixel Resolution Width\n- ram: Random Access Memory in Megabytes\n- sc_h: Screen Height of mobile in cm\n- sc_w: Screen Width of mobile in cm\n- talk_time: longest time that a single battery charge will last when you are\n- three_g: Has 3G or not\n- touch_screen: Has touch screen or not\n- wifi: Has wifi or not\n- price_range : phone price range\n\n\nHere, price_range is our target."}}