{"cell_type":{"d9dc8186":"code","e8755a7b":"code","2ed1e384":"code","c5971ada":"code","5f26882e":"code","14f64a1f":"code","bf448702":"code","e614d1a1":"code","d76d78b9":"markdown","5fe8b733":"markdown","5b5ed9fa":"markdown","46f6b5d1":"markdown","d389c94a":"markdown","99b69d26":"markdown","3c94a1a9":"markdown","9dec160c":"markdown","a8f5912b":"markdown","b83a180d":"markdown","fd7542e1":"markdown"},"source":{"d9dc8186":"import bs4\nimport requests\nimport time\nimport random as ran\nimport sys\nimport pandas as pd","e8755a7b":"url = 'https:\/\/www.imdb.com\/search\/title?release_date=2018&sort=boxoffice_gross_us,desc&start=1'\n\nsource = requests.get(url).text\nsoup = bs4.BeautifulSoup(source,'html.parser')","2ed1e384":"movie_blocks = soup.findAll('div',{'class':'lister-item-content'})","c5971ada":"mname = movie_blocks[0].find('a').get_text() # Name of the movie\n\nm_reyear = int(movie_blocks[0].find('span',{'class': 'lister-item-year'}).contents[0][1:-1]) # Release year\n\nm_rating = float(movie_blocks[0].find('div',{'class':'inline-block ratings-imdb-rating'}).get('data-value')) #rating\n\nm_mscore = float(movie_blocks[0].find('span',{'class':'metascore favorable'}).contents[0].strip()) #meta score\n\nm_votes = int(movie_blocks[0].find('span',{'name':'nv'}).get('data-value')) # votes\n\nprint(\"Movie Name: \" + mname,\n      \"\\nRelease Year: \" + str(m_reyear),\n      \"\\nIMDb Rating: \" + str(m_rating),\n      \"\\nMeta score: \" + str(m_mscore),\n      \"\\nVotes: \" + '{:,}'.format(m_votes)\n\n)","5f26882e":"def scrape_mblock(movie_block):\n    \n    movieb_data ={}\n  \n    try:\n        movieb_data['name'] = movie_block.find('a').get_text() # Name of the movie\n    except:\n        movieb_data['name'] = None\n\n    try:    \n        movieb_data['year'] = str(movie_block.find('span',{'class': 'lister-item-year'}).contents[0][1:-1]) # Release year\n    except:\n        movieb_data['year'] = None\n\n    try:\n        movieb_data['rating'] = float(movie_block.find('div',{'class':'inline-block ratings-imdb-rating'}).get('data-value')) #rating\n    except:\n        movieb_data['rating'] = None\n\n    try:\n        movieb_data['m_score'] = float(movie_block.find('span',{'class':'metascore favorable'}).contents[0].strip()) #meta score\n    except:\n        movieb_data['m_score'] = None\n\n    try:\n        movieb_data['votes'] = int(movie_block.find('span',{'name':'nv'}).get('data-value')) # votes\n    except:\n        movieb_data['votes'] = None\n\n    return movieb_data\n    ","14f64a1f":"def scrape_m_page(movie_blocks):\n    \n    page_movie_data = []\n    num_blocks = len(movie_blocks)\n    \n    for block in range(num_blocks):\n        page_movie_data.append(scrape_mblock(movie_blocks[block]))\n    \n    return page_movie_data","bf448702":"def scrape_this(link,t_count):\n    \n    #from IPython.core.debugger import set_trace\n\n    base_url = link\n    target = t_count\n    \n    current_mcount_start = 0\n    current_mcount_end = 0\n    remaining_mcount = target - current_mcount_end \n    \n    new_page_number = 1\n    \n    movie_data = []\n    \n    \n    while remaining_mcount > 0:\n\n        url = base_url + str(new_page_number)\n        \n        #set_trace()\n        \n        source = requests.get(url).text\n        soup = bs4.BeautifulSoup(source,'html.parser')\n        \n        movie_blocks = soup.findAll('div',{'class':'lister-item-content'})\n        \n        movie_data.extend(scrape_m_page(movie_blocks))   \n        \n        current_mcount_start = int(soup.find(\"div\", {\"class\":\"nav\"}).find(\"div\", {\"class\": \"desc\"}).contents[1].get_text().split(\"-\")[0])\n\n        current_mcount_end = int(soup.find(\"div\", {\"class\":\"nav\"}).find(\"div\", {\"class\": \"desc\"}).contents[1].get_text().split(\"-\")[1].split(\" \")[0])\n\n        remaining_mcount = target - current_mcount_end\n        \n        print('\\r' + \"currently scraping movies from: \" + str(current_mcount_start) + \" - \"+str(current_mcount_end), \"| remaining count: \" + str(remaining_mcount), flush=True, end =\"\")\n        \n        new_page_number = current_mcount_end + 1\n        \n        time.sleep(ran.randint(0, 10))\n    \n    return movie_data\n    \n    ","e614d1a1":"base_scraping_link = \"https:\/\/www.imdb.com\/search\/title?release_date=2018-01-01,2018-12-31&sort=boxoffice_gross_us,desc&start=\"\n\ntop_movies = 150 #input(\"How many movies do you want to scrape?\")\nfilms = []\n\nfilms = scrape_this(base_scraping_link,int(top_movies))\n\nprint('\\r'+\"List of top \" + str(top_movies) +\" movies:\" + \"\\n\", end=\"\\n\")\npd.DataFrame(films)","d76d78b9":"Now I search for the for [top 1000 films released in year of 2018 at imdb.com](https:\/\/www.imdb.com\/search\/title?release_date=2018&sort=boxoffice_gross_us,desc&start=1) and scrape results from the first page","5fe8b733":"Finally, I put together all functions created above to scrape the top 150 movies on the list","5b5ed9fa":"In this simple kernal, I illustrate how to we can use `BeautifulSoup` to scrape the International Movies Database (IMDB) at [imdb.com](https:\/\/imdb.com) for top films released in year 2018 with the highest US box office. \n\nI am organizing the final results as a dataframe with below elements:\n\n* `name` - title of the movie, \n* `year` - release year of the movie, \n* `imdb` - IMDB score of the movie, \n* `m_score` - meta score of the movie, \n* `vote` - number of votes.","46f6b5d1":"First, we import the requried packages","d389c94a":"Since above code extracts all data on the first page, below code is run only to extract movie information on it.","99b69d26":"Now since scraping the data is an iterative process, I define separate functions for each purpose.\n\nFirst I am going to define a function which will extract the targeted elements from a 'movie block list' (discussed above)","3c94a1a9":"Once you examine the resulting pages of the imbd search that we initially did , it's obvious that by editing the html link it is possible to view all search results. Thus I will be using this feature during the scrape to iterate through all pages.","9dec160c":"Then I create the below function to scrape all movie blocks within a single search result page","a8f5912b":"Before extracting information across all movies, I first examine one of the extracted block to identify the elements that we need to scrape.\n\nBelow I've extracted the elements from the first movie block","b83a180d":"That's it! Likewise, the same principle can be used to scrape data from any page!\n\nI believe if you follow a bottom-up approach when scraping data, i.e., to build functions to extract data from the smallest pieces and work yourself up to higher levels, it'll make your life much easier than tryin to extract a lot of imformation at once.\n\nThanks for reading! Please let me know what you think and appreciate any feedback.","fd7542e1":"Now we built functions to extract all movie data from a single page.\n\nNext function will be created to iterate the above made function through all pages of the search result untill we scrape data for the targeted number of movies"}}