{"cell_type":{"19460d72":"code","e069efe4":"code","d746c90d":"code","3bdcb76f":"code","3867375b":"code","0189da5c":"code","8b37931c":"code","2a7be36e":"code","1354d0b3":"code","6a6da6db":"code","076bfb79":"code","21d4b3b3":"code","24b598f5":"code","32660fcf":"code","6c166995":"code","e72c5633":"code","d4708189":"code","fb32fbf0":"code","19624b9b":"code","32212c92":"code","227f454a":"code","28d849b0":"code","d096abd7":"code","4a74a8af":"code","75cc8626":"code","feee3ce3":"code","00d98146":"code","167221ed":"code","9a994b49":"code","8f48eacc":"code","b5d8a987":"code","44c990b1":"code","dd73aec1":"code","9842f8de":"code","324e4282":"code","3b1e2dea":"code","1a3f9e30":"code","eff4570a":"code","17b24220":"code","a0e84dde":"code","c9ad4b37":"code","2ae12123":"code","c922522f":"code","7e40e962":"markdown","f8dba881":"markdown","0bb2ac6f":"markdown","5cc8d8dc":"markdown"},"source":{"19460d72":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport torch\nfrom torch.utils.data import Dataset, random_split, DataLoader\nfrom PIL import Image\nimport torchvision.models as models\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nimport torchvision.transforms as T\nfrom sklearn.metrics import f1_score\nimport torch.nn.functional as F\nimport torch.nn as nn\nfrom torchvision.utils import make_grid","e069efe4":"DATA_DIR = '..\/input\/jovianpytorch\/Human protein atlas'\nTRAIN_DIR = DATA_DIR + '\/train'\nTEST_DIR = DATA_DIR + '\/test'\nTRAIN_CSV = DATA_DIR + '\/train.csv'\nTEST_CSV = '..\/input\/jovianpytorch\/submission.csv'","d746c90d":"data_df = pd.read_csv(TRAIN_CSV)\n\ndata_df.head()","3bdcb76f":"labels = {\n    0:'Mitochondria',\n    1:'Nuclear bodies',\n    2:'Nucleoli',\n    3:'Golgi apparatus',\n    4:'Nucleoplasm',\n    5:'Nucleoli fibrillar center',\n    6:'Cytosol',\n    7:'Plasma membrane',\n    8:'Centrosome',\n    9:'Nuclear speckles'\n}","3867375b":"def encode_label(label):\n    target = torch.zeros(10)\n    for l in str(label).split(' '):\n        target[int(l)] = 1.\n    return target\n\ndef decode_target(target, text_labels = False, threshold = 0.5):\n    result = []\n    for i,x in enumerate(target):\n        if (x >= threshold):\n            if text_labels:\n                result.append(labels[i]+ '(' +str(i) + ')')\n            else:\n                result.append(str(i))\n    return ' '.join(result)","0189da5c":"class HumanProteinDataset(Dataset):\n    def __init__(self, df, root_dir, transform = None):\n        self.df = df\n        self.transform = transform\n        self.root_dir = root_dir\n        \n    def __len__(self):\n        return len(self.df)\n    \n    def __getitem__(self, idx):\n        row = self.df.loc[idx]\n        img_id, img_label = row['Image'], row['Label']\n        img_fname = self.root_dir + '\/' + str(img_id) + '.png'\n        img = Image.open(img_fname)\n        if self.transform:\n            img = self.transform(img)\n        return img, encode_label(img_label)","8b37931c":"imagenet_stats = ([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\ntrain_tfms = T.Compose([\n    T.RandomCrop(512, padding = 0, padding_mode = 'reflect'),\n    T.RandomHorizontalFlip(),\n    T.RandomRotation(10),\n    T.ToTensor(),\n    T.RandomErasing(inplace  =True)\n])\n\nvalid_tfms = T.Compose([\n    T.ToTensor(),\n])","2a7be36e":"np.random.seed(42)\nmsk = np.random.rand(len(data_df)) < 0.9\ntrain_df = data_df[msk].reset_index()\nval_df = data_df[~msk].reset_index()","1354d0b3":"train_ds = HumanProteinDataset(train_df, TRAIN_DIR, transform = train_tfms)\nval_ds = HumanProteinDataset(val_df, TRAIN_DIR, transform = valid_tfms)\nlen(train_ds), len(val_ds)","6a6da6db":"def show_example(img, target, invert = True):\n    if invert:\n        plt.imshow(1-img.permute((1,2,0)))\n    else:\n        plt.imshow(img.permute(1,2,0))\n    print('Labels', decode_target(target, text_labels = True))","076bfb79":"show_example(*train_ds[151])","21d4b3b3":"batch_size = 64","24b598f5":"train_dl = DataLoader(train_ds, batch_size, shuffle = True, pin_memory = True)\nval_dl = DataLoader(val_ds, batch_size, shuffle = True, pin_memory = True)","32660fcf":"def show_batch(dl, invert = True):\n    for images, labels in dl:\n        fig, ax = plt.subplots(figsize = (16,8))\n        ax.set_xticks([]); ax.set_yticks([])\n        data = 1-images if invert else images\n        ax.imshow(make_grid(data, nrow = 16).permute(1,2,0))\n        break","6c166995":"show_batch(train_dl, invert = True)","e72c5633":"def F_score(output, label, threshold = 0.5, beta = 1):\n    prob = output>threshold\n    label = label > threshold\n    TP = (prob&label).sum(1).float()\n    TN = ((~prob)&(~label)).sum(1).float()\n    FP = (prob&(~label)).sum(1).float()\n    FN = ((~prob)&label).sum(1).float()\n    precision = torch.mean(TP\/(TP+FP + 1e-12))\n    recall = torch.mean(TP\/(TP+FN + 1e-12))\n    F2 = (1+beta**2) * precision * recall\/(beta ** 2 *precision + recall +1e-12)\n    return F2.mean(0)","d4708189":"class MultilabelImageClassificationBase(nn.Module):\n    def training_step(self, batch):\n        images, targets = batch\n        out = self(images)\n        loss = F.binary_cross_entropy(out, targets)\n        return loss\n    \n    def validation_step(self, batch):\n        images, targets = batch\n        out = self(images)\n        loss = F.binary_cross_entropy(out, targets)\n        score = F_score(out, targets)\n        return {'val_loss': loss.detach(), 'val_score': score.detach()}\n    \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()\n        batch_scores = [x['val_score'] for x in outputs]\n        epoch_score = torch.stack(batch_scores).mean()\n        return {'val_loss': epoch_loss.item(), 'val_score':epoch_score.item()}\n    \n    def epoch_end(self, epoch, result):\n        print('Epoch [{}], last_lr: {:.4f}, train_loss: {:.4f}, val_loss: {:.4f}, val_score: {:.4f}'.format(\n            epoch, result['lrs'][-1], result['train_loss'], result['val_loss'], result['val_score']))","fb32fbf0":"class ProteinResnet(MultilabelImageClassificationBase):\n    def __init__(self):\n        super().__init__()\n        self.network = models.resnet34(pretrained = True)\n        num_ftrs = self.network.fc.in_features\n        self.network.fc = nn.Linear(num_ftrs, 10)\n    \n    def forward(self, xb):\n        return torch.sigmoid(self.network(xb))\n    \n    def freeze(self):\n        for param in self.network.parameters():\n            param.require_grad = False\n        for param in self.network.fc.parameters():\n            param.require_grad = True\n    \n    def unfreeze(self):\n        for param in self.network.parameters():\n            param.require_grad = True","19624b9b":"def get_default_device():\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')\n    \ndef to_device(data, device):\n    if isinstance(data, (list, tuple)):\n        return [to_device(x, device) for x in data]\n    return data.to(device, non_blocking= True)\n\nclass DeviceDataLoader():\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        for b in self.dl:\n            yield to_device(b, self.device)\n            \n    def __len__(self):\n        return len(self.dl)","32212c92":"device = get_default_device()\ndevice","227f454a":"train_dl = DeviceDataLoader(train_dl, device)\nval_dl = DeviceDataLoader(val_dl, device)","28d849b0":"@torch.no_grad()\ndef evaluate(model, val_loader):\n    model.eval()\n    output = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(output)\n\ndef get_lr(optimizer):\n    for param_group in optimizer.param_groups:\n        return param_group['lr']\n    \ndef fit_one_cycle(epochs, max_lr, model, train_loader, val_loader,\n                  weight_decay = 0, grad_clip = None, opt_func = torch.optim.SGD):\n    torch.cuda.empty_cache()\n    history = []\n    optimizer = opt_func(model.parameters(), max_lr, weight_decay = weight_decay)\n    sched = torch.optim.lr_scheduler.OneCycleLR(optimizer, max_lr, epochs = epochs,\n                                                steps_per_epoch = len(train_loader))\n    for epoch in range(epochs):\n        model.train()\n        train_losses = []\n        lrs = []\n        for batch in tqdm(train_loader):\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            \n            if grad_clip:\n                nn.utils.clip_grad_value_(model.parameters(), grad_clip)\n                \n            optimizer.step()\n            optimizer.zero_grad()\n            lrs.append(get_lr(optimizer))\n            sched.step()\n            \n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        result['lrs'] = lrs\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","d096abd7":"model = to_device(ProteinResnet(), device)","4a74a8af":"history = [evaluate(model, val_dl)]\nhistory","75cc8626":"model.freeze()","feee3ce3":"epochs = 5\nmax_lr = 0.01\ngrad_clip = 0.1\nweight_decay = 1e-4\nopt_func = torch.optim.Adam","00d98146":"%%time\nhistory += fit_one_cycle(epochs, max_lr, model, train_dl, val_dl,\n                         grad_clip = grad_clip,\n                         weight_decay = weight_decay,\n                         opt_func = opt_func)","167221ed":"model.unfreeze()","9a994b49":"%%time\nhistory += fit_one_cycle(epochs, 0.001, model, train_dl, val_dl, grad_clip = grad_clip, weight_decay = weight_decay, opt_func = opt_func)","8f48eacc":"def plot_scores(history):\n    scores = [x['val_score'] for x in history]\n    plt.plot(scores, '-x')\n    plt.xlabel('epoch')\n    plt.ylabel('score')\n    plt.title('F2 score vs. No. of epochs')","b5d8a987":"plot_scores(history)","44c990b1":"def plot_losses(history):\n    train_losses = [x.get('train_loss') for x in history]\n    val_losses = [x['val_loss'] for x in history]\n    plt.plot(train_losses, '-bx')\n    plt.plot(val_losses, '-rx')\n    plt.xlabel('epoch')\n    plt.ylabel('loss')\n    plt.legend(['Training', 'Validation'])\n    plt.title('Loss vs. No. of epochs')","dd73aec1":"plot_losses(history)","9842f8de":"def plot_lrs(history):\n    lrs = np.concatenate([x.get('lrs', []) for x in history])\n    plt.plot(lrs)\n    plt.xlabel('Batch no.')\n    plt.ylabel('Learning rate')\n    plt.title('Learning Rate vs. Batch no.')","324e4282":"plot_lrs(history)","3b1e2dea":"def predict_single(image):\n    xb = image.unsqueeze(0)\n    xb = to_device(xb, device)\n    preds = model(xb)\n    prediction = preds[0]\n    print('Prediction: ', prediction)\n    show_example(image, prediction, invert = False)","1a3f9e30":"test_df = pd.read_csv(TEST_CSV)\ntest_dataset = HumanProteinDataset(test_df, TEST_DIR, transform = valid_tfms)","eff4570a":"img, target = test_dataset[0]\nimg.shape","17b24220":"predict_single(test_dataset[90][0])","a0e84dde":"test_dl = DeviceDataLoader(DataLoader(test_dataset, batch_size, pin_memory = True), device)","c9ad4b37":"@torch.no_grad()\ndef predict_dl(dl, model):\n    torch.cuda.empty_cache()\n    batch_probs = []\n    for xb, _ in tqdm(dl):\n        probs = model(xb)\n        batch_probs.append(probs.cpu().detach())\n    batch_probs = torch.cat(batch_probs)\n    return [decode_target(x) for x in batch_probs]","2ae12123":"test_preds = predict_dl(test_dl, model)","c922522f":"submission_df = pd.read_csv(TEST_CSV)\nsubmission_df.Label = test_preds\nsubmission_df.sample(20)","7e40e962":"## Model-Transfer Learning","f8dba881":"## Data augumentations","0bb2ac6f":"## DataLoaders","5cc8d8dc":"## Training"}}