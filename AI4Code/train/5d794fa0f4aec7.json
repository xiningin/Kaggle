{"cell_type":{"1adb6be2":"code","0af76eb6":"code","c5e6e858":"code","4cf177ca":"code","e14ff978":"code","c4d8017c":"code","f6756f7e":"code","4cadb6ca":"code","893a1351":"code","eba8c3de":"code","47998fa0":"markdown","a9ebfd26":"markdown","a5756059":"markdown","8b0307a5":"markdown","e032704e":"markdown"},"source":{"1adb6be2":"import matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches as patches\n%matplotlib inline\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\nIris = pd.read_csv(\"..\/input\/iris\/Iris.csv\")\nIris = Iris.drop(Iris.columns[-1],axis=1)\ntrain = StandardScaler().fit_transform(Iris.values)\npd.DataFrame(train).head()","0af76eb6":"pip install SimpSOM","c5e6e858":"#Import the library\nimport SimpSOM as sps\n\n#Build a network 20x20 with a weights format taken from the raw_data and activate Periodic Boundary Conditions. \nnet = sps.somNet(20, 20, train, PBC=True)\n\n#Train the network for 10000 epochs and with initial learning rate of 0.01. \nnet.train(0.01, 10000)\n\n#Save the weights to file\nnet.save('filename_weights')\n\n#Print a map of the network nodes and colour them according to the first feature (column number 0) of the dataset\n#and then according to the distance between each node and its neighbours.\nnet.nodes_graph(colnum=0)\nnet.diff_graph()","4cf177ca":"raw_data = train.transpose()  ## already normalized by feature-wise\n\nnetwork_dimensions = np.array([10, 10])\nn_iterations = 10000\ninit_learning_rate = 0.01\n\nm = raw_data.shape[0]\nn = raw_data.shape[1]\n\n# initial neighbourhood radius\ninit_radius = max(network_dimensions[0], network_dimensions[1]) \/ 2\n# radius decay parameter\ntime_constant = n_iterations \/ np.log(init_radius)\n\ndata = raw_data","e14ff978":"net = np.random.random((network_dimensions[0], network_dimensions[1], m))","c4d8017c":"def find_bmu(t, net, m):\n    \"\"\"\n        Find the best matching unit for a given vector, t\n        Returns: bmu and bmu_idx is the index of this vector in the SOM\n    \"\"\"\n    bmu_idx = np.array([0, 0])\n    min_dist = np.iinfo(np.int).max\n    \n    # calculate the distance between each neuron and the input\n    for x in range(net.shape[0]):\n        for y in range(net.shape[1]):\n            w = net[x, y, :].reshape(m, 1)\n            sq_dist = np.sum((w - t) ** 2)\n            sq_dist = np.sqrt(sq_dist)\n            if sq_dist < min_dist:\n                min_dist = sq_dist # dist\n                bmu_idx = np.array([x, y]) # id\n    \n    bmu = net[bmu_idx[0], bmu_idx[1], :].reshape(m, 1)\n    return (bmu, bmu_idx)","f6756f7e":"def decay_radius(initial_radius, i, time_constant):\n    return initial_radius * np.exp(-i \/ time_constant)\n\ndef decay_learning_rate(initial_learning_rate, i, n_iterations):\n    return initial_learning_rate * np.exp(-i \/ n_iterations)\n\ndef calculate_influence(distance, radius):\n    return np.exp(-distance \/ (2* (radius**2)))","4cadb6ca":"for i in range(n_iterations):\n    # select a training example at random\n    t = data[:, np.random.randint(0, n)].reshape(np.array([m, 1]))\n    \n    # find its Best Matching Unit\n    bmu, bmu_idx = find_bmu(t, net, m)\n    \n    # decay the SOM parameters\n    r = decay_radius(init_radius, i, time_constant)\n    l = decay_learning_rate(init_learning_rate, i, n_iterations)\n    \n    # update weight vector to move closer to input\n    # and move its neighbours in 2-D vector space closer\n    \n    for x in range(net.shape[0]):\n        for y in range(net.shape[1]):\n            w = net[x, y, :].reshape(m, 1)\n            w_dist = np.sum((np.array([x, y]) - bmu_idx) ** 2)\n            w_dist = np.sqrt(w_dist)\n            \n            if w_dist <= r:\n                # calculate the degree of influence (based on the 2-D distance)\n                influence = calculate_influence(w_dist, r)\n                \n                # new w = old w + (learning rate * influence * delta)\n                # where delta = input vector (t) - old w\n                new_w = w + (l * influence * (t - w))\n                net[x, y, :] = new_w.reshape(1, 5)","893a1351":"net.shape","eba8c3de":"fig = plt.figure()\n\nax = fig.add_subplot(111, aspect='equal')\nax.set_xlim((0, net.shape[0]+1))\nax.set_ylim((0, net.shape[1]+1))\nax.set_title('Self-Organising Map after %d iterations' % n_iterations)\n\n# plot\nfor x in range(1, net.shape[0] + 1):\n    for y in range(1, net.shape[1] + 1):\n        ax.add_patch(patches.Rectangle((x-0.5, y-0.5), 1, 1,\n                     facecolor=net[x-1,y-1,:],\n                     edgecolor='none'))\nplt.show()","47998fa0":"**Loading the dataset - Iris**","a9ebfd26":"**Introduction to cluster visualization using SOM**\n\nThis notebook will describe various cluster visualization techniques for SOMs. Then implement couple of methods to understand the concept better.\n\nFollowing 3 types of visualization are more common in the literature.    \n\n1. U-matrix\n2. Vector fields\n3. Component planes","a5756059":"**Use SimpSOM to visualize U-matrix**\n\nFollowing documents and codes are used to demostrate this.    \n\n> GitHub - https:\/\/github.com\/fcomitani\/SimpSOM    \n> Example - https:\/\/www.kaggle.com\/asparago\/unsupervised-learning-with-som","8b0307a5":"**Existing implementations of SOMs as python libraries**\n\nYou can use following libraries to train and visualize self oranizing maps which is used for cluster analysis jobs of low\/high dimensional data.\nIt is not that hard to write the SOM algorithm on yourown.\n\n**1. somclu**\n\nyou can use the implementation of this at following links\n\n> Documentation :- https:\/\/peterwittek.github.io\/somoclu\/   \n> Github        :- https:\/\/somoclu.readthedocs.io\/en\/stable\/    \n> Example       :- https:\/\/github.com\/abhinavralhan\/kohonen-maps\/blob\/master\/somoclu-iris.ipynb\n\n**2. minisom**\n\n**3. GSom**\n\n**4. SimpSPM**\n\n> GitHub - https:\/\/github.com\/fcomitani\/SimpSOM    \n> Sample - https:\/\/www.kaggle.com\/asparago\/unsupervised-learning-with-som","e032704e":"**Implement an own SOM and visualize**\n\nFollowing implementation from github is taken as a reference for the implementation   \n> https:\/\/github.com\/abhinavralhan\/kohonen-maps\/blob\/master\/som-random.ipynb"}}