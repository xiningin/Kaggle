{"cell_type":{"0032afe3":"code","a5a80c31":"code","dad0e9e6":"code","dbb402fe":"code","0b656ebc":"code","7b0484a8":"code","670edc54":"code","4fa65fc9":"code","5c03c056":"code","c2ad7e61":"code","b3cc0b38":"code","5ad85498":"markdown","1f27f1b3":"markdown","14e43f4b":"markdown","ca77f9f4":"markdown","f6b1ad70":"markdown","4903918e":"markdown","470af2f6":"markdown","27335f34":"markdown","160b93ad":"markdown","15ceb3d4":"markdown","587ac407":"markdown","563b9830":"markdown","e50a051d":"markdown","e9aaccfe":"markdown"},"source":{"0032afe3":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))","a5a80c31":"# XML model\nfrom enum import Enum\n\n\nclass XMLTagsUpperLevel:\n    \"\"\"\n    This class defines the XML tag constants at the higher level of XML tree. The tag <record> is found below the tag\n    <page> in the tree hierarchy.\n    \"\"\"\n    PAGE = \"page\"\n    RECORD = \"record\"\n\n\nclass XMLTagsLowerLevel(Enum):\n    \"\"\"\n    This class defines all the XML tag constants that are one level below the <record> tag. This is defined as an\n    enumerated type for ease of iterating over all tags.\n    \"\"\"\n    UNIQUE_ID = \"uniq_id\"\n    CRAWL_TIMESTEMP = \"crawl_timestamp\"\n    URL = \"url\"\n    JOB_TITLE = \"job_title\"\n    CATEGORY = \"category\"\n    COMPANY_NAME = \"company_name\"\n    POST_DATE = \"post_date\"\n    JOB_DESCRIPTION = \"job_description\"\n    JOB_TYPE = \"job_type\"\n    SALARY_OFFERED = \"salary_offered\"\n    JOB_BOARD = \"job_board\"\n    GEO = \"geo\"\n    LOCATION = \"location\"\n","dad0e9e6":"# XML parser \nimport xml.etree.ElementTree as ET\n\nclass XMLParser:\n    BASE_PATH = \"..\/input\"\n    \n    \n    def __init__(self, file_path=BASE_PATH + \"\/emedcareers_eu_job_board_common_setup_pc_jobspikr_deduped_n_merged_20180822_071129200803658.xml\"):\n        \"\"\"\n        Initializes the XMLParser class instance.\n        :param file_path: Path to input xml file containing all the jobs data.\n        \"\"\"\n        self.file_path = file_path\n\n\n    def xml_to_pandas_df(self):\n        \"\"\"\n        Using the standard xml python library, we parse the data xml file and convert the xml data to a pandas\n        data frame.\n        :return: A pandas data frame instance containing all the jobs data.\n        \"\"\"\n        tree = ET.parse(self.file_path)\n        root = tree.getroot()\n\n        jobs_data = dict()\n        for tag in XMLTagsLowerLevel:\n            jobs_data[tag.value] = []\n\n        for i, page in enumerate(root.findall(XMLTagsUpperLevel.PAGE)):\n            for j, record in enumerate(page.findall(XMLTagsUpperLevel.RECORD)):\n                for tag in XMLTagsLowerLevel:\n                    temp = record.find(tag.value)\n                    if temp is not None:\n                        jobs_data[tag.value].append(temp.text)\n                    else:\n                        jobs_data[tag.value].append(\"\")\n\n        return pd.DataFrame(data=jobs_data)\n","dbb402fe":"base_path = \"..\/input\"\nfile_path = base_path + \"\/\" + os.listdir(\"..\/input\")[0]\nparser = XMLParser(file_path)\njobs_df = parser.xml_to_pandas_df()\nprint(\"----------------------------\")\nprint(\"Dataframe columns:\")\nprint(\"----------------------------\")\nprint(jobs_df.columns)\nprint(\"----------------------------\")\nprint(\"Sample data:\")\nprint(\"----------------------------\")\nprint(jobs_df.head())\nprint(\"----------------------------\")\nprint(\"Dataframe shape:\")\nprint(\"----------------------------\")\nprint(jobs_df.shape)","0b656ebc":"# Import libraries needed for plotting \nimport matplotlib.pyplot as plt\nimport seaborn as sns","7b0484a8":"COLUMN_COUNTS = \"counts\"\n\n\ndef groupby_and_get_number_of_rows(df, by):\n    \"\"\"\n    For the input dataframe df, group the rows by the column defined by the parameter by and return the number of rows\n    per value in the by column in a separate column titled COLUMN_COUNTS. \n    :param df: input pandas dataframe\n    :param by: input column name by which we group the rows in df\n    :return: A dataframe with first column as by and second column as COLUMN_COUNTS\n    \"\"\"\n    return df.groupby([by]).size().reset_index(name=COLUMN_COUNTS)","670edc54":"__X_LABEL = \"frequency\"\n__Y_LABEL_1_STR = \"{} (top {} out of {})\"\n__Y_LABEL_2_STR = \"{}\"\n\n\ndef plot_top_k_frequency_distribution_for_df_property(column_count_df, df_property, plot_properties, top_k):\n    x_labels = column_count_df[df_property]\n    n_x_labels = len(x_labels)\n    if top_k > n_x_labels:\n        top_k = n_x_labels\n    plt.figure(figsize=(plot_properties.width, plot_properties.height))\n    # _, ax = plt.subplots()\n    sns.set(font_scale=plot_properties.font_scale)\n    h1 = sns.barplot(y=df_property, x=COLUMN_COUNTS, data=column_count_df.head(n=top_k),\n                     color=plot_properties.bar_plot_color, alpha=plot_properties.alpha)\n    h1.set_yticklabels(list(x_labels[:top_k]))\n    h1.set_xticks(plot_properties.xticks)\n    y_label = __Y_LABEL_2_STR.format(df_property) if top_k == n_x_labels else __Y_LABEL_1_STR.format(df_property, top_k,\n                                                                                                     n_x_labels)\n    plt.xlabel(__X_LABEL)\n    plt.ylabel(y_label)\n    plt.show()","4fa65fc9":"class DefaultPlotProperties:\n    WIDTH = 60\n    HEIGHT = 40\n    FONT_SCALE = 3\n    BAR_PLOT_COLOR = [0, 0.5, 0.7]\n    ALPHA = 0.8\n    XTICK_ROTATION = 90\n    XTICKS = range(0, 1000, 100)","5c03c056":"class PlotProperties:\n    def __init__(self,\n                 width=DefaultPlotProperties.WIDTH,\n                 height=DefaultPlotProperties.HEIGHT,\n                 font_scale=DefaultPlotProperties.FONT_SCALE,\n                 bar_plot_color=DefaultPlotProperties.BAR_PLOT_COLOR,\n                 alpha=DefaultPlotProperties.ALPHA,\n                 xtick_rotation=DefaultPlotProperties.XTICK_ROTATION,\n                 xticks=DefaultPlotProperties.XTICKS):\n        self.width = width\n        self.height = height\n        self.font_scale = font_scale\n        self.bar_plot_color = bar_plot_color\n        self.alpha = alpha\n        self.xtick_rotation = xtick_rotation\n        self.xticks = xticks","c2ad7e61":"num_jobs_per_company_df = groupby_and_get_number_of_rows(jobs_df, by=XMLTagsLowerLevel.COMPANY_NAME.value)\nnum_jobs_per_company_df.sort_values([COLUMN_COUNTS], ascending=False, inplace=True)\nprint(num_jobs_per_company_df.head())\nplot_properties = PlotProperties(xticks=range(0, 5000, 500))\nplot_top_k_frequency_distribution_for_df_property(num_jobs_per_company_df, XMLTagsLowerLevel.COMPANY_NAME.value, plot_properties, top_k=30)","b3cc0b38":"num_jobs_per_location_df = groupby_and_get_number_of_rows(jobs_df, by=XMLTagsLowerLevel.LOCATION.value)\nnum_jobs_per_location_df.sort_values([COLUMN_COUNTS], ascending=False, inplace=True)\nprint(num_jobs_per_location_df.head())\nplot_properties = PlotProperties(bar_plot_color=[0.7, 0, 0], xticks=range(0, 8000, 500))\nplot_top_k_frequency_distribution_for_df_property(num_jobs_per_location_df, XMLTagsLowerLevel.LOCATION.value, plot_properties, top_k=30)","5ad85498":"***Though most folk do not use much object-oriented principles when writing Python code, I have found it somewhat useful to write modular code for the ease of code reuse and  maintainability. So the above is just my attempt at modular design to hopefully make anlaysis easier. ***","1f27f1b3":"<h1>Part 2: Analysis<\/h1>\n<h2>Part 2.1: Top-k frequency distributions<\/h2>","14e43f4b":"<h2>Part 1.1: As the first step, we write classes that define all the tags associated with the XML tree for the given input .xml file. The XMLTagsUpperLevel defines all the tags at the higher level in the XML tree and the XMLTagsLowerLevel defines all the tags in the lower level (at the record definition level) of the XML tree. Subclassing XMLTagsLowerLevel from Enum python class allows us to iterate over all the tags defined for a record. Coding the parser becomes quite convenient as a result. <\/h2>","ca77f9f4":"<u><h1>Simple analysis of healthcare job openings<\/h1><\/u><br>\n***Yogesh Virkar***  -- *11\/15\/2018*","f6b1ad70":"<h2>Part 1.3: The following code demonstrates the usage of the XML parser. The final data is obtained in the jobs_df pandas dataframe variable. <\/h2>","4903918e":"<h2>Part 1.2: The following code defines the XML parser required to parse the xml file and store the data into a pandas dataframe. <\/h2>","470af2f6":"***A class that defines the plot properties ***","27335f34":"***I am trying to figure out why some of the company names are weird such as \"0203 8757550\" seen in the top 30 companies for the number of job postings in 2.1.1 and why \"Science\" appears as a location in part 2.1.2. More will be added soon... ***","160b93ad":"***A class that defines the default plot properties ***","15ceb3d4":"***Define another helper function to plot frequency result***","587ac407":"**<h3>Part 2.1.2: Location with highest job openings (plotting top 30)<\/h3>**","563b9830":"***Define helper function to manipulate dataframe: For the input dataframe \"df\", group the rows by the column defined by the parameter \"by\" and return the number of rows per value in the by column in a separate column titled COLUMN_COUNTS***","e50a051d":"<h3>Part 2.1.1: Highest number of job posting by a particular company (plotting top 30)<\/h3>","e9aaccfe":"<h1>Part 1: Convert XML format to pandas dataframe<\/h1>\nFeel free to skip this part if you are not interested in knowing how parsing the xml file works. You can simply copy over the classes for your own analysis and checkout the example usage in Part 1.3 inorder to convert the xml file to a pandas dataframe. "}}