{"cell_type":{"1d719f12":"code","282a2edb":"code","940a827f":"code","e5f9f135":"code","bfb5d238":"code","12ae1562":"code","3846d486":"code","501191aa":"code","3d455ee6":"code","772bb2a9":"code","32719eb2":"code","c8a185fa":"code","d2bcbc71":"code","40521e5d":"code","d33505b9":"code","f0f55eb6":"code","98aa7be1":"code","ed696509":"code","dbe7ebc2":"code","190031b2":"code","6eeb4f5c":"code","3d59110d":"code","e4150d43":"code","608a8ff5":"code","14d23572":"code","b9baf67a":"code","baa6eeac":"code","a2a21cd6":"code","50ebd40a":"code","19c3da10":"code","b6f4c332":"code","dd3ddb52":"code","184cd31e":"code","6c6abe21":"code","613356e3":"code","b464646a":"code","0100b4f6":"code","066e8559":"code","9c49f719":"code","b739d0ab":"code","dabe2ff1":"code","36c13ea3":"code","df37a5d5":"code","30dbbc74":"code","57e9a282":"code","e388e9ca":"code","e2df5c13":"code","877d34be":"code","6dd1ae6b":"code","b0f09139":"code","2cfb292c":"code","a452a4e3":"code","b1ac48ab":"code","523ffe19":"code","cc93ceca":"code","ecbfe3b2":"code","4ff2af2a":"code","5e3ec417":"code","62b2d4a6":"code","b69a8e8a":"markdown","f1f28f5b":"markdown","1798da15":"markdown","810102d7":"markdown","6e4de209":"markdown","b11b3dc5":"markdown","63067d2e":"markdown","41b047b0":"markdown","c0920f74":"markdown","d5c6c2ac":"markdown","2f91feed":"markdown","abda6340":"markdown","2de01332":"markdown","6f37214a":"markdown","2bc70d19":"markdown","84f9ba80":"markdown","53a07d24":"markdown","4a4c586f":"markdown","e9a7d1f6":"markdown","5d230308":"markdown","ef6e1b37":"markdown","f7786e4d":"markdown","25e30fed":"markdown","58abcae2":"markdown"},"source":{"1d719f12":"import os\nimport gc\nimport sys\nimport json\nimport glob\nimport random\nfrom pathlib import Path\n\nimport pickle\nimport cv2\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport itertools\nfrom tqdm import tqdm\n\nfrom imgaug import augmenters as iaa\nfrom sklearn.model_selection import StratifiedKFold, KFold","282a2edb":"DATA_DIR = Path('\/kaggle\/input\/imaterialist-fashion-2019-FGVC6')\nROOT_DIR = Path('\/kaggle\/working')\n\n# For demonstration purpose, the classification ignores attributes (only categories),\n# and the image size is set to 512, which is the same as the size of submission masks\nNUM_CATS = 46\nIMAGE_SIZE = 512","940a827f":"!pwd","e5f9f135":"!pwd","bfb5d238":"!git clone https:\/\/www.github.com\/matterport\/Mask_RCNN.git\nos.chdir('Mask_RCNN')\n\n!rm -rf .git # to prevent an error when the kernel is committed\n!rm -rf images assets # to prevent displaying images at the bottom of a kernel","12ae1562":"!pwd","3846d486":"sys.path.append(ROOT_DIR\/'Mask_RCNN')\nfrom mrcnn.config import Config\nfrom mrcnn import utils\nimport mrcnn.model as modellib\nfrom mrcnn import visualize\nfrom mrcnn.model import log","501191aa":"!pwd","3d455ee6":"os.chdir('\/kaggle\/working\/')","772bb2a9":"!pwd","32719eb2":"import tensorflow as tf\nprint(tf.__version__)","c8a185fa":"#!wget --quiet https:\/\/github.com\/matterport\/Mask_RCNN\/releases\/download\/v2.0\/mask_rcnn_coco.h5\n#!ls -lh mask_rcnn_coco.h5\n\n","d2bcbc71":"!cp '..\/input\/imat2019-weights\/mask_rcnn_fashion_0002.h5'  '\/kaggle\/working'","40521e5d":"COCO_WEIGHTS_PATH = '.\/mask_rcnn_fashion_0002.h5'\nCOCO_WEIGHTS_PATH","d33505b9":"class FashionConfig(Config):\n    NAME = \"fashion\"\n    NUM_CLASSES = NUM_CATS + 1 # +1 for the background class\n    \n    GPU_COUNT = 1\n    IMAGES_PER_GPU = 4 # a memory error occurs when IMAGES_PER_GPU is too high\n    \n    BACKBONE = 'resnet50'\n    \n    IMAGE_MIN_DIM = IMAGE_SIZE\n    IMAGE_MAX_DIM = IMAGE_SIZE    \n    IMAGE_RESIZE_MODE = 'none'\n    \n    RPN_ANCHOR_SCALES = (16, 32, 64, 128, 256)\n    #DETECTION_NMS_THRESHOLD = 0.0\n    \n    # STEPS_PER_EPOCH should be the number of instances \n    # divided by (GPU_COUNT*IMAGES_PER_GPU), and so should VALIDATION_STEPS;\n    # however, due to the time limit, I set them so that this kernel can be run in 9 hours\n    STEPS_PER_EPOCH = 1000\n    VALIDATION_STEPS = 200\n    \nconfig = FashionConfig()\nconfig.display()","f0f55eb6":"!pwd","98aa7be1":"%cd \/kaggle\/working\/","ed696509":"with open(DATA_DIR\/\"label_descriptions.json\") as f:\n    label_descriptions = json.load(f)\n\nlabel_names = [x['name'] for x in label_descriptions['categories']]","dbe7ebc2":"#label_names","190031b2":"print(len(label_names))","6eeb4f5c":"segment_df = pd.read_csv(DATA_DIR\/\"train.csv\")","3d59110d":"#segment_df","e4150d43":"multilabel_percent = len(segment_df[segment_df['ClassId'].str.contains('_')])\/len(segment_df)*100\nprint(f\"Segments that have attributes: {multilabel_percent:.2f}%\")","608a8ff5":"#segment_df","14d23572":"segment_df['AttributeId'] = segment_df['ClassId'].str.split('_').str[0]\n\nprint(\"Total segments: \", len(segment_df))\nsegment_df.head()","b9baf67a":"image_df = segment_df.groupby('ImageId')['EncodedPixels', 'AttributeId'].agg(lambda x: list(x))\nsize_df = segment_df.groupby('ImageId')['Height', 'Width'].mean()\nimage_df = image_df.join(size_df, on='ImageId')\n\nprint(\"Total images: \", len(image_df))\nimage_df.head()","baa6eeac":"!pwd","a2a21cd6":"def resize_image(image_path):\n    img = cv2.imread(image_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = cv2.resize(img, (IMAGE_SIZE, IMAGE_SIZE), interpolation=cv2.INTER_AREA)  \n    return img","50ebd40a":"#label_descriptions","19c3da10":"IMAGE_SIZE","b6f4c332":"class FashionDataset(utils.Dataset):\n\n    def __init__(self, df):\n        super().__init__(self)\n        \n        # Add classes\n        for i, name in enumerate(label_names):\n            self.add_class(\"fashion\", i+1, name)\n            \n        \n        # Add images \n        for i, row in df.iterrows():\n            self.add_image(\"fashion\", \n                           image_id=row.name, \n                           path=str(DATA_DIR\/'train'\/row.name), \n                           labels=row['AttributeId'],\n                           annotations=row['EncodedPixels'], \n                           height=row['Height'], width=row['Width'])\n\n    def image_reference(self, image_id):\n        info = self.image_info[image_id]\n        return info['path'], [label_names[int(x)] for x in info['labels']]\n    \n    def load_image(self, image_id):\n        return resize_image(self.image_info[image_id]['path'])\n\n    def load_mask(self, image_id):\n        info = self.image_info[image_id]\n                \n        mask = np.zeros((IMAGE_SIZE, IMAGE_SIZE, len(info['annotations'])), dtype=np.uint8)\n        labels = []\n        \n        for m, (annotation, label) in enumerate(zip(info['annotations'], info['labels'])):\n            sub_mask = np.full(info['height']*info['width'], 0, dtype=np.uint8)\n            annotation = [int(x) for x in annotation.split(' ')]\n            \n            for i, start_pixel in enumerate(annotation[::2]):\n                sub_mask[start_pixel: start_pixel+annotation[2*i+1]] = 1\n\n            sub_mask = sub_mask.reshape((info['height'], info['width']), order='F')\n            sub_mask = cv2.resize(sub_mask, (IMAGE_SIZE, IMAGE_SIZE), interpolation=cv2.INTER_NEAREST)\n            \n            mask[:, :, m] = sub_mask\n            labels.append(int(label)+1)\n            \n        return mask, np.array(labels)","dd3ddb52":"dataset = FashionDataset(image_df)\ndataset.prepare()\n\nfor i in range(6):\n    image_id = random.choice(dataset.image_ids)\n    print(dataset.image_reference(image_id))\n    \n    image = dataset.load_image(image_id)\n    mask, class_ids = dataset.load_mask(image_id)\n    visualize.display_top_masks(image, mask, class_ids, dataset.class_names, limit=4)","184cd31e":"# This code partially supports k-fold training, \n# you can specify the fold to train and the total number of folds here\nFOLD = 0\nN_FOLDS = 5\n\nkf = KFold(n_splits=N_FOLDS, random_state=42, shuffle=True)\nsplits = kf.split(image_df) # ideally, this should be multilabel stratification\n\ndef get_fold():    \n    for i, (train_index, valid_index) in enumerate(splits):\n        if i == FOLD:\n            return image_df.iloc[train_index], image_df.iloc[valid_index]\n        \ntrain_df, valid_df = get_fold()\n\ntrain_dataset = FashionDataset(train_df)\ntrain_dataset.prepare()\n\nvalid_dataset = FashionDataset(valid_df)\nvalid_dataset.prepare()","6c6abe21":"train_segments = np.concatenate(train_df['AttributeId'].values).astype(int)\nprint(\"Total train images: \", len(train_df))\nprint(\"Total train segments: \", len(train_segments))\n\nplt.figure(figsize=(12, 3))\nvalues, counts = np.unique(train_segments, return_counts=True)\nplt.bar(values, counts)\nplt.xticks(values, label_names, rotation='vertical')\nplt.show()\n\nvalid_segments = np.concatenate(valid_df['AttributeId'].values).astype(int)\nprint(\"Total train images: \", len(valid_df))\nprint(\"Total validation segments: \", len(valid_segments))\n\nplt.figure(figsize=(12, 3))\nvalues, counts = np.unique(valid_segments, return_counts=True)\nplt.bar(values, counts)\nplt.xticks(values, label_names, rotation='vertical')\nplt.show()","613356e3":"#the model is trained on epoches 8","b464646a":"# Note that any hyperparameters here, such as LR, may still not be optimal\nLR = 1e-4\nEPOCHS = [2, 6, 8]\n\nimport warnings \nwarnings.filterwarnings(\"ignore\")","0100b4f6":"COCO_WEIGHTS_PATH = '\/kaggle\/working\/mask_rcnn_fashion_0002.h5'","066e8559":"print(os.listdir('\/kaggle\/working'))","9c49f719":"model = modellib.MaskRCNN(mode='training', config=config, model_dir=ROOT_DIR)\n\nmodel.load_weights(COCO_WEIGHTS_PATH, by_name=True, exclude=[\n    'mrcnn_class_logits', 'mrcnn_bbox_fc', 'mrcnn_bbox', 'mrcnn_mask'])","b739d0ab":"augmentation = iaa.Sequential([\n    iaa.Fliplr(0.5) # only horizontal flip here\n])","dabe2ff1":"image.size","36c13ea3":"%%time\nmodel.train(train_dataset, valid_dataset,\n            learning_rate=LR*2, # train heads with higher lr to speedup learning\n            epochs=EPOCHS[0],\n            layers='heads',\n            augmentation=None)\n\nhistory = model.keras_model.history.history","df37a5d5":"#import os\n#!cp '.\/fashion20200822T0408\/mask_rcnn_fashion_0002.h5' '.\/' \nprint(os.listdir('.\/'))","30dbbc74":"%%time\nmodel.train(train_dataset, valid_dataset,\n            learning_rate=LR,\n            epochs=2,\n            layers='all',\n            augmentation=augmentation)\n\nnew_history = model.keras_model.history.history\n#for k in new_history: history[k] = history[k] + new_history[k]","57e9a282":"import os\n!cp '.\/fashion20200822T0408\/mask_rcnn_fashion_0006.h5' '.\/' \nprint(os.listdir('.\/'))","e388e9ca":"#!cp '\/kaggle\/working\/fashion*\/mask_rcnn_fashion_0006.h5' '.\/'\n#print(os.listdir('.\/'))","e2df5c13":"%%time\nmodel.train(train_dataset, valid_dataset,\n            learning_rate=LR\/5,\n            epochs=EPOCHS[2],\n            layers='all',\n            augmentation=augmentation)\n\nnew_history = model.keras_model.history.history\nfor k in new_history: history[k] = history[k] + new_history[k]","877d34be":"epochs = range(EPOCHS[-1])\n\nplt.figure(figsize=(18, 6))\n\nplt.subplot(131)\nplt.plot(epochs, history['loss'], label=\"train loss\")\nplt.plot(epochs, history['val_loss'], label=\"valid loss\")\nplt.legend()\nplt.subplot(132)\nplt.plot(epochs, history['mrcnn_class_loss'], label=\"train class loss\")\nplt.plot(epochs, history['val_mrcnn_class_loss'], label=\"valid class loss\")\nplt.legend()\nplt.subplot(133)\nplt.plot(epochs, history['mrcnn_mask_loss'], label=\"train mask loss\")\nplt.plot(epochs, history['val_mrcnn_mask_loss'], label=\"valid mask loss\")\nplt.legend()\n\nplt.show()","6dd1ae6b":"best_epoch = np.argmin(history[\"val_loss\"]) + 1\nprint(\"Best epoch: \", best_epoch)\nprint(\"Valid loss: \", history[\"val_loss\"][best_epoch-1])","b0f09139":"glob_list = glob.glob(f'\/kaggle\/working\/fashion*\/mask_rcnn_fashion_{best_epoch:04d}.h5')\nmodel_path = glob_list[0] if glob_list else ''","2cfb292c":"model_path = '..\/input\/imat2019-weights\/mask_rcnn_fashion_0008.h5'","a452a4e3":"model_path","b1ac48ab":"class InferenceConfig(FashionConfig):\n    GPU_COUNT = 1\n    IMAGES_PER_GPU = 1\n\ninference_config = InferenceConfig()\n\nmodel = modellib.MaskRCNN(mode='inference', \n                          config=inference_config,\n                          model_dir=ROOT_DIR)\n\nassert model_path != '', \"Provide path to trained weights\"\nprint(\"Loading weights from \", model_path)\nmodel.load_weights(model_path, by_name=True)","523ffe19":"model","cc93ceca":"with open('trained_MODEL_maskrcn_8k.pkl', 'wb') as fid:\n    pickle.dump(model, fid)    ","ecbfe3b2":"sample_df = pd.read_csv(DATA_DIR\/\"sample_submission.csv\")\nsample_df.head()","4ff2af2a":"# Convert data to run-length encoding\ndef to_rle(bits):\n    rle = []\n    pos = 0\n    for bit, group in itertools.groupby(bits):\n        group_list = list(group)\n        if bit:\n            rle.extend([pos, sum(group_list)])\n        pos += len(group_list)\n    return rle","5e3ec417":"# Since the submission system does not permit overlapped masks, we have to fix them\ndef refine_masks(masks, rois):\n    areas = np.sum(masks.reshape(-1, masks.shape[-1]), axis=0)\n    mask_index = np.argsort(areas)\n    union_mask = np.zeros(masks.shape[:-1], dtype=bool)\n    for m in mask_index:\n        masks[:, :, m] = np.logical_and(masks[:, :, m], np.logical_not(union_mask))\n        union_mask = np.logical_or(masks[:, :, m], union_mask)\n    for m in range(masks.shape[-1]):\n        mask_pos = np.where(masks[:, :, m]==True)\n        if np.any(mask_pos):\n            y1, x1 = np.min(mask_pos, axis=1)\n            y2, x2 = np.max(mask_pos, axis=1)\n            rois[m, :] = [y1, x1, y2, x2]\n    return masks, rois\n","62b2d4a6":"for i in range(3):\n    image_id = sample_df.sample()['ImageId'].values[0]\n    image_path = str(DATA_DIR\/'test'\/image_id)\n    \n    img = cv2.imread(image_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    \n    result = model.detect([resize_image(image_path)])\n    r = result[0]\n    \n    if r['masks'].size > 0:\n        masks = np.zeros((img.shape[0], img.shape[1], r['masks'].shape[-1]), dtype=np.uint8)\n        for m in range(r['masks'].shape[-1]):\n            masks[:, :, m] = cv2.resize(r['masks'][:, :, m].astype('uint8'), \n                                        (img.shape[1], img.shape[0]), interpolation=cv2.INTER_NEAREST)\n        \n        y_scale = img.shape[0]\/IMAGE_SIZE\n        x_scale = img.shape[1]\/IMAGE_SIZE\n        rois = (r['rois'] * [y_scale, x_scale, y_scale, x_scale]).astype(int)\n        \n        masks, rois = refine_masks(masks, rois)\n    else:\n        masks, rois = r['masks'], r['rois']\n        \n    visualize.display_instances(img, rois, masks, r['class_ids'], \n                                ['bg']+label_names, r['scores'],\n                                title=image_id, figsize=(12, 12))","b69a8e8a":"Welcome to the world where fashion meets computer vision! This is a starter kernel that applies Mask R-CNN with COCO pretrained weights to the task of [iMaterialist (Fashion) 2019 at FGVC6](https:\/\/www.kaggle.com\/c\/imaterialist-fashion-2019-FGVC6).","f1f28f5b":"Afterwards, we reduce LR and train again.","1798da15":"# Train","810102d7":"Rows with the same image are grouped together because the subsequent operations perform in an image level.","6e4de209":"The crucial part is to create a dataset for this task.","b11b3dc5":"Segments that contain attributes are only 3.46% of data, and [according to the host](https:\/\/www.kaggle.com\/c\/imaterialist-fashion-2019-FGVC6\/discussion\/90643#523135), 80% of images have no attribute. So, in the first step, we can only deal with categories to reduce the complexity of the task.","63067d2e":"# Predict","41b047b0":"Let's visualize training history and choose the best epoch.","c0920f74":"Finally, it's pleasing to visualize the results! Sample images contain both fashion models and predictions from the Mask R-CNN model.","d5c6c2ac":"Let's visualize some random images and their masks.","2f91feed":"# Set Config","abda6340":"Mask R-CNN has a load of hyperparameters. I only adjust some of them.","2de01332":"# Dowload Libraries and Pretrained Weights","6f37214a":"# Make Datasets","2bc70d19":"This section creates a Mask R-CNN model and specifies augmentations to be used.","84f9ba80":"Then, load the submission data.","53a07d24":"Here is the main prediction steps, along with some helper functions.","4a4c586f":"Let's visualize class distributions of the train and validation data.","e9a7d1f6":"Now, the data are partitioned into train and validation sets.","5d230308":"This cell defines InferenceConfig and loads the best trained model.","ef6e1b37":"Then, all layers are trained.","f7786e4d":"The final step is to use our model to predict test data.","25e30fed":"The submission file is created, when all predictions are ready.","58abcae2":"First, we train only the heads."}}