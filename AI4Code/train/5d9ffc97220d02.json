{"cell_type":{"32d2bfd0":"code","4aeb7f44":"code","f287fad3":"code","4b512980":"code","dd30e5da":"code","49ca00da":"code","1139b1a8":"code","9cd9e614":"code","19670d8a":"code","a8156fdb":"code","d68ca96a":"markdown","d07b3561":"markdown","81bacbbc":"markdown","54a8a69c":"markdown","79516197":"markdown","b35fbbd3":"markdown","dea4a9fd":"markdown","637f9443":"markdown","37fed083":"markdown","0c30a421":"markdown","e104ff0d":"markdown"},"source":{"32d2bfd0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","4aeb7f44":"!pip install scanpy\nimport scanpy as sc\nimport anndata\n\nimport scipy \n\n\nimport time\nt0start = time.time()\n\nimport pandas as pd\nimport numpy as np\nimport os\nimport sys\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams['figure.dpi'] = 70\nplt.style.use('dark_background')\n\nimport seaborn as sns\n\nfrom sklearn.decomposition import PCA","f287fad3":"t0 = time.time() \n\nfn = '\/kaggle\/input\/rna-seq-data\/CHLA9\/CHLA9.txt'\nstr_data_inf = ' CHLA9 ' # set information string on data - will be used in titles of plots etc \nfn = '\/kaggle\/input\/rna-seq-data\/CHLA10\/CHLA10.txt'\nstr_data_inf = ' CHLA10 ' # set information string on data - will be used in titles of plots etc \nfn = '\/kaggle\/input\/rna-seq-data\/TC71\/TC71.txt'\nstr_data_inf = ' TC71 ' # set information string on data - will be used in titles of plots etc \n\nif fn.endswith('.txt'):\n    df = pd.read_csv(fn, sep = '\\t', index_col = 0)\n    df = df.T\n    display(df)\n    var = pd.DataFrame(index = df.columns)\n    obs = pd.DataFrame(index = df.index )\n    adata =  anndata.AnnData(df.values,  obs=obs, \n                         var=var ) #\n    #print('New non-sparse adata: ', adata)\n\nprint('Data loaded. ', np.round(time.time() - t0,1), 'seconds passed')\nif ('obs' in dir(adata) ) and ('n.umi' not in adata.obs.columns):\n    if ('obs' in dir(adata) ) and ('TotalUMIs' in  adata.obs.columns):\n        adata.obs['n.umi'] = adata.obs['TotalUMIs'] \n    elif np.sum(adata.X) == int( np.sum(adata.X) ) :\n        adata.obs['n.umi'] = adata.X.sum(axis = 1) \n\n\nadata_orig = adata.copy() \nprint(np.sum(adata.X))\nadata","4b512980":"v = np.asarray(adata.X.sum(axis = 0)).ravel()\nadata.var['Expression Sum'] = v\nv = np.asarray( (adata.X != 0) .sum(axis = 0)).ravel()\nadata.var['Count Expressed Cells'] = v\nadata.var.sort_values('Expression Sum',ascending = False ).head(30) # ['counts']","dd30e5da":"v = np.asarray(adata.X.sum(axis = 0)).ravel()\ndisplay(pd.Series(v).describe())\nv = np.log10(1+v)\nfig = plt.figure(figsize = (20,6)); c = 0\nc+=1; fig.add_subplot(1,2,c);\nplt.plot(np.sort(v)) \nplt.title('LOG10 Expression per gene')\nplt.xlabel('genes sorted')\nplt.ylabel('Log10 (1+Counts) ')\n\nc+=1; fig.add_subplot(1,2,c);\nplt.hist(np.sort(v), bins = 30) \nplt.title('LOG10 Expression per gene')\n\nplt.show()\n\npd.Series(v).describe()","49ca00da":"fig = plt.figure(figsize = (20,6)); c = 0\nc+=1; fig.add_subplot(1,2,c);\nv = np.asarray(adata.X.sum(axis = 1)).ravel() # adata.obs['n.umi']\nplt.plot(np.sort(v ),'*-') \nplt.title('Expression per cell')\nplt.xlabel('cells sorted')\nplt.ylabel('Expression Total')\n\nc+=1; fig.add_subplot(1,2,c);\nplt.hist(np.sort(v), bins = 100) \nplt.title('Expression per cell')\n\nplt.show()\n\npd.Series(v).describe()\n\n\nfig = plt.figure(figsize = (20,6)); c = 0\nc+=1; fig.add_subplot(1,2,c);\nv = np.asarray((adata.X != 0).sum(axis = 1)).ravel() # adata.obs['n.umi']\nplt.plot(np.sort(v ),'*-') \nplt.title('Count genes expressed per cell')\nplt.xlabel('cells sorted')\nplt.ylabel('Count expressed genes')\n\nc+=1; fig.add_subplot(1,2,c);\nplt.hist(np.sort(v), bins = 100) \nplt.title('Count genes expressed per cell')\n\nplt.show()\n\npd.Series(v).describe()","1139b1a8":"import scipy \n\nnumber_top_genes_to_consider = 10_000\nv = np.asarray(adata.X.sum(axis = 0 ) ).ravel()\nv.shape\nI = np.argsort(v)\nI = I[::-1]\nI = I[:number_top_genes_to_consider]\n\nmask = np.ones( adata.X.shape[0]).astype(bool) \nt0 = time.time()\nif scipy.sparse.issparse(adata.X):\n    corr_matr = np.corrcoef(adata[mask].X[:,I].toarray().T) # Hint - use numpy , pandas is MUCH SLOWER   (df.corr() )\nelse:\n    corr_matr = np.corrcoef(adata[mask].X[:,I].T) # Hint - use numpy , pandas is MUCH SLOWER   (df.corr() )\nprint('Calculated correlation matrix. Shape: ',corr_matr.shape,'  seconds passed:' , np.round( time.time() - t0,1) )\n\nprint()\nprint(np.min(corr_matr ), 'minimal correlation' )\ncorr_matr_abs = np.abs( corr_matr )\nprint(np.mean(corr_matr_abs ), 'average absolute correlation' )\nprint(np.median(corr_matr_abs), 'median absolute correlation' )\nprint(np.min(corr_matr_abs ), 'min absolute correlation' )\nprint(np.std(corr_matr_abs ), 'std absolute correlation' )\nprint()\n\nv = corr_matr.flatten()\nplt.figure(figsize=(14,8))\nt0 = time.time()\nplt.hist(v, bins = 50)\nplt.title('correlation coefficients distribution')\nplt.show()\nprint(time.time() - t0, 'seconds passed')\n\nprint(np.min(corr_matr ), 'minimal correlation' )\nprint(np.mean(corr_matr_abs ), 'average absolute correlation' )\nprint(np.median(corr_matr_abs), 'median absolute correlation' )\nprint(np.min(corr_matr_abs ), 'min absolute correlation' )\nprint(np.std(corr_matr_abs ), 'std absolute correlation' )\nfor t in [0.5,0.6, 0.7,0.8,0.9,0.95,0.97,0.98,.99]:\n    print( ((np.abs(v) < 0.99999999) & (np.abs(v) > t)).sum()\/2 , 'number of pairs correlated more than', t  )\nv.shape\n\nprint()\nprint()\nfor threshold_corr in [0.99,0.98,00.97,0.95,0.93,0.90,0.85,0.8,0.75,0.7,0.65,0.6,0.55,.5,0.45,0.4,0.35,0.3]: \n    a,b = np.where( np.triu(np.abs(corr_matr),1) > threshold_corr )\n    if len(a) > 50: break\nprint('for threshold:', threshold_corr,'we have ',len(a),' correlated pairs' )\n\n\nd = pd.DataFrame()\nfor i in range(len(a)):\n    Iai, Ibi =  I[a[i]], I[b[i]]\n    d.loc[i,'Gene1'] = adata[mask].var.index[Iai] \n    d.loc[i,'Gene2'] = adata[mask].var.index[Ibi ] \n    d.loc[i,'Correlation'] = corr_matr[a[i],b[i]] \n    d.loc[i,'Correlation Abs'] = np.abs(d.loc[i,'Correlation'] )\n    d.loc[i,'Gene1 Expression Sum'] = np.asarray(adata[mask].X[:,Iai].sum(axis = 0)).ravel()[0]\n    d.loc[i,'Gene2 Expression Sum'] = np.asarray(adata[mask].X[:,Ibi].sum(axis = 0)).ravel()[0]\n    \nprint(time.time() - t0, 'seconds passed')\n    \nd.sort_values('Correlation Abs',ascending = False).head(30)","9cd9e614":"import seaborn as sns\nt0 = time.time()\nsns.clustermap(np.abs(corr_matr[:3000,:3000]),cmap='vlag');\nprint( np.round(time.time()- t0,1), ' seconds passed.')","19670d8a":"import scipy\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.decomposition import PCA\nimport time\nt0 = time.time()\nif scipy.sparse.issparse(adata.X):\n    reducer = TruncatedSVD(n_components=2, n_iter=7, random_state=42)\nelse:\n    reducer = PCA(n_components=2)\n    \nr = reducer.fit_transform(adata.X)\n\nfig = plt.figure(figsize = (25,12))\nplt.title(str_data_inf + ' PCA  n_cells: ' + str(adata.X.shape[0]) +\\\n            ' n_genes: ' + str(adata.X.shape[1])  + ' '  , fontsize = 20   )#' \n\nif 'n.umi' not in adata.obs.columns: \n    ax = sns.scatterplot(x=r[:,0], y = r[:,1])#,  hue= color_by)#, palette = color_palette )#, palette = \"viridis\")# sns.color_palette(\"viridis\", as_cmap=True),\n                        #)# ,   alpha = 0.8, marker = '.')#, )#, legend=None)\nelse:\n    color_by = adata.obs['n.umi'].values\n    ax = sns.scatterplot(x=r[:,0], y = r[:,1],  hue= color_by)#, palette = color_palette )#, palette = \"viridis\")# sns.color_palette(\"viridis\", as_cmap=True),\n                        #)# ,   alpha = 0.8, marker = '.')#, )#, legend=None)\n    plt.setp(ax.get_legend().get_texts(), fontsize='20') # for legend text\n    plt.setp(ax.get_legend().get_title(), fontsize='20') # for legend title\nplt.xlabel('PCA1' , fontsize = 20 )\nplt.ylabel('PCA2' , fontsize = 20 )\nplt.show()\nprint( np.round( time.time() - t0,1) , ' seconds passed ' )","a8156fdb":"import scipy\nimport umap \nt0 = time.time()\nreducer = umap.UMAP()\nr = reducer.fit_transform(adata.X)\n\nfig = plt.figure(figsize = (25,12))\nplt.title(str_data_inf + ' UMAP n_cells: ' + str(adata.X.shape[0]) +\\\n            ' n_genes: ' + str(adata.X.shape[1])  + ' '  , fontsize = 20   )#' \nif 'n.umi' not in adata.obs.columns: \n    ax = sns.scatterplot(x=r[:,0], y = r[:,1])#,  hue= color_by)#, palette = color_palette )#, palette = \"viridis\")# sns.color_palette(\"viridis\", as_cmap=True),\n                        #)# ,   alpha = 0.8, marker = '.')#, )#, legend=None)\nelse:\n    color_by = adata.obs['n.umi'].values\n    ax = sns.scatterplot(x=r[:,0], y = r[:,1],  hue= color_by)#, palette = color_palette )#, palette = \"viridis\")# sns.color_palette(\"viridis\", as_cmap=True),\n                        #)# ,   alpha = 0.8, marker = '.')#, )#, legend=None)\n    plt.setp(ax.get_legend().get_texts(), fontsize='20') # for legend text\n    plt.setp(ax.get_legend().get_title(), fontsize='20') # for legend title\n\nplt.xlabel('UMAP1' , fontsize = 20 )\nplt.ylabel('UMAP2' , fontsize = 20 )\nplt.show()\nprint( np.round( time.time() - t0,1) , ' seconds passed ' ) ","d68ca96a":"# EDA","d07b3561":"# Correlation analysis","81bacbbc":"# What is about ?\n\nLoad and EDA for scRNA-seq data.\n\nData:\nhttps:\/\/www.ncbi.nlm.nih.gov\/geo\/query\/acc.cgi?acc=GSE146221\n\nPaper:\nhttps:\/\/www.mdpi.com\/2072-6694\/12\/4\/948\/htm\nCancers 2020, 12(4), 948; https:\/\/doi.org\/10.3390\/cancers12040948\nReconstruction of Ewing Sarcoma Developmental Context from Mass-Scale Transcriptomics Reveals Characteristics of EWSR1-FLI1 Permissibility\nHenry E. Miller 1,2OrcID,Aparna Gorthi 1,2OrcID,Nicklas Bassani 2,Liesl A. Lawrence 1,2OrcID,Brian S. Iskra 1,2 andAlexander J. R. Bishop\n\n","54a8a69c":"# Load data ","79516197":"## Expression per cell","b35fbbd3":"## UMAP","dea4a9fd":"# Visualisation\n","637f9443":"# Import and install modules","37fed083":"## Expression per gene","0c30a421":"## PCA\n","e104ff0d":"## Show top expressed genes"}}