{"cell_type":{"2b077ccf":"code","dcb4afd2":"code","91187a9c":"code","f1b561cc":"code","d2b923c4":"code","a05bb01b":"code","4e0fcc40":"code","9db1878c":"code","02880b5c":"code","ae1cc701":"code","7c7a7361":"code","7f27bbb0":"code","d5e222da":"code","0c4cf058":"code","aa331022":"code","3a7d86aa":"code","184d9304":"code","1db87634":"code","5fe7f3b0":"code","842c84fb":"code","c478bb88":"code","dd885ad9":"code","74b57a38":"code","adcc9718":"code","388e77e9":"code","fe3b09d8":"code","6fa76871":"code","f9c8e5d9":"code","5911f3ce":"code","f53ba7a0":"code","810792b0":"code","0c368920":"code","0986a7a1":"code","8975d04b":"code","a7785d1c":"code","6a401487":"code","5c74d74b":"code","9ed0ee38":"code","87595811":"code","54dd4ba6":"code","5ff87f8c":"code","3ff6f55d":"code","fa02a52c":"code","93751c98":"code","529ceb65":"code","e99b9431":"code","8612545c":"code","95dfc18c":"code","405336ea":"code","9f786b73":"code","95cac66a":"code","1a4af5b5":"code","217d0ca5":"code","5af15a39":"code","b0294d45":"code","dbd8b300":"code","6c74d5d3":"code","67106e0e":"code","64685459":"code","2f7fc1f6":"code","4adb6e0e":"code","906ced07":"code","49462958":"code","a61a4763":"code","ab8a54bc":"code","47ca9df9":"code","1c63ccd2":"code","6052d75e":"code","a7854c13":"code","c7a05bc3":"code","44a5d831":"code","e52c6fc1":"code","695c86e7":"code","7fab17f9":"code","df10db1e":"code","67eabd33":"code","e789260b":"code","bbdd4076":"code","9044d87b":"code","d67e3ab8":"code","da95834e":"code","40e185e6":"code","bd478fc5":"code","72513f0b":"code","29274f5c":"code","7e54025b":"code","e63f5f0a":"code","504038fe":"code","1b994f95":"code","7f640a0c":"code","3bd43701":"code","8e57cbc1":"code","5d886e22":"code","c48c3664":"code","68443e70":"code","04c2cb54":"code","9e4d52d3":"code","4228907d":"code","5d068879":"code","221ff151":"code","a774b6e1":"code","97b31a87":"code","77f221e8":"code","6b6a402a":"code","da3fd62d":"code","5cd3a4a7":"code","1dc9d6ee":"code","1afbffaf":"code","c8550677":"code","17e3b40c":"code","8e9330df":"code","23b9c1cb":"code","a52d197a":"code","70c101ad":"code","8b95ae94":"code","64fcbf94":"code","c81591e0":"code","ee138c70":"code","435b0eb3":"code","446f069f":"code","95c901d1":"code","6fec0b3c":"code","9d39bc37":"code","b8ea35b7":"code","9104b6d1":"code","73401cbb":"code","12278416":"code","04447a43":"code","3559e926":"code","f5ec8344":"code","84bfff24":"code","94d1500d":"code","9ba6965d":"code","c842c161":"code","da355efb":"code","a845711c":"code","f8ae2e21":"code","99259d1d":"code","47f2f2f0":"code","5bd302ec":"code","5a8c6f65":"markdown","b92b2a6e":"markdown","40c1eb3d":"markdown","4cf87672":"markdown","a95da278":"markdown","83353fdc":"markdown","904c4f32":"markdown","711823a1":"markdown","759839f9":"markdown","c716e856":"markdown","d9e08624":"markdown","c98a54fd":"markdown","957da80b":"markdown","1a6bbc95":"markdown","7c473792":"markdown","837c5984":"markdown","94d9b477":"markdown","289078b4":"markdown","f4768596":"markdown","12b3daf1":"markdown","4d18af93":"markdown","cf284e7b":"markdown","52c5d3ea":"markdown","ba5045ca":"markdown","b44e89a0":"markdown","62738b7f":"markdown","8023e1b3":"markdown","4905c84f":"markdown","7acef7b7":"markdown","8348abad":"markdown","49f5dfdb":"markdown","12145318":"markdown","5fb22152":"markdown","5e7ef75b":"markdown"},"source":{"2b077ccf":"# import the basic libraries we will use in this kernel\nimport os\nimport numpy as np\nimport pandas as pd\nimport pickle\n\nimport time\nimport datetime\nfrom datetime import datetime\nimport calendar\n\nfrom sklearn import metrics\nfrom math import sqrt\n\nimport matplotlib\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom string import punctuation\n\nfrom xgboost import XGBRegressor\nfrom xgboost import plot_importance\n\nfrom sklearn.preprocessing import LabelEncoder\n\nimport itertools\nimport warnings\n\nwarnings.filterwarnings(\"ignore\") # specify to ignore warning messages","dcb4afd2":"# Resample the sales by this parameter\nPERIOD = \"M\"\n\nPATH_DATA = \"..\/input\/nuclio08-dsc-0921\"","91187a9c":"# load all the df we have\nshops_df = pd.read_csv(os.path.join(PATH_DATA, \"shops.csv\"))\nitems_df = pd.read_csv(os.path.join(PATH_DATA, \"items.csv\"))\nitems_category_df = pd.read_csv(os.path.join(PATH_DATA, \"item_categories.csv\"))\nsales_df = pd.read_csv(os.path.join(PATH_DATA, \"sales_train.csv\"))","f1b561cc":"city_dict = {\n    2 : 'Adygea',\n    3 : 'Balashikha',\n    4 : 'Volzhski',\n    5 : 'Vlogda',\n    6 : 'Voronezh',\n    7 : 'Voronezh',\n    8 : 'Voronezh',\n    9 : 'Comercio Ambulante',\n    11 : 'Zhukovsky',\n    12 : 'Tienda Online',\n    13 : 'Kazan',\n    14 : 'Kazan',\n    15 : 'Kaluga',\n    16 : 'Kolomna',\n    17 : 'Krasnoyarsk',\n    18 : 'Krasnoyarsk',\n    19 : 'Kursk',\n    20 : 'Mosc\u00fa',\n    21 : 'Mosc\u00fa',\n    22 : 'Mosc\u00fa',\n    24 : 'Mosc\u00fa',\n    25 : 'Mosc\u00fa',\n    26 : 'Mosc\u00fa',\n    27 : 'Mosc\u00fa',\n    28 : 'Mosc\u00fa',\n    29 : 'Mosc\u00fa',\n    30 : 'Mosc\u00fa',\n    31 : 'Mosc\u00fa',\n    32 : 'Mosc\u00fa',\n    33 : 'Mytishchi',\n    34 : 'Nizhny Novgorod',\n    35 : 'Nizhny Novgorod',\n    36 : 'Novosibirsk',\n    37 : 'Novosibirsk',\n    38 : 'Omsk',\n    39 : 'Rostov Na Donu',\n    40 : 'Rostov Na Donu',\n    41 : 'Rostov Na Donu',\n    42 : 'San Petersburgo',\n    43 : 'San Petersburgo',\n    44 : 'Samara',\n    45 : 'Samara',\n    46 : 'Posad',\n    47 : 'Surgut',\n    48 : 'Tomsk',\n    49 : 'Tyumen',\n    50 : 'Tyumen',\n    51 : 'Tyumen',\n    52 : 'Ufa',\n    53 : 'Ufa',\n    54 : 'Khimki',\n    55 : 'Tienda Online',\n    56 : 'Checos',\n    57 : 'Yakutsk',\n    58 : 'Yakutsk',\n    59 : 'Yaroslavl'\n}","d2b923c4":"def fix_shops(shops, city_dict):\n    '''\n    This function modifies the shops df inplace.\n    It correct's 3 shops that we have found to be 'duplicates'\n    and also creates a few more features: extracts the city and encodes it using LabelEncoder\n    '''\n    shops = shops[~shops[\"shop_id\"].isin([0, 1, 10, 23])]\n\n    # replace all the punctuation in the shop_name columns\n    shops[\"shop_name_cleaned\"] = shops[\"shop_name\"].apply(lambda s: \"\".join([x for x in s if x not in punctuation]))\n    \n    # extract the city name\n    shops[\"city\"] = shops[\"shop_id\"].map(city_dict)\n    \n    # encode it using a simple LabelEncoder\n    shops[\"city_code\"] = LabelEncoder().fit_transform(shops['city'])\n    \n    return shops","a05bb01b":"shops_df.head()","4e0fcc40":"# we have seen in our EDA that we have some duplicate shops, let's correct them.\nshops_df = fix_shops(shops_df, city_dict)","9db1878c":"shops_df.head()","02880b5c":"pd.get_dummies(items_category_df[\"type\"].head())","ae1cc701":"items_category_df[\"type_code2\"] = LabelEncoder().fit_transform(items_category_df[\"type\"])","7c7a7361":"items_category_df.head()","7f27bbb0":"items_category_df['split'] = items_category_df['item_category_name'].str.split('-')\nitems_category_df['type'] = items_category_df['split'].map(lambda x: x[0].strip())\nitems_category_df['type_code'] = LabelEncoder().fit_transform(items_category_df['type'])\n\n# if subtype is nan then type\nitems_category_df['subtype'] = items_category_df['split'].map(lambda x: x[1].strip() if len(x) > 1 else x[0].strip())\nitems_category_df['subtype_code'] = LabelEncoder().fit_transform(items_category_df['subtype'])\n\nitems_category_df.head()","d5e222da":"sales_df.shape","0c4cf058":"sales_df = sales_df[sales_df[\"item_price\"] < np.percentile(sales_df[\"item_price\"], q = 100)]\nsales_df = sales_df[sales_df[\"item_cnt_day\"] < np.percentile(sales_df[\"item_cnt_day\"], q = 100)]","aa331022":"sales_df.shape","3a7d86aa":"sales_df.info()","184d9304":"type(sales_df[\"date\"].iloc[0])","1db87634":"# convert to datetime the date column\n# specify the format since otherwise it might give some problems\nsales_df[\"date\"] = pd.to_datetime(sales_df[\"date\"], format = \"%d.%m.%Y\")","5fe7f3b0":"min_date = sales_df[\"date\"].min()\nmax_date_sales = sales_df[\"date\"].max()","842c84fb":"max_date_sales","c478bb88":"# how to create a new date\nmax_date_test = datetime(2015, 10, 31)","dd885ad9":"# create a date range that begins with the first sale and ends with the last day from our max_date_test\ndate_range = pd.date_range(min_date, max_date_sales, freq = \"D\")\ndate_range","74b57a38":"len(date_range)","adcc9718":"shops = sorted(list(sales_df[\"shop_id\"].unique()))\n\n# only items present in test\nitems = sorted(list(sales_df[\"item_id\"].unique()))","388e77e9":"len(pd.MultiIndex.from_product([shops, items, date_range]))","fe3b09d8":"\ncartesian_product = pd.MultiIndex.from_product([date_range, shops, items], names = [\"date\", \"shop_id\", \"item_id\"])\nlen(cartesian_product)","6fa76871":"date_range = pd.date_range(min_date, max_date_test, freq = PERIOD)\nprint(\"We have a total of {} months\".format(len(date_range)))\ndate_range","f9c8e5d9":"cartesian_product = pd.MultiIndex.from_product([date_range, shops, items], names = [\"date\", \"shop_id\", \"item_id\"])\nlen(cartesian_product)","5911f3ce":"cartesian_product.to_frame().head()","f53ba7a0":"sales_df.info()","810792b0":"sales_df.set_index(\"date\").resample(\"Y\")[\"item_cnt_day\"].sum()","0c368920":"gb_df = sales_df.set_index(\"date\").groupby([\"shop_id\", \"item_id\"]).resample(PERIOD).agg(\n    {\n        \"item_cnt_day\":np.sum,\n        \"item_price\":np.mean, # precio medio\n        \"revenue\":np.sum\n    }\n)","0986a7a1":"gb_df.head()","8975d04b":"sales_df[\"revenue\"] = sales_df[\"item_price\"] * sales_df[\"item_cnt_day\"]\n\nsales_df.head()","a7785d1c":"gb_df.to_pickle(\"GROUP_BY_DF.pkl\")","6a401487":"if not os.path.isfile(os.path.join(PATH_DATA, \"GROUP_BY_DF.pkl\")):\n    st = time.time()\n\n    # # set index\n    sales_df[\"revenue\"] = sales_df[\"item_cnt_day\"]*sales_df[\"item_price\"]\n    gb_df = sales_df.set_index(\"date\")\n\n    # # groupby shop_id and item_id\n    gb_df = gb_df.groupby([\"shop_id\", \"item_id\"])\n\n    # # resample the sales to a weekly basis\n    gb_df = gb_df.resample(PERIOD).agg({'item_cnt_day':np.sum, \"item_price\":np.mean, \"revenue\":np.sum})\n\n    # # convert to dataframe and save the full dataframe\n    gb_df.reset_index(inplace = True)\n\n    # # save the groupby dataframe\n    gb_df.to_pickle(\"GROUP_BY_DF.pkl\")\n\n    et = time.time()\n\n    print(\"Total time in minutes to preprocess took {}\".format((et - st)\/60))\n    \n    gb_df = pd.read_pickle(\"GROUP_BY_DF.pkl\")\n    \nelse:\n    gb_df = pd.read_pickle(os.path.join(PATH_DATA, \"GROUP_BY_DF.pkl\"))","5c74d74b":"\".\/GROUP_BY_DF.pkl\"","9ed0ee38":"PATH_DATA","87595811":"gb_df.head()","54dd4ba6":"full_df = pd.DataFrame(index = cartesian_product).reset_index()","5ff87f8c":"full_df.head()","3ff6f55d":"print(full_df.shape)\nfull_df.head()","fa02a52c":"print(gb_df.shape)\ngb_df.head()","93751c98":"full_df = pd.merge(\n    left = full_df,\n    right = gb_df,\n    on = [\"date\", \"shop_id\", \"item_id\"],\n    how = \"left\"\n)","529ceb65":"(20 - 18) ** 2","e99b9431":"(20 - 0) ** 2","8612545c":"(1305 - 1) ** 2","95dfc18c":"np.clip([-3, 3, 35], 0, 20)","405336ea":"full_df[\"item_cnt_day\"].describe()","9f786b73":"pd.Series(np.clip(full_df[\"item_cnt_day\"], a_min = 0, a_max = 20)).describe()","95cac66a":"full_df.head()","1a4af5b5":"# full_df = pd.merge(full_df, gb_df, on = ['date','shop_id', \"item_id\"], how = 'left')\n\nfull_df[\"item_cnt_day\"] = np.clip(full_df[\"item_cnt_day\"], 0, 20)","217d0ca5":"print(full_df.shape)","5af15a39":"test_index = pd.read_csv(os.path.join(PATH_DATA, \"sales_test_no_data.csv\"))","b0294d45":"test_index.shape","dbd8b300":"test_index.head()","6c74d5d3":"print(full_df.shape)\nfull_df[\"unique_id\"] = full_df[\"shop_id\"].map(str) + \"-\" + full_df[\"item_id\"].map(str)\nfull_df = full_df[full_df[\"unique_id\"].isin(test_index[\"unique_id\"].unique())]\nprint(full_df.shape)\nfull_df.head()","67106e0e":"full_df[\"item_cnt_day\"].fillna(0, inplace = True)\nfull_df[\"revenue\"].fillna(0, inplace = True)","64685459":"series_ = full_df[\n    (full_df[\"shop_id\"] == 6) &\n    (full_df[\"item_id\"] == 31)\n]\n# series_.fillna(series_[\"item_price\"].mean())\nseries_.ffill().backfill()","2f7fc1f6":"full_df.isnull().sum()","4adb6e0e":"full_df[\"item_price\"] = full_df.groupby([\"shop_id\", \"item_id\"])[\"item_price\"].backfill()","906ced07":"full_df[\"item_price\"] = full_df.groupby([\"shop_id\", \"item_id\"])[\"item_price\"].ffill()","49462958":"full_df[\"item_price\"].fillna(0, inplace = True)","a61a4763":"full_df.isnull().sum()","ab8a54bc":"full_df[full_df[\"item_price\"].isnull()].head()","47ca9df9":"full_df.head()","1c63ccd2":"# full_df[\"item_price\"] = full_df.groupby([\"shop_id\", \"item_id\"])[\"item_price\"].backfill().ffill()","6052d75e":"full_df.isnull().sum()","a7854c13":"full_df[\"item_price\"] = full_df.groupby([\"shop_id\", \"item_id\"])[\"item_price\"].backfill().ffill()\n# full_df[\"item_price\"].backfill()","c7a05bc3":"full_df.head()","44a5d831":"full_df.isnull().sum()","e52c6fc1":"# filter only items present in test.\nfull_df[\"unique_id\"] = full_df[\"shop_id\"].map(str) + \"-\" + full_df[\"item_id\"].map(str)\nfull_df = full_df[full_df[\"unique_id\"].isin(test_index[\"unique_id\"].unique())]","695c86e7":"print(full_df.shape)","7fab17f9":"full_df.head()","df10db1e":"full_df.tail()","67eabd33":"# add shops_df information\nfull_df = pd.merge(full_df, shops_df, on = \"shop_id\", how = \"left\")\nfull_df.head()","e789260b":"# add items_df information\nfull_df = pd.merge(full_df, items_df, on = \"item_id\", how = \"left\")\nfull_df.head()","bbdd4076":"full_df.drop(columns = \"type_code2\", axis = 1, inplace = True)","9044d87b":"# add items_category_df information\nfull_df = pd.merge(full_df, items_category_df, on = \"item_category_id\", how = \"left\")\nfull_df.head()","d67e3ab8":"full_df.isnull().sum()[full_df.isnull().sum() > 0]","da95834e":"full_df[\"item_cnt_day\"].fillna(0, inplace = True)\nfull_df[\"revenue\"].fillna(0, inplace = True)","40e185e6":"'''\nfull_df[\"item_price\"] = full_df.groupby([\"shop_id\", \"item_id\"])\\\n.apply(lambda x: x.item_price.bfill()).reset_index(drop = True)\n\nfull_df[\"item_price\"] = full_df.groupby([\"shop_id\", \"item_id\"])\\\n.apply(lambda x: x.item_price.ffill()).reset_index(drop = True)\n'''","bd478fc5":"# full_df.isnull().sum()","72513f0b":"# full_df[\"item_price\"].fillna(0, inplace = True)","29274f5c":"class FeatureGenerator(object):\n    \n    '''\n    This is a helper class that takes a df and a list of features and creates sum, mean, \n    lag features and variation (change over month) features.\n    \n    '''\n    \n    def __init__(self, full_df,  gb_list):\n        \n        '''\n        Constructor of the class.\n        gb_list is a list of columns that must be in full_df.\n        '''\n        \n        self.full_df = full_df\n        self.gb_list = gb_list\n        # joins the gb_list, this way we can dinamically create new columns\n        # [\"date, \"shop_id] --> date_shop_id\n        self.objective_column_name = \"_\".join(gb_list)\n            \n    def generate_gb_df(self):\n        \n        '''\n        This function thakes the full_df and creates a groupby df based on the gb_list.\n        It creates 2 columns: \n            1. A sum column for every date and gb_list\n            2. Mean columns for every_date and gb_list\n            \n        The resulting df (gb_df_) is assigned back to the FeatureGenerator class as an attribute.\n        '''\n\n        def my_agg(full_df_, args):\n            \n            '''\n            This function is used to perform multiple operations over a groupby df and returns a df\n            without multiindex.\n            '''\n            \n            names = {\n                # you can put here as many columns as you want \n                '{}_sum'.format(args):  full_df_['item_cnt_day'].sum()\n            }\n\n            return pd.Series(names, index = [key for key in names.keys()])\n        \n        # the args is used to pass additional argument to the apply function\n        gb_df_ = self.full_df.groupby(self.gb_list).apply(my_agg, args = (self.objective_column_name)).reset_index()\n\n        self.gb_df_ = gb_df_\n\n        \n    def return_gb_df(self):  \n        \n        '''\n        This function takes the gb_df_ created in the previous step (generate_gb_df) and creates additional features.\n        We create 3 lag features (values from the past).\n        And 6 variation features: 3 with absolute values and 3 with porcentual change.\n        '''\n        \n        def generate_shift_features(self, suffix):\n            \n            '''\n            This function is a helper function that takes the gb_df_ and a suffix (sum or mean) and creates the\n            additional features.\n            '''\n\n            # dinamically creates the features\n            # date_shop_id --> date_shop_id_sum if suffix is sum\n            # date_shop_id --> date_shop_id_mean if suffix is mean\n            name_ = self.objective_column_name + \"_\" + suffix\n\n            self.gb_df_['{}_shift_1'.format(name_)] =\\\n            self.gb_df_.groupby(self.gb_list[1:])[name_].transform(lambda x: x.shift(1))\n            \n            self.gb_df_['{}_shift_2'.format(name_)] =\\\n            self.gb_df_.groupby(self.gb_list[1:])[name_].transform(lambda x: x.shift(2))\n            \n            self.gb_df_['{}_shift_3'.format(name_)] =\\\n            self.gb_df_.groupby(self.gb_list[1:])[name_].transform(lambda x: x.shift(3))\n\n            self.gb_df_['{}_var_pct_1'.format(name_)] =\\\n            self.gb_df_.groupby(self.gb_list[1:])[name_].transform(lambda x: (x.shift(1) - x.shift(2))\/x.shift(2))\n            \n            self.gb_df_['{}_var_pct_2'.format(name_)] =\\\n            self.gb_df_.groupby(self.gb_list[1:])[name_].transform(lambda x: (x.shift(1) - x.shift(3))\/x.shift(3))\n            \n            self.gb_df_['{}_var_pct_3'.format(name_)] =\\\n            self.gb_df_.groupby(self.gb_list[1:])[name_].transform(lambda x: (x.shift(1) - x.shift(4))\/x.shift(4))\n            \n            self.gb_df_.fillna(-1, inplace = True)\n\n            self.gb_df_.replace([np.inf, -np.inf], -1, inplace = True)\n        \n        # call the generate_shift_featues function with different suffix (sum and mean)\n        generate_shift_features(self, suffix = \"sum\")\n    \n        return self.gb_df_\n        ","7e54025b":"full_df.head()","e63f5f0a":"gb_df_ = full_df.groupby([\"shop_id\", \"item_id\"])\ngb_df_.get_group((6, 31)).head(1)","504038fe":"df_ = gb_df_[\"item_cnt_day\"].sum()","1b994f95":"gb_df_[\"item_cnt_day\"].sum()","7f640a0c":"gb_df_[\"\"]","3bd43701":"full_df.head()","8e57cbc1":"st = time.time()\n\ngb_list = [\"date\", \"shop_id\", \"city\"]\n\nfe_generator = FeatureGenerator(full_df = full_df, gb_list = gb_list)\n\nfe_generator.generate_gb_df()\n\nshop_sales_features = fe_generator.return_gb_df()\n\nshop_sales_features.drop(\"city\", axis = 1, inplace = True)\net = time.time()\n\n(et - st)\/60","5d886e22":"shop_sales_features.shape","c48c3664":"shop_sales_features[shop_sales_features[\"shop_id\"] == 15].head(5)","68443e70":"def generate_gb_df(full_df_, gb_list):\n\n    '''\n    This function thakes the full_df and creates a groupby df based on the gb_list.\n    It creates 2 columns: \n        1. A sum column for every date and gb_list\n        2. Mean columns for every_date and gb_list\n\n    The resulting df (gb_df_) is assigned back to the FeatureGenerator class as an attribute.\n    '''\n    objective_column_name = \"_\".join(gb_list)\n    \n    def my_agg(full_df_, args):\n\n        '''\n        This function is used to perform multiple operations over a groupby df and returns a df\n        without multiindex.\n        '''\n\n        names = {\n            # you can put here as many columns as you want \n            '{}_sum'.format(args):  full_df_['item_cnt_day'].sum()\n        }\n\n        return pd.Series(names, index = [key for key in names.keys()])\n\n    # the args is used to pass additional argument to the apply function\n    gb_df_ = full_df_.groupby(gb_list).apply(my_agg, args = (objective_column_name)).reset_index()\n\n    return gb_df_\n\ndef return_gb_df(gb_df_, gb_list, suffix = \"sum\"):  \n\n    # dinamically creates the features\n    # date_shop_id --> date_shop_id_sum if suffix is sum\n    # date_shop_id --> date_shop_id_mean if suffix is mean\n    \n    objective_column_name = \"_\".join(gb_list)\n    name_ = objective_column_name + \"_\" + suffix\n\n    gb_df_['{}_shift_1'.format(name_)] =\\\n    gb_df_.groupby(gb_list[1:])[name_].transform(lambda x: x.shift(1))\n    \n    gb_df_['{}_shift_2'.format(name_)] =\\\n    gb_df_.groupby(gb_list[1:])[name_].transform(lambda x: x.shift(2))\n\n    gb_df_['{}_shift_3'.format(name_)] =\\\n    gb_df_.groupby(gb_list[1:])[name_].transform(lambda x: x.shift(3))\n\n    gb_df_['{}_var_pct_1'.format(name_)] =\\\n    gb_df_.groupby(gb_list[1:])[name_].transform(lambda x: (x.shift(1) - x.shift(2))\/x.shift(2))\n\n    gb_df_['{}_var_pct_2'.format(name_)] =\\\n    gb_df_.groupby(gb_list[1:])[name_].transform(lambda x: (x.shift(1) - x.shift(3))\/x.shift(3))\n\n    gb_df_['{}_var_pct_3'.format(name_)] =\\\n    gb_df_.groupby(gb_list[1:])[name_].transform(lambda x: (x.shift(1) - x.shift(4))\/x.shift(4))\n\n    gb_df_.fillna(-1, inplace = True)\n\n    gb_df_.replace([np.inf, -np.inf], -1, inplace = True)\n        \n    return gb_df_\n\ngb_list = [\"date\", \"shop_id\", \"city\"]\n\ngb_df_ = generate_gb_df(full_df_ = full_df, gb_list = gb_list)\ngb_df_features_ = return_gb_df(gb_df_ = gb_df_, gb_list = gb_list)\ngb_df_features_.drop(\"city\", axis = 1, inplace = True)\n\ngb_df_features_.head()","04c2cb54":"gb_df_features_.sum()","9e4d52d3":"shop_sales_features.sum()","4228907d":"# compare 2 dataframes to see if they are equal\nshop_sales_features.equals(gb_df_features_)","5d068879":"full_df.rename(columns = {\"sales\":\"item_cnt_day\"}, inplace = True)","221ff151":"st = time.time()\n\ngb_list = [\"date\", \"item_id\"]\n\nfe_generator = FeatureGenerator(full_df = full_df, gb_list = gb_list)\n\nfe_generator.generate_gb_df()\n\nitem_id_features = fe_generator.return_gb_df()\n\net = time.time()\n\n(et - st)\/60","a774b6e1":"st = time.time()\n\ngb_list = [\"date\", \"item_category_id\"]\n\nfe_generator = FeatureGenerator(full_df = full_df, gb_list = gb_list)\n\nfe_generator.generate_gb_df()\n\nmonth_item_category_features = fe_generator.return_gb_df()\n\net = time.time()\n\n(et - st)\/60","97b31a87":"month_item_category_features.shape","77f221e8":"month_item_category_features[month_item_category_features[\"item_category_id\"] == 2].head(3)","6b6a402a":"full_df[\"year\"] = full_df[\"date\"].dt.year\nfull_df[\"month\"] = full_df[\"date\"].dt.month\nfull_df[\"days_in_month\"] = full_df[\"date\"].dt.days_in_month","da3fd62d":"holidays_this_month = {\n    1:8,\n    2:1,\n    3:1,\n    4:0,\n    5:2,\n    6:1,\n    7:0,\n    8:0,\n    9:0,\n    10:0,\n    11:1,\n    12:0\n}\n\nfull_df[\"holidays_this_month\"] = full_df[\"month\"].map(holidays_this_month)","5cd3a4a7":"def extract_number_weekends(test_month):\n    '''\n    Extracts the number of weekend days in a month.\n    '''\n    saturdays = len([1 for i in calendar.monthcalendar(test_month.year, test_month.month) if i[5] != 0])\n    sundays = len([1 for i in calendar.monthcalendar(test_month.year, test_month.month) if i[6] != 0])\n    \n    return saturdays + sundays\n\nfull_df[\"total_weekend_days\"] = full_df[\"date\"].apply(extract_number_weekends)","1dc9d6ee":"full_df.head()","1afbffaf":"print(\"Shape before merge is {}\".format(full_df.shape))\n\nfull_df = pd.merge(full_df, shop_sales_features, on = [\"date\", \"shop_id\"], how = \"left\")\nfull_df = pd.merge(full_df, month_item_category_features, on = [\"date\", \"item_category_id\"], how = \"left\")\nfull_df.rename(columns = {\"item_cnt_day\":\"sales\"}, inplace = True)\n\nprint(\"Shape after merge is {}\".format(full_df.shape))","c8550677":"full_df = pd.merge(full_df, item_id_features, on = [\"date\", \"item_id\"], how = \"left\")","17e3b40c":"print(\"Shape after merge is {}\".format(full_df.shape))","8e9330df":"# save the file\n\nst = time.time()\n\nfull_df.to_pickle(\"FULL_DF_ALL_FEATURES.pkl\")\n\net = time.time()\n(et - st)\/60","23b9c1cb":"# load the preprocessed data\nfull_df = pd.read_pickle(\"FULL_DF_ALL_FEATURES.pkl\")\nfull_df[\"sales\"] = np.clip(full_df[\"sales\"], 0, 20)\n\n# delete all the columns where lags features are - 1 (shift(3))\n# full_df = full_df[full_df[\"date\"] > np.datetime64(\"2013-03-31\")]","a52d197a":"cols_to_drop = [\n\n'revenue',\n'shop_name',\n\"shop_name_cleaned\",\n\"city\",\n'item_name',\n'item_category_name',\n'split',\n'type',\n'subtype',\n\"unique_id\",\n\n# \"date_shop_id_city_sum\",\n# \"date_item_category_id_sum\",\n    \n]\n\nfull_df.drop(cols_to_drop, inplace = True, axis = 1)","70c101ad":"full_df.head(3).T","8b95ae94":"# ------------------------------------------------------\n# separate the dates for train, validation and test\n\ntrain_index = sorted(list(full_df[\"date\"].unique()))[:-2] # train ventas hasta sept\n\nvalida_index = [sorted(list(full_df[\"date\"].unique()))[-2]] # sept\n\ntest_index = [sorted(list(full_df[\"date\"].unique()))[-1]] # mes de octubre","64fcbf94":"full_df.rename(columns = {\"item_cnt_day\":\"sales\"}, inplace = True)","c81591e0":"# ------------------------------------------------------\n# split the data into train, validation and test dataset\n# we \"simulate\" the test dataset to be the Kaggle test dataset\n\nX_train = full_df[full_df[\"date\"].isin(train_index)].drop(['sales', \"date\"], axis=1)\nY_train = full_df[full_df[\"date\"].isin(train_index)]['sales']\n\nX_valida = full_df[full_df[\"date\"].isin(valida_index)].drop(['sales', \"date\"], axis=1)\nY_valida = full_df[full_df[\"date\"].isin(valida_index)]['sales']\n\nX_test = full_df[full_df[\"date\"].isin(test_index)].drop(['sales', \"date\"], axis = 1)\nY_test = full_df[full_df[\"date\"].isin(test_index)]['sales']","ee138c70":"st = time.time()\n\nmodel = XGBRegressor(seed = 175)\n\nmodel_name = str(model).split(\"(\")[0]\n\nday = str(datetime.now()).split()[0].replace(\"-\", \"_\")\nhour = str(datetime.now()).split()[1].replace(\":\", \"_\").split(\".\")[0]\nt = str(day) + \"_\" + str(hour)\n\nmodel.fit(X_train, Y_train, eval_metric = \"rmse\", \n    eval_set = [(X_train, Y_train), (X_valida, Y_valida)], \n    verbose = True, \n    early_stopping_rounds = 10)\n\net = time.time()\n\nprint(\"Training took {} minutes!\".format((et - st)\/60))","435b0eb3":"pickle.dump(model, open(\"{}_{}.dat\".format(model_name, t), \"wb\"))","446f069f":"print(\"{}_{}.dat\".format(model_name, t))","95c901d1":"model = pickle.load(open(\"{}_{}.dat\".format(model_name, t), \"rb\"))","6fec0b3c":"importance = model.get_booster().get_score(importance_type = \"gain\")\nimportance = {k: v for k, v in sorted(importance.items(), key = lambda item: item[1])}\n\nfig, ax = plt.subplots(figsize = (10, 15))\nplot_importance(model, importance_type = \"gain\", ax = ax);","9d39bc37":"Y_valida_pred = model.predict(X_valida)\n\nrmse_valida = sqrt(metrics.mean_squared_error(Y_valida, Y_valida_pred))\nrmse_valida","b8ea35b7":"if \"sales_predicted\" in X_test.columns:\n    X_test.drop(\"sales_predicted\", axis = 1, inplace = True)\n    \nY_test_predict = model.predict(X_test)\nX_test[\"sales_predicted\"] = np.clip(Y_test_predict, 0, 20)\n","9104b6d1":"X_test.head()","73401cbb":"X_test[\"unique_id\"] = X_test[\"shop_id\"].map(str) + \"-\" + X_test[\"item_id\"].map(str)","12278416":"X_test_short = X_test[[\"unique_id\", \"sales_predicted\"]]","04447a43":"X_test_short.head()","3559e926":"test_index = pd.read_csv(os.path.join(PATH_DATA, \"sales_test_no_data.csv\"))\ntest_index[\"unique_id\"] = test_index[\"unique_id\"].map(str)","f5ec8344":"submission_file = pd.merge(test_index, X_test_short, left_on = \"unique_id\", right_on = \"unique_id\", how = \"left\")\nsubmission_file.drop(\"sales\", axis = 1, inplace = True)\nsubmission_file.rename(columns = {\"sales_predicted\":\"sales\"}, inplace = True)","84bfff24":"submission_file.head()","94d1500d":"submission_file.isnull().sum()","9ba6965d":"submission_file.to_csv(\"submission.csv\", index = False)","c842c161":"# code here","da355efb":"# code here","a845711c":"# code here","f8ae2e21":"# code here","99259d1d":"# code here","47f2f2f0":"# code here","5bd302ec":"# code here","5a8c6f65":"<a id = \"new_feature_3\"><\/a>\n# Additional feature 3\n[Go back to the table of contents](#table_of_contents)","b92b2a6e":"<a id = \"feature_5\"><\/a>\n## Datetime features\n[Go back to the table of contents](#table_of_contents)","40c1eb3d":"<a id = \"add_new_csvs\"><\/a>\n# Add additional features to our full sales df\n[Go back to the table of contents](#table_of_contents)","4cf87672":"<a id = \"feature_importance_1\"><\/a>\n# Feature importance\n[Go back to the table of contents](#table_of_contents)","a95da278":"<a id = \"new_feature_1\"><\/a>\n# Additional feature 1\n[Go back to the table of contents](#table_of_contents)","83353fdc":"<a id = \"create_new_features\"><\/a>\n# Generate additional features as, mean and total sales for shop_id , item_id, city ... for every month\n[Go back to the table of contents](#table_of_contents)","904c4f32":"<a id = \"only_functions\"><\/a>\n## Achieving the same result without clases\n[Go back to the table of contents](#table_of_contents)","711823a1":"<a id = \"table_of_contents\"><\/a>\n# Table of contents\n\n[Import of libraries](#imports)\n\n[Global variables](#global_variables)\n\n[Preprocessing before features generation](#preprocessing_before_fe)\n\n-->[Correct the shop names and id](#correct_shop_names_id)\n\n-->[Generate item_category_features](#generate_item_category_features)\n\n-->[Remove the huge price and item sales outliers](#remove_outliers)\n\n[Generate a full df with all data and records](#generate_full_df_with_all_records)\n\n[Join the full_df with gb_df](#join_dfs)\n\n[Add additional features to our full sales df](#add_new_csvs)\n\n[FeatureGenerator class](#fe_generator_class)\n\n[Generate additional features as, mean and total sales for shop_id , item_id, city ... for every month](#create_new_features)\n\n-->[Date and shop_id features](#feature_1)\n\n--->[Achieving the same result without clases](#only_functions)\n\n-->[Date and item_category features](#feature_3)\n\n-->[Datetime features](#feature_5)\n\n-->[Adding holidays](#feature_6)\n\n[Join full sales df with all the features generated](#join_dfs_with_features)\n\n[Basic model train](#basic_model)\n\n[Feature importance](#feature_importance_1)\n\n[Predict and model evaluation](#predict_and_model_evaluation_1)\n\n[Submission to Kaggle](#submission_kaggle)\n\n[To do](#to_do)\n\n-->[Additional feature 1](#new_feature_1)\n\n-->[Additional feature 2](#new_feature_2)\n\n-->[Additional feature 3](#new_feature_3)\n\n-->[Join df's with new features](#join_dfs_with_new_features)\n\n-->[Model training](#new_model)\n\n-->[Feature importance of new model](#feature_importance_2)\n\n-->[Predict and model evaluation of new model](#predict_and_model_evaluation_2)","759839f9":"<a id = \"correct_shop_names_id\"><\/a>\n## Correct the shop names and id\n[Go back to the table of contents](#table_of_contents)","c716e856":"<a id = \"submission_kaggle\"><\/a>\n# Submission to Kaggle\n[Go back to the table of contents](#table_of_contents)","d9e08624":"<a id = \"join_dfs_with_new_features\"><\/a>\n# Join df's with new features\n[Go back to the table of contents](#table_of_contents)","c98a54fd":"Now that we have the sales_df resampled by months, and we have created a cartesian product (all possible combinations of months, shop_id and item_id), let's merge the df.","957da80b":"<a id = \"join_dfs\"><\/a>\n# Join the full_df with gb_df\n[Go back to the table of contents](#table_of_contents)","1a6bbc95":"<a id = \"feature_3\"><\/a>\n## Date and item_category features\n[Go back to the table of contents](#table_of_contents)","7c473792":"<a id = \"feature_1\"><\/a>\n## Date and shop_id features\n[Go back to the table of contents](#table_of_contents)","837c5984":"<a id = \"fe_generator_class\"><\/a>\n# FeatureGenerator class\n[Go back to the table of contents](#table_of_contents)","94d9b477":"<a id = \"preprocessing_before_fe\"><\/a>\n# Preprocessing before features generation\n[Go back to the table of contents](#table_of_contents)","289078b4":"Our model will benefit a lot if we can train it with the highest granularity (daily sales).\n\nHowever, as we can see doing this on a local machine is almost impossible since we have almost 27 Million rows.","f4768596":"<a id = \"predict_and_model_evaluation_2\"><\/a>\n# Predict and model evaluation of new model\n[Go back to the table of contents](#table_of_contents)","12b3daf1":"<a id = \"basic_model\"><\/a>\n# Basic model train\n[Go back to the table of contents](#table_of_contents)","4d18af93":"The idea of this section is very simple. We have seen in our EDA part that there are a lot of missing values.\nOur model will benefit a lot if we can supply it a training data, with the missing values being zero. This way, it can learn from more amount of data.\n\nIn order to do so, we must perform a cartesian operation over dates x shops x items_id to generate all the possible combinations of months x shops and x items sales.\n\nIn this kernel we will only generate this type of features for the items that are present in TEST only.\n\nThis will reduce the amount of calculations required. If you have enough memory, we can do this for all possible combinations.","cf284e7b":"<a id = \"to_do\"><\/a>\n# To do\n[Go back to the table of contents](#table_of_contents)","52c5d3ea":"<a id = \"imports\"><\/a>\n# Import of libraries\n[Go back to the table of contents](#table_of_contents)","ba5045ca":"<a id = \"feature_6\"><\/a>\n## Adding holidays\n[Go back to the table of contents](#table_of_contents)","b44e89a0":"<a id = \"predict_and_model_evaluation_1\"><\/a>\n# Predict and model evaluation\n[Go back to the table of contents](#table_of_contents)","62738b7f":"<a id = \"generate_item_category_features\"><\/a>\n## Generate item_category_features\n[Go back to the table of contents](#table_of_contents)","8023e1b3":"<a id = \"remove_outliers\"><\/a>\n## Remove the huge price and item sales outliers\n[Go back to the table of contents](#table_of_contents)","4905c84f":"<a id = \"new_model\"><\/a>\n# Model training\n[Go back to the table of contents](#table_of_contents)","7acef7b7":"<a id = \"generate_full_df_with_all_records\"><\/a>\n# Generate a full df with all data and records\n[Go back to the table of contents](#table_of_contents)","8348abad":"<a id = \"new_feature_2\"><\/a>\n# Additional feature 2\n[Go back to the table of contents](#table_of_contents)","49f5dfdb":"Methods of a class can be viewed as functions but attached to a class (hence the self parameter).\n\nIf we extact the methods from FeatureGenerator and eliminame all the ***self*** parameter and add a ***return*** clase, we can easily convert the above methods to functions and use them as usually.","12145318":"<a id = \"feature_importance_2\"><\/a>\n# Feature importance of new model\n[Go back to the table of contents](#table_of_contents)","5fb22152":"<a id = \"join_dfs_with_features\"><\/a>\n# Join full sales df with all the features generated\n[Go back to the table of contents](#table_of_contents)","5e7ef75b":"<a id = \"global_variables\"><\/a>\n# Global variables\n[Go back to the table of contents](#table_of_contents)"}}