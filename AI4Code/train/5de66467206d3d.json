{"cell_type":{"3c40c22f":"code","6d153184":"code","a5912c7d":"code","fb0c3bb0":"code","7a11c65f":"code","7e4accb2":"code","8dce8fa8":"code","0e33a4c9":"code","c9edec68":"code","cc34e8a0":"code","0a46b753":"code","ec038fb2":"code","a36dc70e":"code","750e27f9":"code","85358798":"code","05cc15c5":"code","6f48f1ce":"markdown"},"source":{"3c40c22f":"import torch \nimport torch.nn as nn","6d153184":"import pandas as pd\ntrain_data=pd.read_csv('..\/input\/digit-recognizer\/train.csv')\ntrain_data","a5912c7d":"train_data=train_data.values\nX_train, y_train = train_data[:, 1:] , train_data[:, 0]\nX_train = X_train.reshape(X_train.shape[0], 1, 28, 28)\nX_train, y_train = torch.from_numpy(X_train).float(), torch.from_numpy(y_train).long()\ntrain_dataset = torch.utils.data.TensorDataset(X_train, y_train)\ntrain_loader = torch.utils.data.DataLoader(train_dataset, batch_size=128, shuffle=True)","fb0c3bb0":"class Image_classification(nn.Module):\n  def __init__(self):\n    super().__init__()\n    self.network=nn.Sequential(\n        nn.Conv2d(1,28,kernel_size=3,stride=1,padding=1),    #32x28x28\n        nn.ReLU(),\n        nn.Conv2d(28,64,kernel_size=3,stride=1,padding=1),   #64x28x28\n        nn.ReLU(),\n        nn.MaxPool2d(2,2) ,                                  #64x14x14\n        nn.Conv2d(64,128,kernel_size=3,stride=1,padding=1),  \n        nn.Flatten(),\n        nn.Linear(128*14*14,1024),\n        nn.ReLU(),\n        nn.Linear(1024,10)  )\n  def forward(self,x):\n    return self.network(x)  ","7a11c65f":"model_cnn=Image_classification()\nmodel_cnn","7e4accb2":"optimizer=torch.optim.SGD(model_cnn.parameters(),lr=1e-5)","8dce8fa8":"loss_fn=nn.CrossEntropyLoss()","0e33a4c9":"if torch.cuda.is_available():\n    model_cnn=model_cnn.cuda()","c9edec68":"%%time\nepochs=35\nfor epoch in range(epochs):\n    score=0\n    for batch in train_loader:\n        x,y=batch\n        if torch.cuda.is_available():\n            x=x.cuda()\n            y=y.cuda()\n        model_cnn.train()\n        #STEP-1: Forward\n        out=model_cnn(x)\n        \n        #STEP-2:Loss\n        loss=loss_fn(out,y)\n        \n        #Step-3:Cleaning the prev calculated gradients\n        model_cnn.zero_grad()\n        \n        #Step-4:Accumalate partial derivatives of Loss wrt to params\n        loss.backward()\n        \n        #Step-5: Takes 5 steps to update\n        optimizer.step()\n        _,pred=torch.max(out,axis=1)\n        score+=(pred==y).sum()\n    acc=score\/len(train_data)\n    print(\"{}\/{} Epochs | Train Loss={:.4f} |Accuracy={:.4f}\".format(epoch+1,epochs,loss,acc)  )","cc34e8a0":"import pandas as pd\ntest_data=pd.read_csv('..\/input\/digit-recognizer\/test.csv')\ntest_data","0a46b753":"try:\n    test_data=test_data.values\nexcept:\n    print(type(test_data),test_data.shape)","ec038fb2":"pred=[]\nfor i in range(len(test_data)):\n    img=test_data[i,:]\n    img=img.reshape(1,1,28,28)\n    img=torch.from_numpy(img).float()\n    model_cnn.eval()\n    if torch.cuda.is_available():\n        img=img.cuda()\n    output=model_cnn(img)\n    _,predicted = torch.max(output , 1)\n    pred.append(predicted.item())","a36dc70e":"len(pred)","750e27f9":"df=pd.read_csv('..\/input\/digit-recognizer\/sample_submission.csv')\ndf","85358798":"df['Label']=pred\ndf","05cc15c5":"df.to_csv('Submission.csv',index=False)","6f48f1ce":"# USING CONVOLUTIONAL NUERAL NETWORKS\n## Epochs: 35\n## Accuracy: 95.79%\n## Time Taken: 2min 9s (Using GPU)"}}