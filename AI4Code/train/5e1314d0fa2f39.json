{"cell_type":{"b595b5f5":"code","4899fea0":"code","dca6fa85":"code","8194762f":"code","25983612":"code","d086915b":"code","d89cab91":"code","56be6f74":"code","ddf4f701":"code","bf8aab4e":"code","9fc986f4":"code","c5413d2f":"code","0350f931":"code","a6038cb1":"code","a2c9a7a0":"code","613e438e":"code","64262646":"code","ad8248ff":"code","4173c3b5":"code","07969507":"code","18160ebe":"code","6372f284":"code","d5369236":"code","831e78df":"code","83757d16":"code","c04c3e3f":"code","ab15b2c2":"code","03bd564d":"code","1c40a65e":"code","ec2a0fb1":"code","b821467b":"code","c7240f93":"code","878473fa":"code","e0c2a2cf":"code","bd3240e0":"code","12a64127":"code","2de3e9d2":"code","ac2abaf9":"code","b1d7f5aa":"code","c2a5db0f":"code","deb2e483":"code","ba33259e":"code","f432b253":"code","657b9c8b":"code","21b97491":"code","ef6c3c8d":"code","7edef7d4":"markdown","7e88ea7c":"markdown","9625a580":"markdown","3148368a":"markdown","d8fbd6a6":"markdown","b20d6aa3":"markdown","b4cf65e6":"markdown","5e944fdf":"markdown","90ca5046":"markdown","2711bb02":"markdown","597f8dc8":"markdown","7be8f4f8":"markdown","59328b6d":"markdown","0d265d03":"markdown","e1daf3a5":"markdown","41f3bc7a":"markdown","2d3cf85a":"markdown","a17647ae":"markdown"},"source":{"b595b5f5":"'''We start by importing the data and having a look at the various features gathered for the problem'''\n\n# Importing the libraires\nimport pandas as pd\nimport numpy as np\nattrition = pd.read_csv(\"..\/input\/hr-attrition-dataset\/Final dataset Attrition.csv\")","4899fea0":"# Since the dataset is loaded we check a few details like\nattrition.head(10)","dca6fa85":"# Checking the columns wihtin the dataset\nattrition.columns","8194762f":"# checking the dimensions of the dataset\nattrition.shape ","25983612":"attrition.describe() ","d086915b":"# Checking whether the datset has any missing values within\nattrition.isna().sum() ","d89cab91":"# Category columns in the data\ncategory_cols = ['Attrition', 'BusinessTravel', 'Department', 'Gender', 'JobRole', 'MaritalStatus', 'OverTime', 'Higher_Education', 'Status_of_leaving', 'Mode_of_work', 'Work_accident', 'Source_of_Hire', 'Job_mode']","56be6f74":"from sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\nattrition[category_cols] = attrition[category_cols].apply(le.fit_transform)\nattrition","ddf4f701":"# removing\/ dropping the columns passenger id, Name, ticket, cabin\nattrition = attrition.drop([\"Date_of_Hire\", \"Date_of_termination\"], axis = 1)\nattrition","bf8aab4e":"# Lets check out some visualisation to get the insights on the data\ndf_company = attrition\n\nimport seaborn as sns \nimport matplotlib.pyplot as plt\ndef stacked_plot(df, group, target):\n    \"\"\"\n    Function to generate a stacked plots between two variables\n    \"\"\"\n    fig, ax = plt.subplots(figsize = (6,4))\n    temp_df = (df.groupby([group, target]).size()\/df.groupby(group)[target].count()).reset_index().pivot(columns=target, index=group, values=0)\n    temp_df.plot(kind = 'bar', stacked = True, ax = ax, color = [\"green\", \"darkred\"])\n    ax.xaxis.set_tick_params(rotation = 0)\n    ax.set_xlabel(group)\n    ax.set_ylabel('Attrition')\n","9fc986f4":"def Age(a):\n    if a <= 25:\n        return 1\n    elif a > 25 and a <= 32:\n        return 2\n    elif a > 32 and a <= 40:\n        return 3\n    elif a > 40 and a <= 50:\n        return 4\n    else:\n        return 5\n\ndf_company[\"Age_group\"] = df_company[\"Age\"].apply(lambda x: Age(x))\ndf_company[\"Age_group\"].value_counts()\nsns.countplot(x = \"Age_group\", hue = \"Attrition\", data = df_company)\n\n''' \nHaving a look at the plot which gives the relation between attrition and age group gives the insight that\nthe employees in the age group of under 25 tend to move faster and the ones within 25 and 32 also.\n'''\n","c5413d2f":"def DistanceFromHome(d):\n    if d <= 5:\n        return 1\n    elif d > 5 and d <= 10:\n        return 2\n    elif d > 10 and d <= 15:\n        return 3\n    elif d > 15 and d <= 20:\n        return 4\n    elif d > 20 and d <= 25:\n        return 5\n    else:\n        return 6\n    \ndf_company[\"DistanceFromHome_group\"] = df_company[\"DistanceFromHome\"].apply(lambda x: DistanceFromHome(x))\ndf_company[\"DistanceFromHome_group\"].value_counts()\nsns.countplot(x = \"DistanceFromHome_group\", hue=\"Attrition\", data = df_company)\n\n''' \nNow taking the relation between attrition and Distance from home gives the insight that \nthe employees with a farther distance from home tend to take a decision to attrite quite obviously.\n'''","0350f931":"def YearsAtCompany(t):\n    if t <= 1:\n        return 1\n    elif t > 1 and t <= 5:\n        return 2\n    elif t > 5 and t <= 10:\n        return 3\n    elif t > 10 and t <= 20:\n        return 4\n    elif t > 20 and t <= 30:\n        return 5\n    else:\n        return 6\n\ndf_company[\"YearsAtCompany\"] = df_company[\"YearsAtCompany\"].apply(lambda x:YearsAtCompany(x))\ndf_company[\"YearsAtCompany\"].value_counts()\nsns.countplot(x = \"YearsAtCompany\", hue = \"Attrition\", data = df_company)\n\n''' \nNow this interesting fact is very well known that the one year atrrition employees are \nknown as Jumpers but this does go against their profile, and then the most attritions \ntake place in the range of 1 to 5 years of employment.\n'''\n","a6038cb1":"from sklearn.preprocessing import MinMaxScaler as mms\nscale = mms() \nattrition_mms = pd.DataFrame(scale.fit_transform(attrition.iloc[:,:]))","a2c9a7a0":"attrition_mms.columns = attrition.columns","613e438e":"attrition","64262646":"attrition = attrition.drop(attrition.iloc[:, 30:31], axis = 1)","ad8248ff":"attrition","4173c3b5":"# We check the correlation of the various features\nattrition_mms.corr() ","07969507":"attrition_mms = attrition_mms.drop(attrition_mms.iloc[:, 30:31], axis = 1)\ncorr_matrix = attrition_mms.corr() \n(corr_matrix['Attrition'].sort_values(ascending = False)) ","18160ebe":"EDA = {\"column\": attrition_mms.columns,\n       \"mean\": attrition_mms.mean(),\n       \"median\": attrition_mms.median(),\n       \"mode\": attrition_mms.mode(),\n       \"standard deviation\": attrition_mms.std(),\n       \"variance\": attrition_mms.var(),\n       \"skewness\": attrition_mms.skew(),\n       \"kurtosis\": attrition_mms.kurt()}\n","6372f284":"print(EDA)","d5369236":"df_company = attrition_mms ","831e78df":"stacked_plot(df_company, \"Gender\", \"Attrition\")\nstacked_plot(df_company, \"MaritalStatus\", \"Attrition\")\nstacked_plot(df_company, \"BusinessTravel\", \"Attrition\")\nstacked_plot(df_company, \"Department\", \"Attrition\")\nstacked_plot(df_company, \"JobInvolvement\", \"Attrition\")\nstacked_plot(df_company, \"JobRole\", \"Attrition\")\nstacked_plot(df_company, \"JobLevel\", \"Attrition\")\nstacked_plot(df_company, \"JobSatisfaction\", \"Attrition\")\nstacked_plot(df_company, \"NumCompaniesWorked\", \"Attrition\")\nstacked_plot(df_company, \"OverTime\", \"Attrition\")\nstacked_plot(df_company, \"PercentSalaryHike\", \"Attrition\")\nstacked_plot(df_company, \"PerformanceRating\", \"Attrition\")\nstacked_plot(df_company, \"StockOptionLevel\", \"Attrition\")\nstacked_plot(df_company, \"TrainingTimesLastYear\", \"Attrition\")\nstacked_plot(df_company, \"Higher_Education\", \"Attrition\")\nstacked_plot(df_company, \"Status_of_leaving\", \"Attrition\")\nstacked_plot(df_company, \"Mode_of_work\", \"Attrition\")\nstacked_plot(df_company, \"Leaves\", \"Attrition\")\nstacked_plot(df_company, \"Absenteeism\", \"Attrition\")\nstacked_plot(df_company, \"Work_accident\", \"Attrition\")\nstacked_plot(df_company, \"Source_of_Hire\", \"Attrition\")\nstacked_plot(df_company, \"Job_mode\", \"Attrition\")","83757d16":"##############################################\n# We plot the heat map to see the various relationships under correlation using the heatmap\n\nplt.figure(figsize = (10,8))\nsns.heatmap(df_company.corr(), annot = False, cmap = 'coolwarm')\nplt.show()\n\n# Checking the correlation coeficients and importance ordered\ncorr_attr = df_company.corr()\n(corr_attr['Attrition'].sort_values(ascending = False))\n\ncol = df_company.corr().nlargest(20, \"Attrition\").Attrition.index\nplt.figure(figsize=(15, 15))\nsns.heatmap(df_company[col].corr(), annot = True, cmap = \"RdYlGn\", annot_kws = {\"size\":10})\n","c04c3e3f":"!pip install lifelines\nimport lifelines","ab15b2c2":"df = pd.read_csv(\"..\/input\/hr-attrition-dataset\/Final dataset Attrition.csv\")","03bd564d":"# Taking \"YearsAtCompany\" to be time spell\nT = df.YearsAtCompany \n\n# Importing the KaplanMeierFitter model to fit the survival analysis\nfrom lifelines import KaplanMeierFitter\n# Initiating the KaplanMeierFitter model\nkmf = KaplanMeierFitter()\n# Fitting KaplanMeierFitter model on Time and Events for Attrition\nkmf.fit(durations = T, event_observed = df_company.Attrition)\n# Time-line estimations plot \nkmf.survival_function_.plot()\nplt.title('Survival curve wrt the Attrition as event and YearsAtCompany as spell')\nplt.show()\n\n# Print survival probabilities at each year\nkmf.survival_function_\n\n# Plot the survival function with confidence intervals\nkmf.plot_survival_function()\nplt.show()","1c40a65e":"##############################################\n# We try over Multiple groups with the event being \"Attrition\"\n''' We first select the group to be OverTime'''\ndf_company.OverTime.value_counts()\n\nOT_worked = df_company.OverTime == 1\nOT_Not = df_company.OverTime == 0\n# Applying KaplanMeierFitter model on Time and Events for the group \"1\"\nkmf.fit(T[df_company.OverTime == 1], df_company.Attrition[df_company.OverTime == 1], label = 'OT_worked')\nax = kmf.survival_function_.plot()\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0\"\nkmf.fit(T[df_company.OverTime == 0], df_company.Attrition[df_company.OverTime == 0], label = 'OT_Not')\nkmf.survival_function_.plot(ax=ax)\nplt.title('Survival plot for \"Attrition\" w.r.t \"OverTime\"')\n","ec2a0fb1":"##############################################\n''' We now select the group to be BusinessTravel'''\ndf_company.BusinessTravel.value_counts()\n\nFrequent = df_company.BusinessTravel == 1.00\nRare = df_company.BusinessTravel == 0.50\nNon = df_company.BusinessTravel == 0.00\n# Applying KaplanMeierFitter model on Time and Events for the group \"1\"\nkmf.fit(T[df_company.BusinessTravel == 1], df_company.Attrition[df_company.BusinessTravel == 1], label = 'Frequent')\nax = kmf.survival_function_.plot()\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0.5\"\nkmf.fit(T[df_company.BusinessTravel == 0.5], df_company.Attrition[df_company.BusinessTravel == 0.5], label = 'Rare')\nkmf.survival_function_.plot(ax=ax)\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0\"\nkmf.fit(T[df_company.BusinessTravel == 0], df_company.Attrition[df_company.BusinessTravel == 0], label = 'Non')\nkmf.survival_function_.plot(ax=ax)\nplt.title('Survival plot for \"Attrition\" w.r.t \"BusinessTravel\"')\n","b821467b":"##############################################\n''' We now select the group to be JobLevel'''\ndf_company.JobLevel.value_counts()\n\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"1\"\nkmf.fit(T[df_company.JobLevel == 1], df_company.Attrition[df_company.JobLevel == 1], label = '5')\nax = kmf.survival_function_.plot()\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0.75\"\nkmf.fit(T[df_company.JobLevel == 0.75], df_company.Attrition[df_company.JobLevel == 0.75], label = '4')\nkmf.survival_function_.plot(ax=ax)\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0.50\"\nkmf.fit(T[df_company.JobLevel == 0.50], df_company.Attrition[df_company.JobLevel == 0.50], label = '3')\nkmf.survival_function_.plot(ax=ax)\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0.25\"\nkmf.fit(T[df_company.JobLevel == 0.25], df_company.Attrition[df_company.JobLevel == 0.25], label = '2')\nkmf.survival_function_.plot(ax=ax)\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0\"\nkmf.fit(T[df_company.JobLevel == 0], df_company.Attrition[df_company.JobLevel == 0], label = '1')\nkmf.survival_function_.plot(ax=ax)\nplt.title('Survival plot for \"Attrition\" w.r.t \"JobLevel\"')","c7240f93":"##############################################\n''' We now select the group to be Age_group'''\ndf_company.Age_group.value_counts()\n\n# Applying KaplanMeierFitter model on Time and Events for the group \"1\"\nkmf.fit(T[df_company.Age_group == 1], df_company.Attrition[df_company.Age_group == 1], label = '1')\nax = kmf.survival_function_.plot() \n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0.75\"\nkmf.fit(T[df_company.Age_group == 0.75], df_company.Attrition[df_company.Age_group == 0.75], label = '0.75')\nkmf.survival_function_.plot(ax=ax) \n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0.50\"\nkmf.fit(T[df_company.Age_group == 0.50], df_company.Attrition[df_company.Age_group == 0.50], label = '0.50')\nkmf.survival_function_.plot(ax=ax) \n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0.25\"\nkmf.fit(T[df_company.Age_group == 0.25], df_company.Attrition[df_company.Age_group == 0.25], label = '0.25')\nkmf.survival_function_.plot(ax=ax) \n\n# Applying KaplanMeierFitter model on Time and Events for the group \"0\"\nkmf.fit(T[df_company.Age_group == 0], df_company.Attrition[df_company.Age_group == 0], label = '0')\nkmf.survival_function_.plot(ax=ax) \nplt.title('Survival plot for \"Attrition\" w.r.t \"Age_group\"') ","878473fa":"#######################################################\n'''\nWe start building the models for classification\nWe start by splitting the data into Train and test\n'''\n#######################################################\n\nfrom sklearn.model_selection import train_test_split\ndf = df_company.iloc[:, 1]\ndf1 = df_company.drop('Attrition', axis = 1)\nX = df1\nY = df","e0c2a2cf":"# herein we split the data with test size kept as 15%\nx_train, x_test, y_train, y_test = train_test_split(X, Y, test_size = 0.15, random_state = 40)\nprint(y_train.value_counts())\nprint(y_test.value_counts())","bd3240e0":"# We start building the models using the following regression models for classifying\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.ensemble import BaggingClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom xgboost import XGBClassifier\nfrom sklearn.metrics import accuracy_score,confusion_matrix","12a64127":"'''Logistic Regression'''\nlog = LogisticRegression() \n","2de3e9d2":"x_test = x_test.drop(x_test.iloc[:, 29:30], axis = 1)\nx_test","ac2abaf9":"x_train = x_train.drop(x_train.iloc[:, 29:30], axis = 1)\nx_train","b1d7f5aa":"log.fit(x_train, y_train)\nlog_acc = accuracy_score(y_test, log.predict(x_test)) \nprint(\"Train Set Accuracy:\"+str(accuracy_score(y_train, log.predict(x_train))*100)) \nprint(\"Test Set Accuracy:\"+str(accuracy_score(y_test, log.predict(x_test))*100)) \n\nplt.figure(figsize = (6,4)) \ndf_ = pd.DataFrame(confusion_matrix(y_test, log.predict(x_test)), range(2),range(2))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(df_, annot=True,annot_kws={\"size\": 16}, fmt='g')\nplt.xlabel('Predicted Class')\nplt.ylabel('Original Class')\nplt.show()","c2a5db0f":"'''Descision Tree'''\ndec = DecisionTreeClassifier()\ndec.fit(x_train, y_train)\n\ndec_acc = accuracy_score(y_test, dec.predict(x_test))\nprint(\"Train test Accuracy:\"+str(accuracy_score(y_train, dec.predict(x_train))*100))\nprint(\"Test Set Accuracy:\"+str(accuracy_score(y_test, dec.predict(x_test))*100))\n\nplt.figure(figsize = (6,4)) \ndf_ = pd.DataFrame(confusion_matrix(y_test, dec.predict(x_test)), range(2),range(2))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(df_, annot=True,annot_kws={\"size\": 16}, fmt='g')\nplt.xlabel('Predicted Class')\nplt.ylabel('Original Class')\nplt.show()\n","deb2e483":"\"\"\"**Random Forest**\"\"\"\n\nr_for = RandomForestClassifier()\nr_for.fit(x_train,y_train)\n\nr_acc=accuracy_score(y_test,r_for.predict(x_test))\n\nprint(\"Train Set Accuracy:\"+str(accuracy_score(y_train,r_for.predict(x_train))*100))\nprint(\"Test Set Accuracy:\"+str(accuracy_score(y_test,r_for.predict(x_test))*100))\n\nplt.figure(figsize=(6,4))\ndf_ = pd.DataFrame(confusion_matrix(y_test, r_for.predict(x_test)), range(2),range(2))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(df_, annot=True,annot_kws={\"size\": 16}, fmt='g')\nplt.xlabel('Predicted Class')\nplt.ylabel('Original Class')\nplt.show()\n","ba33259e":"\"\"\"**K-NN**\n\"\"\"\n\nk_nei = KNeighborsClassifier()\nk_nei.fit(x_train,y_train)\n\nk_acc = accuracy_score(y_test,k_nei.predict(x_test))\n\nprint(\"Train set Accuracy:\"+str(accuracy_score(y_train,k_nei.predict(x_train))*100))\nprint(\"Test Set Accuracy:\"+str(accuracy_score(y_test,k_nei.predict(x_test))*100))\n\nplt.figure(figsize=(6,4))\ndf_ = pd.DataFrame(confusion_matrix(y_test, k_nei.predict(x_test)), range(2),range(2))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(df_, annot=True,annot_kws={\"size\": 16}, fmt='g')\nplt.xlabel('Predicted Class')\nplt.ylabel('Original Class')\nplt.show()","f432b253":"\n\"\"\"**SVC**\"\"\"\n\ns_vec = SVC()\ns_vec.fit(x_train,y_train)\n\ns_acc = accuracy_score(y_test,s_vec.predict(x_test))\n\nprint(\"Train set Accuracy:\"+str(accuracy_score(y_train,s_vec.predict(x_train))*100))\nprint(\"Test Set Accuracy:\"+str(accuracy_score(y_test,s_vec.predict(x_test))*100))\n\nplt.figure(figsize=(6,4))\ndf_ = pd.DataFrame(confusion_matrix(y_test, s_vec.predict(x_test)), range(2),range(2))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(df_, annot=True,annot_kws={\"size\": 16}, fmt='g')\nplt.xlabel('Predicted Class')\nplt.ylabel('Original Class')\nplt.show()","657b9c8b":"g_clf = GaussianNB()\ng_clf.fit(x_train,y_train)\n\ng_acc = accuracy_score(y_test,g_clf.predict(x_test))\n\nprint(\"Train set Accuracy:\"+str(accuracy_score(y_train,g_clf.predict(x_train))*100))\nprint(\"Test Set Accuracy:\"+str(accuracy_score(y_test,g_clf.predict(x_test))*100))\n\nplt.figure(figsize=(6,4))\ndf_ = pd.DataFrame(confusion_matrix(y_test, g_clf.predict(x_test)), range(2),range(2))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(df_, annot=True,annot_kws={\"size\": 16}, fmt='g')\nplt.xlabel('Predicted Class')\nplt.ylabel('Original Class')\nplt.show()\n","21b97491":"models = pd.DataFrame({'Model': ['Logistic', 'KNN', 'SVC', 'Decision Tree Classifier',\n                       'Random Forest Classifier', 'Gaussian'],\n                       'Accuracy': [ log_acc,k_acc, s_acc, dec_acc, r_acc, g_acc]})\n\nmodels.sort_values(by = 'Accuracy', ascending = False) ","ef6c3c8d":"plt.figure(figsize = (16,3))\nsns.barplot(x = 'Model', y = 'Accuracy', data = models)\nplt.show()\n\n\"\"\"We notice here that Random Forest Classifier is giving us the best accuracy result\n so ,we will go with the Random Forest model\"\"\"\n\n","7edef7d4":"# We use now various features that are impactful on the attrition and try to check the survival analysis over them to determine the duration","7e88ea7c":"# Now we try and visualise the factors that effect the attrtion most using the stacked plots as under.\n# Not only does it give a better understanding but the visuals help select the features better.\n# ","9625a580":"# Splitting the Data and Building the Model","3148368a":"# Random Forest","d8fbd6a6":"# Decision Tree","b20d6aa3":"# > EDA - Exploratory Data Analysis","b4cf65e6":"# KNN - K Nearest Neighbours","5e944fdf":"# We notice the correlation of various features and find that OverTime, Marital Status, DistanceFromHome and JobRole has the highest corelation with the Attririon","90ca5046":"# Comparing the models and checking the best accuracy result off the lot","2711bb02":"# We note that Random Forest Classifier gives the best result and we can move ahead with building a model and app by deployment using streamlit or flask, etc","597f8dc8":"# Logistic Regression","7be8f4f8":"# We will see step by step procedure for the project including, data cleaning, EDA, Visualization, Survival Analysis and Prediction using various models.","59328b6d":"**Additionally we have to now normalize the data as the scale is not the same for all the variables. We will use minmax scaler for the job**","0d265d03":"# Gaussian Naive Bayes","e1daf3a5":"# Let us import the various libraries to build the models","41f3bc7a":"# SVC","2d3cf85a":"# '''Project work for Workforce Analytics, wherein we need to work on the available features to figure out a solution on the attrition and forecast the problem in order to help stabilise the attrition rate and sturdy the features to help the businiess flow be proper'''","a17647ae":"# **The dataset has the following features and the description are as follows**\nThe dataset gathered has 1,470 nos of observations and the following 32 nos of features\n\n1. \"Age\"                        = The age of the employee\n2. \"Attrition\"                  = Whether the employee has attrited or not\n3. \"BusinessTravel\"             = Whether the employee used to travel for business or not\n4. \"Department\"                 = Which department the employee was employed under\n5. \"DistanceFromHome\"           = The distance the employee travels to reach for job on a day to day basis\n6. \"Gender\"                     = Gender of the employee\n7. \"JobInvolvement\"             = The involvement rating of an employee over the job handled\n8. \"JobLevel\"                   = Level at which the employee is working\n9. \"JobRole\"                    = The roles and resposibilites of the employee\n10. \"JobSatisfaction\"           = Satisfaction rating of the employee for the job\n11. \"MaritalStatus\"             = Marital status of the employee\n12. \"MonthlyIncome\"             = Monthly income of the employees\n13. \"NumCompaniesWorked\"        = Number of companies the employees has worked for\n14. \"OverTime\"                  = Whether working Overtime or not\n15. \"PercentSalaryHike\"         = Percentage salary hike since their appointment in the company\n16. \"PerformanceRating\"         = Performance rating \n17. \"StockOptionLevel\"          = Level of opted for sharing the stock \n18. \"TotalWorkingYears\"         = Total years worked by the employees\n19. \"TrainingTimesLastYear\"     = How many trainings the employee has undergone\n20. \"YearsAtCompany\"            = Years spent at the present organisation\n21. \"YearsSinceLastPromotion\"   = Time gone in years since last promotion\n22. \"YearsWithCurrManager\"      = Years working under he current manager\n23. \"Higher_Education\"          = Higher education level of the employee\n24. \"Date_of_Hire\"              = Date of hire of the employee in the current organisation\n25. \"Date_of_termination\"       = Date of termination from the organisation\n26. \"Status_of_leaving\"         = Reason for leaving the organisation\n27. \"Mode_of_work\"              = WFH or WFO\n28. \"Leaves\"                    = Total permitted leaves taken by the employee\n29. \"Absenteeism\"               = Total days absent for the employee\n30. \"Work_accident\"             = Work accident if any\n31. \"Source_of_hire\"            = Source of hire\n32. \"Job_Mode\"                  = Working full time\/ part or contractual"}}