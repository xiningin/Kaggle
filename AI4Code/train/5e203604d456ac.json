{"cell_type":{"7b116322":"code","c149888c":"code","f64271c4":"code","f081d1d4":"code","53aa75b4":"code","89a89c3d":"code","14e5c90c":"code","117b7398":"code","78f64197":"code","471f0fd9":"markdown","b57fdba4":"markdown","3b88795d":"markdown","210ffcaa":"markdown","17b171e5":"markdown","9b07126b":"markdown"},"source":{"7b116322":"!rsync -a ..\/input\/mmdetection-v280\/mmdetection ..\/\n!pip install ..\/input\/mmdetection-v280\/src\/mmdet-2.8.0\/mmdet-2.8.0\/\n!pip install ..\/input\/mmdetection-v280\/src\/mmpycocotools-12.0.3\/mmpycocotools-12.0.3\/\n!pip install ..\/input\/mmdetection-v280\/src\/addict-2.4.0-py3-none-any.whl\n!pip install ..\/input\/mmdetection-v280\/src\/yapf-0.30.0-py2.py3-none-any.whl\n!pip install ..\/input\/mmdetection-v280\/src\/mmcv_full-1.2.6-cp37-cp37m-manylinux1_x86_64.whl","c149888c":"import pandas as pd\nimport numpy as np\nimport os\nimport cv2\nfrom tqdm import tqdm\nimport pickle\nfrom itertools import groupby\nfrom pycocotools import mask as mutils\nfrom pycocotools import _mask as coco_mask\nimport matplotlib.pyplot as plt\nimport os\nimport base64\nimport typing as t\nimport zlib\nimport random\nrandom.seed(0)\n\nexp_name = \"v4\"\nconf_name = \"mask_rcnn_s101_fpn_syncbn-backbone+head_mstrain_1x_coco\"\nmodel_name = 'mask_rcnn_resnest101_v5_ep9'\nROOT = '..\/input\/hpa-single-cell-image-classification\/'\ntrain_or_test = 'test'\ndf = pd.read_csv(os.path.join(ROOT, 'sample_submission.csv'))\nif len(df) == 559:\n    debug = True\n    df = df[:3]\nelse:\n    debug = False","f64271c4":"def encode_binary_mask(mask: np.ndarray) -> t.Text:\n  \"\"\"Converts a binary mask into OID challenge encoding ascii text.\"\"\"\n\n  # check input mask --\n  if mask.dtype != np.bool:\n    raise ValueError(\n        \"encode_binary_mask expects a binary mask, received dtype == %s\" %\n        mask.dtype)\n\n  mask = np.squeeze(mask)\n  if len(mask.shape) != 2:\n    raise ValueError(\n        \"encode_binary_mask expects a 2d mask, received shape == %s\" %\n        mask.shape)\n\n  # convert input mask to expected COCO API input --\n  mask_to_encode = mask.reshape(mask.shape[0], mask.shape[1], 1)\n  mask_to_encode = mask_to_encode.astype(np.uint8)\n  mask_to_encode = np.asfortranarray(mask_to_encode)\n\n  # RLE encode mask --\n  encoded_mask = coco_mask.encode(mask_to_encode)[0][\"counts\"]\n\n  # compress and base64 encoding --\n  binary_str = zlib.compress(encoded_mask, zlib.Z_BEST_COMPRESSION)\n  base64_str = base64.b64encode(binary_str)\n  return base64_str.decode()\n\ndef read_img(image_id, color, train_or_test='train', image_size=None):\n    filename = f'{ROOT}\/{train_or_test}\/{image_id}_{color}.png'\n    assert os.path.exists(filename), f'not found {filename}'\n    img = cv2.imread(filename, cv2.IMREAD_UNCHANGED)\n    if image_size is not None:\n        img = cv2.resize(img, (image_size, image_size))\n    if img.dtype == 'uint16':\n        img = (img\/256).astype('uint8')\n    return img\n\ndef load_RGBY_image(image_id, train_or_test='train', image_size=None):\n    red = read_img(image_id, \"red\", train_or_test, image_size)\n    green = read_img(image_id, \"green\", train_or_test, image_size)\n    blue = read_img(image_id, \"blue\", train_or_test, image_size)\n    # using rgb only here\n    #yellow = read_img(image_id, \"yellow\", train_or_test, image_size)\n    stacked_images = np.transpose(np.array([red, green, blue]), (1,2,0))\n    return stacked_images\n\ndef print_masked_img(image_id, mask):\n    img = load_RGBY_image(image_id, train_or_test)\n    \n    plt.figure(figsize=(15, 15))\n    plt.subplot(1, 3, 1)\n    plt.imshow(img)\n    plt.title('Image')\n    plt.axis('off')\n    \n    plt.subplot(1, 3, 2)\n    plt.imshow(mask)\n    plt.title('Mask')\n    plt.axis('off')\n    \n    plt.subplot(1, 3, 3)\n    plt.imshow(img)\n    plt.imshow(mask, alpha=0.6)\n    plt.title('Image + Mask')\n    plt.axis('off')\n    plt.show()","f081d1d4":"out_image_dir = f'..\/work\/mmdet_{exp_name}_{train_or_test}\/'\n!mkdir -p {out_image_dir}\n\nannos = []\nfor idx in tqdm(range(len(df))):\n    image_id = df.iloc[idx].ID\n    img = load_RGBY_image(image_id, train_or_test)\n    \n    cv2.imwrite(f'{out_image_dir}\/{image_id}.jpg', img)\n    ann = {\n        'filename': image_id+'.jpg',\n        'width': img.shape[1],\n        'height': img.shape[0],\n        'ann': {\n            'bboxes': None,\n            'labels': None,\n            'masks': None\n        }\n    }\n    annos.append(ann)\n    \nwith open(f'..\/work\/mmdet_{exp_name}_tst.pkl', 'wb') as f:\n    pickle.dump(annos, f)","53aa75b4":"# I just made following config files based on default mask_rcnn.\n# The main changes are CustomDataset, num_classes, data path, etc.\n# Other than that, I used it as is for mmdetection.\n!ls -l ..\/mmdetection\/configs\/hpa\/","89a89c3d":"config = f'configs\/hpa_{exp_name}\/{conf_name}.py'\nmodel_file = f'..\/input\/hpa-models\/{model_name}.pth'\nresult_pkl = f'..\/work\/{model_name}.pkl'\nadditional_conf = '--cfg-options'\nadditional_conf += ' test_cfg.rcnn.score_thr=0.001'\ncmd = f'python tools\/test.py {config} {model_file} --out {result_pkl} {additional_conf}'\n!cd ..\/mmdetection; {cmd}\nresult = pickle.load(open('..\/mmdetection\/'+result_pkl, 'rb'))","14e5c90c":"for ii in range(3):\n    image_id = annos[ii]['filename'].replace('.jpg','').replace('.png','')\n    for class_id in range(19):\n        #print(ii,class_id,len(result[ii][0][class_id]), len(result[ii][1][class_id]))\n        bbs = result[ii][0][class_id]\n        sgs = result[ii][1][class_id]\n        for bb, sg in zip(bbs,sgs):\n            box = bb[:4]\n            cnf = bb[4]\n            h = sg['size'][0]\n            w = sg['size'][0]\n            if cnf > 0.3:\n                print(f'class_id:{class_id}, image_id:{image_id}, confidence:{cnf}')\n                mask = mutils.decode(sg).astype(bool)\n                print_masked_img(image_id, mask)","117b7398":"with open('submission.csv', 'w') as outf:\n    print('ID,ImageWidth,ImageHeight,PredictionString', file=outf)\n    for ii in range(len(annos)):\n        image_id = annos[ii]['filename'].replace('.jpg','').replace('.png','')\n        pred_strs = []\n        for class_id in range(19):\n            #print(ii,class_id,len(result[ii][0][class_id]), len(result[ii][1][class_id]))\n            bbs = result[ii][0][class_id]\n            sgs = result[ii][1][class_id]\n            for bb, sg in zip(bbs,sgs):\n                box = bb[:4]\n                cnf = bb[4]\n                h = sg['size'][0]\n                w = sg['size'][1]\n                #convert coco format to kaggle format\n                mask = mutils.decode(sg).astype(bool)\n                rle = encode_binary_mask(mask)\n                pred_strs.append(f'{class_id} {cnf} {rle}')\n        print(f'{image_id},{w},{h},{\" \".join(pred_strs)}', file=outf)\n","78f64197":"!ls -l ","471f0fd9":"# generate files for mmdetection","b57fdba4":"# format submission file","3b88795d":"This is simple mmdetection infrence script as a base line.\nTraining part can be foud [here](https:\/\/www.kaggle.com\/its7171\/mmdetection-for-segmentation-training).","210ffcaa":"# inference","17b171e5":"# helper funcs","9b07126b":"# result check"}}