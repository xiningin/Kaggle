{"cell_type":{"17280477":"code","b0e3a748":"code","029a5c49":"code","29ca230c":"code","63159376":"code","e1293f76":"code","bc57133c":"code","8fa9b030":"code","52020578":"code","b1869077":"code","b32ab1e8":"markdown","5b5ab0a0":"markdown","2aebfb99":"markdown","0e58f6fe":"markdown","d9e3c918":"markdown","0f4ffcb9":"markdown","f905d1c2":"markdown"},"source":{"17280477":"import pandas as pd \nimport numpy as np \ncredits_df=pd.read_csv('..\/input\/tmdb-movie-metadata\/tmdb_5000_credits.csv')\nmovies_df=pd.read_csv('..\/input\/tmdb-movie-metadata\/tmdb_5000_movies.csv')","b0e3a748":"print(credits_df.columns)\ncredits_df.columns = ['id','tittle','cast','crew']\ncredits_df.head(10)","029a5c49":"print(movies_df.columns)\nmovies_df.head(10)","29ca230c":"print(\"credits_df columns\")\nprint(credits_df.columns)\nprint(\"-----------------------------------------------------------------------------------------\")\nprint(\"movies_df columns\")\nprint(movies_df.columns)\nprint(\"-----------------------------------------------------------------------------------------\")\ndf= movies_df.merge(credits_df,on='id')\nprint(\"df columns after merging\")\nprint(df.columns)\nprint(\"-----------------------------------------------------------------------------------------\")\ndf","63159376":"C= movies_df['vote_average'].mean()\nC","e1293f76":"m= movies_df['vote_count'].quantile(0.9)\nm","bc57133c":"q_movies = movies_df.copy().loc[movies_df['vote_count'] >= m]\nq_movies.shape","8fa9b030":"def weighted_rating(x, m=m, C=C):\n    v = x['vote_count']\n    R = x['vote_average']\n    # Calculation based on the IMDB formula\n    return (v\/(v+m) * R) + (m\/(m+v) * C)\nq_movies['score'] = q_movies.apply(weighted_rating, axis=1)","52020578":"#Sort movies based on score calculated above\nq_movies = q_movies.sort_values('score', ascending=False)\n\n#Print the top 15 movies\nq_movies[['title', 'vote_count', 'vote_average', 'score']].head(10)","b1869077":"pop= movies_df.sort_values('popularity', ascending=False)\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(12,4))\nplt.barh(pop['title'].head(6),pop['popularity'].head(6), align='center',color='blue')\nplt.gca().invert_yaxis()\nplt.xlabel(\"Popularity\")\nplt.title(\"Popular Movies\")","b32ab1e8":"So, the mean rating for all the movies is approx 6 on a scale of 10.The next step is to determine an appropriate value for m, the minimum votes required to be listed in the chart. We will use 90th percentile as our cutoff. In other words, for a movie to feature in the charts, it must have more votes than at least 90% of the movies in the list.","5b5ab0a0":"Finally, let's sort the DataFrame based on the score feature and output the title, vote count, vote average and weighted rating or score of the top 10 movies.","2aebfb99":"We see that there are 481 movies which qualify to be in this list. Now, we need to calculate our metric for each qualified movie. To do this, we will define a function, **weighted_rating()** and define a new feature **score**, of which we'll calculate the value by applying this function to our DataFrame of qualified movies:","0e58f6fe":"# **Demographic Filtering** -\n   Before getting started with this  -\n* we need a metric to score or rate movie \n* Calculate the score for every movie \n* Sort the scores and recommend the best rated movie to the users.\n\nWe can use the average ratings of the movie as the score but using this won't be fair enough since a movie with 8.9 average rating and only 3 votes cannot be considered better than the movie with 7.8 as as average rating but 40 votes.\nSo, I'll be using IMDB's weighted rating (wr) which is given as :-\n\n![](https:\/\/image.ibb.co\/jYWZp9\/wr.png)\nwhere,\n* v is the number of votes for the movie;\n* m is the minimum votes required to be listed in the chart;\n* R is the average rating of the movie; And\n* C is the mean vote across the whole report\n\nWe already have v(**vote_count**) and R (**vote_average**) and C can be calculated as ","d9e3c918":"Now, we can filter out the movies that qualify for the chart ","0f4ffcb9":"Now something to keep in mind is that these demographic recommender provide a general chart of recommended movies to all the users. They are not sensitive to the interests and tastes of a particular user. This is when we move on to a more refined system- Content Basesd Filtering.","f905d1c2":"## **Conclusion** \nWe create recommenders using demographic , content- based and collaborative filtering. While demographic filtering is very elemantary and cannot be used practically, **Hybrid Systems** can take advantage of content-based and collaborative filtering as the two approaches are proved to be almost complimentary.\nThis model was very baseline and only provides a fundamental framework to start with.\n\nI would like to mention some excellent refereces that I learned from\n\n1. [https:\/\/www.kaggle.com\/rounakbanik\/movie-recommender-systems](https:\/\/www.kaggle.com\/rounakbanik\/movie-recommender-systems)\n2. [https:\/\/towardsdatascience.com\/how-to-build-a-movie-recommendation-system-67e321339109](https:\/\/towardsdatascience.com\/how-to-build-a-movie-recommendation-system-67e321339109)\n"}}