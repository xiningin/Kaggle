{"cell_type":{"9e149fa8":"code","3e6d50d0":"code","0243d75a":"code","44302ffa":"code","d7461d9a":"code","f6001c32":"code","8b12c74f":"code","14caf54d":"code","c9b697f1":"code","6cb07ff9":"code","67d0b9a4":"code","e425afe8":"markdown","16dceefc":"markdown","b09d5c68":"markdown","9ea21103":"markdown","4e9e912b":"markdown","29d115c4":"markdown","7af99954":"markdown","e6cd53cc":"markdown"},"source":{"9e149fa8":"#local file path stuff (skip if need be)\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","3e6d50d0":"%matplotlib inline\n\nimport collections\nimport sys\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas\nfrom matplotlib import colors\nfrom matplotlib.ticker import PercentFormatter","0243d75a":"\n\nclass Classroom:\n    def __init__(self, P, S, R, K):\n        self.P, self.S, self.K, self.R, self.Q = P, S, K, R, sys.maxsize\n        self.projects = collections.OrderedDict()\n        self.students = collections.OrderedDict()\n    \n    def import_csv(self, path_to_csv):\n        ''' Import real student\/project data from provided csv'''\n        file1 = open(path_to_csv, 'r') \n        Lines = file1.readlines() \n        for line in Lines: #student reading\n            formatted_line = line.strip().replace(' ', '')\n            line_arr = formatted_line.split(',')\n            student_pref_list = []\n            student_name = \"\"\n            for i in range(0,len(line_arr)):\n                \n                if i == 0:\n                    student_name = str(line_arr[i])\n                else:\n                    student_pref_list.append(chr(96+int(line_arr[i])))\n            self.students[student_name] = {'Preferences': student_pref_list, \"Q\": sys.maxsize} #Q is set to max int initially\n#             print(student_name)\n#             print(student_pref_list)\n\n        for i in range(0,self.P): #project generation\n            proj_name = ''\n            if i > 25:\n                temp = i\n                while temp >= 0:\n                    proj_name = chr(ord('a')+(temp%26)) + proj_name\n                    temp = int(temp\/26) - 1\n                print(proj_name)\n            else:\n                proj_name = chr(ord('a')+i)\n            self.projects[proj_name] = []\n            \n            \n        \n    def generate_data(self):\n        ''' Generates mock project and random student preferences based on P,S,K values '''\n        for i in range(0,self.P): #project generation\n            proj_name = ''\n            if i > 25:\n                temp = i\n                while temp >= 0:\n                    proj_name = chr(ord('a')+(temp%26)) + proj_name\n                    temp = int(temp\/26) - 1\n                print(proj_name)\n            else:\n                proj_name = chr(ord('a')+i)\n            self.projects[proj_name] = []\n        \n        for i in range(0,self.S): #student generation\n            sname = 's' + str(i)\n            import random\n            assignments = random.sample(range(self.P), self.K)\n            #assignments = random.choices(range(self.P),weights=(36,15,10,5,5,5,5,5,2,2,2,2,1,1,1,1,1,1),k=self.K) #weighted\n            items = list(self.projects.items())\n            preferences = []\n            for n in assignments:\n                preferences.append(items[n][0])\n            self.students[sname] = {'Preferences': preferences, \"Q\": sys.maxsize} #Q is set to max int initially\n            \n    def pretty_print(self,only_projects=False):\n        ''' Clean print of data with or without student info'''\n        print(\"\\nProjects and Assignments\")\n        for project in self.projects:\n            print(\"project: %s %s\"% (project,self.projects[project]))\n        if not only_projects:\n            print(\"\\nStudents and Preferences\")\n            for student in self.students:\n                print(\"%s, pref: %s, Q: %s\"% (student,self.students[student]['Preferences'],self.students[student]['Q']))\n                \n    def graph_Q_dist(self):\n        ''' Graph the Q distribution across all Qs'''\n        import matplotlib.pyplot as plt\n        fig = plt.figure()\n        ax = fig.add_axes([0,0,1,1])\n        q_dict = {}\n        q_scores = []\n        q_values = []\n        for student in self.students:\n            q_score = self.students[student]['Q']\n            if q_score not in q_dict:\n                q_dict[q_score] = 1\n            else:\n                q_dict[q_score] += 1\n        for i in range(1,self.K+2):\n            q_values.append(i)\n            if i in q_dict:\n                q_scores.append(q_dict[i])\n            else:\n                q_scores.append(0)\n        \n        ax.bar(q_values,q_scores)\n        plt.show()\n        \n    def unassigned_students(self):\n        ''' Find the number of unassigned students'''\n        number = 0\n        for student in self.students:\n#             print(self.students[student]['Q'])\n            if self.students[student]['Q'] == sys.maxsize:\n                number+= 1\n#         print(\"unass: %s\"%(number))\n        return number\n        \n    def compute_avgQ(self):\n        ''' Calculate avg Q for all students'''\n        sum = 0.0\n        unassigned = 0\n        assigned_sum = 0.0\n        for student in self.students:\n            sum += self.students[student]['Q']\n            if self.students[student]['Q'] == sys.maxsize:\n                unassigned +=1\n            else:\n                assigned_sum += self.students[student]['Q']\n        avgQ = sum\/float(self.S)\n        avgQ_assigned = assigned_sum\/float(self.S)\n        print(\"Avg Q: %.5f, Unassigned: %s\"%(avgQ,unassigned))\n        \n        return avgQ\n    \n    def projects_below_R(self):\n        ''' Checks which projects have below R assignments and returns them'''\n        project_list = []\n        for project in self.projects:\n            if len(self.projects[project]) < self.R:\n                project_list.append(project)\n        return project_list\n    \n    def Q_score(self, student, project):\n        ''' Returns student Q score for a given student\/project combo (worst Q is maxint) '''\n        student_prefs = self.students[student]['Preferences']\n        for i in range (0,len(student_prefs)):\n            if student_prefs[i] == project:\n                return i+1\n        return self.K +1 \n    \n    def solution_1(self):\n        ''' \n        First approach for project assignment\n        Iterate through each project that still needs students\n        Assign a student to a project as long as no better assignment exists\n        Once reached R threshold per project, find any students yet to be assigned and find best option for them else random assignment\n        '''\n        import time\n        start_time = time.time()\n\n        projects_to_assign = self.projects_below_R()\n        count = 0\n        while len(projects_to_assign)>0: #while there is a project that needs assignment\n#             if count > 4:\n#                 break\n            projects_to_assign_ref = projects_to_assign\n            for project in projects_to_assign: #iterate through those projects\n                if project not in projects_to_assign_ref:\n                    continue\n                best_student_candidate = \"None\"\n                best_project_candidate = project\n                minQ = sys.maxsize\n                for student in self.students: #find best student for that project\n                    if self.students[student]['Q'] != sys.maxsize: #skip if student is already assigned\n                        #print(\"skipping student %s\"%(student))\n                        continue\n                    qscore = self.Q_score(student,project)\n                    if qscore <= minQ:\n                        best_student_candidate = student\n                        minQ = qscore\n                        \n                #make sure lower Q can't be achieved by assigning student to another project\n                for project2 in projects_to_assign_ref:\n                    if project2 == project:\n                        continue\n                    secondary_minQ = self.Q_score(best_student_candidate, project2)\n                    if secondary_minQ < minQ and project2:\n                        best_project_candidate = project2\n                        minQ = secondary_minQ\n                        \n                #do official assignment of stud -> proj here\n                self.projects[best_project_candidate].append(best_student_candidate)\n                self.students[best_student_candidate]['Q'] = self.Q_score(best_student_candidate,best_project_candidate)\n                #print(\"Best student for proj %s is %s with Qscore %s\"%(best_project_candidate, best_student_candidate, minQ))\n                projects_to_assign_ref = self.projects_below_R()\n            projects_to_assign = self.projects_below_R()\n\n            count+= 1\n        \n        self.pretty_print() \n        print(self.compute_avgQ())\n        self.graph_Q_dist()\n            \n        #Assign remaining unassigned students to projects \n        students_to_assign = self.unassigned_students()\n        while (students_to_assign > 0):\n            for student in self.students:\n                if self.students[student]['Q'] != sys.maxsize: #skip if student is already assigned\n                        continue\n                best_project_candidate = \"None\"\n                minQ = sys.maxsize\n                for project in self.projects:\n                    if len(self.projects[project]) >= self.R+1:\n                        continue\n                    qscore = self.Q_score(student,project)\n                    if qscore <= minQ:\n                        best_project_candidate = project\n                        minQ = qscore \n                if self.unassigned_students() == 0:\n                    break\n                self.projects[best_project_candidate].append(student)\n                qscore_to_give = self.Q_score(student,best_project_candidate)\n                print(\"Assigned %s to %s with qscore: %s\"%(student,best_project_candidate, qscore_to_give))\n                self.students[student]['Q'] = qscore_to_give\n                students_to_assign -=1\n                \n#         while(students_to_assign>0):\n#             for project in self.projects:\n#                 best_student_candidate = \"None\"\n#                 minQ = sys.maxsize\n#                 for student in self.students: #find best student for that project\n#                     if self.students[student]['Q'] != sys.maxsize: #skip if student is already assigned\n#                         continue\n#                     qscore = self.Q_score(student,project)\n# #                     print(\"qscore: %s\"%(qscore))\n# #                     print(\"minq: %s\"%(minQ))\n# #                     print(student)\n#                     if qscore <= minQ:\n#                         best_student_candidate = student\n#                         minQ = qscore \n# #                         print(best_student_candidate)\n#                 if self.unassigned_students() == 0:\n#                     break\n#                 self.projects[project].append(best_student_candidate)\n# #                 print(self.projects[project])\n#                 score_to_give = self.Q_score(best_student_candidate,project)\n#                 if self.Q_score(best_student_candidate,project) == sys.maxsize:\n#                     score_to_give = self.K\n                \n#                 self.students[best_student_candidate]['Q'] = score_to_give\n#                 students_to_assign -=1\n                \n\n\n\n        \n        print(\"alg1(P%s,S%s,R%s,K%s) execution: %0.5fs\" % (self.P,self.S,self.R,self.K,time.time() - start_time))\n        return self.compute_avgQ(),self.unassigned_students()","44302ffa":"classroom1 = Classroom(P=18,S=95,R=5,K=5)\nclassroom1.import_csv('\/kaggle\/input\/projectdata-final\/Project_CSV.csv')\nclassroom1.pretty_print()","d7461d9a":"q,errors = classroom1.solution_1()\nclassroom1.pretty_print()","f6001c32":"classroom1.graph_Q_dist()","8b12c74f":"classroom = Classroom(P=18,S=89,R=4,K=5)\nclassroom.generate_data()\nclassroom.pretty_print()\n","14caf54d":"q,errors = classroom.solution_1()\nclassroom.pretty_print()","c9b697f1":"classroom.graph_Q_dist()","6cb07ff9":"%%capture\ntest_iterations = 500\nn_bins = 20\nq_values = []\n\nfor i in range(0,test_iterations):\n    c = Classroom(P=13,S=70,R=5,K=7)\n    c.generate_data()\n    q,errors = c.solution_1()\n    q_values.append(q)\n","67d0b9a4":"fig, axs = plt.subplots(1,sharey=True, tight_layout=True)\naxs.hist(q_values, bins=n_bins)","e425afe8":"### Plot Dist","16dceefc":"CSV Assignment Here\n\nS = 90, P=18, K=5, R=4","b09d5c68":"### Main Classroom Object for Data Generation and Assignment","9ea21103":"# Project Assignment Solution\n* There are S students, P projects, and each project should have at least R students ( R < S\/P)\n* Each student rank orders at most K (K < P, for example K = 5) projects according to their preferences \n* After a student is assigned to a project, the quality of assignment from that student\u2019s perspective is Q ( 1 <= Q <= K). Lower the Q, better it is for the student \n* We want low class-wise average Q so that the performance is good at the class level\n* We also want a low variance in class wise Q so that the assignment is fairer","4e9e912b":"### Q-score distribution across students","29d115c4":"### High Volume Test (500 Classrooms) of Solution 1","7af99954":"## Test 1 (Autogenerated Data)","e6cd53cc":"### Try Solution 1"}}