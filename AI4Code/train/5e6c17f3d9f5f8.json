{"cell_type":{"ed92a307":"code","f0c71e74":"code","e381a93c":"code","5527deab":"code","b46051e9":"code","7d224dce":"code","4bf1a6d6":"code","c00c2994":"code","67e0a1c2":"code","586e0a94":"code","2d6a9256":"code","6936e067":"code","e632fc7e":"code","191d9a83":"code","36ce52c2":"markdown","306879c9":"markdown","3d51caba":"markdown","7b8c1c4f":"markdown","d186370f":"markdown","a9d97bf3":"markdown","4468c884":"markdown"},"source":{"ed92a307":"!pip install -q efficientnet","f0c71e74":"# Asthetics\nimport warnings\nimport sklearn.exceptions\nwarnings.filterwarnings('ignore', category=DeprecationWarning)\nwarnings.filterwarnings('ignore', category=FutureWarning)\nwarnings.filterwarnings(\"ignore\", category=sklearn.exceptions.UndefinedMetricWarning)\n\n# General\nfrom kaggle_datasets import KaggleDatasets\nfrom glob import glob\nimport pandas as pd\nimport numpy as np\nimport os\nimport time\nimport cv2\nimport random\nimport shutil\nimport math\nimport re\npd.set_option('display.max_columns', None)\n\n# Visualizations\nfrom PIL import Image\nfrom plotly.subplots import make_subplots\nfrom plotly.offline import iplot\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport cv2\nimport plotly.graph_objs as go\nimport plotly.figure_factory as ff\nimport plotly.express as px\n%matplotlib inline\nsns.set(style=\"whitegrid\")\n\n# Machine Learning\n# Pre Procesing\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\n# Models\nfrom sklearn.model_selection import train_test_split, KFold\n# Deep Learning\nimport tensorflow as tf\nimport tensorflow.keras.backend as K\nimport efficientnet.tfkeras as efn\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.applications import EfficientNetB4\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Activation, BatchNormalization, GlobalAveragePooling2D\nfrom tensorflow.keras.callbacks import TensorBoard, EarlyStopping, ReduceLROnPlateau, ModelCheckpoint\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.losses import CategoricalCrossentropy\nimport tensorflow_addons as tfa\nfrom tensorflow_addons.metrics import F1Score, FBetaScore\nfrom tensorflow_addons.callbacks import TQDMProgressBar\nfrom tensorflow.keras.utils import plot_model\n\n#Metrics\nfrom sklearn.metrics import confusion_matrix, classification_report, roc_auc_score\n\nprint('TF',tf.__version__)\n\n# Random Seed Fixing\nRANDOM_SEED = 42\n\ndef seed_everything(seed=RANDOM_SEED):\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    random.seed(seed)\n    tf.random.set_seed(seed)\n\nseed_everything()","e381a93c":"# From https:\/\/www.kaggle.com\/xhlulu\/ranzcr-efficientnet-tpu-training\ndef auto_select_accelerator():\n    TPU_DETECTED = False\n    try:\n        tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n        tf.config.experimental_connect_to_cluster(tpu)\n        tf.tpu.experimental.initialize_tpu_system(tpu)\n        strategy = tf.distribute.experimental.TPUStrategy(tpu)\n        print(\"Running on TPU:\", tpu.master())\n        TPU_DETECTED =True\n    except ValueError:\n        strategy = tf.distribute.get_strategy()\n    print(f\"Running on {strategy.num_replicas_in_sync} replicas\")\n    \n    return strategy, TPU_DETECTED","5527deab":"# Model Params\nKFOLDS = 4\nIMG_SIZES = [256]*KFOLDS\nBATCH_SIZES = [64]*KFOLDS\nEPOCHS = [20]*KFOLDS\nEFF_NETS = [1]*KFOLDS # WHICH EFFICIENTNET B? TO USE\n\n# Model Eval Params\nDISPLAY_PLOT = True\n\n# Inference Params\nWGTS = [1\/KFOLDS]*KFOLDS","b46051e9":"strategy, TPU_DETECTED = auto_select_accelerator()\nAUTO = tf.data.experimental.AUTOTUNE\nREPLICAS = strategy.num_replicas_in_sync","7d224dce":"from tqdm.notebook import tqdm\n\nfiles_train_g = []\nfor i,k in tqdm([(0, 3), (4,7), (8, 12), (12,15)]):\n    GCS_PATH = KaggleDatasets().get_gcs_path(f'g2net-{i}{k}')\n    files_train_g.extend(np.sort(np.array(tf.io.gfile.glob(GCS_PATH + '\/train*.tfrec'))).tolist())\nnum_train_files = len(files_train_g)\nprint('train_files:',num_train_files)","4bf1a6d6":"def read_labeled_tfrecord(example):\n    tfrec_format = {\n        'image'                        : tf.io.FixedLenFeature([], tf.string),\n        'image_id'                     : tf.io.FixedLenFeature([], tf.string),\n        'target'                       : tf.io.FixedLenFeature([], tf.int64)\n    }           \n    example = tf.io.parse_single_example(example, tfrec_format)\n    return prepare_image(example['image']), tf.reshape(tf.cast(example['target'], tf.float32), [1])\n\n\ndef read_unlabeled_tfrecord(example, return_image_id):\n    tfrec_format = {\n        'image'                        : tf.io.FixedLenFeature([], tf.string),\n        'image_id'                     : tf.io.FixedLenFeature([], tf.string),\n    }\n    example = tf.io.parse_single_example(example, tfrec_format)\n    return prepare_image(example['image']), example['image_id'] if return_image_id else 0\n\n \ndef prepare_image(img, dim=IMG_SIZES[0]):    \n    img = tf.image.resize(tf.image.decode_png(img, channels=3), size=(dim, dim))\n    img = tf.cast(img, tf.float32) \/ 255.0\n    img = tf.reshape(img, [dim,dim, 3])\n            \n    return img\n\ndef count_data_items(fileids):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(fileid).group(1)) \n         for fileid in fileids]\n    return np.sum(n)","c00c2994":"def get_dataset(files, shuffle = False, repeat = False, \n                labeled=True, return_image_ids=True, batch_size=16, dim=IMG_SIZES[0]):\n    \n    ds = tf.data.TFRecordDataset(files, num_parallel_reads=AUTO)\n    ds = ds.cache()\n    \n    if repeat:\n        ds = ds.repeat()\n    \n    if shuffle: \n        ds = ds.shuffle(1024*2)\n        opt = tf.data.Options()\n        opt.experimental_deterministic = False\n        ds = ds.with_options(opt)\n        \n    if labeled: \n        ds = ds.map(read_labeled_tfrecord, num_parallel_calls=AUTO)\n    else:\n        ds = ds.map(lambda example: read_unlabeled_tfrecord(example, return_image_ids), \n                    num_parallel_calls=AUTO)      \n    \n    ds = ds.batch(batch_size * REPLICAS)\n    ds = ds.prefetch(AUTO)\n    return ds","67e0a1c2":"EFNS = [efn.EfficientNetB0, efn.EfficientNetB1, efn.EfficientNetB2, efn.EfficientNetB3, \n        efn.EfficientNetB4, efn.EfficientNetB5, efn.EfficientNetB6, efn.EfficientNetB7]\n\ndef build_model(size, ef=0, count=820):\n    inp = tf.keras.layers.Input(shape=(size, size,3))\n    base = EFNS[ef](input_shape=(size,size,3),weights='imagenet',include_top=False)\n    \n    x = base(inp)\n    \n    x = tf.keras.layers.GlobalAvgPool2D()(x)\n    \n    x = tf.keras.layers.Dropout(0.5)(x)\n    \n    x = tf.keras.layers.Dense(1,activation='sigmoid')(x)\n    model = tf.keras.Model(inputs=inp, outputs=x)\n    lr_decayed_fn = tf.keras.experimental.CosineDecay(\n                              1e-3,\n                              count,\n    )\n\n    opt = tfa.optimizers.AdamW(lr_decayed_fn, learning_rate=1e-4)\n    loss = tf.keras.losses.BinaryCrossentropy() \n    model.compile(optimizer=opt,loss=loss,metrics=['AUC'])\n    return model","586e0a94":"def vis_lr_callback(batch_size=8):\n    lr_start   = 1e-4\n    lr_max     = 0.000015 * REPLICAS * batch_size\n    lr_min     = 1e-5\n    lr_ramp_ep = 3\n    lr_sus_ep  = 0\n    lr_decay   = 0.7\n   \n    def lrfn(epoch):\n        if epoch < lr_ramp_ep:\n            lr = (lr_max - lr_start) \/ lr_ramp_ep * epoch + lr_start\n            \n        elif epoch < lr_ramp_ep + lr_sus_ep:\n            lr = lr_max\n            \n        else:\n            lr = (lr_max - lr_min) * lr_decay**(epoch - lr_ramp_ep - lr_sus_ep) + lr_min\n            \n        return lr\n    plt.figure(figsize=(10, 7))\n    plt.plot([lrfn(i) for i in range(EPOCHS[0])])\n    plt.show()","2d6a9256":"def get_lr_callback(batch_size=8):\n    lr_start   = 1e-5\n    lr_max     = 0.000015 * REPLICAS * batch_size\n    lr_min     = 1e-7\n    lr_ramp_ep = 3\n    lr_sus_ep  = 0\n    lr_decay   = 0.7\n   \n    def lrfn(epoch):\n        if epoch < lr_ramp_ep:\n            lr = (lr_max - lr_start) \/ lr_ramp_ep * epoch + lr_start\n            \n        elif epoch < lr_ramp_ep + lr_sus_ep:\n            lr = lr_max\n            \n        else:\n            lr = (lr_max - lr_min) * lr_decay**(epoch - lr_ramp_ep - lr_sus_ep) + lr_min\n            \n        return lr\n\n    lr_callback = tf.keras.callbacks.LearningRateScheduler(lrfn, verbose=False)\n    return lr_callback","6936e067":"vis_lr_callback(BATCH_SIZES[0])","e632fc7e":"skf = KFold(n_splits=KFOLDS,shuffle=True,random_state=RANDOM_SEED)\noof_pred = []; oof_tar = []; oof_val = []; oof_f1 = []; oof_ids = []; oof_folds = [] \n\nfiles_train_g = np.array(files_train_g)\n\nfor fold,(idxT,idxV) in enumerate(skf.split(files_train_g)):\n    # CREATE TRAIN AND VALIDATION SUBSETS\n    files_train = files_train_g[idxT]\n    np.random.shuffle(files_train);\n    files_valid = files_train_g[idxV]\n    \n    print('#'*25); print('#### FOLD',fold+1)\n    print('#### Image Size: %i | model: %s | batch_size %i'%\n          (IMG_SIZES[fold],EFNS[EFF_NETS[fold]].__name__,BATCH_SIZES[fold]*REPLICAS))\n    train_images = count_data_items(files_train)\n    val_images   = count_data_items(files_valid)\n    print('#### Training: %i | Validation: %i'%(train_images, val_images))\n    \n    # BUILD MODEL\n    K.clear_session()\n    with strategy.scope():\n        model = build_model(IMG_SIZES[fold], ef=EFF_NETS[fold], \n                            count=count_data_items(files_train)\/BATCH_SIZES[fold]\/\/REPLICAS\/\/4)\n    print('#'*25)   \n    # SAVE BEST MODEL EACH FOLD\n    sv = tf.keras.callbacks.ModelCheckpoint(\n        'fold-%i.h5'%fold, monitor='val_auc', verbose=0, save_best_only=True,\n        save_weights_only=True, mode='max', save_freq='epoch')\n   \n    # TRAIN\n    print('Training...')\n    history = model.fit(\n        get_dataset(files_train, shuffle=True, repeat=True,\n                dim=IMG_SIZES[fold], batch_size = BATCH_SIZES[fold]), \n        epochs=EPOCHS[fold], \n        callbacks = [sv, get_lr_callback(BATCH_SIZES[fold])], \n        steps_per_epoch=count_data_items(files_train)\/BATCH_SIZES[fold]\/\/REPLICAS\/\/4,\n        validation_data=get_dataset(files_valid, shuffle=False,\n                repeat=False,dim=IMG_SIZES[fold]),\n        verbose=1\n    )\n    \n    # Loading best model for inference\n    print('Loading best model...')\n    model.load_weights('fold-%i.h5'%fold)  \n    \n    ds_valid = get_dataset(files_valid,labeled=False,return_image_ids=False,\n            repeat=True,shuffle=False,dim=IMG_SIZES[fold],batch_size=BATCH_SIZES[fold]*2)\n    ct_valid = count_data_items(files_valid); STEPS = ct_valid\/BATCH_SIZES[fold]\/2\/REPLICAS\n    pred = model.predict(ds_valid,steps=STEPS,verbose=0)[:ct_valid,] \n    oof_pred.append( np.mean(pred.reshape((ct_valid,1),order='F'),axis=1) )                 \n    \n    # GET OOF TARGETS AND idS\n    ds_valid = get_dataset(files_valid, repeat=False, dim=IMG_SIZES[fold],\n            labeled=True, return_image_ids=True)\n    oof_tar.append( np.array([target.numpy() for img, target in iter(ds_valid.unbatch())]) )\n    \n    # PLOT TRAINING\n    if DISPLAY_PLOT:\n        plt.figure(figsize=(8, 6))\n        sns.distplot(oof_pred[-1])\n        plt.show()\n        \n        plt.figure(figsize=(15,5))\n        plt.plot(np.arange(len(history.history['auc'])),history.history['auc'],'-o',label='Train auc',color='#ff7f0e')\n        plt.plot(np.arange(len(history.history['auc'])),history.history['val_auc'],'-o',label='Val auc',color='#1f77b4')\n        x = np.argmax( history.history['val_auc'] ); y = np.max( history.history['val_auc'] )\n        xdist = plt.xlim()[1] - plt.xlim()[0]; ydist = plt.ylim()[1] - plt.ylim()[0]\n        plt.scatter(x,y,s=200,color='#1f77b4'); plt.text(x-0.03*xdist,y-0.13*ydist,'max auc\\n%.2f'%y,size=14)\n        plt.ylabel('auc',size=14); plt.xlabel('Epoch',size=14)\n        plt.legend(loc=2)\n        plt2 = plt.gca().twinx()\n        plt2.plot(np.arange(len(history.history['auc'])),history.history['loss'],'-o',label='Train Loss',color='#2ca02c')\n        plt2.plot(np.arange(len(history.history['auc'])),history.history['val_loss'],'-o',label='Val Loss',color='#d62728')\n        x = np.argmin( history.history['val_loss'] ); y = np.min( history.history['val_loss'] )\n        ydist = plt.ylim()[1] - plt.ylim()[0]\n        plt.scatter(x,y,s=200,color='#d62728'); plt.text(x-0.03*xdist,y+0.05*ydist,'min loss',size=14)\n        plt.ylabel('Loss',size=14)\n        plt.title('FOLD %i - Image Size %i, %s'%\n                (fold+1,IMG_SIZES[fold],EFNS[EFF_NETS[fold]].__name__),size=18)\n        plt.legend(loc=3)\n        plt.savefig(f'fig{fold}.png')\n        plt.show()","191d9a83":"oof = np.concatenate(oof_pred); true = np.concatenate(oof_tar);\nauc = roc_auc_score(true,oof)\nprint('Overall OOF AUC= %.3f'%auc)","36ce52c2":"# Dataset Creation","306879c9":"# Reading Tfrecords","3d51caba":"# CFG","7b8c1c4f":"# Next steps\n* Generate Test Sets\n* Create Inference Notebook\n* Add augmentation\n* Add TTA Inference","d186370f":"# Build Model","a9d97bf3":"# Training","4468c884":"# Datasets\n* [Spector Power(TFRecords)](https:\/\/www.kaggle.com\/miklgr500\/spector-power-tfrecords)\n    * [G2Net [0-3]](https:\/\/www.kaggle.com\/miklgr500\/g2net-03)\n    * [G2Net [4-7]](https:\/\/www.kaggle.com\/miklgr500\/g2net-47)\n    * [G2Net [8-12]](https:\/\/www.kaggle.com\/miklgr500\/g2net-812)\n    * [G2Net [12-15]](https:\/\/www.kaggle.com\/miklgr500\/g2net-1215)"}}