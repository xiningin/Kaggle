{"cell_type":{"a038dcca":"code","a6e2da59":"code","86308875":"code","77fcce88":"code","bbb170aa":"code","c9d417f7":"code","e2f56b03":"code","aade3e2c":"code","05f00bfd":"code","8198e20e":"code","edf7fdf1":"code","26086c55":"code","3794a0e2":"code","1b1c5eea":"code","e8fe7ad0":"code","3f469fb1":"code","6b31aad2":"code","f9aeb603":"code","634d308e":"code","ce2dc46b":"code","f1b30c2a":"code","66e50b3f":"code","f8a250f2":"code","b5070c7f":"code","705fceea":"code","81119b74":"code","0b151233":"code","97aaf291":"code","c5d3fa75":"code","5b62e4f1":"code","35a1af1b":"code","c1d26263":"code","2b087f9d":"code","d091457f":"code","5fb1b000":"code","ca595805":"code","eca2d426":"code","c87d14d2":"code","f514ff04":"code","6897883b":"code","204c3f48":"code","619f2bf0":"code","76f7e4a5":"code","2753dea1":"code","159aa1d3":"code","22a331c3":"code","45e7dbea":"code","c8c0cdc4":"code","9e9c4f36":"markdown","08ca6d1b":"markdown","fead1d33":"markdown","90506e46":"markdown","f196d682":"markdown","5c293f73":"markdown","01257bef":"markdown","c2e6fd64":"markdown","b4d4f42b":"markdown","32716bd3":"markdown","ef2aef2c":"markdown","ca0aa379":"markdown","3bd2e69b":"markdown","67e0041d":"markdown","09525c13":"markdown","a8469535":"markdown","6d7b6f2e":"markdown","80693dfa":"markdown","8d0f198a":"markdown","27bae758":"markdown","8f805dc5":"markdown","6ff8babe":"markdown","4740f850":"markdown","393adaee":"markdown","0615a0fb":"markdown"},"source":{"a038dcca":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\n#basic imports in this section\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport gc\nimport os\nprint(os.listdir(\"..\/input\"))\nimport time\n\n# Any results you write to the current directory are saved as output.","a6e2da59":"#ignoring any future warnings in the code\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)","86308875":"from kaggle.competitions import twosigmanews\nenv = twosigmanews.make_env()","77fcce88":"#get_training_data is an inbiult kaggle method that returns datasets.\n(market, news) = env.get_training_data()","bbb170aa":"gc.collect()","c9d417f7":"#number of rows in the market dataset\nmarket.shape[0]","e2f56b03":"#number of features in the market dataset\nmarket.shape[1]","aade3e2c":"#datatype of each feature in the market dataset \nmarket.dtypes","05f00bfd":"#number of rows in the news dataset\nnews.shape[0]","8198e20e":"#number of features in the news dataset\nnews.shape[1]","edf7fdf1":"#datatype of each feature in the market dataset \nnews.dtypes","26086c55":"#this method contains code for basic preprocessing of both market and news dataset\n'''\nthis method\n1. converts time feature from market dataset whose datatype is datetime into date datatype\n2. converts time feature from news dataset whose datatype is datetime into float datatype considering only the hours of the entire datetime datatype\n3. converts sourceTimeStamp feature from news dataset whose datatype is datetime into float datatype considering only the hours of the entire datetime datatype\n4. converts firstCreated feature from news dataset whose datatype is datetime into date datatype\n5. converts universe and volume feartures from float datatype to integer datatype\n6. sorts the time columns in both the datasets\n7. places 0 in place of null values, which was proven damaging, hence, dropped the idea\n8. the eval function used will convert string column into a dictionary containing all the assetCodes\n    news['assetCodesLen'] = news['assetCodes'].map(lambda x: len(eval(x))) -> this line takes the length of the column of dictionary that was just created from the cloumn of strings using eval function and figures out how many assetCodes are there in news dataset.\n    news['assetCodes'] = news['assetCodes'].map(lambda x: list(eval(x))[0]) -> this line converts dictionary into a list. It takes the only first value from the list and attaches it to the assetCodes column.\n9. basic rounding of float datatype\n10. returns both, the market and news dataset.\n'''\ndef preprocess_data(market, news):\n    market.time = market.time.dt.date\n    news.time = news.time.dt.hour\n    news.sourceTimestamp = news.sourceTimestamp.dt.hour\n    news.firstCreated = news.firstCreated.dt.date\n    news['assetCodesLen'] = news['assetCodes'].map(lambda x: len(eval(x)))\n    news['assetCodes'] = news['assetCodes'].map(lambda x: list(eval(x))[0])\n    market['volume'] = market.volume.astype(int)\n    market['universe'] = market.universe.astype(int)\n    #this is just an experiment\n    market = market.sort_values('time')\n    news = news.sort_values('time')\n    #if accuracy decreases then change null values to raw values from that same row\n    #just uncomment the next four lines\n    '''columns = ['returnsClosePrevMktres1','returnsOpenPrevMktres1','returnsClosePrevMktres10', 'returnsOpenPrevMktres10']\n    columns_raw = ['returnsClosePrevRaw1', 'returnsOpenPrevRaw1','returnsClosePrevRaw10', 'returnsOpenPrevRaw10']\n    for i in range(len(column_raw)):\n        market[column_market[i]] = market[column_market[i]].fillna(market[column_raw[i]])'''\n    \n    \n    market.round({'close': 2, 'open' : 2, 'returnsClosePrevRaw1' : 4, 'returnsOpenPrevRaw1' : 4, 'returnsClosePrevRaw10' : 4, \n                  'returnsOpenPrevRaw10' : 4, 'returnsOpenNextMktres10' : 4})\n    news.round({'relevance' : 3, 'sentimentNegative' : 3, 'sentimentNeutral' : 3, 'sentimentPositive' : 3})\n    market_num_cols = ['volume', 'close', 'open', 'returnsClosePrevRaw1', 'returnsOpenPrevRaw1', 'returnsClosePrevMktres1',\n                    'returnsOpenPrevMktres1', 'returnsClosePrevRaw10', 'returnsOpenPrevRaw10', 'returnsClosePrevMktres10',\n                    'returnsOpenPrevMktres10']\n    news_num_cols = ['urgency', 'takeSequence', 'bodySize', 'companyCount', 'sentenceCount', 'wordCount', \n                     'firstMentionSentence', 'sentimentClass', 'sentimentNegative', 'sentimentNeutral', 'sentimentPositive', \n                     'sentimentWordCount', 'noveltyCount12H', 'noveltyCount24H', 'noveltyCount3D', 'noveltyCount5D', \n                     'noveltyCount7D', 'volumeCounts12H', 'volumeCounts24H', 'volumeCounts3D', \n                     'volumeCounts5D', 'volumeCounts7D']\n    #this helps reducing the accuracy so we will replace nan values with mean in next phase and comment the next two lines\n    #market[market_num_cols] = market[market_num_cols].fillna(0)\n    #news[news_num_cols] = news[news_num_cols].fillna(0)\n    return market, news;\n[market, news] = preprocess_data(market, news)","3794a0e2":"#this method changes all the nan values in every column by the mean of that respective column.\n#many classifiers cannot handle nan values and hence we have to compromise with the data(either drop row, which is loss of some important data or drop a column, which is also loss of important data, but less damaging than dropping a row)\n#there were only 6 columns remaining after dropping the columns containing nan values.\n#hence we decided to write this method.\n#the plus point of y\\this method is that we can now apply any classifier to the dataset and predict results.\n#the most logical way is to replace nan values by the mean of the column.\n#this way the mean of the column will not be affected and the further process won't get hurt.\ndef handling_nan_values(df):\n    for i in df.columns:\n        print(i, df[i].dtype)\n        \n        if df[i].dtype == \"object\":\n            df[i] = df[i].fillna(\"other\")\n        elif (df[i].dtype == \"int64\" or df[i].dtype == \"float64\" or df[i].dtype == \"int16\" or df[i].dtype == \"int8\" or df[i].dtype == \"int32\" or df[i].dtype == \"float32\"):\n            df[i] = df[i].fillna(df[i].mean())\n            print(i, df[i].mean())\n        else:\n            pass\n    return df","1b1c5eea":"#adjusting outliers\n#rather than removing outliers, we decided to adjust them near to the farthest point after removing that outlier, or in more technical words, clipping the outliers.\n#outliers are the noise in the dataset.\n#they are corrupted data and affects prediction powers of the model severely in a bad way.\n#hence it only makes sense to control these outliers in the dataset by decreasing or increasing its values to a specific value.\n#here, in this method we are clipping all rows that contains outliers to a specified value(0.05 and  0.95).\n#an outlier is a data point which has high variance and its value is far away from the mean\/ average value.\ndef remove_outliers(data_frame, column_list, low=0.05, high=0.95):\n    temp_frame = data_frame\n    for column in column_list:\n        this_column = data_frame[column]\n        quant_df = this_column.quantile([low,high])\n        low_limit = quant_df[low]\n        high_limit = quant_df[high]\n        temp_frame[column] = data_frame[column].clip(lower=low_limit, upper=high_limit)\n    return temp_frame","e8fe7ad0":"#the outliers in the columns of news dataset, mentioned in columns_outliers are handled using the remove_outliers method\n#only the outliers in numerical columns are handled as we are planning to remove categorical columns\ncolumns_outlier = ['takeSequence', 'bodySize', 'sentenceCount', 'wordCount', 'sentimentWordCount', 'firstMentionSentence',\n                   'noveltyCount12H','noveltyCount24H', 'noveltyCount3D', 'noveltyCount5D', 'noveltyCount7D', \n                   'volumeCounts12H', 'volumeCounts24H','volumeCounts3D','volumeCounts5D','volumeCounts7D']\nnews = remove_outliers(news, columns_outlier)","3f469fb1":"#the outliers in market dataset are removed as per the logic mentioned above\nmarket['close_open_ratio'] = np.abs(market['close']\/market['open'])\nthreshold = 0.5\nmarket = market.loc[market['close_open_ratio'] < 1.5]\nmarket = market.loc[market['close_open_ratio'] > 0.5]\nmarket = market.drop(columns=['close_open_ratio'])","6b31aad2":"columns =['returnsClosePrevMktres1','returnsOpenPrevMktres1','returnsClosePrevMktres10', 'returnsOpenPrevMktres10', 'returnsClosePrevRaw1', 'returnsOpenPrevRaw1','returnsClosePrevRaw10', 'returnsOpenPrevRaw10', 'returnsOpenNextMktres10']\nfor column in columns:\n    market = market.loc[market[column]>=-2]\n    market = market.loc[market[column]<=2]","f9aeb603":"#market = market[~market['assetCode'].isin(['PGN.N','EBRYY.OB'])]\nmarket = market[~market['assetName'].isin(['Unknown'])]","634d308e":"market","ce2dc46b":"news","f1b30c2a":"import matplotlib.pyplot as plt\nplot = (market.nunique()).sort_values(ascending=False)\nplot.plot(kind=\"bar\", figsize = (20,10), fontsize = 15)\nplt.xlabel(\"Columns\", fontsize = 15)\nplt.ylabel(\"Unique Values\", fontsize = 15)\nprint('Done!')","66e50b3f":"market.nunique()","f8a250f2":"import matplotlib.pyplot as plt\nplot = (news.nunique()).sort_values(ascending=False)\nplot.plot(kind=\"bar\", figsize = (20,10), fontsize = 15)\nplt.xlabel(\"Columns\", fontsize = 15)\nplt.ylabel(\"Unique Values\", fontsize = 15)\nprint('Done!')","b5070c7f":"news.nunique()","705fceea":"#we will merge dataset based on assetCodes and not assetName because there are unknown values in the assetName column and also we handled the assetCodes column very nicely in data preprocessing\n#we will make a left join on time and assetCode of market data and a righ join on firstCreated and assetCodes. Because in preprocessing part we converted time and firstCreated into date format and assetCode and assetCodes is explained above.\ndef dataset_merge(market, news):\n    grouping_cols = ['firstCreated', 'assetCodes']\n    news = news.groupby(grouping_cols, as_index=False).mean() \n    market = pd.merge(market, news, how='left', left_on= ['time', 'assetCode'], right_on= ['firstCreated', 'assetCodes'])\n    return market\nmarket = dataset_merge(market, news)","81119b74":"pearson_dataframe = market.corr(method= 'pearson') ","0b151233":"pearson_dataframe","97aaf291":"cov_dataframe = market.cov()","c5d3fa75":"cov_dataframe","5b62e4f1":"#plotting the correlation\nimport matplotlib.pyplot as plt\nplt.matshow(pearson_dataframe)\nplt.title(\"pearson correlation chart\\n\")","35a1af1b":"# defining only those columns that are important to the dataset\n# we deduced this result based on prior preprocessing\nreduced_cols = [c for c in market if c not in ['assetCode', 'assetCodes', 'assetCodesLen', 'assetName', 'audiences', 'firstCreated', 'headline', 'headlineTag', 'provider', 'bodySize', 'wordCount', 'returnsOpenNextMktres10', 'sourceId', 'subjects', 'time', 'time_x', 'time_y', 'universe','sourceTimestamp']]","c1d26263":"#we will make target variable in this section\ntarget = market.returnsOpenNextMktres10 >= 0\ntarget = target.values\nop = market.returnsOpenNextMktres10.values","2b087f9d":"reduced_cols","d091457f":"market = market[reduced_cols]","5fb1b000":"market","ca595805":"#after making a left join on the dataset, there will be some nan values in the combined dataset.\n#hence we will call handling_nan_values method again\nmarket = handling_nan_values(market)","eca2d426":"# we will scale the merged dataset using standard scaler.\n# there are other approaches using min-max scaler, etc. \n# but we chose standard scaler because it handles categorical data which min-max fails to handle.\n# the range of standard scaler is typically [-2, 4] while the range of min-max scaler is [0, 1] which will not give us important data to classify a stock as negative\nfrom sklearn.preprocessing import StandardScaler\n\ndata_scaler = StandardScaler()\nmarket[reduced_cols] = data_scaler.fit_transform(market[reduced_cols])","c87d14d2":"from sklearn.decomposition import PCA\npca = PCA(n_components=27)\nmarket = pca.fit_transform(market)  \n#market = pca.transform(market)","f514ff04":"market.shape[1]","6897883b":"op","204c3f48":"#spliting the dataset using test_train_split\n#our next task is to split using time series as the dataset contains time related data\nfrom sklearn import *\nX_train, X_test, target_train, target_test, op_train, op_test = model_selection.train_test_split(market, target, op, test_size=0.2, random_state=5)","619f2bf0":"X_train","76f7e4a5":"#fitting the dataset using CatBoost classifier\nfrom catboost import CatBoostClassifier\nt = time.time()\ncat = CatBoostClassifier(thread_count=4, n_estimators=200, max_depth=8, eta=0.1, loss_function='Logloss' , verbose=10)\ncat.fit(X_train, target_train)\nprint(f'Done, time = {time.time() - t}')","2753dea1":"#printing the confusion matrix and accuracy using built in library\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score\nt = time.time()\ntarget_test, prediction = target_test, cat.predict(X_test)\nprint(classification_report(target_test, prediction))\nprint(\"Detailed confusion matrix:\")\nprint(confusion_matrix(target_test, prediction))\nprint(prediction)\nprint(accuracy_score(target_test, prediction))\nprint(f'Done, time = {time.time() - t}')","159aa1d3":"from sklearn.metrics import mean_squared_error\nmean_squared_error(target_test, prediction)","22a331c3":"ycat_pred_proba = cat.predict_proba(X_test)[::,1]\nfpr, tpr, _ = metrics.roc_curve(target_test,  ycat_pred_proba)\nauc = metrics.roc_auc_score(target_test, ycat_pred_proba)\nplt.figure()\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.plot([0, 1], [0, 1], color='navy', linestyle='--')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.plot(fpr, tpr, color='blue', lw=2, label=\"roc curve\" % auc)\nplt.legend(loc=\"lower right\")\nplt.show()","45e7dbea":"confidence_test = cat.predict_proba(X_test)[:,1]*2 -1\nprint(accuracy_score(confidence_test>0,target_test))\nplt.hist(confidence_test, bins='auto')\nplt.title(\"Cat predicted confidence\")\nplt.show()","c8c0cdc4":"# distribution of confidence that will be used as submission\nplt.hist(confidence_test, bins='auto', label='Prediciton')\nplt.hist(op_test, bins='auto',alpha=0.8, label='True data')\nplt.title(\"predicted confidence\")\nplt.legend(loc='best')\nplt.xlim(-1,1)\nplt.show()","9e9c4f36":"**ROC curve**","08ca6d1b":"**Correlation among data** : Pearson Correlation","fead1d33":"the difference between open and close values can not be too much. The threshold in following code can be changed as per convenience. The lower threshold is 0.5 and upper threshold is 1.5. Every row not in the range[0.5, 1.5] will be dropped. Because those are noise data points.","90506e46":"> **Data Description**","f196d682":"The accuracy is decreasing when PCA is applied with less n_components, hence we will keep large values in n_components such as 20, 25, etc because the dataset is such that the model will require more data than a threshold to predict correctly","5c293f73":"**Simple garbage collection**","01257bef":"**merging the dataset in next section**","c2e6fd64":"#fitting the dataset using XGBoost classifier\nfrom xgboost import XGBClassifier\nt = time.time()\nxgb = XGBClassifier(n_jobs=4, n_estimators=200, max_depth=8, eta=0.1)\nxgb.fit(X_train, target_train)\nprint(f'Done, time = {time.time() - t}')","b4d4f42b":"**Visualizing both datasets**","32716bd3":"**Inferences based on the correlation matrix:**\nThe pairs having >0.7 correlation are asfollows:\n1. (open, close)\n2. (returnsClosePrevMktres1, returnsClosePrevRaw1)\n3. (returnsOpenPrevRaw1, returnsOpenPrevMktres1)\n4. (returnsOpenPrevRaw10, returnsClosePrevRaw10)\n5. (returnsOpenPrevMktres10, returnsOpenPrevRaw10)\n6. (returnsOpenPrevMktres10, returnsClosePrevMktres10)\n7. (time_y, source_time_stamp)\n8. (body_size, sentenceCount)\n9. (body_size, wordCount)\n10. (sentenceCount, wordCount)\n11. (sentimentClass, sentimentPositive) and \n12. every columns of valueCounts","ef2aef2c":"**Loading the Two Sigma environment.**","ca0aa379":"**CatBoost next**","3bd2e69b":"\n**Next is the function to remove outliers.**","67e0041d":"#printing the confusion matrix and accuracy using built in library\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score\nt = time.time()\ntarget_test, prediction = target_test, xgb.predict(X_test)\nprint(classification_report(target_test, prediction))\nprint(\"Detailed confusion matrix:\")\nprint(confusion_matrix(target_test, prediction))\nprint(prediction)\naccuracy_score(target_test, prediction)\nprint(f'Done, time = {time.time() - t}')","09525c13":"**Covariance among data**","a8469535":"**Preprocessing starts from here!**","6d7b6f2e":"Two datasets, namely, market dataset and news dataset will be loaded in market and news dataframes respectively","80693dfa":"If returns exceed by 50% or fall by 50% of their value then the data is noisy data","8d0f198a":"changing nan values by mean alues of the feature","27bae758":"market_num_cols = ['volume', 'close', 'open', 'returnsClosePrevRaw1', 'returnsOpenPrevRaw1', 'returnsClosePrevMktres1', 'returnsOpenPrevMktres1', 'returnsClosePrevRaw10', 'returnsOpenPrevRaw10', 'returnsClosePrevMktres10', 'returnsOpenPrevMktres10', 'urgency', 'takeSequence', 'companyCount', 'marketCommentary', 'sentenceCount', 'firstMentionSentence', 'relevance', 'sentimentClass', 'sentimentNegative', 'sentimentNeutral', 'sentimentPositive', 'sentimentWordCount', 'noveltyCount12H', 'noveltyCount24H', 'noveltyCount3D', 'noveltyCount5D', 'noveltyCount7D', 'volumeCounts12H', 'volumeCounts24H', 'volumeCounts3D', 'volumeCounts5D', 'volumeCounts7D']\nmarket[market_num_cols] = market[market_num_cols].fillna(0)","8f805dc5":"There's no need perform one hot encoding on string columns because tree-like classifiers can easily handle those.","6ff8babe":"We already filled nan values by the mean.... so no need of the next block anymore","4740f850":"**outliers for market data**","393adaee":"removing data having unknown asset name","0615a0fb":"**outliers for news data**"}}