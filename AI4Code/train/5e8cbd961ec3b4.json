{"cell_type":{"524f1892":"code","a0b65ce8":"code","a5ee389d":"code","00d614dd":"code","aa31e088":"code","664a5d44":"code","9e1d4a55":"code","05fc050f":"code","e7fceb94":"code","31d0df08":"code","7f6d3eb0":"code","2b34c3f4":"code","41acb03c":"code","056002c0":"code","a1bf0d22":"code","b3d5deeb":"code","5011a70d":"markdown","aaeafc3b":"markdown"},"source":{"524f1892":"# loading a simple library I created that scales, imputes and one-hot encodes the data.\n\n!pip install git+https:\/\/github.com\/sd274\/pipeline_tools.git\n","a0b65ce8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pipeline_tools as pt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\nfrom sklearn.pipeline import Pipeline\nimport xgboost as xgb\nimport optuna","a5ee389d":"df = pd.read_csv('\/kaggle\/input\/weather-dataset-rattle-package\/weatherAUS.csv')","00d614dd":"df.head()","aa31e088":"df.describe(include='object')","664a5d44":"df.describe(exclude='object')","9e1d4a55":"df.columns","05fc050f":"cat_features = [\n    'Location',\t\n    'WindGustDir',\n    'WindDir9am',\n    'WindDir3pm',\n    'RainToday',\n]\n\nnum_features = [\n    'MinTemp',\n    'MaxTemp',\n    'Rainfall',\n    'Evaporation',\n    'Sunshine',\n    'WindGustSpeed',\n    'WindSpeed9am',\n    'WindSpeed3pm',\n    'Humidity9am',\n    'Humidity3pm',\n    'Pressure9am',\n    'Pressure3pm'\n]\n\ntarget = 'RainTomorrow'","e7fceb94":"X = df[cat_features + num_features]\ny = pd.get_dummies(df[target])[['Yes']]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)","31d0df08":"pre_pipe = pt.standard_preprocessing_pipe(cat_features=cat_features, num_features=num_features)\n\npipe = Pipeline([\n    ('pre_pipe', pre_pipe),\n    ('learn', xgb.XGBClassifier(random_state=42, use_label_encoder=False, eval_metric='logloss'))\n])","7f6d3eb0":"def objective(trial,data=X_train,target=y_train):\n    train_x, test_x, train_y, test_y = train_test_split(data, target, test_size=0.15,random_state=42)\n    param = {\n#         'learn__tree_method':'gpu_hist',  # this parameter means using the GPU when training our model to speedup the training process\n        'learn__reg_lambda': trial.suggest_loguniform('learn__reg_lambda', 1e-3, 10.0),\n        'learn__reg_alpha': trial.suggest_loguniform('learn__reg_alpha', 1e-3, 10.0),\n        'learn__colsample_bytree': trial.suggest_categorical('learn__colsample_bytree', [0.3,0.4,0.5,0.6,0.7,0.8,0.9, 1.0]),\n        'learn__subsample': trial.suggest_categorical('learn__subsample', [0.4,0.5,0.6,0.7,0.8,1.0]),\n        'learn__learning_rate': trial.suggest_categorical('learn__learning_rate', [0.001, 0.003,0.03,0.3,0.6]),\n        'learn__n_estimators': trial.suggest_int(\"learn__n_estimators\", 100, 1000),\n        'learn__max_depth': trial.suggest_categorical('learn__max_depth', [5,7,9,11,13,15,17,20]),\n        'learn__random_state': trial.suggest_categorical('learn__random_state', [24, 48,2020]),\n    }\n#     try:\n    pipe.set_params(**param)\n\n    pipe.fit(train_x, train_y)\n\n#     preds = pipe.predict_proba(test_x)[:,1]\n    preds = pipe.predict(test_x)\n\n    score = metrics.accuracy_score(test_y, preds)\n\n    return score\n#     except:\n#         return None","2b34c3f4":"study = optuna.create_study(direction='maximize')\nstudy.optimize(objective, n_trials=50)\nprint('Number of finished trials:', len(study.trials))\nprint('Best trial:', study.best_trial.params)","41acb03c":"print('Number of finished trials:', len(study.trials))\nprint('Best trial:', study.best_trial.params)\nprint('Best Score: ', study.best_trial.value)","056002c0":"best_params = study.best_trial.params\n\nbest_params","a1bf0d22":"pipe.set_params(**best_params)\n\npipe.fit(X_train, y_train)","b3d5deeb":"from sklearn import metrics\n\ntest_prediction = pipe.predict_proba(X_test)[:,1]\npredictions = pipe.predict(X_test)\n\nscore = metrics.roc_auc_score(y_test, test_prediction)\naccuracy = metrics.accuracy_score(y_test, predictions)\n\nprint(f'Area under ROC of Model On Test Set - {score:,.2%}')\nprint(f'Accuracy - {accuracy:,.2%}')","5011a70d":"There are some missing values. We will ignore the categorical ones for now and impute the numerical ones.","aaeafc3b":"# Build a Basic Pipe"}}