{"cell_type":{"eab7c8d6":"code","e88e4cd5":"code","a2ad61ec":"code","a29079ea":"code","7a962e79":"code","f329ed9c":"code","7c0d1d2c":"code","119288e4":"code","762899ea":"markdown","d2c7d94b":"markdown","4a43ad06":"markdown","38984a72":"markdown","3bed9ea6":"markdown","cefa924c":"markdown","f2b6d048":"markdown","0356e15d":"markdown","3094a00a":"markdown","1fcdc0a2":"markdown"},"source":{"eab7c8d6":"import numpy as np\nimport pandas as pd\nimport os\nimport statsmodels.api as sm\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","e88e4cd5":"def extract_feature(play, is_train=True):\n    \n    if play['PlayDirection'].iloc[0] == 'right':\n        direction = 1\n    else:\n        direction = -1\n        \n    home, away = play['Team'].values == 'home', play['Team'].values == 'away'\n    indRusher = np.where(play['NflId'].values == play['NflIdRusher'].iloc[0])[0][0]\n\n    if play['FieldPosition'].iloc[0] == play['PossessionTeam'].iloc[0]:\n        yardToGoal = 100 - play['YardLine'].iloc[0]\n        start = np.array([120 + (play['YardLine'].iloc[0] + 10) * direction, 53.3 \/ 2]) % 120\n    else:\n        yardToGoal = play['YardLine'].iloc[0]\n        start = np.array([120 - (play['YardLine'].iloc[0] + 10) * direction, 53.3 \/ 2]) % 120\n\n    Dir = play['Dir'].values\n    rad = np.nan_to_num(2 * np.pi * (90 - Dir) \/ 360)\n    x, y = play['X'].values, play['Y'].values\n    S = play['S'].values * np.logical_not(np.isnan(Dir))\n    A = play['A'].values * np.logical_not(np.isnan(Dir))\n\n    loc = np.vstack([x - start[0], y - start[1]]).T * direction\n    vel = (S * np.vstack([np.cos(rad), np.sin(rad)])).T * direction\n    acc = (A * np.vstack([np.cos(rad), np.sin(rad)])).T * direction\n    locRusher, velRusher, accRusher = loc[indRusher], vel[indRusher], acc[indRusher]\n\n    diff = np.hstack([np.square(loc - locRusher), np.square(vel - velRusher), np.square(acc - accRusher)])\n\n    scrimWidth = 5\n    inTheBox = (play['NflId'].values != play['NflIdRusher'].iloc[0]) * (np.abs(loc[:, 0]) < scrimWidth)\n\n    locDet = np.linalg.slogdet(np.exp(- np.square(loc[inTheBox, np.newaxis] - loc[inTheBox][np.newaxis]).sum(2) \/ 2.))[1]\n    locHomeDet = np.linalg.slogdet(np.exp(- np.square(loc[home * inTheBox][:, np.newaxis] - loc[home * inTheBox][np.newaxis]).sum(2) \/ 2.))[1]\n    locAwayDet = np.linalg.slogdet(np.exp(- np.square(loc[away * inTheBox][:, np.newaxis] - loc[away * inTheBox][np.newaxis]).sum(2) \/ 2.))[1]\n\n    if play['PossessionTeam'].iloc[0] == play['HomeTeamAbbr'].iloc[0]:\n        x = np.hstack([diff[home].sum(0), diff[away].sum(0), locDet, locHomeDet, locAwayDet])\n    else: \n        x = np.hstack([diff[away].sum(0), diff[home].sum(0), locDet, locAwayDet, locHomeDet])\n        \n    x = np.hstack([locRusher, velRusher, accRusher, x, (downs == play['Down'].iloc[0]).astype(np.float), (teams == play['PossessionTeam'].iloc[0]).astype(np.float)])    \n    \n    offset = locRusher[0] - 5\n    threshold = play['Distance'].iloc[0] - offset\n    \n    if is_train:\n         \n        yard = play['Yards'].iloc[0] - offset\n        \n        c = yard < threshold\n        y = np.minimum(yard, threshold)\n        \n        return x, y, c, offset\n    \n    else:\n        return x, offset","a2ad61ec":"data = pd.read_csv('\/kaggle\/input\/nfl-big-data-bowl-2020\/train.csv', low_memory=False)\n\ndata.loc[data.HomeTeamAbbr.values == \"ARI\", 'HomeTeamAbbr'] = \"ARZ\"\ndata.loc[data.HomeTeamAbbr.values == \"BAL\", 'HomeTeamAbbr'] = \"BLT\"\ndata.loc[data.HomeTeamAbbr.values == \"CLE\", 'HomeTeamAbbr'] = \"CLV\"\ndata.loc[data.HomeTeamAbbr.values == \"HOU\", 'HomeTeamAbbr'] = \"HST\"\n\ndata.loc[data['Season'] == 2017, 'S'] = (data['S'][data['Season'] == 2017] - 2.4355) \/ 1.2930 * 1.4551 + 2.7570\n\ndowns = np.array([1, 2, 3])\nteams = pd.get_dummies(data['PossessionTeam']).columns[:-1]\n\ntrain = data\nn_train = train.shape[0] \/\/ 22","a29079ea":"inds = list(train.groupby('PlayId').groups.values())\n\nxs, ys, cs = [], [], []\n\nfor i in range(n_train):\n\n    ind = inds[i]\n    play = train.loc[ind]\n    x, y, c, _ = extract_feature(play)\n\n    xs.append(x)\n    ys.append(y)\n    cs.append(c)\n\nxs, ys, cs = np.vstack(xs), np.hstack(ys), np.array(cs).astype(np.int)\nys = np.maximum(0, ys)","7a962e79":"model = sm.PHReg(ys, xs, cs)\nresult = model.fit()\n\nbaseline_cum_hazard_func = result.baseline_cumulative_hazard_function[0]\npred_index = np.arange(-99, 100)","f329ed9c":"from kaggle.competitions import nflrush\nenv = nflrush.make_env()","7c0d1d2c":"for (play, prediction_df) in env.iter_test():\n    \n    play.loc[play.HomeTeamAbbr.values == \"ARI\", 'HomeTeamAbbr'] = \"ARZ\"\n    play.loc[play.HomeTeamAbbr.values == \"BAL\", 'HomeTeamAbbr'] = \"BLT\"\n    play.loc[play.HomeTeamAbbr.values == \"CLE\", 'HomeTeamAbbr'] = \"CLV\"\n    play.loc[play.HomeTeamAbbr.values == \"HOU\", 'HomeTeamAbbr'] = \"HST\"\n    \n    x, offset = extract_feature(play, False)\n    \n    cum_hazard = np.exp(result.params.dot(x)) * baseline_cum_hazard_func(pred_index - offset)\n    pred = 1 - np.exp(- cum_hazard)\n    \n    if play['FieldPosition'].iloc[0] == play['PossessionTeam'].iloc[0]:\n        yardToGoal = 100 - play['YardLine'].iloc[0]\n    else:\n        yardToGoal = play['YardLine'].iloc[0]\n\n    pred \/= pred[pred_index <= yardToGoal][-1]\n    pred[pred_index > yardToGoal] = 1.\n    \n    prediction_df = pd.DataFrame(pred[np.newaxis], columns=prediction_df.columns)\n    \n    env.predict(prediction_df)","119288e4":"env.write_submission_file()","762899ea":"# Load data","d2c7d94b":"# Cox proportional hazard model","4a43ad06":"Survival analysis mainly focus on explaining the duration of time until some events happen. In survival analysis, our aim is to express the hazard function instead of probability density function, which is defined as\n\n$$\n\\begin{aligned}\nh(t) = \\lim_{\\Delta t \\to 0} \\frac{\\mathrm{Pr}(t \\leq T < t + \\Delta t \\mid T \\geq t)}{\\Delta t}, \\quad t \\geq 0.\n\\end{aligned}\n$$\n\n**Cox proportional model** divides this hazard function into two parts as\n\n$$\n\\begin{aligned}\n    &h(t) = h_0(t) \\exp(X \\beta), \\quad \\\\\n    &\\text{$X$ : covariates, $\\beta$: parameter.}\n\\end{aligned}\n$$\n\n\nThe former part indicates how the hazard function depends on time and the latter part indicates how it depends on the covariate information.  Estimating the former part in empirical manner enables us to express the complex distribution easily.","38984a72":"# Setup","3bed9ea6":"In this notebook, we consider that the distance obtained by ball carrier as duration of time until event happens. We adopt simple linear model with players location, velocity, acceralation, counts of down, team as covariates.","cefa924c":"# Estimate parameters of Cox proportional model","f2b6d048":"## Define function for etracting features from raw dataset ","0356e15d":"The yardage gained on the play distributes to a one-dimenstional distribution which depends on rushing plays information. This notebook adopts **Cox proportional hazard model** to express this distribution and shows the advantage of suvival analysis approach in this competition.","3094a00a":"# Predict ","1fcdc0a2":"# Extract features from training dataset"}}