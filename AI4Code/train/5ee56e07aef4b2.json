{"cell_type":{"059add91":"code","34d95ecd":"code","3aae55cd":"code","dee04c8e":"code","c98584d0":"code","3f5909ae":"code","2c84dd41":"code","d5a3803e":"code","12a74988":"code","195fda7a":"markdown","8e394138":"markdown","e0d0ca82":"markdown","ade59293":"markdown","474d3764":"markdown","8dc57649":"markdown","b5aa8641":"markdown"},"source":{"059add91":"import numpy as np\nimport pandas as pd\nimport scipy.optimize as opt\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm_notebook\nfrom datetime import datetime, timedelta\nfrom sklearn.metrics import mean_squared_log_error\nimport warnings; warnings.filterwarnings('ignore')","34d95ecd":"train = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-1\/train.csv')\ntrain['Date'] = pd.to_datetime(train['Date'])\ntest = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-1\/test.csv')\ntest['Date'] = pd.to_datetime(test['Date'])\nsub = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-1\/submission.csv')\nsub['ForecastId'] = test['ForecastId'].values\nsub = sub.set_index('ForecastId', drop=True)\ntrain","3aae55cd":"# Only use data up to 11\/03 to get a public LB score\nprint(len(train))\neval = train[train[\"Date\"] >= min(test['Date'])]\ntrain = train[train[\"Date\"] < min(test['Date'])]\nprint(len(train))","dee04c8e":"def sigmoid(t, M, beta, alpha):\n    return M \/ (1 + np.exp(-beta * (t - alpha)))\n\nsigmoid_models = {}\ndef forecast(data, steps, key=None):\n    if sum(data) == 0 or sum(data != 0) <= 3:\n        return [data[-1]] * steps\n    \n    filtered_data = data[data > 0]\n    \n    try:\n        def error(params):\n            M, beta, alpha = params\n            return np.sqrt(mean_squared_log_error(filtered_data, sigmoid(list(range(sum(data == 0), len(data))), M, beta, alpha)))\n        res = opt.minimize(error, x0=[1000, 0.25, 100])\n        M, beta, alpha = res.x\n        sigmoid_models[key] = (M, beta, alpha)\n        return np.clip(sigmoid(list(range(len(data), len(data) + steps)), M, beta, alpha), 0, None).astype(int)\n    except:\n        try:\n            popt, pcov = opt.curve_fit(sigmoid, list(range(sum(data == 0), len(data))), \n                                       filtered_data, maxfev=10000, p0=[1000, 0.25, 100])\n            M, beta, alpha = popt\n            sigmoid_models[key] = (M, beta, alpha)\n            return np.clip(sigmoid(list(range(len(data), len(data) + steps)), M, beta, alpha), 0, None).astype(int)\n        except:\n            print(key)\n            return [data[-1]] * steps\n    \n\n\nfor country in tqdm_notebook(np.unique(train['Country\/Region'])):\n    country_data = train[(train['Country\/Region'] == country)]\n    country_data = country_data.sort_values(by='Date')\n    if country not in ['US', 'China', 'Canada', 'Australia', 'France', 'United Kingdom', 'Netherlands', 'Denmark', 'Cruise Ship']:\n        country_test_data = test[test['Country\/Region'] == country].sort_values(by='Date')\n        sub.loc[country_test_data['ForecastId'], 'ConfirmedCases'] = forecast(country_data['ConfirmedCases'].values, len(country_test_data), key=(country, np.NaN, 'ConfirmedCases'))\n        sub.loc[country_test_data['ForecastId'], 'Fatalities'] = forecast(country_data['Fatalities'].values, len(country_test_data), key=(country, np.NaN, 'Fatalities'))\n    else:\n        for region in np.unique(country_data['Province\/State']):\n            region_data = country_data[country_data['Province\/State'] == region]\n            region_data = region_data.sort_values(by='Date')\n            \n            region_test_data = test[(test['Country\/Region'] == country) & (test['Province\/State'] == region)].sort_values(by='Date')\n            sub.loc[region_test_data['ForecastId'], 'ConfirmedCases'] = forecast(region_data['ConfirmedCases'].values, len(region_test_data), key=(country, region, 'ConfirmedCases'))\n            sub.loc[region_test_data['ForecastId'], 'Fatalities'] = forecast(region_data['Fatalities'].values, len(region_test_data), key=(country, region, 'Fatalities'))","c98584d0":"random_key_ix = list(np.random.choice(list(range(len(sigmoid_models))), 22, replace=False))\nrandom_keys = [list(sigmoid_models.keys())[ix] for ix in random_key_ix] + [('Austria', np.NaN, 'ConfirmedCases'), ('Italy', np.NaN, 'ConfirmedCases'), ('Belgium', np.NaN, 'ConfirmedCases')]\nf, ax = plt.subplots(5, 5, figsize=(20, 20))\nfor i, key in enumerate(random_keys):\n    country, region, task = key\n    \n    filtered_data = train[(train['Country\/Region'] == country)]\n    if not pd.isnull(region):\n        filtered_data = filtered_data[(filtered_data['Province\/State'] == region)]\n        \n    filtered_eval_data = eval[(eval['Country\/Region'] == country)]\n    if not pd.isnull(region):\n        filtered_eval_data = filtered_eval_data[(filtered_eval_data['Province\/State'] == region)]\n        \n    x = list(range(len(country_data)))\n    x += list(range(len(x), len(x) + 25))\n    \n    M, beta, alpha = sigmoid_models[key]\n    ax[i \/\/ 5][i % 5].plot(x, sigmoid(x, M, beta, alpha))\n    ax[i \/\/ 5][i % 5].scatter(list(range(len(filtered_data))), filtered_data[task].values)\n    ax[i \/\/ 5][i % 5].scatter(list(range(len(filtered_data), len(filtered_data) + len(filtered_eval_data))), filtered_eval_data[task].values)\n    ax[i \/\/ 5][i % 5].set_title('{} ({}, {})'.format(task, country, region), fontsize=8)\nplt.show()","3f5909ae":"eval1 = eval.merge(test, how='left', on=['Date', 'Country\/Region', 'Province\/State'])\neval1 = eval1.merge(sub, left_on=['ForecastId'], right_index=True)\nscore_c = np.sqrt(mean_squared_log_error(eval1['ConfirmedCases_x'].values, eval1['ConfirmedCases_y']))\nscore_f = np.sqrt(mean_squared_log_error(eval1['Fatalities_x'].values, eval1['Fatalities_y']))\n\nprint(f'score_c: {score_c}, score_f: {score_f}, mean: {np.mean([score_c, score_f])}')","2c84dd41":"plt.scatter(np.log1p(eval1['ConfirmedCases_x'].values), np.log1p(eval1['ConfirmedCases_y']))","d5a3803e":"plt.scatter(np.log1p(eval1['Fatalities_x'].values), np.log1p(eval1['Fatalities_y']))","12a74988":"sub.to_csv('submission.csv')","195fda7a":"# [STATISTICAL APPROACH FOR MAKING PREDICTIONS OF CONFIRMED INFECTION AND DEATHS ON CORONA VIRUS](https:\/\/assets.tue.nl\/fileadmin\/content\/pers\/2020\/03%20March\/TUe%20-%20Technical_Report_Prediction_Corona_Virus.pdf)\n\nI will be reimplementing the model proposed by researchers from TU Eindhoven in this notebook. They proposed to fit a simple sigmoid function to each of the measurements of a country:\n![image.png](attachment:image.png)\nwith M the maximal number of cases, \ud835\udefc the number of days at which the expected number of counts is half way the maximum,and \ud835\udefd > 0 the growth parameter.\n\n**Special caution should be taken with exponential models such as these though... I am not saying that this is the ideal approach, I am merely replicating their study**\n\n**!!! IMPORTANT: The public test set overlaps with the training set !!! We have to filter out data from after 11\/03 in order to get an accurate public LB score**","8e394138":"# Write away our submission","e0d0ca82":"# Load in our data","ade59293":"# Plot some of our fitted models","474d3764":"# Calculate public LB score","8dc57649":"# Fit sigmoid model for each country \/ region combination","b5aa8641":"# Remove overlap between train and test set"}}