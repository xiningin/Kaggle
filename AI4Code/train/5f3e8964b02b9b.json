{"cell_type":{"34b1e322":"code","84ff7ec9":"code","461ebca7":"code","c663685a":"code","2cf3e23e":"code","a3cf4282":"code","8c84f0da":"code","b6ffcc00":"code","39e42f99":"code","b9d8bc32":"code","56e19659":"code","ce16d1c5":"code","b46c6d74":"code","eb0ee877":"code","e68b986d":"code","4faff7dd":"code","23bf00ce":"code","1996d42a":"code","543dc5ed":"code","0bc4f847":"code","a4de863b":"code","ff01412c":"code","19a4423e":"code","fd091d92":"code","a638b43d":"code","6fa3fda3":"code","797cf70e":"code","e6b282cc":"code","89ac88d4":"code","770165f9":"code","081d1fbb":"code","737afd96":"code","b0827fe6":"code","6336ec0d":"code","c46b446d":"code","49d566a0":"code","160ec895":"code","3c595ef9":"code","898606e2":"code","8df77786":"code","1518eb50":"code","d692557a":"code","f0a2c628":"code","bf053de1":"code","b1bb0ac6":"code","f564b7dd":"markdown","4e70481e":"markdown","2f441426":"markdown"},"source":{"34b1e322":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","84ff7ec9":"train = pd.read_csv(\"\/kaggle\/input\/omletcomments\/train.csv\")","461ebca7":"train.shape","c663685a":"# !pip install transformers\n!pip install pytorch_lightning==0.8.1","2cf3e23e":"import argparse\nimport glob\nimport os\nimport json\nimport time\nimport logging\nimport random\nimport re\nfrom itertools import chain\nfrom string import punctuation\n\nimport nltk\nnltk.download('punkt')\nfrom nltk.tokenize import sent_tokenize\n\nimport pandas as pd\nimport numpy as np\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nimport pytorch_lightning as pl\n","a3cf4282":"train.head()","8c84f0da":"train.shape","b6ffcc00":"pl.__version__","39e42f99":"pip install transformers==4.0.0rc1","b9d8bc32":"from transformers import (\n    AdamW,\n    MT5ForConditionalGeneration,\n    AutoTokenizer,\n    get_linear_schedule_with_warmup\n)","56e19659":"def set_seed(seed):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed_all(seed)\n\nset_seed(42)","ce16d1c5":"import pytorch_lightning as pl\n","b46c6d74":"class T5FineTuner(pl.LightningModule):\n    def __init__(self, hparams):\n        super(T5FineTuner, self).__init__()\n        self.hparams = hparams\n\n        self.model = MT5ForConditionalGeneration.from_pretrained(hparams.model_name_or_path)\n        self.tokenizer = AutoTokenizer.from_pretrained(hparams.tokenizer_name_or_path)\n\n    def is_logger(self):\n        return True\n\n    def forward(\n            self, input_ids, attention_mask=None, decoder_input_ids=None, decoder_attention_mask=None, labels=None\n    ):\n        return self.model(\n            input_ids,\n            attention_mask=attention_mask,\n            decoder_input_ids=decoder_input_ids,\n            decoder_attention_mask=decoder_attention_mask,\n            labels=labels,\n        )\n\n    def _step(self, batch):\n        labels = batch[\"target_ids\"]\n        labels[labels[:, :] == self.tokenizer.pad_token_id] = -100\n\n        outputs = self(\n            input_ids=batch[\"source_ids\"],\n            attention_mask=batch[\"source_mask\"],\n            labels=labels,\n            decoder_attention_mask=batch['target_mask']\n        )\n\n        loss = outputs[0]\n\n        return loss\n\n    def training_step(self, batch, batch_idx):\n        loss = self._step(batch)\n\n        tensorboard_logs = {\"train_loss\": loss}\n        return {\"loss\": loss, \"log\": tensorboard_logs}\n\n    def training_epoch_end(self, outputs):\n        avg_train_loss = torch.stack([x[\"loss\"] for x in outputs]).mean()\n        tensorboard_logs = {\"avg_train_loss\": avg_train_loss}\n        return {\"avg_train_loss\": avg_train_loss, \"log\": tensorboard_logs, 'progress_bar': tensorboard_logs}\n\n    def validation_step(self, batch, batch_idx):\n        loss = self._step(batch)\n        return {\"val_loss\": loss}\n\n    def validation_epoch_end(self, outputs):\n        avg_loss = torch.stack([x[\"val_loss\"] for x in outputs]).mean()\n        tensorboard_logs = {\"val_loss\": avg_loss}\n        return {\"avg_val_loss\": avg_loss, \"log\": tensorboard_logs, 'progress_bar': tensorboard_logs}\n\n    def configure_optimizers(self):\n        \"Prepare optimizer and schedule (linear warmup and decay)\"\n\n        model = self.model\n        no_decay = [\"bias\", \"LayerNorm.weight\"]\n        optimizer_grouped_parameters = [\n            {\n                \"params\": [p for n, p in model.named_parameters() if not any(nd in n for nd in no_decay)],\n                \"weight_decay\": self.hparams.weight_decay,\n            },\n            {\n                \"params\": [p for n, p in model.named_parameters() if any(nd in n for nd in no_decay)],\n                \"weight_decay\": 0.0,\n            },\n        ]\n        optimizer = AdamW(optimizer_grouped_parameters, lr=self.hparams.learning_rate, eps=self.hparams.adam_epsilon)\n        self.opt = optimizer\n        return [optimizer]\n\n    def optimizer_step(self, epoch, batch_idx, optimizer, optimizer_idx, second_order_closure=None):\n        if self.trainer.use_tpu:\n            xm.optimizer_step(optimizer)\n        else:\n            optimizer.step()\n        optimizer.zero_grad()\n        self.lr_scheduler.step()\n\n    def get_tqdm_dict(self):\n        tqdm_dict = {\"loss\": \"{:.3f}\".format(self.trainer.avg_loss), \"lr\": self.lr_scheduler.get_last_lr()[-1]}\n\n        return tqdm_dict\n\n    def train_dataloader(self):\n        train_dataset = get_dataset(tokenizer=self.tokenizer, type_path=\"train\", args=self.hparams)\n        dataloader = DataLoader(train_dataset, batch_size=self.hparams.train_batch_size, drop_last=True, shuffle=True,\n                                num_workers=4)\n        t_total = (\n                (len(dataloader.dataset) \/\/ (self.hparams.train_batch_size * max(1, self.hparams.n_gpu)))\n                \/\/ self.hparams.gradient_accumulation_steps\n                * float(self.hparams.num_train_epochs)\n        )\n        scheduler = get_linear_schedule_with_warmup(\n            self.opt, num_warmup_steps=self.hparams.warmup_steps, num_training_steps=t_total\n        )\n        self.lr_scheduler = scheduler\n        return dataloader\n\n    def val_dataloader(self):\n        val_dataset = get_dataset(tokenizer=self.tokenizer, type_path=\"valid\", args=self.hparams)\n        return DataLoader(val_dataset, batch_size=self.hparams.eval_batch_size, num_workers=4)\n","eb0ee877":"logger = logging.getLogger(__name__)\n\nclass LoggingCallback(pl.Callback):\n        def on_validation_end(self, trainer, pl_module):\n            logger.info(\"***** Validation results *****\")\n            if pl_module.is_logger():\n                  metrics = trainer.callback_metrics\n                  # Log results\n                  for key in sorted(metrics):\n                    if key not in [\"log\", \"progress_bar\"]:\n                      logger.info(\"{} = {}\\n\".format(key, str(metrics[key])))\n\n        def on_test_end(self, trainer, pl_module):\n            logger.info(\"***** Test results *****\")\n\n            if pl_module.is_logger():\n                metrics = trainer.callback_metrics\n\n                  # Log and save results to file\n                output_test_results_file = os.path.join(pl_module.hparams.output_dir, \"test_results.txt\")\n                with open(output_test_results_file, \"w\") as writer:\n                    for key in sorted(metrics):\n                          if key not in [\"log\", \"progress_bar\"]:\n                            logger.info(\"{} = {}\\n\".format(key, str(metrics[key])))\n                            writer.write(\"{} = {}\\n\".format(key, str(metrics[key])))","e68b986d":"args_dict = dict(\n    data_dir=\"\", # path for data files\n    output_dir=\"\", # path to save the checkpoints\n    model_name_or_path='google\/mt5-small',\n    tokenizer_name_or_path='google\/mt5-small',\n    max_seq_length=512,\n    learning_rate=3e-4,\n    weight_decay=0.0,\n    adam_epsilon=1e-8,\n    warmup_steps=0,\n    train_batch_size=32,\n    eval_batch_size=32,\n    num_train_epochs=2,\n    gradient_accumulation_steps=64,\n    n_gpu=1,\n    early_stop_callback=False,\n    fp_16=False, # if you want to enable 16-bit training then install apex and set this to true\n    opt_level='O1', # you can find out more on optimisation levels here https:\/\/nvidia.github.io\/apex\/amp.html#opt-levels-and-properties\n    max_grad_norm=1.0, # if you enable 16-bit training then set this to a sensible value, 0.5 is a good default\n    seed=42,\n)","4faff7dd":"!ls","23bf00ce":"!ls ..\/input\/","1996d42a":"train_path = \"..\/input\/omletcomments\/train.csv\"\nval_path = \"..\/input\/omletcomments\/valid.csv\"\n\ntrain = pd.read_csv(train_path)\nprint (train.head())\n\n# tokenizer = AutoTokenizer.from_pretrained('google\/mt5-small')","543dc5ed":"df = pd.read_csv(train_path)\ndf.columns","0bc4f847":"df.head()","a4de863b":"class CommentDataset(Dataset):\n    def __init__(self, tokenizer, data_dir, type_path, max_len=30):\n        self.path = os.path.join(data_dir, type_path + '.csv')\n\n        self.title = 'Title'\n        self.comment = 'Comment'\n        self.category = 'Category'\n        self.data = pd.read_csv(self.path)\n\n        self.max_len = max_len\n        self.tokenizer = tokenizer\n        self.inputs = []\n        self.targets = []\n\n        self._build()\n\n    def __len__(self):\n        return len(self.inputs)\n\n    def __getitem__(self, index):\n        source_ids = self.inputs[index][\"input_ids\"].squeeze()\n        target_ids = self.targets[index][\"input_ids\"].squeeze()\n\n        src_mask = self.inputs[index][\"attention_mask\"].squeeze()  # might need to squeeze\n        target_mask = self.targets[index][\"attention_mask\"].squeeze()  # might need to squeeze\n\n        return {\"source_ids\": source_ids, \"source_mask\": src_mask, \"target_ids\": target_ids, \"target_mask\": target_mask}\n\n    def _build(self):\n        for idx in range(len(self.data)):\n            input_text_1,input_text_2,output_text= self.data.loc[idx, self.title],self.data.loc[idx, self.category],self.data.loc[idx, self.comment]\n   \n            input_ = \"Title: %s Category: %s\" % (input_text_1,input_text_2)\n            target = \"%s\" %(output_text)\n\n            # tokenize inputs\n            tokenized_inputs = self.tokenizer.batch_encode_plus(\n                [input_], max_length=30, pad_to_max_length=True, return_tensors=\"pt\"\n            )\n            # tokenize targets\n            tokenized_targets = self.tokenizer.batch_encode_plus(\n                [target], max_length=30, pad_to_max_length=True, return_tensors=\"pt\"\n            )\n\n            self.inputs.append(tokenized_inputs)\n            self.targets.append(tokenized_targets)","ff01412c":"tokenizer = AutoTokenizer.from_pretrained('google\/mt5-large')","19a4423e":"dataset = CommentDataset(tokenizer, '..\/input\/omletcomments', 'valid', 30)\nprint(\"Val dataset: \",len(dataset))","fd091d92":"data = dataset[20]\nprint(tokenizer.decode(data['source_ids']))\nprint(tokenizer.decode(data['target_ids']))","a638b43d":"!mkdir result\n!ls\n!pwd","6fa3fda3":"args_dict.update({'data_dir': '..\/input\/omletcomments', 'output_dir': '\/kaggle\/working\/result', 'num_train_epochs':30,'max_seq_length':30})\nargs = argparse.Namespace(**args_dict)\nprint(args_dict)","797cf70e":"checkpoint_callback = pl.callbacks.ModelCheckpoint(\n    \n    period =1,filepath=args.output_dir, prefix=\"checkpoint\", monitor=\"val_loss\", mode=\"min\", save_top_k=1\n)\ntrain_params = dict(\n    accumulate_grad_batches=args.gradient_accumulation_steps,\n    gpus=args.n_gpu,\n    max_epochs=args.num_train_epochs,\n    early_stop_callback=False,\n    precision= 16 if args.fp_16 else 32,\n    amp_level=args.opt_level,\n    gradient_clip_val=args.max_grad_norm,\n    checkpoint_callback=checkpoint_callback,\n    callbacks=[LoggingCallback()],\n)","e6b282cc":"def get_dataset(tokenizer, type_path, args):\n    return CommentDataset(tokenizer=tokenizer, data_dir=args.data_dir, type_path=type_path,  max_len=args.max_seq_length)","89ac88d4":"print (\"Initialize model\")\nmodel = T5FineTuner(args)\n\ntrainer = pl.Trainer(**train_params)","770165f9":"print (\" Training model\")\ntrainer.fit(model)\n\nprint (\"training finished\")\n\nprint (\"Saving model\")\nmodel.model.save_pretrained(\"\/kaggle\/working\/result\")\n\nprint (\"Saved model\")","081d1fbb":"!ls ","737afd96":"1+1","b0827fe6":"!ls result","6336ec0d":"!pwd","c46b446d":"!cp -r \/kaggle\/working\/result\/pytorch_model.bin \/kaggle\/working\/\n!cp -r \/kaggle\/working\/result\/config.json \/kaggle\/working\/","49d566a0":"!ls\n","160ec895":"!rm -rf result","3c595ef9":"!ls","898606e2":"!pwd","8df77786":"from transformers import MT5ForConditionalGeneration, AutoTokenizer\nmodel = MT5ForConditionalGeneration.from_pretrained(\"\/kaggle\/working\")","1518eb50":"article = '''Hindi Title:10 Best Places to Visit in India - Travel Video'''\n","d692557a":"def top_kp(inp_ids, attn_mask):\n    ''' To generate multiple output for same input we are using top-k encoding\n    '''\n    topkp_output = model.generate(input_ids=inp_ids,\n                                       attention_mask=attn_mask,\n                                       do_sample=True,\n                                       max_length=30,\n                                       top_p=0.84,\n                                       top_k=80,\n                                       num_return_sequences=10,\n                                       min_length=3,\n                                       temperature=0.9,\n                                       repetition_penalty=1.2,\n                                       length_penalty=1.5,\n                                       no_repeat_ngram_size=2,\n                                       )\n    Questions = [tokenizer.decode(out, skip_special_tokens=True, clean_up_tokenization_spaces=True) for out in\n                 topkp_output]\n    return [Question.strip().capitalize() for Question in Questions]\n\ndef t5_topkp(input_text):\n    '''\n    \n    '''\n    con = \"Hindi Title: %s\" % (input_text)\n    encoding = tokenizer.encode_plus(con, return_tensors=\"pt\")\n    input_ids, attention_masks = encoding[\"input_ids\"].to(device), encoding[\"attention_mask\"].to(device)\n    output = top_kp(input_ids, attention_masks)\n    return output\n","f0a2c628":"import torch\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n# print (\"device \",device)\nmodel = model.to(device)","bf053de1":"start = time.time()\n\nprint(article)\noutput = t5_topkp(article)\nprint (\"Topkp decoding:: \\n \",output)\nend = time.time()\nprint (\"\\nTime elapsed \", end-start)\nprint (\"\\n\")","b1bb0ac6":"!ls","f564b7dd":"Let's define the hyperparameters and other arguments. You can overide this dict for specific task as needed. While in most of cases you'll only need to change the data_dirand output_dir.\n\nHere the batch size is 8 and gradient_accumulation_steps are 8 so the effective batch size is 64","4e70481e":"We'll be pytorch-lightning library for training. Most of the below code is adapted from here https:\/\/github.com\/huggingface\/transformers\/blob\/master\/examples\/lightning_base.py\n\nThe trainer is generic and can be used for any text-2-text task. You'll just need to change the dataset. Rest of the code will stay unchanged for all the tasks.\n\nThis is the most intresting and powrfull thing about the text-2-text format. You can fine-tune the model on variety of NLP tasks by just formulating the problem in text-2-text setting. No need to change hyperparameters, learning rate, optimizer or loss function. Just plug in your dataset and you are ready to go!","2f441426":"This notebook is an example on how to fine tune mT5 model with Higgingface Transformers to solve multilingual task in 101 lanaguges. This notebook especially takes the problem of question generation in hindi lanagues"}}