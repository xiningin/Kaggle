{"cell_type":{"19bdb98e":"code","d6b1f623":"code","6e83e09d":"code","2e41ec83":"code","72a790e2":"code","effc90f1":"code","a282e426":"code","3108395f":"code","f5152037":"code","e59eff13":"code","69cf6b09":"code","a8aa563d":"code","3f5a9892":"code","41c45477":"code","456494b9":"code","e320b10f":"code","36325669":"code","8067f985":"code","dc733453":"code","d7132bfe":"code","16562213":"code","d0c15b6e":"code","5e30f6ff":"code","0a2abcae":"code","6505d69b":"code","155bc256":"code","7580dd19":"code","9f14d6a5":"code","dd3f8a58":"code","e2cbf6d0":"code","bfe21e84":"code","f4dfd572":"code","d10fa6f7":"code","a6711009":"code","ec34766c":"code","7aefc658":"code","d5d0c534":"code","c3c99124":"code","7d22b836":"code","ba7c4bbe":"code","437de4a3":"code","52eaac8d":"markdown","7d3182ed":"markdown","ce14a226":"markdown","ab9e41ea":"markdown","69e35c85":"markdown","a729143e":"markdown","96bf6151":"markdown","53763d73":"markdown","c6cd7bd6":"markdown","f6e580e1":"markdown","c2514406":"markdown","02de4bcb":"markdown","682caf09":"markdown","cf7f46df":"markdown","f1da9b3e":"markdown","094d4983":"markdown","53ae2ced":"markdown","fddedeae":"markdown","cf5e9d7b":"markdown","3adf95ba":"markdown","89bbdfe7":"markdown","a3f1d8e4":"markdown","b5c47ccc":"markdown","b3b629f5":"markdown","1e1f6fd7":"markdown","db02f056":"markdown","bc0bc488":"markdown","942019c6":"markdown","21524e15":"markdown","0e368655":"markdown","158b4601":"markdown","667fdd43":"markdown","13ae31c4":"markdown","b6955914":"markdown","03d3030f":"markdown","68fb21ec":"markdown","853992fe":"markdown","9b38f3a7":"markdown","9eac0cb4":"markdown","6fc02ad7":"markdown","a8623fd5":"markdown","614ec284":"markdown","8e3f3d50":"markdown"},"source":{"19bdb98e":"!pip install selenium\n!pip install tweepy","d6b1f623":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport re\nimport time\nimport string\nimport warnings\n\n# for all NLP related operations on text\nimport nltk\nfrom nltk.corpus import stopwords\nfrom nltk.tokenize import sent_tokenize, word_tokenize\nfrom nltk.sentiment.vader import SentimentIntensityAnalyzer\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk.stem.porter import *\nfrom nltk.classify import NaiveBayesClassifier\nfrom wordcloud import WordCloud\n\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import f1_score, confusion_matrix, accuracy_score\nfrom sklearn.svm import SVC\nfrom sklearn.naive_bayes import GaussianNB\n\n\n# To consume Twitter's API\nimport tweepy\nfrom tweepy import OAuthHandler \n\n# To identify the sentiment of text\nfrom textblob import TextBlob\nfrom textblob.sentiments import NaiveBayesAnalyzer\nfrom textblob.np_extractors import ConllExtractor\n\n# ignoring all the warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\n# downloading stopwords corpus\nnltk.download('stopwords')\nnltk.download('wordnet')\nnltk.download('vader_lexicon')\nnltk.download('averaged_perceptron_tagger')\nnltk.download('movie_reviews')\nnltk.download('punkt')\nnltk.download('conll2000')\nnltk.download('brown')\nstopwords = set(stopwords.words(\"english\"))\n\n# for showing all the plots inline\n%matplotlib inline","6e83e09d":"# keys and tokens from the Twitter Dev Console\nconsumer_key = 'Sec3MvclRIx2RVlgu9l0SJX6D'\nconsumer_secret = 'ayoPNWtBm7fWpMBoK6EwRmegu3SW8Rw9mzJkottkv97quPe941'\naccess_token = '736550752760406018-so5CPJrEbJKb3c3Pq8va3VFr0yk4S0E'\naccess_token_secret = 'Cgr8tz0h6FTU7kxAjDzpHnjffNTHxWsBytXnu4Ihd1TFb'","2e41ec83":"class TwitterClient(object): \n    def __init__(self): \n        #Initialization method. \n        try: \n            # create OAuthHandler object \n            auth = OAuthHandler(consumer_key, consumer_secret) \n            # set access token and secret \n            auth.set_access_token(access_token, access_token_secret) \n            # create tweepy API object to fetch tweets \n            # add hyper parameter 'proxy' if executing from behind proxy \"proxy='http:\/\/172.22.218.218:8085'\"\n            self.api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True)\n            \n        except tweepy.TweepError as e:\n            print(f\"Error: Tweeter Authentication Failed - \\n{str(e)}\")\n\n    def get_tweets(self, query, maxTweets = 1000):\n        #Function to fetch tweets. \n        # empty list to store parsed tweets \n        tweets = [] \n        sinceId = None\n        max_id = -1\n        tweetCount = 0\n        tweetsPerQry = 100\n\n        while tweetCount < maxTweets:\n            try:\n                if (max_id <= 0):\n                    if (not sinceId):\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry)\n                    else:\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry,\n                                                since_id=sinceId)\n                else:\n                    if (not sinceId):\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry,\n                                                max_id=str(max_id - 1))\n                    else:\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry,\n                                                max_id=str(max_id - 1),\n                                                since_id=sinceId)\n                if not new_tweets:\n                    print(\"No more tweets found\")\n                    break\n\n                for tweet in new_tweets:\n                    parsed_tweet = {} \n                    parsed_tweet['tweets'] = tweet.text \n\n                    # appending parsed tweet to tweets list \n                    if tweet.retweet_count > 0: \n                        # if tweet has retweets, ensure that it is appended only once \n                        if parsed_tweet not in tweets: \n                            tweets.append(parsed_tweet) \n                    else: \n                        tweets.append(parsed_tweet) \n                        \n                tweetCount += len(new_tweets)\n                print(\"Downloaded {0} tweets\".format(tweetCount))\n                max_id = new_tweets[-1].id\n\n            except tweepy.TweepError as e:\n                # Just exit if any error\n                print(\"Tweepy error : \" + str(e))\n                break\n        \n        return pd.DataFrame(tweets)","72a790e2":"twitter_client = TwitterClient()\n\n# calling function to get tweets\ntweets_df = twitter_client.get_tweets('India', maxTweets=100)\nprint(f'tweets_df Shape - {tweets_df.shape}')\ntweets_df.head(10)","effc90f1":"# 1 way\ndef fetch_sentiment_using_SIA(text):\n    sid = SentimentIntensityAnalyzer()\n    polarity_scores = sid.polarity_scores(text)\n    return 'neg' if polarity_scores['neg'] > polarity_scores['pos'] else 'pos'\n\n# 2 way\ndef fetch_sentiment_using_textblob(text):\n    analysis = TextBlob(text)\n    return 'pos' if analysis.sentiment.polarity >= 0 else 'neg'","a282e426":"sentiments_using_SIA = tweets_df.tweets.apply(lambda tweet: fetch_sentiment_using_SIA(tweet))\npd.DataFrame(sentiments_using_SIA.value_counts())","3108395f":"sentiments_using_textblob = tweets_df.tweets.apply(lambda tweet: fetch_sentiment_using_textblob(tweet))\npd.DataFrame(sentiments_using_textblob.value_counts())","f5152037":"tweets_df['sentiment'] = sentiments_using_textblob\ntweets_df.head()","e59eff13":"def remove_pattern(text, pattern_regex):\n    r = re.findall(pattern_regex, text)\n    for i in r:\n        text = re.sub(i, '', text)\n    \n    return text ","69cf6b09":"# We are keeping cleaned tweets in a new column called 'tidy_tweets'\ntweets_df['tidy_tweets'] = np.vectorize(remove_pattern)(tweets_df['tweets'], \"@[\\w]*: | *RT*\")\ntweets_df.head(10)","a8aa563d":"cleaned_tweets = []\n\nfor index, row in tweets_df.iterrows():\n    # Here we are filtering out all the words that contains link\n    words_without_links = [word for word in row.tidy_tweets.split() if 'http' not in word]\n    cleaned_tweets.append(' '.join(words_without_links))\n\ntweets_df['tidy_tweets'] = cleaned_tweets\ntweets_df.head(10)","3f5a9892":"tweets_df = tweets_df[tweets_df['tidy_tweets']!='']\ntweets_df.head()","41c45477":"tweets_df.drop_duplicates(subset=['tidy_tweets'], keep=False)\ntweets_df.head()","456494b9":"tweets_df = tweets_df.reset_index(drop=True)\ntweets_df.head()","e320b10f":"tweets_df['absolute_tidy_tweets'] = tweets_df['tidy_tweets'].str.replace(\"[^a-zA-Z# ]\", \"\")","36325669":"stopwords_set = set(stopwords)\ncleaned_tweets = []\n\nfor index, row in tweets_df.iterrows():\n    \n    # filerting out all the stopwords \n    words_without_stopwords = [word for word in row.absolute_tidy_tweets.split() if not word in stopwords_set and '#' not in word.lower()]\n    \n    # finally creating tweets list of tuples containing stopwords(list) and sentimentType \n    cleaned_tweets.append(' '.join(words_without_stopwords))\n    \ntweets_df['absolute_tidy_tweets'] = cleaned_tweets\ntweets_df.head(10)","8067f985":"tokenized_tweet = tweets_df['absolute_tidy_tweets'].apply(lambda x: x.split())\ntokenized_tweet.head()","dc733453":"word_lemmatizer = WordNetLemmatizer()\n\ntokenized_tweet = tokenized_tweet.apply(lambda x: [word_lemmatizer.lemmatize(i) for i in x])\ntokenized_tweet.head()","d7132bfe":"for i, tokens in enumerate(tokenized_tweet):\n    tokenized_tweet[i] = ' '.join(tokens)\n\ntweets_df['absolute_tidy_tweets'] = tokenized_tweet\ntweets_df.head(10)","16562213":"class PhraseExtractHelper(object):\n    def __init__(self):\n        self.lemmatizer = nltk.WordNetLemmatizer()\n        self.stemmer = nltk.stem.porter.PorterStemmer()\n    \n    def leaves(self, tree):\n        \"\"\"Finds NP (nounphrase) leaf nodes of a chunk tree.\"\"\"\n        for subtree in tree.subtrees(filter = lambda t: t.label()=='NP'):\n            yield subtree.leaves()\n\n    def normalise(self, word):\n        \"\"\"Normalises words to lowercase and stems and lemmatizes it.\"\"\"\n        word = word.lower()\n        # word = self.stemmer.stem_word(word) # We will loose the exact meaning of the word \n        word = self.lemmatizer.lemmatize(word)\n        return word\n\n    def acceptable_word(self, word):\n        \"\"\"Checks conditions for acceptable word: length, stopword. We can increase the length if we want to consider large phrase\"\"\"\n        accepted = bool(3 <= len(word) <= 40\n            and word.lower() not in stopwords\n            and 'https' not in word.lower()\n            and 'http' not in word.lower()\n            and '#' not in word.lower()\n            )\n        return accepted\n\n    def get_terms(self, tree):\n        for leaf in self.leaves(tree):\n            term = [ self.normalise(w) for w,t in leaf if self.acceptable_word(w) ]\n            yield term","d0c15b6e":"sentence_re = r'(?:(?:[A-Z])(?:.[A-Z])+.?)|(?:\\w+(?:-\\w+)*)|(?:\\$?\\d+(?:.\\d+)?%?)|(?:...|)(?:[][.,;\"\\'?():-_`])'\ngrammar = r\"\"\"\n    NBAR:\n        {<NN.*|JJ>*<NN.*>}  # Nouns and Adjectives, terminated with Nouns\n        \n    NP:\n        {<NBAR>}\n        {<NBAR><IN><NBAR>}  # Above, connected with in\/of\/etc...\n\"\"\"\nchunker = nltk.RegexpParser(grammar)","5e30f6ff":"key_phrases = []\nphrase_extract_helper = PhraseExtractHelper()\n\nfor index, row in tweets_df.iterrows(): \n    toks = nltk.regexp_tokenize(row.tidy_tweets, sentence_re)\n    postoks = nltk.tag.pos_tag(toks)\n    tree = chunker.parse(postoks)\n\n    terms = phrase_extract_helper.get_terms(tree)\n    tweet_phrases = []\n\n    for term in terms:\n        if len(term):\n            tweet_phrases.append(' '.join(term))\n    \n    key_phrases.append(tweet_phrases)\n    \nkey_phrases[:10]","0a2abcae":"textblob_key_phrases = []\nextractor = ConllExtractor()\n\nfor index, row in tweets_df.iterrows():\n    # filerting out all the hashtags\n    words_without_hash = [word for word in row.tidy_tweets.split() if '#' not in word.lower()]\n    \n    hash_removed_sentence = ' '.join(words_without_hash)\n    \n    blob = TextBlob(hash_removed_sentence, np_extractor=extractor)\n    textblob_key_phrases.append(list(blob.noun_phrases))\n\ntextblob_key_phrases[:10]","6505d69b":"tweets_df['key_phrases'] = textblob_key_phrases\ntweets_df.head(10)","155bc256":"def generate_wordcloud(all_words):\n    wordcloud = WordCloud(width=800, height=500, random_state=21, max_font_size=100, relative_scaling=0.5, colormap='Dark2').generate(all_words)\n\n    plt.figure(figsize=(14, 10))\n    plt.imshow(wordcloud, interpolation=\"bilinear\")\n    plt.axis('off')\n    plt.show()","7580dd19":"all_words = ' '.join([text for text in tweets_df['absolute_tidy_tweets'][tweets_df.sentiment == 'pos']])\ngenerate_wordcloud(all_words)","9f14d6a5":"all_words = ' '.join([text for text in tweets_df['absolute_tidy_tweets'][tweets_df.sentiment == 'neg']])\ngenerate_wordcloud(all_words)","dd3f8a58":"# function to collect hashtags\ndef hashtag_extract(text_list):\n    hashtags = []\n    # Loop over the words in the tweet\n    for text in text_list:\n        ht = re.findall(r\"#(\\w+)\", text)\n        hashtags.append(ht)\n\n    return hashtags\n\ndef generate_hashtag_freqdist(hashtags):\n    a = nltk.FreqDist(hashtags)\n    d = pd.DataFrame({'Hashtag': list(a.keys()),\n                      'Count': list(a.values())})\n    # selecting top 15 most frequent hashtags     \n    d = d.nlargest(columns=\"Count\", n = 25)\n    plt.figure(figsize=(16,7))\n    ax = sns.barplot(data=d, x= \"Hashtag\", y = \"Count\")\n    plt.xticks(rotation=80)\n    ax.set(ylabel = 'Count')\n    plt.show()","e2cbf6d0":"hashtags = hashtag_extract(tweets_df['tidy_tweets'])\nhashtags = sum(hashtags, [])","bfe21e84":"generate_hashtag_freqdist(hashtags)","f4dfd572":"# For sake of consistency, we are going to discard the records which contains no phrases i.e where tweets_df['key_phrases'] contains []\ntweets_df2 = tweets_df[tweets_df['key_phrases'].str.len()>0]","d10fa6f7":"# BOW features\nbow_word_vectorizer = CountVectorizer(max_df=0.90, min_df=2, stop_words='english')\n# bag-of-words feature matrix\nbow_word_feature = bow_word_vectorizer.fit_transform(tweets_df2['absolute_tidy_tweets'])\n\n# TF-IDF features\ntfidf_word_vectorizer = TfidfVectorizer(max_df=0.90, min_df=2, stop_words='english')\n# TF-IDF feature matrix\ntfidf_word_feature = tfidf_word_vectorizer.fit_transform(tweets_df2['absolute_tidy_tweets'])","a6711009":"phrase_sents = tweets_df2['key_phrases'].apply(lambda x: ' '.join(x))\n\n# BOW phrase features\nbow_phrase_vectorizer = CountVectorizer(max_df=0.90, min_df=2)\nbow_phrase_feature = bow_phrase_vectorizer.fit_transform(phrase_sents)\n\n# TF-IDF phrase feature\ntfidf_phrase_vectorizer = TfidfVectorizer(max_df=0.90, min_df=2)\ntfidf_phrase_feature = tfidf_phrase_vectorizer.fit_transform(phrase_sents)","ec34766c":"target_variable = tweets_df2['sentiment'].apply(lambda x: 0 if x=='neg' else 1)","7aefc658":"def plot_confusion_matrix(matrix):\n    plt.clf()\n    plt.imshow(matrix, interpolation='nearest', cmap=plt.cm.Set2_r)\n    classNames = ['Positive', 'Negative']\n    plt.title('Confusion Matrix')\n    plt.ylabel('Predicted')\n    plt.xlabel('Actual')\n    tick_marks = np.arange(len(classNames))\n    plt.xticks(tick_marks, classNames)\n    plt.yticks(tick_marks, classNames)\n    s = [['TP','FP'], ['FN', 'TN']]\n\n    for i in range(2):\n        for j in range(2):\n            plt.text(j,i, str(s[i][j])+\" = \"+str(matrix[i][j]))\n    plt.show()","d5d0c534":"def naive_model(X_train, X_test, y_train, y_test):\n    naive_classifier = GaussianNB()\n    naive_classifier.fit(X_train.toarray(), y_train)\n\n    # predictions over test set\n    predictions = naive_classifier.predict(X_test.toarray())\n\n    # calculating Accuracy Score\n    print(f'Accuracy Score - {accuracy_score(y_test, predictions)}')\n    conf_matrix = confusion_matrix(y_test, predictions, labels=[True, False])\n    plot_confusion_matrix(conf_matrix)","c3c99124":"X_train, X_test, y_train, y_test = train_test_split(bow_word_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","7d22b836":"X_train, X_test, y_train, y_test = train_test_split(tfidf_word_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","ba7c4bbe":"X_train, X_test, y_train, y_test = train_test_split(bow_phrase_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","437de4a3":"X_train, X_test, y_train, y_test = train_test_split(tfidf_phrase_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","52eaac8d":"#### <a id='2Ba'>a. Using NLTK's SentimentIntensityAnalyzer<\/a>","7d3182ed":"#### <a id='3Aj'>j. Joining all tokens into sentences<\/a>","ce14a226":"## <a id='3'>3. Text Pre-processing<\/a> \n### <a id='3A'>A. Pre-processing 'Key Words'<\/a>\n#### <a id='3Aa'>a. Removing '@names'<\/a>\nHere we can see that at many places we have '@names', which is of no use, since it don't have any meaning, So needs to be removed.","ab9e41ea":"Features extracted from 'key words' helps model in performing better. They have better positive predictions than the later one. However, using 'key-phrase' based features improves the negative predictions.<br\/><br\/>\n__This is it from my side, suggestions are always welcome. Thanks :)__","69e35c85":"### <a id='6B'>B. Predictions on 'key phrases' based features<\/a>","a729143e":"Seems good, now we don't have '@name' values","96bf6151":"As expected, AI, DeepLearning and MachineLearning are most common hashtags.","53763d73":"#### <a id='6Ba'>a. BOW Phrase features<\/a>","c6cd7bd6":"#### <a id='4C'>C. Most commonly used Hashtags<\/a>","f6e580e1":"#### <a id='3Ac'>c. Removing tweets with empty text<\/a>","c2514406":"#### <a id='4A'>A. Most common words in positive tweets<\/a>\nAnswer can be best found using WordCloud","02de4bcb":"#### <a id='3Ai'>i. Converting words to Lemma<\/a>","682caf09":"## <a id='4'>4. Story Generation and Visualization<\/a>","cf7f46df":"#### <a id='2Ab'>b. Using 'tweepy'<\/a>","f1da9b3e":"TextBlob gives us more negative sentiments than SIA, so we will prefer textblob, since classfication seems better.","094d4983":"#### <a id='3Ab'>b. Removing links (http | https)<\/a>","53ae2ced":"In obtained key phrases, we can see words like 'year', 'talk', 'appl', 'compan' etc. are present which should never be considered as key phrases. There is one other simple way to extract key phrases, by using TextBlob (ConllExtractor).","fddedeae":"#### <a id='6Aa'>a. BOW word features<\/a>","cf5e9d7b":"#### <a id='6Bb'>b. TF-IDF Phrase features<\/a>","3adf95ba":"#### <a id='3Af'>f. Removing Punctuations, Numbers and Special characters<\/a>\nThis step should not be followed if we also want to do sentiment analysis on __key phrases__ as well, because semantic meaning in a sentence needs to be present. So here we will create one additional column 'absolute_tidy_tweets' which will contain absolute tidy words which can be further used for sentiment analysis on __key words__.","89bbdfe7":"## <a id='5'>5. Feature Extraction<\/a>\n\nWe need to convert textual representation in the form on numeric features. We have two popular techniques to perform feature extraction:\n\n1. __Bag of words (Simple vectorization)__\n2. __TF-IDF (Term Frequency - Inverse Document Frequency)__\n\nWe will use extracted features from both one by one to perform sentiment analysis and will compare the result at last.\n\nCheck out my below kernel to properly understand these techniques:<br\/>\n__https:\/\/www.kaggle.com\/amar09\/text-pre-processing-and-feature-extraction__","a3f1d8e4":"These key phrases seems better, let's consider these key phrase only.","b5c47ccc":"#### <a id='3Ad'>d. Dropping duplicate rows<\/a>","b3b629f5":"## <a id='6'>6. Model Building: Sentiment Analysis<\/a>","1e1f6fd7":"#### <a id='3Ae'>e. Resetting index<\/a>\nIt seems that our index needs to be reset, since after removal of some rows, some index values are missing, which may cause problem in future operations.","db02f056":"### <a id='3B'>B. Pre-processing 'Key Phrases'<\/a> ","bc0bc488":"#### <a id='6Ab'>b. TF-IDF word features<\/a>","942019c6":"#### <a id='3Ba'>a. Helper class, will help in preprocessing phrase terms<\/a>","21524e15":"#### Map target variables to  {0, 1}","0e368655":"#### <a id='3Ah'>h. Tokenize *'absolute_tidy_tweets'*<\/a>  ","158b4601":"#### <a id='3Bb'>b. Grammatical rule to identify phrases<\/a>","667fdd43":"### <a id='5A'>A. Feature Extraction for 'Key Words'<\/a>","13ae31c4":"### <a id='6A'>A. Predictions on 'key words' based features<\/a>","b6955914":"#### <a id='3Bc'>c. New feature called 'key_phrases', will contain phrases for corresponding tweet<\/a>","03d3030f":"## <a id='1'>1. Import Libraries<\/a>","68fb21ec":"#### <a id='2Bb'>b. Using TextBlob<\/a>","853992fe":"Text is everywhere in the form of openions, complaints, news and information; each of us are contributing in generating this text throughout the internet. This large amount of text which is present in the unstructured format can be used for welfare of the society and businesses by analysing the sentiments and trends. A part of NLP deals with Text processing and analysis. Commonly available text can not be directly used for analysis, it needs to pre-processed first, and that is where NLTK, the most popular library for text processing in Python, comes into the picture.\n\nYou may check out my previous related work where I have performed NLTK basic operations, Text Pre-processing, explained Bag of Words (BOW) and TF-IDF feature extraction techniques in detail with examples. If you already don't know how BOW and TF-IDF technique works then you must go through the first kernel atleast before proceeding any further.\n\n* _https:\/\/www.kaggle.com\/amar09\/text-pre-processing-and-feature-extraction_\n* _https:\/\/www.kaggle.com\/amar09\/nltk-feature-extraction-and-sentiment-analysis_\n\nIn this notebook, I am going to perform Sentiment Analysis on tweets on any desired topic. Instead of fetching tweets from and CSV I am going to scrap these tweets from the internet. So, get ready for a crash course on Scraping (using Selenium) and Twitter Sentiment Analysis.","9b38f3a7":"#### <a id='4B'>B. Most common words in negative tweets<\/a>","9eac0cb4":"#### <a id='3Ag'>g. Removing Stop words<\/a>\nWith the same reason we mentioned above, we won't perform this on 'tidy_tweets' column, because it needs to be used for __key_phrases__ sentiment analysis.","6fc02ad7":"### <a id='2B'>B. Fetch sentiments<\/a>\nTo proceed further, we need to know the sentiment type of every tweet, that can be done using two ways: <br\/>\n    __a. Using NLTK's SentimentIntensityAnalyzer (We'll refer as SIA)<br\/>__\n    __b. Using TextBlob<br\/>__","a8623fd5":"### <a id='5B'>B. Feature Extraction for 'Key Phrases'<\/a>","614ec284":"### Actions I am going to perform are:\n\n\n1. __<a href='#1' target='_self'>Import Libraries<\/a>__\n1. __<a href='#2' target='_self'>Fetch Tweets & Sentiments<\/a>__\n    1. __<a href='#2A' target='_self'>Fetch Tweets<\/a>__\n        1. <a href='#2Aa' target='_self'>Using Selenium<\/a>\n        1. <a href='#2Ab' target='_self'>Using tweepy<\/a>\n    1. __<a href='#2B' target='_self'>Fetch sentiments<\/a>__\n        1. <a href='#2Ba' target='_self'>Using NLTK's SentimentIntensityAnalyzer<\/a>\n        1. <a href='#2Bb' target='_self'>Using TextBlob<\/a>\n1. __<a href='#3' target='_self'>Text Pre-processing<\/a>__\n    1. __<a href='#3A' target='_self'>Pre-processing 'Key Words'<\/a>__\n        1. <a href='#3Aa' target='_self'>Removing '@names'<\/a>\n        1. <a href='#3Ab' target='_self'>Removing links (http | https)<\/a>\n        1. <a href='#3Ac' target='_self'>Removing tweets with empty text<\/a>\n        1. <a href='#3Ad' target='_self'>Dropping duplicate rows<\/a>\n        1. <a href='#3Ae' target='_self'>Removing Punctuations, Numbers and Special characters<\/a>\n        1. <a href='#3Af' target='_self'>Removing Stop words<\/a>\n        1. <a href='#3Ag' target='_self'>Tokenizing<\/a>\n        1. <a href='#3Ah' target='_self'>Converting words to Lemma <\/a>\n        1. <a href='#3i' target='_self'>Joining all tokens into sentences<\/a>\n    1. __<a href='#3B' target='_self'>Pre-processing 'Key Phrases'<\/a>__\n        1. <a href='#3Ba' target='_self'>Setting Grammatical rule to identify phrases<\/a>\n        1. <a href='#3Bb' target='_self'>Creating new feature called 'key_phrases', will contain phrases for corresponding tweet<\/a>\n1. __<a href='#4' target='_self'>Story Generation and Visualization<\/a>__\n    1. __<a href='#4A' target='_self'>Most common words in positive tweets<\/a>__\n    1. __<a href='#4B' target='_self'>Most common words in negative tweets<\/a>__\n    1. __<a href='#4C' target='_self'>Most commonly used Hashtags<\/a>__\n1. __<a href='#5' target='_self'>Feature Extraction<\/a>__\n    1. __<a href='#5A' target='_self'>Feature Extraction for 'Key Words'<\/a>__\n    1. __<a href='#5B' target='_self'>Feature Extraction for 'Key Phrases'<\/a>__\n1. __<a href='#6' target='_self'>Model Building: Sentiment Analysis<\/a>__\n    1. __<a href='#6A' target='_self'>Predictions on 'key words' based features<\/a>__\n        1. <a href='#6Aa' target='_self'> BOW word features<\/a>\n        1. <a href='#6Ab' target='_self'>TF-IDF word features<\/a>\n    1. __<a href='#6B' target='_self'>Predictions on 'key phrases' based features<\/a>__\n        1. <a href='#6Ba' target='_self'>BOW phrase features<\/a>\n        1. <a href='#6Bb' target='_self'>TF-IDF phrase features<\/a>\n       ","8e3f3d50":"- One thing to notice here is that word _'deep learning'_ has been used more than _'Machine Learning', 'AI', 'Artificial Intelligence', 'BigData'_ and _'DataScience'_, which shows the buzz of deep learning these days.\n\n- AI, DeepLearning and MachineLearning have clearly been used in both positive and negative tweets, which is very obvious.\nHowever, in negative tweets we can also see negative words as well like *stop, wrong, Unfortunately, fall, Cancer, shit, Greed, pressure, problem, complex, biased, never etc.*"}}