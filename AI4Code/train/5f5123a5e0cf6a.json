{"cell_type":{"d7b5b1a8":"code","03605a34":"code","105766d7":"code","7b817b88":"code","c0214b5e":"code","db3ff9f4":"code","6eabd63b":"code","278ff7cd":"code","a990d008":"code","282c60b3":"code","60f674b8":"code","d691bd8d":"code","d01c00d0":"code","41c5ffdd":"code","b5e16068":"code","c88c751b":"code","68a5cb20":"code","a406e945":"code","4736f27d":"code","edbc1ba0":"code","010a2281":"code","f9d083b9":"code","4aa77fe6":"code","5ed03c2f":"code","9bc9a994":"code","4814ed68":"code","d2907546":"code","ea348f81":"code","1662ea5a":"code","cb47154a":"code","34497c11":"code","f7f96f0b":"code","27d22153":"code","8e0b8b3c":"code","6e604de9":"code","8ebe2282":"code","f2b69a8c":"code","83b60693":"code","221fea13":"code","9252bc26":"code","9d923c3b":"code","d107a3d5":"code","49a014ce":"code","82366fd8":"code","33b062cd":"code","a956b66a":"code","4f2f0afe":"code","a42b7930":"code","53251818":"code","f244f81c":"code","69f308d5":"code","9b07398c":"code","f70d4a61":"code","1c293242":"code","bb4242e3":"markdown","3e769f5a":"markdown","df890e87":"markdown","92b0bf72":"markdown","d35359de":"markdown","249eaf77":"markdown","160cefc8":"markdown","cc60fad4":"markdown","30da3025":"markdown","3409d4cc":"markdown","0699cc6f":"markdown","39af3cf5":"markdown","b17b388e":"markdown","e9e7d55e":"markdown","60f5a8b7":"markdown","f8f3f64d":"markdown","e08ebe75":"markdown"},"source":{"d7b5b1a8":"import  pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics  import confusion_matrix,roc_auc_score,classification_report\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection  import GridSearchCV\nfrom sklearn.svm import SVC","03605a34":"df=pd.read_json('..\/input\/loan-application-data\/loan_data.json')","105766d7":"df.head()","7b817b88":"df.info()","c0214b5e":"df.describe()","db3ff9f4":"df['Dependents'].value_counts()","6eabd63b":"# grouping on the basis of 'dependents' columns\ng=df.groupby('Dependents')","278ff7cd":"Total_applications=511  #or df.shape[0]\nfor group,df1 in g:\n    print('Percentage of total applicants having',group,'no. of dependents is:')\n    print(((df1.shape[0])\/(df.shape[0]))*100,'%\\n\\n')\n    ","a990d008":"# #average number of dependents per applicant = total no. of dependents \/ total no. of applicants\nTotal_dependents=0\nfor i in df['Dependents']:\n    if i=='3+' :\n        Total_dependents+=3\n    else:\n        Total_dependents+=int(i)\n        \nTotal_applicants= df.shape[0]\naverage_number_of_dependents_per_applicant=Total_dependents\/Total_applicants\nprint('average number of dependents per applicant is: ',round(average_number_of_dependents_per_applicant,2))","282c60b3":"No_of_selfemployed_applicants=df[df['Self_Employed']=='Yes'].shape[0]\nprint('%of applications approved for self-employed applicants is : ',(No_of_selfemployed_applicants\/Total_applicants)*100,'%')","60f674b8":"No_of_married_males_rejected=df[(df['Married']=='Yes') & (df['Application_Status']=='N') & (df['Gender']=='Male')].shape[0]\n\ntotal_no_of_married_males_applied=df[(df['Married']=='Yes') &  (df['Gender']=='Male')].shape[0]\n\npercentage_of_rejections_for_married_male_applicants= (No_of_married_males_rejected\/total_no_of_married_males_applied)*100\n\nprint('% of rejections for married male applicants is:' , percentage_of_rejections_for_married_male_applicants,'%')","d691bd8d":"#grouping by property_area\np=df.groupby('Property_Area')\nfor group,df1 in p:\n    approvals=df1[df1['Application_Status']=='Y'].shape[0]\n    total_application_from_that_property_area=df1.shape[0]\n    approval_ratio=approvals\/total_application_from_that_property_area\n    print(f'the approval ratio for {group} property is {approval_ratio}')","d01c00d0":"#avg_dependentin_x_income_grp=(Total dependents)\/(Total no. of income groups)\n#grouping by income_group\nTotal_no_of_income_grps=len(df['Income'].value_counts())\nAvg_dependent_per_income_group=Total_dependents\/Total_no_of_income_grps\nprint('average dependents per income group is :',Avg_dependent_per_income_group)","41c5ffdd":"df.head()","b5e16068":"import warnings\nwarnings.filterwarnings('ignore')\nfor column in df.drop('Application_ID',axis=1).columns:\n    sns.countplot(df[column])\n    plt.show()","c88c751b":"#making a copy so that original dataset remains same\ndf_new=df.copy()","68a5cb20":"#dropping Application_Id column\ndf_new.drop('Application_ID',axis=1,inplace=True)","a406e945":"#label encoding of categorical columns\ncateg_columns=[column for column in df_new.columns if df_new[column].dtype=='object']","4736f27d":"categ_columns","edbc1ba0":"for column in categ_columns:\n    le=LabelEncoder()\n    df_new[column]=le.fit_transform(df_new[column])","010a2281":"df_new.head()","f9d083b9":"# df_new.drop(['Property_Area','Gender','Married'],axis=1,inplace=True)","4aa77fe6":"X_train, X_test, y_train, y_test =train_test_split(df_new.drop('Application_Status',axis=1),df_new['Application_Status'],test_size=0.2)","5ed03c2f":"lr_model=LogisticRegression()\nlr_model.fit(X_train,y_train)","9bc9a994":"lr_model.score(X_test,y_test)","4814ed68":"y_pred_lr=lr_model.predict(X_test)\nroc_auc_score(y_test,y_pred_lr)","d2907546":"print(classification_report(y_test,y_pred_lr))","ea348f81":"confusion_matrix(y_test,y_pred_lr)","1662ea5a":"sns.heatmap(confusion_matrix(y_test,y_pred_lr))","cb47154a":"params_cv_dt=[{'max_depth':(list(range(1,50)))}]\ndt_model=DecisionTreeClassifier()\ncv_dt=GridSearchCV(estimator=dt_model,param_grid=params_cv_dt)\n","34497c11":"cv_dt.fit(X_train,y_train)","f7f96f0b":"y_pred_cv_dt=cv_dt.predict(X_test)\nconfusion_matrix(y_test,y_pred_cv_dt)","27d22153":"roc_auc_score(y_test,y_pred_cv_dt)","8e0b8b3c":"print(classification_report(y_test,y_pred_cv_dt))","6e604de9":"sns.heatmap(confusion_matrix(y_test,y_pred_cv_dt))","8ebe2282":"rf_model=RandomForestClassifier()\nrf_model.fit(X_train,y_train)\ny_pred_rf=rf_model.predict(X_test)","f2b69a8c":"confusion_matrix(y_test,y_pred_rf)","83b60693":"roc_auc_score(y_test,y_pred_rf)","221fea13":"sns.heatmap(confusion_matrix(y_test,y_pred_rf))","9252bc26":"rf_model.score(X_test,y_test)","9d923c3b":"print(classification_report(y_test,y_pred_rf))","d107a3d5":"model_svc=SVC(kernel='rbf')\n","49a014ce":"params_cv=[{'C':[0.1,1,2,3,4,5],'gamma':[0.01,0.05,0.1,0.2,0.3,0.4,0.5,1]}]\ncv_svc=GridSearchCV(estimator=model_svc,param_grid=params_cv)","82366fd8":"cv_svc.fit(X_train,y_train)","33b062cd":"y_predit_cv_svc=cv_svc.predict(X_test)","a956b66a":"cv_svc.best_params_","4f2f0afe":"confusion_matrix(y_test,y_predit_cv_svc)","a42b7930":"rf_model.predict([[1,1,1,0,0,1,0,2]])","53251818":"sns.heatmap(confusion_matrix(y_test,y_predit_cv_svc))","f244f81c":"from sklearn.ensemble import VotingClassifier\nlr_model1=LogisticRegression()\ndt_model1=DecisionTreeClassifier()\nrf_model1=RandomForestClassifier()\nmodel_svc1=SVC(kernel='rbf')\n\nmodel = VotingClassifier(estimators=[('lr', lr_model1), ('dt', dt_model1),('rf',rf_model1),('sv',model_svc1)], voting='hard')\nmodel.fit(X_train,y_train)\nmodel.score(X_test,y_test)","69f308d5":"y_predict_ensemble=model.predict(X_test)","9b07398c":"confusion_matrix(y_test,y_predict_ensemble)","f70d4a61":"sns.heatmap(confusion_matrix(y_test,y_predict_ensemble))","1c293242":"roc_auc_score(y_test,y_predict_ensemble)","bb4242e3":"### Not bad","3e769f5a":"# 6. Find average dependents per income group.\n","df890e87":"# Decision tree classifier","92b0bf72":"#  Logistic regression","d35359de":"### since , we do not want to give loan to the person who do not deserve it,\n### Thus,we need to minimize the no. of False positives \n### Therefore , Random Forest classifier or decision tree classifier would be a good choice with minimizing the false positives","249eaf77":"# Ensemble using bagging method (voting classifier) (Bonus)","160cefc8":"# 3. Find the %of applications approved for self-employed applicants.\n","cc60fad4":"# 1. Find % of total applicants for each unique value of dependents. ","30da3025":"#  Random forest classifier","3409d4cc":"# 7. Create a simple predictive model to assess whether a loan application will be approved or rejected and provide the accuracy score.\n","0699cc6f":"#### Pretty much unbalanced data","39af3cf5":"# SVC (support vector classifier)","b17b388e":"### Thus the approval ratio is maximum from Rural area (i.e. 0.7)","e9e7d55e":"# 5. Which property area has the maximum approval ratio.\n","60f5a8b7":"# 4. What is the % of rejections for married male applicants?\n","f8f3f64d":"# Conclusion","e08ebe75":"# 2. Find the average number of dependents per applicant.\n"}}