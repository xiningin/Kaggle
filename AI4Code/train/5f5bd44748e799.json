{"cell_type":{"8e1f9340":"code","5096dcb4":"code","2d25c8fe":"code","d8875770":"code","aa001564":"code","d0bc0d19":"code","07ded69f":"code","2990e9dd":"code","071c95c8":"code","f253bba2":"code","efef19a6":"code","b2accfe4":"code","c4179fa7":"code","7c290280":"code","aa8ef5b5":"code","dbd7e420":"code","d360e40e":"code","593d02a2":"code","c66f8615":"code","524a588e":"code","2f8af7ce":"code","ffecfdba":"code","11616cc4":"code","89c9856a":"code","ab413ea0":"code","d038c5f7":"code","21e28d0e":"code","cb3ba921":"code","acc61fd5":"code","8f280b55":"code","ebf5c321":"code","672a0570":"code","db1e5d7a":"code","909e1701":"code","45855aa4":"code","bbda5d3e":"code","5a25a7c9":"code","8faafa3f":"code","02e52f86":"markdown","c3db9bfe":"markdown","2e4b27d9":"markdown","eb585f58":"markdown","031381e1":"markdown","c21bba6f":"markdown","1009e973":"markdown","2c5e7b94":"markdown","9144c12d":"markdown","d53e8318":"markdown","967c7b02":"markdown","a95fa456":"markdown","14b83de1":"markdown","7512f6ea":"markdown","643dba04":"markdown","46ca1c72":"markdown","f322e047":"markdown","147ab6d5":"markdown","eb6ec6e5":"markdown","9db10728":"markdown","8ea851af":"markdown","7d2d89a6":"markdown","8f8bd9e3":"markdown","fb2bb7f3":"markdown","06e0dd6b":"markdown","0d7035af":"markdown","eb906914":"markdown","349302d6":"markdown","f1ff9ed8":"markdown","01e666b3":"markdown","fca19f88":"markdown","988c962f":"markdown","ff3b7c93":"markdown","ba0211c7":"markdown","27c90e43":"markdown"},"source":{"8e1f9340":"import os\nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport folium\nfrom folium.plugins import MarkerCluster\nimport geopandas as gpd\nfrom PIL import Image\nimport requests\nfrom io import BytesIO\nfrom wordcloud import WordCloud, STOPWORDS, ImageColorGenerator\n\n# ignore deprecation warnings in sklearn\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Default configurations and constants\nplt.style.use('seaborn-pastel')\npd.set_option('display.max_columns', 500)\npd.set_option('display.max_rows', 500)\ncolPlots = ['skyblue','lightgreen','lightcoral','gainsboro','cadetblue', 'khaki']\ncolGeoJson = [['#ffffcc','#fecc5c','#fd8d3c','#f03b20','#bd0026'],\n              ['#ffffcc','#cceeff','#4da6ff','#1a1aff','#000080'],\n              ['#ffffcc','#bbff99','#78c679','#31a354','#006837'],\n              ['#d73027','#f46d43','#fdae61','#fee08b','#ffffbf','#d9ef8b','#a6d96a','#66bd63','#1a9850'],\n              ['#f7fcf5','#e5f5e0','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#006d2c','#00441b'],\n              ['#80ff80','#ff9980','#80b3ff','#ff99ff', '#ffff66']]\n\nprint('Libraries imported and default configuration set!')","5096dcb4":"def cardinalN(i):\n    \n    \"\"\" With a number given, return it's cardinal suffix\"\"\"\n    \n    if i == 1:\n        return '1st'\n    elif i == 2:\n        return '2nd'\n    elif i == 3:\n        return '3rd'\n    else:\n        return str(i) + 'th'\n    ","2d25c8fe":"def foliumGJ(mMap, df, key, countV, lstColor,  aliases, vmin, vmax, name, step = 10):\n    \n    \"\"\" Function that create a choropleth map. \n    \n    Arguments\n    ---------\n    map:        Folium map\n    df:         Dataframe\n    key:        Key to use with the GeoJson\n    countV:     Varible with the amount to be used with the colormap\n    lstColor:   Color list to create the colormap\n    aliases:    Aliases for the popup\n    vmin, vmax: Min and Max for the colormap\n    step:       Gradient steps for the colormap\n\n    \"\"\"\n    colormap = folium.LinearColormap(colors = lstColor,\n                                     vmin = vmin, vmax = vmax).to_step(step)\n    folium.GeoJson(df[['geometry',key ,countV]],\n                   name = name,\n                   style_function = lambda x: {\"weight\" : 0.25, 'color':'black','fillColor':colormap(x['properties'][countV]), 'fillOpacity' : 0.55},\n                   highlight_function = lambda x: {'weight': 0.75 , 'color':'black', 'fillOpacity' : 0.85},\n                   smooth_factor=2.0,\n                   tooltip=folium.features.GeoJsonTooltip(fields=[key,countV],\n                                                          aliases=aliases, \n                                                          labels=True)).add_to(mMap)\n\n    return mMap","d8875770":"def plotBarV(X, y, fig, title, width, factor, nType = '', symbol = '', fontS = 10, bColor = 'skyblue'):\n\n    \"\"\" Function that draw a tuned bar plot \n    \n    Arguments\n    ---------\n    X, y:   Axis of the plot\n    fig:    Figure to tune\n    title:  Plot Title\n    width:  Bar width\n    factor: amount to add to bar height text \n    nType:  if is double (percentage or currency)\n    symbol: if is double (percentage '%' or currency '$'\/'\u20ac'\/etc)\n    fontS:  Font size of the lables that will be printed above the bars\n    bColor: Color of the bars\n\n    \"\"\"\n    plt.title(title, fontsize = 15)\n    _ = plt.bar(X, y, width = 0.65, color = bColor, alpha = 0.65)\n    plt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='off', labelbottom='on')\n    plt.xticks(fontsize = 13)\n    plt.grid(b=False)\n    plt.rcParams['axes.facecolor'] = 'white'\n    b,t = plt.ylim()\n    plt.ylim(top=(t*1.15))\n\n    for spine in plt.gca().spines.values():\n        spine.set_visible(False)\n\n    for bar in _:\n        height = bar.get_height()\n        if nType == 'double':\n            txtHeight = str(np.around(height,decimals=2))+symbol\n        else:\n            txtHeight = str(height)\n            \n        plt.gca().text(bar.get_x() + bar.get_width()\/2, (bar.get_height()+factor), txtHeight,\n                       ha='center', color='black', fontsize=fontS)\n\n    return fig","aa001564":"def autolabel(AX, rects, symbol='', fontS = 10):\n    \n    \"\"\"Attach a text label above each bar in *rects*, displaying its height.\"\"\"\n    \n    for rect in rects:\n        height = round(rect.get_height(),2)\n        AX.annotate('{:.2f}{}'.format(height, symbol),\n                    xy = (rect.get_x() + rect.get_width() \/ 2, height),\n                    xytext=(0, 3),  # 3 points vertical offset\n                    textcoords=\"offset points\", fontsize = fontS,\n                    ha='center', va='bottom')","d0bc0d19":"def autolabel2(AX, x ,y, text, fSize = 12, color = 'black'):\n    \n    \"\"\"Display text in an AX on given coordinates\"\"\"\n    \n    AX.text(x,y, text, fontsize = fSize, color = color)","07ded69f":"# Search files in the folder\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","2990e9dd":"# Import dataset of NYC Airbnb data in pandas dataframe\nfullDF = pd.read_csv('\/kaggle\/input\/new-york-city-airbnb-open-data\/AB_NYC_2019.csv')\n\n# Import NYC geoJsons\nNYC_NGJ = gpd.read_file('\/kaggle\/input\/nyc-borough-geojson\/NYC_neighborhoods.geojson')\nNYC_BGJ = gpd.read_file('\/kaggle\/input\/nyc-borough-geojson\/NYC_borough.geojson')\n\nprint('Data imported!')","071c95c8":"fullDF.head()","f253bba2":"# Check shape and statistics of the dataset\nprint(fullDF.shape)\nfullDF.describe()","efef19a6":"# Check if there're NaN values\nfullDF.info()","b2accfe4":"# As we see, there're NaN values in several features, let's see the list\nfullDF.isna().sum()","c4179fa7":"#Create figure\nfig1 = plt.figure(figsize=(22, 7))\n\n# Create the data\ntmpDF = fullDF.groupby('neighbourhood_group').count()['id']\nstrTitle = 'Distribution of rooms per Borough'\n\n# Plot figure\nplotBarV(tmpDF.index, tmpDF, fig1.add_subplot(1,2,1), strTitle,\n         0.65, 200, 'int', fontS = 12)\n\n# Create the data\ntmpDF = fullDF.groupby('neighbourhood_group').agg({'price' : np.mean}).reset_index()\nstrTitle = 'Average price per Borough'\n\n# Plot figure\nplotBarV(tmpDF['neighbourhood_group'], tmpDF['price'],  fig1.add_subplot(1,2,2), strTitle,\n         0.65, 2, nType = 'double', symbol = '$', bColor = colPlots[1], fontS = 12)\n\nplt.show()","7c290280":"# Create the map\n\nmMap = folium.Map(location=[40.683356, -73.911270], zoom_start = 10, width = 600, height = 600, tiles='cartodbpositron')\n\n# Create the data (rooms)\nNYC_rooms = NYC_BGJ.merge(fullDF.groupby('neighbourhood_group').count()['id'].reset_index(), \n                          left_on='borough', right_on='neighbourhood_group', how='inner').fillna(0)\n\n# Add geoJson density layer\nmMap = foliumGJ(mMap, df = NYC_rooms, key = 'borough', \n                countV = 'id', lstColor = colGeoJson[0], \n                aliases = ['Neighborhood:','Airbnbs:'], \n                vmin = 0, vmax = int(NYC_rooms['id'].max()),\n                name = 'Airbnb places in NYC')\n\n# Create the data (prices)\ntmpDF = fullDF.groupby('neighbourhood_group').agg({'price' : np.mean}).reset_index()\nvMin = round(tmpDF['price'].min(),0)\nvMax = round(tmpDF['price'].max(),0)\ntmpDF['price'] = tmpDF['price'].map('{:,.2f}'.format)\ntmpDF['price'] = tmpDF['price'].astype(float)\n\nNYC_pricesB = NYC_BGJ.merge(tmpDF, left_on='borough',\n                            right_on='neighbourhood_group', how='inner').fillna(0)\n\n# Add geoJson density layer\nmMap = foliumGJ(mMap, df = NYC_pricesB, key = 'borough', \n                countV = 'price', lstColor = colGeoJson[1], \n                aliases = ['Neighborhood:','Average Price:'], \n                vmin = vMin, vmax = vMax, step = 5,\n                name = 'Airbnb average price in NYC')\n\n# Add title and layer control\ntitle_html = '''\n             <h3 align=\"left\" style=\"font-size:16px\"><b>NYC boroughs (Airbnb places and average price)<\/b><\/h3>\n             '''\nmMap.get_root().html.add_child(folium.Element(title_html))\nmMap.add_child(folium.map.LayerControl(collapsed=False))\n\n# Show map\nmMap","aa8ef5b5":"# Create figure\nfig1 = plt.figure(figsize=(12, 7))\n\n# Create the data\ntmpDF = fullDF.groupby('room_type').count()['id']\nstrTitle = 'Room type distribution'\n\n# Plot figure\nplotBarV(tmpDF.index, tmpDF, fig1.add_subplot(1,2,1), strTitle,\n         0.65, 200, fontS = 12)\n\n# Create the data\ntmpDF = fullDF.groupby('room_type').agg({'price' : np.mean}).reset_index()\nstrTitle = 'Average price per Airbnb room type'\n\n# Plot figure\nplotBarV(tmpDF['room_type'], tmpDF['price'], fig1.add_subplot(1,2,2), strTitle,\n         0.65, 2, nType = 'double', symbol = '$', bColor = colPlots[1], fontS = 12)\n\nplt.show()","dbd7e420":"# Create the data\ntmpDF = fullDF.groupby(['neighbourhood_group', 'room_type']).count()['id'].reset_index()\ntmpDF = tmpDF.pivot(index='neighbourhood_group', columns='room_type', values='id').fillna(0)\nX_labels = list(tmpDF.index)\ntmpDF.reset_index(inplace=True)\n\ntmpDF['totalNG'] = tmpDF.sum(axis=1)\ntmpDF['Entire home\/apt'] = tmpDF['Entire home\/apt'].div(tmpDF['totalNG']).mul(100)\ntmpDF['Private room'] = tmpDF['Private room'].div(tmpDF['totalNG']).mul(100)\ntmpDF['Shared room'] = tmpDF['Shared room'].div(tmpDF['totalNG']).mul(100)\n\nX = np.arange(len(X_labels))\nwidth = 0.25\n\n# Create figure and define properties\nfig, ax = plt.subplots(figsize=(22,7))\nplt.title('Airbnb room type distribution per borough', fontsize=15)\n\nrects1 = ax.bar(X - 0.25, tmpDF['Entire home\/apt'], width, label='Entire home\/apt', color = colPlots[0], alpha = 0.65)\nrects2 = ax.bar(X , tmpDF['Private room'], width, label='Private room', color = colPlots[1], alpha = 0.65)\nrects3 = ax.bar(X + 0.25, tmpDF['Shared room'], width, label='Shared room', color = colPlots[2], alpha = 0.65)\n\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n    \nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='off', labelbottom='on')\nplt.xticks(fontsize = 13)\nplt.rcParams['axes.facecolor'] = 'white'\nb,t = plt.ylim()\nplt.ylim(top=(t*1.15))\nplt.legend(frameon=False, bbox_to_anchor=(0.91,1.01), loc=\"upper left\", fontsize = 12)\nax.set_xticks(X)\nax.set_xticklabels(X_labels)\n\n# Put values on top of every bar\nautolabel(ax, rects1, '%', fontS = 12)\nautolabel(ax, rects2, '%', fontS = 12)\nautolabel(ax, rects3, '%', fontS = 12)","d360e40e":"# Create the data\ntmpDF = fullDF.groupby(['room_type', 'neighbourhood_group']).agg({'price' : np.mean}).reset_index()\ntmpDF['price'] = tmpDF['price'].map('{:,.2f}'.format)\ntmpDF['price'] = tmpDF['price'].astype(float)\ntmpDF = tmpDF.pivot(index='room_type', columns='neighbourhood_group', values='price').fillna(0)\nX_labels = list(tmpDF.index)\ntmpDF.reset_index(inplace=True)\n\nX = np.arange(len(X_labels))\nwidth = 0.15\n\n# Create figure, define properties and plot it\nfig, ax = plt.subplots(figsize=(22,7))\nplt.title('Airbnb room type price per borough', fontsize=15)\n\nrects1 = ax.bar(X - 0.3, tmpDF['Bronx'], width, label='Bronx', color = colPlots[0], alpha = 0.65)\nrects2 = ax.bar(X - 0.15, tmpDF['Brooklyn'], width, label='Brooklyn', color = colPlots[1], alpha = 0.65)\nrects3 = ax.bar(X , tmpDF['Manhattan'], width, label='Manhattan', color = colPlots[2], alpha = 0.65)\nrects4 = ax.bar(X + 0.15, tmpDF['Queens'], width, label='Queens', color = colPlots[3], alpha = 0.65)\nrects5 = ax.bar(X + 0.3, tmpDF['Staten Island'], width, label='Staten Island', color = colPlots[4], alpha = 0.65)\n\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n    \nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='off', labelbottom='on')\nplt.xticks(fontsize = 11)\nplt.rcParams['axes.facecolor'] = 'white'\nb,t = plt.ylim()\nplt.ylim(top=(t*1.15))\nplt.legend(frameon=False, bbox_to_anchor=(0.85,1), loc=\"upper left\", fontsize = 12)\nax.set_xticks(X)\nax.set_xticklabels(X_labels)\n\n# Put values on top of every bar\nautolabel(ax, rects1, '$', fontS = 12)\nautolabel(ax, rects2, '$', fontS = 12)\nautolabel(ax, rects3, '$', fontS = 12)\nautolabel(ax, rects4, '$', fontS = 12)\nautolabel(ax, rects5, '$', fontS = 12)","593d02a2":"# Create the map\nmMap = folium.Map(location=[40.683356, -73.911270], zoom_start = 10, width = 600, height = 600, tiles='cartodbpositron')\n\n# Create the data\n\n# Entire Home\nEH= tmpDF.iloc[0,:].reset_index()\nEH.columns = ['borough', 'price']\nEH.drop(0, inplace=True)\nNYC_EH = NYC_BGJ.merge(EH, left_on='borough', right_on='borough', how='inner').fillna(0)\nvMinEH = round(NYC_EH['price'].min(),0)\nvMaxEH = round(NYC_EH['price'].max(),0)\n\n# Private Room\nPR = tmpDF.iloc[1,:].reset_index()\nPR.columns = ['borough', 'price']\nPR.drop(0, inplace=True)\nNYC_PR = NYC_BGJ.merge(PR, left_on='borough', right_on='borough', how='inner').fillna(0)\nvMinPR = round(NYC_PR['price'].min(),0)\nvMaxPR = round(NYC_PR['price'].max(),0)\n\n# Shared Room\nSR = tmpDF.iloc[1,:].reset_index()\nSR.columns = ['borough', 'price']\nSR.drop(0, inplace=True)\nNYC_SR = NYC_BGJ.merge(SR, left_on='borough', right_on='borough', how='inner').fillna(0)\nvMinSR = round(NYC_SR['price'].min(),0)\nvMaxSR = round(NYC_SR['price'].max(),0)\n\n# Add geoJson density layers\nmMap = foliumGJ(mMap, df = NYC_EH, key = 'borough', \n                countV = 'price', lstColor = colGeoJson[0], \n                aliases = ['Borough:','Average price:'], \n                vmin = vMinEH, vmax = vMaxEH,\n                name = 'Entire home\/apt')\n\nmMap = foliumGJ(mMap, df = NYC_PR, key = 'borough', \n                countV = 'price', lstColor = colGeoJson[1], \n                aliases = ['Borough:','Average price:'], \n                vmin = vMinPR, vmax = vMaxPR,\n                name = 'Private room')\n\nmMap = foliumGJ(mMap, df = NYC_SR, key = 'borough', \n                countV = 'price', lstColor = colGeoJson[2], \n                aliases = ['Borough:','Average price:'], \n                vmin = vMinSR, vmax = vMaxSR,\n                name = 'Shared room')\n\n# Add title and layer control\ntitle_html = '''\n             <h3 align=\"left\" style=\"font-size:16px\"><b>NYC boroughs (Airbnb places and average price per Room type)<\/b><\/h3>\n             '''\nmMap.get_root().html.add_child(folium.Element(title_html))\nmMap.add_child(folium.map.LayerControl(collapsed=False))\n\n# Show map\nmMap","c66f8615":"# Create the data\nbrooklynDF_R = fullDF[fullDF['neighbourhood_group'] == 'Brooklyn'].groupby(['neighbourhood']).count()['id'].reset_index()\nbrooklynDF_R['borough'] = 'Brooklyn'\nbrooklynDF_R2 = brooklynDF_R.sort_values('id', ascending=False).head(10)\nbrooklynDFlst = list(brooklynDF_R2['neighbourhood'])\n\nmanhattanDF_R = fullDF[fullDF['neighbourhood_group'] == 'Manhattan'].groupby(['neighbourhood']).count()['id'].reset_index()\nmanhattanDF_R['borough'] = 'Brooklyn'\nmanhattanDF_R2 = manhattanDF_R.sort_values('id', ascending=False).head(10)\nmanhattanDFlst = list(manhattanDF_R2['neighbourhood'])\n\n# Create figure\nfig1 = plt.figure(figsize=(22, 7))\n\n# Define first subplot, define properties and plot it\nfig1.add_subplot(1,2,1)\n_ = plt.barh(brooklynDF_R2['neighbourhood'], brooklynDF_R2['id'], color = colPlots[0], height = 0.85, alpha = 0.65)\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='on', labelbottom='off')\nplt.yticks(fontsize = 12.5)\nplt.rcParams['axes.facecolor'] = 'white'\nplt.title('Brooklyn top-10 Airbnb Neighborhoods', fontsize=15)\nfor bar in _:\n    width = bar.get_width()\n    if width < 1000 : \n        sep = 105\n    else:\n        sep = 130\n    plt.gca().text((bar.get_width()-sep), bar.get_y() + bar.get_height()\/3, str(width),\n                   ha='center', color='black', fontsize=12)\n\n# Define second subplot, define properties and plot it\nax = fig1.add_subplot(1,2,2)\n_2 = plt.barh(manhattanDF_R2['neighbourhood'], manhattanDF_R2['id'], color = colPlots[1], height = 0.85, alpha = 0.65)\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='on', labelright='off',  labelbottom='off')\nplt.yticks(fontsize = 12.5)\nplt.rcParams['axes.facecolor'] = 'white'\nplt.title('Manhattan top-10 Airbnb Neighborhoods', fontsize=15)\nfor bar in _2:\n    width = bar.get_width()\n    if width < 1000 : \n        sep = 75\n    else:\n        sep = 90\n    plt.gca().text((bar.get_width()-sep), bar.get_y() + bar.get_height()\/3, str(width),\n                   ha='center', color='black', fontsize=12)\nplt.show()","524a588e":"# Create the data\nbrooklynDF_P = fullDF[fullDF['neighbourhood_group'] == 'Brooklyn'].groupby('neighbourhood').agg({'price' : np.mean}).reset_index()\nbrooklynDF_P['borough'] = 'Brooklyn'\nbrooklynDF_P['price'] = brooklynDF_P['price'].map('{:,.2f}'.format)\nbrooklynDF_P['price'] = brooklynDF_P['price'].astype(float)\nbrooklynDF_P2 = brooklynDF_P.sort_values('price', ascending=False).head(10)\nbrooklynDFlst = list(brooklynDF_P2['neighbourhood'])\n\nmanhattanDF_P = fullDF[fullDF['neighbourhood_group'] == 'Manhattan'].groupby('neighbourhood').agg({'price' : np.mean}).reset_index()\nmanhattanDF_P['borough'] = 'Manhattan'\nmanhattanDF_P['price'] = manhattanDF_P['price'].map('{:,.2f}'.format)\nmanhattanDF_P['price'] = manhattanDF_P['price'].astype(float)\nmanhattanDF_P2 = manhattanDF_P.sort_values('price', ascending=False).head(10)\nmanhattanDFlst = list(manhattanDF_P2['neighbourhood'])\n\n# Create figure\nfig1 = plt.figure(figsize=(22, 7))\n\n# Define first subplot, define properties and plot it\nfig1.add_subplot(1,2,1)\n_ = plt.barh(brooklynDF_P2['neighbourhood'], brooklynDF_P2['price'], color = colPlots[0], height = 0.85, alpha = 0.65)\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='on', labelbottom='off')\nplt.yticks(fontsize = 12.5)\nplt.rcParams['axes.facecolor'] = 'white'\nplt.title('Brooklyn top-10 Airbnb Neighborhoods', fontsize=15)\nfor bar in _:\n    sep = 25\n    width = bar.get_width()\n    width = str(width) + '$'\n    plt.gca().text((bar.get_width()-sep), bar.get_y() + bar.get_height()\/3, str(width),\n                   ha='center', color='black', fontsize=12)\n\n# Define second subplot, define properties and plot it\nax = fig1.add_subplot(1,2,2)\n_2 = plt.barh(manhattanDF_P2['neighbourhood'], manhattanDF_P2['price'], color = colPlots[1], height = 0.85, alpha = 0.65)\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='on', labelright='off',  labelbottom='off')\nplt.yticks(fontsize = 12.5)\nplt.rcParams['axes.facecolor'] = 'white'\nplt.title('Manhattan top-10 Airbnb Neighborhoods', fontsize=15)\nfor bar in _2:\n    sep=25\n    width = bar.get_width()\n    width = str(width) + '$'\n    plt.gca().text((bar.get_width()-sep), bar.get_y() + bar.get_height()\/3, str(width),\n                   ha='center', color='black', fontsize=12)\nplt.show()","2f8af7ce":"# Create map\nmMap = folium.Map(location=[40.649249, -73.950485], zoom_start = 11, width = 600, height = 600, tiles='cartodbpositron')\n\n# Create the data\nbrooklynDF_R.columns = ['neighbourhood', 'count', 'borough']\nNYC_Brooklyn_R = NYC_NGJ[NYC_NGJ['borough'] == 'Brooklyn']\nNYC_Brooklyn_R = NYC_Brooklyn_R.merge(brooklynDF_R, left_on='neighborhood', right_on='neighbourhood', how='left').fillna(0)\nNYC_Brooklyn_R.drop(67, inplace=True)\nvMaxR = int(NYC_Brooklyn_R['count'].max())\n\nNYC_Brooklyn_P = NYC_NGJ[NYC_NGJ['borough'] == 'Brooklyn']\nNYC_Brooklyn_P = NYC_Brooklyn_P.merge(brooklynDF_P, left_on='neighborhood', right_on='neighbourhood', how='left').fillna(0)\nNYC_Brooklyn_P.drop(67, inplace=True)\nvMaxP = round(NYC_Brooklyn_P['price'].max(),0)\n\n# Add geoJson density layer\nmMap = foliumGJ(mMap, df = NYC_Brooklyn_R, key = 'neighborhood', \n                countV = 'count', lstColor = colGeoJson[0], \n                aliases = ['Neighborhood:','Airbnbs:'], \n                vmin = 0, vmax = vMaxR,\n                name = 'Airbnb places per neighborhood', step = 5)\n                    \n# Add geoJson density layer\nmMap = foliumGJ(mMap, df = NYC_Brooklyn_P, key = 'neighborhood', \n                countV = 'price', lstColor = colGeoJson[1], \n                aliases = ['Neighborhood:','Price:'], \n                vmin = 0, vmax = vMaxP,\n                name = 'Average price per neighborhood', step = 5)\n\n# Add title and layer control\ntitle_html = '''\n             <h3 align=\"left\" style=\"font-size:16px\"><b>Brooklyn (Airbnb places and average price)<\/b><\/h3>\n             '''\nmMap.get_root().html.add_child(folium.Element(title_html))\nmMap.add_child(folium.map.LayerControl(collapsed=False))\n\n# Show map\nmMap","ffecfdba":"# Create map\nmMap = folium.Map(location=[40.791685, -73.938714], zoom_start = 11, width = 600, height = 600, tiles='cartodbpositron')\n\n# Create the data\nmanhattanDF_R.columns = ['neighbourhood', 'count', 'borough']\nNYC_Manhattan_R = NYC_NGJ[NYC_NGJ['borough'] == 'Manhattan']\nNYC_Manhattan_R = NYC_Manhattan_R.merge(manhattanDF_R, left_on='neighborhood', right_on='neighbourhood', how='left').fillna(0)\nvMaxR = int(NYC_Manhattan_R['count'].max())\n\nNYC_Manhattan_P = NYC_NGJ[NYC_NGJ['borough'] == 'Manhattan']\nNYC_Manhattan_P = NYC_Manhattan_P.merge(manhattanDF_P, left_on='neighborhood', right_on='neighbourhood', how='left').fillna(0)\nvMaxP = round(NYC_Manhattan_P['price'].max(),0)\n\n# Add geoJson density layer\nmMap = foliumGJ(mMap, df = NYC_Manhattan_R, key = 'neighborhood', \n                countV = 'count', lstColor = colGeoJson[0], \n                aliases = ['Neighborhood:','Airbnbs:'], \n                vmin = 0, vmax = vMaxR,\n                name = 'Airbnb places per neighborhood', step = 5)\n                    \n# Add geoJson density layer\nmMap = foliumGJ(mMap, df = NYC_Manhattan_P, key = 'neighborhood', \n                countV = 'price', lstColor = colGeoJson[1], \n                aliases = ['Neighborhood:','Price:'], \n                vmin = 0, vmax = vMaxP,\n                name = 'Average price per neighborhood', step = 5)\n\n# Add title and layer control\ntitle_html = '''\n             <h3 align=\"left\" style=\"font-size:16px\"><b>Manhattan (Airbnb places and average price)<\/b><\/h3>\n             '''\nmMap.get_root().html.add_child(folium.Element(title_html))\nmMap.add_child(folium.map.LayerControl(collapsed=False))\n\n# Show map\nmMap","11616cc4":"# Create the data\nfullDF.loc[fullDF['number_of_reviews']<=0, 'have_rev'] = 0\nfullDF.loc[fullDF['number_of_reviews']> 0, 'have_rev'] = 1\n\n# Create figure and define properties\nfig = plt.figure(figsize=(7,7))\nplt.pie([fullDF[fullDF['have_rev'] == 1].count()['id'], fullDF[fullDF['have_rev'] == 0].count()['id']], \n         startangle = 90, textprops={'size': 12}, autopct='%1.1f%%', wedgeprops={'alpha' : 0.65}, \n         explode = (0, 0.025), labels = ['',''], colors = [colPlots[0], colPlots[1]])\n\n# Plot the figure\nplt.axis('off')\nplt.legend(['With reviews','No reviews'],loc=4, frameon=False, fontsize = 12)\nplt.title('Airbnb places with\/without reviews', fontsize=15)\nplt.show()","89c9856a":"# Create the data\ntmpDF = fullDF.groupby(['neighbourhood_group', 'have_rev']).count()['id'].reset_index()\ntmpDF = tmpDF.pivot(index='neighbourhood_group', columns='have_rev', values='id').fillna(0)\nX_labels = list(tmpDF.index)\ntmpDF.reset_index(inplace=True)\ntmpDF.columns = ['Borough', 'No Reviews', 'With Reviews']\n\ntmpDF['totalR'] = tmpDF.sum(axis=1)\ntmpDF['No Reviews'] = tmpDF['No Reviews'].div(tmpDF['totalR']).mul(100)\ntmpDF['With Reviews'] = tmpDF['With Reviews'].div(tmpDF['totalR']).mul(100)\n\n# Create the figures, define properties and plot it\nfig = plt.figure(figsize=(22, 7))\nfor index, row in tmpDF.iterrows():\n    ax = fig.add_subplot(1,5,index+1)\n    _ = plt.pie([row['With Reviews'], row['No Reviews']], \n                startangle = 90, textprops={'size': 12.5}, autopct='%1.1f%%', \n                explode = (0, 0.025), wedgeprops={'alpha' : 0.65},\n                labels = ['',''], colors = [colPlots[0], colPlots[1]])\n\n    plt.axis('off')\n    if index == 4 :\n        plt.legend(['With reviews','No reviews'], bbox_to_anchor=(0.85,1), frameon=False, fontsize = 13)\n    plt.title(row['Borough'], fontsize=14)","ab413ea0":"# Create the data\nfullDF.loc[np.logical_and(fullDF['number_of_reviews']>0 ,fullDF['number_of_reviews']< 11), 'rev_range'] = '0' \nfullDF.loc[np.logical_and(fullDF['number_of_reviews']>10, fullDF['number_of_reviews']<= 25), 'rev_range'] = '1'\nfullDF.loc[np.logical_and(fullDF['number_of_reviews']>25, fullDF['number_of_reviews']<= 50), 'rev_range'] = '2'\nfullDF.loc[fullDF['number_of_reviews']> 50, 'rev_range'] = '3'\n\nlstVal = list(fullDF.groupby('rev_range').count().iloc[:,0].reset_index().sort_values(by='rev_range')['id'])\nlstLbl = ['Less than 10',' 10 - 25','26 - 50','More than 50']\nlstColors = [colPlots[0], colPlots[1],colPlots[2], colPlots[3]]\n\n# Create the figures, define properties and plot it\nfig1, ax1 = plt.subplots(figsize = (6.5,6.5))\nplt.pie(lstVal, autopct='%1.1f%%', startangle=90, pctdistance=0.65, \n        textprops={'size': 12}, colors = lstColors, explode = (0, 0.015, 0.01, 0.015),\n        wedgeprops={'alpha' : 0.65})\n\n#centre_circle = plt.Circle((0,0),0.55,fc='white') # draw circle\n#fig = plt.gcf()\n#fig.gca().add_artist(centre_circle) # Equal aspect ratio ensures that pie is drawn as a circle\n\nax1.axis('equal') \nplt.axis('off')\nplt.legend(lstLbl,frameon=False, bbox_to_anchor=(0.915,1), loc=\"upper left\", fontsize = 12)\nplt.title('Airbnb places reviews distribution', fontsize=15)\nplt.tight_layout()\nplt.show()","d038c5f7":"# Create the data\ntmpDF = fullDF.groupby(['neighbourhood_group','rev_range']).count().iloc[:,0].reset_index().sort_values(by='neighbourhood_group')\ntmpDF = tmpDF.pivot(index='neighbourhood_group', columns='rev_range', values='id').fillna(0).reset_index()\n\ntmpDF['totalNG'] = tmpDF.sum(axis=1)\nfor i in range(0,4):\n    tmpDF[str(i)] = tmpDF[str(i)].div(tmpDF['totalNG']).mul(100)\n\nX = np.arange(len(tmpDF))\nwidth = 0.2\n\n# Create the figures, define properties and plot it\nfig, ax = plt.subplots(figsize=(22,7))\nplt.title('Airbnb places reviews per borough', fontsize=15)\n\nrects1 = ax.bar(X - 0.3, tmpDF['0'], width, label='Less than 10', color = colPlots[0], alpha = 0.65)\nrects2 = ax.bar(X - 0.1, tmpDF['1'], width, label='10 - 25', color = colPlots[1], alpha = 0.65)\nrects3 = ax.bar(X + 0.1, tmpDF['2'], width, label='26 - 50', color = colPlots[2], alpha = 0.65)\nrects4 = ax.bar(X + 0.3, tmpDF['3'], width, label='More than 50', color = colPlots[3], alpha = 0.65)\n\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n    \nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='off', labelbottom='on')\nplt.xticks(fontsize = 13)\nplt.rcParams['axes.facecolor'] = 'white'\nb,t = plt.ylim()\nplt.ylim(top=(t*1.15))\nplt.legend(frameon=False, bbox_to_anchor=(0.9,1), loc=\"upper left\", fontsize = 12)\nax.set_xticks(X)\nax.set_xticklabels(X_labels)\n\nautolabel(ax, rects1, '%', 11)\nautolabel(ax, rects2, '%', 11)\nautolabel(ax, rects3, '%', 11)\nautolabel(ax, rects4, '%', 11)","21e28d0e":"\n# Create the data\nlstCols = ['neighbourhood_group', 'neighbourhood', 'latitude', 'longitude', 'room_type', 'price', 'number_of_reviews']\ntmpDF_ = fullDF[lstCols].sort_values(by='number_of_reviews', ascending = False).reset_index(drop=True).head(100)\ntmpDF_.columns = ['borough', 'neighborhood', 'lat', 'long', 'room_type', 'price', 'numRev']\n\nborDF = pd.DataFrame(tmpDF_.groupby('borough').count()['room_type']).reset_index()\nborDF.columns = ('borough', 'value')\nborDF = NYC_BGJ.merge(borDF, left_on='borough', right_on='borough', how='left').fillna(0)\n\n# Colors dictionary to paint markers\ncolorDict = {'1-10' : 'red', \n             '11-25' : 'cadetblue',\n             '26-50' : 'lightblue', \n             '51-100' : 'lightgreen'}\n\n# Create the map and the MarkerCluster\nmMap = folium.Map(location=[40.683356, -73.911270], zoom_start = 10, width = 600, height = 600, tiles='cartodbpositron')\nmc = MarkerCluster(name = 'aaa').add_to(mMap)\n\n# Add borough boundings\ncolormap = folium.LinearColormap(colors = colGeoJson[5],\n                                 vmin = 1, vmax = 5).to_step(5)\n\nfolium.GeoJson(borDF[['geometry','borough' ,'boroughCode', 'value']],\n               style_function = lambda x: {\"weight\" : 0.15, 'color':'black','fillColor':colormap(x['properties']['boroughCode']), 'fillOpacity' : 0.5},\n               smooth_factor=2.0,\n               tooltip=folium.features.GeoJsonTooltip(fields=['borough' ,'value'],\n                                                      aliases=['Borough: ', 'Airbnb places: '], \n                                                      labels=True)).add_to(mMap)\n\n# Place markers\nfor index, row in tmpDF_.iterrows():\n    \n    if index < 10 :\n        markCol = '1-10'\n    elif index < 25:\n        markCol = '11-25'\n    elif index < 50:\n        markCol = '26-50'\n    else:\n        markCol = '51-100'\n        \n    toolTip = str(index+1) + ' of 100'\n    strPopup = 'Borough: <b>%s<\/b><br>Neighborhood: <b>%s<\/b><br>Reviews: <b>%s<\/b><br>Room Type: <b>%s<\/b><br>Price: <b>%.2f$<\/b>'%(row['borough'], \n                                                                                                                                     row['neighborhood'],\n                                                                                                                                     row['numRev'],\n                                                                                                                                     row['room_type'],\n                                                                                                                                     row['price'])\n    \n    folium.Marker(location=[row['lat'], row['long']],\n                               tooltip = toolTip,\n                               popup= folium.Popup(strPopup, min_width = 185, max_width = 115),\n                               icon=folium.Icon( prefix='fa', icon='home', color=colorDict[markCol])).add_to(mc)\n    \n\n# Create legend\nlegend_html =   '''\n                <div style=\"position: fixed; \n                            background-color:white;\n                            top: 0px; left: 625px; width: 150px; height: 122px; \n                            border:2px solid grey; z-index:9999; font-size:12px;\n                            \">&nbsp; <b>Ranking<\/b> <br>\n                              &nbsp; <i class=\"fa fa-home fa-2x\" style=\"color:red\"><\/i> &nbsp; <b>1-10 reviews<\/b><br>\n                              &nbsp; <i class=\"fa fa-home fa-2x\" style=\"color:cadetblue\"><\/i> &nbsp; <b>11-25 reviews<\/b><br>\n                              &nbsp; <i class=\"fa fa-home fa-2x\" style=\"color:lightblue\"><\/i> &nbsp; <b>26-50 reviews<\/b><br>\n                              &nbsp; <i class=\"fa fa-home fa-2x\" style=\"color:lightgreen\"><\/i> &nbsp; <b>51-100 reviews<\/b>\n                <\/div>\n                ''' \nmMap.get_root().html.add_child(folium.Element(legend_html))\n\ntitle_html = '''\n             <h3 align=\"left\" style=\"font-size:16px\"><b>Top-100 Airbnbs in NYC<\/b><\/h3>\n             '''\nmMap.get_root().html.add_child(folium.Element(title_html))\n    \nmMap","cb3ba921":"print('----------------------------------------------------------')\nfor index, row in tmpDF_.head(10).iterrows():\n    if index == 9 :\n        print('{} place --> Borough : {}'.format(cardinalN(index+1), row['borough']))\n    else :\n        print('{} place -->  Borough : {}'.format(cardinalN(index+1), row['borough']))\n    print('               Neighborhood: {}'.format(row['neighborhood']))\n    print('               Room Type: {}'.format(row['room_type']))\n    print('               Price: {:.2f}$'.format(row['price']))\n    print('               Reviews: {}'.format(row['numRev']))\n    print('----------------------------------------------------------')\n    ","acc61fd5":"# Create data\nborDF = tmpDF_.groupby('room_type').count()['price'].reset_index()\nlstValues = borDF['price']\nlstLbl = borDF['room_type']\nlstColors = [colPlots[1],colPlots[0],colPlots[2]] \n\n# Create figure and define properties\nfig = plt.figure(figsize=(7,7))\nplt.pie(lstValues,\n         startangle = 12, textprops={'size': 12}, wedgeprops={'alpha' : 0.65}, \n         explode = (0.0075,0.0075,0.0075), colors = lstColors,  autopct='%1.1f%%',\n         pctdistance = 1.125)\n\n# Plot the figure\nplt.axis('off')\nplt.legend(lstLbl,frameon=False, bbox_to_anchor=(0.995,1), loc=\"upper left\", fontsize = 12)\nplt.title('Top-100 room type distribution', fontsize=15)\nplt.show()","8f280b55":"# Create data\nrtDF = tmpDF_.groupby(['room_type', 'borough']).count()['price'].reset_index()\nrtDF = rtDF.pivot(index='room_type', columns='borough', values='price').fillna(0)\n\n# Create figure and define properties\nax = rtDF.plot.barh(stacked=True, figsize =(14,7), alpha = 0.65)\n\nfor spine in ax.spines:\n    ax.spines[spine].set_visible(False)\n\nax.tick_params(axis=u'both', which=u'both',length=0, labelsize=12)\nax.legend(frameon = False, fontsize = 13, bbox_to_anchor=(1.25,1))\nax.get_xaxis().set_visible(False)\nax.set(ylabel='')\nax.set_title('Top-100 distribution by room type & borough', fontsize=15)\n\nautolabel2(ax, 1.5,1.96,str(int(rtDF.loc['Shared room', 'Queens'])) + ' place')\nautolabel2(ax, 7.5,0.96,str(int(rtDF.loc['Private room', 'Brooklyn'])) + ' places')\nautolabel2(ax, 29.5,0.96,str(int(rtDF.loc['Private room', 'Manhattan'])) + ' places')\nautolabel2(ax, 56,0.96,str(int(rtDF.loc['Private room', 'Queens'])) + ' places')\nautolabel2(ax, 74,0.96,str(int(rtDF.loc['Private room', 'Staten Island'])) + ' place')\nautolabel2(ax, 5.5,-0.04,str(int(rtDF.loc['Entire home\/apt', 'Brooklyn'])) + ' places')\nautolabel2(ax, 16.6,-0.04,str(int(rtDF.loc['Entire home\/apt', 'Manhattan'])) + ' places')\nautolabel2(ax, 27,-0.04,str(int(rtDF.loc['Entire home\/apt', 'Queens'])) + ' places')\n","ebf5c321":"# Create data\ntmpDF = fullDF[['neighbourhood_group', \"minimum_nights\"]]\ntmpDF['minimum_nights'] = np.clip(tmpDF['minimum_nights'], 0, 100)\n\n# Create figure and define properties\nfig = plt.figure(figsize=(18,6))\n_ = sns.violinplot(x=\"neighbourhood_group\", y=\"minimum_nights\", data=tmpDF, palette = colPlots[0:5])\n_.set_xlabel('', fontsize = 15)\n_.set_ylabel('Minimum Nights', fontsize = 15)\n_.tick_params(axis='both', which='major', labelsize=13, length=0)\n_.set(frame_on=False)\n_.yaxis.set_label_coords(-0.05, 0.5)\nplt.show()","672a0570":"# Create data\ntmpDF = fullDF[['neighbourhood_group', 'minimum_nights', 'room_type']].sort_values(by='room_type')\ntmpDF['minimum_nights'] = np.clip(tmpDF['minimum_nights'], 0, 100)\n\n# Create figure and define properties\nfig = plt.figure(figsize=(22,8))\n_ = sns.violinplot(x=\"neighbourhood_group\", y=\"minimum_nights\", hue='room_type', data=tmpDF, palette = colPlots[0:5])\n_.set_xlabel('')\n_.set_ylabel('Minimum Nights', fontsize = 15)\n_.tick_params(axis='both', which='major', labelsize=13, length=0)\n_.set(frame_on=False)\n_.yaxis.set_label_coords(-0.05, 0.5)\n_.legend(frameon=False, bbox_to_anchor=(0.995,1), loc=\"upper left\", fontsize = 12)\nplt.show()","db1e5d7a":"# Create the data\nfullDF.loc[np.logical_and(fullDF['minimum_nights']>0 ,fullDF['minimum_nights']< 10), 'minN_range'] = '0' \nfullDF.loc[np.logical_and(fullDF['minimum_nights']>9, fullDF['minimum_nights']<= 25), 'minN_range'] = '1'\nfullDF.loc[np.logical_and(fullDF['minimum_nights']>25, fullDF['minimum_nights']<= 50), 'minN_range'] = '2'\nfullDF.loc[fullDF['minimum_nights']> 50, 'minN_range'] = '3'\n\nlstVal = list(fullDF.groupby('minN_range').count().iloc[:,0].reset_index().sort_values(by='minN_range')['id'])\nlstLbl = ['Less than 10',' 10 - 25','26 - 50','More than 50']\nlstColors = [colPlots[0], colPlots[1],colPlots[2], colPlots[3]]\n\n# Create the figures, define properties and plot it\nfig1, ax1 = plt.subplots(figsize = (6.5,6.5))\nplt.pie(lstVal, autopct='%1.1f%%', startangle=-270, pctdistance=1.15, \n        textprops={'size': 12}, colors = lstColors, explode = (0.015, 0.015, 0.015, 0.015),\n        wedgeprops={'alpha' : 0.65})\n\nax1.axis('equal') \nplt.axis('off')\nplt.legend(lstLbl,frameon=False, bbox_to_anchor=(0.995,1), loc=\"upper left\", fontsize = 12)\nplt.title('Minimum nights count distribution', fontsize=15)\nplt.tight_layout()\nplt.show()","909e1701":"# Create figure and define properties\nfig = plt.figure(figsize=(7,7))\nplt.pie([fullDF[fullDF['availability_365']>0].count()['id'], fullDF[fullDF['availability_365']==0].count()['id']], \n         startangle = 90, textprops={'size': 12}, autopct='%1.1f%%', wedgeprops={'alpha' : 0.65}, \n         explode = (0, 0.025), labels = ['',''], colors = [colPlots[0], colPlots[1]])\n\n# Plot the figure\nplt.axis('off')\nplt.legend(['With value','Without value'],loc=4, frameon=False, fontsize = 12)\nplt.title('Airbnb places with\/without Availability 365 value', fontsize=15)\nplt.show()","45855aa4":"# Create the figures, define properties and plot it\nfig = plt.figure(figsize=(9,7))\nsns.distplot(fullDF[fullDF['availability_365']>0]['availability_365'], bins = 10, axlabel = 'Days available')\n\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n    \nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='off', labelbottom='on')\nplt.xticks(fontsize = 13)\nplt.title('Availability 365 distribution and KDE', fontsize=15)\nplt.show()","bbda5d3e":"# Create the data\nhostDF = pd.DataFrame(fullDF.groupby('host_id').count()['id']).reset_index()\n\n# Create figure and define properties\nfig = plt.figure(figsize=(7,7))\nplt.pie([hostDF[hostDF['id']==1].count()['id'], hostDF[hostDF['id']>1].count()['id']], \n         startangle = 90, textprops={'size': 12}, autopct='%1.1f%%', wedgeprops={'alpha' : 0.65}, \n         explode = (0, 0.025), labels = ['',''], colors = [colPlots[0], colPlots[1]])\n\n# Plot the figure\nplt.axis('off')\nplt.legend(['1 place','More than 1 place'],bbox_to_anchor=(0.925,0.925), frameon=False, fontsize = 12)\nplt.title('Distribution of hosts with 1 or more records', fontsize=15)\nplt.show()","5a25a7c9":"# Create the data\nhostDF = hostDF[hostDF['id']>1].sort_values(by='id', ascending=False).head(20)\ndctNames = {row[2] : row[3] for row in fullDF[fullDF['host_id'].isin(list(hostDF['host_id']))].values}\nhostDF['host_name'] = hostDF['host_id'].map(dctNames)\n\n# Create figure and define properties\nfig1 = plt.figure(figsize=(18, 10))\n_ = plt.barh(hostDF['host_name'], hostDF['id'], color = colPlots[0], height = 0.85, alpha = 0.65)\n\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n    \nplt.grid(b=False)\nplt.tick_params(top='off', bottom='off', left='off', right='off', labelleft='on', labelbottom='off')\nplt.yticks(fontsize = 12.5)\nplt.rcParams['axes.facecolor'] = 'white'\nplt.title('Top-20 hosts', fontsize=15)\n\nfor bar in _:\n    width = bar.get_width()\n    plt.gca().text((bar.get_width()-5), bar.get_y() + bar.get_height()\/3, str(width),\n                   ha='center', color='black', fontsize=12)\n\nplt.show()","8faafa3f":"# Create joined names variable\ntext = \" \".join(str(name) for name in fullDF['name'])\n\n# Create stopword list\nstopwords = set(STOPWORDS)\nstopwords.update(['home', 'apt', 'room', 'rent', 'private', 'apartment', 'bedroom', 'bed', 'NYC', 'house'])\n\n# Create mask array\nmask = np.array(Image.open('\/kaggle\/input\/nyc-borough-geojson\/NYC_Boroughs.png'))\n\n# create coloring from image\nimage_colors = ImageColorGenerator(mask)\n\n# Generate a word cloud image\nwordcloud = WordCloud(stopwords=stopwords, background_color=\"white\", mode=\"RGBA\",\n                      width = 1000, height = 1000, max_words = 450, mask=mask).generate(text)\n\n# Display the generated image:\nplt.figure(figsize=[12,12])\nplt.imshow(wordcloud.recolor(color_func=image_colors), interpolation=\"bilinear\")\nplt.axis(\"off\")\n\nplt.show()","02e52f86":"Well, Staten Island only have one place among the top-100 (89th position), and the Bronx not even one, the remaining 99 places are equaly distributed (36, 32, 31) among Manhattan, Brooklyn and Queens. Let's print the top-10 places, to see in which borough they're located, and which kind of room are.","c3db9bfe":"As we can see, the names change. In Brooklyn *Sea Gate* doubles by far the next neighborhood of the borough, and is almost as expensive as *Tribeca*, the most expensive neighborhood in Manhattan. But, the 10th position of the Manhattan top-10 price is 15% higher than the silver medal neighborhood in Brooklyn. Perhaps we have just found an outlier in *Sea Gate*, or a top luxury flat with a small number of places in that neighborhood that allows the average be that high.\n\nLet's see this data plotted in a density map of both neighborhoods.","2e4b27d9":"Well, as expected and coherent, almost 9 out of 10 places have a minimum nights requirement below 10, and 1 out of 10 bewteen 25 and 50, which we saw before, an average 30 (one month) which is also logical due to the nature of the Airbnb business. But, 1% (almost 500) have requirements beyond 50 days. Interesting...\n\nNow, let's see the distribution of the availability on the year values, first how many rows have value higher than 0.","eb585f58":"To begin, let's see the first rows of the dataset, it shape, its statistics, detailed information of the features and finally, check if there're NaN values.","031381e1":"As expected, Manhattan have the highest average price in every type of Airbnb room type. Is interesting that Staten Island, with not even 400 places, is almost as expensive as Brooklyn in average. It is also curious that a Private room in Manhattan costs roughly the same as an Entire home\/apt in the Bronx. Let's see the distribution in a map.\n\n","c21bba6f":"Only roughly the 2.5% are shared rooms, other 2 types of room divide the 97%. However, a private room cost almost the same as one shared. Let's see now the distribution of the rooms per borough.","1009e973":"We can see that Manhattan win both categories, most rooms and higher average price. The borough with less rooms is Staten Island and the cheaper is the Bronx. Now let's see the distribution of the Room Types.","2c5e7b94":"More than half of the places have less than 10 reviews, 30% have between 10 and 50 reviews and surprisingly an 18% have more than 50 reviews... Let's see how this is distributed per borough.","9144c12d":"It seems that 3\/4 of the places listed, haven't an availability value. Don't know how the Airbnb algorythm works but I suppose that it interpret the 0 value to *always available*, but as we cannot make those assumptions, we'll leave them outside the following analysis. Let's see the distribution of the places with availability values","d53e8318":"1. You might ask, why there's not a machine learning model or any kind of prediction? Well, I think this dataset isn't fit to it, I mean, what can we predict? Based on which features can we train a model? If there were some kind of time-series data about the real rental dates, price fluctation over the year (yes, it does change)... Perhaps we could forecast how many days the place will be occupied the next year, or something like that. But I think this dataset is good to do visualizations and extract analysis on the current data, that was what I just has made above.\n\n2. In NYC the top boroughs to have a place to rent in Airbnb are *Manhattan* and *Brooklyn*, they both have 85% of the records and being the most expensive on average too. *Staten Island* and the *Bronx* are who have less places to rent, but *Staten Island* is surprisingly almost as expensive as *Brooklyn*. While Queens stays in the middle. \n\n3. Among the 3 types of rooms, the *Entire home\/apt* earns by little to the private room, the *Shared rooms* being 2% of the total. But, even if the average price of both is not the same, they are very close to each other.\n\n4. Interestingly, in all borough except Manhattan, *Private rooms* are majority. In all 3 types of rooms, *Manhattan* is the expensive and the *Bronx* the cheaper.\n\n5. We analyze a bit deeper the 2 *big* boroughs' neighborhoods, we found that the neighborhoods with more places to rent, aren't necessarily the expensive ones. In fact, non of the top-3 neighborhood by places is in the top-10 by price average, and only one is in both top-10 lists (*Park Slope* in *Brooklyn*).\n\n6. Analyzing the *review* feature, we found out that 2 out of 10 haven't received a review yest. Of that 80% who have, half have less than 10 reviews and 18% have 50 or more.\n\n7. We've extracted the top-100 places and plot them in a map, and found that the *Bronx* doesn't have representation and *Staten Island* only 1 record, the rest is equally distributed on the 3 remaining boroughs. 75 are *Private rooms*, 24 * Entire home\/apt* and one *Shared room*!\n\n8. Out of that top-100, the top-10 places were 9 are *Private rooms* and only one *Entire home\/apt*, the average costs is around 65\\$.\n\n9. The minimum night feature had several outliers, but more than 90% of the records had values between 1 and 30. Being from 3 to 7 the most recurrent value, which is logical due to the Airbnb business. Interestly, only the *Shared rooms* places in *Staten Island* have no outliers.\n\n10. 2 out of 3 records have a value for availability in the year, being the most frequent the small ones (1-30) and the highest (330-365).\n\n11. Companies are the most recurrent hosts in the dataset, there's also people names on them, but its unlikely that a single person owns 30+ flats on a city like NYC, so my guess is that they are representatives for companies.\n\n12. The Airbnbs in NYC are **Cozy**, are located mainly in **Brooklyn**, are also **beautiful**, **spacious**, **modern** and **sunny**! What else you can ask for? :)","967c7b02":"### Context\n\nSince 2008, guests and hosts have used Airbnb to expand on traveling possibilities and present more unique, personalized way of experiencing the world. This dataset describes the listing activity and metrics in NYC, NY for 2019. This data file includes all needed information to find out more about hosts, geographical availability, necessary metrics to make predictions and draw conclusions.\n\n### Acknowledgements\n\nThis public dataset is part of [Airbnb](https:\/\/news.airbnb.com\/about-us\/), and the original source can be found on this [website](http:\/\/insideairbnb.com\/)","a95fa456":"Brooklyn and Manhattan hold 85% of the Airbnbs, and Bronx and Staten Island doesn't arrive together at 3%. By price, Manhattan stand above all other 4 boroughs, being the cheaper the Bronx with almost 100$ less than Manhattan. Let's see this in a map.","14b83de1":"We can see that in Brooklyn, 50% of it's places are in the top 3 neighborhoods (*Williamsburg*, *Bedford-Stuyvesant*, *Bushwick*), in Manhattan instead, the distribution is more balanced. This time, let's see the top-10 neighborhoods by price average in this 2 boroughs.","7512f6ea":"Interesting facts:\n\n* In *Brooklyn* a relevant number of *Shared rooms* have around 30 nights minimum stay.\n* *Manhattan* have a considerable number of *Entire home\/apt* that requires a 30 nights minimum stay.\n* In *Staten Island* all the *Shared rooms* have less than 5 nights of minimum stay.\n* *Shared rooms* minimum nights values are more or less equally distributed in all borough except *Staten Island*.\n* In fact, in *Staten Island* only *Shared rooms* have a dense form with *no outliers*, an opposite behaviour compared with the other 4 borough. \n\nLet's create some range values to see the distribution of the minimum nights on the data.","643dba04":"We see that the most values group on both ends, meaning that or have an availability in a range of 1-35 days or values closer to a full year. But we have a considerable amount of rows in the middle range values, either closer to the ends or the middle bin.\n\nIn conclusion, this distribution is totally opposite to a normal *bell-shaped* distribution.\n\nTo finish our analysis on this dataset, let's get information out of the owners\/host of the places listed. We already know that there're 21 host with no name, but all rows have an ID. As it isn't statisticaly significant, we'll go ahead ignoring this fact.","46ca1c72":"Private rooms are majority in 4 borough, even if in Brooklyn and Staten Island the percentages are separated by 2% or 3%. Instead, on Manhattan almost 2\/3 of the places are Entire home\/apt. Shared rooms are below 3.5% except in the Bronx that reaches 5.5%.\n\nLet's now the average price of each of the room types, separated by borough.","f322e047":"Now let's change subject, let's see some facts about the reviews.","147ab6d5":"Well, I hope you find this analysis interesting, I'd love to hear your opinions, correct me if you see anything wrong, or ask anything you might want to know.\n\nIf you like it please upvote it!","eb6ec6e5":"As you can see, I've updated the values higher than 100 to 100, as there're some values above that limit, which wouldn't let us see the *violins* shapes. Besides, in my opinion, Airbnb was created for short periods. 3 months is a long period, but is OK, 1-year period shouldn't be called an Airbnb but a normal rent.\n\nAnyhow, we see that almost all records have from 1 to 8-9 nights value, being 3-5 nights the real average (where the violin is wider). But we also notice that a small but relevant amount of records are around 30 days, which means, an important amount of records have 1 month minimum stay. Let's see this plot splitted by room type.","9db10728":"Having in mind, that Manhattan have almost 45% of the records, is the one that have more unreviewed records (almost one of each 4), and Staten Island, being in the opposite position with less than 1% of the records, is the one with more places reviewed. I've created a *rank* based on the number of reviews, to see how they are distributed, Let's check it out.","8ea851af":"Again, Manhattan have the highest percentage of places with less than 10 reviews (around 55%), and again, the borough with more 50 or more reviews is Staten Island! If you do the math, 2 out of 5 places have more than 25 reviews.\n\nLet's see the top-100 places with most comments in a map, we'll also see how they're distributed among boroughs, neighborhoods and room types. Let's check if the trend on Staten Island holds. In the map if you click the markers, a popup will show the details of the Airbnb.","7d2d89a6":"### 5) Conclusions","8f8bd9e3":"Here, we'll draw several plots to see how the data is distributed among it's variables. First, let's see how many borough (neighborhood groups) are listed,  how many Airbnbs they have and the average price per borough.","fb2bb7f3":"As we can see, the top-2 hosts are companies (*[Sonder](https:\/\/www.sonder.com\/)* and *[Blueground](https:\/\/www.theblueground.com)*), including the 5th position which is *Sonder* but without the NYC on it, having around 650 places among each other. Then we have *Kara* and *Kazuya* with more than 100 places each, which I think they work for some of these companies, but is more personal to use their name; I'd like to deal with a real person (called **Super Hosts** in Airbnb) instead with a company, is smart and effective I think.\n\nOne last curious fact, *Host* have 39 places listed, I'd like to meet a host named *Host*! xD\n\nNow, a final bonus, let's which words are the most frequently used in the name of each place. We'll generate *WordCloud* to see it in a fun way.","06e0dd6b":"The most reviewed Airbnb place is a private room in *Jamaica*, a Queens neighborhood, which places 3 more in the top-10, as Manhattan does, finally Brooklyn have the 2 last positions. Only one entire home\/apartment on the list, teh rest are Private rooms. The prices are low, in fact, 7 of them costs less than 50\\$ per night, and only the Entire home\/apt goes high to 160$. Can you find the top-3 places in the map? Remember, they are the red markers ;)\n\nNow let's see how the room types are distributed among boroughs, and on which neighborhoods are they placed.","0d7035af":"The Shared room is on Queens borough, which have also the most Private rooms of this Top-100. But Brooklyn overall have more places than the other boroughs. \n\nNow, let's analyze the minimum nights values.","eb906914":"Now, as Brooklyn and Manhattan gather around 85% of all the records, and as the data is also splitted by neighborhood, let's see the top-10 neighborhoods by number of places in this 2 boroughs.","349302d6":"### 1) Importing libraries and default configurations","f1ff9ed8":"### 2) Import data","01e666b3":"### 3) Preliminary data visualization and analysis","fca19f88":"In the first view of the data, we see that around 20% of the rental places haven't recieved a review. And we have 16 rental places and 21 hosts without a name. Let's do a deeper analysis of the data, including distribution per feature and among features.","988c962f":"![](https:\/\/i.imgur.com\/ZcpJzqg.png)","ff3b7c93":"### 4) Exploratory data analysis and visualization","ba0211c7":"One of each 5 Airbnb places haven't a review yet. Let's see the distribution per borough.","27c90e43":"Private room keeps the tendency saw in the list printed before, and as incredible it might seems, a Shared room have entered in our Top-100! Let's see where they are located."}}