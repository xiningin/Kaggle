{"cell_type":{"27ada718":"code","2fc8fc84":"code","813d1333":"code","ca69ad29":"code","cebc509b":"code","e442cf38":"code","27560c27":"code","f811b40a":"code","a4724fd7":"code","2ed1d5e2":"code","76b0e5f0":"code","b21224bb":"code","e3f1c54d":"code","77015c3d":"code","a97cda52":"code","5370873b":"code","a1fe49a3":"code","e2cfe45e":"code","2ecc7d54":"code","10f3d3fd":"code","4d816573":"markdown","a4df5a84":"markdown","d8717ef7":"markdown","a9e05c97":"markdown","99ff30f2":"markdown","492452e1":"markdown","b297dd73":"markdown","b4d18abd":"markdown","6b669000":"markdown","c0dad42e":"markdown"},"source":{"27ada718":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tensorflow as tf\nfrom tensorflow.keras.layers import Dense, Input\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.callbacks import ModelCheckpoint\nfrom kaggle_datasets import KaggleDatasets\nimport transformers\nfrom tqdm.notebook import tqdm\nfrom tokenizers import BertWordPieceTokenizer\nfrom keras.callbacks import Callback\nfrom sklearn.metrics import confusion_matrix, f1_score, precision_score, recall_score, roc_auc_score\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","2fc8fc84":"from keras import backend as K\n\ndef recall_m(y_true, y_pred):\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    recall = true_positives \/ (possible_positives + K.epsilon())\n    return recall\n\ndef precision_m(y_true, y_pred):\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    precision = true_positives \/ (predicted_positives + K.epsilon())\n    return precision\n\ndef f1_m(y_true, y_pred):\n    precision = precision_m(y_true, y_pred)\n    recall = recall_m(y_true, y_pred)\n    return 2*((precision*recall)\/(precision+recall+K.epsilon()))","813d1333":"class RocAucCallback(Callback):\n    def __init__(self, test_data, score_thr):\n        self.test_data = test_data\n        self.score_thr = score_thr\n        self.test_pred = []\n        \n    def on_epoch_end(self, epoch, logs=None):\n        if logs['val_auc_5'] > self.score_thr:\n            print('\\nRun TTA...')\n            for td in self.test_data:\n                self.test_pred.append(self.model.predict(td))","ca69ad29":"def fast_encode (texts, tokenizer, chunk_size=256, maxlen=512):\n    tokenizer.enable_truncation(max_length = maxlen)\n    tokenizer.enable_padding(max_length = maxlen)\n    all_ids = []\n    \n    for i in tqdm(range(0, len(texts), chunk_size)):\n        text_chunk = texts[i:i+chunk_size].to_list()\n        encs = tokenizer.encode_batch(text_chunk)\n        all_ids.extend([enc.ids for enc in encs])\n     \n    return np.array(all_ids)","cebc509b":"def build_model (transformer, max_len=512, loss='binary_crossentropy', lr=1e-5):\n    input_word_ids = Input(shape=(max_len,), dtype=tf.int32, name=\"input_word_ids\")\n    sequence_output = transformer(input_word_ids)[0]\n    cls_token = sequence_output[:, 0, :]\n    out = Dense(1, activation='sigmoid')(cls_token)\n    \n    model = Model(input_word_ids,out)\n    model.compile(Adam(lr = lr), loss = loss, metrics = ['accuracy',tf.keras.metrics.AUC(),f1_m, precision_m, recall_m])\n    \n    return model","e442cf38":"# Detect hardware, return appropriate distribution strategy\ntry:\n    # TPU detection. No parameters necessary if TPU_NAME environment variable is\n    # set: this is always the case on Kaggle.\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print('Running on TPU ', tpu.master())\nexcept ValueError:\n    tpu = None\n\nif tpu:\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nelse:\n    # Default distribution strategy in Tensorflow. Works on CPU and single GPU.\n    strategy = tf.distribute.get_strategy()\n\nprint(\"REPLICAS: \", strategy.num_replicas_in_sync)","27560c27":"AUTO = tf.data.experimental.AUTOTUNE\n\n# Data access\nGCS_DS_PATH = KaggleDatasets().get_gcs_path('jigsaw-multilingual-toxic-comment-classification')\n\n# Configuration\nEPOCHS = 10\nBATCH_SIZE = 16 * strategy.num_replicas_in_sync\nMAX_LEN = 512","f811b40a":"GCS_DS_PATH","a4724fd7":"tokenizer = transformers.BertTokenizer.from_pretrained('bert-base-multilingual-cased')\ntokenizer.save_pretrained('.')\nfast_tokenizer = BertWordPieceTokenizer(\"vocab.txt\", lowercase=False)\n","2ed1d5e2":"train_toxic_data = pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/jigsaw-toxic-comment-train.csv\")\ntrain_unintended_bias_data =  pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/jigsaw-unintended-bias-train.csv\")","76b0e5f0":"train_unintended_bias_data.toxic = train_unintended_bias_data.toxic.round().astype(int)\ntrain_data = pd.concat([train_toxic_data[[\"comment_text\", \"toxic\"]], train_unintended_bias_data[[\"comment_text\", \"toxic\"]]])","b21224bb":"print(len(train_data))","e3f1c54d":"train_data_sample = train_data.sample(100000)","77015c3d":"validation_data =  pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/validation.csv\")\ntest_data =  pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/test.csv\")\nsub_data =  pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/sample_submission.csv\")","a97cda52":"y_train = train_data_sample.toxic.values\ny_valid = validation_data.toxic.values","5370873b":"x_train = fast_encode(train_data_sample.comment_text.astype(str), fast_tokenizer, maxlen=MAX_LEN)\nx_valid = fast_encode(validation_data.comment_text.astype(str), fast_tokenizer, maxlen=MAX_LEN)\nx_test = fast_encode(test_data.content.astype(str), fast_tokenizer, maxlen=MAX_LEN)","a1fe49a3":"traind_dataset = (\n    tf.data.Dataset.from_tensor_slices((x_train,y_train)).repeat().shuffle(2000).batch(BATCH_SIZE).prefetch(AUTO))\n\nvalid_dataset = (\n    tf.data.Dataset.from_tensor_slices((x_valid,y_valid)).batch(BATCH_SIZE).cache().prefetch(AUTO))\n\ntest_dataset = (\n    tf.data.Dataset.from_tensor_slices((x_test)).batch(BATCH_SIZE))\n","e2cfe45e":"with strategy.scope():\n    transformer_layer = (transformers.TFBertModel.from_pretrained('bert-base-multilingual-cased'))\n    model = build_model(transformer_layer, lr=1e-3, max_len=MAX_LEN)\nmodel.summary()","2ecc7d54":"#metric_callbacks = RocAucCallback(test_dataset, 0.91)\nn_steps = x_train.shape[0] \/\/ BATCH_SIZE\ntrain_history = model.fit(traind_dataset, \n                         steps_per_epoch=n_steps,\n                         validation_data=valid_dataset,\n                         epochs=EPOCHS)","10f3d3fd":"sub_data['toxic'] = model.predict(test_dataset, verbose=1)\nsub_data.to_csv(\"submission.csv\", index=False)","4d816573":"## Abou this notebook\n","a4df5a84":"## TPU configuration","d8717ef7":"## Helpers","a9e05c97":"## read validation and test data","99ff30f2":"## Read training data","492452e1":"## Settings","b297dd73":"## train model","b4d18abd":"## create tokenizer from Distill-bert-multilingual-cased","6b669000":"## feature extraction","c0dad42e":"## Build dataset objects"}}