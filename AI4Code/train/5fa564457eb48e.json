{"cell_type":{"9f846673":"code","150ba510":"code","fcf8a5d0":"code","b48c84f0":"code","246fb082":"code","01837ba9":"code","303638e9":"code","b33c8f8a":"code","ddcb05a2":"code","dc0497e0":"code","dcb48139":"code","e5f17d08":"code","49204055":"code","1b30e090":"code","af06443e":"markdown","47308402":"markdown","c96a61cc":"markdown","c5d1ebe6":"markdown","6dfb2a3a":"markdown","81515f15":"markdown","ebd76a5a":"markdown","024ec932":"markdown","c82421b7":"markdown","580e4f2e":"markdown","951f8e22":"markdown"},"source":{"9f846673":"import warnings\nwarnings.filterwarnings('ignore')\nimport pandas as pd\nimport numpy as np\npd.set_option('display.max_columns', 500)\npd.set_option('display.max_rows', 500)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport lightgbm as lgb\nfrom sklearn import preprocessing, metrics\nimport gc\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","150ba510":"def reduce_mem_usage(df, verbose=True):\n    \n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if   c_min > np.iinfo(np.int8 ).min and c_max < np.iinfo(np.int8).max :\n                    df[col] = df[col].astype(np.int8 )\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if   c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n        \n    return df","fcf8a5d0":"def read_data():\n    \n    calendar               = reduce_mem_usage(pd.read_csv('..\/input\/m5-forecasting-accuracy\/calendar.csv'))\n    sell_prices            = reduce_mem_usage(pd.read_csv('..\/input\/m5-forecasting-accuracy\/sell_prices.csv'))    \n    sales_train_validation = reduce_mem_usage(pd.read_csv('..\/input\/m5-forecasting-accuracy\/sales_train_validation.csv'))\n    submission             = reduce_mem_usage(pd.read_csv('..\/input\/m5-forecasting-accuracy\/sample_submission.csv'))\n    \n    print('calendar               has {} rows, {} columns'.format(calendar.shape[0],               calendar.shape[1]))\n    print('sell_prices            has {} rows, {} columns'.format(sell_prices.shape[0],            sell_prices.shape[1]))    \n    print('sales_train_validation has {} rows, {} columns'.format(sales_train_validation.shape[0], sales_train_validation.shape[1]))\n    print('submission             has {} rows, {} columns'.format(submission.shape[0],             submission.shape[1]))\n    \n    return calendar, sell_prices, sales_train_validation, submission","b48c84f0":"def melt_and_merge(calendar, sell_prices, sales_train_validation, submission, nrows=55_000_000, merge=False):\n    \n    \n    # sales_train_validation\n    sales_train_validation = pd.melt(sales_train_validation,\n                                    id_vars   = ['id', 'item_id', 'dept_id', 'cat_id', 'store_id', 'state_id'],\n                                    var_name  = 'day',\n                                    value_name = 'demand')\n    print('melted sales_train_validation has {} rows, {} columns'.format(sales_train_validation.shape[0], sales_train_validation.shape[1]))\n    \n    \n    # submission\n    test1 = submission[submission['id'].str.contains('validation')]\n    test2 = submission[submission['id'].str.contains('evaluation')]\n    \n    test1.columns = ['id'] + ['d_' + str(i) for i in range(1914, 1942)]\n    test2.columns = ['id'] + ['d_' + str(i) for i in range(1942, 1970)]  \n    \n    product = sales_train_validation[['id', 'item_id', 'dept_id', 'cat_id', 'store_id', 'state_id']].drop_duplicates()\n    test1 = test1.merge(product, on = 'id', how = 'left')\n    test2['id'] = test2['id'].str.replace('_evaluation','_validation')\n    test2 = test2.merge(product, on = 'id', how = 'left')\n    test2['id'] = test2['id'].str.replace('_validation','_evaluation')\n    \n    test1 = pd.melt(test1,\n                    id_vars   = ['id', 'item_id', 'dept_id', 'cat_id', 'store_id', 'state_id'],\n                    var_name  = 'day',\n                    value_name = 'demand')\n    test2 = pd.melt(test2,\n                    id_vars   = ['id', 'item_id', 'dept_id', 'cat_id', 'store_id', 'state_id'],\n                    var_name  = 'day',\n                    value_name = 'demand') \n    \n    sales_train_validation['part'] = 'train'\n    test1['part'] = 'test1'\n    test2['part'] = 'test2'\n    \n    data = pd.concat([sales_train_validation, test1, test2], axis = 0).loc[nrows:]\n    data = data[data['part'] != 'test2']\n    del sales_train_validation, test1, test2, submission\n    \n    \n    # calendar, sell_prices\n    if merge:\n        calendar = calendar.drop(columns = ['weekday', 'wday', 'month', 'year'])\n        data = data.merge(calendar, how = 'left', left_on = ['day'], right_on = ['d']).drop(columns=['d', 'day'])\n        data = data.merge(sell_prices, on = ['store_id', 'item_id', 'wm_yr_wk'], how = 'left')\n        print('final dataset has {} rows and {} columns'.format(data.shape[0], data.shape[1]))\n    \n    gc.collect()\n    \n    return data","246fb082":"calendar, sell_prices, sales_train_validation, submission = read_data()\ndata = melt_and_merge(calendar, sell_prices, sales_train_validation, submission, nrows = 27_500_000, merge = True)","01837ba9":"data.head()","303638e9":"def transform(data):\n    \n    nan_features = ['event_name_1', 'event_type_1', 'event_name_2', 'event_type_2']\n    for feature in nan_features:\n        data[feature] = data[feature].fillna('unknown')\n    \n    cat_features = ['item_id', 'dept_id', 'cat_id', 'store_id', 'state_id', 'event_name_1', 'event_type_1', 'event_name_2', 'event_type_2']\n    for feature in cat_features:\n        le = preprocessing.LabelEncoder()\n        data[feature] = le.fit_transform(data[feature])\n    \n    return data","b33c8f8a":"def simple_fe(data):\n    \n    # demand features\n    data['lag_t28']                = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28))\n    data['lag_t29']                = data.groupby(['id'])['demand'].transform(lambda x: x.shift(29))\n    data['lag_t30']                = data.groupby(['id'])['demand'].transform(lambda x: x.shift(30))\n    data['rolling_mean_t7']        = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(7).mean())\n    data['rolling_std_t7']         = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(7).std())\n    data['rolling_mean_t30']       = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(30).mean())\n    data['rolling_std_t30']        = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(30).std())\n    data['rolling_mean_t90']       = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(90).mean())\n    data['rolling_std_t90']        = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(90).std())\n    data['rolling_mean_t180']      = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(180).mean())\n    data['rolling_std_t180']        = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(180).std())\n    data['rolling_skew_t30']       = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(30).skew())\n    data['rolling_kurt_t30']       = data.groupby(['id'])['demand'].transform(lambda x: x.shift(28).rolling(30).kurt())\n    \n    # price features\n    data['lag_price_t1']           = data.groupby(['id'])['sell_price'].transform(lambda x: x.shift(1))\n    data['price_change_t1']        = (data['lag_price_t1'] - data['sell_price']) \/ data['lag_price_t1']\n    data['rolling_price_max_t365'] = data.groupby(['id'])['sell_price'].transform(lambda x: x.shift(1).rolling(365).max())\n    data['price_change_t365']      = (data['rolling_price_max_t365'] - data['sell_price']) \/ data['rolling_price_max_t365']\n    data['rolling_price_std_t7']   = data.groupby(['id'])['sell_price'].transform(lambda x: x.rolling(7).std())\n    data['rolling_price_std_t30']  = data.groupby(['id'])['sell_price'].transform(lambda x: x.rolling(30).std())\n    data = data.drop(columns = ['rolling_price_max_t365', 'lag_price_t1'])\n    \n    # time features\n    data['date']      = pd.to_datetime(data['date']) \n    data['year']      = data['date'].dt.year\n    data['month']     = data['date'].dt.month\n    data['week']      = data['date'].dt.week\n    data['day']       = data['date'].dt.day\n    data['dayofweek'] = data['date'].dt.dayofweek\n    \n    return data","ddcb05a2":"data = transform(data)\ndata = simple_fe(data)\ndata = reduce_mem_usage(data)","dc0497e0":"data.head()","dcb48139":"def run_lgb(data):\n    \n    features = ['item_id', 'dept_id', 'cat_id', 'store_id', 'state_id', \n                'event_name_1', 'event_type_1', 'event_name_2', 'event_type_2', 'snap_CA', 'snap_TX', 'snap_WI', 'sell_price', \n                'lag_t28', 'lag_t29', 'lag_t30', 'rolling_mean_t7', 'rolling_std_t7', 'rolling_mean_t30', 'rolling_std_t30', 'rolling_mean_t90', 'rolling_std_t90', 'rolling_mean_t180', 'rolling_std_t180', 'rolling_skew_t30', 'rolling_kurt_t30',\n                'price_change_t1', 'price_change_t365', 'rolling_price_std_t7', 'rolling_price_std_t30', \n                'year', 'month', 'week', 'day', 'dayofweek']\n    \n    x_train = data[data['date'] <= '2016-03-27'][features]\n    y_train = data[data['date'] <= '2016-03-27']['demand']\n    x_val   = data[(data['date'] > '2016-03-27') & (data['date'] <= '2016-04-24')][features]\n    y_val   = data[(data['date'] > '2016-03-27') & (data['date'] <= '2016-04-24')]['demand']\n    test    = data[(data['date'] > '2016-04-24')]\n    \n    del data\n    gc.collect()    \n    \n    train_set = lgb.Dataset(x_train, y_train)\n    val_set   = lgb.Dataset(x_val, y_val)\n    \n    params = {\n        'boosting_type': 'gbdt',\n        'metric': 'rmse',\n        'objective': 'regression',\n        'n_jobs': -1,\n        'seed': 236,\n        'learning_rate': 0.01,\n        'bagging_fraction': 0.75,\n        'bagging_freq': 10, \n        'colsample_bytree': 0.75}\n    \n    model       = lgb.train(params, train_set, num_boost_round=2500, early_stopping_rounds=50, valid_sets = [train_set, val_set], verbose_eval=100)\n    train_pred  = model.predict(x_train)\n    train_score = np.sqrt(metrics.mean_squared_error(train_pred, y_train))\n    val_pred    = model.predict(x_val)\n    val_score   = np.sqrt(metrics.mean_squared_error(val_pred, y_val))\n    print(f'train rmse score is {train_score}')\n    print(f'val rmse score is {val_score}')\n    \n    y_pred = model.predict(test[features])\n    test['demand'] = y_pred\n    \n    return test","e5f17d08":"test = run_lgb(data)","49204055":"def predict(test, submission):\n    predictions = test[['id', 'date', 'demand']]\n    predictions = pd.pivot(predictions, index = 'id', columns = 'date', values = 'demand').reset_index()\n    predictions.columns = ['id'] + ['F' + str(i + 1) for i in range(28)]\n\n    evaluation_rows = [row for row in submission['id'] if 'evaluation' in row] \n    evaluation = submission[submission['id'].isin(evaluation_rows)]\n\n    validation = submission[['id']].merge(predictions, on = 'id')\n    final = pd.concat([validation, evaluation])\n    final.to_csv('submission.csv', index = False)","1b30e090":"predict(test, submission)","af06443e":"# 4. \u30e2\u30c7\u30eb\u306e\u5b66\u7fd2, test\u306e\u63a8\u5b9a","47308402":"# 3. \u7279\u5fb4\u91cf\u306e\u4f5c\u6210","c96a61cc":"## 3-1. \u6b20\u640d\u5024\u306e\u6271\u3044, \u30ab\u30c6\u30b4\u30ea\u5909\u6570\u306e\u5909\u63db","c5d1ebe6":"# 2. \u95a2\u6570\u306e\u5b9a\u7fa9\u3068\u30c7\u30fc\u30bf\u306e\u6574\u5f62","6dfb2a3a":"## 2-3. \u30c7\u30fc\u30bf\u3092\u6574\u5f62\u30fb\u7d50\u5408","81515f15":"## 2-1. \u30e1\u30e2\u30ea\u3092\u7bc0\u7d04\u3059\u308b\u95a2\u6570\u306e\u5b9a\u7fa9\n\u30c7\u30fc\u30bf\u91cf\u304c\u5927\u304d\u3044\u305f\u3081\u3001\u30e1\u30e2\u30ea\u3092\u7bc0\u7d04\u3059\u308b\u51e6\u7406\u3092\u3057\u306a\u3044\u3068\u3001\u3059\u3050\u306b\u30e1\u30e2\u30ea\u30aa\u30fc\u30d0\u30fc\u3057\u307e\u3059\u3002","ebd76a5a":"https:\/\/www.kaggle.com\/ragnar123\/very-fst-model \u3092\u53c2\u8003\u306b\u3057\u3066\u3044\u307e\u3059\u3002","024ec932":"## 2-2. \u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3080\u95a2\u6570\u306e\u5b9a\u7fa9","c82421b7":"# 1. \u30e2\u30b8\u30e5\u30fc\u30eb\u306eimport","580e4f2e":"## 3-2. \u65b0\u305f\u306a\u7279\u5fb4\u91cf\u306e\u4f5c\u6210","951f8e22":"# 5. submission\u30d5\u30a1\u30a4\u30eb\u306e\u4f5c\u6210"}}