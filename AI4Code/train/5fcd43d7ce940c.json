{"cell_type":{"6ec034ac":"code","459ad5d4":"code","9cb4ba34":"code","0641e97b":"code","a1fabcc9":"code","2208740f":"code","399e7bcd":"code","99f95c95":"code","f4e4e82e":"code","43b1bd3f":"code","c3c7e112":"code","eeeb52f6":"code","7f820481":"code","6093728c":"code","f5a83ea2":"code","e6623010":"code","08dfef6e":"markdown","80d4b6d9":"markdown","20807198":"markdown","6eaa2adb":"markdown","6dc373c9":"markdown","e876a875":"markdown","4ce8df01":"markdown","4df9adc9":"markdown","55c4d450":"markdown","7b6a30ce":"markdown","e7fdc28b":"markdown","065fa482":"markdown","d1cc5f37":"markdown","d5757a19":"markdown","d93a7d71":"markdown","0c8c34ef":"markdown","c99542ee":"markdown","7d26ba9e":"markdown","f5651e97":"markdown"},"source":{"6ec034ac":"import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport ipywidgets as widgets\nfrom IPython.display import IFrame","459ad5d4":"IFrame('https:\/\/app.powerbi.com\/view?r=eyJrIjoiN2E2M2RkZGMtNDVmMC00ODJiLTlkYTUtMzU3NzM0MjViMmVlIiwidCI6ImUwNDhkZjczLWU1MDMtNDdmNC04ZWMxLWQ4YmM1NGI3NzNhNSIsImMiOjF9', width=800, height=600)","9cb4ba34":"dataset=pd.read_csv('..\/input\/Energy_Dataset.csv')","0641e97b":"dataset=dataset.iloc[:,2:]\ndataset.head()","a1fabcc9":"toggle_button = widgets.ToggleButtons(\n            options= dataset.columns[0:4],\n            description='Response Variable:',\n            disabled=False,\n            button_style='')\ntoggle_button","2208740f":"variable = toggle_button.value","399e7bcd":"var_res=[]\nvar_res.append(variable)\nfor i in list(dataset.columns[4:]):\n    var_res.append(i)\n    \nres_pred = dataset.loc[:,var_res]\nres_pred.describe()","99f95c95":"res_pred.corr()[variable]","f4e4e82e":"res_var = widgets.SelectMultiple(\n    options=list(res_pred.corr()[[variable]].index[1:]),\n    value=(),\n    rows=15,\n    description='Predictors',\n    disabled=False\n)\nres_var ","43b1bd3f":"predictors = list(res_var.value)\ny = res_pred[variable]\nX = res_pred[predictors]\n\ncols = 4\nif len(predictors)<=cols:\n    rows = 1\n    cols = len(predictors)\n    \nelse:\n    if len(predictors)%cols == 0:\n        rows = int(len(predictors)\/cols)\n    \n    else:\n        rows = int(len(predictors)\/cols) + 1\n               \nplt.style.use('ggplot')\nplt.figure(figsize=(cols*4,2*rows + 5))\nplt.tight_layout()\nfor index in range(len(predictors)):\n    plt.subplot(rows,cols, index+1)\n    plt.scatter(y, X.iloc[:,index])\n    plt.title('Predictor: '+ predictors[index])\nplt.show()","c3c7e112":"if len(predictors)==2:\n    import plotly.express as px\n    fig = px.scatter_3d(dataset, x=predictors[0], y=predictors[1], z=variable)\n    fig.show()","eeeb52f6":"predictors = list(res_var.value)\ncorr_matrix = res_pred.loc[:,predictors].corr()\ncorr_matrix[corr_matrix == 1] = np.nan\n\nplt.figure(figsize=(8, 7))\nsns.heatmap(corr_matrix, annot=True, linewidths= 2, cmap='coolwarm')\nplt.show()","7f820481":"sns.pairplot(res_pred.loc[:,predictors])\nplt.show()","6093728c":"toggle_button2 = widgets.ToggleButtons(\n            options= ['Statmodel', 'SciKitLearn', 'Gradient Descent'],\n            description='Model:',\n            disabled=False,\n            button_style='')\ntoggle_button2","f5a83ea2":"model = toggle_button2.value\n\nif model == 'Statmodel':\n    import statsmodels.api as sm\n    \n    y = res_pred[variable]\n    X = res_pred[predictors]\n    \n    X = sm.add_constant(X)\n    rmodel=sm.regression.linear_model.OLS(y,X)\n    linear_regression=rmodel.fit()\n    print(linear_regression.summary())\n    parameters = linear_regression.params\n    \nelif model=='SciKitLearn':\n    from sklearn import linear_model\n    \n    y = res_pred[variable]\n    X = res_pred[predictors]\n    \n    rmodel = linear_model.LinearRegression()\n    rmodel  = rmodel.fit(X,y)\n    print(rmodel.intercept_)\n    print(rmodel.coef_)\n    \nelif model == 'Gradient Descent':\n    \n    from sklearn.preprocessing import StandardScaler\n\n    X = res_pred[predictors]\n    elements=len(X)\n    standardization=StandardScaler()\n    Xst = standardization.fit_transform(X)\n    original_means=standardization.mean_\n    original_stds=standardization.var_**0.5\n    Xst = np.column_stack((Xst, np.ones(elements)))\n    y = res_pred[variable]\n    \n    import random\n    def random_w(p):\n        return np.array([np.random.normal() for j in range(p)])\n\n    def hypothesis(X,w): \n        return np.dot(X,w) # X is the matrix ()X and ()w are the coeficients (w only one column)\n                         # if we multiply X.w we get the matrix y(one column)\n\n    def loss(X,w,y): # \n        return hypothesis(X,w) - y # this is the loss function (Xw -y)\n\n    def squared_loss(X,w,y): #(Xw -y)*2\n        return loss(X,w,y)**2 \n\n    def gradient(X,w,y): # the loop \n        gradients = list() # defining a list\n        n = float(len( y )) # the lenght of the y\n        for j in range(len(w)):\n            gradients.append(np.sum(loss(X,w,y) * X[:,j]) \/ n) # generating coefficients\n        return gradients #everytime we loop through we generate a coefficient and we add it to the gradient\n\n    def update(X,w,y, alpha=0.01): # alpha value by default\n        return [t - alpha*g for t, g in zip(w, gradient(X,w,y))]\n\n    def optimize(X, y, alpha = 0.01, eta = 10*-12, iterations = 1000):\n        w=random_w(X.shape[1])\n        path = list()\n        for k in range(iterations):\n            SSL = np.sum(squared_loss(X, w, y))\n            new_w = update(X, w, y, alpha= alpha)\n            new_SSL= np.sum(squared_loss(X, new_w,y))\n            w = new_w\n            if k >= 5 and (new_SSL -SSL <= eta and new_SSL - SSL > -eta):\n                path.append(new_SSL)\n                return w, path\n            if k%(iterations \/20)==0:\n                path.append(new_SSL)\n        return w, path\n    \n    alpha = 0.02\n    w, path = optimize(Xst, y, alpha, eta = 10**-12, iterations=20000)\n    \n    unstandardized_betas = w[:-1] \/ original_stds\n    unstandardized_bias = w[-1]-np.sum((original_means \/\n    original_stds) * w[:-1])\n    print ('%8s: %8.4f' % ('bias', unstandardized_bias))\n    for beta,varname in zip(unstandardized_betas, predictors):\n        print ('%8s: %8.4f' % (varname, beta))","e6623010":"if len(predictors)==2 and model == 'Statmodel':\n    x_min = res_pred[predictors[0]].min()\n    x_max = res_pred[predictors[0]].max()\n\n    y_min = res_pred[predictors[1]].min()\n    y_max = res_pred[predictors[1]].max()\n\n    xx, yy = np.meshgrid(np.linspace(x_min, x_max, 300), np.linspace(y_min, y_max, 300))\n\n    zz = parameters.const + xx*parameters[predictors[0]] + yy*parameters[predictors[1]]\n    \n    import plotly.graph_objects as go\n    import plotly.express as px\n    \n    trace1 = trace1 = go.Scatter3d(\n        x=dataset[predictors[0]],\n        y=dataset[predictors[1]],\n        z=dataset[variable],\n        mode='markers'\n    )\n    \n    \n    trace2 = go.Surface(z=zz, x=xx, y=yy, colorscale='Greys', opacity=0.75)\n    \n    data_test1 = go.Data([trace1, trace2])\n    \n    fig = go.Figure(data=data_test1)\n    \n    fig.show()   ","08dfef6e":"We began exploring our dataset taken from [The ScienceDirect Website](https:\/\/www.sciencedirect.com\/science\/article\/abs\/pii\/S036054421730600X?via%3Dihub). We rely on Power BI to show the behavior of the different variables influencing the energy comsuption and price.\nThe following image is the description of the more than 20 variables included in the dataset:\n![image.png](attachment:image.png)","80d4b6d9":"## Relationship between selected predictors and response variable","20807198":"## Selecting the response variable","6eaa2adb":"## Introduction","6dc373c9":"# Weather, Socio-Economic and Energy usage for the Residential and Commercial sectors in FL, US.","e876a875":"### Visualizing the regression surface << if possible >>","4ce8df01":"## Selecting the Regression Model","4df9adc9":"### Preparing the environment and loading the dataset","55c4d450":"### Final Project","7b6a30ce":" Authors\n- Claudio Castillo\n- Carla Cespedes\n- Nicholas Rivera","e7fdc28b":"## Running the Model","065fa482":"As a Floridian consumer we would like to estimate energy comsumption and price depending on the economic perspective whether it is commercial or residential sectors.\n\nFor this reason we collected data on the climate and electricity usage on residential and commercial sectors in State of Florida.\n\nThe goal of this project is to build four different multiple regression models to accomplished the explained above.","d1cc5f37":"## Materials and Methods","d5757a19":"## Selecting the Predictors","d93a7d71":"We built an interactive report where any user can select the response variable, the predictors and the model in order to estimate the price and the energy comsumption regardles of the economic sector.","0c8c34ef":"## Correlation Matrix","c99542ee":"<a href = \"Final_Project.pbix\">Final Project Power BI<\/a>","7d26ba9e":"### Exploring our Dataset","f5651e97":"## Conclusion"}}