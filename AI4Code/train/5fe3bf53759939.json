{"cell_type":{"7fd244e8":"code","3a5df920":"code","482f7920":"code","33c2e584":"code","d34b1d6e":"code","70c2bb6b":"code","9d5cbeb9":"code","f102b221":"code","695c308c":"code","ec42a830":"code","0935000f":"code","f2d5e082":"code","bdbf4a97":"code","03e4d0be":"markdown","237993bb":"markdown","f128a35a":"markdown","e4caf987":"markdown","ba40af4a":"markdown","42c79552":"markdown","275c10de":"markdown","e4f262de":"markdown","72b81a12":"markdown","b24315e9":"markdown","165b09ed":"markdown","ee0e121e":"markdown","ddabd97d":"markdown","0a0bc2ec":"markdown","c8bb3f35":"markdown","cfbd03b9":"markdown","520d0c64":"markdown"},"source":{"7fd244e8":"import pandas as pd\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom keras.callbacks import EarlyStopping, TensorBoard\nfrom keras.layers import Dense\nfrom keras.models import Sequential\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\nfrom sklearn.preprocessing import StandardScaler\n\nfrom tqdm import tqdm\nimport numpy as np\nimport random\nimport pickle as pkl\n\nimport matplotlib.pyplot as plt","3a5df920":"dataset = pd.read_csv('..\/input\/mushrooms.csv')\ny_train = dataset['class']\nx_train = dataset.drop(labels =['class'],axis=1)\n\nohe = OneHotEncoder()\nle = LabelEncoder()\n\ncols = x_train.columns.values\nfor col in cols:\n    x_train[col] = le.fit_transform(x_train[col])\n\ny_train = le.fit_transform(y_train)\n\nohe = OneHotEncoder(categorical_features='all')\nx_train = ohe.fit_transform(x_train).toarray()\nsc = StandardScaler()\nx_train = sc.fit_transform(x_train)\n\n\nx_train, x_test, y_train, y_test = train_test_split(x_train,y_train, test_size = 0.30, random_state = 42)\nx_valid, x_test, y_valid, y_test = train_test_split(x_test,y_test, test_size = 0.50, random_state = 42)\n","482f7920":"def sigmoid(x):\n    return 1\/(1 + np.exp(-x)) \n\ndef relu(x):\n    return np.maximum(0, x)\n\ndef forward(x, w, activation):\n    return activation(np.matmul(x, w))\n\ndef accuracy_fn(y, y_hat):\n    return (np.where(y == y_hat)[0].size \/ y_hat.size)\n\ndef predict(x, y_hat, weights, activation):\n    predictions = np.zeros(shape=(x.shape[0]))\n    \n    for idx in range(x.shape[0]):\n        r1 = x[idx, :]\n        for curr_weights in weights:\n            r1 = forward(r1, curr_weights, activation)\n        predictions[idx] = np.where(r1 == np.max(r1))[0][0]\n\n    accuracy = accuracy_fn(predictions, y_hat)\n    return accuracy, predictions\n    \ndef fitness(x, y_hat, weights, activation):\n    accuracy = np.empty(shape=(weights.shape[0]))\n    for idx in range(weights.shape[0]):\n        accuracy[idx], _ = predict(x, y_hat, weights[idx, :], activation)\n    return accuracy","33c2e584":"def mat_to_vector(mat_pop_weights):\n    weights_vector = []\n    for idx in range(mat_pop_weights.shape[0]):\n        curr_vector = []\n        for layer_idx in range(mat_pop_weights.shape[1]):\n            vector_weights = np.reshape(mat_pop_weights[idx, layer_idx], newshape=(mat_pop_weights[idx, layer_idx].size))\n            curr_vector.extend(vector_weights)\n        weights_vector.append(curr_vector)\n    return np.array(weights_vector)\n\n\ndef vector_to_mat(vector_weights, mat_pop_weights):\n    mat_weights = []\n    for idx in range(mat_pop_weights.shape[0]):\n        start = 0\n        end = 0\n        for layer_idx in range(mat_pop_weights.shape[1]):\n            end = end + mat_pop_weights[idx, layer_idx].size\n            curr_vector = vector_weights[idx, start:end]\n            mat_layer_weights = np.reshape(curr_vector, newshape=(mat_pop_weights[idx, layer_idx].shape))\n            mat_weights.append(mat_layer_weights)\n            start = end\n    return np.reshape(mat_weights, newshape=mat_pop_weights.shape)","d34b1d6e":"def mating_pool(pop, fitness, num_parents):\n    parents = np.empty((num_parents, pop.shape[1]))\n    for parent_num in range(num_parents):\n        max_fitness_idx = np.where(fitness == np.max(fitness))\n        max_fitness_idx = max_fitness_idx[0][0]\n        parents[parent_num, :] = pop[max_fitness_idx, :]\n        fitness[max_fitness_idx] = -99\n    return parents\n\n\ndef crossover(parents, offspring_size):\n    offspring = np.empty(offspring_size)\n    crossover_point = np.uint32(offspring_size[1]\/2)\n\n    for k in range(offspring_size[0]):\n        \n        parent1_idx = k%parents.shape[0]\n        parent2_idx = (k+1)%parents.shape[0]\n        \n        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\n        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\n        \n    return offspring\n\n\ndef mutation(offspring_crossover, mutation_percent):\n    num_mutations = np.uint32((mutation_percent*offspring_crossover.shape[1]))\n    mutation_indices = np.array(random.sample(range(0, offspring_crossover.shape[1]), num_mutations))\n    \n    for idx in range(offspring_crossover.shape[0]):\n        random_value = np.random.uniform(-1.0, 1.0, 1)\n        offspring_crossover[idx, mutation_indices] = offspring_crossover[idx, mutation_indices] + random_value\n    \n    return offspring_crossover","70c2bb6b":"solution_per_population = 8\nnum_parents_mating = 4\nnum_generations = 100\nmutation_percent = 0.20","9d5cbeb9":"input_shape = x_train.shape[1]\noutput_shape = len(np.unique(y_train))","f102b221":"initial_weights = []\nfor curr_sol in np.arange(0, solution_per_population):\n    \n    w1 = np.random.uniform(low=-0.1, high=0.1, size=(input_shape, 128))\n    w2 = np.random.uniform(low=-0.1, high=0.1, size=(128, 64))\n    w3 = np.random.uniform(low=-0.1, high=0.1,size=(64, output_shape))\n\n    initial_weights.append(np.array([w1, w2, w3]))","695c308c":"weights_mat = np.array(initial_weights)\nweights_vector = mat_to_vector(weights_mat)\n\nbest_outputs = []\naccuracies = np.empty(shape=(num_generations))","ec42a830":"for generation in tqdm(range(num_generations)):\n\n    # vector to matrix\n    weights_mat = vector_to_mat(weights_vector, weights_mat)\n\n    # fitness of the population\n    fit = fitness(x_train, y_train, weights_mat, activation=sigmoid)\n    \n    # assign first fitness to the array\n    accuracies[generation] = fit[0]\n\n    # selecting mating parents from pool\n    parents = mating_pool(weights_vector, fit.copy(), num_parents_mating)\n\n    # generate new population using crossover\n    offspring_crossover = crossover(parents, offspring_size=(weights_vector.shape[0]-parents.shape[0], weights_vector.shape[1]))\n\n    # adding mutation to the population\n    offspring_mutation = mutation(offspring_crossover, mutation_percent=mutation_percent)\n    \n    # new population combining parents of crossver and mut\n    weights_vector[0:parents.shape[0], :] = parents\n    weights_vector[parents.shape[0]:, :] = offspring_mutation","0935000f":"weights_mat = vector_to_mat(weights_vector, weights_mat)\nbest_weights = weights_mat [0, :]\nacc, predictions = predict(x_train, y_train, best_weights, sigmoid)\nprint(\"Accuracy of the best solution is : \", acc)","f2d5e082":"plt.plot(accuracies)\nplt.xlabel(\"Iteration\", fontsize=15)\nplt.ylabel(\"Fitness\", fontsize=15)\nplt.xticks(np.arange(0, num_generations+1, 100))\nplt.yticks(np.arange(0, 1, 0.1))\nplt.show()","bdbf4a97":"weights_mat = vector_to_mat(weights_vector, weights_mat)\nbest_weights = weights_mat [0, :]\nacc, predictions = predict(x_test, y_test, best_weights, sigmoid)\nprint(\"Accuracy of the best solution is : \", acc)","03e4d0be":"<h1 id=\"gen-architecture\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Genetic Algorithm Architecture\n        <a class=\"anchor-link\" href=\"#gen-architecture\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","237993bb":"<h1 id=\"analysis\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Analysis\n        <a class=\"anchor-link\" href=\"#analysis\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","f128a35a":"![genetic.png](https:\/\/i.imgur.com\/nIPyj03.png)\n\n<div align='center'>Copyright to Alin Cijov<\/div>","e4caf987":"### Test predictions","ba40af4a":"![ANN%20Arch.png](https:\/\/i.imgur.com\/T3sNW2l.png)","42c79552":"In computer science and operations research, a genetic algorithm (GA) is a metaheuristic inspired by the process of natural selection that belongs to the larger class of evolutionary algorithms (EA). Genetic algorithms are commonly used to generate high-quality solutions to optimization and search problems by relying on biologically inspired operators such as mutation, crossover and selection.John Holland introduced genetic algorithms in 1960 based on the concept of Darwin\u2019s theory of evolution; his student David E. Goldberg further extended GA in 1989\n\nhttps:\/\/en.wikipedia.org\/wiki\/Genetic_algorithm","275c10de":"<h1 id=\"definition\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Definition\n        <a class=\"anchor-link\" href=\"#definition\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","e4f262de":"### Resources\n\nhttps:\/\/www.linkedin.com\/pulse\/introduction-optimization-genetic-algorithm-ahmed-gad\/ <br>\nhttps:\/\/www.kdnuggets.com\/2018\/03\/introduction-optimization-with-genetic-algorithm.html <br>\nhttps:\/\/towardsdatascience.com\/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b <br>\nhttps:\/\/www.springer.com\/us\/book\/9781484241660 ","72b81a12":"### Initial weights","b24315e9":"<h1 id=\"aan-architecture\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Artificial Neural Network Architecture\n        <a class=\"anchor-link\" href=\"#aan-architecture\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","165b09ed":"<h1 id=\"training\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Training\n        <a class=\"anchor-link\" href=\"#training\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","ee0e121e":"### Vector-Matrix Manipulations","ddabd97d":"<h1 id=\"aan\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Artificial Neural Network Implementation\n        <a class=\"anchor-link\" href=\"#aan\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","0a0bc2ec":"<div style=\"width:100%;\">\n    <img style=\"width:100%;\" src=\"https:\/\/storage.googleapis.com\/kaggle-datasets-images\/478\/974\/557711140aeab7ca242d1e903c4e058e\/dataset-cover.jpg\"\/>\n<\/div>","c8bb3f35":"<h1 id=\"dataset\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Dataset\n        <a class=\"anchor-link\" href=\"#dataset\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","cfbd03b9":"### Parameters","520d0c64":"<h1 id=\"gen-implementation\" style=\"color:#024434; background:#f4684b; border:0.5px dotted;\"> \n    <center>Genetic Algorithm Implementation\n        <a class=\"anchor-link\" href=\"#gen-implementation\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>"}}