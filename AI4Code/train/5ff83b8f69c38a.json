{"cell_type":{"51b2565d":"code","bba0d26b":"code","671f0fde":"code","10986f51":"code","3af1d488":"code","c87d5439":"code","042063d9":"code","ab66baa2":"code","80859905":"code","045f113e":"code","e1e44687":"code","8c41dba9":"code","fea2d2d9":"code","40715bcf":"markdown","6a6885e6":"markdown","f8d3f314":"markdown","03c8a2bd":"markdown","b67ce0f0":"markdown","484bf3b2":"markdown"},"source":{"51b2565d":"import numpy as np\nimport pandas as pd\nimport math\nimport sklearn\nimport sklearn.preprocessing\nimport datetime\nimport os\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\n\n# split data in 80%\/10%\/10% train\/validation\/test sets\nvalid_set_size_percentage = 10 \ntest_set_size_percentage = 10 \n\n#display parent directory and working directory\nprint(os.path.dirname(os.getcwd())+':', os.listdir(os.path.dirname(os.getcwd())));\nprint(os.getcwd()+':', os.listdir(os.getcwd()));\n","bba0d26b":"tf.__version__","671f0fde":"# import all stock prices \ndf = pd.read_csv(\"..\/input\/wuliangye-stock-price\/000858.SZ_adj.csv\")\ndf = pd.DataFrame(df[['Open','Adj Close','Low','High','Volume']])\ndf.info()\ndf.head()","10986f51":"df.tail()","3af1d488":"df.describe()","c87d5439":"df.info()","042063d9":"plt.figure(figsize=(15, 5));\nplt.subplot(1,2,1);\nplt.plot(df[['Open']], color='red', label='Open')\nplt.plot(df[['Low']], color='blue', label='Low')\nplt.plot(df[['High']], color='black', label='High')\nplt.plot(df[['Adj Close']], label='Adj Close')\nplt.title('stock price')\nplt.xlabel('time [days]')\nplt.ylabel('price')\nplt.legend(loc='best')\n#plt.show()\n\nplt.subplot(1,2,2);\nplt.plot(df[['Volume']], label='Volume')\nplt.title('stock volume')\nplt.xlabel('time [days]')\nplt.ylabel('volume')\nplt.legend(loc='best');","ab66baa2":"# function for min-max normalization of stock\nfrom sklearn import preprocessing\n\ndef normalize_data(df):\n    min_max_scaler = preprocessing.MinMaxScaler()#\u9ed8\u8ba4\u4e3a\u8303\u56f40~1\uff0c\u62f7\u8d1d\u64cd\u4f5c\n    df[['Open']] = min_max_scaler.fit_transform(df[['Open']])\n    df[['Adj Close']] = min_max_scaler.fit_transform(df[['Adj Close']])\n    df[['Low']] = min_max_scaler.fit_transform(df[['Low']])\n    df[['High']] = min_max_scaler.fit_transform(df[['High']])\n    return df\n\n# function to create train, validation, test data given stock data and sequence length\ndef load_data(stock, seq_len):\n    data_raw = stock.as_matrix() # convert to numpy array\n    data = []\n    \n    # create all possible sequences of length seq_len\n    for index in range(len(data_raw) - seq_len): \n        data.append(data_raw[index: index + seq_len])\n    \n    data = np.array(data);\n    valid_set_size = int(np.round(valid_set_size_percentage\/100*data.shape[0]));  \n    test_set_size = int(np.round(test_set_size_percentage\/100*data.shape[0]));\n    train_set_size = data.shape[0] - (valid_set_size + test_set_size);\n    \n    x_train = data[:train_set_size,:-1,:]\n    y_train = data[:train_set_size,-1,:]\n    \n    x_valid = data[train_set_size:train_set_size+valid_set_size,:-1,:]\n    y_valid = data[train_set_size:train_set_size+valid_set_size,-1,:]\n    \n    x_test = data[train_set_size+valid_set_size:,:-1,:]\n    y_test = data[train_set_size+valid_set_size:,-1,:]\n    \n    return [x_train, y_train, x_valid, y_valid, x_test, y_test]\n\ndf_stock = df\ndf_stock.drop(['Volume'],1,inplace=True)\n\ncols = list(df_stock.columns.values)\nprint('df_stock.columns.values = ', cols)\n\n# normalize stock\ndf_stock_norm = df_stock.copy()\n# df_stock_norm = normalize_data(df_stock_norm)\n\n# create train, test data\nseq_len = 20 # choose sequence length\nx_train, y_train, x_valid, y_valid, x_test, y_test = load_data(df_stock_norm, seq_len)\nprint('x_train.shape = ',x_train.shape)\nprint('y_train.shape = ', y_train.shape)\nprint('x_valid.shape = ',x_valid.shape)\nprint('y_valid.shape = ', y_valid.shape)\nprint('x_test.shape = ', x_test.shape)\nprint('y_test.shape = ',y_test.shape)","80859905":"plt.figure(figsize=(15, 5));\nplt.plot(df_stock_norm.Open.values, color='red', label='open')\nplt.plot(df_stock_norm.Low.values, color='blue', label='low')\nplt.plot(df_stock_norm.High.values, color='black', label='high')\nplt.plot(df_stock_norm[['Adj Close']], label='low')\n#plt.plot(df_stock_norm.volume.values, color='gray', label='volume')\nplt.title('stock')\nplt.xlabel('time [days]')\nplt.ylabel('normalized price\/volume')\nplt.legend(loc='best')\nplt.show()","045f113e":"## Basic Cell RNN in tensorflow\nfrom sklearn import metrics\n\nindex_in_epoch = 0;\nperm_array  = np.arange(x_train.shape[0])\nnp.random.seed(88)\nnp.random.shuffle(perm_array)\n\n# function to get the next batch\ndef get_next_batch(batch_size):\n    global index_in_epoch, x_train, perm_array   \n    start = index_in_epoch\n    index_in_epoch += batch_size\n    \n    if index_in_epoch > x_train.shape[0]:\n        np.random.shuffle(perm_array) # shuffle permutation array\n        start = 0 # start next epoch\n        index_in_epoch = batch_size\n        \n    end = index_in_epoch\n    return x_train[perm_array[start:end]], y_train[perm_array[start:end]]\n\n# parameters\nn_steps = seq_len-1 \nn_inputs = 4 \nn_neurons = 200 \nn_outputs = 4\nn_layers = 3\nlearning_rate = 0.0005\nbatch_size = 50\nn_epochs = 150\ntrain_set_size = x_train.shape[0]\ntest_set_size = x_test.shape[0]\n\ntf.reset_default_graph()\n\nX = tf.placeholder(tf.float32, [None, n_steps, n_inputs])\ny = tf.placeholder(tf.float32, [None, n_outputs])\n\n# use Basic RNN Cell\nlayers = [tf.contrib.rnn.BasicRNNCell(num_units=n_neurons, activation=tf.nn.leaky_relu)\n          for layer in range(n_layers)]\n\n# use Basic LSTM Cell \n#layers = [tf.contrib.rnn.BasicLSTMCell(num_units=n_neurons, activation=tf.nn.leaky_relu)\n#         for layer in range(n_layers)]\n\n# use LSTM Cell with peephole connections\n#layers = [tf.contrib.rnn.LSTMCell(num_units=n_neurons, activation=tf.nn.leaky_relu, use_peepholes = True)\n#          for layer in range(n_layers)] \n\n# use GRU cell\n#layers = [tf.contrib.rnn.GRUCell(num_units=n_neurons, activation=tf.nn.leaky_relu)\n#          for layer in range(n_layers)]\n                                                                     \nmulti_layer_cell = tf.contrib.rnn.MultiRNNCell(layers)\nrnn_outputs, states = tf.nn.dynamic_rnn(multi_layer_cell, X, dtype=tf.float32)\n\nstacked_rnn_outputs = tf.reshape(rnn_outputs, [-1, n_neurons]) \nstacked_outputs = tf.layers.dense(stacked_rnn_outputs, n_outputs)\noutputs = tf.reshape(stacked_outputs, [-1, n_steps, n_outputs])\noutputs = outputs[:,n_steps-1,:] # keep only last output of sequence\n                                              \nloss = tf.reduce_mean(tf.square(outputs - y)) # loss function = mean squared error \noptimizer = tf.train.AdamOptimizer(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08) \ntraining_op = optimizer.minimize(loss)\n                   \nbest_mse = 1    \n# run graph\nwith tf.Session() as sess: \n    sess.run(tf.global_variables_initializer())\n    for iteration in range(int(n_epochs)):\n        x_batch, y_batch = get_next_batch(batch_size) # fetch the next training batch \n        sess.run(training_op, feed_dict={X: x_batch, y: y_batch}) \n        mse_train = loss.eval(feed_dict={X: x_train, y: y_train}) \n        mse_valid = loss.eval(feed_dict={X: x_valid, y: y_valid}) \n        mse_test = loss.eval(feed_dict={X: x_test, y: y_test}) \n        print('%d epochs: MSE train\/valid\/test = %.8f\/%.8f\/%.8f'%(\n                iteration, mse_train, mse_valid, mse_test))\n        if mse_test < best_mse:\n            best_mse = mse_test\n            print('Best n_epochs = %d'%(iteration))\n            print('Best MSE_test = %.8f'%(mse_test))\n    print('Finished\uff01')\n\n    y_train_pred = sess.run(outputs, feed_dict={X: x_train})\n    y_valid_pred = sess.run(outputs, feed_dict={X: x_valid})\n    y_test_pred = sess.run(outputs, feed_dict={X: x_test})","e1e44687":"def mape(y_true, y_pred):\n    return np.mean(np.abs((y_pred - y_true) \/ y_true)) * 100\n\nrmse_test = np.sqrt(metrics.mean_squared_error(y_test, y_test_pred))\nmape_test = mape(y_test, y_test_pred)\nprint(\"RMSE_test = %.8f\"%(rmse_test))\nprint(\"MAPE_test =\"+ str(round(mape_test,8))+\"%\")","8c41dba9":"y_train.shape","fea2d2d9":"ft = 0 # 0 = open, 1 = close, 2 = highest, 3 = lowest\n\n## show predictions\nplt.figure(figsize=(15, 5));\nplt.subplot(1,2,1);\n\nplt.plot(np.arange(y_train.shape[0]), y_train[:,ft], color='blue', label='train target')\n\nplt.plot(np.arange(y_train.shape[0], y_train.shape[0]+y_valid.shape[0]), y_valid[:,ft],\n         color='gray', label='valid target')\n\nplt.plot(np.arange(y_train.shape[0]+y_valid.shape[0],\n                   y_train.shape[0]+y_test.shape[0]+y_test.shape[0]),\n         y_test[:,ft], color='black', label='test target')\n\nplt.plot(np.arange(y_train_pred.shape[0]),y_train_pred[:,ft], color='red',\n         label='train prediction')\n\nplt.plot(np.arange(y_train_pred.shape[0], y_train_pred.shape[0]+y_valid_pred.shape[0]),\n         y_valid_pred[:,ft], color='orange', label='valid prediction')\n\nplt.plot(np.arange(y_train_pred.shape[0]+y_valid_pred.shape[0],\n                   y_train_pred.shape[0]+y_valid_pred.shape[0]+y_test_pred.shape[0]),\n         y_test_pred[:,ft], color='green', label='test prediction')\n\nplt.title('past and future stock prices')\nplt.xlabel('time [days]')\nplt.ylabel('normalized price')\nplt.legend(loc='best');\n\nplt.subplot(1,2,2);\n\nplt.plot(np.arange(y_train.shape[0], y_train.shape[0]+y_test.shape[0]),\n         y_test[:,ft], color='black', label='test target')\n\nplt.plot(np.arange(y_train_pred.shape[0], y_train_pred.shape[0]+y_test_pred.shape[0]),\n         y_test_pred[:,ft], color='green', label='test prediction')\n\nplt.title('future stock prices')\nplt.xlabel('time [days]')\nplt.ylabel('normalized price')\nplt.legend(loc='best');\n\ncorr_price_development_train = np.sum(np.equal(np.sign(y_train[:,1]-y_train[:,0]),\n            np.sign(y_train_pred[:,1]-y_train_pred[:,0])).astype(int)) \/ y_train.shape[0]\ncorr_price_development_valid = np.sum(np.equal(np.sign(y_valid[:,1]-y_valid[:,0]),\n            np.sign(y_valid_pred[:,1]-y_valid_pred[:,0])).astype(int)) \/ y_valid.shape[0]\ncorr_price_development_test = np.sum(np.equal(np.sign(y_test[:,1]-y_test[:,0]),\n            np.sign(y_test_pred[:,1]-y_test_pred[:,0])).astype(int)) \/ y_test.shape[0]\n\nprint('correct sign prediction for close - open price for train\/valid\/test: %.8f\/%.8f\/%.8f'%(\n    corr_price_development_train, corr_price_development_valid, corr_price_development_test))\n","40715bcf":"# 5. Predictions <a class=\"anchor\" id=\"5-bullet\"><\/a> ","6a6885e6":"# 4. Model and validate data <a class=\"anchor\" id=\"4-bullet\"><\/a> \n- RNNs with basic, LSTM, GRU cells\n","f8d3f314":"**Author:** Raoul Malm  \n\n**Description:** \n\nThis notebook demonstrates the future price prediction for different stocks using recurrent neural networks in tensorflow. Recurrent neural networks with basic, LSTM or GRU cells are implemented. \n\n**Outline:**\n\n1. [Libraries and settings](#1-bullet)\n2. [Analyze data](#2-bullet)\n3. [Manipulate data](#3-bullet)\n4. [Model and validate data](#4-bullet)\n5. [Predictions](#5-bullet)\n\n**Reference:**  \n\n[LSTM_Stock_prediction-20170507 by BenF](https:\/\/www.kaggle.com\/benjibb\/lstm-stock-prediction-20170507\/notebook)","03c8a2bd":"# 2. Analyze data <a class=\"anchor\" id=\"2-bullet\"><\/a> \n- load stock prices from prices-split-adjusted.csv\n- analyze data","b67ce0f0":"# 3. Manipulate data <a class=\"anchor\" id=\"3-bullet\"><\/a> \n- choose a specific stock\n- drop feature: volume\n- normalize stock data\n- create train, validation and test data sets","484bf3b2":"# 1. Libraries and settings <a class=\"anchor\" id=\"1-bullet\"><\/a> "}}