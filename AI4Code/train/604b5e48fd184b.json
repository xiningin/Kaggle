{"cell_type":{"16c1c719":"code","6f4bda1e":"code","94803a12":"code","0f5a257e":"code","a3396159":"code","27d3c95f":"code","10c7bdaf":"code","408d2b56":"code","e9ea356c":"code","6fc35285":"code","1a2557d5":"code","3ac22916":"code","6181f4fb":"code","8ee2b88b":"code","63023bfa":"code","df69e743":"code","79f6fa0d":"code","0202294b":"code","70bf4543":"code","701beaa5":"code","f76312c5":"code","888f3142":"code","4488ab9e":"code","bf709e20":"code","d5808029":"code","b79d2d68":"code","57ee249f":"code","8c6b6270":"code","969b3986":"code","b872838f":"code","4c81c281":"code","ec1dcdbd":"code","ef2ff81f":"code","d8280ef3":"code","94e41af3":"code","eab142de":"code","043fc805":"code","ed4d728a":"code","68297418":"code","c0da727b":"code","4f283060":"code","30556ef8":"code","9f336652":"code","6f1aaedb":"code","7de13e72":"code","1e69f5a1":"code","4a6bb1bc":"code","b3f6013d":"code","fc44c90d":"code","207a8260":"code","9da59475":"code","296702c7":"code","f48f1abd":"code","ea78736a":"code","45104d4b":"code","580ba7fd":"code","439d0309":"code","00321bef":"code","6c60aa25":"code","ca13b460":"code","9a90f7a6":"code","2194efff":"code","08f79eb2":"code","7aff3c85":"code","c65741b8":"code","9ab56d7c":"code","d08d47bd":"code","913ff35f":"code","0da21def":"code","7b98d922":"code","568f9d5d":"code","0a32016f":"code","b5caf97d":"code","0cac2917":"code","37eb4445":"code","187334fb":"code","13b2c6ad":"code","0622dcbf":"code","50fc860d":"code","4b61e44c":"code","11d292ba":"code","d7c0251a":"code","835aa5ad":"code","87254f00":"code","3e39c311":"code","3fd34cfd":"code","feeb0717":"code","45025ac0":"code","889912ad":"code","75e6c07a":"code","46982efa":"code","4959df9b":"code","9fc2b10e":"code","31d5d427":"code","dd358a5f":"code","a6cc1759":"code","28c08060":"markdown","de2305a2":"markdown","cdf9aee8":"markdown","cb683547":"markdown","20e5574c":"markdown","d66c53de":"markdown","c84b2080":"markdown","eb43d301":"markdown","119358aa":"markdown","fa73c798":"markdown","aa059e12":"markdown","e9a0da7f":"markdown","16678219":"markdown","6d3cf496":"markdown","9bacfb05":"markdown","de9c4b46":"markdown","aceeb753":"markdown","6c49ed7e":"markdown","c82d47d2":"markdown","65283bf1":"markdown","245fbcba":"markdown","5d011736":"markdown","67e2fcef":"markdown","f42e86ef":"markdown","4247036b":"markdown","2be11a28":"markdown","24b54fdc":"markdown","d3d09619":"markdown","33665483":"markdown","745359a0":"markdown","8a9fd1ab":"markdown","c5189b15":"markdown","c4815226":"markdown","2a058c8f":"markdown","33f702e6":"markdown","5b72ff02":"markdown","e7a63d69":"markdown","468447b1":"markdown","13875f05":"markdown","09970d11":"markdown","1570f7cf":"markdown","f945c9ce":"markdown","fc60f7b3":"markdown","f86a9fdd":"markdown","8d335e25":"markdown","157a9039":"markdown","3796f61e":"markdown","39b88a48":"markdown","9d7fcd4d":"markdown","9ee8abb5":"markdown","43d01fce":"markdown","56cdc187":"markdown","adce4eea":"markdown","f8c69615":"markdown","51884834":"markdown","91c4d892":"markdown","d94fc574":"markdown","be912dc9":"markdown","41af47dc":"markdown","933a7748":"markdown","9af784f1":"markdown","25ed80a3":"markdown","18bba976":"markdown","008f1c58":"markdown","0e49bbbb":"markdown","0a136fbd":"markdown","7e26c91c":"markdown","7048bacc":"markdown","ec1f010d":"markdown","727f083c":"markdown","f78975ef":"markdown","42ab1bf6":"markdown","ed806876":"markdown","f743c855":"markdown","1078112a":"markdown","069abcb2":"markdown","0fb52c18":"markdown","49fcad7d":"markdown","dcc079dc":"markdown","e4d1430f":"markdown","0c521ca7":"markdown","f75eb029":"markdown","6807035f":"markdown","f5974606":"markdown","156b5cbb":"markdown","9a6cd75f":"markdown","51159804":"markdown","15bb4b8a":"markdown","a48ab0aa":"markdown","d06da8b8":"markdown","b0f230ea":"markdown"},"source":{"16c1c719":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","6f4bda1e":"\ndf = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Aquifer_Auser.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.head()","94803a12":"df1 = df.dropna(subset=['Rainfall_Gallicano', 'Rainfall_Pontetetto', 'Rainfall_Monte_Serra',\n       'Rainfall_Orentano', 'Rainfall_Borgo_a_Mozzano', 'Rainfall_Piaggione',\n       'Rainfall_Calavorno', 'Rainfall_Croce_Arcana',\n       'Rainfall_Tereglio_Coreglia_Antelminelli',\n       'Rainfall_Fabbriche_di_Vallico'])\nrain_df = df1[['Rainfall_Gallicano', 'Rainfall_Pontetetto', 'Rainfall_Monte_Serra',\n       'Rainfall_Orentano', 'Rainfall_Borgo_a_Mozzano', 'Rainfall_Piaggione',\n       'Rainfall_Calavorno', 'Rainfall_Croce_Arcana',\n       'Rainfall_Tereglio_Coreglia_Antelminelli',\n       'Rainfall_Fabbriche_di_Vallico']]\ntemp_df = df1[['Temperature_Orentano', 'Temperature_Monte_Serra',\n       'Temperature_Ponte_a_Moriano', 'Temperature_Lucca_Orto_Botanico']]\n","0f5a257e":"rain_media = rain_df.resample('Y').mean()\n\n\n# Sommo su tutti gli acquiferi che influenzano la falda\ntemp_df = df1[['Temperature_Orentano', 'Temperature_Monte_Serra',\n       'Temperature_Ponte_a_Moriano', 'Temperature_Lucca_Orto_Botanico']]\ntemp_media = temp_df.resample('Y').mean()\nh = rain_df.resample('m').mean()\ntemp_magg0 = np.array(temp_media[temp_media>0]*4.75,dtype = float)    \napp = (temp_df.resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\nkj = np.array([0.82,0.81,1.03,1.11,1.26,1.27,1.29,1.19,1.05,0.93,0.77,0.78],dtype=float)\n# kj Font S.I.I. sun exposure, Latitude: 42,5\u00b0","a3396159":"app = temp_df.resample('m').mean()\nkpj = np.concatenate((kj,kj,kj)*5,axis=0)\nkpj = np.concatenate((kj,kj,kj)*int(np.size(temp_media,0)\/3),0)\nkpj = kpj.repeat(4).reshape(np.size(h,0),np.size(temp_media,1))\naa = a.to_numpy(dtype=float).repeat(12,axis=0).reshape(np.size(h,0),np.size(temp_media,1))\n\n#potential evapotranspiration\nEpj = kpj*135*(app\/26.5)**aa\nEpj.head()\n","27d3c95f":"import matplotlib.pyplot as plt\nfig = plt.figure(figsize=(20,10))\nfig.suptitle('Potenzial Evapotraspiration Aqufer Auser')\nT = Epj.iloc[:,:].values\nH = h.iloc[:,:].values\nfor d in range(1,np.size(temp_media,1)+1):\n    temp = T[:,d-1]\n    alt = H[:,d-1]\n    plt.subplot(2,2,d)\n    ylab = 'h + Epj '+ temp_media.columns[d-1][12:]\n    plt.plot(Epj.index,temp,color='red',label='Epj')\n    plt.plot(h.index,alt,color='blue',label='h')\n    plt.ylabel(ylab),plt.xlabel('time')\n    plt.legend(loc='best')\n    ","10c7bdaf":"import seaborn as sns\nsns.set(style='whitegrid',context='notebook')\ncols = ['Depth_to_Groundwater_SAL', 'Depth_to_Groundwater_PAG',\n       'Depth_to_Groundwater_CoS', 'Depth_to_Groundwater_DIEC','Volume_POL', 'Volume_CC1', 'Volume_CC2', 'Volume_CSA', 'Volume_CSAL',\n       'Hydrometry_Monte_S_Quirico', 'Hydrometry_Piaggione']\ndf_drna = df.dropna()\nsns.pairplot(df_drna[cols],size=2.5)\n","408d2b56":"cm = np.corrcoef(df_drna[cols].values.T)\nsns.set(font_scale=1.5)\nhm = sns.heatmap(cm,cbar=True,annot=True,square=True,fmt='.2f',annot_kws={'size' : 8},yticklabels=cols,xticklabels=cols)\n\n","e9ea356c":"from sklearn.linear_model import LinearRegression\nslt = LinearRegression()\nX = df_drna[['Hydrometry_Monte_S_Quirico']].values\ny = df_drna['Depth_to_Groundwater_PAG'].values\nslt.fit(X,y)\nfig=plt.figure(figsize=(7,5))\nsns.regplot(X,y,slt)\nplt.xlabel('Hydrometry Monte S. Quirico')\nplt.ylabel('Depth to Groundwater PAG')\n\nprint('slope: %.3f'% slt.coef_[0])\nprint('Intercept: %.3f' % slt.intercept_)","6fc35285":"\ncols = ['Depth_to_Groundwater_SAL', 'Depth_to_Groundwater_PAG',\n       'Depth_to_Groundwater_CoS', 'Depth_to_Groundwater_DIEC',\n       'Hydrometry_Monte_S_Quirico', 'Hydrometry_Piaggione']\n\nvol = ['Volume_POL', 'Volume_CC1', 'Volume_CC2', 'Volume_CSA', 'Volume_CSAL']\n\ndf_drna = df.dropna()\n\ndf_new = df_drna[cols]\nX = df_new.iloc[:,:].values\ny = df_drna[vol].mean(axis=1).values\ny = y.reshape(-1,1)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\nsc_x = StandardScaler()\nsc_y = StandardScaler()\nX_std = sc_x.fit_transform(X)\ny_std = sc_y.fit_transform(y)\nslr=LinearRegression()\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.3,random_state=0)\nslr.fit(X_train,y_train)\ny_train_pred = slr.predict(X_train)\ny_test_pred = slr.predict(X_test)\nplt.scatter(y_train_pred, y_train_pred - y_train, c='blue',marker='o',label='Train data')\nplt.scatter(y_test_pred,y_test_pred-y_test, c = 'lightgreen',marker='s',label='Test data')\nplt.hlines(0,xmin=-10000,xmax=-6000,lw=2,color='red')\nplt.xlim([-10000,-6000])\nplt.xlabel('Predicted values')\nplt.ylabel('Residual')\nplt.legend(loc='best')","1a2557d5":"from sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import r2_score\nprint('MSE Train: %.3f , Test: %.3f' % (mean_squared_error(y_train,y_train_pred),mean_squared_error(y_test,y_test_pred)))\nprint('RMSE Train: %.3f , Test: %.3f' % (mean_squared_error(y_train,y_train_pred)**0.5,mean_squared_error(y_test,y_test_pred)**0.5))\nprint('R^2 Train: %.3f , Test: %.3f' % (r2_score(y_train,y_train_pred)**0.5,r2_score(y_test,y_test_pred)**0.5))","3ac22916":"X = df_drna[['Hydrometry_Monte_S_Quirico']].values\ny = df_drna['Depth_to_Groundwater_PAG'].values\n\n\nfrom sklearn.linear_model import LinearRegression\nregr = LinearRegression()\n\n# Creo polinomio \nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.metrics import r2_score\nquadratic = PolynomialFeatures(degree=2)\ncubic = PolynomialFeatures(degree=3)\nX_quad = quadratic.fit_transform(X)\nX_cubic = cubic.fit_transform(X)\n\n#Linear fit\nX_fit = np.arange(X.min(),X.max(),1)[:, np.newaxis]\nregr = regr.fit(X,y)\ny_lin_fit = regr.predict(X_fit)\nlinear_r2 = r2_score(y, regr.predict(X))\n\n#Quadratic fit\nregr = regr.fit(X_quad,y)\ny_quad_fit = regr.predict(quadratic.fit_transform(X_fit))\nquadratic_r2 = r2_score(y,regr.predict(X_quad))\n\n#cubic fit\nregr = regr.fit(X_cubic,y)\ny_cubic_fit = regr.predict(cubic.fit_transform(X_fit))\ncubic_r2 = r2_score(y, regr.predict(X_cubic))\n\n#plot results\nfig=plt.figure(figsize=(15,7))\nplt.scatter(X,y,label='punti di addestramento',color='lightgray')\nplt.plot(X_fit,y_lin_fit,label='lineare (d=1), $R^2=%.2f$' % linear_r2,color='blue',lw=2,linestyle=':')\nplt.plot(X_fit,y_quad_fit,label='quadratic (d=2), $R^2=%.2f$' % quadratic_r2,color='red',lw=2,linestyle='-')\nplt.plot(X_fit,y_cubic_fit,label='cubic (d=3), $R^2=%.2f$' % cubic_r2,color='green',lw=2,linestyle='--')\nplt.xlabel('Hydrometry_Monte_S_Quirico')\nplt.ylabel('Depth_to_groundwater_PAG')\nplt.legend(loc='best')\n ","6181f4fb":"X = df_new.iloc[:,:].values\ny = df_drna[vol].mean(axis=1).values\n\nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=0)\nfrom sklearn.ensemble import RandomForestRegressor\nforest = RandomForestRegressor(n_estimators=1000,criterion='mse',random_state=0,n_jobs=-1)\nforest.fit(X_train,y_train)\ny_train_pred = forest.predict(X_train)\ny_test_pred = forest.predict(X_test)\nmean_squared_error(y_test,y_test_pred)\nmean_squared_error(y_train,y_train_pred)-mean_squared_error(y_test,y_test_pred)\nplt.scatter(y_train_pred,y_train_pred-y_train,c='black',marker='o',s=35,alpha=0.5,label='data train')\nplt.scatter(y_test_pred,y_test_pred-y_test,c='lightgreen',marker='s',s=35,alpha=0.7,label='data test')\nplt.hlines(y=0,xmin=-11000,xmax=-6000,color='red')\nplt.xlabel('Predicted values')\nplt.ylabel('Residuals')\nplt.title('Regressione a foreste casuali')\nplt.legend(loc='best')\n\n\n","8ee2b88b":"print('MSE Train: %.3f , Test: %.3f' %(mean_squared_error(y_train,y_train_pred),mean_squared_error(y_test,y_test_pred)))\nprint('RMSE Train: %.3f , Test: %.3f' %(mean_squared_error(y_train,y_train_pred)**0.5,mean_squared_error(y_test,y_test_pred)**0.5))\nprint('R^2 Train: %.3f , Test: %.3f' %(r2_score(y_train,y_train_pred),r2_score(y_test,y_test_pred)))","63023bfa":"\ndf_drna = df.dropna()\nvol = df_drna[['Volume_POL', 'Volume_CC1', 'Volume_CC2', 'Volume_CSA', 'Volume_CSAL']]\n\nX = vol.iloc[:,:].values\nQ = -X\/24\nt = np.arange(24,(np.size(Q,0)+1)*24,24)\nt = t.reshape(-1,1)\n\nfig = plt.figure(figsize=(20,10))\nfig.suptitle('Acqufer Auser')\nfor i in range(1,np.size(vol,1)+1):\n    q = Q[:,i-1]\n    if sum(q==0)!=0:\n        q = q[sum(q==0):]\n        t = np.arange(24,(np.size(q)+1)*24,24)\n        t = t.reshape(-1,1)\n    q = np.log(q)\n    slr = LinearRegression()\n    slr.fit(t,q)\n    plt.subplot(3,2,i)\n    ylab = 'log(Q0) '+vol.columns[i-1][7:]\n    sns.regplot(t,q,slr,label='k: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_))\n    plt.xlabel('time')\n    plt.ylabel(ylab)\n    plt.legend(loc='best')\n ","df69e743":"from statsmodels.graphics.tsaplots import plot_pacf\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\nimport matplotlib.pyplot as plt\nfig = plt.figure(figsize=(20,10))\nplt.suptitle('Depth to Groundwater')\ncols = ['Depth_to_Groundwater_LT2',\n       'Depth_to_Groundwater_SAL', 'Depth_to_Groundwater_PAG',\n       'Depth_to_Groundwater_CoS', 'Depth_to_Groundwater_DIEC']\nfor i in range(1,len(cols)+1):\n    df1 = df.dropna(subset=[cols[i-1]])\n    df1[cols[0]][df1[cols[0]]==0]=df1[cols[0]].mean(axis=0)\n    df_mou = df1.resample('m').mean()\n    plt.subplot(3,2,i)\n    df_mou[cols[i-1]].plot(),plt.ylabel(cols[i-1][21:])","79f6fa0d":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Partial Autocorrelation')\nfig.subplots_adjust()\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[0]][df_drna[cols[0]]==0]=df_drna[cols[0]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    ax = fig.add_subplot(3,2,i)\n    plot_pacf(df_mou[cols[i-1]],ax,title=None),plt.ylabel(cols[i-1][21:]),plt.xlabel('lag')\n    ","0202294b":"split = \"2019-12-31\"\nfig = plt.figure(figsize=(20,10))\nplt.suptitle('Train - Test')\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[0]][df_drna[cols[0]]==0]=df_drna[cols[0]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    train = df_mou[df_mou.index <= split]\n    test = df_mou[df_mou.index >= split]\n    test = test[test.index < '2020-07-31']\n    fig, plt.subplot(3,2,i)\n    train[cols[i-1]].plot(label='train'),test[cols[i-1]].plot(label='test')\n    plt.ylabel(cols[i-1][21:])\n    plt.legend(loc='best')","70bf4543":"fig = plt.figure(figsize=(15,8))\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[i-1]][df_drna[cols[i-1]]==0]=df_drna[cols[i-1]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    train = df_mou[df_mou.index <= split]\n    test = df_mou[df_mou.index >= split]\n    test = test[test.index < '2020-07-31']\n    model = SARIMAX(train[cols[i-1]],order=(3,1,1),seasonal_order=(3,1,1,12),enforce_stationarity=False)\n    fitted_model = model.fit(maxiter=200,disp=True)\n    #fitted_model.summary() #sommario analisi\n    train_residui = fitted_model.resid #residui aleatori [train - train_predicted]\n    in_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\n    out_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\n    fig = plt.figure(figsize=(15,8))\n    plt.suptitle('SARIMA '+cols[i-1])\n    plt.subplot(3,1,1)\n    train[cols[i-1]].plot(label='train'),test[cols[i-1]].plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='best')\n    plt.subplot(3,1,2)\n    train_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylim([-2,2])\n    plt.subplot(3,1,3)\n    in_sample['mean'].plot(label='Forecasted Values'),train[cols[i-1]].plot(label='Misured values'),plt.legend(loc='best'),plt.ylabel(cols[i-1])\n","701beaa5":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndf = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Aquifer_Doganella.csv',index_col='Date')\n\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.head()","f76312c5":"df_raitemp = df[['Rainfall_Monteporzio', 'Rainfall_Velletri','Temperature_Monteporzio', 'Temperature_Velletri']]\n\n###### Monteporzio $$$$$$$$$\n\ndf_new = df_raitemp.dropna(subset=['Rainfall_Monteporzio','Temperature_Monteporzio'])\n##### I check amount data Temperature\ndf['Temperature_Monteporzio'].resample('Y').count()","888f3142":"h1 = df_raitemp['Rainfall_Monteporzio'].resample('m').mean()\ntemp1_media = df_raitemp['Temperature_Monteporzio'].resample('Y').mean()\n\ntemp_magg0 = np.array(temp1_media[temp1_media>0]*4.75,dtype = float)\n\napp = (df_raitemp['Temperature_Monteporzio'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\n# kj Fonte S.I.I. tabellato e dipende dall'esposizione al sole, Latitudine: 42,5\u00b0\n\napp = df_new['Temperature_Monteporzio'].resample('m').mean()\nkpj = np.concatenate((kj,kj)*8,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n#Stima del defici Idrico \nEpj1= kpj*135*(app\/26.5)**aa\nEpj1[Epj1.isna()] = Epj1.mean()\nEpj1[Epj1>40] = Epj1.mean()\nylab = 'h + Epj '+ 'Monteporzio'\nplt.subplot(2,1,1)\nplt.plot(Epj1.index,Epj1,color='red',label='Epj'),plt.plot(h1.index,h1,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n### Velletri\n\ndf_new = df_raitemp.dropna(subset=['Rainfall_Velletri','Temperature_Velletri'])\nh2 = df_raitemp['Rainfall_Velletri'].resample('m').mean()\ntemp2_media = df_raitemp['Temperature_Velletri'].resample('Y').mean()\n\ntemp_magg0 = np.array(temp2_media[temp1_media>0]*4.75,dtype = float)\n\napp = (df_raitemp['Temperature_Velletri'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\n# kj Fonte S.I.I. tabellato e dipende dall'esposizione al sole, Latitudine: 42,5\u00b0\n\napp = df_new['Temperature_Velletri'].resample('m').mean()\nkpj = np.concatenate((kj,kj)*8,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n#Stima del defici Idrico mensile per gli anni di osservazione\nEpj2= kpj*135*(app\/26.5)**aa\nEpj2[Epj2.isna()] = Epj2.mean()\nEpj2[Epj2>40] = Epj2.mean()\nylab = 'h + Epj '+ 'Velletri'\nplt.subplot(2,1,2)\nplt.plot(Epj2.index,Epj2,color='red',label='Epj'),plt.plot(h2.index,h2,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n","4488ab9e":"app = df[['Depth_to_Groundwater_Pozzo_1', 'Depth_to_Groundwater_Pozzo_2',\n       'Depth_to_Groundwater_Pozzo_3', 'Depth_to_Groundwater_Pozzo_4',\n       'Depth_to_Groundwater_Pozzo_5', 'Depth_to_Groundwater_Pozzo_6',\n       'Depth_to_Groundwater_Pozzo_7', 'Depth_to_Groundwater_Pozzo_8',\n       'Depth_to_Groundwater_Pozzo_9', 'Volume_Pozzo_1', 'Volume_Pozzo_2',\n       'Volume_Pozzo_3', 'Volume_Pozzo_4', 'Volume_Pozzo_5+6',\n       'Volume_Pozzo_7', 'Volume_Pozzo_8', 'Volume_Pozzo_9']].resample('Y').count()\n\napp[app > 0].dropna()","bf709e20":"import seaborn as sns\ncols = ['Volume_Pozzo_1', 'Volume_Pozzo_2','Volume_Pozzo_3', 'Volume_Pozzo_4', 'Volume_Pozzo_5+6',\n       'Volume_Pozzo_7', 'Volume_Pozzo_8', 'Volume_Pozzo_9']\n\ndf_drna = df.dropna(subset=cols)\n\nsns.set(style='whitegrid',context='notebook')\nsns.pairplot(df_drna[cols],size=2.5)\n","d5808029":"cm = np.corrcoef(df_drna[cols].values.T)\nsns.set(font_scale=1.5)\nhm = sns.heatmap(cm,cbar=True,annot=True,square=True,fmt='.2f',annot_kws={'size' : 10},yticklabels=cols,xticklabels=cols)\n","b79d2d68":"fig = plt.figure(figsize = (20,12))\nfrom sklearn.linear_model import LinearRegression\nslt = LinearRegression()\nX = df_drna[['Volume_Pozzo_2']].values\ny = df_drna['Volume_Pozzo_9'].values\nslt.fit(X,y)\nplt.subplot(2,2,1)\nsns.regplot(X,y,slt,label='slope: %.5f Intercept: %.3f' % (slt.coef_[0],slt.intercept_)),plt.xlabel('Volume_Pozzo_2'),plt.ylabel('Volume_Pozzo_9'),plt.legend(loc='best')\n\nX = df_drna[['Volume_Pozzo_3']].values\nplt.subplot(2,2,2)\nsns.regplot(X,y,slt,label='slope: %.5f Intercept: %.3f' % (slt.coef_[0],slt.intercept_)),plt.xlabel('Volume_Pozzo_3'),plt.ylabel('Volume_Pozzo_9'),plt.legend(loc='best')\n\nX = df_drna[['Volume_Pozzo_4']].values\nplt.subplot(2,2,3)\nsns.regplot(X,y,slt,label='slope: %.5f Intercept: %.3f' % (slt.coef_[0],slt.intercept_)),plt.xlabel('Volume_Pozzo_4'),plt.ylabel('Volume_Pozzo_9'),plt.legend(loc='best')\n\nX = df_drna[['Volume_Pozzo_7']].values\nplt.subplot(2,2,4)\nsns.regplot(X,y,slt,label='slope: %.5f Intercept: %.3f' % (slt.coef_[0],slt.intercept_)),plt.xlabel('Volume_Pozzo_7'),plt.ylabel('Volume_Pozzo_9'),plt.legend(loc='best')\n","57ee249f":"from sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nslt = LinearRegression()\nX = df_drna[cols].iloc[:,:-1]\ny = df_drna['Volume_Pozzo_9'].values\n\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.3,random_state=0)\nslt.fit(X_train,y_train)\ny_train_pred = slt.predict(X_train)\ny_test_pred = slt.predict(X_test)\nplt.scatter(y_train_pred, y_train_pred - y_train, c='blue',marker='o',label='Train Data'),plt.scatter(y_test_pred,y_test_pred-y_test, c = 'lightgreen',marker='s',label='Test Data'),plt.xlabel('Predicted Values'),plt.ylabel('residual'),plt.legend(loc='best')\nplt.hlines(0,0,4000,color='red')","8c6b6270":"from sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import r2_score\nprint('MSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred),mean_squared_error(y_test, y_test_pred)))\nprint('RMSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred)**0.5,mean_squared_error(y_test, y_test_pred)**0.5))\nprint('R^2: Train %.3f Test: %.3f' % (r2_score(y_train, y_train_pred),r2_score(y_test, y_test_pred)))\n\n\n","969b3986":"from sklearn.ensemble import RandomForestRegressor\nforest = RandomForestRegressor(n_estimators=1000,criterion='mse',random_state=0,n_jobs=-1)\nforest.fit(X_train,y_train)\ny_train_pred = forest.predict(X_train)\ny_test_pred = forest.predict(X_test)\nmean_squared_error(y_test,y_test_pred)\nmean_squared_error(y_train,y_train_pred)-mean_squared_error(y_test,y_test_pred)\nplt.scatter(y_train_pred,y_train_pred-y_train,c='black',marker='o',s=35,alpha=0.5,label='Train Data'),plt.scatter(y_test_pred,y_test_pred-y_test,c='lightgreen',marker='s',s=35,alpha=0.7,label='Test Data'),plt.xlabel('Predicted Values'),plt.ylabel('Residual'),plt.title('Random Forest Method'),plt.legend(loc='best')\nplt.hlines(0,0,4500,color='red')","b872838f":"print('MSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred),mean_squared_error(y_test, y_test_pred)))\nprint('RMSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred)**0.5,mean_squared_error(y_test, y_test_pred)**0.5))\nprint('R^2: Train %.3f Test: %.3f' % (r2_score(y_train, y_train_pred),r2_score(y_test, y_test_pred)))\n\n","4c81c281":"X = df_drna[cols].iloc[:,:].values\n\nQ = X\/24\nt = np.arange(24,(np.size(Q,0)+1)*24,24)\nt = t.reshape(-1,1)\n\nfig = plt.figure(figsize=(40,20))\nfig.suptitle('Aqufer Doganella')\nfor i in range(1,np.size(cols)+1):\n    q = Q[:,i-1]\n    if sum(q==0)!=0:\n        q = q[q >0]\n        t = np.arange(24,(np.size(q)+1)*24,24)\n        t = t.reshape(-1,1)\n    q = np.log(q)\n    slr = LinearRegression()\n    slr.fit(t,q)\n    plt.subplot(4,2,i)\n    ylab = 'log(Q0) '+cols[i-1][7:]\n    sns.regplot(t,q,slr,label='alpha: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_)),plt.xlabel('time'),plt.ylabel(ylab),plt.legend(loc='best')\n ","ec1dcdbd":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Depth to Groundwater')\ncols = ['Depth_to_Groundwater_Pozzo_1', 'Depth_to_Groundwater_Pozzo_2',\n       'Depth_to_Groundwater_Pozzo_3', 'Depth_to_Groundwater_Pozzo_4',\n       'Depth_to_Groundwater_Pozzo_5', 'Depth_to_Groundwater_Pozzo_6',\n       'Depth_to_Groundwater_Pozzo_7', 'Depth_to_Groundwater_Pozzo_8',\n       'Depth_to_Groundwater_Pozzo_9']\nfor i in range(1,len(cols)+1):\n    df1 = df.dropna(subset=[cols[i-1]])\n    df1[cols[0]][df1[cols[0]]==0]=df1[cols[0]].mean(axis=0)\n    df_mou = df.resample('m').mean()\n    plt.subplot(3,3,i)\n    df_mou[cols[i-1]].plot(),plt.ylabel(cols[i-1][21:])","ef2ff81f":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Partial Autocorrelation')\nfig.subplots_adjust()\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[0]][df_drna[cols[0]]==0]=df_drna[cols[0]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    ax = fig.add_subplot(3,3,i)\n    plot_pacf(df_mou[cols[i-1]],ax,title=None),plt.ylabel(cols[i-1][21:]),plt.xlabel('lag')\n    ","d8280ef3":"split = \"2019-12-31\"\nfig = plt.figure(figsize=(20,10))\nplt.suptitle('Train - Test')\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[0]][df_drna[cols[0]]==0]=df_drna[cols[0]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    train = df_mou[df_mou.index <= split]\n    test = df_mou[df_mou.index >= split]\n    test = test[test.index < '2020-07-31']\n    fig, plt.subplot(3,3,i)\n    train[cols[i-1]].plot(label='train'),test[cols[i-1]].plot(label='test')\n    plt.ylabel(cols[i-1][21:])\n    plt.legend(loc='best')","94e41af3":"fig = plt.figure(figsize=(15,8))\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[i-1]][df_drna[cols[i-1]]==0]=df_drna[cols[i-1]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    train = df_mou[df_mou.index <= split]\n    test = df_mou[df_mou.index >= split]\n    test = test[test.index < '2020-07-31']\n    model = SARIMAX(train[cols[i-1]],order=(3,1,1),seasonal_order=(3,1,1,12),enforce_stationarity=False)\n    fitted_model = model.fit(maxiter=200,disp=True)\n    #fitted_model.summary() #sommario analisi\n    train_residui = fitted_model.resid #residui aleatori [train - train_predicted]\n    in_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\n    out_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\n    fig = plt.figure(figsize=(15,8))\n    plt.suptitle('SARIMA '+cols[i-1])\n    plt.subplot(3,1,1)\n    train[cols[i-1]].plot(label='train'),test[cols[i-1]].plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='best')\n    plt.subplot(3,1,2)\n    train_residui.plot(label='Resudal'),plt.legend(loc='best')\n    plt.subplot(3,1,3)\n    in_sample['mean'].plot(label='Forecasted Values'),train[cols[i-1]].plot(label='Misured Values'),plt.legend(loc='best')\n","eab142de":"df = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Aquifer_Luco.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\n\ndf.isna().sum()\/np.size(df,0)*100","043fc805":"rain_temp = df[['Rainfall_Simignano', 'Rainfall_Siena_Poggio_al_Vento',\n       'Rainfall_Mensano', 'Rainfall_Montalcinello',\n       'Rainfall_Monticiano_la_Pineta', 'Rainfall_Sovicille',\n       'Rainfall_Ponte_Orgia', 'Rainfall_Scorgiano', 'Rainfall_Pentolina',\n       'Rainfall_Monteroni_Arbia_Biena','Temperature_Siena_Poggio_al_Vento',\n       'Temperature_Mensano', 'Temperature_Pentolina',\n       'Temperature_Monteroni_Arbia_Biena']]\nimport seaborn as sns\n###### Siena ######\ndf_drna = rain_temp.dropna(subset=['Rainfall_Simignano','Temperature_Siena_Poggio_al_Vento'])\napp = (df_drna['Temperature_Siena_Poggio_al_Vento'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*10,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj1= kpj*135*(app\/26.5)**aa\n\nh1 = df_drna['Rainfall_Simignano'].resample('m').mean()\nh1 = h1[Epj1>0]\nEpj1 = Epj1[Epj1>0]\n\n#%%########## Mensano #######\ndf_drna = rain_temp.dropna(subset=['Rainfall_Montalcinello','Temperature_Mensano'])\napp = (df_drna['Temperature_Mensano'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\nkpj = np.concatenate((kj,kj)*9,0)\nkpj = np.concatenate((kpj,kj))\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj2= kpj*135*(app\/26.5)**aa\n\nh2= df_drna['Rainfall_Montalcinello'].resample('m').mean()\nh2 = h2[Epj2>0]\nEpj2 = Epj2[Epj2>0]\n#%%%####### Pentolina #######\n\ndf_drna = rain_temp.dropna(subset=['Rainfall_Montalcinello','Temperature_Pentolina'])\napp = (df_drna['Temperature_Pentolina'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\nkpj = np.concatenate((kj,kj)*9,0)\nkpj = np.concatenate((kpj,kj))\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj3= kpj*135*(app\/26.5)**aa\n\nh3 = df_drna['Rainfall_Montalcinello'].resample('m').mean()\n\n#%%%##### Monteroni_Arbia_Biena #####\n\ndf_drna = rain_temp.dropna(subset=['Rainfall_Simignano','Temperature_Monteroni_Arbia_Biena'])\napp = (df_drna['Temperature_Pentolina'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\nkpj = np.concatenate((kj,kj)*10,0)\nkpj = np.concatenate((kpj,kj))\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj4= kpj*135*(app\/26.5)**aa\n\nh4 = df_drna['Rainfall_Simignano'].resample('m').mean()\n\n### Plot Results\nfig = plt.figure(figsize=(20,10))\n\nplt.suptitle('Evapotraspiration - Rainfall')\nplt.subplot(2,2,1)\nylab = ylab = 'h + Epj '+ 'Siena'\nplt.plot(Epj1.index,Epj1,color='red',label='Epj'),plt.plot(h1.index,h1,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\nplt.subplot(2,2,2)\nylab = ylab = 'h + Epj '+ 'Mensano'\nplt.plot(Epj2.index,Epj2,color='red',label='Epj'),plt.plot(h2.index,h2,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\nplt.subplot(2,2,3)\nylab = ylab = 'h + Epj '+ 'Pentolina'\nplt.plot(Epj3.index,Epj3,color='red',label='Epj'),plt.plot(h3.index,h3,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\nplt.subplot(2,2,4)\nylab = ylab = 'h + Epj '+ 'Monteroni'\nplt.plot(Epj4.index,Epj4,color='red',label='Epj'),plt.plot(h4.index,h4,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n","ed4d728a":"cols = ['Volume_Pozzo_1', 'Volume_Pozzo_3','Volume_Pozzo_4']\n\nfrom sklearn.linear_model import LinearRegression\n\nQ = df[cols]\nQ = Q.resample('m').mean()\nfig = plt.figure(figsize=(20,10))\nfig.suptitle('Aquifer Luco')\nfor i in range(1,4):\n    slr = LinearRegression()\n    #ANBcontinuous.remove_outliers_by_boundaries(Q,cols[i-1],0.0,0.95)\n    X = Q.iloc[:,i-1].dropna()\n    X = X[X < 0]\n    X = -X\n    X = np.log(X)\n    t = np.arange(1,(np.size(X)+1),1)\n    t = t.reshape(-1,1)\n    slr.fit(t,X)\n    ylab = 'log(Q) ' + cols[i-1][7:]\n    plt.subplot(2,2,i)\n    sns.regplot(np.linspace(2015,2020,np.size(X,0)),X,slr,label='alpha: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_))\n    plt.xlabel('t[h]')\n    plt.ylabel(ylab)\n    plt.legend(loc='best')","68297418":"cols = ['Depth_to_Groundwater_Podere_Casetta',\n       'Depth_to_Groundwater_Pozzo_1', 'Depth_to_Groundwater_Pozzo_3',\n       'Depth_to_Groundwater_Pozzo_4','Volume_Pozzo_1', 'Volume_Pozzo_3',\n       'Volume_Pozzo_4']\n\ndf_drna = df[cols].dropna()\n\nsns.set(style='whitegrid',context='notebook')\n# Matrice a Dispersione\nfig = plt.figure(figsize=(20,10))\nsns.pairplot(df_drna,size=2.5) ","c0da727b":"fig = plt.figure(figsize=(20,18))\ncm = np.corrcoef(df_drna.values.T)\nsns.set(font_scale=1.5)\nhm = sns.heatmap(cm,cbar=True,annot=True,square=True,fmt='.2f',annot_kws={'size' : 20},yticklabels=df_drna.columns,xticklabels=df_drna.columns)\n","4f283060":"cols = ['Depth_to_Groundwater_Podere_Casetta',\n       'Depth_to_Groundwater_Pozzo_1', 'Depth_to_Groundwater_Pozzo_3',\n       'Depth_to_Groundwater_Pozzo_4']\ndf_new = df_drna[cols]\nX = df_new.iloc[:,:].values\ny = df_drna[['Volume_Pozzo_1', 'Volume_Pozzo_3',\n       'Volume_Pozzo_4']].mean(axis=1).values\nfrom sklearn.model_selection import train_test_split\n#Valuto l'MSE e RMSE\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import r2_score\n       \nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=0)\nfrom sklearn.ensemble import RandomForestRegressor\nforest = RandomForestRegressor(n_estimators=1000,criterion='mse',random_state=0,n_jobs=-1)\nforest.fit(X_train,y_train)\ny_train_pred = forest.predict(X_train)\ny_test_pred = forest.predict(X_test)\nplt.scatter(y_train_pred,y_train_pred-y_train,c='black',marker='o',s=35,alpha=0.5,label='dati di addestramento'),plt.scatter(y_test_pred,y_test_pred-y_test,c='lightgreen',marker='s',s=35,alpha=0.7,label='dati di test'),plt.xlabel('valori previsti'),plt.ylabel('residui aleatori'),plt.title('Regressione a foreste casuali'),plt.legend(loc='best')\nplt.hlines(0,-220,-140,color='red')\n","30556ef8":"print('MSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred),mean_squared_error(y_test, y_test_pred)))\nprint('RMSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred)**0.5,mean_squared_error(y_test, y_test_pred)**0.5))\nprint('R^2: Train %.3f Test: %.3f' % (r2_score(y_train, y_train_pred),r2_score(y_test, y_test_pred)))\n\n","9f336652":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Depth to Groundwater')\ncols = ['Depth_to_Groundwater_Podere_Casetta',\n       'Depth_to_Groundwater_Pozzo_1', 'Depth_to_Groundwater_Pozzo_3',\n       'Depth_to_Groundwater_Pozzo_4']\nfor i in range(1,len(cols)+1):\n    df1 = df.dropna(subset=[cols[i-1]])\n    df1[cols[0]][df1[cols[0]]==0]=df1[cols[0]].mean(axis=0)\n    df_mou = df1.resample('m').mean()\n    plt.subplot(2,2,i)\n    df_mou[cols[i-1]].plot(),plt.ylabel(cols[i-1][21:])","6f1aaedb":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Partial Autocorrelation')\nfig.subplots_adjust()\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[0]][df_drna[cols[0]]==0]=df_drna[cols[0]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    ax = fig.add_subplot(2,2,i)\n    plot_pacf(df_mou[cols[i-1]],ax,title=None),plt.ylabel(cols[i-1][21:]),plt.xlabel('lag')\n    ","7de13e72":"fig = plt.figure(figsize=(15,8))\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[i-1]][df_drna[cols[i-1]]==0]=df_drna[cols[i-1]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    train = df_mou[df_mou.index <= split]\n    test = df_mou[df_mou.index >= split]\n    test = test[test.index < '2020-07-31']\n    model = SARIMAX(train[cols[i-1]],order=(3,1,1),seasonal_order=(3,1,1,12),enforce_stationarity=False)\n    fitted_model = model.fit(maxiter=200,disp=True)\n    #fitted_model.summary() #sommario analisi\n    train_residui = fitted_model.resid #residui aleatori [train - train_predicted]\n    in_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\n    out_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\n    fig = plt.figure(figsize=(15,8))\n    plt.suptitle('SARIMA '+cols[i-1])\n    plt.subplot(3,1,1)\n    train[cols[i-1]].plot(label='train'),test[cols[i-1]].plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='best')\n    plt.subplot(3,1,2)\n    train_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylim([-2,2])\n    plt.subplot(3,1,3)\n    in_sample['mean'].plot(label='Forecasted Values'),train[cols[i-1]].plot(label='Misured Values'),plt.legend(loc='best'),plt.ylabel(cols[i-1])\n","1e69f5a1":"df = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Aquifer_Petrignano.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.isna().sum()\/np.size(df,0)*100","4a6bb1bc":"###### Betia Umbra ######\n\ndf_drna = df.dropna()\n\napp = (df_drna['Temperature_Bastia_Umbra'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*6,0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj1= kpj*135*(app\/26.5)**aa\n\nh = df_drna['Rainfall_Bastia_Umbra'].resample('m').mean()\n\n#%%#########\u00a0Petrignano #######\n\napp = (df_drna['Temperature_Petrignano'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*6,0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj2 = kpj*135*(app\/26.5)**aa\n\n#%% Plot\nfig = plt.figure(figsize=(16,8))\nplt.suptitle('Evapotraspiration - Rainfall')\nplt.subplot(2,1,1)\nylab = ylab = 'h + Epj '+ 'Bastia_Umbra'\nplt.plot(Epj1.index,Epj1,color='red',label='Epj'),plt.plot(h.index,h,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\nplt.subplot(2,1,2)\nylab = ylab = 'h + Epj '+ 'Petrignano'\nplt.plot(Epj2.index,Epj2,color='red',label='Epj'),plt.plot(h.index,h,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\n","b3f6013d":"import seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\nslr = LinearRegression()\nQ = df['Volume_C10_Petrignano'].dropna()\nQ = Q.resample('m').mean()\nfig = plt.figure(figsize=(16,8))\nfig.suptitle('Aquifer Luco')\nX = Q.values\nX = X[X < 0]\nX = -X\nX = np.log(X)\nt = np.arange(1,(np.size(X)+1),1)\nt = t.reshape(-1,1)\n\nslr.fit(t,X)\nsns.regplot(np.linspace(2007,2020,np.size(X,0)),X,slr,label='alpha: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_))\nplt.xlabel('t[h]')\nplt.ylabel('log(Q) Petrignano')\nplt.legend(loc='best')","fc44c90d":"cols = ['Depth_to_Groundwater_P24',\n       'Depth_to_Groundwater_P25','Volume_C10_Petrignano',\n       'Hydrometry_Fiume_Chiascio_Petrignano']\n\n\ndf_drna = df[cols].dropna()\n\nsns.set(style='whitegrid',context='notebook')\n# Matrice a Dispersione\nfig = plt.figure(figsize=(22,13))\nsns.pairplot(df_drna,size=2.5) ","207a8260":"fig = plt.figure(figsize=(20,18))\ncm = np.corrcoef(df_drna.values.T)\nsns.set(font_scale=1.5)\nhm = sns.heatmap(cm,cbar=True,annot=True,square=True,fmt='.2f',annot_kws={'size' : 20},yticklabels=df_drna.columns,xticklabels=df_drna.columns)\n","9da59475":"#from NBprocessing import NBcontinuous\n\ncols = ['Depth_to_Groundwater_P24',\n       'Depth_to_Groundwater_P25','Volume_C10_Petrignano','Hydrometry_Fiume_Chiascio_Petrignano','Volume_C10_Petrignano']\ndf_new = df_drna[cols]\n#NBcontinuous.remove_outliers_by_boundaries(df_new,'Hydrometry_Fiume_Chiascio_Petrignano',0.0,0.97)\n\nX = df_new.iloc[:,:-1].values\ny = df_new['Volume_C10_Petrignano'].values\nfrom sklearn.model_selection import train_test_split\n#Valuto l'MSE e RMSE\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import r2_score\n       \nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=0)\nfrom sklearn.ensemble import RandomForestRegressor\nforest = RandomForestRegressor(n_estimators=1000,criterion='mse',random_state=0,n_jobs=-1)\nforest.fit(X_train,y_train)\ny_train_pred = forest.predict(X_train)\ny_test_pred = forest.predict(X_test)\n\nplt.scatter(y_train_pred,y_train_pred-y_train,c='black',marker='o',s=35,alpha=0.5,label='dati di addestramento'),plt.scatter(y_test_pred,y_test_pred-y_test,c='lightgreen',marker='s',s=35,alpha=0.7,label='dati di test'),plt.xlabel('valori previsti'),plt.ylabel('residui aleatori'),plt.title('Regressione a foreste casuali'),plt.legend(loc='best')\nplt.ylim([-100,100])\nplt.hlines(0,-40000,0,color='red')\n\n","296702c7":"print('MSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred),mean_squared_error(y_test, y_test_pred)))\nprint('RMSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred)**0.5,mean_squared_error(y_test, y_test_pred)**0.5))\nprint('R^2: Train %.3f Test: %.3f' % (r2_score(y_train, y_train_pred),r2_score(y_test, y_test_pred)))\n","f48f1abd":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Depth to Groundwater')\ncols = ['Depth_to_Groundwater_P24',\n       'Depth_to_Groundwater_P25']\nfor i in range(1,len(cols)+1):\n    df = df.dropna(subset=[cols[i-1]])\n    df[cols[0]][df[cols[0]]==0]=df[cols[0]].mean(axis=0)\n    df_mou = df.resample('m').mean()\n    plt.subplot(2,1,i)\n    df_mou[cols[i-1]].plot(),plt.ylabel(cols[i-1][21:])","ea78736a":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Partial Autocorrelation')\nfig.subplots_adjust()\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[0]][df_drna[cols[0]]==0]=df_drna[cols[0]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    ax = fig.add_subplot(3,2,i)\n    plot_pacf(df_mou[cols[i-1]],ax,title=None),plt.ylabel(cols[i-1][21:]),plt.xlabel('lag')\n    ","45104d4b":"fig = plt.figure(figsize=(15,8))\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[i-1]][df_drna[cols[i-1]]==0]=df_drna[cols[i-1]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    train = df_mou[df_mou.index <= split]\n    test = df_mou[df_mou.index >= split]\n    test = test[test.index < '2020-07-31']\n    model = SARIMAX(train[cols[i-1]],order=(3,1,1),seasonal_order=(3,1,1,12),enforce_stationarity=False)\n    fitted_model = model.fit(maxiter=200,disp=True)\n    #fitted_model.summary() #sommario analisi\n    train_residui = fitted_model.resid #residui aleatori [train - train_predicted]\n    in_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\n    out_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\n    fig = plt.figure(figsize=(15,8))\n    plt.suptitle('SARIMA '+cols[i-1])\n    plt.subplot(3,1,1)\n    train[cols[i-1]].plot(label='train'),test[cols[i-1]].plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='upper left')\n    plt.subplot(3,1,2)\n    train_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylim([-2,2])\n    plt.subplot(3,1,3)\n    in_sample['mean'].plot(label='Forecasted Values'),train[cols[i-1]].plot(label='Misured Values'),plt.legend(loc='best'),plt.ylabel(cols[i-1])\n","580ba7fd":"df = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Lake_Bilancino.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.isna().sum()\/np.size(df,0)*100","439d0309":"###### Le Croci ######\n\ndf_drna = df.dropna()\n\napp = (df_drna['Temperature_Le_Croci'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*8,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj= kpj*135*(app\/26.5)**aa\n\nh = df_drna['Rainfall_Le_Croci'].resample('m').mean()\nfig = plt.figure(figsize=(16,8))\nylab = ylab = 'h + Epj '+ 'Le_Croci'\nplt.plot(Epj.index,Epj,color='red',label='Epj'),plt.plot(h.index,h,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n","00321bef":"import seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\nslr = LinearRegression()\nQ = df['Flow_Rate'].dropna()\nQ = Q.resample('m').mean()\nfig = plt.figure(figsize=(16,8))\nfig.suptitle('Lake Bilancino')\nX = Q.values\nX = X[X > 0]\nX = X*3600*24\nX = np.log(X)\nt = np.arange(1,(np.size(X)+1),1)\nt = t.reshape(-1,1)\nslr.fit(t,X)\nsns.regplot(np.linspace(2007,2020,np.size(X,0)),X,slr,label='alpha: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_))\nplt.xlabel('time[g]')\nplt.ylabel('log(Q)')\nplt.legend(loc='best')","6c60aa25":"cols = ['Lake_Level','Flow_Rate']\ndf_drna = df[cols].dropna()\n\nsns.set(style='whitegrid',context='notebook')\n# Matrice a Dispersione\nfig = plt.figure(figsize=(20,10))\nsns.pairplot(df_drna,size=2.5)","ca13b460":"cm = np.corrcoef(df_drna.values.T)\nsns.set(font_scale=1.5)\nhm = sns.heatmap(cm,cbar=True,annot=True,square=True,fmt='.2f',annot_kws={'size' : 20},yticklabels=df_drna.columns,xticklabels=df_drna.columns)\n","9a90f7a6":"X = df_drna[['Lake_Level']].values\ny = df_drna['Flow_Rate'].values\n\nfrom sklearn.linear_model import LinearRegression\nregr = LinearRegression()\n\n# Creo polinomio \nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.metrics import r2_score\nquadratic = PolynomialFeatures(degree=2)\ncubic = PolynomialFeatures(degree=3)\nX_quad = quadratic.fit_transform(X)\nX_cubic = cubic.fit_transform(X)\n\n#Linear fit\nX_fit = np.arange(X.min(),X.max(),1)[:, np.newaxis]\nregr = regr.fit(X,y)\ny_lin_fit = regr.predict(X_fit)\nlinear_r2 = r2_score(y, regr.predict(X))\n\n#Quadratic fit\nregr = regr.fit(X_quad,y)\ny_quad_fit = regr.predict(quadratic.fit_transform(X_fit))\nquadratic_r2 = r2_score(y,regr.predict(X_quad))\n\n#cubic fit\nregr = regr.fit(X_cubic,y)\ny_cubic_fit = regr.predict(cubic.fit_transform(X_fit))\ncubic_r2 = r2_score(y, regr.predict(X_cubic))\n\n#plot results\nplt.scatter(X,y,label='punti di addestramento',color='lightgray'),plt.plot(X_fit,y_lin_fit,label='lineare (d=1), $R^2=%.2f$' % linear_r2,color='blue',lw=2,linestyle=':'),plt.plot(X_fit,y_quad_fit,label='quadratic (d=2), $R^2=%.2f$' % quadratic_r2,color='red',lw=2,linestyle='-'),plt.plot(X_fit,y_cubic_fit,label='cubic (d=3), $R^2=%.2f$' % cubic_r2,color='green',lw=2,linestyle='--'),plt.xlabel('Hydrometry_Monte_S_Quirico'),plt.ylabel('Depth_to_groundwater_PAG'),plt.legend(loc='best')\n ","2194efff":"cols = ['Lake_Level', 'Flow_Rate']\n\nfig = plt.figure(figsize=(16,10))\nplt.suptitle('Lake Bilancino')\n\nfor i in range(1,len(cols)+1):\n    df_mou = df.resample('m').mean()\n    plt.subplot(2,1,i)\n    df_mou[cols[i-1]].plot(),plt.ylabel(cols[i-1])","08f79eb2":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Partial Autocorrelation')\nfig.subplots_adjust()\nfor i in range(1,len(cols)+1):\n    ax = fig.add_subplot(2,1,i)\n    plot_pacf(df_mou[cols[i-1]],ax,title=None),plt.ylabel(cols[i-1][21:]),plt.xlabel('lag')\n  ","7aff3c85":"#%%  SARIMA   LAKE LEVEL\nsplit = \"2019-12-31\"\nfig = plt.figure(figsize=(15,8))\nplt.suptitle('LAKE LEVEL')\ntrain = df_mou[df_mou.index <= split]\ntest = df_mou[df_mou.index >= split]\ntest = test[test.index < '2020-07-31']\nmodel = SARIMAX(train[cols[0]],order=(2,1,0),seasonal_order=(4,1,0,5),enforce_stationarity=False)\nfitted_model = model.fit(maxiter=200,disp=True)\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\ntrain_residui = fitted_model.resid #residui aleatori [train - train_predicted]\nin_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\nplt.subplot(3,1,1)\ntrain[cols[0]].plot(label='train'),test[cols[0]].plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='upper left')\nplt.subplot(3,1,2)\ntrain_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylim([-50,50]),plt.ylabel('Residual')\nplt.subplot(3,1,3)\ntrain[cols[0]].plot(label='misure Value'),in_sample['mean'].plot(label='Forecasted Values'),plt.legend(loc='best'),plt.ylim([200,300])\n","c65741b8":"#%%  SARIMA   FLOW RATE\nfig = plt.figure(figsize=(15,8))\nplt.suptitle('FOLW RATE')\nmodel = SARIMAX(train[cols[1]],order=(1,1,1),seasonal_order=(1,2,1,10),enforce_stationarity=False)\nfitted_model = model.fit(maxiter=200,disp=True)\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\ntrain_residui = fitted_model.resid #residui aleatori [train - train_predicted]\nin_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\nplt.subplot(3,1,1)\ntrain[cols[1]].plot(label='train'),test[cols[1]].plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='upper left')\nplt.subplot(3,1,2)\ntrain_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylim([-50,50]),plt.ylabel('Residual')\nplt.subplot(3,1,3)\ntrain[cols[1]].plot(label='misure Value'),in_sample['mean'].plot(label='Forecasted Values'),plt.legend(loc='best')\n","9ab56d7c":"df = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/River_Arno.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.isna().sum()\/np.size(df,0)*100","d08d47bd":"Potential Evapotraspiration Estimation ","913ff35f":"df_drna = df['2004-01-01':'2016-12-31']\ntemp_media = df_drna['Temperature_Firenze'].resample('Y').mean()\napp = (df_drna['Temperature_Firenze'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\n\napp = df_drna['Temperature_Firenze'].resample('m').mean()\nkpj = np.concatenate((kj,kj)*6,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj= kpj*135*(app\/26.5)**aa\nrain = ['Rainfall_Le_Croci', 'Rainfall_Cavallina', 'Rainfall_S_Agata',\n       'Rainfall_Mangona', 'Rainfall_S_Piero']\nh = df_drna[rain].resample('m').mean()\n\nfig = plt.figure(figsize=(20,10))\nfor d in range(1,5+1):\n    \n    \n    plt.subplot(3,2,d)\n    ylab = 'h + Epj '+ rain[d-1][9:]\n    plt.plot(Epj.index,Epj,color='red',label='Epj'),plt.plot(h.index,h[rain[d-1]],color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='best')\n    ","0da21def":"Variation Hydrometer over Time","7b98d922":"imetro = df['Hydrometry_Nave_di_Rosano'].dropna()\nimetro  = imetro[imetro.isnull() == False ]\n\nimetro_mean = imetro.resample('m').mean()\nimetro_mean = imetro_mean[imetro_mean > 1]\nfig = plt.figure()\nmag = imetro_mean[imetro_mean > 2]\nfig = plt.figure(figsize=(15,7))\nplt.plot(imetro_mean.index,imetro_mean),plt.plot(mag.index,mag,'o'),plt.hlines(imetro.mean(),xmin=imetro_mean.index[0],xmax=imetro_mean.index[-1],color='red',label='mean'),plt.ylabel('Hydrometry_Nave_di_Rosano'),plt.legend(loc='best')\n","568f9d5d":"idrometro = df['Hydrometry_Nave_di_Rosano'].dropna()\nidrometro_mon = idrometro.resample('m').mean()\nidrometro_mon.plot()","0a32016f":"plot_pacf(idrometro_mon)","b5caf97d":"split = \"2019-12-31\"\nfig = plt.figure(figsize=(15,8))\nplt.suptitle('Hydrometry River Arno')\ntrain = idrometro_mon[idrometro_mon.index <= split]\ntest = idrometro_mon[idrometro_mon.index >= split]\ntest = test[test.index < '2020-07-31']\nmodel = SARIMAX(train,order=(2,1,3),seasonal_order=(2,1,3,6),enforce_stationarity=False)\nfitted_model = model.fit(maxiter=200,disp=True)\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\ntrain_residui = fitted_model.resid #residui aleatori [train - train_predicted]\nin_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\nplt.subplot(3,1,1)\ntrain.plot(label='train'),test.plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='upper left')\nplt.subplot(3,1,2)\ntrain_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylabel('Residual')\nplt.subplot(3,1,3)\ntrain.plot(label='misure Value'),in_sample['mean'].plot(label='Forecasted Values'),plt.legend(loc='best')\n","0cac2917":"df = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Water_Spring_Amiata.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.isna().sum()\/np.size(df,0)*100","37eb4445":"### Abbiata ####\n\ncols = ['Rainfall_Abbadia_S_Salvatore',\n       'Rainfall_S_Fiora', 'Rainfall_Laghetto_Verde',\n       'Temperature_Abbadia_S_Salvatore', 'Temperature_S_Fiora',\n       'Temperature_Laghetto_Verde']\n\ndf_new = df[cols].resample('Y').count()\n\ndf_Abbiata = df[['Rainfall_Abbadia_S_Salvatore','Temperature_Abbadia_S_Salvatore']]\n\ndf_drna = df_Abbiata.dropna()\n\n\napp = (df_drna['Temperature_Abbadia_S_Salvatore'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*5,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj1= kpj*135*(app\/26.5)**aa\n\nh1 = df_drna['Rainfall_Abbadia_S_Salvatore'].resample('m').mean()\n\n### Fiora ####\n\ndf_Fiora = df[['Rainfall_S_Fiora','Temperature_S_Fiora']]\ndf_drna = df_Fiora.dropna()\n\napp = (df_drna['Temperature_S_Fiora'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*4,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj2= kpj*135*(app\/26.5)**aa\n\nh2 = df_drna['Rainfall_S_Fiora'].resample('m').mean()\n\n### Laghetto Verde ###\n\ndf_Laghetto = df[['Rainfall_Laghetto_Verde','Temperature_Laghetto_Verde']]\ndf_drna = df_Laghetto.dropna()\n\napp = (df_drna['Temperature_Laghetto_Verde'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*4,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj3 = kpj*135*(app\/26.5)**aa\n\nh3 = df_drna['Rainfall_Laghetto_Verde'].resample('m').mean()\n\nfig = plt.figure(figsize=(20,10))\nplt.suptitle('Evapotranspiration - Rainfall')\nplt.subplot(2,2,1)\nylab = ylab = 'h + Epj '+ 'Abbadia S. Salvatore'\nplt.plot(Epj1.index,Epj1,color='red',label='Epj'),plt.plot(h1.index,h1,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\nplt.subplot(2,2,2)\nylab = ylab = 'h + Epj '+ 'S_Fiora'\nplt.plot(Epj2.index,Epj2,color='red',label='Epj'),plt.plot(h2.index,h2,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\nplt.subplot(2,2,3)\nylab = ylab = 'h + Epj '+ ' Lghetto_Verde'\nplt.plot(Epj3.index,Epj3,color='red',label='Epj'),plt.plot(h3.index,h3,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n\n","187334fb":"from sklearn.linear_model import LinearRegression\nimport seaborn as sns\n#from NBprocessing import NBcontinuous\n\ncols = ['Flow_Rate_Bugnano', 'Flow_Rate_Arbure',\n       'Flow_Rate_Ermicciolo', 'Flow_Rate_Galleria_Alta']\nslr = LinearRegression()\nQ = df[cols]\nQ = Q.resample('m').mean()\n#Q = Q.dropna()\n#Q = Q[Q < 0]\n\nfig = plt.figure(figsize=(20,10))\nfig.suptitle('Water Spring Amiata')\nfor i in range(1,5):\n    slr = LinearRegression()\n    #ANBcontinuous.remove_outliers_by_boundaries(Q,cols[i-1],0.0,0.95)\n    X = Q.iloc[:,i-1].dropna()\n    X = X[X < -0.3]\n    X = -X\n    X = np.log(X)\n    t = np.arange(1,(np.size(X)+1),1)\n    t = t.reshape(-1,1)\n    slr.fit(t,X)\n    ylab = 'log(Q) ' + cols[i-1][10:]\n    plt.subplot(2,2,i)\n    sns.regplot(np.linspace(2014,2020,np.size(X,0)),X,slr,label='alpha: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_))\n    plt.xlabel('t[Y]')\n    plt.ylabel(ylab)\n    plt.legend(loc='best')","13b2c6ad":"sns.set(style='whitegrid',context='notebook')\n# Matrice a Dispersione\ncols=['Depth_to_Groundwater_S_Fiora_8', 'Depth_to_Groundwater_S_Fiora_11bis',\n       'Depth_to_Groundwater_David_Lazzaretti','Flow_Rate_Bugnano', 'Flow_Rate_Arbure',\n       'Flow_Rate_Ermicciolo', 'Flow_Rate_Galleria_Alta']\nfig = plt.figure(figsize=(20,10))\ndf_drna = df[cols].dropna()\nsns.pairplot(df_drna,size=2.5)  ","0622dcbf":"fig = plt.figure(figsize=(20,18))\ncm = np.corrcoef(df_drna.values.T)\nsns.set(font_scale=1.5)\nhm = sns.heatmap(cm,cbar=True,annot=True,square=True,fmt='.2f',annot_kws={'size' : 20},yticklabels=df_drna.columns,xticklabels=df_drna.columns)","50fc860d":"X = df_drna[['Flow_Rate_Galleria_Alta']].values\ny = df_drna['Depth_to_Groundwater_S_Fiora_8'].values\n\nfrom sklearn.linear_model import LinearRegression\nregr = LinearRegression()\n\n# Creo polinomio \nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.metrics import r2_score\nquadratic = PolynomialFeatures(degree=2)\ncubic = PolynomialFeatures(degree=3)\nX_quad = quadratic.fit_transform(X)\nX_cubic = cubic.fit_transform(X)\n\n#Linear fit\nX_fit = np.arange(X.min(),X.max(),1)[:, np.newaxis]\nregr = regr.fit(X,y)\ny_lin_fit = regr.predict(X_fit)\nlinear_r2 = r2_score(y, regr.predict(X))\n\n#Quadratic fit\nregr = regr.fit(X_quad,y)\ny_quad_fit = regr.predict(quadratic.fit_transform(X_fit))\nquadratic_r2 = r2_score(y,regr.predict(X_quad))\n\n#cubic fit\nregr = regr.fit(X_cubic,y)\ny_cubic_fit = regr.predict(cubic.fit_transform(X_fit))\ncubic_r2 = r2_score(y, regr.predict(X_cubic))\n\n#plot results\nfig = plt.figure(figsize=(15,8))\nplt.scatter(X,y,label='punti di addestramento',color='lightgray'),plt.plot(X_fit,y_lin_fit,label='lineare (d=1), $R^2=%.2f$' % linear_r2,color='blue',lw=2,linestyle=':'),plt.plot(X_fit,y_quad_fit,label='quadratic (d=2), $R^2=%.2f$' % quadratic_r2,color='red',lw=2,linestyle='-'),plt.plot(X_fit,y_cubic_fit,label='cubic (d=3), $R^2=%.2f$' % cubic_r2,color='green',lw=2,linestyle='--'),plt.xlabel('Hydrometry_Monte_S_Quirico'),plt.ylabel('Depth_to_groundwater_PAG'),plt.legend(loc='best')\n ","4b61e44c":"cols = ['Depth_to_Groundwater_S_Fiora_8', 'Depth_to_Groundwater_S_Fiora_11bis',\n       'Depth_to_Groundwater_David_Lazzaretti']\ndf_new = df_drna[cols]\nX = df_new.iloc[:,:].values\ny = df_drna['Flow_Rate_Galleria_Alta'].values\nfrom sklearn.model_selection import train_test_split\n#Valuto l'MSE e RMSE\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import r2_score\n       \nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=0)\nfrom sklearn.ensemble import RandomForestRegressor\nforest = RandomForestRegressor(n_estimators=1000,criterion='mse',random_state=0,n_jobs=-1)\nforest.fit(X_train,y_train)\ny_train_pred = forest.predict(X_train)\ny_test_pred = forest.predict(X_test)\nfig=plt.figure(figsize=(15,8))\nplt.scatter(y_train_pred,y_train_pred-y_train,c='black',marker='o',s=35,alpha=0.5,label='dati di addestramento'),plt.scatter(y_test_pred,y_test_pred-y_test,c='lightgreen',marker='s',s=35,alpha=0.7,label='dati di test'),plt.xlabel('valori previsti'),plt.ylabel('residui aleatori'),plt.title('Regressione a foreste casuali'),plt.legend(loc='best')\nplt.hlines(0,-26,-16,color='red')","11d292ba":"print('MSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred),mean_squared_error(y_test, y_test_pred)))\nprint('RMSE: Train %.3f Test: %.3f' % (mean_squared_error(y_train, y_train_pred)**0.5,mean_squared_error(y_test, y_test_pred)**0.5))\nprint('R^2: Train %.3f Test: %.3f' % (r2_score(y_train, y_train_pred),r2_score(y_test, y_test_pred)))","d7c0251a":"cols = ['Flow_Rate_Bugnano', 'Flow_Rate_Arbure',\n       'Flow_Rate_Ermicciolo', 'Flow_Rate_Galleria_Alta']\n\nfig = plt.figure(figsize=(20,10))\nplt.suptitle('Folw Rate')\n\nfor i in range(1,len(cols)+1):\n    df1 = df.dropna(subset=[cols[i-1]])\n    df1[cols[i-1]][df1[cols[i-1]]==0]=df1[cols[i-1]].mean(axis=0)\n    df_mou = df.resample('m').mean()\n    plt.subplot(2,2,i)\n    df_mou[cols[i-1]].plot(),plt.ylabel(cols[i-1][10:])","835aa5ad":"fig = plt.figure(figsize=(20,10))\nplt.suptitle('Partial Autocorrelation')\nfig.subplots_adjust()\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[i-1]][df_drna[cols[i-1]]==0]=df_drna[cols[i-1]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    ax = fig.add_subplot(2,2,i)\n    plot_pacf(df_mou[cols[i-1]],ax,title=None),plt.ylabel(cols[i-1][21:]),plt.xlabel('lag')\n    ","87254f00":"split = \"2019-12-31\"\nfig = plt.figure(figsize=(15,8))\nfor i in range(1,len(cols)+1):\n    df_drna = df.dropna(subset=[cols[i-1]])\n    df_drna[cols[i-1]][df_drna[cols[i-1]]==0]=df_drna[cols[i-1]].mean(axis=0)\n    df_mou = df_drna.resample('m').mean()\n    train = df_mou[df_mou.index <= split]\n    test = df_mou[df_mou.index >= split]\n    test = test[test.index < '2020-07-31']\n    model = SARIMAX(train[cols[i-1]],order=(1,1,1),seasonal_order=(4,1,2,4),enforce_stationarity=False)\n    fitted_model = model.fit(maxiter=200,disp=True)\n    #fitted_model.summary() #sommario analisi\n    train_residui = fitted_model.resid #residui aleatori [train - train_predicted]\n    in_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\n    out_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\n    fig = plt.figure(figsize=(15,8))\n    plt.suptitle('SARIMA '+cols[i-1])\n    plt.subplot(3,1,1)\n    train[cols[i-1]].plot(label='train'),test[cols[i-1]].plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='best')\n    plt.subplot(3,1,2)\n    train_residui.plot(label='Resudal'),plt.legend(loc='best')\n    plt.subplot(3,1,3)\n    in_sample['mean'].plot(label='Forecasted Values'),plt.legend(loc='best'),plt.ylabel(cols[i-1])\n","3e39c311":"df = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Water_Spring_Lupa.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.isna().sum()\/np.size(df,0)*100","3fd34cfd":"from sklearn.linear_model import LinearRegression\nimport seaborn as sns\n#from NBprocessing import NBcontinuous\n#NBcontinuous.remove_outliers_by_boundaries(df,'Rainfall_Terni',0.0,0.95)\nfrom sklearn.linear_model import LinearRegression\nimport seaborn as sns\n#from NBprocessing import NBcontinuous\n#NBcontinuous.remove_outliers_by_boundaries(df,'Rainfall_Terni',0.0,0.95)\ndf = df.dropna()\n\nX = df.iloc[:,1].values\ny = np.arange(1,np.size(X),1).reshape(-1,1)\nq = -X\nq = q[q>0]\nq = np.log(q)\nslr = LinearRegression()\nslr.fit(y,q)\nfig = plt.figure()\nsns.regplot(y,q,slr,label='alpha: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_)),plt.ylabel('Log(Q)'),plt.xlabel('time'),plt.legend(loc='best')\n","feeb0717":"rain = df['Rainfall_Terni'].resample('m').mean()\nfig = plt.figure(figsize=(15,8))\nplt.plot(rain.index,rain),plt.hlines(rain.mean(),rain.index[0],rain.index[-1],color='red',label='mean'),plt.legend(loc='best')\n\nplt.ylabel('rain')","45025ac0":"cols = ['Flow_Rate_Lupa']\ndf = df.dropna()\ndf['Flow_Rate_Lupa'][df['Flow_Rate_Lupa']==0]=df['Flow_Rate_Lupa'].mean(axis=0)\ndf_mou = df.resample('m').mean()\ndf_mou['Flow_Rate_Lupa'].plot(),plt.ylabel(cols)\n","889912ad":"plot_pacf(df['Flow_Rate_Lupa'])","75e6c07a":"split = \"2019-12-31\"\nidrometro_mon  = df_mou['Flow_Rate_Lupa']\nfig = plt.figure(figsize=(15,8))\nplt.suptitle('Flow Rate Lupa')\ntrain = idrometro_mon[idrometro_mon.index <= split]\ntest = idrometro_mon[idrometro_mon.index >= split]\ntest = test[test.index < '2020-07-31']\nmodel = SARIMAX(train,order=(2,1,3),seasonal_order=(2,1,3,6),enforce_stationarity=False)\nfitted_model = model.fit(maxiter=200,disp=True)\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\ntrain_residui = fitted_model.resid #residui aleatori [train - train_predicted]\nin_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\nplt.subplot(3,1,1)\ntrain.plot(label='train'),test.plot(label='test'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='upper left')\nplt.subplot(3,1,2)\ntrain_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylabel('Residual')\nplt.subplot(3,1,3)\ntrain.plot(label='misure Value'),in_sample['mean'].plot(label='Forecasted Values'),plt.legend(loc='best')\n","46982efa":"df = pd.read_csv('\/kaggle\/input\/acea-water-prediction\/Water_Spring_Madonna_di_Canneto.csv',index_col='Date')\ndf_time = pd.to_datetime(df.index)\ndatetime_index = pd.DatetimeIndex(df_time.values)\ndf = df.set_index(datetime_index)\ndf.isna().sum()\/np.size(df,0)*100","4959df9b":"df_drna = df.dropna(subset=['Rainfall_Settefrati', 'Temperature_Settefrati'])\n\napp = (df_drna['Temperature_Settefrati'].resample('m').mean())**1.514\/5\ni = app.resample('Y').sum()\na = 0.49239+0.01792*i+0.0000771*i**2+6.75*10**-7*i**3\n\nkj = np.array([0.84,0.83,1.03,1.11,1.24,1.25,1.27,1.18,1.04,0.96,0.83,0.81],dtype=float)\nkpj = np.concatenate((kj,kj)*3,0)\nkpj = np.concatenate((kpj,kj),0)\naa = a.to_numpy(dtype=float).repeat(12,axis=0)\n\nEpj= kpj*135*(app\/26.5)**aa\n\nh = df_drna['Rainfall_Settefrati'].resample('m').mean()\n\nylab = ylab = 'h + Epj '+ 'Settefrati'\nfig = plt.figure(figsize=(15,8))\nplt.suptitle('Evapotranspiration - Rainfall')\n\nplt.plot(Epj.index,Epj,color='red',label='Epj'),plt.plot(h.index,h,color='blue',label='h'),plt.ylabel(ylab),plt.xlabel('time'),plt.legend(loc='upper left')\n","9fc2b10e":"df_drna = df.dropna(subset=['Flow_Rate_Madonna_di_Canneto'])\n\nX= df_drna.iloc[:,-1].values\n\nq = np.log(X)\nt = np.arange(1,np.size(q,0)+1,1).reshape(-1,1)\nfig = plt.figure(figsize=(15,8))\nfrom sklearn.linear_model import LinearRegression\nimport seaborn as sns\nslr = LinearRegression()\nslr.fit(t,q)\nsns.regplot(t,q,slr,label='alpha: %.6f log(Q0): %.3f' % (slr.coef_[0],slr.intercept_)),plt.xlabel('time'),plt.ylabel('log(Q) Settefrati'),plt.legend(loc='best')\n","31d5d427":"df = df.dropna()\ndf['Flow_Rate_Madonna_di_Canneto'][df['Flow_Rate_Madonna_di_Canneto']==0]=df['Flow_Rate_Madonna_di_Canneto'].mean(axis=0)\ndf_mou = df.resample('m').mean()\ndf_mou['Flow_Rate_Madonna_di_Canneto'].plot(),plt.ylabel('Flow_Rate')","dd358a5f":"plot_pacf(df_mou['Flow_Rate_Madonna_di_Canneto'])","a6cc1759":"split = \"2019-12-31\"\nidrometro_mon = df_mou['Flow_Rate_Madonna_di_Canneto']\nfig = plt.figure(figsize=(15,8))\nplt.suptitle('Flow Rate')\ntrain = idrometro_mon\nmodel = SARIMAX(train,order=(2,1,3),seasonal_order=(2,1,3,6),enforce_stationarity=False)\nfitted_model = model.fit(maxiter=200,disp=True)\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\ntrain_residui = fitted_model.resid #residui aleatori [train - train_predicted]\nin_sample = fitted_model.get_prediction(end=fitted_model.nobs).summary_frame() # Andamento della previsione\nout_of_simple = fitted_model.get_prediction(start = fitted_model.nobs,end=fitted_model.nobs+10).summary_frame()\nplt.subplot(3,1,1)\ntrain.plot(label='train'),out_of_simple['mean'].plot(lw=2,label='Prediction'),plt.fill_between(out_of_simple.index,out_of_simple['mean_ci_lower'],out_of_simple['mean_ci_upper'],color='k',alpha=.10,label='mean error'),plt.legend(loc='upper left')\nplt.subplot(3,1,2)\ntrain_residui.plot(label='Resudal'),plt.legend(loc='best'),plt.ylabel('Residual')\nplt.subplot(3,1,3)\ntrain.plot(label='misure Value'),in_sample['mean'].plot(label='Forecasted Values'),plt.legend(loc='best')\n","28c08060":"Detection zones chart","de2305a2":"# Aquifer Auser","cdf9aee8":"Noting the lag of the autocorrelation graphs, it can be seen that some trends do not have an acceptable level of significance","cb683547":"Random Forest Method","20e5574c":"Exploratory Data Analysis (EDA)","d66c53de":"MSE RMSE and R^2 coefficient Estimation","c84b2080":"Exploratory Data Analysis (EDA)\n\nCreate a dispersion matrix to represent the pairwise correlations between the different characteristics of the datasets.","eb43d301":"Flow Rate Exhaustion Estimation","119358aa":"Pierson's Coefficient","fa73c798":"In this case, the forecast led to excellent results","aa059e12":"\nThe model used is the SARIMAX where the values of AR (p) and MA (q) are estimated through Python's pmAutoArima method and with some seasonal considerations in the data.","e9a0da7f":"# Lake Bilancino","16678219":"Pierson's Coefficient","6d3cf496":"Estimation of the Rate flow of exhaustion","9bacfb05":"represents the percentage of missing data for each characteristic of the datasets.\n\nEvapotranspiration evaluation","de9c4b46":"Now try to apply a non-linear regression and assume a polynomial of 2nd and 3rd degree.","aceeb753":"Random Forest Method","6c49ed7e":"In this case the graphs do not seem to follow a stationary trend over time","c82d47d2":"In the evaluation of the Datasets it has been shown that some machine learning algorithms can improve the predictions of the Italian supply sources. In the future it would be interested to study hydrological phenomena in more depth, using data from pluviographs in such a way as to be able to better estimate the pluviometric probability curves and to be able to better estimate the flow rates in aquifers in springs or even better in Italian rivers.\nThanks to Acea for this challenge.\nGianmario Farina.","65283bf1":"# Aquifer Luco","245fbcba":"Water deficit evaluated with potential evapotranspiration index followed by S.I.I.\n    ","5d011736":"# Water Spring Madonna di Canneto","67e2fcef":"In groundwater Hypothesis which rests above a horizontal plane waterproof and has a height H practically constant both in time and in space, so that you have anywhere speed and very limited gradients, the law of exhaustion with a good approximation is given by the equation:\n\nQ=Qo e^(-kt)\n\nWhere Qo is the scope of the instant chosen as the origin of the times, Q is the flow rate at time t and k is a constant, characteristic storage aquifer, which is defined constant exhaustion.\nNow we do not have the data of the flow rate measured daily. Still force the concept by considering that the flow rate is equal to the daily collected volume divided 24h.\nQ [m ^ 3 \/ h] and t [h]\n\nThe equation is write in the form:\n\nlog(Q) = log(Qo)-kt\n\n","f42e86ef":"Forecast of the monthly seasonal trend of the Depth to GroundWater","4247036b":"Given the scarcity of data, it was not possible to measure a future forecast of the Depth to groundWater","2be11a28":"These graphs represent the monthly trend of the various Depth to GroundWater to roughly verify the stationarity over time.\nNow estimate the average delay over time through trend autocorrelation","24b54fdc":"Potential Evapotraspiration Evalutation","d3d09619":"# River Arno","33665483":"Rate Flow depletion Evalutation","745359a0":"Estimation coefficients MSE RMSE and R^2","8a9fd1ab":"Estimate a multiple regression and evaluate the MSE RMSE and R ^ 2 coefficients","c5189b15":"Forecat Model","c4815226":"Apply linear regression on terms that have a very high value of the Pierson coefficient.","2a058c8f":"Exploratory Data Analysis (EDA)","33f702e6":"Calculate of the flow rate of aquifer exhaustion","5b72ff02":"Random Forest Method:\n","e7a63d69":"In this case we don't have enough data so we will use a detailed drop","468447b1":"Non linear regression","13875f05":"Estimation of the aquifer emptying time","09970d11":"Delete NaN values and Estimated climatic trend:","1570f7cf":"Forecast Model","f945c9ce":"Evaluate 4 linear relations","fc60f7b3":"# Water Spring Amiata","f86a9fdd":"In this case, given the volatility of the data, different SARIMA model values should have been expressed for each datasets","8d335e25":"# Aquifer Doganella\n\n\n","157a9039":"Pierson's Coefficient","3796f61e":"Evaluation MSE, RMSE and R ^ 2 estimators","39b88a48":"Exploratory Data Analysis (EDA)","9d7fcd4d":"Pierson's Coefficient","9ee8abb5":"![1](https:\/\/imagizer.imageshack.com\/img923\/9213\/sCoyo0.png)","43d01fce":"Estimation coefficients MSE RMSE and R^2","56cdc187":"As anticipated, the evapotranspiration values for the years: 2015, 2016, 2017, 2018 have been replaced with the average","adce4eea":"Exploratory Data Analysis (EDA)","f8c69615":"Unfortunately, the linear regression doesn't involve an overfitting.\n\n","51884834":"![1](https:\/\/imagizer.imageshack.com\/img922\/920\/USigXi.png)","91c4d892":"Non Linear Regression","d94fc574":"The graphs show a low volatility value so it is possible to make a forecast.\nNow I separate the datasets into a train and Test part.","be912dc9":"The regression to random forests led to an improvement\n\n\n","41af47dc":" Potential Evapotranspiration Estimation ","933a7748":"Red label: temperature measurement\nYellow Label: Rain Measure\nGreen label: both measurements","9af784f1":"Flow Rate of exhaustion Estimation","25ed80a3":"Notice a strong linear correlation between some volumes, we check the Pierson coefficients","18bba976":"      hjm < Epjm  Deficit","008f1c58":"The problem of defining the use of water has always been linked to the need to meet the water needs for civil uses, agriculture and industry. \nIn Italy the most widely used sources of supply are surface waters that flow into the riverbeds of a hydrographic network, groundwater flowing through permeable areas of the subsoil. In this analysis an attempt is made to reconstruct the hydrographic trend in engineering terms using the data recorded by the pluviographs managed by the Acea company shared in this challenge. \n\nThe analysis of the Datasets is based on the following parts:\n\n* Screening Datasets \n* Climatic evaluation of the areas of interest\n* Statistical evaluation by structuring the correlations \n* Data training and error evaluation with MSE and RMSE indexes \n* Estimation of the time of exhaustion of the water resource\n* Forecast of the monthly seasonal trend.\n\n","0e49bbbb":"there are too many anomalies in the datasets.\n","0a136fbd":"# Water Spring Lupa","7e26c91c":"Using the random forest method results in an improvement in the data","7048bacc":"Forecast Model","ec1f010d":"Forecast Model:","727f083c":"Red label: temperature measurement\nYellow Label: Rain Measure\nGreen label: both measurements","f78975ef":"Random forest method","42ab1bf6":"Forecast Model","ed806876":"In this case we have lake level and flow rate which are two completely different quantities, so we will apply the SARIMA method twice to best calibrate the parameters.","f743c855":"Potential Evapotraspiration Evalutation.","1078112a":"The graph represents the Water Deficit which can be quantified through the area underlying the two trends.\nAs can be seen in the datasets, some values relating to the year 2009 are missing.\nThis water deficit is important in order to estimate the amount of rain reaching the aquifer.","069abcb2":"we can detect that there are anomalies in the Datasets in the columns of the Volumes taken, moreover the volume_CSA follow a similar normal distribution.","0fb52c18":"Flow Rate depletion Estimation ","49fcad7d":"Exploratory Data Analysis (EDA)","dcc079dc":"There are few data for some years of observation, there will be a distortion of the evapotranspiration referred to the years reported","e4d1430f":"To quantify the linear relationship between the characteristics, a covariance matrix is created. In reality, the correlation matrix is identical to a covarinze matrix but calculated on standardized data.\nThe correlation matrix is a square matrix containing Pearson's coefficients 'r' which measure the linear dependence between pairs of characteristics. These coefficients vary between -1 and 1 where:\n1 perfect linear correlation;\n0 has no correlation;\n-1 negative correlation;","0c521ca7":"Forecast Model","f75eb029":"Forecast Model","6807035f":"It has reported the number of data relating to each year.\nIt notes that there is in the data omogeneot\u00e0 so little information between Depth and Volume.\nThen it evaluates the relationship between the ","f5974606":"Forecast Model","156b5cbb":"Random Forest Method \n","9a6cd75f":"have a lot of data that is sparse missing","51159804":"Performance evaluation of linear regression models","15bb4b8a":"Rate Flow depletion Evalutation","a48ab0aa":"Detection zones chart\n","d06da8b8":"represents the percentage of missing data.\n\nPotenzial Evapotraspiration Evalutation","b0f230ea":"# Aquifer Petrignano"}}