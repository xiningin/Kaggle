{"cell_type":{"84e02baa":"code","ee1b64f5":"code","e2a913b0":"code","4d455ce7":"code","90c651ab":"code","8bacaf8d":"code","08425548":"code","72e0a7a8":"code","d78e6138":"code","9cb144ae":"code","ca1607b7":"code","2a3c07e2":"code","92cf3463":"code","ba76e913":"code","85be158c":"code","a125e54d":"code","d5bab5e1":"markdown","e9c9d80c":"markdown","b090e73f":"markdown","2fca10bd":"markdown","23a60b3f":"markdown"},"source":{"84e02baa":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ee1b64f5":"# Load data & setup pandas\ntrain = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-oct-2021\/train.csv\", index_col='id'\n#                     , nrows=500000\n                   )\ntest = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-oct-2021\/test.csv\", index_col='id'\n#                     , nrows=250000\n                   )\nprint(train.shape)\nprint(test.shape)","e2a913b0":"pd.set_option('max_columns', None)\npd.set_option('max_rows', None)\n\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nimport gc","4d455ce7":"def reduce_mem_usage(df, verbose=True):\n    numerics = [\"int16\", \"int32\", \"int64\", \"float32\", \"float64\"]\n    start_mem = df.memory_usage().sum() \/ 1024 ** 2\n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == \"int\":\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                    \n    end_mem = df.memory_usage().sum() \/ 1024 ** 2\n    if verbose:\n        print(\n            \"Mem. usage decreased to {:.2f} Mb ({:.1f}% reduction)\".format(\n                end_mem, 100 * (start_mem - end_mem) \/ start_mem\n            )\n        )\n    \n    return df","90c651ab":"train = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)\ngc.collect()","8bacaf8d":"#train.info(verbose=True, show_counts=True)\n# Only float16 and int8 columns are present in our data set","08425548":"# y = train[\"target\"].copy()\n# train.drop(columns=\"target\", inplace=True)","72e0a7a8":"bin_cols = list(train.select_dtypes('int8').columns)\nbin_cols.remove('target')\ncont_cols = list(train.select_dtypes('float16').columns)","d78e6138":"train.target.hist()","9cb144ae":"train[cont_cols].astype(float).describe()","ca1607b7":"train.iloc[:, :12].hist(bins=100, figsize = (15,20))","2a3c07e2":"sns.set(rc={\"figure.figsize\":(15, 10)})\nsns.boxplot(data=train.iloc[:, :12])\n","92cf3463":"train[bin_cols].astype('category').describe()","ba76e913":"corr = train[['target'] + cont_cols].corr()\ncorr.style.background_gradient(cmap='coolwarm').format(precision = 3)","85be158c":"corr = train[['target'] + bin_cols].corr()\ncorr.style.background_gradient(cmap='coolwarm').format(precision = 3)","a125e54d":"#Save data in binary format\ntrain.reset_index(inplace=True)\ntrain.to_feather('train.feather')\ntest.reset_index(inplace=True)\ntest.to_feather('test.feather')\n","d5bab5e1":"train.shape (1000000, 286) \\\ntest.shape  (500000, 285)","e9c9d80c":"Target set is not skewed","b090e73f":"f22 has a highest correlation with target","2fca10bd":"Continious features have a different nature.\nThere are features with left\/right tails.\nSome features with multimodal distribution.","23a60b3f":"Continious features already scaled to the [0;1] interval"}}