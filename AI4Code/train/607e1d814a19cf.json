{"cell_type":{"d63379bf":"code","f79f68fe":"code","85e3631c":"code","d3fcdd47":"code","006f6088":"code","db2a8ec4":"code","00022212":"code","41226695":"code","2842c067":"code","83c687ff":"code","ff7ef86a":"code","c2f21b4e":"code","88d3fd11":"code","d7ae5465":"code","b76e0cdc":"code","d54479e2":"code","71127393":"code","b042d7e6":"code","13dbf12e":"code","acdd3e9d":"code","cc416066":"code","1201dbf0":"code","f2b153f4":"code","c31f0808":"code","1ccd45c0":"code","c0e0baf7":"code","ae8a8b4f":"code","664d441a":"code","3bfba83a":"code","2fbc15b6":"code","4d79951d":"code","6d1985c1":"code","f1dcc7d4":"code","28c2e339":"code","94c6b43b":"code","89e091e0":"code","9452e450":"code","cdde6c5d":"code","d1563416":"code","2272aa3d":"code","0fda2c6c":"code","1a742e31":"code","6f4e1c3f":"code","fcc996eb":"code","3731ee48":"code","8eaa6f61":"code","ef5cd6da":"code","ecefaaa6":"code","75efba3e":"code","a69adb0d":"markdown","ac7b008a":"markdown","9e596db7":"markdown","e8da2036":"markdown","7b6a7b4b":"markdown","c2394234":"markdown","53fcc779":"markdown","6e7fa7a0":"markdown","5aaf78bf":"markdown","4866708e":"markdown","1fa0b02e":"markdown","357485b2":"markdown","f2df70df":"markdown","6afed6f6":"markdown","aa77d9cd":"markdown","60b35901":"markdown","8348c692":"markdown","44416618":"markdown","fe16abf4":"markdown","c51e6996":"markdown","37a0d445":"markdown","f07a7a10":"markdown","f00e20c2":"markdown","73e58e7e":"markdown","618ad642":"markdown","e8dbc5ce":"markdown"},"source":{"d63379bf":"import re\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom collections import OrderedDict,defaultdict\n\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\npd.options.display.max_rows = 500\npd.options.display.max_columns = None\npd.set_option('display.max_colwidth', None)","f79f68fe":"group = pd.read_csv('..\/input\/open-round1\/Extra Material 2 - keyword list_with substring.csv')","85e3631c":"titles = pd.read_csv('..\/input\/open-round1\/Keyword_spam_question.csv')","d3fcdd47":"mismatch = pd.read_csv('..\/input\/open-round1\/Extra Material 3 - mismatch list.csv')","006f6088":"group.head()","db2a8ec4":"titles.head()","00022212":"titles.name = titles.name.str.lower()","41226695":"titles.head()","2842c067":"mismatch.head()","83c687ff":"mismatch_dic = {}\nfor col in mismatch:\n    mismatch_dic[col] = [item for item in mismatch[col] if item == item] # numpy nans do not == themselves --> filtered\n\nmismatch_dic","ff7ef86a":"group.head()","c2f21b4e":"group_split = group.copy()\ngroup_split.Keywords = group_split.Keywords.str.split(',')","88d3fd11":"group_split","d7ae5465":"# keys not strip() yet! (don't be suprised to see leading space when using group_dict for debugging later)\ngroup_dict = OrderedDict(zip(group_split.Group,group_split.Keywords))","b76e0cdc":"len(group_dict)","d54479e2":"rdict = {}\n\nfor index, keywords in reversed(group_dict.items()):\n        for word in keywords:\n            rdict[word.strip()] = index        # .strip!","71127393":"rdict['notebook']","b042d7e6":"# drop spikes indicate keywords which got overwritten with a lower group\npd.Series(list(rdict.values()),index= list(rdict.keys())).plot()","13dbf12e":"pd.DataFrame({'word':list(rdict.keys()),'group':list(rdict.values())},index=range(len(rdict)))","acdd3e9d":"substring_map = defaultdict(list)\n\nfor word in rdict:\n     for word2 in rdict:\n            if word != word2 and word in word2:\n                substring_map[word].append(word2)\n                print('{:<20}'.format(word),word2)","cc416066":"len(substring_map)\nsubstring_map","1201dbf0":"substring_map_full = defaultdict(list)\n\nfor word in rdict:\n     for word2 in rdict:\n            if word != word2 and re.search(fr'\\b{word}\\b', word2):\n                substring_map_full[word].append(word2)\n                print('{:<20}'.format(word),word2)","f2b153f4":"len(substring_map_full)\nsubstring_map_full","c31f0808":"removed_keys = set(substring_map) - set(substring_map_full)\nlist(zip(removed_keys,[substring_map[key] for key in removed_keys]))","1ccd45c0":"sum(titles[:10000].name.duplicated())\nsum(titles.name.duplicated())","c0e0baf7":"def search_func(title):\n    result_groups = []\n    for word in rdict:\n        if word in title:\n            if word in substring_map and any(superstring in title for superstring in substring_map[word]):   \n                continue\n            \n            if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n                continue    \n            result_groups.append(rdict[word])\n    return result_groups\n\ntitles[:10].name.apply(search_func)","ae8a8b4f":"# result_df = titles[:1].copy()\n# result_df['groups_found'] = ''\n\n# for word in rdict:\n#     contains_word = titles.name.str.contains(word)\n#     print('contains_word_done')\n    \n#     # must check word in to prevent keyerrors\n#     contains_superstring = word in substring_map and titles.name.str.contains('|'.join(substring_map[word]))\n#     print('contains_superstring_done')\n    \n#     contains_mismatch = word in mismatch_dic and titles.name.str.contains('|'.join(mismatch_dic[word]))\n#     print('contains_mismatch_done')\n    \n#     add_group = contains_word & ~contains_superstring & ~contains_mismatch\n    \n#     # to prepare for str.split to generate groups in list\n#     new_string = ','+str(rdict[word])\n#     result_df.loc[add_group,'groups_found'] = result_df.loc[add_group,'groups_found'] + new_string ","664d441a":"spaced_titles = titles.copy()\nspaced_titles.name = ' '+spaced_titles.name+' '","3bfba83a":"# search_res_spaced = {}\n\n# for index,title in enumerate(spaced_titles.name):\n#     search_res_spaced[index] = []\n#     for word in rdict:\n#         if ' ' + word + ' ' in title:\n#             #print(f'Title: {title}')\n#             #print(f'Matched: {word}')\n            \n#             # prevent accessing non-existent key in substring_map (defaultdict) and causing empty list to generate\n#             if word in substring_map and any(superstring in title for superstring in substring_map[word]):     # check eg 3 condition\n#                 #print(f'{word}\\n found in map: {substring_map[word]}\\n')\n#                 continue\n            \n#             if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n#                 #print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n#                 continue    \n                    \n#             #print(f'{word}\"s group added\\n')\n#             search_res_spaced[index].append(rdict[word])","2fbc15b6":"# for index, groups_found in search_res_spaced.items():\n#     search_res_spaced[index] = sorted(list(set(groups_found)))\n\n# ans_df = pd.Series(list(search_res_spaced.values())).to_frame().reset_index().rename(columns={0:'groups_found'})\n# ans_df.to_csv('spaced_title_word.csv',index=False)","4d79951d":"# sub_spaced = {}\n\n# for index,title in enumerate(spaced_titles.name):\n#     sub_spaced[index] = []\n#     for word in rdict:\n#         if ' ' + word + ' ' in title:\n#             #print(f'Title: {title}')\n#             #print(f'Matched: {word}')\n            \n#             # prevent accessing non-existent key in substring_map (defaultdict) and causing empty list to generate\n#             if word in substring_map and any(' '+superstring+' ' in title for superstring in substring_map[word]):     # check eg 3 condition\n#                 #print(f'{word}\\n found in map: {substring_map[word]}\\n')\n#                 continue\n            \n#             if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n#                 #print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n#                 continue    \n                    \n#             #print(f'{word}\"s group added\\n')\n#             sub_spaced[index].append(rdict[word])","6d1985c1":"# for index, groups_found in sub_spaced.items():\n#     sub_spaced[index] = sorted(list(set(groups_found)))\n\n# spaced_tws_df = pd.Series(list(sub_spaced.values())).to_frame().reset_index().rename(columns={0:'groups_found'})\n# spaced_tws_df.to_csv('spaced_title_word_superstring.csv',index=False)","f1dcc7d4":"# sub_mismatch_spaced = {}\n\n# for index,title in enumerate(spaced_titles.name):\n#     sub_mismatch_spaced[index] = []\n#     for word in rdict:\n#         if ' ' + word + ' ' in title:\n#             #print(f'Title: {title}')\n#             #print(f'Matched: {word}')\n            \n#             # prevent accessing non-existent key in substring_map (defaultdict) and causing empty list to generate\n#             if word in substring_map and any(' '+superstring+' ' in title for superstring in substring_map[word]):     # check eg 3 condition\n#                 #print(f'{word}\\n found in map: {substring_map[word]}\\n')\n#                 continue\n            \n#             if word in mismatch_dic and any(' '+mismatched_term+' ' in title for mismatched_term in mismatch_dic[word]):\n#                 #print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n#                 continue    \n                    \n#             #print(f'{word}\"s group added\\n')\n#             sub_mismatch_spaced[index].append(rdict[word])","28c2e339":"# for index, groups_found in sub_mismatch_spaced.items():\n#     sub_mismatch_spaced[index] = sorted(list(set(groups_found)))\n\n# spaced_twsm_df = pd.Series(list(sub_mismatch_spaced.values())).to_frame().reset_index().rename(columns={0:'groups_found'})\n# spaced_twsm_df.to_csv('spaced_title_word_substring_mismatch.csv',index=False)","94c6b43b":"# search_res = {}\n\n# for index,title in enumerate(titles.name):\n#     search_res[index] = []\n#     for word in rdict:\n#         # regex is 600x slower than `a in b`-> minimize regex use or wrap in many if conditions\n#         #if re.search(f'\\s{word}\\s|^{word}\\s|\\s{word}$|^{word}$',title):  \n        \n#         if word in title:\n#             if re.search(fr'\\b{word}\\b',title):\n#                 #print(f'Title: {title}')\n#                 #print(f'Matched: {word}')\n            \n#                 # prevent accessing non-existent key in substring_map (defaultdict) and causing empty list to generate\n#                 if word in substring_map and any(superstring in title for superstring in substring_map[word]):     # check eg 3 condition\n#                     #print(f'{word}\\n found in map: {substring_map[word]}\\n')\n#                     continue\n\n#                 if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n#                     #print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n#                     continue    \n\n#                 #print(f'{word}\"s group added\\n')\n#                 search_res[index].append(rdict[word])","89e091e0":"# for index, groups_found in search_res.items():\n#     search_res[index] = sorted(list(set(groups_found)))\n\n# regex_df = pd.Series(list(search_res.values())).to_frame().reset_index().rename(columns={0:'groups_found'})\n# regex_df.to_csv('regex_word_boundary.csv',index=False)","9452e450":"# search_res_full = {}\n\n# for index,title in enumerate(titles.name):\n#     search_res_full[index] = []\n#     for word in rdict:\n#         # regex is 600x slower than `a in b`-> minimize regex use or wrap in many if conditions\n#         #if re.search(f'\\s{word}\\s|^{word}\\s|\\s{word}$|^{word}$',title):  \n        \n#         if word in title:\n#             if re.search(fr'\\b{word}\\b',title):\n#                 #print(f'Title: {title}')\n#                 #print(f'Matched: {word}')\n            \n#                 # prevent accessing non-existent key in substring_map_full (defaultdict) and causing empty list to generate\n#                 if word in substring_map_full and any(superstring in title for superstring in substring_map_full[word]):     # check eg 3 condition\n#                     #print(f'{word}\\n found in map: {substring_map_full[word]}\\n')\n#                     continue\n\n#                 if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n#                     #print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n#                     continue    \n\n#                 #print(f'{word}\"s group added\\n')\n#                 search_res_full[index].append(rdict[word])","cdde6c5d":"# for index, groups_found in search_res_full.items():\n#     search_res_full[index] = sorted(list(set(groups_found)))\n\n# regex_df_full = pd.Series(list(search_res_full.values())).to_frame().reset_index().rename(columns={0:'groups_found'})\n# regex_df_full.to_csv('regex_word_boundary_fullmap.csv',index=False)","d1563416":"# full_super_ = {}\n\n# for index,title in enumerate(titles.name):\n#     full_super[index] = []\n#     for word in rdict:\n#         # regex is 600x slower than `a in b`-> minimize regex use or wrap in many if conditions\n#         #if re.search(f'\\s{word}\\s|^{word}\\s|\\s{word}$|^{word}$',title):  \n        \n#         if word in title:\n#             if re.search(fr'\\b{word}\\b',title):\n#                 #print(f'Title: {title}')\n#                 #print(f'Matched: {word}')\n            \n#                 # prevent accessing non-existent key in substring_map_full (defaultdict) and causing empty list to generate\n#                 if word in substring_map_full and any(bool(re.search(fr'\\b{superstring}\\b',title)) for superstring in substring_map_full[word]):\n#                 #if word in substring_map_full and any(superstring in title for superstring in substring_map_full[word]):     # check eg 3 condition\n#                     #print(f'{word}\\n found in map: {substring_map_full[word]}\\n')\n#                     continue\n\n#                 if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n#                     #print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n#                     continue    \n\n#                 #print(f'{word}\"s group added\\n')\n#                 full_super[index].append(rdict[word])","2272aa3d":"# for index, groups_found in full_super.items():\n#     full_super[index] = sorted(list(set(groups_found)))\n\n# regex_df_full_super = pd.Series(list(full_super.values())).to_frame().reset_index().rename(columns={0:'groups_found'})\n# regex_df_full_super.to_csv('regex_word_boundary_fullmap_super.csv',index=False)","0fda2c6c":"full_super_mismatch = {}\n\nfor index,title in enumerate(titles.name):\n    full_super_mismatch[index] = []\n    for word in rdict:\n        # regex is 600x slower than `a in b`-> minimize regex use or wrap in many if conditions\n        #if re.search(f'\\s{word}\\s|^{word}\\s|\\s{word}$|^{word}$',title):  \n        \n        if word in title:\n            if re.search(fr'\\b{word}\\b',title):\n                #print(f'Title: {title}')\n                #print(f'Matched: {word}')\n            \n                # prevent accessing non-existent key in substring_map_full (defaultdict) and causing empty list to generate\n                if word in substring_map_full and any(bool(re.search(fr'\\b{superstring}\\b',title)) for superstring in substring_map_full[word]):\n                #if word in substring_map_full and any(superstring in title for superstring in substring_map_full[word]):     # check eg 3 condition\n                    #print(f'{word}\\n found in map: {substring_map_full[word]}\\n')\n                    continue\n                \n                if word in mismatch_dic and any(bool(re.search(fr'\\b{mismatched_term}\\b',title)) for mismatched_term in mismatch_dic[word]):\n                #if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n                    #print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n                    continue    \n\n                #print(f'{word}\"s group added\\n')\n                full_super_mismatch[index].append(rdict[word])","1a742e31":"for index, groups_found in full_super_mismatch.items():\n    full_super_mismatch[index] = sorted(list(set(groups_found)))\n\nregex_df_full_super_mismatch = pd.Series(list(full_super_mismatch.values())).to_frame().reset_index().rename(columns={0:'groups_found'})\nregex_df_full_super_mismatch.to_csv('regex_word_boundary_fullmap_super_mismatch.csv',index=False)","6f4e1c3f":"plt.hist(list(map(len,full_super.values())))  # list() because RuntimeError: matplotlib does not support generators as input","fcc996eb":"# regex_df_full_super_mismatch =  pd.read_csv('regex_word_boundary_fullmap_super_mismatch.csv')\n# regex_df_full_super  = pd.read_csv('regex_word_boundary_fullmap_super.csv')","3731ee48":"# sum(regex_df_full_super.groups_found!=regex_df_full_super_mismatch.groups_found)","8eaa6f61":"# regex_df_full_super[regex_df_full_super.groups_found!=regex_df_full_super_mismatch.groups_found].sample(5,random_state=2)\n# regex_df_full_super_mismatch[regex_df_full_super.groups_found!=regex_df_full_super_mismatch.groups_found].sample(5,random_state=2)","ef5cd6da":"# titles.loc[\t316836,'name']\n\n# # select a word from this list and assign to keyword below to check what superstrings\/mismatch are there\n# print('keywords in group:', group_dict[239])  \n\n# keyword = 'jam'\n\n# print('superstrings: ',substring_map_full[keyword])\n# print('mismatched words: ',mismatch_dic[keyword])","ecefaaa6":"# index = 654229\n\n# for index,title in enumerate(titles[index:index+1].name):\n#     #search_res[index] = []\n#     for word in rdict:\n#         # regex is 600x slower than `a in b`-> minimize regex use or wrap in many if conditions\n#         #if re.search(f'\\s{word}\\s|^{word}\\s|\\s{word}$|^{word}$',title):  \n        \n#         if word in title:\n#             if re.search(fr'\\b{word}\\b',title):\n#                 print(f'Title: {title}')\n#                 print(f'Matched: {word}')\n#                 print(f'rdict group number: {rdict[word]}')\n                \n            \n#                 # prevent accessing non-existent key in substring_map (defaultdict) and causing empty list to generate\n#                 if word in substring_map and any(superstring in title for superstring in substring_map[word]):     # check eg 3 condition\n#                     print(f'{word} found in map: {substring_map[word]}\\n')\n#                     continue\n\n#                 if word in mismatch_dic and any(mismatched_term in title for mismatched_term in mismatch_dic[word]):\n#                     print(f'{word} found in mismatch_dic: {mismatch_dic[word]} \\n')\n#                     continue    \n\n#                 #print(f'{word}\"s group added\\n')\n#                 #search_res[index].append(rdict[word])","75efba3e":"#df1 = regex_df_full\n#df2 = regex_df_full_super\n\n# removal_prevention = df1[df1.groups_found!=df2.groups_found]\n# no_removal_prevention = df2[df1.groups_found!=df2.groups_found]\n\n# all(removal_prevention.groups_found.str.len()> no_removal_prevention.groups_found.str.len())","a69adb0d":"# Debugging on a single index (only the print statements and control flow matters)","ac7b008a":"## Need unique keys --> use index in key (titles have duplicate)","9e596db7":"# Inverting the group: keyword --> keyword: group ","e8da2036":"<a id='wordboundaries'><\/a>\n# Wrapping `title` with spaces (hack to accomodate keywords at start and end of title) and `keyword` in spaces to prevent finding `table` in `inflatable` (index 7) \n\n**Private:0.90675,  Public:0.90806**","7b6a7b4b":"## Reversed Group dict (ensures every keyword gets smallest group number)","c2394234":"# Using word boundaries to identify groups that add space method fails to recognize \n**Private:0.96637,  Public:0.96657**\n\n**Keywords not surrounded by space**\n- `(magazine` in index 21  \n- `wardrobe-` in index 32","53fcc779":"# Test speed of series.str.contains \n- Flattened structure with boolean series naming is more readable and avoids looping through titles row by row later\n- However some series.str methods use re.match, re.findall, re.search behind the scenes --> Very slow (https:\/\/colab.research.google.com\/github\/jakevdp\/PythonDataScienceHandbook\/blob\/master\/notebooks\/03.10-Working-With-Strings.ipynb)\n- Only 2 keywords (`word in rdict`) checked per second. ","6e7fa7a0":"# Checking differences between groups found by different methods ","5aaf78bf":"# Interpreting substring requirements ","4866708e":"# Producing full word match substrings using regex word boundaries","1fa0b02e":"# Searching in title for keywords and assigning groups ","357485b2":"# Comparing the substring maps \n- `substring_map_full` has only 76 keys vs 99 in original `substring_map` (eg. `led tv` is not substring of `oled tv` anymore )\n- `substring_map_full` also has less superstrings per key than `substring_map` (harder to remove bad groups later)","f2df70df":"# Results Summary\n\n| Method                                                                   | Private | Public  |\n|:-------------------------------------------------------------------------|---------|---------|\n| Space wrap word                                                          | 0.90675 | 0.90806 |\n| Space wrap word, superstring                                             | 0.90882 | 0.91043 |\n| Space wrap word, superstring, mismatch                                   | 0.90925 | 0.91088 |\n| \\b wrap word                                                             | 0.96637 | 0.96657 |\n| \\b wrap word, substring_map_full                                         | 0.97199 | 0.97193 |\n| \\b wrap word, substring_map_full, superstring                            | 0.97367 | 0.97358 |\n| \\b wrap word, substring_map_full, superstring, mismatch                  | 0.97412 | 0.97407 |\n| * plural mismatch (not required by instructions, just common sense)      | 0.97370 | 0.97361 |\n| * clean titles (`re.sub('[^\\x00-\\x7F]',' ',string)`)                     | 0.97269 | 0.97291 |\n| * add `flags=re.ASCII` to all 3 `re.search`                              | 0.97269 | 0.97291 |\n\n- `*` means not shown in this notebook\n- `plural mismatch` changes just 1 line from the highest 0.97412 method (`re.search(fr'\\b{mismatched_term}(\\b|s\\b|es\\b)',title)`)\n- both `clean titles` and re.ASCII are to add shorts (group 18) to index 26658 `...shorts\u77ed\u88e4`\n- Not advised to use `re.sub([\\W_],' ',string)` to clean titles as keywords contains \\W. eg `e-juice, e-book, tablets 2-in-1` \n\n- All major code blocks commented out except highest scoring one to speed up kaggle commit. Highlight all, `Ctrl+\/` to uncomment ","6afed6f6":"# Wrapping the superstring and mismatch conditions in spaces too \n**Private:0.90925,  Public:0.91088**\n\n- For all product titles, there are more groups found without removal protection (previous method of only wrapping title and keyword) compared to this method of wrapping spaces around superstring and mismatch \n- **Leaving those groups in the result is logically wrong, why does it score higher?**\n \n**Evidence against space wrapping superstring or mismatch:**\n\n**Superstring space wrap effects** \n- `futon-sofa bed` (index 554 ) 'bed' group is protected from removal if superstring 'sofa bed' wrapped by space\n- `ready stock*baby socks` (index 620) socks protected from removal due to superstring 'baby socks' \n\n**Mismatch list space wrap effects** (Should not space wrap superstring?)\n- `... slim pencil skirts dress with belt` (index 799). \n    - `pencil` (group 205) not removed because `pencil skirt` in mismatch list had spaces wrapped' \n- `...g-shock watches jam tangan'` (index 853) \n    - `jam`  (group 239) was not removed because `jam watch` from mismatch list wrapped space\n- `zhuji men's basketball jerseys short sleeve vest suit` (index 799686) \n    - `basketball` (group 108) not removed because `basketball jersey` from mismatch list wrapped in space\n- `team sports football soccer training train pinnies jerseys bib vest` (index 317911)\n    - `football` (group 108) did not get removed because space wrapped `jersey` in mismatch list cannot match `jerseys`","aa77d9cd":"# Wrapping word boundary for superstring  \n<a id='super_boundary'><\/a>\n**Private:0.97367, Public:0.97358**\n- logically makes no sense given all the evidence above against making superstrings and mismatch list stricter, but just testing to see if it gets higher score --> Yes\n\n**Evidence against keeping word boundary around superstring**\n- `mouse pad gaming mousepad anti-slip...` (index 286628)  - mouse (Group 84) should be removed\n    - `mouse` (group 84) was kept from removal because boundary wrapped superstring `\\bgaming mouse\\b` cannot match `gaming mousepad`\n    - If word boundary around superstring is removed and mouse (group 84) got removed because of superstring `gaming mouse` , there is still another keyword `gaming mouse` (also group 84) that can add 84 in, but following the \\bword\\b (table in inflatable) case, `gaming mouse` will fail to match to  `gaming mousepad` in title, so 84 cannot be added back in both ways \n    \n\n- `'ready stock new slveelesst-shirt ...'` (index 52598) - shirt (Group 29) should be removed and t-shirt (also Group 29) added, same effect, but through correct mechanism  \n    - Making superstring `t-shirt` stricter using word boundaries prevented removal of `shirt` (group 29) \n    - The default methodology assumes groups of the longer keyword  (`t-shirt`) and the shorter keyword ( `shirt`) are different, and the longer keyword group should overwrite shorter keyword group, however in this example both `shirt` and `t-shirt` are group 29, resulting in the same group assignments when leaving the shorter keyword group in without being removed\n    \n<a id='plural'><\/a>\n- `...female summer a-line skirt knitted mini dresses` (index 522868) - dress(Group 30) should be removed\n    - `dress` not removed because superstring `\\bmini dress\\b` could not match `mini dresses` in title \n    ","60b35901":"# Only wrapping the superstring in spaces \n**Private:0.90882,  Public:0.91043**\n- Why does this score higher than only space wrapping keyword with the evidence below?\n\n**Evidence against wrapping space around superstring**\n- `t-shirt+shorts set boys short sleeve t shirt casual suit boys t-shirts` (index 799494) \n    - `shirt` (group 29) not removed because space wrapped ` t-shirt ` cannot match `t-shirt+` or `t-shirts` \n- `'handmade waterproof laptop bag\/laptop case (christmas tree)'` (index 1243)\n    - `laptop` (group 77) could not be removed because space wrapped ` laptop bag ` mismatch  `laptop bag\/`","8348c692":"- The substring section in instructions is assumed to be designed with the following goals, and qualitative method evaluation in the notebook is based on fulfilling such goals:\n    - If there is a superstring, and obviously refers to a different object from the substring (eg `table` (group 172) vs `table lamps` (group 194)), the shorter string should not be added because it is does not convey what's in the product (This point is more explicit in the instructions)\n    - If there is a superstring, that means the group from the shorter string should not be added because the longer string provides more specific information about a product (eg `curtains` (group 185) vs `shower curtains` (group 195)) (This interpretation is not explicitly promoted in the instructions)\n        - However, there are cases where both sub and superstring appear in same group (`mouse` and `gaming mouse` in 84, or `shirt` and `t-shirt` in 29, where [complications](#super_boundary) arise. Especially for the product title `mouse pad gaming mousepad...` in that linked cell, where we want to fulfil the first interpretation by going for a longer\/more specific description  `mouse` vs `gaming mouse`, and also fulfil the second interpretation by not confusing `gaming mouse` vs `gaming mousepad`   \n\n- The mix of these complications, with necessity to define [word boundaries](#wordboundaries) , and appearance of [plural](#plural) word forms in product titles makes it difficult to find an ideal way to fulfil both interpretations.","44416618":"# Formatting mismatch list","fe16abf4":"## Test speed of series.apply() --> No difference from for-loop through titles","c51e6996":"# Read data ","37a0d445":"# Distribution of keyword matches - high match count being spam suspect  ","f07a7a10":"# Check if those more restrictive search strategies (Wrapping superstring\/mismatch with space) always produce less groups --> Yes","f00e20c2":"# Exploring what substrings there are in reverse_dict","73e58e7e":"# Wrapping word boundary for superstring and mismatch list\n**Private:0.97412, Public:0.97407**\n\n**Evidence against word boundary around mismatch list**\n- `...sexy pencil denim striped jeans jumpsuit skirts dress` (index 485792) \n    - `pencil` (group 205) was not removed because mismatched word `\\bskirt\\b` could not match `skirts` in title\n    \n- `new fashion basketball 3d hoodies celebrity superstar print 3d sweatshirt` (index 143253)\n    - `basketball` (group 108) not removed because mismatched word `\\bshirt\\b` could not match `sweatshirt` in title","618ad642":"## Checking for duplicated titles ","e8dbc5ce":"# Using full match substring match for filtering \n**Private:0.97199,  Public:0.97193**\n- Why does `substring_map_full` score higher than using `substring_map`? (with the evidence below showing it's logically wrong to use `substring_map_full` because it does not create necessary superstrings to remove bad groups)\n\n**Evidence against using substring_map_full**\n- `usb flash drives pendrives usb 2.0 pen drive drive memory` (index 550). \n    - With `substring_map`, pen (group 205) correctly removed due to `pendrives` superstring. \n    - With `substring_map_full`, superstring `pendrives` will not be created and `pen`'s group is not removed  \n- `double-end waterproof eyebrow pencil eye brow brush...` (index 483). \n    - With `substring_map` pen group (205) correctly removed due to `eyebrow pencil` superstring. \n    - With `substring_map_full`, superstring `eyebrow pencil` will not be created and `pen`'s group is not removed \n"}}