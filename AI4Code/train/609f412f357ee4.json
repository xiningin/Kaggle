{"cell_type":{"9fea08a9":"code","b8b70f82":"code","2099cf03":"code","bb1a1f90":"code","e76c4953":"code","fdeeb324":"code","d0722355":"code","3f332bf3":"code","56238bb1":"code","d617e28e":"code","c6609e04":"code","e5ceb36e":"code","ea48c4f8":"code","e5b90959":"code","350da36f":"code","c6548d93":"code","ccee977a":"code","c21fe0bf":"code","17310972":"markdown","15d1c382":"markdown","98c5e5b1":"markdown","8c2805db":"markdown","64a09c7f":"markdown","d5fc00c9":"markdown","ee7a8dc0":"markdown","445cda94":"markdown","6bbb81ea":"markdown"},"source":{"9fea08a9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plot\nfrom scipy import stats\nplot.style.use(\"ggplot\")\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom scipy import stats\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b8b70f82":"data = pd.read_csv(\"..\/input\/breast-cancer-wisconsin-data\/data.csv\")\ndata.head()","2099cf03":"data = data.drop(['Unnamed: 32','id'],axis=1)\ndata.head()","bb1a1f90":"data.shape","e76c4953":"data.columns","fdeeb324":"m = plot.hist(data[data[\"diagnosis\"] == \"M\"].radius_mean,bins=30,fc=(1,0,0,0.5), label=\"Malignant\")\nb = plot.hist(data[data[\"diagnosis\"] == \"B\"].radius_mean,bins=30,fc=(0,1,0,0.5), label=\"Bening\")\nplot.legend()\nplot.xlabel(\"Radius Mean Values\")\nplot.ylabel(\"Frequency\")\nplot.title(\"Histogram\")\nplot.show()","d0722355":"np.mean(data[data[\"diagnosis\"] == \"M\"].radius_mean)","3f332bf3":"np.mean(data[data[\"diagnosis\"] == \"B\"].radius_mean)","56238bb1":"melted_data = pd.melt(data,id_vars = \"diagnosis\", value_vars = ['radius_mean', 'texture_mean'])\nsns.boxplot(x = \"variable\", y=\"value\",hue=\"diagnosis\", data=melted_data)\nplot.show()","d617e28e":"data_bening = data[data[\"diagnosis\"] == \"B\"]\nprint(\"mean: \", data_bening.radius_mean.mean())\nprint(\"variance: \", data_bening.radius_mean.var())\nprint(\"std: \", data_bening.radius_mean.std())\nprint(\"median: \", data_bening.radius_mean.median(), \"\\n\")\nprint(\"describe method: \", data_bening.radius_mean.describe())\n","c6609e04":"plot.hist(data_bening.radius_mean, bins=50, fc=(0,1,0,0.5), label='bening', cumulative = True)\n# Why is this not possible to use 'normed = True' ? \nsorted_data = np.sort(data_bening.radius_mean)\ny = np.arange(len(sorted_data))\/float(len(sorted_data)-1)\nplot.plot(sorted_data,y,color='r')\nplot.title('cdf')\nplot.show()\n","e5ceb36e":"sns.jointplot(data.radius_mean,data.area_mean,kind = \"reg\")\nplot.show","ea48c4f8":"sns.set(style = \"white\")\ndf = data.loc[:,[\"radius_mean\",\"area_mean\",\"fractal_dimension_se\"]]\ng = sns.PairGrid(df,diag_sharey = False)\ng.map_lower(sns.kdeplot, camp=\"Blues_d\")\ng.map_upper(plot.scatter)\ng.map_diag(sns.kdeplot, lw = 3)\nplot.show()","e5b90959":"f, ax = plot.subplots(figsize = (18,18))\nsns.heatmap(data.corr(), annot = True, linewidths = 0.5, fmt = \".1f\", ax = ax)\nplot.xticks(rotation = 90)\nplot.yticks(rotation = 0)\nplot.title('Correlatiojn Map')\nplot.savefig('graph.png')\nplot.show()","350da36f":"np.cov(data.radius_mean,data.area_mean)\nprint(\"Cov between radius and area\", data.radius_mean.cov(data.area_mean))\nprint(\"Cov between radius and fractal\", data.radius_mean.cov(data.fractal_dimension_se))\n","c6548d93":"p1 = data.loc[:,[\"area_mean\",\"radius_mean\"]].corr(method = \"pearson\")\nprint('Pearson correaltion: ', p1)","ccee977a":"ranked_data = data.rank()\nspearman_corr = ranked_data.loc[:,[\"area_mean\",\"radius_mean\"]].corr(method = \"pearson\")\nprint(\"Spearman's correlation:\", spearman_corr)","c21fe0bf":"x = data.area_mean\nx_mean = np.mean(x)\nx_std = np.std(x)\nz = (x-x_mean)\/x_std\nplot.hist(z,bins=100)","17310972":"# Pearson correlation","15d1c382":"# Load data","98c5e5b1":"# Covariance","8c2805db":"# Spearman's Rank correlation","64a09c7f":"# Histogram","d5fc00c9":"# CDF (Cumulative distribution function) \n- CDF is the probability that the variable takes a value less than or equal to x. P(","ee7a8dc0":"# Box plot","445cda94":"# Z-scoring (Normalization)","6bbb81ea":"# Correlation"}}