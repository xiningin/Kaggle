{"cell_type":{"efa824b5":"code","0b6d7f84":"code","f2e50356":"code","eb345753":"code","ce61e5ef":"code","86dd8c17":"code","22c24ff9":"code","8c3da0a9":"code","06d7ad4f":"markdown","214cd570":"markdown","b8166496":"markdown","24830a34":"markdown","047fc18f":"markdown","2d885fef":"markdown","ba54ee6f":"markdown","8f4b016d":"markdown","3571f501":"markdown"},"source":{"efa824b5":"import numpy as np\nimport cv2\nimport matplotlib.pyplot as plt","0b6d7f84":"# Sobel x-axis kernel\nSOBEL_X = np.array((\n    [-1, 0, 1],\n    [-2, 0, 2],\n    [-1, 0, 1]), dtype=\"int32\")\n\n# Sobel y-axis kernel\nSOBEL_Y = np.array((\n    [-1, -2, -1],\n    [0, 0, 0],\n    [1, 2, 1]), dtype=\"int32\")\n\n# Gaussian kernel\nGAUSS = np.array((\n    [1\/16, 2\/16, 1\/16],\n    [2\/16, 4\/16, 2\/16],\n    [1\/16, 2\/16, 1\/16]), dtype=\"float64\")\n","f2e50356":"def convolve(img, kernel):\n    \"\"\"\n    Convolve function for odd dimensions.\n    IT CONVOLVES IMAGES\n    \"\"\"\n    if kernel.shape[0] % 2 != 1 or kernel.shape[1] % 2 != 1:\n        raise ValueError(\"Only odd dimensions on filter supported\")\n\n    img_height = img.shape[0]\n    img_width = img.shape[1]\n    pad_height = kernel.shape[0] \/\/ 2\n    pad_width = kernel.shape[1] \/\/ 2\n    \n    pad = ((pad_height, pad_height), (pad_height, pad_width))\n    g = np.empty(img.shape, dtype=np.float64)\n    img = np.pad(img, pad, mode='constant', constant_values=0)\n    # Do convolution\n    for i in np.arange(pad_height, img_height+pad_height):\n        for j in np.arange(pad_width, img_width+pad_width):\n            roi = img[i - pad_height:i + pad_height +\n                      1, j - pad_width:j + pad_width + 1]\n            g[i - pad_height, j - pad_width] = (roi*kernel).sum()\n\n    if (g.dtype == np.float64):\n        kernel = kernel \/ 255.0\n        kernel = (kernel*255).astype(np.uint8)\n    else:\n        g = g + abs(np.amin(g))\n        g = g \/ np.amax(g)\n        g = (g*255.0)\n    return g","eb345753":"def harris(img, threshold=0.6):\n\n    img_cpy = img.copy() # copying image\n\n    img1_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # grayscaling (0-1)\n\n    dx = convolve(img1_gray, SOBEL_X) # convolving with sobel filter on X-axis\n    dy = convolve(img1_gray, SOBEL_Y) # convolving with sobel filter on Y-axis\n    # square of derivatives\n    dx2 = np.square(dx)\n    dy2 = np.square(dy)\n    dxdy = dx*dy #cross filtering\n    # gauss filter for all directions (x,y,cross axis)\n    g_dx2 = convolve(dx2, GAUSS)\n    g_dy2 = convolve(dy2, GAUSS)\n    g_dxdy = convolve(dxdy, GAUSS)\n    # Harris Function\n    harris = g_dx2*g_dy2 - np.square(g_dxdy) - 0.12*np.square(g_dx2 + g_dy2) # r(harris) = det - k*(trace**2)\n    # Normalizing inside (0-1)\n    cv2.normalize(harris, harris, 0, 1, cv2.NORM_MINMAX)\n\n    # find all points above threshold (nonmax supression line)\n    loc = np.where(harris >= threshold)\n    # drawing filtered points\n    for pt in zip(*loc[::-1]):\n        cv2.circle(img_cpy, pt, 3, (0, 0, 255), -1)\n\n    return img_cpy,g_dx2,g_dy2,dx,dy,loc","ce61e5ef":"img = cv2.imread('\/kaggle\/input\/drone-dataset-uav\/drone_dataset_yolo\/dataset_txt\/0003.jpg')\n\ncorners,g_dx2,g_dy2,dx,dy,loc = harris(img,0.85)","86dd8c17":"# display raw & filtered images\nplt.figure(figsize=(20, 20))\nplt.subplot(131), plt.imshow(img)\nplt.title(\"Raw Image\"), plt.xticks([]), plt.yticks([])\nplt.subplot(132), plt.imshow(dx)\nplt.title(\"Sobel on X axis\"), plt.xticks([]), plt.yticks([])\nplt.subplot(133), plt.imshow(dy)\nplt.title(\"Sobel on Y axis\"), plt.xticks([]), plt.yticks([])\nplt.show()","22c24ff9":"plt.figure(figsize=(20, 20))\nplt.subplot(131), plt.imshow(img)\nplt.title(\"Raw Image\"), plt.xticks([]), plt.yticks([])\nplt.subplot(132), plt.imshow(g_dx2)\nplt.title(\"Gauss on X axis\"), plt.xticks([]), plt.yticks([])\nplt.subplot(133), plt.imshow(g_dy2)\nplt.title(\"Gauss on Y axis\"), plt.xticks([]), plt.yticks([])\nplt.show()","8c3da0a9":"plt.figure(figsize=(20, 20))\nplt.subplot(121), plt.imshow(img)\nplt.title(\"Raw Image\"), plt.xticks([]), plt.yticks([])\nplt.subplot(122), plt.imshow(corners)\nplt.title(\"Harris Corner Output\"), plt.xticks([]), plt.yticks([])","06d7ad4f":"## Harris function\n- Image converted to grayscale\n- Sobel filters convolved on image for both axis\n- Square of derivatives and cross multiply calculated\n- All axes filtered with gaussian kernel\n- Cornerness Function used to calculate\n- Non-max supression implemented\n- Circles drawed on filtered points","214cd570":"## Raw Image and Harris Corner Output Visualization","b8166496":" ## Convolution function from scratch. Alternatively, you can use opencv, skimage, pillow libraries.","24830a34":"## Raw Image and Sobel-Gauss Filtered Images Visualization","047fc18f":"# Harris Corner Detector Implementation Process","2d885fef":"![howto.png](attachment:howto.png)","ba54ee6f":"## Sobel and gaussian kernels defined here with numpy","8f4b016d":"## Raw Image and Sobel Filtered Images Visualization","3571f501":"# Image Reading and Filtering Area"}}