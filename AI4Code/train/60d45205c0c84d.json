{"cell_type":{"5a2866b7":"code","fabb4849":"code","1a654bce":"code","65c472c8":"code","08de29a2":"code","9d9a7755":"code","ab7f1cc6":"code","bb717e83":"code","4afcb242":"code","9d9a15cf":"code","7254e898":"code","201698ee":"code","c5542bf4":"code","ab4f60b8":"code","ebff0cc3":"code","eb705ee3":"code","ebd61fdd":"code","99443d39":"code","88e0fb9f":"code","91cae450":"code","46cb9ebb":"code","f6b08d48":"code","16d28160":"code","3f70db3a":"code","fc437321":"code","36436e77":"code","d311ad8d":"code","d0ebf18b":"code","72177f97":"code","5700d92e":"code","68075ebe":"code","82e0af0d":"code","1c2b612b":"code","2aeb444b":"code","dcff6eae":"code","bdec6058":"code","f35b4f52":"code","498ffba9":"code","aed1c45f":"code","9ad09e7c":"code","221bb24b":"code","5a887366":"code","887ecb4f":"code","06865bc9":"code","f86a171d":"code","438617ab":"code","8b901ba2":"code","9f2f346b":"code","77a76a31":"code","2ee2e1b1":"code","c5548400":"code","df9c2f2c":"markdown","21b045e1":"markdown","3a4bee33":"markdown","bcf1d06a":"markdown","317a3b6d":"markdown","7671bb16":"markdown","a3a9566d":"markdown","c00f9bbe":"markdown","7b89e077":"markdown","ddd0ec0e":"markdown","95c0765c":"markdown","2b7a74bd":"markdown","d0f5e516":"markdown","503b6310":"markdown","fe612841":"markdown","210401fc":"markdown","ba32c2e8":"markdown","4c42f479":"markdown","f873feca":"markdown"},"source":{"5a2866b7":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom sklearn.model_selection import train_test_split","fabb4849":"df = pd.read_csv('..\/input\/digit-recognizer\/train.csv')\ndf1 = pd.read_csv('..\/input\/digit-recognizer\/test.csv')","1a654bce":"x_train = df.drop('label', axis = 1)\ny_train = df['label']\n\ntest = df1","65c472c8":"x_train.shape","08de29a2":"test.shape","9d9a7755":"x_train = x_train.values.reshape(42000, 28,28)\ntest = test.values.reshape(28000, 28, 28)","ab7f1cc6":"x_train.shape","bb717e83":"test.shape","4afcb242":"single_image = x_train[0]","9d9a15cf":"single_image","7254e898":"#matplotlib has a method to show these values in image format\nplt.imshow(single_image)","201698ee":"#exploring labels\ny_train","c5542bf4":"from tensorflow.keras.utils import to_categorical","ab4f60b8":"#checking the shape of y_train\ny_train.shape","ebff0cc3":"y_example = to_categorical(y_train)","eb705ee3":"y_example.shape","ebd61fdd":"y_example[0]","99443d39":"y_cat_train = to_categorical(y_train, num_classes=10)\n#to_categorical takes num_classes on its own based on the label's unique values\n#here it was from 0 to 9, hence, it took 10. You can specify them too using num_classes","88e0fb9f":"y_cat_train[0]","91cae450":"#checking the maximum value of single_image\nsingle_image.max()","46cb9ebb":"#checking the minimum value of single_image\nsingle_image.min()","f6b08d48":"x_train = x_train\/255\ntest = test\/255","16d28160":"#checking the scaled image\nscaled_image = x_train[0]","3f70db3a":"scaled_image","fc437321":"scaled_image.max()","36436e77":"plt.imshow(scaled_image)","d311ad8d":"x_train.shape","d0ebf18b":"#batch_size, width, height, color channels\nx_train = x_train.reshape(42000, 28, 28, 1)","72177f97":"test.shape","5700d92e":"test = test.reshape(28000, 28, 28, 1)","68075ebe":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, Flatten","82e0af0d":"random_seed = 2\n\nx_train, x_val, y_cat_train, y_val = train_test_split(x_train, y_cat_train, test_size = 0.1, random_state=random_seed)","1c2b612b":"model = Sequential()\n\nmodel.add(Conv2D(filters = 32, kernel_size=(4,4), strides = (1,1), input_shape=(28,28,1),activation='relu'))\nmodel.add(MaxPool2D(pool_size=(2,2)))\n\nmodel.add(Flatten()) #flatten our layer, eg, our image is 28x28 so the flattened image will be 28*28=784 pixels\n\nmodel.add(Dense(128, activation='relu'))\n\n#OUTPUT layer\nmodel.add(Dense(10, activation='softmax')) #choosing softmax because of 'multiclass classification'\n\n\nmodel.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics= ['accuracy'])","2aeb444b":"#Gonna import EarlyStopping in order to avoid overfitting\nfrom tensorflow.keras.callbacks import EarlyStopping","dcff6eae":"early_stop = EarlyStopping(monitor = 'val_loss', patience = 1)","bdec6058":"#Fitting the model\nmodel.fit(x_train, y_cat_train, epochs = 10, validation_data = (x_val, y_val), callbacks = [early_stop])","f35b4f52":"metrics = pd.DataFrame(model.history.history)","498ffba9":"metrics.head()","aed1c45f":"#Plotting loss and val_loss together\nmetrics[['loss', 'val_loss']].plot()","9ad09e7c":"#Plotting accuracy and val_accuracy together\nmetrics[['accuracy', 'val_accuracy']].plot()","221bb24b":"#Evaluating validation loss and accuracy\nmodel.evaluate(x_val, y_val, verbose = 0)","5a887366":"from sklearn.metrics import classification_report, confusion_matrix","887ecb4f":"predictions = model.predict(x_val)\n\n# Convert predictions classes to one hot vectors \npredictions_classes = np.argmax(predictions, axis = 1)\n# Convert validation observations to one hot vectors\ny_true = np.argmax(y_val, axis = 1)","06865bc9":"#we'll use y_true for predictions\nprint(classification_report(y_true, predictions_classes))","f86a171d":"print(confusion_matrix(y_true, predictions_classes))","438617ab":"#visualizing confusion matrix\nimport seaborn as sns\n\nplt.figure(figsize = (12, 8))\nsns.heatmap(confusion_matrix(y_true, predictions_classes), annot=True)","8b901ba2":"# predict results\nresults = model.predict(test)\n\n# gives the index of the greatest number in the given column\nresults = np.argmax(results,axis = 1)\n\nresults = pd.Series(results,name=\"Label\")","9f2f346b":"results","77a76a31":"kaggle_submission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1)","2ee2e1b1":"kaggle_submission","c5548400":"kaggle_submission.to_csv(\"digit_recognizer_mnist.csv\", index=False)","df9c2f2c":"# Now we're gonna take 10% data from the training data and use it for data validation","21b045e1":"Here, y_train's dataset of 42000 represents labels, what we want is each of these labels to represent a category,so we'll use to_categorical method","3a4bee33":"we can see that to_categorical converted a class vector into a binary class matrix","bcf1d06a":"**Now we are going to normalize our data**","317a3b6d":"# Both of them look pretty good","7671bb16":"# Now we're going to train our model. Let's import some libraries.","a3a9566d":"Checking the metrics now.","c00f9bbe":"**If this analysis helps you in any way, please upvote :)**","7b89e077":"# Now we'll get Classification Report and Confusion Matrix. \n# A Classification report is used to measure the quality of predictions from a classification algorithm and a Confusion Matrix is a tabular summary of the number of correct and incorrect predictions made by a classifier.","ddd0ec0e":"# Now we're gonna reshape our image to let the model know that we're dealing with a greyscale image, hence 1 color channel","95c0765c":"# filters:- how many filters to apply on an image\n# kernel_size:- size of the matrix which strides through the whole image \n# stride:- (x,y) steps while moving the kernel \n# padding:- Padding is the extra layer we add to the corner of the image to prevent shrinkage and loss of info, such as add a padding of 0 on the outside of the image matrix, so that the corner matrix is also covered more than once while striding","2b7a74bd":"this looks like a **'1'**, and since greyscale values varies from 0 to 255, we can see values close to 255 in the matrix above","d0f5e516":"Split the training data by features and labels","503b6310":"Check the shape of training and test data","fe612841":"Here we stand correct, the first value is 1, as shown in the image above\n\n\nThe values here represent labels, what we want is categories, so we have to use one-hot-encoding","210401fc":"displaying the matrix of a single image, [0] defines the first instance of the data","ba32c2e8":"**Reshaping our data into a 28x28 matrix**","4c42f479":"# we're gonna scale them between 0 and 1","f873feca":"Notice here, the first value of label was 1, so to_categorical() has transformed that into an entire row"}}