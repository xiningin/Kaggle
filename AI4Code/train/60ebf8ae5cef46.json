{"cell_type":{"1f832b0f":"code","3938b60f":"code","c0cc034e":"code","f1bfe772":"code","5cb913d1":"code","0cc21212":"code","a51f516d":"code","20f9f97c":"code","4649c047":"code","8e4b94fa":"code","6aa1d034":"code","bbc9ac7a":"code","06fee092":"code","b5875ef1":"code","b0c2d4f1":"code","228f8605":"code","789d1688":"code","74d9b994":"code","b6aaa4e5":"code","68293d52":"markdown","f50f076d":"markdown","990aeabd":"markdown","8e9b1899":"markdown","a9704ea3":"markdown","2cffbbda":"markdown","1c37a86c":"markdown","a6d1c777":"markdown","385cfa03":"markdown","062902c8":"markdown","13708103":"markdown","79b656ff":"markdown","19a906ec":"markdown","88fb6510":"markdown","2fbb9c4e":"markdown","c14f1312":"markdown","91a690e4":"markdown","26a314bc":"markdown","9cd84058":"markdown","78d6ff4e":"markdown","51184098":"markdown","654030c1":"markdown"},"source":{"1f832b0f":"import numpy as np, random, operator, pandas as pd, matplotlib.pyplot as plt","3938b60f":"class City:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def distance(self, city):\n        xDis = abs(self.x - city.x)\n        yDis = abs(self.y - city.y)\n        distance = np.sqrt((xDis ** 2) + (yDis ** 2))\n        return distance\n    \n    def __repr__(self):\n        return \"(\" + str(self.x) + \",\" + str(self.y) + \")\"","c0cc034e":"class Fitness:\n    def __init__(self, route):\n        self.route = route\n        self.distance = 0\n        self.fitness= 0.0\n    \n    def routeDistance(self):\n        if self.distance ==0:\n            pathDistance = 0\n            for i in range(0, len(self.route)):\n                fromCity = self.route[i]\n                toCity = None\n                if i + 1 < len(self.route):\n                    toCity = self.route[i + 1]\n                else:\n                    toCity = self.route[0]\n                pathDistance += fromCity.distance(toCity)\n            self.distance = pathDistance\n        return self.distance\n    \n    def routeFitness(self):\n        if self.fitness == 0:\n            self.fitness = 1 \/ float(self.routeDistance())\n        return self.fitness","f1bfe772":"def createRoute(cityList):\n    route = random.sample(cityList, len(cityList))\n    return route","5cb913d1":"def initialPopulation(popSize, cityList):\n    population = []\n\n    for i in range(0, popSize):\n        population.append(createRoute(cityList))\n    return population","0cc21212":"def rankRoutes(population):\n    fitnessResults = {}\n    for i in range(0,len(population)):\n        fitnessResults[i] = Fitness(population[i]).routeFitness()\n    return sorted(fitnessResults.items(), key = operator.itemgetter(1), reverse = True)","a51f516d":"def selection(popRanked, eliteSize):\n    selectionResults = []\n    df = pd.DataFrame(np.array(popRanked), columns=[\"Index\",\"Fitness\"])\n    df['cum_sum'] = df.Fitness.cumsum()\n    df['cum_perc'] = 100*df.cum_sum\/df.Fitness.sum()\n    \n    for i in range(0, eliteSize):\n        selectionResults.append(popRanked[i][0])\n    for i in range(0, len(popRanked) - eliteSize):\n        pick = 100*random.random()\n        for i in range(0, len(popRanked)):\n            if pick <= df.iat[i,3]:\n                selectionResults.append(popRanked[i][0])\n                break\n    return selectionResults","20f9f97c":"def matingPool(population, selectionResults):\n    matingpool = []\n    for i in range(0, len(selectionResults)):\n        index = selectionResults[i]\n        matingpool.append(population[index])\n    return matingpool","4649c047":"def breed(parent1, parent2):\n    child = []\n    childP1 = []\n    childP2 = []\n    \n    geneA = int(random.random() * len(parent1))\n    geneB = int(random.random() * len(parent1))\n    \n    startGene = min(geneA, geneB)\n    endGene = max(geneA, geneB)\n\n    for i in range(startGene, endGene):\n        childP1.append(parent1[i])\n        \n    childP2 = [item for item in parent2 if item not in childP1]\n\n    child = childP1 + childP2\n    return child","8e4b94fa":"def breedPopulation(matingpool, eliteSize):\n    children = []\n    length = len(matingpool) - eliteSize\n    pool = random.sample(matingpool, len(matingpool))\n\n    for i in range(0,eliteSize):\n        children.append(matingpool[i])\n    \n    for i in range(0, length):\n        child = breed(pool[i], pool[len(matingpool)-i-1])\n        children.append(child)\n    return children","6aa1d034":"def mutate(individual, mutationRate):\n    for swapped in range(len(individual)):\n        if(random.random() < mutationRate):\n            swapWith = int(random.random() * len(individual))\n            \n            city1 = individual[swapped]\n            city2 = individual[swapWith]\n            \n            individual[swapped] = city2\n            individual[swapWith] = city1\n    return individual","bbc9ac7a":"def mutatePopulation(population, mutationRate):\n    mutatedPop = []\n    \n    for ind in range(0, len(population)):\n        mutatedInd = mutate(population[ind], mutationRate)\n        mutatedPop.append(mutatedInd)\n    return mutatedPop","06fee092":"def nextGeneration(currentGen, eliteSize, mutationRate):\n    popRanked = rankRoutes(currentGen)\n    selectionResults = selection(popRanked, eliteSize)\n    matingpool = matingPool(currentGen, selectionResults)\n    children = breedPopulation(matingpool, eliteSize)\n    nextGeneration = mutatePopulation(children, mutationRate)\n    return nextGeneration","b5875ef1":"def geneticAlgorithm(population, popSize, eliteSize, mutationRate, generations):\n    pop = initialPopulation(popSize, population)\n    print(\"Initial distance: \" + str(1 \/ rankRoutes(pop)[0][1]))\n    progress = []\n    \n    the_best_distance = 10**20\n    the_best_route = []\n    step = 0\n    for i in range(0, generations):\n        pop = nextGeneration(pop, eliteSize, mutationRate)\n        progress.append(1 \/ rankRoutes(pop)[0][1])\n        print(\"step:\", i, \"distance:\", 1 \/ rankRoutes(pop)[0][1])\n#         print((1 \/ rankRoutes(pop)[0][1]), the_best_distance)\n        if (1 \/ rankRoutes(pop)[0][1]) < the_best_distance:\n            print(\"update\")\n            the_best_distance = (1 \/ rankRoutes(pop)[0][1])\n            bestRouteIndex = rankRoutes(pop)[0][0]\n            the_best_route = pop[bestRouteIndex]\n            step = i\n    \n    print(\"Final distance: \" + str( the_best_distance), \"at step:\", step)  \n#     print(\"Final distance: \" + str(1 \/ rankRoutes(pop)[0][1]))\n#     bestRouteIndex = rankRoutes(pop)[0][0]\n#     bestRoute = pop[bestRouteIndex]\n    \n    \n    plt.plot(progress)\n    plt.ylabel('Distance')\n    plt.xlabel('Generation')\n    plt.show()\n    \n    print(the_best_route)","b0c2d4f1":"import matplotlib.pyplot as plt\nimport numpy as np\n\ndef midpoint(x1,x2,y1,y2):\n    x_m_point = (x1 + x2)\/2\n    y_m_point = (y1 + y2)\/2\n    return x_m_point, y_m_point\n    \ncityList = []\nr = np.random.RandomState(1234)\nprint(r)\nNN = 20\nD_city = {}\nfor i in range(0,NN):\n    temp = City(x=int(r.rand() * 10), y=int(r.rand() * 10))\n    cityList.append(temp)\n\nprint(\"cityList\", cityList)\nfor i,items in enumerate(cityList):\n    plt.scatter(items.x, items.y, alpha=1)\n    for j in range (i+1, NN):\n        plt.plot([cityList[i].x,cityList[(j)].x],[cityList[i].y,cityList[(j)].y],'c-')\n        x_m_point, y_m_point = midpoint(cityList[i].x,cityList[(j)].x,cityList[i].y,cityList[(j)].y)\n        d = cityList[i].distance(cityList[(j)])\n        plt.text(x_m_point, y_m_point, str(d.round(2)), ha='center', size=10)\nplt.show()","228f8605":"# #Do thi day du N dinh co N(N-1)\/2 canh\n# route = random.sample(cityList, len(cityList))\n# print(\"route\", route)\n# pop = initialPopulation(50, cityList)\n# # print(pop)\n# rankRoutes(pop)\n","789d1688":"geneticAlgorithm(population=cityList, popSize=50, eliteSize=10, mutationRate=0.01, generations=500)","74d9b994":"# def geneticAlgorithmPlot(population, popSize, eliteSize, mutationRate, generations):\n#     pop = initialPopulation(popSize, population)\n#     progress = []\n#     progress.append(1 \/ rankRoutes(pop)[0][1])\n    \n#     for i in range(0, generations):\n#         pop = nextGeneration(pop, eliteSize, mutationRate)\n#         progress.append(1 \/ rankRoutes(pop)[0][1])\n    \n#     plt.plot(progress)\n#     plt.ylabel('Distance')\n#     plt.xlabel('Generation')\n#     plt.show()","b6aaa4e5":"# geneticAlgorithmPlot(population=cityList, popSize=50, eliteSize=5, mutationRate=0.01, generations=100)","68293d52":"Run the function with our assumptions to see how distance has improved in each generation","f50f076d":"Create mating pool","990aeabd":"Create function to mutate a single route","8e9b1899":"## Create necessary classes and functions","a9704ea3":"Create a fitness function","2cffbbda":"## Create our initial population","1c37a86c":"Route generator","a6d1c777":"## Plot the progress","385cfa03":"Run the genetic algorithm","062902c8":"Rank individuals","13708103":"Create class to handle \"cities\"","79b656ff":"Create a selection function that will be used to make the list of parent routes","19a906ec":"Create function to run crossover over full mating pool","88fb6510":"Create function to run mutation over entire population","2fbb9c4e":"## Create the genetic algorithm","c14f1312":"Create a crossover function for two parents to create one child","91a690e4":"## Running the genetic algorithm","26a314bc":"Create first \"population\" (list of routes)","9cd84058":"Put all steps together to create the next generation","78d6ff4e":"Create list of cities","51184098":"Note, this will win run a separate GA","654030c1":"Final step: create the genetic algorithm"}}