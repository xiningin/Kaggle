{"cell_type":{"6f2e1526":"code","bf45f827":"code","5a5be8ab":"code","4a1f2fb1":"code","09f2483c":"code","b6e2285c":"code","1aa39b72":"code","4f740cca":"code","b3e1e035":"code","2044b499":"code","4b025246":"code","3b226876":"code","5881e115":"code","cc429f3f":"code","5836c318":"code","aba968ae":"code","bf5b340b":"code","6fa77211":"markdown","31d3b98a":"markdown","22a8ab9d":"markdown","45671fd9":"markdown","1f8f057b":"markdown","6a10dae7":"markdown"},"source":{"6f2e1526":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom PIL import Image\n%matplotlib inline","bf45f827":"df_train = pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv')\ndf_test = pd.read_csv('\/kaggle\/input\/digit-recognizer\/test.csv')\ndf_train.head()","5a5be8ab":"def get_image(row):\n    '''\n    This function takes a series as input and returns image and it's label\n    '''\n    \n    label = row['label']\n    image = row.drop('label').values\n    image = image.reshape(28, 28)\n    image = np.array(image, np.float32)\n        \n    image = image \/ 255.0\n    \n    return image, label","4a1f2fb1":"def show_images():\n    '''\n    This function is used to visualize the images \n    '''\n    plt.figure(figsize=(20, 20))\n    for i in range(25):\n        plt.subplot(5, 5, i+1)\n        index = np.random.randint(0, len(df_train))\n        image, label = get_image(df_train.iloc[index])\n        \n        plt.imshow(image)\n        plt.title('Label: {}'.format(label))\n        \n    plt.show()\n    \nshow_images()","09f2483c":"'''\nDefine Data generator class\n'''\nfrom tensorflow.keras.utils import Sequence\nclass DataGenerator(Sequence):\n    'Generates data for Keras'\n    def __init__(self, name, images, labels, batch_size=32, shuffle=True):\n        \n        \n        'Initialization'\n        self.name = name\n        self.batch_size = batch_size\n        self.images = images\n        self.labels = labels\n        self.shuffle = shuffle\n        self.on_epoch_end()\n\n    def __len__(self):\n        'Denotes the number of batches per epoch'\n        #print('returning length')\n        #print(int(np.floor(len(self.sentences) \/ self.batch_size)))\n        return int(np.floor(len(self.labels) \/ self.batch_size))\n\n    def __getitem__(self, index):\n        'Generate one batch of data'\n        # Generate indexes of the batch\n        #print(index)\n        indexes = self.indexes[index*self.batch_size:(index+1)*self.batch_size]\n\n        # Find list of IDs\n        images = [self.images[k] for k in indexes]\n        labels = [self.labels[k] for k in indexes]\n        \n        images = np.array(images)\n        labels = np.array(labels)\n        \n        return images, labels\n\n    def on_epoch_end(self):\n        'Updates indexes after each epoch'\n        self.indexes = np.arange(len(self.labels))\n        if self.shuffle == True:\n            np.random.shuffle(self.indexes)\n\n\n    def add_data(self, images, labels):\n        self.images=np.append(self.images, images, axis=0)\n        self.labels=np.append(self.labels, labels, axis=0)\n        self.on_epoch_end()","b6e2285c":"def generate_images(df, generator_name, batch_size=32):\n    \n    total_images = len(df)\n    num_batches = total_images \/\/ batch_size\n    batch_count = 0\n    while batch_count < num_batches:\n        x_batch = np.zeros((batch_size, 28, 28, 1))\n        label_batch = np.zeros((batch_size,))\n\n        for i in range(batch_size):\n            index = np.random.randint(0, total_images)\n            image, label = get_image(df.iloc[index])\n            image = image.reshape(28, 28, 1)\n\n            x_batch[i] = image \n            label_batch[i] = label\n            \n        if batch_count == 0:\n            generator = DataGenerator(generator_name, x_batch, label_batch)\n        else:\n            generator.add_data(x_batch, label_batch)\n            \n        batch_count += 1\n\n    return generator","1aa39b72":"# Defining training and validation generators\ndf_val = df_train.sample(4000)\ndf_train = df_train.sample(len(df_train)-4000)\n\ntrain_gen = generate_images(df_train, 'training_generator')\nval_gen = generate_images(df_val, 'validation generator')","4f740cca":"from tensorflow.keras.layers import Convolution2D, MaxPool2D, MaxPooling2D, LeakyReLU, Flatten, Dense, BatchNormalization, Dropout, Concatenate, Activation, Input, Add\nfrom tensorflow.keras.models import Model\nimport tensorflow as tf","b3e1e035":"input = Input(shape=(28, 28, 1), name='input')\n\nconv_1 = Convolution2D(32, 3, padding='same', activation='relu')(input)\nbatch_1 = BatchNormalization(name='batch_1')(conv_1)\nconv_2 = Convolution2D(32, 3, padding='same', activation='relu')(conv_1)\nbatch_2 = BatchNormalization(name='batch_2')(conv_2)\n\npool_1 = MaxPooling2D(pool_size=(2, 2))(batch_2)\ndrop_1 = Dropout(0.4)(pool_1)\n\nconv_3 = Convolution2D(64, 3, padding='same', activation='relu')(drop_1)\nbatch_3 = BatchNormalization(name='batch_3')(conv_3)\nconv_4 = Convolution2D(64, 3, padding='same', activation='relu')(conv_3)\nbatch_4 = BatchNormalization(name='batch_4')(conv_4)\ndrop_2 = Dropout(0.4)(batch_4)\n\nadd_1 = Concatenate()([pool_1, drop_2])\npool_2 = MaxPooling2D(pool_size=(2, 2))(add_1)\nbatch_5 = BatchNormalization(name='batch_5')(pool_2)\n\nconv_5 = Convolution2D(128, 3, padding='same', activation='relu')(pool_2)\nbatch_6 = BatchNormalization(name='batch_6')(conv_5)\n\nflat_2 = Flatten(name='flat_2')(batch_6)\ndense_1 = Dense(128, name='dense_1')(flat_2)\nact_1 = LeakyReLU()(dense_1)\ndrop_3 = Dropout(0.4)(act_1)\nlabel = Dense(10, activation='softmax', name='label')(drop_3)\n\nmodel = Model(inputs=input, outputs=label)\nmodel.compile(\n    loss='sparse_categorical_crossentropy',\n    metrics=['accuracy'],\n    optimizer='adam'\n)\n\nmodel.summary()","2044b499":"class Logger(tf.keras.callbacks.Callback):\n    def on_epoch_end(self, epoch, logs=None):\n        print() #just for spacing between two epochs stats","4b025246":"checkpoints = tf.keras.callbacks.ModelCheckpoint(\n    '.\/models\/checkpoint.h5',\n    monitor=\"val_loss\",\n    save_best_only=True,\n    verbose=1\n)","3b226876":"model.fit(train_gen, \n              validation_data=val_gen, \n              epochs=20,\n              callbacks=[Logger(), tf.keras.callbacks.TensorBoard(log_dir='.\/logs'), checkpoints],\n              verbose=1)","5881e115":"# model.save('.\/models\/digit_recognizer_skip.h5')\nmodel.load_weights('.\/models\/checkpoint.h5')\nmodel.summary()","cc429f3f":"df_test.head()","5836c318":"x_test = df_test.values\nx_test = x_test.reshape(28000, 28, 28, 1) \/ 255.0\nprint(x_test.shape)","aba968ae":"#Make predictions\npredictions = model.predict(x_test)\ny_pred = []\nfor pred in predictions:\n    y_pred.append(pred.argmax())\n    \nprint(len(y_pred))","bf5b340b":"submission = pd.read_csv('\/kaggle\/input\/digit-recognizer\/sample_submission.csv')\nsubmission['Label']=y_pred\nsubmission.to_csv('solution_3.csv', index=False)","6fa77211":"#### Load Data","31d3b98a":"#### Training ","22a8ab9d":"#### Define Model","45671fd9":"#### Test Data","1f8f057b":"#### Data preprocessing","6a10dae7":"#### Import Libraries"}}