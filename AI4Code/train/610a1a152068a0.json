{"cell_type":{"a3e5fb4c":"code","60fdd6c5":"code","ce563958":"code","20e00a25":"code","545a756b":"code","08fc1113":"code","286e2103":"code","d49bfa52":"code","84fcb10a":"code","dff38129":"code","da40ca2c":"code","46255976":"code","2bff8bab":"markdown","f43acf76":"markdown","6f182771":"markdown","4ab58d9d":"markdown","92ce3a70":"markdown","32ca902f":"markdown","c2f739e3":"markdown"},"source":{"a3e5fb4c":"!pip install EMD-signal\n#!pip install NBEATS\n!pip install nbeats_forecast\nimport pandas as pd \nimport numpy as np","60fdd6c5":"df = pd.read_csv(\"..\/input\/392-crypto-currency-pairs-at-minute-resolution\/antusd.csv\")","ce563958":"import matplotlib.pyplot as plt\nfrom PyEMD import EMD\n\nplt.plot(df.close)\nplt.title(\"Raw Data\")","20e00a25":"from nbeats_forecast import NBeats","545a756b":"df = df.close.values[20000:40000]","08fc1113":"i = 0\n\ntrain = df[:(19000+i*12)]\ntest = df[(19000+i*12):]\n\nIMF = EMD().emd(train)\nIMF = np.array(pd.DataFrame(IMF).transpose())\n\nHigh = np.sum(IMF[:,:3],axis=1)\nLow = np.sum(IMF[:,3:],axis=1)    ","286e2103":"plt.plot(train[-50:], label=\"Raw data\")\nplt.plot(Low[-50:], label=\"Denoised\")\nplt.legend(loc=\"upper left\")\nplt.title(\"Denoising by extracting first 3 IMFs\")","d49bfa52":"#model = NBeats(data=High.reshape(len(High),1), period_to_forecast=12)\n#model.fit()\n\nmodel2 = NBeats(data=Low.reshape(len(Low),1), period_to_forecast=12)\nmodel2.fit()","84fcb10a":"F1 = []\nF2 = []\nNaive = []\n\nfor i in range(5):\n    train = df[:(19000+i*12)]\n    test = df[(19000+i*12):]\n\n    IMF = EMD().emd(train)\n    IMF = np.array(pd.DataFrame(IMF).transpose())\n\n    High = np.sum(IMF[:,:3],axis=1)\n    Low = np.sum(IMF[:,3:],axis=1)\n\n    \n    \n #   forecast1 = model.predict(High[-36:].reshape([36,1]))\n    forecast2 = model2.predict(Low[-36:].reshape([36,1]))\n\n    #forecast1 = model.predict()\n    #forecast2 = model2.predict()\n    \n  #  forecast = forecast1 + forecast2\n\n\n   # F1.append( np.mean( (test[:12] - forecast[:,0])**2))\n    F2.append( np.mean( (test[11] - forecast2[11,0])**2))\n    Naive.append( np.mean( (test[11] - train[-1])**2) )\n    \n    plt.plot(test[:12], label=\"Real test data\")\n    plt.plot(forecast2[:,0], label=\"12 minute forecast\")\n    plt.legend(loc=\"upper left\")\n    plt.title(\"12 step (minute) out of sample forecast\")\n    plt.show()","dff38129":"print(\"12th minute MSE using NBEATS =\",np.round(np.mean(F2),5) )","da40ca2c":"print(\"12th minute MSE using Naive model =\",np.round(np.mean(Naive),5) )","46255976":"print(\"N-beats + EMD improvement, compared to Naive model for the 12th minute is\" ,np.round((np.round(np.mean(Naive),5) \/np.round(np.mean(F2),5))*100)-100,\"%\")","2bff8bab":"### The Mean Squared Error (MSE) show the improvement for the 12th minute forecast","f43acf76":"## Split the time series in 5, 12-minute intervals. Denoise the data in each iteration and forecast each interval","6f182771":"### It is evident that forecasting the trend can result in a reliable estimate of a 12-minute forecast ","4ab58d9d":"### The denoised data is derived by substracting the first 3 high frequency IMFs","92ce3a70":"## Neural Basis Expansion Analysis for Interpretable Time Series (N-BEATS) is a deep neural architecture based on backward and forward residual links and a very deep stack of fully-connected layers. This architecture will be used in forecasting low frequency signal","32ca902f":"## Empical mode decomposition is a way to decompose a signal into so-called intrinsic mode functions (IMF) along with a trend, and obtain instantaneous frequency data. It is designed to work well for data that is nonstationary and nonlinear\n","c2f739e3":"# Train the model"}}