{"cell_type":{"e5da6415":"code","1e0b8f86":"code","41b40759":"code","024c665f":"code","8a0f5c5d":"code","625aca00":"code","213866df":"code","abadc176":"code","b6e8a653":"code","29326bd1":"code","9eb00ec3":"code","329de166":"code","ceb1295e":"code","e55ce0e8":"code","8909cb3c":"code","3b80ec9d":"code","0f04de02":"code","e465b181":"code","a740e055":"code","d19f5424":"code","d241f655":"code","0a4bbce1":"code","4b80191e":"code","d4850366":"code","6de2ed51":"code","3bf75eb3":"code","ce319ff7":"code","8a5d686b":"code","d9e485c7":"code","53c9250a":"code","92176669":"code","03137733":"code","398c15d7":"code","206119b2":"code","71be7dd0":"code","24550a51":"code","b13207c3":"code","031889c9":"code","88021340":"code","32fb15ab":"code","7631a6f4":"code","0dcf1d85":"code","3975332b":"code","91040273":"code","c69a4027":"markdown","ead4b251":"markdown","1012db9b":"markdown","d54d7b69":"markdown","c5db6151":"markdown","86a5fc07":"markdown","fe55b2fa":"markdown","f166c6fe":"markdown","dc9404a1":"markdown","aba8ab45":"markdown","ca5b4807":"markdown","5be60c1a":"markdown","f3036621":"markdown","b879be24":"markdown","534ec489":"markdown","fc1fd174":"markdown","fd8acb75":"markdown","867d793d":"markdown","e00bce1f":"markdown","0efe8260":"markdown","730c1589":"markdown","10f1c4ac":"markdown","8b0351fa":"markdown","1f583353":"markdown","fc7ce4d5":"markdown","6abf6488":"markdown","6242ecc6":"markdown","46ebbf2b":"markdown","12fc46bb":"markdown","bdd853e1":"markdown","c95d83e0":"markdown"},"source":{"e5da6415":"from re import sub, search\nimport numpy as np\nimport pandas as pd\nimport os\nimport math\n\n''' Display List '''\n# display list neatly\n# https:\/\/stackoverflow.com\/questions\/1524126\/how-to-print-a-list-more-nicely\ndef lstcol(obj, cols=4, columnwise=True, gap=4):\n    sobj = [str(item) for item in obj]\n    if cols > len(sobj): cols = len(sobj)\n    max_len = max([len(item) for item in sobj])\n    if columnwise: cols = int(math.ceil(float(len(sobj)) \/ float(cols)))\n    plist = [sobj[i: i+cols] for i in range(0, len(sobj), cols)]\n    if columnwise:\n        if not len(plist[-1]) == cols:\n            plist[-1].extend(['']*(len(sobj) - len(plist[-1])))\n        plist = zip(*plist)\n    printer ='\\n'.join([\n        ''.join([c.ljust(max_len + gap) for c in p])\n        for p in plist])\n    print (printer)","1e0b8f86":"import numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom collections import Counter\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom re import finditer\n\n# Mapping Dictionary\ndef dic_map(map_id='codon',tid=None):\n\t\n\t# Codon \/ Amino Acid Conversion\n\tif(map_id is 'codon'):\n\t\ttc = {\n\t\t\t\"GCT\":\"A\", \"GCC\":\"A\", \"GCA\":\"A\",\"GCG\":\"A\",\n\t\t\t\"TGT\":\"C\", \"TGC\":\"C\",\"GAT\":\"D\",\"GAC\":\"D\",   \n\t\t\t\"GAA\":\"E\", \"GAG\":\"E\",\"TTT\":\"F\",\"TTC\":\"F\",   \n\t\t\t\"GGT\":\"G\", \"GGC\":\"G\",\"GGA\":\"G\",\"GGG\":\"G\",\n\t\t\t\"CAT\":\"H\", \"CAC\":\"H\",\"ATA\":\"I\",\"ATT\":\"I\", \"ATC\":\"I\",  \n\t\t\t\"AAA\":\"K\", \"AAG\":\"K\",\"TTA\":\"L\",\"TTG\":\"L\", \"CTT\":\"L\",  \n\t\t\t\"CTC\":\"L\", \"CTA\":\"L\",\"CTG\":\"L\",\n\t\t\t\"ATG\":\"M\", # starting codon\n\t\t\t\"AAT\":\"N\", \"AAC\":\"N\",\"CCT\":\"P\",\"CCC\":\"P\", \"CCA\":\"P\", \"CCG\":\"P\",\n\t\t\t\"CAA\":\"Q\", \"CAG\":\"Q\",\"CGT\":\"R\",\"CGC\":\"R\", \"CGA\":\"R\",\n\t\t\t\"CGG\":\"R\", \"AGA\":\"R\",\"AGG\":\"R\",\"TCT\":\"S\", \"TCC\":\"S\", \"TCA\":\"S\",\n\t\t\t\"TCG\":\"S\", \"AGT\":\"S\",\"AGC\":\"S\",\"ACT\":\"T\", \"ACC\":\"T\", \"ACA\":\"T\", \n\t\t\t\"ACG\":\"T\",\"GTT\":\"V\", \"GTC\":\"V\",\"GTA\":\"V\",\"GTG\":\"V\",\"TGG\":\"W\",\n\t\t\t\"TAT\":\"Y\", \"TAC\":\"Y\",\n\t\t\t\"TAA\":\"_\",\"TAG\":\"_\",\"TGA\":\"_\" # ending codon\n\t\t\t}\n\t\n\t# IUPAC Amino Acids\n\telif(map_id is 'iupac_amino'):\n\t\ttc   = {'A':'Alanine','C':'Cysteine','D':'Aspartic Acid',\n\t\t\t\t'E':'Glutamic Acid','F':'Phenylalanine','G':'Glycine',\n\t\t\t\t'H':'Histidine','I':'Isoleucine','L':'Lysine',\n\t\t\t\t'M':'Methionine','N':'Asparagine','P':'Proline',\n\t\t\t\t'Q':'Glutamine','R':'Arginine','S':'Serine',\n\t\t\t\t'T':'Threonine','V':'Valine','W':'Tryptophan',\n\t\t\t\t'Y':'Tryosine','_':'Gap'}\n\t   \n\t# IUPAC nuceotides\n\telif(map_id is 'iupac_nucleotide'):\n\t\ttc  = {'A':'Adenine','C':'Cytosine','G':'Guanine','T':'Thymine',\n\t\t\t   'U':'Uracil'}\n\t\n\tif tid in tc: \n\t  return tc[tid]\n\telse: \n\t  return None\n\n# Class for Sequence Operations \nclass SQ(): \n    \n    # Constructor\n    def __init__ (self, seq=None,  # Sequence String\n                        seq_type = \"dna\", # Sequence Type \n                        id=None, # Sequence Identifier\n                        name=None, # Sequene Name\n                        description=None):  # Sequence Description\n        \n        # Core SQ \n        self.seq = seq.upper()\n        self.seq_type = seq_type\n        \n        # If more detail is provided\n        self.id = id  # sequence identifier (eg. database id)\n        self.name = name   # name of sequence (eg. polyprotein)\n        self.description = description # give the sequence some description\n        self.annotations = {} # Annotate some parts of the seqence\n        \n    @staticmethod\n    def dict_sum(dictlist):\n        outdic = {}\n        for d in dictlist:\n            for k in d.keys():\n                outdic[k] = 0\n        for d in dictlist:\n            for k in d.keys():\n                outdic[k]+=d[k]\n        return outdic\n    \n    # class instance operations\n    def __len__(self):\n        return len(self.seq)\n    def __getitem__(self, n):\n        return self.seq[n]\n    def __getslice__(self, i, j):\n        return self.seq[i:j]\n    def __str__(self):\n        return self.seq\n    def __add__(self,other):\n        if(self.seq_type == other.seq_type):\n            return SQ(self.seq + other.seq,seq_type=self.seq_type)\n        else:\n            print('sequences must of be same type')\n            \n    #####################################################\n            \n    # General Methods\n    # info - show sequence information\n    # abc - show sequence base alphabet\n    # validate - check if the sequence contains no errors\n            \n    #####################################################\n    @staticmethod\n    def colored(lseq):\n        \n        bcolors = {'A': '\\033[92m','C': '\\033[94m','G':'\\033[93m',\n            'T': '\\033[91m','U': '\\033[91m','reset': '\\033[0;0m'}\n        tmpStr = \"\"\n        for nuc in lseq:\n            if nuc in bcolors:\n                tmpStr += bcolors[nuc] + nuc\n            else:\n                tmpStr += bcolors['reset'] + nuc\n        return tmpStr + '\\033[0;0m'\n    \n    def info(self):\n        if(self.seq_type is 'dna' or self.seq_type is 'rna'):\n            print (f\"SEQ: {self.colored(self.seq)}\" + \\\n                   \" \"+ f\"TYPE: {self.seq_type}\")\n        else:\n            print (f\"SEQ: {self.seq}\" +\" \" + \\\n                   f\"TYPE: {self.seq_type}\")\n            \n    # Get ABC\n    def abc(self):\n        if(self.seq_type==\"dna\"): \n          return \"ACGT\"\n        elif(self.seq_type==\"rna\"):\n          return \"ACGU\"\n        elif (self.seq_type==\"aa\"): \n          return \"ACDEFGHIKLMNPQRSTVWY\"\n        else: \n          return None\n        \n    # Check Validity\n    def validate(self,verbose=False):\n        alp = self.abc()\n        res = True; i = 0\n        while (res and i < len(self.seq)):\n            if self.seq[i] not in alp: \n                res = False\n            else: i += 1\n        if(res):\n            if(verbose):\n                print(f'{self.seq_type} is valid')\n            return res\n        else:\n            if(verbose):\n                print(f'{self.seq_type} is invalid')\n            return res\n        \n    #####################################################\n        \n    # Counting\n    # freq - count bases in sequence\n    # count_purines - count purines & pyrimidines\n    # groupfreq - count grouped bases\n        \n    #####################################################\n        \n    # Frequency of Symbols \n    def freq(self,compare=None, # list of comparing sequences\n                  show_id='perc', # perc\/count\n                  fsize=[None,None],\n                  title=None,\n                  barmode='group'): \n        \n        c1 = dict(Counter(self.seq))  # abc counter for s1\n        abc = list(self.abc())\n        count = Counter(abc)\n        abc_c = dict(Counter({x:0 for x in count}))\n        c_all1 = self.dict_sum([c1,abc_c])\n            \n        lst = []\n        for i in c_all1.keys():\n           if(self.seq_type == 'dna' or self.seq_type == 'rna'):\n               lst.append(dic_map('iupac_nucleotide',i))\n           elif(self.seq_type == 'aa'):\n               lst.append(dic_map('iupac_amino',i))\n                    \n        perc = [round(x\/len(self.seq),3)*100 for x in [*c_all1.values()]]\n        if(show_id is 'perc'):\n            show1 = lst; show2 = perc;\n            xaxis_id = 'Character (%)'\n        elif(show_id is 'count'):\n            show1 = lst; show2 = [*c_all1.values()]\n            xaxis_id = 'Count'\n            \n        if(self.id is not None):\n            lname = self.id\n        else:\n            lname = 'main sequence'\n        fig = go.Figure(go.Bar(y=show1,x=show2,\n                               marker_color='rgb(55, 83, 109)',\n                               orientation='h',name=lname))\n        \n        # Compare other sequences\n        if(compare is not None):\n            \n            ii=-1\n            for lseq in compare:\n                \n                ii+=1;\n                c2 = dict(Counter(lseq.seq))  # abc counter for s2\n                c_all2 = self.dict_sum([c2,abc_c])    \n            \n                lst2 = []\n                for i in c_all2.keys():\n                   if(self.seq_type == 'dna' or self.seq_type == 'rna'):\n                       lst2.append(dic_map('iupac_nucleotide',i))\n                   elif(self.seq_type == 'aa'):\n                       lst2.append(dic_map('iupac_amino',i))\n                \n                perc = [round(x\/len(lseq.seq),3)*100 for x in [*c_all2.values()]]\n                if(show_id is 'perc'):\n                    show1 = lst2;show2 = perc\n                elif(show_id is 'count'):\n                    show1 = lst2; show2 = [*c_all2.values()]\n                \n                if(lseq.id is not None):\n                    lname = lseq.id\n                else:\n                    lname = f'seq{ii}'\n                    \n                fig.add_trace(go.Bar(y=show1,x=show2,\n                                     orientation='h',name=lname))\n        if(title is None):\n            title = f'<b>{self.seq_type.upper()} SEQUENCE CONTENT<\/b>'\n        else:\n            title = title\n            \n        fig.update_layout(template='plotly_white',\n                          barmode=barmode, # stack,group,overlay,relative\n                          height=fsize[0],\n                          width=fsize[1],\n                          bargroupgap=0.2, # gap between bars of the same location coordinate.\n                          font=dict(family='sans-serif',size=12),\n                          title=title)\n        fig.update_layout(margin=dict(t=60,b=5));\n        fig.update_xaxes(nticks=20,title_text=xaxis_id);fig.show()\n            \n    # Count frequency of grouped nucleotides\n    def groupfreq(self,compare=None,count_id='di',\n                  fsize=[None,None],barmode='group'):\n        \n        if(count_id is 'di'):\n            lst_count_id = ['AA','AC','AG','AT',\n                            'CA','CC','CG','CT',\n                            'GA','GC','GG','GT',\n                            'TA','TC','TG','TT']\n            \n        elif(count_id is 'tri'):\n            lst_count_id = ['AAA','AAC','AAG','AAT','ACA','ACC','ACG',\n                            'ACT','AGA','AGC','AGG','AGT','ATA','ATC',\n                            'ATG','ATT','CAA','CAC','CAG','CAT','CCA',\n                            'CCC','CCG','CCT','CGA','CGC','CGG','CGT',\n                            'CTA','CTC','CTG','CTT','GAA','GAC','GAG',\n                            'GAT','GCA','GCC','GCG','GCT','GGA','GGC',\n                            'GGG','GGT','GTA','GTC','GTG','GTT','TAA',\n                            'TAC','TAG','TAT','TCA','TCC','TCG','TCT',\n                            'TGA','TGC','TGG','TGT','TTA','TTC','TTG',\n                            'TTT']\n            \n        if(self.seq_type is 'dna'):\n            \n            lst_c = []\n            for i in lst_count_id:\n                lst_c.append(self.seq.count(i))\n                \n            df = pd.DataFrame(data=lst_c,\n                              index=lst_count_id).T\n            df.index = ['main']\n            \n            if(compare is not None):\n                \n                ii=-1\n                for seq in compare: # cycle through all SQ\n                \n                    ii+=1;lst_c = []\n                    for jj in lst_count_id:\n                        lst_c.append(compare[ii].seq.count(jj))\n                        \n                    ldf = pd.DataFrame(data=lst_c,\n                                       index=lst_count_id).T\n                    ldf.index = [f'sequence{ii}']\n                    df = pd.concat([df,ldf],axis=0)\n            \n            if(count_id is 'tri'):\n                xaxis=dict(rangeslider=dict(visible=True))\n            else:\n                xaxis = None\n                \n            # Plot\n            fig = px.bar(df.T,x=df.T.index,y=df.T.columns)\n            fig.update_layout(template='plotly_white',\n                              barmode=barmode,\n                              title=f'{count_id}nucleotide | count'.upper(),\n                              font=dict(family='sans-serif',size=12),\n#                               margin=dict(l=20, r=20, t=80, b=20),\n                              xaxis=xaxis,\n                              height=fsize[0],width=fsize[1]); fig.show()\n        else:\n            print('input must be dna type')\n            \n    # Return purines & pyrimidines (%)\n    def purines(self):\n        \n        if (self.seq_type == \"dna\" or self.seq_type == \"rna\"):        \n        \n            dic_count = {}\n            purines1 = self.seq.count(\"A\") + self.seq.count(\"G\")\n            pyrimidines1 = self.seq.count(\"C\") + self.seq.count(\"T\")\n            purines1 = purines1\/len(self.seq)\n            pyrimidines1 = pyrimidines1\/len(self.seq)\n            dic_count['purines'] = round(purines1,4)\n            dic_count['pyrimidine'] = round(pyrimidines1,4)\n            return dic_count\n    \n    # Return GC nucleotide (%)\n    def gc(self):\n        \n        if (self.seq_type == \"dna\" or self.seq_type == \"rna\"):\n            ii = 0\n            for s in self.seq:\n                if(s in \"GC\"):\n                    ii += 1\n\n            val = round(ii \/ len(self.seq),4)\n            return val\n        \n    #####################################################\n        \n    # Complementary DNA Strands\n    # reverse_comp - reverse complement strand of input DNA\n        \n    #####################################################\n        \n    # Reverse Complement\n    def reverse_comp(self):\n        \n        if (self.seq_type != \"dna\"): \n            print('input not DNA')\n            return None\n        \n        lst_seq = ['A','T','G','C']\n        lst_comp = ['T','A','C','G']\n        \n        comp = ''\n        for char in self.seq:\n            ii=-1\n            for c in lst_seq:\n                ii+=1\n                if(char == c ):\n                    comp = lst_comp[ii] + comp\n                    \n        return SQ(comp,\"dna\")\n    \n    #####################################################\n    \n    # Decoding of instructions for making proteins from DNA\n    # transcription (DNA -> RNA)\n    # get_protein (RNA -> AA chains containing proteins)\n    \n    #####################################################\n    \n    # Transcription \n    def transcription(self):\n        if (self.seq_type == \"dna\"):\n            return SQ(self.seq.replace(\"T\",\"U\"), \"rna\")\n        else:\n            return None\n        \n    # Translate \n    @staticmethod\n    def translate(seq,p0=0):\n        seq_aa = \"\"\n        for pos in range(p0,len(seq)-2,3):\n            cod = seq[pos:pos+3]\n            seq_aa += dic_map(map_id='codon',tid=cod)\n        return seq_aa\n    \n    '''Get All Possible open reading frames (ORF)'''\n    # store all possible collections of amino acid \n    # groups in all 6 frames\n    def frames(self):\n        res = []\n        for i in range(0,3):\n            res.append(self.translate(self.seq,i))\n        rc = self.reverse_comp()\n        for i in range(0,3):\n            res.append(self.translate(rc,i)) \n        return res\n    \n    ''' Computes all possible proteins in an aa sequence in RF '''\n    # using the knowledge that it starts with M and ends with _, \n    # filter out rule breaking ORFs\n    # aa_seq -> full converted amino acid sequence\n    \n    @staticmethod\n    def all_proteins_RF(aa_seq):\n        \n        current_prot = []\n        proteins = []\n        for aa in aa_seq:\n            \n            # stopping gap\n            if(aa == \"_\"):\n                if(current_prot):\n                    for p in current_prot:\n                        proteins.append(p)\n                    current_prot = []\n                    \n            # not stopping gap\n            else:\n                \n                # starting amino acid\n                if(aa == \"M\"):\n                    current_prot.append(\"\")\n                for i in range(len(current_prot)):\n                    current_prot[i] += aa\n                    \n        return proteins\n    \n    '''Computes all possible putative proteins for all ORF'''\n    # and sort them based on size\n    def get_protein(self,min_size=0):\n        \n        # order \n        def insert_prot_ord (prot, lst_prot):\n            i = 0\n            while(i < len(lst_prot) and len(prot)<len(lst_prot[i])):\n                i += 1\n            lst_prot.insert(i, prot)\n            \n        rfs = self.frames()  # get all ORF conversions\n        res = []\n        for rf in rfs:\n            # return only protein cases\n            prots = self.all_proteins_RF(rf) \n            # additionally sort based on protein size\n            for p in prots: \n                if(len(p) > min_size): \n                    insert_prot_ord(p, res)\n        return res\n    \n    #####################################################\n    \n    # Finding Patterns in Sequence\n    # find_pattern - find index(ies) of particular pattern \n    \n    #####################################################\n    \n    # Prosite Pattern Lines\n    # - Standard IUPAC amino acid used to as bases in pattern, separated by -\n    # - x -> any amino acid acceptable\n    # - [] -> ambiguity represented by list, any aa in that list acceptable\n    # - {} -> ambiguity represented by list, any aa other than in {} accepted\n    # - repetition of pattern element shown below:\n    #   x(3) -> x-x-x, x(2,4) -> to x-x or x-x-x or x-x-x-x\n    \n    @staticmethod\n    def prosite_process(rex):\n        # adjust prosite to RE format\n        rex = rex.replace(\"(\",\"{\")\n        rex = rex.replace(\")\",\"}\")\n        rex = rex.replace(\"x\",\".\")\n        rex = rex.replace(\"-\",\"\")\n        return rex\n    \n    def find_pattern(self,pattern,  #  sequence of interest\n                          find_id='first', # first,all,overlap\n                          search_id=None,\n                          verbose=True): # None,prosite\n        \n        if(find_id is 'first'):\n            \n            if(search_id is 'prosite'):\n                pattern = self.prosite_process(pattern)\n                \n            # General search as well\n            re_search = search(pattern,self.seq)\n            if (re_search != None):\n                if(verbose):\n                    print(f\"showing first for {pattern}\")\n                result = re_search.span()[0]\n                return result\n            else:\n                if(verbose):\n                    print(f'no matches for {pattern} found')\n                \n        elif(find_id is 'all'):\n            \n            if(search_id is 'prosite'):\n                pattern = self.prosite_process(pattern)\n                \n            re_search = finditer(pattern,self.seq)\n            result = []\n            for x in re_search:\n                result.append(x.span()[0])\n                \n            if(len(result) is not 0):\n                if(verbose):\n                    print(f\"found {len(result)} matches\")\n                return result\n            else:\n                if(verbose):\n                    print(f'no matches for {pattern} found')\n                \n        elif(find_id is 'overlap'):\n            \n            if(search_id is 'prosite'):\n                pattern = self.prosite_process(pattern)\n            mos = finditer(\"(?=\"+pattern+\")\",self.seq)\n            result = []\n            for x in mos:\n                result.append(x.span()[0])\n                \n            if(len(result) is not 0):\n                if(verbose):\n                    print(f\"found {len(result)} matches\")\n                return result\n            else:\n                if(verbose):\n                    print(f'no matches for {pattern} found')\n        else:\n            print('first,all,overlap options')\n            \n    #####################################################\n            \n    # Cutting the Sequence\n    # cut_pattern - cut sequence based on particular pattern\n            \n    #####################################################\n            \n    # converts IUB ambiguity code into RE\n    # returns cut position of a restriction enzyme \n    # (in IUB code) in a sequence\n            \n    @staticmethod\n    def divide_loc(enzyme, sequence):\n        \n        def iubrex(IUB):   \n            \n            # main 4 bases\n            # purine, pyrimidine, amino\n            # keto, strong, weak\n            # not A, not C, not G, not T\n            #  not T, any \n            \n            dic = {\"A\":\"A\", \"C\":\"C\", \"G\":\"G\", \"T\":\"T\", \n                    # Additional Cases\n                    \"R\":\"[GA]\", \"Y\":\"[CT]\", \"M\":\"[AC]\", \n                    \"K\":\"[GT]\", \"S\":\"[GC]\", \"W\": \"[AT]\",\n                    \"B\":\"[CGT]\", \"D\":\"[AGT]\", \"H\":\"[ACT]\",\n                    \"V\":\"[ACG]\", \"N\":\"[ACGT]\"}\n            \n            site = IUB.replace(\"|\",\"\")\n            rex = \"\"\n            \n            for c in site:\n                rex += dic[c]\n            return rex\n        \n        regexp = iubrex(enzyme) # convert pattern to IUB format\n        matches = finditer(regexp, sequence)\n        locs = []\n        for match in matches:\n            locs.append(match.start() + enzyme.find(\"|\"))\n            \n        return locs # indicies of cuts\n    \n    # determines subsequences resulting from a sequence \n    # cut in a list of positions\n    def cut_pattern(self,cut_pattern):\n        \n        res = []\n        positions = self.divide_loc(cut_pattern,self.seq)\n        positions.insert(0,0)\n        positions.append(len(self.seq))\n        for i in range(len(positions)-1):\n            res.append(self.seq[positions[i]:positions[i+1]])\n        return res\n    \n    # Function for when you want to prepare DNA sequence \n    # feature for ML applications\n    def dnaseq_features(self,start=0,n_segs=101,seq_name=None):\n        \n        print(f\"Input Sequence Length: {len(self.seq)}\")\n        remaind = len(self.seq)%n_segs\n        if(remaind is not 0):\n            last_id = len(self.seq) - remaind\n        print(f\"# Bases cut-off: {int(remaind)}\")\n        \n        upd_seq = self.seq[start:last_id]\n        \n        print(f\"Updated sequence length: {len(upd_seq)}\")\n        print(f\"# Segments: {int(len(upd_seq)\/n_segs)} created\")\n        if(seq_name is None):\n            seq_name = 'seq'\n            \n        # store sequence subsets in a dictionary\n        dic_seq = {}\n        for i in range(0,3):\n            a = int(i*n_segs) ; b = int(i*n_segs)+n_segs \n            identifier = f\"{seq_name}_{a}:{b}\"\n            dic_seq[identifier] = upd_seq[a:b]\n            \n        lst_seq = dic_seq.values()\n        index = list(dic_seq.keys())\n        \n        # One hot encode\n        \n        ii=-1\n        for data in lst_seq:\n            \n            ii+=1; abc = 'acgt'.upper()\n            \n            char_to_int = dict((c, i) for i, c in enumerate(abc))\n            int_enc = [char_to_int[char] for char in data]\n            \n            ohe = []\n            for value in int_enc:\n                base = [0 for _ in range(len(abc))]\n                base[value] = 1\n                ohe.append(base)\n            np_mat = np.array(ohe)\n            np_mat = np.expand_dims(np_mat,axis=0)\n            \n            if(ii is not 0):\n                matrix = np.concatenate([np_mat,matrix],axis=0)\n            else:\n                matrix = np_mat\n                \n        return matrix,index\n    \n    #####################################################\n            \n    # Annotating Sequence, Notes\n    # add_annotation - add_annotation\n            \n    #####################################################\n    \n    # method to add annotation to the current detailed sequence\n    def add_annotation(self,inSQ):\n        lseq = inSQ \n        lid = inSQ.id\n        ldesc = inSQ.description\n        idx = self.find_pattern(pattern=str(lseq),\n                                   find_id='all',                                            \n                                   search_id='standard',\n                                   verbose=False)\n        for i in idx:\n            ln = len(lseq)\n            self.annotations[f'sq_{i}:{i+ln}'] = f\"{lid}_{ldesc}\"","41b40759":"# Define sequences in string format\nseqn = 'ATGACGGATCAGCCGCAAGCGGAATTGGCGTTTACGTACGATGCGCCGTAA'\nseqaa = 'MMMELQHQRLMALAGQLQLESLISAAPALSQQAVDQEWSYMDFLEHLLHDFTF'\n\n# Define Two DNA sequences (instances)\nsq_n = SQ(seqn,'dna')\n# define new protein sequence \nsq_aa = SQ(seqaa,'aa')\n\n# Show class variables\nsq_n.info()\nsq_aa.info()","024c665f":"print(f'sequence: {sq_aa.seq} is valid: {sq_aa.validate()}')","8a0f5c5d":"rev_comp = sq_n.reverse_comp()\nrev_comp.info()","625aca00":"# Defining some extra detail\nseq_det = SQ(seq='ACTTTTGACCTCAA',\n            id='sequence',\n            description='mysequence')\n\n# When required, we can call the SQ object by using .seq\nprint(f'Extracting SQ when needed: {seq_det.seq}')","213866df":"print(f'Sequence ID: {seq_det.id}') # used for alignment naming etc\nprint(f'Sequence Annotations for subsequence labeling: {seq_det.annotations}')\nprint(f'A note describing the sequence: {seq_det.description}')","abadc176":"subsequence1 = SQ('TTTT',id='db|1',description='subseq') \nsubsequence2 = SQ('CCTCA',id='db|2',description='subseq')","b6e8a653":"seq_det.add_annotation(subsequence1)\nseq_det.add_annotation(subsequence2)","29326bd1":"seq_det.annotations","9eb00ec3":"# compare content percentage (default)\n# sequences w\/o id are set to default names\nsq_n_compare = SQ('ACTCCCTGAGGATCATGC',id='sequence A')\nsq_n_compare2 = SQ('ACATACATAACACATCC')\n\n# Compare the nucleotide % of three sequences\nsq_n.freq(compare=[sq_n_compare,sq_n_compare2], # list of sequences\n          fsize=[350,None],\n          title='Comparing Nucleotide Content (%)')","329de166":"# show the amino acid content of the protein\nsq_aa.freq(show_id='count', \n           fsize=[500,None])","ceb1295e":"# Define Two DNA sequences (instances)\nsq_1 = SQ('ATGACGGATCAGCCGCAAGCGGAATTGGCGCACATTTACGTACGATGCGCCGTAA','dna')\nsq_2 = SQ('ATGACGGATCAGCCGCAAGCGGAATTGGCGTTTACGTACGAAGAGACACCCGTAA','dna')\nsq_3 = SQ('ATTTAATCATTGCCGTTATCGGAATTGGCGTTTACGTACGAAGAGACACCCGTAA','dna')\n\n# Compare Trinucleotides of two sequences\nsq_1.groupfreq(compare=[sq_2,sq_3],\n               count_id='tri',\n               barmode = 'group', # group,stack\n               fsize=[300,None])","e55ce0e8":"## Compare Dinucleotides of two sequences\nsq_n.groupfreq(compare=[sq_1,sq_2,sq_3],\n               count_id='di',\n               barmode = 'stack', # group,stack\n               fsize=[400,None])","8909cb3c":"round(sq_n.gc(),3)","3b80ec9d":"sq_n.purines()","0f04de02":"rna_seq = sq_n.transcription()\nrna_seq.info()","e465b181":"''' Don't actually have to call (just for demonstration) '''\n\n# Sequence with initial codon coinciding with start codon &\n# end w\/ end codon (ATG & TAA respectively)\nseq = 'ATGACGGATCAGCCGCAAGCGGAATTGGCGTTTACGTACGATGCGCCGTAA'\nstrand = SQ(seq=seq,seq_type='dna')\nprint(f'Correct ORF: {strand.translate(strand.seq,p0=0)}')\n\nprint(f'All ORF:')\nlst_ORF = strand.frames()\nlstcol(lst_ORF)","a740e055":"# Only one of the ORFs meets the requirement, so only one putative protein is found\nproteins = strand.get_protein()\nprint(proteins)\nprint(f'{len(proteins[0])} characters')","d19f5424":"# NCBI identifiers\nidentifiers_dic = {'lcl':'local(nodb)','bbs':'GenInfo backbone seqid',\n                   'bbm':'GenInfo backbone moltype','gim':'GenInfo import ID',\n                   'gb':'GenBank','emb':'EMBL','pir':'PIR','sp':'SWISS-PROT',\n                   'pat':'patent','pgp':'pre-grant patent','ref':'RefSeq',\n                   'gnl':'general database reference','prf':'PRF','pdb':'PDB',\n                   'gi':'GenInfo integrated database','dbj':'DDBJ'}\n\n# FASTA formats\nFASTA_dic = {'fa':'generic','fasta':'generic','fna':'nucleic acid',\n             'ffn':'nucleotide of gene regions','faa':'amino acid',\n             'frn':'non-coding RNA'}\n\n# Class to read different files and store info only\nclass read_seq(SQ):\n    \n    def __init__(self,name):\n        self.name = name\n        self.format = name.rsplit('.',1)[1]    \n        if(self.format in FASTA_dic):      # if one of the fasta formats\n            self.read_FASTA(self.name)\n\n    # read FASTA format\n    def read_FASTA(self,filename):\n\n        tseq = None; self.lst_seq = []     # list of sequences\n        thead = None; self.lst_header = [] # list of sequence identifications\n        ff = FASTA_dic[filename.rsplit('.',1)[1]]\n        file = open(filename,'r')\n\n        for line in file:\n            if(search(\">.*\", line)): # get lines w\/ >\n                    if(tseq != None and thead != None and tseq != \"\"):\n                        self.lst_seq.append(tseq)\n                    thead = line; self.lst_header.append(line)              \n                    tseq = \"\"\n            else:\n                if(tseq == None):\n                    return None\n                else: \n                    tseq += sub(\"\\s\",\"\",line)\n\n        if(tseq != None and thead != None and tseq != \"\"):\n            self.lst_seq.append(tseq)\n            \n        print(f'READ -> FASTA [{ff}] | #SEQ: {len(self.lst_seq)}')\n        file.close()\n        \n    # get read sequences\n    def get_sq(self):\n        lst_out = []\n        \n        # If there's more than one sequence\n        if(len(self.lst_seq) > 1):\n            for i in range(0,len(self.lst_seq)):\n                lst_types = ['dna','rna','aa']\n                for check in lst_types:\n                    if(SQ(seq=self.lst_seq[i],seq_type=check).validate()):\n                        lst_out.append(SQ(self.lst_seq[i],seq_type=check,\n                                          description=self.lst_header[i]))\n            return lst_out\n        \n        # return just the one file\n        else:\n            lst_types = ['dna','rna','aa']\n            for check in lst_types:\n                if(SQ(self.lst_seq[0],check).validate()): # if valid sq\n                    return SQ(seq=self.lst_seq[0],seq_type=check,\n                              description=self.lst_header[0])","d241f655":"# define pathway to FASTA file\nfile_faa = '\/kaggle\/input\/bioinformatics\/sequences\/NC_005816.faa' # amino acid chain sequence\nfile_fna = '\/kaggle\/input\/bioinformatics\/sequences\/NC_005816.fna' # nucleotide sequence \n\n# fetch sequence from file and store each in sequence class, SQ\ncol_seq_aa = read_seq(file_faa).get_sq()\ncol_seq_n = read_seq(file_fna).get_sq()","0a4bbce1":"col_seq_aa[0].description","4b80191e":"col_seq_aa[1].info()","d4850366":"print(f'Number of Sequences stored: {len(col_seq_aa)}'); \nprint(f'List of Sequences Type: {type(col_seq_aa)}')\nprint(f'List Content Type: {type(col_seq_aa[0])}')\nprint(f'Single Fetched Sequence Type: {type(col_seq_n)}') # seqrec objects","6de2ed51":"# Select only a subset as the strand is a little too big (arbitrarily selected)\nprint('Create subsequence:\\n')\nsubseq_string = col_seq_n.seq[100:500]\ncol_seq_subset = SQ(seq=subseq_string,\n                    seq_type=col_seq_n.seq_type)\ncol_seq_subset.info()\n\nprint('\\nDecode DNA: \\n')\n# get all proteins with a length of more than 1\nproteins = col_seq_subset.get_protein()\n\n# # list all found proteins above a length of 2 \nprint('Proteins in Sequence col_seq_subset:')\nlstcol(proteins,2)","3bf75eb3":"file_fasta = '\/kaggle\/input\/bioinformatics\/sequences\/P38398.fasta'\naa_seq = read_seq(file_fasta).get_sq()","ce319ff7":"aa_seq.description","8a5d686b":"aa_seq.seq","d9e485c7":"# find_id -> 'first' (find the first match index)\n# find id -> 'all' (find all non overlapping indicies)\n# find_id -> 'overlap' (find all overlapping indicies)\n\naa_seq.find_pattern(pattern='C-x-H-x-[LIVMFY]-C-x(2)-C-[LIVMYA]',\n                    find_id='first',                                            \n                    search_id='prosite')","53c9250a":"aa_seq.find_pattern(pattern='EES',\n                    find_id='all',                                            \n                    search_id='standard')","92176669":"# Arbitrary cut pattern\nn_seq = SQ('AAGATTCGAGCATGCAAACCGGATACA',seq_type='dna')\nn_seq.cut_pattern('AGC|AT')","03137733":"seqn = SQ('ATGACGGATCAGCCGCAAGCGGAATTGGCGTTTACGTACGATGCGCCGTAA',seq_type='dna')\nfeatures, index = seqn.dnaseq_features(0,10,'dna_features')\nfeatures","398c15d7":"index","206119b2":"from Bio.Blast import NCBIXML \nfrom Bio.Blast import NCBIWWW \nfrom Bio.Seq import Seq\nfrom Bio import SeqIO\nimport re\nimport pandas as pd\n\n# Search NCBI for a sequence \ndef blast_aav1(seq,database,verbose=False,n_top=5):\n    \n    if(type(seq) is str):\n        seq = Seq(seq)\n    \n    res_handle = NCBIWWW.qblast(\"blastp\",database,seq)\n    sf = open(\"\/kaggle\/working\/temp_blast.xml\", \"w\")\n    sf.write(res_handle.read()) \n    sf.close() \n    res_handle.close()\n    res_handle = open(\"\/kaggle\/working\/temp_blast.xml\")\n    record = NCBIXML.read(res_handle)\n\n    print (f\"SEARCHING DATABASE: {record.database}\")\n    print (f\"SUBSTITUTION MATRIX USED in PSA: {record.matrix}\")\n    print (f'GAP PENALTY IN PSA: {record.gap_penalties}')\n\n    print (f\"TOT # OF HITS: {len(record.alignments)}\")\n    first_alignment = record.alignments[0]\n    hsp = first_alignment.hsps[0]\n\n    if(verbose):\n        print(f\"\\nFIRST HIT #1:\")\n        print('--------------------------------------------------------')\n        print (f\"ID: {first_alignment.hit_id}\")\n        print (f\"ACCESSION: {first_alignment.accession}\")\n        print (f\"DEFINITION: {first_alignment.hit_def}\")\n        print (f\"ALI LENGTH: {first_alignment.length}\")\n        print (f\"HSP NUMBER: {len(first_alignment.hsps)}\")\n\n        print (f\"e-VALUE: \", hsp.expect)\n        print (f\"SCORE: {hsp.score}\")\n        print (f\"LENGTH: {hsp.align_length}\")\n        print (f\"IDENTITIES: {hsp.identities}\")\n        print (\"ALI OF HSPS:\")\n        print (f'QUERY: {hsp.query}')\n        print (f'MATCH: {hsp.match}')\n        print (f'SUBJE: {hsp.sbjct}')\n        print('--------------------------------------------------------\\n')\n        print(\"TOP 5 ALIGNMENTS:\")\n        print('--------------------------------------------------------\\n')\n    \n    lst_hit = []; lst_access = []; lst_alilen = [];\n    lst_hsps = []; lst_eval = []; lst_score = [];\n    lst_len = []; lst_ident = []; lst_def = [];\n    lst_quer = []; lst_mat = []; lst_sub = []\n    \n    # store data for alignment\n    for i in range(n_top):\n\n        loc_al = record.alignments[i]\n        hsp = loc_al.hsps[0] # store only first (can be multi)\n        \n        lst_hit.append(loc_al.hit_id)\n        lst_access.append(loc_al.accession)\n        lst_def.append(loc_al.hit_def)\n        lst_alilen.append(loc_al.length)\n        lst_hsps.append(len(loc_al.hsps))\n\n        lst_eval.append(hsp.expect)\n        lst_score.append(hsp.score)\n        lst_len.append(hsp.align_length)\n        lst_ident.append(hsp.identities)\n\n        lst_quer.append(hsp.query)\n        lst_mat.append(hsp.match)\n        lst_sub.append(hsp.sbjct)\n\n        if(verbose):\n            print (f\"ACCESSION: {loc_al.accession}\")\n            print (f\"DEFINITION: {loc_al.hit_def}\")\n            for hsp in alignment.hsps:\n                print (f\"e-VALUE: {hsp.expect}\")\n\n    dic_data = \\\n    {\"ID\":lst_hit,\"ACCESSION\":lst_access,\"DEFINITION\":lst_def,\n     \"ALI LENGTH\":lst_alilen,\"HSP NUMER\":lst_hsps,\"e-VALUE\":lst_eval,\n     \"SCORE\":lst_score,\"LENGTH\":lst_len,\"IDENTITIES\":lst_ident,\n     \"SEQ-QUERY\":lst_quer,\"SEQ-MATCH\":lst_mat,\"SEQ-SUBJECT\":lst_sub,\n    };df_data = pd.DataFrame(dic_data)\n                \n    lst_org = []\n    for i in range(n_top):\n        ali = record.alignments[i]\n        defin = ali.hit_def\n        x = re.search(\"\\[(.*?)\\]\", defin).group(1)\n        lst_org.append(x)\n        \n        if(verbose):\n            print (\"ORGANISMS:\")\n            print('--------------------------------------------------------\\n')\n            for s in lst_orgs: \n                print(s)\n            \n    return df_data","71be7dd0":"from Bio import SeqIO, SearchIO\nfrom Bio.Blast import NCBIWWW \nfrom Bio.Seq import Seq\nimport pandas as pd\nimport panel as pn\nimport panel.widgets as pnw\npn.extension()\nfrom bokeh.plotting import figure\nfrom bokeh.models import ColumnDataSource, Plot, Grid, Range1d\nfrom bokeh.models.glyphs import Text, Rect\nfrom bokeh.layouts import gridplot\nfrom bokeh.transform import dodge\nimport bokeh\n\n# Class to access BioPython's blastwww & plot alignments \nclass BLASTwww:\n    \n    def __init__(self,seq=None,database='pdb',verbose=False,\n                 show_top=10,hit_id=0,read_xml=None,name=None):\n        self.seq = seq \n        self.database = database\n        self.verbose = verbose\n        self.show_top = show_top\n        self.hit_id = hit_id\n        self.read_xml = read_xml # if present -> read xml\n        self.name = name  # search identifier (used for save)\n        \n    def save(self):\n        # save search xml\n        sf = open(f\"\/kaggle\/working\/blast_{self.name}.xml\", \"w\")\n        sf.write(self.result_handle.read()) \n        self.result_handle.close()\n        sf.close() \n\n        # save metadata\n        self.df.to_csv(f'\/kaggle\/working\/csv_{self.name}.csv')\n        \n    # Find amino acid sequence in NCBI databases\n    def blast_aa(self):\n\n        # if not seq format\n        if(type(self.seq) is str):\n            self.seq = Seq(self.seq)\n        \n        if(self.read_xml is not None):\n            self.result_handle = open(f\"\/kaggle\/working\/blast_{self.name}.xml\")\n            blast_qresult = SearchIO.read(self.result_handle,\"blast-xml\")\n        else:\n            self.result_handle = NCBIWWW.qblast(\"blastp\",self.database,self.seq)\n            blast_qresult = SearchIO.read(self.result_handle,\"blast-xml\")\n \n        ii=-1\n        lst_id = []; lst_descr = []; lst_bitscore = []\n        lst_ali = []; lst_eval = []\n        \n        for f in blast_qresult: \n            ii+=1\n            seqid = blast_qresult[ii]\n            details = seqid[0]\n\n            lst_id.append(seqid.id)\n            lst_descr.append(seqid.description)\n            lst_eval.append(details.evalue)\n            lst_bitscore.append(details.bitscore)\n            lst_ali.append(details.aln)\n\n        dic_data = {'id':lst_id,'description':lst_descr,\n                    'evalue':lst_eval,'bitscore':lst_bitscore,\n                    'alignment':lst_ali}\n\n        self.df = pd.DataFrame(dic_data)\n\n        if(self.verbose):\n\n            print(blast_qresult[0:self.show_top])\n            #fetch the id, description, evalue, bitscore & alignment\n            print(f'\\nShowing BLAST query result #{hit_id}')\n            print('-------------------------------------------------------------------------------------------')\n            seqid = blast_qresult[hit_id]\n            details = seqid[hit_id]\n\n            print(f'Sequence ID: {seqid.id}')\n            print(f'Description: {seqid.description}')\n            print(f'e-value: {details.evalue}')\n            print(f'Bit Score: {details.bitscore}')\n\n            print('\\nShowing Alignment:')\n            print('-------------------------------------------------------------------------------------------')\n            print(f\"Alignment:\\n{details.aln}\")\n            \n    @staticmethod\n    def get_colors(seqs):\n        \"\"\"make colors for bases in sequence\"\"\"\n        text = [i for s in list(seqs) for i in s]\n\n        # DNA\n    #     clrs =  {'A':'red','T':'green','G':'orange','C':'blue','-':'white'}\n        # IUPAC aa\n        clrs   = {'A':'#3386FF','C':'#3386FF','D':'#B842B2','E':'#B842B2',\n                'F':'#3386FF','G':'#FF5733','H':'#37ADBB','I':'#3386FF',\n                'L':'#3386FF','M':'#3386FF','N':'#24CE5D','P':'#E3E710',\n                'Q':'#24CE5D','R':'#D3385E','S':'#24CE5D','T':'#24CE5D',\n                'V':'#3386FF','W':'#3386FF','Y':'#37ADBB','_':'white',\n                'K':'#D3385E'}\n\n        colors = [clrs[i] for i in text]\n        return colors\n            \n    # View BLAST alignment using Bokeh\n    def view(self,aln, fontsize=\"9pt\", plot_width=800):\n\n        #make sequence and id lists from the aln object\n        seqs = [rec.seq for rec in (aln)]\n        ids = [rec.id for rec in aln]    \n        text = [i for s in list(seqs) for i in s]\n        colors = self.get_colors(seqs)    \n        N = len(seqs[0])\n        S = len(seqs)    \n\n        x = np.arange(0.5,N+0.5)\n        y = np.arange(0,S,1)\n        #creates a 2D grid of coords from the 1D arrays\n        xx, yy = np.meshgrid(x, y)\n        #flattens the arrays\n        gx = xx.ravel()\n        gy = yy.flatten()\n        #use recty for rect coords with an offset\n        recty = gy+0.5\n        h= 1\/S\n        #now we can create the ColumnDataSource with all the arrays\n        source = ColumnDataSource(dict(x=gx, y=gy, recty=recty, text=text, colors=colors))\n        plot_height = len(seqs)*15+25\n        x_range = Range1d(0,N+1, bounds='auto')\n        if N>100:\n            viewlen=50\n        else:\n            viewlen=N\n        #view_range is for the close up view\n        view_range = (0,viewlen)\n        tools=\"xpan, xwheel_zoom, reset, save\" \n\n        #entire sequence view (no text, with zoom)\n        p = figure(title=None, plot_width= plot_width, plot_height=50,\n                   x_range=x_range, y_range=(0,S), tools=tools,\n                   min_border=0, toolbar_location='below')\n        rects = Rect(x=\"x\", y=\"recty\",  width=1, height=1, fill_color=\"colors\",\n                     line_color=None, fill_alpha=0.6)\n        p.add_glyph(source, rects)\n        p.yaxis.visible = False\n        p.grid.visible = False  \n\n        #sequence text view with ability to scroll along x axis\n        p1 = figure(title=None, plot_width=plot_width, plot_height=plot_height,\n                    x_range=view_range, y_range=ids, tools=\"xpan,reset\",\n                    min_border=0, toolbar_location='below')#, lod_factor=1)          \n        glyph = Text(x=\"x\", y=\"y\", text=\"text\", text_align='center',text_color=\"black\",\n                    text_font_size=fontsize,text_font_style='bold')\n        rects = Rect(x=\"x\", y=\"recty\",  width=1.0, height=1, fill_color=\"colors\",\n                    line_color=None, fill_alpha=0.4)\n        p1.add_glyph(source, glyph)\n        p1.add_glyph(source, rects)\n\n        p1.grid.visible = False\n        p1.xaxis.major_label_text_font_style = \"bold\"\n        p1.yaxis.minor_tick_line_width = 0\n        p1.yaxis.major_tick_line_width = 0\n        \n        return gridplot([[p],[p1]],toolbar_location='below') ","24550a51":"# Read FASTA format containing Covid Genome\nvirus_fna = '\/kaggle\/input\/coronavirus-genome-sequence\/MN908947.fna'\nvirus_n = read_seq(virus_fna) # read and store FNA data \nprint(f'Sequence Header: {virus_n.lst_header[0]}')","b13207c3":"# Store the sequence, defining a SQ class instance\nvirus_sq = virus_n.get_sq()\nprint(f'Sequence length: {len(virus_sq)} nucleotides')\n\n# The sequence is a bit too long, lets show the first 1000 characters\nvirus_sq[0:500]","031889c9":"# The virus contains a heavy portion of Thymine & Adenine (63%)\nvirus_sq.freq(fsize=[200,None],\n              title='Nucleotide Content (%)')\n\nprint(f'GC-Content Sequence 1: {round(virus_sq.gc()*100,3)}%')","88021340":"# Get all amino acid chains above default = 1\nlst_prot = virus_sq.get_protein()\nprint(f'Total Number of Amino Acid Chains: {len(lst_prot)}')","32fb15ab":"# # For convenience, let's select a subset above 50 amino acids\nprint(f'Amino Acid Chains: {len(virus_sq.get_protein(min_size=50))}')\nlargest_aa = virus_sq.get_protein(min_size=50)[0]\nprint(f'Largest Amino Acid: {largest_aa}')\nprint(f'Length of Largest Amino Acid: {len(virus_sq.get_protein(min_size=50)[0])}')","7631a6f4":"# ''' interpret xml w\/ NCBIXML '''\n# search_res = blast_aav1(largest_aa,'pdb') # search for aa chain in pdb databse\n# search_res.head() # stored in hit order\n# search_res.to_csv('\/kaggle\/working\/search_blast.csv')\n\ndata = BLASTwww(seq=largest_aa,database='pdb',name='c19')\ndata.blast_aa()\ndata.df.head()","0dcf1d85":"# Best hit\nprint(data.df.loc[0,'description']);print('\\n')\nalign0 = data.df.loc[0,'alignment'] # choose an alignment\nplot = data.view(align0) # view alignment \npn.pane.Bokeh(plot)","3975332b":"print('Search hit sequence:')\nprint(f'length of hit sequence: {len(align0[1].seq)}','\\n')\nprint(align0[1].seq)\n\naa_seq = SQ(largest_aa)\naa_seq.find_pattern(pattern=str(align0[1].seq),\n                    find_id='all',                                            \n                    search_id='standard')","91040273":"data.save() # save metadata (alignments arent actually saved)\n# to save alignments, just save xml of BLAST search","c69a4027":"<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>1.5 | CREATING OUR OWN SEQUENCE CLASS<\/b><\/p>\n<\/div>\n- Whilst there are wonderful libraries like **<span style='color:#5D2ECC'>BioPython<\/span>**, but it's often quite benefitial to understand the workings of the code & expand on the code if a need arises. \n- This is more time consuming, nevertheless it's definitely more interesting & allows us to incorporate different libraries (eg.<code>bokeh<\/code>) \n- In this notebook, emphasis will be placed on replicating something similar to two BioPython modules:\n> - from Bio import **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">SeqIO<\/mark>**  ( Class for readng sequences )\n> - from Bio.Seq import **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">Seq<\/mark>** ( Class for Sequence Operations )\n- At the very end of this notebook, we'll also create a <code>whl<\/code> package, which is uploaded & updated in the dataset: **[bioseq](https:\/\/www.kaggle.com\/shtrausslearning\/bioseq)**, which includes classes used here\n- <code>whl<\/code> is the format of packages used on pip & these files can be uploaded to datasets, installed via pip & called as you would an existing pip package on Kaggle\n- If you are interested in bioinformatics & I'd definitely recommend getting to know **[bioconductor](https:\/\/www.kaggle.com\/shtrausslearning\/bioconductor-bioinformatics-basics)** as well","ead4b251":"# <b>8 <span style='color:#F55AA2'>|<\/span> CREATING SUBSEQUENCES<\/b>\n- Our entire sequence may be very long & we might have want cut the current sequence for a variety of purposes\n- Example applications:\n> - Where a **full sequence** was cut into non overlapping unitigs - **[Identifying Antibiotic Resistant Bacteria](https:\/\/www.kaggle.com\/shtrausslearning\/identifying-antibiotic-resistant-bacteria)**\n> - Where a **full sequence** was cut into a predefined sets of nucleotide bases & OHE was used - **[Transcription Factor Binding Location Prediction](https:\/\/www.kaggle.com\/shtrausslearning\/transcription-factor-binding-location-prediction)**\n> - <b><span style='color:#5D2ECC'>Restriction Enzymes<\/span><\/b> can cut DNA sequences at particular segments of the DNA, defined by a particular pattern (we'll look at this here)\n\n### <b><span style='color:#F55AA2'>CREATING LISTS OF SUBSEQUENCES<\/span><\/b>\n- Whatever the mechanism, the function <code>cut_pattern<\/code> is general, requiring us to specify where in the sequence a cut occurs using \"|\"","1012db9b":"# <b>3 <span style='color:#F55AA2'>|<\/span> BASIC SEQUENCE OPERATIONS<\/b>\n### <b><span style='color:#F55AA2'>DEFINING A BASIC SEQUENCE<\/span><\/b>\n- We can create an instance of object <code>SQ<\/code> using the following ( including the <b>sequence type<\/b> )\n- The **sequence** and **sequence type** summary can be view by calling <code>info()<\/code> method,\n- DNA sequences are also colour coded, making it a little easier to distinguish the different characters","d54d7b69":"# <b>6 <span style='color:#F55AA2'>|<\/span> LOADING FILES CONTAINING SEQUENCES<\/b>\n\n### <b><span style='color:#F55AA2'>REAL SEQUENCES<\/span><\/b>\n\n- Most realistic application of bioinformatics certainly involve working with <b><span style='color:#5D2ECC'>sequences that are too long<\/span><\/b>\n- Often we need to work with databases, so it's convenient to have an effective I\/O system in place\n- One of such formats is <code>FASTA<\/code>, its made to be a very flexible format, allowing us to work with single, multiple or even alignment sequences.\n\n### <b><span style='color:#F55AA2'>THE FASTA FORMAT<\/span><\/b>\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">FASTA<\/mark>** | **[FASTA format](https:\/\/en.wikipedia.org\/wiki\/FASTA_format)**:\n>In bioinformatics and biochemistry, the FASTA format is a text-based format for representing either <b>nucleotide sequences<\/b> or <b>amino acid (protein) sequences<\/b>, in which nucleotides or amino acids are represented using single-letter codes. The format also allows for sequence names and comments to precede the sequences. The format originates from the FASTA software package, but has now become a near universal standard in the field of bioinformatics.\n\n- Commonly used to store nucleotide or protein sequences. It's less detailed & usually containing only the <b><span style='color:#5D2ECC'>sequence<\/span><\/b>, and <b><span style='color:#5D2ECC'>name\/header<\/span><\/b> only.\n- <b><span style='color:#5D2ECC'>File extension<\/span><\/b> | Typically changed based on the <b>sequence type<\/b> content of the file, defined below in the dictionary <code>FASTA_dic<\/code>.\n- <b><span style='color:#5D2ECC'>Multisequences<\/span><\/b> | The format can contain any number of sequences, each starting with the symbol: <b>><\/b>.\n- The <b><span style='color:#5D2ECC'>name\/header<\/span><\/b>, defined after the symbol <b>><\/b> contains an origin identifier (<b><span style='color:#5D2ECC'>NCBI identifiers<\/span><\/b>), defined in the the dictionary <code>identifiers_dic<\/code>.\n\n> - The NCBI defined a standard for the unique identifier used for the sequence (SeqID) in the header line. \n> - This allows a sequence that was obtained from a database to be labelled with a reference to its database record. \n> - The database identifier format is understood by the NCBI tools like makeblastdb and table2asn. \n> - The following list describes the NCBI FASTA defined format for sequence identifiers\n\n### <b><span style='color:#F55AA2'>READING SEQUENCE FILES CLASS<\/span><\/b>\n\n- We define a custom class, <code>read_seq()<\/code>, which methods used for reading the <code>FASTA<\/code> format\n- The class automatically should detect the class type and call the corresponding class, storing the sequence upon instantiation\n- Sequences that are read are stored in <code>SQ<\/code> objects, which allows us to also to also store additional information about the sequences\n\n### <b>read_seq | <span style='color:#F55AA2'>CLASS METHODS<\/span><\/b>\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">CONSTRUCTOR<\/mark>**\n- <code>name<\/code> : stores the **<span style='color:#5D2ECC'>pathway<\/span>**\n- <code>format<\/code> : stores the **<span style='color:#5D2ECC'>FASTA format<\/span>**\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">GENERAL CLASS METHODS<\/mark>**\n- <code>read_FASTA<\/code> : used to read <code>FASTA<\/code> formats, storing sequence data in <code>lst_seq<\/code> & descriptions in <code>SQ<\/code> objects\n- <code>get_sq<\/codE> : used to store the return a list or a sequence of <code>SQ<\/code> class objects","c5db6151":"# <b>9 <span style='color:#F55AA2'>|<\/span> COVID-19: PROTEIN IDENTIFICATION<\/b>\n\n### <b><span style='color:#F55AA2'>READING DNA SEQUENCE FROM A DATABASE<\/span><\/b>\n\n- Having defined a class that can **<span style='color:#5D2ECC'>read<\/span>**, **<span style='color:#5D2ECC'>store<\/span>** & **<span style='color:#5D2ECC'>derive proteins<\/span>** from a sequence file in the **FASTA** format, we can use a database to obtain a real sequence.\n- Let's use the **<span style='color:#5D2ECC'>coronavirus genomoe\/sequence<\/span>**, already uploaded to [Kaggle](https:\/\/www.kaggle.com\/paultimothymooney\/coronavirus-genome-sequence) & [original source](https:\/\/www.ncbi.nlm.nih.gov\/nuccore\/NC_045512).\n\n### <b><span style='color:#F55AA2'>BLAST - DATABASE SEARCHING<\/span><\/b>\n\nSteps we'll be taking:\n> - (1) Get the <b><span style='color:#5D2ECC'>proteins<\/span><\/b> encoded in the genome ( using <code>.translate<\/code> )\n> - (2) Identify the particular protein present & pick some that interest us\n> - (3) Using a **local sequence alignmnent** tool called **[BLAST](https:\/\/blast.ncbi.nlm.nih.gov\/Blast.cgi)**; (using class <code>BLASTwww<\/code>)\n> - (3) Visualise the alignment, so we can see which parts of the sequence match to that of the database\n\n\n- We will look into <b>Local Sequence Alignment<\/b> in another notebook **[Biological Sequence Alignment](https:\/\/www.kaggle.com\/shtrausslearning\/custom-class-biological-sequence-alignment)**, which BLAST uses.\n- However for the time being keeping things simple; a protein sequence is compared to others already found in a database and returns very simular sequences\n\n### <b><span style='color:#F55AA2'>USING THE NCBI API (via Biopython)<\/span><\/b>\n\nTo use the class function <code>BLASTwww<\/code>, we'll first need to:\n> - (1) decode the proteins from the DNA sequence \n> - (2) select a specific protein & search for matching results in the database\n\nBelow there are two functions that differ slightly, both use the **NCBI API**, to search databases:\n- <code>blast_aav1<\/code> - Uses <code>NCBIXML.read<\/code> in Biopython, thus don't obtain the **alignment alignment**\n- <code>BLASTwww<\/code> - Uses <code>SearchIO.read<\/code> in Biopython, which enables us to visualise the alignment using <code>view<\/code>","86a5fc07":"### <b><span style='color:#F55AA2'>DEFINING A DETAILED SEQUENCE<\/span><\/b>\n- <code>SQ<\/code> can also be used to store more detailed information about our sequence \n- Later we'll need to look at a sequence & jot down some information about parts of the sequence after we have identified them as well","fe55b2fa":"- We can obtain the individual sequences from the **alignment** in the following way\n- Using <code>.find_pattern<\/code>, we can find where in out input sequence we actually got a hit","f166c6fe":"### <b><span style='color:#F55AA2'>GENERATING OHE DNA FEATURES<\/span><\/b>\n- We can cut the sequence at a starting location & number of characters that must be present in each sequence\n- characters which aren't sufficient to create another segment; the leftover characters are discarded ","dc9404a1":"![](https:\/\/images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com\/f\/8cc1eeaa-4046-4c4a-ae93-93d656f68688\/deuhlxl-8e773d23-a58f-40a3-857c-704af8622e43.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcLzhjYzFlZWFhLTQwNDYtNGM0YS1hZTkzLTkzZDY1NmY2ODY4OFwvZGV1aGx4bC04ZTc3M2QyMy1hNThmLTQwYTMtODU3Yy03MDRhZjg2MjJlNDMuanBnIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.mmn4_1KfUZo-hlGvKyDsIaRkLCdc4-hQEuKXcJ0FEko)\n[Kras-Driven Lung Cancer @nci (unsplash)](https:\/\/unsplash.com\/photos\/zoFbfT0M_BU)\n\n# <b>1 <span style='color:#F55AA2'>|<\/span> BACKGROUND<\/b>\n\n<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>1.1 | CELL INFORMATION<\/b><\/p>\n<\/div>\n\nA cell is mostly composed of water:\n> - a bacteria cell has a weight composition of roughly 70% water & 30% <b><span style='color:#5D2ECC'>chemical origin<\/span><\/b>, (of which <b>7% are small molecules<\/b>)\n    > - Inc. <b><span style='color:#5D2ECC'>amino acids<\/span><\/b> and <b><span style='color:#5D2ECC'>nucleotides<\/span><\/b> & 23% -> <b>macro molecules<\/b> (<b>proteins<\/b>,lipids,polysaccharides)\n- According to their internal structure, they can be divided into to major categories; \n > - <b><span style='color:#5D2ECC'>Prokaryotic<\/span><\/b> cells : have no nucleus or internal membranes. \n > - <b><span style='color:#5D2ECC'>Eukaryotic<\/span><\/b> cells : which have a defined <b>nucleus<\/b>, <b>internal membranes<\/b> and functional elements called <b>organelles<\/b>.\n- At a structural level, all cells are surrounded by a structure called cell <b><span style='color:#5D2ECC'>membrane<\/span><\/b> or <b><span style='color:#5D2ECC'>plasma membrane<\/span><\/b>. \n- This <b><span style='color:#5D2ECC'>membrane<\/span><\/b> is permeable to molecules that cells need to absorb from or excrete to the outside medium.\n- Within the cell we find the <b>cytoplasm<\/b> (largely composed of water), which serves as the medium for the cell","aba8ab45":"Some interesting information about how many amino acids do we need to actually classify the decoded result as a protein\n- **[proteins & amino acids](https:\/\/www.ncbi.nlm.nih.gov\/books\/NBK234922\/)** (Both animal and plant proteins are made up of about 20 common amino acids)\n- We will mention those with **less than about 20 amino acids** below when we'll look at an example","ca5b4807":"# <b>7 <span style='color:#F55AA2'>|<\/span> RECOGNISING PATTERNS<\/b>\n- Another important part relating to sequences are pattern recognition within a sequence\n- There are specific <b><span style='color:#5D2ECC'>patterns<\/span><\/b> of nucleotides we can try to find, in order to understand our sequence content a little more\n- Having looked at the **<span style='color:#5D2ECC'>decoding of proteins<\/span>** in **Section 4**, we might want to know more about our amino acid chains\n\nFor example, an amino acid chain containing the pattern **Zinc finger RING-type** | **[Prosite Database](https:\/\/prosite.expasy.org\/cgi-bin\/prosite\/prosite-search-ac?PDOC00022)**\n- Some proteins known to include a RING finger include **Mammalian breast cancer type 1 susceptibility protein (BRCA1)**\n- Let's load the Breast cancer type 1 susceptibility protein **[BRCA1_HUMAN](https:\/\/www.uniprot.org\/uniprot\/P38398#)** in FASTA format (from the **<span style='color:#5D2ECC'>UniProtKB<\/span>** database)\n- Using the loader from **Section 5** to see if we have a match as well, since they should be related\n- Other **ZnF** types of prosite information **[@github](https:\/\/proteinswebteam.github.io\/interpro-blog\/potm\/2007_3\/Page1.htm)**\n\n### <b><span style='color:#F55AA2'>PROSITE PATTERN FORMAT<\/span><\/b>\n- Looking at the example, it should be quite clear what the below format rules mean, \n- Last point not currently added so you'd need to be specific, which case you're actualy searching for eg. x(2),x(3),x(4) instead of x(2,4)\n> - Standard **IUPAC amino acid** used to as bases in pattern, separated by -\n> - x -> any amino acid acceptable\n> - [] -> ambiguity represented by list, any aa in that list acceptable\n> - {} -> ambiguity represented by list, any aa other than in {} accepted\n> - Repetition of pattern element shown below:\n>   x(3) -> x-x-x, x(2,4) -> to x-x or x-x-x or x-x-x-x","5be60c1a":"### <b><span style='color:#F55AA2'>STANDARD ABC PATTERNS<\/span><\/b>\n- We can use standard patterns of nucleotide\/amino acid subsequence as well, for example <code>EES<\/code>","f3036621":"### <b><span style='color:#F55AA2'>FUNCTIONAL PROTEINS & OLIGOPEPTIDES<\/span><\/b>\n\n- Upon translation, our <b>amino acid chains<\/b> aren't actually all proteins, some extra criteria these chains must meet in order to be classified as proteins exist: \n> - **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">Functional proteins<\/mark>** are chains above <b>20 amino acids<\/b>.\n> - Smaller chains are called **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">oligopeptides<\/mark>** (2-20 amino acids) & have other functionalities.\n- Let's select the <b>largest amino acid chain<\/b> found in the genome & search for it in a databse, so we can identify it.\n- Interestingly enough, the largest amino acid chain actually differred from the Biopython result I tried in **[that notebook](https:\/\/www.kaggle.com\/shtrausslearning\/biopython-bioinformatics-basics)**","b879be24":"# <b>5 <span style='color:#F55AA2'>|<\/span> DECODING DNA FOR PROTEIN GENERATION<\/b>\n\n<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>5.1 | TRANSCRIPTION<\/b><\/p>\n<\/div>\n\n- The mRNA is created as the two complementary strands are split, and is complement to one of the strands.\n- Transcription of <b>DNA sequence<\/b> can be obtained using the <code>.transcription()<\/code> function, where the <b>T<\/b> is replaced by <b>U<\/b> in the sequence string.","534ec489":"### <b><span style='color:#F55AA2'>GC CONTENT COUNTS<\/span><\/b>\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">GC-Content<\/mark>** | [WIKIPEDIA](https:\/\/en.wikipedia.org\/wiki\/GC-content) & [SCIENCEDIRECT](https:\/\/www.sciencedirect.com\/topics\/biochemistry-genetics-and-molecular-biology\/gc-content)\n\n> - In molecular biology and genetics, GC-content (or guanine-cytosine content) is the percentage of nitrogenous bases in a DNA or RNA molecule that are either <b>guanine<\/b> (G) or <b>cytosine<\/b> (C). This measure indicates the proportion of G and C bases out of an implied four total bases, also including adenine and thymine in DNA and adenine and uracil in RNA.\n> - GC content is strongly correlated with biological features of genome organization such as distribution of various classes of repeated elements, gene density, level and tissue-specificity of transcription, and mutation rate.","fc1fd174":"### <b><span style='color:#F55AA2'>CHECK ITS VALIDITY<\/span><\/b>\n- A sequence is valid if its alphabet corresponds to a specific set of code, class <b>SQ<\/b> uses the **[IUPAC](https:\/\/www.bioinformatics.org\/sms2\/iupac.html)** code standard\n- We can check whether a sequence is valid or not by using the <code>.validate()<\/code> function, returning a logical output\n- This can be handy when our sequece is very large, and we can check the entire sequence for errors","fd8acb75":"<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>1.2 | BIOLOGICAL SEQUENCE ALPHABETS<\/b><\/p>\n<\/div>\n\n**<mark style=\"background-color:#323232;color:white;border-radius:5px;opacity:0.7\">ABC (I\/II)<\/mark>** **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">Nucleic Acids<\/mark>**\n\n> - Among <b><span style='color:#5D2ECC'>molecules with a biological role<\/span><\/b>, we can find <b><span style='color:#5D2ECC'>nucleic acids<\/span><\/b>. \n> - Nucleic acids encode and express the genetic code that is kept within the cell. \n- There are two major types of <b><span style='color:#5D2ECC'>nucleic acids<\/span><\/b>: \n> - <b>DeoxyriboNucleic Acid (DNA)<\/b>\n> - <b>RiboNucleic Acid (RNA)<\/b> (Obtainable via transcription)\n- DNA contains the information necessary to build a cell, and keep it functioning. \n- In <b><span style='color:#5D2ECC'>eukaryotic<\/span><\/b> cells, DNA will be found in the nucleus, whilst in the <b><span style='color:#5D2ECC'>prokaryotic<\/span><\/b> cells, it will be found in the cytoplasm. \n- <b><span style='color:#5D2ECC'>IUPAC<\/span><\/b> defines the full list of nucleotides as shown in the table below, with <b>A,T,G,C<\/b> being the main four:\n- Another type of nucleotide list often used is **[IUB Ambiguity Codes](http:\/\/biocorp.ca\/IUB.php)**, which we use later in the notebook as well\n\n![](https:\/\/images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com\/f\/8cc1eeaa-4046-4c4a-ae93-93d656f68688\/detobk7-b1446b53-4979-4ebd-ad87-5ee7e8548736.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcLzhjYzFlZWFhLTQwNDYtNGM0YS1hZTkzLTkzZDY1NmY2ODY4OFwvZGV0b2JrNy1iMTQ0NmI1My00OTc5LTRlYmQtYWQ4Ny01ZWU3ZTg1NDg3MzYuanBnIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.p-CsyGW9JeJ7FhPQMECB4Jeb2CJYy9xO-FKWr-Qp_ug)\n\n**<mark style=\"background-color:#323232;color:white;border-radius:5px;opacity:0.7\">ABC (II\/II)<\/mark>** **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">Amino Acids<\/mark>**\n- **<span style='color:#5D2ECC'>Amino acids<\/span>**: \n> The **<span style='color:#5D2ECC'>building blocks of proteins<\/span>**, which are <b>macromolecules<\/b> that perform most of the functions inside a cell\n- Proteins have a **<span style='color:#5D2ECC'>broad range of functions<\/span>**, spanning from **<span style='color:#5D2ECC'>catalytic<\/span>** to **<span style='color:#5D2ECC'>structural functions<\/span>**:\n\n> - **<span style='color:#5D2ECC'>Enzymes<\/span>** : Type of abundant proteins that promote chemical reactions and convert certain molecules into other types of molecules required for the functioning of the cell.\n> - **<span style='color:#5D2ECC'>Carbohydrates<\/span>** : Serve as energy storage, both for immediate and long term energy demands.\n> - **<span style='color:#5D2ECC'>Lipids<\/span>**: Part of the plasma membrane, doing signaling and energy storage.\n- The cell also contains other components of varying complexity. Of importance: \n> - <b>Mitochondria<\/b> & the <b>Chloroplasts<\/b> : Organelles involved in the production of energy. \n> - <b>Ribosomes<\/b> : Large and complex molecules composed of a mixture of genetic material, req. to assemble proteins and play a central role in the flow of genetic information.\n\n![](https:\/\/images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com\/f\/8cc1eeaa-4046-4c4a-ae93-93d656f68688\/detodgt-0c9ae2b8-3e64-4876-86d9-5ff3b38de5ff.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcLzhjYzFlZWFhLTQwNDYtNGM0YS1hZTkzLTkzZDY1NmY2ODY4OFwvZGV0b2RndC0wYzlhZTJiOC0zZTY0LTQ4NzYtODZkOS01ZmYzYjM4ZGU1ZmYuanBnIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.iqWr09YT1s7s1R4phtzoY2ak6M_jE4VfF6MRAHKEIO8)","867d793d":"### <b><span style='color:#F55AA2'>DI\/TRINUCLEOTIDES COUNTS<\/span><\/b>\n- We may want to know the different combinations of <b><span style='color:#5D2ECC'>double<\/span><\/b> or <b><span style='color:#5D2ECC'>tripple nucleotides<\/span><\/b> that is present within the sequence\n- One example would be to count all the <b><span style='color:#5D2ECC'>codons<\/span><\/b> present in a sequence","e00bce1f":"### <b><span style='color:#F55AA2'>MANUALLY SEARCHING OTHER DATABASES<\/span><\/b>\n- There are quite a few databses, we only checked the **pdb** database & **not all are accessible** via the NCBI API\n- We might not actually find a match for the entire sequence all the time, especially if it's as long as the one we have, naturally it will likely contain different subsequences\n- We can use this string; copy & paste this protein & search for it using the [PSI BLAST](https:\/\/www.ebi.ac.uk\/Tools\/sss\/psiblast\/) in order to find proteins already in a predefined database. \n- For the protein sequence that we searched for:\n> The results indicate that a 100% match was found with an already existing sequence in the database: **[sp|P0C6U8|R1A_SARS Replicase polyprotein 1a](https:\/\/pubchem.ncbi.nlm.nih.gov\/protein\/P0C6U8)**\n\n\nWhat is a **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">polyprotein<\/mark>** | **[NCBI](https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC7125721\/)**\n> Polyproteins are chains of covalently conjoined smaller proteins that occur in nature as versatile means to organize the proteome of viruses including HIV.","0efe8260":"### <b><span style='color:#F55AA2'>MAKING ANNOTATIONS<\/span><\/b>\n\n- Say we searched a database to find if our sequence contains something interesting\n- We have two hits, **<span style='color:#F55AA2'>'TTTT'<\/span>**,**<span style='color:#F55AA2'>'CCTCA'<\/span>**, which we want to save in <code>annotation<\/code>\n- Usually, when we search databases, we'll have a **sequence identifier** & **a description\/comment** about the sequence, so we'll be able to save this info\n- The search result sequences can be extracted from the **alignment format** & saved in <code>SQ<\/code> format","730c1589":"# <b>4 <span style='color:#F55AA2'>|<\/span> COUNTING CHARACTERS<\/b>\n\n### <b><span style='color:#F55AA2'>NUCLEOTIDE\/AMINO ACID<\/span><\/b>\n\n- We may want to obtain the count for each each nucleotide or amino acid in the given sequence\n- We can use the <code>.freq()<\/code> function to show:\n> - The **count**\/**percentage** of each of the alphabet **compare two sets** of sequences with the addition of <b>compare<\/b>\n- We may want to compare sequences of different length, so in that case it's best to use **percentage (default)**\n- <code>show_id='count'<\/code> is good for when we just want to see the character count of sequence","10f1c4ac":"# <b>10 <span style='color:#F55AA2'>|<\/span> SUMMARY<\/b>\n\n### <b><span style='color:#F55AA2'>CUSTOM CLASSES<\/span><\/b>\n- In this notebook, we have defined a class that stores <b>basic information<\/b> about a specific sequence of interest. \n- Another class was also defined in order to read a commonly encountered format type <b>FASTA<\/b>. \n\n### <b><span style='color:#F55AA2'>OVERVIEW<\/span><\/b>\n- We also looked at common sequence related operations such as <b>transcription<\/b> & <b>translation<\/b>, which are quite critical concepts.\n- We also looked at some basic visualisation of the nucleotide & amino acid distributions, which can be helpful when comparing not only the <b>count<\/b>, but also the percentage of each alphabet for the corresponding sequence type.\n\n### <b><span style='color:#F55AA2'>WHERE TO FROM HERE<\/span><\/b>\n- As with the <b>BioPython<\/b> module, we have defined classes which store sequence data & which can be expanded further.\n- The class, <b>SQ<\/b> will be used as a basis for other sequence related operations, such as <b>pairwise<\/b> & <b>multiple sequence alignment<\/b>, which due to their content size alone, can have their own dedicated classes, similar to the class <b>READ_SEQ<\/b>, which is dedicated to reading and passing on the sequence information to class <b>SQ<\/b>.\n- The notebook will of course be continuously updated and futher functions will be added in the future.","8b0351fa":"- Next, we can find where it is located in the sequence, using yet to be introduced method; <code>find_pattern<\/code>\n- This will be handy in **Section 8**, where we'll be searching & annotating a sequence of interest","1f583353":"- Next, let's choose a few search hit results & plot them, visualising the results: <code>pdb|7MSW|A<\/code>, <code>pdb|6WUU|A<\/code>\n- If we have a hit, we of course can search & find more about this specific sequence in literature or databases\n- We can see that our perfect hit case; <b><span style='color:#5D2ECC'>pdb|7WUU|A<\/span><\/b> is not the entire sequence that we input & visually can see its much smaller than our input\n- We got a match for the the entire sequence, using the <b><span style='color:#5D2ECC'>UniProt database<\/span><\/b>. However as we can see with the <b><span style='color:#5D2ECC'>pdb<\/span><\/b>, we only managed to identify sequences representing part of the protein, which still gave us 100% match locally.","fc7ce4d5":"### <b><span style='color:#F55AA2'>PURINES & PYRIMIDINES COUNTS<\/span><\/b>\n- **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">Purines<\/mark>** - (adenine and guanine) have a two-ringed structure consisting of a nine-membered molecule with four nitrogen atoms\n- **<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">Pyrimidines<\/mark>** - (cytosine, uracil, and thymine) only have one single ring, which has just six members and two nitrogen atoms","6abf6488":"<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>1.4 | CENTRAL DOGMA OF MOLECULAR & CELL BIOLOGY<\/b><\/p>\n<\/div>\n\n- The process talked about in the next section is quite complex & not all aspects are competely understood,  a general and simplistic picture is provided below\n- **<span style='color:#5D2ECC'>DNA<\/span>**, **<span style='color:#5D2ECC'>RNA<\/span>** & **<span style='color:#5D2ECC'>Proteins<\/span>** are the central elements of the flow of genetic information that occurs in two steps:\n\n### <b>[STEP 1] RNA SYNTHESIS : <span style='color:#F55AA2'>TRANSCRIPTION<\/span><\/b>\n\n> - Preliminary step required to produce a <b>protein<\/b>\n> - The nucleotide sequence of a gene from one of the DNA strands is transcribed ( copied into a complementary molecule of RNA )\n> - The complementarity of the genetic code allows recovering the information encoded in the original DNA sequence, a process performed by the enzyme, RNA polymerase.\n> - Additional steps of RNA processing, including stabilising elements at the end of the molecule, are performed by different protein complexes.\n> - After these steps, which occur within the nucleus of the cell, an RNA molecule; <b>mature messenger RNA (mRNA)<\/b> is obtained.\n> - The <b>mRNA<\/b> is then transported to the cytoplasm, where it will be used by the cellular machine to guide the production of a protein.\n\n### <b>[STEP 2] PROTEIN SYNTHESIS : <span style='color:#F55AA2'>TRANSLATION<\/span><\/b>\n\n> - Process in which the nucleotide sequence of the mRNA is <b>transcribed into a chain of amino acids<\/b>, forming a <b>polypeptide<\/b>. \n> - <b>Proteins<\/b> are cellular entities that have either:\n    - (a) **<span style='color:#5D2ECC'>Structural function<\/span>** - Participating in the physical definition of a cell.\n    - (b) **<span style='color:#5D2ECC'>Chemical function<\/span>** - Being involved in chemical reactions occuring in the cell.\n> -  In order to function as expected, a protein needs to acquire the appropriate structure & this structure is often decomposed at different complexity levels.\n> The primary structure is defined by the chain of amino acids; <b>polypeptide<\/b>, consisting in part or completely of protein.\n> - This process is performed by the **<span style='color:#5D2ECC'>ribosomes<\/span>** that attach and scan the mRNA from one end to the other, in groups of <b>nucleotide triplets<\/b> \/ <b>Codons<\/b>.\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">CODONS<\/mark>**\n    \n> - In each position of the triplet, we have 1\/4 nucleotides, ie. there are 4x4x4 (64) possible triplets\/Codons. \n> - For each codon in the mRNA sequence, we have a corresponding amino acid in the <b>polypeptide chain<\/b>.\n    \n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">START AND STOP CODONS<\/mark>**\n    \n> - Some of these codons represent significant signals that indicate the <b>initiation<\/b> or the <b>termination<\/b> of the translation process.\n> - Once the **ribosome** detects an initiation codon, it starts the formation of the amino acid chain, and when it scans the stop codon, it stops the translation and detaches from the mRNA molecule.\n\n> - There are <b>20 types of amino acids used to form polypeptides<\/b> (for IUPAC) & less than the 64 possible codons, therefore we have more than one codon corresponds to a type of amino acid.\n    \n> - During the translation process:\n    - A type of small RNA molecule, <b>transfer RNA (tRNAs)<\/b> will bring to the <b>ribosome<\/b>, the amino acids of the corresponding type, which will be complementary to the mRNA codon that is currently being scanned.\n    - Each mRNA molecule can be scanned multiple times by different ribosomes, giving rise to multiple copies of the polypeptide. \n    - With its redundency, where more than one codon encodes an amino acid, the genetic code encloses a very efficient code-correction mechanism that minimises the impact of errors in the nucleotide sequence occuring in DNA replication.\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">OPEN READING FRAMES<\/mark>**\n\nDuring translation process:\n> - Parsing of the **mRNA sequence** by the ribosome **<span style='color:#5D2ECC'>may start at different nucleotides<\/span>**. \n> - Given that a codon is composed of three nucleotides, the mRNA sequence may have <b>3 possible interpretations<\/b>. \n> - These three ways of parsing the sequence are called **<span style='color:#5D2ECC'>reading frames<\/span>**.","6242ecc6":"<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>5.2 | TRANSLATION<\/b><\/p>\n<\/div>\n\n### <b><span style='color:#F55AA2'>OVERVIEW<\/span><\/b>\n- The background to what happens during the translation process was already outlined in <code>1.3<\/code>, however it makes sense to expand on theory a little more.\n- Proteins are synthesised by creating <b>chains of aminoacids<\/b>, according to information contained in the <b>messenger RNA (mRNA)<\/b> in a process called <b>translation<\/b>.\n\n### <b><span style='color:#F55AA2'>START & STOP CODONS<\/span><\/b>\n- <b>Translation<\/b> of a protein always begins with a specific codon <b>ATG<\/b> -> <b>M (Methionine)<\/b>, which is always the first amino in the protein.\n- <b>Translation<\/b> process terminates when a stop codon is found; <b>TAA<\/b>,<b>TAG<\/b>,<b>TGA<\/b> -> <code>_<\/code>.\n- An example sequence where we know exactly where the <b>start<\/b> and <b>termination codons<\/b> are:\n    - **<span style='color:#F55AA2'>ATG<\/span>**<code>ACGGATCAGCCGCAAGCGGAATTGGCGTTTACGTACGATGCGCCG<\/code>**<span style='color:#5D2ECC'>TAA<\/span>**\n    - We can note it **<span style='color:#5D2ECC'>starts with ATG<\/span>** & ends with **<span style='color:#5D2ECC'>one of the three stop codons<\/span>**.\n- As the sequence follows the rule of start and ending codon, in such a case we can use the <b>staticmethod<\/b> defined in SQ; <code>.translate(p0=0)<\/code> directly.\n- Some interesting discussions about the **[starting amino acid](https:\/\/www.researchgate.net\/post\/Does_every_protein_start_with_methionine)** (ATG is usually the starting codon)\n\n### <b><span style='color:#F55AA2'>OPEN READING FRAME<\/span><\/b>\n- A <b>reading frame<\/b> is a way of dividing the DNA sequence into a set of consecutive, <b>non-overlapping triplet nucleotides<\/b> (possible codons) (using dictionary mapping).\n- A given sequence has 3 possible reading frames, first, second and third nucleotide positions. In addition, considering there is another complementary strand, we should compute the only 3 frames corresponding to the reverse compliment.\n- In many cases, given a DNA sequence, <b>we don't know in advance where the coding regions are<\/b>, especially when dealing with complete sequences.\n- In such cases, we need to <b>scan the DNA sequence for the coding region<\/b>. First, we need to divide and compute these reading frames (6 in total). The <code>frames<\/code> function stores the converted 6 converted amino acid strings in a list.\n\n<b>OPEN READING FRAME<\/b> | [genomove.gov](https:\/\/www.genome.gov\/genetics-glossary\/Open-Reading-Frame)\n\n> - An open reading frame is a portion of a DNA molecule that, when translated into amino acids, contains no stop codons\n> - The genetic code reads DNA sequences in groups of three base pairs, which means that a double-stranded DNA molecule can read in any of six possible reading frames: three in the forward direction and three in the reverse.\n> - A long open reading frame is likely part of a gene.\n    \n| Open Reading Frames (ORF)[[1]](https:\/\/www.genome.gov\/genetics-glossary\/Open-Reading-Frame) |\n| - |\n|<img src=\"https:\/\/www.genome.gov\/sites\/default\/files\/tg\/en\/illustration\/open_reading_frame.jpg\" alt=\"Drawing\" style=\"width:700px;\"\/> |\n\n### <b><span style='color:#F55AA2'>IDEAL CASE (P=0)<\/span><\/b>\n- Let's try one of the reading frames at the start of the sequence (<b><span style='color:#5D2ECC'>p0=0<\/span><\/b>), which we know follows the correct rules observed in life.\n- Let's also consider all other possible ORFS & get the final protein found in the DNA sequence.","46ebbf2b":"<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>1.3 | DNA STRANDS<\/b><\/p>\n<\/div>\n\n### <b><span style='color:#F55AA2'>COMPLEMENTARY STRANDS IN DNA<\/span><\/b>\n\n- DNA is a molecule composed of **<span style='color:#5D2ECC'>two complementary strands<\/span>** that form and stick together due to the connections established between the nucleotides in both strands. \n\n> - This is made possible by due to the chemical phenomenon where **<span style='color:#5D2ECC'>Adenine (A)<\/span>** bonds only with **<span style='color:#5D2ECC'>Thymine (T)<\/span>** nucleotides, as a result of two hydrogen connections. \n> - Similarly, **<span style='color:#5D2ECC'>Guanine (G)<\/span>** bonds only with **<span style='color:#5D2ECC'>Cytosine (C)<\/span>** nucleotides by three hydrogen connections.\n\n### <b><span style='color:#F55AA2'>REVERSE COMPLEMENT<\/span><\/b>\n\n- This results in **<span style='color:#5D2ECC'>two complementary<\/span>** and **<span style='color:#5D2ECC'>anti-parallel strands<\/span>** (connected in opposite directions), if we know the nucleotide sequence in one of the strands, we can get the sequence in the opposite strand by taking the complement of its nucleotides, which are also read backwards, thus we have the **<span style='color:#5D2ECC'>reverse complement<\/span>** of the other strand.\n- It has become a **<span style='color:#5D2ECC'>standard to describe the DNA though only one<\/span>** of the strands, due to this **<span style='color:#5D2ECC'>complementarity<\/span>** using <b>[A,T,G,C]<\/b>.\n- The existence of these two strands is essential in order to **<span style='color:#5D2ECC'>pass on genetic information<\/span>** to new cells and **<span style='color:#5D2ECC'>produce proteins<\/span>**.","12fc46bb":"# <b>2 <span style='color:#F55AA2'>|<\/span> DEFINING A SEQUENCE OPERATIONS CLASS<\/b>\n\n<div style=\"color:white;display:fill;border-radius:8px;\n            background-color:#323232;font-size:150%;\n            font-family:Nexa;letter-spacing:0.5px\">\n    <p style=\"padding: 8px;color:white;\"><b>2.1 | MAIN SEQUENCE CLASS<\/b><\/p>\n<\/div>\n\n### <b><span style='color:#F55AA2'>SEQUENCE OPERATION CLASS<\/span><\/b>\n\n- We define a custom class, <code>SQ()<\/code>, which contains basic <b>sequence related operations<\/b>\n- The <b>sequence class<\/b> <code>SQ<\/code> can be coupled with other classes that incorporate more sophisticated sequence based operations; eg. **[sequence alignment](https:\/\/www.kaggle.com\/shtrausslearning\/biological-sequence-alignment)**\n\n### <b>SQ | <span style='color:#F55AA2'>CLASS METHODS<\/span><\/b>\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">CONSTRUCTOR<\/mark>**\n> - <code>seq<\/code> : String format of sequence\n> - <code>seq_type<\/code> : Sequence Character Type\n> - <code>id<\/code> : Sequence Identifier \n> - <code>name<\/code> : used to allocate a name to the sequence\n> - <code>description<\/code> : used to show more information about the sequence\n> - <code>annotation<\/code> : used to store annotation information about our sequence\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">GENERAL CLASS METHODS<\/mark>**\n- <code>info<\/code> : Show the sequence & type **<span style='color:#5D2ECC'>information only<\/span>**\n- <code>abc<\/code> : Show the **<span style='color:#5D2ECC'>alphabet characters<\/span>** of the the sequence type\n- <code>validate<\/code> : Determine if the current **<span style='color:#5D2ECC'>sequence contains valid subsets<\/span>** of charaters for its type\n- <code>freq<\/code> : Calculate & plot the **<span style='color:#5D2ECC'>frequencey of each character<\/span>** in the alphabet of the define sequence **<span style='color:#5D2ECC'>type<\/span>**\n- <code>count_purines<\/code> : Count purines  <code>A&G<\/code> sum & pyrimidines <code>C&T<\/code>\n- <code>groupfreq<\/code> : Cound dinucleotides & trincucleotide groupings in sequence\n- <code>gc<\/code> : Calculate the **<span style='color:#5D2ECC'>GC content<\/span>** of the sequence\n- <code>reverse_comp<\/code> : Rearrange the DNA sequnce to show its **<span style='color:#5D2ECC'>reverse complement sequence pair<\/span>**\n- <code>transcription<\/code> : Convert DNA sequence into an **<span style='color:#5D2ECC'>RNA sequence<\/span>** \n- <code>get_protein<\/code> : Derive all the **<span style='color:#5D2ECC'>amino acid chains<\/span>** in **<span style='color:#5D2ECC'>all reading frames<\/span>** and store as one sequence\n- <code>find_pattern<\/code> : Find standard\/string patterns in the sequence & more specialised\/specific patterns\n- <code>cut_pattern<\/code> : Cut sequence in specific parts based on a pattern\n\n**<mark style=\"background-color:#F55AA2;color:white;border-radius:5px;opacity:0.7\">MAPPING DICTIONARY<\/mark>** <code>dic_map<\/code>\n- Similar to BioPython's <b>CodonTable<\/b> as shown in **[Biopython for Bioinformatics Basics](https:\/\/www.kaggle.com\/shtrausslearning\/biopython-for-bioinformatics-basics)**\n- A dictionary containing mapping data between different combinations of mRNA nucleotides (codons) and <b>amino acids<\/b> is obtainable in <b>dic_map<\/b> by setting <b>map_id<\/b> to *codon*. \n- Similarly, mapping between the IUPAC amino acid symbols & names can be obtained by using <b>map_id = 'iupac_amino'<\/b> &  <b>map_id = 'iupac_nucleotide'<\/b> respectively.","bdd853e1":"Two examples are shown below, reading files: \n> <code>file_faa<\/code> & <code>file_fna<\/code>, containing a <b>set of protein sequences (faa)<\/b> and a <b>single nucleotide sequence (fna)<\/b> resepectively","c95d83e0":"### <b><span style='color:#F55AA2'>SWITCH TO ITS REVERSE COMPLEMENT<\/span><\/b>\n- DNA has **<span style='color:#5D2ECC'>two complementary strands<\/span>**\n- Due to the complementarity of the DNA strands, usually only one of the strands is provided in a sequence file obtained from databases\n- The second strand to the input <b>DNA sequence<\/b> can be obtained by calling the <code>.reverse_comp()<\/code> function"}}