{"cell_type":{"08e270df":"code","6d593020":"code","65e52187":"code","9ede681b":"code","af891dfb":"code","e20daa39":"code","40924636":"code","f4091440":"code","734a2dda":"code","319a715c":"code","8b837a56":"code","1502694d":"code","50517120":"code","7dfc10d8":"code","177ffc3b":"code","3aeb212f":"code","d081509f":"code","cb705ba5":"code","6bd2b2dc":"code","540ac874":"code","ed3273f5":"code","4b84ad23":"markdown","65442b57":"markdown","b1d66dcb":"markdown","6eab480e":"markdown","a45f0ad8":"markdown","8cc9c284":"markdown","e0c82d9a":"markdown","52dae80a":"markdown","74a86d8c":"markdown","f641e0f4":"markdown","29d43be6":"markdown","88ec2e9f":"markdown","a5b02b8d":"markdown","a07ba7b4":"markdown","c685f278":"markdown","5a4a39a7":"markdown","7f5a1628":"markdown","3b538e12":"markdown"},"source":{"08e270df":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as lines\nimport matplotlib.gridspec as gridspec\nimport seaborn as sns\n\nfrom scipy.stats import probplot\nfrom warnings import filterwarnings\nfilterwarnings('ignore')\n\nplt.rcParams['font.family'] = 'monospace'","6d593020":"df = pd.read_csv('..\/input\/netflix-original-films-imdb-scores\/NetflixOriginals.csv')","65e52187":"colors = ['#751a2c','#b33a3a','#d57056','#f2b0a5','#261421']\nbg_color = '#fbfbfb'\ntxt_color = '#5c5c5c'\n\nsns.palplot(colors)","9ede681b":"print(f\"Shape: {df.shape}\")\nprint(':'*25)\ndf.head(5)","af891dfb":"df.info()","e20daa39":"# create time based features\ndf['Premiere'] = pd.to_datetime(df['Premiere'])\ndf['Year'] = df['Premiere'].dt.year\ndf['Month'] = df['Premiere'].dt.month\ndf['Week'] = df['Premiere'].dt.week\ndf['DayName'] = df['Premiere'].dt.day_name()\ndf['Weekday'] = df['Premiere'].dt.weekday\n\n# create string based features\ndf['TitleLen'] = df['Title'].apply(lambda x: len(x))","40924636":"fig = plt.figure(tight_layout=True, figsize=(15,9))\ngs = gridspec.GridSpec(nrows=2, ncols=2, width_ratios=[3,1])\n\nfig.patch.set_facecolor(bg_color)\n\nax0 = fig.add_subplot(gs[:,0])\nax1 = fig.add_subplot(gs[0,1])\nax2 = fig.add_subplot(gs[1,1])\n\nax0.set_facecolor(bg_color)\nax1.set_facecolor(bg_color)\nax2.set_facecolor(bg_color)\n\nmean = df['IMDB Score'].mean()\nmedian = df['IMDB Score'].median()\n\n#################\n#### KDE-PLOT####\n#################\nax0.axvline(x=mean, ymin=0, ymax=1, zorder=2, color='#fff', alpha=0.5, lw=2, ls='--')\nax0.axvline(x=median, ymin=0, ymax=1, zorder=2, color='#fff', alpha=0.5, lw=2, ls=':')\n\nax0.annotate(\n    s=f\"Mean: {np.round(mean,1)}\",\n    xy=(mean, 0.25),\n    xytext=(mean - 0.8,0.3),\n    color=txt_color,\n    fontsize=14, fontweight='light', \n    fontfamily='calibri', fontstyle='italic',\n    va='center', ha='center',\n    bbox=dict(\n        boxstyle='square,pad=0.3',\n        facecolor=bg_color,edgecolor=txt_color\n    ),\n    arrowprops=dict(\n        arrowstyle='->', \n        color='#000',\n        connectionstyle='arc3, rad=0.5'\n    )\n)\n\nax0.annotate(\n    s=f\"Median: {np.round(median,1)}\",\n    xy=(median, 0.2),\n    xytext=(median + 1.1, 0.25),\n    color=txt_color,\n    fontsize=14, fontweight='light', \n    fontfamily='calibri', fontstyle='italic',\n    va='center', ha='center',\n    bbox=dict(\n        boxstyle='square,pad=0.3',\n        facecolor=bg_color,edgecolor=txt_color\n    ),\n    arrowprops=dict(\n        arrowstyle='->', \n        color='#000',\n        connectionstyle='arc3, rad=-0.45'\n    )\n)\n\nsns.kdeplot(\n    data=df, x='IMDB Score', shade=True, color=colors[0],\n    edgecolor=colors[4], lw=1, alpha=0.8, ax=ax0, zorder=1\n)\n\nax0.set_xlabel('')\nax0.set_ylabel('')\nax0.set_yticks([])\n\n##################\n#### BOX-PLOT ####\n##################\n\nax1.boxplot(\n    data=df, x='IMDB Score',\n    vert=False, patch_artist=True,\n    boxprops=dict(facecolor=colors[4], color='#fff', lw=0),\n    whiskerprops=dict(color='gray', lw=1, ls='--'),\n    capprops=dict(color='gray', lw=1, ls='--'),\n    medianprops=dict(color='#fff', lw=2),\n    flierprops=dict(markerfacecolor=colors[0],alpha=0.75)\n)\n\nax1.annotate(\n    s='left-outliers',\n    xy=(39.5, 165),\n    xytext=(0,225),\n    color=txt_color,\n    fontsize=14, fontweight='light', \n    fontfamily='calibri', fontstyle='italic',\n    xycoords='axes points',\n    arrowprops=dict(arrowstyle='-[, widthB=1.75')\n)\n\nax1.set_xlabel('')\nax1.set_ylabel('')\nax1.set_xticks([])\nax1.set_yticks([])\n\n###################\n#### PROB-PLOT ####\n###################\n\nres = probplot(x=df['IMDB Score'], plot=ax2)\n\nl0 = ax2.get_lines()[0]\nl1 = ax2.get_lines()[1]\n\nl0.set_marker('D')\nl0.set_alpha(0.25)\nl0.set_color(colors[3])\nl1.set_color(colors[4])\nl1.set_linestyle('--')\nl1.set_linewidth(0.5)\nl1.set_alpha(0.75)\n\nax2.set_xlabel('')\nax2.set_ylabel('')\nax2.set_xticks([])\nax2.set_yticks([])\nax2.set_title('')\n\n# Text & Titles\nfig.text(\n    s=':IMDB Score - Distribution',\n    x=0, y=0.975,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    Our IMDB Score is normally distributed.\n    However we have some outliers to the left, which can\n    be seen in the boxplot as well as on the probability\n    distribution plot.\n    ''',\n    x=0, y=0.875,\n    color=txt_color\n)\n\nfig.text(\n    s='Box-Plot', rotation=90, \n    x=0.72, y=0.90,\n    color=txt_color\n)\n\nfig.text(\n    s='Probability-Plot', rotation=90, \n    x=0.72, y=0.275,\n    color=txt_color\n)\n\n# seperation lines\nsl1 = lines.Line2D(xdata=[0.73,0.73], ydata=[0.05,0.4], lw=1, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nsl2 = lines.Line2D(xdata=[0.73,0.73], ydata=[0.6,0.95], lw=1, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nfig.lines.extend([sl1, sl2])\n\n# despine\nfor spine in ['top','left','right','bottom']:\n    ax0.spines[spine].set_visible(False)\n    ax1.spines[spine].set_visible(False)\n    ax2.spines[spine].set_visible(False)\n\n# show\nplt.show()","f4091440":"# create a helper function\ndef group_df(df:pd.DataFrame, col:str) -> pd.DataFrame:\n    tmp = df.groupby(col).agg({'Title':'count','Runtime':'mean','IMDB Score':'mean'})\n    tmp = tmp.sort_values(by='Title', ascending=False).reset_index()\n    tmp = tmp.rename(columns={'Title':'Count', 'Runtime':'MeanRuntime','IMDB Score':'MeanScore'})\n    return tmp","734a2dda":"# create grouped dataframes for analysis\ndf_genre = group_df(df, 'Genre')[:5]\ndf_language = group_df(df, 'Language')[:5]\n\n# calculate ratio for alpha values\ndf_genre['Ratio'] = df_genre['Count'].apply(lambda x: x \/ df_genre['Count'].sum())","319a715c":"# basic overview how many titles over time\ndf_time = df.groupby('Year').nunique()[['Title']].reset_index()\ndf_time = df_time[df_time['Year'] <= 2020]\ndf_time = df_time.rename(columns={'Title':'Count'})\nsum_titles = df_time['Count'].sum()\n\n# plot\nfig, ax = plt.subplots(figsize=(12,6))\nfig.patch.set_facecolor(bg_color)\nax.set_facecolor(bg_color)\n\nax.plot(data=df_time['Year'], y1= df_time['Count'], color=colors[4], lw=0.5)\nax.fill_between(x=df_time['Year'], y1=0, y2=df_time['Count'], color=colors[0], alpha=0.85)\n\nax.axhline(y=0, color=colors[4], lw=2, alpha=1)\nax.set_xlim(df_time['Year'].min(), df_time['Year'].max())\n\nax.yaxis.tick_right()\nax.tick_params(axis='both', which='both', length=0)\n\n# Text & Titles\nfig.text(\n    s=':Number of Titles over Time (until 2020)',\n    x=0, y=0.975,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    the amount of titles added \n    has steadily risen over the years\n    ''',\n    x=-0.01, y=0.89,\n    color=txt_color\n)\n\nfig.text(\n    s='Total Movies:',\n    x=0.762, y=0.84,\n    color=txt_color,\n    fontsize=9,\n)\n\nfig.text(\n    s=sum_titles,\n    x=0.785, y=0.80,\n    color=txt_color,\n    fontsize=14,fontweight='bold'\n)\n\n# seperation lines\nsl1 = lines.Line2D(xdata=[0.75,0.75], ydata=[0.78,0.86], lw=1, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nsl2 = lines.Line2D(xdata=[0.75,0.80], ydata=[0.78,0.78], lw=1, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nfig.lines.extend([sl1,sl2])\n\n# despine\nfor spine in ['top','left','right','bottom']:\n    ax.spines[spine].set_visible(False)\n\nplt.show()","8b837a56":"import squarify\n\ndf_top_titles = df.groupby('Title').mean()['IMDB Score'].nlargest(5)\ndf_flop_titles = df.groupby('Title').mean()['IMDB Score'].nsmallest(5).sort_values(ascending=False)\ndf_titles = pd.concat([df_top_titles, df_flop_titles])\ndf_titles = pd.DataFrame({'Title':df_titles.index,'Score':df_titles.values})\n\n# create labels for treemap\nlabels = [label +'\\n'+ str(score) +' Score' for label, score in zip(df_titles['Title'],df_titles['Score'])]\n\nfig, ax = plt.subplots(tight_layout=True, figsize=(15,9))\nfig.patch.set_facecolor(bg_color)\nax.set_facecolor(bg_color)\n\n# create treemap\nsquarify.plot(\n    sizes=df_titles['Score'], label=labels, color=colors, alpha=0.8,\n    pad=0.05, ax=ax, text_kwargs=dict(color='white', fontsize=9, fontweight='light')\n)\n\nax.axis('off')\n\n# Text & Titles\nfig.text(\n    s=':Top & Flop Titles',\n    x=0, y=1.1,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    Congratulations David Attenborough,\n    I also like your movies ...\n    ''',\n    x=-0.01, y=1.04,\n    color=txt_color\n)\n\nplt.show()","1502694d":"!pip install circlify","50517120":"import circlify\n\nfig = plt.figure(tight_layout=True, figsize=(15,10))\ngs = gridspec.GridSpec(nrows=1, ncols=2, width_ratios=[1.5,0.5])\n\nfig.patch.set_facecolor(bg_color)\nfig.subplots_adjust(wspace=1, right=2)\n\nax0 = fig.add_subplot(gs[0,0])\nax1 = fig.add_subplot(gs[0,1])\n\nax0.set_facecolor(bg_color)\nax1.set_facecolor(bg_color)\n\n# create circles based on title count\ncircles = circlify.circlify(\n    data=df_genre['Count'].tolist(),\n    show_enclosure=False,\n    target_enclosure=circlify.Circle(x=0,y=0,r=1)\n)\n\n# find and set limit\nlim = max(\n    max(\n        abs(circle.x) + circle.r,\n        abs(circle.y) + circle.r\n    )\n    for circle in circles\n)\n\nax0.set_xlim(-lim, lim)\nax0.set_ylim(-lim, lim)\n\n# labels\nlabels = df_genre['Genre'][::-1]\nscores = df_genre['MeanScore'][::-1]\nratios = df_genre['Ratio'][::-1]\n\n# print circles\nfor label, score, ratio, circle in zip(labels, scores, ratios, circles):\n    x,y,r = circle\n    ax0.add_patch(\n        plt.Circle(\n            (x,y), r, \n            alpha=(1*ratio+0.5), lw=1, \n            fill=True, facecolor=colors[0]\n            )\n        )\n    ax0.annotate(\n        s=f\"{label}\\n{np.round(score,1)}\",\n        xy=(x,y),\n        va='center',ha='center', color='#fff'\n    )\n\n# average runtime per genre\nax1.set_xlim(0, df_genre['MeanRuntime'].max()+10)\n\nax1 = sns.scatterplot(\n    data=df_genre, x=10, y='Genre', color='#000', s=200\n)\nax1 = sns.scatterplot(\n    data=df_genre, x='MeanRuntime', y='Genre', color=colors[0], s=2e3\n)\n\nfor idx in range(0,len(df_genre['Genre'])):\n    xmin = 10\/(df_genre['MeanRuntime'].max()+10)\n    xmax = df_genre['MeanRuntime'][idx]\/(df_genre['MeanRuntime'].max()+10)\n\n    ax1.axhline(\n        y=df_genre['Genre'][idx], \n        xmin=xmin, \n        xmax=xmax,\n        color=txt_color, zorder=0\n    )\n\n    ax1.annotate(\n        s=f\"{int(df_genre['MeanRuntime'][idx])}\\nmin\",\n        xy=(df_genre['MeanRuntime'][idx],df_genre['Genre'][idx]),\n        va='center', ha='center',\n        color='#fff'\n        \n    )\n\nax1.set_xticks([])\nax1.set_xlabel('')\nax1.set_ylabel('')\nax1.tick_params(axis='both', which='both', length=0)\n\n# despine\nfor spine in ['top','left','right','bottom']:\n    ax1.spines[spine].set_visible(False)\n\nax0.axis('off')\n\n# Text & Titles\nfig.text(\n    s=':TOP 5 - Genres',\n    x=0, y=0.975,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    by number of titles (size)\n    average score and runtime\n    ''',\n    x=-0.01, y=0.925,\n    color=txt_color\n)\n\nfig.text(\n    s='''\n    Documentaries are not only \n    the biggest (159 Titles)\n    but also the (on average) \n    highest scoring movies.\n    ''',\n    x=0.51, y=0.7,\n    color=txt_color,\n    fontsize=9,alpha=0.5\n)\n\nfig.text(\n    s='avg. Runtime',\n    rotation=90,\n    x=0.665, y=0.875,\n    color=txt_color,\n    fontsize=9,alpha=0.5\n)\n\n# seperation lines\nsl1 = lines.Line2D(xdata=[0.525,0.525], ydata=[0.68,0.78], lw=2, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nsl2 = lines.Line2D(xdata=[0.675,0.675], ydata=[0.05,0.95], lw=1, alpha=0.25, color='#aeaeae', transform=fig.transFigure, figure=fig)\nfig.lines.extend([sl1,sl2])\n\nplt.show()","7dfc10d8":"# prepare data for top genre boxplot\ncols = [*df_genre['Genre'].value_counts().index]\n\ndf_top_genre = df.copy()\ndf_top_genre['TopGenre'] = df_top_genre['Genre'].apply(lambda x: 1 if x in cols else 0)\ndata = df_top_genre[df_top_genre['TopGenre'] == 1]\n\n# violin plot\nfig, ax = plt.subplots(figsize=(15,6))\n\nfig.patch.set_facecolor(bg_color)\nax.set_facecolor(bg_color)\n\nsns.violinplot(data=data, x='Genre', y='IMDB Score', palette=colors, saturation=0.5, ax=ax)\n\nax.set_ylabel('')\nax.set_xlabel('')\nax.tick_params(axis='x',length=0)\n\n# despine\nfor spine in ['top','left','right']:\n    ax.spines[spine].set_visible(False)\n\n# Text & Titles\nfig.text(\n    s=':Genres vs. IMDB Score',\n    x=0.1, y=1.1,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    Documentaries are the highest scoring genre,\n    but we can spot a few outliers (low scores) too.\n    ''',\n    x=0.09, y=1.02,\n    color=txt_color\n)\n\nplt.show()","177ffc3b":"# !pip install squarify\n# import squarify\n\nfig = plt.figure(figsize=(15,10))\n\ngs = gridspec.GridSpec(nrows=2, ncols=2, height_ratios=[3,1])\n\nax0 = fig.add_subplot(gs[0,:])\nax1 = fig.add_subplot(gs[1,0])\nax2 = fig.add_subplot(gs[1,1])\n\nfig.patch.set_facecolor(bg_color)\nfig.subplots_adjust(wspace=0.2, hspace=0.1)\nax0.set_facecolor(bg_color)\nax1.set_facecolor(bg_color)\nax2.set_facecolor(bg_color)\n\n# create labels for treemap\nlabels = [label +'\\n#'+ str(count) +' Titles' for label, count in zip(df_language['Language'],df_language['Count'])]\n\n# create treemap\nsquarify.plot(\n    sizes=df_language['Count'], label=labels, color=colors, \n    pad=True, ax=ax0, text_kwargs=dict(color='white', fontsize=13, fontweight='light'))\n\n# average runtime\nax1.bar(\n    x=df_language['Language'], height=df_language['MeanRuntime'],\n    color='#000', edgecolor='#000', lw=1, alpha=0.45\n)\n\n\nax1.tick_params(length=0)\nax1.set_yticks([])\nax1.set_ylabel('')\n\n# average scores\nax2.bar(\n    x=df_language['Language'], height=df_language['MeanScore'],\n    color='#000', edgecolor='#000', lw=1, alpha=0.45\n)\n\nax2.tick_params(length=0)\nax2.set_yticks([])\nax2.set_ylabel('')\n\n# annotations\nfor idx in range(0,len(df_language['Language'])):\n    ax1.annotate(\n        s=f\"\u00d8 {int(df_language['MeanRuntime'][idx])} min\",\n        xy=(df_language['Language'][idx], 60),\n        rotation=90,\n        va='center', ha='center',\n        color='#fff', fontsize=9\n    )\n    ax2.annotate(\n        s=f\"\u00d8\\n{np.round(df_language['MeanScore'][idx],1)}\",\n        xy=(df_language['Language'][idx], 4),\n        va='center', ha='center',\n        color='#fff', fontsize=9\n    )\n    \n# despine\nax0.axis('off')\nfor spine in ['top','left','right']:\n    ax1.spines[spine].set_visible(False)\n    ax2.spines[spine].set_visible(False)\n\n# Text & Titles\nfig.text(\n    s=':TOP 5 - Languages',\n    x=0.1, y=0.975,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    by number of titles (size)\n    average score and runtime\n    ''',\n    x=0.09, y=0.925,\n    color=txt_color\n)\n\nfig.text(\n    s='avg. Runtime',\n    rotation=90,\n    x=0.1075, y=0.2,\n    color=txt_color,\n    fontsize=9,alpha=0.5\n)\n\nfig.text(\n    s='avg. Score',\n    rotation=90,\n    x=0.5275, y=0.2,\n    color=txt_color,\n    fontsize=9,alpha=0.5\n)\n\nsl1 = lines.Line2D(xdata=[0.115,0.115], ydata=[0.15,0.3], lw=1, alpha=0.25, color='#aeaeae', transform=fig.transFigure, figure=fig)\nsl2 = lines.Line2D(xdata=[0.535,0.535], ydata=[0.15,0.3], lw=1, alpha=0.25, color='#aeaeae', transform=fig.transFigure, figure=fig)\nfig.lines.extend([sl1,sl2])\n\nplt.show()","3aeb212f":"# figure, grid\nfig = plt.figure(tight_layout=True, figsize=(15,9))\ngs = gridspec.GridSpec(nrows=2, ncols=2)\n\nfig.patch.set_facecolor(bg_color)\n\nax0 = fig.add_subplot(gs[0,0])\nax1 = fig.add_subplot(gs[1,0])\nax2 = fig.add_subplot(gs[:,1])\n\n# plots\nax0 = sns.kdeplot(\n    data=df, x='Runtime', ax=ax0,\n    shade=True, color=colors[0],\n    edgecolor=colors[4], lw=1, alpha=0.8\n)\n\nax1.boxplot(\n    data=df, x='Runtime',\n    vert=False, patch_artist=True,\n    boxprops=dict(facecolor=colors[4], color='#fff', lw=0),\n    whiskerprops=dict(color='gray', lw=1, ls='--'),\n    capprops=dict(color='gray', lw=1, ls='--'),\n    medianprops=dict(color='#fff', lw=2),\n    flierprops=dict(markerfacecolor=colors[0],alpha=0.75)\n)\n\nax2.scatter(\n    y=df['Runtime'], x=df['IMDB Score'],\n    color=colors[3], alpha=0.5, s=1*df['Runtime']\n)\n\n# Text & Titles\nfig.text(\n    s=':Runtime - Distribution & Relation',\n    x=0, y=1.1,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    as we can see the runtime is negatively skewed with\n    outliers to the left. From the scatterplot we can tell\n    that there is no relation between runtime and IMDB-Score.\n    ''',\n    x=0, y=1.02,\n    color=txt_color\n)\n\nfig.text(\n    s='''\n    IMDB Score vs. Runtime\n    ''',\n    x=0.535, y=0.89,\n    color=txt_color\n)\n\nfig.text(\n    s='''\n    Runtime Distribution\n    ''',\n    x=0.05, y=0.89,\n    color=txt_color\n)\n\nfig.text(\n    s='''\n    Runtime Outliers\n    ''',\n    x=0.05, y=0.34,\n    color=txt_color\n)\n\n# seperation lines\nsl1 = lines.Line2D(xdata=[0.535,0.535], ydata=[0.85,0.95], lw=1, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nsl2 = lines.Line2D(xdata=[0.05,0.05], ydata=[0.85,0.95], lw=1, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nsl3 = lines.Line2D(xdata=[0.05,0.05], ydata=[0.3,0.4], lw=1, alpha=0.5, color='#aeaeae', transform=fig.transFigure, figure=fig)\nfig.lines.extend([sl1,sl2,sl3])\n\n# ax colors\nax0.set_facecolor(bg_color)\nax1.set_facecolor(bg_color)\nax2.set_facecolor(bg_color)\n\n# labels & ticks\nax0.set_xlabel('')\nax0.set_ylabel('')\nax0.set_yticks([])\n\nax1.set_yticks([])\nax1.set_xticks([])\n\nax2.set_yticks([])\n\nax0.tick_params(length=0, colors=txt_color)\nax2.tick_params(length=0, colors=txt_color)\n\n# despine\nfor spine in ['top','left','right','bottom']:\n    ax1.spines[spine].set_visible(False)\n    \nfor spine in ['top','left','right']:\n    ax0.spines[spine].set_visible(False)\n    ax2.spines[spine].set_visible(False)\n\nax2.spines['bottom'].set_color(txt_color)\nax2.spines['bottom'].set_alpha(0.25)\n\nplt.show()","d081509f":"df_month = df.groupby('Month').mean()[['IMDB Score']].reset_index()\n\nfig, ax = plt.subplots(figsize=(15,6))\n\nfig.patch.set_facecolor(bg_color)\nax.set_facecolor(bg_color)\n\nax.plot(data=df_month['Month'], y1=df_month['IMDB Score'], color=colors[4], lw=10)\nax.fill_between(x=np.arange(0,12), y1=df_month['IMDB Score'], color=colors[0], alpha=0.05, label='avg. Score')\n\nsns.swarmplot(data=df, x='Month', y='IMDB Score', palette=colors, ax=ax)\n\nax.set_ylabel('')\nax.set_xlabel('')\nax.set_ylim(0,8)\nax.tick_params(axis='both',length=0)\n\n# despine\nfor spine in ['top','left','right']:\n    ax.spines[spine].set_visible(False)\n\n# Text & Titles\nfig.text(\n    s=':Month vs. IMDB Score',\n    x=0.1, y=1.1,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    The average score is distributed\n    evenly across the different month.\n    One can see a small peak around June\n    and October, but there is no strong\n    relation to the IMDB Score evident.\n    ''',\n    x=0.09, y=0.94,\n    color=txt_color\n)\n\nplt.legend(loc='lower center',frameon=False)\nplt.show()","cb705ba5":"df_day = df.groupby('DayName').mean()[['IMDB Score']].reset_index()\n\nfig, ax = plt.subplots(figsize=(15,6))\n\nfig.patch.set_facecolor(bg_color)\nax.set_facecolor(bg_color)\n\nsns.swarmplot(data=df, x='DayName', y='IMDB Score', palette=colors, ax=ax)\n\nax.plot(data=df_day['DayName'], y1=df_day['IMDB Score'], color=colors[4], lw=10)\nax.fill_between(x=df_day['DayName'], y1=0, y2=df_day['IMDB Score'], color=colors[0], alpha=0.05, label='avg. Score')\n\nax.set_ylim(0,8)\n\nax.set_ylabel('')\nax.set_xlabel('')\nax.tick_params(axis='both',length=0)\n\n# despine\nfor spine in ['top','left','right']:\n    ax.spines[spine].set_visible(False)\n\n# Text & Titles\nfig.text(\n    s=':Day vs. IMDB Score',\n    x=0.1, y=1.1,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    Friday is release day. The average score\n    is relatively even distributed, however\n    wednesday seems to be a bad day for a new movie.\n    ''',\n    x=0.09, y=0.98,\n    color=txt_color\n)\n\nplt.legend(loc='lower center',frameon=False)\nplt.show()","6bd2b2dc":"# preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import OrdinalEncoder, OneHotEncoder\n\n# prepare dataset\nX = df.drop(columns=['Title', 'Premiere','DayName','IMDB Score'])\ny = df['IMDB Score']\n\n# split into train and test\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True, random_state=1)\n\n# encoder = OrdinalEncoder(handle_unknown='use_encoded_value',unknown_value=999,dtype='int')\n# X_train[['Genre','Language']] = encoder.fit_transform(X=X_train[['Genre','Language']])\n# X_test[['Genre','Language']] = encoder.transform(X=X_test[['Genre','Language']])\n\nencoder = OneHotEncoder(handle_unknown='ignore')\nX_train = encoder.fit_transform(X=X_train)\nX_test = encoder.transform(X=X_test)","540ac874":"# fit decisiontree based models\nfrom sklearn.metrics import mean_squared_error\nfrom lightgbm import LGBMRegressor\nfrom catboost import CatBoostRegressor\nfrom xgboost import XGBRegressor\nfrom sklearn.ensemble import RandomForestRegressor\n\nmodels = [\n    ('lgbm',LGBMRegressor()),\n    ('catb',CatBoostRegressor(verbose=0)),\n    ('xgb',XGBRegressor(verbosity=0)),\n    ('RF',RandomForestRegressor(verbose=0))\n]\n\nresults = dict()\n\nfor name, model in models:\n    model.fit(X_train, y_train)\n    y_hat = model.predict(X_test)\n    rmse = mean_squared_error(y_test, y_hat, squared=False)\n    results[name] = rmse","ed3273f5":"df_results = pd.DataFrame([results])\ndf_results = df_results.transpose()\ndf_results = df_results.rename(columns={0:'RMSE'})\n\nfig, ax = plt.subplots(figsize=(12,6))\n\nax = sns.barplot(\n    data=df_results,\n    x='RMSE',\n    y=df_results.index,\n    color=colors[0],\n    saturation=0.5,\n    ax = ax\n)\n\nfor idx in range(0, len(df_results['RMSE'])):\n    ax.annotate(\n        s=f\"{np.round(df_results['RMSE'][idx],2)}\",\n        xy=(df_results['RMSE'][idx]-0.05,idx),\n        va='center', ha='right',\n        color='#fff'\n    )\n\n# Text & Titles\nfig.text(\n    s=':Model Evaluation - RMSE',\n    x=0.1, y=1.05,\n    color=txt_color,\n    fontsize=17, fontweight='bold'\n)\n\nfig.text(\n    s='''\n    CatBoost performs best with an RMSE of 0.92,\n    followed by LGBM (0.95) and RandomForest(0.96)\n    ''',\n    x=0.09, y=0.96,\n    color=txt_color\n)\n\nax.set_xlabel('')\nax.set_xticks([])\nax.tick_params(length=0)\n\nfor spine in ['top','left','right','bottom']:\n    ax.spines[spine].set_visible(False)\n\nplt.show()","4b84ad23":"#### <div style='background:#5c5c5c;color:white;padding:0.5em;border-radius:0.2em'>Premiere (Time)<\/div>","65442b57":"#### <div style='background:#5c5c5c;color:white;padding:0.5em;border-radius:0.2em'>Titles<\/div>","b1d66dcb":"#### <div style='background:#5c5c5c;color:white;padding:0.5em;border-radius:0.2em'>Languages<\/div>","6eab480e":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Color Palettes<\/div>","a45f0ad8":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Modeling<\/div>","8cc9c284":"I had a **lot of fun** working with this (small) dataset and I put a lot of **effort into the visuals**.<br>\nIn terms of **predicting** the IMDB Score, the size of the dataset and the sparse feature-set was noticeable.<br>\nTo **improve model performance** one would have to gather more and more relevant (correlating) training data\nas well as tune some hyperparameters.","e0c82d9a":"<div style='border-radius:3px;background:#b1d3e3;padding:2em;text-align:left;font-family:monospace;font-weight:light;font-size:1.1em;color:black'>\n    <b>Thanks for checking out my notebook!<\/b><br>\n    Feel free to leave a comment, a suggestion, an upvote or just a simple message to say hello :)\n<\/div>","52dae80a":"## When I'm not on Kaggle, well I'm watching ... Netflix\n\n\n...with this dataset in particular I wanted to put special **emphasis on the 'Exploratory Analysis'** trying to produce\nnot only appealing but also meaningful visuals.<br><br> \nSome questions I'll try to answer are the following:\n\n* Which genres are the most common and\/or most successfull?\n* What's the most common language?\n* What's the average runtime per genre\/language?\n* Are there special relations between some of the features and our target variable the IMDB Score?\n\nAfter an thorough analysis I will also try to **predict the IMDB Score**.\nTherefore I will build some baseline models and compare the performance in the end.\n\nThank you already for checking out my notebook. Feel free to leave a comment, an upvote or just say hi :)\n\n**Take a look at some of my other work here:**\n* [Water-Quality EDA & Model-Comparison](https:\/\/www.kaggle.com\/mlanhenke\/waterquality-eda-baseline-model-comparison)\n* [Student-Test-Scores - EDA & Score Prediction](https:\/\/www.kaggle.com\/mlanhenke\/test-scores-epic-eda-prediction-cb-xgb-lgbm)","74a86d8c":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Feature Analysis<\/div>","f641e0f4":"#### <div style='background:#5c5c5c;color:white;padding:0.5em;border-radius:0.2em'>Genres<\/div>","29d43be6":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Basic Overview<\/div>","88ec2e9f":"...to analyze this dataset we have to create some time-features before. So let's get to work","a5b02b8d":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Conclusion<\/div>","a07ba7b4":"#### <div style='background:#5c5c5c;color:white;padding:0.5em;border-radius:0.2em'>Runtime<\/div>","c685f278":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Import Data<\/div>","5a4a39a7":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Target Analysis: IMDB Score<\/div>","7f5a1628":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Feature Engineering<\/div>","3b538e12":"## <div style='background:#2b6684;color:white;padding:0.5em;border-radius:0.2em'>Introduction<\/div>"}}