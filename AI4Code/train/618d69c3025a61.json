{"cell_type":{"2f9b5662":"code","2cfa0ec0":"code","b4932e86":"code","366f8fc3":"code","bf806396":"code","c99a83f7":"code","71080026":"code","e79d6e5d":"code","ca54df5f":"code","914f374f":"code","fd51f068":"code","68e2da77":"code","7d3ec21b":"code","9e680ea4":"code","3f4eb59e":"code","e767267a":"code","f10d8641":"code","a7a26b63":"code","63fc9c6f":"code","00e36652":"code","bc4423e7":"code","056d8e72":"code","dae31396":"code","1b95532f":"code","f8d85419":"code","ffd22259":"code","84369b5b":"code","b3bb2b2c":"code","1b1da3dc":"code","4b90c169":"code","21d0f212":"code","3b2e1e4f":"code","6d1ea85e":"code","34c7658a":"code","f7e6621f":"code","dfc0ae6e":"code","0f65ada5":"code","3c04a02b":"code","e7e51805":"code","91818e14":"code","7bfbc2a7":"code","812e4acc":"code","f2cc3a0b":"code","537eb7e5":"code","de13987a":"code","c9b6bd53":"code","229cac5e":"code","ffd37048":"code","8cbffce5":"code","ce99b34f":"code","7b9dbea9":"code","9d5e9048":"code","ed03ffce":"code","2daff260":"code","6b9dfe1b":"code","899b90cf":"code","7e7f51e9":"code","e73ac320":"code","59f121a0":"markdown","bd4eb4a3":"markdown","fa487c06":"markdown","fe4a33bb":"markdown","5098f3ef":"markdown","489a2eb3":"markdown","a877cab5":"markdown","b713df72":"markdown","cde48083":"markdown","ecef7940":"markdown","13d1832f":"markdown","8fcd8904":"markdown","2713abf5":"markdown","180d7b01":"markdown","40c0f1ca":"markdown","c961b680":"markdown","1c0b1561":"markdown","70497429":"markdown","33bbbf18":"markdown","9cd1664f":"markdown","e5de1fa1":"markdown","6b2e2ca0":"markdown","8153de4f":"markdown","84d80782":"markdown","3e222adf":"markdown","dd434218":"markdown","15df0607":"markdown","75ff7def":"markdown","ddf18ffa":"markdown","0f3517db":"markdown","02cfe81e":"markdown","6dda2186":"markdown","f0699129":"markdown","a074f0cc":"markdown","bcbd97e1":"markdown","35ca2c80":"markdown","481732b3":"markdown","e21c94a3":"markdown"},"source":{"2f9b5662":"import warnings\nwarnings.filterwarnings('ignore')\n\nimport numpy as np\nimport pandas as pd\nimport tqdm.notebook as tqdm\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split, GroupKFold, KFold\nfrom sklearn import metrics\nimport tensorflow as tf\nfrom tensorflow import keras\n\nplt.rcParams.update({'font.size': 18})\nplt.style.use('ggplot')\n\npd.set_option('display.max_colwidth',None)","2cfa0ec0":"train = pd.read_csv('..\/input\/ventilator-pressure-prediction\/train.csv')\ntest = pd.read_csv('..\/input\/ventilator-pressure-prediction\/test.csv')\n\nprint(train.shape, test.shape)","b4932e86":"train.head(2)","366f8fc3":"test.head(2)","bf806396":"train.isnull().sum()\ntest.isnull().sum()","c99a83f7":"unique_breath_id = train['breath_id'].nunique()\nprint('Number of unique breath IDs in train are: ', unique_breath_id)\n\nunique_breath_id_test = test['breath_id'].nunique()\nprint('Number of unique breath IDs in test are: ', unique_breath_id_test)","71080026":"train_breath_id = [x for x in (np.unique(train['breath_id']))]\ntest_breath_id = [x for x in (np.unique(test['breath_id']))]","e79d6e5d":"print(len(list(set(test_breath_id) - set(train_breath_id))))","ca54df5f":"set(test_breath_id).intersection(train_breath_id)","914f374f":"train.pressure.hist(figsize=(16, 4))","fd51f068":"sns.kdeplot(train['pressure'])","68e2da77":"sns.kdeplot(train['R'].to_numpy(), color = 'red')\nsns.kdeplot(test['R'].to_numpy(), color = 'green')","7d3ec21b":"sns.kdeplot(train['C'].to_numpy(), color = 'red')\nsns.kdeplot(test['C'].to_numpy(), color = 'green')","9e680ea4":"sns.countplot(train['R'])","3f4eb59e":"sns.countplot(test['R'])","e767267a":"sns.countplot(train['u_out'])","f10d8641":"sns.countplot(test['u_out'])","a7a26b63":"corr = train.corr().abs()\nfig = plt.figure()\nax = fig.add_subplot(111)\ncax = ax.matshow(corr,cmap='coolwarm', vmin=-1, vmax=1)\nfig.colorbar(cax)\nticks = np.arange(0,len(train.columns),1)\nax.set_xticks(ticks)\nplt.xticks(rotation=90)\nax.set_yticks(ticks)\nax.set_xticklabels(train.columns)\nax.set_yticklabels(train.columns)\nplt.show()","63fc9c6f":"corr","00e36652":"train.pressure.max()","bc4423e7":"breath_id_1 = train[train['breath_id'] == 1]\nbreath_id_1.head()","056d8e72":"breath_id_1.shape","dae31396":"fig, ax1 = plt.subplots(figsize = (6, 4))\nax2 = ax1.twinx()\nax1.plot(breath_id_1['time_step'], breath_id_1['pressure'], 'm-', label='pressure')\nax1.plot(breath_id_1['time_step'], breath_id_1['u_in'], 'g-', label='u_in')\nax2.plot(breath_id_1['time_step'], breath_id_1['u_out'], 'b-', label='u_out')\n\nax1.set_xlabel('Timestep')\n\nR = breath_id_1['R'][0]\nC = breath_id_1['C'][0]\nax1.set_title(f'breath_id:{1}, R:{R}, C:{C}')\n\nax1.legend(loc=(1.1, 0.8))\nax2.legend(loc=(1.1, 0.7))\nplt.show()","1b95532f":"sns.lineplot(x = 'id',y='pressure',data=breath_id_1[breath_id_1['u_out']==0],color='green',label='inhale pressure');\nsns.lineplot(x = 'id',y='pressure',data=breath_id_1[breath_id_1['u_out']==1],color='orange',label='exhale pressure');\nsns.lineplot(x = 'id',y='u_in',data=breath_id_1,color='blue',label='valve pressure')\nplt.title(f\"Variation of Pressure and Input valve position during breath Id 1\");\nplt.show()","f8d85419":"plt.title(f'breath_id:{1}, Time Step Plot')\nplt.ylabel('Timestep')\nplt.xlabel('Row No.')\nplt.plot(breath_id_1['time_step'])\nplt.show()","ffd22259":"plt.figure(figsize = (10,5))\nsns.histplot(data=train,x='time_step', bins=20)\nplt.show()","84369b5b":"train.groupby(\"breath_id\")[\"time_step\"].count()","b3bb2b2c":"print(\"For train max time_step: \",train.time_step.max())\nprint(\"For test max time_step: \",test.time_step.max())","1b1da3dc":"print(train.nunique().to_frame())\nprint('------------------------------')\nprint(test.nunique().to_frame())","4b90c169":"train.columns.values","21d0f212":"def feature_engineering(df):\n    # adding feature last_value_u_in\n    \n    # for each breath fetching maximum time_step value\n    idxmax_time_step = df.groupby('breath_id')['time_step'].idxmax()\n    # for a maximum time_step value this column is fetching associated breath_id & u_in\n    last_value_u_in = df.loc[idxmax_time_step, ['breath_id','u_in']]\n    last_value_u_in.columns = ['breath_id','last_value_u_in']\n    df = df.merge(last_value_u_in, on='breath_id')\n    \n    \n    # adding feature mean_value_u_in\n    \n    mean_u_in = df.groupby('breath_id')['u_in'].mean().to_frame()\n    mean_u_in.columns = ['mean_value_u_in']\n    df = df.merge(mean_u_in,on='breath_id')\n    \n    \n    # adding feature 'diff_u_in'\n    # this is basically, u_in[1] = u_in[1] - u_in[0], u_in[2] = u_in[2] - u_in[1] ...\n    df['diff_u_in'] = df.groupby('breath_id')['u_in'].diff()\n    df = df.fillna(0)\n    \n    \n    # adding feature 'diff_diff_u_in'\n    # i.e. \n    df['diff_diff_u_in'] = df.groupby('breath_id')['diff_u_in'].diff()\n    df = df.fillna(0)\n    \n    \n    # adding feature cummulative sum 'u_in_cumsum'\n    df['u_in_cumsum'] = df.groupby(['breath_id'])['u_in'].cumsum()\n    \n    \n    # adding feature sum_value_u_in\n    # sum of all u_in values for a particular breath_id\n    sum_u_in = df.groupby('breath_id')['u_in'].sum().to_frame()\n    sum_u_in.columns = ['sum_value_u_in']\n    df = df.merge(sum_u_in,on='breath_id')\n    \n    \n    # adding feature u_in_cumsum_rate\n    df['u_in_cumsum_rate'] = df['u_in_cumsum'] \/ df['sum_value_u_in']\n    \n    \n    df = df.fillna(0)\n    \n    \n    #adding feature lag_u_in\n    df['lag_u_in'] = df.groupby('breath_id')['u_in'].shift(1)\n    df = df.fillna(0)\n    \n    \n    #adding feature lag2_u_in\n    df['lag2_u_in'] = df.groupby('breath_id')['u_in'].shift(2)\n    df = df.fillna(0)\n    \n    \n    #adding feature lag_-1_u_in\n    df['lag_-1_u_in'] = df.groupby('breath_id')['u_in'].shift(-1)\n    df = df.fillna(0)\n    \n    \n    #adding feature lag_-2_u_in\n    df['lag_-2_u_in'] = df.groupby('breath_id')['u_in'].shift(-2)\n    df = df.fillna(0)\n    \n    \n    #adding feature lag3_u_in\n    df['lag3_u_in'] = df.groupby('breath_id')['u_in'].shift(3)\n    df = df.fillna(0)\n    \n    \n    #adding feature lag2_u_in\n    df['lag_-3_u_in'] = df.groupby('breath_id')['u_in'].shift(-3)\n    df = df.fillna(0)\n    \n    \n    #adding feature max_u_in_breath_id\n    # maximum u_in value for a particular breath_id\n    df['max_u_in_breath_id'] = df.groupby('breath_id')['u_in'].transform('max')\n    \n    \n    #adding feature R*C\n    df['R*C'] = df['R'] * df['C']\n    \n    \n    #adding feature min_u_in_breath_id\n    # minimum u_in value for a particular breath_id\n    df['min_u_in_breath_id'] = df.groupby('breath_id')['u_in'].transform('min')\n    \n    \n    #adding max_u_in_breath_id_diff\n    df['max_u_in_breath_id_diff'] = df.groupby('breath_id')['u_in'].transform('max') - df['u_in']\n    \n    \n    #adding mean_u_in_breath_id_diff\n    df['mean_u_in_breath_id_diff'] = df.groupby('breath_id')['u_in'].transform('mean') - df['u_in']\n    \n    \n    #adding u_in_partition_out_sum\n    df['u_in_partition_out_sum'] = df.groupby(['breath_id', 'u_out'])['u_in'].transform('sum')\n    \n    \n    #adding area\n    df['area'] = df['time_step'] * df['u_in']\n    df['area'] = df.groupby('breath_id')['area'].cumsum()\n    \n    return df\n","3b2e1e4f":"df_train = feature_engineering(train)\ndf_test = feature_engineering(test)","6d1ea85e":"df_train","34c7658a":"df_train.shape","f7e6621f":"df_train.columns","dfc0ae6e":"df_test","0f65ada5":"models = []\ncolumns = [col for col in df_train.columns if col not in ['id', 'breath_id', 'pressure']]\nX = df_train[columns]\ny = df_train['pressure']","3c04a02b":"print(X.shape, y.shape)","e7e51805":"prediction = []","91818e14":"X_test = df_test[columns]","7bfbc2a7":"X_test","812e4acc":"X_test.shape","f2cc3a0b":"X = np.array(X)\nX = X.reshape(-1, 80, X.shape[-1])\ny = y.to_numpy().reshape(-1, 80)\nX_test = np.array(X_test)\nX_test = X_test.reshape(-1, 80, X_test.shape[-1])\n\nprint(X.shape, y.shape, X_test.shape)","537eb7e5":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print('Device:', tpu.master())\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nexcept:\n    strategy = tf.distribute.get_strategy()\nprint('Number of replicas:', strategy.num_replicas_in_sync)","de13987a":"with strategy.scope(): \n    folds = KFold(n_splits=5, shuffle=True, random_state=2021)\n\n    for fold_n, (train_index, valid_index) in enumerate(folds.split(X, y)):\n        print(f'------------------ Fold {fold_n} ------------------')\n        X_train, X_valid =  X[train_index], X[valid_index]\n        y_train, y_valid = y[train_index], y[valid_index]\n\n        scheduler = tf.keras.optimizers.schedules.ExponentialDecay(1e-3, 200*((len(X_train)*0.8)\/1024), 1e-5)\n        model = keras.models.Sequential([\n            keras.layers.Input(shape=(80, 25)),\n            keras.layers.Bidirectional(keras.layers.LSTM(200, return_sequences=True)),\n            keras.layers.Bidirectional(keras.layers.LSTM(150, return_sequences=True)),\n            keras.layers.Bidirectional(keras.layers.LSTM(100, return_sequences=True)),\n            keras.layers.Dense(100, activation='relu'),\n            keras.layers.Dense(1),\n        ])\n        model.compile(optimizer=\"adam\", loss=\"mae\")\n        model.fit(X_train, y_train,\n                  validation_data=(X_valid, y_valid),\n                  epochs = 180,\n                  batch_size = 256,\n                  callbacks=[tf.keras.callbacks.LearningRateScheduler(scheduler)])\n#         model.save(f'Fold {fold_n+1} Weights')\n\n\n        prediction.append(model.predict(X_test).squeeze().reshape(-1, 1).squeeze())\n        models.append(model)\n","c9b6bd53":"model.summary()","229cac5e":"submission = pd.read_csv('..\/input\/ventilator-pressure-prediction\/sample_submission.csv')\nsubmission.head()","ffd37048":"prediction","8cbffce5":"len(prediction[0])","ce99b34f":"len(prediction)","7b9dbea9":"mean = np.mean(prediction, axis=0)\nmed = np.median(prediction, axis=0)\nstd = np.std(prediction, axis=0)\n\n\n\n# mean of values inside the standard mean\nclipped_pres = np.clip(np.vstack(prediction), mean-std, mean+std)\nclipped_mean = np.mean(clipped_pres, axis=0)","9d5e9048":"print('clipped mean is: ', clipped_mean)","ed03ffce":"clipped_pres","2daff260":"prediction_ = clipped_pres.ravel()\nprediction_","6b9dfe1b":"submission_ = pd.DataFrame({\"id\":submission[\"id\"],\"pressure\":clipped_mean})","899b90cf":"submission_","7e7f51e9":"submission_.shape","e73ac320":"submission_.to_csv('submission.csv', index = False)\nprint('submission saved -- !')","59f121a0":"#### Checking if all the `breath_id` from `test` is present in `train`\n\nNo `breath_id` of `test` are included in `train`","bd4eb4a3":"making an empty array for storing prediction values.","fa487c06":"we can see that we have 80 unique `time_step` per breath.","fe4a33bb":"# <a name=\"eda\"><\/a><mark style=\"background: #FFBF00\">Exploratory Data Analysis<\/mark>","5098f3ef":"# <a name=\"process\"><\/a><mark style=\"background: #FFBF00\">Data Processing<\/mark>","489a2eb3":"Defining `X_test` to make prediction on `df_test`","a877cab5":"We can see from the plot above that when valve is closed the pressure on valve is higher and when opened the pressure decreases.","b713df72":"Max `pressure`","cde48083":"#### Checking for unique `breath_id`","ecef7940":"`time_step` value ranges from 0 ~ 3","13d1832f":"#### Countplot on columns","8fcd8904":"### Breath Plot\n\nlets plot a breath with a `breath_id == 1` \n\nI took help from the kernel [here](https:\/\/www.kaggle.com\/marutama\/eda-about-time-step-and-u-out)","2713abf5":"Maximum `time_step` | how long a breath last?","180d7b01":"Applying the above features to `train` and `test` data","40c0f1ca":"#### `pressure` hiatogram","c961b680":"## <mark style=\"background: #d9ead3\">Motiavtion<\/mark>\n\nWhen a patient has trouble breathing the doctors use a ventilator to pump oxygen into patient's lungs. However, this procedure is operated by the help of a clinician, which is a limitation.   The current simulators are not dynamic they are modeled to simulate a single lung setting. In reality, lungs and its attributes vary from patient to patient.                                                                                                                                 \n## <mark style=\"background: #d9ead3\">Goal<\/mark>\n\nIn this competition, our goal is to simulate a ventilator connected to a sedated patient's lung. By taking lungs attributes and other constraints in account we should simulate a mechanical ventilator that can take burdens off of clinicians.\n\nAs a result, ventilator treatments may become more widely available to help patients breathe.","1c0b1561":"Here `R` and `C` are categorical features","70497429":"# <mark style=\"background: #FFBF00\">Contents<\/mark>\n- [Imports](#import)\n- [Explaining the Attributes](#explain)\n- [Exploratory Data Analysis](#eda)\n- [Data Processing](#process)\n- [Model Creation](#model)\n- [Prediction](#prediction)\n- [Submission](#sub)","33bbbf18":"there are no null values","9cd1664f":"### feature engineering on train data:\n\n[Really helpful kernel](https:\/\/www.kaggle.com\/yasuosuzuki\/various-feature-and-lightgbm)","e5de1fa1":"`R` for `test`","6b2e2ca0":"### <a name=\"explain\"><\/a><mark style=\"background: #FFBF00\">Explaining the attributes<\/mark>\n\n**The columns**\n\n- id - globally-unique time step identifier across an entire file\n- breath_id - globally-unique time step for breaths\n- R - lung attribute indicating how restricted the airway is (in cmH2O\/L\/S). Physically, this is the change in pressure per change in flow (air volume per time). Intuitively, one can imagine blowing up a balloon through a straw. We can change R by changing the diameter of the straw, with higher R being harder to blow. \n> (Basically, the diameter of the airway of the lung)\n\n- C - lung attribute indicating how compliant the lung is (in mL\/cmH2O). Physically, this is the change in volume per change in pressure. Intuitively, one can imagine the same balloon example. We can change C by changing the thickness of the balloon\u2019s latex, with higher C having thinner latex and easier to blow. \n> (Basically, the thickness of the airway (i.e. how thivk or thin is the airway))\n\n- time_step - the actual time stamp.\n\n    **The below two columns are control input.**\n\n- u_in - the control input for the inspiratory solenoid valve. Ranges from 0 to 100. \n> (Basically, represents the opening state of the inspiratory valve. 0 being completely closed, no air can get in. 100 is when the valve is completely open).\n\n- u_out - the control input for the exploratory solenoid valve. Either 0 or 1. \n> (Basically, represents the opening state of the exploratory valve. 1 --> valve open and 0 --> valve closed,\n\n- pressure - the airway pressure measured in the respiratory circuit, measured in cmH2O.","8153de4f":"Defining `X` and `y` for model creation. \n\nNot including columns like `id`, `breath_id`, `pressure` for `X`\n\n`y` has the `pressure` column only from `df_train`","84d80782":"# <a name=\"prediction\"><\/a><mark style=\"background: #FFBF00\">Prediction<\/mark>","3e222adf":"To well develop the prediction I will first calculate the `mean` and `median` of the prediction values. Once this has been done the `standard deviation` of the prediction will be calculated and will be clipped within this range to finally calculate the average of `clipped data`.\n\n[Reference Kernel](https:\/\/github.com\/angliu-bu\/Kaggle-Google-Brain\/blob\/main\/google_brain.ipynb)","dd434218":"`u_out` for `test`","15df0607":"Kdeplot is a Kernel Distribution Estimation Plot which depicts the probability density function of the continuous or non-parametric data variables.\n\nKdeplot plot for `pressure`","75ff7def":"# <a name=\"sub\"><\/a><mark style=\"background: #FFBF00\">Submission<\/mark>","ddf18ffa":"choosing the `clipped_mean` for `pressure` prediction","0f3517db":"Reshaping the `X` and `y` variables","02cfe81e":"By looking at the correlation plot below we can see that `u_out` and `time_step` has kind of strong correlation.","6dda2186":"# <a name=\"model\"><\/a><mark style=\"background: #FFBF00\">Model Creation<\/mark>","f0699129":"### TPU setup","a074f0cc":"# <a name=\"import\"><\/a><mark style=\"background: #FFBF00\">Imports<\/mark>","bcbd97e1":"reading the given `train` and `test` files","35ca2c80":"I have used the below kernels as inspiration to make the model:\n\n- [kernel 1](https:\/\/www.kaggle.com\/kaitohonda\/beginner-lgbm)\n- [kernel 2](https:\/\/www.kaggle.com\/coder247\/simple-xgboost-solution-for-beginner-s)\n","481732b3":"Time step plot for `breath_id_1`","e21c94a3":"Reference kernel [here](https:\/\/www.kaggle.com\/ahmedaffan789\/google-brain-eda-lstm-bi-directional)\n\nAs described above `u_in` == valve pressure\n\nSo, when `u_in == 0` then the valve is closed and that is inhale pressure from the patient (patient inhales)\n\nand, when `u_in == 1` then the valve is open and that is exhale pressure from the patient (patient exhales)"}}