{"cell_type":{"993296d3":"code","0449a06d":"code","4c378c93":"code","739f9a8f":"code","d24e389c":"code","5d629492":"code","83aefde6":"code","040dd4b5":"code","c9ae3f9f":"markdown","70b8e4f4":"markdown","ac4163df":"markdown","9d901f26":"markdown","41e97b36":"markdown","b642a8d0":"markdown","58e473c3":"markdown","b44f9387":"markdown"},"source":{"993296d3":"import os\nimport cv2\nimport numpy as np","0449a06d":"train_dir = \"\/kaggle\/input\/deepfake-detection-challenge\/train_sample_videos\"\nvideo_path = os.path.join(train_dir, np.random.choice(os.listdir(train_dir)))\nvideo_path","4c378c93":"def grab_frames_from_video(path, num_frames=10):\n    capture = cv2.VideoCapture(path)\n    frame_count = int(capture.get(cv2.CAP_PROP_FRAME_COUNT))\n    frame_idxs = np.linspace(0, frame_count, num_frames, endpoint=False, dtype=np.int)\n\n    i = 0\n    for frame_idx in range(int(frame_count)):\n        # Get the next frame, but don't decode if we're not using it.\n        ret = capture.grab()\n        if not ret: \n            print(\"Error grabbing frame %d from movie %s\" % (frame_idx, path))\n\n        # Need to look at this frame?\n        if frame_idx >= frame_idxs[i]:\n            ret, frame = capture.retrieve()\n            if not ret or frame is None:\n                print(\"Error retrieving frame %d from movie %s\" % (frame_idx, path))\n            else:\n                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n                # Do something with `frame`\n\n            i += 1\n            if i >= len(frame_idxs):\n                break\n\n    capture.release()","739f9a8f":"%time grab_frames_from_video(video_path, num_frames=10)","d24e389c":"%time grab_frames_from_video(video_path, num_frames=50)","5d629492":"# This version.\n\ndef grab_frames_from_video(path, num_frames=10):\n    capture = cv2.VideoCapture(path)\n    frame_count = int(capture.get(cv2.CAP_PROP_FRAME_COUNT))\n    frame_idxs = np.linspace(0, frame_count, num_frames, endpoint=False, dtype=np.int)\n\n    for i, frame_idx in enumerate(frame_idxs):\n        capture.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)\n        ret, frame = capture.read()\n        if not ret or frame is None:\n            print(\"Error retrieving frame %d from movie %s\" % (frame_idx, path))\n        else:\n            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n    capture.release()","83aefde6":"%time grab_frames_from_video(video_path, num_frames=10)","040dd4b5":"%time grab_frames_from_video(video_path, num_frames=50)","c9ae3f9f":"This version uses OpenCV. It looks at all the frames in the video but only decodes the ones we're interested in:","70b8e4f4":"Pick a video at random.","ac4163df":"Yeah that's 4x slower than the other method.","9d901f26":"And unlike the previous method, it gets way worse the more frames you want to look at.","41e97b36":"The next version jumps directly to the frame you want to read. You might expect this to be faster but it actually isn't. My guess is that a \"streaming\" approach is more efficient than a \"random access\" approach because, unless you happen to grab a keyframe, the decoder still needs to read all the previous frames in order to reconstruct the one you're asking for.","b642a8d0":"At least reading more frames doesn't make the time much worse...","58e473c3":"1.2 seconds for reading a single video. Ouch. With 4000 videos that is 1.5 hours to read the entire test set.","b44f9387":"# Video reading speed test\n\nSee also [this discussion topic](https:\/\/www.kaggle.com\/c\/deepfake-detection-challenge\/discussion\/122328).\n\nI currently have a face detector that takes about 30 ms for a batch of 30 images, but loading that batch from the video takes 330 ms (on my local computer). So video loading is 10x slower than doing face detection. Because we're dealing with a LOT of data in this competition, it's worthwhile to reduce any overhead where possible.\n\n> Note that loading speeds appear to be slower on Kaggle than on my local machine (1.2 seconds instead of 330 ms for the same video). Not sure why that is. On my local machine the videos are stored on HDD, not SSD."}}