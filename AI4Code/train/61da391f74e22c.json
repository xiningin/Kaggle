{"cell_type":{"0f5bc522":"code","3e25101e":"code","7678e2d7":"code","efd19638":"code","f9a624d5":"code","69217745":"code","d6de89a0":"code","3531861c":"code","42ea902c":"code","cd34d5fd":"code","4cda5c6d":"code","aed6c8eb":"code","32381e23":"code","6b09bbca":"code","e5b436e8":"code","d44693e4":"code","d407668e":"code","b19d2d63":"code","9e45f533":"code","c8011c52":"code","f2ffdcae":"code","6f766c62":"code","58134a5e":"code","a6522cc2":"code","bcc3b8bc":"code","552a2be6":"code","409ad94f":"code","4846ce21":"code","d680aead":"code","13220c40":"code","c6e2aa9d":"code","8b760a9d":"code","e499a756":"code","7a5b5d15":"code","174d588a":"code","326c82f1":"code","73a44267":"code","4a47d2c0":"code","6bbb42db":"code","7c0e1222":"code","32fc141b":"markdown","ea53434a":"markdown","7a04c2ec":"markdown","f1f83c6f":"markdown","e483b60b":"markdown","58eaf0d1":"markdown","fe566a66":"markdown","d9760e45":"markdown","28222e52":"markdown","8b0599f7":"markdown","7fb892a8":"markdown","cc281a28":"markdown","1056db1f":"markdown","7a09807b":"markdown","1892ecf9":"markdown","14e831ec":"markdown","3367e1c8":"markdown","36e68559":"markdown"},"source":{"0f5bc522":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","3e25101e":"%matplotlib inline\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\n\ndf= pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/train.csv')\ndft= pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/test.csv')","7678e2d7":"df.head()","efd19638":"print(df.shape)\nprint(dft.shape)","f9a624d5":"# We took out ID of test file as it will help us map prices of our pridiction for the submission. \n# We took out SalePrice because we added it as the the target for our label.\n# Also, IDs didnt quite help adding more value to our features. \n\na= df['Id']\nb= dft['Id']\ny= df['SalePrice']\ndf.drop({'Id'},axis=1,  inplace= True)\ndft.drop({'Id'},axis=1, inplace= True)\ndf.drop({'SalePrice'}, axis=1, inplace= True)","69217745":"cat_train= df.select_dtypes(include=['object'])\ncat_test= dft.select_dtypes(include=['object'])","d6de89a0":"print(cat_train.shape)\nprint(cat_test.shape)","3531861c":"df.isna().sum().sort_values(ascending= False)[:15]","42ea902c":"dft.isna().sum().sort_values(ascending= False)[:15]","cd34d5fd":"# As most of them are missing in these 5 features and none of them are quentessential in predicting house prices; Like if i am getting a good deal\n# of a house, i would mostly not be concerned whether it has a fence or not. \n\ndf.drop({'PoolQC', 'Alley', 'FireplaceQu', 'GarageYrBlt', 'Fence'}, axis= 1, inplace= True)\ndft.drop({'PoolQC', 'Alley', 'FireplaceQu', 'GarageYrBlt', 'Fence'}, axis= 1, inplace= True)\n\n","4cda5c6d":"# For training set\n\nfor i in range(len(df['MiscFeature'])):\n  if df['MiscFeature'][i]== 'Shed':\n   df['MiscFeature'][i] = 1\n  elif df['MiscFeature'][i] == 'TenC':\n   df['MiscFeature'][i] = 2\n  else:\n   df['MiscFeature'][i] = 0\n\n# For test set\n\nfor i in range(len(dft['MiscFeature'])):\n  if dft['MiscFeature'][i]== 'Shed':\n   dft['MiscFeature'][i] = 1\n  elif dft['MiscFeature'][i] == 'TenC':\n   dft['MiscFeature'][i] = 2\n  else:\n   dft['MiscFeature'][i] = 0","aed6c8eb":"print(df['OverallCond'].groupby(df['GarageCond']).median())\nprint(df['OverallCond'].groupby(df['GarageCond']).count())","32381e23":"# For training set\n\ndf['GarageCond'].fillna(0, inplace= True)\nfor i in range(len(df['GarageCond'])):\n  if df['GarageCond'][i] == 0:\n    if df['OverallCond'][i] <= 5:\n      df['GarageCond'][i] = 'TA'\n    elif df['OverallCond'][i] >6:\n      df['GarageCond'][i] = 'Gd'\n    elif df['OverallCond'][i] == 6:\n      df['GarageCond'][i] = 'Fa'","6b09bbca":"# For test set\n\ndft['GarageCond'].fillna(0, inplace= True)\nfor i in range(len(dft['GarageCond'])):\n  if dft['GarageCond'][i] == 0:\n    if dft['OverallCond'][i] <= 5:\n      dft['GarageCond'][i] = 'TA'\n    elif dft['OverallCond'][i] >6:\n      dft['GarageCond'][i] = 'Gd'\n    elif dft['OverallCond'][i] == 6:\n      dft['GarageCond'][i] = 'Fa'","e5b436e8":"df['GarageQual'].groupby(df['GarageCond']).value_counts()","d44693e4":"df['GarageQual'].fillna(0, inplace= True)\ndft['GarageQual'].fillna(0, inplace= True)\n\nfor i in range(len(df['GarageQual'])):\n    if df['GarageQual'][i] == 0:\n        df['GarageQual'][i] = df['GarageCond'][i]\n\nfor i in range(len(dft['GarageQual'])):\n    if dft['GarageQual'][i] == 0:\n        dft['GarageQual'][i] = dft['GarageCond'][i]","d407668e":"df['GarageArea'].groupby(df['GarageFinish']).mean()\n\n# we can see that larger garages tend to be more finished. So,","b19d2d63":"df['GarageFinish'].fillna(0, inplace= True)\ndft['GarageFinish'].fillna(0, inplace= True)\n\nfor i in range(len(df)):\n  if df['GarageFinish'][i] == 0:\n    if df['GarageArea'][i] <= 500:\n      df['GarageFinish'][i] = 'Unf'\n    elif 500 < df['GarageArea'][i] <= 555:\n      df['GarageFinish'][i] = 'RFn'\n    else:\n      df['GarageFinish'][i] = 'Fin'\n    \nfor i in range(len(dft)):\n  if dft['GarageFinish'][i] == 0:\n    if dft['GarageArea'][i] <= 500:\n      dft['GarageFinish'][i] = 'Unf'\n    elif 500 < dft['GarageArea'][i] <= 555:\n      dft['GarageFinish'][i] = 'RFn'\n    else:\n      dft['GarageFinish'][i] = 'Fin'","9e45f533":"print(df['GarageType'].value_counts())\n\nprint(df['GarageArea'].groupby(df['GarageType']).mean())","c8011c52":"df['GarageType'].fillna(0, inplace= True)\ndft['GarageType'].fillna(0, inplace= True)\n\n\nfor i in range(len(df['GarageType'])):\n  if df['GarageType'][i] == 0:\n    if df['GarageArea'][i] > 550:\n      df['GarageType'][i] = '2Types'\n    elif 400 < df['GarageArea'][i] <= 455:\n      df['GarageType'][i] = 'Detchd'\n    else:\n      df['GarageType'][i] = 'BuiltIn'\n    \nfor i in range(len(dft['GarageType'])):\n  if dft['GarageType'][i] == 0:\n    if dft['GarageArea'][i] > 550:\n      dft['GarageType'][i] = '2Types'\n    elif 400 < dft['GarageArea'][i] <= 455:\n      dft['GarageType'][i] = 'Detchd'\n    else:\n      dft['GarageType'][i] = 'BuiltIn'","f2ffdcae":"df['BsmtCond'].fillna(0, inplace= True)\ndft['BsmtCond'].fillna(0, inplace= True)\n\nfor i in range(len(df['BsmtCond'])):\n  if df['BsmtCond'][i] == 0:\n    if 1000 < df['TotalBsmtSF'][i] <= 1100:\n      df['BsmtCond'][i] = 'TA'\n    elif df['TotalBsmtSF'][i] < 840:\n      df['BsmtCond'][i] = 'Po'\n    else:\n      df['BsmtCond'][i] = 'Gd'\n    \nfor i in range(len(dft['BsmtCond'])):\n  if dft['BsmtCond'][i] == 0:\n    if 1000 < dft['TotalBsmtSF'][i] <= 1100:\n      dft['BsmtCond'][i] = 'TA'\n    elif dft['TotalBsmtSF'][i] < 840:\n      dft['BsmtCond'][i] = 'Po'\n    else:\n      dft['BsmtCond'][i] = 'Gd'","6f766c62":"df['TotalBsmtSF'].groupby(df['BsmtExposure']).median()","58134a5e":"df['BsmtExposure'].fillna(0, inplace= True)\ndft['BsmtExposure'].fillna(0, inplace= True)\n\nfor i in range(len(df['BsmtExposure'])):\n  if df['BsmtExposure'][i] == 0:\n    if df['TotalBsmtSF'][i] <= 1000:\n      df['BsmtExposure'][i] = 'No'\n    else:\n      df['BsmtExposure'][i] = 'Av'\n    \nfor i in range(len(dft['BsmtExposure'])):\n  if dft['BsmtExposure'][i] == 0:\n    if dft['TotalBsmtSF'][i] <= 1000:\n      dft['BsmtExposure'][i] = 'No'\n    else:\n      dft['BsmtExposure'][i] = 'Av'","a6522cc2":"df.drop({'BsmtFinType2'}, axis=1, inplace= True)\n\ndft.drop({'BsmtFinType2'}, axis=1, inplace= True)","bcc3b8bc":"df['TotalBsmtSF'].groupby(df['BsmtQual']).median()","552a2be6":"df['BsmtQual'].fillna(0, inplace= True)\ndft['BsmtQual'].fillna(0, inplace= True)\n\n\nfor i in range(len(df['BsmtQual'])):\n  if df['BsmtQual'][i] == 0:\n    if df['TotalBsmtSF'][i] <= 1000:\n      df['BsmtQual'][i] = 'TA'\n    elif 1000 < df['BsmtQual'][i] < 1200:\n      df['BsmtQual'][i] = 'Gd'\n    else:\n      df['BsmtQual'][i] = 'EX'\n    \nfor i in range(len(dft['BsmtQual'])):\n  if dft['BsmtQual'][i] == 0:\n    if dft['TotalBsmtSF'][i] <= 1000:\n      dft['BsmtQual'][i] = 'TA'\n    elif 1000 < dft['BsmtQual'][i] < 1200:\n      dft['BsmtQual'][i] = 'Gd'\n    else:\n      dft['BsmtQual'][i] = 'EX'","409ad94f":"df['BsmtFinSF1'].groupby(df['BsmtFinType1']).mean()","4846ce21":"df['BsmtFinType1'].fillna(0, inplace= True)\ndft['BsmtFinType1'].fillna(0, inplace= True)\n\nfor i in range(len(df['BsmtFinType1'])):\n  if df['BsmtFinType1'][i] == 0:\n    if 350 < df['BsmtFinSF1'][i] <= 550:\n      df['BsmtFinType1'][i] = 'Rec'\n    elif 550 < df['BsmtFinSF1'][i] < 620:\n      df['BsmtFinType1'][i] = 'ALQ'\n    elif 620< df['BsmtFinSF1'][i] <= 850:\n      df['BsmtFinType1'][i] = 'GLQ'\n    else:\n      df['BsmtFinType1'][i] = 'Unf'\n    \nfor i in range(len(dft['BsmtFinType1'])):\n  if dft['BsmtFinType1'][i] == 0:\n    if 350 < dft['BsmtFinSF1'][i] <= 550:\n      dft['BsmtFinType1'][i] = 'Rec'\n    elif 550 < dft['BsmtFinSF1'][i] < 620:\n      dft['BsmtFinType1'][i] = 'ALQ'\n    elif 620< dft['BsmtFinSF1'][i] <= 850:\n      dft['BsmtFinType1'][i] = 'GLQ'\n    else:\n      dft['BsmtFinType1'][i] = 'Unf'","d680aead":"df['MasVnrType'].fillna(df['MasVnrType'].mode()[0], inplace= True)\n\ndft['MasVnrType'].fillna(dft['MasVnrType'].mode()[0], inplace= True)","13220c40":"df.fillna(0, inplace= True)\ndft.fillna(0, inplace= True)","c6e2aa9d":"df_tr= pd.get_dummies(df)\ndf_ts= pd.get_dummies(dft)","8b760a9d":"print(df_tr.shape)\nprint(df_ts.shape)","e499a756":"for i in df_tr.columns:\n    if i not in df_ts.columns:\n        df_tr.drop({i},axis= 1, inplace= True)\n        \nfor i in df_ts.columns:\n    if i not in df_tr.columns:\n        df_ts.drop({i},axis= 1, inplace= True)","7a5b5d15":"X_train, X_test, y_train, y_test= train_test_split(df_tr, y, random_state= 42)\n\nreg= GradientBoostingRegressor()\n\nreg.fit(df_tr, y)","174d588a":"reg.score(X_test, y_test)","326c82f1":"a= reg.predict(df_ts)","73a44267":"a= pd.DataFrame({'Id': b, 'SalePrice':a})","4a47d2c0":"a.set_index('Id', inplace= True)","6bbb42db":"a.head()","7c0e1222":"a.to_csv('prices_these_days.csv')\n\n# import the modules we'll need\nfrom IPython.display import HTML\nimport pandas as pd\nimport numpy as np\nimport base64\n\n# function that takes in a dataframe and creates a text link to  \n# download it (will only work for files < 2MB or so)\ndef create_download_link(df, title = \"Download CSV file\", filename = \"prices_these_days.csv\"):  \n    csv = df.to_csv()\n    b64 = base64.b64encode(csv.encode())\n    payload = b64.decode()\n    html = '<a download=\"{filename}\" href=\"data:text\/csv;base64,{payload}\" target=\"_blank\">{title}<\/a>'\n    html = html.format(payload=payload,title=title,filename=filename)\n    return HTML(html)\n\n# create a link to download the dataframe\ncreate_download_link(a)","32fc141b":"## Garage Quality: We can see that garage quality and condition are very closely correlated.","ea53434a":"## We have uneven number of columns: What we can do here is make an intersection of features from both of the data sets:","7a04c2ec":"# Now we have no missing\/categorical values: we can proceed with our model development","f1f83c6f":"## Garage Type\n\n## We conclude that garage type is very closely realted to Garage Area. ","e483b60b":"## #Basement Exposure","58eaf0d1":"# One hot encoding","fe566a66":"# Basement Finished area 1 (BsmtFinType1)\n\n# We see a correlation with BsmtFinSF1: Type 1 finished square feet AND BsmtFinType1","d9760e45":"## Garage Finish","28222e52":"## Basement Quality:","8b0599f7":"### Misc features","7fb892a8":"## Importing important libraries and reading files","cc281a28":"## We will filter out the categorical variables and try to make them numeric. ","1056db1f":"## BsmtFinType2: Rating of basement finished area (if multiple types)\n\n## We can drop this as most of them are unfinished. ","7a09807b":"## Basement Condition:","1892ecf9":"## Total basement area and basement condition are closely realted. \n\n### BsmtCond\nFa     871.733333\n\nGd    1134.153846\n\nPo     822.000000\n\nTA    1090.202136\n","14e831ec":"### Garage condition: We are gonna fill the missing values here based on overall condition.","3367e1c8":"# Since MasVnrType: Masonry veneer type is only 16\/8 missing values, we can just replace them with mode. ","36e68559":"## Lets try imputing the missing values in our data set"}}