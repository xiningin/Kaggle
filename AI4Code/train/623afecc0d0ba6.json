{"cell_type":{"43a0f335":"code","8721b002":"code","f766dc76":"code","fbbed4f4":"code","140a6848":"code","bc1a54cb":"code","22f85654":"code","8525df56":"code","433cffa8":"code","46d914dc":"code","6e8bfb28":"code","80cac7b4":"code","f2c281b6":"code","7c69d821":"code","827bb1ce":"code","490a8643":"code","4334fb1a":"code","30981ba4":"code","03b42f35":"code","dcb3dd58":"code","c7a83fbf":"code","f789b402":"code","d39c32c9":"markdown","32875cd8":"markdown","a915a207":"markdown","b1fe84de":"markdown","81dd0281":"markdown","ce1c5eb4":"markdown","871fd25e":"markdown","84dfbc19":"markdown","833b9f39":"markdown","796513f2":"markdown","0602cf60":"markdown","51ebc739":"markdown","289fc6da":"markdown"},"source":{"43a0f335":"import time, sys, os, copy\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' \nimport numpy as np\nimport pandas as pd\nfrom math import sqrt\nimport random\nimport subprocess\nfrom collections import Counter\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\n\nfrom multiprocessing import Pool\nimport multiprocessing\n\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Activation, Dropout, TimeDistributed, BatchNormalization\nfrom tensorflow.keras.layers import LSTM, GRU\nfrom tensorflow.keras.optimizers import RMSprop, Adagrad, Adam, SGD\n#from keras.models import load_model\nimport tensorflow.keras.backend as K\n\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nweeks = []\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        if 'week5' in filename:\n            weeks = os.path.join(dirname, filename)\n        if 'plays' in filename: \n            plays = os.path.join(dirname, filename)","8721b002":"datadf =  pd.read_csv(weeks)\ndatadf.head()","f766dc76":"def compute_speed(data):\n    data['v_x'] = np.sin(data['dir']*np.pi\/180) * data['s']\n    data['v_y'] = np.cos(data['dir']*np.pi\/180) * data['s']\n    data['v_theta'] = np.arctan(data['v_x']\/data['v_y']) if data['v_y'] != 0 else 0 \n    return data\n","fbbed4f4":"player_trajectories = []\nplay = datadf.query('gameId== 2018100400 and playId==51')\nplay = play.apply(compute_speed, axis=1)\nhome = play.query('team==\"home\"')\naway = play.query('team==\"away\"')\nfootball = play.query('team==\"football\"')\nfootball = football.sort_values('frameId')\nnames = play['displayName'].value_counts().index\n\n\nfor player in away['displayName'].value_counts().index:\n    trajectory = play.loc[play['displayName']==player]\n    player_seq = trajectory.sort_values(['frameId'])\n    dist_to_ball_x = np.absolute(player_seq[['x']].to_numpy()-football[['x']].to_numpy())\n    dist_to_ball_y = np.absolute(player_seq[['y']].to_numpy()-football[['y']].to_numpy())\n    player_seq = player_seq[['x','y','v_x','v_y']].to_numpy()\n    #final_player_traj = np.hstack((player_seq, dist_to_ball_x, dist_to_ball_y))\n    player_trajectories.append(player_seq)\n\nfor player in home['displayName'].value_counts().index:\n    trajectory = play.loc[play['displayName']==player]\n    player_seq = trajectory.sort_values(['frameId'])\n    dist_to_ball_x = np.absolute(player_seq[['x']].to_numpy()-football[['x']].to_numpy())\n    dist_to_ball_y = np.absolute(player_seq[['y']].to_numpy()-football[['y']].to_numpy())\n    player_seq = player_seq[['x','y','v_x','v_y']].to_numpy()\n    #final_player_traj = np.hstack((player_seq, dist_to_ball_x, dist_to_ball_y))\n    player_trajectories.append(player_seq)\n\n\n\nfootball_seq = football[['x','y']].to_numpy()\n\na = np.hstack(player_trajectories)\na = np.hstack((a,football_seq))\n#a = a[10:]- np.mean(a, axis=0)\na = np.expand_dims(a[10:], axis=0)","140a6848":"def get_sequences(single_plays, policies, sequence_length, overlap, n_fts =6):\n    training_complete = []\n    target_complete = []\n    for pol in range(policies): \n        train = []\n        target = []\n        for i in single_plays:\n            for j in range(0, i.shape[0]+sequence_length, sequence_length-overlap):\n                try:\n                    if  j>sequence_length-1:\n                        targets = i[j+1, pol*n_fts:pol*n_fts+2]\n                        training = i[j-sequence_length:j]    \n                        train.append(np.expand_dims(training,0))\n                        target.append(np.expand_dims(targets,0))\n                    else:\n                        targets = i[j+1, pol*n_fts:pol*n_fts+2]\n                        training = i[:j]\n                        training = np.vstack((np.tile(i[0], (sequence_length-j,1)), training))\n                        train.append(np.expand_dims(training,0))\n                        target.append(np.expand_dims(targets,0))\n                except:\n                    pass\n        training_complete.append(np.vstack(train))\n        target_complete.append(np.vstack(target))\n    \n    return training_complete ,target_complete \n\nsequence_length = 20\noverlap = 15\nn_epoch = 5\nnum = len(list(away['displayName'].value_counts().index))\n\n\ntrain_, target_ = get_sequences(a, num, sequence_length, overlap, n_fts=4)","bc1a54cb":"\"\"\"         Batch Size, Seq. Len, Feature length\nInput Shape: 8, 20, 54  \nOut shape : 8, 2\n\"\"\"\n\n\nadagradOpt = Adagrad(lr=0.005, epsilon=1e-08)\nmodel_list = list(away['displayName'].value_counts().index)\nbatchSize= 8\nnumOfPrevSteps = 20\nfeaturelen = a.shape[-1]\nprint('Load models...')\npolicies2 = []\nfor _ in model_list:\n\n    conv_model = tf.keras.Sequential([\n        tf.keras.layers.Conv1D(filters=32,\n                            kernel_size=(5,),\n                            activation='relu'),\n        tf.keras.layers.Conv1D(filters=32,\n                            kernel_size=(8,),\n                            activation='relu'),\n        tf.keras.layers.Conv1D(filters=32,\n                            kernel_size=(9,),\n                            activation='relu'),\n        tf.keras.layers.Dense(units=32, activation='relu'),\n        tf.keras.layers.Dense(units=2),\n    ])\n    conv_model.compile(loss='mae', optimizer='adam')\n    policies2.append(conv_model)\n\n\nprint('Train Models')\ntraining_loss =[[] for index in range(len(policies2))]\nfor index in range(len(policies2)):\n\n        inp =train_[index]\n        out =target_[index]\n        loss = policies2[index].fit(inp, out,epochs =150, verbose=False)\n        training_loss[index].append(loss)  \nfor n,loss in enumerate(training_loss):\n    plt.plot(loss[-1].history['loss'],label = str(n))\nplt.legend()\nplt.show()\nprint('Finished')","22f85654":"complete_data = np.squeeze(np.array(a),0)\npred = []\nfor i in range(38): \n    next_prediction_all = []\n    inp_pred_all = []\n    n_fts = 4\n    if i<20:\n        continue\n    for index in range(len(policies2)):\n        inp = np.array(complete_data[i-sequence_length:i,:])\n        next_prediction = policies2[index].predict(np.expand_dims(inp,0))\n        next_prediction_all.append(next_prediction.flatten())\n        inp_pred_all.append(inp)\n    next_prediction_all = np.vstack(next_prediction_all)\n    pred.append(next_prediction_all)\n    home_players = np.array([complete_data[i+1,index*n_fts:index*n_fts+2] for index in range(len(policies2))])\n    plt.scatter(home_players[:,0], home_players[:,1], color='red')\n    plt.scatter(next_prediction_all[:,0], next_prediction_all[:,1], color ='b')\n    '''\n    #input trajectory\n    for j in inp_pred_all:\n        for k in range(j.shape[0]):\n            u = np.array([j[k,index*n_fts:index*n_fts+2] for index in range(len(policies2))])\n            plt.scatter(u[:,0], u[:,1], color = 'yellow')\n    '''\n    plt.show()","8525df56":"for p in pred:\n    plt.scatter(p[:,0], p[:,1],color = 'k')\nfor t in target_:\n    plt.scatter(t[:,0], t[:,1])\n","433cffa8":"next_prediction_all  = []\ntrue_pred = []\nfor index in range(len(policies2)):\n\n        inp =train_[index]\n        out =target_[index]\n        next_prediction = policies2[index].predict(inp).flatten()\n        next_prediction_all.append(next_prediction)\n        true_pred.append(out)\n        break\nnext_prediction_all = np.vstack(next_prediction_all)\ntrue_pred = np.vstack(true_pred)\nplt.scatter(next_prediction_all[:,0], next_prediction_all[:,1], color ='b')\nplt.scatter(true_pred[:,0], true_pred[:,1], color ='r')","46d914dc":"a = np.hstack(player_trajectories)\na = np.hstack((a,football_seq))\nprint(a.shape)\na = a[10:]- np.mean(a, axis=0)\nprint(a.shape)\na = np.expand_dims(a, axis=0)\ntrain_, target_ = get_sequences(a, num, sequence_length, overlap, n_fts=4)\nadagradOpt = Adagrad(lr=0.005, epsilon=1e-08)\nmodel_list = list(away['displayName'].value_counts().index)\nbatchSize= 8\nnumOfPrevSteps = 20\nfeaturelen = a.shape[-1]\nprint('Load models...')\npolicies2 = []\n#### Load the model\nfor model_name in model_list:\n    model = Sequential()\n    model.add(tf.keras.layers.Bidirectional(LSTM(512 ,return_sequences=True)))\n    model.add(tf.keras.layers.Bidirectional(LSTM(512 , return_sequences=False)))\n    model.add(Dense(64,activation='relu'))\n    model.add(Dense(2, activation = 'linear') )\n    model.compile(loss='mae', optimizer='adam')\n    model.reset_states()\n    policies2.append(model)   \n\nprint('Train Models')\ntraining_loss =[[] for index in range(len(policies2))]\nfor index in range(len(policies2)):\n\n        inp =train_[index]\n        out =target_[index]\n        loss = policies2[index].fit(inp, out,epochs =150, verbose=False)\n        training_loss[index].append(loss)  \nfor n,loss in enumerate(training_loss):\n    plt.plot(loss[-1].history['loss'],label = str(n))\nplt.legend()\nplt.show()\nprint('Finished')","6e8bfb28":"complete_data = np.squeeze(np.array(a),0)\npred = []\nfor i in range(38): \n    next_prediction_all = []\n    inp_pred_all = []\n    n_fts = 4\n    if i<20:\n        continue\n    for index in range(len(policies2)):\n        inp = np.array(complete_data[i-sequence_length:i,:])\n        next_prediction = policies2[index].predict(np.expand_dims(inp,0))\n        next_prediction_all.append(next_prediction.flatten())\n        inp_pred_all.append(inp)\n    next_prediction_all = np.vstack(next_prediction_all)\n    pred.append(next_prediction_all)\n    home_players = np.array([complete_data[i+1,index*n_fts:index*n_fts+2] for index in range(len(policies2))])\n    plt.scatter(home_players[:,0], home_players[:,1], color='red')\n    plt.scatter(next_prediction_all[:,0], next_prediction_all[:,1], color ='b')\n    '''\n    #input trajectory\n    for j in inp_pred_all:\n        for k in range(j.shape[0]):\n            u = np.array([j[k,index*n_fts:index*n_fts+2] for index in range(len(policies2))])\n            plt.scatter(u[:,0], u[:,1], color = 'yellow')\n    '''\n    plt.show()\n","80cac7b4":"for p in pred:\n    plt.scatter(p[:,0], p[:,1],color = 'k')\nfor t in target_:\n    plt.scatter(t[:,0], t[:,1])\n","f2c281b6":"next_prediction_all  = []\ntrue_pred = []\nfor index in range(len(policies2)):\n\n        inp =train_[index]\n        out =target_[index]\n        next_prediction = policies2[index].predict(inp)\n        next_prediction_all.append(next_prediction)\n        true_pred.append(out)\n        break\nnext_prediction_all = np.vstack(next_prediction_all)\ntrue_pred = np.vstack(true_pred)\nplt.scatter(next_prediction_all[:,0], next_prediction_all[:,1], color ='b')\nplt.scatter(true_pred[:,0], true_pred[:,1], color ='r')","7c69d821":"data =  pd.read_csv(weeks)\nplaydf = pd.read_csv(plays)\n\ngameIndex = data['gameId'].value_counts().index\ndefensive_lineup = ['CB','SS', 'FS', 'S', 'MLB', 'OLB', 'ILB', 'LB', 'DB', 'DE']\noffensive_lineup = ['WR', 'RB', 'HB','TE', 'FB', 'QB']\nsorter = defensive_lineup + offensive_lineup + ['NaN'] #nan is football\nsorterIndex = dict(zip(sorter, range(len(sorter))))\nsequences = []\nseq_play = []","827bb1ce":"for gameId in gameIndex:\n    print('Starting with game: ' + str(gameId))\n    start_game = time.time()\n    playIds = data.query('gameId== ' + str(gameId))['playId'].value_counts().index\n    for playId in playIds:\n        play = data.query('playId == ' +str(playId) + 'and gameId== ' + str(gameId))\n        yardline = playdf.query('playId == ' +str(playId) + 'and gameId== ' + str(gameId))\n        start = time.time()\n        if (set(list(play.position.value_counts().index)) <= set(sorter)) and (len(play.displayName.value_counts().index)==17): \n            try:\n                play = play.apply(compute_speed, axis=1)\n                player_trajectories = []\n                football = play.query('team==\"football\"')\n                football = football.sort_values('frameId')\n                devensive_players = 0\n                off_player = 0 \n                for player in sorter:\n                    trajectory1 = play.loc[play['position']==player]\n                    for i in trajectory1.displayName.value_counts().index:\n                        if i == 'Football':\n                            continue\n                        if player in defensive_lineup:\n                            devensive_players +=1    \n                        else:\n                            off_player +=1 \n                        trajectory = trajectory1.loc[trajectory1['displayName']==i]\n                        player_seq = trajectory.sort_values(['frameId'])\n                        try:\n                            dist_to_ball_x = np.absolute(player_seq[['x']].to_numpy()-football[['x']].to_numpy())\n                            dist_to_ball_y = np.absolute(player_seq[['y']].to_numpy()-football[['y']].to_numpy())\n                        except:\n                            px = np.vstack([player_seq[['x']].to_numpy(),player_seq[['x']].to_numpy()[-1]])\n                            py = np.vstack([player_seq[['y']].to_numpy(),player_seq[['y']].to_numpy()[-1]])\n                            dist_to_ball_x = np.absolute(px-football[['x']].to_numpy())\n                            dist_to_ball_y = np.absolute(py-football[['y']].to_numpy())\n                        player_seq['x'] -=  football['x'].iloc[0]\n                        player_seq['y'] -=  football['y'].iloc[0]\n                        player_seq = player_seq[['x','y','v_x','v_y']].to_numpy()\n                        final_player_traj = np.hstack((player_seq, dist_to_ball_x, dist_to_ball_y))\n                        player_trajectories.append(final_player_traj)\n                football['x'] -=  football['x'].iloc[0]\n                football['y'] -=  football['y'].iloc[0]\n                football_seq = football[['x','y']].to_numpy()\n                a = np.hstack(player_trajectories)\n                a = np.hstack((a,football_seq))\n                print('defensive players: ' + str(devensive_players))\n                print('offensive players: ' + str(off_player))\n                sequences.append(a)\n                seq_play.append(yardline)\n            except:\n                print('Play wasnt added to sequences: ' + str(playId))\n        else:\n            print('Abort')\n            print(play.position.value_counts().index)\n            print(len(play.displayName.value_counts().index))\n            continue\n    print('Done with one game')\n    print(time.time()-start_game)\n","490a8643":"### Preprocessing Alterations \nnum = len(defensive_lineup)\nsequence_length = 15\noverlap = 6\ntrain_, target_ = get_sequences(sequences, num, sequence_length, overlap, n_fts=6)","4334fb1a":"train_datasets = [tf.data.Dataset.from_tensor_slices((train, target)) for train, target in zip(train_, target_)]\n\nBATCH_SIZE = 128\nSHUFFLE_BUFFER_SIZE = 100\nfor index in range(len(train_datasets)):    \n    train_datasets[index] = train_datasets[index].shuffle(SHUFFLE_BUFFER_SIZE).batch(BATCH_SIZE)","30981ba4":"model_list = defensive_lineup\nbatchSize= 8\nnumOfPrevSteps = 20\nfeaturelen = a.shape[-1]\nprint('Load models...')\npolicies2 = []\n#### Load the model\nfor model_name in model_list:\n    model = Sequential()\n    model.add(tf.keras.layers.Bidirectional(LSTM(512 ,return_sequences=True)))\n    model.add(tf.keras.layers.Bidirectional(LSTM(512 , return_sequences=False)))\n    model.add(Dense(32,activation='relu'))\n    model.add(Dense(2, activation = 'linear') )\n    model.compile(loss='mae', optimizer='adam')\n    #model.load_weights(model_name)\n    #model.load_weights('init_weights_minibatch1024_10epochs.h5') # Load the pretrained model\n    model.reset_states()\n    policies2.append(model)   \n\n","03b42f35":"print('Train Models')\ntraining_loss =[[] for index in range(len(policies2))]\nfor index,(model, trainset) in enumerate(zip(policies2, train_datasets)):\n    print('Starting with Model ' + str(index))\n    loss = model.fit(trainset ,epochs =50)\n    training_loss[index].append(loss)  \nfor n,loss in enumerate(training_loss):\n    plt.plot(loss[-1].history['loss'],label = str(n))\nplt.legend()\nplt.show()\nprint('Finished')","dcb3dd58":"def create_football_field(linenumbers=True,\n                          endzones=True,\n                          highlight_line=False,\n                          highlight_line_number=50,\n                          highlighted_name='Line of Scrimmage',\n                          fifty_is_los=False,\n                          figsize=(12, 6.33)):\n    \"\"\"\n    Function that plots the football field for viewing plays.\n    Allows for showing or hiding endzones.\n    \"\"\"\n    rect = patches.Rectangle((0, 0), 120, 53.3, linewidth=0.1,\n                             edgecolor='r', facecolor='darkgreen', zorder=0)\n\n    fig, ax = plt.subplots(1, figsize=figsize)\n    ax.add_patch(rect)\n\n    plt.plot([10, 10, 10, 20, 20, 30, 30, 40, 40, 50, 50, 60, 60, 70, 70, 80,\n              80, 90, 90, 100, 100, 110, 110, 120, 0, 0, 120, 120],\n             [0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3,\n              53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 53.3, 0, 0, 53.3],\n             color='white')\n    if fifty_is_los:\n        plt.plot([60, 60], [0, 53.3], color='gold')\n        plt.text(62, 50, '<- Player Yardline at Snap', color='gold')\n    # Endzones\n    if endzones:\n        ez1 = patches.Rectangle((0, 0), 10, 53.3,\n                                linewidth=0.1,\n                                edgecolor='r',\n                                facecolor='blue',\n                                alpha=0.2,\n                                zorder=0)\n        ez2 = patches.Rectangle((110, 0), 120, 53.3,\n                                linewidth=0.1,\n                                edgecolor='r',\n                                facecolor='blue',\n                                alpha=0.2,\n                                zorder=0)\n        ax.add_patch(ez1)\n        ax.add_patch(ez2)\n    plt.xlim(0, 120)\n    plt.ylim(-5, 58.3)\n    plt.axis('off')\n    if linenumbers:\n        for x in range(20, 110, 10):\n            numb = x\n            if x > 50:\n                numb = 120 - x\n            plt.text(x, 5, str(numb - 10),\n                     horizontalalignment='center',\n                     fontsize=20,  # fontname='Arial',\n                     color='white')\n            plt.text(x - 0.95, 53.3 - 5, str(numb - 10),\n                     horizontalalignment='center',\n                     fontsize=20,  # fontname='Arial',\n                     color='white', rotation=180)\n    if endzones:\n        hash_range = range(11, 110)\n    else:\n        hash_range = range(1, 120)\n\n    for x in hash_range:\n        ax.plot([x, x], [0.4, 0.7], color='white')\n        ax.plot([x, x], [53.0, 52.5], color='white')\n        ax.plot([x, x], [22.91, 23.57], color='white')\n        ax.plot([x, x], [29.73, 30.39], color='white')\n\n    if highlight_line:\n        hl = highlight_line_number + 10\n        plt.plot([hl, hl], [0, 53.3], color='yellow')\n        plt.text(hl + 2, 50, '<- {}'.format(highlighted_name),\n                 color='yellow')\n    return fig, ax\n","c7a83fbf":"pred = []\ncomplete_data = np.array(sequences[0])\nfor i in range(sequences[0].shape[0]):\n    next_prediction_all = []\n    inp_pred_all = []\n    n_fts = 6\n    if i<15:\n        continue\n    for index in range(len(policies2)):\n        inp = np.array(complete_data[i-sequence_length:i,:])\n        next_prediction = policies2[index].predict(np.expand_dims(inp,0))\n        next_prediction_all.append(next_prediction.flatten())\n    next_prediction_all = np.vstack(next_prediction_all)\n    pred.append(next_prediction_all)\n    plt.scatter(next_prediction_all[:,0], next_prediction_all[:,1], color='orange', s=30)","f789b402":"fig, ax = create_football_field()\nplay = data.query('gameId == 2018100703 and playId == 4943 ')\nexample_play_home = play.query('team==\"home\"')\nexample_play_away = play.query('team == \"away\"')\nexample_football = play.query('team == \"football\"')\nexample_play_home.plot(x='x', y='y', kind='scatter', ax=ax, color='orange', s=30, legend='Away')\n#example_play_away.plot(x='x', y='y', kind='scatter', ax=ax, color='blue', s=30, legend='Home')\nexample_football.plot(x='x', y='y', kind='scatter', ax=ax, color='red', s=30, legend='football')\n\nexample_play_home = play.query('team==\"home\"')\nfor p in pred: \n    offset = [example_football.query('frameId ==1')['x'].to_numpy(),  example_football.query('frameId ==1')['y'].to_numpy()]\n    ax.scatter(p[:,0].flatten() + offset[0],\n               p[:,1].flatten() +offset[1], color='blue', s=30)\n\nplt.legend()\nplt.show()","d39c32c9":"# Description \nIn this notebook, I try to predict players next position, based on previous positions, velocity and distance to the ball respctively. To do so, I used a sample dataset of *gameId== 2018100400 and playId==51* to overfit Models. As can be seen in this notebook the model is basically collapsing to the mean. So here is my question: \n### Why is this happening? \n1. I tested it with LSTMs and Conv Networks\n2. Should be the Datapreparation\n\n\n### Solution\n1. Conv Network: I didnt really care to get it to work\n2. LSTM Network:*Even tho I thought for Overfitting the data, It doesnt matter if I normalize the data, It converges if substracting the mean.*","32875cd8":"## Plotting the last 18 Trajectory Points of the model","a915a207":"## Load the data again and Sort the players\nFor input of the data, I sorted the players. First the defensive linup, then the offense and lastly the football\n","b1fe84de":"## Model Predictions in Black and Targets in Color","81dd0281":"## Training Convolutional Sequential Models and plotting the results","ce1c5eb4":"# Whats next?\n* Stabilize training\n* Change data prep, so that mean does not influence position\n* Improve plotting","871fd25e":"## Loading the example data","84dfbc19":"### Depricated: We can see that the model seems to collaps to the mean of the labeled targets.\n\n### Solution: Substract the mean of the player positions to get good predictions. -> ","833b9f39":"## Do sample predictions of a sequence","796513f2":"# Here we Train the LSTMs","0602cf60":"# Stabilizing the training\n\nAfter ensuring that the training is taking place for a single sample, Lets train on a week data. \nWe could further implement **DAgger**.","51ebc739":"## Prediction of ONE single Track ","289fc6da":"## Return sequences with a simple rolling window approach"}}