{"cell_type":{"238f27a0":"code","8f0407e6":"code","717a8b4c":"code","24ca4764":"code","b088a4aa":"code","bfb2b493":"code","7f058403":"code","7e0875fb":"code","cda83685":"code","c004be31":"code","d56e5d8c":"code","4361e9cd":"code","c4b1ab44":"code","fbab1348":"code","159f97e9":"code","924ac6d6":"code","305a1a02":"code","43204c70":"code","33a7d35a":"code","25499534":"code","188f1258":"code","cd50964d":"code","0bf720e7":"code","729bccb0":"code","9e974cee":"code","3c51fe55":"code","d11c5919":"code","d3b4ceba":"code","2f02922f":"code","f518d083":"code","24049c92":"code","85c911e3":"code","3c4fc7d7":"code","b751c167":"code","c12805b1":"code","606746b2":"code","7dbfdeb3":"code","e071e6f3":"code","551d4251":"code","b6bbdb31":"code","54e8cd8c":"code","d75a9b3e":"code","a1631bcf":"code","cae69948":"code","a3c02436":"code","4906bb40":"code","9d1a05c3":"code","b4792fde":"code","e2c1325e":"code","dad4d044":"code","62629436":"code","149cb0bf":"code","82d229ae":"code","edc8d872":"code","dd228ffd":"code","3807576c":"code","ff0b6566":"markdown","51d2a0d7":"markdown","5c73e89f":"markdown","54dbe758":"markdown","44134cbd":"markdown","ba94d73d":"markdown","47d4d331":"markdown","774e1f26":"markdown","e17eac7c":"markdown","e3565375":"markdown","0a1154eb":"markdown","c0ec48dd":"markdown","5d4d5a3d":"markdown","139a41d1":"markdown","ed589f1b":"markdown","6766bbd0":"markdown","c20c3867":"markdown","47c380a2":"markdown","4428b547":"markdown","1749227f":"markdown","470c0b29":"markdown","18c58e03":"markdown","684e2901":"markdown","d89a06e0":"markdown","6f2d74d9":"markdown","2c730f30":"markdown","81361f53":"markdown","c7c879d2":"markdown","e2f78f38":"markdown","9ddd363c":"markdown","e6995660":"markdown","cd05167d":"markdown","133f11b0":"markdown","2653daba":"markdown","239bd33e":"markdown","d846253b":"markdown","63a53efb":"markdown","f82bece3":"markdown","e0e22d60":"markdown","0995c84a":"markdown","2a59514e":"markdown","d84155d4":"markdown","97d3a058":"markdown","f0d51c61":"markdown","ce773f07":"markdown","4d055578":"markdown","8f2917e3":"markdown","a35fcc76":"markdown","b478802c":"markdown","2f1b939e":"markdown","88539b49":"markdown","c1eedc9f":"markdown","f931616f":"markdown","4512f260":"markdown","30b1b4e3":"markdown","dee621fe":"markdown","63dcd7d4":"markdown","d3e1b382":"markdown","918e18d4":"markdown","ceb84d92":"markdown","0b471435":"markdown","01b701f2":"markdown","c6a39d3d":"markdown","6d8c3d61":"markdown","25c408c5":"markdown","60c8821c":"markdown","dc597756":"markdown","d56b88ff":"markdown","fa28ea58":"markdown","ca41ed4a":"markdown","af7ea1c8":"markdown","8f606264":"markdown","e8e2d117":"markdown","ee2be59f":"markdown","4ba42a97":"markdown","77bdada9":"markdown","5ef64343":"markdown","ca8ceb8d":"markdown","60d0d669":"markdown","bf8f5b3f":"markdown"},"source":{"238f27a0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8f0407e6":"! pip install scipy","717a8b4c":"from scipy import constants","24ca4764":"from scipy import constants\n\nprint(constants.liter)","b088a4aa":"import scipy\n\nprint(scipy.__version__)","bfb2b493":"# Print the constant value of PI:\n\nfrom scipy import constants\n\nprint(constants.pi)","7f058403":"from scipy import constants\n\nprint(dir(constants))","7e0875fb":"from scipy import constants\n\nprint(constants.yotta)    #1e+24\nprint(constants.zetta)    #1e+21\nprint(constants.exa)      #1e+18\nprint(constants.peta)     #1000000000000000.0\nprint(constants.tera)     #1000000000000.0\nprint(constants.giga)     #1000000000.0\nprint(constants.mega)     #1000000.0\nprint(constants.kilo)     #1000.0\nprint(constants.hecto)    #100.0\nprint(constants.deka)     #10.0\nprint(constants.deci)     #0.1\nprint(constants.centi)    #0.01\nprint(constants.milli)    #0.001\nprint(constants.micro)    #1e-06\nprint(constants.nano)     #1e-09\nprint(constants.pico)     #1e-12\nprint(constants.femto)    #1e-15\nprint(constants.atto)     #1e-18\nprint(constants.zepto)    #1e-21","cda83685":"from scipy import constants\n\nprint(constants.kibi)    #1024\nprint(constants.mebi)    #1048576\nprint(constants.gibi)    #1073741824\nprint(constants.tebi)    #1099511627776\nprint(constants.pebi)    #1125899906842624\nprint(constants.exbi)    #1152921504606846976\nprint(constants.zebi)    #1180591620717411303424\nprint(constants.yobi)    #1208925819614629174706176","c004be31":"from scipy import constants\n\nprint(constants.gram)        #0.001\nprint(constants.metric_ton)  #1000.0\nprint(constants.grain)       #6.479891e-05\nprint(constants.lb)          #0.45359236999999997\nprint(constants.pound)       #0.45359236999999997\nprint(constants.oz)          #0.028349523124999998\nprint(constants.ounce)       #0.028349523124999998\nprint(constants.stone)       #6.3502931799999995\nprint(constants.long_ton)    #1016.0469088\nprint(constants.short_ton)   #907.1847399999999\nprint(constants.troy_ounce)  #0.031103476799999998\nprint(constants.troy_pound)  #0.37324172159999996\nprint(constants.carat)       #0.0002\nprint(constants.atomic_mass) #1.66053904e-27\nprint(constants.m_u)         #1.66053904e-27\nprint(constants.u)           #1.66053904e-27","d56e5d8c":"from scipy import constants\n\nprint(constants.degree)     #0.017453292519943295\nprint(constants.arcmin)     #0.0002908882086657216\nprint(constants.arcminute)  #0.0002908882086657216\nprint(constants.arcsec)     #4.84813681109536e-06\nprint(constants.arcsecond)  #4.84813681109536e-06","4361e9cd":"from scipy import constants\n\nprint(constants.minute)      #60.0\nprint(constants.hour)        #3600.0\nprint(constants.day)         #86400.0\nprint(constants.week)        #604800.0\nprint(constants.year)        #31536000.0\nprint(constants.Julian_year) #31557600.0","c4b1ab44":"from scipy import constants\n\nprint(constants.inch)              #0.0254\nprint(constants.foot)              #0.30479999999999996\nprint(constants.yard)              #0.9143999999999999\nprint(constants.mile)              #1609.3439999999998\nprint(constants.mil)               #2.5399999999999997e-05\nprint(constants.pt)                #0.00035277777777777776\nprint(constants.point)             #0.00035277777777777776\nprint(constants.survey_foot)       #0.3048006096012192\nprint(constants.survey_mile)       #1609.3472186944373\nprint(constants.nautical_mile)     #1852.0\nprint(constants.fermi)             #1e-15\nprint(constants.angstrom)          #1e-10\nprint(constants.micron)            #1e-06\nprint(constants.au)                #149597870691.0\nprint(constants.astronomical_unit) #149597870691.0\nprint(constants.light_year)        #9460730472580800.0\nprint(constants.parsec)            #3.0856775813057292e+16","fbab1348":"from scipy import constants\n\nprint(constants.atm)         #101325.0\nprint(constants.atmosphere)  #101325.0\nprint(constants.bar)         #100000.0\nprint(constants.torr)        #133.32236842105263\nprint(constants.mmHg)        #133.32236842105263\nprint(constants.psi)         #6894.757293168361","159f97e9":"from scipy import constants\n\nprint(constants.hectare) #10000.0\nprint(constants.acre)    #4046.8564223999992","924ac6d6":"from scipy import constants\n\nprint(constants.liter)            #0.001\nprint(constants.litre)            #0.001\nprint(constants.gallon)           #0.0037854117839999997\nprint(constants.gallon_US)        #0.0037854117839999997\nprint(constants.gallon_imp)       #0.00454609\nprint(constants.fluid_ounce)      #2.9573529562499998e-05\nprint(constants.fluid_ounce_US)   #2.9573529562499998e-05\nprint(constants.fluid_ounce_imp)  #2.84130625e-05\nprint(constants.barrel)           #0.15898729492799998\nprint(constants.bbl)              #0.15898729492799998","305a1a02":"from scipy import constants\n\nprint(constants.kmh)            #0.2777777777777778\nprint(constants.mph)            #0.44703999999999994\nprint(constants.mach)           #340.5\nprint(constants.speed_of_sound) #340.5\nprint(constants.knot)           #0.5144444444444445","43204c70":"from scipy import constants\n\nprint(constants.zero_Celsius)      #273.15\nprint(constants.degree_Fahrenheit) #0.5555555555555556","33a7d35a":"from scipy import constants\n\nprint(constants.eV)            #1.6021766208e-19\nprint(constants.electron_volt) #1.6021766208e-19\nprint(constants.calorie)       #4.184\nprint(constants.calorie_th)    #4.184\nprint(constants.calorie_IT)    #4.1868\nprint(constants.erg)           #1e-07\nprint(constants.Btu)           #1055.05585262\nprint(constants.Btu_IT)        #1055.05585262\nprint(constants.Btu_th)        #1054.3502644888888\nprint(constants.ton_TNT)       #4184000000.0","25499534":"from scipy import constants\n\nprint(constants.hp)         #745.6998715822701\nprint(constants.horsepower) #745.6998715822701","188f1258":"from scipy import constants\n\nprint(constants.dyn)             #1e-05\nprint(constants.dyne)            #1e-05\nprint(constants.lbf)             #4.4482216152605\nprint(constants.pound_force)     #4.4482216152605\nprint(constants.kgf)             #9.80665\nprint(constants.kilogram_force)  #9.80665","cd50964d":"# Find root of the equation x + cos(x):\n\nfrom scipy.optimize import root\nfrom math import cos\n\ndef eqn(x):\n    return x + cos(x)\n\nmyroot = root(eqn, 0)\n\nprint(myroot.x)","0bf720e7":"print(myroot)","729bccb0":"# Minimize the function x^2 + x + 2 with BFGS:\n\nfrom scipy.optimize import minimize\n\ndef eqn(x):\n    return x**2 + x + 2\n\nmymin = minimize(eqn, 0, method='BFGS')\n\nprint(mymin)","9e974cee":"# Create a CSR matrix from an array:\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\narr = np.array([0, 0, 0, 0, 0, 1, 1, 0, 2])\n\nprint(csr_matrix(arr))\n","3c51fe55":"import numpy as np\nfrom scipy.sparse import csr_matrix\n\narr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])\n\nprint(csr_matrix(arr).data)","d11c5919":"# Counting nonzeros with the count_nonzero() method:\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\narr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])\n\nprint(csr_matrix(arr).count_nonzero())\n","d3b4ceba":"# Removing zero-entries from the matrix with the eliminate_zeros() method:\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\narr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])\n\nmat = csr_matrix(arr)\nmat.eliminate_zeros()\n\nprint(mat)","2f02922f":"# Eliminating duplicate entries with the sum_duplicates() method:\n# Eliminating duplicates by adding them\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\narr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])\n\nmat = csr_matrix(arr)\nmat.sum_duplicates()\n\nprint(mat)","f518d083":"# Converting from csr to csc with the tocsc() method:\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\narr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])\n\nnewarr = csr_matrix(arr).tocsc()\n\nprint(newarr)","24049c92":"import numpy as np\nfrom scipy.sparse.csgraph import connected_components\nfrom scipy.sparse import csr_matrix\n\narr = np.array([\n  [0, 1, 2],\n  [1, 0, 0],\n  [2, 0, 0]\n])\n\nnewarr = csr_matrix(arr)\n\nprint(connected_components(newarr))","85c911e3":"import numpy as np\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\n\narr = np.array([\n  [0, 1, 2],\n  [1, 0, 0],\n  [2, 0, 0]\n])\n\nnewarr = csr_matrix(arr)\n\nprint(dijkstra(newarr, return_predecessors=True, indices=0))","3c4fc7d7":"import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\narr = np.array([\n  [0, 1, 2],\n  [1, 0, 0],\n  [2, 0, 0]\n])\n\nnewarr = csr_matrix(arr)\n\nprint(floyd_warshall(newarr, return_predecessors=True))","b751c167":"import numpy as np\nfrom scipy.sparse.csgraph import bellman_ford\nfrom scipy.sparse import csr_matrix\n\narr = np.array([\n  [0, -1, 2],\n  [1, 0, 0],\n  [2, 0, 0]\n])\n\nnewarr = csr_matrix(arr)\n\nprint(bellman_ford(newarr, return_predecessors=True, indices=0))","c12805b1":"import numpy as np\nfrom scipy.sparse.csgraph import depth_first_order\nfrom scipy.sparse import csr_matrix\n\narr = np.array([\n  [0, 1, 0, 1],\n  [1, 1, 1, 1],\n  [2, 1, 1, 0],\n  [0, 1, 0, 1]\n])\n\nnewarr = csr_matrix(arr)\n\nprint(depth_first_order(newarr, 1))","606746b2":"import numpy as np\nfrom scipy.sparse.csgraph import breadth_first_order\nfrom scipy.sparse import csr_matrix\n\narr = np.array([\n  [0, 1, 0, 1],\n  [1, 1, 1, 1],\n  [2, 1, 1, 0],\n  [0, 1, 0, 1]\n])\n\nnewarr = csr_matrix(arr)\n\nprint(breadth_first_order(newarr, 1))","7dbfdeb3":"import numpy as np\nfrom scipy.spatial import Delaunay\nimport matplotlib.pyplot as plt\n\npoints = np.array([\n  [2, 4],\n  [3, 4],\n  [3, 0],\n  [2, 2],\n  [4, 1]\n])\n\nsimplices = Delaunay(points).simplices\n\nplt.triplot(points[:, 0], points[:, 1], simplices)\nplt.scatter(points[:, 0], points[:, 1], color='r')\n\nplt.show()","e071e6f3":"import numpy as np\nfrom scipy.spatial import ConvexHull\nimport matplotlib.pyplot as plt\n\npoints = np.array([\n  [2, 4],\n  [3, 4],\n  [3, 0],\n  [2, 2],\n  [4, 1],\n  [1, 2],\n  [5, 0],\n  [3, 1],\n  [1, 2],\n  [0, 2]\n])\n\nhull = ConvexHull(points)\nhull_points = hull.simplices\n\nplt.scatter(points[:,0], points[:,1])\nfor simplex in hull_points:\n    plt.plot(points[simplex,0], points[simplex,1], 'k-')\n\nplt.show()","551d4251":"from scipy.spatial import KDTree\n\npoints = [(1, -1), (2, 3), (-2, 3), (2, -3)]\n\nkdtree = KDTree(points)\n\nres = kdtree.query((1, 1))\n\nprint(res)","b6bbdb31":"from scipy.spatial.distance import euclidean\n\np1 = (1, 0)\np2 = (10, 2)\n\nres = euclidean(p1, p2)\n\nprint(res)","54e8cd8c":"from scipy.spatial.distance import cityblock\n\np1 = (1, 0)\np2 = (10, 2)\n\nres = cityblock(p1, p2)\n\nprint(res)","d75a9b3e":"from scipy.spatial.distance import cosine\n\np1 = (1, 0)\np2 = (10, 2)\n\nres = cosine(p1, p2)\n\nprint(res)","a1631bcf":"from scipy.spatial.distance import hamming\n\np1 = (True, False, True)\np2 = (False, True, True)\n\nres = hamming(p1, p2)\n\nprint(res)","cae69948":"from scipy import io\nimport numpy as np\n\narr = np.arange(10)\n\nio.savemat('arr.mat', {\"vec\": arr})","a3c02436":"from scipy import io\nimport numpy as np\n\narr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9,])\n\n# Export:\nio.savemat('arr.mat', {\"vec\": arr})\n\n# Import:\nmydata = io.loadmat('arr.mat')\n\nprint(mydata)","4906bb40":"print(mydata['vec'])","9d1a05c3":"# Import:\nmydata = io.loadmat('arr.mat', squeeze_me=True)\n\nprint(mydata['vec'])","b4792fde":"from scipy.interpolate import interp1d\nimport numpy as np\n\nxs = np.arange(10)\nys = 2*xs + 1\n\ninterp_func = interp1d(xs, ys)\n\nnewarr = interp_func(np.arange(2.1, 3, 0.1))\n\nprint(newarr)","e2c1325e":"from scipy.interpolate import UnivariateSpline\nimport numpy as np\n\nxs = np.arange(10)\nys = xs**2 + np.sin(xs) + 1\n\ninterp_func = UnivariateSpline(xs, ys)\n\nnewarr = interp_func(np.arange(2.1, 3, 0.1))\n\nprint(newarr)","dad4d044":"from scipy.interpolate import Rbf\nimport numpy as np\n\nxs = np.arange(10)\nys = xs**2 + np.sin(xs) + 1\n\ninterp_func = Rbf(xs, ys)\n\nnewarr = interp_func(np.arange(2.1, 3, 0.1))\n\nprint(newarr)","62629436":"import numpy as np\nfrom scipy.stats import ttest_ind\n\nv1 = np.random.normal(size=100)\nv2 = np.random.normal(size=100)\n\nres = ttest_ind(v1, v2)\n\nprint(res)","149cb0bf":"res = ttest_ind(v1, v2).pvalue\n\nprint(res)","82d229ae":"import numpy as np\nfrom scipy.stats import kstest\n\nv = np.random.normal(size=100)\n\nres = kstest(v, 'norm')\n\nprint(res)","edc8d872":"import numpy as np\nfrom scipy.stats import describe\n\nv = np.random.normal(size=100)\nres = describe(v)\n\nprint(res)","dd228ffd":"import numpy as np\nfrom scipy.stats import skew, kurtosis\n\nv = np.random.normal(size=100)\n\nprint(skew(v))\nprint(kurtosis(v))","3807576c":"import numpy as np\nfrom scipy.stats import normaltest\n\nv = np.random.normal(size=100)\n\nprint(normaltest(v))","ff0b6566":"# Constant Units\n\n+ A list of all units under the constants module can be seen using the dir() function.","51d2a0d7":"# Mass:\n\nReturn the specified unit in kg (e.g. gram returns 0.001)","5c73e89f":"+ How many cubic meters are in one liter:","54dbe758":"# Roots of an Equation\n\n+ NumPy is capable of finding roots for polynomials and linear equations, but it can not find roots for non linear equations, like this one:\n\nx + cos(x)\n\nFor that you can use SciPy's optimze.root function.\n\nThis function takes two required arguments:\n\nfun - a function representing an equation.\n\nx0 - an initial guess for the root.\n\nThe function returns an object with information regarding the solution.\n\nThe actual solution is given under attribute x of the returned object:\n\n","44134cbd":"# Optimizers in SciPy\n\n+ Optimizers are a set of procedures defined in SciPy that either find the minimum value of a function, or the root of an equation.\n\n","ba94d73d":"# Volume:\nReturn the specified unit in cubic meters (e.g. liter returns 0.001)","47d4d331":"Alpha value\nAlpha value is the level of significance.\n\nExample:\n\nHow close to extremes the data must be for null hypothesis to be rejected.\n\nIt is usually taken as 0.01, 0.05, or 0.1.\n\nP value\nP value tells how close to extreme the data actually is.\n\nP value and alpha values are compared to establish the statistical significance.\n\nIf p value <= alpha we reject the null hypothesis and say that the data is statistically significant. otherwise we accept the null hypothesis.\n\nT-Test\nT-tests are used to determine if there is significant deference between means of twovariables. and lets us know if they belong to the same distribution.\n\nIt is a two tailed test.\n\nThe function ttest_ind() takes two samples of same size and produces a tuple of t-statistic and p-value.","774e1f26":"# Working with Graphs\n\n+ Graphs are an essential data structure.\n\n+ SciPy provides us with the module scipy.sparse.csgraph for working with such data structures.\n\n","e17eac7c":"# Force:\nReturn the specified unit in newton (e.g. kilogram_force returns 9.80665)","e3565375":"# Exporting Data in Matlab Format\n\nThe savemat() function allows us to export data in Matlab format.\n\nThe method takes the following parameters:\n\nfilename - the file name for saving data.\nmdict - a dictionary containing the data.\ndo_compression - a boolean value that specifies wheter to compress the reult or not. Default False.","0a1154eb":"# Checking SciPy Version\n\n+ The version string is stored under the __version__ attribute.","c0ec48dd":"# Binary Prefixes:\n\n+ Return the specified unit in bytes (e.g. kibi returns 1024)","5d4d5a3d":"# Which Language is SciPy Written in?\n\n+ SciPy is predominantly written in Python, but a few segments are written in C.","139a41d1":"# Why Use SciPy?\n\n+ If SciPy uses NumPy underneath, why can we not just use NumPy?\n\n+ SciPy has optimized and added functions that are frequently used in NumPy and Data Science.","ed589f1b":"# What is Statistical Significance Test?\nIn statistics, statistical significance means that the result that was produced has a reason behind it, it was not produced randomly, or by chance.\n\nSciPy provides us with a module called scipy.stats, which has functions for performing statistical significance tests.\n\nHere are some techniques and keywords that are important when performing such tests:","6766bbd0":"#  Convex Hull\n+ A convex hull is the smallest polygon that covers all of the given points.\n\nUse the ConvexHull() method to create a Convex Hull.","c20c3867":"# Import SciPy\n\n+ Once SciPy is installed, import the SciPy module(s)   you want to use in your applications by adding the     from scipy import module statement:\n\n","47c380a2":"# Metric (SI) Prefixes:\n\n+ Return the specified unit in meter (e.g. centi returns 0.01)","4428b547":"# Finding Minima\n\nWe can use scipy.optimize.minimize() function to minimize the function.\n\nThe minimize() function takes the following arguments:\n\nfun - a function representing an equation.\n\nx0 - an initial guess for the root.\n\nmethod - name of the method to use. Legal values:\n    'CG'\n    'BFGS'\n    'Newton-CG'\n    'L-BFGS-B'\n    'TNC'\n    'COBYLA'\n    'SLSQP'\n\ncallback - function called after each iteration of optimization.","1749227f":"# Power:\nReturn the specified unit in watts (e.g. horsepower returns 745.6998715822701)","470c0b29":"# Normality Tests (Skewness and Kurtosis)\nNormality tests are based on the skewness and kurtosis.\n\nThe normaltest() function returns p value for the null hypothesis:\n\n\"x comes from a normal distribution\".\n\nSkewness:\nA measure of symmetry in data.\n\nFor normal distributions it is 0.\n\nIf it is negative, it means the data is skewed left.\n\nIf it is positive it means the data is skewed right.\n\n","18c58e03":"# Angle:\nReturn the specified unit in radians (e.g. degree returns 0.017453292519943295)","684e2901":"# Spline Interpolation\nIn 1D interpolation the points are fitted for a single curve whereas in Spline interpolation the points are fitted against a piecewise function defined with polynomials called splines.\n\nThe UnivariateSpline() function takes xs and ys and produce a callable funciton that can be called with new xs.","d89a06e0":"# SciPy Constants\n\n+ As SciPy is more focused on scientific implementations, it provides many built-in scientific constants.\n\n+ These constants can be helpful when you are working with Data Science.","6f2d74d9":"# Connected Components\n+ Find all of the connected components with the connected_components() method.","2c730f30":"# How to Work With Sparse Data\n\n+ SciPy has a module, scipy.sparse that provides functions to deal with sparse data.\n\n+ There are primarily two types of sparse matrices that we use:\n\n+ CSC - Compressed Sparse Column. For efficient arithmetic, fast column slicing.\n\n+ CSR - Compressed Sparse Row. For fast row slicing, faster matrix vector products\n\n+ We will use the CSR matrix in this tutorial.","81361f53":"# Sparse Matrix Methods\n\n+ Sparse Matrix Methods\n","c7c879d2":"+ The source code for SciPy is located at this github repository https:\/\/github.com\/scipy\/scipy","e2f78f38":"+ In scientific computing, when we are dealing with partial derivatives in linear algebra we will come across sparse data.\n\n","9ddd363c":"+ Note: two underscore characters are used in __version__.","e6995660":"# Length:\nReturn the specified unit in meters (e.g. nautical_mile returns 1852.0)","cd05167d":"# In this NoteBook\n\n+ Install SciPy\n\n+ Constants\n\n+ Optimizers\n\n+ Sparse Data\n\n+ Matlab Array\n\n+ Interpolation\n\n+ Significance Tests","133f11b0":"# Breadth First Order\n\n+ The breadth_first_order() method returns a breadth first traversal from a node.\n\n+ This function takes following arguments:\n\nthe graph.\nthe starting element to traverse graph from.","2653daba":"Note: The simplices property creates a generalization of the triangle notation.","239bd33e":"One tailed test\nWhen our hypothesis is testing for one side of the value only, it is called \"one tailed test\".\n\nExample:\n\nFor the null hypothesis:\n\n\"the mean is equal to k\", we can have alternate hypothesis:\n\n\"the mean is less than k\", or:\n\n\"the mean is greater than k\"\n\nTwo tailed test\nWhen our hypothesis is testing for both side of the values.\n\nExample:\n\nFor the null hypothesis:\n\n\"the mean is equal to k\", we can have alternate hypothesis:\n\n\"the mean is not equal to k\"\n\nIn this case the mean is less than, or greater than k, and both sides are to be checked.","d846253b":"# 1D Interpolation\nThe function interp1d() is used to interpolate a distribution with 1 variable.\n\nIt takes x and y points and returns a callable function that can be called with new x and returns corresponding y.","63a53efb":"# Triangulation\n\nA Triangulation of a polygon is to divide the polygon into multiple triangles with which we can compute an area of the polygon.\n\nA Triangulation with points means creating surface composed triangles in which all of the given points are on at least one vertex of any triangle in the surface.\n\nOne method to generate these triangulations through points is the Delaunay() Triangulation.","f82bece3":"# Cosine Distance\nIs the value of cosine angle between the two points A and B.","e0e22d60":"# Area:\nReturn the specified unit in square meters(e.g. hectare returns 10000.0)","0995c84a":"+ Print all information about the solution (not just x which is the root).\n\n","2a59514e":"# Depth First Order\n\n+ The depth_first_order() method returns a depth first traversal from a node.\n\n+ This function takes following arguments:\n\nthe graph.\nthe starting element to traverse graph from.","d84155d4":"# Hypothesis in Statistics\nHypothesis is an assumption about a parameter in population.","97d3a058":"# Statistical Description of Data\nIn order to see a summary of values in an array, we can use the describe() function.\n\nIt returns the following description:\n\nnumber of observations (nobs)\nminimum and maximum values = minmax\nmean\nvariance\nskewness\nkurtosis","f0d51c61":"# Unit Categories\n\nThe units are placed under these categories:\n\n+ Metric\n+ Binary\n+ Mass\n+ Angle\n+ Time\n+ Length\n+ Pressure\n+ Volume\n+ Speed\n+ Temperature\n+ Energy\n+ Power\n+ Force","ce773f07":"# Speed:\nReturn the specified unit in meters per second (e.g. speed_of_sound returns 340.5)","4d055578":"+ Sparse Data: is a data set where most of the item values are zero.\n\n+ Dense Array: is the opposite of a sparse array: most of the values are not zero.","8f2917e3":"# Hamming Distance\nIs the proportion of bits where two bits are difference.\n\nIt's a way to measure distance for binary sequences.","a35fcc76":"# Energy:\nReturn the specified unit in joules (e.g. calorie returns 4.184)","b478802c":"Note: The returned object has much more information about the solution.","2f1b939e":"# KS-Test\nKS test is used to check if given values follow a distribution.\n\nThe function takes the value to be tested, and the CDF as two parameters.\n\nA CDF can be either a string or a callable function that returns the probability.\n\nIt can be used as a one tailed or two tailed test.\n\nBy default it is two tailed. We can pass parameter alternative as a string of one of two-sided, less, or greater.","88539b49":"# Please Upvote ","c1eedc9f":"# Euclidean Distance\n\nFind the euclidean distance between given points.\n\n","f931616f":"# Working with Spatial Data\n\nSpatial data refers to data that is represented in a geometric space.\n\nE.g. points on a coordinate system.\n\nWe deal with spatial data problems on many tasks.\n\nE.g. finding if a point is inside a boundary or not.\n\nSciPy provides us with the module scipy.spatial, which has functions for working with spatial data.","4512f260":"# Pressure:\nReturn the specified unit in pascals (e.g. psi returns 6894.757293168361)","30b1b4e3":"# Import Data from Matlab Format\n\nThe loadmat() function allows us to import data from a Matlab file.\n\nThe function takes one required parameter:\n\nfilename - the file name of the saved data.\n\nIt will return a structured array whose keys are the variable names, and the corresponding values are the variable values.","dee621fe":"# CSR Matrix\n\nWe can create CSR matrix by passing an arrray into function scipy.sparse.csr_matrix().","63dcd7d4":"# KDTrees\n\nKDTrees are a datastructure optimized for nearest neighbor queries.\n\nE.g. in a set of points using KDTrees we can efficiently ask which points are nearest to a certain given point.\n\nThe KDTree() method returns a KDTree object.\n\nThe query() method returns the distance to the nearest neighbor and the location of the neighbors.\n","d3e1b382":"# Working With Matlab Arrays\n\nWe know that NumPy provides us with methods to persist the data in readable formats for Python. But SciPy provides us with interoperability with Matlab as well.\n\nSciPy provides us with the module scipy.io, which has functions for working with Matlab arrays.","918e18d4":"# Interpolation with Radial Basis Function\nRadial basis function is a function that is defined corresponding to a fixed reference point.\n\nThe Rbf() function also takes xs and ys as arguments and produces a callable function that can be called with new xs.","ceb84d92":"+ constants: SciPy offers a set of mathematical constants, one of them is liter which returns 1 liter as cubic meters.","0b471435":"# Minimizing a Function\n\n+ A function, in this context, represents a curve, curves have high points and low points.\n\n+ High points are called maxima.\n\n+ Low points are called minima.\n\n+ The highest point in the whole curve is called global maxima, whereas the rest of them are called local maxima.\n\n+ The lowest point in whole curve is called global minima, whereas the rest of them are called local minima.","01b701f2":"# Floyd Warshall\n\n+ Use the floyd_warshall() method to find shortest path between all pairs of elements.","c6a39d3d":"# Dijkstra\n\n+ Use the dijkstra method to find the shortest path in a graph from one element to another.\n\n+ It takes following arguments:\n\n+ return_predecessors: boolean (True to return whole path of traversal otherwise False).\n+ indices: index of the element to return all paths from that element only.\n+ limit: max weight of path.","6d8c3d61":"# What is Interpolation?\nInterpolation is a method for generating points between given points.\n\nFor example: for points 1 and 2, we may interpolate and find points 1.33 and 1.66.\n\nInterpolation has many usage, in Machine Learning we often deal with missing data in a dataset, interpolation is often used to substitute those values.\n\nThis method of filling values is called imputation.\n\nApart from imputation, interpolation is often used where we need to smooth the discrete points in a dataset.","25c408c5":"+ options - a dictionary defining extra params:\n{\n     \"disp\": boolean - print detailed description\n     \"gtol\": number - the tolerance of the error\n  }","60c8821c":"# Temperature:\nReturn the specified unit in Kelvin (e.g. zero_Celsius returns 273.15)","dc597756":"# Optimizing Functions\n\n+ Essentially, all of the algorithms in Machine Learning are nothing more than a complex equation that needs to be minimized with the help of given data.","d56b88ff":"Null Hypothesis\nIt assumes that the observation is not stastically significant.\n\nAlternate Hypothesis\nIt assumes that the observations are due to some reason.\n\nIts alternate to Null Hypothesis.\n\nExample:\n\nFor an assessment of a student we would take:\n\n\"student is worse than average\" - as a null hypothesis, and:\n\n\"student is better than average\" - as an alternate hypothesis.\n\n","fa28ea58":"# How to Implement it in SciPy?\nSciPy provides us with a module called scipy.interpolate which has many functions to deal with interpolation:","ca41ed4a":"For a graph like this, with elements A, B and C, the connections are:\n\nA & B are connected with weight 1.\n\nA & C are connected with weight 2.\n\nC & B is not connected.\n\nThe Adjency Matrix would look like this:","af7ea1c8":"# Cityblock Distance (Manhattan Distance)\n\nIs the distance computed using 4 degrees of movement.\n\nE.g. we can only move: up, down, right, or left, not diagonally.\n","8f606264":"# Bellman Ford\n\n+ The bellman_ford() method can also find the shortest path between all pairs of elements, but this method can handle negative weights as well.","e8e2d117":"# Distance Matrix\n\nThere are many Distance Metrics used to find various types of distances between two points in data science, Euclidean distsance, cosine distsance etc.\n\nThe distance between two vectors may not only be the length of straight line between them, it can also be the angle between them from origin, or number of unit steps required etc.\n\nMany of the Machine Learning algorithm's performance depends greatly on distance metrices. E.g. \"K Nearest Neighbors\", or \"K Means\" etc.\n\nLet us look at some of the Distance Metrices:","ee2be59f":"# Kurtosis:\nA measure of whether the data is heavy or lightly tailed to a normal distribution.\n\nPositive kurtosis means heavy tailed.\n\nNegative kurtosis means lightly tailed.","4ba42a97":"+ Now we have imported the constants module from SciPy, and the application is ready to use it:","77bdada9":"# Installation of SciPy\n\n+ If you have Python and PIP already installed on a system, then installation of SciPy is very easy.\n\n+ Install it using this command:\n\n+ If this command fails, then use a Python distribution that already has SciPy installed like, Anaconda, Spyder etc.","5ef64343":"# Time:\nReturn the specified unit in seconds (e.g. hour returns 3600.0)\n\nExample","ca8ceb8d":"# SciPy Sparse Data\n\n+ What is Sparse Data\n\nSparse data is data that has mostly unused elements (elements that don't carry any information ).\n\nIt can be an array like this one:\n\n[1, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0]","60d0d669":"# Adjacency Matrix\n\n+ Adjacency matrix is a nxn matrix where n is the number of elements in a graph.\n\n+ And the values represents the connection between the elements.\n\n","bf8f5b3f":"#  What is SciPy?\n\n+ SciPy is a scientific computation library that uses NumPy underneath.\n\n+ SciPy stands for Scientific Python.\n\n+ It provides more utility functions for optimization, stats and signal processing.\n\n+ Like NumPy, SciPy is open source so we can use it freely.\n\n+ SciPy was created by NumPy's creator Travis Olliphant."}}