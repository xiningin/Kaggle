{"cell_type":{"b9171d46":"code","a86663d2":"code","aca88e31":"code","a8669c99":"code","973eb921":"code","cf610c97":"code","48059c42":"code","79fd0a3d":"code","f81b15c6":"code","14d2b5c7":"code","2d9d8f85":"code","726a7f85":"code","b419662c":"code","e2cdd412":"code","643da119":"code","3ea98add":"code","a13ba3d0":"code","53323d09":"code","28b4ae2d":"code","74d8f42d":"code","ec3b3437":"code","ef4f5535":"code","2436626b":"code","be1c7eb0":"code","7b80f651":"markdown","baa2886e":"markdown","8c1a4e11":"markdown","e283b07b":"markdown","1dbd89b7":"markdown","33bd6f75":"markdown","44af8b1f":"markdown","287eda0a":"markdown","05cd5771":"markdown","8a60cf2d":"markdown","71e57d0d":"markdown","d6e883d4":"markdown","e1f7ecf4":"markdown","43ffbe2d":"markdown","5efb76cc":"markdown","6be29e21":"markdown"},"source":{"b9171d46":"import os\nimport gc\ngc.enable()\nimport math\nimport json\nimport time\nimport random\nimport multiprocessing\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm, trange\nfrom sklearn import model_selection\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn import Parameter\nimport torch.optim as optim\nfrom torch.utils.data import (\n    Dataset, DataLoader,\n    SequentialSampler, RandomSampler\n)\nfrom torch.utils.data.distributed import DistributedSampler\n\ntry:\n    from apex import amp\n    APEX_INSTALLED = True\nexcept ImportError:\n    APEX_INSTALLED = False\n\nimport transformers\nfrom transformers import (\n    WEIGHTS_NAME,\n    AdamW,\n    AutoConfig,\n    AutoModel,\n    AutoTokenizer,\n    get_cosine_schedule_with_warmup,\n    get_linear_schedule_with_warmup,\n    logging,\n    MODEL_FOR_QUESTION_ANSWERING_MAPPING,\n)\nlogging.set_verbosity_warning()\nlogging.set_verbosity_error()\n\ndef fix_all_seeds(seed):\n    np.random.seed(seed)\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n\ndef optimal_num_of_loader_workers():\n    num_cpus = multiprocessing.cpu_count()\n    num_gpus = torch.cuda.device_count()\n    optimal_value = min(num_cpus, num_gpus*4) if num_gpus else num_cpus - 1\n    return optimal_value\n\nMODEL_CONFIG_CLASSES = list(MODEL_FOR_QUESTION_ANSWERING_MAPPING.keys())\nMODEL_TYPES = tuple(conf.model_type for conf in MODEL_CONFIG_CLASSES)","a86663d2":"tamil_xquad_tr = pd.read_csv('..\/input\/google-translated-squad20-to-hindi-and-tamil\/squad_ta.csv')\nhindi_xquad_tr = pd.read_csv('..\/input\/google-translated-squad20-to-hindi-and-tamil\/squad_hi.csv')\nhindi_xquad_tr.head()","aca88e31":"import ast\nhindi_xquad_tr['answers'] = hindi_xquad_tr['answers'].apply(ast.literal_eval)\ntamil_xquad_tr['answers'] = tamil_xquad_tr['answers'].apply(ast.literal_eval)\n\ndef get_text(d):\n    return d[0]['text']\ndef get_start(d):\n    return d[0]['answer_start']\n\nhindi_xquad_tr['answer_text'] = hindi_xquad_tr['answers'].apply(get_text)\nhindi_xquad_tr['answer_start'] = hindi_xquad_tr['answers'].apply(get_start)\ntamil_xquad_tr['answer_text'] = tamil_xquad_tr['answers'].apply(get_text)\ntamil_xquad_tr['answer_start'] = tamil_xquad_tr['answers'].apply(get_start)\n\nhindi_xquad_tr['language'] = 'hindi'\ntamil_xquad_tr['language'] = 'tamil'\n\nhindi_xquad_tr.drop(['id','answers','c_id','is_in'], axis=1, inplace=True)\ntamil_xquad_tr.drop(['id','answers','c_id','is_in'], axis=1, inplace=True)\n\nhindi_xquad_tr = hindi_xquad_tr[hindi_xquad_tr['answer_start']!=-1]\ntamil_xquad_tr = tamil_xquad_tr[tamil_xquad_tr['answer_start']!=-1]\n\nhindi_xquad_tr = hindi_xquad_tr.sample(frac=0.03)\ntamil_xquad_tr = tamil_xquad_tr.sample(frac=0.05)\n\ntamil_xquad_tr.shape,hindi_xquad_tr.shape","a8669c99":"tamil_xquad_tr","973eb921":"XQA_tamil_dev = pd.read_csv('..\/input\/preprocessed-xqa-tamil\/XQA_tamil_dev.csv')\nXQA_tamil_test = pd.read_csv('..\/input\/preprocessed-xqa-tamil\/XQA_tamil_test.csv')\nXQA_tamil_dev = XQA_tamil_dev[XQA_tamil_dev['answer_start']!=-1]\nXQA_tamil_test = XQA_tamil_test[XQA_tamil_test['answer_start']!=-1]\nXQA_tamil_dev = XQA_tamil_dev.sample(frac=0.5)\nXQA_tamil_test = XQA_tamil_test.sample(frac=0.5)\nXQA_tamil_dev.head()","cf610c97":"XQA_tamil_test.shape,XQA_tamil_dev.shape","48059c42":"class Config:\n    # model\n    model_type = 'xlm_roberta'\n    model_name_or_path = '..\/input\/xlm-roberta-squad2\/deepset\/xlm-roberta-large-squad2'\n    config_name = '..\/input\/xlm-roberta-squad2\/deepset\/xlm-roberta-large-squad2'\n    fp16 = True if APEX_INSTALLED else False\n    fp16_opt_level = \"O1\"\n    gradient_accumulation_steps = 2\n\n    # tokenizer\n    tokenizer_name = '..\/input\/xlm-roberta-squad2\/deepset\/xlm-roberta-large-squad2'\n    max_seq_length = 400\n    doc_stride = 135\n\n    # train\n    epochs = 1\n    train_batch_size = 4\n    eval_batch_size = 8\n\n    # optimizer\n    optimizer_type = 'AdamW'\n    learning_rate = 1e-5\n    weight_decay = 1e-2\n    epsilon = 1e-8\n    max_grad_norm = 1.0\n    \n    # scheduler\n    decay_name = 'cosine-warmup'\n    warmup_ratio = 0.1\n\n    # logging\n    logging_steps = 10\n\n    # evaluate\n    output_dir = 'output'\n    seed = 43","79fd0a3d":"train = pd.read_csv('..\/input\/chaii-hindi-and-tamil-question-answering\/train.csv')\ntest = pd.read_csv('..\/input\/chaii-hindi-and-tamil-question-answering\/test.csv')\nexternal_mlqa = pd.read_csv('..\/input\/mlqa-hindi-processed\/mlqa_hindi.csv')\nexternal_xquad = pd.read_csv('..\/input\/mlqa-hindi-processed\/xquad.csv')\nexternal_train = pd.concat([external_mlqa, external_xquad,XQA_tamil_dev,XQA_tamil_test,hindi_xquad_tr, tamil_xquad_tr])#\n\ndef create_folds(data, num_splits):\n    data[\"kfold\"] = -1\n    kf = model_selection.StratifiedKFold(n_splits=num_splits, shuffle=True, random_state=43)\n    for f, (t_, v_) in enumerate(kf.split(X=data, y=data['language'])):\n        data.loc[v_, 'kfold'] = f\n    return data\n\ntrain = create_folds(train, num_splits=5)\nexternal_train[\"kfold\"] = -1\nexternal_train['id'] = list(np.arange(1, len(external_train)+1))\ntrain = pd.concat([train, external_train]).reset_index(drop=True)\n\ndef convert_answers(row):\n    return {'answer_start': [row[0]], 'text': [row[1]]}\n\ntrain['answers'] = train[['answer_start', 'answer_text']].apply(convert_answers, axis=1)","f81b15c6":"len(train)","14d2b5c7":"train = train.drop_duplicates(subset=['context','question','answer_text','answer_start','language'])\nlen(train)","2d9d8f85":"def prepare_train_features(args, example, tokenizer):\n    example[\"question\"] = example[\"question\"].lstrip()\n    tokenized_example = tokenizer(\n        example[\"question\"],\n        example[\"context\"],\n        truncation=\"only_second\",\n        max_length=args.max_seq_length,\n        stride=args.doc_stride,\n        return_overflowing_tokens=True,\n        return_offsets_mapping=True,\n        padding=\"max_length\",\n    )\n\n    sample_mapping = tokenized_example.pop(\"overflow_to_sample_mapping\")\n    offset_mapping = tokenized_example.pop(\"offset_mapping\")\n\n    features = []\n    for i, offsets in enumerate(offset_mapping):\n        feature = {}\n\n        input_ids = tokenized_example[\"input_ids\"][i]\n        attention_mask = tokenized_example[\"attention_mask\"][i]\n\n        feature['input_ids'] = input_ids\n        feature['attention_mask'] = attention_mask\n        feature['offset_mapping'] = offsets\n\n        cls_index = input_ids.index(tokenizer.cls_token_id)\n        sequence_ids = tokenized_example.sequence_ids(i)\n        \n        ## for validation\n        feature[\"example_id\"] = example['id'] \n        feature['sequence_ids'] = [0 if i is None else i for i in tokenized_example.sequence_ids(i)] \n        feature['context'] = example[\"context\"]\n        feature['question'] = example[\"question\"]\n        feature['hindi_tamil'] = 0 if example[\"language\"]=='hindi' else 1 \n        ## \n\n        sample_index = sample_mapping[i]\n        answers = example[\"answers\"]\n\n        if len(answers[\"answer_start\"]) == 0:\n            feature[\"start_position\"] = cls_index\n            feature[\"end_position\"] = cls_index\n        else:\n            start_char = answers[\"answer_start\"][0]\n            end_char = start_char + len(answers[\"text\"][0])\n\n            token_start_index = 0\n            while sequence_ids[token_start_index] != 1:\n                token_start_index += 1\n\n            token_end_index = len(input_ids) - 1\n            while sequence_ids[token_end_index] != 1:\n                token_end_index -= 1\n\n            if not (offsets[token_start_index][0] <= start_char and offsets[token_end_index][1] >= end_char):\n                feature[\"start_position\"] = cls_index\n                feature[\"end_position\"] = cls_index\n            else:\n                while token_start_index < len(offsets) and offsets[token_start_index][0] <= start_char:\n                    token_start_index += 1\n                feature[\"start_position\"] = token_start_index - 1\n                while offsets[token_end_index][1] >= end_char:\n                    token_end_index -= 1\n                feature[\"end_position\"] = token_end_index + 1\n\n        features.append(feature)\n    return features","726a7f85":"class DatasetRetriever(Dataset):\n    def __init__(self, features, mode='train'):\n        super(DatasetRetriever, self).__init__()\n        self.features = features\n        self.mode = mode\n        \n    def __len__(self):\n        return len(self.features)\n    \n    def __getitem__(self, item):   \n        feature = self.features[item]\n        if self.mode == 'train':\n            return {\n                'input_ids':torch.tensor(feature['input_ids'], dtype=torch.long),\n                'attention_mask':torch.tensor(feature['attention_mask'], dtype=torch.long),\n                'offset_mapping':torch.tensor(feature['offset_mapping'], dtype=torch.long),\n                'start_position':torch.tensor(feature['start_position'], dtype=torch.long),\n                'end_position':torch.tensor(feature['end_position'], dtype=torch.long)\n            }\n        else:\n            if self.mode == 'valid': \n                return {\n                'input_ids':torch.tensor(feature['input_ids'], dtype=torch.long),\n                'attention_mask':torch.tensor(feature['attention_mask'], dtype=torch.long),\n                'offset_mapping':torch.tensor(feature['offset_mapping'], dtype=torch.long),\n                'sequence_ids':feature['sequence_ids'],\n                'start_position':torch.tensor(feature['start_position'], dtype=torch.long),\n                'end_position':torch.tensor(feature['end_position'], dtype=torch.long),\n                'example_id':feature['example_id'],\n                'context': feature['context'],\n                }\n            else:\n                return {\n                    'input_ids':torch.tensor(feature['input_ids'], dtype=torch.long),\n                    'attention_mask':torch.tensor(feature['attention_mask'], dtype=torch.long),\n                    'offset_mapping':feature['offset_mapping'],\n                    'sequence_ids':feature['sequence_ids'],\n                    'id':feature['example_id'],\n                    'context': feature['context'],\n                    'question': feature['question']\n                }","b419662c":"class WeightedLayerPooling(nn.Module):\n    def __init__(self, num_hidden_layers, layer_start: int = 4, layer_weights=None):\n        super(WeightedLayerPooling, self).__init__()\n        self.layer_start = layer_start\n        self.num_hidden_layers = num_hidden_layers\n        self.layer_weights = layer_weights if layer_weights is not None \\\n            else nn.Parameter(\n            torch.tensor([1] * (num_hidden_layers + 1 - layer_start), dtype=torch.float)\n        )\n\n    def forward(self, all_hidden_states):\n        all_layer_embedding = all_hidden_states[self.layer_start:, :, :, :]\n        weight_factor = self.layer_weights.unsqueeze(-1).unsqueeze(-1).unsqueeze(-1).expand(all_layer_embedding.size())\n        weighted_average = (weight_factor * all_layer_embedding).sum(dim=0) \/ self.layer_weights.sum()\n        return weighted_average\n\n\nclass Model(nn.Module):\n    def __init__(self, modelname_or_path, config, layer_start, layer_weights=None):\n        super(Model, self).__init__()\n        self.config = config\n        config.update({\n            \"hidden_dropout_prob\": 0.0,\n            \"layer_norm_eps\": 1e-7,\n            \"output_hidden_states\": True\n        })\n        self.xlm_roberta = AutoModel.from_pretrained(modelname_or_path, config=config)\n        self.layer_start = layer_start\n        self.pooling = WeightedLayerPooling(config.num_hidden_layers,\n                                            layer_start=layer_start,\n                                            layer_weights=None)\n        self.layer_norm = nn.LayerNorm(config.hidden_size)\n        self.dropout = torch.nn.Dropout(0.3)\n        self.qa_output = torch.nn.Linear(config.hidden_size, 2)\n        torch.nn.init.normal_(self.qa_output.weight, std=0.02)\n\n    def forward(self, input_ids, attention_mask=None):\n        outputs = self.xlm_roberta(input_ids, attention_mask=attention_mask)\n        all_hidden_states = torch.stack(outputs.hidden_states)\n        weighted_pooling_embeddings = self.layer_norm(self.pooling(all_hidden_states))\n        #weighted_pooling_embeddings = weighted_pooling_embeddings[:, 0]\n\n        norm_embeddings = self.dropout(weighted_pooling_embeddings)\n        logits = self.qa_output(norm_embeddings)\n        start_logits, end_logits = logits.split(1, dim=-1)\n\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        return start_logits, end_logits","e2cdd412":"def loss_fn(preds, labels):\n    start_preds, end_preds = preds\n    start_labels, end_labels = labels\n    start_loss = nn.CrossEntropyLoss(ignore_index=-1)(start_preds, start_labels)\n    end_loss = nn.CrossEntropyLoss(ignore_index=-1)(end_preds, end_labels)\n    total_loss = (start_loss + end_loss) \/ 2\n    return total_loss","643da119":"def get_optimizer_grouped_parameters(args, model):\n    no_decay = [\"bias\", \"LayerNorm.weight\"]\n    group1=['layer.0.','layer.1.','layer.2.','layer.3.']\n    group2=['layer.4.','layer.5.','layer.6.','layer.7.']    \n    group3=['layer.8.','layer.9.','layer.10.','layer.11.']\n    group_all=['layer.0.','layer.1.','layer.2.','layer.3.','layer.4.','layer.5.','layer.6.','layer.7.','layer.8.','layer.9.','layer.10.','layer.11.']\n    optimizer_grouped_parameters = [\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if not any(nd in n for nd in no_decay) and not any(nd in n for nd in group_all)],'weight_decay': args.weight_decay},\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if not any(nd in n for nd in no_decay) and any(nd in n for nd in group1)],'weight_decay': args.weight_decay, 'lr': args.learning_rate\/10},\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if not any(nd in n for nd in no_decay) and any(nd in n for nd in group2)],'weight_decay': args.weight_decay, 'lr': args.learning_rate},\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if not any(nd in n for nd in no_decay) and any(nd in n for nd in group3)],'weight_decay': args.weight_decay, 'lr': args.learning_rate*10},\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if any(nd in n for nd in no_decay) and not any(nd in n for nd in group_all)],'weight_decay': 0.0},\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if any(nd in n for nd in no_decay) and any(nd in n for nd in group1)],'weight_decay': 0.0, 'lr': args.learning_rate\/10},\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if any(nd in n for nd in no_decay) and any(nd in n for nd in group2)],'weight_decay': 0.0, 'lr': args.learning_rate},\n        {'params': [p for n, p in model.xlm_roberta.named_parameters() if any(nd in n for nd in no_decay) and any(nd in n for nd in group3)],'weight_decay': 0.0, 'lr': args.learning_rate*10},\n        {'params': [p for n, p in model.named_parameters() if args.model_type not in n], 'lr':args.learning_rate*40, \"weight_decay\": 0.0},\n    ]\n    return optimizer_grouped_parameters","3ea98add":"class AverageMeter(object):\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n        self.max = 0\n        self.min = 1e5\n\n    def update(self, val, n=1):\n        self.val = val\n        self.sum += val * n\n        self.count += n\n        self.avg = self.sum \/ self.count\n        if val > self.max:\n            self.max = val\n        if val < self.min:\n            self.min = val","a13ba3d0":"def make_model(args):\n    config = AutoConfig.from_pretrained(args.config_name)\n    tokenizer = AutoTokenizer.from_pretrained(args.tokenizer_name)\n    model = Model(args.model_name_or_path, config=config,layer_start=12,layer_weights=None)\n    #model = Model(args.model_name_or_path, config=config)\n    return config, tokenizer, model\n\ndef make_optimizer(args, model):\n    named_parameters = list(model.named_parameters())   \n\n    roberta_parameters = named_parameters[:389]   \n    pooler_parameters = named_parameters[389:391] \n    qa_parameters = named_parameters[391:]\n    \n    parameters = []\n    \n    # increase lr every k layer\n    increase_lr_every_k_layer = 1\n    lrs = np.linspace(1, 5, 24 \/\/ increase_lr_every_k_layer)\n    for layer_num, (name, params) in enumerate(roberta_parameters):\n        weight_decay = 0.0 if \"bias\" in name else 0.01\n        splitted_name = name.split('.')\n        lr = args.learning_rate #Config.lr\n        if len(splitted_name) >= 4 and str.isdigit(splitted_name[3]):\n            layer_num = int(splitted_name[3])\n            lr = lrs[layer_num \/\/ increase_lr_every_k_layer] * lr\n\n        parameters.append({\"params\": params,\n                           \"weight_decay\": weight_decay,\n                           \"lr\": lr})\n    \n    default_lr = 1e-3 #default LR for AdamW\n    for layer_num, (name,params) in enumerate(qa_parameters):\n        weight_decay = 0.0 if \"bias\" in name else 0.01\n        parameters.append({\"params\": params,\n                           \"weight_decay\": weight_decay,\n                           \"lr\": default_lr})\n    \n    for layer_num, (name,params) in enumerate(pooler_parameters):\n        weight_decay = 0.0 if \"bias\" in name else 0.01\n        parameters.append({\"params\": params,\n                           \"weight_decay\": weight_decay,\n                           \"lr\": default_lr})\n\n    return AdamW(parameters)\n\n\ndef make_scheduler(\n    args, optimizer, \n    num_warmup_steps, \n    num_training_steps\n):\n    if args.decay_name == \"cosine-warmup\":\n        scheduler = get_cosine_schedule_with_warmup(\n            optimizer,\n            num_warmup_steps=num_warmup_steps,\n            num_training_steps=num_training_steps\n        )\n    else:\n        scheduler = get_linear_schedule_with_warmup(\n            optimizer,\n            num_warmup_steps=num_warmup_steps,\n            num_training_steps=num_training_steps\n        )\n    return scheduler    \n\n\ndef make_loader(\n    args, data, \n    tokenizer, fold\n):\n    train_set, valid_set = data[data['kfold']!=fold], data[data['kfold']==fold].reset_index(drop=True)\n    \n    train_features, valid_features = [[] for _ in range(2)]\n    for i, row in train_set.iterrows():\n        train_features += prepare_train_features(args, row, tokenizer)\n    for i, row in valid_set.iterrows():\n        valid_features += prepare_train_features(args, row, tokenizer)\n\n    ## Weighted sampler\n    hindi_tamil_count = [] \n    for i, f in enumerate(train_features):\n        hindi_tamil_count.append(train_features[i]['hindi_tamil'])      \n    class_sample_count = pd.Series(hindi_tamil_count).value_counts().values\n    weight = 1. \/ class_sample_count\n    samples_weight = np.array([weight[t] for t in hindi_tamil_count]) \n    samples_weight = torch.from_numpy(samples_weight)\n    wsampler = torch.utils.data.sampler.WeightedRandomSampler(samples_weight.type('torch.DoubleTensor'), len(samples_weight))\n\n    train_dataset = DatasetRetriever(train_features, mode=\"train\")\n    valid_dataset = DatasetRetriever(valid_features, mode=\"valid\")\n    print(f\"Num examples Train= {len(train_dataset)}, Num examples Valid={len(valid_dataset)}\")\n    \n    train_sampler = RandomSampler(train_dataset)\n    valid_sampler = SequentialSampler(valid_dataset)\n\n    train_dataloader = DataLoader(\n        train_dataset,\n        batch_size=args.train_batch_size,\n        sampler=train_sampler, #wsampler\n        num_workers=optimal_num_of_loader_workers(),\n        pin_memory=True,\n        drop_last=False \n    )\n\n    valid_dataloader = DataLoader(\n        valid_dataset,\n        batch_size=args.eval_batch_size, \n        sampler=valid_sampler,\n        num_workers=optimal_num_of_loader_workers(),\n        pin_memory=True, \n        drop_last=False\n    )\n\n    return train_dataloader, valid_dataloader, valid_features, valid_set","53323d09":"class Trainer:\n    def __init__(\n        self, model, tokenizer, \n        optimizer, scheduler\n    ):\n        self.model = model\n        self.tokenizer = tokenizer\n        self.optimizer = optimizer\n        self.scheduler = scheduler\n\n    def train(\n        self, args, \n        train_dataloader, \n        epoch, result_dict\n    ):\n        count = 0\n        losses = AverageMeter()\n        \n        self.model.zero_grad()\n        self.model.train()\n        \n        fix_all_seeds(args.seed)\n        \n        for batch_idx, batch_data in enumerate(train_dataloader):\n            input_ids, attention_mask, targets_start, targets_end = \\\n                batch_data['input_ids'], batch_data['attention_mask'], \\\n                    batch_data['start_position'], batch_data['end_position']\n            \n            input_ids, attention_mask, targets_start, targets_end = \\\n                input_ids.cuda(), attention_mask.cuda(), targets_start.cuda(), targets_end.cuda()\n\n            outputs_start, outputs_end = self.model(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n            )\n            \n            loss = loss_fn((outputs_start, outputs_end), (targets_start, targets_end))\n            loss = loss \/ args.gradient_accumulation_steps\n\n            if args.fp16:\n                with amp.scale_loss(loss, self.optimizer) as scaled_loss:\n                    scaled_loss.backward()\n            else:\n                loss.backward()\n\n            count += input_ids.size(0)\n            losses.update(loss.item(), input_ids.size(0))\n\n            # if args.fp16:\n            #     torch.nn.utils.clip_grad_norm_(amp.master_params(self.optimizer), args.max_grad_norm)\n            # else:\n            #     torch.nn.utils.clip_grad_norm_(self.model.parameters(), args.max_grad_norm)\n\n            if batch_idx % args.gradient_accumulation_steps == 0 or batch_idx == len(train_dataloader) - 1:\n                self.optimizer.step()\n                self.scheduler.step()\n                self.optimizer.zero_grad()\n\n            if (batch_idx % args.logging_steps == 0) or (batch_idx+1)==len(train_dataloader):\n                _s = str(len(str(len(train_dataloader.sampler))))\n                ret = [\n                    ('Epoch: {:0>2} [{: >' + _s + '}\/{} ({: >3.0f}%)]').format(epoch, count, len(train_dataloader.sampler), 100 * count \/ len(train_dataloader.sampler)),\n                    'Train Loss: {: >4.5f}'.format(losses.avg),\n                ]\n                print(', '.join(ret))\n\n        result_dict['train_loss'].append(losses.avg)\n        return result_dict","28b4ae2d":"class Evaluator:\n    def __init__(self, model):\n        self.model = model\n    \n    def save(self, result, output_dir):\n        with open(f'{output_dir}\/result_dict.json', 'w') as f:\n            f.write(json.dumps(result, sort_keys=True, indent=4, ensure_ascii=False))\n\n    def evaluate(self, valid_dataloader, epoch, result_dict):\n        losses = AverageMeter()\n        all_outputs_start, all_outputs_end = [], []\n        for batch_idx, batch_data in enumerate(valid_dataloader):\n            self.model = self.model.eval()\n            input_ids, attention_mask, targets_start, targets_end = \\\n                batch_data['input_ids'], batch_data['attention_mask'], \\\n                    batch_data['start_position'], batch_data['end_position']\n            \n            input_ids, attention_mask, targets_start, targets_end = \\\n                input_ids.cuda(), attention_mask.cuda(), targets_start.cuda(), targets_end.cuda()\n            \n            with torch.no_grad():            \n                outputs_start, outputs_end = self.model(\n                    input_ids=input_ids,\n                    attention_mask=attention_mask,\n                )\n                all_outputs_start.append(outputs_start.cpu().numpy().tolist())\n                all_outputs_end.append(outputs_end.cpu().numpy().tolist())\n        \n                loss = loss_fn((outputs_start, outputs_end), (targets_start, targets_end))\n                losses.update(loss.item(), input_ids.size(0))\n                \n        all_outputs_start = np.vstack(all_outputs_start)\n        all_outputs_end = np.vstack(all_outputs_end)\n\n        print('----Validation Results Summary----')\n        print('Epoch: [{}] Valid Loss: {: >4.5f}'.format(epoch, losses.avg))\n        result_dict['val_loss'].append(losses.avg)        \n        return result_dict, all_outputs_start, all_outputs_end\n    \n    ","74d8f42d":"def init_training(args, data, fold):\n    fix_all_seeds(args.seed)\n    \n    if not os.path.exists(args.output_dir):\n        os.makedirs(args.output_dir)\n    \n    # model\n    model_config, tokenizer, model = make_model(args)\n    if torch.cuda.device_count() >= 1:\n        print('Model pushed to {} GPU(s), type {}.'.format(\n            torch.cuda.device_count(), \n            torch.cuda.get_device_name(0))\n        )\n        model = model.cuda() \n    else:\n        raise ValueError('CPU training is not supported')\n    \n    # data loaders\n    train_dataloader, valid_dataloader, valid_features, valid_set = make_loader(args, data, tokenizer, fold)\n\n    # optimizer\n    optimizer = make_optimizer(args, model)\n\n    # scheduler\n    num_training_steps = math.ceil(len(train_dataloader) \/ args.gradient_accumulation_steps) * args.epochs\n    if args.warmup_ratio > 0:\n        num_warmup_steps = int(args.warmup_ratio * num_training_steps)\n    else:\n        num_warmup_steps = 0\n    print(f\"Total Training Steps: {num_training_steps}, Total Warmup Steps: {num_warmup_steps}\")\n    scheduler = make_scheduler(args, optimizer, num_warmup_steps, num_training_steps)\n\n    # mixed precision training with NVIDIA Apex\n    if args.fp16:\n        model, optimizer = amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)\n    \n    result_dict = {\n        'epoch':[], \n        'train_loss': [], \n        'val_loss' : [], \n        'best_val_loss': np.inf\n    }\n\n    return (\n        model, model_config, tokenizer, optimizer, scheduler, \n        train_dataloader, valid_dataloader, result_dict, valid_features, valid_set\n    )","ec3b3437":"# Ref: https:\/\/www.kaggle.com\/rhtsingh\/chaii-qa-5-fold-xlmroberta-torch-infer\nimport collections\n\ndef postprocess_qa_predictions(examples, features1, raw_predictions, tokenizer, n_best_size = 20, max_answer_length = 30):\n    features = features1\n    all_start_logits, all_end_logits = raw_predictions\n    \n    example_id_to_index = {k: i for i, k in enumerate(examples[\"id\"])}\n    features_per_example = collections.defaultdict(list)\n    for i, feature in enumerate(features):\n        features_per_example[example_id_to_index[feature[\"example_id\"]]].append(i)\n\n    predictions = collections.OrderedDict()\n\n    print(f\"Post-processing {len(examples)} example predictions split into {len(features)} features.\")\n\n    for example_index, example in examples.iterrows():\n        feature_indices = features_per_example[example_index]\n        #print(example['id'],example_index,feature_indices)\n        min_null_score = None\n        valid_answers = []\n        \n        context = example[\"context\"]\n        for feature_index in feature_indices:\n            start_logits = all_start_logits[feature_index]\n            end_logits = all_end_logits[feature_index]\n\n            sequence_ids = features[feature_index][\"sequence_ids\"]\n            context_index = 1\n\n            offset_mapping = [\n                (o if sequence_ids[k] == context_index else None)\n                for k, o in enumerate(features[feature_index][\"offset_mapping\"])\n            ]    \n        \n            cls_index = features[feature_index][\"input_ids\"].index(tokenizer.cls_token_id)\n            feature_null_score = start_logits[cls_index] + end_logits[cls_index]\n            if min_null_score is None or min_null_score < feature_null_score:\n                min_null_score = feature_null_score\n\n            start_indexes = np.argsort(start_logits)[-1 : -n_best_size - 1 : -1].tolist()\n            end_indexes = np.argsort(end_logits)[-1 : -n_best_size - 1 : -1].tolist()\n            for start_index in start_indexes:\n                for end_index in end_indexes:\n                    if (\n                        start_index >= len(offset_mapping)\n                        or end_index >= len(offset_mapping)\n                        or offset_mapping[start_index] is None\n                        or offset_mapping[end_index] is None\n                    ):\n                        continue\n                    # Don't consider answers with a length that is either < 0 or > max_answer_length.\n                    if end_index < start_index or end_index - start_index + 1 > max_answer_length:\n                        continue\n\n                    start_char = offset_mapping[start_index][0]\n                    end_char = offset_mapping[end_index][1]\n                    valid_answers.append(\n                        {\n                            \"score\": start_logits[start_index] + end_logits[end_index],\n                            \"text\": context[start_char: end_char]\n                        }\n                    )\n        \n        if len(valid_answers) > 0:\n            best_answer = sorted(valid_answers, key=lambda x: x[\"score\"], reverse=True)[0]\n        else:\n            best_answer = {\"text\": \"\", \"score\": 0.0}\n        \n        predictions[example[\"id\"]] = best_answer[\"text\"]\n        \n        \n    return predictions","ef4f5535":"def jaccard(str1, str2): \n    a = set(str1.lower().split()) \n    b = set(str2.lower().split())\n    c = a.intersection(b)\n    return float(len(c)) \/ (len(a) + len(b) - len(c))","2436626b":"all_jacard_scores = []\n\ndef run(data, fold):\n    args = Config()\n    model, model_config, tokenizer, optimizer, scheduler, train_dataloader, \\\n        valid_dataloader, result_dict, valid_features, valid_set = init_training(args, data, fold)\n    \n    trainer = Trainer(model, tokenizer, optimizer, scheduler)\n    evaluator = Evaluator(model)\n\n    train_time_list = []\n    valid_time_list = []\n\n    for epoch in range(args.epochs):\n        result_dict['epoch'].append(epoch)\n\n        # Train\n        torch.cuda.synchronize()\n        tic1 = time.time()\n        result_dict = trainer.train(\n            args, train_dataloader, \n            epoch, result_dict\n        )\n        torch.cuda.synchronize()\n        tic2 = time.time() \n        train_time_list.append(tic2 - tic1)\n        # Evaluate\n        torch.cuda.synchronize()\n        tic3 = time.time()\n        result_dict, all_outputs_start, all_outputs_end = evaluator.evaluate(\n            valid_dataloader, epoch, result_dict\n        )\n        torch.cuda.synchronize()\n#         # Get valid jaccard score\n        valid_features1 = valid_features.copy()\n        valid_preds = postprocess_qa_predictions(valid_set, valid_features1, (all_outputs_start, all_outputs_end), tokenizer)\n        valid_set['PredictionString'] = valid_set['id'].map(valid_preds)\n        valid_set['jaccard'] = valid_set[['answer_text','PredictionString']].apply(lambda x: jaccard(x[0],x[1]), axis=1)\n        print(\"valid jaccard: \",np.mean(valid_set.jaccard))\n        all_jacard_scores.append(np.mean(valid_set.jaccard))\n        \n        tic4 = time.time() \n        valid_time_list.append(tic4 - tic3)\n            \n        output_dir = os.path.join(args.output_dir, f\"checkpoint-fold-{fold}-epoch-{epoch}\")\n        os.makedirs(output_dir, exist_ok=True)\n        if result_dict['val_loss'][-1] < result_dict['best_val_loss']:\n            print(\"{} Epoch, Best epoch was updated! Valid Loss: {: >4.5f}\".format(epoch, result_dict['val_loss'][-1]))\n            result_dict[\"best_val_loss\"] = result_dict['val_loss'][-1]        \n            \n#             os.makedirs(output_dir, exist_ok=True)\n            torch.save(model.state_dict(), f\"{output_dir}\/pytorch_model.bin\")\n            model_config.save_pretrained(output_dir)\n            tokenizer.save_pretrained(output_dir)\n            print(f\"Saving model checkpoint to {output_dir}.\")\n            \n        print()\n\n    evaluator.save(result_dict, output_dir)\n    \n    print(f\"Total Training Time: {np.sum(train_time_list)}secs, Average Training Time per Epoch: {np.mean(train_time_list)}secs.\")\n    print(f\"Total Validation Time: {np.sum(valid_time_list)}secs, Average Validation Time per Epoch: {np.mean(valid_time_list)}secs.\")\n    \n    #del trainer, evaluator\n    #del model, model_config, tokenizer\n    #del optimizer, scheduler\n    #del train_dataloader, valid_dataloader, result_dict","be1c7eb0":"for fold in range(5):\n  print();print()\n  print('-'*50)\n  print(f'FOLD: {fold}')\n  print('-'*50)\n  run(train, fold)\n\nprint(\"*\"*50)\nprint(\"Final jacard scores, 5-fold: \", np.round(all_jacard_scores,5))\nprint(\"Average jacard:\",np.mean(all_jacard_scores))\nprint(\"*\"*50)","7b80f651":"#### Model","baa2886e":"#### Evaluator","8c1a4e11":"#### Training Configuration","e283b07b":"#### Run","1dbd89b7":"#### Trainer","33bd6f75":"#### Convert Examples to Features (Preprocess)","44af8b1f":"Original notebook by @rhtsingh -  https:\/\/www.kaggle.com\/rashmibanthia\/xlm-roberta-jaccard-validation-mean-max-head\n\nI have added - \n - replace the mean\/max head with weightedlayerpooling\n \n ","287eda0a":"#### Utilities","05cd5771":"#### Validation Jaccard","8a60cf2d":"#### Initialize Training","71e57d0d":"#### Data Factory","d6e883d4":"#### Grouped Layerwise Learning Rate Decay","e1f7ecf4":"#### Dataset Retriever","43ffbe2d":"#### Import Dependencies","5efb76cc":"#### Loss","6be29e21":"#### Metric Logger"}}