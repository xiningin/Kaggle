{"cell_type":{"8d3d116a":"code","4b32a21b":"code","29f0ec82":"code","47d08e80":"code","ea72bc61":"code","8304af49":"code","b4a5c09a":"code","451967f8":"code","8b4e517a":"code","026bfb62":"code","31123e6f":"code","890d9a61":"code","3cd2f53e":"code","46505f2e":"code","962bf1b4":"code","5956853d":"code","1b379f7c":"code","b6170dbe":"code","892e594e":"code","d831f3c6":"code","b08f24e8":"code","503843f2":"code","b76a3510":"code","c8e53cca":"code","4a7d6d5c":"markdown","dc685532":"markdown","ed26b31c":"markdown","85486690":"markdown","52341e15":"markdown","7245a0ff":"markdown","a6d1a9bb":"markdown","75ea2c10":"markdown","cb7ff438":"markdown","415af97a":"markdown","77d430ec":"markdown","105bee9a":"markdown","370e2b07":"markdown","b0659100":"markdown","5a917666":"markdown","71b7acb5":"markdown","34b6ce0e":"markdown","5f162fc0":"markdown","bc7a3805":"markdown","5f48fdba":"markdown","9362814e":"markdown","0a2f67e5":"markdown"},"source":{"8d3d116a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file \\\\I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","4b32a21b":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline \n\nfrom scipy import stats\nfrom scipy.stats import norm, skew\n\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder, StandardScaler, MinMaxScaler, RobustScaler\nfrom sklearn.model_selection import train_test_split, KFold, GroupKFold, GridSearchCV, StratifiedKFold\n\nfrom sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier, AdaBoostClassifier\nfrom sklearn.neighbors import KNeighborsRegressor, KernelDensity, KDTree\nfrom sklearn.metrics import *\n\nfrom imblearn.over_sampling import SMOTE, BorderlineSMOTE, ADASYN, RandomOverSampler, SMOTENC, SVMSMOTE\nfrom imblearn.combine import SMOTETomek, SMOTEENN\nfrom imblearn.under_sampling import ClusterCentroids, TomekLinks, NearMiss, RandomUnderSampler, AllKNN, CondensedNearestNeighbour,\\\n                                        NeighbourhoodCleaningRule, OneSidedSelection, RepeatedEditedNearestNeighbours, InstanceHardnessThreshold\n\n\n\nimport sys, os\nimport random \n\nif not sys.warnoptions:\n    import warnings\n    warnings.simplefilter(\"ignore\")\n    \nfrom IPython.display import display\n\n\ndef set_seed(seed=4242):\n    random.seed(seed)\n    np.random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\nset_seed()","29f0ec82":"train  = pd.read_csv('\/kaggle\/input\/imbalanced-data-practice\/aug_train.csv')\ntest  = pd.read_csv('\/kaggle\/input\/imbalanced-data-practice\/aug_test.csv')\nanswers = np.load('\/kaggle\/input\/answer\/answer.npy')\nprint(train.shape, test.shape)\ndisplay(train.head())\ndisplay(test.head())","47d08e80":"train.info()","ea72bc61":"train.describe(include=['O'])","8304af49":"cats = [c for c in train.columns if train[c].dtypes =='object']\nprint('Categories', cats)\n\nnums = [c for c in train.columns if c not in cats]\nprint('Numerics', nums)","b4a5c09a":"for c in cats:\n    le=LabelEncoder()\n    le.fit(list(train[c].astype('str')) + list(test[c].astype('str')))\n    train[c] = le.transform(list(train[c].astype(str))) \n    test[c] = le.transform(list(test[c].astype(str))) \ntrain.head()","451967f8":"del train['id']\ndel test['id']\n\ntarget = train.pop('Response')\n\ntrain.shape, test.shape","8b4e517a":"plt.figure(figsize=(15, 12))\nsns.heatmap(pd.concat([train, target], axis=1).corr(),annot=True , cmap='vlag') ","026bfb62":"ax = sns.countplot(x = target ,palette=\"Set2\")\nsns.set(font_scale=1.5)\nax.set_xlabel(' ')\nax.set_ylabel(' ')\nfig = plt.gcf()\nfig.set_size_inches(10,5)\nax.set_ylim(top=700000)\nfor p in ax.patches:\n    ax.annotate('{:.2f}%'.format(100*p.get_height()\/len(target)), (p.get_x()+ 0.3, p.get_height()+10000))\n\nplt.title('Distribution of Target')\n\nplt.ylabel('Frequency [%]')\nplt.show()","31123e6f":"score_auc = []\nscore_recall = []\noof_rf = np.zeros(len(train))\npred_rf = np.zeros(len(test))\n\nfolds = StratifiedKFold(n_splits=3, shuffle=True, random_state=42)\n\nfor fold_ , (train_ind, val_ind) in enumerate(folds.split(train, target)):\n    print('fold:', fold_, '  - Starting ...')\n    trn_data, val_data = train.iloc[train_ind], train.iloc[val_ind]\n    y_train, y_val = target.iloc[train_ind], target.iloc[val_ind]\n    \n    rf = RandomForestClassifier(n_estimators=150, max_depth=5, criterion='gini', max_features=0.8, n_jobs= -1, random_state=32)\n    rf.fit(trn_data, y_train)\n    oof_rf[val_ind] = rf.predict_proba(val_data)[:, 1]\n    y = rf.predict_proba(trn_data)[:, 1]\n    print('val auc:' , roc_auc_score(y_val, oof_rf[val_ind]))\n    print('val recall:' , recall_score(y_val, np.where(oof_rf[val_ind] > 0.5, 1, 0)))\n   \n    score_auc.append(roc_auc_score(y_val, oof_rf[val_ind]))\n    score_recall.append(recall_score(y_val, np.where(oof_rf[val_ind] > 0.5, 1, 0)))\n                        \n    pred_rf += rf.predict_proba(test)[:, 1]\/folds.n_splits\n    \nprint(' Model auc: -------> ', np.mean(score_auc))\nprint(' Model recall: -------> ', np.mean(score_recall))","890d9a61":"oof_rf_01 = np.where(oof_rf > 0.5, 1, 0)\n\n\n\n\ncf_matrix = confusion_matrix(target, (oof_rf_01)) \ngroup_names = ['True Neg','False Pos','False Neg','True Pos']\ngroup_counts = [\"{0:0.0f}\".format(value) for value in\n                cf_matrix.flatten()]\ngroup_percentages = [\"{0:.2%}\".format(value) for value in\n                     cf_matrix.flatten()\/np.sum(cf_matrix)]\nlabels = [f\"{v1}\\n{v2}\\n{v3}\" for v1, v2, v3 in\n          zip(group_names,group_counts,group_percentages)]\nlabels = np.asarray(labels).reshape(2,2)\nplt.figure(figsize=(8, 6))\nsns.set(font_scale=1.4)\nplt.style.use('seaborn-poster')\nsns.heatmap(cf_matrix, annot=labels, fmt='', cmap='vlag_r')","3cd2f53e":"\n\npred = np.where(pred_rf>0.50, 1, 0)\npred\n\nrecall_score(answers, pred)","46505f2e":"smote= SMOTE(sampling_strategy='minority', random_state=2020, k_neighbors=5) # used default imblearn parameters\n\ntrain_resampled, target_resampled = smote.fit_resample(train, target)\ntrain_resampled.shape, target_resampled.shape, test.shape","962bf1b4":"type(train_resampled)","5956853d":"ax = sns.countplot(x = target_resampled ,palette=\"vlag\")\nsns.set(font_scale=1.5)\nax.set_xlabel(' ')\nax.set_ylabel(' ')\nfig = plt.gcf()\nfig.set_size_inches(10,5)\nax.set_ylim(top=700000)\nfor p in ax.patches:\n    ax.annotate('{:.2f}%'.format(100*p.get_height()\/len(target_resampled)), (p.get_x()+ 0.3, p.get_height()+10000))\n\nplt.title('Distribution of Target')\n\nplt.ylabel('Frequency [%]')\nplt.show()","1b379f7c":"score_auc = []\nscore_recall = []\n\noof_rf = np.zeros(len(train_resampled))\npred_rf = np.zeros(len(test))\n\nfolds = KFold(n_splits=3, shuffle=True, random_state=42)\n\nfor fold_ , (train_ind, val_ind) in enumerate(folds.split(train_resampled, target_resampled)):\n    print('fold:', fold_, '  - Starting ...')\n    trn_data, val_data = train_resampled.iloc[train_ind], train_resampled.iloc[val_ind]\n    y_train, y_val = target_resampled.iloc[train_ind], target_resampled.iloc[val_ind]\n    \n    rf = RandomForestClassifier(n_estimators=150, max_depth=5, criterion='gini', max_features=0.8, min_samples_split=5, n_jobs= -1, random_state=32)\n    rf.fit(trn_data, y_train)\n    oof_rf[val_ind] = rf.predict_proba(val_data)[:, 1]\n    y = rf.predict_proba(trn_data)[:, 1]\n    #print('train:',roc_auc_score(y_train, y),'val :' , roc_auc_score(y_val, oof_rf[val_ind]))\n    \n    print('val auc:' , roc_auc_score(y_val, oof_rf[val_ind]))\n    print('val recall:' , recall_score(y_val, np.where(oof_rf[val_ind] > 0.5, 1, 0)))\n    \n    \n    \n    score_auc.append(roc_auc_score(y_val, oof_rf[val_ind]))\n    score_recall.append(recall_score(y_val, np.where(oof_rf[val_ind] > 0.5, 1, 0)))\n    pred_rf += rf.predict_proba(test)[:, 1]\/folds.n_splits\n    \nprint(' Model auc: -------> ', np.mean(score_auc))\nprint(' Model recall: -------> ', np.mean(score_recall))","b6170dbe":"oof_rf_01 = np.where(oof_rf > 0.5, 1, 0)\ncf_matrix = confusion_matrix(target_resampled, (oof_rf_01)) \ngroup_names = ['True Neg','False Pos','False Neg','True Pos']\ngroup_counts = [\"{0:0.0f}\".format(value) for value in\n                cf_matrix.flatten()]\ngroup_percentages = [\"{0:.2%}\".format(value) for value in\n                     cf_matrix.flatten()\/np.sum(cf_matrix)]\nlabels = [f\"{v1}\\n{v2}\\n{v3}\" for v1, v2, v3 in\n          zip(group_names,group_counts,group_percentages)]\nlabels = np.asarray(labels).reshape(2,2)\nplt.figure(figsize=(8, 6))\nsns.set(font_scale=1.4)\nplt.style.use('seaborn-poster')\nsns.heatmap(cf_matrix, annot=labels, fmt='', cmap='vlag_r')","892e594e":"\n\npred = np.where(pred_rf>0.50, 1, 0)\n\nrecall_score(answers, pred)","d831f3c6":"smote= SMOTE(sampling_strategy='minority', k_neighbors=5) # used default imblearn parameters\n\n\ntml = TomekLinks()","b08f24e8":"score_auc = []\nscore_recall = []\n\n\noof_rf = np.zeros(len(train))\npred_rf = np.zeros(len(test))\n\nfolds = KFold(n_splits=3, shuffle=True, random_state=42)\n\nfor fold_ , (train_ind, val_ind) in enumerate(folds.split(train, target)):\n    print('fold:', fold_, '  - Starting ...')\n    trn_data, val_data = train.iloc[train_ind], train.iloc[val_ind]\n    y_train, y_val = target.iloc[train_ind], target.iloc[val_ind]\n    \n    train_upsample, y_upsample = smote.fit_resample(trn_data, y_train)\n    rf = RandomForestClassifier(n_estimators=150, max_depth=5, criterion='gini', max_features=0.8, min_samples_split=5, n_jobs= -1, random_state=32)\n    rf.fit(train_upsample, y_upsample)\n    \n    oof_rf[val_ind] = rf.predict_proba(val_data)[:, 1]\n    \n    y = rf.predict_proba(train_upsample)[:, 1]\n    \n    print('val auc:' , roc_auc_score(y_val, oof_rf[val_ind]))\n    print('val recall:' , recall_score(y_val, np.where(oof_rf[val_ind] > 0.5, 1, 0)))\n    \n    score_auc.append(roc_auc_score(y_val, oof_rf[val_ind]))\n    score_recall.append(recall_score(y_val, np.where(oof_rf[val_ind] > 0.5, 1, 0)))\n            \n    \n    pred_rf += rf.predict_proba(test)[:, 1]\/folds.n_splits\n    \nprint(' Model auc: -------> ', np.mean(score_auc))\nprint(' Model recall: -------> ', np.mean(score_recall))\n","503843f2":"\noof_rf_01 = np.where(oof_rf > 0.5, 1, 0)\n\ncf_matrix = confusion_matrix(target, (oof_rf_01)) \ngroup_names = ['True Neg','False Pos','False Neg','True Pos']\ngroup_counts = [\"{0:0.0f}\".format(value) for value in\n                cf_matrix.flatten()]\ngroup_percentages = [\"{0:.2%}\".format(value) for value in\n                     cf_matrix.flatten()\/np.sum(cf_matrix)]\nlabels = [f\"{v1}\\n{v2}\\n{v3}\" for v1, v2, v3 in\n          zip(group_names,group_counts,group_percentages)]\nlabels = np.asarray(labels).reshape(2,2)\nplt.figure(figsize=(8, 6))\nsns.set(font_scale=1.4)\nplt.style.use('seaborn-poster')\nsns.heatmap(cf_matrix, annot=labels, fmt='', cmap='vlag_r')","b76a3510":"pred_rf","c8e53cca":"pred = np.where(pred_rf>0.50, 1, 0)\nrecall_score(answers, pred)","4a7d6d5c":"#### SMOTE","dc685532":"To see why it happened, Let's say every data point from the minority class is copied 6 times before making the splits. If we did a 3-fold validation, each fold has (on average) 2 copies of each point! If our classifier overfits by memorizing its training set, it should be able to get a perfect score on the validation set! Our cross-validation will choose the model that overfits the most. We see that CV chose the deepest trees it could!\n\nInstead, we should split into training and validation folds. Then, on each fold:\n\n>1.Oversample the minority class\n>\n>2.Train the classifier on the training folds\n>\n>3.Validate the classifier on the remaining fold\n\n\n","ed26b31c":"You can find an overview of most popular methods and advantage and disadvantage here:\n\n[Imbalanced Data : How to handle Imbalanced Classification Problems](https:\/\/www.analyticsvidhya.com\/blog\/2017\/03\/imbalanced-data-classification\/)","85486690":"**Conclusion**\n\n1. Considering appropriate metric is a key and also depends on your business use case and its goal if we want more TPs so auc wont be a good chice.\n2. Resampling is one of the techniques to handle imbalanced problem if we apply resampling the right way. some time othe techniques such as class weight or applying better algoritms or ensemble modeling could help more. \n3. We just focused on modeling,  feature engineering and selection in many cases could boost the performance regarding recall and confusion  matrix.","52341e15":"So as we can boost auc with different techniques but the result of Confusion Matrix is terrible (TP=0.0%) , so we will continue with resampling. ","7245a0ff":"### **Upsampling the wrong way !**","a6d1a9bb":"#### *So our model is not generalized: cv recall = 0.94535924158125 , test recall= 0.9087221095334685*","75ea2c10":"### Loading the data","cb7ff438":"### Categories","415af97a":"![](https:\/\/miro.medium.com\/max\/725\/0*FeIp1t4uEcW5LmSM.png)","77d430ec":"CV recall = 0.9057 , test recall = 0.9088\n\nSo not only  we have very fit model(cv and test recall are very consistent) but also we have better confusion matrix and recall in comparision with first model, and model upsampling the wrong way is completely overfit.","105bee9a":"### Base Model : Original Data","370e2b07":"In this algorithm, we end up removing the majority element from the Tomek link, which provides a better decision boundary for a classifier.\n\n![](https:\/\/miro.medium.com\/max\/798\/0*YWVxE7SbWKnTnbZi)","b0659100":"In SMOTE (Synthetic Minority Oversampling Technique) we synthesize elements for the minority class, in the vicinity of already existing elements.\nAt a high level, SMOTE creates synthetic observations of the minority class [0] by:\n\n- Finding the k-nearest-neighbors for minority class observations (finding similar observations)\n- Randomly choosing one of the k-nearest-neighbors and using it to create a similar, but randomly tweaked, new observation.\n\n![](https:\/\/miro.medium.com\/max\/734\/0*_XpwY9GznmejI4WN.png)","5a917666":"This notebook is about how to do cross-validation once you have decided that oversampling is the right approach for imbalance problem.So  in this notebook i have focused on modeling , You can't fin feat eng , feat selection , hyper parameter optimization and so on.  If you want to play with the process yourself;you can complete the pipeline applying better algorithm(s) and feat eng as well. \n\nwe will be going through the following steps:\n\n- Getting a base model with random forest \n- Oversampling the wrong way: Do oversample, then oof cross-validate. Sounds fine, but results are overly optimistic.\n- Oversampling the right way: Make SMOTE a part of our oof cross validation and compare recall and confusion matrix\n\nalso i used answer.npy , the target values of test data to evaluate unseen data for models.\n\nOur goal will be to find a classifier with a good recall (i.e. we want our classifier to find as many positive cases as it can). So i didn't apply method to boost roc-auc for example. ","71b7acb5":"Lets look how Random Forest models insurance imalanced data. As performance metrics I will use recall and ConfusionMatrix. \n\n*Note: The goal of your modeling in practical projects could be specified by the business. here our goal is better TP* \n","34b6ce0e":"#### Tomek Links","5f162fc0":"\n\n\n>*If cross-validation is done on already upsampled data, the scores don't generalize to new data. In a real problem, you should only use the test set ONCE; we are reusing it to show that if we do cross-validation on already upsampled data, the results are overly optimistic and do not generalize to new data (or the test set).*","bc7a3805":"you can find several resources and kaggle notebooks for understanding resampling methods  and fundamentals, but the summary is that:\n    \n>*The main motivation behind the need to preprocess imbalanced data before we feed them into a classifier is that typically classifiers are more sensitive to detecting the majority class and less sensitive to the minority class.* *Thus, if we don't take care of the issue, the classification output will be biased, in many cases resulting in always predicting the majority class. Many methods have been proposed in the past few years to deal with imbalanced data.*\n\n","5f48fdba":"### **Upsampling the Right way !**","9362814e":"### Introduction","0a2f67e5":"### Resampling Methods"}}