{"cell_type":{"ced63b6e":"code","8b35e6ef":"code","df321820":"code","4594ba49":"code","4e62d870":"code","3c4045ff":"code","69e0e754":"code","067892e3":"code","792693ee":"code","f5e39583":"code","9cbf6587":"code","6e657d84":"code","7b856ea1":"code","f986518c":"code","9a83665f":"code","6cfe3216":"code","26457a2d":"markdown"},"source":{"ced63b6e":"# i am importing numpy and pands for working with data\nimport numpy as np\nimport pandas as pd\n\n# for visualisation\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.express as px\n\n# for preprocessing\nfrom pathlib import Path\nfrom sklearn.model_selection import train_test_split\n\n# i'll get my model up and running with tensorflow\nimport tensorflow as tf\n\n# evaluating the performance using sklearn\nfrom sklearn.metrics import confusion_matrix, classification_report","8b35e6ef":"# using flow from data frame\npositive_dir = Path('..\/input\/surface-crack-detection\/Positive')\nnegative_dir = Path('..\/input\/surface-crack-detection\/Negative')","df321820":"# creating the data frame\ndef generate_df(image_dir, label):\n    filepaths = pd.Series(list(image_dir.glob(r'*.jpg')), name='Filepath').astype(str)\n    labels = pd.Series(label, name='Label', index=filepaths.index)\n    df = pd.concat([filepaths, labels], axis=1)\n    return df","4594ba49":"positive_df = generate_df(positive_dir, label=\"POSITIVE\")\nnegative_df = generate_df(negative_dir, label=\"NEGATIVE\")\n\nall_df = pd.concat([positive_df, negative_df], axis=0).sample(frac=1.0, random_state=1).reset_index(drop=True)\nprint(all_df)","4e62d870":"# doing the train test split from sklearn\ntrain_df, test_df = train_test_split(\n    all_df.sample(6000, random_state=1),\n    train_size=0.7,\n    shuffle=True,\n    random_state=1\n)","3c4045ff":"train_df","69e0e754":"test_df","067892e3":"# loading the image data\ntrain_gen = tf.keras.preprocessing.image.ImageDataGenerator(\n    # rescaling it because I want to make sure that the actual image data is comming between values 0 and 1\n    rescale=1.\/255,\n    validation_split=0.2\n)\n\ntest_gen = tf.keras.preprocessing.image.ImageDataGenerator(\n    rescale=1.\/255\n)","792693ee":"# flowing data from the data frames\ntrain_data = train_gen.flow_from_dataframe(\n    train_df,\n    # specifying which column is used as a filepath and which column is used as labels\n    x_col='Filepath',\n    y_col='Label',\n    target_size=(120, 120),\n    color_mode='rgb',\n    class_mode='binary',\n    batch_size=32,\n    shuffle=True,\n    seed=42,\n    subset='training'\n)\n\nval_data = train_gen.flow_from_dataframe(\n    train_df,\n    x_col='Filepath',\n    y_col='Label',\n    target_size=(120, 120),\n    color_mode='rgb',\n    class_mode='binary',\n    batch_size=32,\n    shuffle=True,\n    seed=42,\n    subset='validation'\n)\n\ntest_data = train_gen.flow_from_dataframe(\n    test_df,\n    x_col='Filepath',\n    y_col='Label',\n    target_size=(120, 120),\n    color_mode='rgb',\n    class_mode='binary',\n    batch_size=32,\n    shuffle=False,\n    seed=42\n)","f5e39583":"# training part\ninputs = tf.keras.Input(shape=(120, 120, 3))\nx = tf.keras.layers.Conv2D(filters=16, kernel_size=(3, 3), activation='relu')(inputs)\nx = tf.keras.layers.MaxPool2D(pool_size=(2, 2))(x)\nx = tf.keras.layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu')(x)\nx = tf.keras.layers.MaxPool2D(pool_size=(2, 2))(x)\nx = tf.keras.layers.GlobalAveragePooling2D()(x)\noutputs = tf.keras.layers.Dense(1, activation='sigmoid')(x)\n\nmodel = tf.keras.Model(inputs=inputs, outputs=outputs)\n\nmodel.compile(\n    optimizer='adam',\n    loss='binary_crossentropy',\n    metrics=['accuracy']\n)\n\nprint(model.summary())","9cbf6587":"# fitting model on the train data\nhistory = model.fit(\n    train_data,\n    validation_data=val_data,\n    epochs=100,\n    callbacks=[\n        tf.keras.callbacks.EarlyStopping(\n            monitor='val_loss',\n            patience=3,\n            # restoring weights from best epochs\n            restore_best_weights=True\n        )\n    ]\n)","6e657d84":"# using plotly to get graph of training loss over time\n# creating plotly figure\nfig = px.line(\n    history.history,\n    y=['loss', 'val_loss'],\n    labels={'index': \"Epoch\", 'value': \"Loss\"},\n    title=\"Training and Validation Loss Over Time\"\n)\n\nfig.show()","7b856ea1":"(model.predict(test_data) >= 0.5).astype(np.int)","f986518c":"test_data.labels","9a83665f":"# getting the results\ndef evaluate_model(model, test_data):\n    \n    results = model.evaluate(test_data, verbose=0)\n    loss = results[0]\n    acc = results[1]\n    \n    print(\"    Test Loss: {:.5f}\".format(loss))\n    print(\"Test Accuracy: {:.2f}%\".format(acc * 100))\n    \n    y_pred = np.squeeze((model.predict(test_data) >= 0.5).astype(np.int))\n    cm = confusion_matrix(test_data.labels, y_pred)\n    clr = classification_report(test_data.labels, y_pred, target_names=[\"NEGATIVE\", \"POSITIVE\"])\n    \n    plt.figure(figsize=(6, 6))\n    sns.heatmap(cm, annot=True, fmt='g', vmin=0, cmap='Blues', cbar=False)\n    plt.xticks(ticks=np.arange(2) + 0.5, labels=[\"NEGATIVE\", \"POSITIVE\"])\n    plt.yticks(ticks=np.arange(2) + 0.5, labels=[\"NEGATIVE\", \"POSITIVE\"])\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"Actual\")\n    plt.title(\"Confusion Matrix\")\n    plt.show()\n    \n    print(\"Classification Report:\\n--------------------------------------------------------------\\n\", clr)","6cfe3216":"evaluate_model(model, test_data)","26457a2d":"**Predicting Results**"}}