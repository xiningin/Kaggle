{"cell_type":{"5aca4c63":"code","30165175":"code","3fa5c0e1":"code","756f3ecb":"code","a5c7c0ae":"code","cdb5c2be":"code","cc592bb8":"code","fdf830b7":"code","aed879ef":"code","08d936d9":"code","b0ceb491":"code","608752f1":"code","dd401374":"markdown","1c6c798f":"markdown","2fcecfcf":"markdown","cb7bc30c":"markdown","e53f910a":"markdown","92b392a2":"markdown","d3a537c0":"markdown"},"source":{"5aca4c63":"!pip install tensorflow_datasets\n!pip install tensorflow==2.0.0rc1\n","30165175":"import numpy as np\nimport tensorflow as tf\nimport tensorflow_datasets as tfds\nprint(tf.__version__)","3fa5c0e1":"mnist_dataset,mnist_info = tfds.load(name='mnist',as_supervised=True,with_info=True)\n\nmnist_train,mnist_test = mnist_dataset['train'],mnist_dataset['test']\n\nnumber_val_samples = 0.1 * mnist_info.splits['train'].num_examples\nnumber_val_samples = tf.cast(number_val_samples, tf.int64)\n\nnumber_test_samples = mnist_info.splits['test'].num_examples\nnumber_test_samples = tf.cast(number_test_samples, tf.int64)","756f3ecb":"def scale(image,label):\n    image = tf.cast(image, tf.float32)\n    image \/= 255.\n    return image,label\n\nscaled_train_val_data = mnist_train.map(scale)\nscaled_test_data = mnist_test.map(scale)\n","a5c7c0ae":"# size =1 means not shuffling at all, number of objects to be put in buffer at each iter\n\nbuffer_size=10000\n\nshuffled_scaled_train_val_data = scaled_train_val_data.shuffle(buffer_size)","cdb5c2be":"validation_data = shuffled_scaled_train_val_data.take(number_val_samples)\ntrain_data = shuffled_scaled_train_val_data.skip(number_val_samples)","cc592bb8":"#samples to take in each batch\n\nbatch_size = 100\n\ntrain_data = train_data.batch(batch_size)\nvalidation_data = validation_data.batch(number_val_samples)\ntest_data= scaled_test_data.batch(number_test_samples)\n\nvalidation_inputs, validation_targets = next(iter(validation_data))","fdf830b7":"input_size = 784\noutput_size = 10\nhidden_layer_size = 100\n\n\nmodel = tf.keras.Sequential ([\n    \n    # the first layer (the input layer)\n    # each observation is 28x28x1 pixels, therefore it is a tensor of rank 3\n    # since we don't know CNNs yet, we don't know how to feed such input into our net, so we must flatten the images\n    # there is a convenient method 'Flatten' that simply takes our 28x28x1 tensor and orders it into a (None,) \n    # or (28x28x1,) = (784,) vector\n    # this allows us to actually create a feed forward neural network\n    \n    tf.keras.layers.Flatten(input_shape=(28,28,1)),\n    \n    # tf.keras.layers.Dense is basically implementing: output = activation(dot(input, weight) + bias)\n    # it takes several arguments, but the most important ones for us are the hidden_layer_size and the activation function\n    tf.keras.layers.Dense(hidden_layer_size, activation='relu'),\n    tf.keras.layers.Dense(hidden_layer_size, activation='relu'),\n    tf.keras.layers.Dense(hidden_layer_size, activation='relu'),\n    tf.keras.layers.Dense(hidden_layer_size, activation='relu'),\n    tf.keras.layers.Dense(hidden_layer_size, activation='relu'),\n    \n    # the final layer is no different, we just make sure to activate it with softmax\n    tf.keras.layers.Dense(output_size, activation='softmax')\n])\n\n#model","aed879ef":"model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics = ['accuracy'])","08d936d9":"num_of_epochs = 5\ntensorboard_callback = tf.keras.callbacks.TensorBoard(\"logs\")\nmodel.fit(train_data, epochs=num_of_epochs, validation_data=(validation_inputs, validation_targets), verbose =2, validation_steps=1)","b0ceb491":"import matplotlib.pyplot as plt\n#x = test_data.next_batch(1)\n\n\n#  plt.imshow(image.numpy()[:, :, 0].astype(np.float32), cmap=plt.get_cmap(\"gray\"))\n#  print(\"Label: %d\" % label.numpy())\n\nx = mnist_test.take(10).__iter__()\n\n#np.array(x,dtype='float')\n#next(x)\n\n#z = np.array(next(x))\n\n#z.shape\n\n#plt.gray()\n#plt.imshow(z)\n\n#tf.reshape(z, [28, 28])","608752f1":"%load_ext tensorboard\n%tensorboard --logdir logs","dd401374":"## Training","1c6c798f":"## Optimizor and loss","2fcecfcf":"## Shuffling data","cb7bc30c":"## Preparing sets","e53f910a":"## Outline","92b392a2":"# Model\n","d3a537c0":"## Scaling images"}}