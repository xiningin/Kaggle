{"cell_type":{"869ab61c":"code","80084d67":"code","b5979546":"code","d80b1d40":"code","ced42619":"code","d98f3053":"code","1175a42e":"code","072fdd6f":"code","5b001469":"code","c9ea5d33":"markdown","2579b5d7":"markdown","2e453c7d":"markdown","aed74b4d":"markdown"},"source":{"869ab61c":"! pip install MTCNN","80084d67":"import tensorflow\nfrom mtcnn import MTCNN\nimport cv2\nimport os\nimport numpy as np\nfrom tqdm import tqdm\nimport shutil\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import imshow","b5979546":"def align(img):\n    # This function takes in an image, detects the bounding boxes for the face or faces\n    # in the image and then selects the face with the largest number of pixels.\n    # for the largest face the eye centers are detected and the angle of the eyes with respect to\n    # the horizontal axis is determined. It then provides this angle to the rotate_bound function\n    # the rotate_bound function the rotates the image so the eyes are parallel to the horizontal axis\n        \n    data=detector.detect_faces(img)\n    # In case the image has more than 1 face, find the biggest face\n    biggest=0\n    if data !=[]:\n        for faces in data:\n            box=faces['box']            \n            # calculate the area in the image\n            area = box[3]  * box[2]\n            if area>biggest:\n                biggest=area\n                bbox=box                \n                keypoints=faces['keypoints']\n                left_eye=keypoints['left_eye']\n                right_eye=keypoints['right_eye']                 \n        lx,ly=left_eye        \n        rx,ry=right_eye\n        dx=rx-lx\n        dy=ry-ly\n        tan=dy\/dx\n        theta=np.arctan(tan)\n        theta=np.degrees(theta)    \n        img=rotate_bound(img, theta)        \n        return (True,img)\n    else:\n        return (False, None)\n ","d80b1d40":"def crop_image(img): \n    data=detector.detect_faces(img)\n    #y=box[1] h=box[3] x=box[0] w=box[2]   \n    biggest=0\n    if data !=[]:\n        for faces in data:\n            box=faces['box']            \n            # calculate the area in the image\n            area = box[3]  * box[2]\n            if area>biggest:\n                biggest=area\n                bbox=box \n        bbox[0]= 0 if bbox[0]<0 else bbox[0]\n        bbox[1]= 0 if bbox[1]<0 else bbox[1]\n        img=img[bbox[1]: bbox[1]+bbox[3],bbox[0]: bbox[0]+ bbox[2]]        \n        return (True, img) \n    else:\n        return (False, None)\n    \ndef rotate_bound(image, angle):\n    #rotates an image by the degree angle\n    # grab the dimensions of the image and then determine the center\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w \/\/ 2, h \/\/ 2)\n    # grab the rotation matrix (applying the angle to rotate clockwise), then grab the sine and cosine\n    # (i.e., the rotation components of the matrix)\n    M = cv2.getRotationMatrix2D((cX, cY), angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1]) \n    # compute the new bounding dimensions of the image\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin)) \n    # adjust the rotation matrix to take into account translation\n    M[0, 2] += (nW \/ 2) - cX\n    M[1, 2] += (nH \/ 2) - cY \n    # perform the actual rotation and return the image\n    return cv2.warpAffine(image, M, (nW, nH)) ","ced42619":"def align_crop_resize(sdir,dest_dir, height=None, width= None): \n    aligned_dir=os.path.join(dest_dir, 'Aligned Images')\n    cropped_dir=os.path.join(dest_dir, 'Cropped_Images')\n    if os.path.isdir(dest_dir):\n        shutil.rmtree(dest_dir)\n    os.mkdir(dest_dir)  #start with an empty destination directory\n    os.mkdir(aligned_dir)\n    os.mkdir(cropped_dir)\n    flist=os.listdir(sdir) #get a list of the image files    \n    success_count=0\n    for i,f in enumerate(flist): # iterate through the image files\n        fpath=os.path.join(sdir,f)        \n        if os.path.isfile(fpath) and i <10:\n            try:\n                img=cv2.imread(fpath) # read in the image\n                shape=img.shape\n                status,img=align(img) # rotates the image for the eyes are horizontal\n                if status:\n                    aligned_path=os.path.join(aligned_dir,f)\n                    cv2.imwrite(aligned_path, img)                    \n                    cstatus, img=crop_image(img) # crops the aligned image to return the largest face\n                    if cstatus:\n                        if height != None and width !=None:\n                            img=cv2.resize(img, (height, width)) # if height annd width are specified resize the image\n                        cropped_path=os.path.join(cropped_dir, f)\n                        cv2.imwrite(cropped_path, img) # save the image\n                        success_count +=1 # update the coount of successful processed images\n                \n            except:\n                print('file ', fpath, ' is a bad image file')\n    return success_count\n   ","d98f3053":"detector = MTCNN()\nsdir=r'..\/input\/ffhq-flickr-faces-align-crop-and-segment'\nworking_dir=r'.\/'\ndest_dir=os.path.join(working_dir, 'results')\nheight=128\nwidth=128\ncount=align_crop_resize(sdir,dest_dir)\nprint ('Number of sucessfully processed images= ', count)","1175a42e":"def show_images(tdir):\n    filelist=os.listdir(tdir)\n    length=len(filelist)\n    columns=5\n    rows=int(np.ceil(length\/columns))    \n    plt.figure(figsize=(20, rows * 4))\n    for i, f in enumerate(filelist):    \n        fpath=os.path.join(tdir, f)\n        imgpath=os.path.join(tdir,f)\n        img=plt.imread(imgpath)\n        plt.subplot(rows, columns, i+1)\n        plt.axis('off')\n        plt.title(f, color='blue', fontsize=12)\n        plt.imshow(img)","072fdd6f":"show_dir=os.path.join(dest_dir, 'Cropped_Images')\nshow_images(show_dir)","5b001469":"show_dir=os.path.join(dest_dir, 'Aligned Images')\nshow_images(show_dir)","c9ea5d33":"show the cropped images","2579b5d7":"show the aligned images before being cropped","2e453c7d":"define a function to show images","aed74b4d":"The code below will input the image.  Then it detects the face or faces in the image.\nIt then selects the largest face (most pixels in it) and detects the centers of the\nleft and right eye. It then determines the angle of the line joining the eye centers.\nThis angle is then feed into a function that rotates the image so the line is paralllel\nto the x axis. Then the rotatedimage is cropped to return the largest face and the image\nis stored in the working\/dir\/car.\nMTCNN is the most acurate face cropper I have found but unfortunately it is very slow.\nConsequently I only tried to crop and align 10 images. I did not bother with the sementation\ntask.\n"}}