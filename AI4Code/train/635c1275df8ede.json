{"cell_type":{"f4a73554":"code","36895d15":"code","4091a8d0":"code","2dc148eb":"code","7d539014":"code","afdf7d4b":"markdown","3870f468":"markdown"},"source":{"f4a73554":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","36895d15":"import sqlite3\nDB = sqlite3.connect('\/kaggle\/input\/mitosis-wsi-ccmct-training-set\/MITOS_WSI_CCMCT_ODAEL_train_dcm.sqlite')\ncur = DB.cursor()","4091a8d0":"import numpy as np\nfrom pydicom.encaps import decode_data_sequence\nfrom PIL import Image\nimport io\nimport pydicom\n\nclass ReadableDicomDataset():\n    def __init__(self, filename):\n        self._ds = pydicom.dcmread(filename)\n        self.geometry_imsize = (self._ds[0x48,0x6].value,self._ds[0x48,0x7].value)\n        self.geometry_tilesize = (self._ds.Columns, self._ds.Rows)\n        self.geometry_columns = round(0.5+(self.geometry_imsize[0]\/self.geometry_tilesize[0]))\n        self.geometry_rows = round(0.5 + (self.geometry_imsize[1] \/ self.geometry_tilesize[1] ))\n        self._dsequence = decode_data_sequence(self._ds.PixelData)\n\n\n    def imagePos_to_id(self, imagePos:tuple):\n        id_x, id_y = imagePos\n        return (id_x+(id_y*self.geometry_columns))\n    \n    def get_tile(self, pos):\n        return np.array(Image.open(io.BytesIO(self._dsequence[pos])))\n        \n\n    def get_id(self, pixelX:int, pixelY:int) -> (int, int, int):\n\n        id_x = round(-0.5+(pixelX\/self.geometry_tilesize[1]))\n        id_y = round(-0.5+(pixelY\/self.geometry_tilesize[0]))\n\n        return (id_x,id_y), pixelX-(id_x*self.geometry_tilesize[0]), pixelY-(id_y*self.geometry_tilesize[1]),\n\n    @property\n    def dimensions(self):\n        return self.geometry_imsize\n        \n    def read_region(self, location: tuple, size:tuple):\n        lu, lu_xo, lu_yo = self.get_id(*list(location))\n        rl, rl_xo, rl_yo = self.get_id(*[sum(x) for x in zip(location,size)])\n        # generate big image\n        bigimg = np.zeros(((rl[1]-lu[1]+1)*self.geometry_tilesize[0], (rl[0]-lu[0]+1)*self.geometry_tilesize[1], self._ds[0x0028, 0x0002].value), np.uint8)\n        for xi, xgridc in enumerate(range(lu[0],rl[0]+1)):\n            for yi, ygridc in enumerate(range(lu[1],rl[1]+1)):\n                if (xgridc<0) or (ygridc<0):\n                    continue\n                bigimg[yi*self.geometry_tilesize[0]:(yi+1)*self.geometry_tilesize[0],\n                       xi*self.geometry_tilesize[1]:(xi+1)*self.geometry_tilesize[1]] = \\\n                       self.get_tile(self.imagePos_to_id((xgridc,ygridc)))\n        # crop big image\n        return bigimg[lu_yo:lu_yo+size[1],lu_xo:lu_xo+size[0]]\n\n    ","2dc148eb":"ds = ReadableDicomDataset('\/kaggle\/input\/mitosis-wsi-ccmct-training-set\/fff27b79894fe0157b08.dcm')\nlocation=(69700,17100)\nsize=(500,500)\nimg = Image.fromarray(ds.read_region(location=location,size=size))\nimg","7d539014":"# Get the annotation coordinates, offset by the left upper coordinate (location)\n# NOTE: We would actually have to check the label class - which we omit for the sake of simplicity here\ncells = cur.execute(f\"\"\"SELECT coordinateX-{location[0]}, coordinateY-{location[1]}\n                        from Annotations_coordinates where slide==7 and \n                        coordinateX>{location[0]} and coordinateX<{location[0]+size[0]} and \n                        coordinateY>{location[1]} and coordinateY<{location[1]+size[1]}\"\"\").fetchall()\n\nfrom PIL import ImageDraw\ndraw = ImageDraw.Draw(img)\nfor (cx,cy) in cells:\n    r=25\n    draw.ellipse([(cx-r,cy-r),(cx+r,cy+r)],outline=(255,0,0,255))\nimg\n","afdf7d4b":"## First steps with the MITOS WSI CCMCT data set\n\nIn this short tutorial, you will see how to use the database and the DICOM images of this data set.","3870f468":"Et voila - here we have found two annotated cells, in this case mitotic figures. Note that we did not check for the class in this code."}}