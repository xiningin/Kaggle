{"cell_type":{"e147ebff":"code","f876cbfb":"code","2a1f12a3":"code","b41097b4":"code","39c1a475":"code","e84bc66a":"code","fed9d8d9":"markdown","f49ac3a2":"markdown","9fcbc661":"markdown","006fe314":"markdown","8a4e7451":"markdown","58368b99":"markdown","8c0b8f83":"markdown","b5debb8d":"markdown","f030c327":"markdown","462fee53":"markdown","c8cf7d35":"markdown","ab529ab5":"markdown","74ffa432":"markdown"},"source":{"e147ebff":"import pandas as pd\nnetflix_titles = pd.read_csv(\"..\/input\/netflix-shows\/netflix_titles.csv\")\nprint(netflix_titles.columns)\nprint(netflix_titles.head())","f876cbfb":"user_id = '1'\nuser_movietitles = ['Sierra Burgess Is A Loser', 'Narcos', 'Explained', 'The Mind of a Chef']\nstatus = ['Watched' for x in range(len(user_movietitles))]","2a1f12a3":"# Use .copy() to avoid warning related to modifying one of the dataframes used while not meaning to\ndf_user = netflix_titles.loc[netflix_titles['title'].isin(user_movietitles)].copy()\ndf_user['user_id'] = user_id\ndf_user['status'] = status\nprint(df_user[['user_id', 'title', 'status', 'description']])","b41097b4":"# Add stopwords, tokenize 'description' in both netflix_titles df and df_user df\nfrom nltk.corpus import stopwords\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\nstop_words = set(stopwords.words('english'))\ntfidf_vectorizer = TfidfVectorizer(stop_words = stop_words)\ntfidf_netflix_titles = tfidf_vectorizer.fit_transform(netflix_titles['description'].str.lower()).toarray()\ntfidf_user_df = tfidf_vectorizer.transform(df_user['description'].str.lower()).toarray()\nsimilarity = cosine_similarity(tfidf_user_df, tfidf_netflix_titles)","39c1a475":"for similarity_x in similarity:\n    similarity_x = pd.Series(list(similarity_x))\n    top_recommendations = similarity_x.nlargest(6)\n    netflix_id = top_recommendations.index.values.tolist()\n    print('*Recommended for you from:')\n    print('Title: ' + str(netflix_titles.loc[netflix_id[0], 'title']))\n    print('Desc : ' + str(netflix_titles.loc[netflix_id[0], 'description']))\n    \n    print('\\n*Top 5 recommendations:')\n    titles_only = []\n    for id in range(1, len(netflix_id)):\n        titles_only.append(str(netflix_titles.loc[netflix_id[id], 'title']))\n        print('Title: ' + str(netflix_titles.loc[netflix_id[id], 'title']))\n        print('Desc : ' + str(netflix_titles.loc[netflix_id[id], 'description']))\n        print('\\n')","e84bc66a":"genres_all = list(netflix_titles.listed_in.unique())\ngenres = []\nfor x in genres_all:\n    x1 = x.replace(' ', '').split(',')\n    genres.extend(x1)\n\ngenres = sorted(list(set(genres)))\nprint(genres)","fed9d8d9":"# Load Dataset","f49ac3a2":"# Improvement Ideas","9fcbc661":"Anyways, I personally used this recommender sometimes as a complement of Netflix's in app recommendations. Haven't used any convoluted techniques here but I found this worked well enough. Happy binge watching!!","006fe314":"# Recommendation System","8a4e7451":"# User Input","58368b99":"First, we load the dataset and explore the columns. We can see that the dataset contains `description` column, which is a short summary of the movie. We'll build up the recommendations based on contents in `description` column.","8c0b8f83":"For easier further development, I created a copy dataframe that'll store input movies from multiple users, hence the dataframe now also contains `user_id` and `status` with dummy contents. For now it'll only store the movies passed to `user_movietitles`. ","b5debb8d":"In this dataset, I tried using cosine similarity to collect movie recommendations based on the movie description provided in the dataset.","f030c327":"As seen in the result, we still see some not too similar movies recommended. As an example, Richard Pryor: Live in Concert is recommended to users watching Explained. I think adding sub genres for this movie dataset would be a helpful feature. Take the Richard Pryor: Live in Concert, we can add `Music` as the second tier for this movie's genre. Then, we can add a new scoring on whether or not the recommended movies matched the first tier genre and second tier genre. Finally, we can have weighted scores for both cosine similarity (scaled from 0 to 1) and genre similarity (scaled from 0 to 1). Simply put, `final_score = 0.5 * (cosine_similarity + genre_similarity)`. The larger final_score, the more similar the movie to the user input movie.","462fee53":"You can try passing your movie(s) of interest here. For this version I just made the input to be exact and case sensitive. Will loosen up (case insensitive, more elastic titles) in later versions. For multiple movies, you can pass the titles separated by commas. Movie titles are stored in a list named `user_movietitles`. Movie titles used for the base of the recommender are limited to those listed in the dataset.","c8cf7d35":"As we're working with text data for summaries in the `description` column, we first need to import packages like NLTK and TFIDF. Next, we remove stopwords and tokenize the sentences, with `lower()` function to not differ same tokens written in different cases. I haven't add any lemmatization to these tokens. Do this in both (i) whole Netflix dataset (here imported as `netflix_titles` dataframe) and (ii) user movies dataframe (here imported as `df_user`). Also create the similarity function, here we're using cosine similarity. The larger the cosine similarity value, the more similar the movie summaries. The object `similarity` will be in Numpy array.","ab529ab5":"Here's the list of unique genres available. See how we can improve the sub genres?","74ffa432":"Sort `similarity` and collect top 5 most similar movies as our recommendations."}}