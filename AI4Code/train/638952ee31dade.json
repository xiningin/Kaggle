{"cell_type":{"571cfe56":"code","899418f2":"code","bcf50fc2":"code","ea8d6a20":"code","825f7d9c":"code","fc981271":"code","610dde3b":"code","dbf43346":"code","0339ebfd":"code","dfda26fa":"code","42dbe2bf":"code","3adb84f8":"code","a1627ae2":"code","3939d9a7":"code","72ea4e55":"code","88cdd62a":"code","d5b81bb3":"code","457779d1":"code","71c2c65c":"code","d70655b1":"code","207db216":"code","d40223a5":"code","4a09c6a3":"code","1674d475":"code","03d7c4be":"code","e915011b":"code","bb3cf91c":"code","b8b87f53":"code","cf95be5b":"code","394f1b93":"code","a0aa27c9":"code","25754059":"code","ccde4867":"code","34dc1bac":"code","bf02a433":"code","7f7df50f":"code","f95b947b":"code","223b0269":"code","9df9cd8e":"code","19ad8dc8":"code","93c6ce7a":"code","3815460f":"code","d52da5c9":"code","b13cadf6":"code","87502ed6":"code","32fcf8e4":"code","22438bfb":"code","c82aa126":"code","0766006c":"code","2cda69b4":"code","9c93f65e":"code","2ab4999a":"code","69e6615f":"code","12b3bc4c":"markdown","567a92ca":"markdown","dc0402d6":"markdown","15839032":"markdown","8c850268":"markdown","6ebd7ceb":"markdown","b1572b52":"markdown","dfb3d84e":"markdown","cf21fcef":"markdown","1e9dd76b":"markdown","72058333":"markdown","5c854616":"markdown","919a38f0":"markdown","f643ac75":"markdown","71034572":"markdown","cea3c0f5":"markdown","92cfc6a1":"markdown","77443235":"markdown","495cb25c":"markdown","4a290916":"markdown","c3a95b93":"markdown","3d3a3c72":"markdown","5616e60a":"markdown","061f5fa3":"markdown","3e8bcf30":"markdown","dfa5a78e":"markdown"},"source":{"571cfe56":"import numpy as np\na = np.array([0, 1, 2, 3])\nprint(a)\n\nprint(type(a))\n\nprint(np.arange(10))","899418f2":"#python lists\nL = range(1000)\n%timeit [i**2 for i in L]","bcf50fc2":"a = np.arange(1000)\n%timeit a**2","ea8d6a20":"#1-D\n\na = np.array([0, 1, 2, 3])\n\na","825f7d9c":"#print dimensions\n\na.ndim","fc981271":"#shape\n\na.shape","610dde3b":"len(a)","dbf43346":"# 2-D, 3-D....\n\nb = np.array([[0, 1, 2], [3, 4, 5]])\n\nb","0339ebfd":"b.ndim","dfda26fa":"b.shape","42dbe2bf":"len(b) #returns the size of the first dimention","3adb84f8":"c = np.array([[[0, 1, 3], [2, 3, 4]], [[4, 5, 4], [6, 7, 9]], [[1, 2, 2], [2, 3, 4]]])\n\nc","a1627ae2":"c.ndim","3939d9a7":"c.shape","72ea4e55":"#using arrange function\n\n# arange is an array-valued version of the built-in Python range function\n\na = np.arange(10) # 0.... n-1\na","88cdd62a":"b = np.arange(1, 10, 2) #start, end (exclusive), step\n\nb","d5b81bb3":"#using linspace\n\na = np.linspace(0, 2, 6) #start, end, number of points\n\na","457779d1":"#common arrays\n\na = np.ones((3, 3))\n\na","71c2c65c":"b = np.zeros((3, 3))\n\nb","d70655b1":"c = np.eye(3)  #Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\nc","207db216":"d = np.eye(3, 2) #3 is number of rows, 2 is number of columns, index of diagonal start with 0\n\nd","d40223a5":"#create array using diag function\n\na = np.diag([1, 2, 3, 4]) #construct a diagonal array.\n\na","4a09c6a3":"np.diag(a)   #Extract diagonal","1674d475":"#create array using random\n\n#Create an array of the given shape and populate it with random samples from a uniform distribution over [0, 1).\na = np.random.rand(4) \n\na","03d7c4be":"a = np.random.randn(4)#Return a sample (or samples) from the \u201cstandard normal\u201d distribution.  ***Gausian***\n\na","e915011b":"a = np.arange(10)\n\na.dtype","bb3cf91c":"#You can explicitly specify which data-type you want:\n\na = np.arange(10, dtype='float64')\na","b8b87f53":"#The default data type is float for zeros and ones function\n\na = np.zeros((3, 3)) #dtype= 'int64')\n\nprint(a)\n\na.dtype","cf95be5b":"d = np.array([1+2j, 2+4j])   #Complex datatype\n\nprint(d.dtype)","394f1b93":"b = np.array([True, False, True, False])  #Boolean datatype\nprint(b)\nprint(b.dtype)","a0aa27c9":"s = np.array(['Ram', 'Robert', 'Rahim'])\n\ns.dtype","25754059":"a = np.arange(10)\n\nprint(a[1])  #indices begin at 0, like other Python sequences (and C\/C++)","ccde4867":"# For multidimensional arrays, indexes are tuples of integers:\n\na = np.diag([1, 2, 3])\n\nprint(a)\n\nprint(a[2, 2])","34dc1bac":"a[2, 1] = 5 #assigning value\n\na","bf02a433":"a = np.arange(10)\n\na","7f7df50f":"a[1:8:2] # [startindex: endindex(exclusive) : step]","f95b947b":"#we can also combine assignment and slicing:\n\na = np.arange(10)\na[5:] = 10\na","223b0269":"b = np.arange(5)\na[5:] = b[::-1]  #assigning\nprint(b)\nprint(b[::-2])\na","9df9cd8e":"a = np.arange(10)\na","19ad8dc8":"b = a[::2]\nb","93c6ce7a":"np.shares_memory(a, b)","3815460f":"b[0] = 10\nb","d52da5c9":"a  #eventhough we modified b,  it updated 'a' because both shares same memory","b13cadf6":"a = np.arange(10)\n\nc = a[::2].copy()     #force a copy\nc","87502ed6":"np.shares_memory(a, c)","32fcf8e4":"c[0] = 10\n\na","22438bfb":"a = np.random.randint(0, 20, 15)\na","c82aa126":"mask = (a % 2 == 0)","0766006c":"extract_from_a = a[mask]\n\nextract_from_a","2cda69b4":"a[mask] = -1\na","9c93f65e":"a = np.arange(0, 100, 10)\n\na","2ab4999a":"#Indexing can be done with an array of integers, where the same index is repeated several time:\n\na[[2, 3, 2, 4, 2]]","69e6615f":"# New values can be assigned \n\na[[9, 7]] = -200\n\na","12b3bc4c":"# 1. Creating arrays","567a92ca":"**For more details**\n\n**https:\/\/docs.scipy.org\/doc\/numpy-1.10.1\/user\/basics.types.html**","dc0402d6":"# 5. Fancy Indexing","15839032":"**Indexing with a mask can be very useful to assign a new value to a sub-array:**","8c850268":"**Note:**\n    \nFor random samples from N(\\mu, \\sigma^2), use:\n\nsigma * np.random.randn(...) + mu\n\n","6ebd7ceb":"** 1.1.  Manual Construction of arrays**","b1572b52":"# 2. Basic DataTypes","dfb3d84e":"# NumPy Arrays","cf21fcef":"# 3. Indexing and Slicing","1e9dd76b":"**Indexing with an array of integers**","72058333":"**3.1 Indexing**","5c854616":"# 4. Copies and Views","919a38f0":"NumPy arrays can be indexed with slices, but also with boolean or integer arrays **(masks)**. This method is called **fancy indexing**. It creates copies not views.","f643ac75":"**other datatypes**","71034572":"** 1.2  Functions for creating arrays**","cea3c0f5":"The items of an array can be accessed and assigned to the same way as other **Python sequences (e.g. lists)**:","92cfc6a1":"**3.2 Slicing**","77443235":"**python objects:** \n\n1. high-level number objects: integers, floating point\n2. containers: lists (costless insertion and append), dictionaries (fast lookup)","495cb25c":"**Numpy provides:**\n\n1. extension package to Python for multi-dimensional arrays\n2. closer to hardware (efficiency)\n3. designed for scientific computation (convenience)\n4. Also known as array oriented computing","4a290916":"**Using Boolean Mask**","c3a95b93":"# The Numpy array object","3d3a3c72":"**Each built-in data type has a character code that uniquely identifies it.**\n\n'b' \u2212 boolean\n\n'i' \u2212 (signed) integer\n\n'u' \u2212 unsigned integer\n\n'f' \u2212 floating-point\n\n'c' \u2212 complex-floating point\n\n'm' \u2212 timedelta\n\n'M' \u2212 datetime\n\n'O' \u2212 (Python) objects\n\n'S', 'a' \u2212 (byte-)string\n\n'U' \u2212 Unicode\n\n'V' \u2212 raw data (void)","5616e60a":"**When modifying the view, the original array is modified as well:**","061f5fa3":"**Why it is useful:** Memory-efficient container that provides fast numerical operations.","3e8bcf30":"You may have noticed that, in some instances, array elements are displayed with a **trailing dot (e.g. 2. vs 2)**. This is due to a difference in the **data-type** used:","dfa5a78e":"A slicing operation creates a view on the original array, which is just a way of accessing array data. Thus the original array is not copied in memory. You can use **np.may_share_memory()** to check if two arrays share the same memory block. "}}