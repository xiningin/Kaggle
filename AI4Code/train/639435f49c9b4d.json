{"cell_type":{"ec46d940":"code","cb7fda70":"code","8015088f":"code","53ba4dc0":"code","f99ce583":"code","f4e7b772":"code","7180ec2e":"markdown","89a93d66":"markdown","4ae142f5":"markdown"},"source":{"ec46d940":"params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)\ndef f1(z, *params):\n    x, y = z\n    a, b, c, d, e, f, g, h, i, j, k, l, scale = params\n    return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f)\n\ndef f2(z, *params):\n    x, y = z\n    a, b, c, d, e, f, g, h, i, j, k, l, scale = params\n    return (-g*np.exp(-((x-h)**2 + (y-i)**2) \/ scale))\n\ndef f3(z, *params):\n    x, y = z\n    a, b, c, d, e, f, g, h, i, j, k, l, scale = params\n    return (-j*np.exp(-((x-k)**2 + (y-l)**2) \/ scale))\n\ndef f(z, *params):\n    return f1(z, *params) + f2(z, *params) + f3(z, *params)","cb7fda70":"rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))","8015088f":"from scipy import optimize\nimport numpy as np","53ba4dc0":"resbrute = optimize.brute(f, rranges, args=params, full_output=True,finish=optimize.fmin)","f99ce583":"resbrute[0]  # global minimum","f4e7b772":"resbrute[1]  # function value at global minimum","7180ec2e":"Minimize a function over a given range by brute force.\n\nUses the \u201cbrute force\u201d method, i.e., computes the function\u2019s value at each point of a multidimensional grid of points, to find the global minimum of the function.","89a93d66":"Thus, the objective function may have local minima near the minimum of each of the three functions of which it is composed. To use fmin to polish its gridpoint result, we may then continue as follows:","4ae142f5":"We illustrate the use of brute to seek the global minimum of a function of two variables that is given as the sum of a positive-definite quadratic and two deep \u201cGaussian-shaped\u201d craters. Specifically, define the objective function f as the sum of three other functions, f = f1 + f2 + f3. We suppose each of these has a signature (z, *params), where z = (x, y), and params and the functions are as defined below."}}