{"cell_type":{"360cacf8":"code","4fb9bf50":"markdown","83ec57e3":"markdown","62d2c78d":"markdown","8d3fc26c":"markdown","98d35143":"markdown"},"source":{"360cacf8":"#!\/usr\/bin\/env python3\n\nimport argparse\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import List\nfrom subprocess import PIPE\n\nparser = argparse.ArgumentParser(\n    description='Compile a list of python files into a Kaggle compatable script: \\n' +\n                '.\/kaggle_compile.py [script_files.py] --save'\n)\nparser.add_argument('files', nargs='+',                                help='list of files to parse' )\nparser.add_argument('--python-path', default='.',                      help='directory to search for local namespace imports')\nparser.add_argument('--output-dir',  default='.\/',                     help='directory to write output if --save')\nparser.add_argument('--save',        action='store_true',              help='should file be saved to disk')\nparser.add_argument('--commit',      action='store_true',              help='should saved file be commited to git')\nargs, unknown = parser.parse_known_args()  # Ignore extra CLI args passed in by Kaggle\nif len(args.files) == 0:  parser.print_help(sys.stderr); sys.exit();\n\n\nmodule_names = [ name for name in os.listdir(args.python_path)\n                 if os.path.isdir(os.path.join(args.python_path, name))\n                 and not name.startswith('.') ]\nmodule_regex = '(?:' + \"|\".join(map(re.escape, module_names)) + ')'\nimport_regex = re.compile(f'^from\\s+({module_regex}.*?)\\s+import', re.MULTILINE)\n\n\ndef read_and_comment_file(filename: str) -> str:\n    code = open(filename, 'r').read()\n    code = re.sub(import_regex, r'# \\g<0>', code)\n    return code\n\n\n# TODO: handle \"import src.module\" syntax\n# TODO: handle \"from src.module.__init__.py import\" syntax\ndef extract_dependencies_from_file(filename: str) -> List[str]:\n    code    = open(filename, 'r').read()\n    imports = re.findall(import_regex, code)\n    files   = list(map(lambda string: string.replace('.', '\/')+'.py', imports))\n    return files\n\n\ndef recurse_dependencies(filelist: List[str]) -> List[str]:\n    output = filelist\n    for filename in filelist:\n        dependencies = extract_dependencies_from_file(filename)\n        if len(dependencies):\n            output = [\n                recurse_dependencies(dependencies),\n                dependencies,\n                output\n            ]\n    output = flatten(output)\n    return output\n\n\ndef flatten(filelist):\n    output = []\n    for item in filelist:\n        if isinstance(item,list):\n            if len(item):         output.extend(flatten(item))\n        else:                     output.append(item)\n    return output\n\n\ndef unique(filelist: List[str]) -> List[str]:\n    seen   = {}\n    output = []\n    for filename in filelist:\n        if not seen.get(filename, False):\n            seen[filename] = True\n            output.append(filename)\n    return output\n\n\ndef make_executable(path):\n    mode = os.stat(path).st_mode\n    mode |= (mode & 0o444) >> 2    # copy R bits to X\n    os.chmod(path, mode)\n\n\ndef savefile():\n    savefile = os.path.join( args.output_dir, os.path.basename(args.files[-1]) )  # Assume last provided filename\n    return savefile\n\n\ndef compile_script(filelist: List[str]) -> str:\n    filelist = unique(filelist)\n\n\n    shebang = \"#!\/usr\/bin\/env python3\"\n    header = [\n        (\"\\n\" + (\" \".join(sys.argv)) + \"\\n\"),\n        subprocess.run('date --rfc-3339 seconds',     shell=True, stdout=PIPE).stdout.decode(\"utf-8\"),\n        subprocess.run('git remote -v',               shell=True, stdout=PIPE).stdout.decode(\"utf-8\"),\n        subprocess.run('git branch -v ',              shell=True, stdout=PIPE).stdout.decode(\"utf-8\"),\n        subprocess.run('git rev-parse --verify HEAD', shell=True, stdout=PIPE).stdout.decode(\"utf-8\"),\n    ]\n    if args.save: header += [ f'Wrote: {savefile()}' ]\n\n    header = map(lambda string: string.split(\"\\n\"), header )\n    header = map(lambda string: '##### ' + string, flatten(header))\n    header = \"\\n\".join(flatten(header))\n\n    output_lines = [\n        shebang,\n        header,\n    ]\n    for filename in filelist:\n        output_lines += [\n            f'#####\\n##### START {filename}\\n#####',\n            read_and_comment_file(filename),\n            f'#####\\n##### END   {filename}\\n#####',\n        ]\n    output_lines += [ header ]\n    output_text   = \"\\n\\n\".join(output_lines)\n    output_text   = reorder_from_future_imports(output_text)\n    return output_text\n\ndef reorder_from_future_imports(output_text):\n    lines   = output_text.split('\\n')\n    shebangs = [ line for line in lines[:10] if line.startswith('#!\/')         ]\n    futures  = [ line for line in lines      if '__future__' in line           ]\n    other    = [ line for line in lines      if line not in shebangs + futures ]\n    output   = \"\\n\".join([ *shebangs, *sorted(set(futures)), *other ])\n    return output\n\n\n\nif __name__ == '__main__':\n    filenames = recurse_dependencies(args.files)\n    code      = compile_script(filenames)\n    print(code)\n    if args.save or args.commit:\n        with open(savefile(), 'w') as file:\n            file.write(code)\n            file.close()\n        make_executable(savefile())\n\n        if args.commit:\n            while not os.path.exists(savefile()): continue\n            command = f'git add {savefile()}; git commit -o {savefile()} -m \"kaggle_compile.py | {savefile()}\"'\n            print(f'$ {command}')\n            print( subprocess.check_output(command, shell=True).decode(\"utf-8\") )\n","4fb9bf50":"# kaggle_compile.py\n- https:\/\/github.com\/JamesMcGuigan\/kaggle-arc\/blob\/master\/submission\/kaggle_compile.py\n\nNOTE: This script must be run on localhost, and will throw an exception inside a Kaggle Notebook when it tried to run `git remote -v` outside of a localhost git repo.","83ec57e3":"# kaggle_compile.sh\n- https:\/\/github.com\/JamesMcGuigan\/kaggle-arc\/blob\/master\/submission\/kaggle_compile.sh","62d2c78d":"Please leave an upvote if you use this script","8d3fc26c":"# kaggle_compile.py: Python IDE to Kaggle Compiler\n\nOne of the big limitations of Kaggle Kernel Only competitions is that the code needs to be written in a notebook. \n\nWhilst this is fine for some usecases, there is a limit to the complexity of code that can be written outside a localhost IDE (I'm a big fan of IntelliJ) with a linter, debugger, type checker and profiler. Code reuse, reorganization, and refactoring is also greatly enhanced using multi-file codebase and git version control. This is the workflow I am familiar with as a professional programmer.\n\nMy first attempt involved manually copy and pasting required functions into a Kaggle Script Notebook, but then I decided that this process could be automated with a script.\n\nTaking inspiration from my IE6 javascript days, I wrote a python script compiler for Kaggle. It reads in a python executable script, parses the `import` headers for any local include files, then recursively builds a dependency tree and concatenates these into single python file \/ text-blob. It can be called with either `--save` or `--commit` cli flags to automatically save to disk or commit the result to git.\n  \n# Limitations\n\nthe script only works for `from local.module import function` syntax, and does not support `import local .module` syntax, as calling `module.function()` inside a script would not work with script concatenation. Also the entire python file for the dependency is included, which does not guarantee the absence of namespace conflicts, but given an awareness of good coding practices, it is sufficiently practical for generating Kaggle submissions.\n  \nThere are other more robust solutions to this problem such as [stickytape](https:\/\/github.com\/mwilliamson\/stickytape), which allow for module imports, however, the code for dependency files is obfuscated into a single line string variable, which makes for an unreadable Kaggle submission. [kaggle_compile.py](https:\/\/github.com\/JamesMcGuigan\/kaggle-arc\/blob\/master\/submission\/kaggle_compile.py) produces readable and easily editable output.\n\n\n# Example Notebooks\n- https:\/\/www.kaggle.com\/jamesmcguigan\/bengali-ai-tensorflow-imagedatagenerator-cnn\n- https:\/\/www.kaggle.com\/jamesmcguigan\/arc-oo-framework-xgboost-multimodel-solvers\n","98d35143":"```\n#!\/usr\/bin\/env bash\ncd \"$(dirname \"$(readlink -f \"${BASH_SOURCE[0]}\/..\")\")\"  # https:\/\/stackoverflow.com\/questions\/3349105\/how-to-set-current-working-directory-to-the-directory-of-the-script\/51651602#51651602\n\npython3 .\/submission\/kaggle_compile.py .\/src\/main.py | tee .\/submission\/submission.py\ntime -p python3 .\/submission\/submission.py           | tee .\/submission\/submission.log\n```"}}