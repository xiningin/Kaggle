{"cell_type":{"aadac91d":"code","9db59a66":"code","08936bf2":"code","78d45ff8":"code","6dd0dec4":"code","3b7ac2d0":"markdown","6c8f451a":"markdown"},"source":{"aadac91d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport math\nimport random as rd\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9db59a66":"J=np.matrix([[0.9, 0.2, 0.9], [0.4, 0.8, 2.4], [0, 1.1, 0.9]])\ny=np.array([[19, 5.7, 2.2]])\nf=np.array([[17, 10, 3.3]])\np=np.array([[19, 2.2, 5]])\nab2=np.array([[5, 10, 20]])\n\nr = y - f\ndp = np.matmul(np.matmul(J.transpose(), J)**(-1), np.matmul(J.transpose(), r.transpose()))\np = np.array(p + dp.transpose())\n\nprint(\"p1=\" + str(p[0]))","08936bf2":"def VES1dmod(p,s):\n    r = np.array([p[0][0],p[0][1]])\n    t = np.array([p[0][2]])\n    q = 13;\n    f = 10;\n    m = 4.438;\n    x = 0;\n    e = math.exp(0.5*math.log(10)\/m);\n    h = 2*q-2;\n    u = s*math.exp(-f*math.log(10)\/m-x);\n    l = r.shape[0];\n    n = 1;\n    a = np.zeros((1,n+h))\n    a = a.transpose()\n    for i in range(n+h):\n        w = l-1;\n        v = r[l-1];\n        while w>0:\n            w = w-1;\n            aa = math.tanh(t[w]\/u);\n            v = (v+r[w]*aa)\/(1+v*aa\/r[w]);\n        a[i] = v;\n        u = u*e;\n    i = 0;\n    g = 105*a[i]-262*a[i+2]+416*a[i+4]-746*a[i+6]+1605*a[i+8];\n    g = g-4390*a[i+10]+13396*a[i+12]-27841*a[i+14];\n    g = g+16448*a[i+16]+8183*a[i+18]+2525*a[i+20];\n    g = (g+336*a[i+22]+225*a[i+24])\/10000;\n    return g","78d45ff8":"p=np.array([[19, 2.2, 5]])\nab2=np.array([[5, 10, 20]])\n\nprint(\"Erechnete Werte f\u00fcr die gew\u00e4hlten Anfangsparameter\")\nfor i in range(3):\n    print(VES1dmod(p,ab2[0][i]))\nprint(\"Zum Vergleich die gegebenen Werte f:\" + str(f[0]))","6dd0dec4":"J=np.matrix([[0.9, 0.2, 0.9], [0.4, 0.8, 2.4], [0, 1.1, 0.9]])\ny=np.array([[19, 5.7, 2.2]])\nf=np.array([[17, 10, 3.3]])\np=np.array([[25, 2.2, 5]])\nab2=np.array([[5, 10, 20]])\nn=25 #max iterations\n\nfor i in range(p.shape[1]):\n    f[0][i] = VES1dmod(p,ab2[0][i]) #Errechne Werte f\n    \nk=0\nrunning=True\n\nwhile(running):\n    r = y - f\n    for i in range(3):\n        for j in range(3):\n            dx = np.zeros((1,3))\n            dx[0][j] = 10e-3\n            #dx[0][j] = 10e-7 * p[0][j]\n            p1 = np.array(p + dx)\n            g = np.float128((VES1dmod(p1,ab2[0][i]) - VES1dmod(p,ab2[0][i]))\/dx[0][j])\n            J[i, j] = g + 10e-7*rd.random()     #Berechnen der JakobiMatrix und hinzuf\u00fcgen eines minimalen Rauschens um Singularit\u00e4ten zu vermeiden\n    \n    \n    dp = np.matmul(np.matmul(J.transpose(), J)**(-1), np.matmul(J.transpose(), r.transpose()))\n    p = np.array(p + dp.transpose())            #Bestimmen von dp und dem neuen Parametervektor p\n    \n    for i in range(p.shape[1]):\n        f[0][i] = VES1dmod(p,ab2[0][i])         #Errechne neue Werte f\u00fcr f \n        \n    k=k+1\n    print(\"k=\" + str(k))\n    #print(\"r=\" + str(y-f))\n    print(\"p=\" + str(p))\n    if k == n:\n        running=False\n    if np.where(np.absolute(dp.transpose()\/p[0]) < 10e-4, True, False).all():\n        running=False                           #Abbruchkriterien\n    \nprint(\"Das finale Inversionsergebnis nach \" + str(k) + \" Iterationen ist:\")\nprint(\"rho1 = \" + str(p[0][0]))\nprint(\"rho2 = \" + str(p[0][1]))\nprint(\"h1 = \" + str(p[0][2]))","3b7ac2d0":"Dies entspricht der 1. Iteration, und gibt uns den neuen Parametervektor p1 an.\nUm weiterzumachen, m\u00fcssten wir die neuen Werte f aus p1 berechnen.","6c8f451a":"Das ist die Funktion aus der Pr\u00e4senz\u00fcbung zur bestimmung der errechneten Werte eines Modells bei Parametern p und AB\/2 = s. Diese wurde lediglich in Python \"\u00fcbersetzt\"."}}