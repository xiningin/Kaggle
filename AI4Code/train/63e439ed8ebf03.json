{"cell_type":{"e040151f":"code","4a9239a2":"code","f560d04b":"code","9f25acaf":"code","86a092eb":"code","fe12917d":"code","d64caf1c":"code","3a795a6a":"code","7473544f":"code","98b37120":"code","50db32d6":"markdown","b6d296ed":"markdown","93cefc25":"markdown","32513085":"markdown","fe5c6da7":"markdown"},"source":{"e040151f":"# Imports\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport cv2\nimport random\nfrom tqdm import tqdm\n\nimport tensorflow as tf","4a9239a2":"# Read the data\ndata = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\ntest_data = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\n\ndata.head()","f560d04b":"train_data = data[:40000]\nvalid_data = data[40000:]\n\nprint(train_data.shape, valid_data.shape)","9f25acaf":"class DigitDataGenerator(tf.keras.utils.Sequence):\n    \"\"\"\n    Custom data generator class for Digits dataset\n    \"\"\"\n    def __init__(self, data: pd.DataFrame, batch_size: int=64):\n        self.labels = data['label'].values\n        self.images = data.drop(['label'], axis=1).values.reshape(-1, 28, 28)\n        self.labels = tf.keras.utils.to_categorical(self.labels)\n        self.batch_size = batch_size\n    \n    def __len__(self):\n        return np.math.ceil(len(self.images) \/ self.batch_size)\n    \n    def __getitem__(self, index):\n        \"\"\"\n        Returns a batch of data\n        \"\"\"\n        batch_images = self.images[index * self.batch_size : (index + 1) * self.batch_size]\n        batch_labels = self.labels[index * self.batch_size : (index + 1) * self.batch_size]\n\n        return batch_images, batch_labels","86a092eb":"def get_model(image_shape: tuple=(28, 28)):\n    return tf.keras.Sequential([\n        tf.keras.layers.Flatten(input_shape=image_shape),\n        tf.keras.layers.Dense(128, activation='relu'),\n        tf.keras.layers.Dense(64, activation='relu'),\n        tf.keras.layers.Dense(32, activation='relu'),\n        tf.keras.layers.Dense(10, activation='softmax')\n    ])","fe12917d":"model = get_model()\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodel.summary()","d64caf1c":"train_loader = DigitDataGenerator(train_data)\nvalid_loader = DigitDataGenerator(valid_data)","3a795a6a":"history = model.fit(train_loader, validation_data=valid_loader, epochs=25)","7473544f":"plt.plot(history.history['accuracy'], 'ro-', label='Training Accuracy')\nplt.plot(history.history['val_accuracy'], 'go-', label='Validation Accuracy')\nplt.title(\"Training and Validation Accuracy\")\nplt.legend(loc='best')\nplt.show()","98b37120":"plt.plot(history.history['loss'], 'mo-', label='Training Loss')\nplt.plot(history.history['val_loss'], 'bo-', label='Validation Loss')\nplt.title(\"Training and Validation Losses\")\nplt.legend(loc='best')\nplt.show()","50db32d6":"So here's the juicy part!\nI'll now explain the below class.\n\nSo the `DigitDataGenerator(tf.keras.utils.Sequence)` is the custom Data Generator we'll be making.\n\n* The `tf.keras.utils.Sequence` is basically a module from Keras that we need to use if we want to make our own data generators.\n* Every Data Generator class needs to have atleast the following 3 functions:\n    * The `__init__()` function:\n        * This is the constructor function that will be called when we make the objects of this class.\n        * You can do data splitting, reshaping and everything in here.\n        * You should always get the batch size when object is instantiated (it'll be useful later).\n    * The `__len__()` function:\n        * This function will return the number of batches in the data set.\n        * It will be calculated using the formula:  $batches = \\frac{trainingSamples}{batchSize}$\n    * The `__getitem__()` function:\n        * This functions is the main driver in this code.\n        * It takes `index` as an argument (the index is same as the indexes we use in lists, etc)\n        * This function does the following:\n            * It calculates the current batch indexes for all the data that you will return.\n            * For example: `batch_images = self.images[index * self.batch_size : (index + 1) * self.batch_size]` takes the list of all the images and calculates the current batch (which starts from index * batch_size and goes to index+1 * batch_size).\n            * Since you want to return data in batches, you have to do this for all the different data you want to return.\n            * In this case, I am just returning the batched images and batched labels after converting them into a numpy array\n\nAnd this is basically it! This is how you create a custom data generator.","b6d296ed":"I hope you found this notebook useful! Please don't forget to give an upvote and a comment if you have any doubts!\n\nThanks for reading!","93cefc25":"If you like this notebook, please consider giving an <span style='color:red;font-size:25px'>Upvote!<\/span>","32513085":"Now, you just make the objects of this data generator and pass them to the `model.fit()` function.","fe5c6da7":"# Making Custom Keras Data Generators!\n\nIf you have ever tried to do deep learning on a task that requires data in un-conventional formats that is, Not in the usual `(X, y)` format but something else, then you surely would've felt the need for custom data generators in keras.\n\nAn example of where you would need a custom data generator is when training a Convolutional Auto-encoder: You train it by passing your training images as both X (training data) and as y (ground truth).\n\nIn situations like these (where a normal `tf.keras.preprocessing.image.ImageDataGenerator()`) just wouldn't do the job; you have only 1 choice remaining which is to get all the data in a huge numpy array. \nBut this is very memory consuming and it doesn't even work when your dataset is large.\n\nSo here's a 2nd way of doing it! By making your very own \"Customized\" Data Generator in Keras!"}}