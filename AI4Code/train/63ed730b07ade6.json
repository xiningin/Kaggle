{"cell_type":{"34b8f1c7":"code","802d45b1":"code","1d07f7cb":"code","d8a31488":"code","f2e619e9":"code","93163105":"code","d8dc5b95":"code","4ef63687":"code","f1cdb6c9":"code","a66b4d0b":"code","cbd5c66d":"code","1283d635":"code","8d7be48c":"code","481a51de":"code","fe5200c3":"code","1f8aed15":"code","e83fa675":"code","9928a7d1":"code","df08ecdb":"code","4eb57de5":"code","331dffcf":"markdown","564f8a12":"markdown","60ada4ac":"markdown","3ba5f6e2":"markdown","05d9c444":"markdown","9c28a241":"markdown","629095d0":"markdown","7eb048bf":"markdown","bed20100":"markdown","92372888":"markdown","bbcf0ab1":"markdown","177369a4":"markdown","8fd0d35b":"markdown","91f64d42":"markdown","1c94acef":"markdown","b519657a":"markdown","82c6494c":"markdown","083b5945":"markdown","a6b60f6b":"markdown","5dba7199":"markdown","c8149acc":"markdown","8c5f4094":"markdown","49e28eae":"markdown","39e41439":"markdown","b493ef2d":"markdown","7ffd33b4":"markdown","93022148":"markdown","c10b95e5":"markdown","97d4f4c2":"markdown","a8241bc1":"markdown","89ed91da":"markdown","085dcd9d":"markdown","288cda4d":"markdown","59b533f0":"markdown","7c647285":"markdown","04f10b42":"markdown"},"source":{"34b8f1c7":"import numpy as np\nimport pandas as pd\nfd = '..\/input\/cee-498-project8-pore-in-concrete\/train.xlsx'\n\n# tabular data for first and second batches are placed in first and second sheets of our excel sheet, respectively\n\nbatch1 = pd.DataFrame(pd.read_excel(fd, sheet_name = 0))\nbatch2 = pd.DataFrame(pd.read_excel(fd, sheet_name = 'Batch2'))","802d45b1":"from IPython.core.display import display, HTML\n\n# set style of table caption\n\nstyles = [dict(selector=\"caption\", \n    props=[(\"text-align\", \"center\"),\n    (\"font-size\", \"120%\"),\n    (\"color\", 'blue')])]\n\n# this block is partially adapted from https:\/\/stackoverflow.com\/a\/58866040\n\n# prints the tables (i.e. batch1 and batch2) side by side.\n\ndef display_side_by_side(dfs:list, captions:list):\n    output = \"\"\n    combined = dict(zip(captions, dfs))\n    for caption, df in combined.items():\n        output += df.style.set_table_attributes(\"style='display:inline; font-size:90%;color:black;textalign:center'\"\n             ).set_caption(caption).set_table_styles(styles)._repr_html_()\n\n# increasing spacing between two tables\n\n        output += \"\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\"\n    display(HTML(output))\n    \n# assign suitable caption to each batch\n\nbatch1.rename(columns=({'ID':'batch1_image_id'}), inplace=True); batch2.rename(columns=({'ID':'batch2_image_id'}), inplace=True);\ndisplay_side_by_side([batch1.head(5),batch2.head(5)],['Batch1', 'Batch2'])\n\nprint('batches 1 and 2 have %s and %s images\/rows, respectively.'%(len(batch1),len(batch2)))","1d07f7cb":"from matplotlib import ticker as tick\nfrom matplotlib.figure import Figure\nimport PIL\nimport matplotlib.pyplot as plt\nimport glob\n\n# representing first five images of batch 1 in subplot format\n\nfig, axes=plt.subplots(nrows=1, ncols=5, figsize=(20,20))\n\n# the format of images were stored in png format \n\n# we select the first 5 images of batch1 just to show the reader how they look like in viridis threshold system\n\nfor i, f in enumerate(glob.glob('..\/input\/cee-498-project8-pore-in-concrete\/batch1\/batch1\/*.png')[:5]):\n    ax=axes[i%5]\n    ax.set_title('batch1_image_%d'%(i+1),fontsize=15, color='r', pad=15)\n    \n# values shown on x and y axes represents number of pixels in orthogonal directions \n\n    ax.set_xlabel('width',fontsize=15)\n    ax.set_ylabel('height',fontsize=15)\n    im=PIL.Image.open(f)\n    ax.imshow(im);\n    fig.subplots_adjust(wspace=20)\n    fig.tight_layout(pad=-4)\nprint('dimension of each image is %s (width) by %s (height) pixels'%((im.size)))","d8a31488":"fig, axes=plt.subplots(ncols=2, figsize=(20,6))\n\n#  here we illustrate two completely different color scales for image analysis\n\nfor k in range(2):\n        img = np.zeros((100,256),dtype=np.uint8)\n        for i in range(img.shape[1]):\n            for j in range(img.shape[0]):\n                img[j,i]=i\n                \n#  Viridis color scale\n\n        axes[0].imshow(img, cmap = 'viridis')\n    \n#  Greyscale color scale\n    \n        axes[1].imshow(img, cmap = 'gray')\n        axes[k].tick_params(axis='y',left = False,labelleft = False)\n        \n#  numbers appeared on x-axis tick-mark increases every 50 threshold\n\n        axes[k].set_xticks([0,50,100,150,200,255])\n        axes[k].tick_params(labelsize=16)\n        axes[0].set_title('Viridis threshold', fontsize=19)\n        axes[1].set_title('Greyscale threshold', fontsize=19)","f2e619e9":"# converting Viridis to Greyscale thresholds\n\nfig, axes=plt.subplots(nrows=1, ncols=5, figsize=(20,20))\nfor i, f in enumerate(glob.glob('..\/input\/cee-498-project8-pore-in-concrete\/batch1\/batch1\/*.png')[:5]):\n    ax=axes[i%5]\n    ax.set_title('batch1_greyscale_image_%d'%(i+1),fontsize=15, color='r', pad=15)\n    ax.set_xlabel('width',fontsize=15)\n    ax.set_ylabel('height',fontsize=15)\n    im=PIL.Image.open(f)\n    ax.imshow(im.convert('LA'));\n    fig.subplots_adjust(wspace=10)\n    fig.tight_layout(pad=-10)","93163105":"from PIL import Image\nimport requests\nfrom io import BytesIO\nplt.figure(figsize=(10,7))\n\n# importing sample image from open web source\n\nsample_image = requests.get('https:\/\/www.zkg.de\/imgs\/1\/5\/3\/9\/6\/9\/8\/Schade_Bild_8a-9d4e1097c0899084.jpeg')\nsample_back_scattered_image = Image.open(BytesIO(sample_image.content))\nplt.imshow(sample_back_scattered_image);","d8dc5b95":"ave_porosity_batch1=[]\nporosity_batch1_sub_threshold=[]\n\n# greyscale threshold of images in batch1 varies from 0 to 40\n\nthreshold_limit=41\nfor i in range(threshold_limit):\n    for f in glob.glob('..\/input\/cee-498-project8-pore-in-concrete\/batch1\/batch1\/*.png'):\n        im_bch1=PIL.Image.open(f).convert('LA')\n        total=np.array(im_bch1)\n        poros_bch1_count=0\n        for j in total:\n            for k in j:\n                \n# we quantify pores having luminance threshold less than i\n\n                if float(k[0]) < (i+1):\n                    poros_bch1_count+=1            \n        porosity_batch1_sub_threshold.append(poros_bch1_count\/(im.size[0]*im.size[1]))\n        \n# for different thresholds we calculate ave porosity of batch1 to compare them with exact ave porosity of this batch\n\n    ave_porosity_batch1.append(np.mean(porosity_batch1_sub_threshold))","4ef63687":"ave_porosity_batch2=[]\nporosity_batch2_sub_threshold=[]\n\n# greyscale threshold of images in batch2 varies from 0 to 40\n\nthreshold_limit=41\nfor i in range(threshold_limit):\n    for f in glob.glob('..\/input\/cee-498-project8-pore-in-concrete\/batch2\/batch2\/*.png'):\n        im_bch2=PIL.Image.open(f).convert('LA')\n        total=np.array(im_bch2)\n        poros_bch2_count=0\n        for j in total:\n            for k in j:\n                \n# we quantify pores having luminance threshold less than i\n\n                if float(k[0]) < (i+1):\n                    poros_bch2_count+=1            \n        porosity_batch2_sub_threshold.append(poros_bch2_count\/(im.size[0]*im.size[1]))\n        \n# for different thresholds we calculate ave porosity of batch2 to compare them with exact ave porosity of this batch\n\n    ave_porosity_batch2.append(np.mean(porosity_batch2_sub_threshold))","f1cdb6c9":"gray_scale_threshold=[]\nfor i in range(threshold_limit):\n    gray_scale_threshold.append(i)\n    \n# ave porosities are multiplied by 100 to be expressed in percentage(%)\n\nbatch_data={'Batch1 ave porosity(%)':100*np.array(ave_porosity_batch1),'Batch2 ave porosity(%)':100*np.array(ave_porosity_batch2),\n             'threshold':np.array(gray_scale_threshold)}\ndf_batch=pd.DataFrame(batch_data)\ndf_batch[30:41]","a66b4d0b":"# illustrating subplots of ave porosity for each batch as a funciton of threshold limit\n\nfig, axes=plt.subplots(nrows=1, ncols=2, figsize=(20,6))\n\n# batch1\n\naxes[0].scatter(df_batch['Batch1 ave porosity(%)'], df_batch['threshold'], color='red');\naxes[0].set_xlabel(\"batch1 ave porosity(%)\", size=16);axes[0].set_ylabel(\"greyscale threshold\", size=16);axes[0].set_title(\n        \"Batch1 ave porosity vs. greyscale threshold\", fontsize=16,color='blue');\nplt.setp(axes[0].get_xticklabels(), fontsize=12);plt.setp(axes[0].get_yticklabels(), fontsize=12);\n\n# batch2  \n\naxes[1].scatter(df_batch['Batch2 ave porosity(%)'], df_batch['threshold'], color='red');\naxes[1].set_xlabel(\"batch2 ave porosity(%)\", size=16);axes[1].set_ylabel(\"greyscale threshold\", size=16);axes[1].set_title(\n        \"Batch2 ave porosity vs. greyscale threshold\", fontsize=16, color='blue');\nplt.setp(axes[1].get_xticklabels(), fontsize=12);plt.setp(axes[1].get_yticklabels(), fontsize=12);","cbd5c66d":"import cv2\nfig, axes=plt.subplots(nrows=1, ncols=5, figsize=(20,20))\nfor i in range(5):\n        img = cv2.imread('..\/input\/cee-498-project8-pore-in-concrete\/batch1\/batch1\/image_1_7.png')\n\n# changing luminance of pixels having a threshold limit < 10*i to black (and the rest to white)\n\n        img[img >10*i] = 255\n        ax=axes[i%5]\n        ax.set_title('batch1_image_1_7_threshold= %d'%(10*(i)),fontsize=15, color='r', pad=15)\n        ax.set_xlabel('width',fontsize=15)\n        ax.set_ylabel('height',fontsize=15)\n        ax.imshow(img)\n        fig.subplots_adjust(wspace=10)\n        fig.tight_layout(pad=-15)","1283d635":"fig, axes=plt.subplots(nrows=1, ncols=5, figsize=(20,20))\nfor i in range(5):\n        img = cv2.imread('..\/input\/cee-498-project8-pore-in-concrete\/batch2\/batch2\/image_2_2.png')\n        \n# changing luminance of pixels having a threshold limit < 10*i to black (and the rest to white)\n        \n        img[img >10*i] = 255\n        ax=axes[i%5]\n        ax.set_title('batch2_image_1_7_threshold= %d'%(10*(i)),fontsize=15, color='r', pad=15)\n        ax.set_xlabel('width',fontsize=15)\n        ax.set_ylabel('height',fontsize=15)\n        ax.imshow(img)\n        fig.subplots_adjust(wspace=10)\n        fig.tight_layout(pad=-15)","8d7be48c":"import os\nbacth1_image_id=[]\ndf_first_id_to_integer=[]\ndf_second_id_split=[]\n\n# importing the name of images in batch1\n\nfor f in glob.glob('..\/input\/cee-498-project8-pore-in-concrete\/batch1\/batch1\/*.png'):\n        bacth1_image_id.append(os.path.split(f)[-1])\nmeasured_porosity=pd.DataFrame({'batch1_image_id':np.array(bacth1_image_id)})\n\n# sorting images to compare calculated porosities in batch1 with exact porosity\n\ndf_first_id=measured_porosity['batch1_image_id'].str.split('_', expand=True)[1]\nfor i in df_first_id:\n    df_first_id_to_integer.append(int(i))\ndf_second_id=measured_porosity['batch1_image_id'].str.split('_', expand=True)[2]\nfor i in df_second_id:\n    df_second_id_split.append(int(''.join(list(filter(str.isdigit, i)))))\n\n# representing porosity of each image at different thresholds\n\nmeasured_porosity_splitted_batch1=pd.DataFrame({'batch1_img_1st_id':df_first_id_to_integer, 'batch1_img_2nd_id':df_second_id_split,'posority_thershold=0'\n                                :100*np.array(porosity_batch1_sub_threshold)[0:100],'posority_thershold=10'\n                                :100*np.array(porosity_batch1_sub_threshold)[1000:1100],'posority_thershold=13'\n                                :100*np.array(porosity_batch1_sub_threshold)[1300:1400],'posority_thershold=14'\n                                :100*np.array(porosity_batch1_sub_threshold)[1400:1500],'posority_thershold=20'\n                                :100*np.array(porosity_batch1_sub_threshold)[2000:2100],'posority_thershold=30'\n                                :100*np.array(porosity_batch1_sub_threshold)[3000:3100],'posority_thershold=40'\n                                :100*np.array(porosity_batch1_sub_threshold)[4000:4100]})\n\nmeasured_porosity_splitted_sorted_batch1=measured_porosity_splitted_batch1.sort_values(by=['batch1_img_1st_id','batch1_img_2nd_id']\n                                                                        ).reset_index().drop(['index','batch1_img_1st_id'], axis=1)\n\nmeasured_porosity_splitted_sorted_batch1.rename(columns=({'batch1_img_2nd_id':'batch_1_porosity(%)_exact'}),inplace=True)\nmeasured_porosity_splitted_sorted_batch1['batch_1_porosity(%)_exact']=batch1['porosity(%)']\nmeasured_porosity_splitted_sorted_batch1.head(5)","481a51de":"bacth2_image_id=[]\ndf_second_id_split=[]\ndf_first_id_to_integer=[]\n\n# importing the name of images in batch2\n\nfor f in glob.glob('..\/input\/cee-498-project8-pore-in-concrete\/batch2\/batch2\/*.png'):\n        bacth2_image_id.append(os.path.split(f)[-1])\nmeasured_porosity=pd.DataFrame({'batch2_image_id':np.array(bacth2_image_id)})\n\n# sorting images to compare calculated porosities in batch2 with exact porosity\n\ndf_first_id=measured_porosity['batch2_image_id'].str.split('_', expand=True)[1]\nfor i in df_first_id:\n    df_first_id_to_integer.append(int(i))\ndf_second_id=measured_porosity['batch2_image_id'].str.split('_', expand=True)[2]\nfor i in df_second_id:\n    df_second_id_split.append(int(''.join(list(filter(str.isdigit, i)))))\n\n# representing porosity of each image at different thresholds\n\nmeasured_porosity_splitted_batch2=pd.DataFrame({'batch2_img_1st_id':df_first_id_to_integer, 'batch2_img_2nd_id':df_second_id_split,'posority_thershold=0'\n                                :100*np.array(porosity_batch2_sub_threshold)[0:100],'posority_thershold=9'\n                                :100*np.array(porosity_batch2_sub_threshold)[900:1000],'posority_thershold=10'\n                                :100*np.array(porosity_batch2_sub_threshold)[1000:1100],'posority_thershold=11'\n                                :100*np.array(porosity_batch2_sub_threshold)[1100:1200],'posority_thershold=20'\n                                :100*np.array(porosity_batch2_sub_threshold)[2000:2100],'posority_thershold=30'\n                                :100*np.array(porosity_batch2_sub_threshold)[3000:3100],'posority_thershold=40'\n                                :100*np.array(porosity_batch2_sub_threshold)[4000:4100]})\n\nmeasured_porosity_splitted_sorted_batch2=measured_porosity_splitted_batch2.sort_values(by=['batch2_img_1st_id','batch2_img_2nd_id']\n                                                                        ).reset_index().drop(['index','batch2_img_1st_id'], axis=1)\n\nmeasured_porosity_splitted_sorted_batch2.rename(columns=({'batch2_img_2nd_id':'batch_2_porosity(%)_exact'}),inplace=True)\nmeasured_porosity_splitted_sorted_batch2['batch_2_porosity(%)_exact']=batch2['porosity(%)']\nmeasured_porosity_splitted_sorted_batch2.head(5)","fe5200c3":"fig, axes=plt.subplots(nrows=1, ncols=5, figsize=(30,5))\n\n# matching calculated and exact porosities in batch1 \n\nfor i in range(5):\n        ax=axes[i%5]\n        ax.set_title('batch1 porosity vs. threshold= %d'%(10*(i)),fontsize=16, color='r')\n        ax.scatter(measured_porosity_splitted_sorted_batch1['batch_1_porosity(%)_exact'], measured_porosity_splitted_sorted_batch1\n                ['posority_thershold=%d'%(10*i)], color='blue')\n        ax.set_xlabel('porosity threshold=%d'%(10*i),fontsize=16);\n        plt.setp(ax.get_xticklabels(), fontsize=16);plt.setp(ax.get_yticklabels(), fontsize=16);\naxes[0].set_ylabel('bacth1 exact porosity(%)',fontsize=16);\n\nfig, axes=plt.subplots(nrows=1, ncols=5, figsize=(30,5))\n\n# matching calculated and exact porosities in batch2 \n\nfor i in range(5):\n        ax=axes[i%5]\n        ax.set_title('batch2 porosity vs. threshold= %d'%(10*(i)),fontsize=16, color='r')\n        ax.scatter(measured_porosity_splitted_sorted_batch2['batch_2_porosity(%)_exact'], measured_porosity_splitted_sorted_batch2\n                ['posority_thershold=%d'%(10*i)], color='blue')\n        ax.set_xlabel('porosity threshold=%d'%(10*i),fontsize=16);\n        plt.setp(ax.get_xticklabels(), fontsize=16);plt.setp(ax.get_yticklabels(), fontsize=16);\naxes[0].set_ylabel('bacth2 exact porosity(%)',fontsize=16);","1f8aed15":"fig.suptitle('test title', fontsize=20)\ncolor = {'boxes': 'DarkGreen', 'whiskers': 'black',\n               'medians': 'red', 'caps': 'Gray'}\nmeasured_porosity_splitted_sorted_batch1.plot.box(color=color, figsize=(27,5), title='Batch1', fontsize=14).set_ylabel('batch1 porosity(%)', fontsize=14);\nmeasured_porosity_splitted_sorted_batch2.plot.box(color=color, figsize=(27,5),title='Batch2', fontsize=14).set_ylabel('batch2 porosity(%)', fontsize=14);","e83fa675":"mean_batch1=[];mean_batch2=[]\nstd_batch1=[];std_batch2=[]\ncv_batch1=[];cv_batch2=[]\ntitles=['matching mean of 10 random images','matching std of 10 random images','matching CV of 10 random images' ]\n\nfor i in range(10):\n    \n#  calculating mean value of subbaches of batch 1 and 2\n\n    mean_batch1.append(100*np.array(porosity_batch1_sub_threshold)[10*i:10*(i+1)].mean())\n    mean_batch2.append(100*np.array(porosity_batch2_sub_threshold)[10*i:10*(i+1)].mean())\n    \n#  calculating standard deviation of subbaches of batch 1 and 2\n\n    std_batch1.append(100*np.array(porosity_batch1_sub_threshold)[10*i:10*(i+1)].std())\n    std_batch2.append(100*np.array(porosity_batch2_sub_threshold)[10*i:10*(i+1)].std())\n    \n#  calculating coefficient of variation of subbaches of batch 1 and 2\n\n    cv_batch1.append(np.array(porosity_batch1_sub_threshold)[10*i:10*(i+1)].mean()\/np.array(porosity_batch1_sub_threshold)[10*i:10*(i+1)].std())\n    cv_batch2.append(np.array(porosity_batch2_sub_threshold)[10*i:10*(i+1)].mean()\/np.array(porosity_batch1_sub_threshold)[10*i:10*(i+1)].std())\nstats_batches=[[mean_batch1,mean_batch2],[std_batch1,std_batch2],[cv_batch1,cv_batch2]]\nfrom sklearn.metrics import r2_score\n\nfig, axes=plt.subplots(nrows=1, ncols=3, figsize=(26,6))\nfor i in range(3):\n    ax=axes[i%3]\n    ax.plot(stats_batches[i][0],stats_batches[i][1],\"*\", ms=8, mec=\"k\")\n    \n# calculating R-squared for linear regression analysis\n\n    z = np.polyfit(stats_batches[i][0],stats_batches[i][1], 1)\n    y_hat = np.poly1d(z)(stats_batches[i][0])\n    ax.plot(stats_batches[i][0], y_hat, \"r-\", lw=1)\n    text = f\"$y={z[0]:0.3f}\\;x{z[1]:+0.3f}$\\n$R^2 = {r2_score(stats_batches[i][1],y_hat):0.3f}$\"\n    ax.set_title(titles[i], fontsize=20, color='b')\n    ax.set_xlabel('batch1', fontsize=16);ax.set_ylabel('batch2', fontsize=16)\n    ax.legend(['matched data','linear regression'],fontsize=15)\n    ax.tick_params(labelsize=14)\n    ax.text(0.05, 0.65, text,transform=ax.transAxes,fontsize=15, verticalalignment='top', color='r');","9928a7d1":"import scipy\nfrom scipy. stats import lognorm \nmu_batches=[]\nsigma_batches=[]\nksquare_parameters=[]\nx_lognormal=[]\ny_lognormal=[]\ny_lognormal_bacthes=[]\ncolors=['g','b']\n\nporosity_batches=[measured_porosity_splitted_sorted_batch1['posority_thershold=0'],measured_porosity_splitted_sorted_batch2['posority_thershold=0']]\n \nfor i in range(2):\n\n# fitting lognormal distribution to histograms of batches 1 and 2\n\n# the following code is partially adapted from https:\/\/stackoverflow.com\/q\/26406056\n\n    shape, location, scale = scipy.stats.lognorm.fit(porosity_batches[i])\n    mu, sigma = np.log(scale), shape\n    mu_batches.append(mu)\n    sigma_batches.append(sigma)\n    for j in range(1,1000):\n        x_lognormal.append(j\/10)\n        y_lognormal.append(np.exp(-(np.log(j\/10) - mu)**2 \/ (2 * sigma**2))\/ (j\/10* sigma * np.sqrt(2 * np.pi)))\n        \n#  calculating average porosity in batches 1 and 2\n\nmu_batches_round=np.round(np.exp(mu_batches),3)    \nporosity_distr=[measured_porosity_splitted_sorted_batch1['posority_thershold=0'],measured_porosity_splitted_sorted_batch2['posority_thershold=0']]\nave_porosity=[round(porosity_distr[0].mean(),3),round(porosity_distr[1].mean(),3)]\n\n\nfig, axes=plt.subplots(nrows=2, ncols=2, figsize=(20,10))\nfor i in range(4):\n        ax=axes[int(i\/2)][i%2]\n        ax.set_title('batch%d porosity distribution, bins=%d'%(int(i\/2)+1,10**(i%2+1)),fontsize=20, color='r')\n        ax.hist(porosity_distr[int(i\/2)], color=colors[i%2], bins=10**(i%2+1), density=True)\n        ax.plot(x_lognormal[0:999],y_lognormal[0:999], color='r')\n        ax.set_xlabel('porosity(%)',fontsize=18);\n        ax.set_ylabel('normalized frequency',fontsize=18);\n        plt.setp(ax.get_xticklabels(), fontsize=16);plt.setp(ax.get_yticklabels(), fontsize=16);\n\n# as well, we show the average porsoity of lognormal dist we fitted to the histograms\n\n        ax.legend(['lognormal ave. porosity=%s'%(mu_batches_round[int(i\/2)]),'batch%s ave. porosity=%s'%(int(i\/2)+1,\n                                                                                                           ave_porosity[int(i\/2)])],fontsize=15,loc=0)\n        fig.tight_layout()","df08ecdb":"import scipy.stats as stats\nfrom matplotlib import scale as mscale\nfrom matplotlib import transforms as mtransforms\nfrom matplotlib.ticker import Formatter, FixedLocator\nimport math\n\n# the follwoing code is partially adapted from https:\/\/stackoverflow.com\/a\/55732312\n\n# the following class calculates 'ordered' medians (i.e. rank of frequency) vs response values (i.e. frequency)\n\nclass PPFScale(mscale.ScaleBase):\n    name = 'ppf'\n\n    def __init__(self, axis, **kwargs):\n        mscale.ScaleBase.__init__(self, axis)\n\n    def get_transform(self):\n        return self.PPFTransform()\n\n    def set_default_locators_and_formatters(self, axis):\n        class VarFormatter(Formatter):\n            def __call__(self, x, pos=None):\n                return f'{x}'[1:]\n\n        axis.set_major_locator(FixedLocator(np.array([.01,.1,.2,.3,.4,.5,.6,.7,.8,.9,.99,.999])))\n        axis.set_major_formatter(VarFormatter())\n\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        return max(vmin, 1e-6), min(vmax, 1-1e-6)\n\n    class PPFTransform(mtransforms.Transform):\n        input_dims = output_dims = 1\n\n        def ___init__(self, axis, thresh):\n            mtransforms.Transform.__init__(self)\n\n        def transform_non_affine(self, a):\n            return stats.norm.ppf(a)\n\n        def inverted(self):\n            return PPFScale.IPPFTransform()\n\n    class IPPFTransform(mtransforms.Transform):\n        input_dims = output_dims = 1\n\n        def transform_non_affine(self, a):\n            return stats.norm.cdf(a)\n\n        def inverted(self):\n            return PPFScale.PPFTransform()\n\nmscale.register_scale(PPFScale)\n\nif __name__ == '__main__':\n   \n# calclating cumulative density function (CDF)\n\n    plt.rcParams[\"figure.figsize\"] = (20,8)\n    \n#  to do probability plot analysis, our data should be sorted \n\n    dataSorted_batch1 = np.sort(measured_porosity_splitted_sorted_batch1['posority_thershold=0'])\n    dataCdf_batch1 = np.linspace(0,1,len(dataSorted_batch1))\n    dataSorted_batch2 = np.sort(measured_porosity_splitted_sorted_batch2['posority_thershold=0'])\n    dataCdf_batch2 = np.linspace(0,1,len(dataSorted_batch2))\n\n# skteching probability plots of batches 1 and 2\n\n    plt.scatter(dataCdf_batch1, dataSorted_batch1, color='red')\n    plt.scatter(dataCdf_batch2, dataSorted_batch2, color='blue')\n    plt.xlabel('Log(rank of frequency)', fontsize=16)\n    plt.ylabel('Log(frequency)', fontsize=16)\n    plt.title('lognormal probability test of porosities in batches 1 and 2', fontsize=20, color='k')\n    plt.grid(b=True, which='both')\n    \n# skteching linear regression (LR) of batches 1 and 2\n\n# constants used for calculating LR of batch1\n\n    a=dataCdf_batch1[1:100]\n    b=dataSorted_batch1[1:100]\n\n# constants used for calculating LR of batch2\n    \n    c=dataCdf_batch2[1:100]\n    d=dataSorted_batch2[1:100]\n\n    def powerfit(x, y, xnew):\n        k, m = np.polyfit(np.log(x), np.log(y), 1)\n        return np.exp(m) * xnew**(k)\n    ys_batch1 = powerfit(a, b, a)\n    ys_batch2 = powerfit(c, d, c)\n    \n    plt.plot(a,ys_batch1, color='r')\n    plt.plot(c,ys_batch2, color='b')\n    plt.gca().set_xscale('log')\n    plt.gca().set_yscale('log')\n    plt.legend(['linear regression batch1','linear regression batch2','prob plot of porosities batch1','prob plot of porosities batch2'],fontsize=16)\n    plt.xlim(0.01, 1)\n    plt.xticks(fontsize=14)\n    plt.yticks(fontsize=14)\n    \n    correlation_matrix_batch1 = np.corrcoef(np.log(b),ys_batch1)\n    correlation_xy_batch1 = correlation_matrix_batch1[0,1]\n    r_squared_batch1 = correlation_xy_batch1**2\n    \n    correlation_matrix_batch2 = np.corrcoef(np.log(d),ys_batch2)\n    correlation_xy_batch2 = correlation_matrix_batch2[0,1]\n    r_squared_batch2 = correlation_xy_batch2**2\n\n# printing R_squared values corresponds to each prob plots \n\n    plt.text(0.04, 0.06, 'R-squared_batch1 = %s'%(np.round(r_squared_batch1,3)), fontsize=18, color='r')\n    plt.text(0.04, 3.96, 'R-squared_batch2 = %s'%(np.round(r_squared_batch2,3)), fontsize=18, color='b')\n    plt.show();","4eb57de5":"fig, axes=plt.subplots(nrows=1, ncols=2, figsize=(20,8))\n\n# comparing lognormal distributions of pores in batches 1 and 2\n\naxes[0].plot(x_lognormal[0:999],y_lognormal[0:999], color='g');\naxes[0].plot(x_lognormal[999:1998],y_lognormal[999:1998], color='b');\naxes[0].axvline(7.5, color='b', linestyle='dashed',linewidth=2)\naxes[0].axvline(1.5, color='g', linestyle='dashed',linewidth=2)\naxes[0].legend(['bacth1','bacth2'], fontsize=14)\naxes[0].tick_params(labelsize=16)\naxes[0].set_xlabel('porosity', fontsize=16);axes[0].set_ylabel('normalized frequency', fontsize=16)\n\n# matching lognormal distributions of porosities in batches 1 and 2\n\naxes[1].plot(y_lognormal[80:998],y_lognormal[1080:1998],\".\", ms=8, mec=\"k\")\nz = np.polyfit(y_lognormal[80:998],y_lognormal[1080:1998], 1)\ny_hat = np.poly1d(z)(y_lognormal[80:998])\naxes[1].plot(y_lognormal[80:998], y_hat, \"r-\", lw=2)\ntext = f\"$y={z[0]:0.3f}\\;x{z[1]:+0.3f}$\\n$R^2 = {r2_score(y_lognormal[1080:1998],y_hat):0.3f}$\"\naxes[1].text(0.05, 0.55, text,transform=axes[1].transAxes,fontsize=20, verticalalignment='top', color='r');\naxes[1].tick_params(labelsize=14)\naxes[1].set_xlabel('batch1 porosity lognormal fitting', fontsize=16);axes[1].set_ylabel('batch2 porosity lognormal fitting', fontsize=16);\naxes[1].legend(['matched log normal distr', 'linear regression'], fontsize=16);","331dffcf":"### It would be of interest to determine whether the mean, standard deviation (std), or coefficient of variation (CV) of random subbatch (each has 10 random images) of batch 1 and 2 are correlated. For this purpose, these statistical parameters are calculated for different batches at threshold=0, which provides us exact porosity. However, further analysis using linear regression revealed a low R-squared value, meaning no correlation (matching) could be established between these parameters.","564f8a12":"### Similar comparison was made for a single image in batch2. As a result, for both batches, we need to specify a realistic threshold limit corresponds to porosity, which excludes cement hydration products from calculations.","60ada4ac":"### To find a possible distribution of porosities in batches 1 and 2 we present their histograms made with different band widths (i.e. bins value). It is determined that smaller band width (i.e. b=10) is desired for selecting a distribution. Based on the positively skewed distribution we found in Step 6, our first assumption is to fit a lognormal distribution to the following histograms.","3ba5f6e2":"## <font color='red'>Step 8:<\/font> Distribution of porosity in selected batches","05d9c444":"## <font color='red'>Step 2:<\/font> Representing images in different color scales","9c28a241":"## <font color='red'>Step 6:<\/font> Porosities skewness of <font color='blue'>individual <\/font> images as a function of greyscale threshold ","629095d0":"***\n\n# <font color='red'>CEE 498 (Group 8)<\/font>\n\n\n# Porosity Measurement & Characterization in Cement Paste Matrix\n\n\n## Phase1: Exploratory Data Analysis\n\n\n### Hossein Kabir, PhD Student (Construction Materials Group)\n\n\n#### [hkabir2@illinois.edu](mailto:hkabir2@illinois.edu)\n\n***","7eb048bf":"## <font color='red'>Step 10:<\/font> Matching lognormal distribution of porosities in batches 1 and 2","bed20100":"### Also, the calculated porosity of images in batch2 would remain constant and match exact porosity as long as the greyscale threshold is limited to 9. ","92372888":"### The average porsity(%) of each batch calculated for different thresholds are shown in the following table. As an example, if grayscale threshold is limited to 37 (i.e. 0$\\leq$ threshold interval $\\leq$ 37) the average porosity would be 20.978 % and 14.871 % for batches 1 and 2, respectively.","bbcf0ab1":"### For this purpose, images previously shown in viridis system are now converted to greyscale colors and shown as follows:","177369a4":"## <font color='red'>Step 3:<\/font> Importance of defining a grayscale threshold","8fd0d35b":"### In cement paste matrix, some elements including `periclase` have relatively dark black scattered threshold (see image below, taken from an open web source):","91f64d42":"## <font color='red'>Step 9:<\/font> Validate the fitted lognormal[](http:\/\/) distribution of porosity in selected batches","1c94acef":"### Next, it is required to determine whether skewness of porosities are subjected to change by modifying greyscale threshold. The figures below suggest that porosities are positively skewed. However, the interquartile range of pores are not significantly changed by increasing the luminance threshold.","b519657a":"### As discussed earlier, python represents imported images in `Viridis` threshold. In this color scale, dark blue and bright yellow colors correspond to 0 and 255 respectively. However, there is a problem associates with this system and, that is we cannot quanify pores as they would not be correctly quanitifed using this system. To go futher, the backscattered images of pores, i.e. filled with epoxy resin, has no reflectance (i.e. zero electron emission) and must be shown in dark balck color (rather navy blue). As a result, it is required to convert `Viridis` to `Greyscale` thresholds.","82c6494c":"### As previously shown in Step 7, apparently no correlation exists between main statistical parameters (e.g. mean, and std) of image porosities in two batches. However, in Step 8 we fitted a lognormal distribution to the porosities. And in Step 9, we validated this lognormal fitting. Now, in Step 10, it is of interest to determine whether any correlation could be established between lognormal distribution of porosities of different batches. For this purpose, we matched the lognormal distribution of batch1 and 2. It is worth noting that we ignored the porosities placed prior to the peak location of lognormal distribution marked with a dashed line. Matching the distributions shows an R-squared of 0.986 suggesting a strong affinity in the log-normal distribution of results.","083b5945":"### In this step, we use a technique commonly used in exploratory data analysis to determine whether the chosen distribution is valid. This method which is called [probability plot](http:\/\/www.itl.nist.gov\/div898\/handbook\/eda\/section3\/probplot.htm) and asses our data to see whether it follows lognormal distribution. Since the R-squared found from the probability plot is relatively high (i.e. close to 1), our lognormal distribution is valid, see figure below.","a6b60f6b":"## <font color='red'>Conclusions:<\/font> ","5dba7199":"### As shown in the following figures, limiting the greyscale threshold would enhance accuracy of measured porosities. This could be inferred by matching the calculated and exact porosities of both batches. ","c8149acc":"### For each image, we compare the calculated porosity with that estimated by ImageJ commercial software (i.e. exact porosity). As shown in the table below, the calculated porosity of images in batch1 would remain constant and match exact porosity as long as the greyscale threshold is limited to 13.   ","8c5f4094":"## <font color='red'>Step 5:<\/font> Comparing caluclated and exact porosities of <font color='blue'>individual <\/font> images","49e28eae":"### In this worksheet, a robust image-based method is developed to measure and characterize porosity in cement paste matrix. To calibrate our model, it is required to train our model with two random batches, which are read as follows:","39e41439":"## <font color='red'>Step 5:<\/font> Separating cement hydration products from capillary pores (voids) using greyscale thresholds","b493ef2d":"## <font color='red'>Step 4:<\/font> Impact of grayscale threshold limit on <font color='blue'>average<\/font> porosity of batches","7ffd33b4":"### As a result, it is required to specify a correct threshold to differentiate capillary voids from cement hydration products. For this purpose, we evalaute greyscale thresholds in batch1 for each image varies from 0 to 40 (this subthreshold interval resembels dark color). It is worth noting that Kaggle platform needs approximately 4 minutes to analyze 200 million pixels in batch1. ","93022148":"### Similarly, threshold of images in batch2 varries from 0 to 40. Again, it will take 4 minutes for Kaggle to analyze 200 millions pixels in batch2 at different thresholds. ","c10b95e5":"### In the next block, our two batches are presented `side by side`. These batches, which consist of two columns (i.e. image id, and corresponding exact porosity found from ImageJ commercial software) will be used to characterize porosity.","97d4f4c2":"### To better understand how to quantify porosity, it is required to illustrate images. The next block represents the first five images of batch1, which were by default shown in `Viridis threshold`.","a8241bc1":"### Based on the present exploratory data analysis, the following conclusions could be drawn: \n* ### Cement paste porosity could be quantified using image-based analysis and is based on backscattered grayscale threshold. Specific threshold limits are suggested to differentiate capillary voids from cement hydration products\n* ### The porosites of each batch follow lognormal distribution with relatively strong R-squared value","89ed91da":"## <font color='red'>Step 7:<\/font> Statistical parameters for subbatch of images","085dcd9d":"## <font color='red'>Step 1:<\/font> Importing tabular data","288cda4d":"### It is found that in batches 1 and 2, the average porosity remains constant for certain `threshold limits`, i.e. 0$\\leq$ batch1 threshold $\\leq$ 13, and 0$\\leq$ batch2 threshold $\\leq$ 9 (see figure below). In addition, further increase in threshold limit results in an increase in average porosity of batches. It is now required to determine whether an increase in greyscale threshold limit would include cement hydration products (having relatively dark luminance) in porosity measurments. ","59b533f0":"## <font color='red'>Future Directions:<\/font> ","7c647285":"### Exploratory data analysis illuminated the role of greyscale threshold limits on the accuracy of porosity quantification. However, this analysis failed to provide us the following information:\n\n* ### shape of voids\n* ### connectivity of voids\n* ### best distribution that fits our data\n\n### In other words, exploratory data analysis quantified porosity in cement paste matrix, but failed to characterize it. As a result, in the next step, we will be leveraging machine learning algorithms to further analyze our image in an automated way to decently characterize porosity\n","04f10b42":"### In the next block, we convert pixels having specific threshold limit to black. Consequently, enhancing the threshold limit in batch1 would increase volume of pores in cement paste matrix. To go further into detail, comparing pore volume having luminance threshold limits of 0 and 40 reveales that we may have included cement hydration products to porosity by increasing threshold limit. This comparison is shown for a sample image (i.e. image_1_7) of batch1."}}