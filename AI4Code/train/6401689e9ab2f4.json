{"cell_type":{"e7e1f7d8":"code","57f1ca4b":"code","1b1c2b33":"code","8fdc16f6":"code","37920a16":"code","231b40f2":"code","53a6d326":"code","4e3e3e64":"code","45dffcb7":"code","3d908144":"code","e0fd3651":"code","d86408f2":"code","05915f7a":"code","a1cf463f":"code","fdcb5fbf":"code","9cd74d21":"code","c10e8c0a":"code","76b80fc4":"code","1aea1508":"code","7fef2bc9":"code","cc23ff49":"code","b6147aea":"code","3d739213":"code","cbba9b2e":"code","40752450":"markdown","b76f2652":"markdown","58ebd818":"markdown","a6bcff46":"markdown","5f23fe8f":"markdown","8d697798":"markdown","91b55414":"markdown","7d0402cb":"markdown","d58d7f0e":"markdown","222e6257":"markdown","2c8cbfb2":"markdown","f85e3da6":"markdown","b5e6ad78":"markdown","1b3139e5":"markdown","5b2b63b8":"markdown","39e78732":"markdown","104d9f1a":"markdown"},"source":{"e7e1f7d8":"# set seeds to ensure repeatability of results\nfrom numpy.random import seed\nseed(101)\nfrom tensorflow import set_random_seed\nset_random_seed(101)\n\nimport pandas as pd\nimport numpy as np\nimport os\nimport cv2\n\nimport tensorflow \n\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten, ZeroPadding2D\nfrom tensorflow.keras.layers import BatchNormalization, LeakyReLU\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.metrics import categorical_crossentropy\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint\nfrom tensorflow.keras.metrics import binary_accuracy\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom skimage.io import imread, imshow\nfrom skimage.transform import resize\n\n\n# Don't Show Warning Messages\nimport warnings\nwarnings.filterwarnings('ignore')","57f1ca4b":"IMG_HEIGHT = 128\nIMG_WIDTH = 128\nIMG_CHANNELS = 3\n\nPADDING = 40\n\nNUM_TEST_IMAGES = 10","1b1c2b33":"# ==============================    \n# Make a List of Test Set Masks\n# ==============================\n\ntest_id_list = ['SIMCEPImages_A15_C61_F1_s03_w2.TIF',\n 'SIMCEPImages_A21_C87_F1_s03_w1.TIF',\n 'SIMCEPImages_A01_C1_F1_s02_w1.TIF',\n 'SIMCEPImages_A04_C14_F1_s05_w1.TIF',\n 'SIMCEPImages_A18_C74_F1_s01_w1.TIF',\n 'SIMCEPImages_A04_C14_F1_s18_w1.TIF',\n 'SIMCEPImages_A18_C74_F1_s09_w2.TIF',\n 'SIMCEPImages_A13_C53_F1_s10_w2.TIF',\n 'SIMCEPImages_A08_C31_F1_s13_w2.TIF',\n 'SIMCEPImages_A19_C78_F1_s15_w2.TIF']\n\nnum_cells = [61, 87, 1, 14, 74, 14, 74, 53, 31, 78]\n\n\n# =====================    \n# Create X_test\n# ===================== \n\n# create an empty matrix\nX_test = np.zeros((len(test_id_list), IMG_HEIGHT, IMG_WIDTH, IMG_CHANNELS)) #, dtype=np.bool)\n\n\nfor i, mask_id in enumerate(test_id_list):\n    \n    path_mask = '..\/input\/bbbc005_v1_ground_truth\/BBBC005_v1_ground_truth\/' + mask_id\n    \n    # read the file as an array\n    cv2_image = cv2.imread(path_mask)\n    # resize the image\n    cv2_image = cv2.resize(cv2_image, (IMG_HEIGHT, IMG_WIDTH))\n    # save the image at the destination as a jpg file\n    cv2.imwrite('mask.jpg', cv2_image)\n\n    \n    # read the image using skimage\n    mask = imread('mask.jpg')\n\n    \n    # resize the image\n    #mask = resize(mask, (IMG_HEIGHT, IMG_WIDTH), mode='constant', preserve_range=True)\n    \n    # use np.expand dims to add a channel axis so the shape becomes (IMG_HEIGHT, IMG_WIDTH, 1)\n    #mask = np.expand_dims(mask, axis=-1)\n    \n    # insert the image into X_Train\n    X_test[i] = mask\n\n    \n    \n# =====================    \n# Display the masks\n# =====================  \n\n# set up the canvas for the subplots\nplt.figure(figsize=(10,10))\nplt.axis('Off')\n\n# Our subplot will contain 3 rows and 3 columns\n# plt.subplot(nrows, ncols, plot_number)\n\n\n# == row 1 ==\n\n# image\nplt.subplot(3,3,1)\ntest_image = X_test[1, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 87', fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,2)\ntest_image = X_test[2, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 1', fontsize=14)\nplt.axis('off')\n\n\n# image\nplt.subplot(3,3,3)\ntest_image = X_test[3, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 14', fontsize=14)\nplt.axis('off')\n\n\n# == row 2 ==\n\n# image\nplt.subplot(3,3,4)\ntest_image = X_test[4, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 74', fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,5)\ntest_image = X_test[5, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 14', fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,6)\ntest_image = X_test[6, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 74', fontsize=14)\nplt.axis('off')\n\n\n# == row 3 ==\n\n# image\nplt.subplot(3,3,7)\ntest_image = X_test[7, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 53', fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,8)\ntest_image = X_test[8, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 31', fontsize=14)\nplt.axis('off')\n\n\n# image\nplt.subplot(3,3,9)\ntest_image = X_test[9, :, :, 0]\nplt.imshow(test_image)\nplt.title('Num Cells: 78', fontsize=14)\nplt.axis('off')\n\n\nplt.tight_layout()\nplt.show()\n","8fdc16f6":"# get a list of files in each folder\n\nimg_list = os.listdir('..\/input\/bbbc005_v1_images\/BBBC005_v1_images')\nmask_list = os.listdir('..\/input\/bbbc005_v1_ground_truth\/BBBC005_v1_ground_truth')\n\n# create a dataframe\ndf_images = pd.DataFrame(img_list, columns=['image_id'])\n\n# filter out the non image file that's called .htaccess\ndf_images = df_images[df_images['image_id'] != '.htaccess']\n\n\n\n# Example file name: SIMCEPImages_A13_C53_F1_s23_w2.TIF\n\n\n# ======================================================\n# Add a column showing how many cells are on each image\n# ======================================================\n\ndef get_num_cells(x):\n    # split on the _\n    a = x.split('_')\n    # choose the third item\n    b = a[2] # e.g. C53\n    # choose second item onwards and convert to int\n    num_cells = int(b[1:])\n    \n    return num_cells\n\n# create a new column called 'num_cells'\ndf_images['num_cells'] = df_images['image_id'].apply(get_num_cells)\n\n\n# ================================================\n# Add a column indicating if an image has a mask.\n# ================================================\n\n# Keep in mind images and masks have the same file names.\n\ndef check_for_mask(x):\n    if x in mask_list:\n        return 'yes'\n    else:\n        return 'no'\n    \n# create a new column called 'has_mask'\ndf_images['has_mask'] = df_images['image_id'].apply(check_for_mask)\n\n\n\n# ===========================================================\n# Add a column showing how much blur was added to each image\n# ===========================================================\n\ndef get_blur_amt(x):\n    # split on the _\n    a = x.split('_')\n    # choose the third item\n    b = a[3] # e.g. F1\n    # choose second item onwards and convert to int\n    blur_amt = int(b[1:])\n    \n    return blur_amt\n\n# create a new column called 'blur_amt'\ndf_images['blur_amt'] = df_images['image_id'].apply(get_blur_amt)\n","37920a16":"df_images.head()","231b40f2":"df_masks = df_images[df_images['has_mask'] == 'yes']\n\n# create a new column called mask_id that is just a copy of image_id\ndf_masks['mask_id'] = df_masks['image_id']\n\ndf_masks.shape","53a6d326":"df_masks.head()","4e3e3e64":"\n# test_id_list and num_cells were defined in the introduction section.\ndf_test = pd.DataFrame(test_id_list, columns=['mask_id'])\n\n# add a new column with the number of cells on each mask\ndf_test['num_cells'] = num_cells\n\n# Reset the index.\n# This is so that we can use loc to access mask id's later.\ndf_test = df_test.reset_index(drop=True)\n\n\n# Select only rows that are not part of the test set.\n# Note the use of ~ to execute 'not in'.\ndf_masks = df_masks[~df_masks['mask_id'].isin(test_id_list)]\n\nprint(df_masks.shape)\nprint(df_test.shape)","45dffcb7":"df_test.head()","3d908144":"# X_train\n\n# Get lists of images and their masks.\nmask_id_list = list(df_masks['mask_id'])\n\n# Create empty arrays\nX_train = np.zeros((len(mask_id_list), IMG_HEIGHT, IMG_WIDTH, IMG_CHANNELS)) #, dtype=np.bool)\n\n\nfor i, mask_id in enumerate(mask_id_list):\n    \n    path_mask = '..\/input\/bbbc005_v1_ground_truth\/BBBC005_v1_ground_truth\/' + mask_id\n    \n    # read the file as an array\n    cv2_image = cv2.imread(path_mask)\n    # resize the image\n    cv2_image = cv2.resize(cv2_image, (IMG_HEIGHT, IMG_WIDTH))\n    # save the image at the destination as a jpg file\n    cv2.imwrite('mask.jpg', cv2_image)\n    \n    # read the image using skimage\n    mask = imread('mask.jpg')\n    \n    # resize the image\n    #mask = resize(mask, (IMG_HEIGHT, IMG_WIDTH), mode='constant', preserve_range=True)\n    \n    # use np.expand dims to add a channel axis so the shape becomes (IMG_HEIGHT, IMG_WIDTH, 1)\n    #mask = np.expand_dims(mask, axis=-1)\n    \n    # insert the image into X_Train\n    X_train[i] = mask\n\n    \n    \n# y_train\n\ny_train = df_masks['num_cells'] #.astype(np.float16)\n\n","e0fd3651":"print(X_train.shape)\nprint(y_train.shape)\nprint(X_test.shape)","d86408f2":"X_train[1, :, :, :].shape","05915f7a":"kernel_size = (3,3)\npool_size= (2,2)\nfirst_filters = 32\nsecond_filters = 64\nthird_filters = 128\n\ndropout_conv = 0.3\ndropout_dense = 0.3\n\n\nmodel = Sequential()\n\n# Input layer for rgb image. For grayscale image use the same channel 3 times\n# to maintain the shape that the model requires.\nmodel.add(Conv2D(first_filters, kernel_size, activation = 'relu', \n                 input_shape = (IMG_HEIGHT, IMG_WIDTH, IMG_CHANNELS)))\n\nmodel.add(ZeroPadding2D(padding=(PADDING, PADDING), data_format=None))\n\nmodel.add(Conv2D(first_filters, kernel_size, activation = 'relu'))\nmodel.add(Conv2D(first_filters, kernel_size, activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size = pool_size)) \nmodel.add(Dropout(dropout_conv))\n\nmodel.add(Conv2D(second_filters, kernel_size, activation ='relu'))\nmodel.add(Conv2D(second_filters, kernel_size, activation ='relu'))\nmodel.add(Conv2D(second_filters, kernel_size, activation ='relu'))\nmodel.add(MaxPooling2D(pool_size = pool_size))\nmodel.add(Dropout(dropout_conv))\n\nmodel.add(Conv2D(third_filters, kernel_size, activation ='relu'))\nmodel.add(Conv2D(third_filters, kernel_size, activation ='relu'))\nmodel.add(Conv2D(third_filters, kernel_size, activation ='relu'))\nmodel.add(MaxPooling2D(pool_size = pool_size))\nmodel.add(Dropout(dropout_conv))\n\nmodel.add(Conv2D(third_filters, kernel_size, activation ='relu'))\nmodel.add(Conv2D(third_filters, kernel_size, activation ='relu'))\nmodel.add(Conv2D(third_filters, kernel_size, activation ='relu'))\nmodel.add(MaxPooling2D(pool_size = pool_size))\nmodel.add(Dropout(dropout_conv))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(1024))\nmodel.add(LeakyReLU())\nmodel.add(BatchNormalization())\n\nmodel.add(Dense(512))\nmodel.add(LeakyReLU())\nmodel.add(BatchNormalization())\n\nmodel.add(Dense(1, activation='relu')) # set activation='relu' to keep all values positive\n\nmodel.summary()","a1cf463f":"model.compile(Adam(lr=0.001), loss='mean_squared_error', \n              metrics=['mse'])\n\nfilepath = \"model.h5\"\n\nearlystopper = EarlyStopping(patience=15, verbose=1)\n\ncheckpoint = ModelCheckpoint(filepath, monitor='val_mean_squared_error', verbose=1, \n                             save_best_only=True, mode='min')\n\ncallbacks_list = [earlystopper, checkpoint]\n\nhistory = model.fit(X_train, y_train, validation_split=0.1, batch_size=16, epochs=100, \n                    callbacks=callbacks_list)","fdcb5fbf":"# display the loss and accuracy curves\n\nimport matplotlib.pyplot as plt\n\nmean_squared_error = history.history['mean_squared_error']\nval_mean_squared_error = history.history['val_mean_squared_error']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nepochs = range(1, len(mean_squared_error) + 1)\n\nplt.plot(epochs, loss, 'bo', label='Training loss')\nplt.plot(epochs, val_loss, 'b', label='Validation loss')\nplt.title('Training and validation loss')\nplt.legend()\nplt.figure()\n\nplt.plot(epochs, mean_squared_error, 'bo', label='Training mse')\nplt.plot(epochs, val_mean_squared_error, 'b', label='Validation mse')\nplt.title('Training and validation mse')\nplt.legend()\nplt.figure()","9cd74d21":"# use the best epoch\nmodel.load_weights('model.h5')\n\npreds = model.predict(X_test)\n","c10e8c0a":"preds","76b80fc4":"# add the preds to df_test\ndf_test['preds'] = np.round(preds)\n\n# change the preds to integers to improve the look of the displayed results\ndf_test['preds'] = df_test['preds'].apply(np.int)\n\n# create a dataframe caled df_results\ndf_results = df_test[['mask_id', 'num_cells', 'preds']]\n\n# add a new column with the difference between the true and predicted values.\ndf_results['difference'] = abs(df_results['num_cells'] - df_results['preds'])\n","1aea1508":"df_results.head(10)","7fef2bc9":"# What was the max difference?\n\nmax_diff = df_results['difference'].max()\nmin_diff = df_results['difference'].min()\n\nprint('Max Error: ', max_diff)\nprint('Min Error: ', min_diff)","cc23ff49":"# =====================    \n# Display the masks\n# =====================  \n\n# set up the canvas for the subplots\nplt.figure(figsize=(10,10))\nplt.axis('Off')\n\n# Our subplot will contain 3 rows and 3 columns\n# plt.subplot(nrows, ncols, plot_number)\n\n\n# == row 1 ==\n\n# image\nplt.subplot(3,3,1)\ntest_image = X_test[1, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[1, 'num_cells']\npred = df_results.loc[1, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,2)\ntest_image = X_test[2, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[2, 'num_cells']\npred = df_results.loc[2, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n\n# image\nplt.subplot(3,3,3)\ntest_image = X_test[3, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[3, 'num_cells']\npred = df_results.loc[3, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n\n# == row 2 ==\n\n# image\nplt.subplot(3,3,4)\ntest_image = X_test[4, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[4, 'num_cells']\npred = df_results.loc[4, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,5)\ntest_image = X_test[5, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[5, 'num_cells']\npred = df_results.loc[5, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,6)\ntest_image = X_test[6, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[6, 'num_cells']\npred = df_results.loc[6, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n\n# == row 3 ==\n\n# image\nplt.subplot(3,3,7)\ntest_image = X_test[7, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[7, 'num_cells']\npred = df_results.loc[7, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,8)\ntest_image = X_test[8, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[8, 'num_cells']\npred = df_results.loc[8, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n# image\nplt.subplot(3,3,9)\ntest_image = X_test[9, :, :, 0]\nplt.imshow(test_image)\n\ntrue = df_results.loc[9, 'num_cells']\npred = df_results.loc[9, 'preds']\nresult = 'True: ' + str(true) + ' Pred: ' + str(pred)\n\nplt.title(result, fontsize=14)\nplt.axis('off')\n\n\nplt.tight_layout()\nplt.show()\n","b6147aea":"# --ignore-installed is added to fix an error.\n\n# https:\/\/stackoverflow.com\/questions\/49932759\/pip-10-and-apt-how-to-avoid-cannot-uninstall\n# -x-errors-for-distutils-packages\n\n!pip install tensorflowjs --ignore-installed","3d739213":"# Use the command line conversion tool to convert the model\n\n!tensorflowjs_converter --input_format keras model.h5 tfjs\/model","cbba9b2e":"# check that the folder containing the tfjs model files has been created\n!ls","40752450":"## Introduction","b76f2652":"### What were the max and min errors?","58ebd818":"## Train the Model","a6bcff46":"## Plot the Training Curves","5f23fe8f":"In this kernel our goal is to build a computer vision model that can look at a mask of a micropscope slide and predict how many cells are present. \n\nThis is a link to a web interface where a similar model has been deployed. You can submit jpg mask images and get an automatic cell count. Please use the Chrome browser for best results.<br>\nhttp:\/\/cellcount.test.woza.work\/\n\nThis site can be used to convert images from TIF to jpg format.<br>\nhttps:\/\/tiff2jpg.com\/\n\n\n","8d697798":"## Model Architecture","91b55414":"## Convert the Model to Tensorflow.js","7d0402cb":"## Put all info into a dataframe","d58d7f0e":"<hr>","222e6257":"## Define X_train and y_train","2c8cbfb2":"These are 9 masks from the test set that we will be using in this kernel. As you can see some masks look like paint splashes. Even a human would find it difficult to predict how many cells are present. In fact cell counting requires a highly skilled microscopicist. As you can imagine, this work takes a long time. With only 1,190 training images, would it be possible to build a model that can automatically process these paint splashes and produce good results? Let's find out. ","f85e3da6":"## Display the Results","b5e6ad78":"## Create df_test","1b3139e5":"## Make a Prediction","5b2b63b8":"## Create a df containing only masks","39e78732":"## Conclusion","104d9f1a":"We see that the results are unexpectedly good. Who would have thought that a simple cnn could perform this well. With only 1,190 training images it appears that it is in fact possible to build a cell counting model that produces good results.\n\nYou will notice that the model has a padding layer. Padding the images helped to improve the model's performance. This could be because padding helped the model to detect cells that are located at the edges of the masks.\n\nIntuitively one would think that to improve the model's performance we need to add more images that look like paint splashes. Surprisingly, while doing different experiments, I saw that the model found it easier to analyze paint splash images and images with a large number of cells. It struggled a bit with images that showed a few individual cells. Therefore, one preliminary conclusion is that, in order to improve model performance, we need to add more images showing just a few individual cells (about 1 to 14 cells).\n\nIt's important to take note that the results are different each time this kernel is run. This could be because Keras uses a different validation set each time. Therefore, it's advisable to perform 5 fold cross validation to get a more confident estimate of this models performance.\n\nThank you for reading."}}