{"cell_type":{"c6ac81ba":"code","5862bd8e":"code","2cdfe08f":"code","a23cda7e":"code","3829902d":"code","768b9112":"code","8aa38e0c":"code","7063fda1":"markdown","172e99fb":"markdown","25724cd2":"markdown","4c156ffe":"markdown","cbc8349f":"markdown","9b715dc8":"markdown","6e3b3571":"markdown","d801be46":"markdown","75c68368":"markdown"},"source":{"c6ac81ba":"#Librerias necesarias\nimport pandas as pd\nimport numpy as np\n\n#PASO 1: HALLAR MATRIZ DE DISTANCIAS\ndef matrizHamming(Cadenas,etiquetas):\n    longitud = len(Cadenas[0])\n    MatrizDistancias = np.zeros((len(Cadenas),len(Cadenas)))\n    \n    #Comparamos las cadenas de par en par\n    for i in range(len(Cadenas)):\n        for j in range(len(Cadenas)):\n            if(i==j or MatrizDistancias[i][j]!=0): continue\n            else:\n                #inicializamos la distancia en 0\n                Distancia = 0\n                for k in range(longitud):\n                    if(Cadenas[i][k]!=Cadenas[j][k]):\n                        #Por cada elemento distinto, incrementamos la distancia en 1\n                        Distancia+=1\n                print('\\n',Cadenas[i],'\\n',Cadenas[j],'\\nDistancia  = ',Distancia)\n                \n                #Asignamos la distancia en su respectivo espacio en la matriz\n                MatrizDistancias[i][j] = Distancia\n                MatrizDistancias[j][i] = Distancia\n    #Construimos el dataframe usando la libreria pandas\n    hamming = pd.DataFrame(data = MatrizDistancias, index = etiquetas, columns = etiquetas, dtype = np.int)\n    display(hamming)\n    return(hamming)","5862bd8e":"def MenorDistancia(MatrizDistancias):\n    #Tomamos como valor maximo 100000000 en la posicion [-1,-1]\n    menor = [100000000,[-1,-1]]\n    #Comparamos cada elemento en la matriz en busca del menor\n    for j in range(len(MatrizDistancias)):\n        for i in range(len(MatrizDistancias)):\n            if(i==j): \n                continue\n            #Si encontramos alguno que sea menor al valor actual, lo tomamos y almacenamos su posicion tambien\n            elif(MatrizDistancias.iat[i,j] < menor[0]):\n                menor = [MatrizDistancias.iat[i,j],[i,j]]               \n    return menor","2cdfe08f":"#Libreria para graficar el arbol final\nfrom graphviz import Digraph\n\n#Metodo que retorna:\n#- Una cadena con los elementos similares de 2 cadenas, siendo los distintos representados por '-'(gap)\n#- Dos cadenas adicionales con los elementos diferentes entre si, correspondientes a las comparadas\ndef extraerSimilares(Cad1, Cad2):\n    cadena = ''\n    dist1 = ''\n    dist2 = ''\n    #Comparamos cada elemento de las cadenas\n    for i in range(len(Cad1)):\n        #Si son iguales, lo aniadimos a la cadena de similares\n        # y agregamos '-'(gap) a las demas\n        if(Cad1[i]==Cad2[i]):\n            cadena+=Cad1[i]\n            dist1+='-'\n            dist2+='-'\n        #Caso contrario agregamos '-'(gap) a la cadena de similares\n        # y cada elemento distinto a su cadena respectiva\n        else:\n            cadena+='-'\n            dist1+=Cad1[i]\n            dist2+=Cad2[i]\n    return [cadena,dist1, dist2]\n#Metodo que retornara el arbol \ndef subArbol(Hamming, Cadenas, Menor, Nombres):\n    nodos = []\n    #Creamos el arbol con sus propiedades respectivas\n    Arbol = Digraph()\n    Arbol.attr('node',shape='rectangle')\n    #Iteraremos el numero total de cadenas -1 para poder unir todas.\n    for i in range(len(Cadenas)-1):\n        print('\\n\\x1b[6;30;43mEl menor valor es:',Menor[0],'\\nUbicado en la posicion: [',Hamming.index[Menor[1][0]],',',Hamming.index[Menor[1][1]],']')\n        \n        #Tomamos como hijos a las dos cadenas con las que trabajaremos\n        Hijo1 = Hamming.index[Menor[1][0]]\n        Hijo2 = Hamming.columns[Menor[1][1]]\n        \n        #Hallamos la distancia entre estas 2\n        distancia = Hamming.at[Hijo1,Hijo2]\/2\n        \n        #Hallamos las etiquetas que vendran respectivamente en cada nodo\n        Etiquetas = extraerSimilares(Cadenas[Hijo1],Cadenas[Hijo2])\n        \n        #Actualizaremos las etiquetas que nos ayudaran a identificar las cadenas\n        if(len(Hijo1)==1):\n            Etiquetas[1]+=' <= '+Nombres[Hijo1]\n        if(len(Hijo2)==1):\n            Etiquetas[2]+=' <= '+Nombres[Hijo2]\n            \n        #Si el hijo 1 o 2 aun no se encuentran en el arbol, los tendremos que crear\n        if(Hijo1 not in nodos):\n            Arbol.node(Hijo1, label = Etiquetas[1])\n            nodos.append(Hijo1)\n        if(Hijo2 not in nodos):\n            Arbol.node(Hijo2, label = Etiquetas[2])\n            nodos.append(Hijo2)\n        \n        #El nombre del padre sera la union de sus hijos\n        padre = \"\".join(sorted(Hijo1+Hijo2))\n        #Crearemos el nodo padre y lo aniadiremos al arbol\n        Arbol.node(padre, label = Etiquetas[0])\n        nodos.append(padre)\n        \n        #Uniremos el padre con sus 2 hijos, poniendo como etiqueta de la union la distancia\n        Arbol.edge(padre,Hijo1, label = str(distancia))\n        Arbol.edge(padre,Hijo2, label = str(distancia))\n        \n        #PASO 4. RECALCULAMOS LA MATRIZ DE DISTANCIAS\n        #Creamos una nueva matriz de 0's que tenga la misma dimension que la anterior menos una fila y una columna.\n        NuevasDistancias = np.zeros((len(Hamming.columns)-1,len(Hamming.columns)-1))\n        \n        #Asignamos la etiqueta obtenida con la cadena similar entre las 2 comparadas, al padre usando diccionarios\n        Cadenas[padre]=Etiquetas[0]\n        \n        #Obtenemos los anteriores indices de hamming\n        indices = list(Hamming.columns)\n        #Removemos las 2 cadenas unidas\n        indices.remove(Hijo1)\n        indices.remove(Hijo2)\n        #Aniadimos al padre\n        indices.append(padre)\n        indices.sort()\n        #Creamos nuestra nueva matriz de distancias\n        Nueva_Hamming = pd.DataFrame(data = NuevasDistancias, columns = indices, index = indices)\n        #Recorremos cada celda del dataFrame\n        for j in range(len(indices)):\n            for k in range(len(indices)):\n                #Si los indices son iguales(distancia 0), solo continuamos\n                if(indices[j]==indices[k]): continue\n                #Si algun indice es igual al padre, calculamos la nueva distancia del otro indice\n                #a cada parte del padre\/2, es decir: dist(padre,x) = (dist(hijo1,x)+dist(hijo2,x))\/2\n                elif(indices[j]==padre):\n                    T1 = Hamming.at[Hijo1,indices[k]]\n                    T2 = Hamming.at[Hijo2,indices[k]]\n                    Nueva_Hamming.iat[j,k]=(T1+T2)\/2\n                elif(indices[k]==padre):\n                    T1 = Hamming.at[Hijo1, indices[j]]\n                    T2 = Hamming.at[Hijo2, indices[j]]\n                    Nueva_Hamming.iat[j,k]=(T1+T2)\/2\n                #Caso contrario, solo asignamos su anterior distancia\n                else:\n                    Nueva_Hamming.iat[j,k] = Hamming.at[indices[j],indices[k]]\n        #Mostramos la nueva matriz de distancias\n        display(Nueva_Hamming)\n        Hamming = Nueva_Hamming\n        #Hallamos el nuevo menor de la nueva matriz\n        Menor = MenorDistancia(Hamming)\n                               \n    print('El arbol resultado es:')\n    Arbol.attr(rankdir='LR')\n    return Arbol","a23cda7e":"A = 'AGTAGTTC'\nB = 'AGTAGTTA'\nC = 'AGTAGTAA'\nD = 'AGTAGGGG'\nE = 'AGTAGGGC'\nindices = ['A','B','C','D','E']    \nHamming_inicial = matrizHamming([A,B,C,D,E],indices)\n\nMenor = MenorDistancia(Hamming_inicial)\nprint('Menor: ',Menor)","3829902d":"Cadenas = dict(zip(\"\".join(indices),[A,B,C,D,E]))\nNombres = dict(zip(\"\".join(indices),indices))\ndisplay(Hamming_inicial)\nsubArbol(Hamming_inicial, Cadenas,Menor, Nombres)","768b9112":"Alineamientos = [\n    'MWAFGGRAAVGL---------L---P-RTA-SRASAWVGNPRWREPIVTCGRRGL--HVTVNAGAT-RHAHLNLHY----L-QILNIKKQSVCVVHLRNLGTLDNPSSLDETAYERLAEETLDSLAEFFEDLADKPYTLEDYDVSFGDGVLTIKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGK----NWVYSHDGVSLHELLARELTKA-LNTKLDLSSLAYSGKGT------',\n    'MWTFGRRAAAGL---------L---P-RTA-SRASAWVRNPRGRERIGTCGRRGL--HVTANADAI-RHSHLNLHY----LGQILNIKKQSVCVVHLRNSGTLGNPSSLDETAYERLAEETLDALAEFFEDLADKPYTLKDYDVSFGDGVLTIKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGK----NWVYSHDGVSLHELLARELTEA-LNTKLDLSSLAYSGKGT------',\n    'MWTLGRRAAAGL---------LPRSA-PPGSAAAGAGTRGPTRA--APLHGGRGL--RVGTGAARGPSHANLSLHH----LNQLVNVKKQSVCLMNMRTVGTVSSPGSLDETTYERLAETTLDSLAEFFEDLADKPYTLEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGK----NWVYSHDGVSLHELLATELTKA-FKIKLDLSSLAYSGKGT------',\n    'MWTFGRRAVAGL---------L---A-SPSPAQAQTLTRAPRLAELAQLCSRRGL--RTGINATCTTHHTSSNLRG----LNQIRNVKRQSVYLMNLRKSGTLGHPGSLDDTTYERLAEETLDSLAEFFEDLADKPYTFEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGK----NWVYSHDGVSLHELLGAELTKA-LKTKLDLSSLAYSGKDA------',\n    'MWTLGRRAVAGL---------L---A-SPSPAQAQTLTRVPRPAELAPLCGRRGL--RTDIDATCTPRRASSNQRG----LNQIWNVKKQSVYLMNLRKSGTLGHPGSLDETTYERLAEETLDSLAEFFEDLADKPYTFEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGK----NWVYSHDGVSLHELLAAELTKA-LKTKLDLSSLAYSGKDA------',\n    'MIYRSPAAISGLGERVDVWRER---A-APCLARGRA---IPSVSRLLPSPGKRGIVSRSASAGKGTGKGREGGQSSSLHFLSQILNVKKQSVCVMHLRTTGTLGDPGSLDETTYERLAEETLDSLAEFFEDLADKPYTFEDYDVSFGSGVLTIKMGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGK----NWVYSHDGVSLHELLAAELTKA-LKTKLDLSSLAYSGKGT------',\n    'MWTLGRRSVASF---------L---PRSALPGFAPTRAGAPRPAKDLSLSGLPGL--RIGTAKAPARSQSSLSLRC----LNQTLDVKKQSVCWINLRTAGTLGDAGTLDDTTYERLAEETLDSLAEFFEDLADKPYTFEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGR----NWVYSHDGVSLHELLATELTQA-LKTKLDLSALAYSGKDTCCPAQC',\n    'MWTLGRRAVAGL---------L---A-SPSPAQAQTLTRVPRPAELAPLCGRRSL--RTGIDATCTPRRASSNLRG----LNQIWNVKKQSVYLMNLRKSGTLGHPGLLGSNPYERLAEETLDFLAEFFEDLADKPYTFEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGK----NWVYSHDGVSLHELLAAELTKA-LKTKLDLSSLAYSGKDA------',\n    '-MFAGRLMVRSI---------VGR----ACLATMGRWSKPQAHASQVILPSTPAIA-----AVAIQCEEFTANRRLF----------------------SSQIETESTLDGATYERVCSDTLDALCDYFEELTENASELQGTDVAYSDGVLTVNLGGQHGTYVINRQTPNKQIWLSSPTSGPKRYDFVGTVAAGRWIYKHSGQSLHELLQQEIPGILKSQSVDFLRLPYCS---------',\n    'MLLTRGTIKHSVFKILSY--DLVK-SIINKCLIQEINVKCQTNIGYHILHFKKNLN--INKDLKILSYESIAHNHC------------NKNLFIISSNNLST----QELTSVQFEKVSDETLTSLTEYFDELVEQAIHLSDADVSYGDGVLTIKFGDTHGTYVINRQSPNRQIWLSSPKSGPKRYDFID----GKWIYKYDRKTLHELLDDEIPAI-IGNQTNFNKCSFSGK--------',\n    '-------------------------------------------------------------------MLTNVLRNGFVR------------------R----AFSVRVFSQNEYESAADSTLEKLSDYFDQIADSYPVSDQFDVSHAMGVLTVTVSKTVGTYVINKQSPNKQIWLSSPLSGPKRYDLAEE---QSWKYSHDGENLDELLNREFRKILGDDRIDFSRHV------------',\n    '--MASRKLVLGL------------------TAARRLRSRAPVLVSSSPFLEASTST--SDATAATATRGSGLGPWGLFLSSRALSSTRPVSLSAGDAPGSSAADHRSILPEDEYHKLADETIHDLLEKLEEYGDSL-QMDGFDIDYGNQVLTLRL-GELGTYVVNKQAPNRQIWLSSPVSGPSRFDWDAP--TNCWIYRRTGANLVELLEKEIGEL-CGTPVELS---------------',\n    'MATASRFLLRKLPRFLKLSPTLLR-------------SNGVRVSSNLIQDSIEPLD--SFWRIGSRIRHDSLTTRSFSS------------------QGPASVDYSSVLQEEEFHKLANFTINHLLEKIEDYGDNV-QIDGFDIDYGNEVLTLKL-GSLGTYVLNKQTPNRQIWMSSPVSGPSRFDWDRD--ANAWIYRRTEAKLHKLLEEELENL-CGEPIQLS---------------',\n    '--MASKLLLQRR-----LFRFLRQ-----------------SQESLYSCSSSSSIQ-RSSFHSTKQTEILGFSTSSRSF-------CSRKSSLVDESNAPAPIDYTSLLQEGEFHRLAESTIHSLQEKFEDYGDFI-DLDGFDIDYANDVLTVKL-GELGTYVLNKQTPNRQLWLSSPVRYFIVYMVFF---------------------------------------------------',\n    '------------------------------------------------------------------------------------------------------------MNDSEFHRLADQLWLTIEERLDDW--DG--DSDIDCEINGGVLTITF-ENGSKIIINRQEPLHQVWLATKQ-GGYHFDLKG----DEWICDRSGETFWDLLEQAATQQ-AGETVSFR---------------',\n    '----------------------------------------------------------------------------------------------------------MAMTDTEFHQLADDMFQAIESAIETAIDEQ--DADVDIDASGNVLQLEF-VDGSKIVINKQEPLHEIWVATRF-GGYHFGFVE----GKWLDGRNGGEFMPFVQDSILRQ-GGIKLSF----------------']\nindices2 = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P']    \nHamming_inicial2 = matrizHamming(Alineamientos,indices2)\nMenor2 = MenorDistancia(Hamming_inicial2)\nprint('Menor: ',Menor2)","8aa38e0c":"Cadenas2 = dict(zip(\"\".join(indices2),Alineamientos))\nNombres2 = dict(zip(\"\".join(indices2),['raton','rata','perro','macaco','hombre','caballo','vaca',\n                                      'chimpance','drosophila','abeja','arroz','arabidopsis',\n                                      'alfalfa','c.elegans','shewandela','E.coli']))\ndisplay(Hamming_inicial2)\nsubArbol(Hamming_inicial2, Cadenas2,Menor2, Nombres2)","7063fda1":"#### Matriz de hamming y hallamos el primer menor","172e99fb":"#### De forma iterativa empezamos a armar el arbol actualizando la matriz de distancias","25724cd2":"### PASO 2: HALLAR MENOR DISTANCIA EN LA MATRIZ","4c156ffe":"### PASO 3 y 4: UNIR LAS SECUENCIAS DE MENOR DISTANCIA EN UN SUB-ARBOL y RECALCULAMOS LA MATRIZ DE DISTANCIAS","cbc8349f":"## Ejemplos\n### Ejemplo 1","9b715dc8":"## ALGORITMO\n### PASO 1: HALLAR MATRIZ DE DISTANCIAS","6e3b3571":"#### De forma iterativa empezamos a armar el arbol actualizando la matriz de distancias","d801be46":"# PR\u00c1CTICA IMPLEMENTACI\u00d3N UPGMA\n```\nDocente: Luis Beltran Palma Ttito\nCurso: Bioinformatica\nAlumno: Jorge Andre Salcedo Hurtado\n```","75c68368":"### Ejemplo 2\n#### Matriz de hamming y hallamos el primer menor"}}