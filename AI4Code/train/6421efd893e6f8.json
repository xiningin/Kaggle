{"cell_type":{"447c7a22":"code","6f6bab4e":"code","97acc6e9":"code","b2a02236":"code","2993a8be":"code","e5ee9633":"code","bbb374a5":"code","4d5f33cd":"code","820b7124":"code","229c527f":"code","afe1b0e6":"code","b0e3ce94":"code","22f548ba":"code","cd760ae6":"code","8b40b071":"code","06f2ab7d":"code","1a27abbd":"code","cafe52fb":"code","dd9d115e":"code","f167c56f":"code","43d45e25":"markdown","6557877b":"markdown","c6d3258c":"markdown","e6033945":"markdown","34dc25b0":"markdown","f6e3d380":"markdown","628ac214":"markdown","04af4d9b":"markdown","257cbbdc":"markdown","7deec03c":"markdown","f68e2e0f":"markdown","610b8132":"markdown","f2faf7b2":"markdown","9dc6c735":"markdown","71021080":"markdown","fcdd2dfc":"markdown","3c4c84da":"markdown","81d06740":"markdown","8ed75526":"markdown","8dd27e83":"markdown","c01d8219":"markdown","ca298101":"markdown","e0808472":"markdown"},"source":{"447c7a22":"import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd","6f6bab4e":"dataset = pd.read_csv('..\/input\/credit-card-applications\/Credit_Card_Applications.csv')","97acc6e9":"dataset.head()","b2a02236":"X = dataset.iloc[: , :-1].values\ny = dataset.iloc[: , -1].values  #We won't be using this value in our training as SOM is an Unsupervised Learning algorithm","2993a8be":"X.shape","e5ee9633":"y.shape","bbb374a5":"from sklearn.preprocessing import MinMaxScaler\n\nsc = MinMaxScaler(feature_range=(0,1)) \nX = sc.fit_transform(X)","4d5f33cd":"! pip install minisom","820b7124":"from minisom import MiniSom","229c527f":"som = MiniSom(x=20 ,y=20 ,sigma=1.0 ,learning_rate=0.5 ,input_len=15)","afe1b0e6":"som.random_weights_init(X)","b0e3ce94":"som.train_random(data=X ,num_iteration=100)","22f548ba":"from pylab import bone, pcolor, colorbar, plot, show\n\nplt.figure(figsize=(17, 10), dpi= 80, facecolor='w', edgecolor='k') # To make the fig bigger \n\npcolor(som.distance_map().T) # This line finds out the mean inter neuron distance and makes a map based on these distances.\n                             # It makes clusters based on the colours based on the distances. The darker the colour the closer the neurons is to it's neighbourhood.\n                             # The lighter neurons are the outliers and if customers are present in it that means they are fradulent.\ncolorbar() # This is the legend of the map","cd760ae6":"plt.figure(figsize=(17, 10), dpi= 80, facecolor='w', edgecolor='k') # To make the fig bigger \npcolor(som.distance_map().T) \n\ncolorbar()\nmarkers = ['o', 's']\ncolors = ['r', 'g']\nfor i, x in enumerate(X):  # Looping through X such as x loops through the rows and i loops through columns of that customer (each attribute of a customer).\n    w = som.winner(x)      # Finding out the winner node of each customer\n    plot(w[0] + 0.5,       # w[0]- x coordinate , w[1] - y coordinate. We are placing the markers at the center of each node\/neuron. That's the whole code inside the plot().\n         w[1] + 0.5,\n         markers[y[i]],\n         markeredgecolor = colors[y[i]],\n         markerfacecolor = 'None',\n         markersize = 10,\n         markeredgewidth = 2)\nshow()","8b40b071":"mappings = som.win_map(X)","06f2ab7d":"mappings.keys()","1a27abbd":"frauds = np.concatenate( (mappings[(16,3)],mappings[(18,3)]) , axis = 0 ) ","cafe52fb":"frauds = sc.inverse_transform(frauds)","dd9d115e":"CustID = frauds[:,0]","f167c56f":"CustID","43d45e25":"Initializing the weights","6557877b":"## Credit Card fraud detection using Self Organising Map ","c6d3258c":"Extracting out all the Customer ID's that are frauds.","e6033945":"We can stop here and find out the customers in the white squares by inverse transforming. And return the data to the bank.\n\nHowever, we have the data of fraud customers decided by bank(y) and we want to compare it with our result. \n\nFor that we will add a feature of 'markers' in our map. These markers will tell us if customer got their credit card approved or not :\n\n1. Red circles - Card approved\n2. Green squares - Card Denied","34dc25b0":"# Here are the fraudulent customers ","f6e3d380":"# Importing the dataset","628ac214":"So here we determined the fradulent customers based on the distance between the neurons.\nThe outlier neurons were the ones which had the maximum mean distance between it's neighbours. And can be seen in lighter shades in the map.","04af4d9b":"I will be using MiniSom implimentation","257cbbdc":"Concatenating all the fraud customers in a nparray.","7deec03c":"**Training the som.** ","f68e2e0f":"These are the co-ordinates of all the mappings done. \n\nOf these we have identified customers of (16,3) and (18,3) as frauds.","610b8132":"# Training the SOM","f2faf7b2":"Scaling back the attributes to find out the customer ID's that are frauds","9dc6c735":"To get all the mappings for all the winning nodes in this SOM. This will be in a form of a dictionary where the key is the co-ordinate of the mapping and the values are all the attributes of customers (corresponding rows of X)","71021080":"Normalizing","fcdd2dfc":"The outlier categories are the frauds. \n\nAs you can see there are 2 outliers categories (white)  at co-ordinates (16,3) and (18,3). Which means under these categories customers are most likely to be frauds.\n\nAs there can be many customers in a category. In both of these categories there are both green square and red circle, which means that some of them got their credit card approved too.","3c4c84da":"# Visualizing the results","81d06740":"We will be plotting such that lighter shades have a higher chance of fraud and darker shades have lower chance.","8ed75526":"# Importing basic libraries","8dd27e83":"# Feature Scaling","c01d8219":"Parameters :\n1. x and y = dimensions of the grid\n2. input_len = No of features in input dataset\n3. sigma = radius of the neighbourhoods\n4. learning_rate = By how much the weiights are updated in each iteration. Higher the value faster the algorithm runs.","ca298101":"# Conclusion","e0808472":"# Finding the frauds"}}