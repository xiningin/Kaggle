{"cell_type":{"903623fa":"code","d7ac05d3":"code","8e0b8189":"code","3a481c4c":"code","bdae3ad9":"code","e27b5a15":"code","5ba9f095":"code","618ce1a0":"code","a0e1c8df":"code","c3b41226":"code","38cf8cb9":"markdown","6e0561e7":"markdown","56dca018":"markdown","6f6613cc":"markdown","5adeee8a":"markdown","1de455ac":"markdown","d5155023":"markdown"},"source":{"903623fa":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport math\nimport os\nimport pickle\nimport h5py\n\n# The official data directory `ciphertext-challenge-ii`\n# and my private directory `cipher`\nprint(os.listdir(\"..\/input\"))\n\nplain = pd.read_csv('..\/input\/ciphertext-challenge-ii\/training.csv')\ncipher = pd.read_csv('..\/input\/ciphertext-challenge-ii\/test.csv')\n\n# Select difficlty 2\nidx = cipher['difficulty'] == 2\ncipher2 = cipher[idx]\n\n# Cipher text -> plain text correspondance\n# private file [secret \ud83d\ude1d]\nwith h5py.File('..\/input\/cipher\/answer2.h5', 'r') as f:\n    answer2 = f['answer2'][:]","d7ac05d3":"# Find out how each character is mapped to cipher character\n# assuming that jth character in plain text is mappted to jth character in cipher\n\nn_cipher = cipher2.shape[0]\ntransition = {}\n\nfor i in range(n_cipher):\n    # knowing which text_plain corresponds to text_cipher\n    text_cipher = cipher2.ciphertext.iloc[i]\n    text_plain = plain.text.iloc[answer2[i]] \n    \n    # remove padding\n    pad = (len(text_cipher) - len(text_plain)) \/\/ 2\n    text_cipher = text_cipher[pad:(pad + len(text_plain))]\n\n    for j, w in enumerate(text_plain):\n        w_cipher = text_cipher[j]\n        if w not in transition:\n            transition[w] = set()\n        transition[w].add(w_cipher)\n        # character w become characeter w_cipher in the cipher text\n\n# 'e' in plain text is mapped to:\ndest_e = transition['e']\nprint('e \u2192 ', dest_e)","8e0b8189":"# Count the frequently of the mapped character\n\ndef count_destination(c_plain):\n    \"\"\"\n    \n    Count the distribution of character that c_plain is mapped to\n    \n    Returns:\n        count (dict): count[c] is the frequency that c_plain is mapped to c\n    \"\"\"\n    count = {}\n\n    n = len(answer2)\n    for i in range(n):\n        i_plain = answer2[i]\n        text_plain = plain.text.iloc[i_plain]\n        text_cipher = cipher2.ciphertext.iloc[i]\n    \n        # remove padding\n        pad = (len(text_cipher) - len(text_plain)) \/\/ 2\n        text_cipher = text_cipher[pad:(pad + len(text_plain))]\n    \n        for j in range(len(text_plain)):\n            if text_plain[j] == c_plain:\n                c = text_cipher[j]\n                if c not in count:\n                    count[c] = 0\n                count[c] += 1\n\n    return count","3a481c4c":"char = 'e'\ncount = count_destination(char)\n\nprint(count)\nx = list(count.keys())\ny = list(count.values())\n\nplt.title(\"'%s' is mapped to\" % char)\nplt.xlabel('character in chiper')\nplt.ylabel('frequency')\nplt.bar(x, y)\nplt.show()","bdae3ad9":"# convert 6 possibilities to integers for 'e'\ndest_number = {'a': 0, 'i':1, 'p':2, 's':3, 'y':4, 'z':5}\n\nn = len(answer2)\nperiod = 8\nreminder = []\npos_plain = []\npos_cipher = []\ndest = []\n\n\n# prepair dictionary for 8 cases of i mod 8\nfor i in range(period):\n    reminder.append({})\n\nfor i in range(n_cipher):\n    text_cipher = cipher2.ciphertext.iloc[i]\n    text_plain = plain.text.iloc[answer2[i]]\n\n    # remove padding\n    pad = (len(text_cipher) - len(text_plain)) \/\/ 2\n    text_cipher = text_cipher[pad:(pad + len(text_plain))]\n\n    for j, w in enumerate(text_plain):\n        if w == 'e':\n            n_cipher = cipher2.shape[0]\ncount = {}\n\ntest = 0\n\nfor i in range(n_cipher):\n    text_cipher = cipher2.ciphertext.iloc[i]\n    text_plain = plain.text.iloc[answer2[i]]\n\n    # remove padding\n    pad = (len(text_cipher) - len(text_plain)) \/\/ 2\n    text_cipher = text_cipher[pad:(pad + len(text_plain))]\n\n    for j, w in enumerate(text_plain):\n        if w == 'e':\n            # character w become characeter w_cipher in the cipher text\n            w_cipher = text_cipher[j]\n\n            location = pad + j # position in cipher text\n            location_plain = j # position in plain text\n            # using the location in the plain text does't change the result\n\n            pos_cipher.append(location) # position of the character in cipher text\n            pos_plain.append(location_plain)\n            dest.append(dest_number[w_cipher]) # character in cipher\n            \n            count = reminder[location % period]\n            \n            if w_cipher not in count:\n                count[w_cipher] = 0\n            count[w_cipher] += 1\n            \npos_plain = np.array(pos_plain)\npos_cipher = np.array(pos_cipher)\ndest = np.array(dest)\n\nfor i in range(period):\n    print(reminder[i])","e27b5a15":"frequency2 = np.zeros((len(dest_e), period))\nfor i, c in enumerate(dest_e): # {'a', 'i', 'p', 's', 'y', 'z'}\n    for j in range(period):\n        frequency2[i, j] = reminder[j][c]\n\nplt.xlabel('character position i mod 8')\nplt.ylabel('cipher character a,i,p,s,y,z')\nplt.imshow(frequency2)\nplt.colorbar()\nplt.show()","5ba9f095":"# The desnination of mapping when the position of 'e' is 95\nidx = pos_plain == 95\n\nplt.title('Distribition when 95th character is e')\nplt.hist(dest[idx], np.arange(7) - 0.5)\nplt.show()\n\nidx = pos_cipher == 95\nplt.title('Distribition when 95th character (with padding) is e')\nplt.hist(dest[idx], np.arange(7) - 0.5)\nplt.show()","618ce1a0":"# Assigning a number to 6 characters\n# 'p' and 'e' have 6 possibilities each\np_to_num = {}\nfor i, c in enumerate(transition['p']):\n    p_to_num[c] = i\n\ne_to_num = {}\nfor i, c in enumerate(transition['e']):\n    e_to_num[c] = i\n    \nprint('p \u2192', p_to_num)\nprint('e \u2192', e_to_num)","a0e1c8df":"n = len(answer2)\n\ncount = np.zeros((len(p_to_num), len(e_to_num)))\n\nfor i in range(n):\n    i_plain = answer2[i]\n    text_plain = plain.text.iloc[i_plain]\n    text_cipher = cipher2.ciphertext.iloc[i]\n    \n    # remove padding\n    pad = (len(text_cipher) - len(text_plain)) \/\/ 2\n    text_cipher = text_cipher[pad:(pad + len(text_plain))]\n    \n    # split text into words, '7' is the space in the cipher\n    words = text_plain.split(' ')\n    words_cipher = text_cipher.split('7')\n    assert(len(words) == len(words_cipher))\n\n    for j, w in enumerate(words):\n        if len(w) >= 2 and w[0] == 'p' and w[1] == 'e': # word starting from pe, e.g. people\n            w_cipher = words_cipher[j]\n            count[p_to_num[w_cipher[0]], e_to_num[w_cipher[1]]] += 1","c3b41226":"plt.title(\"'p' and 'e' become\")\nplt.xlabel('e')\nplt.ylabel('p')\nplt.xticks(np.arange(len(transition['e'])), transition['e'])\nplt.yticks(np.arange(len(transition['p'])), transition['p'])\nplt.imshow(count)\nplt.show()","38cf8cb9":"1. 'e' is not mapped uniformly to {i, y, s, a, p, z}\n2. y, z are exactly twice more frequent than i s a p\n\nWhat kind of algorithms can do this?\n\n* Some classical ciphers use multiple mapping periodically, e.g., *i* mod 6 rule is applied to *i*th character -- if *i*th character is 'e' and *i* = 0 mod 6, then 'e' -> i for example. But then {i, y, s, a, p, z} must appear evenly.\n(*i* mod 6 is the remainder devided by 6; i % 6 in many computer language)\n\n* Another idea is that the rule is selected by the previous character, if previous character is 'a' then 'e' is mapped to 'i', for example. It can be generalized to using nth character on the left. This can explain inhomogenous distribution, but cannot explain the exact 1:2:1:1:2 distribution in the figure.\n\nTrying out with more characters, I find,\n* Some characters are always mapped to 1 character in cipher;\n* when the densination of mapping have 6 candidates, it is always 1:1:1:1:2:2 ratio\n\nThen, how about assuming that rule (*i* **mod 8**) mod 6 is applied to *i*th character? i mod 8 = 0, 6 use rule 0, and i mod 8 1, 7 use rule 1, exaclty twice more frequently than rule 2 3 4 5.","6e0561e7":"I found some nonuniform pattern. For words starting from 'pe', like people, not all 36 patterns appear. \n\n'pe' can become 'qi' or 'qz' in cipher, but not qa, qs, qy, qp. I hope this gives some clue.","56dca018":"The mapping rule does not depend on the character position. There are 6 posibilities even the position is the same. We have to think other rules.","6f6613cc":"# Finding the conversion pattern in difficulty 2\nI am able to match cipher texts in difficulty 2 \u21c4 plain text, but I still can't find out the algorithm how the text is converted to cipher.\n\nUpdates (ver 2): Added a new pattern for word 'people'","5adeee8a":"The mapping is not 1:1 but there are only 6 possibilities","1de455ac":"# Find a pattern in bigram\n\n(Not exactly a bigram, first two characters in words)\n\n","d5155023":"No......, the mapping does not depend on the position of the character mod 8."}}