{"cell_type":{"5475d1dd":"code","f506640c":"code","28190427":"code","46370924":"code","8061e233":"code","bbe9f30b":"code","9c6c6f40":"code","5b42c5a6":"code","dfb90fa6":"code","c7f262e0":"code","d9fa1171":"code","d4d5aec8":"code","913ce04a":"code","19d103b3":"code","cfeae757":"markdown","9ba6045a":"markdown","517c2571":"markdown","d7177f1e":"markdown","f077de6c":"markdown","1ea1d51c":"markdown","0111ecf5":"markdown","ba5b4ed4":"markdown","109300a8":"markdown","4a1b60f2":"markdown","0ca976d5":"markdown","24c48a69":"markdown","32f1dbff":"markdown","bf3fa7f2":"markdown","8df9c8cf":"markdown"},"source":{"5475d1dd":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import rgb2hex\nimport seaborn as sns\nimport os\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nplt.style.use('bmh')","f506640c":"df = pd.read_csv('..\/input\/inverter-data-set\/Inverter Data Set.csv')\ndf.shape","28190427":"df.head()","46370924":"df.describe()","8061e233":"print('Variables at time k:')\nprint(sorted([c for c in df if c.endswith('k')]))\nprint('\\nVariables at time k-1:')\nprint(sorted([c for c in df if c.endswith('k-1')]))\nprint('\\nVariables at time k-2:')\nprint(sorted([c for c in df if c.endswith('k-2')]))\nprint('\\nVariables at time k-3:')\nprint(sorted([c for c in df if c.endswith('k-3')]))\n","bbe9f30b":"corr = df.corr()\n# Generate a mask for the upper triangle\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\nplt.figure(figsize=(14,14))\n_ = sns.heatmap(corr, mask=mask, cmap=cmap, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})","9c6c6f40":"dfui = df  # dataframe under investigation\n# prepare colors\ncolor_list = plt.cm.tab10(np.tile(np.linspace(0, 1, 10), dfui.shape[1])[:dfui.shape[1]])\ncoi = dfui.columns.tolist()  # columns of interest\nfeat_clrs = {k: rgb2hex(color_list[i][:3]) for i, k in enumerate(coi)} if color_list is not None else {}\n\nn_cols = 7\nn_rows = np.ceil(dfui.shape[1] \/ n_cols).astype(int)\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(2.8*n_cols, n_rows*3))\nfor i, (ax, col) in enumerate(zip(axes.flatten(), list(dfui.columns))):\n    sns.distplot(dfui[col], color=feat_clrs[col], ax=ax)\n    if i % n_cols == 0:\n        ax.set_ylabel('Frequency')\nplt.tight_layout()","5b42c5a6":"n_rows = 1\n\ndef plot_scatter_consecutively(coi):\n    fig, axes = plt.subplots(n_rows, len(coi)-1, sharey=True, sharex=True, figsize=(2.8*(len(coi)-1), n_rows*3))\n    if len(coi)-1 > 1:\n        for i, (ax, c) in enumerate(zip(axes.flatten(), coi[1:]), start=1):\n            ax.scatter(df[c], df[coi[i-1]], s=.5)\n            ax.set_xlabel(c)\n            ax.set_ylabel(coi[i-1])\n    else:\n        axes.scatter(df[coi[1]], df[coi[0]], s=.5)\n        axes.set_xlabel(coi[1])\n        axes.set_ylabel(coi[0])\n    fig.tight_layout()\n\ncol_ids = ['u_dc', 'i_a', 'i_b', 'i_c', 'd_a', 'd_b', 'd_c', 'u_a', 'u_b', 'u_c']\ncols_d = {k: [c for c in df if c.startswith(k)] for k in col_ids}\n\nfor k, l in cols_d.items():\n    if len(l) > 1:\n        plot_scatter_consecutively(sorted(l))","dfb90fa6":"x_cols = [c for c in df if c.startswith('d_') and c.endswith('k-2')]\ny_cols = [c for c in df if c.startswith('i_') and c.endswith(('k-2', 'k-1'))]\nfig, axes = plt.subplots(2*n_rows, len(x_cols), sharey=True, sharex=True, figsize=(2.8*len(x_cols), n_rows*3*2))\nfor i, (ax, (c_x, c_y)) in enumerate(zip(axes.flatten(), zip(2*x_cols, y_cols))):\n    ax.scatter(df[c_x], df[c_y], s=.5)\n    if i \/\/ len(x_cols) >= 1:\n        ax.set_xlabel(c_x)\n    ax.set_ylabel(c_y)\n\nfig.tight_layout()","c7f262e0":"current_cols_d = {k: v for k, v in cols_d.items() if k.startswith('i_')}\ndfui = df.sample(1000)  # 1000 random samples\nfig, axes = plt.subplots(n_rows, len(current_cols_d), sharey=True, sharex=True, figsize=(2.8*len(current_cols_d), n_rows*3))\n\nfor i, (ax, (c_id, c_l)) in enumerate(zip(axes.flatten(), current_cols_d.items())):\n    \n    ax.plot(dfui.loc[:, reversed(c_l)].T)\n    ax.set_title(c_id)\n    ax.set_xlabel('time')\n    ax.set_xticklabels([c.split('_')[-1] for c in reversed(c_l)])\n    if i == 0:\n        ax.set_ylabel('currents in A')\nfig.tight_layout()\n","d9fa1171":"transformed_currents_d = {}\nclarke_transform_matrix = 2\/3 * np.array([[1, -0.5, -0.5],\n                                         [0, np.sqrt(3)\/2, -np.sqrt(3)\/2],\n                                         [0.5, 0.5, 0.5]])\nfor k in ['k', 'k-1', 'k-2', 'k-3']:\n    cols = [c for c in df if c.startswith('i_') and c.endswith(k)]\n    phase_currents = df[cols]\n    assert phase_currents.shape[1] == 3\n    transformed_currents =  np.dot(clarke_transform_matrix,  \n                                   phase_currents.T.values)[:-1, :].T  # clarke transform\n    transformed_currents_d[f'i_alpha_{k}'] = transformed_currents[:, 0]\n    transformed_currents_d[f'i_beta_{k}'] = transformed_currents[:, 1]\ndf = df.assign(**transformed_currents_d)","d4d5aec8":"dfui = df[[c for c in df if 'beta' in c or 'alpha' in c]]\nn_cols = 8\nn_rows = np.ceil(dfui.shape[1] \/ n_cols).astype(int)\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(2.8*n_cols, n_rows*3))\nfor i, (ax, col) in enumerate(zip(axes.flatten(), list(dfui.columns))):\n    sns.distplot(dfui[col], ax=ax)\n    if i % n_cols == 0:\n        ax.set_ylabel('Frequency')\nplt.tight_layout()","913ce04a":"time_steps = ['k', 'k-1', 'k-2', 'k-3']\nn_cols = len(time_steps)\nn_rows = 1\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(2.8*n_cols, n_rows*3))\nfor i, (ax, k) in enumerate(zip(axes.flatten(), time_steps)):\n    x_col = f'i_alpha_{k}'\n    y_col = f'i_beta_{k}'\n    ax.scatter(df[x_col], df[y_col], s=0.5)\n    ax.set_xlabel(x_col)\n    ax.set_ylabel(y_col)\n    ax.set_title(f'time step {k}')\n\nplt.tight_layout()","19d103b3":"# heat map\nN_BINS = 100\ncoi = [c for c in df if 'alpha' in c or 'beta' in c]\ndfui = df.assign(**{f'binned_{c}': pd.cut(df[c].values.ravel(), bins=N_BINS, include_lowest=True)\n                   for c in coi})\nts_map = {}\nfor k in time_steps:\n    \n    ts_map[k] = dfui.loc[:, [f'binned_i_alpha_{k}', f'binned_i_beta_{k}', 'i_beta_k']]\\\n                .groupby([f'binned_i_alpha_{k}', f'binned_i_beta_{k}']).count().fillna(0).reset_index()\\\n                .rename(columns={'i_beta_k': 'count'})\\\n                .pivot(index=f'binned_i_beta_{k}', columns=f'binned_i_alpha_{k}', values='count')\\\n                .sort_values(f'binned_i_beta_{k}', ascending=False)\n    \nn_cols = len(time_steps)\nn_rows = 1\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(4*n_cols, n_rows*6))\nfor i, (ax, k) in enumerate(zip(axes.flatten(), time_steps)):\n    sns.heatmap(ts_map[k], robust=True, square=True, yticklabels=49, xticklabels=49, cbar=False, ax=ax)\n    x_col = f'i_alpha_{k}'\n    y_col = f'i_beta_{k}'\n    ax.set_xlabel(x_col+' normalized')\n    ax.set_ylabel(y_col+' normalized')\n    _ = ax.set_xticklabels([-1, 0, 1], rotation=0)\n    _ = ax.set_yticklabels([1, 0, -1])\n    ax.set_title(f'time step {k}')\n\nfig.tight_layout()\n","cfeae757":"We see strong linear correlation between the same signals across the time domain, as expected, while there is zero correlation between the motor speed and all currents, phase voltages, and duty cycles. Same goes for the DC-link voltage and all other signals.\n\nOnly the DC-link voltage to its own past values or to the motor speed show some correlation.","9ba6045a":"It is slightly evident that currents tend to run on the six edges of a hexagon.\nThis is reasonable due to the [inverter voltage limits that can be reached at each phase which are shifted by 120\u00b0](https:\/\/www.switchcraft.org\/learning\/2017\/3\/15\/space-vector-pwm-intro).","517c2571":"## Context\nThe data set comprises several sensor data collected from a typical combined system between an inverter, an induction motor, and a control system, deployed on a test bench. \nTest bench measurements were collected by the [LEA department at Paderborn University](https:\/\/ei.uni-paderborn.de\/en\/lea).\n\nAn inverter is a power electronic component with transistors (read 'switches'), that determine how the battery voltage (so called DC-link voltage) is applied on the three phase circuits of the electric motor.\nThe control unit decides according to some control strategy the current switching states of the inverter at each discrete point in time.\n\n![image.png](attachment:image.png)\n\n## Content\nThe data set comprises approximately 235 thousand samples in the complete operating range of an exemplary drive system.\n\nRows follow no particular order.\n\n\n## Inspiration\nThe most important aspect of an electric vehicle from a marketing and engineering perspective is its efficiency and, thus, achievable range.\nFor this, it is essential to avoid over-dimensioning of the drive train, i.e. applying more and heavier metal packs to increase its thermal capabilities.\nIf the motor is controlled inefficiently through the inverter, there'll be superfluous power losses, i.e. heat build-up, which eventually leads to electric power derating during operation and, crucially, early depletion of the battery.\n\nPrecise phase voltage information is mandatory in order to enable an accurate, efficient or high dynamic control performance of electric motor drives, especially if a torque-controlled operation is considered. However, most electrical drives do not measure the phase voltages online due to their cost implications, and, therefore, these have to be estimated by inverter models. \n\nBecause of various nonlinear switching effects partly at nanosecond scale, an analytical white-box modeling approach is hardly feasible in a control context. \nHence, data-driven inverter models seem favorable for this purpose.\n\nSince the control utilizes [pulse width modulation (PWM)](https:\/\/en.wikipedia.org\/wiki\/Pulse-width_modulation#:~:text=Pulse%2Dwidth%20modulation%20(PWM),it%20up%20into%20discrete%20parts.), the mean phase voltages for each PWM interval are the targets of the inverter models.\n\n![tesla](https:\/\/images.unsplash.com\/photo-1537988489137-33d67a16f3ec?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1489&q=80)\n_(Image Source: [Unsplash.com](https:\/\/unsplash.com\/photos\/87royqk4t6o))_\n\nSee [this paper](https:\/\/www.researchgate.net\/publication\/343480544_Data_Set_Description_Three-Phase_IGBT_Two-Level_Inverter_for_Electrical_Drives) for a detailed research background.","d7177f1e":"A slight positive linear correlation is visible.","f077de6c":"## Distributions","1ea1d51c":"## Time correlation\nLet's explore the scatter between consecutive signals.","0111ecf5":"All variables are continuous and vary significantly in their value range as they pose different units.\n\nEach variable comes with a sub-index k which indicates the point in time: k at present, k-1 the sampling step before that, and so on.\n\nLet's group the variables in time:","ba5b4ed4":"\n## Time series\nLet's explore the time trajectory of the current signals, for which the most consecutive values per row are available.**","109300a8":"In general, four consecutive time steps are captured per row, but not each variable is present at each time step.\n\nParticularly, motor speed __n_k__ is only present at _k_, while phase voltages __u_a\/b\/c__ are only present at _k-1_.\nMoreover, duty cycles __d_a\/b\/c__ appear only in the first time steps _k-3_ and _k-2_.\n\nPresent in all time steps are the phase currents __i_a\/b\/c__ and the DC-link voltage __u_dc__.\n\n## Modeling tasks\nThere are two potential modeling problems that this data set poses:\n\n1. Inverter modeling:\n    Targets: Phase voltages __u_a\/b\/c__ at time _k-1_, Inputs: All remaining features\n2. Inverter compensation scheme:\n    Targets: duty cycles __d_a\/b\/c__ at time _k-2_, Inputs: all remaining features\n    \n    \n## Linear correlations","4a1b60f2":"The high time correlation becomes clear also in these plots. The signals are sampled with $10$ kHz after all.\nAn automatic matching algorithm might find order in the rows to exhibit the three phase sinusoidal signals.","0ca976d5":"The cycling trajectories are characteristic for three-phase currents in stator-fixed coordinates that $alpha$ and $beta$ are.\n\nThe same can be repeated for the phase voltages and the phase duty cycles. No information is lost during these transformations\n\n### Current $alpha$\/$beta$ heat map\n\nBrighter areas are visited more often.","24c48a69":"As expected, the linear correlation is significant between consecutive signals. For the duty cycle it is less strong.\n\nLet's have a look at the phase currents given the duty cyle.","32f1dbff":"# Inverter Data","bf3fa7f2":"## Feature Engineering\n\nUtilizing the fact that the three phases always inherit a 120\u00b0 phase shift, we can condense the phases a\/b\/c into two: $\\alpha$\/$\\beta$.\nThis procedure is also known as the [Clarke-transformation](https:\/\/en.wikipedia.org\/wiki\/Alpha%E2%80%93beta_transformation).","8df9c8cf":"We find:\n* n_k follows around three certain values most of the time,\n* All signals exhibit the same distribution as their past counterparts,\n* __u_dc__ is bi-modal,\n* phase currents __i_a\/b\/c__ seem to be pretty gaussian except for three spikes near the center,\n* duty cycles __d_a\/b\/c__ and phase voltages __u_a\/b\/c__ follow a very similar distribution of symmetrical shape, whereas it is not quite gaussian,\n* there are neglectable differences between the phases a\/b\/c.\n"}}