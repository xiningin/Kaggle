{"cell_type":{"a4871bbd":"code","057d489a":"code","96ad98fb":"code","e9bb882a":"code","be9a2465":"code","30816e97":"code","070f70c6":"code","45ef1f15":"code","49c16f21":"code","0d7db5f4":"code","48b73639":"code","63ecfc72":"code","26125249":"code","4e5e928f":"code","227660a4":"code","95e8fd2f":"code","0a484ff3":"code","69b749d4":"code","ae07c735":"code","d440fabd":"code","f2a6ce9e":"code","9d377c23":"code","4732536a":"code","84873c7a":"code","bb189bc8":"code","7b080b52":"code","d2b7a29a":"code","f333adc1":"code","941e1bb9":"code","cdb48d4e":"code","60cca693":"code","2916dca9":"code","21875823":"code","effc6fc1":"code","be3938bd":"code","001114dc":"code","d1ad4f0b":"code","a8bd85d7":"code","4e49e74f":"code","79b4dce2":"code","bf94dac3":"code","e2d5caa6":"code","195d26db":"code","0bb12b0e":"code","fbcdea48":"code","40e62cd4":"code","af82b622":"code","d722e146":"code","8ae03a37":"code","a6720cf0":"markdown","6163a77a":"markdown","851ddc0a":"markdown","4ba3fe4d":"markdown","d9cd015e":"markdown","c65f2bf6":"markdown","6a465e65":"markdown"},"source":{"a4871bbd":"%reload_ext autoreload\n%autoreload 2\n%matplotlib inline","057d489a":"import time\n\nfrom itertools import groupby\n\nfrom fastai.vision import *\nfrom fastai.callbacks.hooks import *\nfrom fastai.utils.mem import *","96ad98fb":"import fastai; \nfastai.__version__","e9bb882a":"!pwd","be9a2465":"# !ls -R ..\/input\/steel-create-labels\/\n! apt install  -y unzip \n! mkdir -p ..\/labels\/\n! unzip ..\/input\/steel-create-labels\/labels-img.zip -d ..\/labels\/","30816e97":"start = time.time()\npath = Path('..\/input')\npath_lbl = Path('..\/labels')\n\npath_img = path\/'severstal-steel-defect-detection\/train_images'\npath_test = path\/'severstal-steel-defect-detection\/test_images'\n# path_lbl.ls(), path_img.ls()","070f70c6":"fnames = get_image_files(path_img)\nfnames[:3]","45ef1f15":"lbl_names = get_image_files(path_lbl)\nlbl_names[:3]","49c16f21":"img_f = fnames[0]\nimg = open_image(img_f)\nimg.show(figsize=(5,5))","0d7db5f4":"def get_y_fn(x):\n    x = Path(x)\n    return path_lbl\/f'{x.stem}.png'","48b73639":"mask = open_mask(get_y_fn(img_f))\nmask.show(figsize=(5,5), alpha=1)","63ecfc72":"codes = ['0','1','2','3', '4'] # ClassId = codes + 1\nfree = gpu_mem_get_free_no_cache()\nbs = 4\nprint(f\"using bs={bs}, have {free}MB of GPU RAM free\")","26125249":"train_df = pd.read_csv(path\/\"severstal-steel-defect-detection\/train.csv\")\ntrain_df[['ImageId', 'ClassId']] = train_df['ImageId_ClassId'].str.split('_', expand=True)\ntrain_df.head()","4e5e928f":"image_df = pd.DataFrame(train_df['ImageId'].unique())\nimage_df.head()\n# 12k\n# image_df = image_df.iloc[:1000]","227660a4":"name2id = {v:k for k,v in enumerate(codes)}\nvoid_code = 4\nwd=1e-2\n\ndef acc_steel(input, target):\n#     import pdb; pdb.set_trace()\n    target = target.squeeze(1)\n    mask = target != void_code\n    return (input.argmax(dim=1)[mask]==target[mask]).float().mean()\n\ndef dice(pred, targs):\n    pred = (pred>0).float()\n    return 2. * (pred*targs).sum() \/ (pred+targs).sum()\n\ndef iou(input:Tensor, targs:Tensor) -> Rank0Tensor:\n    \"IoU coefficient metric for binary target.\"\n    n = targs.shape[0]\n    input = input.argmax(dim=1).view(n,-1)\n    targs = targs.view(n,-1)\n    intersect = (input*targs).sum().float()\n    union = (input+targs).sum().float()\n    return intersect \/ (union-intersect+1.0)\n\nmetrics = [acc_steel, iou]","95e8fd2f":"size = 256#, 1600\n\ndef no_tfms(self, x, **kwargs): return x\nEmptyLabel.apply_tfms = no_tfms\n\nsrc = (SegmentationItemList.from_df(image_df, path_img,)\n       .split_by_rand_pct(valid_pct=0.2, seed=33)\n       .label_from_func(get_y_fn, classes=codes)\n       .add_test_folder('..\/test_images')\n      )\ndata = (src.transform(get_transforms(flip_vert=True, ), size=size, tfm_y=True)\n       .databunch(bs=bs)\n       .normalize()\n       )","0a484ff3":"print(\"TEST ==> {}\\n VALID ==> {}\\n ==> TRAIN {}\".format(data.test_ds, data.valid_ds, data.train_ds))","69b749d4":"# len(path_test.ls()) # => 1801","ae07c735":"data.show_batch(2, figsize=(20,5))","d440fabd":"data.show_batch(2, figsize=(20,5),ds_type=DatasetType.Valid)","f2a6ce9e":"# learner, include where to save pre-trained weights (default is in non-write directory)\nlearn = unet_learner(data, models.resnet18, metrics=metrics, wd=wd, \n                     model_dir=\"\/kaggle\/working\/models\")\n","9d377c23":"# print(learn.model)","4732536a":"# lr_find(learn)\n# learn.recorder.plot(skip_end=15)","84873c7a":"# Got nan with acc_steel at lr = 1e-3\nlr=3e-4\nepoch = 10\nlearn.fit_one_cycle(epoch, slice(lr), pct_start=0.9)","bb189bc8":"learn.save('stage-1')\nlearn.export(\"\/kaggle\/working\/steel-1.pkl\")","7b080b52":"learn.show_results()","d2b7a29a":"learn.unfreeze()\nlrs = slice(lr\/400,lr\/4)\nlearn.fit_one_cycle(epoch, lrs, pct_start=0.8)\n","f333adc1":"learn.recorder.plot_losses()","941e1bb9":"learn.show_results()","cdb48d4e":"learn.save('stage-2')\nlearn.export(\"\/kaggle\/working\/steel-2.pkl\")","60cca693":"# learn.destroy()\n# free = gpu_mem_get_free_no_cache()\n# # the max size of bs depends on the available GPU RAM\n# if free > 8200: bs=3\n# else:           bs=1\n# print(f\"Using bs={bs}, have {free}MB of GPU RAM free\")","2916dca9":"# data = (src.transform(get_transforms(), size=size, tfm_y=True)\n#         .databunch(bs=bs)\n#         .normalize())","21875823":"# learn = unet_learner(data, models.resnet18, metrics=metrics, wd=wd, model_dir=\"\/kaggle\/working\/models\")\n# learn.load(\"\/kaggle\/working\/models\/stage-2\")","effc6fc1":"# lr_find(learn)\n# learn.recorder.plot()","be3938bd":"# lr=1e-3\n# learn.fit_one_cycle(epoch, slice(lr), pct_start=0.8)","001114dc":"# learn.recorder.plot_losses()","d1ad4f0b":"# learn.recorder.plot_metrics()","a8bd85d7":"# learn.show_results(rows=5, figsize=(20,5))","4e49e74f":"# learn.unfreeze()\n# lrs = slice(1e-6,lr\/10)\n# learn.fit_one_cycle(epoch, lrs)","79b4dce2":"# learn.recorder.plot_losses()","bf94dac3":"# learn.recorder.plot_metrics()","e2d5caa6":"# learn.show_results(rows=5, figsize=(20,5))","195d26db":"# learn.save('stage-2-big')\n# learn.export(\"\/kaggle\/working\/steel-2-big.pkl\")","0bb12b0e":"learn.predict(open_image(\"..\/input\/severstal-steel-defect-detection\/test_images\/38b9631df.jpg\"))[1].data.numpy().flatten()","fbcdea48":"# def get_predictions(path_test, learn):\n#     # predicts = get_predictions(path_test, learn)\n#     learn.model.cuda()\n#     files = list(path_test.glob(\"**\/*.jpg\"))    #<---------- HERE\n#     test_count = len(files)\n#     results = {}\n#     for i, img in enumerate(files):\n#         results[img.stem] = learn.predict(open_image(img))[1].data.numpy().flatten()\n    \n#         if i%20==0:\n#             print(\"\\r{}\/{}\".format(i, test_count), end=\"\")\n#     return results    \n\n# results = get_predictions(path_test, learn)","40e62cd4":"def encode(input_string):\n    return [(len(list(g)), k) for k,g in groupby(input_string)]\n\ndef run_length(label_vec):\n    encode_list = encode(label_vec)\n    index = 1\n    class_dict = {}\n    for i in encode_list:\n        if i[1] != len(codes)-1:\n            if i[1] not in class_dict.keys():\n                class_dict[i[1]] = []\n            class_dict[i[1]] = class_dict[i[1]] + [index, i[0]]\n        index += i[0]\n    return class_dict\n\n# https:\/\/www.kaggle.com\/nikhilikhar\/pytorch-u-net-steel-1-submission\/output#Export-File\ndef get_predictions(path_test, learn):\n    # predicts = get_predictions(path_test, learn)\n    learn.model.cuda()\n    files = list(path_test.glob(\"**\/*.jpg\"))    #<---------- HERE\n    test_count = len(files)\n    results = []\n    for i, img in enumerate(files):\n        img_name = img.stem + '.jpg'\n        pred = learn.predict(open_image(img))[1].data.numpy().flatten()\n        class_dict = run_length(pred)\n        if len(class_dict) == 0:\n            for i in range(4):\n                results.append([img_name+ \"_\" + str(i+1), ''])\n        else:\n            for key, val in class_dict.items():\n                results.append([img_name + \"_\" + str(key+1), \" \".join(map(str, val))])\n            for i in range(4):\n                if i not in class_dict.keys():\n                    results.append([img_name + \"_\" + str(i+1), ''])\n        \n        \n        if i%20==0:\n            print(\"\\r{}\/{}\".format(i, test_count), end=\"\")\n    return results    \n\nsub_list = get_predictions(path_test, learn)\n\n","af82b622":"submission_df = pd.DataFrame(sub_list, columns=['ImageId_ClassId', 'EncodedPixels'])\nsubmission_df.head()","d722e146":"submission_df.to_csv(\"submission.csv\", index=False)","8ae03a37":"end = time.time()\nhours, rem = divmod(end-start, 3600)\nminutes, seconds = divmod(rem, 60)\nprint(\"Execution Time  {:0>2}:{:0>2}:{:05.2f}\".format(int(hours),int(minutes),seconds))","a6720cf0":"# Data","6163a77a":"# Model","851ddc0a":"## Finish of training for part-2\nTraining with new learner is pending. See at, ","4ba3fe4d":"## Finish of training for part-1\nTraining with new learner is pending. See at, ","d9cd015e":"## With fastai.\n\nIssues,\n1. Need more than 9 hr on kaggle p100.\n1. `acc_steel` is nan. Debug it.","c65f2bf6":"We are pre created labels in https:\/\/www.kaggle.com\/nikhilikhar\/steel-create-labels?scriptVersionId=18627876\n\nWe want to access the output directly in this Kernel. We will unzip label mask in `..\/labels`","6a465e65":"https:\/\/forums.fast.ai\/t\/unet-segmentation-mask-converter-to-help-against-common-errors-problems\/42949"}}