{"cell_type":{"f64601e9":"code","1c2fd183":"code","64c9067a":"code","ce06f637":"code","bf34e4bb":"code","f9221ebf":"code","76b681d4":"code","22c1b18f":"code","acb3d316":"code","2e1976cd":"code","17d00f2c":"code","b2f24e1a":"code","4eb8054c":"code","29dd7f12":"code","a2483f6e":"code","8b4f2585":"code","9b348b31":"code","a5e7ef67":"code","da095636":"code","c9c8a5b4":"code","c434dc31":"code","840acc4c":"code","5d1ee179":"code","69b66214":"code","d34dfd28":"code","657e17b9":"code","0339ea03":"code","7494bf83":"code","6e588d9b":"code","f212016a":"code","aa30de7f":"code","670fff6b":"code","9ee00f06":"code","26908953":"code","3513bea6":"code","1c7de16e":"code","38a91894":"code","a7b41a75":"code","9e0708a6":"code","81e722e2":"code","64e0cd2f":"markdown","0ce6dff5":"markdown","d023e361":"markdown","8619c8f1":"markdown","c424a8d7":"markdown","4fc5e60d":"markdown","88763ec3":"markdown","fc92a093":"markdown","950093ce":"markdown","b1c3bea8":"markdown","f01934d0":"markdown","e8c4fe90":"markdown","c4b5de73":"markdown","3dbce70f":"markdown","aff5b2a2":"markdown","a4b97dee":"markdown","072e86e0":"markdown","165f2793":"markdown","2cd8e0be":"markdown","aed2efaf":"markdown","24cc6e6c":"markdown","9202df10":"markdown","e802dc25":"markdown","0601932f":"markdown","ec80829f":"markdown","803c5db3":"markdown","e6d4ccb7":"markdown","a3254311":"markdown","69a16c88":"markdown","02767b9e":"markdown","86e4bc04":"markdown","590b2fc1":"markdown","8509c517":"markdown","d273979a":"markdown","4d98455e":"markdown","e979a76b":"markdown","38e16b31":"markdown","aa127b43":"markdown","7c553cf4":"markdown","85d39cfa":"markdown","b8d1a0ac":"markdown","6c731064":"markdown","7990b97a":"markdown","a14c7f93":"markdown","7fb8b4b3":"markdown"},"source":{"f64601e9":"from datetime import datetime\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport seaborn as sn\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nimport xgboost as xgb\nimport lightgbm as lgb\nimport itertools \nimport calendar\nimport glob\nimport os","1c2fd183":"pd.set_option('display.max_columns', None)\nsn.set_palette(\"rocket\")","64c9067a":"data = pd.read_csv('\/kaggle\/input\/wine-reviews\/winemag-data-130k-v2.csv')","ce06f637":"data.head(2)","bf34e4bb":"data.describe()","f9221ebf":"def missing_data_percentage(column):\n    percentage = (data[column].isna().sum()\/len(data[column])) * 100\n    print('{} column - missing data percentage: {:.2f} %' .format(column, percentage))","76b681d4":"for column in data.columns:\n    missing_data_percentage(column)","22c1b18f":"data.drop([\"region_2\"], axis = 1, inplace=True)","acb3d316":"def fill_na(column):\n    if column.isnumeric():\n        print(data[column])\n        data[column].fillna(data[column].median(), inplace=True)\n    else:\n        data[column].fillna(data[column].mode()[0], inplace=True)","2e1976cd":"for column in data.columns:\n    fill_na(column)\n    missing_data_percentage(column)","17d00f2c":"columns = data.columns\n\nQ1 = data[columns].quantile(0.25)\nQ3 = data[columns].quantile(0.75)\nIQR = Q3 - Q1\n\nprint(\"Q1\")\nprint(Q1)\nprint(\"Q3\")\nprint(Q3)\nprint(\"IQR\")\nprint(IQR)","b2f24e1a":"data.head(1)","4eb8054c":"data.drop([\"taster_name\", \"taster_twitter_handle\"], axis = 1, inplace=True)","29dd7f12":"data","a2483f6e":"corr = data.iloc[:,1:].corr()\ncorr","8b4f2585":"data.head(1)","9b348b31":"sn.countplot(x = data[\"country\"], order = data[\"country\"].value_counts().iloc[:11].index)\nsn.set(rc={'figure.figsize':(30, 10)}, font_scale = 2)","a5e7ef67":"sn.countplot(x = data[\"points\"])","da095636":"sn.countplot(x = data[\"price\"], order = data[\"price\"].value_counts().iloc[:30].index)","c9c8a5b4":"sn.countplot(x = data[\"variety\"], order = data[\"variety\"].value_counts().iloc[:10].index)","c434dc31":"sn.countplot(x = data[\"winery\"], order = data[\"winery\"].value_counts().iloc[:10].index)","840acc4c":"countries = pd.DataFrame(data[\"country\"].replace(\"United States\", \"US\").value_counts())\ncountries = pd.DataFrame(data[\"country\"].replace(\"Georgia\", \"Gruzija\").value_counts()) # using georgia name in another language so that it is not shown as state in the US\ncountries[\"lat\"] = 0\ncountries[\"long\"] = 0","5d1ee179":"#function to get longitude and latitude data from country name\nfrom geopy.geocoders import Nominatim\n\ngeolocator = Nominatim(user_agent = \"my-applications\")\n\ndef geolocate(country):\n    try:\n        # Geolocate the center of the country\n        loc = geolocator.geocode(country)\n        \n        # And return latitude and longitude\n        return (loc.latitude, loc.longitude)\n    except:\n        # Return missing value\n        return np.nan\n\ncountries = countries.reset_index()\n\nfor i,row in countries[\"index\"].iteritems():\n    countries.at[i, [\"lat\", \"long\"]] = geolocate(row)","69b66214":"# Create a world map to show distributions of users \nimport folium\nfrom folium.plugins import MarkerCluster\nfrom folium.features import DivIcon\n\n#empty map\nworld_map = folium.Map(tiles=\"cartodbpositron\")\nmarker_cluster = MarkerCluster().add_to(world_map)\n\n#for each coordinate, create circlemarker of user percent\nfor i in range(len(countries)):\n        lat = countries.iloc[i][\"lat\"]\n        long = countries.iloc[i][\"long\"]\n        radius = 50\n        popup_text = \"\"\"Country : {}<br>\n                    #Reviews : {}<br>\"\"\"\n        popup_text = popup_text.format(countries.iloc[i][\"index\"],\n                                   countries.iloc[i][\"country\"]\n                                   )\n        popup = folium.Popup(popup_text,\n                             width = 100,\n                       height = 100)\n        folium.CircleMarker(location = [lat, long], radius = radius, popup = popup, fill = True).add_to(marker_cluster)\n\n#show the map\nworld_map","d34dfd28":"fig,ax = plt.subplots(1,2,figsize=(16,8))\nax1,ax2 = ax.flatten()\n\nw = data.groupby(['variety'])['price'].max().sort_values(ascending=False).to_frame()[:15]\nsn.barplot(x = w['price'], y = w.index, ax=ax1)\nax1.set_title('The variety used for most expensive wines')\nax1.set_ylabel('Variety')\nax1.set_xlabel('Price')\n\nw = data.groupby(['variety'])['points'].max().sort_values(ascending=False).to_frame()[:15]\nsn.barplot(x = w['points'], y = w.index, ax=ax2)\nax2.set_title('The variety used for best rated wines')\nax2.set_ylabel('')\nax2.set_xlabel('Points')\nplt.subplots_adjust(wspace=0.9);","657e17b9":"f,ax = plt.subplots(1,2,figsize=(16,6))\nax1,ax2 = ax.flatten()\n\nw = data.groupby(['winery'])['price'].max().to_frame().sort_values(by='price',ascending=False)[:15]\nsn.barplot(w['price'],y = w.index,ax = ax1)\nax1.set_title('Wineries with the most expensive wines')\n\nw = data.groupby(['winery'])['points'].max().to_frame().sort_values(by = 'points', ascending = False)[:15]\nsn.barplot(w['points'], y = w.index)\nplt.title('Wineries with the best rated wines')\nplt.subplots_adjust(wspace=0.9)","0339ea03":"from PIL import Image\nfrom wordcloud import WordCloud, STOPWORDS, ImageColorGenerator","7494bf83":"stopwords = set(STOPWORDS)\nnewStopWords = ['fruit', \"Drink\", \"black\", 'wine', 'drink']\nstopwords.update(newStopWords)\n\nwordcloud = WordCloud(\n    stopwords=stopwords,\n    max_words=300,\n    max_font_size=200, \n    width=1000, height=800,\n    random_state=42,\n).generate(\" \".join(data['description'].astype(str)))\n\nprint(wordcloud)\nfig = plt.figure(figsize = (12,14))\nplt.imshow(wordcloud)\nplt.title(\"Word Cloud - Description\",fontsize=25)\nplt.axis('off')","6e588d9b":"wordcloud = WordCloud(\n    background_color='white',\n    stopwords=stopwords,\n    colormap='autumn_r',\n    max_words=300,\n    max_font_size=200, \n    width=1000, height=800,\n    random_state=42,\n).generate(\" \".join(data['variety'].astype(str)))\nprint(wordcloud)\nfig = plt.figure(figsize = (12,14))\nplt.imshow(wordcloud)\nplt.title(\"Word Cloud - Variety\",fontsize=25)\nplt.axis('off')\n","f212016a":"from sklearn import preprocessing\nle = preprocessing.LabelEncoder()\ndata[[\"country_encoded\"]] = data[[\"country\"]].apply(le.fit_transform)","aa30de7f":"#X = data[[\"country_encoded\", \"points\", \"price\"]]\n#X = data[[\"country\", \"points\", \"price\"]]\nX = data","670fff6b":"from sklearn.cluster import KMeans\nwcss = []\n\nfor i in range(1, 6):\n    kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)\n    kmeans.fit(X[[\"points\", \"price\"]])\n    wcss.append(kmeans.inertia_)\n\nplt.plot(range(1, 6), wcss)\nplt.title('The Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.show()","9ee00f06":"kmeans = KMeans(n_clusters = 3, init = 'k-means++', random_state = 42)\n\nclusters = kmeans.fit_predict(X[[\"points\", \"price\"]])","26908953":"X[\"Cluster\"] = clusters","3513bea6":"kmeans.cluster_centers_","1c7de16e":"# Visualising the clusters\n\nplt.scatter(X[X[\"Cluster\"] == 0][\"points\"], X[X[\"Cluster\"] == 0][\"price\"], c = \"red\", s = 500, alpha = 0.5, label = 'Cluster 1')\nplt.scatter(X[X[\"Cluster\"] == 1][\"points\"], X[X[\"Cluster\"] == 1][\"price\"], c = \"blue\", s = 500, alpha = 0.5, label = 'Cluster 2')\nplt.scatter(X[X[\"Cluster\"] == 2][\"points\"], X[X[\"Cluster\"] == 2][\"price\"], c = \"lightblue\", s = 500, alpha = 0.5, label = 'Cluster 3')\n\nplt.title('Wine Reviews')\nplt.xlabel('Points')\nplt.ylabel('Price')\nplt.legend()\nplt.show()","38a91894":"X[\"points_by_price\"] = round(X[\"points\"] \/ X[\"price\"],2)","a7b41a75":"sn.distplot(X[\"points_by_price\"])\nsn.set(rc={'figure.figsize':(20, 10)}, font_scale = 2)","9e0708a6":"X[X[\"Cluster\"] == 0][[\"country\", \"points\", \"price\", \"points_by_price\"]].sort_values(by = \"points_by_price\", ascending = False).head(10)","81e722e2":"X[X[\"Cluster\"] == 0][[\"country\", \"points\", \"price\", \"points_by_price\", \"title\", \"winery\"]].sort_values(by = \"points_by_price\", ascending = False).head(10)","64e0cd2f":"# Creating the Model\n****","0ce6dff5":"We can see that now there are no columns with missing values.","d023e361":"#### Points","8619c8f1":"### Variety vs Price and Points","c424a8d7":"# Importing the Libraries\n****","4fc5e60d":"On the plot, it is visible that country with most reviews is USA with more than 50000 reviews, followed by France and Italy with 20000+ reviews, and Spain and Portugal with 5000+ reviews.","88763ec3":"Taster name and Taster twitter handles are personal information and aren't needed in this analysis, therefore they will be removed:","fc92a093":"The points distribution show that most of the points assigned to the wines are between 87 and 90 points.","950093ce":"#### Building the model with 3 clusters","b1c3bea8":"### Finding the best wines for the smallest price by country","f01934d0":"## Importing The Data\n****","e8c4fe90":"### Visualizing the clusters in 3D space","c4b5de73":"# Data Transformations\n****","3dbce70f":"The columns with more than 50% of missing values will be removed from the dataset: the column with more than 61% of missing values is region_2 column.","aff5b2a2":"It is visible from the cluster plot that there are three clusters: \n* Cluster 1 consisting of data with **lowest** prices of wine\n* Cluster 2 consisting of data with **mid-range** prices of wine\n* Cluster 3 consisting of data with **highest** prices of wine","a4b97dee":"Pearson\u2019s correlation coefficient is the test statistics that measures the statistical relationship, or association, between two continuous variables.\n\nWhen there are two independent variables that are very highly correlated, you definitely should remove one of them because you run into the multicollinearity conundrum and your regression model's coefficients related to the two highly correlated variables will be unreliable.","072e86e0":"#### Country","165f2793":"### Bivariate Data Analysis\n****","2cd8e0be":"The graph shows top 10 most reviewed varieties of wines. Pinot Noir, Chardonnay and Cabernet Sauvignon are the most common varieties of wine.","aed2efaf":"# Dealing with Missing Values\n****","24cc6e6c":"There is **weak** correlation between price and points attributes, meaning they aren't highly correlated and that one of those variables shouldn't be removed.","9202df10":"## KMeans Clustering","e802dc25":"Generally, if the correlation between a pair of variables is greater than 0.5-0.6, we should seriously consider dropping one of those variables.\nWe are selecting the columns which are having absolute correlation greater than 0.8 and making a list of those columns named 'to_drop'.\n\npearson's r = correlation coefficient = r:\n\n0.00-0.19: very weak\n\n0.20-0.39: weak\n\n0.40-0.59: moderate \n\n0.60-0.79: strong\n\n0.80-1.00: very strong","0601932f":"# Looking Into The Data\n****","ec80829f":"###### Visualising the clusters","803c5db3":"# Data Outliers\n****","e6d4ccb7":"#### Price","a3254311":"***Dealing with missing data - using median value for numerical columns and mean value for categorical values***","69a16c88":"# Get the data\n****","02767b9e":"### Variety","86e4bc04":"### Variety and Points","590b2fc1":"The interquartile range (IQR) is a measure of statistical dispersion and is calculated as the difference between the 75th and 25th percentiles.\nIt is represented by the formula IQR = Q3 \u2212 Q1.\nThe lines of code below calculate and print the interquartile range for each of the variables in the dataset","8509c517":"## Explorative Data Analysis\n****","d273979a":"Inside the Cluster 1 with the lowest prices, we are looking at the wines with the highest number of points by price.\n\nCountries with the highest points by price are Romania, US, Spain and Argentina.\n\nNow we will list the wines and wineries that correspond to the data shown above:","4d98455e":"# Clustering of Countries by Wine quality and Prices\n****","e979a76b":"The distribution of prices of wine shows that most wines cost 20.0 price points (16000+), followed by 15.0 and 25.0 price points at 6000 reviews.","38e16b31":"### Winery","aa127b43":"### Count of reviews by country","7c553cf4":"### Univariate Data Analysis\n****","85d39cfa":"# Attributes Correlation\n****","b8d1a0ac":"The optimal number of clusters is 3:","6c731064":"Wines & Winemakers, Testarossa and DFJ Vinhos are three most common wineries shown in the data.","7990b97a":"### Encoding the categorical variable - country","a14c7f93":"Here we combine points and price by dividing points by price to make an number representing the quality of wine divided by the price.","7fb8b4b3":"## Word Clouds\n****"}}