{"cell_type":{"b9f4d32c":"code","bf7d8722":"code","33771fc8":"code","708f768d":"code","a046523a":"code","082f369d":"code","5a41edf6":"code","036945b5":"code","51145402":"code","e6a32c2a":"code","4f453c3f":"code","2270d140":"code","f564b999":"code","5e672a98":"code","46a1db04":"markdown","093dce2b":"markdown","c0a5da1a":"markdown","029c38bf":"markdown","873cb738":"markdown","608345fa":"markdown","ba6f4d0b":"markdown","e0c60075":"markdown","3f0ea9f9":"markdown","0bb74e1d":"markdown","3819609d":"markdown","3fd78adb":"markdown","ae24a059":"markdown"},"source":{"b9f4d32c":"from IPython.display import Image\nprint(\"[Source: https:\/\/www.eweek.com\/enterprise-apps\/organizations-need-to-be-prepared-for-quantum-computing-threats]\")\nImage(\"..\/input\/quantumimage\/qc.jpg\")","bf7d8722":"# installing necessary pakages\n\n!pip install qiskit # Quantum Qiskit Library\n!pip install pylatexenc # Quantum circuit visualization library. More info: https:\/\/github.com\/phfaist\/pylatexenc","33771fc8":"# importing libraries\n\n%matplotlib inline\n\nfrom qiskit import *\nfrom qiskit.visualization import *\nfrom qiskit.tools.monitor import *","708f768d":"Image(\"..\/input\/quantumimage\/QC.png\")","a046523a":"# create a circuit to put a state in superposition and measure it\n\n# define simple circuit with 1 qubit and 1 classical bit for the measure result\nqc = QuantumCircuit(1,1)\n\n# apply the H gate (Hadamard Gate)\nqc.h(0)\n\n# measure the qubit\nqc.measure(range(1),range(1))\n\n# drawing the circuit\nqc.draw(output='mpl')","082f369d":"# printing the QASM code\n\nprint(qc.qasm())","5a41edf6":"# executing the circuit on the local simulator\n\n# choose the backend\nbackend_sim = Aer.get_backend('qasm_simulator') # We choose the backend\n\n# execute the circuit with 1024 shots (repetitions or iterations)\njob_sim = execute(qc, backend_sim, shots=1024)\n\n# collecting the results\nresult_sim = job_sim.result()\n\n# obtain the frequency of each result\ncounts = result_sim.get_counts(qc)\n\n# printing the counts\nprint(counts) \n\n# ploting the counts\nplot_histogram(counts)","036945b5":"# execution to the get the statevector\n\n# define simple circuit with 1 qubit and 1 classical bit for the measure result\nqc2 = QuantumCircuit(1,1)\n\n# apply the H gate (Hadamard Gate)\nqc2.h(0)\n\n# choose the backend as statevector_simulator\nbackend = Aer.get_backend('statevector_simulator') # We change the backend\n\n# executing the circuit\njob = execute(qc2, backend) # Line 1: We execute the circuit with the new simulator. Now, we do not need repetitions\n\n# collecting the results in order to access statevector\nJobResult = job.result() # Line 2\n\n# tetting the statevector\noutputstate = JobResult.get_statevector(qc2) # Line 3\n\n# The above Line 1,2 and 3 can be combined by running following 1 line only\n# outputstate = execute(qc2, backend).result().get_statevector(qc2, decimals=3)\n\n# printing the statevector\nprint(outputstate)\n\n# visual result\nplot_bloch_multivector(outputstate)","51145402":"backend = Aer.get_backend('unitary_simulator') # We change the backend again\n\njob = execute(qc2, backend) # We execute the circuit\n\nresult = job.result() # We collect the results and obtain the matrix\nunitary = result.get_unitary()\nprint(unitary)\n","e6a32c2a":"# Connecting to the real quantum computers\nfrom qiskit import IBMQ\n\n# provider = IBMQ.load_account() # We load our account \n\nIBMQ.save_account('dbb9cbbd6b15f1b1750124a20e7b798a300a066be7e466f27f6ede04a39b723ed79133ed5f944c660e6002e7fa985812cc1108d3e0dae8d7c5d667913c0a0019',overwrite=True)  #save your creds\nIBMQ.load_account()\n\nprovider = IBMQ.get_provider() # We load our account \nprovider.backends() # We retrieve the backends to check their status\n\nfor b in provider.backends():\n    print(b.status().to_dict())","4f453c3f":"# Executing on the IBMQ Experience simulator\n\n# seleting backend\nbackend_sim = provider.get_backend('ibmq_qasm_simulator')\n\n# execute the circuit by providing backend and number of repetitions or 'shots'\njob_sim = execute(qc, backend_sim, shots=1024) \n\n# collecting the results\nresult_sim = job_sim.result() \n\n# Obtain the frequency of each result and we show them\ncounts = result_sim.get_counts(qc)  \n\n# printing counts\nprint(counts) \n\n# shwoing counts on graphs\nplot_histogram(counts)","2270d140":"# Executing the job on the Quantum Computer\n\n# selecting backend. We have selected IBMQ machine: ibmq_santiago\nbackend = provider.get_backend('ibmq_santiago') # selecting IBMQ machine as backend\n\njob_exp = execute(qc, backend=backend) # executing job by providing quantum circuit and IBMQ machine as backend\n\n\njob_monitor(job_exp)","f564b999":"# comparing the results of job running on IBMQ and Simulator\n\n# collecting results of the job\nresult_exp = job_exp.result()\n\n# collecting the counts\ncounts_exp = result_exp.get_counts(qc)\n\n# visualizing results\nplot_histogram([counts_exp,counts], legend=['Device', 'Simulator'])","5e672a98":"print(\"Notebook completed!\")","46a1db04":"Now, we are going to use the quantum computers at the IBM Quantum Experience to use our circuit ","093dce2b":"# Obtain QASM Code\n\nQASM originated as a language for formally defining a quantum circuit to render images for visualization purposes. As quantum computation evolved, the language was adopted as a way to specify quantum circuits as input to a quantum computer.\n\n[Source: https:\/\/www.quantum-inspire.com\/kbase\/cqasm\/]","c0a5da1a":"# Execution of Circuit to get the Statevector\n\nWe can also run the circuit with a simulator that computes the final state. In that case, we need to create a circuit with no measures (shots)","029c38bf":"Finally, we can also obtain the unitary matrix that represents the action of the circuit","873cb738":"# Execute the circuit on simulators\n\nLets run circuit on qasm_simulator.","608345fa":"We can execute the circuit on IBM's quantum simulator (supports up to 32 qubits). We only need to select the appropriate backend.","ba6f4d0b":"# Importing libraries","e0c60075":"# Quantum Computing: Introduction \"Hadamard (H) Gate\"\n\nIn this notebook, I have explained how to begin using Qiskit to define your first simple circuit with Hadamard Gate and to execute it on both simulators and the quantum computers of the IBM Quantum Experience.\n\nIn quantum computing and specifically the quantum circuit model of computation, a quantum logic gate (or simply quantum gate) is a basic quantum circuit operating on a small number of qubits. They are the building blocks of quantum circuits, like classical logic gates are for conventional digital circuits.\n\n![](http:\/\/)[Source: https:\/\/en.wikipedia.org\/wiki\/Quantum_logic_gate]","3f0ea9f9":"# Execute Job on the IBMQ machine\n\nNow we will execute job on one of the real IBMQ computer machine. In that case we only need to select IBMQ machine as backend.\n\nThe *job_monitor* provides live information on the job status, so we will use it.\n\n**Note:**\nWe can select one of following IBMQ machine to execute the job:\n> ibmq_qasm_simulator, ibmqx2, ibmq_16_melbourne, ibmq_vigo, ibmq_ourense, ibmq_valencia, ibmq_armonk, ibmq_athens, ibmq_santiago","0bb74e1d":"# Defining the circuit\n\nWe are going to define a very simple circuit. We will use the $H$ gate (Hadamard Gate) to put a qubit in superposition and then we will measure it","3819609d":"# Installing necessary pakages","3fd78adb":"### H Gate\nA Hadamard gate represents a rotation of $\\pi$ about the axis that is in the middle of the $X$-axis and $Z$-axis.\nIt maps the basis state $|0\\rangle$ to $\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}$, which means that a measurement will have equal probabilities of being `1` or `0`, creating a 'superposition' of states. This state is also written as $|+\\rangle$.\n\n> $H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}\n> 1 & 1 \\\\\n> 1 & -1 \\\\\n> \\end{pmatrix}$","ae24a059":"# Compare the results: IMBQ and Simulator\n\nWhen the job is completed, we can collect the results and compare them to the results we obtained with the simulator."}}