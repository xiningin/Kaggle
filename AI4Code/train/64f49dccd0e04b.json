{"cell_type":{"729d8a56":"code","2b4421c6":"code","f20bc906":"code","ac7a71c5":"code","ef613233":"code","173e867e":"code","85301133":"code","ff1acdb9":"code","5f43074a":"code","ccbfa3f1":"code","f55ed670":"code","fe415cef":"code","11e50073":"code","e8069d73":"code","7b0142be":"code","0c10dfd1":"code","8d780049":"code","2f43cd3a":"code","6053605d":"code","76465a01":"code","c118ce2b":"code","9a949b7a":"code","4997caa6":"code","e2346f3e":"code","364b9571":"code","e0509363":"code","0f6adeb5":"code","664719f0":"code","51d87eea":"code","2157c00b":"code","10f53247":"code","bae3c3e1":"markdown","b6733c2b":"markdown","cbf840cd":"markdown","c0fda748":"markdown","d7f03347":"markdown","003d7b41":"markdown","d65a4863":"markdown","ada50187":"markdown","eae08e04":"markdown","c8d27a6e":"markdown","3c9d0239":"markdown","ae0c7ef6":"markdown","1a2cd2c9":"markdown","daa8db29":"markdown","a48dfb8b":"markdown","288c8e8f":"markdown","5699f931":"markdown","134b8c79":"markdown","4a4b1aef":"markdown","52271a42":"markdown","a1632518":"markdown","7c05be95":"markdown","a806a8b9":"markdown","344c45b8":"markdown","a3a62579":"markdown"},"source":{"729d8a56":"pip install lifelines","2b4421c6":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom scipy import stats\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom lifelines import KaplanMeierFitter\nfrom lifelines.statistics import logrank_test\nfrom lifelines.statistics import multivariate_logrank_test\nfrom lifelines.statistics import pairwise_logrank_test\nfrom lifelines import CoxPHFitter\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","f20bc906":"df = pd.read_csv('\/kaggle\/input\/telecom-churn\/telecom_churn.csv').reset_index()\ndf.head()","ac7a71c5":"df.info()","ef613233":"def countplot(data, title, title_x, annotate_x, palette):\n    \n    '''\n    : param data: categorical data.\n    : param title: chart title.\n    : param title_x: title location by x.\n    : param annotate_x: annotate location by x.\n    : param palette: colors.\n    : return bar chart   \n    '''\n    \n    fig = plt.figure(figsize = (8, 4))\n\n    ax = fig.add_axes([0, 0, 1, 1])\n\n    sns.countplot(\n        y = data,\n        palette = palette,\n        order = data.value_counts().index,\n        edgecolor = 'black',\n        lw = 2)\n\n    sns.despine(bottom = True)\n\n    plt.xticks([])\n    plt.yticks(\n        fontsize = 15,\n        color = 'black',\n        family = 'sans-serif')\n\n    plt.xlabel('')\n    plt.ylabel('')\n\n    for p in ax.patches:\n        width = p.get_width()\n        height = p.get_height()\n        x, y = p.get_xy() \n        ax.annotate('{:.0f}'.format(width), (annotate_x + width, y + height*0.5), ha='center', fontsize=15, color='black', family='sans-serif')\n\n    plt.title(\n        label = title,\n        fontsize = 20,\n        x = title_x,\n        y = 1.1,\n        family = 'sans-serif',\n        fontweight='bold')    \n\n    plt.show()","173e867e":"def stack_hist(categorial_data, data, palette, x_label, title, title_x):\n    \n    '''\n    : param categorial_data: categorical data.\n    : param data: numeric data.\n    : param palette: colors.\n    : param x_label: x_label name.\n    : param title: chart title.\n    : param title_x: title location by x.\n    : return stacked histogram   \n    '''\n    \n    plt.figure(figsize = (13, 6))\n\n    sns.histplot(\n        x=data,\n        hue=categorial_data.astype('str'),\n        palette=palette,\n        multiple='stack',\n        edgecolor='black')\n\n    sns.despine()\n\n    plt.xticks(\n        fontsize=15,\n        color='black',\n        family='sans-serif')\n    plt.yticks(\n        fontsize=15,\n        color='black',\n        family='sans-serif')\n\n    plt.xlabel(\n        xlabel=x_label,\n        fontsize=17,\n        color='black',\n        family='sans-serif',\n        fontweight='bold')\n    plt.ylabel(\n        ylabel='Count',\n        fontsize=17,\n        color='black',\n        family='sans-serif',\n        fontweight='bold')\n\n    plt.title(\n        label=title,\n        fontsize=20,\n        x=title_x,\n        y=1.1,\n        family='sans-serif',\n        fontweight='bold')\n\n    plt.legend([]).set_visible(False)\n\n    plt.show()","85301133":"def stack_bar(data, column_1, column_2, palette, title, title_x):\n    \n    '''\n    : param data: data set.\n    : param column_1: first categorical data.\n    : param column_2: second categorical data.\n    : param palette: colors.\n    : param title: chart title.\n    : param title_x: title location by x.\n    : return stacked bar chart   \n    '''\n    \n    group = data \\\n    .groupby([column_1, column_2],as_index = False) \\\n    .agg({'index' : 'count'}) \\\n    .rename(columns={'index':'count'})\n\n    fig = plt.figure(figsize=(8, 4))\n\n    ax = fig.add_axes([0, 0, 1, 1])\n\n    sns.histplot(\n        x=group.iloc[:,0].astype('str'),\n        hue=group.iloc[:,1],\n        weights=group.iloc[:,2],\n        multiple='stack',\n        ax=ax,\n        palette=palette,\n        shrink=0.8,\n        edgecolor='black',\n        lw=2)\n\n    sns.despine(left=True)\n\n    plt.yticks([])\n    plt.xticks(\n        fontsize = 15,\n        color = 'black',\n        family = 'sans-serif')\n\n    plt.xlabel('')\n    plt.ylabel('')\n\n    plt.legend([]).set_visible(False)\n\n    for p in ax.patches:\n        width, height = p.get_width(), p.get_height()\n        x, y = p.get_xy() \n        ax.text(x+width\/2, \n                y+height\/2, \n                '{:.0f}'.format(height), \n                horizontalalignment='center', \n                verticalalignment='center',\n                fontsize=11,\n                color='white',\n                fontweight='bold',\n                family='sans-serif')\n\n    plt.title(\n        label=title,\n        fontsize=20,\n        x=title_x,\n        y=1.1,\n        family='sans-serif',\n        fontweight='bold')\n\n    plt.show()","ff1acdb9":"def get_bootstrap(data_column_1, data_column_2, boot_it = 1000, statistic = np.mean, bootstrap_conf_level = 0.99):\n\n    '''\n    :param data_column_1: first group\n    :param data_column_2: second group\n    :param boot_it: number of bootstrap subsamples (by default - 1000)\n    :param statistic: statistic (by default - mean)\n    :param bootstrap_conf_level: significance level\n    :return p-value.\n    '''\n    \n    boot_len = max([len(data_column_1), len(data_column_2)])\n    boot_data = []\n    for i in (range(boot_it)): \n        samples_1 = data_column_1.sample(\n            boot_len, \n            replace = True \n        ).values\n        \n        samples_2 = data_column_2.sample(\n            boot_len, \n            replace = True\n        ).values\n        \n        boot_data.append(statistic(samples_1-samples_2)) \n        \n    pd_boot_data = pd.DataFrame(boot_data)\n        \n    left_quant = (1 - bootstrap_conf_level)\/2  \n    right_quant = 1 - (1 - bootstrap_conf_level) \/ 2  \n    ci = pd_boot_data.quantile([left_quant, right_quant]) \n        \n    p_1 = stats.norm.cdf(                 \n        x = 0, \n        loc = np.mean(boot_data), \n        scale = np.std(boot_data)\n    )\n    p_2 = stats.norm.cdf(\n        x = 0, \n        loc = -np.mean(boot_data), \n        scale = np.std(boot_data)\n    )\n    p_value = min(p_1, p_2) * 2       \n    \n    print(f'p-value - {p_value}')","5f43074a":"def chi_2(alpha, data_1, data_2):\n    '''\n    :param alpha: significance level\n    :param data_1: first categorical data\n    :param alpha: second categorical data\n    :return result (reject\/no reject H0)\n    '''\n    print('Test chi2:')\n    alpha = alpha\n    p = stats.chi2_contingency(pd.crosstab(data_1, data_2))[1]\n    if p < 0.05:\n        print('Reject H0')\n    else:\n        print('No reject H0')","ccbfa3f1":"countplot(\n    data=df['Churn'],\n    title='Churn count',\n    title_x=0,\n    annotate_x=110,\n    palette=['#4869D6', '#FF7373'])\n\nprint(f\"Churn percentage - {round(len(df[df['Churn']==1]) \/ len(df)*100, 2)}%\")","f55ed670":"stack_hist(\n    categorial_data=df['Churn'],\n    data=df['AccountWeeks'],\n    palette=['#4869D6', '#FF7373'],\n    x_label='AccountWeeks',\n    title='Duration by churn',\n    title_x=0.1\n    )\nprint(f'''AccountWeeks mean (No Churn) - {round(df[df['Churn']==0]['AccountWeeks'].mean())}\nAccountWeeks mean (Churn) - {round(df[df['Churn']==1]['AccountWeeks'].mean())}''')\nprint()\nprint(f'''std (No Churn) - {round(df[df['Churn']==0]['AccountWeeks'].std())}\nstd (Churn) - {round(df[df['Churn']==1]['AccountWeeks'].std())}''')\nprint()\nget_bootstrap(\n    data_column_1=df[df['Churn']==0]['AccountWeeks'], \n    data_column_2=df[df['Churn']==1]['AccountWeeks'], \n    boot_it = 1000,\n    statistic = np.mean, \n    bootstrap_conf_level = 0.99 \n)","fe415cef":"stack_bar(\n    data=df,\n    column_1='ContractRenewal',\n    column_2='Churn',\n    palette=['#4869D6', '#FF7373'],\n    title='Churn count by renewal contract',\n    title_x=0.35)\n\nchi_2(\n    alpha=0.01,\n    data_1=df['Churn'],\n    data_2=df['ContractRenewal'])","11e50073":"stack_bar(\n    data=df,\n    column_1='DataPlan',\n    column_2='Churn',\n    palette=['#4869D6', '#FF7373'],\n    title='Churn count by DataPlan',\n    title_x=0.2)\n\nchi_2(\n    alpha=0.01,\n    data_1=df['Churn'],\n    data_2=df['DataPlan'])","e8069d73":"stack_hist(\n    categorial_data=df['Churn'],\n    data=df['DataUsage'],\n    palette=['#4869D6', '#FF7373'],\n    x_label='DataUsage',\n    title='DataUsage by churn',\n    title_x=0.1\n    )\nprint(f'''Average datause (No Churn) - {round(df[df['Churn']==0]['DataUsage'].mean(), 2)}\nAverage datause (Churn) - {round(df[df['Churn']==1]['DataUsage'].mean(), 2)}''')\nprint()\nget_bootstrap(\n    data_column_1=df[df['Churn']==0]['DataUsage'], \n    data_column_2=df[df['Churn']==1]['DataUsage'], \n    boot_it = 1000,\n    statistic = np.mean, \n    bootstrap_conf_level = 0.99 \n)","7b0142be":"stack_bar(\n    data=df,\n    column_1='CustServCalls',\n    column_2='Churn',\n    palette=['#4869D6', '#FF7373'],\n    title='Churn count by CustServCalls',\n    title_x=0.35)\n\nchi_2(\n    alpha=0.01,\n    data_1=df['Churn'],\n    data_2=df['CustServCalls'])","0c10dfd1":"stack_hist(\n    categorial_data=df['Churn'],\n    data=df['DayCalls'],\n    palette=['#4869D6', '#FF7373'],\n    x_label='DayCalls',\n    title='DayCalls by churn',\n    title_x=0.1\n    )\nprint(f'''Average daycalls (No Churn) - {round(df[df['Churn']==0]['DayCalls'].mean())}\nAverage daycalls (Churn) - {round(df[df['Churn']==1]['DayCalls'].mean())}''')\nprint()\nprint(f'''std daycalls (No Churn) - {round(df[df['Churn']==0]['DayCalls'].std())}\nstd daycalls (Churn) - {round(df[df['Churn']==1]['DayCalls'].std())}''')\nprint()\nget_bootstrap(\n    data_column_1=df[df['Churn']==0]['DayCalls'], \n    data_column_2=df[df['Churn']==1]['DayCalls'], \n    boot_it = 1000,\n    statistic = np.mean, \n    bootstrap_conf_level = 0.99 \n)","8d780049":"stack_hist(\n    categorial_data=df['Churn'],\n    data=df['MonthlyCharge'],\n    palette=['#4869D6', '#FF7373'],\n    x_label='MonthlyCharge',\n    title='MonthlyCharge by churn',\n    title_x=0.1\n    )\nprint(f'''Average monthlycharge (No Churn) - {round(df[df['Churn']==0]['MonthlyCharge'].mean(), 2)}\nAverage monthlycharge (Churn) - {round(df[df['Churn']==1]['MonthlyCharge'].mean(), 2)}''')\nprint()\nprint(f'''std monthlycharge (No Churn) - {round(df[df['Churn']==0]['MonthlyCharge'].std())}\nstd monthlycharge (Churn) - {round(df[df['Churn']==1]['MonthlyCharge'].std())}''')\nprint()\nget_bootstrap(\n    data_column_1=df[df['Churn']==0]['MonthlyCharge'], \n    data_column_2=df[df['Churn']==1]['MonthlyCharge'], \n    boot_it = 1000,\n    statistic = np.mean, \n    bootstrap_conf_level = 0.99 \n)","2f43cd3a":"stack_hist(\n    categorial_data=df['Churn'],\n    data=df['OverageFee'],\n    palette=['#4869D6', '#FF7373'],\n    x_label='OverageFee',\n    title='OverageFee by churn',\n    title_x=0.1\n    )\nprint(f'''Average overagefee (No Churn) - {round(df[df['Churn']==0]['OverageFee'].mean(), 2)}\nAverage overagefee (Churn) - {round(df[df['Churn']==1]['OverageFee'].mean(), 2)}''')\nprint()\nprint(f'''std overagefee (No Churn) - {round(df[df['Churn']==0]['OverageFee'].std(), 2)}\nstd overagefee (Churn) - {round(df[df['Churn']==1]['OverageFee'].std(), 2)}''')\nprint()\nget_bootstrap(\n    data_column_1=df[df['Churn']==0]['OverageFee'], \n    data_column_2=df[df['Churn']==1]['OverageFee'], \n    boot_it = 1000,\n    statistic = np.mean, \n    bootstrap_conf_level = 0.99 \n)","6053605d":"stack_hist(\n    categorial_data=df['Churn'],\n    data=df['RoamMins'],\n    palette=['#4869D6', '#FF7373'],\n    x_label='RoamMins',\n    title='RoamMins by churn',\n    title_x=0.1\n    )\nprint(f'''Average roammins (No Churn) - {round(df[df['Churn']==0]['RoamMins'].mean(), 2)}\nAverage roammins (Churn) - {round(df[df['Churn']==1]['RoamMins'].mean(), 2)}''')\nprint()\nprint(f'''std roammins (No Churn) - {round(df[df['Churn']==0]['RoamMins'].std(), 2)}\nstd roammins (Churn) - {round(df[df['Churn']==1]['RoamMins'].std(), 2)}''')\nprint()\nget_bootstrap(\n    data_column_1=df[df['Churn']==0]['RoamMins'], \n    data_column_2=df[df['Churn']==1]['RoamMins'], \n    boot_it = 1000,\n    statistic = np.mean, \n    bootstrap_conf_level = 0.99 \n)","76465a01":"plt.figure(figsize=(13,8))\n\nkmf = KaplanMeierFitter()\nkmf.fit(\n    durations=df['AccountWeeks'], \n    event_observed=df['Churn'])\n\nkmf.plot()\n\nplt.vlines(\n    x=kmf.median_survival_time_,\n    ymin=0,\n    ymax=0.8,\n    ls=':',\n    color='crimson',\n    lw=3)\n\nplt.ylim(0,1)\n\nplt.yticks(np.arange(0.1, 1.1, 0.1))\n\nsns.despine()\n\nplt.legend().set_visible(False)\n\nplt.xticks(\n    fontsize=15,\n    color='black',\n    family='sans-serif')\nplt.yticks(\n    fontsize=15,\n    color='black',\n    family='sans-serif')\n\nplt.xlabel(\n    xlabel='AccountWeeks',\n    fontsize=17,\n    color='black',\n    family='sans-serif',\n    fontweight='bold')\nplt.ylabel(\n    ylabel='Percentage',\n    fontsize=17,\n    color='black',\n    family='sans-serif',\n    fontweight='bold')\n\nplt.title(\n    label='Survival function',\n    fontsize=20,\n    x=0,\n    y=1.1,\n    family='sans-serif',\n    fontweight='bold')\n\nplt.show()\n\nprint(f'''50% of customers will refuse services before {int(kmf.median_survival_time_)} weeks''')","c118ce2b":"def surv_func(data, categorial_data, duration, event, title_x):\n\n    '''\n    :param data: data set\n    :param categorial_data: column name with categorical data\n    :param duration: column name with duration\n    :param event: column name with event\n    :param title_x: title location by x\n    :return Survival function.\n    '''\n    \n    median_surv_time_list = []\n    labels = []\n\n    plt.figure(figsize=(13,8))\n    ax = plt.subplot()\n\n    for i in data[categorial_data].unique():\n        kmf = KaplanMeierFitter()\n        kmf.fit(\n            durations=data[data[categorial_data]== i][duration], \n            event_observed=data[data[categorial_data]== i][event],\n            label=f'{i}')\n        kmf.survival_function_.plot(ax=ax)\n        median_surv_time = kmf.median_survival_time_\n        median_surv_time_list.append(median_surv_time)\n        labels.append(i)\n\n    data_median = pd.DataFrame(index=labels, data=median_surv_time_list, columns=['median'])\n\n    plt.xticks(\n        fontsize=15,\n        color='black',\n        family='sans-serif')\n    plt.yticks(\n        fontsize=15,\n        color='black',\n        family='sans-serif')\n\n    plt.xlabel(\n        xlabel=duration,\n        fontsize=17,\n        color='black',\n        family='sans-serif',\n        fontweight='bold')\n    plt.ylabel(\n        ylabel='Percentage',\n        fontsize=17,\n        color='black',\n        family='sans-serif',\n        fontweight='bold')\n\n    plt.title(\n        label=f'Survival function by {categorial_data}',\n        fontsize=20,\n        x=title_x,\n        y=1.1,\n        family='sans-serif',\n        fontweight='bold')\n\n    sns.despine()\n\n    plt.show()\n\n    print(data_median)","9a949b7a":"surv_func(\n    data=df,\n    categorial_data='ContractRenewal',\n    duration='AccountWeeks',\n    event='Churn',\n    title_x=0.1)","4997caa6":"results = logrank_test(\n    durations_A=df[df['ContractRenewal']== 0]['AccountWeeks'],\n    durations_B=df[df['ContractRenewal']== 1]['AccountWeeks'],\n    event_observed_A=df[df['ContractRenewal']== 0]['Churn'],\n    event_observed_B=df[df['ContractRenewal']== 1]['Churn'])\nresults.print_summary()","e2346f3e":"surv_func(\n    data=df,\n    categorial_data='DataPlan',\n    duration='AccountWeeks',\n    event='Churn',\n    title_x=0.1)","364b9571":"results = logrank_test(\n    durations_A=df[df['DataPlan']== 0]['AccountWeeks'],\n    durations_B=df[df['DataPlan']== 1]['AccountWeeks'],\n    event_observed_A=df[df['DataPlan']== 0]['Churn'],\n    event_observed_B=df[df['DataPlan']== 1]['Churn'])\nresults.print_summary()","e0509363":"surv_func(\n    data=df.query('CustServCalls <= 4'),\n    categorial_data='CustServCalls',\n    duration='AccountWeeks',\n    event='Churn',\n    title_x=0.1)","0f6adeb5":"result = multivariate_logrank_test(\n    event_durations=df.query('CustServCalls <= 4')['AccountWeeks'],\n    event_observed=df.query('CustServCalls <= 4')['Churn'],\n    groups=df.query('CustServCalls <= 4')['CustServCalls'])\nresult.print_summary()","664719f0":"result = pairwise_logrank_test(\n    event_durations=df.query('CustServCalls <= 4')['AccountWeeks'],\n    event_observed=df.query('CustServCalls <= 4')['Churn'],\n    groups=df.query('CustServCalls <= 4')['CustServCalls'])\nresult.print_summary()","51d87eea":"df.drop('index', axis=1, inplace=True)\ncoxph = CoxPHFitter(alpha = 0.01)\ncoxph.fit(df, duration_col='AccountWeeks', event_col='Churn')\ncoxph.print_summary()","2157c00b":"plt.figure(figsize = (13, 8))\n\ncoxph.plot()","10f53247":"some_users = df[df['Churn']==1].reset_index().iloc[165:169,:]\nround(coxph.predict_survival_function(some_users, conditional_after=some_users['AccountWeeks']), 4)","bae3c3e1":"The percentage of Churn users is higher among those who do not have an Internet connection.\n\nThe chi-square test showed that the variable has an effect on Churn.","b6733c2b":"Most users have made one request to technical support. Only a small part of users made more than 4 calls to technical support.","cbf840cd":"The differences are statistically significant.\n\n* 50% of customers who did not renew the contract will leave before 136 weeks;\n\n* 50% of clients who have extended the contract will leave before 212 weeks.","c0fda748":"Next features have the significance:\n* ContractRenewal\n* CustServCalls\n* RoamMins","d7f03347":"The worst results among those who made 4 calls in support.","003d7b41":"The test showed us that at least one of the groups is statistically significantly different. To find out between which groups there is a statistically significant difference, I will use pairwise_logrank_test.","d65a4863":"# Survival analysis.","ada50187":"The distribution of the number of minutes per day is close to normal with small outliers. The distribution of Churn users is more variable.\n\nOn average, the Churn users make 1 more call per day, the differences are not statistically significant","eae08e04":"We can also check whether the differences are statistically significant.","c8d27a6e":"The distribution is close to normal.\n\nOn average, the Churn users used more roaming minutes, and the differences are statistically significant.","3c9d0239":"From the data we can see what is the probability that these users will not stop using the service","ae0c7ef6":"For predict let's create data set with some No Churn users","1a2cd2c9":"**Create functions**","daa8db29":"Using Cox regression, it is possible to determine the significance of predictors, how they affect and predict the probability of survival.","a48dfb8b":"On average, Churn users pay more per month, and the differences are statistically significant.","288c8e8f":"Since the level we set is alpha = 0.01, there are statistically significant differences between the following groups:\n* 0 and 4\n* 1 and 4\n* 2 and 4\n* 3 and 4","5699f931":"# Cox","134b8c79":"Since we have 2+ groups, we will apply a multivariate_logrank_test that tests the hypothesis that there is a statistically significant difference for at least one of the groups.","4a4b1aef":"In EDA, I found out that only a small proportion of users made more than 4 calls to technical support. Therefore, to analyze the survival rate and the possibility of interpreting the results, we will take into account only users who have made 4 or fewer requests.","52271a42":"Most users do not exceed 1 GB.\n\nOn average, Churn users use less traffic, and these differences are statistically significant.","a1632518":"The duration distribution is close to normal. The distribution of the No Churn users is more variable.\n\nThe average duration of the No Churn users is less than 2 weeks, but the differences are not statistically significant.","7c05be95":"From the data presented, it can be seen that among users who have the Internet connected, the survival rate has not fallen below ~ 65%.\n\n50% of users who are not connected to the Internet leave before 193 weeks.\n\nThe differences are statistically significant.","a806a8b9":"The Churn ratio among users who did not renew the contract does not differ much (~ 42%). However, the percentage of Churn users among those who extended the contract is significantly less than the share of remaining users.\n\nThe chi-square test showed that the variable has an effect on Churn.","344c45b8":"The distribution is close to normal.\n\nOn average, the Churn users have the highest overpayment for 12 months more, and the differences are statistically significant","a3a62579":"**Columns**:\n* Churn - 1 if customer cancelled service, 0 if not\n* AccountWeeks - number of weeks customer has had active account\n* ContractRenewal - 1 if customer recently renewed contract, 0 if not\n* DataPlan - 1 if customer has data plan, 0 if not\n* DataUsage - gigabytes of monthly data usage\n* CustServCalls - number of calls into customer service\n* DayMins - average daytime minutes per month\n* DayCalls - average number of daytime calls\n* MonthlyCharge - average monthly bill\n* OverageFee - largest overage fee in last 12 months\n* RoamMins - average number of roaming minutes"}}