{"cell_type":{"4100d34e":"code","4384286b":"code","fe6ff755":"code","4d5c5ed0":"code","d6420148":"code","ea1f7492":"code","a0a1aaa0":"code","d525bfb5":"code","0266104c":"code","d8235679":"code","2ca9887f":"markdown","1d4036c9":"markdown","69d8b693":"markdown","b2e4b472":"markdown","3b9389e3":"markdown","4f40a594":"markdown","ee5dabaf":"markdown","fc01a626":"markdown"},"source":{"4100d34e":"import numpy as np\nimport pandas as pd\nimport numba\nfrom sympy import isprime, primerange\nfrom math import sqrt\nfrom sklearn.neighbors import KDTree\nfrom tqdm import tqdm\nfrom itertools import combinations","4384286b":"cities = pd.read_csv('..\/input\/traveling-santa-2018-prime-paths\/cities.csv', index_col=['CityId'])\nXY = np.stack((cities.X.astype(np.float32), cities.Y.astype(np.float32)), axis=1)\nis_not_prime = np.array([0 if isprime(i) else 1 for i in cities.index], dtype=np.int32)","fe6ff755":"@numba.jit('f8(i8, i8, i8)', nopython=True, parallel=False)\ndef cities_distance(offset, id_from, id_to):\n    xy_from, xy_to = XY[id_from], XY[id_to]\n    dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n    distance = sqrt(dx * dx + dy * dy)\n    if offset % 10 == 9 and is_not_prime[id_from]:\n        return 1.1 * distance\n    return distance\n\n\n@numba.jit('f8(i4, i8[:])', nopython=True, parallel=False)\ndef score_chunk(offset, chunk):\n    pure_distance, penalty = 0.0, 0.0\n    penalty_modulo = 9 - offset % 10\n    for path_index in numba.prange(chunk.shape[0] - 1):\n        id_from, id_to = chunk[path_index], chunk[path_index+1]\n        xy_from, xy_to = XY[id_from], XY[id_to]\n        dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n        distance = sqrt(dx * dx + dy * dy)\n        pure_distance += distance\n        if path_index % 10 == penalty_modulo and is_not_prime[id_from]:\n            penalty += distance\n    return pure_distance + 0.1 * penalty\n\n\n@numba.jit('f8(i8[:])', nopython=True, parallel=False)\ndef score_path(path):\n    return score_chunk(0, path)","4d5c5ed0":"kdt = KDTree(XY)","d6420148":"pairs = set()\nfor city_id in tqdm(cities.index):\n    dists, neibs = kdt.query([XY[city_id]], 31)\n    for neib_id in neibs[0][1:]:\n        if city_id and neib_id:  # skip pairs that include starting city \n            pairs.add(tuple(sorted((city_id, neib_id))))\n    neibs = kdt.query_radius([XY[city_id]], 31, count_only=False, return_distance=False)\n    for neib_id in neibs[0]:\n        if city_id and neib_id and city_id != neib_id:\n            pairs.add(tuple(sorted((city_id, neib_id))))\n\nprint(f'{len(pairs)} cities pairs are selected.')\n# sort pairs by distance\npairs = np.array(list(pairs))\ndistances = np.sum((XY[pairs.T[0]] - XY[pairs.T[1]])**2, axis=1)\norder = distances.argsort()\npairs = pairs[order]","ea1f7492":"path = np.array(pd.read_csv('..\/input\/gpu-shuffle-numba-cuda\/submission.csv').Path)\ninitial_score = score_path(path)","a0a1aaa0":"path_index = np.argsort(path[:-1])\n\ntotal_score = initial_score\nprint(f'Total score is {total_score:.2f}.')\nfor _ in range(3):\n    for step, (id1, id2) in enumerate(tqdm(pairs), 1):\n        if step % 10**6 == 0:\n            new_total_score = score_path(path)\n            print(f'Score: {new_total_score:.2f}; improvement over last 10^6 steps: {total_score - new_total_score:.2f}; total improvement: {initial_score - new_total_score:.2f}.')\n            total_score = new_total_score\n        i, j = path_index[id1], path_index[id2]\n        i, j = min(i, j), max(i, j)\n        chunk, reversed_chunk = path[i-1:j+2], np.concatenate([path[i-1:i], path[j:i-1:-1], path[j+1:j+2]])\n        chunk_score, reversed_chunk_score = score_chunk(i-1, chunk), score_chunk(i-1, reversed_chunk)\n        if j - i > 2:\n            chunk_abc = np.concatenate([path[i-1:i+1], path[j:i:-1], path[j+1:j+2]])\n            chunk_acb = np.concatenate([path[i-1:i], path[j:j+1], path[i:j], path[j+1:j+2]])\n            chunk_abcb = np.concatenate([path[i-1:i+1], path[j:j+1], path[i+1:j], path[j+1:j+2]])\n            abc_score, acb_score, abcb_score = map(lambda chunk: score_chunk(i-1, chunk), [chunk_abc, chunk_acb, chunk_abcb])\n            for chunk, score, name in zip((chunk_abc, chunk_acb, chunk_abcb), (abc_score, acb_score, abcb_score), ('abc', 'acb', 'abcb')):\n                if score < chunk_score:\n                    path[i-1:j+2] = chunk\n                    path_index = np.argsort(path[:-1])  # update path index\n                    chunk_score = score\n        if reversed_chunk_score < chunk_score:\n            path[i-1:j+2] = reversed_chunk\n            path_index = np.argsort(path[:-1])  # update path index","d525bfb5":"print(f'Total improvement is {initial_score - total_score:.2f}.')","0266104c":"def make_submission(name, path):\n    pd.DataFrame({'Path': path}).to_csv(f'{name}.csv', index=False)","d8235679":"make_submission(score_path(path), path)","2ca9887f":"3. Define fast scoring functions using numba.","1d4036c9":"I'm going to share simple but working tsp solutions optimization technique.\n\nThe idea is straightforward: if you have two cities in the path that are 'close' (in distance terms) to each other you can try to reverse the order of the path between them hoping that the decrease of the total penalty in this part of the path will be greater than the increase of the length caused by the reversing itself.\n\nAlso instead of just reversing the chunk of the path you can try to play with its ends. This is exactly what is called chunk_abc\/chunk_acb\/chunk_abcb in the code below.","69d8b693":"1. Import all that we need.","b2e4b472":"6. Use optimization described above.","3b9389e3":"4. Precompute close cities pairs using KDTree.","4f40a594":"5. Load the initial path to start optimization from. I'll use the one generated by [this](https:\/\/www.kaggle.com\/nagadomi\/gpu-shuffle-numba-cuda) remarkable kernel.","ee5dabaf":"2. Read input data and define some arrays that we'll need later.","fc01a626":"7. Save the result path."}}