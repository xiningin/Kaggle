{"cell_type":{"c499bc14":"code","c5ba84bb":"code","4ac3ee0f":"code","b223f1ab":"code","6528aa54":"code","601c63c1":"code","48038b8c":"code","d4f8ec3f":"code","9c43d406":"code","3754828c":"code","e85fa4a6":"code","b42810e2":"code","2dd24683":"code","4584a03e":"code","6eb6748a":"code","4aa26e25":"code","9572fb7e":"code","2b1c7d5a":"code","75561a4a":"code","2f9e9129":"code","221f8fa5":"code","802e484f":"code","3594a936":"code","679aa200":"code","19a47c0f":"code","42167a77":"code","122e6352":"code","ba5442a7":"markdown","dee21962":"markdown","43c61998":"markdown","064e3d86":"markdown","2e39ae7e":"markdown","f2acd177":"markdown","e4e44b26":"markdown"},"source":{"c499bc14":"import pandas as pd\nimport numpy as np\nimport cv2 as cv\nimport os\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch import optim\nimport torchvision\nfrom torchvision import transforms\nfrom torch.utils.data import TensorDataset, DataLoader, Dataset, random_split\nfrom torch.utils.data.sampler import SubsetRandomSampler\n\nfrom matplotlib import pyplot as plt\nfrom matplotlib import patches\nplt.style.use(\"ggplot\")\nimport seaborn as sns\n\nimport sklearn\nfrom sklearn.utils import shuffle\nfrom sklearn.metrics import roc_auc_score, accuracy_score\n\nfrom PIL import Image\n\nfrom tqdm import tqdm","c5ba84bb":"oznake = pd.read_csv(\"..\/input\/histopathologic-cancer-detection\/train_labels.csv\")\noznake.head()","4ac3ee0f":"sns.countplot(x=\"label\", data=oznake)\nlabelsCount = oznake[\"label\"].value_counts()\nplt.xticks([0,1], [\"Negativni ({})\".format((oznake.label==0).sum()), \"Pozitivni ({})\".format((oznake.label==1).sum())])\nplt.ylabel(\"Broj primjera\");","b223f1ab":"plt.pie(labelsCount, labels=['Negativno', 'Pozitivno'], startangle=180, \n        autopct='%1.1f', colors=['#FF96A7', '#00ff99'], shadow=True);","6528aa54":"trainPath = \"\/kaggle\/input\/histopathologic-cancer-detection\/train\/\"\ntestPath = \"\/kaggle\/input\/histopathologic-cancer-detection\/test\/\"\n\npozitivniUzorci = oznake.loc[oznake[\"label\"] == 1].sample(20)\nnegativniUzorci = oznake.loc[oznake[\"label\"] == 0].sample(20)\n\nslikePozitivnih = []\nslikeNegativnih = []\n\nfor i in pozitivniUzorci[\"id\"]:\n    path = os.path.join(trainPath, i+\".tif\")\n    slika = cv.imread(path)\n    slikePozitivnih.append(slika)\nfor i in negativniUzorci[\"id\"]:\n    path = os.path.join(trainPath, i+\".tif\")\n    slika = cv.imread(path)\n    slikeNegativnih.append(slika)\n    \nfig,axis = plt.subplots(4,10,figsize=(20,10), dpi=150)\nfig.suptitle(\"Primjeri slika iz dataseta\",fontsize=20)\n\nfor i,elem in enumerate(slikePozitivnih):\n    if i<10:\n        k=0\n    else:\n        k=1\n    axis[k,i%10].imshow(elem)\n    rect = patches.Rectangle((32,32),32,32,linewidth=3,edgecolor=\"lime\",facecolor=\"none\", linestyle=\":\", capstyle=\"round\")\n    axis[k,i%10].add_patch(rect)\n    axis[k,i%10].set_title(\"Pozitivno\")\n    axis[k,i%10].axis(\"off\")\n\nfor i,elem in enumerate(slikeNegativnih):\n    if i<10:\n        k=2\n    else:\n        k=3\n    axis[k,i%10].imshow(elem)\n    rect = patches.Rectangle((32,32),32,32,linewidth=3,edgecolor=\"r\",facecolor=\"none\", linestyle=\":\", capstyle=\"round\")\n    axis[k,i%10].add_patch(rect)\n    axis[k,i%10].set_title(\"Negativno\")\n    axis[k,i%10].axis(\"off\")\n\nplt.show()","601c63c1":"negativni = oznake.loc[oznake[\"label\"] == 0].sample(50000)\npozitivni = oznake.loc[oznake[\"label\"] == 1].sample(50000)\n\nslikeP = []\nslikeN = []\n\nfor i in tqdm(pozitivni[\"id\"], desc=\"Pozitivni\"):\n    path = os.path.join(trainPath, i+\".tif\")\n    slika = cv.imread(path)\n    slikeP.append(slika)\nfor i in tqdm(negativni[\"id\"], desc=\"Negativni\"):\n    path = os.path.join(trainPath, i+\".tif\")\n    slika = cv.imread(path)\n    slikeN.append(slika)\n    \nslikeP = np.array(slikeP)\nslikeN = np.array(slikeN)\n\nbins = 256\n\nfig, axis = plt.subplots(4,2, sharey=True, figsize=(8,8), dpi=150);\n\n#RGB\naxis[0,0].hist(slikeN[:,:,:,0].flatten(), bins=bins, density=True);\naxis[0,1].hist(slikeP[:,:,:,0].flatten(), bins=bins, density=True);\naxis[1,0].hist(slikeN[:,:,:,1].flatten(), bins=bins, density=True);\naxis[1,1].hist(slikeP[:,:,:,1].flatten(), bins=bins, density=True);\naxis[2,0].hist(slikeN[:,:,:,2].flatten(), bins=bins, density=True);\naxis[2,1].hist(slikeP[:,:,:,2].flatten(), bins=bins, density=True);\n\n#sve zajedno\naxis[3,0].hist(slikeN.flatten(), bins=bins, density=True);\naxis[3,1].hist(slikeP.flatten(), bins=bins, density=True);\n\n#opisi\naxis[0,0].set_title(\"Negativni\")\naxis[0,1].set_title(\"Pozitvni\")\naxis[0,1].set_ylabel(\"Red\", rotation=\"horizontal\", labelpad=23, fontsize=12)\naxis[1,1].set_ylabel(\"Green\", rotation=\"horizontal\", labelpad=23, fontsize=12)\naxis[2,1].set_ylabel(\"Blue\", rotation=\"horizontal\", labelpad=23, fontsize=12)\naxis[3,1].set_ylabel(\"Svi\", rotation=\"horizontal\", labelpad=23, fontsize=12)\n\nfor i in range(4):\n    axis[i,0].set_ylabel(\"Relativna frekvencija\", fontsize=8)\naxis[3,0].set_xlabel(\"Pixel\");\naxis[3,1].set_xlabel(\"Pixel\");","48038b8c":"bins = 256 #we use a bit fewer bins to get a smoother image\nfig,axis = plt.subplots(1,2,sharey=True, sharex = True, figsize=(8,2),dpi=150)\naxis[0].hist(np.mean(slikeN,axis=(1,2,3)),bins=bins,density=True);\naxis[1].hist(np.mean(slikeP,axis=(1,2,3)),bins=bins,density=True);\naxis[0].set_title(\"Negativni\");\naxis[1].set_title(\"Pozitivni\");\naxis[0].set_xlabel(\"Svjetlina slike\")\naxis[1].set_xlabel(\"Svjetlina slike\")\naxis[0].set_ylabel(\"Relativna frekvencija\")\naxis[1].set_ylabel(\"Relativna frekvencija\");","d4f8ec3f":"train = shuffle(oznake)","9c43d406":"class Kreiraj(Dataset):\n    def __init__ (self, data, dataPath=\".\/\", transform=None):\n        super().__init__()\n        self.df = data\n        self.dataPath = dataPath\n        self.transform = transform\n        \n    def __len__(self):\n        return len(self.df)\n    \n    def __getitem__(self, index):\n        slikaIme, oznaka = self.df.iloc[index]\n        slikaPath = os.path.join(self.dataPath, slikaIme + \".tif\")\n        slika = cv.imread(slikaPath)\n        if self.transform is not None:\n            slika = self.transform(slika)\n        return slika, oznaka","3754828c":"transformTrain = transforms.Compose([\n    transforms.ToPILImage(),\n    transforms.RandomHorizontalFlip(p=0.7),\n    transforms.RandomVerticalFlip(p=0.7),\n    transforms.RandomRotation(45),\n    transforms.ToTensor()\n])\n\ntransformStart = transformTest = transforms.Compose([\n    transforms.ToPILImage(),\n    transforms.ToTensor(),\n])\n\npocetniData = Kreiraj(data = train, dataPath = trainPath, transform = transformStart)","e85fa4a6":"img,label = pocetniData[10]\nprint(img.shape, torch.min(img), torch.max(img))","b42810e2":"batch = 64\n\nvalSize = 0.2\ntestSize = 0.1\n\nfullLen = len(pocetniData)\nvalLen = int(valSize * fullLen)\nhelpLen = fullLen - valLen\n\ntestLen = int(testSize*helpLen)\ntrainLen = helpLen-testLen\n\n\nhelpSet, valSet = random_split(pocetniData, [helpLen, valLen])\ntrainSet, testSet = random_split(helpSet, [trainLen, testLen])\n\ntrainSet.transform = transformTrain\nvalSet.transform = transformStart\ntestSet.transform = transformStart\n\ntrainLoad = DataLoader(trainSet, batch_size=batch, shuffle=True)\nvalLoad = DataLoader(valSet, batch_size=batch, shuffle=False)\ntestLoadF = DataLoader(testSet, batch_size=batch, shuffle=False)\n\n\nprint(\"Velicina training seta je {}.\".format(trainLen))\nprint(\"Velicina validation seta je {}.\".format(valLen))\nprint(\"Velicina test seta je {}.\".format(testLen))","2dd24683":"sample = pd.read_csv(\"\/kaggle\/input\/histopathologic-cancer-detection\/sample_submission.csv\")\ntestData = Kreiraj(data = sample, dataPath = testPath, transform = transformTest)\n\ntestLoad = DataLoader(testData, batch_size=batch, shuffle=False)","4584a03e":"class Model(nn.Module):\n    \n    def __init__(self):\n        super(Model, self).__init__()\n        self.conv1 = nn.Sequential(\n                nn.Conv2d(in_channels=3,out_channels=32,kernel_size=3,stride=1,padding=0),\n                nn.BatchNorm2d(32),\n                nn.ReLU(inplace=True),\n                nn.MaxPool2d(2,2))\n        self.conv2 = nn.Sequential(\n                nn.Conv2d(in_channels=32,out_channels=64,kernel_size=2,stride=1,padding=1),\n                nn.BatchNorm2d(64),\n                nn.ReLU(inplace=True),\n                nn.MaxPool2d(2,2))\n        self.conv3 = nn.Sequential(\n                nn.Conv2d(in_channels=64,out_channels=128,kernel_size=3,stride=1,padding=1),\n                nn.BatchNorm2d(128),\n                nn.ReLU(inplace=True),\n                nn.MaxPool2d(2,2))\n        self.conv4 = nn.Sequential(\n                nn.Conv2d(in_channels=128,out_channels=256,kernel_size=3,stride=1,padding=1),\n                nn.BatchNorm2d(256),\n                nn.ReLU(inplace=True),\n                nn.MaxPool2d(2,2))\n        self.conv5 = nn.Sequential(\n                nn.Conv2d(in_channels=256, out_channels=512, kernel_size=3, stride=1, padding=1),\n                nn.BatchNorm2d(512),\n                nn.ReLU(inplace=True),\n                nn.MaxPool2d(2,2))\n        \n        self.dropout2d = nn.Dropout2d()\n        \n        self.fc=nn.Sequential(\n                nn.Linear(512*3*3,1024),\n                nn.ReLU(inplace=True),\n                nn.Dropout(0.3),\n                nn.Linear(1024,512),\n                nn.Dropout(0.3),\n                nn.Linear(512, 1),\n                nn.Sigmoid())\n        \n    def forward(self,x):\n        x=self.conv1(x)\n        x=self.conv2(x)\n        x=self.conv3(x)\n        x=self.conv4(x)\n        x=self.conv5(x)\n        x=x.view(x.shape[0],-1)\n        x=self.fc(x)\n        return x","6eb6748a":"train_on_gpu = torch.cuda.is_available()\n\nif not train_on_gpu:\n    print('CUDA nedostupan -> CPU')\nelse:\n    print('CUDA dostupan -> GPU')","4aa26e25":"model = Model()\nprint(model)\n\nif train_on_gpu: model.cuda()","9572fb7e":"ukupnoParametara = sum(elem.numel() for elem in model.parameters() if elem.requires_grad)\nprint(\"Parametri za treniranje: {}\".format(ukupnoParametara))","2b1c7d5a":"lossFunc = nn.BCELoss()\nopt = optim.Adam(model.parameters(), lr=1.5e-4)","75561a4a":"epohe = 20\nminLossVal = np.inf\ntrainLos, valLos, aucEp, valAuc = [],[],[],[]\n\nfor i in range(epohe):\n    trainL = 0\n    valL = 0\n    \n    model.train()\n    for data, oznaka in tqdm(trainLoad, desc=\"Training {}\".format(i+1)):\n        if train_on_gpu:\n            data, oznaka = data.cuda(), oznaka.cuda().float()\n        oznaka = oznaka.view(-1,1)\n        opt.zero_grad()\n        izlaz = model(data)\n        loss = lossFunc(izlaz, oznaka)\n        loss.backward()\n        opt.step()\n        trainL += loss.item()*data.size(0)\n        yTocan = oznaka.data.cpu().numpy()\n        yDobiven = izlaz[:,-1].detach().cpu().numpy()\n        \n    \n    model.eval()\n    with torch.no_grad(): \n        for data, oznaka in tqdm(valLoad, desc=\"Validation {}\".format(i+1)):\n            if train_on_gpu:\n                data, oznaka = data.cuda(), oznaka.cuda().float()\n            oznaka = oznaka.view(-1,1)\n            izlaz = model(data)\n            loss = lossFunc(izlaz, oznaka)\n            valL += loss.item()*data.size(0)\n            yTocan = oznaka.data.cpu().numpy()\n            yDobiven = izlaz[:,-1].detach().cpu().numpy()\n            valAuc.append(roc_auc_score(yTocan, yDobiven))\n    \n    trainL \/= len(trainLoad.sampler)\n    valL \/= len(valLoad.sampler)\n    valAucElem = np.mean(valAuc)\n    aucEp.append(valAucElem)\n    \n    trainLos.append(trainL)\n    valLos.append(valL)\n    \n\n    print(\"Epoha: {}, Training Loss: {}, Validation Loss: {}, Validation AUC: {}\".format(i+1, trainL, valL, valAucElem))\n    \n    if valL <= minLossVal:\n        print(\"Smanjen validation loss: {} -> {}.\".format(minLossVal, valL))\n        torch.save(model.state_dict(), \"best_model.pt\")\n        minLossVal = valL","2f9e9129":"%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nplt.plot(np.arange(1,epohe+1),trainLos, label='Training loss')\nplt.plot(np.arange(1,epohe+1),valLos, label='Validation loss')\nplt.xticks(np.arange(1,epohe+1, 1.0))\nplt.xlabel(\"Epoha\")\nplt.ylabel(\"Loss\")\nplt.legend(frameon=False);","221f8fa5":"%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nplt.plot(np.arange(1,epohe+1),aucEp)\nplt.xticks(np.arange(1,epohe+1, 1.0))\nplt.legend(\"\")\nplt.xlabel(\"Epoha\")\nplt.ylabel(\"AUC\")\nplt.legend(frameon=False);","802e484f":"model.load_state_dict(torch.load('best_model.pt'))","3594a936":"model.eval()\n\npredikcijaT = []\nfor i, (data,oznaka) in tqdm(enumerate(testLoad)):\n    data, oznaka = data.cuda(), oznaka.cuda()\n    izlaz = model(data)\n    \n    pr = izlaz.detach().cpu().numpy()\n    for i in pr:\n        predikcijaT.append(int(i))\n    \nsample[\"label\"] = predikcijaT","679aa200":"sample.to_csv(\".\/submission.csv\", index=False)","19a47c0f":"model.load_state_dict(torch.load('best_model.pt'))","42167a77":"model.eval()\n\npredikcija = []\ntocno = []\nfor i, (data,oznaka) in tqdm(enumerate(testLoadF)):\n    t = oznaka.detach().cpu().numpy()\n    data, oznaka = data.cuda(), oznaka.cuda()\n    izlaz = model(data)\n    \n    pr = izlaz.detach().cpu().numpy()\n    for i,j in zip(pr,t):\n        predikcija.append(i>=0.5)\n        tocno.append(j)","122e6352":"print(\"Preciznost: {:.2f}%\".format(accuracy_score(tocno, predikcija)*100))","ba5442a7":"Test","dee21962":"Raspodjela pixela za svaki kanal zasebno (R, G, B) i zajedni\u010dki prikaz. Za zeleni kanal i pozitivni i negativni imaju tamne pixele, dok za crveni i plavi kanal nemaju. Negativni primjeri, op\u0107enito imaju vi\u0161e svjetlijih pixela od pozitivnih. Jako velika frekvencija pojavljivanja pixela 255 \u0161to zna\u010di da je velik udio bijele boje na slikama.","43c61998":"Na dijelu slika koje se koriste za treniranje modela (ne i validacija) provode se transformacije slike kako bi se izmjenila slika i smanjila prenau\u010denost.","064e3d86":"Velika razlika u distribuciji za pozitivne i negativne primjere. Pozitivni poprimaju oblik normalne distribucije oko vrijednosti 150, a negativni prate oblik bimodalne distribucije s vr\u0161nim vrijednostima oko 140 i 220.","2e39ae7e":"Prikaza odnosa pozitivnih i negativnih primjera iz train seta. Gore je prikaz countplotom, a dolje piechartom.","f2acd177":"Procjena za na\u0161 \"test set\":","e4e44b26":"Prikazano je po 20 primjera za pozitivno i negativno ozna\u010dene primjere iz train seta. Pozitivan primjer je onaj koji ima bar jedan pixel tkiva tumora u centralnom 32x32 prostoru (posebno ozna\u010den)."}}