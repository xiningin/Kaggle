{"cell_type":{"82fa435b":"code","c0d00970":"code","bed19aa1":"code","f97221de":"code","2502b8c4":"code","80b772c1":"code","5515d253":"code","ae374b2d":"code","99d5364b":"code","28523bd1":"code","789b0411":"code","2469f323":"code","2b73e4f2":"code","5262576e":"code","c609a594":"code","bc8e1e77":"code","47b71701":"code","3562c9fe":"code","ba4dc551":"code","15e4e654":"code","97aaad96":"code","8e192265":"code","ac2068bf":"code","42f16802":"code","7972b65b":"code","86583d68":"code","2be80723":"code","9b411ab9":"code","9a5b37ff":"code","319b75e9":"markdown","e09122d9":"markdown","5e05b4d2":"markdown","e48f28c6":"markdown","b2bd34c9":"markdown","8d4ae1ab":"markdown","ac92a5f0":"markdown","5c6a50ef":"markdown","bb988fc2":"markdown","805d80c5":"markdown","30addeff":"markdown","c5453d8c":"markdown","9ee201fc":"markdown","d7ede71d":"markdown","1b2c0518":"markdown"},"source":{"82fa435b":"# Import needed packages\nimport numpy as np\nimport pandas as pd\nimport sklearn as skit\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport html5lib\nimport requests\nimport itertools\nimport ipywidgets as widgets\nfrom ipywidgets import interact, interact_manual\n%matplotlib inline \nmatplotlib.style.use('ggplot')","c0d00970":"# ### 1. Save URLs from 2002 to 2018\n# urls = []\n# for i in range(0, 5):\n#     year = str(2002 + i * 4)\n#     urls.append('https:\/\/www.volby.cz\/pls\/kv{}\/kv1111?xjazyk=CZ&xid=0&xdz=3&xnumnuts=4102&xobec=554961'.format(year))\n    \n# # save tables from URLs to list of Dataframes\n# dfs_list = []\n# for url in urls:\n#     dfs_list.append(pd.read_html(url, flavor='html5lib'))\n    \n# # add Year column to each table and assign their years\n# for i, j in itertools.product(range(0,5), range(0,2)):\n#     dfs_list[i][j][('Year', 'Year')] = 2002 + i * 4\n    \n# # rename not matching column names in the table from 2002\n# for i in range(0, len(dfs_list[0][1].columns)):\n#     if dfs_list[0][1].columns[i] != dfs_list[1][1].columns[i]:\n#         new_col = dfs_list[1][1].columns[i]\n#         old_col = dfs_list[0][1].columns[i]\n#         dfs_list[0][1] = dfs_list[0][1].rename(columns={old_col[0] : new_col[0]}, level=0)\n#         dfs_list[0][1] = dfs_list[0][1].rename(columns={old_col[1] : new_col[1]}, level=1)\n        \n# # tables from 2006 to 2018 have wrong percentages in columns 3 and 6\n# for i in range(1, 5):\n#     dfs_list[i][1].iloc[:,3] = dfs_list[i][1].iloc[:,3] \/ 100\n#     dfs_list[i][1].iloc[:,6] = dfs_list[i][1].iloc[:,6] \/ 100\n    \n# # split list of Dataframes by table types\n# dfs_table1 = []\n# dfs_table2 = []\n# for i, j in itertools.product(range(0,2), range(0,5)):\n#     if i == 0:\n#         dfs_table1.append(dfs_list[j][i])\n#     elif i == 1:\n#         dfs_table2.append(dfs_list[j][i])\n# # concat Dataframes with the same table type\n# df1 = pd.concat(dfs_table1, ignore_index=True)\n# df2 = pd.concat(dfs_table2, ignore_index=True)\n\n# # export Dataframe to csv\n# df2.to_csv('parties.csv', index=False)","bed19aa1":"# ### 1. Save URLs from 2002 to 2018\n# urls = []\n# for i in range(0, 5):\n#     year = str(2002 + i * 4)\n#     urls.append('https:\/\/www.volby.cz\/pls\/kv{}\/kv21111?xjazyk=CZ&xid=0&xv=23&xdz=3&xnumnuts=4102&xobec=554961&xstrana=0&xodkaz=1'.format(year))\n    \n# # save tables from URLs to list of Dataframes\n# dfs_list = []\n# for url in urls:\n#     dfs_list.append(pd.read_html(url, flavor='html5lib'))\n    \n# # add Year column to each table and assign their years\n# for i, j in itertools.product(range(0,5), range(0,2)):\n#     dfs_list[i][j][('Year', 'Year')] = 2002 + i * 4\n    \n# # rename not matching column names in the table from 2002\n# for i in range(0, len(dfs_list[0][1].columns)):\n#     if dfs_list[0][1].columns[i] != dfs_list[1][1].columns[i]:\n#         new_col = dfs_list[1][1].columns[i]\n#         old_col = dfs_list[0][1].columns[i]\n#         dfs_list[0][1] = dfs_list[0][1].rename(columns={old_col[0] : new_col[0]}, level=0)\n#         dfs_list[0][1] = dfs_list[0][1].rename(columns={old_col[1] : new_col[1]}, level=1)\n        \n# # tables from 2006 to 2018 have wrong percentages in columns 3 and 6\n# for i in range(1, 5):\n#     dfs_list[i][1].iloc[:,3] = dfs_list[i][1].iloc[:,3] \/ 100\n#     dfs_list[i][1].iloc[:,6] = dfs_list[i][1].iloc[:,6] \/ 100\n    \n# # split list of Dataframes by table types\n# dfs_table1 = []\n# dfs_table2 = []\n# for i, j in itertools.product(range(0,2), range(0,5)):\n#     if i == 0:\n#         dfs_table1.append(dfs_list[j][i])\n#     elif i == 1:\n#         dfs_table2.append(dfs_list[j][i])\n# # concat Dataframes with the same table type\n# df1 = pd.concat(dfs_table1, ignore_index=True)\n# df2 = pd.concat(dfs_table2, ignore_index=True)\n\n# # export Dataframe to csv\n# df2.to_csv('parties.csv', index=False)","f97221de":"# load the csv files we have prepared in the previous section\ndf_parties = pd.read_csv('..\/input\/parties.csv', header=[0, 1])\ndf_candidates = pd.read_csv('..\/input\/candidates.csv', header=[0, 1])","2502b8c4":"# extract yearly data from both DataFrames and count them\nn_parties = pd.DataFrame(df_parties.iloc[:,9].value_counts(sort=False))\nn_candidates = pd.DataFrame(df_candidates.iloc[:,10].value_counts(sort=False))","80b772c1":"# assign custom column names\nn_parties.columns = ['# of parties']\nn_candidates.columns = ['# of chosen candidates']\n# join these DataFrames\ntmp = pd.concat([n_candidates,n_parties], axis=1)","5515d253":"# plot\nax = tmp.plot(kind='bar', title='Number of parties and chosen candidates throughout the years')\nax.set_xlabel('Year')","ae374b2d":"# get candidates by party throughout the years\nparty_col = df_candidates.iloc[:,1]\n@interact\ndef plot_number_of_candidates_by_party(party= party_col.unique()):\n    # get candidates and years column names\n    candidates_col_name = df_parties.columns[4]\n    years_col_name = df_parties.columns[9]\n    # pull out needed data into temporal DataFrame\n    tmp = df_parties[df_parties.iloc[:, 1] == party][[candidates_col_name, years_col_name]].set_index(years_col_name)\n    # rename column\n    tmp.columns = ['# of candidates']\n    # plot DataFrame\n    ax = tmp.plot(kind='bar', title='Number of \\\"{}\\\" candidates throughout the years'.format(party))\n    ax.set_xlabel('Year')","99d5364b":"# age structure overall\nage_col = df_candidates.iloc[:,4]\nax = age_col.plot(kind='hist', title='Age structure overall')\nax.set_xlabel('Age')","28523bd1":"# age structure by party\nparty_col = df_candidates.iloc[:,1]\n@interact\ndef plot_age_structure_by_party(party=party_col.unique()):\n    ax = df_candidates[party_col == party].iloc[:,4].plot(kind='hist', title=party)\n    ax.set_xlabel('Age')","789b0411":"# group age structure data by year and plot them each seperately\nyear_col = df_candidates.iloc[:,10]\nyear_groups = df_candidates.iloc[:,[4,10]].groupby(df_candidates.columns[10])\nfor group in year_groups:\n    group[1].columns = ['Candidate ages', '']\n    group[1].set_index(group[1].columns[1]).plot(kind='hist', title=group[0])","2469f323":"party_col = df_parties.iloc[:, 1]\n@interact\ndef plot_votes_by_party(party= party_col.unique()):\n    tmp = df_parties[party_col == party].iloc[:,[9, 2]]\n    # rename column since plotting writes a multilevel index badly\n    tmp.columns = ['Year', 'Votes']\n    # set year data as index for xaxis \n    tmp = tmp.set_index(tmp.columns[0])\n    # delete whitespaces in numbers for conversion\n    tmp[tmp.columns[0]] = tmp[tmp.columns[0]].str.replace(\"\\s+\", \"\")\n    # convert values to number so we can plot\n    tmp[tmp.columns[0]] = pd.to_numeric(tmp[tmp.columns[0]])\n    tmp.plot(kind='bar', title=party)","2b73e4f2":"# split data by title\nhas_title = df_candidates[df_candidates.iloc[:,3].str.contains('\\.')]\nno_title = df_candidates[~df_candidates.iloc[:,3].str.contains('\\.')]","5262576e":"# put counted data into a new dataframe for concat\na = pd.DataFrame(has_title.iloc[:,10].value_counts(sort=False))\nb = pd.DataFrame(no_title.iloc[:,10].value_counts(sort=False))\n# rename columns\na.columns = ['with title']\nb.columns = ['no title']","c609a594":"# concat both dataframes and plot\npd.concat([a, b], axis=1).plot(kind='bar', title='Candidates with a title vs candidates without one')","bc8e1e77":"# define title categories\nbachelor_titles = ['Bc.']\nmaster_titles = ['Ing.', 'Ing. arch.', 'MUDr.', 'MDDr.', 'MVDr.', 'MgA.', 'Mgr.']\ndoc_titles = ['Ph.D.', 'JUDr.', 'PhDr.', 'RNDr.', 'CSc.']","47b71701":"# extract only needed columns\nhas_title = has_title.iloc[:,[3,10]]","3562c9fe":"# helper function to find atleast one match between two arrays\n# return true if found, false otherwise\ndef match_atleast_one(a, b):\n    return len([x for x in a if x in b]) != 0","ba4dc551":"# define variables\noutput = pd.DataFrame(columns=['year', 'bachelors', 'masters', 'doctors', 'non academic title', 'women', 'men'])\nbachelors = masters = doctors = others = women = men = 0\nyear = 2002\n# iterate through each line (candidate)\nfor i in has_title.itertuples():\n    # if year changed, append counted data into output DataFrame\n    if i[2] != year:\n        output = output.append(dict({'year': year, 'bachelors': bachelors, 'masters': masters, 'doctors': doctors, 'non academic title': others, 'women': women, 'men': men}), ignore_index=True)\n        # assign new year and reset output variables\n        year = i[2]\n        bachelors = masters = doctors = others = women = men = 0\n    # tokenize each name of a candidate\n    tokens = i[1].split()\n    titles = []\n    names = []\n    # exctarct only title tokens\n    for t in tokens:\n        if '.' in t:\n            titles.append(t)\n        else:\n            names.append(t)\n    # if candidate is a woman, first name ends with 'a'\n    if names[-1][-1] == 'a':\n        women += 1\n    else:\n        men += 1\n    # clasify candidate by titles\n    # need to check every title since some have f.e. bachelors and masters in name and we want to classify them as master only\n    if match_atleast_one(titles, doc_titles):\n        doctors += 1\n        continue\n    elif match_atleast_one(titles, master_titles):\n        masters += 1\n        continue\n    elif match_atleast_one(titles, bachelor_titles):\n        bachelors += 1\n        continue\n    else:\n        others += 1\n# append output variables again at the end for the last year\noutput = output.append(dict({'year': year, 'bachelors': bachelors, 'masters': masters, 'doctors': doctors, 'non academic title': others, 'women': women, 'men': men}), ignore_index=True)","15e4e654":"# plot title types\noutput.set_index('year').iloc[:,0:4].plot(kind='bar')","97aaad96":"# plot num. of women\/men\noutput.set_index('year').iloc[:,[4,5]].plot(kind='bar')","8e192265":"# extract needed data\ndata = df_candidates.iloc[:,[3, 6, 7]].copy()\n# rename columns\ndata.columns = ['name', 'party', 'votes']","ac2068bf":"# votes column contain numbers with different whitespaces\n# thus we delete whitespaces and retype to int\nintvotes = data.votes.str.replace('\\s', '').astype(int)","42f16802":"# put int votes into Dataframe\ndata.votes = intvotes.values","7972b65b":"# delete titles from data as some cadidates might have gotten a new title between elections\n# there are also different whitespaces mixed in, so we replace every whitespace by a normal one since names might not match\n# str.strip() for stripping any leading and trailing whitespaces\nfiltered_titles = data.name.str.replace(r'[A-z]+?\\.', r'').str.replace(r'\\s', r' ').str.strip()","86583d68":"# put filtered column in main Dataframe\ndata.name = filtered_titles.values","2be80723":"# count occurances and choose top 10 candidates\ntop10 = data.iloc[:,0].value_counts().head(10)\ntop10.plot(kind='bar', title='Candidates by participation in elections')","9b411ab9":"# put top 10 names into an array\ntop10 = top10.index.values","9a5b37ff":"# group by party and name and sum their votes\ndata[data.name.isin(top10)].groupby(['party', 'name']).sum()","319b75e9":"## 2.7 Most active candidates","e09122d9":"### 2.6.2 Categorize by sex","5e05b4d2":"# 2. Data visualisation","e48f28c6":"## 2.4 Vote count","b2bd34c9":"## 2.1 Number of parties vs number of chosen candidates","8d4ae1ab":"This work contains simple data scrapping, processing and visualization on two datasets from the Czech political party election.","ac92a5f0":"## 1.2 Scrapping data of candidates\nDone similarly to the previous section. Again, I will leave the code for refference.","5c6a50ef":"# 1. Webscrap data from the official Czech elections website\nWe will only use data from the years: 2002, 2006, 2010, 2014 and 2018 for this work, aiming for two datasets: data of political **parties** and data of chosen **candidates**.","bb988fc2":"## 2.2 Number of candidates for a party","805d80c5":"## 2.6 Categorizing candidates by titles and sex\n### 2.6.1 Categorize by title","30addeff":"### 2.3.3 Age structure by year","c5453d8c":"## 2.3 Age structure of candidates\n### 2.3.1 Age structure overall","9ee201fc":"## 1.1 Scrapping data of parties\nAs you cannot scrap data on a kaggle notebook, I ran the code on my personal machine and uploaded the needed csv files. I'll only leave the code I've used for the reader to see how it was done.","d7ede71d":"## 2.5 Candidates with title vs without title","1b2c0518":"### 2.3.2 Age structure by party"}}