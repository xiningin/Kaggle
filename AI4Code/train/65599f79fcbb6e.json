{"cell_type":{"e7e6d714":"code","df34b5a4":"code","db566377":"code","2769540e":"code","60fa19e9":"code","b2647e35":"code","843b0490":"code","7d9dbf4d":"code","670a1ad1":"code","a9828e72":"code","8ee7d1b9":"code","9f0f7c98":"code","113fda8e":"code","68551c06":"code","4fa6eaea":"code","e1c479ec":"code","edb2e157":"code","193a2672":"code","6ce83482":"code","e9d9f63c":"code","648a6391":"code","4597c5b7":"code","ae3766c4":"code","90d4d02c":"code","778fc205":"code","cd79474f":"code","5259f112":"code","9f2f036b":"code","3733d0a5":"markdown","300150eb":"markdown","2126b70b":"markdown","dcefa32d":"markdown","da9f0280":"markdown","10037da2":"markdown","a9a4e06d":"markdown","c8f1ba2d":"markdown","6d1275e2":"markdown","582479b5":"markdown","98508731":"markdown","371eb4e0":"markdown","7b96b866":"markdown","8fce2127":"markdown","5be2c98d":"markdown","d62d96ac":"markdown","273b8e01":"markdown","4f69ac4b":"markdown","009f2c85":"markdown","ef211ecf":"markdown","29028804":"markdown","2b2827ad":"markdown","380009c2":"markdown","3460fc4d":"markdown","5dbb3ca6":"markdown","a79162da":"markdown","b2545874":"markdown","2de0d510":"markdown","f27eaee7":"markdown","691f4a05":"markdown","78727384":"markdown","61ec575d":"markdown","3a76f286":"markdown","78acf3c9":"markdown","a3fffda9":"markdown","e9a524b9":"markdown","8599965e":"markdown","d11cfd4c":"markdown","7913fb27":"markdown","edf55a3f":"markdown","ca3c6b1c":"markdown","3b377081":"markdown"},"source":{"e7e6d714":"from IPython.display import Image # Image modul\u00fcn\u00fc projeye dahil edilir.\nImage(\"..\/input\/knnimage\/mantar.png\") # Image fonksiyonuna resmin dosya yolu verilir.","df34b5a4":"import numpy as np # Kullan\u0131lacak olan dizi, matris veya vekt\u00f6r gibi lineer cebir ara\u00e7lar\u0131 i\u00e7in gerekli olacakt\u0131r.\nimport pandas as pd # Veriyi d\u00fczenlemek, veriyi y\u00fcklemek ve bir dataframe yap\u0131s\u0131nda veriyi daha kolay incelemek i\u00e7in gerekli olacakt\u0131r.\n","db566377":"data=pd.read_csv(\"..\/input\/mushrooms.csv\")","2769540e":"mframe=pd.DataFrame(data)","60fa19e9":"mframe.head(10)","b2647e35":"mframe.tail()","843b0490":"print(mframe.columns)","7d9dbf4d":"# Veri seti i\u00e7erisinde yer alan \"cap-shape\",\"population\",\"class\" kolonlar\u0131n\u0131n ilk 5 de\u011feri getirilir.\n\nprint(mframe[\"cap-shape\"].head()) \nprint(mframe[\"population\"].head())\nprint(mframe[\"class\"].head()) ","670a1ad1":"Image(\"..\/input\/knnimage\/knn.png\")","a9828e72":"Image(\"..\/input\/knnimages\/uzaklikfonk.png\")","8ee7d1b9":"X=mframe.iloc[:,1:] # \"class\" kolonu d\u0131\u015f\u0131ndaki t\u00fcm kolonlar girdi de\u011feri olarak tan\u0131mland\u0131. Ne kadar \u00e7ok birbiriyle alakal\u0131 girdi kolonu kullan\u0131l\u0131rsa \u00e7\u0131kt\u0131n\u0131n tahmini o kadar y\u00fcksek do\u011frulukta \u00e7\u0131kacakt\u0131r.\n\ny=mframe.iloc[:,0]  # \"class\" kolonu \u00e7\u0131kt\u0131 de\u011feri olarak tan\u0131mland\u0131. \u00c7\u00fcnk\u00fc class kolonu i\u00e7erisindeki kategori tahmin edilecek.","9f0f7c98":"from sklearn.preprocessing import LabelEncoder\nfrom collections import defaultdict\n\nd=defaultdict(LabelEncoder)\n\nXFit=X.apply(lambda x: d[x.name].fit_transform(x))\n\nLEncoder=LabelEncoder()\n\nyFit=LEncoder.fit_transform(y)","113fda8e":"import warnings # Uyar\u0131lar\u0131n y\u00f6netimi i\u00e7in kullan\u0131lan k\u00fct\u00fcphanedir.\n\nwarnings.filterwarnings(\"ignore\") # \u00c7\u0131kacak uyar\u0131lar\u0131n g\u00f6zard\u0131 edilmesi i\u00e7in kullan\u0131l\u0131r.\n\nfrom sklearn.preprocessing import OneHotEncoder\nohc=defaultdict(OneHotEncoder)\n\nresultFrame=pd.DataFrame()\n\nkolonSayisi=mframe.shape[1]\n\nfor i in range(kolonSayisi-1):\n    \n    Xtemp_i=pd.DataFrame(ohc[XFit.columns[i]].fit_transform(XFit.iloc[:,i:i+1]).toarray())\n    \n    ohc_obj=ohc[XFit.columns[i]]\n    LEncoder_i=d[XFit.columns[i]]\n    Xtemp_i.columns=XFit.columns[i]+ \"_\" + LEncoder_i.inverse_transform(ohc_obj.active_features_)\n    \n    \n    X_ohc_i=Xtemp_i.iloc[:,1:]\n    \n    resultFrame=pd.concat([resultFrame,X_ohc_i],axis=1)","68551c06":"print(mframe.shape,\"->\",resultFrame.shape) # Yeni veri setinin boyutu\n\n# Bir kolonda yer alan kategoriler i\u00e7in ayr\u0131 ayr\u0131 kolonlar olu\u015fturulmu\u015f dolay\u0131s\u0131yla veri setinin boyutu artm\u0131\u015ft\u0131r.","4fa6eaea":"resultFrame.head(10) # Haz\u0131rlanan yeni veri setinden \u00f6rnek al\u0131nmas\u0131.","e1c479ec":"from sklearn.model_selection import train_test_split # E\u011fitim ve Test verilerini ay\u0131rmak i\u00e7in kullan\u0131lan fonksiyondur.\n\nX_train, X_test, y_train, y_test=train_test_split(resultFrame,yFit,test_size=0.3) # Test Verisi %30 E\u011fitim Verisi %70 olarak atand\u0131.","edb2e157":"from sklearn.neighbors import KNeighborsClassifier # KNN Algoritmas\u0131n\u0131n mod\u00fcl\u00fc projeye dahil edildi.\n\nKModel=KNeighborsClassifier(n_neighbors=30,metric=\"minkowski\") # KNN Modeli kuruldu ve k kom\u015fuluk say\u0131s\u0131 30 olarak al\u0131nd\u0131. Yani s\u0131n\u0131fland\u0131r\u0131lacak olan verinin 30 eleman kom\u015fulu\u011funa bakara karar verir. \n# E\u011fer herhangi bir uzakl\u0131k metri\u011fi verilmez ise algoritma \"minkowski\" uzakl\u0131\u011f\u0131na g\u00f6re uzakl\u0131k hesaplayacakt\u0131r. Burada da minkowski uzakl\u0131k metri\u011fi kullan\u0131lm\u0131\u015ft\u0131r.\n\nKModel.fit(X_train,y_train) # KNN algoritmas\u0131 ayarlanan E\u011fitim verileri \u00fczerinde uyguland\u0131 ve model \"E\u011fitildi\"\n\ny_pred=KModel.predict(X_test) # Uygulanan model i\u00e7in Test verileri tahmin edildi.","193a2672":"Image(\"..\/input\/knnimages\/uzaklikfonk.png\")","6ce83482":"Image(\"..\/input\/knnimages\/karisiklikmatrisi.png\")","e9d9f63c":"Image(\"..\/input\/knnimages\/dogrulukOrani.png\")","648a6391":"from sklearn.metrics import confusion_matrix # Kar\u0131\u015f\u0131kl\u0131k matris fonksiyonunun dahil oldu\u011fu paket dahil edilir.\n\nKarisiklik_Matrisi=confusion_matrix(y_test,y_pred) # Kar\u0131\u015f\u0131kl\u0131k matrisinin girdi de\u011ferleri yaz\u0131larak matris hesaplan\u0131r.\n\nprint(Karisiklik_Matrisi)","4597c5b7":"from sklearn.metrics import accuracy_score\n\ndogruluk_Orani=accuracy_score(y_test,y_pred) # Yap\u0131lan s\u0131n\u0131fland\u0131rma i\u015fleminin ne oranda do\u011fru oldu\u011funu d\u00f6nd\u00fcr\u00fcr. 0 ile 1 aras\u0131nda de\u011fer al\u0131r.\n\nprint(dogruluk_Orani) ","ae3766c4":"Image(\"..\/input\/knnimages\/tprfpr.png\")","90d4d02c":"from sklearn.metrics import roc_curve, roc_auc_score # ROC E\u011frisi i\u00e7in gerekli de\u011ferlerin hesaplanmas\u0131nda kullan\u0131lan mod\u00fcllerdir.\nimport matplotlib.pyplot as plt # ROC E\u011frisini \u00e7izmek i\u00e7in gerekli \u00e7izim mod\u00fcl\u00fcd\u00fcr.\n\n\nfalse_positive_rate, true_positive_rate, threshold = roc_curve(y_test, y_pred) # roc_curve() fonksiyonu ald\u0131\u011f\u0131 y_test ve y_pred de\u011ferlerini kullanarak FPR, TPR ve Threshold(E\u015fik De\u011feri) ifadelerini d\u00f6nd\u00fcr\u00fcr\n\nprint('KNN Algoritmas\u0131 i\u00e7in AUC De\u011feri : ', roc_auc_score(y_test, y_pred))","778fc205":"plt.subplots(figsize=(10,10))\nplt.title('ROC E\u011frisi - KNN')\n\nplt.plot(false_positive_rate, true_positive_rate)\nplt.plot([0, 1], [0,1])\n\nplt.ylabel('True Positive Rate (TPR)')\nplt.xlabel('False Positive Rate (FPR)')\n\nplt.show()","cd79474f":"# De\u011fi\u015fen k-kom\u015fuluk say\u0131lar\u0131na g\u00f6re algoritman\u0131n do\u011fruluk oran\u0131na bak\u0131l\u0131r:\n\ndef KNNHesapla(komsuluk,uzaklik,X_train,X_test,y_train,y_test):\n    \"\"\"\n    Fonksiyon de\u011fi\u015fen kom\u015fuluk ve uzakl\u0131k parametrelerine g\u00f6re KNN algoritmas\u0131n\u0131n do\u011fruluk oran listesini d\u00f6nd\u00fcr\u00fcr.\n    \n    komsuluk: KNN algoritmas\u0131nda kullan\u0131lan k-kom\u015fuluk say\u0131s\u0131n\u0131n parametresidir.\n    uzakl\u0131k: KNN algoritmas\u0131nda kullan\u0131lan uzakl\u0131k tipinin parametresidir. minkowski - euclidean - manhattan olmak \u00fczere \u00fc\u00e7 t\u00fcrd\u00fcr.\n    X_train: Girdi de\u011ferlerinden e\u011fitim verisi olarak kullan\u0131lan listedir.\n    y_train: \u00c7\u0131kt\u0131 de\u011ferlerinden e\u011fitim verisi olarak kullan\u0131lan listedir.\n    X_test: Girdi de\u011ferlerinden test verisi olarak kullan\u0131lan listedir.\n    y_test: \u00c7\u0131kt\u0131 de\u011ferlerinden test verisi olarak kullan\u0131lan listedir. Tahmin edilecek olan listedir.\n    \n    \"\"\"\n    oranListesi=[]\n    \n    for i in range(1,komsuluk):\n        \n        knnModel=KNeighborsClassifier(n_neighbors=i,metric=uzaklik) \n        \n        knnModel.fit(X_train,y_train)\n        \n        y_pred=knnModel.predict(X_test)\n        \n        dogrulukOrani=accuracy_score(y_test,y_pred)\n        \n        oranListesi.append(dogrulukOrani)\n        \n    return oranListesi","5259f112":"# KNNHesapla fonksiyonu kullan\u0131larak de\u011fi\u015fen uzakl\u0131k hesaplama y\u00f6ntemlerine g\u00f6re algoritman\u0131n do\u011fruluk oranlar\u0131 hesaplan\u0131r:\n\noranListe_Min=KNNHesapla(100,\"minkowski\",X_train,X_test,y_train,y_test) # Minkowski uzakl\u0131\u011f\u0131 i\u00e7in 1-100 kom\u015fulu\u011funda algoritma do\u011fruluk oran\u0131n\u0131n listesi hesapland\u0131.\n\noranListe_Euc=KNNHesapla(100,\"euclidean\",X_train,X_test,y_train,y_test) # Euclidean uzakl\u0131\u011f\u0131 i\u00e7in 1-100 kom\u015fulu\u011funda algoritma do\u011fruluk oran\u0131n\u0131n listesi hesapland\u0131.\n\noranListe_Man=KNNHesapla(100,\"manhattan\",X_train,X_test,y_train,y_test) # Manhattan uzakl\u0131\u011f\u0131 i\u00e7in 1-100 kom\u015fulu\u011funda algoritma do\u011fruluk oran\u0131n\u0131n listesi hesapland\u0131.\n","9f2f036b":"plt.subplots(figsize=(15,15)) # Grafik \u00e7izimi i\u00e7in 15x15 boyutunda \u015fablon olu\u015fturulur.\n\nx=range(1,100) # Grafikte kullan\u0131lacak olan X-Ekseni k-kom\u015fuluk say\u0131s\u0131n\u0131 temsil edece\u011finden x-ekseni 1-100 aras\u0131nda bir say\u0131 dizisi olarak tan\u0131mlan\u0131r.\n\n# X eksenleri sabit olacak \u015fekilde daha \u00f6ncesinden Minkowski, Euclidean ve Manhattan uzakl\u0131klar\u0131 kullan\u0131larak hesaplanan do\u011fruluk oranlar\u0131na g\u00f6re farkl\u0131 \u00e7izgiler ayn\u0131 grafi\u011fe eklenir:\n\nplt.plot(x,oranListe_Min,color=\"r\",linewidth=3.0,label=\"Minkowski\",marker=\"o\",markersize=5) \nplt.plot(x,oranListe_Euc,color=\"g\",linewidth=3.0,label=\"Euclidean\")\nplt.plot(x,oranListe_Man,color=\"b\",linewidth=3.0,label=\"Manhattan\",linestyle=\"--\")\n\n# Grafi\u011fin X ve Y ekseninde g\u00f6r\u00fcnecek isimler ile bilgilendirme panosu eklenir: \n\nplt.xlabel(\"K-Kom\u015fuluk De\u011feri\",fontsize=\"xx-large\")\nplt.ylabel(\"Algoritman\u0131n Do\u011fruluk Oran\u0131\",fontsize=\"xx-large\")\nplt.legend(fontsize=\"xx-large\")\n\nplt.show() # Grafikle birlikte bilgilendirme sat\u0131r\u0131n\u0131n \u00e7\u0131kmamas\u0131n\u0131 sa\u011flar. Sadece grafi\u011fin g\u00f6rseli \u00e7\u0131kt\u0131 olarak g\u00f6r\u00fcn\u00fcr.\n","3733d0a5":"Minkowski, Euclidean ve Manhattan uzakl\u0131klar\u0131 bu veri seti i\u00e7in 1-100 kom\u015fulu\u011funda ayn\u0131 de\u011ferleri vermektedir.En uygun k kom\u015fuluk say\u0131s\u0131 1-60 aras\u0131nda se\u00e7ilmelidir. Kom\u015fuluk say\u0131s\u0131 yakla\u015f\u0131k olarak 60 dan fazla al\u0131nd\u0131\u011f\u0131nda algoritman\u0131n do\u011fru s\u0131n\u0131fland\u0131rma oran\u0131nda ciddi d\u00fc\u015f\u00fc\u015f g\u00f6r\u00fclmektedir.","300150eb":"> **DataFrame** pandas k\u00fct\u00fcphanesi i\u00e7erisinde bulunan veriyi bir tablo \u015feklinde tiple ifade eden ve verinin okunabilirli\u011fini dolay\u0131s\u0131yla y\u00f6netilebilirli\u011fini artt\u0131ran bir veri tipidir.\n\n> *data* olarak projeye dahil edilen veri seti art\u0131k \"mframe\" de\u011fi\u015fkenine atanm\u0131\u015ft\u0131r ve DataFrame yap\u0131s\u0131ndad\u0131r.\n","2126b70b":"<a id=\"4\"><\/a> <br>\n## K - EN YAKIN KOM\u015eULUK ALGOR\u0130TMASI (K NEAREST NEIGHBORS)\n\nVeri seti incelendi\u011finde de\u011ferlerin kategorik veriler oldu\u011fu g\u00f6r\u00fclmektedir. Kategorik verilerde varsay\u0131m ve tahmin i\u00e7in Makine \u00d6\u011frenmesi Algoritmalar\u0131'ndan **Y\u00f6nlendirilmi\u015f-G\u00f6zetimli \u00d6\u011frenme Algoritmalar\u0131** kullan\u0131labilir \u00e7\u00fcnk\u00fc algoritmadan veriler hakk\u0131nda bilgi almadan \u00f6nce algoritmaya etiketlenmi\u015f, \u00f6nceden kategorize edilmi\u015f veriler tan\u0131t\u0131lacakt\u0131r. G\u00f6zetimli Algoritmalar i\u00e7erisinde yer alan **S\u0131n\u0131fland\u0131rma Algoritmalar\u0131** kategorize edilmi\u015f veriler \u00fczerinde \u00e7al\u0131\u015fan \u00e7\u00f6z\u00fcmlerdir. \u00d6rnek olarak kullan\u0131lan mantar veri seti i\u00e7in **S\u0131n\u0131fland\u0131rma Algoritmalar\u0131**'ndan herhangi biri kullan\u0131labilir. Veri i\u00e7erisinde neredeyse her kolonda bir s\u0131n\u0131fland\u0131rma vard\u0131r fakat baz\u0131 kolonlar\u0131n s\u0131n\u0131fland\u0131r\u0131lmas\u0131 baz\u0131 kolonlara bak\u0131larak daha kolay tahmin edilebilir. Veri seti i\u00e7erisinde bulunan *class* kolonu mantar\u0131n zehirli olup olmad\u0131\u011f\u0131n\u0131 kategorize etmi\u015ftir. Di\u011fer kolonlara bak\u0131larak bu kolonda yer alan kategori tahmin edilebilir.","dcefa32d":"Veri seti i\u00e7erisinde bulunan kategorilerin (her bir kategori i\u00e7in ayr\u0131) say\u0131sal de\u011ferlerle ifade edilmesi verileri s\u0131n\u0131fland\u0131rmak a\u00e7\u0131s\u0131ndan iyidir. Fakat girdi de\u011ferlerinin say\u0131sal ifadelerden olu\u015fuyor olmas\u0131 modeli e\u011fitmek a\u00e7\u0131s\u0131ndan yanl\u0131\u015f sonu\u00e7lar do\u011furabilir. \u00c7\u00fcnk\u00fc say\u0131sal de\u011ferler her ne kadar s\u0131n\u0131fland\u0131rma amac\u0131yla yap\u0131l\u0131yor olsa da say\u0131sal de\u011ferler kar\u015f\u0131la\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda bir sonu\u00e7 ortaya \u00e7\u0131kmaktad\u0131r. \u00d6rne\u011fin Elma ile Armut s\u0131n\u0131f\u0131 kar\u015f\u0131la\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda iki ayr\u0131 grupland\u0131rma oldu\u011fundan herhangi bir aritmetik de\u011fer \u00e7\u0131kmaz fakat 1 ile 2 kar\u015f\u0131la\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda sonu\u00e7 1 k\u00fc\u00e7\u00fck ya da 2 b\u00fcy\u00fck \u015fekilde olabilir. Say\u0131sal kategorize edilen verileri kullanmak i\u00e7in sonu\u00e7lar\u0131n model taraf\u0131ndan \u00e7arp\u0131t\u0131lmas\u0131n\u0131 **One Hot Encoding** y\u00f6netimi engelleyebilir. \u00d6rne\u011fin bir kolonda **1, 2, 3** ile ifade edilen kategoriler olsun. Bu kolona One Hot Encoding y\u00f6ntemi uygulad\u0131\u011f\u0131nda **[1 0 0], [0 1 0], [0 0 1]** \u015feklinde \u00fc\u00e7 kolon tan\u0131mlan\u0131r. **[1 0 0]** kolonu 1 de\u011ferini, **[0 1 0]** kolonu 2 de\u011ferini, **[0 0 1]** kolonu da 3 de\u011ferini temsil etmektedir.","da9f0280":"**K - En Yak\u0131n Kom\u015fuluk Algoritmas\u0131n\u0131n Uygulanmas\u0131 : **","10037da2":"<a id=\"5\"><\/a> <br>\n## PERFORMANS \u00d6L\u00c7\u00dcM\u00dc","a9a4e06d":"> **LabelEncoder** kategorize edilmi\u015f verileri etiketlemek i\u00e7in kullan\u0131l\u0131r.","c8f1ba2d":"-----------------------------------------------------------------------------------------------------------------------------------------------------------------","6d1275e2":">**Do\u011fru Pozitif - True Positive - TP :** Ger\u00e7ekte olan de\u011ferin 1 ile tahmin edilen de\u011ferin 1 oldu\u011fu \u00f6rneklerin say\u0131s\u0131d\u0131r.\n\n>**Yanl\u0131\u015f Pozitif - False Positive - FP :** Ger\u00e7ekte olan de\u011ferin 1 ile tahmin edilen de\u011ferin 0 oldu\u011fu \u00f6rneklerin say\u0131s\u0131d\u0131r.\n\n>**Yanl\u0131\u015f Negatif - False Negative - FN :** Ger\u00e7ekte olan de\u011ferin 0 ile tahmin edilen de\u011ferin 1 oldu\u011fu \u00f6rneklerin say\u0131s\u0131d\u0131r.\n\n>**Do\u011fru Negatif - True Negative  - TN :** Ger\u00e7ekte olan de\u011ferin 0 ile tahmin edilen de\u011ferin 0 oldu\u011fu \u00f6rneklerin say\u0131s\u0131d\u0131r.\n\n>**Do\u011fruluk Oran\u0131 - Accuracy Rate :** S\u0131n\u0131flay\u0131c\u0131 olarak kullan\u0131lan algoritman\u0131n ne kadar do\u011frulukta s\u0131n\u0131fland\u0131rd\u0131\u011f\u0131n\u0131n \u00f6l\u00e7\u00fcs\u00fcd\u00fcr. 0 ile 1 aras\u0131nda \u00e7\u0131kan bir de\u011ferdir. Oran 1' e yakla\u015ft\u0131k\u00e7a s\u0131n\u0131fland\u0131rman\u0131n do\u011frulu\u011fu artar.","582479b5":"## G\u0130R\u0130\u015e","98508731":"### \u0130\u00e7indekiler\n\n\n[MANTAR VER\u0130 SET\u0130](#1)\n\n> [Veri Setinde \u0130ncelenen \u00d6zellikler](#2)\n\n\n[VER\u0130 SET\u0130N\u0130N \u0130NCELENMES\u0130](#3)\n\n\n[K - EN YAKIN KOM\u015eULUK ALGOR\u0130TMASI (K NEAREST NEIGHBORS)](#4)\n\n\n[PERFORMANS \u00d6L\u00c7\u00dcM\u00dc](#5)\n\n> [Kar\u0131\u015f\u0131kl\u0131k Matrisi (Confusion Matrix) ](#6)\n\n> [ROC E\u011frisi (Receiver Operating Characteristics Curve)](#7)\n\n[KAYNAK\u00c7A](#8)","371eb4e0":"<a id=\"8\"><\/a> <br>\n## KAYNAK\u00c7A\n\n> 1. https:\/\/medium.com\/@ayyucekizrak\/yapay-zekaya-ba%C5%9Flama-rehberi-91e79d3de8e1\n\n> 1. https:\/\/archive.ics.uci.edu\/ml\/datasets\/mushroom \n\n> 2. https:\/\/medium.com\/@k.ulgen90\/makine-%C3%B6%C4%9Frenimi-b%C3%B6l%C3%BCm-2-6d6d120a18e1\n\n> 3. https:\/\/towardsdatascience.com\/supervised-machine-learning-classification-5e685fe18a6d\n\n> 4. https:\/\/www.analyticsvidhya.com\/blog\/2018\/03\/introduction-k-neighbours-algorithm-clustering\/\n\n> 5. https:\/\/setscholars.net\/2019\/02\/03\/how-to-plot-roc-curve-in-python\/\n\n> 6. https:\/\/towardsdatascience.com\/understanding-confusion-matrix-a9ad42dcfd62\n\n> 7. https:\/\/towardsdatascience.com\/understanding-auc-roc-curve-68b2303cc9c5\n\n> 8. https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.neighbors.KNeighborsClassifier.html\n\n> 9. https:\/\/matplotlib.org\/3.1.0\/api\/_as_gen\/matplotlib.pyplot.plot.html\n\n> 10. https:\/\/towardsdatascience.com\/understanding-the-bias-variance-tradeoff-165e6942b229","7b96b866":"#### ROC E\u011frisi De\u011ferleri Hesaplan\u0131r : ","8fce2127":"K - En Yak\u0131n Kom\u015fuluk(KNN) algoritmas\u0131nda hi\u00e7 \u015f\u00fcphesiz en \u00f6nemli de\u011fi\u015fken **k-kom\u015fuluk say\u0131s\u0131**d\u0131r. Kom\u015fuluk say\u0131s\u0131 algoritman\u0131n \u00e7al\u0131\u015ft\u0131\u011f\u0131 veri seti \u00fczerinde ne \u015fekilde uzakl\u0131k hesaplayaca\u011f\u0131n\u0131 belirtti\u011fi i\u00e7in veri setinin \u00f6zelli\u011fine ba\u011fl\u0131 olarak da de\u011fi\u015fir. E\u011fer sadece 100 elemanl\u0131 bir veri setinde bu algoritma \u00e7al\u0131\u015ft\u0131r\u0131l\u0131rsa mutlaka k-kom\u015fuluk say\u0131s\u0131 100'den k\u00fc\u00e7\u00fck olmal\u0131d\u0131r ki anlaml\u0131 sonu\u00e7lar \u00e7\u0131ks\u0131n. \u00c7\u00fcnk\u00fc 100 elemanl\u0131 bir veri setinde herhangi bir eleman\u0131n 100 eleman kom\u015fulu\u011funa bak\u0131ld\u0131\u011f\u0131nda veri setinin neredeyse t\u00fcm elemanlar\u0131yla \u00e7al\u0131\u015f\u0131laca\u011f\u0131 i\u00e7in algoritman\u0131n e\u011fitim ve test verilerine gerek kalmayacakt\u0131r, algoritma t\u00fcm verileri g\u00f6recektir. B\u00f6ylece algoritma hem veriyi **ezberleyecek** hem de veri setine yeni bir veri eklendi\u011finde o verinin s\u0131n\u0131f\u0131n\u0131 bulmakta **duyars\u0131zla\u015facak**t\u0131r.","5be2c98d":"**Veri Setinin Uygulanacak Algoritma i\u00e7in Haz\u0131rlanmas\u0131 : **","d62d96ac":"### 5.3. De\u011fi\u015fen K Kom\u015fuluk De\u011ferleri i\u00e7in K - En Yak\u0131n Kom\u015fuluk Algoritmas\u0131n\u0131n Performans\u0131","273b8e01":"**Veri seti projeye dahil edilir :**","4f69ac4b":"**E\u011fitim ve Test Verilerinin Ayarlanmas\u0131 :**","009f2c85":"**Veri setinden incelenmek \u00fczere \u00f6rnek al\u0131n\u0131r :**","ef211ecf":"Veri seti \u00fczerinde bir makine \u00f6\u011frenmesi algoritmas\u0131 \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce i\u00e7eri\u011fi hakk\u0131nda bilgi almak i\u00e7in veriler incelenmelidir. \u00c7\u00fcnk\u00fc tan\u0131nan veriler hakk\u0131nda daha kolay yorumlama yap\u0131labilir.\n\n\u00d6ncellikle veri setini projeye dahil etmek ve sonras\u0131nda incelemek i\u00e7in gerekli k\u00fct\u00fcphaneler projeye dahil edilir:","29028804":"<a id=\"1\"><\/a> <br>\n## MANTAR VER\u0130 SET\u0130\n\nMantar veri seti, *Agaricus* ve *Lepiota* mantar ailesine ait 23 mantar t\u00fcr\u00fcn\u00fcn varsay\u0131msal \u00f6rneklerinin bir tak\u0131m \u00f6zelliklerini i\u00e7erir. Veri seti i\u00e7erisindeki incelenen mantarlar zehirli olup olmamalar\u0131na g\u00f6re *kesinlikle yenilebilir, kesinlikle zehirli* veya *bilinmeyen yenilebilir* olarak tan\u0131mlan\u0131r. Bilinmeyen yenilebilir ile kesinlikle zehirli olanlar birle\u015ftirilip kesinlikle zehirli olarak kabul edilmi\u015ftir. Son tahlilde incelenen mantar veri seti i\u00e7erisinde iki adet s\u0131n\u0131f mevcuttur : *Kesinlikle Yenilebilir(Eligible)*, *Kesinlikle Zehirli(Poisonous)*. \n\nMantar\u0131n hangi s\u0131n\u0131fa dahil oldu\u011funu apa\u00e7\u0131k belirten sadece birka\u00e7 \u00f6zellik bulunmamaktad\u0131r. Bu nedenle mantar s\u0131n\u0131f\u0131n\u0131n do\u011fru olarak tespiti i\u00e7in bir\u00e7ok g\u00f6zlem sonucuna ihtiya\u00e7 vard\u0131r.\n\n<a id=\"2\"><\/a> <br>\n### Veri Setinde \u0130ncelenen \u00d6zellikler\n\n**cap-shape:** bell=b,conical=c,convex=x,flat=f, knobbed=k,sunken=s \n\n**cap-surface:** fibrous=f,grooves=g,scaly=y,smooth=s \n\n**cap-color:** brown=n,buff=b,cinnamon=c,gray=g,green=r, pink=p,purple=u,red=e,white=w,yellow=y \n\n**bruises?:** bruises=t,no=f \n\n**odor:** almond=a,anise=l,creosote=c,fishy=y,foul=f, musty=m,none=n,pungent=p,spicy=s \n\n**gill-attachment:** attached=a,descending=d,free=f,notched=n \n\n**gill-spacing:** close=c,crowded=w,distant=d \n\n**gill-size:** broad=b,narrow=n \n\n**gill-color:** black=k,brown=n,buff=b,chocolate=h,gray=g, green=r,orange=o,pink=p,purple=u,red=e, white=w,yellow=y \n\n**stalk-shape:** enlarging=e,tapering=t \n\n**stalk-root:** bulbous=b,club=c,cup=u,equal=e, rhizomorphs=z,rooted=r,missing=? \n\n**stalk-surface-above-ring:** fibrous=f,scaly=y,silky=k,smooth=s \n\n**stalk-surface-below-ring:** fibrous=f,scaly=y,silky=k,smooth=s \n\n**stalk-color-above-ring:** brown=n,buff=b,cinnamon=c,gray=g,orange=o, pink=p,red=e,white=w,yellow=y \n\n**stalk-color-below-ring:** brown=n,buff=b,cinnamon=c,gray=g,orange=o, pink=p,red=e,white=w,yellow=y \n\n**veil-type:** partial=p,universal=u \n\n**veil-color:** brown=n,orange=o,white=w,yellow=y \n\n**ring-number:** none=n,one=o,two=t \n\n**ring-type:** cobwebby=c,evanescent=e,flaring=f,large=l, none=n,pendant=p,sheathing=s,zone=z \n\n**spore-print-color:** black=k,brown=n,buff=b,chocolate=h,green=r, orange=o,purple=u,white=w,yellow=y \n\n**population:** abundant=a,clustered=c,numerous=n, scattered=s,several=v,solitary=y \n\n**habitat:** grasses=g,leaves=l,meadows=m,paths=p, urban=u,waste=w,woods=d\n\n","2b2827ad":" Model olu\u015fturmak i\u00e7in Girdi(X) ve \u00c7\u0131kt\u0131(y) de\u011ferleri belirlenir.\n Girdi de\u011ferleri bir algoritmik modelde kullan\u0131lacak ve \u00e7\u0131kt\u0131 de\u011ferleri tahmin edilecektir.","380009c2":"**Veri setinde bulunan kolonlar incelenir :**","3460fc4d":"G\u00fcn\u00fcm\u00fcz\u00fcn pop\u00fcler konular\u0131ndan biri haline gelen **Yapay Zeka** en basit tan\u0131m\u0131yla insan zekas\u0131ndan esinlenerek yap\u0131lan \u00e7al\u0131\u015fmalar\u0131n t\u00fcm\u00fcne verilen isimdir. Yapay zekan\u0131n ne oldu\u011fu nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131 ve hangi ara\u00e7lar\u0131 kulland\u0131\u011f\u0131 ise olduk\u00e7a karma\u015f\u0131k bir d\u00fcnyay\u0131 kar\u015f\u0131m\u0131za \u00e7\u0131karmaktad\u0131r. \u00c7\u00fcnk\u00fc bir\u00e7ok a\u00e7\u0131dan yapay zekay\u0131 de\u011ferlendirmek m\u00fcmk\u00fcnd\u00fcr. Robotlar\u0131n insan ya\u015fant\u0131s\u0131na egemen olmas\u0131ndan bilinen verilerle bilinemeyen bir varsay\u0131mda bulunabilen algoritmalara kadar bir\u00e7ok farkl\u0131 alanda yapay zeka kullan\u0131lmaktad\u0131r. Burada yapay zekan\u0131n daha bilimsel olan bir y\u00f6n\u00fcnden bahsedilecektir.\n\nYapay zeka hesaplamayla insan\u0131n anlama yetene\u011fini bulu\u015fturmay\u0131 ama\u00e7layan bilgisayar biliminin bir alt dal\u0131d\u0131r. \u0130nsan\u0131n \u00e7evresini anlamland\u0131r\u0131rken kullanm\u0131\u015f oldu\u011fu zekas\u0131n\u0131 yapay zeka, \u00e7al\u0131\u015fmalar\u0131n\u0131n merkezine alm\u0131\u015ft\u0131r ve bu minvalde geli\u015ftirdi\u011fi \u00fcr\u00fcnlerde \"insan benzeri\" davran\u0131\u015flar ama\u00e7lamaktad\u0131r. G\u00fcn\u00fcm\u00fczde yapay zeka \u00e7al\u0131\u015fmalar\u0131 ile pop\u00fcler hale gelmi\u015f olan insan gibi okuyabilme, baz\u0131 durumlarda insan gibi \"d\u00fc\u015f\u00fcn\u00fcp\" karar verebilme ve insan gibi g\u00f6r\u00fcnt\u00fcleri alg\u0131layabilme sistemleri geli\u015ftirilmektedir. Belli bir sorunun \u00e7\u00f6z\u00fcm\u00fc i\u00e7in geli\u015ftirilen, veriden \u00f6\u011frenen yapay zeka \u00e7\u00f6z\u00fcmleri \"Dar Yapay Zeka\" olarak tan\u0131mlan\u0131rken daha geni\u015f anlamda ses ve g\u00f6r\u00fcnt\u00fc alg\u0131layabilen, insans\u0131 bir karar verebilme yetene\u011fine sahip kendi kendine \u00f6\u011frenebilen sistemlere \"Geni\u015f Yapay Zeka\" denilmektedir.\n\nMakine \u00d6\u011frenmesi ise yapay zeka \u00e7al\u0131\u015fmalar\u0131nda bir alt grup te\u015fkil eden karma\u015f\u0131k kavramdan sadece bir tanesidir. Yapay zekan\u0131n kapsam\u0131\u015f oldu\u011fu Makine \u00d6\u011frenmesi, \u00e7e\u015fitli algoritmalar (bir sorun kar\u015f\u0131s\u0131nda ortaya konan \u00e7\u00f6z\u00fcm ad\u0131mlar\u0131) b\u00fct\u00fcn\u00fc olarak de\u011ferlendirilebilir. Burada kastedilen algoritmalar ise bazen bir g\u00f6r\u00fcnt\u00fcy\u00fc i\u015flemek bazen konu\u015fulan bir dili anlamak bazen de belirli bir durum i\u00e7in ge\u00e7mi\u015f \u00f6rneklere bakarak gelecekteki durumu tahmin etme i\u015flemidir. Makine \u00f6\u011frenmesi denilince elbette bu gibi i\u015flemlerle s\u0131n\u0131rland\u0131r\u0131lamayacak \u00f6l\u00e7\u00fcde geni\u015f bir kavramdan bahsedilmektedir. Makineler ya y\u00f6nlendirilmelerle \u00f6\u011frenir (Supervised Machine Learning) ya y\u00f6nlendirmeler olmadan \u00f6\u011frenir (Unsupervised Machine Learning) ya da deneme yan\u0131lma yolu ile \u00f6\u011frenir (Reinforcement Machine Learning).\n\n\nYapm\u0131\u015f oldu\u011fu g\u00f6zetimlerle y\u00f6nlendirilen makine \u00f6\u011frenmesi algoritmalar\u0131 (Supervised Machine Learning) \u00f6ncelikle \"e\u011fitilerek\" istenilen ama\u00e7 i\u00e7in haz\u0131rlan\u0131r. E\u011fitme i\u015flemi sisteme sunulan girdilerle yap\u0131ld\u0131ktan sonra \"\u00f6\u011frenen\" sistem test verileri \u00fczerinde \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r ve performans\u0131na bak\u0131l\u0131r: Algoritma e\u011fitimde neyi ne do\u011frulukta \u00f6\u011frendi ? Daha sonras\u0131nda ise performans\u0131na y\u00f6nelik \u00e7al\u0131\u015fmalarla g\u00f6zetimli olarak \u00e7al\u0131\u015ft\u0131r\u0131lan algoritman\u0131n en iyi \u00e7al\u0131\u015fmas\u0131n\u0131 yapmas\u0131 i\u00e7in u\u011fra\u015f verilir. Y\u00f6nlendirilen-g\u00f6zetimli makine \u00f6\u011frenmesinde iki farkl\u0131 sorun \u00fczerinde \u00e7al\u0131\u015f\u0131l\u0131r: Ya var olan say\u0131sal de\u011ferler kullan\u0131larak sonucu bilinmeyen bir ifade hesaplan\u0131r (Regression - Regresyon) ya da kategorik olarak ayr\u0131lm\u0131\u015f bir veride kategorisi belli olmayan veriler i\u00e7in kategori ayr\u0131m\u0131 yap\u0131l\u0131r (Classification - S\u0131n\u0131fland\u0131rma).\n\nKNN - En Yak\u0131n Kom\u015fuluk Algoritmas\u0131 y\u00f6nlendirilen-g\u00f6zetimli makine \u00f6\u011frenmesi algoritmalar\u0131ndan en basitidir. S\u0131n\u0131fland\u0131rma ve Regresyon problemlerinin ikisi i\u00e7in de kullan\u0131labilmesine ra\u011fmen daha \u00e7ok s\u0131n\u0131fland\u0131rma i\u015flemlerinde \u00e7al\u0131\u015ft\u0131r\u0131lmaktad\u0131r. S\u0131n\u0131fland\u0131rmada kullan\u0131lacak olan KNN algoritmas\u0131 i\u00e7in kategorize edilmi\u015f ya da edilebilecek bir veri setine ihtiya\u00e7 duyulmaktad\u0131r. ","5dbb3ca6":"> **A\u015f\u0131r\u0131 \u00d6\u011frenme (Overfitting) :** Bir \u00f6\u011frenme modeli,algoritmas\u0131, e\u011fitilece\u011fi veri \u00fczerinde gere\u011finden fazla \u00e7al\u0131\u015fm\u0131\u015f ise e\u011fitim verilerini ezberlemeye ba\u015flar. Model e\u011fitim verilerini ezberledi\u011finde yeni gelen verilere kar\u015f\u0131 duyars\u0131zla\u015f\u0131r ve tek bildi\u011fi,cevap verdi\u011fi durumlar e\u011fitim verileri olmu\u015f olur.B\u00f6yle durumlara modelin **A\u015f\u0131r\u0131 \u00d6\u011frenme**si ad\u0131 verilir. A\u015f\u0131r\u0131 \u00f6\u011frenme durumunda modelin varyans\u0131 y\u00fcksek yanl\u0131l\u0131\u011f\u0131 d\u00fc\u015f\u00fck \u00e7\u0131kar.\n\n> **Eksik \u00d6\u011frenme (Underfitting) :** Olu\u015fturulan bir \u00f6\u011frenme modeli e\u011fitim verilerinden gerekli modeli \u00e7\u0131kartamad\u0131\u011f\u0131nda ortaya **Eksik \u00d6\u011frenme** durumu \u00e7\u0131kar. Modelin e\u011fitilece\u011fi verinin azl\u0131\u011f\u0131 ya da s\u0131n\u0131fland\u0131rmaya uymayan bir veri seti i\u00e7erisinde s\u0131n\u0131fland\u0131rma algoritmas\u0131 kullan\u0131larak model olu\u015fturulmaya \u00e7al\u0131\u015f\u0131ld\u0131\u011f\u0131nda ortaya eksik \u00f6\u011frenme \u00e7\u0131kar. Eksik \u00f6\u011frenmede model y\u00fcksek varyansa ve d\u00fc\u015f\u00fck yanl\u0131l\u0131\u011fa sahiptir. ","a79162da":"**Herhangi bir kolon \u00f6zelinde veri seti incelenir : **","b2545874":"> **DataFrame.columns :** DataFrame yap\u0131s\u0131 i\u00e7erisinde bulunan kolonlar\u0131 getirir.","2de0d510":"\n**Kar\u0131\u015f\u0131kl\u0131k Matrisini Olu\u015fturma : **","f27eaee7":"**DataFrame yap\u0131s\u0131 kurulur :**","691f4a05":"# KNN - EN YAKIN KOM\u015eULUK ALGOR\u0130TMASI","78727384":"**head(sayi) :** DataFrame i\u00e7erisinden ilk ba\u015ftan *sayi* say\u0131s\u0131 kadar sat\u0131r\u0131 getirir. E\u011fer bo\u015f kullan\u0131l\u0131rsa 5 sat\u0131r al\u0131n\u0131r.\n\n**tail(sayi) :**  DataFrame i\u00e7erisinden en sondan *sayi* say\u0131s\u0131 kadar sat\u0131r\u0131 getirir. E\u011fer bo\u015f kullan\u0131l\u0131rsa 5 sat\u0131r al\u0131n\u0131r.","61ec575d":"S\u0131n\u0131f\u0131 belli olmayan verinin k say\u0131s\u0131 kadar kom\u015fulu\u011funa bak\u0131l\u0131r. k=3 i\u00e7in s\u0131n\u0131fs\u0131z verinin \u00e7evresinde 3 adet s\u0131n\u0131fl\u0131 veriye bak\u0131l\u0131r, bu verilerim s\u0131n\u0131flar\u0131 kontrol edilir. Hangi s\u0131n\u0131f\u0131n verisi fazla ise s\u0131n\u0131fs\u0131z veri o s\u0131n\u0131fa dahil edilir. \u00d6rne\u011fin k=3 kom\u015fulu\u011funda 2 adet A s\u0131n\u0131f\u0131ndan eleman var ise 2>1 oldu\u011fuundan s\u0131n\u0131fs\u0131z verinin s\u0131n\u0131f\u0131 A olarak atan\u0131r. B\u00f6yle bir y\u00f6ntemle s\u0131n\u0131f belirlenmesinde **oy \u00e7oklu\u011fu** kullan\u0131l\u0131r, kom\u015fuluk i\u00e7erisinde eleman\u0131 \u00e7ok olan s\u0131n\u0131f oylamay\u0131 kazan\u0131r ve s\u0131n\u0131fs\u0131z eleman oylamay\u0131 kazanan s\u0131n\u0131fa dahil edilir.\n\nK - En Yak\u0131n Kom\u015fuluk algoritmas\u0131n\u0131n kullan\u0131m\u0131nda **Girdi(X)** ve **\u00c7\u0131kt\u0131(y)** de\u011ferleri ile **E\u011fitim** ve **Test** veri setleri belirlenir. E\u011fitim verilerindeki Girdi ve \u00c7\u0131kt\u0131 de\u011ferlerinden yararlanan algoritman\u0131n modeli verinin kural\u0131n\u0131 belirler. Kural belirlemeden kas\u0131t *hangi Girdi de\u011ferleri i\u00e7in veri seti i\u00e7erisinde hangi \u00c7\u0131kt\u0131 de\u011ferlerinin oldu\u011funu algoritman\u0131n \" \u00f6\u011frenmesidir \"*. Daha sonra da Test veri setinde bulunan Girdi verileri kullan\u0131larak yine Test veri setinde bulunan \u00c7\u0131kt\u0131 de\u011ferleri tahmin edilir.\n\nYeni verinin s\u0131n\u0131f\u0131n\u0131 belirlerken daha \u00f6nce s\u0131n\u0131fland\u0131r\u0131lm\u0131\u015f verilere olan k kom\u015fulu\u011funa bak\u0131l\u0131rken s\u0131n\u0131fs\u0131z veri ile s\u0131n\u0131fland\u0131r\u0131lm\u0131\u015f veriler aras\u0131ndaki uzakl\u0131k de\u011ferine bak\u0131l\u0131r. K - En Yak\u0131n Kom\u015fuluk algoritmas\u0131 i\u00e7in genelde \u00fc\u00e7 ayr\u0131 uzakl\u0131k fonksiyonu kullan\u0131l\u0131r. \n","3a76f286":"#### ROC E\u011frisi \u00c7izilir : ","78acf3c9":"**Do\u011fruluk Oran\u0131n\u0131 Hesaplama : **","a3fffda9":"Veri seti kullan\u0131larak s\u0131n\u0131fland\u0131rma i\u015flemi yap\u0131ld\u0131 fakat hangi s\u0131n\u0131f ne kadar do\u011fru tahmin edildi bilinmemektedir. Makine \u00f6\u011frenmesi algoritmalar\u0131 veya herhangi bir algoritma \u00e7al\u0131\u015ft\u0131r\u0131l\u0131rken ayr\u0131lan kaynak ve \u00e7\u0131kan sonucun takibi olduk\u00e7a \u00f6nemlidir. Yap\u0131lan t\u00fcm geli\u015ftirmelerde hi\u00e7 \u015f\u00fcphesiz daha az kaynak kullan\u0131m\u0131 ile daha iyi sonu\u00e7 elde etme \u00e7abas\u0131 g\u00fcd\u00fclmektedir. Peki \"daha iyi\" sonu\u00e7 derken ne kastedilmektedir? Makine \u00f6\u011frenmesi algoritmalar\u0131ndan g\u00f6zetimli \u00f6\u011frenme olan s\u0131n\u0131fland\u0131rma algoritmalar\u0131nda \"daha iyi sonu\u00e7\"tan kas\u0131t bir veriyi en do\u011fru \u015fekilde s\u0131n\u0131fland\u0131rmak demektir. Tabiki en iyi \u015fekilde s\u0131n\u0131fland\u0131rma i\u015flemi yap\u0131l\u0131rken de kaynak kullan\u0131m\u0131 g\u00f6zard\u0131 edilmemelidir. Genelde herhangi bir s\u0131n\u0131fland\u0131rma algoritmas\u0131n\u0131 \u00f6zelde ise KNN Algoritmas\u0131n\u0131 incelerken performans \u00f6l\u00e7\u00fcm\u00fc s\u0131ras\u0131nda algoritman\u0131n ne kadar iyi s\u0131n\u0131fland\u0131rma yapt\u0131\u011f\u0131n\u0131n yan\u0131 s\u0131ra veri setine yeni kat\u0131lan dolay\u0131s\u0131yla s\u0131n\u0131f\u0131 belli olmayan verilere kar\u015f\u0131 davran\u0131\u015f\u0131 da dikkate al\u0131nmaktad\u0131r. \n\nAlgoritman\u0131n e\u011fitilece\u011fi E\u011fitim verileri ile ne kadar do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131n test edilece\u011fi Test verileri aras\u0131ndaki oran burada \u00f6nem kazanmaktad\u0131r. E\u011fer algoritma e\u011fitim verileri \u00fczerinde fazla \u00e7al\u0131\u015f\u0131rsa A\u015f\u0131r\u0131 \u00d6\u011frenme(Overfitting) durumu ortaya \u00e7\u0131kar ve bu durumda y\u00fcksek Varyans ortaya \u00e7\u0131kar. Algoritma yetersiz e\u011fitim verisiyle \u00e7al\u0131\u015ft\u0131r\u0131l\u0131rsa eksik \u00f6\u011frenme durumu olu\u015fur ve y\u00fcksek Yanl\u0131l\u0131k ortaya \u00e7\u0131kar.\n","e9a524b9":"ROC e\u011frisi iki boyut i\u00e7eren bir e\u011fridir. Boyutlar\u0131ndan <u>y eksenine<\/u> **TPR** de\u011feri, <u>x eksenine<\/u> **FPR** de\u011feri atan\u0131r.","8599965e":"> **read_csv(dosya_yolu)** fonksiyonu pandas k\u00fct\u00fcphanesinin bir fonksiyonu olup .csv format\u0131nda dosya okumak i\u00e7in kullan\u0131l\u0131r.\n\n> *data* de\u011fi\u015fkeni DataFrame yap\u0131s\u0131ndad\u0131r.","d11cfd4c":"<a id=\"3\"><\/a> <br>\n## VER\u0130 SET\u0130N\u0130N \u0130NCELENMES\u0130","7913fb27":"> Projeye gerekli resimleri eklemek i\u00e7in Image mod\u00fcl\u00fcnden yararlan\u0131labilir.","edf55a3f":"<a id=\"7\"><\/a> <br>\n### 5.2. ROC E\u011frisi (Receiver Operating Characteristics Curve)\n\nROC e\u011frisi \u00e7ok s\u0131n\u0131f i\u00e7eren s\u0131n\u0131fland\u0131rma problemlerinin performanslar\u0131n\u0131 kontrol etmek i\u00e7in kullan\u0131lan e\u011fridir.\n**AUC (Area Under The Curve)** kavram\u0131 burada \u00f6nemlidir ve ROC E\u011frisinin alt\u0131nda kalan alan\u0131n \u00f6l\u00e7\u00fcs\u00fcn\u00fc temsil etmektedir. ROC E\u011frisi bir olas\u0131l\u0131k e\u011frisi oldu\u011fu i\u00e7in m\u00fckemmel bir modelde e\u011frinin alt\u0131nda kalan alan bire e\u015fittir. Yani s\u0131f\u0131ra yakla\u015ft\u0131k\u00e7a modelin performans\u0131, s\u0131n\u0131flar\u0131 ay\u0131rabilirli\u011fi, d\u00fc\u015fecektir. E\u011fer AUC de\u011feri 0.5 gibi bir de\u011fer ise \u00f6l\u00e7\u00fclen model neredeyse hi\u00e7 s\u0131n\u0131f ay\u0131ram\u0131yor demektir. ROC e\u011frisinin alt\u0131ndaki alan (Area Under Curve (AUC)), bir parametrenin iki s\u0131n\u0131f aras\u0131nda ne kadar iyi ay\u0131rt edilebilece\u011finin bir \u00f6l\u00e7\u00fcs\u00fcd\u00fcr.","ca3c6b1c":"LabelEncoder kategorize edilmi\u015f verilerde her bir kategoriye s\u0131f\u0131rdan ba\u015flayarak say\u0131 verir. Bu veri seti i\u00e7in zehirli mantar s\u0131n\u0131f\u0131na(p: poisonous) 1 de\u011ferini atarken zehirsiz mantar s\u0131n\u0131f\u0131na(e: eligible) 0 de\u011ferini atam\u0131\u015ft\u0131r. T\u00fcm s\u00fctunlar i\u00e7erisinde bulunan kategorik veriler g\u00f6re say\u0131sal de\u011ferler kullan\u0131larak yeniden tan\u0131mlanm\u0131\u015ft\u0131r.","3b377081":"<a id=\"6\"><\/a> <br>\n### 5.1. Kar\u0131\u015f\u0131kl\u0131k Matrisi (Confusion Matrix) \n\nGer\u00e7ek de\u011ferleri bilinen, s\u0131n\u0131fland\u0131rma algoritmalar\u0131n\u0131n performanslar\u0131n\u0131 \u00f6l\u00e7mek i\u00e7in kullan\u0131lan de\u011ferleri i\u00e7eren matrise \"Kar\u0131\u015f\u0131kl\u0131k Matrisi (Confusion Matrix)\" denir. Kar\u0131\u015f\u0131kl\u0131k matrisi s\u0131n\u0131fland\u0131rmada olu\u015fturulan modelin neyi ne kadar do\u011fru s\u0131n\u0131fland\u0131rd\u0131\u011f\u0131n\u0131 \u00f6l\u00e7mek i\u00e7in kullan\u0131lmaktad\u0131r. \u0130kili bir s\u0131n\u0131fland\u0131rma \u00f6rne\u011finde 2X2 boyutunda bir kar\u0131\u015f\u0131kl\u0131k matrisi hesaplanabilir."}}