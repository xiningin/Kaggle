{"cell_type":{"604b47a0":"code","c3381835":"code","93b0c2b2":"code","b094c385":"code","7c98dae9":"code","ef59da19":"code","40048d38":"code","0c673ebf":"code","ecd1375e":"code","02897ff8":"markdown","8e0c9b6f":"markdown","1ed5d930":"markdown","d3dfd242":"markdown","2e014f4e":"markdown","2356f4bd":"markdown"},"source":{"604b47a0":"#Importing necessary libaries\nimport pandas as pd\nimport numpy as np\nimport torch.optim as optim\nfrom math import sqrt\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as fn","c3381835":"class Net(nn.Module):\n    \n    def __init__(self):\n        super(Net, self).__init__()\n        self.h1 = nn.Linear(14,28)\n        \n        self.h2 = nn.Linear(28,28)\n        \n        self.h3 = nn.Linear(28,28)\n        \n        self.o = nn.Linear(28,1)\n        \n    def forward(self,x):\n            h1 = fn.relu(self.h1(x))\n            h2 = fn.relu(self.h2(h1))    \n            h3 = fn.relu(self.h3(h2))\n            \n            return self.o(h3)\n        ","93b0c2b2":"df = pd.read_csv('..\/input\/uio_clean.csv')\n\ndf= df.drop(['id','vendor_id','store_and_fwd_flag'], axis=1)\ndf.describe()\n# removing outliers or erroneous values i.e. trip duration should be between 20 sec and 3hrs, distance should be\n# between 100m and 100km, trip duration should be greater than wait time\ndf=df[(df['trip_duration'].between(30,7200)) & (df['dist_meters'].between(100,100000)) & (df['trip_duration']>df['wait_sec'])]\ndf=df[df['wait_sec'].between(0,7200)]\ndf=df[(df['pickup_longitude'].between(-80,-77)) & (df['pickup_latitude'].between(-4,1)) & (df['dropoff_longitude'].between(-80,-77))\n      &(df['dropoff_latitude'].between(-4,1))]\ndf.shape[0]\ndf['pickup_datetime'] = pd.to_datetime(df['pickup_datetime'], format='%Y-%m-%d %H:%M:%S')\ndf['dropoff_datetime'] = pd.to_datetime(df['dropoff_datetime'], format='%Y-%m-%d %H:%M:%S')\ndf['hour_of_day']=df['pickup_datetime'].dt.hour\ndf['month'] = df['pickup_datetime'].dt.month\ndf['day_of_week'] = df['pickup_datetime'].dt.dayofweek\ndf['day_of_year'] = df['pickup_datetime'].dt.dayofyear\ndf['week_of_year'] = df['pickup_datetime'].dt.weekofyear\ndf=df.drop(['pickup_datetime','dropoff_datetime'], axis=1)\n\ndf['trip_duration_log'] = np.round(np.log1p(df['trip_duration']), 5)\ndf['dist_meters_log'] = np.round(np.log1p(df['dist_meters']), 5)\ndf['avg_speed'] = df['dist_meters'] \/ df['trip_duration'] \n# avg speed should be between 3m\/s and 30m\/s or 108km\/hr\ndf = df[df['avg_speed'].between(3,30)]\n\ndf=df.dropna()\n\n\n\n#split dependent and independent variable\nX = df.drop(['wait_sec'],axis=1)\n#Taking natural log of the target variable, this helps the model converge better and gives better results\ny = np.log1p(df['wait_sec'])\n\n#Normalization function\n\nXscaler = StandardScaler()\n\n# Spliting the data into training set and testing set in a 80\/20 ratio\n\nX_train, X_test, y_train, y_test = train_test_split(Xscaler.fit_transform(X), y, test_size=0.20, random_state=42)\n# Concatenating X_train and y_train for the mini-batches for training the NN\nZ = np.column_stack((X_train,y_train))\n#A = np.array(A.values,dtype=np.float32)\nZ.shape","b094c385":"\ndef training(Z):\n        learning_rate = 0.001\n        batch_size = 100\n        \n        model = Net()\n        \n        #defining the loss function\n        criterion = nn.SmoothL1Loss()\n        \n        #defining the optimizer\n        optimizer = optim.Adam(model.parameters(), lr=learning_rate)\n\n        #Loop that defines the number of times the data is passed through the network\n\n        for i in range(70):\n            #shuffle the data every time\n            np.random.shuffle(Z)\n            start = 0\n\n            while start < len(Z):\n                #Zero the gradient buffers of all parameters and backprops with random gradients\n                # clear previous gradients\n                optimizer.zero_grad()\n                end = start + batch_size if (start+batch_size) < len(Z) else len(Z)\n                batch = Z[start:end,:]\n                X = np.array(batch[:,:14],dtype=np.float32)\n                y = np.array(batch[:,14],dtype=np.float32)\n                start = end\n\n                #Create a tensor from a numpy.ndarray\n                X = torch.from_numpy(X)\n                y = torch.from_numpy(y)\n                y = y.unsqueeze(1)\n                \n                # Pass the input data through the Net using forward function\n                p = model.forward(X)\n                # Compute loss\n                loss = criterion(p,y) \n                # compute gradients of all variables wrt loss\n                # Propagate gradients back into the network\u2019s parameters\n                loss.backward()\n                # Update the weights of the network\n                # perform updates using calculated gradients\n                optimizer.step()\n            print(loss.item())\n                \n        return model","7c98dae9":"y_test = np.array(y_test.values,dtype=np.float32)\ny_test.shape","ef59da19":"def test(X_test,y_test,model):\n        y_pred = np.zeros(len(y_test))\n        for idx, x in enumerate(X_test):\n                X = np.array(x,dtype=np.float32)\n                \n                X = torch.from_numpy(X)\n\n                X = X.unsqueeze(0)\n                p = model.forward(X)\n                y_pred[idx] = p.item()\n                \n        mae_error = np.abs(y_test - y_pred)\n        return y_pred,mae_error.mean()","40048d38":"# Function call to Train the model\nmodel = training(Z)\n# Function call to test the accuracy on test set\ny_pred,mae_error=test(X_test,y_test,model)","0c673ebf":"print('MAE on test data is',mae_error)","ecd1375e":"y_test_act = np.expm1(y_test)\ny_pred_act = np.expm1(y_pred)\nmae = np.abs(y_test_act - y_pred_act)\nprint(\"The actual mean absolute test error is: \",mae.mean())","02897ff8":"### Testing loop","8e0c9b6f":"### Data pre-processing","1ed5d930":"# Predicting the waiting time for taxi using ANN ","d3dfd242":"### Training function","2e014f4e":"Lets define the network","2356f4bd":"### Define the Network"}}