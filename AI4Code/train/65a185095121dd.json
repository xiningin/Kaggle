{"cell_type":{"4752a279":"code","7f5238b8":"code","0da29693":"code","99d5c374":"code","09950058":"code","c6b5fcd1":"code","036732ff":"code","5fb8023c":"code","7ea60832":"code","d156532f":"code","6ee211d4":"code","2a062150":"code","4aaeface":"code","eb7ba164":"code","2e44d173":"code","9f0ba8d5":"code","4e90aca5":"code","f594e09d":"code","e5da9b7f":"code","c88d7619":"code","d184352e":"code","e3b6cbd4":"code","9e175a2d":"code","66488fe1":"code","763cb5a0":"code","4cd358ab":"code","e587fc76":"markdown","7f3f8a1a":"markdown","56890f18":"markdown","e98c20aa":"markdown","b870b1f1":"markdown","b919e9a9":"markdown","9160a4b8":"markdown","3b9982f8":"markdown","fc1bd5a6":"markdown","ba6d061b":"markdown"},"source":{"4752a279":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Classification Models\nfrom sklearn.svm import SVC\nfrom xgboost import XGBClassifier\nfrom lightgbm import LGBMClassifier\nfrom catboost import CatBoostClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.linear_model import RidgeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.linear_model import LogisticRegression, PassiveAggressiveClassifier\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis\nfrom sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier, ExtraTreesClassifier\n\n# Helper Libraries\nfrom sklearn.pipeline import Pipeline\nfrom imblearn.over_sampling import SMOTE\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import classification_report\nfrom sklearn.model_selection import cross_validate\nfrom imblearn.pipeline import Pipeline as imbpipeline\nfrom sklearn.datasets import make_classification, load_breast_cancer\nfrom sklearn.model_selection import train_test_split, GridSearchCV, StratifiedKFold\nfrom sklearn.metrics import roc_auc_score, accuracy_score, precision_score, recall_score, f1_score\nfrom sklearn.metrics import confusion_matrix, precision_recall_curve, auc, roc_curve, recall_score, classification_report, f1_score\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","7f5238b8":"sns.set(style='darkgrid')\n\ndef get_label(g):\n  for p in g.patches:\n    height = p.get_height()\n    g.text(p.get_x()+p.get_width()\/2.,\n            height\/2,\n            '{}'.format(round(height)),\n            ha=\"center\", color='white')","0da29693":"df = pd.read_csv('..\/input\/haberman-dataset\/haberman.csv')","99d5c374":"df.head()","09950058":"df.shape","c6b5fcd1":"df.info()","036732ff":"df.isna().sum()","5fb8023c":"df1 = df.copy()","7ea60832":"df1['year_of_operation'] = df1['Patient_year_of_operation'].apply(lambda x: x + 1900)\ndf1['year_of_operation'] = df1['year_of_operation'].astype(int)","d156532f":"df1.head()","6ee211d4":"df1['year_of_operation'] = pd.to_datetime(df1['year_of_operation'], format='%Y')","2a062150":"df1.dtypes","4aaeface":"plt.figure(figsize=[15,5]);\ng = sns.countplot(x='Survival_status', data=df)\nget_label(g)","eb7ba164":"plt.figure(figsize=[20,9]);\ng = sns.countplot(x='Age_of_patient_at_time_of_operation', hue='Survival_status', data=df)\nplt.xlabel(\"Age of patient at time fo operation\")","2e44d173":"plt.figure(figsize=[15,6]);\ng = sns.countplot(x=df1['year_of_operation'].dt.year, hue='Survival_status', data=df)\nplt.xlabel(\"year of operation\")\ng.legend([\"survived\", \"Not survived\"]);","9f0ba8d5":"mask = (df['Number_of_positive_axillary_nodes_detected'] <= 10)\nmask1 = (df['Number_of_positive_axillary_nodes_detected'] > 10) & (df['Number_of_positive_axillary_nodes_detected'] <= 30)\nmask2 = (df['Number_of_positive_axillary_nodes_detected'] > 30)\ndf_1 = df.loc[mask]\ndf_2 = df.loc[mask1]\ndf_3 = df.loc[mask2]","4e90aca5":"plt.figure(figsize=[15,6]);\ng = sns.countplot(x='Number_of_positive_axillary_nodes_detected', hue='Survival_status', data=df_1)\nplt.xlabel(\"year of operation\")\ng.legend([\"survived\", \"Not survived\"]);","f594e09d":"plt.figure(figsize=[15,6]);\ng = sns.countplot(x='Number_of_positive_axillary_nodes_detected', hue='Survival_status', data=df_2)\nplt.xlabel(\"year of operation\")\ng.legend([\"survived\", \"Not survived\"]);","e5da9b7f":"class Classifier:\n    Models = {\n        'SVC': SVC(),\n        'LGBMClassifier': LGBMClassifier(),\n        'GaussianNB': GaussianNB(),\n        'SGD': SGDClassifier(),\n        'DecisionTree': DecisionTreeClassifier(),\n        'AdaBoostClassifier': AdaBoostClassifier(),\n        'RidgeClassifier': RidgeClassifier(),\n        'KNeighborsClassifier': KNeighborsClassifier(),\n        'LogisticRegression': LogisticRegression(),\n        'RandomForestClassifier': RandomForestClassifier(),\n        'GradientBoostingClassifier': GradientBoostingClassifier(),\n        'PassiveAggressiveClassifier': PassiveAggressiveClassifier(),\n        'LinearDiscriminantAnalysis': LinearDiscriminantAnalysis(),\n        'QuadraticDiscriminantAnalysis': QuadraticDiscriminantAnalysis(),\n        'CatBoostClassifier': CatBoostClassifier(verbose= False, eval_metric = 'AUC'),\n        'XGBClassifier': XGBClassifier(objective= 'binary:logistic', eval_metric='auc'),\n        'ExtraTreesClassifier': ExtraTreesClassifier()\n    }\n    scaler = StandardScaler()\n    scoring = ['accuracy', 'precision_macro', 'recall_macro' , 'f1_weighted', 'roc_auc']\n    model_results = {\n        'Model': [], 'Fitting time': [], 'Scoring time':[], 'Accuracy':[], 'Precision':[], 'Recall':[], 'F1_Score':[], 'AUC':[]\n    }\n    \n    def __init__(self, data, target):\n        self.df = data\n        self.cols = list(data.columns)\n        self.cols.remove(target)\n        self.scaler.fit(self.df[self.cols])\n        self.target = target\n    \n    def cross_validation(self, model, folds):\n        X = self.scaler.transform(self.df[self.cols])\n        scores = cross_validate(model, X, self.df[self.target], scoring=self.scoring, cv=folds, verbose=False)\n        sorted(scores.keys())\n        return scores['fit_time'].mean(), scores['score_time'].mean(), scores['test_accuracy'].mean(), scores['test_precision_macro'].mean(), scores['test_recall_macro'].mean(),scores['test_f1_weighted'].mean(),scores['test_roc_auc'].mean()\n    \n    def score_models(self, folds = 10):\n        for model_name in self.Models.keys():\n            fit_time, score_time, accuracy, precision, recall, f1_score, auc = self.cross_validation(self.Models[model_name], folds)\n            self.model_results['Model'].append(model_name)\n            self.model_results['Fitting time'].append(fit_time)\n            self.model_results['Scoring time'].append(score_time)\n            self.model_results['Accuracy'].append(accuracy)\n            self.model_results['Precision'].append(precision)\n            self.model_results['Recall'].append(recall)\n            self.model_results['F1_Score'].append(f1_score)\n            self.model_results['AUC'].append(auc)\n        \n        return pd.DataFrame(self.model_results)","c88d7619":"pipeline = Classifier(df, 'Survival_status')\nresults = pipeline.score_models()","d184352e":"results.sort_values(by='AUC', ascending=False)","e3b6cbd4":"plt.figure(figsize=(15,5))\n\nfor col in list(results.columns):\n    if col=='AUC' or col=='Accuracy':\n        plt.plot(results['Model'], results[col], '-o', label = col)\n\nplt.title('Mean Score with different params')\nplt.xticks(rotation=90)\nplt.grid(True)\nplt.legend()\nplt.show()","9e175a2d":"cols = list(df.columns)\ncols.remove('Survival_status')","66488fe1":"X_train, X_test, y_train, y_test = train_test_split(df[cols], df['Survival_status'], test_size=0.1, stratify=df['Survival_status'], random_state=123)","763cb5a0":"smote = SMOTE(random_state = 123)\nX_train, y_train = smote.fit_resample(X_train, y_train)","4cd358ab":"pipeline = Pipeline(steps = [['scaler', MinMaxScaler()],\n                             ['classifier', LogisticRegression(random_state=11, max_iter=1000)]])\n\nstratified_kfold = StratifiedKFold(n_splits=10, shuffle=True, random_state=11)\n\nparam_grid = {'classifier__C':[0.001, 0.01, 0.1, 1, 10, 100, 1000]}\n\ngrid_search = GridSearchCV(estimator=pipeline,\n                           param_grid=param_grid,\n                           scoring='roc_auc',\n                           cv=stratified_kfold,\n                           n_jobs=-1)\n\ngrid_search.fit(X_train, y_train)\ncv_score = grid_search.best_score_\ntest_score = grid_search.score(X_test, y_test)\nprint(f'Cross-validation score: {cv_score}')","e587fc76":"# **LOADING DATA**","7f3f8a1a":"# **IMPORTS**","56890f18":"# **Oversampling using SMOTE**","e98c20aa":"# **Classification Pipeline**","b870b1f1":"1. Age of patient at time of operation (numerical)\n2. Patient's year of operation (year - 1900, numerical)\n3. Number of positive axillary nodes detected (numerical)\n4. Survival status (class attribute)\n\n  1 = the patient survived 5 years or longer\n\n  2 = the patient died within 5 year\n","b919e9a9":"# **EXPLORATORY DATA ANALYSIS**","9160a4b8":"# **FEATURE ENGENNERING**","3b9982f8":"# **DATA DESCRIPTION**","fc1bd5a6":"# **GridSearch Pipeline**","ba6d061b":"# **RESULTS**"}}