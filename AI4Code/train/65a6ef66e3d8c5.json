{"cell_type":{"b483d7c9":"code","4b8e4f27":"markdown"},"source":{"b483d7c9":"from sklearn.impute import MissingIndicator\n\ndef cleanup2(X):\n    \"\"\"\n    Fixes the numerical features. \n    \n    \n    Each feature has different specific problems, but they usually have\n    garbage values (usually zero) that should really be read as NANs.\n    \n    I want to fix those values, but I also want to take note of the \n    datapoints where they happened.  I do this because I assume that \n    missing values tell us something about the well that our model\n    might be able to pick up later.\n    \n    \n    Parameters\n    ----------\n    X : pandas.DataFrame\n        DF with raw numerical features\n    \n    Returns\n    ----------\n    X2 : pandas.DataFrame\n         DF with cleaned numerical features and a new matrix of former\n         garbage locations within those features.\n    \n    \"\"\"\n    \n    \n    # Make a clean copy, to ensure we're not changing the original DF\n    X2 = X.copy()\n    \n    # I make a list of the numerical columns and a dict of their \n    # garbage values that really should be nulls\n    numericals = ['amount_tsh',\n                    'date_recorded',\n                    'gps_height',\n                    'longitude',\n                    'latitude',\n                    'num_private',\n                    'population',\n                    'construction_year']\n\n    null_values = {'amount_tsh':0,\n                     'date_recorded':0,\n                     'gps_height':0,\n                     'longitude':0,\n                     'latitude':-2.000000e-08,\n                     'num_private':0,\n                     'population':0,\n                     'construction_year':0}\n\n    # I replace all garbage values with NANs.\n    for feature, null in null_values.items():\n        X2[feature] = X2[feature].replace(null, np.nan)\n\n    # construction_year occasionally claims years far in the future, and \n    # could presumably also contain years way in the past.  I'll turn anything\n    # not between 1960 and 2019 into a NAN.\n    X2['construction_year'] = [i if 1960 < i < 2019 else np.nan for i in X2['construction_year']]\n    \n    \n    # Creating indicator columns.\n    # ---------------------------------------------------------------\n    # These columns mark the locations of all the NANs \n    # in the numericals. Note that MissingIndicator returns a numpy array.\n    \n    indicator = MissingIndicator()\n    trash_array = indicator.fit_transform(X2[numericals]) # Bool array\n    trash_array = trash_array.astype('float64')     # Float64 array\n\n    # Create a titles for the columns in num_trashmarker\n    trashy_names = [numericals[i] + '_trash' for i in indicator.features_]\n\n    # Create num_trashmarker\n    trash_df = pd.DataFrame(trash_array, columns=trashy_names)\n\n    # I add trash_df to X2\n    X2 = pd.concat([X2,trash_df], sort=False, axis=1)\n    \n    \n    # Fixing the numerical columns.\n    # ---------------------------------------------------------------\n    # Whenever possible, a good replacement value for a NAN is the \n    # mean or median value for the geographic region around it.\n\n    # Replaces the NANs in a ward with the mean of the other rows in that \n    # same ward. If all the rows in a ward are NANs, though, they remain.\n    for feature in numericals:\n        replacements = X2.groupby('ward')[feature].transform('mean')\n        X2[feature] = X2[feature].fillna(replacements)\n\n    # Replaces the NANs in a region with the mean of the other rows in that \n    # same region (which are much larger than wards)\n    for feature in numericals:\n        replacements = X2.groupby('region')[feature].transform('mean')\n        X2[feature] = X2[feature].fillna(replacements)\n    \n    return X2","4b8e4f27":"My [previous kernel](https:\/\/www.kaggle.com\/danielmartinalarcon\/it-ain-t-much) contained a basic cleaning function that produces a minimum viable dataset for regression.  This cleaner works independently, and cleans up your numerical features."}}