{"cell_type":{"30c991e3":"code","4aa1c547":"code","69fd8c13":"code","68a65841":"code","3c6e17e9":"code","df0de1dc":"code","dcf8655a":"code","8d931ddf":"code","8b0507a1":"code","738a5af6":"code","36f79211":"code","2cb5c8a7":"code","84d94ed3":"code","d88de502":"code","d504fa17":"code","3dc598bf":"code","e73cd1d7":"code","42134a8d":"code","cd9f78b2":"code","576767c8":"code","15f4e671":"code","7fc850fc":"code","762cd793":"code","43fee1c0":"code","67fb6a58":"code","403ff17c":"code","1ec4167c":"code","79c63d9b":"code","8d917e57":"markdown","f16c31c8":"markdown","851cd33d":"markdown","bf402a50":"markdown","dcf8a0ea":"markdown","f1747b9e":"markdown","8fe05a76":"markdown","bfd90360":"markdown","d805b234":"markdown","bfe9bb3f":"markdown","e48522a6":"markdown","e04f4099":"markdown","5fa16638":"markdown","6b5fdda6":"markdown","3b057d3f":"markdown","25cf7e44":"markdown","b44123ed":"markdown","b26c8626":"markdown","278b82eb":"markdown","12fd849c":"markdown","721d34c6":"markdown","c6f48de6":"markdown","96e01289":"markdown","3a5f21e3":"markdown","a54fd4a8":"markdown","cd05f115":"markdown"},"source":{"30c991e3":"\"\"\"\nCreated on Tue Jul 10 13:46:33 2018\nhttps:\/\/www.kaggle.com\/uciml\/indian-liver-patient-records\n@author: devp\n\"\"\"\n# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\n# import os\n# print(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","4aa1c547":"filepath = '..\/input\/indian_liver_patient.csv'","69fd8c13":"data = pd.read_csv(filepath)","68a65841":"data.head()","3c6e17e9":"from matplotlib import pyplot as plt\n%matplotlib inline\nimport seaborn as sns","df0de1dc":"data1 = data[data['Dataset']==2] # no disease (original dataset had it labelled as 2 and not 0)\ndata1 = data1.iloc[:,:-1]\n\ndata2 = data[data['Dataset']==1] # with disease\ndata2 = data2.iloc[:,:-1]\n\nfig = plt.figure(figsize=(10,15))\n\nax1 = fig.add_subplot(211)\nax2 = fig.add_subplot(212,sharex=ax1)\n\nax1.grid()\nax2.grid()\n\nax1.set_title('Features vs mean values',fontsize=13,weight='bold')\nax1.text(200,0.8,'NO DISEASE',fontsize=20,horizontalalignment='center',color='green',weight='bold')\n\n\nax2.set_title('Features vs mean values',fontsize=13,weight='bold')\nax2.text(200,0.8,'DISEASE',fontsize=20,horizontalalignment='center',color='red',weight='bold')\n\n# for axis ax1\nplt.sca(ax1)\nplt.xticks(rotation = 0, \n           weight='bold', \n           family='monospace',\n           size='large')\nplt.yticks( weight='bold', \n           family='monospace',\n           size='large')\n# for axis ax2\nplt.sca(ax2)\nplt.xticks(rotation = 0, \n           weight='bold', \n           family='monospace',\n           size='large')\nplt.yticks( weight='bold', \n           family='monospace',\n           size='large')\n\n# sns.set_style('whitegrid')\n\nsns.barplot(data=data1,ax=ax1,orient='horizontal', palette='bright') # no disease\nsns.barplot(data=data2,ax=ax2,orient='horizontal',palette='bright',saturation=0.80) # with disease\n\n\n","dcf8655a":"with_disease = data[data['Dataset']==1]\n\nwith_disease = with_disease.drop(columns=['Gender','Age','Dataset'])\nnames1 = with_disease.columns.unique()\nmean_of_features1 = with_disease.mean(axis=0,skipna=True)\n\n\nwithout_disease = data[data['Dataset']==2]\n\nwithout_disease = without_disease.drop(columns=['Gender','Age','Dataset'])\nnames2 = without_disease.columns.unique()\nmean_of_features2 = without_disease.mean(axis=0,skipna=True)\n\npeople = []\n\nfor x,y in zip(names1,mean_of_features1):\n    people.append([x,y,'Diseased'])\nfor x,y in zip(names2,mean_of_features2):\n    people.append([x,y,'Healthy'])\n    \nnew_data = pd.DataFrame(people,columns=['Chemicals','Mean_Values','Status'])\n\n#ValueError: If using all scalar values, you must pass an index\n#https:\/\/stackoverflow.com\/questions\/17839973\/construct-pandas-dataframe-from-values-in-variables\n\nfig = plt.figure(figsize=(20,8))\nplt.title('Comparison- Diseased vs Healthy',size=20,loc='center')\nplt.xticks(rotation = 30, \n           weight='bold', \n           family='monospace',\n           size='large')\nplt.yticks( weight='bold', \n           family='monospace',\n           size='large')\n\ng1 = sns.barplot(x='Chemicals',y='Mean_Values',hue='Status',data=new_data,palette=\"RdPu_r\")\nplt.legend(prop={'size': 20})\nplt.xlabel('Chemicals',size=19)\nplt.ylabel('Mean_Values',size=19)\n\nnew_data","8d931ddf":"# create data\nwith_disease = data[data['Dataset']==1]\nwith_disease = with_disease.drop(columns=['Dataset','Gender','Age'])\nnames = with_disease.columns.unique()\nmean_of_features = with_disease.mean(axis=0,skipna=True)\n\n# I couldn't find a way to automize this list process\n# the goal was to arrange numbers in such a way that numbers that are very small compared to \n# others do not stay together\n# that is the smaller numbers be embedded between larger numbers\n# this helps to visualize pie plot clearly\n\nlist_names = ['Total_Bilirubin','Alkaline_Phosphotase','Direct_Bilirubin','Albumin','Alamine_Aminotransferase',\n              'Total_Protiens','Aspartate_Aminotransferase','Albumin_and_Globulin_Ratio']\nlist_means = [4.164423076923075,319.00721153846155,1.923557692307693,3.0605769230769226,\n             99.60576923076923,6.459134615384617,137.69951923076923,0.9141787439613527]\n\nl_names = []\nl_means = []\nmydict = {}\nfor x,y in zip(names,mean_of_features):\n    mydict[x]=y\n    l_names.append(x)\n    l_means.append(y)\n\n\nfig = plt.figure()\nplt.title('Percentage of Chemicals in Unhealthy People',size=20,color='#016450')\n# Create a pieplot\nplt.axis('equal')\nexplode = (0.09,)*(len(list_means))\ncolor_pink=['#7a0177','#ae017e','#dd3497','#f768a1','#fa9fb5','#fcc5c0','#fde0dd','#fff7f3']\n\nwedges, texts, autotexts = plt.pie( list_means,\n                                    explode=explode,\n                                    labels=list_names, \n                                    labeldistance=1,\n                                    textprops=dict(color='k'),\n                                    radius=2.5,\n                                    autopct=\"%1.1f%%\",\n                                    pctdistance=0.7,\n                                    wedgeprops = { 'linewidth' : 3, 'edgecolor' : 'white' })\n\nplt.setp(autotexts,size=17)\nplt.setp(texts,size=12)\n\n# plt.show() # don't show pie here [leave it commented]\n \n# add a circle at the center\nmy_circle=plt.Circle( (0,0), 1, color='white')\np=plt.gcf() # get current figure reference\np.gca().add_artist(my_circle) # get current axes\n\nplt.show()","8b0507a1":"fig= plt.figure(figsize=(15,6),frameon=False) # I don't know why figure boundary is still visible\nplt.title(\"Total Data\",loc='center',weight=10,size=15)\nplt.xticks([]) # to disable xticks\nplt.yticks([]) # to disable yticks\nax1 = fig.add_subplot(121)\nax2 = fig.add_subplot(122)\n\nonly_gender = data['Gender']\n\nmale_tot = only_gender[only_gender=='Male']\n\nno_of_male = len(male_tot)\nno_of_female = len(data) - len(male_tot)\n\nm_vs_f = [no_of_male,no_of_female]\n\n\nwith_disease = data[data['Dataset']==1]\nnot_with_disease = data[data['Dataset']==2]\n\nwith_disease = with_disease['Gender']\n\nno_of_diseased = len(with_disease)\nno_of_not_diseased = len(data) - len(with_disease)\n\nd_vs_healthy = [no_of_diseased,no_of_not_diseased]\n\n\n'''\nBy default, plots have more pixels along one axis over the other.\nWhen you add a circle, it's traditionally added in data units. \nIf your axes have a symmetric range, that means one step along the x axis \nwill involve a different number of pixels than one step along your y axis. \nSo a symmetric circle in data units is asymmetric in your Pixel units (what you actually see).\n'''\n\n# you can force the x and y axes to have equal number of pixels per data unit. \n# This is done using the plt.axis(\"equal\") or ax.axis(\"equal\") methods \n# (where ax is an instance of an Axes). \n\nax1.axis('equal')\nax2.axis('equal')\n\n# pie plot\nwedges, texts, autotexts= ax1.pie(m_vs_f, \n                                  labels=('Male','Female'),\n                                  radius=1,\n                                  textprops=dict(color='k'),\n                                  colors=['xkcd:ocean blue','xkcd:dark pink'],\n                                  autopct=\"%1.1f%%\")\n\n# pie plot\nwedges2, texts2, autotexts2 = ax2.pie(d_vs_healthy, \n                                  labels=('Diseased','Not Diseased'),\n                                  radius=1,\n                                  textprops=dict(color='k'),\n                                  colors=['#d95f02','#1b9e77'],\n                                  autopct=\"%1.1f%%\")\n\n\nplt.setp(autotexts,size=20)\nplt.setp(texts,size=20)\n\n\nplt.setp(autotexts2,size=20)\nplt.setp(texts2,size=20)\n\n","738a5af6":"fig= plt.figure(figsize=(15,6))\nax1 = fig.add_subplot(121)\nax2 = fig.add_subplot(122)\n\nwith_disease = data[data['Dataset']==1]\nnot_with_disease = data[data['Dataset']==2]\n\nwith_disease_m = with_disease[with_disease['Gender']=='Male']\nwith_disease_m = with_disease['Gender']\nnot_with_disease_m = not_with_disease[not_with_disease['Gender']=='Male']\nnot_with_disease_m = not_with_disease['Gender']\n\nwith_disease_f = with_disease[with_disease['Gender']=='Female']\nnot_with_disease_f = not_with_disease[not_with_disease['Gender']=='Female']\n\nno_of_diseased_m = len(with_disease_m)\nno_of_not_diseased_m = len(not_with_disease_m)\n\nno_of_diseased_f = len(with_disease_f)\nno_of_not_diseased_f = len(not_with_disease_f)\n\nd_vs_healthy_m = [no_of_diseased_m, no_of_not_diseased_m]\nd_vs_healthy_f = [no_of_diseased_f, no_of_not_diseased_f]\n\nax1.axis('equal')\nax2.axis('equal')\n# pie plot\n\nwedges, texts, autotexts = ax1.pie(d_vs_healthy_m, \n                                  labels=('Diseased','Not Diseased'),\n                                  radius=1,\n                                  textprops=dict(color='k'),\n                                  colors=['#f46d43','#4575b4'],\n                                  autopct=\"%1.1f%%\")\n\nwedges2, texts2, autotexts2 = ax2.pie(d_vs_healthy_f, \n                                  labels=('Diseased','Not Diseased'),\n                                  radius=1,\n                                  textprops=dict(color='k'),\n                                  colors=['#f46d43','#4575b4'],\n                                  autopct=\"%1.1f%%\")\n\nplt.setp(autotexts,size=20)\nplt.setp(texts,size=20)\n\nplt.setp(autotexts2,size=20)\nplt.setp(texts2,size=20)\n\nax1.text(0,0.04,'Male',size=20,color='#f7fcfd',horizontalalignment='center',weight='bold')\nax2.text(0,0.04,'Female',size=20,color='#f7fcfd',horizontalalignment='center',weight='bold')","36f79211":"X = data.iloc[:,:-1].values\nt = data.iloc[:,-1].values","2cb5c8a7":"for u in range(len(t)):\n    if t[u] == 2:\n        t[u] = 0","84d94ed3":"from sklearn.preprocessing import LabelEncoder\nlbl = LabelEncoder()\nX[:,1] = lbl.fit_transform(X[:,1])","d88de502":"data.isnull().any()","d504fa17":"data['Albumin_and_Globulin_Ratio'].isnull().sum()","3dc598bf":"missing_values_rows = data[data.isnull().any(axis=1)]\nprint(missing_values_rows)","e73cd1d7":"from sklearn.preprocessing import Imputer\nimp = Imputer(missing_values='NaN', strategy='mean', axis=0)\nX[:,9:10] = imp.fit_transform(X[:,9:10])","42134a8d":"from sklearn.model_selection import train_test_split\nX_train, X_test, t_train, t_test = train_test_split(X,t,random_state=0,test_size=0.25)","cd9f78b2":"from sklearn. preprocessing import StandardScaler\nsc = StandardScaler()\nX_train[:,2:] = sc.fit_transform(X_train[:,2:])\nX_test[:,2:] = sc.transform(X_test[:,2:])","576767c8":"from sklearn.metrics import accuracy_score\nfrom sklearn.metrics import confusion_matrix","15f4e671":"from sklearn.linear_model import LogisticRegression\n# creating object of LogisticRegression class\nclassifier_logis = LogisticRegression(random_state=0)\n# fitting the model\/ training the model on training data (X_train,t_train)\nclassifier_logis.fit(X_train,t_train)\n# predicting whether the points (people\/rows) in the test set (X_test) have the liver disease or not\ny_pred_logis = classifier_logis.predict(X_test)\n# evaluating model performance by confusion-matrix\ncm_logis = confusion_matrix(t_test,y_pred_logis)\nprint(cm_logis)\n# accuracy-result of LogisticRegression model\naccuracy_logis = accuracy_score(t_test,y_pred_logis)\nprint('The accuracy of LogisticRegression is : ', str(accuracy_logis*100) , '%')","7fc850fc":"from sklearn.svm import SVC\n# creating object of SVC class\nclassifier_svc = SVC(kernel='rbf', random_state=0, gamma='auto')\n# fitting the model\/ training the model on training data (X_train,t_train)\nclassifier_svc.fit(X_train,t_train)\n# predicting whether the points (people\/rows) in the test set (X_test) have the liver disease or not\ny_pred_svc = classifier_svc.predict(X_test)\n# evaluating model performance by confusion-matrix\ncm_svc = confusion_matrix(t_test,y_pred_svc)\nprint(cm_svc)\n# accuracy-result of SVC model\naccuracy_svc = accuracy_score(t_test,y_pred_svc)\nprint('The accuracy of SupportVectorClassification is : ', str(accuracy_svc*100) , '%')","762cd793":"from sklearn.ensemble import RandomForestClassifier\n# creating object of RandomForestClassifier class\nclassifier_rfc = RandomForestClassifier(n_estimators=250, criterion='entropy',random_state=0 )\n# fitting the model\/ training the model on training data (X_train,t_train)\nclassifier_rfc.fit(X_train,t_train)\n# predicting whether the points (people\/rows) in the test set (X_test) have the liver disease or not\ny_pred_rfc = classifier_rfc.predict(X_test)\n# evaluating model performance by confusion-matrix\ncm_rfc = confusion_matrix(t_test,y_pred_rfc)\nprint(cm_rfc)\n# accuracy-result of RandomForestClassifier model\naccuracy_rfc = accuracy_score(t_test,y_pred_rfc)\nprint('The accuracy of RandomForestClassifier is : ', str(accuracy_rfc*100) , '%')","43fee1c0":"models_comparison = [['Logistic Regression',accuracy_logis*100],\n                     ['Support Vector Classfication',accuracy_svc*100], \n                     ['Random Forest Classifiaction',accuracy_rfc*100]\n                    ]\nmodels_compaison_df = pd.DataFrame(models_comparison,columns=['Model','% Accuracy'])\nmodels_compaison_df.head()","67fb6a58":"fig = plt.figure(figsize=(20,8))\nsns.set()\nsns.barplot(x='Model',y='% Accuracy',data=models_compaison_df,palette='Dark2')\nplt.xticks(size=18)\nplt.ylabel('% Accuracy',size=14)\nplt.xlabel('Model',size=14)","403ff17c":"def n_trees_acc(n):\n    classifier_rfc = RandomForestClassifier(n_estimators=n, criterion='entropy',random_state=0 )\n    classifier_rfc.fit(X_train,t_train)\n    y_pred_rfc = classifier_rfc.predict(X_test)\n    accuracy_rfc = accuracy_score(t_test,y_pred_rfc)\n    return accuracy_rfc*100","1ec4167c":"n_trees = [10,50,100,200,250,400,500,1000]\nn_trees_acc_score = list(map(n_trees_acc,n_trees))\nprint(n_trees_acc_score)","79c63d9b":"d1 = []\nfor (x,y) in zip(n_trees,n_trees_acc_score):\n    d1.append([x,y])\nd2 = pd.DataFrame(d1,columns=['no. of trees in forest','% accuracy'])\nfig = plt.figure(figsize=(20,6))\nsns.pointplot(x='no. of trees in forest',y='% accuracy',data=d2,color='#41ab5d')\nplt.title('Trees in Forest vs Accuracy',size=18)\nplt.xlabel('no. of trees in forest',size=15)\nplt.ylabel('% accuracy',size=15)\nplt.grid()","8d917e57":"## Visualizing the features of each category of people (healthy\/unhealthy)","f16c31c8":"## Male vs Female statistics","851cd33d":"## Analysing the effect of number of trees in Random forest to its accuracy","bf402a50":"## Comparing Model Performance","dcf8a0ea":"## Visualizing the differences in chemicals in Healthy\/Unhealthy people","f1747b9e":"# Machine Learning","8fe05a76":"Output variable (target)\n\n**1** means **having liver disease**\n\n**2** means **not having liver disease**\n\n***We need to convert all 2's into zeroes for confusion-matrix calulations***","bfd90360":"**Choosing colors**\n\nhttps:\/\/xkcd.com\/color\/rgb\/\n\nhttps:\/\/matplotlib.org\/api\/colors_api.html\n\ncolor visualize online for data types - categorical, sequential, divergent\n\nhttp:\/\/colorbrewer2.org\/#type=qualitative&scheme=Set2&n=3","d805b234":"**We need to separate the target values from the rest of the table**","bfe9bb3f":"**plotting tools**","e48522a6":"**Logistic Regression**","e04f4099":"## Label encoding","5fa16638":"**Gender column has entries as Male and Female.  For a mathematical model to learn, we have to encode these into numbers.**","6b5fdda6":"**Here we fill it by mean of the values of that corresponding column**","3b057d3f":"## Fill the missing rows with values","25cf7e44":"## Other statistics of dataset","b44123ed":"**Let's check how many entries have a NaN (Not a Number) or missing values**","b26c8626":"**Importing Model Evaluation metrics**","278b82eb":"**Random Forest Classification**","12fd849c":"https:\/\/stackoverflow.com\/questions\/9230389\/why-is-matplotlib-plotting-my-circles-as-ovals","721d34c6":"## Traning and Predictions","c6f48de6":"**Support Vector Machine - Classification**","96e01289":"## Feature Scaling\n\n**Standardisation** is applied to all rows of all columns **except the age and the gender column**.\n","3a5f21e3":"## Training and Testing data\nLet's partition our dataset into **training data** and **testing data**\n\nHere, we keep 25% data as testing data.","a54fd4a8":"# Analyzing DataSet","cd05f115":"## Percentage of Chemicals in Unhealthy People"}}