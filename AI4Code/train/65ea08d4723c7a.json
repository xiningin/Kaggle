{"cell_type":{"548dcc70":"code","17178105":"code","41e23044":"code","0569af2c":"code","f96eeffb":"code","c0f6baa6":"code","d393f90e":"code","312439f4":"code","b20aa8f9":"code","b39ecbee":"code","8ab90570":"code","75521b68":"code","d68e4bd8":"code","2d9d7db4":"code","a34bad0d":"code","847e5005":"code","95649da0":"code","a2d612fe":"code","db30ba92":"code","21501622":"code","099d4606":"code","bfcbe555":"code","4a531207":"code","dc5a3bd9":"code","f017c7f7":"code","89b503af":"code","74c248e3":"code","ef376b07":"code","c7acae1b":"code","c3cfe4de":"code","8c6d497a":"code","bd024323":"code","674a177c":"code","fd3f2ef0":"code","e36f5fe3":"code","064aa361":"code","e4c9c0d5":"code","912d3db7":"code","cfd4a69c":"code","d2563825":"code","b9865242":"code","3c008a9e":"code","f62f9ae9":"code","9380a205":"code","4daecc84":"code","aaf9f666":"code","4544a3f4":"code","ce084d4c":"code","2632596b":"code","f70b3c6e":"code","5eb1214c":"code","d75d930c":"code","cc2463ca":"code","9e1fb9c5":"code","2bc90e3a":"code","bf4190cd":"code","52f9681d":"code","ff64bedb":"code","0c827edb":"code","a7fb2707":"code","beb6b090":"code","e3ef39a2":"code","8f8b2ebc":"code","cebb9392":"code","fc98c49b":"code","dfab3eb8":"code","0bb56fd3":"code","a038beb1":"code","0eac9fed":"code","8da7b682":"code","a912211e":"code","6850ab99":"code","fb94f1da":"code","dc95be5d":"code","e2b0ae99":"code","4e7db04e":"code","21f56ac3":"code","251ef063":"code","b2f03e70":"code","d100d3ec":"code","00efdcca":"code","a8aef11a":"code","82c7f968":"code","4ff252eb":"code","02b6720c":"code","36faaf33":"code","e7b095fb":"code","7a816e32":"code","7344e1bc":"code","f068dc52":"code","443d837c":"code","3872ccf8":"code","b10cc3cb":"code","19cb2db7":"code","20003621":"code","6effb499":"code","a1e0e8c7":"code","97e7c42d":"code","585522f0":"code","8c8395d6":"code","61dd3c60":"code","04c5f9d4":"code","c41e0c08":"code","a95ea0d6":"code","d3524dd2":"code","927b0642":"code","f029cee7":"code","a48b5b5f":"code","41290f00":"code","52f6e631":"code","21d65dbe":"code","1db23195":"code","05cc26a5":"code","cbf7c2a8":"code","6bf02124":"code","ddd2b6cb":"code","542e6591":"code","df303419":"code","1e4238fe":"code","a3ef7830":"code","ee84131f":"code","0d2a0293":"code","a60207e8":"code","7b5f31c5":"code","8a5e1ecd":"code","9deb1ca1":"code","fa55284c":"code","957c2df9":"code","d3442038":"code","0e7de0d2":"code","b21d7ed6":"code","4959ac2b":"code","46d42d53":"code","581e4e1f":"code","a28b6056":"code","42fa0601":"code","0e63c934":"code","a5710f6c":"code","8137f10f":"code","841a6770":"code","679e7d3a":"code","cc99909a":"code","e0c6d75f":"code","8c71b996":"code","36c58bb8":"code","087aaad1":"code","a8a2d802":"code","5d9b7eec":"code","e9dd4a28":"code","817534ab":"code","459cb527":"code","469c58d8":"code","90dbe35f":"code","3584de87":"code","495e70be":"code","1f87fb4e":"code","37d2d872":"code","e07cb408":"code","34e92996":"code","486b0f60":"code","2d87b136":"code","fa65eaf0":"code","fdebb640":"code","81a6bdee":"code","1589ad81":"code","2841d92f":"code","8cf8f95e":"code","5d643216":"code","80992e9f":"code","1f8776f8":"code","8d4cdbf1":"code","b1af5a0f":"code","29f4d78a":"code","63b4a283":"code","dd66c9a8":"code","e79ef44d":"code","61e74187":"code","cd57dcb7":"code","5b0ec349":"code","f9554fe1":"code","5e0fd49e":"code","2e76196c":"code","19ae4c16":"code","aae06b15":"code","d421a70e":"code","a4ca788a":"code","6bd3c15d":"code","fe820661":"code","1475e71c":"code","b934c827":"code","c1b55465":"code","73723120":"code","12baff2f":"markdown","7b616cd9":"markdown","5f8987f3":"markdown","0c03a624":"markdown","a0f7aa75":"markdown","e65c195e":"markdown","b2580348":"markdown","d319e981":"markdown","b0aaee43":"markdown","1ddab8ae":"markdown","ce420696":"markdown","ef26ed41":"markdown","2d32a1d0":"markdown","8c6ea438":"markdown","fa3cbcd3":"markdown","34d8f2a2":"markdown","85460c8e":"markdown","3866ca00":"markdown","ad71d900":"markdown","91552f98":"markdown","25127cf8":"markdown","5718a618":"markdown","cf3f1645":"markdown","cdb0722d":"markdown","d13481a1":"markdown","38726604":"markdown","24034a55":"markdown","d4800521":"markdown","4925637c":"markdown","4e974248":"markdown","9341fb23":"markdown","742f1a27":"markdown","6dbbf749":"markdown","907e099c":"markdown","4783d868":"markdown","bddb80dd":"markdown","92276706":"markdown","e695c839":"markdown","4ad68c82":"markdown","c96eb4bd":"markdown","90617d91":"markdown","49eb550a":"markdown","ea777423":"markdown","014805a3":"markdown","88d08f2c":"markdown","7f9c981d":"markdown","a38f0320":"markdown","f0894027":"markdown","7960728f":"markdown","f8735e96":"markdown","1297b654":"markdown","d9bb660a":"markdown","2f8342dd":"markdown","ffbc899e":"markdown","9e9f69c7":"markdown","d748b588":"markdown","96b26863":"markdown","b1023f0a":"markdown","dca66917":"markdown"},"source":{"548dcc70":"from IPython.display import Image\nImage('..\/input\/easymoneygrupo5\/dashboard_structure.png', height = 300) ","17178105":"!pip install xlrd","41e23044":"# DataFrame y matrices\nimport numpy as np \nimport pandas as pd\n\nimport os\n\n# Visualizacion\nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport folium\nimport plotly.express as px\nimport plotly.graph_objects as go\n\n# Mapa\nimport folium\n\n# Tree map\nimport squarify \n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\npd.options.display.float_format = '{:,.2f}'.format","0569af2c":"PATH_DATA = \"..\/input\/easymoneygrupo5\/\"\n#PATH_DATA = '\/content\/drive\/MyDrive\/Nuclio Data Science - Proyecto Final\/data\/'\n#PATH_DATA = '\/Users\/carlosperezricardo\/Documents\/data\/'","f96eeffb":"#from google.colab import drive\n#drive.mount('\/content\/drive')","c0f6baa6":"products = pd.read_csv(PATH_DATA+'products_df.csv')\nproducts.drop('Unnamed: 0', axis=1, inplace=True)\nproducts.head(3).T","d393f90e":"products.info()","312439f4":"# Codificar variables logicas (1\/0 = bool)\nboolean_cols = [\"short_term_deposit\", \"loans\", \"mortgage\", \"funds\", \"securities\", \"long_term_deposit\", \"em_account_pp\", \"credit_card\", \"payroll_account\", \"emc_account\", \"debit_card\", \"em_account_p\", \"em_acount\", \"payroll\", \"pension_plan\"] \n# payroll y pension_plan tienen nulos en el dataset completo\n\nfor x in boolean_cols:\n    products[x] = products[x].astype(bool)\n    \nproducts_sorted = products.sort_values(by=['pk_cid', 'pk_partition'])","b20aa8f9":"partitions = ['2018-01-28','2018-02-28','2018-03-28','2018-04-28','2018-05-28','2018-06-28','2018-07-28','2018-08-28','2018-09-28','2018-10-28','2018-11-28','2018-12-28','2019-01-28','2019-02-28','2019-03-28','2019-04-28','2019-05-28']\nlist_products = [\"short_term_deposit\", \"loans\", \"mortgage\", \"funds\", \"securities\", \"long_term_deposit\", \"em_account_pp\", \"credit_card\",  \"pension_plan\", \"payroll_account\", \"emc_account\", \"debit_card\", \"em_account_p\", \"em_acount\"]","b39ecbee":"def altas_bajas_contrataciones( products_sorted, prod ):\n\n  prod_df = pd.DataFrame()\n\n  prev_month2 = 'prev_month'\n  prev_month1 = 'prev_month'\n  col_diff = 'diff'\n\n  prod_df = products_sorted.loc[:,['pk_cid','pk_partition',prod]] # para evitar warning\n  prod_df['prev_month1'] = prod_df.groupby('pk_cid')[prod].shift(1)\n  prod_df['prev_month2'] = prod_df.groupby('pk_cid')[prod].shift(2)\n  prod_df['prev_month3'] = prod_df.groupby('pk_cid')[prod].shift(3)\n  #prod_df['diff'] = prod_df.loc[:,prod] - prod_df.loc[:,'prev_month1']\n\n  prod_df.fillna(-2, inplace=True)\n\n  ## ALTAS\n  # nuevas contrataciones (nuevas de este mes a\u00fan por cobrar - llevan 1 mes)\n  cond1 = (prod_df[prod]==1) & ((prod_df['prev_month1'] == 0) | ((prod_df['prev_month1'] == -2) & (prod_df['pk_partition']!='2018-01-28')))\n  nuevas_contrataciones = prod_df[ cond1 ] \n  #nuevas_contrataciones = prod_df[ prod_df[ 'diff' ] == 1 ] \n  nuevas_contrataciones = nuevas_contrataciones.groupby(['pk_partition'])['pk_cid'].count().sort_index()\n\n  # nuevas contrataciones (del mes anterior a\u00fan por cobrar - llevan 2 meses y no se han dado de baja)\n  cond2 = (prod_df[prod]==1) & (prod_df['prev_month1']==1) & ((prod_df['prev_month2']==0) | ((prod_df['prev_month2'] == -2) & (prod_df['pk_partition']!='2018-02-28')))\n  contrataciones_pendientes = prod_df[ cond2 ] \n  contrataciones_pendientes = contrataciones_pendientes.groupby(['pk_partition'])['pk_cid'].count().sort_index()\n\n  # nuevas contrataciones (ya cobrados - llevan 3 meses y no se han dado de baja)\n  cond3 = (prod_df[prod]==1) & (prod_df['prev_month1']==1) & (prod_df['prev_month2']==1) & ((prod_df['prev_month3']==0) | ((prod_df['prev_month3'] == -2) & (prod_df['pk_partition']!='2018-03-28')))\n  contrataciones_cobradas = prod_df[ cond3 ] \n  contrataciones_cobradas = contrataciones_cobradas.groupby(['pk_partition'])['pk_cid'].count().sort_index()\n\n  ## BAJAS\n  # bajas de contrataciones no cobradas\n  cond41 = (prod_df[prod]==0) & (prod_df['prev_month1']==1) & (prod_df['prev_month2']==0) & (prod_df['prev_month3']==-2) & (prod_df['pk_partition']!='2018-03-28')\n  cond42 = (prod_df[prod]==0) & (prod_df['prev_month1']==1) & (prod_df['prev_month2']==-2) & (prod_df['pk_partition']!='2018-02-28')\n  cond43 = (prod_df[prod]==0) & (prod_df['prev_month1']==1) & (prod_df['prev_month2']==0) \n  cond44 = (prod_df[prod]==0) & (prod_df['prev_month1']==1) & (prod_df['prev_month2']==1) & (prod_df['prev_month3']==0) \n  bajas_no_cobradas = prod_df[ cond41 | cond42 | cond43 | cond44 ] \n  bajas_no_cobradas = bajas_no_cobradas.groupby(['pk_partition'])['pk_cid'].count().sort_index()\n\n  # bajas de contrataciones ya cobradas\n  cond5 = (prod_df[prod]==0) & (prod_df['prev_month1']==1) & (prod_df['prev_month2']==1) & (prod_df['prev_month3']==1)\n  bajas_cobradas = prod_df[ cond5 ] \n  bajas_cobradas = bajas_cobradas.groupby(['pk_partition'])['pk_cid'].count().sort_index()\n\n  return nuevas_contrataciones, contrataciones_pendientes, contrataciones_cobradas, bajas_no_cobradas, bajas_cobradas","8ab90570":"# esto tarda unos minutos\ncontrataciones_nuevas = pd.DataFrame( range(len(partitions)), index=partitions )\ncontrataciones_pendientes = pd.DataFrame( range(len(partitions)), index=partitions )\ncontrataciones_cobradas = pd.DataFrame( range(len(partitions)), index=partitions )\n\nbajas_sin_cobro = pd.DataFrame( range(len(partitions)), index=partitions )\nbajas_con_cobro = pd.DataFrame( range(len(partitions)), index=partitions )\n\nfor prod in list_products:\n    altas_nuevas, altas_pendientes, altas_cobradas, bajas_no_cobradas, bajas_cobradas = altas_bajas_contrataciones( products_sorted, prod )\n    \n    # Altas\n    contrataciones_nuevas[prod] = altas_nuevas\n    contrataciones_pendientes[prod] = altas_pendientes\n    contrataciones_cobradas[prod] = altas_cobradas\n\n    # Bajas\n    bajas_sin_cobro[prod] = bajas_no_cobradas\n    bajas_con_cobro[prod] = bajas_cobradas\n    \n    print(prod)","75521b68":"contrataciones_nuevas.drop(0, axis=1, inplace=True)\ncontrataciones_nuevas.fillna(0, inplace=True)\n\ncontrataciones_pendientes.drop(0, axis=1, inplace=True)\ncontrataciones_pendientes.fillna(0, inplace=True)\n\ncontrataciones_cobradas.drop(0, axis=1, inplace=True)\ncontrataciones_cobradas.fillna(0, inplace=True)\n\nbajas_sin_cobro.drop(0, axis=1, inplace=True)\nbajas_sin_cobro.fillna(0, inplace=True)\n\nbajas_con_cobro.drop(0, axis=1, inplace=True)\nbajas_con_cobro.fillna(0, inplace=True)","d68e4bd8":"contrataciones_nuevas","2d9d7db4":"run = False\nif run == True:\n    contrataciones_nuevas.to_csv(PATH_DATA+'contrataciones_nuevas.csv')\n    contrataciones_pendientes.to_csv(PATH_DATA+'contrataciones_pendientes.csv')\n    contrataciones_cobradas.to_csv(PATH_DATA+'contrataciones_cobradas.csv')\n    bajas_sin_cobro.to_csv(PATH_DATA+'bajas_sin_cobro.csv')\n    bajas_con_cobro.to_csv(PATH_DATA+'bajas_con_cobro.csv')","a34bad0d":"# limpiamos memoria\ndel products","847e5005":"contrataciones_nuevas = pd.read_csv(PATH_DATA+'contrataciones_nuevas.csv', encoding='utf-8', index_col=0)\ncontrataciones_pendientes = pd.read_csv(PATH_DATA+'contrataciones_pendientes.csv', encoding='utf-8', index_col=0)\ncontrataciones_cobradas = pd.read_csv(PATH_DATA+'contrataciones_cobradas.csv', encoding='utf-8', index_col=0)\n\nbajas_sin_cobro = pd.read_csv(PATH_DATA+'bajas_sin_cobro.csv', encoding='utf-8', index_col=0)\nbajas_con_cobro = pd.read_csv(PATH_DATA+'bajas_con_cobro.csv', encoding='utf-8', index_col=0)\n\nproductos_exist_df = pd.read_csv(PATH_DATA + 'productos_existentes.csv')","95649da0":"products_dict = {\"short_term_deposit\":\"ahorro e inversi\u00f3n\", \"loans\":\"financiaci\u00f3n\", \"mortgage\":\"financiaci\u00f3n\", \n    \"funds\":\"ahorro e inversi\u00f3n\", \"securities\":\"ahorro e inversi\u00f3n\", \"long_term_deposit\":\"ahorro e inversi\u00f3n\", \n    \"em_account_pp\":\"cuenta\", \"credit_card\":\"financiaci\u00f3n\", \"payroll_account\":\"cuenta\", \n    \"emc_account\":\"cuenta\", \"debit_card\":\"financiaci\u00f3n\", \"em_account_p\":\"cuenta\", \"em_acount\":\"cuenta\", \"pension_plan\":\"ahorro e inversi\u00f3n\"}\n\ncost_product = {'cuenta':10, 'ahorro e inversi\u00f3n':40, 'financiaci\u00f3n':60}\n\npartitions = ['2018-01-28','2018-02-28','2018-03-28','2018-04-28','2018-05-28','2018-06-28', \\\n    '2018-07-28','2018-08-28','2018-09-28','2018-10-28','2018-11-28','2018-12-28','2019-01-28', \\\n        '2019-02-28','2019-03-28','2019-04-28','2019-05-28']\n\nlist_products = [\"short_term_deposit\", \"loans\", \"mortgage\", \"funds\", \"securities\", \"long_term_deposit\", \"em_account_pp\",\\\n                \"credit_card\", \"payroll_account\", \"pension_plan\", \"emc_account\", \"debit_card\", \"em_account_p\", \"em_acount\"]","a2d612fe":"def tipos_producto(df, products_dict):\n    ahorros = df.copy(deep=True)\n    financiacion = df.copy(deep=True)\n    cuentas = df.copy(deep=True)\n\n    for key, value in products_dict.items():\n        if value == 'ahorro e inversi\u00f3n':\n            ahorros[key] = df[key]\n        else:\n            ahorros.drop(columns=key, inplace=True)\n        if value == \"financiaci\u00f3n\":\n            financiacion[key] = df[key]\n        else:\n            financiacion.drop(columns=key, inplace=True)\n        if value == \"cuenta\":\n            cuentas[key] = df[key]\n        else:\n            cuentas.drop(columns=key, inplace=True)\n            \n    return ahorros, financiacion, cuentas","db30ba92":"# Obtencion de ingresos\ningresos_df = contrataciones_cobradas.copy(deep=True)\ningresos_perdidos_df = bajas_sin_cobro.copy(deep=True)\n\n\nfor key, value in products_dict.items():\n  ingresos_df[key] = ingresos_df[key]*cost_product[value] \n  ingresos_perdidos_df[key] = ingresos_perdidos_df[key]*cost_product[value] \n\ningresos_df.drop( partitions[:3], axis=0, inplace=True )\ningresos_perdidos_df.drop( partitions[:3], axis=0, inplace=True )\n\nahorros_df, financiacion_df, cuentas_df = tipos_producto(ingresos_df, products_dict)","21501622":"ahorros_df","099d4606":"print('Ingresos totales: {} \u20ac'.format(ingresos_df.sum(axis=1)[ partitions[-1] ]))\nprint(' Ahorro e inversi\u00f3n: {} \u20ac'.format(ahorros_df.sum(axis=1)[ partitions[-1] ]))\nprint(' Financiaci\u00f3n: {} \u20ac'.format(financiacion_df.sum(axis=1)[ partitions[-1] ]))\nprint(' Cuentas: {} \u20ac'.format(cuentas_df.sum(axis=1)[ partitions[-1] ]))","bfcbe555":"def fig_resumen_mes(financiacion_df, ahorros_df, cuentas_df):\n  resumen_mes = pd.DataFrame( [financiacion_df.sum(axis=1)['2019-05-28'], ahorros_df.sum(axis=1)['2019-05-28'], cuentas_df.sum(axis=1)['2019-05-28']], index=['Financiacion', 'Ahorros', 'Cuentas'], columns=['ingresos'])\n  resumen_mes = resumen_mes.reset_index()\n  resumen_mes.columns = ['tipo','ingresos']\n \n  fig = px.bar(resumen_mes, x=\"ingresos\", y=[1,1,1], color='tipo', orientation='h')\n\n  fig.update_layout(legend=dict(\n      orientation=\"h\",\n      yanchor=\"bottom\",\n      y=1.02,\n      xanchor=\"center\",\n      x=0.5,\n      font=dict(\n              family=\"Courier\",\n              size=18,\n              color=\"black\"\n      )\n  ))\n\n  fig.update_yaxes(visible=False, showticklabels=False)\n  \n  return fig\n\nfig = fig_resumen_mes(financiacion_df, ahorros_df, cuentas_df)\nfig.show()","4a531207":"last_month_sells = contrataciones_cobradas.loc['2019-05-28']\nsold_products = last_month_sells [ last_month_sells != 0 ].sort_values()\n\nfig = go.Figure()\nfor key, value in zip(sold_products.index, sold_products):\n    fig.add_trace(go.Bar(x=[key], y=[value], name=key, text=[value],\n            textposition='auto'))\n\nfig.update_yaxes(visible=False, showticklabels=False)\nfig.update_layout(title={'text':'Productos vendidos en el \u00faltimo mes', 'x':0.1,'y':0.75})","dc5a3bd9":"del last_month_sells, sold_products","f017c7f7":"def alta_baja_total (data, name):\n  totales = pd.DataFrame(data.sum(axis='columns')).reset_index()  \n  totales.columns = ['pk_partition',name]\n\n  return totales","89b503af":"# Resumen total altas e ingresos altas\naltas_nuevas = alta_baja_total (contrataciones_nuevas, 'altas')\ningresos_ganados = alta_baja_total (ingresos_df, 'altas')\naltas_pendientes = alta_baja_total (contrataciones_pendientes, 'altas')\n\naltas_por_cobrar = altas_nuevas.set_index('pk_partition') + altas_pendientes.set_index('pk_partition')\naltas_por_cobrar = altas_por_cobrar.reset_index()\n\naltas_cobradas = alta_baja_total (contrataciones_cobradas, 'altas').set_index('pk_partition')\n\naltas_totales = altas_por_cobrar.set_index('pk_partition')  + altas_cobradas\naltas_totales.reset_index(inplace=True)\naltas_cobradas.reset_index(inplace=True)\n\n# Resumen total bajas e ingresos bajas\n\nbajas_no_cobro = alta_baja_total (bajas_sin_cobro, 'bajas')\ningresos_perdidos = alta_baja_total (ingresos_perdidos_df, 'altas')\nbajas_si_cobro = alta_baja_total (bajas_con_cobro, 'bajas')\n\nbajas_totales = bajas_no_cobro.set_index('pk_partition') + bajas_si_cobro.set_index('pk_partition') \nbajas_totales.reset_index(inplace=True)\n\n# Ingresos potenciales\n\ningresos_potenciales = ingresos_perdidos.set_index('pk_partition') + ingresos_ganados.set_index('pk_partition')\ningresos_potenciales = ingresos_potenciales.reset_index()","74c248e3":"altas_totales.T","ef376b07":"ingresos_potenciales.T","c7acae1b":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(x=ingresos_potenciales[\"pk_partition\"], y=ingresos_potenciales[\"altas\"], \n    name='Ganancias con conversi\u00f3n 100%',  fill='tozeroy', line_color='indianred'))\nfig.add_trace(go.Scatter(x=ingresos_ganados[\"pk_partition\"], y=ingresos_ganados[\"altas\"], \n    name='Ganacias Reales', fill='tozeroy', line_color='blue'))\n\nmaximums = np.array([ingresos_potenciales['altas'].max(), ingresos_ganados['altas'].max()])\nfig.update_yaxes(range=[-500, maximums.max()*1.05])\nfig.update_layout(yaxis_title='Ingresos [\u20ac]')\n#fig.update_layout(title='Cashflow')\nfig.show()","c3cfe4de":"fig = go.Figure()\n\ninicio = 3\n#fig.add_trace(go.Scatter(x=altas_totales[\"pk_partition\"][inicio:], y=altas_totales[\"altas\"][inicio:], name='Altas totales'))\naltas_nuevas= altas_nuevas[inicio:]\naltas_pendientes = altas_pendientes[inicio:]\naltas_cobradas = altas_cobradas[inicio:]\n\nfig.add_trace(go.Scatter(x=altas_nuevas[\"pk_partition\"], y=altas_nuevas[\"altas\"], name='Nuevas altas'))\nfig.add_trace(go.Scatter(x=altas_pendientes[\"pk_partition\"], y=altas_pendientes[\"altas\"], name='Altas pendientes de cobro'))\nfig.add_trace(go.Scatter(x=altas_cobradas[\"pk_partition\"], y=altas_cobradas[\"altas\"], name='Altas reci\u00e9n cobradas'))\n\nmaximums = np.array([altas_nuevas['altas'].max(), altas_pendientes['altas'].max(), altas_cobradas['altas'].max()])\nfig.update_yaxes(range=[0, maximums.max()*1.05])\nfig.update_layout(yaxis_title='Cantidad de productos')","8c6d497a":"fig = go.Figure()\n\ninicio = 3\nfig.add_trace(go.Scatter(x=bajas_totales[\"pk_partition\"][inicio:], y=bajas_totales[\"bajas\"][inicio:], name='Bajas totales'))\n\nfig.add_trace(go.Scatter(x=bajas_no_cobro[\"pk_partition\"][inicio:], y=bajas_no_cobro[\"bajas\"][inicio:], name='Bajas sin cobro'))\nfig.add_trace(go.Scatter(x=bajas_si_cobro[\"pk_partition\"][inicio:], y=bajas_si_cobro[\"bajas\"][inicio:], name='Bajas con cobro'))\n\n#maximums = np.array([bajas_no_cobro['bajas'].max(), bajas_si_cobro['bajas'].max()])\n#fig.update_yaxes(range=[0, maximums.max()*1.05])\nfig.update_layout(yaxis_title='Cantidad de productos')\nfig.update_layout(title='Bajas de Productos')\nfig.show()","bd024323":"conversiones = pd.DataFrame()\nfor ix in range(len(partitions)): \n  if ix >= 3:\n    total = contrataciones_nuevas.loc[partitions[ix-2]]\n    cobra = contrataciones_cobradas.loc[partitions[ix]]\n    conversiones[partitions[ix]] = cobra\/total*100\n\nconversiones = conversiones.fillna(0).T","674a177c":"conversiones","fd3f2ef0":"conversion_df = pd.DataFrame(conversiones.min(axis=0), columns=['min'])\nconversion_df['mean'] = conversiones.mean(axis=0)\nconversion_df['max'] = conversiones.max(axis=0)\nconversion_df.reset_index(inplace=True)\n\nconversion_df['tipo'] = conversion_df['index'].replace(products_dict)\n\nfig = px.bar(conversion_df, x='index', y='mean', color='tipo')\nfig.update_layout(xaxis_title='')\nfig.update_layout(yaxis_title='Conversi\u00f3n [%]')\nfig.update_layout(title='Conversi\u00f3n media de cada producto')\nfig.show()","e36f5fe3":"conversion_df.set_index('index', inplace=True)","064aa361":"# Forecast\ndef ingresos_forecast(contrataciones_nuevas, conversion):\n    forecast = pd.DataFrame()\n    new_partitions = {'2019-06-28':'2019-04-28','2019-07-28':'2019-05-28'}\n    for key, val in new_partitions.items():\n        new_row = pd.DataFrame(contrataciones_nuevas.loc[val]).T.reset_index()\n        new_row['index'] = key\n        new_row.rename(columns={'index': 'pk_partition'}, inplace=True)\n        forecast = pd.concat( [forecast, new_row*conversion\/100] )\n    \n    forecast['pk_partition'] = new_partitions.keys()\n    forecast.set_index('pk_partition', inplace=True)\n    \n    return forecast\n\ningresos_futuros = contrataciones_nuevas.copy(deep=True)\n\nfor key, value in products_dict.items():\n  ingresos_futuros[key] = ingresos_futuros[key]*cost_product[value] \n\n\nworst_case = ingresos_forecast(ingresos_futuros, conversion_df['min'])\ncommon_case = ingresos_forecast(ingresos_futuros, conversion_df['mean'])\nbest_case = ingresos_forecast(ingresos_futuros, conversion_df['max'])","e4c9c0d5":"worst_case","912d3db7":"def calculate_case( case, last_ingresos ):\n    ingresos = alta_baja_total (case, 'altas')\n    ingresos = ingresos.append( last_ingresos.iloc[-1] )\n\n    return ingresos.sort_values('pk_partition')\n\nworst_ingresos = calculate_case( worst_case, ingresos_ganados )\nexpected_ingresos = calculate_case( common_case, ingresos_ganados )\nbest_ingresos = calculate_case( best_case, ingresos_ganados )","cfd4a69c":"worst_mean = int( conversion_df['min'].mean()*100 )\/100\nexpected_mean = int( conversion_df['mean'].mean()*100 )\/100\nbest_mean = int( conversion_df['max'].mean()*100 )\/100\n\nworst_ingresos","d2563825":"fig = go.Figure()\n\nfig.add_trace(go.Scatter(x=ingresos_ganados[\"pk_partition\"], y=ingresos_ganados[\"altas\"], name='Ingresos hasta la fecha'))\n\nfig.add_trace(go.Scatter(x=worst_ingresos[\"pk_partition\"], y=worst_ingresos[\"altas\"], name=str('Worst Case: {}%'.format( worst_mean ))))\nfig.add_trace(go.Scatter(x=worst_ingresos[\"pk_partition\"], y=expected_ingresos[\"altas\"], name= str('Expected Case: {}%'.format( expected_mean ))))\nfig.add_trace(go.Scatter(x=worst_ingresos[\"pk_partition\"], y=best_ingresos[\"altas\"], name= ('Best Case: {}%'.format( best_mean ))))\n\nmaximums = np.array([ingresos_ganados['altas'].max(), best_ingresos['altas'].max()])\nfig.update_yaxes(range=[0, maximums.max()*1.05])\nfig.update_layout(yaxis_title='Ingresos[\u20ac]')\nfig.update_layout(title='Ingresos Forecasting')\nfig.show()","b9865242":"prod_ahorros, prod_financiacion, prod_cuentas = tipos_producto(productos_exist_df, products_dict)\n\naltas_ahorros, altas_financiacion, altas_cuentas = tipos_producto(contrataciones_cobradas, products_dict)\nbajas_ahorros, bajas_financiacion, bajas_cuentas = tipos_producto(bajas_sin_cobro + bajas_con_cobro, products_dict)\n\nprod_ahorros","3c008a9e":"# Totales\ndef obtener_prod_totales(df):\n  totales = df.sum(axis='columns').reset_index()\n  totales.columns = ['pk_partition','productos']\n  return totales\n\nproductos_totales = obtener_prod_totales(productos_exist_df)\n\nahorros_totales = obtener_prod_totales(prod_ahorros)\nfinanciacion_totales = obtener_prod_totales(prod_financiacion)\ncuentas_totales = obtener_prod_totales(prod_cuentas)\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=productos_totales[\"pk_partition\"], y=productos_totales[\"productos\"], name='Totales'))\n\nfig.add_trace(go.Scatter(x=productos_totales[\"pk_partition\"], y=ahorros_totales[\"productos\"], name='Ahorros'))\nfig.add_trace(go.Scatter(x=productos_totales[\"pk_partition\"], y=financiacion_totales[\"productos\"], name='Financiaci\u00f3n'))\nfig.add_trace(go.Scatter(x=productos_totales[\"pk_partition\"], y=cuentas_totales[\"productos\"], name='Cuentas'))\nfig.update_yaxes(range=[0, productos_totales.max()['productos']*1.05])\nfig.update_layout(title='Evoluci\u00f3n de productos',\n                   yaxis_title='Cantidad de productos')\nfig.show()","f62f9ae9":"del productos_totales, ahorros_totales, financiacion_totales, cuentas_totales","9380a205":"def tipo_producto_totales (df, ahorros, financiacion, cuentas):\n\n    totales = alta_baja_total (df, 'value')\n\n    ahorros_totales = alta_baja_total(ahorros, 'value')\n    financiacion_totales = alta_baja_total(financiacion, 'value')\n    cuentas_totales = alta_baja_total(cuentas, 'value')\n \n    fig = go.Figure()\n    inicio = 1\n    fig.add_trace(go.Scatter(x=totales[\"pk_partition\"][inicio:], y=totales[\"value\"][inicio:], name='Totales'))\n\n    fig.add_trace(go.Scatter(x=totales[\"pk_partition\"][inicio:], y=ahorros_totales[\"value\"][inicio:], name='Ahorros'))\n    fig.add_trace(go.Scatter(x=totales[\"pk_partition\"][inicio:], y=financiacion_totales[\"value\"][inicio:], name='Financiaci\u00f3n'))\n    fig.add_trace(go.Scatter(x=totales[\"pk_partition\"][inicio:], y=cuentas_totales[\"value\"][inicio:], name='Cuentas'))\n\n    fig.update_yaxes(range=[0, totales.max()['value']*1.05])\n\n    return fig\n\n\nfig = tipo_producto_totales (contrataciones_nuevas, altas_ahorros, altas_financiacion, altas_cuentas)\n\nfig.update_layout(title='Evoluci\u00f3n de altas',\n                   yaxis_title='N\u00famero de altas')\nfig.show()","4daecc84":"def obtener_ingresos_totales(df):\n    totales = pd.DataFrame(df.sum(axis='columns')).reset_index()\n    totales.columns = ['pk_partition','ingresos']\n    return totales\n\ntotales_ingresos = obtener_ingresos_totales(ingresos_df)\n\ntotales_ahorros = obtener_ingresos_totales(ahorros_df)\ntotales_financiacion = obtener_ingresos_totales(financiacion_df)\ntotales_cuentas = obtener_ingresos_totales(cuentas_df)\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=totales_ingresos['pk_partition'], y=totales_ingresos['ingresos'], name='Total'))\n\nfig.add_trace(go.Scatter(x=totales_ingresos['pk_partition'], y=totales_ahorros['ingresos'], name='Ahorros'))\nfig.add_trace(go.Scatter(x=totales_ingresos['pk_partition'], y=totales_financiacion['ingresos'], name='Financiacion'))\nfig.add_trace(go.Scatter(x=totales_ingresos['pk_partition'], y=totales_cuentas['ingresos'], name='Cuentas'))\n\nfig.update_yaxes(range=[0, totales_ingresos.max()['ingresos']*1.05])\nfig.update_layout(title= 'Evoluci\u00f3n de los Ingresos',\n                   yaxis_title='Ingresos mensuales')\nfig.show()","aaf9f666":"# limpiamos memoria\ntry:\n    del conversiones, totales_ahorros, totales_financiacion, totales_cuentas\nexcept:\n    pass","4544a3f4":"productos = pd.read_csv(PATH_DATA+'products_df.csv')\nproductos.drop('Unnamed: 0', axis=1, inplace=True)\n\n# para aligerar el fichero cambio el tipo de datos a int8 para las columnas de productos\nfor i in productos.columns:\n        if (productos[i].dtype==\"int64\" and [i]!=[\"pk_cid\"]):\n            productos[i]=productos[i].astype(\"int8\")\n        else:            \n            productos[i]=productos[i]","ce084d4c":"productos_his = pd.DataFrame(productos.groupby(['pk_partition'])[productos.columns[2:]].sum())\nproductos_his = productos_his.reset_index()","2632596b":"# Borramos payroll porque es un servicio no producto\nproductos_his. drop('payroll', axis=1, inplace=True)\nproductos_his","f70b3c6e":"# Calculamos el total de productos contratados para cada mes\nproductos_his['total'] = productos_his.sum(axis=1)\n\nproductos_his[\"date\"]=productos_his[\"pk_partition\"]\nproductos_his[\"date\"] = pd.to_datetime(productos_his[\"pk_partition\"], format = \"%Y-%m-%d\")\n\n# set index con date y borramos pk_partition\nproductos_his.set_index('date', inplace=True)\nproductos_his.drop('pk_partition', axis=1, inplace=True)","5eb1214c":"run = False\nif run == True:\n    productos_his.to_csv(PATH_DATA+'productos_his.csv')","d75d930c":"# Gr\u00e1fico con la evoluci\u00f3n total de los productos \nfig = go.Figure(go.Indicator(\n    mode = \"number+delta\",\n    value = productos_his.iloc[-1,-1],\n    delta = {\"reference\": productos_his.iloc[-2,-1], \"valueformat\": \".0f\"},\n    title = {\"text\": \"Total \u00faltimo mes\"},\n    domain = {'x': [0.8, 1], 'y': [0, 0.5]}))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_his['total'], \n    name='total', fill='tozeroy', line_color='green'))\n\nfig.update_layout(title='Evoluci\u00f3n cartera de productos total', yaxis_title='Unidades')\nfig.show()","cc2463ca":"# Para ver la evoluci\u00f3n de los productos dividimos el gr\u00e1fico en dos partes para una mejor visualizaci\u00f3n\n# Parte 1\ndf2 = px.data.medals_wide()\n\nfig = px.bar(productos_his, x=productos_his.index, y=['em_acount', 'debit_card', 'payroll_account', 'emc_account', 'pension_plan'], title=\"Hist\u00f3rico de productos - Top-5 Ventas\", opacity=0.80)\nfig.show()","9e1fb9c5":"# parte 2\ndf1 = px.data.medals_wide()\n\nfig = px.bar(productos_his, x=productos_his.index, y=['long_term_deposit', 'credit_card', 'securities', 'funds',  'loans', 'mortgage', 'short_term_deposit',  'em_account_p',   'em_account_pp', ], title=\"Hist\u00f3rico de productos - Restante\", opacity=0.80)\nfig.show()","2bc90e3a":"# Treemap para ver la distribuci\u00f3n de los productos en el \u00faltimo mes\ndf2 = productos_his.iloc[[-1]]\ndf2=df2.T\n\ndf2.columns = ['total_mes']\ndf2['producto']=df2.index\ndf2['distribucion']=df2['total_mes']*100\/422365\n\ndf2.drop([\"total\"], inplace=True)","bf4190cd":"fig = px.treemap(df2, path=['producto'], values='distribucion', title=\"Distribuci\u00f3n productos - \u00daltimo mes\", )\n\nfig.update_traces(opacity=0.8)\n\nfig.show()","52f9681d":"# C\u00e1lculo de la tasa de crecimiento promedio mensual del \u00faltimo mes respecto al mismo mes del a\u00f1o anterior para cada producto\nproductos_var_mean12=[]\nproductos_var_mean12=pd.DataFrame(productos_var_mean12, index=range(1))\nfor i,j in zip(productos_his.columns, range(0, productos_his.shape[1])):\n    productos_var_mean12[i] = (((productos_his.iat[-1,j]\/productos_his.iat[0,j])**(1\/13))-1)*100\nproductos_var_mean12.index = ['var12']","ff64bedb":"# gr\u00e1fico de lollipop\n# preparaci\u00f3n de los datos\ndf=productos_var_mean12.T.copy(deep=True)\ndf.rename(columns={'var12':\"x_plot\"}, inplace=True)\ndf.dropna(inplace=True)\ndf.sort_values(\"x_plot\", inplace = True)\ndf.reset_index(inplace = True)\ndf.rename(columns={'index':'productos'}, inplace=True)\ndf\n\ndf[\"color\"] = df['productos'].apply(lambda x: \"orange\" if x == 'total' else (\"red\" if x== 'short_term_deposit' else \"green\"))\n\n# instancia el gr\u00e1fico\nfig = plt.figure(figsize = (6, 10))\nax = fig.add_subplot()\n\nax.hlines(y = df.index, \n          xmin = 0,\n          xmax = df[\"x_plot\"],\n          color = df[\"color\"],\n          alpha = 0.6)\n\n# plot the dots\nax.scatter(x = df[\"x_plot\"],\n          y = df.index,\n          s = 100,\n          color = df[\"color\"],\n          alpha = 0.6)\n\n# set title\nax.set_title(\"Variaci\u00f3n porcentual promedio mensual (%)\")\n\n# autoscale\nax.autoscale_view()\n\n# change x lim\nax.set_xlim(-40, 10)\n\n# set labels\nax.set_xlabel(\"%\")\nax.set_ylabel(\"Producto\")\n\n# instead of y = 1, 2, 3...\n# put the products on the y axis\nax.set_yticks(df.index)\nax.set_yticklabels(df['productos'])\n\n# change the spines to make it nicer\nax.spines[\"right\"].set_color(\"None\")\nax.spines[\"top\"].set_color(\"None\")\n\n# add a grid\nax.grid(linestyle='--', alpha=0.5);","0c827edb":"run = False\nif run == True:\n    fig.savefig('lollipop.png')","a7fb2707":"# C\u00e1lculo de las ventas para cada mes\nproductos_vtas=productos_his.index\nproductos_vtas=pd.DataFrame(productos_vtas)\nproductos_vtas.set_index('date', inplace=True)\nfor i in productos_his.columns:\n    productos_vtas[i] = productos_his[i] - productos_his[i].shift(1)\n\n# Tabla de contratos mensual\nproductos_vtas","beb6b090":"# Variaci\u00f3n porcentual mensual por mes con respecto al mes anterior y producto\nproductos_crec=productos_his.index\nproductos_crec=pd.DataFrame(productos_crec)\nproductos_crec.set_index('date', inplace=True)\nfor i in productos_his.columns:\n    productos_crec[i] = ((productos_his[i] - productos_his[i].shift(1))\/productos_his[i].shift(1))*100\nproductos_crec","e3ef39a2":"# Para hacer una tabla resumen por producto y comparativa: ventas \u00faltimo mes, ventas mes anterior, ventas respecto mismo mes a\u00f1o anterior y variacion porcentual\n#Cventas_mes=productos_vtas.describe().loc[['mean', 'max']].astype(int)\n#ventas_mes\ntabla_resu=productos_vtas.iloc[[-2,-1]]","8f8b2ebc":"tabla_resu=tabla_resu.append(productos_vtas.iloc[[-13]])\ntabla_resu","cebb9392":"tabla_resu.index = ['vtas_mes_ant', 'vtas_mes', 'vtas_12m']\ntabla_resu=tabla_resu.append(productos_var_mean12)\n\nvar1=productos_crec.iloc[[-1]]\nvar1.index = ['var1']\n\ntabla_resu=tabla_resu.append(var1)\ntabla_resu.fillna(0, inplace=True)\ntabla_resu=tabla_resu.T","fc98c49b":"# Preparando los datos para hacer la tabla en dash\ndf=tabla_resu.copy(deep=True)","dfab3eb8":"df['producto']=tabla_resu.index\ndf=df.reindex([\"producto\", \"vtas_mes\", \"vtas_mes_ant\", \"vtas_12m\", \"var1\", \"var12\" ], axis=1)\n\ndf['var1']=df['var1'].map('{:,.2f}'.format)\ndf['var12']=df['var12'].map('{:,.2f}'.format)\n\n# preparando la tabla\n\nfig = go.Figure(data=[go.Table(\n    header=dict(values=['<b>Producto<b>', '<b>vtas_mes<b>', '<b>vtas_mes_ant<b>', '<b>vtas_12m<b>'],\n                fill_color='green',\n                align='right',\n                font=dict(color='white')\n                ),\n\n    cells=dict(values=[df.producto, df.vtas_mes, df.vtas_mes_ant, df.vtas_12m, ],\n               fill_color='whitesmoke',\n               align='right'),\n               ),\n\n])\n\nfig.update_layout(width=700, height=600, title='Resumen cartera de productos')\n\n\nfig.show()","0bb56fd3":"df['var12']=df['var12'].astype('float')\ndf['var1']=df['var1'].astype('float')","a038beb1":"fig = go.Figure()\n\nfig.add_trace(go.Indicator(\n    mode = \"number\",\n    value = df.iloc[-1,-2],\n    title = {\"text\": \"Variaci\u00f3n porcentual (%) <br><span style='font-size:0.8em;color:green'>Mes anterior<\/span>\"},\n    delta = {'reference': df.iloc[-1,2], 'relative': True},\n    domain = {'x': [0.7, 0.5], 'y': [0, 1]}))\n\n#fig.update_layout(width=1000, height=300)\n\nfig.show()","0eac9fed":"fig = go.Figure()\n\nfig.add_trace(go.Indicator(\n    mode = \"number\",\n    value = df.iloc[-1,-1],\n    #title = {\"text\": \"Variaci\u00f3n porcentual (%)<br><span style='font-size:0.8em;color:gray'>Subtitle<\/span><br><span style='font-size:0.8em;color:gray'>Subsubtitle<\/span>\"}\n    title = {\"text\": \"Variaci\u00f3n porcentual (%) <br><span style='font-size:0.8em;color:green'>Media \u00faltimos 12 meses<\/span>\"},\n    delta = {'reference': df.iloc[-1,2], 'relative': True},\n    domain = {'x': [0.1, 1], 'y': [0.1, 0.3]}))\n\nfig.add_trace(go.Indicator(\n    mode = \"number\",\n    value = df.iloc[-1,-2],\n    title = {\"text\": \"Variaci\u00f3n porcentual (%) <br><span style='font-size:0.8em;color:green'>Mes anterior<\/span>\"},\n    delta = {'reference': df.iloc[-1,2], 'relative': True},\n    domain = {'x': [0.1, 1], 'y': [0.5, 0.9]}))\n\n#fig.update_layout(width=1000, height=300)\n\nfig.show()","8da7b682":"productos_crec.columns.names = ['productos']\n\nfig = px.area(productos_crec, facet_col=\"productos\", facet_col_wrap=3, range_y=[-20, 20])\n\nfig.update_layout(\n    autosize=False,\n    width=1200,\n    height=600,\n    title= 'Evoluci\u00f3n variaci\u00f3n porcentual mensual por producto (%)', showlegend=False)\n\nfig.show()","a912211e":"# Agrupamos los productos por tipo y vemos como se comporta la variaci\u00f3n porcentual mes a mes.\n\n# ahorro_inv = (\"short_term_deposit\", \"funds\", \"securities\",\"long_term_deposit\",\"pension_plan\")\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['short_term_deposit'], \n    name='short_term_deposit',  fill='tozeroy', line_color='green'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['funds'], \n    name='funds', fill='tozeroy', line_color='orange'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['securities'], \n    name='securities', fill='tozeroy', line_color='indianred'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['long_term_deposit'], \n    name='long_term_deposit', fill='tozeroy', line_color='blue'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['pension_plan'], \n    name='pension_plan', fill='tozeroy', line_color='gray'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['total'], \n    name='total', fill='tozeroy', line_color='red'))\n\n\nfig.update_yaxes(range=[-100, 60])\nfig.update_layout(yaxis_title='Variaci\u00f3n mensual (%)', title= 'Productos de ahorro e inversi\u00f3n')\nfig.show()","6850ab99":"# Financiaciaci\u00f3n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['loans'], \n    name='loans', fill='tozeroy', line_color='green'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['mortgage'], \n    name='mortgage', fill='tozeroy', line_color='gray'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['credit_card'], \n    name='credit_card', fill='tozeroy', line_color='orange'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['debit_card'], \n    name='debit_card', fill='tozeroy', line_color='blue'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['total'], \n    name='total', fill='tozeroy', line_color='red'))\n\nfig.update_yaxes(range=[-10, 25])\nfig.update_layout(yaxis_title='Variaci\u00f3n mensual (%)', title= 'Productos de financiaci\u00f3n')\nfig.show()","fb94f1da":"# cuenta = (\"em_account_pp\", \"payroll_account\", \"emc_account\",\"em_account_p\", \"em_acount\")\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['em_account_pp'], \n    name='account_pp',  fill='tozeroy', line_color='indianred'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['payroll_account'], \n    name='payroll_account', fill='tozeroy', line_color='green'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['emc_account'], \n    name='emc_account', fill='tozeroy', line_color='gray'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['em_account_p'], \n    name='em_account_p', fill='tozeroy', line_color='orange'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['em_acount'], \n    name='em_acount', fill='tozeroy', line_color='blue'))\n\nfig.add_trace(go.Scatter(x=productos_his.index, y=productos_crec['total'], \n    name='total', fill='tozeroy', line_color='red'))\n\n\nfig.update_yaxes(range=[-10, 10])\nfig.update_layout(yaxis_title='Variaci\u00f3n mensual (%)', title= 'Productos de cuentas')\nfig.show()","dc95be5d":"del productos, productos_his, productos_var_mean12, df2","e2b0ae99":"sociodemographic_df = pd.read_csv(PATH_DATA+'sociodemographic_df.csv')\nsociodemographic_df.drop('Unnamed: 0', axis=1, inplace=True)\nproducts_df = pd.read_csv(PATH_DATA+'products_df.csv')\nproducts_df.drop('Unnamed: 0', axis=1, inplace=True)\ncommercial_df = pd.read_csv(PATH_DATA+'commercial_activity_df.csv')\ncommercial_df .drop('Unnamed: 0', axis=1, inplace=True)\n\nsociodemographic_df.head()","4e7db04e":"socioproducts = pd.merge(sociodemographic_df, products_df, how='inner', on=['pk_cid','pk_partition'])\nsocioproductscommercial = pd.merge(socioproducts, commercial_df, how='inner', on=['pk_cid','pk_partition'])\nsocioproductscommercial.head()","21f56ac3":"paises_code = {'ES': ['ES','Spain'], 'GB':['EU','United Kingdom'], 'US':['NA','US'], \n    'FR':['EU','France'], 'CH':['EU','Switzerland'], 'DE':['EU','Germany'], 'BE':['EU','Belgium'], \n    'BR':['SA','Brazil'], 'VE':['SA','Venezuela'], 'MX':['SA','Mexico'], 'AR':['SA','Argentina'], \n    'IE':['EU','Ireland'], 'PL':['EU','Poland'], 'IT':['EU','Italy'], 'AT':['EU','Austria'], \n    'SE':['EU','Sweden'], 'CL':['SA','Chile'], 'MA':['AF','Morocco'], 'CO':['SA','Colombia'], \n    'DZ':['AF','Algeria'], 'SN':['AF','Senegal'], 'ET':['AF','Ethiopia'], 'RU':['EU','Russia'], \n    'GA':['AF','Gambia'], 'SA':['AS','Saudi Arabia'], 'MR':['AF','Mautirania'], 'HU':['EU','Hungary'], \n    'JM':['SA','Jamaica'], 'CM':['AF','Cameroon'], 'CI':['AF',\"Cote d'Ivoire\"], 'RO':['EU','Romania'], \n    'PE':['SA','Peru'], 'DO':['SA','Dominican Republic'], 'QA':['AS','Qatar'], 'PT':['EU','Portugal'], \n    'LU':['EU','Luxembourg'], 'DJ':['AF','Djibouti'], 'GT':['SA','Guatemala'], 'CN':['AS','China'], \n    'NO':['EU','Norway'], 'CA':['NA','Canada']}\n\ncontinente = {'ES':'Espa\u00f1a', 'EU':'Europa', 'SA':'Sur Am\u00e9rica', 'NA':'Norte Am\u00e9rica', 'AS': 'Asia', 'AF':'\u00c1frica'}","251ef063":"spanish_regions_code = {1:['Elciego', 'Pa\u00eds Vasco'], 2:['Albacete', 'Castilla-La Mancha'], 3:['Alicante\/Alacant', 'Com. Valenciana'],4:['Almer\u00eda','Andaluc\u00eda'],5:['\u00c1vila','Castilla y Le\u00f3n'], 6:['Badajoz','Extremadura'],\t7:['Palma','Islas Baleares'], 8:['Barcelona','Catalu\u00f1a'],9:['Burgos','Castilla y Le\u00f3n'], 10: ['C\u00e1ceres','Extremadura'], 11: ['C\u00e1diz','Andaluc\u00eda'], 12: ['Castell\u00f3n de la Plana\/Castell\u00f3 de la Plana','Com. Valenciana'], 13: ['Ciudad Real','Castilla-La Mancha'], 14: ['C\u00f3rdoba','Andaluc\u00eda'], 15: ['Coru\u00f1a (A)','Galicia'], 16: ['Cuenca','Castilla-La Mancha'], 17: ['Girona','Catalu\u00f1a'], 18: ['Granada','Andaluc\u00eda'], 19: ['Guadalajara','Castilla-La Mancha'], 20: ['Donostia-San Sebasti\u00e1n','Pa\u00eds Vasco'], 21: ['Huelva','Andaluc\u00eda'], 22: ['Huesca','Arag\u00f3n'], 23: ['Ja\u00e9n','Andaluc\u00eda'], 24: ['Le\u00f3n','Castilla y Le\u00f3n'], 25: ['Lleida','Catalu\u00f1a'], 26: ['Logro\u00f1o','La Rioja'], 27: ['Lugo','Galicia'], 28: ['Madrid','Madrid'], 29: ['M\u00e1laga','Andaluc\u00eda'], 30: ['Murcia','Murcia'], 31: ['Pamplona\/Iru\u00f1a','Com. de Navarra'], 32: ['Ourense','Galicia'], 33: ['Oviedo','Princ. de Asturias'], 34: ['Palencia','Castilla y Le\u00f3n'], 35: ['Palmas de Gran Canaria (Las)','Islas Canarias'], 36: ['Pontevedra','Galicia'], 37: ['Salamanca','Castilla y Le\u00f3n'], 38: ['Santa Cruz de Tenerife','Islas Canarias'], 39: ['Santander','Cantabria'], 40: ['Segovia','Castilla y Le\u00f3n'], 41: ['Sevilla','Andaluc\u00eda'], 42: ['Soria','Castilla y Le\u00f3n'], 43: ['Tarragona','Catalu\u00f1a'], 44: ['Teruel','Arag\u00f3n'], 45: ['Toledo','Castilla-La Mancha'], 46: ['Valencia','Com. Valenciana'], 47: ['Valladolid','Castilla y Le\u00f3n'], 48: ['Bilbao','Pa\u00eds Vasco'], 49: ['Zamora','Castilla y Le\u00f3n'], 50: ['Zaragoza','Arag\u00f3n'], 51: ['Ceuta','Ceuta y Melilla'], 52: ['Melilla','Ceuta y Melilla']}\nspanish_regions_code","b2f03e70":"country_lon_lat = pd.read_csv(PATH_DATA+'country_lon_lat.csv', encoding='utf-8', index_col=0)\n\n# China y Canada faltan!\ncountry_lon_lat = country_lon_lat.append( {'Country\/Region': 'China', 'Lat':35.86166, 'Long':104.195397}, ignore_index=True)\ncountry_lon_lat = country_lon_lat.append( {'Country\/Region': 'Canada', 'Lat':56.130366, 'Long':-106.346771}, ignore_index=True)\ncountry_lon_lat.head()","d100d3ec":"lon_lat = pd.read_excel(PATH_DATA+'listado-longitud-latitud-municipios-espana.xls', skiprows=2)\nlon_lat.head()","00efdcca":"spain = pd.DataFrame(spanish_regions_code).T\nspain.columns = ['Ciudad','Com.Autonoma']\nspain.head()","a8aef11a":"spain_lot_lat = pd.merge(spain, lon_lat[['Provincia','Poblaci\u00f3n','Latitud','Longitud']], left_on='Ciudad', right_on='Poblaci\u00f3n', how='left')\nspain_lot_lat.head(30)","82c7f968":"active_clients = socioproductscommercial.copy(deep=True)\nactive_clients['num_products'] = active_clients[list_products].sum(axis=1)\nactive_clients = active_clients[ (active_clients['num_products'] != 0) & (active_clients['active_customer'] != 0) & (active_clients['pk_partition'] == '2019-05-28') ]\nactive_clients.head()","4ff252eb":"country_match = {}\nfor key, value in paises_code.items():\n  country_match[key] = value[1]\n\nactive_clients['Pais'] = active_clients['country_id'].replace(country_match)","02b6720c":"region_match = {}\nfor key, value in spanish_regions_code.items():\n  region_match[key] = value[0]\n\nactive_clients['Region'] = active_clients['region_code'].replace(region_match)","36faaf33":"clients_df = pd.merge(active_clients, country_lon_lat, how='left', left_on ='Pais', right_on='Country\/Region')\nclients_df = pd.merge(clients_df, spain_lot_lat, how='left', left_on ='Region', right_on='Ciudad')\n\nclients_df['Lat'] = np.where( clients_df['Latitud'].isna(), clients_df['Lat'], clients_df['Latitud'] )\nclients_df['Long'] = np.where( clients_df['Longitud'].isna(), clients_df['Long'], clients_df['Longitud'] )\n\nclients_df['Region'].fillna('', inplace=True)\n\nclients_df.head()","e7b095fb":"results_df = clients_df.groupby(['Pais','Region','Lat','Long'])[['pk_cid']].count()\nresults_df.reset_index(inplace=True)\nresults_df","7a816e32":"if run == True:\n    results_df.to_csv(PATH_DATA+'mapa_clientes.csv')","7344e1bc":"#import calmap\n\nmapa_global = folium.Map(location=[40, 1], tiles='cartodbpositron',\n               min_zoom=5, max_zoom=5, zoom_start=5)\n\nfor i in range(0, len(results_df)):\n    folium.Circle(\n        location=[results_df.iloc[i]['Lat'], results_df.iloc[i]['Long']],\n        color='crimson', \n        tooltip =   '<li><bold>Country : '+str(results_df.iloc[i]['Pais'])+\n                    '<li><bold>Province : '+str(results_df.iloc[i]['Region']+\n                    '<li><bold>Active Users : '+str(results_df.iloc[i]['pk_cid'])),\n        radius=int(17000)).add_to(mapa_global)\n        #radius=int(results_df.iloc[i]['pk_cid'])**1.1).add_to(mapa_global)\n        \nmapa_global","f068dc52":"del spain, results_df, mapa_global, clients_df, active_clients","443d837c":"commercial_products = pd.merge(commercial_df, products_df, on=['pk_cid','pk_partition'], how='left')\ncommercial_products_sorted = commercial_products.sort_values(by=['pk_cid', 'pk_partition'])","3872ccf8":"active_customers = commercial_products_sorted [ (commercial_products_sorted[list_products].max(axis=1) == 1) & (commercial_products_sorted['active_customer'] == 1) ]\n\nactive_customers_df = pd.DataFrame()\n\nfor prod in list_products:\n    df_ = commercial_products_sorted [ (commercial_products_sorted[prod] == 1) & (commercial_products_sorted['active_customer'] == 1)]\n    active_customers_df[prod] = df_.groupby('pk_partition')[prod].count()\n\nactive_customers_df['totales'] = active_customers.groupby('pk_partition')['pk_cid'].count()\nactive_customers_df.fillna(0, inplace=True)\nactive_customers_df","b10cc3cb":"if run == True:\n    active_customers_df.to_csv(PATH_DATA+'usuarios_activos.csv')","19cb2db7":"resumen_usuarios = active_customers_df[['totales']]\nresumen_usuarios.reset_index(inplace=True)","20003621":"import plotly.graph_objects as go\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nresumen_usuarios['pk_partition'] = pd.to_datetime(resumen_usuarios['pk_partition'])\nresumen_usuarios['month'] = resumen_usuarios['pk_partition'].dt.month\nresumen_usuarios['year'] = resumen_usuarios['pk_partition'].dt.year\n\nmonths = {1:'Enero',2:'Febrero',3:'Marzo',4:'Abril',5:'Mayo',6:'Junio',7:'Julio',8:'Agosto',9:'Septiembre',10:'Octubre',11:'Noviembre',12:'Diciembre'}\n\nresumen_usuarios['month_name'] = resumen_usuarios['month'].map(months)\n\nmonth_map = {'Enero':4,'Febrero':3,'Marzo':2,'Abril':1,'Mayo':12,'Junio':10,'Julio':10,'Agosto':9,'Septiembre':8,'Octubre':7,'Noviembre':6,'Diciembre':5}\nresumen_usuarios = resumen_usuarios.sort_values('month')\n\nresumen_usuarios['order'] = resumen_usuarios['month_name'].map(month_map)\nresumen_usuarios = resumen_usuarios.sort_values('order')\n\ndf_2019 = resumen_usuarios[resumen_usuarios['year'] == 2019]\ndf_2018 = resumen_usuarios[resumen_usuarios['year'] == 2018]\n\n#\ndf_2018 = df_2018.append( {'pk_partition':'enero', 'ingresos':np.nan, 'month':1, 'month_name':months[1], 'order':month_map[months[1]]}, ignore_index=True )\ndf_2018 = df_2018.sort_values('order')\n\nfig = go.Figure()\nfig.add_trace(go.Scatterpolar(r=df_2018['totales'], theta=df_2018['month_name'], name='2018', mode='markers', marker=dict(size=20)))\nfig.add_trace(go.Scatterpolar(r=df_2019['totales'], theta=df_2019['month_name'], name='2019', mode='markers', marker=dict(size=20)))\n\nfig.update_layout(\n    polar = dict(\n      radialaxis = dict(\n        angle = -90,\n        tickangle = -90 # so that tick labels are not upside down\n      )\n    )\n)\n\nfig.show()","6effb499":"commercial_products = pd.merge(commercial_df, products_df, on=['pk_cid','pk_partition'], how='left')","a1e0e8c7":"from datetime import datetime as dt\n# 2015-02-29 = esta fecha no existe!\n\nwrong_dates = {'2015-02-29': '2015-02-28', '2019-02-29':'2019-02-28'}\n\ncommercial_products['entry_date'] = commercial_products['entry_date'].replace(wrong_dates)\ncommercial_products['entry_date'] = pd.to_datetime(commercial_products['entry_date'], format='%Y-%m-%d')\n\ncommercial_products['pk_partition'] = commercial_products['pk_partition'].replace(wrong_dates)\ncommercial_products['pk_partition'] = pd.to_datetime(commercial_products['pk_partition'], format='%Y-%m-%d')","97e7c42d":"for x in list_products:\n    commercial_products[x] = commercial_products[x].astype(bool)","585522f0":"commercial_products_sorted = commercial_products.sort_values(by=['pk_cid', 'pk_partition'])","8c8395d6":"commercial_products_sorted['status'] = commercial_products_sorted [list_products].max(axis='columns')\ncommercial_products_sorted['status_shift'] = commercial_products_sorted .groupby('pk_cid')['status'].shift(1)\ncommercial_products_sorted['diff'] = commercial_products_sorted['status'] - commercial_products_sorted['status_shift']\n\n# son nuevos si no tenian status_shift \nnew_clients_df = commercial_products_sorted [ (commercial_products_sorted['status'] == 1) & (commercial_products_sorted['status_shift'].isna()) ]\nnew_clients_df = new_clients_df[ new_clients_df['pk_partition'] != '2018-01-28' ]\n\n#new_clients_df['buy'] = new_clients_df[list_products].sum(axis=1)\n\nnew_clients_df","61dd3c60":"products_new_clients = new_clients_df.groupby('pk_partition')[list_products].sum()\n\nproducts_new_clients.reset_index()","04c5f9d4":"# Nuevos clientes\nnew_clients = pd.DataFrame(new_clients_df.groupby('pk_partition')['loans'].count())\nnew_clients.reset_index(inplace=True)\nnew_clients.columns = ['pk_partition','totales']\n\n# Productos de nuevos clientes\nproducts_new_clients = new_clients_df.groupby('pk_partition')[list_products].sum()\nproducts_new_clients.reset_index(inplace=True)\n\nproducts_new_clients = pd.merge( products_new_clients, new_clients, on='pk_partition', how='left')\n\nproducts_new_clients","c41e0c08":"if run == True:\n    products_new_clients.to_csv(PATH_DATA + 'clientes_primerizos.csv')","a95ea0d6":"#list_ingresos = []\n#for key, value in products_dict.items():\n#    products_new_clients[key+'_revenue'] = products_new_clients[key] * cost_product[value]\n#    list_ingresos.append(key+'_revenue')\n\n#products_new_clients['total_ingresos'] = products_new_clients[list_ingresos].sum(axis=1)\n#products_new_clients\n","d3524dd2":"ahorros, financiacion, cuentas = tipos_producto(products_new_clients, products_dict)\n\nahorros_list = []\nfinanciacion_list = []\ncuentas_list = []\n\nfor key, val in products_dict.items():\n  if val == 'ahorro e inversi\u00f3n':\n    ahorros_list.append(key)\n  if val == 'financiaci\u00f3n':\n    financiacion_list.append(key)\n  if val == 'cuenta':\n    cuentas_list.append(key)\n\nfig = go.Figure()\n\nx = ['ahorro e inversi\u00f3n']\nfor key, value in zip(ahorros_list, ahorros[ahorros_list].sum(axis=0)):\n  fig.add_trace(go.Bar(x=x, y=[value], name=key))\n\nx = ['financiaci\u00f3n']\nfor key, value in zip(financiacion_list, financiacion[financiacion_list].sum(axis=0)):\n  fig.add_trace(go.Bar(x=x, y=[value], name=key))\n\nx = ['cuenta']\nfor key, value in zip(cuentas_list, cuentas[cuentas_list].sum(axis=0)):\n  fig.add_trace(go.Bar(x=x, y=[value], name=key))\n\nfig.update_layout(barmode='stack', xaxis={'categoryorder':'category ascending'})\n\nfig.show()","927b0642":"totales = alta_baja_total (contrataciones_nuevas, 'value')\n#totales.set_index('pk_partition', inplace=True)\ntotales = totales.iloc[1:]\n  \ntry: \n    products_new_clients.set_index('pk_partition', inplace=True)\nexcept: \n    pass\n\nnew = products_new_clients[list_products].sum(axis=1).to_frame().reset_index()\nnew.columns = ['pk_partition','new']\ntotales['pk_partition'] = pd.to_datetime( totales['pk_partition'] )\n\ntotales = pd.merge(totales, new, how='left', on='pk_partition')\n#totales['new'] = products_new_clients[list_products].sum(axis=1)\ntotales['recurrent'] = totales['value'] - totales['new']","f029cee7":"fig = go.Figure()\nfig.add_trace(go.Scatter(x=totales[\"pk_partition\"], y= totales[\"value\"], name='Totales'))\nfig.add_trace(go.Scatter(x=totales[\"pk_partition\"], y= totales[\"recurrent\"], name='Clientes Recurrentes'))\nfig.add_trace(go.Scatter(x=totales[\"pk_partition\"], y= totales[\"new\"], name='Clientes Nuevos'))\n\nfig.update_yaxes(range=[0, totales.max()['value']*1.05])\nfig.update_layout(title= 'Evoluci\u00f3n de las altas',\n                   yaxis_title='Altas mensuales')\n\nfig.show()","a48b5b5f":"commercial_products_sorted = commercial_products.sort_values(by=['pk_cid', 'pk_partition'])\ncommercial_products_sorted","41290f00":"len(commercial_products_sorted['pk_cid'].unique())","52f6e631":"# Hay clientes que pueden ser no pagadores: se dan de alta de un producto (no pasan 3 meses), se dan de alta de otro en el mes 3... Hay que mirar por producto\npaying_customers = {}\nfor prod in list_products:\n    comm = commercial_products_sorted[['pk_partition','pk_cid',prod]]\n    comm['prev_month1'] = comm.groupby('pk_cid')[prod].shift(1)\n    comm['prev_month2'] = comm.groupby('pk_cid')[prod].shift(2)\n    comm['prev_month3'] = comm.groupby('pk_cid')[prod].shift(3)\n\n    condition = (comm['prev_month1']==1) & (comm['prev_month2']==1) & \\\n        ( (comm['prev_month3']==1) | ((comm['prev_month3'].isna()) | (comm['pk_partition']=='2018-03-28')))\n    #condition = (comm['prev_month1']==1) & (comm['prev_month2']==1) & (comm['prev_month3']==1)\n\n    commercial_products_sorted[prod] = condition\n    #add_df = comm.groupby('pk_partition')[prod].sum()\n#paying_customers_df['totales'] = paying_customers.groupby('pk_partition')['loans'].count()\n#paying_customers_df\n\ncommercial_products_sorted.head()","21d65dbe":"commercial_products_sorted['status'] = commercial_products_sorted[list_products].max(axis='columns')\npaying_customers_df = commercial_products_sorted.groupby('pk_partition')[list_products].sum()\npaying_customers_df['totales'] = commercial_products_sorted.groupby('pk_partition')['status'].sum()\npaying_customers_df","1db23195":"if run == True:\n    paying_customers_df.to_csv(PATH_DATA+'clientes_pagadores.csv')","05cc26a5":"commercial_products_sorted = commercial_products.sort_values(by=['pk_cid', 'pk_partition'])\ncommercial_products_sorted['status'] = commercial_products_sorted[list_products].max(axis='columns')","cbf7c2a8":"total_customers_df = commercial_products_sorted[ commercial_products_sorted['status']==1].groupby('pk_partition')[list_products].sum()\ntotal_customers_df['totales'] = commercial_products_sorted[ commercial_products_sorted['status']==1].groupby('pk_partition')['loans'].count()\ntotal_customers_df","6bf02124":"if run == True:\n    total_customers_df.to_csv(PATH_DATA+'clientes_totales.csv')","ddd2b6cb":"fig = go.Figure()\nfig.add_trace( go.Scatter(x=total_customers_df.index[2:], y=total_customers_df['totales'][2:],\n                    mode='lines',name='Clientes Totales' ))\nfig.add_trace( go.Scatter(x=paying_customers_df.index[2:], y= paying_customers_df['totales'][2:],\n                    mode='lines',name='Clientes Pagadores' ))\n\nfig.update_yaxes(range=[0, total_customers_df['totales'].max()*1.05])\nfig.show()\n","542e6591":"commercial_products_sorted = commercial_products.sort_values(by=['pk_cid', 'pk_partition'])","df303419":"for prod in list_products:\n    comm = commercial_products_sorted[['pk_partition','pk_cid',prod]]\n    comm['prev_month1'] = comm.groupby('pk_cid')[prod].shift(1)\n    comm['prev_month2'] = comm.groupby('pk_cid')[prod].shift(2)\n    comm['prev_month3'] = comm.groupby('pk_cid')[prod].shift(3)\n\n    comm.fillna(-2, inplace=True)\n\n    condition = (comm['prev_month1']==1) & (comm['prev_month2']==1) & \\\n        ((comm['prev_month3']==0) | ((comm['prev_month3']==-2) & (comm['pk_partition']!='2018-03-28')))\n\n    commercial_products_sorted[prod] = condition\n\ncommercial_products_sorted","1e4238fe":"# last year\ncommercial_products_sorted['pk_partition'] = commercial_products_sorted['pk_partition'].astype(object)\ncommercial_products_sorted['pk_partition_num'] = commercial_products_sorted['pk_partition'].apply( lambda x : str(x.year) + str(x.month) + str(x.day) )\ncommercial_products_sorted['pk_partition_num'] = commercial_products_sorted['pk_partition_num'].astype(int)\n\ncommercial_products_sorted = commercial_products_sorted[ commercial_products_sorted['pk_partition_num'] >= 20180528 ]\n\ncustomers_pay = commercial_products_sorted.groupby('pk_cid')[list_products].sum()\n\nresumen_clv = customers_pay[list_products].sum()","a3ef7830":"ingresos_per_customer = commercial_products_sorted.copy(deep=True)\ningresos_per_customer['buy'] = ingresos_per_customer[list_products].max(axis=1)\ningresos_per_customer","ee84131f":"ingresos_per_customer = commercial_products_sorted.copy(deep=True)\ningresos_per_customer['buy'] = ingresos_per_customer[list_products].max(axis=1)\npct_buyers = ingresos_per_customer['buy'].sum(axis=0)\/ingresos_per_customer.shape[0]*100\n\ningresos_per_customer = ingresos_per_customer[ ingresos_per_customer['buy'] == True ]\n\nfor key, value in products_dict.items():\n  ingresos_per_customer[key] = ingresos_per_customer[key]*cost_product[value] \n\ningresos_per_customer['total'] = ingresos_per_customer[list_products].sum(axis='columns')","0d2a0293":"resumen_clv['mean_clv'] = ingresos_per_customer['total'].mean()\nresumen_clv['pct_buyers'] = pct_buyers\nresumen_clv","a60207e8":"plt.hist( ingresos_per_customer['total'] )\nplt.show()","7b5f31c5":"resumen_clv = pd.DataFrame(resumen_clv).T\nif run == True:\n    resumen_clv.to_csv(PATH_DATA+'resumen_ultimo_anyo.csv')","8a5e1ecd":"altas_ahorros, altas_financiacion, altas_cuentas = tipos_producto(contrataciones_nuevas, products_dict)\nbajas_ahorros, bajas_financiacion, bajas_cuentas = tipos_producto(bajas_sin_cobro+bajas_con_cobro, products_dict)","9deb1ca1":"tipo_producto = 'Ahorros e inversi\u00f3n' # Ahorros e inversi\u00f3n - Financiaci\u00f3n - Cuentas\ntipo_producto = 'Financiacion'\n\nif tipo_producto == 'Ahorros e inversi\u00f3n':\n  tipo_ingresos = ahorros_df.copy(deep=True)\n  tipo_productos = prod_ahorros.copy(deep=True)\n  tipo_altas = altas_ahorros.copy(deep=True)\n  tipo_bajas = bajas_ahorros.copy(deep=True)\nelif tipo_producto == 'Financiacion':\n  tipo_ingresos = financiacion_df.copy(deep=True)\n  tipo_productos = prod_financiacion.copy(deep=True)\n  tipo_altas = altas_financiacion.copy(deep=True)\n  tipo_bajas = bajas_financiacion.copy(deep=True)\nelif tipo_producto == 'Cuentas':\n  tipo_ingresos = cuenta_df.copy(deep=True)\n  tipo_productos = prod_cuentas.copy(deep=True)\n  tipo_altas = altas_cuentas.copy(deep=True)\n  tipo_bajas = bajas_cuentas.copy(deep=True)\n\ntipo_ingresos","fa55284c":"tipo_ingresos.columns.to_list()","957c2df9":"ingresos_totales = alta_baja_total(tipo_ingresos,'ingresos')\ningresos_totales\n  \nfig = go.Figure()\nfig.add_trace(go.Scatter(x=ingresos_totales['pk_partition'], y=ingresos_totales['ingresos'], name='Totales'))\n\nfor prod in tipo_ingresos.columns:\n  ing = tipo_ingresos\n  ing = ing[prod]\n  fig.add_trace(go.Scatter(x=ingresos_totales['pk_partition'], y=ing, name=prod))\n  \nfig.update_layout(title= 'Evoluci\u00f3n de los Ingresos ({})'.format(tipo_producto),\n                   yaxis_title='Ingresos mensuales')\n\nfig.show()","d3442038":"prod_totales = obtener_prod_totales(tipo_productos)\nprod_totales\n  \nfig = go.Figure()\nfig.add_trace(go.Scatter(x=prod_totales['pk_partition'], y=prod_totales['productos'], name='Totales'))\n\nfor prod in tipo_productos.columns:\n  ing = tipo_productos\n  ing = ing[prod]\n  fig.add_trace(go.Scatter(x=prod_totales['pk_partition'], y=ing, name=prod))\n  \nfig.update_layout(title= 'Evoluci\u00f3n de los productos ({})'.format(tipo_producto),\n                   yaxis_title='Productos')\n\nfig.show()","0e7de0d2":"def altas_bajas_por_tipo (df):\n\n  totales = alta_baja_total(df, 'ingresos')\n  totales = totales.iloc[3:]\n\n  fig = go.Figure()\n  fig.add_trace(go.Scatter(x=totales['pk_partition'], y=totales['ingresos'], name='Totales'))\n\n  for prod in df.columns:\n    ing = df[3:]\n    ing = ing[prod]\n    fig.add_trace(go.Scatter(x=totales['pk_partition'], y=ing, name=prod))\n\n  return fig\n\nfig = altas_bajas_por_tipo (tipo_altas) \n\nfig.update_layout(title= 'Evoluci\u00f3n de las altas ({})'.format(tipo_producto),\n                   yaxis_title='Altas de productos mensuales')\n\nfig.show()","b21d7ed6":"fig = altas_bajas_por_tipo (tipo_bajas) \n\nfig.update_layout(title= 'Evoluci\u00f3n de las bajas ({})'.format(tipo_producto),\n                   yaxis_title='Bajas de productos mensuales')\n\nfig.show()","4959ac2b":"# Global\ntry:\n    tipo_productos.set_index('pk_partition', inplace=True)\nexcept:\n    pass\n\nchurn_global = pd.DataFrame(tipo_productos.sum(axis=1))\nchurn_global.columns = ['productos']\nchurn_global['old'] = churn_global['productos'].shift(1)\n\nchurn_global['altas'] = pd.DataFrame(tipo_altas.sum(axis=1))\nchurn_global['bajas'] = pd.DataFrame(tipo_bajas.sum(axis=1))\nchurn_global['churn_rate'] = churn_global['bajas']\/(churn_global['old'] + churn_global['altas'])*100\nchurn_global = churn_global[1:]\n\nchurn_global","46d42d53":"print('El Churn Rate medio de {} es del {:3f} %'.format(tipo_producto, churn_global['churn_rate'].mean()))","581e4e1f":"# Global (all)\nchurn_all = tipo_productos.copy(deep=True)\nchurn_cols = []\n\nfor x in churn_all.columns:\n  churn_all['old'] = churn_all[x].shift(1)\n  churn_all['altas'] = tipo_altas[x]\n  churn_all['bajas'] = tipo_bajas[x]\n  name = x+'_rate'\n  churn_all[name] = churn_all['bajas']\/(churn_all['old'] + churn_all['altas'])*100\n  churn_cols.append(name)\n\nchurn_all = churn_all[3:]\nchurn_all = churn_all.reset_index()\n#churn_global\n\nfig = go.Figure()\nfor x in churn_cols:\n  fig.add_trace(go.Scatter(x=churn_all['pk_partition'], y=churn_all[x], name=x[:-5]))\n\nfig.show()","a28b6056":"# Particular\nprod = 'credit_card'\nchurn_local = tipo_productos[[prod]]\nchurn_local['old'] = churn_local[prod].shift(1)\n\nchurn_local['altas'] = tipo_altas[[prod]]\nchurn_local['bajas'] = tipo_bajas[[prod]]\nchurn_local['churn_rate'] = churn_local['bajas']\/(churn_local['old'] + churn_local['altas'])*100\nchurn_local = churn_local[1:]\n\nchurn_local = churn_local.reset_index()\nchurn_local","42fa0601":"print('El Churn Rate medio de {} es del {:3f} %'.format(prod, churn_local['churn_rate'].mean()))","0e63c934":"fig = px.line(churn_local, x='pk_partition', y='churn_rate')\nfig.show()","a5710f6c":"ingresos_tabla = ingresos_df.sum(axis=1).reset_index()\ningresos_tabla.columns = ['pk_partition', 'ingresos']\n\ningresos_tabla['pk_partition'] = pd.to_datetime( ingresos_tabla['pk_partition'] )\ningresos_tabla['month'] = ingresos_tabla['pk_partition'].dt.month\ningresos_tabla['year'] = ingresos_tabla['pk_partition'].dt.year\n\nyear_max = ingresos_tabla['year'].max()\nmonth_max = ingresos_tabla[ ingresos_tabla['year'] == year_max ]['month'].max()\n\ningresos_resumen = pd.DataFrame()\n\n\nfor month in range(1, month_max+1):\n  recent = ingresos_tabla[ (ingresos_tabla['year'] == year_max) & (ingresos_tabla['month'] == month) ] ['ingresos']\n  old = ingresos_tabla[ (ingresos_tabla['year'] == year_max-1) & (ingresos_tabla['month'] == month) ]['ingresos']\n  ingresos_resumen = ingresos_resumen.append( {'recent':recent, 'old':old, 'rate':round( (recent - old) \/ old * 100 *10)\/10}, ignore_index=True )\n\n#ingresos_resumen[1:]","8137f10f":"def calcular_rate (df): # index = pk_partition, 1 column with value\n    tabla = df.reset_index()\n    tabla.columns = ['pk_partition', 'value']\n    tabla = tabla[1:]\n\n    tabla['old'] = tabla['value'].shift(1)\n\n    tabla['rate'] = (tabla['value'] - tabla['old'])\/tabla['old']*100\n    return tabla","841a6770":"ingresos_df['totales'] = ingresos_df.sum(axis=1)\ningresos_tabla = calcular_rate (ingresos_df[['totales']] )","679e7d3a":"fig = px.area(ingresos_tabla, x=\"pk_partition\", y=\"rate\")\n\nfig.update_layout(title= 'Evoluci\u00f3n del crecimiento mensual (Ingresos)',\n                   yaxis_title='Crecimiento mensual')","cc99909a":"recent_comm_prod_df = socioproductscommercial [ commercial_products['pk_partition'] == '2019-05-28' ]","e0c6d75f":"prod = 'securities' \ntipo_prod = products_dict[prod]\n\nproducts = []\n\nfor key, val in products_dict.items():\n    if val == tipo_prod:\n        products.append(key)\n\nproducts","8c71b996":"c1 = (socioproductscommercial [products[0]] == 1) \nc2 = (socioproductscommercial [products[1]] == 1) \nc3 = (socioproductscommercial [products[2]] == 1) \nc4 = (socioproductscommercial [products[3]] == 1) \n\nif len(products) == 5:\n    c5 = (socioproductscommercial [products[4]] == 1) \nelse:\n    c5 = (socioproductscommercial [products[0]] == 1) \n\ninfo_product = socioproductscommercial [ c1 | c2 | c3 | c4 | c5 ]\ninfo_product = info_product.sort_values(['pk_cid','pk_partition'], ascending=False)\ninfo_product = info_product.groupby('pk_cid').last()\n\ninfo_product","36c58bb8":"from plotly.subplots import make_subplots\n\nfig = make_subplots(rows=2, cols=1, subplot_titles=(\"Salario (con outliers)\",\"Salario (sin outliers)\"), vertical_spacing = 0.1)\n\ncolours = {0:['lightseagreen','green'], 1:['lightsalmon','salmon'],2:['palevioletred','indianred'], \n  3:['skyblue','steelblue'],4:['orange','orangered'],5:['fuchsia','magenta']}\ni = 0\n\nfor p in products:\n    salary_box = info_product[ info_product[p] == 1 ]['salary'].dropna()\n    salary_box_without = salary_box[ salary_box < np.percentile(salary_box, q = 95) ]\n    # Use x instead of y argument for horizontal plot\n    fig.add_trace(go.Violin(x=salary_box, name=p, legendgroup=p, \n      fillcolor=colours[i][0], line_color= colours[i][1]), row=1, col=1)\n    fig.add_trace(go.Violin(x=salary_box_without, name=p, legendgroup=p, showlegend = False,\n      box_visible=True, meanline_visible=True, fillcolor=colours[i][0], line_color=colours[i][1]), row=2, col=1)\n    i += 1\n\nfig.update_xaxes(title_text=\"Salario\", row=1, col=1)\nfig.update_xaxes(title_text=\"Salario\", row=2, col=1)\nfig.update_layout(\n    legend=dict(\n      orientation=\"h\", yanchor=\"bottom\", y=1.04,\n      xanchor=\"center\", x=0.5,\n      font=dict(family=\"Courier\",size=14,color=\"black\")\n    ))\n\nfig.update_layout(height=1200, width=1000)\nfig.show()","087aaad1":"def figura_salarios(info_product):\n    fig = make_subplots(rows=2, cols=1, subplot_titles=(\"Salario (con outliers)\",\"Salario (sin outliers)\"), vertical_spacing = 0.1)\n\n    colours = {0:['lightseagreen','green'], 1:['lightsalmon','salmon'],2:['palevioletred','indianred'], \n    3:['skyblue','steelblue'],4:['orange','orangered'],5:['fuchsia','magenta']}\n    i = 0\n\n    for p in products:\n        salary_box = info_product[ info_product[p] == 1 ]['salary'].dropna()\n        try:\n            salary_box_without = salary_box[ salary_box < np.percentile(salary_box, q = 95) ]\n        except:\n            salary_box_without = salary_box\n        # Use x instead of y argument for horizontal plot\n        fig.add_trace(go.Violin(x=salary_box, name=p, legendgroup=p, \n        fillcolor=colours[i][0], line_color= colours[i][1]), row=1, col=1)\n        fig.add_trace(go.Violin(x=salary_box_without, name=p, legendgroup=p, showlegend = False,\n        box_visible=True, meanline_visible=True, fillcolor=colours[i][0], line_color=colours[i][1]), row=2, col=1)\n        i += 1\n\n    fig.update_xaxes(title_text=\"Salario\", row=1, col=1)\n    fig.update_xaxes(title_text=\"Salario\", row=2, col=1)\n    fig.update_layout(\n        legend=dict(\n        orientation=\"h\", yanchor=\"bottom\", y=1.04,\n        xanchor=\"center\", x=0.5,\n        font=dict(family=\"Courier\",size=14,color=\"black\")\n        ))\n\n    fig.update_layout(height=1000, width=700)\n\n    return fig","a8a2d802":"fig = go.Figure()\n\nfor p in products:\n    age_box = info_product[ info_product[p] == 1 ]['age'].dropna()\n    \n    # Use x instead of y argument for horizontal plot\n    fig.add_trace(go.Box(x=age_box, name=p))\n\nfig.update_layout(xaxis_title=\"Edad\",\n    legend=dict(\n      orientation=\"h\", yanchor=\"bottom\", y=1.02,\n      xanchor=\"center\", x=0.5,\n      font=dict(family=\"Courier\",size=14,color=\"black\")\n    ))\nfig.show()","5d9b7eec":"del info_product","e9dd4a28":"#! conda install -c plotly plotly-orca","817534ab":"#3 tipos de productos\nprods = ['securities','em_acount','loans']\n\nfor prod in prods:\n\n    tipo_prod = products_dict[prod]\n\n    products = []\n\n    for key, val in products_dict.items():\n        if val == tipo_prod:\n            products.append(key)\n    \n    c1 = (socioproductscommercial [products[0]] == 1) \n    c2 = (socioproductscommercial [products[1]] == 1) \n    c3 = (socioproductscommercial [products[2]] == 1) \n    c4 = (socioproductscommercial [products[3]] == 1) \n\n    if len(products) == 5:\n        c5 = (socioproductscommercial [products[4]] == 1) \n    else:\n        c5 = (socioproductscommercial [products[0]] == 1) \n\n    info_product = socioproductscommercial [ c1 | c2 | c3 | c4 | c5 ]\n    info_product = info_product.sort_values(['pk_cid','pk_partition'], ascending=False)\n    info_product = info_product.groupby('pk_cid').last()\n\n    # Salarios\n    fig1 = go.Figure()\n\n    fig1 = figura_salarios(info_product)\n\n    # Edades\n    fig2 = go.Figure()\n\n    for p in products:\n        age_box = info_product[ info_product[p] == 1 ]['age'].dropna()\n        \n        # Use x instead of y argument for horizontal plot\n        fig2.add_trace(go.Box(x=age_box, name=p))\n\n    fig2.update_layout(xaxis_title=\"Edad\",\n        legend=dict(\n        orientation=\"h\", yanchor=\"bottom\", y=1.02,\n        xanchor=\"center\", x=0.5,\n        font=dict(family=\"Courier\",size=14,color=\"black\")\n        ))\n    \n    fig2.update_layout(height=1000, width=700)\n\n    if tipo_prod == 'financiaci\u00f3n':\n        tipo_prod = 'financiacion'\n    if tipo_prod == 'ahorro e inversi\u00f3n':\n        tipo_prod = 'ahorro'\n    if tipo_prod == 'cuentas':\n        tipo_prod = 'cuenta'\n\n    #fig1.write_image(PATH_DATA + tipo_prod + \"_salarios.png\")  \n    #fig2.write_image(PATH_DATA + tipo_prod + \"_edades.png\")    ","459cb527":"info_product_ = socioproductscommercial [ (socioproductscommercial [prod] == 1) ]\ninfo_product_ = info_product_.sort_values(['pk_cid','pk_partition'], ascending=False)\ninfo_product_ = info_product_.groupby('pk_cid').last()\n\ninfo_product_.head()","469c58d8":"spain = pd.DataFrame(spanish_regions_code).T.reset_index()\nspain.columns = ['index','Ciudad','Com.Autonoma']\nspain.head()","90dbe35f":"spain_result = pd.DataFrame(info_product_.groupby('region_code')['pk_partition'].count().sort_values(ascending=False).head(10))\nspain_result.reset_index(inplace=True)\nspain_result = pd.merge(spain_result, spain, left_on='region_code', right_on='index', how='left')\n\nspain_result \n#result = pd.DataFrame(info_product_.groupby('country_id')['pk_partition'].count().sort_values(ascending=False).head(10))\n#result.reset_index(inplace=True)","3584de87":"fig = px.bar(spain_result, x='Ciudad', y='pk_partition')\nfig.show()","495e70be":"info_clients_ = socioproductscommercial.sort_values(['pk_cid','pk_partition'], ascending=False)\ninfo_clients_ = info_clients_.groupby('pk_cid').last()\n\nspain = pd.DataFrame(spanish_regions_code).T.reset_index()\nspain.columns = ['index','Ciudad','Com.Autonoma']\n\nspain_result = pd.DataFrame(info_clients_.groupby('region_code')['pk_partition'].count().sort_values(ascending=False))\nspain_result.reset_index(inplace=True)\nspain_result = pd.merge(spain_result, spain, left_on='region_code', right_on='index', how='left')\n\nspain_result.head(20)","1f87fb4e":"spain_result.columns = ['region_code','number_clients','indice','ciudad','com_autonoma']\n\n# corregimos madrid = Comunidad de Madrid \ncorreccion = {'Madrid':'Com. de Madrid'}\nspain_result['com_autonoma'] = spain_result['com_autonoma'].replace(correccion)\n\nif run == True:\n    spain_result.to_csv(PATH_DATA+'espana.csv')","37d2d872":"#https:\/\/plotly.com\/python\/treemaps\/\n\nfig = px.treemap(spain_result, path=['com_autonoma', 'ciudad'], values='number_clients',\n                  color='number_clients', \n                  color_continuous_scale='RdBu')\nfig.show()","e07cb408":"my_values = spain_result['number_clients'] \nlabels = spain_result['ciudad']\n\nplt.figure(figsize = (30, 8))\nsquarify.plot(sizes = my_values, label = labels,  alpha = 0.8)\nplt.title(\"Regiones de Espa\u00f1a\",fontsize = 23, fontweight = \"bold\")\n\nplt.axis('off')\nplt.tight_layout()","34e92996":"abroad_result = pd.DataFrame(info_clients_.groupby('country_id')['pk_partition'].count().sort_values(ascending=False))\nabroad_result.reset_index(inplace=True)\nabroad_result = abroad_result[ abroad_result['country_id'] != 'ES']\n\ncountry_match = {}\ncontinent_match = {}\nfor key, value in paises_code.items():\n  country_match[key] = value[1]\n  continent_match[key] = value[0]\n\nabroad_result['Pais'] = abroad_result['country_id'].replace(country_match)\nabroad_result['Continente'] = abroad_result['country_id'].replace(continent_match)\nabroad_result['Continente'] = abroad_result['Continente'].replace(continente)\n\nabroad_result","486b0f60":"abroad_result.columns = ['country_id','number_clients','pais','continente']\nif run == True:\n    abroad_result.to_csv(PATH_DATA+'extranjero.csv')","2d87b136":"fig = px.bar(abroad_result, x='pais', y='number_clients')\nfig.show()","fa65eaf0":"my_values = abroad_result['number_clients'] \nlabels = abroad_result['pais']\n\nplt.figure(figsize = (30, 8))\nsquarify.plot(sizes = my_values, label = labels,  alpha = 0.8)\nplt.title(\"Clientes fuera de Espa\u00f1a\",fontsize = 23, fontweight = \"bold\")\n\nplt.axis('off')\nplt.tight_layout()","fdebb640":"fig = px.treemap(abroad_result, path=['continente', 'pais'], values='number_clients',\n                  color='number_clients', \n                  color_continuous_scale='RdBu')\nfig.show()","81a6bdee":"channel_result = pd.DataFrame(info_clients_.groupby('entry_channel')['pk_partition'].count().sort_values(ascending=False))\nchannel_result.reset_index(inplace=True)\n\nfig = px.bar(channel_result.head(10) , x='entry_channel', y='pk_partition')\nfig.show()","1589ad81":"top_channels = channel_result['entry_channel'].head(9).to_list()\n\nchannel_result['entry_channel'] = np.where(~channel_result['entry_channel'].isin(top_channels), 'Others',channel_result['entry_channel'])\nchannel_result = channel_result.groupby('entry_channel').sum()\nchannel_result.reset_index(inplace=True)","2841d92f":"channel_result.columns = ['entry_channel','number_clients']\nif run == True:\n    channel_result.to_csv(PATH_DATA+'entry_channel.csv')","8cf8f95e":"my_values = channel_result['number_clients'].head(15)\nlabels = channel_result['entry_channel'].head(15)\n\nplt.figure(figsize = (30, 8))\nsquarify.plot(sizes = my_values, label = labels,  alpha = 0.8)\nplt.title(\"Canales de entrada\",fontsize = 23, fontweight = \"bold\")\n\nplt.axis('off')\nplt.tight_layout()","5d643216":"import plotly.express as px\nfig = px.pie(channel_result, values='number_clients', names='entry_channel')\nfig.show()","80992e9f":"product_information = pd.DataFrame( )\nadd = pd.DataFrame( range(10) )\n\nfor prod in list_products:\n    info_product_ = socioproductscommercial [ (socioproductscommercial [prod] == 1) ]\n    info_product_ = info_product_.sort_values(['pk_cid','pk_partition'], ascending=False)\n    info_product_ = info_product_.groupby('pk_cid').last()\n\n    # Espana\n    spain = pd.DataFrame(spanish_regions_code).T.reset_index()\n    spain.columns = ['index','Ciudad','Com.Autonoma']\n\n    spain_result = pd.DataFrame(info_product_.groupby('region_code')['pk_partition'].count().sort_values(ascending=False).head(10))\n    spain_result.reset_index(inplace=True)\n    spain_result = pd.merge(spain_result, spain, left_on='region_code', right_on='index', how='left')\n\n    add['producto'] = prod\n    add['ciudad'] = spain_result['Ciudad']\n    add['ciudad_num'] = spain_result['pk_partition']\n\n    # Extranjero\n    abroad_result = pd.DataFrame(info_product_.groupby('country_id')['pk_partition'].count().sort_values(ascending=False).head(11))\n    abroad_result.reset_index(inplace=True)\n    abroad_result = abroad_result[ abroad_result['country_id'] != 'ES']\n\n    country_match = {}\n    for key, value in paises_code.items():\n        country_match[key] = value[1]\n\n    abroad_result['Pais'] = abroad_result['country_id'].replace(country_match)\n\n    add['pais'] = abroad_result['Pais']\n    add['pais_num'] = abroad_result['pk_partition']\n\n    # Channel\n    channel_result = pd.DataFrame(info_product_.groupby('entry_channel')['pk_partition'].count().sort_values(ascending=False).head(10))\n    channel_result.reset_index(inplace=True)\n\n    add['entry_channel'] = channel_result['entry_channel']\n    add['entry_channel_num'] = channel_result['pk_partition']\n\n    product_information = pd.concat( [product_information, add], ignore_index=True )\n\nproduct_information.drop(0, axis=1, inplace=True)\n","1f8776f8":"if run == True:\n    product_information.to_csv(PATH_DATA+'informacion_productos.csv')","8d4cdbf1":"def obtener_permanencia (products_sorted, prod, first_partition, last_partition):\n    prev = 'prev'\n    diff = 'diff'\n    prev_date = 'prev_date'\n\n    prod_df = products_sorted[['pk_cid','pk_partition',prod]]\n\n    prod_df[prev] = prod_df.groupby('pk_cid')[prod].shift(1) # columna con valor del mes anterior \n    prod_df.loc[:,diff] = prod_df[prod] - prod_df[prev] # +1: alta, 0: no cambio, -1: baja\n\n    prod_df.fillna(-2, inplace=True)\n\n    # Consideramos el primer mes como origen\n    prod_df[diff] = np.where( (prod_df[prev] == -2) & (prod_df[prod] == 1) , 1, prod_df[diff] )\n\n    # Nos quedamos con casos: 1 y -1.\n    prod_df = prod_df[ (prod_df[diff] == 1) | (prod_df[diff] == -1) ]\n\n    prod_df.loc[:,prev_date] = prod_df.groupby('pk_cid')['pk_partition'].shift(1)\n\n    prod_df = prod_df[ prod_df[diff] == -1 ]\n\n    prod_df['perm'] = round((prod_df['pk_partition'] - prod_df[prev_date])\/np.timedelta64(1, 'M')) # diferencia en meses\n\n    permanencia = vc_to_dict(prod_df, 'perm', 16) # pasamos el resultado a diccionario\n\n    return permanencia\n\n\ndef vc_to_dict(prod_df, col, imax):\n    dicc = {}\n    result = prod_df[col].value_counts().sort_index()\n\n    for i in range(1,imax+1):\n        if i in result.index:\n            dicc[i] = result[i] \n        else:\n            dicc[i] = 0   \n            \n    return dicc\n\n\ndef dicc_mean(dicc):\n    accu = 0\n    count = 0\n    for x in dicc:\n        accu += x*dicc[x]\n        count += dicc[x]\n    \n    return accu\/count","b1af5a0f":"import warnings\nwarnings.filterwarnings(\"ignore\")\n\nfirst_partition = '2018-01-28'\nlast_partition = '2019-05-28'\n\nproducts = pd.read_csv(PATH_DATA+'products_df.csv', encoding='utf-8')\nproducts.drop(columns=['Unnamed: 0'], inplace=True)\n\nproducts_sorted = products.sort_values(by=['pk_cid', 'pk_partition'])\nproducts_sorted['pk_partition'] = pd.to_datetime(products_sorted['pk_partition'])\n\nlist_products = [\"short_term_deposit\", \"loans\", \"mortgage\", \"funds\", \"securities\", \"long_term_deposit\", \"em_account_pp\", \"credit_card\", \"payroll_account\", \"pension_plan\", \"emc_account\", \"debit_card\", \"em_account_p\", \"em_acount\"]\n\npermanencias = {}\n\nfor prod in list_products:\n    permanencia = obtener_permanencia (products_sorted, prod, first_partition, last_partition)\n    permanencias[prod] = permanencia\n\npermanencias_df = pd.DataFrame(permanencias)\npermanencias_df ","29f4d78a":"if run == True:\n    permanencias_df.to_csv(PATH_DATA+'permanencias.csv')","63b4a283":"prod = 'payroll_account'\nperm = obtener_permanencia (products_sorted, prod, first_partition, last_partition)\n\nmean = dicc_mean(perm)\nprint('La permanencia media de {} es {} meses'.format(prod, mean))\n\nperm = pd.DataFrame(perm, index=['mes']).T\nperm = perm.reset_index()\n\nfig = px.bar(perm, x=\"index\", y=\"mes\", title=\"Permanencia de los clientes para \"+prod)\nfig.update_layout(\n    xaxis = dict(tickmode = 'linear', dtick = 1),\n    yaxis_title='N\u00famero de clientes',\n    xaxis_title='N\u00famero de meses'\n)\nfig.show()","dd66c9a8":"def cambiar_duraciones(vector, duraciones):\n    new_vector = {}\n    for x in duraciones:\n        #print(duraciones[x][0])\n        for i in range( duraciones[x][0], duraciones[x][1]+1 ):\n            #print(i)\n            if i in vector:\n                if x in new_vector:\n                    new_vector[x] += vector[i]\n                else:\n                    new_vector[x] = vector[i]\n    \n    return new_vector","e79ef44d":"prod = 'payroll_account'\nperm = obtener_permanencia (products_sorted, prod, first_partition, last_partition)\n\nduraciones = {'1-2 meses':[1,2], '3-6 meses':[3,6], '7-12 meses':[7,12], 'M\u00e1s de 12 meses':[13,20]}\n\nnew_perm = cambiar_duraciones(perm, duraciones)\nnew_perm = pd.DataFrame(new_perm, index=['mes']).T\nnew_perm = new_perm.reset_index()\n\nfig = px.bar(new_perm, x=\"index\", y=\"mes\", title=\"Permanencia de los clientes para \"+prod)\nfig.update_layout(\n  yaxis_title='N\u00famero de clientes',\n  xaxis_title=''\n)\nfig.show()","61e74187":"prod = 'em_acount'\nprev = 'prev'\ndiff = 'diff'\nprev_date = 'prev_date'\n\nprod_df = products_sorted[['pk_cid','pk_partition',prod]]\nprod_df[prev] = prod_df.groupby('pk_cid')[prod].shift(1)\nprod_df.loc[:,diff] = 0\n\nprod_df.fillna(-2, inplace=True)\n\nprod_df[diff] = np.where( (prod_df[prev] == -2) & (prod_df[prod] == 1) , 1, prod_df[diff] )\n\nprod_df[diff] = np.where( (prod_df[prod] == 1) & (prod_df['pk_partition'] == last_partition), -1, prod_df[diff] )\n\nprod_df = prod_df[ (prod_df[diff] == -1) | (prod_df[diff] == 1) ]\nprod_df.loc[:,prev_date] = prod_df.groupby('pk_cid')['pk_partition'].shift(1)\n\nprod_df = prod_df[ (prod_df['pk_partition'] == last_partition) ]\nprod_df['perm'] = round((prod_df['pk_partition'] - prod_df[prev_date])\/np.timedelta64(1, 'M'))\n\nprod_df.head(20)","cd57dcb7":"def obtener_antiguedad (products_sorted, prod, first_partition, last_partition):\n    prev = 'prev'\n    diff = 'diff'\n    prev_date = 'prev_date'\n\n    prod_df = products_sorted[['pk_cid','pk_partition',prod]]\n    prod_df[prev] = prod_df.groupby('pk_cid')[prod].shift(1)\n    prod_df.loc[:,diff] = 0\n\n    prod_df.fillna(-2, inplace=True)\n\n    prod_df[diff] = np.where( (prod_df[prev] == -2) & (prod_df[prod] == 1) , 1, prod_df[diff] )\n\n    prod_df[diff] = np.where( (prod_df[prod] == 1) & (prod_df['pk_partition'] == last_partition), -1, prod_df[diff] )\n\n    prod_df = prod_df[ (prod_df[diff] == -1) | (prod_df[diff] == 1) ]\n    prod_df.loc[:,prev_date] = prod_df.groupby('pk_cid')['pk_partition'].shift(1)\n\n    prod_df = prod_df[ (prod_df['pk_partition'] == last_partition) ]\n    prod_df['perm'] = round((prod_df['pk_partition'] - prod_df[prev_date])\/np.timedelta64(1, 'M'))\n\n    antiguedad = vc_to_dict(prod_df, 'perm', 16)\n\n    return antiguedad","5b0ec349":"antiguedades = {}\n\nfor prod in list_products:\n    \n    antiguedad = obtener_antiguedad (products_sorted, prod, first_partition, last_partition)\n    antiguedades[prod] = antiguedad\n\nantiguedades_df = pd.DataFrame(antiguedades)\nantiguedades_df ","f9554fe1":"if run == True:\n    antiguedades_df.to_csv(PATH_DATA+'antiguedades.csv')","5e0fd49e":"prod = 'securities'\nantig = obtener_antiguedad (products_sorted, prod, first_partition, last_partition)\n\nmean = dicc_mean(antig)\nprint('La antig\u00fcedad media de {} es {} meses'.format(prod, mean))\n\nantig = pd.DataFrame(antig, index=['mes']).T\nantig = antig.reset_index()\n\nfig = px.bar(antig, x=\"index\", y=\"mes\", title=\"Antig\u00fcedad de los clientes para \"+prod)\nfig.update_layout(\n    xaxis = dict(tickmode = 'linear', dtick = 1),\n    yaxis_title='N\u00famero de clientes',\n    xaxis_title='N\u00famero de meses'\n)\nfig.show()","2e76196c":"prod = 'securities'\nantig = obtener_antiguedad (products_sorted, prod, first_partition, last_partition)\n\nduraciones = {'1-2 meses':[1,2], '3-6 meses':[3,6], '7-12 meses':[7,12], 'M\u00e1s de 12 meses':[13,20]}\n\nnew_antig = cambiar_duraciones(antig, duraciones)\nnew_antig = pd.DataFrame(new_antig, index=['mes']).T\nnew_antig = new_antig.reset_index()\n\nfig = px.bar(new_antig, x=\"index\", y=\"mes\", title=\"Antig\u00fcedad de los clientes para \"+prod)\nfig.update_layout(\n  yaxis_title='N\u00famero de clientes',\n  xaxis_title=''\n)\nfig.show()","19ae4c16":"new_antig","aae06b15":"most_popular_products = products_df[[\"short_term_deposit\", \"loans\", \"mortgage\", \"funds\", \"securities\", \"long_term_deposit\", \"em_account_pp\", \"credit_card\", \"payroll_account\", \"emc_account\", \"debit_card\", \"em_account_p\", \"em_acount\", \"payroll\", \"pension_plan\"]].sum(axis=0)\n\nmost_popular_products = pd.DataFrame(most_popular_products.sort_values()).reset_index()\nmost_popular_products.columns = ['product','units']\n\nmost_popular_products\nfig = px.bar(most_popular_products, x=\"product\", y=\"units\", title=\"Wide-Form Input\")\nfig.show()","d421a70e":"products_by_customer = products_df[ list_products ].sum(axis=1).value_counts().sort_index()\n\ndisplay(products_by_customer)\n\nproducts_by_customer = products_df[ list_products ].sum(axis=1).value_counts(normalize=True).sort_index()\nfig, ax = plt.subplots(figsize=[10,3])\nax.bar(products_by_customer.index, products_by_customer[:])\nplt.show()","a4ca788a":"x = 1\nlist_products\n\nvector = np.arange(len(list_products))\ncomb_2 = []\n\nfor y in vector[vector > x]:\n  comb_2.append([x,y])\n\ncomb_2","6bd3c15d":"two_pack = pd.DataFrame(columns=['producto_1','producto_2','total','total_1','total_2'])\nfor x, y in comb_2:\n    col_x = list_products[x]\n    col_y = list_products[y]\n    df_x = products_df.loc[ (products_df[ col_x ] == True) ]\n    df_y = products_df.loc[ (products_df[ col_y ] == True) ]\n    df = products_df.loc[ (products_df[ col_x ] == True) & (products_df[ col_y ] == True) ]\n    if df.shape[0] != 0:\n       # pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)],\n       #   ignore_index=True)\n        df_ = pd.DataFrame( {'producto_1':col_x, 'producto_2':col_y, 'total':df.shape[0], 'total_1': df_x.shape[0] ,'total_2': df_y.shape[0] }, index=[0] )\n        two_pack = pd.concat( [two_pack, df_], ignore_index=True) \n\ntwo_pack['prop_1'] = two_pack['total'] \/ two_pack['total_1'] * 100\n#two_pack['prop_2'] = two_pack['total'] \/ two_pack['total_2'] * 100\n\ndisplay(two_pack.sort_values('prop_1', ascending=False))","fe820661":"x_ = \"loans\"\n\nx = list_products.index(x_)\nx","1475e71c":"def two_combination(product, products_df):\n  \n    list_products = [\"short_term_deposit\", \"loans\", \"mortgage\", \"funds\", \"securities\", \"long_term_deposit\", \"em_account_pp\", \"credit_card\", \"payroll_account\", \"pension_plan\", \"emc_account\", \"debit_card\", \"em_account_p\", \"em_acount\"]\n    x = boolean_cols.index(product)\n    vector = np.arange(len(boolean_cols))\n    comb_2 = []\n\n    for y in vector[vector > x]:\n        comb_2.append([x,y])\n\n    two_pack = pd.DataFrame(columns=['producto_1','producto_2','total','total_1','total_2'])\n    for x, y in comb_2:\n        col_x = boolean_cols[x]\n        col_y = boolean_cols[y]\n        df_x = products_df.loc[ (products_df[ col_x ] == True) ]\n        df_y = products_df.loc[ (products_df[ col_y ] == True) ]\n        df = products_df.loc[ (products_df[ col_x ] == True) & (products_df[ col_y ] == True) ]\n        if df.shape[0] != 0:\n        # pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)],\n        #   ignore_index=True)\n            df_ = pd.DataFrame( {'producto_1':col_x, 'producto_2':col_y, 'total':df.shape[0], 'total_1': df_x.shape[0] ,'total_2': df_y.shape[0] }, index=[0] )\n            two_pack = pd.concat( [two_pack, df_], ignore_index=True) \n\n    two_pack['prop_1'] = two_pack['total'] \/ two_pack['total_1'] * 100\n    #two_pack['prop_2'] = two_pack['total'] \/ two_pack['total_2'] * 100\n    two_pack.sort_values('prop_1', ascending=False, inplace=True)\n\n    return two_pack\n\ntwo_pack = two_combination(\"mortgage\", products_df)","b934c827":"boolean_cols = [\"short_term_deposit\", \"loans\", \"mortgage\", \"funds\", \"securities\", \"long_term_deposit\", \"em_account_pp\", \"credit_card\", \"payroll_account\", \"emc_account\", \"debit_card\", \"em_account_p\", \"em_acount\", \"payroll\", \"pension_plan\"]\n\ntwo_pack = pd.DataFrame()\n\nfor col in boolean_cols:\n  add = two_combination(col, products_df)\n  two_pack = pd.concat( [two_pack, add] )","c1b55465":"two_pack","73723120":"if run == True:\n    two_pack.to_csv(PATH_DATA+'combinations.csv')","12baff2f":"El principal inconveniente al mostrar las gr\u00e1ficas de salarios y edades es que se necesita cargar en memoria todos los valores para as\u00ed poder representar la distribuci\u00f3n. En el apartado de *Estructura del Dashboard* se mencionaba que se han creado unas tablas intermedias en SQL de manera que el tratamiento y preprocesado de datos para la visualizaci\u00f3n de resultados en el dashboard es \u00ednfima. \n\nPor ende, se decide que estas dos gr\u00e1ficas son generadas en este notebook y guardadas como archivo .png y ser\u00e1n cargadas como imagen en est\u00e1tico en el dashboard. De esta manera, el tiempo de reload o refresh no se ve afectado, aunque se pierden algunas features que ofrece Plotly como es el hover. ","7b616cd9":"El gr\u00e1fico anterior podemos identificar cu\u00e1les son los productos que m\u00e1s y menos han crecido durante el \u00faltimo a\u00f1o.","5f8987f3":"Conocidos los productos que solicitan los que los clientes de nueva entrada, es posible conocer que productos son m\u00e1s solicitados por \u00e9stos. En la siguiente gr\u00e1fica se observa la cantidad de productos agrupados por tipo de producto.\n\nSin duda, em_acount es el m\u00e1s exitoso entre los clientes de nueva entrada. ","0c03a624":"La \u00faltima gr\u00e1fica no aporta mucho valor dado que se espera que la cantidad de productos contratados como tambi\u00e9n la cantidad de usuarios aumente con el tiempo, pero no define qu\u00e9 bien o mal se est\u00e1 haciendo y c\u00f3mo se progresa. Por lo que esta gr\u00e1fica no se presentar\u00e1 en el dashboard.\n\nSimilarmente tambi\u00e9n se puede el n\u00famero de productos en la \u00faltima partici\u00f3n. Seguidamente tambi\u00e9n se presentan las altas desglosadas en cada tipo de producto, as\u00ed como las totales. ","a0f7aa75":"## Combinaciones de productos <a class=\"anchor\" id=\"14\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn este \u00faltimo apartado se obtienen las combinaciones de productos m\u00e1s comunes. Para los clientes con cierto producto se observa que otros productos tambi\u00e9n son contratados por estos mismos. Esta informaci\u00f3n se presenta en una tabla que se incluye en el dashboard. \n\nDonde las 2 primeras columnas hacen referencia al producto en cuesti\u00f3n o producto de referencia y el producto complementario. Los totales indican el n\u00famero de clientes que han solicitado ambos productos, el total de clientes con el producto 1 y con el producto 2; y la \u00faltima columna corresponde al % de clientes que teniendo contratado el producto 1 tambi\u00e9n tienen contratado el producto 2. ","e65c195e":"## Customer Lifetime Value <a class=\"anchor\" id=\"8\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEl <a href=\"https:\/\/www.inboundcycle.com\/blog-de-inbound-marketing\/customer-lifetime-value-cltv-como-calcularlo\">Customer Lifetime Value<\/a> (CLV) o valor del tiempo de vida del cliente es un pron\u00f3stico sobre la cantidad de dinero que espera recibir la empresa por parte de un usuario, durante todo el tiempo en que este siga siendo su cliente.\n\nSeguidamente, se calcula el dinero recibido por cada cliente y se hace la media. Dado los requisitos de permanencia para el cobro, los datos de las primeras particiones se pierden, por lo que en lugar de obtener el CLV en toda su vida, se obtiene el CLV en un a\u00f1o, siendo el dinero que se obtiene de media por cliente.\n\nN\u00f3tese que para el c\u00e1lculo del CLV tan s\u00f3lo se consideran los clientes que han comprado alg\u00fan producto.","b2580348":"El gr\u00e1fico de barras est\u00e1 bien para visualizar la informaci\u00f3n, pero para no saturar el dashboard con tantos gr\u00e1ficos de barras se propone utilizar un tree map para as\u00ed ofrecer m\u00e1s variedad y diversidad en los gr\u00e1ficos. Las provincias son adem\u00e1s agrupadas por Comunidad Aut\u00f3noma.","d319e981":"El siguiente conjunto de gr\u00e1fico muestra por producto y mes a mes el variaci\u00f3n porcentual, de este modo podemos ver los productos de nuestra cartera mas y menos estable a lo largo de los 17 meses.","b0aaee43":"### Clientes recurrentes <a class=\"anchor\" id=\"73\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nUna vez obtenidos los clientes nuevos y las altas que \u00e9stos generan, y conocidas las altas en total, es posible diferenciar entre las altas que provienen de clientes de nueva entrada o de clientes recurrentes. \n\nDado que:\n$$altas_{totales} = altas_{clientes \\; nuevos} +  altas_{clientes \\; recurrentes}$$","1ddab8ae":"### Churn Rate <a class=\"anchor\" id=\"91\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nUna vez obtenidas las bajas y el n\u00famero de productos contratados, es posible obtener una m\u00e9trica relevante para el negocio: el Churn Rate. \n\nEl <a href=\"https:\/\/www.inboundcycle.com\/blog-de-inbound-marketing\/que-es-el-churn-rate-o-tasa-de-cancelacion\">Churn Rate<\/a> o tasa de cancelaci\u00f3n de clientes en espa\u00f1ol es un t\u00e9rmino empresarial propio de los negocios online que hace referencia a la rotaci\u00f3n, migraci\u00f3n y cancelaci\u00f3n de las suscripciones de los clientes. Por lo tanto, debe establecerse como una forma de determinar la cantidad de personas que est\u00e1n est\u00e1n dejando de ser usuarios en un per\u00edodo de tiempo espec\u00edfico. \n\nSe define con la formula:\n\n$$churn \\; rate = \\frac{clientes \\; que \\; abandonan}{ clientes \\; al \\; inicio + nuevos \\; clientes }$$\n\nEsta m\u00e9trica suele contabilizarse de manera mensual, es decir clientes que abandonaron, clientes al inicio y nuevos clientes en un mes dado, como tambi\u00e9n la media de todos los meses.","ce420696":"Finalmente se representan en el mapa los clientes activos siendo \u00e9stos clientes con almenos 1 producto contratado y siendo activos en la plataforma, es decir, active_customer = 1. ","ef26ed41":"El Churn Rate calculado anteriormente tiene en cuenta todos los productos en este tipo de producto. Sin embargo, como se ha observa en la gr\u00e1fica la evoluci\u00f3n del churn rate de cada producto es diferente por lo que un churn rate global puede ocultar deficiencias o flaquezas de alguno de los productos.\n\nEnseguida se calcula el churn rate individual de un producto.","2d32a1d0":"Los pa\u00edses est\u00e1n codificados con 2 letras  <a href=\"https:\/\/laendercode.net\/es\/2-letter-code\/br\">C\u00f3digo Pa\u00edses<\/a>, adem\u00e1s dada la larga lista de pa\u00edses ser\u00eda interesante agruparlos por continente (dejando a Espa\u00f1a fuera de la categor\u00eda Europa pese a estar en ella dado que la mayor\u00eda de clientes son espa\u00f1oles).","8c6ea438":"### An\u00e1lisis de Salario <a class=\"anchor\" id=\"94\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn la siguiente gr\u00e1fica se presenta la distribuci\u00f3n salarial de cada uno de los productos en los productos de financiaci\u00f3n. Dado que los salarios no est\u00e1n normalmente distribuidos y su distribuci\u00f3n est\u00e1 esparcida (spread), contiene muchos outliers. Por lo que se propone deshacernos de los outliers en la parte superior y quedarnos tan s\u00f3lo con los clientes en el 95% inferior, es decir no se consideran el 5% superior.\n\nEl resultado es una distribuci\u00f3n m\u00e1s uniforme donde pueden apreciarse diferencias entre los productos. Por ejemplo, la mediana de salarios de los clientes que contratan pension_plan es menor que la del resto. \n\n\nComo se menciona en <a href=\"https:\/\/www.amazon.es\/Practical-Statistics-Data-Scientists-Essential\/dp\/149207294X\">Practical Statistics for Data Scientists: 50+ Essential Concepts Using R and Python<\/a> de Peter Bruce, Andrew Bruce y Peter Gedeck, cuando hablamos de salario, la mediana es el *estimate* m\u00e1s correcto. En el libro, se pone el ejemplo de la localidad de Medina, Washington que tiene la particularidad de que dos personajes muy importantes viven all\u00ed, Jeff Bezos y Bill Gates. Si se calcula el salario medio de los habitantes de esta localidad el resultado es de millones, sin embargo la realidad de los habitantes dista mucho de este estimado, es por ello que la mediana es m\u00e1s adecuada y refleja la realidad de sus habitantes. ","fa3cbcd3":"## An\u00e1lisis demogr\u00e1fico <a class=\"anchor\" id=\"10\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn esta secci\u00f3n se realiza un estudio demogr\u00e1fico de los clientes. Dado que la mayor\u00eda de clientes son de Espa\u00f1a se decide dividir los clientes en espa\u00f1oles y no espa\u00f1oles (extranjero). \n\n### Regiones en Espa\u00f1a <a class=\"anchor\" id=\"101\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nPara los clientes de Espa\u00f1a, hay un campo llamado regi\u00f3n que indica la provincia de cada uno de ellos. Por lo que se puede diferenciar y clasificar con m\u00e1s detalle.","34d8f2a2":"## Estudio de la permanencia <a class=\"anchor\" id=\"12\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEl objetivo de este apartado es obtener la permanencia en meses de los clientes que han contratado cierto producto. Para ello se trabaja con el dataset de productos y se crea una funci\u00f3n *obtener_permanencia* que permite obtener la permanencia de cada producto. \n\nPosteriormente se guardan los resultados en un diccionario, y se grafica este diccionario ya sea con los meses de manera individual o agrup\u00e1ndolos en grupos de varios meses (para as\u00ed tener una mejor imagen de c\u00f3mo se distribuye la permanencia de ese producto y poder resolver la pregunta de cu\u00e1nta gente cumple la permanencia). ","85460c8e":"## Estructura del dashboard <a class=\"anchor\" id=\"1\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nAntes de pasar a explicar c\u00f3mo se han obtenido las figuras de la parte de An\u00e1lisis. Se explica el estrucutura del dashboard:\n\nPor un lado, se encuentran los archivos csv de *productos_df.csv*, *sociodemographic_df.csv* y *commercial_activity_df.csv*. Estos archivos forman parte de la parte de *Ingestion*. En este notebook, se realizan una serie de tablas intermedias que nos permiten obtener m\u00e9tricas resumen sobre estas tablas. Como por ejemplo, el n\u00famero de altas por producto en cada mes. \n\nLas siguientes tablas intermedias fueron generadas: \n (1) altas, (2) antiguedades, (3) bajas, (4) bajas_con_cobro, (5) bajas_sin_cobro, (6) clientes_pagadores, (7) clientes_primerizos, (8) clientes_totales, (9) combinaciones, (10) contrataciones_cobradas, (11) contrataciones_nuevas, (12) contrataciones_pendientes, (13) entry_channel, (14) espana, (15) extranjero, (16) informacion_productos, (17) mapa_clientes, (18) permanencias, (19) productos_existentes, (20) resumen_ultimo_anyo, (21) usuarios_activos\n\nEl script para pasar las tablas intermedias a SQL se encuentra en <a href=\"https:\/\/github.com\/carlosperez1997\/easymoney_dashboard\/blob\/main\/convert_sql.ipynb\">Convert to SQL<\/a>.\n\nDe esta manera, para la visualizaci\u00f3n de las altas, no hace falta cargar los archivos originales y as\u00ed se evita que el dashboard tarde mucho en cargar la informaci\u00f3n ofreciendo rapidez y una mejor experiencia al usuario.\n\nLas tablas est\u00e1n almacenadas en lo que se conoce como un data warehouse con MySQL en Amazon RDS de Amazon Web Services. De esta manera la informaci\u00f3n de estas tablas puede ser consultada desde cualquier ordenador con conexi\u00f3n internet, permitiendo as\u00ed poder colgar el proyecto en una p\u00e1gina web.\n\nEl proyecto se hostea en PythonAnywhere donde se renta una m\u00e1quina virtual en la que instala los paquetes necesarios y se hace correr el c\u00f3digo del dashboard.","3866ca00":"Dado la metodolog\u00eda de cobro de la compa\u00f1\u00eda, se puede obtener una predicci\u00f3n de los ingresos que se recibir\u00e1n los 2 pr\u00f3ximos meses, dado que las altas de este mes ser\u00e1n las altas cobradas de aqu\u00ed 2 meses, teniendo en cuenta la conversi\u00f3n.\n\nPor ello se plantean tres casos de forecasting de ingresos:\n- Worst Case. Nos quedamos con la conversi\u00f3n m\u00ednima de cada producto.\n- Expected Case. Nos quedamos con la conversi\u00f3n media de cada producto.\n- Best Case. Nos quedamos con la conversi\u00f3n m\u00e1xima de cada producto.\n\nPor lo que se augura que los ingresos los pr\u00f3ximos 2 meses est\u00e9n entre en un rango de valores. Finalmente las conversiones medias de todos los productos considerando el Worst, Expected y Best Case son los siguientes: 44.24%, 63,38%, 74,7%.\n\nEste enfoque es m\u00e1s realista que establecer una conversi\u00f3n de 90% u otro valor, dado que esperar tener una conversi\u00f3n mejor que la m\u00e1xima hist\u00f3rica es demasiado ambicioso, sin embargo poder reproducir los mismos resultados ya previamente obtenidos es m\u00e1s factible. ","ad71d900":"Seguidamente, se obtiene la evoluci\u00f3n temporal de productos y se obtiene el n\u00famero de productos actual. Y despu\u00e9s se dividen las altas y bajas dependiendo de su tipo de producto.","91552f98":"Finalmente estas tablas se guardan en csv y posteriormente son convertidas a tablas en SQL. C\u00f3mo se puede observar para la obtenci\u00f3n de las altas no har\u00e1 falta cargar el archivo de productos de dimensiones mucho m\u00e1s grandes y tan s\u00f3lo bastar\u00e1 con cargar la tabla o csv resumen. Este paso se conoce como *Data Preparation y Computation*.","25127cf8":"Los dos gr\u00e1ficos anteriores nos indican como han evolucionado nuestros productos a lo largo de estos 17 meses. Observamos que, mientras nuestro top ventas (em account) se ha estancado, han aumentado la venta de debit cards, payroll account y pension plan. Por otra parte, los dep\u00f3sitos a corto plazo casi est\u00e1n desapareciendo y los dep\u00f3sitos de largo plazo est\u00e1n decreciendo. ","5718a618":"### Organizamos el dataset","cf3f1645":"Finalmente se obtiene la evoluci\u00f3n de los ingresos mensuales considerando todos los productos y agrupados en los 3 tipos de productos.","cdb0722d":"### An\u00e1lisis de Edad <a class=\"anchor\" id=\"95\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nSimilarmente al punto anterior, en este caso se calcula la distribuci\u00f3n de edades de cada producto. Las informaci\u00f3n de sus distribuciones puede observarse con mayor facilidad por lo que no es necesario deshacerse de outliers. ","d13481a1":"Dado que el proceso para la obtenci\u00f3n de esta gr\u00e1fica es largo y tarda bastante al tener que leer los 3 datasets (y como el dashboard estar\u00e1 en un servidor por lo que cuanto menos demanda de RAM y menor el tiempo de ejecuci\u00f3n mucho mejor). \n\nSe guarda en un csv el n\u00famero de clientes activos por cada pa\u00eds y regi\u00f3n. Este csv despu\u00e9s es convertido a una tabla SQL y as\u00ed tan s\u00f3lo basta con leer los datos de la tabla y poder obtener la imagen.","38726604":"## Obtenci\u00f3n de las altas y bajas <a class=\"anchor\" id=\"2\"><\/a> \n\n[Tabla de Contenidos](#0)\n\nEl principal reto en esta tarea es determinar el n\u00famero de bajas y altas de productos en cada partici\u00f3n. Para determinar las altas que se han cobrado se debe cumplir que el cliente almenos haya pasado 3 meses de permanencia con el producto, por lo que hay que tener en cuenta la evoluci\u00f3n del status de un producto para saber si finalmente se recibieron ingresos.\n\nUna vez conocidas las altas se podr\u00e1n determinar los ingresos. Para ello, primero se importa el dataset de *products_df.csv*. ","24034a55":"En la siguiente gr\u00e1fica pueden diferenciarse las altas en:\n- Altas nuevas\n- Altas pendientes de cobro\n- Altas reci\u00e9n cobradas\n\nPuede observarse que los c\u00e1lculos de altas seg\u00fan su estado est\u00e1n bien calculados, dado que no se pueden cobrar m\u00e1s productos de los que se dieron de alta hace 3 meses, como tampoco se pueden tener m\u00e1s productos pendientes de cobro que altas en el mes anterior. \n\nSimilarmente tambi\u00e9n se dividen las bajas en cada mes en bajas de productos en las que se lleg\u00f3 a cobrar y de las que no. ","d4800521":"### Clientes pagadores y no pagadores <a class=\"anchor\" id=\"74\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nOtra m\u00e9trica interesante a obtener es la evoluci\u00f3n temporal de los clientes seg\u00fan si son pagadores o no. Siendo un cliente pagador alguien que compr\u00f3 un producto y un no pagador alguien que estando en nuestra base de datos nunca compr\u00f3 un producto.\n\nEl reto en este punto es diferenciar los clientes seg\u00fan su actividad en cada producto. Es decir, puede ocurrir que un cliente no cumpla la permanencia en un producto pero s\u00ed lo haga en otro producto ese mismo mes, por lo que se debe particularizar en cada producto para despu\u00e9s poder obtener qu\u00e9 clientes son pagadores o no.","4925637c":"## An\u00e1lisis por canal de entrada <a class=\"anchor\" id=\"11\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn este apartado se realiza un estudio similar al anterior donde se estudia el canal de entrada de los clientes. Se opta por visualizar esta informaci\u00f3n en pie chart, aunque tambi\u00e9n se presenta un gr\u00e1fico de barras y un tree map.","4e974248":"## Mapa de clientes <a class=\"anchor\" id=\"6\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nDel campo county_id y region_code en socialdemographic_df es posible obtener tanto altas, bajas, n\u00famero de productos o ingresos de cada regi\u00f3n y pa\u00eds. Por lo que tambi\u00e9n es posible si se tienen la latitud y longitud de cada capital, graficar un mapa con la cantidad de clientes de cada sitio del planeta.\n\nEn este caso se representar\u00e1n tan s\u00f3lo los clientes activos de cada regi\u00f3n y pa\u00eds. Para obtener los ingresos de cada regi\u00f3n o pa\u00eds, habr\u00eda que tras obtener los ingresos por cada clientes agruparlos por su localidad, algo que es m\u00e1s laborioso, pero posible de realizar. ","9341fb23":"## Evoluci\u00f3n por tipo de productos <a class=\"anchor\" id=\"9\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nComo se ha realizado anteriormente en este apartado se pretende obtener la evoluci\u00f3n de altas, bajas, productos e ingresos para un tipo de producto (ahorros e inversi\u00f3n, financiaci\u00f3n y cuentas) para ello se construyen una serie de funciones que devuelven el dataframe con los resultados y la figura para ser mostrada.\n\nComo se observar\u00e1 m\u00e1s adelante los productos en un mismo tipo comparten caracter\u00edsticas y es una buena manera de reducir el n\u00famero de variables a comparar o a tener en cuenta.","742f1a27":"En la gr\u00e1fica anterior se muestra el crecimiento mensual o variaci\u00f3n percentual respecto al mes anterior de los ingresos. El \u00e1rea sombreada por encima del eje X nos indica meses de crecimiento, mientras que por debajo meses donde los ingresos ese mes fueron menores al mes anterior. C\u00f3mo se puede obervar desde Julio de 2019 hasta Enero de 2019 la empresa creci\u00f3 y aument\u00f3 sus ingresos.","6dbbf749":"Como se observ\u00f3 anteriormente la mayor\u00eda de clientes se dan de alta con cuentas y el producto m\u00e1s vendido es la em_acount por lo que la distribuci\u00f3n est\u00e1 concentrada en los 10 euros (precio de una cuenta). La distribuci\u00f3n tiene est\u00e1 skewed hacia la derecha.","907e099c":"### Ratio de crecimiento <a class=\"anchor\" id=\"92\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nDado que se tiene informaci\u00f3n de 17 hist\u00f3ricos desde Enero de 2018 hasta Mayo de 2019. Una m\u00e9trica sencilla de interpretar y calcular es comparar el estado actual con un a\u00f1o atr\u00e1s o con el mes anterior. Un crecimiento positivo significar\u00e1 que la empresa est\u00e1 creciendo. Se define el crecimiento como:\n\n$$ratio \\_ crecimiento [\\%] = \\frac{valor_{actual} - valor_{pasado}}{valor_{pasado}}\\cdot 100 $$\n\n\nComo se comenta en <a href=\"https:\/\/www.amazon.es\/Lean-Analytics-utilizar-startup-Emprende\/dp\/8416125244\/ref=sr_1_1?adgrpid=59959394361&dchild=1&gclid=CjwKCAjwkN6EBhBNEiwADVfya4xNYFn73QEXn4GhBkveyY4UrvityCVlnaExapqkyOI2O_KajKpsKxoCPbgQAvD_BwE&hvadid=499055720137&hvdev=c&hvlocphy=1005545&hvnetw=g&hvqmt=e&hvrand=5908958132630783138&hvtargid=kwd-296219379062&hydadcr=443_2419024&keywords=lean+analytics&qid=1620549468&sr=8-1\">Lean Analytics<\/a> de Alistar Croll y  Benjamin Yoskovitz, los ratios son id\u00f3neos porque son:\n\n- Simples: Es un num\u00e9ro \u00fanico.\n- Immediatos: Son f\u00e1ciles de generar.\n- Accionable: Puedes cambiar ciertos par\u00e1metros durante el d\u00eda, semana o mes siguiente para cambiarlo. ","4783d868":"## An\u00e1lisis Ventas <a class=\"anchor\" id=\"6\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn esta parte hacemos un an\u00e1lisis de la evoluci\u00f3n de la cartera de productos que tenemos en el mercado, crecimiento mensual en t\u00e9rminos absolutos y relativos y composici\u00f3n. ","bddb80dd":"El CLV anual de un cliente es de 21.08 \u20ac, lo que indica que un cliente pagador de media se gasta 21.08 \u20ac al a\u00f1o. Los clientes que han comprado alg\u00fan producto en el \u00faltimo a\u00f1o equivale al 5.69 % de la cartera de clientes, es decir los clientes que aparecen en nuestra base de datos. ","92276706":"Como se observ\u00f3 en el EDA [PONER LINK], el dataset de productos tiene 17 columnas, 14 de las cuales equivalen a productos indicando con 0 o 1 si el status del producto (es decir si est\u00e1 dado de alta o no). Existen 17 particiones o hist\u00f3ricos, que reflejan el estado de los productos en ese mes.\n\nSeguidamente se implementa una funci\u00f3n llamada *altas_bajas_contrataciones* que permite obtener las altas seg\u00fan si son altas nuevas, si son altas pendientes de cobrar (es decir que el producto sigue contratado pero no ha cumplido la permanencia) y las altas finalmente cobradas. Como tambi\u00e9n obtener las bajas de productos con cobro y sin cobro (no se cobra productos de clientes que no han cumplido la permanencia de 3 meses).","e695c839":"## Estudio de la antig\u00fcedad de los clientes <a class=\"anchor\" id=\"13\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nSimilarmente al apartado anterior, en este caso se estudia la antig\u00fcedad de los clientes que tienen contratado actualmente el producto a consultar. Al igual que en permanencia, se agrupan los valores en meses para as\u00ed obtener una imagen m\u00e1s global de la antig\u00fcedad de la cartera de clientes. ","4ad68c82":"## Obtenci\u00f3n de los ingresos <a class=\"anchor\" id=\"3\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nUna vez obtenidas las altas y bajas se pueden obtener los ingresos. Como se comenta en el correo correspondiente a la Tarea 3: Recomendaci\u00f3n, los ingresos por cada producto son diferentes. Los productos se engloban en 3 grupos principales. Los ingresos por cada tipo son los siguientes:\n- cuenta vendida (10 \u20ac)\n- productos de ahorro e inversi\u00f3n (40 \u20ac)\n- productos de financiaci\u00f3n (60 \u20ac)\n\nCon estos valores es posible obtener los ingresos por cada grupo y los ingresos totales. ","c96eb4bd":"Otra manera de representar una evoluci\u00f3n temporal es con una gr\u00e1fica polar, donde en cada una de las direcciones ($\\theta$) se colocan los meses y en los radios los valores en estos meses. En este caso se representan los usuarios activos.\n\nEste tipo de gr\u00e1fica permite observar estacionalidades y c\u00f3mo se evoluciona a\u00f1o tras a\u00f1o. Una gr\u00e1fica similar que muestra el potencial que tienen las gr\u00e1ficas polares para la representaci\u00f3n de series temporales puede observarse en <a href=\"https:\/\/otexts.com\/fpp2\/seasonal-plots.html\">Seasonal plots en Forecasting: Principles and Practice<\/a>.","90617d91":"Finalmente podemos obtener el n\u00famero de clientes nuevos para cada producto en cada una de las particiones, como tambi\u00e9n el n\u00famero de nuevos clientes totales. N\u00f3tese que la suma de clientes por productos no es igual a la total, dado que un cliente puede darse de alta con varios productos su primera vez (algo poco com\u00fan como se observar\u00e1 m\u00e1s adelante). \n\nLos clientes totales tan s\u00f3lo muestran los clientes nuevos en total, indiferentemente si se han dado de alta con 1 o m\u00e1s productos. ","49eb550a":"Pese a que esta m\u00e9trica pueda parecer interesante, los resultados que se observan en la gr\u00e1fica no permiten extraer demasiadas conclusiones. Por lo que esta gr\u00e1fica no se presentar\u00e1 en el dashboard, quiz\u00e1s otro tipo de visualizaci\u00f3n diferenciando por tipo de producto o cambiando las condiciones de que se considera un cliente pagador permitir\u00edan obtener conclusiones. ","ea777423":"## Informaci\u00f3n sociodemogr\u00e1fica por tipo de producto <a class=\"anchor\" id=\"93\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEl objetivo de este apartado es obtener una serie de gr\u00e1ficas que nos ofrezcan un an\u00e1lisis demogr\u00e1fico de los clientes que tienen contratado X producto, con el objetivo de poder comparar productos seg\u00fan el tipo de clientes que lo contratan. \n\nEn este caso el an\u00e1lisis se har\u00e1 por tipo de producto. El an\u00e1lisis se realizar\u00e1 con la informaci\u00f3n de todos los clientes que han solicitado alguna vez el producto. ","014805a3":"El campo region_code corresponde a la Comunidad Aut\u00f3noma en Espa\u00f1a <a href=\"https:\/\/es.wikipedia.org\/wiki\/Anexo:Provincias_de_Espa%C3%B1a_por_c%C3%B3digo_postal\">Provincias en Espa\u00f1a<\/a>. En el siguiente diccionario se listan todos los c\u00f3digos y comunidades aut\u00f3nomas con la correspondiente capital.\n\nSi desea mostrar cualquier par\u00e1metro en un mapa para ello, se deber\u00e1 entrar la longitud y latitud de cada capital (ya sea capital de pa\u00eds o de regi\u00f3n).\n\nDel dataset de time_series_global del Covid de la escuela de ingenier\u00eda de John Hopkins <a href=\"https:\/\/github.com\/CSSEGISandData\/COVID-19\">Time Series Covid-19<\/a> (con el que se trabaj\u00f3 con Joseph) se pueden obtener las longitudes y latitudes de los pa\u00edses, guardamos en un csv esta informaci\u00f3n. \n\nPor otro lado la informaci\u00f3n de las comunidades aut\u00f3nomas se puede encontrar en <a href=\"https:\/\/www.businessintelligence.info\/resources\/assets\/listado-longitud-latitud-municipios-espana.html\">Latitud y Longitud de ciudades espa\u00f1olas<\/a>. Podr\u00eda realizarse webscraping para obtener las coordenadas, sin embargo se ha optado por descargar el excel con esta lista, leer el excel y hacer un join con la informaci\u00f3n para as\u00ed poder diferenciar las regiones dentro de Espa\u00f1a.","88d08f2c":"En el siguiente dataset *contrataciones_nuevas* se pueden observar el n\u00famero de contrataciones nuevas. Una contrataci\u00f3n nueva es aquella en la que el cliente el mes anterior no ten\u00eda solicitado este producto y decide contratarlo. En las filas tenemos las particiones y en las columnas los productos. ","7f9c981d":"## Conversi\u00f3n <a class=\"anchor\" id=\"5\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nConocidas las altas nuevas en cada mes y las altas finalmente cobradas cada mes, se puede obtener la conversi\u00f3n entre el n\u00famero de productos dados de alta hace 3 meses y el n\u00famero de productos que se han finalmente cobrado este mes. \n\n$$conversion [\\%] = \\frac{ contrataciones_{nuevas - 3 \\; meses \\; antes} }{ contrataciones_{cobradas} } \\cdot 100$$","a38f0320":"## Tipos de clientes <a class=\"anchor\" id=\"7\"><\/a>\n\n### Clientes activos <a class=\"anchor\" id=\"71\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nComo se mencionaba anteriormente, se pueden obtener los clientes activos siendo \u00e9stos clientes con almenos con al menos 1 producto contratado y siendo activos en la plataforma (active_customer = 1). En este caso, se puede obtener el n\u00famero de clientes activos por producto y en cada partici\u00f3n.","f0894027":"Vemos en el gr\u00e1fico anterior que en el \u00faltimo mes tenemos un total de 422K contratos y que en el \u00faltimo mes se firmaron 5000 nuevos contratos. La tendencia es creciente desde enero de 2018.","7960728f":"## Evoluci\u00f3n de hist\u00f3ricos <a class=\"anchor\" id=\"4\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn esta secci\u00f3n se pretende obtener la evoluci\u00f3n en el tiempo de tanto las altas, bajas, productos contratados e ingresos. \n\nUna gr\u00e1fica interesante es ver cu\u00e1les hubieran sido los ingresos por cada mes si la conversi\u00f3n hubiera sido del 100%, es decir que todos los clientes que solicitaron el producto hubieran pasado los 3 meses de permanencia y por lo tanto se les hubiera cobrado por el producto.","f8735e96":"## Tabla de Contenidos <a class=\"anchor\" id=\"0\"><\/a>\n\n1. [Estructura del dashboard](#1)\n2. [Obtenci\u00f3n de las altas y bajas](#2)\n3. [Obtenci\u00f3n de los ingresos](#3)\n4. [Evoluci\u00f3n hist\u00f3ricos](#4)\n5. [Conversi\u00f3n](#5)\n6. [Mapa Clientes](#6)\n7. [Tipos de clientes](#7) <br>\n    7.1. [Clientes Activos](#71) <br>\n    7.2. [Nuevos Clientes](#72) <br>\n    7.3. [Clientes Recurrentes](#73) <br>\n    7.4. [Clientes pagadores y no pagadores](#74) <br>  \n8. [Customer Lifetime Value](#8)\n9. [Evoluci\u00f3n por tipo de productos](#9) <br>\n    9.1. [Churn Rate](#91) <br>\n    9.2. [Ratio de crecimiento](#92) <br>\n    9.3. [Informaci\u00f3n sociodemogr\u00e1fica](#93) <br>\n    9.4. [An\u00e1lisis de Salario](#94) <br>\n    9.5. [An\u00e1lisis de Edad](#95) <br>   \n10. [An\u00e1lisis demogr\u00e1fico](#10) <br>\n    10.1. [Regiones en Espa\u00f1a](#101) <br>\n    10.1. [Pa\u00edses fuera de Espa\u00f1a](#102) <br>  \n11. [An\u00e1lisis por canal de entrada](#11)\n12. [Estudio de la permanencia](#12)\n13. [Estudio de la antig\u00fcedad de los clientes](#13)\n14. [Combinaciones de productos](#14)\n","1297b654":"A continuaci\u00f3n, incorporamos en el dashboard dos etiquetas grandes que indiquen la tasa de crecimiento con respecto al mes anterior y la tasa promedio de los \u00faltimos 12 meses (total productos). Observamos que la tasa promedio mensual de los \u00faltimos 12 meses es mucho mayor a la del \u00faltimo mes.","d9bb660a":"### Nuevos clientes <a class=\"anchor\" id=\"72\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nUn punto importante que se remarcaba en los emails era conocer el n\u00famero de clientes nuevos cada mes. Una vez conocidos, es posible determinar que altas provienen de clientes de nueva entrada o de clientes recurrentes.\n\nUn cliente nuevo se considera alguien que aparece por primera vez en la base de datos y solicita un producto. Sin embargo, aquellos clientes que aparezcan en la base de datos por primera vez, pero que no soliciten ning\u00fan producto en su entrada no se consideran como clientes nuevos. ","2f8342dd":"En las gr\u00e1ficas de arriba, se muestran los ingresos y productos existentes en para los productos de financiaci\u00f3n, el tipo de producto puede ser cambiado y as\u00ed se hace en el dashboard. Seguidamente se obtienen las altas y bajas, en el dashboard tan s\u00f3lo le presentan las bajas y los ingresos, dado que son los c\u00e1lculos m\u00e1s relevantes. ","ffbc899e":"El tree map nos indica que el 70% de los contratos son de em_account, un 10% son debit cards y un 6% son payroll accounts. El restante 14% se distribuyen entre el resto de los 10 productos que tenemos en nuestra cartera.","9e9f69c7":"El c\u00f3digo anterior se encapsula en una funci\u00f3n para que as\u00ed pueda ser utilizada en el dashboard. ","d748b588":"### Pa\u00edses fuera de Espa\u00f1a <a class=\"anchor\" id=\"102\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn este caso se representan los clientes de fuera de Espa\u00f1a. Primero se obtiene un gr\u00e1fico de barras y seguidamente se realiza un treemap agrupando por Continente (o por sub continente dividiendo Am\u00e9rica en Norte y Sur).","96b26863":"**Importaci\u00f3n del dataset y los paquetes**\n\nPrimero se importan los paquetes necesarios y se instalan algunas dependencias.","b1023f0a":"Los ingresos se pueden agrupar seg\u00fan el tipo de producto: ahorros e inversi\u00f3n, financiaci\u00f3n y cuentas. Los ingresos de cad tipo pueden representarse en una barra horizontal stacked como se muestra a continuaci\u00f3n. \n\nDe la \u00faltima partici\u00f3n de otros datasets ya preprocesados o tablas intermedias se pueden obtener el n\u00famero de clientes de nueva entrada, el n\u00famero de usuarios activos y los productos vendidos este \u00faltimo mes.\n\nCon estos datos se ofrece una visi\u00f3n del balance de este mes. ","dca66917":"# Tarea 1: An\u00e1lisis\n\n<a href=\"https:\/\/www.amazon.es\/Hands-Unsupervised-Learning-Using-Python\/dp\/1492035645\">Volver a P\u00e1gina Principal<\/a>\n\nEl objetivo de esta tarea es realizar un an\u00e1lisis de la situaci\u00f3n de la empresa EasyMoney, obteniendo las ventas, altas y bajas de productos como tambi\u00e9n la alta de clientes y su informaci\u00f3n demogr\u00e1fica. Esta informaci\u00f3n se visualizar\u00e1 a trav\u00e9s de un dashboard interactivo donde el equipo de direcci\u00f3n pueda ver cu\u00e1l es la situaci\u00f3n en el \u00faltimo mes, ver c\u00f3mo ha ido evolucionando la empresa y poder distinguir entre los diferentes productos y las caracter\u00edsticas de los clientes que los han contratado.\n\nEn este notebook se obtienen las diferentes gr\u00e1ficas y c\u00e1lculos que se muestran en el dashboard de EasyMoney en la secci\u00f3n de An\u00e1lisis <a href=\"http:\/\/carlosperez1697.pythonanywhere.com\/#analisis\">Visita el Dashboard<\/a>. N\u00f3tese que pueden haber algunos peque\u00f1os cambios en algunas figuras, con el fin de ajustar y mejorar la est\u00e9tica y funcionalidad de las figuras en el dashboard."}}