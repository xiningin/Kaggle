{"cell_type":{"0c433755":"code","03e2a63a":"code","7f495071":"code","46236c11":"code","e616ee83":"code","e70235eb":"code","887b8b41":"code","81871ec0":"code","7a41a9e7":"code","db931c39":"code","13358afc":"code","a2504ff1":"code","aaaa1757":"code","ccd938ec":"code","68739bd2":"code","ce0f9896":"code","0bfce49c":"code","f6898d3e":"code","7511084e":"code","11e5fe3e":"code","6dbf1226":"code","fa5355fa":"code","f9c11db0":"code","6e0c377f":"code","42e99974":"code","aead50af":"code","4cbe6be2":"code","455707eb":"code","dd3b23c8":"code","9100750d":"code","a1a9ca4d":"code","308cab14":"code","7bac241e":"code","972675ac":"code","862585cb":"code","088f951d":"markdown","a55b078a":"markdown","a429c822":"markdown","8d242836":"markdown","1ed93850":"markdown","6d6aa7cd":"markdown","ef9b8200":"markdown","da07827f":"markdown","4595678f":"markdown","22e4f5b2":"markdown","fd41c6a8":"markdown","ff4546b7":"markdown","39fc6c60":"markdown","2a3559ae":"markdown","884579d6":"markdown","e93e2880":"markdown","bb65fd40":"markdown","cc53fba2":"markdown","64736747":"markdown","f559b98c":"markdown","1b0e986a":"markdown","60cdcd64":"markdown","de8c7f87":"markdown","92b31e18":"markdown","d0d8653a":"markdown","db63ed57":"markdown","297c01d3":"markdown","cb87bd4f":"markdown","6af0e334":"markdown","5380b147":"markdown","ea191bf0":"markdown","a4cf9c0d":"markdown","4ab874c6":"markdown","cb6c5cc6":"markdown","a84a97f0":"markdown","4c7cd104":"markdown","d19137c9":"markdown","a50342bb":"markdown"},"source":{"0c433755":"from math import sqrt\nfrom numpy import concatenate\nfrom matplotlib import pyplot\nimport pandas as pd\nfrom datetime import datetime\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import mean_squared_error\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nimport plotly.offline as py\nimport plotly.graph_objs as go\nimport numpy as np\nimport seaborn as sns\npy.init_notebook_mode(connected=True)\n%matplotlib inline","03e2a63a":"data = pd.read_csv(filepath_or_buffer=\"..\/input\/btcusdkraken\/BTCUSDKRAKEN\", index_col=\"Date\")","7f495071":"data.info()","46236c11":"data.head()","e616ee83":"data.tail()","e70235eb":"btc_trace = go.Scatter(x=data.index, y=data['Weighted Price'], name= 'Price')\npy.iplot([btc_trace])","887b8b41":"data['Weighted Price'].replace(0, np.nan, inplace=True)\ndata['Weighted Price'].fillna(method='ffill', inplace=True)","81871ec0":"btc_trace = go.Scatter(x=data.index, y=data['Weighted Price'], name= 'Price')\npy.iplot([btc_trace])","7a41a9e7":"from sklearn.preprocessing import MinMaxScaler\nvalues = data['Weighted Price'].values.reshape(-1,1)\nvalues = values.astype('float32')\nscaler = MinMaxScaler(feature_range=(0, 1))\nscaled = scaler.fit_transform(values)","db931c39":"train_size = int(len(scaled) * 0.7)\ntest_size = len(scaled) - train_size\ntrain, test = scaled[0:train_size,:], scaled[train_size:len(scaled),:]\nprint(len(train), len(test))","13358afc":"def create_dataset(dataset, look_back=1):\n    dataX, dataY = [], []\n    for i in range(len(dataset) - look_back):\n        a = dataset[i:(i + look_back), 0]\n        dataX.append(a)\n        dataY.append(dataset[i + look_back, 0])\n    print(len(dataY))\n    return np.array(dataX), np.array(dataY)","a2504ff1":"look_back = 1\ntrainX, trainY = create_dataset(train, look_back)\ntestX, testY = create_dataset(test, look_back)","aaaa1757":"trainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))\ntestX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))","ccd938ec":"model = Sequential()\nmodel.add(LSTM(100, input_shape=(trainX.shape[1], trainX.shape[2])))\nmodel.add(Dense(1))\nmodel.compile(loss='mae', optimizer='adam')\nhistory = model.fit(trainX, trainY, epochs=300, batch_size=100, validation_data=(testX, testY), verbose=0, shuffle=False)","68739bd2":"pyplot.plot(history.history['loss'], label='train')\npyplot.plot(history.history['val_loss'], label='test')\npyplot.legend()\npyplot.show()","ce0f9896":"yhat = model.predict(testX)\npyplot.plot(yhat, label='predict')\npyplot.plot(testY, label='true')\npyplot.legend()\npyplot.show()","0bfce49c":"yhat_inverse = scaler.inverse_transform(yhat.reshape(-1, 1))\ntestY_inverse = scaler.inverse_transform(testY.reshape(-1, 1))","f6898d3e":"rmse = sqrt(mean_squared_error(testY_inverse, yhat_inverse))\nprint('Test RMSE: %.3f' % rmse)","7511084e":"pyplot.plot(yhat_inverse, label='predict')\npyplot.plot(testY_inverse, label='actual', alpha=0.5)\npyplot.legend()\npyplot.show()","11e5fe3e":"predictDates = data.tail(len(testX)).index","6dbf1226":"testY_reshape = testY_inverse.reshape(len(testY_inverse))\nyhat_reshape = yhat_inverse.reshape(len(yhat_inverse))","fa5355fa":"actual_chart = go.Scatter(x=predictDates, y=testY_reshape, name= 'Actual Price')\npredict_chart = go.Scatter(x=predictDates, y=yhat_reshape, name= 'Predict Price')\npy.iplot([predict_chart, actual_chart])","f9c11db0":"sns.heatmap(data.corr(), annot=True, cmap='RdYlGn', linewidths=0.1, vmin=0)","6e0c377f":"def series_to_supervised(data, n_in=1, n_out=1, dropnan=True):\n    n_vars = 1 if type(data) is list else data.shape[1]\n    df = pd.DataFrame(data)\n    cols, names = list(), list()\n    # input sequence (t-n, ... t-1)\n    for i in range(n_in, 0, -1):\n        cols.append(df.shift(i))\n        names += [('var%d(t-%d)' % (j+1, i)) for j in range(n_vars)]\n    # forecast sequence (t, t+1, ... t+n)\n    for i in range(0, n_out):\n        cols.append(df.shift(-i))\n        if i == 0:\n            names += [('var%d(t)' % (j+1)) for j in range(n_vars)]\n        else:\n            names += [('var%d(t+%d)' % (j+1, i)) for j in range(n_vars)]\n    # put it all together\n    agg = pd.concat(cols, axis=1)\n    agg.columns = names\n    # drop rows with NaN values\n    if dropnan:\n        agg.dropna(inplace=True)\n    return agg","42e99974":"values = data[['Weighted Price'] + ['Volume (BTC)'] + ['Volume (Currency)']].values\nvalues = values.astype('float32')","aead50af":"scaler = MinMaxScaler(feature_range=(0, 1))\nscaled = scaler.fit_transform(values)","4cbe6be2":"reframed = series_to_supervised(scaled, 1, 1)\nreframed.head()","455707eb":"reframed.drop(reframed.columns[[4,5]], axis=1, inplace=True)\nprint(reframed.head())","dd3b23c8":"values = reframed.values\nn_train_hours = int(len(values) * 0.7)\ntrain = values[:n_train_hours, :]\ntest = values[n_train_hours:, :]\n# split into input and outputs\ntrain_X, train_y = train[:, :-1], train[:, -1]\ntest_X, test_y = test[:, :-1], test[:, -1]\n# reshape input to be 3D [samples, timesteps, features]\ntrain_X = train_X.reshape((train_X.shape[0], 1, train_X.shape[1]))\ntest_X = test_X.reshape((test_X.shape[0], 1, test_X.shape[1]))\nprint(train_X.shape, train_y.shape, test_X.shape, test_y.shape)","9100750d":"multi_model = Sequential()\nmulti_model.add(LSTM(100, input_shape=(train_X.shape[1], train_X.shape[2])))\nmulti_model.add(Dense(1))\nmulti_model.compile(loss='mae', optimizer='adam')\nmulti_history = multi_model.fit(train_X, train_y, epochs=300, batch_size=100, validation_data=(test_X, test_y), verbose=0, shuffle=False)","a1a9ca4d":"pyplot.plot(multi_history.history['loss'], label='multi_train')\npyplot.plot(multi_history.history['val_loss'], label='multi_test')\npyplot.legend()\npyplot.show()","308cab14":"yhat = multi_model.predict(test_X)\npyplot.plot(yhat, label='predict')\npyplot.plot(test_y, label='true')\npyplot.legend()\npyplot.show()","7bac241e":"test_X = test_X.reshape((test_X.shape[0], test_X.shape[2]))\n# invert scaling for forecast\ninv_yhat = concatenate((yhat, test_X[:, 1:]), axis=1)\ninv_yhat = scaler.inverse_transform(inv_yhat)\ninv_yhat = inv_yhat[:,0]\n# invert scaling for actual\ntest_y = test_y.reshape((len(test_y), 1))\ninv_y = concatenate((test_y, test_X[:, 1:]), axis=1)\ninv_y = scaler.inverse_transform(inv_y)\ninv_y = inv_y[:,0]","972675ac":"rmse = sqrt(mean_squared_error(inv_y, inv_yhat))\nprint('Test RMSE: %.3f' % rmse)","862585cb":"actual_chart = go.Scatter(x=predictDates, y=inv_y, name= 'Actual Price')\nmulti_predict_chart = go.Scatter(x=predictDates, y=inv_yhat, name= 'Multi Predict Price')\npredict_chart = go.Scatter(x=predictDates, y=yhat_reshape, name= 'Predict Price')\npy.iplot([predict_chart, multi_predict_chart, actual_chart])","088f951d":"**Using Weighted Price as a feature to train the LSTM model**","a55b078a":"**Using additional features for model training\nFind corrleration in features to Weighted Price**","a429c822":"**Plot predicted and actual line graph with X=dates, Y=USD**","8d242836":"**Observation: Volume is corrlerated to Weighted Price. Open, High, Low, Close are directly related to Weighted Price\n\nFunction to convert series to supervised learning**","1ed93850":"**Plot line graph base on Weighted Price**","6d6aa7cd":"RMSE","ef9b8200":"**Plot new line graph again on Weighted Price with newly filled values**","da07827f":"**Plot line graph to show amount loss according the the epoch**","4595678f":"**Use Quandl api to get BTC\/USD data from kraken exchange**","22e4f5b2":"**Split data to 70% training, 30% testing**","fd41c6a8":"**Import necessary library needed for the model training**","ff4546b7":"**Plot line graph with actual price, predicted price with feature Weighted Price, predicted price with features Volume and Weighted Price**","39fc6c60":"**Create function for creating dataset with look back**","2a3559ae":"**Check latest date of data**","884579d6":"**Scaler Inverse Y back to normal value**","e93e2880":"**Plot line graph to show amount loss according the the epoch**","bb65fd40":"**Convert X to dates**","cc53fba2":"**Scaler Inverse Y back to normal value**","64736747":"**Training the LSTM model with 300 epochs**","f559b98c":"**Generate dataset for trainX, trainY, testX, testY**","1b0e986a":"**Root-mean-square error**","60cdcd64":"**Plot line graph with Y as USD**","de8c7f87":"**Use MinMaxScaler to normalize Weighted Price to range from 0 to 1**","92b31e18":"**Normalize features to range from 0 to 1**","d0d8653a":"**Split 70% of data for training and 30% for testing**","db63ed57":"**Make prediction using textX and plotting line graph against testY**","297c01d3":"# **Bitcoin Time Series Prediction with LSTM**\n","cb87bd4f":"**Make prediction using textX and plotting line graph against testY**","6af0e334":"**Drop unncessary columns**","5380b147":"**Get all data values**","ea191bf0":"**Frame as supervised learning**","a4cf9c0d":"**Root-mean-square error**","4ab874c6":"**Reshape X for model training**","cb6c5cc6":"Running the LSTM model with 300 epochs","a84a97f0":"**Fill value 0 data points on Weighted Price with NAN and then use ffill method to fill values**","4c7cd104":"**view data rows**","d19137c9":"**Reshape testY and yhat for plotly**","a50342bb":"**Reading data set**"}}