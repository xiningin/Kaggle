{"cell_type":{"28b87cd3":"code","69db8778":"code","198fbb07":"code","56c21744":"code","f5b35346":"code","b52ff6a9":"code","231971fb":"code","0af33e5b":"code","7453e2e2":"code","14735ac8":"code","7545da5c":"markdown","c48fd55f":"markdown","f10b798f":"markdown","183e3921":"markdown","f655f08b":"markdown","5477529b":"markdown","6630dfbc":"markdown","7c9f989f":"markdown","60918a03":"markdown","460470b2":"markdown"},"source":{"28b87cd3":"import os\nimport skimage\nimport numpy as np\nimport pandas as pd\nimport skimage.segmentation\nimport matplotlib.pyplot as plt\n\nfrom random import shuffle","69db8778":"def rles_to_mask(encs, shape):\n    \"\"\"\n    Decodes a rle.\n\n    Args:\n        encs (list of str): Rles for each class.\n        shape (tuple [2]): Mask size.\n\n    Returns:\n        np array [shape]: Mask.\n    \"\"\"\n    img = np.zeros(shape[0] * shape[1], dtype=np.uint)\n    for m, enc in enumerate(encs):\n        if isinstance(enc, np.float) and np.isnan(enc):\n            continue\n        enc_split = enc.split()\n        for i in range(len(enc_split) \/\/ 2):\n            start = int(enc_split[2 * i]) - 1\n            length = int(enc_split[2 * i + 1])\n            img[start: start + length] = 1 + m\n    return img.reshape(shape)","198fbb07":"df = pd.read_csv('..\/input\/sartorius-cell-instance-segmentation\/train.csv')\ndf = df.groupby('id').agg(list).reset_index()\n\nfor col in df.columns[2:]:\n    df[col] = df[col].apply(\n        lambda x: np.unique(x)[0] if len(np.unique(x)) == 1 else np.unique(x)\n    )","56c21744":"i = 0  # feel free to change that\n\nshape = df[['height', 'width']].values[i]\n\nrles = df['annotation'][i]\nmasks = rles_to_mask(rles, shape).astype(np.uint16)\n\nrles_shuffled = rles.copy()\nshuffle(rles_shuffled)\nmasks_shuffled = rles_to_mask(rles_shuffled, shape).astype(np.uint16)","f5b35346":"f,ax = plt.subplots(1, 2, figsize=(15, 10))\nax[0].axis(False)\nax[0].imshow(masks)\nax[1].axis(False)\nax[1].imshow(masks_shuffled)\nplt.show() ","b52ff6a9":"def compute_iou(labels, y_pred):\n    \"\"\"\n    Computes the IoU for instance labels and predictions.\n\n    Args:\n        labels (np array): Labels.\n        y_pred (np array): predictions\n\n    Returns:\n        np array: IoU matrix, of size true_objects x pred_objects.\n    \"\"\"\n\n    true_objects = len(np.unique(labels))\n    pred_objects = len(np.unique(y_pred))\n\n    # Compute intersection between all objects\n    intersection = np.histogram2d(\n        labels.flatten(), y_pred.flatten(), bins=(true_objects, pred_objects)\n    )[0]\n\n    # Compute areas (needed for finding the union between all objects)\n    area_true = np.histogram(labels, bins=true_objects)[0]\n    area_pred = np.histogram(y_pred, bins=pred_objects)[0]\n    area_true = np.expand_dims(area_true, -1)\n    area_pred = np.expand_dims(area_pred, 0)\n\n    # Compute union\n    union = area_true + area_pred - intersection\n    iou = intersection \/ union\n    \n    return iou[1:, 1:]  # exclude background","231971fb":"def precision_at(threshold, iou):\n    \"\"\"\n    Computes the precision at a given threshold.\n\n    Args:\n        threshold (float): Threshold.\n        iou (np array [n_truths x n_preds]): IoU matrix.\n\n    Returns:\n        int: Number of true positives,\n        int: Number of false positives,\n        int: Number of false negatives.\n    \"\"\"\n    matches = iou > threshold\n    true_positives = np.sum(matches, axis=1) >= 1  # Correct objects\n    false_negatives = np.sum(matches, axis=1) == 0  # Missed objects\n    false_positives = np.sum(matches, axis=0) == 0  # Extra objects\n    tp, fp, fn = (\n        np.sum(true_positives),\n        np.sum(false_positives),\n        np.sum(false_negatives),\n    )\n    return tp, fp, fn","0af33e5b":"def iou_map(truths, preds, verbose=0):\n    \"\"\"\n    Computes the metric for the competition.\n    Masks contain the segmented pixels where each object has one value associated,\n    and 0 is the background.\n\n    Args:\n        truths (list of masks): Ground truths.\n        preds (list of masks): Predictions.\n        verbose (int, optional): Whether to print infos. Defaults to 0.\n\n    Returns:\n        float: mAP.\n    \"\"\"\n    ious = [compute_iou(truth, pred) for truth, pred in zip(truths, preds)]\n    \n    print(ious[0].shape)\n\n    if verbose:\n        print(\"Thresh\\tTP\\tFP\\tFN\\tPrec.\")\n\n    prec = []\n    for t in np.arange(0.5, 1.0, 0.05):\n        tps, fps, fns = 0, 0, 0\n        for iou in ious:\n            tp, fp, fn = precision_at(t, iou)\n            tps += tp\n            fps += fp\n            fns += fn\n\n        p = tps \/ (tps + fps + fns)\n        prec.append(p)\n\n        if verbose:\n            print(\"{:1.3f}\\t{}\\t{}\\t{}\\t{:1.3f}\".format(t, tps, fps, fns, p))\n\n    if verbose:\n        print(\"AP\\t-\\t-\\t-\\t{:1.3f}\".format(np.mean(prec)))\n\n    return np.mean(prec)","7453e2e2":"iou_map([masks], [masks], verbose=1)  # This should score 1","14735ac8":"iou_map([masks], [masks_shuffled], verbose=1)","7545da5c":"As you can see that shuffling RLEs do change the score.","c48fd55f":"## IoU","f10b798f":"## Ground truth","183e3921":"## Compute","f655f08b":"## Precision","5477529b":"### IoU","6630dfbc":"# Order of instances in metric \/ submission\n\nThis notebook demonstrates that the LB score might depend on order of instance row in the submission.\n\nThe code was taken from [here](https:\/\/www.kaggle.com\/theoviel\/competition-metric-map-iou) and modified for the demo.\n\n[Here](https:\/\/www.kaggle.com\/c\/sartorius-cell-instance-segmentation\/discussion\/288762) is discussion thread for your comments and feedback.","7c9f989f":"# Metric","60918a03":"## Overall Metric","460470b2":"# Load Example"}}