{"cell_type":{"f5a5ff81":"code","d79a5134":"code","d52b1aad":"code","18b837ac":"code","c882ec84":"code","dda708cc":"code","f18c088c":"code","baeec37b":"markdown","8bf1217b":"markdown","3119c89d":"markdown","3dd87d62":"markdown","be968d16":"markdown","1f7ae134":"markdown","422e6d83":"markdown","00a33f65":"markdown","c7841064":"markdown"},"source":{"f5a5ff81":"## Top-Down Heapsort\nclass TD_Heapsort():\n    def __init__(self,a,direction='aufsteigend',tiebreak='links'):        \n        # Prepare the correct test\n        if direction == 'absteigend':\n            self.test = lambda x,y: x < y\n        else: # aufsteigend\n            self.test = lambda x,y: x > y\n        # Tiebreaking: left or right\n        self.left = True if tiebreak=='links' else False\n        self.vgl = 0 # Z\u00e4hlen der Vergleiche\n        # Now sort it\n        self.phase1(a)\n        self.phase2(a)\n        if debug: print(\"\\nVergleiche:\",self.vgl,\"\\n\")\n        \n    '''\n    Min-Heap f\u00fcr absteigende Sortierung (Wurzel <= Kinder)\n    Max-Heap f\u00fcr aufsteigende Sortierung (Wurzel >= Kinder)\n    \n    Rekursive L\u00f6sung (damit es leichter nachverfolgbar ist)\n    '''\n    def sift_in(self,a,i,anfang,ende,step=0):\n        if debug: print(a,\"|\",anfang,ende,\"|\",i,end=' ')\n        s_l = i*2   # linker Sohn\n        s_r = i*2+1 # rechter Sohn\n        # Keine Kinder mehr, done\n        if s_l > ende: \n            if debug: print('-','-','-')\n            return\n        # Bestimme das richtige Kind\n        if s_r > ende: # es gibt nur das linke Kind\n            s = s_l\n            if debug: s_r_str = '-'\n        elif a[s_l-1] == a[s_r-1]:\n            s = s_l if self.left else s_r\n            if debug: s_r_str = str(s_r)\n            self.vgl += 1\n        else:\n            self.vgl += 1\n            s = s_l if self.test(a[s_l-1],a[s_r-1]) else s_r\n            if debug: s_r_str = str(s_r)\n        self.vgl += 1\n        if self.test(a[s-1],a[i-1]):\n            a[s-1],a[i-1] = a[i-1],a[s-1]\n            if debug: print(s_l,s_r_str,s)\n            self.sift_in(a,s,anfang,ende,step+1)\n        elif debug: print(s_l,s_r_str,\"-\")\n                \n                         \n    def phase1(self,a):\n        ende = len(a)\n        mitte = (ende \/\/ 2)\n        for anfang in range(mitte,0,-1):\n            self.sift_in(a,anfang,anfang,ende)\n                \n    def phase2(self,a):\n        l = len(a)\n        for ende in range(l,1,-1):\n            a[ende-1],a[1-1] = a[1-1],a[ende-1]\n            self.sift_in(a,1,1,ende-1)\n            \ndebug = True # Erzeugt eine tabellarische Ausgabe, die \n             # der Tabelle aus \u00dcbung und Klausur entspricht\n\na = [17, 6, 11, 15, 5, 6, 1, 8]\nb = a[:] # COPY of a\nc = a[:] # Another COPY of a\n\nprint(\"Sortiere: \",a,\"\\n\")\nTD_Heapsort(a,tiebreak='rechts')\nprint(\"Aufsteigend sortiert, Tiebreak nach rechts: \",a,\"\\n\\n\")\n\nprint(\"Sortiere: \",b,\"\\n\")\nTD_Heapsort(b)\nprint(\"Aufsteigend sortiert, Tiebreak nach links: \",b,\"\\n\\n\")\n\n\nprint(\"Sortiere: \",c,\"\\n\")\nTD_Heapsort(c,'absteigend')\nprint(\"Absteigend sortiert, Tiebreak nach links: \",c)","d79a5134":"## Top-Down Heapsort\nclass TD_Heapsort():\n    def __init__(self,direction='aufsteigend',tiebreak='links'):        \n        # Tiebreaking: left or right\n        self.left = True if tiebreak=='links' else False\n        # Prepare the correct tests\n        if direction == 'absteigend': # absteigend, Min-Heap\n            self.test_wurzel = lambda s,w: s < w\n            if self.left: \n                self.test_sohn = lambda sl,sr: sl <= sr # Fall 3\n            else:\n                self.test_sohn = lambda sl,sr: sl < sr # Fall 4\n        else: # aufsteigend, Max-Heap\n            self.test_wurzel = lambda s,w: s > w\n            if self.left: \n                self.test_sohn = lambda sl,sr: sl >= sr # Fall 1\n            else:\n                self.test_sohn = lambda sl,sr: sl > sr # Fall 2\n        \n    def sort(self,a):\n        self.vgl = 0 # Z\u00e4hlen der Vergleiche\n        # Now sort it\n        self.phase1(a)\n        self.phase2(a)\n        return self.vgl\n    \n    '''\n    Min-Heap f\u00fcr absteigende Sortierung (Wurzel <= Kinder)\n    Max-Heap f\u00fcr aufsteigende Sortierung (Wurzel >= Kinder)\n    \n    Rekursive L\u00f6sung (damit es leichter nachverfolgbar ist)\n    '''\n    def sift_in(self,a,i,ende):\n        s_l = i*2   # linker Sohn\n        s_r = i*2+1 # rechter Sohn\n        # Keine Kinder mehr, done\n        if s_l > ende: return\n        # Bestimme das richtige Kind\n        if s_r > ende: # es gibt nur das linke Kind\n            s = s_l\n        else:\n            self.vgl += 1\n            s = s_l if self.test_sohn(a[s_l-1],a[s_r-1]) else s_r\n        self.vgl += 1\n        if self.test_wurzel(a[s-1],a[i-1]):\n            a[s-1],a[i-1] = a[i-1],a[s-1]\n            self.sift_in(a,s,ende)\n                         \n    def phase1(self,a):\n        ende = len(a)\n        mitte = (ende \/\/ 2)\n        for anfang in range(mitte,0,-1):\n            self.sift_in(a,anfang,ende)\n                \n    def phase2(self,a):\n        l = len(a)\n        for ende in range(l,1,-1):\n            a[ende-1],a[1-1] = a[1-1],a[ende-1]\n            self.sift_in(a,1,ende-1)\n\na = [17, 6, 11, 15, 5, 6, 1, 8]\nb = a[:] # COPY of a\nc = a[:] # Another COPY of a\n\nh1 = TD_Heapsort(tiebreak=\"rechts\")\nvgl = h1.sort(a)\nprint(\"Aufsteigend sortiert: \",a,\"\\nVergleiche: \",vgl,\"\\n\")\n\nh2 = TD_Heapsort(tiebreak=\"links\")\nvgl = h2.sort(b)\nprint(\"Aufsteigend sortiert: \",b,\"\\nVergleiche: \",vgl,\"\\n\")\n\n\nh3 = TD_Heapsort('absteigend')\nvgl = h3.sort(c)\nprint(\"Absteigend sortiert: \",c,\"\\nVergleiche: \",vgl,\"\\n\")","d52b1aad":"a1 = [9,12,247,18,4,21,99,123,76]\na2 = [1,2,3,4,9,8,7,6,5,4,2,1]\n\n# Create the Heapsorter for \"absteigend\" und \"rechts\"\nh = TD_Heapsort('absteigend','rechts')\n\n# Apply it to data\nvgl = h.sort(a1)\nprint(\"Absteigend sortiert: \",a1,\"\\nVergleiche: \",vgl,\"\\n\")\n\n# ..and again\nvgl = h.sort(a2)\nprint(\"Absteigend sortiert: \",a2,\"\\nVergleiche: \",vgl,\"\\n\")\n\nimport math\nn = len(a2)\n\nprint(\"Absch\u00e4tzung der Vergleiche im O-Kalk\u00fcl:\", n*math.log(n,2))\n","18b837ac":"# Die Magie der Objektorientierung...wir \u00fcberschreiben eine der Methoden\nclass TD_Heapsort_Iterativ(TD_Heapsort):\n    def sift_in(self,a,i,ende,step=0):\n        tausch = True\n        while i*2 <= ende and tausch: # Keine Kinder mehr: \n            s_l = i*2   # linker Sohn\n            s_r = i*2+1 # rechter Sohn\n            # Bestimme das richtige Kind\n            if s_r > ende: # es gibt nur das linke Kind\n                s = s_l\n            else:\n                self.vgl += 1\n                s = s_l if self.test_sohn(a[s_l-1],a[s_r-1]) else s_r\n            self.vgl += 1\n            if self.test_wurzel(a[s-1],a[i-1]):\n                a[s-1],a[i-1] = a[i-1],a[s-1]\n                i = s\n            else:\n                tausch = False\n                \na = [17, 6, 11, 15, 5, 6, 1, 8]\nb = a[:] # COPY of a\nc = a[:] # Another COPY of a\n\nh1 = TD_Heapsort_Iterativ(tiebreak=\"rechts\")\nvgl = h1.sort(a)\nprint(\"Aufsteigend sortiert: \",a,\"\\nVergleiche: \",vgl,\"\\n\")\n\nh2 = TD_Heapsort_Iterativ(tiebreak=\"links\")\nvgl = h2.sort(b)\nprint(\"Aufsteigend sortiert: \",b,\"\\nVergleiche: \",vgl,\"\\n\")\n\nh3 = TD_Heapsort_Iterativ('absteigend')\nvgl = h3.sort(c)\nprint(\"Absteigend sortiert: \",c,\"\\nVergleiche: \",vgl,\"\\n\")\n                ","c882ec84":"class BU_Heapsort(TD_Heapsort):\n    '''\n    Wir m\u00fcssen nur das Einsinken anpassen!\n    '''\n    def sift_in(self,a,i,ende):\n        vgl = 0\n        if debug: print(a,i,ende,end=' ')\n        start = i\n        weg = [i]\n        # Virtuellen Einsinkpfad bestimmen (\"Weg\" in der Tabelle)\n        while i*2 <= ende: # Keine Kinder mehr: \n            s_l = i*2   # linker Sohn\n            s_r = i*2+1 # rechter Sohn\n            # Bestimme das richtige Kind\n            if s_r > ende: # es gibt nur das linke Kind\n                i = s_l\n            else:\n                vgl += 1\n                i = s_l if self.test_sohn(a[s_l-1],a[s_r-1]) else s_r\n            weg.append(i)\n        if debug: print(weg,end=' ')\n        # Einf\u00fcgeposition finden (epos)\n        ringtausch = []\n        epos=start\n        for pos in reversed(weg):\n            # Look for\n            if ringtausch == [] and pos != start:\n                vgl += 1\n                # if self.test_wurzel(a[pos-1],a[start-1]): # W\u00fcrde bei Gleichstand zur\n                # Wurzel weiter nach oben r\u00fccken, semantisch ok, aber nicht, was das\n                # Lernsystem m\u00f6chte!\n                # Besser:\n                # Epos gefunden, wenn s >= w f\u00fcr max_heap bzw. s <= w f\u00fcr min_heap\n                # Getestet wird das mit not (w > s) und not (w < s), weil so\n                # unsere Bedingungen oben gesetzt sind (f\u00fcr TD)\n                if not self.test_wurzel(a[start-1],a[pos-1]): \n                    ringtausch = [start]\n                    store = a[start-1]\n                    epos = pos\n            if ringtausch != []:\n                ringtausch.append(pos)\n                a[pos-1],store = store,a[pos-1]\n        if debug: print(\"Epos:\",epos, \"Ringtausch:\",ringtausch, \"Vgl:\",vgl)\n        self.vgl += vgl # z\u00e4hlen der Vergleiche\n\ndebug = True          \n            \na = [17, 6, 11, 15, 5, 6, 1, 8]\nb = a[:] # COPY of a\nc = a[:] # Another COPY of a\n\nh1 = BU_Heapsort(tiebreak=\"rechts\")\nvgl = h1.sort(a)\nprint(\"Aufsteigend sortiert: \",a,\"\\nVergleiche: \",vgl,\"\\n\")\n\nh2 = BU_Heapsort(tiebreak=\"links\")\nvgl = h2.sort(b)\nprint(\"Aufsteigend sortiert: \",b,\"\\nVergleiche: \",vgl,\"\\n\")\n\n\nh3 = BU_Heapsort('absteigend')\nvgl = h3.sort(c)\nprint(\"Absteigend sortiert: \",c,\"\\nVergleiche: \",vgl,\"\\n\")","dda708cc":"debug = True          \n            \na = [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]\n\nh1 = BU_Heapsort(tiebreak=\"rechts\")\nvgl = h1.sort(a)\nprint(\"Aufsteigend sortiert: \",a,\"\\nVergleiche: \",vgl,\"\\n\")","f18c088c":"debug = True          \n            \na = [13,4,13,17,14]\n\nh1 = BU_Heapsort(tiebreak=\"rechts\")\nvgl = h1.sort(a)\nprint(\"Aufsteigend sortiert: \",a,\"\\nVergleiche: \",vgl,\"\\n\")","baeec37b":"## Top-Down and Bottom-Up Heapsort\n\nVersion 1.0 (5. Juni 2020)\n\nWir beginnen mit einer **Top-Down-Heapsort**-Implementierung, die unsere Tabelle zur Ablaufverfolgung erzeugt. Diesen Code k\u00f6nnen Sie zur Selbstkontrolle nutzen, wenn sie eigene Beispiele ausprobieren und pr\u00fcfen wollen.\n\nWeiter unten folgen noch 2 Implementierungsvarianten, deren Aufbau man im Code m\u00f6glicherweise besser folgen kann, weil sie auf Ausgaben verzichten und die Tests f\u00fcr den zu w\u00e4hlenden Sohn in korrekter Art und Weise umsetzen.\n\nNoch weiter unten folgt dann eine Umsetzung zu **Bottom-Up Heapsort**.","8bf1217b":"Der Code oben ist vermutlich nicht auf den ersten Blick zu verstehen. Insbesondere finden Suche nach Epos und Ringtausch in der gleichen Schleife statt (in der wir \"von hinten\" den Weg abarbeiten, klar, sobald wir die Epos gefunden haben (die wir uns nicht mal merken m\u00fcssten...), k\u00f6nnen wir anfangen, die Werte f\u00fcr den Ringtausch \"nach oben\" zu geben, genau das machen wir. Zus\u00e4tzlich muss man nat\u00fcrlich die Epos mit dem Wert aus der _anfang_-Position f\u00fcllen, klar, und beim \u00dcberschreiben ein wenig aufpassen (Python kann das sehr elegant mit dem logisch parallelen Tausch a,b = b,a, der implizit einen Zwischenspeicher nutzt, um reihenfolgeunabh\u00e4ngig zu sein). Ach ja, der Details gibt es viele...aber sonst m\u00fcsste man ja auch nicht studieren ;)\n\nDie Idee des Algo ist nat\u00fcrlich die bekannte Idee aus der Pr\u00e4sentation: erst den virtuellen Einsinkpfad bestimmen (den Weg w\u00fcrde das Element auf der Position _anfang_ im Baum zur\u00fccklegen, wenn es maximal tief einsinken w\u00fcrde). Dann den Weg so lange r\u00fcckw\u00e4rts (also im Baum von unten) anschauen, bis man die Einf\u00fcgeposition gefunden hat. Dann den Ringtausch durchf\u00fchren, also ausgehend von der Einf\u00fcgeposition, den Rest des R\u00fcckw\u00e4rts-Weges \"nach oben\" mit dem Wert des jeweiligen Nachfolgers und die Einf\u00fcgeposition durch die Wurzel f\u00fcllen, s. unsere Pr\u00e4sentation.\n\nEin wichtiges Detail f\u00fcr das Erledigen von Aufgaben im Lernsystem muss noch genannt werden: wenn man beim Suchen nach der Einf\u00fcgeposition f\u00fcr die \"Wurzel\", also das Element an _anfang_, auf einen Gleichstand trifft, dann hat man die Einf\u00fcgeposition gefunden! Man k\u00f6nnte auch noch weiter nach oben laufen (die Sortierung w\u00e4re immer noch korrekt dann), aber man w\u00fcrde in der Regel mehr Vergleiche ben\u00f6tigen (daf\u00fcr h\u00e4tte man allerdings einen kleineren Ringtausch). In der Klausur kann man das so oder so machen (ich zeige noch einmal ein Beispiel dazu in der Klausurvorbesprechung), im Lernsystem muss man \"so fr\u00fch wie m\u00f6glich\" den Ringtausch durchf\u00fchren.\n\nHier ein Minibeispiel, stellen wir uns vor, unser _anfang_ w\u00e4re die Position $1$, das Element dort (unsere \"Wurzel\") h\u00e4tte den Wert $8$ UND ALLE ELEMENTE ENTLANG DES WEGS $1-2-4-8$ h\u00e4tten ebenfalls den Wert $8$. \n\nAus Sicht der Aufgabe \"Sortiere das Array\" w\u00e4re es nun offensichtlich v\u00f6llig egal, ob wir die $8$ an der Position 1 lassen, oder ob wir sie an eine der anderen Positionen packen und entsprechende Ringt\u00e4usche erzeugen w\u00fcrden. Jede L\u00f6sung w\u00e4re \"semantisch\" korrekt.\n\nDie Implementierung oben will allerdings die Schl\u00fcsselvergleiche minimieren (so, wie es auch die Implementierung im Lernsystem will). Da wir von hinten den Weg anschauen, m\u00fcssen wir stoppen mit den Vergleichen, sobald wir einen Gleichstand finden (so ist es oben auch umgesetzt, wir stoppen beim Max-Heap, wenn Wert des Sohns >= Wurzelwert und beim Min-Heap, wenn Wert des Sohns <= Wurzelwert, verhalten uns also im Gleichheitsfall, wie eben behauptet). Im Beispiel w\u00fcrden wir als Einf\u00fcgeposition f\u00fcr unseren Wurzelwert (Epos genannt) also die Position 8 finden und dann wie folgt ringtauschen: 1->8->4->2->1. Zeigen wir das einmal am Beispiel im Code:\n","3119c89d":"Wenn wir oben im Code des *sift_in* f\u00fcr den Bottom-Up-Heapsort die andere Vergleichszeile (zu Beginn der langen Kommentars zum Thema) einkommentieren und die andere rausnehmen, dann ergibt sich folgenes Bild:\n\n<pre>\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 5 11 [5, 11] Epos: 5 Ringtausch: [] Vgl: 2\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 4 11 [4, 9] Epos: 4 Ringtausch: [] Vgl: 2\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 3 11 [3, 7] Epos: 3 Ringtausch: [] Vgl: 2\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 2 11 [2, 5, 11] Epos: 2 Ringtausch: [] Vgl: 4\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 11 [1, 3, 7] Epos: 1 Ringtausch: [] Vgl: 4\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 10 [1, 3, 7] Epos: 1 Ringtausch: [] Vgl: 4\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 9 [1, 3, 7] Epos: 1 Ringtausch: [] Vgl: 4\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 8 [1, 3, 7] Epos: 1 Ringtausch: [] Vgl: 4\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 7 [1, 3, 7] Epos: 1 Ringtausch: [] Vgl: 4\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 6 [1, 3, 6] Epos: 1 Ringtausch: [] Vgl: 3\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 5 [1, 3] Epos: 1 Ringtausch: [] Vgl: 2\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 4 [1, 3] Epos: 1 Ringtausch: [] Vgl: 2\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 3 [1, 3] Epos: 1 Ringtausch: [] Vgl: 2\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 2 [1, 2] Epos: 1 Ringtausch: [] Vgl: 1\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] 1 1 [1] Epos: 1 Ringtausch: [] Vgl: 0\nAufsteigend sortiert:  [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8] \nVergleiche:  40 \n<\/pre>\n\nMan ben\u00f6tigt hier also mehr Vergleiche, hat aber weniger \"zu tun\" beim Ringtausch. Wie gesagt, in der Klausur kann man das so oder so machen (Hauptsache semantisch korrekt), im Lernsystem muss man sich bei Gleichstand so verhalten, wie es der Code oben tut.\n\nDas \u00dcbersetzen der Ausgaben in unsere Notation f\u00fcr Ringtausch etc. \u00fcberlasse ich Ihnen (sie k\u00f6nnen das auch gern im Code erg\u00e4nzen), das ist absolut \"straightforward\".\n\n## Weitere \u00dcbungsaufgaben\n\n**\u00dcbung1**: Realisieren sie TD- und BU-Heapsort in jeweils wenigstens einer Variante in Java!\n\n**\u00dcbung2**: L\u00f6sen sie von jedem Heapsort-Typ einige Aufgaben im Lernsystem. \n\nDabei hilft der Top-Down in der Regel dabei, zu verstehen, was Heapsort \u00fcberhaupt tut. F\u00fcr die Klausur sollten sie aber unbedingt auch Bottom-Up drauf haben!","3dd87d62":"Der Code l\u00e4uft so, es ist aber nicht so leicht zu verstehen, was genau bei den Vergleichen von S\u00f6hnen untereinander passiert. Davon abgesehen haben wir einen zus\u00e4tzlichen Test oben auf Gleichheit der S\u00f6hne, um entscheiden zu k\u00f6nnen, ob es mit dem linken oder rechten Sohn weiter geht (und mogeln deshalb ein wenig beim Z\u00e4hlen der Vergleiche, schauen Sie mal, ob sie verstehen, wieso die Anzahl Vergleiche am Ende den Sollwert erreicht, und wo wir beim Z\u00e4hlen schummeln). Das k\u00f6nnen wir vermeiden. Zudem ist die L\u00f6sung oben rekursiv, das werden wir weiter unten durch Iteration ersetzen.\n\nEs gibt 4 F\u00e4lle in der Parametrisierung, die in der Klausur vorkommen k\u00f6nnten:\n\n   1. Aufsteigend, Wahl des linken Sohns bei Gleichstand\n   2. Aufsteigend, Wahl des rechten Sohns bei Gleichstand\n   3. Absteigend, Wahl des linken Sohns bei Gleichstand\n   4. Absteigend, Wahl des rechten Sohns bei Gleichstand\n   \nWir nehmen nun an, dass es zu dem zu pr\u00fcfenden Element an Position $i$ zwei Kindpositionen, $s_l$ (linker Sohn) und $s_r$ (rechter Sohn) gibt (anderenfalls g\u00e4be es ohnehin nur einen Vergleich).\n\nWie m\u00fcssen wir in den einzelnen Situationen nun vergleichen, damit wir nur 2 Vergleiche ben\u00f6tigen?\n\n<pre>\n1.    s = s_l if a[s_l] >= a[s_r] else s_r  # links bei Gleichstand, Max-Heap\n2.    s = s_l if a[s_l] >  a[s_r] else s_r  # rechts bei Gleichstand, Max-Heap\n3.    s = s_l if a[s_l] <= a[s_r] else s_r  # links bei Gleichstand, Min-Heap\n4.    s = s_l if a[s_l] <  a[s_r] else s_r  # rechts bei Gleichstand, Min-Heap\n<\/pre>\n\n$s$ ist hier der Index des f\u00fcr den Vergleich gegen die Wurzel ausgew\u00e4hlten Sohnes. \n\nZur Erinnerung: Wenn wir **aufsteigend** sortieren, also am Ende das kleinste Element vorn und das gr\u00f6\u00dfte Element hinten steht, dann verwenden wir einen **Max-Heap**. Wenn wir **absteigend** sortieren, also am Ende das gr\u00f6\u00dfte Element vorn und das kleinste Element hinten steht, dann verwenden wir einen **Min-Heap**.\n\nSetzen wir das entsprechend um:   ","be968d16":"Sie k\u00f6nnen den Code hier gern erg\u00e4nzen um die Debug-Ausgaben von oben. Es sollte dann exakt die gleiche Ausgabe entstehen (f\u00fcr Lernzwecke bzw. zur Selbstkontrolle k\u00f6nnen sie den Code oben nutzen). Hier z\u00e4hlen wir jetzt wirklich jeden Schl\u00fcsselvergleich korrekt.\n\n**Zur Erinnerung:** Bei Top-Down m\u00fcssen sie nicht unbedingt die Vergleiche z\u00e4hlen, w\u00e4hrend sie dem Algo folgen. Sie k\u00f6nnen auch am Ende einfach die Anzahl der Eintr\u00e4ge in den Spalten f\u00fcr linken und rechten Sohn z\u00e4hlen (jeder Sohn f\u00fchrt zu genau einem Vergleich).\n\nMan erzeugt in der zweiten Version jetzt einen parametrisierten Heapsorter, den man wiederholt nutzen kann. Hier sehen Sie, was ich meine:","1f7ae134":"### Noch einige Beispiele:","422e6d83":"## Bottom-Up Heapsort","00a33f65":"Der Vollst\u00e4ndigkeit halber jetzt noch die iterative L\u00f6sung (man erspart sich die Nutzung des Call-Stacks, daf\u00fcr sieht es vielleicht einen Hauch weniger elegant aus durch die boole'sche Variable _tausch_).  ","c7841064":"## Weitere Hinweise zu Top-Down\n\nDadurch, dass wir nicht nach und nach einen Baum aufbauen, sondern von unten nach oben Elemente weiter oben im Baum aufdecken und diese dann einsinken lassen, spielt die _Insert_-Operation aus unseren Pr\u00e4sentationen gar keine Rolle mehr. Das *sift_in* oben entspricht der *DecreaseKey*-Operation, die wir in der Heap-Pr\u00e4sentation erl\u00e4utert haben: wir lassen den Wert an der Position $i$ einsinken in den bereits korrekten Heap unter ihm (so, wie im _DecreaseKey_ das Element einsinken w\u00fcrde, das wir gerade von unten rechts aus dem Heap nach oben geholt haben, um die oben entstandene L\u00fccke nach einem Entfernen des obersten Elements zu f\u00fcllen. In der Phase 2 ist das sogar genau das gleiche! Mal abgesehen davon, dass wir das oberste Element nicht wegwerfen, sondern den Heap um ein Element k\u00fcrzen und auf den frei werdenden Platz das gerade entnommene Element packen).\n\nDas Element _unten rechts_ in einem Heap in Baumdarstellung ist in unserem Array das Element an der Position _ende_ (also \"ganz hinten\" im Heap - das ist nicht immer \"ganz hinten\" im Array, weil wir den \"aktiven\" Heap ja nach und nach verk\u00fcrzen (in Phase 2, in Phase 1 ist es tats\u00e4chlich immer auch das Ende des Array)).\n\nIn den Pr\u00e4sentation nummerieren wir die Elemente im Array in der Regel von $1$ bis $n$ (wobei $n$ die L\u00e4nge des Arrays angibt). Hier in der Implementierung (oder in ihrer eigenen Java-Implementierung) wollen wir nat\u00fcrlich auf $0..(n-1)$ zugreifen. Im Code oben tun wir einfach so, als w\u00fcrde alles im Bereich $1..n$ liegen und ziehen, wann immer wir auf das Array tats\u00e4chlich zugreifen, $1$ ab. Das ist an sich recht schick, weil es das Rechnen beim Halbieren, beim Bestimmen der Kind-Positionen, beim Pr\u00fcfen der Grenzen etc. genauso l\u00e4\u00dft, wie es in den Pr\u00e4sentationen ist, also z.B. hat $i$ weiter die Kinder $2*i$ und $2*i+1$ (wenn man das direkt mit Positionen zwischen $0..(n-1)$ ausdr\u00fccken wollte, w\u00fcrde man $s_l = 2*(i+1)-1 = 2*i+1$ und $s_r = 2*(i+1)+1-1 = 2*i+2$ schreiben, das ergebe f\u00fcr $i=0$ die Kinder $1$ und $2$; f\u00fcr $i=1$, Kinder $3$ und $4$, usw., w\u00fcrde auch gehen, sieht aber einen Hauch \"unintuitiver\" aus - und man m\u00fc\u00dfte nat\u00fcrlich alle Grenzen ver\u00e4ndern um -1, aber daf\u00fcr w\u00fcrden s_l, s_r und i dann direkt die richtige Position im Array angeben).\n\n"}}