{"cell_type":{"2311a253":"code","39626126":"code","61350d98":"code","c1af40d6":"code","ebd3aa5f":"code","5dbe1822":"code","2cf75077":"code","182911bf":"code","e02620ca":"code","e4405aca":"code","569f24fe":"code","a4357551":"code","12a8131c":"code","1a4831a3":"code","b9a6b092":"code","cdb04371":"code","6b88b6c0":"code","f3c7cbd6":"code","4e43f5cb":"code","d8ebff56":"code","c12e12b0":"code","8d2a8583":"code","e309454a":"markdown","64487a9a":"markdown","3765e78a":"markdown","8c4306ca":"markdown","bfc2c062":"markdown","0b3ab503":"markdown","29460e9f":"markdown","d234863c":"markdown","03ad3da3":"markdown","0618cb63":"markdown","889ab0d8":"markdown","c97e3e37":"markdown","4e75c0bb":"markdown","68858c6d":"markdown"},"source":{"2311a253":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nimport matplotlib.cm as cm\nimport plotly.express as px\nimport datetime as dt\nimport math as m\nfrom scipy import stats\nimport statsmodels.api as sm\nimport os\n\nimport warnings\n\nwarnings.simplefilter(\"ignore\", UserWarning)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session\n\ndf_weather = pd.read_csv('..\/input\/knmi-19012020-historical-weather-data\/KNMI_20200710.csv', delimiter=',', nrows = None, low_memory=False)\ndf_weather.dataframeName = 'KNMI_20200710.csv'\n\nnRow, nCol = df_weather.shape\nprint(f'There are {nRow} rows and {nCol} columns')","39626126":"df_weather.info()","61350d98":"df_weather","c1af40d6":"# Reformat data into useful numeric data types\ncol_int = ['DDVEC','FHXH', 'FHNH', 'FXXH', 'TNH', 'TXH', 'T10NH', 'SP', 'Q','RHXH','PXH',\n           'PNH', 'VVN', 'VVNH', 'VVX', 'VVXH', 'NG', 'UG', 'UX', 'UXH', 'UN','UNH']\ncol_flt = ['FHVEC', 'FG', 'FHX', 'FHN', 'FXX', 'TG', 'TN', 'TX', 'T10N', 'SQ', 'DR',\n           'RH', 'RHX', 'PG', 'PX', 'PN', 'EV24']\n\ndf_weather[col_int] = df_weather[col_int].apply(pd.to_numeric, errors = 'coerce', downcast = 'integer')\ndf_weather[col_flt] = df_weather[col_flt].apply(pd.to_numeric, errors = 'coerce').div(10)\ndf_weather = df_weather.drop(['STN'], axis = 1)\n\ndf_weather['YYYYMMDD'] = pd.to_datetime(df_weather['YYYYMMDD'], format='%Y%m%d')\ndf_weather = df_weather.set_index('YYYYMMDD')","ebd3aa5f":"# Daily average temperature of selected year\n\ndef showYearlyAvgTemp(df, year):\n\n    # Collect minimum and maximum daily temperatures from 1901 to 2019\n    data = df[df.index.year <= 2019]\n    min_temp = []\n    max_temp = []\n    nor_temp = []\n\n    for m in range(1,13):\n        month_data = data[data.index.month == m]\n        min_temp.append(month_data.TG.groupby(month_data.index.day).min())\n        max_temp.append(month_data.TG.groupby(month_data.index.day).max())\n\n    min_temp = np.hstack(min_temp) # Minimum average daily temperatures\n    max_temp = np.hstack(max_temp) # Maximum average daily temperatures\n\n    # Normal average temperatures based on three decades 1981-2010\n    data = df[(df.index.year >= 1981) & (df.index.year <= 2010)]\n    for m in range(1,13):\n        month_data = data[data.index.month == m]\n        nor_temp.append(month_data.TG.groupby(month_data.index.day).mean())\n\n    nor_temp = np.hstack(nor_temp) \n    df_nor_temp = pd.DataFrame(nor_temp, columns = ['y'])\n\n    # Data for selected year\n    temp_sel_year = df[df.index.year == year]\n\n    # Plot data\n    plt.figure(figsize = (12, 5))\n\n    ax = sns.lineplot(x = range(1,len(max_temp) + 1), y = max_temp, color = 'r', label = 'Highest 1901-2019')\n    sns.lineplot(x = range(1,len(nor_temp) + 1), y = nor_temp, color = 'lime', label =  'Normal 1981-2010')\n    #sns.lmplot(x = df_nor_temp.index, y = 'y', data = df_nor_temp, order = 2)\n    sns.lineplot(x = range(1,len(min_temp) + 1), y = min_temp, color = 'b', label = 'Lowest 1901-2019')\n    sns.lineplot(x = range(1,temp_sel_year.shape[0] + 1), y = 'TG', data = temp_sel_year, color = 'k', label = 'Year ' + str(year))\n\n    month_labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month_ndays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    month_days = [sum(month_ndays[:i]) for i in range(1,13)]\n\n    ax.grid(axis = 'y')\n    ax.set(xlim = (0, 365), ylim = (-15, 30), xticks = month_days, ylabel = 'Degrees Celsius', title = 'Daily average temperature ' + str(year))\n    ax.set_xticklabels(month_labels, ha = 'right')\n    ax.legend(frameon = False);\n    ","5dbe1822":"showYearlyAvgTemp(df_weather, 2020)\nshowYearlyAvgTemp(df_weather, 2019)","2cf75077":"# Daily average temperature of selected year AND rolling average\n\ndef showYearlyAvgTemp(df, year):\n\n    nor_temp = []\n\n    # Normal average temperatures based on three decades 1981-2010\n    data = df[(df.index.year >= 1981) & (df.index.year <= 2010)]\n    for m in range(1,13):\n        month_data = data[data.index.month == m]\n        nor_temp.append(month_data.TG.groupby(month_data.index.day).mean())\n\n    nor_temp = np.hstack(nor_temp) \n\n    # Data for selected year\n    temp_sel_year = df[df.index.year == year]\n    rol_temp = temp_sel_year.rolling('30D').mean()\n\n    # Plot data\n    plt.figure(figsize = (12, 5))\n\n    ax = sns.lineplot(x = range(1,len(nor_temp) + 1), y = nor_temp, color = 'k', label =  'Normal 1981-2010')\n    sns.lineplot(x = range(1,temp_sel_year.shape[0] + 1), y = 'TG', data = temp_sel_year, color = 'r', label = '24HR avg for year ' + str(year))\n    sns.lineplot(x = range(1,rol_temp.shape[0] + 1), y = 'TG', data = rol_temp, color = 'b', label = 'Rolling 30-day for year ' + str(year))\n\n    month_labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month_ndays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    month_days = [sum(month_ndays[:i]) for i in range(1,13)]\n\n    ax.grid(axis = 'y')\n    ax.set(xlim = (0, 365), ylim = (-5, 30), xticks = month_days, ylabel = 'Degrees Celsius', title = 'Daily rolling average temperature ' + str(year))\n    ax.set_xticklabels(month_labels, ha = 'right')\n    ax.legend(frameon = False);\n    \n","182911bf":"showYearlyAvgTemp(df_weather, 2020)","e02620ca":"# Temperature timeseries\n\ndef showTempRange(df, start_date, end_date):\n    mask = (df.index >= start_date) & (df.index <= end_date)\n    title = 'Average temperature and min\/max spread for ' + start_date + ' to ' + end_date\n    \n    plt.figure()\n    sns.set_style(\"ticks\")\n    ax = sns.lineplot(data = df.TG.loc[mask], color='blue')\n    ax.fill_between(df.index[mask], df.TN.loc[mask], df.TX.loc[mask], facecolor='blue', alpha=0.1)\n    plt.setp(ax.get_xticklabels(), rotation=45, horizontalalignment='right')\n    ax.set(ylabel = 'Degrees Celsius', title = title)","e4405aca":"showTempRange(df_weather, '2020-06', '2020-07')\nshowTempRange(df_weather, '2020-01-01', '2020-01-31')","569f24fe":"# Windrose code - credits https:\/\/github.com\/python-windrose\n\n#!\/usr\/bin\/env python\n# -*- coding: utf-8 -*-\n\n# from __future__ import absolute_import, division, print_function\n\nimport locale\nimport matplotlib as mpl\nfrom matplotlib import docstring\nimport numpy as np\nimport random\nfrom matplotlib.projections.polar import PolarAxes\nfrom numpy.lib.twodim_base import histogram2d\nimport matplotlib.pyplot as plt\n\nZBASE = -1000  # The starting zorder for all drawing, negative to have the grid on\nVAR_DEFAULT = \"speed\"\nDIR_DEFAULT = \"direction\"\nFIGSIZE_DEFAULT = (8, 8)\nDPI_DEFAULT = 80\nCALM_CIRCLE_COLOR = \"red\"\nCALM_CIRCLE_ALPHA = 0.4\n\n\nclass WindAxesFactory(object):\n    \"\"\"\n\n    Factory class to create WindroseAxes or WindAxes\n\n    \"\"\"\n\n    @staticmethod\n    def create(typ, ax=None, *args, **kwargs):\n        \"\"\"\n\n        Create\n\n        Mandatory:\n\n        Parameters\n        ----------\n        typ : string, 'windroseaxes' or 'windaxes'\n            Type of axes to create\n                * windroseaxes : a WindroseAxes axe\n                * windaxe : a WindAxes axe\n\n        ax : matplotlib.Axes, optional\n            A matplotlib axe\n\n        \"\"\"\n        typ = typ.lower()\n        d = {\"windroseaxes\": WindroseAxes, \"windaxes\": WindAxes}\n        if typ in d.keys():\n            cls = d[typ]\n            if isinstance(ax, cls):\n                return ax\n            else:\n                ax = cls.from_ax(ax, *args, **kwargs)\n                return ax\n        else:\n            raise NotImplementedError(\"typ=%r but it might be in %s\" % (typ, d.keys()))\n\n\nclass WindroseAxes(PolarAxes):\n    \"\"\"\n\n    Create a windrose axes\n\n    \"\"\"\n\n    name = \"windrose\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        See Axes base class for args and kwargs documentation\n        \"\"\"\n\n        # Uncomment to have the possibility to change the resolution directly\n        # when the instance is created\n        # self.RESOLUTION = kwargs.pop('resolution', 100)\n        self.rmax = kwargs.pop(\"rmax\", None)\n        self.theta_labels = kwargs.pop(\"theta_labels\") or [\"E\", \"N-E\", \"N\", \"N-W\", \"W\", \"S-W\", \"S\", \"S-E\"]\n        PolarAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(\"equal\", adjustable=\"box\", anchor=\"C\")\n        self.radii_angle = 67.5\n        self.cla()\n\n    @staticmethod\n    def from_ax(ax=None, fig=None, rmax=None, theta_labels=None, *args, **kwargs):\n        \"\"\"\n        Return a WindroseAxes object for the figure `fig`.\n        \"\"\"\n        if ax is None:\n            if fig is None:\n                fig = plt.figure(\n                    figsize=FIGSIZE_DEFAULT,\n                    dpi=DPI_DEFAULT,\n                    facecolor=\"w\",\n                    edgecolor=\"w\",\n                )\n            rect = [0.1, 0.1, 0.8, 0.8]\n            ax = WindroseAxes(fig, rect, facecolor=\"w\", rmax=rmax, theta_labels=theta_labels, *args, **kwargs)\n            fig.add_axes(ax)\n            return ax\n        else:\n            return ax\n\n    def cla(self):\n        \"\"\"\n        Clear the current axes\n        \"\"\"\n        PolarAxes.cla(self)\n\n        self.theta_angles = np.arange(0, 360, 45)\n        self.set_thetagrids(angles=self.theta_angles, labels=self.theta_labels)\n\n        self._info = {\"dir\": list(), \"bins\": list(), \"table\": list()}\n\n        self.patches_list = list()\n\n        self.calm_count = None\n\n    def _colors(self, cmap, n):\n        \"\"\"\n        Returns a list of n colors based on the colormap cmap\n\n        \"\"\"\n        return [cmap(i) for i in np.linspace(0.0, 1.0, n)]\n\n    def set_radii_angle(self, **kwargs):\n        \"\"\"\n        Set the radii labels angle\n        \"\"\"\n\n        kwargs.pop(\"labels\", None)\n        angle = kwargs.pop(\"angle\", None)\n        if angle is None:\n            angle = self.radii_angle\n        self.radii_angle = angle\n        N = 5\n        rmax = self.get_rmax()\n        radii = np.linspace(0, rmax, N + 1)\n        if rmax % N == 0:\n            fmt = \"%d\"\n        else:\n            fmt = \"%.1f\"\n        radii_labels = [fmt % r for r in radii]\n        # radii_labels[0] = \"\"  # Removing label 0\n        self.set_rgrids(\n            radii=radii[1:], labels=radii_labels[1:], angle=self.radii_angle, **kwargs\n        )\n\n    def _update(self):\n        if not self.rmax:\n            self.rmax = np.max(np.sum(self._info[\"table\"], axis=0))\n        calm_count = self.calm_count or 0\n        self.set_rmax(rmax=self.rmax + calm_count)\n        self.set_radii_angle(angle=self.radii_angle)\n\n    def legend(self, loc=\"lower left\", decimal_places=1, units=None, **kwargs):\n        \"\"\"\n        Sets the legend location and her properties.\n\n        Parameters\n        ----------\n        loc : int, string or pair of floats, default: 'lower left'\n            see :obj:`matplotlib.pyplot.legend`.\n\n        decimal_places : int, default 1\n            The decimal places of the formated legend\n\n        units: str, default None\n\n        Other Parameters\n        ----------------\n        isaxes : boolean, default True\n            whether this is an axes legend\n        prop : FontProperties(size='smaller')\n            the font property\n        borderpad : float\n            the fractional whitespace inside the legend border\n        shadow : boolean\n            if True, draw a shadow behind legend\n        labelspacing : float, 0.005\n            the vertical space between the legend entries\n        handlelenght : float, 0.05\n            the length of the legend lines\n        handletextsep : float, 0.02\n            the space between the legend line and legend text\n        borderaxespad : float, 0.02\n            the border between the axes and legend edge\n        kwarg\n            Every other kwarg argument supported by\n            :obj:`matplotlib.pyplot.legend`\n        \"\"\"\n\n        def get_handles():\n            handles = list()\n            for p in self.patches_list:\n                if isinstance(p, mpl.patches.Polygon) or isinstance(\n                    p, mpl.patches.Rectangle\n                ):\n                    color = p.get_facecolor()\n                elif isinstance(p, mpl.lines.Line2D):\n                    color = p.get_color()\n                else:\n                    raise AttributeError(\"Can't handle patches\")\n                handles.append(\n                    mpl.patches.Rectangle(\n                        (0, 0), 0.2, 0.2, facecolor=color, edgecolor=\"black\"\n                    )\n                )\n            return handles\n\n#         def get_labels(decimal_places=1, units=None):\n#             _decimal_places = str(decimal_places)\n\n#             fmt = \"[%.\" + _decimal_places + \"f \" + \": %0.\" + _decimal_places + \"f\"\n\n#             labels = np.copy(self._info[\"bins\"])\n#             if locale.getlocale()[0] in [\"fr_FR\"]:\n#                 fmt += \"[\"\n#             else:\n#                 fmt += \")\"\n\n#             if units:\n#                 fmt += ' ' + units\n\n#             labels = [fmt % (labels[i], labels[i + 1]) for i in range(len(labels) - 1)]\n#             return labels\n\n#         kwargs.pop(\"labels\", None)\n#         kwargs.pop(\"handles\", None)\n\n#         # decimal_places = kwargs.pop('decimal_places', 1)\n\n#         handles = get_handles()\n#         labels = get_labels(decimal_places, units)\n#         self.legend_ = mpl.legend.Legend(self, handles, labels, loc, **kwargs)\n#         return self.legend_\n\n        def get_labels(labels, decimal_places=1):\n            _decimal_places = str(decimal_places)\n\n            fmt = (\n                \"[%.\" + _decimal_places + \"f \" +\n                \": %0.\" + _decimal_places + \"f\"\n            )\n\n            if labels is None:\n                labels = np.copy(self._info['bins'])\n                if locale.getlocale()[0] in ['fr_FR']:\n                    fmt += '['\n                else:\n                    fmt += ')'\n                labels = [fmt % (labels[i], labels[i + 1])\n                    for i in range(len(labels) - 1)]\n            else:\n                if len(labels) != len(self._info['bins']) -1 :\n                    print(\"ERROR\")\n                labels = labels\n            \n            return labels\n\n\n        kwargs.pop('handles', None)\n\n        decimal_places = kwargs.pop('decimal_places', 1)\n        labels = kwargs.pop('labels', None)\n\n        handles = get_handles()\n        labels = get_labels(labels, decimal_places)\n        self.legend_ = mpl.legend.Legend(self, handles, labels, loc, **kwargs)\n        return self.legend_\n    \n\n    def set_legend(self, **pyplot_arguments):\n        if \"borderaxespad\" not in pyplot_arguments:\n            pyplot_arguments[\"borderaxespad\"] = -0.10\n        legend = self.legend(**pyplot_arguments)\n        plt.setp(legend.get_texts(), fontsize=8)\n        return legend\n\n    def _init_plot(self, direction, var, **kwargs):\n        \"\"\"\n        Internal method used by all plotting commands\n\n        Parameters\n        ----------\n        direction : 1D array,\n            directions the wind blows from, North centred\n        var : 1D array,\n            values of the variable to compute. Typically the wind speeds\n\n        Other Parameters\n        ----------------\n        normed : boolean, default False\n        blowto : boolean, default False\n        colors : str or list of str, default None\n            The colors of the plot.\n        cmap : color map, default `jet`\n            A :obj:`matplotlib.cm` colormap for the plot.\n            Warning! It overrides `colors`.\n        weibull_factors :\n        mean_values :\n        frequency :\n        kwarg\n            Any argument accepted by :obj:`matplotlib.pyplot.plot`.\n        \"\"\"\n\n        # if weibull factors are entered overwrite direction and var\n        if \"weibull_factors\" in kwargs or \"mean_values\" in kwargs:\n            if \"weibull_factors\" in kwargs and \"mean_values\" in kwargs:\n                raise TypeError(\"cannot specify both weibull_factors and mean_values\")\n            statistic_type = \"unset\"\n            if \"weibull_factors\" in kwargs:\n                statistic_type = \"weibull\"\n                val = kwargs.pop(\"weibull_factors\")\n            elif \"mean_values\" in kwargs:\n                statistic_type = \"mean\"\n                val = kwargs.pop(\"mean_values\")\n            if val:\n                if \"frequency\" not in kwargs:\n                    raise TypeError(\n                        \"specify 'frequency' argument for statistical input\"\n                    )\n                windFrequencies = kwargs.pop(\"frequency\")\n                if len(windFrequencies) != len(direction) or len(direction) != len(var):\n                    if len(windFrequencies) != len(direction):\n                        raise TypeError(\"len(frequency) != len(direction)\")\n                    elif len(direction) != len(var):\n                        raise TypeError(\"len(frequency) != len(direction)\")\n                windSpeeds = []\n                windDirections = []\n                for dbin in range(len(direction)):\n                    for _ in range(int(windFrequencies[dbin] * 10000)):\n                        if statistic_type == \"weibull\":\n                            windSpeeds.append(\n                                random.weibullvariate(var[dbin][0], var[dbin][1])\n                            )\n                        elif statistic_type == \"mean\":\n                            windSpeeds.append(\n                                random.weibullvariate(var[dbin] * 2 \/ np.sqrt(np.pi), 2)\n                            )\n                        windDirections.append(direction[dbin])\n                var, direction = windSpeeds, windDirections\n\n        # self.cla()\n        kwargs.pop(\"zorder\", None)\n\n        # Init of the bins array if not set\n        bins = kwargs.pop(\"bins\", None)\n        if bins is None:\n            bins = np.linspace(np.min(var), np.max(var), 6)\n        if isinstance(bins, int):\n            bins = np.linspace(np.min(var), np.max(var), bins)\n        bins = np.asarray(bins)\n        nbins = len(bins)\n\n        # Number of sectors\n        nsector = kwargs.pop(\"nsector\", None)\n        if nsector is None:\n            nsector = 16\n\n        # Sets the colors table based on the colormap or the \"colors\" argument\n        colors = kwargs.pop(\"colors\", None)\n        cmap = kwargs.pop(\"cmap\", None)\n        if colors is not None:\n            if isinstance(colors, str):\n                colors = [colors] * nbins\n            if isinstance(colors, (tuple, list)):\n                if len(colors) != nbins:\n                    raise ValueError(\"colors and bins must have same length\")\n        else:\n            if cmap is None:\n                cmap = mpl.cm.jet\n            colors = self._colors(cmap, nbins)\n\n        # Building the angles list\n        angles = np.arange(0, -2 * np.pi, -2 * np.pi \/ nsector) + np.pi \/ 2\n\n        normed = kwargs.pop(\"normed\", False)\n        blowto = kwargs.pop(\"blowto\", False)\n\n        # Calm condition\n        calm_limit = kwargs.pop(\"calm_limit\", None)\n        if calm_limit is not None:\n            mask = var > calm_limit\n            self.calm_count = len(var) - np.count_nonzero(mask)\n            if normed:\n                self.calm_count = self.calm_count * 100 \/ len(var)\n            var = var[mask]\n            direction = direction[mask]\n\n        # Set the global information dictionnary\n        self._info[\"dir\"], self._info[\"bins\"], self._info[\"table\"] = histogram(\n            direction, var, bins, nsector, normed, blowto\n        )\n\n        return bins, nbins, nsector, colors, angles, kwargs\n\n    def _calm_circle(self):\n        \"\"\"\n        Draw the calm centered circle\n        and return the initial offset for plots methods\n        \"\"\"\n        if self.calm_count and self.calm_count > 0:\n            circle = mpl.patches.Circle(\n                (0., 0.),\n                self.calm_count,\n                transform=self.transData._b,\n                color=CALM_CIRCLE_COLOR,\n                alpha=CALM_CIRCLE_ALPHA,\n            )\n            self.add_artist(circle)\n        return self.calm_count or 0\n\n    def contour(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in linear mode. For each var bins, a line will be\n        draw on the axes, a segment between each sector (center to center).\n        Each line can be formated (color, width, ...) like with standard plot\n        pylab command.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds.\n\n        Other Parameters\n        ----------------\n        sector : integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6,\n            then bins=linspace(min(var), max(var), 6)\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n        others kwargs\n            Any supported argument of :obj:`matplotlib.pyplot.plot`\n\n        \"\"\"\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n\n        # closing lines\n        angles = np.hstack((angles, angles[-1] - 2 * np.pi \/ nsector))\n        vals = np.hstack(\n            (\n                self._info[\"table\"],\n                np.reshape(\n                    self._info[\"table\"][:, 0], (self._info[\"table\"].shape[0], 1)\n                ),\n            )\n        )\n\n        offset = self._calm_circle()\n        for i in range(nbins):\n            val = vals[i, :] + offset\n            offset += vals[i, :]\n            zorder = ZBASE + nbins - i\n            patch = self.plot(angles, val, color=colors[i], zorder=zorder, **kwargs)\n            self.patches_list.extend(patch)\n        self._update()\n\n    def contourf(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in filled mode. For each var bins, a line will be\n        draw on the axes, a segment between each sector (center to center).\n        Each line can be formated (color, width, ...) like with standard plot\n        pylab command.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds\n\n        Other Parameters\n        ----------------\n        nsector: integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6,\n            then bins=linspace(min(`var`), max(`var`), 6)\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n\n        others kwargs\n            Any supported argument of :obj:`matplotlib.pyplot.plot`\n        \"\"\"\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(\"facecolor\", None)\n        kwargs.pop(\"edgecolor\", None)\n\n        # closing lines\n        angles = np.hstack((angles, angles[-1] - 2 * np.pi \/ nsector))\n        vals = np.hstack(\n            (\n                self._info[\"table\"],\n                np.reshape(\n                    self._info[\"table\"][:, 0], (self._info[\"table\"].shape[0], 1)\n                ),\n            )\n        )\n        offset = self._calm_circle()\n        for i in range(nbins):\n            val = vals[i, :] + offset\n            offset += vals[i, :]\n            zorder = ZBASE + nbins - i\n            patch = self.fill(np.append(angles, 0), np.append(val, 0),\n                              facecolor=colors[i], edgecolor=colors[i],\n                              zorder=zorder, **kwargs)\n            self.patches_list.extend(patch)\n        self._update()\n\n    def bar(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in bar mode. For each var bins and for each sector,\n        a colored bar will be draw on the axes.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds.\n\n        Other Parameters\n        ----------------\n        nsector : integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6\n            between min(`var`) and max(`var`).\n        blowto : bool, optional.\n            if True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted\n            in different colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional.\n            if cmap == None and colors == None, a default Colormap is used.\n        edgecolor : string, optional\n            The string color each edge box will be plotted.\n            Default : no edgecolor\n        opening : float, optional\n            between 0.0 and 1.0, to control the space between each sector (1.0\n            for no space)\n\n        \"\"\"\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(\"facecolor\", None)\n        edgecolor = kwargs.pop(\"edgecolor\", None)\n        if edgecolor is not None:\n            if not isinstance(edgecolor, str):\n                raise ValueError(\"edgecolor must be a string color\")\n        opening = kwargs.pop(\"opening\", None)\n        if opening is None:\n            opening = 0.8\n        dtheta = 2 * np.pi \/ nsector\n        opening = dtheta * opening\n\n        offs = self._calm_circle()\n\n        for j in range(nsector):\n            offset = offs\n            for i in range(nbins):\n                if i > 0:\n                    offset += self._info[\"table\"][i - 1, j]\n                val = self._info[\"table\"][i, j]\n                zorder = ZBASE + nbins - i\n                patch = mpl.patches.Rectangle(\n                    (angles[j] - opening \/ 2, offset),\n                    opening,\n                    val,\n                    facecolor=colors[i],\n                    edgecolor=edgecolor,\n                    zorder=zorder,\n                    **kwargs\n                )\n                self.add_patch(patch)\n                if j == 0:\n                    self.patches_list.append(patch)\n        self._update()\n\n    def box(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in proportional box mode. For each var bins and for\n        each sector, a colored box will be draw on the axes.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds\n\n        Other Parameters\n        ----------------\n        nsector: integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6\n            between min(`var`) and max(`var`).\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n        edgecolor : string, optional\n            The string color each edge bar will be plotted.  Default : no\n            edgecolor\n\n        \"\"\"\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(\"facecolor\", None)\n        edgecolor = kwargs.pop(\"edgecolor\", None)\n        if edgecolor is not None:\n            if not isinstance(edgecolor, str):\n                raise ValueError(\"edgecolor must be a string color\")\n        opening = np.linspace(0.0, np.pi \/ 16, nbins)\n\n        offs = self._calm_circle()\n\n        for j in range(nsector):\n            offset = offs\n            for i in range(nbins):\n                if i > 0:\n                    offset += self._info[\"table\"][i - 1, j]\n                val = self._info[\"table\"][i, j]\n                zorder = ZBASE + nbins - i\n                patch = mpl.patches.Rectangle(\n                    (angles[j] - opening[i] \/ 2, offset),\n                    opening[i],\n                    val,\n                    facecolor=colors[i],\n                    edgecolor=edgecolor,\n                    zorder=zorder,\n                    **kwargs\n                )\n                self.add_patch(patch)\n                if j == 0:\n                    self.patches_list.append(patch)\n        self._update()\n\n\nclass WindAxes(mpl.axes.Subplot):\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        See Axes base class for args and kwargs documentation\n        \"\"\"\n        super(WindAxes, self).__init__(*args, **kwargs)\n\n    @staticmethod\n    def from_ax(ax=None, fig=None, *args, **kwargs):\n        if ax is None:\n            if fig is None:\n                fig = plt.figure(figsize=FIGSIZE_DEFAULT, dpi=DPI_DEFAULT)\n            ax = WindAxes(fig, 1, 1, 1, *args, **kwargs)\n            fig.add_axes(ax)\n            return ax\n        else:\n            return ax\n\n    def pdf(\n        self,\n        var,\n        bins=None,\n        Nx=100,\n        bar_color=\"b\",\n        plot_color=\"g\",\n        Nbins=10,\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        Draw probability density function and return Weibull distribution\n        parameters\n        \"\"\"\n        import scipy.stats\n\n        if bins is None:\n            bins = np.linspace(0, np.max(var), Nbins)\n        hist, bins = np.histogram(var, bins=bins, normed=True)\n        width = 0.7 * (bins[1] - bins[0])\n        center = (bins[:-1] + bins[1:]) \/ 2\n        self.bar(center, hist, align=\"center\", width=width, color=bar_color)\n        params = scipy.stats.exponweib.fit(var, floc=0, f0=1)\n        x = np.linspace(0, bins[-1], Nx)\n        self.plot(x, scipy.stats.exponweib.pdf(x, *params), color=plot_color)\n        return (self, params)\n\n\ndef histogram(direction, var, bins, nsector, normed=False, blowto=False):\n    \"\"\"\n    Returns an array where, for each sector of wind\n    (centred on the north), we have the number of time the wind comes with a\n    particular var (speed, polluant concentration, ...).\n\n    Parameters\n    ----------\n    direction : 1D array\n        directions the wind blows from, North centred\n    var : 1D array\n        values of the variable to compute. Typically the wind speeds\n    bins : list\n        list of var category against we're going to compute the table\n    nsector : integer\n        number of sectors\n\n    Other Parameters\n    ----------------\n    normed : boolean, default False\n        The resulting table is normed in percent or not.\n    blowto : boolean, default False\n        Normaly a windrose is computed with directions as wind blows from. If\n        true, the table will be reversed (usefull for pollutantrose)\n    \"\"\"\n\n    if len(var) != len(direction):\n        raise ValueError(\"var and direction must have same length\")\n\n    angle = 360. \/ nsector\n\n    dir_bins = np.arange(-angle \/ 2, 360. + angle, angle, dtype=np.float)\n    dir_edges = dir_bins.tolist()\n    dir_edges.pop(-1)\n    dir_edges[0] = dir_edges.pop(-1)\n    dir_bins[0] = 0.\n\n    var_bins = bins.tolist()\n    var_bins.append(np.inf)\n\n    if blowto:\n        direction = direction + 180.\n        direction[direction >= 360.] = direction[direction >= 360.] - 360\n\n    table = histogram2d(x=var, y=direction, bins=[var_bins, dir_bins], normed=False)[0]\n    # add the last value to the first to have the table of North winds\n    table[:, 0] = table[:, 0] + table[:, -1]\n    # and remove the last col\n    table = table[:, :-1]\n    if normed:\n        table = table * 100 \/ table.sum()\n\n    return dir_edges, var_bins, table\n\n\n@docstring.copy(WindroseAxes.contour)\ndef wrcontour(direction, var, ax=None, rmax=None, **kwargs):\n    \"\"\"\n    Draw contour probability density function and return Weibull\n    distribution parameters.\n    \"\"\"\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.contour(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.contourf)\ndef wrcontourf(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.contourf(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.box)\ndef wrbox(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.box(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.bar)\ndef wrbar(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.bar(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindAxes.pdf)\ndef wrpdf(\n    var,\n    bins=None,\n    Nx=100,\n    bar_color=\"b\",\n    plot_color=\"g\",\n    Nbins=10,\n    ax=None,\n    rmax=None,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Draw probability density function and return Weitbull distribution\n    parameters\n    \"\"\"\n    ax = WindAxes.from_ax(ax)\n    ax, params = ax.pdf(var, bins, Nx, bar_color, plot_color, Nbins, *args, **kwargs)\n    return (ax, params)\n\n\ndef wrscatter(direction, var, ax=None, rmax=None, *args, **kwargs):\n    \"\"\"\n    Draw scatter plot\n    \"\"\"\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    direction = -np.array(direction) + np.radians(90)\n    ax.scatter(direction, var, *args, **kwargs)\n    return ax\n\n\n# def clean(direction, var):\n#     '''\n#     Remove masked values in the two arrays, where if a direction data is masked,\n#     the var data will also be removed in the cleaning process (and vice-versa)\n#     '''\n#     dirmask = direction.mask==False\n#     varmask = direction.mask==False\n#     mask = dirmask*varmask\n#     return direction[mask], var[mask]\n\n\ndef clean_df(df, var=VAR_DEFAULT, direction=DIR_DEFAULT):\n    \"\"\"\n    Remove nan and var=0 values in the DataFrame\n    if a var (wind speed) is nan or equal to 0, this row is\n    removed from DataFrame\n    if a direction is nan, this row is also removed from DataFrame\n    \"\"\"\n    return df[df[var].notnull() & df[var] != 0 & df[direction].notnull()]\n\n\ndef clean(direction, var, index=False):\n    \"\"\"\n    Remove nan and var=0 values in the two arrays\n    if a var (wind speed) is nan or equal to 0, this data is\n    removed from var array but also from dir array\n    if a direction is nan, data is also removed from both array\n    \"\"\"\n    dirmask = np.isfinite(direction)\n    varmask = var != 0 & np.isfinite(var)\n    mask = dirmask * varmask\n    if index is None:\n        index = np.arange(mask.sum())\n        return direction[mask], var[mask], index\n    elif not index:\n        return direction[mask], var[mask]\n    else:\n        index = index[mask]\n        return direction[mask], var[mask], index\n\n\nD_KIND_PLOT = {\n    \"contour\": wrcontour,\n    \"contourf\": wrcontourf,\n    \"box\": wrbox,\n    \"bar\": wrbar,\n    \"pdf\": wrpdf,\n    \"scatter\": wrscatter,\n}\n\n\ndef plot_windrose(\n    direction_or_df,\n    var=None,\n    kind=\"contour\",\n    var_name=VAR_DEFAULT,\n    direction_name=DIR_DEFAULT,\n    by=None,\n    rmax=None,\n    **kwargs\n):\n    if var is None:\n        # Assuming direction_or_df is a DataFrame\n        df = direction_or_df\n        var = df[var_name].values\n        direction = df[direction_name].values\n    else:\n        direction = direction_or_df\n    return plot_windrose_np(direction, var, kind=kind, by=by, rmax=rmax, **kwargs)\n\n\ndef plot_windrose_df(\n    df,\n    kind=\"contour\",\n    var_name=VAR_DEFAULT,\n    direction_name=DIR_DEFAULT,\n    by=None,\n    rmax=None,\n    **kwargs\n):\n    var = df[var_name].values\n    direction = df[direction_name].values\n    return plot_windrose_np(direction, var, by=by, rmax=rmax, **kwargs)\n\n\ndef plot_windrose_np(\n    direction, var, kind=\"contour\", clean_flag=True, by=None, rmax=None, **kwargs\n):\n    if kind in D_KIND_PLOT.keys():\n        f_plot = D_KIND_PLOT[kind]\n    else:\n        raise Exception(\"kind=%r but it must be in %r\" % (kind, D_KIND_PLOT.keys()))\n    # if f_clean is not None:\n    #     df = f_clean(df)\n    # var = df[var_name].values\n    # direction = df[direction_name].values\n    if clean_flag:\n        var, direction = clean(var, direction)\n    if by is None:\n        ax = f_plot(direction=direction, var=var, rmax=rmax, **kwargs)\n        if kind not in [\"pdf\"]:\n            ax.set_legend()\n        return ax\n    else:\n        raise NotImplementedError(\n            \"'by' keyword not supported for now \"\n            \"https:\/\/github.com\/scls19fr\/windrose\/issues\/10\"\n        )","a4357551":"def showWindrose(df, start_date, end_date, bins = False, labels = False):\n    mask = (df.index >= start_date) & (df.index <= end_date)\n\n    ws = df['FHVEC'].loc[mask]\n    wd = df['DDVEC'].loc[mask]\n\n    ax = WindroseAxes.from_ax()\n        \n    if bins:\n        #ax.bar(wd, ws, normed = True, opening = 0.8, edgecolor = 'white', bins = bins, colors = ['white', 'lavender', 'blue', 'navy'])\n        ax.box(wd, ws, normed = True, edgecolor = 'white', bins = bins, colors = ['white', 'lightskyblue', 'blue', 'navy'])\n    else:\n        ax.bar(wd, ws, normed = True, opening = 0.8, edgecolor = 'white')\n        #ax.box(wd, ws, normed = True, edgecolor = 'white')\n\n    if labels:\n        ax.set_legend(labels = labels)\n    else:\n        ax.set_legend(units = 'm\/s')\n        \n    circle = plt.Circle((0, 0), 9.8, transform=ax.transData._b, color=\"white\")\n    ax.add_artist(circle)    \n        \n    ax.set_yticks(np.arange(-10, 40, step = 10))\n    ax.set_yticklabels(np.arange(-10, 40, step = 10))\n    plt.title(r\"$\\bf{\" + 'Wind rose' + \"}$\\n\" + start_date + ' to ' + end_date);\n\n    \n# beaufort_bins = [0, 0.5, 1.5, 3.3, 5.5, 7.9, 10.7, 13.8, 17.1, 20.7, 24.4, 28.4, 32.6]\n# beaufort_labels = ['Calm', '1 Bft', '2 Bft', '3 Bft', '4 Bft', '5 Bft', '6 Bft', '7 Bft', '8 Bft', '9 Bft', '10 Bft', '11 Bft', '12 Bft']\n\nbeaufort_bins = [0, 0.5, 3.3, 7.9]\nbeaufort_labels = ['Calm', '1-2 Bft', '3-4 Bft', '>=5 Bft']\n\n#showWindrose(df_weather, '2019-01-01', '2020-01-01')\n    \n# Other plot types\n\n# ax = WindroseAxes.from_ax()\n# ax.box(wd, ws, normed = True, bins = np.arange(0, 8, 1))\n# ax.set_legend();\n\n# ax = WindroseAxes.from_ax()\n# ax.contourf(wd, ws, normed = True, bins = np.arange(0, 8, 1), cmap=cm.hot)\n# ax.set_legend();","12a8131c":"showWindrose(df_weather, '2020-02-01', '2020-02-27', bins = beaufort_bins, labels = beaufort_labels)\nshowWindrose(df_weather, '2020-01-01', '2020-07-01', bins = beaufort_bins, labels = beaufort_labels)","1a4831a3":"def showAvgTrend(df, var, var_name, start_year, end_year,):\n    #max_var_yearly = [max(df[str(y)][var]) for y in years]\n    data = df[(df.index.year >= start_year) & (df.index.year <= end_year)]\n    avg_var_yearly = data[var].groupby(data.index.year).mean()\n    \n    plt.figure(figsize = (10, 5))\n    ax1 = sns.lineplot(data = avg_var_yearly, color='blue')\n\n    # OLS linear trend\n    ax2 = sns.regplot(x = avg_var_yearly.index, y = avg_var_yearly, marker='', order=1, color='orange')\n    slope, intercept, r_value, p_value, std_err = stats.linregress(avg_var_yearly.index,avg_var_yearly)\n    delta = slope * (end_year - start_year)\n    \n    if delta > 0:\n        delta_text = '+' + str(round(delta, 2))\n    elif delta < 0:\n        delta_text = '-' + str(round(delta, 2))\n    \n    ax2.text(start_year + 0.02 * (end_year - start_year), max(avg_var_yearly) * 0.98, 'Trend shows change of ' + delta_text)\n    ax2.set(xlabel = 'Years', ylabel = 'Degrees Celsius', title = var_name + ' from ' + str(start_year) + ' to ' + str(end_year));\n\n","b9a6b092":"showAvgTrend(df_weather, 'TG', 'Average Yearly Temperature', 1901, 2020)","cdb04371":"df_weather.loc[df_weather.SP > 0.1, 'DaylightTest'] = df_weather['SQ'] \/ df_weather['SP'] * 100\ndf_weather.loc[df_weather.SP < 0.1, 'DaylightTest'] = np.nan\ndf_weather[df_weather.index.year == 2019].DaylightTest.plot(c='blue');\nplt.title(r'$\\bf{Daylight\\;hours\\;for\\;2019}$' + '\\nObtained by dividing measured sunshine hours by\\nits fraction of available daylight hours');","6b88b6c0":"# Calculate daylight hours by the daylight hours approximation equations.\n\ndef getDaylight(timestamp):\n    day_of_year = (timestamp - dt.datetime(timestamp.year, 1, 1)).days + 1\n    long = 5.180\n    lat = 52.100\n    offset = -1\n\n    y = (2 * m.pi \/ 365) * (day_of_year - 1)\n    declin = 0.006918 - 0.399912 * m.cos(y) + 0.070257 * m.sin(y) - 0.006758 * m.cos(2 * y) + 0.000907 * m.sin(2 * y) - 0.002697 * m.cos(3 * y) + 0.00148 * m.sin(3 * y)\n    eqtime = 229.18 * (0.000075 + 0.001868 * m.cos(y) - 0.032077 * m.sin(y) - 0.014615 * m.cos(2 * y) - 0.040849 * m.sin(2 * y))\n    ha = m.acos(m.cos(90.833 \/ 180 * m.pi) \/ (m.cos(lat \/ 180 * m.pi) * m.cos(declin)) - m.tan(lat \/ 180 * m.pi) * m.tan(declin))\n    daylight = 2 * ha \/ (15 * 24)\n\n    sunrise = 720 - 4*(long + ha \/ m.pi * 180) - eqtime\n    sunset = 720 - 4*(long - ha \/ m.pi * 180) - eqtime\n\n    return round((sunset - sunrise) \/ 60, 2)","f3c7cbd6":"df_weather['Daylight'] = df_weather.apply(lambda x: getDaylight(x.name), axis=1)","4e43f5cb":"def showSunshine (df, date, size, rotate = False):\n    \n    plt.figure(figsize = size)\n    df['DaylightLeft'] = df.Daylight - df.SQ\n    ax = plt.bar(df[date].index, df[date].SQ, color = 'yellow');\n    ax = plt.bar(df[date].index, df[date].DaylightLeft, bottom = df[date].SQ, color = 'deepskyblue');\n    \n    if rotate:\n        plt.xticks(rotation = 45)\n\n    text = 'Sum = {:.0f} hrs ({:.0f}%)'.format(round(df[date].SQ.sum(), 0), round(df[date].SQ.sum()\/df[date].Daylight.sum() * 100, 0)) \n    plt.title(r'$\\bf{' + 'Hours\\;of\\;sunshine' + '}$\\nfor ' + date + '\\n' + text);","d8ebff56":"showSunshine(df_weather, '2020', (20 ,5))\nshowSunshine(df_weather, '2020-1', (8 ,3), True)","c12e12b0":"\"\"\"\nCalendar heatmaps from Pandas time series data.\n\nPlot Pandas time series data sampled by day in a heatmap per calendar year,\nsimilar to GitHub's contributions calendar.\n\"\"\"\n\n\nfrom __future__ import unicode_literals\n\nimport calendar\nimport datetime\n\nfrom matplotlib.colors import ColorConverter, ListedColormap\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom distutils.version import StrictVersion\n\n__version_info__ = ('0', '0', '7', 'dev')\n__date__ = '14 Feb 2016'\n\n\n__version__ = '.'.join(__version_info__)\n__author__ = 'Martijn Vermaat'\n__contact__ = 'martijn@vermaat.name'\n__homepage__ = 'https:\/\/github.com\/martijnvermaat\/calmap'\n\n_pandas_18 = StrictVersion(pd.__version__) >= StrictVersion('0.18')\n\n\ndef yearplot(data, year=None, how='sum', vmin=None, vmax=None, cmap='Reds',\n             fillcolor='whitesmoke', linewidth=1, linecolor=None,\n             daylabels=calendar.day_abbr[:], dayticks=True,\n             monthlabels=calendar.month_abbr[1:], monthticks=True, ax=None, colorbar = True,\n             **kwargs):\n    \"\"\"\n    Plot one year from a timeseries as a calendar heatmap.\n\n    Parameters\n    ----------\n    data : Series\n        Data for the plot. Must be indexed by a DatetimeIndex.\n    year : integer\n        Only data indexed by this year will be plotted. If `None`, the first\n        year for which there is data will be plotted.\n    how : string\n        Method for resampling data by day. If `None`, assume data is already\n        sampled by day and don't resample. Otherwise, this is passed to Pandas\n        `Series.resample`.\n    vmin, vmax : floats\n        Values to anchor the colormap. If `None`, min and max are used after\n        resampling data by day.\n    cmap : matplotlib colormap name or object\n        The mapping from data values to color space.\n    fillcolor : matplotlib color\n        Color to use for days without data.\n    linewidth : float\n        Width of the lines that will divide each day.\n    linecolor : color\n        Color of the lines that will divide each day. If `None`, the axes\n        background color is used, or 'white' if it is transparent.\n    daylabels : list\n        Strings to use as labels for days, must be of length 7.\n    dayticks : list or int or bool\n        If `True`, label all days. If `False`, don't label days. If a list,\n        only label days with these indices. If an integer, label every n day.\n    monthlabels : list\n        Strings to use as labels for months, must be of length 12.\n    monthticks : list or int or bool\n        If `True`, label all months. If `False`, don't label months. If a\n        list, only label months with these indices. If an integer, label every\n        n month.\n    ax : matplotlib Axes\n        Axes in which to draw the plot, otherwise use the currently-active\n        Axes.\n    kwargs : other keyword arguments\n        All other keyword arguments are passed to matplotlib `ax.pcolormesh`.\n\n    Returns\n    -------\n    ax : matplotlib Axes\n        Axes object with the calendar heatmap.\n\n    Examples\n    --------\n\n    By default, `yearplot` plots the first year and sums the values per day:\n\n    .. plot::\n        :context: close-figs\n\n        calmap.yearplot(events)\n\n    We can choose which year is plotted with the `year` keyword argment:\n\n    .. plot::\n        :context: close-figs\n\n        calmap.yearplot(events, year=2015)\n\n    The appearance can be changed by using another colormap. Here we also use\n    a darker fill color for days without data and remove the lines:\n\n    .. plot::\n        :context: close-figs\n\n        calmap.yearplot(events, cmap='YlGn', fillcolor='grey',\n                        linewidth=0)\n\n    The axis tick labels can look a bit crowded. We can ask to draw only every\n    nth label, or explicitely supply the label indices. The labels themselves\n    can also be customized:\n\n    .. plot::\n        :context: close-figs\n\n        calmap.yearplot(events, monthticks=3, daylabels='MTWTFSS',\n                        dayticks=[0, 2, 4, 6])\n\n    \"\"\"\n    if year is None:\n        year = data.index.sort_values()[0].year\n\n    if how is None:\n        # Assume already sampled by day.\n        by_day = data\n    else:\n        # Sample by day.\n        if _pandas_18:\n            by_day = data.resample('D').agg(how)\n        else:\n            by_day = data.resample('D', how=how)\n\n    # Min and max per day.\n    if vmin is None:\n        vmin = by_day.min()\n    if vmax is None:\n        vmax = by_day.max()\n\n    if ax is None:\n        ax = plt.gca()\n\n    if linecolor is None:\n        # Unfortunately, linecolor cannot be transparent, as it is drawn on\n        # top of the heatmap cells. Therefore it is only possible to mimic\n        # transparent lines by setting them to the axes background color. This\n        # of course won't work when the axes itself has a transparent\n        # background so in that case we default to white which will usually be\n        # the figure or canvas background color.\n        linecolor = ax.get_fc()\n        #linecolor = ax.get_axis_bgcolor()\n        if ColorConverter().to_rgba(linecolor)[-1] == 0:\n            linecolor = 'white'\n\n    # Filter on year.\n    by_day = by_day[str(year)]\n\n    # Add missing days.\n    by_day = by_day.reindex(\n        pd.date_range(start=str(year), end=str(year + 1), freq='D')[:-1])\n\n    # Create data frame we can pivot later.\n    by_day = pd.DataFrame({'data': by_day,\n                           'fill': 1,\n                           'day': by_day.index.dayofweek,\n                           'week': by_day.index.week})\n\n    # There may be some days assigned to previous year's last week or\n    # next year's first week. We create new week numbers for them so\n    # the ordering stays intact and week\/day pairs unique.\n    by_day.loc[(by_day.index.month == 1) & (by_day.week > 50), 'week'] = 0\n    by_day.loc[(by_day.index.month == 12) & (by_day.week < 10), 'week'] \\\n        = by_day.week.max() + 1\n\n    # Pivot data on day and week and mask NaN days.\n    plot_data = by_day.pivot('day', 'week', 'data').values[::-1]\n    plot_data = np.ma.masked_where(np.isnan(plot_data), plot_data)\n\n    # Do the same for all days of the year, not just those we have data for.\n    fill_data = by_day.pivot('day', 'week', 'fill').values[::-1]\n    fill_data = np.ma.masked_where(np.isnan(fill_data), fill_data)\n\n    # Draw heatmap for all days of the year with fill color.\n    ax.pcolormesh(fill_data, vmin=0, vmax=1, cmap=ListedColormap([fillcolor]))\n\n    # Draw heatmap.\n    kwargs['linewidth'] = linewidth\n    kwargs['edgecolors'] = linecolor\n    im = ax.pcolormesh(plot_data, vmin=vmin, vmax=vmax, cmap=cmap, **kwargs)\n\n    # Limit heatmap to our data.\n    ax.set(xlim=(0, plot_data.shape[1]), ylim=(0, plot_data.shape[0]))\n\n    # Square cells.\n    ax.set_aspect('equal')\n\n    # Remove spines and ticks.\n    for side in ('top', 'right', 'left', 'bottom'):\n        ax.spines[side].set_visible(False)\n    ax.xaxis.set_tick_params(which='both', length=0)\n    ax.yaxis.set_tick_params(which='both', length=0)\n\n    # Get indices for monthlabels.\n    if monthticks is True:\n        monthticks = range(len(monthlabels))\n    elif monthticks is False:\n        monthticks = []\n    elif isinstance(monthticks, int):\n        monthticks = range(len(monthlabels))[monthticks \/\/ 2::monthticks]\n\n    # Get indices for daylabels.\n    if dayticks is True:\n        dayticks = range(len(daylabels))\n    elif dayticks is False:\n        dayticks = []\n    elif isinstance(dayticks, int):\n        dayticks = range(len(daylabels))[dayticks \/\/ 2::dayticks]\n\n    \n    ax.set_xlabel('')\n    \n#     ax.set_xticks([by_day.index[datetime.date(year, i + 1, 15)].week\n#                    for i in monthticks])\n#---------------------------\n# Updated to isocalendar()[1], the .week code above doesn't work\n\n    ax.set_xticks([datetime.date(year, i + 1, 15).isocalendar()[1]  \n                   for i in monthticks])\n    ax.set_xticklabels([monthlabels[i] for i in monthticks], ha='center')\n\n    ax.set_ylabel('')\n    ax.yaxis.set_ticks_position('right')\n    ax.set_yticks([6 - i + 0.5 for i in dayticks])\n    ax.set_yticklabels([daylabels[i] for i in dayticks], rotation='horizontal',\n                       va='center')\n    \n    if colorbar is True:\n        plt.colorbar(im, ax=ax)\n    \n    return ax\n\n\ndef calendarplot(data, how='sum', yearlabels=True, yearascending=True, yearlabel_kws=None,\n                 subplot_kws=None, gridspec_kws=None, fig_kws=None, **kwargs):\n    \"\"\"\n    Plot a timeseries as a calendar heatmap.\n\n    Parameters\n    ----------\n    data : Series\n        Data for the plot. Must be indexed by a DatetimeIndex.\n    how : string\n        Method for resampling data by day. If `None`, assume data is already\n        sampled by day and don't resample. Otherwise, this is passed to Pandas\n        `Series.resample`.\n    yearlabels : bool\n       Whether or not to draw the year for each subplot.\n    yearascending : bool\n       Sort the calendar in ascending or descending order.\n    yearlabel_kws : dict\n       Keyword arguments passed to the matplotlib `set_ylabel` call which is\n       used to draw the year for each subplot.\n    subplot_kws : dict\n        Keyword arguments passed to the matplotlib `add_subplot` call used to\n        create each subplot.\n    gridspec_kws : dict\n        Keyword arguments passed to the matplotlib `GridSpec` constructor used\n        to create the grid the subplots are placed on.\n    fig_kws : dict\n        Keyword arguments passed to the matplotlib `figure` call.\n    kwargs : other keyword arguments\n        All other keyword arguments are passed to `yearplot`.\n\n    Returns\n    -------\n    fig, axes : matplotlib Figure and Axes\n        Tuple where `fig` is the matplotlib Figure object `axes` is an array\n        of matplotlib Axes objects with the calendar heatmaps, one per year.\n\n    Examples\n    --------\n\n    With `calendarplot` we can plot several years in one figure:\n\n    .. plot::\n        :context: close-figs\n\n        calmap.calendarplot(events)\n\n    \"\"\"\n    yearlabel_kws = yearlabel_kws or {}\n    subplot_kws = subplot_kws or {}\n    gridspec_kws = gridspec_kws or {}\n    fig_kws = fig_kws or {}\n\n    years = np.unique(data.index.year)\n    if not yearascending:\n        years = years[::-1]\n\n    fig, axes = plt.subplots(nrows=len(years), ncols=1, squeeze=False,\n                             subplot_kw=subplot_kws,\n                             gridspec_kw=gridspec_kws, **fig_kws)\n    axes = axes.T[0]\n\n    # We explicitely resample by day only once. This is an optimization.\n    if how is None:\n        by_day = data\n    else:\n        if _pandas_18:\n            by_day = data.resample('D').agg(how)\n        else:\n            by_day = data.resample('D', how=how)\n\n    ylabel_kws = dict(\n        fontsize=32,\n        color=kwargs.get('fillcolor', 'whitesmoke'),\n        fontweight='bold',\n        fontname='Arial',\n        ha='center')\n    ylabel_kws.update(yearlabel_kws)\n\n    max_weeks = 0\n\n    for year, ax in zip(years, axes):\n        yearplot(by_day, year=year, how=None, ax=ax, **kwargs)\n        max_weeks = max(max_weeks, ax.get_xlim()[1])\n\n        if yearlabels:\n            ax.set_ylabel(str(year), **ylabel_kws)\n\n    # In a leap year it might happen that we have 54 weeks (e.g., 2012).\n    # Here we make sure the width is consistent over all years.\n    for ax in axes:\n        ax.set_xlim(0, max_weeks)\n\n    # Make the axes look good.\n    plt.tight_layout()\n\n    return fig, axes","8d2a8583":"# plt.figure(figsize=(20,2))\n# yearplot(df_weather.RH, year = 2019, colorbar = True);\n\ncalendarplot(df_weather[df_weather.index.year >= 2017].RH, fig_kws = dict(figsize = (20, 8)));","e309454a":"### Time series for minumum, average and maximum temperature\n\nThe plotting function is hidden, but it plots the average temperature superimposed on a shaded area indicating the spread between the measured minimum and maximum temperature each observation.\n\n[(go to top)](#A-Century-worth-of-Weather-Observations!)","64487a9a":"# A Century worth of Weather Observations!\n**Welcome Kaggle friends!**\n\nThis is my first notebook on Kaggle and I'm excited to share this with you.\nIt is based on a weather observation dataset from the Netherlands Royal Weather Institue (KNMI) with over a century worth of measurements, all the way back to 1901!\n\nThis specific dataset covers observations made in De Bilt, the KNMI base office, smack in the country's center.\n\n**Contents**\n\n1. [A Century worth of Weather Observations!](#A-Century-worth-of-Weather-Observations!)\n    1. [Inspect dataset](#Inspect-dataset)\n    2. [Verification and data quality](#Verification-and-data-quality)\n2. [Visualizing the static data](#Visualizing-the-static-data)\n    1. [Time series for minumum, average and maximum temperature](###Time-series-for-minumum,-average-and-maximum-temperature)\n    2. [Wind: direction and speed](#Wind:-direction-and-speed)\n    3. [How about climate change?](#How-about-climate-change?)\n    4. [Hours of sunshine](#Hours-of-sunshine)\n2. ...","3765e78a":"### Precipitation\nOur dataset includes columns on precipitation, i.e. RH sum precipitation (mm), RHX maximum hourly precipitation (mm) and RHXH hour in which RHX has occured. Let's select a year and generate a heatmap showing the precipitation intensity for each weekday.\n\nI use the Calmap library (https:\/\/pythonhosted.org\/calmap\/) to plot them. The hidden code below is taken directly from Github (https:\/\/github.com\/martijnvermaat\/calmap\/blob\/master\/calmap\/__init__.py) although I added the colorbar and fixed some bugs (depricated use of 'ix' and a week number issue).\n\n[(go to top)](#A-Century-worth-of-Weather-Observations!)","8c4306ca":"### How about climate change?\n\nNow, for a simple assessment of temperature increase of the past centure, let's plot the average yearly temperature since 1901 and have seaborn compute a linear regression. It shows a 2.0 degree increase! Is this the 2 degree limit the Paris Agreement talks about with respect to 'pre-industrial levels'?\n\nWell, this is just one series of observations in The Netherlands and it does not account for the worldwide average. Perhaps some parts of the world are warmed up more than others. I leave that level of complexity out of this analysis for now.\n\n[(go to top)](#A-Century-worth-of-Weather-Observations!)","bfc2c062":"### Verification and data quality\n\nTo make sure the data is processed well and just as a sanity check, the graphs below replicate official published KNMI graphs.\nThe first one replicates the Daily Average Temperature, with highs, lows and 'normal' based on a 30-year climatological average from 1981-2010.\nSee for yourself and check https:\/\/www.knmi.nl\/nederland-nu\/klimatologie\/grafieken\/jaar.\n\nThe normal temperature data can be 'smoothed' by resampling the data into larger intervals to mimick the official KNMI graphs, but for verification purposes this is fine.\n\n[(go to top)](#A-Century-worth-of-Weather-Observations!)","0b3ab503":"### Hours of sunshine\n\nThe dataset also includes columns for hours of sunshine (SQ) and sunshine as a perecentage of the maximum possible sunshine (SP), effectively a fraction of the daylight hours. It would be nice to plot this in a handy barplot, just like this: https:\/\/www.knmi.nl\/nederland-nu\/klimatologie\/maand-en-seizoensoverzichten\/lopende_maand (select 'Aantal uren zonneschijn' in the submenu).\n\nMy first attempt was to divide the hours of sunshine by the percentage (SQ \/ SP * 100) to obtain the daylight hours of each day. However, some days without sunshine (SP = 0) result in NaN values. These can then be found by interpolation, but even then some data show erratic behaviour, as can be seen from the plot below.\n\n[(go to top)](#A-Century-worth-of-Weather-Observations!)","29460e9f":"### Wind: direction and speed\n\nThanks to the amazing *windrose* library (https:\/\/windrose.readthedocs.io\/) it becomes easy to plot beautiful windroses that help us in intrepeting wind speed and direction of a timeframe.\n\nIt is not possible to import it yet on Kaggle, so hidden below is the full code (https:\/\/github.com\/python-windrose) which we can then use in our plotting function. I have made plotting function such, that it either lets the windrose library compute the bins itself (in m\/s wind speed) or add a scale manually. Handy for the Beaufort scale for example.\n\n[(go to top)](#A-Century-worth-of-Weather-Observations!)","d234863c":"How about the 30-day rolling average and compare it to the 1981-2010 and current year data?","03ad3da3":"Convert integer observations to integer columns, float observations to float columns.\nThe float observations in the dataset are in units of '0.1', for instance 14.2 degrees Celsius is stored as 142 and 3.6 m\/s wind speed as 36. Therefore, we divide those columns by 10.\n\nFinally, the YYYYMMDD column is converted to datetime and set as index. This will help us in plotting timeseries later on. ","0618cb63":"Initialize Notebook: import libraries and load CSV file.","889ab0d8":"# Visualizing the static data\nThe following cells are purely visualizations of the dataset. I tried to come up with a type of graph that most intuitively depicts the selected data.","c97e3e37":"### Inspect dataset\n\nSome columns are of type 'object'. They need to be converted to a numeric data type for pandas operations to work.\nAdditionally, we can immediately see that in the early years only a few measurements were taken, namely average temperature (TG) and 24HR average daily humidity (UG).\n\n[(go to top)](#A-Century-worth-of-Weather-Observations!)","4e75c0bb":"Instead of cleaning this code for each year by algorithms, then interpolating and smoothing (losing accuracy) I decided to Google the daylight hour approximation equations and just compute them in a separate column 'Daylight', see code below.\n\nEquations: https:\/\/www.esrl.noaa.gov\/gmd\/grad\/solcalc\/solareqns.PDF or http:\/\/www.jgiesen.de\/astro\/suncalc\/calculations.htm.","68858c6d":"Now we can visualize the daily hours of sunshine in a stacked barplot. First a bar of sunshine hours (SQ), then on top a bar of the remaining daylight hours without sunshine 'DaylightLeft'."}}