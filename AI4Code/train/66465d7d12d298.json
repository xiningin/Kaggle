{"cell_type":{"c0fe5d71":"code","d26b35d4":"code","b03c8b8d":"code","12e6a659":"code","3f901b11":"code","2534fde4":"code","1af7aa65":"code","bd38efd4":"code","d6ecd98a":"code","d284d415":"code","641efcde":"code","50eb046f":"code","110b796b":"code","9dba16a8":"code","f746ce86":"code","c569f417":"code","4d7e7f40":"code","283fc844":"code","fecbaa24":"markdown","39a5885f":"markdown","61a69f6b":"markdown","7e8ea2d0":"markdown","fec399ef":"markdown","9429d4c4":"markdown","e50c06f5":"markdown","fbb5eb5a":"markdown","6aabd3fc":"markdown","ff80c4e7":"markdown","fdacc170":"markdown","bda2fc0c":"markdown","2720c8b7":"markdown","bfdd258d":"markdown","09b60450":"markdown"},"source":{"c0fe5d71":"from IPython.core.display import HTML\nHTML(\"\"\"\n<style>\n.output_png {\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n    horizontal-align: middle;\n}\nh1,h2 {\n    text-align: center;\n    background-color: pink;\n    padding: 20px;\n    margin: 0;\n    color: white;\n    font-family: ariel;\n    border-radius: 80px\n}\n\nh3 {\n    text-align: center;\n    border-style: solid;\n    border-width: 3px;\n    padding: 12px;\n    margin: 0;\n    color: black;\n    font-family: ariel;\n    border-radius: 80px;\n    border-color: gold;\n}\n\nbody, p {\n    font-family: ariel;\n    font-size: 15px;\n    color: charcoal;\n}\ndiv {\n    font-size: 14px;\n    margin: 0;\n\n}\n\nh4 {\n    padding: 0px;\n    margin: 0;\n    font-family: ariel;\n    color: purple;\n}\n<\/style>\n\"\"\")","d26b35d4":"import pandas as pd\nimport numpy as np\nimport torch \nimport datatable as dt\nfrom sklearn.model_selection import train_test_split","b03c8b8d":"df = dt.fread('..\/input\/tabular-playground-series-dec-2021\/train.csv').to_pandas()","12e6a659":"class Dataset:\n    def __init__(self, X, y):\n        self.X = X.values\n        self.y = y.values\n        \n    def __len__(self):\n        return len(self.X)\n    \n    def __getitem__(self, idx):\n        return {\n            'X' : torch.tensor(self.X[idx], dtype=torch.float),\n            'y' : torch.tensor(self.y[idx], dtype=torch.float)\n        }","3f901b11":"X = df.drop('Cover_Type', axis=1)","2534fde4":"X.columns","1af7aa65":"from sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()","bd38efd4":"X.head()","d6ecd98a":"for i in range(1,5):\n    X[f'Wilderness_Area{i}'] = le.fit_transform(X[f'Wilderness_Area{i}'])\nfor i in range(1,41):\n    X[f'Soil_Type{i}'] = le.fit_transform(X[f'Soil_Type{i}'])","d284d415":"X.head()","641efcde":"y = df['Cover_Type']","50eb046f":"xtrain, xtest, ytrain, ytest = train_test_split(X, y, test_size=0.2)","110b796b":"print('Length of train: ', len(xtrain))\nprint('Length of test: ', len(xtest))","9dba16a8":"train_dataset = Dataset(xtrain, ytrain)\ntest_dataset = Dataset(xtest, ytest)","f746ce86":"print('First item of the train_dataset:\\n',train_dataset[0])\nprint('\\n\\nLength of the train_dataset: ', len(train_dataset))","c569f417":"from torch.utils.data import DataLoader","4d7e7f40":"train_loader = DataLoader(train_dataset, batch_size = 4)\ntest_loader = DataLoader(test_dataset, batch_size = 16)","283fc844":"for batch in train_loader:\n    print('Keys of batch:', (batch.keys()))\n    print('Length of the batch:', (len(batch['X'])))\n    print('-'*70)\n    print('The batch Items:')\n    print('-'*70)\n    print(batch)\n    break","fecbaa24":"# Upvote if you Like :)","39a5885f":"# **PyTorch Tutorial**","61a69f6b":"# Train-Test-Split","7e8ea2d0":"* The Dataloader is a wrapper around the Dataset Class.\n* It is a iterable that wraps around the datasets for easy access of the samples.\n* This loads the data in batches and feed to the Neural Network","fec399ef":"# The iteration loops","9429d4c4":"# The DataLoader","e50c06f5":"# We will use this DataLoader in the training and validation Loops","fbb5eb5a":"![Pytorch](https:\/\/venturebeat.com\/wp-content\/uploads\/2019\/06\/pytorch-e1576624094357.jpg?fit=750%2C375&strip=all)","6aabd3fc":"# Creating the datasets as objects of the Dataset class","ff80c4e7":"#### The Dataset class has 3 funtions\n* __init__ : just a constructor, defines the variables for that class instance\n* __len__ : returns the length of the dataset\n* __getitem__ : returns the values for a particular index (convert to tensors)","fdacc170":"### One Hot Encoded!!!\nA we can see the Wilderness_Area1-4 and Soild_Type1-40 are one-hot-encoded and values are either `True` or `False`. Let's convert `True` to `1` and `False` to `0` using `LabelEncoder`","bda2fc0c":"### Now then the Values are now converted to `1` and `0`","2720c8b7":"# Creating the Dataset Class","bfdd258d":"\nAt first I found so hard to understand the Pytorch documentation. But after investing much of my time I understood that this is not that very difficult.\n\nHere I will be breaking down the steps that are followed as a framework to create any Pytorch model from scratch or fine-tune any pretrained models made with Pytorch. \n\nAnyone can just copy paste these codes and tune to their needs and use :)\n\nSteps:\n\n* __Creating a Dataset Class__\n* __Creating a DataLoader__\n* __Making the Model__\n* __Training and Evaluation Loops__\n* __Saving and Inference__","09b60450":"# Loading the File"}}