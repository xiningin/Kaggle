{"cell_type":{"48a8105c":"code","e20fae38":"code","5ca6cbf8":"code","1772d556":"code","6af4111d":"code","8d93ec80":"code","c0d06e08":"code","6c41b936":"code","00d4bb36":"code","09e01247":"code","c73fea1b":"code","1e226388":"code","490d2a97":"code","2a8bee06":"code","92653e33":"code","01bfb646":"code","6839241e":"code","de216436":"code","75ae2150":"code","e7bde1dc":"code","e1b73dc9":"code","33450d7f":"code","b408e601":"code","ce5636c2":"code","b410abd0":"code","33ed1830":"code","0ceea6e0":"code","e72fbe85":"code","38064e17":"code","d56a67f4":"code","ec3e172a":"code","b7ecf69d":"code","8dc9ecda":"code","0d6fab39":"code","27516360":"code","060382a6":"code","3c91ff8f":"code","a908d1f6":"code","a305b3ae":"code","80396016":"code","4ffdbd0c":"code","27aeb2c3":"code","60601e35":"code","ec5d79fb":"code","d62dc3e9":"code","23f5841a":"markdown","f90e25ba":"markdown","93f9e85e":"markdown","dd1691f7":"markdown","a274498a":"markdown","f44daec3":"markdown","a050ed44":"markdown","f508d7eb":"markdown","fb5425c8":"markdown"},"source":{"48a8105c":"#Importing the necessary modulues beforehand is a good practice\nimport os\nimport torch\nimport pandas as pd\nimport numpy as np\nimport math\nfrom torch.utils.data import DataLoader\nfrom PIL import Image\nimport torchvision.models as models\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\nimport torchvision.transforms as T\nimport torch.nn.functional as F\nimport torch.nn as nn\nfrom torchvision.datasets import ImageFolder\nfrom torchvision.utils import make_grid\n%matplotlib inline","e20fae38":"#Classes of the dataset should be defined explicitly\nlabels_str={\n0:\"Hit\",\n1:\"Kick\",\n2:\"Punch\",\n3:\"Push\",\n4:\"ridehorse\",\n5:\"shootgun\",\n6:\"stand\",\n7:\"wave\"}","5ca6cbf8":"DATA_DIR = \"..\/input\/fight-dataset\/actions (2)\/actions\" #root directory comtaning the dataset.\n\nTRAIN_DIR = DATA_DIR + '\/train'                           # Sub-directory containing training images\nTEST_DIR = DATA_DIR + '\/test'                             # Sub-directory containing test images","1772d556":"#Initializing the values needed.\nbatch_size = 64 \nstats = ([0.485, 0.456, 0.406] #mean value of each channel in imagenet dataset.\n         , [0.229, 0.224, 0.225]) #standard deviation value of each channel in imagenet dataset.\nimage_size=224 #size of the image required. ","6af4111d":"#ImageFolder is very useful for image datasets as it takes the labels from the folder names and sends the images accordingly to the model.\ntrain_ds = ImageFolder(TRAIN_DIR, transform=T.Compose([\n    T.Resize((image_size,image_size)), #getting all the iamges of unique size as the images in the dataset may be of different sizes.\n    T.ToTensor(), #converts the arrays to tensor.\n    T.Normalize(*stats)])) #Normalizing the data which will be very useful for early convergence during training.\n#val denotes validation set.Here we will use our test data as validation data.\nval_ds = ImageFolder(TEST_DIR, transform=T.Compose([\n    T.Resize((image_size,image_size)),\n    T.ToTensor(),\n    T.Normalize(*stats)])) #'*' will make the tuple values according to arguements.\n\ntrain_dl = DataLoader(train_ds, batch_size, shuffle=True, num_workers=3, pin_memory=True) #The last two parameters are used to optimize the loading of the data to the gpu.\nval_dl = DataLoader(val_ds, batch_size*2, num_workers=2, pin_memory=True)","8d93ec80":"#The below function is used to renormalize the image for visualization of the dataset.\ndef denorm(img_tensors):\n    return img_tensors * stats[1][0] + stats[0][0] \n#The below 2 functions are used for visualizing the images in grid form.\ndef show_images(images, nmax=64):\n    fig, ax = plt.subplots(figsize=(8, 8))\n    ax.set_xticks([]); ax.set_yticks([])\n    ax.imshow(make_grid(denorm(images.detach()[:nmax]), nrow=8).permute(1, 2, 0))\ndef show_batch(dl, nmax=64):\n    for images, _ in dl:\n        show_images(images, nmax)\n        break","c0d06e08":"show_batch(train_dl)","6c41b936":"#FBeta Score is an evaluation metric used for complex datasets which is used to determine the performance of the model.\ndef F_score(output, label, threshold=0.5, beta=1):\n    prob = torch.argmax(torch.exp(output)\/sum(torch.exp(output)),axis=-1).view(1,-1) #don't forget about axis and view.\n\n    TP = (prob & label).sum(1).float() #True Positive -> Total number of True predictions that are actually True.\n    TN = ((~prob) & (~label)).sum(1).float() #True Negative -> Total number of False predictions that are actually False.\n    FP = (prob & (~label)).sum(1).float() #False Positive -> Total number of False prdictions that are actually True.\n    FN = ((~prob) & label).sum(1).float() #False Negative -> Total number of True predictions that are actually False\n\n    precision = torch.mean(TP \/ (TP + FP + 1e-12)) #Predictions that are True among the Total Predicted True values.\n    recall = torch.mean(TP \/ (TP + FN + 1e-12)) #Predictions that are True among the Total actual True values.\n    F2 = (1 + beta**2) * precision * recall \/ (beta**2 * precision + recall + 1e-12)\n    return F2.mean(0)","00d4bb36":"#This class is used for training and validation purposes which i have explained in my previous posts. For clarification you can refer there which I will linking down.\nclass ImageClassificationBase(nn.Module):\n    def training_step(self, batch):\n        images, targets= batch \n        out = self(images)                      \n        loss = F.cross_entropy(out, targets)      \n        return loss\n    \n    def validation_step(self, batch):\n        images, targets = batch \n        out = self(images)                           # Generate predictions\n        loss = F.cross_entropy(out, targets)  # Calculate loss\n        score = F_score(out, targets)\n        return {'val_loss': loss.detach(), 'val_score': score }\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_scores = [x['val_score'] for x in outputs]\n        epoch_score = torch.stack(batch_scores).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_score': epoch_score.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch [{}], last_lr: {:.4f}, train_loss: {:.4f}, val_loss: {:.4f}, val_score: {:.4f}\".format(\n            epoch, result['lrs'][-1], result['train_loss'], result['val_loss'], result['val_score']))","09e01247":"#There are more State-of-the-Art pre-trained models which are mostly trained on ImageNet dataset. ResNet is one of them.\nresnet34 = models.resnet34(pretrained=True)\nresnet34","c73fea1b":"class ActionResNet(ImageClassificationBase):\n    def __init__(self):\n        super().__init__()\n        # Using a pretrained model\n        self.network = models.resnet34(pretrained=True) #pretrained states that the model is taken with trained weights.\n        # Replace last layer\n        num_ftrs = self.network.fc.in_features\n        self.network.fc = nn.Linear(num_ftrs, 256)\n        #Adding top layers for better performance.\n        self.network1=nn.Linear(256,8)\n        self.networkact=nn.ReLU()\n        self.softmax=nn.Softmax(dim=1)\n    \n    def forward(self, xb):\n        out=self.network(xb)\n        out=self.networkact(out)\n        out=self.network1(out)\n        return self.softmax(out) #for matrices dimension is 1 as we say to model to do softmax to the last dimension(i.e vectors)\n    #the below function will make only the top layers to be available for training i.e the layers we added.\n    def freeze(self):\n        # To freeze the residual layers\n        for param in self.network.parameters():\n            param.require_grad = False\n        for param in self.network.fc.parameters():\n            param.require_grad = True\n    #the below function will make the entire model trainable.\n    def unfreeze(self):\n        # Unfreeze all layers\n        for param in self.network.parameters():\n            param.require_grad = True","1e226388":"def get_default_device():\n    \"\"\"Pick GPU if available, else CPU\"\"\"\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')\n    \ndef to_device(data, device):\n    \"\"\"Move tensor(s) to chosen device\"\"\"\n    if isinstance(data, (list,tuple)):\n        return [to_device(x, device) for x in data]\n    return data.to(device, non_blocking=True)\n\nclass DeviceDataLoader():\n    \"\"\"Wrap a dataloader to move data to a device\"\"\"\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        \"\"\"Yield a batch of data after moving it to device\"\"\"\n        for b in self.dl: \n            yield to_device(b, self.device)\n\n    def __len__(self):\n        \"\"\"Number of batches\"\"\"\n        return len(self.dl)","490d2a97":"device = get_default_device()\ndevice","2a8bee06":"train_dl = DeviceDataLoader(train_dl, device)\nval_dl = DeviceDataLoader(val_dl, device)","92653e33":"@torch.no_grad() #Not to perform any backprop calculation during this cell is running.\ndef evaluate(model, val_loader):\n    model.eval()\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n#the below function is used to get the learning_rate from the optimizer.\ndef get_lr(optimizer):\n    for param_group in optimizer.param_groups:\n        return param_group['lr']\n#Fit function for one-cyclical-learningrate-scheduler.\ndef fit_one_cycle(epochs, max_lr, model, train_loader, val_loader, \n                  weight_decay=0.1, grad_clip=True, opt_func=torch.optim.SGD):\n    torch.cuda.empty_cache() #To clear unwanted training data from memory\n    history = []\n    \n    # Set up custom optimizer with weight decay where weight decay is a type of regularization technique which is used to reduce overfitting.\n    optimizer = opt_func(model.parameters(), max_lr, weight_decay=weight_decay) \n    # Set up one-cycle learning rate scheduler\n    sched = torch.optim.lr_scheduler.OneCycleLR(optimizer, max_lr, epochs=epochs, \n                                                steps_per_epoch=len(train_loader))\n    \n    for epoch in range(epochs):\n        # Training Phase \n        model.train()\n        train_losses = []\n        lrs = []\n        for batch in tqdm(train_loader):\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            \n            # Gradient clipping which is used to prevent exploding gradients i.e gradient values which will go very high.\n            #Here gradient values will be cutted off to a value when it goes beyond that value i.e if value>1,then value=1.\n            if grad_clip: \n                nn.utils.clip_grad_value_(model.parameters(), grad_clip)\n            \n            optimizer.step()\n            optimizer.zero_grad()\n            \n            # Record & update learning rate\n            lrs.append(get_lr(optimizer))\n            sched.step()\n        \n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        result['lrs'] = lrs\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","01bfb646":"#Fit function for Learning_rate_finder\ndef fit(epochs, start_lr,end_lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    lrs=[]\n    \n    # LR function lambda\n\n    lr_lambda = lambda x: math.exp(x * math.log(end_lr \/ start_lr) \/ (epochs * len( train_dl))) \n\n    optimizer = opt_func(model.parameters(), start_lr )\n    scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda)\n    for epoch in range(epochs):\n        # Training Phase \n        model.train()\n        train_losses = []\n        for batch in tqdm(train_loader):\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            #Updating gradients\n            optimizer.step()\n            optimizer.zero_grad()\n            scheduler.step()\n        #logging lr at each epoch end.\n        lr_step = optimizer.state_dict()[\"param_groups\"][0][\"lr\"]\n\n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        result['lrs'] = [lr_step]\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","6839241e":"model = to_device(ActionResNet(), device) ","de216436":"model.unfreeze() #unfreezing to get the optimal learning rate.","75ae2150":"#Initializing the required values for learning_rate_finder.\nepochs = 10\nstart_lr = 1e-7\nend_lr = 0.1\nopt_func = torch.optim.Adam","e7bde1dc":"%%time\nhistory = fit(epochs, start_lr,end_lr, model, train_dl, val_dl, \n                         opt_func=opt_func)","e1b73dc9":"#Plotting Learning_rate vs Training_Loss\nimport matplotlib.pyplot as plt\nplt.semilogx([x.get('lrs') for x in history],[x.get('train_loss') for x in history])","33450d7f":"model = to_device(ActionResNet(), device) #Re-initializing the model to start training.","b408e601":"#If you want load the weights and start testing the model,you can uncomment the below 2 lines and directly go to prediction section\n#model.load_state_dict(torch.load(\".\/savemodelweights.pth\"))\n#model.eval()","ce5636c2":"model.freeze()","b410abd0":"#Initializing the required values.\nepochs = 8\nmax_lr = 8e-5\ngrad_clip = 0.1\nweight_decay = 1e-4\nopt_func = torch.optim.Adam","33ed1830":"%%time \nhistory = fit_one_cycle(epochs, max_lr, model, train_dl, val_dl, \n                         grad_clip=grad_clip, \n                         weight_decay=weight_decay, \n                         opt_func=opt_func)","0ceea6e0":"model.unfreeze()","e72fbe85":"%%time \nhistory += fit_one_cycle(epochs, 1e-4 , model, train_dl, val_dl, \n                         grad_clip=grad_clip, \n                         weight_decay=weight_decay, \n                         opt_func=opt_func )","38064e17":"#use the below line for saving the weights to a directory in pth format which you can use for next training i.e when you start again from the same spot you left training.\ntorch.save(model.state_dict(), \"savemodelweights.pth\")","d56a67f4":"#Now let's evaluate the model to get final results on the performance.\nprint([evaluate(model, val_dl)])","ec3e172a":"#Let's now plot the validation F-beta scores.\ndef plot_scores(history):\n    scores = [x['val_score'] for x in history]\n    plt.plot(scores, '-x')\n    plt.xlabel('epoch')\n    plt.ylabel('score')\n    plt.title('F1 score vs. No. of epochs');","b7ecf69d":"plot_scores(history)","8dc9ecda":"#Here we plot train_loss and val_loss to check for overfitting.\ndef plot_losses(history):\n    train_losses = [x.get('train_loss') for x in history]\n    val_losses = [x['val_loss'] for x in history]\n    plt.plot(train_losses, '-bx')\n    plt.plot(val_losses, '-rx')\n    plt.xlabel('epoch')\n    plt.ylabel('loss')\n    plt.legend(['Training', 'Validation'])\n    plt.title('Loss vs. No. of epochs');","0d6fab39":"plot_losses(history)","27516360":"#This graph shows how learning rate values went through the training.\ndef plot_lrs(history):\n    lrs = np.concatenate([x.get('lrs', []) for x in history])\n    plt.plot(lrs)\n    plt.xlabel('Batch no.')\n    plt.ylabel('Learning rate')\n    plt.title('Learning Rate vs. Batch no.');","060382a6":"plot_lrs(history)","3c91ff8f":"def predict_single(image,label):\n    xb = image.unsqueeze(0)\n    xb = to_device(xb, device)  #to load the image to the gpu memory.\n    preds = model(xb)\n    prediction = preds[0]\n    print(\"Actual Label: \",labels_str[label])\n    print(\"Prediction: \", labels_str[torch.argmax(prediction).tolist()]) #The predicted class is extracted from the predicted values.\n    show_images(image)","a908d1f6":"predict_single(*val_ds[300])","a305b3ae":"predict_single(*val_ds[800])","80396016":"predict_single(*val_ds[1000])","4ffdbd0c":"predict_single(*val_ds[1250])","27aeb2c3":"predict_single(*val_ds[2000])","60601e35":"predict_single(*val_ds[4000])","ec5d79fb":"predict_single(*val_ds[4500])","d62dc3e9":"predict_single(*val_ds[6200])","23f5841a":"**Let us now predict using the model to see the performance.**","f90e25ba":"## Preparing the Data","93f9e85e":"Now, unfreeze and train some more.","dd1691f7":"## Training","a274498a":"First, freeze the ResNet layers and train some epochs. This only trains the final layer to start classifying the images.","f44daec3":"## Model - Transfer Learning","a050ed44":"## Making predictions and submission","f508d7eb":"[Learn about ResNets.](https:\/\/towardsdatascience.com\/an-overview-of-resnet-and-its-variants-5281e2f56035)\n\nCheck out torchvision models: https:\/\/pytorch.org\/docs\/stable\/torchvision\/models.html","fb5425c8":"# **For more details and tutorial on this notebook , feel free to click [here](https:\/\/medium.com\/@karthikayanmailsamy\/action-certainer-using-transfer-learning-in-pytorch-d3fb41a21a09?source=your_stories_page---------------------------).**\n"}}