{"cell_type":{"6bc49122":"code","381f4ca6":"code","7141955e":"code","2c8f663c":"code","67ed1ba6":"code","e7ce370b":"code","ca8041dc":"code","84922484":"code","f50f8324":"code","37ae8fd5":"code","b25161d8":"code","98a9d4ce":"code","b6ebc62f":"code","46a29825":"code","86764c1b":"code","b17017f2":"code","6896970b":"code","4c1b8b70":"code","ac4f8468":"code","53385805":"code","68a68a36":"code","7bec321a":"code","53b6149c":"code","fb4ffeef":"code","6c315e4f":"code","8185867b":"code","6ad74427":"code","ab9c6a45":"code","01e8c95b":"code","bc19ea5d":"code","2ade3f46":"code","c2cde4fc":"code","16e68f0a":"code","0482138a":"code","993821fe":"code","84d5c40c":"code","62f9e602":"code","82f4a70d":"code","b3f16e5a":"code","65fdd6b6":"code","c0028c52":"code","9c4f4e29":"code","b52956b0":"code","33071267":"code","e814cf2d":"code","ec29c8fe":"code","35ae93c0":"code","d1764e98":"code","a6e14a01":"code","fdc890d7":"code","d4ebb6d3":"code","cea5982b":"code","1c896b8a":"code","4eddf207":"code","c942f6b4":"code","32f514d0":"code","5f6aeb05":"code","2d90679e":"code","9b6799b0":"markdown","46ccd4f6":"markdown","fe562570":"markdown","b402cbb1":"markdown","b538051e":"markdown","8eec363f":"markdown","ea1cbeaf":"markdown","bec64865":"markdown","ee761b45":"markdown","f0707214":"markdown","13ca83f6":"markdown","efc3f42d":"markdown","4b40d599":"markdown","7a012a36":"markdown","c6d2b181":"markdown","673c62e0":"markdown","e2a139fe":"markdown","da6840c1":"markdown","9c5aa2e9":"markdown","51176920":"markdown","41c01409":"markdown","e1033eda":"markdown","7f5e7308":"markdown","9b73f616":"markdown","2417c153":"markdown","d4f2e37a":"markdown","67e7a157":"markdown","703c3f80":"markdown","cc40e230":"markdown","f0e32132":"markdown","6e1bef25":"markdown","1b8c1c48":"markdown","ae977350":"markdown","d267e8be":"markdown","7ab67392":"markdown","96d91f5a":"markdown"},"source":{"6bc49122":"# coding: utf-8\n\n# C\u00f3digo ensinado no curso de python 2 do instituto Prandiano. \n\n# Pacotes:\nimport numpy as np\nimport pandas as pd\nimport pickle as pkl\n\n\ndef svm(banco_de_dados):\n    '''\n    :param banco_de_dados: Banco de Dados de input\n    return: A: Matrix de Coeficientes [A],\n    B: vector das Sa\u00eddas [B],\n    X: Coeficientes da solu\u00e7\u00e3o do sistema de equa\u00e7\u00f5es da matriz A,\n    '''\n\n    # valor_c: coeficiente de ajuste\n    valor_c = 0.1\n\n    # tolerancia: Tolerancia para a matriz ser ou nao inversivel... Se detA < tolerancia n\u00e3o \u00e9 invers\u00edvel. (Somente os valores v\u00e1lidos para o c\u00e1lculo)\n    tolerancia = 0.9\n\n\n    bd_auxiliar = banco_de_dados\n    \n    # Remover a \u00fatlima coluna - coluna com os resultados experimentais da classifica\u00e7\u00e3o: Coluna HONESTO\n    # axis = 1 indica que ir\u00e1 remover uma coluna.\n    # bd_auxiliar.shape[1]: n\u00famero de colunas. Axis =1 remove no sentido da coluna. Se fosse linha usaria axis = 0.\n    # Veja que o \u00edndice da \u00faltima coluna que queremos remover (HONESTO) \u00e9 o tamanho de colunas - 1, pois o \u00edndice come\u00e7a em zero.\n    bd_auxiliar = bd_auxiliar.drop([bd_auxiliar.columns[bd_auxiliar.shape[1] - 1]],\n                                   axis = 1)\n    \n    # Armazenar somente os valores, ou seja, sem os t\u00edtulos das colunas: Aqui voc\u00ea transforma o dataFrame numa array.\n    valores = bd_auxiliar.values\n    \n    num_de_variaveis = valores.shape[1]\n    num_de_licoes = valores.shape[0]\n    \n    # Armazenar a ultima coluna do banco de dados da vari\u00e1vel banco_de_dados, resultados experimentais:\n    # Estou pegando todas as linhas, por\u00e9m apenas 10 primeiras das 11 colunas originais do bd.\n    # iloc: integer localization.\n    # loc: localiza via texto.\n    # shape[0] -> n\u00famero de linhas do data frame\n    # shape[1] -> n\u00famero de colunas do data frame\n    B = banco_de_dados.iloc[:, banco_de_dados.shape[1] - 1]\n    \n    # num_de_colunas_faltantes: n\u00famero de colunas faltantes para transformar a matrix de coeficientess A numa matriz quadrada.\n    # A ideia \u00e9 construir uma matriz quadrada. Entao vamos ter que criar colunas preenchidas apenas com 1. Essas colunas faltantes sao as linhas - colunas, ou seja, li\u00e7oes menos variaveis.\n    if num_de_licoes > num_de_variaveis:\n        num_de_colunas_faltantes = num_de_licoes - num_de_variaveis\n    elif num_de_licoes == num_de_variaveis:\n        num_de_colunas_faltantes = 0\n    elif num_de_licoes < num_de_variaveis:\n        print(\"O n\u00famero de linhas no banco de dadods \u00e9 \" +\n              \"menor que o n\u00famero de colunas, ou seja, o\" + \n              \"banco de dados possui poucos dados quando\" + \n              \"comparado com o n\u00famero de vari\u00e1veis (colunas) \" + \n              \"Adicionar mais registros (linhas) no banco de dados se for poss\u00edvel.\")\n\n    # Caso mais comum com li\u00e7\u00f5es maiores que vari\u00e1veis.\n    if num_de_colunas_faltantes != 0:\n        \n        matrix = np.zeros((num_de_licoes, num_de_colunas_faltantes))\n        \n        n = 0\n        \n        # Na vari\u00e1vel matrix, s\u00e3o preenchidas as colunas faltantes, sendo que a primeira coluna dever\u00e1 ser preenchida\n        # com 'uns', a segunda coluna com 'dois' e assim por diante\n        for k in range(0, num_de_colunas_faltantes, 1):\n            n = n + 1\n            for i in range(0, num_de_licoes, 1):\n                matrix[i, k] = n\n        # na variavel matrix serao armazenadas as colunas faltantes conforme descrito no coment\u00e1rios acima.\n        \n        # Acoplamento do banco de dados (com colunas faltantes) com as colunas preenchidas e que devem ser acoplados ao bd\n        valores = np.hstack((valores, matrix))\n        \n        # Atualiza\u00e7\u00e3o do n\u00famero de colunas\n        num_de_variaveis = valores.shape[1]\n        \n        # Armazenar matrix [A]\n        A = np.zeros((num_de_licoes, num_de_variaveis))\n        \n    elif num_de_colunas_faltantes == 0:\n        # Armazenar matrix [A]\n        A = np.zeros((num_de_licoes, num_de_variaveis))\n        \n    # A variavel abaixo vai armazenar o valor do 'c' para realizar a solu\u00e7\u00e3o do modelo, este valor vem do main_svm como um input.\n    # Este valor \u00e9 fundamental, principalmente, quando \u00e9 necess\u00e1rio incluir colunas de uns, ou dois e assim por diante.\n    c = float(valor_c)\n\n    # Cada elemento da matriz A \u00e9 o produto escalar (inner) da primeira linha do banco de dados com a primeira linha, depois primeira com segunda, etc..\n    for i in range(0, A.shape[0], 1):\n        for j in range(0, A.shape[1], 1):\n            A[i,j] = np.inner(valores[i], valores[j]) + c ** 2 # inner = \u00c9 o produto escalar entre dois vetores.\n\n\n    # O SVM depende que a matriz quadrada seja invers\u00edvel, ou seja, DET A != 0. Portanto, primeira coisa a fazer \u00e9 o teste.\n    # Para fins pr\u00e1ticos, qualquer determinante de A pr\u00f3ximo a zero, ou seja, < toler\u00e2ncia, invalida o m\u00e9todo! N\u00f3s definimos a toler\u00e2ncia para isso.\n    det_A = np.linalg.det(A)\n    if np.abs(det_A) <= tolerancia:\n        print(\"\")\n        print(\"Observacao: O determinante da Matrix de coeficientes\"\n                \"[A] \u00e9 muito pr\u00f3ximo de 0 zero: ], \", det_A,\n                \" . Portanto, o m\u00e9todo pode n\u00e3o ser adequado.\")\n        print(\"\")\n\n    # Armazenar matrix [X]\n    inv_A = np.linalg.inv(A)\n    # matmul \u00e9 multiplica\u00e7\u00e3o de matrizes\n    X = np.matmul(inv_A, B)\n    \n    A = np.array(A)\n    B = np.array(B)\n    # Vetor de coeficientes solu\u00e7\u00e3o. Cont\u00e9m o valor dos par\u00e2metros.\n    # VERIFICAR SE OS PARAMETROS SAO ESTATISTICAMENTE DIFERENTE DE ZERO.\n    # P-valor dos par\u00e2metros\n    X = np.array(X)\n    \n    # matrix_solucao \u00e9  a vari\u00e1vel que armazena a multiplica\u00e7ao de cada linha do BD com o vetor [x] de solu\u00e7\u00f5es do sistema de equa\u00e7\u00f5es\n    \n    matrix_solucao = np.zeros((num_de_licoes, num_de_variaveis))\n    for i in range(0, num_de_licoes, 1):\n        # Aqui vamos preencher a matriz solu\u00e7\u00e3o multiplicando os valores dos coeficientes X pelos valores\n        matrix_solucao[i, :] = np.multiply(valores[i, :], X[i])\n        \n    # soma_vector_C = coef linear da solucao do modelo\n    soma_vector_C = X.sum(axis=0)\n    \n    # a variavel vector_solucao armazena os resultados obitdos dos coeficientes angulares\n\n    # Declara vetor solucao\n    vector_solucao = np.zeros(num_de_licoes)\n    # Abastece o vetor solucao com s soma das linhas da matriz solucao.\n    vector_solucao = matrix_solucao.sum(axis=0)\n\n    print(\" Este programa gera o seguinte vetor de resultados: [B, valores, vector_solucao, soma_vector_C] \\n\"\n          \" valores: Matriz contendo os valores do banco de dados (sem a sa\u00edda). \\n \"\n          \"vector_solucao: Coeficientes angulares da fun\u00e7\u00e3o te\u00f3rica. \\n \"\n          \"soma_vector_C: valor do coeficente linear. \\n\")\n\n    return [B, valores, vector_solucao, soma_vector_C]","381f4ca6":"import numpy as np\nimport pandas as pd","7141955e":"# Carregamento e Armazenamento:\n\n# Caminho para os dados\npath = \"..\/input\/covid19\/dataset.xlsx\"\n\n# L\u00ea os dados do excel.\ndata_original = pd.read_excel(path, encoding='UTF-8', delimiter=';' , sheet_name=\"All\")\n\n# C\u00f3pia do banco original, para N\u00c3O alterar o primeiro, caso seja necess\u00e1rio utiliz\u00e1-lo posteriormente no c\u00f3digo.\ndata_mod = data_original.copy()","2c8f663c":"# O banco de dados possui 111 colunas e 5644 linhas (que por motivos did\u00e1ticos tamb\u00e9m chamaremos de li\u00e7\u00f5es)\ndata_mod.shape","67ed1ba6":"data_mod.head()","e7ce370b":"# Criando um dataFrame que ser\u00e1 usado na an\u00e1lise de NaN\ndf_analise = pd.DataFrame(columns=['variavel_name', 'variavel_qtd_NaN', 'variavel_tipo', 'variavel_categorias'])\ndf_analise","ca8041dc":"# Criando uma lista com o nome das vari\u00e1veis do banco original\ncoluna_name_list = list(data_mod.columns.values)","84922484":"# Agora vamos criar um dataFrame em que exibimos o nome da vari\u00e1vel do banco original, a quantidade de vazios desta vari\u00e1vel, o tipo desta vari\u00e1vel.\n# Tamb\u00e9m temos uma coluna final que ir\u00e1 armazenar uma lista com o nome das possibilidades que cada vari\u00e1vel n\u00e3o num\u00e9rica assume.\nfor i in coluna_name_list:\n    lista=[i, data_mod[i].isna().sum() , data_mod[i].dtypes, \"variavel num\u00e9rica\"]\n    df_length = len(df_analise)\n    df_analise.loc[df_length] = lista","f50f8324":"# CONCLUS\u00c3O\n\n# As seguintes vari\u00e1veis do nosso banco possuem todos os valores vazios e dever\u00e3o ser removidas\nvariaveis_vazias = df_analise[df_analise[\"variavel_qtd_NaN\"]==data_mod.shape[0]]","37ae8fd5":"variaveis_vazias","b25161d8":"# Variavel_name passa a ser o \u00edndice do dataFrame\ndf_analise.set_index('variavel_name', inplace=True)","98a9d4ce":"# Agora para as vari\u00e1veis do tipo \"object\" ou seja, categ\u00f3ricas, vamos atribuir uma lista com valores \u00fanicos que ela assume no banco original.\nfor i in coluna_name_list:\n    if(df_analise.loc[i, \"variavel_tipo\"] == \"object\"):\n        df_analise.loc[i, \"variavel_categorias\"] = list(data_mod[i].unique())\n    else:\n        pass","b6ebc62f":"# CONCLUS\u00c3O\n\n# Vari\u00e1veis com valores categ\u00f3ricos que precisam ser transformados em num\u00e9ricos.\ndf_variavies_qualitativas = df_analise[df_analise[\"variavel_tipo\"]==\"object\"]\ndf_variavies_qualitativas","46a29825":"# 4.0) Transformar os valores \"not_done\" e \"N\u00e3o realizado\" em vazios\n\ndata_mod = data_mod.replace(\"not_done\", np.NaN).replace(\"N\u00e3o Realizado\", np.NaN)","86764c1b":"# Primeiro vamos montar uma lista com o nome das vari\u00e1veis vazias\nlista_variaveis_vazias = list(variaveis_vazias[\"variavel_name\"])\n# Agora para cada nome de vari\u00e1vel vamos remover do banco de dados\nfor i in lista_variaveis_vazias:\n    del data_mod[i]","b17017f2":"# Criar uma coluna adicional que ir\u00e1 armazenar a quantidade de NaNs que determina linha apresenta.\ndata_mod[\"isNaN\"] = \"\"","6896970b":"# Agora vamos analisar cada coluna referente a um teste laboratorial e verificar se ela possui NaN. \n# Assim, a coluna \"isNaN\" cont\u00e9m o n\u00famero de vezes que a linha possui o valor NaN.\ncontador=0\n# Avalia se todos os valores desta linha s\u00e3o NA. Se forem, no fim alimenta a coluna  \"isNaN\" com SIM. Se n\u00e3o, muda de linha e n\u00e3o faz nada.\nfor lin in range(data_mod.shape[0]):\n    for col in range(6, data_mod.shape[1]-1, 1):\n        if(pd.isnull(data_mod.iloc[lin, col])):\n            contador = contador + 1\n        else:\n            pass\n            # Muda de linha\n    data_mod.iloc[lin,106] = contador\n    contador=0","4c1b8b70":"data_mod['isNaN'].describe()","ac4f8468":"# Vamos trabalhar apenas com as linhas que apresentaram pelo menos XXX dos 100 testes com algum valor n\u00e3o nulo.\ndata_sem_vazios = (data_mod.loc[data_mod['isNaN'] < 80]).copy()","53385805":"data_sem_vazios.reset_index(drop=True)","68a68a36":"# Atribuir aos NaN o valor num\u00e9rico -10. Este valor \u00e9 bom pois \u00e9 distinto dos demais, dado que o menor valor que aparece no dataset \u00e9 -5,9.\n# Importante para o modelo entender que para estes casos n\u00e3o foi realizado teste.\ndata_sem_vazios = data_sem_vazios.fillna(-10)","7bec321a":"# Remove colunas desnecess\u00e1rias\ndel data_sem_vazios[\"isNaN\"]\ndel data_sem_vazios[\"Patient ID\"]","53b6149c":"# As seguintes variaveis qualitativas receber\u00e3o valores num\u00e9ricos arbitr\u00e1rios. Esta \u00e9 a maneira com a qual o modelo SVM funciona.\ndf_variavies_qualitativas","fb4ffeef":"# Vari\u00e1veis bin\u00e1rias\nprint(\"Respiratory Syncytial Virus\", data_sem_vazios[\"Respiratory Syncytial Virus\"].unique())\nprint(\"Influenza A\", data_sem_vazios[\"Influenza A\"].unique())\nprint(\"Influenza B\", data_sem_vazios[\"Influenza B\"].unique())\nprint(\"Parainfluenza 1\", data_sem_vazios[\"Parainfluenza 1\"].unique())\nprint(\"CoronavirusNL63\", data_sem_vazios[\"CoronavirusNL63\"].unique())\nprint(\"Rhinovirus\/Enterovirus\", data_sem_vazios[\"Rhinovirus\/Enterovirus\"].unique())\nprint(\"Coronavirus HKU1\", data_sem_vazios[\"Coronavirus HKU1\"].unique())\nprint(\"Parainfluenza 3\", data_sem_vazios[\"Parainfluenza 3\"].unique())\nprint(\"Chlamydophila pneumoniae\", data_sem_vazios[\"Chlamydophila pneumoniae\"].unique())\nprint(\"Adenovirus\", data_sem_vazios[\"Adenovirus\"].unique())\nprint(\"Parainfluenza 4\", data_sem_vazios[\"Parainfluenza 4\"].unique())\nprint(\"Coronavirus229E\", data_sem_vazios[\"Coronavirus229E\"].unique())\nprint(\"CoronavirusOC43\", data_sem_vazios[\"CoronavirusOC43\"].unique())\nprint(\"Inf A H1N1 2009\", data_sem_vazios[\"Inf A H1N1 2009\"].unique())\nprint(\"Bordetella pertussis\", data_sem_vazios[\"Bordetella pertussis\"].unique())\nprint(\"Metapneumovirus\", data_sem_vazios[\"Metapneumovirus\"].unique())\nprint(\"Parainfluenza 2\", data_sem_vazios[\"Parainfluenza 2\"].unique())","6c315e4f":"data_sem_vazios[\"Influenza A\"]= data_sem_vazios[\"Influenza A\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Influenza B\"]= data_sem_vazios[\"Influenza B\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Respiratory Syncytial Virus\"]= data_sem_vazios[\"Respiratory Syncytial Virus\"].replace(\"not_detected\", 0).replace(\"detected\", 1) \n\ndata_sem_vazios[\"Parainfluenza 1\"]= data_sem_vazios[\"Parainfluenza 1\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"CoronavirusNL63\"]= data_sem_vazios[\"CoronavirusNL63\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Rhinovirus\/Enterovirus\"]= data_sem_vazios[\"Rhinovirus\/Enterovirus\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Coronavirus HKU1\"]= data_sem_vazios[\"Coronavirus HKU1\"].replace(\"not_detected\", 0).replace(\"detected\", 1) \n\ndata_sem_vazios[\"Parainfluenza 3\"]= data_sem_vazios[\"Parainfluenza 3\"].replace(\"not_detected\", 0).replace(\"detected\", 1) \n\ndata_sem_vazios[\"Chlamydophila pneumoniae\"]= data_sem_vazios[\"Chlamydophila pneumoniae\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Adenovirus\"]= data_sem_vazios[\"Adenovirus\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Parainfluenza 4\"]= data_sem_vazios[\"Parainfluenza 4\"].replace(\"not_detected\", 0).replace(\"detected\", 1) \n\ndata_sem_vazios[\"Coronavirus229E\"]= data_sem_vazios[\"Coronavirus229E\"].replace(\"not_detected\", 0).replace(\"detected\", 1) \n\ndata_sem_vazios[\"CoronavirusOC43\"]= data_sem_vazios[\"CoronavirusOC43\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Inf A H1N1 2009\"]= data_sem_vazios[\"Inf A H1N1 2009\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n\ndata_sem_vazios[\"Bordetella pertussis\"]= data_sem_vazios[\"Bordetella pertussis\"].replace(\"not_detected\", 0).replace(\"detected\", 1)\n                                                                                                \ndata_sem_vazios[\"Metapneumovirus\"]= data_sem_vazios[\"Metapneumovirus\"].replace(\"not_detected\", 0).replace(\"detected\", 1) \n\ndata_sem_vazios[\"Parainfluenza 2\"]= data_sem_vazios[\"Parainfluenza 2\"].replace(\"not_detected\", 0).replace(\"detected\", 1) ","8185867b":"# Vari\u00e1veis bin\u00e1rias do tipo: positive\/negative\n\nprint(\"SARS-Cov-2 exam result\", data_sem_vazios[\"SARS-Cov-2 exam result\"].unique())\nprint(\"Influenza B, rapid test\", data_sem_vazios[\"Influenza B, rapid test\"].unique())\nprint(\"Influenza A, rapid test\", data_sem_vazios[\"Influenza A, rapid test\"].unique())\nprint(\"Strepto A\", data_sem_vazios[\"Strepto A\"].unique())","6ad74427":"data_sem_vazios[\"SARS-Cov-2 exam result\"]= data_sem_vazios[\"SARS-Cov-2 exam result\"].replace(\"negative\", 0).replace(\"positive\", 1)\n\ndata_sem_vazios[\"Influenza B, rapid test\"]= data_sem_vazios[\"Influenza B, rapid test\"].replace(\"negative\", 0).replace(\"positive\", 1)\n\ndata_sem_vazios[\"Influenza A, rapid test\"]= data_sem_vazios[\"Influenza A, rapid test\"].replace(\"negative\", 0).replace(\"positive\", 1)\n\ndata_sem_vazios[\"Strepto A\"]= data_sem_vazios[\"Strepto A\"].replace(\"negative\", 0).replace(\"positive\", 1).replace(\"not_done\", -10)","ab9c6a45":"# Vari\u00e1veis do tipo absent\/presente\n\nprint(\"Urine - Esterase\", data_sem_vazios[\"Urine - Esterase\"].unique())\nprint(\"Urine - Hemoglobin\", data_sem_vazios[\"Urine - Hemoglobin\"].unique())\nprint(\"Urine - Bile pigments\", data_sem_vazios[\"Urine - Bile pigments\"].unique())\nprint(\"Urine - Ketone Bodies\", data_sem_vazios[\"Urine - Ketone Bodies\"].unique())\nprint(\"Urine - Nitrite\", data_sem_vazios[\"Urine - Nitrite\"].unique())\nprint(\"Urine - Urobilinogen\", data_sem_vazios[\"Urine - Urobilinogen\"].unique())\nprint(\"Urine - Protein\", data_sem_vazios[\"Urine - Protein\"].unique())\nprint(\"Urine - Hyaline cylinders\", data_sem_vazios[\"Urine - Hyaline cylinders\"].unique())\nprint(\"Urine - Granular cylinders\", data_sem_vazios[\"Urine - Granular cylinders\"].unique())\nprint(\"Urine - Yeasts\", data_sem_vazios[\"Urine - Yeasts\"].unique())","01e8c95b":"data_sem_vazios[\"Urine - Esterase\"]= data_sem_vazios[\"Urine - Esterase\"].replace(\"absent\", 0).replace(\"not_done\", -10)\n\ndata_sem_vazios[\"Urine - Hemoglobin\"]= data_sem_vazios[\"Urine - Hemoglobin\"].replace(\"absent\", 0).replace(\"present\", 1).replace(\"not_done\", -10)\n\ndata_sem_vazios[\"Urine - Bile pigments\"]= data_sem_vazios[\"Urine - Bile pigments\"].replace(\"absent\", 0).replace(\"not_done\", -10)\n\ndata_sem_vazios[\"Urine - Ketone Bodies\"]= data_sem_vazios[\"Urine - Ketone Bodies\"].replace(\"absent\", 0).replace(\"not_done\", -10)\n\ndata_sem_vazios[\"Urine - Nitrite\"]= data_sem_vazios[\"Urine - Nitrite\"].replace(\"not_done\", -10)\n\ndata_sem_vazios[\"Urine - Urobilinogen\"]= data_sem_vazios[\"Urine - Urobilinogen\"].replace(\"normal\", 0).replace(\"not_done\", -10)\n\ndata_sem_vazios[\"Urine - Protein\"]= data_sem_vazios[\"Urine - Protein\"].replace(\"absent\", 0).replace(\"not_done\", -10)\n\ndata_sem_vazios[\"Urine - Hyaline cylinders\"]= data_sem_vazios[\"Urine - Hyaline cylinders\"].replace(\"absent\", 0)\n\ndata_sem_vazios[\"Urine - Granular cylinders\"]= data_sem_vazios[\"Urine - Granular cylinders\"].replace(\"absent\", 0)\n\ndata_sem_vazios[\"Urine - Yeasts\"]= data_sem_vazios[\"Urine - Yeasts\"].replace(\"absent\", 0)","bc19ea5d":"# Vari\u00e1veis categ\u00f3ricas\nprint(\"Urine - Aspect\", data_sem_vazios[\"Urine - Aspect\"].unique())\nprint(\"Urine - Crystals\", data_sem_vazios[\"Urine - Crystals\"].unique())\nprint(\"Urine - Color\", data_sem_vazios[\"Urine - Color\"].unique())","2ade3f46":"data_sem_vazios[\"Urine - Aspect\"]= data_sem_vazios[\"Urine - Aspect\"].replace(\"clear\", 0).replace(\"cloudy\", 1).replace(\"altered_coloring\", 2).replace(\"lightly_cloudy\", 3)\n\ndata_sem_vazios[\"Urine - Crystals\"]= data_sem_vazios[\"Urine - Crystals\"].replace(\"Ausentes\", 0).replace(\"Urato Amorfo --+\", 1).replace(\"Oxalato de C\u00e1lcio +++\", 2).replace(\"Oxalato de C\u00e1lcio -++\", 3).replace(\"Urato Amorfo +++\", 4)\n\ndata_sem_vazios[\"Urine - Color\"]= data_sem_vazios[\"Urine - Color\"].replace(\"light_yellow\", 0).replace(\"yellow\", 1).replace(\"orange\", 2).replace(\"citrus_yellow\", 3)","c2cde4fc":"# Vari\u00e1veis categ\u00f3ricas mas que apenas precisa transformar em int\n\nprint(\"Urine - pH\", data_sem_vazios[\"Urine - pH\"].unique())\nprint(\"Urine - Leukocytes\", data_sem_vazios[\"Urine - Leukocytes\"].unique())","16e68f0a":"data_sem_vazios[\"Urine - pH\"]= data_sem_vazios[\"Urine - pH\"].replace(\"N\u00e3o Realizado\", -10)\ndata_sem_vazios[\"Urine - pH\"] = data_sem_vazios[\"Urine - pH\"].astype(float)\n\ndata_sem_vazios[\"Urine - Leukocytes\"]= data_sem_vazios[\"Urine - Leukocytes\"].replace(\"<1000\", 0)\ndata_sem_vazios[\"Urine - Leukocytes\"] = data_sem_vazios[\"Urine - Leukocytes\"].astype(float)","0482138a":"# Vamos criar uma base de dados espec\u00edfica para rodar a tarefa 1:\ndata_tarefa1 = data_sem_vazios.copy()","993821fe":"data_tarefa1","84d5c40c":"# Vamos atribuir \u00e0 vari\u00e1vel explicada -100 quando a pessoa n\u00e3o testar positivo para Covid e 100 quando for positivo.\ndata_tarefa1[\"SARS-Cov-2 exam result\"]= data_tarefa1[\"SARS-Cov-2 exam result\"].replace(0, -100).replace(1, 100)\ndata_tarefa1[\"SARS-Cov-2 exam result\"].describe()","62f9e602":"# Deletar colunas desnecess\u00e1rias:\ndel data_tarefa1[\"Patient addmited to regular ward (1=yes, 0=no)\"]\ndel data_tarefa1[\"Patient addmited to semi-intensive unit (1=yes, 0=no)\"]\ndel data_tarefa1[\"Patient addmited to intensive care unit (1=yes, 0=no)\"]","82f4a70d":"# Agora precisamos levar a coluna da vari\u00e1vel explicada para a \u00faltima posi\u00e7\u00e3o da direita, pois \u00e9 assim que o programa recebe. \n# Criamos uma fun\u00e7\u00e3o para fazer isso:\ndef movecol(df, cols_to_move=[], ref_col='', place='After'):\n    \n    cols = df.columns.tolist()\n    if place == 'After':\n        seg1 = cols[:list(cols).index(ref_col) + 1]\n        seg2 = cols_to_move\n    if place == 'Before':\n        seg1 = cols[:list(cols).index(ref_col)]\n        seg2 = cols_to_move + [ref_col]\n    \n    seg1 = [i for i in seg1 if i not in seg2]\n    seg3 = [i for i in cols if i not in seg1 + seg2]\n    \n    return(df[seg1 + seg2 + seg3])","b3f16e5a":"# E com base na fun\u00e7\u00e3o definida anteriormente vamos mandar a coluna que quermos para depois da \u00faltima coluna, que no caso \u00e9: ctO2 (arterial blood gas analysis)\ndata_tarefa1 = movecol(data_tarefa1, \n             cols_to_move=[\"SARS-Cov-2 exam result\"], \n             ref_col='ctO2 (arterial blood gas analysis)',\n             place='After')","65fdd6b6":"# Reiniciano \u00edndices\ndata_tarefa1 = data_tarefa1.reset_index(drop=True)\ndata_tarefa1","c0028c52":"# Vamos criar uma base de dados espec\u00edfica para rodar a tarefa 2:\ndata_tarefa2_aux = data_sem_vazios.copy()","9c4f4e29":"# Vamos criar a coluna de resultados baseado na regra: se foi admitido apenas no ambulat\u00f3rio: -100. Se foi admitido em qualquer UTI: 100.\ndata_tarefa2_aux[\"admission_result\"] = data_tarefa2_aux[\"Patient addmited to semi-intensive unit (1=yes, 0=no)\"] +  data_tarefa2_aux[\"Patient addmited to intensive care unit (1=yes, 0=no)\"] - (100*(data_tarefa2_aux[\"Patient addmited to regular ward (1=yes, 0=no)\"]))\n\ndata_tarefa2_aux[\"admission_result\"]= data_tarefa2_aux[\"admission_result\"].replace(1, 100)","b52956b0":"# Vamos desconsiderar as linhas em que o paciente n\u00e3o foi nem para ambulat\u00f3rio nem para UTI.\ndata_tarefa2 = (data_tarefa2_aux.loc[data_tarefa2_aux['admission_result'] != 0]).copy()","33071267":"data_tarefa2","e814cf2d":"# Deletar colunas desnecess\u00e1rias:\ndel data_tarefa2[\"SARS-Cov-2 exam result\"]\ndel data_tarefa2[\"Patient addmited to regular ward (1=yes, 0=no)\"]\ndel data_tarefa2[\"Patient addmited to semi-intensive unit (1=yes, 0=no)\"]\ndel data_tarefa2[\"Patient addmited to intensive care unit (1=yes, 0=no)\"]","ec29c8fe":"# Reiniciano \u00edndices\ndata_tarefa2 = data_tarefa2.reset_index(drop=True)\ndata_tarefa2","35ae93c0":"[B, valores, vector_solucao, soma_vector_C] = svm(data_tarefa1)","d1764e98":"# Verifica\u00e7\u00e3o apenas dos valores do banco de dados que foi gerada a colu\u00e7\u00e3o\npd.DataFrame(valores)","a6e14a01":"print(\"Coeficientes de Ajuste\")\npd.DataFrame(vector_solucao)","fdc890d7":"# soma_vector_C = Coeficiente linear da Solu\u00e7\u00e3o do modelo\nprint(\"Coeficiente Linear\", soma_vector_C)","d4ebb6d3":"# Greando vetor solu\u00e7\u00f5es\ny_teo = np.zeros(len(B))\nfor i in range(0, valores.shape[0], 1):\n    y_teo[i] = np.matmul(valores[i], vector_solucao) + soma_vector_C\n    # Podemos usar este trecho para dizer que qualquer coisa positiva \u00e9 um tipo de solu\u00e7\u00e3o, e negativo, outro tipo. \n    y_teo = np.where(y_teo > 0, 100, -100)\n\n\nvetor_sol_tarefa1 = pd.DataFrame(y_teo)\nvetor_sol_tarefa1","cea5982b":"data_tarefa1.to_excel(\"resultado_tarefa1.xlsx\")\nvetor_sol_tarefa1.to_excel(\"vetor_sol_tarefa1.xlsx\")","1c896b8a":"[B, valores, vector_solucao, soma_vector_C] = svm(data_tarefa2)","4eddf207":"# Verifica\u00e7\u00e3o apenas dos valores do banco de dados que foi gerada a colu\u00e7\u00e3o\npd.DataFrame(valores)","c942f6b4":"print(\"Coeficientes de Ajuste\")\npd.DataFrame(vector_solucao)","32f514d0":"# soma_vector_C = Coeficiente linear da Solu\u00e7\u00e3o do modelo\nprint(\"Coeficiente Linear\", soma_vector_C)","5f6aeb05":"# Greando vetor solu\u00e7\u00f5es\ny_teo = np.zeros(len(B))\nfor i in range(0, valores.shape[0], 1):\n    y_teo[i] = np.matmul(valores[i], vector_solucao) + soma_vector_C\n    # Podemos usar este trecho para dizer que qualquer coisa positiva \u00e9 um tipo de solu\u00e7\u00e3o, e negativo, outro tipo. \n    y_teo = np.where(y_teo > 0, 100, -100)\n\n\nvetor_sol_tarefa2 = pd.DataFrame(y_teo)\nvetor_sol_tarefa2","2d90679e":"data_tarefa2.to_excel(\"resultado_tarefa2.xlsx\")\nvetor_sol_tarefa2.to_excel(\"vetor_sol_tarefa2.xlsx\")","9b6799b0":"## 2) Importando banco de dados","46ccd4f6":"## Resultados Tarefa 1\nComparando o vetor de solu\u00e7\u00f5es para a tarefa 1 com os resultados observados no banco original, vemos que o modelo acertou 435 dos 507 resultados. \u00cdndice de acerto de 85.7%.","fe562570":"<span style='color:Red ; font-size: 150%'>IMPORTANTE\n\n* Tarefa 1: Para esta tarefa vamos usar como vari\u00e1vel a ser explicada a coluna **SARS-Cov-2 exam result**. As vari\u00e1veis explicativas ser\u00e3o as demais, exceto aquelas que possuem todos os valores vazios ou as que indicam para onde o paciente foi encaminhado.\n\n* Tarefa 2: O modelo usado neste desafio \u00e9 o Support Vector Machine. Este modelo funciona bem para prever vari\u00e1veis bin\u00e1rias. Portanto, para a vari\u00e1vel a ser explicada, vamos criar a vari\u00e1vel **admission_result** que considera apenas duas categorias: Encaminhado para o ambulat\u00f3rio ou encaminhado para UTI, seja Semi ou n\u00e3o. Essa agrega\u00e7\u00e3o ser\u00e1 importante para usarmos este modelo, por\u00e9m gera um resultado que \u00e9 diferente do que foi proposto no desafio.","b402cbb1":"### 6.1 Chamada do modelo SVM","b538051e":"## Sobre o modelo que ser\u00e1 usado: Support Vector Machine","8eec363f":"<span style='color:Red ; font-size: 250%'> Modelo SVM feito na m\u00e3o  <\/span> \n#### AUTOR: [Rafael Klanfer Nunes](https:\/\/www.linkedin.com\/in\/rafaelknunes\/)\n\nEste trabalho foi baseado nos cursos de big data do professor Aguinaldo Prandini Ricieri e do curso de python 2 do professor \u00c9den. Deixo minha gratid\u00e3o pelos ensinamentos e recomendo a todos os cursos do instituto Prandiano, refer\u00eancia em ci\u00eancia de dados no Brasil.\n\n[Link para o curso](https:\/\/www.prandiano.com.br\/bigdata)","ea1cbeaf":"### 3.3) Conclus\u00e3o da an\u00e1lise inicial\n\n* Os valores num\u00e9ricos foram normalizados. O ideal para este modelo seria termos os valores reais, de tal forma que pudessem ser transformados em vari\u00e1veis qualitativas.\n\n* Onde houver valores vazios, not_done ou n\u00e3o realizado, vamos assumir que o teste n\u00e3o foi realizado. Vamos atribuir o valor -10 nestes casos.\n\n* Existem algumas vari\u00e1veis que assumme o valor: \"not_done\", ou \"n\u00e3o realizado\". Nestes casos vamos considerar como se o teste n\u00e3o foi realizado, ou seja, campo vazio.\n\n* A vari\u00e1vel \"Urine - Leukocytes\" \u00e9 categ\u00f3rica por\u00e9m seus valores s\u00e3o num\u00e9ricos. Para resolver isto, vamos atribuir ao valor <1000 o valor 0.\n\n* Muitas vari\u00e1veis categ\u00f3ricas representam testes que deram \"negativo\/normal\/absent\", ou \"positivo\/present\/detected\". Como regra atribu\u00edmos o valor 0 quando for negativo, e 1 quando for positivo.\n\n* A vari\u00e1vel \"Urine - Aspect\" assume mais do que dois valores: ['clear', 'cloudy', 'altered_coloring', 'lightly_cloudy']. Nestes casos vamos atribuir um n\u00famero inteiro para cada categoria.","bec64865":"#### 5.1) Base de dados da tarefa 1: data_tarefa1 | Vari\u00e1vel explicada: SARS-Cov-2 exam result","ee761b45":"### TAREFA 2: Predict admission to general ward, semi-intensive unit or intensive care unit\n\n* Enunciado: Based on the results of laboratory tests commonly collected among confirmed COVID-19 cases during a visit to the emergency room, would it be possible to predict which patients will need to be admitted to a general ward, semi-intensive unit or intensive care unit?\n\n* Coment\u00e1rios: Para esta tarefa a vari\u00e1vel a ser prevista \u00e9 aquela que indica para onde o paciente foi encaminhado. Ambulat\u00f3rio, UTI Semi ou UTI.","f0707214":"## 7. SVM - Aplica\u00e7\u00e3o tarefa 2","13ca83f6":"### 3.1) An\u00e1lise de valores vazios (NaN)","efc3f42d":"## Resultados Tarefa 2\nComparando o vetor de solu\u00e7\u00f5es para a tarefa 1 com os resultados observados no banco original, vemos que o modelo acertou 75 dos 128 resultados. \u00cdndice de acerto de 58.7%.","4b40d599":"---","7a012a36":"### 7.1 Chamada do modelo SVM","c6d2b181":"## Sobre as tarefas","673c62e0":"### TAREFA 1: Predict confirmed COVID-19 cases among suspected cases\n\n* Enunciado: Based on the results of laboratory tests commonly collected for a suspected COVID-19 case during a visit to the emergency room, would it be possible to predict the test result for SARS-Cov-2 (positive\/negative)?\n\n* Coment\u00e1rios: Para esta tarefa a vari\u00e1vel a ser prevista \u00e9 o resultado do exame para SARS-Cov-2. As vari\u00e1veis explicativas s\u00e3o os testes realizados no laborat\u00f3rio.","e2a139fe":"---","da6840c1":"---","9c5aa2e9":"---","51176920":"#### Coment\u00e1rio sobre vazios\n\nVerificamos que dos 5644 pacientes, apenas 507 possuiam ao menos 20 dos 100 testes laboratoriais realizados. Portanto foram descartadas os demais pacientes.\n\nEm rela\u00e7\u00e3o \u00e0s colunas vazias, as seguintes estavam completamente vazias e portanto foram descartadas:\n\n* 'Mycoplasma pneumoniae'\n* 'Urine - Sugar'\n* 'Partial thromboplastin time (PTT) 2100'\n* 'Prothrombin time (PT), Activity'\n* 'D-Dimer'","41c01409":"---","e1033eda":"---","7f5e7308":"### 3.2) An\u00e1lise de vari\u00e1veis categ\u00f3ricas","9b73f616":"## 1) Importando pacotes","2417c153":"#### 4.5) Criar sistema num\u00e9rico para vari\u00e1veis qualitativas.\n\nMuitas vari\u00e1veis categ\u00f3ricas representam testes que deram \"negativo\/normal\/absent\", ou \"positivo\/present\/detected\". Como regra atribu\u00edmos o valor 0 quando for negativo, e 1 quando for positivo.","d4f2e37a":"## 6. SVM - Aplica\u00e7\u00e3o tarefa 1","67e7a157":"#### 4.4) Remover colunas desnecess\u00e1rias.","703c3f80":"---","cc40e230":"## 5 Preparar as bases de dados finais para cada tarefa","f0e32132":"#### 4.3) Transformar vazios (NaN) em valores num\u00e9ricos.","6e1bef25":"#### 4.2) Eliminar linhas vazias.","1b8c1c48":"#### 4.1) Eliminar colunas vazias.","ae977350":"---","d267e8be":"## 4) Prepara\u00e7\u00e3o do banco de dados baseado na an\u00e1lise inicial. Para uso nas tarefas.\n\n* Transfomar valores iguais a \"not_done\" e \"N\u00e3o realizado\" em vazios. \n\n* Eliminar colunas vazias.\n\n* Eliminar linhas vazias.\n\n* Transformar vazios (NaN) em valores num\u00e9ricos.\n\n* Remover colunas desnecess\u00e1rias.\n\n* Criar sistema num\u00e9rico para vari\u00e1veis qualitativas.\n\n* Preparar as duas vari\u00e1veis a serem previstas pelo modelo. Na tarefa 1 teremos *SARS-Cov-2 exam result* e na tarefa 2 teremos *admission_result*.\n\n* Vari\u00e1veis est\u00e3o todas normalizadas. Seria interessante tranformar em qualitativas. Acima de 1 DP ent\u00e3o 1, 2 ent\u00e3o 2, etc.","7ab67392":"## 3) An\u00e1lise incial do banco de dados","96d91f5a":"#### 5.2) Base de dados da tarefa 2: data_tarefa2\n\nComo muitos casos n\u00e3o levou nem a ambulat\u00f3rio nem a UTI, ficamos apenas com 89 li\u00e7\u00f5es para treinar o modelo."}}