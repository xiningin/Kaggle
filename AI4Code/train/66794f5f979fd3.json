{"cell_type":{"658aba5c":"code","726a5fce":"code","f02d85e9":"code","8a15579d":"code","6c860c49":"code","fe5bc9f4":"code","1106bd47":"markdown","3d3410f4":"markdown","e3201d72":"markdown"},"source":{"658aba5c":"from IPython.core.display import display, HTML\n\nimport pandas as pd\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport glob\nimport os\nimport gc\n\nfrom joblib import Parallel, delayed\n\nfrom sklearn import preprocessing, model_selection\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.metrics import r2_score\n\nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport numpy.matlib\nfrom sklearn.cluster import KMeans\nfrom scipy import stats\nfrom tqdm import tqdm\nimport copy\n\npath_submissions = '\/'\n\ntarget_name = 'target'\nscores_folds = {}","726a5fce":"# data directory\ndata_dir = '..\/input\/optiver-realized-volatility-prediction\/'\n# Function to calculate first WAP\ndef calc_wap1(df):\n    wap = (df['bid_price1'] * df['ask_size1'] + df['ask_price1'] * df['bid_size1']) \/ (df['bid_size1'] + df['ask_size1'])\n    return wap\n\n# Function to calculate second WAP\ndef calc_wap2(df):\n    wap = (df['bid_price2'] * df['ask_size2'] + df['ask_price2'] * df['bid_size2']) \/ (df['bid_size2'] + df['ask_size2'])\n    return wap\n\ndef calc_wap3(df):\n    wap = (df['bid_price1'] * df['bid_size1'] + df['ask_price1'] * df['ask_size1']) \/ (df['bid_size1'] + df['ask_size1'])\n    return wap\n\ndef calc_wap4(df):\n    wap = (df['bid_price2'] * df['bid_size2'] + df['ask_price2'] * df['ask_size2']) \/ (df['bid_size2'] + df['ask_size2'])\n    return wap\n\n\n# Function to calculate the log of the return\n# Remember that logb(x \/ y) = logb(x) - logb(y)\ndef log_return(series):\n    return np.log(series).diff()\n\n# Calculate the realized volatility\ndef realized_volatility(series):\n    return np.sqrt(np.sum(series**2))\n\ndef realized_volatility_10_90(series):\n    x = np.sort(series)\n    siz = len(x)\n    x = x[int(siz*0.10):int(siz*0.90)]\n    return np.sqrt(np.sum(x**2))\n\ndef realized_volatility_90(series):\n    x = np.sort(series)\n    x = x[~numpy.isnan(x)]\n    siz = len(x)\n    x = x[int(siz*0.90):]\n    return np.sqrt(np.sum(x**2))\n\ndef realized_volatility_10(series):\n    x = np.sort(series)\n    siz = len(x)\n    x = x[:int(siz*0.10)]\n    return np.sqrt(np.sum(x**2))\n\ndef realized_volatility_qt(series):\n    series = series[~numpy.isnan(series)].values.reshape(1, -1)\n    qt = QuantileTransformer(random_state=21,n_quantiles=2000, output_distribution='normal')\n    series = qt.fit_transform(series)    \n    return np.sqrt(np.sum(series**2))\n\ndef realized_volatility_25(series):\n    x = np.sort(series)\n    x = x[~numpy.isnan(x)]\n    siz = len(x)\n    x = x[:int(siz*0.25)]\n    return np.sqrt(np.sum(x**2))\n\n# Function to count unique elements of a series\ndef count_unique(series):\n    return len(np.unique(series))\n\ndef time_return(series):\n    return ( np.abs(series.diff()) )\n\ndef kurtosis2(x):\n    return(stats.kurtosis(x,nan_policy='omit'))\n\n# interquartile\ndef iqr_p_v(x):\n    return (np.percentile( x,75) - np.percentile(x,25) )\n\n# signal energy\ndef energy (series):\n    return( np.mean(series**2) )\n\ndef rfil(x):\n    \n    if numpy.isnan(x.iat[0]):        \n        return (np.log(x.iat[-1]\/x.iat[1])**2)\n    else:\n        return (np.log(x.iat[-1]\/x.iat[0])**2)\n    \ndef rmnl(x):\n    return np.log((np.max(x)\/np.min(x))**2)\n\n# Adverse retrun\ndef adverse_volatility(series):\n    v = np.array([x for x in series if x < 0])\n    return np.sqrt(np.sum(v**2))\n\ndef outliers(series):\n    std = np.std(series)\n    mean = np.mean(series)\n    v = np.array([x for x in series if abs(x) > (mean+3*(std)) ])\n    return len(v)\/np.float(len(series))\n\ndef realized_volatility_abs(series):\n    return (np.sum(np.abs(series)))\n\n\n#https:\/\/www.kaggle.com\/cldavies\/single-value-baseline\ndef single_prediction(series):\n    series = series[~numpy.isnan(series)]\n    series = series[ series != 0]\n    inverse_target = 1 \/ np.abs(series)\n    single_prediction = np.sum(inverse_target) \/  np.sum(np.square(inverse_target))\n    return single_prediction\n\n\n# Function to read our base train and test set\ndef read_train_test():\n    train = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/train.csv')\n    test = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/test.csv')\n    # Create a key to merge with book and trade data\n    train['row_id'] = train['stock_id'].astype(str) + '-' + train['time_id'].astype(str)\n    test['row_id'] = test['stock_id'].astype(str) + '-' + test['time_id'].astype(str)\n    print(f'Our training set has {train.shape[0]} rows')\n    return train, test\n\n# Function to preprocess book data (for each stock id)\ndef book_preprocessor(file_path):\n    df = pd.read_parquet(file_path)\n    # Calculate Wap\n    df['wap1'] = calc_wap1(df)\n    df['wap2'] = calc_wap2(df)\n    df['wap3'] = calc_wap3(df)\n    df['wap4'] = calc_wap4(df)\n    # Calculate log returns\n    df['log_return1'] = df.groupby(['time_id'])['wap1'].apply(log_return)\n    df['log_return2'] = df.groupby(['time_id'])['wap2'].apply(log_return)\n    df['log_return3'] = df.groupby(['time_id'])['wap3'].apply(log_return)\n    df['log_return4'] = df.groupby(['time_id'])['wap4'].apply(log_return)\n    \n    # Calculate wap balance\n    df['wap_balance'] = abs(df['wap1'] - df['wap2'])\n    # Calculate spread\n    df['price_spread'] = (df['ask_price1'] - df['bid_price1']) \/ ((df['ask_price1'] + df['bid_price1']) \/ 2)\n    df['price_spread2'] = (df['ask_price2'] - df['bid_price2']) \/ ((df['ask_price2'] + df['bid_price2']) \/ 2)\n    df['bid_spread'] = df['bid_price1'] - df['bid_price2']\n    df['ask_spread'] = df['ask_price1'] - df['ask_price2']\n    df[\"bid_ask_spread\"] = abs(df['bid_spread'] - df['ask_spread'])\n    df['total_volume'] = (df['ask_size1'] + df['ask_size2']) + (df['bid_size1'] + df['bid_size2'])\n    df['volume_imbalance'] = abs((df['ask_size1'] + df['ask_size2']) - (df['bid_size1'] + df['bid_size2']))\n    \n    # Dict for aggregations\n    create_feature_dict = {\n        'wap1': [np.sum, np.std, rfil,rmnl],\n        'wap2': [np.sum, np.std],\n         'wap3': [np.sum, np.std],\n        'wap4': [np.sum, np.std],\n        'log_return1':  [single_prediction,realized_volatility,outliers,np.std,kurtosis2,realized_volatility_25],\n        'log_return2':  [realized_volatility_abs],\n        'log_return3':  [adverse_volatility],\n        'log_return4': [outliers],\n        'wap_balance':  [np.sum, np.max, np.std],\n        'price_spread': [np.sum, np.max, np.std],\n        'price_spread2':[np.sum, np.max, np.std,stats.median_abs_deviation],\n        'bid_spread':   [np.sum, np.max, np.std],\n        'ask_spread':   [np.sum, np.max, np.std],\n        'total_volume': [np.sum, np.max, np.std],\n        'volume_imbalance':[np.sum, np.max, np.std],\n        \"bid_ask_spread\":[np.sum, np.max, np.std],\n    }\n    \n    create_feature_dict_time = {\n        'log_return1': [realized_volatility],\n        'log_return2': [realized_volatility_abs],\n        'log_return3': [adverse_volatility],\n        'log_return4': [outliers],\n    }\n        \n    # Function to get group stats for different windows (seconds in bucket)\n    def get_stats_window(fe_dict,seconds_in_bucket, add_suffix = False):\n        # Group by the window\n        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(fe_dict).reset_index()\n        # Rename columns joining suffix\n        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n        # Add a suffix to differentiate windows\n        if add_suffix:\n            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n        return df_feature\n    \n    # Get the stats for different windows\n    df_feature = get_stats_window(create_feature_dict,seconds_in_bucket = 0, add_suffix = False)\n    df_feature_450 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 450, add_suffix = True)\n    df_feature_300 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 300, add_suffix = True)\n    df_feature_150 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 150, add_suffix = True)\n\n    # Merge all\n    df_feature = df_feature.merge(df_feature_450, how = 'left', left_on = 'time_id_', right_on = 'time_id__450')\n    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n    df_feature = df_feature.merge(df_feature_150, how = 'left', left_on = 'time_id_', right_on = 'time_id__150')\n    # Drop unnecesary time_ids\n    df_feature.drop(['time_id__450', 'time_id__300', 'time_id__150'], axis = 1, inplace = True)\n    \n    \n    # Create row_id so we can merge\n    stock_id = file_path.split('=')[1]\n    df_feature['row_id'] = df_feature['time_id_'].apply(lambda x: f'{stock_id}-{x}')\n    df_feature.drop(['time_id_'], axis = 1, inplace = True)\n    return df_feature\n\n# Function to preprocess trade data (for each stock id)\ndef trade_preprocessor(file_path):\n    df = pd.read_parquet(file_path)\n    df['log_return'] = df.groupby('time_id')['price'].apply(log_return)\n    df['time_return'] = df.groupby('time_id')['seconds_in_bucket'].apply(time_return) \n    df['amount']=df['price']*df['size']\n    \n    # Dict for aggregations\n    create_feature_dict = {\n        'price': [iqr_p_v,rfil,rmnl],\n        'log_return':[realized_volatility,kurtosis2],\n        'seconds_in_bucket':[count_unique],\n        'size':[np.sum, np.std, np.max, np.min,energy,iqr_p_v],\n        'order_count':[np.sum,np.max],\n        'time_return':[np.sum,np.max],\n        'amount':[np.sum,np.max,np.min],\n    }\n    \n\n    create_feature_dict_time = {\n        'log_return':[realized_volatility,outliers],\n        'seconds_in_bucket':[count_unique],\n        'size':[np.sum],\n        'order_count':[np.sum],\n    }\n    \n    # Function to get group stats for different windows (seconds in bucket)\n    def get_stats_window(fe_dict,seconds_in_bucket, add_suffix = False):\n        # Group by the window\n        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(fe_dict).reset_index()\n        # Rename columns joining suffix\n        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n        # Add a suffix to differentiate windows\n        if add_suffix:\n            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n        return df_feature\n    \n\n    # Get the stats for different windows\n    df_feature = get_stats_window(create_feature_dict,seconds_in_bucket = 0, add_suffix = False)\n    df_feature_450 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 450, add_suffix = True)\n    df_feature_300 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 300, add_suffix = True)\n    df_feature_150 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 150, add_suffix = True)\n    \n\n    \n    # Merge all\n    df_feature = df_feature.merge(df_feature_450, how = 'left', left_on = 'time_id_', right_on = 'time_id__450')\n    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n    df_feature = df_feature.merge(df_feature_150, how = 'left', left_on = 'time_id_', right_on = 'time_id__150')\n    # Drop unnecesary time_ids\n    df_feature.drop(['time_id__450', 'time_id__300', 'time_id__150'], axis = 1, inplace = True)\n    \n    \n    \n    df_feature = df_feature.add_prefix('trade_')\n    stock_id = file_path.split('=')[1]\n    df_feature['row_id'] = df_feature['trade_time_id_'].apply(lambda x:f'{stock_id}-{x}')\n    df_feature.drop(['trade_time_id_'], axis = 1, inplace = True)\n    return df_feature\n\n# Function to get group stats for the stock_id and time_id\ndef get_time_stock(df):\n    # Get realized volatility columns\n    vol_cols = ['log_return1_realized_volatility', 'log_return2_realized_volatility_abs', \n                'log_return1_realized_volatility_450', 'log_return2_realized_volatility_abs_450', \n                'log_return1_realized_volatility_300', 'log_return2_realized_volatility_abs_300', \n                'log_return1_realized_volatility_150', 'log_return2_realized_volatility_abs_150', \n                'trade_log_return_realized_volatility', 'trade_log_return_realized_volatility_450',\n                'trade_log_return_realized_volatility_300', 'trade_log_return_realized_volatility_150',\n                'wap1_rfil','wap1_rmnl','log_return1_realized_volatility_25','log_return1_outliers']\n\n\n    # Group by the stock id\n    df_stock_id = df.groupby(['stock_id'])[vol_cols].agg(['mean', 'std', 'max', 'min', ]).reset_index()\n    # Rename columns joining suffix\n    df_stock_id.columns = ['_'.join(col) for col in df_stock_id.columns]\n    df_stock_id = df_stock_id.add_suffix('_' + 'stock')\n\n    # Group by the stock id\n    df_time_id = df.groupby(['time_id'])[vol_cols].agg(['mean', 'std', 'max', 'min', ]).reset_index()\n    # Rename columns joining suffix\n    df_time_id.columns = ['_'.join(col) for col in df_time_id.columns]\n    df_time_id = df_time_id.add_suffix('_' + 'time')\n    \n    # Merge with original dataframe\n    df = df.merge(df_stock_id, how = 'left', left_on = ['stock_id'], right_on = ['stock_id__stock'])\n    df = df.merge(df_time_id, how = 'left', left_on = ['time_id'], right_on = ['time_id__time'])\n    df.drop(['stock_id__stock', 'time_id__time'], axis = 1, inplace = True)\n    return df\n    \n# Funtion to make preprocessing function in parallel (for each stock id)\ndef preprocessor(list_stock_ids, is_train = True):\n    \n    # Parrallel for loop\n    def for_joblib(stock_id):\n        # Train\n        if is_train:\n            file_path_book = data_dir + \"book_train.parquet\/stock_id=\" + str(stock_id)\n            file_path_trade = data_dir + \"trade_train.parquet\/stock_id=\" + str(stock_id)\n        # Test\n        else:\n            file_path_book = data_dir + \"book_test.parquet\/stock_id=\" + str(stock_id)\n            file_path_trade = data_dir + \"trade_test.parquet\/stock_id=\" + str(stock_id)\n    \n        # Preprocess book and trade data and merge them\n        df_tmp = pd.merge(book_preprocessor(file_path_book), trade_preprocessor(file_path_trade), on = 'row_id', how = 'left')\n        \n        # Return the merge dataframe\n        return df_tmp\n    \n    # Use parallel api to call paralle for loop\n    df = Parallel(n_jobs = -1, verbose = 1)(delayed(for_joblib)(stock_id) for stock_id in tqdm(list_stock_ids))\n    # Concatenate all the dataframes that return from Parallel\n    df = pd.concat(df, ignore_index = True)\n    return df\n\n# Function to calculate the root mean squared percentage error\ndef rmspe(y_true, y_pred):\n    return np.sqrt(np.mean(np.square((y_true - y_pred) \/ y_true)))\n\n# Function to early stop with root mean squared percentage error\ndef feval_rmspe(y_pred, lgb_train):\n    y_true = lgb_train.get_label()\n    return 'RMSPE', rmspe(y_true, y_pred), False","f02d85e9":"# Read train and test\ntrain, test = read_train_test()\n# Get unique stock ids \ntrain_stock_ids = train['stock_id'].unique()\n# Preprocess them using Parallel and our single stock id functions\ntrain_ = preprocessor(train_stock_ids, is_train = True)\ntrain = train.merge(train_, on = ['row_id'], how = 'left')","8a15579d":"train = get_time_stock(train)","6c860c49":"# replace by order sum (tau)\ntrain['size_tau2'] = np.sqrt( 1\/ train['trade_order_count_sum'] )\ntrain['rrr'] = train['log_return1_realized_volatility_25']\/train['log_return1_realized_volatility']","fe5bc9f4":"train.to_pickle('dataset_baseline_train_best_v3.pkl')","1106bd47":"## Train and test datasets","3d3410f4":"## version 1 datasets\n\ncopied from -- https:\/\/www.kaggle.com\/lucasmorin\/tf-keras-nn-with-stock-embedding\n","e3201d72":"## First version dataset creation"}}