{"cell_type":{"f9341e64":"code","b5ed500f":"code","0388ab75":"code","3df89474":"code","2148de6c":"code","f5a0222b":"code","0fec3bb6":"code","27260c22":"code","e04996b0":"code","544d9a1c":"code","f3ec789d":"code","4b31be80":"code","aec2da2d":"code","ee62cf53":"code","1f7cffe5":"code","5a193b46":"code","f79e7b9a":"code","7c42e326":"code","a21e4084":"code","a8b916d7":"code","bc988598":"code","b8405288":"code","75bdb430":"code","264c82d5":"code","0a0562ad":"code","6a45eed0":"code","73cea6bc":"code","4c92a84e":"code","fa0f274b":"markdown"},"source":{"f9341e64":"import pickle\nimport numpy as np\nimport pandas as pd\nfrom collections import Counter\nimport matplotlib.pyplot as plt\nfrom sklearn.utils import shuffle\nimport tensorflow as tf\nfrom tensorflow.python.framework import ops\nimport math","b5ed500f":"tf.compat.v1.disable_eager_execution()","0388ab75":"ratings_df = pd.read_csv('..\/input\/the-movies-dataset\/ratings_small.csv')","3df89474":"n_ratings, _ = ratings_df.shape\nprint(ratings_df.head())\nprint(ratings_df.tail())\nprint(n_ratings)","2148de6c":"train_size = int(0.8*n_ratings)\nshuffled_indexes = shuffle(range(n_ratings))\ndf = ratings_df.iloc[shuffled_indexes[:train_size]]\ntest_df = ratings_df.iloc[shuffled_indexes[train_size:]]","f5a0222b":"print(df.shape)\nprint(test_df.shape)","0fec3bb6":"df_flag = df.pivot(index='movieId', columns='userId', values='rating').isna()==False","27260c22":"df_flag = df_flag.values","e04996b0":"col_names = df.pivot(index='movieId', columns='userId', values='rating').columns\nrow_names = df.pivot(index='movieId', columns='userId', values='rating').index","544d9a1c":"y_matrix = df.pivot(index='movieId', columns='userId', values='rating').fillna(0).values","f3ec789d":"n_movies, n_users = y_matrix.shape","4b31be80":"print(n_movies, n_users)","aec2da2d":"def create_placeholders(n_y):\n\n    ### START CODE HERE ### (approx. 2 lines)\n    Y = tf.compat.v1.placeholder(tf.float32,shape=(n_y, None), name='Y')    \n    Y_flag = tf.compat.v1.placeholder(tf.float32, shape=(n_y, None), name=\"Y_flag\")\n    ### END CODE HERE ###\n    \n    return Y, Y_flag","ee62cf53":"Y, Y_flag = create_placeholders(12288)\nprint (\"Y = \" + str(Y))\nprint (\"Y_flag = \" + str(Y_flag))","1f7cffe5":"def initialize_parameters(item, user):\n\n    tf.compat.v1.set_random_seed(1)                   # so that your \"random\" numbers match ours\n        \n    ### START CODE HERE ### (approx. 6 lines of code)\n    X_mat = tf.compat.v1.get_variable(\"X_mat\", [item, 100], initializer = tf.initializers.GlorotUniform(seed = 1))\n    theta_mat = tf.compat.v1.get_variable(\"theta_mat\", [100,user], initializer = tf.initializers.GlorotUniform(seed = 1))\n    ### END CODE HERE ###\n\n    parameters = {\"X_mat\": X_mat,\n                  \"theta_mat\": theta_mat}\n    \n    return parameters","5a193b46":"tf.compat.v1.reset_default_graph()\nwith tf.compat.v1.Session() as sess:\n    parameters = initialize_parameters(500, 600)\n    print(\"X_mat = \" + str(parameters[\"X_mat\"]))\n    print(\"theta_mat = \" + str(parameters[\"theta_mat\"]))","f79e7b9a":"def compute_cost(X, theta, Y, Y_flag):\n       \n    # to fit the tensorflow requirement for tf.nn.softmax_cross_entropy_with_logits(...,...)\n    \n    ### START CODE HERE ### (1 line of code)\n    cost = tf.reduce_sum(tf.multiply(0.5,tf.multiply(tf.math.squared_difference(tf.matmul(X, theta), Y),Y_flag)))\n    ### END CODE HERE ###\n    \n    return cost","7c42e326":"tf.compat.v1.reset_default_graph()\n\nwith tf.compat.v1.Session() as sess:\n    Y, Y_flag = create_placeholders(500)\n    parameters = initialize_parameters(500, 600)\n    cost = compute_cost(parameters[\"X_mat\"],parameters[\"theta_mat\"], Y, Y_flag)\n    print(\"cost = \" + str(cost))","a21e4084":"def random_mini_batches(Y_mat, Y_flag, mini_batch_size = 64, seed = 0):\n    \n    m = Y_mat.shape[1]                  # number of training examples\n    mini_batches = []\n    np.random.seed(seed)\n    \n    # Step 1: Shuffle (X, Y)\n    permutation = list(np.random.permutation(m))\n    shuffled_X = Y_mat[:, permutation]\n    shuffled_Y = Y_flag[:, permutation]\n\n    # Step 2: Partition (shuffled_X, shuffled_Y). Minus the end case.\n    num_complete_minibatches = math.floor(m\/mini_batch_size) # number of mini batches of size mini_batch_size in your partitionning\n    for k in range(0, num_complete_minibatches):\n        mini_batch_X = shuffled_X[:, k * mini_batch_size : k * mini_batch_size + mini_batch_size]\n        mini_batch_Y = shuffled_Y[:, k * mini_batch_size : k * mini_batch_size + mini_batch_size]\n        mini_batch = (mini_batch_X, mini_batch_Y)\n        mini_batches.append(mini_batch)\n    \n    # Handling the end case (last mini-batch < mini_batch_size)\n    if m % mini_batch_size != 0:\n        mini_batch_X = shuffled_X[:, num_complete_minibatches * mini_batch_size : m]\n        mini_batch_Y = shuffled_Y[:, num_complete_minibatches * mini_batch_size : m]\n        mini_batch = (mini_batch_X, mini_batch_Y)\n        mini_batches.append(mini_batch)\n    \n    return mini_batches","a8b916d7":"def model(Y_mat, flag, learning_rate = 0.001,\n          num_epochs = 1500, minibatch_size = 32, print_cost = True):\n    \n    ops.reset_default_graph()                         \n    tf.compat.v1.set_random_seed(1)                         \n    seed = 3                                          \n    (n_x, m) = Y_mat.shape                           \n    costs = []                                       \n    \n    Y, Y_flag = create_placeholders(n_x)\n    \n    parameters = initialize_parameters(n_x, m)\n    ### END CODE HERE ###\n        \n    cost = compute_cost(parameters[\"X_mat\"],parameters[\"theta_mat\"], Y, Y_flag)\n    \n    # Backpropagation: Define the tensorflow optimizer. Use an AdamOptimizer.\n    ### START CODE HERE ### (1 line)\n    optimizer = tf.compat.v1.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost)\n    ### END CODE HERE ###\n    \n    # Initialize all the variables\n    init = tf.compat.v1.global_variables_initializer()\n\n    # Start the session to compute the tensorflow graph\n    with tf.compat.v1.Session() as sess:\n        \n        # Run the initialization\n        sess.run(init)\n        \n        # Do the training loop\n        for epoch in range(num_epochs):\n\n            epoch_cost = 0.                      \n            num_minibatches = int(m \/ minibatch_size) \n            seed = seed + 1\n            minibatches = random_mini_batches(Y_mat, flag, minibatch_size, seed)\n\n            for minibatch in minibatches:\n\n                # Select a minibatch\n                (minibatch_X, minibatch_Y) = minibatch\n                \n               \n                _ , minibatch_cost = sess.run([optimizer, cost], feed_dict={Y: minibatch_X, Y_flag: minibatch_Y})\n              \n                epoch_cost += minibatch_cost \/ minibatch_size\n\n            # Print the cost every epoch\n            if print_cost == True and epoch % 100 == 0:\n                print (\"Cost after epoch %i: %f\" % (epoch, epoch_cost))\n            if print_cost == True and epoch % 5 == 0:\n                print(f\"epoch_cost: {epoch_cost:{10}}\")\n                costs.append(epoch_cost)\n                \n        # plot the cost\n        plt.plot(np.squeeze(costs))\n        plt.ylabel('cost')\n        plt.xlabel('iterations (per fives)')\n        plt.title(\"Learning rate =\" + str(learning_rate))\n        plt.show()\n\n        # lets save the parameters in a variable\n        parameters = sess.run(parameters)\n        print (\"Parameters have been trained!\")\n\n        \n        return parameters","bc988598":"parameters = model(y_matrix, df_flag, minibatch_size = 671, num_epochs = 150)","b8405288":"parameters","75bdb430":"results = np.dot(parameters[\"X_mat\"],parameters[\"theta_mat\"])","264c82d5":"results.shape","0a0562ad":"rating_filled = pd.DataFrame(np.dot(parameters[\"X_mat\"],parameters[\"theta_mat\"]), columns = col_names, index=row_names)","6a45eed0":"rating_filled.head()","73cea6bc":"rating_filled[212][3269]","4c92a84e":"df.tail(30)","fa0f274b":"#### import pandas as pd"}}