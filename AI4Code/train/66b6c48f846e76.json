{"cell_type":{"e410fdf4":"code","525d6b75":"code","e3fb94c3":"code","633126c5":"code","f9b52000":"code","4026d2af":"code","426d2edb":"code","19c989c7":"code","0ea43d49":"code","b640eefb":"code","5db7c2f0":"code","647e25e7":"code","22f70d85":"code","f3fc9965":"code","8b50da36":"code","366e6f24":"code","7b07515f":"code","b7699ffc":"code","f94b54b7":"code","294af726":"code","246a5127":"code","180f4d67":"code","a4c0e43a":"code","26f3c789":"code","72eaeac9":"code","33cc3b75":"code","e002acb6":"code","ca04b18b":"code","eefb3775":"code","dc570423":"code","fd6efa8e":"code","3f035b42":"code","2cceed4e":"code","4001fa14":"code","a1a9de47":"code","9ce92f6c":"code","beabc73a":"code","541e52fc":"code","37c5e4f5":"code","a0d7dddd":"code","d20ccee0":"code","c926ee10":"code","1425efea":"code","00425d31":"code","9bc9241b":"markdown","f71e5239":"markdown","0fdbb1dd":"markdown","20d386c9":"markdown","16f9a07d":"markdown","40d27b0d":"markdown","f98bdd83":"markdown","a2d8e78d":"markdown","c4f59a61":"markdown","ceaa372d":"markdown","591005c7":"markdown"},"source":{"e410fdf4":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport os\nfrom surprise import KNNWithMeans\nfrom surprise import Dataset,Reader\nfrom surprise.model_selection import train_test_split\nfrom collections import defaultdict\nfrom surprise import SVD\nfrom surprise import accuracy\nfrom scipy.sparse.linalg import svds\nimport copy","525d6b75":"# print(os.listdir(\"..\/input\"))","e3fb94c3":"user_rating_data = pd.read_csv('..\/input\/ratings_Electronics.csv')","633126c5":"user_rating_data.columns = ['UserID','ProductID','Ratings','Timestamp']","f9b52000":"user_rating_data.head()","4026d2af":"user_rating_data.hist()","426d2edb":"# Crate a subset of data with users who has given ratings more than 50 times\nusers_filter = user_rating_data['UserID'].value_counts()\nusersfilter_df = pd.DataFrame(users_filter).reset_index()\nusersfilter_df.columns = ['UserID','Count']\nusersfilter_df_IDs = usersfilter_df[usersfilter_df['Count'] > 100]['UserID']\nuser_rating_data_Subset = user_rating_data[user_rating_data['UserID'].isin(usersfilter_df_IDs)]\nuser_rating_data_Subset","19c989c7":"# Data can be more filtered  to have product which are atleast rated 10 times\n# products_filter = user_rating_data_Subset['ProductID'].value_counts()\n# products_filter_df = pd.DataFrame(products_filter).reset_index()\n# products_filter_df.columns = ['ProductID','Count']\n# products_filter_df_IDs = products_filter_df[products_filter_df['Count'] > 10]['ProductID']\n# user_product_rating_data_Subset = user_rating_data_Subset[user_rating_data_Subset['ProductID'].isin(products_filter_df_IDs)]\n# user_product_rating_data_Subset","0ea43d49":"user_rating_data_Subset.isna().sum()\n# user_product_rating_data_Subset.isna().sum()","b640eefb":"# group by data according to product and count of users gave ratings\ncountProductUsers = user_rating_data_Subset.groupby(['ProductID']).agg({'UserID': 'count'}).reset_index()\ncountProductUsers.columns = ['ProductID','UserID_Counts']\ncountProductUsers.head()","5db7c2f0":"# group by data according to product and avg rating users has given\navgProductRating = user_rating_data_Subset.groupby(['ProductID']).agg({'Ratings': 'mean'}).reset_index()\navgProductRating.columns = ['ProductID','AvgRating']\navgProductRating.head()","647e25e7":"product_rating_set = countProductUsers.merge(avgProductRating,on='ProductID')\nproduct_rating_set","22f70d85":"# Sorting data and get top results\nproduct_rating_set.sort_values([\"UserID_Counts\", \"AvgRating\"], ascending = (False, False)).head()\n# product_rating_set.sort_values([\"AvgRating\"], ascending = False).head(10)","f3fc9965":"# applying weightage to get hybrid popularity products to recommend\nw1 = 0.8\nw2 = 0.4\n\n# score = w1* v1 + w2 *v2 \/(w1 + w2)\nproduct_rating_set['Score'] = (w1*(product_rating_set['UserID_Counts']) + w2*(product_rating_set['AvgRating']))\/(w1+w2)\n","8b50da36":"product_rating_set.sort_values('Score',ascending = False).head()","366e6f24":"# Apply KNNwith means algo to get recommendation based on neighbours","7b07515f":"reader = Reader(rating_scale=(0,5))\ndata = Dataset.load_from_df(user_rating_data_Subset[['UserID','ProductID','Ratings']],reader)\ntrainset,testset = train_test_split(data, test_size=.3)\ntrainset.ur","b7699ffc":"# Apply user user collabrative model\nalgo = KNNWithMeans(k=50,sim_options={'name':'pearson_baseline','user_based':True})\nalgo.fit(trainset)","f94b54b7":"test_predictions_KNN = algo.test(testset)","294af726":"test_predictions_KNN","246a5127":"# check prediction of one user who has not bought one perticula rproduct\nuser_rating_data_Subset.loc[(user_rating_data_Subset['UserID'] == 'A1V3TRGWOMA8LC') & ( user_rating_data_Subset['ProductID'] == '0594481813')]\n# Product user A1V3TRGWOMA8LC have not bought 0594481813 yet \n","180f4d67":"pred = algo.predict('A1V3TRGWOMA8LC','0594481813',verbose=True)","a4c0e43a":"# We can see maximum users does not have neighbours or very less number of it in our predictions data\n# We can not recommend products on basis of thse less neighbou found data","26f3c789":"# Implmenting SVD algo","72eaeac9":"trainset_svd  = data.build_full_trainset()\nlen(trainset_svd.ur)","33cc3b75":"algo_svd = SVD()\nalgo_svd.fit(trainset_svd)","e002acb6":"# prepare test data set\ntestset_svd = trainset_svd.build_anti_testset()\nlen(testset_svd)","ca04b18b":"predictions_svd = algo_svd.test(testset_svd)","eefb3775":"predictions_svd","dc570423":"# valuate the model\n#Check for accuracy for collabrative model\nprint(\"User-based Model : Test Set\")\naccuracy.rmse(predictions_svd, verbose=True)","fd6efa8e":"top_n = defaultdict(list)\nfor uid, iid, true_r, est, _ in predictions_svd:\n        top_n[uid].append((iid,true_r,est,_))","3f035b42":"def get_top_n(predictions, n=10):\n    # First map the predictions to each user.\n    top_n = defaultdict(list)\n    for uid, iid, true_r, est, _ in predictions:\n        top_n[uid].append((iid, est))\n\n    # Then sort the predictions for each user and retrieve the n highest ones.\n    for uid, user_ratings in top_n.items():\n        user_ratings.sort(key=lambda x: x[1], reverse=True)\n        top_n[uid] = user_ratings[:n]\n\n    return top_n","2cceed4e":"top_n = get_top_n(predictions_svd, n=5)","4001fa14":"for uid, user_ratings in top_n.items():\n    print(uid, [iid for (iid, _) in user_ratings])","a1a9de47":"# predict for sample user\npred = algo_svd.predict('A1V3TRGWOMA8LC','B003ES5ZUU',verbose=True)","9ce92f6c":"# Implementing SVDs using matrix generation","beabc73a":"# Create pivot table\nuser_ratings_matrix = user_rating_data_Subset.pivot(index='UserID', columns='ProductID', values='Ratings')","541e52fc":"# fill with 0 for the combination which has not been bought\nuser_ratings_matrix.fillna(0,inplace=True)","37c5e4f5":"U,sigma,Vt = svds(user_ratings_matrix,k=50)","a0d7dddd":"sigma = np.diag(sigma)\nall_user_predicted_ratings = np.dot(np.dot(U, sigma), Vt) \npreds_df = pd.DataFrame(all_user_predicted_ratings, columns = user_ratings_matrix.columns)","d20ccee0":"preds_df.head()","c926ee10":"user_ratings_matrix.reset_index(inplace=True)\nuserid_col = user_ratings_matrix['UserID']\npred_df_col = preds_df.join(userid_col)","1425efea":"# 'A1V3TRGWOMA8LC',:'0594481813']\npred_df_col[pred_df_col['UserID'] == 'A1V3TRGWOMA8LC']['B003ES5ZUU']","00425d31":"# get top n recommendation using SVD matrix \n# get user and product data which user has not bought yet\n# merge predicted rating from the predicition matrix\n# \/sort and fetch top records\n\nuser_id = 'A1V3TRGWOMA8LC'\nuser_id_pred =  pred_df_col[pred_df_col['UserID'] == user_id].T\nuser_id_pred.reset_index(inplace =True)\nuser_id_pred.columns= ['ProductID','Ratings']\nuser_id_pred.drop(index =  len(user_id_pred) -1,inplace=True)\nuser_id_pred.sort_values(by='Ratings',ascending=False).head(5)","9bc9241b":"### Summary:\n1. Product B0088CJT4U is the most popular one to recommend to a new user (**among subset of data where users who has given ratings more than 100 times******)\n2. KNNwith means algorithm can not be used as our data set doesn't have users which are very similar to each other\n3. Using SVD algorithm we can say that model getting accuracy of RMSE 0.38 (considering the subset taken as users with more than 100 ratings)\n4. For user A1V3TRGWOMA8LC and product B003ES5ZUU is most recommended one\n","f71e5239":"Get top 5 Recommendation","0fdbb1dd":"Evaluate The Model","20d386c9":"##### Take subset of data","16f9a07d":"#### Load the data","40d27b0d":"#### Draw histogram to get idea how data is distributed","f98bdd83":"#### build train data and test data set","a2d8e78d":"##### Apply popularity based recommendation system","c4f59a61":"Build Collaborative Filtering model","ceaa372d":"Get top 10 results for recommendations","591005c7":"#### load data and split into train and test set"}}