{"cell_type":{"f245d2c5":"code","68ba233e":"code","897f17bf":"code","ad7c29c2":"code","a189ca40":"code","824ba68a":"code","38e62496":"code","84b31407":"code","60449de7":"code","e161caea":"markdown","f2e32cd8":"markdown","389bd119":"markdown","5ed47590":"markdown","7186c485":"markdown","083d4d5b":"markdown","1e93b3fd":"markdown","5ad2e053":"markdown","75e27fd2":"markdown","0d2ac21c":"markdown","6ac848e4":"markdown","e7de6b1a":"markdown","3add7ae7":"markdown"},"source":{"f245d2c5":"import pandas as pd\ninput_path = '\/kaggle\/input\/order-brushing-shopee-code-league\/order_brush_order.csv'\ndf = pd.read_csv(input_path)\ndf.head()","68ba233e":"df.groupby('shopid').size().describe()","897f17bf":"df.groupby('shopid')['userid'].count().sort_values(ascending=False).head(10)","ad7c29c2":"unique_shopid = df['shopid'].unique()\nprint(f'{len(unique_shopid)} shops unique')\n\nshopid_over3_df = pd.DataFrame(df.groupby('shopid').size()[df.groupby('shopid').size() >= 3]).to_dict()\nshopid_over3 = shopid_over3_df[0].keys()\nprint(f'{len(shopid_over3)} shops more than 3 orders')","a189ca40":"df['event_time'] = pd.to_datetime(df['event_time'])\ndf['ts'] = df[['event_time']].apply(lambda x: x[0].timestamp(), axis=1).astype(int)\ndf.head()","824ba68a":"df = df.sort_values(by='ts', ascending=True)\ndf","38e62496":"from datetime import datetime\nimport time\n\ncount = 0\nans_dict = dict()\n\nfor shop_id in shopid_over3:\n    time_record = time.time()\n    cheat = 0\n    # record the cheating row index in shop_df\n    cheat_order_list = set() \n    \n    shop_df = df[df['shopid'] == shop_id]\n    len_shop_data = len(shop_df)\n    \n    # initial previous_order_time which is 1 hour earlier than the start_order_time, here we set 9999 secs which is greater than 3600 secs (aka 1 hour)\n    previous_order_time = shop_df.iloc[0]['ts'] - 9999\n    # We don't need to check for the last 2 orders since it need more than 3 orders to fit the condition of brushing order\n    for start_order in range(len_shop_data - 2): \n        start_order_time = shop_df.iloc[start_order]['ts']\n        # same as the reason above, end_order is start from start_order+2\n        for end_order in range(start_order + 2, len_shop_data): \n            \n            # start_order_time and end_order_time need to within 1 hour\n            end_order_time = shop_df.iloc[end_order]['ts']\n            if end_order_time > start_order_time + 3600:\n                break\n            \n            # Find the event time of next_order\n            # edge condition which end_order is the last order of this shop\n            if end_order == len_shop_data - 1: \n                # similar to how we did for previous_order_time\n                next_order_time = shop_df.iloc[end_order]['ts'] + 9999 \n            else:\n                next_order_time = shop_df.iloc[end_order + 1]['ts']\n            \n            # check whether next_order_time - previous_order_time > 1 hour\n            if next_order_time > previous_order_time + 3601:\n                # we can not divide orders which have same timestamp into different time interval\n                if next_order_time == end_order_time: \n                    continue\n\n                tmp_df = shop_df.iloc[start_order: end_order + 1]\n                order_num = tmp_df.orderid.nunique()\n                user_num = tmp_df.userid.nunique()\n\n                # check whether order brushing\n                if order_num \/ user_num >= 3:\n                    cheat = 1\n                    cheat_order_list.update(list(range(start_order, end_order + 1)))\n        # refresh the previous order time\n        previous_order_time = start_order_time \n        \n    count += 1 \n\n    if cheat == 1:\n        # find the brushing user\n        tmp_df = shop_df.iloc[list(cheat_order_list)]\n        tmp_dict = tmp_df.groupby('userid').size().to_dict()\n        max_time = max(list(tmp_dict.values()))\n        \n        ans_dict[shop_id] = []\n        for user in tmp_dict:\n            if tmp_dict[user] == max_time:\n                ans_dict[shop_id].append(user)\n                        \n        print(f'{count:4d}, shop {shop_id} used {time.time() - time_record:4.2f} sec(s), cheat!!!')","84b31407":"# count how many shop is brushing (tips: the true num is 315 shops)\nlen(ans_dict)","60449de7":"ans_shop = []\nans_user = []\nfor shop in ans_dict.keys():\n    if len(ans_dict[shop]) > 1:\n        user_cheat = set(ans_dict[shop])\n        user_cheat = sorted(list(user_cheat), reverse=False)\n        ans_user.append(\"&\".join([str(i) for i in user_cheat]))\n    else:\n        ans_user.append(str(ans_dict[shop][0]))\n    ans_shop.append(shop)\n\nfor shop in unique_shopid:\n    if shop not in ans_dict.keys():\n        ans_shop.append(shop)\n        ans_user.append(\"0\")\n\nprint(len(ans_shop))\nprint(len(ans_user))\n\ndf_ans = pd.DataFrame({'shopid': ans_shop, 'userid': ans_user})\ndf_ans.to_csv('\/kaggle\/working\/prediction.csv',index=False)","e161caea":"## 2. Data Analysis","f2e32cd8":"### Generate timestamp","389bd119":"### Find all shops IDs and shops which have more than 3 orders","5ed47590":"Read the csv file into a Pandas dataframe.","7186c485":"**Variable definition:**\n* previous_order: The nearest order before the time interval.\n* previous_order_time: The event time of previous_order.\n* start_order: The first order of this time interval.\n* start_order_time: The event time of start_order.\n* end_order: The last order of this time interval.\n* end_order_time: The event time of end_order.\n* next_order: The nearest order after the time interval.\n* next_order_time: The event time of next_order.\n\n\n**We will find time interval with following two conditions:**\n1. start_order_time and end_order_time are within 1 hour.\n2. next_order_time - previous_order_time > 1 hour.\n\nWarning: It will take more than 5 minutes to run this cell.","083d4d5b":"### Sort orders by event time","1e93b3fd":"List shops with most orders.","5ad2e053":"### Check number of brushing shops","75e27fd2":"# Shopee Code League - Order Brushing\n\n## Collaborators of this notebook: [YeuTong](https:\/\/www.kaggle.com\/yeutong), [Eric](https:\/\/www.kaggle.com\/ericttt) ,[ZihYong](https:\/\/www.kaggle.com\/huangzihyong)\n\n> kaggle competition: https:\/\/www.kaggle.com\/c\/order-brushing-shopee-code-league\n\nIn this notebook, we would like to share our method using Pandas to figure out the brushing order.\n\nAfter few hour finding the tricks of this competition, we finally get score 1 with the late submition. ","0d2ac21c":"### Start to detect brushing orders","6ac848e4":"## 1. Data Exploration","e7de6b1a":"## 3. Save the result","3add7ae7":"There are total 18770 shops and most of the shops only have few orders (50% of shops less than 2 orders).\n\nHowever, there exist the outlier which has 11703 orders. "}}