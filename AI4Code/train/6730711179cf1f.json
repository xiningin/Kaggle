{"cell_type":{"c69a6db9":"code","b042d7c6":"code","a8a5809d":"code","c5fddfa8":"code","55bf3495":"code","78afe4df":"code","1d024b1d":"code","b6a8483e":"code","670ba6d3":"code","b6b9ca52":"code","b0c9bfa8":"code","5bd4b24c":"code","0accdd55":"code","15e3510c":"code","01ddeb16":"code","0a12ebf8":"code","53e888ab":"code","139bb54c":"markdown","bb3d024b":"markdown","48731f57":"markdown","ddf3e2c3":"markdown","2fa036b5":"markdown","f1049cd9":"markdown","2ca2fcd2":"markdown","63486ef7":"markdown","b9dc0bd6":"markdown","492b0ad6":"markdown","b81680f2":"markdown"},"source":{"c69a6db9":"import os\nimport sys\n\nimport numpy as np\nimport pandas as pd\npd.set_option('display.max_rows', 500)\npd.set_option('display.max_columns', 500)\npd.set_option('display.width', 1000)\n\nfrom tqdm.notebook import tqdm\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader, Dataset\n\nfrom transformers import AdamW\nfrom transformers import get_linear_schedule_with_warmup\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","b042d7c6":"APEX=False\nEPOCHS=50\nHIDDEN_SIZE=64\nTRAIN_BATCH_SIZE=64\nVALID_BATCH_SIZE=16\nOUTPUT_DIR = \".\/\"","a8a5809d":"if APEX:\n    from apex import amp\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')","c5fddfa8":"class AverageMeter:\n    \"\"\"\n    Computes and stores the average and current value\n    \"\"\"\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n\n    def update(self, val, n=1):\n        self.val = val\n        self.sum += val * n\n        self.count += n\n        self.avg = self.sum \/ self.count","55bf3495":"class EarlyStopping:\n    def __init__(self, patience=7, mode=\"max\", delta=0.01):\n        self.patience = patience\n        self.counter = 0\n        self.mode = mode\n        self.best_score = None\n        self.early_stop = False\n        self.delta = delta\n        if self.mode == \"min\":\n            self.val_score = np.Inf\n        else:\n            self.val_score = -np.Inf\n\n    def __call__(self, epoch_score, model, model_path):\n\n        if self.mode == \"min\":\n            score = -1.0 * epoch_score\n        else:\n            score = np.copy(epoch_score)\n\n        if self.best_score is None:\n            self.best_score = score\n            self.save_checkpoint(epoch_score, model, model_path)\n        elif score < self.best_score + self.delta:\n            self.counter += 1\n            print('EarlyStopping counter: {} out of {}'.format(self.counter, self.patience))\n            if self.counter >= self.patience:\n                self.early_stop = True\n        else:\n            self.best_score = score\n            self.save_checkpoint(epoch_score, model, model_path)\n            self.counter = 0\n\n    def save_checkpoint(self, epoch_score, model, model_path):\n        if epoch_score not in [-np.inf, np.inf, -np.nan, np.nan]:\n            print('Validation score improved ({} --> {}). Saving model!'.format(self.val_score, epoch_score))\n            torch.save(model.state_dict(), model_path)\n        self.val_score = epoch_score","78afe4df":"class BreathDataset():\n    def __init__(self, df):\n        self.df = df\n        self.groups = df.groupby('breath_id').groups\n        self.keys = list(self.groups.keys())\n        \n    def __len__(self):\n        return len(self.keys)\n    \n    def __getitem__(self, idx):\n        indexes = self.groups[self.keys[idx]]\n        df = self.df.iloc[indexes]\n                \n        r = df.R.values\n        c = df.C.values\n        time_step = df.time_step.values\n        u_in = df.u_in.values\n        u_out = df.u_out.values\n        breath_time = df.breath_time.values\n        u_in_time = df.u_in_time.values\n        pressure = df.pressure.values\n        \n        return {\n                    \"r\": torch.tensor(r, dtype=torch.long),\n                    \"c\": torch.tensor(c, dtype=torch.long),\n                    \"time_step\": torch.tensor(time_step, dtype=torch.long),\n                    \"u_in\": torch.tensor(u_in, dtype=torch.long),\n                    \"u_out\": torch.tensor(u_out, dtype=torch.long),\n                    \"breath_time\": torch.tensor(breath_time, dtype=torch.long),\n                    \"u_in_time\": torch.tensor(u_in_time, dtype=torch.long),\n                    \"pressure\": torch.tensor(pressure, dtype=torch.float),\n                }","1d024b1d":"class BreathModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.hidden_size = HIDDEN_SIZE\n        self.r_emb = nn.Embedding(3, 2, padding_idx=0)\n        self.c_emb = nn.Embedding(3, 2, padding_idx=0)\n        self.seq_emb = nn.Sequential(\n            nn.Linear(9, self.hidden_size),\n            nn.LayerNorm(self.hidden_size),\n            nn.ReLU(),\n            nn.Dropout(0.3),\n        )\n        self.lstm = nn.LSTM(\n            self.hidden_size,\n            self.hidden_size,\n            dropout=0.3,\n            batch_first=True,\n            bidirectional=True\n        )\n        self.head = nn.Sequential(\n            nn.Linear(\n                self.hidden_size * 2,\n                self.hidden_size * 2),\n            nn.LayerNorm(self.hidden_size * 2),\n            nn.ReLU(),\n            nn.Dropout(0.3),\n            nn.Linear(self.hidden_size * 2, 1),\n        )\n                        \n    def forward(self, r, c, time_step, u_in, u_out, breath_time, u_in_time):\n        r_emb = self.r_emb(r)\n        c_emb = self.c_emb(c)\n        seq_x = torch.cat((r_emb, c_emb, time_step, u_in, u_out, breath_time, u_in_time), 2)\n        seq_emb = self.seq_emb(seq_x)\n        seq_emb, _ = self.lstm(seq_emb)\n        output = self.head(seq_emb)\n        return output","b6a8483e":"class VentilatorLoss(nn.Module):\n    \"\"\"\n    Directly optimizes the competition metric\n    \"\"\"\n    def __call__(self, outputs, targets, loss_mask):\n\n        x = outputs[loss_mask]\n        y = targets[loss_mask]\n\n        mae = (y - x).abs().mean()\n\n        return mae","670ba6d3":"def train_fn(data_loader, model, optimizer, device, scheduler=None):\n    \n    model.train()\n    \n    losses = AverageMeter()\n    tk0 = tqdm(data_loader, total=len(data_loader))\n    \n    for batch_index, data in enumerate(tk0):\n        r = data[\"r\"]\n        c = data[\"c\"]\n        time_step = data[\"time_step\"].unsqueeze(2)\n        u_in = data[\"u_in\"].unsqueeze(2)\n        u_out = data[\"u_out\"].unsqueeze(2)\n        breath_time = data[\"breath_time\"].unsqueeze(2)\n        u_in_time = data[\"u_in_time\"].unsqueeze(2)\n        targets = data[\"pressure\"].unsqueeze(2)\n \n        r = r.to(device, dtype=torch.long)\n        c = c.to(device, dtype=torch.long)\n        time_step = time_step.to(device, dtype=torch.long)\n        u_in = u_in.to(device, dtype=torch.long)\n        u_out = u_out.to(device, dtype=torch.long)\n        breath_time = breath_time.to(device, dtype=torch.long)\n        u_in_time = u_in_time.to(device, dtype=torch.long)\n        targets = targets.to(device, dtype=torch.long)\n\n        outputs = model(\n            r,\n            c,\n            time_step,\n            u_in,\n            u_out,\n            breath_time,\n            u_in_time,\n        )\n        \n        loss_fnc = VentilatorLoss()\n        \n        loss_mask = u_out == 1\n    \n        loss = loss_fnc(\n                outputs,\n                targets,\n                loss_mask,\n        )\n        \n        losses.update(loss.item(), len(loss_mask))\n\n        loss.backward()\n        optimizer.step()\n        scheduler.step()\n        \n\n    tk0.set_postfix(loss=losses.avg) \n    print(f\"train loss : {losses.avg}\")  ","b6b9ca52":"def valid_fn(data_loader, model, device):\n    \n    losses = AverageMeter()\n    \n    model.eval()\n    \n    tk0 = tqdm(data_loader, total=len(data_loader))\n    \n    for batch_index, data in enumerate(tk0):\n        r = data[\"r\"]\n        c = data[\"c\"]\n        time_step = data[\"time_step\"].unsqueeze(2)\n        u_in = data[\"u_in\"].unsqueeze(2)\n        u_out = data[\"u_out\"].unsqueeze(2)\n        breath_time = data[\"breath_time\"].unsqueeze(2)\n        u_in_time = data[\"u_in_time\"].unsqueeze(2)\n        targets = data[\"pressure\"].unsqueeze(2)\n\n        r = r.to(device, dtype=torch.long)\n        c = c.to(device, dtype=torch.long)\n        time_step = time_step.to(device, dtype=torch.long)\n        u_in = u_in.to(device, dtype=torch.long)\n        u_out = u_out.to(device, dtype=torch.long)\n        breath_time = breath_time.to(device, dtype=torch.long)\n        u_in_time = u_in_time.to(device, dtype=torch.long)\n        targets = targets.to(device, dtype=torch.long)\n        \n        outputs = model(\n            r,\n            c,\n            time_step,\n            u_in,\n            u_out,\n            breath_time,\n            u_in_time,\n        )\n        \n        loss_fnc = VentilatorLoss()\n    \n        loss_mask = u_out == 1\n    \n        loss = loss_fnc(\n                outputs,\n                targets,\n                loss_mask,\n        )\n        \n        losses.update(loss.item(), len(loss_mask))\n        \n\n    tk0.set_postfix(loss=losses.avg)\n    print(f\"valid loss : {losses.avg}\")\n    \n    return losses.avg","b0c9bfa8":"df = pd.read_csv(\"..\/input\/ventilator-pressure-fold\/ventilator_pressure_fold.csv\")\n\nfor fold in tqdm(range(5)):\n    \n    model = BreathModel()\n    model.train()\n    model.to(device)\n\n    df_train = df[df.kfold != fold].reset_index(drop=True)\n    df_valid = df[df.kfold == fold].reset_index(drop=True)\n\n    train_dataset = BreathDataset(\n        df=df_train\n    )\n\n    train_data_loader = torch.utils.data.DataLoader(\n        train_dataset,\n        batch_size=VALID_BATCH_SIZE,\n        num_workers=2\n    )\n\n    valid_dataset = BreathDataset(\n        df=df_valid\n    )\n\n    valid_data_loader = torch.utils.data.DataLoader(\n        valid_dataset,\n        batch_size=TRAIN_BATCH_SIZE,\n        num_workers=2\n    )\n\n    es = EarlyStopping(patience=3, mode=\"min\")\n\n    optimizer = AdamW(model.parameters(), lr=1e-5, weight_decay=1e-6)\n\n    num_train_steps = int(len(train_dataset) \/ TRAIN_BATCH_SIZE * EPOCHS)\n\n    scheduler = get_linear_schedule_with_warmup(\n        optimizer, \n        num_warmup_steps=0, \n        num_training_steps=num_train_steps\n    )\n\n    for epoch in tqdm(range(EPOCHS)):\n        print(f\"Training is Starting for epoch={epoch}\")\n        train_fn(train_data_loader, model, optimizer, device, scheduler=scheduler)\n        print(f\"Validating is Starting for epoch={epoch}\")\n        valid_loss = valid_fn(valid_data_loader, model, device)\n        \n        es(valid_loss, model, model_path=f\"model_{fold}.bin\")\n        if es.early_stop:\n            print(\"Early stopping\")\n            break","5bd4b24c":"class TestBreathDataset():\n    def __init__(self, df):\n        self.df = df\n        self.groups = df.groupby('breath_id').groups\n        self.keys = list(self.groups.keys())\n        \n    def __len__(self):\n        return len(self.keys)\n    \n    def __getitem__(self, idx):\n        indexes = self.groups[self.keys[idx]]\n        df = self.df.iloc[indexes]\n                \n        r = df.R.values\n        c = df.C.values\n        time_step = df.time_step.values\n        u_in = df.u_in.values\n        u_out = df.u_out.values\n        breath_time = df.breath_time.values\n        u_in_time = df.u_in_time.values\n        #pressure = df.pressure.values\n        \n        return {\n                    \"r\": torch.tensor(r, dtype=torch.long),\n                    \"c\": torch.tensor(c, dtype=torch.long),\n                    \"time_step\": torch.tensor(time_step, dtype=torch.long),\n                    \"u_in\": torch.tensor(u_in, dtype=torch.long),\n                    \"u_out\": torch.tensor(u_out, dtype=torch.long),\n                    \"breath_time\": torch.tensor(breath_time, dtype=torch.long),\n                    \"u_in_time\": torch.tensor(u_in_time, dtype=torch.long),\n                    #\"pressure\": torch.tensor(pressure, dtype=torch.float),\n                }","0accdd55":"def add_feature(df):\n    \n    df[\"u_in\"] = np.log1p( df[\"u_in\"] )\n    \n    r_map = {5: 0, 20:1, 50:2 }\n    c_map = {10:0, 20:1, 50:2 }\n    df[\"R\"] = df[\"R\"].map(r_map)\n    df[\"C\"] = df[\"C\"].map(c_map) \n    \n    df[\"breath_time\"] = df[\"time_step\"] - df[\"time_step\"].shift(1)\n    df.loc[df[\"time_step\"] == 0, \"breath_time\"] = 0\n    df[\"u_in_time\"] = df[\"u_in\"] - df[\"u_in\"] - df[\"u_in\"].shift(1)\n    df.loc[df[\"time_step\"] == 0, \"u_in_time\"] = 0\n    \n    return df","15e3510c":"def predict_fn(model, data_loader):\n\n    preds = []\n\n    tk0 = tqdm(data_loader, total=len(data_loader))\n\n    for batch_index, data in enumerate(tk0):\n        r = data[\"r\"]\n        c = data[\"c\"]\n        time_step = data[\"time_step\"].unsqueeze(2)\n        u_in = data[\"u_in\"].unsqueeze(2)\n        u_out = data[\"u_out\"].unsqueeze(2)\n        breath_time = data[\"breath_time\"].unsqueeze(2)\n        u_in_time = data[\"u_in_time\"].unsqueeze(2)\n        #targets = data[\"pressure\"].unsqueeze(2)\n\n        r = r.to(device, dtype=torch.long)\n        c = c.to(device, dtype=torch.long)\n        time_step = time_step.to(device, dtype=torch.long)\n        u_in = u_in.to(device, dtype=torch.long)\n        u_out = u_out.to(device, dtype=torch.long)\n        breath_time = breath_time.to(device, dtype=torch.long)\n        u_in_time = u_in_time.to(device, dtype=torch.long)\n        #targets = targets.to(device, dtype=torch.long)\n\n        outputs = model(\n            r,\n            c,\n            time_step,\n            u_in,\n            u_out,\n            breath_time,\n            u_in_time,\n        )\n\n        test_pred = outputs.cpu().detach().numpy()\n        test_pred = test_pred.flatten()\n\n        preds.append(test_pred)\n    \n    final_preds = []\n    for datas in preds:\n        for data in datas:\n            final_preds.append(data)\n            \n    return final_preds","01ddeb16":"device = torch.device(\"cuda\")\n\nmodel_0 = BreathModel()\nmodel_0.to(device)\nmodel_0.load_state_dict(torch.load(\"..\/input\/lstm-ventilator-pressure\/model_0.bin\"))\nmodel_0.eval()\n\nmodel_1 = BreathModel()\nmodel_1.to(device)\nmodel_1.load_state_dict(torch.load(\"..\/input\/lstm-ventilator-pressure\/model_1.bin\"))\nmodel_1.eval()\n\nmodel_2 = BreathModel()\nmodel_2.to(device)\nmodel_2.load_state_dict(torch.load(\"..\/input\/lstm-ventilator-pressure\/model_2.bin\"))\nmodel_2.eval()\n\nmodel_3 = BreathModel()\nmodel_3.to(device)\nmodel_3.load_state_dict(torch.load(\"..\/input\/lstm-ventilator-pressure\/model_3.bin\"))\nmodel_3.eval()\n\nmodel_4 = BreathModel()\nmodel_4.to(device)\nmodel_4.load_state_dict(torch.load(\"..\/input\/lstm-ventilator-pressure\/model_4.bin\"))\nmodel_4.eval()","0a12ebf8":"df_test = pd.read_csv(\"..\/input\/ventilator-pressure-prediction\/test.csv\")\ndf_test = add_feature(df_test)\n\ntest_dataset = TestBreathDataset(\n    df=df_test,\n)\n\ndata_loader = torch.utils.data.DataLoader(\n    test_dataset,\n    batch_size=VALID_BATCH_SIZE,\n    num_workers=1\n)\n\npreds_0 = predict_fn(model_0, data_loader)\npreds_1 = predict_fn(model_1, data_loader)\npreds_2 = predict_fn(model_2, data_loader)\npreds_3 = predict_fn(model_3, data_loader)\npreds_4 = predict_fn(model_4, data_loader)\n\nnp_preds_0 = np.array(preds_0)\nnp_preds_1 = np.array(preds_1)\nnp_preds_2 = np.array(preds_2)\nnp_preds_3 = np.array(preds_3)\nnp_preds_4 = np.array(preds_4)\n\npredictions = (np_preds_0 + np_preds_1 + np_preds_2 + np_preds_3 + np_preds_4) \/ 5","53e888ab":"df_sub = pd.read_csv(\"..\/input\/ventilator-pressure-prediction\/sample_submission.csv\")\ndf_sub['pressure'] = predictions\ndf_sub.to_csv('submission.csv', index=False)","139bb54c":"# Utility","bb3d024b":"# Loss","48731f57":"# Predict","ddf3e2c3":"# Porpuse","2fa036b5":"# Engine","f1049cd9":"# Import","2ca2fcd2":"# Model","63486ef7":"# Config","b9dc0bd6":"# Dataset","492b0ad6":"# Train","b81680f2":"This kernel influenced below kernels.\n\nReference:\n[Ventilator Pressure \/ LSTM starter](https:\/\/www.kaggle.com\/yasufuminakama\/ventilator-pressure-lstm-starter)"}}