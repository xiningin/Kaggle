{"cell_type":{"0b4f30d1":"code","4c984f47":"code","6ad5e6c0":"code","2cd5d8c2":"code","83cee4fa":"code","c9af71e0":"code","3bd08fc2":"code","71d6a60e":"code","62bfd851":"code","6b8aed85":"code","3e5a4c96":"code","da5d40b7":"code","ff0c9f6b":"code","9b281c15":"markdown"},"source":{"0b4f30d1":"import tensorflow as tf\nimport tensorflow.keras as keras\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom tensorflow.keras.applications import VGG16\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras import layers\nfrom tensorflow.keras import Model\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator","4c984f47":"train_dir = '\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/train'\nval_dir = '\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/val'\ntest_dir = '\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/test'\n# len(os.listdir('\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/train\/PNEUMONIA'))","6ad5e6c0":"ls \/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/test","2cd5d8c2":"nb_train_samples = len(os.listdir(train_dir + '\/NORMAL')) + len(os.listdir(train_dir + '\/PNEUMONIA'))\nprint(nb_train_samples)\nnb_val_samples  = len(os.listdir(val_dir + '\/NORMAL')) + len(os.listdir(val_dir + '\/PNEUMONIA'))\nprint(nb_val_samples)","83cee4fa":"train_datagen = ImageDataGenerator(rescale = 1.\/255,\n                                      shear_range=0.2,zoom_range=0.2,\n                                      horizontal_flip=True)\n\nval_datagen = ImageDataGenerator(rescale = 1.\/255)\n\ntest_datagen = ImageDataGenerator(rescale=1.\/ 255)\n\nbatch_size = 10\nimg_width = 150\nimg_height = 150\n\ntrain_generator = train_datagen.flow_from_directory(train_dir,batch_size = batch_size,\n                                                    class_mode = 'binary', \n                                                    target_size =(img_width, img_height))\n\nval_generator = val_datagen.flow_from_directory(val_dir,batch_size = batch_size,\n                                                    class_mode = 'binary', \n                                                    target_size =(img_width, img_height))\n\n\n\ntest_generator = test_datagen.flow_from_directory(test_dir,batch_size=batch_size,                                              \n                                                class_mode='binary',\n                                                target_size=(img_width, img_height))\n\n","c9af71e0":"pre_trained_model = VGG16(input_shape = (150, 150, 3), \n                                include_top = False, \n                                weights = 'imagenet')\n\npre_trained_model.summary()","3bd08fc2":"for layer in pre_trained_model.layers:\n      layer.trainable = False","71d6a60e":"\nlast_layer = pre_trained_model.get_layer('block4_pool')\n\nprint('Shape of last layer {}'.format(last_layer.output_shape))\nlast_output = last_layer.output","62bfd851":"\n\n# Flatten the output layer to 1 dimension\nx = layers.Flatten()(last_output)\n# Add a fully connected layer with 1,024 hidden units and ReLU activation\nx = layers.Dense(1024, activation='relu')(x)\n# Add a dropout rate of 0.2\nx = layers.Dropout(0.2)(x)                  \n# Add a final sigmoid layer for classification\nx = layers.Dense(1, activation='sigmoid')(x)           \n\nmodel = Model(pre_trained_model.input, x) \n\nmodel.summary()","6b8aed85":"model.compile(optimizer = Adam(lr=0.0001), \n              loss = 'binary_crossentropy', \n              metrics = ['acc'])","3e5a4c96":"history = model.fit_generator(\n            train_generator,\n            validation_data = val_generator,\n            steps_per_epoch = nb_train_samples \/\/ batch_size,\n            epochs = 5,\n            validation_steps = nb_val_samples \/\/ batch_size,\n            verbose = 1)","da5d40b7":"import matplotlib.pyplot as plt\nacc = history.history['acc']\nval_acc = history.history['val_acc']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nepochs = range(len(acc))\n\nplt.plot(epochs, acc, 'r', label='Training accuracy')\nplt.plot(epochs, val_acc, 'b', label='Validation accuracy')\nplt.title('Training and validation accuracy')\nplt.legend(loc=0)\nplt.figure()\n\n\nplt.show()","ff0c9f6b":"# evaluate the model\nscores = model.evaluate_generator(test_generator)\nprint(\"\\n%s: %.2f%%\" % (model.metrics_names[1], scores[1]*100))","9b281c15":"Now we will freeze all layers of our pretrained model"}}