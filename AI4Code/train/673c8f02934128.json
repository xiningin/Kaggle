{"cell_type":{"50e70dda":"code","6b84ce53":"code","39df62eb":"code","df8e3294":"code","c9f927d3":"code","7815c847":"code","673c6b59":"code","19fdee9c":"code","6d97bcf0":"code","cb9ca374":"code","f14148f0":"code","e188aea0":"code","19c57342":"code","ea75076d":"markdown","60cb6259":"markdown","0b2345c2":"markdown","0660edda":"markdown","8b98e5bc":"markdown","d2201d6d":"markdown","64d5b2b0":"markdown","e184110d":"markdown","8782b3cd":"markdown"},"source":{"50e70dda":"import numpy as np\nimport pandas as pd\n\nfrom collections import defaultdict\nfrom itertools import chain, combinations\nfrom optparse import OptionParser","6b84ce53":"df = pd.read_csv('..\/input\/cooking-ingredients\/train.csv')\ndf.head()","39df62eb":"features = df.iloc[:, 1:]\nlabels = df.iloc[:, 0]","df8e3294":"def powerset(s):\n    return chain.from_iterable(combinations(s, r) for r in range(1, len(s)))\n\n\ndef getAboveMinSup(itemSet, itemSetList, minSup, globalItemSetWithSup):\n    freqItemSet = set()\n    localItemSetWithSup = defaultdict(int)\n\n    for item in itemSet:\n        for itemSet in itemSetList:\n            if item.issubset(itemSet):\n                globalItemSetWithSup[item] += 1\n                localItemSetWithSup[item] += 1\n\n    for item, supCount in localItemSetWithSup.items():\n        support = float(supCount \/ len(itemSetList))\n        if(support >= minSup):\n            freqItemSet.add(item)\n\n    return freqItemSet\n\n\ndef getUnion(itemSet, length):\n    return set([i.union(j) for i in itemSet for j in itemSet if len(i.union(j)) == length])\n\n\ndef pruning(candidateSet, prevFreqSet, length):\n    tempCandidateSet = candidateSet.copy()\n    for item in candidateSet:\n        subsets = combinations(item, length)\n        for subset in subsets:\n            # if the subset is not in previous K-frequent get, then remove the set\n            if(frozenset(subset) not in prevFreqSet):\n                tempCandidateSet.remove(item)\n                break\n    return tempCandidateSet\n\n\ndef associationRule(freqItemSet, recipes, labels, itemSetWithSup, minConf):\n    rules = []\n    lbls = []\n    \n    sets_compare = [set(re) for re in recipes]\n    \n    for k, itemSet in freqItemSet.items():\n        for item in itemSet:\n            subsets = powerset(item)\n            for s in subsets:\n                \n                ss = set([es for es in s])\n                if(len(ss.intersection(sets_compare[0])) > 0 and len(ss.intersection(sets_compare[1])) > 0):\n                    lbls.append([labels[0], labels[1]])\n                if(len(ss.intersection(sets_compare[0])) > 0):\n                    lbls.append(labels[0])\n                if(len(ss.intersection(sets_compare[1])) > 0):\n                    lbls.append(labels[1])\n                    \n                confidence = float(\n                    itemSetWithSup[item] \/ itemSetWithSup[frozenset(s)])\n                if(confidence > minConf):\n                    rules.append([set(s), set(item.difference(s)), confidence])\n    return rules, lbls\n\n\ndef getItemSetFromList(itemSetList):\n    tempItemSet = set()\n\n    for itemSet in itemSetList:\n        for item in itemSet:\n            tempItemSet.add(frozenset([item]))\n\n    return tempItemSet","c9f927d3":"def apriori(itemSetList, labels, minSup, minConf):\n    C1ItemSet = getItemSetFromList(itemSetList)\n    # Final result global frequent itemset\n    globalFreqItemSet = dict()\n    # Storing global itemset with support count\n    globalItemSetWithSup = defaultdict(int)\n\n    L1ItemSet = getAboveMinSup(\n        C1ItemSet, itemSetList, minSup, globalItemSetWithSup)\n    currentLSet = L1ItemSet\n    k = 2\n\n    # Calculating frequent item set\n    while(currentLSet):\n        # Storing frequent itemset\n        globalFreqItemSet[k-1] = currentLSet\n        # Self-joining Lk\n        candidateSet = getUnion(currentLSet, k)\n        # Perform subset testing and remove pruned supersets\n        candidateSet = pruning(candidateSet, currentLSet, k-1)\n        # Scanning itemSet for counting support\n        currentLSet = getAboveMinSup(\n            candidateSet, itemSetList, minSup, globalItemSetWithSup)\n        k += 1\n\n    rules, lbls = associationRule(globalFreqItemSet, itemSetList, labels, globalItemSetWithSup, minConf)\n    #rules.sort(key=lambda x: x[2])\n\n    return globalFreqItemSet, rules, lbls","7815c847":"idx_to_column = {k:v for k,v in enumerate(features.columns.values)}\ncolumn_to_idx = {v:k for k,v in enumerate(features.columns.values)}","673c6b59":"def get_random_recipes(features, labels, nr):\n    ids = np.random.randint(0, len(features), size=nr).tolist()\n    idxs = np.array([np.arange(len(features.columns.values)).tolist() for x in range(nr)])\n    multiply = features.iloc[ids].values.astype(np.int32) * idxs\n    idx_arr  = [np.where(mult != 0)[0].tolist() for mult in multiply]\n    recipes = []\n    for arr_idx in idx_arr:\n        temp_result = []\n        for idx in arr_idx:\n            temp_result.append(idx_to_column[idx])\n        recipes.append(temp_result)\n    return recipes, labels[ids].values","19fdee9c":"def print_recipe(recipe, label):\n    print(\"-\" * 50)\n    print(\"Recipe: \", label)\n    print(\"-\" * 50)\n    for item in recipe:\n        print(item)","6d97bcf0":"# get 2 random receipes\nrecipes, lbls = get_random_recipes(features, labels, nr=2)\n\n# print recipes\npr = [print_recipe(rec, lbl) for rec, lbl in list(zip(recipes,lbls))]","cb9ca374":"freqItemSet, rules, lbls = apriori(recipes, lbls, minSup=0.5, minConf=0.5)","f14148f0":"def find_recipe(ingredients, rules, lbls):\n    rules_dic = {}\n    for i, item in enumerate(np.array(rules)[:, :-1]):\n        item = [list(i) for i in item]\n        rules_dic[str(item)] = lbls[i]\n    \n    result = None\n    \n    try:\n        result = rules_dic[str(ingredients)]\n    except:\n        result = \"Recipe not found\"\n        \n    return result","e188aea0":"print('Try to find recipe using ingredients: {0} and {1}'.format(recipes[0][0], recipes[0][1]))\nfound_recipe = find_recipe([[recipes[0][0]], [recipes[0][1]]], rules, lbls)\nprint('Found recipe: ', found_recipe)","19c57342":"ingredients_to_try = [['vanilla vodka'], ['coconut extract']]\nprint('Testing not finding ingredients')\nprint('Using the following ingredients: {0} and {1}'.format(ingredients_to_try[0][0], ingredients_to_try[1][0]))\nprint(find_recipe(ingredients_to_try, rules, lbls))","ea75076d":"# Apriori implementation","60cb6259":"# Apriori pseudocode","0b2345c2":"# Prepare Data","0660edda":"# Compare two receipes","8b98e5bc":"# Find recipe using Apriori algorithm","d2201d6d":"<pre>\nApriori algorithm is really useful for data minning.\nWe can use it easily to build an application that given ingredients, gives you the recipe.\n<\/pre>","64d5b2b0":"# Additional functionality","e184110d":"<pre>\nL[1] = {frequent 1-itemsets};\nfor (k=2; L[k-1] != 0; k ++) do begin\n    \/\/ perform self-joining\n    C[k] = getUnion(L[k-1])\n    \/\/ remove pruned supersets\n    C[k] = pruning(C[k])\n    \/\/ get itemsets that satisfy minSup\n    L[k] = getAboveMinSup(C[k], minSup)\nend\nAnswer = Lk (union)\n<\/pre>","8782b3cd":"# Conclusion"}}