{"cell_type":{"d032a6dc":"code","0fc03dcc":"code","c8da9c24":"code","a257b02f":"code","4f769a6f":"code","77f47d01":"code","bca872a1":"code","310e393b":"code","4d4c17e6":"code","b97f47a2":"code","5adad5f2":"code","4279e3e0":"code","e03b6c3f":"code","3272fe7b":"code","70f2a970":"code","680b6dbe":"code","8a0ddeb8":"code","2aed9653":"code","50937938":"code","8067025b":"code","904ec142":"code","442c8ff7":"code","aa9f3d9e":"code","0e80ae5d":"code","ac16c889":"code","770beed5":"code","c5636d44":"code","072defc4":"code","e1e8409a":"code","3944abe0":"code","2d9bf235":"code","a377c9fc":"code","3d994d1f":"code","02bcb65a":"code","9dafcbef":"code","d998d13e":"code","97f53f5a":"code","1aea9506":"code","52f5c3c8":"code","bb462378":"code","c2af2287":"code","e1a9ff45":"code","33ebf3bb":"code","7f5fb2d3":"code","b67483ae":"code","62cf4bdd":"markdown","427d2ccb":"markdown","84760811":"markdown","1d2e7c50":"markdown","014da5da":"markdown","af95775a":"markdown","f095ee18":"markdown","3db7c7d6":"markdown","82a54a71":"markdown","598d0259":"markdown","b11ca283":"markdown","0ebc0a4a":"markdown","764effb1":"markdown","52673fa5":"markdown","d354b9f1":"markdown","72e95860":"markdown","05c0c879":"markdown","4261f4f1":"markdown","862f89bf":"markdown"},"source":{"d032a6dc":"import pandas as pd\nimport numpy as np\n%pylab inline\npd.set_option(\"display.max_columns\", None)\npd.set_option(\"display.max_rows\", None)\nimport warnings; warnings.simplefilter('ignore')","0fc03dcc":"df_raw = pd.read_csv('..\/input\/housing.csv')","c8da9c24":"df_raw.head()","a257b02f":"# Recherches des valeurs nulles\ndf_raw.info()       # les donn\u00e9es sont compl\u00e8tes. pas de valeurs manquantes","4f769a6f":"#donn\u00e9es manquantes ou valeurs nulles\npd.isnull(df_raw).sum()","77f47d01":"df_raw['ocean_proximity'].value_counts()","bca872a1":"# taille du data frame\ndf_raw.shape","310e393b":"ocean_proximity_dummies_houses  = pd.get_dummies(df_raw['ocean_proximity'])\nocean_proximity_dummies_houses.columns = ['<1H OCEAN','INLAND','NEAR OCEAN','NEAR BAY','ISLAND']","4d4c17e6":"ocean_proximity_dummies_houses.head()","b97f47a2":"# On \u00e9limine la variable 'ocean_proximity'\ndf_raw.drop(['ocean_proximity'],axis=1,inplace=True)","5adad5f2":"# On remplace la variable 'ocean_proximity' par ses sous-variables obtenues par dummification\ndf_raw = df_raw.join(ocean_proximity_dummies_houses)","4279e3e0":"# On visualise le nouveau tableau \ndf_raw.tail()","e03b6c3f":"# package permettant de normaliser les variables (voir \u00e0 la fin)\nfrom sklearn.preprocessing import MinMaxScaler","3272fe7b":"df_raw['income_cat']=np.ceil(df_raw['median_income'] \/1.5)\ndf_raw['income_cat'].where(df_raw['income_cat'] < 5, 5.0 , inplace = True)","70f2a970":"# diagramme en battons pour le revenu median\ndf_raw['income_cat'].value_counts().plot(kind='bar')\nplt.title('revenu median par cat\u00e9gorie')\nplt.xlabel('cat\u00e9gorie')\nplt.ylabel('montant')","680b6dbe":"from sklearn.model_selection import StratifiedShuffleSplit","8a0ddeb8":"split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state = 42)","2aed9653":"for train_index, test_index in split.split(df_raw,df_raw['income_cat']):\n    strat_train_set = df_raw.loc[train_index]  # L'indexeur de locus Pandas peut \u00eatre utilis\u00e9 avec DataFrames pour deux \n                                          # cas d'utilisation diff\u00e9rents:\n                                          # a.) S\u00e9lection des lignes par \u00e9tiquette \/ index\n                                          # b.) S\u00e9lection de lignes avec une recherche bool\u00e9enne \/ conditionnelle\n    strat_test_set =df_raw.loc[test_index]","50937938":"housing = strat_train_set.copy()","8067025b":"# On \u00e9limine la variable 'median_income'\nhousing.drop(['income_cat'],axis=1,inplace=True)","904ec142":"housing.head()","442c8ff7":"df_raw.plot(kind='scatter', x='longitude',y='latitude', alpha = 0.1)\n# on ajoute alpha= 0,1 pour distinguer les points de plus forte densit\u00e9 de population","aa9f3d9e":"df_raw.plot(kind='scatter', x='longitude',y='latitude', alpha = 0.4,\n             s=df_raw['population']\/100, label='population', figsize=(10,7),\n             c='median_house_value', cmap=plt.get_cmap('jet'), colorbar = True,)\nplt.legend()","0e80ae5d":"import seaborn as sns\nsns.set_style('whitegrid')","ac16c889":"# Matrice couleur des donn\u00e9es\ndef plot_correlation_map( df_raw ):\n    corr = df_raw.corr()\n    _ , ax = plt.subplots( figsize =( 12 , 10 ) )\n    cmap = sns.diverging_palette( 220 , 10 , as_cmap = True )\n    _ = sns.heatmap(\n        corr, \n        cmap = cmap,\n        square=True, \n        cbar_kws={ 'shrink' : .9 }, \n        ax=ax, \n        annot = True, \n        annot_kws = { 'fontsize' : 12 }\n    )\nplot_correlation_map(df_raw)","770beed5":"corr_matrix = df_raw.corr()","c5636d44":"corr_matrix['median_house_value'].sort_values(ascending=False)\n# Corr\u00e9lation positive forte => les prix augmentent. n\u00e9gative => les prix diminuent. proche de z\u00e9ro = pas de corr\n# UNIQUEMENT POUR LES CORRELATIONS LINEAIRES","072defc4":"# Nombre de chambres par appartement:\ndf_raw['room_per_households']=df_raw['total_rooms']\/df_raw['households']\ndf_raw['bedrooms_per_room']=df_raw['total_bedrooms']\/df_raw['total_rooms']\ndf_raw['population_per_house']=df_raw['population']\/df_raw['households']","e1e8409a":"corr_matrix = df_raw.corr()\ncorr_matrix['median_house_value'].sort_values(ascending=False)","3944abe0":"df_raw.head()","2d9bf235":"#donn\u00e9es manquantes \npd.isnull(df_raw).sum()","a377c9fc":"# On remplace les valeurs manquantes par la m\u00e9diane\ndf_raw[\"total_bedrooms\"].fillna(df_raw[\"total_bedrooms\"].median(), inplace=True)\n# convert from float to int\ndf_raw['total_bedrooms'] = df_raw['total_bedrooms'].astype(int)","3d994d1f":"# On remplace les valeurs manquantes par la m\u00e9diane\ndf_raw[\"bedrooms_per_room\"].fillna(df_raw[\"bedrooms_per_room\"].median(), inplace=True)\n# convert from float to int\ndf_raw['bedrooms_per_room'] = df_raw['bedrooms_per_room'].astype(int)","02bcb65a":"# normalisation de certaines variables\ndf_raw['longitude'] = MinMaxScaler().fit_transform(df_raw['longitude'].values.reshape(-1, 1))\ndf_raw['latitude'] = MinMaxScaler().fit_transform(df_raw['latitude'].values.reshape(-1, 1))   \ndf_raw['total_rooms'] = MinMaxScaler().fit_transform(df_raw['total_rooms'].values.reshape(-1, 1))   \ndf_raw['population'] = MinMaxScaler().fit_transform(df_raw['population'].values.reshape(-1, 1))   \ndf_raw['households'] = MinMaxScaler().fit_transform(df_raw['households'].values.reshape(-1, 1))   \ndf_raw['total_bedrooms'] = MinMaxScaler().fit_transform(df_raw['total_bedrooms'].values.reshape(-1, 1)) \ndf_raw['median_house_value'] = (df_raw['median_house_value']\/100).astype(int)","9dafcbef":"df_raw.head()","d998d13e":"from sklearn.linear_model import LogisticRegression","97f53f5a":"from sklearn.model_selection import train_test_split","1aea9506":"# d\u00e9finition de la variable 'cols' (plus facile pour manipuler toutes les colonnes)\ncols = ['longitude', \n        'latitude',\n        'housing_median_age',\n        'total_rooms',\n        'total_bedrooms',\n        'population',\n        'households',\n        'median_income',\n        'median_house_value',\n        '<1H OCEAN',\n        'INLAND',\n        'NEAR OCEAN',\n        'NEAR BAY',\n        'ISLAND',\n        'room_per_households',\n        'bedrooms_per_room',\n        'population_per_house'\n       ] ","52f5c3c8":"# X repr\u00e9sente les colonnes\nX = df_raw[cols]","bb462378":"# y repr\u00e9sente la colonne 'median_house_value'. \n# On \u00e9limine 'median_house_value' de X\ny = X['median_house_value']\ndel X['median_house_value']","c2af2287":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)","e1a9ff45":"from sklearn.svm import SVR              # Pour des valeurs continues en cible on va utiliser SVR\nsvr = SVR()\nsvr.fit(X_train, y_train)\nprint(svr.score(X_train, y_train))\nprint(svr.score(X_test, y_test))","33ebf3bb":"def parse_model_0(X):\n    target = X.median_house_value\n    X=X[cols] #(Valeurs ayant des donn\u00e9es compl\u00e8tes)\ud83d\ude0a\n    return X, target","7f5fb2d3":"X,y = parse_model_0(df_raw.copy())","b67483ae":"from sklearn.model_selection import cross_val_score\ndef compute_score(clf, X, y):\n    xval = cross_val_score(clf, X, y, cv = 5)\n    return mean(xval) ","62cf4bdd":"###### Normalisation des variables \npour faciliter le travail des algorithmes","427d2ccb":"### Visualisation des donn\u00e9es en fonction des coordonn\u00e9es g\u00e9ographiques","84760811":"## recherche des corr\u00e9lations","1d2e7c50":"##### On y ajoute les prix de l'immobilier","014da5da":"##### On visualise toutes les corr\u00e9lations","af95775a":"#### Nouvelle matrice de corr\u00e9lations","f095ee18":"### Revenu median\n##### Le revenu median \u00e9tant une valeur importante, on va la cat\u00e9goriser","3db7c7d6":"#### Donn\u00e9es brutes","82a54a71":" #### Les donn\u00e9es sont pr\u00eates. On va pouvoir entrainer le mod\u00e8le","598d0259":"## Nettoyage des donn\u00e9es","b11ca283":"### Normalisation des coordonn\u00e9es polaires","0ebc0a4a":"## Cr\u00e9ation de nouvelles variables","764effb1":"##### Corr\u00e9lation avec la valeur des maisons","52673fa5":"#### Infos sur les donn\u00e9es","d354b9f1":"### Valeurs manquantes 'total_bedrooms'","72e95860":" ##### info sur la variable 'Ocean_proximity' qui est une valeur qualitative\n Il faut regarder ce qu'elle contient","05c0c879":"### Echantillonage stratifi\u00e9 sur les tranches de revenus","4261f4f1":"#### Importation des librairies","862f89bf":"##### Visualisation de la variable ocean_proximity"}}