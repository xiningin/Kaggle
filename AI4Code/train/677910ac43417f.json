{"cell_type":{"f7883522":"code","fb307a40":"code","dda38067":"code","147b973d":"code","84e13dc3":"code","18a15b38":"code","d4c620db":"code","c6c75ef7":"code","950a1415":"code","fd721db3":"code","218ff044":"code","889227fa":"code","6a6e7a79":"code","50cb99fe":"code","82bcc113":"code","c13e68d7":"code","991c290d":"code","5c36e87b":"code","83a3ec4b":"code","047a330c":"code","3089b1ee":"code","9646e192":"code","a4814051":"code","95c7dac5":"code","970a1f4c":"code","76fd2785":"code","1326b997":"code","c7ec882d":"code","b5594469":"code","ff58fb66":"code","7644e075":"code","57156129":"markdown","22b90dd6":"markdown","dccb0544":"markdown","4855a29a":"markdown","52a05638":"markdown","80eea9c9":"markdown","7833c40b":"markdown","964be8fe":"markdown","3bd1dbe2":"markdown","b05eb270":"markdown","7c8b068b":"markdown","cc9516aa":"markdown","3fffaa88":"markdown","c323a25b":"markdown","da26fed7":"markdown"},"source":{"f7883522":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os","fb307a40":"!pip install -U torchvision # We need a new versino of torchvision for this project","dda38067":"import torch\nimport torchvision\nfrom torchvision import datasets, models\nfrom torchvision.transforms import functional as FT\nfrom torchvision import transforms as T\nfrom torch import nn, optim\nfrom torch.nn import functional as F\nfrom torch.utils.data import DataLoader, sampler, random_split, Dataset\nimport copy\nimport math\nfrom PIL import Image\nimport cv2\nimport albumentations as A  # our data augmentation library\n\nimport matplotlib.pyplot as plt\n%matplotlib inline","147b973d":"# remove arnings (optional)\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom collections import defaultdict, deque\nimport datetime\nimport time\nfrom tqdm import tqdm # progress bar\nfrom torchvision.utils import draw_bounding_boxes","84e13dc3":"print(torch.__version__)\nprint(torchvision.__version__)","18a15b38":"# our dataset is in cocoformat, we will need pypcoco tools\n!pip install pycocotools\nfrom pycocotools.coco import COCO","d4c620db":"# Now, we will define our transforms\nfrom albumentations.pytorch import ToTensorV2","c6c75ef7":"def get_transforms(train=False):\n    if train:\n        transform = A.Compose([\n            A.Resize(600, 600), # our input size can be 600px\n            A.HorizontalFlip(p=0.3),\n            A.VerticalFlip(p=0.3),\n            A.RandomBrightnessContrast(p=0.1),\n            A.ColorJitter(p=0.1),\n            ToTensorV2()\n        ], bbox_params=A.BboxParams(format='coco'))\n    else:\n        transform = A.Compose([\n            A.Resize(600, 600), # our input size can be 600px\n            ToTensorV2()\n        ], bbox_params=A.BboxParams(format='coco'))\n    return transform","950a1415":"class AquariumDetection(datasets.VisionDataset):\n    def __init__(self, root, split='train', transform=None, target_transform=None, transforms=None):\n        # the 3 transform parameters are reuqired for datasets.VisionDataset\n        super().__init__(root, transforms, transform, target_transform)\n        self.split = split #train, valid, test\n        self.coco = COCO(os.path.join(root, split, \"_annotations.coco.json\")) # annotatiosn stored here\n        self.ids = list(sorted(self.coco.imgs.keys()))\n        self.ids = [id for id in self.ids if (len(self._load_target(id)) > 0)]\n    \n    def _load_image(self, id: int):\n        path = self.coco.loadImgs(id)[0]['file_name']\n        image = cv2.imread(os.path.join(self.root, self.split, path))\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        return image\n    def _load_target(self, id):\n        return self.coco.loadAnns(self.coco.getAnnIds(id))\n    \n    def __getitem__(self, index):\n        id = self.ids[index]\n        image = self._load_image(id)\n        target = self._load_target(id)\n        target = copy.deepcopy(self._load_target(id))\n        \n        boxes = [t['bbox'] + [t['category_id']] for t in target] # required annotation format for albumentations\n        if self.transforms is not None:\n            transformed = self.transforms(image=image, bboxes=boxes)\n        \n        image = transformed['image']\n        boxes = transformed['bboxes']\n        \n        new_boxes = [] # convert from xywh to xyxy\n        for box in boxes:\n            xmin = box[0]\n            xmax = xmin + box[2]\n            ymin = box[1]\n            ymax = ymin + box[3]\n            new_boxes.append([xmin, ymin, xmax, ymax])\n        \n        boxes = torch.tensor(new_boxes, dtype=torch.float32)\n        \n        targ = {} # here is our transformed target\n        targ['boxes'] = boxes\n        targ['labels'] = torch.tensor([t['category_id'] for t in target], dtype=torch.int64)\n        targ['image_id'] = torch.tensor([t['image_id'] for t in target])\n        targ['area'] = (boxes[:, 3] - boxes[:, 1]) * (boxes[:, 2] - boxes[:, 0]) # we have a different area\n        targ['iscrowd'] = torch.tensor([t['iscrowd'] for t in target], dtype=torch.int64)\n        return image.div(255), targ # scale images\n    def __len__(self):\n        return len(self.ids)","fd721db3":"dataset_path = \"\/kaggle\/input\/aquarium-dataset\/Aquarium Combined\/\"","218ff044":"#load classes\ncoco = COCO(os.path.join(dataset_path, \"train\", \"_annotations.coco.json\"))\ncategories = coco.cats\nn_classes = len(categories.keys())\ncategories","889227fa":"classes = [i[1]['name'] for i in categories.items()]\nclasses","6a6e7a79":"train_dataset = AquariumDetection(root=dataset_path, transforms=get_transforms(True))","50cb99fe":"# Lets view a sample\nsample = train_dataset[2]\nimg_int = torch.tensor(sample[0] * 255, dtype=torch.uint8)\nplt.imshow(draw_bounding_boxes(\n    img_int, sample[1]['boxes'], [classes[i] for i in sample[1]['labels']], width=4\n).permute(1, 2, 0))","82bcc113":"len(train_dataset)","c13e68d7":"# lets load the faster rcnn model\nmodel = models.detection.fasterrcnn_mobilenet_v3_large_fpn(pretrained=True)\nin_features = model.roi_heads.box_predictor.cls_score.in_features # we need to change the head\nmodel.roi_heads.box_predictor = models.detection.faster_rcnn.FastRCNNPredictor(in_features, n_classes)","991c290d":"def collate_fn(batch):\n    return tuple(zip(*batch))","5c36e87b":"train_loader = DataLoader(train_dataset, batch_size=4, shuffle=True, num_workers=4, collate_fn=collate_fn)","83a3ec4b":"images,targets = next(iter(train_loader))\nimages = list(image for image in images)\ntargets = [{k:v for k, v in t.items()} for t in targets]\noutput = model(images, targets) # just make sure this runs without error","047a330c":"device = torch.device(\"cuda\") # use GPU to train","3089b1ee":"model = model.to(device)","9646e192":"# Now, and optimizer\nparams = [p for p in model.parameters() if p.requires_grad]\noptimizer = torch.optim.SGD(params, lr=0.01, momentum=0.9, nesterov=True, weight_decay=1e-4)\n# lr_scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[16, 22], gamma=0.1) # lr scheduler","a4814051":"import sys","95c7dac5":"def train_one_epoch(model, optimizer, loader, device, epoch):\n    model.to(device)\n    model.train()\n    \n#     lr_scheduler = None\n#     if epoch == 0:\n#         warmup_factor = 1.0 \/ 1000 # do lr warmup\n#         warmup_iters = min(1000, len(loader) - 1)\n        \n#         lr_scheduler = optim.lr_scheduler.LinearLR(optimizer, start_factor = warmup_factor, total_iters=warmup_iters)\n    \n    all_losses = []\n    all_losses_dict = []\n    \n    for images, targets in tqdm(loader):\n        images = list(image.to(device) for image in images)\n        targets = [{k: torch.tensor(v).to(device) for k, v in t.items()} for t in targets]\n        \n        loss_dict = model(images, targets) # the model computes the loss automatically if we pass in targets\n        losses = sum(loss for loss in loss_dict.values())\n        loss_dict_append = {k: v.item() for k, v in loss_dict.items()}\n        loss_value = losses.item()\n        \n        all_losses.append(loss_value)\n        all_losses_dict.append(loss_dict_append)\n        \n        if not math.isfinite(loss_value):\n            print(f\"Loss is {loss_value}, stopping trainig\") # train if loss becomes infinity\n            print(loss_dict)\n            sys.exit(1)\n        \n        optimizer.zero_grad()\n        losses.backward()\n        optimizer.step()\n        \n#         if lr_scheduler is not None:\n#             lr_scheduler.step() # \n        \n    all_losses_dict = pd.DataFrame(all_losses_dict) # for printing\n    print(\"Epoch {}, lr: {:.6f}, loss: {:.6f}, loss_classifier: {:.6f}, loss_box: {:.6f}, loss_rpn_box: {:.6f}, loss_object: {:.6f}\".format(\n        epoch, optimizer.param_groups[0]['lr'], np.mean(all_losses),\n        all_losses_dict['loss_classifier'].mean(),\n        all_losses_dict['loss_box_reg'].mean(),\n        all_losses_dict['loss_rpn_box_reg'].mean(),\n        all_losses_dict['loss_objectness'].mean()\n    ))","970a1f4c":"num_epochs=10\n\nfor epoch in range(num_epochs):\n    train_one_epoch(model, optimizer, train_loader, device, epoch)\n#     lr_scheduler.step()","76fd2785":"# our learning rate was too low, due to a lr scheduler bug. For this task, we wont need a scheudul.er","1326b997":"# we will watch first epoich to ensure no errrors\n# while it is training, lets write code to see the models predictions. lets try again\nmodel.eval()\ntorch.cuda.empty_cache()","c7ec882d":"test_dataset = AquariumDetection(root=dataset_path, split=\"test\", transforms=get_transforms(False))","b5594469":"img, _ = test_dataset[5]\nimg_int = torch.tensor(img*255, dtype=torch.uint8)\nwith torch.no_grad():\n    prediction = model([img.to(device)])\n    pred = prediction[0]","ff58fb66":"# it did learn","7644e075":"fig = plt.figure(figsize=(14, 10))\nplt.imshow(draw_bounding_boxes(img_int,\n    pred['boxes'][pred['scores'] > 0.8],\n    [classes[i] for i in pred['labels'][pred['scores'] > 0.8].tolist()], width=4\n).permute(1, 2, 0))","57156129":"## Optimizer\n\nHere, we define the optimizer. If you wish, you can also define the LR Scheduler, but it is not necessary for this notebook since our dataset is so small.\n\n> Note, there are a few bugs with the current way `lr_scheduler` is implemented. If you wish to use the scheduler, you will have to fix those bugs","22b90dd6":"We use albumentations as our data augmentation library due to its capability to deal with bounding boxes in multiple formats","dccb0544":"This is our collating function for the train dataloader, it allows us to create batches of data that can be easily pass into the model","4855a29a":"Here are all the necessary libraries","52a05638":"## Trying on sample Images\n\nThis is the inference code for the model. First, we set the model to evaluation mode and clear the GPU Cache. We also load a test dataset, so that we can use fresh images that the model hasn't seen.","80eea9c9":"10 Epochs should be enough to train this model for a high accuracy","7833c40b":"## Model\n\nOur model is FasterRCNN with a backbone of `MobileNetV3-Large`. We need to change the output layers because we have just 7 classes but this model was trained on 90 classes.","964be8fe":"## Training\n\nThe following is a function that will train the model for one epoch. Torchvision Object Detections models have a loss function built in, and it will calculate the loss automatically if you pass in the `inputs` and `targets`","3bd1dbe2":"PyCOCOTools provides many utilities for dealing with datasets in the COCO format, and if you wanted, you could evaluate the model's performance on the dataset with some of the utilities provided with this library.\n\nThat is out of scope for this notebook, however.","b05eb270":"## Dataset\n\nThis is our dataset class. It loads all the necessary files and it processes the data so that it can be fed into the model.","7c8b068b":"# Object Detection with Faster RCNN\n\nCode is for the following video: https:\/\/www.youtube.com\/watch?v=Uc90rr5jbA4&t=71s\n\nDo give this notebook a thumbs-up if you liked it. Thanks!","cc9516aa":"This code just gets a list of classes","3fffaa88":"The following blocks ensures that the model can take in the data and that it will not crash during training","c323a25b":"We require the latest version of torchvision","da26fed7":"This is a sample image and its bounding boxes, this code does not get the model's output"}}