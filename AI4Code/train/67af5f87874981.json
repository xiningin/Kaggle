{"cell_type":{"f51a2c6c":"code","83af2b09":"code","dd7e6b92":"code","5a993e16":"code","2333fd53":"code","0c0df55b":"code","eddc741e":"code","f33b7722":"code","35f56d9e":"code","c7ac5b17":"code","6a72650e":"code","502ba9bb":"code","261f76e6":"code","79a8d4dc":"code","81992d11":"code","20982287":"code","5a70f1ca":"code","effc9d2c":"markdown","699cafbe":"markdown"},"source":{"f51a2c6c":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# vis\nimport seaborn as sns\nimport plotly.express as px\n\n# imp\nfrom sklearn.impute import SimpleImputer\n# encode\nfrom sklearn.preprocessing import OneHotEncoder\n# pipeline\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.compose import make_column_selector as selector\nfrom  copy import deepcopy\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.pipeline import make_pipeline","83af2b09":"class Features:\n    \n    _num_cols = ['SalePrice', 'LotFrontage', 'LotArea', 'YearBuilt', 'YearRemodAdd','MasVnrArea', 'BsmtFinSF1',\n               'BsmtFinSF2', 'BsmtUnfSF',  'TotalBsmtSF', '1stFlrSF', '2ndFlrSF',\n               'LowQualFinSF', 'GrLivArea', \n               'BsmtFullBath', 'BsmtHalfBath', 'FullBath', # check the values, expect discrete numeric\n               'HalfBath', 'BedroomAbvGr', 'KitchenAbvGr', 'TotRmsAbvGrd', 'Fireplaces',\n               'GarageYrBlt', 'GarageCars', 'GarageArea', 'WoodDeckSF', 'OpenPorchSF',\n               'EnclosedPorch', '3SsnPorch', 'ScreenPorch', 'PoolArea',\n               'MiscVal', 'MoSold', 'YrSold', 'OverallCond', 'OverallQual']\n\n\n    _cat_cols = ['MSSubClass', 'MSZoning', 'Street', 'Alley', 'LotShape', 'LandContour', 'Utilities',\n               'LotConfig', 'LandSlope', 'Neighborhood', 'Condition1', 'Condition2', 'BldgType',\n               'HouseStyle', 'RoofStyle', 'RoofMatl', 'Exterior1st', 'Exterior2nd',\n               'MasVnrType', 'ExterQual', 'ExterCond', 'Foundation', 'BsmtQual', 'BsmtCond',\n               'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2', 'Heating', 'HeatingQC',\n               'CentralAir', 'Electrical', 'KitchenQual', 'Functional', 'FireplaceQu',\n               'GarageType', 'GarageFinish', 'GarageQual', 'GarageCond', 'PavedDrive', \n                'PoolQC', 'Fence', 'SaleType', 'SaleCondition', 'MiscFeature']\n\n    _ordinal_cat = ['ExterQual', 'ExterCond', 'BsmtQual', 'BsmtCond',\n                  'BsmtExposure', # could be treated as ordinal except maybe one category\n                  'BsmtFinType1',\n                  'BsmtFinType2', # likely good choice of ordernal\n                  'HeatingQC', 'KitchenQual', 'Functional', 'FireplaceQu',\n                  'GarageFinish', 'GarageQual', 'GarageCond',\n                  'PoolQC',\n                  'Fence', # except no fence which does not fit in the order\n                  ] #\n\n    _mapping_features = {\"ExterQual\": {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                       \"ExterCond\": {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                       \"BsmtQual\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"BsmtCond\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"BsmtExposure\": {\"NA\": 0, \"No\": 1, \"Mn\": 2, \"Av\": 3, \"Gd\": 4},\n                        \"BsmtFinType1\": {\"NA\": 0, \"Unf\": 1, \"LwQ\": 2, \"Rec\": 3, \"BLQ\": 4, \"ALQ\": 5, \"GLQ\": 6},\n                        \"BsmtFinType2\" : {\"NA\": 0, \"Unf\": 1, \"LwQ\": 2, \"Rec\": 3, \"BLQ\": 4, \"ALQ\": 5, \"GLQ\": 6},\n                        \"HeatingQC\": {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                        \"KitchenQual\" :  {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                        \"Functional\": {\"Sal\": 0, \"Sev\": 1, \"Maj2\": 2, \"Maj1\": 3, \"Mod\": 4, \"Min2\": 5, \"Min1\": 6, \"Typ\": 7},\n                        \"FireplaceQu\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"GarageFinish\": {\"NA\": 0, \"Unf\": 1, \"RFn\": 2, \"Fin\": 3},\n                        \"GarageQual\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"GarageCond\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"PoolQC\": {\"NA\": 0, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"Fence\": {\"NA\": 0, \"MnWw\": 1, \"GdWo\": 2, \"MnPrv\":3 , \"GdPrv\":4}}\n    \n    def __init__(self, iolevel=0):\n        self.iolevel = iolevel\n        self.stats()\n        \n    def stats(self):\n        if self.iolevel > 0:\n            print(f\"num numeric cols: {len(self._num_cols)}, cat cols: {len(self._cat_cols)}, \\\n              ordinary cols: {len(self._ordinal_cat)}\")\n        \n    def remove(self, fnames):\n        \n        for fname in fnames:\n            if fname in self._num_cols:\n                self._num_cols.remove(fname)\n            elif fname in self._cat_cols:\n                self._cat_cols.remove(fname)\n            else:\n                print(f\" {fname} not in features\")\n            \n            if fname in self._ordinal_cat:\n                self._ordinal_cat.remove(fname)\n        self.stats()\n                \n    def get(self, ftype=\"all\"):\n        \n        if ftype==\"all\": return self._num_cols + self._cat_cols\n        elif ftype==\"num\": return self._num_cols\n        elif ftype=='cat': return self._cat_cols\n        elif ftype=='ord': return self._ordinal_cat\n        else:\n            print(f\" wrong ftype {ftype}\")\n            \n    def add(self, names, types):\n        \n        assert len(names) == len(types)\n        if type == \"cat\": raise(\"not implemented yet\")\n        for name, typef in zip(names, types):\n            if typef == \"num\": self._num_cols.extend([name])\n        self.stats()\n                \n    def map_ordinal(self, name):\n        assert name in self._mapping_features \n        assert name in self._ordinal_cat\n\n        return self._mapping_features[name]","dd7e6b92":"class PreprocessTransform(BaseEstimator, TransformerMixin):\n    \"\"\"sklearn pipeline transformer \"\"\"\n    def __init__(self):\n        pass\n    def fit(self, X, y=None):\n        return self\n    def transform(self, X, y=None):\n        X_trans = X\n        return X_trans","5a993e16":"class BasicePrepro(PreprocessTransform):\n    \n    def __init__(self): \n        pass\n        \n    def transform(self, X, y=None):\n\n        X_trans = self.num_to_cat(X)\n        X_trans = self._set_missing_vals(X_trans)\n        X_trans = self._year_to_age(X_trans)\n        X_trans = self._remove_low_var(X_trans)\n        \n        return X_trans\n\n    def _remove_low_var(self, df):\n        low_cat_vars = ['Street', 'Utilities', 'Condition2']\n        return df.drop(columns=low_cat_vars)\n\n    def _set_missing_vals(self, df):    \n        '''replace NA string with missing vals for cols'''\n\n        cols = ['GarageYrBlt', 'MasVnrArea', 'LotFrontage']\n        for col in cols:\n            df[col] = df[col].replace(\"NA\", np.nan).astype(float)\n\n        return df\n        \n    def _year_to_age(self, data):\n\n        year_cols = ['YearBuilt', 'YearRemodAdd', 'GarageYrBlt', 'YrSold']    \n        year_of_data_collection = 2010\n\n        for col in year_cols:\n            new_col = col.replace(\"Year\", \"Age\").replace(\"Yr\", \"Age\")\n            data[new_col] = year_of_data_collection - data[col]\n            data.drop(columns=[col], inplace=True)\n\n        return data\n    \n    def num_to_cat(self, df):\n        \n        # contains numeric values but are categories without order\n        df['MSSubClass'] = df['MSSubClass'].astype(str)\n        \n        return df\n        ","2333fd53":"class Imputer(PreprocessTransform):\n    \n    def __init__(self, method='simple', config='median'): \n        \n        self.method = method\n        self.config = config\n\n    def fit(self, X, y=None):\n        \n        self.num_cols = X.select_dtypes(\"number\").columns\n        \n        if self.method == 'simple':\n            self.imputer = SimpleImputer(strategy=self.config)\n            self.imputer.fit(X[self.num_cols])           \n            \n        return self\n    \n    def transform(self, X, y=None):\n        \n        X.loc[:,self.num_cols] = self.imputer.transform(X.loc[:, self.num_cols])\n        \n        assert isinstance(X, pd.DataFrame)\n        \n        return X","0c0df55b":"class Transforms(PreprocessTransform):\n    \n    def __init__(self, log_cols=[\"LotFrontage\", \"GrLivArea\"]): \n        \n        self.log_cols = log_cols         \n\n    def transform(self, X, y=None):\n        \n        assert isinstance(X, pd.DataFrame)\n        \n        X_trans = self._log_transform(X)\n\n        return X_trans\n\n    def _log_transform(self, df):\n\n        for col in self.log_cols:\n            df.loc[:, col] = df[col].apply(np.log)\n            \n        return df","eddc741e":"class Encoder(PreprocessTransform):\n\n    _mapping_features = {\"ExterQual\": {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                       \"ExterCond\": {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                       \"BsmtQual\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"BsmtCond\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"BsmtExposure\": {\"NA\": 0, \"No\": 1, \"Mn\": 2, \"Av\": 3, \"Gd\": 4},\n                        \"BsmtFinType1\": {\"NA\": 0, \"Unf\": 1, \"LwQ\": 2, \"Rec\": 3, \"BLQ\": 4, \"ALQ\": 5, \"GLQ\": 6},\n                        \"BsmtFinType2\" : {\"NA\": 0, \"Unf\": 1, \"LwQ\": 2, \"Rec\": 3, \"BLQ\": 4, \"ALQ\": 5, \"GLQ\": 6},\n                        \"HeatingQC\": {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                        \"KitchenQual\" :  {\"Po\": 0, \"Fa\": 1, \"TA\": 2, \"Gd\": 3, \"Ex\": 4},\n                        \"Functional\": {\"Sal\": 0, \"Sev\": 1, \"Maj2\": 2, \"Maj1\": 3, \"Mod\": 4, \"Min2\": 5, \"Min1\": 6, \"Typ\": 7},\n                        \"FireplaceQu\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"GarageFinish\": {\"NA\": 0, \"Unf\": 1, \"RFn\": 2, \"Fin\": 3},\n                        \"GarageQual\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"GarageCond\": {\"NA\": 0, \"Po\": 1, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"PoolQC\": {\"NA\": 0, \"Fa\": 2, \"TA\": 3, \"Gd\": 4, \"Ex\": 5},\n                        \"Fence\": {\"NA\": 0, \"MnWw\": 1, \"GdWo\": 2, \"MnPrv\":3 , \"GdPrv\":4}}\n    \n    \n    def __init__(self, cat_method='oho'): \n        '''method performs encoding of categorical variables\n        ordinal cat are encoded as numeric, nominal optionally as one-hot'''\n        \n        self.cat_method = cat_method\n\n    def fit(self, X, y=None):\n\n        self.cat_cols = [col for col in X.select_dtypes(\"object\").columns\n                         if not col in self._mapping_features]\n        \n        if self.cat_method == 'oho':\n            self.cat_enc = OneHotEncoder(handle_unknown='ignore', sparse=False)\n            self.cat_enc.fit(X[self.cat_cols])\n                \n        return self\n    \n    def transform(self, X, y=None):\n        \n        X_trans = self._encode_ordinal(X)\n        #X_trans = X\n        \n        if self.cat_method == 'oho':\n            X_oho = self._encode_one_hot(X_trans[self.cat_cols])\n            X_trans = pd.merge(X_trans.drop(columns=self.cat_cols), X_oho, \n                               left_index=True, right_index=True)\n        else:\n            # exclude one-hot encoded vars\n            X_trans.drop(columns=self.cat_cols, inplace=True)\n            \n        return X_trans\n    \n    def _encode_ordinal(self, df):\n        '''encode ordinal categorical based on mapping'''\n\n        for feat in self._mapping_features:\n            if feat in df.columns:\n                df.loc[:, feat] = df[feat].map(self._mapping_features[feat])\n                #df[feat].update(df[feat].map(self._mapping_features[feat]))\n                \n        return df\n    \n    def _encode_one_hot(self, df):\n\n        data_cat_oho = self.cat_enc.transform(df)\n        oho_cols = self.cat_enc.get_feature_names(self.cat_cols)\n        oho_names_mapping = {}\n        for col in df.columns:\n            oho_names_mapping[col] = []\n            for col_oho in oho_cols:\n                if col == col_oho.split(\"_\")[0]:\n                    oho_names_mapping[col].append(col_oho)\n        \n        return pd.DataFrame(data_cat_oho.T, oho_cols).T","f33b7722":"from sklearn import set_config\nset_config(display='diagram')\nfrom sklearn.compose import ColumnTransformer","35f56d9e":"pipe_steps_prepro = [\n    ('BasicePrepro', BasicePrepro()),\n    ('Imputer', Imputer()),\n    ('Transforms', Transforms()),\n    ('Encoder', Encoder(cat_method=None))\n]","c7ac5b17":"pipe_prepro = Pipeline(pipe_steps_prepro)\npipe_prepro","6a72650e":"train = pd.read_csv(\"..\/input\/house-prices-advanced-regression-techniques\/train.csv\", \n                    keep_default_na=False, na_values=[\"\"])\ntrain.shape","502ba9bb":"train.head()","261f76e6":"train.columns","79a8d4dc":"pipe_prepro.fit_transform(train.drop(columns=['Id', 'SalePrice']))","81992d11":"train_trans = pipe_prepro.transform(train.drop(columns=['Id', 'SalePrice']))\ntrain_trans.head()","20982287":"train_trans.dtypes.value_counts()","5a70f1ca":"class ClfSwitcher(BaseEstimator):\n    def __init__(self, estimator):\n        \"\"\"\n        A Custom BaseEstimator that can switch between classifiers.\n        :param estimator: sklearn object - The classifier\n        \"\"\" \n        try:\n            self.estimator = estimator()\n        except:\n            self.estimator = estimator\n\n    def fit(self, X, y=None, **kwargs):\n        self.estimator.fit(X, y)\n        return self\n\n\n    def predict(self, X, y=None):\n        return self.estimator.predict(X)\n\n\n    def predict_proba(self, X):\n        return self.estimator.predict_proba(X)\n\n\n    def score(self, X, y):\n        return self.estimator.score(X, y)","effc9d2c":"# I. Preprocessing","699cafbe":"# Pipeline Utility Script for House Prices - Advanced Regression Techniques"}}