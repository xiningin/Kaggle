{"cell_type":{"5203dbbf":"code","a02e48eb":"code","91b935c0":"code","0370316e":"code","31aa9c6f":"code","23d7dd13":"code","e49edb13":"code","c3901238":"code","ed0534fc":"code","06a4cf6a":"code","6d427d0c":"code","d8711278":"code","8593434a":"code","130b4869":"code","fc30d270":"code","753af2a7":"code","7de737ea":"code","3b85dd21":"code","2fdd5645":"code","43e05791":"code","4fa15c01":"code","f05d28b5":"code","7c642c16":"code","20d7e031":"code","0e62b52f":"code","8289068e":"code","49aaf569":"code","f4a1dca8":"code","3cbdc67d":"code","f3a0b41a":"code","e860cab0":"code","59a89a6d":"code","2a69e976":"code","e03e5e97":"code","b19ae629":"code","18e3ddc6":"code","984f216a":"code","38e595fa":"code","10b9d2b3":"code","fc42bc93":"code","5505064f":"code","0b1d67b5":"code","9f4f1220":"code","2709c2b5":"code","578e5ca6":"code","0e621f27":"code","c012e9e8":"code","fe24d491":"code","41abb26c":"code","29247aea":"markdown","52fcbead":"markdown","b93838ab":"markdown","a5541a46":"markdown","4929bbef":"markdown","76f98cbf":"markdown","b23ed7b8":"markdown","b18b7195":"markdown","cffa3013":"markdown","a112f7e8":"markdown","fda33c24":"markdown","4d05be42":"markdown","13fdf698":"markdown","f645adcd":"markdown","666749e9":"markdown","b7180776":"markdown","63c3e26c":"markdown","24b3b93f":"markdown","814a8ba1":"markdown","bedbcb7d":"markdown","5d21614d":"markdown","d83a31af":"markdown","fa9bc9f2":"markdown","aa4d375c":"markdown","bd582a7f":"markdown","9f6b2e44":"markdown","fb7da790":"markdown","407fec79":"markdown","d6a7ed24":"markdown","b96fb554":"markdown"},"source":{"5203dbbf":"import numpy as np\nimport pandas as pd\n\nimport os\nprint(os.listdir('..\/input'))\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly as py\nimport plotly.graph_objs as go","a02e48eb":"# reading the dataset\n\ndata = pd.read_csv('..\/input\/online_shoppers_intention.csv')\n\n# checking the shape of the data\ndata.shape","91b935c0":"# checking the head of the data\n\ndata.head()","0370316e":"# describing the data\n\ndata.describe()","31aa9c6f":"# checking if the data contains any NULL values\n\ndata.isnull().sum().sum()","23d7dd13":"# checking the Distribution of customers on Revenue\n\nplt.rcParams['figure.figsize'] = (18, 7)\n\nplt.subplot(1, 2, 1)\nsns.countplot(data['Weekend'], palette = 'pastel')\nplt.title('Buy or Not', fontsize = 30)\nplt.xlabel('Revenue or not', fontsize = 15)\nplt.ylabel('count', fontsize = 15)\n\n\n# checking the Distribution of customers on Weekend\nplt.subplot(1, 2, 2)\nsns.countplot(data['Weekend'], palette = 'inferno')\nplt.title('Purchase on Weekends', fontsize = 30)\nplt.xlabel('Weekend or not', fontsize = 15)\nplt.ylabel('count', fontsize = 15)\n\nplt.show()","e49edb13":"data['VisitorType'].value_counts()","c3901238":"# plotting a pie chart for browsers\n\nplt.rcParams['figure.figsize'] = (18, 7)\nsize = [10551, 1694, 85]\ncolors = ['violet', 'magenta', 'pink']\nlabels = \"Returning Visitor\", \"New_Visitor\", \"Others\"\nexplode = [0, 0, 0.1]\nplt.subplot(1, 2, 1)\nplt.pie(size, colors = colors, labels = labels, explode = explode, shadow = True, autopct = '%.2f%%')\nplt.title('Different Visitors', fontsize = 30)\nplt.axis('off')\nplt.legend()\n\n# plotting a pie chart for browsers\nsize = [7961, 2462, 736, 467,174, 163, 300]\ncolors = ['orange', 'yellow', 'pink', 'crimson', 'lightgreen', 'cyan', 'blue']\nlabels = \"2\", \"1\",\"4\",\"5\",\"6\",\"10\",\"others\"\n\nplt.subplot(1, 2, 2)\nplt.pie(size, colors = colors, labels = labels, shadow = True, autopct = '%.2f%%', startangle = 90)\nplt.title('Different Browsers', fontsize = 30)\nplt.axis('off')\nplt.legend()\nplt.show()","ed0534fc":"# visualizing the distribution of customers around the Region\n\nplt.rcParams['figure.figsize'] = (18, 7)\n\nplt.subplot(1, 2, 1)\nplt.hist(data['TrafficType'], color = 'lightgreen')\nplt.title('Distribution of diff Traffic',fontsize = 30)\nplt.xlabel('TrafficType Codes', fontsize = 15)\nplt.ylabel('Count', fontsize = 15)\n\n# visualizing the distribution of customers around the Region\n\nplt.subplot(1, 2, 2)\nplt.hist(data['Region'], color = 'lightblue')\nplt.title('Distribution of Customers',fontsize = 30)\nplt.xlabel('Region Codes', fontsize = 15)\nplt.ylabel('Count', fontsize = 15)\n\nplt.show()","06a4cf6a":"# checking the no. of OSes each user is having\n\ndata['OperatingSystems'].value_counts()","6d427d0c":"#checking the months with most no.of customers visiting the online shopping sites\n\ndata['Month'].value_counts()","d8711278":"# creating a donut chart for the months variations'\n\n# plotting a pie chart for different number of OSes users have.\n\nsize = [6601, 2585, 2555, 478, 111]\ncolors = ['orange', 'yellow', 'pink', 'crimson', 'lightgreen']\nlabels = \"2\", \"1\",\"3\",\"4\",\"others\"\nexplode = [0, 0, 0, 0, 0]\n\ncircle = plt.Circle((0, 0), 0.6, color = 'white')\n\nplt.subplot(1, 2, 1)\nplt.pie(size, colors = colors, labels = labels, explode = explode, shadow = True, autopct = '%.2f%%')\nplt.title('OSes Users have', fontsize = 30)\np = plt.gcf()\np.gca().add_artist(circle)\nplt.axis('off')\nplt.legend()\n\n# plotting a pie chart for share of special days\n\nsize = [3364, 2998, 1907, 1727, 549, 448, 433, 432, 288, 184]\ncolors = ['orange', 'yellow', 'pink', 'crimson', 'lightgreen', 'cyan', 'magenta', 'lightblue', 'lightgreen', 'violet']\nlabels = \"May\", \"November\", \"March\", \"December\", \"October\", \"September\", \"August\", \"July\", \"June\", \"February\"\nexplode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\ncircle = plt.Circle((0, 0), 0.6, color = 'white')\n\nplt.subplot(1, 2, 2)\nplt.pie(size, colors = colors, labels = labels, explode = explode, shadow = True, autopct = '%.2f%%')\nplt.title('Special Days', fontsize = 30)\np = plt.gcf()\np.gca().add_artist(circle)\nplt.axis('off')\nplt.legend()\n\nplt.show()","8593434a":"# product related duration vs revenue\n\nplt.rcParams['figure.figsize'] = (18, 15)\n\nplt.subplot(2, 2, 1)\nsns.boxenplot(data['Revenue'], data['Informational_Duration'], palette = 'rainbow')\nplt.title('Info. duration vs Revenue', fontsize = 30)\nplt.xlabel('Info. duration', fontsize = 15)\nplt.ylabel('Revenue', fontsize = 15)\n\n# product related duration vs revenue\n\nplt.subplot(2, 2, 2)\nsns.boxenplot(data['Revenue'], data['Administrative_Duration'], palette = 'pastel')\nplt.title('Admn. duration vs Revenue', fontsize = 30)\nplt.xlabel('Admn. duration', fontsize = 15)\nplt.ylabel('Revenue', fontsize = 15)\n\n# product related duration vs revenue\n\nplt.subplot(2, 2, 3)\nsns.boxenplot(data['Revenue'], data['ProductRelated_Duration'], palette = 'dark')\nplt.title('Product Related duration vs Revenue', fontsize = 30)\nplt.xlabel('Product Related duration', fontsize = 15)\nplt.ylabel('Revenue', fontsize = 15)\n\n# exit rate vs revenue\n\nplt.subplot(2, 2, 4)\nsns.boxenplot(data['Revenue'], data['ExitRates'], palette = 'spring')\nplt.title('ExitRates vs Revenue', fontsize = 30)\nplt.xlabel('ExitRates', fontsize = 15)\nplt.ylabel('Revenue', fontsize = 15)\n\n\nplt.show()\n","130b4869":"# page values vs revenue\n\nplt.rcParams['figure.figsize'] = (18, 7)\n\nplt.subplot(1, 2, 1)\nsns.stripplot(data['Revenue'], data['PageValues'], palette = 'autumn')\nplt.title('PageValues vs Revenue', fontsize = 30)\nplt.xlabel('PageValues', fontsize = 15)\nplt.ylabel('Revenue', fontsize = 15)\n\n# bounce rates vs revenue\nplt.subplot(1, 2, 2)\nsns.stripplot(data['Revenue'], data['BounceRates'], palette = 'magma')\nplt.title('Bounce Rates vs Revenue', fontsize = 30)\nplt.xlabel('Boune Rates', fontsize = 15)\nplt.ylabel('Revenue', fontsize = 15)\n\nplt.show()","fc30d270":"# weekend vs Revenue\n\ndf = pd.crosstab(data['Weekend'], data['Revenue'])\ndf.div(df.sum(1).astype(float), axis = 0).plot(kind = 'bar', stacked = True, figsize = (15, 5), color = ['orange', 'crimson'])\nplt.title('Weekend vs Revenue', fontsize = 30)\nplt.show()","753af2a7":"# Traffic Type vs Revenue\n\ndf = pd.crosstab(data['TrafficType'], data['Revenue'])\ndf.div(df.sum(1).astype(float), axis = 0).plot(kind = 'bar', stacked = True, figsize = (15, 5), color = ['lightpink', 'yellow'])\nplt.title('Traffic Type vs Revenue', fontsize = 30)\nplt.show()","7de737ea":"# visitor type vs revenue\n\ndf = pd.crosstab(data['VisitorType'], data['Revenue'])\ndf.div(df.sum(1).astype(float), axis = 0).plot(kind = 'bar', stacked = True, figsize = (15, 5), color = ['lightgreen', 'green'])\nplt.title('Visitor Type vs Revenue', fontsize = 30)\nplt.show()\n","3b85dd21":"# region vs Revenue\n\ndf = pd.crosstab(data['Region'], data['Revenue'])\ndf.div(df.sum(1).astype(float), axis = 0).plot(kind = 'bar', stacked = True, figsize = (15, 5), color = ['lightblue', 'blue'])\nplt.title('Region vs Revenue', fontsize = 30)\nplt.show()","2fdd5645":"# lm plot\n\nplt.rcParams['figure.figsize'] = (20, 10)\n\nsns.lmplot(x = 'Administrative', y = 'Informational', data = data, x_jitter = 0.05)\nplt.title('LM Plot between Admistrative and Information', fontsize = 15)\n","43e05791":"# month vs pagevalues wrt revenue\n\nplt.rcParams['figure.figsize'] = (18, 15)\nplt.subplot(2, 2, 1)\nsns.boxplot(x = data['Month'], y = data['PageValues'], hue = data['Revenue'], palette = 'inferno')\nplt.title('Mon. vs PageValues w.r.t. Rev.', fontsize = 30)\n\n# month vs exitrates wrt revenue\nplt.subplot(2, 2, 2)\nsns.boxplot(x = data['Month'], y = data['ExitRates'], hue = data['Revenue'], palette = 'Reds')\nplt.title('Mon. vs ExitRates w.r.t. Rev.', fontsize = 30)\n\n# month vs bouncerates wrt revenue\nplt.subplot(2, 2, 3)\nsns.boxplot(x = data['Month'], y = data['BounceRates'], hue = data['Revenue'], palette = 'Oranges')\nplt.title('Mon. vs BounceRates w.r.t. Rev.', fontsize = 30)\n\n# visitor type vs exit rates w.r.t revenue\nplt.subplot(2, 2, 4)\nsns.boxplot(x = data['VisitorType'], y = data['BounceRates'], hue = data['Revenue'], palette = 'Purples')\nplt.title('Visitors vs BounceRates w.r.t. Rev.', fontsize = 30)\n\nplt.show()","4fa15c01":"# visitor type vs exit rates w.r.t revenue\n\nplt.rcParams['figure.figsize'] = (18, 15)\nplt.subplot(2, 2, 1)\nsns.violinplot(x = data['VisitorType'], y = data['ExitRates'], hue = data['Revenue'], palette = 'rainbow')\nplt.title('Visitors vs ExitRates wrt Rev.', fontsize = 30)\n\n# visitor type vs exit rates w.r.t revenue\nplt.subplot(2, 2, 2)\nsns.violinplot(x = data['VisitorType'], y = data['PageValues'], hue = data['Revenue'], palette = 'gnuplot')\nplt.title('Visitors vs PageValues wrt Rev.', fontsize = 30)\n\n# region vs pagevalues w.r.t. revenue\nplt.subplot(2, 2, 3)\nsns.violinplot(x = data['Region'], y = data['PageValues'], hue = data['Revenue'], palette = 'Greens')\nplt.title('Region vs PageValues wrt Rev.', fontsize = 30)\n\n#region vs exit rates w.r.t. revenue\nplt.subplot(2, 2, 4)\nsns.violinplot(x = data['Region'], y = data['ExitRates'], hue = data['Revenue'], palette = 'spring')\nplt.title('Region vs Exit Rates w.r.t. Revenue', fontsize = 30)\n\nplt.show()","f05d28b5":"# Inputing Missing Values with 0\n\ndata.fillna(0, inplace = True)\n\n# checking the no. of null values in data after imputing the missing values\ndata.isnull().sum().sum()","7c642c16":"# Q1: Time Spent by The Users on Website vs Bounce Rates\n\n'''\nBounce Rate :The percentage of visitors to a particular website who navigate away from the site after \nviewing only one page.\n'''\n# let's cluster Administrative duration and Bounce Ratw to different types of clusters in the dataset.\n# preparing the dataset\nx = data.iloc[:, [1, 6]].values\n\n# checking the shape of the dataset\nx.shape\n\n\nfrom sklearn.cluster import KMeans\n\nwcss = []\nfor i in range(1, 11):\n    km = KMeans(n_clusters = i,\n              init = 'k-means++',\n              max_iter = 300,\n              n_init = 10,\n              random_state = 0,\n              algorithm = 'elkan',\n              tol = 0.001)\n    km.fit(x)\n    labels = km.labels_\n    wcss.append(km.inertia_)\n    \nplt.rcParams['figure.figsize'] = (15, 7)\nplt.plot(range(1, 11), wcss)\nplt.grid()\nplt.tight_layout()\nplt.title('The Elbow Method', fontsize = 20)\nplt.xlabel('No. of Clusters')\nplt.ylabel('wcss')\nplt.show()","20d7e031":"km = KMeans(n_clusters = 3, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)\ny_means = km.fit_predict(x)\n\nplt.scatter(x[y_means == 0, 0], x[y_means == 0, 1], s = 100, c = 'pink', label = 'Un-interested Customers')\nplt.scatter(x[y_means == 1, 0], x[y_means == 1, 1], s = 100, c = 'yellow', label = 'General Customers')\nplt.scatter(x[y_means == 2, 0], x[y_means == 2, 1], s = 100, c = 'cyan', label = 'Target Customers')\nplt.scatter(km.cluster_centers_[:,0], km.cluster_centers_[:, 1], s = 50, c = 'blue' , label = 'centeroid')\n\nplt.title('Administrative Duration vs Duration', fontsize = 20)\nplt.grid()\nplt.xlabel('Administrative Duration')\nplt.ylabel('Bounce Rates')\nplt.legend()\nplt.show()","0e62b52f":"# informational duration vs Bounce Rates\nx = data.iloc[:, [3, 6]].values\n\nwcss = []\nfor i in range(1, 11):\n    km = KMeans(n_clusters = i,\n              init = 'k-means++',\n              max_iter = 300,\n              n_init = 10,\n              random_state = 0,\n              algorithm = 'elkan',\n              tol = 0.001)\n    km.fit(x)\n    labels = km.labels_\n    wcss.append(km.inertia_)\n    \nplt.rcParams['figure.figsize'] = (15, 7)\nplt.plot(range(1, 11), wcss)\nplt.grid()\nplt.tight_layout()\nplt.title('The Elbow Method', fontsize = 20)\nplt.xlabel('No. of Clusters')\nplt.ylabel('wcss')\nplt.show()","8289068e":"km = KMeans(n_clusters = 2, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)\ny_means = km.fit_predict(x)\n\nplt.scatter(x[y_means == 0, 0], x[y_means == 0, 1], s = 100, c = 'pink', label = 'Un-interested Customers')\nplt.scatter(x[y_means == 1, 0], x[y_means == 1, 1], s = 100, c = 'yellow', label = 'Target Customers')\nplt.scatter(km.cluster_centers_[:,0], km.cluster_centers_[:, 1], s = 50, c = 'blue' , label = 'centeroid')\n\nplt.title('Informational Duration vs Bounce Rates', fontsize = 20)\nplt.grid()\nplt.xlabel('Informational Duration')\nplt.ylabel('Bounce Rates')\nplt.legend()\nplt.show()","49aaf569":"# informational duration vs Bounce Rates\nx = data.iloc[:, [1, 7]].values\n\nwcss = []\nfor i in range(1, 11):\n    km = KMeans(n_clusters = i,\n              init = 'k-means++',\n              max_iter = 300,\n              n_init = 10,\n              random_state = 0,\n              algorithm = 'elkan',\n              tol = 0.001)\n    km.fit(x)\n    labels = km.labels_\n    wcss.append(km.inertia_)\n    \nplt.rcParams['figure.figsize'] = (15, 7)\nplt.plot(range(1, 11), wcss)\nplt.grid()\nplt.tight_layout()\nplt.title('The Elbow Method', fontsize = 20)\nplt.xlabel('No. of Clusters')\nplt.ylabel('wcss')\nplt.show()","f4a1dca8":"km = KMeans(n_clusters = 2, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)\ny_means = km.fit_predict(x)\n\nplt.scatter(x[y_means == 0, 0], x[y_means == 0, 1], s = 100, c = 'pink', label = 'Un-interested Customers')\nplt.scatter(x[y_means == 1, 0], x[y_means == 1, 1], s = 100, c = 'yellow', label = 'Target Customers')\nplt.scatter(km.cluster_centers_[:,0], km.cluster_centers_[:, 1], s = 50, c = 'blue' , label = 'centeroid')\n\nplt.title('Administrative Clustering vs Exit Rates', fontsize = 20)\nplt.grid()\nplt.xlabel('Administrative Duration')\nplt.ylabel('Exit Rates')\nplt.legend()\nplt.show()","3cbdc67d":"# informational duration vs Bounce Rates\nx = data.iloc[:, [13, 14]].values\n\nwcss = []\nfor i in range(1, 11):\n    km = KMeans(n_clusters = i,\n              init = 'k-means++',\n              max_iter = 300,\n              n_init = 10,\n              random_state = 0,\n              algorithm = 'elkan',\n              tol = 0.001)\n    km.fit(x)\n    labels = km.labels_\n    wcss.append(km.inertia_)\n    \nplt.rcParams['figure.figsize'] = (15, 7)\nplt.plot(range(1, 11), wcss)\nplt.grid()\nplt.tight_layout()\nplt.title('The Elbow Method', fontsize = 20)\nplt.xlabel('No. of Clusters')\nplt.ylabel('wcss')\nplt.show()","f3a0b41a":"km = KMeans(n_clusters = 2, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)\ny_means = km.fit_predict(x)\n\nplt.scatter(x[y_means == 0, 0], x[y_means == 0, 1], s = 100, c = 'pink', label = 'Un-interested Customers')\nplt.scatter(x[y_means == 1, 0], x[y_means == 1, 1], s = 100, c = 'yellow', label = 'Target Customers')\nplt.scatter(km.cluster_centers_[:,0], km.cluster_centers_[:, 1], s = 50, c = 'blue' , label = 'centeroid')\n\nplt.title('Region vs Traffic Type', fontsize = 20)\nplt.grid()\nplt.xlabel('Region')\nplt.ylabel('Traffic')\nplt.legend()\nplt.show()","e860cab0":"# informational duration vs Bounce Rates\nx = data.iloc[:, [1, 13]].values\n\nwcss = []\nfor i in range(1, 11):\n    km = KMeans(n_clusters = i,\n              init = 'k-means++',\n              max_iter = 300,\n              n_init = 10,\n              random_state = 0,\n              algorithm = 'elkan',\n              tol = 0.001)\n    km.fit(x)\n    labels = km.labels_\n    wcss.append(km.inertia_)\n    \nplt.rcParams['figure.figsize'] = (15, 7)\nplt.plot(range(1, 11), wcss)\nplt.grid()\nplt.tight_layout()\nplt.title('The Elbow Method', fontsize = 20)\nplt.xlabel('No. of Clusters')\nplt.ylabel('wcss')\nplt.show()","59a89a6d":"km = KMeans(n_clusters = 2, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)\ny_means = km.fit_predict(x)\n\nplt.scatter(x[y_means == 0, 0], x[y_means == 0, 1], s = 100, c = 'pink', label = 'Unproductive Customers')\nplt.scatter(x[y_means == 1, 0], x[y_means == 1, 1], s = 100, c = 'yellow', label = 'Target Customers')\nplt.scatter(km.cluster_centers_[:,0], km.cluster_centers_[:, 1], s = 50, c = 'blue' , label = 'centeroid')\n\nplt.title('Adminstrative Duration vs Region', fontsize = 20)\nplt.grid()\nplt.xlabel('Administrative Duration')\nplt.ylabel('Region Type')\nplt.legend()\nplt.show()","2a69e976":"# one hot encoding \n\ndata1 = pd.get_dummies(data)\n\ndata1.columns","e03e5e97":"# label encoding of revenue\n\nfrom sklearn.preprocessing import LabelEncoder\n\nle = LabelEncoder()\ndata['Revenue'] = le.fit_transform(data['Revenue'])\ndata['Revenue'].value_counts()","b19ae629":"# getting dependent and independent variables\n\nx = data1\n# removing the target column revenue from x\nx = x.drop(['Revenue'], axis = 1)\n\ny = data['Revenue']\n\n# checking the shapes\nprint(\"Shape of x:\", x.shape)\nprint(\"Shape of y:\", y.shape)\n","18e3ddc6":"# splitting the data\n\nfrom sklearn.model_selection import train_test_split\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)\n\n# checking the shapes\n\nprint(\"Shape of x_train :\", x_train.shape)\nprint(\"Shape of y_train :\", y_train.shape)\nprint(\"Shape of x_test :\", x_test.shape)\nprint(\"Shape of y_test :\", y_test.shape)","984f216a":"# MODELLING\n\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\n\nmodel = RandomForestClassifier()\nmodel.fit(x_train, y_train)\n\ny_pred = model.predict(x_test)\n\n# evaluating the model\nprint(\"Training Accuracy :\", model.score(x_train, y_train))\nprint(\"Testing Accuracy :\", model.score(x_test, y_test))\n\n# confusion matrix\ncm = confusion_matrix(y_test, y_pred)\nplt.rcParams['figure.figsize'] = (6, 6)\nsns.heatmap(cm ,annot = True)\n\n# classification report\ncr = classification_report(y_test, y_pred)\nprint(cr)","38e595fa":"# finding the Permutation importance\n\nimport eli5\nfrom eli5.sklearn import PermutationImportance\n\nperm = PermutationImportance(model, random_state = 0).fit(x_test, y_test)\neli5.show_weights(perm, feature_names = x_test.columns.tolist())","10b9d2b3":"# plotting the partial dependence plot for adminisrative duration\n\n# importing pdp\nfrom pdpbox import pdp, info_plots\n\nbase_features = x_test.columns.values.tolist()\n\nfeat_name = 'Administrative_Duration'\npdp_dist = pdp.pdp_isolate(model=model, dataset=x_test, model_features = base_features, feature = feat_name)\n\npdp.pdp_plot(pdp_dist, feat_name)\nplt.show()","fc42bc93":"# plotting partial dependency plot for Informational Duration\n\nbase_features = x_test.columns.tolist()\n\nfeat_name = 'Informational_Duration'\npdp_dist = pdp.pdp_isolate(model, x_test, base_features, feat_name)\n\npdp.pdp_plot(pdp_dist, feat_name)\nplt.show()","5505064f":"# let's take a look at the shap values\n\n# importing shap\nimport shap\n\nexplainer = shap.TreeExplainer(model)\nshap_values = explainer.shap_values(x_test)\n\nshap.summary_plot(shap_values[1], x_test, plot_type = 'bar')","0b1d67b5":"shap.summary_plot(shap_values[1], x_test)","9f4f1220":"# let's create a function to check the customer's conditions\n\ndef customer_analysis(model, customer):\n  explainer = shap.TreeExplainer(model)\n  shap_values = explainer.shap_values(customer)\n  shap.initjs()\n  return shap.force_plot(explainer.expected_value[1], shap_values[1], customer)","2709c2b5":"# let's do some real time prediction for patients\n\ncustomers = x_test.iloc[1,:].astype(float)\ncustomer_analysis(model, customers)","578e5ca6":"# let's do some real time prediction for patients\n\ncustomers = x_test.iloc[15,:].astype(float)\ncustomer_analysis(model, customers)","0e621f27":"# let's do some real time prediction for patients\n\ncustomers = x_test.iloc[100,:].astype(float)\ncustomer_analysis(model, customers)","c012e9e8":"# let's do some real time prediction for patients\n\ncustomers = x_test.iloc[150,:].astype(float)\ncustomer_analysis(model, customers)","fe24d491":"# let's do some real time prediction for patients\n\ncustomers = x_test.iloc[200,:].astype(float)\ncustomer_analysis(model, customers)","41abb26c":"shap_values = explainer.shap_values(x_train.iloc[:50])\nshap.initjs()\nshap.force_plot(explainer.expected_value[1], shap_values[1], x_test.iloc[:50])","29247aea":"**Attribute Information:**\n\n* * The dataset consists of 10 numerical and 8 categorical attributes. \n* The 'Revenue' attribute can be used as the class label. \n* \n* \"Administrative\", \"Administrative Duration\", \"Informational\", \"Informational Duration\", \"Product Related\" and \"Product Related Duration\" represent the number of different types of pages visited by the visitor in that session and total time spent in each of these page categories. The values of these features are derived from the URL information of the pages visited by the user and updated in real time when a user takes an action, e.g. moving from one page to another. The \"Bounce Rate\", \"Exit Rate\" and \"Page Value\" features represent the metrics measured by \"Google Analytics\" for each page in the e-commerce site. The value of \"Bounce Rate\" feature for a web page refers to the percentage of visitors who enter the site from that page and then leave (\"bounce\") without triggering any other requests to the analytics server during that session. The value of \"Exit Rate\" feature for a specific web page is calculated as for all pageviews to the page, the percentage that were the last in the session. The \"Page Value\" feature represents the average value for a web page that a user visited before completing an e-commerce transaction. The \"Special Day\" feature indicates the closeness of the site visiting time to a specific special day (e.g. Mother\u2019s Day, Valentine's Day) in which the sessions are more likely to be finalized with transaction. The value of this attribute is determined by considering the dynamics of e-commerce such as the duration between the order date and delivery date. For example, for Valentina\u2019s day, this value takes a nonzero value between February 2 and February 12, zero before and after this date unless it is close to another special day, and its maximum value of 1 on February 8. The dataset also includes operating system, browser, region, traffic type, visitor type as returning or new visitor, a Boolean value indicating whether the date of the visit is weekend, and month of the year.\n\n","52fcbead":"**Reading the Dataset**","b93838ab":"## Where from the Users of the Website come?","a5541a46":"### 2. Informative Duration vs Bounce Rates","4929bbef":"**By,  Looking at this Clustering plot, we can say confindently say that the customers who spent a longer administrative duration in a website are very less likely to bounce from the website that is navigating away from the website just after navigating one page of that website.**\n\n**There are Three Groups, The Pink Group is a group of customers who stay for shortest adminstrative duration and have highest chance for Navigating away from a w**","76f98cbf":"## Clustering Analysis","b23ed7b8":"**Importing Some Basic Libraries**","b18b7195":"**Splitting of the Data**","cffa3013":"<img src=\"https:\/\/images.pexels.com\/photos\/920382\/pexels-photo-920382.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500.jpg\" width=\"1000px\">\n\n","a112f7e8":"### 2. Adminstrative Duration vs Region","fda33c24":"**One Hot and Label Encoding**","4d05be42":"**Shap Values**","13fdf698":"**3.Administrative Duration vs Exit Rates**","f645adcd":"**According to this plot, the maximum bend is at third index, that is the number of Optimal no. of Clusters for Adminstrative Duration and Revenue is Three.\nLet's go to the next step, i.e., Plotting the Clusters.**","666749e9":"> Compute clustering algorithm (e.g., k-means clustering) for different values of k. For instance, by varying k from   1 to 10 clusters.\n\n> For each k, calculate the total within-cluster sum of square (wss).\n\n> Plot the curve of wss according to the number of clusters k.\n\n> The location of a bend (knee) in the plot is generally considered as an indicator of the appropriate number of       clusters.","b7180776":"**Bi-Variate Analysis**","63c3e26c":"**Customer Analysis**","24b3b93f":"**Force Plot**","814a8ba1":"**1. Administrative Duration vs Bounce Rate**","bedbcb7d":"**Visualizing the Cluster using Scatter Plot.**","5d21614d":"**Some Analysis to Understand the Data**","d83a31af":"**Random Forest Classifier**","fa9bc9f2":"**Evaluating Model**","aa4d375c":"**Uni-Variate Analysis of the Data**","bd582a7f":"**Multi-Variate Analysis**","9f6b2e44":"### 1. Region vs Traffic Type","fb7da790":"**Partial Dependency Plots**","407fec79":"**The Elbow Method to Find out the Maximum no. of Optimal Clusters**","d6a7ed24":"## Trying to learn the user characteristics of in terms of time spent on the Website\n","b96fb554":"## Data Preprocessing"}}