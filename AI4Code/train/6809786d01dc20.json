{"cell_type":{"fe8edef3":"code","6ba52cd0":"code","628f9c6d":"code","798ecf52":"code","56b47f72":"code","db632c80":"code","64d06d7f":"markdown","cc2a2d4f":"markdown","6252e3ef":"markdown","6f6b033f":"markdown"},"source":{"fe8edef3":"import math\nmath.pi","6ba52cd0":"import random\nimport pandas\nimport numpy as np\nfrom scipy.stats import sem\nimport scipy.stats as st\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom IPython import display\n\ninside = 0\noutside = 0\nestimates = []\nstandard_error = []\nN = []\nCI_lower = []\nCI_upper = []\npoint_frames = []\n\n# insidecircle takes two inputs between 0 and 1 and returns 1 if these points fall within the unit circle.\ndef insidecircle(x,y):\n    success = int(((x**2+y**2) <= 1))\n    return(success)\n\n# estimatepi takes a single input \ud835\udc41\ud835\udc41, generates \ud835\udc41\ud835\udc41 pairs of uniform random numbers and uses insidecircle to produce an estimate of \ud835\udf0b\ud835\udf0b as described above.\n# In addition to the estimate of \ud835\udf0b, estimatepi should also return the standard error of this estimate, and a 95% confidence interval for the estimate.\ndef estimatepi():\n    global inside\n    global outside\n    x = random.random()\n    y = random.random()\n    \n    if insidecircle(x, y) == 1:\n        inside += 1\n        color = 'r'\n    else:\n        outside += 1\n        color = 'b'\n        \n    point_frames.append([x, y, color])\n\n# Use estimatepi to estimate \ud835\udf0b for \ud835\udc41 = 1000 to 10000 in increments of 500 and record the estimate, its standard error and the upper and lower bounds of the 95% CI.\nfor i in range(1,21):\n    for ii in range(1, 501):\n        estimatepi()\n    \n    estimates.append(((inside)*4)\/(ii*i))\n    standard_error.append(sem(estimates))\n    N.append(ii*i)\n    #create 95% confidence interval for population mean weight\n    CI_lower.append(st.t.interval(alpha=0.95, df=len(estimates)-1, loc=np.mean(estimates), scale=st.sem(estimates))[0])\n    CI_upper.append(st.t.interval(alpha=0.95, df=len(estimates)-1, loc=np.mean(estimates), scale=st.sem(estimates))[1])\n\ndata = [N, estimates, standard_error, CI_lower, CI_upper]\nheaders=[\"N\", \"Estimates\", \"Standard Error\", \"Lower CI\", \"Upper CI\"]\nresults = pandas.DataFrame(data, headers).T\nresults[1:20]","628f9c6d":"fig = plt.figure(figsize=(6,6))\n\ndef animate(frame):\n    # update plot\n    \n    plt.suptitle(\"Monte Carlo Method\", fontsize=12)\n    plt.title(\"Approximation of \u03c0 = %1.3f\" % estimates[len(estimates)-1], fontsize=12)\n\n    # Plot the cities\n    plt.scatter(point_frames[frame][0],point_frames[frame][1], s=4, c=point_frames[frame][2])\n    \n    # Plot a unit circle\n    theta = np.linspace(0, 2*np.pi, 100)\n    r = np.sqrt(1.0)\n    x1 = r*np.cos(theta)\n    x2 = r*np.sin(theta)\n    plt.plot(x1, x2)\n    \n    # Plot Area Limits\n    plt.xlim([0, 1])\n    plt.ylim([0, 1])\n\nanim = FuncAnimation(fig, animate, frames=len(point_frames[0:2000]), interval=8)\nvideo = anim.to_html5_video()\nhtml = display.HTML(video)\ndisplay.display(html)\nplt.close()","798ecf52":"import matplotlib.pyplot as plt\n\ninside = 0\noutside = 0\nestimates = []\n\n# insidecircle takes two inputs between 0 and 1 and returns 1 if these points fall within the unit circle.\ndef insidecircle(x,y):\n    success = int(((x**2+y**2) <= 1))\n    return(success)\n\n# estimatepi takes a single input \ud835\udc41, generates \ud835\udc41 pairs of uniform random numbers and uses insidecircle to produce an estimate of \ud835\udf0b\ud835\udf0b as described above.\n# In addition to the estimate of \ud835\udf0b, estimatepi should also return the standard error of this estimate, and a 95% confidence interval for the estimate.\ndef estimatepi():\n    global inside\n    global outside\n    \n    if insidecircle(random.random(), random.random()) == 1:\n        inside += 1\n    else:\n        outside += 1\n\n# Use estimatepi to estimate \ud835\udf0b for \ud835\udc41 = 500\nfor i in range(1,500):\n    estimatepi()    \n    estimates.append(((inside)*4)\/(i))\n\n# Plot histogram\nplt.hist(estimates, bins='auto')\nplt.title(\"500 different estimates of pi\")\nplt.xlabel('Histogram skewed-to-the-left')","56b47f72":"np.std(estimates)","db632c80":"lower = sorted(i for i in estimates if i < 3.001175)\nupper = sorted(i for i in estimates if i > 3.270825)\n\n((500-(len(lower)+len(upper)))\/500)*100","64d06d7f":"![image.png](attachment:image.png)","cc2a2d4f":"# Animate MCM Process","6252e3ef":"# Histogram","6f6b033f":"# Monte Carlo integration to estimate the value of \u03c0"}}