{"cell_type":{"ad9ec3b9":"code","66d6a835":"code","c396ff8a":"code","66978192":"code","297d5280":"code","72054c5c":"code","cfed9d98":"code","24acfd5d":"code","3483accb":"code","eb9643d8":"code","e849c1f8":"code","c11ad9d8":"code","c9c216cc":"code","095d217b":"code","b7b0d05c":"code","4ed7f805":"code","3c18583a":"code","f4ecbfc7":"code","c197165e":"code","a2ce0048":"code","4b9c4ed2":"code","9f62a745":"code","b598ca02":"code","181478f0":"code","c4bb34c5":"markdown","ce0acc26":"markdown","9c3767d5":"markdown","2bf3a367":"markdown"},"source":{"ad9ec3b9":"# Listage des donn\u00e9es source\nimport os\nracine_data = \"..\/input\";\nrepertoires = os.listdir(racine_data)\nfor repertoire in repertoires:\n    print(repertoire)\n    fichiers = os.listdir(racine_data+\"\/\"+repertoire)\n    for fichier in fichiers:\n        print(\"   > \" +fichier)","66d6a835":"# Chargement des donn\u00e9es d'entrainement et de test\nimport pandas as pd\ntrain = pd.read_csv('..\/input\/digits\/train.csv')\ntest100 = pd.read_csv('..\/input\/test-100-premiers\/test100.csv')\nevaluation = pd.read_csv('..\/input\/digits\/test.csv')","c396ff8a":"# Affichage des informations\nprint(\"Il y a {0} exemples d'apprentissage.\".format(train.shape[0]))\nprint(\"Il y a {0} exemples d'\u00e9valuation.\".format(evaluation.shape[0]))\nprint(\"Il y a {0} exemples de test.\".format(test100.shape[0]))\nprint(\"Nombre de colonnes : \" , train.shape[1])\nprint(\"Liste des colonnes :\")\ntrain.columns","66978192":"# On s\u00e9pare la classe (label) des donn\u00e9es (pixels)\n\n# Le vecteur des num\u00e9ros de classe\ntrain_label = train[\"label\"]\n\n# Suppression de cette colonne \ntrain.drop(\"label\", axis = 1 , inplace=True)\n\n# Nombre d'exemples d'entrainement par classe\ntrain_label.value_counts().sort_index()","297d5280":"# La m\u00eame chose pour les tests\ntest100_label = test100[\"label\"]\ntest100.drop(\"label\", axis = 1 , inplace=True)\ntest100_label.value_counts().sort_index()","72054c5c":"# Normalisation des valeurs des images [0-255] -> [0.0-1.0]\ntrain      = train\/255.0\ntest100    = test100\/255.0\nevaluation = evaluation\/255.0\n","cfed9d98":"# Affichage des images de l'ensemble de test\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# Dimension de l'affichage\nnb_cols = 10\nnb_ligs = 10\ntaille  = 20\n\n# Affichage de nb_ligs lignes de nb_cols images\nfig1, ax1 = plt.subplots(nb_ligs,nb_cols, figsize=(taille,taille))\nfor no_lig in range(nb_ligs):\n    for no_col in range(nb_cols):\n        ax1[no_lig][no_col].imshow(test100.iloc[no_lig*nb_cols+no_col].values.reshape((28,28)), cmap='gray')\n        ax1[no_lig][no_col].axis('off')\n        ax1[no_lig][no_col].set_title(test100_label[no_lig*nb_cols+no_col])  ","24acfd5d":"import numpy as np\n# Restructuration des images en 3 dimensions (height = 28px, width = 28px , canal = 1)\ntrain_image =np.array(train).reshape(-1,28,28,1)\ntest100_image =np.array(test100).reshape(-1,28,28,1)","3483accb":"# Encodage du label de l'ensemble d'apprentissage\n#   par exemple le label '2' -> [ 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.]\nfrom keras.utils.np_utils import to_categorical\n\ntrain_label_cat = to_categorical(train_label)\ntest100_label_cat = to_categorical(test100_label)","eb9643d8":"# import de Keras \nfrom keras.models import Sequential\nfrom keras.layers import Conv2D\nfrom keras.layers import MaxPooling2D\nfrom keras.layers import Flatten\nfrom keras.layers import Dense","e849c1f8":"# Convolutional Neural Network (CNN)\n\n# Un r\u00e9seau en couches s\u00e9quentielles\nclassifier = Sequential()","c11ad9d8":"# Premier \u00e9tage de convolution - pooling\nclassifier.add(\n    Conv2D(32,                      # Taille du filtre\n           (3, 3),                  # Taille de la fen\u00eatre\n           padding = 'Same',        # Remplissage des bords externes\n           activation=\"relu\",       # Fonction d'activation\n           input_shape=(28, 28, 1)  # Dimension de l'entr\u00e9e (uniquement pour la 1\u00e8re couche)\n          )\n)\n\nclassifier.add(\n    MaxPooling2D(\n        pool_size = (2, 2)\n    )\n)\n\n# Deuxi\u00e8me niveau \nclassifier.add(Conv2D(32, (3, 3), activation=\"relu\"))\nclassifier.add(MaxPooling2D(pool_size = (2, 2)))","c9c216cc":"# Applanissement (\u00e9tranglement)\nclassifier.add(Flatten())","095d217b":"# Couche totalement connect\u00e9e \nclassifier.add(Dense(units = 256, activation = 'relu'))\n\n# Couche de sortie (nos 10 classes-chiffres)\nclassifier.add(Dense(units = 10, activation = 'softmax'))","b7b0d05c":"# Compilation du CNN d\u00e9crit\nclassifier.compile(\n    optimizer = 'adam',\n    loss = 'categorical_crossentropy',\n    metrics = ['accuracy'])","4ed7f805":"# Sauvegarde de la repr\u00e9sentation graphique du r\u00e9seau\n#     Ce fichier sera accessible dans l'onglet 'output' du kernel apr\u00e8s un commit\nfrom keras.utils import plot_model\nplot_model(classifier, to_file='model_classifier_digit.png', show_shapes=True)","3c18583a":"from keras.callbacks import Callback\nimport matplotlib.patches as mpatches\n\nclass AccLossPlotter(Callback):\n    \"\"\"Plot training Accuracy and Loss values on a Matplotlib graph. \n    The graph is updated by the 'on_epoch_end' event of the Keras Callback class\n    # Arguments\n        graphs: list with some or all of ('acc', 'loss')\n        save_graph: Save graph as an image on Keras Callback 'on_train_end' event \n    \"\"\"\n    \n    def __init__ (self, graphs=['acc','loss'], save_graph=False):\n        self.graphs = graphs\n        self.num_subplots = len(graphs)\n        self.save_graph = save_graph\n    \n    \n    def on_train_begin(self, logs={}):\n        self.acc = []\n        self.val_acc = []\n        self.loss = []\n        self.val_loss = []\n        self.epoch_count = 0\n        plt.ion()\n        plt.show()\n\n\n    def on_epoch_end(self, epoch, logs={}):\n        self.epoch_count += 1\n        self.val_acc.append(logs.get('val_acc'))\n        self.acc.append(logs.get('acc'))\n        self.loss.append(logs.get('loss'))\n        self.val_loss.append(logs.get('val_loss'))\n        epochs = [x for x in range(self.epoch_count)]\n\n        count_subplots = 0\n        \n        if 'acc' in self.graphs:\n            count_subplots += 1\n            plt.subplot(self.num_subplots, 1, count_subplots)\n            plt.title('Accuracy')\n            #plt.axis([0,100,0,1])\n            plt.plot(epochs, self.val_acc, color='r')\n            plt.plot(epochs, self.acc, color='b')\n            plt.ylabel('accuracy')\n\n            red_patch = mpatches.Patch(color='red', label='Test')\n            blue_patch = mpatches.Patch(color='blue', label='Train')\n\n            plt.legend(handles=[red_patch, blue_patch], loc=4)\n\n        if 'loss' in self.graphs:\n            count_subplots += 1\n            plt.subplot(self.num_subplots, 1, count_subplots)\n            plt.title('Loss')\n            #plt.axis([0,100,0,5])\n            plt.plot(epochs, self.val_loss, color='r')\n            plt.plot(epochs, self.loss, color='b')\n            plt.ylabel('loss')\n\n            red_patch = mpatches.Patch(color='red', label='Test')\n            blue_patch = mpatches.Patch(color='blue', label='Train')\n\n            plt.legend(handles=[red_patch, blue_patch], loc=4)\n        \n        plt.draw()\n        plt.pause(0.001)\n\n    def on_train_end(self, logs={}):\n        if self.save_graph:\n            plt.savefig('training_acc_loss.png')\n\n","f4ecbfc7":"# http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.metrics.confusion_matrix.html\nfrom sklearn.metrics import confusion_matrix\n\nimport itertools\n\nclass ConfusionMatrixPlotter(Callback):\n    \"\"\"Plot the confusion matrix on a graph and update after each epoch\n    # Arguments\n        X_val: The input values \n        Y_val: The expected output values\n        classes: The categories as a list of string names\n        normalize: True - normalize to [0,1], False - keep as is\n        cmap: Specify matplotlib colour map\n        title: Graph Title\n    \"\"\"\n    def __init__(self, X_val, Y_val, classes, normalize=False, cmap=plt.cm.Blues, title='Confusion Matrix'):\n        self.X_val = X_val\n        self.Y_val = Y_val\n        self.title = title\n        self.classes = classes\n        self.normalize = normalize\n        self.cmap = cmap             # Color map\n        plt.ion()                    # Utilisation de pyplot en mode interactif\n        #plt.show()\n        plt.figure()\n\n        plt.title(self.title)\n        \n\n    def on_train_begin(self, logs={}):\n        pass\n\n    \n    def on_epoch_end(self, epoch, logs={}):\n        \"\"\" A la fin d'un cycle \"\"\"\n        plt.clf()\n        # On \u00e9value le r\u00e9sultat du mod\u00e8le sur toutes les entr\u00e9es de X_val\n        pred = self.model.predict(self.X_val)\n        # On r\u00e9cup\u00e8re l'index de la colonne de plus grande valeur pour toutes les lignes\n        #     du r\u00e9sultat\n        max_pred = np.argmax(pred, axis=1)\n        # On r\u00e9cup\u00e8re l'index de la colonne de plus haute valeur pour toutes les lignes\n        max_y = np.argmax(self.Y_val, axis=1)\n        # On \u00e9value la matrice de confusion\n        cnf_mat = confusion_matrix(max_y, max_pred)\n        \n        # S'il y a une demande de normalisation \n        if self.normalize:\n            cnf_mat = cnf_mat.astype('float') \/ cnf_mat.sum(axis=1)[:, np.newaxis]\n\n        # Seuil \u00e0 la moiti\u00e9 du max\n        thresh = cnf_mat.max() \/ 2.\n        \n        # Pour tous les \u00e9l\u00e9ments du produit cart\u00e9sien (tous les \u00e9l\u00e9ments de la matrice)\n        for i, j in itertools.product(range(cnf_mat.shape[0]), range(cnf_mat.shape[1])):\n            plt.text(j, i, cnf_mat[i, j],                                          \n                         horizontalalignment=\"center\",\n                         color=\"white\" if cnf_mat[i, j] > thresh else \"black\")\n\n        plt.imshow(cnf_mat, interpolation='nearest', cmap=self.cmap)\n\n        # Labels\n        tick_marks = np.arange(len(self.classes))\n        plt.xticks(tick_marks, self.classes, rotation=45)\n        plt.yticks(tick_marks, self.classes)\n\n        plt.colorbar()\n                                                                                                         \n        plt.tight_layout()                                                    \n        plt.ylabel('True label')                                              \n        plt.xlabel('Predicted label')\n            #plt.draw()\n        plt.show()\n        plt.pause(0.001)\n","c197165e":"# plotter : accuracy et loss \u00e0 chaque cycle\nplotterAccLoss = AccLossPlotter(graphs=['acc', 'loss'], save_graph=True)","a2ce0048":"# plotter : matrice de confusion \u00e0 chaque cycle\nclass_names = ['0', '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9']\nplotterCM = ConfusionMatrixPlotter(\n    X_val=train_image,\n    classes=class_names,\n    Y_val=train_label_cat)","4b9c4ed2":"# Entrainement du R\u00e9seau\nepochs= 10        # 20\nbatch_size=90\n\nclassifier.fit(train_image, train_label_cat,\n               batch_size=batch_size,\n               validation_data=(test100_image, test100_label_cat),\n               epochs=epochs, \n               callbacks=[plotterAccLoss,plotterCM])","9f62a745":"# Evaluation des r\u00e9sultats sur les donn\u00e9es de test\nresults = classifier.predict(test100_image)\n# results","b598ca02":"# Sauvegarde des r\u00e9sultats\npred = []\nnumTest = results.shape[0]\n# Pour chacun des items de test\nfor i in range(numTest):\n    # Neurone de sortie de plus grande valeur\n    pred.append(np.argmax(results[i])) \npredictions = np.array(pred) \n\nsample_submission = pd.read_csv('..\/input\/test-100-premiers\/sample_submission100.csv')\nresult=pd.DataFrame({'ImageId':sample_submission.ImageId, 'Label pr\u00e9dit':predictions, 'Classe r\u00e9elle':test100_label})\nresult.to_csv('submission.csv',index=False)","181478f0":"print(result)","c4bb34c5":"# CHPS0942 : TD 2 : Working on MNIST\n\n<!-- > **Attention : sujet en cours de d\u00e9veloppement** -->\n\n## Objectifs\n> - D\u00e9velopper votre premier r\u00e9seau de neurones\n> - D\u00e9marrer un challenge sur la base de MNIST\n\n## Pr\u00e9sentation\n> * La base d'images de chiffres manuscrits am\u00e9ricains est un ensemble mondialement reconnu et sur laquelle de tr\u00e8s nombreux travaux ont \u00e9t\u00e9 r\u00e9alis\u00e9s. \n> * Ces donn\u00e9es sont issues d'un challenge \"Digit Recognizer\". Celui-ci fournit un fichier avec les images d'entrainement (_train.csv_), un fichier d'\u00e9valuation (_test.csv_), et un fichier de soumission des r\u00e9sultats de la classification obtenue sur les donn\u00e9es de 'test'.\n> * Je vous fournis un fichier compl\u00e9mentaire (_test100.csv_) des 100 premiers items du fichier de test dans lequel j'ai ajout\u00e9 la classe.\n> * Les images propos\u00e9es sont des versions centr\u00e9es et retaill\u00e9e. Elles sont de dimension 28x28 pixels en niveau de gris \\[0-255\\].\n> * Les fichiers .csv d'entrainement et de test sont constitu\u00e9 d'une colonne _label_ dont la valeur est s\u00e9mantiquement le nom de la classe (le chiffre associ\u00e9\/dessin\u00e9) et des 28x28 valeurs de pixel\n> * Le fichier .csv d'\u00e9valuation ne contient pas de label\n\n> * __Le travail \u00e0 r\u00e9aliser par vous m\u00eame et \u00e0 rendre se trouve \u00e0 la fin de ce Notebook__\n","ce0acc26":"## Cr\u00e9ation du r\u00e9seau de neurones\nNous allons utiliser un r\u00e9seau en couches s\u00e9quentielles : https:\/\/keras.io\/getting-started\/sequential-model-guide\/ ","9c3767d5":"## Cr\u00e9ation des fonctionnalit\u00e9s pour un affichage de l'\u00e9volution de l'apprentissage","2bf3a367":"# Travail \u00e0 r\u00e9aliser\n1. A partir de ce notebook, essayez plusieurs r\u00e9seaux afin de comparer leurs r\u00e9sultats (_loss_ et _accuracy_) en changeant par exemple les fonctions d'activation, la taille des fen\u00eatres de convolution... \n__Proposez 1 autre r\u00e9seau avec les r\u00e9sultats obtenus sur la base de test.__\n1. On peut aussi utiliser des r\u00e9seaux s\u00e9quentiels auto-associatifs o\u00f9 ce que l'on cherche \u00e0 apprendre c'est que le r\u00e9seau fournisse en sortie une image qui soit le mieux possible identique \u00e0 l'entr\u00e9e. On a : au milieu du r\u00e9seau une couche d'\u00e9tranglement,  1 ou 2 couches de convolution en amont, 1 ou 2 couche de d\u00e9convolution en aval.\n__Proposez 2 r\u00e9seaux et les r\u00e9sultats obtenus sur les tests.__"}}