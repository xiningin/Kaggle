{"cell_type":{"63be9e38":"code","c09d656e":"code","3d940e29":"code","9c8d171a":"code","e354154b":"code","9c19b9a0":"code","a6f20bc7":"code","9d8d787b":"code","34b72f98":"code","3728547f":"code","66debb96":"code","cbb477ae":"code","49e31f3e":"code","aecf67e9":"code","5fd73983":"code","a62ef3cd":"code","cb816957":"code","beda3506":"code","3f9e32d2":"code","1ac9a769":"code","dbe67cc7":"code","f5fcbefc":"code","e72bdc99":"code","1241b344":"code","d83140b4":"code","715ada61":"code","31cf86ef":"code","b5400134":"markdown","2b4616f3":"markdown","51ac425a":"markdown","d71ee3ad":"markdown","77d376a7":"markdown","9967dcb6":"markdown","a4d2c253":"markdown","82a04b71":"markdown","4535aa61":"markdown","25a0e921":"markdown","c8803a3a":"markdown","9be9762e":"markdown","b9782aee":"markdown","90476909":"markdown","7cd9be1f":"markdown"},"source":{"63be9e38":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport librosa\nimport librosa.display\nfrom tqdm import tqdm\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nimport tensorflow as tf\nimport tensorflow.keras.models as models\nimport tensorflow.keras.layers as layers\n\n%matplotlib inline\n%load_ext tensorboard","c09d656e":"from IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"","3d940e29":"CSV_FILE_PATH = \"..\/input\/environmental-sound-classification-50\/esc50.csv\"  # path of csv file\nDATA_PATH = \"..\/input\/environmental-sound-classification-50\/audio\/audio\/44100\/\" # path to folder containing audio files","9c8d171a":"#reading the csv file\ndf = pd.read_csv(CSV_FILE_PATH)\ndf","e354154b":"\ndf = df.drop(['fold','esc10','src_file','take'], axis=1)\ndf","9c19b9a0":"classes = df['category'].unique()\nclasses","a6f20bc7":"class_dict = {i:x for x,i in enumerate(classes)}\nclass_dict","9d8d787b":"sample_df = df.drop_duplicates(subset=['target'])\nsample_df","34b72f98":"signals = {}\nmel_spectrograms = {}\nmfccs = {}\n\nfor row in tqdm(sample_df.iterrows()):  # every row will be like [[index], [filename , target , category]]\n    signal , rate = librosa.load(DATA_PATH+ row[1][0])\n    signals[row[1][2]] = signal    # row[1][2] will be the category of that signal. eg. signal[\"dog\"] = signal of dog sound\n    \n    mel_spec = librosa.feature.melspectrogram(y=signal , sr=rate ,  n_fft=2048, hop_length=512)\n    mel_spec = librosa.power_to_db(mel_spec, ref=np.max)  #visualizing mel_spectrogram directly gives black image. So, coverting from power_to_db is required\n    mel_spectrograms[row[1][2]] = mel_spec\n    \n    mfcc = librosa.feature.mfcc(signal , rate , n_mfcc=13, dct_type=3)\n    mfccs[row[1][2]] = mfcc","3728547f":"def plot_signal(signal):\n    \"\"\"\n    this function will take the signal dictionary and plot the signals\n    \"\"\"\n    fig , axes = plt.subplots(nrows=5 , ncols=2 , sharex =False ,sharey=True,\n                             figsize=(40,20))\n    fig.suptitle('Time series',size=15)\n    i=0\n    for x in range(5):\n        for y in range(2):\n            axes[x,y].set_title(list(signal.keys())[i])\n            axes[x,y].plot(list(signal.values())[i])\n            axes[x,y].get_xaxis().set_visible(False)\n            axes[x,y].get_yaxis().set_visible(False)\n            i +=1","66debb96":"def dis_feature(mfccs, cmap=None):\n    \"\"\"\n    this function will take the mfcc\/mel_spectrogram dictionary and plot the signals\n    \"\"\"\n    fig ,axes= plt.subplots(nrows=5 , ncols=2 , sharex=False, sharey=True , figsize=(40,20))\n    fig.suptitle('mel')\n    i=0\n    for x in range(5):\n        for y in range(2):\n            axes[x,y].set_title(list(mfccs.keys())[i])\n            axes[x,y].imshow(list(mfccs.values())[i], cmap=cmap,interpolation='nearest')\n            axes[x,y].get_xaxis().set_visible(False)\n            axes[x,y].get_yaxis().set_visible(False)\n            i+=1","cbb477ae":"plot_signal(signals)","49e31f3e":"dis_feature(mel_spectrograms)","aecf67e9":"dis_feature(mfccs, cmap='hot')","5fd73983":"X , y = [] , []\nfor data in tqdm(df.iterrows()):\n  sig , sr = librosa.load(DATA_PATH+data[1][0])\n  for i in range(3):\n    n = np.random.randint(0, len(sig)-(sr*2))\n    sig_ = sig[n : int(n+(sr*2))]\n    mfcc_ = librosa.feature.mfcc(sig_ , sr=sr, n_mfcc=13)\n    X.append(mfcc_)\n    y.append(data[1][1])\n\n# convert list to numpy array\nX = np.array(X) \ny = np.array(y)\n\n#one-hot encoding the target\ny = tf.keras.utils.to_categorical(y , num_classes=10)\n\n# our tensorflow model takes input as (no_of_sample , height , width , channel).\n# here X has dimension (no_of_sample , height , width).\n# So, the below code will reshape it to (no_of_sample , height , width , 1).\nX = X.reshape(X.shape[0], X.shape[1], X.shape[2], 1)","a62ef3cd":"X.shape\ny.shape","cb816957":"x_train , x_val , y_train , y_val = train_test_split(X , y ,test_size=0.2, random_state=2020)","beda3506":"INPUTSHAPE = (13,87,1)","3f9e32d2":"model =  models.Sequential([\n                          layers.Conv2D(16 , (3,3),activation = 'relu',padding='valid', input_shape = INPUTSHAPE),\n                          layers.Conv2D(16, (3,3), activation='relu',padding='valid'),\n\n                          layers.Conv2D(32, (3,3), activation='relu',padding='valid'),\n                          layers.Conv2D(32, (3,3), activation='relu',padding='valid'),\n\n                          layers.Conv2D(64, (3,3), activation='relu',padding='valid'),\n                          layers.Conv2D(32, (3,3), activation='relu',padding='valid'),\n                          layers.GlobalAveragePooling2D(),\n\n\n                          layers.Dense(32 , activation = 'relu'),\n                          layers.Dense(10 , activation = 'softmax')\n])\n\nmodel.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics = 'acc')","1ac9a769":"model.summary()","dbe67cc7":"%mkdir \"cpkt\"\n%mkdir \"logs\"","f5fcbefc":"LOGDIR = \"logs\"\nCPKT = \"cpkt\/\"","e72bdc99":"#this callback is used to prevent overfitting.\ncallback_1 = tf.keras.callbacks.EarlyStopping(\n    monitor='val_loss', min_delta=0, patience=3, verbose=0, mode='auto',\n    baseline=None, restore_best_weights=False\n)\n\n#this checkpoint saves the best weights of model at every epoch\ncallback_2 = tf.keras.callbacks.ModelCheckpoint(\n    CPKT, monitor='val_loss', verbose=0, save_best_only=True,\n    save_weights_only=True, mode='auto', save_freq='epoch', options=None\n)\n\n#this is for tensorboard\ntensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=LOGDIR)\n","1241b344":"history = model.fit(x_train,y_train ,\n            validation_data=(x_val,y_val),\n            epochs=100,\n            callbacks = [callback_1 , callback_2 , tensorboard_callback])","d83140b4":"# %tensorboard --logdir=\"logs\"","715ada61":"# Download Ngrok to tunnel the tensorboard port to an external port\n!wget https:\/\/bin.equinox.io\/c\/4VmDzA7iaHb\/ngrok-stable-linux-amd64.zip\n!unzip ngrok-stable-linux-amd64.zip\n\n# Run tensorboard as well as Ngrox (for tunneling as non-blocking processes)\nimport os\nimport multiprocessing\n\n\npool = multiprocessing.Pool(processes = 10)\nresults_of_processes = [pool.apply_async(os.system, args=(cmd, ), callback = None )\n                        for cmd in [\n                        f\"tensorboard --logdir=\\\"logs\\\" --host 0.0.0.0 --port 6006 &\",\n                        \".\/ngrok http 6006 &\"\n                        ]]","31cf86ef":"! curl -s http:\/\/localhost:4040\/api\/tunnels | python3 -c \\\n    \"import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])\"","b5400134":"if running in kaggle kernel use this code.\nthere are some error displaying tensorboard. So,the below code is taken from this amazing kernel.(https:\/\/www.kaggle.com\/shivam1600\/tensorboard-on-kaggle)","2b4616f3":"> Here we extracted two features mel-spectrogram and mfcc.\n> I had tried to use both feature for training and mfcc performed very well.\n> So, here we are going to use mfcc for training.","51ac425a":"[](http:\/\/)","d71ee3ad":"## Step 1. Importing Libraries","77d376a7":"## Step 2. Loading and Preprocessing","9967dcb6":"## Step 4. Getting Data ready for training","a4d2c253":"if running this in google colab use the following code:","82a04b71":"## Step 5. Model","4535aa61":"# Environmental Sound Classification\n\n* this kernel is useful for any audio classification task.\n* the following libraries are used in this kernel\n    1. Tensorflow (for model making and training)\n    2. sklearn (for splitting the data into trian,test,validation)\n    3. librosa (for loading and feature extraction of audio signals)\n    4. pandas (for reading csv file)\n    5. matplotlib (for plotting)","25a0e921":"Taking one sample from each of the 10 classes for visualization","c8803a3a":">**Please upvote if you like my approach or if you learned something from this notebook.\nYour support gives me motivation to create interesting stuff.\nThank you.**","9be9762e":"## Step 3. Visualization\n\n* if you have little or no idea about mel-spectrogram and MFCC visit this site.\n[Introduction to feature extraction](https:\/\/towardsdatascience.com\/how-to-apply-machine-learning-and-deep-learning-methods-to-audio-analysis-615e286fcbbc)","b9782aee":"* Now we are going to take a three random 2 second clip from each audio file. this will increase the data size and also classification speed increases.\n* the following code iterate through every file and take three random clip from it.","90476909":"> use the link in the output of the following section to view in tensorboard.","7cd9be1f":"* editing target column according to the 10 classes."}}