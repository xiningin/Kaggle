{"cell_type":{"a81ad6c8":"code","43274b2b":"code","7487a050":"code","7cc2096b":"code","eced012b":"code","aee9262a":"code","9791ddc9":"code","36603c66":"code","c7d50d36":"code","0f68b17b":"code","7a86f127":"code","88827aea":"code","1dbf798e":"code","4ad55b33":"code","14f44946":"code","fe8696f1":"code","db154ae3":"markdown","6216907e":"markdown","be6cb0b7":"markdown","8d7306b1":"markdown","4b26624a":"markdown","8b9766e3":"markdown","82f5efa4":"markdown","609b2f80":"markdown","5e59ddd4":"markdown","663f9462":"markdown","0dd3d4dc":"markdown","566c20d2":"markdown","e9b98dc9":"markdown","04e9bbf4":"markdown","7f3f027b":"markdown","b0db478c":"markdown","bfb79b19":"markdown","ffd29c41":"markdown","6503d490":"markdown","8449c2da":"markdown","0ba15ff0":"markdown"},"source":{"a81ad6c8":"%matplotlib inline\n\nimport pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches","43274b2b":"df = pd.read_csv(\"..\/input\/NFL Play by Play 2009-2017 (v4).csv\")\ndf.head(10)","7487a050":"df.info()","7cc2096b":"print(\"Rows: \",len(df))","eced012b":"total_interceptions = len(df[df.InterceptionThrown == 1])\nprint(\"Total Count of Interceptions Thrown: \", total_interceptions)\n\ntotal_fumbles = len(df[df.Fumble == 1])\nprint(\"Total Count of Fumbles: \", total_fumbles)\n\ntotal_punts_blocked = len(df[df.PuntResult == 'Blocked'])\nprint(\"Total Count of Blocked Punts: \", total_punts_blocked)\n\ntotal_fg_unsuccessful = len(df[(df.FieldGoalResult == 'Blocked') | (df.FieldGoalResult == 'No Good')])\nprint(\"Total Missed\/Blocked Field Goals: \", total_fg_unsuccessful)\n\n# because I'm not taking into account the hefty logic to determine turnover on downs -- \"Giveaways\"\ntotal_giveaways = total_interceptions + total_fumbles + total_punts_blocked + total_fg_unsuccessful\nprint(\"Total Giveaways: \", total_giveaways)\n\n\n# create a dict object containing the above calculations\ngiveaways = {'Interceptions': [total_interceptions],\n             'Fumbles': [total_fumbles],\n             'Blocked Punts': [total_punts_blocked],\n             'Missed\/Blocked FG': [total_fg_unsuccessful]}\ngiveaways_df = pd.DataFrame.from_dict(giveaways)\n\n# plot the results in a simple bar chart\ngiveaways_df.plot(kind='bar')","aee9262a":"# update data for consistent team names to just label franchises instead of cities to avoid outliers\/ambiguity:\n\n# LA --> LAR (avoid ambiguity with LAC)\ndf.loc[df.posteam == 'LA', 'posteam'] = 'LAR'\ndf.loc[df.DefensiveTeam == 'LA', 'DefensiveTeam'] = 'LAR'\ndf.loc[df.HomeTeam == 'LA', 'HomeTeam'] = 'LAR'\ndf.loc[df.AwayTeam == 'LA', 'AwayTeam'] = 'LAR'\ndf.loc[df.RecFumbTeam == 'LA', 'RecFumbTeam'] = 'LAR'\ndf.loc[df.PenalizedTeam == 'LA', 'PenalizedTeam'] = 'LAR'\ndf.loc[df.SideofField == 'LA', 'PenalizedTeam'] = 'LAR'\n\n# STL --> LAR\ndf.loc[df.posteam == 'STL', 'posteam'] = 'LAR'\ndf.loc[df.DefensiveTeam == 'STL', 'DefensiveTeam'] = 'LAR'\ndf.loc[df.HomeTeam == 'STL', 'HomeTeam'] = 'LAR'\ndf.loc[df.AwayTeam == 'STL', 'AwayTeam'] = 'LAR'\ndf.loc[df.RecFumbTeam == 'STL', 'RecFumbTeam'] = 'LAR'\ndf.loc[df.PenalizedTeam == 'STL', 'PenalizedTeam'] = 'LAR'\ndf.loc[df.SideofField == 'STL', 'PenalizedTeam'] = 'LAR'\n\n# SD --> LAC\ndf.loc[df.posteam == 'SD', 'posteam'] = 'LAC'\ndf.loc[df.DefensiveTeam == 'SD', 'DefensiveTeam'] = 'LAC'\ndf.loc[df.HomeTeam == 'SD', 'HomeTeam'] = 'LAC'\ndf.loc[df.AwayTeam == 'SD', 'AwayTeam'] = 'LAC'\ndf.loc[df.RecFumbTeam == 'SD', 'RecFumbTeam'] = 'LAC'\ndf.loc[df.PenalizedTeam == 'SD', 'PenalizedTeam'] = 'LAC'\ndf.loc[df.SideofField == 'SD', 'PenalizedTeam'] = 'LAC'\n\n# JAC --> JAX\ndf.loc[df.posteam == 'JAC', 'posteam'] = 'JAX'\ndf.loc[df.DefensiveTeam == 'JAC', 'DefensiveTeam'] = 'JAX'\ndf.loc[df.HomeTeam == 'JAC', 'HomeTeam'] = 'JAX'\ndf.loc[df.AwayTeam == 'JAC', 'AwayTeam'] = 'JAX'\ndf.loc[df.RecFumbTeam == 'JAC', 'RecFumbTeam'] = 'JAX'\ndf.loc[df.PenalizedTeam == 'JAC', 'PenalizedTeam'] = 'JAX'\ndf.loc[df.SideofField == 'JAC', 'PenalizedTeam'] = 'JAX'","9791ddc9":"# update data to have an attribute for turnovers:\ndf['Turnover'] = df.apply(lambda x: 1 \n                                 if ((x.InterceptionThrown == 1) | \n                                     (x.Fumble == 1) |\n                                     (x.FieldGoalResult == 'Blocked') |\n                                     (x.FieldGoalResult == 'No Good') |\n                                     (x.PuntResult == 'Blocked'))\n                                 else 0, axis=1)","36603c66":"# disable chained assignments --> for the logic I'm using this is simply an annoying warning and is populating correctly\npd.options.mode.chained_assignment = None \n\n# minimze the dataset for computational efficiency\ndf_scores = df[(df.qtr >= 4)]\n\n# copy the columns(attributes) we declare in the list to a new dataframe to modify\nresults_attributes = ['HomeTeam','AwayTeam','posteam','PosTeamScore','DefensiveTeam','DefTeamScore','GameID','Date','qtr','PlayType','sp','Touchdown','FieldGoalResult','ExPointResult','TwoPointConv','Turnover','Safety','TimeSecs','Drive']\ndf_scores = df_scores[results_attributes]\n\n# apply the lambda funstion to copy the PosTeamScores\/DefTeamScores into HomeTeamScores and AwayTeam Scores\ndf_scores['HomeTeamScore'] = df_scores.apply(lambda x: x.PosTeamScore if x.HomeTeam == x.posteam else x.DefTeamScore, axis=1)\ndf_scores['AwayTeamScore'] = df_scores.apply(lambda x: x.PosTeamScore if x.AwayTeam == x.posteam else x.DefTeamScore, axis=1)\n\nresults_attributes = ['HomeTeam','HomeTeamScore','AwayTeam','AwayTeamScore','posteam','PosTeamScore','DefensiveTeam','DefTeamScore','GameID','Date','qtr','PlayType','sp','Touchdown','FieldGoalResult','ExPointResult','TwoPointConv','Turnover','Safety','TimeSecs','Drive']\ndf_scores = df_scores[results_attributes]\ndf_scores.head(20)","c7d50d36":"# get a list of the indices for the rows that indicate the End of Game\nidx = df_scores[df_scores['PlayType'] == 'End of Game'].index.tolist()\n\n# subtract 1 from the indices to use for accessing the row above the End of Game row\nidx[:] = [x - 1 for x in idx]\n\n# iterate over the list to access the values and copy them into the End of Game rows\nfor x in idx:\n    home_score = df_scores.loc[x, 'HomeTeamScore']\n    away_score = df_scores.loc[x, 'AwayTeamScore']\n    y = x + 1\n    if((df_scores.loc[y, 'PlayType'] == 'End of Game')):\n        df_scores.loc[y, 'HomeTeamScore'] = home_score\n        df_scores.loc[y, 'AwayTeamScore'] = away_score\n\n# subset the dataframe to only include end of game results\nFinal_Results = df_scores[df_scores['PlayType'] == 'End of Game']\nFinal_Results.head(5)","0f68b17b":"# the GameID's that are not already in Final Results - because we already have the final scores for those games\ndf_scores = df_scores[~df_scores.GameID.isin(Final_Results.GameID)]\n\n# Lets filter to only look at scoring plays first\ndf_sp = df_scores[df_scores.sp == 1]\n\n#remove dups\ndf_sp = df_sp.drop_duplicates(subset=['GameID'], keep='last')\n\n# function to add points to the Defensive Team's score whether they are Home or Away\ndef update_def_score(row):\n    if (row['DefensiveTeam'] == row['HomeTeam']):\n        if (row.Safety == 1): # There is a safety\n            row.HomeTeamScore = row.HomeTeamScore+2\n        else: row.HomeTeamScore = row.HomeTeamScore+6\n    else:\n        if (row.Safety == 1): # There is a safety\n            row.AwayTeamScore = row.AwayTeamScore+2\n        else: row.AwayTeamScore = row.AwayTeamScore+6\n        return row\n\ndef update_score(row):\n    if (row['posteam'] == row['AwayTeam']): #posteam is home team\n        if (row.Touchdown == 1): # Touchdown ends game\n            row.AwayTeamScore = row.AwayTeamScore+6\n        elif ((row.PlayType == 'Field Goal')&(row.FieldGoalResult == 'Good')): # Field Goal to win game\n            row.AwayTeamScore = row.AwayTeamScore+3\n        elif ((row.PlayType == 'Extra Point')&(row.ExPointResult == 'made')): # Extra Point seals W\n            row.AwayTeamScore = row.AwayTeamScore+1\n        elif (row.TwoPointConv == 'Success'):\n            row.AwayTeamScore = row.AwayTeamScore+2 # 2-pt conversion successful to win game\n    elif(row['posteam'] == row['HomeTeam']): # posteam is away team\n        if (row.Touchdown == 1): # Touchdown ends game\n            row.HomeTeamScore = row.HomeTeamScore+6\n        elif ((row.PlayType == 'Field Goal')&(row.FieldGoalResult == 'Good')): # Field Goal to win game\n            row.HomeTeamScore = row.HomeTeamScore+3\n        elif ((row.PlayType == 'Extra Point')&(row.ExPointResult == 'made')): # Extra Point seals W\n            row.HomeTeamScore = row.HomeTeamScore+1\n        elif (row.TwoPointConv == 'Success'):\n            row.HomeTeamScore = row.HomeTeamScore+2 # 2-pt conversion successful to win game\n    return row\n\n\n# update the scores using apply(function)\nd_sp = df_sp[((df_sp['Turnover'] == 1)&(df_sp['Touchdown'] == 1))&(df_sp['Safety'] == 1)].apply(update_def_score, axis = 1)\no_sp = df_sp[(df_sp['Turnover'] == 0) & (df_sp['Safety'] == 0)].apply(update_score, axis = 1)\nd_sp = d_sp.append(o_sp)","7a86f127":"# append to Final Results DF\nFinal_Results = Final_Results.append(d_sp)","88827aea":"# the GameID's that are not already in Final Results - because we already have the final scores for those games\ndf_scores = df_scores[~df_scores.GameID.isin(Final_Results.GameID)]\n\n#remove dups\ndf_scores = df_scores.drop_duplicates(subset=['GameID'], keep='last')\n\n\n# append the Non-Scoring endings to the Final Results\nFinal_Results = Final_Results.append(df_scores, sort = True)","1dbf798e":"# remove the duplicates\nFinal_Results = Final_Results.drop_duplicates(subset=['GameID'], keep='last')\nprint('Total Unique Games in the data:             ',len(df.GameID.unique()))\nprint('Total Games in the Final Results DF:        ',len(Final_Results))\nprint('Total Unique Games in the Final Results DF: ',len(Final_Results.GameID.unique()))\n\n\n","4ad55b33":"# drop the listed columns\nnot_needed = ['PosTeamScore', 'DefTeamScore','posteam','DefensiveTeam','qtr','PlayType','sp','Touchdown','FieldGoalResult','ExPointResult','TwoPointConv','Turnover','Safety','TimeSecs']\nFinal_Results = Final_Results.drop(columns=not_needed)\n\n# winning team\nFinal_Results['WinningTeam'] = Final_Results.apply(lambda x: x.HomeTeam if x.HomeTeamScore > x.AwayTeamScore else x.AwayTeam, axis=1)\n\n# point differential between the winning and losing teams\nFinal_Results['PointSpread'] = Final_Results['HomeTeamScore'] - Final_Results['AwayTeamScore']\nFinal_Results['PointSpread'] = Final_Results['PointSpread']\n\n# taking a look:\nFinal_Results.head(5)","14f44946":"WinningTeam = Final_Results['WinningTeam'].value_counts()\nax = WinningTeam.plot.bar(figsize=(22,10),rot=0,)\nax.set_title(\"Each Team's Number of Games Won\", fontsize=24,)\nax.set_xlabel(\"Team\", fontsize=18)\nax.set_ylabel(\"# of Wins\", fontsize=14)\nax.set_alpha(0.8)\n\n# set individual bar lables using above list\nfor i in ax.patches:\n    # get_x: width; get_height: verticle\n    ax.text(i.get_x()+.02, i.get_height()+1, str(round((i.get_height()), 2)), fontsize=10, color='black',rotation=0)","fe8696f1":"result_df = Final_Results.groupby('HomeTeam')['PointSpread'].mean()\nax = result_df.plot.bar(figsize=(22,10),rot=0,color='orange', width=1)\nax.set_title(\"Average Point Differentials by Team\", fontsize=24)\nax.set_xlabel(\"Team\", fontsize=18)\nax.set_ylabel(\"Average Point Differential\", fontsize=14)\nax.set_alpha(0.6)\n","db154ae3":"**This notebook's purpose is to explore NFL data from 2009-2017. The goal is to hopefully provide useful analysis for others to use or to provide useful code for others to learn from.**","6216907e":"<h3>\nLooking at the Data\n<\/h3>\n<body>\n    We can see that the data is particularily encompassing. 102 Columns of data is a lot more data than we'll need while building potential models. This is because more attributes can typically cause over-fitting for any method we decide to impliment.\n    <\/body>","be6cb0b7":"<body>\n    <p>It looks as if the unique counts line up now!<\/p>\n<\/body>","8d7306b1":"<h3>Franchises that Changed Citys<\/h3>\n<body>\n    <p>Because teams like the Las Angeles Chargers and Las Angeles Rams used to be the San Diego Chargers and St.Louis Rams respectively, we must alter the records to be consistent:<\/p>\n<\/body>","4b26624a":"<body>\n    <p>Now that we have our final scores for the Home and Away teams, we can remove the columns that we will no longer need, to further clean things up.<\/p>\n    <p>Secondly, I want to add a column that contains the winning and losing teams for simple aggregation and comparison purposes, followed by computing the absolute difference between the scores.<\/p>\n    <\/body>","8b9766e3":"<h1>\nFinal Outcomes for Games\n<\/h1>\n<body>\n    <p>Before we dive into segmenting our data, we'll need to aquire the final scores for each game. Because the PlayType attribute has an 'End of Game' entry to signify the final results of a game, we can use that to appropriately get the final results; but the issue is that the scores are held in the \"PosTeamScore\" and \"DefTeamScore\" columns, which are 'NA' for the columns where PLayType = 'End of Game' because there isn't a possession team or a defensive team. To appropriately get the scores in a subset, we will have to clean the data and appropriatley match the scores with the home and away teams.<\/p>\n    <p>To begin, the columns indicating score are PosTeamScore and DefTeamScore. One way we can alter the data to show score is by creating 2 new columns that indicate HomeTeamScore and AwayTeamScore, then use that to apply logic in order to populate the 'End of Game' PlayTypes to essentially reflect the final score of each game.<\/p>\n    <p>Below, I am using a lambda function to properly place the Scores into new columns. The logic is: <\/p>\n    <p>**If:** the PosTeam is the same as the HomeTeam, then copy the PosTeamScore into the HomeTeamScore.<\/p>\n    <p>**Else:** Copy the DefTeamScore into the HomeTeamScore column (repeated for AwayTeam as well)<\/p>\n<\/body>","82f5efa4":"<body>\n    <p>Moving onto the plays where sp = 0, which indicates that the final record for the game was not a scoring play.<\/p>\n<\/body>","609b2f80":"<p>**As a Browns Fan:** I don't know why I'm doing this...<\/p>\n<h2>Average Score Differential<\/h2>","5e59ddd4":"<p>That's it for now, but after the Brownies beat Pit in Game 1 I'm sure I'll be back for add on to this!<\/p>","663f9462":"<h1>Graphical Representation<\/h1>","0dd3d4dc":"<h1>NFL ANALYSIS - Series 1: Obtaining the Final Results for Each Game<\/h1>\n<body>\n    <p>This Data origionates from the curtousy of Kaggle user Max Horowitz (@ https:\/\/www.kaggle.com\/maxhorowitz). He has used nflscrapR to obtain the data and also represents https:\/\/www.cmusportsanalytics.com\/. nflscrapeR is an R package engineered to scrape NFL data by researchers Maksim Horowitz, Ron Yurko, and Sam Ventura.<\/p>\n    <p>**Series 1 - Obtaining The Final Result for Each Game:** In this part of the series, I'm going to undergo an ETL processing approach of the data set. There are various issues with calculating the final scores for each game and I will show my methodology to overcome the problems that are associated with doing so.<\/p>\n<\/body>","566c20d2":"<h1>\nImporting Data\n<\/h1>","e9b98dc9":"<h1>\nExploratory Analysis\n<\/h1>","04e9bbf4":"<body>\n    <p>Now the logic is complete and we've successfully updated scores for the rows containing the last instances of the Game ID for the games that do not have a PlayType = End of Game. Each record in the DataFrame containing the game id's for plays that had an ending in which there was a score is now updated with the actualy final score. Now that we know each record is correct, we can safely append it to the Final_Results DataFrame.<\/p>\n<\/body>","7f3f027b":"<h1>Preparing the Data - Data Cleansing<\/h1>\n<body>\n    <p>The data I'm working with is particulariy meaty - 102 columns is a ton of data to work with. The rows and columns hold various indicators that I want to extract for further analysis. One indicator I'm particularily interested in and believe to be sufficiently important to endeavor the process of data cleansing for is the score at the end of the game.<\/p>\n    <p>There are rows in the column 'PlayType' that indicates the 'End of Game', but unfortunately this is only available for 1917 or the 2304 total games. The games that do not have this column vary in a ton of different ways, which means we'll have to endear quite an extensive cleaning process involving a lot of logic.<\/p>\n<\/body>","b0db478c":"<h1>Computing Turnovers<\/h1>\n<body>\n    <p>This is important to know before breaking anything else down. Here, I'm using a lambda function to check for various plays that indicate the offensive team explicitly gave the ball to the other team. The only instance I am not checking for in this attribute is whether a team turned the ball over on downs. This is because a defensive team cannot score a touchdown on a turnover on downs, vs. the others I'm checking for<\/p>\n<\/body>","bfb79b19":"<h4>Adjusting Final Scores for instances where there is not an 'End of Game' indication<\/h4>\n<body>\n    <p>Because not all games end with the incidation of 'End of Game', we must dive further and find the other final scores. This is fairly complicated because of the various end results. A game can end in a Field Goal, Touchdown, Extra Point, Interception, Defensive TD, QB Kneel, Pass, etc.<\/p>\n    <p>Where there is no End of Game, we must look into other ways achieving the final solution. I think the easiest route is to drop the duplicated values and obtain the last indexed value to obtain these plays, which is done at the beginning of the below cell.\n    <\/p>\n    <p>Before I go on, it is also important to know that when there is a scoring play to end a game, the information in the 'scores' attribute is not updated before moving onto the final game. Due to this, we must mannually update and incriment the team scores depending on how the team has scored. We must also consider Defensive touchdowns, so the turnover attribute I had created earlier will come in handy.<\/p>\n    <p>Below, I will first using indexing to my advantage to Read, Update, and Delete records that need to be changed. This is the first, and the more complicated method to clean this dataset up:<\/p>\n<\/body>","ffd29c41":"<body>\n<p>We can see that the scores were correctly copied into new columns. Now, lets deal with those pesky 'NA' values. To do this, I'm finding a list of indices for the rows containing a \"PlayType\" thats indicating the End of Game. Then, by subtracting 1 from each index in the list I can access the row that proceeds the End of Game row. This allows me to copy the values in those rows to the End of Game Rows.<\/p>\n<\/body>","6503d490":"<body>\n    Over the 9 seasons from 2009-2017, the most common turnover was a fumble.\n<\/body>","8449c2da":"<h3>\nFurther Exploration\n<\/h3>\n<body>\n    <p>Taking a look at turnovers:<\/p>\n<\/body>","0ba15ff0":"<h3>Checking The Multiplicity and Adding Parameters<\/h3>"}}