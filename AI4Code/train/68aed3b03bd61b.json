{"cell_type":{"0bff0523":"code","08c202c8":"code","0afcad83":"code","b7d774f4":"code","8d3ae732":"code","450c31cc":"code","17a7fbdf":"code","80a9b8b7":"code","35f8c31e":"code","f50359ab":"code","882cfdb8":"code","d4d062e2":"code","0d5549cc":"markdown","c07f4040":"markdown","7d5162e7":"markdown","b833447e":"markdown","a842f2df":"markdown","7ddf6383":"markdown","4a395b24":"markdown","51097405":"markdown"},"source":{"0bff0523":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nDATADIR='..\/input'\n\n# Any results you write to the current directory are saved as output.","08c202c8":"df = pd.read_csv(os.path.join(DATADIR, 'train.csv'),\n                 dtype={'acoustic_data': np.int16, 'time_to_failure': np.float64})","0afcad83":"class FFTFeatures(object):\n    SEQUENCE_LENGHT = 150_000\n    WINDOW = 4096\n\n    def shape(self):\n        return (self.SEQUENCE_LENGHT \/\/ self.WINDOW, self.WINDOW \/\/ 2, 2)\n\n    def generate(self, df: pd.DataFrame, predict=False):\n        \"\"\" Convert a signal into frequency space with amplitude and phase\n            per frequency.\n        \"\"\"\n        steps = self.shape()[0]\n        bsize = steps * self.WINDOW\n        offset = self.SEQUENCE_LENGHT - bsize\n        data = df['acoustic_data'].values[offset:].reshape(steps, -1)\n        yf = np.fft.fft(data)\n        yf = yf[:, : self.WINDOW \/\/ 2]\n        yf = yf \/ self.WINDOW\n        epsilon = 1.0e-9\n        X = np.stack([np.log(np.abs(yf) + epsilon), np.angle(yf)], axis=2)\n        if predict:\n            return X\n        y = df['time_to_failure'].iloc[df.shape[0] - 1]\n        return X, np.array([y])\n\n\ndef fft_invert(X: np.array, datapoints=4096) -> np.array:\n    \"\"\" Convert a signal from frequency to temporal domain \n    \"\"\"\n    assert X.shape == (2048, 2)\n    x = np.linspace(0, 1, datapoints)\n    f = np.fft.fftfreq(X.shape[0] * 2, d=1\/(X.shape[0] * 2))\n\n    m = np.outer(x, f)\n    amp = np.exp(X[:, 0])\n    phase = X[:, 1]\n    p = np.concatenate([phase, np.array([0]), np.flip(-phase[1:])])\n    a = np.concatenate([amp, np.array([0]), np.flip(amp[1:])])\n    ys = np.dot(np.cos(2 * np.pi * m + p), a)\n    return ys\n","b7d774f4":"%matplotlib inline\nimport matplotlib.pyplot as plt\n\ndef show_signal_and_recon(df: pd.DataFrame, Xs: np.array):\n    start = 0\n    end = start + 150_000\n    step = 10\n    fig, axes = plt.subplots(2, 1, figsize=(40, 16), sharex=True)\n    ax1 = axes[0]\n    ax1.set_ylim((-100, 100))\n    ax1.set_title('Signal')\n    ax1.plot(df_sample[start:end:step]['acoustic_data'].values, color='b')\n    ax1.set_ylabel('signal', color='b')\n    ax2 = ax1.twinx()\n    ax2.plot(df_sample[start:end:step]['time_to_failure'].values, color='r')\n    ax2.set_ylabel('ttf', color='r')\n    ax3 = axes[1]\n    ax3.set_ylim((-100, 100))\n    ax3.set_title('Reconstructed signal')\n    ax3.plot(Xs[start:end:step], color='g')\n    plt.show()\n\ndef fftseq_to_signal(X: np.array):\n    Xs = np.zeros((150_000, 1))\n    offset = 150_000 - (FFTFeatures().shape()[0] * 4096)\n    for i in range(X.shape[0]):\n        Xs[offset:offset+4096] = fft_invert(X[i])[:, np.newaxis]\n        offset += 4096\n    return Xs","8d3ae732":"# select an arbitrary signal sample\n\nstart = 200 * 150_000\ndf_sample = df[start:start+150_000]\n\nX = FFTFeatures().generate(df_sample, True)\nXs = fftseq_to_signal(X)\nshow_signal_and_recon(df_sample, Xs)","450c31cc":"from matplotlib import animation, rc\nfrom IPython.display import HTML\n\ndef show_frequency_amp(X: np.array):\n    fig, ax = plt.subplots(figsize=(12, 4))\n    rects = ax.bar(np.arange(2048), np.exp(X[0, :, 0]), log=True)\n    def init():\n        return rects\n    def animate(i):\n        for j, rect in enumerate(rects):\n            rect.set_height(np.exp(X[i, j, 0]))\n        return rects\n    anim = animation.FuncAnimation(\n        fig, animate, init_func=init,\n        frames=FFTFeatures().shape()[0], interval=360, blit=True, repeat=False)\n    plt.close(anim._fig)\n    return anim\n\nanim = show_frequency_amp(X)\nHTML(anim.to_jshtml())","17a7fbdf":"def apply_filter(X, filter_fn):\n    Xf = np.empty(X.shape)\n    for ts in range(X.shape[0]):\n        Xf[ts] = filter_fn(X[ts])\n    return Xf\n\ndef filter_sigma(X, sigma=1):\n    epsilon = 1.0e-9\n    m = np.mean(X[:, 0])\n    d = np.std(X[:, 0])\n    idx = np.where(X[:, 0] < (m + sigma * d))[0]\n    Xp = X.copy()\n    Xp[idx, 0] = np.log(epsilon)\n    return Xp\n\nXs_f0 = fftseq_to_signal(apply_filter(X, filter_sigma))\nshow_signal_and_recon(df_sample, Xs_f0)","80a9b8b7":"def peak_frequencies(X: np.array, k_peak = 1, k_freq = 4):\n    \"\"\" Compute what frequencies contribute the most to the top peaks.\n    \"\"\"\n    amp = X[:, 0]\n    phase = X[:, 1]\n    x = np.linspace(0, 1, 4096)\n    f = np.fft.fftfreq(amp.size * 2, d=1\/(amp.size * 2))\n\n    m = np.outer(x, f)\n    p = np.concatenate([phase, np.array([0]), np.flip(-phase[1:])])\n    fs = np.cos(2 * np.pi * m + p)\n    \n    a = np.exp(amp)\n    a = np.concatenate([a, np.array([0]), np.flip(a[1:])])\n    # ys is the reconstructuted signal in temporal domain\n    ys = np.dot(fs, a)\n\n    # min amplitude\n    l_idx = np.argpartition(ys, k_peak)[:k_peak]\n\n    # Ax = b, where A = cos ( [time x frequency] + phase )\n    # indices in b correspond to rows in A.\n    # indices correspond to a time slot, each time slot is\n    # Sum ( cos(f + p) . amp )\n\n    l_val = fs[l_idx]\n    l_m = np.einsum('ij,j->ij', l_val, a)\n    l_freq = np.argpartition(l_m, k_freq, axis=1)[:, :k_freq]\n\n    # max amplitude\n    h_idx = np.argpartition(ys, -k_peak)[-k_peak:]\n    h_val = fs[h_idx]\n    h_m = np.einsum('ij,j->ij', h_val, a)\n    h_freq = np.argpartition(l_m, -k_freq, axis=1)[:, -k_freq:]\n\n    # convert negative frequencies (> 2k) into positives\n    cond = l_freq > 2048\n    l_freq[cond] = 4096 - l_freq[cond] + 1\n    cond = h_freq > 2048\n    h_freq[cond] = 4096 - h_freq[cond] + 1    \n\n    freq = set(l_freq.flatten())\n    freq |= set(h_freq.flatten())\n    return list(freq)\n","35f8c31e":"def filter_peek_frequencies(X, k_peak=2, k_freq=16):\n    epsilon = 1.0e-9\n    Xp = np.zeros(X.shape)\n    Xp[:, 0] = np.log(epsilon)\n    frequencies = peak_frequencies(X, k_peak, k_freq)\n    Xp[frequencies, :] = X[frequencies, :]\n    return Xp\n\nXs_f1 = fftseq_to_signal(apply_filter(X, filter_peek_frequencies))\nshow_signal_and_recon(df_sample, Xs_f1)","f50359ab":"import random\n\ndef segment_peak_frequencies(X):\n    counts = np.zeros((2048, ))\n    for ts in range(X.shape[0]):\n        freqs = peak_frequencies(X[ts], 4, 16)\n        counts[freqs] += 1\n    return counts\n\n# pick n samples\nN_SAMPLES = 10\nfig, axes = plt.subplots(N_SAMPLES, 1, figsize=(10, 20), sharex=True)\nfor i, ax in enumerate(axes):\n    idx = random.randint(0, df.shape[0] \/\/ 150_000)\n    df_xsample = df[idx * 150_000: (idx + 1) * 150_000]\n    Xi = FFTFeatures().generate(df_xsample, True)\n    counts = segment_peak_frequencies(Xi)\n    ax.set_title(str(df_xsample['time_to_failure'].iloc[-1]))\n    ax.bar(np.arange(2048), counts)\n    ax.set_ylim((0, 30))\nplt.show()","882cfdb8":"TOP_FREQUENCIES = [\n    slice(140, 150),\n    slice(160, 200),\n    slice(210, 300),\n]\n\ndef filter_top_frequencies(X):\n    epsilon = 1.0e-9\n    Xp = np.zeros(X.shape)\n    Xp[:, 0] = np.log(epsilon)\n    for r in TOP_FREQUENCIES:\n        Xp[r, :] = X[r, :]\n    return Xp\n\nXs_f2 = fftseq_to_signal(apply_filter(X, filter_top_frequencies))\nshow_signal_and_recon(df_sample, Xs_f2)","d4d062e2":"def show_top_frequency(X: np.array):\n    size = 0\n    for r in TOP_FREQUENCIES:\n        size += r.stop - r.start\n    Xp = np.empty((X.shape[0], size,))\n\n    offset = 0\n    for r in TOP_FREQUENCIES:\n        rsize = r.stop - r.start\n        Xp[:, offset:offset + rsize] = np.exp(X[:, r, 0])\n        offset += rsize\n\n    fig, ax = plt.subplots(figsize=(12, 4))\n\n    xaxis = []\n    for r in TOP_FREQUENCIES:\n        xaxis.append(np.arange(r.start, r.stop))\n    xaxis = np.concatenate(xaxis)\n\n    rects = ax.bar(xaxis, Xp[0], log=True)\n    ax.set_ylim((np.min(Xp), np.max(Xp)))\n\n    def init():\n        return rects\n    def animate(i):\n        for j, rect in enumerate(rects):\n            rect.set_height(Xp[i, j])\n        return rects\n    anim = animation.FuncAnimation(\n        fig, animate, init_func=init,\n        frames=FFTFeatures().shape()[0], interval=360, blit=True, repeat=False)\n    plt.close(anim._fig)\n    return anim\n\nanim = show_top_frequency(X)\nHTML(anim.to_jshtml())","0d5549cc":"Calculate frequencies that contribute to the signal amplitide peaks","c07f4040":"Show an example 150_000 datapoint segment and the reconstructed signal without any filtering.","7d5162e7":"Zoom in on the top frequencies.","b833447e":"Generate a filter eliminates all frequencies bellow mean + sigma. The signal looks the same with sigma = 1.","a842f2df":"Create an animation of the amplitudes in the frequency domain.","7ddf6383":"# FFT\n\nThis notebook converts the signal from a 150_000 datapoint segment from temporal to frequency domain and back.\nProcessing the signal in terms of frequencies can be useful in terms of denoising it. For instance by removing lower amplitude frequencies.\n\nVisualizing the reconstructued signal after filtering is very useful in terms of experimenting with filters.","4a395b24":"There a small number of frequencies that seem to account for most of the signal peaks, even across a random distribution of samples.","51097405":"Show only the top frequencies at the peaks. The example bellow selects the top 2 positive and negative peaks for each 4k block and select 16 frequencies from each."}}