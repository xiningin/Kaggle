{"cell_type":{"bfbb325f":"code","a1e675cc":"code","25398d47":"code","eb1ea88b":"code","c8539333":"code","40e18543":"code","8f35751c":"code","5ebe0cbd":"code","2aa991f0":"code","11c128ed":"code","a75cb3bc":"code","7246d2b2":"code","13531382":"code","7fa3aa81":"code","44ab96ee":"code","ccb28e51":"code","3af5cd8e":"code","5f0d0140":"code","fc788dce":"markdown","3131bd4d":"markdown","3fd0b876":"markdown","36a703d4":"markdown","a512d335":"markdown","cc91210b":"markdown","92e9957f":"markdown","188193b4":"markdown","be08e818":"markdown","98a28798":"markdown","d34af8f9":"markdown","a3eb9152":"markdown","984f2b43":"markdown","c8f3d647":"markdown","e29d175b":"markdown"},"source":{"bfbb325f":"!pip install kaggle-environments -U","a1e675cc":"# run this if using kaggle notebooks\n!cp -r ..\/input\/lux-ai-2021\/* .","25398d47":"from kaggle_environments import make\n# pick interesting seed shown in tutorial\n# https:\/\/www.kaggle.com\/stonet2000\/lux-ai-season-1-jupyter-notebook-tutorial\nenv = make(\"lux_ai_2021\", configuration={\"seed\": 562124210, \"loglevel\": 2}, debug=True)\n# env = make(\"lux_ai_2021\", configuration={\"seed\": 562124210, \"loglevel\": 0}, debug=True)","eb1ea88b":"from lux.game import Game\nfrom lux.game_map import Cell, RESOURCE_TYPES, Position\nfrom lux.constants import Constants\nfrom lux.game_constants import GAME_CONSTANTS\nfrom lux import annotate\nimport networkx as nx\nimport math\nimport sys\nimport random","c8539333":"north = (\"move\", Constants.DIRECTIONS.NORTH)\neast = (\"move\", Constants.DIRECTIONS.EAST)\nsouth = (\"move\", Constants.DIRECTIONS.SOUTH)\nwest = (\"move\", Constants.DIRECTIONS.WEST)\ncenter = (\"move\", Constants.DIRECTIONS.CENTER)\ncity = (\"city\", )\n# transfer = (\"transfer\", dest_id, resourceType, amount)\npillage = (\"pillage\", )","40e18543":"research = (\"research\", )\nworker = (\"worker\", )\ncart = (\"cart\", )","8f35751c":"# traveller = (\"traveller\", pos)\n# citizen = (\"citizen\", city)","5ebe0cbd":"smart_worker = (\"smart_worker\", )\nsmart_cart = (\"smart_cart\", )","2aa991f0":"# snippet to find the closest city tile to a position\ndef find_closest_city_tile(pos, player):\n    closest_city_tile = None\n    if len(player.cities) > 0:\n        closest_dist = math.inf\n        # the cities are stored as a dictionary mapping city id to the city object, which has a citytiles field that\n        # contains the information of all citytiles in that city\n        for k, city in player.cities.items():\n            for city_tile in city.citytiles:\n                dist = city_tile.pos.distance_to(pos)\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_city_tile = city_tile\n    return closest_city_tile","11c128ed":"# this snippet finds all resources stored on the map and puts them into a list so we can search over them\ndef find_resources(game_state):\n    resource_tiles: list[Cell] = []\n    width, height = game_state.map_width, game_state.map_height\n    for y in range(height):\n        for x in range(width):\n            cell = game_state.map.get_cell(x, y)\n            if cell.has_resource():\n                resource_tiles.append(cell)\n    return resource_tiles\n\n# the next snippet finds the closest resources that we can mine given position on a map\ndef find_closest_resources(pos, player, resource_tiles):\n    closest_dist = math.inf\n    closest_resource_tile = None\n    for resource_tile in resource_tiles:\n        # we skip over resources that we can't mine due to not having researched them\n        if resource_tile.resource.type == Constants.RESOURCE_TYPES.COAL and not player.researched_coal(): continue\n        if resource_tile.resource.type == Constants.RESOURCE_TYPES.URANIUM and not player.researched_uranium(): continue\n        dist = resource_tile.pos.distance_to(pos)\n        if dist < closest_dist:\n            closest_dist = dist\n            closest_resource_tile = resource_tile\n    return closest_resource_tile","a75cb3bc":"class City(object):\n    \n    def __init__(self, observation, pos_list):\n        self.game_state = Game()\n        self.game_state._initialize(observation[\"updates\"])\n        self.game_state._update(observation[\"updates\"][2:])\n        self.game_state.id = observation.player\n        self.width, self.height = self.game_state.map.width, self.game_state.map.height\n        \n        self.player = self.game_state.players[observation.player]\n        self.opponent = self.game_state.players[(observation.player + 1) % 2]\n        self.resource_tiles = find_resources(self.game_state)\n        \n        self.pos_list = pos_list\n        self.city_tiles = []\n        self.city_tiles_to_build = []\n        for pos in pos_list:\n            tile = self.game_state.map.get_cell_by_pos(pos)\n            if tile.citytile is None:  # not already a citytile\n                if not tile.has_resource():  # not resource\n                    self.city_tiles_to_build.append(tile)\n            else:\n                self.city_tiles.append(tile)\n        \n    def update(self, observation):\n        self.game_state._update(observation[\"updates\"])\n        \n        self.player = self.game_state.players[observation.player]\n        self.opponent = self.game_state.players[(observation.player + 1) % 2]\n        self.resource_tiles = find_resources(self.game_state)\n        \n        self.city_tiles = []\n        self.city_tiles_to_build = []\n        for pos in self.pos_list:\n            tile = self.game_state.map.get_cell_by_pos(pos)\n            if tile.citytile is None:  # not already a citytile\n                if not tile.has_resource():  # not resource\n                    self.city_tiles_to_build.append(tile)\n            else:\n                self.city_tiles.append(tile)\n                \n    def update_pos_list(self, pos_list):\n        self.pos_list = pos_list\n        self.city_tiles = []\n        self.city_tiles_to_build = []\n        for pos in pos_list:\n            tile = self.game_state.map.get_cell_by_pos(pos)\n            if tile.citytile is None:  # not already a citytile\n                if not tile.has_resource():  # not resource\n                    self.city_tiles_to_build.append(tile)\n            else:\n                self.city_tiles.append(tile)\n                \n    def find_closest_resources(self, pos):\n        closest_dist = math.inf\n        closest_resource_tile = None\n        for resource_tile in self.resource_tiles:\n            # we skip over resources that we can't mine due to not having researched them\n            if resource_tile.resource.type == Constants.RESOURCE_TYPES.COAL and not self.player.researched_coal(): continue\n            if resource_tile.resource.type == Constants.RESOURCE_TYPES.URANIUM and not self.player.researched_uranium(): continue\n            dist = resource_tile.pos.distance_to(pos)\n            if dist < closest_dist:\n                closest_dist = dist\n                closest_resource_tile = resource_tile\n        return closest_resource_tile\n\n    def distance_to_resources(self, pos):\n        closest_dist = 1000\n        closest_resource_tile = None\n        for resource_tile in self.resource_tiles:\n            # we skip over resources that we can't mine due to not having researched them\n            if resource_tile.resource.type == Constants.RESOURCE_TYPES.COAL and not self.player.researched_coal(): continue\n            if resource_tile.resource.type == Constants.RESOURCE_TYPES.URANIUM and not self.player.researched_uranium(): continue\n            dist = resource_tile.pos.distance_to(pos)\n            if dist < closest_dist:\n                closest_dist = dist\n                closest_resource_tile = resource_tile\n        return closest_dist\n    \n    def find_closest_city_tile(self, pos):\n        closest_city_tile = None\n        if len(self.city_tiles) > 0:\n            closest_dist = math.inf\n            for city_tile in self.city_tiles:\n                dist = city_tile.pos.distance_to(pos)\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_city_tile = city_tile\n        return closest_city_tile\n    \n    def distance_to_city_tile(self, pos):\n        closest_city_tile = None\n        closest_dist = 1000\n        if len(self.city_tiles) > 0:\n            closest_dist = 1000\n            for city_tile in self.city_tiles:\n                dist = city_tile.pos.distance_to(pos)\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_city_tile = city_tile\n        return closest_dist\n    \n    def find_empty_city_tile(self, pos):\n        closest_city_tile = None\n        if len(self.city_tiles_to_build) > 0:\n            closest_dist = math.inf\n            for city_tile in self.city_tiles_to_build:\n                dist = city_tile.pos.distance_to(pos)\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_city_tile = city_tile\n        return closest_city_tile\n    \n    def distance_to_empty_city_tile(self, pos):\n        closest_city_tile = None\n        closest_dist = 1000\n        if len(self.city_tiles_to_build) > 0:\n            closest_dist = 1000\n            for city_tile in self.city_tiles_to_build:\n                dist = city_tile.pos.distance_to(pos)\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_city_tile = city_tile\n        return closest_dist\n    \n    def worker_action(self, unit):\n        # returns list of (pos_x, pos_y, score, action)\n        res_list = []\n        pos_0 = unit.pos\n        pos_1 = unit.pos.translate(Constants.DIRECTIONS.NORTH, 1)\n        pos_2 = unit.pos.translate(Constants.DIRECTIONS.EAST, 1)\n        pos_3 = unit.pos.translate(Constants.DIRECTIONS.SOUTH, 1)\n        pos_4 = unit.pos.translate(Constants.DIRECTIONS.WEST, 1)\n        \n        d0_empty_city = self.distance_to_empty_city_tile(pos_0)\n        d1_empty_city = self.distance_to_empty_city_tile(pos_1)\n        d2_empty_city = self.distance_to_empty_city_tile(pos_2)\n        d3_empty_city = self.distance_to_empty_city_tile(pos_3)\n        d4_empty_city = self.distance_to_empty_city_tile(pos_4)\n        \n        d0_city = self.distance_to_city_tile(pos_0)\n        d1_city = self.distance_to_city_tile(pos_1)\n        d2_city = self.distance_to_city_tile(pos_2)\n        d3_city = self.distance_to_city_tile(pos_3)\n        d4_city = self.distance_to_city_tile(pos_4)\n        \n        d0_resource = self.distance_to_resources(pos_0)\n        d1_resource = self.distance_to_resources(pos_1)\n        d2_resource = self.distance_to_resources(pos_2)\n        d3_resource = self.distance_to_resources(pos_3)\n        d4_resource = self.distance_to_resources(pos_4)\n        \n        v0 = 0\n        v1 = 0\n        v2 = 0\n        v3 = 0\n        v4 = 0\n        \n        # build city\n        if unit.get_cargo_space_left() == 0:\n            if d0_empty_city == 1000:\n                pass\n            else:\n                if d0_empty_city == 0:\n                    res_list.append((pos_0.x, pos_0.y, 1000, unit.build_city()))\n                else:\n                    v0 += 900 - 100 * d0_empty_city\n                    v1 += 900 - 100 * d1_empty_city\n                    v2 += 900 - 100 * d2_empty_city\n                    v3 += 900 - 100 * d3_empty_city\n                    v4 += 900 - 100 * d4_empty_city\n            # may hit to a city, but that's better than wandering\n        else:\n            v0 += - 5 * d0_empty_city\n            v1 += - 5 * d1_empty_city\n            v2 += - 5 * d2_empty_city\n            v3 += - 5 * d3_empty_city\n            v4 += - 5 * d4_empty_city\n            \n        # back to city\n        resource_in_cargo = 100 - unit.get_cargo_space_left()\n        if resource_in_cargo > 0:\n            v0 += resource_in_cargo - 10 * d0_city\n            v1 += resource_in_cargo - 10 * d1_city\n            v2 += resource_in_cargo - 10 * d2_city\n            v3 += resource_in_cargo - 10 * d3_city\n            v4 += resource_in_cargo - 10 * d4_city\n        elif self.game_state.turn % 40 >= 28:\n            # back if night is coming\n            v0 += - 1000 * d0_city\n            v1 += - 1000 * d1_city\n            v2 += - 1000 * d2_city\n            v3 += - 1000 * d3_city\n            v4 += - 1000 * d4_city\n        \n        # new resource\n        if resource_in_cargo < 100:\n            v0 += 3 * (100 - resource_in_cargo - 10 * d0_resource)\n            v1 += 3 * (100 - resource_in_cargo - 10 * d1_resource)\n            v2 += 3 * (100 - resource_in_cargo - 10 * d2_resource)\n            v3 += 3 * (100 - resource_in_cargo - 10 * d3_resource)\n            v4 += 3 * (100 - resource_in_cargo - 10 * d4_resource)\n        \n        # do not go out at night\n        # need to be more precise to work\n        if self.game_state.turn % 40 >= 28 and resource_in_cargo == 0:\n            if d0_resource > 1 and d0_city > 0:\n                v0 = -10000\n            if d1_resource > 1 and d1_city > 0:\n                v1 = -10000\n            if d2_resource > 1 and d2_city > 0:\n                v2 = -10000\n            if d3_resource > 1 and d3_city > 0:\n                v3 = -10000\n            if d4_resource > 1 and d4_city > 0:\n                v4 = -10000\n            \n        # build is better than stay\n        if len(res_list) == 0:\n            res_list.append((pos_0.x, pos_0.y, v0, unit.move(Constants.DIRECTIONS.CENTER)))\n        if pos_1.y >= 0:\n            res_list.append((pos_1.x, pos_1.y, v1, unit.move(Constants.DIRECTIONS.NORTH)))\n        if pos_2.x < self.width:\n            res_list.append((pos_2.x, pos_2.y, v2, unit.move(Constants.DIRECTIONS.EAST)))\n        if pos_3.y < self.height:\n            res_list.append((pos_3.x, pos_3.y, v3, unit.move(Constants.DIRECTIONS.SOUTH)))\n        if pos_4.x >= 0:\n            res_list.append((pos_4.x, pos_4.y, v4, unit.move(Constants.DIRECTIONS.WEST)))\n        # print(unit.id, res_list)\n\n        return res_list","7246d2b2":"# test for min cost max flow\n\naction_dict = {'u_1': [(3, 27, 265, 'm u_1 c'), (3, 26, 270, 'm u_1 n'), (4, 27, 290, 'm u_1 e'), (3, 28, 295, 'm u_1 s'), (2, 27, 270, 'm u_1 w')]}\nactions = []\n\nimport networkx as nx\n\nn_units = len(action_dict.keys())\nG = nx.DiGraph()\nG.add_node(0, demand=-n_units)\nG.add_node(1, demand=n_units)\n\nunit_name_dict = dict()\n\n# source -> unit\nedge_list_1 = [(0, 32 * i + j + 2, 0) for i in range(32) for j in range(32)]\nG.add_weighted_edges_from(edge_list_1)\n# unit -> position\nedge_list_2 = []\nfor i, k in enumerate(action_dict.keys()):\n    for x, y, c, _ in action_dict[k]:\n        edge_list_2.append((i + 2, 10000 + 32 * x + y, -c))\nG.add_weighted_edges_from(edge_list_2)\n# position -> sink\nedge_list_3 = [(10000 + 32 * i + j, 1, 0) for i in range(32) for j in range(32)]\nG.add_weighted_edges_from(edge_list_3)\n\nfor (i, j) in G.edges():\n    G[i][j][\"capacity\"] = 1\n    \nres = nx.min_cost_flow(G)\n\nfor i, k in enumerate(action_dict.keys()):\n    for x, y, c, command in action_dict[k]:\n        if res[i + 2][10000 + 32 * x + y] == 1:\n            if command != \"\":\n                actions.append(command)\n                \nprint(actions)","13531382":"class SmartCommand(object):\n    \n    def __init__(self, observation):\n        self.game_state = Game()\n        self.game_state._initialize(observation[\"updates\"])\n        self.game_state._update(observation[\"updates\"][2:])\n        self.game_state.id = observation.player\n        self.width, self.height = self.game_state.map.width, self.game_state.map.height\n        \n        self.player = self.game_state.players[observation.player]\n        self.opponent = self.game_state.players[(observation.player + 1) % 2]\n        self.citytile_count = 0\n        self.unit_count = 0\n        self.resource_tiles = find_resources(self.game_state)\n        \n    def update(self, observation):\n        self.game_state._update(observation[\"updates\"])\n        \n        self.player = self.game_state.players[observation.player]\n        self.opponent = self.game_state.players[(observation.player + 1) % 2]\n        self.citytile_count = 0\n        self.unit_count = 0\n        self.resource_tiles = find_resources(self.game_state)\n        \n    def unit_action(self, unit, action):\n        if action[0] == \"move\":\n            return unit.move(action[1])\n        elif action[0] == \"city\":\n            self.citytile_count += 1\n            return unit.build_city()\n        elif action[0] == \"pillage\":\n            return unit.pillage()\n        elif action[0] == \"transfer\":\n            return unit.transfer(action[1], action[2], action[3])  # dest_id, resourceType, amount\n        elif action[0] == \"traveller\":\n            pos = action[1]\n            if unit.pos.equals(pos):\n                return unit.move(Constants.DIRECTIONS.CENTER)\n            else:\n                unit.move(unit.pos.direction_to(pos))\n        elif action[0] == \"builder\":\n            pos_list = action[1]\n            # empty tile > resource > city\n            \n            for pos in pos_list:\n                cell = self.game_state.map.get_cell_by_pos(pos)\n                if cell.citytile is None:  # already a citytile\n                    break\n            else:\n                return self.unit_action(unit, (\"citizen\", ))\n            if cell.has_resource():  # resource\n                if unit.get_cargo_space_left() == 0:\n                    new_tile = find_closest_city_tile(pos, self.player)\n                    if new_tile is not None:\n                        new_pos = new_tile.pos  # nearest citytile\n                    else:\n                        new_tile = find_closest_resources(pos, self.player, self.resource_tiles)\n                        if new_tile is not None:\n                            new_pos = new_tile.pos  # nearest resource\n                        else:\n                            new_pos = unit.pos\n                    return unit.move(unit.pos.direction_to(new_pos))\n                else:\n                    return unit.move(unit.pos.direction_to(pos))\n            else:\n                if unit.get_cargo_space_left() == 0:\n                    if unit.pos.equals(pos):\n                        self.citytile_count += 1\n                        return unit.build_city()\n                    else:\n                        return unit.move(unit.pos.direction_to(pos))\n                else:\n                    if unit.pos.equals(pos):\n                        new_tile = find_closest_resources(pos, self.player, self.resource_tiles)\n                        if new_tile is not None:\n                            new_pos = new_tile.pos  # nearest resource\n                        else:\n                            nnew_pos = pos\n                        return unit.move(unit.pos.direction_to(new_pos))\n                    else:\n                        return unit.move(unit.pos.direction_to(pos))\n        elif action[0] == \"citizen\":\n            new_tile = find_closest_city_tile(unit.pos, self.player)\n            if new_tile is not None:\n                new_pos = new_tile.pos  # nearest citytile\n                if unit.pos.distance_to(new_pos) >= 3:  # return anyway \n                    return unit.move(unit.pos.direction_to(new_pos))\n                elif unit.get_cargo_space_left() <= 10:\n                    return unit.move(unit.pos.direction_to(new_pos))\n                else:\n                    new_tile = find_closest_resources(unit.pos, self.player, self.resource_tiles)\n                    if new_tile is not None:\n                        new_pos = new_tile.pos  # nearest resource\n                    else:\n                        new_pos = unit.pos\n                    return unit.move(unit.pos.direction_to(new_pos))\n            else:\n                new_tile = find_closest_resources(unit.pos, self.player, self.resource_tiles)\n                if new_tile is not None:\n                    new_pos = new_tile.pos  # nearest resource\n                else:\n                    new_pos = unit.pos\n                return unit.move(unit.pos.direction_to(new_pos))\n        return None\n\n\n    def city_tile_action(self, city_tile, action):\n        if action[0] == \"research\":\n            return city_tile.research()\n        elif action[0] == \"worker\":\n            self.unit_count += 1\n            return city_tile.build_worker()\n        elif action[0] == \"cart\":\n            self.unit_count += 1\n            return city_tile.build_cart()\n        elif action[0] == \"smart_worker\":\n            if self.unit_count < self.citytile_count:\n                self.unit_count += 1\n                return city_tile.build_worker()\n            else:\n                return city_tile.research()\n        elif action[0] == \"smart_cart\":\n            if self.unit_count < self.citytile_count:\n                self.unit_count += 1\n                return city_tile.build_cart()\n            else:\n                return city_tile.research()\n        return None","7fa3aa81":"city_0_pos_list_0 = [\n    Position(2, 27), Position(2, 28), Position(3, 27), Position(3, 28), \n]\ncity_0_pos_list_1 = [\n    Position(2, 26), Position(2, 27), Position(2, 28), \n    Position(3, 26), Position(3, 27), Position(3, 28), \n    Position(4, 26), Position(4, 27), Position(4, 28), \n]\ncity_0_pos_list_2 = [\n    Position(2, 26), Position(2, 27), Position(2, 28), Position(2, 29), \n    Position(3, 26), Position(3, 27), Position(3, 28), Position(3, 29), \n    Position(4, 26), Position(4, 27), Position(4, 28), Position(4, 29), \n    Position(5, 26), Position(5, 27), Position(5, 28), Position(5, 29), \n]","44ab96ee":"sc = None\ncity_0 = None\n\ndef semi_manual_agent(observation, configuration):\n\n    global sc\n    global city_0\n    \n    ### I did edit ###\n    if observation[\"step\"] == 0:\n        sc = SmartCommand(observation)\n        city_0 = City(observation, city_0_pos_list_0)\n    else:\n        sc.update(observation)\n        city_0.update(observation)\n    \n    if observation[\"step\"] == 40:\n        city_0.update_pos_list(city_0_pos_list_1)\n    \n    actions = []\n    \n    for unit in sc.player.units:\n        sc.unit_count += 1\n    for city in sc.player.cities.values():\n        for city_tile in city.citytiles:\n            sc.citytile_count += 1\n    \n    action_dict = dict()\n    for unit in sc.player.units:\n        # print(unit.id)\n        if unit.can_act():\n            if unit.id in unit_actions.keys():\n                action_tuple = unit_actions[unit.id][observation[\"step\"]]\n            else:\n                action_tuple = unit_actions['u_0'][observation[\"step\"]]\n            if action_tuple[0] == \"citizen\":\n                if unit.is_worker():\n                    action_dict[unit.id] = city_0.worker_action(unit)\n                else:\n                    action_dict[unit.id] = city_0.cart_action(unit)\n            else:\n                action = sc.unit_action(unit, action_tuple)\n                if action is not None:\n                    action_dict[unit.id] = [(unit.pos.x, unit.pos.y, 0, action)]\n                else:\n                    action_dict[unit.id] = [(unit.pos.x, unit.pos.y, 0, \"\")]               \n        else:\n            action_dict[unit.id] = [(unit.pos.x, unit.pos.y, 0, \"\")]\n    # print(action_dict)\n    \n    # matching\n    n_units = len(action_dict.keys())\n    G = nx.DiGraph()\n    G.add_node(0, demand=-n_units)\n    G.add_node(1, demand=n_units)\n\n    unit_name_dict = dict()\n\n    # source -> unit\n    edge_list_1 = [(0, 32 * i + j + 2, 0) for i in range(32) for j in range(32)]\n    G.add_weighted_edges_from(edge_list_1)\n    \n    # unit -> position\n    edge_list_2 = []\n    for i, k in enumerate(action_dict.keys()):\n        for x, y, c, _ in action_dict[k]:\n            edge_list_2.append((i + 2, 10000 + 32 * x + y, -c))\n    G.add_weighted_edges_from(edge_list_2)\n    \n    # position -> sink\n    edge_list_3 = [(10000 + 32 * i + j, 1, 0) for i in range(32) for j in range(32)]\n    G.add_weighted_edges_from(edge_list_3)\n    \n    # capacity 1\n    for (i, j) in G.edges():\n        G[i][j][\"capacity\"] = 1\n        \n    # citytiles have infinite capacity\n    for city in sc.player.cities.values():\n        for city_tile in city.citytiles:\n            pos = city_tile.pos\n            p_xy = 10000 + 32 * pos.x + pos.y\n            G[p_xy][1][\"capacity\"] = 1024\n    \n    # resolve colision by min cost max flow \n    res = nx.min_cost_flow(G)\n\n    for i, k in enumerate(action_dict.keys()):\n        for x, y, c, command in action_dict[k]:\n            if res[i + 2][10000 + 32 * x + y] == 1:\n                if command != \"\":\n                    actions.append(command)\n    for city in sc.player.cities.values():\n        for city_tile in city.citytiles:\n            # print(city_tile.pos)\n            city_tile_key = f\"ct_{city_tile.pos.x}_{city_tile.pos.y}\"\n            if city_tile.can_act():\n                action_tuple = city_tile_actions[city_tile_key][observation[\"step\"]]\n                action = sc.city_tile_action(city_tile, action_tuple)\n                # print(action)\n                if action is not None:\n                    actions.append(action) \n    # print(actions)\n    return actions","ccb28e51":"city_tile_actions = {}\nfor i in range(32):\n    for j in range(32):\n        city_tile_actions[f\"ct_{i}_{j}\"] = [smart_worker] * 400","3af5cd8e":"u_0_actions = [(\"citizen\", )] * 400\n\nunit_actions = {\n    'u_0': u_0_actions,\n}","5f0d0140":"env.reset()\n_ = env.run([semi_manual_agent, \"simple_agent\"])\nenv.render(mode=\"ipython\", width=800, height=600)","fc788dce":"actions for citytiles, default is research","3131bd4d":"# Issues found","3fd0b876":"## Run and Watch\nand edit commans and run and edit commands and run and ...","36a703d4":"# My Commands for smart agents\nWhat makes me tired and bored is micro-management. It is tiring, even if they listen to what I say completely.  \nSo I decided to make the agent a litte smarter.   \nInstead of \"move north, stay, move west, build city, ...\", I want to say \"make your city bigger\" or \"go there and build a new city\"","a512d335":"## My basic commands fot units ","cc91210b":"## Imports\nsee [tutorial notebook](https:\/\/www.kaggle.com\/stonet2000\/lux-ai-season-1-jupyter-notebook-tutorial) for details. ","92e9957f":"- do not build house by coals...","188193b4":"actions for units(workers and carts), default is random move","be08e818":"## Semi-Manual Agent","98a28798":"## commands for citytiles","d34af8f9":"## commands for smart workers and carts","a3eb9152":"## Motivation\n\nI got tired and bored in doing this: https:\/\/www.kaggle.com\/cashfeg\/play-game-by-hand-2-days  \nSo I decided to think of easier way to do.  \n\nReference: \n- Turorial: https:\/\/www.kaggle.com\/stonet2000\/lux-ai-season-1-jupyter-notebook-tutorial\n- API: https:\/\/github.com\/Lux-AI-Challenge\/Lux-Design-2021\/blob\/master\/kits\/README.md\n- lux-ai-specifications: https:\/\/www.kaggle.com\/c\/lux-ai-2021\/overview\/lux-ai-specifications","984f2b43":"## commands for workers and carts","c8f3d647":"Use same game seed so that I can compare. ","e29d175b":"## function to return command"}}