{"cell_type":{"ddd3ff7d":"code","5de0dcd2":"code","f37d91d1":"code","0105432d":"code","f0bbd9b2":"code","5e0ce16d":"code","0763aa5a":"code","18c83cd7":"code","3128380a":"code","6675f6c1":"code","78d32d46":"markdown","9aec4fa9":"markdown","9c048430":"markdown","beea6cd0":"markdown","1834aabb":"markdown","22906ad2":"markdown","c90dd51b":"markdown","f7e4505a":"markdown","d7e141f6":"markdown","37b5cc42":"markdown","e59efaee":"markdown","f6822dbe":"markdown"},"source":{"ddd3ff7d":"import time\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom concorde.tsp import TSPSolver\nfrom sympy import isprime, primerange","5de0dcd2":"primes = {i for i in primerange(0, 197770)}\ncities = pd.read_csv('..\/input\/cities.csv', index_col=['CityId'])\n\nXY = np.stack((cities.X.values, cities.Y.values), axis=1)\nadd = np.array([0 if i in primes else 0.1 for i in cities.index])\n\ndef score_path(path):\n    xy = XY[path, :]\n    steps = np.sqrt(\n        np.sum(\n            np.square(xy - np.roll(xy, -1, axis=0)),\n            axis=1))\n    return steps.sum() + (steps[9::10] * add[path[9::10]]).sum()","f37d91d1":"# Instantiate solver\nsolver = TSPSolver.from_data(\n    cities.X * 10000,\n    cities.Y * 10000,\n    norm=\"CEIL_2D\"  # more exact in couple with scaling\n)","0105432d":"import random\n\nbest_score, best_path = 2 * 10**6, None\nfor i in range(5):\n    tour_data = solver.solve(time_bound = 60.0, verbose = True, random_seed=random.randint(0, 2019))\n    path = np.append(tour_data.tour,[0])\n    if score_path(path[::-1]) < score_path(path):\n        path = path[::-1]\n    score = score_path(path)\n    if score < best_score:\n        best_score, best_path = score, path\npath = best_path","f0bbd9b2":"pd.DataFrame({'Path': path}).to_csv('submission.csv', index=False)","5e0ce16d":"%matplotlib inline\nplt.figure(figsize=(32,18))\nplt.plot(cities.X[path], cities.Y[path])\nplt.show()","0763aa5a":"prime_path, composite_path = [0], []\nfor i in path:\n    if i in primes:\n        prime_path.append(i)\n    else:\n        composite_path.append(i)\nprime_path.append(0)\n\nplt.figure(figsize=(32,18))\nplt.plot(cities.X[composite_path], cities.Y[composite_path])\nplt.plot(cities.X[prime_path], cities.Y[prime_path])\nplt.show()\n\nplt.figure(figsize=(32,18))\nplt.plot(cities.X[composite_path], cities.Y[composite_path])\nplt.show()\n\nplt.figure(figsize=(32,18))\nplt.plot(cities.X[prime_path], cities.Y[prime_path], color='red')\nplt.show()","18c83cd7":"n_good, n_bad = 0, 0\ngood_edges, bad_edges = [], []\nfor i, city_id in enumerate(path[:-1], 1):\n    if i % 10 == 0:\n        if city_id in primes:\n            n_good += 1\n            good_edges.append([path[i-1], path[i]])\n        else:\n            n_bad += 1\n            bad_edges.append([path[i-1], path[i]])\nprint(f'Number of \"good\" tenth moves: {n_good}, number of \"bad\" tenth moves: {n_bad}.')","3128380a":"# # please make it faster with LineCollection\n# plt.figure(figsize=(32,18))\n# for edge in good_edges:\n#     plt.plot(cities.X[edge], cities.Y[edge], color='green')\n# for edge in bad_edges:\n#     plt.plot(cities.X[edge], cities.Y[edge], color='red')\n# plt.show()","6675f6c1":"def pure_score(path):\n    xy = XY[path, :]\n    steps = np.sqrt(\n        np.sum(\n            np.square(xy - np.roll(xy, -1, axis=0)),\n            axis=1))\n    return steps.sum()\n\nprint(\"Pure path's length is shorter by {:.2f}.\".format(score_path(path) - pure_score(path)))","78d32d46":"Save submission file","9aec4fa9":"Select best of five","9c048430":"# 1. Construct path ","beea6cd0":"Concorde's EUC_2D norm rounds the distances between cities to the nearest integer ([source](https:\/\/github.com\/matthelb\/concorde\/blob\/master\/UTIL\/edgelen.c#L299)) whereas competition metric doesn't. This significantly hurts quality as you get closer to TSP optimum. Simply scaling the coordinates up by a few orders of magnitude lets you get quite a bit better solution.","1834aabb":"\"Good\" and \"bad\" tenth moves","22906ad2":"Define score function","c90dd51b":"# 2. Some visualizations","f7e4505a":"Plot its prime and composite parts","d7e141f6":"Construct path","37b5cc42":"Looks like there is a room for improvement)))) Lets check it out!","e59efaee":"Plot whole tour","f6822dbe":"* This kernel hands off the cities to the very fast Concorde TSP solver\n* Ignores the prime twist on this problem\n* You must have https:\/\/github.com\/jvkersch\/pyconcorde installed in Kernels to run this\n"}}