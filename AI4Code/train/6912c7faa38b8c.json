{"cell_type":{"d2050ed7":"code","e24a1787":"code","66733e6b":"code","c4965fb5":"code","6815cb01":"code","004acbda":"code","91e76929":"code","ab0a51b5":"code","9870ecfe":"code","e1a855ab":"code","b2a4e4c2":"code","3ebe339c":"code","6efd92c5":"code","a372f6d3":"code","d03f123c":"code","e2d90ac4":"code","e7ba4aef":"code","97d40302":"code","7af93abe":"code","5a00c021":"code","f867aba7":"code","388b8822":"code","bf62ef74":"code","8f5691bb":"code","a3e7de78":"code","44dbf1b1":"code","d6affc35":"code","61f3b7c7":"code","39499d81":"code","ada23d3d":"code","96050bc3":"code","3c7cac4a":"code","4ad9ddd5":"code","ea2e132a":"code","e6b4c5d8":"code","751162a1":"code","7b15b85e":"code","1f079379":"code","4232862c":"markdown","db79bf39":"markdown","b8b8bf64":"markdown","70219375":"markdown","eee3e6c9":"markdown","a9234fa7":"markdown","0e2e4f4e":"markdown","09c94141":"markdown","f6f66071":"markdown","9724c519":"markdown","e8b5bfde":"markdown","9c6aecb4":"markdown","cff9e672":"markdown","e279f25e":"markdown","cf479cfe":"markdown","4f6989ac":"markdown","974a79ad":"markdown","3ce9362e":"markdown","17ec0ce4":"markdown"},"source":{"d2050ed7":"from IPython.display import YouTubeVideo\nYouTubeVideo('i0ZabxXmH4Y', width=800, height=450)","e24a1787":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nimport numpy as np\nimport pandas as pd\nsns.set()\nimport numpy as np # linear algebra\n # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import  Input, Conv2D, MaxPooling2D,GlobalMaxPooling2D, Flatten, Dense, GlobalAveragePooling2D, Activation, MaxPool2D, AvgPool2D, Dropout, Conv1D, MaxPooling1D\nfrom tensorflow.keras.optimizers import Adam, SGD, RMSprop\nfrom tensorflow.keras.applications import DenseNet121, VGG19, ResNet50\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nfrom IPython.display import display, Image\nimport matplotlib.pyplot as mpimg\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom sklearn.utils import shuffle\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","66733e6b":"train_df = pd.read_csv('..\/input\/coronahack-chest-xraydataset\/Chest_xray_Corona_Metadata.csv')","c4965fb5":"train_df.head(5)","6815cb01":"missing_vals = train_df.isnull().sum()\nmissing_vals.plot(kind = 'bar')","004acbda":"train_df.dropna(how = 'all')\ntrain_df.isnull().sum()","91e76929":"train_data = train_df[train_df['Dataset_type'] == 'TRAIN']\ntest_data = train_df[train_df['Dataset_type'] == 'TEST']\nassert train_data.shape[0] + test_data.shape[0] == train_df.shape[0]\nprint(f\"Shape of train data : {train_data.shape}\")\nprint(f\"Shape of test data : {test_data.shape}\")\ntest_data.sample(10)","ab0a51b5":"train_fill = train_data.fillna('unknown')\ntest_fill = test_data.fillna('unknown')\ndisplay(train_fill.head(5))","9870ecfe":"# Count plot for 3 attributes with unknown variable addition\ntargets = ['Label', 'Label_2_Virus_category', 'Label_1_Virus_category']\nfig, ax = plt.subplots(2,2, figsize=(20, 10))\nsns.countplot(x=targets[0], data=train_fill, ax=ax[0, 0])\nsns.countplot(x=targets[1], data=train_fill, ax=ax[0, 1])\nsns.countplot(x=targets[2], data=train_fill, ax=ax[1, 0])\nplt.show()","e1a855ab":"test_img_dir = '\/kaggle\/input\/coronahack-chest-xraydataset\/Coronahack-Chest-XRay-Dataset\/Coronahack-Chest-XRay-Dataset\/test'\ntrain_img_dir = '\/kaggle\/input\/coronahack-chest-xraydataset\/Coronahack-Chest-XRay-Dataset\/Coronahack-Chest-XRay-Dataset\/train'\n\nassert os.path.isdir(test_img_dir) == True\nassert os.path.isdir(train_img_dir) == True\n\nsample_train_images = list(os.walk(train_img_dir))[0][2][:8]\nsample_train_images = list(map(lambda x: os.path.join(train_img_dir, x), sample_train_images))\n\nsample_test_images = list(os.walk(test_img_dir))[0][2][:8]\nsample_test_images = list(map(lambda x: os.path.join(test_img_dir, x), sample_test_images))","b2a4e4c2":"from PIL import Image\nplt.figure(figsize = (17,17))\nfor iterator, filename in enumerate(sample_train_images):\n    image = Image.open(filename)\n    plt.subplot(4,2,iterator+1)\n    plt.imshow(image)\n\nplt.tight_layout()","3ebe339c":"plt.figure(figsize = (17,17))\nfor iterator, filename in enumerate(sample_test_images):\n    image = Image.open(filename)\n    plt.subplot(4,2,iterator+1)\n    plt.imshow(image)\n\nplt.tight_layout()","6efd92c5":"fig, ax = plt.subplots(4, 2, figsize=(17, 17))\n\n\ncovid_path = train_data[train_data['Label_2_Virus_category']=='COVID-19']['X_ray_image_name'].values\n\nsample_covid_path = covid_path[:4]\nsample_covid_path = list(map(lambda x: os.path.join(train_img_dir, x), sample_covid_path))\n\nfor row, file in enumerate(sample_covid_path):\n    image = plt.imread(file)\n    ax[row, 0].imshow(image)\n    ax[row, 1].hist(image.ravel(), 256, [0,256])\n    ax[row, 0].axis('off')\n    if row == 0:\n        ax[row, 0].set_title('Images')\n        ax[row, 1].set_title('Histograms')\nfig.suptitle('Label 2 Virus Category = COVID-19', size=16)\nplt.show()","a372f6d3":"fig, ax = plt.subplots(4, 2, figsize=(17, 17))\n\n\nnormal_path = train_data[train_data['Label']=='Normal']['X_ray_image_name'].values\n\nsample_normal_path = normal_path[:4]\nsample_normal_path = list(map(lambda x: os.path.join(train_img_dir, x), sample_normal_path))\n\nfor row, file in enumerate(sample_normal_path):\n    image = plt.imread(file)\n    ax[row, 0].imshow(image)\n    ax[row, 1].hist(image.ravel(), 256, [0,256])\n    ax[row, 0].axis('off')\n    if row == 0:\n        ax[row, 0].set_title('Images')\n        ax[row, 1].set_title('Histograms')\nfig.suptitle('Label = NORMAL', size=16)\nplt.show()","d03f123c":"final_train_data = train_data[(train_data['Label'] == 'Normal') | \n                              ((train_data['Label'] == 'Pnemonia') & (train_data['Label_2_Virus_category'] == 'COVID-19'))]\n\n\n# Create a target attribute where value = positive if 'Pnemonia + COVID-19' or value = negative if 'Normal'\nfinal_train_data['target'] = ['negative' if holder == 'Normal' else 'positive' for holder in final_train_data['Label']]\n\nfinal_train_data = shuffle(final_train_data, random_state=1)\n\nfinal_validation_data = final_train_data.iloc[1000:, :]\nfinal_train_data = final_train_data.iloc[:1000, :]\n\nprint(f\"Final train data shape : {final_train_data.shape}\")\nfinal_train_data.sample(10)","e2d90ac4":"train_image_generator = ImageDataGenerator(\n    rescale=1.\/255,\n    validation_split = 0.2,\n    shear_range=0.2,\n    zoom_range=0.2,\n)\n\ntrain_generator = train_image_generator.flow_from_dataframe(\n    dataframe=final_train_data,\n    directory=train_img_dir,\n    x_col='X_ray_image_name',\n    y_col='target',\n    target_size=(224, 224),\n    batch_size=16,\n    seed=2020,\n    shuffle=True,\n    class_mode='binary'\n)\n\nvalidation_generator = train_image_generator.flow_from_dataframe(\n    dataframe=final_validation_data,\n    directory=train_img_dir,\n    x_col='X_ray_image_name',\n    y_col='target',\n    target_size=(224, 224),\n    batch_size=16,\n    seed=2020,\n    shuffle=True,\n    class_mode='binary'\n)\n","e7ba4aef":"model = Sequential()\nmodel.add(Conv2D(32, (3, 3), input_shape= (224,224,3)))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(32, (3, 3)))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\n\nmodel.add(Conv2D(64,(3,3)))\nmodel.add(Activation(\"relu\"))\nmodel.add(Conv2D(250,(3,3)))\nmodel.add(Dropout(0.5))\nmodel.add(Activation(\"relu\"))\n  \nmodel.add(Conv2D(128,(3,3)))\nmodel.add(Activation(\"relu\"))\nmodel.add(AvgPool2D(2,2))\nmodel.add(Conv2D(64,(3,3)))\nmodel.add(Activation(\"relu\"))\nmodel.add(AvgPool2D(2,2))\n\nmodel.add(Conv2D(256,(2,2)))\nmodel.add(Activation(\"relu\"))\nmodel.add(MaxPool2D(2,2))\n    \nmodel.add(Flatten())\nmodel.add(Dense(32))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(1))\nmodel.add(Activation(\"sigmoid\"))","97d40302":"model.summary()","7af93abe":"callbacks = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=2)","5a00c021":"BATCH_SIZE = 16\nEPOCHS = 30","f867aba7":"model.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])\nhistory = model.fit(train_generator,\n                              steps_per_epoch = train_generator.samples \/\/BATCH_SIZE,\n                              validation_data=validation_generator,\n                              epochs=EPOCHS,\n                              validation_steps= validation_generator.samples \/\/BATCH_SIZE,\n                              callbacks = [callbacks]\n                                     )","388b8822":"plt.figure(figsize=(17,17))\nplt.subplot(2, 2, 1)\nplt.plot(history.history['loss'], label='Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.legend()\nplt.title('Training - Loss Function')\n\nplt.subplot(2, 2, 2)\nplt.plot(history.history['accuracy'], label='Accuracy')\nplt.plot(history.history['val_accuracy'], label='Validation Accuracy')\nplt.legend()\nplt.title('Train - Accuracy')\n\nplt.legend()\nplt.title('Metrics estimations')\n","bf62ef74":"mob_model = Sequential()\nmob_model.add(tf.keras.applications.MobileNetV2(include_top=False, pooling = 'avg', weights='imagenet',input_shape=(224, 224, 3), classes=2))\nmob_model.add(Dense(32, activation='relu'))\nmob_model.add(Dense(1, activation='sigmoid'))\nmob_model.layers[0].trainable = False\nmob_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])","8f5691bb":"mob_history = mob_model.fit_generator(train_generator,\n                              steps_per_epoch = len(train_generator),\n                              validation_data=validation_generator,\n                              epochs=20,\n                              validation_steps=len(validation_generator),\n                              callbacks = [callbacks]\n                                     )","a3e7de78":"plt.figure(figsize=(17,17))\n\nplt.subplot(2, 1, 2)\nplt.plot(mob_history.history['loss'], label='Loss')\nplt.plot(mob_history.history['loss'], label='Validation Loss')\n\nplt.legend()\nplt.title('Training - Loss Function')\n\nplt.subplot(2, 1, 2)\nplt.plot(mob_history.history['accuracy'], label='Accuracy')\nplt.plot(mob_history.history['val_accuracy'], label='Validation Accuracy')\n\n\nplt.legend()\nplt.title('Train - Accuracy')","44dbf1b1":"label = validation_generator.classes\nprint('Cases summary of the models : \\n{}'.format(label))","d6affc35":"pred= model.predict(validation_generator)\npredicted_class_indices=np.argmax(pred,axis=1)\nlabels = (validation_generator.class_indices)\nlabels2 = dict((v,k) for k,v in labels.items())\npredictions = [labels2[k] for k in predicted_class_indices]","61f3b7c7":"labels","39499d81":"print('CNN Model Predictions : \\n{}'.format(predictions))","ada23d3d":"from sklearn.metrics import confusion_matrix, classification_report\n\ncf_matrix = confusion_matrix(predicted_class_indices,label)\ncf_matrix","96050bc3":"exp_series = pd.Series(label)\npred_series = pd.Series(predicted_class_indices)\npd.crosstab(exp_series, pred_series, rownames=['Actual'], colnames=['Predicted'],margins=True)","3c7cac4a":"import seaborn as sns\n\nmatrix_index = [\"Negative\", \"Positive\"]\n# Negative - no COVID\n\n\npreds = model.predict(validation_generator)\nclasspreds = np.argmax(preds, axis=1) # predicted classes \n#y_testclass = np.argmax(valida, axis=1) # true classes\n\ncm = confusion_matrix(predicted_class_indices,label)\nprint(classification_report(predicted_class_indices,label, target_names=matrix_index))\n\n# Get percentage value for each element of the matrix\ncm_sum = np.sum(cm, axis=1, keepdims=True)\ncm_perc = cm \/ cm_sum.astype(float) * 100\nannot = np.empty_like(cm).astype(str)\nnrows, ncols = cm.shape\nfor i in range(nrows):\n    for j in range(ncols):\n        c = cm[i, j]\n        p = cm_perc[i, j]\n        if i == j:\n            s = cm_sum[i]\n            annot[i, j] = '%.1f%%\\n%d\/%d' % (p, c, s)\n        elif c == 0:\n            annot[i, j] = ''\n        else:\n            annot[i, j] = '%.1f%%\\n%d' % (p, c)\n\n\n# Display confusion matrix \ndf_cm = pd.DataFrame(cm, index = matrix_index, columns = matrix_index)\ndf_cm.index.name = 'Actual'\ndf_cm.columns.name = 'Predicted'\nfig, ax = plt.subplots(figsize=(10,7))\nsns.heatmap(df_cm, annot=annot, fmt='')","4ad9ddd5":"pred= mob_model.predict(validation_generator)\npredicted_class_indices=np.argmax(pred,axis=1)\nlabels = (validation_generator.class_indices)\nlabels2 = dict((v,k) for k,v in labels.items())\npredictions = [labels2[k] for k in predicted_class_indices]","ea2e132a":"labels","e6b4c5d8":"print('MobileNet Model Predictions : \\n{}'.format(predictions))","751162a1":"cf_matrix = confusion_matrix(predicted_class_indices,label)\ncf_matrix","7b15b85e":"exp_series = pd.Series(label)\npred_series = pd.Series(predicted_class_indices)\npd.crosstab(exp_series, pred_series, rownames=['Actual'], colnames=['Predicted'],margins=True)","1f079379":"matrix_index = [\"Negative\", \"Positive\" ]\n# Negative - no COVID\n\npreds = mob_model.predict(validation_generator)\nclasspreds = np.argmax(preds, axis=1) # predicted classes \n#y_testclass = np.argmax(valida, axis=1) # true classes\n\ncm = confusion_matrix(predicted_class_indices,label)\nprint(classification_report(predicted_class_indices,label, target_names=matrix_index))\n\n# Get percentage value for each element of the matrix\ncm_sum = np.sum(cm, axis=1, keepdims=True)\ncm_perc = cm \/ cm_sum.astype(float) * 100\nannot = np.empty_like(cm).astype(str)\nnrows, ncols = cm.shape\nfor i in range(nrows):\n    for j in range(ncols):\n        c = cm[i, j]\n        p = cm_perc[i, j]\n        if i == j:\n            s = cm_sum[i]\n            annot[i, j] = '%.1f%%\\n%d\/%d' % (p, c, s)\n        elif c == 0:\n            annot[i, j] = ''\n        else:\n            annot[i, j] = '%.1f%%\\n%d' % (p, c)\n\n\n# Display confusion matrix \ndf_cm = pd.DataFrame(cm, index = matrix_index, columns = matrix_index)\ndf_cm.index.name = 'Actual'\ndf_cm.columns.name = 'Predicted'\nfig, ax = plt.subplots(figsize=(10,7))\nsns.heatmap(df_cm, annot=annot, fmt='')","4232862c":"# 6. Model Development","db79bf39":"Let's fill the missing values with 'unknown'","b8b8bf64":"# Plots to estimate loss and accuracy","70219375":"# Beginners Intro to Coronavirus","eee3e6c9":"# 4.1 Histogram analysis of Images","a9234fa7":"# 5. Image Augmentation","0e2e4f4e":"# MobileNetV2","09c94141":"**Normal Histogram images**","f6f66071":"**For COVID-19 cases**","9724c519":"# Load the libraries","e8b5bfde":"Displaying test images","9c6aecb4":"# 3. Visualization of Unknown Data","cff9e672":"# CNN predictions","e279f25e":"# 8. References\nThanks to some amazing notebooks I was able to learn how to display images in an orderly fashion and was able to apply transfer learning CNN in COVID related applications.\n1. https:\/\/www.kaggle.com\/adityam1311\/covid-19-x-ray-images-eda-models\/notebook\n2. https:\/\/www.kaggle.com\/eswarchandt\/covid-19-detection-from-lung-x-rays","cf479cfe":"# 2. Missing Values","4f6989ac":"# COVID-19 Pandemic\n\n![](https:\/\/www.statnews.com\/wp-content\/uploads\/2020\/02\/Coronavirus-CDC-645x645.jpg)\n\nSource = https:\/\/www.statnews.com\/wp-content\/uploads\/2020\/02\/Coronavirus-CDC-645x645.jpg\n","974a79ad":"# 6.1 Convolutional Neural Network","3ce9362e":"# MobileNet predictions","17ec0ce4":"# 4. Display Images"}}