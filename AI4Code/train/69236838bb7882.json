{"cell_type":{"ca2d90f4":"code","6d8a4b6c":"code","81ddac23":"code","e320c7d7":"code","c92b450f":"code","b8ce6a4b":"code","9977894e":"code","18a896f6":"code","c220cdf4":"code","01653162":"code","7d5db17c":"code","cdbba361":"code","66484b53":"code","e6c1500c":"code","f7006b6b":"code","032187a9":"code","65fad94e":"code","49f7e30b":"code","76868f0e":"code","5d83dd6e":"code","9fb0409c":"code","1ec04bdf":"code","02dcfc2b":"code","08f68dff":"code","a4473c4c":"code","b98656d5":"code","644c1d7c":"code","0fbaa96c":"code","44e4c141":"markdown","724ac103":"markdown","fb0863be":"markdown","c83d41b7":"markdown","5e7d85da":"markdown","cd08cdf5":"markdown","2d0b1e39":"markdown","f459f838":"markdown"},"source":{"ca2d90f4":"import numpy as np\nimport scipy\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nfrom scipy.ndimage import rotate\nsns.set(color_codes=True)\nfrom skimage.transform import resize, rescale","6d8a4b6c":"#from google.colab import drive\n#drive.mount('\/content\/drive')","81ddac23":"import glob\nfrom PIL import Image\nimport PIL\nimage_limit = 2500 # change according to ram availiblity\nimage_path = ''\ndestination_path = ''\nimage_collection = glob.glob(image_path + '*.jpg')\nsize = 256\nimages = np.array([np.array(Image.open(img).convert('RGB').resize((size, size), Image.ANTIALIAS)) for img in image_collection])","e320c7d7":"images.shape","c92b450f":"def translate(img, direction, shift, roll=True):\n  assert direction in ['right', 'left', 'down', 'up'], 'Directions should be top|up|left|right'\n  img = img.copy()\n  if direction == 'right':\n      right_slice = img[:, -shift:].copy()\n      img[:, shift:] = img[:, :-shift]\n      if roll:\n          img[:,:shift] = np.fliplr(right_slice)\n  if direction == 'left':\n      left_slice = img[:, :shift].copy()\n      img[:, :-shift] = img[:, shift:]\n      if roll:\n          img[:, -shift:] = left_slice\n  if direction == 'down':\n      down_slice = img[-shift:, :].copy()\n      img[shift:, :] = img[:-shift,:]\n      if roll:\n          img[:shift, :] = down_slice\n  if direction == 'up':\n      upper_slice = img[:shift, :].copy()\n      img[:-shift, :] = img[shift:, :]\n      if roll:\n          img[-shift:,:] = upper_slice   \n  return img    ","b8ce6a4b":"shift = 10\ntranslated_images = []\ndirections = ['right', 'left', 'down', 'up']\nskip_factor = 2\ni = 1\nfor direction in directions:\n  for img in images:\n    if i % skip_factor == 0:\n      translated_images.append(translate(img,direction,shift))\n    i = i + 1  ","9977894e":"translated_images = np.asarray(translated_images) \n#translated_images.shape\nif images.shape[0] +translated_images.shape[0] < image_limit:\n  images = np.concatenate( (images, translated_images) )  ","18a896f6":"images.shape","c220cdf4":"def random_crop(img, crop_size=(10, 10)):\n    assert crop_size[0] <= img.shape[0] and crop_size[1] <= img.shape[1], \"Crop size should be less than image size\"\n    img = img.copy()\n    w, h = img.shape[:2]\n    x, y = np.random.randint(h-crop_size[0]), np.random.randint(w-crop_size[1])\n    img = img[y:y+crop_size[0], x:x+crop_size[1]]\n    return img","01653162":"import cv2\ndef res_image(image):\n  image = image.copy()\n  resize_image = cv2.resize(image, (256, 256),interpolation=cv2.INTER_NEAREST)\n  return resize_image","7d5db17c":"cropped_images = []\nn_crops = 1 #number of crops per image\nskip_factor = 2\ni = 1\nfor _ in range (0,n_crops):\n  for img in images:\n    if i % skip_factor == 0:\n      crop_size = (int(img.shape[0]\/\/4),int(img.shape[1]\/\/4)) \n      cropped_images.append(res_image(random_crop(img,crop_size)))\n    i = i + 1  ","cdbba361":"cropped_images = np.asarray(cropped_images) \nif images.shape[0] + cropped_images.shape[0] < image_limit:\n  images = np.concatenate( (images, cropped_images) )","66484b53":"images.shape[0]","e6c1500c":"def rotate_img(img, angle, bg_patch=(5,5)):\n    assert len(img.shape) <= 3, \"Incorrect image shape\"\n    rgb = len(img.shape) == 3\n    if rgb:\n        bg_color = np.mean(img[:bg_patch[0], :bg_patch[1], :], axis=(0,1))\n    else:\n        bg_color = np.mean(img[:bg_patch[0], :bg_patch[1]])\n    img = rotate(img, angle, reshape=False)\n    mask = [img <= 0, np.any(img <= 0, axis=-1)][rgb]\n    img[mask] = bg_color\n    return img","f7006b6b":"rotated_images = []\nn_rotations = 1 #number of rotated pictures per picture\nskip_factor = 1\ni = 1\nfor _ in range (0,n_rotations):\n  for img in images:\n    if i % skip_factor == 0:\n      angle = np.random.randint(359)\n      rotated_images.append(rotate_img(img,angle))\n    i = i + 1","032187a9":"rotated_images = np.asarray(rotated_images)\nif images.shape[0] + rotated_images.shape[0] < image_limit:\n  images = np.concatenate((images, rotated_images))\nimages.shape","65fad94e":"def gaussian_noise(img, mean=0, sigma=0.03):\n    img = img.copy()\n    noise = np.random.normal(mean, sigma, img.shape)\n    mask_overflow_upper = img+noise >= 1.0\n    mask_overflow_lower = img+noise < 0\n    noise[mask_overflow_upper] = 1.0\n    noise[mask_overflow_lower] = 0\n    img = img + noise\n    return img","49f7e30b":"noised_images = []\nn_noises = 1\nskip_factor = 1 #due to high memory usage it's adviced to skip some images \ni = 2\nfor _ in range (0,n_noises):\n  for img in images:\n    if i % skip_factor == 0:\n      sigma = round((np.random.randint(10)\/121),2)\n      noised_images.append(gaussian_noise(img,sigma))\n\n    i = i + 1","76868f0e":"noised_images = np.asarray(noised_images)\nif images.shape[0] + noised_images.shape[0] < image_limit:\n  images = np.concatenate( (images, noised_images) )\nimages.shape","5d83dd6e":"def distort(img, orientation='horizontal', func=np.sin, x_scale=0.05, y_scale=5):\n    assert orientation[:3] in ['hor', 'ver'], \"dist_orient should be 'horizontal'|'vertical'\"\n    assert func in [np.sin, np.cos], \"supported functions are np.sin and np.cos\"\n    assert 0.00 <= x_scale <= 0.1, \"x_scale should be in [0.0, 0.1]\"\n    assert 0 <= y_scale <= min(img.shape[0], img.shape[1]), \"y_scale should be less then image size\"\n    img_dist = img.copy()\n    def shift(x):\n        return int((y_scale * func(np.pi * x * x_scale)))\n    \n    for c in range(3):\n        for i in range(img.shape[orientation.startswith('ver')]):\n            if orientation.startswith('ver'):\n                img_dist[:, i, c] = np.roll(img[:, i, c], shift(i))   \n            else:\n                img_dist[i, :, c] = np.roll(img[i, :, c], shift(i))  \n    return img_dist","9fb0409c":"imgs_distorted = []\nskip_factor = 2\ni = 1\n\nfor img in images:\n  for ori in ['ver', 'hor']:\n    if i % skip_factor == 0:\n      x_param = np.random.randint(1)\/10\n      y_param = np.random.randint(min(img.shape[0], img.shape[1]) - np.random.randint(min(img.shape[0], img.shape[1])))\n      imgs_distorted.append(distort(img, orientation=ori, x_scale=x_param, y_scale=y_param))\n    i = i + 1 \nimgs_distorted = np.asarray(imgs_distorted)\nif images.shape[0] + imgs_distorted.shape[0] < image_limit:\n  images = np.concatenate((images, imgs_distorted))","1ec04bdf":"def change_channel_ratio(img, channel, ratio=0.5):\n    assert channel in 'rgb', \"Value for channel: rg|b|\"\n    img = img.copy()\n    ci = 'rgb'.index(channel)\n    img[:, :, ci] =  img[:, :, ci]*  ratio\n    return img","02dcfc2b":"colored_images = []\nn_colors = 1\nskip_factor = 2 #due to high memory usage it's adviced to skip some images \ni = 1\nfor _ in range (0,n_colors):\n  for img in images:\n    if i % skip_factor == 0:\n      colors = ['r','g','b']\n      for color in colors:\n        sigma = round((np.random.randint(10)\/135),2)\n        ratio = np.random.randint(10)\/14\n        colored_images.append(change_channel_ratio(img,color,ratio))\n    i = i + 1","08f68dff":"colored_images = np.asarray(colored_images)\nif images.shape[0] + colored_images.shape[0] < image_limit:\n  images = np.concatenate((images, colored_images))\nimages.shape","a4473c4c":"def change_channel_ratio_gauss(img, channel='r', mean = 0, sigma=0.03):\n    assert channel in 'rgb', \"cahenel must be r|g|b\"\n    img = img.copy()\n    ci = 'rgb'.index(channel)\n    img[:, :, ci] = gaussian_noise(img[:, :, ci], mean=mean, sigma=sigma)\n    return img","b98656d5":"colored_images = []\nn_colors = 1\nskip_factor = 1 #due to high memory usage it's adviced to skip some images \ni = 1\nfor _ in range (0,n_colors):\n  for img in images:\n    if i % skip_factor == 0:\n      colors = ['r','g','b']\n      for color in colors:\n        mean = 0\n        sigma = np.random.randint(10)\/40\n        colored_images.append(change_channel_ratio_gauss(img,color,0,sigma))\n    i = i + 1","644c1d7c":"colored_images = np.asarray(colored_images)\nif images.shape[0] + colored_images.shape[0] < image_limit:\n  images = np.concatenate((images, colored_images))\nimages.shape","0fbaa96c":"import os\nsave_path = destination_path\ni = 0\nfor i in range(0,len(images)-1):\n  gen_img = Image.fromarray(images[i].astype(np.uint8))\n  file = 'grain_'+str(i+1)\n  gen_img.save(save_path+file+'.jpg')\n  i = i + 1 ","44e4c141":"### Distortions","724ac103":"https:\/\/colab.research.google.com\/drive\/1a-U-odzlPeTIToPi3IwyFyxjz6d367bM?usp=sharing","fb0863be":"# Data Augmentation in NumPy","c83d41b7":"### Translations","5e7d85da":"### Random Noise","cd08cdf5":"You can use the following notebook to create new images using Data Augmentation.\nNote: You can use functions seperately with complete control over all transformation factors, \nmixing the function implementations rather than linearly using it may give better results ","2d0b1e39":"### Rotations","f459f838":"### Color channels change"}}