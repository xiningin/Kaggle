{"cell_type":{"e38f66f3":"code","4608cee4":"code","94a4b30f":"code","f63973f1":"code","cf5c266e":"code","141c5ac9":"code","b88eed23":"code","3306e69e":"code","93719dff":"code","ff7048e7":"code","8a3131af":"code","61dd9354":"code","6cf008cb":"markdown","0e0d9b42":"markdown","eba85d7b":"markdown","d4345b72":"markdown","631d9875":"markdown","2e1abf02":"markdown","5a949fce":"markdown","a20fadf9":"markdown","237cffe1":"markdown","a65997f7":"markdown","3952a0e0":"markdown","c7fcf905":"markdown","8aac5c4d":"markdown","4846bd44":"markdown"},"source":{"e38f66f3":"import numpy as np\nimport pandas as pd\nimport math\nimport matplotlib.pyplot as plt\nfrom numpy.linalg import inv","4608cee4":"n_iters = 50","94a4b30f":"# Actual position of the ship\nactual_x = 0\nactual_y = 0\n\n# Process noise covariance which is assumed to be a small value.\nQ = np.full((2,2), 0.0001)\nprint('Q matrix: ', Q.shape, '\\n\\n', Q)","f63973f1":"# Create 50 random x and y position measurements\nx_pos = np.random.normal(0, 0.5, n_iters)\ny_pos = np.random.normal(0, 0.5, n_iters)\n\n# Combine the measurements in a matrix\nmeasurements = np.stack((x_pos, y_pos), axis=1).reshape((n_iters,2,1))\n\nprint('Measurements: ', measurements.shape, '\\n\\n', measurements[0:5], '\\n', '...')","cf5c266e":"# Measurement noise covariance.\nR = np.diag([0.25, 0.25])\nprint('R matrix: ', R.shape, '\\n\\n', R)","141c5ac9":"# Creating empty matrices\nx_hat = np.zeros((n_iters, 2,1))\nP = np.zeros((n_iters,2,2))\nx_hat_min = np.zeros((n_iters, 2,1))\nP_min = np.zeros((n_iters,2,2))\nK = np.zeros((n_iters,2,2))","b88eed23":"# Initial state\nx_hat[0] = [[0],[0]]\n\n# Initial error covariance\nP[0] = np.diag([1000.0, 1000.0])\n\nprint('x_hat[0]:\\n\\n', x_hat[0], '\\n\\n P[0] matrix: ', P[0].shape, '\\n\\n', P[0])","3306e69e":"# A matrix\nA = np.array([[1.0, 0.0],\n               [0.0, 1.0]])\n\n# H matrix\nH = np.eye(2)\n\n# Unit matrix for Kalman gain\nI = np.eye(2)\n\nprint('A matrix \\n\\n', A, '\\n\\n H matrix \\n\\n', H, '\\n\\n I matrix \\n\\n', I)","93719dff":"for k in range(1, n_iters):\n    # Calculating a priori estimate and error covariance\n    x_hat_min[k] = A.dot(x_hat[k-1])\n    P_min[k] = A.dot(P[k-1]).dot(A.T) + Q\n    \n    # Calculating Kalman gain\n    S = H.dot(P_min[k]).dot(H.T) + R\n    K[k] = P_min[k].dot(H.T).dot(inv(S))\n    \n    # Calculating a posteriori estimate and error covariance\n    x_hat[k] = x_hat_min[k] + K[k].dot(measurements[k] - H.dot(x_hat_min[k]))\n    P[k] = (I - K[k]).dot(P_min[k])","ff7048e7":"plt.figure(figsize=(7,7))\nfor n in range(n_iters):\n    plt.scatter(float(measurements[n][0]), float(measurements[n][1]), \n                color='orange', label='measured position', alpha=0.7)\n    plt.scatter(float(x_hat[n][0]), float(x_hat[n][1]), \n                color='blue', label='kalman position', alpha=0.3)\n\nplt.scatter(actual_x, actual_y, color='red', s=100, label='actual position')\nplt.title('Actual, Measured and Estimated Positions')\nplt.xlabel('X axis')\nplt.ylabel('Y axis');","8a3131af":"plt.figure(figsize=(10,5))\nfor n in range(n_iters):\n    plt.scatter(x = n, y = measurements[n][0], label='measurements', color='orange', alpha=0.7)\n    plt.scatter(x = n, y = x_hat[n][0], label='estimate after kalman', color='blue', alpha=0.5)\nplt.axhline(actual_x, color='r', label='actual x position')\nplt.title('Actual, Measured and Estimated Positions on X axis')\nplt.xlabel('Number of Steps')\nplt.ylabel('X Position')\n\nplt.figure(figsize=(10,5))\nfor n in range(n_iters):\n    plt.scatter(x = n, y = measurements[n][1], label='measurements', color='orange', alpha=0.7)\n    plt.scatter(x = n, y = x_hat[n][1], label='estimate after kalman', color='blue', alpha=0.5)\nplt.axhline(actual_x, color='r', label='actual x position')\nplt.title('Actual, Measured and Estimated Positions on Y axis')\nplt.xlabel('Number of Steps')\nplt.ylabel('Y Position');","61dd9354":"# Creating a pandas dataframe for animation\nx_position = []\ny_position = []\ndata_type = []\nn_steps = []\n\nfor n in range(n_iters):\n    x_position.append(float(measurements[n][0]))\n    y_position.append(float(measurements[n][1]))\n    data_type.append('measured')\n    n_steps.append(int(n))\n    \nfor n in range(n_iters):\n    x_position.append(float(x_hat[n][0]))\n    y_position.append(float(x_hat[n][1]))\n    data_type.append('estimated')\n    n_steps.append(int(n))\n\ndf = pd.DataFrame({'x_position':x_position,\n                   'y_position':y_position,\n                   'data_type':data_type,\n                   'n_steps':n_steps})\n\n# Creating the animation\nimport plotly.express as px\n\nfig = px.scatter(df, \n                 x =\"x_position\", \n                 y =\"x_position\", \n                 animation_frame =\"n_steps\",\n                 animation_group =\"data_type\",\n                 color =\"data_type\",\n                 facet_col =\"data_type\",\n                 range_x=[-3, 3], \n                 range_y=[-3, 3])\nfig.show()","6cf008cb":"## 3. Creating imaginary, noisy position measuremants with same number of steps.\n\nNormally distributed noisy measurements for x and y values are created here. ","0e0d9b42":"## 1. Defining number of steps (or time period)","eba85d7b":"## 2. Defining actual (physical) position of the ship","d4345b72":"Initial position of the ship and initial error covariance should be defined. A high value of initial error covariance is chosen here. But one can see the error covariance will decrease with the successive steps.","631d9875":"Actual position, measurements and estimates for x and y values are plotted seperately through the steps. ","2e1abf02":"## 6. Conducting calculations and saving measurements.","5a949fce":"One can see from above, kalman filtered estimates converge near the actual position as the iterations progress. \n\nWith this basic application, I wanted to demonstrate how to use kalman filter to stabilize noisy position data. Similarly noisy wind, current and acoustic position data can be stabilized before usage. This study can be improved by defining mathematical model of the ship and adding velocity, acceleration, wind and current data to the related matrices.\n\n**Resources:**\n\nGreat video explanations:\\\nhttps:\/\/www.youtube.com\/watch?v=mwn8xhgNpFY&list=PLn8PRpmsu08pzi6EMiYnR-076Mh-q3tWr&ab_channel=MATLAB\n\nDetailed video explanations:\\\nhttps:\/\/www.youtube.com\/watch?v=CaCcOwJPytQ&feature=youtu.be&ab_channel=MichelvanBiezen\n\nOne dimensional kalman filter approach:\\\nhttps:\/\/towardsdatascience.com\/kalman-filters-a-step-by-step-implementation-guide-in-python-91e7e123b968\n\nOne dimensional kalman filter with Python:\\\nhttps:\/\/scipy-cookbook.readthedocs.io\/items\/KalmanFiltering.html\n\nMulti dimensional kalman filter approach:\\\nhttps:\/\/medium.com\/@jaems33\/understanding-kalman-filters-with-python-2310e87b8f48\n\nIntroduction to kalman filter:\\\nhttps:\/\/www.cs.unc.edu\/~welch\/media\/pdf\/kalman_intro.pdf\n\nKalman filtering and DP applications:\\\nhttps:\/\/dynamic-positioning.com\/proceedings\/dp2003\/design_cadet.pdf","a20fadf9":"Visualizing measurements and estimated positions in an animation.","237cffe1":"We need to define our measurement noise covariance. Change in R matrix can be examined in the position estimates. Because R is going to be used in kalman gain.","a65997f7":"## 5. Defining related matrices for mathematical calculations.","3952a0e0":"## 7. Visualising the actual, noisy measurements and estimated positions.\n\nActual position is plotted in red, noisy measurements are plotted in orange and kalman filtered estimates are plotted in blue for x and y coordinates.","c7fcf905":"## Kalman Filter\n\nThere are amazing resources to learn about kalman filters, and I would recommend to check the resources at the end of this study. But I need to define some of the mathematical steps in order to clarify my study.\n\n### System State\nFirst of all, we have our ship's state (which is the position). This state is represented with x and consists of position information on x and y axes. Because I am not going to use control inputs in this study, there isn't any 'B' or 'u' matrices. And we have our state measurement which is z.\n\n$$ x_{k} = Ax_{k\u20131} + Bu_{k \u2013 1} + w_{k \u2013 1} $$\n\n$$ z_{k} = Hx_{k} + v_{k} $$\n\n'w' is the process noise and 'v' is the measurement noise. And we assume they have normal probabilty distribution. Process noise has a process noise covariance of 'Q' and measurement has a measurement noise covariance of 'R'.\n\n$$ p(w) \\text{~} N(0, Q) $$\n$$ p(v) \\text{~} N(0, R) $$\n\n### Kalman Filter Cycle\n\nSteps can be summarized as follows: \n1. Calculate a priori estimate  \n\n    $ x^{\u02c6-}_k = A x^{\u02c6-}_{k-1} $\n   \n\n2. Calculate a priori noise covariance\n\n    $ P^{-}_k = A P_{k-1} A^{T} + Q $\n    \n\n3. Calculate kalman gain\n    \n    $  K_k = \\frac{P^{-}_k C^{T}}{C P^{-}_k C^{T} + R} $ \n    \n\n4. Calculate a posteriori estimate\n\n    $  x^{\u02c6}_k = x^{\u02c6-}_k + K_k (z_{k} - C x^{\u02c6-}_k)   $\n\n\n5. Calculate a posteriori noise covariance\n\n    $ P_k = (I - K_k C)P^{-}_k  $\n    \n\n6. Use a posteriori estimate and noise covariance as new a priori estimate and covairance, and repeat the steps.\n\n### Matrix Operations\nAs an example let's look at a priori estimate calculation. The ship's position information consists of x and y values. So our a priori estimate is a matrix. \n\n$$ x^{\u02c6-}_k = \\begin{bmatrix} Posx_k \\\\ Posy_k \\end{bmatrix} \n= A\n\\begin{bmatrix} Posx_{k-1} \\\\ Posy_{k-1} \\end{bmatrix}\n$$ \n\nTo be able to conduct matrix operation above, we should have A matrix of (2x2). Similarly we should consider B, H, I, K, P, Q, R matrices properly. This process is different for each application and depends on our system's mathematical model. Because I dind't use ship velocity, wind, current or IMU sensor data, I only needed (2x1), (2x2) shaped matrices.","8aac5c4d":"## 4. Creating empty arrays\n\nEmpty arrays are created to save estimated positions after the kalman filter is applied.","4846bd44":"# Kalman Filter Application in Dynamic Positioning System \n\nMy main goal of this study is to understand how to apply kalman filter by using Python. I wanted to choose an example from a real life scenerio. As I had experience working onboard a ship with Dynamic Positioning (DP) system, I knew that kalman filter is widely used in the system.\n\nBefore starting the study, I should explain what is the Dynamic Positioning System and how is the kalman filter used in DP systems.\n\nEspecially in the offshore industry, DP system is widely used to automatically maintain a marine platform's (either a ship or an offshore platform) position, heading (yaw angle), follow survey routes, conduct berthing or docking maneavours. These platforms have multiple thrusters (propellers) and multiple sensors (GPS, wind, current, IMU sensors, acoustic transponders, laser rangefinders etc). \n\nFor a position keeping scenario, imagine the platform is on the location where we want to keep her position. One can measure her position from multiple GPS sensors. And if acoustic transponders are used, one can also see the relative position of the platform from these transponders. In reality, sensor data can be noisy and unstable. At the same time external forces like wind or current speed and direction can change over time. External forces can cause a drift in the platform's position. Every time the position information changes, the DP system commands thrusters to get the platform back into her desired position. If the system uses these unstable and noisy data, it can command thrusters unnecessarily and this can cause more of a position drift. Kalman filter is used to in order to discard these noisy data and estimate a stable position information. For more information about the kalman filter and it's use in DP system, I would recommend you to check resources at the end of this study. \n\nIn reality, DP system configuration is much more complex than this definition of mine, but I wanted to explain the basics of the procedure. In order to simplfy the problem, I didn't use velocity, accelaration, wind, current data. I used only position data (x and y axes). And I followed these steps:\n1. Defining number of steps (or time period).\n2. Defining actual (physical) position of the ship. In order to simplfy the study x and y axes are used instead of geographic coordinates.\n3. Creating imaginary, noisy position measuremants with the same number of steps.\n4. Creating empty arrays to save calculated measurements after kalman filter is applied.\n5. Defining related matrices for mathematical calculations.\n6. Conducting calculations and saving measurements.\n7. Visualising the actual, noisy measurements and estimated positions."}}