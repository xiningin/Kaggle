{"cell_type":{"78ea96c6":"code","927ed964":"code","a5883053":"code","6767aae6":"code","9a011007":"code","d14c171d":"code","9aeeecf6":"code","695dfab8":"code","9c12e706":"code","03b0cae9":"code","df664d2e":"code","492e6d68":"code","5e378c70":"code","6f358635":"markdown","ae7b4990":"markdown"},"source":{"78ea96c6":"pip install autoviz","927ed964":"pip install xlrd","a5883053":"import pandas as pd\nimport numpy as np\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.experimental import enable_hist_gradient_boosting\nfrom sklearn.ensemble import HistGradientBoostingClassifier\n\nfrom warnings import filterwarnings\nfilterwarnings('ignore')","6767aae6":"df_train = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/train.csv')\ndf_test  = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/test.csv')\nss       = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/sample_submission.csv')","9a011007":"df_train.head()","d14c171d":"df_train.nunique().to_frame()","9aeeecf6":"df_train.describe()","695dfab8":"from autoviz.AutoViz_Class import AutoViz_Class\n\nAV = AutoViz_Class()","9c12e706":"filename = \"..\/input\/tabular-playground-series-oct-2021\/train.csv\"\nsep = \",\"\ndft = AV.AutoViz(\n    filename,\n    sep=\",\",\n    depVar=\"target\",\n    dfte=None,\n    header=0,\n    verbose=0,\n    lowess=False,\n    chart_format=\"svg\",\n    max_rows_analyzed=150000,\n    max_cols_analyzed=30,\n)","03b0cae9":"X = df_train.drop(columns=['id','target']).copy()\ny = df_train['target'].copy()\nX_test = df_test.drop(columns=['id']).copy()","df664d2e":"params = {'learning_rate': 0.7,\n          'max_iter': 500,\n          'max_leaf_nodes': 5,\n          'max_depth': 7,\n          'min_samples_leaf': 97,\n          'l2_regularization': 0.012598398890369964}","492e6d68":"kf = StratifiedKFold(n_splits = 5, shuffle = True, random_state=2021)\n\npreds = []\nscores = []\n\nfor fold, (idx_train, idx_valid) in enumerate(kf.split(X, y)):\n    X_train, y_train = X.iloc[idx_train], y.iloc[idx_train]\n    X_valid, y_valid = X.iloc[idx_valid], y.iloc[idx_valid]\n    \n    model = HistGradientBoostingClassifier(**params,\n                                           scoring='roc_auc')\n    model.fit(X_train,y_train)\n    \n    pred_valid = model.predict_proba(X_valid)[:,1]\n    fpr, tpr, _ = roc_curve(y_valid, pred_valid)\n    score = auc(fpr, tpr)\n    scores.append(score)\n    \n    print(f\"Fold: {fold + 1} Score: {score}\")\n    print('::'*25)\n    \n    test_preds = model.predict_proba(X_test)[:,1]\n    preds.append(test_preds)\n    \nprint(f\"Overall Validation Score: {np.mean(scores)}\")","5e378c70":"predictions = np.mean(np.column_stack(preds),axis=1)\nss['target'] = predictions\nss.to_csv('.\/gbhist.csv', index=False)\nss.head()","6f358635":"# AutoViz","ae7b4990":"# HistGradientBoost"}}