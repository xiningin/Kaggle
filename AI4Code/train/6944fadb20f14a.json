{"cell_type":{"9d6a56b1":"code","2bea7b94":"code","67dc06ea":"code","9e646d1a":"markdown"},"source":{"9d6a56b1":"code = \"\"\"\n#include <bits\/stdc++.h>\nusing namespace std;\n\n#define sqr(a) ((a) * (a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\/\/ #define debugl(...) fprintf(stderr, __VA_ARGS__)\n\/\/ #define debugl(...) fprintf(flog, __VA_ARGS__)\n#define debugl(...)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAXN 100100\n\nint D, I, S, V, F;\n\nmap<string,int> streetIds;\nvector<string> streetNames;\n\nstruct Street {\n  int B, E, L;\n  string name;\n  int id;\n  void read() {\n    static char buffer[101];\n    scanf(\"%d%d%s%d\", &B, &E, buffer, &L);\n    name = buffer;\n    id = streetIds.size();\n    streetIds[name] = id;\n    streetNames[id] = name;\n  }\n};\n\nstruct Car {\n  vector<int> path;\n  void read() {\n    int n;\n    scanf(\"%d\", &n);\n    path.resize(n);\n    for (int i = 0; i < n; ++i) {\n      static char buffer[101];\n      scanf(\"%s\", buffer);\n      path[i] = streetIds[buffer];\n    }\n  }\n};\n\nvector<pair<int,int>> adj[MAXN];\nvector<pair<int,int>> adji[MAXN];\n\nvector<Street> streets;\nvector<Car> cars;\n\nbool used[MAXN];\n\nvector<vector<int>> simulate() {\n  vector<vector<int>> X(I);\n  for (int i = 0; i < I; ++i) {\n    int cnt = 0;\n    for (pii v : adji[i]) {\n      if (used[v.second]) {\n        cnt++;\n      }\n    }\n    X[i].resize(cnt, -1);\n  }\n  vector<int> Xi(S, -1);\n\n  \/\/ queue for each intersections\n  vector<queue<int>> q;\n  q.resize(S);\n\n  \/\/ events is \"releasing a car from an intersection queue\"\n  \/\/ events[T] = queue<street id to process>\n  vector<queue<int>> events;\n  events.resize(D + 1);\n\n  \/\/ qevents is \"a car entering an intersection queue\"\n  \/\/ qevents[T] = queue<street id, car id>\n  vector<queue<pair<int, int>>> qevents;\n  qevents.resize(D + 1);\n\n  \/\/ events are triggered by:\n  \/\/ - a car entering a queue\n\n  \/\/ at T = 0, initialize all cars at the end of the streets\n  vector<int> p; \/\/ index of car path\n  p.resize(V);\n  for (int i = 0; i < V; ++i) {\n    int streetId = cars[i].path[p[i]];\n    qevents[0].emplace(streetId, i);\n  }\n\n  vector<int> arrival;\n  arrival.resize(V, -1);\n\n  for (int t = 0; t <= D; ++t) {\n    debugl(\"T = %d\\\\n\", t);\n    debugl(\"qevents.size() = %d\\\\n\", (int)qevents[t].size());\n\n    \/\/ insert cars into queue\n    while (!qevents[t].empty()) {\n      auto front = qevents[t].front();\n      qevents[t].pop();\n\n      int streetId = front.first;\n      int carId = front.second;\n      if (q[streetId].empty()) {\n        events[t].push(streetId);\n      }\n      q[streetId].push(carId);\n\n      debugl(\"\\\\t<streetId = %s, carId = %d>\\\\n\", streetNames[streetId].c_str(), carId);\n    }\n\n    debugl(\"events.size() = %d\\\\n\", (int)events[t].size());\n\n    while (!events[t].empty()) {\n      int id = events[t].front();\n      events[t].pop();\n\n      debugl(\"\\\\t<streetId = %s>\\\\n\", streetNames[id].c_str());\n\n      queue<int>& qs = q[id];\n      assert(!qs.empty());\n\n      int iid = streets[id].E;\n      int _t = t;\n      int cycle = X[iid].size();\n      int mod = t % cycle;\n      \/\/ check if id is assigned\n      if (Xi[id] != -1) {\n        debugl(\"\\\\talready assigned: %d\\\\n\", Xi[id]);\n        int cycle = X[iid].size();\n        _t = cycle * (t \/ cycle) + Xi[id];\n        if (_t < t) {\n          _t += cycle;\n        }\n      } else if (X[iid][mod] == -1) {\n        debugl(\"\\\\tempty!\\\\n\");\n        \/\/ assign it right away\n        X[iid][mod] = id;\n        Xi[id] = mod;\n        debugl(\"\\\\tAssigning <streetId = %s> = %d in <intersectionId = %d>\\\\n\", streetNames[id].c_str(), mod, iid);\n      } else {\n        \/\/ now what?\n        \/\/ just defer to t+1 I guess\n        _t = t + 1;\n      }\n\n      if (t != _t) {\n        if (_t <= D) {\n          events[_t].push(id);\n        }\n      }\n      else {\n        \/\/ take single car in the queue\n        int c = qs.front(); qs.pop();\n        p[c]++;\n        assert(p[c] < cars[c].path.size());\n        int snext = cars[c].path[p[c]];\n        int inext = streets[snext].E;\n        int tnext = t + streets[snext].L;\n\n        debugl(\"\\\\tprocessing <car = %d>: snext = %s, inext = %d, tnext = %d\\\\n\", c, streetNames[snext].c_str(), inext, tnext);\n\n        if (tnext <= D) {\n          \/\/ arrive!\n          if (p[c] == cars[c].path.size() - 1) {\n            arrival[c] = tnext;\n          }\n          else {\n            qevents[tnext].emplace(snext, c);\n          }\n        }\n\n        \/\/ reinsert self into events if queue is still not empty\n        if (!qs.empty() && t < D) {\n          events[t + 1].push(id);\n        }\n\n        debugl(\"\\\\tdone processing <car = %d>\\\\n\", c);\n      }\n    }\n  }\n\n  \/\/ assign what's left randomly\n  int maxslots = 0;\n  for (int i = 0; i < I; ++i) {\n    vector<int> slots;\n    for (int j = 0; j < X[i].size(); ++j) {\n      if (X[i][j] == -1) {\n        slots.push_back(j);\n      }\n    }\n    maxslots = max(maxslots, (int)slots.size());\n\n    for (pii v : adji[i]) {\n      if (used[v.second] && Xi[v.second] == -1) {\n        Xi[v.second] = slots.back();\n        X[i][slots.back()] = v.second;\n        slots.pop_back();\n      }\n    }\n  }\n  debugl(\"maxslots = %d\\\\n\", maxslots);\n\n  debugl(\"arrival:\\\\n\");\n  int score = 0;\n  for (int c = 0; c < V; ++c) {\n    if (arrival[c] == -1) continue;\n    assert(arrival[c] <= D);\n    score += F + D - arrival[c];\n    debugl(\"<car = %d> arrived at %d\\\\n\", c, arrival[c]);\n  }\n  debug(\"score = %d\\\\n\", score);\n\n  for (int i = 0; i < I; ++i) {\n    for (int j = 0; j < X[i].size(); ++j) {\n      assert(X[i][j] != -1);\n    }\n  }\n\n  return X;\n}\n\nint main(int argc, char** argv) {\n  srand(0);\n\n  scanf(\"%d%d%d%d%d\", &D, &I, &S, &V, &F);\n\n  streets.resize(S);\n  streetNames.resize(S);\n  for (int i = 0; i < S; ++i) {\n    streets[i].read();\n    adj[streets[i].B].emplace_back(streets[i].E, streets[i].id);\n    adji[streets[i].E].emplace_back(streets[i].B, streets[i].id);\n  }\n\n  cars.resize(V);\n  for (int i = 0; i < V; ++i) {\n    cars[i].read();\n    for (int s : cars[i].path) {\n      used[s] = true;\n    }\n  }\n\n  auto X = simulate();\n\n  vector<vector<pair<int,int>>> ans;\n\n  for (int v = 0; v < I; ++v) {\n    vector<pair<int,int>> schedule;\n    for (int x : X[v]) {\n      schedule.emplace_back(x, 1);\n    }\n    ans.emplace_back(schedule);\n  }\n  assert(ans.size() == I);\n\n  int nans = 0;\n  for (int v = 0; v < I; ++v) {\n    if (ans[v].size()) {\n      nans++;\n    }\n  }\n  printf(\"%d\\\\n\", nans);\n  for (int v = 0; v < I; ++v) {\n    if (!ans[v].size()) continue;\n    printf(\"%d\\\\n%d\\\\n\", v, (int)ans[v].size());\n    for (auto y : ans[v]) {\n      printf(\"%s %d\\\\n\", streetNames[y.first].c_str(), y.second);\n    }\n  }\n\n  return 0;\n}\n\n\"\"\"","2bea7b94":"import os\n\nwith open('program.cpp','w') as f:\n    f.write(code)\n    f.close()\n\n!g++ program.cpp && .\/a.out < \/kaggle\/input\/hashcode-2021-oqr-extension\/hashcode.in > submission.csv","67dc06ea":"# cleanup\n!rm -f a.out log","9e646d1a":"This notebook implements [this comment on Codeforces by Errichto](https:\/\/codeforces.com\/blog\/entry\/88188?#comment-765533) that achieves 2.4 million on D.\n\nQuoting the comment:\n> In D, first find all roads that are ever useful. Assume that each of them should be on for exactly 1 second. This gives you cycle size for each intersection and we are yet to fix the order of roads going in. Then simulate everything (from time 0 to D) and always do this: if a car is waiting at some intersection and this remainder modulo cycleSize isn't assigned yet, assign it now (which lets this car pass now).\n\nThis notebook also demonstrates how to compile C++ codes within Kaggle kernels. Note that all `\\` in the code should be replaced with `\\\\`."}}