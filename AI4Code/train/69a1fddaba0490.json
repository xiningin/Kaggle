{"cell_type":{"cf3458d7":"code","73b4b4d3":"code","d6024eda":"code","59323054":"code","c2a68550":"code","c315aa83":"code","e44843c3":"code","1ee1427e":"code","31d746e2":"code","1b8ef25e":"code","1e00129e":"code","2fd0f754":"code","6541c900":"code","0ce40ab0":"code","74574454":"code","868a3d51":"code","58863290":"code","00c74796":"markdown","ecc90114":"markdown","d734f93d":"markdown","5609d626":"markdown","953437ad":"markdown","9a580640":"markdown","f3dabae2":"markdown","0d0f9381":"markdown","b94c7f85":"markdown"},"source":{"cf3458d7":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom numpy.fft import *\nimport pyarrow.parquet as pq\nimport matplotlib.pyplot as plt\n\nsns.set_style(\"whitegrid\")","73b4b4d3":"signals = pq.read_table('..\/input\/train.parquet', columns=[str(i) for i in range(999)]).to_pandas()","d6024eda":"signals = np.array(signals).T.reshape((999\/\/3, 3, 800000))","59323054":"plt.figure(figsize=(15, 10))\nplt.plot(signals[0, 0, :], label='Phase 0')\nplt.plot(signals[0, 1, :], label='Phase 1')\nplt.plot(signals[0, 2, :], label='Phase 2')\nplt.legend()\nplt.show()","c2a68550":"train_df = pd.read_csv('..\/input\/metadata_train.csv')\ntrain_df.head()","c315aa83":"target = train_df['target'][::3]","e44843c3":"plt.figure(figsize=(15, 10))\nsns.countplot(target)\nplt.show()","1ee1427e":"def sample(signal, kernel_size):\n    sampled = np.zeros((signal.shape[0], signal.shape[1], signal.shape[2]\/\/kernel_size))\n    for i in range(signal.shape[2]\/\/kernel_size):\n        begin = kernel_size * i\n        end = min(kernel_size * (i + 1), signal.shape[2])\n        sampled[:, :, i] = np.mean(signal[:, :, begin:end], axis=2)\n    return sampled","31d746e2":"sampled = sample(signals, 100)","1b8ef25e":"plt.figure(figsize=(15, 10))\nplt.plot(sampled[0, 0, :], label='Phase 0')\nplt.plot(sampled[0, 1, :], label='Phase 1')\nplt.plot(sampled[0, 2, :], label='Phase 2')\nplt.legend()\nplt.show()","1e00129e":"def filter_signal(signal, threshold=1e8):\n    fourier = rfft(signal)\n    frequencies = rfftfreq(signal.size, d=20e-3\/signal.size)\n    fourier[frequencies > threshold] = 0\n    return irfft(fourier)","2fd0f754":"filtered = filter_signal(signals[0, 0, :], threshold=1e3)","6541c900":"plt.figure(figsize=(15, 10))\nplt.plot(signals[0, 0, :], label='Raw')\nplt.plot(filtered, label='Filtered')\nplt.legend()\nplt.title(\"FFT Denoising with threshold = 1e3\", size=15)\nplt.show()","0ce40ab0":"filtered = filter_signal(signals[0, 0, :], threshold=1e5)","74574454":"plt.figure(figsize=(15, 10))\nplt.plot(signals[0, 0, :], label='Raw')\nplt.plot(filtered, label='Filtered')\nplt.legend()\nplt.title(\"FFT Denoising with threshold = 1e5\", size=15)\nplt.show()","868a3d51":"filtered = filter_signal(signals[0, 0, :], threshold=1e7)","58863290":"plt.figure(figsize=(15, 10))\nplt.plot(signals[0, 0, :], label='Raw')\nplt.plot(filtered, label='Filtered')\nplt.legend()\nplt.title(\"FFT Denoising with threshold = 1e7\", size=15)\nplt.show()","00c74796":"### Testing some thresholds","ecc90114":"## 1 - Loading Data","d734f93d":"### Target","5609d626":"Thats all for now,\n#### *Thanks for reading !*\nAny feedback is appreciated","953437ad":"## 2 - Smoothing by mean\nThe idea is to reduce the length and the noise of the signal by merging $k$ neighbour values into their average.","9a580640":"### Signals","f3dabae2":"# 3 - Fast Fourier Transform denoising\n\n#### A little bit of maths ...\nThe Fourier Transform of an 1D signal $x$ of length $n$ is the following : \n\n> ### $\\mathscr{f}_j = \\sum_{k=0}^{n-1} x_k e^{\\frac{2\\pi i}{n} jk} , ~~\\forall j=0, ... , n-1$ \n\nThe idea is to represent the signal in the complex space, It is roughly a sum of sinuso\u00efdal functions. And there is one coefficient per frequency present in the signal.\n\nThe frequency takes the following values : \n- $f = \\frac{1}{dn} [0, 1, \\ldots ,   \\frac{n}{2}-1,  -\\frac{n}{2}, \\ldots , -1] $  if $n$ is even\n- $f =\\frac{1}{dn}  [0, 1, \\ldots,  \\frac{n-1}{2}, -\\frac{n-1}{2}, \\ldots, -1] $   if $n$ is odd\n\n#### Denoising algorithm\nThe denoising steps are the following :\n- Apply the fft to the signal\n- Compute the frequencies associated with each coefficient\n- Keep only the coefficients which have a low enough frequency (in absolute)\n- Compute the inverse fft\n","0d0f9381":"### Other uses of the fft ...\nThe fft coefficients can be used as features to represent the signal. I'll try that in a future kernel.\n\nHowever, there are too many of them so some more processing has to be done before feeding them into a classifier. Denoising being a solution.","b94c7f85":"# Fast Fourier Transform & Denoising\nIn this kernel, I briefly introduces two ways to perform denoising :\n- Using an averaging  smoothing technique\n- Using the FFT\n\n##### Enjoy!"}}