{"cell_type":{"f4ca06cb":"code","150fcb66":"code","a2819f9a":"code","acac9052":"code","9ec3ad41":"code","65c15f1c":"code","a25b13b9":"code","aa9ed67e":"code","8513a72d":"code","b47ee0f6":"code","67692986":"code","f8530686":"code","3288d03a":"code","e17103b4":"code","e53d7cfc":"code","7ec71804":"code","8246f900":"code","a89e60c3":"code","6cadcc34":"code","89446731":"code","13953ed4":"code","be865a0b":"code","b37530a6":"code","c1f73d20":"code","221b9a5b":"code","32f19428":"code","ab972a9e":"code","44853f97":"markdown","bea80162":"markdown","8ff0c2e7":"markdown","59a9370f":"markdown","c6e6c687":"markdown","2f7551f8":"markdown","bfefa3e6":"markdown","95bc985b":"markdown","cbc3ca79":"markdown","ce8d97b0":"markdown","ad5483c8":"markdown","2bcd3404":"markdown","67adcc24":"markdown","8adfe35b":"markdown","b7e83671":"markdown","70ac9e07":"markdown","9a6cd90a":"markdown","9de802d6":"markdown","16cea756":"markdown","52e6aad3":"markdown","f4b83bdc":"markdown","ea144e49":"markdown","6c634245":"markdown","4278a975":"markdown","93680d25":"markdown","aa001a29":"markdown","c0f2cd64":"markdown","f7e36242":"markdown","1edf0dc9":"markdown","f9664123":"markdown","a4a00aa1":"markdown","365c1fda":"markdown","e8847bc0":"markdown","bc9ac1a9":"markdown"},"source":{"f4ca06cb":"!pip install -q quick-ml","150fcb66":"import tensorflow as tf\nimport quick_ml","a2819f9a":"from quick_ml.begin_tpu import define_tpu_strategy, get_training_dataset, get_validation_dataset, get_test_dataset","acac9052":"strategy, tpu = define_tpu_strategy()","9ec3ad41":"from kaggle_datasets import KaggleDatasets\nGCS_DS_PATH = KaggleDatasets().get_gcs_path('cats-dogs-tfrecords-192x192')\nprint(GCS_DS_PATH)\n","65c15f1c":"train_tfrec_path = '\/train.tfrecords'\nval_tfrec_path = '\/val.tfrecords'","a25b13b9":"BATCH_SIZE = 16*strategy.num_replicas_in_sync\nEPOCHS = 6\nNUM_TRAINING_IMAGES = 14961\nSTEPS_PER_EPOCH = NUM_TRAINING_IMAGES \/\/ BATCH_SIZE\n\nprint(\"STEPS PER EPOCH  => \", STEPS_PER_EPOCH)","aa9ed67e":"dictionary_labeled = \"{'image_raw' : tf.io.FixedLenFeature([], tf.string),'label' : tf.io.FixedLenFeature([], tf.int64)}\"\nIMAGE_SIZE = \"192,192\"\n\nfrom quick_ml.begin_tpu import get_labeled_tfrecord_format\nget_labeled_tfrecord_format(dictionary_labeled, IMAGE_SIZE)","8513a72d":"## LOADING TRAINING DATASET\n\ntrain_dataset = get_training_dataset(GCS_DS_PATH, train_tfrec_path, BATCH_SIZE)","b47ee0f6":"### LOADING VALIDATION DATASET\n\nval_dataset = get_validation_dataset(GCS_DS_PATH, val_tfrec_path, BATCH_SIZE)","67692986":"from quick_ml.load_models_quick import create_model","f8530686":"from quick_ml.callbacks import get_callbacks\n\ncallbacks = get_callbacks(lr_scheduler = 'rampup', early_stopping = None, reduce_lr_on_plateau = None)\nprint(callbacks)","3288d03a":"with strategy.scope():\n    model = create_model(1, model_name = 'EfficientNetB1', classification_model = 'default', freeze = True,\n                         input_shape = [192,192,3], activation = 'sigmoid', weights = 'imagenet', optimizer = 'rmsprop', \n                        loss = 'binary_crossentropy', metrics = 'accuracy')","e17103b4":"model.fit(train_dataset, \n         epochs = EPOCHS,\n         steps_per_epoch = STEPS_PER_EPOCH, \n         validation_data = val_dataset, batch_size = BATCH_SIZE, callbacks = callbacks)","e53d7cfc":"with strategy.scope():\n    model2 = create_model(1, model_name = 'EfficientNetB0', classification_model = 'default', freeze = True,\n                        input_shape = [192,192,3], activation = 'sigmoid', weights = 'imagenet', optimizer = 'rmsprop',\n                        loss = 'binary_crossentropy', metrics = 'accuracy')","7ec71804":"model2.fit(train_dataset, epochs = EPOCHS, steps_per_epoch = STEPS_PER_EPOCH,\n          validation_data = val_dataset, batch_size = BATCH_SIZE\n          , callbacks = callbacks)","8246f900":"with strategy.scope():\n    model3 = create_model(1, model_name = 'ResNet50V2', classification_model = 'default', freeze = True,\n                         input_shape = [192,192,3], activation = 'sigmoid', weights = 'imagenet', \n                         optimizer = 'rmsprop', loss = 'binary_crossentropy', metrics = 'accuracy')","a89e60c3":"model3.fit(train_dataset, epochs = EPOCHS, steps_per_epoch = STEPS_PER_EPOCH, validation_data = val_dataset,\n          batch_size = BATCH_SIZE, callbacks = callbacks)","6cadcc34":"## obtain the GCS Path\n\nfrom kaggle_datasets import KaggleDatasets\nGCS_DS_PATH_unlabeled = KaggleDatasets().get_gcs_path('test-tfrecords-cats-dogs-192x192')\nprint('GCS_DS_PATH Unlabeled  -> ', GCS_DS_PATH_unlabeled)","89446731":"# Define TFRecord Format for Unlabeled Data\n\nfrom quick_ml.begin_tpu import get_unlabeled_tfrecord_format\ndictionary_unlabeled = \"{ 'image' : tf.io.FixedLenFeature([], tf.string), 'idnum' : tf.io.FixedLenFeature([], tf.string) }\"\nIMAGE_SIZE = \"192,192\"\nget_unlabeled_tfrecord_format(dictionary_unlabeled, IMAGE_SIZE)","13953ed4":"\ntest_tfrec_path = '\/test_cats_dogs_192x192.tfrecords'\nBATCH_SIZE = 16 * strategy.num_replicas_in_sync\ntest_dataset = get_test_dataset(GCS_DS_PATH_unlabeled, test_tfrec_path, BATCH_SIZE)","be865a0b":"from quick_ml.predictions import ensemble_predictions","b37530a6":"models = [model, model2, model3]\nensemble_predictions(models, test_dataset, ensemble_type = 'Model Averaging', classification_type = \"binary\")","c1f73d20":"import pandas as pd\n\ndf = pd.read_csv('.\/ensemble_model_averaging.csv')","221b9a5b":"df","32f19428":"ensemble_predictions(models, test_dataset, ensemble_type = 'Model Weighted', classification_type = 'binary', weights = [0.2,0.3,0.5])","ab972a9e":"df2 = pd.read_csv('\/kaggle\/working\/ensemble_model_weighted.csv')\ndf2","44853f97":"## Predictions","bea80162":"### Define Labeled TFRecord Format","8ff0c2e7":"## Official Website of quick_ml -> [quick_ml](http:\/\/antoreepjana.wixsite.com\/quick-ml)","59a9370f":"weighted predictions with weight for model1, model2, model3 being 0.2, 0.3, 0.5 respectively.","c6e6c687":"Specifications :-\n* ResNet50V2\n* Binary Output -> n_class -> 1\n* classification model -> using 'default' classification model used by quick_ml. This is the classification model by removing the top of the pretrained model architecture. You can define your own classification model using TF and pass it as an argument to 'classification_model'\n* freeze -> True or False, depening on whether to freeze the entire model during training or not\n* input_shape -> of the images in TFRecords\n* activation -> sigmoid\n* weights -> imagenet\n\nFor compilation\n* optimizer -> RMSProp\n* loss -> binary cross entropy\n* metrics -> accuracy","2f7551f8":"## Get TPU strategy & Instance","bfefa3e6":"##### Loading the test dataset","95bc985b":"Once **GCS_DS_PATH** for the Labeled Dataset is obtained, the **train_tfrec_path** is mentioned & the **Batch Size** is defined along with the above step where we mentioned the labeled_tfrecord_format, we can begin loading the training datasets. Learn more by scrolling down to **get_training_dataset** section under **Begin Working w\/ TPU** page. ","cbc3ca79":"Please keep the order of imports same as mentioned below. Tensorflow should be imported first. quick_ml should be imported after tensorflow.","ce8d97b0":"Since we are about to ensemble model predictions, use ensemble_predicitons. Learn more about ensemble predictions using quick_ml [here](https:\/\/antoreepjana.wixsite.com\/quick-ml\/predictions).","ad5483c8":"define_tpu_strategy is used to instantiate the TPU strategy (if TPU present) & tpu instance (if TPU present).\nLearn more [here](https:\/\/antoreepjana.wixsite.com\/quick-ml\/begin-working-w-tpu)","2bcd3404":"Specifications :-\n* Efficient Net B1\n* Binary Output -> n_class -> 1\n* classification model -> using 'default' classification model used by quick_ml. This is the classification model by removing the top of the pretrained model architecture. You can define your own classification model using TF and pass it as an argument to 'classification_model'\n* freeze -> True or False, depening on whether to freeze the entire model during training or not\n* input_shape -> of the images in TFRecords\n* activation -> sigmoid\n* weights -> imagenet\n\nFor compilation\n* optimizer -> RMSProp\n* loss -> binary cross entropy\n* metrics -> accuracy","67adcc24":"Once **GCS_DS_PATH** for the Labeled Dataset is obtained, the **val_tfrec_path** is mentioned & the **Batch Size** is defined along with the above step where we mentioned the labeled_tfrecord_format, we can begin loading the training datasets. Learn more by scrolling down to **get_validation_dataset** section under **Begin Working w\/ TPU** page. ","8adfe35b":"### Define Parameters","b7e83671":"Note:- Please mention the full name of the dataset as an argument in get_gcs_path() rather than leaving it empty. In presence of more than one dataset, it would cause conflict. However, in the presence of single dataset, it's a good practice to mention the full name of the dataset as an argument in the get_gcs_path().","70ac9e07":"Specifications :-\n* Efficient Net B0\n* Binary Output -> n_class -> 1\n* classification model -> using 'default' classification model used by quick_ml. This is the classification model by removing the top of the pretrained model architecture. You can define your own classification model using TF and pass it as an argument to 'classification_model'\n* freeze -> True or False, depening on whether to freeze the entire model during training or not\n* input_shape -> of the images in TFRecords\n* activation -> sigmoid\n* weights -> imagenet\n\nFor compilation\n* optimizer -> RMSProp\n* loss -> binary cross entropy\n* metrics -> accuracy","9a6cd90a":"#### Loading the Datasets","9de802d6":"### Model 2","16cea756":"## Obtaining Model Predictions","52e6aad3":"### Define the training parameters","f4b83bdc":"Model Weighted Ensemble","ea144e49":"After successful installation and correct imports of the both packages, you should see a message indicating status of Tensorflow import & it's version number.","6c634245":"## Summary -> <br>\nIn this notebook, we'll learn how quick_ml simplifies Ensemble Model training & obtaininig predictions. <br>\nThe process workflow is extremely simple and simple to simple model training using quick_ml. For reference, you can check simple model training using quick_ml [here](https:\/\/www.kaggle.com\/antoreepjana\/quick-ml-binary-classification-cats-dogs).","4278a975":"Define any callbacks you want while model training. Learn more about callbacks [here](https:\/\/antoreepjana.wixsite.com\/quick-ml\/callbacks)","93680d25":"* Batch Size - Usually 16 * strategy.num_replicas_in_sync. However, 32*strategy.num_replicas_in_sync will work equally good and faster.\n* Number of Epochs to train for\n* Num_Training_Images \n* Steps Per Epoch","aa001a29":"If the GCS_DS_PATH was printed sucessfully, mention the relative path (relative to the GCS_DS_PATH's folder directory) of the tfrec files.","c0f2cd64":"### Model 3","f7e36242":"### Necessary Imports","1edf0dc9":"### Model 1","f9664123":"Define the Test TFRecords Files as follows:\n\n* obtain the GCS_DS_PATH and\n* store it in a different variable (different from the one used for labeled\/train tfrecords).\n* get the relative path of the Test TFRecords Files (relative to the directory of Test TFRecords)\n* define the unlabeled TFRecord format using get_unlabeled_tfrecord_format. Learn more [here](https:\/\/antoreepjana.wixsite.com\/quick-ml\/begin-working-w-tpu)","a4a00aa1":"get_labeled_tfrecord_format is used to define the format of the TFRecords dataset to be used for model trianing. Learn more [here](https:\/\/antoreepjana.wixsite.com\/quick-ml\/begin-working-w-tpu)","365c1fda":"Model Averaging Ensemble","e8847bc0":"## Single Model Training ( 3 different Models)","bc9ac1a9":"Use create_model to create_model and compile it in the fastest possible manner. Learn more about create model [here](https:\/\/antoreepjana.wixsite.com\/quick-ml\/create-models-quickly)"}}