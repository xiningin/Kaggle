{"cell_type":{"ef012d02":"code","7d664963":"code","b06ff828":"code","9b397250":"code","01d2118d":"code","19d456b2":"code","4840e22f":"code","be149750":"code","64b4df3b":"code","cc3eea9a":"code","9ef0db48":"code","bcf69df1":"code","a801f808":"code","f0a0a209":"code","cc2e6bbd":"code","7b55d385":"code","eeb88585":"code","8dfa4f29":"code","02868b31":"code","28394d42":"code","70c37bb7":"code","1672e2b2":"code","0f1f64fa":"code","6a9de5c2":"code","5cd43b2f":"code","bd90596a":"code","ffeef19b":"code","69beaad3":"code","e14c54aa":"markdown","4a063a59":"markdown","62024192":"markdown","875606bf":"markdown","8cc620be":"markdown","c5c170a9":"markdown"},"source":{"ef012d02":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport nibabel as nib\nfrom tqdm import tqdm\nfrom scipy import stats\nimport matplotlib\nimport matplotlib.pyplot as plt # for plotting\nimport seaborn as sns","7d664963":"ROOT = \"\/kaggle\/input\/trends-assessment-prediction\/\"\n!ls {ROOT}","b06ff828":"# image and mask directories\ndata_dir = f'{ROOT}\/fMRI_train'\nloading_data = f'{ROOT}loading.csv'\nicn_data = f'{ROOT}ICN_numbers.csv'\nfnc_data = f'{ROOT}fnc.csv'\ntrain_scores_data = f'{ROOT}train_scores.csv'\nfmri_mask = f'{ROOT}fMRI_mask.nii'","9b397250":"load_data = pd.read_csv(loading_data)\nicn_data = pd.read_csv(icn_data)\nfnc_data = pd.read_csv(fnc_data)\ntrain_scores_data = pd.read_csv(train_scores_data)","01d2118d":"load_data.head()","19d456b2":"print(load_data.shape)","4840e22f":"load_data.head()","be149750":"icn_data.head()","64b4df3b":"icn_data.shape","cc3eea9a":"fnc_data.head()","9ef0db48":"train_scores_data.head()","bcf69df1":"targets= load_data.columns[1:]\nfig, axes = plt.subplots(6, 5, figsize=(18, 15))\naxes = axes.ravel()\nbins = np.linspace(-0.05, 0.05, 20)\n\nfor i, col in enumerate(targets):\n    ax = axes[i]\n    sns.distplot(load_data[col], label=col, kde=False, bins=bins, ax=ax)\nplt.tight_layout()\nplt.show()\nplt.close()","a801f808":"targets= train_scores_data.columns[1:]\nfig, axes = plt.subplots(1, 5, figsize=(18, 4))\naxes = axes.ravel()\nbins = np.linspace(0, 100, 20)\n\nfor i, col in enumerate(targets):\n    ax = axes[i]\n    sns.distplot(train_scores_data[col], label=col, kde=False, bins=bins, ax=ax)\n\nplt.tight_layout()\nplt.show()\nplt.close()","f0a0a209":"fig, ax = plt.subplots(figsize=(8, 6))\ncols = load_data.columns[1:]\nsns.heatmap(load_data[cols].corr(), ax=ax)","cc2e6bbd":"fig, ax = plt.subplots(figsize=(8, 6))\ncols = train_scores_data.columns[1:]\nsns.heatmap(train_scores_data[cols].corr(), ax=ax)","7b55d385":"img = nib.load(fmri_mask)","eeb88585":"print(img.shape)\nprint(img.get_data_dtype())\nprint(img.get_data_dtype() == np.dtype(np.float32))\nprint(img.affine.shape)\ndata = img.get_fdata()\nprint(data.shape)\nprint(type(data))\nhdr = img.header\nprint(hdr.get_xyzt_units())\nraw = hdr.structarr\nprint(raw['xyzt_units'])","8dfa4f29":"df_loading_train = load_data[load_data.Id.isin(train_scores_data.Id)]\ndf_loading_test = load_data[~load_data.Id.isin(train_scores_data.Id)]","02868b31":"df_loading_train.head()","28394d42":"df_loading_test.head()","70c37bb7":"# Equally splitted data \nprint(df_loading_test.shape)\nprint(df_loading_train.shape)","1672e2b2":"df_fnc_train = fnc_data[fnc_data.Id.isin(train_scores_data.Id)]\ndf_fnc_test = fnc_data[~fnc_data.Id.isin(train_scores_data.Id)]","0f1f64fa":"print(df_fnc_train.shape)\nprint(df_fnc_test.shape)","6a9de5c2":"df_train_loading_fcn = pd.merge(df_loading_train, df_fnc_train, on = 'Id', how = 'inner')\ndf_test_loading_fcn =   pd.merge(df_loading_test, df_fnc_test, on = 'Id', how = 'inner')\n\nprint(df_train_loading_fcn.shape)\nprint(df_test_loading_fcn.shape)","5cd43b2f":"columns = df_train_loading_fcn.columns\ndf_test_loading_fcn = df_test_loading_fcn[columns]","bd90596a":"p_value = .00001   # you can change the p-value and experiment\nlist_p_value =[]\n\nfor i in tqdm(columns[1:]):\n    list_p_value.append(stats.ks_2samp(df_test_loading_fcn[i] , df_train_loading_fcn[i])[1])\n\nSe = pd.Series(list_p_value, index = columns[1:]).sort_values() \nlist_dissimilar = list(Se[Se < p_value].index)","ffeef19b":"len(list_dissimilar)","69beaad3":"df_train_loading_fcn.head()","e14c54aa":"More Coming Soon...","4a063a59":"Human brain research is among the most complex areas of study for scientists. We know that age and other factors can affect its function and structure, but more research is needed into what specifically occurs within the brain. With much of the research using MRI scans, data scientists are well positioned to support future insights. In particular, neuroimaging specialists look for measurable markers of behavior, health, or disorder to help identify relevant brain regions and their contribution to typical or symptomatic effects.\n\n\nIn this competition, you will predict multiple assessments plus age from multimodal brain MRI features. You will be working from existing results from other data scientists, doing the important work of validating the utility of multimodal features in a normative population of unaffected subjects. Due to the complexity of the brain and differences between scanners, generalized approaches will be essential to effectively propel multimodal neuroimaging research forward.","62024192":"# Reading a nii file","875606bf":"Splitting the DataFrame into Train and Test\n","8cc620be":"NiBabel supports an ever growing collection of neuroimaging file formats. Every file format format has its own features and pecularities that need to be taken care of to get the most out of it. To this end, NiBabel offers both high-level format-independent access to neuroimages, as well as an API with various levels of format-specific access to all available information in a particular file format. The following examples show some of NiBabel\u2019s capabilities and give you an idea of the API.","c5c170a9":"![image.png](attachment:image.png)"}}