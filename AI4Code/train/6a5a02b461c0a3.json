{"cell_type":{"bbccbdf1":"code","c618231b":"code","e1037164":"code","2ad9c27e":"code","5541d962":"code","9e1f04d0":"code","4d2275db":"code","387b6f04":"code","862ac5ab":"code","8ef62c0b":"code","2b7bd8ba":"code","64e7b0a7":"code","dc1dec2f":"code","c586d9cf":"code","701838f3":"code","b459488b":"code","d8596258":"code","0fdcf8ea":"code","0a34fcbb":"code","8bac32ec":"code","68ce77e4":"markdown","41500697":"markdown","26755988":"markdown","f0605d26":"markdown"},"source":{"bbccbdf1":"import os\nimport json\nimport numpy as np\nfrom pathlib import Path\nimport random\nfrom collections import Counter\nimport pandas as pd\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n","c618231b":"torch.backends.cudnn.deterministic = True\ntorch.backends.cudnn.benchmark = False","e1037164":"data_path = Path('\/kaggle\/input\/abstraction-and-reasoning-challenge')\ntrain_path = data_path \/ 'training'\nvalid_path = data_path \/ 'evaluation'\ntest_path = data_path \/ 'test'\n","2ad9c27e":"SEEDS = [0,1,2]","5541d962":"def set_seeds(seed):\n    torch.manual_seed(seed)\n    np.random.seed(seed)\n    torch.cuda.manual_seed(seed)\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED']=str(seed)","9e1f04d0":"set_seeds(0) # i set seed here just in case. really seads are set in predict_tasks function. ","4d2275db":"paths = {'train': train_path, 'eval': valid_path, 'test': test_path}\n\ndef get_tasks(dataset='train'):\n    path = paths[dataset]\n    fns = sorted(os.listdir(path))\n    tasks = {}\n    for idx, fn in enumerate(fns):\n        fp = path \/ fn\n        with open(fp, 'r') as f:\n            task = json.load(f)\n            tasks[fn.split('.')[0]] = task\n    return tasks\n\n\ntest_tasks = get_tasks('test')","387b6f04":"def input_output_shape_is_same(task):\n    return all([np.array(el['input']).shape == np.array(el['output']).shape for el in task['train']])","862ac5ab":"class Encoder():\n    def __init__(self, task):\n        pass\n    \n    def encode(self, inp):\n        inp = np.array(inp)\n        img = np.full((10, inp.shape[0], inp.shape[1]), 0, dtype=np.uint8)\n        for i in range(10):\n            img[i] = (inp==i)\n        return img\n    \n    def encode_y(self, inp):\n        inp = np.array(inp)\n        return inp\n    \n    \n    def decode(self,img, num_states):\n        return img[:, :num_states, :, :].argmax(1).squeeze().cpu().numpy()","8ef62c0b":"def encode_colors(array, color2num):\n\n    new_array = np.empty_like(array)\n    for i in range(array.shape[0]):\n        for j in range(array.shape[1]):\n            new_array[i, j] = color2num[array[i, j]]\n    return new_array","2b7bd8ba":"class ColorFreqEncoder():\n    def __init__(self, sample, task):\n        train = task['train']\n        sample0 = train[0]\n        input0 = sample0['input']\n        output0 = sample0['output']\n        input0_colors_cnt = Counter(np.array(input0).flatten().tolist())\n        output0_colors_cnt = Counter(np.array(output0).flatten().tolist())\n        sorted_input0_colors = [color for color,_ in input0_colors_cnt.most_common()]\n        sorted_output0_colors =  [color for color,_ in output0_colors_cnt.most_common()\n                                 if color not in sorted_input0_colors]\n        input_colors_cnt = Counter(np.array(sample['input']).flatten().tolist())\n        sorted_input_colors = [color for color,_ in input_colors_cnt.most_common()]\n        task_colors = sorted_input_colors + sorted_output0_colors\n        self.color2num = {color:num for num, color in enumerate(task_colors)}\n        self.num2color = task_colors\n        self.num_states = len(task_colors)\n\n        self.encoder = Encoder(sample)\n    \n    def encode(self, array):\n        array = np.array(array)\n        array = encode_colors(array, self.color2num)\n        img = self.encoder.encode(array)\n        return img\n    def encode_y(self, array):\n        array = np.array(array)\n        array = encode_colors(array, self.color2num)\n        return self.encoder.encode_y(array)\n    \n    def decode(self, img):\n        out = self.encoder.decode(img, self.num_states)\n        return encode_colors(out, self.num2color)","64e7b0a7":"class CAModel(nn.Module):\n    def __init__(self, num_states):\n        super(CAModel, self).__init__()\n        self.transition = nn.Sequential(\n            nn.Conv2d(num_states,128, kernel_size=3, padding=0),\n            nn.ReLU(),\n            nn.Conv2d(128, num_states, kernel_size=1)\n        \n        )\n        \n    def forward(self, x, steps=1):\n        for _ in range(steps):\n            x = nn.functional.pad(x, (1,1,1,1), 'constant', 1)\n            x = self.transition(torch.softmax(x, dim=1))\n        return x","dc1dec2f":"@torch.no_grad()\ndef predict(model, task, num_steps=100, mode='train'):\n    task_ = task\n    task = task[mode]\n    model.eval()\n    predictions = []\n    for sample in task:\n        encoder = ColorFreqEncoder(sample, task_)\n        x = torch.from_numpy(encoder.encode(sample[\"input\"])).unsqueeze(0).float().to(device)\n        pred = encoder.decode(model(x, num_steps))\n        predictions.append(pred)\n    return predictions\n\n\ndef solve_task(task, max_steps=10):\n    \n    task_ = task\n    task = task['train']\n    model = CAModel(10).to(device)\n    model.train()\n    num_epochs = 100\n    num_epochs_2 = 1\n    criterion = nn.CrossEntropyLoss()\n    losses = np.zeros((max_steps - 1) * num_epochs * num_epochs_2)\n    for ep2 in range(num_epochs_2):\n        for num_steps in range(ep2 +1, max_steps):\n            optimizer = torch.optim.Adam(model.parameters(), lr=(0.1 \/ (num_steps * 2)))\n\n            for e in range(num_epochs):\n                optimizer.zero_grad()\n                loss = 0.0\n\n                for sample in task:\n                    encoder= ColorFreqEncoder(sample, task_)\n                    x = torch.from_numpy(encoder.encode(sample[\"input\"])).unsqueeze(0).float().to(device)\n                    y = torch.tensor(encoder.encode_y(sample[\"output\"])).long().unsqueeze(0).to(device)\n                    y_pred = model(x, num_steps)\n                    loss += criterion(y_pred, y)\n\n                    y_in = torch.from_numpy(encoder.encode(sample[\"output\"])).unsqueeze(0).float().to(device)\n                    y_pred = model(y_in, 1) \n                    loss +=  criterion(y_pred, y)\n\n\n                loss.backward()\n                optimizer.step()\n                losses[ep2 * num_epochs * (num_steps - 1) + (num_steps - 1) * num_epochs + e] = loss.item()\n                random.shuffle(task)\n            \n    return model, num_steps, losses","c586d9cf":"def color_n(array):\n    array = np.array(array)\n    return len(set(array.flatten().tolist()))","701838f3":"def get_colors(array):\n    array = np.array(array)\n    return set(array.flatten().tolist())","b459488b":"def same_color_number(task):\n    train = task['train']\n    test = task['test']\n    inputs = [sample['input'] for sample in train + test]\n    outputs = [sample['output'] for sample in train]\n    input_color_n = color_n(inputs[0])\n    output_color_n =color_n(outputs[0])\n    only_output_colors = get_colors(outputs[0]) - get_colors(inputs[0])\n    for input in inputs:\n        if color_n(input) != input_color_n:\n            return False\n    for output in outputs:\n        if color_n(output) != output_color_n:\n            return False\n    for input,output in zip(inputs, outputs):\n        if get_colors(output) - get_colors(input) != only_output_colors:\n            return False\n    return True","d8596258":"def predict_tasks(tasks):\n    predictions = {}\n    k = 0\n    for idx, task in tqdm(tasks.items()):\n\n        if input_output_shape_is_same(task) and same_color_number(task): \n            preds = [[]] * len(task['test'])\n            for i in SEEDS:\n                set_seeds(i)\n                model, num_steps, _ = solve_task(task)\n                pred = predict(model, task, mode='test')\n                for j in range(len(task['test'])):\n                    preds[j].append(pred[j])\n        else:\n            preds = []\n        k += 1\n        predictions[idx] = preds\n\n    return predictions","0fdcf8ea":"predictions = predict_tasks(test_tasks)","0a34fcbb":"def get_string(pred):\n    str_pred = str([list(row) for row in pred])\n    str_pred = str_pred.replace(', ', '')\n    str_pred = str_pred.replace('[[', '|')\n    str_pred = str_pred.replace('][', '|')\n    str_pred = str_pred.replace(']]', '|')\n    return str_pred","8bac32ec":"def submit():\n    submission = pd.read_csv(data_path \/ 'sample_submission.csv', index_col='output_id')\n    submission['output'] = ''\n    test_fns = sorted(os.listdir(test_path))\n    count = 0\n    for fn in test_fns:\n        fp = test_path \/ fn\n        with open(fp, 'r') as f:\n            task_idx = fn.split('.')[0]\n            all_input_preds = predictions[task_idx]\n            if all_input_preds:\n                count += 1\n\n                for i, preds in enumerate(all_input_preds):\n                    output_id = str(fn.split('.')[-2]) + '_' + str(i)\n                    string_preds = [get_string(pred) for pred in preds[:3]]\n                    pred = ' '.join(string_preds)\n                    submission.loc[output_id, 'output'] = pred\n    print(count)\n    submission.to_csv('submission.csv')\n\nsubmit()\n","68ce77e4":"Part of 9th place solution","41500697":"Changes comparing to original kernel: using 3 random seeds, encoding colors by frequency (useful for tasks when colors change from example to example).","26755988":"Based on @teddykoker \"Training Cellular Automata Part II: Learning Tasks\" kernel: https:\/\/www.kaggle.com\/teddykoker\/training-cellular-automata-part-ii-learning-tasks.","f0605d26":"# Cellular Automata with ColorFreqEncoder"}}