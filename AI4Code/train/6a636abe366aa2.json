{"cell_type":{"98d57d94":"code","b2b5eed6":"code","0f50be70":"code","9aa607ee":"code","87ae379b":"code","804336ec":"code","b2a20fb1":"code","ac43a548":"code","669d90ac":"code","8c72bbe4":"code","1a8aa137":"code","0a6171a4":"code","19a0b13a":"code","86af58cc":"code","caf291c6":"code","5dc1f50d":"code","d6bdb45a":"code","3cd20408":"code","91abdd50":"code","49a4b521":"code","bc720781":"code","d11f7735":"code","3a97251d":"code","56281871":"code","455ac371":"code","2a7f31d9":"code","eefe4eec":"code","dfab1887":"code","3dce1f6b":"code","e1d38fdd":"code","bb922948":"code","b9296405":"code","9c02ad10":"code","5bdda6b1":"code","e6bf9bdc":"code","37013c66":"code","7b2d1467":"code","7fb1f4be":"code","b986b546":"code","322297d7":"code","998734ef":"code","6632616f":"code","8556045e":"code","82f9823e":"code","e2637057":"code","d679d3f3":"code","caee4a3f":"markdown","54ab9443":"markdown","821a6ca3":"markdown","d13e907c":"markdown","69581e31":"markdown","c400c4e5":"markdown","12820ef4":"markdown","bd9f85e9":"markdown","e4c1d83a":"markdown","cc9a5bb0":"markdown","579763f8":"markdown","d156fab4":"markdown","40ed172e":"markdown","a0f51207":"markdown","de576672":"markdown","261b9f73":"markdown","a59c0228":"markdown","ce8c609b":"markdown","9d28117d":"markdown","28e2eedd":"markdown","493a4f60":"markdown","d0763f95":"markdown","808d4e5e":"markdown","05dcfb35":"markdown","8e5bbd61":"markdown","6ff2a044":"markdown"},"source":{"98d57d94":"import pandas as pd\nimport lightgbm as lgb","b2b5eed6":"import os\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.model_selection import train_test_split\n\ntrain = pd.read_csv('\/kaggle\/input\/iris\/Iris.csv', index_col='Id')\ndataX = train[ train.columns[train.columns.str.contains('Cm$')] ]\ndatay = OrdinalEncoder().fit_transform(train[['Species']]).flatten().astype(int)\ntrainSet = lgb.Dataset(dataX, datay)\n\nparam = {'objective'       : 'multiclass',\n         'metric'          : 'multi_logloss',\n         'num_class'       : train['Species'].nunique(),\n         'num_leaves'      : 3,\n         'min_data_in_leaf': 36, \n         'learning_rate'   : .15,\n         'num_boost_round' : 30}\nmodel = lgb.train(param, trainSet)","0f50be70":"def grabdict(tisdict, tree_index, split_index, depth, splits, leaves):\n# recursive function to unravel nested dictionaries\n    depth += 1\n    if 'split_index' in tisdict.keys():\n        tis = tisdict.copy()\n        del tis['left_child']\n        del tis['right_child']\n        tis['tree_index'] = tree_index\n        split_index = tis['split_index']\n        splits = pd.concat([splits, pd.DataFrame(tis, index=[len(splits)])])\n        splits, leaves = grabdict(tisdict['left_child'], tree_index, split_index, depth, splits, leaves)\n        splits, leaves = grabdict(tisdict['right_child'], tree_index, split_index, depth, splits, leaves)\n    else:\n        tis = tisdict.copy()\n        tis['tree_index'] = tree_index\n        tis['split_index'] = split_index\n        tis['depth'] = depth\n        leaves = pd.concat([leaves, pd.DataFrame(tis, index=[len(leaves)])])\n    return splits, leaves\n\ndef grabtrees(model):\n# wrapper function to call the two functions above\n    splits, leaves = pd.DataFrame(), pd.DataFrame()\n    tree_info = model.dump_model()['tree_info']\n    for tisdict in tree_info:\n        splits, leaves = grabdict(tisdict['tree_structure'], tisdict['tree_index'], 0, 0, splits, leaves)\n    leaves = leaves.merge(splits, left_on=['tree_index', 'split_index'], right_on=['tree_index', 'split_index'], how='left')\n    return tree_info, leaves\n\ntree_info, leaves = grabtrees(model)\nleaves   # all leaves in a single df: one leaf per row","9aa607ee":"# How many trees altogether?\nhow_many_trees = len(tree_info)\nassert how_many_trees == param['num_boost_round'] * param['num_class']\nhow_many_trees","87ae379b":"leaves.describe()","804336ec":"import matplotlib.pyplot as plt\ncols = leaves.select_dtypes(include='float').columns\nplt.figure(figsize=(20, 3))\nfor ncol, col in enumerate(cols):\n    plt.subplot(1, len(cols), 1+ncol)\n    plt.plot(leaves['tree_index'], leaves[col], '.')\n    plt.title(col); plt.grid(True); plt.xlabel('tree_index')\n# Never mind the details. Suffice to note at this point that the 90 trees we get are not independent. There is a clear monotonic trend towards convergence.","b2a20fb1":"plt.figure(figsize=(20, 3))\nfor nleaf_index, leaf_index in enumerate(leaves['leaf_index'].unique()):\n    plt.subplot(1, leaves['leaf_index'].nunique(), 1+nleaf_index)\n    select = leaves['leaf_index']==leaf_index\n    plt.plot(leaves.loc[select, 'tree_index'], leaves.loc[select, 'leaf_value'], '.-')\n    plt.xlabel('tree_index')\n    plt.title(f'leaf_index={leaf_index}')\n    plt.grid(True)","ac43a548":"# our first tree\nleaves.loc[ leaves['tree_index']==0 ]","669d90ac":"tree_info[0]","8c72bbe4":"show_info = ['split_gain', 'internal_value', 'internal_weight', 'internal_count', 'leaf_weight', 'leaf_count', 'data_percentage']\nlgb.plot_tree(model, tree_index=0, show_info=show_info)\n# Here we find 1 split (square) and 2 leaves (oval). This is a tree in its simplest form. More complicated trees later.","1a8aa137":"model.feature_name()[tree_info[0]['tree_structure']['split_feature']]","0a6171a4":"leaves.loc[ leaves['tree_index']==0 ][['threshold', 'split_gain', 'internal_value', 'internal_weight', 'internal_count']]\n# These values are characteristic of the split. Therefore shared in common by both leaves.","19a0b13a":"tree_info[0]['tree_structure']['threshold']","86af58cc":"tree_info[0]['tree_structure']['split_gain']","caf291c6":"tree_info[0]['tree_structure']['internal_value']","5dc1f50d":"tree_info[0]['tree_structure']['internal_weight']","d6bdb45a":"tree_info[0]['tree_structure']['internal_count']","3cd20408":"tree_info[0]['tree_structure']['internal_count'] \/ len(dataX) * 100","91abdd50":"leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==0)]","49a4b521":"tree_info[0]['tree_structure']['left_child']","bc720781":"tree_info[0]['tree_structure']['left_child']['leaf_count'] \/ len(dataX) * 100","d11f7735":"(dataX['PetalLengthCm']<=3.15).sum(),   leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==0), 'leaf_count'].values","3a97251d":"leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==1)]","56281871":"tree_info[0]['tree_structure']['right_child']","455ac371":"tree_info[0]['tree_structure']['right_child']['leaf_count'] \/ len(dataX) * 100","2a7f31d9":"(dataX['PetalLengthCm']>3.15).sum(),   leaves.loc[ (leaves['tree_index']==0) & (leaves['leaf_index']==1), 'leaf_count'].values","eefe4eec":"tree_info[0]['tree_structure']['internal_count'] == \\\ntree_info[0]['tree_structure']['left_child']['leaf_count'] + \\\ntree_info[0]['tree_structure']['right_child']['leaf_count']\n# Yes!","dfab1887":"leaves.loc[ leaves['tree_index'] == leaves['tree_index'].max() ]","3dce1f6b":"tree_info[-1]\n# See that num_leaves=3 so we rightly found 3 leaves in the previous cell","e1d38fdd":"lgb.plot_tree(model, tree_index=89, figsize=(10, 10), show_info=show_info)\n# Here we find 2 splits (square) and 3 leaves (oval).\n# Leaf count is 3, consistent with the output from the previous 2 cells.","bb922948":"leaves.loc[ (leaves['tree_index']==89) & (leaves['split_index']==0) ]\n* Note that each box splits into two. Always two: either Yes or No. Not one. Not more.","b9296405":"leaves.loc[ (leaves['tree_index']==89) & (leaves['split_index']==1) ]","9c02ad10":"sum((dataX['PetalWidthCm']<=1.35) & \\\n    (dataX['SepalWidthCm']<=3.05)),   leaves.loc[ (leaves['tree_index']==89) & (leaves['leaf_index']==0), 'leaf_count'].values","5bdda6b1":"sum(dataX['PetalWidthCm']>1.35),   leaves.loc[ (leaves['tree_index']==89) & (leaves['leaf_index']==1), 'leaf_count'].values","e6bf9bdc":"sum((dataX['PetalWidthCm']<=1.35) & \\\n    (dataX['SepalWidthCm']>3.05)),   leaves.loc[ (leaves['tree_index']==89) & (leaves['leaf_index']==2), 'leaf_count'].values","37013c66":"param.update({'num_leaves'      : 50,  # set ridiculously high for demo purpose\n              'min_data_in_leaf': 2})  # letting our guard down for demo purpose\nmodel = lgb.train(param, trainSet)\ntree_info, leaves = grabtrees(model)\nleaves.sort_values(by='depth', ascending=False)","7b2d1467":"deepest_leaf = leaves.loc[leaves['depth'].argmax()]\ndeepest_leaf","7fb1f4be":"tree_with_deepest_leaf = deepest_leaf['tree_index']\nleaves.loc[ leaves['tree_index']==tree_with_deepest_leaf ]","b986b546":"lgb.plot_tree(model, tree_index=int(tree_with_deepest_leaf), figsize=(20, 15), show_info=show_info)\n# We count 36 ovals and 35 boxes; by now we notice that number of ovals = 1 + number of boxes.","322297d7":"len(leaves.loc[ leaves['tree_index']==tree_with_deepest_leaf ])\n# All good.","998734ef":"leaves.loc[ leaves['tree_index']==tree_with_deepest_leaf, 'split_index' ].max() + 1\n# Perfect tally.","6632616f":"leaves.sort_values(by='split_index', ascending=False)\n# No. \n# The deepest tree has depth=18 and max(split_index)=31. \n# The tree with most splits has depth=11 and max(split_index)=41.","8556045e":"leaf_with_most_splits = leaves.loc[leaves['split_index'].argmax()]\ntree_with_most_splits = leaf_with_most_splits['tree_index']","82f9823e":"lgb.plot_tree(model, tree_index=int(tree_with_most_splits), figsize=(20, 15), show_info=show_info)\n# We count 42 boxes and 43 ovals","e2637057":"leaves.loc[leaves['tree_index']==tree_with_most_splits, 'split_index'].max() + 1\n# Yes!","d679d3f3":"(leaves['tree_index']==tree_with_most_splits).sum()\n# Yes!","caee4a3f":"### 6.5 The 3rd leaf (leaf_index=2, count=42)","54ab9443":"# 4. A quick bird's-eye tour","821a6ca3":"### 6.1 The 1st split (split_index=0)","d13e907c":"### 7.2 Plot our deepest tree yet","69581e31":"### 7.7 Does the number boxes agree with max(split_index)+1?","c400c4e5":"### 6.2 The 2nd split (split_index=1)","12820ef4":"# 5. Case study (*Tree* study, rather)","bd9f85e9":"# 7. Bump *num_leaves* up to something ridiculous","e4c1d83a":"# 2. Toy data & toy model \nBorrowing data from https:\/\/www.kaggle.com\/uciml\/iris.\n*Replace next cell with your own data.*","cc9a5bb0":"### 7.1 Grab the deepest leaf of all","579763f8":"# 8. Sister notebooks: the Leaf-by-leaf series\nDecision trees: a leaf-by-leaf demo  (we are here)\n\nhttps:\/\/www.kaggle.com\/marychin\/decision-trees-a-leaf-by-leaf-demo\n\n**num_leaves** and **min_data_in_leaf**: a LightGBM demo\n\nhttps:\/\/www.kaggle.com\/marychin\/num-leaves-min-data-in-leaf-a-lightgbm-demo\n\nmin_sum_hessian: a LightGBM demo\n\nhttps:\/\/www.kaggle.com\/marychin\/min-sum-hessian-a-lightgbm-demo\n\nfeature_importances split vs gain: a demo\n\nhttps:\/\/www.kaggle.com\/marychin\/feature-importances-split-vs-gain-a-demo\n\n# 9. Cheers, Kagglers & Kaggle!\nTogether we democratise learning and skills.","d156fab4":"### 7.4 Verify that total number of boxes = max(split_index) + 1\nWe need to plus one because split_index starts from zero.","40ed172e":"### 7.5 Is the deepest tree the one with most splits?","a0f51207":"# 0. What decision trees are\n* a subset of machine learning approaches (one other approach, for example, is neural networks);\n* a superset and the foundation of different algorithms e.g. random forests and gradient boosting;\n* among the easiest to understand;\n* among the most readily interpretable;\n* as white as boxes can be (as opposed to black boxes).\n\n# What decision trees aren't\n* child's play;\n* for beginners only.\n\nIn fact implementations such as *LightGBM* and *XGBoost* frequently score top in Kaggle competitions! \n\nIn this notebook we shall gently walkthrough leaf by leaf, tree by tree. I use LightGBM here; the same principle applies to decision trees in general.","de576672":"# 6. Jump to our last tree","261b9f73":"# 1. Initiation rite\nInvocations we can't go on without.","a59c0228":"7.8 Does the number of ovals agree with the number of leaves on this tree?","ce8c609b":"### 5.2 The top leaf\n* Where does -0.880 come from?\n* Where do 22.667 weight, count: 51, 34.00% of data come from?","9d28117d":"### 7.6 Let's plot the tree with the highest number of splits","28e2eedd":"### 5.3 The bottom leaf\n* Where does -1.211 come from?\n* Where edo 44.000 weight, count: 99, 66.00% of data come from?","493a4f60":"### 6.4 The 2nd leaf (leaf_index=1, count=72)","d0763f95":"### 7.3 Verify that total number of ovals = number of leaves","808d4e5e":"# 3. Put trees in Pandas DataFrame\nSkip the next cell unless you are particularly interested! The original notebook where I wrote these[](http:\/\/) functions is available from https:\/\/www.kaggle.com\/marychin\/lightgbm-trees-to-pandas-dataframe.","05dcfb35":"* Do leaf counts add up to the count in the parent node?","8e5bbd61":"### 6.3 The 1st leaf (leaf_index=0, count=36)","6ff2a044":"### 5.1 Inside the box\n* Where does PetalLengthCm come from?\n* Where does 3.150 come from?\n* Where do 72.794 gain, 0.000 value, 0.000 weight, count: 150, 100% of data come from?"}}