{"cell_type":{"c089bdd1":"code","8e9ee394":"code","44c9f380":"code","a078ab80":"code","3cf5830a":"code","875258c3":"code","a5d96b21":"code","4e1eff75":"code","a61dfe43":"code","127ceadb":"markdown","f471260a":"markdown","b7bd81ce":"markdown"},"source":{"c089bdd1":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\nimport os\nimport matplotlib.pyplot as plt\nfrom collections import defaultdict\n\nfrom skimage import color\nfrom skimage import io\nfrom skimage.feature import peak_local_max\nfrom skimage.segmentation import watershed\nfrom scipy import ndimage\n\nimport cv2\nimport matplotlib.patches as patches","8e9ee394":"malaria = []\nno_malaria = []\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        if \"\/malaria\/\" in os.path.join(dirname, filename):\n            malaria.append(os.path.join(dirname, filename))\n        elif \"\/no_malaria\/\" in os.path.join(dirname, filename):\n            no_malaria.append(os.path.join(dirname, filename))","44c9f380":"# implement an algorithm mimicking recent paper https:\/\/arxiv.org\/abs\/2102.08708\n\ndef hist_equalization(input_file):\n    img = cv2.imread(input_file, 0)\n\n    hist,bins = np.histogram(img.flatten(),256,[0,256])\n\n    cdf = hist.cumsum()\n    cdf_normalized = cdf * hist.max()\/ cdf.max()\n    cdf_m = np.ma.masked_equal(cdf,0)\n    cdf_m = (cdf_m - cdf_m.min())*255\/(cdf_m.max()-cdf_m.min())\n    cdf = np.ma.filled(cdf_m,0).astype('uint8')\n    return cdf[img]\n\ndef otsu_thresholding(image):\n    otsu_val,thresh = cv2.threshold(image,0,255,cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)\n    return otsu_val,thresh\n\ndef do_watershed(threshold_image):\n    D = ndimage.distance_transform_edt(threshold_image)\n    localMax = peak_local_max(D, indices=False, min_distance=15, labels=threshold_image)\n    # perform a connected component analysis on the local peaks,\n    # using 8-connectivity, then appy the Watershed algorithm\n    markers = ndimage.label(localMax, structure=np.ones((3, 3)))[0]\n    labels = watershed(-D, markers, mask=threshold_image)\n    return labels, markers\n\ndef annotate_and_plot(image_file, watershed_img):\n    fig, ax = plt.subplots()\n    variances = []\n    means = []\n    for label in set(watershed_img.flatten()):\n        # gets indices \n        x_indices = np.where(np.any(watershed_img==label, axis=0))[0]\n        y_indices =  np.where(np.any(watershed_img==label, axis=1))[0]\n        # Display the image\n        # Create a Rectangle patc\n#         print(min(x_indices), max(x_indices), min(y_indices), max(y_indices))\n#         print(watershed_img[min(x_indices):max(x_indices), min(y_indices):max(y_indices)].shape)\n#         x_var = np.var(watershed_img[min(x_indices):max(x_indices)].flaten())\n#         y_var = np.var(watershed_img[min(y_indices):max(y_indices)].flaten())\n#         x_mean = np.mean(watershed_img[min(x_indices):max(x_indices)].flaten())\n#         y_mean = np.mean(watershed_img[min(y_indices):max(y_indices)].flaten())\n#         print(x_var, y_var, x_mean, y_mean)\n        if (max(x_indices)-min(x_indices))<20 or (max(y_indices)-min(y_indices))<20:\n            continue\n        cropped = watershed_img[min(x_indices):max(x_indices), min(y_indices):max(y_indices)]\n        var = np.var(cropped.flatten())\n        mean = np.mean(cropped.flatten())\n        variances.append(var)\n        means.append(mean)\n        rect = patches.Rectangle((min(x_indices), min(y_indices)), max(x_indices)-min(x_indices),  \n                                 max(y_indices)-min(y_indices), \n                                 linewidth=1, edgecolor='r', facecolor='none')\n        ax.add_patch(rect)\n    image = cv2.imread(image_file)\n    return ax, image, variances, means\n\ndef run_segmentation(image_file):\n    gray = hist_equalization(image_file)\n    _, thresh = otsu_thresholding(gray)\n    water, markers = do_watershed(thresh)\n    ax, im, vs, ms = annotate_and_plot(image_file, water)\n    return ax, im, vs, ms","a078ab80":"image = cv2.imread(no_malaria[50])\nplt.imshow(image)\nplt.title(\"RGB input\")\nplt.show()\ngray = hist_equalization(no_malaria[50])\nplt.imshow(gray)\nplt.title(\"Increase contrast with histogram equalization\")\nplt.show()\n_, thresh = otsu_thresholding(gray)\nwater, markers = do_watershed(thresh)\nplt.imshow(thresh)\nplt.title(\"Threshold with otsu\")\nplt.show()\nplt.imshow(water)\nplt.title(\"Apply watershed algorithm, nlabels={}\".format(len(set(water.flatten()))))\nplt.show()\n\n","3cf5830a":"malaria_maxvars = []\nmalaria_maxmeans = []\n\nfor mal_image_file in malaria:\n    patched_ax, image, var, mean = run_segmentation(mal_image_file)\n    patched_ax.imshow(image)\n    print(max(mean))\n    print(max(var))\n    malaria_maxvars.append(max(var))\n    malaria_maxmeans.append(max(mean))\n    plt.show()","875258c3":"nomalaria_maxvars = []\nnomalaria_maxmeans = []\n\n\nfor no_mal_image_file in no_malaria:\n    patched_ax, image, var, mean = run_segmentation(no_mal_image_file)\n    patched_ax.imshow(image)\n    print(max(mean))\n    print(max(var))\n    nomalaria_maxvars.append(max(var))\n    nomalaria_maxmeans.append(max(mean))\n    plt.show()","a5d96b21":"import seaborn as sns","4e1eff75":"sns.kdeplot(nomalaria_maxmeans)\nsns.kdeplot(malaria_maxmeans)\n","a61dfe43":"sns.kdeplot(nomalaria_maxvars)\nsns.kdeplot(malaria_maxvars)\n","127ceadb":"### Malaria took approximately [400,000](https:\/\/www.who.int\/news-room\/fact-sheets\/detail\/malaria) lives in 2019, with most of these deaths occuring in children ages 5 and below. \n\n\n### Identifying cases through microscopy early is a priority, preventing transmission, severe illness and death. Machine learning-based methods could help as a tool to aid medical professionals in underdeveloped or resource-deficient areas.","f471260a":"Example of the output of each step is shown below.","b7bd81ce":"The first algorithm we use is histogram equalization, which is a contrast preprocessing step intended to allow for the use of a threshold to label the image. First we need to convert our rbg image to grayscale, then we get a histogram describing the number of occurences of a given pixel value. To improve contrast, we would rather these pixels were as spread out as possible while respecting the fidelity of the picture. This is done by distributing the pixels while enforcing a linear cumulative distribution function.\n\nThe output of this algorithm is then passed to a thresholding algorithm using Otsu's method to find the optimum threhsold to use to split the image by calculating the split which returns the optimum intra-class variance. This splits the image into two regions.\n\nFinally, we use the [watershed](https:\/\/en.wikipedia.org\/wiki\/Watershed_(image_processing)) method to segment the thresholded image into different sections which are then passed to the segmentation labeller in `annotate_segments`."}}