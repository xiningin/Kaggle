{"cell_type":{"95d4153e":"code","fcb2e457":"code","245f5aec":"code","c65720ee":"code","8c44c35e":"code","6b852420":"code","b4ff2001":"code","fbef7dcd":"code","dff5551f":"code","f2715945":"code","1e4088c7":"markdown","a488df55":"markdown","4634185f":"markdown","d1cda4e4":"markdown","648921e8":"markdown","37b3080b":"markdown","ae8fa52b":"markdown","93c7a220":"markdown"},"source":{"95d4153e":"import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport tifffile as tiff","fcb2e457":"def rle2mask(rle, mask_shape):\n    ''' takes a space-delimited RLE string in column-first order\n    and turns it into a 2d boolean numpy array of shape mask_shape '''\n    \n    mask = np.zeros(np.prod(mask_shape), dtype=bool) # 1d mask array\n    rle = np.array(rle.split()).astype(int) # rle values to ints\n    starts = rle[::2]\n    lengths = rle[1::2]\n    for s, l in zip(starts, lengths):\n        mask[s:s+l] = True\n    return mask.reshape(np.flip(mask_shape)).T # flip because of column-first order\n\n\ndef mask2rle(mask):\n    ''' takes a 2d boolean numpy array and turns it into a space-delimited RLE string '''\n    \n    mask = mask.T.reshape(-1) # make 1D, column-first\n    mask = np.pad(mask, 1) # make sure that the 1d mask starts and ends with a 0\n    starts = np.nonzero((~mask[:-1]) & mask[1:])[0] # start points\n    ends = np.nonzero(mask[:-1] & (~mask[1:]))[0] # end points\n    rle = np.empty(2 * starts.size, dtype=int) # interlacing...\n    rle[0::2] = starts # ...starts...\n    rle[1::2] = ends - starts # ...and lengths\n    rle = ' '.join([ str(elem) for elem in rle ]) # turn into space-separated string\n    return rle","245f5aec":"df_enc = pd.read_csv('..\/input\/hubmap-kidney-segmentation\/train.csv')\ndf_enc","c65720ee":"enc_original = df_enc.iloc[3,1]\nenc_original[:1000]","8c44c35e":"tiff_shape = tiff.TiffFile('..\/input\/hubmap-kidney-segmentation\/train\/0486052bb.tiff').pages[0].shape[:2]\ntiff_shape","6b852420":"%%time\nmask = rle2mask(enc_original, tiff_shape)","b4ff2001":"plt.imshow(mask[::50,::50]);","fbef7dcd":"%%time\nenc_reencoded = mask2rle(mask)","dff5551f":"enc_reencoded[:1000]","f2715945":"enc_original == enc_reencoded","1e4088c7":"OK, do we really need another set of RLE decoding and encoding routines? I think so, because I spent way too much time fiddling with existing ones, so I wrote another one from scratch.\n\nThese routines are\n* memory-efficient\n* fast\n* definitely correct on a pixel basis for the specific format used in this competition.\n\nSome other routines I've found were off 1 pixel (not that it matters, but aren't we all a bit nitpicky in this line of work ;)) or had other limitations.","a488df55":"And the final check:","4634185f":"Fast decoding:","d1cda4e4":"Fast encoding, no RAM was harmed in the process...","648921e8":"Here we go. Enjoy!","37b3080b":"Let's check with the original train RLEs:","ae8fa52b":"Mask looks ok *and is in the correct numpy orientation*:","93c7a220":"We'll take image 0486052bb:"}}