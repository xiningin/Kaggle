{"cell_type":{"4b8476f0":"code","9941df4e":"code","b9ad447f":"code","9a5d814f":"code","57b4cf96":"code","d5842474":"code","cde5ada2":"code","b8a81702":"code","3e87dce5":"code","6d92b7a2":"code","add8e279":"code","f17afbf6":"code","7078198f":"code","bb104b18":"code","c5aaa287":"code","2be05c46":"code","a56922f7":"code","4b7bec51":"code","bf1a73c9":"code","fa70e3e8":"markdown","3a8e6aba":"markdown","ea743a50":"markdown","a48085af":"markdown","d6fc69bb":"markdown","8971a157":"markdown"},"source":{"4b8476f0":"import numpy as np\nimport pandas as pd\nimport os","9941df4e":"app_dat = pd.read_csv('\/kaggle\/input\/google-play-store-apps\/googleplaystore.csv')\napp_dat.head()\n## Notice how the installs column does not have an integer value","b9ad447f":"##Probably should have seen this mistake coming, gave me a good laugh\n##essentially this just adds all the strings from \"Installs\" into one large superstring for each catagory\n\nagg_df = app_dat.groupby(['Category'])['Installs'].sum()\ndisplay(agg_df)\n","9a5d814f":"#now to see exactly what string values are in the 'Installs' catagory\napp_dat.Installs.unique()","57b4cf96":"app_dat.info()","d5842474":"app_dat.isnull().sum()","cde5ada2":"over_list = ['1,000,000,000+', '500,000,000+', '100,000,000+', '50,000,000+', '10,000,000+', '5,000,000+', '1,000,000+', '500,000+', '100,000+', '50,000+', '10,000+', '5,000+', '1,000+', '500+', '100+', '50+', '10+', '5+', '1+', '0+', '0']\n#this list orders the bins for easier graphing             ","b8a81702":"import matplotlib as plt\nimport seaborn as sns\nimport matplotlib.pyplot","3e87dce5":"matplotlib.pyplot.figure(figsize=(22,6))\nsns.countplot(app_dat.Installs, order=over_list, orient='v')","6d92b7a2":"#'Free' is a rather wacky value to have here, let's look closer\nfree = app_dat['Installs'] == 'Free'\ndisplay(app_dat[free])\nwack = app_dat['Category'] == '1.9'\ndisplay(app_dat[wack])\n\n##turns out this value is also unique in catagories as well. clearly this data is not intact\n##this is an anomoly in the dataset and should be ignored\n##by shifting all entries one column this entry makes sence but we wouldn't have an accurate catagory for it","add8e279":"## removing entry\napp_dat.drop(app_dat[wack].index, axis=0, inplace=True)","f17afbf6":"## I could have used a dictionary and mapping function, which would have been more concise\n## This perticular layout just helped me to see the gaps between values better\ndef installs_min(stng):\n    if stng == '1,000,000,000+':\n        return 1000000001\n    if stng == '500,000,000+':\n        return 500000001\n    if stng == '100,000,000+':\n        return 100000001\n    if stng == '50,000,000+':\n        return 50000001\n    if stng == '10,000,000+':\n        return 10000001\n    if stng == '5,000,000+':\n        return 5000001\n    if stng == '1,000,000+':\n        return 1000001\n    if stng == '500,000+':\n        return 500001\n    if stng == '100,000+':\n        return 100001\n    if stng == '50,000+':\n        return 50001\n    if stng == '10,000+':\n        return 10001\n    if stng == '5,000+':\n        return 5001\n    if stng == '1,000+':\n        return 1001\n    if stng == '500+':\n        return 501\n    if stng == '100+':\n        return 101\n    if stng == '50+':\n        return 51\n    if stng == '10+':\n        return 11\n    if stng == '5+':\n        return 6\n    if stng == '1+':\n        return 2\n    if stng == '0+':\n        return 1\n    if stng == '0':\n        return 0\n    if stng == 'Free': ##this entry should be deleted in the final version but lets not take chances\n        return 0\n    \ndef installs_mid(stng):\n    if stng == '1,000,000,000+': ##I assume 5 billion would come next, yes this is getting silly\n        return 2500000000\n    if stng == '500,000,000+':\n        return 750000000\n    if stng == '100,000,000+':\n        return 250000000\n    if stng == '50,000,000+':\n        return 75000000\n    if stng == '10,000,000+':\n        return 25000000\n    if stng == '5,000,000+':\n        return 7500000\n    if stng == '1,000,000+':\n        return 2500000\n    if stng == '500,000+':\n        return 750000\n    if stng == '100,000+':\n        return 250000\n    if stng == '50,000+':\n        return 75000\n    if stng == '10,000+':\n        return 25000\n    if stng == '5,000+':\n        return 7500\n    if stng == '1,000+':\n        return 2500\n    if stng == '500+':\n        return 750\n    if stng == '100+':\n        return 250\n    if stng == '50+':\n        return 75\n    if stng == '10+':\n        return 25\n    if stng == '5+':\n        return 8\n    if stng == '1+':\n        return 3\n    if stng == '0+':\n        return 1\n    if stng == '0':\n        return 0\n    if stng == 'Free':\n        return \n    \ndef installs_max(stng):#shows max value\n    if stng == '1,000,000,000+':\n        return 5000000000\n    if stng == '500,000,000+':\n        return 1000000000\n    if stng == '100,000,000+':\n        return 500000000\n    if stng == '50,000,000+':\n        return 100000000\n    if stng == '10,000,000+':\n        return 50000000\n    if stng == '5,000,000+':\n        return 10000000\n    if stng == '1,000,000+':\n        return 5000000\n    if stng == '500,000+':\n        return 1000000\n    if stng == '100,000+':\n        return 500000\n    if stng == '50,000+':\n        return 100000\n    if stng == '10,000+':\n        return 50000\n    if stng == '5,000+':\n        return 10000\n    if stng == '1,000+':\n        return 5000\n    if stng == '500+':\n        return 1000\n    if stng == '100+':\n        return 500\n    if stng == '50+':\n        return 100\n    if stng == '10+':\n        return 50\n    if stng == '5+':\n        return 10\n    if stng == '1+':\n        return 5\n    if stng == '0+':\n        return 1\n    if stng == '0':\n        return 0\n    if stng == 'Free': ##this entry should be deleted in the final version but lets not take chances\n        return 0","7078198f":"app_dat['min_installs'] = pd.Series([installs_min(x) for x in app_dat.Installs], index=app_dat.index)\napp_dat['mid_installs'] = pd.Series([installs_mid(x) for x in app_dat.Installs], index=app_dat.index)\napp_dat['max_installs'] = pd.Series([installs_max(x) for x in app_dat.Installs], index=app_dat.index)\napp_dat.head(3)","bb104b18":"#Now to aggrigate and sort the data\nfull_app = app_dat.groupby(['Category'])['max_installs', 'mid_installs', 'min_installs'].sum()\nfull_app = full_app.sort_values(by=['min_installs'],ascending=False)\nfull_app","c5aaa287":"#mako\nmatplotlib.pyplot.figure(figsize=(10,10))\nsns.barplot(x=full_app['min_installs'], y=full_app.index, palette='mako')\n\n#Additional ideas: bin bottum 5% of apps","2be05c46":"#full_app = full_app.sort_values(by=['mid_installs'],ascending=False)\nmatplotlib.pyplot.figure(figsize=(10,10))\n#with sns.palplot(sns.color_palette(\"BuGn_r\")):\nsns.barplot(x=full_app['mid_installs'], y=full_app.index, palette='BuGn_r')\n#sns.palplot(sns.color_palette(\"BuGn_r\"))","a56922f7":"matplotlib.pyplot.figure(figsize=(10,10))\nsns.barplot(x=full_app['max_installs'], y=full_app.index, palette='Blues_r')\n#when we replace each value with the max for its bin we start seeing communication overtake games as the installed catagory","4b7bec51":"short_app = full_app.head(10) ##shorter list of the top entries\n##one other alternative that I did not try was to group all the entries that have fewer than 5% of the installs","bf1a73c9":"import matplotlib.pyplot as plt\nf, ax = plt.subplots(figsize=(10, 8))\n\nsns.set_color_codes(\"pastel\")\nsns.barplot(x=short_app['max_installs'], y=short_app.index,\n            label=\"Maximum possible value\", color=\"b\")\n\nsns.set_color_codes(\"muted\")\nsns.barplot(x=short_app['mid_installs'], y=short_app.index,\n            label=\"Median value\", color=\"b\")\n\nsns.set_color_codes(\"dark\")\nsns.barplot(x=short_app['min_installs'], y=short_app.index,\n            label=\"Minimum possible value\", color=\"b\")\n\nax.legend(ncol=3, loc=\"lower right\", frameon=True)\nax.set( ylabel=\"Catagory\",\n       xlabel=\"Number of Installs\")\nsns.despine(left=True, bottom=True)","fa70e3e8":"# Further thoughts:\n\n* I could have removed some of the uncertainty by viewing the distrobution of the # of ratings within each bin.\n* I was also curious, but ran out of time, about what the average number of installs for each catagory might be (I'm trying to do a task a week so thats were the self imposed dealine comes from).\n* Finally, this time I decided to show the final graphic in the first cell and then show my work below. Was this a more optimal layout for a response to a task?\n\nAs always I'd love to hear your thoughts, ideas, and constructive criticism in the comments below. And if you liked what you see here feel free to upvote the notebook and check out my profile for links to my other notebooks.","3a8e6aba":"So looking above we can see that the most popular catagory is games, with communication being a close second (when viewing the middle values the difference is less than 5% and it only shifts to communication when all values are set to max). There is still some room for debate, but I'm reasonably confident in my result.","ea743a50":"The numbers used for this graphic are aproximations based on availible data. The dataset isn't precice when it comes to number of downloads so I got a bit creative to reach my solution. I'd love to hear your opinions on my solution down bellow. Did you agree with my aproximation or do you have a better idea?\n\n![image.png](attachment:image.png)","a48085af":"At this point I'll want to experiment with three different options for replacing the current values for 'Installs' and see how it affects the projection for most downloaded catagory:\n\n* First option: set each value to the minimum possible\n\n* Second option: set each value to the mid point between its minimum and maximum values.\n\n* Third option: set each value to the maximum possible for the bin.\n\nI've hidden the code cell bellow for the functions I'll use to populate the three test columns. The code is nothing impressive and has alot of lines.","d6fc69bb":"The code for the below graphic was highly influenced by the tutorial on the website for the seaborn library:\nhttps:\/\/seaborn.pydata.org\/examples\/horizontal_barplot.html","8971a157":"This notebook is for the Most popular category task from the google play store apps. \n\"What is the most popular category that has the largest number of installs.\"\n\nMy thanks to:\n* Lavanya Gupta for the dataset: https:\/\/www.kaggle.com\/lava18\/google-play-store-apps\n* Tinotenda Mhlanga for creating the task: https:\/\/www.kaggle.com\/lava18\/google-play-store-apps\/tasks?taskId=276\n\nas one side note: I'm trying to do one Kaggle task a week (this would be my second week) if there is anything i could do to improve the format I'd appriciate any constructive feedback. You can message me directly or comment on the notebook itself."}}