{"cell_type":{"1462cc46":"code","315b2728":"code","3c923b34":"code","3158a0c4":"code","8bdefb43":"code","cd463768":"code","645a0cce":"code","062ae97c":"code","804ac7dc":"code","ef5a31e8":"code","c874addf":"code","5ab44e81":"code","50a94e7b":"code","5c937067":"code","bf53c6cd":"code","77a79d1c":"code","a53f80c1":"markdown","d7a0c130":"markdown","b2250244":"markdown","76c44537":"markdown","ef786038":"markdown","3e973739":"markdown","99741631":"markdown","77548262":"markdown"},"source":{"1462cc46":"!mkdir efficientnet\n!cp -r ..\/input\/segmentation-masters\/efficientnet-master\/efficientnet-master\/efficientnet\/* .\/efficientnet","315b2728":"!mkdir classification_models\n!cp -r ..\/input\/segmentation-masters\/classification_models-master\/classification_models-master\/classification_models\/* .\/classification_models","3c923b34":"!mkdir segmentation_models\n!cp -r ..\/input\/segmentation-masters\/segmentation_models-master\/segmentation_models-master\/segmentation_models\/* .\/segmentation_models","3158a0c4":"!ls .\/efficientnet","8bdefb43":"! python ..\/input\/mlcomp\/mlcomp\/mlcomp\/setup.py","cd463768":"import warnings\nwarnings.filterwarnings('ignore')\nimport os\nimport gc\nimport matplotlib.pyplot as plt\n\nimport numpy as np\nimport cv2\nimport albumentations as A\nfrom tqdm import tqdm_notebook\nimport pandas as pd\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\nfrom torch.jit import load\n\nfrom mlcomp.contrib.transform.albumentations import ChannelTranspose\nfrom mlcomp.contrib.dataset.classify import ImageDataset\nfrom mlcomp.contrib.transform.rle import rle2mask, mask2rle\nfrom mlcomp.contrib.transform.tta import TtaWrap","645a0cce":"unet_se_resnext50_32x4d = load('\/kaggle\/input\/severstalmodels\/unet_se_resnext50_32x4d.pth').cuda()\nunet_mobilenet2 = load('\/kaggle\/input\/severstalmodels\/unet_mobilenet2.pth').cuda()\nunet_resnet34 = load('\/kaggle\/input\/severstalmodels\/unet_resnet34.pth').cuda()","062ae97c":"class Model:\n    def __init__(self, models):\n        self.models = models\n    \n    def __call__(self, x):\n        res = []\n        x = x.cuda()\n        with torch.no_grad():\n            for m in self.models:\n                res.append(m(x))\n        res = torch.stack(res)\n        return torch.mean(res, dim=0)\n\nmodel = Model([unet_se_resnext50_32x4d, unet_mobilenet2, unet_resnet34])","804ac7dc":"def create_transforms(additional):\n    res = list(additional)\n    # add necessary transformations\n    res.extend([\n        A.Normalize(\n            mean=(0.485, 0.456, 0.406), std=(0.230, 0.225, 0.223)\n        ),\n        ChannelTranspose()\n    ])\n    res = A.Compose(res)\n    return res\n\nimg_folder = '\/kaggle\/input\/severstal-steel-defect-detection\/test_images'\nbatch_size = 2\nnum_workers = 0\n\n# Different transforms for TTA wrapper\ntransforms = [\n    [],\n    [A.HorizontalFlip(p=1)]\n]\n\ntransforms = [create_transforms(t) for t in transforms]\ndatasets = [TtaWrap(ImageDataset(img_folder=img_folder, transforms=t), tfms=t) for t in transforms]\nloaders = [DataLoader(d, num_workers=num_workers, batch_size=batch_size, shuffle=False) for d in datasets]","ef5a31e8":"thresholds = [0.5, 0.7, 0.5, 0.5]\nmin_area = [600, 600, 1000, 2000]\n\nres = []\n# Iterate over all TTA loaders\ntotal = len(datasets[0])\/\/batch_size\nfor loaders_batch in tqdm_notebook(zip(*loaders), total=total):\n    preds = []\n    image_file = []\n    for i, batch in enumerate(loaders_batch):\n        features = batch['features'].cuda()\n        p = torch.sigmoid(model(features))\n        # inverse operations for TTA\n        p = datasets[i].inverse(p)\n        preds.append(p)\n        image_file = batch['image_file']\n    \n    # TTA mean\n    preds = torch.stack(preds)\n    preds = torch.mean(preds, dim=0)\n    preds = preds.detach().cpu().numpy()\n    \n    # Batch post processing\n    for p, file in zip(preds, image_file):\n        file = os.path.basename(file)\n        # Image postprocessing\n        for i in range(4):\n            p_channel = p[i]\n            imageid_classid = file+'_'+str(i+1)\n            p_channel = (p_channel>thresholds[i]).astype(np.uint8)\n            if p_channel.sum() < min_area[i]:\n                p_channel = np.zeros(p_channel.shape, dtype=p_channel.dtype)\n\n            res.append({\n                'ImageId_ClassId': imageid_classid,\n                'EncodedPixels': mask2rle(p_channel)\n            })\n            \ndf = pd.DataFrame(res)\ndf = df.fillna('')   ","c874addf":"import matplotlib.pyplot as plt\nimport random\nimport math as math\nimport os\nimport numpy as np\nimport pandas as pd\nimport cv2\nfrom PIL import Image\nimport os\nimport tensorflow as tf\nimport keras.backend as K\nfrom keras.utils import Sequence\nfrom keras.applications import Xception\nfrom keras.layers import UpSampling2D, Conv2D, Activation, LeakyReLU, BatchNormalization\nfrom keras import Model\nfrom keras.losses import binary_crossentropy\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint\nfrom keras.optimizers import Adam\n\nimport imgaug as ia\nimport imgaug.augmenters as iaa\nimport segmentation_models as sm\n\nimport efficientnet.keras as efn \nfrom keras.optimizers import Adam\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Activation, Flatten","5ab44e81":"base = efn.EfficientNetB3(weights=None, include_top=False, input_shape=(256, 1600, 3), pooling='avg')\nbase.trainable=True\ndropout_dense_layer = 0.2 # for B0\n\nclassifier_model = Sequential()\nclassifier_model.add(base)\nclassifier_model.add(Dropout(dropout_dense_layer))\nclassifier_model.add(Dense(4, activation='sigmoid'))\n\nclassifier_model.compile(\n    loss='binary_crossentropy',\n    optimizer='adam',\n    metrics=['accuracy']\n)\n\nclassifier_model.load_weights('..\/input\/single-models\/B3_opt_multi_new3.h5')\n\nIMAGE_RGB_MEAN = [0.485, 0.456, 0.406]\nIMAGE_RGB_STD  = [0.229, 0.224, 0.225]\n\ndef normalize(images):\n    images = images \/ 255.0\n    images[:,:,:,0] = (images[:,:,:,0]-IMAGE_RGB_MEAN[0])\/IMAGE_RGB_STD[0]\n    images[:,:,:,1] = (images[:,:,:,1]-IMAGE_RGB_MEAN[1])\/IMAGE_RGB_STD[1]\n    images[:,:,:,2] = (images[:,:,:,2]-IMAGE_RGB_MEAN[2])\/IMAGE_RGB_STD[2]\n    return images\n    \ndef denormalize(images):\n    images[:,:,:,0] = images[:,:,:,0]*IMAGE_RGB_STD[0]+IMAGE_RGB_MEAN[0]\n    images[:,:,:,1] = images[:,:,:,1]*IMAGE_RGB_STD[1]+IMAGE_RGB_MEAN[1]\n    images[:,:,:,2] = images[:,:,:,2]*IMAGE_RGB_STD[2]+IMAGE_RGB_MEAN[2]\n    images = np.array(images * 255).astype('uint8')\n    \nTEST_PATH = '..\/input\/severstal-steel-defect-detection\/test_images\/'\ndef prepareData(source, path, cleanup=True):\n    source['defect'] = False\n    if cleanup: source.EncodedPixels = ''\n    \n    source['ClassId'] = source['ImageId_ClassId'].str[-1:]\n    source['ImageId'] = source['ImageId_ClassId'].str[:-2]\n    source = source[['ImageId_ClassId', 'ImageId','ClassId','defect','EncodedPixels']]\n    source.ClassId = source.ClassId.astype('int')\n    source['path'] = path + source['ImageId']\n    return source","50a94e7b":"test_df = pd.read_csv('..\/input\/severstal-steel-defect-detection\/sample_submission.csv')\ntest_df = prepareData(test_df, TEST_PATH)\n\n# Predictions\n\nids = test_df['ImageId'].unique()\ntest_df.EncodedPixels = ''\n\n\nclass_weights = [0.5, 0.5, 0.5, 0.5] \n\nfor picIdx in tqdm_notebook(range(len(ids))):\n    \n    batch = np.zeros((4, 256, 1600, 3))\n    filename = ids[picIdx]  \n    img = cv2.imread(TEST_PATH+filename)    \n\n    batch[0, :, :, :] = img\n    batch[1, :, :, :] = img[:,::-1,:]\n    batch[2, :, :, :] = img[::-1,:,:]\n    batch[3, :, :, :] = img[::-1,::-1,:]\n    \n    batch = normalize(batch)\n    classTTA = classifier_model.predict(batch)\n    hasDefect = np.mean(classTTA, axis=0)>class_weights\n\n    for i, classId in enumerate(hasDefect):\n        if classId == False:\n\n            name = filename+\"_\"+str(i+1)\n            line = test_df[test_df.ImageId_ClassId == name].index[0] \n\n            test_df.loc[line, 'EncodedPixels'] = -1","5c937067":"mark = test_df[test_df.EncodedPixels == -1]\nmark.ClassId.value_counts()\n\nsub = df.copy()","bf53c6cd":"for filename in mark.ImageId_ClassId:\n    sub.loc[sub.ImageId_ClassId == filename, 'EncodedPixels'] = -1\n\nsub = sub.replace(-1, '')\nsub.to_csv('submission.csv', index=False)\nsub.head(20)","77a79d1c":"sub['Image'] = sub['ImageId_ClassId'].map(lambda x: x.split('_')[0])\nsub['Class'] = sub['ImageId_ClassId'].map(lambda x: x.split('_')[1])\nsub['empty'] = sub['EncodedPixels'].map(lambda x: not x)\nsub[sub['empty'] == False]['Class'].value_counts()","a53f80c1":"### Import required libraries","d7a0c130":"### Loaders' mean aggregator","b2250244":"### Models' mean aggregator","76c44537":"As the competition does not allow commit with the kernel that uses internet connection, we use offline installation","ef786038":"Save predictions","3e973739":"### Create TTA transforms, datasets, loaders","99741631":"Histogram of predictions","77548262":"Catalyst allows to trace models. That is an extremely useful features in Pytorch since 1.0 version: \n\nhttps:\/\/pytorch.org\/docs\/stable\/jit.html\n\nNow we can load models without re-defining them"}}