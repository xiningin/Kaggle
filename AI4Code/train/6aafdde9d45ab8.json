{"cell_type":{"05174742":"code","92545f3c":"code","dcc56e2d":"code","df2c4a03":"code","9fe13632":"code","5345a028":"code","e46dc75f":"code","fdeb2587":"code","9a78a6d9":"code","37a91a7d":"code","69bf5767":"markdown","f43c6388":"markdown","bea6759c":"markdown","ea4d759b":"markdown","dec91df5":"markdown","feac2b15":"markdown","5ee3736c":"markdown","55f1af11":"markdown","b34f05df":"markdown","b382c69f":"markdown"},"source":{"05174742":"import sys, os, csv\nimport pandas as pd\nimport numpy as np\ntry:\n    import navpy\nexcept ImportError as e:\n    !pip install navpy\n    import navpy\n\nfrom ephemeris_manager import EphemerisManager","92545f3c":"\ninput_filepath = '..\/input\/android-smartphones-high-accuracy-datasets\/training\/2020-07-17-US-MTV-1\/Mi8_GnssLog.txt'\nwith open(input_filepath) as csvfile:\n    reader = csv.reader(csvfile)\n    for row in reader:\n        if row[0][0] == '#':\n            if 'Fix' in row[0]:\n                android_fixes = [row[1:]]\n            elif 'Raw' in row[0]:\n                measurements = [row[1:]]\n        else:\n            if row[0] == 'Fix':\n                android_fixes.append(row[1:])\n            elif row[0] == 'Raw':\n                measurements.append(row[1:])\n\nandroid_fixes = pd.DataFrame(android_fixes[1:], columns = android_fixes[0])\nmeasurements = pd.DataFrame(measurements[1:], columns = measurements[0])\n\n# Format satellite IDs\nmeasurements.loc[measurements['Svid'].str.len() == 1, 'Svid'] = '0' + measurements['Svid']\nmeasurements.loc[measurements['ConstellationType'] == '1', 'Constellation'] = 'G'\nmeasurements.loc[measurements['ConstellationType'] == '3', 'Constellation'] = 'R'\nmeasurements['SvName'] = measurements['Constellation'] + measurements['Svid']\n\n# Remove all non-GPS measurements\nmeasurements = measurements.loc[measurements['Constellation'] == 'G']\n\n# Convert columns to numeric representation\nmeasurements['Cn0DbHz'] = pd.to_numeric(measurements['Cn0DbHz'])\nmeasurements['TimeNanos'] = pd.to_numeric(measurements['TimeNanos'])\nmeasurements['FullBiasNanos'] = pd.to_numeric(measurements['FullBiasNanos'])\nmeasurements['ReceivedSvTimeNanos']  = pd.to_numeric(measurements['ReceivedSvTimeNanos'])\nmeasurements['PseudorangeRateMetersPerSecond'] = pd.to_numeric(measurements['PseudorangeRateMetersPerSecond'])\nmeasurements['ReceivedSvTimeUncertaintyNanos'] = pd.to_numeric(measurements['ReceivedSvTimeUncertaintyNanos'])\nif 'BiasNanos' in measurements.columns:\n    measurements['BiasNanos'] = pd.to_numeric(measurements['BiasNanos'])\nelse:\n    measurements['BiasNanos'] = 0\nif 'TimeOffsetNanos' in measurements.columns:\n    measurements['TimeOffsetNanos'] = pd.to_numeric(measurements['TimeOffsetNanos'])\nelse:\n    measurements['TimeOffsetNanos'] = 0\n\nprint(measurements.columns)","dcc56e2d":"from datetime import datetime, timezone, timedelta\n\nmeasurements['GpsTimeNanos'] = measurements['TimeNanos'] - (measurements['FullBiasNanos'] - measurements['BiasNanos'])\ngpsepoch = datetime(1980, 1, 6, 0, 0, 0)\nmeasurements['UnixTime'] = pd.to_datetime(measurements['GpsTimeNanos'], utc = True, origin=gpsepoch)\nmeasurements['UnixTime'] = measurements['UnixTime']\n\n# Split data into measurement epochs\nmeasurements['Epoch'] = 0\nmeasurements.loc[measurements['UnixTime'] - measurements['UnixTime'].shift() > timedelta(milliseconds=200), 'Epoch'] = 1\nmeasurements['Epoch'] = measurements['Epoch'].cumsum()","df2c4a03":"WEEKSEC = 604800\nLIGHTSPEED = 2.99792458e8\n\n# This should account for rollovers since it uses a week number specific to each measurement\n\nmeasurements['tRxGnssNanos'] = measurements['TimeNanos'] + measurements['TimeOffsetNanos'] - (measurements['FullBiasNanos'].iloc[0] + measurements['BiasNanos'].iloc[0])\nmeasurements['GpsWeekNumber'] = np.floor(1e-9 * measurements['tRxGnssNanos'] \/ WEEKSEC)\nmeasurements['tRxSeconds'] = 1e-9*measurements['tRxGnssNanos'] - WEEKSEC * measurements['GpsWeekNumber']\nmeasurements['tTxSeconds'] = 1e-9*(measurements['ReceivedSvTimeNanos'] + measurements['TimeOffsetNanos'])\nmeasurements['prSeconds'] = measurements['tRxSeconds'] - measurements['tTxSeconds']\nmeasurements['PrM'] = LIGHTSPEED * measurements['prSeconds']\nmeasurements['PrSigmaM'] = LIGHTSPEED * 1e-9 * measurements['ReceivedSvTimeUncertaintyNanos']","9fe13632":"manager = EphemerisManager()\n\nepoch = 1\ntimestamp = measurements.iloc[epoch]['UnixTime'].to_pydatetime(warn=False)\none_epoch = measurements.loc[(measurements['Epoch'] == epoch) & (measurements['prSeconds'] < 0.1)].drop_duplicates(subset='SvName')\none_epoch.set_index('SvName', inplace=True)\n\nsats = one_epoch.index.unique().tolist()\nephemeris = manager.get_ephemeris(timestamp, sats)","5345a028":"def calculate_satellite_position(ephemeris, transmit_time):\n    mu = 3.986005e14\n    OmegaDot_e = 7.2921151467e-5\n    F = -4.442807633e-10\n    sv_position = pd.DataFrame()\n    sv_position['sv']= ephemeris.index\n    sv_position.set_index('sv', inplace=True)\n    sv_position['t_k'] = transmit_time - ephemeris['t_oe']\n    A = ephemeris['sqrtA'].pow(2)\n    n_0 = np.sqrt(mu \/ A.pow(3))\n    n = n_0 + ephemeris['deltaN']\n    M_k = ephemeris['M_0'] + n * sv_position['t_k']\n    E_k = M_k\n    err = pd.Series(data=[1]*len(sv_position.index))\n    i = 0\n    while err.abs().min() > 1e-8 and i < 10:\n        new_vals = M_k + ephemeris['e']*np.sin(E_k)\n        err = new_vals - E_k\n        E_k = new_vals\n        i += 1\n        \n    sinE_k = np.sin(E_k)\n    cosE_k = np.cos(E_k)\n    delT_r = F * ephemeris['e'].pow(ephemeris['sqrtA']) * sinE_k\n    delT_oc = transmit_time - ephemeris['t_oc']\n    sv_position['delT_sv'] = ephemeris['SVclockBias'] + ephemeris['SVclockDrift'] * delT_oc + ephemeris['SVclockDriftRate'] * delT_oc.pow(2)\n\n    v_k = np.arctan2(np.sqrt(1-ephemeris['e'].pow(2))*sinE_k,(cosE_k - ephemeris['e']))\n\n    Phi_k = v_k + ephemeris['omega']\n\n    sin2Phi_k = np.sin(2*Phi_k)\n    cos2Phi_k = np.cos(2*Phi_k)\n\n    du_k = ephemeris['C_us']*sin2Phi_k + ephemeris['C_uc']*cos2Phi_k\n    dr_k = ephemeris['C_rs']*sin2Phi_k + ephemeris['C_rc']*cos2Phi_k\n    di_k = ephemeris['C_is']*sin2Phi_k + ephemeris['C_ic']*cos2Phi_k\n\n    u_k = Phi_k + du_k\n\n    r_k = A*(1 - ephemeris['e']*np.cos(E_k)) + dr_k\n\n    i_k = ephemeris['i_0'] + di_k + ephemeris['IDOT']*sv_position['t_k']\n\n    x_k_prime = r_k*np.cos(u_k)\n    y_k_prime = r_k*np.sin(u_k)\n\n    Omega_k = ephemeris['Omega_0'] + (ephemeris['OmegaDot'] - OmegaDot_e)*sv_position['t_k'] - OmegaDot_e*ephemeris['t_oe']\n\n    sv_position['x_k'] = x_k_prime*np.cos(Omega_k) - y_k_prime*np.cos(i_k)*np.sin(Omega_k)\n    sv_position['y_k'] = x_k_prime*np.sin(Omega_k) + y_k_prime*np.cos(i_k)*np.cos(Omega_k)\n    sv_position['z_k'] = y_k_prime*np.sin(i_k)\n    return sv_position\n\n# Run the function and check out the results:\nsv_position = calculate_satellite_position(ephemeris, one_epoch['tTxSeconds'])\nprint(sv_position)","e46dc75f":"#initial guesses of receiver clock bias and position\nb0 = 0\nx0 = np.array([0, 0, 0])\nxs = sv_position[['x_k', 'y_k', 'z_k']].to_numpy()\n\n# Apply satellite clock bias to correct the measured pseudorange values\npr = one_epoch['PrM'] + LIGHTSPEED * sv_position['delT_sv']\npr = pr.to_numpy()","fdeb2587":"def least_squares(xs, pr, x0, b0):\n    dx = 100*np.ones(3)\n    b = b0\n    # set up the G matrix with the right dimensions. We will later replace the first 3 columns\n    # note that b here is the clock bias in meters equivalent, so the actual clock bias is b\/LIGHTSPEED\n    G = np.ones((pr.size, 4))\n    iterations = 0\n    while np.linalg.norm(dx) > 1e-3:\n        norms = np.linalg.norm(xs - x0, axis=1)\n        dp = pr - norms + b - b0\n        G[:, 0:3] = -(xs - x0)\/norms[:, None]\n        sol = np.linalg.inv(np.transpose(G)@G) @ np.transpose(G) @ dp\n        dx = sol[0:3]\n        db = sol[3]\n        norm_dp = np.linalg.norm(dp)\n        x0 = x0 + dx\n        b0 = b0 + db\n\n    return x0, b0, norm_dp\n\nx, b, dp = least_squares(xs, pr, x0, b0)\nprint(navpy.ecef2lla(x))\nprint(b\/LIGHTSPEED)\nprint(dp)","9a78a6d9":"lla_list = []\nned_list = []\nfor epoch in measurements['Epoch'].unique():\n    one_epoch = measurements.loc[(measurements['Epoch'] == epoch) & (measurements['prSeconds'] < 0.1)] \n    one_epoch = one_epoch.drop_duplicates(subset='SvName').set_index('SvName')\n    if len(one_epoch.index) > 4:\n        timestamp = one_epoch.iloc[0]['UnixTime'].to_pydatetime(warn=False)\n        sats = one_epoch.index.unique().tolist()\n        ephemeris = manager.get_ephemeris(timestamp, sats)\n        sv_position = calculate_satellite_position(ephemeris, one_epoch['tTxSeconds'])\n\n        xs = sv_position[['x_k', 'y_k', 'z_k']].to_numpy()\n        pr = one_epoch['PrM'] + LIGHTSPEED * sv_position['delT_sv']\n        pr = pr.to_numpy()\n\n        x, b, dp = least_squares(xs, pr, x, b)\n        lla = navpy.ecef2lla(x)\n        lla_list.append(lla)\n        ned_list.append(navpy.lla2ned(lla[0], lla[1], lla[2], lla_list[0][0], lla_list[0][1], lla_list[0][2]))","37a91a7d":"import matplotlib.pyplot as plt\nned_df = pd.DataFrame(ned_list, columns=['N', 'E', 'D'])\nplt.plot(ned_df['E'], ned_df['N'])\n\n# Add titles\nplt.title('Simple Least Squares Position Calculation')\nplt.xlabel(\"East (m)\")\nplt.ylabel(\"North (m)\")\nplt.gca().set_aspect('equal', adjustable='box')","69bf5767":"Looks like it worked! The pseudorange residual is in the tens of meters, which is reasonable considering we didn't correct for ionospheric delay or the rotation of the Earth during signal transmission.\n\nNow let's wrap this entire process into a loop to calculate receiver position for every measurement epoch in the dataset with more than 4 satellite measurements.\n\n","f43c6388":"Let's read in a GNSS log file, format the satellite IDs to match up with the RINEX 3.0 standard, and convert the columns we need to calculate receiver position to numeric values. We'll also filter the data so that we're only working with GPS measurements to simplify the rest of the analysis.","bea6759c":"Calculating satellite position from ephemeris data is a bit involved, but the details are conveniently laid out in Tables 20-III and 20-IV of the GPS [Interface Specification Document](https:\/\/www.gps.gov\/technical\/icwg\/IS-GPS-200L.pdf). The function below performs this calculation, taking a Pandas dataframe with the ephemeris parameters for every satellite and a dataseries containing the transmit time for all received signals in seconds since the start of the current GPS week. It also calculates the satellite clock offsets for the given transmission time.","ea4d759b":"Here's the function to calculate rough receiver position. Its inputs are Numpy arrays containing satellite positions in the ECEF frame, pseudorange measurements in meters, and initial estimates of receiver position and clock bias. The unit for clock bias is meters, so you need to divide by the speed of light to convert to seconds.\n\nThis function is adapted and simplified from the MATLAB code in Ankur Mohan's [blog](https:\/\/www.telesens.co\/2017\/07\/17\/calculating-position-from-raw-gps-data\/). It's a simple least squares iteration with no correction for ionospheric delay or satellite movement during signal time of flight.","dec91df5":"Those with experience in GNSS data processing will probably notice that we're missing a few important fields for calculating receiver position.\n\nFirst, we'll calculate the GPS time in nanoseconds using the equations from Section 2.4 of the European Global Navigation Satellite Systems Agency's [white paper](https:\/\/www.gsa.europa.eu\/system\/files\/reports\/gnss_raw_measurement_web_0.pdf). Then we'll convert it to a normal Unix timestamp using the Pandas.to_datetime() function with the GPS reference epoch.\n\n**An aside on timestamps:** note that the UTC flag is set to True in the Pandas.to_datetime() method. The timestamp column needs to be timezone-aware, because we're eventually going to plug it into the Python datetime library and use it to format the ephemeris filepath for download from NASA. The EphemerisManager module compares the timestamp with the current time to determine which files to retrieve. Since the datetime library defaults to local time on some systems, it was necessary to keep everything timezone-aware to avoid mix-ups.\n\nThis nomenclature is a bit confusing since we're using the method to create a column called UnixTime. Unix time and UTC are technically in the same time zone, but UTC includes leap seconds, while Unix time does not. Since we're creating a timestamp from the number of seconds elapsed since the GPS epoch, the resulting timestamp could differ from UTC by some number of leap seconds. That's close enough to ensure we get the correct ephemeris file, and it won't affect the actual position calculations because we don't use the UnixTime column for those.\n\nFinally, let's split the data into measurement epochs. We do this by creating a new column and setting it to 1 whenever the difference between a timestamp and the previous timestamp is greater than 200 milliseconds using the DataFrame.shift() command. Then we use the cumsum method to generate unique numbers for the individual epochs.","feac2b15":"Now that we have pseudorange values, we can begin the standard process for calculating receiver position. First we need to retrieve the ephemeris data for each satellite from one of the International GNSS Service (IGS) analysis centers. These include NASA's [CDDIS](https:\/\/cddis.nasa.gov\/Data_and_Derived_Products\/GNSS\/orbit_products.html) and the German [BKG](https:\/\/igs.bkg.bund.de\/dataandproducts\/index).\n\nThis process is, frankly, a bit of a pain, so I wrote a Python module to handle the details. You can view the code and documentation [here](https:\/\/github.com\/johnsonmitchelld\/gnss-analysis\/tree\/main\/gnssutils).","5ee3736c":"Finally, we'll convert the list of NED translations into a Pandas dataframe and create a plot of change in position relative to the first measurement epoch.","55f1af11":"This notebook was written by [Mitchell Johnson](https:\/\/www.johnsonmitchelld.com\/). The source code, as well as the gnssutils Python package containing the EphemerisManager module, can be found on [Github](https:\/\/github.com\/johnsonmitchelld\/gnss-analysis).\n\nI had to hack arounds some issues using pip to install the dependencies for the EphemerisManager class on Kaggle. As a result, this first cell will take a minute the first time you run it and you may see some info\/warning messages from pip. See the import section of the ephemeris_manager utility script for the details.\n\nAlso, make sure you enable Internet in the settngs panel on the side so the EphemerisManager can retrieve the necessary ephemeris files from NASA.","b34f05df":"Next let's calculate the estimated signal transmission and reception times. From those we'll calculate the pseudorange for each satellite in both seconds and meters.","b382c69f":"We now have raw pseudorange values, satellite positions, and satellite clock offsets. Let's correct the pseudoranges for satellite clock bias and convert the values to Numpy arrays."}}