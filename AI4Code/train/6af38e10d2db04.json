{"cell_type":{"6cb979ef":"code","328ed366":"code","64e9d798":"code","5c344233":"code","cb21c182":"code","4c1364c7":"code","396f6fb1":"code","56165e1e":"code","5f4af7de":"code","1c44de87":"code","74ab3535":"code","9023a3fa":"code","68048ca6":"code","5184b356":"code","bc0cf181":"code","236697ec":"code","da1e9403":"code","1b7df317":"code","db641c5f":"code","61effdb7":"code","d0087760":"code","e2b7dfaa":"code","d6528a47":"code","c5c4aed9":"code","8324715d":"code","8a0e127f":"code","0e250c51":"code","5f308f19":"code","d54672cc":"code","7d51c760":"code","7bef8ded":"code","f7549bbf":"code","00a02a67":"code","0cb63c61":"code","87fbbe17":"code","352735a5":"code","59ef69cf":"code","f1a85cbd":"code","a23c7d6b":"code","8af73469":"code","48469c0a":"code","5062ed67":"code","31e1ef41":"code","a2f05d94":"code","15e06004":"code","2ad485a5":"code","131ea720":"code","0c533c32":"code","5a68c1d6":"code","d7811af7":"code","3c7a82c5":"markdown","dc211d30":"markdown","b771ed02":"markdown","320931e2":"markdown","972d9d13":"markdown","6c26b23c":"markdown","f5919eef":"markdown","97758989":"markdown","ddb8cd9a":"markdown","a9e98fd2":"markdown","18bb2f4f":"markdown","7da6bacc":"markdown","5f17d63f":"markdown","b1702616":"markdown","0826ece3":"markdown","ff6c6dc8":"markdown","3006347b":"markdown","feec46f3":"markdown","4f37938d":"markdown","b64e63c7":"markdown","60d344ca":"markdown","38d40309":"markdown","56ce923b":"markdown","56e23a48":"markdown","3469bbe9":"markdown","a5512426":"markdown","286f5f41":"markdown","416f8512":"markdown","dc034318":"markdown","26fcf859":"markdown","5a518ca6":"markdown","04d5240a":"markdown","16b01d7e":"markdown","1a3b0050":"markdown","411247e0":"markdown","3ecada72":"markdown","7a5d3773":"markdown","006a212f":"markdown","64816ab7":"markdown","0d43cf11":"markdown","1a658e63":"markdown","58bed8b2":"markdown","3b55cc61":"markdown","6b68d215":"markdown","294a4a91":"markdown","f6032c63":"markdown","108288df":"markdown","2c101123":"markdown","b64cff01":"markdown","e03cc067":"markdown","02ef6d0a":"markdown","406c32b9":"markdown","c00cac39":"markdown","75b8eb85":"markdown","ea4c71c3":"markdown","2f333ad4":"markdown","85650d49":"markdown","64312c01":"markdown","89d6febe":"markdown","c9ff2d68":"markdown","8ba5cf41":"markdown","16628d71":"markdown","43622ced":"markdown","f8e22233":"markdown","d29806a4":"markdown","939975f3":"markdown","445329e7":"markdown","307544a3":"markdown","d805bac3":"markdown","0ed3fe09":"markdown","bae002af":"markdown","f7392453":"markdown","45371f8a":"markdown","f003944f":"markdown","a1144756":"markdown","06aede56":"markdown","948a5c5b":"markdown","f6900abe":"markdown","f6dbe989":"markdown","e0ccccce":"markdown","ed9d30ba":"markdown","41d5d025":"markdown","8e3b153f":"markdown","b975c480":"markdown","cd882575":"markdown","8bcce7d6":"markdown","a284724d":"markdown","e6d03a8a":"markdown","448a6e6e":"markdown","9fcb25ff":"markdown","f075490e":"markdown","6d513da1":"markdown","6de9dea5":"markdown","cc63cf36":"markdown","cc10dcc3":"markdown","4f860302":"markdown","443db45e":"markdown","992b2080":"markdown","583862bc":"markdown","7ef5298d":"markdown","8ec5c579":"markdown","60ace5ec":"markdown"},"source":{"6cb979ef":"# @title Tutorial slides\n\n# @markdown These are the slides for the videos in this tutorial\nfrom IPython.display import IFrame\nIFrame(src=f\"https:\/\/mfr.ca-1.osf.io\/render?url=https:\/\/osf.io\/ft2sz\/?direct%26mode=render%26action=download%26mode=render\", width=854, height=480)","328ed366":"# @title Install dependencies\n!pip install git+https:\/\/github.com\/NeuromatchAcademy\/evaltools --quiet\nfrom evaltools.airtable import AirtableForm\n\n# generate airtable form\natform = AirtableForm('appn7VdPRseSoMXEG','W1D4_T1','https:\/\/portal.neuromatchacademy.org\/api\/redirect\/to\/9548a279-c9f9-4586-b89c-f0ceceba5c14')","64e9d798":"# Imports\nimport time\nimport copy\nimport torch\nimport torchvision\n\nimport numpy as np\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\nimport torchvision.datasets as datasets\n\nfrom tqdm.auto import tqdm","5c344233":"# @title Figure settings\nimport ipywidgets as widgets       # interactive display\n%config InlineBackend.figure_format = 'retina'\nplt.style.use(\"https:\/\/raw.githubusercontent.com\/NeuromatchAcademy\/content-creation\/main\/nma.mplstyle\")\nplt.rc('axes', unicode_minus=False)","cb21c182":"# @title Helper functions\ndef print_params(model):\n  for name, param in model.named_parameters():\n    if param.requires_grad:\n      print(name, param.data)","4c1364c7":"# @title Set random seed\n\n# @markdown Executing `set_seed(seed=seed)` you are setting the seed\n\n# for DL its critical to set the random seed so that students can have a\n# baseline to compare their results to expected results.\n# Read more here: https:\/\/pytorch.org\/docs\/stable\/notes\/randomness.html\n\n# Call `set_seed` function in the exercises to ensure reproducibility.\nimport random\nimport torch\n\ndef set_seed(seed=None, seed_torch=True):\n  if seed is None:\n    seed = np.random.choice(2 ** 32)\n  random.seed(seed)\n  np.random.seed(seed)\n  if seed_torch:\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.benchmark = False\n    torch.backends.cudnn.deterministic = True\n\n  print(f'Random seed {seed} has been set.')\n\n\n# In case that `DataLoader` is used\ndef seed_worker(worker_id):\n  worker_seed = torch.initial_seed() % 2**32\n  np.random.seed(worker_seed)\n  random.seed(worker_seed)","396f6fb1":"# @title Set device (GPU or CPU). Execute `set_device()`\n# especially if torch modules used.\n\n# inform the user if the notebook uses GPU or CPU.\n\ndef set_device():\n  device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n  if device != \"cuda\":\n    print(\"WARNING: For this notebook to perform best, \"\n        \"if possible, in the menu under `Runtime` -> \"\n        \"`Change runtime type.`  select `GPU` \")\n  else:\n    print(\"GPU is enabled in this notebook.\")\n\n  return device","56165e1e":"SEED = 2021\nset_seed(seed=SEED)\nDEVICE = set_device()","5f4af7de":"# @title Video 1: Introduction\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1VB4y1K7Vr\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"zm9oekdkJbQ\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 1: Introduction')\n\ndisplay(out)","1c44de87":"# @title Video 2: Case Study - MLP Classification\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1GB4y1K7Ha\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"pJc2ENhYbqA\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 2: Case Study - MLP Classification')\n\ndisplay(out)","74ab3535":"# @title Download MNIST dataset\nimport tarfile, requests, os\n\nfname = 'MNIST.tar.gz'\nname = 'MNIST'\nurl = 'https:\/\/osf.io\/y2fj6\/download'\n\nif not os.path.exists(name):\n  print('\\nDownloading MNIST dataset...')\n  r = requests.get(url, allow_redirects=True)\n  with open(fname, 'wb') as fh:\n    fh.write(r.content)\n  print('\\nDownloading MNIST completed.')\n\nif not os.path.exists(name):\n  with tarfile.open(fname) as tar:\n    tar.extractall()\n    os.remove(fname)\nelse:\n  print('MNIST dataset has been dowloaded.')","9023a3fa":"def load_mnist_data(change_tensors=False, download=False):\n  \"\"\"Load training and test examples for the MNIST digits dataset\n\n  Returns:\n    train_data (tensor): training input tensor of size (train_size x 784)\n    train_target (tensor): training 0-9 integer label tensor of size (train_size)\n    test_data (tensor): test input tensor of size (70k-train_size x 784)\n    test_target (tensor): training 0-9 integer label tensor of size (70k-train_size)\n\n  \"\"\"\n  # Load train and test sets\n  train_set = datasets.MNIST(root='.', train=True, download=download,\n                             transform=torchvision.transforms.ToTensor())\n  test_set = datasets.MNIST(root='.', train=False, download=download,\n                            transform=torchvision.transforms.ToTensor())\n\n  # Original data is in range [0, 255]. We normalize the data wrt its mean and std_dev.\n  ## Note that we only used *training set* information to compute mean and std\n  mean = train_set.data.float().mean()\n  std = train_set.data.float().std()\n\n  if change_tensors:\n    # Apply normalization directly to the tensors containing the dataset\n    train_set.data = (train_set.data.float() - mean) \/ std\n    test_set.data = (test_set.data.float() - mean) \/ std\n  else:\n    tform = torchvision.transforms.Compose([torchvision.transforms.ToTensor(),\n                                            torchvision.transforms.Normalize(mean=[mean \/ 255.], std=[std \/ 255.])\n                                            ])\n    train_set = datasets.MNIST(root='.', train=True, download=download,\n                               transform=tform)\n    test_set = datasets.MNIST(root='.', train=False, download=download,\n                              transform=tform)\n\n  return train_set, test_set\n\n\ntrain_set, test_set = load_mnist_data(change_tensors=True)","68048ca6":"# Sample a random subset of 500 indices\nsubset_index = np.random.choice(len(train_set.data), 500)\n\n# We will use these symbols to represent the training data and labels, to stay\n# as close to the mathematical expressions as possible.\nX, y = train_set.data[subset_index, :], train_set.targets[subset_index]","5184b356":"# @title Run me!\nnum_figures = 3\nfig, axs = plt.subplots(1, num_figures, figsize=(5 * num_figures, 5))\n\nfor sample_id, ax in enumerate(axs):\n  # Plot the pixel values for each image\n  ax.matshow(X[sample_id, :], cmap='gray_r')\n  # 'Write' the pixel value in the corresponding location\n  for (i, j), z in np.ndenumerate(X[sample_id, :]):\n    text = '{:.1f}'.format(z)\n    ax.text(j, i, text, ha='center',\n            va='center', fontsize=6, c='steelblue')\n\n  ax.set_title('Label: ' + str(y[sample_id].item()))\n  ax.axis('off')\n\nplt.show()","bc0cf181":"28*28","236697ec":"class MLP(nn.Module):\n  \"\"\" This class implements MLPs in Pytorch of an arbitrary number of hidden\n  layers of potentially different sizes. Since we concentrate on classification\n  tasks in this tutorial, we have a log_softmax layer at prediction time.\n  \"\"\"\n\n  def __init__(self, in_dim=784, out_dim=10, hidden_dims=[], use_bias=True):\n    \"\"\"Constructs a MultiLayerPerceptron\n\n    Args:\n        in_dim (int): dimensionality of input data\n        out_dim (int): number of classes\n        hidden_dims (list): contains the dimensions of the hidden layers, an empty\n            list corresponds to a linear model (in_dim, out_dim)\n    \"\"\"\n\n    super(MLP, self).__init__()\n\n    self.in_dim = in_dim\n    self.out_dim = out_dim\n\n    # If we have no hidden layer, just initialize a linear model (e.g. in logistic regression)\n    if len(hidden_dims) == 0:\n      layers = [nn.Linear(in_dim, out_dim, bias=use_bias)]\n    else:\n      # 'Actual' MLP with dimensions in_dim - num_hidden_layers*[hidden_dim] - out_dim\n      layers = [nn.Linear(in_dim, hidden_dims[0], bias=use_bias), nn.ReLU()]\n\n      # Loop until before the last layer\n      for i, hidden_dim in enumerate(hidden_dims[:-1]):\n        layers += [nn.Linear(hidden_dim, hidden_dims[i + 1], bias=use_bias),\n                   nn.ReLU()]\n\n      # Add final layer to the number of classes\n      layers += [nn.Linear(hidden_dims[-1], out_dim, bias=use_bias)]\n\n    self.main = nn.Sequential(*layers)\n\n  def forward(self, x):\n    # Flatten the images into 'vectors'\n    transformed_x = x.view(-1, self.in_dim)\n    hidden_output = self.main(transformed_x)\n    output = F.log_softmax(hidden_output, dim=1)\n    return output","da1e9403":"# Empty hidden_dims means we take a model with zero hidden layers.\nmodel = MLP(in_dim=784, out_dim=10, hidden_dims=[])\n\n# We print the model structure with 784 inputs and 10 outputs\nprint(model)","1b7df317":"#import torch.nn.functional as F\nloss_fn = F.nll_loss","db641c5f":"#@markdown Run _this cell_ to train the model. If you are curious about how the training\n#@markdown takes place, double-click this cell to find out. At the end of this tutorial\n#@markdown you will have the opportunity to train a more complex model on your own.\n\ncell_verbose = False\npartial_trained_model = MLP(in_dim=784, out_dim=10, hidden_dims=[])\n\nif cell_verbose:\n  print('Init loss', loss_fn(partial_trained_model(X), y).item()) # This matches around np.log(10 = # of classes)\n\noptimizer = optim.Adam(partial_trained_model.parameters(), lr=7e-4)\nfor _ in range(200):\n  loss = loss_fn(partial_trained_model(X), y)\n  optimizer.zero_grad()\n  loss.backward()\n  optimizer.step()\n\nif cell_verbose:\n  print('End loss', loss_fn(partial_trained_model(X), y).item()) # This should be less than 1e-2","61effdb7":"# Show class filters of a trained model\nW = partial_trained_model.main[0].weight.data.numpy()\n\nfig, axs = plt.subplots(1, 10, figsize=(15, 4))\nfor class_id in range(10):\n  axs[class_id].imshow(W[class_id, :].reshape(28, 28), cmap='gray_r')\n  axs[class_id].axis('off')\n  axs[class_id].set_title('Class ' + str(class_id) )\n\nplt.show()","d0087760":"# @title Video 3: Optimization of an Objective Function\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1aL411H7Ce\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"aSJTRdjRvvw\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 3: Optimization of an Objective Function')\n\ndisplay(out)","e2b7dfaa":"def zero_grad(params):\n  \"\"\"Clear up gradients as Pytorch automatically accumulates gradients from\n  successive backward calls\n  \"\"\"\n  for par in params:\n    if not(par.grad is None):\n      par.grad.data.zero_()\n\n\ndef random_update(model, noise_scale=0.1, normalized=False):\n  \"\"\" Performs a random update on the parameters of the model\n  \"\"\"\n  for par in model.parameters():\n    noise = torch.randn_like(par)\n    if normalized:\n      noise \/= torch.norm(noise)\n    par.data +=  noise_scale * noise","d6528a47":"def gradient_update(loss, params, lr=1e-3):\n  \"\"\"Perform a gradient descent update on a given loss over a collection of parameters\n\n  Args:\n    loss (tensor): A scalar tensor containing the loss whose gradient will be computed\n    params (iterable): Collection of parameters with respect to which we compute gradients\n    lr (float): Scalar specifying the learning rate or step-size for the update\n  \"\"\"\n  # Clear up gradients as Pytorch automatically accumulates gradients from\n  # successive backward calls\n  zero_grad(params)\n\n  # Compute gradients on given objective\n\n  loss.backward()\n\n  with torch.no_grad():\n    for par in params:\n      #################################################\n      ## TODO for students: update the value of the parameter ##\n      # raise NotImplementedError(\"Student exercise: implement gradient update\")\n      #################################################\n      # Here we work with the 'data' attribute of the parameter rather than the\n      # parameter itself.\n      par.data -= lr * par.grad.data\n\n\n# add event to airtable\natform.add_event('Coding Exercise 3: Implement gradient descent')\n\n\nset_seed(seed=SEED)\nmodel1 = MLP(in_dim=784, out_dim=10, hidden_dims=[])\nprint('\\n The model1 parameters before the update are: \\n')\nprint_params(model1)\nloss = loss_fn(model1(X), y)\n\n## Uncomment below to test your function\ngradient_update(loss, list(model1.parameters()), lr=1e-1)\nprint('\\n The model1 parameters after the update are: \\n')\nprint_params(model1)","c5c4aed9":"# @markdown _Run this cell_ to visualize the results\nfig, axs = plt.subplots(1, 2, figsize=(10, 4))\n\nfor id, (model_name, my_model) in enumerate([('Initialization', model),\n                                              ('Partially trained', partial_trained_model)]):\n  # Compue the loss we will be comparing to\n  base_loss = loss_fn(my_model(X), y)\n\n  # Compute the improvement via gradient descent\n  dummy_model = copy.deepcopy(my_model)\n  loss1 = loss_fn(dummy_model(X), y)\n  gradient_update(loss1, list(dummy_model.parameters()), lr=1e-2)\n  gd_delta = loss_fn(dummy_model(X), y) - base_loss\n\n  deltas = []\n  for trial_id in range(100):\n    # Compute the improvement obtained with a random direction\n    dummy_model = copy.deepcopy(my_model)\n    random_update(dummy_model, noise_scale=1e-2)\n    deltas.append((loss_fn(dummy_model(X), y) - base_loss).item())\n\n  # Plot histogram for random direction and vertical line for gradient descent\n  axs[id].hist(deltas, label='Random Directions', bins=20)\n  axs[id].set_title(model_name)\n  axs[id].set_xlabel('Change in loss')\n  axs[id].set_ylabel('% samples')\n  axs[id].axvline(0, c='green', alpha=0.5)\n  axs[id].axvline(gd_delta.item(), linestyle='--', c='red', alpha=1,\n                  label='Gradient Descent')\n\n\nhandles, labels = axs[id].get_legend_handles_labels()\nfig.legend(handles, labels, loc='upper center',\n           bbox_to_anchor=(0.5, 1.05),\n           fancybox=False, shadow=False, ncol=2)\n\nplt.show()","8324715d":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer('q1' , text.value)\n   print(\"Submission successful!\")\n\n\nbutton.on_click(on_button_clicked)","8a0e127f":"# @title Video 4: Momentum\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1NL411H71t\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"3ES5O58Y_2M\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 4: Momentum')\n\ndisplay(out)","0e250c51":"# @markdown _Run this cell_ to setup some helper functions.\n\ndef loss_2d(model, u, v, mask_idx=(0, 378), bias_id=7):\n  \"\"\"Defines a 2-dim function by freezing all but two parameters of a linear\n  model.\n\n  Args:\n    model (torch module): a pytorch 0-hidden layer (linear) model\n    u (scalar): first free parameter\n    v (scalar): second free parameter\n    mask_idx (tuple): selects parameter in weight matrix replaced by u\n    bias_idx (int): selects parameter in bias vector replaced by v\n\n  Returns:\n    scalar: loss of the 'new' model over inputs X, y (defined externally)\n  \"\"\"\n\n  # We zero out the element of the weight tensor that will be\n  # replaced by u\n  mask = torch.ones_like(model.main[0].weight)\n  mask[mask_idx[0], mask_idx[1]] = 0.\n  masked_weights = model.main[0].weight * mask\n\n  # u is replacing an element of the weight matrix\n  masked_weights[mask_idx[0], mask_idx[1]] = u\n\n  res = X.reshape(-1, 784) @ masked_weights.T + model.main[0].bias\n\n  # v is replacing a bias for class 7\n  res[:, 7] += v - model.main[0].bias[7]\n  res =  F.log_softmax(res, dim=1)\n\n  return loss_fn(res, y)\n\n\ndef plot_surface(U, V, Z, fig):\n  \"\"\" Plot a 3D loss surface given meshed inputs U, V and values Z\n  \"\"\"\n  ax = fig.add_subplot(1, 2, 2, projection='3d')\n  ax.view_init(45, -130)\n\n  surf = ax.plot_surface(U, V, Z, cmap=plt.cm.coolwarm,\n                      linewidth=0, antialiased=True, alpha=0.5)\n\n  # Select certain level contours to plot\n  # levels = Z.min() * np.array([1.005, 1.1, 1.3, 1.5, 2.])\n  # plt.contour(U, V, Z)# levels=levels, alpha=0.5)\n\n  ax.set_xlabel('Weight')\n  ax.set_ylabel('Bias')\n  ax.set_zlabel('Loss', rotation=90)\n\n  return ax\n\n\ndef plot_param_distance(best_u, best_v, trajs, fig, styles, labels,\n                        use_log=False, y_min_v=-12.0, y_max_v=1.5):\n  \"\"\" Plot the distance to each of the two parameters for a collection of 'trajectories'\n  \"\"\"\n  ax = fig.add_subplot(1, 1, 1)\n\n  for traj, style, label in zip(trajs, styles, labels):\n    d0 = np.array([np.abs(_[0] - best_u) for _ in traj])\n    d1 = np.array([np.abs(_[1] - best_v) for _ in traj])\n    if use_log:\n      d0 = np.log(1e-16 + d0)\n      d1 = np.log(1e-16 + d1)\n    ax.plot(range(len(traj)), d0, style, label='weight - ' + label)\n    ax.plot(range(len(traj)), d1, style, label='bias - ' + label)\n  ax.set_xlabel('Iteration')\n  if use_log:\n    ax.set_ylabel('Log distance to optimum (per dimension)')\n    ax.set_ylim(y_min_v, y_max_v)\n  else:\n    ax.set_ylabel('Abs distance to optimum (per dimension)')\n  ax.legend(loc='right', bbox_to_anchor=(1.5, 0.5),\n            fancybox=False, shadow=False, ncol=1)\n\n  return ax\n\n\ndef run_optimizer(inits, eval_fn, update_fn, max_steps=500,\n                  optim_kwargs={'lr':1e-2}, log_traj=True):\n  \"\"\"Runs an optimizer on a given objective and logs parameter trajectory\n\n  Args:\n      inits list(scalar): initialization of parameters\n      eval_fn (callable): function computing the objective to be minimized\n      update_fn (callable): function executing parameter update\n      max_steps (int): number of iterations to run\n      optim_kwargs (dict): customize optimizer hyperparameters\n\n  Returns:\n      list[list]: trajectory information [*params, loss] for each optimization step\n  \"\"\"\n\n  # Initialize parameters and optimizer\n  params = [nn.Parameter(torch.tensor(_)) for _ in inits]\n  # Methods like momentum and rmsprop keep and auxiliary vector of parameters\n  aux_tensors = [torch.zeros_like(_) for _ in params]\n  if log_traj:\n    traj = np.zeros((max_steps, len(params)+1))\n  for _ in range(max_steps):\n    # Evaluate loss\n    loss = eval_fn(*params)\n    # Store 'trajectory' information\n    if log_traj:\n      traj[_, :] = [_.item() for _ in params] + [loss.item()]\n    # Perform update\n    if update_fn == gradient_update:\n      gradient_update(loss, params, **optim_kwargs)\n    else:\n      update_fn(loss, params, aux_tensors, **optim_kwargs)\n  if log_traj:\n    return traj\n\n\nL = 4.\nxs = np.linspace(-L, L, 30)\nys = np.linspace(-L, L, 30)\nU, V = np.meshgrid(xs, ys)","5f308f19":"def momentum_update(loss, params, grad_vel, lr=1e-3, beta=0.8):\n  \"\"\"Perform a momentum update over a collection of parameters given a loss and 'velocities'\n\n  Args:\n    loss (tensor): A scalar tensor containing the loss whose gradient will be computed\n    params (iterable): Collection of parameters with respect to which we compute gradients\n    grad_vel (iterable): Collection containing the 'velocity' v_t for each parameter\n    lr (float): Scalar specifying the learning rate or step-size for the update\n    beta (float): Scalar 'momentum' parameter\n  \"\"\"\n  # Clear up gradients as Pytorch automatically accumulates gradients from\n  # successive backward calls\n  zero_grad(params)\n  # Compute gradients on given objective\n  loss.backward()\n\n  with torch.no_grad():\n    for (par, vel) in zip(params, grad_vel):\n      #################################################\n      ## TODO for students: update the value of the parameter ##\n      # raise NotImplementedError(\"Student exercise: implement momentum update\")\n      #################################################\n      # Update 'velocity'\n      vel.data = - lr*par.grad.data + beta*vel.data\n      # Update parameters\n      par.data += vel.data\n\n\n# add event to airtable\natform.add_event('Coding Exercise 4: Implement momentum')\n\n\nset_seed(seed=SEED)\nmodel2 = MLP(in_dim=784, out_dim=10, hidden_dims=[])\nprint('\\n The model2 parameters before the update are: \\n')\nprint_params(model2)\nloss = loss_fn(model2(X), y)\ninitial_vel = [torch.randn_like(p) for p in model2.parameters()]\n\n## Uncomment below to test your function\nmomentum_update(loss, list(model2.parameters()), grad_vel=initial_vel, lr=1e-1, beta=0.9)\nprint('\\n The model2 parameters after the update are: \\n')\nprint_params(model2)","d54672cc":"# @markdown Run this cell to enable the widget!\nfrom matplotlib.lines import Line2D\n\n# Find the optimum of this 2D problem using Newton's method\ndef run_newton(func, init_list=[0., 0.], max_iter=200):\n\n  par_tensor = torch.tensor(init_list, requires_grad=True)\n  t_g = lambda par_tensor: func(par_tensor[0], par_tensor[1])\n\n  for _ in tqdm(range(max_iter)):\n    eval_loss = t_g(par_tensor)\n    eval_grad = torch.autograd.grad(eval_loss, [par_tensor])[0]\n    eval_hess = torch.autograd.functional.hessian(t_g, par_tensor)\n    # Newton's update is:  - inverse(Hessian) x gradient\n    par_tensor.data -= torch.inverse(eval_hess) @ eval_grad\n\n  return par_tensor.data.numpy()\n\n\nset_seed(2021)\nmodel = MLP(in_dim=784, out_dim=10, hidden_dims=[])\n# Define 2d loss objectives and surface values\ng = lambda u, v: loss_2d(copy.deepcopy(model), u, v)\nZ = np.fromiter(map(g, U.ravel(), V.ravel()), U.dtype).reshape(V.shape)\n\nbest_u, best_v  = run_newton(func=g)\n\n# Initialization of the variables\nINITS = [2.5, 3.7]\n\n# Used for plotting\nLABELS = ['GD', 'Momentum']\nCOLORS = ['black', 'red']\nLSTYLES = ['-', '--']\n\n\n@widgets.interact_manual\ndef momentum_experiment(max_steps=widgets.IntSlider(300, 50, 500, 5),\n                        lr=widgets.FloatLogSlider(value=1e-1, min=-3, max=0.7, step=0.1),\n                        beta=widgets.FloatSlider(value=9e-1, min=0, max=1., step=0.01)\n                        ):\n\n  # Execute both optimizers\n  sgd_traj = run_optimizer(INITS, eval_fn=g, update_fn=gradient_update,\n                           max_steps=max_steps, optim_kwargs={'lr': lr})\n  mom_traj = run_optimizer(INITS, eval_fn=g, update_fn=momentum_update,\n                           max_steps=max_steps, optim_kwargs={'lr': lr, 'beta':beta})\n\n  TRAJS = [sgd_traj, mom_traj]\n\n  # Plot distances\n  fig = plt.figure(figsize=(9,4))\n  plot_param_distance(best_u, best_v, TRAJS, fig,\n                      LSTYLES, LABELS, use_log=True, y_min_v=-12.0, y_max_v=1.5)\n\n  # # Plot trajectories\n  fig = plt.figure(figsize=(12, 5))\n  ax = plot_surface(U, V, Z, fig)\n  for traj, c, label in zip(TRAJS, COLORS, LABELS):\n    ax.plot3D(*traj.T, c, linewidth=0.3, label=label)\n    ax.scatter3D(*traj.T, '.-', s=1, c=c)\n\n  # Plot optimum point\n  ax.scatter(best_u, best_v, Z.min(), marker='*', s=80, c='lime', label='Opt.');\n  lines = [Line2D([0], [0],\n                  color=c,\n                  linewidth=3,\n                  linestyle='--') for c in COLORS]\n  lines.append(Line2D([0], [0], color='lime', linewidth=0, marker='*'))\n  ax.legend(lines, LABELS + ['Optimum'], loc='right',\n            bbox_to_anchor=(.8, -0.1), ncol=len(LABELS) + 1)","7d51c760":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer('q2' , text.value)\n   print(\"Submission successful!\")\n\n\nbutton.on_click(on_button_clicked)","7bef8ded":"# @title Video 5: Overparametrization\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV16h41167Jr\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"7vUpUEKKl5o\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event(\"Video 5: Overparametrization\")\n\ndisplay(out)","f7549bbf":"# @markdown Execute this cell to enable the widget!\n\n@widgets.interact_manual\ndef overparam(max_steps=widgets.IntSlider(150, 50, 500, 5),\n              hidden_dims=widgets.Dropdown(options=[\"10\", \"20, 20\", \"100, 100\"],\n                                           value=\"10\"),\n              lr=widgets.FloatLogSlider(value=5e-2, min=-3, max=0, step=0.1),\n              num_inits=widgets.IntSlider(7, 5, 10, 1)):\n\n    X, y = train_set.data[subset_index, :], train_set.targets[subset_index]\n\n    hdims = [int(s) for s in hidden_dims.split(',')]\n    base_model = MLP(in_dim=784, out_dim=10, hidden_dims=hdims)\n\n    fig, axs = plt.subplots(1, 1, figsize=(5, 4))\n\n    for _ in tqdm(range(num_inits)):\n      model = copy.deepcopy(base_model)\n      random_update(model, noise_scale=2e-1)\n\n      loss_hist = np.zeros((max_steps, 2))\n      for step in range(max_steps):\n        loss = loss_fn(model(X), y)\n        gradient_update(loss, list(model.parameters()), lr=lr)\n        loss_hist[step] = np.array([step, loss.item()])\n\n      plt.plot(loss_hist[:, 0], loss_hist[:, 1])\n\n    plt.xlabel('Iteration')\n    plt.ylabel('Loss')\n    plt.ylim(0, 3)\n    plt.show()\n\n    num_params = sum([np.prod(_.shape) for _ in model.parameters()])\n    print('Number of paramaters in model:  ' + str(num_params))","00a02a67":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer('q3' , text.value)\n   print(\"Submission successful!\")","0cb63c61":"# @title Video 6: Mini-batches\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1ty4y1T7Uh\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"hbqUxpNBUGk\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event(\"Video 6: Mini-batches\")\n\ndisplay(out)","87fbbe17":"# @markdown Execute this cell to enable the widget!\n\ndef measure_update_time(model, num_points):\n  X, y = train_set.data[:num_points], train_set.targets[:num_points]\n  start_time = time.time()\n  loss = loss_fn(model(X), y)\n  loss_time = time.time()\n  gradient_update(loss, list(model.parameters()), lr=0)\n  gradient_time = time.time()\n  return loss_time - start_time, gradient_time - loss_time\n\n\n@widgets.interact\ndef computation_time(hidden_dims=widgets.Dropdown(options=[\"1\", \"100\", \"50, 50\"],\n                                                  value=\"100\")):\n\n  hdims = [int(s) for s in hidden_dims.split(',')]\n  model = MLP(in_dim=784, out_dim=10, hidden_dims=hdims)\n\n  NUM_POINTS = [1, 5, 10, 100, 200, 500, 1000, 5000, 10000, 20000, 30000, 50000]\n  times_list = []\n  for _ in range(5):\n    times_list.append(np.array([measure_update_time(model, _) for _ in NUM_POINTS]))\n\n  times = np.array(times_list).mean(axis=0)\n\n  fig, axs = plt.subplots(1, 1, figsize=(5,4))\n  plt.plot(NUM_POINTS, times[:, 0], label='Forward')\n  plt.plot(NUM_POINTS, times[:, 1], label='Backward')\n  plt.xlabel('Number of data points')\n  plt.ylabel('Seconds')\n  plt.legend()","352735a5":"def sample_minibatch(input_data, target_data, num_points=100):\n  \"\"\"Sample a minibatch of size num_point from the provided input-target data\n\n  Args:\n    input_data (tensor): Multi-dimensional tensor containing the input data\n    target_data (tensor): 1D tensor containing the class labels\n    num_points (int): Number of elements to be included in minibatch\n\n  Returns:\n    batch_inputs (tensor): Minibatch inputs\n    batch_targets (tensor): Minibatch targets\n  \"\"\"\n  #################################################\n  ## TODO for students: sample minibatch of data ##\n  # raise NotImplementedError(\"Student exercise: implement gradient update\")\n  #################################################\n  # Sample a collection of IID indices from the existing data\n  batch_indices = torch.randperm(len(input_data))[:num_points]\n  #print(batch_indices)\n\n  # Use batch_indices to extract entries from the input and target data tensors\n  batch_inputs = input_data[batch_indices]\n  batch_targets = target_data[batch_indices]\n\n  return batch_inputs, batch_targets\n\n# add event to airtable\natform.add_event('Coding Exercise 6: Implement minibatch sampling')\n\n\n## Uncomment to test your function\nx_batch, y_batch = sample_minibatch(X, y, num_points=100)\nprint(f\"The input shape is {x_batch.shape} and the target shape is: {y_batch.shape}\")\n","59ef69cf":"# @markdown Execute this cell to enable the widget!\n\n@widgets.interact_manual\ndef minibatch_experiment(batch_sizes='20, 250, 1000',\n                         lrs='5e-3, 5e-3, 5e-3',\n                         time_budget=widgets.Dropdown(options=[\"2.5\", \"5\", \"10\"],\n                                                      value=\"2.5\")):\n\n  batch_sizes = [int(s) for s in batch_sizes.split(',')]\n  lrs = [float(s) for s in lrs.split(',')]\n\n  LOSS_HIST = {_:[] for _ in batch_sizes}\n\n  X, y = train_set.data, train_set.targets\n  base_model = MLP(in_dim=784, out_dim=10, hidden_dims=[100, 100])\n\n  for id, batch_size in enumerate(tqdm(batch_sizes)):\n    start_time = time.time()\n    # Create a new copy of the model for each batch size\n    model = copy.deepcopy(base_model)\n    params = list(model.parameters())\n    lr = lrs[id]\n    # Fixed budget per choice of batch size\n    while (time.time() - start_time) < float(time_budget):\n      data, labels = sample_minibatch(X, y, batch_size)\n      loss = loss_fn(model(data), labels)\n      gradient_update(loss, params, lr=lr)\n      LOSS_HIST[batch_size].append([time.time() - start_time,\n                                    loss.item()])\n\n  fig, axs = plt.subplots(1, len(batch_sizes), figsize=(10, 3))\n  for ax, batch_size in zip(axs, batch_sizes):\n    plot_data = np.array(LOSS_HIST[batch_size])\n    ax.plot(plot_data[:, 0], plot_data[:, 1], label=batch_size,\n            alpha=0.8)\n    ax.set_title('Batch size: ' + str(batch_size))\n    ax.set_xlabel('Seconds')\n    ax.set_ylabel('Loss')\n  plt.show()","f1a85cbd":"# @title Video 7: Adaptive Methods\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1eq4y1W7JG\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"Zr6r2kfmQUM\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 7: Adaptive Methods')\n\ndisplay(out)","a23c7d6b":"def rmsprop_update(loss, params, grad_sq, lr=1e-3, alpha=0.8, epsilon=1e-8):\n  \"\"\"Perform an RMSprop update on a collection of parameters\n\n  Args:\n    loss (tensor): A scalar tensor containing the loss whose gradient will be computed\n    params (iterable): Collection of parameters with respect to which we compute gradients\n    grad_sq (iterable): Moving average of squared gradients\n    lr (float): Scalar specifying the learning rate or step-size for the update\n    alpha (float): Moving average parameter\n    epsilon (float): for numerical estability\n  \"\"\"\n  # Clear up gradients as Pytorch automatically accumulates gradients from\n  # successive backward calls\n  zero_grad(params)\n  # Compute gradients on given objective\n  loss.backward()\n\n  with torch.no_grad():\n    for (par, gsq) in zip(params, grad_sq):\n      #################################################\n      ## TODO for students: update the value of the parameter ##\n      # Use gsq.data and par.grad\n      # raise NotImplementedError(\"Student exercise: implement gradient update\")\n      #################################################\n      # Update estimate of gradient variance\n      gsq.data = alpha * gsq.data + (1-alpha) * torch.square(par.grad.data)\n      # Update parameters\n      par.data -=  lr * ( par.grad.data \/ torch.sqrt(gsq.data + epsilon) )\n\n\n# add event to airtable\natform.add_event('Coding Exercise 7: Implement RMSprop')\n\n\nset_seed(seed=SEED)\nmodel3 = MLP(in_dim=784, out_dim=10, hidden_dims=[])\nprint('\\n The model3 parameters before the update are: \\n')\nprint_params(model3)\nloss = loss_fn(model3(X), y)\n# Intialize the moving average of squared gradients\ngrad_sq = [1e-6*i for i in list(model3.parameters())]\n\n\n\n## Uncomment below to test your function\nrmsprop_update(loss, list(model3.parameters()), grad_sq=grad_sq, lr=1e-3)\nprint('\\n The model3 parameters after the update are: \\n')\nprint_params(model3)","8af73469":"# @markdown Execute this cell to enable the widget!\nX, y = train_set.data, train_set.targets\n\n@widgets.interact_manual\ndef compare_optimizers(\n    batch_size=(25, 250, 5),\n    lr=widgets.FloatLogSlider(value=2e-3, min=-5, max=0),\n    max_steps=(50, 500, 5)):\n\n  SGD_DICT = [gradient_update, 'SGD', 'black', '-', {'lr': lr}]\n  MOM_DICT = [momentum_update, 'Momentum', 'red', '--', {'lr': lr, 'beta': 0.9}]\n  RMS_DICT = [rmsprop_update, 'RMSprop', 'fuchsia', '-', {'lr': lr, 'alpha': 0.8}]\n\n  ALL_DICTS = [SGD_DICT, MOM_DICT, RMS_DICT]\n\n  base_model = MLP(in_dim=784, out_dim=10, hidden_dims=[100, 100])\n\n  LOSS_HIST = {}\n\n  for opt_dict in tqdm(ALL_DICTS):\n    update_fn, opt_name, color, lstyle, kwargs = opt_dict\n    LOSS_HIST[opt_name] = []\n\n    model = copy.deepcopy(base_model)\n    params = list(model.parameters())\n\n    if opt_name != 'SGD':\n      aux_tensors = [torch.zeros_like(_) for _ in params]\n\n    for step in range(max_steps):\n      data, labels = sample_minibatch(X, y, batch_size)\n      loss = loss_fn(model(data), labels)\n      if opt_name == 'SGD':\n        update_fn(loss, params, **kwargs)\n      else:\n        update_fn(loss, params, aux_tensors, **kwargs)\n      LOSS_HIST[opt_name].append(loss.item())\n\n  fig, axs = plt.subplots(1, len(ALL_DICTS), figsize=(9, 3))\n  for ax, optim_dict in zip(axs, ALL_DICTS):\n    opt_name = optim_dict[1]\n    ax.plot(range(max_steps), LOSS_HIST[opt_name], alpha=0.8)\n    ax.set_title(opt_name)\n    ax.set_xlabel('Iteration')\n    ax.set_ylabel('Loss')\n    ax.set_ylim(0, 2.5)\n  plt.show()","48469c0a":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer('q4' , text.value)\n   print(\"Submission successful!\")","5062ed67":"# @title Video 8: Ethical concerns\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1TU4y1G7Je\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"0EthSI0cknI\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 8: Ethical concerns')\n\ndisplay(out)","31e1ef41":"# @title Airtable Submission Link\nfrom IPython import display as IPydisplay\nIPydisplay.HTML(\n   f\"\"\"\n <div>\n   <a href= \"{atform.url()}\" target=\"_blank\">\n   <img src=\"https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/blob\/main\/tutorials\/static\/SurveyButton.png?raw=1\"\n alt=\"button link end of day Survey\" style=\"width:410px\"><\/a>\n   <\/div>\"\"\" )","a2f05d94":"# @title Video 9: Putting it all together\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1MK4y1u7u2\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"DP9c13vLiOM\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 9: Putting it all together')\n\ndisplay(out)","15e06004":"# @title Download parameters of the benchmark model\nimport requests\n\nfname = 'benchmark_model.pt'\nurl = \"https:\/\/osf.io\/sj4e8\/download\"\nr = requests.get(url, allow_redirects=True)\nwith open(fname, 'wb') as fh:\n  fh.write(r.content)\n\n# Load the benchmark model's parameters\nDEVICE = set_device()\nif DEVICE == \"cuda\":\n  benchmark_state_dict = torch.load(fname)\nelse:\n  benchmark_state_dict = torch.load(fname, map_location=torch.device('cpu'))","2ad485a5":"# Create MLP object and update weights with those of saved model\nbenchmark_model = MLP(in_dim=784, out_dim=10,\n                      hidden_dims=[200, 100, 50]).to(DEVICE)\nbenchmark_model.load_state_dict(benchmark_state_dict)\n\n\n# Define helper function to evaluate models\ndef eval_model(model, data_loader, num_batches=np.inf, device='cpu'):\n\n  loss_log, acc_log = [], []\n  model.to(device=device)\n\n  # We are just evaluating the model, no need to compute gradients\n  with torch.no_grad():\n    for batch_id, batch in enumerate(data_loader):\n      # If we only evaluate a number of batches, stop after we reach that number\n      if batch_id > num_batches:\n        break\n      # Extract minibatch data\n      data, labels = batch[0].to(device), batch[1].to(device)\n      # Evaluate model and loss on minibatch\n      preds = model(data)\n      loss_log.append(loss_fn(preds, labels).item())\n      acc_log.append(torch.mean(1. * (preds.argmax(dim=1) == labels)).item())\n\n  return np.mean(loss_log), np.mean(acc_log)","131ea720":"#################################################\n## TODO for students: adjust training settings ##\n\n# The three parameters below are in your full control\nMAX_EPOCHS = 2  # select number of epochs to train\nLR = 1e-5  # choose the step size\nBATCH_SIZE = 64  # number of examples per minibatch\n\n# Define the model and associated optimizer -- you may change its architecture!\nmodel = MLP(in_dim=784, out_dim=10, hidden_dims=[200, 100, 50]).to(DEVICE)\n\n# You can take your pick from many different optimizers\n# Check the optimizer documentation and hyperparameter meaning before using!\n# More details on Pytorch optimizers: https:\/\/pytorch.org\/docs\/stable\/optim.html\n# optimizer = torch.optim.SGD(model.parameters(), lr=LR, momentum=0.9)\n# optimizer = torch.optim.RMSprop(model.parameters(), lr=LR, alpha=0.99)\n# optimizer = torch.optim.Adagrad(model.parameters(), lr=LR)\noptimizer = torch.optim.Adam(model.parameters(), lr=LR)\n#################################################","0c533c32":"set_seed(seed=SEED)\n# Print trainig stats every LOG_FREQ minibatches\nLOG_FREQ = 200\n# Frequency for evaluating the validation metrics\nVAL_FREQ = 200\n# Load data using a Pytorch Dataset\ntrain_set_orig, test_set_orig = load_mnist_data(change_tensors=False)\n\n# We separate 10,000 training samples to create a validation set\ntrain_set_orig, val_set_orig = torch.utils.data.random_split(train_set, [50000, 10000])\n\n# Create the corresponding DataLoaders for training and test\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED)\n\ntrain_loader = torch.utils.data.DataLoader(train_set_orig,\n                                           shuffle=True,\n                                           batch_size=BATCH_SIZE,\n                                           worker_init_fn=seed_worker,\n                                           generator=g_seed)\nval_loader = torch.utils.data.DataLoader(val_set_orig,\n                                         shuffle=True,\n                                         batch_size=256,\n                                         worker_init_fn=seed_worker,\n                                         generator=g_seed)\ntest_loader = torch.utils.data.DataLoader(test_set_orig,\n                                          batch_size=256,\n                                          worker_init_fn=seed_worker,\n                                          generator=g_seed)\n\n# Run training\nmetrics = {'train_loss':[],\n           'train_acc':[],\n           'val_loss':[],\n           'val_acc':[],\n           'val_idx':[]}\n\nstep_idx = 0\nfor epoch in tqdm(range(MAX_EPOCHS)):\n\n  running_loss, running_acc = 0., 0.\n\n  for batch_id, batch in enumerate(train_loader):\n    step_idx += 1\n    # Extract minibatch data and labels\n    data, labels = batch[0].to(DEVICE), batch[1].to(DEVICE)\n    # Just like before, refresh gradient accumulators.\n    # Note that this is now a method of the optimizer.\n    optimizer.zero_grad()\n    # Evaluate model and loss on minibatch\n    preds = model(data)\n    loss = loss_fn(preds, labels)\n    acc = torch.mean(1.0 * (preds.argmax(dim=1) == labels))\n    # Compute gradients\n    loss.backward()\n    # Update parameters\n    # Note how all the magic in the update of the parameters is encapsulated by\n    # the optimizer class.\n    optimizer.step()\n    # Log metrics for plotting\n    metrics['train_loss'].append(loss.cpu().item())\n    metrics['train_acc'].append(acc.cpu().item())\n\n    if batch_id % VAL_FREQ == (VAL_FREQ - 1):\n      # Get an estimate of the validation accuracy with 100 batches\n      val_loss, val_acc = eval_model(model, val_loader,\n                                     num_batches=100,\n                                     device=DEVICE)\n      metrics['val_idx'].append(step_idx)\n      metrics['val_loss'].append(val_loss)\n      metrics['val_acc'].append(val_acc)\n\n      print(f\"[VALID] Epoch {epoch + 1} - Batch {batch_id + 1} - \"\n            f\"Loss: {val_loss:.3f} - Acc: {100*val_acc:.3f}%\")\n\n    # print statistics\n    running_loss += loss.cpu().item()\n    running_acc += acc.cpu().item()\n    # Print every LOG_FREQ minibatches\n    if batch_id % LOG_FREQ == (LOG_FREQ-1):\n      print(f\"[TRAIN] Epoch {epoch + 1} - Batch {batch_id + 1} - \"\n            f\"Loss: {running_loss \/ LOG_FREQ:.3f} - \"\n            f\"Acc: {100 * running_acc \/ LOG_FREQ:.3f}%\")\n\n      running_loss, running_acc = 0., 0.","5a68c1d6":"fig, ax = plt.subplots(1, 2, figsize=(10, 4))\n\nax[0].plot(range(len(metrics['train_loss'])), metrics['train_loss'],\n           alpha=0.8, label='Train')\nax[0].plot(metrics['val_idx'], metrics['val_loss'], label='Valid')\nax[0].set_xlabel('Iteration')\nax[0].set_ylabel('Loss')\nax[0].legend()\n\nax[1].plot(range(len(metrics['train_acc'])), metrics['train_acc'],\n           alpha=0.8, label='Train')\nax[1].plot(metrics['val_idx'], metrics['val_acc'], label='Valid')\nax[1].set_xlabel('Iteration')\nax[1].set_ylabel('Accuracy')\nax[1].legend()\nplt.tight_layout()\nplt.show()","d7811af7":"print('Your model...')\ntrain_loss, train_accuracy = eval_model(my_model, train_loader, device=DEVICE)\ntest_loss, test_accuracy = eval_model(my_model, test_loader, device=DEVICE)\nprint(f'Train Loss {train_loss:.3f} \/ Test Loss {test_loss:.3f}')\nprint(f'Train Accuracy {100*train_accuracy:.3f}% \/ Test Accuracy {100*test_accuracy:.3f}%')\n\nprint('\\nBenchmark model')\ntrain_loss, train_accuracy = eval_model(benchmark_model, train_loader, device=DEVICE)\ntest_loss, test_accuracy = eval_model(benchmark_model, test_loader, device=DEVICE)\nprint(f'Train Loss {train_loss:.3f} \/ Test Loss {test_loss:.3f}')\nprint(f'Train Accuracy {100*train_accuracy:.3f}% \/ Test Accuracy {100*test_accuracy:.3f}%')","3c7a82c5":"###  Run me!\n","dc211d30":"### Evaluation\n\nWe _finally_ can evaluate and compare the performance of the models on previously unseen examples. \n\nWhich model would you keep? (\\*drum roll*)    ","b771ed02":"---\n# Section 2: Case study: successfully training an MLP for image classification\n\n*Time estimate: ~40 mins*","320931e2":" Execute this cell to enable the widget!\n","972d9d13":"So far we have used only a small (fixed) subset of 500 training examples to perform the updates on the model parameters in our quest to minimize the loss. But what if we decided to use the training set? Do our current approach scale to datasets with tens of thousands, or millions of datapoints?\n\nIn this section we explore an efficient alternative to avoid having to perform computations on all the training examples before performing a parameter update.","6c26b23c":"### **Discussion**\n\nTune the 3 methods above in order to make each individually excel and discuss your findings. How do the methods compare in terms of robustness to small changes of the hyperparameters? How easy was it to find a good hyperparameter configuration? ","f5919eef":"---\n# Section 6: Full gradients are expensive\n\n*Time estimate: ~25 mins*","97758989":"## Coding Exercise 6: Implement minibatch sampling\n\nComplete the code in `sample_minibatch` so as to produce IID subsets of the training set of the desired size. (This is _not_ a trick question.) ","ddb8cd9a":"### Locality of Gradients\nAs we've seen throught this tutorial, poor conditioning can be a significant burden on convergence to an optimum while using gradient based optimization. Of the methods we've seen to deal with this issue, notice how both momentum and adaptive learning rates incorperate past gradient values into their update schemes. Why do we use past values of our loss function's gradient while updating our current MLP weights?\n\nRecall from W1D2 that the gradient of a function, $\\nabla f(w_t)$, is a **local** property and computes the direction of maximum change of $f(w_t)$ at the point $w_t$. However, when we train our MLP model we are hoping to find the __global__ optimum for our training loss. By incorperating past values of our function's gradient into our optimization schemes, we use more information about the overall shape of our function than just a single gradient alone can provide. ","a9e98fd2":"## Section 2.2: Model\n\nAs you will see next week, there are specific model architectures that are better suited to image-like data, such as Convolutional Neural Networks (CNNs). For simplicity, in this tutorial we will focus exclusively on Multi-Layer Perceptron (MLP) models as they allow us to highlight many important optimization challenges shared with more advanced neural network designs.","18bb2f4f":"## Coding Exercise 4: Implement momentum\n\nIn this exercise you will implement the momentum update given by:\n\n\\begin{equation}\nw_{t+1} = w_t - \\eta \\nabla J(w_t) + \\beta (w_t - w_{t-1})\n\\end{equation}\n\nIt is convenient to re-express this update rule in terms of a recursion. For that, we define 'velocity' as the quantity:\n\\begin{equation}\nv_{t-1} := w_{t} - w_{t-1}\n\\end{equation}\n\nwhich leads to the two-step update rule:\n\n\\begin{equation}\nv_t = - \\eta \\nabla J(w_t) + \\beta (\\underbrace{w_t - w_{t-1}}_{v_{t-1}})\n\\end{equation}\n\n\\begin{equation}\nw_{t+1} \\leftarrow w_t + v_{t}\n\\end{equation}\n\nPay attention to the positive sign of the update in the last equation, given the definition of $v_t$, above. ","7da6bacc":"We define an optimizer in the following steps:\n\n1. Load  the corresponding class that implements the parameter updates and other internal management activities, including:\n    - create auxiliary variables,\n    - update moving averages,\n    - adjust learning rate.\n2. Pass the parameters of the Pytorch model that the optimizer has control over. Note that different parameter groups can potentially be controlled by different optimizers.\n3. Specify hyperparameters, including learning rate, momentum, moving average factors, etc.\n\n","5f17d63f":"We illustrate this issue in a 2-dimensional setting. We freeze all but two parameters of the network: one of them is an element of the weight matrix (filter) for class 0, while the other is the bias for class 7. This results in an optimization with two decision variables.\n\nHow much difference is there in the behavior of these two parameters under gradient descent? What is the effect of momentum in bridging that gap?\n","b1702616":"Run the following cell to visualize the content of three examples in our training set. Note how the pre-processing we applied to the data changes the range of pixel values after normalization.\n","0826ece3":" These are the slides for the videos in this tutorial\n","ff6c6dc8":"Already in this 'simple' logistic regression problem, the issue of bad conditioning is haunting us. Not all parameters are created equal and the sensitivity of the network to changes on the parameters will have a big impact in the dynamics of the optimization.\n","3006347b":"Take a couple of minutes to play with a more complex 3D visualization of the loss landscape of a neural network on a non-convex problem. Visit https:\/\/losslandscape.com\/explorer.\n\n1. Explore the features on the bottom left corner. You can see an explanation for each icon by clicking on the [i] button located on the top right corner.\n2. Use the 'gradient descent' feature to perform a thought experiment:\n    -   Choose an initialization\n    -   Choose the learning rate\n    -   Mentally formulate your hypothesis about what kind of trajectory you expect to observe \n3. Run the experiment and contrast your intuition with the observed behavior.\n4. Repeat this experiment a handful of times for several initialization\/learning rate configurations\n","feec46f3":"## Section 2.4: Interpretability","4f37938d":"##  Video 4: Momentum\n","b64e63c7":"###  Student Response\n","60d344ca":"##  Download parameters of the benchmark model\n","38d40309":"###  Student Response\n","56ce923b":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_d69ca8d7.py)\n\n","56e23a48":" Execute this cell to enable the widget!\n","3469bbe9":"---\n# Setup","a5512426":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_ba72f88a.py)\n\n","286f5f41":"## Think! 4: Momentum and oscillations\n\n- Discuss how this specific example illustrates the issue of poor conditioning in optimization? How does momentum help resolve these difficulties?\n\n- Do you see oscillations for any of these methods? Why does this happen?\n\n- Finally, tune the learning rate and momentum parameters to achieve a loss below $10^{-6}$ (for both dimensions) within 100 iterations.","416f8512":"## Exercise Bonus: Train your own model\n\nNow, train the model with your preferred optimizer and find a good combination of hyperparameter settings.","dc034318":"---\n# Section 5: Non-convexity\n\n*Time estimate: ~30 mins*","26fcf859":"---\n# Tutorial Objectives\n\nObjectives:\n*   Necessity and importance of optimization\n*   Introduction to commonly used optimization techniques\n*   Optimization in non-convex loss landscapes \n*   'Adaptive' hyperparameter tuning \n*   Ethical concerns\n\n","5a518ca6":"## Comparing updates\n\nThese plots compare the effectiveness of updating random directions for the problem of optimizing the parameters of a high-dimensional linear model. We contrast the behavior at initialization and during an intermediate stage of training by showing the histograms of change in loss over 100 different random directions vs the changed in loss induced by the gradient descent update\n\n**Remember:** since we are trying to minimize, here negative is better!\n","04d5240a":"## Think! Bonus: Metrics\n\nWhich metric did you optimize when searching for the right configuration? The training set loss? Accuracy? Validation\/test set metrics? Why? Discuss!","16b01d7e":"## Discuss: Unexpected consequences\n\nCan you think of examples from your own experience\/life where poorly chosen incentives or objectives have lead to unexpected consequences?","1a3b0050":"# Tutorial 1: Optimization techniques\n**Week 1, Day 4: Optimization**\n\n**By Neuromatch Academy**\n\n__Content creators:__ Jose Gallego-Posada, Ioannis Mitliagkas\n\n__Content reviewers:__ Piyush Chauhan, Vladimir Haltakov, Siwei Bai, Kelson Shilling-Scrivo\n\n__Content editors:__ Charles J Edelson, Gagana B, Spiros Chavlis\n\n__Production editors:__ Arush Tagade, Spiros Chavlis","411247e0":" Executing `set_seed(seed=seed)` you are setting the seed\n","3ecada72":"<a href=\"https:\/\/colab.research.google.com\/github\/NeuromatchAcademy\/course-content-dl\/blob\/main\/tutorials\/W1D4_Optimization\/student\/W1D4_Tutorial1.ipynb\" target=\"_blank\"><img alt=\"Open In Colab\" src=\"https:\/\/colab.research.google.com\/assets\/colab-badge.svg\"\/><\/a>","7a5d3773":"Many of the core ideas (and tricks) in modern optimization for deep learning can be illustrated in the simple setting of training an MLP to solve an image classification task. In this tutorial we will guide you through the key challenges that arise when optimizing high-dimensional, non-convex$^\\dagger$ problems. We will use these challenges to motivate and explain some commonly used solutions.\n\n**Disclaimer:** Some of the functions you will code in this tutorial are already implemented in Pytorch and many other libraries. For pedagogical reasons, we decided to bring these simple coding tasks into the spotlight and place a relatively higher emphasis in your understanding of the algorithms, rather than the use of a specific library. \n\nIn 'day-to-day' research projects you will likely to rely on the community-vetted, optimized libraries rather than the 'manual implementations' you will write today. In Section 8 you will have a chance to 'put it all together' and use the full power of Pytorch to tune the parameters of an MLP to classify handwritten digits.","006a212f":" _Run this cell_ to visualize the results\n","64816ab7":"```\n The model3 parameters after the update are: \n\nmain.0.weight tensor([[-0.0240,  0.0031,  0.0193,  ...,  0.0316,  0.0297, -0.0198],\n        [-0.0063, -0.0318, -0.0109,  ..., -0.0093,  0.0232, -0.0255],\n        [ 0.0218, -0.0253,  0.0320,  ...,  0.0102,  0.0248, -0.0203],\n        ...,\n        [-0.0027,  0.0136,  0.0089,  ...,  0.0123, -0.0324, -0.0166],\n        [ 0.0159,  0.0281,  0.0233,  ..., -0.0133, -0.0197,  0.0182],\n        [ 0.0186, -0.0376, -0.0205,  ..., -0.0293,  0.0077, -0.0019]])\nmain.0.bias tensor([-0.0313, -0.0011,  0.0122, -0.0342,  0.0045,  0.0199,  0.0329,  0.0265,\n         0.0182, -0.0041])\n```","0d43cf11":"##  Install dependencies\n","1a658e63":"## Interactive Demo 6.1: Cost of computation\n\nEvaluating a neural network is a relatively fast process. However, when repeated millions of times, the computational cost of performing forward and backward passes through the network starts to become significant.\n\nIn the visualization below, we show the time (averaged over 5 runs) of computing a forward and backward pass with a changing number of input examples. Choose from the different options in the drop-down box and note how the vertical scale changes depending on the size of the network. \n\n**Remarks:** Note that the computational cost of a forward pass shows a clear linear relationship with the number of input examples, and the cost of the corresponding backward pass exhibits a similar computational complexity.","58bed8b2":"---\n# Section 4: Poor conditioning\n\n*Time estimate: ~30 mins*","3b55cc61":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_a3f4354b.py)\n\n","6b68d215":"In last lecture, you saw that inspecting the weights of a model can provide insights on what 'concepts' the model has learned. Here we show the weights of a partially trained model. The weights corresponding to each class 'learn' to _fire_ when an input of the class is detected.\n","294a4a91":"```\n The model2 parameters after the update are: \n\nmain.0.weight tensor([[ 1.5898,  0.0116, -2.0239,  ..., -1.0871,  0.4030, -0.9577],\n        [ 0.4653,  0.6022, -0.7363,  ...,  0.5485, -0.2747, -0.6539],\n        [-1.4117, -1.1045,  0.6492,  ..., -1.0201,  0.6503,  0.1310],\n        ...,\n        [-0.5098,  0.5075, -0.0718,  ...,  1.1192,  0.2900, -0.9657],\n        [-0.4405, -0.1174,  0.7542,  ...,  0.0792, -0.1857,  0.3537],\n        [-1.0824,  1.0080, -0.4254,  ..., -0.3760, -1.7491,  0.6025]])\nmain.0.bias tensor([ 0.4147, -1.0440,  0.8720, -1.6201, -0.9632,  0.9430, -0.5180,  1.3417,\n         0.6574,  0.3677])\n```","f6032c63":"###  Student Response\n","108288df":"## Coding Exercise 7: Implement RMSprop\n\nIn this exercise you will implement the update of the RMSprop optimizer:\n\n\\begin{align}\nv_{t} &= \\alpha v_{t-1} + (1 - \\alpha) \\nabla J(w_t)^2 \\\\ \\\\\nw_{t+1} &= w_t - \\eta \\frac{\\nabla J(w_t)}{\\sqrt{v_t + \\epsilon}}\n\\end{align}\n\nwhere the non-standard operations (division of two vectors, squaring a vector, etc) are to be interpreted as element-wise operations, i.e., the operation is applied to each (pair of) entry[ies] of the vector(s) considered as real number(s).\n\nHere, the $\\epsilon$ hyperparameter provides numerical estability to the algorithm, by preventing the learning rate to become too big when $v_t$ is small. Typically, we set $\\epsilon$ to a default small value, like $10^{-8}$.  ","2c101123":"\n**Remarks:** Note that RMSprop is allowing us to use a 'per-dimension' learning rate _without having to tune one learning rate for each dimension **ourselves**_. The method uses information collected about the variance of the gradients throughout training to **adapt** the step size for each of the parameters automatically. The savings in tuning efforts of RMSprop over SGD or 'plain' momentum are undisputed on this task. \n\nMoreover, adaptive optimization methods are currently a highly active research domain, with many related algorithms like Adam, AMSgrad, Adagrad being used in practical application and theoretically investigated. ","b64cff01":"## Section 2.3: Loss\n\nWhile we care about the accuracy of the model, the 'discrete' nature of the 0-1 loss makes it challenging to optimize. In order to learn good parameters for this model, we will use the cross entropy loss (negative log-likelihood), which you saw in last lecture, as a surrogate objective to be minimized. \n\nThis particular choice of model and optimization objective leads to a *convex* optimization problem with respect to the parameters $W$ and $b$. ","e03cc067":"##  Video 8: Ethical concerns\n","02ef6d0a":"---\n# Section 3: High dimensional search\n\n*Time estimate: ~25 mins*","406c32b9":"##  Airtable Submission Link\n","c00cac39":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_1c2b3d1a.py)\n\n","75b8eb85":"$^\\dagger$: A **convex** function has one, global minimum - a nice property, as an optimization algorithm won't get stuck in a local minimum that isn't a global one (e.g., $f(x)=x^2 + 2x + 1$). A **non-convex** function is wavy - has some 'valleys' (local minima) that aren't as deep as the overall deepest 'valley' (global minimum). Thus, the optimization algorithms can get stuck in the local minimum, and it can be hard to tell when this happens (e.g., $f(x) = x^4 + x^3 - 2x^2 - 2x$). See also **Section 5** for more details.","ea4c71c3":"We now have a model with its corresponding trainable parameters as well as an objective to optimize. Where do we go to next? How do we find a 'good' configuration of parameters?\n\nOne idea is to choose a random direction and move only if the objective is reduced. However, this is inefficient in high dimensions and you will see how gradient descent (with a suitable step-size) can guarantee consistent improvement in terms of the objective function.","2f333ad4":"##  Video 7: Adaptive Methods\n","85650d49":"Linear models constitute a very special kind of MLPs: they are equivalent to an MLP with *zero* hidden layers. This is simply an affine transformation, in other words a 'linear' map $W x$ with an 'offset' $b$; followed by a softmax function.\n\n$$f(x) = \\text{softmax}(W x + b)$$\n\nHere $x \\in \\mathbb{R}^{784}$, $W \\in \\mathbb{R}^{10 \\times 784}$ and $b \\in \\mathbb{R}^{10}$. Notice that the dimensions of the weight matrix are $10 \\times 784$ as the input tensors are flattened images, i.e., $28 \\times 28 = 784$-dimensional tensors and the output layer consists of $10$ nodes.","64312c01":"### Think! 5.1: Width and depth of the network\n\n- We see that as we increase the width\/depth of the network, training becomes faster and more consistent across different initializations. What might be the reasons for this behavior? \n\n- What are some potential downsides of this approach to dealing with non-convexity? \n","89d6febe":"###  Download MNIST dataset\n","c9ff2d68":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_2de57667.py)\n\n","8ba5cf41":"## Coding Exercise 3: Implement gradient descent\n\nIn this exercise you will use PyTorch automatic differentiation capabilities to compute the gradient of the loss with respect to the parameters of the model. You will then use these gradients to implement the update performed by the gradient descent method.  ","16628d71":"##  Helper functions\n","43622ced":"####  Student Response\n","f8e22233":"---\n# Bonus: Putting it all together\n\n*Time estimate: ~40 mins*","d29806a4":"##  Figure settings\n","939975f3":"##  Set device (GPU or CPU). Execute `set_device()`\n","445329e7":"##  Video 9: Putting it all together\n","307544a3":"##  Video 1: Introduction\n","d805bac3":"The introduction of even just 1 hidden layer in the neural network transforms the previous convex optimization problem into a non-convex one. And with great non-convexity, comes great responsibility... (Sorry, we couldn't help it!)\n\n**Note:** From this section onwards we will be dealing with non-convex optimization problems for the remaining of the tutorial. ","0ed3fe09":" _Run this cell_ to setup some helper functions.\n","bae002af":"## Interactive Demo 5: Overparametrization to the rescue!\n\nAs you may have seen, the non-convex nature of the surface can lead the optimization process to get stuck in undesirable local-optima. There is ample empirical evidence supporting the claim that 'overparameterized' models are easier to train.\n\nWe will explore this assertion in the context of our MLP training. For this, we initialize a fixed model and construct several models by small random perturbations to the original initialized weights. Now, we train each of these perturbed models and see how the loss evolves. If we were in the convex setting, we should reach very similar objective values upon convergence since all these models were very close at the beginning of training, and in convex problems, every local optimum is also a global optimum.\n\nUse the interactive plot below to visualize the loss progression for these perturbed models:\n\n1. Select different settings from the `hidden_dims` drop-down menu.\n2. Explore the effect of the number of steps and learning rate.","f7392453":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_b8bbba6f.py)\n\n","45371f8a":"## Section 2.1: Data\n\nWe will use the MNIST dataset of handwritten digits. We load the data via the Pytorch `datasets` module, as you learned in W1D1.\n\n**Note:** Although we can download the MNIST dataset directly from `datasets` using the optional argument `download=True`, we are going to download them from NMA directory on OSF to ensure network reliability.\n","f003944f":"**Our 2021 Sponsors, including Presenting Sponsor Facebook Reality Labs**\n\n<p align='center'><img src='https:\/\/github.com\/NeuromatchAcademy\/widgets\/blob\/master\/sponsors.png?raw=True'\/><\/p>","a1144756":"##  Video 6: Mini-batches\n","06aede56":"As of now, you should be aware that there are many knobs to turn when working on a machine learning problem. Some of these relate to the optimization algorithm, to the choice of model, or to the objective to minimize. Here are some prototypical examples:\n\n- Problem: loss function, regularization coefficients (Day 5)\n- Model: architecture, activations function\n- Optimizer: learning rate, batch size, momentum coefficient\n\nWe concentrate on the choices that are directly related with optimization. In particular, we will explore some _automatic_ methods for setting the learning rate, in a way that fixes the poor-conditioning problem and is robust across different problems.","948a5c5b":"##  Video 5: Overparametrization\n","f6900abe":" Execute this cell to enable the widget!\n","f6dbe989":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_5eaa9306.py)\n\n","e0ccccce":" Execute this cell to enable the widget!\n","ed9d30ba":"---\n# Summary\n\n* Optimization is necessary to create Deep Learning models that are guaranteed to converge \n* Stochastic Gradient Descent and Momentum are two commonly used optimization techniques\n* RMSProp is a way of adaptive hyper parameter tuning which utilises a per-dimension learning rate\n* Poor choice of optimization objectives can lead to unforeseen, undesirable consequences \n\nIf you have time left, you can read the Bonus material, were we put all together and we compare our model with a benchmark model.","41d5d025":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_093a66ad.py)\n\n","8e3b153f":"##  Tutorial slides\n","b975c480":"---\n# Section 8: Ethical concerns\n\n*Time estimate: ~15mins*","cd882575":"**Remarks:** SGD works! We have an algorithm that can be applied (with the due precautions) to learn datasets of arbitrary size. \n\nHowever, **note the diference in the vertical scale** across the plots above. When using a larger minibatch, we can perform fewer parameter updates as the forward and backward passes are more expensive.\n\nThis highlights the interplay between the minibatch size and the learning rate: when our minibatch is larger, we have a more confident estimator of the direction to move, and thus can afford a larger learning rate. On the other hand, extremely small minibatches are very fast computationally but are not representative of the data distribution and yield estimations of the gradient with high variance.\n\nWe encourage you to tune the value of the learning rate for each of the minibatch sizes in the previous demo, to achieve a training loss steadily below 0.5 within 5 seconds.","8bcce7d6":"##  Video 3: Optimization of an Objective Function\n","a284724d":"## Interactive Demo 4: Momentum vs. GD\n\nThe plots below show the distance to the optimum for both variables across the two methods, as well as the parameter trajectory over the loss surface.","e6d03a8a":" Run this cell to enable the widget!\n","448a6e6e":"As we are just getting started, we will concentrate on a small subset of only 500 examples out of the 60.000 data points contained in the whole training set.\n\n","9fcb25ff":"##  Set random seed\n","f075490e":"We have progressively built a sophisticated optimization algorithm which is able to deal with a non-convex, poor-conditioned problem concerning tens of thousands of training examples. Now we present _you_ with a small challenge: beat us! :P\n\nYour mission is to train an MLP model that can compete with a benchmark model which we have pre-trained for you. In this section you will be able to use the full Pytorch power: loading the data, defining the model, sampling minibatches as well as Pytorch's **optimizer implementations**. \n\nThere is a big engineering component behind the design of optimizers and their implementation can sometimes become tricky. So unless you are directly doing research in optimization, it's recommended to use an implementation provided by a widely reviewed open-source library.","6d513da1":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_6bf245d5.py)\n\n","6de9dea5":"---\n# Section 1. Introduction\n\n*Time estimate: ~15 mins*","cc63cf36":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D4_Optimization\/solutions\/W1D4_Tutorial1_Solution_b4a7e579.py)\n\n","cc10dcc3":"```\n The model1 parameters after the update are: \n\nmain.0.weight tensor([[-0.0263,  0.0010,  0.0174,  ...,  0.0298,  0.0278, -0.0220],\n        [-0.0047, -0.0302, -0.0093,  ..., -0.0077,  0.0248, -0.0240],\n        [ 0.0234, -0.0237,  0.0335,  ...,  0.0117,  0.0263, -0.0187],\n        ...,\n        [-0.0006,  0.0156,  0.0110,  ...,  0.0143, -0.0302, -0.0145],\n        [ 0.0164,  0.0286,  0.0238,  ..., -0.0127, -0.0191,  0.0188],\n        [ 0.0206, -0.0354, -0.0184,  ..., -0.0272,  0.0098,  0.0002]])\nmain.0.bias tensor([-0.0292, -0.0018,  0.0115, -0.0370,  0.0054,  0.0155,  0.0317,  0.0246,\n         0.0198, -0.0061])\n```","4f860302":"```\nThe input shape is torch.Size([100, 28, 28]) and the target shape is: torch.Size([100])\n```","443db45e":"---\n# Section 7: Adaptive methods\n\n*Time estimate: ~25 mins*","992b2080":"## Interactive Demo 6.2: *Compare* different minibatch sizes\n\nWhat are the trade-offs induced by the choice of minibatch size? The interactive plot below shows the training evolution of a 2-hidden layer MLP with 100 hidden units in each hidden layer. Different plots correspond to a different choice of minibatch size. We have a fixed time budget for all the cases, reflected in the horizontal axes of these plots.","583862bc":"## Think! 7: Loss function and optimization\n\nCan you think of other ways we can incorperate more information about our loss function into our optimization schemes?","7ef5298d":"##  Video 2: Case Study - MLP Classification\n","8ec5c579":"## Think! 3: Gradient descent vs. random search\n\nCompare the behavior of gradient descent and random search based on the histograms above. Is any of the two methods more reliable? How can you explain the changes between behavior of the methods at initialization vs during training?","60ace5ec":"## Interactive Demo 7: Compare optimizers\n\nBelow, we compare your implementations of SGD, momentum and RMSprop. If you have successfully coded all the exercises so far: congrats! You are now *in the know* of some of the most commonly used and powerful tools of optimization for deep learning. "}}