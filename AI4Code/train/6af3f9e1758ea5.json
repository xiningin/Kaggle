{"cell_type":{"0f6c74a0":"code","c405f65a":"code","bbfa4f9f":"code","eb645a14":"code","91dfd842":"code","c067d287":"code","015115b2":"code","9b4bc5f0":"code","10a666a5":"code","519bd198":"code","afa10422":"code","d082dc26":"code","1f716a19":"code","9dc00036":"code","0d733616":"code","4d9f43a2":"code","417acb62":"code","e151792e":"code","d524f574":"code","f823d802":"code","51a6fa48":"code","479b4311":"code","a94df23a":"code","ba208238":"code","d7d3fda0":"code","b73106a9":"code","de78a89d":"code","ef8069d7":"code","a6bac9f7":"code","390f2050":"code","645f7618":"code","7788a725":"code","afbfddd6":"code","bc942114":"code","2467faba":"code","d165b13e":"code","0a58257f":"code","2e511aff":"code","cc3b3cd2":"code","1315c373":"code","2ebb7063":"code","610da6a5":"code","2507dd8a":"code","2df2b737":"code","5ca3475d":"code","b6cd9ff3":"code","14305a29":"code","8565c653":"code","ff560226":"code","79498d24":"code","30687b38":"code","085dc054":"code","130cc698":"code","4cddf558":"code","92486c62":"code","3e4362f6":"code","178930ff":"code","54e0c7e1":"code","55951a56":"code","41b698fb":"code","ede62482":"code","818c565c":"code","c89132a7":"code","9467ea89":"code","4eb1b69e":"code","0f58fff7":"code","84f76a30":"code","812734bc":"code","0f4a5885":"code","27ed8553":"code","82847e0a":"code","fa3d95c7":"code","a0f9160b":"code","0c3f55ef":"code","7c3d87a3":"code","90924dd0":"code","f5678d5c":"code","9bc518d8":"code","0e35da0f":"code","51d33c85":"code","8487fc87":"code","ffd2e2a1":"code","86fccc95":"code","cfe49763":"code","e172d4f2":"code","7a0ff7c7":"code","1cea7fc8":"code","3517b6b0":"code","72ca0156":"code","08035b83":"code","b63f248d":"markdown"},"source":{"0f6c74a0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","c405f65a":"train=pd.read_csv('\/kaggle\/input\/amexpert\/train.csv')\ns=pd.read_csv('\/kaggle\/input\/amexpert\/sample_submission_Byiv0dS.csv')\ncoup_item=pd.read_csv('\/kaggle\/input\/amexpert\/coupon_item_mapping.csv')\ntest=pd.read_csv('\/kaggle\/input\/amexpert\/test_QyjYwdj.csv')\ncomp=pd.read_csv('\/kaggle\/input\/amexpert\/campaign_data.csv')\ntran=pd.read_csv('\/kaggle\/input\/amexpert\/customer_transaction_data.csv')\ndemo=pd.read_csv('\/kaggle\/input\/amexpert\/customer_demographics.csv')\nitem=pd.read_csv('\/kaggle\/input\/amexpert\/item_data.csv')\nprint(train.shape,test.shape,coup_item.shape,comp.shape,tran.shape,demo.shape,item.shape)","bbfa4f9f":"train.head()","eb645a14":"print(train.shape)\ntrain.redemption_status.value_counts()","91dfd842":"print(comp.shape)\ncomp.head()","c067d287":"df=train.append(test,ignore_index=True)\ndf.head()","015115b2":"comp['start_date']=pd.to_datetime(comp['start_date'],format='%d\/%m\/%y',dayfirst=True)\ncomp['end_date']=pd.to_datetime(comp['end_date'],format='%d\/%m\/%y',dayfirst=True)\n\n# comp['start_date_d']=comp['start_date'].dt.day.astype('category')\n# comp['start_date_m']=comp['start_date'].dt.month.astype('category')\n# comp['start_date_y']=comp['start_date'].dt.year.astype('category')\n# comp['start_date_w']=comp['start_date'].dt.week.astype('category')\n\n\n# comp['end_date_d']=comp['end_date'].dt.day.astype('category')\n# comp['end_date_m']=comp['end_date'].dt.month.astype('category')\n# comp['end_date_y']=comp['end_date'].dt.year.astype('category')\n# comp['end_date_w']=comp['end_date'].dt.week.astype('category')\n\n\ncomp['diff_d']=(comp['end_date']-comp['start_date'])\/np.timedelta64(1,'D')\ncomp['diff_m']=(comp['end_date']-comp['start_date'])\/np.timedelta64(1,'M')\ncomp['diff_w']=(comp['end_date']-comp['start_date'])\/np.timedelta64(1,'W')\n\n# comp.drop(['start_date','end_date'],axis=1,inplace=True)","9b4bc5f0":"comp.describe(include='all').T","10a666a5":"comp.head()","519bd198":"df=df.merge(comp,on='campaign_id',how='left')\ndf.head()","afa10422":"for j in ['brand', 'brand_type', 'category']:\n    print(j,item[j].nunique())","d082dc26":"\nfor j in ['brand', 'brand_type', 'category']:\n    item[j]=item[j].astype('category')\n    \ncoup_item=coup_item.merge(item,on='item_id',how='left')\n","1f716a19":"coup_item.coupon_id.nunique()","9dc00036":"coup_item.head(),coup_item.shape","0d733616":"tran=pd.read_csv('\/kaggle\/input\/amexpert\/customer_transaction_data.csv')\ntran['date']=pd.to_datetime(tran['date'],format='%Y-%m-%d')\ntran['date_d']=tran['date'].dt.day.astype('category')\ntran['date_m']=tran['date'].dt.month.astype('category')\ntran['date_w']=tran['date'].dt.week.astype('category')\n\n# tran.drop('date',axis=1,inplace=True)\ntran.head()","4d9f43a2":"tran[tran['quantity']==20]","417acb62":"tran['discount_bin']=tran['coupon_discount'].apply(lambda x: 0 if x>=0 else 1)\ntran['marked_price']=tran['selling_price']-tran['other_discount']-tran['coupon_discount']\ntran['disc_percent']=(tran['marked_price']-tran['selling_price'])\/tran['selling_price']\ntran['price_per_quan']=tran['marked_price']\/tran['quantity']\ntran['marked_by_sale']=tran['marked_price']\/tran['selling_price']\n","e151792e":"tran.columns","d524f574":"tran=tran.merge(coup_item,on='item_id',how='left')\ntran.head()","f823d802":"print(tran.shape)\ntran=tran[tran.duplicated()==False]\nprint(tran.shape,train.shape)\n# --drop it","51a6fa48":"tran.head()","479b4311":"tran=tran.merge(tran.groupby(['customer_id','date']).agg({'coupon_id':'count','item_id':'count','disc_percent':sum}).reset_index()\n                .rename(columns={'coupon_id':'coupon_aquired','item_id':'item_bought','disc_percent':'tot_disc'}),on=['customer_id','date'],how='left')","a94df23a":"tran[(tran['customer_id']==1052) & (tran['coupon_id']==21)]","ba208238":"tran['coupon_to_item']=tran['item_bought']-tran['coupon_aquired']","d7d3fda0":"tran[(tran['customer_id']==413) & (tran['coupon_id']==577)]","b73106a9":"df[(df['customer_id']==413) & (df['coupon_id']==577)]","de78a89d":"# tran.groupby(['customer_id','coupon_id']).agg({'date':set}).reset_index()\ntran.head()","ef8069d7":"def func(a,b,c):\n    if c!=0:\n        c=list(c)\n        v=0\n        for k in c:\n            if a<=k and b>k:\n                v+=1\n        return v\n    else:\n        return 0\n# cc['within']=cc.apply(lambda x: func(x['start_date'],x['end_date'],x['date']),axis=1)","a6bac9f7":"# Magic features\n# tran.groupby(['customer_id','date']).agg({'coupon_id':'count','discount_bin':sum,'quantity':sum,'item_id':'count'}).reset_index()","390f2050":"df.head()","645f7618":"# cc=df.merge(tran.groupby(['customer_id','date']).agg({'coupon_id':'count','discount_bin':sum,'quantity':sum,'item_id':'count'}).reset_index(),on=['customer_id','date'],how='left')\n# cc.sample(10)\ntran.columns","7788a725":"ddf=df.merge(tran.groupby(['customer_id','coupon_id']).agg({'date':set,'discount_bin':sum,'quantity':sum,'item_id':'count',\n                                                            'coupon_aquired':sum,'item_bought':'mean','tot_disc':sum}).reset_index(),on=['customer_id','coupon_id'],how='left')\nddf.sample(10)","afbfddd6":"ddf['coupon_aquired'].fillna(0)","bc942114":"# def new_df(df):\n\nprint(ddf.shape)\nddf['date'].replace(np.nan,0,inplace=True)\nddf['discount_bin'].replace(np.nan,-1,inplace=True)\n# ddf['quantity'].replace(np.nan,0,inplace=True)\n# ddf['item_id'].replace(np.nan,0,inplace=True)\n# df['camp_date_within_count']=ddf.apply(lambda x: func(x['start_date'],x['end_date'],x['date']),axis=1)\n\n\n# df['bin']=ddf['discount_bin'].apply(lambda x: 1 if x!=-1 else 0)\ndf['within_date']=ddf['date'].apply(lambda x: len(x) if x !=0 else 0)\n# df['C1']=ddf['coupon_aquired'].fillna(0)\n# df['C2']=ddf['item_bought'].fillna(0)\n# df['C3']=ddf['tot_disc'].fillna(0)\n\n\n\n\n# df['within_date_discount']=ddf['discount_bin'].apply(lambda x: x if x >=0 else 0)\n#     df['quantity_date']=ddf['quantity']\n# df['item_count']=ddf['item_id']\n\n# -- worked good\n    # df['quantity_date']=ddf['quantity']\n    # df['item_count']=ddf['item_id']\n","2467faba":"ddf.head()","d165b13e":"\n# %time\n# within_date=[]\n# from tqdm import tqdm_notebook as tqdm\n# for i in tqdm(range(df.shape[0])):\n#     st_dt=df.loc[i,'start_date']\n#     en_dt=df.loc[i,'end_date']\n#     cust=df.loc[i,'customer_id']\n#     coup=df.loc[i,'coupon_id']\n# #     temp=tran[(tran['date']>=st_dt) & (tran['date']<en_dt) & (tran['customer_id']==cust) & (tran['coupon_id']==coup)]\n# #     temp=temp[temp.duplicated()==False]\n#     if tran[(tran['date']>=st_dt) & (tran['date']<en_dt) & (tran['customer_id']==cust) & (tran['coupon_id']==coup)].shape[0]>0:\n#         within_date.append(1)\n#     else:\n#         within_date.append(0)\n# #     print(temp.shape,df.loc[i,'redemption_status'])\n\n# df['within_date']=within_date\ntran.columns","0a58257f":"c=['count','nunique']\nn=['mean','max','min','sum','std']\nnn=['mean','max','min','sum','std','quantile']\n# agg_c={'date_d':c,'date_m':c,'date_w':c,'quantity':n,'selling_price':n,'other_discount':n,'coupon_discount':n,'item_id':c,'brand':c,\n#        'category':c,'coupon_id':c,'discount_bin':nn,'marked_price':n,'disc_percent':n,'price_per_quan':n,'brand_type':c,'marked_by_sale':n,\n#        'coupon_aquired':nn, 'item_bought':nn, 'tot_disc':n, 'coupon_to_item':nn}\n\n\nagg_c={'date_d':c,'date_m':c,'date_w':c,'quantity':n,'selling_price':n,'other_discount':n,'coupon_discount':n,'item_id':c,'brand':c,\n       'category':c,'coupon_id':c,'discount_bin':nn,'marked_price':n,'disc_percent':n,'price_per_quan':n,'brand_type':c,'marked_by_sale':n,\n       'coupon_aquired':nn, 'item_bought':nn, 'tot_disc':n, 'coupon_to_item':nn}\ntrans=tran.groupby(['customer_id']).agg(agg_c)\ntrans.head()","2e511aff":"trans.columns=['F_' + '_'.join(col).strip() for col in trans.columns.values]\ntrans.reset_index(inplace=True)\ntrans.head()","cc3b3cd2":"trans.shape","1315c373":"df=df.merge(trans,on=['customer_id'],how='left')\n\n\n# -------to uncomment\n\n# df.head()","2ebb7063":"df['campaign_type']=df['campaign_type'].astype('category')","610da6a5":"# df['campaign_id']=df['campaign_id'].astype('category')\n# df['coupon_id']=df['coupon_id'].astype('category')\n# df['customer_id']=df['customer_id'].astype('category')\n# df['campaign_type']=df['campaign_type'].astype('category')\n\n# df['within_date_discount'].value_counts()","2507dd8a":"df.info()","2df2b737":"df_train=df[df['redemption_status'].isnull()==False].copy()\ndf_test=df[df['redemption_status'].isnull()==True].copy()\n\nprint(df_train.shape,df_test.shape)","5ca3475d":"df_train.merge(df_train.drop(['id','redemption_status'],axis=1).groupby('campaign_id').mean().reset_index(),on='campaign_id',how='left')","b6cd9ff3":"df_train=df_train.merge(df_train.drop(['id','redemption_status'],axis=1).groupby('coupon_id').mean().reset_index(),on='coupon_id',how='left')\ndf_test=df_test.merge(df_test.drop(['id','redemption_status'],axis=1).groupby('coupon_id').mean().reset_index(),on='coupon_id',how='left')\n\n# df_train=df_train.merge(df_train.drop(['id','redemption_status'],axis=1).groupby('coupon_id_x').mean().reset_index(),on='coupon_id_x',how='left')\n# df_test=df_test.merge(df_test.drop(['id','redemption_status'],axis=1).groupby('coupon_id_x').mean().reset_index(),on='coupon_id_x',how='left')\n\n\n\n# df_train=new_df(df_train)\n# print(df_train.shape)\n\n# df_train.head()","14305a29":"df_train[df_train.redemption_status==1]","8565c653":"import seaborn as sns\n%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(15,15))\n\n# sns.heatmap(df_train.corr())","ff560226":"from catboost import CatBoostClassifier,Pool, cv\nfrom lightgbm import LGBMClassifier\nfrom sklearn.model_selection import StratifiedKFold,train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score,confusion_matrix,roc_auc_score","79498d24":"df_train.columns","30687b38":"# X,y=df_train.drop(['id','redemption_status'],axis=1),df_train['redemption_status']\n# Xtest=df_test.drop(['id','redemption_status'],axis=1)\n# col_to_drop=['id','redemption_status','start_date','end_date','F_quantity_min','F_other_discount_max','F_coupon_discount_max','F_discount_bin_min',\n#              'F_disc_percent_min','F_brand_type_nunique','F_marked_by_sale_min','customer_id','campaign_id','coupon_id']\n\ncol_to_drop=['id','redemption_status','start_date','end_date']\n\nX,y=df_train.drop(col_to_drop,axis=1),df_train['redemption_status']\nXtest=df_test.drop(col_to_drop,axis=1)\n\n# X,y=df_train.drop(['id','redemption_status','start_date','end_date','customer_id','coupon_id','campaign_id'],axis=1),df_train['redemption_status']\n# Xtest=df_test.drop(['id','redemption_status','start_date','end_date','customer_id','coupon_id','campaign_id'],axis=1)\n\n# X=pd.get_dummies(X,drop_first=True)\n\n# from sklearn.ensemble import IsolationForest\n# clf = IsolationForest(contamination = 'auto', random_state=1994,behaviour=\"new\",bootstrap=True)\n# clf.fit(X)\n# df_train['iso_out']=clf.predict(X)\n# print(df_train['iso_out'].value_counts())\n\n\n\n\n\n# print(df_train[df_train['iso_out']==1].shape)\n# print(df_train[df_train['iso_out']==-1].shape)","085dc054":"# X['iso_out'].value_counts()\n# X=X[X.iso_out==1].copy()\nprint(X.shape,Xtest.shape)\nX_train,X_val,y_train,y_val = train_test_split(X,y,test_size=0.3,random_state = 1994,stratify=y)","130cc698":"X_train.columns","4cddf558":"col=['campaign_id', 'coupon_id', 'customer_id', 'campaign_type','within_date', 'within_date_discount']","92486c62":"# # for j in col:\n# X_train,X_val,y_train,y_val = train_test_split(X,y,test_size=0.3,random_state = 1994,stratify=y)\n# print('Dropped->',j)\n# X_train.drop(col,inplace=True,axis=1)\n# X_val.drop(col,inplace=True,axis=1)\n# m=LGBMClassifier(n_estimators=1500,random_state=1994,learning_rate=0.03,reg_alpha=0.2,colsample_bytree=0.5,bagging_fraction=0.9)\n# # m=RidgeCV(cv=4)\n# m.fit(X_train,y_train,eval_set=[(X_train,y_train),(X_val, y_val.values)],eval_metric='auc', early_stopping_rounds=100,verbose=200)\n# p=m.predict_proba(X_val)[:,-1]\n\n# print(roc_auc_score(y_val,p))\n# print('---------------------')","3e4362f6":"from scipy.special import logit\nm=LGBMClassifier(n_estimators=1500,random_state=1994,learning_rate=0.03,reg_alpha=0.2,colsample_bytree=0.5,reg_lambda=20)\n# m=RidgeCV(cv=4)\nm.fit(X_train,y_train,eval_set=[(X_train,y_train),(X_val, y_val.values)],eval_metric='auc', early_stopping_rounds=100,verbose=200)\np=m.predict_proba(X_val)[:,-1]\np1=logit(p)\nprint(roc_auc_score(y_val,p))\nprint(roc_auc_score(y_val,p1))","178930ff":"p1","54e0c7e1":"m.feature_importances_","55951a56":"confusion_matrix(y_val,p>0.5)","41b698fb":"sorted(zip(m.feature_importances_,X_train),reverse=True)","ede62482":"err=[]\ny_pred_tot=[]\n\n\nfeature_importance_df = pd.DataFrame()\ngr=X.campaign_id_x.values\nfrom sklearn.model_selection import KFold,StratifiedKFold,GroupKFold\nfold=GroupKFold(n_splits=10)\ni=1\nfor train_index, test_index in fold.split(X,y,gr):\n    X_train, X_test = X.iloc[train_index], X.iloc[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n    m=LGBMClassifier(n_estimators=5000,random_state=1994,learning_rate=0.03,reg_alpha=0.2,colsample_bytree=0.5)\n    m.fit(X_train,y_train,eval_set=[(X_train,y_train),(X_test, y_test)],eval_metric='auc', early_stopping_rounds=200,verbose=200)\n    \n    preds=m.predict_proba(X_test,num_iteration=m.best_iteration_)[:,-1]\n    \n    fold_importance_df = pd.DataFrame()\n    fold_importance_df[\"feature\"] = X_train.columns\n    fold_importance_df[\"importance\"] = m.feature_importances_\n    fold_importance_df[\"fold\"] = i + 1\n    feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n    \n    \n    print(\"err: \",roc_auc_score(y_test,preds))\n    err.append(roc_auc_score(y_test,preds))\n    p = m.predict_proba(Xtest)[:,-1]\n    i=i+1\n    y_pred_tot.append(p)","818c565c":"np.mean(err,0)\n","c89132a7":"all_features = feature_importance_df[[\"feature\", \"importance\"]].groupby(\"feature\").mean().sort_values(by=\"importance\", ascending=False)\nall_features.reset_index(inplace=True)\nimportant_features = list(all_features[0:170]['feature'])\nall_features[0:170]","9467ea89":"df1 = X[important_features]\ncorr_matrix = df1.corr().abs()\n\n# Select upper triangle of correlation matrix\nupper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))\n\n# Find index of feature columns with correlation greater than 0.95\nhigh_cor = [column for column in upper.columns if any(upper[column] > 0.98)]\nprint(len(high_cor))\nprint(high_cor)","4eb1b69e":"features = [i for i in important_features if i not in high_cor]\nprint(len(features))\nprint(features)","0f58fff7":"X=X[features]\nXtest=Xtest[features]","84f76a30":"err=[]\ny_pred_tot=[]\n\n# feature_importance_df = pd.DataFrame()\n\nfrom sklearn.model_selection import KFold,StratifiedKFold\nfold=GroupKFold(n_splits=15)\ni=1\nfor train_index, test_index in fold.split(X,y,gr):\n    X_train, X_test = X.iloc[train_index], X.iloc[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n    m=LGBMClassifier(n_estimators=5000,random_state=1994,learning_rate=0.03,reg_alpha=0.2,colsample_bytree=0.5)\n    m.fit(X_train,y_train,eval_set=[(X_train,y_train),(X_test, y_test)],eval_metric='auc', early_stopping_rounds=200,verbose=200)\n    \n    preds=m.predict_proba(X_test,num_iteration=m.best_iteration_)[:,-1]\n    \n#     fold_importance_df = pd.DataFrame()\n#     fold_importance_df[\"feature\"] = X_train.columns\n#     fold_importance_df[\"importance\"] = m.feature_importances_\n#     fold_importance_df[\"fold\"] = i + 1\n#     feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n    \n    \n    print(\"err: \",roc_auc_score(y_test,preds))\n    err.append(roc_auc_score(y_test,preds))\n    p = m.predict_proba(Xtest)[:,-1]\n    i=i+1\n    y_pred_tot.append(p)","812734bc":"np.mean(err,0)","0f4a5885":"s['redemption_status']=np.mean(y_pred_tot,0)\ns.head()\n","27ed8553":"sum(s.redemption_status>0.5)","82847e0a":"s.to_csv('AV_amex_lgb_folds_v39.csv',index=False)\ns.shape","fa3d95c7":"# print(X.shape,Xtest.shape)\n\n# X_train,X_val,y_train,y_val = train_test_split(X,y,test_size=0.25,random_state = 1994,stratify=y)\n# categorical_features_indices = np.where(X_train.dtypes =='category')[0]\n# categorical_features_indices","a0f9160b":"# m=CatBoostClassifier(n_estimators=2500,random_state=1994,learning_rate=0.03,eval_metric='AUC')\n# # m=RidgeCV(cv=4)\n# m.fit(X_train,y_train,eval_set=[(X_val, y_val.values)], early_stopping_rounds=300,verbose=200,cat_features=categorical_features_indices)\n# p=m.predict_proba(X_val)[:,-1]\n# print(roc_auc_score(y_val,p))\n\n\n# 0:\ttest: 0.7072835\tbest: 0.7072835 (0)\ttotal: 94.6ms\tremaining: 3m 56s\n# 200:\ttest: 0.9846892\tbest: 0.9846892 (200)\ttotal: 6.49s\tremaining: 1m 14s\n# 400:\ttest: 0.9857940\tbest: 0.9857940 (400)\ttotal: 13.1s\tremaining: 1m 8s\n# 600:\ttest: 0.9860940\tbest: 0.9860980 (590)\ttotal: 19.6s\tremaining: 1m 1s\n# 800:\ttest: 0.9861993\tbest: 0.9862259 (737)\ttotal: 25.9s\tremaining: 54.9s\n# 1000:\ttest: 0.9862786\tbest: 0.9863095 (882)\ttotal: 32.2s\tremaining: 48.2s\n# 1200:\ttest: 0.9863154\tbest: 0.9863839 (1056)\ttotal: 38.5s\tremaining: 41.6s\n# 1400:\ttest: 0.9863995\tbest: 0.9864448 (1265)\ttotal: 44.8s\tremaining: 35.1s\n# Stopped by overfitting detector  (300 iterations wait)\n\n# bestTest = 0.9864447541\n# bestIteration = 1265\n\n# Shrink model to first 1266 iterations.\n# 0.9864447540507506","0c3f55ef":"# errCB=[]\n# y_pred_tot_cb=[]\n# from sklearn.model_selection import KFold,StratifiedKFold\n# fold=StratifiedKFold(n_splits=15,shuffle=True,random_state=1994)\n# i=1\n# for train_index, test_index in fold.split(X,y):\n#     X_train, X_test = X.iloc[train_index], X.iloc[test_index]\n#     y_train, y_test = y[train_index], y[test_index]\n#     m=CatBoostClassifier(n_estimators=5000,random_state=1994,eval_metric='AUC',learning_rate=0.03)\n#     m.fit(X_train,y_train,eval_set=[(X_train,y_train),(X_test, y_test)], early_stopping_rounds=200,verbose=200,cat_features=categorical_features_indices)\n#     preds=m.predict_proba(X_test)[:,-1]\n#     print(\"err_cb: \",roc_auc_score(y_test,preds))\n#     errCB.append(roc_auc_score(y_test,preds))\n#     p = m.predict_proba(Xtest)[:,-1]\n#     i=i+1\n#     y_pred_tot_cb.append(p)","7c3d87a3":"# np.mean(errCB,0)","90924dd0":"# s['redemption_status']=np.mean(y_pred_tot_cb,0)\n# s.head()","f5678d5c":"# sum(s.redemption_status>0.5)","9bc518d8":"# s.to_csv('AV_amex_cb_folds_v28.csv',index=False)\n# s.shape","0e35da0f":"# s['redemption_status']=np.mean(y_pred_tot_cb,0)*0.25+np.mean(y_pred_tot,0)*0.75\n# s.head()","51d33c85":"# sum(s.redemption_status>0.5)","8487fc87":"# s.to_csv('AV_amex_stack2_folds_v28.csv',index=False)\n# # s.shape","ffd2e2a1":"# print(X.shape,Xtest.shape)\n\n# X=pd.get_dummies(X,drop_first=True)\n# Xtest=pd.get_dummies(Xtest,drop_first=True)\n\n# X_train,X_val,y_train,y_val = train_test_split(X,y,test_size=0.25,random_state = 1994,stratify=y)\n# categorical_features_indices = np.where(X_train.dtypes =='category')[0]\n# categorical_features_indices","86fccc95":"# from xgboost import XGBClassifier\n\n# errxgb=[]\n# y_pred_tot_xgb=[]\n# from sklearn.model_selection import KFold,StratifiedKFold\n# fold=StratifiedKFold(n_splits=10,shuffle=True,random_state=1994)\n# i=1\n# for train_index, test_index in fold.split(X,y):\n#     X_train, X_test = X.iloc[train_index], X.iloc[test_index]\n#     y_train, y_test = y[train_index], y[test_index]\n#     m=XGBClassifier(n_estimators=5000,random_state=1994,eval_metric='auc',learning_rate=0.03)\n#     m.fit(X_train,y_train,eval_set=[(X_train,y_train),(X_test, y_test)], early_stopping_rounds=200,verbose=200)\n#     preds=m.predict_proba(X_test)[:,-1]\n#     print(\"err_xgb: \",roc_auc_score(y_test,preds))\n#     errxgb.append(roc_auc_score(y_test,preds))\n#     p = m.predict_proba(Xtest)[:,-1]\n#     i=i+1\n#     y_pred_tot_xgb.append(p)","cfe49763":"# np.mean(errxgb,0)","e172d4f2":"# s['redemption_status']=np.mean(y_pred_tot_xgb,0)\n# s.head()","7a0ff7c7":"# s.to_csv('AV_amex_xgb_folds_v28.csv',index=False)\n# s.shape","1cea7fc8":"# s['redemption_status']=(np.mean(y_pred_tot_cb,0)+np.mean(y_pred_tot,0)+np.mean(y_pred_tot_xgb,0))\/3\n# s.head()","3517b6b0":"# s.to_csv('AV_amex_stack3_folds_v28.csv',index=False)","72ca0156":"# s['redemption_status']=np.mean(y_pred_tot_xgb,0)*0.5+np.mean(y_pred_tot,0)*0.5\n# s.head()","08035b83":"# s.to_csv('AV_amex_stack4_folds_v17.csv',index=False)\n# s.shape","b63f248d":"Problem Statement\nPredicting Coupon Redemption\nXYZ Credit Card company regularly helps it\u2019s merchants understand their data better and take key business decisions accurately by providing machine learning and analytics consulting. ABC is an established Brick & Mortar retailer that frequently conducts marketing campaigns for its diverse product range. As a merchant of XYZ, they have sought XYZ to assist them in their discount marketing process using the power of machine learning. Can you wear the AmExpert hat and help out ABC?\n\n \nDiscount marketing and coupon usage are very widely used promotional techniques to attract new customers and to retain & reinforce loyalty of existing customers. The measurement of a consumer\u2019s propensity towards coupon usage and the prediction of the redemption behaviour are crucial parameters in assessing the effectiveness of a marketing campaign.\n\n \nABC\u2019s promotions are shared across various channels including email, notifications, etc. A number of these campaigns include coupon discounts that are offered for a specific product\/range of products. The retailer would like the ability to predict whether customers redeem the coupons received across channels, which will enable the retailer\u2019s marketing team to accurately design coupon construct, and develop more precise and targeted marketing strategies.\n\n \nThe data available in this problem contains the following information, including the details of a sample of campaigns and coupons used in previous campaigns -\n\nUser Demographic Details\nCampaign and coupon Details\nProduct details\nPrevious transactions\nBased on previous transaction & performance data from the last 18 campaigns, predict the probability for the next 10 campaigns in the test set for each coupon and customer combination, whether the customer will redeem the coupon or not?\n\n \n\nDataset Description\nHere is the schema for the different data tables available. The detailed data dictionary is provided next.\n\n\n \n\nYou are provided with the following files in train.zip:\n\ntrain.csv: Train data containing the coupons offered to the given customers under the 18 campaigns\n\nVariable\tDefinition\nid\tUnique id for coupon customer impression\ncampaign_id\tUnique id for a discount campaign\ncoupon_id\tUnique id for a discount coupon\ncustomer_id\tUnique id for a customer\nredemption_status\t(target) (0 - Coupon not redeemed, 1 - Coupon redeemed) \ncampaign_data.csv: Campaign information for each of the 28 campaigns\n\nVariable\tDefinition\ncampaign_id\tUnique id for a discount campaign\ncampaign_type\tAnonymised Campaign Type (X\/Y)\nstart_date\tCampaign Start Date\nend_date\tCampaign End Date \ncoupon_item_mapping.csv: Mapping of coupon and items valid for discount under that coupon\n\nVariable\tDefinition\ncoupon_id\tUnique id for a discount coupon (no order)\nitem_id\tUnique id for items for which given coupon is valid (no order) \ncustomer_demographics.csv: Customer demographic information for some customers\n\nVariable\tDefinition\ncustomer_id\tUnique id for a customer\nage_range\tAge range of customer family in years\nmarital_status\tMarried\/Single\nrented\t0 - not rented accommodation, 1 - rented accommodation\nfamily_size\tNumber of family members\nno_of_children\tNumber of children in the family\nincome_bracket\tLabel Encoded Income Bracket (Higher income corresponds to higher number) \ncustomer_transaction_data.csv: Transaction data for all customers for duration of campaigns in the train data\n\nVariable\tDefinition\ndate\tDate of Transaction\ncustomer_id\tUnique id for a customer\nitem_id\tUnique id for item\nquantity\tquantity of item bought\nselling_price\tSales value of the transaction\nother_discount\tDiscount from other sources such as manufacturer coupon\/loyalty card\ncoupon_discount\tDiscount availed from retailer coupon \nitem_data.csv: Item information for each item sold by the retailer\n\nVariable\tDefinition\nitem_id\tUnique id for item\nbrand\tUnique id for item brand\nbrand_type\tBrand Type (local\/Established)\ncategory\tItem Category \ntest.csv: Contains the coupon customer combination for which redemption status is to be predicted\n\nVariable\tDefinition\nid\tUnique id for coupon customer impression\ncampaign_id\tUnique id for a discount campaign\ncoupon_id\tUnique id for a discount coupon\ncustomer_id\tUnique id for a customer \n*Campaign, coupon and customer data for test set is also contained in train.zip \n\nsample_submission.csv: This file contains the format in which you have to submit your predictions.\n\nTo summarise the entire process:\n\nCustomers receive coupons under various campaigns and may choose to redeem it.\nThey can redeem the given coupon for any valid product for that coupon as per coupon item mapping within the duration between campaign start date and end date\nNext, the customer will redeem the coupon for an item at the retailer store and that will reflect in the transaction table in the column coupon_discount.\n \nEvaluation Metric\nSubmissions are evaluated on area under the ROC curve between the predicted probability and the observed target.\n \n\nPublic and Private Split\nTest data is further randomly divided into Public (40%) and Private data (60%)\nYour initial responses will be checked and scored on the Public data.\nThe final rankings would be based on your private score which will be published once the competition is over.\nHackathon Rules\nSetting the final submission is mandatory. Without a final submission, the submission corresponding to best public score will be taken as final submission\nUse of external datasets is not allowed\nUse of id variable as a part of making predictions is not allowed\nYou can only make 10 submissions per day\nThe code file is mandatory while setting final submission. For GUI based tools, please upload a zip file of snapshots of steps taken by you, else upload code file.\nThe code file uploaded should be pertaining to your final submission.\nNo submission will be accepted after the contest deadline\n "}}