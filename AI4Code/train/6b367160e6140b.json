{"cell_type":{"ef1246b8":"code","b0294de8":"code","f7ab196d":"code","48968be9":"code","0936ef7b":"code","ff1c1350":"code","eaf32cc8":"code","968af2ac":"code","12934690":"code","739e5136":"code","cce9bcb2":"code","dcb5f0b3":"code","d427dd1c":"code","742cae1e":"code","10657691":"code","fbfe6b0b":"code","e715eadc":"code","12b46ff5":"code","a0cc767f":"code","327e631e":"code","ead809b4":"code","a2901d54":"code","095c78c5":"code","d47cdba9":"code","b92b33d0":"code","6e2427cd":"code","7a3799ea":"code","c4d52bd7":"code","aa0a5302":"code","9ce2402d":"code","f91fd10b":"code","45cff81b":"code","6b513e4b":"code","4298e063":"code","e2bbca69":"code","a2dbfe74":"code","dc58bd07":"code","0d2b96b2":"code","f87c31af":"code","16a37a9e":"code","df966010":"code","739895bf":"code","3b1dd15b":"code","cc12b85d":"code","ab690a24":"code","917b9191":"code","597ec9db":"code","ec74ce71":"code","30527773":"code","f186dfa8":"code","61a56f13":"code","df57248e":"code","7715978d":"code","9f9e10a5":"code","0fea8a44":"code","a901a9d9":"code","50f2baa2":"markdown","a9e35c32":"markdown","94871726":"markdown","f58499c2":"markdown","2d0037a0":"markdown","2ad2e556":"markdown","293c5796":"markdown","44c8e109":"markdown","e4173681":"markdown","873bc4f3":"markdown","52ccd4f1":"markdown","aab33c27":"markdown","29261f75":"markdown","a43048eb":"markdown","8348a0fd":"markdown","49374df4":"markdown","03e6f4de":"markdown","1390cb6c":"markdown","7e877ceb":"markdown","2c40ad0a":"markdown","2e8f5ac0":"markdown","fe8394fa":"markdown","6f1ea1cd":"markdown","63ac4435":"markdown","e2fa33c5":"markdown","1d1a343b":"markdown","b4bfc443":"markdown","678f449e":"markdown"},"source":{"ef1246b8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b0294de8":"water_quality = pd.read_csv('\/kaggle\/input\/water-potability\/water_potability.csv')\nwater_quality.head()","f7ab196d":"water_quality.shape","48968be9":"water_quality.isnull().sum() \/ len(water_quality) * 100","0936ef7b":"import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom itertools import product","ff1c1350":"fig, axes = plt.subplots(3, 3, figsize=(10, 10))\n\n\ncolumns = water_quality.columns\n\nindices = product([0, 1, 2], [0, 1, 2])\n\nfor col, idx in zip(columns, indices):\n    sns.histplot(x=col, data=water_quality, kde=True, ax=axes[idx[0], idx[1]], bins=20)","eaf32cc8":"water_quality.ph = water_quality.ph.fillna(water_quality.ph.median())\nwater_quality.Sulfate = water_quality.Sulfate.fillna(water_quality.Sulfate.median())\nwater_quality.Trihalomethanes = water_quality.Trihalomethanes.fillna(water_quality.Trihalomethanes.median())","968af2ac":"water_quality.isnull().sum() \/ len(water_quality) * 100","12934690":"water_quality.describe()","739e5136":"# firstly we use pairplot\n\nsns.pairplot(water_quality, hue='Potability')","cce9bcb2":"var = 'Solids'\nsns.boxplot(x='Potability', y=var, data=water_quality)","dcb5f0b3":"var = 'Hardness'\nsns.boxplot(x='Potability', y=var, data=water_quality)","d427dd1c":"var = 'Conductivity'\nsns.boxplot(x='Potability', y=var, data=water_quality)","742cae1e":"# set the num of 99.5% quantile of Solids\noutfilters_of_Solids = water_quality.Solids.quantile(0.995).tolist()\n\nwater_quality_without_outfilters_of_Solids = water_quality.copy()\nwater_quality_without_outfilters_of_Solids = water_quality_without_outfilters_of_Solids.query('Solids <= @outfilters_of_Solids')","10657691":"var = 'Solids'\nsns.boxplot(x='Potability', y=var, data=water_quality_without_outfilters_of_Solids)","fbfe6b0b":"# set the num of 99.5% quantile of Hardness\noutfilters_of_left = water_quality_without_outfilters_of_Solids.Hardness.quantile(0.005).tolist()\noutfilters_of_right = water_quality_without_outfilters_of_Solids.Hardness.quantile(0.995).tolist()\n\n\nwater_quality_without_outfilters_of_Solids = water_quality_without_outfilters_of_Solids.query('@outfilters_of_left <= Hardness <= @outfilters_of_right')","e715eadc":"var = 'Hardness'\nsns.boxplot(x='Potability', y=var, data=water_quality_without_outfilters_of_Solids)","12b46ff5":"# set the num of 99.9% quantile of Conductivity\n# we can't cut over 5% because we have to keep quality and quantity as possible\noutfilters_of_Conductivity = water_quality_without_outfilters_of_Solids.Conductivity.quantile(0.999).tolist()\n\nwater_quality_without_outfilters = water_quality_without_outfilters_of_Solids.query('Conductivity <= @outfilters_of_Conductivity')","a0cc767f":"var = 'Conductivity'\nsns.boxplot(x='Potability', y=var, data=water_quality_without_outfilters)","327e631e":"water_quality_without_outfilters.shape","ead809b4":"water_quality_without_outfilters.describe()","a2901d54":"(water_quality.shape[0] - water_quality_without_outfilters.shape[0]) \/ water_quality.shape[0] * 100","095c78c5":"# set the num of 99.5% quantile of Solids\noutfilters_of_Solids_left = water_quality.Solids.quantile(0.003).tolist()\noutfilters_of_Solids_right = water_quality.Solids.quantile(0.997).tolist()\n\nwater_quality_without_outfilters_of_Solids = water_quality.copy()\nwater_quality_without_outfilters_of_Solids = water_quality_without_outfilters_of_Solids.query('@outfilters_of_Solids_left <= Solids <= @outfilters_of_Solids_right')","d47cdba9":"var = 'Solids'\nsns.boxplot(x='Potability', y=var, data=water_quality_without_outfilters_of_Solids)","b92b33d0":"# set the num of 99.5% quantile of Hardness\noutfilters_of_left = water_quality_without_outfilters_of_Solids.Hardness.quantile(0.003).tolist()\noutfilters_of_right = water_quality_without_outfilters_of_Solids.Hardness.quantile(0.995).tolist()\n\n\nwater_quality_without_outfilters_of_Hardness = water_quality_without_outfilters_of_Solids.query('@outfilters_of_left <= Hardness <= @outfilters_of_right')","6e2427cd":"var = 'Hardness'\nsns.boxplot(x='Potability', y=var, data=water_quality_without_outfilters_of_Hardness)","7a3799ea":"# set the num of 99.9% quantile of Conductivity\n# we can't cut over 5% because we have to keep quality and quantity as possible\noutfilters_of_Conductivity = water_quality_without_outfilters_of_Hardness.Conductivity.quantile(0.999).tolist()\n\nwater_quality_without_outfilters = water_quality_without_outfilters_of_Hardness.query('Conductivity <= @outfilters_of_Conductivity')","c4d52bd7":"var = 'Conductivity'\nsns.boxplot(x='Potability', y=var, data=water_quality_without_outfilters)","aa0a5302":"(water_quality.shape[0] - water_quality_without_outfilters.shape[0]) \/ water_quality.shape[0] * 100","9ce2402d":"water_quality_without_outfilters.describe()","f91fd10b":"from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.decomposition import PCA\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import StackingClassifier\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.metrics import accuracy_score","45cff81b":"data = water_quality_without_outfilters.copy()","6b513e4b":"scaler = StandardScaler()","4298e063":"X = data.drop('Potability', axis=1).values\ny = data.copy()['Potability']\n\nX_scaled = scaler.fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, stratify=y)","e2bbca69":"estimators = [\n   ('rf', RandomForestClassifier(n_estimators=100)),\n   ('pipeline', Pipeline([\n                        ('pca', PCA(n_components=2)),\n                        ('lr', LogisticRegression(max_iter=500))\n                    ])\n   )\n]\n\n\n\nstack = StackingClassifier(estimators=estimators, \n                           final_estimator=LogisticRegression(max_iter=1000))\n\nscores = cross_val_score(estimator=stack,\n                        X=X_train, y=y_train,\n                        cv=10, scoring='accuracy')\n\nnp.mean(scores)","a2dbfe74":"estimators = [\n   ('rf', RandomForestClassifier(n_estimators=100)),\n   ('pipeline', Pipeline([\n                        ('pca', PCA(n_components=2)),\n                        ('lr', LogisticRegression(max_iter=500))\n                    ])\n   )\n]\n\n\n\nstack = StackingClassifier(estimators=estimators, \n                           final_estimator=LogisticRegression(max_iter=1000))\n\nscores = cross_val_score(estimator=stack,\n                        X=X_train, y=y_train,\n                        cv=10, scoring='roc_auc')\n\nnp.mean(scores)","dc58bd07":"from sklearn.ensemble import AdaBoostClassifier\n\n\ntree = DecisionTreeClassifier(max_depth=None, criterion='entropy')\n\nada = AdaBoostClassifier(base_estimator=tree,  n_estimators=1000, learning_rate=0.1)\n\n\nscores = cross_val_score(estimator=ada,\n                        X=X_train, y=y_train,\n                        cv=10, scoring='roc_auc')\n\nnp.mean(scores)","0d2b96b2":"stack.fit(X_train, y_train)\n\ny_pred = stack.predict(X_test)\n\naccuracy_score(y_true=y_test, y_pred=y_pred)","f87c31af":"water_quality = pd.read_csv('\/kaggle\/input\/water-potability\/water_potability.csv')\nwater_quality.head()","16a37a9e":"water_quality['Trihalomethanes'] = water_quality['Trihalomethanes'].fillna(water_quality['Trihalomethanes'].median())","df966010":"# check\nwater_quality['Trihalomethanes'].isnull().sum()","739895bf":"X_for_null = water_quality.dropna().drop(['Potability', 'Sulfate', 'ph'], axis=1).values\ny_ph = water_quality.dropna().ph.values\n\nscaler = StandardScaler()\nX_for_null_scaled = scaler.fit_transform(X_for_null)\n\nX_for_null_train, X_for_null_test, y_ph_train, y_ph_test = train_test_split(X_for_null_scaled, y_ph, test_size=0.2)","3b1dd15b":"X_for_null = water_quality.dropna().drop(['Potability', 'Sulfate', 'ph'], axis=1).values\ny_ph = water_quality.dropna().ph.values.reshape(-1, 1)\n\nscaler = StandardScaler()\nX_for_null_scaled = scaler.fit_transform(X_for_null)\n\nscaler = StandardScaler()\ny_ph = scaler.fit_transform(y_ph)\n\nX_for_null_train, X_for_null_test, y_ph_train, y_ph_test = train_test_split(X_for_null_scaled, y_ph, test_size=0.2)","cc12b85d":"from sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import KFold\n\n\nmodel = LinearRegression()\n\nkfold = KFold(n_splits=5).split(X_for_null_train, y_ph_train)\n\nscores = []\nfor train, test in kfold:\n    model.fit(X_for_null_train[train], y_ph_train[train])\n    \n    score = model.score(X_for_null_train[test], y_ph_train[test])\n    \n    scores.append(score)\n    \n\n# mean the cross validation scores!\nnp.mean(scores)","ab690a24":"water_quality_ffill = water_quality.copy()\nwater_quality_ffill = water_quality_ffill.sort_values('ph')\nwater_quality_ffill.ph = water_quality_ffill.ph.fillna(method='ffill')\n\nwater_quality_ffill = water_quality_ffill.sort_values('Sulfate')\nwater_quality_ffill.Sulfate = water_quality_ffill.Sulfate.fillna(method='ffill')\n\nwater_quality_ffill.isnull().sum()","917b9191":"# set the num of 99.5% quantile of Solids\noutfilters_of_Solids_left = water_quality_ffill.Solids.quantile(0.003).tolist()\noutfilters_of_Solids_right = water_quality_ffill.Solids.quantile(0.997).tolist()\n\nwater_quality_without_outfilters_of_Solids = water_quality_ffill.copy()\nwater_quality_without_outfilters_of_Solids = water_quality_without_outfilters_of_Solids.query('@outfilters_of_Solids_left <= Solids <= @outfilters_of_Solids_right')","597ec9db":"# set the num of 99.5% quantile of Hardness\noutfilters_of_left = water_quality_without_outfilters_of_Solids.Hardness.quantile(0.003).tolist()\noutfilters_of_right = water_quality_without_outfilters_of_Solids.Hardness.quantile(0.995).tolist()\n\n\nwater_quality_without_outfilters_of_Hardness = water_quality_without_outfilters_of_Solids.query('@outfilters_of_left <= Hardness <= @outfilters_of_right')","ec74ce71":"# set the num of 99.9% quantile of Conductivity\n# we can't cut over 5% because we have to keep quality and quantity as possible\noutfilters_of_Conductivity = water_quality_without_outfilters_of_Hardness.Conductivity.quantile(0.999).tolist()\n\nwater_quality_without_outfilters = water_quality_without_outfilters_of_Hardness.query('Conductivity <= @outfilters_of_Conductivity')","30527773":"scaler = StandardScaler()\n\nX = water_quality_without_outfilters.drop('Potability', axis=1).values\ny = water_quality_without_outfilters['Potability']\n\nX_scaled = scaler.fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, stratify=y)","f186dfa8":"estimators = [\n   ('rf', RandomForestClassifier(n_estimators=100)), \n   ('tree', DecisionTreeClassifier(max_depth=1)), \n   ('pipeline', Pipeline([\n                        ('pca', PCA(n_components=2)),\n                        ('lr', LogisticRegression(max_iter=500))\n                    ])\n   )\n]\n\n\n\nstack = StackingClassifier(estimators=estimators, \n                           final_estimator=LogisticRegression(max_iter=1000))\n\nscores = cross_val_score(estimator=stack,\n                        X=X_train, y=y_train,\n                        cv=10, scoring='accuracy')\n\nnp.mean(scores)","61a56f13":"for key in stack.get_params().keys():\n    print(key)","df57248e":"from sklearn.model_selection import RandomizedSearchCV\n\nestimators = [\n   ('rf', RandomForestClassifier()), \n   ('tree', DecisionTreeClassifier()), \n   ('pipeline', Pipeline([\n                        ('pca', PCA(n_components=2)),\n                        ('lr', LogisticRegression(max_iter=500))\n                    ])\n   )\n]\n\n\n\nstack = StackingClassifier(estimators=estimators, \n                           final_estimator=LogisticRegression(max_iter=1000))\n\nscores = cross_val_score(estimator=stack,\n                        X=X_train, y=y_train,\n                        cv=10, scoring='accuracy')\n\nnp.mean(scores)\n\n\nparam_dist = {'pipeline__lr__C': np.arange(0.01, 10), \n              'tree__max_depth':[1, 2, 3, None], \n              'tree__criterion': ['gini', 'entropy'], \n              'rf__max_depth':[1, 2, 3, None], \n              'final_estimator__C': np.arange(0.01, 10),\n              'tree__max_features': range(1, 5)\n             }\n\n\nrand_search = RandomizedSearchCV(estimator=stack, param_distributions=param_dist, cv=5)\nrand_search.fit(X_train, y_train)\n\nrand_search.best_score_","7715978d":"rand_search.best_params_","9f9e10a5":"rand_search.score(X_test,y_test)","0fea8a44":"from sklearn.preprocessing import MinMaxScaler\n\n\nscaler = MinMaxScaler()\n\nX = water_quality_without_outfilters.drop('Potability', axis=1).values\ny = water_quality_without_outfilters['Potability']\n\nX_scaled = scaler.fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, stratify=y)\n\n# we use the previous best param\nestimators = [\n   ('rf', RandomForestClassifier(max_depth=None)), \n   ('tree', DecisionTreeClassifier(max_features=2, max_depth=1, criterion='entropy')), \n   ('pipeline', Pipeline([\n                        ('pca', PCA(n_components=2)),\n                        ('lr', LogisticRegression(max_iter=500, C=9))\n                    ])\n   )\n]\n\nstack = StackingClassifier(estimators=estimators, \n                           final_estimator=LogisticRegression(max_iter=1000, C=3))\n\nscores = cross_val_score(estimator=stack,\n                        X=X_train, y=y_train,\n                        cv=10, scoring='accuracy')\n\nnp.mean(scores)","a901a9d9":"from sklearn.model_selection import StratifiedKFold\n\nstack.fit(X_train, y_train)\n\ny_pred = stack.predict(X_test)\naccuracy_score(y_true=y_test, y_pred=y_pred)","50f2baa2":"#### let's cut the outfilters again and then predict!!!!","a9e35c32":"#### It looks nearly above stacking model","94871726":"#### I think we cut the bottom of 0.5% and top of 0.5% because the distance from start to 25% quantile and from 75% quantile to last","f58499c2":"#### recheck how many outfilters we've cut","2d0037a0":"I think we barely save the quality and quantity??, haha","2ad2e556":"#### We have still outfilters in Solids\n#### so We check whether we can continue to cut down those outfilters aspect of the amount of cut samples","293c5796":"### first, we try to predict ph by columns without Potability and Sulfate\n#### and we use Linear Regression first.","44c8e109":"#### What!! this is quit bad...\n#### so, we can't predict enough..","e4173681":"#### Well, It's higer than my last stacking models\n#### so, why don't we use adaboost??","873bc4f3":"### Second, we use the fillna's method 'ffill'","52ccd4f1":"#### all right..\n\n#### for the moment, we predict test data!","aab33c27":"#### so, this score got a little worse, so we try to change the scale instead of standardscaler\n#### we replace the minmax","29261f75":"#### I try 2nd task\nhttps:\/\/www.kaggle.com\/adityakadiwal\/water-potability\/tasks?taskId=4773\n\nEDA for water potability","a43048eb":"### Let's go back to the filling null part.\n\n#### We know the 'ph' and 'Sulfate' null rates are more than 10%, so we rethink how to fill and what we should fill with!","8348a0fd":"#### still not be enough but we have to check the best param","49374df4":"#### so, finally we predict the test data and check acc","03e6f4de":"### Well, still not be enough acc but it's more accurate than my last prediction (which scores 0.625...)","1390cb6c":"### We can't find out pair of values which have high correlation.\n\n#### but some values look different from each Potability","7e877ceb":"I've done the 1st task (if I think up something I will modify the code..)\n\nhttps:\/\/www.kaggle.com\/yutotsubaki\/water-quality-1st-task-to-train","2c40ad0a":"#### I think Trihalomethanes' null can be filled with mean (or median).\n\n#### so, we try to fill 'ph' and 'Sulfate' null with predictions!","2e8f5ac0":"### So, We retry to predict this data!!","fe8394fa":"### we try to tune the best param to use RandimizeSearch","6f1ea1cd":"well, we've cut over 1%...\n\n#### We cut outfilters again from first and adjust the percentage..","63ac4435":"We have to recheck the number of null","e2fa33c5":"#### of course, that's worse..","1d1a343b":"### Conclusion for the moment.\n\n#### I think we have to use deep learning if we want to get more accuracy\n#### and this time, we had better use median to fill null and cut some outfilters!","b4bfc443":"#### This time We have to do EDA for water potability","678f449e":"last time, I fill the null with mean, but this time I fill them with Median"}}