{"cell_type":{"d75ba81b":"code","b5af8d4c":"code","eb8eb9fa":"code","7c97851d":"code","ad3954f5":"code","eb6fbb2b":"code","5dca333b":"code","df8d20d3":"markdown","d87e6b10":"markdown","aff83c9e":"markdown","c32ad6bc":"markdown","aa15ee67":"markdown","5670d6be":"markdown","cd4f5f1a":"markdown"},"source":{"d75ba81b":"import numpy as np\nimport random\nimport cv2\nimport os\nimport matplotlib.pyplot as plt\nimport pickle","b5af8d4c":"def upscale(img, scale=2):\n    arr = np.zeros((img.shape[0] * scale, img.shape[1] * scale))\n    filt = np.ones((scale, scale))\n    # print(filt)\n    for i in range(0, img.shape[0]):\n        for j in range(0, img.shape[1]):\n            arr[i * scale:i * scale + filt.shape[0], j *\n                scale: j * scale + filt.shape[1]] = filt * img[i, j]\n    return arr","eb8eb9fa":"!mkdir vis","7c97851d":"# Generating some random colors for later mapping because I don't know any other way\ncolor = np.random.randint(0, 255, (20, 3))\ncolor[0] = [0, 0, 0]\ncolor[-1] = [220,220,220] #Placeholder colour\n\ndef plot_images(arr1, arr2):\n    # arr1 is array of inputs and arr2 is for outputs\n    for i in range(len(arr1)):\n        t1 = np.array(arr1[i]) \n        t2 = np.array(arr2[i]) \n\n        t1 = np.array(t1)\n        t2 = np.array(t2)\n\n        max0 = max([t1.shape[0], t2.shape[0]])\n        max1 = max([t1.shape[1], t2.shape[1]])\n        to1 = np.zeros((max0, max1))-1 #using empty places as placeholders\n        to2 = np.zeros((max0, max1))-1\n        cx = max0 \/ 2\n        cy = max1 \/ 2\n\n        to1[round(cx - round(t1.shape[0] \/ 2)):round(cx - round(t1.shape[0] \/ 2)) + (t1.shape[0]),\n            round(cy - round(t1.shape[1] \/ 2)):round(cy - round(t1.shape[1] \/ 2)) + (t1.shape[1]) ] = t1\n        to2[round(cx - round(t2.shape[0] \/ 2)):round(cx - round(t2.shape[0] \/ 2)) + (t2.shape[0]),\n            round(cy - round(t2.shape[1] \/ 2)):round(cy - round(t2.shape[1] \/ 2)) + (t2.shape[1])] = t2\n\n        to1 = upscale(to1, 10) # upscaled 10 times, for normal viewing, like in a folder, I prefer 20\n        to2 = upscale(to2, 10)\n\n        to1 = np.array([np.array([color[int(k)] for k in j]) for j in to1.tolist()])\n        to2 = np.array([np.array([color[int(k)] for k in j]) for j in to2.tolist()])\n\n        cv2.imwrite('vis\/' + str(i) + '.png', np.hstack([to1,np.ones((to1.shape[0],2,3))*255,to2]))\n        if i%50 == 0:\n            print(\"written \"+str(i))\n","ad3954f5":"train_data = pickle.loads(\n    open(r'..\/input\/arc-dataset-pickle-format\/separated_pickle\/train_data_sep.pickle', 'rb').read())","eb6fbb2b":"plot_images(train_data['train_ip'], train_data['train_op'])","5dca333b":"for idx,i in enumerate(list(os.listdir('vis'))):\n    if idx%10 == 0:\n        img = cv2.imread('vis\/'+i)\n        plt.imshow(img)\n        plt.show()","df8d20d3":"### The function that will save the images","d87e6b10":"### Upscaling function, to save upscaled images\nI tried different ways to resize image in opencv like INTER_NEAREST and stuff, but all gave same outputs, which is without replicating a pixel, like done for pixel-art","aff83c9e":"## Some necessary functions\nThese may be (probably are) very inefficient and I would like to know any way I can improve performance or method","c32ad6bc":"## Import necessary stuff","aa15ee67":"### Load the data\nI have saved the data as pickle files, so that I don't need to use JSON files every time. These are ofcourse only for visualization and are not separated based on different tasks.","5670d6be":"# Visualizing the data as pairs and storing for later reference\nIn this kernel, I have tried to show the way I have visualized the data, this gives a better undersanding of the task at hand","cd4f5f1a":"## Visualizing\nHere, the left part is the input and the right part is the output, separated by a white line in the center. The smaller shaped inputs or outputs are padded by grey."}}