{"cell_type":{"d6df68c0":"code","4c9124ab":"code","af02130e":"code","705b743c":"code","e647672d":"code","cc8f13f6":"code","a1314345":"code","407d2863":"code","889636a8":"markdown","bf979fe5":"markdown","ed75b937":"markdown","4543e985":"markdown","d2c697e9":"markdown","46cc266c":"markdown"},"source":{"d6df68c0":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt","4c9124ab":"D=pd.read_csv(\"\/kaggle\/input\/rps-competition-games-info\/rps.csv\")\n\nD=D.query(\"Player1 != Player2\")\nD[\"round\"]=D[\"Rounds\"].str.extract(\"round: ([0-9]+)\")\nD.dropna(subset=[\"Movement1\", \"Movement2\"], inplace=True)  # no idea why some are NA\nD[\"outcome\"]=D[\"Movement1\"].sub(D[\"Movement2\"]).mod(3).map({0:0,1:1,2:-1})\nD","af02130e":"# for simplicity we take the highest score for each player to determine the ranking\nplayer_scores = pd.concat([D.groupby(\"Player1\")[\"P1UpdateScore\"].max(), D.groupby(\"Player2\")[\"P2UpdateScore\"].max()], axis=1).max(axis=1)\nplayer_scores","705b743c":"from scipy.stats.distributions import chi2\n\ndef block_freq(seq, block_size=30, round_var=2\/3):\n    seq=list(seq)\n    blocks=[seq[i*block_size:(i+1)*block_size] for i in range(len(seq)\/\/block_size)]\n    block_sums=list(map(np.sum, blocks))\n    block_sum_var=np.var(block_sums)\n    n=len(blocks)\n    pval=chi2.cdf(block_sum_var*(n-1)\/(round_var*block_size), df=n-1)\n    if pval > 0.5:\n        pval = 1 - pval  # two-sided?!\n    return pval","e647672d":"from cytoolz import partition\n\n# Test on real random numbers; should be rather uniform distribution\npvals = [block_freq(np.random.randint(-1, 2, size=1000)) for _ in range(10000)]\n\nnum_games=30\nmean_min_pval = np.mean([np.min(random_player_pvals) for random_player_pvals in partition(num_games, pvals)])\nprint(f\"Average minimum p-value for a random player with {num_games} games: {mean_min_pval:.3g}\")\n\nplt.hist(pvals, bins=\"doane\");\n\n","cc8f13f6":"# Calculate min block freq p-values for all players\nplayer_min_pval = pd.concat([D.groupby([col, \"Game\"])[\"outcome\"].apply(block_freq).groupby(col).min() for col in [\"Player1\", \"Player2\"]], axis=1).min(axis=1)\nplayer_min_pval","a1314345":"import warnings\nwarnings.filterwarnings(\"ignore\")\n\nplayer_randomness = player_min_pval.loc[player_scores.sort_values().index].pipe(lambda d:d.rename(index={name: f\"{i}. {name}\" for i, name in zip(reversed(range(1, len(d)+1)), d.index)}))\nplayer_randomness.plot.barh(figsize=(5, 0.2 * len(player_min_pval)))\nplt.xlim(0, 0.2)\nplt.axvline(mean_min_pval);\n\n# If a player has won at least once convincingly, the minimum p-value should be very small\n# Players with high p-values can be random\n# It's meaningless how big the p-values are, though, if they are above some threshold\n# But remember that algorithms may seem random, too, when they face a tough opponent","407d2863":"# same for overview\nplayer_randomness.iloc[::-1].plot.bar(figsize=(30,5));","889636a8":"# Calculate minimum p-values on all game outcomes for each player","bf979fe5":"# Plot randomness score","ed75b937":"# Test for randomness","4543e985":"# Validate test on real random numbers","d2c697e9":"This notebook attempts to identify random bots in the leaderboard. It uses a block frequency test on the game outcome.\n\nPlease check and comment! Any other methods to try?\n\nThe conclusion seems to be that there may be 1 or 2 random bots in the top 100, but overall all bots in the top 100 are legit.\nHowever, just below position 100 a lot of randomness seems to be going on.\n\nNote, that an algorithmic bot can seem random, too, when it faces random or a strong bot. And here only one particular test is performed.","46cc266c":"# Load and clean data"}}