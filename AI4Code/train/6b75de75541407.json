{"cell_type":{"ec9fa8f6":"code","92372241":"code","f46147bc":"code","de8315bc":"code","bd7e25d3":"code","3751ad59":"code","e8a962b6":"code","a0cfd989":"code","9d6ddd18":"code","5b87e817":"code","32757bb4":"code","50328474":"code","df18f031":"code","03593435":"code","3b4401a7":"code","6527299c":"code","f8b403d2":"code","8ffc2080":"code","a1068b4f":"code","16789482":"code","ef80e394":"code","61040ff3":"code","70ba24d7":"code","2583de56":"code","4ac73433":"code","d0bc8241":"code","574ea65e":"code","a622a57d":"code","056e15ae":"code","ca0d6617":"code","7f3d2175":"code","640a2931":"code","96078f8a":"code","3c64410f":"code","d7a34eb3":"code","93699c26":"code","19cfc3b4":"markdown","c754cd75":"markdown","badcaf48":"markdown","637d7b53":"markdown","bfda6e5f":"markdown","d735f841":"markdown","4888a4b6":"markdown","acf13ef9":"markdown","6452703c":"markdown"},"source":{"ec9fa8f6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport plotly.express as px\nimport seaborn as sns\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","92372241":"df_train = pd.read_csv('\/kaggle\/input\/ventilator-pressure-prediction\/train.csv')\ndf_train.head()","f46147bc":"df_test = pd.read_csv('\/kaggle\/input\/ventilator-pressure-prediction\/test.csv')\ndf_test.head()","de8315bc":"df_train.describe(include='all')","bd7e25d3":"df_train.nunique()","3751ad59":"df_train[df_train['u_out'] == 0].groupby(['C', 'R'])[['time_step', 'u_in', 'pressure']].agg(['mean', 'max', 'min', 'std'])","e8a962b6":"df_train.query('id < 500').plot.line(x='id', y=['pressure', 'u_in'])","a0cfd989":"# this breath_id represents an experiment on oscillation\ndf_train.query('breath_id == 928 and id < 46910').plot.line(x='id', y=['pressure', 'u_in'])","9d6ddd18":"(df_train\n .query('breath_id == 928 and id < 46910')\n .assign(u_in_shift_1=lambda x: x['u_in'].shift(1),\n         u_in_shift_2=lambda x: x['u_in'].shift(2),\n         u_in_shift_3=lambda x: x['u_in'].shift(3))\n .plot.line(x='id', y=['pressure', 'u_in', 'u_in_shift_1', 'u_in_shift_2', 'u_in_shift_3'], figsize=(15, 8)))","5b87e817":"(df_train\n .query('u_out == 0')[['u_in', 'pressure']]\n .assign(u_in_shift_1=lambda x: x['u_in'].shift(1),\n         u_in_shift_2=lambda x: x['u_in'].shift(2),\n         u_in_shift_3=lambda x: x['u_in'].shift(3))\n .corr())","32757bb4":"delta_lags_path = '\/kaggle\/working\/df_delta_lags.parquet'\nos.path.exists(delta_lags_path)","50328474":"#os.remove(delta_lags_path)","df18f031":"# We'll create different sizes for the Delta window (pressure and flow)\nsteps = range(0, 10)\n# And diffferent lags for Delta P\nlags_pressure = range(0, 5)","03593435":"if os.path.exists(delta_lags_path):\n    df_ = pd.read_parquet(delta_lags_path)\nelse:\n    # only analyse the inspiratory phase\n    df_ = df_train[(df_train['u_out'] == 0)]\n\n    # Delta windows\n    vars_ = ['u_in', 'pressure']\n    grp = df_.groupby('breath_id')[vars_]\n    for step in steps:\n        df_step = grp.diff(step)\n        df_step.columns = [f'delta_{c}_{step}' for c in df_step.columns]\n        df_[df_step.columns] = df_step\n        \n        # For Second Try, we'll get the average u_in between steps, for better approx\n        for var in [vars_[0]]:  # just u_ins, not pressure        \n            df_u_in_avg = (grp.shift(0)[[var]] + grp.shift(-step)[[var]])\/2\n            df_u_in_avg.columns = [f'{var}_avg_{step}']\n            df_[df_u_in_avg.columns] = df_u_in_avg\n\n    # we'll also accumulate those diffs\n    df_cumsum = df_.groupby('breath_id')[[c for c in df_.columns if 'delta_' in c]].cumsum()\n    df_cumsum.columns = [f'{c}_cumsum' for c in df_cumsum.columns]\n    df_[df_cumsum.columns] = df_cumsum\n    \n    # Pressure lags\n    grp = df_.groupby('breath_id')[[c for c in df_.columns if 'pressure' in c]]\n    for lag in lags_pressure:\n        df_lag = grp.shift(-lag)\n        df_lag.columns = [f'{c}_l{lag}' for c in df_lag]\n        df_[df_lag.columns] = df_lag\n\n    df_.to_parquet(delta_lags_path)\n","3b4401a7":"df_.head()","6527299c":"df_.columns","f8b403d2":"cols = [c for c in df_.columns if ('pressure' in c) or ('u_in' in c) and ('cumsum' not in c)]\ncols_pressure = [c for c in df_.columns if ('pressure' in c)]\ncorr = df_[cols].corr()","8ffc2080":"cols_pressure = [c for c in df_.columns if ('pressure' in c) and ('cumsum' not in c)]","a1068b4f":"corr[cols_pressure].drop(cols_pressure, axis='index')","16789482":"(df_\n .reset_index()\n .query('id > 1000 and id < 2000')\n .plot.line(y=['u_in', 'delta_u_in_1_cumsum', 'pressure'], figsize=(14,8)))","ef80e394":"corr_df = pd.DataFrame()\nfor step in steps:\n    corrs = df_[[f'delta_u_in_{step}'] + [f'delta_pressure_{step}_l{lag}' for lag in lags_pressure]].corr().iloc[:, 0]\n    corrs.index = [c.replace(f'_{step}', '') for c in corrs.index]\n    corr_df[f'st_{step}'] = corrs\n\nprint('First try: corrs of delta u_in vs delta_pressure')\ncorr_df","61040ff3":"corr_df = pd.DataFrame()\nfor step in steps:\n    corrs = df_[[f'u_in_avg_{step}'] + [f'delta_pressure_{step}_l{lag}' for lag in lags_pressure]].corr().iloc[:, 0]\n    corrs.index = [c.replace(f'_{step}', '') for c in corrs.index]\n    corr_df[f'st_{step}'] = corrs\n\nprint('Second try: corrs of average u_in versus delta_pressure')\ncorr_df","70ba24d7":"corr_df = pd.DataFrame()\nfor step in steps:\n    corrs = df_[[f'u_in'] + [f'delta_pressure_{step}_l{lag}' for lag in lags_pressure]].corr().iloc[:, 0]\n    corrs.index = [c.replace(f'_{step}', '') for c in corrs.index]\n    corr_df[f'st_{step}'] = corrs\n\nprint('Second try: corrs of u_in versus delta_pressure')\ncorr_df","2583de56":"df_['C'] = df_['C'].astype(\"category\")\ndf_['R'] = df_['R'].astype('category')","4ac73433":"step = 2\ng = sns.lmplot(data=df_.sample(20000),\n               x=f'u_in_avg_{step}', \n               y=f'delta_pressure_{step}_l2', \n               row='R',\n               col='C',\n               hue='R')","d0bc8241":"(df_['delta_u_in_2'] == 0).sum()","574ea65e":"g = sns.lmplot(data=df_[df_[f'delta_u_in_{step}'] != 0],\n               x=f'delta_u_in_{step}', \n               y=f'delta_pressure_{step}_l2', \n               row='R',\n               col='C',\n               hue='R')","a622a57d":"step = 9\ng = sns.lmplot(data=df_[df_[f'delta_u_in_{step}'] != 0],\n               x=f'delta_u_in_{step}', \n               y=f'delta_pressure_{step}_l2', \n               row='R',\n               col='C',\n               hue='R')","056e15ae":"step = 1\n\ng = sns.lmplot(data=df_[df_[f'delta_u_in_{step}'] != 0],\n               x=f'delta_u_in_{step}', \n               y=f'delta_pressure_{step}_l2', \n               row='R',\n               col='C',\n               hue='R')","ca0d6617":"from scipy import stats\n\nlinreg = (df_[df_[f'delta_u_in_{step}'] != 0]\n          .dropna(subset=[f'delta_u_in_{step}', f'delta_pressure_{step}_l2'])\n          .groupby(['C', 'R'])\n          .apply(lambda x: pd.Series(stats.linregress(x[f'delta_u_in_{step}'], x[f'delta_pressure_{step}_l2'])))\n          .rename(columns={0: 'slope', 1: 'intercept', 2: 'rvalue', 3: 'pvalue', 4: 'stderr'})\n          .assign(f_max=lambda x: x['slope']\/x.index.get_level_values('R').astype(int)))\n\nlinreg","7f3d2175":"sns.lineplot(data=linreg.reset_index(), x='C', y='f_max', hue='R')","640a2931":"sns.lineplot(data=linreg.reset_index(), x='R', y='f_max', hue='C')","96078f8a":"sns.relplot(data=df_[df_['breath_id'] < 1000],\n            x='delta_u_in_2',\n            y='delta_pressure_2_l2',\n            hue='breath_id',\n            col='C',\n            row='R',\n            kind='line')","3c64410f":"df_[df_['breath_id'] == 1].plot.scatter(x='delta_u_in_2', y='delta_pressure_2_l2')","d7a34eb3":"df_[df_['breath_id'] == 39].plot.scatter(x='u_in', y='pressure')","93699c26":"g = sns.PairGrid(data=df_[df_['breath_id'] == 39],\n                 x_vars=['time_step', 'delta_pressure_2_l2'],\n                 y_vars=['pressure', 'u_in', 'delta_u_in_2'])\ng.map(sns.scatterplot)","19cfc3b4":"# Impact of R\n\nR (measured in $cmH2O\/l\/s$) indicates how restricted the airway is or alternatively, the $\\Delta Pressure$ per $\\Delta Flow$, how much the pressure increases by a change in the flow rate.  This value should be related to $u_{in}$ somewhat.  \n\n## First try (WRONG)\n\nDefine $u_{in}$ as a dimensionless variable that is the percentage the valve is opened. Let's suppose that, at 100%, the valve delivers $F = F_{max} = X \\, l\/s$, and at 0%, it delivers $F = 0 \\, l\/s$. Hence, $F$ can be thought of as:\n\n$$ F = u_{in} \\cdot F_{max} \\quad (l\/s)$$\n\nand $R$:\n\n$$ R = \\frac{\\Delta P}{\\Delta F} = \\frac{\\Delta P}{\\Delta u_{in} \\cdot F_{max}} $$\n\nIf this holds for the dataset, then the plot of $\\Delta P$ per $\\Delta u_{in}$ should be a straight line, with its slope given by $R \\cdot F_{max}$. \n\nTHIS IS WRONG: We can have a decrease in flow (negative $\\Delta F$) with an increase in pressure (positive $\\Delta P$). The flow just has to stay positive inside the lung. Lets go for second try.\n\n## Second Try\n\nDefine $u_{in}$ as a dimensionless variable that is the percentage the valve is opened. Let's suppose that, at 100%, the valve delivers $F = F_{max} = X \\, l\/s$, and at 0%, it delivers $F = 0 \\, l\/s$. Hence, $F$ can be thought of as:\n\n$$ F = u_{in} \\cdot F_{max} \\quad (l\/s)$$\n\nand $R$:\n\n$$ R = \\frac{\\Delta P}{ F} = \\frac{\\Delta P}{u_{in} \\cdot F_{max}} $$\n\nIf this holds for the dataset, then the plot of $\\Delta P$ per $u_{in}$ should be a straight line, with its slope given by $R \\cdot F_{max}$. \n\n## Analysis\n\nWeird, it seems that the procedure in First Try leads to a better result than in Second Try (higher correlation).\n Why?\n","c754cd75":"# Description \n\nCollection of some ideas and hypothesis I've tested to try building better features. ","badcaf48":"$F_{max}$ seems to vary with $R$, which wasn't in our hypothesis.","637d7b53":"Now, having this, we can calculate the correlation between all the $\\Delta u_{in}$ columns and different (lagged) $\\Delta P$, to check whether the hypothesis of hysteresis of $\\Delta P$ makes sense","bfda6e5f":"Our hypothesis seems to hold true, with higher values of $R$ having a bigger slope on the plots.\n\nNow let's calculate this slope","d735f841":"### First try\nWe can see that the $\\Delta P$s with $lag = 2$ have higher correlations with $\\Delta u_{in}$ for every step, meaning that the hysteresis hypothesis might be true.\n\n### Second try\n\nHowever, we found out that we shouldn't be using $\\Delta u_{in}$, but $u_{in}$ itself for the analysis. Redoing that, we find out lower correlations. Why?\n\n### Continuing...\n\nFinally, we can make some plots of $\\Delta P$ _versus_ $\\Delta u_{in}$ and $u_{in}$ to visualize the (expected) linearity between them.","4888a4b6":"It seems that a shift equal to two units is appropriate. However, let's use a more robust approach, comparing the correlation between the pressure and shifted $u_{in}$","acf13ef9":"# Hysteresis of $\\Delta P$\n\nIt seems that the change in $u_{in}$ does not represent an instant change on $P$, there's some hysteresis in play here (likely related to $C$ and the internal circuitry), so to correctly represent this, we need to find out the right lag for $P$.","6452703c":"We have our highest correlation between the pressure and $u_{in}$ using a shift of two units (why?)."}}