{"cell_type":{"7701c209":"code","c771552d":"code","7a715640":"code","ec294421":"code","a73a5b9c":"code","73907701":"code","3ef6632b":"code","dd3516b5":"code","254adbd6":"code","8781d544":"code","8a154b81":"code","c8b17a4c":"code","2445eca0":"code","e350160a":"code","d35b7f24":"code","6e31ae54":"code","d06cb796":"code","1493fcdf":"code","6f65c21c":"code","418d0fa0":"code","bfce7075":"code","70633408":"code","d65290c1":"code","6f403da0":"code","1e66503a":"code","5a85467f":"code","9269e1f0":"code","52be88a1":"code","6099d46b":"code","d7ef4450":"code","be08820e":"code","788f322d":"code","e64f8cf4":"code","e8ec926b":"code","6110a628":"code","3b64f40e":"code","16ee4420":"code","c834acfc":"code","2384af16":"code","97839136":"code","4837955e":"code","34a0e8fd":"code","570c99d7":"code","1fa4757c":"code","e2aa1f3f":"code","50beb387":"code","e3b7cf3c":"code","c87db7a2":"code","efb247d7":"code","9c571f3b":"code","568bc437":"code","e9799504":"code","ad59fbd4":"code","27ce5879":"markdown","4a9e9b19":"markdown","284bf03c":"markdown","9b5213a5":"markdown","afabbffa":"markdown","480c4d81":"markdown","6e7a3aa0":"markdown","27bc96d1":"markdown","91366455":"markdown","f50c6f03":"markdown","590b7455":"markdown","18f842ae":"markdown","48139c67":"markdown","0ad3bf9f":"markdown","a6324701":"markdown","e228d048":"markdown","af8c2c18":"markdown","96e2a181":"markdown","3325f553":"markdown","6df3e831":"markdown","c767a09c":"markdown","85dbce73":"markdown","c03ef4d5":"markdown","abe2cf93":"markdown"},"source":{"7701c209":"!pip install --upgrade seaborn\n!pip install ensemble_boxes","c771552d":"import numpy as np, pandas as pd\nfrom glob import glob\nimport shutil, os\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import GroupKFold\nfrom tqdm.notebook import tqdm\nimport seaborn as sns","7a715640":"dim = 512 #512, 256, 'original'\nfold = 4","ec294421":"train_df = pd.read_csv(f'..\/input\/vinbigdata-{dim}-image-dataset\/vinbigdata\/train.csv')\ntrain_df.head()","a73a5b9c":"train_df['image_path'] = f'\/kaggle\/input\/vinbigdata-{dim}-image-dataset\/vinbigdata\/train\/'+train_df.image_id+('.png' if dim!='original' else '.jpg')\ntrain_df.head()","73907701":"# \u5c06no finding\u53bb\u6389\ntrain_df = train_df[train_df.class_id!=14].reset_index(drop = True)\ntrain_df.head()","3ef6632b":"# df = pd.read_csv(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train.csv\")\n# df.head()","dd3516b5":"# df = pd.read_csv(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train.csv\")\n\n# df.head()\n\n# train_df.head()","254adbd6":"data = train_df[train_df[\"image_id\"] == '9a5094b2563a1ef3ff50dc5c7ff71345']\ndata","8781d544":"# import numpy as np\n# import pandas as pd\n\n# from tqdm import tqdm\n# from ensemble_boxes import *\n\n# # ===============================\n# # Default WBF config (you can change these)\n# iou_thr = 0.5\n# skip_box_thr = 0.0001\n# sigma = 0.1\n# # ===============================\n\n# # Loading the train DF\n# # df = pd.read_csv(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train.csv\")\n# df = train_df\n# df.fillna(0, inplace=True)\n# # df.loc[df[\"class_id\"] == 14, ['x_max', 'y_max']] = 1.0\n\n# results = []\n# image_ids = df[\"image_id\"].unique()\n\n\n# count=3#\n\n\n# for image_id in tqdm(image_ids, total=len(image_ids)):\n#     count-=1\n#     print('count',count)\n#     if count==0:#\n#         break#\n    \n#     print('image_id',image_id)\n        \n#     # All annotations for the current image.\n#     data = df[df[\"image_id\"] == image_id]\n#     data = data.reset_index(drop=True)\n#     annotations = {}\n#     weights = []\n    \n    \n#     width=data.iloc[0].width\n#     height=data.iloc[0].height\n#     image_path=data.iloc[0].image_path\n#     class_name=data.iloc[0].class_name\n\n#     # WBF expects the coordinates in 0-1 range.\n#     max_value = data.iloc[:, 4:8].values.max()\n#     data.loc[:, [\"x_min\", \"y_min\", \"x_max\", \"y_max\"]] = data.iloc[:, 4:8] \/ max_value\n\n#     # Loop through all of the annotations\n#     for idx, row in data.iterrows():\n\n#         class_name_id = row[\"class_name\"]\n\n#         if class_name_id not in annotations:\n#             annotations[class_name_id] = {\n#                 \"boxes_list\": [],\n#                 \"scores_list\": [],\n#                 \"labels_list\": [],\n#             }\n\n#             # We consider all of the radiologists as equal.\n#             weights.append(1.0)\n\n#         annotations[class_name_id][\"boxes_list\"].append([row[\"x_min\"], row[\"y_min\"], row[\"x_max\"], row[\"y_max\"]])\n# #         annotations[class_name_id][\"scores_list\"].append(1.0)\n#         annotations[class_name_id][\"labels_list\"].append(class_name_id)\n\n#     boxes_list = []\n#     scores_list = []\n#     labels_list = []\n    \n# #     print('annotations',annotations)\n\n#     for annotator in annotations.keys():\n#         boxes_list.append(annotations[annotator][\"boxes_list\"])\n#         scores_list.append(annotations[annotator][\"scores_list\"])\n#         labels_list.append(annotations[annotator][\"labels_list\"])\n        \n#     print()\n#     print('boxes_list',boxes_list)\n#     print()\n#     print('scores_list',scores_list)\n#     print()\n#     print('labels_list',labels_list)\n#     print()\n#     print()","8a154b81":"###","c8b17a4c":"import numpy as np\nimport pandas as pd\n\nfrom tqdm import tqdm\nfrom ensemble_boxes import *\n\n# ===============================\n# Default WBF config (you can change these)\niou_thr = 0.5\nskip_box_thr = 0.0001\nsigma = 0.1\n# ===============================\n\n# Loading the train DF\n# df = pd.read_csv(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train.csv\")\ndf = train_df\ndf.fillna(0, inplace=True)\n# df.loc[df[\"class_id\"] == 14, ['x_max', 'y_max']] = 1.0\n\nresults = []\nimage_ids = df[\"image_id\"].unique()\n\ncount=3#\n\n\nfor image_id in tqdm(image_ids, total=len(image_ids)):\n    count-=1\n    print('count',count)\n    if count==0:#\n        break#\n    \n    print('image_id',image_id)\n        \n    # All annotations for the current image.\n    data = df[df[\"image_id\"] == image_id]\n    data = data.reset_index(drop=True)\n    annotations = {}\n    weights = []\n    \n    \n    width=data.iloc[0].width\n    height=data.iloc[0].height\n    image_path=data.iloc[0].image_path\n    class_name=data.iloc[0].class_name\n\n    # WBF expects the coordinates in 0-1 range.\n    max_value = data.iloc[:, 4:8].values.max()\n    data.loc[:, [\"x_min\", \"y_min\", \"x_max\", \"y_max\"]] = data.iloc[:, 4:8] \/ max_value\n\n    # Loop through all of the annotations\n    for idx, row in data.iterrows():\n\n        rad_id = row[\"rad_id\"]\n\n        if rad_id not in annotations:\n            annotations[rad_id] = {\n                \"boxes_list\": [],\n                \"scores_list\": [],\n                \"labels_list\": [],\n            }\n\n            # We consider all of the radiologists as equal.\n            weights.append(1.0)\n\n        annotations[rad_id][\"boxes_list\"].append([row[\"x_min\"], row[\"y_min\"], row[\"x_max\"], row[\"y_max\"]])\n        annotations[rad_id][\"scores_list\"].append(1.0)\n        annotations[rad_id][\"labels_list\"].append(row[\"class_id\"])\n\n    boxes_list = []\n    scores_list = []\n    labels_list = []\n    \n#     print('annotations',annotations)\n\n    for annotator in annotations.keys():\n        boxes_list.append(annotations[annotator][\"boxes_list\"])\n        scores_list.append(annotations[annotator][\"scores_list\"])\n        labels_list.append(annotations[annotator][\"labels_list\"])\n        \n#     print()\n#     print('boxes_list',boxes_list)\n#     print()\n#     print('scores_list',scores_list)\n#     print()\n#     print('labels_list',labels_list)\n#     print()\n#     print()\n    \n    # soft_nms\n    boxes, scores, labels = soft_nms(\n        boxes_list, scores_list, labels_list, weights=weights, iou_thr=iou_thr, sigma=sigma, thresh=skip_box_thr\n    )\n\n\n    for idx, box in enumerate(boxes):\n    results.append({\n        \"image_id\": image_id,\n        \"class_id\": int(labels[idx]),\n        \"rad_id\": \"wbf\",\n        \"x_min\": box[0] * max_value,\n        \"y_min\": box[1] * max_value,\n        \"x_max\": box[2] * max_value,\n        \"y_max\": box[3] * max_value,\n        \"width\": width,\n        \"height\": height,\n        \"image_path\": image_path,\n        \"class_name\": class_name\n    })\n\nresults = pd.DataFrame(results)","2445eca0":"results","e350160a":"train_df=results","d35b7f24":"df = pd.read_csv(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train.csv\")","6e31ae54":"# \u505a\u5f52\u4e00\u5316\uff0c\u628a\u5de6\u4e0a\u53f3\u4e0b\u56db\u4e2a\u70b9\u7684\u5750\u6807\uff0c\u8ba1\u7b97\u6210\u4e2d\u5fc3\u70b9\u5750\u6807\u548cw\/h\ntrain_df['x_min'] = train_df.apply(lambda row: (row.x_min)\/row.width, axis =1)\ntrain_df['y_min'] = train_df.apply(lambda row: (row.y_min)\/row.height, axis =1)\n\ntrain_df['x_max'] = train_df.apply(lambda row: (row.x_max)\/row.width, axis =1)\ntrain_df['y_max'] = train_df.apply(lambda row: (row.y_max)\/row.height, axis =1)\n\ntrain_df['x_mid'] = train_df.apply(lambda row: (row.x_max+row.x_min)\/2, axis =1)\ntrain_df['y_mid'] = train_df.apply(lambda row: (row.y_max+row.y_min)\/2, axis =1)\n\ntrain_df['w'] = train_df.apply(lambda row: (row.x_max-row.x_min), axis =1)\ntrain_df['h'] = train_df.apply(lambda row: (row.y_max-row.y_min), axis =1)\n\ntrain_df['area'] = train_df['w']*train_df['h']\ntrain_df.head()","d06cb796":"# \u7c7b\u540d\u6539\u6210str\nclass_ids, class_names = list(zip(*set(zip(train_df.class_id, train_df.class_name))))\nclasses = list(np.array(class_names)[np.argsort(class_ids)])\nclasses = list(map(lambda x: str(x), classes))\nclasses","1493fcdf":"# \u53d6\u7279\u5f81\u6570\u636e\nfeatures = ['x_min', 'y_min', 'x_max', 'y_max', 'x_mid', 'y_mid', 'w', 'h', 'area']\nX = train_df[features]\ny = train_df['class_id']\nX.shape, y.shape","6f65c21c":"# %%time\n# # \u901a\u8fc7t-SNE\u770b\u6837\u672c\u9ad8\u7ef4\u5206\u5e03\n\n# from sklearn.manifold import TSNE\n\n# tsne = TSNE(n_components = 2, perplexity = 40, random_state=1, n_iter=5000)\n# data_X = X\n# data_y = y.loc[data_X.index]\n# embs = tsne.fit_transform(data_X)\n# # Add to dataframe for convenience\n# plot_x = embs[:, 0]\n# plot_y = embs[:, 1]","418d0fa0":"# import matplotlib.pyplot as plt\n# plt.figure(figsize = (15, 15))\n# plt.axis('off')\n# scatter = plt.scatter(plot_x, plot_y, marker = 'o',s = 50, c=data_y.tolist(), alpha= 0.5,cmap='viridis')\n# plt.legend(handles=scatter.legend_elements()[0], labels=classes)","bfce7075":"from scipy.stats import gaussian_kde\n\n\nx_val = train_df.x_mid.values\ny_val = train_df.y_mid.values\n\n# Calculate the point density\nxy = np.vstack([x_val,y_val])\nz = gaussian_kde(xy)(xy)\n\nfig, ax = plt.subplots(figsize = (10, 10))\nax.axis('off')\nax.scatter(x_val, y_val, c=z, s=100, cmap='viridis')\n# ax.set_xlabel('x_mid')\n# ax.set_ylabel('y_mid')\nplt.show()","70633408":"x_val = train_df.w.values\ny_val = train_df.h.values\n\n# Calculate the point density\nxy = np.vstack([x_val,y_val])\nz = gaussian_kde(xy)(xy)\n\nfig, ax = plt.subplots(figsize = (10, 10))\nax.axis('off')\nax.scatter(x_val, y_val, c=z, s=100, cmap='viridis')\n# ax.set_xlabel('bbox_width')\n# ax.set_ylabel('bbox_height')\nplt.show()","d65290c1":"x_val = train_df.width.values\ny_val = train_df.height.values\n\n# Calculate the point density\nxy = np.vstack([x_val,y_val])\nz = gaussian_kde(xy)(xy)\n\nfig, ax = plt.subplots(figsize = (10, 10))\nax.axis('off')\nax.scatter(x_val, y_val, c=z, s=100, cmap='viridis')\n# ax.set_xlabel('image_width')\n# ax.set_ylabel('image_height')\nplt.show()","6f403da0":"# K\u6298\u9a8c\u8bc1\ngkf  = GroupKFold(n_splits = 5)\ntrain_df['fold'] = -1\nfor fold, (train_idx, val_idx) in enumerate(gkf.split(train_df, groups = train_df.image_id.tolist())):\n    train_df.loc[val_idx, 'fold'] = fold\ntrain_df.head()","1e66503a":"train_df.shape","5a85467f":"# \u62c6\u5206\u51fa\u4e00\u4e2a\u8bad\u7ec3\u548c\u4e00\u4e2a\u9a8c\u8bc1\ntrain_files = []\nval_files   = []\nval_files += list(train_df[train_df.fold==fold].image_path.unique())\ntrain_files += list(train_df[train_df.fold!=fold].image_path.unique())\nlen(train_files), len(val_files)","9269e1f0":"# \u628a\u6807\u7b7e\u548c\u56fe\u7247\u5206\u522b\u5904\u7406\u597d\uff0c\u6309\u7167Yolov5\u7684\u8981\u6c42\u653e\u5230\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\u91cc\u53bb\nos.makedirs('\/kaggle\/working\/vinbigdata\/labels\/train', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/labels\/val', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/images\/train', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/images\/val', exist_ok = True)\nlabel_dir = '\/kaggle\/input\/vinbigdata-yolo-labels-dataset\/labels'\nfor file in tqdm(train_files):\n    shutil.copy(file, '\/kaggle\/working\/vinbigdata\/images\/train')\n    filename = file.split('\/')[-1].split('.')[0]\n    shutil.copy(os.path.join(label_dir, filename+'.txt'), '\/kaggle\/working\/vinbigdata\/labels\/train')\n    \nfor file in tqdm(val_files):\n    shutil.copy(file, '\/kaggle\/working\/vinbigdata\/images\/val')\n    filename = file.split('\/')[-1].split('.')[0]\n    shutil.copy(os.path.join(label_dir, filename+'.txt'), '\/kaggle\/working\/vinbigdata\/labels\/val')","52be88a1":"train_df","6099d46b":"# \u83b7\u53d6\u7c7b\u540d\nclass_ids, class_names = list(zip(*set(zip(train_df.class_id, train_df.class_name))))\nclasses = list(np.array(class_names)[np.argsort(class_ids)])\nclasses = list(map(lambda x: str(x), classes))\nclasses","d7ef4450":"classes=list(set(classes))","be08820e":"# \u505ayolov5\u7684\u914d\u7f6e\u6587\u4ef6\nfrom os import listdir\nfrom os.path import isfile, join\nimport yaml\n\ncwd = '\/kaggle\/working\/'\n\nwith open(join( cwd , 'train.txt'), 'w') as f:\n    for path in glob('\/kaggle\/working\/vinbigdata\/images\/train\/*'):\n        f.write(path+'\\n')\n            \nwith open(join( cwd , 'val.txt'), 'w') as f:\n    for path in glob('\/kaggle\/working\/vinbigdata\/images\/val\/*'):\n        f.write(path+'\\n')\n\ndata = dict(\n    train =  join( cwd , 'train.txt') ,\n    val   =  join( cwd , 'val.txt' ),\n    nc    = 14,\n    names = classes\n    )\n\nwith open(join( cwd , 'vinbigdata.yaml'), 'w') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False)\n\nf = open(join( cwd , 'vinbigdata.yaml'), 'r')\nprint('\\nyaml:')\nprint(f.read())","788f322d":"# https:\/\/www.kaggle.com\/ultralytics\/yolov5\n# !git clone https:\/\/github.com\/ultralytics\/yolov5  # clone repo\n# %cd yolov5\nshutil.copytree('\/kaggle\/input\/yolov5-official-v31-dataset\/yolov5', '\/kaggle\/working\/yolov5')\nos.chdir('\/kaggle\/working\/yolov5')\n# %pip install -qr requirements.txt # install dependencies\n\nimport torch\nfrom IPython.display import Image, clear_output  # to display images\n\nclear_output()\nprint('Setup complete. Using torch %s %s' % (torch.__version__, torch.cuda.get_device_properties(0) if torch.cuda.is_available() else 'CPU'))","e64f8cf4":"# \u6d4b\u8bd5\u5b98\u65b9\u7684\u6743\u91cd\u6587\u4ef6\n!python detect.py --weights yolov5s.pt --img 640 --conf 0.25 --source data\/images\/\nImage(filename='runs\/detect\/exp\/zidane.jpg', width=600)","e8ec926b":"# !WANDB_MODE=\"dryrun\" python train.py --img 640 --batch 16 --epochs 3 --data coco128.yaml --weights yolov5s.pt --nosave --cache \n!WANDB_MODE=\"dryrun\" python train.py --img 640 --batch 8 --epochs 30 --data \/kaggle\/working\/vinbigdata.yaml --weights yolov5m.pt --cache","6110a628":"# xywh\u7684\u5206\u5e03\nplt.figure(figsize = (20,20))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp\/labels_correlogram.jpg'));","3b64f40e":"# \u7c7b\u7684\u5206\u5e03\uff0c\u5404\u7c7b\u6846\u7684\u5206\u5e03\nplt.figure(figsize = (20,20))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp\/labels.jpg'));","16ee4420":"# \u753b\u51fa\u5404\u4e2a\u6279\u6b21\u7684\u6807\u8bb0\u56fe\nimport matplotlib.pyplot as plt\nplt.figure(figsize = (15, 15))\nplt.imshow(plt.imread('runs\/train\/exp\/train_batch0.jpg'))\n\nplt.figure(figsize = (15, 15))\nplt.imshow(plt.imread('runs\/train\/exp\/train_batch1.jpg'))\n\nplt.figure(figsize = (15, 15)\nplt.imshow(plt.imread('runs\/train\/exp\/train_batch2.jpg'))","c834acfc":"# \u770b\u6807\u8bb0\u548c\u9884\u6d4b\u7684\u5dee\u522b\nfig, ax = plt.subplots(3, 2, figsize = (2*5,3*5), constrained_layout = True)\nfor row in range(3):\n    ax[row][0].imshow(plt.imread(f'runs\/train\/exp\/test_batch{row}_labels.jpg'))\n    ax[row][0].set_xticks([])\n    ax[row][0].set_yticks([])\n    ax[row][0].set_title(f'runs\/train\/exp\/test_batch{row}_labels.jpg', fontsize = 12)\n    \n    ax[row][1].imshow(plt.imread(f'runs\/train\/exp\/test_batch{row}_pred.jpg'))\n    ax[row][1].set_xticks([])\n    ax[row][1].set_yticks([])\n    ax[row][1].set_title(f'runs\/train\/exp\/test_batch{row}_pred.jpg', fontsize = 12)","2384af16":"# \u770b\u635f\u5931\u4e0b\u964d\u901f\u5ea6\nplt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp\/results.png'));","97839136":"# \u6df7\u6dc6\u77e9\u9635\nplt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp\/confusion_matrix.png'));","4837955e":"# \u7528\u8bad\u7ec3\u597d\u7684\u6a21\u578b\u63a8\u7406\n!python detect.py --weights 'runs\/train\/exp\/weights\/best.pt'\\\n--img 640\\\n--conf 0.15\\\n--iou 0.5\\\n--source \/kaggle\/working\/vinbigdata\/images\/val\\\n--exist-ok","34a0e8fd":"# \u63a8\u65ad\u6837\u672c\uff0c\u5e76\u505a\u6807\u8bb0\u56fe\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport numpy as np\nimport random\nimport cv2\nfrom glob import glob\nfrom tqdm import tqdm\n\nfiles = glob('runs\/detect\/exp\/*')\nfor _ in range(3):\n    row = 4\n    col = 4\n    grid_files = random.sample(files, row*col)\n    images     = []\n    for image_path in tqdm(grid_files):\n        img          = cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB)\n        images.append(img)\n\n    fig = plt.figure(figsize=(col*5, row*5))\n    grid = ImageGrid(fig, 111,  # similar to subplot(111)\n                     nrows_ncols=(col, row),  # creates 2x2 grid of axes\n                     axes_pad=0.05,  # pad between axes in inch.\n                     )\n\n    for ax, im in zip(grid, images):\n        # Iterating over the grid returns the Axes.\n        ax.imshow(im)\n        ax.set_xticks([])\n        ax.set_yticks([])\n    plt.show()","570c99d7":"# \u5220\u9664\u4e00\u4e9b\u6587\u4ef6\u5939\uff0c\u9632\u6b62\u518d\u6b21\u8fd0\u884c\u65f6\u62a5\u9519\nshutil.rmtree('\/kaggle\/working\/vinbigdata')\nshutil.rmtree('runs\/detect')\nfor file in (glob('runs\/train\/exp\/**\/*.png', recursive = True)+glob('runs\/train\/exp\/**\/*.jpg', recursive = True)):\n    os.remove(file)","1fa4757c":"import numpy as np, pandas as pd\nfrom glob import glob\nimport shutil, os\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import GroupKFold\nfrom tqdm.notebook import tqdm\nimport seaborn as sns","e2aa1f3f":"dim = 512 #1024, 256, 'original'\ntest_dir = f'\/kaggle\/input\/vinbigdata-{dim}-image-dataset\/vinbigdata\/test'\nweights_dir = 'runs\/train\/exp\/weights\/best.pt'","50beb387":"test_df = pd.read_csv(f'\/kaggle\/input\/vinbigdata-{dim}-image-dataset\/vinbigdata\/test.csv')\ntest_df.head()","e3b7cf3c":"shutil.copytree('\/kaggle\/input\/yolov5-official-v31-dataset\/yolov5', '\/kaggle\/working\/yolov5')\n# shutil.copytree('\/kaggle\/input\/yolov5-official-v31-dataset\/yolov5', '.\/yolov5')\n\nos.chdir('\/kaggle\/working\/yolov5') # install dependencies\n\nimport torch\nfrom IPython.display import Image, clear_output  # to display images\n\nclear_output()\nprint('Setup complete. Using torch %s %s' % (torch.__version__, torch.cuda.get_device_properties(0) if torch.cuda.is_available() else 'CPU'))","c87db7a2":"!python detect.py --weights $weights_dir\\\n--img 640\\\n--conf 0.15\\\n--iou 0.4\\\n--source $test_dir\\\n--save-txt --save-conf --exist-ok","efb247d7":"import matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport numpy as np\nimport random\nimport cv2\nfrom glob import glob\nfrom tqdm import tqdm\n\nfiles = glob('runs\/detect\/exp\/*png')\nfor _ in range(3):\n    row = 4\n    col = 4\n    grid_files = random.sample(files, row*col)\n    images     = []\n    for image_path in tqdm(grid_files):\n        img          = cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB)\n        images.append(img)\n\n    fig = plt.figure(figsize=(col*5, row*5))\n    grid = ImageGrid(fig, 111,  # similar to subplot(111)\n                     nrows_ncols=(col, row),  # creates 2x2 grid of axes\n                     axes_pad=0.05,  # pad between axes in inch.\n                     )\n\n    for ax, im in zip(grid, images):\n        # Iterating over the grid returns the Axes.\n        ax.imshow(im)\n        ax.set_xticks([])\n        ax.set_yticks([])\n    plt.show()","9c571f3b":"def yolo2voc(image_height, image_width, bboxes):\n    \"\"\"\n    yolo => [xmid, ymid, w, h] (normalized)\n    voc  => [x1, y1, x2, y1]\n    \n    \"\"\" \n    bboxes = bboxes.copy().astype(float) # otherwise all value will be 0 as voc_pascal dtype is np.int\n    \n    bboxes[..., [0, 2]] = bboxes[..., [0, 2]]* image_width\n    bboxes[..., [1, 3]] = bboxes[..., [1, 3]]* image_height\n    \n    bboxes[..., [0, 1]] = bboxes[..., [0, 1]] - bboxes[..., [2, 3]]\/2\n    bboxes[..., [2, 3]] = bboxes[..., [0, 1]] + bboxes[..., [2, 3]]\n    \n    return bboxes","568bc437":"image_ids = []\nPredictionStrings = []\n\nfor file_path in tqdm(glob('runs\/detect\/exp\/labels\/*txt')):\n    image_id = file_path.split('\/')[-1].split('.')[0]\n    w, h = test_df.loc[test_df.image_id==image_id,['width', 'height']].values[0]\n    f = open(file_path, 'r')\n    data = np.array(f.read().replace('\\n', ' ').strip().split(' ')).astype(np.float32).reshape(-1, 6)\n    data = data[:, [0, 5, 1, 2, 3, 4]]\n    bboxes = list(np.round(np.concatenate((data[:, :2], np.round(yolo2voc(h, w, data[:, 2:]))), axis =1).reshape(-1), 1).astype(str))\n    for idx in range(len(bboxes)):\n        bboxes[idx] = str(int(float(bboxes[idx]))) if idx%6!=1 else bboxes[idx]\n    image_ids.append(image_id)\n    PredictionStrings.append(' '.join(bboxes))","e9799504":"pred_df = pd.DataFrame({'image_id':image_ids,\n                        'PredictionString':PredictionStrings})\nsub_df = pd.merge(test_df, pred_df, on = 'image_id', how = 'left').fillna(\"14 1 0 0 1 1\")\nsub_df = sub_df[['image_id', 'PredictionString']]\nsub_df.to_csv('\/kaggle\/working\/submission_wbf.csv',index = False)\nsub_df.tail()","ad59fbd4":"pred_df = pd.DataFrame({'image_id':image_ids,\n                        'PredictionString':PredictionStrings})\nsub_df = pd.merge(test_df, pred_df, on = 'image_id', how = 'left').fillna(\"14 1 0 0 1 1\")\nsub_df = sub_df[['image_id', 'PredictionString']]\nsub_df.to_csv('\/kaggle\/working\/submission_wbf.csv',index = False)\nsub_df.tail()","27ce5879":"# [YOLOv5](https:\/\/github.com\/ultralytics\/yolov5)\n![](https:\/\/user-images.githubusercontent.com\/26833433\/98699617-a1595a00-2377-11eb-8145-fc674eb9b1a7.jpg)\n![](https:\/\/user-images.githubusercontent.com\/26833433\/90187293-6773ba00-dd6e-11ea-8f90-cd94afc0427f.png)","4a9e9b19":"# Pre-Processing","284bf03c":"# Selecting Models\nIn this notebok I'm using `v5s`. To select your prefered model just replace `--cfg models\/yolov5s.yaml --weights yolov5s.pt` with the following command:\n* `v5s` : `--cfg models\/yolov5s.yaml --weights yolov5s.pt`\n* `v5m` : `--cfg models\/yolov5m.yaml --weights yolov5m.pt`\n* `v5l` : `--cfg models\/yolov5l.yaml --weights yolov5l.pt`\n* `v5x` : `--cfg models\/yolov5x.yaml --weights yolov5x.pt`","9b5213a5":"# (Loss, Map) Vs Epoch","afabbffa":"# GT Vs Pred","480c4d81":"# Split","6e7a3aa0":"# Get Class Name","27bc96d1":"## bbox_w Vs bbox_h","91366455":"# YOLOv5 Stuff","f50c6f03":"## Pretrained Checkpoints:\n\n| Model | AP<sup>val<\/sup> | AP<sup>test<\/sup> | AP<sub>50<\/sub> | Speed<sub>GPU<\/sub> | FPS<sub>GPU<\/sub> || params | FLOPS |\n|---------- |------ |------ |------ | -------- | ------| ------ |------  |  :------: |\n| [YOLOv5s](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | 37.0     | 37.0     | 56.2     | **2.4ms** | **416** || 7.5M   | 13.2B\n| [YOLOv5m](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | 44.3     | 44.3     | 63.2     | 3.4ms     | 294     || 21.8M  | 39.4B\n| [YOLOv5l](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | 47.7     | 47.7     | 66.5     | 4.4ms     | 227     || 47.8M  | 88.1B\n| [YOLOv5x](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | **49.2** | **49.2** | **67.7** | 6.9ms     | 145     || 89.0M  | 166.4B\n| | | | | | || |\n| [YOLOv5x](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0) + TTA|**50.8**| **50.8** | **68.9** | 25.5ms    | 39      || 89.0M  | 354.3B\n| | | | | | || |\n| [YOLOv3-SPP](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0) | 45.6     | 45.5     | 65.2     | 4.5ms     | 222     || 63.0M  | 118.0B","590b7455":"# Confusion Matrix","18f842ae":"# t-SNE Visualization","48139c67":"# Class Distribution","0ad3bf9f":"# Image Aspect Ratio\nbox\u7684\u5bbd\u9ad8","a6324701":"# Batch Image","e228d048":"# Version\n* `v13`: Fold4\n* `v12`: Fold3\n* `v10`: Fold2\n* `v09`: Fold1\n* `v03`: Fold0","af8c2c18":"# Only 14 Class","96e2a181":"# Inference Plot","3325f553":"# Copying Files","6df3e831":"# \u51c6\u5907\u6570\u636e","c767a09c":"# BBox Location","85dbce73":"# Inference","c03ef4d5":"## x_mid Vs y_mid","abe2cf93":"# Train"}}