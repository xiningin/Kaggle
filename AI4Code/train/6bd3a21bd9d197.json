{"cell_type":{"14998b57":"code","1f14fe0c":"code","3f948a7a":"code","ebbb28e7":"code","60408de2":"code","492c0e55":"code","5895b53b":"code","bebd4f17":"code","dfe92d31":"code","163aa3dd":"code","de0af73c":"code","ba261695":"code","e416bd05":"code","e887026e":"code","61c0d01e":"code","fb29b597":"code","b5387da0":"code","81f92611":"code","7c2ba44a":"code","cc1deb2b":"code","bc454728":"code","0ea9f21b":"code","87b8af5f":"code","5a9b6620":"code","aed326a7":"code","6ec3d402":"code","eb09fdd6":"code","7cd06cc9":"code","b71c3792":"code","8b8ae96f":"code","40b1e0e5":"code","e506d33e":"code","3ab7d71b":"code","941a2e95":"code","19c8c835":"code","9d24d346":"code","ee618430":"code","f7230413":"code","376289af":"code","9c17f190":"code","4483ac29":"code","485c97fe":"code","66678d14":"code","aeeffc87":"code","5cc28abf":"code","56ba7619":"code","acd12071":"code","a86f570d":"code","c33e5a99":"code","2806e481":"code","16dffd1c":"code","cb3a6b34":"code","73f3eea7":"code","91aa0cec":"code","5774c871":"code","26962d86":"code","0700cf60":"code","8ba5bb17":"code","c63c3a6b":"code","32cb0c68":"code","18a55ce6":"code","31074bc7":"code","fe514229":"code","cd991eeb":"code","fca52a65":"code","51266b60":"code","90cac939":"code","7c6609b3":"code","96bda66a":"code","dc225c15":"code","0f161c1f":"code","50f60195":"code","de0293e4":"code","96b71ea6":"code","ca56c590":"code","8f057c17":"code","2134a5ea":"code","a3f7c375":"code","fda16f20":"code","397935c6":"code","acc15bda":"code","2720ca91":"code","dc69d134":"code","27f31d23":"code","f3447f7c":"code","af58f738":"code","11e22950":"code","591a4ffb":"code","23937ccd":"code","e105e13b":"code","16d26b32":"code","39d3a8db":"code","1645d700":"code","c6a12a1d":"code","4046e0e2":"code","b15146eb":"code","09e355df":"code","992878c6":"code","2b84b141":"code","8765d041":"code","e58e0b9b":"code","060bb154":"code","70768635":"code","150a8d81":"code","2ad6ef2c":"code","7a82da2e":"markdown","5673026b":"markdown","1f051fd3":"markdown","22936d93":"markdown","5af816e2":"markdown","6dc94c2e":"markdown","7aa63086":"markdown","4ccac83d":"markdown","4a208bce":"markdown","7f2d53a2":"markdown","72e62fb4":"markdown","371f038b":"markdown","a2c06ba8":"markdown","3914dc88":"markdown","66a20397":"markdown","225f18fc":"markdown","b4a9119b":"markdown","7c8b6e1f":"markdown","f0673339":"markdown","b5d2e54c":"markdown","35280d7e":"markdown","18392b28":"markdown","19900a64":"markdown","8aec3b55":"markdown","9bb33d36":"markdown","eb9393f5":"markdown","64775cda":"markdown","89af3065":"markdown","68d9d82a":"markdown","7adbe665":"markdown","55ba345f":"markdown","8ba4fce2":"markdown","e2da6d7f":"markdown","ce953212":"markdown","5a0d7813":"markdown","cf2a3fb3":"markdown","7d1388c2":"markdown","062c22ae":"markdown","8a284543":"markdown","2fcec64b":"markdown","c768713f":"markdown","aa762279":"markdown","654e8218":"markdown","f0871286":"markdown","e3c7a105":"markdown","7c4df755":"markdown","eb87a8de":"markdown","4df428d1":"markdown","32553f34":"markdown","8b3deb24":"markdown"},"source":{"14998b57":"# On Kaggle Numpy is pre installed ( else use pip install numpy)\n## Once installed import numpy as \n\nimport numpy as np\nfrom numpy import random  ## NumPy offers the random module to work with random numbers.\n\n## Here np is alias (In Python alias are an alternate name for referring to the same thing.)\n### Thus now the NumPy package can be referred to as np instead of numpy.","1f14fe0c":"### Checking NumPy Version \nprint('Numpy Version: ',np.__version__)","3f948a7a":"# We can create a NumPy ndarray object by using the array() function.\n## To create an ndarray, we can pass a list, tuple or any array-like object into the array() method, and it will be converted into an ndarray:\narr  = np.array([1, 2, 3, 4, 5])  ### use list to create an array\narr2 = np.array((6, 7, 8, 9, 10)) ### Use tuple to create an array\n\n### Creating list and tuple \nl_list= [5.5,6.5,7.5,8,9]\nt_tuple= (24,25,525,45,95)\n# Similarly we can convert tuple and list using np.array\narr3 = np.array([l_list,t_tuple] , np.int32 ) ### Creating a 2d array with data type int32\nnp.array(t_tuple) ","ebbb28e7":"print('Array created with List:  ', arr)\nprint('Array created with Tuple: ', arr2)\nprint('2D Array created with List & Tuple: ')\nprint(arr3)","60408de2":"## check the type of arr\nprint('Type of Array created with List:  ',type(arr))\nprint('Type of Array created with Tuple: ',type(arr2))\nprint('Type of Array created with L & T: ',type(arr3))\n\n## type(): This built-in Python function tells us the type of the object passed to it. Like in above code it shows that arr is numpy.ndarray type.\ntype(arr)","492c0e55":"print('Dimension of List array: ',arr.ndim)   ### .ndim  Returns Number of array dimensions.\nprint('Shape of List array:     ',arr.shape)  ### .shape Returns Shape of Array\nprint('Data Type of List array: ',arr.dtype)  ### .dtype Returns Data Type of elements of array\nprint('Length of one array element in bytes (itemsize): ', arr.itemsize, 'Bytes')\nprint('Total bytes consumed by the elements of the array: ', arr.nbytes, 'Bytes')\nprint('Total Bytes consumed = 5 elemts *8 bytes (8 bytes as this is int 64)')\nprint()\nprint('Dimension of 2D array: ',arr3.ndim)\nprint('Shape of 2D array:     ',arr3.shape)\nprint('Data Type of 2D array: ',arr3.dtype)\nprint('Length of one array element in bytes (itemsize): ', arr3.itemsize, 'Bytes')\nprint('Total bytes consumed by the elements of the array: ', arr3.nbytes, 'Bytes')\nprint('Total Bytes consumed = 2*5 elemts * 4 bytes (4 bytes as this is int 32)')","5895b53b":"# dtype that allows us to define the expected data type of the array elements:\n\narr = np.array([1, 2, 3, 4], dtype='S')\n\nprint(arr)\nprint(arr.dtype)","bebd4f17":"arr = np.array([1, 2, 3, 4], dtype='i2') ## i:: int 32, i2:: int16, i4 :: int32 \n\nprint(arr)\nprint(arr.dtype)","dfe92d31":"## Convert float to int\narr = np.array([1.1, 2.1, 3.1])\n\nnewarr = arr.astype('i')\n\nprint(newarr)\nprint(newarr.dtype)","163aa3dd":"############ ~~~~~~~~~~~~~~~ 0D Array ~~~~~~~~~~~~~~~ ############\n# 0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array.\narr_0D = np.array(7)\n\n############ ~~~~~~~~~~~~~~~ 1D Array ~~~~~~~~~~~~~~~ ############\n# An array that has 0-D arrays as its elements is called uni-dimensional or 1-D array.\narr_1D = np.array([128,256,512,1024,2048])\n\n############ ~~~~~~~~~~~~~~~ 2D Array ~~~~~~~~~~~~~~~ ############\n# An array that has 1-D arrays as its elements is called a 2-D array. These are often used to represent matrix or 2nd order tensors.\narr_2D = np.array([[121, 144, 169], [196, 225, 256]])\n\n############ ~~~~~~~~~~~~~~~ 3D Array ~~~~~~~~~~~~~~~ ############\n# An array that has 2-D arrays (matrices) as its elements is called 3-D array. These are often used to represent a 3rd order tensor.\narr_3D = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])","de0af73c":"display(arr_0D)\nprint('Dimension of this array',arr_0D.ndim)\nprint()\ndisplay(arr_1D)\nprint('Dimension of this array', arr_1D.ndim)\nprint()\nprint(arr_2D)\nprint('Dimension of this array',arr_2D.ndim)\nprint()\nprint(arr_3D)\nprint('Dimension of this array',arr_3D.ndim)\n\n### Observe the difference between print and display","ba261695":"for i in range(6,11):\n    arr = np.array([1, 2, 3, 4], ndmin=i)\n    print(arr)\n    print('number of dimensions :', arr.ndim)\n    print()","e416bd05":"# now lets do same thing when we use tuple to create array\nfor i in range(6,11):\n    arr = np.array((1, 2, 3, 4), ndmin=i)\n    print(arr)\n    print('number of dimensions :', arr.ndim)\n    print()","e887026e":"### Arrange certain no in an array\nnp.arange(1,11)","61c0d01e":"# All zeros\nnp.zeros((3, 2))","fb29b597":"# All ones\nnp.ones([2, 2, 3])","b5387da0":"# Identity matrix\nnp.eye(3)","81f92611":"# Random vector\nnp.random.rand(5)","7c2ba44a":"# Random matrix\nnp.random.randn(2, 3) # rand vs. randn - what's the difference?","cc1deb2b":"# Fixed value\nnp.full([2, 3], 42)","bc454728":"# Range with start, end and step\nnp.arange(10, 90, 3)","0ea9f21b":"# Equally spaced numbers in a range\nnp.linspace(3, 27, 9)","87b8af5f":"arr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\narr3 = np.array([[1, 2, 3, 4], \n                 [5, 6, 7, 8], \n                 [9, 10, 11, 12]])","5a9b6620":"arr1 + arr2","aed326a7":"arr2 + 7 ### awhat happen when we add a no (or scaler) to array","6ec3d402":"arr3 - 3","eb09fdd6":"### Division by Scaler\narr3\/5","7cd06cc9":"arr2%2  ## using modulus function","b71c3792":"### Using * to multiply 2 array\narr1*arr2","8b8ae96f":"np.dot(arr1, arr2)","40b1e0e5":"## We can use the np.matmul function or the @ operator to perform matrix multiplication.\nnp.matmul(arr1, arr2)","e506d33e":"arr2 = np.array([[1, 2, 3, 4], \n                 [5, 6, 7, 8], \n                 [9, 1, 2, 3]])","3ab7d71b":"arr2.shape","941a2e95":"arr4 = np.array([4, 5, 6, 7])","19c8c835":"arr4.shape","9d24d346":"arr2 + arr4","ee618430":"arr5 = np.array([7, 8])","f7230413":"arr5.shape","376289af":"### Reshape function\n\na = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\na_original= a.copy()   ### Creating a copy\n\na1 = a.reshape(4, 3)\nprint(\"Reshaping 1D array to 2D array\")\nprint(a1)\nprint()\n\na2 = a.reshape(2,2,3)\nprint(\"Reshaping 1D array to 3D array\")\nprint(a2)\n","9c17f190":"### Reshape playing with order parameter\n### C row wise operation\n### F column wise operation\n### A \n\nr = np.reshape(a, (4, 3))\nc= np.reshape(a, (4,3), order='F')  ## by default it is C (i.e. row wise) and F for column wise\n\nprint(\"Reshape array row wise as order = C\")\nprint(r,'\\n')\nprint(\"Reshape array column wise as order = F\")\nprint(c)\n","4483ac29":"### Resize\n\na=np.array([[0,1],[2,3]])\n #### np.resize(a,(2,3)) isn't working on my notebook  >> However this gives us new array and doesn't change original array\na.resize((2,3))   #### this will resize the original array itself\na","485c97fe":"### flatten will give a copy of array which will contain same elements of array but here we will get 1D array.\na.flatten()","66678d14":"### Lets try one with 3D array\nb = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])\nprint('Original array')\nprint(b,'\\n')\n\nprint('When use only flatten')\nprint(b.flatten(),'\\n')\n\nprint('When use flatten with Order = C (this is default i.e row majors)')\nprint(b.flatten(order=\"C\"),'\\n')\n\nprint('When use flatten with Order = F (i.e w.r.t columns)')\nprint(b.flatten(order=\"F\"),'\\n')\n\nprint('When use flatten with Order = A')\nprint(b.flatten(order=\"A\"),'\\n')\n\nprint('When use flatten with Order = K')\nprint(b.flatten(order=\"K\"),'\\n')","aeeffc87":"### Now lets try ravel\n\nprint('Original array')\nprint(b,'\\n')\n\nprint('When use only ravel')\nprint(np.ravel(b),'\\n')\n\nprint('When use ravel with Order = C (this is default i.e row majors)')\nprint(np.ravel(b, order=\"C\"),'\\n')\n\nprint('When use ravel with Order = F (i.e w.r.t columns)')\nprint(np.ravel(b, order=\"F\"),'\\n')\n\nprint('When use ravel with Order = A')\nprint(np.ravel(b, order=\"A\"),'\\n')\n\nprint('When use ravel with Order = K')\nprint(b.ravel(order=\"K\"),'\\n')  ### Another method to perform ravel","5cc28abf":"##### Transpose on 1D array\na= np.arange(1,10)\nprint(a)\nprint(np.transpose(a))\nprint('Shape of original array',a.shape)\nprint('Shape of transposed array',np.transpose(a).shape)","56ba7619":"a= np.random.randint(100,size= (20))  ### Created a 1D array with 20 elements \nb = a.reshape(5,4) ### reshape that array into 5x4\nprint(\"Original 1D array\")\nprint(a)\nprint()\nprint(\"Original 1D array after reshape\")\nprint(b)\nprint()\nprint(\"reshaped array after being transposed\")\nprint(np.transpose(b))\nprint(\"This rearranged the dimension from 5,4 to 4,5\")\nprint()","acd12071":"### Lets c for 3D array\na= np.arange(1,25).reshape(2,3,4)\nprint('Shape of original array',a.shape)\nprint(a)\nprint()\nprint(\"After transpose check shape of array\")\nprint()\nprint('Shape of transposed array',np.transpose(a).shape)\nprint(np.transpose(a))\nprint()","a86f570d":"### Joining 1D Array\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\narr = np.concatenate((arr1, arr2))\nprint(arr)","c33e5a99":"### Joining 2D array\n\narr1 = np.array([[1, 2], [3, 4]])\narr2 = np.array([[5, 6], [7, 8]])\n\narr = np.concatenate((arr1, arr2), axis=1)\nprint(arr)","2806e481":"arr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\narr = np.stack((arr1, arr2), axis=1)\nprint(arr)","16dffd1c":"### Stacking Along Rows\n# NumPy provides a helper function: hstack() to stack along rows.\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\narr = np.hstack((arr1, arr2))\nprint(arr)\nprint(arr.ndim)","cb3a6b34":"# Stacking Along Columns\n# NumPy provides a helper function: vstack()  to stack along columns.\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\narr = np.vstack((arr1, arr2))\nprint(arr)\nprint(arr.ndim)\nprint(\"we can notice this turned 2 1-D array into 1 2D array\")","73f3eea7":"## Stacking Along Height (depth)\n### NumPy provides a helper function: dstack() to stack along height, which is the same as depth.\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\narr = np.dstack((arr1, arr2))\nprint(arr)\nprint(arr.ndim)\nprint(arr.shape)","91aa0cec":"### Split the array in 3 parts:\n\narr= np.random.randint(100, size=(12))\nnew= np.array_split(arr,3)\nprint(new)","5774c871":"## If you split an array into 3 arrays, you can access them from the result just like any array element:\nnewarr = np.array_split(arr, 3)\n\nprint(newarr[0])\nprint(newarr[1])\nprint(newarr[2])","26962d86":"arr = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\nnewarr = np.array_split(arr, 3)\nprint(newarr)","0700cf60":"## Split the 2-D array into three 2-D arrays along rows.\n\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])\nnewarr = np.array_split(arr, 3, axis=1)\nprint(newarr)","8ba5bb17":"### Use the hsplit() method to split the 2-D array into three 2-D arrays along rows.\n\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])\nnewarr = np.hsplit(arr, 3)\nprint(newarr)","c63c3a6b":"a= np.array([[1,2,3,4,5,6,7,8],[9,10,11,12,13,14,15,16]])\nb= np.array([17,18,19,20,21,22,23,24], dtype='int8')\n\nprint(a, '\\n')\nprint('Shape of a array: ',a.shape)\nprint('Dimension: ',a.ndim)\n\nprint()\nprint(b)","32cb0c68":"print('3rd element of array b:',b[2])","18a55ce6":"print('4th element on 1st row:', a[0, 3],'\\n')\nprint('6th element on 2nd row:', a[1, 5])","31074bc7":"print(b[:]) ### will show complete array\nprint(b[1:5]) ## index 1 to 4 ~~~ 5th Index is excluded\nprint(b[4:])  ## will after 4th index (including 4th)\nprint()\nprint(\"Negative Slicing\")\nprint(\"Use the minus operator to refer to an index from the end\")\nprint(b[-3:])     ## Will print last 3 elements\nprint(b[-3:-1])   ## Will print 2nd last 2 elements","fe514229":"#####~~~~~~~~~~~~~~~~~~~~~~~~~ STEP ~~~~~~~~~~~~~~~~~~~~~~~~~#####\n# Use the step value to determine the step of the slicing:\n\nprint(b)\nprint(b[1:7:2])\nprint(b[::2])  ## Print elements after n no of steps","cd991eeb":"print(a[0:2])   ## Will return complete array\nprint(a[0:1])   ## will only print elements from 1st row\nprint(a[1:2])   ## will only print elements from 2nd row\nprint()\nprint(a[0:2,2]) ## Will return 2nd index of both row\nprint(a[1:2,2]) ## Will return 2nd index of 2nd row\n","fca52a65":"# From both elements, slice index 1 to index 4 (not included), this will return a 2-D array:\nprint(a[0:2, 1:4])","51266b60":"#### Use Where\n\ng= np.array((25,75,85,75,48,95,25,36,789,100,2,256,125,521,-5,6,7,9,21), dtype='int16')  ### Observe the reading with int8\n\nprint(\"Looking for 100 in array\",np.where(g == 100))\nprint(\"Looking for element greater than 100 in array\",np.where(g > 100))\nprint(\"Looking for element greater than equal to 100 in array\",np.where(g >= 100))\nprint()\nprint(\"Index having Even No\", np.where(g%2==0))\nprint(\"Index having Odd No\", np.where(g%2==1))","90cac939":"############~~~~~~~~~~~~~~~~~~~~~~~~ Search Sorted ~~~~~~~~~~~~~~~~~~~~~~~~############\n### searchsorted() method is assumed to be used on sorted arrays.\n\narr = np.array([0,1,2,3,4,5,6,7,8,9, 10, 11, 12, 13, 14])\n\nx = np.searchsorted(arr, 7)\n\nprint('7 is present at index no',x)","7c6609b3":"## The method starts the search from the left and returns the first index where the number 7 is no longer larger than the next value.\n\narr = np.array([0,1,2,3,4,5,6,7,7,7,8,9, 10, 11, 12, 13, 14])\nx = np.searchsorted(arr, 7)\n\nprint(\"Index no\",x)\nprint('searchsorted return only 1 value whereas where() would have returned 3 index values')\nprint(np.where(arr==7))","96bda66a":"### Similary we can search from Right side\nprint(np.searchsorted(arr, 7, side='right'))","dc225c15":"#####~~~~~~~~~~~~~~~~~~~~~~~~~~Multiple Values~~~~~~~~~~~~~~~~~~~~~~~~~~#####\n## To search for more than one value, use an array with the specified values.\nx = np.searchsorted(arr, [2, 4, 6, 7, 15, 20])\nprint(x)  ### For missing values it is giving same index no ","0f161c1f":"### We will sort this array\ng","50f60195":"np.sort(g)","de0293e4":"a = np.array(['zacusi', 'APPLE', 'banana','coconut', 'cherry', 'apple', 'pineapple', 'Apple', 'Cherry'])\nprint(np.sort(a))","96b71ea6":"a = np.array([True, False, True, False, True, False, True, False, False])\nprint(np.sort(a))","ca56c590":"### Sort 2d Array \narr = np.array([[3, 2, 4], [5, 0, 1]])\nprint(np.sort(arr, axis=1))","8f057c17":"print(np.sort(arr, axis=0))","2134a5ea":"### 3D Array Sort ###\n# a= np.array([[[1,2,3,4],[5,6,7,8]],[[9,10,11,12],[13,14,15,16]]])\n\na= np.random.rand(2,2,3)   ### creates float random array\nprint(a)\nprint()\nprint(\"sort array on axis=0\")\nprint(np.sort(a, axis=0))\nprint()\nprint(\"sort array on axis=1\")\nprint(np.sort(a, axis=1))\nprint()\nprint(\"sort array on axis=2\")\nprint(np.sort(a, axis=2))","a3f7c375":"a= np.random.randint(100, size=(2,2,3))   ### creates int random array with elements value less than 100\nprint(a)\nprint()\nprint(\"sort array on axis=0\")\nprint(np.sort(a, axis=0))\nprint()\nprint(\"sort array on axis=1\")\nprint(np.sort(a, axis=1))\nprint()\nprint(\"sort array on axis=2\")\nprint(np.sort(a, axis=2))","fda16f20":"# Iterate on the elements of the following 1-D array:\narr = np.array([1, 2, 3])\n\nfor x in arr:\n  print(x)","397935c6":"## Iterate on the elements of the following 3-D array:\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\nfor x in arr:\n  print(x)\n","acc15bda":"## To return the actual values, the scalars, we have to iterate the arrays in each dimension.  \n### This should be followed for all array above 1D\n\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\nfor x in arr:\n  for y in x:\n    for z in y:\n      print(z)","2720ca91":"### Same thing for 2D\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nfor i in arr:\n    for j in i:\n        print(j)","dc69d134":"arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n\nfor x in np.nditer(arr):\n  print(x)","27f31d23":"arr = np.array([1, 2, 3])\n\nfor x in np.nditer(arr, flags=['buffered'], op_dtypes=['S']):\n  print(x)\n","f3447f7c":"arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n\nfor x in np.nditer(arr[:, ::2]):\n  print(x)\n","af58f738":"arr = np.array([1, 2, 3])\n\nfor idx, x in np.ndenumerate(arr):\n  print(idx, x)","11e22950":"arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n\nfor idx, x in np.ndenumerate(arr):\n  print(idx, x)","591a4ffb":"### Quick python test \n### What will be the output\n\nl=['A','M','A','N']\nstr(l)","23937ccd":"arr = np.array([41, 42, 43, 44])\nx = [True, False, True, False]\n\nnewarr = arr[x]\nprint(newarr)","e105e13b":"#### Create a filter array that will return only values higher than 42:\n\narr = np.array([41, 42, 43, 44])\n\n# Create an empty list\nfilter_arr = []\n\n# go through each element in arr\nfor element in arr:\n  # if the element is higher than 42, set the value to True, otherwise False:\n  if element > 42:\n    filter_arr.append(True)\n  else:\n    filter_arr.append(False)\n\nnewarr = arr[filter_arr]\n\nprint(filter_arr)\nprint(newarr)","16d26b32":"### Q. Create a filter array that will return only even elements from the original array:\n\narr= np.arange(1,20)\nfilter_arg= []\n\nfor i in arr:\n    if i % 2==0:\n        filter_arg.append(True)\n    else:\n        filter_arg.append(False)\n\nnew_arr = arr[filter_arg]\n\nprint(filter_arg)\nprint(new_arr)","39d3a8db":"### Create a filter array that will return only values higher than 42:\n\narr = np.array([41, 42, 43, 44])\n\nfilter_arr = arr > 42\n\nnewarr = arr[filter_arr]\n\nprint(filter_arr)\nprint(newarr)","1645d700":"### Create a filter array that will return only even elements from the original array:\n\narr = np.array([1, 2, 3, 4, 5, 6, 7])\n\nfilter_arr = arr % 2 == 0\n\nnewarr = arr[filter_arr]\n\nprint(filter_arr)\nprint(newarr)","c6a12a1d":"#### In case if u r curious what this \" arr % 2 == 0\" returns\n\narr % 2 == 0","4046e0e2":"from numpy import random  ## NumPy offers the random module to work with random numbers.","b15146eb":"## Generate random no\na = random.randint(777)  ### random no in between 0 and 777\nb = random.rand()  ## random module's rand() method returns a random float between 0 and 1.\nprint('Integer No: ',a)\nprint('Float No: ',b)\nprint('This create new no every time we run this code, to create same output everytime we need random.seed')","09e355df":"print('1st run',np.random.rand(4))\nprint('2nd run',np.random.rand(4))\nprint('Now Lets use random.seed')\nnp.random.seed(7)\nprint('1st run',np.random.rand(4))\nnp.random.seed(7)\nprint('2nd run',np.random.rand(4))","992878c6":"## Generate a 1-D array containing 5 random integers from 0 to 100:\nrandom.randint(100, size=(5))","2b84b141":"# Generate a 2-D array with 3 rows, each row containing 5 random integers from 0 to 100:\nrandom.randint(100, size=(3, 5))","8765d041":"# Generate a 3-D array with 3,2,5:\nrandom.randint(100, size=(3,2,5))","e58e0b9b":"random.choice([3, 6, 9, 12, 15, 18, 21]) ### Will choose from an array of 7","060bb154":"random.choice(100,size=(5))\n# What is the difference between this and random.randint(100, size=5)","70768635":"# Generate a 2-D array that consists of the values in the array parameter (3, 6, 9, 12, 15, 18 and 21):\nrandom.choice([3, 6, 9, 12, 15, 18, 21], size=(3, 5))","150a8d81":"# Shuffle means changing arrangement of elements in-place. i.e. in the array itself.\n\narr = np.array([1, 2, 3, 4, 5])\nrandom.shuffle(arr)  ## The shuffle() method makes changes to the original array.\nprint('1st try',arr)\n\nrandom.shuffle(arr)\nprint('2nd try',arr)\n\nrandom.shuffle(arr)\nprint('3rd try',arr)\nprint(\"each this is also random\")","2ad6ef2c":"## Generating Permutation of Arrays\n\narr = np.array([1, 2, 3, 4, 5])\nprint(random.permutation(arr))  ### The permutation() method returns a re-arranged array (and leaves the original array un-changed).","7a82da2e":"### Enumerated Iteration Using ndenumerate()\n\n* Enumeration means mentioning sequence number of somethings one by one.\n* Sometimes we require corresponding index of the element while iterating, the ndenumerate() method can be used for those usecases.","5673026b":"### Generate Random Number From Array\n* The **choice()** method allows you to generate a random value based on an array of values.\n* The *choice()* method takes an array as a parameter and randomly returns one of the values.\n* The choice() method also allows you to return an array of values.\n* ***size*** parameter to specify the shape of the array.","1f051fd3":"# Iteration\n* Iterating means going through elements one by one.\n* As we deal with multi-dimensional arrays in numpy, we can do this using basic for loop of python.\n* `NOTE:` ***If we iterate on a n-D array it will go through n-1th dimension one by one.***","22936d93":"`NOTE:` We also have the method split() available but it will not adjust the elements when elements are less in source array for splitting like in example above, array_split() worked properly but split() would fail.","5af816e2":"## np.dot() VS np.mutmul()\nIn Python, arrays are treated as vectors. 2-D arrays are also called matrices. We have functions available to carry out multiplication between them in Python. The two methods used are the numpy.dot() function and the @ operator (the array\u2019s __matmul__ method). Now it may seem that they both perform the same function of multiplication. However, there is some difference between both of them, which is explained in this tutorial.\nThe numpy.dot() function is used for performing matrix multiplication in Python. It also checks the condition for matrix multiplication, that is, the number of columns of the first matrix must be equal to the number of the rows of the second. It works with multi-dimensional arrays also. We can also specify an alternate array as a parameter to store the result. The @ operator for multiplication invokes the matmul() function of an array that is used to perform the same multiplication","6dc94c2e":"# Numpy Data Type\n\nBy default Python have these data types:\n\n* strings - used to represent text data, the text is given under quote marks. e.g. \"ABCD\"\n* integer - used to represent integer numbers. e.g. -1, -2, -3\n* float - used to represent real numbers. e.g. 1.2, 42.42\n* boolean - used to represent True or False.\n* complex - used to represent complex numbers. e.g. 1.0 + 2.0j, 1.5 + 2.5j\n\nNumPy has some extra data types, and refer to data types with one character, like i for integers, u for unsigned integers etc.  \nBelow is a list of all data types in NumPy and the characters used to represent them.\n\n* i - integer\n* b - boolean\n* u - unsigned integer\n* f - float\n* c - complex float\n* m - timedelta\n* M - datetime\n* O - object\n* S - string\n* U - unicode string\n* V - fixed chunk of memory for other type ( void )","7aa63086":"> #### Can we create an mix array\n a= np.array([['a', 'b', 'n', 'k', 'j', 'A'],[1,2,3,4,5,6,7]])\n![numpy error.PNG](attachment:5d6be8ac-76cf-410b-aabf-fc59536677c9.PNG)","4ccac83d":"### Splitting Numpy Arrays\n\n* Splitting is reverse operation of Joining.\n* Joining merges multiple arrays into one and Splitting breaks one array into multiple.\n* We use array_split() for splitting arrays, we pass it the array we want to split and the number of splits.\n\n1. np.array_split(array_name, no of parts)  `Note: The return value is an array containing three arrays.`\n> The return value of the array_split() method is an array containing each of the split as an array.  \n If you split an array into 3 arrays, you can access them from the result just like any array element:","4a208bce":"## Sorting Array\n\n* Sorting means putting elements in an ordered sequence.\n* Ordered sequence is any sequence that has an order corresponding to elements, like numeric or alphabetical, ascending or descending.\n* The NumPy ndarray object has a function called sort(), that will sort a specified array.  \n`NOTE:` **np.sort() method returns a copy of the array, leaving the original array unchanged.**","7f2d53a2":"Did u get it???  \n* By counting the no of brackets\n* Also even if u use tuple array will use Square bracket only ","72e62fb4":"### Other methods to create numpy arrays","371f038b":"## Dimensions in Arrays\n* A dimension in arrays is one level of array depth (nested arrays).\n* Nested array: are arrays that have arrays as their elements.","a2c06ba8":"### Iterating Array With Different Data Types\n\nWe can use op_dtypes argument and pass it the expected datatype to change the datatype of elements while iterating.\n\nNumPy does not change the data type of the element in-place (where the element is in array) so it needs some other space to perform this action, that extra space is called buffer, and in order to enable it in nditer() we pass flags=['buffered'].","3914dc88":"An alternate solution is using `hsplit()` opposite of `hstack()`","66a20397":"### Creating Filter Directly From Array\n\n* The above example is quite a common task in NumPy and NumPy provides a nice way to tackle it.\n* We can directly substitute the array instead of the iterable variable in our condition and it will work just as we expect it to.","225f18fc":"### Iterating Arrays Using nditer()\n\nThe **function nditer()** is a `helping function` that can be used from very basic to very advanced iterations. *It solves some basic issues which we face in iteratio*n, lets go through it with examples.\n\n* Iterating on Each Scalar Element\n* In basic for loops, iterating through each scalar of an array we need to use n for loops which can be difficult to write for arrays with very high dimensionality.","b4a9119b":"#### Multiplication & Divide\n1. np.dot() : numpy.dot(vector_a, vector_b, out = None) returns the dot product of vectors a and b. It can handle 2D arrays but considers them as matrix and will perform matrix multiplication. For N dimensions it is a sum-product over the last axis of a and the second-to-last of b :\n        + vector_a : [array_like] if a is complex its complex conjugate is used for the calculation of the dot product. \n        + vector_b : [array_like] if b is complex its complex conjugate is used for the calculation of the dot product. \n        + out : [array, optional] output argument must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). \n        + Return: **Dot Product of vectors a and b. if vector_a and vector_b are 1D, then scalar is returned**","7c8b6e1f":"# Random Permutations of Elements\n\n* A permutation refers to an arrangement of elements. e.g. [3, 2, 1] is a permutation of [1, 2, 3] and vice-versa.\n* The NumPy Random module provides two methods for this: shuffle() and permutation().","f0673339":"![convert array error.PNG](attachment:c20b8b00-f6d9-4782-b82f-57d5581e741e.PNG)","b5d2e54c":"### Iterating With Different Step Size\n","35280d7e":"# Creating Random Array","18392b28":"#### Can we sort words and booleans?","19900a64":"### Highlights of what we will use in this notebook\n1. array()   :: Create Array\n2. type()    :: Get Type\n3. dtype()   :: Get Data type\n4. ndim()    :: Get Dimension\n5. shape     :: Get Shape\n5. itemsize  :: Get Size(returns in bytes), Length of one array element in bytes.\n6. nbytes    :: Total Bytes consumed by elements of the array\n7. reshape   :: By reshaping we can add or remove dimensions or change number of elements in each dimension.\n\n* NumPy arrays have an attribute called **shape** that returns a tuple with each index having the number of corresponding elements","8aec3b55":"When the expression `arr2 + arr4` is evaluated, `arr4` (which has the shape `(4,)`) is replicated three times to match the shape `(3, 4)` of `arr2`. Numpy performs the replication without actually creating three copies of the smaller dimension array, thus improving performance and using lower memory.\n\n<img src=\"https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/figures\/02.05-broadcasting.png\" width=\"360\">\n\nBroadcasting only works if one of the arrays can be replicated to match the other array's shape.","9bb33d36":"# Array Manipulation \n## `Flatten` and `Ravel`\n1. **Flatten method** : Returns a copy of array collapsed into 1D so if we give nD (2D,3D,4D,...ND) this will return. This method will return a copy of the array collapsed into 1D array.\n> Syntax: ndaary_name.flatten(order) and by `default order value = C` Order can be picked from C, A, F, K\n        C:  Flatten the array into row major order\n        A:  Flatten in column major order if array is Fortran contagious in memorry, row major otherwise\n        F:  Flatten in **Column major**\n        K: Flatten in order the elements occur in memory\n       \n2. **Ravel Function** : This is also used to flatten the array. ***Input is returned but a copy is made only if needed***, `However in flatten method it will give the copy of array but in this function it will copy only when needed, It will give the view of the array`\n> syntax: `numpy.ravel(array_name, order)` :: by default order=C\n\nDifference\n\n| Flatten       | Ravel         |\n| ------------- |:-------------:|\n| Returns a copy of array     | rreturn the copy only when needed, other wise it will give view of error | \n| -     | Ravel function is only **reference or view of original array**      |\n| Flatten is a **method** of nd array object | **Library level** function |\n| This is why we can't write np.flatten() as it is not a function | where as we can write np.ravel()|","eb9393f5":"## Searching and Sorting\n\n### We can seach an array for certain values, and return the indexes that get a match with the help of `where()` method\n#### We can also use `searchsorted()` method which performs a binary search in an array and return the index where specified value would be inserted to maintain the search order. The searchsorted() method is assumed to be used on sorted arrays.\n#### `Search from right side` By default the left most index is returned, but we can give side='right' to return the right most index instead.\n#### `Multiple Values` To search for more than one value, use an array with the specified values.\n\n\n### Sorting means putting elements in an ordered sequence. Ordered sequence is any sequence that has an order corresponding to elements, like numeric or alphabetical, ascending or descending. The NumPy ndarray object has a function called sort(), that will sort a specified array.\n#### `NOTE:` This method returns a copy of the array, leaving the original array unchanged.\n\n![2-Dimensional-sort-axis-none.jpg](attachment:2d6600d4-f126-4aec-ad88-6c9bf358ca32.jpg)\n\n![numpy-sort.png](attachment:a70d4bb4-f6f4-4633-95e1-1585e91923ca.png)","64775cda":"# Operating on Numpy arrays\n\nWe can now compute the dot product of the two vectors using the `np.dot` function.","89af3065":"## Q. What is Random\n* Random number does NOT mean a different number every time. Random means something that can not be predicted logically.\n\n## Pseudo Random and True Random\n![apple ipod bias.PNG](attachment:0736288d-001f-487f-9666-80c1aed0d613.PNG)\n[link](https:\/\/forums.macrumors.com\/threads\/ipod-classics-shuffle-songs-feature-is-not-random-at-all-same-artists-often.1127298\/)\n\n* Computers work on programs, and programs are definitive set of instructions. So it means there must be some algorithm to generate a random number as well.\n* If there is a program to generate random number it can be predicted, thus it is not truly random.\n* Random numbers generated through a generation algorithm are called pseudo random.\n\n### Can we make truly random numbers?\n> Yes. In order to generate a truly random number on our computers we need to get the random data from some outside source. This outside source is generally our keystrokes, mouse movements, data on network etc.\n\n**Note:** `We do not need truly random numbers, unless its related to security (e.g. encryption keys) or the basis of application is the randomness (e.g. Digital roulette wheels).`","68d9d82a":"# Array Indexing and Slicing\n\n* Array indexing is the same as accessing an array element.\n* You can access an array element by referring to its index number.\n* The indexes in NumPy arrays start with 0, meaning that the first element has index 0, and the second has index 1 etc.\n\n![indexing and slicing.PNG](attachment:bb0bdc43-1d78-4dcb-aef1-f53cfca50ce5.PNG)","7adbe665":"```python\narr2 + arr3\n```\n\n**We can't add matrix with different dimension nor can we substract** We need to use broadcasting  \n![error matrix addition.PNG](attachment:7f5e37e4-c126-41a6-a472-278718bf29fc.PNG)","55ba345f":"#### ADD SUB","8ba4fce2":"# Numpy ( Numerical Python )\n \n **Numpy is a multi-dimensional array libray**\n\n1. Why Use Numpy?\n    * In Python we have lists that serve the purpose of arrays, but they are slow to process.\n    * NumPy aims to provide an array object that is up to 50x faster than traditional Python lists.\n    * The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.\n    * Arrays are very frequently used in data science, where speed and resources are very important.\n  \n  \n2. Why is NumPy Faster Than Lists? or Why use Numpy over List?\n    * NumPy arrays are stored at one continuous place in memory unlike lists, so processes can access and manipulate them very efficiently.\n    * This behavior is called locality of reference in computer science.\n    * This is the main reason why **NumPy is faster than lists.** Also it is **optimized to work with latest CPU architectures.** \n    * Numpy is fast because it uses fixed types\n    \n3. Why Numpy used for numerical computation in python?\n    * NumPy internally stores data in a contiguous block of memory, independent of other built-in Python objects. NumPy\u2019s library of algorithms written in the C language can operate on this memory without any type checking or other overhead. NumPy arrays also use much less memory than built-in Python sequences.\n    * **NumPy operations perform complex computations on entire arrays without the need for Python for loops.**\n\n**NOTE:** `NumPy is a Python library and is written partially in Python, but most of the parts that require fast computation are written in C or C++.`  \n          `NumPy has a whole sub module dedicated towards matrix operations called numpy.mat`\n          \n### Fun Facts about Numpy\n\u2022 ndarray, an efficient multidimensional array providing fast array-oriented arithmetic operations and flexible broadcasting capabilities.  \n\u2022 Mathematical functions for fast operations on entire arrays of data without having to write loops.  \n\u2022 Tools for reading\/writing array data to disk and working with memory-mapped files.  \n\u2022 Linear algebra, random number generation, and Fourier transform capabilities.  \n\u2022 A C API for connecting NumPy with libraries written in C, C++, or FORTRAN.  \n\n## Application of Numpy\n1. Mathematics (Matplab Replacement)\n2. Plotting Matplotlib\n3. Backend (of pandas, connect4, Digital Photography {Later on we will see how we can represent an image in form of array})\n4. Machine Learning and Deep Learning (Idea of tensors infact Tensor is quite similar to Numpy Library)\n\n### As a analyst Numpy is used for\n\u2022 Fast vectorized array operations for data munging and cleaning, subsetting and filtering, transformation, and any other kinds of computations  \n\u2022 Common array algorithms like sorting, unique, and set operations    \n\u2022 Efficient descriptive statistics and aggregating\/summarizing data   \n\u2022 Data alignment and relational data manipulations for merging and joining together heterogeneous datasets  \n\u2022 Expressing conditional logic as array expressions instead of loops with if-elif-else branches  \n\u2022 Group-wise data manipulations (aggregation, transformation, function application)","e2da6d7f":"# 1. Array Creation","ce953212":"## `Join` & `Split`\n\n### Joining Numpy Arrays\n* Joining means putting contents of two or more arrays in a single array.\n* In *SQL we join tables* `based on a key`, whereas in NumPy we join `arrays by axes`.\n* We pass a sequence of arrays that we want to join to the **concatenate()** function, along with the axis. If axis is not explicitly passed, it is taken as 0.","5a0d7813":"np.random.seed(n) :: n is any integer no >> random.seed `makes the random numbers predictable`\n* With the seed reset (every time), the same set of numbers will appear every time.\n* If the random seed is not reset, different numbers appear with every invocation:\n\n![random seed.PNG](attachment:b978ab92-008f-4462-acd8-7f5922f4497f.PNG)\n\n![use of random seed.PNG](attachment:eb9fe95a-de8d-4fbb-83ec-74528aa121ad.PNG)\n\n(pseudo-)random numbers work by starting with a number (the seed), multiplying it by a large number, adding an offset, then taking modulo of that sum. The resulting number is then used as the seed to generate the next \"random\" number. When you set the seed (every time), it does the same thing every time, giving you the same numbers.  \n\nIf you want seemingly random numbers, do not set the seed. If you have code that uses random numbers that you want to debug, however, it can be very helpful to set the seed before each run so that the code does the same thing every time you run it.  \n\nTo get the most random numbers for each run, call numpy.random.seed(). This will cause numpy to set the seed to a random number obtained from \/dev\/urandom or its Windows analog or, if neither of those is available, it will use the clock.  \n[read more Wikipedia](https:\/\/en.wikipedia.org\/wiki\/Random_number_generation#Computational_methods)","cf2a3fb3":"While reshaping be cautious 4x3 , 3x4 or 2x6 might work for 12 element array  \nbut not 2x5 or 3x3 as these product to 10 and 9 respectively.","7d1388c2":"# Random","062c22ae":"## Filter\n\n* Getting some elements out of an existing array and creating a new array out of them is called filtering.\n* In NumPy, you filter an array using a boolean index list.\n* A boolean index list is a list of booleans corresponding to indexes in the array.\n> If the value at an index is True that element is contained in the filtered array, if the value at that index is False that element is excluded from the filtered array.\n","8a284543":"Q. Why only 41 and 43?  \nBecause the new filter contains only the values where the filter array had the value True, in this case, index 0 and 2.","2fcec64b":"#### `NOTE:` ***Similar alternates to `vstack()` and `dstack()` are available as `vsplit()` and `dsplit()`.***","c768713f":"## Reshape numpy array\n1. reshape() function : This gives new shape to array **without changing it's data** \n> syntax: np.reshape(`array, shape, order`) or arrayname.reshape(`shape, order`)  \n> returns: ndaarry with mentioned shape , Returned ndarray elements may be copy od the original elements or view of original array elements.\n2. resize() function : This will change the **Data of array** , Thus we can mention any `size, shape` it will resize the array according to that shape\n> numpy.resize(`arrayname, shape`)     \n\n>It will return a ndarray: The new array is formed from the data in the old array, repeated if required to fillout the element of required elements. ***Data is repeated in order they are stored in a memory***","aa762279":"### Slicing\n\n* Slicing in python **means taking elements from one given index to another given index.**\n* We pass slice instead of index like this: [start:end].\n* We can also define the step, like this: [start:end:step].\n* If we don't pass start its considered 0\n* If we don't pass end its considered length of array in that dimension\n* If we don't pass step its considered 1\n\n***NOTE:*** `The result includes the start index, but excludes the end index.`","654e8218":"# Array Broadcasting\n\nNumpy arrays also support *broadcasting*, allowing arithmetic operations between two arrays with different numbers of dimensions but compatible shapes. Let's look at an example to see how it works.","f0871286":"## `Transpose` & `Swapaxes`\n\n![download (1).png](attachment:07947aea-e93d-4b55-9cbf-ad8a2a40e340.png)  ![download.png](attachment:5e986c36-7314-49ac-b428-1955efa7c3a1.png)\n\n1. **Transpose()** function: Transposition is a special form of data reorganization that can return to the view of the underlying data without copying any content. The array has a transpose method and a special T attribute. `.T` is the simplest transposition attribute and the basis of all transpositions.\n> or numpy.transpose(array_name, axes= None) :: None is default  ` This won't copy the data but would give view of original array`\n\n\n2. **Swapaxes()** function:  This function swaps the two axes of the array, returns a view of the swap array, and does not copy the data. This method is **different from transpose in that it receives a pair of axis numbers as parameters and performs axis transposition**.\n> Syntax: `numpy . swapaxes ( arr , axis1 , axis2 )`             # (array to be swapped, axis number)   \n**Returns**\na_swappedndarray For NumPy >= 1.10.0, if a is an ndarray, then a view of a is returned; otherwise a new array is created. For earlier NumPy versions a view of a is returned only if the order of the axes is changed, otherwise the input array is returned.","e3c7a105":"It should have returned 9th position but retuned 8th because\n> The method starts the search from the right and returns the first index where the number 7 is no longer less than the next value.","7c4df755":"### Joining Arrays Using Stack Functions\n\n* Stacking is same as concatenation, the **only difference is that stacking is done along a new axis**.\n* `We can concatenate two 1-D arrays along the second axis which would result in putting them one over the other, ie. stacking.`\n* We pass a sequence of arrays that we want to join to the stack() method along with the axis. If axis is not explicitly passed it is taken as 0.","eb87a8de":"# Array\n\nNumPy is used to work with arrays. The array object in NumPy is called ndarray.\n\n![numpy_arrays-1024x572.png](attachment:3a659304-3332-4016-9899-7033e41bcb42.png)\n\n\n***What is Broadcasting?***\nThe purpose of broadcasting is to facilitate the operation of matrices. so what is broadcasting? \uff1f when the matrix is added and subtracted, when the two matrix dimensions do not match \uff0c will trigger the broadcast mechanism. let's take a look at the picture below.\n![numpy_broadcasting.png](attachment:ae5c6e54-8267-4829-92d2-6354b812442a.png)\n\n![adding-different-size-matrices.jpg](attachment:dbdc28f4-1f91-40f4-9e45-34811fd15941.jpg)\n![Dimensions+are+not+the+same..jpg](attachment:49b78b16-20a1-49ca-b252-f82b98a71b9a.jpg)\n\n","4df428d1":"#### Converting Data Type on Existing Arrays\nThe best way to change the data type of an existing array, is to make a copy of the array with the astype() method.\n\nThe astype() function creates a copy of the array, and allows you to specify the data type as a parameter.\n\nThe data type can be specified using a string, like 'f' for float, 'i' for integer etc. or you can use the data type directly like float for float and int for integer.","32553f34":"### Q. How would u find dimension of array by just looking at it?","8b3deb24":"#### Splitting 2-D Arrays\n* Use the same syntax when splitting 2-D arrays.\n* Use the `array_split()` method, pass in the array you want to split and the number of splits you want to do."}}