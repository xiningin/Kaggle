{"cell_type":{"249db904":"code","c6111e9e":"code","1faec8e8":"code","0b1643b3":"code","9da299ce":"code","265ab343":"code","c92f536f":"code","159a12d5":"code","8eef9cde":"code","3635d906":"code","fa88ec59":"code","16735747":"code","b5c9970d":"code","25464844":"markdown","99bb9cd2":"markdown"},"source":{"249db904":"#@title Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.","c6111e9e":"from __future__ import absolute_import, division, print_function, unicode_literals\n\n# !pip install tensorflow-gpu==2.0.0-alpha0\nimport tensorflow as tf\nfrom tensorflow.keras import regularizers\nfrom tensorflow.keras.layers import Input, Dense\nfrom tensorflow.keras.models import Model, load_model, save_model\nfrom tensorflow.keras.callbacks import EarlyStopping\n\nimport os\nimport time\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nfrom keras.preprocessing.image import img_to_array, load_img\nfrom random import shuffle\nimport PIL\nimport json\nimport numpy as np\nimport sys\nnp.set_printoptions(threshold=sys.maxsize)\nimport matplotlib.pyplot as plt\nimport matplotlib\n# matplotlib.use('TKAgg')\n%matplotlib inline","1faec8e8":"input_data_folder = \"..\/input\/midcurvenn\/images\"","0b1643b3":"def read_input_image_pairs(datafolder=input_data_folder):\n    profile_pngs = []\n    midcurve_pngs = []\n    for file in os.listdir(datafolder):\n        fullpath = os.path.join(datafolder, file)\n        if os.path.isdir(fullpath):\n            continue\n        if file.endswith(\".png\"):\n            if file.find(\"Profile\") != -1:\n                profile_pngs.append(fullpath)\n            if file.find(\"Midcurve\") != -1:\n                midcurve_pngs.append(fullpath)\n    profile_pngs = sorted(profile_pngs)\n    midcurve_pngs = sorted(midcurve_pngs)\n    return profile_pngs,midcurve_pngs","9da299ce":"def get_training_data(datafolder = input_data_folder):\n    profile_pngs,midcurve_pngs = read_input_image_pairs(datafolder)\n    \n    profile_pngs_objs = [img_to_array(load_img(f, color_mode='rgba', target_size=(100, 100))) for f in profile_pngs ]\n    midcurve_pngs_objs = [img_to_array(load_img(f, color_mode='rgba', target_size=(100, 100))) for f in midcurve_pngs]\n\n    profile_pngs_gray_objs = [x[:,:,3] for x in profile_pngs_objs]\n    midcurve_pngs_gray_objs =[x[:,:,3] for x in midcurve_pngs_objs]\n    \n        \n    # shufle them\n    zipped_profiles_midcurves = [(p,m) for p,m in zip(profile_pngs_gray_objs,midcurve_pngs_gray_objs)]\n    shuffle(zipped_profiles_midcurves)\n    profile_pngs_gray_objs, midcurve_pngs_gray_objs = zip(*zipped_profiles_midcurves)\n    \n    return profile_pngs_gray_objs, midcurve_pngs_gray_objs","265ab343":"profile_pngs_objs, midcurve_pngs_objs = get_training_data()","c92f536f":"def plot_results(original_imgs,computed_imgs):\n    n = 10  # how many digits we will display\n    plt.figure(figsize=(20, 4))\n    for i in range(n):\n        # display original\n        ax = plt.subplot(2, n, i + 1)\n        plt.imshow(original_imgs[i].reshape(100, 100),cmap='gray_r')\n        ax.get_xaxis().set_visible(False)\n        ax.get_yaxis().set_visible(False)\n    \n        # display reconstruction\n        ax = plt.subplot(2, n, i + 1 + n)\n        plt.imshow(computed_imgs[i].reshape(100, 100),cmap='gray_r')\n        ax.get_xaxis().set_visible(False)\n        ax.get_yaxis().set_visible(False)\n    plt.show()","159a12d5":"plot_results(profile_pngs_objs,midcurve_pngs_objs)","8eef9cde":"from keras import regularizers\nfrom keras.layers import Input, Dense\nfrom keras.models import Model, load_model\nimport os\nimport numpy as np\nimport sys\nimport random\n\nnp.set_printoptions(threshold=sys.maxsize)\n\nclass simple_encoderdecoder:\n    def __init__(self):\n        self.encoding_dim = 100\n        self.input_dim = 10000\n        self.epochs = 200\n        self.batch_size = 5\n        self.autoencoder_model_pkl = \"models\/autoencoder_model.pkl\"\n        self.encoder_model_pkl = \"models\/encoder_model.pkl\"\n        self.decoder_model_pkl = \"models\/decoder_model.pkl\"\n                \n    def process_images(self,grayobjs):\n        flat_objs = [x.reshape(self.input_dim) for x in grayobjs]\n        pngs_objs = np.array(flat_objs)\n        return pngs_objs\n\n    def train(self,\n            profile_pngs_gray_objs, \n            midcurve_pngs_gray_objs,\n            retrain_model=False):\n        \n        if not os.path.exists(self.autoencoder_model_pkl) or retrain_model:\n            # this is our input placeholder\n            input_img = Input(shape=(self.input_dim,))\n            \n            # \"encoded\" is the encoded representation of the input\n            encoded = Dense(self.encoding_dim, activation='relu',activity_regularizer=regularizers.l1(10e-5))(input_img)\n            # \"decoded\" is the lossy reconstruction of the input\n            decoded = Dense(self.input_dim, activation='sigmoid')(encoded) \n            \n            # Model 1: Full AutoEncoder, includes both encoder single dense layer and decoder single dense layer. \n            # This model maps an input to its reconstruction\n            self.autoencoder = Model(input_img, decoded)\n                    \n            # Model 2: a separate encoder model: -------------------\n            # this model maps an input to its encoded representation\n            self.encoder = Model(input_img, encoded)\n            \n            # Model 3: a separate encoder model: -------------------\n            # create a placeholder for an encoded (32-dimensional) input\n            encoded_input = Input(shape=(self.encoding_dim,))\n            # retrieve the last layer of the autoencoder model\n            decoder_layer = self.autoencoder.layers[-1]\n            # create the decoder model\n            self.decoder = Model(encoded_input, decoder_layer(encoded_input))\n            \n            # Compilation of Autoencoder (only)\n            self.autoencoder.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n\n            profile_pngs_objs = self.process_images(profile_pngs_gray_objs)\n            midcurve_pngs_objs = self.process_images(midcurve_pngs_gray_objs)\n            \n\n            es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=50)\n            self.x = profile_pngs_objs\n            self.y = midcurve_pngs_objs\n            self.autoencoder.fit(self.x, self.y,\n                        epochs=self.epochs,\n                        batch_size=self.batch_size,\n                        validation_split=0.3,\n                        callbacks=[es],                                 \n                        shuffle=True)                \n            # Save models\n            save_model(self.autoencoder,\n                       self.autoencoder_model_pkl)  # self.autoencoder.save(self.autoencoder_model_pkl)\n            save_model(self.encoder, self.encoder_model_pkl)  # self.encoder.save(self.encoder_model_pkl)\n            save_model(self.decoder, self.decoder_model_pkl)  # self.decoder.save(self.decoder_model_pkl)\n        else:\n            # Save models\n            self.autoencoder = load_model(self.autoencoder_model_pkl)\n            self.encoder= load_model(self.encoder_model_pkl)\n            self.decoder = load_model(self.decoder_model_pkl)\n    \n    def predict(self, test_profile_images):\n        png_profile_images = self.process_images(test_profile_images)\n        encoded_imgs = self.encoder.predict(png_profile_images)\n        decoded_imgs = self.decoder.predict(encoded_imgs)    \n        return test_profile_images,decoded_imgs  ","3635d906":"profile_gray_objs, midcurve_gray_objs = get_training_data()\nprofile_gray_objs = np.asarray(profile_gray_objs) \/ 255.\nmidcurve_gray_objs = np.asarray(midcurve_gray_objs) \/ 255.\n\nendec = simple_encoderdecoder()\n\nendec.train(profile_gray_objs, midcurve_gray_objs)","fa88ec59":"test_gray_images = random.sample(list(profile_gray_objs),10)","16735747":"original_profile_imgs,predicted_midcurve_imgs = endec.predict(test_gray_images)\n","b5c9970d":"plot_results(original_profile_imgs,predicted_midcurve_imgs)","25464844":"## Installations","99bb9cd2":"# Simple EncoderDecoder\n\nRefer https:\/\/github.com\/yogeshhk\/MidcurveNN for more details, for now"}}