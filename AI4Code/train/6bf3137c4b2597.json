{"cell_type":{"c7de77bc":"code","98819f34":"code","079a326b":"code","de055537":"code","6b3d3229":"code","0aeefe2d":"code","63caebaa":"code","292db07b":"code","dbd402b0":"code","4558c202":"code","b32dfbeb":"code","e72fb90a":"code","b63c0236":"code","a80efefb":"code","a87ca6f5":"code","9e79790c":"code","b7fff46b":"code","fcf41eff":"code","4a59a2a6":"code","9bef6211":"code","6933df08":"code","0a98cfa9":"code","bf4f42f0":"code","a83721e1":"code","0cee03e9":"markdown","35f4bbde":"markdown","6215565b":"markdown","b6943a56":"markdown","e22b98a9":"markdown","57d40283":"markdown","76286ef5":"markdown","8706b487":"markdown","6df42038":"markdown","ce2772cd":"markdown","970e27d7":"markdown","9d08d747":"markdown"},"source":{"c7de77bc":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","98819f34":"# Import\naq_auser = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Auser.csv\")\naq_doganella = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Doganella.csv\")\naq_luco = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Luco.csv\")\naq_petrignago = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Petrignano.csv\")\nlakeBilancino = pd.read_csv(\"..\/input\/acea-water-prediction\/Lake_Bilancino.csv\")\nriverArno = pd.read_csv(\"..\/input\/acea-water-prediction\/River_Arno.csv\")\nws_Amiata = pd.read_csv(\"..\/input\/acea-water-prediction\/Water_Spring_Amiata.csv\")\nws_Lupa = pd.read_csv(\"..\/input\/acea-water-prediction\/Water_Spring_Lupa.csv\")\nws_Madonna = pd.read_csv(\"..\/input\/acea-water-prediction\/Water_Spring_Madonna_di_Canneto.csv\")\n","079a326b":"riverArno","de055537":"def datumsplit(data,datumvar,isnafilter,diff,pref):\n\n\n    #drop empty data, loosing that info leaves us with the available data\n    data=data[data[isnafilter].isna()==False].reset_index()    \n    #split date in components for regression, this way one can discover seasonal, week, year effects\n    column_1=pd.to_datetime(data[datumvar],format='%d\/%m\/%Y')\n    temp=pd.DataFrame({pref+\"year\": column_1.dt.year,\n                  pref+\"month\": column_1.dt.month,\n                  pref+\"day\": column_1.dt.day,\n                  #\"hour\": column_1.dt.hour,\n                  #pref+\"dayofyear\": column_1.dt.dayofyear,\n                  pref+\"week\": column_1.dt.week,\n                  pref+\"weekofyear\": column_1.dt.weekofyear,\n                  pref+\"dayofweek\": column_1.dt.dayofweek,\n                  pref+\"weekday\": column_1.dt.weekday,\n                  pref+\"quarter\": column_1.dt.quarter,\n                 })\n\n\n    #drop date since you cannot regress a date\n    datalabel=data[isnafilter]\n    data=data.drop([datumvar,isnafilter],axis=1)\n    #move the information of (diff=1) yesterday one day foreward and add  the columns\n    data2=data[diff:]\n    for ki in data.columns:\n        data2[ki+'_lag'+str(diff)]=data[:-diff][ki].values\n    #add splitted date\n    for ki in temp.columns:\n        data2[ki]=temp[diff:][ki].values  \n    #add moving average to dataset (moving average filters noise)\n    temp=data.rolling(diff*5,).mean()\n    for ki in data.columns:\n        data2[ki+'_MA5*'+str(diff)]=temp[:-diff][ki].values\n    data2[isnafilter]=datalabel[diff:]\n    print(data.shape,data2.shape)\n    return data2\n\ntrain=datumsplit(riverArno,'Date','Hydrometry_Nave_di_Rosano',1,'ext_')\ntrain","6b3d3229":"    from statsmodels.tsa.statespace.sarimax import SARIMAX\n    from statsmodels.graphics.tsaplots import plot_acf\n    from statsmodels.graphics.tsaplots import plot_pacf\n    from statsmodels.tsa.stattools import adfuller\n    from sklearn.metrics import mean_squared_error\n    from math import sqrt\n    \n\n    label='Hydrometry_Nave_di_Rosano'\n\n    isnafilter='Rainfall_Le_Croci'\n    # Find  by Date\/Time not na\n    train=riverArno[riverArno[isnafilter].isna()==False]\n\n    day_df = train[['Date',label]]\n    # setting Date\/Time as index\n    day_df.index = pd.DatetimeIndex(day_df.Date)\n    # Resampling to daily trips\n    day_df = day_df.resample('1D').apply(np.sum)\n\n    day_df.plot()\n","0aeefe2d":"##Checking trend and autocorrelation\ndef initial_plots(time_series, num_lag):\n    import matplotlib.pyplot as plt\n\n    #Original timeseries plot\n    plt.figure(1)\n    plt.plot(time_series)\n    plt.title('Original data across time')\n    plt.figure(2)\n    plot_acf(time_series, lags = num_lag)\n    plt.title('Autocorrelation plot')\n    plot_pacf(time_series, lags = num_lag)\n    plt.title('Partial autocorrelation plot')\n    \n    plt.show()\n\n    \n#Augmented Dickey-Fuller test for stationarity\n#checking p-value\nprint('p-value: {}'.format(adfuller(day_df)[1]))\n\n#plotting\ninitial_plots(day_df, 45)","63caebaa":"#storing differenced series\ndiff_series = day_df.diff(periods=1)\n\n#Augmented Dickey-Fuller test for stationarity\n#checking p-value\nprint('p-value: {}'.format(adfuller(diff_series.dropna())[1]))\n\n\ninitial_plots(diff_series.dropna(), 45)","292db07b":"train","dbd402b0":"    if True:\n        !pip install dabl\n        import dabl\n        #data = dabl.clean(train, verbose=1)\n        #dabl.plot(data.drop('Hydrometry_Nave_di_Rosano',axis=1), data['Hydrometry_Nave_di_Rosano'])\n        #model = dabl.SimpleClassifier(random_state=0).fit(data.fillna(0), target_col=\"Hydrometry_Nave_di_Rosano\")","4558c202":"#train[['index','Rainfall_Le_Croci','Rainfall_Le_Croci_1']]","b32dfbeb":"\ndef aquaforecast(aqua,label,indxvar,dropvalue,diff,dayahead):\n    # prepare data with datesplit function see above\n    train=datumsplit(aqua,'Date',dropvalue,diff,'ext_')\n    # split train test with number of day ahead\n    if True:\n        #!pip install dabl\n        #import dabl\n        train = dabl.clean(train, verbose=1)\n        dabl.plot(train.drop(label,axis=1), train[label])\n        #model = dabl.SimpleClassifier(random_state=0).fit(data.fillna(0), target_col=\"Hydrometry_Nave_di_Rosano\") \n        \n    test=train[-dayahead:]\n    train=train[:-dayahead] \n    print('Availbable columns to regress',aqua.columns)\n    param = {'num_leaves': 200,   # increasing or decreasing can influence the decisiontree and the result, there is optimum possible beware overfit\n             'min_data_in_leaf': 50, # increasing or decreasing can influence the decisiontree and the result, there is optimum possible beware overfit\n             'objective':'regression', #regress\n             'max_depth': -1,\n             'learning_rate': 0.1,\n             \"boosting\": \"gbdt\", #gbdt,dart  #gradient boost \n             \"feature_fraction\": 0.8,\n             \"bagging_freq\": 1,\n             \"bagging_fraction\": 0.8 ,\n             \"bagging_seed\": 11,\n             \"metric\": 'mse', #'rmse',#auc  #use mean square error\n             \"num_classes\": 1,#classific\n             \"lambda_l1\": 0.1,\n\n             \"random_state\": 133,\n             \"verbosity\": -1}\n\n    max_iter = 10\n    from sklearn import metrics\n    import lightgbm as lgb\n    from sklearn.model_selection import KFold\n    import warnings\n    import gc\n    import time\n    import sys\n    import datetime\n    import matplotlib.pyplot as plt\n    import seaborn as sns\n    from tqdm import tqdm\n    from sklearn.metrics import mean_squared_error\n    from sklearn.metrics import mean_squared_error\n\n    target = train[[label]]\n    # drop column to forecast\n    train=train.drop([label],axis=1)\n\n    folds = KFold(n_splits=5, shuffle=True, random_state=15)\n    oof = np.zeros((len(train)))\n\n    features = [c for c in train.columns if c not in ['ID']]\n    predictions = np.zeros(len(test))\n    start = time.time()\n    feature_importance_df = pd.DataFrame()\n    start_time= time.time()\n    score = [0 for _ in range(folds.n_splits)]\n    # folding takes care of 'unbalanced data', is always a strong idea to use\n    for fold_, (trn_idx, val_idx) in enumerate(folds.split(train.values, target.values)):\n        print(\"fold n\u00b0{}\".format(fold_))\n        trn_data = lgb.Dataset(train.iloc[trn_idx][features],\n                               label=target.iloc[trn_idx]#.fillna('')#,\n                               \n                              )\n        val_data = lgb.Dataset(train.iloc[val_idx][features],\n                               label=target.iloc[val_idx]#.fillna('')#,\n                               \n                              )\n        print(train.shape,target.shape,target.iloc[val_idx].shape,train.iloc[val_idx][features].shape,val_data,trn_data)\n        num_round = 20000\n        clf = lgb.train(param,\n                        trn_data,\n                        num_round,\n                        valid_sets = [trn_data, val_data],\n                        verbose_eval=1000,\n                        early_stopping_rounds = 100)\n\n        oof[val_idx] = clf.predict(train.iloc[val_idx][features], num_iteration=clf.best_iteration)\n\n        fold_importance_df = pd.DataFrame()\n        fold_importance_df[\"feature\"] = features\n        fold_importance_df[\"importance\"] = clf.feature_importance(importance_type='gain')\n        fold_importance_df[\"fold\"] = fold_ + 1\n        feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n\n        # we perform predictions by chunks\n        initial_idx = 0\n        chunk_size = 1000000\n        current_pred = np.zeros(len(test))\n        while initial_idx < test.shape[0]:\n            final_idx = min(initial_idx + chunk_size, test.shape[0])\n            idx = range(initial_idx, final_idx)\n            current_pred[idx] = clf.predict(test.iloc[idx][features], num_iteration=clf.best_iteration)\n            initial_idx = final_idx\n        predictions += current_pred \/ min(folds.n_splits, max_iter)\n        plt.scatter(x=0,y=0)\n        plt.scatter(x=test[label], y=current_pred, marker='.', alpha=1,c=np.abs(test[label].values-current_pred))\n        plt.scatter(x=[np.mean(test[label])], y=[np.mean(current_pred)], marker='o', color='red')\n        plt.xlabel('Real test'); plt.ylabel('Pred. test')\n        plt.show()\n\n        print(\"time elapsed: {:<5.2}s\".format((time.time() - start_time) \/ 3600))\n        #score[fold_] = metrics.roc_auc_score(target.iloc[val_idx], oof[val_idx])\n        #mse = mean_squared_error(target.iloc[val_idx], oof[val_idx])\n        #print(mse)\n\n        if fold_ == max_iter - 1: break\n\n    if (folds.n_splits == max_iter):\n        print(\"CV score: {:<8.5f}\".format(metrics.roc_auc_score(target, oof)))\n    else:\n         print(\"CV score: {:<8.5f}\".format(sum(score) \/ max_iter))\n\n    sub_df = pd.DataFrame({indxvar: test[indxvar].values})\n    sub_df[label] =predictions\n    sub_df[:10]\n    sub_df.to_csv(\"submit.csv\", index=False)\n    test[label],predictions\n    mse=mean_squared_error(predictions, test[label].fillna(0).values)\n    print( 'mse',mse, 'rmse',sqrt(mse) )\n    \n    lgb.plot_importance(\n        clf, \n        max_num_features=20, \n        importance_type='gain', \n        figsize=(12,8));\n    return","e72fb90a":"aquaforecast(riverArno,'Hydrometry_Nave_di_Rosano' ,\"index\",'Hydrometry_Nave_di_Rosano',1,400)","b63c0236":"aquaforecast(riverArno,'Hydrometry_Nave_di_Rosano' ,\"index\",'Rainfall_Le_Croci',1,400)","a80efefb":"aquaforecast(aq_petrignago.drop('Depth_to_Groundwater_P25',axis=1),'Depth_to_Groundwater_P24' ,\"index\",'Depth_to_Groundwater_P24',1,400)","a87ca6f5":"aquaforecast(aq_petrignago,'Depth_to_Groundwater_P24' ,\"index\",'Depth_to_Groundwater_P24',1,400)","9e79790c":"aquaforecast(ws_Lupa,'Flow_Rate_Lupa' ,\"index\",'Flow_Rate_Lupa',1,400)","b7fff46b":"ws_Lupa['Dummy']=1","fcf41eff":"aquaforecast(ws_Lupa,'Flow_Rate_Lupa' ,\"index\",'Dummy',1,400)","4a59a2a6":"aquaforecast(lakeBilancino.drop('Lake_Level',axis=1),'Flow_Rate' ,\"index\",'Flow_Rate',1,400)","9bef6211":"aquaforecast(lakeBilancino,'Flow_Rate' ,\"index\",'Flow_Rate',1,400)","6933df08":"aquaforecast(ws_Madonna,'Flow_Rate_Madonna_di_Canneto' ,\"index\",'Flow_Rate_Madonna_di_Canneto',1,400)","0a98cfa9":"ws_Madonna['Dummy']=1\naquaforecast(ws_Madonna,'Flow_Rate_Madonna_di_Canneto' ,\"index\",'Dummy',1,400)","bf4f42f0":"aquaforecast(aq_auser,'Depth_to_Groundwater_SAL' ,\"index\",'Depth_to_Groundwater_SAL',1,400)","a83721e1":"aquaforecast(aq_auser.drop(['Depth_to_Groundwater_LT2', 'Depth_to_Groundwater_PAG',\n       'Depth_to_Groundwater_CoS', 'Depth_to_Groundwater_DIEC'],axis=1),'Depth_to_Groundwater_SAL' ,\"index\",'Depth_to_Groundwater_SAL',1,400)","0cee03e9":"# check if you don't create a selffulfilling prophecy\n- this means you have to take care that you don't forecast with data you could impossibly know at the day 5, you can not know what is the temperature of day 6, and if the moving average has even a slight knowledge of the day ahaid, this narrows the error of the forecast, but  your forecast is wrong..\n","35f4bbde":"# ARIMA Timeseries analysis\n- there is a month effect\n- there is a 1-5 day lag effect autoc\n- autocorrelation is nonstationary, needs difference per day to do an ARIMA forecast\n- indeed the difference of the seasonal gives the better forecast \n- a week effect in the forecast seems to me rather intuitive, since the weekly structure of our habits, but the monthly effect is for me rather counterintuitive. I wonder what habit could be monthly...\n- ARIMA does not use any other information than the production itself, and just uses the 'monthly' and '5day' peak effets to forecast the consumption until 14days ahead. Its not such a strong forecaster but as such you can always use it\n","6215565b":"# overview of aqua systems and first interpretation","b6943a56":"# lets create an aquaforecast function\n- its a forecast that works as long as you have all variables available\n- althoug beware : temperature, waterlevels can mere be an estimate of historical values so maybe we need to drop all those values and fill in historical values for everything","e22b98a9":"# Aqua Auser\n- a nice forecast is possible\n- beware for the outlayers like 'zero depth' values...\n- its not clear if we forecast SAL depth, if the PAG is a variable we should drop too, lets drop all depth levels, the forecast remains narrow\n\n","57d40283":"# riverbed Arno\n\n\nthis system is autocorrelated as all forecasts, lag en moving average is always the best forecast, but has as drawback that you feed in during the 400day period information you can not know on forehand. You could know the forecasted data though, which gives a huge autocorrelation. This means the autocorrelation means that the best forecast for next day or even this week is perfectly narrowly possible, but 400days ahead you can't know the fluctuations in the system on forehand. So you simply expect the outflow to be what is was the day before.\n\n\nfirst regression is with dropout of Hydrometry_Nave_di_Rosano label Moving average and Lagged information, what gives a rather good forecast of the riversystem. The best forecast is the 'week effet', temperature, rainfall Moving Average and month effect as expected.\nBut when one adds the 'lagged information' of the riverbed, so you can use this forecast for week-ahead but not much further\n","76286ef5":"# lake Bilancino\n\n- again a relative flat and uncorrelated forecast, if we drop the Lake level\n- keeping the variable Lake lavel in the prediction, narrows the error. You could keep this variable to forecast, since a lake level is something very visible, and you can trust any prediction of that lake level stays within a deviation limit (fe 1meter) of the forecast. \n- imho the flatness means there is no overdraining of the lake, and the source is not stressed to his limits","8706b487":"# Aqua Lupa\n- a flat prediction, there seems no information avaibable other then 'rainfall...\n- here i could try to add weather and rain data from 'italy' in general to see if the errorate becomes smaller, for the time being its an unsolved problem\n- exept if we use the 'autocorrelation power by forgetting to omit the P25, the forecast has higher forecast error, although the parameter is most influential","6df42038":"# aqua petrignago\n\nhere there are two variables Depth to groudwater p24,p25\nevidently again you drop out the other variable to get a forecast without autocorrelation effect\nthe test \/ prediction graph shows the great variability of the forecast. Although this fuzziness, the forecast is still good\n","ce2772cd":"# lets try an LGBM regression\n\n- its a robust and fast decisiontree regressor\n- that can find a regression fit with unbalanced data, omitting the outliers\n-\n","970e27d7":"# prepare data\n- split date\n- copy data with timelag 3 days","9d08d747":"# water system Madonna\n\n- again an unpredictable system..., this means imho there is not yet a limit in that system"}}