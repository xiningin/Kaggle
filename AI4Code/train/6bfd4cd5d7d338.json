{"cell_type":{"747aa2d9":"code","c860a1e7":"code","c1a27ec1":"code","d1ab1428":"code","a08ef723":"code","b7cec15c":"code","8969b9ec":"code","4675d332":"code","7f1ad0cc":"code","61e22681":"code","00a0af14":"code","84a7cec1":"code","6153a890":"code","cf7015a6":"code","a63d7b34":"code","091d774b":"code","3fa26068":"code","7e452d4f":"code","dc69d8d6":"code","8b7621f2":"code","c9de6368":"code","7cc09791":"code","d1f1e460":"code","6f25b69c":"code","949417f0":"code","82655d11":"code","fe6e0c2f":"markdown","c4157d92":"markdown","367a598d":"markdown","67586fa7":"markdown","9fb3bf2b":"markdown","c9765dba":"markdown","7f93a538":"markdown"},"source":{"747aa2d9":"import os, gc, random, math\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader\nfrom torchvision import datasets, models, transforms\nfrom torchvision.io import read_image, ImageReadMode\nfrom torchvision.datasets import ImageFolder\n\nimport pandas as pd\n\nimport numpy as np\n\nimport matplotlib.pyplot as plt","c860a1e7":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ndevice","c1a27ec1":"from sklearn.utils import shuffle\n\ndef prepare_csv(csv_fn, dataset_cnt):\n    patients = {}\n    \n    for folder in range(1, 13):\n        img_path = '..\/input\/data\/images_{:03d}\/images'.format(folder)\n        img_fns = [name for name in os.listdir(img_path)]\n\n        for i in img_fns:\n            key = i[:8]\n            patients.setdefault(key, [])\n            fn = os.path.join(img_path, i)\n            patients[key].append(fn)\n                    \n    for p in list(patients.keys()):\n        if (len(patients[p]) <= 1):\n            del patients[p]\n    \n    entries = {\n        'img1': [],\n        'img2': [],\n        'label': []\n    }\n    for i in range(dataset_cnt):\n        choice = random.randint(0, 1)\n        \n        if (choice == 0):\n            p1, p2 = random.choices(list(patients.keys()), k=2)\n            p1 = random.choice(patients[p1])\n            p2 = random.choice(patients[p2])\n            entries['img1'].append(p1)\n            entries['img2'].append(p2)\n            entries['label'].append(0)\n        else:\n            p = random.choice(list(patients.keys()))\n            p1, p2 = random.choices(patients[p], k=2)\n            entries['img1'].append(p1)\n            entries['img2'].append(p2)\n            entries['label'].append(1)\n\n    df = pd.DataFrame(entries)\n    df = shuffle(df)\n    df.to_csv(csv_fn, index=False, header=True)\n\nexamples_cnt = 25000\nprepare_csv('.\/xray_pairs.csv', examples_cnt)","d1ab1428":"class CXR8Dataset(Dataset):\n    def __init__(self, df, transform=None):\n        self.transform = transform\n        self.triplet_labels = df\n\n    def __len__(self):\n        return len(self.triplet_labels)\n\n    def __getitem__(self, idx):\n        img1 = read_image(self.triplet_labels.iloc[idx, 0], mode=ImageReadMode.RGB)\n        img2 = read_image(self.triplet_labels.iloc[idx, 1], mode=ImageReadMode.RGB)\n        label = [self.triplet_labels.iloc[idx, 2]]\n        label = torch.tensor(label)\n\n        if self.transform:\n            img1 = self.transform(img1)\n            img2 = self.transform(img2)\n\n        return (img1, img2, label)","a08ef723":"from sklearn.model_selection import train_test_split\n\ntf = transforms.Compose([\n    transforms.Resize(size=(256, 256))\n])\n\ndef prepare_datasets(csv_path, test_rate=0.3):\n    df = pd.read_csv(csv_path, header=0)\n    train_imgs, test_imgs = train_test_split(df, test_size=test_rate)\n    datasets = {}\n    datasets['train'] = CXR8Dataset(df=train_imgs, transform=tf)\n    datasets['test'] = CXR8Dataset(df=test_imgs, transform=tf)\n    return datasets\n\ndatasets = prepare_datasets('.\/xray_pairs.csv')","b7cec15c":"def get_samples(csv_path, display_cnt):\n    df = pd.read_csv(csv_path, header=0)\n    display = CXR8Dataset(df=df.sample(display_cnt), transform=tf)\n    return display","8969b9ec":"batch_sz = 32\n\ntrain_dataloader = DataLoader(datasets['train'], batch_size=batch_sz, shuffle=True)\ntest_dataloader = DataLoader(datasets['test'], batch_size=batch_sz, shuffle=True)","4675d332":"print(len(train_dataloader))\nprint(len(test_dataloader))","7f1ad0cc":"CustomResNet50 = models.resnet50(pretrained=True).to(device)\nCustomResNet50.fc = nn.Linear(in_features=2048, out_features=128, bias=True)","61e22681":"class PatientVerificationModel(nn.Module):\n    def __init__(self):\n        super(PatientVerificationModel, self).__init__()\n\n        self.conv = CustomResNet50\n        self.fc = nn.Sequential(nn.Linear(128, 1), nn.Sigmoid())\n\n    def forward_one(self, x):\n        return self.conv(x)\n\n    def forward(self, x1, x2):\n        x1 = torch.sigmoid(self.forward_one(x1))\n        x2 = torch.sigmoid(self.forward_one(x2))\n        dis = abs(x1 - x2)\n        return self.fc(dis)","00a0af14":"class MultipleOptimizer(object):\n    def __init__(self, *op):\n        self.optimizers = op\n\n    def zero_grad(self):\n        for op in self.optimizers:\n            op.zero_grad()\n\n    def step(self):\n        for op in self.optimizers:\n            op.step()","84a7cec1":"from sklearn.metrics import roc_curve, roc_auc_score, accuracy_score, f1_score, precision_score, recall_score","6153a890":"def plot_roc_auc_95ci(y_true, y_pred, positive=1):\n    fpr, tpr, _ = roc_curve(y_true, y_pred)\n    AUC = roc_auc_score(y_true, y_pred)\n    \n    N1 = sum(y_true == positive)\n    N2 = sum(y_true != positive)\n    Q1 = AUC \/ (2 - AUC)\n    Q2 = 2*AUC**2 \/ (1 + AUC)\n    SE_AUC = math.sqrt((AUC*(1 - AUC) + (N1 - 1)*(Q1 - AUC**2) + (N2 - 1)*(Q2 - AUC**2)) \/ (N1*N2))\n    lower = AUC - 1.96*SE_AUC\n    upper = AUC + 1.96*SE_AUC\n    if lower < 0:\n        lower = 0\n    if upper > 1:\n        upper = 1\n        \n    print(f'95% CI:    low={lower:.4f} up={upper:.4f}')\n    \n    plt.figure(1)\n    plt.plot([0, 1], [0, 1], 'k-')\n    plt.plot(fpr, tpr, label='N = {0} (AUC = {1:.3f})'.format(len(y_true), AUC))\n    plt.xlabel('False positive rate')\n    plt.ylabel('True positive rate')\n    plt.title('ROC curve')\n    plt.legend(loc='best')\n    plt.show()","cf7015a6":"def print_scores(y_true, y_pred, acc_arr, f1_arr, pre_arr, rec_arr):\n    min_acc = min(acc_arr)\n    max_acc = max(acc_arr)\n    avg_acc = accuracy_score(y_true, y_pred)\n    \n    min_f1 = min(f1_arr)\n    max_f1 = max(f1_arr)\n    avg_f1 = f1_score(y_true, y_pred)\n    \n    min_prec = min(pre_arr)\n    max_prec = max(pre_arr)\n    avg_prec = precision_score(y_true, y_pred)\n    \n    min_rec = min(rec_arr)\n    max_rec = max(rec_arr)\n    avg_rec = recall_score(y_true, y_pred)\n    \n    print('Accuracy:  min=%.4f max=%.4f avg=%.4f' % (min_acc, max_acc, avg_acc))\n    print('F1-score:  min=%.4f max=%.4f avg=%.4f' % (min_f1, max_f1, avg_f1))\n    print('Precision: min=%.4f max=%.4f avg=%.4f' % (min_prec, max_prec, avg_prec))\n    print('Recall:    min=%.4f max=%.4f avg=%.4f\\n' % (min_rec, max_rec, avg_rec))","a63d7b34":"def print_results(y_true, y_scores, y_pred, acc_arr, f1_arr, pre_arr, rec_arr):\n    print_scores(y_true, y_pred, acc_arr, f1_arr, pre_arr, rec_arr)\n    plot_roc_auc_95ci(y_true, y_scores, y_pred)","091d774b":"def plot_metrics(title, acc, f1, prec, recall, data_x = None):\n    fig, axs = plt.subplots(2, 2)\n    fig.suptitle(title)\n    \n    if data_x is not None:\n        axs[0,0].plot(data_x, acc)\n        axs[0,1].plot(data_x, f1)\n        axs[1,0].plot(data_x, prec)\n        axs[1,1].plot(data_x, recall)\n    else:\n        axs[0,0].plot(acc)\n        axs[0,1].plot(f1)\n        axs[1,0].plot(prec)\n        axs[1,1].plot(recall)\n       \n    axs[0,0].set_title('accuracy')\n    axs[0,1].set_title('F1-score')\n    axs[1,0].set_title('precision')\n    axs[1,1].set_title('recall')\n    \n    plt.tight_layout()\n    plt.show()","3fa26068":"print_interval = max(10, int(examples_cnt \/\/ (100 * batch_sz)))\nprint_interval","7e452d4f":"net = PatientVerificationModel()\nnet.to(device)\n\nif torch.cuda.is_available():\n    net.cuda()\n\nnet.train()\n\nloss_fn = nn.BCELoss()\n\nlrate = 0.0001\noptimizer = MultipleOptimizer(\n    torch.optim.SGD(net.parameters(), lr=lrate),\n    torch.optim.Adam(net.parameters()))\noptimizer.zero_grad()\n\nloss_arr = []\nacc = []\nprec = []\nrecall = []\nf1 = []\n\nall_pred = []\nall_label = []\nall_scores = []\n\nprint('Training...')\nfor i, data in enumerate(train_dataloader):\n    img1, img2, label = data\n    img1 = img1.float().to(device)\n    img2 = img2.float().to(device)\n    label = label.float().to(device)\n\n    optimizer.zero_grad()\n    output = net(img1, img2)\n    loss = loss_fn(output, label)\n    loss.backward()\n    optimizer.step()\n\n    res = (output >= 0.5).to(device)\n    res = res.cpu().numpy()\n    res = res.reshape(-1)\n    label = label.cpu().numpy()\n    label = label.reshape(-1)\n    \n    loss_arr.append(loss.item())\n    acc.append(accuracy_score(label, res))\n    f1.append(f1_score(label, res))\n    recall.append(recall_score(label, res))\n    prec.append(precision_score(label, res))\n    \n    output = output.detach().cpu().numpy()\n    \n    all_pred = np.append(all_pred, res)\n    all_label = np.append(all_label, label)\n    all_scores = np.append(all_scores, output)\n\n    if (i % print_interval == 0):\n        print('[gr-batch %d] loss=%.3f, acc=%.3f' % (i \/ print_interval, loss.item(), acc[-1]))\n\n    del img1, img2, label, res, loss, output\n    gc.collect()\n\n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()","dc69d8d6":"print('Training results:')\nprint_results(all_label, all_scores, all_pred, acc, f1, prec, recall)\nplot_metrics('Training', acc, f1, prec, recall)","8b7621f2":"net.eval()\n\ngc.collect()\n\nif torch.cuda.is_available():\n    torch.cuda.empty_cache()\n\nloss_arr = []\nacc = []\nprec = []\nrecall = []\nf1 = []\n\nall_pred = []\nall_label = []\nall_scores = []\n\nprint('Testing...')\nfor i, data in enumerate(test_dataloader):\n    img1, img2, label = data\n    img1 = img1.float().to(device)\n    img2 = img2.float().to(device)\n    label = label.float().to(device)\n\n    output = net(img1, img2)\n    loss = loss_fn(output, label)\n\n    res = (output >= 0.5)\n    \n    res = res.cpu().numpy()\n    res = res.reshape(-1)\n    label = label.cpu().numpy()\n    label = label.reshape(-1)\n    \n    loss_arr.append(loss.item())\n    acc.append(accuracy_score(label, res))\n    f1.append(f1_score(label, res))\n    recall.append(recall_score(label, res))\n    prec.append(precision_score(label, res))\n    \n    output = output.detach().cpu().numpy()\n    \n    all_pred = np.append(all_pred, res)\n    all_label = np.append(all_label, label)\n    all_scores = np.append(all_scores, output)\n\n    if (i % print_interval == 0):\n        print('[gr-batch %d] loss=%.3f, acc=%.3f' % (i \/ print_interval, loss.item(), acc[-1]))\n\n    del img1, img2, label, res, loss, output\n    gc.collect()\n\n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()","c9de6368":"print('Testing results:')\nprint_results(all_label, all_scores, all_pred, acc, f1, prec, recall)\nplot_metrics('Testing', acc, f1, prec, recall)","7cc09791":"display_dataloader = DataLoader(get_samples('.\/xray_pairs.csv', 10), batch_size=1, shuffle=True)","d1f1e460":"def display_image(img1, img2):\n    _, axs = plt.subplots(1, 2)\n    axs = axs.flatten()\n    axs[0].imshow(np.transpose(img1, (1, 2, 0)), interpolation='nearest')\n    axs[1].imshow(np.transpose(img2, (1, 2, 0)), interpolation='nearest')\n    plt.show()","6f25b69c":"class bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'","949417f0":"net.eval()\n\nfor i, data in enumerate(display_dataloader):\n    img1, img2, label = data\n    \n    display_image(img1[0], img2[0])\n    \n    img1 = img1.float().to(device)\n    img2 = img2.float().to(device)\n    label = label.float().to(device)\n    \n    output = net(img1, img2)\n    res = (output >= 0.5)\n    \n    headcolor = ''\n    tailcolor = ''\n    if (res != label):\n        headcolor = bcolors.FAIL + bcolors.BOLD\n        tailcolor = bcolors.ENDC\n        \n    print('%slabel=%d, predicted=%d, confidence: %.3f%s' % (headcolor, label, res, output, tailcolor))\n    \n    del img1, img2, label, res, output\n    gc.collect()\n    \n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()","82655d11":"torch.save(net.state_dict(), '.\/model.pth')","fe6e0c2f":"### Training","c4157d92":"### Custom ResNet50 model and the Siamese network","367a598d":"### Generating dataset","67586fa7":"### Testing","9fb3bf2b":"### Evaluation metrics","c9765dba":"# Is Medical Chest X-ray Data Anonymous?\n## Patient Verification Model - A PyTorch implementation\n\n[Original paper at arXiv](https:\/\/arxiv.org\/abs\/2103.08562)\n\nReferences:\n- https:\/\/towardsdatascience.com\/a-friendly-introduction-to-siamese-networks-85ab17522942\n\n- https:\/\/www.pyimagesearch.com\/2020\/11\/30\/siamese-networks-with-keras-tensorflow-and-deep-learning\/\n\n- https:\/\/github.com\/fangpin\/siamese-pytorch\/","7f93a538":"### Sample display"}}