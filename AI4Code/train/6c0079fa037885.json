{"cell_type":{"66dc4287":"code","fbf60340":"code","26d10518":"code","6b869b45":"code","09c9c342":"code","ea1fdf87":"code","14aeda8c":"code","9839acb7":"code","2d8c326a":"code","24f8947f":"code","df64224f":"code","b32eb140":"code","8f2c3e0e":"code","c68a6c5e":"code","3463859d":"code","8284a8e5":"code","74757bec":"code","68216720":"code","4465cfaf":"code","01e74c99":"code","9a9cb5b6":"code","26af64d7":"code","77be2fa3":"markdown","7774f4bc":"markdown","768e8118":"markdown","e4d7621e":"markdown","b3d15896":"markdown","fe4c4041":"markdown"},"source":{"66dc4287":"%matplotlib inline\n%reload_ext autoreload\n%autoreload 2\n","fbf60340":"import json\nimport pydicom\nfrom pathlib import Path\nfrom PIL import ImageDraw, ImageFont\nfrom matplotlib import patches, patheffects\nfrom fastai.conv_learner import *\nfrom fastai.dataset import *\n\ntorch.cuda.set_device(0)","26d10518":"PATH = Path(\"..\/input\")\nlist(PATH.iterdir())","6b869b45":"train_bb_df = pd.read_csv(PATH\/'stage_1_train_labels.csv')\n# train_bb_df.head()\ntrain_bb_df['duplicate'] = train_bb_df.duplicated(['patientId'], keep=False)\n# train_bb_df[train_bb_df['duplicate']].head()\ndetailed_df = pd.read_csv(PATH\/'stage_1_detailed_class_info.csv')\n# merge two df\nclass_df = train_bb_df.merge(detailed_df, on=\"patientId\")\ncsv_df = class_df.filter(['patientId', 'class'], )\n# csv_df = csv_df.set_index('patientId', )\n# detailed_df.head() , \nclass_df.head()\n# csv_df.head()","09c9c342":"DCMS = 'stage_1_train_images'\nIMG_PATH = PATH\/DCMS\nimg_size = 1024\nall_images = list(IMG_PATH.iterdir())\nall_images[:5]","ea1fdf87":"def open_image(loc):\n    if isinstance(loc, str):\n        loc = loc + '.dcm'\n    else: # posix path\n        loc = loc.as_posix()\n    img_arr = pydicom.read_file(loc).pixel_array\n    img_arr = img_arr\/img_arr.max()\n    img_arr = (255*img_arr).clip(0, 255)#.astype(np.int32)\n    img_arr = Image.fromarray(img_arr).convert('RGB') # model expects 3 channel image\n    return np.array(img_arr)","14aeda8c":"from fastai import dataset\ndataset.open_image = open_image","9839acb7":"im0 = all_images[0]\nim = open_image(im0)","2d8c326a":"def show_img(im, figsize=None, ax=None):\n    if isinstance(im, Path): # read image from loc\n        im = open_image(im)\n    if not ax: \n        fig,ax = plt.subplots(figsize=figsize)\n    ax.imshow(im)\n    ax.get_xaxis().set_visible(False)\n    ax.get_yaxis().set_visible(False)\n    return ax\n\ndef draw_outline(o, lw):\n  o.set_path_effects([patheffects.Stroke(\n      linewidth=lw, foreground='black'), patheffects.Normal()])\n\ndef draw_rect(ax, b):\n    patch = ax.add_patch(patches.Rectangle(b[:2], *b[-2:], fill=False, edgecolor='white', lw=2))\n    draw_outline(patch, 4)\n\ndef draw_text(ax, xy, txt, sz=14, color='white'):\n    text = ax.text(*xy, txt, verticalalignment='top', color=color, fontsize=sz, weight='bold')\n    draw_outline(text, 1)","24f8947f":"ax = show_img(im)","df64224f":"def resized (patients, resize):\n    if not resize:\n        return (patients.x, patients.y, patients.width, patients.height), patients.Target\n    else:\n        scale = img_size\/resize\n        return (patients.x\/scale, patients.y\/scale, patients.width\/scale, patients.height\/scale), patients.Target\n\ndef get_bb_category(im_loc, only_one=True, resize=None):\n    patientId = im_loc.name.split('.dcm')[0]\n    patients = class_df[class_df['patientId'] == patientId]\n\n    patients.iloc[np.argsort(patients.width * patients.height).values]\n    if only_one:\n        patients = patients.iloc[-1:].iloc[0]\n        return resized(patients, resize)\n    else:\n        return [resized(patients.iloc[i], resize )for i in range(len(patients))]\n            \n\nim_loc = IMG_PATH\/'00436515-870c-4b36-a041-de91049b9ab4.dcm'   \nget_bb_category(im_loc,only_one=False, resize=224)","b32eb140":"ax = show_img(im_loc, figsize=(16,8))\ndraw_text(ax, (0,0), im_loc.name.split('.dcm')[0], color='green')\nfor b,c in get_bb_category(im_loc,only_one=False):\n    draw_rect(ax, b)\n    draw_text(ax, b[:2], c)","8f2c3e0e":"CSV = '\/tmp\/lrg.csv'\ncsv_df.sample(100, random_state=5500).to_csv(CSV, index=False)","c68a6c5e":"f_model = resnet34\nresize=sz=224\nbs=64","3463859d":"tfms = tfms_from_model(f_model, sz, aug_tfms=transforms_side_on, crop_type=CropType.NO)\nmd = ImageClassifierData.from_csv(PATH, DCMS, CSV, tfms=tfms, bs=bs)","8284a8e5":"x,y=next(iter(md.val_dl))","74757bec":"# does fastai internally uses denorm? \nshow_img(md.val_ds.denorm(to_np(x))[0]);","68216720":"# https:\/\/github.com\/fastai\/fastai\/blob\/921777feb46f215ed2b5f5dcfcf3e6edd299ea92\/fastai\/conv_learner.py\nfrom fastai.learner import Learner\nclass CustomLearner(Learner):\n    def __init__(self, data, models, opt_fn=None, tmp_name='\/tmp', models_name='models', metrics=None, clip=None, crit=None):\n        self.data_,self.models,self.metrics = data,models,metrics\n        self.sched=None\n        self.wd_sched = None\n        self.clip = None\n        self.opt_fn = opt_fn or SGD_Momentum(0.9)\n        self.tmp_path = '\/tmp' \n        self.models_path = '\/tmp\/models' \n        os.makedirs(self.tmp_path, exist_ok=True)\n        os.makedirs(self.models_path, exist_ok=True)\n        self.crit = crit if crit else self._get_crit(data)\n        self.reg_fn = None\n        self.fp16 = False\n        \n    def _get_crit(self, data): return F.mse_loss\n    \nfrom fastai.conv_learner import ConvLearner\nclass CustomConvLearner(CustomLearner, ConvLearner):\n    def __init__(self, data, models, precompute=False, **kwargs):\n        self.precompute = False\n        super().__init__(data, models, **kwargs)\n        if hasattr(data, 'is_multi') and not data.is_reg and self.metrics is None:\n            self.metrics = [accuracy_thresh(0.5)] if self.data.is_multi else [accuracy]\n        if precompute: self.save_fc1()\n        self.freeze()\n        self.precompute = precompute","4465cfaf":"\nlearn = CustomConvLearner.pretrained(f_model, md, metrics=[accuracy])\nlearn.opt_fn = optim.Adam","01e74c99":"# def accuracy(preds, targs):\n#     preds,targs=preds.type(torch.LongTensor),targs.type(torch.LongTensor)\n# #     preds = torch.max(preds, dim=1)[1]\n#     return (preds==targs).float().mean()\n\n# from fastai import metrics\n# metrics.accuracy = accuracy","9a9cb5b6":"lrf=learn.lr_find(1e-5,100)","26af64d7":"learn.sched.plot()","77be2fa3":"Let's have fun to fetch the xy co-ordinate to show the target bounding box. We will first fetch biggest bounding box. We can modify it later to show all bounding box.","7774f4bc":"Create dataframe with all csv's. ","768e8118":"Save our patient with category in csv. We will randomly select 100 pateints.","e4d7621e":"We will write our own `open_image` fun, as `open_image` from fastai can't handle `.dcm` files. Next we replace fastai open_image with ours. ","b3d15896":"We will create a learner model for `f_model`. But this was failing because it tries to create `\/tmp` inside readonly `..\/input\/tmp` file system. We will override Learner in conv_learner.","fe4c4041":"We got image, we have to display it. Lets add those func."}}