{"cell_type":{"3ef78f3b":"code","48d81868":"code","4757d4ba":"code","7e28ebec":"code","687ea6d6":"code","28d4d656":"code","46158952":"code","d75296cc":"code","52024070":"code","16dce022":"code","33adc81a":"code","74384013":"code","a18e52d4":"code","893782b9":"code","e23de2f7":"code","c854f85f":"code","4d171acc":"code","7e9873db":"code","e37cb5c7":"code","0c2623cc":"code","0eea3d62":"code","3a76e9a4":"code","529ee9ed":"code","71fd65fa":"code","64f0955d":"code","461bbeb1":"code","55b21bc6":"code","fa39c75a":"code","df1b54c4":"code","37657a01":"code","b7695d85":"code","df84d989":"code","0036577a":"code","17115278":"code","e948134b":"code","75aa1d00":"code","3115d73c":"code","228f5659":"markdown","38a02de7":"markdown","178897e6":"markdown","d42e15db":"markdown"},"source":{"3ef78f3b":"# Importing Modules\nimport os\nimport torch\nfrom torch.utils.data import Dataset,DataLoader\nimport torch.nn as nn   \nfrom torch.optim import Adam\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n","48d81868":"# Cudnn for internal optimization\ntorch.backends.cudnn.benchmark = True","4757d4ba":"device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')","7e28ebec":"# Dataset Path\npath = r'..\/input\/digit-recognizer'\noutputPath = r'..\/input\/output\/'","687ea6d6":"# Reading the Data\ntrain = pd.read_csv(os.path.join(path,'train.csv'))\ntest = pd.read_csv(os.path.join(path,'test.csv'))\nsample_submission = pd.read_csv(os.path.join(path,'sample_submission.csv'))","28d4d656":"# The label field is for label of the data\n# The other fields are pixel values ranging from 0 to 255\ntrain.head()","46158952":"test.head()","d75296cc":"sample_submission.head()","52024070":"trainY = train.pop('label')\ntestY = pd.get_dummies(sample_submission.Label)\ntrainX = train.copy()\ntestX = test.copy()","16dce022":"trainX","33adc81a":"trainY","74384013":"testY","a18e52d4":"testX","893782b9":"testY","e23de2f7":"# Load the model and the dataset in the GPU(if any) , will help to speed up","c854f85f":"class datasetClass(Dataset):\n    \n    def __init__(self,):\n        super(datasetClass,self).__init__()\n        self.trainX = torch.tensor(trainX.values).type(torch.float32).div(255)\n        self.trainX = self.trainX.sub_(0.1307).div_(0.3081).to(device)\n        self.trainY = torch.tensor(trainY.values).type(torch.long).to(device)\n\n    def __getitem__(self,index):\n        return torch.tensor(self.trainX[index]),self.trainY[index]\n    \n    def __len__(self,):\n        return len(self.trainY)","4d171acc":"datasetClassObj = datasetClass()","7e9873db":"iterObj= iter(datasetClassObj)","e37cb5c7":"x,y = next(iterObj)","0c2623cc":"class datasetClassValid(Dataset):\n    \n    def __init__(self,):\n        super(datasetClassValid,self).__init__()\n        self.testX = torch.tensor(testX.values).type(torch.float32).div(255).sub_(0.1307).div_(0.3081).to(device)\n        self.testY = torch.tensor(testY.values).type(torch.long).to(device)\n        \n    def __getitem__(self,index):\n        return self.testX[index],self.testY[index]\n    \n    def __len__(self,):\n        return len(self.testY)","0eea3d62":"datasetClassValidObj = datasetClassValid()","3a76e9a4":"iterObj= iter(datasetClassValidObj)","529ee9ed":"x,y = next(iterObj)","71fd65fa":"class modelClass(nn.Module):\n    def __init__(self,inputDim,outputDim):\n        super(modelClass,self).__init__()\n        self.linearLayer1 = nn.Linear(inputDim,inputDim)\n        self.batchnormLayer1  = nn.BatchNorm1d(inputDim)\n        self.reluLayer1 = nn.ReLU()\n        self.linearLayer2 = nn.Linear(inputDim,outputDim)\n        self.softmaxLayer = nn.LogSoftmax()\n\n    def forward(self,x):\n        x = self.linearLayer1(x)\n        x = self.batchnormLayer1(x)\n        x = self.reluLayer1(x)\n        x = self.linearLayer2(x)\n        x = self.softmaxLayer(x)\n        return x","64f0955d":"bs = 64\nepochs = 50","461bbeb1":"Model = modelClass(784,10)\nModel.to(device)","55b21bc6":"dataloaderTrain = DataLoader(datasetClassObj,batch_size=bs,shuffle=True)","fa39c75a":"optimizer =  Adam(Model.parameters(),lr=0.01)\nlossFunc = nn.NLLLoss()\nloss  =  torch.tensor(0.1,requires_grad=True)","df1b54c4":"losses = []\nfor epoch in range(epochs):\n    # This step is very important\n    Model.train()\n    for x,y in dataloaderTrain:\n        ydash = Model(x) \n        loss = lossFunc(ydash,y)\n        loss.backward()\n        with torch.no_grad():\n            optimizer.step()\n            optimizer.zero_grad()\n    losses.append(loss)\n    print(f'The epoch {epoch} the Loss is {loss}')\n","37657a01":"# Loss Graph\ncpuLoss = [float(loss.to('cpu')) for loss in losses] \nplt.plot(cpuLoss)","b7695d85":"dataloaderValidObj = DataLoader(datasetClassValidObj,batch_size=64,shuffle=False)","df84d989":"plt.imshow(datasetClassValidObj.testX[0].to('cpu').view(28,28))","0036577a":"submitframe = pd.DataFrame(columns=['Label'])","17115278":"for x,y in dataloaderValidObj:\n    Model.eval()\n    #plt.imshow(x.to('cpu').view(28,28))\n    prediction = torch.argmax(Model(x),dim=1).to('cpu').numpy()\n    submitframe = submitframe.append(pd.DataFrame(prediction,columns=['Label']))\n","e948134b":"submitframe.head()","75aa1d00":"submitframe.shape","3115d73c":"submitframe.to_csv('sample_submission_Result.csv')","228f5659":"## Dataset Class","38a02de7":"## Lets understand the data","178897e6":"##  Lets build a model","d42e15db":"## Next Steps \n\n1. The current model accuracy is 98%,to check the addition of convNet improves it further.\n2. Addition of pytorch's transform function in the dataset creator.\n3. Introduction of LeNet architechture to improve the prediction.\n"}}