{"cell_type":{"04c25940":"code","ad198cb1":"code","aed5ee44":"code","7b8d6bb1":"code","18bb88ab":"code","2d334045":"code","47e810dc":"code","86080c42":"code","79ae398b":"code","a5c490de":"markdown","6ec23f44":"markdown","bda8f796":"markdown","4641f655":"markdown","f09963fd":"markdown","22202986":"markdown","c683bfc8":"markdown","9fd9a038":"markdown","44a9895b":"markdown","b6a2e9cc":"markdown","de1b1498":"markdown"},"source":{"04c25940":"# preprocessing module of the sequential model, so we can embed those different layers toghether\nfrom tensorflow.keras.preprocessing import sequence\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Embedding\nfrom tensorflow.keras.layers import LSTM\nfrom tensorflow.keras.datasets import imdb","ad198cb1":"print('Loading data...')\n# num_words: how many unique words that you want to load into your training and testing dataset\n(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=20000)","aed5ee44":"x_train[1337]","7b8d6bb1":"y_train[1337]","18bb88ab":"x_train = sequence.pad_sequences(x_train, maxlen=80)\nx_test = sequence.pad_sequences(x_test, maxlen=80)","2d334045":"model = Sequential()\nmodel.add(Embedding(20000, 128))\nmodel.add(LSTM(128, dropout=0.2, recurrent_dropout=0.2))\nmodel.add(Dense(1, activation='sigmoid'))","47e810dc":"model.compile(loss='binary_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy'])","86080c42":"model.fit(x_train, y_train,\n          batch_size=32,\n          epochs=15,\n          verbose=2,\n          validation_data=(x_test, y_test))","79ae398b":"score, acc = model.evaluate(x_test, y_test,\n                            batch_size=32,\n                            verbose=2)\nprint('Test score:', score)\nprint('Test accuracy:', acc)","a5c490de":"Now let's set up our neural network model! Considering how complicated a LSTM recurrent neural network is under the hood, it's really amazing how easy this is to do with Keras.\n\nWe will start with an Embedding layer - this is just a step that converts the input data into dense vectors of fixed size that's better suited for a neural network. You generally see this in conjunction with index-based text data like we have here. The 20,000 indicates the vocabulary size (remember we said we only wanted the top 20,000 words) and 128 is the output dimension of 128 units.\n\nNext we just have to set up a LSTM layer for the RNN itself. It's that easy. We specify 128 to match the output size of the Embedding layer, and dropout terms to avoid overfitting, which RNN's are particularly prone to.\n\nFinally we just need to boil it down to a single neuron with a sigmoid activation function to choose our binay sentiment classification of 0 or 1.","6ec23f44":"That doesn't look like a movie review! But this data set has spared you a lot of trouble - they have already converted words to integer-based indices. The actual letters that make up a word don't really matter as far as our model is concerned, what matters are the words themselves - and our model needs numbers to work with, not letters.\n\nSo just keep in mind that each number in the training features represent some specific word. It's a bummer that we can't just read the reviews in English as a gut check to see if sentiment analysis is really working, though.\n\nWhat do the labels look like?","bda8f796":"As this is a binary classification problem, we'll use the binary_crossentropy loss function. And the Adam optimizer is usually a good choice (feel free to try others.)","4641f655":"Let's get a feel for what this data looks like. Let's look at the first training feature, which should represent a written movie review:\n\n> When you are doing machin learning in general models don't work with words, they work with numbers, so we need to convert those words to numbers as a first step. Fortunately Keras has done all of this pre-processing for you already. ","f09963fd":"OK, let's evaluate our model's accuracy:","22202986":"Now import our training and testing data. We specify that we only care about the 20,000 most popular words in the dataset in order to keep things somewhat managable. The dataset includes 5,000 training reviews and 25,000 testing reviews for some reason.","c683bfc8":"# Recurring Neural Networks with Keras\n\n## Sentiment analysis from movie reviews\n\nThis notebook is inspired by the imdb_lstm.py example that ships with Keras.\n\nIt's actually a great example of using RNN's. The data set we're using consists of user-generated movie reviews and classification of whether the user liked the movie or not based on its associated rating.\n\nMore info on the dataset is [here](https:\/\/keras.io\/datasets\/#imdb-movie-reviews-sentiment-classification).\n\n\n\nSo we are going to use an RNN to do sentiment analysis on full-text movie reviews!\n\nThink about how amazing this is. We're going to train an artificial neural network how to \"read\" movie reviews and guess  whether the author liked the movie or not from them.\n\nSince understanding written language requires keeping track of all the words in a sentence, we need a recurrent neural network to keep a \"memory\" of the words that have come before as it \"reads\" sentences over time.\n\nIn particular, we'll use LSTM (Long Short-Term Memory) cells because we don't really want to \"forget\" words too quickly - words early on in a sentence can affect the meaning of that sentence significantly.\n\nLet's start by importing the stuff we need:","9fd9a038":"81% eh? Not too bad, considering we limited ourselves to just the first 80 words of each review.\n\nNote that the validation accuracy while we were training never really improved after the first epoch; we're likely just overfitting. This is a case where early stopping would have been beneficial.\n\nBut again - stop and think about what we just made here! A neural network that can \"read\" reviews and deduce whether the author liked the movie or not based on that text. And it takes the context of each word and its position in the review into account - and setting up the model itself was just a few lines of code! It's pretty incredible what you can do with Keras.","44a9895b":"Now let's kick off the training. Even with a GPU, this will take a long time!","b6a2e9cc":"Now we will actually train our model. RNN's, like [CNN](https:\/\/www.kaggle.com\/alirezanematolahy\/handwriting-recognition-with-cnns)'s, are very resource heavy. Keeping the batch size relatively small is the key to enabling this to run on your PC at all. You'd be taking advantage of GPU's installed across many computers on a cluster to make this scale a lot better.\n\n## Warning\n\nThis will take a very long time to run, even on a fast PC! Don't execute the next blocks unless you're prepared to tie up your computer for an hour or more.","de1b1498":"They are just 0 or 1, which indicates whether the reviewer said they liked the movie or not.\n\nSo to recap, we have a bunch of movie reviews that have been converted into vectors of words represented by integers, and a binary sentiment classification to learn from.\n\nRNN's can blow up quickly, so again to keep things managable on our little PC let's limit the reviews to their first 80 words:"}}