{"cell_type":{"a52172aa":"code","cbc05944":"code","50b7bebf":"code","5c299a04":"code","fb32361b":"code","7585c270":"code","e9912469":"code","76292ac3":"code","b70eb2c2":"code","bb01a60b":"code","eb90caaa":"markdown","26566a0f":"markdown","ec68204b":"markdown","7d66571b":"markdown","badc8909":"markdown","11afe585":"markdown","55850093":"markdown","ba988b23":"markdown","a69ac318":"markdown"},"source":{"a52172aa":"import os\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# For reproducibility purposes\nnp.random.seed(42)\n\ndef get_random_images(images_path, n=5):\n    image_collection = []\n    \n    for i in np.random.permutation(len(images_path))[:n]:\n        image = cv2.imread(images_path[i])\n        image_collection.append(image)\n        \n    return image_collection\n\n\n# We obtain the path of all the original images\nbase_path = \"..\/input\/Captcha Dataset\/original\"\nimages_path = list(map(lambda x: os.path.join(base_path, x), os.listdir(base_path)))\n\nrandom_images = get_random_images(images_path, n=9)\n\nplt.figure(figsize=(9, 3))\n\nfor i, image in enumerate(random_images):\n    plt.subplot(3, 3, i + 1)\n    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n    plt.axis('off')\n\nplt.suptitle('Random Captchas')\nplt.tight_layout()\nplt.show()","cbc05944":"def plot_histogram(image, colorspace):\n    chans = cv2.split(image)\n    \n    plt.title(f\"{colorspace} Histogram\")\n    plt.xlabel(\"Bins\")\n    plt.ylabel(\"# of Pixels\")\n    \n    for (chan_data, channel_name) in zip(chans, list(colorspace)):\n        if colorspace == \"BGR\":\n            hist = cv2.calcHist([chan_data], [0], None, [256], [0, 256])\n            plt.plot(hist, label=channel_name, color=channel_name.lower())\n        elif colorspace == \"HSV\":\n            if channel_name == \"H\":\n                hist = cv2.calcHist([chan_data], [0], None, [180], [0, 256])\n            else:\n                hist = cv2.calcHist([chan_data], [0], None, [256], [0, 256])\n                \n            plt.plot(hist, label=channel_name)\n        \n    \n    plt.xlim([0, 256])\n    plt.legend(loc=\"upper right\")","50b7bebf":"plt.figure(figsize=(10, 6))\nplt.subplot(3, 1, 1)\nplt.imshow(cv2.cvtColor(random_images[0], cv2.COLOR_BGR2RGB))\nplt.axis('off')\nplt.subplot(3, 1, 2)\nplot_histogram(image, \"BGR\")\nplt.subplot(3, 1, 3)\nplot_histogram(cv2.cvtColor(random_images[0], cv2.COLOR_BGR2HSV), \"HSV\")\nplt.tight_layout()\nplt.show()","5c299a04":"random_images = get_random_images(images_path)\n\nfor image in random_images:\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    channels = cv2.split(image)\n    \n    plt.figure(figsize=(20, 10))\n    \n    for index, channel in enumerate(channels):\n        plt.subplot(1, 3, 1 + index)\n        plt.imshow(channel, cmap=\"gray\")\n        \n    plt.show()","fb32361b":"def threshold_image(image, level):\n    # image should be in BGR space\n    \n    # Conversion and extraction of `value` channel\n    image = cv2.cvtColor(image.copy(), cv2.COLOR_BGR2HSV)[:, :, 2]\n    \n    # Thresholding at specified level\n    ret, thresh_img = cv2.threshold(image, level, 255, cv2.THRESH_BINARY_INV)\n    \n    return thresh_img\n\n\n# Plotting at different threshold levels\nlevels = np.linspace(0, 255, 10).astype('uint8')\n\nplt.figure(figsize=(10, 5))\n\nfor i, level in enumerate(levels):\n    plt.subplot(5, 2, i + 1)\n    \n    plt.title(f'Threshold = {level}')    \n    plt.imshow(threshold_image(random_images[0], level), cmap='gray')\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show()","7585c270":"plt.figure(figsize=(5, 5))\n\nfor i, image in enumerate(random_images):\n    thresholded = threshold_image(image, 99)\n    \n    plt.subplot(5, 1, i + 1)\n    plt.imshow(thresholded, cmap='gray')\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show()","e9912469":"threshold_level = 99\n\n# 1: Load the images\nfor image in random_images:\n    # 2, 3: Convert to HSV, obtain the value channel and threshold it\n    binarized = threshold_image(image, threshold_level)\n    \n    # 4: Obtain the contours over the binarized image\n    cnts, _ = cv2.findContours(binarized, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # 4.1: Create a copy of the binary image to draw over it\n    gray = cv2.cvtColor(binarized, cv2.COLOR_GRAY2RGB)\n    \n    # 4.2: Contour drawing\n    for c in cnts:\n        (x, y, w, h) = cv2.boundingRect(c)\n        \n        cv2.rectangle(gray, (x, y), (x + w, y + h), (0, 255, 0), 1)\n        \n    # 5: Visualization\n    \n    plt.figure(figsize=(15, 5))\n    \n    plt.subplot(1, 2, 1)\n    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n    plt.axis('off')\n    \n    plt.subplot(1, 2, 2)\n    plt.imshow(gray)\n    plt.axis('off')\n    \n    plt.show()","76292ac3":"threshold_level = 99\narea_threshold = 100\n\n# NEW: Kernel for the closing operation\nkernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))\n\n# 1: Load the images\nfor image in random_images:\n    # 2, 3: Convert to HSV, obtain the value channel and threshold it\n    binarized = threshold_image(image, threshold_level)\n    \n    # NEW: Apply a closing operation\n    binarized = cv2.morphologyEx(binarized, cv2.MORPH_CLOSE, kernel)\n    \n    # 4: Obtain the contours over the binarized image\n    cnts, _ = cv2.findContours(binarized, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # 4.1: Create a copy of the binary image to draw over it\n    gray = cv2.cvtColor(binarized, cv2.COLOR_GRAY2RGB)\n    \n    # 4.2: Contour drawing\n    for c in cnts:\n        (x, y, w, h) = cv2.boundingRect(c)\n        \n        # NEW: Apply an area threshold\n        if w * h > area_threshold:\n            cv2.rectangle(gray, (x, y), (x + w, y + h), (0, 255, 0), 1)\n        \n    # 5: Visualization\n    \n    plt.figure(figsize=(15, 5))\n    \n    plt.subplot(1, 2, 1)\n    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n    plt.axis('off')\n    \n    plt.subplot(1, 2, 2)\n    plt.imshow(gray)\n    plt.axis('off')\n    \n    plt.show()","b70eb2c2":"def get_letters(image, threshold_level=99, area_threshold=100):\n    letters_bin = []\n    rects = []\n    \n    # 2, 3: Convert to HSV, obtain the value channel and threshold it\n    binarized = threshold_image(image, threshold_level)\n    \n    # 3.1: Apply a closing operation\n    binarized = cv2.morphologyEx(binarized, cv2.MORPH_CLOSE, kernel)\n    \n    # 4: Obtain the contours over the binarized image\n    cnts, _ = cv2.findContours(binarized, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # 4.2: Create a copy of the binary image to draw over it\n    gray = cv2.cvtColor(binarized, cv2.COLOR_GRAY2RGB)\n    \n    # Creation of bounding rects\n    for c in cnts:\n        (x, y, w, h) = cv2.boundingRect(c)\n        \n        # 4.4: Apply an area threshold\n        if w * h > area_threshold:\n            rects.append((x, y, w, h))\n    \n    # Sort by position along the x axis. This is necessary because the order does matter when\n    # typing the answer to a captcha\n    rects = sorted(rects, key=lambda x: x[0])\n    \n    for (x, y, w, h) in rects:\n        # 4.5: Extract the letter and append it into an array\n        letters_bin.append(binarized[y:(y + h), x:(x + w)])\n            \n            \n    return letters_bin","bb01a60b":"image = get_random_images(images_path, n=1)[0]\n\nplt.figure()\nplt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\nplt.axis('off')\nplt.show()\n\nletters = get_letters(image)\n\nplt.figure()\nfor i, letter in enumerate(letters):\n    plt.subplot(len(letters), 1, i + 1)\n    plt.imshow(letter, cmap='gray')\n    plt.axis('off')\n    \nplt.tight_layout()\nplt.show()","eb90caaa":"Bingo! We can clearly separate the letters from the background. Now we need to find their contours to be able to extract them from the image.\n\n## Contours Finding\n\nSo far the pipepline to segmentate the letters from the background has been:\n\n1. Load the image\n2. Convert from BGR to HSV space and extract the Value channel\n3. Apply thresholding to the value channel with a threshold level of 99\n\nThe last step before classifying the letters is to detect the contours of the letters to be able to extract them.\n\nOpenCV comes with a handy function that detect the contours of a grayscale \/ binarized image: `cv2.findContours()`. Let's see it into action:","26566a0f":"### Histograms\n\nIf we want to extract the letters from the background, it is necesary to find a threshold level that will be applied to the image to binarize it. The main problem that we face is that in not all the images the letters are of the same color. So in order to find that level, we will need to explore the images using the histograms.","ec68204b":"## Letter Extraction\n\nFinally we need to extract the letters from the image. In this scenario the best idea would be to create a function which input is the original image and its output an array containing the binarized letters for further processing.","7d66571b":"Usually while working with colors in image processing, is better to use the HSV because it gives the colors a more \"logical\" way of grouping similar colors. After looking at a couple of images, we arrive to the conclusion that the letters are usually darker than its background. So the channel that will be of most use, in the HSV space, will be the value channel; the lower the value, the darker the color is.\n\n### Channels plotting","badc8909":"It seems that the best results lie between a threshold level of 85 and 113. Let's plot the random images thresholded at a level of 99, which is the intermediate value between 113 and 85.","11afe585":"Almost perfect! But there is still some room for improvement.\n\nFirst, we need to filter the contours to avoid enclosing noise as a letter. This problem can be easily solved using the area of the contour. If the area of the contour is below a certain threshold level, ignore it.\n\nSecond, sometimes there is an opening in the letter, splitting it into two and at the moment of detecting the contours. After applying the area threshold level, we still have it and this will impact the classification of the letter. This can be solved by applying a closing morphological operation over the binarized image.\n\nThe following plots try to address these problems.","55850093":"## Image Processing\n\nWe will be using the value channel to process the images. The general idea behind the processing is to get a binary image in order to find the contours. Hopefuly the contours will be the ones of the letters.\n\n### Thresholding\n\nTo find an adecuate threshold level, we will be showing the image thresholded at different levels and seek for the one that yields better results.","ba988b23":"## Exploratory Analysis\n\nFirstly we will display the original images and from there, we will develop a strategy to segment the letters from the background, without using machine learning \/ deep learning techniques.","a69ac318":"The first column represents the Hue channel, the second represents the Saturation channel and the third one represents the Value channel. Out of the three channels, the value channel seems to be the most useful to separete between letters and background; because as it was said before, the letters are usually darker than the rest of the image."}}