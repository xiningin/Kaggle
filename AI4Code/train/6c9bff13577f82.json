{"cell_type":{"b4996e18":"code","df43a8af":"code","f8907d7f":"code","255b299b":"code","c92030cc":"code","faec62b9":"code","e267d9af":"code","43c3c869":"code","7d225fb3":"code","76dcc9f6":"code","8a773f07":"code","aa70d9a0":"code","7d8e082a":"code","e4f24563":"code","49c9fa31":"code","cd1e9b3e":"code","29627172":"code","1b2eedf4":"code","3a79b61d":"code","d3e52624":"code","4c318e57":"code","060c7e50":"code","fec609d8":"code","ea774c81":"code","b40e59b6":"code","cf2bc21a":"code","cb283322":"code","0b30f0ed":"code","667864f4":"code","b83d7629":"code","98f046a2":"code","4dfcc509":"code","5a6c82c7":"code","ebecc3be":"code","68ed01a6":"code","38fb95ca":"code","1ac7b412":"code","ffa1d9b0":"code","a6b7e693":"code","3978b386":"code","e1c3c5b1":"code","30af2db9":"code","8834dfcd":"markdown","5e89d2b4":"markdown","447c66bc":"markdown","185267fd":"markdown","a0be2315":"markdown","200fe42a":"markdown"},"source":{"b4996e18":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()","df43a8af":"from sklearn.datasets import load_breast_cancer","f8907d7f":"cancer = load_breast_cancer()","255b299b":"cancer.keys()","c92030cc":"print(cancer['DESCR'])","faec62b9":"print(cancer['target'])","e267d9af":"data = cancer['data']","43c3c869":"df = pd.DataFrame(data,columns=cancer['feature_names'])","7d225fb3":"df.head().T","76dcc9f6":"df.info()","8a773f07":"df.describe().T","aa70d9a0":"df['target'] = cancer['target']","7d8e082a":"corr_ = df.corr()\nplt.figure(figsize=(10,10))\nsns.heatmap(corr_,cmap='coolwarm')","e4f24563":"sns.pairplot(df, vars = ['mean radius','mean texture', 'mean area', 'mean perimeter', 'mean smoothness'], hue='target')","49c9fa31":"sns.countplot(df['target'])","cd1e9b3e":"plt.figure(figsize=(10,7))\nsns.scatterplot(data=df,x='mean area',y='mean smoothness', hue='target')","29627172":"from sklearn.model_selection import train_test_split","1b2eedf4":"y=df['target']\nX = df.drop(['target'],axis=1)\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=101)","3a79b61d":"from sklearn.svm import SVC","d3e52624":"from sklearn.metrics import classification_report, confusion_matrix","4c318e57":"model = SVC()\nmodel.fit(X_train,y_train)\npred_svc = model.predict(X_test)\n","060c7e50":"cm = confusion_matrix(y_test,pred_svc)\nsns.heatmap(cm, annot=True)","fec609d8":"from sklearn.model_selection import GridSearchCV","ea774c81":"params = {\n    \"C\": [0.1,1,10,100],\n    \"gamma\": [1,0.1,0.01,0.001],\n    \"kernel\":['rbf']\n}","b40e59b6":"grid_model = GridSearchCV(SVC(),params,refit=True, verbose=3)\ngrid_model.fit(X_train,y_train)\nprint(grid_model.best_params_)","cf2bc21a":"pred_svc_grid = grid_model.best_estimator_.predict(X_test)","cb283322":"cm = confusion_matrix(y_test,pred_svc_grid)\nsns.heatmap(cm, annot=True)","0b30f0ed":"from sklearn.model_selection import StratifiedKFold\nfrom xgboost import XGBClassifier\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom sklearn import metrics\nfolds = 5\nparam_comb = 3\nskf = StratifiedKFold(n_splits=folds, shuffle = True, random_state = 1001)\nxgb = XGBClassifier(learning_rate=0.01, objective='binary:logistic', eval_metric='auc',use_label_encoder =False)\nxgb_gpu = XGBClassifier(learning_rate=0.01, objective='binary:logistic', tree_method='gpu_hist', eval_metric='auc',use_label_encoder =False)","667864f4":"params = {\n    \"n_estimators\":[1000,2000,3000],\n    \"alpha\":[5,2,1,0.1,0.01]\n}","b83d7629":"random_search = GridSearchCV(xgb,params, cv=skf.split(X_train,y_train), verbose=3)\nrandom_search.fit(X_train, y_train)","98f046a2":"preds_XGB_grid = random_search.best_estimator_.predict(X_test)\ncm = confusion_matrix(y_test,preds_XGB_grid)\nsns.heatmap(cm, annot=True)","4dfcc509":"random_search_gpu = GridSearchCV(xgb_gpu,params, cv=skf.split(X_train,y_train), verbose=3)\n","5a6c82c7":"random_search_gpu.fit(X_train, y_train)","ebecc3be":"random_search_gpu.best_params_","68ed01a6":"preds_XGB_grid_gpu = random_search_gpu.best_estimator_.predict(X_test)","38fb95ca":"cm = confusion_matrix(y_test,preds_XGB_grid_gpu)\nsns.heatmap(cm, annot=True)","1ac7b412":"import sklearn.metrics as metrics\ndef run_metrics(pred,actual):\n    print('Accuracy on unseen hold out set:' , metrics.accuracy_score(actual,pred) * 100 , '%' )\n    print()\n    f1_score = metrics.f1_score(actual,pred)\n    precision = metrics.precision_score(actual,pred)\n    recall = metrics.recall_score(actual,pred)\n    score_dict = { 'f1_score':[f1_score], 'precision':[precision], 'recall':[recall]}\n    score_frame = pd.DataFrame(score_dict)\n    print(score_frame)","ffa1d9b0":"print(\"The Accuracies for the different methods are\")\n","a6b7e693":"print(\"For SVC without GridSerch\")\nrun_metrics(pred_svc,y_test)","3978b386":"print(\"For SVC with GridSerch\")\nrun_metrics(pred_svc_grid,y_test)","e1c3c5b1":"print(\"For XGBoost with GridSerch and GPU off\")\nrun_metrics(preds_XGB_grid,y_test)","30af2db9":"print(\"For XGBoost with GridSerch and GPU on\")\nrun_metrics(preds_XGB_grid_gpu,y_test)","8834dfcd":"# SVC Model","5e89d2b4":"# Conclusion","447c66bc":"As we can see the best accuraccy and scores across all measures is achieved by XGBoost Algorithm with GPU support.","185267fd":"# Using XGBoostClassifier with GPU","a0be2315":"# Evaluation of all the models","200fe42a":"# Improving the model using GridSearch"}}