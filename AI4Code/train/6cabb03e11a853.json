{"cell_type":{"053b6de8":"code","81650a44":"code","db272364":"code","c0fb0206":"code","8e06b27a":"code","b6e8b842":"code","1ed4424d":"code","71467396":"code","b2219497":"code","c83fa179":"code","5b51c551":"code","8ffaff97":"code","e4fe0658":"code","1d27c632":"code","99877ad3":"code","35c915ff":"code","26991025":"code","83b478bb":"code","f7bd6e37":"code","01fefc28":"code","022f4c04":"code","7df8865f":"code","dfafde11":"code","f84cc479":"code","96bb4f2d":"code","7e91be7b":"code","b335513a":"code","bba551e8":"code","e623db93":"code","ae904439":"code","f0f3c8a5":"code","a97ac6e8":"code","e4a1afb8":"code","f289f453":"code","73b4811a":"code","48e04a48":"code","3bdf3fbb":"code","4464b13b":"code","5b6b0d6f":"markdown"},"source":{"053b6de8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport datetime\nfrom tqdm.auto import tqdm\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","81650a44":"#NN layer node counts\nLAYER1_SIZE = 50\nLAYER2_SIZE = 512\nTEAM_LAYER = True\nEPOCHS=30\nREPEATS=3\n","db272364":"df_train = pd.read_csv(\"\/kaggle\/input\/nfl-big-data-bowl-2020\/train.csv\")\nyards = df_train[\"Yards\"]","c0fb0206":"play_groups = df_train.groupby(\"PlayId\")\nsizes = play_groups.size()","8e06b27a":"sizes.describe()","b6e8b842":"#this simply assumes the home team abbreviation and possion team abbreviation are matching in number and in alphabetical order\n#then compares where the lines differ to find mismatching use of abbreviations\nfor x,y  in zip(sorted(df_train['HomeTeamAbbr'].unique()), sorted(df_train['PossessionTeam'].unique())):\n    if x!=y:\n        print(x + \" \" + y)","1ed4424d":"#this creates a mapping of the mismatchin abbreviations above\nmap_abbr = {'ARI': 'ARZ', 'BAL': 'BLT', 'CLE': 'CLV', 'HOU': 'HST'}\n#and this adds all the rest of abbreviations from PossessionTeam, mapping their abbreviations to themselves\n#this dos not override above map initialization, since it only has the ones missing from PossessionTeam (as keys)\nfor abb in df_train['PossessionTeam'].unique():\n    map_abbr[abb] = abb\n\nfor abb in sorted(map_abbr.keys()):\n    print(f\"{abb}={map_abbr[abb]}, \", end=\"\")","71467396":"def strtoseconds(txt):\n    txt = txt.split(':')\n    ans = int(txt[0])*60 + int(txt[1]) + int(txt[2])\/60\n    return ans","b2219497":"def map_weather(txt):\n    ans = 1\n    if pd.isna(txt):\n        return 0\n    if 'partly' in txt:\n        ans*=0.5\n    if 'climate controlled' in txt or 'indoor' in txt:\n        return ans*3\n    if 'sunny' in txt or 'sun' in txt:\n        return ans*2\n    if 'clear' in txt:\n        return ans\n    if 'cloudy' in txt:\n        return -ans\n    if 'rain' in txt or 'rainy' in txt:\n        return -2*ans\n    if 'snow' in txt:\n        return -3*ans\n    return 0","c83fa179":"off_form = df_train['OffenseFormation'].unique()\noff_form","5b51c551":"def str_to_float(txt):\n    try:\n        return float(txt)\n    except:\n        return -1","8ffaff97":"def map_turf(txt):\n    txt = txt.lower()\n    words = txt.split(\" \")\n    if \"grass\" in words or \"natural\" in words:\n        return \"natural\"\n    return \"artificial\"","e4fe0658":"\ndef create_features(df, dummy_cols=None, show_tqdm=True):\n    if show_tqdm:\n        pbar = tqdm(total=21)\n    #defenders in the box = defenders near the line of \"scrimmage\" (scrimmage seems to be line parallel to goal line, at the ball)\n    #distance = yards needed for first down\n    #so what is the point of this feature? the closer you are to getting the yards, the less you want defenders at ball?\n    df['DefendersInTheBox_vs_Distance'] = df['DefendersInTheBox'] \/ df['Distance']\n    if show_tqdm:\n        pbar.update()\n    #this seems to be just making sure the OffenseFormation only has values that were already present in the training set\n    df['OffenseFormation'] = df['OffenseFormation'].apply(lambda x: x if x in off_form else np.nan)\n    if show_tqdm:\n        pbar.update()\n    #OffenseFormation: one-hot encode and drop the original. needed for most classifiers, including keras used later here\n    df = pd.concat([df.drop(['OffenseFormation'], axis=1), pd.get_dummies(df['OffenseFormation'], prefix='Formation')], axis=1)\n    if show_tqdm:\n        pbar.update()\n    #Position: one-hot encode and drop the original. needed for most classifiers, including keras used later here\n    #https:\/\/en.wikipedia.org\/wiki\/American_football_positions\n\n    df = pd.concat([df.drop(['Position'], axis=1), pd.get_dummies(df['Position'], prefix='Position')], axis=1)\n    if show_tqdm:\n        pbar.update()\n    if dummy_cols is not None:\n        missing_cols = set( dummy_cols ) - set( df.columns ) - set('Yards')\n        for c in missing_cols:\n            df[c] = 0\n        df = df[dummy_cols]\n    \n    #unify all team abbreviations used in different columns\n    df['PossessionTeam'] = df['PossessionTeam'].map(map_abbr)\n    if show_tqdm:\n        pbar.update()\n    df['HomeTeamAbbr'] = df['HomeTeamAbbr'].map(map_abbr)\n    if show_tqdm:\n        pbar.update()\n    df['VisitorTeamAbbr'] = df['VisitorTeamAbbr'].map(map_abbr)\n    if show_tqdm:\n        pbar.update()\n    #is the team in possession of the ball in this play the home team?\n    df['HomePossesion'] = df['PossessionTeam'] == df['HomeTeamAbbr']\n    if show_tqdm:\n        pbar.update()\n    #Field_eq_Possession = is the ball on the field side of the possessing team\n    df['Field_eq_Possession'] = df['FieldPosition'] == df['PossessionTeam']\n    if show_tqdm:\n        pbar.update()\n    #convert the game clock string with hours, minutes, seconds into a single number of seconds\n    df['GameClock'] = df['GameClock'].apply(strtoseconds)\n    if show_tqdm:\n        pbar.update()\n    #convert height from foots-inches notation to inches only (or a single number anyway)\n    df['PlayerHeight'] = df['PlayerHeight'].apply(lambda x: 12*int(x.split('-')[0])+int(x.split('-')[1]))\n    if show_tqdm:\n        pbar.update()\n    #convert handoff and snap times to datetime format so one can calculate their diff\n    df['TimeHandoff'] = df['TimeHandoff'].apply(lambda x: datetime.datetime.strptime(x, \"%Y-%m-%dT%H:%M:%S.%fZ\"))\n    if show_tqdm:\n        pbar.update()\n    df['TimeSnap'] = df['TimeSnap'].apply(lambda x: datetime.datetime.strptime(x, \"%Y-%m-%dT%H:%M:%S.%fZ\"))\n    if show_tqdm:\n        pbar.update()\n    #calculate the delta (diff) from snap (picking up the ball) to handoff (giving it to next snapper)\n    df['TimeDelta'] = df.apply(lambda row: (row['TimeHandoff'] - row['TimeSnap']).total_seconds(), axis=1)\n    if show_tqdm:\n        pbar.update()\n    #convert player birthdate into datetime format to calculate age\n    df['PlayerBirthDate'] = df['PlayerBirthDate'].apply(lambda x: datetime.datetime.strptime(x, \"%m\/%d\/%Y\"))\n    if show_tqdm:\n        pbar.update()\n    seconds_in_year = 60*60*24*365.25\n    #calculate player age at the time of handoff, float in years\n    df['PlayerAge'] = df.apply(lambda row: (row['TimeHandoff']-row['PlayerBirthDate']).total_seconds()\/seconds_in_year, axis=1)\n    if show_tqdm:\n        pbar.update()\n    #clean up windspeed from all the garbage strings, convert to float\n    df['WindSpeed'] = df['WindSpeed'].astype(\"str\").apply(lambda x: x.lower().replace('mph', '').strip() if not pd.isna(x) else x)\n    df['WindSpeed'] = df['WindSpeed'].apply(lambda x: (int(x.split('-')[0])+int(x.split('-')[1]))\/2 if not pd.isna(x) and '-' in x else x)\n    df['WindSpeed'] = df['WindSpeed'].apply(lambda x: (int(x.split()[0])+int(x.split()[-1]))\/2 if not pd.isna(x) and type(x)!=float and 'gusts up to' in x else x)\n    df['WindSpeed'] = df['WindSpeed'].apply(str_to_float)\n    if show_tqdm:\n        pbar.update()\n    #is play going left or right on the field? convert to boolean\n    df['PlayDirection'] = df['PlayDirection'].apply(lambda x: x is 'right')\n    if show_tqdm:\n        pbar.update()\n    #perhaps \"team\" defines if the team whose turn is to \"play\" is the home team or not?\n    df['Team'] = df['Team'].apply(lambda x: x.strip()=='home')\n    if show_tqdm:\n        pbar.update()\n    df[\"Turf\"] = df[\"Turf\"].map(map_turf)\n    if show_tqdm:\n        pbar.update()\n    indoor = \"indoor\"\n    #replace variants of indoor text in GameWeather with just \"indoor\"\n    df['GameWeather'] = df['GameWeather'].apply(lambda x: indoor if not pd.isna(x) and indoor in x else x)\n    #seems to be fixing typos\n    df['GameWeather'] = df['GameWeather'].apply(lambda x: x.lower().replace('coudy', 'cloudy').replace('clouidy', 'cloudy').replace('party', 'partly').replace('clear and sunny', 'sunny and clear').replace('skies', '').replace(\"mostly\", \"\").strip() if not pd.isna(x) else x)\n    #convert weather into a number between -3 to 3, where -3 is snow, 2 is sunny and 3 is indoor climate control\n    df['GameWeather'] = df['GameWeather'].apply(map_weather)\n    if show_tqdm:\n        pbar.update()\n    #mark the rushing player\n    df['IsRusher'] = df['NflId'] == df['NflIdRusher']\n    if show_tqdm:\n        pbar.update()\n    return df\n\n","1d27c632":"df = df_train\ndf.shape","99877ad3":"df = df_train\n#drop the target variable\ndf.drop(['Yards'], axis=1, inplace=True)\ndf = create_features(df)\n","35c915ff":"#order by play id, team type, and rusher last\ndf = df.sort_values(by=['PlayId', 'Team', 'IsRusher']).reset_index()\n","26991025":"df.shape","83b478bb":"all_cols = df.columns","f7bd6e37":"from sklearn.preprocessing import StandardScaler\n\nscaler = StandardScaler()","01fefc28":"\ndf = df.drop(['TimeHandoff', 'TimeSnap', 'PlayerBirthDate', 'WindDirection', 'NflId', 'NflIdRusher', 'GameId', 'PlayId', 'index', 'Team'], axis=1)\ncat_features = []\nfor col in df.columns:\n    if df[col].dtype =='object':\n        cat_features.append(col)\ndf = df.drop(cat_features, axis=1)\n\ndf.fillna(-999, inplace=True)\nX = df.values\nX = scaler.fit_transform(X)\n","022f4c04":"X.shape","7df8865f":"X_train = X\n","dfafde11":"X_slices = []\nfor x in range(0,22):\n    player_slice = X_train[x::22]\n    X_slices.append(player_slice)\nX_train = X_slices\nX_train[0].shape","f84cc479":"y_train = np.zeros(shape=(X_train[0].shape[0], 199))\nfor i,yard in enumerate(yards[::22]):\n    y_train[i, yard+99:] = np.ones(shape=(1, 100-yard))","96bb4f2d":"len(X_train)","7e91be7b":"import keras\nfrom keras.callbacks import EarlyStopping\nfrom keras.optimizers import Adam\nfrom keras.models import Model\nimport tensorflow as tf\nfrom keras.layers import Input, Dense, BatchNormalization, Dropout, concatenate\n\ndef create_model(team_layer, player_feature_count):\n    player_layers = []\n    player_inputs = []\n    for x in range(1,23):\n        player_input = Input(shape=(player_feature_count,), name=f\"in{x}\")\n        if not team_layer or True: #the OR TRUE part avoids the other branch as I just wanted to give it a go this way\n            player_layer = Dense(units=LAYER1_SIZE, activation='relu', name=f\"d{x}\")(player_input)\n            player_layer = BatchNormalization(name=f\"bn{x}\")(player_layer)\n            player_layers.append(player_layer)\n        else:\n            player_layers.append(player_input)\n        player_inputs.append(player_input)\n\n    if team_layer:\n        layer_size = int(LAYER2_SIZE\/2)\n        \n        team1_layer = concatenate(player_layers[:11], name=\"team1\")\n        team1_layer = Dense(units=layer_size, activation='relu', name=\"t1_dense\")(team1_layer)\n        team1_layer = BatchNormalization(name=\"t1_bn\")(team1_layer)\n        \n        team2_layer = concatenate(player_layers[11:], name=\"team2\")\n        team2_layer = Dense(units=layer_size, activation='relu', name=\"t2_dense\")(team2_layer)\n        team2_layer = BatchNormalization(name=\"t2_bn\")(team2_layer)\n        \n        combined = concatenate([team1_layer, team2_layer], name=\"all_merge\")\n    else:\n        combined = concatenate(player_layers, name=\"all_merge\")\n\n    mid = Dropout(0.3, name=\"mid_drop\")(combined)\n    mid = Dense(units=LAYER2_SIZE, activation='relu', name=\"mid_dense\")(mid)\n    mid = BatchNormalization(name=\"final_bn\")(mid)\n    mid = Dropout(0.2, name=\"final_drop\")(mid)\n    output=keras.layers.Dense(units=199, activation='sigmoid', name=\"output\")(mid)\n\n    model = Model(inputs=player_inputs, outputs=output)\n    return model\n","b335513a":"#https:\/\/keras.io\/visualization\/\nfrom IPython.display import SVG\nfrom keras.utils import model_to_dot\n\nmodel = create_model(True, df_train.shape[1])\n#print(model.summary())\nSVG(model_to_dot(model, dpi=48, rankdir=\"LR\").create(prog='dot', format='svg'))","bba551e8":"model = create_model(False, df_train.shape[1])\n#print(model.summary())\nSVG(model_to_dot(model, dpi=48, rankdir=\"LR\").create(prog='dot', format='svg'))","e623db93":"def train_model(x_tr, y_tr, x_vl, y_vl):\n    player_feature_count = x_tr[0].shape[1]\n\n    model = create_model(TEAM_LAYER, player_feature_count)\n\n    er = EarlyStopping(patience=5, min_delta=1e-4, restore_best_weights=True, monitor='val_loss')\n    metric = None\n\n    loss = \"mse\"\n    model.compile(optimizer=Adam(lr=0.0005), loss=loss)\n\n    model.fit(x_tr, y_tr, epochs=EPOCHS, batch_size=32, callbacks=[er], validation_data=[x_vl, y_vl])\n    return model","ae904439":"from sklearn.model_selection import RepeatedKFold\n\nrkf = RepeatedKFold(n_splits=5, n_repeats=REPEATS)","f0f3c8a5":"len(y_train)","a97ac6e8":"models = []\n\nfor tr_idx, vl_idx in rkf.split(X_train[0], y_train):\n    \n    x_tr = []\n    for player in X_train:\n        x_tr.append(player[tr_idx])\n    y_tr = y_train[tr_idx]\n\n    x_vl = []\n    for player in X_train:\n        x_vl.append(player[vl_idx])\n    y_vl = y_train[vl_idx]\n    \n    model = train_model(x_tr, y_tr, x_vl, y_vl)\n    models.append(model)","e4a1afb8":"def make_pred(X):\n    player_feature_count = X.shape[1]\n    inputs = np.hsplit(X.reshape(-1, player_feature_count*22), 22)\n    y_pred = np.mean([model.predict(inputs) for model in models], axis=0)\n    for pred in y_pred:\n        prev = 0\n        for i in range(len(pred)):\n            if pred[i]<prev:\n                pred[i]=prev\n            prev=pred[i]\n    y_pred[:, -1] = np.ones(shape=(y_pred.shape[0]))\n    y_pred[:, 0] = np.zeros(shape=(y_pred.shape[0]))\n    return y_pred\n","f289f453":"y_pred = make_pred(X)\ny_pred","73b4811a":"def preprocess_test(df):\n    #order by play id, team, and rusher last\n    df = df.sort_values(by=['PlayId', 'Team', 'IsRusher']).reset_index()\n    df = df.drop(['TimeHandoff', 'TimeSnap', 'PlayerBirthDate', 'WindDirection', 'NflId', 'NflIdRusher', 'GameId', 'PlayId', 'index', 'Team'], axis=1)\n    df = df.drop(['level_0'], axis=1)\n    df = df.drop(cat_features, axis=1)\n\n    df.fillna(-999, inplace=True)\n    X = df.values\n    X = scaler.transform(X)\n    return X","48e04a48":"from kaggle.competitions import nflrush\n\nenv = nflrush.make_env()","3bdf3fbb":"for test, sample in tqdm(env.iter_test()):\n    #add new features, no scaling or anything yet\n    df_test = create_features(test, all_cols, False)\n    X = preprocess_test(df_test)\n    y_pred = make_pred(X)\n    env.predict(pd.DataFrame(data=y_pred,columns=sample.columns))\n","4464b13b":"env.write_submission_file()","5b6b0d6f":"# Keras with Multiple Inputs\n\nThe published kernels seem to treat the data as a single flat vector. Just to try something different, I made a model that treats each player as a separate input to the model. And a variant that combines each of those player vectors into two teams.\n\nDid not make much of a difference for me, but maybe someone has better skills, or gets some ideas. The graphs looks kind of cool though :).\n\nGenerally, this is based on the same template as all the other Keras kernels here, just squeezed the basic features into a bit smaller space and added the input layers.\n"}}