{"cell_type":{"68a28910":"code","6b909c85":"code","ad692580":"code","1a88868b":"code","bd8dbbe1":"code","f74abcc1":"code","9e79c608":"code","b2c59458":"code","0d73e3f9":"code","b02a700c":"code","9242d1cc":"code","5705648f":"code","e0794f4f":"code","92d5762b":"code","66672b4c":"code","f3e04c41":"code","923288c9":"code","cbb185c8":"code","b237f09a":"code","b339da56":"code","d0b6e8e2":"code","fa52fa8e":"code","2b40dfb8":"code","dfdf84ee":"code","6a378812":"markdown","1fb765ba":"markdown","6b0918db":"markdown","a3bcb3b1":"markdown","0d0da952":"markdown","0af2fb0b":"markdown","cd8993e9":"markdown","324781fd":"markdown"},"source":{"68a28910":"%matplotlib inline\nimport numpy as np\nimport pandas as pd\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\npd.set_option('display.max_columns', 99)\npd.set_option('display.max_rows', 99)\nfrom tqdm import tqdm\nimport plotly.express as px\nimport plotly.subplots as subplots\nimport plotly.graph_objects as go\nimport os\n\nfrom plotly.offline import init_notebook_mode, iplot, plot\ninit_notebook_mode(connected=True)","6b909c85":"%%javascript\nIPython.OutputArea.prototype._should_scroll = function(lines) {\n    return false;\n}","ad692580":"train = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-5\/train.csv')\ntrain = train.fillna('')\ntrain['Location'] = train.Country_Region + '-' + train.Province_State + '-' + train.County\ntrain = train[['Location', 'Date', 'Target', 'Weight', 'TargetValue']]\ntest = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-5\/test.csv')\ntest = test.fillna('')\ntest['Location'] = test.Country_Region + '-' + test.Province_State + '-' + test.County\ntest = test[['Location', 'Date', 'Target', 'ForecastId']]","1a88868b":"train.shape, test.shape\ntrain.head(2)\ntest.head(2)","bd8dbbe1":"train.Date.max()","f74abcc1":"PRIVATE_START = '2020-05-13'\n\nDATA_DIR = '\/kaggle\/input\/covid19belugaw5\/'\n\ntop_submission_files = [f for f in os.listdir(DATA_DIR) if f.startswith('submission_')]\ntop_submission_files","9e79c608":"top_submissions = pd.concat([\n    pd.read_csv(DATA_DIR + f).set_index('ForecastId_Quantile') for f in top_submission_files],\n    axis=1)\ntop_teams = [f.split('_')[1][:-4] for f in top_submission_files]\ntop_submissions.columns = [f'pred_{f}' for f in top_teams]\ntop_submissions['pred_blend'] = top_submissions.median(axis=1)\ntop_submissions['ForecastId'] = top_submissions.index.map(lambda s: s.split('_')[0]).astype(int)\ntop_submissions['q'] = top_submissions.index.map(lambda s: s.split('_')[1]).astype('float64')\ntop_submissions = top_submissions.merge(test, on='ForecastId')\ntop_submissions.Date.max()\ntop_submissions = top_submissions.merge(train, on=['Date', 'Location', 'Target'])","b2c59458":"top_submissions = top_submissions[top_submissions.Date >= PRIVATE_START]\ntop_submissions.shape\ntop_submissions.head(3)","0d73e3f9":"def loss(preds, actual, weights, qs):\n    l = 1 * (actual >= preds) * qs * (actual - preds) - 1 * (actual < preds) * (1 - qs) * (actual - preds)\n    return l * weights","b02a700c":"predictions = top_teams + ['blend']\nfor p in predictions:\n    top_submissions[f'loss_{p}'] = loss(top_submissions[f'pred_{p}'],\n                                        top_submissions.TargetValue,\n                                        top_submissions.Weight,\n                                        top_submissions.q)\ntop_submissions.head(3)","9242d1cc":"predictions = [c for c in top_submissions.columns if c.startswith('pred_')]\nweighted_predictions = top_submissions[predictions].copy()\nfor c in weighted_predictions.columns:\n    weighted_predictions[c] *= top_submissions.Weight.values\ncorr = weighted_predictions.corr()","5705648f":"fig = px.imshow(corr,\n                labels=dict(x=\"Teams\", y=\"Teams\", color=\"Correlation\"),\n                x=[c.split('_')[1] for c in corr.columns],\n                y=[c.split('_')[1] for c in corr.index],\n                color_continuous_scale='Viridis'\n               )\n_ = fig.update_xaxes(side=\"top\", title_text='Correlation among top teams')\nfig.show()","e0794f4f":"wp = pd.concat([weighted_predictions, top_submissions[['q', 'Location', 'Date', 'Target']]], axis=1)\nlow = wp[wp.q == 0.05].drop(columns=['q'])\nhigh = wp[wp.q == 0.95].drop(columns=['q'])\n\nspread = pd.merge(low, high, on=['Location', 'Date', 'Target'], suffixes=['_l', '_h'])\nfor p in predictions:\n    spread[f'spread_{p}'] = spread[[f'{p}_l', f'{p}_h']].max(axis=1) - spread[[f'{p}_l', f'{p}_h']].min(axis=1)\nmean_weighted_spread = spread[[c for c in spread.columns if c.startswith('spread')]].mean().reset_index()\nmean_weighted_spread.columns = ['p', 'mean_weighted_spread']\nmean_weighted_spread.sort_values(by='mean_weighted_spread')","92d5762b":"losses = [c for c in top_submissions.columns if c.startswith('loss_')]\ntop_submissions[losses].mean().reset_index().sort_values(by=0)","66672b4c":"daily_losses = top_submissions.groupby('Date')[losses].mean()\ndaily_losses.tail()","f3e04c41":"plot_data = daily_losses.reset_index().melt(id_vars='Date')\nlb = top_submissions[losses].mean().reset_index()\nlb.columns = ['variable', 'LB']\nplot_data = plot_data.merge(lb, on='variable')\nplot_data.variable = plot_data.variable.str.replace('loss_', '')\nplot_data['name'] = plot_data.variable + '(' + plot_data.LB.round(4).astype(str) + ')'\nfig = px.line(plot_data, x='Date', y='value', color='name')\n_ = fig.update_layout(title_text='Daily Prediction Performance')\nfig.show()","923288c9":"loss_cols = [c for c in top_submissions.columns if c.startswith('loss_')]\nlocations = top_submissions.groupby('Location')[loss_cols].mean().reset_index()\nlocations['relative_loss'] = locations.loss_blend \/ locations.loss_blend.sum()\nlocations = locations.sort_values(by='loss_blend', ascending=False)\n\nlocations.head(10)\nlocations.head(10).relative_loss.sum()","cbb185c8":"top = locations.head(10)\nfig = px.imshow(top[losses],\n                labels=dict(x=\"Teams\", y=\"Locations\", color=\"Pinball Loss\"),\n                x=[c.split('_')[1] for c in losses],\n                y=top.Location,\n                color_continuous_scale='Reds'\n               )\n_ = fig.update_xaxes(side=\"top\", title_text='Model Performance by Location')\nfig.show()","b237f09a":"top_submissions.loc[top_submissions.Location != 'Brazil--', losses].mean()","b339da56":"top_submissions.loc[top_submissions.Location.str.startswith('US'), losses].mean()","d0b6e8e2":"def draw_predictions(location, target):\n    selected_loc = top_submissions[\n        (top_submissions.Location == location) & (top_submissions.Target == target)]\n    team_colors = {t: c for t, c in zip(top_teams, px.colors.qualitative.Plotly)}\n    fig = go.Figure()\n\n    low = data=selected_loc[selected_loc.q == 0.05]\n    median = data=selected_loc[selected_loc.q == 0.5]\n    high = data=selected_loc[selected_loc.q == 0.95]\n\n    for team in top_teams:\n        _ = fig.add_trace(go.Scatter(\n            x=low.Date, y=low[f'pred_{team}'], mode='lines', name=team,\n            line=dict(color=team_colors[team], dash='dash')\n        ))\n        _ = fig.add_trace(go.Scatter(\n            x=median.Date, y=median[f'pred_{team}'], mode='lines', name=team,\n            line=dict(color=team_colors[team], width=3)\n        ))\n        _ = fig.add_trace(go.Scatter(\n            x=high.Date, y=high[f'pred_{team}'], mode='lines', name=team,\n            line=dict(color=team_colors[team], dash='dash')\n        ))\n    _ = fig.add_trace(go.Scatter(\n        x=median.Date, y=median['TargetValue'], mode='lines',\n        name='Actual', line=dict(color='black', width=3)))\n    _ = fig.update_layout(\n        title=f'{location} - {target}', yaxis_title=target, height=700\n    )\n    return fig","fa52fa8e":"location_names = list(locations.Location.values[:50])\ndefault_location = location_names[0]\ntargets = ['ConfirmedCases', 'Fatalities']\nfig = go.Figure()\nfig = subplots.make_subplots(\n    rows=2, cols=1,\n    subplot_titles=[\"Daily Cases\", \"Daily Fatalities\"], vertical_spacing=0.05)\nregion_plot_names = []\nteam_colors = {t: c for t, c in zip(top_teams, px.colors.qualitative.Plotly)}\nfor location in location_names:\n    for row, target in enumerate(targets):\n        selected_loc = top_submissions[\n            (top_submissions.Location == location) & (top_submissions.Target == target)]\n\n        low = data=selected_loc[selected_loc.q == 0.05]\n        median = data=selected_loc[selected_loc.q == 0.5]\n        high = data=selected_loc[selected_loc.q == 0.95]\n\n        for team in top_teams:\n            _ = fig.add_trace(go.Scatter(\n                x=low.Date, y=low[f'pred_{team}'], mode='lines', name=team,\n                line=dict(color=team_colors[team], dash='dash'),\n                visible=(location==default_location),\n                showlegend=(row==0)\n            ), row=row + 1, col=1)\n            _ = fig.add_trace(go.Scatter(\n                x=median.Date, y=median[f'pred_{team}'], mode='lines', name=team,\n                line=dict(color=team_colors[team], width=3),\n                visible=(location==default_location),\n                showlegend=(row==0)\n            ), row=row + 1, col=1)\n            _ = fig.add_trace(go.Scatter(\n                x=high.Date, y=high[f'pred_{team}'], mode='lines', name=team,\n                line=dict(color=team_colors[team], dash='dash'),\n                visible=(location==default_location),\n                showlegend=False\n            ), row=row + 1, col=1)\n        _ = fig.add_trace(go.Scatter(\n            x=median.Date, y=median['TargetValue'], mode='lines',\n            name='Actual', line=dict(color='black', width=3),\n            visible=(location==default_location),\n            showlegend=(row==0)\n        ), row=row + 1, col=1)\n        number_of_lines = len(top_teams) * 3 + 1\n        region_plot_names.extend([location] * number_of_lines)\n\nbuttons = []\nfor location in location_names:\n    buttons.append(dict(\n        method='update',\n        label=location,\n        args = [{\n            'visible': [location==r for r in region_plot_names],\n            'title': location\n        }]\n    ))\n\n_ = fig.update_layout(\n    updatemenus=[{'buttons': buttons,\n                  'direction': 'down',\n                  'active': location_names.index(default_location),\n                  'showactive': True, 'x': 0.58, 'y': 1.1\n                }],\n    yaxis_title=targets[0],\n    yaxis2_title=targets[1],\n    height=1000\n)\nfig.show()","2b40dfb8":"for location in locations.Location.values[:20]:\n    for target in ['ConfirmedCases', 'Fatalities']:\n        fig = draw_predictions(location, target)\n        fig.show()","dfdf84ee":"for location in ['Hungary--']:\n    for target in ['ConfirmedCases', 'Fatalities']:\n        fig = draw_predictions(location, target)\n        fig.show()","6a378812":"# Unexpected Regions","1fb765ba":"# Private Leaderboard","6b0918db":"## Top regions with select button","a3bcb3b1":"\n## A couple of more charts...","0d0da952":"# Calculate Weighted Pinball Loss\n","0af2fb0b":"# Read Submission Files","cd8993e9":"# Read train test files","324781fd":"# Check correlations"}}