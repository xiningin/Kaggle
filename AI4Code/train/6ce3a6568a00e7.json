{"cell_type":{"c06f4277":"code","94c547de":"code","56c93f3e":"code","814adfa4":"code","ec831d59":"code","aa1a9e81":"code","3d71412f":"code","3f273643":"code","87982247":"code","c340316c":"code","55f95467":"code","0a39120f":"code","2cc33f26":"code","b083732a":"code","ce79d228":"code","bfde5119":"code","b4fc5f0c":"code","d4458ff2":"code","d6a1bb5b":"markdown","7de299f3":"markdown"},"source":{"c06f4277":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","94c547de":"import os\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns#data visualization\nimport numpy as np\nimport pandas as pd\nfrom glob import glob #collecting files with the same extensions \nfrom PIL import Image\nnp.random.seed(11) # any nymber\n\nfrom sklearn.preprocessing import StandardScaler \nfrom sklearn.model_selection import train_test_split, KFold, cross_val_score, GridSearchCV\nfrom sklearn.metrics import accuracy_score\nimport itertools\n\nfrom keras.preprocessing import image\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.python.keras.models import Sequential\nfrom tensorflow.python.keras.layers import Dense\nfrom tensorflow.python.keras import optimizers\nfrom tensorflow.keras.applications.resnet50 import ResNet50\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout, Flatten, Conv2D, MaxPool2D\nfrom tensorflow.keras.models import Sequential, Model\nfrom tensorflow.keras.optimizers import Adam, RMSprop\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.callbacks import ReduceLROnPlateau\nfrom tensorflow.keras.wrappers.scikit_learn import KerasClassifier\nfrom keras.utils.np_utils import to_categorical # used for converting labels to one-hot-encoding\nprint(tf.__version__)\n\nfrom sklearn.metrics import roc_auc_score, auc\nfrom sklearn.metrics import roc_curve\n\nimport cv2\nimport joblib","56c93f3e":"# total 3820\n# 2637 trained data\n# 523 (.2) validation\n# 660 test\nfolder_benign_train = '..\/input\/dataset\/data\/train\/benign'\nfolder_malignant_train = '..\/input\/dataset\/data\/train\/malignant'\nfolder_benign_test = '..\/input\/dataset\/data\/test\/benign'\nfolder_malignant_test = '..\/input\/dataset\/data\/test\/malignant'","814adfa4":"read = lambda imname: np.asarray(Image.open(imname).convert(\"RGB\"))\n\n# convert malignant train data to array and RGB\nims_malignant = [read(os.path.join(folder_malignant_train, filename)) for filename in os.listdir(folder_malignant_train)]\nX_malignant = np.array(ims_malignant, dtype='uint8')\n\n\n\n# convert benign train  to array and RGB\nread = lambda imname: np.asarray(Image.open(imname).convert(\"RGB\"))\nims_benign = [read(os.path.join(folder_benign_train, filename)) for filename in os.listdir(folder_benign_train)]\nX_benign = np.array(ims_benign, dtype='uint8')\n\n\n'''\n# join each image id with it's folder name: as folder_benign_train or folder_malignant_train\nims_malignant = [read(os.path.join(folder_malignant_train, filename)) for filename in os.listdir(folder_malignant_train)]\nX_malignant = np.array(ims_malignant, dtype='uint8')\n'''\n\n# convert benign test data to RGB\nims_benign = [read(os.path.join(folder_benign_test, filename)) for filename in os.listdir(folder_benign_test)]\nX_benign_test = np.array(ims_benign, dtype='uint8')\n\n# convert MALIGNANT test data to RGB\nims_malignant = [read(os.path.join(folder_malignant_test, filename)) for filename in os.listdir(folder_malignant_test)]\nX_malignant_test = np.array(ims_malignant, dtype='uint8')\n\n\n# #####################\n\n\n# Create labels\n# encoding targets : benign as zero and malignant as ones,this happen for test and train data \ny_benign = np.zeros(X_benign.shape[0])\ny_malignant = np.ones(X_malignant.shape[0])\n\ny_benign_test = np.zeros(X_benign_test.shape[0])\ny_malignant_test = np.ones(X_malignant_test.shape[0])\n\n\n# ##############\n\n# Merge data \"BENIGN AND MALIGNANT \" \"FOR TRAIN AND TEST\"\nX_train = np.concatenate((X_benign, X_malignant), axis = 0)\ny_train = np.concatenate((y_benign, y_malignant), axis = 0)\n\nX_test = np.concatenate((X_benign_test, X_malignant_test), axis = 0)\ny_test = np.concatenate((y_benign_test, y_malignant_test), axis = 0)\n\n# ########3####\n\n# Shuffle data FOR TRAIN \ns = np.arange(X_train.shape[0])\nnp.random.shuffle(s)\nX_train = X_train[s]\ny_train = y_train[s]\n\n# Shuffle data FOR TEST\ns = np.arange(X_test.shape[0])\nnp.random.shuffle(s)\nX_test = X_test[s]\ny_test = y_test[s]\n\n\n\nprint('train: {} \\nTeste: {}'.format(len(X_train), len(X_test)))","ec831d59":"# Display first 15 images of moles, and how they are classified\nw=40\nh=30\nfig=plt.figure(figsize=(12, 8))\ncolumns = 5\nrows = 3\n\nfor i in range(1, columns*rows +1):\n    ax = fig.add_subplot(rows, columns, i)\n    if y_train[i] == 0:\n        ax.title.set_text('Benign')\n    else:\n        ax.title.set_text('Malignant')\n    plt.imshow(X_train[i], interpolation='nearest')\nplt.show()","aa1a9e81":"y_train = to_categorical(y_train, num_classes= 2)\ny_test = to_categorical(y_test, num_classes= 2)","3d71412f":"# With data augmentation to prevent overfitting \nX_train = X_train\/255.\nX_test = X_test\/255.","3f273643":"\n# Set a learning rate annealer\nlearning_rate_reduction = ReduceLROnPlateau(monitor='val_acc', \n                                            patience=5, \n                                            verbose=1, \n                                            factor=0.1, \n                                            min_lr=0.01)\n","87982247":"# Step 8: ResNet50\n\ninput_shape = (224,224,3)\nlr = 1e-5\nepochs = 50\nbatch_size = 64\n\nmodel = ResNet50(include_top=True,\n                 weights= None,\n                 input_tensor=None,\n                 input_shape=input_shape,\n                 pooling='avg',\n                 classes=2)\n\nmodel.compile(optimizer = Adam(lr) ,\n              loss = \"binary_crossentropy\", \n              metrics=[\"accuracy\"])\n\n# fit model fpr just 2190 sample as we took 523 sample(0.2) as validation \nhistory = model.fit(X_train, y_train, validation_split=0.2,\n                    epochs= epochs, batch_size= batch_size, verbose=1, \n                    callbacks=[learning_rate_reduction]\n                   )\n\n# list all data in history\nprint(history.history.keys())\n","c340316c":"# without validation split \n# applied for all trained data (2637)\nmodel.fit(X_train, y_train,\n                    epochs= epochs, batch_size= batch_size, verbose=1, \n                    callbacks=[learning_rate_reduction]\n                   )","55f95467":"# summarize history for accuracy\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()\n# summarize history for loss\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","0a39120f":"# Testing model on test data to evaluate\ny_pred = model.predict(X_test)\nprint(accuracy_score(np.argmax(y_test, axis=1), np.argmax(y_pred, axis=1)))\n","2cc33f26":"# summarize feature map size for each conv layer\n\n# summarize feature map shapes\nfor i in range(len(model.layers)):\n\tlayer = model.layers[i]\n\t# check for convolutional layer\n\tif 'conv' not in layer.name:\n\t\tcontinue\n\t# summarize output shape\n\tprint(i, layer.name, layer.output.shape)","b083732a":"#roc curve \n\nroc_log = roc_auc_score(np.argmax(y_test, axis=1), np.argmax(y_pred, axis=1))\nfalse_positive_rate, true_positive_rate, threshold = roc_curve(np.argmax(y_test, axis=1), np.argmax(y_pred, axis=1))\narea_under_curve = auc(false_positive_rate, true_positive_rate)\n\nplt.plot([0, 1], [0, 1], 'r--')\nplt.plot(false_positive_rate, true_positive_rate, label='AUC = {:.3f}'.format(area_under_curve))\nplt.xlabel('False positive rate')\nplt.ylabel('True positive rate')\nplt.title('ROC curve')\nplt.legend(loc='best')\nplt.show()\n#plt.savefig(ROC_PLOT_FILE, bbox_inches='tight')\nplt.close()\n","ce79d228":"from sklearn.metrics import confusion_matrix\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=55)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    plt.tight_layout()\n\ncm = confusion_matrix(np.argmax(y_test, axis=1), np.argmax(y_pred , axis=1))\n\ncm_plot_label =['benign', 'malignant']\nplot_confusion_matrix(cm, cm_plot_label, title ='Confusion Metrix for Skin Cancer')\n","bfde5119":"# save model\n# serialize model to JSON\nresnet50_json = model.to_json()\n\nwith open(\"resnet50.json\", \"w\") as json_file:\n    json_file.write(resnet50_json)\n    \n# serialize weights to HDF5\nmodel.save_weights(\"resnet50.h5\")\nprint(\"Saved model to disk\")","b4fc5f0c":"# final test\nimage = Image.open(\"..\/input\/final-test\/download (1).jpg\")\nnew_image = image.resize((224, 224))\nnew_image.save('new_image.jpg')\n\nprint(image.size) # Output: (1200, 776)\nprint(new_image.size) # Output: (400, 400)","d4458ff2":"from keras.preprocessing import image\nimg=image.load_img('..\/input\/final-test\/download (1).jpg', target_size=(224,224) )\ntarget_size=(224,224)\nnew = np.asarray(img)\n#image=image.img_to_array(img)\nnew = new.reshape(1,224,224,3) \nclasses=model.predict(new)\nprint(classes[0])","d6a1bb5b":"# Import libraries","7de299f3":"# Setup notebook "}}