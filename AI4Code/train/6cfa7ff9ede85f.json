{"cell_type":{"dcc91237":"code","55ecb9d6":"code","fbf92eb8":"code","bb411e3b":"code","a486ae1b":"code","eb049f8e":"code","4cf4bc55":"code","609213d5":"code","2a608d52":"code","f4877aeb":"code","5a60c7dc":"code","880b9d7f":"code","351a88ef":"code","c409bc2a":"code","21d70912":"code","b632983f":"code","8a49a4a4":"code","52b8ba38":"code","80a1dcc7":"code","8e5a3eaf":"code","072532ed":"code","52dedb66":"code","df6ba78c":"code","ff9b44b8":"code","925565ec":"code","9c2ff2f7":"code","5cd5684d":"code","73ecdb5a":"code","1edac3ff":"code","16056d96":"code","605a3cac":"code","1f6d9fc2":"code","1c5e4163":"code","2d431045":"markdown","2697e2a7":"markdown","1e0408a5":"markdown","e41d1935":"markdown","3f01258b":"markdown","a272dc69":"markdown","4bfb195d":"markdown","15403568":"markdown","b19550f5":"markdown","b3b7f7db":"markdown","f135f867":"markdown","4a829373":"markdown","0c23442e":"markdown","d44da199":"markdown","1ffabec0":"markdown"},"source":{"dcc91237":"import numpy as np \nimport pandas as pd \nimport tensorflow as tf\nimport sys\nimport collections\nsys.path.extend(['..\/input\/bert-joint-baseline\/'])\n\nimport bert_utils\nimport modeling \n\nimport tokenization\nimport json\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","55ecb9d6":"on_kaggle_server = os.path.exists('\/kaggle')\nnq_test_file = '..\/input\/tensorflow2-question-answering\/simplified-nq-test.jsonl' \nnq_train_file = '..\/input\/tensorflow2-question-answering\/simplified-nq-train.jsonl'\npublic_dataset = os.path.getsize(nq_test_file)<20_000_000\nprivate_dataset = os.path.getsize(nq_test_file)>=20_000_000","fbf92eb8":"if True:\n    import importlib\n    importlib.reload(bert_utils)","bb411e3b":"with open('..\/input\/bert-joint-baseline\/bert_config.json','r') as f:\n    config = json.load(f)\nprint(json.dumps(config,indent=4))\n","a486ae1b":"class TDense(tf.keras.layers.Layer):\n    def __init__(self,\n                 output_size,\n                 kernel_initializer=None,\n                 bias_initializer=\"zeros\",\n                **kwargs):\n        super().__init__(**kwargs)\n        self.output_size = output_size\n        self.kernel_initializer = kernel_initializer\n        self.bias_initializer = bias_initializer\n    def build(self,input_shape):\n        dtype = tf.as_dtype(self.dtype or tf.keras.backend.floatx())\n        if not (dtype.is_floating or dtype.is_complex):\n          raise TypeError(\"Unable to build `TDense` layer with \"\n                          \"non-floating point (and non-complex) \"\n                          \"dtype %s\" % (dtype,))\n        input_shape = tf.TensorShape(input_shape)\n        if tf.compat.dimension_value(input_shape[-1]) is None:\n          raise ValueError(\"The last dimension of the inputs to \"\n                           \"`TDense` should be defined. \"\n                           \"Found `None`.\")\n        last_dim = tf.compat.dimension_value(input_shape[-1])\n        self.input_spec = tf.keras.layers.InputSpec(min_ndim=3, axes={-1: last_dim})\n        self.kernel = self.add_weight(\n            \"kernel\",\n            shape=[self.output_size,last_dim],\n            initializer=self.kernel_initializer,\n            dtype=self.dtype,\n            trainable=True)\n        self.bias = self.add_weight(\n            \"bias\",\n            shape=[self.output_size],\n            initializer=self.bias_initializer,\n            dtype=self.dtype,\n            trainable=True)\n        super(TDense, self).build(input_shape)\n    def call(self,x):\n        return tf.matmul(x,self.kernel,transpose_b=True)+self.bias\n    \ndef mk_model(config):\n    seq_len = config['max_position_embeddings']\n    unique_id  = tf.keras.Input(shape=(1,),dtype=tf.int64,name='unique_id')\n    input_ids   = tf.keras.Input(shape=(seq_len,),dtype=tf.int32,name='input_ids')\n    input_mask  = tf.keras.Input(shape=(seq_len,),dtype=tf.int32,name='input_mask')\n    segment_ids = tf.keras.Input(shape=(seq_len,),dtype=tf.int32,name='segment_ids')\n    BERT = modeling.BertModel(config=config,name='bert')\n    pooled_output, sequence_output = BERT(input_word_ids=input_ids,\n                                          input_mask=input_mask,\n                                          input_type_ids=segment_ids)\n    \n    logits = TDense(2,name='logits')(sequence_output)\n    start_logits,end_logits = tf.split(logits,axis=-1,num_or_size_splits= 2,name='split')\n    start_logits = tf.squeeze(start_logits,axis=-1,name='start_squeeze')\n    end_logits   = tf.squeeze(end_logits,  axis=-1,name='end_squeeze')\n    \n    ans_type      = TDense(5,name='ans_type')(pooled_output)\n    return tf.keras.Model([input_ for input_ in [unique_id,input_ids,input_mask,segment_ids] \n                           if input_ is not None],\n                          [unique_id,start_logits,end_logits,ans_type],\n                          name='bert-baseline')    ","eb049f8e":"small_config = config.copy()\nsmall_config['vocab_size']=16\nsmall_config['hidden_size']=64\nsmall_config['max_position_embeddings'] = 32\nsmall_config['num_hidden_layers'] = 4\nsmall_config['num_attention_heads'] = 4\nsmall_config['intermediate_size'] = 256\nsmall_config","4cf4bc55":"model= mk_model(config)","609213d5":"model.summary()","2a608d52":"cpkt = tf.train.Checkpoint(model=model)\ncpkt.restore('..\/input\/bert-joint-baseline\/model_cpkt-1').assert_consumed()","f4877aeb":"class DummyObject:\n    def __init__(self,**kwargs):\n        self.__dict__.update(kwargs)\n\nFLAGS=DummyObject(skip_nested_contexts=True,\n                 max_position=50,\n                 max_contexts=48,\n                 max_query_length=64,\n                 max_seq_length=512,\n                 doc_stride=128,\n                 include_unknowns=-1.0,\n                 n_best_size=20,\n                 max_answer_length=30)","5a60c7dc":"import tqdm\neval_records = \"..\/input\/bert-joint-baseline\/nq-test.tfrecords\"\n#nq_test_file = '..\/input\/tensorflow2-question-answering\/simplified-nq-test.jsonl'\nif on_kaggle_server and private_dataset:\n    eval_records='nq-test.tfrecords'\nif not os.path.exists(eval_records):\n    # tf2baseline.FLAGS.max_seq_length = 512\n    eval_writer = bert_utils.FeatureWriter(\n        filename=os.path.join(eval_records),\n        is_training=False)\n\n    tokenizer = tokenization.FullTokenizer(vocab_file='..\/input\/bert-joint-baseline\/vocab-nq.txt', \n                                           do_lower_case=True)\n\n    features = []\n    convert = bert_utils.ConvertExamples2Features(tokenizer=tokenizer,\n                                                   is_training=False,\n                                                   output_fn=eval_writer.process_feature,\n                                                   collect_stat=False)\n\n    n_examples = 0\n    tqdm_notebook= tqdm.tqdm_notebook if not on_kaggle_server else None\n    for examples in bert_utils.nq_examples_iter(input_file=nq_test_file, \n                                           is_training=False,\n                                           tqdm=tqdm_notebook):\n        for example in examples:\n            n_examples += convert(example)\n\n    eval_writer.close()\n    print('number of test examples: %d, written to file: %d' % (n_examples,eval_writer.num_features))","880b9d7f":"seq_length = FLAGS.max_seq_length #config['max_position_embeddings']\nname_to_features = {\n      \"unique_id\": tf.io.FixedLenFeature([], tf.int64),\n      \"input_ids\": tf.io.FixedLenFeature([seq_length], tf.int64),\n      \"input_mask\": tf.io.FixedLenFeature([seq_length], tf.int64),\n      \"segment_ids\": tf.io.FixedLenFeature([seq_length], tf.int64),\n  }\n\ndef _decode_record(record, name_to_features=name_to_features):\n    \"\"\"Decodes a record to a TensorFlow example.\"\"\"\n    example = tf.io.parse_single_example(serialized=record, features=name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n        t = example[name]\n        if name != 'unique_id': #t.dtype == tf.int64:\n            t = tf.cast(t, dtype=tf.int32)\n        example[name] = t\n\n    return example\n\ndef _decode_tokens(record):\n    return tf.io.parse_single_example(serialized=record, \n                                      features={\n                                          \"unique_id\": tf.io.FixedLenFeature([], tf.int64),\n                                          \"token_map\" :  tf.io.FixedLenFeature([seq_length], tf.int64)\n                                      })\n      \n","351a88ef":"raw_ds = tf.data.TFRecordDataset(eval_records)\ntoken_map_ds = raw_ds.map(_decode_tokens)\ndecoded_ds = raw_ds.map(_decode_record)\nds = decoded_ds.batch(batch_size=16,drop_remainder=False)","c409bc2a":"result=model.predict_generator(ds,verbose=1)","21d70912":"np.savez_compressed('bert-joint-baseline-output.npz',\n                    **dict(zip(['uniqe_id','start_logits','end_logits','answer_type_logits'],\n                               result)))","b632983f":"Span = collections.namedtuple(\"Span\", [\"start_token_idx\", \"end_token_idx\"])","8a49a4a4":"class ScoreSummary(object):\n  def __init__(self):\n    self.predicted_label = None\n    self.short_span_score = None\n    self.cls_token_score = None\n    self.answer_type_logits = None","52b8ba38":"class EvalExample(object):\n  \"\"\"Eval data available for a single example.\"\"\"\n  def __init__(self, example_id, candidates):\n    self.example_id = example_id\n    self.candidates = candidates\n    self.results = {}\n    self.features = {}","80a1dcc7":"def get_best_indexes(logits, n_best_size):\n  \"\"\"Get the n-best logits from a list.\"\"\"\n  index_and_score = sorted(\n      enumerate(logits[1:], 1), key=lambda x: x[1], reverse=True)\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\ndef top_k_indices(logits,n_best_size,token_map):\n    indices = np.argsort(logits[1:])+1\n    indices = indices[token_map[indices]!=-1]\n    return indices[-n_best_size:]","8e5a3eaf":"def compute_predictions(example):\n  \"\"\"Converts an example into an NQEval object for evaluation.\"\"\"\n  predictions = []\n  n_best_size = FLAGS.n_best_size\n  max_answer_length = FLAGS.max_answer_length\n  i = 0\n  for unique_id, result in example.results.items():\n    if unique_id not in example.features:\n      raise ValueError(\"No feature found with unique_id:\", unique_id)\n    token_map = np.array(example.features[unique_id][\"token_map\"]) #.int64_list.value\n    start_indexes = top_k_indices(result.start_logits,n_best_size,token_map)\n    if len(start_indexes)==0:\n        continue\n    end_indexes   = top_k_indices(result.end_logits,n_best_size,token_map)\n    if len(end_indexes)==0:\n        continue\n    indexes = np.array(list(np.broadcast(start_indexes[None],end_indexes[:,None])))  \n    indexes = indexes[(indexes[:,0]<indexes[:,1])*(indexes[:,1]-indexes[:,0]<max_answer_length)]\n    for start_index,end_index in indexes:\n        summary = ScoreSummary()\n        summary.short_span_score = (\n            result.start_logits[start_index] +\n            result.end_logits[end_index])\n        summary.cls_token_score = (\n            result.start_logits[0] + result.end_logits[0])\n        summary.answer_type_logits = result.answer_type_logits-result.answer_type_logits.mean()\n        start_span = token_map[start_index]\n        end_span = token_map[end_index] + 1\n\n        # Span logits minus the cls logits seems to be close to the best.\n        score = summary.short_span_score - summary.cls_token_score\n        predictions.append((score, i, summary, start_span, end_span))\n        i += 1 # to break ties\n\n  # Default empty prediction.\n  score = -10000.0\n  short_span = Span(-1, -1)\n  long_span  = Span(-1, -1)\n  summary    = ScoreSummary()\n\n  if predictions:\n    score, _, summary, start_span, end_span = sorted(predictions, reverse=True)[0]\n    short_span = Span(start_span, end_span)\n    for c in example.candidates:\n      start = short_span.start_token_idx\n      end = short_span.end_token_idx\n      ## print(c['top_level'],c['start_token'],start,c['end_token'],end)\n      if c[\"top_level\"] and c[\"start_token\"] <= start and c[\"end_token\"] >= end:\n        long_span = Span(c[\"start_token\"], c[\"end_token\"])\n        break\n\n  summary.predicted_label = {\n      \"example_id\": int(example.example_id),\n      \"long_answer\": {\n          \"start_token\": int(long_span.start_token_idx),\n          \"end_token\": int(long_span.end_token_idx),\n          \"start_byte\": -1,\n          \"end_byte\": -1\n      },\n      \"long_answer_score\": float(score),\n      \"short_answers\": [{\n          \"start_token\": int(short_span.start_token_idx),\n          \"end_token\": int(short_span.end_token_idx),\n          \"start_byte\": -1,\n          \"end_byte\": -1\n      }],\n      \"short_answer_score\": float(score),\n      \"yes_no_answer\": \"NONE\",\n      \"answer_type_logits\": summary.answer_type_logits.tolist(),\n      # here:\n      \"answer_type\": int(np.argmax(summary.answer_type_logits))\n  }\n\n  return summary","072532ed":"def compute_pred_dict(candidates_dict, dev_features, raw_results,tqdm=None):\n    \"\"\"Computes official answer key from raw logits.\"\"\"\n    raw_results_by_id = [(int(res.unique_id),1, res) for res in raw_results]\n\n    examples_by_id = [(int(k),0,v) for k, v in candidates_dict.items()]\n  \n    features_by_id = [(int(d['unique_id']),2,d) for d in dev_features] \n  \n    # Join examples with features and raw results.\n    examples = []\n    print('merging examples...')\n    merged = sorted(examples_by_id + raw_results_by_id + features_by_id)\n    print('done.')\n    for idx, type_, datum in merged:\n        if type_==0: #isinstance(datum, list):\n            examples.append(EvalExample(idx, datum))\n        elif type_==2: #\"token_map\" in datum:\n            examples[-1].features[idx] = datum\n        else:\n            examples[-1].results[idx] = datum\n\n    # Construct prediction objects.\n    print('Computing predictions...')\n   \n    nq_pred_dict = {}\n    #summary_dict = {}\n    if tqdm is not None:\n        examples = tqdm(examples)\n    for e in examples:\n        summary = compute_predictions(e)\n        #summary_dict[e.example_id] = summary\n        nq_pred_dict[e.example_id] = summary.predicted_label\n\n    return nq_pred_dict\n","52dedb66":"def read_candidates_from_one_split(input_path):\n  \"\"\"Read candidates from a single jsonl file.\"\"\"\n  candidates_dict = {}\n  print(\"Reading examples from: %s\" % input_path)\n  if input_path.endswith(\".gz\"):\n    with gzip.GzipFile(fileobj=tf.io.gfile.GFile(input_path, \"rb\")) as input_file:\n      for index, line in enumerate(input_file):\n        e = json.loads(line)\n        candidates_dict[e[\"example_id\"]] = e[\"long_answer_candidates\"]\n        \n  else:\n    with tf.io.gfile.GFile(input_path, \"r\") as input_file:\n      for index, line in enumerate(input_file):\n        e = json.loads(line)\n        candidates_dict[e[\"example_id\"]] = e[\"long_answer_candidates\"]\n        # candidates_dict['question'] = e['question_text']\n  return candidates_dict","df6ba78c":"def read_candidates(input_pattern):\n  \"\"\"Read candidates with real multiple processes.\"\"\"\n  input_paths = tf.io.gfile.glob(input_pattern)\n  final_dict = {}\n  for input_path in input_paths:\n    final_dict.update(read_candidates_from_one_split(input_path))\n  return final_dict","ff9b44b8":"all_results = [bert_utils.RawResult(*x) for x in zip(*result)]\n    \nprint (\"Going to candidates file\")\n\ncandidates_dict = read_candidates('..\/input\/tensorflow2-question-answering\/simplified-nq-test.jsonl')\n\nprint (\"setting up eval features\")\n\neval_features = list(token_map_ds)\n\nprint (\"compute_pred_dict\")\n\ntqdm_notebook= tqdm.tqdm_notebook\nnq_pred_dict = compute_pred_dict(candidates_dict, \n                                       eval_features,\n                                       all_results,\n                                      tqdm=tqdm_notebook)\n\npredictions_json = {\"predictions\": list(nq_pred_dict.values())}\n\nprint (\"writing json\")\n\nwith tf.io.gfile.GFile('predictions.json', \"w\") as f:\n    json.dump(predictions_json, f, indent=4)","925565ec":"def create_short_answer(entry):\n    answer = []    \n    if entry['answer_type'] == 0:\n        return \"\"\n    \n    elif entry['answer_type'] == 1:\n        return 'YES'\n    \n    elif entry['answer_type'] == 2:\n        return 'NO'\n        \n    elif entry[\"short_answer_score\"] < 1.5:\n        return \"\"\n    \n    else:\n        for short_answer in entry[\"short_answers\"]:\n            if short_answer[\"start_token\"] > -1:\n                answer.append(str(short_answer[\"start_token\"]) + \":\" + str(short_answer[\"end_token\"]))\n    \n        return \" \".join(answer)\n\ndef create_long_answer(entry):\n    \n    answer = []\n    \n    if entry['answer_type'] == 0:\n        return ''\n    \n    elif entry[\"long_answer_score\"] < 1.5:\n        return \"\"\n\n    elif entry[\"long_answer\"][\"start_token\"] > -1:\n        answer.append(str(entry[\"long_answer\"][\"start_token\"]) + \":\" + str(entry[\"long_answer\"][\"end_token\"]))\n        return \" \".join(answer)","9c2ff2f7":"test_answers_df = pd.read_json(\"..\/working\/predictions.json\")\nfor var_name in ['long_answer_score','short_answer_score','answer_type']:\n    test_answers_df[var_name] = test_answers_df['predictions'].apply(lambda q: q[var_name])\ntest_answers_df[\"long_answer\"] = test_answers_df[\"predictions\"].apply(create_long_answer)\ntest_answers_df[\"short_answer\"] = test_answers_df[\"predictions\"].apply(create_short_answer)\ntest_answers_df[\"example_id\"] = test_answers_df[\"predictions\"].apply(lambda q: str(q[\"example_id\"]))\n\nlong_answers = dict(zip(test_answers_df[\"example_id\"], test_answers_df[\"long_answer\"]))\nshort_answers = dict(zip(test_answers_df[\"example_id\"], test_answers_df[\"short_answer\"]))\n\ntest_answers_df.head()","5cd5684d":"sample_submission = pd.read_csv(\"..\/input\/tensorflow2-question-answering\/sample_submission.csv\")\n\nlong_prediction_strings = sample_submission[sample_submission[\"example_id\"].str.contains(\"_long\")].apply(lambda q: long_answers[q[\"example_id\"].replace(\"_long\", \"\")], axis=1)\nshort_prediction_strings = sample_submission[sample_submission[\"example_id\"].str.contains(\"_short\")].apply(lambda q: short_answers[q[\"example_id\"].replace(\"_short\", \"\")], axis=1)\n\nsample_submission.loc[sample_submission[\"example_id\"].str.contains(\"_long\"), \"PredictionString\"] = long_prediction_strings\nsample_submission.loc[sample_submission[\"example_id\"].str.contains(\"_short\"), \"PredictionString\"] = short_prediction_strings\n","73ecdb5a":"sample_submission.to_csv('submission.csv', index=False)","1edac3ff":"sample_submission.head()","16056d96":"yes_answers = sample_submission[sample_submission['PredictionString'] == 'YES']\nyes_answers","605a3cac":"no_answers = sample_submission[sample_submission['PredictionString'] == 'NO']\nno_answers","1f6d9fc2":"blank_answers = sample_submission[sample_submission['PredictionString'] == '']\nblank_answers.head()","1c5e4163":"blank_answers.count()","2d431045":"## 1- Understanding the code\n#### For a better understanding, I will briefly explain here.\n#### In the item \"answer_type\", in the last lines of this block, it is responsible for storing the identified response type, which, according to [github project repository](https:\/\/github.com\/google-research\/language\/blob\/master\/language\/question_answering\/bert_joint\/run_nq.py) can be:\n1. UNKNOWN = 0\n2. YES = 1\n3. NO = 2\n4. SHORT = 3\n5. LONG = 4","2697e2a7":"## 2- Main Change\n#### Here is the small, but main change: we created an if to check the predicted response type and thus filter \/ identify the responses that are passed to the submission file.","1e0408a5":"* No Answers","e41d1935":"### Setting the Flags","3f01258b":"### Generating the Submission File","a272dc69":"### If this notebook is useful to you, I appreciate your upvote :)\n\n### Now, after the change and official explanation of the [metric](https:\/\/www.kaggle.com\/c\/tensorflow2-question-answering\/overview\/evaluation), we can work more efficiently.\n### As we got here with the help of several kagglers, I will not change it to private.\n\n### This notebook is an edition of [bert joint baseline notebook](https:\/\/www.kaggle.com\/prokaj\/bert-joint-baseline-notebook\/notebook). With some modifications, it was possible to slightly improve the code and get the YES \/ NO answers and leave the unknowns blank.","4bfb195d":"* Yes Answers","15403568":"### Importing Libraries","b19550f5":"### Creating a DataFrame","b3b7f7db":"### Checkpoint","f135f867":"### Splitting the Dataset","4a829373":"### We'll be grateful if someone gets a better understanding and can share what really impacts the assessment. No need to share code, just knowledge.\n### Thank you!","0c23442e":"### Filtering the Answers","d44da199":"* Balnk Answers","1ffabec0":"### I am only sharing modifications that I believe may help. I left out Tunning and any significant code changes I made."}}