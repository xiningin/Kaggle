{"cell_type":{"bdbac298":"code","17584180":"code","35dbfcf8":"code","850f252a":"code","67d7b8fd":"code","ae3e4cf4":"code","e80f5ffa":"code","a1c32be1":"code","c746a8b4":"code","6b0e6a99":"code","7d8f9d20":"code","fceb9b73":"code","e4528b02":"code","d123413d":"code","72f5c850":"code","63e7c22f":"code","c3ce84cc":"code","7eb4d6d5":"code","436a70dd":"code","c4349038":"code","a63f5cd8":"code","7481fd83":"code","b576d95b":"code","a076b2c1":"code","62ee13f1":"code","552013dc":"code","520ba795":"code","268889fc":"code","4ff66e39":"code","a5bf05b8":"code","f089f824":"code","f5b8b0a6":"code","715bd992":"code","000fb451":"markdown","a582e890":"markdown","c5aa57bc":"markdown","d793f9bd":"markdown","84962a68":"markdown","ede85d86":"markdown","28d05619":"markdown","ece51a21":"markdown","848ceda8":"markdown","a5aa8cd9":"markdown","d583192b":"markdown","615da1fb":"markdown","35e94c8a":"markdown","d9e5e18e":"markdown","1088b17f":"markdown","2580f88d":"markdown","1ac07314":"markdown","0f318be8":"markdown","9b97cff9":"markdown","d01d33e7":"markdown","57efa3a8":"markdown","72a5ba14":"markdown","14497c71":"markdown","68d035a8":"markdown","6ab33a58":"markdown","659faeaa":"markdown","870dca9c":"markdown","52034b41":"markdown","d119030d":"markdown"},"source":{"bdbac298":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom plotly import tools\nimport plotly.plotly as py\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.figure_factory as ff\nfrom IPython.display import HTML, Image","17584180":"pkmn = pd.read_csv(\"..\/input\/Pokemon.csv\", index_col=0)\npkmn.head()","35dbfcf8":"pkmn.isnull().sum()","850f252a":"# Almost half of the Type 2 attribute is empty but it's because many pokemon have only one type. So fill NaN with 'Blank'\npkmn = pkmn.fillna(value={'Type 2':'Blank'})\npkmn.head()","67d7b8fd":"#Rename Column \"Type 1\" and \"Type 2\" to plot pie charts\npkmn.rename(columns={\"Type 1\":\"Type1\", \"Type 2\": \"Type2\"}, inplace=True)\npkmn.head()","ae3e4cf4":"d_frame = pkmn.iloc[:800,:]\ndonut= d_frame.Type1.value_counts()\nlabels = d_frame.Type1.value_counts().index\n\n#Creat figure\nfig = {\n    \"data\":\n    [\n        {\n            \"values\": donut,\n            \"labels\": labels,\n            \"domain\": {\"x\": [0, 1]},\n            \"name\": \"Type 1\",\n            \"hoverinfo\": \"label+percent+name\",\n            \"hole\": .4,\n            \"type\": \"pie\"\n        }, \n    ],\n    \"layout\":\n    {\n        \"title\":\"Type 1 of Pokemons\",\n        \"annotations\":\n        [\n            { \n                \"font\":{\"size\":20},\n                \"showarrow\":False,\n                \"text\": \"\",\n                \"x\": 0,\n                \"y\": 1\n            },\n        ]\n    }\n}\niplot(fig)","e80f5ffa":"d_frame = pkmn.iloc[:800,:]\ndonut= d_frame.Type2.value_counts()\nlabels = d_frame.Type2.value_counts().index\n\n#Creat figure\nfig = {\n    \"data\":\n    [\n        {\n            \"values\": donut,\n            \"labels\": labels,\n            \"domain\": {\"x\": [0, 1]},\n            \"name\": \"Type 2\",\n            \"hoverinfo\": \"label+percent+name\",\n            \"hole\": .4,\n            \"type\": \"pie\"\n        }, \n    ],\n    \"layout\":\n    {\n        \"title\":\"Type 2 of Pokemons\",\n        \"annotations\":\n        [\n            { \n                \"font\":{\"size\":20},\n                \"showarrow\":False,\n                \"text\": \"\",\n                \"x\": 0,\n                \"y\": 1\n            },\n        ]\n    }\n}\niplot(fig)","a1c32be1":"d_frame = pkmn.iloc[:800,:]\ndonut= d_frame.Generation.value_counts()\nlabels = d_frame.Generation.value_counts().index\n\n#Creat figure\nfig = {\n    \"data\":\n    [\n        {\n            \"values\": donut,\n            \"labels\": labels,\n            \"domain\": {\"x\": [0, 1]},\n            \"name\": \"Generation\",\n            \"hoverinfo\": \"label+percent+name\",\n            \"hole\": .4,\n            \"type\": \"pie\"\n        }, \n    ],\n    \"layout\":\n    {\n        \"title\":\"Generation of Pokemons\",\n        \"annotations\":\n        [\n            { \n                \"font\":{\"size\":20},\n                \"showarrow\":False,\n                \"text\": \"\",\n                \"x\": 0,\n                \"y\": 1\n            },\n        ]\n    }\n}\niplot(fig)","c746a8b4":"hist_data = [pkmn['HP'],pkmn['Attack'],pkmn['Defense'],pkmn['Sp. Atk'],pkmn['Sp. Def'],pkmn['Speed']]\ngroup_labels = list(pkmn.iloc[:,4:10].columns)\n\nfig = ff.create_distplot(hist_data, group_labels, bin_size=5)\niplot(fig, filename='Distribution of Pokemons Stats')","6b0e6a99":"data = []\nfor i in range(4,10):\n    trace = {\n            \"type\": 'violin',\n            \"x\": max(pkmn.iloc[:,i]),\n            \"y\": pkmn.iloc[:,i],\n            \"name\": list(pkmn.columns)[i],\n            \"box\": {\n                \"visible\": True\n            },\n            \"meanline\": {\n                \"visible\": True\n            }\n        }\n    data.append(trace)\n        \nfig = {\n    \"data\": data,\n    \"layout\" : {\n        \"title\": \"Violin plot of all stats\",\n        \"yaxis\": {\n            \"zeroline\": False,\n        }\n    }\n}\n\niplot(fig, filename='violin', validate = False)","7d8f9d20":"#Select first 400 pokemons, create 3d scatterplot of their abilities and use HP as solorscale\nd_frame = pkmn.iloc[:400,:]\nc = d_frame.HP\ntrace = go.Scatter3d(\n    x=d_frame.Attack,\n    y=d_frame.Defense,\n    z=d_frame.Speed,\n    text= d_frame.Name,\n    mode='markers',\n    marker=dict(\n        size=5,\n        color= c,           \n        colorscale='Viridis',  \n        opacity=0.7\n    )\n)\ndata = [trace]\nlayout = go.Layout(\n    margin=dict(\n        l=0,\n        r=0,\n        b=0,\n        t=0\n    )\n)\nfig = go.Figure(data=data, layout=layout)\niplot(fig)","fceb9b73":"plt.subplots(figsize=(20,15))\nax = plt.axes()\nax.set_title(\"Pokemon Ability Correlation Heatmap\")\ncorr = pkmn.corr()\nsns.heatmap(corr, \n            xticklabels=corr.columns.values,\n            yticklabels=corr.columns.values,\n           cmap=\"BuGn\",\n           annot =True)","e4528b02":"One = pkmn.loc[pkmn.Generation ==1,\"Total\"]\nTwo = pkmn.loc[pkmn.Generation ==2,\"Total\"]\nThree = pkmn.loc[pkmn.Generation ==3,\"Total\"]\nFour = pkmn.loc[pkmn.Generation ==4,\"Total\"]\nFive = pkmn.loc[pkmn.Generation ==5,\"Total\"]\nSix = pkmn.loc[pkmn.Generation ==6,\"Total\"]","d123413d":"plt.figure(figsize=(15,8))\nsns.kdeplot(One, color=\"lightcoral\", shade=False)\nsns.kdeplot(Two, color=\"steelblue\", shade=False)\nsns.kdeplot(Three, color=\"darkturquoise\", shade=False)\nsns.kdeplot(Four, color=\"forestgreen\", shade=False)\nsns.kdeplot(Five, color=\"dimgray\", shade=False)\nsns.kdeplot(Six, color=\"yellow\", shade=False)\nplt.legend(['One', 'Two','Three','Four','Five','Six'])\nplt.title('Density Plot of Generation')\nplt.show()","72f5c850":"legendary = pkmn.loc[pkmn.Legendary ==True,\"Total\"]\nnot_legendary = pkmn.loc[pkmn.Legendary ==False,\"Total\"]\n","63e7c22f":"plt.figure(figsize=(15,8))\nsns.kdeplot(legendary, color=\"lightcoral\", shade=False)\nsns.kdeplot(not_legendary, color=\"forestgreen\", shade=False)\nplt.legend(['Legendary', 'Not Legendary'])\nplt.title('Density Plot of Legendary or Not')\nplt.show()","c3ce84cc":"g = sns.pairplot(pkmn, hue='Type1', palette='muted')","7eb4d6d5":"pkmn_knn= pkmn.copy()\npkmn_knn.drop(['Name','Type1', 'Type2', 'Total'],axis=1, inplace=True)","436a70dd":"pkmn_knn['Legendary'] = pkmn_knn['Legendary'].astype(int)","c4349038":"from sklearn.preprocessing import StandardScaler\nscaler= StandardScaler()\nscaler.fit(pkmn_knn.drop('Legendary', axis=1))\nscaled_data= scaler.transform(pkmn_knn.drop('Legendary', axis=1))\nscaled= pd.DataFrame(scaled_data, columns=pkmn_knn.columns[:-1])","a63f5cd8":"X= scaled\ny= pkmn_knn['Legendary']","7481fd83":"scaled.head()","b576d95b":"from sklearn.model_selection import train_test_split","a076b2c1":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.2, random_state=88)","62ee13f1":"from sklearn.neighbors import KNeighborsClassifier","552013dc":"knn= KNeighborsClassifier(n_neighbors=1)","520ba795":"knn.fit(X_train, y_train)","268889fc":"predictions= knn.predict(X_test)","4ff66e39":"from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report\n\ndef get_metrics(y_test, predictions):  \n    # true positives \/ (true positives+false positives)\n    precision = precision_score(y_test, predictions, pos_label=None,\n                                    average='weighted')             \n    # true positives \/ (true positives + false negatives)\n    recall = recall_score(y_test, predictions, pos_label=None,\n                              average='weighted')\n    # harmonic mean of precision and recall\n    f1 = f1_score(y_test, predictions, pos_label=None, average='weighted')\n    # true positives + true negatives\/ total\n    accuracy = accuracy_score(y_test, predictions)\n    return accuracy, precision, recall, f1\n\naccuracy, precision, recall, f1 = get_metrics(y_test, predictions)\nprint(\"accuracy = %.3f, precision = %.3f, recall = %.3f, f1 = %.3f\" % (accuracy, precision, recall, f1))","a5bf05b8":"import itertools\nfrom sklearn.metrics import confusion_matrix\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.winter):\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title, fontsize=30)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, fontsize=15)\n    plt.yticks(tick_marks, classes, fontsize=15)\n    \n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt), horizontalalignment=\"center\", \n                 color=\"white\" if cm[i, j] < thresh else \"black\", fontsize=30)\n    \n    plt.tight_layout()\n    plt.ylabel('True label', fontsize=20)\n    plt.xlabel('Predicted label', fontsize=20)\n\n    return plt","f089f824":"cm= confusion_matrix(y_test, predictions)\nfig = plt.figure(figsize=(8, 8))\nplot = plot_confusion_matrix(cm, classes=['Non-Legendary','Legendary'], normalize=False, title='Confusion Matrix')\nplt.show()","f5b8b0a6":"error_rate = []\n\nfor i in range(1,40):\n    \n    knn = KNeighborsClassifier(n_neighbors=i)\n    knn.fit(X_train,y_train)\n    pred_i = knn.predict(X_test)\n    error_rate.append(np.mean(pred_i != y_test))","715bd992":"plt.figure(figsize=(10,6))\nplt.plot(range(1,40),error_rate,color='blue', linestyle='dashed', marker='o',\n         markerfacecolor='red', markersize=10)\nplt.title('Error Rate vs. K Value')\nplt.xlabel('K')\nplt.ylabel('Error Rate')","000fb451":"**Fit the training sets**","a582e890":"**3D Scatterplot**","c5aa57bc":"**Predict on test set**","d793f9bd":"We cannot see clusters in ability dimension. ","84962a68":"**Heat Map**","ede85d86":"**Data Cleaning**","28d05619":"We can see most Pokemons are in Water, Normal, Grass, Bug, Psychic and Fire types. And Flying  and Fairy are the rarest types.","ece51a21":"** Standardize data**","848ceda8":"We can't see a strong trend with Pokemon type. ","a5aa8cd9":"**Pair Plot**","d583192b":"Almost half of pokemons don't have Type 2. An interesting finding is in Type 1, there are very few flying pokemons but in Type 2, flying is the biggest group.","615da1fb":"Legendary pokemons have higher points than non-legendary pokemons.","35e94c8a":"**Pie Chart**","d9e5e18e":"**Train Test Split Data for KNN**","1088b17f":"Generation 1 and 2 are the biggest groups while Generation 6 is the smallest one.","2580f88d":"**Density Plot**","1ac07314":"** Plot Confusion Matrix**","0f318be8":"   Correlation between ability variables are not very significant.","9b97cff9":"There is no much difference between generations.","d01d33e7":"# Pok\u00e9mon : EDA and KNN\n\n#### Data :\n* **Name** Name of the Pokemon\n* **Type 1** First ability\n* **Type 2** Second ability\n* **Total** Sum of all power points\n* **HP** Health Points\n* **Attack** Attack points\n* **Defense** Defense points\n* **Sp. Atk** Speed points on attack\n* **Sp. Def** Speed points on defense\n* **Speed** Speed points\n* **Generation** Number of generation (1-6)\n* **Legendary** True\/False \n","57efa3a8":"**Import KNN with sklearn library**","72a5ba14":"## KNN","14497c71":"** Best n_neighbors value**\n\n* knn= KNeighborsClassifier(n_neighbors=1)","68d035a8":"**Import Data**","6ab33a58":"**Violin Plot**","659faeaa":"**Histogram**","870dca9c":"## EDA","52034b41":"All abilities are close to normal distribution with a little right skewness. We can use violin plot to separate abilities and have a clearer look.","d119030d":"In predicting non-legendary pokemon, the model has a very good accuracy. In total 152 non-legendary pokemons, it only wrongly predicts 2. But in terms of legendary pokemon, it wrongly 2 pokemons out of 8."}}