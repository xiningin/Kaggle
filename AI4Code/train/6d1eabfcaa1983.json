{"cell_type":{"7b4347e8":"code","585306ea":"code","8ca6b024":"code","66823491":"code","30040641":"code","45829278":"code","65960773":"code","9a53c031":"markdown"},"source":{"7b4347e8":"from collections import namedtuple\nimport sys\nimport lightgbm as lg\nfrom tqdm import tqdm\nimport numpy as np\nfrom sortedcontainers import SortedDict\nfrom sklearn.metrics import roc_auc_score\n\nEventBody = namedtuple('EventBody', [\n                       'time', 'id', 'action', 'type', 'side', 'price', 'amount', 'is_snapshot', 'Y'])\n\nclass Event(EventBody):\n    @property\n    def need_prediction(self):\n        return self.Y >= 0","585306ea":"class Side:\n    BID = 0\n    ASK = 1\n\nclass Action:\n    DELETE = 0\n    ADD = 1\n    MODIFY_AMOUNT = 2\n    DEAL = 3\n    NEW_CHUNK = 10\n\nMIN_PRICE = 0\nMAX_PRICE = 10**10\n\nDEBUG = False\n\nclass Order:\n    def __init__(self, event):\n        self.order_id = event.id\n        self.side = event.side\n        self.price = event.price\n        self.type = event.type\n        self.amount = event.amount\n        self.initial_amount = event.amount\n        self.time = event.time\n\n\nclass PriceLevel:\n    def __init__(self, side, price):\n        self.side = side\n        self.price = price\n        self.orders = []\n        self.num_orders = 0\n        self.total_amount = 0\n        self.id_to_order = {}\n\n    def add_order(self, order):\n        self.orders.append(order)\n        self.num_orders += 1\n        self.total_amount += order.amount\n        self.id_to_order[order.order_id] = order\n        self._check_level()\n\n    def _get_order(self, order_id):\n        return self.id_to_order[order_id]\n\n    def delete_order(self, order_id):\n        order = self._get_order(order_id)\n\n        self.num_orders -= 1\n        self.total_amount -= order.amount\n        self.orders.remove(order)\n        del self.id_to_order[order_id]\n        self._check_level()\n\n    def modify_order(self, order_id, new_amount):\n        order = self._get_order(order_id)\n        change_amount = order.amount - new_amount\n        assert change_amount > 0\n        order.amount -= change_amount\n        self.total_amount -= change_amount\n        self._check_level()\n\n    def get_volume(self):\n        return self.total_amount\n\n    def get_num_orders(self):\n        return self.num_orders\n\n    def get_orders(self):\n        return self.orders\n\n    def _check_level(self):\n        if not DEBUG:\n            return\n        assert self.num_orders == len(self.orders)\n        assert sum([o.amount for o in self.orders]) == self.total_amount\n        \n\n\nclass OrderBook:\n    def __init__(self):\n        self._clear()\n\n    def _clear(self):\n        self.best_price = [MIN_PRICE, MAX_PRICE]\n        self.price_levels = [SortedDict(), SortedDict()]\n        self.time = 0\n        self.events = []\n\n    def _get_empty_price(self, side):\n        return MIN_PRICE if side == Side.BID else MAX_PRICE\n\n    def _get_updated_best_price(self, side):\n        if len(self.price_levels[side]) == 0:\n            return self._get_empty_price(side)\n        if side == Side.BID:\n            return self.price_levels[side].peekitem(-1)[0]  # max_key\n        return self.price_levels[side].peekitem(0)[0]  # min_key\n\n    def get_price_level(self, side, price):\n        if price not in self.price_levels[side]:\n            self.price_levels[side][price] = PriceLevel(side, price)\n        return self.price_levels[side][price]\n\n    def add_order(self, order):\n        side, price = order.side, order.price\n        self.get_price_level(side, price).add_order(order)\n        self.best_price[side] = self._get_updated_best_price(side)\n\n    def _del_if_empty(self, side, price):\n        if self.price_levels[side][price].get_num_orders() == 0:\n            del self.price_levels[side][price]\n            if price == self.get_best_price(side):\n                self.best_price[side] = self._get_updated_best_price(side)\n\n    def delete_order(self, side, price, order_id):\n        self.price_levels[side][price].delete_order(order_id)\n        self._del_if_empty(side, price)\n        \n    def modify_order(self, side, price, order_id, new_amount):\n        self.price_levels[side][price].modify_order(order_id, new_amount)\n        self._del_if_empty(side, price)\n\n    def apply_event(self, event):\n        self.time = event.time\n        self.events.append(event)\n\n        if event.action == Action.DELETE:  # deletion\n            self.delete_order(event.side, event.price, event.id)\n        elif event.action == Action.MODIFY_AMOUNT:  # modifying\n            self.modify_order(event.side, event.price, event.id, event.amount)\n        elif event.action == Action.ADD:  # adding new order\n            self.add_order(Order(event=event))\n        elif event.action == Action.NEW_CHUNK: \n            self._clear()\n        else:\n            pass\n        assert self.best_price[1] > self.best_price[0]\n\n    def get_best_price(self, side):\n        return self.best_price[side]\n\n    def get_mean_price(self):\n        return (self.best_price[Side.BID] + self.best_price[Side.ASK]) \/ 2.0\n\n    def get_time(self):\n        return self.time\n\n    def get_events(self):\n        return self.events\n\n    def get_price_at_ix(self, side, index):\n        return self.best_price[side] - index * (1 - 2 * side)\n\n    def get_ix_at_price(self, side, price):\n        return (self.best_price[side] - price) * (1 - 2 * side)\n\n    def get_price_level_at_ix(self, side, ix):\n        price = self.get_price_at_ix(side, ix)\n        return self.price_levels[side].get(price, None)\n\n\nclass EventPlayer:\n    def __init__(self, filename):\n        self.events = np.load(filename)[\"events\"]\n\n    def iget_events(self):\n        for event in self.events:\n            yield Event(*event)\n\n    def __len__(self):\n        return len(self.events)","8ca6b024":"SIDE_BID = 0 \nSIDE_ASK = 1\n\ndef get_simple_features_from_orderbook(orderbook, max_index=2):\n    '''\n        Getting simple features from the orderbook\n    '''\n    spread = orderbook.get_best_price(SIDE_ASK) - orderbook.get_best_price(SIDE_BID)\n    features = [spread]\n    for side in (SIDE_BID, SIDE_ASK):\n        for ix in range(max_index):\n            price_level = orderbook.get_price_level_at_ix(side, ix)\n            if price_level is None:\n                features += [-1, -1]\n            else:\n                features += [price_level.get_volume(), \n                             price_level.get_num_orders()]\n    return features\n\n\ndef get_simple_deals_features(last_deals, orderbook):\n    '''\n        Getting simple features from the last deals\n    '''\n    cur_mean_price = orderbook.get_mean_price()\n    cur_time = orderbook.get_time()\n\n    features = []\n    for side in (SIDE_BID, SIDE_ASK):\n        deal_event = last_deals[side]\n        if deal_event is None:\n            features += [-1e9, -1e9, -1e9]\n        else:\n            features += [cur_mean_price - deal_event.price, \n                         cur_time - deal_event.time, \n                         deal_event.amount]\n    return features\n\n\ndef collect_dataset(data_path):\n    '''\n        Collecting dataset\n    '''\n    event_player = EventPlayer(data_path)\n    orderbook = OrderBook()\n\n    X = []\n    Y = []\n\n    last_deals = [None, None]\n    for ev in tqdm(event_player.iget_events(), \n                    total=len(event_player), \n                    desc=\"collecting dataset\"):\n        if ev.action == Action.DEAL:\n            last_deals[ev.side] = ev\n        elif ev.action == Action.NEW_CHUNK:\n            last_deals = [None, None]\n        \n        orderbook.apply_event(ev)\n        if ev.need_prediction:\n            features = get_simple_features_from_orderbook(orderbook)\n            features += get_simple_deals_features(last_deals, orderbook)\n\n            X.append(features)\n            Y.append(ev.Y)\n\n    print(f\"Dataset collected: len(X) = {len(X)}\")\n    return np.array(X), np.array(Y)\n\n\nX_train, Y_train = collect_dataset(\"..\/input\/orderbooks-events-binary-classification\/train_small_A.npz\")\nX_test, Y_test = collect_dataset(\"..\/input\/orderbooks-events-binary-classification\/train_small_B.npz\")","66823491":"def train_classifier(X_train, Y_train, X_test, Y_test):\n    '''\n        Classifier training\n    '''\n    clf = lg.LGBMClassifier(num_leaves=31, n_estimators=1000, learning_rate=0.1)\n    clf.fit(X_train, Y_train, eval_set=[(X_test, Y_test)], \n            eval_metric=\"auc\", early_stopping_rounds=20)\n    return clf\n \nclf = train_classifier(X_train, Y_train, X_test, Y_test)","30040641":"last_deals = [None, None]\n\ndef process_event_and_predict_proba(event, orderbook):\n    if event.action == Action.DEAL:\n        last_deals[event.side] = event\n    elif event.action == Action.NEW_CHUNK:\n        last_deals[:] = [None, None]\n        \n    if not event.need_prediction:\n        return None\n    \n    features = get_simple_features_from_orderbook(orderbook)\n    features += get_simple_deals_features(last_deals, orderbook)    \n    proba = clf.predict_proba([features])[0, 1]\n    return proba","45829278":"class Scorer:\n    def __init__(self, fname):\n        self.fname = fname\n        self.event_player = EventPlayer(fname)\n\n    def _check_return_value(self, event, pred_proba):\n        if event.need_prediction:\n            if pred_proba is None:\n                raise ValueError(\"You should return probability if event.need_prediction == True\")\n            if not (0 <= pred_proba <= 1):\n                raise ValueError(\"Predicted probability is not in [0, 1] range\")\n        else:\n            if pred_proba is not None:\n                raise ValueError(\"Return probability should be None if event.need_prediction == False\")\n\n    def score(self, process_event_func):\n        Ys = []\n        pred_probas = []\n        orderbook = OrderBook()\n\n        for event in tqdm(self.event_player.iget_events(), \n                            total=len(self.event_player),\n                            desc=\"scoring\"):        \n            orderbook.apply_event(event)\n            pred_proba = process_event_func(event, orderbook)\n            self._check_return_value(event, pred_proba)\n\n            if not event.need_prediction:\n                continue\n\n            Ys.append(event.Y)\n            pred_probas.append(pred_proba)\n\n        roc_auc = roc_auc_score(Ys, pred_probas)\n        print(f\"\\nroc_auc_score = {roc_auc:.3f}\")\n        return roc_auc, (Ys, pred_probas)","65960773":"scoring = Scorer(\"..\/input\/orderbooks-events-binary-classification\/train_small_C.npz\")\nroc_auc, (true_ys, pred_probas) = scoring.score(process_event_and_predict_proba)","9a53c031":"## This is a submission example."}}