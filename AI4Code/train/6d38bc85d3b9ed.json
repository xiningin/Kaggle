{"cell_type":{"ec9f459f":"code","bda5f841":"code","4b01791d":"code","5b7f6665":"code","fc74a173":"code","c1675d11":"code","ae8178bc":"code","3a86c772":"code","a3bb48c0":"code","6a8de926":"code","4329f818":"markdown","f14e0715":"markdown","0ffe7934":"markdown","03d773d1":"markdown","cff32967":"markdown","f7a6c50a":"markdown","96260d39":"markdown","072dd320":"markdown","fd57a28d":"markdown","b3b60611":"markdown","d33be162":"markdown"},"source":{"ec9f459f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        os.path.join(dirname, filename)\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","bda5f841":"import os\nimport torch\nimport pandas as pd\nimport numpy as np\nfrom torch.utils.data import Dataset, random_split, DataLoader\nfrom PIL import Image\nimport torchvision.models as models\nimport matplotlib.pyplot as plt\nimport torchvision.transforms as transforms\nfrom sklearn.metrics import f1_score\nimport torch.nn.functional as F\nimport torch.nn as nn\nfrom torchvision.utils import make_grid\n%matplotlib inline","4b01791d":"DATA_DIR = '..\/input\/jovian-pytorch-z2g\/Human protein atlas'\n\nTRAIN_DIR = DATA_DIR + '\/train'                           # Contains training images\nTEST_DIR = DATA_DIR + '\/test'                             # Contains test images\n\nTRAIN_CSV = DATA_DIR + '\/train.csv'                       # Contains real labels for training images\nTEST_CSV = '..\/input\/jovian-pytorch-z2g\/submission.csv'   # Contains dummy labels for test image","5b7f6665":"import pandas as pd\ntrain_df = pd.read_csv(TRAIN_CSV)","fc74a173":"def encode_label(label):\n    target = torch.zeros(10)\n    for l in str(label).split(' '):\n        target[int(l)] = 1.\n    return target\n\ndef decode_target(target, text_labels=False, threshold=0.5):\n    result = []\n    for i, x in enumerate(target):\n        if (x >= threshold):\n            if text_labels:\n                result.append(labels[i] + \"(\" + str(i) + \")\")\n            else:\n                result.append(str(i))\n    return ' '.join(result)","c1675d11":"class HumanProteinDataset(Dataset):\n    def __init__(self, csv_file, root_dir, transform=None):\n        self.df = pd.read_csv(csv_file)\n        self.transform = transform\n        self.root_dir = root_dir\n        \n    def __len__(self):\n        return len(self.df)    \n    \n    def __getitem__(self, idx):\n        row = self.df.loc[idx]\n        img_id, img_label = row['Image'], row['Label']\n        img_fname = self.root_dir + \"\/\" + str(img_id) + \".png\"\n        img = Image.open(img_fname)\n        if self.transform:\n            img = self.transform(img)\n        return img, encode_label(img_label)","ae8178bc":"transform = transforms.Compose([transforms.ToTensor()])\ndataset = HumanProteinDataset(TRAIN_CSV, TRAIN_DIR, transform=transform)","3a86c772":"batch_size=28","a3bb48c0":"dataset_dl = DataLoader(dataset, batch_size, shuffle=True, num_workers=2, pin_memory=True)","6a8de926":"\nno_of_images = 0\nmean = 0.\nstd = 0.\nfor batch, _ in dataset_dl:\n    # Rearrange batch to be the shape of [batch_size, no_of_channels, width_of_image * height_of_image]\n    batch = batch.view(batch.size(0), batch.size(1), -1)\n    \n    # Update total number of images\n    no_of_images += batch.size(0)\n    \n    # Compute mean and std here\n    mean += batch.mean(2).sum(0) \n    std += batch.std(2).sum(0)\n\n\nmean \/= no_of_images\nstd \/= no_of_images\n\nprint(\"Total number of images :\", no_of_images,\" where Mean of images across channels: \", mean , \"and std of images across channels: \" , std)","4329f818":"# Now you have normalization parmeters that you can use for transforming\/normalizing datasets\/images .","f14e0715":"# Load dataset","0ffe7934":"# Creating dataloader","03d773d1":"**This notebook contains basic information about how to find mean and std of images across channels that is used in torchvision.transforms.Noramlize() to transform\/normalize images**\n<br><br><br>\nHope it will help many of us.\n","cff32967":"# Function for encoding and decoding target","f7a6c50a":"# Transforming dataset into pytorch tensors","96260d39":"References:\n<br>\nhttps:\/\/www.kaggle.com\/aakashns\/simple-cnn-starter","072dd320":"# Following is the code for getting mean and std of images across channels","fd57a28d":"To know more about Normalization : https:\/\/pytorch.org\/docs\/stable\/torchvision\/transforms.html#torchvision.transforms.Normalize<br>\n","b3b60611":"# Defining own dataset via implementing methods __init__ and __getitem__","d33be162":"# Define path for data available"}}