{"cell_type":{"fb565cb5":"code","b5a9f056":"code","55b123da":"code","929ed14b":"code","46c5e6d9":"code","916c4c2f":"code","6ec558a8":"code","e552b21c":"code","5fdb61f0":"code","30e1b6db":"code","69a05179":"code","fc8f34fa":"code","fe3fa07f":"code","6f31e6a1":"code","b266a9ce":"code","562ed432":"code","6ddd983f":"code","0e66558d":"code","72263386":"code","174ee484":"code","fd0fa393":"code","88c49a72":"code","8c9ea23b":"code","8f347a0f":"markdown","d5dc9267":"markdown","5f8908cb":"markdown","1d1244bc":"markdown","f8581e37":"markdown","bb57688e":"markdown","d7f5640b":"markdown","55975115":"markdown","ff5a3bc1":"markdown","cd5ee47b":"markdown","ad378356":"markdown","cb5eeefc":"markdown","6ccf8aba":"markdown","530fb84c":"markdown","c41ee5e1":"markdown","7db2d58c":"markdown","2d0e94ea":"markdown","1c0dc064":"markdown","9c394e32":"markdown","5757493d":"markdown","c15d872d":"markdown","098630c2":"markdown","0e57e773":"markdown","d8efeefb":"markdown","2f5ecb70":"markdown","8dfcd8db":"markdown","6360b9fb":"markdown","67660246":"markdown"},"source":{"fb565cb5":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.cluster import KMeans\nfrom numpy import unique, where\nimport warnings\nwarnings.filterwarnings(\"ignore\")","b5a9f056":"df = pd.read_csv('..\/input\/flipkart-headphones-dataset\/flipkart_headphones.csv')","55b123da":"display(df.head())\nprint('-'*100)\nprint('Dataframe Info')\ndisplay(df.info())\nprint('-'*100)\nprint('Dataframe Describe')\ndisplay(df.describe())\nprint('-'*100)\nprint('Null Data In Dataframe')\ndisplay(df.isnull().sum())","929ed14b":"# We will create new column for headphone brand\n# we assume that the brand name is first word in column title\ndf['title'] = df['title'].apply(lambda x: x.lower())\ndf['brand'] = df['title'].apply(lambda x: x.split(' ')[0])","46c5e6d9":"# Show percentage on countplot\/barplot\ndef barPerc_without_hue(ax, feature):\n    total = len(feature)\n    for p in ax.patches:\n        percentage = '{:.1f}%'.format(100 * p.get_width()\/total)\n        x = p.get_x() + p.get_width() \n        y = p.get_y() + p.get_height()\n        ax.annotate(percentage, (x, y), size = 12)\n\ndef barPerc_without_hue2(ax, feature):\n    total = len(feature)\n    for p in ax.patches:\n        percentage = p.get_width()\n        x = p.get_x() + p.get_width() \n        y = p.get_y() + p.get_height()\n        ax.annotate(percentage, (x, y), size = 12)","916c4c2f":"# We will create visualization top 10 for our categorical column\nfig, axs = plt.subplots(3, figsize=(10,10))\nax1 = sns.countplot(data=df, y='brand', order=df['brand'].value_counts().iloc[:10].index, ax=axs[0])\nbarPerc_without_hue(ax1, df['brand'])\naxs[0].set_title('Brand')\n\nax2 = sns.countplot(data=df, y='color', order=df['color'].value_counts().iloc[:10].index, ax=axs[1])\nbarPerc_without_hue(ax2, df['color'])\naxs[1].set_title('Color')\n\nax3 = sns.countplot(data=df, y='type', order=df['type'].value_counts().iloc[:10].index, ax=axs[2])\nbarPerc_without_hue(ax3, df['type'])\naxs[2].set_title('Type')\n\nplt.suptitle('TOP 10 Products Based On Data Count', size=15)\nplt.tight_layout()\nplt.show()","6ec558a8":"fig, axs = plt.subplots(3, figsize=(10,10))\ncomp = df.groupby('brand')['num_of_ratings'].sum().sort_values(ascending=False).head(10).reset_index(name='total')\nax1 = sns.barplot(data=comp, x='total', y='brand', ax=axs[0])\nbarPerc_without_hue2(ax1, df['brand'])\naxs[0].set_title('Brand')\n\ncolor = df.groupby('color')['num_of_ratings'].sum().sort_values(ascending=False).head(10).reset_index(name='total')\nax2 = sns.barplot(data=color, x='total', y='color', ax=axs[1])\nbarPerc_without_hue2(ax2, df['color'])\naxs[1].set_title('Color')\n\ntypes = df.groupby('type')['num_of_ratings'].sum().sort_values(ascending=False).head(10).reset_index(name='total')\nax3 = sns.barplot(data=types, x='total', y='type', ax=axs[2])\nbarPerc_without_hue2(ax3, df['type'])\naxs[2].set_title('Type')\n\nplt.suptitle('TOP 10 Most Selling Products', size=15)\nplt.tight_layout()\nplt.show()","e552b21c":"fig, axs = plt.subplots(3, figsize=(10,10))\ncomp = df.groupby('brand')['avg_rating'].mean().sort_values(ascending=False).head(10).reset_index(name='total')\nsns.barplot(data=comp, x='total', y='brand', ax=axs[0])\naxs[0].set_title('Brand')\n\ncolor = df.groupby('color')['avg_rating'].mean().sort_values(ascending=False).head(10).reset_index(name='total')\nsns.barplot(data=color, x='total', y='color', ax=axs[1])\naxs[1].set_title('Color')\n\ntypes = df.groupby('type')['avg_rating'].mean().sort_values(ascending=False).head(10).reset_index(name='total')\nsns.barplot(data=types, x='total', y='type', ax=axs[2])\naxs[2].set_title('Type')\n\nplt.suptitle('TOP 10 Products Based On Rating', size=15)\nplt.tight_layout()\nplt.show()","5fdb61f0":"X = df[['selling_price']]\nmodel = KMeans(n_clusters=3)\nmodel.fit(X)\nlabel = model.predict(X)\n\nlabel_0 = df[label==0]\nlabel_1 = df[label==1]\nlabel_2 = df[label==2]\n\ncols = label_0.columns\nplt.scatter(label_0[cols[5]], label_0[cols[6]], color = 'red')\nplt.scatter(label_1[cols[5]], label_1[cols[6]], color = 'blue')\nplt.scatter(label_2[cols[5]], label_2[cols[6]], color = 'yellow')\nplt.ylabel('MRP')\nplt.xlabel('Selling Price')\nplt.title('Plot Cluster For Selling_Price')\nplt.show()\n\ndf['price_level'] = label\ndf['price_level'] = df['price_level'].replace([0,1,2],['Low','Mid','High'])\ndf[['title','selling_price','price_level']].sample(5)","30e1b6db":"df['clean_profit'] = df['MRP'] - df['selling_price']\nX = df[['clean_profit']]\nmodel = KMeans(n_clusters=3)\nmodel.fit(X)\nlabelz = model.predict(X)\n\nlabel_0 = df[labelz==0]\nlabel_1 = df[labelz==1]\nlabel_2 = df[labelz==2]\n\ncols = label_0.columns\nplt.scatter(label_0[cols[9]], label_0[cols[6]], color = 'red')\nplt.scatter(label_1[cols[9]], label_1[cols[6]], color = 'blue')\nplt.scatter(label_2[cols[9]], label_2[cols[6]], color = 'yellow')\nplt.ylabel('MRP')\nplt.xlabel('Profit')\nplt.title('Plot Cluster For Profit')\nplt.show()\n\ndf['profit_level'] = labelz\ndf['profit_level'] = df['profit_level'].replace([1,0,2],['Low','Mid','High'])\n\n# We relize that in the clean_profit there are some minus data, so we give them 'Loss' label\n# And some data have value 0 in MRP, so we give them 'Unknown' label in profit_level\nlabel1 = []\nfor a,b,c in df[['MRP','clean_profit','profit_level']].values:\n    if a == 0:\n        label1.append('Unknown')\n    elif b < 0:\n        label1.append('Loss')\n    else:\n        label1.append(c)\n\ndf['profit_level'] = label1\ndf[['title','clean_profit','profit_level']].sample(5)","69a05179":"df[df['brand']=='crossbuzz']","fc8f34fa":"def real_rating(df, rating, voter, quan=0.80, agg=True):\n    if agg==True:\n        # Calculate mean of vote average column\n        C = df[rating].mean().sum()\n        \n        # Calculate the minimum number of votes required to be in the chart, m\n        m = df[voter].quantile(quan).sum()\n        \n        # Filter out all qualified animes into a new DataFrame\n        q = df.copy().loc[df[voter]['sum'] >= m]\n    else:\n        # Calculate mean of vote average column\n        C = df[rating].mean()\n\n        # Calculate the minimum number of votes required to be in the chart, m\n        m = df[voter].quantile(quan)\n        \n        # Filter out all qualified animes into a new DataFrame\n        q = df.copy().loc[df[voter] >= m]\n\n    # Function that computes the weighted rating of each movie\n    def weighted_rating(x, m=m, C=C):\n        if agg == True:\n            v = x[voter]['sum']\n            R = x[rating]['mean']\n        else:\n            v = x[voter]\n            R = x[rating]\n        # Calculation based on the IMDB formula\n        return round((v\/(v+m) * R) + (m\/(m+v) * C),2)\n    \n\n    # Define a new feature 'score' and calculate its value with `weighted_rating()`\n    q['score'] = q.apply(weighted_rating, axis=1)\n#     q = q.sort_values('score', ascending=False)[['brand','score']]\n    return q","fe3fa07f":"brand = df.groupby('brand').agg({\"num_of_ratings\": [np.sum], \"avg_rating\": [np.mean]}).reset_index()\nbrand = real_rating(brand, 'avg_rating', 'num_of_ratings')\nbrand = brand.sort_values('score',ascending=False)[['brand','score']].head(10)\nax = sns.barplot(data=brand, x='score', y='brand')\nbarPerc_without_hue2(ax, brand['score'])\nplt.title('TOP 10 Brand Based On New Rating')\nplt.show()","6f31e6a1":"hp = real_rating(df, 'avg_rating','num_of_ratings',0.50, False)\nhp_cp = hp.sort_values('score',ascending=False)[['title','score','price_level']]\nhp_cp['title'] = hp_cp['title'].apply(lambda x: x.lower())\nhp_cp = hp_cp.drop_duplicates('title')\n\nfig, axs = plt.subplots(3, figsize=(10,10))\nplt.suptitle('Best Headphone To Buy', size=15)\nsns.barplot(data=hp_cp[hp_cp['price_level']=='Low'].head(10), x='score', y='title', ax=axs[0])\naxs[0].set_title('Low Level Price')\n\nsns.barplot(data=hp_cp[hp_cp['price_level']=='Mid'].head(10), x='score', y='title', ax=axs[1])\naxs[1].set_title('Mid Level Price')\n\nsns.barplot(data=hp_cp[hp_cp['price_level']=='High'].head(10), x='score', y='title', ax=axs[2])\naxs[2].set_title('High Level Price')\nplt.tight_layout()\nplt.show()","b266a9ce":"# If you want high profit from one headphone\nhp[hp['profit_level']=='High'][['title','selling_price','price_level','MRP','clean_profit','profit_level','score']].sort_values('clean_profit', ascending=False).head(10)","562ed432":"hp[hp['num_of_ratings']>=600000][['title','num_of_ratings','selling_price','price_level','MRP','clean_profit','profit_level','score']].sort_values(['clean_profit'], ascending=False).head(10)","6ddd983f":"hp[hp['price_level']=='Low'][['title','num_of_ratings','selling_price','price_level','MRP','clean_profit','profit_level','score']].sort_values(['clean_profit'], ascending=False).head(10)","0e66558d":"df[df['profit_level']=='Loss'][['title','num_of_ratings','selling_price','price_level','MRP','clean_profit','profit_level']].sort_values(['clean_profit']).head(10)","72263386":"# Create new df for recomendation\ndf_re = real_rating(df, 'avg_rating','num_of_ratings',0, False)\n\n# Select column that will be attribute to recomendation, because we will use item based\nselected_col = ['title','color','type','price_level','profit_level']\ndf_rec = df_re.copy()\ndf_rec = df_rec[selected_col]","174ee484":"from sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics.pairwise import linear_kernel\n\n# Change all text to lower form\nfor col in selected_col:\n    df_rec[col] = df_rec[col].apply(lambda x: x.lower())\n    \n# Join all column\ndef create_soup(x):\n    return x['title'] + ' ' + x['color'] + ' ' + x['type']\ndf_rec['Soup'] = df_rec.apply(create_soup, axis=1)\n\n# Give value to data with CountVectorizer\ncount = CountVectorizer(stop_words='english')\ncount_matrix = count.fit_transform(df_rec['Soup'])\n\n# Create cosine similarity with linear kernel\ncosine_sim2 = linear_kernel(count_matrix,count_matrix)\n\n# Create indices for headphone name\ndf_test = df.drop_duplicates(subset='title')\nindices = df_test[['title']].reset_index(drop=True)","fd0fa393":"def get_recommendations(title, ind=indices ,cosine_sim=cosine_sim2):\n    idx = indices[ind['title']==title].index[0]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:11]\n    headphone_indices = [i[0] for i in sim_scores]\n    return df_rec['title'].iloc[headphone_indices]","88c49a72":"# We try to generate one headphone for recommendation\nhp_ex = df_rec['title'].sample(1).values[0]\nhp_ex","8c9ea23b":"get_recommendations(hp_ex)","8f347a0f":"## Clustering Price\n<a id=\"segment1\"><\/a>","d5dc9267":"# THANK YOU","5f8908cb":"### If you want high profit from one headphone","1d1244bc":"## Introduction\nThis dataset containing details of various headphones products in India scraped from an e-commerce website '[Flipkart.com](https:\/\/www.flipkart.com)'. This dataset has 1000 samples with 7 attributes.\n\nAttributes\n1. Title of the headphone product (title)\n2. Color of the headphone product (color)\n3. Type of the headphone product (type)\n4. Average rating of the product (avg_rating)\n5. Number of ratings available (num_of_ratings)\n6. Selling price of the headphone at the time of scraping (selling_price)\n7. Maximum Retail Price (MRP)","f8581e37":"In this section we will find the most worth it headphone of each price level, we find out in df, there are some duplicate headphone title, so we will drop the duplicate, we only need one because it only differs in color.","bb57688e":"# TOP 10 Products\n<a id=\"TOP10\"><\/a>","d7f5640b":"## List Of Best Headphone To Sell If You Want To Be Reseller\n<a id=\"worthit2\"><\/a>","55975115":"## Clustering Profit If We Sell The Product At its MRP\n<a id=\"segment2\"><\/a>","ff5a3bc1":"In this section we will do clustering for price, method that we use in K-Means, what is K-Means ?\n<br>\nK-means clustering is one of the simplest and popular unsupervised machine learning algorithms.\nTypically, unsupervised algorithms make inferences from datasets using only input vectors without referring to known, or labelled, outcomes.\nAndreyBu, who has more than 5 years of machine learning experience and currently teaches people his skills, says that \u201cthe objective of K-means is simple: group similar data points together and discover underlying patterns. To achieve this objective, K-means looks for a fixed number (k) of clusters in a dataset.\u201d\nA cluster refers to a collection of data points aggregated together because of certain similarities.\nYou\u2019ll define a target number k, which refers to the number of centroids you need in the dataset. A centroid is the imaginary or real location representing the center of the cluster.\nEvery data point is allocated to each of the clusters through reducing the in-cluster sum of squares.\nIn other words, the K-means algorithm identifies k number of centroids, and then allocates every data point to the nearest cluster, while keeping the centroids as small as possible.\nThe \u2018means\u2019 in the K-means refers to averaging of the data; that is, finding the centroid.\n<br><br>\nTo process the learning data, the K-means algorithm in data mining starts with a first group of randomly selected centroids, which are used as the beginning points for every cluster, and then performs iterative (repetitive) calculations to optimize the positions of the centroids\nIt halts creating and optimizing clusters when either:\n- The centroids have stabilized \u2014 there is no change in their values because the clustering has been successful.\n- The defined number of iterations has been achieved.","cd5ee47b":"## The Best Headphone to Buy Based On Real Rating For Every Price Level\n<a id=\"worthit1\"><\/a>","ad378356":"Source : [Understanding K-means Clustering in Machine Learning](https:\/\/towardsdatascience.com\/understanding-k-means-clustering-in-machine-learning-6a6e67336aa1)","cb5eeefc":"### If you short of money but you still want to get high profit at once","6ccf8aba":"## TOP 10 Most Selling Products\n<a id=\"TOP10B\"><\/a>","530fb84c":"See, its not fair if we compare with brand who has rating around 4, but with many num_of_ratings. If we want to buy headphone we will definitely buy headphone with many buyers even though the rating is not 5. Because of that we will find the real rating with this metric\n![](https:\/\/images.tutorialedge.net\/images\/python\/recommender-system-python\/image2-19.png)\n\n","c41ee5e1":"# The Most Worth it Headphone To Buy\n<a id=\"worthit\"><\/a>","7db2d58c":"# Get Real Rating\n<a id='real_rating'><\/a>","2d0e94ea":"# Create Cluster For Price\n<a id=\"segment\"><\/a>","1c0dc064":"## TOP 10 Products Based On Data Count\n<a id=\"TOP10A\"><\/a>","9c394e32":"And finally we will see the truth, lets visualize it","5757493d":"### If you are too rich to be a reseller","c15d872d":"# Import Library\n<a id=\"import_lib\"><\/a>","098630c2":"# Recomendation Headphone\n<a id=\"rec\"><\/a>","0e57e773":"<h1 align=\"center\"> Flipkart Headphones Analysis <\/h1>\n\n<div align=\"center\">\n<img src=\"https:\/\/img.shields.io\/badge\/Upvote-If%20you%20like%20my%20work-07b3c8?style=for-the-badge&logo=kaggle\" alt=\"upvote\">\n<\/div>","d8efeefb":"# Read Data\n<a id=\"read_data\"><\/a>","2f5ecb70":"Whaaaat ??? Real Rating ??? Yes real rating you didn't read it wrong, We do this because we find out in the section 'TOP 10 Products Based On Rating' there is an oddity, the number one brand is CrossBuzz, if we look at the df, CrossBuzz only have one product with 0 num_of_rating but its have 5 avg_rating","8dfcd8db":"## Our Goals:\n- Find TOP 10 Products From Each Atribute (Price, Rating, etc)\n- Create cluster for headphone price\n- Find the most worth it headphone to buy\n- Create headphone recommendation\n\n## Outline:\n<b style=\"font-size:15px\">I  . Import Library<\/b><br><br>\n\n<b style=\"font-size:15px\">II . Read Data<\/b><br><br>\n\n<b style=\"font-size:15px\">III. TOP 10 Products<\/b><br>\na) [TOP 10 Products Based on Data Counts](#TOP10A)<br>\nb) [TOP 10 Most Selling Products](#TOP10B)<br>\nc) [TOP 10 Products Based on Rating](#TOP10C)<br><br>\n\n<b style=\"font-size:15px\">IV. Clustering Price<\/b><br>\na) [Clustering Price](#segment1)<br>\nb) [Clustering Profit](#segment2)<br><br>\n\n<b style=\"font-size:15px\">V. Get Real Rating<\/b><br><br>\n\n<b style=\"font-size:15px\">VI. The Most Worth it Headphone To Buy<\/b><br><br>\na) [Best Headphone To Buy For Each Price Level](#worthit1)<br>\nb) [List Of Headphone To Sell If You Wanna Be Reseller](#worthit2)<br><br>\n\n<b style=\"font-size:15px\">VII. Recommendation Headphone<\/b><br><br>","6360b9fb":"## TOP 10 Products Based On Rating\n<a id=\"TOP10C\"><\/a>","67660246":"### If you want get profit from popular headphone"}}