{"cell_type":{"3f7b2125":"code","1529ab67":"code","c5859d55":"code","a4949a07":"code","39ee0bee":"code","bdb22403":"code","d83dab31":"code","aa820713":"code","b2260fe4":"code","a3d59cdf":"code","ea93e189":"code","0b05c0d6":"code","553bf275":"code","56d5d844":"code","19cc6ea8":"code","0dfba4eb":"code","1d63e7c7":"code","5d136559":"code","e08750d7":"code","ebae8cd1":"code","2dae99fa":"code","b017820b":"code","7ce9c480":"code","f3aa3c07":"code","0d70ea9e":"code","6534c719":"code","d5d4251e":"markdown","68ef5148":"markdown","c8e010ac":"markdown","39cd1d11":"markdown","9723a3ce":"markdown","d96d3bea":"markdown","1f541b23":"markdown","8aec3286":"markdown","bc3b194a":"markdown","66cc7ae5":"markdown","a0781118":"markdown","8cbc7cf4":"markdown","c2dfd784":"markdown","b644a341":"markdown","8067bc68":"markdown","f932ccfd":"markdown","b8d79230":"markdown","3cabeb8e":"markdown","c9d77e2c":"markdown","32e49a6a":"markdown","a9c4d201":"markdown","2b4179db":"markdown","c3488de5":"markdown","eae904f6":"markdown","5a6c5a0d":"markdown","e8504e69":"markdown","c002cdce":"markdown","46198ff0":"markdown","be527448":"markdown"},"source":{"3f7b2125":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport math\nfrom sklearn.metrics import pairwise_distances\nimport matplotlib.patheffects as PathEffects\nfrom sklearn.manifold import TSNE\nimport random\nimport seaborn as sns\nsns.set_style('darkgrid')\nsns.set_palette('muted')\nsns.set_context(\"notebook\", font_scale=1.5,\n                rc={\"lines.linewidth\": 2.5})","1529ab67":"survey = pd.read_csv('\/kaggle\/input\/kaggle-survey-2020\/kaggle_survey_2020_responses.csv')","c5859d55":"survey.head()","a4949a07":"Questions=dict()\nfor q in survey.columns.tolist():\n    Questions[q]=survey.loc[0,q]","39ee0bee":"survey.drop('Time from Start to Finish (seconds)',axis=1,inplace=True)\nsurvey.drop(0,axis=0,inplace=True)","bdb22403":"def label_generator(col):\n    \n    size_dict={}\n    \n    label_list=list(survey[col].unique())\n    \n    for label in label_list:\n        size_dict[label]=len(survey[survey[col]==label])\n        \n    max_value=max(list(size_dict.values()))\n    for label in label_list:\n        size_dict[label]=np.around(size_dict[label]*20\/max_value+7,2)\n        \n    sorted_dict={}\n    for w in sorted(size_dict, key=size_dict.get, reverse=True):\n        sorted_dict[w]=size_dict[w]\n        \n    return sorted_dict\n","d83dab31":"label_dict={}\ncolumns=survey.columns.tolist()\nfor col in columns:\n    label_dict[col]=label_generator(col)","aa820713":"label_dict['Q2']","b2260fe4":"columns=survey.columns.tolist()\nfor col in columns:\n    survey[col]=survey[col].astype('category')\n    survey[col]=survey[col].cat.codes","a3d59cdf":"survey.head()","ea93e189":"print('Computing Cosine Matrix \\n')\nMatrix=survey.values\ndistance_matrix = pairwise_distances(Matrix, Matrix, metric='cosine', n_jobs=-1)","0b05c0d6":"print('TSNE \\n')\nstate=77\ntsne=TSNE(n_components=2,metric=\"precomputed\",random_state=state,verbose=1,perplexity=40,n_iter=300)\ntsne_results=tsne.fit_transform(distance_matrix)\nsurvey['X']=tsne_results[:,0]\nsurvey['Y']=tsne_results[:,1]\nprint('t-SNE done!')","553bf275":"f = plt.figure(figsize=(12, 12))\nax = plt.subplot(aspect='equal')\n\nsc = ax.scatter(survey['X'],survey['Y'], lw=0, s=20,c='red')\nax.axis('off')\nax.axis('tight')\n\nplt.show()","56d5d844":"new_label_dict={}\ncolumns=survey.columns.tolist()\nfor col in columns:\n    new_label_dict[col]=label_generator(col)","19cc6ea8":"def image_generator(col):\n    \n    encoder={}\n    for i,label in enumerate(label_dict[col].keys()):\n        encoder[label]=list(new_label_dict[col].keys())[i]\n    \n    f = plt.figure(figsize=(12, 12))\n    ax = plt.subplot(aspect='equal')\n    \n    palette = np.array(sns.color_palette(\"hls\", len(label_dict[col])))\n    \n    txts = []\n    pixels=[]\n    \n    Labels=list(label_dict[col].keys())[::-1][-5:]\n    \n    for item in Labels:\n        _survey=survey[survey[col]==encoder[item]]\n        pixels.append(ax.scatter(_survey['X'],_survey['Y'], lw=0, s=20,c=palette[encoder[item].astype(np.int)]))\n        if len(pixels)>4:\n            break\n            \n    txts = []\n    \n    for item in Labels:\n        # Position of each label.\n        xtext, ytext = np.median(survey[survey[col]==encoder[item]][['X','Y']],axis=0)\n        if not math.isnan(xtext) and not math.isnan(ytext):\n            txt = ax.text(xtext, ytext, item, weight='bold',fontsize=label_dict[col][item])\n            txt.set_path_effects([\n                PathEffects.Stroke(linewidth=5, foreground=\"w\"),\n            PathEffects.Normal()])\n        txts.append(txt)\n    \n    plt.legend(pixels,Labels,bbox_to_anchor=(0.9, 1), loc='upper left', shadow=True)\n    \n    ax.axis('off')\n    ax.axis('tight')\n    plt.title(Questions[col])\n    plt.show()","0dfba4eb":"image_generator('Q1')","1d63e7c7":"image_generator('Q2')","5d136559":"image_generator('Q3')","e08750d7":"image_generator('Q4')","ebae8cd1":"image_generator('Q5')","2dae99fa":"image_generator('Q6')","b017820b":"image_generator('Q7_Part_1')","7ce9c480":"image_generator('Q7_Part_3')","f3aa3c07":"image_generator('Q8')","0d70ea9e":"image_generator('Q11')","6534c719":"image_generator('Q13')","d5d4251e":"Men outnumber women by a huge margin. The red dots overwhelm the violet dots!","68ef5148":"We will collect all the questions into a dictionary, with the column as the key and the question as the value. \n\nQuestions={column_name:survey_question}","c8e010ac":"Let's take a look at the dataframe again:","39cd1d11":"> The next step is to collect the unique values in each column and rank them according to their istances. For example, in column 2, the labels are 'Man', 'Woman','Nonbinary' etc. The number of rows with each of these values is counted and stored in a dictionary. For the purpose of visualization we will also convert them into a value between 27 and 7 - which will serve as the fontsize for this label in our cluster plot ","9723a3ce":"The age group 25-29 is seen to the most common among the respondees, followed by the 22-24 age group (from the fontsize of the labels). ","d96d3bea":"# Load the data","1f541b23":"The calculated x and y value are stored as columns 'X' and 'Y' in the survey dataframe. This will make our book keeping a lot easier.\n\nHere is what the plot looks like:","8aec3286":"Similarly, each column can be converted into an image - which provides instant insight into the dataframe. I encourage you to try this out for yourself.","bc3b194a":"#  **Vectorization**\n\nNow we can convert the rows into categorical codes","66cc7ae5":"Thus, each row of the original survey result has been converted to a vector.","a0781118":"Python is extensively used - as easily seen in the image","8cbc7cf4":"A TPU has rarely been used by our community!","c2dfd784":"Here is an example cluster image - this is for question 3 (country of origin). The image clusters neatly according to the country of origin. The steps towards the creation of this image are explained below. \n\n![country_results.png](attachment:country_results.png)","b644a341":"# **Data Display and Analysis**","8067bc68":"What we look for is if the plot has enough heterogenity to capture the entropy in our data. This one seems good enough. We will see further confirmation when we color each pixel according to it's column value.","f932ccfd":"So is SQL","b8d79230":"# Install Dependencies","3cabeb8e":"This neat image shows the responses separating based on the country. The green India and the purple United States take the top two positions. One reason why the separation of clusters is so evident in this image could be that this column has the highest entropy (number of responses) - consequently, the clustering approach is incentivized to allot higher weight to this column over others","c9d77e2c":"# **Clustering**\n\nWe calculate first the pairwise distance matrix using the cosine distance. ","32e49a6a":"Finally, we are ready to create images corresponding to each column. \n\nThe procedure is as follows:\n\n1. Select a column.\n2. Create a dictionary between the old and new column values (original values and their categorical   codes).\n2. Plot each category separately in a different color.\n3. Find the median position of the pixels corresponding to each category and affix the textual label at this position. \n4. The size of the label is proportional to the number of instances of that category. The larger label therefore is more common than a smaller label.\n5. Plot the legend.\n6. The title of the plot is the question corresponding to that particular column.\n\nFor the sake of clarity only the top 5 categories from each question (column) are displayed. \n\nAll of this is encoded into the function below - which helps us reuse our code easily.","a9c4d201":"Let's take a look at what we are working with:","2b4179db":"We can now get rid of the first column and the first row. They are not useful for the clustering approach","c3488de5":"If you like this approach, please consider upvoting this notebook. \nLeave a comment and let me know what you think!","eae904f6":"Before we can do that however, we would need to create a mapping between the labels in original survey frame and it's code. This will help in annotating our cluster images and in creating legends.","5a6c5a0d":"**Thank you for reading!**","e8504e69":"# **Survey Analysis - Results**","c002cdce":"The font sizes for the labels in column 2 are:","46198ff0":"# **Kaggle 2020 Suvery Analysis Using Clustering**\n\nIn this notebook, we will explore how a clustering approach can be used to analyze the results of the Kaggle 2020 Survey. The main highlights of the method are:\n\n1. It is fully automated - requiring no manual manipulation of the data\n2. The results are very visual - providing immediate insights into the data\n\nThe method is as follows:\n\n1. Convert all the unique values in each column into numeric categorical values.\n    This converts the dataframe into a numpy matrix.\n2. Compute the cosine matrix of the dataframe. \n    Each row of the matrix (corresponding to each user) is now a vector. The cosine distance between      rows is a measure of how similar two users are.   \n3. Cluster the rows using T distributed Stochastic Nearest Neighbor Embedding (TSNE). \n   This maps the clustered dataframe into two dimensions.\n4. Color each row corresponding to the value of the column.\n\n   This allows us to see how the responses to a question are distributed within the cluster map","be527448":"TSNE calculates the appropriate x and y position for each vectorized row such that similar rows (users with similar responses) cluster together. The overall shape of the plot can be changed by altering the random state. The value used here was found to be more aesthetically pleasing. This can take a little bit of time to run."}}