{"cell_type":{"6d55d096":"code","47bce78f":"code","02cd435a":"code","e3ba2ade":"code","4fb8df4a":"code","c92d8ada":"code","270e8ede":"code","a04a80ee":"code","ff6fa047":"code","b475b7d0":"code","e9fb4c09":"code","ff48b223":"code","b7a988e9":"code","37b6045f":"code","6fc711af":"code","01dd6a23":"code","59f88358":"code","dd78218f":"code","189e8d7b":"code","17115a6a":"code","66b0a1de":"code","aab632c5":"code","9fdf054e":"markdown","c505fb6c":"markdown","760f6504":"markdown","e2d12977":"markdown","3f62b352":"markdown","916916f1":"markdown","d535a774":"markdown","2f12caae":"markdown","4414ce05":"markdown","95dccbfa":"markdown","a4911f2b":"markdown","3622b58c":"markdown","17fb0a93":"markdown"},"source":{"6d55d096":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats.mstats import gmean\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n# Any results you write to the current directory are saved as output.","47bce78f":"price_df = pd.read_csv('..\/input\/nyse\/prices.csv')\nsec_df = pd.read_csv('..\/input\/nyse\/securities.csv')\nfund_df = pd.read_csv('..\/input\/nyse\/fundamentals.csv')","02cd435a":"plt.figure(figsize=(15, 6))\nax = sns.countplot(y='GICS Sector', data=sec_df)\nplt.xticks(rotation=45)","e3ba2ade":"price_df.head()","4fb8df4a":"price_df.isna().sum()","c92d8ada":"sec_df = sec_df.rename(columns = {'Ticker symbol' : 'symbol','GICS Sector' : 'sector'})\nsec_df.head()","270e8ede":"price_df  = price_df.merge(sec_df[['symbol','sector']], on = 'symbol')\nprice_df['date'] = pd.to_datetime(price_df['date'])\nprice_df.head()","a04a80ee":"price_df = price_df[price_df['date'] >= '2016-01-01']","ff6fa047":"sector_pivot = pd.pivot_table(price_df, values = 'close', index = ['date'],columns = ['sector']).reset_index()\nsector_pivot","b475b7d0":"plt.figure(figsize = (10,10))\nsns.heatmap(sector_pivot.corr(),annot=True, cmap=\"coolwarm\")","e9fb4c09":"price_df['return'] = np.log(price_df.close \/ price_df.close.shift(1)) + 1\nprice_df['good'] = price_df['symbol'] == price_df['symbol'].shift(1)\nprice_df = price_df.drop(price_df[price_df['good'] == False].index)\nprice_df.dropna(inplace = True)","ff48b223":"risk_free = 0.032\nsector_df = pd.DataFrame({'return' : (price_df.groupby('sector')['return'].mean() - 1) * 252, 'stdev' : price_df.groupby('sector')['return'].std()})\nsector_df['sharpe'] = (sector_df['return'] - risk_free) \/ sector_df['stdev']\nplt.figure(figsize = (12,8))\nax = sns.barplot(x= sector_df['sharpe'], y = sector_df.index)","b7a988e9":"port_list = sector_df[sector_df['sharpe'] >= 1].index\nport_list","37b6045f":"price_df.head()","6fc711af":"port_stock = []\nreturn_stock = []\ndef get_stock(sector):\n    list_stocks = price_df[price_df['sector'] == sector]['symbol'].unique()\n    performance = price_df.groupby('symbol')['return'].apply(lambda x : (gmean(x) - 1) * 252).sort_values(ascending = False)\n    \n    for i in range(len(performance)):\n        if performance.index[i] in list_stocks:\n            port_stock.append(performance.index[i])\n            return_stock.append(performance[i])\n            break\n    \nfor sector in port_list:\n    get_stock(sector)\n\nreturn_stock","01dd6a23":"port_df = price_df[price_df['symbol'].isin(port_stock)].pivot('date','symbol','return')\n","59f88358":"return_pred = []\nweight_pred = []\nstd_pred = []\nfor i in range(1000):\n    random_matrix = np.array(np.random.dirichlet(np.ones(len(port_stock)),size=1)[0])\n    port_std = np.sqrt(np.dot(random_matrix.T, np.dot(port_df.cov(),random_matrix))) * np.sqrt(252)\n    port_return = np.dot(return_stock, random_matrix)\n    return_pred.append(port_return)\n    std_pred.append(port_std)\n    weight_pred.append(random_matrix)","dd78218f":"pred_output = pd.DataFrame({'weight' : weight_pred , 'return' : return_pred, 'stdev' :std_pred })\npred_output['sharpe'] = (pred_output['return'] - risk_free) \/ pred_output['stdev']\npred_output.head()","189e8d7b":"max_pos = pred_output.iloc[pred_output.sharpe.idxmax(),:]\nsafe_pos = pred_output.iloc[pred_output.stdev.idxmin(),:]","17115a6a":"plt.subplots(figsize=(15,10))\n#ax = sns.scatterplot(x=\"Stdev\", y=\"Return\", data=pred_output, hue = 'Sharpe', size = 'Sharpe', sizes=(20, 200))\n\nplt.scatter(pred_output.stdev,pred_output['return'],c=pred_output.sharpe,cmap='OrRd')\nplt.colorbar()\nplt.xlabel('Volatility')\nplt.ylabel('Return')\n\nplt.scatter(max_pos.stdev,max_pos['return'],marker='^',color='r',s=500)\nplt.scatter(safe_pos.stdev,safe_pos['return'],marker='<',color='g',s=500)\n#ax.plot()","66b0a1de":"print(\"The highest sharpe porfolio is {} sharpe, at {} volitality\".format(max_pos.sharpe.round(3),max_pos.stdev.round(3)))\n\nfor i in range(len(port_stock)):\n    print(\"{} : {}%\".format(port_stock[i],(max_pos.weight[i] * 100).round(3)))","aab632c5":"print(\"The safest porfolio is {} risk, {} sharpe\".format(safe_pos.stdev.round(3), safe_pos.sharpe.round(3)))\nfor i in range(len(port_stock)):\n    print(\"{} : {}%\".format(port_stock[i],(safe_pos.weight[i] * 100).round(3)))","9fdf054e":"Hello guys. Today I just finished my kernel on the visualization of modern portfolio theory. My kernel will briefly discuss and visualize the modern portfolio theory, in which a large number of brokers and portfolio managers are adapting. If you feel my kernel is helpful, please give me an upvote for further motivation.","c505fb6c":"Sharpe ratio is often used to describe how good our portfolio is. The higher the sharpe ratio, the better the portfolio. A sharpe ratio more than 1 is acceptable to investors. As a matter of fact, we will only choose the sectors that have sharpe ratio more than 1.","760f6504":"First of all, let's import our dataset and other useful libs","e2d12977":"**1. Correlation Matrix**","3f62b352":"For simplicity and relevant datas, we will only analyze the stock prices from the year of 2016 and above","916916f1":"**2. Portfolio selection by sector**","d535a774":"Each portfolio will have different stock weights, or the allocation of your investment into each stock.\n![](https:\/\/i.stack.imgur.com\/IrPam.png)\n\nThe portfolio variance can be calculated by the formula above. In another word, to calculate the variance, we take the covariance matrix multiply with the weighted matrix and the tranposed of the weighted matrix\n![](https:\/\/i.stack.imgur.com\/o6aIy.png)","2f12caae":"After running 2000 simulations, we finally plot the results, as well as the options for the portfolio, either the best performing or the safest one for risk adverse. ","4414ce05":"After having the list of sectors, we will choose from each sectors the most outstanding return stock. In real life you should choose many. However, in this example, I will pick only one for simple illustration.","95dccbfa":"We have plotted the correlation matrix of our Sectors. The higher the correlation, the more likely that the stocks are moving in the same direction. To put it simply, if two stocks are highly correlated, they are likely to increase or decrease in price together. \n\nWhen building a diversified portfolio, investors seek negatively correlated stocks. Doing so reduces the risk of catastrophic losses in the portfolio and helps the investor sleep better at night. Assume the portfolio consists of two stocks and they are negatively correlated. This implies that when the price of one performs worse than usual, the other will likely do better than usual. However, risk takers would love to seek for positively correlated stocks for higher expected return, and of course, higher risk.","a4911f2b":"We have the securities dataset and the stock prices dataset. What we want to do next is to fill in the stock prices dataset the sector of each stocks. In order to do this, we are gonnna use the pd.merge function:","3622b58c":"**3. Porfolio risk and return calculation**","17fb0a93":"Thank you for your attention. I hope you have a glance through the modern portfolio theory after seeing my kernel. Please give me an upvote for further motivation for finance - related projects. Thanks a lot!"}}