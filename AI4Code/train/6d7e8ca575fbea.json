{"cell_type":{"4c95dca8":"code","ce5914a0":"code","33a21d74":"code","da66a84a":"code","6742611d":"code","04f40682":"code","e3bd9ce4":"code","c12b77c3":"code","f10d82a1":"code","05896999":"code","73a6f331":"code","ec2f06ee":"code","bb6f0e71":"code","bba0759a":"markdown","e429e4ce":"markdown","6ba577de":"markdown","63de0125":"markdown"},"source":{"4c95dca8":"# Install fastai\n!pip uninstall fastai -y\n!pip install \/kaggle\/input\/fast-v2-offline\/dataclasses-0.6-py3-none-any.whl\n!pip install \/kaggle\/input\/fast-v2-offline\/torch-1.6.0-cp37-cp37m-manylinux1_x86_64.whl\n!pip install \/kaggle\/input\/fast-v2-offline\/torchvision-0.7.0-cp37-cp37m-manylinux1_x86_64.whl\n!pip install \/kaggle\/input\/fast-v2-offline\/fastcore-1.0.1-py3-none-any.whl\n!pip install \/kaggle\/input\/fast-v2-offline\/fastai-2.0.8-py3-none-any.whl","ce5914a0":"LAYERS = [1024, 512, 256]\nFOLDS = 30\nLABEL_SMOOTH_FACTOR = 0.001","33a21d74":"import sys\nsys.path.append('..\/input\/iterative-stratification\/iterative-stratification-master')\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom iterstrat.ml_stratifiers import MultilabelStratifiedKFold\nimport torch\nimport torch.nn as nn\nfrom fastai.tabular.all import *\nfrom torch.utils.data import Dataset, DataLoader\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import preprocessing\nimport os\nimport math ","da66a84a":"test_features = pd.read_csv('..\/input\/lish-moa\/test_features.csv')\ntrain_features = pd.read_csv('..\/input\/lish-moa\/train_features.csv')\ntrain_targets_scored = pd.read_csv('..\/input\/lish-moa\/train_targets_scored.csv')\ntrain_targets_nonscored = pd.read_csv('..\/input\/lish-moa\/train_targets_nonscored.csv')\nsubmission = pd.read_csv('..\/input\/lish-moa\/sample_submission.csv')","6742611d":"# Get rid of useless samples\ntrain_features = train_features[train_features[\"cp_type\"]!=\"ctl_vehicle\"]","04f40682":"# Getrid of useless columns\ntrain_features = train_features.drop([\"cp_type\"], axis=1)\ntest_features_new = test_features.drop([\"cp_type\"], axis=1)","e3bd9ce4":"y_names = [y for y in train_targets_scored.columns if y != \"sig_id\"]\ncat_names = ['cp_dose']\ncont_names = [c for c in train_features.columns if c not in cat_names and c != \"sig_id\"]","c12b77c3":"training_data = train_features.merge(train_targets_scored, how=\"inner\", on=\"sig_id\")","f10d82a1":"# Startified KFold based on targets\nmskf = MultilabelStratifiedKFold(n_splits=FOLDS, shuffle=True, random_state=1982) \nfor fold_, (trn_,val_) in enumerate(mskf.split(X=training_data, y=training_data.iloc[:, 875:])): \n    training_data.loc[val_, \"kfold\"] = fold_","05896999":" def training(fold):\n    fold_data = training_data[training_data[\"kfold\"] != fold]\n    splits = RandomSplitter(valid_pct=0.2)(range_of(fold_data))\n    fold_data = fold_data.drop(\"kfold\", axis=1)\n    \n    # Label smoothing. replace zero from 0.1 and 1 from 0.9\n#     fold_data.iloc[:,-206:] = fold_data.iloc[:,-206:] * (1 - LABEL_SMOOTH_FACTOR) + 0.5 * LABEL_SMOOTH_FACTOR\n    fold_data.iloc[:,-206:] = fold_data.iloc[:,-206:].clip(0.001, 0.999)\n    \n    \n    tabularPandas = TabularPandas(fold_data, y_names=y_names,\n                                     cat_names = cat_names,\n                                     cont_names = cont_names,\n        procs = [Categorify, FillMissing, Normalize],\n                                 splits = splits )\n    dataLoader = tabularPandas.dataloaders(bs=128)\n    learn = tabular_learner(dataLoader, layers=LAYERS, y_range=(0,1), ps=[0.3, 0.3, 0.3], loss_fn=nn.BCELoss(), opt_func=Adam, act_cls=nn.ReLU(), wd=1e-1)\n    learn.fit_one_cycle(20)\n    \n    # Testing on fold's holdout set - find CV metric\n    # Get holdout set\n    fold_holdout_data = training_data[training_data[\"kfold\"] == fold].drop([\"kfold\"], axis=1)\n    holdout_dl = learn.dls.test_dl(fold_holdout_data)\n    smooth_holdout_prediction = learn.get_preds(dl=holdout_dl)\n    holdout_prediction = torch.where(smooth_holdout_prediction[0]<0.5, smooth_holdout_prediction[0]-0.001, smooth_holdout_prediction[0]+0.001)\n    holdout_prediction = torch.clamp(holdout_prediction, 0.0, 1.0)\n#     import pdb; pdb.set_trace()\n    metric = nn.BCELoss()\n    loss = metric(holdout_prediction.double(), torch.tensor(fold_holdout_data.iloc[:, 875:].values, dtype=torch.float64))\n    print (f\"Fold:{fold} - Holdout set metric - {loss}\")\n    \n    # Prediction on test data\n    test_dl = learn.dls.test_dl(test_features_new)\n    prediction = learn.get_preds(dl=test_dl)\n    return prediction[0]","73a6f331":"predictions = torch.zeros([submission.shape[0], 206], dtype=torch.float64)\nfor i in range(FOLDS):\n    preds = training(i)\/FOLDS\n    predictions += preds\n    \nsubmission.iloc[:, 1:] = predictions","ec2f06ee":"# https:\/\/www.kaggle.com\/c\/lish-moa\/discussion\/180165 \nvehicle_indices = test_features[test_features[\"cp_type\"]==\"ctl_vehicle\"].index.tolist()\nsubmission.iloc[vehicle_indices, 1:] = np.zeros((1, 206))","bb6f0e71":"submission.to_csv('submission.csv', index=False)","bba0759a":"### Post Processing","e429e4ce":"### Train","6ba577de":"### Stratified KFold","63de0125":"### Hyper Parameters"}}