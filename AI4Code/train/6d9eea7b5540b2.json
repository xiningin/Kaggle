{"cell_type":{"4b307117":"code","6e2a3f69":"code","c65f2a23":"code","6199a15a":"code","0a0a1bba":"code","d51f9ac2":"code","438907a7":"code","a7f85a9b":"code","6cce9b52":"code","d0be3034":"code","905d9b99":"code","ba383bb3":"code","df76d75e":"code","4af34961":"code","95175e0d":"code","f40a79fe":"code","706bb996":"code","a3f0220c":"code","8438fc12":"code","43417537":"code","bb528158":"code","8b573bb9":"code","d4b66c8c":"code","33f5a767":"code","0cda1397":"code","75db1f3d":"code","7476a80d":"code","f7770358":"code","7f68d555":"code","34147f20":"code","fefd41f6":"code","dbeac1ea":"code","f7d426b7":"code","6f8445fa":"code","ca68889a":"code","1e18c467":"code","093b2b28":"markdown","bc1b4340":"markdown","335d28f4":"markdown","d02cf72c":"markdown","ba400cd4":"markdown","cfd14298":"markdown","f4b6a9db":"markdown","11b8a414":"markdown","bae11910":"markdown","b980b33a":"markdown","22ec16e5":"markdown","e0bbc69b":"markdown","9ea390fc":"markdown","8d0f3cdd":"markdown","129485a7":"markdown","8de5fbe3":"markdown","745e1911":"markdown","7530ed89":"markdown","949ee571":"markdown","763a83ff":"markdown","8a6a0d77":"markdown","320e24f5":"markdown"},"source":{"4b307117":"import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport plotly.express as px","6e2a3f69":"mush = pd.read_csv(\"..\/input\/mushroom-classification\/mushrooms.csv\")\nmush","c65f2a23":"mush.head(10)","6199a15a":"mush.tail()","0a0a1bba":"mush.info()","d51f9ac2":"mush[\"class\"].unique()","438907a7":"mush.dtypes","a7f85a9b":"mush.shape","6cce9b52":"mush.isnull().sum()","d0be3034":"mush.isna().sum()","905d9b99":"#shows description of the text data\nmush.describe()","ba383bb3":"from sklearn.preprocessing import LabelEncoder\nmush_encoded = mush.copy()\nle = LabelEncoder()\nfor col in mush_encoded.columns:\n  mush_encoded[col] = le.fit_transform(mush_encoded[col])\n\nmush_encoded.head(15)","df76d75e":"mush_encoded.max()","4af34961":"mush_encoded.describe()","95175e0d":"#shows the name of all the columns\nmush_encoded.columns","f40a79fe":"import matplotlib.pylab as pylab\nparams = {'legend.fontsize': 'x-large',\n         'axes.labelsize': 'x-large',\n         'axes.titlesize':'x-large',\n         'xtick.labelsize':'x-large',\n         'ytick.labelsize':'x-large'}\npylab.rcParams.update(params)","706bb996":"def plot_col(col, hue=None, color=['blue', 'purple'], labels=None):\n    fig, ax = plt.subplots(figsize=(15, 7))\n    sns.countplot(col, hue=hue, palette=color, saturation=0.6, data=mush_encoded, dodge=True, ax=ax)\n    ax.set(title = f\"Mushroom {col.title()} Quantity\", xlabel=f\"{col.title()}\", ylabel=\"Quantity\")\n    if labels!=None:\n        ax.set_xticklabels(labels)\n    if hue!=None:\n        ax.legend(('Poisonous', 'Edible'), loc=0)","a3f0220c":"class_dict = ('Poisonous', 'Edible')\nplot_col(col='class', labels=class_dict)","8438fc12":"#Visualizing the number of mushrooms for each of the available cap sizes\nshape_dict = {\"bell\":\"b\",\"conical\":\"c\",\"convex\":\"x\",\"flat\":\"f\", \"knobbed\":\"k\",\"sunken\":\"s\"}\nlabels = ('convex', 'bell', 'sunken', 'flat', 'knobbed', 'conical')\nplot_col(col='cap-shape', hue='class', labels=labels)","43417537":"#Visualizing the number of mushrooms for each cap color\ncolor_dict = {\"purple\":\"n\",\"yellow\":\"y\", \"blue\":\"w\", \"violet\":\"g\", \"red\":\"e\",\"pink\":\"p\",\n              \"orange\":\"b\", \"purple\":\"u\", \"black\":\"c\", \"green\":\"r\"}\nplot_col(col='cap-color', color=color_dict.keys(), labels=color_dict)","bb528158":"#Visualizing the Mushroom Cap Surface Quantity\nsurface_dict = {\"smooth\":\"s\", \"scaly\":\"y\", \"fibrous\":\"f\",\"grooves\":\"g\"}\nplot_col(col='cap-surface', hue='class', labels=surface_dict)","8b573bb9":"def get_labels(order, a_dict):    \n    labels = []\n    for values in order:\n        for key, value in a_dict.items():\n            if values == value:\n                labels.append(key)\n    return labels","d4b66c8c":"odor_dict = {\"almond\":\"a\",\"anise\":\"l\",\"creosote\":\"c\",\"fishy\":\"y\",\n             \"foul\":\"f\",\"musty\":\"m\",\"none\":\"n\",\"pungent\":\"p\",\"spicy\":\"s\"}\norder = ['p', 'a', 'l', 'n', 'f', 'c', 'y', 's', 'm']\nlabels = get_labels(order, odor_dict)      \nplot_col(col='odor', color=color_dict.keys(), labels=labels)","33f5a767":"labels = ['Edible', 'Poison']\nvalues = mush_encoded['class'].value_counts()\n\nfig=go.Figure(data=[go.Pie(labels=labels, values=values)])\nfig.update_traces(hoverinfo='label+percent', textinfo='value', textfont_size=20,\n                  marker=dict(colors=['#87CEFA', '#7FFF00'],\n                              line=dict(color='#FFFFFF',width=3)))\nfig.show()","0cda1397":"#Plot to understand the habitat of different mushrooms\nlabels = ['Woods', 'Grasses', 'Paths', 'Leaves', 'Urban', 'Meadows', 'Waste']\nvalues = mush_encoded['habitat'].value_counts()\ncolors = ['#DEB887','#778899', '#B22222', '#FFFF00', \n          '#F8F8FF','#FFE4C4','#FF69B4']\n\nfig=go.Figure(data=[go.Pie(labels=labels,\n                           values=values,\n                           #marker_colors=labels,\n                           pull=[0.1, 0, 0, 0, 0.2, 0, 0])])\nfig.update_traces(title='Mushrooms Habitat Percentage',\n                  hoverinfo='label+value', \n                  textinfo='percent', \n                  opacity=0.9,\n                  textfont_size=20,\n                  marker=dict(colors=colors,\n                             line=dict(color='#000000', width=0.1)),\n                 )\nfig.show()","75db1f3d":"colors = ['#DEB887','#f8f8ff','#778899', '#FF69B4','#FFFF00','#B22222','#FFE4C4','#F0DC82','#C000C5', '#228B22']\nfig = px.histogram(mush_encoded, x='cap-color',\n                   color_discrete_map={'p':'#7FFF00'},\n                   #opacity=0.8,\n                   color_discrete_sequence=[colors],\n                   #barmode='relative',\n                   barnorm='percent',\n                   color='class'\n                  )\nfig.update_layout(title='Percentage of Edible or Poisonous mushrooms Based on Cap Color',\n                  xaxis_title='Cap Color',\n                  yaxis_title='Quantity',\n                 )\n\nfig.show()","7476a80d":"labels = ['Brown', 'Gray', 'Red', 'Yellow', 'White', 'Buff', 'Pink', \n          'Cinnamon', 'Purple', 'Green']\nvalues = mush_encoded['cap-color'].value_counts()\ncolors = ['#DEB887','#778899', '#B22222', '#FFFF00', \n          '#F8F8FF','#FFE4C4','#FF69B4','#F0DC82','#C000C5', '#228B22']\n\nfig=go.Figure(data=[go.Pie(labels=labels,\n                           values=values,\n                           #marker_colors=labels,\n                           pull=[0, 0, 0, 0, 0.2, 0, 0, 0, 0, 0])])\nfig.update_traces(title='Mushrooms Color Quantity',\n                  hoverinfo='label+percent', \n                  textinfo='value',\n                  opacity=0.9,\n                  textfont_size=20,\n                  marker=dict(colors=colors,\n                             line=dict(color='#000000', width=0.1)),\n                 )\nfig.show()","f7770358":"from sklearn.model_selection import train_test_split\nfrom sklearn import preprocessing\n#class column is taken as a numpy array\ny = mush_encoded[\"class\"].values\n#All the features are separated from our target value or label and stored in x\nx = mush_encoded.drop([\"class\"],axis=1)\n#Finally split the data into train and test set\nx_train,x_test,y_train,y_test = train_test_split(x,y,random_state=42,test_size = 0.25)","7f68d555":"from sklearn.linear_model import LogisticRegression\nlr = LogisticRegression(solver=\"newton-cg\")\nlr.fit(x_train,y_train)\nprint(\"Test Accuracy: {}%\".format(round(lr.score(x_test,y_test)*100,2)))","34147f20":"from sklearn.neighbors import KNeighborsClassifier\nbest_Kvalue = 0\nbest_score=0\nfor i in range(1,10):\n    knn = KNeighborsClassifier(n_neighbors=i)\n    knn.fit(x_train,y_train)\n    if knn.score(x_test,y_test) > best_score:\n        best_score = knn.score(x_train,y_train)\n        best_Kvalue = i\nprint(\"\"\"Best KNN Value: {}\nTest Accuracy: {}%\"\"\".format(best_Kvalue, round(best_score*100,2)))","fefd41f6":"from sklearn.svm import SVC\nsvm = SVC(random_state=42, gamma=\"auto\")\nsvm.fit(x_train,y_train)\nprint(\"Test Accuracy: {}%\".format(round(svm.score(x_test,y_test)*100,2)))","dbeac1ea":"from sklearn.naive_bayes import GaussianNB\nnb = GaussianNB()\nnb.fit(x_train,y_train)\nprint(\"Test Accuracy: {}%\".format(round(nb.score(x_test,y_test)*100,2)))\n","f7d426b7":"from sklearn.tree import DecisionTreeClassifier\ndt = DecisionTreeClassifier()\ndt.fit(x_train,y_train)\nprint(\"Test Accuracy: {}%\".format(round(dt.score(x_test,y_test)*100,2)))","6f8445fa":"from sklearn.ensemble import RandomForestClassifier\nrf = RandomForestClassifier(n_estimators=100, random_state=42)\nrf.fit(x_train,y_train)\nprint(\"Test Accuracy: {}%\".format(round(rf.score(x_test,y_test)*100,2)))","ca68889a":"from sklearn.metrics import confusion_matrix\ny_pred_lr = lr.predict(x_test)\ny_true_lr = y_test\ncm = confusion_matrix(y_true_lr, y_pred_lr)\nf, ax = plt.subplots(figsize =(5,5))\nsns.heatmap(cm,annot = True,linewidths=0.5,linecolor=\"red\",fmt = \".0f\",ax=ax)\nplt.xlabel(\"y_pred_lr\")\nplt.ylabel(\"y_true_lr\")\nplt.show()","1e18c467":"from sklearn.metrics import confusion_matrix\ny_pred_nb = nb.predict(x_test)\ny_true_nb = y_test\ncm = confusion_matrix(y_true_nb, y_pred_nb)\nf, ax = plt.subplots(figsize =(5,5))\nsns.heatmap(cm,annot = True,linewidths=0.5,linecolor=\"red\",fmt = \".0f\",ax=ax)\nplt.xlabel(\"y_pred_nb\")\nplt.ylabel(\"y_true_nb\")\nplt.show()","093b2b28":"# Visualizations\n**Set Visualization Functions and Parameters**","bc1b4340":"**Only Naive Bayes and Logistic Regression gives less than 100% accuracy on the test data. Now we need to check our classification results with confusion matrix to know whether there are any false negative or false positive values**","335d28f4":"# Conclusion\n**Through the use of Confusion matrix, we can clearly see that our train and test datas are balanced, so our model is predicting well and also most classification methods scored 100%**","d02cf72c":"**Number of Mushrooms based on Odor**","ba400cd4":"**In this notebook,mushrooms are classified as either edible or poisonous, where edible is denoted as 'e' and poisonous is denoted as 'p' in the data set. Each character in the data set has some specific meaning, for example - in cap-shape column bell = b, conical=c,flat=f,sunken = s.**\n**This is a checklist which shows what each character means - **  \ncap-shape: bell=b,conical=c,convex=x,flat=f, knobbed=k,sunken=s\ncap-surface: fibrous=f,grooves=g,scaly=y,smooth=s\ncap-color: brown=n,buff=b,cinnamon=c,gray=g,green=r, pink=p,purple=u,red=e,white=w,yellow=y\nbruises?: bruises=t,no=f\nodor: almond=a,anise=l,creosote=c,fishy=y,foul=f, musty=m,none=n,pungent=p,spicy=s\ngill-attachment: attached=a,descending=d,free=f,notched=n\ngill-spacing: close=c,crowded=w,distant=d\ngill-size: broad=b,narrow=n\ngill-color: black=k,brown=n,buff=b,chocolate=h,gray=g, green=r,orange=o,pink=p,purple=u,red=e, white=w,yellow=y\nstalk-shape: enlarging=e,tapering=t\nstalk-root: bulbous=b,club=c,cup=u,equal=e, rhizomorphs=z,rooted=r,missing=?\nstalk-surface-above-ring: fibrous=f,scaly=y,silky=k,smooth=s\nstalk-surface-below-ring: fibrous=f,scaly=y,silky=k,smooth=s\nstalk-color-above-ring: brown=n,buff=b,cinnamon=c,gray=g,orange=o, pink=p,red=e,white=w,yellow=y\nstalk-color-below-ring: brown=n,buff=b,cinnamon=c,gray=g,orange=o, pink=p,red=e,white=w,yellow=y\nveil-type: partial=p,universal=u\nveil-color: brown=n,orange=o,white=w,yellow=y\nring-number: none=n,one=o,two=t\nring-type: cobwebby=c,evanescent=e,flaring=f,large=l, none=n,pendant=p,sheathing=s,zone=z\nspore-print-color: black=k,brown=n,buff=b,chocolate=h,green=r, orange=o,purple=u,white=w,yellow=y\npopulation: abundant=a,clustered=c,numerous=n, scattered=s,several=v,solitary=y\nhabitat: grasses=g,leaves=l,meadows=m,paths=p, urban=u,waste=w,woods=d *italicized text*","cfd14298":"**Now we will split the data set into train data and test data to apply machine learning**","f4b6a9db":"**Insight 3 - Red, Violet and Blue Mushrooms are more in quantity than other colors of mushrooms and are above 1000 in quantity**","11b8a414":"**Insight 2 - Canonical shaped Mushrooms are more in quantity where number of poisonous mushrooms are greater than edible mushrooms. Sunked shape mushrooms are also in significant quantity and both types have atleast 1000 samples**","bae11910":"**Visualization using Plotly**","b980b33a":"**No we will apply different classification methods to compare the accuracy of prediction of the classification models in predicting whether the mushrooms are edible or poisonous from the training data fed into the model**\n\n# Logistic Regression Classification","22ec16e5":"**Insight -1: Number of poisonous mushrooms are more in quantity than edible mushrooms**","e0bbc69b":"# Random Forest Classifier","9ea390fc":"# Naive Bayes Classification","8d0f3cdd":"# Importing libraries","129485a7":"****Now we will use Label Encoding which is a preprocessing technique to normalize labels to assign numbers to each of the features using Label Encoder class from scikit Learn library****","8de5fbe3":"**Insight:4 - Scaly Cap-surface mushrooms are very low in quantity in the sample, other categories of cap-surface are in considerable number**","745e1911":"**Insight: 5 - There are 4208 samples of Edible mushrooms and 3916 samples of poisonous ones, i.e, nearly 50% chances of picking a poisonous mushroom from the samples**","7530ed89":"# Decision Tree Classifier","949ee571":"# KNN Classification","763a83ff":"# Exploratory Data Analysis","8a6a0d77":"****In this data set feature scaling will not be much of a requirement as the features already have a low variance****","320e24f5":"# SVM Classification"}}