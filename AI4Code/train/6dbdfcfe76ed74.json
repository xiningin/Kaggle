{"cell_type":{"9098e400":"code","33254596":"code","7891dbe9":"code","045dec44":"code","89c200e0":"code","e7350e6a":"code","720db85e":"code","ebc71d8d":"code","a29d22f7":"code","e659be75":"code","0efeb5e8":"code","bcae74d1":"code","2f273eeb":"code","a5a0e1a3":"code","dfe46957":"markdown","cd55cf38":"markdown","4581fb5e":"markdown","43df194f":"markdown","cbbba249":"markdown","a4c132d5":"markdown","860e42b9":"markdown"},"source":{"9098e400":"import pandas as pd\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.patches as patches\nimport matplotlib.pyplot as plt\nimport os\nimport ast","33254596":"from torch.utils.data import Dataset\nimport torchvision.transforms as T\nimport torch","7891dbe9":"class GlobalWheatDataset(Dataset):\n    def __init__(self, path, train_or_test_path, transforms):\n        self.path = path\n        self.train_or_test_path = train_or_test_path\n        self.transforms = transforms\n\n        self.df = pd.read_csv(path + 'train.csv')\n\n        self.ids = {v:k for k, v in enumerate(np.unique(self.df.image_id.values))}\n        self.imgs_list = list(sorted(os.listdir(os.path.join(path, train_or_test_path))))\n\n    def get_rectangles(self, idx):\n        id = self.imgs_list[idx].split('\/')[-1].split('.jpg')[0]\n        rectangles = []\n\n        for box in self.df[self.df.image_id == id]['bbox'].values:\n            bbox = ast.literal_eval(box)\n            x = bbox[0]\n            y = bbox[1]\n            w = bbox[2]\n            h = bbox[3]\n            rectangles.append(patches.Rectangle((x,y),w,h,linewidth=1,edgecolor='r',facecolor='none'))\n\n        return rectangles\n\n    def format_boxes(self, boxes):\n        # replace width, height with xmax, ymax\n        try:\n            boxes[:, 2] =  boxes[:, 2] + boxes[:, 0]\n            boxes[:, 3] =  boxes[:, 3] + boxes[:, 1]\n        except:\n            pass\n        return boxes\n\n    def get_image(self, idx):\n        img_path = os.path.join(self.path, self.train_or_test_path, self.imgs_list[idx])\n        return np.array(Image.open(img_path).convert(\"RGB\"))\n\n    def draw(self, idx):\n        fig, ax = plt.subplots(1, figsize=(10, 10))\n        ax.imshow(dataset.get_image(idx))\n        for rectangle in dataset.get_rectangles(idx):\n            ax.add_patch(rectangle)\n        plt.show\n\n    def __getitem__(self, idx):\n        id = self.df.iloc[idx].image_id\n        boxes = np.int64(np.array([ast.literal_eval(box) for box in self.df[self.df.image_id == id]['bbox'].values]))\n\n        # format boxes width, height\n        boxes = self.format_boxes(boxes)\n        \n        target = {}\n        target[\"boxes\"] = torch.as_tensor(boxes, dtype=torch.int64)\n        target[\"labels\"] = torch.ones((len(boxes),), dtype=torch.int64)\n        target[\"image_id\"] = torch.tensor([self.ids[id]])\n        target[\"area\"] = (boxes[:, 3] - boxes[:, 1]) * (boxes[:, 2] - boxes[:, 0])\n        target[\"iscrowd\"] = torch.zeros((len(boxes),), dtype=torch.int64)\n        \n        img_path = os.path.join(self.path, self.train_or_test_path, self.imgs_list[idx])\n        img = Image.open(img_path).convert(\"RGB\")\n\n        if self.transforms is not None:\n            img = self.transforms(img)\n\n        return T.ToTensor()(img), target\n\n    def __len__(self):\n        return len(self.imgs_list)","045dec44":"def get_transform(train):\n    transforms = []\n    if train:\n        # random horizontal flip with 50% probability\n        transforms.append(T.RandomHorizontalFlip(0.5))\n    return T.Compose(transforms)","89c200e0":"path = '..\/input\/global-wheat-detection\/'\ntrain_path = 'train'\ntest_path = 'test'","e7350e6a":"dataset = GlobalWheatDataset(path, train_path, get_transform(train=True))\ndataset.draw(8)","720db85e":"device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')","ebc71d8d":"def my_collate(batch):\n    return tuple(zip(*batch))","a29d22f7":"dataset = GlobalWheatDataset(path, train_path, get_transform(train=True))\ndataset_test = GlobalWheatDataset(path, test_path, get_transform(train=False))\n\nindices = torch.randperm(len(dataset)).tolist()\nindices_test = torch.randperm(len(dataset_test)).tolist()\n\ndataset = torch.utils.data.Subset(dataset, indices)\ndataset_test = torch.utils.data.Subset(dataset_test, indices_test)\n\ndata_loader = torch.utils.data.DataLoader(\n        dataset, batch_size=2, shuffle=True, num_workers=4,\n        collate_fn=my_collate)\n\ndata_loader_test = torch.utils.data.DataLoader(\n        dataset_test, batch_size=1, shuffle=False, num_workers=4,\n        collate_fn=my_collate)","e659be75":"import torchvision\nfrom torchvision.models.detection.faster_rcnn import FastRCNNPredictor\n\nmodel = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)\n\nnum_classes = 2\nin_features = model.roi_heads.box_predictor.cls_score.in_features\n\nmodel.roi_heads.box_predictor = FastRCNNPredictor(in_features, num_classes)","0efeb5e8":"model = model.to(device)","bcae74d1":"params = [p for p in model.parameters() if p.requires_grad]\noptimizer = torch.optim.SGD(params, lr=0.005, momentum=0.9, weight_decay=0.0005)\n\n# and a learning rate scheduler\nlr_scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=8, gamma=0.1)","2f273eeb":"total_errors = []\nfor epoch in range(10):\n    losses_arr = []\n\n    for images, targets in data_loader:\n\n        images = list(image.to(device) for image in images)\n        targets = [{k: torch.as_tensor(v).detach().to(device) for k, v in t.items()} for t in targets]\n\n        optimizer.zero_grad()\n\n        loss_dict = model(images, targets)\n        losses = sum(loss for loss in loss_dict.values())\n        losses_arr.append(losses.item())\n\n        losses.backward()\n        optimizer.step()\n\n        # update the learning rate\n        # lr_scheduler.step()\n        \n    total_errors.append(np.mean(np.array(losses_arr)))\n    if epoch % 1 == 0:\n        print(\"Epoch:{0:3d}, Loss:{1:1.3f}\".format(epoch, total_errors[-1]))","a5a0e1a3":"plt.plot(total_errors)","dfe46957":"# Create Datasets and DataLoaders","cd55cf38":"# Dataset","4581fb5e":"# Evaluate Loss","43df194f":"# Global Wheat Detection Faster R-CNN","cbbba249":"# Augmentations","a4c132d5":"# Create Faster RCNN Model with Resnet50","860e42b9":"# Training"}}