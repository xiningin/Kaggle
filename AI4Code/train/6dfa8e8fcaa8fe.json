{"cell_type":{"b240afd4":"code","fe60d2eb":"code","f59d85f0":"code","003b4df7":"code","5c6e672c":"code","77be397b":"code","875eea5b":"code","4e5226cc":"code","fab803c9":"code","eba9870f":"code","5478d053":"code","6341a433":"code","5373fefb":"code","1c850305":"code","5ede5f9a":"code","dd887f35":"code","266ee61d":"code","a2fe3075":"code","9377abd5":"code","43224c70":"code","64a0d3f8":"code","6fc35d8b":"code","8cafcc65":"markdown","a05dee61":"markdown"},"source":{"b240afd4":"#Import libraries for data analysis, visualization, and ML model building\nimport numpy as np\nimport pandas as pd\nfrom sklearn.metrics import accuracy_score,mean_squared_error\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import LogisticRegression\nfrom scipy import stats\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport os\nimport warnings\nwarnings.filterwarnings('ignore')\n%matplotlib inline","fe60d2eb":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","f59d85f0":"train = pd.read_csv('\/kaggle\/input\/learn-together\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/learn-together\/test.csv')\nsample_submission = pd.read_csv('\/kaggle\/input\/learn-together\/sample_submission.csv')","003b4df7":"#List of all non-binary columns\nnon_binary_cols = ['Elevation', 'Aspect', 'Slope',\n       'Horizontal_Distance_To_Hydrology', 'Vertical_Distance_To_Hydrology',\n       'Horizontal_Distance_To_Roadways', 'Hillshade_9am', 'Hillshade_Noon',\n       'Hillshade_3pm', 'Horizontal_Distance_To_Fire_Points']","5c6e672c":"#The 'aspect' variable reflects the azimuth measurement in degrees (0-360).\n#Since a reading of 180 degrees indicates that the sun is directly overhead,\n#readings of 200 and 160 degrees would be equivalent. \n#Therefore, I updated the column for this variable to situate all readings between 0 and 180.\ntrain['Aspect']=np.absolute(180-train['Aspect'])\ntest['Aspect']=np.absolute(180-test['Aspect'])","77be397b":"def create_corr_viz(x):\n    #Create correlation table\n    correlation_table = x.corr().round(3)\n    #Diagonally slice table to remove duplicates using np.tril method\n    data_viz_cols = correlation_table.columns\n    data_viz_index = correlation_table.index\n    correlation_table = pd.DataFrame(np.tril(correlation_table),columns=data_viz_cols,index=data_viz_index).replace(0,np.nan).replace(1,np.nan)\n    #Adjust plot size\n    a4_dims = (11.7, 8.27)\n    fig, ax = plt.subplots(figsize=a4_dims)\n    sns.heatmap(correlation_table, annot=True,cmap='coolwarm')\n    plt.show()\ncreate_corr_viz(train[non_binary_cols])","875eea5b":"#Create lists representing feature and target variables\nfeatures = ['Elevation', 'Slope',\n       'Horizontal_Distance_To_Hydrology', 'Vertical_Distance_To_Hydrology',\n       'Horizontal_Distance_To_Roadways', 'Hillshade_9am', 'Hillshade_Noon',\n       'Hillshade_3pm', 'Horizontal_Distance_To_Fire_Points']\ntarget = ['Cover_Type']\n\n#Create Function to Perform the Following Two Tasks:\n#1.Scale training set values to values between 0 and 1\n#2.Split train model into train, test split for supervised learning\ndef scale_n_split(df,features,target):\n    scale = MinMaxScaler((0,1))\n    scaled_train = scale.fit_transform(df[features])\n    scaled_train_df = pd.DataFrame(scaled_train,columns=features)\n    scaled_train_df[target] = train[target]\n    supervised_train,supervised_test = train_test_split(scaled_train_df,random_state=42)\n    return supervised_train,supervised_test\n\nsupervised_train,supervised_test = scale_n_split(train,features,target)","4e5226cc":"#Train KNN Classifier Model inclusive of all non-binary variables\n\ndef train_knn(train_df,test_df,features,target):\n    model = KNeighborsClassifier(n_neighbors=3,algorithm='auto')\n    model.fit(train_df[features],train_df[target])\n    predictions = model.predict(test_df[features])\n    score = accuracy_score(predictions,test_df[target])\n    score.round(2)\n    return score,predictions,model\n\nscore,predictions,model = train_knn(supervised_train,supervised_test,features,target)\ncross_val_scores = cross_val_score(model,supervised_train[features],supervised_train[target],cv=5)\ncross_val_scores\n#pd.Series(predictions).value_counts(dropna=False,ascending=False)","fab803c9":"test['Cover_Type'] = model.predict(test[features])\ntest['Cover_Type'].value_counts(dropna=False)\n#test[['Id','Cover_Type']].to_csv('knn_init_submission.csv',index=False)","eba9870f":"binary_cols = ['Wilderness_Area1', 'Wilderness_Area2', 'Wilderness_Area3',\n       'Wilderness_Area4', 'Soil_Type1', 'Soil_Type2', 'Soil_Type3',\n       'Soil_Type4', 'Soil_Type5', 'Soil_Type6', 'Soil_Type7', 'Soil_Type8',\n       'Soil_Type9', 'Soil_Type10', 'Soil_Type11', 'Soil_Type12',\n       'Soil_Type13', 'Soil_Type14', 'Soil_Type15', 'Soil_Type16',\n       'Soil_Type17', 'Soil_Type18', 'Soil_Type19', 'Soil_Type20',\n       'Soil_Type21', 'Soil_Type22', 'Soil_Type23', 'Soil_Type24',\n       'Soil_Type25', 'Soil_Type26', 'Soil_Type27', 'Soil_Type28',\n       'Soil_Type29', 'Soil_Type30', 'Soil_Type31', 'Soil_Type32',\n       'Soil_Type33', 'Soil_Type34', 'Soil_Type35', 'Soil_Type36',\n       'Soil_Type37', 'Soil_Type38', 'Soil_Type39', 'Soil_Type40',]\n\nbinary_train,binary_test = scale_n_split(train,binary_cols,target)\nbinary_score,binary_predictions,binary_model = train_knn(binary_train,binary_test,binary_cols,target)\ncross_val_scores = cross_val_score(binary_model,binary_train[binary_cols],binary_train[target],cv=5)\ncross_val_scores","5478d053":"#test['Cover_Type'] = binary_model.predict(test[binary_cols])","6341a433":"#submission_binary_cols = test[['Id','Cover_Type']]\n#submission_binary_cols.to_csv('submission_2.csv',index=False)","5373fefb":"train.head()","1c850305":"target_corrs = round(abs(train.corr()[target]),2)\nsignificant_cols = [index for index,val in target_corrs['Cover_Type'].iteritems() if val>0.1]","5ede5f9a":"soil_type_cols = [x for x in significant_cols if 'Soil' in x ]\nall_soil_type_cols = [x for x in train.columns if 'Soil' in x ]","dd887f35":"soil_frequencies = pd.Series(train[soil_type_cols].sum()\/train.shape[0])\nsoil_frequencies.sort_values(ascending=False)","266ee61d":"sum(soil_frequencies)","a2fe3075":"target_corrs.sort_values(by='Cover_Type',ascending=False)","9377abd5":"train[all_soil_type_cols].where(train[all_soil_type_cols].sum(axis=1)>1).any()","43224c70":"new_model = KNeighborsClassifier(n_neighbors=3)\nscale = MinMaxScaler((0,1))\nscaled_train = scale.fit_transform(train[features])\nscaled_train_df = pd.DataFrame(scaled_train,columns=features)\nscaled_train_df[target] = train[target]\nnew_model.fit(scaled_train_df[features],scaled_train_df[target])\npredictions = model.predict(test[features])","64a0d3f8":"test['Cover_Type'] = predictions","6fc35d8b":"submission_retry_knn =  test[['Id','Cover_Type']]\nsubmission_retry_knn.to_csv('submission_5.csv',index=False)","8cafcc65":"The three non-binary variables with the biggest *positive* correlation coefficients are as follows:\n\n-----------\n| Feature 1 | Feature 2 | Correlation |\n|---|---|---|\n|Vertical Distance to Hydrology | Horizontal Distance to Hydrology|0.65|\n|Hillshade Noon|Hillshade 3pm |0.61|\n|Horizontal Distance to Roadways | Elevation |0.58|\n\n----------\n\nThe three non-binary variables with the biggest *negative* correlation coefficients are as follows:\n\n-----------\n| Feature 1 | Feature 2 | Correlation |\n|---|---|---|\n|Hillshade 9am| Hillshade 3pm|-0.78|\n|Hillshade Noon|Slope|-0.61|\n|Hillshade Noon|Aspect|-0.58|\n\n----------\nObservations Regarding Feature Correlations:\n\n* No features are strongly correlated with the target variable, Cover Type. Horizontal Distance to Roadways is negatively-correlated with the target with a weak -0.11 coefficient. There is a good chance non of these features will be useful in building the model.\n* One would expect to see a positive correlation between Hillshade Noon and Slope as well as a negative  correlation between Hillshade Noon and Aspect, as Slope and Aspect would be the primary if not exclusive variables calculating the degree of hillshade when the Sun is directly overhead. \n* The strong correlation between the Vertical and Horizontal Distances to Hydrology seems to suggest that they are measuring proximity to the *same* body of water and can be combined using the Pythagorean theorem to calculate a direct distance to the water body. \n* Horizontal Distance to Roadways and Elevation is an intuitive correlation, as is the negative correlation between Hillshade 9am and Hillshade 3pm. ","a05dee61":"## Exploratory Data Analysis"}}