{"cell_type":{"010c8d90":"code","85215052":"code","7efb0cec":"code","24a9be4d":"code","c2444414":"code","fc267923":"code","34b70911":"code","f159940a":"code","77fcfef3":"code","aae93380":"code","aafe1d9b":"code","f612420d":"code","eb3f8b6e":"code","60c78574":"code","828b2e41":"code","a01a0cdb":"code","fd548eec":"code","09e680f7":"code","22a90cff":"code","47137443":"code","cd5f0374":"code","89d899b8":"code","6148d92f":"code","3883fffc":"markdown","f26705e8":"markdown","a6e3a918":"markdown","f819751e":"markdown","0b97082f":"markdown","a09d5e24":"markdown","db435a56":"markdown","99b879ab":"markdown","a2e4da52":"markdown","50c4f22f":"markdown","2ec727bf":"markdown","2a0c488b":"markdown","6c887f5a":"markdown","1da40171":"markdown","8656a031":"markdown","83b33dac":"markdown","33a90d22":"markdown","8f8c5dfa":"markdown","81691280":"markdown","1f7486e0":"markdown","b9b51634":"markdown","9da7d6ab":"markdown","f22bb3bb":"markdown","1c704967":"markdown"},"source":{"010c8d90":"import numpy as np \nimport pandas as pd \n\nimport matplotlib.colors\nimport matplotlib.cm as cm\nimport matplotlib.font_manager\nimport matplotlib.pyplot as plt\nimport matplotlib.path as mpath\nfrom matplotlib.path import Path\nimport matplotlib.lines as mlines\nimport matplotlib.patches as mpatches\nimport matplotlib.transforms as mtrans\nfrom matplotlib.patches import Ellipse\nfrom matplotlib.textpath import TextPath\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Rectangle, PathPatch\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","85215052":"    \"\"\"\n    Create a polar axes containing the matplotlib radar plot.\n\n    Parameters\n    ----------\n    fig : matplotlib.figure.Figure\n        The figure to draw into.\n    ax_position : (float, float, float, float)\n        The position of the created Axes in figure coordinates as\n        (x, y, width, height).\n    lw_bars : float\n        The linewidth of the bars.\n    lw_grid : float\n        The linewidth of the grid.\n    lw_border : float\n        The linewidth of the Axes border.\n    rgrid : array-like\n        Positions of the radial grid.\n\n    Returns\n    -------\n    ax : matplotlib.axes.Axes\n        The created Axes.\n    \"\"\"\n    \"\"\"\n    Create a full figure with the Matplotlib logo.\n\n    Parameters\n    ----------\n    height_px : int\n        Height of the figure in pixel.\n    lw_bars : float\n        The linewidth of the bar border.\n    lw_grid : float\n        The linewidth of the grid.\n    lw_border : float\n        The linewidth of icon border.\n    rgrid : sequence of float\n        The radial grid positions.\n    with_text : bool\n        Whether to draw only the icon or to include 'matplotlib' as text.\n    \"\"\"","7efb0cec":"MPL_BLUE = '#11557c'\n\ndef get_font_properties():\n    # The original font is Calibri, if that is not installed, we fall back\n    # to Carlito, which is metrically equivalent.\n    if 'Calibri' in matplotlib.font_manager.findfont('Calibri:bold'):\n        return matplotlib.font_manager.FontProperties(family='Calibri',\n                                                      weight='bold')\n    if 'Carlito' in matplotlib.font_manager.findfont('Carlito:bold'):\n        print('Original font not found. Falling back to Carlito. '\n              'The logo text will not be in the correct font.')\n        return matplotlib.font_manager.FontProperties(family='Carlito',\n                                                      weight='bold')\n    print('Original font not found. '\n          'The logo text will not be in the correct font.')\n    return None\n\ndef create_icon_axes(fig, ax_position, lw_bars, lw_grid, lw_border, rgrid):\n\n    with plt.rc_context({'axes.edgecolor': MPL_BLUE,\n                         'axes.linewidth': lw_border}):\n        ax = fig.add_axes(ax_position, projection='polar')\n        ax.set_axisbelow(True)\n\n        N = 7\n        arc = 2. * np.pi\n        theta = np.arange(0.0, arc, arc \/ N)\n        radii = np.array([2, 6, 8, 7, 4, 5, 8])\n        width = np.pi \/ 4 * np.array([0.4, 0.4, 0.6, 0.8, 0.2, 0.5, 0.3])\n        bars = ax.bar(theta, radii, width=width, bottom=0.0, align='edge',\n                      edgecolor='0.3', lw=lw_bars)\n        for r, bar in zip(radii, bars):\n            color = *cm.jet(r \/ 10.)[:3], 0.6  # color from jet with alpha=0.6\n            bar.set_facecolor(color)\n\n        ax.tick_params(labelbottom=False, labeltop=False,\n                       labelleft=False, labelright=False)\n\n        ax.grid(lw=lw_grid, color='0.9')\n        ax.set_rmax(9)\n        ax.set_yticks(rgrid)\n\n        # the actual visible background - extends a bit beyond the axis\n        ax.add_patch(Rectangle((0, 0), arc, 9.58,\n                               facecolor='white', zorder=0,\n                               clip_on=False, in_layout=False))\n        return ax\n\ndef create_text_axes(fig, height_px):\n    \"\"\"Create an axes in *fig* that contains 'matplotlib' as Text.\"\"\"\n    ax = fig.add_axes((0, 0, 1, 1))\n    ax.set_aspect(\"equal\")\n    ax.set_axis_off()\n\n    path = TextPath((0, 0), \"matplotlib\", size=height_px * 0.8,\n                    prop=get_font_properties())\n\n    angle = 4.25  # degrees\n    trans = mtrans.Affine2D().skew_deg(angle, 0)\n\n    patch = PathPatch(path, transform=trans + ax.transData, color=MPL_BLUE,\n                      lw=0)\n    ax.add_patch(patch)\n    ax.autoscale()\n\ndef make_logo(height_px, lw_bars, lw_grid, lw_border, rgrid, with_text=False):\n\n    dpi = 100\n    height = height_px \/ dpi\n    figsize = (5 * height, height) if with_text else (height, height)\n    fig = plt.figure(figsize=figsize, dpi=dpi)\n    fig.patch.set_alpha(0)\n\n    if with_text:\n        create_text_axes(fig, height_px)\n    ax_pos = (0.535, 0.12, .17, 0.75) if with_text else (0.03, 0.03, .94, .94)\n    ax = create_icon_axes(fig, ax_pos, lw_bars, lw_grid, lw_border, rgrid)\n\n    return fig, ax\n\nmake_logo(height_px=110, lw_bars=0.7, lw_grid=0.5, lw_border=1,\n          rgrid=[1, 3, 5, 7], with_text=True)\nplt.show()","24a9be4d":"def label(xy, text):\n    y = xy[1] - 0.15  # shift y-value for label so that it's below the artist\n    plt.text(xy[0], y, text, ha=\"center\", family='sans-serif', size=14)\n\n\nfig, ax = plt.subplots()\n# create 3x3 grid to plot the artists\ngrid = np.mgrid[0.2:0.8:3j, 0.2:0.8:3j].reshape(2, -1).T\n\npatches = []\n\n# add a circle\ncircle = mpatches.Circle(grid[0], 0.1, ec=\"none\")\npatches.append(circle)\nlabel(grid[0], \"Circle\")\n\n# add a rectangle\nrect = mpatches.Rectangle(grid[1] - [0.025, 0.05], 0.05, 0.1, ec=\"none\")\npatches.append(rect)\nlabel(grid[1], \"Rectangle\")\n\n# add a wedge\nwedge = mpatches.Wedge(grid[2], 0.1, 30, 270, ec=\"none\")\npatches.append(wedge)\nlabel(grid[2], \"Wedge\")\n\n# add a Polygon\npolygon = mpatches.RegularPolygon(grid[3], 5, 0.1)\npatches.append(polygon)\nlabel(grid[3], \"Polygon\")\n\n# add an ellipse\nellipse = mpatches.Ellipse(grid[4], 0.2, 0.1)\npatches.append(ellipse)\nlabel(grid[4], \"Ellipse\")\n\n# add an arrow\narrow = mpatches.Arrow(grid[5, 0] - 0.05, grid[5, 1] - 0.05, 0.1, 0.1,\n                       width=0.1)\npatches.append(arrow)\nlabel(grid[5], \"Arrow\")\n\n# add a path patch\nPath = mpath.Path\npath_data = [\n    (Path.MOVETO, [0.018, -0.11]),\n    (Path.CURVE4, [-0.031, -0.051]),\n    (Path.CURVE4, [-0.115, 0.073]),\n    (Path.CURVE4, [-0.03, 0.073]),\n    (Path.LINETO, [-0.011, 0.039]),\n    (Path.CURVE4, [0.043, 0.121]),\n    (Path.CURVE4, [0.075, -0.005]),\n    (Path.CURVE4, [0.035, -0.027]),\n    (Path.CLOSEPOLY, [0.018, -0.11])]\ncodes, verts = zip(*path_data)\npath = mpath.Path(verts + grid[6], codes)\npatch = mpatches.PathPatch(path)\npatches.append(patch)\nlabel(grid[6], \"PathPatch\")\n\n# add a fancy box\nfancybox = mpatches.FancyBboxPatch(\n    grid[7] - [0.025, 0.05], 0.05, 0.1,\n    boxstyle=mpatches.BoxStyle(\"Round\", pad=0.02))\npatches.append(fancybox)\nlabel(grid[7], \"FancyBboxPatch\")\n\n# add a line\nx, y = ([-0.06, 0.0, 0.1], [0.05, -0.05, 0.05])\nline = mlines.Line2D(x + grid[8, 0], y + grid[8, 1], lw=5., alpha=0.3)\nlabel(grid[8], \"Line2D\")\n\ncolors = np.linspace(0, 1, len(patches))\ncollection = PatchCollection(patches, cmap=plt.cm.hsv, alpha=0.3)\ncollection.set_array(colors)\nax.add_collection(collection)\nax.add_line(line)\n\nplt.axis('equal')\nplt.axis('off')\nplt.tight_layout()\n\nplt.show()","c2444414":"# Fixing random state for reproducibility\nnp.random.seed(1968089)\n\nNUM = 250\n\nells = [Ellipse(xy=np.random.rand(2) * 13,\n                width=np.random.rand(), height=np.random.rand(),\n                angle=np.random.rand() * 360)\n        for i in range(NUM)]\n\nfig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})\nfor e in ells:\n    ax.add_artist(e)\n    e.set_clip_box(ax.bbox)\n    e.set_alpha(np.random.rand())\n    e.set_facecolor(np.random.rand(4))\n\nax.set_xlim(0, 13)\nax.set_ylim(0, 10)\n\nplt.show()","fc267923":"# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nr = np.random.rand(50)\nt = np.random.rand(50) * np.pi * 2.0\nx = r * np.cos(t)\ny = r * np.sin(t)\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncircle = Circle((0, 0), 1, facecolor='none',\n                edgecolor=(0, 0.8, 0.8), linewidth=3, alpha=0.5)\nax.add_patch(circle)\n\nim = plt.imshow(np.random.random((100, 100)),\n                origin='lower', cmap=cm.winter,\n                interpolation='spline36',\n                extent=([-1, 1, -1, 1]))\nim.set_clip_path(circle)\n\nplt.plot(x, y, 'o', color=(0.9, 0.9, 1.0), alpha=0.8)\n\ndolphin = \"\"\"\nM -0.59739425,160.18173 C -0.62740401,160.18885 -0.57867129,160.11183\n-0.57867129,160.11183 C -0.57867129,160.11183 -0.5438361,159.89315\n-0.39514638,159.81496 C -0.24645668,159.73678 -0.18316813,159.71981\n-0.18316813,159.71981 C -0.18316813,159.71981 -0.10322971,159.58124\n-0.057804323,159.58725 C -0.029723983,159.58913 -0.061841603,159.60356\n-0.071265813,159.62815 C -0.080250183,159.65325 -0.082918513,159.70554\n-0.061841203,159.71248 C -0.040763903,159.7194 -0.0066711426,159.71091\n0.077336307,159.73612 C 0.16879567,159.76377 0.28380306,159.86448\n0.31516668,159.91533 C 0.3465303,159.96618 0.5011127,160.1771\n0.5011127,160.1771 C 0.63668998,160.19238 0.67763022,160.31259\n0.66556395,160.32668 C 0.65339985,160.34212 0.66350443,160.33642\n0.64907098,160.33088 C 0.63463742,160.32533 0.61309688,160.297\n0.5789627,160.29339 C 0.54348657,160.28968 0.52329693,160.27674\n0.50728856,160.27737 C 0.49060916,160.27795 0.48965803,160.31565\n0.46114204,160.33673 C 0.43329696,160.35786 0.4570711,160.39871\n0.43309565,160.40685 C 0.4105108,160.41442 0.39416631,160.33027\n0.3954995,160.2935 C 0.39683269,160.25672 0.43807996,160.21522\n0.44567915,160.19734 C 0.45327833,160.17946 0.27946869,159.9424\n-0.061852613,159.99845 C -0.083965233,160.0427 -0.26176109,160.06683\n-0.26176109,160.06683 C -0.30127962,160.07028 -0.21167141,160.09731\n-0.24649368,160.1011 C -0.32642366,160.11569 -0.34521187,160.06895\n-0.40622293,160.0819 C -0.467234,160.09485 -0.56738444,160.17461\n-0.59739425,160.18173\n\"\"\"\n\nvertices = []\ncodes = []\nparts = dolphin.split()\ni = 0\ncode_map = {\n    'M': Path.MOVETO,\n    'C': Path.CURVE4,\n    'L': Path.LINETO,\n}\n\nwhile i < len(parts):\n    path_code = code_map[parts[i]]\n    npoints = Path.NUM_VERTICES_FOR_CODE[path_code]\n    codes.extend([path_code] * npoints)\n    vertices.extend([[*map(float, y.split(','))]\n                     for y in parts[i + 1:][:npoints]])\n    i += npoints + 1\nvertices = np.array(vertices)\nvertices[:, 1] -= 160\n\ndolphin_path = Path(vertices, codes)\ndolphin_patch = PathPatch(dolphin_path, facecolor=(0.6, 0.6, 0.6),\n                          edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch)\n\nvertices = Affine2D().rotate_deg(60).transform(vertices)\ndolphin_path2 = Path(vertices, codes)\ndolphin_patch2 = PathPatch(dolphin_path2, facecolor=(0.5, 0.5, 0.5),\n                           edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch2)\n\nplt.show()","34b70911":"from matplotlib.image import BboxImage\nfrom matplotlib.transforms import Bbox, TransformedBbox\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# ----------------------------\n# Create a BboxImage with Text\n# ----------------------------\ntxt = ax1.text(0.5, 0.5, \"Matplotlib\", size=30, ha=\"center\", color=\"w\")\nkwargs = dict()\n\nbbox_image = BboxImage(txt.get_window_extent,\n                       norm=None,\n                       origin=None,\n                       clip_on=False,\n                       **kwargs\n                       )\na = np.arange(256).reshape(1, 256)\/256.\nbbox_image.set_data(a)\nax1.add_artist(bbox_image)\n\n# ------------------------------------\n# Create a BboxImage for each colormap\n# ------------------------------------\na = np.linspace(0, 1, 256).reshape(1, -1)\na = np.vstack((a, a))\n\n# List of all colormaps; skip reversed colormaps.\nmaps = sorted(m for m in plt.colormaps() if not m.endswith(\"_r\"))\n\nncol = 2\nnrow = len(maps)\/\/ncol + 1\n\nxpad_fraction = 0.3\ndx = 1.\/(ncol + xpad_fraction*(ncol - 1))\n\nypad_fraction = 0.3\ndy = 1.\/(nrow + ypad_fraction*(nrow - 1))\n\nfor i, m in enumerate(maps):\n    ix, iy = divmod(i, nrow)\n\n    bbox0 = Bbox.from_bounds(ix*dx*(1 + xpad_fraction),\n                             1. - iy*dy*(1 + ypad_fraction) - dy,\n                             dx, dy)\n    bbox = TransformedBbox(bbox0, ax2.transAxes)\n\n    bbox_image = BboxImage(bbox,\n                           cmap=plt.get_cmap(m),\n                           norm=None,\n                           origin=None,\n                           **kwargs\n                           )\n\n    bbox_image.set_data(a)\n    ax2.add_artist(bbox_image)\n\nplt.show()","f159940a":"theta = np.arange(0, 7*np.pi, 0.1)\na = 1\nb = .2\n\nfor dt in np.arange(0, 2*np.pi, np.pi\/2.0):\n\n    x = a*np.cos(theta + dt)*np.exp(b*theta)\n    y = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    dt = dt + np.pi\/4.0\n\n    x2 = a*np.cos(theta + dt)*np.exp(b*theta)\n    y2 = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    xf = np.concatenate((x, x2[::-1]))\n    yf = np.concatenate((y, y2[::-1]))\n\n    p1 = plt.fill(xf, yf)\n\nplt.show()","77fcfef3":"# Fixing random state for reproducibility\nnp.random.seed(186123915)\n\n# Compute areas and colors\nN = 600\nr = 2 * np.random.rand(N)\ntheta = 2 * np.pi * np.random.rand(N)\narea = 100 * r**6\ncolors = theta\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='gist_rainbow', alpha=0.9)","aae93380":"fig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.9)\n\nax.set_rorigin(-2.5)\nax.set_theta_zero_location('W', offset=10)","aafe1d9b":"fig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='gist_rainbow', alpha=0.9)\n\nax.set_thetamin(100)\nax.set_thetamax(170)\n\nplt.show()","f612420d":"from matplotlib import cbook\nfrom matplotlib import cm\nfrom matplotlib.colors import LightSource\n\ndem = cbook.get_sample_data('jacksboro_fault_dem.npz', np_load=True)\nz = dem['elevation']\nnrows, ncols = z.shape\nx = np.linspace(dem['xmin'], dem['xmax'], ncols)\ny = np.linspace(dem['ymin'], dem['ymax'], nrows)\nx, y = np.meshgrid(x, y)\n\nregion = np.s_[10:50, 10:50]\nx, y, z = x[region], y[region], z[region]\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\n\nls = LightSource(275, 200)\n# To use a custom hillshading mode, override the built-in shading and pass\n# in the rgb colors of the shaded surface calculated from \"shade\".\nrgb = ls.shade(z, cmap=cm.ocean, vert_exag=0.1, blend_mode='soft')\nsurf = ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=rgb,\n                       linewidth=0, antialiased=False, shade=False)\nax.set_xticks([])\nax.set_yticks([])\nax.set_zticks([])\nfig.savefig(\"surface3d_frontpage.png\", dpi=35)  # results in 160x120 px image","eb3f8b6e":"fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\n\ns = LightSource(275, 400)\n# To use a custom hillshading mode, override the built-in shading and pass\n# in the rgb colors of the shaded surface calculated from \"shade\".\nrgb = ls.shade(z, cmap=cm.ocean, vert_exag=0.5, blend_mode='soft')\nsurf = ax.plot_surface(x, y, z, rstride=5, cstride=9, facecolors=rgb,\n                       linewidth=0, antialiased=False, shade=False)\nax.set_xticks([])\nax.set_yticks([])\nax.set_zticks([])\nfig.savefig(\"surface2d_frontpage.png\", dpi=35)  # results in 160x120 px image","60c78574":"theta = np.linspace(0, 4*np.pi)\nx = np.cos(theta - np.pi\/2)\ny = np.sin(theta - np.pi\/2)\nz = theta\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nax.stem(x, y, z)\n\nplt.show()","828b2e41":"fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(x, y, z, bottom=-1, orientation='x')\nax.set(xlabel='x', ylabel='y', zlabel='z')\n\nplt.show()","a01a0cdb":"fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(\n    x, y, z, linefmt='grey', markerfmt='D', bottom=np.pi)\nmarkerline.set_markerfacecolor('none')\n\nplt.show()","fd548eec":"fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make data\nu = np.linspace(0, 6 * np.pi, 500)\nv = np.linspace(0, np.pi, 9)\nx = 11 * np.outer(np.cos(u), np.sin(v))\ny = 10 * np.outer(np.sin(u), np.sin(v))\nz = 10 * np.outer(np.ones(np.size(u)), np.cos(v))\n\n# Plot the surface\nax.plot_surface(x, y, z)\n\nplt.show()","09e680f7":"fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Create the mesh in polar coordinates and compute corresponding Z.\nr = np.linspace(0, 1.4, 60)\np = np.linspace(0, 1.5*np.pi, 40)\nR, P = np.meshgrid(r, p)\nZ = ((R**1.9 - 1)**2)\n\n# Express the mesh in the cartesian system.\nX, Y = R*np.cos(P), R*np.sin(P)\n\n# Plot the surface.\nax.plot_surface(X, Y, Z, cmap= 'gnuplot2')\n\n# Tweak the limits and add latex math labels.\nax.set_zlim(0, 0.9)\nax.set_xlabel(r'$\\phi_\\mathrm{real}$')\nax.set_ylabel(r'$\\phi_\\mathrm{im}$')\nax.set_zlabel(r'$V(\\phi)$')\n\nplt.show()","22a90cff":"n_radi = 30\nn_angles = 90\n\n# Make radi and angles spaces (radius r=0 omitted to eliminate duplication).\nradi = np.linspace(0.5, 2.0, n_radi)\nangles = np.linspace(0, 5*np.pi, n_angles, endpoint=False)[..., np.newaxis]\n\n# Convert polar (radi, angles) coords to cartesian (x, y) coords.\n# (0, 0) is manually added at this stage,  so there will be no duplicate\n# points in the (x, y) plane.\nx = np.append(0, (radi*np.cos(angles)).flatten())\ny = np.append(0, (radi*np.sin(angles)).flatten())\n\n# Compute z to make the pringle surface.\nz = np.sin(-x*y)\n\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot_trisurf(x, y, z, linewidth=0.5, antialiased=True, cmap='gist_rainbow')\n\nplt.show()","47137443":"import matplotlib.tri as mtri\n\nfig = plt.figure(figsize=plt.figaspect(0.4))\n\n# Make a mesh in the space of parameterisation variables u and v\nu = np.linspace(0, 6.0 * np.pi, endpoint=True, num=50)\nv = np.linspace(-1.9, 0.9, endpoint=True, num=15)\nu, v = np.meshgrid(u, v)\nu, v = u.flatten(), v.flatten()\n\n# This is the Mobius mapping, taking a u, v pair and returning an x, y, z\n# triple\nx = (2 + 0.5 * v * np.cos(u \/ 3.0)) * np.cos(u)\ny = (1 + 0.9 * v * np.cos(u \/ 5.0)) * np.sin(u)\nz = 0.5 * v * np.sin(u \/ 5.0)\n\n# Triangulate parameter space to determine the triangles\ntri = mtri.Triangulation(u, v)\n\n# Plot the surface.  The triangles in parameter space determine which x, y, z\n# points are connected by an edge.\nax = fig.add_subplot(1, 2, 1, projection='3d')\nax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=plt.cm.cool)\nax.set_zlim(-1, 1)","cd5f0374":"fig = plt.figure(figsize=plt.figaspect(0.4))\n\n# Make parameter spaces radii and angles.\nn_angles = 89\nn_radii = 6\nmin_radius = 0.15\nradii = np.linspace(min_radius, 0.65, n_radii)\n\nangles = np.linspace(0, 3*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi\/n_angles\n\n# Map radius, angle pairs to x, y, z points.\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(5*angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = mtri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\nxmid = x[triang.triangles].mean(axis=1)\nymid = y[triang.triangles].mean(axis=1)\nmask = xmid**2 + ymid**4 < min_radius**3\ntriang.set_mask(mask)\n\n# Plot the surface.\nax = fig.add_subplot(1, 2, 2, projection='3d')\nax.plot_trisurf(triang, z, cmap=plt.cm.gist_ncar)\n\n\nplt.show()","89d899b8":"def midpoints(x):\n    sl = ()\n    for i in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) \/ 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, g, b = np.indices((19, 18, 16)) \/ 17.0\nrc = midpoints(r)\ngc = midpoints(g)\nbc = midpoints(b)\n\n# define a sphere about [0.5, 0.5, 0.5]\nsphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 < 0.5**2\n\n# combine the color components\ncolors = np.zeros(sphere.shape + (3,))\ncolors[..., 0] = rc\ncolors[..., 1] = gc\ncolors[..., 2] = bc\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(r, g, b, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(3*colors - 0.8, 0, 1),  # brighter\n          linewidth=0.1)\nax.set(xlabel='r', ylabel='g', zlabel='b')\n\nplt.show()","6148d92f":"def midpoints(x):\n    sl = ()\n    for i in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) \/ 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j]\nx = r*np.cos(theta)\ny = r*np.sin(theta)\n\nrc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z)\n\n# define a wobbly torus about [0.7, *, 0]\nsphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*5))**2 < 0.2**2\n\n# combine the color components\nhsv = np.zeros(sphere.shape + (3,))\nhsv[..., 0] = thetac \/ (np.pi*1)\nhsv[..., 1] = rc\nhsv[..., 2] = zc + 0.6\ncolors = matplotlib.colors.hsv_to_rgb(hsv)\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(5*colors - 0.6, 0, 1),  # brighter\n          linewidth=0.5)\n\nplt.show()","3883fffc":"# Circular 3D surface","f26705e8":"# If you like this notebook, please give an Upvote! Don't forget to check out my other notebooks too!\n\n* [ConnectX Baseline](https:\/\/www.kaggle.com\/brendan45774\/connectx-baseline)\n* [Countries Life Expectancy Animation](https:\/\/www.kaggle.com\/brendan45774\/countries-life-expectancy-animation)\n* [Data Visuals - Matplotlib](http:\/\/www.kaggle.com\/brendan45774\/data-visuals-matplotlib)\n* [Digit Recognizer Solution](http:\/\/www.kaggle.com\/brendan45774\/digit-recognizer-solution)\n* [Dictionary and Pandas Cheat sheet](https:\/\/www.kaggle.com\/brendan45774\/dictionary-and-pandas-cheat-sheet)\n* [EDA Tutorial Hollywood Movies](https:\/\/www.kaggle.com\/brendan45774\/eda-tutorial-hollywood-movies)\n* [Getting Started with Manifold Learning - Isomap](https:\/\/www.kaggle.com\/brendan45774\/getting-started-with-manifold-learning-isomap)\n* [Getting started with Matplotlib](http:\/\/www.kaggle.com\/brendan45774\/getting-started-with-matplotlib)\n* [Guide to Matplotlib Image](https:\/\/www.kaggle.com\/brendan45774\/guide-to-matplotlib-image)\n* [HOG features - Histogram of Oriented Gradients](https:\/\/www.kaggle.com\/brendan45774\/hog-features-histogram-of-oriented-gradients)\n* [How to get the lowest score](https:\/\/www.kaggle.com\/brendan45774\/how-to-get-the-lowest-score)\n* [House predict solution](http:\/\/www.kaggle.com\/brendan45774\/house-predict-solution)\n* [K-Means Clustering (Image Compression)](https:\/\/www.kaggle.com\/brendan45774\/k-means-clustering-image-compression)\n* [Kuzushiji-MNIST Panda](http:\/\/www.kaggle.com\/brendan45774\/kuzushiji-mnist-panda)\n* [Plotly Coronavirus (Covid-19)](https:\/\/www.kaggle.com\/brendan45774\/plotly-coronavirus-covid-19)\n* [Titanic Top Solution](http:\/\/www.kaggle.com\/brendan45774\/titanic-top-solution)\n* [Titanic Data Solution](http:\/\/www.kaggle.com\/brendan45774\/titanic-data-solution)\n* [Topic Modeling (LDA)](https:\/\/www.kaggle.com\/brendan45774\/topic-modeling-lda)\n* [Wine quality - Regression prediction](https:\/\/www.kaggle.com\/brendan45774\/wine-quality-regression-prediction)\n* [Word Cloud - Analyzing Names](https:\/\/www.kaggle.com\/brendan45774\/word-cloud-analyzing-names)","a6e3a918":"# Scatter plot on polar axis\nSize increases radially in this example and color increases with angle.","f819751e":"Frontpage 2D ","0b97082f":"Polar Coordinates","a09d5e24":"# 3d voxel\/ volumetric plot","db435a56":"Sets a Triangulation object's mask and passes the object directly to plot_trisurf","99b879ab":"Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. It is used along with NumPy to provide an environment that is an effective open source alternative for MatLab. It can also be used with graphics toolkits like PyQt and wxPython.","a2e4da52":"# Matplotlib is Fun!","50c4f22f":"# Ellipse Demo\nThis draws many ellipses by a random state","2ec727bf":"# Reference for Matplotlib artists\nThis example displays several of Matplotlib's graphics primitives (artists) drawn using matplotlib API. A full list of artists and the documentation is available at the artist API.","2a0c488b":"Creates a dolphins image","6c887f5a":"# Importing Libraries","1da40171":"# Matplotlib: Python Ploting","8656a031":"# Frontpage 3D","83b33dac":"# Colored Spiral","33a90d22":"# 3D stem\nDemonstration of a stem plot in 3D, which plots vertical lines from a baseline to the z-coordinate and places a marker at the tip.","8f8c5dfa":"# Triangular 3D Surfaces","81691280":"Solid color","1f7486e0":"Plot a triangular mesh that is 3D surface ","b9b51634":"Scatter plot on polar axis, with offset origin.\n\nThe main difference with the previous plot is the configuration of the origin radius, producing an annulus. Additionally, the theta zero location is set to rotate the plot.","9da7d6ab":"Shows the use of plot_trisurf's triangles argument","f22bb3bb":"Scatter plot on polar axis confined to a sector.\n\nThe main difference with the previous plots is the configuration of the theta start and end limits, producing a sector instead of a full circle.","1c704967":"# BboxImage\nA BboxImage can be used to position an image according to a bounding box. This demo shows how to show an image inside a text.Text's bounding box as well as how to manually create a bounding box for the image."}}