{"cell_type":{"f4d2ec09":"code","3e58b529":"code","200c938b":"code","ad126598":"code","ed19c122":"code","6356e848":"code","3389c092":"code","e68839de":"code","0b86bd6e":"code","e778ee01":"code","bac18116":"code","008c67fa":"code","65c40a40":"code","03d6be69":"code","16c7f389":"code","11584fac":"code","dc403388":"code","f3b8dfc7":"code","cbb85310":"markdown","1e1a361a":"markdown","442fa792":"markdown","fbfe9aa6":"markdown","0d9c8ed5":"markdown","aa6195d4":"markdown","4ed99c15":"markdown","85263f30":"markdown","6aae5737":"markdown","b0a22f98":"markdown","731cc86d":"markdown","c2309da4":"markdown"},"source":{"f4d2ec09":"!apt-get update -qq && apt-get install -qq libfluidsynth1 fluid-soundfont-gm build-essential libasound2-dev libjack-dev\n!pip install -q pyfluidsynth\n\n!pip install pretty_midi\n!pip install python-bitvavo-api","3e58b529":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\nfrom datetime import datetime\n\n# midi \nimport pretty_midi\nfrom pretty_midi import Note, Instrument\nfrom IPython.display import Audio\n\n# kaggle\nfrom kaggle_secrets import UserSecretsClient\n\n# crypto API\nfrom python_bitvavo_api.bitvavo import Bitvavo\n\n# sklearn\nfrom sklearn.preprocessing import MinMaxScaler\n\n# scipy\nfrom scipy.interpolate import interp1d\nfrom scipy.misc import derivative\nfrom scipy import optimize","200c938b":"def get_crossings(f, g, fs=500):\n    '''\n    get intersection between two functions, see https:\/\/scipy-user.scipy.narkive.com\/nXYSoaq9\/how-to-find-the-intersections-between-two-lines\n    '''\n    \n    # create intervals\n    xx = np.linspace(np.min(f.x),np.max(f.x), fs)\n\n    # subtract functions\n    gg = [(s, f(s)-g(s)) for s in xx]\n    h = np.array([(i,k,l) for i, (k,l) in enumerate(gg)])\n    output = []\n    \n    for i,j in enumerate(h[:-1]):\n        # check for zero crossings of f(x)-g(x)\n        if (h[i][2] > 0 and h[i+1][2] < 0) or (h[i][2] < 0 and h[i+1][2] > 0):\n            output.append(optimize.brentq(lambda x: f(x)-g(x), h[i][1], h[i+1][1]))\n    return output\n\n\ndef get_thresholds(v=100, percentage=10, max_thresholds=100, min_value=0, max_value=200):\n    ''' return a list of values that are a certain percentage above or below reference value v and are between min_value and max_value\n\n    >>> get_thresholds(100, percentage=10, max_thresholds=100, min_value=0, max_value=200)\n    >>> [100.0, 90.0, 81.0, 110.0, 121.0]\n    '''\n    \n    btl = []\n    atl = []\n    for i in np.arange(max_thresholds \/\/ 2 + 1):\n        threshold_btl = np.round(v * (1 - percentage\/100)**i, 2)\n        threshold_atl = np.round(v * (1 + percentage\/100)**i, 2)\n        \n        if (threshold_btl >= min_value) & (threshold_btl <= max_value):\n            btl.append(threshold_btl)\n        \n        if (threshold_atl >= min_value) & (threshold_atl <= max_value):\n            atl.append(threshold_atl)\n            \n    return btl + atl[1:]\n\n\ndef threshold_crossing(f, thresholds):\n    '''\n    return dataframe with x, y coordinates of the crossings between functions f(x) and g(x)=threshold\n    '''\n    output = []\n    \n    # loop through thresholds\n    for i, threshold in enumerate(thresholds):\n        \n        # create anonymous function g(x) = threshold\n        g = (lambda x: x-x+threshold)\n        \n        # calculate crossing between f and g\n        x_crossings = get_crossings(f, g)\n        \n        # add x, y values to output\n        for x_crossing in x_crossings:\n            output.append({'x': x_crossing, 'y': threshold})\n\n    if len(output) == 0:\n        return\n    \n    # make dataframe\n    df_crossings_all = pd.DataFrame(output).sort_values('x')\n\n    # filter crossings to get remove multiple subsequent crossings through the same threshold\n    cond_crossing = (df_crossings_all['y'] != df_crossings_all['y'].shift(1))\n    df_crossings = df_crossings_all[cond_crossing].sort_values('x')\n    return df_crossings[['x', 'y']]\n\n\ndef scale_to_range(X, range_min=0, range_max=1):\n    scaler = MinMaxScaler()\n    X_scaled = scaler.fit_transform(X.reshape(-1, 1)) * (range_max - range_min) + range_min\n    return X_scaled.reshape(X.shape)\n\n\ndef map_range(value, leftMin, leftMax, rightMin, rightMax):\n    # Figure out how 'wide' each range is\n    leftSpan = leftMax - leftMin\n    rightSpan = rightMax - rightMin\n\n    # Convert the left range into a 0-1 range (float)\n    valueScaled = float(value - leftMin) \/ float(leftSpan)\n\n    # Convert the 0-1 range into a value in the right range.\n    return rightMin + (valueScaled * rightSpan)\n\n\ndef to_scale(intervals, scale='chromatic', base_pitch=60):\n    scales = {}\n    scales['chromatic'] = np.arange(21, 109)\n    scales['c-minor'] = np.array([n for n in np.arange(21, 109) if (n-21) % 12 in [3, 5, 6, 8, 10, 11, 1]])\n    scales['c-major'] = np.array([n for n in np.arange(21, 109) if (n-21) % 12 in [3, 5, 7, 8, 10, 0, 2]])\n\n    selected_scale = scales[scale]\n    \n    # make sure base pitch is available in the scale\n    assert base_pitch in selected_scale, f\"base_pitch: {base_pitch} ({pretty_midi.note_number_to_name(base_pitch)}) not in scale '{scale}'\"\n    \n    # get the index of the base_pitch\n    base_pitch_idx = np.where(selected_scale==base_pitch)[0][0]\n    \n    # calculate pitch scales using the intervals\n    scale_pitch_idxs = np.cumsum(intervals) + base_pitch_idx\n    return selected_scale[scale_pitch_idxs]\n\n\ndef notes_to_midi(notes, program=0):\n    # create midi object\n    midi_data = pretty_midi.PrettyMIDI()\n\n    # create instrument\n    instrument = pretty_midi.Instrument(program=program)\n\n    for note in notes:\n        instrument.notes.append(note)\n\n    # add instrument to midi data\n    midi_data.instruments.append(instrument)\n    \n    return midi_data\n\n\ndef get_midi_notes(df_crossings, scale='chromatic', velocity=120, duration=0.1):\n    notes = []\n    for i, (start, pitch) in enumerate(zip(df_crossings['start'], df_crossings[scale])):\n        notes.append(pretty_midi.Note(velocity=velocity, pitch=pitch, start=start, end=start + duration))\n    return notes","ad126598":"pd.set_option('display.max_rows', 500)\npd.set_option('display.max_columns', 500)\npd.set_option('display.width', 1000)","ed19c122":"# bitvavo api settings\nuser_secrets = UserSecretsClient()\n\nbitvavo = Bitvavo({\n  'APIKEY': user_secrets.get_secret(\"bitvavo-api-key-read-only\"),\n  'APISECRET': user_secrets.get_secret(\"bitvavo-secret-key-read-only\"),\n  'RESTURL': 'https:\/\/api.bitvavo.com\/v2',\n  'WSURL': 'wss:\/\/ws.bitvavo.com\/v2\/',\n  'ACCESSWINDOW': 10000,\n  'DEBUGGING': False\n})","6356e848":"symbol = 'ADA-EUR'\ninterval = '1h'\n\nresponse = bitvavo.candles(symbol, interval, {})\ndf = pd.DataFrame(data=np.array(response), columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\nprint(\"nr records:\", len(df))\ndf.head()","3389c092":"# fix dtypes\ndf['timestamp'] = df['timestamp'].astype('int')\ndf['open'] = df['open'].astype('float')\ndf['close'] = df['close'].astype('float')\ndf['high'] = df['high'].astype('float')\ndf['low'] = df['low'].astype('float')\ndf['volume'] = df['volume'].astype('float')\n\n# sort on timestamp\ndf.sort_values('timestamp', ascending=True, inplace=True)\n\n# moving average for close prices\ndf['close_moving_avg'] = df['close'].rolling(center=True, window=3).mean()\n\n# convert timestamp to datetime\ndf['datetime'] = pd.to_datetime(df['timestamp'].apply(lambda x: datetime.fromtimestamp(x \/ 1000).isoformat()))\ndf.set_index('datetime', inplace=True)\n\ndisplay(df.head())\ndisplay(df.info())","e68839de":"start_date = datetime(2021, 5, 1)","0b86bd6e":"df_slice = df[df.index > start_date]\nprint(\"nr records:\", len(df_slice))\ndf_slice.head()","e778ee01":"# create interpolation function\nfeature = 'close_moving_avg'","bac18116":"yy = df_slice[feature].dropna()\nxx = np.arange(len(yy))\nf = interp1d(xx, yy, kind='cubic', fill_value=\"extrapolate\")","008c67fa":"# percentage used to determine threshold levels relative to a reference price\npercentage = 3","65c40a40":"# use first price value as reference\nreference_value = df_slice['close_moving_avg'].values[0]\n\n# use min- and max prices as boundary for the thresholds\nmin_value = np.min(df_slice['close_moving_avg'])\nmax_value = np.max(df_slice['close_moving_avg'])\n\n# get the thresholds for the reference price\nthresholds = get_thresholds(v=reference_value, percentage=percentage, min_value=min_value, max_value=max_value)\n\nprint(f\"reference value: {reference_value:.2}\")\nprint(f\"threshold range: {min_value:.2}-{max_value:.2}\")\n\n# get all crossings between the interpolated price (f) and changes of +\/- 10% from the first price value\ndf_crossings = threshold_crossing(f, thresholds)\ndf_crossings.head()","03d6be69":"# duration of generated melody in seconds\nmelody_duration = 10\n\n# base pitch for first note, all subsequent notes are relative to this note\nbase_pitch = 60","16c7f389":"df_crossings['start'] = df_crossings.x.apply(lambda x: map_range(x, df_crossings.x.min(), df_crossings.x.max(), 0, melody_duration))\n\n# use threshold crossings, to change the pitch with 1 step\ndf_crossings['pitch_change'] = 0\ndf_crossings.loc[(df_crossings['y'].diff(1) > 0), 'pitch_change'] = 1\ndf_crossings.loc[(df_crossings['y'].diff(1) < 0), 'pitch_change'] = -1\n\n# get pitches for different scales\nintervals = df_crossings['pitch_change'].values\ndf_crossings['chromatic'] = to_scale(intervals=intervals, scale='chromatic', base_pitch=base_pitch)\ndf_crossings['c-major'] = to_scale(intervals=intervals, scale='c-major', base_pitch=base_pitch)\ndf_crossings['c-minor'] = to_scale(intervals=intervals, scale='c-minor', base_pitch=base_pitch)\n\ndf_crossings.head()","11584fac":"# velocity for each note\nvelocity = 120\n\n# duration for each note\nduration = 0.15\n\n# instrument used in the midi file\nprogram = 0","dc403388":"midi_data_chromatic = notes_to_midi(get_midi_notes(df_crossings, scale='chromatic', velocity=velocity, duration=duration), program=program)\nmidi_data_major = notes_to_midi(get_midi_notes(df_crossings, scale='c-major', velocity=velocity, duration=duration), program=program)\nmidi_data_minor = notes_to_midi(get_midi_notes(df_crossings, scale='c-minor', velocity=velocity, duration=duration), program=program)","f3b8dfc7":"plt.figure(figsize=(20, 7))\nplt.title(f\"[{symbol} {interval}] - Crossings between interpolation and thresholds\")\nplt.plot(f.x, f(f.x), linewidth=1, color=\"k\", label=\"price\",  linestyle=\"-.\")\n\nfor i, threshold in enumerate(thresholds):\n    plt.gca().axhline(y=threshold, color=\"#dddddd\", linestyle=\"-.\", linewidth=0.7)\n\nplt.step(x=df_crossings['x'], y=df_crossings['y'], where=\"post\", marker=\"o\", markersize=8, color=\"mediumvioletred\")\n#plt.plot(df_crossings['x'], df_crossings['y'], marker=\"o\", markersize=20, linestyle=\"None\", color=\"k\", markerfacecolor='None', markeredgecolor=\"mediumvioletred\", markeredgewidth=1, label=f\"Change of {percentage}%\")\nticks = np.arange(0, len(df_slice), 24)\nlabels = [df_slice.iloc[tick].name.strftime(\"%d %B %Y\") for tick in ticks]\nplt.xticks(ticks=ticks, labels=labels, rotation=45)\n\nplt.gca().legend(loc='upper left')\nplt.ylim(1, 2)\nplt.xlabel(\"Date\")\nplt.ylabel(\"Close (EUR)\")\nplt.show()\n\ndisplay(df_crossings.head())\n\nprint(\"chromatic scale\")\nwaveform = midi_data_chromatic.fluidsynth()\ndisplay(Audio(waveform, rate=44100))\n\nprint(\"major scale\")\nwaveform = midi_data_major.fluidsynth()\ndisplay(Audio(waveform, rate=44100))\n\nprint(\"minor scale\")\nwaveform = midi_data_minor.fluidsynth()\ndisplay(Audio(waveform, rate=44100))","cbb85310":"### 2. Preprocessing","1e1a361a":"### Functions","442fa792":"### 5. Get threshold crossings\n\nWe let both pitch and timing of the notes depend on whether the price crosses a certain percentage level.\n\nIf the reference price is 1 EUR, and the percentage threshold is 3%, the next note will be played if the price changed with more than 3%.","fbfe9aa6":"#### Plot notes and play audio","0d9c8ed5":"### 4. Fit an interpolation function","aa6195d4":"### Create midi","4ed99c15":"### Settings","85263f30":"### 3. Select time period","6aae5737":"### 1. Get exchange data from API","b0a22f98":"### Generate pitches for different scales\n\n* each price-level crossing increases or decreases the relative pitch with 1\n* lets pitck notes from different scales: `chromatic` , `major` and `minor`","731cc86d":"### Imports","c2309da4":"### Install dependencies"}}