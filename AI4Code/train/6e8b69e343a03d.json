{"cell_type":{"922e4624":"code","2aa8cc46":"code","f0d2e814":"code","2859d90f":"code","7424dfea":"code","91b800a1":"code","99a098cf":"code","561df5a3":"code","cc782116":"code","3fc82dc4":"code","9a731194":"markdown","362f52ab":"markdown","6c94344a":"markdown"},"source":{"922e4624":"import numpy as np\nimport pandas as pd\nimport os\nimport json\n\nimport matplotlib.pyplot as plt\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport torch.autograd as autograd\n\nimport torchvision.transforms as transforms\nimport torchvision.datasets as datasets\nimport torchvision.models as models\n\nfrom PIL import Image\nprint(os.listdir(\"..\/input\"))","2aa8cc46":"train_on_gpu = torch.cuda.is_available()\nif not train_on_gpu:\n    print('CUDA is not available.  Training on CPU ...')\nelse:\n    print('CUDA is available!  Training on GPU ...')\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")","f0d2e814":"class ImageFolderWithPaths(datasets.ImageFolder):\n    \"\"\"Custom dataset that includes image file paths. Extends\n    torchvision.datasets.ImageFolder\n    \"\"\"\n    # override the __getitem__ method. this is the method dataloader calls\n    def __getitem__(self, index):\n        # this is what ImageFolder normally returns \n        original_tuple = super(ImageFolderWithPaths, self).__getitem__(index)\n        # the image file path\n        path = self.imgs[index][0]\n        # make a new tuple that includes original and the path\n        tuple_with_path = (original_tuple + (path,))\n        return tuple_with_path","2859d90f":"batch_size = 20\nn_workers = 0\ndata_dir = '..\/input\/oxford-102-flower-pytorch\/flower_data\/flower_data\/'\nwith open(data_dir + '\/cat_to_name.json', 'r') as f:\n    cat_to_name = json.load(f)\n\ntest_transforms = transforms.Compose([\n    transforms.Resize(255),\n    transforms.CenterCrop(224),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])])\n\n# Load the datasets with ImageFolder\nvalid_dataset = datasets.ImageFolder(root = data_dir + '\/valid', transform = test_transforms)\nvalid_loader = torch.utils.data.DataLoader(valid_dataset, batch_size = batch_size, shuffle = True, num_workers = n_workers)\n\ntest_folder = '..\/input\/test-flowers\/test_data\/test_data\/test'\ntest_dataset = ImageFolderWithPaths(root = test_folder, transform = test_transforms)\ntest_loader = torch.utils.data.DataLoader(test_dataset, batch_size = 1, shuffle = True, num_workers = n_workers)\n\n# Print the statistics:\nprint(\"Datasets Load has finished:\")\nprint(\"\\tNumber of validation images:{}\".format(len(valid_dataset)))\nprint(\"\\tNumber of test images:{}\".format(len(test_dataset)))","7424dfea":"class Classifier(nn.Module):\n    def __init__(self, n_input, n_hidden1, n_hidden2, n_output):\n        super().__init__()\n        self.fc1 = nn.Linear(n_input, n_hidden1)\n        self.fc2 = nn.Linear(n_hidden1, n_hidden2)\n        self.fc3 = nn.Linear(n_hidden2, n_output)\n        self.dropout = nn.Dropout(p = 0.3)\n        \n    def forward(self, x):\n        # make sure input tensor is flattened\n        x = x.view(x.shape[0], -1)\n        x = self.dropout(F.relu(self.fc1(x))) \n        x = self.dropout(F.relu(self.fc2(x)))     \n        x = F.log_softmax(self.fc3(x), dim=1)        \n        return x","91b800a1":"checkpoint_path = '..\/input\/additional-training\/checkpoint_105.pth'\ncheckpoint = torch.load(checkpoint_path)\nmodel = models.densenet121(pretrained=True)\nfor param in model.parameters():\n    param.requires_grad = False\n    \n# Put the classifier on the pretrained network\nn_inputs = model.classifier.in_features\nlast_layer = Classifier(n_inputs, 512, 256, len(cat_to_name))\nmodel.classifier = last_layer\n\npretrained_dict = checkpoint['state_dict']\nmodel_dict = model.state_dict()\npretrained_dict = {k: v for k, v in pretrained_dict.items() if k in model_dict}\nmodel_dict.update(pretrained_dict) \nmodel.load_state_dict(pretrained_dict)\nmodel.to(device);","99a098cf":"# Check again on validation set to see that we didn't \"destroy\" the model:\ncriterion = nn.NLLLoss()\nvalid_loss, accuracy  = 0, 0\nmodel.eval()\nwith torch.no_grad():\n    for inputs, labels in valid_loader:\n        inputs, labels = inputs.to(device), labels.to(device)\n        logps = model.forward(inputs)\n        batch_loss = criterion(logps, labels)                    \n        valid_loss += batch_loss.item()\n\n        # Calculate accuracy\n        ps = torch.exp(logps)\n        top_p, top_class = ps.topk(1, dim=1)\n        equals = top_class == labels.view(*top_class.shape)\n        accuracy += torch.mean(equals.type(torch.FloatTensor)).item()\n\nprint(f\"Validation loss: {valid_loss\/len(valid_loader):.3f}.. \"\n      f\"Validation accuracy: {accuracy\/len(valid_loader):.3f}\")","561df5a3":"predictions = {}\nidx_to_class = {v: k for k, v in valid_dataset.class_to_idx.items()}\nwith torch.no_grad():\n    for image, label, filename in test_loader:\n        image, label = image.to(device), label.to(device)\n        logps = model.forward(image)\n        ps = torch.exp(logps)\n        \n        top_p, top_class = ps.topk(1, dim=1)\n        class_pred = top_class.data.cpu().numpy()[0]        \n        filename = filename[0].split('\/')[-1]\n        predictions[filename] = idx_to_class[class_pred.tolist()[0]]","cc782116":"sub = pd.DataFrame.from_dict(predictions, orient='index')\nsub.index.names = ['file_name']\nsub.columns = ['id']\nsub.to_csv('submission_01.csv')","3fc82dc4":"\"\"\"\ndef image_loader(image_name):\n    #load image, returns cuda tensor\n    image = Image.open(image_name)\n    image = test_transforms(image)#.float()\n    #image = autograd.Variable(image, requires_grad=True)\n    image = image.unsqueeze(0)  #this is for VGG, may not be needed for ResNet\n    return image.to(device)  #assumes that you're using GPU\n    \n# Define Path for Test Images:\ntest_dir = '..\/input\/oxford-102-flower-pytorch\/flower_data\/flower_data\/test\/'\npredictions = {}\nfilenames = next(os.walk(test_dir))[2]\nfor filename in filenames:\n    image = image_loader(test_dir + \"\/\" + filename)\n    pred = model(image)\n    ps = torch.exp(pred)\n    top_p, top_class = ps.topk(1, dim=1)\n    class_pred = top_class.data.cpu().numpy()[0]\n    predictions[filename] = class_pred\n\"\"\"","9a731194":"# Get Predictions on Test Set and Wirte to CSV:","362f52ab":"# Check Model Performance on Validation Set:","6c94344a":"# Reconstruct the Model from Checkpoint:"}}