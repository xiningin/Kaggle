{"cell_type":{"c8a1a667":"code","7c28ff19":"code","a8c58209":"code","61b09e05":"code","9ebe0d42":"markdown","012945f5":"markdown","fdaaa1f1":"markdown","f9a411b0":"markdown"},"source":{"c8a1a667":"import numpy as np\nimport pandas as pd\nimport os\nfrom concorde.tsp import TSPSolver\n#from sympy import primerange\n\npd.options.mode.chained_assignment = None  # default='warn'\n\n# find cities that are prime numbers\ndef sieve_of_eratosthenes(n):\n    n = int(n)\n    primes = [True for i in range(n+1)] # Start assuming all numbers are primes\n    primes[0] = False # 0 is not a prime\n    primes[1] = False # 1 is not a prime\n    for i in range(2,int(np.sqrt(n)) + 1):\n        if primes[i]:\n            k = 2\n            while i*k <= n:\n                primes[i*k] = False\n                k += 1\n    return(primes)\n\nsanta_cities = pd.read_csv('..\/input\/cities.csv')\nprimes_cities = sieve_of_eratosthenes(max(santa_cities.CityId))\nsanta_cities.head()","7c28ff19":"# calculate total distance of the path\ndef total_distance(dfcity,path):\n    prev_city = path[0]\n    total_distance = 0\n    step_num = 1\n    for city_num in path[1:]:\n        next_city = city_num\n        total_distance = total_distance + \\\n            np.sqrt(pow((dfcity.X[city_num] - dfcity.X[prev_city]),2) + pow((dfcity.Y[city_num] - dfcity.Y[prev_city]),2)) * \\\n            (1+ 0.1*((step_num % 10 == 0)*int(not(prime_cities[prev_city]))))\n        prev_city = next_city\n        step_num = step_num + 1\n    return total_distance\n\n# run Concorder TSP Solver to calculate the best path\ndef concorde_tsp(cities, seed=42):\n    solver = TSPSolver.from_data(cities.X, cities.Y, norm=\"EUC_2D\")\n    tour_data = solver.solve(time_bound=60.0, verbose=True, random_seed=seed)\n    if tour_data.found_tour:\n        path = np.append(tour_data.tour,[0])\n        return path\n    else:\n        return None\n\nbest_path = concorde_tsp(santa_cities)\nprint(\"Total concorde distance is {:,}\".format(total_distance(santa_cities,best_path)))","a8c58209":"def score_path(tour):\n    # length of any given tour with primes calculation\n    df = santa_cities.reindex(tour + [0]).reset_index()\n    # mark which cities are prime\n    df['prime'] = df.CityId.isin(primes_cities).astype(int)\n    # calculate the euclidean norm\n    df['dist'] = np.hypot(df.X - df.X.shift(-1), df.Y - df.Y.shift(-1))\n    df['penalty'] = df['dist'][9::10] * (1 - df['prime'][9::10]) * 0.1\n    return df.dist.sum() + df.penalty.sum()\n\n# Let's take a look at our tour\nprint(\"Existing path (0-5):\",best_path[0:5])\n# And the flipped tour looks like:\npath_flip = best_path[::-1]\nprint(\"Flipped path (0-5):\", path_flip[0:5])\n# The scores of our tours are:\nprint(\"Score of original tour:\", score_path(best_path))\nprint(\"Score of flipped tour:\", score_path(path_flip))\n\n# If the flipped tour is quicker, change our tour:\nif score_path(path_flip) < score_path(best_path):\n    print(\"The total improvement was:\", abs(score_path(path_flip) - score_path(best_path)))\n    best_path = path_flip \n    print(\"The better of the original\/flipped tour is:\", best_path[0:5])","61b09e05":"pd.DataFrame({'Path':best_path}).to_csv('santa-path.csv',index = False)","9ebe0d42":"Generate the output file for submission to the competition.","012945f5":"The core code below came from [Matthew Anderson kernel called Flip It](https:\/\/www.kaggle.com\/matthewa313\/flip-it) that attempts to flip the entire path order to see if it helps the prime penalty lessen.","fdaaa1f1":"The \"Corcorde traveling salesman problem\" solver is doing much better than other base methods as [XYZT points out in his TSP Solver kernel](https:\/\/www.kaggle.com\/thexyzt\/xyzt-s-visualizations-and-various-tsp-solvers). In this kernel I'd like to explore the Concorde TSP solver mixed with a path flip approach to optimize for the prime portion of this competition as [Matthew Anderson explores in his Flip It kernel](https:\/\/www.kaggle.com\/matthewa313\/flip-it).\n\n**NOTE:** in order for this to work you'll need to import the \"jvkersch\/pyconcorde\" GitHub repo using the option in the notebook editor called \"Packages\". This GibHub package is a Python wrapper around the original C code written as the \"Concorde TSP Solver\". If you want to learn more, check out the [Concorder TSP Solver page](http:\/\/www.math.uwaterloo.ca\/tsp\/concorde.html) on the University of Waterloo website.","f9a411b0":"The core code of the Concorde \"traveling salesman problem\" solver below came from [XYZT's kernel](https:\/\/www.kaggle.com\/thexyzt\/xyzt-s-visualizations-and-various-tsp-solvers). If you want to learn more, check out the [Concorder TSP Solver page](http:\/\/www.math.uwaterloo.ca\/tsp\/concorde.html) on the University of Waterloo website."}}