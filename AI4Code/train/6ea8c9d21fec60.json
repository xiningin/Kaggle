{"cell_type":{"e1d20b5a":"code","2b6341ca":"code","6d7c2d98":"code","8cdda3c2":"code","eb74ff64":"code","8dba9ee2":"code","0e7fded1":"code","69728702":"code","a5bcbce3":"code","2a15a44f":"code","f6912c16":"code","1c2efb1b":"code","bcedc644":"code","b51e8777":"code","e660a226":"code","13b7939d":"code","09f6b438":"code","f72b7a44":"code","a26e46db":"code","7cf3484d":"code","73a1fdbd":"code","aab8ab67":"code","15796e2d":"code","0cab174e":"code","c789b515":"code","6bfc9fca":"code","57a07013":"code","212cfa43":"code","58f5c8f2":"code","d6d7b02a":"code","4f48296e":"code","2d4665dc":"code","c435e1c0":"code","a0739db1":"code","9b834d5e":"code","a039e04e":"code","376bbc8f":"code","2e018c2d":"code","f9c3be7a":"code","7c0aa716":"code","0d44e715":"code","a0e9aa32":"code","e2a5b454":"code","2b082a43":"code","a92a74ec":"code","65961b2f":"code","e5e01991":"code","4678e212":"code","36aeacc2":"code","7e454ebb":"code","091a854e":"code","2e3df309":"code","988d0fec":"code","e0862c87":"code","38c4755c":"code","8ee471bb":"code","505a4aec":"code","9d950823":"code","9425b496":"code","691c08bd":"code","7745faf6":"code","8f3f618e":"code","b7cfa307":"code","72b41ef1":"code","829c7fa9":"code","f0ea3f9b":"code","4f5766e4":"code","0d0e9c7a":"code","84f02df8":"code","c18b78c9":"markdown","0c84b2d0":"markdown","22f4bb98":"markdown","2a159aea":"markdown","1ff84bdb":"markdown","ea76ee52":"markdown","84643e8a":"markdown"},"source":{"e1d20b5a":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn')\n\nimport tensorflow as tf\nimport cv2\nimport os\nimport glob\nimport keras\nfrom tensorflow.keras.preprocessing import image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.models import Sequential,Model\nfrom tensorflow.keras.layers import Dense,Activation,GlobalAveragePooling2D,Dropout,Flatten,Conv2D,MaxPooling2D\nfrom keras.layers import BatchNormalization\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nimport tensorflow\ntf.random.set_seed(40)","2b6341ca":"# train_path = \"..\/input\/covid-data\/train\/train\"\ntrain_path = '..\/input\/isic2016\/ISBI2016_ISIC_Part3_Training_Data'\ntest_path = \"..\/input\/covid-data\/test\/test-2\"\nSIZE =224","6d7c2d98":"train_images = []\ntrain_ids =[]\n\nfor i in glob.glob( f\"{train_path}\/*\"):\n    ids = i.split(\".\")[-2].split('\/')[-1]\n    for j in glob.glob(os.path.join(i)):\n        img = cv2.imread(j,cv2.IMREAD_COLOR)\n        img = cv2.resize(img,(SIZE,SIZE))\n        img = cv2.cvtColor(img,cv2.COLOR_RGB2BGR)\n        train_images.append(img)\n        train_ids.append(ids)\n        \ntrain_images = np.array(train_images)\ntrain_ids = np.array(train_ids)","8cdda3c2":"train_ids.shape","eb74ff64":"df_train = pd.read_csv('..\/input\/isic2016\/ISBI2016_ISIC_Part3_Training_GroundTruth.csv')","8dba9ee2":"adddi = 'ISIC_0000000'\nadddl     =  'benign'","0e7fded1":"df_train.columns = ['id','label']","69728702":"df_train.loc[899,'id'] = adddi\ndf_train.loc[899,'label'] = adddl","a5bcbce3":"df_train = df_train[df_train['id'].isin(list(train_ids))]","2a15a44f":"from sklearn.preprocessing import LabelEncoder","f6912c16":"le = LabelEncoder()\ndf_train['label'] = le.fit_transform(df_train['label'])","1c2efb1b":"train_labels = []\nfor i in range(0,len(df_train)):\n    train_labels.append(int(df_train[df_train['id']==train_ids[i]].label))","bcedc644":"# test_images = []\n# test_labels =[]\n# for i in glob.glob( f\"{test_path}\/*\"):\n#     label = i.split(\"\\\\\")[-1]\n#     for j  in glob.glob(os.path.join(i,\"*.png\")):\n#         img = cv2.imread(j,cv2.IMREAD_COLOR)\n#         img = cv2.resize(img,(SIZE,SIZE))\n#         img = cv2.cvtColor(img,cv2.COLOR_RGB2BGR)\n#         test_images.append(img)\n#         test_labels.append(label)\n# test_images = np.array(test_images)\n# test_labels = np.array(test_labels)","b51e8777":"from tensorflow.keras.applications.resnet50 import ResNet50\nconv_base = ResNet50(weights='imagenet',include_top =False,\n                  input_shape=(SIZE,SIZE,3))","e660a226":"for layer in conv_base.layers:\n  layer.trainable =False\nconv_base.summary()","13b7939d":"feature_map_model = Model(inputs=conv_base.input, outputs=conv_base.get_layer('conv5_block3_out').output)","09f6b438":"train_features = feature_map_model.predict(train_images[:100])\n# test_features = feature_map_model.predict(test_images)\nprint(np.max(train_features))\nprint(train_features.mean())\n# print(np.max(test_features))\n# print(test_features.mean())\nprint(train_features.std())\n# print(test_features.std())","f72b7a44":"train_features.shape","a26e46db":"np.save('train_feats.npy',train_features)","7cf3484d":"# np.save('test_feats.npy',test_features)","73a1fdbd":"# print(train_features.resize(3201,100352))\n# print(test_features.resize(1147,100352))\n# # from sklearn.preprocessing import RobustScaler\n# # scaler = RobustScaler()\n# # # # transform data\n# # train_features_scaled = scaler.fit_transform(train_features)\n# # test_features_scaled = scaler.transform(test_features)\n\n# from sklearn.preprocessing import StandardScaler\n# scaler = StandardScaler()\n# # # # transform data\n# train_features_scaled = scaler.fit_transform(train_features)\n# test_features_scaled = scaler.transform(test_features)\n\n\n\n# print(train_features_scaled.mean())\n# print(test_features_scaled.mean())\n\n\n","aab8ab67":"# from sklearn import preprocessing\n# le = preprocessing.LabelEncoder()\n# le.fit(test_labels)\ntest_labels_encoded = (test_labels)\n# le.fit(train_labels)\ntrain_labels_encoded = (train_labels)","15796e2d":"\n\n# x= tf.keras.layers.Flatten(input_shape=(7,7,2048))\n\n\n# x1 =tf.keras.layers.Dense(2048)(x)\n# x1_ =tf.keras.layers.Activation('relu')(x1)\n# x1__ =tf.keras.layers.Dropout(0.3)(x1_)\n\n# x2 =tf.keras.layers.Dense(1024)(x1__)\n# x2_ =tf.keras.layers.Activation('relu')(x2)\n# x2__ =tf.keras.layers.Dropout(0.3)(x2_)\n\n# x3= tf.keras.layers.Add([x2__,x1])\n\n\n# x4 =tf.keras.layers.Dense(256)(x3)\n# x4_ =tf.keras.layers.Activation('relu')(x4)\n# x4__ =tf.keras.layers.Dropout(0.3)(x4_)\n\n\n# x5 =tf.keras.layers.Dense(128)(x4__)\n# x5_ =tf.keras.layers.Activation('relu')(x5)\n# x5__ =tf.keras.layers.Dropout(0.3)(x5_)\n\n# x6= tf.keras.layers.Add([x5__,x4])\n\n\n\n\n# x7 =  tf.keras.layers.Dense(64)\n# x7_ = tf.keras.layers.Activation('relu')(x6)\n# x7__=tf.keras.layers.Dropout(0.3)(x7_)\n\n\n\n\n# x8= tf.keras.layers.Dense(1)(x7__)\n# x8_ tf.keras.layers.Activation('sigmoid')(x8)\n# tf.keras.summary()(x8_)","0cab174e":"from sklearn.utils.class_weight import compute_class_weight\nweights = compute_class_weight('balanced', np.unique(train_labels_encoded),train_labels_encoded)\ncw = dict(zip( np.unique(train_labels_encoded), weights))\nprint(cw)","c789b515":"train_features.shape","6bfc9fca":"from sklearn.model_selection import RandomizedSearchCV\n# Number of trees in random forest\nn_estimators = [int(x) for x in np.linspace(start = 200, stop = 2000, num = 10)]\n# Number of features to consider at every split\nmax_features = ['auto', 'sqrt']\n# Maximum number of levels in tree\nmax_depth = [int(x) for x in np.linspace(10, 110, num = 11)]\nmax_depth.append(None)\n# Minimum number of samples required to split a node\nmin_samples_split = [2, 5, 10]\n# Minimum number of samples required at each leaf node\nmin_samples_leaf = [1, 2, 4]\n# Method of selecting samples for training each tree\nbootstrap = [True, False]\n# Create the random grid\nrandom_grid = {'n_estimators': n_estimators,\n               'max_features': max_features,\n               'max_depth': max_depth,\n               'min_samples_split': min_samples_split,\n               'min_samples_leaf': min_samples_leaf,\n               'bootstrap': bootstrap}\nprint(random_grid,)","57a07013":"# from sklearn.ensemble import RandomForestClassifier\n\n# rf_random = RandomizedSearchCV(estimator = rf, param_distributions = random_grid, n_iter = 10, cv = 2, verbose=2, random_state=42, n_jobs = -1)\n# rf_random.fit(train_features.reshape(train_features.shape[0],-1), train_labels_encoded)\n# print(rf_random.best_params_)","212cfa43":"# from sklearn.ensemble import RandomForestClassifier\n\n# rf = RandomForestClassifier(n_estimators= 1000, min_samples_split= 10, min_samples_leaf= 1, max_features= 'auto', max_depth= 80, bootstrap= False)\n# rf.fit(train_features.reshape(train_features.shape[0],-1),train_labels_encoded)\n# pred_rf = rf.predict_proba(test_features.reshape(test_features.shape[0],-1))\n\n\n\n\n\n\n\n","58f5c8f2":"# # n= [x for x in np.linspace(0.1, 1, 0.05)] \n# # predictions_rf = pred_rf.copy()\n# # predictions_rf[predictions_rf] < n\n# # predictions_rf[predictions_rf] > n\n# # import decimal\n# # from sklearn.metrics import roc_curve, roc_auc_score\n# # from sklearn import metrics\n# # def float_range(start, stop , step):\n# #   while start < stop:\n# #     yield float(start)\n# #     start += decimal.Decimal(step)\n\n\n# # for x in list(float_range(0, 1, '0.005')):\n\n# predictions_rf = pred_rf[:,1].copy()\n# predictions_rf[predictions_rf <= 0.275] = 0\n# predictions_rf[predictions_rf > 0.275] = 1\n# # print(roc_auc_score(test_labels_encoded , predictions_rf),x) \n\n\n\n","d6d7b02a":"\n# from sklearn.metrics import classification_report,confusion_matrix\n# cm = pd.DataFrame(data=confusion_matrix(test_labels_encoded, predictions_rf, labels=[0, 1]),index=[\"Actual Covid\", \"Actual Normal\"],\n# columns=[\"Predicted Covid\", \"Predicted Normal\"])\n# import seaborn as sns\n# sns.heatmap(cm,annot=True,fmt=\"d\")\n","4f48296e":"# from sklearn.metrics import classification_report,confusion_matrix\n# print(classification_report(y_true=test_labels_encoded , y_pred=predictions_rf,target_names =['Covid','Normal']))\n# from sklearn import metrics\n# #print(metrics.accuracy_score(test_labels_encoded,predictions_rf))\n\n","2d4665dc":"# from sklearn.metrics import roc_curve, roc_auc_score\n# # roc curve for models\n# fpr2, tpr2, thresh2 = roc_curve(test_labels_encoded,pred_rf[:,1])\n# random_probs = [0 for i in range(len(test_labels_encoded))]\n# p_fpr, p_tpr, _ = roc_curve(test_labels_encoded, random_probs, pos_label=1)","c435e1c0":"#  #plot roc curves\n# plt.plot(fpr2, tpr2, marker='.',color='BLACK',label = \"Resnet50 + RANDOM_FOREST\")\n# plt.plot(p_fpr, p_tpr, linestyle='--', color='blue',label = \"No_skill\")\n# # title\n# plt.title('ROC curve')\n# # x label\n# plt.xlabel('False Positive Rate')\n# # y label\n# plt.ylabel('True Positive rate')\n\n# plt.legend(loc='best')\n# plt.savefig('ROC',dpi=300)\n# plt.show();","a0739db1":"auc = roc_auc_score(test_labels_encoded, pred_rf[:,1])\nprint('AUC of \"RESNET50 + RANDOM_FOREST\": %.3f' % auc)","9b834d5e":"import xgboost as xgb\nmodel = xgb.XGBClassifier()\nmodel.fit(train_features.reshape(train_features.shape[0],-1),train_labels_encoded)\npred_xgb = model.predict(test_features.reshape(test_features.shape[0],-1))\n\n\nfrom sklearn.metrics import classification_report,confusion_matrix\ncm = pd.DataFrame(data=confusion_matrix(test_labels_encoded, pred_xgb, labels=[0, 1]),index=[\"Actual Covid\", \"Actual Normal\"],\ncolumns=[\"Predicted Covid\", \"Predicted Normal\"])\nimport seaborn as sns\nsns.heatmap(cm,annot=True,fmt=\"d\")","a039e04e":"print(classification_report(y_true=test_labels_encoded , y_pred=pred_xgb,target_names =['Covid','Normal']))\n","376bbc8f":"from sklearn.metrics import roc_curve, roc_auc_score\n# roc curve for models\nfpr1, tpr1, thresh1 = roc_curve(test_labels_encoded,pred_xgb)\nrandom_probs = [0 for i in range(len(test_labels_encoded))]\np_fpr, p_tpr, _ = roc_curve(test_labels_encoded, random_probs, pos_label=1)","2e018c2d":"#plot roc curves\nplt.plot(fpr1, tpr1, linestyle='-.',color='brown',label = \"Resnet50 + XGboost\")\nplt.plot(p_fpr, p_tpr, linestyle='--', color='blue',label = \"No_skill\")\n# title\nplt.title('ROC curve')\n# x label\nplt.xlabel('False Positive Rate')\n# y label\nplt.ylabel('True Positive rate')\n\nplt.legend(loc='best')\nplt.savefig('ROC',dpi=300)\nplt.show();","f9c3be7a":"auc = roc_auc_score(test_labels_encoded, pred_xgb)\nprint('AUC of \"RESNET50 + gradient_boost\": %.3f' % auc)","7c0aa716":"from sklearn.linear_model import LogisticRegression","0d44e715":"lr = LogisticRegression()\nlr.fit(train_features.reshape(train_features.shape[0],-1),train_labels_encoded)\npred_lr = lr.predict(test_features.reshape(test_features.shape[0],-1))\n\nfrom sklearn.metrics import classification_report,confusion_matrix\ncm = pd.DataFrame(data=confusion_matrix(test_labels_encoded, pred_lr, labels=[0, 1]),index=[\"Actual Covid\", \"Actual Normal\"],\ncolumns=[\"Predicted Covid\", \"Predicted Normal\"])\nimport seaborn as sns\nsns.heatmap(cm,annot=True,fmt=\"d\")","a0e9aa32":"print(classification_report(y_true=test_labels_encoded , y_pred=pred_lr,target_names =['Covid','Normal']))\n","e2a5b454":"from sklearn.metrics import roc_curve, roc_auc_score\n# roc curve for models\nfpr3, tpr3, thresh1 = roc_curve(test_labels_encoded,pred_lr)\nrandom_probs = [0 for i in range(len(test_labels_encoded))]\np_fpr, p_tpr, _ = roc_curve(test_labels_encoded, random_probs, pos_label=1)","2b082a43":"#plot roc curves\nplt.plot(fpr3, tpr3, marker='.',color='green',label = \"Resnet50 + Logistic_regression\")\nplt.plot(p_fpr, p_tpr, linestyle='--', color='blue',label = \"No_skill\")\n# title\nplt.title('ROC curve')\n# x label\nplt.xlabel('False Positive Rate')\n# y label\nplt.ylabel('True Positive rate')\n\nplt.legend(loc='best')\nplt.savefig('ROC',dpi=300)\nplt.show();","a92a74ec":"auc = roc_auc_score(test_labels_encoded, pred_lr)\nprint('AUC of \"RESNET50 + logistic_regression\": %.3f' % auc)","65961b2f":"from sklearn.neighbors import KNeighborsClassifier\nknn = KNeighborsClassifier(n_neighbors=5)\nknn.fit(train_features.reshape(train_features.shape[0],-1),train_labels_encoded)\nknn_pred = knn.predict(test_features.reshape(test_features.shape[0],-1))","e5e01991":"print(classification_report(y_true=test_labels_encoded , y_pred= knn_pred,target_names =['Covid','Normal']))","4678e212":"from sklearn.metrics import classification_report,confusion_matrix,accuracy_score\ncm = pd.DataFrame(data=confusion_matrix(test_labels_encoded, knn_pred, labels=[0, 1]),index=[\"Actual Covid\", \"Actual Normal\"],\ncolumns=[\"Predicted Covid\", \"Predicted Normal\"])\nimport seaborn as sns\nsns.heatmap(cm,annot=True,fmt=\"d\")","36aeacc2":"from sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score\nfor i in [1,2,3,4,5,6,7,8,9,10]:\n  \n  knn = KNeighborsClassifier(n_neighbors=int(i))\n  knn.fit(train_features.reshape(train_features.shape[0],-1),train_labels_encoded)\n  knn_pred = knn.predict(test_features.reshape(test_features.shape[0],-1))\n  print(accuracy_score(test_labels_encoded,knn_pred),i)\n","7e454ebb":"from sklearn.metrics import roc_curve, roc_auc_score\n# roc curve for models\nfpr4, tpr4, thresh4 = roc_curve(test_labels_encoded,knn_pred)\nrandom_probs = [0 for i in range(len(test_labels_encoded))]\np_fpr, p_tpr, _ = roc_curve(test_labels_encoded, random_probs, pos_label=1)","091a854e":"#plot roc curves\nplt.plot(fpr4, tpr4, marker='.',color='green',label = \"Resnet50 + Logistic_regression\")\nplt.plot(p_fpr, p_tpr, linestyle='--', color='blue',label = \"No_skill\")\n# title\nplt.title('ROC curve')\n# x label\nplt.xlabel('False Positive Rate')\n# y label\nplt.ylabel('True Positive rate')\n\nplt.legend(loc='best')\nplt.savefig('ROC',dpi=300)\nplt.show();","2e3df309":"auc = roc_auc_score(test_labels_encoded,knn_pred )\nprint('AUC of \"RESNET50 + KNN\": %.3f' % auc)","988d0fec":"from sklearn.svm  import SVC\nfrom sklearn.model_selection import GridSearchCV\nparam_grid={'C':[0.1],'gamma':[0.1],'kernel':['rbf']}\nsvm= SVC(probability=True)\nmodel=GridSearchCV(svm,param_grid)\n\nmodel.fit(train_features.reshape(train_features.shape[0],-1),train_labels_encoded)\nsvm_pred = model.predict_proba(test_features.reshape(test_features.shape[0],-1))\n","e0862c87":"import decimal\nfrom sklearn.metrics import roc_curve, roc_auc_score\nfrom sklearn import metrics\ndef float_range(start, stop , step):\n  while start < stop:\n    yield float(start)\n    start += decimal.Decimal(step)\n\n\nfor x in list(float_range(0, 1, '0.005')):\n\n  predictions_svm = svm_pred[:,1].copy()\n  predictions_svm[predictions_rf <= x] = 0\n  predictions_svm[predictions_rf > x] = 1\n  print(roc_auc_score(test_labels_encoded , predictions_svm),x) \n","38c4755c":"model = Sequential()\nmodel.add(Flatten(input_shape = (7,7,2048)))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(2048, activation='relu'))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(1024, activation='relu'))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(512, activation='relu'))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(256, activation='relu'))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dropout(0.3))\n\nmodel.add(Dense(1, activation='sigmoid'))\nmodel.summary()\n","8ee471bb":"from tensorflow.keras.callbacks import EarlyStopping,ReduceLROnPlateau\nearly = EarlyStopping(monitor=\"val_loss\", mode= \"min\", patience=5)\nlearning_rate_reduction = ReduceLROnPlateau(monitor=\"val_loss\", patience =2, verbose=1,factor=0.3, min_learning_rate=0.000001)\ncallbacks_list = [ early,learning_rate_reduction]\n# Compile model\nmodel.compile(optimizer='adam',\n              loss='binary_crossentropy',\n              metrics=['accuracy'])\n  \n\nhistory = model.fit(train_features,train_labels_encoded, batch_size =32 , callbacks= callbacks_list , class_weight = cw , epochs=100, validation_data= (test_features,test_labels_encoded))\n","505a4aec":"pd.DataFrame(model.history.history).plot()","9d950823":"np.mean(train_features)","9425b496":"np.max(train_features)","691c08bd":"from sklearn.metrics import roc_curve, roc_auc_score\npreds  = model.predict(test_features)\n# roc curve for models\n\n\n","7745faf6":"# import decimal\n# from sklearn.metrics import roc_curve, roc_auc_score\n# from sklearn import metrics\n# def float_range(start, stop , step):\n#   while start < stop:\n#     yield float(start)\n#     start += decimal.Decimal(step)\n\n\n\n\n\n# for x in list(float_range(0, 1, '0.01')):\n\n#   predictions = preds.copy()\n#   predictions[predictions <= x] = 0\n#   predictions[predictions > x] = 1\n#   print(roc_auc_score(test_labels_encoded, predictions),x) \n\nfpr1, tpr1, thresh1 = roc_curve(test_labels_encoded,preds)","8f3f618e":"predictions = preds.copy()\npredictions[predictions <= 0.13] = 0\npredictions[predictions > 0.13] = 1\n","b7cfa307":"from sklearn.metrics import classification_report,confusion_matrix\nprint(classification_report(y_true=test_labels_encoded , y_pred=predictions,target_names =['Covid','Normal']))\n\n","72b41ef1":"random_probs = [0 for i in range(len(test_labels_encoded))]\np_fpr, p_tpr, _ = roc_curve(test_labels_encoded, random_probs, pos_label=1)","829c7fa9":"from sklearn.metrics import classification_report,confusion_matrix\ncm = pd.DataFrame(data=confusion_matrix(test_labels_encoded, predictions, labels=[0, 1]),index=[\"Actual Covid\", \"Actual Normal\"],\ncolumns=[\"Predicted Covid\", \"Predicted Normal\"])\nimport seaborn as sns\nsns.heatmap(cm,annot=True,fmt=\"d\")","f0ea3f9b":"f, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\nt = f.suptitle('Resnet50 transfer_learning Performance', fontsize=12)\nf.subplots_adjust(top=0.85, wspace=0.3)\n\nax1.plot( history.history['accuracy'], label='Train Accuracy')\nax1.plot( history.history['val_accuracy'], label='Validation Accuracy')\n\nax1.set_ylabel('Accuracy Value')\nax1.set_xlabel('Epoch')\nax1.set_title('Accuracy')\nl1 = ax1.legend(loc=\"best\")\n\nax2.plot( history.history['loss'], label='Train Loss')\nax2.plot( history.history['val_loss'], label='Validation Loss')\nax2.set_ylabel('Loss Value')\nax2.set_xlabel('Epoch')\nax2.set_title('Loss')\nl2 = ax2.legend(loc=\"best\")","4f5766e4":" #plot roc curves\nplt.plot(fpr1, tpr1, marker='.',color='red',label = \"Resnet50 + ANN\")\nplt.plot(fpr2, tpr2, marker='.',color='BLACK',label = \"Resnet50 + RANDOM_FOREST\")\nplt.plot(fpr3, tpr3, marker='.',color='violet',label = \"Resnet50 + Logistic_regression\", linewidth =3)\nplt.plot(fpr4, tpr4, marker='.',color='green',label = \"Resnet50 + KNN \")\nplt.plot(p_fpr, p_tpr, linestyle='--', color='blue',label = \"No_skill\")\n\n# title\nplt.title('ROC curves ')\n# x label\nplt.xlabel('False Positive Rate')\n# y label\nplt.ylabel('True Positive rate')\n\nplt.legend(loc='best')\nplt.savefig('ROC',dpi=300)\nplt.show();\n","0d0e9c7a":"auc = roc_auc_score(test_labels_encoded, preds)\nprint('AUC of \"RESNET50 + ANN_1\": %.3f' % auc)","84f02df8":"train_images\/255","c18b78c9":"--------------------------------------**CUSTOMISED** **ANN**---------------------------------------------","0c84b2d0":"---------------**RANDOM** **FOREST**---------------------------","22f4bb98":"==============================**NAIVE BAYES**==========================================\n","2a159aea":"---------------------------------**K - NEAREST NEIGHBORS**-------------------------------","1ff84bdb":"**------------------------------------Gradient_BOOST**-----------------------------------------------\n\n\n","ea76ee52":"=================**SVM**==========================================","84643e8a":"================**LOGISTIC REGRESSION**====================="}}