{"cell_type":{"b359f6c5":"code","614c49cb":"code","295296db":"code","e85a3f80":"code","2a142145":"code","92de3021":"code","a9571562":"code","b6b2ea39":"code","91a4a61d":"code","83bbe8d7":"code","a7c49a0a":"code","8373923c":"code","7922a514":"code","0e0823f0":"code","e11fb4d4":"code","363eb131":"code","6a01d5f1":"code","c7ddd5f2":"code","c1419eaa":"code","ebdc5ccc":"code","8832ad15":"code","c5ae47cc":"code","c84c45e7":"code","3d17bf0b":"code","f8310143":"code","9e4d7a90":"code","d6a9ad99":"code","aeb4434e":"code","4131221e":"code","f1a18595":"code","6833878d":"code","0e24bc09":"code","f9d1e5bb":"code","cb149031":"code","fe702ece":"code","89434ded":"code","e68fd92e":"code","d35bd0e6":"code","08979738":"code","07abd9f1":"markdown","a6c92dc0":"markdown","fc51ebe4":"markdown","78a918a6":"markdown","cda2033b":"markdown","611b3647":"markdown","9d6669bd":"markdown","7537803f":"markdown","2fb01f3c":"markdown","b3d8f120":"markdown","9d2dd22d":"markdown","21a9d6d0":"markdown","6fc4a91f":"markdown","092ed0ab":"markdown","553cbe80":"markdown"},"source":{"b359f6c5":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport sklearn\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\n\nimport json\nfrom pandas.io.json import json_normalize\n\nimport wandb\n\nimport os\n\nfrom tensorflow.keras.applications import EfficientNetB0\n\nimport tensorflow as tf\nimport tensorflow.keras as keras\nfrom tensorflow.keras.layers import Input, Dense, Dropout, Conv2D, MaxPooling2D, BatchNormalization, Flatten\n\nimport math\nimport cv2\nfrom skimage.transform import resize\n\nimport seaborn as sns\n\nimport multiprocessing\n\nfrom glob import glob","614c49cb":"from kaggle_secrets import UserSecretsClient\n\nuser_secrets = UserSecretsClient()\nwandb_api = user_secrets.get_secret(\"wandb_api\")\nwandb_user = user_secrets.get_secret(\"wandb_user\")\n\nwandb.login(key = wandb_api)\ninit = wandb.init(project = 'herbarium')\n","295296db":"USE_GPU = True\n\nif USE_GPU:\n    strategy = tf.distribute.MirroredStrategy()\n    print(f'Number of devices: {strategy.num_replicas_in_sync}')\n    print(tf.test.gpu_device_name())\n    print(f\"Number of accelerators: {strategy.num_replicas_in_sync}\")","e85a3f80":"num_cores = multiprocessing.cpu_count()\nprint(f\"CPU Cores: {num_cores}\")","2a142145":"train_df = pd.read_csv(\"..\/input\/herbarium-traincsv\/herb_train.csv\")","92de3021":"# For Kaggle Pathfinding\nfilepath_prefix = \"..\/input\/herbarium-2021-fgvc8\/train\/\"\ntrain_df['absolute_path'] = filepath_prefix + train_df.file_name\n\nget_base = os.path.basename\ntrain_df[\"filename_nopath\"] = train_df[\"file_name\"].apply(get_base)","a9571562":"train_df.head()","b6b2ea39":"sns.histplot(train_df[\"category_id\"])","91a4a61d":"sns.histplot(train_df[\"institution_id\"])","83bbe8d7":"sns.histplot(train_df[\"height\"])","a7c49a0a":"sns.histplot(train_df[\"width\"])","8373923c":"sns.histplot(train_df[\"family\"])","7922a514":"sns.histplot(train_df[\"order\"])","0e0823f0":"GLOBAL_SEED = 42\n\nnp.random.seed(GLOBAL_SEED)\ntf.random.set_seed(GLOBAL_SEED)","e11fb4d4":"TRAIN_DIR = \"..\/input\/herbarium-2021-fgvc8\/train\"\nTEST_DIR =  \"..\/input\/herbarium-2021-fgvc8\/test\"\n\nBATCH_SIZE = 128\nSTAGES_PER_EPOCH = 256\nEPOCHS = 200\n\nIMG_HEIGHT = 224\nIMG_WIDTH = 224\nIMG_SIZE = (IMG_HEIGHT, IMG_WIDTH)","363eb131":"# Rename b\/c it contains y.\n\nX_train, X_val, = train_test_split(train_df, test_size = 0.30,\n    stratify = train_df['name'], random_state = GLOBAL_SEED, shuffle = True\n)","6a01d5f1":"print(X_train.shape)\nprint(X_val.shape)","c7ddd5f2":"DO_SUBSET = True\n\nif DO_SUBSET:\n    n_samples = 20000\n    X_train = X_train.sample(n_samples)\n    X_val = X_val.sample(n_samples)\n    ","c1419eaa":"print(X_train.shape)\nprint(X_val.shape)","ebdc5ccc":"train_names = set(X_train.name)\nvalidation_names = set(X_val.name)\nintersection_names = train_names.intersection(validation_names)\n\nlen(intersection_names)\n\n# Names in train but not in validation.\n\nnames_in_both = train_names.intersection(validation_names)","8832ad15":"X_keep_idx = X_train.isin(names_in_both)\nX_keep_idx.name.value_counts()","c5ae47cc":"X_keep = X_train[X_keep_idx.name]\n\nprint(X_train.shape)\nprint(X_keep.shape)","c84c45e7":"X_val_keep_idx = X_val.isin(names_in_both)\nX_val_keep_idx.name.value_counts()","3d17bf0b":"X_val_keep = X_val[X_val_keep_idx.name]\n\nprint(X_val.shape)\nprint(X_val_keep.shape)","f8310143":"X_val_keep.head()","9e4d7a90":"n_classes = X_keep.name.nunique()\nn_classes","d6a9ad99":"rescale_value = 1\/255.\n\ntrain_data_gen = keras.preprocessing.image.ImageDataGenerator(\n    rescale = rescale_value,\n    horizontal_flip = True,\n    rotation_range = 180,\n    shear_range = 30,\n    vertical_flip = True\n    \n    \n#    preprocessing_function = do_img_preprocessing_pipeline,\n#    featurewise_center = True\n)\n\nvalidation_data_gen = keras.preprocessing.image.ImageDataGenerator(\n    rescale = rescale_value,\n#    preprocessing_function = do_img_preprocessing_pipeline\n)","aeb4434e":"train_data_generator = train_data_gen.flow_from_dataframe(\n    dataframe = X_keep,\n    directory = None,\n    x_col = \"absolute_path\",\n    y_col = \"name\",\n    seed = GLOBAL_SEED,\n    batch_size = BATCH_SIZE,\n    shuffle = True,\n    class_mode = \"categorical\",\n    target_size = IMG_SIZE,\n    subset = \"training\",\n    validate_filenames=False\n)","4131221e":"valid_data_generator = validation_data_gen.flow_from_dataframe(\n    dataframe = X_val_keep,\n    directory = None,\n    x_col = \"absolute_path\",\n    y_col = \"name\",\n    seed = GLOBAL_SEED,\n    batch_size = BATCH_SIZE,\n    shuffle = True,\n    class_mode = \"categorical\",\n    target_size = IMG_SIZE,\n    validate_filenames=False\n)","f1a18595":"def do_img_preprocessing_pipeline(image, label):\n    \n    image = tf.image.resize(image, IMG_SIZE)   # Resize\n    image = tf.cast(image, tf.float32) \/ 255.  # Recale\n    \n    # Flip\n    # Rotate\n    \n    return image, label","6833878d":"class HerbariumBatchSequence(tf.keras.utils.Sequence):\n    \n    def __init__(self, x_set, y_set, \n                 batch_size,\n                 img_size = (224, 224),\n                 augment = False):\n        \"\"\"\n        `x_set` is list of paths to the images\n        `y_set` are the associated classes.\n\n        \"\"\"\n        \n        self.batch_size = batch_size\n        self.img_size = img_size\n        \n        self.x = x_set\n        self.y = y_set\n        \n        label_enc = LabelEncoder()\n        self.y = label_enc.fit_transform(self.y)\n        self.y = tf.keras.utils.to_categorical(self.y)\n    \n    def __len__(self):\n        \"\"\"Denotes the number of batches per epoch\"\"\"\n        return math.ceil(len(self.x) \/ self.batch_size)\n    \n    def __getitem__(self, idx):\n        \"\"\"Generate one batch of data\"\"\"\n        \n        first_id = idx * self.batch_size\n        last_id =  (idx + 1) * (self.batch_size)\n        \n        batch_x = self.x[first_id:last_id]\n        batch_y = self.y[first_id:last_id]\n        \n        output = np.array([\n            resize(cv2.imread(file_name), self.img_size)\n                   for file_name in batch_x]), np.array(batch_y)\n        \n        return output\n\n","0e24bc09":"TrainGenerator = HerbariumBatchSequence(X_keep.absolute_path, \n                                        X_keep.name,\n                                        BATCH_SIZE)\n\nValidGenerator = HerbariumBatchSequence(X_val_keep.absolute_path, \n                                       X_val_keep.name,\n                                       BATCH_SIZE)","f9d1e5bb":"# Source: https:\/\/www.kaggle.com\/guglielmocamporese\/macro-f1-score-keras\n\nimport keras.backend as K\n\ndef macro_f1(y_true, y_pred):\n    y_pred = K.round(y_pred)\n    tp = K.sum(K.cast(y_true*y_pred, 'float'), axis=0)\n    # tn = K.sum(K.cast((1-y_true)*(1-y_pred), 'float'), axis=0)\n    fp = K.sum(K.cast((1-y_true)*y_pred, 'float'), axis=0)\n    fn = K.sum(K.cast(y_true*(1-y_pred), 'float'), axis=0)\n\n    p = tp \/ (tp + fp + K.epsilon())\n    r = tp \/ (tp + fn + K.epsilon())\n\n    f1 = 2*p*r \/ (p+r+K.epsilon())\n    f1 = tf.where(tf.is_nan(f1), tf.zeros_like(f1), f1)\n    return K.mean(f1)","cb149031":"efficientnet = EfficientNetB0(include_top=True, \n                              weights=None, \n                              input_shape = (IMG_HEIGHT, IMG_WIDTH, 3),\n                              classes = n_classes\n)\n\n# efficientnet.summary()","fe702ece":"model = efficientnet","89434ded":"model.compile(optimizer = 'adam',\n              loss = 'categorical_crossentropy',\n              metrics = 'accuracy')","e68fd92e":"#wandb_callback = wandb.keras.WandbCallback(log_weights=True)\n\nhistory = model.fit(TrainGenerator,\n                    steps_per_epoch = STAGES_PER_EPOCH,\n                    validation_data = ValidGenerator,\n                    workers = num_cores,\n                    epochs = 3,\n#                    callbacks=[wandb_callback]\n                   )","d35bd0e6":"preds = pd.DataFrame(model.predict(valid_data_generator))","08979738":"preds.head(15)","07abd9f1":"## GPU or TPU usage?","a6c92dc0":"## Reproducibility","fc51ebe4":"# Efficientnet CNN\n\n","78a918a6":"## Imports","cda2033b":"## Splits","611b3647":"### Weights and Biases for Personal Logging","9d6669bd":"### Make sure (subsample) train and val have same classes.\nThese are the names that are not in this validation split","7537803f":"## Herbarium\n\nThis competition presents a few significant challenges:\n* Huge number of classes.\n* Imbalanced classes.\n* Very Large dataset that Kaggle kernels process slowly.\n\nThis is just a very simple kernel to help get folks started with loading and modifying the dataset.\n\nGood luck!","2fb01f3c":"## Image Dataset Generator Approach (Slower - Unused Right Now)","b3d8f120":"#### Train Test Split","9d2dd22d":"## Tensorflow \/ Keras Starter","21a9d6d0":"## EDA - Quick Distribution Visualizations","6fc4a91f":"## Metadata Read and Dataframe Conversion\n\nSee my post on converting JSON to CSV here: https:\/\/www.kaggle.com\/c\/herbarium-2021-fgvc8\/discussion\/225237\n\nI have added the csv to the kernel for easy loading and minimal processing time.","092ed0ab":"## Faster Loading and Parallel Processing (In Process)","553cbe80":"## Custom Loss (in progress)"}}