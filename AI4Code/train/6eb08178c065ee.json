{"cell_type":{"3f927947":"code","b240a990":"code","e81ce0c7":"code","afc8ea5e":"code","46612453":"code","bc695038":"code","270a30d7":"code","9fb0687d":"code","7a426bfe":"code","b729dffa":"code","fa78bfe4":"code","0a07e2c5":"code","b6044ba8":"markdown","5ef9b751":"markdown","10ea809d":"markdown","26c7bece":"markdown","77dd3b03":"markdown","3e79222d":"markdown","4fd494ae":"markdown"},"source":{"3f927947":"# %pip install xgboost","b240a990":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport copy\nimport xgboost as xgb","e81ce0c7":"# Paths\npath_train = '\/kaggle\/input\/tabular-playground-series-jul-2021\/train.csv'\npath_test = '\/kaggle\/input\/tabular-playground-series-jul-2021\/test.csv'\npath_sub = '\/kaggle\/input\/tabular-playground-series-jul-2021\/sample_submission.csv'\n\n# seed \nSEED = 100","afc8ea5e":"train = pd.read_csv(path_train)\ntrain.head()\n\ntest = pd.read_csv(path_test)\ntest_index = test['date_time']\nprint(test.head())\n","46612453":"train.describe()","bc695038":"corr_matrix = train.corr()\nprint('Carbon Monoxide\\n\\n', corr_matrix['target_carbon_monoxide'].sort_values(ascending=False), '\\n')\nprint('Benzene\\n\\n', corr_matrix['target_benzene'].sort_values(ascending=False), '\\n')\nprint('Nitrogen Oxides\\n\\n', corr_matrix['target_nitrogen_oxides'].sort_values(ascending=False), '\\n')","270a30d7":"sns.heatmap(corr_matrix[['target_carbon_monoxide', 'target_benzene', 'target_nitrogen_oxides']].sort_values(['target_carbon_monoxide', 'target_benzene', 'target_nitrogen_oxides']\n                                                                                                   ,ascending=False))","9fb0687d":"# Convert the date_time column to datetime format \ntrain['date_time'] = pd.to_datetime(train['date_time'])\n\n# Create df copy for feature engineering\ntrain_eng = train.copy()\n\n# day_of_week is an integer for each day of the week (0 is monday, 6 is sunday)\ntrain_eng['day_of_week'] = train['date_time'].dt.dayofweek\n\n# is_weekend is boolean, calculated using the new day_of_week variable\ntrain_eng['is_weekend'] = 0\ntrain_eng.loc[(train_eng['day_of_week'] == 5)|(train_eng['day_of_week'] == 6), 'is_weekend'] = 1\n\n# time_of_day is an int for every hour of the day, from 0 to 23\ntrain_eng['time_of_day'] = train['date_time'].dt.hour\n\n# is_daylight is boolean, true for hours between 6:00 and 19:00\ntrain_eng.loc[(train_eng['time_of_day']>6) & (train_eng['time_of_day']<19), 'is_daylight'] = 1\n\n# is_dark is boolean, true for hours between 18:00 and 7:00\ntrain_eng.loc[(train_eng['time_of_day']>18) | (train_eng['time_of_day']<7), 'is_dark'] = 1\n\n# Check \nprint(train_eng['is_daylight'].value_counts())\nprint(train_eng['is_dark'].value_counts())\n\nassert train_eng[train_eng['is_daylight']==1].shape[0] + train_eng[train_eng['is_dark']==1].shape[0] == train_eng.shape[0]\ntrain_eng.fillna(0, inplace=True)","7a426bfe":"corr_matrix_eng = train_eng.corr()\nsns.heatmap(corr_matrix_eng[['target_carbon_monoxide', 'target_benzene', 'target_nitrogen_oxides']].sort_values(['target_carbon_monoxide', 'target_benzene', 'target_nitrogen_oxides']\n                                                                                                   ,ascending=False))","b729dffa":"from sklearn.base import BaseEstimator, TransformerMixin\n\n# class to add engineered features, will be used as part of a pipeline for rapid testing\nclass FeatureCreator(BaseEstimator, TransformerMixin):\n    def __init__(self, add_day_of_week=True, add_is_weekend=True,add_time_of_day=True, add_is_daylight=False, add_is_dark=True):\n        self.add_day_of_week = add_day_of_week\n        self.add_is_weekend = add_is_weekend\n        self.add_time_of_day = add_time_of_day\n        self.add_is_daylight = add_is_daylight\n        self.add_is_dark = add_is_dark \n        \n    def fit(self, X, y=None):\n        return self\n    def transform(self, X):\n        \n        X['date_time'] = pd.to_datetime(X['date_time'])\n        X['day_of_week'] = X['date_time'].dt.dayofweek\n        X['time_of_day'] = X['date_time'].dt.hour\n\n        if self.add_is_weekend:\n            X.loc[(X['day_of_week'] == 5)|(X['day_of_week'] == 6), 'is_weekend'] = 1\n        if self.add_is_daylight:\n            X.loc[(X['time_of_day']>6) & (X['time_of_day']<19), 'is_daylight'] = 1\n        if self.add_is_dark:\n            X.loc[(X['time_of_day']>18) | (X['time_of_day']<7), 'is_dark'] = 1\n        \n        X.fillna(0, inplace=True)\n        \n        if not self.add_day_of_week:\n            X.drop(columns='day_of_week', inplace=True)\n        if not self.add_time_of_day:\n            X.drop(columns='time_of_day', inplace=True)\n            \n        X.set_index('date_time', inplace=True)\n                    \n        return X\n    \n# testing the FeatureCreator class\n'''feat_creator = FeatureCreator()\ntrain_eng_test = train.copy()\n\ntrain_eng_test = feat_creator.transform(train_eng_test)\ntrain_eng_test.head()'''","fa78bfe4":"from sklearn.model_selection import TimeSeriesSplit\nfrom sklearn.metrics import mean_squared_log_error\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import Pipeline\nfrom catboost import CatBoostRegressor\n\n\nsplits = 3\ntime_kfold = TimeSeriesSplit(n_splits=splits)\n\n# Sort by datetime before performing the splits\ntrain = train.sort_values('date_time')\n\n# Target columns\ntargets = ['target_nitrogen_oxides', 'target_benzene', 'target_carbon_monoxide']\n\n# DataFrame to store the fold errors\ndf_rmsle = pd.DataFrame(index = [i for i in range(splits)], columns=targets)\n\n# Model dict XGboost\n'''dict_model = {'target_nitrogen_oxides':\n              xgb.XGBRegressor(n_estimators=1000,\n                               max_depth=6,\n                              random_state=SEED),\n             'target_benzene':\n              xgb.XGBRegressor(n_estimators=1000,\n                               max_depth=6,\n                              random_state=SEED),\n             'target_carbon_monoxide':\n              xgb.XGBRegressor(n_estimators=1000,\n                               max_depth=6,\n                              random_state=SEED)}'''\n\n'''# Model dict RF\ndict_model = {'target_nitrogen_oxides': \n              RandomForestRegressor(n_estimators=600,\n                                    max_depth=12,\n                                    random_state=SEED),\n             'target_benzene':\n              RandomForestRegressor(n_estimators=1000,\n                                    max_depth=12,\n                                    random_state=SEED),\n             'target_carbon_monoxide':\n              RandomForestRegressor(n_estimators=1000,\n                                    max_depth=12,\n                                    random_state=SEED)}'''\n\n# Model dict Catboost\ndict_model = {'target_nitrogen_oxides': \n              CatBoostRegressor(random_state=SEED,\n                                learning_rate=0.05,\n                                depth=8,\n                               verbose=False),\n             'target_benzene':\n              CatBoostRegressor(random_state=SEED,\n                                depth=4,\n                                learning_rate=0.01,\n                               verbose=False),\n             'target_carbon_monoxide':\n              CatBoostRegressor(random_state=SEED,\n                                learning_rate=0.01,\n                                depth=10,\n                               verbose=False)}\n\ntransformation_pipeline = Pipeline([\n    ('feature_creator', FeatureCreator()),\n    ('scaler', StandardScaler()),\n])\n\n# Loop over the splits\nfor idx_fold, (train_ix, val_ix )in enumerate(time_kfold.split(train)):\n    \n    # Training and validation sets (to avoid confusion with original test set)\n    cv_train, cv_val = train.iloc[train_ix], train.iloc[val_ix]\n    \n    # Another loop to train for each of the three targets\n    for idx_target, target in enumerate(targets, 1):\n        \n        # Drop labels from the training set and validation set\n        X_train = cv_train.iloc[:, :-3]\n        X_val = cv_val.iloc[:, :-3]\n        \n        # Set labels, apply a log transform to the target \n        y_train = cv_train.iloc[:, -idx_target]\n        y_train_log = np.log1p(y_train)\n        y_val = cv_val.iloc[:, -idx_target]                \n\n        # Pipeline\n        X = transformation_pipeline.fit_transform(X_train)\n        X_val = transformation_pipeline.transform(X_val)\n                \n        # Fit, predict, evaluate pipeline\n        dict_model[target].fit(X, y_train_log)\n        preds = dict_model[target].predict(X_val)\n                \n        # Evaluate the predictions, expm1 transforms the predictions back to normal ranges\n        rmsle = mean_squared_log_error(y_val, np.expm1(preds)) ** (1\/2)\n        \n        df_rmsle[target].iloc[idx_fold] = rmsle\n        \n        print(f'Fold {idx_fold} : RSMLE for {target} is {rmsle}.')\n    \n    print('\\n')\n    \ncox_rmsle =  df_rmsle.loc[:, 'target_carbon_monoxide'].mean()\nben_rmsle = df_rmsle.loc[:, 'target_benzene'].mean()\nnox_rmsle = df_rmsle.loc[:, 'target_nitrogen_oxides'].mean()\nprint(f\"Overall RMSLE for Monoxide = {cox_rmsle}\")\nprint(f\"Overall RMSLE for Benzene = {ben_rmsle}\")\nprint(f\"Overall RMSLE for Nitrous Oxide = {nox_rmsle}\")\nprint(f'Overall RMSLE = {(cox_rmsle + ben_rmsle + nox_rmsle)\/3}')","0a07e2c5":"sub_ex = pd.read_csv(path_sub)\n\n# Drop labels from the training set and validation set\nX_train = train.iloc[:, :-3]\n\n# Pipeline\nX_train = transformation_pipeline.fit_transform(X_train)\ntest = transformation_pipeline.transform(test)\n\nsub = pd.DataFrame()\nfor idx_target, target in enumerate(targets, 1):\n        \n    y_train = train.iloc[:, -idx_target]\n    y_train_log = np.log1p(y_train)\n    \n    # Fit, predict, evaluate pipeline\n    dict_model[target].fit(X_train, y_train_log) \n        \n    preds = dict_model[target].predict(test)\n    # print(preds[:5])\n    sub = pd.concat([sub, pd.DataFrame(np.expm1(preds))], axis=1)\n\nsub.columns = targets\nsub = sub[['target_carbon_monoxide', 'target_benzene', 'target_nitrogen_oxides']]\nsub = pd.concat([sub_ex['date_time'], sub], axis=1)\nprint(sub.head())\nsub.to_csv('submission.csv', index=False)","b6044ba8":"Looks like time_of_day has a slight positive correlation, maybe not significant.\nIs_daylight is not adding value.\nDay_of_week, is_dark and is_weekend have negative correlations, could add value to the model, this could be tested in an automated pipeline.","5ef9b751":"### Feature engineering ","10ea809d":"### Modeling Time!\n\nThis first CV part is to test for different models for each target feature.\n\n","26c7bece":"Next steps:\nMaybe experiment with a few neural nets (LSTMs?) and Boosted models.\n\nIn the end probably some ensembling.","77dd3b03":"### First correlation analysis (without feature engineering)","3e79222d":"Takeaways:\n* No missing values.\n* Data could be scaled. Sensors have similar range but deg_C and humidities don't.","4fd494ae":"### EDA"}}