{"cell_type":{"a4c5ae11":"code","8c730da7":"code","39d1e236":"code","7a372b01":"code","717a611c":"code","eac0f531":"code","3bb8eb18":"code","e6dc3f47":"code","e50fb2f4":"code","f67fcfd4":"code","8ded9d35":"code","021e87f0":"markdown","cfaf76c1":"markdown"},"source":{"a4c5ae11":"import seaborn as sns\nimport pandas as pd\nimport random","8c730da7":"# Sample dataframe\n# Each category of events in a time series gets an own column. \n# Depending on whether or not a category appears in a time series it is assigned a 1 or 0\n\n# Examplary ids\nids = [i for i in range(100)]\n# Examplary time series features\nrand = [[random.randint(0,1) for j in range(100)] for k in range(4)]\n# Examplary \"standard features\" (e.g. quantity, price)\nrand_price = [random.randint(0,1000) for i in range(100)]\n# Full table\ndf = pd.DataFrame(data={\"id\": ids, \"x1\": rand[0], \"x2\": rand[1], \"x3\": rand[2], \"x4\": rand_price, \"y\": rand[0]})","39d1e236":"print(df)","7a372b01":"corr = df.corr(method='pearson')\ncorr.head()","717a611c":"sns.heatmap(corr);","eac0f531":"# E.g. determine that the time series category \"x1\" is a cutoff for predicting y\n# -> As soon as x1 appears in a time series, x1 and everything following x1 in the time series has to be masked in order to not leak any information","3bb8eb18":"# helper function\ndef stringify(row):\n    x1 = \"1\" if row.x1 == 1 else \"\"\n    x2 = \"2\" if row.x2 == 1 else \"\"\n    x3 = \"3\" if row.x3 == 1 else \"\"\n    result = [x1,x2,x3]\n    random.shuffle(result)\n    return result[0]+result[1]+result[2]","e6dc3f47":"# Given an original dataset (-> where the time series elements are not split into separate columns) of the following format:\ntime_series = [stringify(df.iloc[i]) for i in range(100)] \ndf_orig = pd.DataFrame(data={\"time_series\": time_series, \"x4\": rand_price, \"y\": rand[0]})\nprint(df_orig)","e50fb2f4":"# Masking everything after - and including - \"1\" in the time series\n# Apply padding (series should have fixed length = 3 (in this example))","f67fcfd4":"# Helper functions\ndef mask(row):\n    try:\n        idx = row.time_series.index(\"1\")\n        if idx==0:\n            return \"000\"\n        else:\n            new_row = row.time_series[:idx]\n            padded_row = padd(new_row)\n            return padded_row\n        \n    except ValueError:\n        if len(row.time_series) > 0:\n            return padd(row.time_series)\n        else:\n            return \"000\"\n        \ndef padd(new_row):\n    lnr = len(new_row)\n    if lnr == 2:\n        return new_row + \"0\" \n    if lnr == 1:\n        return new_row + \"00\" \n    return new_row + \"000\" ","8ded9d35":"# Result: A dataset with (hopefully) removed leakage suspects\ntime_series_masked = [mask(df_orig.iloc[i]) for i in range(100)]\ndf_masked = pd.DataFrame(data={\"time_series\": time_series_masked, \"x4\": rand_price, \"y\": rand[0]})\nprint(df_masked)","021e87f0":"General idea:\n- Perform a correlation analysis (explanatory vs response variables)\n- Identify explanatory variables with a relatively high correlation with a response variable\n- For every response variable:\n- Define a set of explanatory variables that are likely a cause for leakage and therefore to be ignored during training\n- ... where \"ignored during training\" = either drop the explanatory variable's column or mask the part of the time series after the variables first occurence","cfaf76c1":"The following code will explain this procedure with sample data"}}