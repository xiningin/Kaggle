{"cell_type":{"655ca669":"code","d037c423":"code","558cf855":"code","bfc29666":"code","305dc27f":"code","0b8d93de":"code","b1429e29":"code","a03bd7bb":"code","22217dee":"code","005b85f5":"code","5dde4caf":"code","46b54a87":"code","b20fda28":"code","04ae91fd":"code","1573331f":"code","0f99e910":"code","a7e4979b":"code","8e54fa1f":"code","860df375":"code","49862b1f":"code","28c4e17f":"code","9fb07f0c":"code","9d0587fb":"code","554cd067":"code","2b899568":"code","3fa0dac2":"code","99caa5db":"code","a1d58378":"code","cea5f5ed":"code","62654e11":"code","1ab72953":"markdown","2588cebc":"markdown","2a82e980":"markdown","544f309c":"markdown","15e2f778":"markdown","17b3e503":"markdown","ff33e18e":"markdown"},"source":{"655ca669":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt","d037c423":"data=pd.read_csv('..\/input\/amazoncom-employee-access-challenge\/train.csv')","558cf855":"data.head()","bfc29666":"data.describe()","305dc27f":"data.isnull().sum()","0b8d93de":"data[\"ACTION\"].value_counts()","b1429e29":"from sklearn.tree import DecisionTreeClassifier","a03bd7bb":"dc=DecisionTreeClassifier()","22217dee":"from sklearn.model_selection import train_test_split","005b85f5":"import seaborn as sns\n#Zoom in\nfor feature in data.columns:\n    if feature !='ACTION':\n        plt.figure(figsize=(9,6));\n        sns.kdeplot(data[data['ACTION']==1][feature],label='Accepted',shade=True);\n        sns.kdeplot(data[data['ACTION']==0][feature],label='Rejected',shade=True);\n        plt.title('Distribution of '+feature+' variable');\n        plt.xlabel(feature);\n        plt.ylabel('Prob. Density');\n        \n        \n    \n","5dde4caf":"sns.heatmap(data.corr())\nplt.figure(figsize=(9,6));\n","46b54a87":"sns.countplot(data['ACTION'])","b20fda28":"print(\"The total % of ACTION taken are \" + str(round(len(data[data['ACTION']==0])\/len(data[\"ACTION\"])*100,2))+\"%\")\nprint(\"The total % of not ACTION taken are \" + str(round(len(data[data['ACTION']==1])\/len(data[\"ACTION\"])*100,2))+\"%\")","04ae91fd":"dt=list()\ndata_preprocessed=data.copy()\nfor feature in data_preprocessed.columns:\n    if feature!='ACTION':\n        uniques=data_preprocessed[feature].unique()\n        d=data.groupby(feature)\n        mean_dict=dict()\n        print(feature)\n        for grps in d.groups:\n            d1=d.get_group(grps).groupby('ACTION')\n            try:\n                zero=(d1.count().loc[0][1])\n            except:\n                zero=0\n            try:\n                ones=d1.count().loc[1][1]\n            except:\n                ones=0\n            mean=round(zero\/(zero+ones),2)\n            #print(\"Mean for \" + str(grps)+ \" is \"+str(mean))\n            mean_dict[grps]=mean\n        dt.append(mean_dict)\n            \n            \n        \n    ","1573331f":"data_preprocessed['RESOURCE']=data_preprocessed[\"RESOURCE\"].replace(dt[0])\n","0f99e910":"data_preprocessed['MGR_ID']=data_preprocessed[\"MGR_ID\"].replace(dt[1])\ndata_preprocessed['ROLE_ROLLUP_1']=data_preprocessed[\"ROLE_ROLLUP_1\"].replace(dt[2])\ndata_preprocessed['ROLE_ROLLUP_2']=data_preprocessed[\"ROLE_ROLLUP_2\"].replace(dt[3])\ndata_preprocessed['ROLE_DEPTNAME']=data_preprocessed[\"ROLE_DEPTNAME\"].replace(dt[4])\ndata_preprocessed['ROLE_TITLE']=data_preprocessed[\"ROLE_TITLE\"].replace(dt[5])\ndata_preprocessed['ROLE_FAMILY_DESC']=data_preprocessed[\"ROLE_FAMILY_DESC\"].replace(dt[6])\ndata_preprocessed['ROLE_FAMILY']=data_preprocessed[\"ROLE_FAMILY\"].replace(dt[7])\ndata_preprocessed['ROLE_CODE']=data_preprocessed[\"ROLE_CODE\"].replace(dt[8])","a7e4979b":"data_preprocessed.head()","8e54fa1f":"Y=data_preprocessed[\"ACTION\"]\nX=data_preprocessed.iloc[:,1:]\nX_train,X_test,Y_train,Y_test=train_test_split(X,Y,random_state=1,test_size=0.3)","860df375":"dc.fit(X_train,Y_train)","49862b1f":"Y_pred=dc.predict(X_test)","28c4e17f":"from sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import f1_score","9fb07f0c":"print(confusion_matrix(Y_test,Y_pred))","9d0587fb":"Y_test.value_counts()","554cd067":"print(\"The accuracy score for the model is \" + str(accuracy_score(Y_test,Y_pred)))","2b899568":"from sklearn.metrics import recall_score,precision_score","3fa0dac2":"print(\"The recall score for the model is \" +str(recall_score(Y_test,Y_pred)))\nprint(\"The precision score for the model is \" +str(precision_score(Y_test,Y_pred)))","99caa5db":"print(\"the F1 score for the model is \"+str(f1_score(Y_test,Y_pred)))","a1d58378":"from sklearn.metrics import roc_auc_score","cea5f5ed":"print(\"The ROC_AUC score value of model is \"+str(roc_auc_score(Y_test,Y_pred)))","62654e11":"dt_prob=dc.predict_proba(X_test)[:,1]\ndt_auc = roc_auc_score(Y_test, dt_prob)\n# summarize scores\nprint('Decision tree: ROC AUC=%.3f' % (dt_auc))\n# calculate roc curves\nfrom sklearn.metrics import roc_curve\ndt_fpr, dt_tpr, _ = roc_curve(Y_test, Y_pred)\n# plot the roc curve for the model\nplt.plot(dt_fpr, dt_tpr, marker='.', label='Decision Tree')\n# axis labels\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\n# show the legend\nplt.legend()\n# show the plot\nplt.show()","1ab72953":"# Target Class representation","2588cebc":"# Correlation Heatmap","2a82e980":"# Model Building","544f309c":"# Target guided encoding","15e2f778":"# Probability Distribution plot ","17b3e503":"Data is hugely unbalanced as one class consists of 94% and the other has only 5% of total outcome.","ff33e18e":"features of dataset are not very correlated"}}