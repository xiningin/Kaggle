{"cell_type":{"1d578e91":"code","733bf304":"code","22fb55a9":"code","083bb8fb":"code","eec23d6e":"code","e96694ab":"code","e435fc92":"code","684bfc73":"code","08cc34fb":"code","c56509b8":"code","a006689e":"code","36a99b7c":"code","a2f06072":"code","374c9896":"code","4c21c3eb":"code","299b8a06":"code","c6708ff6":"code","5c0c913c":"code","2de1f368":"code","6fae8bbe":"code","cc6ca01b":"code","34b7ef19":"code","475bb4f4":"code","7bb3d172":"code","e5d7827c":"code","b31c54f8":"markdown","f81c54af":"markdown","2c227e62":"markdown","99841e84":"markdown","127be872":"markdown","b2f95c8b":"markdown","aece9f7a":"markdown","74fbe4dc":"markdown","5c58e662":"markdown","c5283e40":"markdown","e4fd9d43":"markdown","0f4e715d":"markdown","a97259a9":"markdown","df4fb3e0":"markdown"},"source":{"1d578e91":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom subprocess import check_output\n\nprint(\"Available data:\\n\")\n!ls ..\/input\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))","733bf304":"available_data = {\n    'bitstamp': pd.read_csv(\"..\/input\/bitstampUSD_1-min_data_2012-01-01_to_2019-08-12.csv\"),\n    'coinbase': pd.read_csv(\"..\/input\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv\"),\n    'btce': pd.read_csv(\"..\/input\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv\"),\n    'kraken': pd.read_csv(\"..\/input\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv\")\n}","22fb55a9":"print(\"Bitstamp data shape: {0}\\nCoinbase data shape: {1}\\nBTCe data shape: {2}\\nKraken data shape: {3}\".format(\n    available_data['bitstamp'].shape,\n    available_data['coinbase'].shape,\n    available_data['btce'].shape,\n    available_data['kraken'].shape))","083bb8fb":"btc = available_data['bitstamp']","eec23d6e":"# Show how the data is structured\n\nbtc.head()","e96694ab":"# Fill the value gaps forward\n\nbtc[btc.columns.values] = btc[btc.columns.values].ffill()","e435fc92":"# Plot how the Open prices look\n\nbtc['Open'].plot()","684bfc73":"btc['Delta'] = btc['Close'] - btc['Open']","08cc34fb":"# And we plot the per-minute movements\n\nbtc['Delta'].plot(kind='line')","c56509b8":"btc[abs(btc['Delta']) >= 100]","a006689e":"def digitize(n):\n    if n > 0:\n        return 1\n    return 0\n    \nbtc['to_predict'] = btc['Delta'].apply(lambda d: digitize(d))","36a99b7c":"# Show the last 5 elements of the btc dataframe\n\nbtc.tail()","a2f06072":"btc_mat = btc.as_matrix()","374c9896":"def rolling_window(a, window):\n    \"\"\"\n        Takes np.array 'a' and size 'window' as parameters\n        Outputs an np.array with all the ordered sequences of values of 'a' of size 'window'\n        e.g. Input: ( np.array([1, 2, 3, 4, 5, 6]), 4 )\n             Output: \n                     array([[1, 2, 3, 4],\n                           [2, 3, 4, 5],\n                           [3, 4, 5, 6]])\n    \"\"\"\n    shape = a.shape[:-1] + (a.shape[-1] - window + 1, window)\n    strides = a.strides + (a.strides[-1],)\n    return np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n\n\nWINDOW_SIZE = 22","4c21c3eb":"# Generate the X dataset (the 'Delta' column is the 8th)\n# Remove the last row since it can't have its Y value\n\nX = rolling_window(btc_mat[:,8], WINDOW_SIZE)[:-1,:]","299b8a06":"# Let's see how it looks\n\nbtc['Delta'].tail(10)","c6708ff6":"# And now let's compare the above with the X matrix\n\nprint(\"{0}\\n\\nShape: {1}\".format(X, X.shape))","5c0c913c":"# We generate the corresponding Y array and check if X and Y shapes are compatible\n\nY = btc['to_predict'].as_matrix()[WINDOW_SIZE:]\nprint(\"{0}\\n\\nShape: {1}\".format(Y, Y.shape))","2de1f368":"from sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report","6fae8bbe":"X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.25, random_state=4284, stratify=Y)","cc6ca01b":"# Let's see how it looks\n\ny_test[:100]","34b7ef19":"clf = RandomForestClassifier(random_state=4284, n_estimators=50)\nclf.fit(X_train, y_train)","475bb4f4":"predicted = clf.predict(X_test)","7bb3d172":"print(classification_report(y_test, predicted))","e5d7827c":"conf_mat = confusion_matrix(y_test, predicted)\n\n# Confusion matrix in percentages\npct_conf_mat = conf_mat\/np.sum(conf_mat) * 100\n\nprint(\"Pred:  0\\t\\t1\\n{}\".format(pct_conf_mat))","b31c54f8":"## It's time for some Random Forest","f81c54af":"We need to clean the data by filling the *NaNs* with the last available values. This is accomplished with [.ffill()](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.ffill.html)","2c227e62":"## Conclusions\n\nThe classification report for this simple model is encouraging, even though it's far from perfect.\n\n### Some suggestions\n* Run multiple models for different batches of time - this is because the dynamics of any financial market can change dramatically over time and the range considered in this analysys is more than 5 years.\n* Use other classification models (NN, SVMs, maybe even k-NN).\n* Cross-validate! Tweak the hyperparameters of the Random Forest classifier and the `WINDOW_SIZE`.\n\n*Feel free to fork and implement your ideas. Enjoy!*","99841e84":"## Preparing the data for classification\nWe attach a label to each movement: \n* **1** if the price goes up\n* **0** if the price goes down (or stays the same)","127be872":"Now, we need the data as a `numpy` matrix","b2f95c8b":"Now, we compute the price movement during the 1 minute interval","aece9f7a":"# Predict BTC Price Movement\n\nWe will use a simple approach to predict whether the **next minute price** goes up or down based on the previous movements","74fbe4dc":"Let's take a look at some strong movements shown by the previous graphs (probably flash crashes). The *100* limit is arbitrary","5c58e662":"First, we create the *train* and *test* datasets, making the second **25%** of the whole data. Also, we need to make sure to balance the two datasets (`stratify=Y`)","c5283e40":"## Model Evaluation","e4fd9d43":"We predict the values from the `X_test` data and we are ready the assess the model","0f4e715d":"Now, we fit a random forest classifier to the `X_train` and `y_train` data","a97259a9":"#### We will use Bitstamp data as our default BTC data","df4fb3e0":"## Here's the idea:\nWe will train a classifier providing it with a window of previous `'Delta'` movements of length `WINDOW_SIZE`.\nThe outcome to predict is the next `'to_predict'` value"}}