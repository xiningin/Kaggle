{"cell_type":{"ad5fe95d":"code","529e9971":"code","094ab099":"code","6bca6a97":"code","0515eea2":"code","74a7ef99":"code","7f351404":"code","8ddfda8f":"code","7b5902c4":"code","13d136d3":"code","baac7e6b":"code","10c5897b":"code","496df589":"code","7736386c":"code","c4256767":"code","b0b24f4b":"code","e0170a46":"code","30e18bc0":"code","3daec203":"code","fa503b8c":"code","4fcb5a96":"code","a1d24f97":"code","91580694":"code","f0317261":"markdown","d213953f":"markdown","f4d9b7ea":"markdown","3b262775":"markdown"},"source":{"ad5fe95d":"from numba import jit\nimport numpy as np \nimport pandas as pd \nfrom datetime import datetime as dt\nimport os\nimport seaborn as sns \nimport matplotlib.pyplot as plt\nplt.style.use('ggplot')\nimport lightgbm as lgb\nimport xgboost as xgb\nimport time\nimport datetime\nfrom tqdm import tqdm_notebook as tqdm\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import StratifiedKFold, KFold, TimeSeriesSplit\nfrom sklearn.metrics import mean_squared_error, roc_auc_score\nfrom sklearn import metrics\nfrom itertools import combinations\nimport gc\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport os\nfrom functools import wraps\nfrom timeit import default_timer as timer\n\nimport os\nprint(os.listdir(\".\/\"))\n\ndtypes = {\n        'MachineIdentifier':                                    'category',\n        'ProductName':                                          'category',\n        'EngineVersion':                                        'category',\n        'AppVersion':                                           'category',\n        'AvSigVersion':                                         'category',\n        'IsBeta':                                               'int8',\n        'RtpStateBitfield':                                     'float16',\n        'IsSxsPassiveMode':                                     'int8',\n        'DefaultBrowsersIdentifier':                            'float16',\n        'AVProductStatesIdentifier':                            'float32',\n        'AVProductsInstalled':                                  'float16',\n        'AVProductsEnabled':                                    'float16',\n        'HasTpm':                                               'int8',\n        'CountryIdentifier':                                    'int16',\n        'CityIdentifier':                                       'float32',\n        'OrganizationIdentifier':                               'float16',\n        'GeoNameIdentifier':                                    'float16',\n        'LocaleEnglishNameIdentifier':                          'int8',\n        'Platform':                                             'category',\n        'Processor':                                            'category',\n        'OsVer':                                                'category',\n        'OsBuild':                                              'int16',\n        'OsSuite':                                              'int16',\n        'OsPlatformSubRelease':                                 'category',\n        'OsBuildLab':                                           'category',\n        'SkuEdition':                                           'category',\n        'IsProtected':                                          'float16',\n        'AutoSampleOptIn':                                      'int8',\n        'PuaMode':                                              'category',\n        'SMode':                                                'float16',\n        'IeVerIdentifier':                                      'float16',\n        'SmartScreen':                                          'category',\n        'Firewall':                                             'float16',\n        'UacLuaenable':                                         'float32',\n        'Census_MDC2FormFactor':                                'category',\n        'Census_DeviceFamily':                                  'category',\n        'Census_OEMNameIdentifier':                             'float16',\n        'Census_OEMModelIdentifier':                            'float32',\n        'Census_ProcessorCoreCount':                            'float16',\n        'Census_ProcessorManufacturerIdentifier':               'float16',\n        'Census_ProcessorModelIdentifier':                      'float16',\n        'Census_ProcessorClass':                                'category',\n        'Census_PrimaryDiskTotalCapacity':                      'float32',\n        'Census_PrimaryDiskTypeName':                           'category',\n        'Census_SystemVolumeTotalCapacity':                     'float32',\n        'Census_HasOpticalDiskDrive':                           'int8',\n        'Census_TotalPhysicalRAM':                              'float32',\n        'Census_ChassisTypeName':                               'category',\n        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',\n        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',\n        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',\n        'Census_PowerPlatformRoleName':                         'category',\n        'Census_InternalBatteryType':                           'category',\n        'Census_InternalBatteryNumberOfCharges':                'float32',\n        'Census_OSVersion':                                     'category',\n        'Census_OSArchitecture':                                'category',\n        'Census_OSBranch':                                      'category',\n        'Census_OSBuildNumber':                                 'int16',\n        'Census_OSBuildRevision':                               'int32',\n        'Census_OSEdition':                                     'category',\n        'Census_OSSkuName':                                     'category',\n        'Census_OSInstallTypeName':                             'category',\n        'Census_OSInstallLanguageIdentifier':                   'float16',\n        'Census_OSUILocaleIdentifier':                          'int16',\n        'Census_OSWUAutoUpdateOptionsName':                     'category',\n        'Census_IsPortableOperatingSystem':                     'int8',\n        'Census_GenuineStateName':                              'category',\n        'Census_ActivationChannel':                             'category',\n        'Census_IsFlightingInternal':                           'float16',\n        'Census_IsFlightsDisabled':                             'float16',\n        'Census_FlightRing':                                    'category',\n        'Census_ThresholdOptIn':                                'float16',\n        'Census_FirmwareManufacturerIdentifier':                'float16',\n        'Census_FirmwareVersionIdentifier':                     'float32',\n        'Census_IsSecureBootEnabled':                           'int8',\n        'Census_IsWIMBootEnabled':                              'float16',\n        'Census_IsVirtualDevice':                               'float16',\n        'Census_IsTouchEnabled':                                'int8',\n        'Census_IsPenCapable':                                  'int8',\n        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',\n        'Wdft_IsGamer':                                         'float16',\n        'Wdft_RegionIdentifier':                                'float16',\n        'HasDetections':                                        'int8'\n        }\n\ndef reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage(deep=True).sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage(deep=True).sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    print('Thanks!!')\n    return df\n\ndef add_count(df, c):\n    new_col = 'fe_count_'+ c\n    df[new_col] = df.groupby(c)[c].transform('count')\n\n# In[ ]:\n\n\nnumerics = ['int8', 'int16', 'int32', 'int64', 'float16', 'float32', 'float64']\nnumerical_columns = [c for c,v in dtypes.items() if v in numerics]\ncategorical_columns = [c for c,v in dtypes.items() if v not in numerics]","529e9971":"train = pd.read_csv('..\/input\/train.csv', dtype=dtypes, nrows= 1500000)\ntrain_y = train['HasDetections']\n\n#display section\ntrain['fe_aspect_ratio'] = train['Census_InternalPrimaryDisplayResolutionHorizontal']\/ train['Census_InternalPrimaryDisplayResolutionVertical']\ntrain['Census_InternalPrimaryDisplayResolutionHorizontal'] = train['Census_InternalPrimaryDisplayResolutionHorizontal'].astype(np.float64)\ntrain['Census_InternalPrimaryDisplayResolutionVertical'] = train['Census_InternalPrimaryDisplayResolutionVertical'].astype(np.float64)\ntrain['fe_dpi'] = ((train['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + train['Census_InternalPrimaryDisplayResolutionVertical']**2)**.5)\/(train['Census_InternalPrimaryDiagonalDisplaySizeInInches'])\ntrain['fe_MegaPixels'] = (train['Census_InternalPrimaryDisplayResolutionHorizontal'] * train['Census_InternalPrimaryDisplayResolutionVertical'])\/1e6\n\nprint('Done Display Features\\n')\n\ndef encode_categorical_columns(x_train, columns, sort=True):\n    train_length = x_train.shape[0]\n    for col in tqdm(columns):\n        if col == 'MachineIdentifier' or col == 'HasDetections':\n            continue\n            \n        combined_data = pd.concat([x_train[col]])\n        combined_data, _ = pd.factorize(combined_data, sort=sort)\n        combined_data = pd.Series(combined_data).astype('int32')\n        x_train[col] = combined_data.iloc[:train_length].values\n        x_train[col] = x_train[col].fillna(0)\n        del combined_data\n        gc.collect()\n        \n    return x_train","094ab099":"def fe(df):\n\n    print(gc.collect())\n    print('Cooking Pointless Things....')\n\n    df['fe_EngineVersion_2'] = df['EngineVersion'].apply(lambda x: x.split('.')[2]).astype('category')\n    df['fe_one_less_AVproductInstalled'] = df['AVProductsInstalled'] - 1\n\n    df['fe_AvSigVersion_minor'] = df['AvSigVersion'].apply(lambda x: x.split('.')[1]).astype('category')\n    df['fe_AvSigVersion_build'] = df['AvSigVersion'].apply(lambda x: x.split('.')[2]).astype('category')\n    df['fe_AvSigVersion_minor_build'] = df['AvSigVersion'].str.replace('1.2&#x17;3.1144.0','1.273.1144.0').apply(lambda x: float((x.split('.')[1]) +'.'+(x.split('.')[2]))).astype('float32')\n    df['fe_AvSigVersion_sum'] = df['AvSigVersion'].str.replace('1.2&#x17;3.1144.0','1.273.1144.0').apply(lambda x: float(x.split('.')[1]) + float(x.split('.')[2])).astype(int).values\n    df['AvSigVersion'] = df['AvSigVersion'].astype('category')\n    top_20 = df['AVProductStatesIdentifier'].value_counts(dropna=False, normalize=True).cumsum().index[:20]\n    df['fe_magic_4'] = 0\n    df.loc[df['AVProductStatesIdentifier'].isin(top_20) == True, 'fe_magic_4'] = 1\n    del top_20\n    gc.collect()\n    df['fe_primary_drive_c_ratio'] = df['Census_SystemVolumeTotalCapacity']\/ df['Census_PrimaryDiskTotalCapacity']\n    df['fe_Census_SystemVolumeTotalCapacity_GB'] = df['Census_SystemVolumeTotalCapacity']\/1024.\n    df['fe_non_primary_drive_MB'] = df['Census_PrimaryDiskTotalCapacity'] - df['Census_SystemVolumeTotalCapacity']\n    df['fe_ram_per_processor'] = df['Census_TotalPhysicalRAM']\/ df['Census_ProcessorCoreCount']\n    df['fe_physical_cores'] = df['Census_ProcessorCoreCount'] \/ 2\n    \n    ##### testing feats\n    df['fe_hghdec_cnt1'] = 0\n    df.loc[df['CountryIdentifier'].isin([214,89,195,4,141,158,43,201,41,9,29,203,171,60,93,142,66,149,207,97,107,68,5,35,160]) == True, 'fe_hghdec_cnt1'] = 1\n    df = reduce_mem_usage(df)\n    gc.collect()\n    \n    return df\n\n# In[ ]:","6bca6a97":"train = fe(train)","0515eea2":"numerical_columns = list(train.select_dtypes(include=numerics).columns)\ncategorical_columns = categorical_columns + ['fe_EngineVersion_2', 'fe_AvSigVersion_minor']\ntrain = encode_categorical_columns(train, categorical_columns)\nprint(train.shape)","74a7ef99":"train = reduce_mem_usage(train)","7f351404":"numerical_columns.remove('HasDetections')\nremove = ['MachineIdentifier','Census_ChassisTypeName','Census_OSEdition','Census_OSArchitecture',\n          'OsPlatformSubRelease','OsVer', 'Census_DeviceFamily']\nfor col in remove:categorical_columns.remove(col)","8ddfda8f":"col_vals_dict = {c: list(train[c].unique()) for c in categorical_columns if c not in ['MachineIdentifier', 'ProductName']}","7b5902c4":"nb_numeric   = len(train.columns) - len(col_vals_dict)\nnb_categoric = len(col_vals_dict)\nprint('Number of Numerical features:', nb_numeric)\nprint('Number of Categorical features:', nb_categoric)","13d136d3":"embed_cols = []\nlen_embed_cols = []\nfor c in col_vals_dict:\n    if len(col_vals_dict[c])>2:\n        embed_cols.append(c)\n        len_embed_cols.append((c, len(col_vals_dict[c])))\n        print(c + ': %d values' % len(col_vals_dict[c])) #look at value counts to know the embedding dimensions\n        \nprint('\\n Number of embed features :', len(embed_cols))","baac7e6b":"len(numerical_columns), len(embed_cols), train.shape","10c5897b":"len_embed_cols","496df589":"from keras import regularizers\ndef build_embedding_network(len_embed_cols):\n    \n    model_out = []\n    model_in  = []\n    \n    for name, dim in len_embed_cols:\n        input_dim = Input(shape=(1,), dtype='int32')\n        embed_dim = Embedding(dim, min(50, dim\/\/2 + 1), input_length=1, name= name)(input_dim) #1 for unknowns\n        embed_dim = Dropout(0.12)(embed_dim)\n        embed_dim = Flatten()(embed_dim) #Tilli's Help\/His share https:\/\/www.kaggle.com\/c\/microsoft-malware-prediction\/discussion\/76384\n        model_out.append(embed_dim)\n        model_in.append(input_dim)\n    \n    input_num = Input(shape=(74,), dtype='float32')\n    num = (Dense(64))(input_num)\n    num = (Activation('relu'))(input_num)\n    num = (Dropout(.1))(input_num)\n    num = (BatchNormalization())(input_num)\n    outputs = Concatenate(axis=1)([*model_out, num])\n    \n    outputs = (Dense(128, kernel_regularizer=regularizers.l2(1e-4)))(outputs) \n    outputs = (Activation('relu'))(outputs)\n    outputs = (Dropout(.2))(outputs)\n    outputs = (BatchNormalization())(outputs)\n    outputs = (Dense(32, kernel_regularizer=regularizers.l2(1e-4)))(outputs) \n    outputs = (Activation('relu'))(outputs)\n    outputs = (Dropout(.1))(outputs)\n    outputs = (Dense(1))(outputs)\n    outputs = (Activation('sigmoid'))(outputs)\n    model = Model([*model_in, input_num], outputs)\n    model.compile(loss='binary_crossentropy', optimizer='adam')\n    \n    return model","7736386c":"def preproc(X_train, X_val):\n\n    input_list_train = []\n    input_list_val = []\n    \n    #the cols to be embedded: rescaling to range [0, # values)\n    for c in embed_cols:\n        raw_vals = np.unique(X_train[c])\n        val_map = {}\n        for i in range(len(raw_vals)):\n            val_map[raw_vals[i]] = i       \n        input_list_train.append(X_train[c].map(val_map).values)\n        input_list_val.append(X_val[c].map(val_map).fillna(0).values)\n        \n    #the rest of the columns\n    other_cols = [c for c in X_train.columns if (not c in embed_cols+['HasDetections', 'MachineIdentifier'])]\n    input_list_train.append(X_train[other_cols].values)\n    input_list_val.append(X_val[other_cols].values)\n    \n    return input_list_train, input_list_val","c4256767":"# Impute missing values in order to scale\nfrom sklearn.preprocessing import MinMaxScaler\n\ntrain[numerical_columns] = train[numerical_columns].fillna(value = 0)\n\n# Fit the scaler only on train data\nscaler = MinMaxScaler().fit(train[numerical_columns])\ntrain.loc[:,numerical_columns] = scaler.transform(train[numerical_columns])","b0b24f4b":"print ('neural network....')\nfrom keras.layers import Input, Embedding, Dense, Flatten, Dropout, concatenate, Reshape\nfrom keras.layers import BatchNormalization, SpatialDropout1D, Concatenate, Activation\nfrom keras.callbacks import Callback, EarlyStopping\nfrom keras.models import Model\nfrom keras.optimizers import Adam","e0170a46":"K = 5\nruns_per_fold = 1\nn_epochs = 15\npatience = 5\nmodels = []\ncv_aucs   = []\nfull_val_preds = np.zeros(np.shape(train)[0])\n\nkfold = StratifiedKFold(n_splits = K, shuffle = True, random_state=2**10)\n\nfor i, (f_ind, outf_ind) in enumerate(kfold.split(train, train_y)):\n\n    train_f, X_val_f = train.loc[f_ind].copy(), train.loc[outf_ind].copy()\n    train_y_f, y_val_f = train_y[f_ind], train_y[outf_ind]\n    \n    print('Shapes Are', train_f.shape, X_val_f.shape)\n    \n    # Shuffle data\n    idx = np.arange(len(train_f))\n    np.random.shuffle(idx)\n    train_f = train_f.iloc[idx]\n    train_y_f = train_y_f.iloc[idx]\n\n    #preprocessing\n\n    print('Preprocessing........!!!')\n    proc_train_f, proc_X_val_f = preproc(train_f, X_val_f)\n    \n    #track oof prediction for cv scores\n    val_preds = 0\n    \n    for j in range(runs_per_fold):\n        \n        print('Build_Embedding_Network........!!!')\n        NN = build_embedding_network(len_embed_cols)\n        \n        # Set callback functions to early stop training and save the best model so far\n        callbacks = [EarlyStopping(monitor='val_loss', patience=patience)]\n\n        print(len(proc_train_f))\n        \n        NN.fit(proc_train_f, train_y_f.values, \n               epochs=n_epochs, batch_size= 2**13, \n               verbose=1,callbacks=callbacks,\n               validation_data=(proc_X_val_f, y_val_f))\n        \n        del proc_train_f, train_y_f, callbacks\n        gc.collect()\n        print('OOF Val Predictions........!!!')\n        val_preds += NN.predict(proc_X_val_f)[:,0] \/ runs_per_fold\n        del proc_X_val_f\n        gc.collect()\n\n        print('Test Predictions........!!!')\n        #need to fix the y_preds over batches...\n        #y_preds[:,i] += NN.predict(proc_test_f)[:,0] \/ runs_per_fold\n        \n        models.append(NN)\n        \n    full_val_preds[outf_ind] += val_preds\n        \n    cv_auc  = roc_auc_score(y_val_f.values, val_preds)\n    cv_aucs.append(cv_auc)\n    #########################################\n    #thanks to @tksasagi for her tweet#######\n    #########################################\n    print('|\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3|')\n    print('|    VALIDATION    |') \n    print('|     Fold %i prediction cv AUC: %.5f  |' %(i,cv_auc))\n    print('| \uff3f\uff3f\uff3f_\uff3f\uff3f\uff3f\uff3f|') \n    print(' (\\__\/) ||') \n    print(' (\u2022\u3145\u2022) || ')\n    print(' \/ \u3000 \u3065')\n    \nprint('Mean out of fold AUC: %.5f' % np.mean(cv_auc))\nprint('Full validation AUC: %.5f' % roc_auc_score(train_y.values, full_val_preds))\n\nprint('Saving OOF Train.......')\nnp.save('train_oof_nn_with_embedddings.npy', full_val_preds)\nprint('Saved\\n')\n\n#for some unknow reason it's overfitting but it wont locally...!!!","30e18bc0":"len_embed_cols","3daec203":"models[0].summary()","fa503b8c":"import pickle\nsave_embeddings = True\nsaved_embeddings_fname = \"embeddings.pickle\"\nall_emb = []\nif save_embeddings:\n    model_ = models[0]    \n    for cols in embed_cols:\n        emb = model_.get_layer(cols).get_weights()[0]\n        all_emb.append(emb)\n    \n    with open(saved_embeddings_fname , 'wb') as f:\n        pickle.dump(all_emb, f, -1)","4fcb5a96":"from keras.models import load_model\n\nmodels[0].save('my_model_0.h5')\nmodels[1].save('my_model_1.h5')\nmodels[3].save('my_model_3.h5')\n\ndel models  # deletes the existing models","a1d24f97":"embed_cols","91580694":"for idx, col in enumerate(train.columns):\n    if col in embed_cols:\n        print(idx, col)      ","f0317261":"- **This Kernel Draws Heavily from other kernels on Kaggle for Embeddings especial From Rosmann Comps.... **\n    - **So Kudos to them!!**","d213953f":"## Have Fun :) \n - Things will change if you run it locally ;)","f4d9b7ea":"### Create the network\nIn order to create our embedding model we need to have a look at the spatiality of the cat features. We choose here to use Embedding only on cat features that present more than 2 outcomes otherwise it is count as a numeric value (0 or 1).","3b262775":"- We are including 31 features out of 33 categorical features into our Embedding.\n- **embedding size = min(50, number of categories\/2)**"}}