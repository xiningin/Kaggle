{"cell_type":{"4d68af1b":"code","27b2a6ed":"code","9da028e9":"code","68b09c60":"code","24af7ed3":"code","aff8bcd5":"code","1c780aa8":"markdown"},"source":{"4d68af1b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","27b2a6ed":"import numpy as np\nimport pandas as pd\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.width', 500)\ndf = pd.read_csv(\"..\/input\/projectgamepersona\/persona.csv\")\ndf.head()","9da028e9":"#data summary\n###########\n#first 5 observations of persona dataset\ndf.head()\n#information about data types and null values\ndf.info()\n#number of rows,columns\ndf.shape\n#variables of the persona dataset including the dependent one\ndf.columns\n#is there any missing value in our dataframe?\ndf.isnull().values.any()\n#dataframe overview with aggregation values in transpose\ndf.describe().T\n#############\n\n#unique sources and frequencies\ndf[\"SOURCE\"].nunique()\ndf[\"SOURCE\"].value_counts()\n#There are 2 unique sources \"android\" and \"ios\".\n#2974 android, 2026 ios.\n###############\n#unique Prices\ndf[\"PRICE\"].nunique()\ndf[\"PRICE\"].unique()\n#There are 6 unique prices.","68b09c60":"\n##prices and Frequencies\ndf[\"PRICE\"].value_counts()\n\"\"\"\nPrice    Quantity of Sold App\n29            1305\n39            1260\n49            1031\n19            992\n59            212\n9             200\n\"\"\"\n#############\n#number of sales by country\nsales_by_country = df[\"COUNTRY\"].value_counts()\nsales_by_country\n\n\n\n###########\n#revenue of total sales by country\ndf.groupby(\"COUNTRY\")[['PRICE']].aggregate(\"sum\")\n\n#################\n#sales by source\ndf.groupby(\"SOURCE\")[\"PRICE\"].count()\n\"\"\"\n         PRICE\nCOUNTRY       \nbra      51354\ncan       7730\ndeu      15485\nfra      10177\ntur      15689\nusa      70225\n\"\"\"\n\n\n######################\n#average value of sales by country\ndf.groupby(\"COUNTRY\")[\"PRICE\"].mean()\n\"\"\"\nCOUNTRY\nbra    34.327540\ncan    33.608696\ndeu    34.032967\nfra    33.587459\ntur    34.787140\nusa    34.007264\n\"\"\"\n\n\n##############\n#average value of sales by source\ndf.groupby(\"SOURCE\")[\"PRICE\"].mean()\n\"\"\"\nandroid    34.174849\nios        34.069102\n\"\"\"\n#############\n#average value of prices by country and source\ndf.groupby(['COUNTRY','SOURCE'])[[\"PRICE\"]].aggregate(\"mean\").unstack()\n\"\"\"\n             PRICE           \nSOURCE     android        ios\nCOUNTRY                      \nbra      34.387029  34.222222\ncan      33.330709  33.951456\ndeu      33.869888  34.268817\nfra      34.312500  32.776224\ntur      36.229437  33.272727\nusa      33.760357  34.371703\n\"\"\"","24af7ed3":"#######################################################################\n#what are the average earnings by country,source, sex and age?\n###################################################\ndf.groupby([\"COUNTRY\",\"SOURCE\",\"SEX\",\"AGE\"])[\"PRICE\"].mean().head()\n\n###################################\n#in order to better observation for our output, we apply the sort_values sort_values method to the price by ascending.\n\n######################################\nagg_df = df.groupby([col for col in df.columns if col != 'PRICE']).mean()\nagg_df.sort_values(\"PRICE\", ascending = False, inplace = True)\nagg_df.head()\n\n\n#################################\n#let's convert the names in the index to variable names\nagg_df.reset_index(inplace = True)\n\n\n####################\n#let's create age ranges and assign them to a categorical value and add it to our dataframe.\n\nbins = [0,18,23,30,40,70]\nlab = [\"0_18\", \"19_23\", \"24_30\", \"31_40\", \"41_70\"]\n\nagg_df[\"AGE_CAT\"] = pd.cut(agg_df[\"AGE\"],bins,labels=lab)\nagg_df.head()\n\n##########################################\n#now we need to create extensive new personas and unify those personas.\nfor row in agg_df.values:\n    print(row)\n\n[row[0].upper() + \"_\" + row[1].upper() + \"_\" + row[2].upper() + \"_\" + row[5].upper() for row in agg_df.values]\n\nagg_df[\"customers_level_based\"] = [row[0].upper() + \"_\" + row[1].upper() + \"_\" + row[2].upper() + \"_\" + row[5].upper() for row in agg_df.values]\nagg_df.head()\n\n#now we can get rid of the other variables, \"customers_level_based\" does all the classifications that we need and that the other variables do.\n#let's assign agg_df only with \"customers_level_based\" and \"PRICE\".\nagg_df = agg_df[[\"customers_level_based\", \"PRICE\"]]\nagg_df.head()\n\nagg_df[\"customers_level_based\"].value_counts()\n#there is more than one from the same segment in our dataset, we should fix this. after groupby the segments, we should get the price averages and deduplicate the segments.\n\nagg_df = agg_df.groupby(\"customers_level_based\").agg({\"PRICE\": \"mean\"})\n#we need to remove customers_level_based from the index and turn it into a variable.\nagg_df = agg_df.reset_index()\nagg_df[\"customers_level_based\"].value_counts()\n#now the all the personas that we created are unique.\n################################\n\n#we want to create segments according to price. this segmentation will give us the opportunity to take action and strategize sales.\nagg_df[\"SEGMENT\"] = pd.qcut(agg_df[\"PRICE\"], 4, labels = [\"D\",\"C\",\"B\", \"A\"])\nagg_df.head()\n#average values of segments by the price.\nagg_df.groupby(\"SEGMENT\")[\"PRICE\"].mean()\n#observation of segment C.\nagg_df[agg_df[\"SEGMENT\"] == \"C\"]\n","aff8bcd5":"######################################################\n#find the segment and average income of a 33-year-old android user Turkish woman.\nnew_user = \"ANROID_FEMALE_TURKEY_31_40\"\nagg_df[agg_df[\"customers_level_based\"] == new_user]\nagg_df.head()\n#now let's look at the 35-year-old ios user French man.\nnew_user = \"IOS_MALE_FRA_31_40\"\nagg_df[agg_df[\"customers_level_based\"] == new_user]\n\n\"\"\"\nnow we can predict how much our customers will earn on average. we can develop a marketing strategy using this segmentation.\n\"\"\"","1c780aa8":"This is a project created by VBO. A gaming company wants to create new level based customer definitions by using certain characteristics of its customers and form new segments accordingly. Then they aim to use these new segments in order to predict how much the company can earn from potential customers on average. Here I\u2019m using persona.cv dataset. This dataset includes the pricing of a mobile application and its users\u2019 age, nationality, gender. I\u2019m re-observing these variables by creating new and more inclusive personas and segmenting them according to average spending. Thus, we can predict how much profit we can make from different kinds of customers.\n\nVARIABLES\n\n**PRICE - Customer Spend Amount\n\n**SOURCE - Operating system of the customer's mobile device\n\n**SEX - Sex\n\n**COUNTRY - Country where the customer is located\n\n**AGE - Age of Customer"}}