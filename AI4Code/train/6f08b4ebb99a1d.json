{"cell_type":{"26045a78":"code","27f38442":"code","2552c26a":"code","bbc88bcc":"code","d7650a79":"code","2436a8a4":"code","e3cb23c9":"code","b9653824":"code","8b86a8be":"code","e0af1795":"code","3f58ac5f":"code","2411bb76":"code","da4a2492":"code","7705a4e0":"code","942bdf05":"code","53c259ee":"markdown","aff0bac8":"markdown","bd33967b":"markdown","12bff26d":"markdown","e94d14a2":"markdown","f30a8637":"markdown","241bfcb1":"markdown","e69da7b4":"markdown","f7d43a7c":"markdown","e8a4a105":"markdown"},"source":{"26045a78":"import json\nimport re\nimport os\nimport sys\nimport requests\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport copy\nimport glob\nimport pandas as pd\nfrom matplotlib.patches import Polygon\nfrom PIL import Image\nfrom io import BytesIO\nfrom sklearn.cluster import KMeans\nimport pickle\n%matplotlib inline","27f38442":"with open('..\/input\/msocrrawoutputs\/ms_ocr_raw_output.pkl', 'rb') as f:\n    raw = pickle.load(f)","2552c26a":"# Enter the image root path here\nIMG_ROOT_PATH = '..\/input\/rlocrcroppedimg\/work\/main table structures'\n\n# Enter an image index here\nIMG_INDEX = 0 # 1\n# IMG_ID = '1135'\nIMG_ID = '0132b'","bbc88bcc":"if IMG_ID is None:\n    assert os.path.isdir(IMG_ROOT_PATH), 'Invalid Root Path.'\n    img_paths = glob.glob(f'{IMG_ROOT_PATH}\/*.JPG')\n    assert len(img_paths) > 0, 'No Image in the Target Folder.'\n    try:\n        path = img_paths[IMG_INDEX]\n    except IndexError:\n        path = img_paths[0]\nelse:\n    path = f'{IMG_ROOT_PATH}\/{IMG_ID}.JPG'\nimg_id = path.split('\/')[-1].split('.')[0]\nprint(f'img_id: {img_id}')\nplt.rcParams['figure.figsize'] = [15, 15]\nplt.axis('off')\nplt.imshow(Image.open(path), cmap='Greys_r')\nplt.show()","d7650a79":"analysis = raw[img_id]\npolygons = []\nif (\"analyzeResult\" in analysis):\n    # Extract the recognized text, with bounding boxes.\n    polygons = [(line[\"boundingBox\"], line[\"text\"])\n                for line in analysis[\"analyzeResult\"][\"readResults\"][0][\"lines\"]]\npolygons[:5]","2436a8a4":"# Display the image and overlay it with the extracted text.\nimage = Image.open(path)\nplt.rcParams['figure.figsize'] = [15, 15]\nax = plt.imshow(image, cmap='Greys_r')\nfor polygon in polygons:\n    vertices = [(polygon[0][i], polygon[0][i+1])\n                for i in range(0, len(polygon[0]), 2)]\n    text = polygon[1]\n    patch = Polygon(vertices, closed=True, fill=False, linewidth=2, color='b')\n    ax.axes.add_patch(patch)\n    plt.text(vertices[1][0], vertices[1][1], text, fontsize=15, color='r', va=\"top\")\nplt.axis('off')\nplt.show()","e3cb23c9":"def calc_h(polygon):\n    h1 = abs(int(polygon[1])-int(polygon[7]))\n    h2 = abs(int(polygon[3])-int(polygon[5]))\n    return (h1+h2)\/2\n\ndef avg_h(polygons):\n    hs = []\n    for poly in polygons:\n        hs.append(calc_h(poly[0]))\n    return np.mean(np.array(hs))\n\ndef calc_center(polygon):\n    '''\n    calculate the center coordinate of a polygon.\n    returns [x_center, y_center]\n    '''\n    x = np.array([polygon[0], polygon[2], polygon[4], polygon[6]])\n    y = np.array([polygon[1], polygon[3], polygon[5], polygon[7]])\n    return [np.mean(x), np.mean(y)]\n\ndef calc_iou(poly1, poly2):\n    y1_upper = (poly1[1] + poly1[3]) \/ 2\n    y1_lower = (poly1[5] + poly1[7]) \/ 2\n    y2_upper = (poly2[1] + poly2[3]) \/ 2\n    y2_lower = (poly2[5] + poly2[7]) \/ 2\n    range1 = set(range(int(2*y1_upper), int(2*y1_lower)))\n    range2 = set(range(int(2*y2_upper), int(2*y2_lower)))\n    return len(range1.intersection(range2)) \/ len(range1.union(range2))    \n\ndef calc_area(polygon):\n    '''\n    calculate the area of a polygon.\n    polygon -- a list of format: [\n        upper_left_x, \n        upper_left_y, \n        upper_right_x,\n        upper_right_y,\n        lower_right_x,\n        lower_right_y\n        lower_left_x,\n        lower_left_y]\n    returns a float.\n    '''\n    x = np.array([polygon[0], polygon[2], polygon[4], polygon[6]])\n    y = np.array([polygon[1], polygon[3], polygon[5], polygon[7]])\n    return 0.5*np.abs(np.dot(x,np.roll(y,1))-np.dot(y,np.roll(x,1)))\n\ndef slope(polygons):\n    '''\n    calculate the mean and variance skewness of the boxes.\n    returns a list [mean, var]\n    '''\n    n = len(polygons)\n    ks = []\n    for i, poly in enumerate(polygons):\n        #filtering out too small boxes\n        if calc_area(poly[0]) < 2200:\n            n -= 1\n            continue\n\n        #avoiding zero-division error\n        if (poly[0][2]-poly[0][0]<=0) or (poly[0][4]-poly[0][6]<=0):\n            n -= 1\n            continue\n\n        upperK = (poly[0][3]-poly[0][1]) \/ (poly[0][2]-poly[0][0])\n        lowerK = (poly[0][5]-poly[0][7]) \/ (poly[0][4]-poly[0][6])\n        k = (upperK+lowerK) \/ 2\n\n        #removing abnormal output\n        if abs(k) > 1: # remove is degree larger than pi\/4\n            n -= 1\n            continue\n\n        ks.append(k)\n    ks = np.array(ks)\n        # print(i, k)\n    return [np.mean(ks), np.var(ks)]\n\n# def slope2dgree(slope):\n#     '''\n#     return the degree of skew (clockwise positive)\n#     '''\n#     return np.arctan(slope) \/ np.pi * 180\n\n# slope(polygons)\n# for i, poly in enumerate(polygons):\n#     print(i, calc_area(poly[0]), poly[1])\ndef denoise(polygons):\n    denoised = copy.deepcopy(polygons)\n    noise_indexs = []\n    for i, poly in enumerate(denoised):\n        text = poly[1]\n        contain_number = any(char.isdigit() for char in text)\n        contain_alpha = any(char.isalpha() for char in text)\n        if (not contain_number) and (not contain_alpha):\n            noise_indexs.append(i)\n    for index in sorted(noise_indexs, reverse=True):\n        del denoised[index]\n    return denoised\n\ndef remove_nonalpha(s):\n    return ''.join([char for char in list(s) if char.isalpha() or char==' ']).strip()\n\ndef extract_head(polygons):\n    '''\n    returns list e.g. [denied, manhattan, polys_nohead]\n    '''\n    ret = [None, None, None]\n    nohead = copy.deepcopy(polygons)\n    head_indexs = []\n    bor_y = 0\n    for i, poly in enumerate(nohead):\n        box, text = poly[0], poly[1]\n        if 'borough' in text.lower():\n            head_indexs.append(i)\n            text = remove_nonalpha(text)\n            ret[1] = text.split()[-1]\n            bor_y = box[1]\n        if any(_ in text.lower() for _ in ['denied', 'revoked', 'granted']):\n            head_indexs.append(i)\n            ret[0] = text\n    for i, poly in enumerate(nohead):\n        box = poly[0]\n        if box[1] < bor_y:\n            head_indexs.append(i)\n    for index in sorted(head_indexs, reverse=True):\n        del nohead[index]\n    ret[2] = nohead\n    return ret","b9653824":"# extractor = extract_head(denoise(polygons))\n# result, borough, polygons_nohead = extractor[0], extractor[1], extractor[2]\n# result, borough\npolygons = denoise(polygons)","8b86a8be":"def get_ncols(polygons, candidates=[1,2,3,4]):\n    for c in reversed(sorted(candidates)):\n        X = np.array([calc_center(poly[0])[0] for poly in polygons])\n        X = X.reshape(-1,1)\n        column_cluster = KMeans(n_clusters=c, random_state=0)\n        column_cluster.fit(X)\n        centers = column_cluster.cluster_centers_\n        centers = centers.reshape(-1)\n#         print(centers)\n        centers.sort()\n        gaps = np.array([centers[i+1]-centers[i] for i in range(len(centers)-1)])\n        if np.var(gaps) < 1e5:\n            break\n    return c\nncols = get_ncols(polygons)\nncols","e0af1795":"X = np.array([calc_center(poly[0])[0] for poly in polygons])\nX = X.reshape(-1,1)\ncolumn_cluster = KMeans(n_clusters=ncols, random_state=0)\ncolumn_cluster.fit(X)\n# for i, p in enumerate(polygons):\n#     print(kmeans.labels_[i], p[1])","3f58ac5f":"color_dict = {\n    0: 'y',\n    1: 'r',\n    2: 'b',\n    3: 'g'\n    }\nlabel_count = {col:0 for col in range(ncols)}\ngt_names = ['number', 'name', 'nature', 'address']\ncolumn_names = {}\n\ncolumn_cluster_centers = column_cluster.cluster_centers_.reshape(ncols).tolist()\nsorted_column_cluster_centers = list(sorted(column_cluster_centers))\nfor i, col in enumerate(column_cluster_centers):\n    column_names[i] = gt_names[sorted_column_cluster_centers.index(col)]\nimage = Image.open(path)\nplt.rcParams['figure.figsize'] = [15, 15]\nax = plt.imshow(image, cmap='Greys_r')\nfor polygon in polygons:\n    vertices = [(polygon[0][i], polygon[0][i+1])\n                for i in range(0, len(polygon[0]), 2)]\n    # text = polygon[1]\n\n    box = polygon[0]\n    center = calc_center(box)\n    \n    x = center[0]\n    label = column_cluster.predict([[x]])[0]\n    label_count[label] += 1\n\n    patch = Polygon(vertices, closed=True, fill=False, linewidth=2, color=color_dict[label])\n    ax.axes.add_patch(patch)\n    plt.text(vertices[1][0], vertices[1][1], column_names[label], fontsize=10, va=\"top\", color=color_dict[label])\nplt.axis('off')\nplt.show()\nprint(label_count)\nname_count = {column_names[k]: v for k, v in label_count.items()}\nprint(name_count)","2411bb76":"def clsfy_sort(polygons, kmeans, ncols):\n    gt_names = ['number', 'name', 'nature', 'address']\n    column_names = {}\n    column_cluster_centers = kmeans.cluster_centers_.reshape(ncols).tolist()\n    sorted_column_cluster_centers = list(sorted(column_cluster_centers))\n    for i, col in enumerate(column_cluster_centers):\n        column_names[i] = gt_names[sorted_column_cluster_centers.index(col)]\n    polygons_col_dict = {k:[] for k in gt_names}\n    for i, poly in enumerate(polygons):\n        box, text = poly[0], poly[1]\n        center = calc_center(box)\n        x = center[0]\n        label = kmeans.predict([[x]])[0]\n        polygons_col_dict[column_names[label]].append(poly)\n    for name, poly in polygons_col_dict.items():\n        gety = lambda poly: calc_center(poly[0])[1]\n        poly.sort(key=gety)\n    return polygons_col_dict\n\ndef poly_union(poly1, poly2):\n    '''\n    polygon -- a tuple of format: ([\n        upper_left_x, \n        upper_left_y, \n        upper_right_x,\n        upper_right_y,\n        lower_right_x,\n        lower_right_y\n        lower_left_x,\n        lower_left_y], text)\n    '''\n    a1 = min(poly1[0][0], poly2[0][0])\n    a2 = min(poly1[0][1], poly2[0][1])\n    a3 = max(poly1[0][2], poly2[0][2])\n    a4 = min(poly1[0][3], poly2[0][3])\n    a5 = max(poly1[0][4], poly2[0][4])\n    a6 = max(poly1[0][5], poly2[0][5])\n    a7 = min(poly1[0][6], poly2[0][6])\n    a8 = max(poly1[0][7], poly2[0][7])\n    text = poly1[1]+' '+poly2[1]\n    return ([a1, a2, a3, a4, a5, a6, a7, a8], text)\n\ndef combine_same_row(polygons_col_dict, thr=0.5):\n    from copy import deepcopy\n    combined = deepcopy(polygons_col_dict)\n    for col_name, polys in polygons_col_dict.items():\n        if len(polys) <= 1:\n            continue\n        comb_is = []\n        for i in range(len(polys)-1):\n            iou = calc_iou(polys[i][0], polys[i+1][0])\n            if iou > thr:\n                comb_is.append(i)\n        for comb_i in comb_is:\n            combined[col_name][comb_i] = poly_union(combined[col_name][comb_i],combined[col_name][comb_i+1])\n        comb_is.sort()\n        for comb_i in reversed(comb_is):\n            del combined[col_name][comb_i+1]\n    return combined\npolygons_col_dict = clsfy_sort(polygons, column_cluster, ncols)\npolygons_col_dict=combine_same_row(polygons_col_dict)\npolygons_col_dict.keys()","da4a2492":"color_dict = {\n    0: 'y',\n    1: 'r',\n    2: 'b',\n    3: 'g'\n    }\nimage = Image.open(path)\nplt.rcParams['figure.figsize'] = [15, 15]\nax = plt.imshow(image, cmap='Greys_r')\ni = 0\nfor col_name, polys in polygons_col_dict.items():\n    for polygon in polys:\n        vertices = [(polygon[0][i], polygon[0][i+1])\n                    for i in range(0, len(polygon[0]), 2)]\n        box = polygon[0]\n        patch = Polygon(vertices, closed=True, fill=False, linewidth=2, color=color_dict[i])\n        ax.axes.add_patch(patch)\n        plt.text(vertices[1][0], vertices[1][1], col_name, fontsize=10, va=\"top\", color=color_dict[i])\n    i += 1\nplt.axis('off')\nplt.show()","7705a4e0":"def remove_non_digits(lst):\n    for i in range(len(lst)):\n        lst[i] = re.sub(\"[^0-9]\", \"\", lst[i])\n\ndef is_all_digit(s):\n    return all([c.isdigit() for c in s])\n\ndef autofill_address(lst):\n    if len(lst) < 2:\n        return\n    for i in range(len(lst)-1):\n        former, latter = lst[i], lst[i+1]\n        if is_all_digit(latter) and (not is_all_digit(former)):\n            omitted = ' '.join([word for word in former.split() if not is_all_digit(word)])\n            lst[i+1] = f'{latter} {omitted}'\n\ndef seg_row(polygons_col_dict):\n    polygons = []\n    for v in polygons_col_dict.values():\n        polygons.extend(v)\n    avgh = avg_h(polygons)\n    gt_names = ['number', 'name', 'nature', 'address']\n    rows_dict = {k:[] for k in gt_names}\n    for name in gt_names:\n        lasty = None\n        for poly in polygons_col_dict[name]:\n            box, text = poly[0], poly[1]\n            y = calc_center(box)[1]\n            if lasty is None:\n                rows_dict[name].append(text)\n            else:\n                # print((y-lasty)\/avgh)\n                gaps = int(((y-lasty)\/avgh)+0.5)\n                for _ in range(gaps-1):\n                    rows_dict[name].append('')\n                rows_dict[name].append(text)\n            lasty = y\n    # add empty strings to end of list\n    max_len = max([len(v) for v in rows_dict.values()])\n    for v in rows_dict.values():\n        for _ in range(max_len-len(v)):\n            v.append('')\n    #remove non-digits in 'number' column\n    remove_non_digits(rows_dict['number'])\n\n    #autofill omitted address\n    autofill_address(rows_dict['address'])\n    \n    # return rows_dict\n    return pd.DataFrame.from_dict(rows_dict)\nrows_df = seg_row(polygons_col_dict)\nprint(rows_df)","942bdf05":"plt.rcParams['figure.figsize'] = [15, 15]\nplt.imshow(Image.open(path), cmap='Greys_r')\nplt.axis('off')\nplt.show()","53c259ee":"# Show the raw image","aff0bac8":"# Read Cached MS OCR","bd33967b":"# Segment rows (on progress)","12bff26d":"# Define some utility functions","e94d14a2":"# Display OCR outputs","f30a8637":"# Denoise & Extract head information","241bfcb1":"# Define some global variables","e69da7b4":"# combine texts in the same row and column","f7d43a7c":"# Cluster columns with KMeans ","e8a4a105":"# Install & Import dependencies"}}