{"cell_type":{"ac42fe6c":"code","08e17598":"code","2305fe2f":"code","c805f981":"code","32a97ec2":"code","0e4b6bf9":"code","b18ce510":"code","47b76dbd":"code","928e5b81":"code","6929c3ed":"code","81dd1707":"code","a10233d5":"markdown"},"source":{"ac42fe6c":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport cv2\nimport math\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        pass\n        #print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","08e17598":"def global_gradient(img):\n    gradient_values_x = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)\n    gradient_values_y = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)\n    gradient_magnitude = cv2.addWeighted(gradient_values_x, 0.5, gradient_values_y, 0.5, 0)\n    gradient_angle = cv2.phase(gradient_values_x, gradient_values_y, angleInDegrees=True)\n    return gradient_magnitude,gradient_angle","2305fe2f":"def cell_gradient(cell_magnitude, cell_angle):\n        orientation_centers = [0] * bin_size\n        for i in range(cell_magnitude.shape[0]):\n            for j in range(cell_magnitude.shape[1]):\n                gradient_strength = cell_magnitude[i][j]\n                gradient_angle = cell_angle[i][j]\n                #print(\"gradient_strength\",gradient_strength)\n                #print(\"gradient_angle\",gradient_angle)\n                min_angle, max_angle, mod = get_closest_bins(gradient_angle)\n                #print(\"min_angle\",min_angle)\n                #print(\"max_angle\",max_angle)\n                #print(\"mod\",mod)\n                orientation_centers[min_angle] += (gradient_strength * (1 - (mod \/ angle_unit)))\n                orientation_centers[max_angle] += (gradient_strength * (mod \/ angle_unit))\n                #print(orientation_centers)\n        return orientation_centers","c805f981":" def get_closest_bins(gradient_angle):\n        idx = int(gradient_angle \/ angle_unit)\n        mod = gradient_angle % angle_unit\n        #print(\"idx\",idx)\n        #print(\"mod\",mod)\n        if idx == bin_size:\n            return idx - 1, (idx) % bin_size, mod\n        return idx, (idx + 1) % bin_size, mod","32a97ec2":"def extract(img):\n        height, width = img.shape\n        print(\"Image height :- \",height)\n        print(\"Image width :- \",width)\n        print(\"cell_size :- \",cell_size)\n        print(\"bin_size :- \",bin_size)\n        print(\"angle_unit :- \",angle_unit)\n        gradient_magnitude, gradient_angle = global_gradient(img)\n        gradient_magnitude = abs(gradient_magnitude)\n        cell_gradient_vector = np.zeros((int(height \/ cell_size), int(width \/ cell_size), bin_size))\n        print(\"cell_gradient_vector shape :- \",cell_gradient_vector.shape)\n        for i in range(cell_gradient_vector.shape[0]):\n            for j in range(cell_gradient_vector.shape[1]):\n                cell_magnitude = gradient_magnitude[i * cell_size:(i + 1) * cell_size,\n                                 j * cell_size:(j + 1) * cell_size]\n                cell_angle = gradient_angle[i * cell_size:(i + 1) * cell_size,\n                             j * cell_size:(j + 1) * cell_size]\n                cell_gradient_vector[i][j] = cell_gradient(cell_magnitude, cell_angle)\n\n        hog_image = render_gradient(np.zeros([height, width]), cell_gradient_vector)\n        hog_vector = []\n        for i in range(cell_gradient_vector.shape[0] - 1):\n            for j in range(cell_gradient_vector.shape[1] - 1):\n                block_vector = []\n                block_vector.extend(cell_gradient_vector[i][j])\n                block_vector.extend(cell_gradient_vector[i][j + 1])\n                block_vector.extend(cell_gradient_vector[i + 1][j])\n                block_vector.extend(cell_gradient_vector[i + 1][j + 1])\n                mag = lambda vector: math.sqrt(sum(i ** 2 for i in vector))\n                magnitude = mag(block_vector)\n                if magnitude != 0:\n                    normalize = lambda block_vector, magnitude: [element \/ magnitude for element in block_vector]\n                    block_vector = normalize(block_vector, magnitude)\n                hog_vector.append(block_vector)\n        return hog_vector, hog_image","0e4b6bf9":"def render_gradient(image, cell_gradient):\n        cell_width = cell_size \/ 2\n        max_mag = np.array(cell_gradient).max()\n        for x in range(cell_gradient.shape[0]):\n            for y in range(cell_gradient.shape[1]):\n                cell_grad = cell_gradient[x][y]\n                cell_grad \/= max_mag\n                angle = 0\n                angle_gap = angle_unit\n                for magnitude in cell_grad:\n                    angle_radian = math.radians(angle)\n                    x1 = int(x * cell_size + magnitude * cell_width * math.cos(angle_radian))\n                    y1 = int(y * cell_size + magnitude * cell_width * math.sin(angle_radian))\n                    x2 = int(x * cell_size - magnitude * cell_width * math.cos(angle_radian))\n                    y2 = int(y * cell_size - magnitude * cell_width * math.sin(angle_radian))\n                    cv2.line(image, (y1, x1), (y2, x2), int(255 * math.sqrt(magnitude)))\n                    angle += angle_gap\n        return image","b18ce510":"img = cv2.imread('..\/input\/hogfeatures\/man-walking.jpg', cv2.IMREAD_GRAYSCALE)\nimg=np.sqrt(img\/float(np.max(img)))\nimg=img*255\ncell_size=8\nbin_size=9\nangle_unit =360\/bin_size\n#hog = Hog_descriptor(img, cell_size=8, bin_size=8)\nvector, image = extract(img)\n","47b76dbd":"plt.figure(figsize=(15,15))\nplt.imshow(img, cmap=plt.cm.gray)\nplt.show()","928e5b81":"plt.figure(figsize=(15,15))\nplt.imshow(image, cmap=plt.cm.gray)\nplt.show()","6929c3ed":"vector=np.array(vector)","81dd1707":"vector.shape","a10233d5":"## HOG, or Histogram of Oriented Gradients, is a feature descriptor that is often used to extract features from image data. It is widely used in computer vision tasks for object detection**"}}