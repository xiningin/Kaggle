{"cell_type":{"5da654bd":"code","069b8b0f":"code","feb0b66a":"code","29292d31":"code","f891336a":"code","eb753fe7":"code","1330feba":"code","402e47c6":"code","c51daf41":"code","f03d5bed":"code","9f9c7dc2":"code","e1f5f228":"code","fb8e4075":"code","49f42f89":"code","abb185b3":"code","1c47f4ea":"code","58ec778f":"code","af07817a":"code","cd100d24":"code","04dd023f":"code","0a3b1166":"code","fd27cb9a":"markdown","0b20824c":"markdown","1c369bd2":"markdown","14cae927":"markdown","cb063095":"markdown","ff8d2de7":"markdown","425a4f96":"markdown","1a7b85b5":"markdown","ca56eae3":"markdown","d0aae261":"markdown","21e1ea5c":"markdown","7fb361e4":"markdown","3fddb643":"markdown","03583de4":"markdown","c46339ac":"markdown","787dcc21":"markdown","7cd7b4a5":"markdown","58b85b6d":"markdown","44249900":"markdown","7f49c43f":"markdown","5f7ce47f":"markdown","57a947b7":"markdown","a5b4fef7":"markdown","9e99d59c":"markdown","9468a6be":"markdown","00effed0":"markdown","0141b707":"markdown"},"source":{"5da654bd":"import numpy as np # Matrizes, opera\u00e7\u00f5es algebricas e matem\u00e1ticas\n\nimport matplotlib.pylab as plt # Biblioteca para visualiza\u00e7\u00e3o gr\u00e1fica\nimport matplotlib.animation as animation # Anima\u00e7\u00e3o das visualiza\u00e7\u00f5es \n\nimport warnings # Avisos levantados pelo c\u00f3digo\nfrom itertools import product as cartesian_product # Calcular produto cartesiano de arrays\n\nfrom pprint import pprint # Print mais bonito\nimport pickle # Salvar e ler objetos em arquivos\n\nfrom tqdm import tqdm # Temporizador de itera\u00e7\u00f5es\n\nimport IPython\nfrom IPython.display import HTML ","069b8b0f":"warnings.filterwarnings(\"ignore\") # Ignorar Avisos\nplt.rcParams['axes.titlepad'] = 30 # Aumentando a distancia do T\u00edtulo dos gr\u00e1ficos e o gr\u00e1fico","feb0b66a":"MAPA_ELEMENTOS = {\n    'vazio': 0,\n    'parede': 1,\n    'cabe\u00e7a': 2,\n    'corpo': 3,\n    'comida': 4,\n}\nMAPA_ELEMENTOS_REVERSO = {\n    0: 'vazio',\n    1: 'parede',\n    2: 'cabe\u00e7a',\n    3: 'corpo',\n    4: 'comida',\n}\nMAPA_CORES = {\n    0: np.array((65, 193, 79)),\n    1: np.array((75, 112, 47)),\n    2: np.array((27, 70, 158)),\n    3: np.array((70, 121, 241)),\n    4: np.array((233, 71, 29)),\n}","29292d31":"def criar_cenario(linhas=200, colunas=200):\n    # Criando a matriz do mapa (com mais 2 linhas e mais 2 colunas para serem paredes)\n    mapa = np.zeros(shape=(linhas+2, colunas+2)).astype(np.uint8)\n    \n    # preenchendo as bordas com parede\n    for cada_linha in range(linhas+2): # preenchendo as colunas 0 e N-1\n        mapa[cada_linha, 0] = MAPA_ELEMENTOS['parede']\n        mapa[cada_linha, colunas+1] = MAPA_ELEMENTOS['parede']\n        \n    for cada_coluna in range(colunas+2): # preenchendo as linhas 0 e M-1\n        mapa[0, cada_coluna] = MAPA_ELEMENTOS['parede']\n        mapa[linhas+1, cada_coluna] = MAPA_ELEMENTOS['parede']\n    return mapa","f891336a":"def substituir_cores(mapa, mapa_cores=MAPA_CORES):\n    # Pega as dimens\u00f5es do mapa\n    linhas, colunas = mapa.shape\n    matriz_mapa_cores = np.zeros(shape=(linhas, colunas, 3)).astype(np.uint8)\n\n    # Percorre cada bloco no mapa\n    for cada_linha in range(linhas):\n        for cada_coluna in range(colunas):\n            # substitui as cores\n            matriz_mapa_cores[cada_linha, cada_coluna] = mapa_cores[mapa[cada_linha, cada_coluna]]\n    return matriz_mapa_cores","eb753fe7":"def renderizar_cena_jogo(matriz_mapa, mapa_cores=MAPA_CORES, figura_tamanho=[]):\n    # Invertemos X, Y pois meio que o numpy trabalha com a matriz ao contr\u00e1rio.\n    x, y = matriz_mapa.shape[::-1]\n    \n    # Define um tamanho para o gr\u00e1fico em polegadas\n    if figura_tamanho:\n        plt.figure(figsize=figura_tamanho)\n    else: \n        plt.figure(figsize=np.array([x, y])\/5)\n        \n    # Gera o mapa com pixeis RGB\n    matriz_mapa_cores = substituir_cores(matriz_mapa, MAPA_CORES)\n    \n    # Exibe o gr\u00e1fico\n    plt.imshow(matriz_mapa_cores, aspect='auto')\n    plt.axis('off')\n    plt.show();","1330feba":"def gerar_comida(matriz_mapa, posicao_inicial=None):\n    # Se n\u00e3o estiver definida uma posi\u00e7\u00e3o inicial \n    if not posicao_inicial:\n        linhas, colunas = matriz_mapa.shape\n        # Geramos pontos aleat\u00f3rios dentre a \u00e1rea acessivel do mapa at\u00e9 achar algo vago\n        x = np.random.randint(low=1, high=colunas-2)\n        y = np.random.randint(low=1, high=linhas-2)\n        while matriz_mapa[y, x] != MAPA_ELEMENTOS['vazio']:\n            x = np.random.randint(low=1, high=colunas-2)\n            y = np.random.randint(low=1, high=linhas-2)\n    else:\n        # Caso contr\u00e1rio apenas usamos as posi\u00e7\u00f5es desejadas\n        x, y = posicao_inicial\n    \n    # invertemos X, y pela diferen\u00e7a de Matriz e plano cartesiano.\n    matriz_mapa[y, x] = MAPA_ELEMENTOS['comida']\n    \n    # Retornamos a posi\u00e7\u00e3o da Comida gerada \n    return (x, y)","402e47c6":"class Cobra():\n    \n    # Inicializa\u00e7\u00e3o da classe, ela recebe o mapa, uma posivel posi\u00e7\u00e3o\n    # inicial e um poss\u00edvel tamanho inicial\n    def __init__(self, mapa, posicao_inicial=None, tamanho_inicial=1):\n        \n        # Definindo as vari\u00e1veis internamente\n        self.mapa = mapa\n        self.size = tamanho_inicial\n        self.movimentos_rastro = []\n        self.jogadas = 0\n        \n        #  Se nenhuma posi\u00e7\u00e3o inicial foi passada crie uma\n        # aleat\u00f3riamente dentre o espa\u00e7o dispon\u00edvel\n        if not posicao_inicial:\n            linhas, colunas = mapa.shape\n            self.x = np.random.randint(low=1, high=colunas-2)\n            self.y = np.random.randint(low=1, high=linhas-2)\n            while self.mapa[self.y, self.x] != MAPA_ELEMENTOS['vazio']:\n                self.x = np.random.randint(low=1, high=colunas-2)\n                self.y = np.random.randint(low=1, high=linhas-2)\n        else:\n            self.x, self.y = posicao_inicial\n        \n        # Para simular a ideia de corpo da cobra, podemos criar um\n        # array que vai conter as ultimas posi\u00e7\u00f5es do corpo da cobra\n        # sempre o ultimo elemento desse array vai ser a cabe\u00e7a. \n        self.movimentos_rastro.append([self.x, self.y])    \n        self.mapa[self.y, self.x] = MAPA_ELEMENTOS['cabe\u00e7a']\n        \n        # Caso nos precisarmos de criar uma cobra que j\u00e1 come\u00e7a com\n        # um corpo grande, podemos tentar criar o corpo de forma reta\n        # at\u00e9 encontrar algum bloqueio e mudar a dire\u00e7\u00e3o do crescimento. \n        if tamanho_inicial > 1:\n            base_x, base_y = self.x, self.y\n            for i in range(1, tamanho_inicial):\n                esquerda = (base_y, base_x - 1)\n                acima = (base_y - 1, base_x)\n                direita = (base_y, base_x + 1)\n                abaixo = (base_y + 1, base_x)\n                encontrou = 0\n                posicoes_possiveis = [esquerda, acima, direita, abaixo]\n                for possivel_y, possivel_x in posicoes_possiveis:\n                    if self.mapa[possivel_y, possivel_x] == MAPA_ELEMENTOS['vazio']:\n                        self.movimentos_rastro.append([possivel_x, possivel_y])    \n                        self.mapa[possivel_y, possivel_x] = MAPA_ELEMENTOS['corpo']\n                        base_x, base_y = possivel_x, possivel_y\n                        encontrou = 1\n                        break\n                if encontrou == 0:\n                    self.size = i \n            self.movimentos_rastro = self.movimentos_rastro[::-1]\n                \n    # Se precisarmos obter a localiza\u00e7\u00e3o da cabe\u00e7a da cobra\n    def obter_posicao_cabeca(self):\n        return (self.x, self.y)\n\n    # Se quisermos saber o tamanho da cobra a qualquer momento do jogo\n    def obter_tamanho(self):\n        return self.size\n        \n    # Para impedir os movimentos inv\u00e1lidos, vamos bloquear movimentos \n    # para a dire\u00e7\u00e3o do corpo (por exemplo da cae\u00e7a para traz\n    # Assim com essa fun\u00e7\u00e3o vamos saber qual a dire\u00e7\u00e3o do pesco\u00e7o\n    # de frente da cabe\u00e7a.\n    def obter_posicao_pescoco(self):\n        resposta = None\n        \n        # So vai acontecer quando a cobra tiver um tamanho maior que 1\n        if len(self.movimentos_rastro) >= 2:\n            x_pescoco, y_pescoco = self.movimentos_rastro[-2]\n            if x_pescoco == self.x and y_pescoco == self.y - 1:\n                resposta = 'ACIMA'\n            elif x_pescoco == self.x and y_pescoco == self.y + 1:\n                resposta = 'ABAIXO'\n            elif x_pescoco == self.x - 1 and y_pescoco == self.y:\n                resposta = 'ESQ'\n            elif x_pescoco == self.x + 1 and y_pescoco == self.y:\n                resposta = 'DIR'\n        \n        return resposta\n    \n    # Com essa fun\u00e7\u00e3o vai ser possivel obter informa\u00e7\u00f5es do ambiente\n    # que est\u00e1 visivel para a cobra\n    def obter_area_cabeca(self):\n        esquerda = self.mapa[self.y, self.x - 1]\n        acima = self.mapa[self.y - 1, self.x]\n        direita = self.mapa[self.y, self.x + 1]\n        abaixo = self.mapa[self.y + 1, self.x]\n        \n        # Retorna um array com as posi\u00e7\u00f5es acima, abaixo\n        # a direita e a esquerda da cabe\u00e7a da cobra\n        return (esquerda, acima, direita, abaixo)\n    \n    # Quando a cobra se movimentar, usamos essa fun\u00e7\u00e3o para apagar\n    # seu rastro ao longo da movimenta\u00e7\u00e3o, e deixar apenas o tamanho definido.\n    def eliminar_rastro(self):\n        tamanho_rastro = len(self.movimentos_rastro)\n        if (tamanho_rastro > self.size):\n            for i in range(0, tamanho_rastro - self.size):\n                x_antigo, y_antigo = self.movimentos_rastro[0]\n                self.mapa[y_antigo, x_antigo] = MAPA_ELEMENTOS['vazio']\n                self.movimentos_rastro.pop(0)\n    \n    # Executa a movimenta\u00e7\u00e3o da cobrinha\n    def movimento(self, direcao:str):\n        if (direcao == 'ESQ'):\n            new_x = self.x - 1\n            new_y = self.y\n        elif (direcao == 'DIR'):\n            new_x = self.x + 1\n            new_y = self.y\n        elif (direcao == 'ACIMA'):\n            new_x = self.x\n            new_y = self.y - 1\n        elif (direcao == 'ABAIXO'):\n            new_x = self.x \n            new_y = self.y + 1\n            \n        bloco_alvo = self.mapa[new_y, new_x]\n        if bloco_alvo == MAPA_ELEMENTOS['comida']:\n            self.size+=1\n        self.mapa[self.y , self.x] = MAPA_ELEMENTOS['corpo']\n        self.mapa[new_y, new_x] = MAPA_ELEMENTOS['cabe\u00e7a']\n        self.x, self.y = new_x, new_y\n        \n        # Elimina os rastros\n        self.movimentos_rastro.append([new_x, new_y])\n        self.eliminar_rastro()\n        self.jogadas+=1\n        return bloco_alvo","c51daf41":"class QLearn:\n    \n    # Inicializamos o Algoritmo de Q-learning\n    def __init__(self, epsilon=0.2, alpha = 0.05, gamma = 0.001):\n        \n        self.qtable = None # Nossa Q-table\n        self.epsilon = epsilon # valor de explora\u00e7\u00e3o \n        self.alpha = alpha # Taxa de aprendizado\n        self.gamma = gamma # Taxa de peso para possibilidades futuras\n        \n        # Poss\u00edveis a\u00e7\u00f5es a serem tomadas\n        self.acoes = {\n            0: 'ESQ',\n            1: 'ACIMA',\n            2: 'DIR',\n            3: 'ABAIXO',\n        }\n        # Poss\u00edveis a\u00e7\u00f5es a serem tomadas Invertida\n        self.acoes_rev = {\n            'ESQ': 0,\n            'ACIMA': 1,\n            'DIR': 2,\n            'ABAIXO': 3,\n        }\n        self.inicializar_qtable()\n        \n    # Inicializa a Qtabel com valores zerados.\n    def inicializar_qtable(self):\n        nova_qtable = {}\n        horizontal_comida = [-1, 0, 1] \n        vertical_comida = [-1, 0, 1]\n        blocos = list(cartesian_product(*[[MAPA_ELEMENTOS['parede'],MAPA_ELEMENTOS['vazio']]] * 4))\n\n        valores_base = np.array([0,0,0,0], dtype=np.float)\n        \n        for i in horizontal_comida:\n            for j in vertical_comida:\n                for esquerda, acima, direita, abaixo in blocos:\n                    nova_qtable[self.estado_str(i, j, esquerda, acima, direita, abaixo)] = valores_base.copy()\n        self.qtable = nova_qtable\n        \n    # Verifica se o bloco em quest\u00e3o \u00e9 pass\u00e1vel ou n\u00e3o\n    def __bloco_passavel(self, bloco):\n        if bloco in (MAPA_ELEMENTOS['corpo'], MAPA_ELEMENTOS['parede']):\n            resposta = 1\n        else:\n            resposta = 2\n        return resposta\n    \n    # Calcula o direcionamento diante da comida\n    def __posicao_comida(self, distancia):\n        if distancia > 0 :\n            resposta = 1\n        elif distancia < 0 :\n            resposta = -1\n        else:\n            resposta = 0\n        return resposta\n        \n    # Gera a string que representa o estado do ambiente naquele momento\n    def estado_str(self, horizontal_comida, vertical_comida, bloco_esq, bloco_acima, bloco_dir, bloco_abaixo):\n        resposta = \"(H:{}|V:{}|ESQ:{}|ACI:{}|DIR:{}|ABA:{})\".format(\n            self.__posicao_comida(horizontal_comida),\n            self.__posicao_comida(vertical_comida),\n            self.__bloco_passavel(bloco_esq),\n            self.__bloco_passavel(bloco_acima),\n            self.__bloco_passavel(bloco_dir),\n            self.__bloco_passavel(bloco_abaixo)\n        )\n        return resposta\n    \n    # Gera a string que representa o estado do ambiente naquele momento\n    def fazer_acao(self, posicao_comida, posicao_cobra, cobra_proximidades, posicao_pescoco=None):\n        \n        \n        comida_x, comida_y = posicao_comida\n        cobra_x, cobra_y = posicao_cobra\n        \n        cobra_esq, cobra_aci, cobra_dir, cobra_aba = cobra_proximidades\n        \n        distancia_cobra_comida_x = cobra_x - comida_x\n        distancia_cobra_comida_y = cobra_y - comida_y\n        \n        estado = self.estado_str(distancia_cobra_comida_x, distancia_cobra_comida_y, cobra_esq, cobra_aci, cobra_dir, cobra_aba)\n        valores = self.qtable[estado]\n                \n        resultado = None\n        acao = np.random.choice(['explore', 'exploit'], p=[self.epsilon, 1-self.epsilon],size=1)\n        valores_iguais = np.all([valores[0] == valores])\n\n        movimento_valido = list(filter(lambda x: x!= posicao_pescoco, list(ql.acoes.values())))\n          \n        if acao == 'explore' or valores_iguais:\n            resultado = np.random.choice(movimento_valido)\n        else: \n            maior_index = np.argmax(valores)\n            resultado = self.acoes[maior_index]\n        \n        return resultado    \n    \n    # Com essa fun\u00e7\u00e3o conseguimos pegar um hist\u00f3rico de jogadas e atualizar a tabela.\n    def atualizar_qtable(self, historia_status, morreu):\n        historia = historia_status[::-1]\n        if morreu:\n            recompensa = -100\n            acao = historia[0]['movimento']\n            \n            comida_x, comida_y = historia[0]['comida']\n            cobra_x, cobra_y = historia[0]['cobra']\n\n            cobra_esq, cobra_aci, cobra_dir, cobra_aba = historia[0]['cobra_proximidades']\n\n            distancia_cobra_comida_x = cobra_x - comida_x\n            distancia_cobra_comida_y = cobra_y - comida_y\n            \n\n            estado = self.estado_str(distancia_cobra_comida_x, distancia_cobra_comida_y, cobra_esq, cobra_aci, cobra_dir, cobra_aba)\n            valor_antigo = self.qtable[estado][self.acoes_rev[acao]]\n            valor_novo = (1-self.alpha) * valor_antigo + self.alpha * recompensa\n            self.qtable[estado][self.acoes_rev[acao]] = valor_novo \n        for en, momento in enumerate(historia[1:-1], start=1):\n  \n            # Estado atual\n            acao = momento['movimento']\n            tamanho = momento['tamanho']\n            comida_x, comida_y = momento['comida']\n            cobra_x, cobra_y = momento['cobra']\n            cobra_esq, cobra_aci, cobra_dir, cobra_aba = momento['cobra_proximidades']\n            distancia_cobra_comida_x = cobra_x - comida_x\n            distancia_cobra_comida_y = cobra_y - comida_y\n            \n            # Estado anterior:\n            momento_anterior = historia[en + 1]\n            acao_anterior = momento_anterior['movimento']\n            tamanho_anterior = momento_anterior['tamanho']\n            comida_x_anterior, comida_y_anterior = momento_anterior['comida']\n            cobra_x_anterior, cobra_y_anterior = momento_anterior['cobra']\n            cobra_esq_anterior, cobra_aci_anterior, cobra_dir_anterior, cobra_aba_anterior = momento_anterior['cobra_proximidades']\n            distancia_cobra_comida_x_anterior = cobra_x_anterior - comida_x_anterior\n            distancia_cobra_comida_y_anterior = cobra_y_anterior - comida_y_anterior\n            \n            # Recompensa:\n            distancia_piorou = np.abs(distancia_cobra_comida_x) > np.abs(distancia_cobra_comida_x_anterior)\n            distancia_piorou = distancia_piorou or np.abs(distancia_cobra_comida_y) > np.abs(distancia_cobra_comida_y_anterior)\n            \n            if tamanho > tamanho_anterior:\n                recompensa = 100\n            elif distancia_piorou:\n                recompensa = -90\n            else:\n                recompensa = 90\n                \n            estado_atual = self.estado_str(\n                distancia_cobra_comida_x, \n                distancia_cobra_comida_y, \n                cobra_esq, \n                cobra_aci, \n                cobra_dir, \n                cobra_aba\n            )\n            estado_anterior = self.estado_str(\n                distancia_cobra_comida_x_anterior, \n                distancia_cobra_comida_y_anterior, \n                cobra_esq_anterior, \n                cobra_aci_anterior, \n                cobra_dir_anterior, \n                cobra_aba_anterior\n            )\n            \n            \n            valor_anterior = self.qtable[estado_anterior][self.acoes_rev[acao_anterior]]\n            valor_atual = self.qtable[estado_atual]\n            \n            valor_anterior_novo = ((1-self.alpha)*(valor_anterior)) + (self.alpha * (recompensa + (self.gamma*valor_atual.max())))\n            self.qtable[estado_anterior][self.acoes_rev[acao_anterior]] = valor_anterior_novo","f03d5bed":"def save_qtable(QL, filename='.\/pickle\/qtable.pk'):\n    with open(filename, 'wb') as f:\n        pickle.dump(QL, f)","9f9c7dc2":"def read_qtable(filename='.\/pickle\/qtable.pk'):\n    res = None\n    with open(filename, 'rb') as f:\n        res = pickle.load(f)\n    return res","e1f5f228":"%matplotlib notebook\ndef gerar_historia_status(historia_status, mapa_cores=MAPA_CORES, duration_frame= 100):\n    historia = []\n    frames = 0 \n    for cada_status in historia_status: \n        historia.append(substituir_cores(cada_status['mapa'], mapa_cores))\n        frames+=1\n        \n    x, y = historia_status[0]['mapa'].shape[::-1]\n    figura = plt.figure(figsize=np.array([x, y])\/5, )\n    plt.axis('off');\n    primeira_cena = historia[0]\n    imagem = plt.imshow(primeira_cena, aspect='auto');\n    \n    def funcao_animacao(i):\n        imagem.set_array(historia[i])\n        return [imagem]\n    animacao = animation.FuncAnimation(\n       figura, \n       funcao_animacao, \n       frames = frames,\n       interval = duration_frame, # in ms\n    );\n    return animacao;","fb8e4075":"def jogos_aleatorios():\n    cobra_size = 1\n    if np.random.choice([False, True], p=[0.7, 0.3]):\n        cobra_size  = np.random.randint(2, 12)\n    return cobra_size","49f42f89":"ql = QLearn(epsilon=1)","abb185b3":"epocas_treino = 10000\nepocas_teste = 1000\ncenario_base = {\"linhas\":20, 'colunas':30}\n","1c47f4ea":"historia_jogo = []\nstatus_base = {\n    'tamanho': None,\n    'mapa': None,\n    'comida': None,\n    'cobra': None,\n    'cobra_proximidades': None,\n    'movimento': None\n}","58ec778f":"# inicializando o mapa\nmatriz_mapa_inicial = criar_cenario(**cenario_base)\n\n# Gerando v\u00e1rias jogos de treinamento (todos aleat\u00f3rios)\nfor epoca in tqdm(range(0, epocas_treino)):\n    # Inicializando Rodada\n    historia_jogo = []\n    cobra_tamanho_inicial = jogos_aleatorios()\n    matriz_mapa = matriz_mapa_inicial.copy()\n    cobra = Cobra(matriz_mapa, tamanho_inicial=cobra_tamanho_inicial)\n    posicao_comida = gerar_comida(matriz_mapa)\n    morreu = False \n    jogadas = 0\n    while not morreu: \n        posicao_cobra = cobra.obter_posicao_cabeca()\n        cobra_proximidades = cobra.obter_area_cabeca()\n        status = status_base.copy()\n        status['mapa'] = matriz_mapa.copy()\n        status['tamanho'] = cobra.obter_tamanho()\n        status['comida'] = posicao_comida\n        status['cobra'] = posicao_cobra\n        status['cobra_proximidades'] = cobra_proximidades\n        movimento = ql.fazer_acao(posicao_comida, posicao_cobra, cobra_proximidades, cobra.obter_posicao_pescoco())\n        status['movimento'] = movimento\n        historia_jogo.append(status)\n        bloco_cobra = cobra.movimento(movimento)\n        jogadas+=1\n        if bloco_cobra == MAPA_ELEMENTOS['comida']:\n            posicao_comida = gerar_comida(matriz_mapa)\n        elif bloco_cobra in (MAPA_ELEMENTOS['parede'],MAPA_ELEMENTOS['corpo']):\n            morreu = True\n    ql.atualizar_qtable(historia_jogo, morreu)","af07817a":"ql.epsilon = 0","cd100d24":"max_jogo_historia = []\nmax_score = 10\nmax_jogadas = 0","04dd023f":"%matplotlib inline\n\n# inicializando o mapa\nmatriz_mapa_inicial = criar_cenario(**cenario_base)\n\nfor i in tqdm(range(epocas_teste)):\n    historia_jogo = []\n    matriz_mapa = matriz_mapa_inicial.copy()\n    cobra = Cobra(matriz_mapa, tamanho_inicial=1)\n    posicao_comida = gerar_comida(matriz_mapa)\n    morreu = False \n    jogadas = 0\n    while not morreu: \n        posicao_cobra = cobra.obter_posicao_cabeca()\n        cobra_proximidades = cobra.obter_area_cabeca()\n        status = status_base.copy()\n        status['mapa'] = matriz_mapa.copy()\n        status['tamanho'] = cobra.obter_tamanho()\n        status['comida'] = posicao_comida\n        status['cobra'] = posicao_cobra\n        status['cobra_proximidades'] = cobra_proximidades\n        movimento = ql.fazer_acao(posicao_comida, posicao_cobra, cobra_proximidades, cobra.obter_posicao_pescoco())\n        status['movimento'] = movimento\n        historia_jogo.append(status)\n        bloco_cobra = cobra.movimento(movimento)\n        jogadas+=1\n        if bloco_cobra == MAPA_ELEMENTOS['comida']:\n            posicao_comida = gerar_comida(matriz_mapa)\n        elif bloco_cobra in (MAPA_ELEMENTOS['parede'],MAPA_ELEMENTOS['corpo']):\n            morreu = True\n        \n    ql.atualizar_qtable(historia_jogo, morreu)\n    if max_score < cobra.obter_tamanho():\n        max_jogo_historia = historia_jogo.copy()\n        max_score = cobra.obter_tamanho()\n        max_jogadas = jogadas\n        print(\"Joagas: {} | Tamanho: {}\".format(max_jogadas, max_score))","0a3b1166":"%matplotlib notebook\nHTML(gerar_historia_status(max_jogo_historia, mapa_cores=MAPA_CORES, duration_frame=70).to_jshtml())\n# HTML(gerar_historia_status(max_jogo_historia, mapa_cores=MAPA_CORES, duration_frame=100).to_html5_video())","fd27cb9a":"Com a fun\u00e7\u00e3o a baixo, vamos conseguir gerar uma sequ\u00eancia de matrizes como uma hist\u00f3ria animada e transforma-l\u00e1 em v\u00eddeo.","0b20824c":"### Cobra\n\nAgora vamos definir a Cobrinha do nosso jogo, como uma estrutura um pouco mais consistente. \n\nComo a cobra tem v\u00e1rias fun\u00e7\u00f5es e tudo mais, vamos gerar uma classe para armazenar tudo em um lugar s\u00f3. ","1c369bd2":"### Jogos aleat\u00f3rios","14cae927":"## Importa\u00e7\u00e3o das bibliotecas Necess\u00e1rias ","cb063095":"### Renderizar Cena\n\nEsse m\u00e9todo n\u00e3o vai ser crucial para o Jogo, mas vamos utiliza-lo bastante para gerar \"**prints**\" do jogo e exibilas:","ff8d2de7":"## Classes do Jogo","425a4f96":"## O Jogo","1a7b85b5":"### Gerar Comida\n\nPor meio dessa fun\u00e7\u00e3o vamos criar pontos no mapa que ser\u00e3o as comidas. \n\nVamos criar comida apenas onde houver blocos vazios. ","ca56eae3":"## Funcionalidades do Jogo ","d0aae261":"### Salvar Q-Table","21e1ea5c":"### Treinamento ","7fb361e4":"### Substituir Cores\n\nComo precisamos visualizar o jogo de forma bonitinha, vamos substituir cada bloco no mapa por um vetor contendo a cor do bloco desejado, para isso que criamos a vari\u00e1vel `MAPA_CORES`","3fddb643":"### Pratico ","03583de4":"## Configura\u00e7\u00f5es do Jogo - Part. 2","c46339ac":"### Ler Q-Table","787dcc21":"`MAPA_ELEMENTOS` vai ser uma forma de transformar elementos em n\u00fameros.\n\n`MAPA_ELEMENTOS_REVERSO` \u00e9 o mapeamento ao contr\u00e1rio, de n\u00fameros para texto.\n\n`MAPA_CORES` \u00e9 uma forma de transformar os elementos do mapa em suas respectivas cores em RGB.","7cd7b4a5":"### Gerar Cen\u00e1rio\n\nVamos criar aqui uma fun\u00e7\u00e3o que vai criar um c\u00e9nario de jogo, assim que receber o tamanho de Linhas e Colunas.\n\nO mapa vai ser criado com mais 2 linhas e mais 2 colunas, para serem as colunas, ou seja, definimos apenas o espa\u00e7o Jog\u00e1vel do mapa ","58b85b6d":"## Configura\u00e7\u00f5es do Jogo - Part. 1","44249900":"A fun\u00e7\u00e3o abaixo, faz com que o jogo tenha estados iniciais diferentes.","7f49c43f":"As vezes, mesmo com as bibliotecas importadas, precisamos fazer algumas configura\u00e7\u00f5es para utiliza-las","5f7ce47f":"Vamos criar aqui 2 fun\u00e7\u00f5es, uma para salvar e outra para ler Qtable em arquivos. ","57a947b7":"### Q-Learn\n\nTodo o processo de aprendizagem e tomada de decis\u00e3o vai ficar por responsabilidade da classe de Qlearn\n\nNessa vai ficar contida todo o processo de aprendizagem ","a5b4fef7":"***","9e99d59c":"# Snake Game com Q-Learn\n\nUtilizando Q-learning, fazendo a implementa\u00e7\u00e3o do zero para fazer o jogo da cobrinha funcionar.\n\nO jogo vai ser basicamente uma anima\u00e7\u00e3o matricial, mas vai ser o suficiente para implementarmos e praticarmos o algoritmo","9468a6be":"Vamos importar abaixo as bibliotecas que vamos utilizar para a implementa\u00e7\u00e3o completa do c\u00f3digo","00effed0":"## Configura\u00e7\u00e3o inicial das bibliotecas importandas","0141b707":"## Gerar Anima\u00e7\u00e3o da Hist\u00f3ria"}}