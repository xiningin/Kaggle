{"cell_type":{"7a08c54b":"code","01ead51e":"code","91adfecd":"code","d1dfaa02":"code","802728cc":"code","86fdb58f":"code","6bad9434":"code","835bad62":"code","c77b88a9":"code","8c44a028":"code","ea6299d3":"code","f132d98a":"markdown","dfc43323":"markdown","0064d8d0":"markdown","957a05a6":"markdown","32edd57a":"markdown"},"source":{"7a08c54b":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib\nfrom collections import Counter\nfrom tqdm import tqdm, tqdm_notebook","01ead51e":"d = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/family_data.csv')\nsample_submission = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/sample_submission.csv')\n\nN_DAYS = 100\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\n\nfamily_size_dict = d[['n_people']].to_dict()['n_people']\ncols = [f'choice_{i}' for i in range(10)]\nchoice_dict = d[cols].to_dict()\ndays = list(range(N_DAYS,0,-1))","91adfecd":"## Faster cost function, from https:\/\/www.kaggle.com\/nickel\/250x-faster-cost-function-with-numba-jit\n\nfrom numba import njit\n\nprediction = sample_submission['assigned_day'].values\ndesired = d.values[:, 1:-1]\nfamily_size = d.n_people.values\npenalties = np.asarray([\n    [\n        0,\n        50,\n        50 + 9 * n,\n        100 + 9 * n,\n        200 + 9 * n,\n        200 + 18 * n,\n        300 + 18 * n,\n        300 + 36 * n,\n        400 + 36 * n,\n        500 + 36 * n + 199 * n,\n        500 + 36 * n + 398 * n\n    ] for n in range(family_size.max() + 1)\n])\n\n@njit()\ndef jited_cost(prediction, desired, family_size, penalties):\n    N_DAYS = 100\n    MAX_OCCUPANCY = 300\n    MIN_OCCUPANCY = 125\n    penalty = 0\n    daily_occupancy = np.zeros(N_DAYS + 1, dtype=np.int64)\n    for i in range(len(prediction)):\n        n = family_size[i]\n        pred = prediction[i]\n        n_choice = 0\n        for j in range(len(desired[i])):\n            if desired[i, j] == pred:\n                break\n            else:\n                n_choice += 1\n        \n        daily_occupancy[pred - 1] += n\n        penalty += penalties[n, n_choice]\n\n    accounting_cost = 0\n    n_out_of_range = 0\n    constraint = 0\n    daily_occupancy[-1] = daily_occupancy[-2]\n    for day in range(N_DAYS):\n        n_next = daily_occupancy[day + 1]\n        n = daily_occupancy[day]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        constraint += 1_000_000 * max( 0, n - MAX_OCCUPANCY, MIN_OCCUPANCY - n )\n        diff = abs(n - n_next)\n        accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n\n    total = penalty + accounting_cost + constraint\n    return np.asarray([total, penalty, n_out_of_range * 1_000_000, accounting_cost, n_out_of_range])","d1dfaa02":"def plot_occupancy(prediction):\n    occupancy = {k:0 for k in days}\n    for family, day in enumerate(prediction):\n        occupancy[day] += family_size_dict[family]    \n    x = occupancy.keys()\n    y = occupancy.values()\n    z = [ 'C0' if u >= MIN_OCCUPANCY and u <= MAX_OCCUPANCY else 'C1' for u in y ]\n    fig, ax = plt.subplots(figsize=(20,5))\n    ax.axhline(MIN_OCCUPANCY, color='black')\n    ax.axhline(MAX_OCCUPANCY, color='black')\n    ax.bar(x, y, color=z)\n    ax.set_ylabel( \"Occupancy\" )\n    ax.set_xlabel( \"Day\" )\n    plt.show()","802728cc":"def plot_choices(prediction):\n    m = np.zeros( (11,len(prediction)) )\n    for family, day in enumerate(prediction):\n        choices = [ f\"choice_{i}\" for i in range(10) ]\n        choices = [ choice_dict[c][family] for c in choices ]\n        i = np.where( [ day == c for c in choices + [day] ] )[0][0]\n        m[i,family] = 1\n        \n    # Re-order the families by day\n    i = np.argsort(prediction)\n    m = m[ : , i]\n    \n    fig, ax = plt.subplots( figsize=(20,4))\n    ax.pcolor(m)\n    ax.set_yticks(np.arange(m.shape[0]) + 0.5, minor=False)\n    ax.set_yticklabels( list(range(10)) + ['other'], minor=False)\n    ax.set_xlabel(\"Family (in chronological order)\") \n    ax.set_ylabel(\"Choice\")\n    plt.show()","86fdb58f":"def get_accounting_cost(prediction, desired, family_size, penalties):\n    N_DAYS = 100\n    MAX_OCCUPANCY = 300\n    MIN_OCCUPANCY = 125\n    penalty = 0\n    \n    daily_occupancy = np.zeros(N_DAYS + 1, dtype=np.int64)\n    for i in range(len(prediction)):\n        daily_occupancy[prediction[i] - 1] += family_size[i]\n\n    accounting_costs = np.zeros(N_DAYS)\n    daily_occupancy[-1] = daily_occupancy[-2]\n    for day in range(N_DAYS):\n        n_next = daily_occupancy[day + 1]\n        n = daily_occupancy[day]\n        diff = abs(n - n_next)\n        accounting_costs[day] = max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n\n    return accounting_costs\n\ndef plot_accounting_costs(prediction):\n    accounting_costs = get_accounting_cost(prediction, desired, family_size, penalties)\n    fig, ax = plt.subplots( figsize=(20,4))\n    ax.bar( range(N_DAYS), accounting_costs )\n    ax.set_xlabel(\"Day\")\n    ax.set_ylabel(\"Accounting cost\")\n    plt.show()","6bad9434":"# Random, uniform solution\nprint( jited_cost(sample_submission['assigned_day'].values, desired, family_size, penalties)[0] )\nplot_occupancy(sample_submission['assigned_day'])\nplot_choices(sample_submission['assigned_day'])\nplot_accounting_costs(sample_submission['assigned_day'])","835bad62":"# Grant everyone their first wish\n\ncols = [f'choice_{i}' for i in range(10)]\nchoices = d[cols].T.to_dict()\nchoices = { k: list(v.values()) for k,v in choices.items() }\nsolution = np.array( [ choices[i][0] for i in range( sample_submission.shape[0] ) ] )\n\nprint( jited_cost(solution, desired, family_size, penalties)[0] )\nplot_occupancy(solution)\nplot_choices(solution)\n#plot_accounting_costs(solution) # Too high","c77b88a9":"best = sample_submission['assigned_day'].values\nbest_cost = jited_cost(best, desired, family_size, penalties)[0]","8c44a028":"N = 100_000   # Increase this\nwith tqdm_notebook(total=N) as pbar:\n    for _ in range(N):\n        candidate = best.copy()\n\n        # Pick a neighbouring solution, for various notions of \"neighbourhood\":\n        # - Reassign a family, but only among its choices\n        # - Reassign a family, anywhere\n        # - Swap two families \n        \n        p = [.98, .01, .01] # Play with those probabilities\n        which = np.random.choice(3, p=p)\n\n        if which == 0:\n            # Re-assign one family, but only among its choices\n            i = np.random.choice( len(candidate) )\n            k = np.random.choice( choices[i] )\n            candidate[i] = k\n\n        if which == 1:\n            # Re-assign one family, anywhere\n            i = np.random.choice( len(candidate) )\n            k = np.random.choice( N_DAYS ) + 1\n            candidate[i] = k\n\n        if which == 2:\n            # Swap two families\n            i1 = np.random.choice( len(candidate) )\n            i2 = np.random.choice( len(candidate)-1 )\n            if i2 >= i1:\n                i2 = i2 + 1\n            k = candidate[i1]\n            candidate[i1] = candidate[i2]\n            candidate[i2] = k\n\n        #cost = cost_function(candidate)\n        cost = jited_cost(candidate, desired, family_size, penalties)\n        if cost[0] < best_cost:\n            best = candidate\n            best_cost = cost[0]\n            pbar.set_description(f\"{round(cost[0])} ({int(cost[4])}) {which}\")    \n        pbar.update(1)","ea6299d3":"print( jited_cost(best, desired, family_size, penalties)[0] )\nplot_occupancy(best)\nplot_choices(best)\nplot_accounting_costs(best)","f132d98a":"- Functions to plot a solution, with the occupancy per day, the satisfaction of each family, and the accounting cost.\n- A simple solution, obtained by descent: start with a solution, try to modify it in some way, keep it if it is better. With enough patience, this gives a score around 107,000.","dfc43323":"# Descent","0064d8d0":"# Data","957a05a6":"# Loss function","32edd57a":"# Plotting functions"}}