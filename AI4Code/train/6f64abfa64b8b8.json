{"cell_type":{"60d12b88":"code","8dce4291":"code","c2ee697a":"code","88e50e8c":"code","f8faed94":"code","0de43ee8":"code","6f27e9a4":"code","e42f53c4":"code","c884e716":"code","ff543eae":"code","2f9356a9":"code","e3e215c3":"code","aa08e152":"code","a576bca0":"code","db43ddd3":"code","abbc4962":"code","a917cb9c":"code","d967b7f5":"code","2bef2de2":"code","5aa6750c":"code","5dbb7aa9":"code","360ab09c":"code","3f0f6437":"code","314e0cbf":"markdown","57855b1e":"markdown","fa981678":"markdown","630603ac":"markdown","4c84b12d":"markdown","b42131ca":"markdown","08f543fa":"markdown","d9dd4b4d":"markdown","8a4686d0":"markdown","463d5f31":"markdown"},"source":{"60d12b88":"import numpy as np\nimport pandas as pd\nimport glob\nimport os\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\nfrom pathlib import Path\nimport plotly.express as px","8dce4291":"data_dir = Path(\"..\/input\/google-smartphone-decimeter-challenge\")\ntrain_df = pd.read_csv(data_dir \/ \"baseline_locations_train.csv\")","c2ee697a":"# get all ground truth dataframe\ngt_df = pd.DataFrame()\nfor (collection_name, phone_name), df in tqdm(train_df.groupby([\"collectionName\", \"phoneName\"])):\n    path = data_dir \/ f\"train\/{collection_name}\/{phone_name}\/ground_truth.csv\"\n    df = pd.read_csv(path)  \n    gt_df = pd.concat([gt_df, df]).reset_index(drop=True)   \ngt_df.head()","88e50e8c":"fig = px.scatter_mapbox(gt_df,\n\n                    # Here, plotly gets, (x,y) coordinates\n                    lat=\"latDeg\",\n                    lon=\"lngDeg\",\n                    text='phoneName',\n\n                    #Here, plotly detects color of series\n                    color=\"collectionName\",\n                    labels=\"collectionName\",\n\n                    zoom=9,\n                    center={\"lat\":37.423576, \"lon\":-122.094132},\n                    height=600,\n                    width=800)\nfig.update_layout(mapbox_style='stamen-terrain')\nfig.update_layout(margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0})\nfig.update_layout(title_text=\"GPS trafic\")\nfig.show()","f8faed94":"target_collection = '2021-04-29-US-SJC-2'\ntarget_gt_df = gt_df[gt_df[\"collectionName\"]==target_collection].reset_index(drop=True)\ntarget_collection","0de43ee8":"fig = px.scatter_mapbox(target_gt_df,\n\n                    # Here, plotly gets, (x,y) coordinates\n                    lat=\"latDeg\",\n                    lon=\"lngDeg\",\n                    text='phoneName',\n\n                    #Here, plotly detects color of series\n                    color=\"collectionName\",\n                    labels=\"collectionName\",\n\n                    zoom=15,\n                    center={\"lat\":37.33351, \"lon\":-121.8906},\n                    height=600,\n                    width=800)\nfig.update_layout(mapbox_style='stamen-terrain')\nfig.update_layout(margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0})\nfig.update_layout(title_text=\"GPS trafic\")\nfig.show()","6f27e9a4":"!pip install osmnx momepy geopandas","e42f53c4":"from shapely.geometry import Point\nimport osmnx as ox\nimport momepy\nimport geopandas as gpd","c884e716":"# change pd.DataFrame -> gpd.GeoDataFrame\ntarget_gt_df[\"geometry\"] = [Point(p) for p in target_gt_df[[\"lngDeg\", \"latDeg\"]].to_numpy()]\ntarget_gt_gdf = gpd.GeoDataFrame(target_gt_df, geometry=target_gt_df[\"geometry\"])\ntarget_gt_gdf.head(5)","ff543eae":"target_gt_gdf.plot()","2f9356a9":"# get road data from open street map by osmnx\noffset = 0.1**5\nbbox = target_gt_gdf.bounds + [-offset, -offset, offset, offset]\neast = bbox[\"minx\"].min()\nwest = bbox[\"maxx\"].max()\nsouth = bbox[\"miny\"].min()\nnorth = bbox[\"maxy\"].max()\nG = ox.graph.graph_from_bbox(north, south, east, west, network_type='drive')","e3e215c3":"ox.folium.plot_graph_folium(G)","aa08e152":"nodes, edges = momepy.nx_to_gdf(G)","a576bca0":"nodes.head()","db43ddd3":"edges.head()","abbc4962":"edges.plot()","a917cb9c":"edges = edges.dropna(subset=[\"geometry\"]).reset_index(drop=True)\nhits = bbox.apply(lambda row: list(edges.sindex.intersection(row)), axis=1)\ntmp = pd.DataFrame({\n    # index of points table\n    \"pt_idx\": np.repeat(hits.index, hits.apply(len)),\n    # ordinal position of line - access via iloc later\n    \"line_i\": np.concatenate(hits.values)\n})\n# Join back to the lines on line_i; we use reset_index() to \n# give us the ordinal position of each line\ntmp = tmp.join(edges.reset_index(drop=True), on=\"line_i\")\n# Join back to the original points to get their geometry\n# rename the point geometry as \"point\"\ntmp = tmp.join(target_gt_gdf.geometry.rename(\"point\"), on=\"pt_idx\")\n# Convert back to a GeoDataFrame, so we can do spatial ops\ntmp = gpd.GeoDataFrame(tmp, geometry=\"geometry\", crs=target_gt_gdf.crs)","d967b7f5":"tmp.head()","2bef2de2":"tmp[\"snap_dist\"] = tmp.geometry.distance(gpd.GeoSeries(tmp.point))\n\n# Discard any lines that are greater than tolerance from points\ntolerance = 0.0005  \ntmp = tmp.loc[tmp.snap_dist <= tolerance]\n# Sort on ascending snap distance, so that closest goes to top\ntmp = tmp.sort_values(by=[\"snap_dist\"])\n\n# group by the index of the points and take the first, which is the\n# closest line \nclosest = tmp.groupby(\"pt_idx\").first()\n# construct a GeoDataFrame of the closest lines\nclosest = gpd.GeoDataFrame(closest, geometry=\"geometry\")\nclosest = closest.drop_duplicates(\"line_i\").reset_index(drop=True)","5aa6750c":"closest.plot()","5dbb7aa9":"closest.head()","360ab09c":"line_points_list = []\nsplit = 50  # param: number of split in each LineString\nfor dist in range(0, split, 1):\n    dist = dist\/split\n    line_points = closest[\"geometry\"].interpolate(dist, normalized=True)\n    line_points_list.append(line_points)\nline_points = pd.concat(line_points_list).reset_index(drop=True)\nline_points = line_points.reset_index().rename(columns={0:\"geometry\"})\nline_points[\"lngDeg\"] = line_points[\"geometry\"].x\nline_points[\"latDeg\"] = line_points[\"geometry\"].y","3f0f6437":"fig = px.scatter_mapbox(line_points,\n\n                    # Here, plotly gets, (x,y) coordinates\n                    lat=\"latDeg\",\n                    lon=\"lngDeg\",\n\n                    zoom=15,\n                    center={\"lat\":37.33351, \"lon\":-121.8906},\n                    height=600,\n                    width=800)\nfig.update_layout(mapbox_style='stamen-terrain')\nfig.update_layout(margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0})\nfig.update_layout(title_text=\"GPS trafic\")\nfig.show()","314e0cbf":"Since it still contains extra roads, we will leave only the relevant roads.","57855b1e":"## Generate road points","fa981678":"## Import geographical library","630603ac":"I shared the road detection and creating grid points in this notebook.\n\nI hope it helps. Thanks!","4c84b12d":"## Find closest road","b42131ca":"In this notebook, I use only edges data.","08f543fa":"In this notebook, I introduce how to detect road from open street map and how to create grid points from road data. \nThe generated grid points may be used for \"snap to grid\". Please refer [original notebook](https:\/\/www.kaggle.com\/robikscube\/indoor-navigation-snap-to-grid-post-processing ) to know the detail of \"snap to grid\".\n\nActually, I haven't applied these grids to \"Snap to Grid\" well yet by some problem, and I'm still trying to figure it out.\nPlese comment if there are my mistakes or any idea.\n\nReference sites:  \nhttps:\/\/medium.com\/@brendan_ward\/how-to-leverage-geopandas-for-faster-snapping-of-points-to-lines-6113c94e59aa","d9dd4b4d":"Then, we can obtain the road data corresponding to the target data. These features may be used for modeling.\n  \nNext, I generate grid points from road data.","8a4686d0":"## Target place\nLet's take '2021-04-29-US-SJC-2' as an example.","463d5f31":"We can get road data from open street map by creating bounding box. "}}