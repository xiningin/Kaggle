{"cell_type":{"ca3d9ca1":"code","cec957db":"code","7181571c":"code","ff3b4ed5":"code","9cc435a9":"code","71c19828":"code","9aa4343a":"code","57787e44":"code","e04eb844":"code","e2fa6b76":"code","86589c25":"code","61236037":"code","e953ce91":"markdown","ec47b241":"markdown","4c068042":"markdown","c7ec3ad9":"markdown","6a45c5cc":"markdown","588ac3f2":"markdown","8189ae72":"markdown","b0a8f40b":"markdown","6a7f1a70":"markdown","6eb0e8ec":"markdown","9a408dd2":"markdown","729632ff":"markdown","eb80851e":"markdown"},"source":{"ca3d9ca1":"import cv2\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D\nfrom keras.layers import MaxPooling2D\nfrom keras.layers import Flatten, Dense, Dropout\nfrom keras.preprocessing.image import *\nfrom keras.preprocessing import image\nfrom sklearn.model_selection import train_test_split\nimport os\n","cec957db":"infected = os.listdir('..\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\/Parasitized')\nuninfected = os.listdir('..\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\/Uninfected')\ndata = []\nlabels = []\nfor i in infected:\n    try:\n        image = cv2.imread('..\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\/Parasitized\/'+i)\n        image_array = Image.fromarray(image , 'RGB')\n        resize_img = image_array.resize((64 , 64))\n        data.append(np.array(resize_img))\n        labels.append(0)\n        \n    except AttributeError:\n        print(\"\")\n\nfor b in uninfected:\n    try:\n        image=cv2.imread('..\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\/Uninfected\/'+b)\n        image_from_array = Image.fromarray(image, 'RGB')\n        resize_img = image_array.resize((64, 64))\n        data.append(np.array(resize_img))\n        labels.append(1)\n    except AttributeError:\n        print(\"\")\n        \ndata = np.array(data)\nlabels = np.array(labels)","7181571c":"train_data , x , train_label , y = train_test_split(data,labels,test_size = 0.2,random_state = 123)\nval_data , test_data , val_label , test_label = train_test_split(x,y,test_size = 0.5,random_state = 123)","ff3b4ed5":"val,occ = np.unique(train_label, return_counts = True)\nval1,occ1= np.unique(val_label, return_counts = True)\nval2,occ2 = np.unique(test_label, return_counts = True)\n\nx_ax = ['0','1']\nplt.subplot(1,3,1)\nplt.bar(x_ax,occ,color = ['C0','C1'], width = 0.5)\nplt.title(\"Training Set\")\nplt.subplot(1,3,2)\nplt.bar(x_ax,occ1,color = ['C0','C1'], width = 0.5)\nplt.title(\"Validation Set\")\nplt.subplot(1,3,3)\nplt.bar(x_ax,occ2,color = ['C0','C1'], width = 0.5)\nplt.title(\"Test Set\")\nplt.tight_layout()\nplt.show()","9cc435a9":"model = Sequential()\n\nmodel.add(Conv2D(filters = 32, kernel_size = (3,3), input_shape = (64,64,3), activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\n\nmodel.add(Conv2D(filters = 64, kernel_size = (3,3), activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\n\nmodel.add(Conv2D(filters = 128, kernel_size = (3,3), activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(units =256,activation = 'relu'))\nmodel.add(Dropout(rate=0.2))\nmodel.add(Dense(units=1, activation='sigmoid'))\n\nmodel.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n","71c19828":"model.summary()","9aa4343a":"train_datagen = ImageDataGenerator(rescale=1.\/255,shear_range=0.25,zoom_range=0.25,horizontal_flip=True,vertical_flip=True)  \nval_datagen= ImageDataGenerator(rescale=1.\/255)\n\ntrain_gen = train_datagen.flow(train_data,train_label, batch_size=16)\nval_gen = val_datagen.flow(val_data,val_label, batch_size=16)\ntest_gen = val_datagen.flow(test_data,test_label, batch_size =1, shuffle = False)\n\nSTEP_SIZE_TRAIN=train_gen.n\/\/train_gen.batch_size\nSTEP_SIZE_VALID=val_gen.n\/\/val_gen.batch_size\nSTEP_SIZE_TEST=test_gen.n\/\/test_gen.batch_size","57787e44":"ep = 5\n\nhist = model.fit_generator(generator = train_gen, validation_data= val_gen,\n                           steps_per_epoch=STEP_SIZE_TRAIN, epochs=ep, \n                           validation_steps=STEP_SIZE_VALID)\n","e04eb844":"(loss,acc) = a= model.evaluate(test_data,test_label,verbose = 1)\nprint(\"On the test set:\")\nprint(\"Loss= \"+ str(loss))\nprint(\"Accuracy= \" + str(acc))\n","e2fa6b76":"val_acc = hist.history['val_acc']\nacc= hist.history['acc']\nx= list(range(1,ep+1))\n\nplt.plot(x,acc,marker='o',label = 'acc')\nplt.plot(x,val_acc,marker='o',label = 'val_acc')\n\nplt.legend()\nplt.show()","86589c25":"val_loss = hist.history['val_loss']\nloss= hist.history['loss']\n\nplt.plot(x,loss,marker='o',label = 'acc')\nplt.plot(x,val_loss,marker='o',label = 'val_acc')\n\nplt.legend()\nplt.show()","61236037":"test_gen.reset()\npred=model.predict_generator(test_gen,steps=STEP_SIZE_TEST, verbose=1)\npred = np.around(pred)\npred = pred.flatten()\n\nnp.array_equal(test_label,pred)\n","e953ce91":"**Building the model**\n\nA sequential model is used.","ec47b241":"The model trains on the **Malaria Cell Images Dataset**. It uses a CNN to classify the images.","4c068042":"**Plotting accuracies over epochs**\n\nTo check for overfitting, the accuracy over the training set and the accuracy over the validation set is plotted","c7ec3ad9":"**Preparing Data**\n\nIn this section, images are loaded and converted into numpy arrays. At the same time labels for them are set.\n0 : Parasitized, 1 : Uninfected","6a45c5cc":"**Plotting Losses over epochs**\n\nSimilarly losses are plotted\n","588ac3f2":"**Checking if accuracy is indeed 1**\n\nSince shuffle is False for the test_generator, we can predict on the test set data and compare the predictions to the test labels. This will verify if the accuracy is indeed 1 on the test set","8189ae72":"**Importing Necessary Libraries**","b0a8f40b":"**Splitting the data**\n\nData is split into 3 subsets: Training set, Validation set, Test set\n","6a7f1a70":"**Evaluating the model on the test set**\n\nModel is evaluated for the test set and loss and accuracy is calculated","6eb0e8ec":"**Training the model**\n\nThe model is trained for no of epochs = 5\n","9a408dd2":"**Visualizing the sub-sets**\n\nJust to see if there is an approximate equal samples of both infected and uninfected in all 3 subsets, plotting the labels.","729632ff":"**Batches of images**\n\nImages are fed to the model in batches. To generate those batches ImageDataGenerator is used.","eb80851e":"**Layers of the model and summary:**\n"}}