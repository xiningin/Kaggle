{"cell_type":{"0444c4d6":"code","fe1cde03":"code","471a50aa":"code","95ab4a39":"code","f4e277ca":"code","c0c7680e":"code","b234c97b":"code","72c0b45a":"code","8d62f849":"code","39972ca7":"code","04ee1132":"code","6192a0fa":"code","418ffd3d":"code","7f9a822b":"code","467961b5":"code","9637069b":"code","b60b7cc8":"code","9c5e82d5":"code","0c4754f1":"code","f738126d":"code","10c0a50a":"code","c05a1232":"code","60ab1f31":"code","9eb2a5ca":"code","d2553b1e":"code","b617162f":"code","3ef42882":"code","832125a3":"code","57a18ece":"code","e331d0d7":"code","dc695194":"code","7325ca3c":"code","ebaf152c":"code","56f3c1ef":"code","30c04a98":"code","f22743b9":"code","c62a13a5":"code","7e4fbb15":"code","ac75e5a3":"markdown","1064aca1":"markdown","8bb033c9":"markdown","deff4ed1":"markdown","364ed572":"markdown","3efa4027":"markdown","d8ca8c72":"markdown","8716158a":"markdown","480bd292":"markdown","c52cdf64":"markdown","195e29a5":"markdown","e29d6d68":"markdown","e9e8c74c":"markdown","898e788d":"markdown","c27ff02e":"markdown","c2730f87":"markdown","5f1eaacf":"markdown","1730498a":"markdown","c5c751fe":"markdown","8a6b7727":"markdown","a7beaf20":"markdown","085c806e":"markdown","fa8bcb35":"markdown","b24a96a7":"markdown","3ec381c4":"markdown","b2c71968":"markdown","130d61af":"markdown","7f220e59":"markdown","654871bc":"markdown","86b41c36":"markdown","e343123d":"markdown","0b2a90e3":"markdown","63445dc3":"markdown","1c2b5b93":"markdown","82281310":"markdown","e5f62674":"markdown","e1e8f865":"markdown"},"source":{"0444c4d6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","fe1cde03":"df = pd.read_csv('..\/input\/china-college-entrance-examination-admission\/02-RawData.csv', encoding='utf8')\ndf.head(2)","471a50aa":"#Code by Schichaoming https:\/\/www.kaggle.com\/shichaoming\/scm-201943407\n\ndef resumetable(df):\n    '''function to create feature summary'''\n    print(f'Shape: {df.shape}')\n    summary = pd.DataFrame(df.dtypes, columns=['Data Type'])\n    summary = summary.reset_index()\n    summary = summary.rename(columns={'index': 'Features'})\n    summary['Num of Null Value'] = df.isnull().sum().values\n    summary['Num of Unique Value'] = df.nunique().values\n    summary['1st Value'] = df.loc[0].values\n    summary['2nd Value'] = df.loc[1].values\n    summary['3rd Value'] = df.loc[2].values\n    return summary","95ab4a39":"#Code by Schichaoming https:\/\/www.kaggle.com\/shichaoming\/scm-201943407\n\nresumetable(df)","f4e277ca":"#Remove percent sign by Scott Boston - jun 4th 2018\n#Code by StackOverflow https:\/\/stackoverflow.com\/questions\/50686004\/change-column-with-string-of-percent-to-float-pandas-dataframe\n\ndf['CEEAR'] = pd.to_numeric(df['CEEAR'].str.strip('%')).div(100)\ndf['GER'] = pd.to_numeric(df['GER'].str.strip('%')).div(100)","c0c7680e":"#Another way to remove percent sign by Scott Boston - jun 4th 2018\n#Code by StackOverflow https:\/\/stackoverflow.com\/questions\/50686004\/change-column-with-string-of-percent-to-float-pandas-dataframe\n\n#df['GER'] = pd.to_numeric(df['GER'].str[:-1]).div(100)","b234c97b":"#Code by Parul Pandey  https:\/\/www.kaggle.com\/parulpandey\/a-guide-to-handling-missing-values-in-python\n\n\nfrom sklearn.impute import SimpleImputer\ndf_most_frequent = df.copy()\n#setting strategy to 'mean' to impute by the mean\nmean_imputer = SimpleImputer(strategy='most_frequent')# strategy can also be mean or median \ndf_most_frequent.iloc[:,:] = mean_imputer.fit_transform(df_most_frequent)","72c0b45a":"df_most_frequent.head()","8d62f849":"#Code by Tejashvi14 https:\/\/www.kaggle.com\/tejashvi14\/casualty-analysis\/notebook\n\n#After that snippet the float(Year) and the other objects become integers.\n\ndf_most_frequent[\"BY\"]=df_most_frequent[\"BY\"].apply(int)\ndf_most_frequent[\"CEEY\"]=df_most_frequent[\"CEEY\"].apply(int)\ndf_most_frequent[\"NBP\"]=df_most_frequent[\"NBP\"].apply(int)\ndf_most_frequent[\"UEE\"]=df_most_frequent[\"UEE\"].apply(int)\ndf_most_frequent[\"GDP-BY\"]=df_most_frequent[\"GDP-BY\"].apply(int)\ndf_most_frequent[\"GDP-CEEY\"]=df_most_frequent[\"GDP-CEEY\"].apply(int)\ndf_most_frequent[\"CEEP\"]=df_most_frequent[\"CEEP\"].apply(int)\ndf_most_frequent[\"CEEA\"] = df_most_frequent[\"CEEA\"].apply(int)\ndf_most_frequent[\"CEEAR\"] = df_most_frequent[\"CEEAR\"].apply(int)\ndf_most_frequent[\"GER\"]=df_most_frequent[\"GER\"].apply(int)","39972ca7":"df_most_frequent.dtypes","04ee1132":"#That worked though the author told to apply the snippet above\n#Code by StackOverflow https:\/\/stackoverflow.com\/questions\/50686004\/change-column-with-string-of-percent-to-float-pandas-dataframe\n\n#df['CEEAR'] = (pd.to_numeric(df['CEEAR'].str[:-1])\n #                           .div(100)\n  #                          .mask(df['CEEAR'] == '%', 0))","6192a0fa":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\n# checking for missing values\n\nplt.rcParams['figure.figsize'] = (17, 6)\nplt.plot(df)\nplt.title('Missing values', fontsize = 20)\nplt.show()","418ffd3d":"#Code by Samuel Cortinhas https:\/\/www.kaggle.com\/samuelcortinhas\/bojack-ratings-analysis\n\n# Scatterplot with regression lines\nsns.lmplot(x='CEEY', y='CEEA', data=df, hue='BY', height=6, aspect=2, fit_reg=True)\n#sns.regplot(x='Id', y='Rating', data=data_episodes, scatter=False, ci=False, color='black', line_kws={'lw': 1})\n\n# Aesthetics\nplt.title('China College Entrance Examination\\n')\nplt.xlabel('Year of college entrance examination');","7f9a822b":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nsns.boxplot(df_most_frequent['CEEY'])\nplt.title('Amount of admissions College Entrance Examination Outliers')\nplt.show()","467961b5":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\n# Linear Interpolation\n\ndf_most_frequent['CEEAR_linear'] = df_most_frequent['CEEAR'].interpolate(method = 'linear')\nplt.plot(df_most_frequent['CEEAR_linear'])\nplt.title('\\nLinear Interpolation of Missing Values\\n', fontsize = 20)\nplt.show()","9637069b":"#Another chart\n\n# Could be any column: No, only numeric data.\ndf_most_frequent['NBP'].plot()\nplt.title('Participants in College Entrance Examination', fontsize=20);","b60b7cc8":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nfrom statsmodels.tsa.stattools import kpss\n\nresult = kpss(df_most_frequent['NBP'])\nprint(f\"KPSS Statistics: {result[0]}\")\nprint(f\"p-value: {result[1]}\")\nprint(f\"num_lags: {result[2]}\")\nfor key, value in result[3].items():\n    print('Critical Values:')\n    print(f\"{key}, {value}\")","9c5e82d5":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nfrom scipy.stats import boxcox\n\nplt.rcParams['figure.figsize'] = (17, 6)\ndata_boxcox = pd.Series(boxcox(df_most_frequent['NBP'], lmbda = 0), index = df.index)\nplt.plot(data_boxcox, label  = 'After Box Cox Transformation')\n\nplt.legend()\nplt.title('Number of Participants in College Entrance Examination \\n', fontsize = 20)\nplt.show()","0c4754f1":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\ndata_boxcox_difference = pd.Series(data_boxcox - data_boxcox.shift(), index = df.index)\ndata_boxcox_difference.dropna(inplace = True)\nplt.plot(data_boxcox_difference, label = 'After Box Cox Transformation and Differencing ')\n\nplt.legend()\nplt.title('Number of Participants in College Entrance Examination \\n', fontsize = 20)\nplt.show()","f738126d":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\n# loading and plotting acf\n\nfrom statsmodels.graphics.tsaplots import plot_acf\n\nplot_acf(data_boxcox_difference, ax = plt.gca(), lags = 10)\nplt.show()","10c0a50a":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n# loading and plotting pacf\n\nfrom statsmodels.graphics.tsaplots import plot_pacf\n\nplot_pacf(data_boxcox_difference, ax = plt.gca(), lags = 20)#requested nlags 30 must be < 30\nplt.show()","c05a1232":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nlength_train = 115\n\ntrain_data_boxcox = data_boxcox[:length_train]\ntest_data_boxcox = data_boxcox[length_train:]\n\ntrain_data_boxcox_difference = data_boxcox_difference[:length_train-1]\ntest_data_boxcox_difference = data_boxcox_difference[length_train-1:]","60ab1f31":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nfrom statsmodels.tsa.arima_model import ARIMA\n\nmodel_ar = ARIMA(train_data_boxcox_difference, order=(1,0,0))\nmodel_fit = model_ar.fit()","9eb2a5ca":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\ny_ar_new = data_boxcox_difference.copy()\ny_ar_new['ar_forecast_boxcox_difference'] = model_fit.predict(data_boxcox_difference.index.min(),\n                                                              data_boxcox_difference.index.max())\n\ny_ar_new['ar_forecast_boxcox'] = y_ar_new['ar_forecast_boxcox_difference'].cumsum()\ny_ar_new['ar_forecast_boxcox'] = y_ar_new['ar_forecast_boxcox'].add(data_boxcox[0])\ny_ar_new['ar_forecast'] = np.exp(y_ar_new['ar_forecast_boxcox'])","d2553b1e":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nlength_train = 115\ntrain = df_most_frequent.iloc[:length_train, :]\ntest = df_most_frequent.iloc[length_train:, :]","b617162f":"plt.rcParams['figure.figsize'] = (17, 8)\n\nplt.plot(train['NBP'], label = 'Train')\nplt.plot(test['NBP'], label = 'Test')\nplt.plot(y_ar_new['ar_forecast'][test.index.min():], label = 'AR model')\n\nplt.legend(fontsize = 15)\nplt.title('Auto Regressive Model\\n', fontsize = 20)\nplt.show()","3ef42882":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\nmodel_ma = ARIMA(train_data_boxcox, order=(0,0,7))\nmodel_fit = model_ma.fit()","832125a3":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\ny_ma_new = data_boxcox_difference.copy()\ny_ma_new['ma_forecast_boxcox_differencing'] = model_fit.predict(data_boxcox_difference.index.min(),\n                                                              data_boxcox_difference.index.max())\ny_ma_new['ma_forecast_boxcox'] = y_ma_new['ma_forecast_boxcox_differencing'].cumsum()\ny_ma_new['ma_forecast_boxcox'] = y_ma_new['ma_forecast_boxcox'].add(data_boxcox[0])\ny_ma_new['ma_forecast'] = np.exp(y_ma_new['ma_forecast_boxcox'])","57a18ece":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nplt.plot(train['NBP'], label = 'Train')\nplt.plot(test['NBP'], label = 'Test')\nplt.plot(y_ma_new['ma_forecast'][test.index.min():], label = 'MA model')\n\nplt.legend(fontsize = 15)\nplt.title('Moving Average regressive model\\n', fontsize = 20)\nplt.show()","e331d0d7":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nfrom statsmodels.tsa.arima_model import ARIMA\n\nmodel_arma = ARIMA(train_data_boxcox_difference, order = (1, 0, 5))\nmodel_fit = model_arma.fit()","dc695194":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\ny_arma_new = data_boxcox_difference.copy()\ny_arma_new['arma_forecast_boxcox_difference'] = model_fit.predict(data_boxcox_difference.index.min(),\n                                                                  data_boxcox_difference.index.max())\ny_arma_new['arma_forecast_boxcox'] = y_arma_new['arma_forecast_boxcox_difference'].cumsum()\ny_arma_new['arma_forecast_boxcox'] = y_arma_new['arma_forecast_boxcox'].add(data_boxcox[0])\ny_arma_new['arma_forecast'] = np.exp(y_arma_new['arma_forecast_boxcox'])","7325ca3c":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nplt.plot(train['NBP'], label = 'Train')\nplt.plot(test['NBP'], label = 'Test')\nplt.plot(y_arma_new['arma_forecast'][test.index.min():], label = 'ARMA model')\n\nplt.legend(fontsize = 15)\nplt.title('Auto regressive Moving Average model\\n', fontsize = 20)\nplt.show()","ebaf152c":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nfrom statsmodels.tsa.arima_model import ARIMA\n\nmodel_arima = ARIMA(train_data_boxcox, order = (9, 1, 5))\nmodel_arima_fit = model_arima.fit()","56f3c1ef":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\ny_arima_new = data_boxcox_difference.copy()\ny_arima_new['arima_forecast_boxcox_difference'] = model_arima_fit.predict(data_boxcox_difference.index.min(),\n                                                                  data_boxcox_difference.index.max())\ny_arima_new['arima_forecast_boxcox'] = y_arima_new['arima_forecast_boxcox_difference'].cumsum()\ny_arima_new['arima_forecast_boxcox'] = y_arima_new['arima_forecast_boxcox'].add(data_boxcox[0])\ny_arima_new['arima_forecast'] = np.exp(y_arima_new['arima_forecast_boxcox'])","30c04a98":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nplt.plot(train['NBP'], label = 'Train')\nplt.plot(test['NBP'], label = 'Test')\nplt.plot(y_arima_new['arima_forecast'][test.index.min():], label = 'ARIMA model')\n\nplt.legend(fontsize = 15)\nplt.title('Auto Regressive Integrated Moving Average Model\\n', fontsize = 20)\nplt.show()","f22743b9":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\n\nmodel_sarima = SARIMAX(train_data_boxcox_difference, order = (1, 1, 1), seasonal_order = (1, 1, 1, 6))\nmodel_sarima_fit = model_sarima.fit()","c62a13a5":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n\ny_sarima_new = data_boxcox_difference.copy()\ny_sarima_new['sarima_forecast_boxcox_difference'] = model_sarima_fit.predict(data_boxcox_difference.index.min(),\n                                                                  data_boxcox_difference.index.max())\ny_sarima_new['sarima_forecast_boxcox'] = y_sarima_new['sarima_forecast_boxcox_difference'].cumsum()\ny_sarima_new['sarima_forecast_boxcox'] = y_sarima_new['sarima_forecast_boxcox'].add(data_boxcox[0])\ny_sarima_new['sarima_forecast'] = np.exp(y_sarima_new['sarima_forecast_boxcox'])","7e4fbb15":"plt.plot(train['NBP'], label = 'Train')\nplt.plot(test['NBP'], label = 'Test')\nplt.plot(y_sarima_new['sarima_forecast'][test.index.min():], label = 'ARIMA model')\n\nplt.legend(fontsize = 15)\nplt.title('Seasonal Auto Regressive Integrated Moving Average Model\\n', fontsize = 20)\nplt.show()","ac75e5a3":"#Though all are integers (input 7 after imputation and transforming float to integer) I still got this error:\n\"TypeError: cannot do slice indexing on RangeIndex with these indexers of type float\"","1064aca1":"#Moving Average Model\n\nIn Moving Average Model, we consider the past forecasted errors to forecast the future values.\nThe Moving Average Model has a parameter called \"q\" which is the size of the Moving average window over which linear combinations of errors are calculated.\n\nThe Mathematical equation is :- $$y(t) = \u00b5 + \u03c6(k)*\u03b5(t-k)$$\n\u00b5 is the mean of the series\n\n\u03b5(t-k) is the past forecasted value\n\n\u03c6(k) is the weight associated with error value\n\n#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","8bb033c9":"#Auto Regressive Moving Average Model (ARMA)\n\nARMA Model combines both AR and MA model.\nIt takes into account one or more past observations as well as the past errors.\nThe ARMA model contains two parameters p and q.\np is the highest lag in the time series.\nq is the number of past errors included.","deff4ed1":"#Plotting Train, Test and Forecast (ARIMA)","364ed572":"#Though all are integers (input 7 after imputation and transforming float to integer) I still got this error:\n\"TypeError: cannot do slice indexing on RangeIndex with these indexers of type float\"","3efa4027":"#Remove Percent Sign. My last code didn't work here and I've no clue why it happened. ","d8ca8c72":"#Though all are integers (input 7 after imputation and transforming float to integer) I still got this error:\n\"TypeError: cannot do slice indexing on RangeIndex with these indexers of type float\"","8716158a":"#Auto Regressive Integrated Moving Average Model (ARIMA)\n\nIt transform the time series using Box Cox and then itself takes care of the differencing and remove the trend from the time series.\n\nWe have three parameters to be used :\n\np is the highest lag in the model.\n\nd id the degree of differencing to make the series stationary.\n\nq is the number of past errors terms included.\n\n","480bd292":"#Plotting Train, Test and Forecast (ARMA)","c52cdf64":"#Plotting Train, Test and Forecast (Moving Average Model)","195e29a5":"#Acknowledgment:\n\nScript by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance\n    ","e29d6d68":"#Though all are integers (input 7 after imputation and transforming float to integer) I still got this error:\n\"TypeError: cannot do slice indexing on RangeIndex with these indexers of type float\"","e9e8c74c":"#Recovering Original Time Series (Moving Average Model)","898e788d":"#Kwiatkowski-Phillips-Schmidt-Shin (KPSS) Test\n\n\nThe Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test figures out if a time series is stationary around a mean or linear trend, or is non-stationary due to a unit root. A stationary time series is one where statistical properties like mean and variance are constant over time.\n\nFor KPSS test,\n\nThe Null Hypothesis : The series is stationary when p-value > 0.05.\nThe Alternate Hypothesis : The series is not stationary when p-value <= 0.05.\n\nCode by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","c27ff02e":"#Code by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","c2730f87":"#ValueError: The computed initial AR coefficients are not stationary You should induce stationarity, choose a different model order, or you can pass your own start_params.\n\nNo clue to solve that. ","5f1eaacf":"#Box Cox Transformation\n\n\"Box Cox transformation transforms non normal dependent variables into normal distribution.\nTransformation technique is used to make the variance constant for a time series.\"\n\nCode by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","1730498a":"#Splitting the train and test data","c5c751fe":"#Plotting Train, Test and Forecast (ARIMA new)","8a6b7727":"#Recovering Original Time Series (ARIMA)","a7beaf20":"#Checking for missing values","085c806e":"#Though all are integers the error persists:\n\n\"TypeError: cannot do slice indexing on RangeIndex with these indexers Nan of type float.","fa8bcb35":"#Recovering Original Time Series (SARIMA)","b24a96a7":"#Dealing with Missing values trying to avoid errors.","3ec381c4":"#To detect outliers we can use boxplots\n\nA boxplot is a standardized way of displaying the distribution of data.\nAny data points which are less than Q1 - 1.5 IQR or greater than Q3 + 1.5 IQR are considered to be outliers.","b2c71968":"#Recovering Original Time Series (ARMA)","130d61af":"#Though all are integers (input 7 after imputation and transforming float to integer) I still got this error:\n\"TypeError: cannot do slice indexing on RangeIndex with these indexers of type float\"","7f220e59":"#Recovering Original Time Series","654871bc":"#ValueError: Can only compute partial correlations for lags up to 50% of the sample size. The requested nlags 30 must be < 30.  Then I changed nlags to 20","86b41c36":"#Dealing with missing values","e343123d":"#Since I got TypeError: cannot do slice indexing on RangeIndex with these indexers Nan of type float\n\nI tried to change float into integers","0b2a90e3":"#Auto Regressive Model\n\nRegressive model is forecasting the future observations as a linear regression of one or more past observations.\nThis model has a parameter called \"p\" which is the lag order p that means p is the maximum number of lags that we consider in order to forecast the future observations.\nAutoregressive model equation would be : $$y(t) = \u03b2_0 + \u03b2_1 y(t-2) + \u03b2_2 y(t-4) + \u03b2_3 y(t-6)$$\n\nCode by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","63445dc3":"#Auto Correlation Function\n\nACF is an (complete) auto-correlation function which gives us values of auto-correlation of any series with its lagged values.\n\nCode by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","1c2b5b93":"#Differencing\n\nDifferencing is a technique used to make the mean constant for a time series.\n\nDifferencing removes the Trend from a time series.\n\nCode by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","82281310":"#Partial Auto Correlation Function (PACF)\n\n\nPartial Auto Correlation Function (PACF) gives the partial correlation of a stationary time series with its own lagged values, regressed the values of the time series at all shorter lags. It contrasts with the autocorrelation function, which does not control for other lags.\n\nCode by Nitesh Yadav https:\/\/www.kaggle.com\/niteshyadav3103\/time-series-from-basic-to-advance","e5f62674":"#Seasonal Auto Regressive Integrated Moving Average Model (SARIMA)\n\nSARIMA model bring all the features of ARIMA model along with the seasonality.\n\nThe key elements performed in SARIMA are :\n\nThe Time Series is differenced to make it stationary.\n\nThe SARIMA equation is a linear combination of past observations and past errors.\n\nSeasonal Differencing is performed on the time series.\n\nSARIMA models future seasonality as a linear combination of past seasonality observations and past seasonality errors.\n\n","e1e8f865":"#Columns Names\n\nBY: Birth year\n\nCEEY: College entrance examination year\n\nNBP: Newborn population (unit: ten thousand people)\n\nUEE: University admission expansion policy, Boolean variable, 0 means none, 1 means yes\n\nGDP-BY: GDP in birth year\n\nGDP-CEEY: GDP in college entrance examination year\n\nCEEP: Amount of participants in the college entrance examination (unit: ten thousand people)\n\nCEEA: Amount of admissions of the college entrance examination (unit: ten thousand people)\n\nCEEAR: College entrance examination admission rate\n\nGER: Gross enrollment rate\n\nhttps:\/\/www.kaggle.com\/g9g99g9g\/china-college-entrance-examination-admission"}}