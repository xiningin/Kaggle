{"cell_type":{"9fd00de8":"code","90f5a6ac":"code","832f1ad6":"code","30394b75":"code","908e5171":"code","0f19b183":"code","c04ac045":"code","24cf166e":"code","bfd095a4":"code","9edec0a2":"code","65d62d10":"code","3774a9a9":"code","62eb6bab":"code","c5fd8d29":"code","4e6a351e":"code","6859a1a7":"code","e6b28ee9":"code","a9f2f074":"code","65528f5a":"code","756cbb37":"code","8c908ea2":"code","2bb77975":"code","b9ee3311":"code","1d25c419":"code","d72058b2":"code","ff6d90e7":"code","a691418a":"code","0a07f074":"code","f230e45a":"code","eda2155a":"code","f2c01f5b":"code","1fffdd53":"code","ec4b334e":"code","f4fd3985":"code","64c6d869":"code","e874e803":"markdown","b2d05eda":"markdown","7a0770d8":"markdown","77e4e5b8":"markdown","89d857ff":"markdown","0f130adc":"markdown","07315acc":"markdown","568dd5d1":"markdown"},"source":{"9fd00de8":"#Here are some standard libraries that are loaded when you \nimport cv2\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport matplotlib.pyplot as plt # visualize satellite images\nimport matplotlib.patches as patches\nimport matplotlib.colors as mcolors\n\nfrom skimage.io import imshow # visualize satellite images\n\nfrom keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, Dropout # components of network\nfrom keras.models import Sequential # type of model\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint","90f5a6ac":"import sklearn\nfrom sklearn.metrics import confusion_matrix, classification_report\nimport seaborn as sns","832f1ad6":"from skimage.filters import gaussian\nfrom scipy.interpolate import interp1d\nimport skimage\nimport pylab as pl\nimport scipy.signal\nfrom scipy import misc","30394b75":"x_train_set_fpath = '..\/input\/X_test_sat4.csv'\ny_train_set_fpath = '..\/input\/y_test_sat4.csv'\nprint ('Loading Training Data')\nX_train = pd.read_csv(x_train_set_fpath)\nprint ('Loaded 28 x 28 x 4 images')\n\nY_train = pd.read_csv(y_train_set_fpath)\nprint ('Loaded labels')","908e5171":"target_class_dict = {\n    0: 'Barren Land',\n    1: 'Trees',\n    2: 'Grasslands',\n    3: 'Urban'\n}","0f19b183":"plt.figure(figsize=(10, 10))\np = pd.Series(Y_train.argmax(axis=1)).value_counts().plot(kind='pie',\n                    labels=['Barren Land', 'Trees', 'Grasslands', 'Urban'],\n                    autopct='%1.1f%%')\np.add_artist(plt.Circle((0,0), 0.7, color='white'))\nplt.title('Class Distribution of Satellite Images')\nplt.legend()\nplt.savefig('Class distribution.PNG')","c04ac045":"X_train = X_train.as_matrix()\nY_train = Y_train.as_matrix()\nprint ('We have',X_train.shape[0],'examples and each example is a list of',X_train.shape[1],'numbers with',Y_train.shape[1],'possible classifications.')","24cf166e":"#First we have to reshape each of them from a list of numbers to a 28*28*4 image.\nX_train_img = X_train.reshape([99999,28,28,4]).astype(float)\nprint (X_train_img.shape)","bfd095a4":"class_idxs = []\ny_targets = Y_train.argmax(axis=1)\nfor c in range(4):\n    class_idxs.append(np.where(y_targets==c))","9edec0a2":"# dimensions\nw=28\nh=28\nc=4","65d62d10":"fig=plt.figure(figsize=(12, 12))\ncolumns = 5\nrows = 4\ni = 0\nfor classs, c_idxs in enumerate(class_idxs):\n    n = c_idxs[0].shape[0]\n    s = np.random.randint(0, n-5)\n    \n    for idx in c_idxs[0][s:s+5]:\n        img = np.squeeze(X_train_img[idx,:,:,0:3]).astype(float)\n        fig.add_subplot(rows, columns, i+1)\n        i+=1\n        plt.title(str(idx)+':'+target_class_dict[classs])\n        plt.xticks([])\n        plt.yticks([])\n        plt.imshow(img)\n        \nplt.savefig('target class examples.PNG')\nplt.show()","3774a9a9":"#Let's take a look at one image. Keep in mind the channels are R,G,B, and I(Infrared)\nix = 5#Type a number between 0 and 99,999 inclusive\nimshow(np.squeeze(X_train_img[ix,:,:,0:3]).astype(float)) #Only seeing the RGB channels\nplt.show()\n#Tells what the image is\nif Y_train[ix,0] == 1:\n    print ('Barren Land')\nelif Y_train[ix,1] == 1:\n    print ('Trees')\nelif Y_train[ix,2] == 1:\n    print ('Grassland')\nelse:\n    print ('Other')","62eb6bab":"def rgb2gray(rgb):\n    r, g, b = rgb[:,:,0], rgb[:,:,1], rgb[:,:,2]\n    gray = 0.2989 * r + 0.5870 * g + 0.1140 * b\n    return gray\n\ndef smooth_image(img):\n    return cv2.GaussianBlur(img, (3,3), 0)\n\ndef im2col(A,BLKSZ):   \n\n    # Parameters\n    M,N = A.shape\n    col_extent = N - BLKSZ[1] + 1\n    row_extent = M - BLKSZ[0] + 1\n\n    # Get Starting block indices\n    start_idx = np.arange(BLKSZ[0])[:,None]*N + np.arange(BLKSZ[1])\n\n    # Get offsetted indices across the height and width of input array\n    offset_idx = np.arange(row_extent)[:,None]*N + np.arange(col_extent)\n\n    # Get all actual indices & index into input array for final output\n    return np.take (A,start_idx.ravel()[:,None] + offset_idx.ravel())\n\ndef coltfilt(A, size):\n    \n    original_shape = np.shape(A)\n    a,b = 0, 0\n    if(size%2==0):\n        a, b = int(size\/2)-1, int(size\/2)\n    else:\n        a,b = int(size\/2), int(size\/2)\n    A = np.lib.pad(A, (a, b), 'constant')\n    Acol = im2col(A, (size, size))\n    rc = np.floor((Acol.max(axis=0) - Acol.min(axis=0))\/float(size)) + 1\n    return np.reshape(rc, original_shape)\n\ndef matlab_style_gauss2D(shape=(3,3),sigma=0.5):\n    \"\"\"\n    2D gaussian mask - should give the same result as MATLAB's\n    fspecial('gaussian',[shape],[sigma])\n    \"\"\"\n    m,n = [(ss-1.)\/2. for ss in shape]\n    y,x = np.ogrid[-m:m+1,-n:n+1]\n    h = np.exp( -(x*x + y*y) \/ (2.*sigma*sigma) )\n    h[ h < np.finfo(h.dtype).eps*h.max() ] = 0\n    sumh = h.sum()\n    if sumh != 0:\n        h \/= sumh\n    return h\n\ndef mat2gray(mat):\n    maxI = np.max(mat)\n    minI = np.min(mat)\n    gray = (mat[:,:] - minI) \/ (maxI - minI)\n    return gray\n    \n#------- computing the slope using linear regression -------\ndef fractal_aug(image):\n    \n    image = smooth_image(image)\n    \n    n_channels = len(np.shape(image))\n\n    if(n_channels == 3):\n        image=rgb2gray(image)\n    \n    image = smooth_image(image)\n\n    image *= 255.0\n    imrows, imcols = np.shape(image)\n    \n    B = np.zeros((6, imrows, imcols))\n\n    #print(\"Calculating Differential Box Counting image\")\n\n    for r in range(2,8):\n        mask = matlab_style_gauss2D((r,r), r\/2.0)\n        im = scipy.signal.convolve2d(image, mask, mode='same')\n        F = (coltfilt(im, r))*(49\/(r**2))\n        B[r - 2] = np.log(F)\n\n    #print(\"Calculating FD image\")\n\n    i = np.log(range(2,8)) #Normalised scale range vector\n\n    Nxx = np.dot(i,i) - (np.sum(i)**2)\/6\n    FD = np.zeros((imrows,imcols))\n\n    for m in range(1,imrows):\n        for n in range(1,imcols):\n            fd = [B[5,m,n], B[4,m,n], B[3,m,n], B[2,m,n], B[1,m,n], B[0,m,n]] #Number of boxes multiscale vector\n            Nxy = np.dot(i,fd) - (sum(i)*sum(fd))\/6\n            FD[m,n] = Nxy\/Nxx # slope of the linear regression line\n\n    tmp = np.zeros(np.shape(B))\n    for r in range(2,8):\n        tmp[r-2, :, :] = FD * np.log(m)\n\n    intercept = np.mean(B - tmp, axis=0)\n\n    FDB = mat2gray(FD);\n\n    intercept_image = mat2gray(intercept)\n    \n    #plt.imshow(intercept_image, cmap='gray')\n    #plt.show()\n    intercept_image = ((intercept_image - intercept_image.min()) * (1\/(intercept_image.max() - intercept_image.min())) * 255).astype('uint8')\n    \n    return intercept_image","c5fd8d29":"ix = 23\ntest_img = np.squeeze(X_train_img[ix,:,:,0:3]).astype(float)\nfractal_img = fractal_aug(test_img)\nprint(fractal_img.shape)\n\nplt.imshow(fractal_img, cmap='gray')\nplt.savefig('fractal-test.PNG')","4e6a351e":"plt.imshow(test_img)\nplt.savefig('original-test.PNG')","6859a1a7":"fig=plt.figure(figsize=(12, 12))\ncolumns = 5\nrows = 4\ni = 0\nfor classs, c_idxs in enumerate(class_idxs):\n    n = c_idxs[0].shape[0]\n    s = np.random.randint(0, n-5)\n    \n    for idx in c_idxs[0][s:s+5]:\n        img = fractal_aug(np.squeeze(X_train_img[idx,:,:,0:3]).astype(float))\n        fig.add_subplot(rows, columns, i+1)\n        i+=1\n        plt.title(str(idx)+':'+target_class_dict[classs])\n        plt.xticks([])\n        plt.yticks([])\n        plt.imshow(img, cmap='gray')\n        \nplt.savefig('target class fractal.PNG')\nplt.show()","e6b28ee9":"def fractal_dimension(image, threshold=0.9):\n    # finding all the non-zero pixels\n    pixels=[]\n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            if image[i,j]>0:\n                pixels.append((i,j))\n\n    Lx=image.shape[1]\n    Ly=image.shape[0]\n    #print (Lx, Ly)\n    pixels=pl.array(pixels)\n    #print (pixels.shape)\n\n    # computing the fractal dimension\n    #considering only scales in a logarithmic list\n    scales=np.logspace(0.001, 1, num=10, endpoint=False, base=2)\n    Ns=[]\n    # looping over several scales\n    for scale in scales:\n        # computing the histogram\n        H, edges=np.histogramdd(pixels, bins=(np.arange(0,Lx,scale),np.arange(0,Ly,scale)))\n        Ns.append(np.sum(H>0))\n\n    # linear fit, polynomial of degree 1\n    coeffs=np.polyfit(np.log(scales), np.log(Ns), 1)\n    return -coeffs[0]","a9f2f074":"fig=plt.figure(figsize=(12, 12))\ncolumns = 2\nrows = 2\ni = 0\nfor classs, c_idxs in enumerate(class_idxs):\n    n = c_idxs[0].shape[0]\n    s = np.random.randint(0, n-5)\n    \n    join_indices = c_idxs[0][s:s+16]\n    img = (np.vstack((\n        np.hstack((np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[0],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[1],:,:,0:3]).astype(float))),\n                              np.hstack((np.squeeze(X_train_img[join_indices[2],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[3],:,:,0:3]).astype(float))))),\n                   np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[4],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[5],:,:,0:3]).astype(float))),\n                              np.hstack((np.squeeze(X_train_img[join_indices[6],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[7],:,:,0:3]).astype(float))))))),\n        np.hstack((np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[8],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[9],:,:,0:3]).astype(float))),\n                              np.hstack((np.squeeze(X_train_img[join_indices[10],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[11],:,:,0:3]).astype(float))))),\n                   np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[12],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[13],:,:,0:3]).astype(float))),\n                              np.hstack((np.squeeze(X_train_img[join_indices[14],:,:,0:3]).astype(float),\n                                         np.squeeze(X_train_img[join_indices[15],:,:,0:3]).astype(float))))))))) )\n    \n    img = rgb2gray(img)\n    \n    # perform adaptive thresholding\n    t = skimage.filters.threshold_otsu(img)\n    mask = img > t\n    \n    fig.add_subplot(rows, columns, i+1)\n    i+=1\n    plt.title('FD of '+target_class_dict[classs]+':'+str(fractal_dimension(mask, 0.25)))\n    #plt.xticks([])\n    #plt.yticks([])\n    plt.imshow(img, cmap='gray')\n        \nplt.savefig('FD of classes 8.PNG')\n#plt.show()","65528f5a":"# FD simulation of all the classes\ni = 0\nlarge_fd_table = {\n    0: [],\n    1: [],\n    2: [],\n    3: []\n}\nfor classs, c_idxs in enumerate(class_idxs):\n    print('...'*15, classs, '...'*15)\n    for _ in range(300):\n        n = c_idxs[0].shape[0]\n        s = np.random.randint(0, n-16)\n\n\n        join_indices = c_idxs[0][s:s+16]\n        img = (np.vstack((\n            np.hstack((np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[0],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[1],:,:,0:3]).astype(float))),\n                                  np.hstack((np.squeeze(X_train_img[join_indices[2],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[3],:,:,0:3]).astype(float))))),\n                       np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[4],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[5],:,:,0:3]).astype(float))),\n                                  np.hstack((np.squeeze(X_train_img[join_indices[6],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[7],:,:,0:3]).astype(float))))))),\n            np.hstack((np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[8],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[9],:,:,0:3]).astype(float))),\n                                  np.hstack((np.squeeze(X_train_img[join_indices[10],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[11],:,:,0:3]).astype(float))))),\n                       np.vstack((np.hstack((np.squeeze(X_train_img[join_indices[12],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[13],:,:,0:3]).astype(float))),\n                                  np.hstack((np.squeeze(X_train_img[join_indices[14],:,:,0:3]).astype(float),\n                                             np.squeeze(X_train_img[join_indices[15],:,:,0:3]).astype(float))))))))) )\n\n        img = rgb2gray(img)\n\n        # perform adaptive thresholding\n        t = skimage.filters.threshold_otsu(img)\n        mask = img > t\n        \n        # add FD to dict\n        large_fd_table[classs].append(fractal_dimension(mask, 0.25))\n        \nfor k in large_fd_table.keys():\n    large_fd_table[k] = np.array(large_fd_table[k])","756cbb37":"large_fd_table_df = pd.DataFrame(large_fd_table)\nlarge_fd_table_df.plot(figsize=(30, 8), grid=True)\nplt.xlabel('Sample Set')\nplt.ylabel('Fractal Dimension')\nplt.title('FD of 300 Sample set of different classes')\nplt.legend(['Barren Lands', 'Trees', 'Grasslands', 'Urban'])\nplt.savefig('FD of 300 Sample set of different classes.PNG')","8c908ea2":"f0 = interp1d(large_fd_table_df.index, large_fd_table_df[0],kind=33)\nf1 = interp1d(large_fd_table_df.index, large_fd_table_df[1],kind=33)\nf2 = interp1d(large_fd_table_df.index, large_fd_table_df[2],kind=33)\nf3 = interp1d(large_fd_table_df.index, large_fd_table_df[3],kind=33)\n\nlarge_fd_table_df2 = pd.DataFrame()\n\nnew_index = np.arange(0, 300)\nlarge_fd_table_df2[0] = f0(new_index)\nlarge_fd_table_df2[1] = f1(new_index)\nlarge_fd_table_df2[2] = f2(new_index)\nlarge_fd_table_df2[3] = f3(new_index)\n\nlarge_fd_table_df2.index = new_index\nlarge_fd_table_df2.plot(style='--', figsize=(25, 12), grid=True)\nplt.xlabel('Sample Set')\nplt.ylabel('Fractal Dimension')\nplt.title('FD of 300 Sample set of different classes - smoothened using cubic interpolation of degree to the power 33')\nplt.legend(['Barren Lands', 'Trees', 'Grasslands', 'Urban'])\nplt.savefig('FD of 300 Sample set of different classes - smoothened using cubic interpolation of degree to the power 33.PNG')","2bb77975":"large_fd_table_df.to_csv('large_fd_table.csv')","b9ee3311":"model = Sequential([\n    Dense(4, input_shape=(3136,), activation='softmax')\n])","1d25c419":"model.summary()","d72058b2":"X_train = X_train\/255","ff6d90e7":"callbacks = [EarlyStopping(monitor='val_loss', patience=8),\n                ModelCheckpoint(filepath='best_model.h5',\n                                monitor='val_loss',\n                                save_best_only=True)]","a691418a":"def evaluate_model(history, X_test, y_test, model):\n    scores = model.evaluate((X_test), y_test, verbose=0)\n    print(\"Accuracy: %.2f%%\" % (scores[1]*100))\n    \n    print(history)\n    fig1, ax_acc = plt.subplots()\n    plt.plot(history.history['acc'])\n    plt.plot(history.history['val_acc'])\n    plt.xlabel('Epoch')\n    plt.ylabel('Accuracy')\n    plt.title('Model - Accuracy')\n    plt.legend(['Training', 'Validation'], loc='lower right')\n    plt.savefig('Accuracy graph.PNG')\n    plt.show()\n    \n    fig2, ax_loss = plt.subplots()\n    plt.plot(history.history['loss'])\n    plt.plot(history.history['val_loss'])\n    plt.xlabel('Epoch')\n    plt.ylabel('Loss')\n    plt.title('Model - Loss')\n    plt.legend(['Training', 'Validation'], loc='upper right')\n    plt.savefig('Loss graph.PNG')\n    plt.show()\n    target_names = [str(i) for i in range(5)]\n    \n    y_true = []\n    for element in y_test:\n        y_true.append(np.argmax(element))\n    prediction_proba = model.predict(X_test)\n    prediction = np.argmax(prediction_proba, axis=1)\n    cnf_matrix = confusion_matrix(y_true, prediction)\n    return cnf_matrix","0a07f074":"model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\nmodel.summary()\nhistory = model.fit(X_train,Y_train,batch_size=32,\n          callbacks=callbacks,\n          epochs=15, verbose=1,\n          validation_split=0.01)","f230e45a":"preds = model.predict(X_train[-1000:], verbose=1)","eda2155a":"conf_matrix = evaluate_model(history, X_train[-1000:], Y_train[-1000:], model)","f2c01f5b":"print(classification_report(Y_train[-1000:].argmax(axis=1), preds.argmax(axis=1)))","1fffdd53":"conf_matrix","ec4b334e":"df_cm = pd.DataFrame(conf_matrix, range(4), range(4))\nplt.figure(figsize=(10,7))\nsns.set(font_scale=0.9) # for label size\nsns.heatmap(df_cm, annot=True, annot_kws={\"size\": 16}) # font size\n\nplt.savefig('confusion_matrix.png')\nplt.show()","f4fd3985":"df_cm = pd.DataFrame(conf_matrix, range(4), range(4)).corr()\nplt.figure(figsize=(10,7))\nsns.set(font_scale=0.9) # for label size\nsns.heatmap(df_cm, annot=True, annot_kws={\"size\": 16}, cmap='summer') # font size\n\nplt.savefig('confusion_matrix corr plot.png')\nplt.show()","64c6d869":"ix = 20 #Type a number between 0 and 999 inclusive\nimshow(np.squeeze(X_train_img[99999-(1000-ix),:,:,0:3]).astype(float)*255) #Only seeing the RGB channels\nplt.show()\n#Tells what the image is\nprint ('Prediction:\\n{:.1f}% probability barren land,\\n{:.1f}% probability trees,\\n{:.1f}% probability grassland,\\n{:.1f}% probability other\\n'.format(preds[ix,0]*100,preds[ix,1]*100,preds[ix,2]*100,preds[ix,3]*100))\n\nprint ('Ground Truth: ',end='')\nif Y_train[99999-(1000-ix),0] == 1:\n    print ('Barren Land')\nelif Y_train[99999-(1000-ix),1] == 1:\n    print ('Trees')\nelif Y_train[99999-(1000-ix),2] == 1:\n    print ('Grassland')\nelse:\n    print ('Other')","e874e803":"Now that we have the data and model ready, there is one more thing we have to do. In neural networks, it is very important we normalize training data. This means we make the mean 0, and the standard deviation 1 for the best results. However, dividing the image by 255 is good enough. We will just divide the array by 255:","b2d05eda":"### Fractal Augmentation","7a0770d8":"## Let's now define our model\nThere are 2 different types of models we can choose from: A 'vanilla' artificial neural network we have been learning about, and a special Convolutional Neural Network we will learn about, which is very, very good at image recognition. For now we will use the simpler, vanilla artificial neural network. The network will only have one layer: the output one. This network will not be expected to be very powerful, and pretty slow.","77e4e5b8":"## Get Input Data\nThe input data was encoded into CSV files. The X_test_sat4.csv flattened the images that were 28 x 28 x 4 that were taken from space. The first three channels are the standard red, green, and blue channels in normal images. The 4th is a near-infrared band. We are using the smaller test set because the training set is too big.\nAfter extracting the data from the csv files, we can reshape it into the original images. Then, we can see the images before we train on them.\nThe second file we are loading are the labels for each image. They can be one of 4: barren land, trees, grassland and other. Each row in the file looks like this [1,0,0,0], where only one of the 4 value is 1. If it is one, then it is that class respective to the order I showed above. If it was the above values, the image is a picture of barren land. If it was [0,1,0,0], then it would be trees. If it was [0,0,1,0], then it would be grassland and so on.","89d857ff":"## Now lets fit our model to the training data","0f130adc":"## The values are in a pandas(data library) DataFrame. We need them as a numpy array\nYou can convert pandas dataframes to numpy arrays like this:","07315acc":"Lets try to see what the model can do on a few images. Let's first get the predictions:","568dd5d1":"Different Classes:\n- 0: Barren Land\n- 1: Trees\n- 2: Grasslands\n- 3: Urban"}}