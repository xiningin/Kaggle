{"cell_type":{"c506b5f3":"code","2641c149":"code","f3d1711e":"code","e9db4d4d":"code","3349e347":"code","67d13a5b":"code","d079c7a7":"code","23538e52":"code","4302174a":"code","e87f00a1":"code","f06ba1fb":"code","23c8c26f":"code","8d10dc1f":"code","b2e8e2b6":"code","b0c7d2a8":"code","5d5d6577":"code","fd2a3021":"code","110981f5":"code","0e44a79d":"code","565c791e":"code","c169c097":"code","da0e55bc":"code","de440eea":"code","31bec4cc":"code","a889bb8c":"code","e798d9ea":"code","ac7e0788":"code","3917e942":"code","53dc2aec":"code","59697753":"markdown","73e1ff59":"markdown","7fdc1c53":"markdown","76a8859d":"markdown","4b993b69":"markdown","634de93c":"markdown","5d31745d":"markdown","3575b511":"markdown","eaef0cc3":"markdown","b3b2de67":"markdown"},"source":{"c506b5f3":"# Getting the file path\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","2641c149":"# Importing Libraries\nimport pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport plotly.graph_objects as go\nimport plotly.express as px\n\nfrom collections import Counter\n\nfrom wordcloud import WordCloud, STOPWORDS, ImageColorGenerator\n# from PIL import Image","f3d1711e":"# Loading in dataframe\ntv = pd.read_csv(\"\/kaggle\/input\/imdb-korean-tv-series\/koreanTV.csv\")\ncomment = pd.read_csv(\"\/kaggle\/input\/imdb-korean-tv-series\/koreanTV_comment.csv\")","e9db4d4d":"tv.head()","3349e347":"# Objective Cleaning up Rating, Votes:, Time, and Short Story columns\ntv['Year'] = tv['Year'].fillna(0)\ntv['Release_year'] = tv['Year'].apply(lambda y: str(y).split(\"\u2013\")[0]).replace('\\D+','',regex = True)\n\ntv['Rating'] = tv['Rating'].str.replace(\"-\",\"0\")\n\ntv = tv.rename(columns = {'Votes:':'Vote'}) # Rename the Vote column, so that it's easier to work with\ntv['Vote'] = tv['Vote'].str.replace(\"-\",\"0\")\ntv['Vote'] = tv['Vote'].str.replace(\",\",\"\")\n\ntv['Time'] = tv['Time'].apply(lambda y: str(y).replace(\"-\",\"0\").replace(\"min\",\"\").strip())\n\ntv['Short Story'] = tv['Short Story'].str.replace(\"\\n\",\"\")\n\nfor col in ['Release_year','Rating','Vote','Time']:\n    tv[col] = tv[col].apply(pd.to_numeric)\n\ntv.drop('Year',axis = 1,inplace = True)\ntv.head()","67d13a5b":"# Number of TV-series released by Year \n# 2022 is the schedule on (not released yet)\nplt.figure(figsize = (12,4))\nsns.countplot(x='Release_year',data=tv[tv['Release_year'] != 0],\n              palette = 'pastel')\nplt.xticks(rotation = 45)\nplt.show()","d079c7a7":"# Objective: Extracting all the unique genre and their frequencies\ngenre_list = list()\nfor genre in tv['Genre'].to_list():\n    for g in genre.split(\", \"):\n        if g != \"-\":\n            genre_list.append(g)\ngenre_df = pd.DataFrame.from_dict(Counter(genre_list),orient='index',columns = ['Frequency']).reset_index()\ngenre_df = genre_df.rename(columns = {'index':'Category'})\ngenre_df = genre_df.sort_values('Frequency',ascending = False)\ngenre_df.head()","23538e52":"text = genre_df['Category'].tolist()\nwordcloud = WordCloud(max_words=100000,background_color=\"white\",colormap=\"magma\").generate(str(text))\nplt.imshow(wordcloud,interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()","4302174a":"fig = px.bar(genre_df, x = 'Category',y = 'Frequency', title = 'TV-Series Genres')\nfig.show()","e87f00a1":"# Explore futher into Drama Romance and Comedy\ntv[tv['Genre'].str.contains('Romance')  & (tv['Vote'] > tv['Vote'].quantile(0.95))].sort_values(by='Vote',ascending = False)","f06ba1fb":"# Drama and Romance\ntv[tv['Genre'].str.contains(\"Drama\") & tv['Genre'].str.contains(\"Romance\")].head(10)","23c8c26f":"# Which combination of genre yield the best average rating? \nfrequency = []\nmean_rating = []\nstdev_rating = []\nfor combination in tv[tv['Genre'] != \"-\"]['Genre'].unique().tolist():\n    temp = tv[tv['Genre'] == combination]['Rating']\n    frequency.append(temp.count())\n    mean_rating.append(temp.mean())\n    stdev_rating.append(temp.std()) # If this genre combination only has one instance, then the std() would yield NaN\ncombination_rating = {'Genre_Combination':tv[tv['Genre'] != \"-\"]['Genre'].unique().tolist(),\n                      'Frequency':frequency,\n                      'Mean_Rating': mean_rating,\n                      'Stdev_Rating':stdev_rating}\ncombination_rating_df = pd.DataFrame.from_dict(combination_rating, orient = 'index').T\ncombination_rating_df = combination_rating_df.fillna(0.0) # 0.00 indicates that the combination only has one instance\ncombination_rating_df.sort_values(by='Genre_Combination')","8d10dc1f":"# Easier way of getting the same DataFrame as the above cell would be using groupby(), describe(), and seleting the column (like Rating  )\ncombination_rating_df2 = tv[tv['Genre'] != \"-\"].groupby(['Genre']).describe()['Rating']\ncombination_rating_df2 = combination_rating_df2.fillna(0.0)\ncombination_rating_df2.head()","b2e8e2b6":"# Marginal Error std\/root(n)\ncombination_rating_df2['SE'] = combination_rating_df2['std'] \/ (combination_rating_df2['count'] ** 0.5)\ncombination_rating_df2.head()","b0c7d2a8":"# Objective: Stars that is not featuring in Animated Series\nnonanimated = tv[tv['Genre'].str.contains(\"Animation\") == False]\nstar_list = []\n\nfor stars in nonanimated['Stars'].to_list():\n    star = stars.split(\", \")\n    for s in star:\n        if s != '-':\n            star_list.append(s)\nstar_df = pd.DataFrame.from_dict(Counter(star_list),orient='index').reset_index()\nstar_df = star_df.rename(columns = {\"index\":\"Star\",0:'Frequency'}).sort_values(by='Frequency',ascending = False)\nstar_df.head()","5d5d6577":"# Objective Which stars contributes to the highest rating of the show they are in \ncutoff = star_df['Frequency'].quantile(0.99) # Cutoff score for the 99 percentile in term of appearance\ntop1_star = star_df[star_df['Frequency'] > cutoff]['Star'].tolist()","fd2a3021":"for star in top1_star:\n    temp = tv[tv['Stars'].str.contains(star)]\n    average_rating = temp['Rating'].mean()\n    print(star, \":\",round(average_rating,3))","110981f5":"# Objective: Ranking by rating \ntv.sort_values(by='Rating',ascending = False).head(10)","0e44a79d":"drama = tv[tv['Genre'].str.contains('Animation|Game-Show|Reality-TV|Documentary') == False]\ndrama.head()","565c791e":"drama['Vote'].mean()","c169c097":"drama.sort_values(by='Rating',ascending = False).head()","da0e55bc":"# Boxplot...\nfig = px.box(drama, y=\"Vote\")\nfig.show()","de440eea":"# There are certainly outlier in the number of vote given \n# Removing the outlier using IQR method\nQ1 = drama['Vote'].quantile(0.25)\nQ3 = drama['Vote'].quantile(0.75)\nIQR = Q3 - Q1\n\nfig = px.box(drama[(drama['Vote'] >=  (Q1 - 1.5 * IQR)) & (drama['Vote'] <= (Q3 + 1.5 * IQR))], y=\"Vote\")\nfig.update_layout(title = {'text':'Number of Votes without Outlier'})\nfig.show()","31bec4cc":"drama[drama['Vote'] == drama['Vote'].max()]","a889bb8c":"tv['Time'].unique()","e798d9ea":"tv.sort_values(by='Time',ascending = False)","ac7e0788":"time_df = tv[tv['Time'] > 0]['Time'].value_counts().sort_values(ascending = False).reset_index().rename(columns = {'Time':'Frequency','index':'Time'})\ntime_df.head()","3917e942":"# Rating Zero would drive down the average (larger number of instances), the amount of vote also effects the mean statistics\ntv[(tv['Time'] > 0) & (tv['Rating'] > 0)].groupby(['Time']).describe().T.loc[[\"Rating\",\"Vote\"],[60,70]]","53dc2aec":"# Average Rating each Time \ntest = tv[tv['Genre'] != \"-\"].groupby(['Genre']).describe().T.loc[\"Rating\":\"Time\"]\ntest","59697753":"<h3 style = \"text-align:center;\n                 font-size:50px;\n                 font-family:optima,monspace;\">\n        \ud83c\uddf0\ud83c\uddf7 Korean TV-Series on IMDb\n<\/h3>","73e1ff59":"<h2 style = \"text-align:center\"> Data Cleaning<\/h2>\nIn this section, I will be cleaning up the data. Most of the column are in object type and we cannot performed certain arithmetics function to gain more insight. I have to change the format of those column and convert them to numeric type. Those columns would inclide: Year, Rating, Votes:, and Time.","7fdc1c53":"<h3 style = 'text-align:center;\n             font-size: 40px;\n             font-family: optima;'>\n    Thank you for checking out my work!\n<\/h3>\n<h5 style = 'text-align:center;\n             font-size: 20px;\n             font-family: optima'>\n    Please leave a comment and give an upvote if like my notebook.<br>\n    It is very much appreciated!\n<\/h5>\n","76a8859d":"<h2 style = \"text-align:center\">Release Year<\/h2>","4b993b69":"<h2 style = \"text-align:center\">Time<\/h2>","634de93c":"<h2 style = \"text-align:center\">Analysis<\/h2>\nWithout any filtering, it is interesting to find that the top rated tv-series are all featuring K pop idols. For instance, Snowdrop is a new drama featuring Jisoo Kim of Blackpink and it has a rating of 10, even when it wasn't released yet as of December 15, 2021. The runner-up tv-series features members of BTS, which is one of korean most famous boy band.<br>\nSince many of these top rated tv-series have relatively fewer votes than others, it is a good idea to setup a minium votes for other analysis. I will not be considering the tv-series that have Animation, Game-Show, and Reality-TV as part of it genre beacause I would like to explore specifically on Korean Drama.","5d31745d":"<h2 style = \"text-align:center\">Analysis<\/h2>\nThe top three categories that appeared the most are Drama, Romance, and Comedy. From the bar chart above, we can see that these three genres are ahead of others by a significant margin. We should examine what IMDb's descriptions for these genres are.<br><br>\n        Drama: Should contain numerous consecutive scenes of characters portrayed to effect a serious narrative throughout the title, usually involving conflicts and emotions. This can be exaggerated upon to produce melodrama.<br><br>Romance: Should contain numerous inter-related scenes of a character and their personal life with emphasis on emotional attachment or involvement with other characters, especially those characterized by a high level of purity and devotion<br><br>Comedy: Virtually all scenes should contain characters participating in humorous or comedic experiences. The comedy can be exclusively for the viewer, at the expense of the characters in the title, or be shared with them.<br><br>\n        You can also check out this <a href = \"https:\/\/help.imdb.com\/article\/contribution\/titles\/genres\/GZDRMS6R742JRGAG#drama\">official website<a> about Genres on IMDb for more information.","3575b511":"<h2 style = \"text-align:center\">Genre<\/h2>","eaef0cc3":"<h2 style = \"text-align:center;\">Stars<\/h2>\nAt least for myself, when I choose which Korean drama to watch, I always factor in the featuring stars and tend to give a lot of weight over other parameters. In this section, we will explore which korean actors or actresses feature in the most drama. Looking at purely the combination of the stars wouldn't show much because it is quite rare to have the same set of leading stars for different drama.","b3b2de67":"This is an example Notebook for Korean TV Series on IMDb dataset. Feel free to use the notebook as a guide for your own exploratory analysis. Please leave any comment, so that I can improve the notebook. If you find this useful, please give an upvote!"}}