{"cell_type":{"2072c56f":"code","f36988df":"code","c609f573":"code","879f93e4":"code","7407034b":"code","0bc3f4d5":"code","c0c693cd":"code","de05ef54":"code","e91eb910":"code","bd00568e":"code","1918f2d2":"code","e644cdc8":"code","0b153b06":"code","b127d34f":"code","3af6f742":"code","7fafbbf9":"code","a1b5b515":"code","692d8a1d":"code","cbc42484":"code","7db9cbf1":"code","9febb23a":"code","4c47fb6c":"code","16c5c9a6":"code","fa7f47b7":"code","2ce647fc":"code","542ac9c7":"code","ce80c779":"code","cc2e9655":"code","02880821":"code","ffab6233":"code","a6b66c5d":"code","440dd2b1":"code","fafb2bef":"code","7405ee86":"markdown","b43c9156":"markdown","6594f066":"markdown","f67e7f9f":"markdown","7a1dade6":"markdown","d67f0a1f":"markdown","52fdd70b":"markdown","b6f8279b":"markdown","740f1e8b":"markdown","39764b1e":"markdown","200b78a0":"markdown","4caf7b47":"markdown","9c828527":"markdown","9b2babb3":"markdown","67daf3a1":"markdown","2a12489a":"markdown","079e40a1":"markdown","5da2b4cc":"markdown","8950fffa":"markdown","20a140c2":"markdown","4db34ab4":"markdown","f849b04c":"markdown","a97b2a40":"markdown","396a9817":"markdown","61af2738":"markdown","d99e716c":"markdown","31e5101f":"markdown","a289f43e":"markdown","3e71908f":"markdown","fd8d1049":"markdown","94319fe5":"markdown","50916645":"markdown","20569458":"markdown"},"source":{"2072c56f":"!pip install plotly\n!pip install cufflinks\n!pip install chart_studio","f36988df":"import os\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\nfrom matplotlib import colors\nimport chart_studio.plotly as py\nimport cufflinks as cf\nimport plotly.express as px\n%matplotlib inline\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\ninit_notebook_mode(connected = True)\ncf.go_offline();\nimport plotly.graph_objs as go\nfrom IPython.display import IFrame\n\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier, VotingClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.linear_model import LogisticRegression\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split, StratifiedKFold, GridSearchCV\n\nfrom imblearn.over_sampling import SMOTE\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c609f573":"df = pd.read_csv('\/kaggle\/input\/pokemon-data\/pokemon_data.csv')\ndf  = df.drop([\"#\"], axis = 1)\ndf.head(10)","879f93e4":"print('Data Shape: {}'.format(df.shape))","7407034b":"df.columns[df.isnull().any()]","0bc3f4d5":"print(\"Types of Pok\u00e9mons:\", df[\"Type 1\"].unique())","c0c693cd":"IFrame('https:\/\/public.tableau.com\/views\/Pokmon_16141947229120\/Pokemon? :showVizHome=no&:embed=true',\n       width=900, height=820)","de05ef54":"df[\"Legendary\"] = df[\"Legendary\"].astype(str)\nF = df[df[\"Legendary\"] == \"False\"]\nT = df[df[\"Legendary\"] == \"True\"]\nplt.figure(figsize=(7,7))\nplt.scatter(F[\"Attack\"],F[\"Defense\"],label= \"False\", color=\"royalblue\", alpha=0.75 )\nplt.scatter(T[\"Attack\"],T[\"Defense\"], label = \"True\", color=\"red\", alpha=0.75)\nplt.xlabel(\"Attack\", size = 15)\nplt.ylabel(\"Defense\", size = 15)\nplt.title(\" Attack - Defense - Legendary\", size = 16)\nplt.legend(loc = 'best')\nplt.show()","e91eb910":"plt.figure(figsize=(7,7))\nplt.scatter(F[\"Sp. Atk\"],F[\"Sp. Def\"],\n            label= \"False\", color=\"royalblue\", alpha=0.75)\nplt.scatter(T[\"Sp. Atk\"],T[\"Sp. Def\"],\n            label = \"True\", color=\"red\", alpha=0.75)\nplt.xlabel(\"Special Attack\", size = 15)\nplt.ylabel(\"Special Defense\", size = 15)\nplt.title(\" Special Attack - Special Defense - Legendary\", size = 16)\nplt.legend(loc = 'best')\nplt.show()","bd00568e":"fig, axes = plt.subplots(2, 3, figsize=(18, 10))\nfig.suptitle('Pok\u00e9mon Stats by Generation', size  = 16)\n\nsns.boxplot(ax=axes[0, 0], data=df,x='Generation', y='Attack')\nsns.boxplot(ax=axes[0, 1], data=df,x='Generation', y='Defense')\nsns.boxplot(ax=axes[0, 2], data=df,x='Generation', y='Speed')\n\nsns.boxplot(ax=axes[1, 0], data=df,x='Generation', y='Sp. Atk')\nsns.boxplot(ax=axes[1, 1], data=df,x='Generation', y='Sp. Def')\nsns.boxplot(ax=axes[1, 2], data=df,x='Generation', y='HP')\nplt.show()","1918f2d2":"fig, axes = plt.subplots(2, 3, figsize=(18, 10))\nfig.suptitle('Pok\u00e9mon Stats by Generation', size  = 16)\n\nsns.violinplot(ax=axes[0, 0],data=df, x='Generation', y='Attack')\nsns.violinplot(ax=axes[0, 1],data=df, x='Generation', y='Defense')\nsns.violinplot(ax=axes[0, 2],data=df, x='Generation', y='Speed')\n\nsns.violinplot(ax=axes[1, 0],data=df, x='Generation', y='Sp. Atk')\nsns.violinplot(ax=axes[1, 1],data=df, x='Generation', y='Sp. Def')\nsns.violinplot(ax=axes[1, 2],data=df, x='Generation', y='HP')\nplt.show()","e644cdc8":"fig, axes = plt.subplots(2, 3, figsize=(18, 10))\nfig.suptitle('Pok\u00e9mon Stats by Legendary', size  = 16)\n\nsns.boxplot(ax=axes[0, 0],data=df, x='Legendary', y='Attack')\nsns.boxplot(ax=axes[0, 1],data=df, x='Legendary', y='Defense')\nsns.boxplot(ax=axes[0, 2],data=df, x='Legendary', y='Speed')\n\nsns.boxplot(ax=axes[1, 0],data=df, x='Legendary', y='Sp. Atk')\nsns.boxplot(ax=axes[1, 1],data=df, x='Legendary', y='Sp. Def')\nsns.boxplot(ax=axes[1, 2],data=df, x='Legendary', y='HP')\nplt.show()","0b153b06":"fig, axes = plt.subplots(2, 3, figsize=(18, 10))\nfig.suptitle('Pok\u00e9mon Stats by Legendary', size  = 16)\n\nsns.violinplot(ax=axes[0, 0], data=df,x='Legendary', y='Attack')\nsns.violinplot(ax=axes[0, 1], data=df,x='Legendary', y='Defense')\nsns.violinplot(ax=axes[0, 2], data=df,x='Legendary', y='Speed')\n\nsns.violinplot(ax=axes[1, 0], data=df,x='Legendary', y='Sp. Atk')\nsns.violinplot(ax=axes[1, 1], data=df,x='Legendary', y='Sp. Def')\nsns.violinplot(ax=axes[1, 2], data=df,x='Legendary', y='HP')\nplt.show()","b127d34f":"target_cols = [\"Attack\",\"Defense\",\"HP\",\"Speed\",\"Sp. Def\",\"Sp. Atk\"]\navg_skills = pd.DataFrame([[df[df[\"Type 1\"] == i][skill].mean() for i in df[\"Type 1\"].unique()] for skill in target_cols],\n                          index = target_cols,\n                          columns= df[\"Type 1\"].unique()).T\nfor i in range(len(avg_skills.index)):\n    fig = px.line_polar(avg_skills,\n                        r=avg_skills.iloc[i,],\n                        theta=avg_skills.columns,\n                        line_close=True,\n                        title = avg_skills.index[i],\n                        width=600,\n                        height=400,\n                        template=\"plotly_dark\")\n    fig.update_traces(fill='toself')\n    fig.update_polars(radialaxis_range=[i,round(avg_skills.max().max(),) + 4])\n    fig.show()","3af6f742":"tp1_sum = df[\"Type 1\"].value_counts().sum()\ntp2_sum = df[\"Type 2\"].value_counts().sum()\ntp1_count = []\ntp2_count = []\npokemon_counts = []\nfor i in df[\"Type 1\"].unique():\n    pokemon_counts.append(df[df[\"Type 1\"] == i].count()[\"Type 1\"] + df[df[\"Type 2\"] == i].count()[\"Type 2\"])\n    tp1_count.append(df[df[\"Type 1\"] == i].count()[\"Type 1\"])\n    tp2_count.append(df[df[\"Type 2\"] == i].count()[\"Type 2\"])\n\nfig, axs = plt.subplots(2, 2, figsize =(12,10))\nfig.suptitle('Number of Pok\u00e9mons by Types', size = 16)\naxs[0, 0].barh(df[\"Type 1\"].unique(),tp1_count, color = \"mediumpurple\")\naxs[0, 0].set_title('Type 1', size = 14)\n\naxs[0, 1].barh(df[\"Type 1\"].unique(),tp2_count, color = \"mediumpurple\")\naxs[0, 1].set_title('Type 2', size = 14)\n\naxs[1, 0].barh(df[\"Type 1\"].unique(),pokemon_counts, color = \"mediumpurple\")\naxs[1, 0].set_title('Sum of Type 1 and Type 2', size = 14)\n\naxs[1, 1].barh([\"Type 1\",\"Type 2\"],[tp1_sum,tp2_sum],color = \"mediumpurple\")\naxs[1, 1].set_title('Type 1 and Type 2', size = 14);","7fafbbf9":"fig = go.Figure(data=[go.Pie(labels=df['Legendary'].value_counts().keys(),\n                             values=df['Legendary'].value_counts().values)])\n\nfig.update_traces(hoverinfo='value',\n                  textinfo='label',\n                  textfont_size=16,\n                  textposition ='auto',\n                  showlegend=False,\n                  marker=dict(colors=['#337DFF', '#FF5733'],line=dict(color='black', width = 0.6)))\n\nfig.update_layout(title={'text': 'Legendary',\n                         'y':0.9,\n                         'x':0.5,\n                         'xanchor': 'center',\n                         'yanchor': 'top'},\n                 template='simple_white')\niplot(fig)","a1b5b515":"fig = go.Figure(data=[go.Pie(labels=df['Generation'].value_counts().keys(),\n                             values=df['Generation'].value_counts().values)])\nfig.update_traces(hoverinfo='value',\n                  textinfo='label',\n                  textfont_size=22,\n                  textposition ='auto',\n                  showlegend=False,\n                  marker=dict(colors=['#28F20C', '#F7322C', '#F27F0C', '#F12CF7','#337DFF','#F7F72C'],\n                              line=dict(color='black', width = 0.6)))\n\nfig.update_layout(title={'text': 'Generation',\n                         'y':0.9,\n                         'x':0.5,\n                         'xanchor': 'center',\n                         'yanchor': 'top'},\n                 template='simple_white')\niplot(fig)","692d8a1d":"cat = sns.catplot(y=\"Type 1\", hue=\"Legendary\", kind=\"count\",\n            edgecolor=\".6\", palette = \"Set2\",\n            legend =True,\n            data=df)\ncat.fig.set_size_inches(10,6)\nplt.yticks(size = 12)\ncat.set(xlabel=None)\ncat.set(ylabel=None)\ncat.set(title='Number of Legendary Pok\u00e9mons by Types')\nplt.show()","cbc42484":"generation_df = df.groupby('Generation').agg({'Attack':'mean',\n                                              'Defense':'mean',\n                                              'HP':'mean',\n                                              'Speed':'mean'})\n\ntrace1 = go.Scatter(x=generation_df.index, y= generation_df['Attack'],\n                    mode='lines', name='Attack',line = dict(color='#FF2F01',width=3))\n\ntrace2 = go.Scatter(x=generation_df.index, y= generation_df['Defense'],\n                    mode='lines', name='Defense',line = dict(color='#79F72C',width=3))\n\ntrace3 = go.Scatter(x=generation_df.index, y= generation_df['HP'],\n                    mode='lines', name='HP',line = dict(color='#2CA4F7',width=3))\n\ntrace4 = go.Scatter(x=generation_df.index, y= generation_df['Speed'],\n                    mode='lines', name='Speed',line = dict(color='#9E2CF7',width=3))\n\nlayout = go.Layout(title={'text': \"Attack - Defense - HP - Speed by Generations\",\n                          'y':0.9,\n                          'x':0.5,\n                          'xanchor': 'center',\n                          'yanchor': 'top'},\n                   xaxis = dict(title='Generation'),template='plotly_white')\n\nfig = go.Figure(data=[trace1, trace2, trace3, trace4], layout=layout)\niplot(fig)","7db9cbf1":"attack_avg = []\ndefense_avg = []\nhp_avg = []\nspeed_avg = []\nfor i in df[\"Type 1\"].unique():\n    attack_avg.append(df[df[\"Type 1\"] == i][\"Attack\"].mean())\n    defense_avg.append(df[df[\"Type 1\"] == i][\"Defense\"].mean())\n    hp_avg.append(df[df[\"Type 1\"] == i][\"HP\"].mean())\n    speed_avg.append(df[df[\"Type 1\"] == i][\"Speed\"].mean())\n    \n\nfig, axs = plt.subplots(2, 2, figsize =(12,10))\nfig.suptitle('Attack - Defense - HP - Speed by Types', size = 16)\naxs[0, 0].barh(df[\"Type 1\"].unique(), attack_avg, color = \"cornflowerblue\")\naxs[0, 0].set_title('Attack', size = 14)\n\naxs[0, 1].barh(df[\"Type 1\"].unique(), defense_avg, color = \"cornflowerblue\")\naxs[0, 1].set_title('Defense', size = 14)\n\naxs[1, 0].barh(df[\"Type 1\"].unique(), hp_avg, color = \"cornflowerblue\")\naxs[1, 0].set_title('HP', size = 14)\n\naxs[1, 1].barh(df[\"Type 1\"].unique(), speed_avg, color = \"cornflowerblue\")\naxs[1, 1].set_title('Speed', size = 14)\nfig.tight_layout()","9febb23a":"total = df[\"HP\"] + df[\"Attack\"] + df[\"Defense\"] + df[\"Sp. Atk\"] + df[\"Sp. Def\"] + df[\"Speed\"]\ntop5_type = {'Type': df[\"Type 1\"] ,'Overall': total}\ntop5_type = pd.DataFrame(top5_type)\ntop5_type = top5_type[[\"Overall\",\"Type\"]].groupby([\"Type\"], as_index = False).mean().sort_values(by=\"Overall\",ascending = False)[0:5]\n\nplt.figure(figsize = (10,6))\nplt.title(\"TOP 5 Strongest Type\", size = 16)\nsns.barplot(x = \"Overall\", y = \"Type\",\n            ci = None, data = top5_type,\n            dodge = False, palette = \"Dark2\")\nplt.yticks(size = 12)\nplt.show()","4c47fb6c":"top10_pokemon = {'Name': df[\"Name\"], 'Type': df[\"Type 1\"] ,'Overall': total}\ntop10_pokemon = pd.DataFrame(top10_pokemon)\ntop10_pokemon = top10_pokemon[[\"Name\",\"Type\",\"Overall\"]].sort_values(by = \"Overall\", ascending = False)[0:10]\n\nplt.figure(figsize = (12,8))\nplt.title(\"TOP 10 Strongest Pok\u00e9mon\", size = 16)\nsns.barplot(x = \"Overall\", y = \"Name\", hue = \"Type\", data = top10_pokemon, dodge = False)\nplt.yticks(size = 12)\nplt.show()","16c5c9a6":"sns.set_style(\"white\")\nmatrix = np.triu(df.corr(method=\"pearson\"))\nf,ax=plt.subplots(figsize = (10,10))\nsns.heatmap(df.corr(),annot= True,fmt = \".2f\",ax=ax,\n            vmin = -1, vmax = 1, mask = matrix, cmap = \"coolwarm\",\n            linewidth = 0.4,linecolor = \"white\",annot_kws={\"size\": 14})\nplt.xticks(rotation=60,size=14)\nplt.yticks(rotation=0,size=14)\nplt.title('Pearson Correlation Map', size = 14)\nplt.show()","fa7f47b7":"y = df[\"Legendary\"].values\nX = df.drop([\"Name\",\"Type 1\",\"Type 2\",\n             \"Legendary\",\"Generation\"], axis= 1)\nX.head()","2ce647fc":"X_train, X_test, y_train, y_test = train_test_split(X,y,test_size = 0.3,random_state=42)\n\nsm = SMOTE()\nX_train, y_train = sm.fit_resample(X_train, y_train)\n\nprint('X_train shape: {}'.format(X_train.shape))\nprint('y_train shape: {}'.format(y_train.shape))","542ac9c7":"sc = StandardScaler()\n\nX_train = sc.fit_transform(X_train)\nX_test = sc.transform(X_test)","ce80c779":"logreg = LogisticRegression()\nlogreg.fit(X_train, y_train)\n\nacc_log_train = round(logreg.score(X_train, y_train)*100,2) \nacc_log_test = round(logreg.score(X_test,y_test)*100,2)\n\nprint(\"Training Accuracy: % {}\".format(acc_log_train))\nprint(\"Testing Accuracy: % {}\".format(acc_log_test))","cc2e9655":"lr_pred = logreg.predict(X_test)\n\ncm = confusion_matrix(y_test, lr_pred)\ndf1 = pd.DataFrame(columns=[\"Not\",\"Legendary\"], index= [\"Not\",\"Legendary\"], data= cm )\n\nf,ax = plt.subplots(figsize=(4,4))\nsns.heatmap(df1, annot=True,cmap=\"Reds\",\n            fmt= '.0f',ax=ax,linewidths = 5,\n            cbar = False,annot_kws={\"size\": 16})\nplt.xlabel(\"Predicted Label\")\nplt.xticks(size = 12)\nplt.yticks(size = 12, rotation = 0)\nplt.ylabel(\"True Label\")\nplt.title(\"Confusion Matrix\", size = 12)\nplt.show()","02880821":"random_state = 42\nclassifier = [DecisionTreeClassifier(random_state = random_state),\n             SVC(random_state = random_state),\n             RandomForestClassifier(random_state = random_state),\n             LogisticRegression(random_state = random_state),\n             KNeighborsClassifier()]\n\ndt_param_grid = {\"min_samples_split\" : range(10,500,20),\n                \"max_depth\": range(1,20,2)}\n\nsvc_param_grid = {\"kernel\" : [\"rbf\"],\n                 \"gamma\": [0.001, 0.01, 0.1, 1],\n                 \"C\": [1,10,50,100,200,300,1000]}\n\nrf_param_grid = {\"max_features\": [1,3,10],\n                \"min_samples_split\":[2,3,10],\n                \"min_samples_leaf\":[1,3,10],\n                \"bootstrap\":[False],\n                \"n_estimators\":[100,300],\n                \"criterion\":[\"gini\"]}\n\nlogreg_param_grid = {'C' : np.logspace(-4, 4, 20),\n                \"penalty\": ['l1','l2']}\n\nknn_param_grid = {\"n_neighbors\": np.linspace(1,19,10, dtype = int).tolist(),\n                 \"weights\": [\"uniform\",\"distance\"],\n                 \"metric\":[\"euclidean\",\"manhattan\"]}\nclassifier_param = [dt_param_grid,\n                   svc_param_grid,\n                   rf_param_grid,\n                   logreg_param_grid,\n                   knn_param_grid]","ffab6233":"cv_result = []\nbest_estimators = []\nfor i in range(len(classifier)):\n    clf = GridSearchCV(classifier[i], param_grid=classifier_param[i], cv = StratifiedKFold(n_splits = 10), scoring = \"accuracy\", n_jobs = -1,verbose = 2)\n    clf.fit(X_train,y_train)\n    cv_result.append(clf.best_score_)\n    best_estimators.append(clf.best_estimator_)\n    print(cv_result[i])","a6b66c5d":"cv_results = pd.DataFrame({\"Cross Validation Means\":cv_result,\n                           \"ML Models\":[\"DecisionTreeClassifier\",\n                                        \"SVC\",\"RandomForestClassifier\",\n                                        \"LogisticRegression\",\n                                        \"KNeighborsClassifier\"]})\n\nplt.figure(figsize = (8,6))\ng = sns.barplot(\"Cross Validation Means\",\n                \"ML Models\", data = cv_results,\n               palette = \"Set1\")\ng.set_xlabel(\"Mean Accuracy\")\nplt.xlim(0.9,1)\ng.set_title(\"Cross Validation Scores\");","440dd2b1":"votingC = VotingClassifier(estimators = [(\"svc\",best_estimators[1]),\n                                        (\"rf\",best_estimators[2]),\n                                        (\"knn\",best_estimators[4])])\n\nvotingC = votingC.fit(X_train, y_train)\nvoting_pred = votingC.predict(X_test)\n\nprint(classification_report(y_test, voting_pred))","fafb2bef":"cm = confusion_matrix(y_test, voting_pred)\n\ndf1 = pd.DataFrame(columns=[\"Not\",\"Legendary\"], index= [\"Not\",\"Legendary\"], data= cm )\nf,ax = plt.subplots(figsize=(4,4))\n\nsns.heatmap(df1, annot=True,cmap=\"Reds\",\n            fmt= '.0f',ax=ax,linewidths = 5,\n            cbar = False,annot_kws={\"size\": 16})\nplt.xlabel(\"Predicted Label\")\nplt.xticks(size = 12)\nplt.yticks(size = 12, rotation = 0)\nplt.ylabel(\"True Label\")\nplt.title(\"Confusion Matrix\", size = 12)\nplt.show()","7405ee86":"<img src= \"https:\/\/media.giphy.com\/media\/s6V4JivpKeXBe\/giphy.gif\">","b43c9156":"<img src= \"https:\/\/media.giphy.com\/media\/QzxONYL3xbj6E\/giphy.gif\">","6594f066":"<a id = \"17\"><\/a>\n## Scaling","f67e7f9f":"<a id = \"6\"><\/a>\n## Attack - Defense - Legendary","7a1dade6":"<img src= \"https:\/\/media.giphy.com\/media\/10LKovKon8DENq\/giphy.gif\">","d67f0a1f":"<a id = \"4\"><\/a>\n# Variable Description\nThis data set includes 800 Pok\u00e9mons, including their number, name, first and second type, and basic stats: HP, Attack, Defense, Special Attack, Special Defense, Speed and Legendary. It has been of great use when teaching statistics to kids. With certain types you can also give a geeky introduction to machine learning.\n1. **Name:** Name of each pokemon\n2. **Type 1:** Each pokemon has a type, this determines weakness\/resistance to attacks\n3. **Type 2:** Some pokemon are dual type and have 2\n4. **HP:** hit points, or health, defines how much damage a pokemon can withstand before fainting\n5. **Attack:** the base modifier for normal attacks (eg. Scratch, Punch)\n6. **Defense:** the base damage resistance against normal attacks\n7. **SP Atk:** special attack, the base modifier for special attacks (e.g. fire blast, bubble beam)\n8. **SP Def:** the base damage resistance against special attacks \n9. **Speed:** determines which pokemon attacks first each round\n10. **Legendary:** indicates whether pokemon is legendary","52fdd70b":"<a id = \"8\"><\/a>\n## Percentages by Legendary and Generation","b6f8279b":"<a id = \"23\"><\/a>\n## Pok\u00e9mon Stats by Generation","740f1e8b":"<img src= \"https:\/\/media.giphy.com\/media\/AFdcYElkoNAUE\/giphy.gif\">","39764b1e":"<a id = \"24\"><\/a>\n## Pok\u00e9mon Stats by Legendary","200b78a0":"<a id = \"12\"><\/a>\n## TOP 5 Strongest Type","4caf7b47":"<a id = \"7\"><\/a>\n## Number of Pok\u00e9mons by Types","9c828527":"<a id = \"18\"><\/a>\n## Logistic Regression","9b2babb3":"<a id = \"9\"><\/a>\n## Number of Legendary Pok\u00e9mons by Types","67daf3a1":"<a id = \"21\"><\/a>\n## Special Attack - Special Defense - Legendary","2a12489a":"<a id = \"14\"><\/a>\n# Models\n<a id = \"15\"><\/a>\n## Dependent - Independent Variables\n- Legendary is dependent variable.\n- Attack, Defense, HP, Speed, Sp. Atk and Sp. Def are independent variables.","079e40a1":"<a id = \"13\"><\/a>\n## Pearson Correlation Map","5da2b4cc":"![image.png](attachment:image.png)","8950fffa":"<a id = \"11\"><\/a>\n## Attack - Defense - HP - Speed by Types","20a140c2":"<a id = \"1\"><\/a>\n# Introduction\nPok\u00e9mon, also known as Pocket Monsters in Japan, is a Japanese media franchise managed by The Pok\u00e9mon Company, a company founded by Nintendo, Game Freak, and Creatures. The franchise was created by Satoshi Tajiri in 1995, and is centered on fictional creatures called \"Pok\u00e9mon\", which humans, known as Pok\u00e9mon Trainers, catch and train to battle each other for sport. Games, shows and other works within the franchise are set in the Pok\u00e9mon universe. The English slogan for the franchise is \"Gotta Catch 'Em All\".","4db34ab4":"<p style=\"color: Black;\n          text-align: center;\n          font-size:250%;\">\nGotta Catch 'Em All!\n<\/p>","f849b04c":"<a id = \"3\"><\/a>\n# Load and Check Data","a97b2a40":"<a id = \"2\"><\/a>\n# Libraries and Utilities","396a9817":"<a id = \"10\"><\/a>\n## Attack - Defense - HP - Speed by Generations","61af2738":"1. [Introduction](#1)\n2. [Libraries and Utilities](#2)   \n3. [Load and Check Data](#3)   \n4. [Variable Description](#4)\n5. [Data Analysis](#5)\n    * [Attack - Defense - Legendary](#6)  \n    * [Special Attack - Special Defense - Legendary](#21)\n    * [Pok\u00e9mon Stats by Generation](#23)\n    * [Pok\u00e9mon Stats by Legendary](#24)\n    * [Pok\u00e9mon Stats by Types](#25)\n    * [Number of Pok\u00e9mons by Types](#7) \n    * [Percentages by Legendary and Generation](#8)\n    * [Number of Legendary Pok\u00e9mons by Types](#9)\n    * [Attack - Defense - HP - Speed by Generations](#10)\n    * [Attack - Defense - HP - Speed by Types](#11)\n    * [TOP 5 Strongest Type](#12)\n    * [TOP 10 Strongest Pok\u00e9mon](#22)\n    * [Pearson Correlation Map](#13)\n6. [Models](#14)\n    * [Dependent - Independent Variables](#15)\n    * [Train - Test Split](#16)\n    * [Standard Scaler](#17)\n    * [Logistic Regression](#18)\n    * [Hyperparameter Tuning - Grid Search - Cross Validation](#19)\n    * [Ensemble Learning](#20)","d99e716c":"<a id = \"19\"><\/a>\n## Hyperparameter Tuning - Grid Search - Cross Validation\nWe will compare 5 ml classifier and evaluate mean accuracy of each of them by stratified cross validation.\n\n- Decision Tree\n- SVM\n- Random Forest\n- KNN\n- Logistic Regression","31e5101f":"<img src= \"https:\/\/media.giphy.com\/media\/4V9pnhxTv6eha\/giphy.gif\">","a289f43e":"<a id = \"22\"><\/a>\n## TOP 10 Strongest Pok\u00e9mon","3e71908f":"<a id = \"16\"><\/a>\n## Train - Test Split","fd8d1049":"<a id = \"5\"><\/a>\n# Data Analysis","94319fe5":"<a id = \"25\"><\/a>\n## Pok\u00e9mon Stats by Types","50916645":"<img src= \"https:\/\/media.giphy.com\/media\/gHnwTttExPf4nwOWm7\/giphy.gif\">","20569458":"<a id = \"20\"><\/a>\n## Ensemble Learning"}}