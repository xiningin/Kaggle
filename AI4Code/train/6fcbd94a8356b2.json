{"cell_type":{"a41bfef3":"code","dd673232":"code","ee60a09b":"code","d57f5c9d":"markdown"},"source":{"a41bfef3":"# Install:\n# Kaggle environments.\n!git clone https:\/\/github.com\/Kaggle\/kaggle-environments.git\n!cd kaggle-environments && pip install .\n\n# GFootball environment.\n!apt-get update -y\n!apt-get install -y libsdl2-gfx-dev libsdl2-ttf-dev\n\n# Make sure that the Branch in git clone and in wget call matches !!\n!git clone -b v2.6 https:\/\/github.com\/google-research\/football.git\n!mkdir -p football\/third_party\/gfootball_engine\/lib\n\n!wget https:\/\/storage.googleapis.com\/gfootball\/prebuilt_gameplayfootball_v2.6.so -O football\/third_party\/gfootball_engine\/lib\/prebuilt_gameplayfootball.so\n!cd football && GFOOTBALL_USE_PREBUILT_SO=1 pip3 install .","dd673232":"%%writefile submission.py\nfrom kaggle_environments.envs.football.helpers import *\nfrom math import sqrt\n\ndirections = [\n[Action.TopLeft, Action.Top, Action.TopRight],\n[Action.Left, Action.Idle, Action.Right],\n[Action.BottomLeft, Action.Bottom, Action.BottomRight]]\n\ndirsign = lambda x: 1 if abs(x) < 0.01 else (0 if x < 0 else 2)\n\nenemyGoal = [1, 0]\nperfectRange = [[0.61, 1], [-0.2, 0.2]]\n\ndef inside(pos, area):\n    return area[0][0] <= pos[0] <= area[0][1] and area[1][0] <= pos[1] <= area[1][1]\n\ndef get_distance(pos1,pos2):\n    return ((pos1[0]-pos2[0])**2+(pos1[1]-pos2[1])**2)**0.5\n\ndef player_direction(obs):\n    controlled_player_pos = obs['left_team'][obs['active']]\n    controlled_player_dir = obs['left_team_direction'][obs['active']]\n    x = controlled_player_pos[0]\n    y = controlled_player_pos[1]\n    dx = controlled_player_dir[0]\n    dy = controlled_player_dir[1]\n    \n    if x <= dx:\n        return 0\n    if x > dx:\n        return 1\n\ndef run_pass(left_team,right_team,x,y):\n    ###Are there defenders dead ahead?\n    defenders=0\n    for i in range(len(right_team)):\n        if right_team[i][0] > x and y +.01 >= right_team[i][1] and right_team[i][1]>= y - .01:\n            if abs(right_team[i][0] - x) <.01:\n                defenders=defenders+1\n    if defenders == 0:\n        return Action.Right\n    \n    teammateL=0\n    teammateR=0\n    for i in range(len(left_team)):\n        #is there a teamate close to left\n        if left_team[i][0] >= x:\n            if left_team[i][1] < y:\n                if abs(left_team[i][1] - x) <.05:\n                    teammateL=teammateL+1\n        \n        #is there a teamate to right\n        if left_team[i][0] >= x:\n            if left_team[i][1] > y:\n                if abs(left_team[i][1] - x) <.05:\n                    teammateR=teammateR+1\n    #pass only close to goal\n    if x >.75:\n        if teammateL > 0 or teammateR > 0:\n            return Action.ShortPass\n    \n    if defenders > 0 and y>=0:\n        return Action.TopRight\n    \n    if defenders > 0 and y<0:\n        return Action.BottomRight\n\n@human_readable_agent\ndef agent(obs):\n    controlled_player_pos = obs['left_team'][obs['active']]\n    \n    # special plays\n    if obs[\"game_mode\"] == GameMode.Penalty:\n        return Action.Shot\n    if obs[\"game_mode\"] == GameMode.Corner:\n        if controlled_player_pos[0] > 0:\n            return Action.Shot\n    if obs[\"game_mode\"] == GameMode.FreeKick:\n        return Action.Shot\n    \n    # Make sure player is running.\n    if  0 < controlled_player_pos[0] < 0.6 and Action.Sprint not in obs['sticky_actions']:\n        return Action.Sprint\n    elif 0.6 < controlled_player_pos[0] and Action.Sprint in obs['sticky_actions']:\n        return Action.ReleaseSprint\n\n    # Does the player we control have the ball?\n    if obs['ball_owned_player'] == obs['active'] and obs['ball_owned_team'] == 0:\n        \n        goalkeeper = 0\n        #if in the zone near goal shoot\n        if inside(controlled_player_pos, perfectRange) and controlled_player_pos[0] < obs['ball'][0]:\n            return Action.Shot\n        #if the goalie is coming out on player near goal shoot\n        elif abs(obs['right_team'][goalkeeper][0] - 1) > 0.2 and controlled_player_pos[0] > 0.4 and abs(controlled_player_pos[1]) < 0.2:\n            return Action.Shot\n        # if close to goal and too wide for shot pass the ball\n        if controlled_player_pos[0] >.75 and controlled_player_pos[1] >.20 or controlled_player_pos[0] >.75 and controlled_player_pos[1] <-.20 :\n            return Action.ShortPass\n        # if near our goal and moving away long pass to get out of our zone\n        if player_direction(obs)==1 and controlled_player_pos[0]<-.3:\n            return Action.LongPass\n        # which way should we run or pass\n        else:\n            return run_pass(obs['left_team'],obs['right_team'],controlled_player_pos[0],controlled_player_pos[1])\n    else:\n        #vector where ball is going\n        ball_targetx=obs['ball'][0]+obs['ball_direction'][0]\n        ball_targety=obs['ball'][1]+obs['ball_direction'][1]\n        \n        #euclidian distance to the ball so we head off movement until very close\n        e_dist=get_distance(obs['left_team'][obs['active']],obs['ball'])\n        \n        #if not close to ball move to where it is going\n        if e_dist >.005:\n            # Run where ball will be\n            xdir = dirsign(ball_targetx - controlled_player_pos[0])\n            ydir = dirsign(ball_targety - controlled_player_pos[1])\n            return directions[ydir][xdir]\n        #if close to ball go to ball\n        else:\n            # Run towards the ball.\n            xdir = dirsign(obs['ball'][0] - controlled_player_pos[0])\n            ydir = dirsign(obs['ball'][1] - controlled_player_pos[1])\n            return directions[ydir][xdir]","ee60a09b":"# Set up the Environment.\nfrom kaggle_environments import make\nenv = make(\"football\", configuration={\"save_video\": True, \"scenario_name\": \"11_vs_11_kaggle\", \"running_in_notebook\": True})\noutput = env.run([\"\/kaggle\/working\/submission.py\", \"do_nothing\"])[-1]\nprint('Left player: reward = %s, status = %s, info = %s' % (output[0]['reward'], output[0]['status'], output[0]['info']))\nprint('Right player: reward = %s, status = %s, info = %s' % (output[1]['reward'], output[1]['status'], output[1]['info']))\nenv.render(mode=\"human\", width=800, height=600)","d57f5c9d":"# Sharing my Best rules bot\n\n**This bot is a fork of my best rules based bot - it is currently in 71st place at 1020.7  as of 10\/17, but has been as high as 1055 so far and has beat some 1100 bots.**\n\nWith the new week, I am moving on to \"trying\" to build an RL bot with PyTorch - I did a simple RL project years ago, but I am just getting going on Deep RL and PyTorch.  I have spent my time this last week working on understanding the environment and working on a rules based bot to get a feel for how much success a rules based bot can have. \n\nThis competition brings back memories of my Artificial Intelligence for Robotics at Georgia Tech... that was an amazing class that was hard, but I loved every minute.\n\nI want to give credit to @eugenkeil (notebook baseline bot) and @raffaelemorganti (notebook rule-based way) that really helped me hit the ground running and gave me many many ideas for making a good rule based bot.\n\nThe major items in this bot that I contirbuted are a VERY CRUDE system (run_pass function) that determines where defenders are and tries to run around them or pass to open teammates nearby.  The system also runs to where the ball is going when it doesn't have the ball and then moves to ball when close - this helps the bots defense IMO and makes a big difference.\n\nI hope it helps and if so, please share ideas and code with others as that is how we all learn.  Also, if you find this useful and have an code you'd be willing to share to help me get a jumpstart on training my Deep RL with Pytorch I will gladly accept it."}}