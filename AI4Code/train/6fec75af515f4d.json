{"cell_type":{"58cd1fb6":"code","dd5b0dfe":"code","8804ec60":"code","d77545fb":"code","29a68233":"code","efc47dab":"code","01117a96":"code","399b31f1":"code","fe06ea27":"code","a87fd853":"code","e11c2bde":"code","5fe2d17c":"code","a9a08e49":"code","a4da6f09":"code","06705d16":"code","aa9025ff":"code","a25e2774":"code","1722d612":"code","532841f7":"code","57681aeb":"markdown","ee3dc2d4":"markdown","95549270":"markdown","ac0fd522":"markdown","c3a6270d":"markdown","ade30994":"markdown","5d3876f6":"markdown","74852e1e":"markdown","0e65fe4c":"markdown","0e527979":"markdown","4da06f33":"markdown","0f758404":"markdown","cca2eab8":"markdown","215e4452":"markdown"},"source":{"58cd1fb6":"!python -m pip install gwpy","dd5b0dfe":"from gwpy.timeseries import TimeSeries\nfrom gwpy.plot import Plot\nimport numpy as np\nfrom scipy import signal\nfrom sklearn.preprocessing import MinMaxScaler\nfrom PIL import Image\nfrom matplotlib import pyplot as plt","8804ec60":"def read_file(fname):\n    data = np.load(fname)\n    d1 = TimeSeries(data[0,:], sample_rate=2048)\n    d2 = TimeSeries(data[1,:], sample_rate=2048)\n    d3 = TimeSeries(data[2,:], sample_rate=2048)\n    return d1, d2, d3\n\ndef plot_time_data(d1, d2, d3):\n    plot = Plot(d1, d2, d3, separate=True, sharex=True, figsize=[12, 8])\n    ax = plot.gca()\n    ax.set_xlim(0,2)\n    ax.set_xlabel('Time [s]')\n    plot.show()","d77545fb":"d1, d2, d3 = read_file('..\/input\/g2net-gravitational-wave-detection\/train\/0\/0\/0\/0002b64784.npy')\nplot_time_data(d1, d2, d3)","29a68233":"window = signal.tukey(4096)\nplt.plot(window);","efc47dab":"d1, d2, d3 = d1*window, d2*window, d3*window\nplot_time_data(d1, d2, d3)","01117a96":"fig2 = d1.asd(fftlength=2).plot(figsize=[12, 6])\nplt.xlim(10,1024)\nplt.ylim(1e-24, 1e-19);","399b31f1":"white_data = d1.whiten()\nbp_data = white_data.bandpass(35, 350) # frequency range 35-350Hz\nfig3 = bp_data.plot(figsize=[12, 6])\nplt.xlim(0, 2)\nax = plt.gca()\nax.set_title('Whitened and bandpassed')\nax.set_xlabel('Time [s]');","fe06ea27":"def preprocess(d1, d2, d3, lf=35, hf=350):\n    window = signal.tukey(4096)\n    d1, d2, d3 = d1*window, d2*window, d3*window\n    white_d1 = d1.whiten()\n    white_d2 = d2.whiten()\n    white_d3 = d3.whiten()\n    bp_d1 = white_d1.bandpass(lf, hf) \n    bp_d2 = white_d2.bandpass(lf, hf)\n    bp_d3 = white_d3.bandpass(lf, hf)\n    return bp_d1, bp_d2, bp_d3","a87fd853":"r1, r2, r3 = read_file('..\/input\/g2net-gravitational-wave-detection\/train\/0\/0\/0\/0002b64784.npy')\np1, p2, p3 = preprocess(r1, r2, r3)\nhq = p1.q_transform(outseg=(0, 2))\nfig4 = hq.plot(figsize=[12, 10])\nax = fig4.gca()\nfig4.colorbar(label=\"Normalised energy\")\nax.grid(False)\nax.set_yscale('log')\nax.set_xlabel('Time [s]');","e11c2bde":"def create_rgb(fname):\n    r1, r2, r3 = read_file(fname)\n    p1, p2, p3 = preprocess(r1, r2, r3)\n    hq1 = p1.q_transform(outseg=(0, 2))\n    hq2 = p2.q_transform(outseg=(0, 2))\n    hq3 = p3.q_transform(outseg=(0, 2))\n    img = np.zeros([hq1.shape[0], hq1.shape[1], 3], dtype=np.uint8)\n    scaler = MinMaxScaler()\n    img[:,:,0] = 255*scaler.fit_transform(hq1)\n    img[:,:,1] = 255*scaler.fit_transform(hq2)\n    img[:,:,2] = 255*scaler.fit_transform(hq3)\n    return Image.fromarray(img).rotate(90, expand=1)","5fe2d17c":"create_rgb('..\/input\/g2net-gravitational-wave-detection\/train\/4\/1\/0\/410031196b.npy')","a9a08e49":"def id2path(img_id, is_test):\n    a, b, c = img_id[0], img_id[1], img_id[2]\n    if is_test: return f'..\/input\/g2net-gravitational-wave-detection\/test\/{a}\/{b}\/{c}\/{img_id}.npy'\n    return f'..\/input\/g2net-gravitational-wave-detection\/train\/{a}\/{b}\/{c}\/{img_id}.npy'","a4da6f09":"import pandas as pd\ndf = pd.read_csv('..\/input\/g2net-gravitational-wave-detection\/sample_submission.csv')","06705d16":"import os\nos.makedirs('test_images', exist_ok=True)","aa9025ff":"def save_test_img(_id):\n    fname = id2path(_id, True)\n    im = create_rgb(fname)\n    im = im.resize((300,300), Image.BILINEAR)\n    im.save(f'test_images\/{_id}.png', format=\"png\")","a25e2774":"df = df[:56500]\nlen(df)","1722d612":"# https:\/\/www.kaggle.com\/yasufuminakama\/g2net-spectrogram-generation-train\nimport joblib\nfrom tqdm.auto import tqdm\n\n_ = joblib.Parallel(n_jobs=8)(\n    joblib.delayed(save_test_img)(_id) for _id in tqdm(df['id'].values)\n)\n","532841f7":"import shutil\n\nshutil.make_archive('test_images', 'zip', 'test_images')\nshutil.rmtree('test_images')","57681aeb":"# Read & plot files\nLet's define helper function to read numpy data and convert into GWpy TimeSeries format and plot the data.","ee3dc2d4":"Now, we have a preprocessed data that is ready for further analysis. First, let's define a function that combines all the steps above and outputs preprocessed data:","95549270":"Let's look at the signal after windowing:","ac0fd522":"# Preprocess\nThen we will follow the general processing steps outlined in [this article](https:\/\/iopscience.iop.org\/article\/10.1088\/1361-6382\/ab685e):  \n* Apply a window function (Tukey - tapered cosine window) to suppress spectral leakage\n* Whiten the spectrum\n* Bandpass","c3a6270d":"# Q-Transform\nThe Q-Transform is related to the Fourier transform, and very closely related to a wavelet transform. The spectrogram is a possible candidate as input for a CNN model.","ade30994":"The Tukey window looks like this:","5d3876f6":"Awesome! (Or crazy?) Next step is to find out if we can train an image classifier with these images...","74852e1e":"## Apply window function","0e65fe4c":"## Spectral whitening and bandpass filtering\nThis is super simple with GWpy:","0e527979":"This code is directly copied from https:\/\/www.kaggle.com\/mistag\/data-preprocessing-with-gwpy by Geir Drange (please upvote his notebook), I'm publishing it only to show how I used this code to create a preprocessed dataset.","4da06f33":"## Combine three channels into one RGB image\nSince we have 3 detectors, we can combine the Q-Transforms as RGB channels into one color image. Let's make a function for that:","0f758404":"Visualize a file:","cca2eab8":"# Processing of gravitational data\nIn this notebook we will apply some signal processing to the gravitational data. Preprocessing is definately required on these signals, and thankfully there is a Python package called [GWpy](https:\/\/gwpy.github.io\/docs\/latest\/index.html) that has all functions that are needed. Theory will not be discussed here in detail, but there are plenty of info and code on the topic:   \n  * [GW tutorials](https:\/\/www.gw-openscience.org\/tutorials\/)\n  * [Gravitational Wave Open Science Center](https:\/\/www.gw-openscience.org\/software\/)\n  * [A guide to LIGO\u2013Virgo detector noise and extraction of transient gravitational-wave signals](https:\/\/iopscience.iop.org\/article\/10.1088\/1361-6382\/ab685e)\n  \n  \nFirst, install GWpy:","215e4452":"Take a look at the spectrum:"}}