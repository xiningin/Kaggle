{"cell_type":{"7444869e":"code","1cf3a8b7":"code","90cea2bb":"code","99f8393c":"code","0817de2b":"code","4c4b43e0":"code","20b69fa3":"code","f8b59127":"code","699cf9d0":"markdown"},"source":{"7444869e":"! pip install imutils\n\nimport os\nimport math\nimport cv2\nimport dlib\nimport numpy as np\nimport pandas as pd\nfrom imutils import face_utils\nimport matplotlib.pyplot as plt","1cf3a8b7":"# Define mathematics functions\n\ndef equation1(points):\n    # This method is a part of Eyebrows shape detector\n    # Use shape_predictor_68 as a reference for points\n    # points = [22,23,24,25,26]  (right eyebrow) - (method works for left eyebrow too)\n    avgPoint = [np.average(points[[2,3],0]), np.average(points[[2,3],1])]\n    angle = angle_of_3points(avgPoint,points[1],points[4])\n    result = angle\n    return result\n\ndef equation2(points):\n    # This method is a part of Eyebrows shape detector\n    # Use shape_predictor_68 as a reference for points\n    # points = [22,23,24,25,26]  (right eyebrow) - (method works for left eyebrow too)\n    result = slope(points[3], points[4])\n    if result == \"inf\" or result == 0 :\n        return 1\n    return result\n\ndef equation3(points):\n    # This method is a part of Eyebrows shape detector\n    # Use shape_predictor_68 as a reference for points\n    # points = [22,23,24,25,26]  (right eyebrow) - (method works for left eyebrow too)\n    result = slope(points[1], points[2], True)\n    if result == \"inf\" :\n        result = 0\n    x1,y1 = points[3]\n    x2,y2 = points[4]\n    slope2 = slope(points[3], points[4], True)\n    if slope2 == \"inf\" :\n        slope2 = 0\n    result += slope2\n    result = 1 if result == 0 else result\n    return result\n\n\ndef equation4(points):\n    # This method is a part of Eyebrows shape detector\n    # Use shape_predictor_68 as a reference for points\n    # points = [22,23,24,25,26]  (right eyebrow) - (method works for left eyebrow too)\n    total = np.array([])\n    for i in range(len(points)-2):\n        total = np.append(total, (points[i+1,1] - points[i,1]))\n        \n    differences = abs(total[1]-total[0]) + abs(total[2] - total[1])\n    \n    slope0 = slope(points[0], points[1], True)\n    slope1 = slope(points[2], points[3])\n    slope2 = slope(points[3], points[4], True)\n    \n    slope0 = 1 if (slope0 == 0 or slope0 == \"inf\") else slope0    \n    slope1 = 1 if (slope1 == 0 or slope1 == \"inf\") else slope1\n    \n    differences = 1 if differences == 0 else differences\n    \n    result = slope2 * (0.5*slope1\/slope0) * (5\/differences)\n    result = 1 if result == 0 else result\n    return result\n\n\n\n# Function to calculate area of any shape given its points coordinates\ndef shape_area(points, circularArray=False):\n    # Circular array means that first point is added to the end of the array    \n    result = 0\n    for i in range(len(points)-1):\n        x1,y1 = points[i]\n        x2,y2 = points[i+1]\n        result += (x1*y2) - (y1*x2)\n    if not circularArray:\n        x1,y1 = points[len(points)-1]\n        x2,y2 = points[0]\n        result += (x1*y2) - (y1*x2)\n    result \/= 2\n    return abs(result)\n\n\n# Function to get the angle of three points\ndef angle_of_3points(p1,p2,p3):\n    # NOTE : p1 is the middle point\n    radian = math.atan2(p3[1] - p1[1], p3[0] - p1[0]) - math.atan2(p2[1] - p1[1], p2[0] - p1[0])\n    degrees = math.degrees(abs(radian))\n    return degrees\n\ndef slope(point1, point2, absolute=False):\n    x1,y1 = point1\n    x2,y2 = point2\n    deltaX = x2-x1\n    deltaY = y2-y1\n    if deltaX == 0:\n        return \"inf\"\n    slope = deltaY \/ deltaX\n    if absolute:\n        slope = abs(slope)\n    return round(slope,3)\n\n\n# Function to calculate the difference between 2 points on Y-axis\ndef diff_Yaxis(point1,point2):\n    return round(point1[1] - point2[1],3)\n\n# Function to calculate the coordinates of the center of the eye\ndef eyeCenter(points):\n    p1,p2,p3,p4 = points\n    x = np.average([p1[0],p2[0],p3[0],p4[0]])\n    y = np.average([p1[1],p2[1],p3[1],p4[1]])\n    return np.array([x,y])\n\n# Function to calculate the gradient difference in Y-axis for a group of points\ndef sum_difference(points):\n    result = 0\n    for i in range(points.shape[0]-1):\n        result += diff_Yaxis(points[i], points[i+1])\n    return round(result,3)\n\n\n# Function to calculate the sum of slopes of a group of points\ndef sum_slopes(points, absolute=False):\n    result = 0\n    for i in range(points.shape[0]-1):\n        _slope = slope(points[i], points[i+1], absolute)\n        if _slope == \"inf\":\n            continue\n        result += _slope\n    return round(result,3)","90cea2bb":"# Define helper functions\n\ndef load_images_from_folder(folder):\n    images = []\n    filenames = []\n    for filename in os.listdir(folder):\n        img = cv2.imread(os.path.join(folder, filename))\n        if img is not None:\n            images.append(img)\n            filenames.append(filename)\n    return images, filenames","99f8393c":"# Computer Vision functions\n\npredictor68 = dlib.shape_predictor('..\/input\/shape-predictor-68-face-landmarks\/shape_predictor_68_face_landmarks.dat')\npredictor81 = dlib.shape_predictor('..\/input\/shape-predictor81\/shape_predictor_81_face_landmarks.dat')\n\n# Function to determine the color range allowed to move landmarks points through image\ndef getAllowedColorRange(avgSkinColor):\n    # Dark skin\n    if (avgSkinColor < 100):\n        colorRange = (avgSkinColor-35, avgSkinColor+50)\n    # Somehow dark skin\n    elif(avgSkinColor <= 130): \n        colorRange = (avgSkinColor-30, avgSkinColor+30)\n    # Normal skin color (tends to dark)\n    elif(avgSkinColor <= 160):\n        colorRange = (avgSkinColor-40, avgSkinColor+40) \n    # Normal skin color \n    elif(avgSkinColor < 180):\n        colorRange = (avgSkinColor-50, avgSkinColor+50)\n    # Normal skin color (tends to white)\n    elif(avgSkinColor < 210):\n        colorRange = (avgSkinColor-50, avgSkinColor+30) \n    # white skin color\n    elif (avgSkinColor < 230):\n        colorRange = (avgSkinColor-40, avgSkinColor+20)\n    # Abnormal white skin color\n    else:\n        colorRange = (avgSkinColor-30, avgSkinColor+15)\n    return colorRange\n\n# Function to move landmarks points, based on skincolor\ndef moveUp(grayscale_image, point, avgSkinColor, foreheadHeight):\n    # Get color range & current color where the point is located in image\n    steps = 5\n    portionOfOriginalPointY = 0.275\n    originalPoint = np.copy(point)\n    colorRange = getAllowedColorRange(avgSkinColor)\n    currentPixelColor = grayscale_image.item(point[1],point[0])\n    \n    # move the landmark point up until a strong change of color happen (outside color range)\n    while currentPixelColor > colorRange[0] and currentPixelColor < colorRange[1]:\n        \n        # If point is going out of image boundary\n        if point[1] < 0:\n            # Get back to original point location, with a little bit higher\n            point[1] = originalPoint[1] - (originalPoint[1] * portionOfOriginalPointY)\n            break\n            \n        # move up (N steps) pixels & get the color\n        point[1] = point[1] - steps\n        \n        currentPixelColor = grayscale_image.item(point[1],point[0])\n        \n    # if the pixel is moved too high than expected (3\/4 forehead height): keep close to original\n    if abs( originalPoint[1] - point[1] ) > ( foreheadHeight * 0.75 ):\n        point[1] = originalPoint[1] - (originalPoint[1] * portionOfOriginalPointY)\n    return point\n\n# Function to detect if the forehead is clear or covered with hair (it corrupts the enhancement of landmarks points)\ndef clearForehead(forehead, avgSkinColor):\n    clarityThreshold = 85\n    colorRange = getAllowedColorRange(avgSkinColor)\n    \n    # Check if most of the forehead is the same as skin color\n    regionOK = np.logical_and(forehead > colorRange[0] , forehead < colorRange[1])\n    try:\n        percentage = (np.count_nonzero(regionOK) \/ forehead.size) * 100\n    except:\n        return False\n    isClear = True if percentage >= clarityThreshold else False\n    return isClear\n\n\n# Function to perform facial landmark detection on the whole face\ndef facial_landmarks(image, eyeOnlyMode=False, allowEnhancement=False):\n    # ARGUMENTS:\n    # - eyeOnlyMode: detect & return eye landmarks, used to align face\n    # - allowEnhancement: allow improvement (landmarks repositioning)\n    \n    # Return:\n    # - NumPy array of coordinates of landmarks\n    \n    # Use dlib 68 & 81 to predict landmarks points coordinates\n    detector = dlib.get_frontal_face_detector()\n    global predictor68\n    global predictor81\n    \n    # Grayscale image\n    try:\n        grayscale_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    except:\n        grayscale_image = image\n    \n    # array of rectangles surrounding faces detected\n    rectangles = detector(grayscale_image, 1)\n\n    # If at least one face is detected   \n    if len(rectangles) > 0:\n        # Get 68 landmark points\n        faceLandmarks = predictor68(grayscale_image, rectangles[0])\n        faceLandmarks = face_utils.shape_to_np(faceLandmarks)\n        \n        if eyeOnlyMode:\n            # Return eye points to perform a calculated rotation\n            return np.array([faceLandmarks[39], faceLandmarks[42]])\n        \n        # Get 81 landmark points\n        foreheadLandmarks = predictor81(grayscale_image, rectangles[0])\n        foreheadLandmarks = face_utils.shape_to_np(foreheadLandmarks)\n        \n        # Get 68 point from -68- predictor (higher accuracy) + forehead from -81- predictor\n        fullFacePoints = np.concatenate((faceLandmarks, foreheadLandmarks[68:]))\n        \n        # Get forehead region & height to perform simple improvement\n        x,y,x2,y2 = (fullFacePoints[69,0]-10, fullFacePoints[68,1], fullFacePoints[80,0]+10, fullFacePoints[23, 1])\n        foreheadRegion = grayscale_image[y:y2,x:x2]\n        foreheadHeight = foreheadRegion.shape[0]\n        \n        if allowEnhancement:\n            # Perform progressive quality improvement\n            # Get nose region to get average skin color\n            x,y,x2,y2 = (fullFacePoints[28,0]-5, fullFacePoints[28,1], fullFacePoints[28,0]+5, fullFacePoints[30,1])\n            noseRegion = grayscale_image[y:y2, x:x2]\n            avgSkinColor = np.average(noseRegion[:,:])\n            \n            # Check if forehead is clear -> perform heuristic based enhancement\n            forehead_is_clear = clearForehead(foreheadRegion, avgSkinColor)\n            originalPoints = fullFacePoints[[69,70,71,73,80]]\n            \n            if forehead_is_clear:\n                avgSkinColor = np.average(foreheadRegion)\n                \n                # Modify some points for more accuracy\n                # Point[68] will be center between lower-lip & chin\n                distance = int((fullFacePoints[8,1]-fullFacePoints[57,1]) \/ 2)\n                fullFacePoints[68] = np.array([fullFacePoints[8,0], fullFacePoints[8,1]-distance])\n                \n                # Enhance points locations\n                enhancedPoints = np.array([moveUp(grayscale_image, orgPoint, avgSkinColor, foreheadHeight) for orgPoint in originalPoints])\n\n                # Assign original points to enhanced points (some maybe the same)\n                fullFacePoints[[69,70,71,73,80]] = enhancedPoints  \n                \n                # Adjust points to fix any corruptions\n                fullFacePoints[[69,70,71,73,80]] = adjustPoints(enhancedPoints, fullFacePoints[76], fullFacePoints[79])\n\n                #Prepare point[72] for center of forehead\n                distance = (fullFacePoints[22,0] - fullFacePoints[21,0]) \/ 2\n                distanceY = (fullFacePoints[21,1] - fullFacePoints[71,1]) \/ 2\n                fullFacePoints[72] = np.array([fullFacePoints[21,0] + distance, fullFacePoints[21,1]-distanceY])\n                \n                # Point[74] sometimes have a fixed corruption, this line helps :)\n                fullFacePoints[74,0] -= foreheadHeight * 0.1 # Arbitery heurestic\n                \n            else:\n                # If forehead isn't clear -> fix points with very simple heuristics\n                fullFacePoints[70,1] -= foreheadHeight * 0.2\n                fullFacePoints[71,1] -= foreheadHeight * 0.3\n                fullFacePoints[80,1] -= foreheadHeight * 0.2\n    \n        else:\n            # If Enhancement is False -> do the simple enhancement, better quality + low performance :)\n            fullFacePoints[70,1] -= foreheadHeight * 0.2\n            fullFacePoints[71,1] -= foreheadHeight * 0.3\n            fullFacePoints[80,1] -= foreheadHeight * 0.2\n            pass\n        \n        return fullFacePoints\n    # No faces found\n    else:\n        return None\n\n# Function to adjust landmarks points of the forehead \n# and fix corruptions of improvement (such as the bald man case)\ndef adjustPoints(points, leftSidePoint, rightSidePoint):    \n    # Use shape_predictor_81 as a reference for points indexes to fix:\n    # points = [69,70,71,73,80]\n    # LeftSidePoint = 76  |  rightSidePoint = 79\n    \n    slopes = []\n    slopeThreshold = 0.4 # slope > 0.4 = corruption -> fix\n    totalSlopeThreshold = 1 # sum of slopes > 1 = corruption -> fix\n    leftPoint = points[0]\n    rightPoint = points[3]\n    criticalLeftPoint = points[1]\n    criticalRightPoint = points[4]\n    \n    # if any point is higher than a (accurate located point) -> fix\n    if leftPoint[1] < criticalLeftPoint[1] :\n        points[0,1] = np.average([criticalLeftPoint[1], leftSidePoint[1]])\n    if rightPoint[1] < criticalRightPoint[1]:\n        points[3,1] = np.average([criticalRightPoint[1], rightSidePoint[1]])\n    \n    # Collect some slopes of the usually corrupted points\n    slopes.append(slope(points[1], points[2], True))\n    slopes.append(slope(points[2], points[4], True))\n    \n    # Calculate slope differences & sum\n    difference = abs(np.diff(slopes))\n    _sum = np.sum(slopes)\n    \n    # If calculation results (either) too high = corruption -> fix\n    if difference > slopeThreshold:\n        issueIndex = np.argmax(slopes)\n        if issueIndex == 0:\n            points[1,1] = max(points[4,1], points[2,1])\n        else:\n            points[4,1] = max(points[1,1], points[2,1])\n            \n    if _sum > totalSlopeThreshold:\n        points[1,1] = np.average(points[[4,2], 1])\n        points[4,1] = np.average(points[[1,2], 1])\n        points[2,1] = np.average(points[[4,1], 1])  \n        \n    return points\n\n# Function to extract the whole face\ndef cropFullFace(image, points, padding = True, xProportion = 0.025, yProportion = 0.025):    \n    imageShape = image.shape\n    # Get borders of the 4 directions\n    top = points[:,1].min()\n    bottom = points[:,1].max()\n    left = points[:,0].min()\n    right = points[:,0].max()\n    \n    if padding:\n        # X-factor is a an additional proportion of the image on X-axis, considered in the output \n        # Y-factor is the same for Y-axis \n        xFactor = int((xProportion) * imageShape[1])\n        yFactor = int((yProportion) * imageShape[0])\n        x,y,x2,y2 = (max(left-xFactor, 0), max(top-yFactor, 0) ,min(right+yFactor, imageShape[0]), min(bottom+yFactor, imageShape[0]) )\n    \n    else:\n        x,y,x2,y2 = (left,top ,right, bottom )\n\n    cropped = image[y:y2, x:x2]\n    return cropped\n\n# Function to rotate image to align the face\ndef align_face(image, eyePoints):\n    # Get left eye & right eye coordinates\n    leftEyeX,leftEyeY = eyePoints[0]\n    rightEyeX, rightEyeY = eyePoints[1]\n\n    # Calculate angle of rotation & origin point\n    angle = math.atan( (leftEyeY - rightEyeY) \/ (leftEyeX - rightEyeX) ) * (180\/math.pi)\n    origin_point = tuple(np.array(image.shape[1::-1]) \/ 2)\n\n    # Rotate using rotation matrix\n    rot_mat = cv2.getRotationMatrix2D(origin_point, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result\n    \n\n# Function to collect landmarks points, grouped, as polygons\ndef collectFaceComponents(facial_points):\n    faceShape = np.concatenate((facial_points[0:17],facial_points[[78,74,79,73,80,71,70,69,76,75,77,0]])) \n    leftEye = np.concatenate((facial_points[36:42],np.array([facial_points[36]])))\n    rightEye = np.concatenate((facial_points[42:47],np.array([facial_points[42]])))\n    leftIBrow = facial_points[17:22]\n    rightIBrow = facial_points[22:27]\n    noseLine = facial_points[27:31]\n    noseArc = facial_points[31:36]\n    upperLip = facial_points[[49,50,51,52,53,61,62,63]]\n    lowerLip = facial_points[[55,56,57,58,59,65,66,67]]\n    faceComponents = {\n            \"face_shape\":faceShape,\n            \"left_eye\":leftEye,\n            \"right_eye\":rightEye,\n            \"left_i_brow\":leftIBrow,\n            \"right_i_brow\":rightIBrow,\n            \"nose_line\":noseLine,\n            \"nose_arc\":noseArc,\n            \"upper_lip\":upperLip,\n            \"lower_lip\":lowerLip\n            }\n    return faceComponents\n\n\n\n# Geometrically analyze & measure facial features & return a Series of measurements\ndef measure_features(facial_points):    \n    # Initialize facial features\/components\n    faceComponents = collectFaceComponents(facial_points)\n    face_shape = faceComponents[\"face_shape\"]\n    leftEye, rightEye = faceComponents[\"left_eye\"], faceComponents[\"right_eye\"]\n    left_ibrow, right_ibrow = faceComponents[\"left_i_brow\"], faceComponents[\"right_i_brow\"]\n    nose_line, nose_arc = faceComponents[\"nose_line\"], faceComponents[\"nose_arc\"]\n    upper_lip, lower_lip = faceComponents[\"upper_lip\"], faceComponents[\"lower_lip\"]\n    \n    # Features\n    \n#    forehead height, middle face height, lower face height,\n#    jaw shape, left eye area, right eye area, eye to eye distance,\n#    eye to eyebrow distance, upper lip height, lower lip height,\n#    eyebrows distance, nose length, nose width, nose arc,\n#    eyebrow detector1, eyebrow detector2,\n#    eye slope detector1, eye slope detector2, eyebrow slope\n        \n    # Graphical points, to draw colored lines on each measured component\n    graphical_points = {}\n    \n    # Forehead height (Distance from Top forehead Eyebrow)\n    # Use 3 points & avg them, to reduce any position\/coordinates errors\n    threeMiddleXForeheadPoints = facial_points[[70,71,80]]\n    averageY =  np.average(threeMiddleXForeheadPoints[:,1])\n    \n    # Top edge point of eyebrow\n    middle_right_ibrow = right_ibrow[2,1]\n    forehead_height = middle_right_ibrow - averageY  # << Final result\n    \n    graphical_points['forehead height'] = [ np.average(threeMiddleXForeheadPoints, axis=0).astype(int), np.average([left_ibrow[2], right_ibrow[2]], axis=0).astype(int) ]\n    \n    ##################################################################\n    \n    # Jaw width (as classes, not actual measurements)\n    # Jaw Classes = Face shape = [Square, Round, Oval, Triangle, Heart, Oblong]\n    measurement_1 = sum_slopes(face_shape[[8,9,10,11,12]], True)\n    measurement_2 = sum_slopes(face_shape[[4,5,6,7,8]], True)\n    measurement_3 = abs(sum_difference(face_shape[[8,9,10,11,12]]))\n    measurement_4 = abs(sum_difference(face_shape[[4,5,6,7,8]]))\n    \n    # Find a relation between measurements to maximize margin between different classes\n    jaw_width = (((measurement_1*measurement_3)\/2) * ((abs(measurement_2)*abs(measurement_4))\/2)) \/ 1000\n    \n    # Get angle of chin & jaw\n    jaw_angle = angle_of_3points(face_shape[8],face_shape[5], face_shape[11])\n    \n    # Find a relation between jaw angle & jaw width\n    jaw_class = (jaw_width \/ jaw_angle) * 100 # << Final result\n    \n#    graphical_points['jaw shape'] = [ face_shape[ [4,5,6,7,8,9,10,11,12] ] ]\n    ##################################################################\n\n    # Eyes Areas\n    left_i_area = shape_area(leftEye) # << Final result\n    right_i_area = shape_area(rightEye) # << Final result\n    \n    graphical_points['left eye area'] = leftEye\n    graphical_points['right eye area'] = rightEye\n    \n    ##################################################################\n    \n    # eye to eye distance\n    eye2eye_distance = np.min(rightEye[:,0]) - np.max(leftEye[:,0]) # << Final result\n    \n    graphical_points['eye to eye distance'] = [ leftEye[leftEye.argmin(axis=0)][0], rightEye[rightEye.argmin(axis=0)][0] ]\n    \n    ##################################################################\n    \n    # Eye to Eyebrow distance (left side + right side) \/ 2\n    left_i2ibrow_distance = np.min(leftEye[:,1]) - left_ibrow[2,1]\n    right_i2ibrow_distance = np.min(rightEye[:,1]) - right_ibrow[2,1]\n    eye2eyebrow_distance = (left_i2ibrow_distance + right_i2ibrow_distance) \/ 2 # << Final result\n    \n    graphical_points['eye to eyebrow distance'] = [rightEye[2], right_ibrow[2]]\n    \n    ##################################################################\n    \n    # Lips height\n    upper_lip_height = np.max(upper_lip[:,1]) - np.min(upper_lip[:,1]) # << Final result\n    lower_lip_height = np.max(lower_lip[:,1]) - np.min(lower_lip[:,1]) # << Final result\n    \n    graphical_points['upper lip height'] = [ upper_lip[1], upper_lip[5] ]\n    graphical_points['lower lip height'] = [ lower_lip[1], lower_lip[5] ]\n    ##################################################################\n    \n    # Eyebrows distance (the space between eyebrows) \n    eyebrows_distance = right_ibrow[0,0] - left_ibrow[4,0] # << Final result\n    \n    graphical_points['eyebrows distance'] = [ right_ibrow[0] , left_ibrow[4] ]\n    \n    ##################################################################\n    \n    # Nose length\n    nose_length = np.max(nose_line[:,1]) - np.min(nose_line[:,1]) # << Final result\n    \n    graphical_points['nose length'] = [ nose_line[0], nose_line[3] ]\n    \n    ##################################################################\n    \n    # Nose Width & Arc angle\n    nose_width = nose_arc[4, 0] - nose_arc[0,0] # << Final result\n    nose_arc_angle = angle_of_3points(nose_arc[2], nose_arc[0], nose_arc[4]) # << Final result\n    \n    graphical_points['nose width'] = [ nose_arc[4] , nose_arc[0] ]\n    graphical_points['nose arc'] = [ nose_arc[0], nose_arc[2], nose_arc[4] ]\n    \n    ##################################################################\n    \n    # Middle-face height (from eyebrow edge to nose end)\n    right_ibrow_y = right_ibrow[2,1]\n    middle_face_height = nose_line[3, 1] - right_ibrow_y # << Final result\n    \n    graphical_points['middle face height'] = [ nose_line[3], np.average([left_ibrow[2], right_ibrow[2]], axis=0).astype(int) ]\n    \n    ##################################################################\n    \n    # Lower-face height (from nose tip to chin)\n    face_bottom_y = np.max(face_shape[:,1])\n    lower_face_height = face_bottom_y - nose_arc[2,1] # << Final result\n    \n    graphical_points['lower face height'] = [facial_points[8], nose_arc[2]]\n    \n    ##################################################################\n    \n    # Left \/ Right Eyebrow class: [Straight, Arched, Angled]\n    lefteyeside = leftEye[3]\n    righteyeside = rightEye[0]\n    \n    # Determine to measure left or right eyebrow, based on\n    # distance between nose bottom-point & eyes angle-point \n    noseTip = nose_line[nose_line.shape[0]-1]\n    nose_eye_diff = abs(noseTip[0]-lefteyeside[0]) - abs(noseTip[0]-righteyeside[0])\n    ibrow_position = \"right\" if nose_eye_diff <= 3 else \"left\"\n    clear_ibrow = faceComponents[ibrow_position+\"_i_brow\"]\n    \n    # If the clear eyebrow is left, reverse points order for correct results\n    if ibrow_position == \"left\":\n        clear_ibrow = clear_ibrow[::-1]\n        \n    # AngleX is the difference between straight eyebrows and other types\n    angleX = angle_of_3points(clear_ibrow[2],clear_ibrow[0],clear_ibrow[4]) # << Final result(1)\n \n    # arched_angled_EQ is the value representing difference between curved & angled eyebrows\n    arched_angled_EQ = math.ceil(((equation1(clear_ibrow)) * (equation2(clear_ibrow)) * (equation3(clear_ibrow))) * (equation4(clear_ibrow)) \/ 100) # << Final result(2)\n    \n    \n    graphical_points['eyebrow shape detector 1'] = [clear_ibrow[0], clear_ibrow[2], clear_ibrow[4]]\n    graphical_points['eyebrow shape detector 2'] = right_ibrow if ibrow_position == 'left' else left_ibrow\n    \n    ##################################################################\n    \n    # Eye slope detectors\n\n    # left\/right eye slope\n    lefteyecenter = eyeCenter(leftEye[[1,2,4,5]])\n    righteyecenter = eyeCenter(rightEye[[1,2,4,5]])\n    \n    \n    # Eye sides slopes shape: [Upward, Downward, Straight]\n    lefteyeslope = slope(leftEye[0],lefteyecenter)\n    righteyeslope = slope(righteyecenter,rightEye[3]) \n    \n    \n    # Eye sides difference (Difference on y-axis between eye edge-point & center point)\n    lefteyediff = diff_Yaxis(leftEye[0],lefteyecenter)\n    righteyediff = diff_Yaxis(righteyecenter, rightEye[3])\n        \n    # Left eye slope & diff, right eye slope & diff\n    leftpair = (lefteyeslope*-1,righteyeslope)\n    rightpair = (lefteyediff,righteyediff*-1)\n    totalpair = np.add(leftpair,rightpair)\n    \n    eyeSlopeDetector1 = totalpair[0] # << Final result(1)\n    eyeSlopeDetector2 = totalpair[1] # << Final result(2)\n    \n    graphical_points['eye slope detector1'] = [ leftEye[0], leftEye[3] ]\n    graphical_points['eye slope detector2'] = [ rightEye[0], rightEye[3] ]\n    \n    ##################################################################\n    \n    # Left or Right eyebrow slope (can be classified into: [Downward, Upward, straight])\n    x,y = clear_ibrow[0][0], np.average(clear_ibrow[[0,1],1])\n    ibrow_tip = np.array((x,y))\n    ibrow_slope = slope(ibrow_tip, clear_ibrow[2]) # << Final result\n    \n    graphical_points['eyebrow slope'] = [ ibrow_tip.astype(int), clear_ibrow[2] ]\n    \n    ##################################################################\n    \n    measures = {\n            \"forehead height\" : int(round(forehead_height)),\n            \"middle face height\" : middle_face_height,\n            \"lower face height\" : lower_face_height,\n            \"jaw shape\" : jaw_class,\n            \"left eye area\" : left_i_area,\n            \"right eye area\" : right_i_area,\n            \"eye to eye dist\": eye2eye_distance,\n            \"eye to eyebrow dist\" : eye2eyebrow_distance,\n            \"upper lip height\" : upper_lip_height,\n            \"lower lip height\" : lower_lip_height,\n            \"eyebrows distance\" : eyebrows_distance,\n            \"nose length\" : nose_length,\n            \"nose width\": nose_width,\n            \"nose arc\" : int(round(nose_arc_angle)),\n            \"eyebrow shape detector 1\" : int(round(angleX)),\n            \"eyebrow shape detector 2\" : arched_angled_EQ,\n            \"eye slope detector1\" : eyeSlopeDetector1,\n            \"eye slope detector2\" : eyeSlopeDetector2,\n            \"eyebrow slope\" : ibrow_slope,\n            }\n    \n    # Some detectors represents classes if used after clustering, such:\n    # Eyebrow shape detector 1 & 2 => [Straight, Arched, Angled]\n    # Eye slope detector 1 & 2: [Upward, Downward, Straight]\n    \n    return measures, graphical_points","0817de2b":"# Drawing functions\n\ncolors = {\n        'forehead height': (255,0,255, 1),\n        'middle face height': (205,0,0, 1),\n        'lower face height': (127,255,0, 1),\n        'left eye area': (255,144,30, 1),\n        'right eye area': (170,232,238, 1),\n        'eye to eye distance': (119,115,13, 1),\n        'eye to eyebrow distance': (47,255,173, 1),\n        'upper lip height': (0,0,255, 1),\n        'lower lip height': (173,222,255, 1),\n        'eyebrows distance': (255,248,240, 1),\n        'nose length': (0,140,255, 1),\n        'nose width': (0,255,255, 1),\n        'nose arc': (114,128,250, 1),\n        'eyebrow shape detector 1': (255,191,0, 1),\n        'eyebrow shape detector 2': (147,20,255, 1),\n        'eye slope detector1': (32,96,255, 1),\n        'eye slope detector2': (255,255,0, 1),\n        'eyebrow slope': (160,255,224, 1)\n        }\n\n# Function to draw points on facial features\ndef drawPoints(image, points, pointColor=(255,255,255), lineColor=(255,255,255), pointThickness=None, lineThickness=1):\n    if pointThickness is None:\n        pointThickness = round((7\/1200) * image.shape[1])\n    imgcopy = image.copy()\n    for i in points:\n        x,y = i\n        imgcopy = cv2.circle(imgcopy, (x,y), radius=0, color=pointColor, thickness=pointThickness)\n    return imgcopy\n\n# Draw lines on measured features .. (visualizing purposes)\ndef drawLinesOnFeatures(image, graphical_pts, thickness=None):\n    global colors\n    if thickness is None:\n        thickness = round((5\/1200) * image.shape[1])\n    for feature in graphical_pts:\n        for i in range(len(graphical_pts[feature])-1):\n            pairXY1 = graphical_pts[feature][i]\n            pairXY2 = graphical_pts[feature][i+1]\n            x1, y1 = pairXY1\n            x2, y2 = pairXY2\n            image = cv2.line(image, (x1, y1), (x2, y2), colors[feature], thickness)\n\n    return image","4c4b43e0":"# Function to normalize the landmarks coordinates\ndef normalize_landmarks(points, max_width, max_height):    \n    # Normalize X-axis coordinates between 0-max_width\n    points[:,0] = (points[:,0] - points[:,0].min()) \\\n                  \/ (points[:,0].max() - points[:,0].min()) * max_width\n        \n    # Normalize Y-axis coordinates between 0-max_height\n    points[:,1] = (points[:,1] - points[:,1].min()) \\\n                  \/ (points[:,1].max() - points[:,1].min()) * max_height\n    return points","20b69fa3":"def main():\n    # Capture all images in current folder & their names\n    images, filesnames = load_images_from_folder('..\/input\/facessamples2')\n    \n    # Detect & Visualize a sample\n    for originalImage in [images[1]]:\n        originalImage = cv2.cvtColor(originalImage,cv2.COLOR_BGR2RGB)\n        \n        eyes_landmarks = facial_landmarks(originalImage, eyeOnlyMode=True)\n        if eyes_landmarks is not None:\n            # Align face and redetect landmarks\n            face_aligned = align_face(originalImage, eyes_landmarks)\n            \n            # Detect landmarks\n            improved_landmarks = facial_landmarks(face_aligned, allowEnhancement=True)\n    \n            # Crop face\n            face_cropped = cropFullFace(face_aligned, improved_landmarks)\n            \n\n            # Measure features (NOT scaled)\n            measures, graphical_pts = measure_features(improved_landmarks)\n            \n            \n            # Scale landmarks coordinates\n            # between (0-190, 0-250) Width, Height\n            # these numbers (190,250) are convenient ratios for\n            # width x height of human face .. in pixels\n            scaled_landmarks = normalize_landmarks(\n                improved_landmarks.copy(),\n                190,\n                250\n            )\n            # Measure features (scaled)\n            measures_scaled, graphical_pts_scaled = measure_features(scaled_landmarks)\n            \n            # Draw colored lines on each measured feature\n            image = drawLinesOnFeatures(face_aligned, graphical_pts)\n            \n            \n            #### The following code formats the output plot ###\n            \n            # Convert scaled measure dict to series for faster processing\n            measures_series = pd.concat(\n                (\n                pd.Series(measures_scaled.keys()),\n                pd.Series(measures_scaled.values())\n                ),\n                axis=1)\n            \n            # Convert RGBA colors to HEX\n            colors_hex = pd.Series(colors).map(\n                lambda x: '#{:02x}{:02x}{:02x}'.format(*x)\n            )\n            # Append another column of colors to values (tuples)\n            colors_formatted = colors_hex.map(lambda x: [x, \"#ffffff\"])\n            \n            # Initialize subplots\n            f, axarr = plt.subplots(1,2, figsize=(16,13))\n            \n            # Show face\n            axarr[0].imshow(image)\n            axarr[0].set_axis_off()\n            \n            # Show table\n            axarr[1].set_axis_off()\n            table = axarr[1].table(\n                cellText=measures_series[measures_series[0]!='jaw shape'].values,\n                colLabels=['Feature', 'Measure'],\n                loc='center',\n                rowLoc='left',\n                colWidths=[0.45, 0.15],\n                cellColours=colors_formatted,\n            )\n            table.auto_set_font_size(False)\n            table.scale(2, 2)\n            table.set_fontsize(22)\n            plt.show()","f8b59127":"main()","699cf9d0":"# Facial Features Measurement & Analysis\n\n<h3>Conclusion:<\/h3>\n<h4><b>Measure 19 facial features using basic geometry equations, and produce normalized measurements in pixels<\/b><\/h4>\n\n<h4><b>Note:<\/b><\/h4>\n<p>\n    Some improvements are applied to the landmarks detection, for more information visit <a href=\"https:\/\/www.kaggle.com\/zeyadkhalid\/full-face-81-landmarks-detection-highly-improved\" target=\"_blank\">(this)<\/a> notebook\n<\/p>\n\n<h3>Features Visual Description<\/h3>\n<img src=\"https:\/\/user-images.githubusercontent.com\/50156227\/140836123-92d5e97f-059a-437a-ba63-56d95664f667.png\" height=\"480\">\n\n<h3>Features Textual Description:<\/h3>\n<ol>\n    <li>\n        <b>Forehead Height<\/b>: distance between the top edge of eyebrows and the top edge of forehead.\n    <\/li>\n    <li>\n        <b>Middle Face Height<\/b>: distance between the top edge of eyebrows and nose tip.\n    <\/li>\n    <li>\n        <b>Lower Face Height<\/b>: distance between nose tip and the baseline of chin.\n    <\/li>\n    <li>\n        <b>Jaw Shape<\/b>: A number to differentiate between jaw shapes. this number can be replaced if you use Face Shape Recognition, see <a href=\"https:\/\/www.kaggle.com\/zeyadkhalid\/face-shape-recognition-73-accuracy\" target=\"_blank\">(this)<\/a> notebook.\n    <\/li>\n    <li>\n        <b>Left Eye Area<\/b>\n    <\/li>\n    <li>\n        <b>Right Eye Area<\/b>\n    <\/li>\n    <li>\n        <b>Eye to Eye Distance<\/b>: distance between eyes (closest edges)\n    <\/li>\n    <li>\n        <b>Eye to Eyebrow Distance<\/b>: distance between eye and eyebrow (left or right is determined by whice side of the face is more directed to the -screen-)\n    <\/li>\n    <li>\n        <b>Eyebrows Distance<\/b>: horizontal distance between eyebrows\n    <\/li>\n    <li>\n        <b>Eyebrow Shape Detector 1<\/b>: The angle between 3 points (eyebrow left edge, eyebrow center, eyebrow right edge), to differentiate between (Straight | Non-straight) eyebrow shapes\n    <\/li>\n    <li>\n        <b>Eyebrow Shape Detector 2<\/b>: A number to differentiate between (Curved | Angled) eyebrow shapes.\n    <\/li>\n    <li>\n        <b>Eyebrow Slope<\/b>\n    <\/li>\n    <li>\n        <b>Eye Slope Detector 1<\/b>: A method to calculate the slope of the eye. it's the slope of the line between eye's center point and eye's edge point. this detector is used to represent 3 types of eye slope (Upward, Downward, Straight).\n    <\/li>\n    <li>\n        <b>Eye Slope Detector 2<\/b>: Another method to calculate the slope of the eye. it's the difference on Y-axis between eye's center point and eye's edge point. this detector isn't a 'mathematical' slope, but a number that can be clustered into 3 types of eye slope (Upward, Downward, Straight).\n    <\/li>\n    <li>\n        <b>Nose Length<\/b>\n    <\/li>\n    <li>\n        <b>Nose Width<\/b>: width of the lower part of the nose\n    <\/li>\n    <li>\n        <b>Nose Arch<\/b>: Angle of the curve of the lower edge of the nose (longer nose = larger curve = smaller angle)\n    <\/li>\n    <li>\n        <b>Upper Lip Height<\/b>\n    <\/li>\n    <li>\n        <b>Lower Lip Height<\/b>\n    <\/li>\n<\/ol>\n<h3><b>Inspirational Ideas<\/b><\/h3>\n<ul>\n    <li>Emotion Recognition from facial features<\/li>\n    <li>Face Identification \/ Authentication<\/li>\n    <li>Detect personality traits from facial features<\/li>\n    <li>Gender Classification<\/li>\n    <li>Down Syndrome Detection<\/li>\n    <li>In General: use it as a preprocessing step to study the relation between numeric data instead of images<\/li>\n<\/ul>\n<h3>Any Suggestions?<\/h3>\n<p>What else would be useful to measure? face width? mouth width (for smile detection)? distance between eyes and mouth? let me know your thoughts and I'll try to apply in a notebook update<\/p>"}}