{"cell_type":{"7d748c0b":"code","1ad6d476":"code","1f6d6634":"code","d94dd2af":"code","35fd4aa9":"code","8375191d":"code","ba2d1efb":"code","0eb1498e":"code","1cc3e6a1":"code","14e6994b":"code","19ab5d29":"code","dbbaf564":"code","7608cf1c":"code","5089a0fb":"code","813075a4":"code","7ac2fd09":"code","eaf81a69":"code","be38abd9":"code","bb3fbd69":"code","4b3a95a1":"code","b29b3734":"markdown","e01cb266":"markdown","b2f4dfda":"markdown","42008628":"markdown","4ee5d427":"markdown","7d5af4f0":"markdown","87fe8213":"markdown","12f744d7":"markdown","086a5196":"markdown","584ed936":"markdown","827adbb0":"markdown","da645d63":"markdown","3b3081d6":"markdown","e21a2d80":"markdown","c6b5e7a1":"markdown"},"source":{"7d748c0b":"import torch\nimport numpy as np\nimport pandas as pd\nimport torch.nn.functional as F\nimport torchvision.datasets as data\nimport torchvision.transforms as transforms\nimport random\n\nfrom sklearn import preprocessing","1ad6d476":"! pip uninstall kaggle\n! pip install --upgrade pip\n! pip install kaggle==1.5.6\n\n! ls -lha kaggle.json\n! mkdir -p ~\/.kaggle\n! cp kaggle.json ~\/.kaggle\/\n! chmod 600 ~\/.kaggle\/kaggle.json ","1f6d6634":"! kaggle competitions download -c 2020termproject-18011826\n! unzip 2020termproject-18011826.zip","d94dd2af":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\n\nrandom.seed(666)\ntorch.manual_seed(666)\nif device =='cuda' :\n    torch.cuda.manual_seed_all(666)","35fd4aa9":"learning_rate = 0.0001\ntraining_epochs = 500\nbatch_size = 50\ndrop_prob = 0.3\nScaler = preprocessing.StandardScaler()","8375191d":"train_data=pd.read_csv('train_sweetpotato_price.csv')\ntest_data=pd.read_csv('test_sweetpotato_price.csv')","ba2d1efb":"train_data['year']=train_data['year']%10000\/100 \nx_train_data = train_data.loc[:,[i for i in train_data.keys()[:-1]]]\ny_train_data=train_data[train_data.keys()[-1]]\n\nx_train_data = np.array(x_train_data)\ny_train_data = np.array(y_train_data)\nx_train_data = Scaler.fit_transform(x_train_data)\n\nx_train_data = torch.FloatTensor(x_train_data)\ny_train_data = torch.FloatTensor(y_train_data)","0eb1498e":"train_dataset = torch.utils.data.TensorDataset(x_train_data, y_train_data)","1cc3e6a1":"data_loader = torch.utils.data.DataLoader(dataset=train_dataset,\n                                          batch_size=batch_size,\n                                          shuffle=True,\n                                          drop_last=True)","14e6994b":"linear1 = torch.nn.Linear(5,10,bias = True)\nlinear2 = torch.nn.Linear(10,10, bias= True)\nlinear3 = torch.nn.Linear(10,10, bias= True)\nlinear4 = torch.nn.Linear(10,1, bias= True)\nrelu = torch.nn.ReLU()\n# dropout = torch.nn.Dropout(p=drop_prob)\n","19ab5d29":"torch.nn.init.xavier_normal_(linear1.weight)\ntorch.nn.init.xavier_normal_(linear2.weight)\ntorch.nn.init.xavier_normal_(linear3.weight)\ntorch.nn.init.xavier_normal_(linear4.weight)\n","dbbaf564":"model = torch.nn.Sequential(linear1,relu,\n                            linear2,relu,\n                            linear3,relu,\n                            linear4).to(device)","7608cf1c":"loss = torch.nn.MSELoss().to(device)\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)","5089a0fb":"total_batch = len(data_loader)\n\nfor epoch in range(training_epochs) :\n\n    avg_cost = 0\n\n    for X, Y in data_loader :\n\n        X = X.to(device)\n        Y = Y.to(device)\n\n        optimizer.zero_grad()\n\n        h = model(X)\n\n        cost = loss(h, Y)\n\n        cost.backward()\n        optimizer.step()\n\n        avg_cost += cost \/ total_batch\n    if epoch % 50 == 0 :\n        print('Epoch {}, Cost : {}'.format(epoch,avg_cost))\n\nprint('Learning Finished')","813075a4":"with torch.no_grad():\n    \n  test_data['year']=test_data['year']%10000\/100 \n  x_test_data = test_data.loc[:,[i for i in test_data.keys()[:]]]\n  x_test_data=np.array(x_test_data)\n  x_test_data=Scaler.transform(x_test_data)\n  x_test_data=torch.from_numpy(x_test_data).float().to(device)\n\n  prediction = model(x_test_data)","7ac2fd09":"## tensor => numpy\ncorrect_prediction = prediction.cpu().numpy().reshape(-1,1)","eaf81a69":"correct_prediction","be38abd9":"submit = pd.read_csv('submit_sample.csv')\nsubmit","bb3fbd69":"for i in range(len(correct_prediction)) :\n   submit['Expected'][i] = correct_prediction[i].item()\n\nsubmit","4b3a95a1":"submit.to_csv('submit.csv',index=False)\n! kaggle competitions submit -c 2020termproject-18011826 -f submit.csv -m \"55\"","b29b3734":"## Init","e01cb266":"## Data Download","b2f4dfda":"## Make torch dataset","42008628":"## Model","4ee5d427":"## Layer","7d5af4f0":"## Make data loader","87fe8213":"## \ud559\uc2b5","12f744d7":"## Setting","086a5196":"## Test","584ed936":"## Make Submit form","827adbb0":"## Train Dataset","da645d63":"## Loss, Optimizer","3b3081d6":"## Kaggle Setting","e21a2d80":"## Import","c6b5e7a1":"## Submit"}}