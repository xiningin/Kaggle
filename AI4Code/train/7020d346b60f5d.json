{"cell_type":{"4046b543":"code","0f202859":"code","4e0304d1":"code","31c9b4f6":"code","7c857f50":"code","2d6d764c":"code","6f8bd341":"code","8d19de4a":"code","620d7504":"code","17e23c35":"code","4d221a0f":"code","cb55676c":"markdown","2573df28":"markdown","12f290fc":"markdown","ff1b5256":"markdown","28672bbe":"markdown","f0a83822":"markdown","2ee0ec95":"markdown","d10b1d73":"markdown","fdce1b00":"markdown"},"source":{"4046b543":"## Gradient Descent from scratch\n\n#Importing the dataset\nimport pandas as pd\nimport seaborn as sns\n\nhousing = pd.read_csv('..\/input\/Housing (2).csv')\nhousing.head()","0f202859":"# Converting Yes to 1 and No to 0\nhousing['mainroad'] = housing['mainroad'].map({'yes': 1, 'no': 0})\nhousing['guestroom'] = housing['guestroom'].map({'yes': 1, 'no': 0})\nhousing['basement'] = housing['basement'].map({'yes': 1, 'no': 0})\nhousing['hotwaterheating'] = housing['hotwaterheating'].map({'yes': 1, 'no': 0})\nhousing['airconditioning'] = housing['airconditioning'].map({'yes': 1, 'no': 0})\nhousing['prefarea'] = housing['prefarea'].map({'yes': 1, 'no': 0})","4e0304d1":"#Converting furnishingstatus column to binary column using get_dummies\nstatus = pd.get_dummies(housing['furnishingstatus'],drop_first=True)\nhousing = pd.concat([housing,status],axis=1)\nhousing.drop(['furnishingstatus'],axis=1,inplace=True)","31c9b4f6":"housing.info()","7c857f50":"# Normalizisng the data\nhousing = (housing - housing.mean())\/housing.std()\nhousing.head()","2d6d764c":"# Simple linear regression\n# Assign feature variable X\nX = housing['area']\n\n# Assign response variable to y\ny = housing['price']","6f8bd341":"# Visualise the relationship between the features and the response using scatterplots\nsns.pairplot(housing, x_vars='area', y_vars='price',size=7, aspect=0.7, kind='scatter')","8d19de4a":"import numpy as np\nX = np.array(X)\ny = np.array(y)","620d7504":"def before_gradient(X, y, m_current=0, c_current=0, iters=1000, learning_rate=0.01):\n    N = float(len(y))\n    #gd_df = pd.DataFrame( columns = ['m_current', 'c_current','cost'])\n    #for i in range(iters):\n    y_current = (m_current * X) + c_current\n    cost = sum([data**2 for data in (y-y_current)]) \/ N\n\n    return cost\n        \ncost_gradients=before_gradient(X,y)\ncost_gradients","17e23c35":"# Implement gradient descent function\n# Takes in X, y, current m and c (both initialised to 0), num_iterations, learning rate\n# returns gradient at current m and c for each pair of m and c\n\ndef gradient(X, y, m_current=0, c_current=0, iters=500, learning_rate=0.01):\n    N = float(len(y))\n    gd_df = pd.DataFrame( columns = ['m_current', 'c_current','cost'])\n    for i in range(iters):\n        y_current = (m_current * X) + c_current\n        cost = sum([data**2 for data in (y-y_current)]) \/ N\n        m_gradient = -(2\/N) * sum(X * (y - y_current))\n        c_gradient = -(2\/N) * sum(y - y_current)\n        m_current = m_current - (learning_rate * m_gradient)\n        c_current = c_current - (learning_rate * c_gradient)\n        gd_df.loc[i] = [m_current,c_current,cost]\n    return(gd_df)","4d221a0f":"# print gradients at multiple (m, c) pairs\n# notice that gradient decreased gradually towards 0\n# we have used 1000 iterations, can use more if needed\ngradients = gradient(X,y)\ngradients","cb55676c":"**One-Hot Encoding Format**","2573df28":"**Model before Gradient Descent**","12f290fc":"**Optimal gradients could be selected for model building.**","ff1b5256":"**We will now optimize this cost with iterations through Gradient Descent.**","28672bbe":"**Normalizing Data**","f0a83822":"**Please comment for suggestion or queries. Thanks!**","2ee0ec95":"**Dummy Variable Creation**","d10b1d73":"**For linear regression we use a cost function known as the mean squared error or MSE.**\n\nNow to apply gradient descent from scratch we need our X and y variables as numpy arrays, Let's convert them.","fdce1b00":"**This Python Jupyter-Notebook demonstrates the implementation of Gradient Descent from scratch applied on Housing dataset.**\n\n**Two Functions (before_gradient and gradient) have been coded to show the cost differences. Optimization have been applied on Univariate data (Area and Price) taken from the data itself.**"}}