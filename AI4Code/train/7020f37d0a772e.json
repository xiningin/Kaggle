{"cell_type":{"b81ace3c":"code","a282460d":"code","144c79ff":"code","266ca0db":"code","bd1a82b9":"code","09790d52":"code","e2cfdc69":"code","19a954b1":"markdown","f7350d2e":"markdown","8d52df55":"markdown","aa284795":"markdown","eef3fbc0":"markdown","9e9cc141":"markdown","210f4d89":"markdown","e57016ae":"markdown","ec8c1ca4":"markdown","7e82754e":"markdown","2c391840":"markdown","f2bc961f":"markdown"},"source":{"b81ace3c":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n        \nimport matplotlib.pyplot as plt\nimport scipy.optimize as opt\n\ndf = pd.DataFrame([['2014-06-21', 0, 130],\n                   ['2014-07-31', 40, 2313],\n                   ['2014-08-30', 70, 6146],\n                   ['2014-10-04', 105, 13400]], columns = ['dates', 'dateNums', 'downloads'])\n\nplt.plot(df.dateNums, df.downloads)\nplt.scatter(df.dateNums, df.downloads, color='red')\nplt.show()","a282460d":"def func(x, A, B, C, D):\n    x = np.float128(x) # perform calulation in 128bit to prevent overflow\n    return np.float64(A * (x + np.log(1+np.exp(B*(C-x)))\/B) + D)","144c79ff":"import warnings\n\nfrom scipy.optimize import differential_evolution\n\nxData = df.dateNums\nyData = df.downloads\n    \ndef sumOfSquaredError(parameterTuple):\n    warnings.filterwarnings(\"ignore\") # do not print warnings by genetic algorithm\n    return np.sum((yData - func(xData, *parameterTuple)) ** 2)\n\ndef generate_Initial_Parameters():    \n    parameterBounds = []\n    \n    # parameter bounds are selected with trial-and-error\n    parameterBounds.append([0, 100]) # parameter bounds for A\n    parameterBounds.append([0, 10]) # parameter bounds for B\n    parameterBounds.append([0, 10]) # parameter bounds for C\n    parameterBounds.append([-100, 10000]) # parameter bounds for D\n\n    # \"seed\" the numpy random number generator for repeatable results\n    result = differential_evolution(sumOfSquaredError, parameterBounds, seed=3, maxiter=10000)\n    return result.x\n\n# generate initial parameter values\ninitialParameters = generate_Initial_Parameters()\n\n# print initial parameter values\nprint(\"Initial Parameters:\")\nfor name, param in zip(['A','B','C','D'], initialParameters):\n    print(name, \": \", param)","266ca0db":"from scipy.optimize import curve_fit\n# curve fit the test data\nfittedParameters, pcov = curve_fit(func, xData, yData, initialParameters)\n\nprint(\"Fitted Parameters\")\nfor name, param in zip(['A','B','C','D'], fittedParameters):\n    print(name, \": \", param)","bd1a82b9":"df.plot.scatter(1, 2, color='red')\nplt.plot(range(-50, 150), func(range(-50,150), *fittedParameters))\nplt.show()","09790d52":"# find intersection\nintersection = opt.fsolve(lambda x : func(x, *fittedParameters) - 27182, 0)\nprint(\"The model predicts the number will be reached\", float(intersection), \"days after 2014-06-21\")\n\nplt.plot(range(200), func(range(200), *fittedParameters), label='model')\nplt.plot(range(200), [27182]*200, label='27182 downloads')\nplt.scatter([intersection], func(intersection, *fittedParameters), color='red')\nplt.legend()\nplt.show()","e2cfdc69":"import datetime\nstart_date = datetime.datetime.strptime(\"2014-06-21\", \"%Y-%m-%d\")\nend_date = start_date + datetime.timedelta(days=float(intersection))\n\nprint(\"The crossover will occur at\", end_date)","19a954b1":"To translate that to a date we'll use Python's `datetime` module","f7350d2e":"# Model and Motivation <a id=\"Model and Motivation\">\nThere is very little provided data to extrapolate from, so it is going to be important that we choose a model that is motivated by prior knowledge of the system as a whole. Consider the following observations: There is a finite number (at least, in the timeframe of the contest) of people that regularly listen to podcasts and who may be interested in a podcast like Data Skeptic. Furthermore, the more regular listeners there are, the greater the exposure the pocast gets through word of mouth, shares, reviews, etc. It follows, Then, that the number of regular listeners will have a tendency to grow exponentially, but is limited by an upper bound or ***carrying capacity***.\n\nThis description is consistent with the [Logistic Funciton](https:\/\/en.wikipedia.org\/wiki\/Logistic_function), so we'll write the number of regular listeners as a generalized logistic function:\n$$\\text{Listeners} = \\frac{A}{1 + e^{-B(x-C)}}$$\n\nWe will make the assumption that the rate of podcast downloads is proportional to the number of listeners, so if $y$ is the function that describes the number of cumulative downloads over time, we can replace the number of listeners with $y$'s first derivative:\n\n$$y' = \\frac{A}{1 + e^{-B(x-C)}}$$\n\nThis yields a differential equation that can be trivially solved by integrating both sides:\n\n$$y = A \\left(x + \\frac{\\log\\left(1 + e^{B (C - x)}\\right)}{B}\\right) + D$$\n\nThis will be the function we use to fit to our data with parameters $A$, $B$, $C$ and $D$","8d52df55":"# Making the Prediciton  <a id=\"Making the Prediciton\">\nNow that we have a working model, we can predict on what day the number of downloads will pass 27,182","aa284795":"# Table of Contents\n1. [Visualizing the Data](#Visualizing the Data)\n2. [Model and Motivation](#Model and Motivation)\n3. [Fitting Our Model to the Data](#Fitting Our Model to the Data)\n4. [Making the prediciton](#Making the Prediciton)","eef3fbc0":"# Visualizing the Data <a id=\"Visualizing the Data\">","9e9cc141":"The fit looks good!","210f4d89":"## Initial paramters\nWe need a good starting point for the optimizer to fit the model properly. To acheive this, we will adapt the code found [here](https:\/\/bitbucket.org\/zunzuncode\/ramanspectroscopyfit\/src\/master\/RamanSpectroscopyFit.py) which uses the differential evolution module from SciPy to find a good set of initial parameters","e57016ae":"# A Solution to the [October 2014 Data Skeptic Podcast Contest](http:\/\/dataskeptic.com\/blog\/episodes\/2014\/contest)\n\nOn the Oct 7 2014 episode of Data Skeptic, Kyle announced a contest to predict the date on which the cumulative number of downloads of the Data Skeptic Podcast surpases 27,182. The only information given to make the prediciton are the following four data points:\n\n```\n##        dates dateNums downloads\n## 1 2014-06-21        0       130\n## 2 2014-07-31       40      2313\n## 3 2014-08-30       70      6146\n## 4 2014-10-04      105     13400\n```\n\nThis notebook will predict the crossover date.","ec8c1ca4":"The shape of the data seems to suggest exponential growth.","7e82754e":"How close was this prediciton? @DataSkeptic on Twitter [revealed the solution](https:\/\/twitter.com\/DataSkeptic\/status\/544527949651648512) to be Nov 25, 2014, making my prediction only 1 day off.","2c391840":"# Fitting Our Model to the Data <a id=\"Fitting Our Model to the Data\">\nFirst, define $y$ as a python function.","f2bc961f":"## Performing the fit\nWe use SciPy's curve_fit to apply the method of least-squares."}}