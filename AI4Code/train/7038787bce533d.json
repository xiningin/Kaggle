{"cell_type":{"695f4d34":"code","e6de83e4":"code","db57ffb1":"code","1fe1948d":"code","002111b5":"code","06609d5c":"code","dc9a6920":"code","f3e4dc8a":"code","47fa0c44":"code","4702c7ac":"code","53cf6dd2":"code","ef6afd26":"code","b27b48da":"code","9e97e520":"code","a6c1b48b":"code","9b26e122":"code","ee16036c":"code","7ad181d9":"code","70bc8ec6":"code","9a97c0b1":"code","23c41f1d":"code","bc25b238":"code","7e1581d8":"code","3a8e0abc":"code","5602ed06":"code","e5f5d843":"code","70b31e8f":"code","c93445ad":"markdown","a536c442":"markdown","e27f7a13":"markdown"},"source":{"695f4d34":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined bty the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\nfrom __future__ import print_function\n\nimport os\nimport json\nimport re\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport copy\n\nimport time, random, math\nimport re  #regular expression\nimport operator\nfrom collections import defaultdict, Counter, OrderedDict, namedtuple\nimport numbers\n\n\nimport nltk#natural language processing\nimport six\nimport scipy.sparse as sp\nfrom operator import itemgetter\nimport string\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MaxNLocator\n\n%matplotlib inline\nmatplotlib.rc('axes', facecolor = 'white')\n\nimport seaborn as sns\nsns.set(style=\"whitegrid\")\n\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\nfrom sklearn.preprocessing import LabelEncoder\n\nfrom sklearn.ensemble import RandomForestClassifier as RFC, AdaBoostClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC, LinearSVC, NuSVC\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer\n\nfrom matplotlib.colors import ListedColormap\nfrom sklearn.metrics import accuracy_score, log_loss\n\nprint(os.listdir(\"..\/input\"))","e6de83e4":"def timer(func):\n    def wrapper(*args, **kwargs):\n        ts = time.time()\n        results = func(*args, **kwargs)\n        te = time.time()\n        print(\"Time to execute {} = {} seconds\".format(func.__name__, te - ts))\n        return results\n              \n    return wrapper\n\nfrom nltk.stem.porter import PorterStemmer\nfrom nltk import word_tokenize\nfrom nltk.stem import WordNetLemmatizer\n\nnltk_stemmer = PorterStemmer()\nnltk_lemma = WordNetLemmatizer()\n\n\nChartParams = namedtuple('ChartParams', ['title', 'xticks', 'yticks', 'xlabel', 'ylabel', 'colors', 'is_horizontal', 'min_max'])","db57ffb1":"# @TODO, for future refence\n# def currency(x, pos):\n#     \"\"\"The two args are the value and tick position\"\"\"\n#     if x >= 1e6:\n#         s = '${:1.1f}M'.format(x*1e-6)\n#     else:\n#         s = '${:1.0f}K'.format(x*1e-3)\n#     return s\n\ndef formatNum(num):\n    if isinstance(num, numbers.Integral):\n        return num\n    return \"{0:.3f}\".format(num)\n    \ndef barplot(ax, data, chart_params):\n    \"\"\"\n    Plots a horizontal or vertical barplot\n    Parameters\n    -------------\n    ax - the figure axes\n    \"\"\"\n    \n    N = len(data)\n    pos = np.arange(N)\n    height=0.8\n    #formatter = FuncFormatter(currency)\n\n    if chart_params.is_horizontal:\n        if len(chart_params.colors) > 0:\n            rects = ax.barh(pos, data, align='center', height=height, color=chart_params.colors)\n        else:\n            rects = ax.barh(pos, data, align='center', height=height)\n\n        ax.set_title(chart_params.title, size=14)\n        ax.xaxis.grid(True, linestyle='--', which='major',color='grey', alpha=.25)\n        ax.set_yticks(pos)\n        ax.set_yticklabels(chart_params.yticks)\n        ax.set(xlim=[chart_params.min_max[0], chart_params.min_max[1]], xlabel=chart_params.xlabel, ylabel=chart_params.ylabel)\n        \n        for i, rect in enumerate(rects):\n            rect_width = rect.get_width()\n            xloc = rect_width if rect_width < 1 else int(rect_width)*0.98\n            yloc = rect.get_y() + rect.get_height()\/2.0\n            ax.text(xloc, yloc, formatNum(data[i]), horizontalalignment='right', verticalalignment='center', color='white', weight='bold', clip_on=True)\n\n            #ax.xaxis.set_major_formatter(formatter)\n    else:\n        rects = ax.bar(pos, data, width, color=colors)\n        ax.set_xticks(pos)\n        ax.set_xticklabels(chart_params.xticks)\n        for tick in ax.get_xticklabels():\n            tick.set_rotation(90)\n            \n        for i, rect in enumerate(rects):\n            xloc = rect.get_x() + 0.02\n            yloc = rect.get_height()\n            ax.text(xloc, yloc, str(data[i]), weight='bold', color='b')\n            \ndef getMainIngredientsByCuisine(tfm, vectorizer, target):\n    results = {}\n    for cuisine in np.unique(train_df.cuisine):\n        ids = np.where(target == cuisine)[0]\n        data = tfm[ids,:].toarray()\n        tfs = np.array(data.sum(axis=0)).ravel()\n        indices = np.argsort(-tfs)\n        names = []\n        counts = []\n        vocab = list(six.iteritems(vectorizer.vocabulary_))\n        for i, index in enumerate(indices):\n            names.append([tup[0] for tup in vocab if tup[1] == index][0])\n            counts.append(tfs[index])\n        results[cuisine] = zip(names, counts)\n        \n    return results\n\ndef getFrequencyDistribution(words_list, ascending=False):\n    '''\n        Calculate the occurrency of each token in a list\n        Parameters\n        ------------\n        words_list : array\n                    list of tokens occurring more than once\n        ascending  : boolean, default=False\n                    the order in which the results is sorted\n    '''\n    vocab = defaultdict()\n    vocab.default_factory = vocab.__len__\n\n    for tokens in words_list:\n        if len(tokens) == 0:\n            continue\n        for token in tokens:\n            vocab[token] += 1\n        \n    vocab = dict(vocab)\n    terms = np.array(list(vocab.keys()))\n    values = np.array(list(vocab.values()))\n    flag = -1\n    if ascending:\n        flag = 1\n    indices = np.argsort(flag*values)\n    return list(zip(terms[indices], values[indices]))\n\ndef find_indices_of_word_groups(vect, words_list):\n    words_indices = [vect.vocabulary_.get(w) for w in words_list]\n    return words_indices\n   \ndef get_vocab_subset(words_list, tfm, vect):\n    words_indices = find_indices_of_word_groups(vect, words_list)\n    all_indices = np.array([tup[1] for tup in sorted(six.iteritems(vect.vocabulary_))])\n    kept_indices = [indx for indx in all_indices if indx not in words_indices]\n    X1 = tfm[:, kept_indices]\n    print(tfm.shape, X1.shape)\n    return X1\n\ndef fit_and_score(X, target, estimator):\n    X_train, X_test, y_train, y_test = train_test_split(X, target, test_size=0.33, random_state=42)\n    print(\"Training on {} features\".format(X_train.shape))\n    clf = copy.deepcopy(estimator)\n    clf = clf.fit(X_train, y_train)\n    predictions = clf.predict(X_test)\n    predict_proba = clf.predict_proba(X_test)\n    print(accuracy_score(y_test, predictions) * 100)\n    print(log_loss(y_test, predict_proba))\n    return clf\n\ndef append_column_with_TFM(X, data_col):\n    '''\n    Arguments\n    -----------\n    X - term frequency matrix\n    data_col - 1D array to be appended\n    '''\n    if sp.issparse(X):\n        X = X.toarray()\n    return np.concatenate((X, data_col), axis=1)\n\ndef get_word_occurrence_by_cuisine(vect, tfm, target, words_list):\n    '''\n        Given a list of words finds the occurrence in each cuisine\n        Parameters\n        --------------\n        target - the target values (list of cuisines)\n        words_list - list of unique words in the vocabulary from countvectorizer\n    '''\n    words_indices = find_indices_of_word_groups(vect, words_list)\n    unique_targets = np.unique(target)\n    results = []\n    labels = []\n    for i, label in enumerate(unique_targets):\n        cuisine_df = tfm[np.where(target == label)]\n        tfs = cuisine_df.sum(axis=0)\n        results.append([cuisine_df[:, indx].sum() for indx in words_indices])\n        labels.append(label)\n        \n    return pd.DataFrame(results, columns=words_list, index=labels)\n\ndef plot_occurrence_across_cuisines(vect, tfm, word):\n    df = get_word_occurrence_by_cuisine(vect, tfm, target, [word])\n    \n    fig, ax = plt.subplots(figsize=(7, 5))\n    plt.subplots_adjust(bottom=0, left=.01, right=.99, top=.90, wspace=.35, hspace=.35)\n    chart_params = ChartParams('Count of ' + word, '', df[word].index.values, '', '', ['#15CBCB'], True, (0, max(df[word].values)))\n    barplot(ax, df[word].values, chart_params)\n    plt.show()\n    \n_uppercase_pat = re.compile(r'[A-Z]\\w+')\n    \ndef plotMainIngredients(tfm, vect, N):\n    n_row = 5\n    n_col = 4\n    colors = ['#A66AF7', '#3290F5', '#EE1F12', \"#8156A4\"]\n    ingredientsByCounts = getMainIngredientsByCuisine(tfm, vect, target)\n\n    fig, axarr = plt.subplots(n_row, n_col, figsize=(5 * n_col, 10 * n_row), squeeze=False)\n    #plt.subplots_adjust(bottom=0, left=.01, right=.99, top=.90, wspace=.35, hspace=.35)\n\n    for i in range(n_row):\n        groups = list(train_df.groupby('cuisine').groups)[i * n_col:(i * n_col) + n_col]\n        for indx, item in enumerate(groups):\n            d = list(ingredientsByCounts[item])[:N]\n            values = [item[1] for item in d]\n            chart_params = ChartParams(item + ' (n=1)', '', [item[0] for item in d], '', '', colors[indx], True)\n            barplot(axarr[i][indx], [item[1] for item in d], chart_params)\n\n    plt.show()\n \ndef get_uniq_ingredients(vect):\n    labels = []\n    values = []\n    for cuisine in np.unique(target):\n        ids = np.where(target == cuisine)[0]\n        d = tfm[ids]\n        sum_words = np.array(d.sum(axis=0)).ravel()\n        word_freq = [(word, sum_words[indx]) for word, indx in vect.vocabulary_.items()]\n        word_freq = [tup for tup in word_freq if tup[1] > 0]\n        labels.append(cuisine)\n        values.append(len(word_freq))\n        \n    return labels, values\n\ndef get_variations_in_ingredients(ingredients_txt, word_list):\n    labels = []\n    matches = []\n    for word in word_list:\n        regex = re.compile(r\"\\b[a-z][a-z]+\\s+\" + word + r\"\\s*[a-z]*\\b\")\n        matches.append(list(set(regex.findall(ingredients_txt))))\n        labels.append(word)\n    \n    indices = np.where(np.array(list(map(len, matches))))[0]\n    return np.array(labels).take(indices), np.array(matches).take(indices)\n\ndef sortListByFreq(vect, tfm, word_list, ascending=False):\n    matrix_indices = [vect.vocabulary_.get(word) for word in word_list]\n    matrix_indices = [num for num in matrix_indices if num is not None]\n    sum_words = np.array(tfm[:, matrix_indices].sum(axis=0)).ravel()\n    sign = -1\n    if ascending:\n        sign = 1\n    sort_indices = np.argsort(sign * sum_words)\n    values = np.array(sum_words)[np.argsort(-sum_words)]\n    names = np.array(word_list)[np.argsort(-sum_words)]\n    return list(zip(names, values))\n\ndef plotFrequency(ax, data, N, chartTitle):\n    '''\n    Plot frequency of tokens\n    Parameters\n    --------------\n    data - array of tokens\n    chartParams - parameters of chart,(e.g. xlabels, ylabels)\n    figsize - width and height of chart figure\n    N - total number of records to show in plot\n    '''\n    vocab = getFrequencyDistribution(data)\n    labels = [item[0] for item in vocab][:N]\n    counts = [item[1] for item in vocab][:N]\n    chart_params = ChartParams(chartTitle, '', labels, '', '', [CHART_COLOR], True, (0, max(counts)))\n    barplot(ax, counts, chart_params)","1fe1948d":"with open(\"..\/input\/train.json\", 'r') as file:\n    data_train = json.load(file)\n    \nwith open(\"..\/input\/test.json\", 'r') as file:\n    data_test = json.load(file)\n    \nCHART_COLOR = '#B9D132'","002111b5":"train_df = pd.DataFrame(data_train)\ntest_df = pd.DataFrame(data_test)\n\nclf = LogisticRegression(multi_class='warn', random_state=42)","06609d5c":"train_df['concat_ingredients'] = train_df['ingredients'].apply(lambda row: \",\".join(row))\ntest_df['concat_ingredients'] = test_df['ingredients'].apply(lambda row: \",\".join(row))","dc9a6920":"corpus = train_df['concat_ingredients']\ntarget = train_df['cuisine']","f3e4dc8a":"def clean_text(doc):\n    doc = re.sub(r'\\bmi\\b', '', doc)\n    doc = re.sub(r'\\bfresh\\b', '', doc)\n    return doc","47fa0c44":"vect = CountVectorizer(preprocessor=clean_text, tokenizer=lambda doc: [word.strip() for word in doc.split(',')])\ntfm = vect.fit_transform(corpus)","4702c7ac":"labels, values = get_uniq_ingredients(vect)\nfig, ax = plt.subplots(figsize=(10, 8))\nchart_params = ChartParams('#Unique ingredients', '', np.array(labels)[np.argsort(values)], '', '', ['#B9D132'], True, (0, max(values)))\nbarplot(ax, np.array(values)[np.argsort(values)], chart_params)\nplt.show()","53cf6dd2":"train_df['total_ingredients'] = train_df['ingredients'].apply(lambda row: len(row))\ntrain_df['n_words'] = train_df['ingredients'].apply(lambda row: sum([len(w.split()) for w in row]))\ntrain_df['n_uppercase_words'] = train_df['ingredients'].apply(lambda row: sum([1 if w[0].isupper() else 0 for w in row]))\ntrain_df['n_digits'] = train_df['ingredients'].apply(lambda row: sum([1 if w[0].isdigit() else 0 for w in row]))\n","ef6afd26":"train_df['hyphen_ingredients'] = train_df['concat_ingredients'].apply(lambda row: re.compile(r'\\b[a-z][a-z]+[-][a-z]+\\b').findall(row))\ntrain_df['negations'] = train_df['concat_ingredients'].apply(lambda row: re.compile(r'\\b(non[\\s-][a-z\\s]+|no[\\s-][a-z\\s]+|not[\\s-][a-z\\s]+)\\b').findall(row))\ntrain_df['quoted_ingredients'] = train_df['concat_ingredients'].apply(lambda row: re.compile(r'\\b([\\w]+\\'[\\w]+)\\b').findall(row))\n","b27b48da":"train_df['punctuations'] = train_df['ingredients'].apply(lambda row: list(set(np.hstack([re.compile(r'\\W').findall(w) for w in row]))))\n","9e97e520":"nrows = 4\nncols = 1\nfig, axarr = plt.subplots(nrows, ncols, figsize=(5, 8), squeeze=False)\nplt.subplots_adjust(bottom=0, left=.001, right=.99, top=.90, wspace=.35, hspace=.35)\n\nplotFrequency(axarr[0][0], train_df['hyphen_ingredients'].values, 5, '# Hyphenized ingredients')\nplotFrequency(axarr[1][0], train_df['negations'].values, 5, '# Negation ingredients')\nplotFrequency(axarr[2][0], train_df['quoted_ingredients'].values, 5, '# Quoted ingredients')\nplotFrequency(axarr[3][0], train_df['punctuations'].values, 5, '# Punctuations')\n\nplt.show()","a6c1b48b":"# plot_occurrence_across_cuisines(vect, tfm, 'gluten free barbecue sauce')","9b26e122":"def preprocess(doc):\n    doc = re.sub(r\"\\s+\",\" \", doc, flags = re.I)  # remove spaces\n    doc = re.sub(r'\\W', ' ', doc, flags = re.I)  # remove non-words\n    return doc\n\ndef preprocess_ngrams(doc):\n    doc = re.sub(r\"\\s+\",\" \", doc, flags = re.I)  # remove spaces\n    return doc","ee16036c":"class CustomVectorizer(CountVectorizer):\n    def build_tokenizer(self):\n        return lambda doc: doc.split(\",\")\n    \ndef tokenizer(doc):\n    ingredients = doc.split(\",\")\n    results = []\n    results_extend = results.extend\n    for ingredient in ingredients:\n        words = ingredient.split()\n        for word in words:\n            if word[0].isdigit():\n                continue\n            if len(word) == 1:\n                continue\n            results_extend([word.lower()])\n    return results\n\nspace_join = \" \".join\n\ndef tokenizer_ngrams(doc):\n    tokens = list(ingredient.strip() for ingredient in doc.split(\",\"))\n    results = []\n    results_extend = results.extend\n    for token in tokens:\n        token = re.sub(r'\\W', ' ', token, flags = re.I)\n        w_splits = token.split()\n        results_extend(w_splits)\n        \n        if len(w_splits) in [1, 2]:\n            results_extend([token])\n            \n        if len(w_splits) in [3]:\n            results_extend([space_join(w_splits[1:])])\n            \n        if len(w_splits) in [4]:\n            results_extend([space_join(w_splits[1:3])])\n            \n        if len(w_splits) in [5, 6]:\n            results_extend([token])\n            \n    return results\n\ndef tokenizer_all(doc):\n    tokens = list(ingredient.strip() for ingredient in doc.split(\",\"))\n    unigrams = []\n    for word in tokens:\n        if len(word.split()) >= 1:\n            unigrams.append(word.split()[-1])\n        else:\n            unigrams.append(word)\n    \n    results = []\n    results_extend = results.extend\n    for i, item in enumerate(unigrams):\n        if i == len(unigrams) - 1:\n            continue\n        results_extend([space_join([unigrams[i], unigrams[i + 1]])])\n    return results","7ad181d9":"vectorizer = CountVectorizer(preprocessor=preprocess, tokenizer=tokenizer, lowercase=False, stop_words=set(['brown', 'fresh', 'purple']))\nX = vectorizer.fit_transform(corpus)\n\nvectorizer_ngrams = CountVectorizer(preprocessor=preprocess_ngrams, tokenizer=tokenizer_ngrams, min_df=2, stop_words='english')\nX_ngrams = vectorizer_ngrams.fit_transform(corpus)","70bc8ec6":"# vectorizer_comb = CountVectorizer(tokenizer=tokenizer_all)\n# X_comb = vectorizer_comb.fit_transform(corpus)\n\n#cooking,condensed, converted, cokked, cooking, ","9a97c0b1":"print(train_df.loc[np.random.choice(train_df.index), 'ingredients'])","23c41f1d":"train_df['no-oils'] = train_df.apply(lambda row: 1 if len([w for w in row['ingredients'] if len(re.split(r'\\boil\\b', w)) == 1]) == row['total_ingredients'] else 0, axis=1)\n\n","bc25b238":"# print(vectorizer.get_feature_names())","7e1581d8":"lr_unigrams = fit_and_score(X, target, clf)\n\n# 78.29498704860582\n# 0.7706321294271727","3a8e0abc":"lr_ngrams = fit_and_score(X_ngrams, target, clf)\n\n# 78.58448880085326\n# 0.7635537827858768","5602ed06":"lr_all = fit_and_score(append_column_with_TFM(X_ngrams, train_df[['no-oils']].values), target, clf)\n\n# 78.37117172024989\n# 0.7713099458169165","e5f5d843":"test_df['total_ingredients'] = test_df['ingredients'].apply(lambda row: len(row))\ntest_df['no-oils'] = test_df.apply(lambda row: 1 if len([w for w in row['ingredients'] if len(re.split(r'\\boil\\b', w)) == 1]) == row['total_ingredients'] else 0, axis=1)\n","70b31e8f":"feature_vectors = vectorizer_ngrams.transform(test_df['concat_ingredients'])\nsubmission = pd.DataFrame({\"cuisine\": lr_all.predict(append_column_with_TFM(feature_vectors, test_df[['no-oils']].values)), \"id\": test_df['id']})\nsubmission.to_csv('submission1.csv', index=False)","c93445ad":">### Treat each ingredient as a token and build the vocabulary ###","a536c442":">### Fit Model on term-frequency matrix ###","e27f7a13":"### Test ###"}}