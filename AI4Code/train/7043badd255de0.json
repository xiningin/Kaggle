{"cell_type":{"eb169838":"code","90e0236e":"code","f143cbd2":"code","f738ee32":"code","dcdaa14a":"code","8a36a695":"code","6454cb03":"code","e8ae6fba":"code","85c0a9a9":"code","4f578613":"code","2a7b7fab":"code","40ada34f":"code","6c75df2d":"code","ad8bd519":"code","2435eb31":"code","165ff9ea":"code","26935c76":"code","7a35a876":"code","29f9f760":"code","136681cf":"code","7c07e339":"code","a85b4fe7":"code","ada44d2a":"code","3577a317":"code","c69eece0":"code","cdeabd10":"code","08934892":"code","dd3dea6f":"code","b1ba94b9":"code","3dcdf773":"markdown","cc2dacaa":"markdown","90804f5f":"markdown","1e27678d":"markdown","fb4e30d7":"markdown","bcfb8e29":"markdown","ba5dfa2c":"markdown","240d3b69":"markdown","76ee2b34":"markdown","fe817d2f":"markdown","043b36f9":"markdown","b8cdb20e":"markdown","c17064ed":"markdown","a05d50db":"markdown","d921fe89":"markdown","c50c453b":"markdown","c8e9021d":"markdown","7871f64a":"markdown","e107c9df":"markdown","e21205de":"markdown"},"source":{"eb169838":"%matplotlib inline","90e0236e":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport gc\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","f143cbd2":"rankings = pd.read_csv('..\/input\/fifa-international-soccer-mens-ranking-1993now\/fifa_ranking.csv')\nrankings = rankings.loc[:,['rank', 'country_full', 'country_abrv', 'cur_year_avg_weighted', 'rank_date', \n                           'two_year_ago_weighted', 'three_year_ago_weighted']]\nrankings = rankings.replace({\"IR Iran\": \"Iran\"})\nrankings['weighted_points'] =  rankings['cur_year_avg_weighted'] + rankings['two_year_ago_weighted'] + rankings['three_year_ago_weighted']\nrankings['rank_date'] = pd.to_datetime(rankings['rank_date'])\n\nmatches = pd.read_csv('..\/input\/international-football-results-from-1872-to-2017\/results.csv')\nmatches =  matches.replace({'Germany DR': 'Germany', 'China': 'China PR'})\nmatches['date'] = pd.to_datetime(matches['date'])\n\nworld_cup = pd.read_csv('..\/input\/world-cup-2018\/World Cup 2018 Dataset.csv')\nworld_cup = world_cup.loc[:, ['Team', 'Group', 'First match \\nagainst', 'Second match\\n against', 'Third match\\n against']]\nworld_cup = world_cup.dropna(how='all')\nworld_cup = world_cup.replace({\"IRAN\": \"Iran\", \n                               \"Costarica\": \"Costa Rica\", \n                               \"Porugal\": \"Portugal\", \n                               \"Columbia\": \"Colombia\", \n                               \"Korea\" : \"Korea Republic\"})","f738ee32":"rankings.head()","dcdaa14a":"matches.head()","8a36a695":"world_cup.head()","6454cb03":"matches['tournament'].unique()","e8ae6fba":"matches = matches[matches['tournament'] != 'Friendly']\nmatches.shape","85c0a9a9":"import datetime\n\nrankings['year'] = rankings['rank_date'].dt.year\nmatches['year'] = matches['date'].dt.year\n\nrankings_sub = rankings[rankings['rank_date'] > '2011-08-24']\nmatches_sub = matches[matches['date'] > '2011-08-24']","4f578613":"rankings_sub = rankings_sub[['rank', 'country_full', 'weighted_points', 'year']]\nrankings_sub = rankings_sub.groupby(['year', 'country_full'], as_index=False).agg({'rank': 'mean', 'weighted_points': 'mean'})\n\nmatches_sub.head()","2a7b7fab":"matches_all = matches_sub.merge(rankings_sub, left_on=['home_team', 'year'], right_on=['country_full', 'year'], how='inner')\nmatches_all = matches_all.merge(rankings_sub, left_on=['away_team', 'year'], right_on=['country_full', 'year'], how='inner')\nmatches_all.drop(['date', 'tournament', 'city', 'country', 'year', 'country_full_x', 'country_full_y'], axis=1, inplace=True)\nmatches_all.head()","40ada34f":"matches_all['weighted_diff'] = matches_all['weighted_points_x'] - matches_all['weighted_points_y']\nmatches_all['rank_diff'] = matches_all['rank_x'] - matches_all['rank_y']\nmatches_all['neutral'] = matches_all['neutral'].astype(int)\nmatches_all['is_win'] = (matches_all['home_score'] - matches_all['away_score']).apply(lambda x: 1 if x>0 else 0)\ntrain = matches_all.drop(['home_team', 'away_team', 'home_score', 'away_score'], axis=1)\ntrain.head()","6c75df2d":"train_X = train.drop('is_win', axis=1)\ntrain_y = train['is_win']","ad8bd519":"from sklearn.ensemble import RandomForestClassifier\nfrom lightgbm import LGBMClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom itertools import combinations\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_curve, roc_auc_score\nimport matplotlib.pyplot as plt","2435eb31":"classifiers = {'Random Forest': RandomForestClassifier(n_estimators=300),\n              'LightGBM': LGBMClassifier(n_estimators=300, learning_rate=.01),\n              'Logistic Regression': LogisticRegression(C=1e-5)}","165ff9ea":"X_train, X_test, y_train, y_test = train_test_split(train_X, train_y, test_size=0.3)\n\nfig = plt.figure(figsize=[12, 4])\nfor i, (name, clf) in enumerate(classifiers.items()):\n    print('Running', name)\n    clf = clf.fit(X_train, y_train)\n    y_pred = clf.predict_proba(X_test)[:, 1]\n    fpr, tpr, _ = roc_curve(y_test, y_pred)\n    # plot\n    ax = fig.add_subplot(1, 3, i+1)\n    ax.plot([0, 1], [0, 1], 'k--')\n    ax.plot(fpr, tpr)\n    ax.set_title('roc score {0:.2f}'.format(roc_auc_score(y_test, y_pred)))","26935c76":"pd.DataFrame({'y_pred': y_pred, 'y_true': y_test}).boxplot(by='y_true')","7a35a876":"rf = RandomForestClassifier(n_estimators=300)\nrf = rf.fit(train_X, train_y)\n\nlr = LogisticRegression(C=1e-5)\nlr = lr.fit(train_X, train_y)\n\nlgb = LGBMClassifier(n_estimators=300, learning_rate=.01)\nlgb = lgb.fit(train_X, train_y)","29f9f760":"world_cup_rankings = world_cup[['Team', 'Group']]\nworld_cup_rankings = world_cup_rankings.merge(rankings_sub[rankings_sub['year']==2018], left_on='Team', right_on='country_full')\nworld_cup_rankings.drop('country_full', axis=1, inplace=True)\nworld_cup_rankings = world_cup_rankings.set_index('Team')\nworld_cup_rankings.head()","136681cf":"world_cup_rankings['Points'] = 0\nfor group in world_cup_rankings['Group'].unique():\n    print('*******************************')\n    print('Simulating Group', group)\n    group_teams = list(world_cup_rankings.query('Group==\"{}\"'.format(group)).index)\n    for home, away in combinations(group_teams, 2):\n        print('########################')\n        print('{} vs {}'.format(home, away))\n        row = pd.DataFrame(columns=train_X.columns)\n        row.loc[0, 'neutral'] = 1\n        row['weighted_points_x'] = world_cup_rankings.loc[home, 'weighted_points']\n        row['rank_x'] = world_cup_rankings.loc[home, 'rank']\n        row['weighted_points_y'] = world_cup_rankings.loc[away, 'weighted_points']\n        row['rank_y'] = world_cup_rankings.loc[away, 'rank']\n        row['weighted_diff'] = row['weighted_points_x'] - row['weighted_points_y']\n        row['rank_diff'] = row['rank_x'] - row['rank_y']\n        # get wining probability\n        y_pred = np.mean([lr.predict_proba(row)[:, 1][0], lgb.predict_proba(row.values)[:, 1][0], rf.predict_proba(row)[:, 1][0]])\n        # if y_pred in [0.4, 0.55] then draw\n        if (y_pred > 0.4) & (y_pred < 0.55):\n            print('Draw')\n            world_cup_rankings.loc[home, 'Points'] += 1\n            world_cup_rankings.loc[away, 'Points'] += 1\n        else:\n            # give a sense of randomness\n            is_win = np.random.choice([1, 0], p=[y_pred, 1-y_pred])\n            if is_win:\n                world_cup_rankings.loc[home, 'Points'] += 3\n                print('{} wins!'.format(home))\n            else:\n                world_cup_rankings.loc[away, 'Points'] += 3\n                print('{} wins!'.format(away))","7c07e339":"world_cup_rankings","a85b4fe7":"final_teams = world_cup_rankings.sort_values(by=['Group', 'Points'], ascending=False).reset_index()\nfinal_teams = final_teams.groupby('Group').apply(lambda x: x.iloc[[0, 1]]).reset_index(drop=True)\nfinal_teams.set_index('Team', inplace=True)\nfinal_teams","ada44d2a":"pairing = [0, 3, 4, 7, 1, 2, 5, 6, 8, 11, 12, 15, 9, 10, 13, 14]","3577a317":"final_teams = final_teams.iloc[pairing]\n\nfinals = ['round_of_16', 'quarterfinal', 'semifinal', 'final']\nfor f in finals:\n    print('######################################')\n    print('Simulation of {}'.format(f))\n    winners = []\n    rds = int(len(final_teams)\/2)\n    for i in range(rds):\n        home = final_teams.index[2*i]\n        away = final_teams.index[2*i+1]\n        print('{} vs {}'.format(home, away))\n        row = pd.DataFrame(columns=train_X.columns)\n        row.loc[0, 'neutral'] = 1\n        row['weighted_points_x'] = final_teams.loc[home, 'weighted_points']\n        row['rank_x'] = final_teams.loc[home, 'rank']\n        row['weighted_points_y'] = final_teams.loc[away, 'weighted_points']\n        row['rank_y'] = final_teams.loc[away, 'rank']\n        row['weighted_diff'] = row['weighted_points_x'] - row['weighted_points_y']\n        row['rank_diff'] = row['rank_x'] - row['rank_y']\n        # get wining probability\n        y_pred = np.mean([lr.predict_proba(row)[:, 1][0], lgb.predict_proba(row.values)[:, 1][0], rf.predict_proba(row)[:, 1][0]])\n       \n         # give a sense of randomness\n        is_win = np.random.choice([1, 0], p=[y_pred, 1-y_pred])\n        if is_win:\n            winners.append(home)\n            print('{} wins!'.format(home))\n        else:\n            winners.append(away)\n            print('{} wins!'.format(away))\n    final_teams = final_teams.loc[winners]\nprint('*******************************')\nprint('The Champion of 2018 World Cup is {}!!!!!!!!!!!!!!!!!!!!!!!'.format(winners[0]))","c69eece0":"def pred_wining(dat, home, away):\n    row = pd.DataFrame(columns=train_X.columns)\n    row.loc[0, 'neutral'] = 1\n    row['weighted_points_x'] = dat.loc[home, 'weighted_points']\n    row['rank_x'] = dat.loc[home, 'rank']\n    row['weighted_points_y'] = dat.loc[away, 'weighted_points']\n    row['rank_y'] = dat.loc[away, 'rank']\n    row['weighted_diff'] = row['weighted_points_x'] - row['weighted_points_y']\n    row['rank_diff'] = row['rank_x'] - row['rank_y']\n    \n    y_pred = np.mean([lr.predict_proba(row)[:, 1][0], lgb.predict_proba(row.values)[:, 1][0], rf.predict_proba(row)[:, 1][0]])\n    return y_pred\n\ndef main():\n    # Group Stage\n    world_cup_rankings['Points'] = 0\n    for group in world_cup_rankings['Group'].unique():\n        group_teams = list(world_cup_rankings.query('Group==\"{}\"'.format(group)).index)\n        for home, away in combinations(group_teams, 2):\n            # get wining probability\n            y_pred = pred_wining(world_cup_rankings, home, away)\n            # if y_pred in [0.4, 0.55] then draw\n            if (y_pred > 0.4) & (y_pred < 0.55):\n                world_cup_rankings.loc[home, 'Points'] += 1\n                world_cup_rankings.loc[away, 'Points'] += 1\n            else:\n                # give a sense of randomness\n                is_win = np.random.choice([1, 0], p=[y_pred, 1-y_pred])\n                if is_win:\n                    world_cup_rankings.loc[home, 'Points'] += 3\n                else:\n                    world_cup_rankings.loc[away, 'Points'] += 3\n    # Eliminating Stage\n    final_teams = world_cup_rankings.sort_values(by=['Group', 'Points'], ascending=False).reset_index()\n    final_teams = final_teams.groupby('Group').apply(lambda x: x.iloc[[0, 1]]).reset_index(drop=True)\n    final_teams.set_index('Team', inplace=True)\n    final_teams = final_teams.iloc[pairing]\n    \n    for f in finals:\n        winners = []\n        rds = int(len(final_teams)\/2)\n        for i in range(rds):\n            home = final_teams.index[2*i]\n            away = final_teams.index[2*i+1]\n            y_pred = pred_wining(world_cup_rankings, home, away)\n            # give a sense of randomness\n            is_win = np.random.choice([1, 0], p=[y_pred, 1-y_pred])\n            if is_win:\n                winners.append(home)\n            else:\n                winners.append(away)\n        final_teams = final_teams.loc[winners]\n    print('The Champion of 2018 World Cup is {}!!!!!!!!!!!!!!!!!!!!!!!'.format(winners[0]))\n    return winners[0]","cdeabd10":"num_simulations = 100\npairing = [0, 3, 4, 7, 1, 2, 5, 6, 8, 11, 12, 15, 9, 10, 13, 14]\nfinals = ['round_of_16', 'quarterfinal', 'semifinal', 'final']","08934892":"if __name__ == '__main__':\n    champions = []\n    for sim in range(num_simulations):\n        print('######## Simulation {} ########'.format(sim+1))\n        champions.append(main())","dd3dea6f":"import gc\ngc.collect()","b1ba94b9":"from collections import Counter\nimport operator\nimport matplotlib\nimport seaborn as sns\n\nsorted_champ = Counter(champions).most_common()\n\nfig, ax = plt.subplots(figsize=[12, 5])\nplt.xticks(rotation=90, size=16)\nax.set_title('World Cup Champion 2018', size=20)\nsns.barplot(x=[t[0] for t in sorted_champ], y=[t[1] for t in sorted_champ], ax=ax)","3dcdf773":"### Modelling\n# 1. Logistic Regression\n# 2. Random Forest\n# 3. LightGBM","cc2dacaa":"### Pairing Rules","90804f5f":"### Great Reference From:\n# https:\/\/www.kaggle.com\/agostontorok\/soccer-world-cup-2018-winner\/notebook","1e27678d":"### Group Stage Simulation\n# Strong team not always wins, higher probability only gives better wining chance.","fb4e30d7":"### Do prediction by averaging 3 models","bcfb8e29":"### Simulation Compiling\n# So one simulation may have some kind of accident, compile the whole simulation process to perform multiple simulations","ba5dfa2c":"### For rankings and matches(rankings points only starts after 2011-08-24), use data after year 2011-08-24","240d3b69":"### Running simulations","76ee2b34":"### View the points after group stage","fe817d2f":"### Delele friendship tournament","043b36f9":"# World Cup Prediction  \n# Predict the winner of world cup 2018 by simulation\n# The original idea coms from the reference below. I just got the interest to try it myself and made some modifications on:\n#     1. Added some randomness of each match outcome\n#     2. Tried use simulations to get a distribution of wining teams.\n#     3. Applied 3 models to predict the wining probability instead of one.\n#     4. Some other changes while training and modeling.\n\nThanks https:\/\/www.kaggle.com\/vbmokin for his work.","b8cdb20e":"### The main training set is matches, and let's check what kind of tournaments we have(test set is world cup this year)","c17064ed":"Here I limited the number of simulations to 100 while I ran 1000 on my own PC.(Here is extremely slow don't know why)","a05d50db":"### Steps:\n#     1. Drop redundunt columns and group average points by year\n#     2. Merge matches and rankings by year","d921fe89":"### Distribution of Wining","c50c453b":"### Get(Home - Away):\n# 1. weighted difference\n# 2. rank difference\n# 3. one-hot-encode neutral\n# 4. target","c8e9021d":"#### Not Bad\n# Check how higher probability relate to wining","7871f64a":"### Merge Data","e107c9df":"### Simulation","e21205de":"### Single Elimination Rounds Simulation"}}