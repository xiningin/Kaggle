{"cell_type":{"e0ee7d16":"code","b9d6540e":"code","792143b4":"code","f9584c7e":"code","31f56da6":"code","168688d8":"code","55290d1e":"code","cb2a83fc":"code","acb021a1":"code","23a3177a":"code","c2f12a27":"markdown","8cbb5508":"markdown","fb5ac9fd":"markdown","19b9fe0f":"markdown","400d17f7":"markdown","ca374461":"markdown","f51fe86b":"markdown","2784c95c":"markdown","090aef6a":"markdown","d29427ab":"markdown"},"source":{"e0ee7d16":"import random\nimport numpy\nimport pandas as pd\nfrom deap import algorithms\nfrom deap import base\nfrom deap import creator\nfrom deap import tools\nimport multiprocessing\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nimport argparse\n#from scoop import futures\nimport hashlib\nimport os\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","b9d6540e":"# Probem COnstants\nN_DAYS        = 100\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\nFAMINY_SIZE   = 5000\nDAYS          = list(range(N_DAYS,0,-1))\n\n\n#load dataset\ndata        = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/family_data.csv', index_col='family_id')\nsubmission  = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/sample_submission.csv', index_col='family_id')\n\n\n# Load util variables\nfamily_size_dict  = data[['n_people']].to_dict()['n_people']\ncols              = [f'choice_{i}' for i in range(10)]\nchoice_dict       = data[cols].T.to_dict()\n\n# from 100 to 1\nfamily_size_ls  = list(family_size_dict.values())\nchoice_dict_num = [{vv:i for i, vv in enumerate(di.values())} for di in choice_dict.values()]\n\n# Computer penalities in a list\npenalties_dict = {\n  n: [\n      0,\n      50,\n      50  + 9 * n,\n      100 + 9 * n,\n      200 + 9 * n,\n      200 + 18 * n,\n      300 + 18 * n,\n      300 + 36 * n,\n      400 + 36 * n,\n      500 + 36 * n + 199 * n,\n      500 + 36 * n + 398 * n\n  ]\n  for n in range(max(family_size_dict.values())+1)\n} ","792143b4":"# Create a Tollbox Optmizer\n\n# The creator is a class factory that can build new classes at run-time. It will be called with first the desired name of the new class, \n# second the base class it will inherit, and in addition any subsequent arguments you want to become attributes of your class. \n# This allows us to build new and complex structures of any type of container from lists to n-ary trees.\ncreator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,))\ncreator.create(\"Individual\", list, fitness=creator.FitnessMin)\n\n# Now we will use our custom classes to create types representing our individuals as well as our whole population.\ntoolbox = base.Toolbox()","f9584c7e":"# Attribute generator\ntoolbox.register(\"attr_int\",   random.randint, 1, 100)\n\n# Structure initializers\ntoolbox.register(\"individual\", tools.initRepeat, creator.Individual, toolbox.attr_int, FAMINY_SIZE)\ntoolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n\npop   = toolbox.population(n=1000)\n\nprint(pop[0])\nprint(\"len: \", len(pop))","31f56da6":"# The evaluation function is pretty simple in our example. We just need to count the number of ones in an individual.\ndef cost_function(prediction, family_size_ls, choice_dict, choice_dict_num, penalties_dict):\n    penalty = 0\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = {k:0 for k in DAYS}\n    \n    # Looping over each family; d is the day, n is size of that family, \n    # and choice is their top choices\n    for n, c, c_dict, choice in zip(family_size_ls, prediction, list(choice_dict.values()), choice_dict_num):\n        d = int(c)\n        daily_occupancy[d] += n\n\n        # Calculate the penalty for not getting top preference\n        if d not in choice:\n            penalty += penalties_dict[n][-1]\n        else:\n            penalty += penalties_dict[n][choice[d]]\n\n    # for each date, check total occupancy\n    #  (using soft constraints instead of hard constraints)\n    k = 0\n    for v in daily_occupancy.values():\n        if (v > MAX_OCCUPANCY):\n            k = k + (v - MAX_OCCUPANCY)\n        if (v < MIN_OCCUPANCY):\n            k = k + (MIN_OCCUPANCY - v)\n    #    if k > 0:\n    #        penalty += 100000000 \n    penalty += 100000*k\n\n    # Calculate the accounting cost\n    # The first day (day 100) is treated special\n    accounting_cost = (daily_occupancy[DAYS[0]]-125.0) \/ 400.0 * daily_occupancy[DAYS[0]]**(0.5)\n    # using the max function because the soft constraints might allow occupancy to dip below 125\n    accounting_cost = max(0, accounting_cost)\n    \n    # Loop over the rest of the days, keeping track of previous count\n    yesterday_count = daily_occupancy[DAYS[0]]\n    for day in DAYS[1:]:\n        today_count = daily_occupancy[day]\n        diff = abs(today_count - yesterday_count)\n        accounting_cost += max(0, (daily_occupancy[day]-125.0) \/ 400.0 * daily_occupancy[day]**(0.5 + diff \/ 50.0))\n        yesterday_count = today_count\n\n    penalty += accounting_cost\n\n    return (penalty, )","168688d8":"toolbox.register(\"evaluate\",   cost_function, family_size_ls=family_size_ls, choice_dict=choice_dict, \n                                                 choice_dict_num=choice_dict_num, penalties_dict=penalties_dict)\ntoolbox.register(\"mate\",       tools.cxUniform, indpb=0.5)\ntoolbox.register(\"select\",     tools.selTournament, tournsize=10) \ntoolbox.register(\"mutate\",     tools.mutShuffleIndexes, indpb=0.5)","55290d1e":"ngen      = 100  # Gerations\nnpop      = 1000 # Population\n\nhof   = tools.ParetoFront()\nstats = tools.Statistics(lambda ind: ind.fitness.values)\n\n# Statistics\nstats.register(\"avg\", numpy.mean, axis=0)\nstats.register(\"std\", numpy.std, axis=0)\nstats.register(\"min\", numpy.min, axis=0)\nstats.register(\"max\", numpy.max, axis=0)\n\n\n# Evolution\npop, logbook = algorithms.eaMuPlusLambda(pop, toolbox, mu=npop, lambda_=npop,\n                                          cxpb=0.7,   mutpb=0.3, ngen=ngen, \n                                          stats=stats, halloffame=hof)","cb2a83fc":"# Best Solution\nbest_solution = tools.selBest(pop, 1)[0]\nprint(\"\")\nprint(\"[{}] best_score: {}\".format(logbook[-1]['gen'], logbook[-1]['min'][0]))","acb021a1":"import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# History AVG\nplt.figure(figsize=(10,8))\nfront = np.array([(c['gen'], c['avg'][0]) for c in logbook])\nplt.plot(front[:,0][1:-1], front[:,1][1:-1], \"-bo\", c=\"b\")\nplt.axis(\"tight\")\nplt.show()","23a3177a":"# Export Result\n\nsubmission['assigned_day']=best_solution\nprint(submission.head())\nsubmission.to_csv('submission_{}.csv'.format(logbook[-1]['min'][0]))  ","c2f12a27":"## Conclusion\n\nIt has been shown that the DEAP library can be used to optimize the proposed problem. The optimization speed depends on the parameterization of each step of the genetic algorithm.\n\nI suggest testing the settings presented in the DEAP documentation https:\/\/deap.readthedocs.io\/en\/master\/api\/tools.html","8cbb5508":"### The Genetic Operators\n\nWithin DEAP there are two ways of using operators. We can either simply call a function from the tools module or register it with its arguments in a toolbox, as we have already seen for our initialization methods. The most convenient way, however, is to register them in the toolbox, because this allows us to easily switch between the operators if desired. The toolbox method is also used when working with the algorithms module. See the One Max Problem: Short Version for an example.\n\nRegistering the genetic operators required for the evolution in our One Max problem and their default arguments in the toolbox is done as follows.","fb5ac9fd":"## Run Evolution...","19b9fe0f":"## DEAP - Distributed Evoluationary Algorithms In Python\n\n![](https:\/\/deap.readthedocs.io\/en\/master\/_images\/deap_long.png)\n\nDEAP is a novel evolutionary computation framework for rapid prototyping and testing of ideas. It seeks to make algorithms explicit and data structures transparent. It works in perfect harmony with parallelisation mechanism such as multiprocessing and SCOOP. The following documentation presents the key concepts and many features to build your own evolutions.\n\nhttps:\/\/deap.readthedocs.io\/en\/master\/overview.html\nhttps:\/\/github.com\/deap\/deap\n","400d17f7":"#### Define constants and support methods","ca374461":"## Introduction Genetic Algorithm\n\nBasic Description\nGenetic algorithms are inspired by Darwin's theory about evolution. Solution to a problem solved by genetic algorithms is evolved.\n\nAlgorithm is started with a set of solutions (represented by chromosomes) called population. Solutions from one population are taken and used to form a new population. This is motivated by a hope, that the new population will be better than the old one. Solutions which are selected to form new solutions (offspring) are selected according to their fitness - the more suitable they are the more chances they have to reproduce.\n\n![](https:\/\/tutorials.retopall.com\/wp-content\/uploads\/2019\/03\/GeneticAlgorithm-1-1024x374.png)\n\nOutline of the Basic Genetic Algorithm\n* **[Start]** Generate random population of n chromosomes (suitable solutions for the problem)\n* **[Fitness]** Evaluate the fitness f(x) of each chromosome x in the population\n    * **[New population]** Create a new population by repeating following steps until the new population is complete\n    * **[Selection]** Select two parent chromosomes from a population according to their fitness (the better fitness, the bigger chance to be selected)\n    * **[Crossover]** With a crossover probability cross over the parents to form a new offspring (children). If no crossover was performed, offspring is an exact copy of parents.\n    * **[Mutation]** With a mutation probability mutate new offspring at each locus (position in chromosome).\n    * [Accepting] Place new offspring in a new population\n* **[Replace]** Use new generated population for a further run of algorithm\n* **[Test]** If the end condition is satisfied, stop, and return the best solution in current population\n* **[Loop]** Go to step 2","f51fe86b":"### Creating the Population\n\nThe population is random. Each individual is a vector of size k, where k = total families and each value is the day chosen by family d, where d varies between 0 and 100.","2784c95c":"### Toolbox","090aef6a":"# Genetic Algorithm with DEAP  \n\nThis kernel introduces genetic algorithms and describes a baseline using genetic algorithms through the DEAP optimization library.\n\n* Introduction Genetic Algorithm\n* DEAP Lib\n* Solution\n\n**All parameters used were modified from the original version to maintain competitiveness. The kernel is just a didactic example of how to use lib DEAP.**","d29427ab":"### The Evaluation Function\n\nThe evaluation function is pretty simple in our example. We just need to count the number of ones in an individual.\nThe returned value must be an iterable of a length equal to the number of objectives (weights)."}}