{"cell_type":{"338ba9a9":"code","71fdc724":"code","9c14b0db":"code","6d14aa3f":"code","11893c54":"code","c4ddd619":"code","cd3cb0ff":"code","b22dbbe3":"code","8d3744f4":"code","5f737468":"code","d69dab32":"code","b2cfa1f9":"code","ead5d8ae":"code","6da57b4b":"markdown","fca1aa9c":"markdown","ad6d8d58":"markdown"},"source":{"338ba9a9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","71fdc724":"df = pd.read_csv('..\/input\/tabular-playground-series-sep-2021\/train.csv')\ndf_test = pd.read_csv('..\/input\/tabular-playground-series-sep-2021\/test.csv')\nsubmission = pd.read_csv('..\/input\/tabular-playground-series-sep-2021\/sample_solution.csv')","9c14b0db":"df = df.drop(columns = 'id')\ndf_test = df_test.drop(columns = 'id')","6d14aa3f":"##create folds\nfrom sklearn import model_selection\ndf[\"kfold\"] = -1\n\ndf = df.sample(frac=1).reset_index(drop=True)\n\nkf = model_selection.StratifiedKFold(n_splits=5, shuffle=False, random_state=42)\n\nfor fold, (train_idx, val_idx) in enumerate(kf.split(X=df, y=df.claim.values)):\n    print(len(train_idx), len(val_idx))\n    df.loc[val_idx, 'kfold'] = fold","11893c54":"# from sklearn.model_selection import GridSearchCV\n# import xgboost as xg\n# from sklearn.ensemble import AdaBoostRegressor\n# import xgboost as xg\n# reg4 = xg.XGBClassifier(use_label_encoder=False)\n# param_grid = {'tree_method' : ['gpu_hist'], 'gamma':[0.02,0.03,0.04],  'subsample':[0.6,0.7,0.8,0.9],\n# 'colsample_bytree':[0.6,0.7,0.8], 'max_depth': [2,3,4]}\n# grid_search = GridSearchCV(reg4,param_grid,cv = 5,scoring = 'roc_auc')","c4ddd619":"# temp_X = df.drop(columns = ['kfold','claim'])\n# temp_y = df.claim\n# grid_search.fit(temp_X,temp_y)","cd3cb0ff":"# grid_search.best_estimator_","b22dbbe3":"import joblib\nimport xgboost as xg\nimport pandas as pd\nfrom sklearn import metrics\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn import tree\ndef run(fold):\n    df_train = df[df.kfold != fold].reset_index(drop=True)\n    df_valid = df[df.kfold == fold].reset_index(drop=True)\n    df_train = df_train.drop(columns = 'kfold')\n    df_valid = df_valid.drop(columns = 'kfold')\n    x_train = df_train.drop('claim', axis=1).values\n    y_train = df_train.claim.values\n    x_valid = df_valid.drop('claim', axis=1).values\n    y_valid = df_valid.claim.values\n    clf = xg.XGBClassifier(use_label_encoder=False,\n                      tree_method ='gpu_hist',\n#                       scale_pos_weight=1,\n#                       learning_rate=0.03,  \n#                       colsample_bytree = 0.4,\n#                       subsample = 0.9,\n#                       objective='binary:logistic', \n#                       n_estimators=1000, \n#                       reg_alpha = 0.3,\n#                       max_depth=5, \n#                       gamma=5\n                          )\n    clf.fit(x_train, y_train)\n    y_pred = clf.predict_proba(x_valid)[:,1]\n    roc_auc_score = metrics.roc_auc_score(y_valid,y_pred)\n    print(f\"Fold={fold}, roc_auc_score={roc_auc_score}\")\n    File_name = 'model' + str(fold)\n    joblib.dump(\n    clf,File_name)\nfor i in range(5):\n    run(fold = i)","8d3744f4":"model_0= joblib.load('.\/model0')\nmodel_1 =joblib.load('.\/model1')\nmodel_2= joblib.load('.\/model2')\nmodel_3= joblib.load('.\/model3')\nmodel_4= joblib.load('.\/model4')","5f737468":"df_test","d69dab32":"y_final_2 = model_2.predict_proba(df_test)[:,1]\ny_final_0 = model_0.predict_proba(df_test)[:,1]\ny_final_1 = model_1.predict_proba(df_test)[:,1]\ny_final_3 = model_3.predict_proba(df_test)[:,1]\ny_final_4 = model_4.predict_proba(df_test)[:,1]\n\n\ny_final_avg = (y_final_0+y_final_1+y_final_2+y_final_3+y_final_4)\/5","b2cfa1f9":"submission['claim'] = y_final_avg","ead5d8ae":"submission.to_csv('pred_csv_avg.csv',index = False)","6da57b4b":"## Ensemble","fca1aa9c":"### Train.py","ad6d8d58":"## Creatfolds.py"}}