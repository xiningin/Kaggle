{"cell_type":{"dc32fc78":"code","ebe5cdc9":"code","705f2a58":"code","fa30c369":"code","4b4de7ea":"code","914a60de":"code","bdf6aa86":"code","bbed456e":"code","0fa8c8ad":"code","c98359ab":"code","31b18924":"code","deaade4e":"code","4fd47fcd":"code","fcbc0c2c":"code","21550c81":"code","57cce8d1":"code","688c3951":"code","8a15e455":"code","273c750e":"code","9d020af1":"code","8afb1b8f":"code","0ba30b0d":"code","780c2f03":"code","51ec1a23":"code","125edc2e":"code","8f86a455":"code","9e6c0baf":"code","80311594":"code","fa4a42b9":"code","77510e3d":"code","cf3c075d":"code","ed34f3ab":"code","9982de4f":"code","ff6c6e77":"markdown","cd5003f1":"markdown","7e3b78e5":"markdown","602ef18d":"markdown","40675fbd":"markdown","1c1afdeb":"markdown","47ef246c":"markdown","bd1ffd68":"markdown","526ca408":"markdown","14d6c83a":"markdown","1b01a7d0":"markdown","5e495964":"markdown","7f5e357d":"markdown"},"source":{"dc32fc78":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom datetime import date, datetime\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn import ensemble\nfrom sklearn import datasets\nfrom sklearn.utils import shuffle\nimport os\nprint(os.listdir(\"..\/input\"))","ebe5cdc9":"# Read the csv files into a pandas DataFrame\n# Our goal is to predict the movie revenue without adding additional data to the dataset\ntrain = pd.read_csv(\"..\/input\/tmdb-box-office-prediction\/train.csv\")\ntest = pd.read_csv(\"..\/input\/tmdb-box-office-prediction\/test.csv\")\ntrain.head(2)","705f2a58":"#Good catch & correction found here\n#https:\/\/www.kaggle.com\/jiegeng94\/simple-tmdb-prediction-with-gradient-boosting\n#The year values have only two digits and the years before 1969 are denoted as ones of 2000's. Make it correct. \ndef expand_release_date(df):\n    df.release_date = pd.to_datetime(df.release_date)\n\n    df['year'] = df.release_date.dt.year\n    df['year'] = df.year.apply(lambda x: x-100 if x > 2020 else x)\n    \n    df['month'] = df.release_date.dt.month\n    df['day'] = df.release_date.dt.dayofweek\n    df['quarter'] = df.release_date.dt.quarter\n    \n    return df\n\ntrain = expand_release_date(train)\ntest = expand_release_date(test)","fa30c369":"# Import Cast Table with Counts of Appearances\nfile = \"..\/input\/weighttables\/Cast_Data.csv\"\ncastData = pd.read_csv(file)\ncastData.rename(columns = {\"Num\":\"numtimesDS\"}, inplace = True)\ncastData.sort_values(by='numtimesDS', ascending=False, inplace = True)\n# calculation to create the actor wt\ncastData['actorWt'] = castData['numtimesDS']\/castData['numtimesDS'].max().astype(np.float64)\ncastData.head()","4b4de7ea":"# Import Production Company Table with Counts of Appearances\nfile = \"..\/input\/prodcotable\/ProdCo_Data.csv\"\nprodcoData = pd.read_csv(file)\nprodcoData.rename(columns = {\"Prod_Co\":\"numtimesDS\"}, inplace = True)\nprodcoData.sort_values(by='numtimesDS', ascending=False, inplace = True)\n\nprodcoData['prodcoWt'] = prodcoData['numtimesDS']\/prodcoData['numtimesDS'].max().astype(np.float64)\nprodcoData.head()","914a60de":"# Import Keyword Table with Counts of Appearances\nfile = \"..\/input\/weighttables\/Keyword_Data.csv\"\nkeywordData = pd.read_csv(file)\nkeywordData.rename(columns = {\"# of Uses in DS\":\"numtimesDS\"}, inplace = True)\nkeywordData.sort_values(by='numtimesDS', ascending=False, inplace = True)\n\nkeywordData['keywordWt'] = keywordData['numtimesDS']\/keywordData['numtimesDS'].max().astype(np.float64)\nkeywordData.head()","bdf6aa86":"# Import Crew Table with Counts of Appearances\nfile = \"..\/input\/weighttables\/Crew_Data_clean.csv\"\ncrewData = pd.read_csv(file)\ncrewData.rename(columns = {\"Num\":\"numtimesDS\"}, inplace = True)\ncrewData.sort_values(by='numtimesDS', ascending=False, inplace = True)\n\ncrewData['crewWt'] = crewData['numtimesDS']\/crewData['numtimesDS'].max().astype(np.float64)\ncrewData.head()","bbed456e":"# In order to apply weights to the field with JSON data, we first flatten, then convert to list, then iterate to produce a wt. \n# We are assuming that bigger \"stars\" appear in the dataset more times. \n#https:\/\/www.kaggle.com\/rajuspartan\/exploratory-data-analysis-with-reusable-functions\n#Flatening JSON columns\ndef get_dictionary(s):\n    try:\n        d = eval(s)\n    except:\n        d = {}\n    return d\ntrain[\"castList\"] = train.cast.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\ntest[\"castList\"] = test.cast.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\n\ntrain[\"keywordList\"] = train.Keywords.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\ntest[\"keywordList\"] = test.Keywords.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\n\ntrain[\"prodcoList\"] = train.production_companies.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\ntest[\"prodcoList\"] = test.production_companies.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\n\ntrain[\"crewList\"] = train.crew.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\ntest[\"crewList\"] = test.crew.map(lambda x: sorted([d['id'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\n\ntrain['castList'].head()","0fa8c8ad":"#The castList is a string, convert this to a list for easy function application\n#Convert string to list, separate on commas\ntrain['castList'] = train['castList'].apply(lambda x: x[1:-1].split(','))\ntest['castList'] = test['castList'].apply(lambda x: x[1:-1].split(','))\n\ntrain['keywordList'] = train['keywordList'].apply(lambda x: x[1:-1].split(','))\ntest['keywordList'] = test['keywordList'].apply(lambda x: x[1:-1].split(','))\n\ntrain['prodcoList'] = train['prodcoList'].apply(lambda x: x[1:-1].split(','))\ntest['prodcoList'] = test['prodcoList'].apply(lambda x: x[1:-1].split(','))\n\ntrain['crewList'] = train['crewList'].apply(lambda x: x[1:-1].split(','))\ntest['crewList'] = test['crewList'].apply(lambda x: x[1:-1].split(','))\n\ntrain['castList'].head()","c98359ab":"#create sum of weights column\ndef weight(data):\n    wt = 0\n    for row in data:\n        for x in row:\n            wt = wt + int(x)\n            \n    return wt\n\ntrain['castWt'] = train['castList'].apply(weight)\ntest['castWt'] = test['castList'].apply(weight)\n\ntrain['keywordWt'] = train['keywordList'].apply(weight)\ntest['keywordWt'] = test['keywordList'].apply(weight)  \n\ntrain['prodcoWt'] = train['prodcoList'].apply(weight)\ntest['prodcoWt'] = test['prodcoList'].apply(weight)\n\ntrain['crewWt'] = train['crewList'].apply(weight)\ntest['crewWt'] = test['crewList'].apply(weight)\n\n#Add columns for Team weights\ntrain['teamWt'] = train['castWt']+train['crewWt']+train['prodcoWt']\ntest['teamWt'] = test['castWt']+test['crewWt']+test['prodcoWt']\n\ntrain.head(2)","31b18924":"def proc_json_len(string):\n    try:\n        data = eval(string)\n        return len(data)\n    except:\n        return 0\n\ntrain['count_genre'] = train.genres.apply(proc_json_len)\ntrain['count_country'] = train.production_countries.apply(proc_json_len)\ntrain['count_company'] = train.production_companies.apply(proc_json_len)\ntrain['count_splang'] = train.spoken_languages.apply(proc_json_len)\ntrain['count_cast'] = train.cast.apply(proc_json_len)\ntrain['count_crew'] = train.crew.apply(proc_json_len)\ntrain['count_staff'] = train.count_cast + train.count_crew\ntrain['count_keyword'] = train.Keywords.apply(proc_json_len)\ntest['count_genre'] = test.genres.apply(proc_json_len)\ntest['count_country'] = test.production_countries.apply(proc_json_len)\ntest['count_company'] = test.production_companies.apply(proc_json_len)\ntest['count_splang'] = test.spoken_languages.apply(proc_json_len)\ntest['count_cast'] = test.cast.apply(proc_json_len)\ntest['count_crew'] = test.crew.apply(proc_json_len)\ntest['count_staff'] = test.count_cast + test.count_crew\ntest['count_keyword'] = test.Keywords.apply(proc_json_len)\ntrain.head()","deaade4e":"#Collection or not?\ntrain['belongs_to_collection'] = train['belongs_to_collection'].notna()\ntest['belongs_to_collection'] = test['belongs_to_collection'].notna()\ntest.head(2)","4fd47fcd":"new_genres_train = pd.DataFrame(train['genres'])\nnew_genres_test = pd.DataFrame(test['genres'])\nnew_splang_train = pd.DataFrame(train['spoken_languages'])\nnew_splang_test = pd.DataFrame(test['spoken_languages'])\nnew_genres_train.head()","fcbc0c2c":"def get_dictionary(s):\n    try:\n        d = eval(s)\n    except:\n        d = {}\n    return d\n#https:\/\/www.kaggle.com\/rajuspartan\/exploratory-data-analysis-with-reusable-functions\n#Flatening JSON columns\nnew_genres_train.genres = new_genres_train.genres.map(lambda x: sorted([d['name'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\nnew_genres_test.genres = new_genres_test.genres.map(lambda x: sorted([d['name'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\n\nnew_splang_train.spoken_languages = new_splang_train.spoken_languages.map(lambda x: sorted([d['iso_639_1'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\nnew_splang_test.spoken_languages = new_splang_test.spoken_languages.map(lambda x: sorted([d['iso_639_1'] for d in get_dictionary(x)])).map(lambda x: ','.join(map(str, x)))\nnew_splang_train.head()\n","21550c81":"#We used this approach from Stack Overflow\n#https:\/\/stackoverflow.com\/questions\/50394099\/separate-columns-based-on-genre\n#featurize the genre column\nnew_genres_train = new_genres_train['genres'].str.get_dummies(',')\nnew_genres_test = new_genres_test['genres'].str.get_dummies(',')\nprint(new_genres_test)","57cce8d1":"#featurize the spoken language column\n# Is english in the spoken language?\ndef proc_json_len2(string):\n        if ('en' in string):\n            return 1\n        else:\n            return 0\n  \nnew_splang_train['inEnglish'] = new_splang_train['spoken_languages'].apply(proc_json_len2)\nnew_splang_test['inEnglish'] = new_splang_test['spoken_languages'].apply(proc_json_len2)\nnew_splang_train.columns\nnew_splang_train.head()\n","688c3951":"#add genres back to data (join)\ntrain = pd.concat([train, new_genres_train], axis = 1, sort = False)\ntest = pd.concat([test, new_genres_test], axis = 1, sort = False)","8a15e455":"#add spoken languages back to data (join)\ntrain = pd.concat([train, new_splang_train], axis = 1, sort = False)\ntest = pd.concat([test, new_splang_test], axis = 1, sort = False)\ntrain.head(2)","273c750e":"train.columns","9d020af1":"#Select subset of columns\ntrain = train[['id','belongs_to_collection','budget', 'original_language', 'popularity', 'status','year', 'month', 'Action', 'Adventure', 'Animation', 'Comedy',\n       'Crime', 'Documentary', 'Drama', 'Family', 'Fantasy', 'Foreign',\n       'History', 'Horror', 'Music', 'Mystery', 'Romance', 'Science Fiction',\n       'TV Movie', 'Thriller', 'War', 'Western', 'count_genre',\n       'count_country', 'count_company', 'count_splang', 'count_cast',\n       'count_crew', 'count_staff', 'count_keyword', \"castWt\",'prodcoWt','keywordWt', 'crewWt','teamWt','inEnglish', \"revenue\"]]\ntest = test[['id','belongs_to_collection','budget', 'original_language', 'popularity', 'status','year', 'month', 'Action', 'Adventure', 'Animation', 'Comedy',\n       'Crime', 'Documentary', 'Drama', 'Family', 'Fantasy', 'Foreign',\n       'History', 'Horror', 'Music', 'Mystery', 'Romance', 'Science Fiction',\n       'Thriller', 'War', 'Western', 'count_genre',\n       'count_country', 'count_company', 'count_splang', 'count_cast',\n       'count_crew', 'count_staff', 'count_keyword', \"castWt\",'prodcoWt','keywordWt', 'crewWt','teamWt','inEnglish']]\n\ntrain.head()","8afb1b8f":"data = train.copy()\ndata2 = test.copy()\ndata_binary_encoded = pd.get_dummies(data, columns=[\"belongs_to_collection\", \"status\"])\ndata2_binary_encoded = pd.get_dummies(data2, columns=[\"belongs_to_collection\", \"status\"])\n#Select subset of columns\ntrain = data_binary_encoded[['id','belongs_to_collection_True', 'budget', 'original_language', 'popularity', 'status_Released', 'year', 'month', 'Action', 'Adventure', 'Animation', 'Comedy',\n       'Crime', 'Documentary', 'Drama', 'Family', 'Fantasy', 'Foreign',\n       'History', 'Horror', 'Music', 'Mystery', 'Romance', 'Science Fiction', 'Thriller', 'War', 'Western', 'count_genre',\n       'count_country', 'count_company', 'count_splang', 'count_cast',\n       'count_crew', 'count_staff', 'count_keyword', \"castWt\",'prodcoWt','keywordWt', 'crewWt','teamWt','inEnglish', 'revenue']]\ntest = data2_binary_encoded[['id','belongs_to_collection_True', 'budget', 'original_language', 'popularity', 'status_Released', 'year', 'month', 'Action', 'Adventure', 'Animation', 'Comedy',\n       'Crime', 'Documentary', 'Drama', 'Family', 'Fantasy', 'Foreign',\n       'History', 'Horror', 'Music', 'Mystery', 'Romance', 'Science Fiction','Thriller', 'War', 'Western', 'count_genre',\n       'count_country', 'count_company', 'count_splang', 'count_cast',\n       'count_crew', 'count_staff', 'count_keyword', \"castWt\", 'prodcoWt','keywordWt', 'crewWt','teamWt','inEnglish']]\n\ntrain.head()","0ba30b0d":"train['language_enc'] = pd.factorize(train['original_language'])[0]\ntest['language_enc'] = pd.factorize(test['original_language'])[0]\n#This is just a list of all of the languages listed\ncatenc = pd.factorize(train['original_language'])\n\ntrain.head()","780c2f03":"X = train[['id','belongs_to_collection_True', 'budget', 'language_enc', 'popularity','year', 'month', 'count_genre',\n       'count_country', 'count_company', 'count_splang', 'count_cast',\n       'count_crew', 'count_staff', 'count_keyword', \"castWt\",'prodcoWt','keywordWt', 'crewWt','teamWt','inEnglish']]\ny = train['revenue'].values.reshape(-1,1)\nprint(X.shape, y.shape)","51ec1a23":"#looking at a subset of attributes only\ntrain2 = train[['belongs_to_collection_True', 'budget', 'popularity', 'year','month', 'revenue']]\ntrain2.head()","125edc2e":"#explore datasets\nimport seaborn as sns; sns.set(style=\"ticks\", color_codes=True)\npairplots = sns.pairplot(train2, diag_kind = 'kde', hue = \"month\",palette = \"Accent\", plot_kws = {'alpha': 0.6, 's': 80, 'edgecolor': 'k'},\n             height = 4)","8f86a455":"# Use train_test_split to create training and testing data from our \"train\" dataset\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\nprint(X_train.shape, y_train.shape)\nprint(X_test.shape, y_test.shape)","9e6c0baf":"from sklearn.linear_model import LinearRegression\n#create the linear regression object\nmodel = LinearRegression(fit_intercept = True)\n#train the model\nmodel.fit(X_train, y_train)\ntraining_score = model.score(X_train, y_train)\nprint(f\"R2 Score: {training_score}\")","80311594":"# Plot the Residuals for the Training and Testing data\n#Residuals are the difference between the true values of y and the predicted values of y.\n#make predictions using the testing set\nprediction = model.predict(X_test)\n#plot residuals\nplt.scatter(model.predict(X_train), model.predict(X_train) - y_train, c=\"black\", label=\"Training Data\")\nplt.scatter(prediction, prediction - y_test, c=\"grey\", label=\"Testing Data\")\nplt.legend()\nplt.hlines(y=0, xmin=y_test.min(), xmax=y_test.max())\nplt.title(\"Residual Plot\")\nplt.show()\n\nMSE = mean_squared_error(y_test, prediction)\nr2 = model.score(X_test, y_test)\n### END SOLUTION\nprint(f\"MSE: {MSE}, R2: {r2}\")","fa4a42b9":"# Fit regression model\nparams = {'n_estimators': 500, 'max_depth': 4, 'min_samples_split': 2,\n          'learning_rate': .01, 'loss': 'ls'} \nclf = ensemble.GradientBoostingRegressor(**params)\npredictions2 = clf.fit(X_train,y_train)\ntraining_score = clf.score(X_train, y_train)\nprint(f\"Training Score: {training_score}\")","77510e3d":"# Plot the Residuals for the Training and Testing data\n### BEGIN SOLUTION\npredictions2 = np.expand_dims(clf.predict(X_test), axis = 1)\nplt.scatter((np.expand_dims(clf.predict(X_train), axis = 1)), (np.expand_dims(clf.predict(X_train), axis = 1)) - y_train, c=\"black\", label=\"Training Data\")\nplt.scatter(predictions2, predictions2 - y_test, c=\"grey\", label=\"Testing Data\")\nplt.legend()\nplt.hlines(y=0, xmin=y_test.min(), xmax=y_test.max())\nplt.title(\"Residual Plot\")\nplt.show()\n\nMSE = mean_squared_error(y_test, predictions2)\nr2 = clf.score(X_test, y_test)\nprint(f\"MSE: {MSE}, R2: {r2}\")","cf3c075d":"#Predictions for the test data\nrevenue_predictions = clf.predict(X_test)\ngbr_predictions = pd.DataFrame(revenue_predictions, columns = ['revenue'])\ngbr_predictions.head()","ed34f3ab":"test2 = pd.concat([test, gbr_predictions], axis = 1, join_axes = [test.index])\n#look at top values only\ntest2 = test2[['belongs_to_collection_True', 'budget', 'popularity', 'year','month', 'revenue']]\ntest2.head()","9982de4f":"#explore datasets\nimport seaborn as sns; sns.set(style=\"ticks\", color_codes=True)\npairplots = sns.pairplot(test2, diag_kind = 'kde', hue = \"month\",palette = \"Accent\", plot_kws = {'alpha': 0.6, 's': 80, 'edgecolor': 'k'},\n             height = 4)","ff6c6e77":"## Correcting Dates","cd5003f1":"## Factorize to map each categorical item in a column to a value","7e3b78e5":"## Part of a Collection, or Not?\nCreate a boolean column","602ef18d":"## Create Count Features\nSome great information found here!\n#https:\/\/www.kaggle.com\/jiegeng94\/machine-learning-beginner-tutorial","40675fbd":"# Modeling","1c1afdeb":"### Residuals\n","47ef246c":"## Dummy Encoding to transform categorical features","bd1ffd68":"## Genres and Spoken Languages","526ca408":"## Gradient Boosting Regressor - No Scaler","14d6c83a":"## Assigning weights to Cast, Crew, Production Companies, and Keyword by # appearances\nSimilar to scalers used for ML models later, we decided to weight the cast, crew, and keywords by number of appearances in the dataset.  We created tables of the unique values, then assigned a weight over the range.  ","1b01a7d0":"# TEST \/ TRAIN SPLIT OF TRAIN Dataset","5e495964":"# Cleaning and Preprocessing Data for Machine Learning","7f5e357d":"# LINEAR REGRESSION - No Scaling"}}