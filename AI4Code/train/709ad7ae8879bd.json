{"cell_type":{"ff58fbbb":"code","e61c30e2":"code","a85570db":"code","ae3105cd":"code","580c7cd3":"code","852d2da7":"code","8cf38592":"code","7e39ee78":"code","beff599b":"code","67b75748":"code","acce7960":"code","7a93ceb8":"code","9fd4aaf7":"code","63979653":"code","697a4efe":"code","b2b0f747":"code","19de00fd":"code","958f4393":"code","65f8c2f5":"code","b0d8f22e":"code","12433408":"markdown","291b58c2":"markdown","86ac827d":"markdown","0c1c3b9a":"markdown","9e6d8fb9":"markdown","34ae34be":"markdown","c2e64055":"markdown","fe216f62":"markdown","727b3494":"markdown","fbf8e9ef":"markdown","3955639c":"markdown","6abe28b1":"markdown","9323a5f5":"markdown","0407222e":"markdown","ba1cb2b6":"markdown","fdb96366":"markdown","1b422bf9":"markdown","7710d6c5":"markdown","6990926e":"markdown"},"source":{"ff58fbbb":"# List\na = [1, 2, 3, 6, 'abc']\nprint('List:', a)\n# Dictionary\nb = {1: 32, 'abc': [1, 2, 3]}\nprint('Dictionary:', b)\n\n# Function\ndef hello():\n    return 'Hello World'\nprint('Function \"hello\" returns:', hello())\n\n# List Comprehensions\nc = [item + item for item in a]\nprint('List Comprehension:', c)","e61c30e2":"# Iterating over a list\nez_list = [1, 2, 3]\nfor i in ez_list:\n    print(i)","a85570db":"# Iterating over a string\nez_string = 'Generators'\nfor s in ez_string:\n    print(s)","ae3105cd":"# Iterating over a dictionary\nez_dict = {1 : 'First', 2 : 'Second'}\nfor key, value in ez_dict.items():\n    print(key, value)","580c7cd3":"number = 12345\nfor n in number:\n    print(n)","852d2da7":"# Regular function\ndef function_a():\n    return \"a\"\n\n# Generator function\ndef generator_a():\n    yield \"a\"","8cf38592":"function_a()","7e39ee78":"generator_a()","beff599b":"# Asking the generator what the next item is\nnext(generator_a())","67b75748":"# Do not do this\nnext(generator_a)","acce7960":"def multi_generate():\n    yield \"a\"\n    yield \"b\"\n    yield \"c\"\n\nmg = multi_generate()","7a93ceb8":"print(next(mg))\nprint(next(mg))\nprint(next(mg))\nprint(next(mg))","9fd4aaf7":"from glob import glob\nimport os\n\npath_to_train = '..\/input\/train\/train'\nglob_train_imgs = os.path.join(path_to_train, '*_sat.jpg')\nglob_train_masks = os.path.join(path_to_train, '*_msk.png')\n\ntrain_img_paths = glob(glob_train_imgs)\ntrain_mask_paths = glob(glob_train_masks)\nprint(train_img_paths[:10])\nprint(train_mask_paths[:10])","63979653":"from skimage.io import imread\nfrom skimage.transform import resize\nfrom skimage.color import rgb2gray\n\n# This will be useful so we can construct the corresponding mask\ndef get_img_id(img_path):\n    img_basename = os.path.basename(img_path)\n    img_id = os.path.splitext(img_basename)[0][:-len('_sat')]\n    return img_id\n\n# Write it like a normal function\ndef image_gen(img_paths, img_size=(128, 128)):\n    # Iterate over all the image paths\n    for img_path in img_paths:\n        \n        # Construct the corresponding mask path\n        img_id = get_img_id(img_path)\n        mask_path = os.path.join(path_to_train, img_id + '_msk.png')\n        \n        # Load the image and mask, and normalize it to 0-1 range\n        img = imread(img_path) \/ 255.\n        mask = rgb2gray(imread(mask_path))\n        \n        # Resize the images\n        img = resize(img, img_size, preserve_range=True)\n        mask = resize(mask, img_size, mode='constant', preserve_range=True)\n        # Turn the mask back into a 0-1 mask\n        mask = (mask >= 0.5).astype(float)\n        \n        # Yield the image mask pair\n        yield img, mask\n","697a4efe":"import matplotlib.pyplot as plt\n\n\nig = image_gen(train_img_paths)\n\nfirst_img, first_mask = next(ig)\n\nplt.imshow(first_img)\nplt.show()\nplt.imshow(first_mask, cmap='gray')\nplt.show()","b2b0f747":"# Create simple model\nfrom keras.layers import Conv2D, Reshape\nfrom keras.models import Sequential\n\nmodel = Sequential()\nmodel.add(Conv2D(64, 5, activation='relu', padding='same', input_shape=(128, 128, 3)))\nmodel.add(Conv2D(128, 5, activation='relu', padding='same'))\nmodel.add(Conv2D(1, 5, activation='sigmoid', padding='same'))\nmodel.add(Reshape((128, 128)))","19de00fd":"import keras.backend as K\nfrom keras.optimizers import Adam\nfrom keras.losses import binary_crossentropy\n\nsmooth = 1e-9\n\n# This is the competition metric implemented using Keras\ndef dice_coef(y_true, y_pred):\n    y_true_f = K.flatten(y_true)\n    y_pred = K.cast(y_pred, 'float32')\n    y_pred_f = K.cast(K.greater(K.flatten(y_pred), 0.5), 'float32')\n    intersection = y_true_f * y_pred_f\n    score = 2. * (K.sum(intersection) + smooth) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n    return score\n\n# We'll construct a Keras Loss that incorporates the DICE score\ndef dice_loss(y_true, y_pred):\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = K.sum(y_true_f * y_pred_f)\n    return 1. - (2. * intersection + 1.) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + 1.)\n\n\ndef bce_dice_loss(y_true, y_pred):\n    return 0.5 * binary_crossentropy(y_true, y_pred) + dice_loss(y_true, y_pred)\n\nmodel.compile(Adam(lr=0.01), loss=bce_dice_loss, metrics=[dice_coef])","958f4393":"import numpy as np\n\n# Keras takes its input in batches \n# (i.e. a batch size of 32 would correspond to 32 images and 32 masks from the generator)\n# The generator should run forever\ndef image_batch_generator(img_paths, batchsize=32):\n    while True:\n        ig = image_gen(img_paths)\n        batch_img, batch_mask = [], []\n        \n        for img, mask in ig:\n            # Add the image and mask to the batch\n            batch_img.append(img)\n            batch_mask.append(mask)\n            # If we've reached our batchsize, yield the batch and reset\n            if len(batch_img) == batchsize:\n                yield np.stack(batch_img, axis=0), np.stack(batch_mask, axis=0)\n                batch_img, batch_mask = [], []\n        \n        # If we have an nonempty batch left, yield it out and reset\n        if len(batch_img) != 0:\n            yield np.stack(batch_img, axis=0), np.stack(batch_mask, axis=0)\n            batch_img, batch_mask = [], []    ","65f8c2f5":"from sklearn.model_selection import train_test_split\n\nBATCHSIZE = 32\n\n# Split the data into a train and validation set\ntrain_img_paths, val_img_paths = train_test_split(train_img_paths, test_size=0.15)\n\n# Create the train and validation generators\ntraingen = image_batch_generator(train_img_paths, batchsize=BATCHSIZE)\nvalgen = image_batch_generator(val_img_paths, batchsize=BATCHSIZE)\n\ndef calc_steps(data_len, batchsize):\n    return (data_len + batchsize - 1) \/\/ batchsize\n\n# Calculate the steps per epoch\ntrain_steps = calc_steps(len(train_img_paths), BATCHSIZE)\nval_steps = calc_steps(len(val_img_paths), BATCHSIZE)\n\n# Train the model\nhistory = model.fit_generator(\n    traingen, \n    steps_per_epoch=train_steps, \n    epochs=5, # Change this to a larger number to train for longer\n    validation_data=valgen, \n    validation_steps=val_steps, \n    verbose=1,\n    max_queue_size=5  # Change this number based on memory restrictions\n)","b0d8f22e":"import pandas as pd\n\n# Plot the training curve\npd.DataFrame(history.history)[['loss', 'val_loss']].plot(title=\"Loss\", logy=True)\npd.DataFrame(history.history)[['dice_coef', 'val_dice_coef']].plot(title=\"Dice\")","12433408":"Let's test it out! We can use `matplotlib`'s `imshow` to visualize the images.","291b58c2":"If you're following along with the data on your own computer, you'll need to replace `path_to_train` with the path on your computer to where the train images are located. This will enable Python to find it and all the train images","86ac827d":"Notice that we have to pass in generator function with the parentheses since the function itself is the generator. Providing only the function name will throw an error since you're trying to give `next()` a function name. As expected, the generator function will `yield` 'a' once we invoke the `next()` function.\n\nThis example is not fully representative of what a generator is useful for. Remember that generators produce a stream of values, so `yield`ing a single value doesn't really qualify as a stream. To do this, we can actually put in multiple `yield` statements into a generator function. These `yield` statements form the sequence that the generator will output.\n\nWe'll create a generator and bind it to a varible `mg`. Then, if we keep passing `mg` into `next()`, we'll get to the next yield. If we keep going past, we'll be given a `StopIteration` error to tell us that the generator has no more values to give. The `StopIteration` error is actually how a `for` loop knows when to stop iterating.","0c1c3b9a":"### Key takeaways: basic terms to know\n\n* Iteration is the idea of repeating some process over a sequence of items. In Python, iteration is usually related to the `for` loop.\n* An iterable is an object that supports iteration.\n* To be an iterable, it must describe to a for loop two things:\n  * What item comes next in the iteration.\n  * When should the loop stop iteration.\n* Generators are iterables.","9e6d8fb9":"### The generator function\n\nA generator function is just like a regular function but with a key difference: the `yield` keyword replaces `return`.","34ae34be":"## Using Generators for our Image Data","c2e64055":"Calling a regular function tells Python to go back to where the function is located in our code, perform the code within the block, and return the result. In order to get the generator function to yield its values, you need to pass it into the `next()` function.\n\n`next()` is a special function that asks, \"What's the next item in the iteration?\" In fact, `next()` is the precise function that is called when you run a for loop! Lists, dictionaries, strings, and the like all implement `next()`, so this is why you can incorporate them into loops in the first place.","fe216f62":"In each of the above examples, the `for` loop iterates over the sequence we give it. The code above used a list, string, and dictionary, but you can iterate over tuples and sets as well. In each loop above, we `print` each of the items in the sequence in the order they appear. For example, you can confirm that the order of the `ez_list` is replicated in the order that its items are printed out.\n\nWe refer to any object that can support iteration as an **iterable**.","727b3494":"An integer is just a singular number, not a sequence. You may argue that the \"first\" number in `number` is 1, but it is not the same as the first item in a sequence. It doesn't make sense to ask \"What's after 1?\" from `number` since Python only understands integers as a single entities.\n\nTherefore, one of the requirements to be an iterable is to be able to describe to the `for` loop what the next item to perform the operation on is. For example, lists tell the `for` loop that the next item to iterate on is in the index+1 from the current one (1 comes after 0).\n\nConsequently, an iterable must also signal to a `for` loop when to *stop* iterating. This signal usually comes when we arrive at the end of a sequence (i.e. the end of a list or string). We will explore the specific functions that make something iterable later in this article, the important thing to know is that iterables describe *how* a `for` loop should traverse its contents.\n\nGenerators are iterables themselves. As you'll see later, `for` loops are one of the main ways we use a generator, so they must be able to support iteration. We'll delve into how we can create our own generators in the next secton.","fbf8e9ef":"The two functions above perform exactly same action (returning\/yielding the same string). However, if you try to inspect the generator function, it won't match what the regular function shows.","3955639c":"It's easy to think of generators as a machine that waits for one command and one command only: `next()`. Once you call `next()` on the generator, it will dispense the next value in the sequence it is holding. Otherwise, you can't do much else with a generator. The image below represents our generator as a simple machine.\n\n![](gen_img.jpg)\n\nWe've noted that as we keep passing in `mg` into next, we get the other `yield` results. This is possible only if the generator somehow remembers what it last did. This memory is what distinguishes generator functions from regular functions! Once you use a function, it's a one-and-done deal. Once you `return` the value from the function. A generator will keep `yield`ing values until its out.\n\nThis brings us to another important property of generators. Once we've finished iterating through them, we can't use them anymore. Once we got through all three `yield` values in `mg`, it can't provide anything to us anymore. We'd have to store another instance of the `multi_generate` generator to begin asking `next()` statements of it again.","6abe28b1":"### Keras `fit_generator`\n\nKeras follows a similar API to the famous python machine learning library, Scikit-Learn. A Keras model comes with a `fit` method that trains the model using some training data. Since training neural networks on image data often involves data that can be quite memory-intensive, Keras also includes a `fit_generator` method that takes as input a python generator of all the image data. Good thing we know how to make one!\n\nSee the documentation for [`fit_generator`](https:\/\/keras.io\/models\/sequential\/#fit_generator)","9323a5f5":"### What defines an iterable?\nIterables support something called the **Iterator Protocol**. The technical definition for the Iterator Protocol is out of the scope of this article, but it can be thought of as a set of *requirements* to be used for a `for` loop. That is to say: lists, strings and dictionaries all follow the Iterator Protocol, therefore we can use them in `for` loops. Conversely, objects that do not follow the protocol cannot be used in a `for` loop. One example of an object that does not follow the protocol is an integer.\n\nIf we try to give an integer to a `for` loop, Python will throw an error.","0407222e":"## Generators and you\n\nIf you've never encountered a generator before, the most common real-life example of a generator is a backup generator, which creates \u2014 *generates* \u2014 electricity for your house or office.\n\nConceptually, Python generators generate values *one at a time* from a given sequence, instead of giving the entirety of the sequence at once. This one-at-a-time fashion of generators is what makes them so compatible with `for` loops. If this sounds confusing, don't worry too much. As we explain how to create generators, it will become more clear.\n\nThere are two ways to create a generator. They differ in their syntax, but the end result is still a generator. We'll teach these concepts by covering their syntax and comparing them to a similar, but non-generator equivalent.\n\n* A generator *function* versus a regular function\n* A generator *expression* versus a list comprehension","ba1cb2b6":"### Prereqs\n\nTo get the most out of this tutorial, you should be familiar with the following concepts:\n\n* Basic Python data structures\n  * What a list is\n  * What a dictionary is\n* Functions\n  * What a function is\n  * How to create and use functions\n* List Comprehensions\n  * What a list comprehension is\n  * How to create a simple list comprehension\n\n","fdb96366":"## Some Basic Terms\n\n### Iteration and iterables\nIteration is the repetition of some kind of process over and over again. Python's for loop gives us an easy way to iterate over various objects. Often, you'll iterate over a list, but we can also iterate over other Python objects such as strings and dictionaries.","1b422bf9":"## Using our Generator with Keras + Tensorflow\n\nSo we've just made a python generator to efficiently read our images from our disk rather than loading them all into memory. What do we do with it now? Use it to train a model! To do this we'll be using a deep learning library called Keras, built on top of Tensorflow. If you're not familiar with Tensorflow and Keras, take a look at some of these resources:\n\n* [Keras Tutorials](https:\/\/github.com\/fchollet\/keras-resources)\n* [Tensorflow Guide to Keras](https:\/\/www.tensorflow.org\/guide\/keras)\n* [Building a U-Net in Keras](https:\/\/www.kaggle.com\/keegil\/keras-u-net-starter-lb-0-277)\n\nIf you want to learn more about deep learning and convolutional neural networks, take a look at these resources:\n\n* [Stanford CS231n Course Notes](http:\/\/cs231n.github.io\/)\n* [Stanford CS231n ConvNet Notes](http:\/\/cs231n.github.io\/convolutional-networks\/)\n* [An Intuitive Explanation of ConvNets](https:\/\/ujjwalkarn.me\/2016\/08\/11\/intuitive-explanation-convnets\/)\n\n**NOTE: The model below will not produce good results, it's just meant to give you an example of the Keras workflow. To make models that will actually work, see the links above**","7710d6c5":"# Python Image Generators\n\nHave you tried to load the entire image dataset into numpy arrays? If you tried, you might have realized that it takes over **60GB of RAM**. In this tutorial we'll go over an easy way in Python to get around this problem and load images on the fly from disk (the file itself).","6990926e":"Our generator will work in the following way:\n* We iterate over the filenames for the images we want to load\n* Open the image file using a library like PIL or scikit-image\n* Open the corresponding mask\n* Yield the image and mask pair"}}