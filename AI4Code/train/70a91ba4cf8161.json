{"cell_type":{"045d9776":"code","9ec79968":"code","005a591a":"code","7270f3c4":"code","0d4b7faf":"code","6ce5b197":"code","79636528":"code","3cfac397":"code","42a76da6":"code","de90804b":"code","241e809d":"code","4fbab746":"code","8980e7cc":"code","ef0cb749":"code","00e33daa":"code","6aa34039":"code","67dfc7d8":"code","8f6ff37e":"code","a26cfb44":"code","5b3db09f":"code","d707efe4":"code","5627574c":"code","eded6742":"markdown","f0253c81":"markdown","3c06b8d6":"markdown","565ab7b5":"markdown","c9386662":"markdown","4dd6c020":"markdown","0c288569":"markdown","9eb6d07f":"markdown","79df3699":"markdown","029b6d4d":"markdown","6fcb0d2b":"markdown","c0a69359":"markdown","f93003f5":"markdown","9647f085":"markdown"},"source":{"045d9776":"import pandas as pd\nimport ast","9ec79968":"# Variables\nPATH_INPUT = \"\/kaggle\/input\/\"\nPATH_WORKING = \"\/kaggle\/working\/\"\nPATH_TMP = \"\/tmp\/\"","005a591a":"# Reading data into a df\ndf_raw = pd.read_csv(f'{PATH_INPUT}train.csv', low_memory=False, skipinitialspace=True)\ndf_raw.shape","7270f3c4":"# Take a look at the first 10 rows\ndf_raw.head(10)","0d4b7faf":"# define columns with data of dict type to process\ncols = ['belongs_to_collection', 'genres', 'production_companies', 'spoken_languages', 'Keywords', 'cast', 'crew']","6ce5b197":"# check the data type\ndf_raw[cols].dtypes","79636528":"# copy the column to a pandas series\ns = df_raw[cols[0]].copy()\ns.shape","3cfac397":"# check the first record\ns[0]","42a76da6":"# evaluate as a list\nl = ast.literal_eval(s[0])\nl","de90804b":"# check the data type\nprint(type(l), type(l[0]))","241e809d":"s[3]","4fbab746":"# copy one column to a pandas series\ns = df_raw[cols[0]].copy()\n# fillna with [None]\ns.fillna('[{}]', inplace=True)\n\nl = []  # init an empty list\n\nfor i in s:\n    if i == [{}]:\n        # append [{}] to the list\n        l += i\n    else:\n        # evaluate as a list\n        l += ast.literal_eval(i)","8980e7cc":"len(l)  # should be 3000 if processed correctly","ef0cb749":"l[:10]","00e33daa":"for i in range(10):\n    print(type(l[i]))","6aa34039":"df_tmp = pd.DataFrame.from_dict(l)\ndf_tmp[:10]","67dfc7d8":"def to_list_of_dict(series):\n    \"\"\"\n    Evaluate a pandas series as a list of dict\n    \n    Input:\n    \"[{'one': 1, 'two': 2, 'three': 3}]\"\n    \n    Output:\n    [{'one': 1,\n      'two': 2,\n      'three' : 3}]\n    \"\"\"\n    l = []  # init an empty list\n    s = series.fillna('[{}]')  # map nan to [{}] for further eval\n    \n    # loop through the whole series\n    for i in s:\n        if i == [{}]:\n            # append [{}] to the list\n            l += i\n        else:\n            # evaluate as a list\n            l += ast.literal_eval(i)\n    \n    return l","8f6ff37e":"def column_conversion(col, df):\n    \"\"\"\n    Merge a pandas series with data like list of dict back to the dataframe\n    \n    Input:\n    \"[{'one': 1, 'two': 2, 'three': 3}]\"\n    \n    Output:\n    A dataframe with the original column removed, each dict's key in a new column\n    \"\"\"\n    l = to_list_of_dict(df[col])  # convert to list of dict\n    df_right = pd.DataFrame.from_dict(l)  # convert to df\n    df_merged = df.merge(df_right.add_prefix(col+'_'),  # add the original column name as prefix\n                         left_index=True, right_index=True)  # merge df with df_right\n    df_merged.drop(col, axis=1, inplace=True) # drop the original column\n    \n    return df_merged","a26cfb44":"# Test\ncolumn_conversion(cols[0], df_raw)[:3]","5b3db09f":"# check the columns to process\ncols","d707efe4":"# make a copy\ndf = df_raw.copy()\n\n# process the columns one by one\nfor col in cols:\n    df = column_conversion(col, df)","5627574c":"# check the first record\ndf[:1]","eded6742":"Some columns contain data which look like `dict`. Let's see how we can parse them","f0253c81":"<p>This notebook demonstrates the thinking process of preparing a complex dateset (nested data structure) for further analysis.\n<p>Key techniques:\n    * ast.literal_eval()\n    * pd.DataFrame.from_dict()\n    * df.merge()\n    \n> \"[{'id': 313576, 'name': 'Hot Tub Time Machine Collection', 'poster_path': '\/iEhb00TGPucF0b4joM1ieyY026U.jpg', 'backdrop_path': '\/noeTVcgpBiD48fDjFVic1Vz7ope.jpg'}]\"\n","3c06b8d6":"literal_eval(nan) will return an error. Replace with an empty dict in a list wrapped as str `'[{}]'`","565ab7b5":"# Data Preparation","c9386662":"## Process all columns at once","4dd6c020":"# Data Import","0c288569":"Note that `nan` are processed as empty `dict`","9eb6d07f":"Cool! The dataframe is now flattened for further analysis.","79df3699":"## Trial with the first column","029b6d4d":"# Rewrite as functions","6fcb0d2b":"Let's put the steps together and parse a single column","c0a69359":"Looks good. See how we can make a df from the list of dict","f93003f5":"Looks like the columns are `string`. See how we can parse the column","9647f085":"Looks good. Let's try the 3rd row with NaN value"}}