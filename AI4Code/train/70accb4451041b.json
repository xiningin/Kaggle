{"cell_type":{"7c92f1d1":"code","5de97e60":"code","13df8f70":"code","d6f64b0a":"code","082fc703":"code","87a0593a":"markdown","eeee8d6f":"markdown","dbd81e8f":"markdown","6068ecff":"markdown"},"source":{"7c92f1d1":"import torch\nimport torchvision\nimport torchvision.transforms as transforms\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport pandas as pd\nimport numpy as np","5de97e60":"class Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv1 = nn.Conv2d(1, 32, 3, padding=1)\n        self.conv2 = nn.Conv2d(32, 32, 3, padding=1)\n        self.conv3 = nn.Conv2d(32, 64, 3, padding=1)\n        self.conv4 = nn.Conv2d(64, 64, 3, padding=1)\n        self.fc1 = nn.Linear(64*7*7, 128)\n        self.fc2 = nn.Linear(128, 10)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = F.relu(self.conv3(x))\n        x = self.pool(F.relu(self.conv4(x)))\n        x = x.view(-1, 64*7*7)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x","13df8f70":"class MNISTTrainset(torch.utils.data.Dataset):\n    def __init__(self, file_path, transform=None):\n        self.data = pd.read_csv(file_path)\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, index):\n        image = self.data.iloc[index, 1:].values.astype(np.uint8).reshape((28, 28, 1))\n        label = self.data.iloc[index, 0]\n\n        if self.transform is not None:\n            image = self.transform(image)\n\n        return image, label\n\n\nclass MNISTTestset(torch.utils.data.Dataset):\n    def __init__(self, file_path, transform=None):\n        self.data = pd.read_csv(file_path)\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, index):\n        image = self.data.iloc[index, :].values.astype(np.uint8).reshape((28, 28, 1))\n        label = 0\n\n        if self.transform is not None:\n            image = self.transform(image)\n\n        return image, label\n\n","d6f64b0a":"if __name__ == \"__main__\":\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    transform = transforms.Compose(\n        [transforms.ToTensor(),\n            transforms.Normalize((0.1307,), (0.3081,))])\n    PATH = '.\/mnist_net.pth'\n\n    trainset = MNISTTrainset('..\/input\/digit-recognizer\/train.csv', transform=transform)\n    trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2)\n\n    testset = MNISTTestset('..\/input\/digit-recognizer\/test.csv', transform=transform)\n    testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False, num_workers=2)\n\n    classes = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')\n\n    net = Net()\n    net.to(device)\n    #net.load_state_dict(torch.load(PATH))\n    optimizer = optim.Adam(net.parameters(), lr=0.0001)\n    criterion = nn.CrossEntropyLoss()\n\n    for epoch in range(8):\n        running_loss = 0.0\n        for i, data in enumerate(trainloader, 0):\n            inputs, labels = data[0].to(device), data[1].to(device)\n            optimizer.zero_grad()\n\n            outputs = net(inputs)\n            loss = criterion(outputs, labels)\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item()\n            if i % 2000 == 1999:    # print every 2000 mini-batches\n                print('[%d, %5d] loss: %.3f' %\n                    (epoch + 1, i + 1, running_loss \/ 2000))\n                running_loss = 0.0\n    print('Finished Training')\n    torch.save(net.state_dict(), PATH)\n","082fc703":"    i = 0\n    numbers = []\n    test_predicted = []\n    with torch.no_grad():\n        for data in testloader:\n            images, labels = data[0].to(device), data[1].to(device)\n            outputs = net(images)\n            _, predicted = torch.max(outputs.data, 1)\n            for j in range(4):\n                if i+j > testset.__len__()-1:\n                    pass\n                numbers.append(i+j+1)\n                test_predicted.append(predicted[j].item())\n            i += 4\n    np_results = np.array([numbers, test_predicted], dtype=object)\n    pframe = pd.DataFrame({'ImageId': numbers, 'Label': test_predicted})\n    pframe.to_csv('submission.csv', index=False, header=True)","87a0593a":"Neural Network adapted from here https:\/\/www.kaggle.com\/cdeotte\/how-to-choose-cnn-architecture-mnist\/notebook","eeee8d6f":"Turn CSV to datasets\n","dbd81e8f":"Test and write to CSV","6068ecff":"Training: I did 8 epochs"}}