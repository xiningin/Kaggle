{"cell_type":{"1d0bed71":"code","150b65ba":"code","2930e7bc":"code","5586f9fe":"code","0e8a98b5":"code","85f7790d":"code","61ce062c":"code","f7db3cdb":"code","01b7317d":"code","b9e86427":"code","41067c95":"code","2e47bbde":"code","03aea643":"code","65c168fb":"code","a79e1214":"code","76b55f5f":"code","457201cd":"code","6580eea0":"code","bfc75c47":"code","5f53cc82":"code","59d9c11c":"code","e8121a1a":"code","090952cc":"code","ebf088e2":"code","b429478f":"code","a93c0932":"code","41d56c73":"code","0de13af8":"code","e425ac8c":"markdown","e3178a7f":"markdown","54de35b6":"markdown","8ced5bee":"markdown","77c95c18":"markdown","23455247":"markdown","f2ec69b3":"markdown","7f6b4873":"markdown","cb85958e":"markdown","a84bd3b7":"markdown","f99fe55a":"markdown","0716f772":"markdown","e5a12293":"markdown","2b0418fe":"markdown","5048b54d":"markdown","f9abf60a":"markdown","250dcbdb":"markdown","7e068425":"markdown","792dcd65":"markdown"},"source":{"1d0bed71":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\nfrom imblearn.under_sampling import NearMiss\nfrom imblearn.over_sampling import SMOTE\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import average_precision_score\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import precision_recall_curve\nfrom sklearn import preprocessing\nfrom tensorflow import keras\nfrom sklearn.utils import shuffle\nfrom sklearn.linear_model import LogisticRegression\n\nimport tensorflow as tf\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator \nfrom tensorflow.keras import datasets, layers, models\nfrom tensorflow.keras.metrics import AUC\nfrom tensorflow.keras.callbacks import ReduceLROnPlateau\n\nimport keras_tuner\nfrom keras_tuner.engine.hyperparameters import HyperParameter\nfrom keras_tuner import RandomSearch\n\nimport shutil\n","150b65ba":"# Detect hardware, return appropriate distribution strategy\ntry:\n    # Sync TPU version\n    from cloud_tpu_client import Client\n    c = Client()\n    c.configure_tpu_version(tf.__version__, restart_type='ifNeeded')\n    \n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()  # TPU detection. No parameters necessary if TPU_NAME environment variable is set. On Kaggle this is always the case.\n    print('Running on TPU ', tpu.master())\nexcept ValueError as v:\n    tpu = None\n    print(v)\n    \n\nif tpu:\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.TPUStrategy(tpu)\nelse:\n    strategy = tf.distribute.get_strategy() # default distribution strategy in Tensorflow. Works on CPU and single GPU.\n\nprint(\"REPLICAS: \", strategy.num_replicas_in_sync)","2930e7bc":"df =  pd.read_csv(\"..\/input\/creditcardfraud\/creditcard.csv\")","5586f9fe":"df","0e8a98b5":"df.describe()","85f7790d":"df.info()","61ce062c":"df_fraud = df.loc[df[\"Class\"]==1]\ndf_no_fraud = df.loc[df[\"Class\"]==0]","f7db3cdb":"df_fraud","01b7317d":"df_no_fraud_sample = df_no_fraud.sample(n=492)","b9e86427":"fig , (ax1,ax2) = plt.subplots(1,2,figsize=(20,3)) \ndf_no_fraud_sample.plot(kind=\"scatter\",x=\"Time\",y=\"Amount\",alpha = 0.5,title = \"Not Fraud\",ax=ax1)\ndf_fraud.plot(kind=\"scatter\",x=\"Time\",y=\"Amount\",alpha = 0.5,title = \"Fraud\",ax=ax2)","41067c95":"fig, axes = plt.subplots(ncols=2,nrows=2,figsize=(15,8))\nplt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=1.01)\nax = axes[0][0]\nsns.kdeplot(df_fraud[\"Time\"], shade=False, color='crimson',ax=ax)\nkdeline = ax.lines[0]\nxs = kdeline.get_xdata()\nys = kdeline.get_ydata() \nax.set_title(\"Fraud:Time\")\nax.fill_between(xs, 0, ys, facecolor='crimson', alpha=0.2)\n\nax = axes[0][1]\namount_fraud = df_fraud[\"Amount\"]\nsns.kdeplot(amount_fraud[(np.abs(stats.zscore(amount_fraud)) < 3)], shade=False, color='crimson',ax=ax)\nkdeline = ax.lines[0]\nxs = kdeline.get_xdata()\nys = kdeline.get_ydata()    \nmiddle = amount_fraud[(np.abs(stats.zscore(amount_fraud)) < 3)].mean()\nsdev = amount_fraud[(np.abs(stats.zscore(amount_fraud)) < 3)].std()\nleft = middle - sdev\nright = middle + sdev\nax.set_title(\"Fraud:Amount\")\nax.vlines(middle, 0, np.interp(middle, xs, ys), color='crimson', ls=':')\nax.fill_between(xs, 0, ys, facecolor='crimson', alpha=0.2)\nax.fill_between(xs, 0, ys, where=(left <= xs) & (xs <= right), interpolate=True, facecolor='crimson', alpha=0.2)\n\nax = axes[1][0]\nsns.kdeplot(df_no_fraud[\"Time\"], shade=False, color='blue',ax=ax)\nkdeline = ax.lines[0]\nxs = kdeline.get_xdata()\nys = kdeline.get_ydata() \nax.set_title(\"No Fraud:Time\")\nax.fill_between(xs, 0, ys, facecolor='blue', alpha=0.2)\n\nax = axes[1][1]\namount_no_fraud = df_no_fraud[\"Amount\"]\nsns.kdeplot(amount_no_fraud[(np.abs(stats.zscore(amount_no_fraud)) < 3)], shade=False, color='blue',ax=ax)\nkdeline = ax.lines[0]\nxs = kdeline.get_xdata()\nys = kdeline.get_ydata()    \nmiddle = amount_no_fraud[(np.abs(stats.zscore(amount_no_fraud)) < 3)].mean()\nsdev = amount_no_fraud[(np.abs(stats.zscore(amount_no_fraud)) < 3)].std()\nleft = middle - sdev\nright = middle + sdev\nax.set_title(\"No Fraud:Amount\")\nax.vlines(middle, 0, np.interp(middle, xs, ys), color='blue', ls=':')\nax.fill_between(xs, 0, ys, facecolor='blue', alpha=0.2)\nax.fill_between(xs, 0, ys, where=(left <= xs) & (xs <= right), interpolate=True, facecolor='blue', alpha=0.2)","2e47bbde":"X= df.iloc[:,1:30]\ny= df.iloc[:,30]","03aea643":"columns = X.columns\nx = X.values \nmin_max_scaler = preprocessing.MinMaxScaler()\nx_scaled = min_max_scaler.fit_transform(x)\nX = pd.DataFrame(x_scaled)\nX.columns = columns","65c168fb":"X_train , X_test , y_train , y_test = train_test_split(X,y , test_size=0.8, random_state=0)","a79e1214":"X_train , X_val , y_train , y_val = train_test_split(X_train,y_train , test_size=0.3, random_state=42)","76b55f5f":"X_train","457201cd":"print(y_train.value_counts()[0]\/y_train.value_counts()[1])","6580eea0":"print(y_val.value_counts()[0]\/y_val.value_counts()[1])","bfc75c47":"X_train, y_train = shuffle(X_train, y_train, random_state=0)\n","5f53cc82":"def build_model(hp):  \n    #model structure\n    model = keras.Sequential()\n    \n    model.add(layers.Dense(\n        units=hp.Int('dense_1_units', min_value=16, max_value=128, step=16),\n        activation=\"sigmoid\",\n        input_dim = 29\n    )),\n\n    model.add(layers.Dense(\n        units=hp.Int('dense_2_units', min_value=16, max_value=128, step=16),\n        activation=\"sigmoid\"\n    )),\n    \n    model.add(layers.Dense(\n        units=hp.Int('dense_3_units', min_value=16, max_value=128, step=16),\n        activation=\"sigmoid\"\n    )),\n    \n    \n    model.add(layers.Dense(\n        units=1,\n        activation=\"sigmoid\" \n    )),\n    \n    \n    AUPRC = AUC(curve = \"PR\")\n  \n    model.compile(optimizer=keras.optimizers.Adam(hp.Choice('learning_rate', values=[1e-2,1e-3])),\n              loss='binary_crossentropy',\n              metrics=['accuracy',AUPRC])\n  \n    return model","59d9c11c":"class_weight = {1:562,0:1}\ntuner_search = RandomSearch(build_model,objective=keras_tuner.Objective(\"val_auc\", direction=\"max\")\n                            ,max_trials=5,distribution_strategy=strategy,directory=\"output\")\ntuner_search.search(X_train,y_train,epochs=20,validation_split=0.3,batch_size=32,validation_data=(X_val,y_val),callbacks = [ReduceLROnPlateau()],class_weight=class_weight)","e8121a1a":"best_hps=tuner_search.get_best_hyperparameters(num_trials=1)[0]\nprint(\"Best params:\\n\")\nprint('dense_1_units'+\":\"+str(best_hps.get('dense_1_units')))\nprint('dense_2_units'+\":\"+str(best_hps.get('dense_2_units')))\nprint('dense_3_units'+\":\"+str(best_hps.get('dense_3_units')))\nprint('learning_rate'+\":\"+str(best_hps.get('learning_rate')))","090952cc":"model = tuner_search.hypermodel.build(best_hps)\nhistory = model.fit(X_train,y_train,epochs=20,validation_data=(X_val,y_val),class_weight=class_weight)","ebf088e2":"val_acc_per_epoch = history.history['val_auc']\nbest_epoch = val_acc_per_epoch.index(max(val_acc_per_epoch)) + 1\nprint('Best epoch: %d' % (best_epoch,))","b429478f":"hypermodel = tuner_search.hypermodel.build(best_hps)\nhypermodel.fit(X_train,y_train,epochs=best_epoch,validation_data=(X_val,y_val),class_weight=class_weight)","a93c0932":"X_test","41d56c73":"y_prob = hypermodel.predict(X_test)\nprint(\"Percision-Recall Curve:\\n\")\np, r, t = precision_recall_curve(y_test, y_prob,pos_label=1)\nf1 = 2*p[:-1]*r[:-1]\/(r[:-1]+p[:-1])\nplt.plot(t, p[:-1], 'r-', label='Precision')\nplt.plot(t, r[:-1], 'b-', label='Recall')\nplt.plot(t, f1, 'g-', label='F1')\nplt.legend(loc='center left')\nplt.xlabel('Threshold')","0de13af8":"y_pred = []\n    \nfor i in y_prob:\n    if i>0.91:\n        y_pred.append(1)\n    else:\n        y_pred.append(0)\nconfusion_matrix_array = confusion_matrix(y_test,y_pred,normalize='true')\n    \nprint(\"Report:\")\nprint(classification_report(y_test, y_pred,\ntarget_names=[\"Not Fraud\",\"Fraud\"]))\n\nsns.heatmap(confusion_matrix_array, annot=True)\n\nprint(\"\\nAUPRC: \",average_precision_score(y_test, y_prob),\"\\n\")\n","e425ac8c":"**Train\/Test Split**","e3178a7f":"**Taking sample of non fraud dataframe in order to have a balanced visualization**","54de35b6":"**Fraud to non fraud ratio in traning and validation datasets**","8ced5bee":"**running keras model tuner**","77c95c18":"**Using the train data sets to create a validiation data set**","23455247":"# 5.Evaluation","f2ec69b3":"**Evaluating model with threshold of 0.91**","7f6b4873":"**Since we dont what most features are, visualizing the wont make any sence**","cb85958e":"**Creating to dataframes of all fruad and non fraud datas**","a84bd3b7":"**Recreating the best model**","f99fe55a":"We didnt use resampling, so now we use class weights to solve imbalanced data problem","0716f772":"**Shufling training dataset data**","e5a12293":"# 1.Loading the data","2b0418fe":"# Setting up TPU","5048b54d":"# 3.Preproccesing","f9abf60a":"**Scaling data between 0 and 1**\n","250dcbdb":"# 2.Visualization","7e068425":"**Model structure for keras tuner**","792dcd65":"# 4.Creating Model\n"}}