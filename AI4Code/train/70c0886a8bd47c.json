{"cell_type":{"61bc85fb":"code","1135e1ff":"code","0d6589ef":"code","c613c535":"code","8aa27e58":"code","49721c91":"code","54a7e0ac":"code","2a3d0ff9":"code","fbfa0e33":"code","a305c8d2":"code","44fa5b2f":"code","0708148e":"code","e014c4fb":"code","2b5fe006":"code","f300517d":"code","94e7a84c":"code","05c3a2b9":"code","9fd4068b":"code","47265e4d":"code","2f4ce906":"code","54c66636":"code","62bf60a4":"code","7300dde9":"code","d93b01f8":"code","c1661274":"code","cffc7c9e":"code","07c75075":"code","e5afd77a":"code","66e63617":"code","b42eb02c":"code","e444f5b5":"code","ac9761aa":"code","6c55e3f1":"code","fc84e7b4":"code","0e63d085":"code","ed3339c5":"code","faeb13f4":"code","09bbb7ba":"code","12435c5f":"code","cb387b35":"markdown","2f5d3986":"markdown","96c437d1":"markdown","84be9b86":"markdown","29bc73c9":"markdown","268f5f17":"markdown","3c653140":"markdown","56fb4df0":"markdown","f89c47b8":"markdown","d48a1043":"markdown","7efc3c1d":"markdown","d64255eb":"markdown","5550f906":"markdown","7ead28b9":"markdown"},"source":{"61bc85fb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","1135e1ff":"pip install git+https:\/\/github.com\/csgroen\/scycle.git#egg=scycle","0d6589ef":"import time\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.decomposition import TruncatedSVD\nimport umap\n","c613c535":"l = os.listdir('\/kaggle\/input\/singlecell-rnaseq-exposed-to-multiple-compounds\/')\nl\nl = list( filter(lambda x: 'sciPlex2' in x, l ) )\nprint(l)\n'''\n['GSM4150377_sciPlex2_A549_Transcription_Modulators_UMI.count.matrix',\n 'GSM4150377_sciPlex2_hashSampleSheet.txt',\n 'GSM4150377_sciPlex2_A549_Transcription_Modulators_hashTable.out.txt',\n 'GSM4150377_sciPlex2_A549_Transcription_Modulators_cell.annotations.txt',\n 'GSM4150377_sciPlex2_A549_Transcription_Modulators_gene.annotations.txt',\n 'GSM4150377_sciPlex2_pData.txt']\n'''\ndirname =  '\/kaggle\/input\/singlecell-rnaseq-exposed-to-multiple-compounds\/'\nll = list( filter(lambda x: 'gene.annotations' in x, l ) )\nprint(ll)\ngenes = pd.read_csv(dirname + ll[0], sep = '\\t', header = None)\n\ndisplay(genes)\nll = list( filter(lambda x: 'cell.annotations' in x, l ) )\nprint(ll)\ncells = pd.read_csv(dirname + ll[0], sep = '\\t', header = None)\ndisplay(cells)\n\nll = list( filter(lambda x: 'hashTable' in x, l ) )\nprint(ll)\ninfo_dict_cells2drugs = pd.read_csv(dirname + ll[0],sep = '\\t', header = None)\ndisplay(info_dict_cells2drugs)\ns = set(cells[0]) & set( info_dict_cells2drugs[1] ) \nprint( len(s), len(cells) )\n\nll = list( filter(lambda x: 'hashSampleSheet' in x, l ) )\nprint(ll)\nhashSampleSheet = pd.read_csv(dirname + ll[0],sep = '\\t', header = None)\ndisplay(hashSampleSheet)\n\nll = list( filter(lambda x: 'pData' in x, l ) )\nprint(ll)\npData = pd.read_csv(dirname + ll[0],sep = ' ')# , header = None)\ndisplay(pData)\n\n\n","8aa27e58":"print()\nt0 = time.time()\nll = list( filter(lambda x: 'count.matrix' in x, l ) )\nexpression_matrix_in_sparse_form = pd.read_csv( dirname + ll[0], sep = '\\t', header = None)\nprint(np.round(time.time() - t0,2),'seconds passed' )\nprint('Each row in file has format - (i,j, value) - that means that count_matrix[i,j]=value')\nexpression_matrix_in_sparse_form[0] -= 1\nexpression_matrix_in_sparse_form[1] -= 1\ndisplay(expression_matrix_in_sparse_form)\n\nfrom scipy.sparse import csr_matrix\nm = csr_matrix((expression_matrix_in_sparse_form[2].values, (expression_matrix_in_sparse_form[0].values, \n                     expression_matrix_in_sparse_form[1].values))) # , shape=(len(genes), len(cells) ))#.toarray()\n\nprint(m.shape)\n","49721c91":"m.shape\nm = m.transpose()\nm.shape","54a7e0ac":"pData.head(2)","2a3d0ff9":"df = pd.DataFrame(index = pData.index, data = range(len(pData) ), columns = ['i'] )\ndf['n.umi'] = pData['n.umi']\ndf['Size_Factor'] = pData['Size_Factor']\n\nf = lambda x: x if not isinstance(x, str)  else x.split('_')[0]\ndf['drug'] = pData['top_oligo'].apply(f )\nf = lambda x: x if not isinstance(x, str)  else float(x.split('_')[1])\ndf['dose'] = pData['top_oligo'].apply(f )\nprint(np.sort( df['dose'].unique()), df['dose'].isnull().sum() )\nprint(( df['dose'].value_counts()) )\n\n\nm2 = m != 0\ndf['count genes expressed'] = np.array( m2.sum(axis = 1) ).ravel()\n\nl = np.array( [ x.startswith('MT-')  for x in genes[1]], dtype = bool )\nmask_MT_genes = l\nprint('Count mitochondrial genes:', l.sum(), ' out of: ', len(genes) )\nmt_expression_sum = np.array(m[:,mask_MT_genes].sum(axis=1)).ravel()\nnon_mt_expression_sum = np.array( m[:,~mask_MT_genes].sum(axis=1)).ravel()\nratio_mt2non_mt = (1+mt_expression_sum)\/(1+non_mt_expression_sum)\ndf['ratio mt2non_mt'] = ratio_mt2non_mt\n\n\ndf","fbfa0e33":"df.describe()","a305c8d2":"# Consistency check. Check that 'n_umi' is exactly the m.sum(axis = 1)\n(m.sum(axis = 1).ravel() != df['n.umi'].values ).sum()","44fa5b2f":"df['drug'].fillna('NAN',inplace = True)\ndf['dose'].fillna('NAN',inplace = True)\ndf.groupby( ['drug','dose'])['dose'].count()","0708148e":"if 1:\n    m2 = m.copy()\n    m2.data = np.log(1+m2.data)\n    m2 = m2.multiply( 1\/m2.sum(axis=1))\n    m2 = m2.tocsr()\n    str_preproc = 'LogThenNorm'\nelse:\n    m2 = m.multiply( 1\/m.sum(axis=1))\n    m2 = m2.tocsr()\n    m2.data = np.log(1+m2.data)\n    str_preproc = 'NormThenLog'\n\nprint(str_preproc)#  \nprint(m2[:4,:4].toarray())\nprint(m2.sum(axis = 1)[:4])","e014c4fb":"genes_save = genes.copy()\nm_save = m.copy()\nm2_save = m2.copy()\ndf_save = df.copy()","2b5fe006":"import seaborn  as sns\nfrom sklearn.decomposition import TruncatedSVD\nimport time\nimport umap\n\nreducer = umap.UMAP(random_state=42)\nstr_reducer = 'UMAP'\n#reducer = ncvis.NCVis()\n#reducer =  trimap.TRIMAP()\nsvd = TruncatedSVD( n_components=50, n_iter=7, random_state=42)\n\n\nv = np.asarray(m2.sum(axis=0)).ravel()\nIX = np.argsort(v )\n\nt00 = time.time()\nfor count_made_zeros in [10]: # range(10,100,10):\n\n    m3 = m2.copy()#  != 0 # \n    if count_made_zeros != 0:\n        #m3[:,IX[-count_made_zeros:]] = 0\n        m3 = m3[:,IX[:-count_made_zeros]] # droping columns - same as make them zeros , but does not create memory alloc prob\n\n\n    t0 = time.time()\n    r = svd.fit_transform(m3)\n    print(time.time() - t0, 'seconds passed on svd')\n    t0 = time.time()\n    r = reducer.fit_transform(r)\n    print(time.time() - t0, 'seconds passed on ', str_reducer)\n    \n    fig = plt.figure(figsize = (20,12))\n    c = 0; \n\n    c+=1; fig.add_subplot(1, 2 , c)         \n    color_by = df['drug'].copy()\n    sns.scatterplot(x=r[:,0],y=r[:,1],   hue= color_by, alpha = 0.7, marker = '.')\n    plt.title(str_reducer + '.  Color by drug. count_made_zeros='  +str( count_made_zeros ) + ' Non binarized' )\n\n    c+=1; fig.add_subplot(1, 2 , c)         \n    color_by = df['dose'].copy()\n    color_by[color_by == 'NAN'] = -1\n    color_by = color_by.astype(float)\n    color_by = np.log10(2+color_by)\n    sns.scatterplot(x=r[:,0],y=r[:,1],   hue= color_by, alpha = 0.7, marker = '.')\n    plt.title(str_reducer + ' Color by log10 of dose. count_made_zeros='  +str( count_made_zeros )+ ' Non binarized' )\n    plt.show()\n    \n    print(time.time() - t0, 'seconds passed')\n\nprint('Finished.', time.time() - t00, 'seconds passed total ')    ","f300517d":"mask1 = r[:,0] > 0  # drop out douplets clearly seen on umap image\n(~mask1).sum()","94e7a84c":"df = df.iloc[mask1,:]\nm = m[mask1,:]\nm2 = m2[mask1,:]\ndf.shape, m.shape,m2.shape","05c3a2b9":"v = np.asarray((m!=0).sum(axis = 0)).ravel()\nplt.plot(np.sort(v),'*-')\nplt.show()\npd.Series(v).describe()\n","9fd4068b":"v = np.asarray((m!=0).sum(axis = 0)).ravel()\nmask2 = v >= 3\nprint(mask2.sum() )\n","47265e4d":"genes = genes[mask2]\nm = m[:,mask2]\nm2 = m2[:,mask2]\ndf.shape, m.shape,m2.shape","2f4ce906":"v = (m!=0).sum(axis = 1)\nv = np.asarray(v).ravel()\nprint( pd.Series(v).describe() )\n\n# so we see that each cell has from 508 (321 if no fileter douplets) to 10488 genes expressed, so we can omit droping out cells \n# cell which has expression less than 200 genes \nplt.plot(np.sort(v),'*-')\nplt.show()\nnp.sort(v)[:10] # First two cell might seem as slight outliers ","54c66636":"# Show that expression and variance are both growing \n\nt = m2.copy()\nt.data **= 2#.toarray()\n#print( t.toarray() )\nX_var = np.array(t.mean(axis = 0 )).ravel() - np.array(m2.mean(axis = 0) ).ravel()**2  \n\ngenes['Variance'] = X_var\nplt.plot( np.sort( (  genes['Variance'].values) ))\n\ngenes['Expression Sum'] = np.asarray(m2.sum(axis = 0)).ravel()\n\ng2 = genes.sort_values('Expression Sum')\ng2 = genes.sort_values('Variance')\n\nplt.plot(np.log10(1+ g2['Expression Sum'].values) )\n# plt.plot(g2['Variance'].values)\nplt.show()\nplt.plot(np.log10(1+ g2['Variance'].values) )\nplt.show()","62bf60a4":"t = m2.copy()\nt.data **= 2#.toarray()\n#print( t.toarray() )\nX_var = np.array(t.mean(axis = 0 )).ravel() - np.array(m2.mean(axis = 0) ).ravel()**2  \nIX = np.argsort(X_var)\nIX = IX[-10000:]\n","7300dde9":"m = m[:,IX]\nm2 = m2[:,IX]\ngenes = genes.iloc[IX,:]\n\ngenes.shape, m2.shape, m.shape","d93b01f8":"if 0:\n    import seaborn  as sns\n    from sklearn.decomposition import TruncatedSVD\n    import time\n    import umap\n\n    reducer = umap.UMAP(random_state=42)\n    str_reducer = 'UMAP'\n    #reducer = ncvis.NCVis()\n    #reducer =  trimap.TRIMAP()\n    svd = TruncatedSVD( n_components=50, n_iter=7, random_state=42)\n\n\n    v = np.asarray(m2.sum(axis=0)).ravel()\n    IX = np.argsort(v )\n\n    t00 = time.time()\n    for count_made_zeros in [10]: # range(10,100,10):\n\n        m3 = m2.copy()#  != 0 # \n        if count_made_zeros != 0:\n            #m3[:,IX[-count_made_zeros:]] = 0\n            m3 = m3[:,IX[:-count_made_zeros]] # droping columns - same as make them zeros , but does not create memory alloc prob\n\n\n        t0 = time.time()\n        r = svd.fit_transform(m3)\n        print(time.time() - t0, 'seconds passed on svd')\n        t0 = time.time()\n        r = reducer.fit_transform(r)\n        print(time.time() - t0, 'seconds passed on ', str_reducer)\n\n        fig = plt.figure(figsize = (20,12))\n        c = 0; \n\n        c+=1; fig.add_subplot(1, 2 , c)         \n        color_by = df['drug'].copy()\n        sns.scatterplot(x=r[:,0],y=r[:,1],   hue= color_by, alpha = 0.7, marker = '.')\n        plt.title(str_reducer + '.  Color by drug. count_made_zeros='  +str( count_made_zeros ) + ' Non binarized' )\n\n        c+=1; fig.add_subplot(1, 2 , c)         \n        color_by = df['dose'].copy()\n        color_by[color_by == 'NAN'] = -1\n        color_by = color_by.astype(float)\n        color_by = np.log10(2+color_by)\n        sns.scatterplot(x=r[:,0],y=r[:,1],   hue= color_by, alpha = 0.7, marker = '.')\n        plt.title(str_reducer + ' Color by log10 of dose. count_made_zeros='  +str( count_made_zeros )+ ' Non binarized' )\n        plt.show()\n\n        print(time.time() - t0, 'seconds passed')\n\n    print('Finished.', time.time() - t00, 'seconds passed total ')    ","c1661274":"IX = np.where( genes[1] =='MALAT1' ) [0] \nprint( genes.iloc[IX,:] )\n\nIX = np.where( genes[0] =='ENSG00000278217.1' )[0][0]\ngenes[1].iat[IX] = 'MALAT1_AP000769' # This gene in somehow related (part of?) to MALAT1 -  \n# see e.g. http:\/\/www.ensembl.org\/Homo_sapiens\/Gene\/Summary?db=core;g=ENSG00000278217;r=11:65502914-65503008;t=ENST00000618249\n# But to avoid name duplicates we rename it differently from existing MALAT1 - ENSG00000251562.7","cffc7c9e":"# genes.groupby(1)[1].count().sort_values(ascending = False) # Way to find duplicating symbols \ngenes[1].nunique(), genes.shape","07c75075":"import anndata as ad\nimport scanpy as sc\n","e5afd77a":"print( genes.shape,m2.shape,m.shape, df.shape )\ndf.head(1)\nobs = df.copy() # \ndisplay(obs.head(2))\ndisplay(genes.head(1))\nvar = genes.reset_index().set_index(1) # Create \"var\" dataframe for anndat\nvar.columns = ['Old Index','Ensemble Id', 'Variance', 'Expression Sum']\nvar.index.name = 'Gene'\ndisplay(var.head(2))\nadata = ad.AnnData( m2.toarray(), obs=obs, var=var ) # memory consumed less than 1G\nif 0: # Examples \n    adata.obs['cell_groups'] = anno['cell_groups']  # categorical annotation of type pandas.Categorical\n    adata.obs['time'] = anno['time']                # numerical annotation of type float\n    # alternatively, you could also set the whole dataframe\n    # adata.obs = anno\n\nadata \n","66e63617":"adata","b42eb02c":"if 1:\n    adata = adata[:,:5000]\n    adata.shape","e444f5b5":"adata.obs.head(2)","ac9761aa":"if 0:\n    mask = (adata.obs.dose == 0)  | (adata.obs.dose == 0.1)  \n    print( mask.sum() )\n    adata = adata[mask,:]\n    adata\n","6c55e3f1":"adata.shape","fc84e7b4":"import scycle as cc\n","0e63d085":"adata_9 = adata\n## Computing a cell cycle trajectory estimation on a dataset copy\n#cc.pp.filter_cells(adata_9, max_counts=50000)\ncc.pp.prep_pooling(adata_9)\ncc.tl.dimensionality_reduction(adata_9, method=\"ica\")\ncc.tl.enrich_components(adata_9, verbose=True)","ed3339c5":"adata","faeb13f4":"adata.obs['G1-S']","09bbb7ba":"\ncc.tl.principal_circle(adata_9)\ncc.tl.celldiv_moment(adata_9)\ncc.tl.remap_nodes(adata_9)\ncc.tl.pseudotime(adata_9)\ncc.tl.curvature(adata_9)","12435c5f":"cc.pl.scatter_projection(adata_9, trajectory=True)\n","cb387b35":"# Create columns with information on each cell (drug, dose, etc)","2f5d3986":"# Normalization and log","96c437d1":"# Save copies ","84be9b86":"# Filter genes by variance - just take 10 000 \n\n\nin our case filtering by variance is more or less the same as by expression sum ","29bc73c9":"# What is about \n\nHere we analyse sciPlex2 subdataset. We consider filering out genes and cells and checking that result of umap image does not change significantly. So such filterings are Okay. \n\nFirst filter out douplets cells which are seen by umap - about 3200 cells.\n\nSecond filter out genes expressed in less than 3 cells - get 35600+ from 58437 \n\nNo need to filter out cells further since - all cells have more than 200 genes expressed. \n\nThird we look on how many top variable \/ top expressed genes we can leave.\nAt the begeninng we check that both conditions are more or less the same,\nthen we check that leaving 10 000, 5 000, 1 000, 500 genes does not change umap image significantly. \nThat means we can expect  that keeping those  number of genes is relatively safe. \nOnly leaving 100 genes leads to visible change. \n\n\nFourth we check intersection of top genes with cell cycle phase markers: top 1000 genes intersects very little - 1,2 markers.\nSo from that perspective it is better to keep more genes. \n\nPrecise numbers: \n\nKeep 10 000 genes  - get  31, 48 out of 43,54 cell cycle phase markers for phases (S and G2M respectively)  \n \nFor 8 000 - 31, 48\n\nFor 5 000 - 11, 24\n\n\n------------------\n\n#### Dataset reminder:\n\nIt is the second \"toy\" subdataset, while sciPlex3 is the main very huge subdataset.\n\nHere - only one cell line - A549 - human lung adenocarcinoma.\n\nExposed to 4 different compounds DEXA, nutlin, BMS, SAHA (HDAC).\n\n24 hours across SEVEN doses. \n\n24262 cells x 58347 genes\n\n\n'GSM4150377_sciPlex2_pData.txt' - contains information on: cell+drugs+doses+etc... There are 24262 rows - one row - one cell.\nThe index (=row number) of cell in that file corresponds to its index in the countmatrix (after transforming csv file with count matrix to sparse countmatrix)\n\nCount matrix (in list of edges format), cell ids, genes ids are in the files (respectively):\n'GSM4150377_sciPlex2_A549_Transcription_Modulators_UMI.count.matrix',\n 'GSM4150377_sciPlex2_A549_Transcription_Modulators_cell.annotations.txt',\n 'GSM4150377_sciPlex2_A549_Transcription_Modulators_gene.annotations.txt',\n \n ","268f5f17":"# Filter genes which are expressed in less than 3 cells ","3c653140":"# Visulization check ","56fb4df0":"# No cells with less than 200 genes expressed - no need to filter ","f89c47b8":"# Load information files: genes annotations, cells info etc...","d48a1043":"# Avoid duplicating symbols \n","7efc3c1d":"# Load count matrix and convert it to sparse matrix csr_matrix","d64255eb":"# Visualization - we will see douplets and later filter them out","5550f906":"# Filter douplets ","7ead28b9":"# Create adata object \n\nit is like a dataframe - but both columns-header and \"index\" - are dataframe - intended to store much more information\n\nSo:\n\n\"var\" - analogue of \"df.columns\"- so various info on genes in our case\n\n\"obs\" - observations - analogue \"df.index\" -  so information on cells in our case \n\n"}}