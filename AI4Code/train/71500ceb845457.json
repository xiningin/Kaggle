{"cell_type":{"b92a551f":"code","ee6f3201":"code","6add9743":"code","5fc41d49":"code","f042ba2f":"code","3e1bd8a1":"code","1bcc370b":"code","2db981f1":"code","ff61bb7a":"code","01ba57e7":"code","8ce620f5":"code","60f7ea71":"code","4ba17a6b":"code","4de8624e":"code","85a3b1d2":"code","c825a949":"code","74c5c2cc":"code","4f1ebc3d":"code","062aa251":"code","869c88ca":"code","9da58bf2":"code","cb3a3c6f":"code","9f581a3b":"code","894df88e":"code","ec645aa7":"code","96365b9b":"code","6526fba1":"code","5af103d4":"code","9962e4f6":"code","eb2393c2":"markdown","55e36164":"markdown","af09a5bc":"markdown","1b776c8d":"markdown","d650f775":"markdown","15acbec8":"markdown"},"source":{"b92a551f":"import numpy as np\nimport pandas as pd\nimport os\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport random\n\n# keras\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense, Activation, BatchNormalization\nfrom keras.optimizers import Adam\nfrom keras.losses import SparseCategoricalCrossentropy\nfrom keras.preprocessing.image import ImageDataGenerator\n\n# sklearn library\nfrom sklearn.preprocessing import StandardScaler \nfrom sklearn.model_selection import train_test_split \nfrom sklearn.metrics import classification_report ","ee6f3201":"# unzipping data files\n\n! unzip \"..\/input\/dogs-vs-cats-redux-kernels-edition\/train.zip\" -d train\n! unzip \"..\/input\/dogs-vs-cats-redux-kernels-edition\/test.zip\" -d test","6add9743":"# creating dataframe\n\n# labels\nfile = os.listdir(\".\/train\/train\")\nLabels = list(map(lambda x: x.split('.')[0], file))\n\n# for filenames\nf = Path(\".\/train\/train\")\nFile_Path = list(f.glob(r\"**\/*.jpg\"))\n\n# dataframe\nFile_Path = pd.Series(File_Path).astype(str)\nLabels = pd.Series(Labels)\ndf = pd.concat([File_Path,Labels],axis=1)\ndf.columns = ['filename', 'category']","5fc41d49":"df.head()","f042ba2f":"# ensuring data isn't biased\n\ndf['category'].value_counts().plot.bar(color=['green', 'orange']);","3e1bd8a1":"# Viewing dataframe images\n\nfig, axes = plt.subplots(nrows=3,ncols=3, figsize=(7, 7),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\n# iterating over images\nfor name, ax, in enumerate(axes.flatten()):\n    ax.imshow(plt.imread(df.filename[name]))   # reading images\n    ax.set_title(df.category[name])            #labelling images\n\nplt.tight_layout()\nplt.show()","1bcc370b":"# splitting the dataset\n# specified random state for split to give same output\n\ntrain_set, test_data = train_test_split(df, test_size= 0.2, random_state = 42)\ntrain_data, val_data = train_test_split(train_set, test_size= 0.2, random_state = 42)\n\n\nprint(train_data.shape)\nprint(test_data.shape)\nprint(val_data.shape)","2db981f1":"# resetting index\n\ntrain_data = train_data.reset_index(drop=True)\ntest_data = test_data.reset_index(drop=True)\nval_data = val_data.reset_index(drop=True)","ff61bb7a":"img_size = (128, 128)\ninput_shape = (128, 128, 3)","01ba57e7":"# image Generator\n\nimg_gen = ImageDataGenerator(    \n    rotation_range=10,\n    rescale=1.\/255,\n    horizontal_flip=True,\n)","8ce620f5":"# example generator\n\nexample_data = train_data.sample(n=1).reset_index(drop=True)\n\nexample_gen = img_gen.flow_from_dataframe(\n    dataframe = example_data,\n    x_col = 'filename', #name of the column containing the image in the test set\n    y_col ='category', #name of column containing the target in the test set\n    target_size = img_size,\n    class_mode ='categorical',\n    batch_size = 32,\n    shuffle = False # not to shuffle the given data\n)\n\nfor i in range(1, 10):\n    plt.subplot(3, 3, i)\n    for X_batch, Y_batch in example_gen:\n        image = X_batch[0]\n        plt.imshow(image)\n        plt.axis('Off')\n        break\n\nplt.tight_layout()  # for auto padding \nplt.show()","60f7ea71":"# training generator\ntrain_gen = img_gen.flow_from_dataframe(\n    train_data, \n    x_col='filename',\n    y_col='category',\n    target_size=img_size,\n    class_mode='categorical',\n    batch_size=32,\n    shuffle = False\n)\n\n# validation generator\nvalidation_gen = img_gen.flow_from_dataframe(\n    val_data, \n    x_col='filename',\n    y_col='category',\n    target_size=img_size,\n    class_mode='categorical',\n    batch_size=32,\n    shuffle = False\n)","4ba17a6b":"# creating model\nmodel = Sequential()\n\n# Adding layers\n\n# input layer\nmodel.add(Conv2D(32, (3, 3), activation='relu', strides=(1, 1),input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\n#flatten layer\nmodel.add(Flatten())\n\n# dense layers with dropout\nmodel.add(Dense(128, activation = 'relu'))\nmodel.add(Dropout(rate = 0.3))\nmodel.add(Dense(64, activation = 'relu'))\n\n#output layer\nmodel.add(Dense(2, activation='softmax'))","4de8624e":"# creating model\nmodel = Sequential()\n\n# Adding layers\n\n# input layer\nmodel.add(Conv2D(32, (3, 3), activation='relu', strides=(1, 1),input_shape=input_shape))\n\nmodel.add(BatchNormalization())\n\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.25))\nmodel.add(Conv2D(64, (3, 3), activation='relu'))\n\n\nmodel.add(BatchNormalization())\n\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.25))\nmodel.add(Conv2D(128, (3, 3), activation='relu'))\n\nmodel.add(BatchNormalization())\n\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.25))\nmodel.add(Flatten())\nmodel.add(Dense(512, activation='relu'))\n\nmodel.add(BatchNormalization())\n\nmodel.add(Dropout(0.5))\n# output layer\nmodel.add(Dense(2, activation='softmax'))","85a3b1d2":"model.summary()","c825a949":"# compile model\nmodel.compile(optimizer='adam',\n              loss=\"categorical_crossentropy\", \n              metrics=['accuracy'])","74c5c2cc":"# preventing overfitting\n\nfrom keras.callbacks import EarlyStopping, ReduceLROnPlateau\n\nlearning_rate_reduction = ReduceLROnPlateau(monitor='val_accuracy', \n                                            patience=2, \n                                            verbose=1, \n                                            factor=0.5, \n                                            min_lr=0.00001)\n\nearlystop = EarlyStopping(patience=10)","4f1ebc3d":"# fitting model\n\nhistory = model.fit(train_gen,\n                    validation_data = validation_gen,\n                    epochs = 20,\n                    verbose=1, #for animated bar during epoch\n                    callbacks = [earlystop, learning_rate_reduction])","062aa251":"# Loss vs Accuracy\n\n#accuracy\nacc = history.history['accuracy']\nval_acc = history.history['val_accuracy']\n\n#loss\nloss = history.history['loss'] \nval_loss = history.history['val_loss']","869c88ca":"plt.figure(figsize=(10, 5))\n\n# visualising Accuracy \nplt.subplot(2, 1, 1)\n\nplt.plot(acc, label='Training Accuracy')\nplt.plot(val_acc, label='Validation Accuracy')\n\nplt.ylabel('Accuracy') \nplt.title('Training and Validation Accuracy') \n\n# Visualising Loss\nplt.subplot(2, 1, 2)\n\nplt.plot(loss, label='Training Loss')\nplt.plot(val_loss, label='Validation Loss')\n\nplt.ylabel('Loss')\nplt.title('Training and Validation Loss')\n\nlegend = plt.legend()\nplt.show()\n","9da58bf2":"# checking accuracy on the test data we left aside\n\ntest_gen = img_gen.flow_from_dataframe(\n    test_data, \n    x_col='filename',\n    y_col='category',\n    target_size=img_size,\n    class_mode='categorical',\n    batch_size=32,\n    shuffle = False\n)","cb3a3c6f":"# Predict the label of the test_images\npred = model.predict(test_gen)\npred = np.argmax(pred,axis = 1) # pick the class with highest probability\n\n# labelling data\nlabels = (train_gen.class_indices)\nlabels = dict((v,k) for k,v in labels.items())\npred2 = [labels[k] for k in pred]\n\n# expected output\ny_test = test_data.category\n\n# model accuracy\nprint(classification_report(y_test, pred2))","9f581a3b":"# Display 15 picture of the dataset with their labels --> EXTRAS\n\nfig, axes = plt.subplots(nrows=3, ncols=5, figsize=(15, 10),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\ncolor = \"blue\" if pred2[i] == test_data.category.iloc[i] else \"red\"\nfor i, ax ,in enumerate(axes.flat):\n    ax.imshow(plt.imread(test_data.filename.iloc[i]))\n    ax.set_title(f\"True: {test_data.category.iloc[i]}\\nPredicted: {pred2[i]}\",color=color)\n    \nplt.subplots_adjust(hspace = 0.3)\nplt.suptitle(\"Model predictions (blue: correct, red: incorrect)\",y=0.98)\nplt.tight_layout()\nplt.show()","894df88e":"test_filenames = os.listdir(\".\/test\/test\")\ntest_df = pd.DataFrame({\n    'filename': test_filenames\n})","ec645aa7":"# checking accuracy on the test data we left aside\n\ntest_gen = img_gen.flow_from_dataframe(\n    test_df, \n    \".\/test\/test\",\n    x_col='filename',\n    y_col=None,\n    target_size=img_size,\n    class_mode=None,\n    batch_size=32,\n    shuffle = False # not to shuffle the given data\n)","96365b9b":"# Predict the label of the test_images\npred = model.predict(test_gen)\npred = np.argmax(pred,axis = 1) # pick the class with highest probability\n\n# labelling data\nlabels = (train_gen.class_indices)\nlabels = dict((v,k) for k,v in labels.items())\npred2 = [labels[k] for k in pred]","6526fba1":"label = np.zeros(len(pred2), dtype='int')\n\npred2 = np.array(pred2)\npred2=='cat'\n\nlabel[pred2=='cat']= 0\nlabel[pred2=='dog']= 1","5af103d4":"label = pd.Series(label)\nind = np.arange(1, len(pred2)+1)\nmy_submission = pd.DataFrame({'id':ind, 'label':label})\nmy_submission","9962e4f6":"my_submission.to_csv('submission.csv', index=False)","eb2393c2":"# Data Augmentation and Generators","55e36164":"# CNN Model","af09a5bc":"# Model Evaluation","1b776c8d":"**Refresh the contents of the output directory '\/kaggle\/working' to find the csv file******","d650f775":"# Submission","15acbec8":"# Pre-processig Data"}}