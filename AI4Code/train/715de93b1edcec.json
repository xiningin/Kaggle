{"cell_type":{"f504bdc9":"code","07791b96":"code","e10e901c":"code","a5904e1b":"code","5bc598ba":"code","3af88d57":"code","a442fbfe":"code","8e999941":"code","e4ac13df":"code","e46817b4":"code","6efcc157":"code","64abf167":"code","c31044e3":"markdown","ab069c45":"markdown","7cce030d":"markdown","a741a4c4":"markdown"},"source":{"f504bdc9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tensorflow as tf\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Activation, BatchNormalization\nfrom keras.callbacks.callbacks import History\nimport matplotlib.pyplot as plt\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#    for filename in filenames:\n#        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","07791b96":"WIDTH = 128\nHEIGHT = 128\nCHANNELS = 3\nbatch_size = 64;","e10e901c":"path_training= '..\/input\/cell-images-for-detecting-malaria\/Training\/'\npath_testing= '..\/input\/cell-images-for-detecting-malaria\/Testing\/'\n\ntraining_generator = ImageDataGenerator(validation_split=0.2,rescale=1.\/255)\nprint(\"Training: \")\nimages_training = training_generator.flow_from_directory(path_training, target_size=(WIDTH, HEIGHT), classes=['Parasitized','Uninfected'], subset='training', batch_size=batch_size)\nprint(\"Validation: \")\nimages_validation = training_generator.flow_from_directory(path_training, target_size=(WIDTH, HEIGHT), classes=['Parasitized','Uninfected'], subset = 'validation', batch_size=batch_size)\n\ntesting_generator = ImageDataGenerator(rescale=1.\/255)\nprint(\"Testing: \")\nimages_testing = testing_generator.flow_from_directory(path_testing,target_size=(WIDTH, HEIGHT), class_mode = None, batch_size=batch_size, shuffle=True)\nimages_testing_with_labels = testing_generator.flow_from_directory(path_testing,target_size=(WIDTH, HEIGHT), classes=['Parasitized','Uninfected'], batch_size=batch_size, shuffle=True)","a5904e1b":"model = Sequential()\n\nmodel.add(Conv2D(64, (3, 3), activation='relu', input_shape=(WIDTH, HEIGHT, CHANNELS))) \nmodel.add(Conv2D(64, (3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(64, (3, 3), activation='relu'))\nmodel.add(Conv2D(128, (3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(BatchNormalization())\n\nmodel.add(Conv2D(128, (3, 3), activation='relu'))\nmodel.add(Conv2D(128, (3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(128, (3, 3), activation='relu'))\nmodel.add(Conv2D(256, (3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(BatchNormalization())\n\nmodel.add(Flatten())\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dense(32, activation='relu'))\nmodel.add(Dense(2, activation='softmax'))\n\nmodel.compile(loss='binary_crossentropy', optimizer='Adam', metrics=['accuracy'])","5bc598ba":"history = History()\nepochs = 10\nresult = model.fit_generator(images_training, epochs=epochs, validation_data = images_validation, steps_per_epoch=len(images_training), validation_steps = len(images_validation), callbacks=[history])","3af88d57":"plt.plot(history.history['accuracy'], color='blue', label=\"Training accuracy\")\nplt.plot(history.history['val_accuracy'],color='red', label=\"Validation accuracy\")\nplt.xticks(np.arange(1,epochs,1))\nplt.legend(loc='best',shadow=True)\nplt.show()\n","a442fbfe":"result = model.evaluate_generator(images_testing_with_labels)","8e999941":"acc = result[1]*100\nacc = np.round(acc, decimals = 2)\nprint(\"Accuracy: \"+ str(acc)+'%')","e4ac13df":"x,y = images_testing_with_labels.next()\nlabels = y;\nsample = x;","e46817b4":"samples = model.predict_classes(sample)","6efcc157":"actual_labels = list()\nfor i in range(len(labels)):\n    if labels[i][0] == 0.0:\n        actual_labels.append(1)\n    else:\n        actual_labels.append(0)","64abf167":"\nfor i in range(32):\n    img  = sample[i]\n    pred = \"uninfected\"\n    actual = \"uninfected\"\n    if samples[i]==0:\n        pred = \"infected\"\n    if (actual_labels[i]==0):\n        actual = \"infected\"\n    plt.imshow(img)\n    plt.title(\"Predicted: \"+ pred+\", Actual: \"+ actual)\n    plt.show()","c31044e3":"# Creating the model","ab069c45":"# Training the model","7cce030d":"# Evaluating the model","a741a4c4":"# Sample predictions"}}