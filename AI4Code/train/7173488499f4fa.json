{"cell_type":{"a7baf59f":"code","0385906c":"code","d8266aa8":"code","4e2b1084":"code","ffb57d4b":"code","d3dd07cc":"code","e97fb9e4":"code","50165593":"code","35366039":"markdown","4a756158":"markdown","bd4de0a3":"markdown"},"source":{"a7baf59f":"import random as rand\nimport numpy.random as rand_2\nimport matplotlib.pyplot as plt","0385906c":"class TspAgent:\n    def __init__(self, cities_distances):\n        self.cities_distances = cities_distances\n      \n    \n    # Generating population randomly from population_size\n    def generate_population(self, population_size=4):\n        n = len(self.cities_distances)\n        chromosome = []\n        \n        # creating a single chromosome. Each unit in chromosome represents a city in form of number like city1 -> 0, city2 -> 1 etc. \n        for i in range(n):\n            chromosome.append(i)\n            \n        population = [chromosome.copy() for _ in range(population_size)]  \n        \n        for i in range(population_size):\n            individual_chromosome = population[i]\n            \n            # Swapping two random cities\/unit n times in each chromosome \n            for j in range(len(individual_chromosome)):   \n                rand_city_1 = rand.randrange(0, len(individual_chromosome))\n                rand_city_2 = rand.randrange(0, len(individual_chromosome))\n                \n                individual_chromosome[rand_city_1], individual_chromosome[rand_city_2] = individual_chromosome[rand_city_2], individual_chromosome[rand_city_1]\n\n        return population\n     \n        \n    # Calculate total distance in a chromosome\n    def calculate_total_distance(self, individual):\n        total_distance = 0\n        prev_city = individual[0] \n        \n        for city in individual[1:]:\n            if self.cities_distances[prev_city][city] is not None:  # As matrix provided is upper triangular matrix\n                total_distance = total_distance + self.cities_distances[prev_city][city]\n            else:\n                total_distance = total_distance + self.cities_distances[city][prev_city]\n            \n            prev_city = city\n        \n        return total_distance\n   \n\n    # calculate fitness of an individual chromosome, shorter the total distance the more bigger fitness value returned\n    def calculate_fitness(self, individual):\n        total_distance = self.calculate_total_distance(individual)\n            \n        return 1\/total_distance   # As our objective function is to minimize total distance thats why dividing a bigger total distance by 1 will make it a small fitness value\n    \n    \n    # Randomly select any individual from population by its selection probability\n    def select(self, population, calculate_fitness):\n        fitness_values = [calculate_fitness(individual) for individual in population]  # fitness values of population\n        sum_fitness = sum(fitness_values)  # sum of fitness values\n        selection_probs = [fitness_values[index]\/sum_fitness for index, individual in enumerate(population)]  # Array holding selection prob for each individual  selection_prob(of individual) = fitness_value(of individual) \/ sum_of_all_fitness_values\n#         print([(i, f, p) for i, f, p in zip(population, fitness_values, selection_probs)],'\\n')\n        population_indices = [ind for ind in range(len(population))]   # Indices of individual in population, necessary for numpy.random.choice as it requires a=1D array\n        selected_individual_index = rand_2.choice(population_indices, p=selection_probs)   # p is the selected_probs of corresponding individuals\n\n        return population[selected_individual_index] \n    \n    \n    # Reproduce a child using x and y chromosome by ordered 1 crossover\n    def reproduce(self, x, y):\n        n = len(x) \n        child = [None] * n   # Initializing child\n        \n        # step 1: Select a random subsequence from x\n        rand_index_1, rand_index_2 = rand.randrange(0, n), rand.randrange(0, n)\n        subseq_start, subseq_end = min(rand_index_1, rand_index_2), max(rand_index_1, rand_index_2)\n        \n        # step 2: Place that subsequence in relevant indices in child and mark out these in y\n        for i in range(subseq_start, subseq_end+1):\n            child[i] = x[i]\n\n        y_remaining = [city  for city in y  if city not in child]\n        none_indexes = [index  for index, city in enumerate(child)  if city is None]\n        \n        # step 3: Starting from right side grab the units of y and place them in child in empty positions starting from right side. Those units are skipped which are marked out\n        for i, city in zip(none_indexes, y_remaining):\n            if child[i] is None:\n                child[i] = city\n                \n        return child\n    \n    \n    # Mutate a child by randomly swapping two random cities\n    def mutate(self, child):\n        new_child = child.copy()\n        n = len(child)\n        rand_index_1, rand_index_2 = rand.randrange(0, n), rand.randrange(0, n)\n        new_child[rand_index_1], new_child[rand_index_2] = child[rand_index_2], child[rand_index_1]\n        return new_child        \n    \n    \n    # Perform genetic search\n    def genetic_search(self, population, calculate_fitness, generations=50):\n        \n        for _ in range(generations):   # repeat unitl any individual is fit enough or time limit (keeping track of generations here)\n            new_population = []\n            \n            for _ in range(len(population)):  \n                x = self.select(population, calculate_fitness)  \n                y = self.select(population, calculate_fitness)\n\n                child = self.reproduce(x, y)\n                if (rand.uniform(0,1) <= 0.1):  # Mutate child with probability 0.1\n                    child = self.mutate(child)\n                    \n                new_population.append(child)\n            \n            population = new_population\n                \n        return max(population, key=calculate_fitness)   # Returning the most fit individual with higher fitness value","d8266aa8":"cities_distances = [ [0,    60,   100, 510,   620,  40,   70,   80,   120,  650],\n                     [None, 0,    60,  130,   40,   80,   90,   90,   440,  540],\n                     [None, None, 0,   450,   450,  860,  910,  190,  10,   145],\n                     [None, None, None, 0,    70,   1500, 440,  220,  660,  250],\n                     [None, None, None, None, 0,    260,  160,  330,  120,  50 ],\n                     [None, None, None, None, None, 0,    370,  260,  350,  110],\n                     [None, None, None, None, None, None, 0,    50,   120,  270],\n                     [None, None, None, None, None, None, None, 0,    330,  990],\n                     [None, None, None, None, None, None, None, None, 0,    330],\n                     [None, None, None, None, None, None, None, None, None, 0  ]  ]","4e2b1084":"tsp = TspAgent(cities_distances)\np = tsp.generate_population(population_size=20)\nprint(p, '\\n')\nsol = tsp.genetic_search(population=p, calculate_fitness=tsp.calculate_fitness, generations=1000)\nprint(sol, tsp.calculate_total_distance(sol), tsp.calculate_fitness(sol))","ffb57d4b":"max_population_size = 20\ntsp = TspAgent(cities_distances)\npops = []\nsols_dists_1 = []\n\nfor population_size in range(2,max_population_size):\n        population = tsp.generate_population(population_size=population_size)\n        sol = tsp.genetic_search(population=population, calculate_fitness=tsp.calculate_fitness)\n        pops.append(population_size)\n        sols_dists_1.append(tsp.calculate_total_distance(sol))","d3dd07cc":"max_generations = 300\ntsp = TspAgent(cities_distances)\ngens = []\nsols_dists_2 = []\n\nfor generations in range(2,max_generations):\n    population = tsp.generate_population()\n    sol = tsp.genetic_search(population=population, calculate_fitness=tsp.calculate_fitness, generations=generations)\n    gens.append(generations)\n    sols_dists_2.append(tsp.calculate_total_distance(sol))","e97fb9e4":"plt.plot(pops, sols_dists_1)\nplt.xlabel('population size')\nplt.ylabel('distance b\/w cities in solution')","50165593":"plt.plot(gens, sols_dists_2)\nplt.xlabel('generations size')\nplt.ylabel('distance b\/w cities in solution')\nplt.tight_layout()","35366039":"## Optimal Population size\nAs one can see from the above plot I think **optimal population size here is 20**, as solution is able to converge more when population size is near 20. Greater population gives more optimized results as proved by the above plot","4a756158":"## 1. Generate Population\nThe code can generate population of any required size. Each chromosome is in the 1D array representing a route where each unit represents a city e.g, [0,5,1,4,6,8,3,7,9,2] city starts from 0 upto the given cities in matrix. In chromosome each city is represented only one time as Travelling salesman problem requires each city to be visited only once. See below for optimal population size discussion\n\n## 2. Fitness values\nEach chromosome represents a route so its total distance can be calculated. I am using an objective function\/fitness function to minimize total distance. So smaller the total distance, bigger is the fitness value\n       \n## 3. Selection\nWe Randomly select an individual by calculating its selection probability\n\n## 4.1 Reproduction \/ Crossover\nTo do a chromosome between x and y parents, we use order 1 crossover  \n\n  **Step 1**: Select a random subsequence from x  \n  \n  **Step 2**: Place that subsequence in relevant indices in child and mark out these in y  \n  \n  **Step 3**: Starting from right side grab the units of y and place them in child in empty position starting from right side. Those units are skipped which are marked out\n\n\n## 4.2 Mutation\nMutate child with probability 0.1 by swapping two random cities in chromosome","bd4de0a3":"## Generations\nAs one can see here in our case, population size impacts genetic search for Travelling Salesman Problem more but generations also lead somewhat to solution convergence "}}