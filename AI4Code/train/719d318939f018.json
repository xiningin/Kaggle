{"cell_type":{"0c4347e9":"code","4637bab1":"code","e95133bf":"code","989598e6":"code","bb763739":"code","1cd93e3c":"code","2d5d8622":"code","a77acc96":"code","8672a601":"code","09af2e0d":"code","c400e262":"code","e65d6f00":"code","55ee208d":"code","a360e162":"code","2482d8e4":"code","b2f6287c":"code","5a02c538":"code","b3d765b9":"code","cbc5beb8":"code","d35d6501":"code","e7d1c482":"code","154e3484":"code","d6629168":"code","8c4853d0":"code","f8d584fb":"code","9de2420d":"code","8b704f62":"code","a52ae609":"code","0d688884":"code","ccff1a5b":"code","92b22ea1":"code","7d24bb47":"code","486a406c":"code","5ce0d69f":"code","71a9e44c":"code","65710e2c":"code","8b51287e":"code","df8da725":"code","1969d7e3":"code","22169384":"code","0b5be457":"code","ae00ef65":"code","ca9cb6a7":"code","22347d71":"code","61e5f7da":"code","d8118128":"code","e89fd90d":"code","f1ebcd42":"code","0d8a9cbc":"code","a4f6aeb6":"code","7d7f5c99":"code","574f3b62":"code","b7310bf3":"code","92ea980d":"code","00c9fbef":"code","77ee3376":"code","53895e62":"code","8b048199":"code","a8473016":"code","dfd2e9c4":"markdown","c17ae6b7":"markdown","7ec7bc40":"markdown","fa319707":"markdown","8f69cfba":"markdown","1fbb6b9d":"markdown","c92e0b43":"markdown","ffa80589":"markdown","206e0037":"markdown","bb7d82e5":"markdown","3048c36f":"markdown","af2c5598":"markdown","20d172e0":"markdown","b3dcc03f":"markdown","7be5d8dc":"markdown","733b1266":"markdown","22964371":"markdown","8e721ab3":"markdown","6c4468c4":"markdown","808555a9":"markdown","ad265a49":"markdown","e78bec26":"markdown","4b539487":"markdown","587a5c72":"markdown"},"source":{"0c4347e9":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns","4637bab1":"import pydicom","e95133bf":"import gc\nimport warnings\nwarnings.simplefilter(action = 'ignore')","989598e6":"from lightgbm import LGBMRegressor, LGBMClassifier\nfrom sklearn.metrics import roc_auc_score, mean_absolute_error\nfrom sklearn.model_selection import KFold","bb763739":"detailed_class_info = pd.read_csv('..\/input\/stage_1_detailed_class_info.csv')\ntrain_labels = pd.read_csv('..\/input\/stage_1_train_labels.csv')\n\ndf = pd.merge(left = detailed_class_info, right = train_labels, how = 'left', on = 'patientId')\n\ndel detailed_class_info, train_labels\ngc.collect()\n\ndf.info(null_counts = True)","1cd93e3c":"df.head()","2d5d8622":"df = df.drop_duplicates()\ndf.info()","a77acc96":"df['patientId'].value_counts().head(10)","8672a601":"df[df['patientId'] == '32408669-c137-4e8d-bd62-fe8345b40e73']","09af2e0d":"df['patientId'].value_counts().value_counts()","c400e262":"df[df['Target'] == 0]['patientId'].value_counts().value_counts()","e65d6f00":"sns.countplot(x = 'class', hue = 'Target', data = df);","55ee208d":"df[df['class'] == 'Lung Opacity']['Target'].value_counts(dropna = False)","a360e162":"df[df['class'] == 'No Lung Opacity \/ Not Normal']['Target'].value_counts(dropna = False)","2482d8e4":"df[df['class'] == 'Normal']['Target'].value_counts(dropna = False)","b2f6287c":"print('Patients can have {} different classes'.format(df.groupby('patientId')['class'].nunique().nunique()))","5a02c538":"df_areas = df.dropna()[['x', 'y', 'width', 'height']].copy()\ndf_areas['x_2'] = df_areas['x'] + df_areas['width']\ndf_areas['y_2'] = df_areas['y'] + df_areas['height']\ndf_areas['x_center'] = df_areas['x'] + df_areas['width'] \/ 2\ndf_areas['y_center'] = df_areas['y'] + df_areas['height'] \/ 2\ndf_areas['area'] = df_areas['width'] * df_areas['height']\n\ndf_areas.head()","b3d765b9":"sns.jointplot(x = 'x', y = 'y', data = df_areas, kind = 'hex', gridsize = 20);","cbc5beb8":"sns.jointplot(x = 'x_center', y = 'y_center', data = df_areas, kind = 'hex', gridsize = 20);","d35d6501":"sns.jointplot(x = 'x_2', y = 'y_2', data = df_areas, kind = 'hex', gridsize = 20);","e7d1c482":"sns.jointplot(x = 'width', y = 'height', data = df_areas, kind = 'hex', gridsize = 20);","154e3484":"n_columns = 3\nn_rows = 3\n_, axes = plt.subplots(n_rows, n_columns, figsize=(8 * n_columns, 5 * n_rows))\nfor i, c in enumerate(df_areas.columns):\n    sns.boxplot(y = c, data = df_areas, ax = axes[i \/\/ n_columns, i % n_columns])\nplt.tight_layout()\nplt.show()","d6629168":"df_areas[df_areas['width'] > 500]","8c4853d0":"pid_width = list(df[df['width'] > 500]['patientId'].values)\ndf[df['patientId'].isin(pid_width)]","f8d584fb":"df_areas[df_areas['height'] > 900].shape[0]","9de2420d":"pid_height = list(df[df['height'] > 900]['patientId'].values)\ndf[df['patientId'].isin(pid_height)]","8b704f62":"df = df[~df['patientId'].isin(pid_width + pid_height)]\ndf.shape","a52ae609":"df_meta = df.drop('class', axis = 1).copy()","0d688884":"dcm_columns = None\n\nfor n, pid in enumerate(df_meta['patientId'].unique()):\n    dcm_file = '..\/input\/stage_1_train_images\/%s.dcm' % pid\n    dcm_data = pydicom.read_file(dcm_file)\n    \n    if not dcm_columns:\n        dcm_columns = dcm_data.dir()\n        dcm_columns.remove('PixelSpacing')\n        dcm_columns.remove('PixelData')\n    \n    for col in dcm_columns:\n        if not (col in df_meta.columns):\n            df_meta[col] = np.nan\n        index = df_meta[df_meta['patientId'] == pid].index\n        df_meta.loc[index, col] = dcm_data.data_element(col).value\n        \n    del dcm_data\n    \ngc.collect()\n\ndf_meta.head()","ccff1a5b":"to_drop = df_meta.nunique()\nto_drop = to_drop[(to_drop <= 1) | (to_drop == to_drop['patientId'])].index\nto_drop = to_drop.drop('patientId')\nto_drop","92b22ea1":"df_meta.drop(to_drop, axis = 1, inplace = True)\ndf_meta.head()","7d24bb47":"print('Dropped {} useless features'.format(len(to_drop)))","486a406c":"df_meta.nunique()","5ce0d69f":"sum(df_meta['ReferringPhysicianName'].unique() != '')","71a9e44c":"df_meta.drop('ReferringPhysicianName', axis = 1, inplace = True)","65710e2c":"df_meta['PatientAge'] = df_meta['PatientAge'].astype(int)\ndf_meta['SeriesDescription'] = df_meta['SeriesDescription'].map({'view: AP': 'AP', 'view: PA': 'PA'})\ndf_meta.head()","8b51287e":"print('There are {} equal elements between SeriesDescription and ViewPosition from {}.' \\\n      .format(sum(df_meta['SeriesDescription'] == df_meta['ViewPosition']), df_meta.shape[0]))","df8da725":"df_meta.drop('SeriesDescription', axis = 1, inplace = True)","1969d7e3":"plt.figure(figsize = (25, 5))\nsns.countplot(x = 'PatientAge', hue = 'Target', data = df_meta);","22169384":"sns.countplot(x = 'PatientSex', hue = 'Target', data = df_meta);","0b5be457":"sns.countplot(x = 'ViewPosition', hue = 'Target', data = df_meta);","ae00ef65":"df_meta['PatientSex'] = df_meta['PatientSex'].map({'F': 0, 'M': 1})\ndf_meta['ViewPosition'] = df_meta['ViewPosition'].map({'PA': 0, 'AP': 1})\ndf_meta.head()","ca9cb6a7":"df_meta.corr()","22347d71":"def fast_lgbm_cv_scores(df, target, task, rs = 0):\n    warnings.simplefilter('ignore')\n    \n    if task == 'classification':\n        clf = LGBMClassifier(n_estimators = 10000, nthread = 4, random_state = rs)\n        metric = 'auc'\n    else:\n        clf = LGBMRegressor(n_estimators = 10000, nthread = 4, random_state = rs)\n        metric = 'mean_absolute_error'\n\n    # Cross validation model\n    folds = KFold(n_splits = 2, shuffle = True, random_state = rs)\n        \n    # Create arrays and dataframes to store results\n    pred = np.zeros(df.shape[0])\n    \n    feats = df.columns.drop(target)\n    \n    feature_importance_df = pd.DataFrame(index = feats)\n    \n    for n_fold, (train_idx, valid_idx) in enumerate(folds.split(df[feats], df[target])):\n        train_x, train_y = df[feats].iloc[train_idx], df[target].iloc[train_idx]\n        valid_x, valid_y = df[feats].iloc[valid_idx], df[target].iloc[valid_idx]\n\n        clf.fit(train_x, train_y, \n                eval_set = [(valid_x, valid_y)], eval_metric = metric, \n                verbose = -1, early_stopping_rounds = 100)\n\n        if task == 'classification':\n            pred[valid_idx] = clf.predict_proba(valid_x, num_iteration = clf.best_iteration_)[:, 1]\n        else:\n            pred[valid_idx] = clf.predict(valid_x, num_iteration = clf.best_iteration_)\n        \n        feature_importance_df[n_fold] = pd.Series(clf.feature_importances_, index = feats)\n        \n        del train_x, train_y, valid_x, valid_y\n        gc.collect()\n\n    if task == 'classification':    \n        return feature_importance_df, pred, roc_auc_score(df[target], pred)\n    else:\n        return feature_importance_df, pred, mean_absolute_error(df[target], pred)","61e5f7da":"f_imp, _, score = fast_lgbm_cv_scores(df_meta.drop(['patientId', 'x', 'y', 'width', 'height'], axis = 1), \n                                      target = 'Target', task = 'classification')\nprint('ROC-AUC for Target = {}'.format(score))","d8118128":"f_imp","e89fd90d":"for c in ['x', 'y', 'width', 'height']:\n    df_meta[c] = df_meta[c].fillna(-1)\ndf_meta.head()","f1ebcd42":"f_imp, pred, score = fast_lgbm_cv_scores(df_meta[['x', 'PatientAge', 'PatientSex', 'ViewPosition']], \n                                   target = 'x', task = 'regression')\nprint('MAE for x = {}'.format(score))","0d8a9cbc":"val = df_meta[['x']]\nval['pred'] = pred\nval['error'] = abs(val['x'] - val['pred'])\nval[['pred', 'error', 'x']].sort_values('x').reset_index(drop = True).plot();","a4f6aeb6":"f_imp","7d7f5c99":"f_imp, pred, score = fast_lgbm_cv_scores(df_meta[['y', 'PatientAge', 'PatientSex', 'ViewPosition']], \n                                   target = 'y', task = 'regression')\nprint('MAE for y = {}'.format(score))","574f3b62":"val = df_meta[['y']]\nval['pred'] = pred\nval['error'] = abs(val['y'] - val['pred'])\nval[['pred', 'error', 'y']].sort_values('y').reset_index(drop = True).plot();","b7310bf3":"f_imp","92ea980d":"f_imp, pred, score = fast_lgbm_cv_scores(df_meta[['width', 'PatientAge', 'PatientSex', 'ViewPosition']], \n                                   target = 'width', task = 'regression')\nprint('MAE for width = {}'.format(score))","00c9fbef":"val = df_meta[['width']]\nval['pred'] = pred\nval['error'] = abs(val['width'] - val['pred'])\nval[['pred', 'error', 'width']].sort_values('width').reset_index(drop = True).plot();","77ee3376":"f_imp","53895e62":"f_imp, pred, score = fast_lgbm_cv_scores(df_meta[['height', 'PatientAge', 'PatientSex', 'ViewPosition']], \n                                   target = 'height', task = 'regression')\nprint('MAE for height = {}'.format(score))","8b048199":"val = df_meta[['height']]\nval['pred'] = pred\nval['error'] = abs(val['height'] - val['pred'])\nval[['pred', 'error', 'height']].sort_values('height').reset_index(drop = True).plot();","a8473016":"f_imp","dfd2e9c4":"## Attempt of forecasting of target and spatial variables according to meta information","c17ae6b7":"Dropped one feature wich is equal another.","7ec7bc40":"### Distribution of `class`","fa319707":"That is, \"class == Lung Opacity\" is equivalent to \"Target == 1\" or \"image has pneumonia areas\".","8f69cfba":"### Loading data","1fbb6b9d":"# Practical EDA on numerical data","c92e0b43":"-  \"class == Lung Opacity\" is equivalent to \"Target == 1\" or \"image has pneumonia areas\". But the advantage of it is doubtful, because test images have not such information.\n\n- 5 rows (3 patients) have been dropped as obvious outliers.\n\n- It can be useful to predict 'Target' directly with meta information ('PatientAge', 'PatientSex', 'ViewPosition') for preliminary selecting images with pneumonia from the test set.\n\n- There is no useful information in meta data for directly prediction spatial features.","ffa80589":"### Rows per patientID","206e0037":"Centers and opposite corners have density more (variance less), than main corners (x, y). The centers have a high density and small correlation. \n\nThere is no reason to replace (x, y) with (x_center, y_center) or (x_2, y_2).","bb7d82e5":"## Analisys of meta information","3048c36f":"# Conclusion","af2c5598":"## Analisys of base information","20d172e0":"It can be useful to predict Target for selecting images with pneumonia.\n\nThere is no useful information in meta data for prediction spatial features directly.","b3dcc03f":"Only class `Lung Opacity` has pneumonia on the train set.","7be5d8dc":"Widths and heights have a very hight correlation.","733b1266":"Dropped one more useless feature","22964371":"### Spatial features: x, y, width, height","8e721ab3":"One patient. Row can be dropped.","6c4468c4":"Count of rows per patientID has 4 values:","808555a9":"'ViewPosition' have a high correlation with 'Target' and 'height' features. It can be useful...","ad265a49":"Score of prediction is rather high","e78bec26":"Each of patients without pneumonia has only one row in dataset:","4b539487":"There are some outliers, especially for 'width' and 'height' features.","587a5c72":"Two patients. All rows must be dropped together."}}