{"cell_type":{"fb4e178e":"code","d22a41dd":"code","1e82e458":"code","5c0a598d":"code","d11ce0ca":"code","985a4002":"code","d6bb019f":"code","d26ddaef":"code","0ea5e264":"code","cea6cf3f":"code","0ad5e31b":"code","17477fa1":"code","6196dc66":"code","61b7f82d":"code","05830352":"code","4d4338f8":"code","7cb127ea":"markdown","175559e2":"markdown","d13795da":"markdown"},"source":{"fb4e178e":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt # for drawing\nimport seaborn as sns # for drawing as well\nfrom scipy.optimize import minimize # will use for training\nfrom sklearn.metrics import accuracy_score, f1_score # some metrics\nfrom functools import partial # better google what it is\nfrom tqdm import tqdm as tqdm # nice trackbar\nimport cv2\n\nimport torch # this is the best library for neural networks (IMHO)\nimport torch.nn as nn # high-level API, useful for deep learning\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nimport os\nos.listdir('\/kaggle\/input\/digit-recognizer')","d22a41dd":"train = pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/digit-recognizer\/test.csv')\n\ntrain.head()","1e82e458":"target = train['label']\n\ntrain = train.drop('label', axis=1).values.reshape([-1, 28, 28]) \/ 255\ntest = test.values.reshape([-1, 28, 28]) \/ 255","5c0a598d":"for i in range(4):\n    plt.title(target[i])\n    plt.imshow(train[i], cmap='gray')\n    plt.show()","d11ce0ca":"!pip install efficientnet-pytorch","985a4002":"from efficientnet_pytorch import EfficientNet","d6bb019f":"effnet = EfficientNet.from_pretrained('efficientnet-b0')","d26ddaef":"img = train[0]\nimg = cv2.resize(img, (224, 224)) # min 64x64, max inf\nimg = np.tile(img[None], [3, 1, 1])\nimg = img[None] # Add batch dimension\nimg = torch.tensor(img, dtype=torch.float32)\nimg.shape","0ea5e264":"feats = effnet.extract_features(img)","cea6cf3f":"feats.shape","0ad5e31b":"def extract_features(img):\n    '''Input: grayscale image'''\n    \n    # Minimum size required by EfficientNet\n    img = cv2.resize(img, (64, 64))\n    # Convert grayscale to RGB\n    img = np.tile(img[None], [3, 1, 1])\n    # Add batch dimension\n    img = img[None]\n    # Convert to tensor\n    img = torch.tensor(img, dtype=torch.float32, device=device)\n    \n    # Pass image through the neural network\n    feats = effnet.extract_features(img)\n    \n    # Get rid of spatial dimensions\n    feats = feats[0].mean(1).mean(1)\n    # Convert to numpy\n    feats = feats.data.cpu().numpy()\n    # float16 takes less memory than float32 (this is optional)\n    feats = feats.astype('float16')\n    \n    return feats","17477fa1":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\nprint(device)\n\neffnet = effnet.to(device)","6196dc66":"feats_train = np.array([extract_features(img) for img in tqdm(train)])\nfeats_test = np.array([extract_features(img) for img in tqdm(test)])","61b7f82d":"print('train', feats_train.shape)\nprint('test', feats_test.shape)","05830352":"from sklearn.linear_model import LogisticRegression\n\nlr = LogisticRegression()\nlr.fit(feats_train, target)\n\npredictions = lr.predict(feats_test)","4d4338f8":"submission = pd.read_csv('\/kaggle\/input\/digit-recognizer\/sample_submission.csv')\nsubmission.Label = predictions\n\n# Save it as csv file\nsubmission.to_csv('submission_10n.csv', index=False)\n\nsubmission.head()","7cb127ea":"Let's train logistic regression","175559e2":"Now let's wrap it into a function","d13795da":"## EfficientNet\nLet's install module"}}