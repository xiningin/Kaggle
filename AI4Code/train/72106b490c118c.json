{"cell_type":{"f6747ab1":"code","9e349121":"code","c16f726c":"code","f4d81797":"code","1cfa674c":"code","2298c86b":"code","a9217a58":"code","883f1576":"code","8be238c0":"code","d98aaf9f":"code","e62b8161":"code","f2a92bcd":"code","c856cc09":"markdown","cbc97f48":"markdown","2c82f9ec":"markdown"},"source":{"f6747ab1":"import numpy as np\nimport keras\nfrom keras.models import Sequential\nfrom keras.layers import Activation,MaxPooling2D,Dropout\nfrom keras.layers.core import Dense, Flatten\nfrom keras.optimizers import Adam\nfrom keras.optimizers import SGD\nfrom keras.metrics import categorical_crossentropy\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.layers.convolutional import Conv2D\nfrom tensorflow.keras.models import load_model\nfrom keras.callbacks import ModelCheckpoint,ReduceLROnPlateau,EarlyStopping,LearningRateScheduler,CSVLogger,LambdaCallback,TensorBoard\nfrom keras import regularizers\nimport itertools\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import confusion_matrix\nfrom keras.regularizers import l2\nimport seaborn as sns\nimport math\nimport os\nfrom keras.applications.resnet50 import ResNet50\nfrom keras.applications.vgg16 import VGG16\nfrom keras.applications.vgg19 import VGG19\n%matplotlib inline","9e349121":"#os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"\ntrain_path = '..\/input\/catdog10000train5000validate\/train\/train'\nvalid_path = '..\/input\/catdog10000train5000validate\/valid\/valid'\ntest_path  = '..\/input\/catdog10000train5000validate\/test\/test'\ntrain_gen = ImageDataGenerator(\n    shear_range=0.2,\n    zoom_range=0.2,\n    rotation_range=20,\n    width_shift_range=0.2,\n    height_shift_range=0.2,\n    horizontal_flip=True,\n    channel_shift_range=10.,\n    fill_mode=\"nearest\"\n)\ngen = ImageDataGenerator(rotation_range=10, width_shift_range=0.1, \n    height_shift_range=0.1, shear_range=0.15, zoom_range=0.1, \n    channel_shift_range=10., horizontal_flip=True)\n\ntrain_batches = train_gen.flow_from_directory(directory=train_path, target_size=(224,224),\n    classes=['dog', 'cat'], batch_size=32)\n\nvalid_batches = ImageDataGenerator().flow_from_directory(directory=valid_path, target_size=(224,224), \n    classes=['dog', 'cat'], batch_size=32)\ntest_batches = ImageDataGenerator().flow_from_directory(directory=test_path, target_size=(224,224),\n    classes=['dog', 'cat'], batch_size=32,shuffle=False)\n","c16f726c":"# learning rate schedule\ndef step_decay(epoch):\n\tinitial_lrate = 0.001\n\tdrop = 0.5\n\tepochs_drop = 1.0\n\tlrate = initial_lrate * math.pow(drop, math.floor((1+epoch)\/epochs_drop))\n\treturn lrate","f4d81797":"# Add all the call backs for Keras\nlr_print_callback = LambdaCallback(\n    on_epoch_begin=lambda epoch,logs: print(\"LearningRate of %e\",model.optimizer.lr))\n\nearlyStopping = EarlyStopping(\n    monitor='val_loss',\n    min_delta=0,\n    verbose=0,\n    mode='auto',\n    baseline=None,\n\tpatience=10,\n    restore_best_weights=True\n)\n\nreduce_lr_loss = ReduceLROnPlateau(\n    monitor='val_loss', \n\tfactor=0.1, \n    patience=7, \n\tverbose=1, \n    min_delta=1e-4,\n\tmode='auto')\n\t\nreduce_lr_loss = ReduceLROnPlateau(\n    monitor='val_loss', \n\tfactor=0.1, \n    patience=7, \n\tverbose=1, \n    min_delta=1e-4,\n\tmode='auto')\n\nmcp_save       = ModelCheckpoint(\n    'cat_dog_ckpt.h5', \n\tsave_best_only=True, \n\tmonitor='val_loss', \n\tmode='auto'\n)\nlrate_sched = LearningRateScheduler(step_decay)\n\ncsv_log = CSVLogger('train.csv', separator=',', append=False)\n","1cfa674c":"# plots images with labels within jupyter notebook\ndef plots(ims, figsize=(12,6), rows=1, interp=False, titles=None):\n    if type(ims[0]) is np.ndarray:\n        ims = np.array(ims).astype(np.uint8)\n        if (ims.shape[-1] != 3):\n            ims = ims.transpose((0,2,3,1))\n    f = plt.figure(figsize=figsize)\n    plt.style.use('ggplot')\n    cols = len(ims)\/rows\n    #cols = 8\n    for i in range(len(ims)):\n    #for i in range(10):\n        sp = f.add_subplot(rows, cols, i+1)\n        sp.axis('Off')\n        if titles is not None:\n            sp.set_title(titles[i], fontsize=16)\n        plt.imshow(ims[i], interpolation=None if interp else 'none')\n\n#test_imgs, labels = next(test_batches)\n#test_imgs, labels = next(train_gen)\n\n#plots(aug_images, figsize=(20,7), rows=2)\n\n\n","2298c86b":"vgg19_model = VGG19()\n#vgg16_model = VGG16() \nmodel_vgg19 = Sequential() \nfor layer in vgg19_model.layers[:-1]: \n    model_vgg19.add(layer) \nfor layer in model_vgg19.layers: \n    layer.trainable = False \n    \nmodel_vgg19.add(Dense(2, activation='sigmoid'))\n\n\nmcp_save       = ModelCheckpoint(\n    'cat_dog_ckpt_vgg19.h5', \n\tsave_best_only=True, \n\tmonitor='val_loss', \n\tmode='auto'\n)\n#print(\"Running the Training of Model from Scratch\") \n#history = model_vgg16.fit_generator(generator=train_batches, steps_per_epoch=len(train_batches),\n#                                    validation_data=valid_batches, validation_steps=len(valid_batches), \n#                                    epochs=50, verbose=1)\n\n","a9217a58":"if os.path.isfile('cat_dog_ckpt_vgg19.h5'):\n    #This code is implemented to load the partly trained model which was stopped due to some reason\n    print(\"Running the Partially Trained Model\")\n    partially_trained_model = load_model('cat_dog_ckpt_vgg19.h5')\n    history = partially_trained_model.fit_generator(generator=train_batches, steps_per_epoch=len(train_batches),\n                                 validation_data=valid_batches, validation_steps=len(valid_batches), \n                                    epochs=50,callbacks=[mcp_save], verbose=1)\nelse:\n    print(\"Running the Training of Model from Scratch\")\n    model_vgg19.compile(loss='binary_crossentropy',optimizer=Adam(lr=0.0001),metrics=['accuracy'])\n    history = model_vgg19.fit_generator(generator=train_batches, steps_per_epoch=len(train_batches),\n                                 validation_data=valid_batches, validation_steps=len(valid_batches), \n                                    epochs=50,callbacks=[mcp_save], verbose=1)\n","883f1576":"acc = history.history['accuracy'] \nval_acc = history.history['val_accuracy'] \nloss = history.history['loss'] \nval_loss = history.history['val_loss']\n\nepochs = range(1, len(acc) + 1)\n\nplt.plot(epochs, acc, 'bo', label='Training acc')\nplt.plot(epochs, val_acc, 'b', label='Validation acc') \nplt.title('Training and validation accuracy') \nplt.legend() \nplt.figure() \nplt.plot(epochs, loss, 'bo', label='Training loss') \nplt.plot(epochs, val_loss, 'b', label='Validation loss') \nplt.title('Training and validation loss') \nplt.savefig('accuracy.png')\nplt.show()","8be238c0":"predictions = model_vgg16.predict_generator(generator=test_batches, steps=len(test_batches), verbose=0)\npred_label = np.argmax(predictions,axis=1)\nclasses = np.argmax(predictions, axis=1)\ncm = confusion_matrix(test_batches.labels,pred_label)\nf,ax = plt.subplots(figsize=(4, 4))\nsns.heatmap(cm, annot=True, linewidths=0.01,cmap=\"Greens\",linecolor=\"gray\", fmt= '.1f',ax=ax)\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.title(\"Confusion Matrix\")\nplt.show()\nplt.savefig('confusion_matrix.png')","d98aaf9f":"from sklearn.metrics import precision_score\nfrom sklearn.metrics import recall_score\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn import metrics\ntn, fp, fn, tp = cm.ravel()\naccuracy = (tn + tp)\/(tn + tp + fn +fp)\nprecision = precision_score(test_batches.labels, pred_label, average='binary')\nrecall = recall_score(test_batches.labels, pred_label,average='binary')\nf1_score = f1_score(test_batches.labels, pred_label, average='binary')\nscore = metrics.accuracy_score(test_batches.labels, pred_label)\nlog_score = metrics.log_loss(pred_label, predictions)","e62b8161":"print(\"Precision \",precision*100)\nprint(\"Recall \",recall*100)\nprint(\"F1 Score \",recall*100)\nprint(\"Accuracy of the model\",accuracy*100)\nprint(\"Accuracy score: {}\".format(score))\nprint(\"Log loss score: {}\".format(log_score))","f2a92bcd":"from sklearn.metrics import roc_curve, auc\ndef plot_roc(pred,y):\n    fpr, tpr, _ = roc_curve(y, pred)\n    roc_auc = auc(fpr, tpr)\n\n    plt.figure()\n    plt.plot(fpr, tpr, label='ROC curve (area = %0.2f)' % roc_auc)\n    plt.plot([0, 1], [0, 1], 'k--')\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.05])\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic (ROC)')\n    plt.legend(loc=\"lower right\")\n    plt.show()\nplot_roc(pred_label,test_batches.labels)","c856cc09":"![cm_vgg19.png](attachment:cm_vgg19.png)","cbc97f48":"![roc_vgg19.png](attachment:roc_vgg19.png)","2c82f9ec":"![accuracy_vgg19.png](attachment:accuracy_vgg19.png)"}}