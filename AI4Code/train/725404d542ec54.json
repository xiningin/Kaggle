{"cell_type":{"b31f4d26":"code","e388edc0":"code","113a44a7":"code","96fc3ee7":"code","1374f36a":"code","84675f72":"code","2a580ca9":"code","de3270bc":"code","2923f757":"code","b4a45373":"code","bfd8b46c":"code","6fb84ed7":"code","54b13c04":"code","7a8f2c03":"code","fe90bed1":"code","2714f8da":"code","34cfda7c":"code","856429c4":"code","55ff78e4":"code","151192e7":"code","aa91bc27":"code","ff2ca994":"code","942db60e":"code","ffcda0b7":"code","131e3176":"code","f63643ca":"code","bc08312e":"code","a4ef2535":"code","43373fca":"code","5591f679":"code","19195cf5":"code","5522b01b":"code","1538d3c2":"markdown","38239844":"markdown","9ff6c053":"markdown","7eddba5f":"markdown","8e5faaa0":"markdown","11007bb5":"markdown","e8352d07":"markdown","9844915e":"markdown","5dfa889a":"markdown","253c2055":"markdown","0d90f67b":"markdown","b2025e2a":"markdown"},"source":{"b31f4d26":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nplt.style.use(\"seaborn-whitegrid\")\nimport matplotlib.image as implt\nfrom PIL import Image \nimport seaborn as sns\nimport cv2 as cs2\nimport os\n\nimport warnings\nwarnings.filterwarnings('ignore')","e388edc0":"## import Keras and its module for image processing and model building\nimport keras\nfrom keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\n\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D\nfrom keras.layers import Activation, Dropout, Flatten, Dense, BatchNormalization","113a44a7":"#copying the pretrained models to the cache directory\ncache_dir = os.path.expanduser(os.path.join('~', '.keras'))\nif not os.path.exists(cache_dir):\n    os.makedirs(cache_dir)\nmodels_dir = os.path.join(cache_dir, 'models')\nif not os.path.exists(models_dir):\n    os.makedirs(models_dir)\n\n#copy the Xception models\n!cp ..\/input\/keras-pretrained-models\/xception* ~\/.keras\/models\/\n#show\n!ls ~\/.keras\/models","96fc3ee7":"train_path = \"..\/input\/animal-faces\/afhq\/train\"\ntest_path = \"..\/input\/animal-faces\/afhq\/val\"\n\ntrain_cat = \"..\/input\/animal-faces\/afhq\/train\/cat\"\ntrain_dog = \"..\/input\/animal-faces\/afhq\/train\/dog\"\ntrain_wild = \"..\/input\/animal-faces\/afhq\/train\/wild\"\n\ntest_cat = \"..\/input\/animal-faces\/afhq\/val\/cat\"\ntest_dog = \"..\/input\/animal-faces\/afhq\/val\/dog\"\ntest_wild = \"..\/input\/animal-faces\/afhq\/val\/wild\"","1374f36a":"# VISUALIZATION\ncategory_names = os.listdir(train_path) # output: ['cat', 'dog','wild']\nnb_categories = len(category_names) # output: 3\ntrain_images = []\n\nfor category in category_names:\n    folder = train_path + \"\/\" + category\n    train_images.append(len(os.listdir(folder)))\n\nsns.barplot(y=category_names, x=train_images).set_title(\"Number Of Training Images Per Category\");","84675f72":"img = load_img('..\/input\/animal-faces\/afhq\/train\/cat\/flickr_cat_000002.jpg')  # this is a PIL image\nx = img_to_array(img)  # this is a Numpy array \nprint('image shape: ', x.shape)\n\nprint('Train Cat Image')\nplt.imshow(img)\nplt.show()\n\n\nimg = load_img('..\/input\/animal-faces\/afhq\/train\/dog\/flickr_dog_000002.jpg')  # this is a PIL image\nx = img_to_array(img)  # this is a Numpy array \nprint('Train Dog Image')\nplt.imshow(img)\nplt.show()\n\n\nimg = load_img('..\/input\/animal-faces\/afhq\/train\/wild\/flickr_wild_000002.jpg')  # this is a PIL image\nx = img_to_array(img)  # this is a Numpy array \nprint('Train Wild Image')\nplt.imshow(img)\nplt.show()\n\n","2a580ca9":"img_size = 50\ncat_train = []\ndog_train = []\nwild_train = []\nlabel = []\n\nfor i in os.listdir(train_cat): # all train cat images\n    if os.path.isfile(train_path + \"\/cat\/\" + i): # check image in file\n        cat = Image.open(train_path + \"\/cat\/\" + i).convert(\"L\") # converting grey scale \n        cat = cat.resize((img_size,img_size), Image.ANTIALIAS) # resizing to 50,50\n        cat = np.asarray(cat)\/255 # bit format\n        cat_train.append(cat)\n        label.append(0)\n        \nfor i in os.listdir(train_dog): # all train dog images\n    if os.path.isfile(train_path + \"\/dog\/\" + i): # check image in file\n        dog = Image.open(train_path + \"\/dog\/\" + i).convert(\"L\") # converting grey scale \n        dog = dog.resize((img_size,img_size), Image.ANTIALIAS) # resizing to 50,50\n        dog = np.asarray(dog)\/255 # bit format\n        dog_train.append(dog)\n        label.append(1)\n        \n        \nfor i in os.listdir(train_wild): # all train wild images\n    if os.path.isfile(train_path + \"\/wild\/\" + i): # check image in file\n        wild = Image.open(train_path + \"\/wild\/\" + i).convert(\"L\") # converting grey scale \n        wild = wild.resize((img_size,img_size), Image.ANTIALIAS) # resizing to 50,50\n        wild = np.asarray(wild)\/255 # bit format\n        wild_train.append(wild)\n        label.append(2)","de3270bc":"x_train = np.concatenate((cat_train,dog_train,wild_train),axis=0) # training dataset\nx_train_label = np.asarray(label) # label array containing 0, 1, and 2\nx_train_label = x_train_label.reshape(x_train_label.shape[0],1)\n\nprint(\"cat:\",np.shape(cat_train) , \"dog:\",np.shape(dog_train), \"wild:\",np.shape(wild_train))\nprint(\"train_dataset:\",np.shape(x_train), \"train_values:\",np.shape(x_train_label))","2923f757":"# Visualizing Training data\nprint(x_train_label[0])\nplt.imshow(cat_train[0])","b4a45373":"# Visualizing Training data\nprint(x_train_label[1])\nplt.imshow(dog_train[0])","bfd8b46c":"# Visualizing Training data\nprint(x_train_label[2])\nplt.imshow(wild_train[0])","6fb84ed7":"img_size = 50\ncat_test = []\ndog_test = []\nwild_test = []\nlabel = []\n\nfor i in os.listdir(test_cat): # all test cat images\n    if os.path.isfile(test_path + \"\/cat\/\" + i): # check image in file\n        cat = Image.open(test_path + \"\/cat\/\" + i).convert(\"L\") # converting grey scale \n        cat = cat.resize((img_size,img_size), Image.ANTIALIAS) # resizing to 50,50\n        cat = np.asarray(cat)\/255 # bit format\n        cat_test.append(cat)\n        label.append(0)\n        \nfor i in os.listdir(test_dog): # all test dog images\n    if os.path.isfile(test_path + \"\/dog\/\" + i): # check image in file\n        dog = Image.open(test_path + \"\/dog\/\" + i).convert(\"L\") # converting grey scale \n        dog = dog.resize((img_size,img_size), Image.ANTIALIAS) # resizing to 50,50\n        dog = np.asarray(dog)\/255 # bit format\n        dog_test.append(dog)\n        label.append(1)\n        \n        \nfor i in os.listdir(test_wild): # all test wild images\n    if os.path.isfile(test_path + \"\/wild\/\" + i): # check image in file\n        wild = Image.open(test_path + \"\/wild\/\" + i).convert(\"L\") # converting grey scale \n        wild = wild.resize((img_size,img_size), Image.ANTIALIAS) # resizing to 50,50\n        wild = np.asarray(wild)\/255 # bit format\n        wild_test.append(wild)\n        label.append(2)","54b13c04":"x_test = np.concatenate((cat_test,dog_test,wild_test),axis=0) # training dataset\nx_test_label = np.asarray(label) # label array containing 0, 1, and 2\nx_test_label = x_test_label.reshape(x_test_label.shape[0],1)\n\nprint(\"cat:\",np.shape(cat_test) , \"dog:\",np.shape(dog_test), \"wild:\",np.shape(wild_test))\nprint(\"test_dataset:\",np.shape(x_test), \"test_values:\",np.shape(x_test_label))","7a8f2c03":"# Visualizing Training data\nprint(x_test_label[0])\nplt.imshow(cat_test[0])","fe90bed1":"# Visualizing Training data\nprint(x_test_label[0])\nplt.imshow(dog_test[0])","2714f8da":"# Visualizing Training data\nprint(x_test_label[0])\nplt.imshow(wild_test[0])","34cfda7c":"x = np.concatenate((x_train,x_test),axis=0) # counttrain_data\n\ny = np.concatenate((x_train_label,x_test_label),axis=0) # count:  test_data\nx = x.reshape(x.shape[0],x.shape[1]*x.shape[2]) # flatten 3D image array to 2D\nprint(\"images:\",np.shape(x), \"labels:\",np.shape(y))","856429c4":"from sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)\nnumber_of_train = X_train.shape[0]\nnumber_of_test = X_test.shape[0]\n\nprint(\"Train Number: \", number_of_train)\nprint(\"Test Number: \", number_of_test)","55ff78e4":"x = np.concatenate((x_train,x_test),axis=0) # count train_data\n\ny = np.concatenate((x_train_label,x_test_label),axis=0) # count test_data\nx = x.reshape(x.shape[0],x.shape[1]*x.shape[2]) # flatten 3D image array to 2D\nprint(\"images:\",np.shape(x), \"labels:\",np.shape(y))","151192e7":"x_train = X_train.T\nx_test = X_test.T\ny_train = y_train.T\ny_test = y_test.T\nprint(\"x train: \",x_train.shape)\nprint(\"x test: \",x_test.shape)\nprint(\"y train: \",y_train.shape)\nprint(\"y test: \",y_test.shape)","aa91bc27":"from sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score\n\nlogreg = LogisticRegression()\ntest_acc_logregsk = round(logreg.fit(x_train.T, y_train.T).score(x_test.T, y_test.T)* 100, 2)\ntrain_acc_logregsk = round(logreg.fit(x_train.T, y_train.T).score(x_train.T, y_train.T)* 100, 2)","ff2ca994":"# with GridSearchCV\nfrom sklearn.model_selection import GridSearchCV\n\ngrid = {\n    \"C\": np.logspace(-4, 4, 20),\n    \"penalty\": [\"l1\",\"l2\"]\n}\nlg=LogisticRegression(random_state=42)\nlog_reg_cv=GridSearchCV(lg,grid,cv=10,n_jobs=-1,verbose=2)\nlog_reg_cv.fit(x_train.T,y_train.T)\nprint(\"accuracy: \", log_reg_cv.best_score_)","942db60e":"models = pd.DataFrame({\n    'Model': ['LR with sklearn','LR with GridSearchCV' ],\n    'Train Score': [train_acc_logregsk, \"-\"],\n    'Test Score': [test_acc_logregsk, log_reg_cv.best_score_*100]\n})\nmodels.sort_values(by='Test Score', ascending=False)","ffcda0b7":"from sklearn.ensemble import BaggingClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.svm import SVC\n\n# We define the SVM model\nsvmcla = OneVsRestClassifier(BaggingClassifier(SVC(C=5,kernel='rbf',random_state=42, probability=True), \n                                               n_jobs=-1))\ntest_acc_svm = round(svmcla.fit(x_train.T, y_train.T).score(x_test.T, y_test.T)* 100, 2)\ntrain_acc_svm = round(svmcla.fit(x_train.T, y_train.T).score(x_train.T, y_train.T)* 100, 2)\n","131e3176":"model2 = pd.DataFrame({\n    'Model': ['SVM'],\n    'Train Score': [train_acc_svm],\n    'Test Score': [test_acc_svm*100]\n})\nmodel2.sort_values(by='Test Score', ascending=False)","f63643ca":"from sklearn.ensemble import RandomForestClassifier\n\n# We define the model\nrfcla = RandomForestClassifier(n_estimators=100,random_state=9,n_jobs=-1)\ntest_acc_rfcla = round(rfcla.fit(x_train.T, y_train.T).score(x_test.T, y_test.T)* 100, 2)\ntrain_acc_rfcla = round(rfcla.fit(x_train.T, y_train.T).score(x_train.T, y_train.T)* 100, 2)","bc08312e":"model3 = pd.DataFrame({\n    'Model': ['Random Forest'],\n    'Train Score': [train_acc_rfcla],\n    'Test Score': [test_acc_rfcla*100]\n})\nmodel3.sort_values(by='Test Score', ascending=False)","a4ef2535":"from sklearn.tree import DecisionTreeClassifier\n\n# We define the model\ndtcla =  DecisionTreeClassifier(random_state=9)\ntest_acc_dtcla = round(dtcla.fit(x_train.T, y_train.T).score(x_test.T, y_test.T)* 100, 2)\ntrain_acc_dtcla = round(dtcla.fit(x_train.T, y_train.T).score(x_train.T, y_train.T)* 100, 2)","43373fca":"model4 = pd.DataFrame({\n    'Model': ['Decision Tree'],\n    'Train Score': [train_acc_dtcla],\n    'Test Score': [test_acc_dtcla*100]\n})\nmodel4.sort_values(by='Test Score', ascending=False)","5591f679":"from sklearn.neighbors import KNeighborsClassifier\n\n# We define the model\nknncla = KNeighborsClassifier(n_neighbors=5,n_jobs=-1)\n\ntest_acc_knncla = round(knncla.fit((x_train.T, y_train.T).score(x_test.T, y_test.T)* 100, 2)\ntrain_acc_knncla = round(knncla.fit(x_train.T, y_train.T).score(x_train.T, y_train.T)* 100, 2)\n\n","19195cf5":"model5 = pd.DataFrame({\n    'Model': ['KNN'],\n    'Train Score': [train_acc_knncla],\n    'Test Score': [test_acc_knncla*100]\n})\nmodel5.sort_values(by='Test Score', ascending=False)","5522b01b":"model5 = pd.DataFrame({\n    'Model': ['Logistic Regression', 'SVM','Random Forest','Decision Tree','KNN'],\n    'Train Score': [train_acc_logregsk, train_acc_svm , train_acc_rfcla ,train_acc_dtcla, train_acc_knncla],\n    'Test Score': [test_acc_logregsk, test_acc_svm , test_acc_rfcla ,test_acc_dtcla,test_acc_knncla ]\n})\nmodel5.sort_values(by='Test Score', ascending=False)","1538d3c2":"# 5. K-Nearest Neighbor classification\nK-Nearest neighbors is a technique that stores all available cases and classifies new cases based on a similarity measure (e.g., distance functions). This technique is non-parametric since there are no assumptions for the distribution of underlying data and it is lazy since it does not need any training data point model generation. All the training data used in the test phase. This makes the training faster and the test phase slower and more costlier. In this technique, the number of neighbors k is usually an odd number if the number of classes is 2. For finding closest similar points, find the distance between points using distance measures such as Euclidean distance, Hamming distance, Manhattan distance and Minkowski distance.","38239844":"# Comparison of classification techniques","9ff6c053":"Then we need to take transpose of all matrices. The purpose of it, quoted from here is: \"In python, it is often the case that transposing will enable you to have the data in a given shape that might make it easier to use whatever framework or algorithm\"","7eddba5f":"This study tries to predict animal face use 4 different algorithms:\n1. Logistic regression classification\n1. SVM (Support Vector Machine) classification\n1. Random forest classification\n1. Decision tree classification\n\n\n* The dataset contains 3 animal: cat, dog, and wild\n* Source dataset: https:\/\/www.kaggle.com\/andrewmvd\/animal-faces","8e5faaa0":"We combine image strings and tags and flatten 'x':","11007bb5":"## 3. Random forest classification\n\nBased on the previous classification method, random forest is a supervised learning algorithm that creates a forest randomly. This forest, is a set of decision trees, most of the times trained with the bagging method. The essential idea of bagging is to average many noisy but approximately impartial models, and therefore reduce the variation. Each tree is constructed using the following algorithm:\n\n* Let $N$ be the number of test cases, $M$ is the number of variables in the classifier.\n* Let $m$ be the number of input variables to be used to determine the decision in a given node; $m<M$.\n* Choose a training set for this tree and use the rest of the test cases to estimate the error.\n* For each node of the tree, randomly choose $m$ variables on which to base the decision. Calculate the best partition of the training set from the $m$ variables.\n\nFor prediction a new case is pushed down the tree. Then it is assigned the label of the terminal node where it ends. This process is iterated by all the trees in the assembly, and the label that gets the most incidents is reported as the prediction. We define the number of trees in the forest in 100. ","e8352d07":"## 2. SVM (Support Vector Machine) classification\n\nSVMs (Support Vector Machine) have shown a rapid proliferation during the last years. The learning problem setting for SVMs corresponds to a some unknown and nonlinear dependency (mapping, function) $y = f(x)$ between some high-dimensional input vector $x$ and scalar output $y$. It is noteworthy that there is no information on the joint probability functions, therefore, a free distribution learning must be carried out. The only information available is a training data set $D = {(x_i, y_i) \u2208 X\u00d7Y }, i = 1$, $l$, where $l$ stands for the number of the training data pairs and is therefore equal to the size of the training data set $D$, additionally, $y_i$ is denoted as $d_i$, where $d$ stands for a desired (target) value. Hence, SVMs belong to the supervised learning techniques.\n\nFrom the classification approach, the goal of SVM is to find a hyperplane in an N-dimensional space that clearly classifies the data points. Thus hyperplanes are decision boundaries that help classify the data points. Data points falling on either side of the hyperplane can be attributed to different classes.\n","9844915e":"## 1. Logistic regression classification\n\nLogistic regression is a technique that can be applied to binary classification problems. This technique uses the logistic function or sigmoid function, which is an S-shaped curve that can assume any real value number and assign it to a value between 0 and 1, but never exactly in those limits. Thus, logistic regression models the probability of the default class (the probability that an input $(X)$ belongs to the default class $(Y=1)$) $(P(X)=P(Y=1|X))$. In order to make the prediction of the probability, the logistic function is used, which allows us to obtain the log-odds or the probit. Thus, the model is a linear combination of the inputs, but that this linear combination relates to the log-odds of the default class.\n\nStarted from make an instance of the model setting the default values. Specify the inverse of the regularization strength in 10. Trained the logistic regression model with the training data, and then applied such model to the test data.","5dfa889a":"Scaling down the train set and test set images:\n\n\n1. cat: (5153, 50, 50) dog: (4739, 50, 50) wild: (4738, 50, 50)\n1. train_dataset: (14630, 50, 50) train_values: (14630, 1)\n1. test_dataset: (1500, 50, 50) test_values: (1500, 1)\n1. label 1 for cat, label 2 for dog and label 3 for wild","253c2055":"# Processing Dataset \nNow we need to modify images. The dataset contains different sizes of RGB color images. \n1. we should resize all the images, \n2. convert images to grayscale (only one dimension), while RBF image has three and helps you to avoid false classification and complexities.\n","0d90f67b":"Next step, we need to determine the amount of data for train and test. You can modify test_size and see how it affects the accuracy. Let's split!","b2025e2a":"# 4. Decision tree classification\nA decision tree is a flowchart-like tree structure where an internal node represents feature, the branch represents a decision rule, and each leaf node represents the outcome. The decision tree analyzes a set of data to construct a set of rules or questions, which are used to predict a class, i.e., the goal of decision tree is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features. In this sense the decision tree selects the best attribute using to divide the records, converting that attribute into a decision node and dividing the data set into smaller subsets, to finally start the construction of the tree repeating this process recursively."}}