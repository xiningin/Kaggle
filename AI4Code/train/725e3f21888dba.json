{"cell_type":{"76aec08c":"code","357de48e":"code","ebe748a7":"code","9537467b":"code","88a44acd":"code","66bcab5e":"code","75e0f7c9":"code","d7c1078a":"code","898908b1":"code","4edb376c":"code","c581cdf5":"code","f58786e8":"code","8b528cbc":"code","04f8e731":"code","ab98e9c4":"code","d87e89d1":"code","c8e3f0cd":"code","860ef97c":"code","e39d073a":"code","ac2adbf4":"code","caf46eef":"code","9bf84070":"code","f2b63de7":"code","f0cc5813":"code","eff981b7":"code","82391e1d":"code","67f6c513":"code","7802b535":"code","3eb1bbff":"code","2a329c79":"code","2a1b3d64":"code","0c9880c1":"code","2a378940":"markdown","b80e2dd2":"markdown","fa9cd62d":"markdown","05f2127b":"markdown","0e7e631b":"markdown","e036fd92":"markdown","95ea086b":"markdown","bcc37122":"markdown","10f36ac2":"markdown","1ccd862c":"markdown","67d75e75":"markdown","d446f139":"markdown","e3d8f04e":"markdown","bae25fe6":"markdown","6e0d74ce":"markdown","d4e2c5d8":"markdown","bdc962b0":"markdown","388cb3d0":"markdown","7bf131d1":"markdown","ae3ffe80":"markdown","33e5692b":"markdown","0f079b1a":"markdown","f194b433":"markdown","dd2a930c":"markdown","7b7a7b34":"markdown","7aa92045":"markdown","9be7e073":"markdown","82aa1ce0":"markdown","e09e9b5a":"markdown","9cd38429":"markdown","0c320a43":"markdown","3a8ad139":"markdown","50660174":"markdown","6aad8806":"markdown","5d46cfec":"markdown","016c0c55":"markdown","35414bed":"markdown","610adbcc":"markdown","5fe4f663":"markdown","b732d90e":"markdown","7fa2d92e":"markdown","08d35867":"markdown","42332cd5":"markdown","fc429307":"markdown","354cf339":"markdown","d4b02c1f":"markdown","1d587639":"markdown","93750e1d":"markdown","00057cb1":"markdown","036da7b1":"markdown","183cfc63":"markdown"},"source":{"76aec08c":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline \ndf = pd.read_csv('..\/input\/pokemon\/Pokemon.csv',index_col=0)\nimport seaborn as sns\nsns.set_theme(context='notebook', style='ticks', palette='colorblind', font='sans', font_scale=1.2, color_codes=True,rc={'figure.figsize':(15,8.27)}) # Liked this theme much more than Seaborn's default style\nimport itertools ","357de48e":"df.head() # Gives us a glimpse of the firts 5 elements of Pokemon's Dataset","ebe748a7":"df.tail() # A glimpse of the last elements of Pokemon's Dataset","9537467b":"df.columns # Not really neccesary in this particular case, We can visualize the columns in head() or tail()","88a44acd":"df.shape # It's important to know the shape, as of right now we know there are 800 observations and 12 variables ","66bcab5e":"df.dtypes #Gives us a glimpse of what type of data we have on the dataset in case we wish to change something with the astype function","75e0f7c9":"df.info() # To know the Non-null count the datatypes, the index and the columns(We already had them)","d7c1078a":"df.describe().T # Gives us a statistical summary of the data , it can also be done without the .T","898908b1":"df.columns = df.columns.str.upper() # Changing all the column names to Upper case \ndf.head()","4edb376c":"df.set_index('NAME',inplace=True) # Setting the name to be the new index\ndf.index = df.index.str.replace(\".*(?=Mega)\", \"\") # Eliminating the Mega prefix\n","c581cdf5":"#First We'll observe the number of types of Pokemon on the TYPE 1 column and then We'll count them and visualize them with the value_counts function\n\ndef type_1():\n    print('These are the types of Pokemon in TYPE 1 column in the dataset : \\n\\n',df['TYPE 1'].unique(),'\\n')\n    print('There are a total of : \\n\\n',df['TYPE 1'].nunique(),'different types of pokemons')\n    print('\\n\\nThese are the value counts of the type of Pokemons in column TYPE 1\\n\\n',df['TYPE 1'].value_counts())\n\n    #Now that the questions asked before have been answered, Let's proceed to plot the data using Matplotlib\n    \n    type_1_number = df['TYPE 1'].value_counts()\n    fig,ax = plt.subplots(figsize=(15,8))\n    ax.bar(type_1_number.index,type_1_number.values) # Nice way to avoid creating a variable by using .index and .values.\n    # This for loop is to place the value on top of the bar\n    for i in range(type_1_number.shape[0]):\n        ax.text(i, type_1_number.values[i]+1, type_1_number.values[i], horizontalalignment='center')\n    ax.set_xlabel('Types of Pokemon')\n    ax.set_ylabel('Number of Types 1 of Pokemon')\n    ax.set_title('Count types 1 of Pokemons')\n    plt.tight_layout()\ntype_1()\n#sns.countplot(x=\"TYPE 1\", data=df,saturation=1) Remember it could've been used and it would've been faster","f58786e8":"def type_2():\n\n    print('These are the types of Pokemon in TYPE 2 column in the dataset :\\n\\n',df['TYPE 2'].unique(),'\\n')\n    print('There are a total of : \\n\\n',df['TYPE 2'].nunique(),'different types 2  of pokemons')\n    print('\\n\\nThese are the value counts of the type of Pokemons in column TYPE 2\\n\\n',df['TYPE 2'].value_counts())\n    \n    # The porpuse of the \\n was to start each print statement in a different line\n    \n    type_2_number = df['TYPE 2'].value_counts()\n    fig,ax = plt.subplots(figsize=(15,8))\n    ax.bar(type_2_number.index,type_2_number.values,color='red')\n    for i in range(type_2_number.shape[0]):\n        ax.text(i, type_2_number.values[i]+1, type_2_number.values[i], horizontalalignment='center')\n    ax.set_xlabel('Types of Pokemon')\n    ax.set_ylabel('Number of Types 2  of Pokemon')\n    ax.set_title('Count types 2 of Pokemons')\n    plt.tight_layout()\ntype_2()\n\n#sns.countplot(x=\"TYPE 1\", data=df,saturation=1) Remember it could've been used and it would've been better","8b528cbc":"def type_3():\n    type_2_number = df['TYPE 2'].value_counts()\n    type_1_number = df['TYPE 1'].value_counts()\n    fig,ax = plt.subplots(figsize=(15,8))\n    ax.bar(type_1_number.index,type_1_number.values,color='red')\n    ax.bar(type_2_number.index,type_2_number.values,color='blue')\n    ax.set_xlabel('Types of Pokemon')\n    ax.set_ylabel('Total number types of Pokemon')\n    ax.set_title('Total count types of Pokemon')\n    plt.tight_layout()\ntype_3()\n\n#sns.countplot(x=\"TYPE 1\", data=df,saturation=1) Remember it could've been used and it would've been better","04f8e731":"sns.countplot(x=\"TYPE 1\", data=df,saturation=1)\nplt.tight_layout()","ab98e9c4":"def combination_of_type1_type2 ():\n    df['TYPE 1-2'] = df['TYPE 1'] + \" - \" + df['TYPE 2']\n    return df['TYPE 1-2'].value_counts()\ncombination_of_type1_type2 ()","d87e89d1":"def type1_type2_number_of_combinations ():\n    df['TYPE 1-2'] = df['TYPE 1'] + \" - \" + df['TYPE 2']\n    return df['TYPE 1-2'].nunique()\ntype1_type2_number_of_combinations ()","c8e3f0cd":"def type_4():\n    type_4_number = df['TYPE 1-2'].value_counts()[0:10]\n    fig,ax = plt.subplots(figsize=(19,8))\n    ax.bar(type_4_number.index,type_4_number.values,color='green')\n    for i in range(type_4_number.shape[0]):\n        ax.text(i, type_4_number.values[i]+1, type_4_number.values[i], horizontalalignment='center')\n    ax.set_xlabel('Types of Pokemon')\n    ax.set_ylabel('Total count of Pokemons types')\n    ax.set_title('Total number of Pokemons types')\n    plt.tight_layout()\ntype_4()","860ef97c":"non_legendary = df[df['LEGENDARY']==False] # False , therfore it's a non-legendary Pokemon\nlegendary = df[df['LEGENDARY']==True]\nfig = non_legendary.iloc[:,0:9].hist(bins=20, color='red', linewidth=1.0, xlabelsize=10, ylabelsize=10, xrot=45, yrot=0, figsize=(10,9), grid=False)\nplt.tight_layout(rect=(0, 0, 1.5, 1.5)) \n","e39d073a":"fig = legendary.iloc[:,0:9].hist(bins=20, color='blue', linewidth=1.0, xlabelsize=10, ylabelsize=10, xrot=45, yrot=0, figsize=(10,9), grid=False)\nplt.tight_layout(rect=(0, 0, 1.5, 1.5))","ac2adbf4":"import matplotlib.gridspec as gridspec\nfig, axes = plt.subplots(3, 3, figsize=(13, 9))\n\n\nsns.distplot(legendary['ATTACK'],hist=False,color='blue',kde_kws={\"shade\": True},ax=axes[0][1])\nsns.distplot(non_legendary['ATTACK'],hist=False,color='red',kde_kws={\"shade\": True},ax=axes[0][1])\n\nsns.distplot(legendary['HP'],hist=False,color='blue',kde_kws={\"shade\": True},ax=axes[0][0])\nsns.distplot(non_legendary['HP'],hist=False,color='red',kde_kws={\"shade\": True},ax=axes[0][0])\n\nsns.distplot(legendary['DEFENSE'],hist=False,color='blue',kde_kws={\"shade\": True},ax=axes[0][2])\nsns.distplot(non_legendary['DEFENSE'],hist=False,color='red',kde_kws={\"shade\": True},ax=axes[0][2])\n\nsns.distplot(legendary['SP. ATK'],hist=False,color='blue',kde_kws={\"shade\": True},ax=axes[1][0])\nsns.distplot(non_legendary['SP. ATK'],hist=False,color='red',kde_kws={\"shade\": True},ax=axes[1][0])\n\nsns.distplot(legendary['SP. DEF'],hist=False,color='blue',kde_kws={\"shade\": True},ax=axes[1][1])\nsns.distplot(non_legendary['SP. DEF'],hist=False,color='red',kde_kws={\"shade\": True},ax=axes[1][1])\n\nsns.distplot(legendary['SPEED'],hist=False,color='blue',kde_kws={\"shade\": True},ax=axes[1][2])\nsns.distplot(non_legendary['SPEED'],hist=False,color='red',kde_kws={\"shade\": True},ax=axes[1][2])\n\n\n#Grid's used to make 3 times bigger the TOTAL density plot at the end\ngs1 = gridspec.GridSpec(3, 1)\nax1 = fig.add_subplot(gs1[2,:])\n\n\nsns.distplot(legendary['TOTAL'],hist=False,color='blue',kde_kws={\"shade\": True},ax=ax1)\nsns.distplot(non_legendary['TOTAL'],hist=False,color='red',kde_kws={\"shade\": True},ax=ax1)\n\naxes[2,0].axis('off')\naxes[2,1].axis('off')\naxes[2,2].axis('off')\n\n\n\nfig.legend(labels=['LEGENDARY','NON-LEGENDARY'],loc=4)\n\nplt.tight_layout()\nplt.show()\ngs1.tight_layout(fig)","caf46eef":"def poke_box_HP():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"HP\",\n            data=df)\n    #dragon_quan = df[df['TYPE 1']=='Dragon']['hp'].quantile(.75).round()\n    #In some cases it does accept float , if that's the case, use round()\n    \n    plt.axvline(df[df['TYPE 1']=='Dragon']['HP'].quantile(.5), ls='--', linewidth=1, color='red')\n    plt.text( (df[df['TYPE 1']=='Dragon']['HP']-14).quantile(.5),18,'Median\/Q2')\n    \n    \n    \nplt.tight_layout()\npoke_box_HP()","9bf84070":"def poke_box_attack():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"ATTACK\",\n            data=df)\n    #dragon_quan = df[df['TYPE 1']=='Dragon']['ATTACK'].quantile(.75).round()\n    #In some cases it does accept \n    plt.axvline(df[df['TYPE 1']=='Dragon']['ATTACK'].quantile(.5), ls='--', linewidth=1, color='red')\n    plt.text( (df[df['TYPE 1']=='Dragon']['ATTACK']-10).quantile(.5),18,'Median\/Q2')\n    plt.tight_layout()\npoke_box_attack()","f2b63de7":"def poke_box_defense():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"DEFENSE\",\n            data=df)\n    \n    plt.axvline(df[df['TYPE 1']=='Steel']['DEFENSE'].quantile(.5), ls='--', linewidth=1, color='red')\n    plt.text( (df[df['TYPE 1']=='Steel']['DEFENSE']-12).quantile(.5),18,'Median\/Q2')\n    \nplt.tight_layout()\npoke_box_defense()","f0cc5813":"def poke_box_sp_attack():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"SP. ATK\",\n            data=df)    \n    plt.axvline(df[df['TYPE 1']=='Dragon']['SP. ATK'].quantile(.5), ls='--', linewidth=1, color='red')\n    plt.text( (df[df['TYPE 1']=='Dragon']['SP. ATK']-2).quantile(.5),18,'Q2')\n    \nplt.tight_layout()\npoke_box_sp_attack()","eff981b7":"def poke_box_sp_defense():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"SP. DEF\",\n            data=df)\n    \n    plt.axvline(df[df['TYPE 1']=='Psychic']['SP. DEF'].quantile(.5), ls='--', linewidth=1, color='red')\n    plt.text( (df[df['TYPE 1']=='Psychic']['SP. DEF']-14).quantile(.5),18,'Median\/Q2')\n\n    \nplt.tight_layout()\npoke_box_sp_defense()","82391e1d":"def poke_box_speed():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"SPEED\",\n            data=df)\n    plt.axvline(df[df['TYPE 1']=='Flying']['SPEED'].quantile(.5), ls='--', linewidth=1, color='red')\n    plt.text( (df[df['TYPE 1']=='Flying']['SPEED']-10).quantile(.5),18,'Median\/Q2')\n    plt.tight_layout()\npoke_box_speed()","67f6c513":"def poke_box_total():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"TOTAL\",\n            data=df)\n    plt.axvline(df[df['TYPE 1']=='Dragon']['TOTAL'].quantile(.5), ls='--', linewidth=1, color='red')\n    plt.text( (df[df['TYPE 1']=='Dragon']['TOTAL']-10).quantile(.5),17,'Median\/Q2')\n    plt.tight_layout()\npoke_box_total()","7802b535":"def poke_box_total_hue():\n    fig = plt.figure()\n    ax = sns.boxplot(y=\"TYPE 1\", x=\"TOTAL\",hue='LEGENDARY',\n            data=df)\n   \n   \n    plt.tight_layout()\npoke_box_total_hue()","3eb1bbff":"def top10_per_stat():\n        fig,ax = plt.subplots(7,figsize=(15,40))\n        \n        #First barplot HP\n        \n        top_5_HP= df[df['LEGENDARY']==False].sort_values(by='HP',ascending=False).iloc[:5,3]\n        ax[0].bar( top_5_HP.index, top_5_HP.values)\n        for i in range( top_5_HP.shape[0]):\n            ax[0].text(i,  top_5_HP.values[i]+1,  top_5_HP.values[i], horizontalalignment='center')\n        ax[0].set_xlabel('Pokemons')\n        ax[0].set_ylabel('HP')\n        ax[0].set_title('Top 5 Pokemons by HP')\n       \n        #Second barplot Attack\n        \n        top_5_ATTACK= df[df['LEGENDARY']==False].sort_values(by='ATTACK',ascending=False).iloc[:5,4]\n        ax[1].bar( top_5_ATTACK.index, top_5_ATTACK.values,color='red')\n        for i in range( top_5_ATTACK.shape[0]):\n            ax[1].text(i,  top_5_ATTACK.values[i]+1,  top_5_ATTACK.values[i], horizontalalignment='center')\n        ax[1].set_xlabel('Pokemons')\n        ax[1].set_ylabel('ATTACK')\n        ax[1].set_title('Top 5 Pokemons by ATTACK')\n        \n        #Third barplot Defense\n        \n        top_5_DEFENSE= df[df['LEGENDARY']==False].sort_values(by='DEFENSE',ascending=False).iloc[:5,5]\n        ax[2].bar( top_5_DEFENSE.index, top_5_DEFENSE.values,color='yellow')\n        for i in range( top_5_DEFENSE.shape[0]):\n            ax[2].text(i,  top_5_DEFENSE.values[i]+1,  top_5_DEFENSE.values[i], horizontalalignment='center')\n        ax[2].set_xlabel('Pokemons')\n        ax[2].set_ylabel('DEFENSE')\n        ax[2].set_title('Top 5 Pokemons by DEFENSE')\n        \n        #Forth barplot Spe.Atk\n        \n        top_5_SP_ATK= df[df['LEGENDARY']==False].sort_values(by='SP. ATK',ascending=False).iloc[:5,6]\n        ax[3].bar( top_5_SP_ATK.index, top_5_SP_ATK.values,color='c')\n        for i in range( top_5_SP_ATK.shape[0]):\n            ax[3].text(i,  top_5_SP_ATK.values[i]+1,  top_5_SP_ATK.values[i], horizontalalignment='center')\n        ax[3].set_xlabel('Pokemons')\n        ax[3].set_ylabel('SP. ATK')\n        ax[3].set_title('Top 5 Pokemons by SP. ATK')\n        \n        #Fifth barplot Spe.Def\n        \n        top_5_SP_DEF= df[df['LEGENDARY']==False].sort_values(by='SP. DEF',ascending=False).iloc[:5,7]\n        ax[4].bar( top_5_SP_DEF.index, top_5_SP_DEF.values,color='g')\n        for i in range( top_5_SP_DEF.shape[0]):\n            ax[4].text(i,  top_5_SP_DEF.values[i]+1,  top_5_SP_DEF.values[i], horizontalalignment='center')\n        ax[4].set_xlabel('Pokemons')\n        ax[4].set_ylabel('SP. DEF')\n        ax[4].set_title('Top 5 Pokemons by SP. DEF')\n        \n        #Sixth barplot\n         \n        top_5_SPEED= df[df['LEGENDARY']==False].sort_values(by='SPEED',ascending=False).iloc[:5,8]\n        ax[5].bar( top_5_SPEED.index, top_5_SPEED.values,color='olive')\n        for i in range( top_5_SPEED.shape[0]):\n            ax[5].text(i,  top_5_SPEED.values[i]+1,  top_5_SPEED.values[i], horizontalalignment='center')\n        ax[5].set_xlabel('Pokemons')\n        ax[5].set_ylabel('SPEED')\n        ax[5].set_title('Top 5 Pokemons by SPEED')\n        \n        #Seventh barplot\n        \n        top_5_TOTAL= df[df['LEGENDARY']==False].sort_values(by='TOTAL',ascending=False).iloc[:5,2]\n        ax[6].bar( top_5_TOTAL.index, top_5_TOTAL.values,color='orange')\n        for i in range( top_5_TOTAL.shape[0]):\n            ax[6].text(i,  top_5_TOTAL.values[i]+1,  top_5_TOTAL.values[i], horizontalalignment='center')\n        ax[6].set_xlabel('Pokemons')\n        ax[6].set_ylabel('TOTAL')\n        ax[6].set_title('Top 5 Pokemons by TOTAL')\n        \n        plt.tight_layout()\ntop10_per_stat()","2a329c79":"def poke_box_total_hue_generation():\n    \n    print('Mean of the TOTAL, first generation : \\n',df[df['GENERATION']==1]['TOTAL'].mean())\n    print('Mean of the TOTAL, second generation : \\n',df[df['GENERATION']==2]['TOTAL'].mean())\n    print('Mean of the TOTAL, third generation : \\n',df[df['GENERATION']==3]['TOTAL'].mean())\n    print('Mean of the TOTAL, forth generation : \\n',df[df['GENERATION']==4]['TOTAL'].mean())\n    print('Mean of the TOTAL, fifth generation : \\n',df[df['GENERATION']==5]['TOTAL'].mean())\n    print('Mean of the TOTAL, sixth generation : \\n',df[df['GENERATION']==6]['TOTAL'].mean())\n\n    fig = plt.figure(figsize=(12,8))\n    ax = sns.violinplot(x=\"TOTAL\", y=\"GENERATION\",\n            data=df,orient='h')\n    plt.title('Best generation')\n    plt.tight_layout()\npoke_box_total_hue_generation()","2a1b3d64":"def number_by_generation():\n    print('Number of Pokemon for generations, first generation : \\n',df[df['GENERATION']==1]['TYPE 1'].count())\n    print('Mean of the TOTAL, second generation : \\n',df[df['GENERATION']==2]['TYPE 1'].count())\n    print('Mean of the TOTAL, third generation : \\n',df[df['GENERATION']==3]['TYPE 1'].count())\n    print('Mean of the TOTAL, forth generation : \\n',df[df['GENERATION']==4]['TYPE 1'].count())\n    print('Mean of the TOTAL, fifth generation : \\n',df[df['GENERATION']==5]['TYPE 1'].count())\n    print('Mean of the TOTAL, sixth generation : \\n',df[df['GENERATION']==6]['TYPE 1'].count())\n    \n    fig,ax = plt.subplots(2,figsize=(15,15))\n    sns.countplot(x=\"TYPE 1\",hue='GENERATION', data=df,ax=ax[1])\n    sns.countplot(x=\"GENERATION\", data=df,ax=ax[0])\n    ax[0].set_title('Number of Pokemon for generations')\n    ax[1].set_title('Number of Pokemon for generations and Type of Pokemon')\nnumber_by_generation()","0c9880c1":"def numb_legendary_pokemons():\n    print('Number of LEGENDARY POKEMONS For the first generation : \\n',df[(df['LEGENDARY']==True)&(df['GENERATION']==1)]['TYPE 1'].count())\n    print('Number of LEGENDARY POKEMONS For the second generation : \\n',df[(df['LEGENDARY']==True)&(df['GENERATION']==2)]['TYPE 1'].count())\n    print('Number of LEGENDARY POKEMONS For the third generation : \\n',df[(df['LEGENDARY']==True)&(df['GENERATION']==3)]['TYPE 1'].count())\n    print('Number of LEGENDARY POKEMONS For the forth generation : \\n',df[(df['LEGENDARY']==True)&(df['GENERATION']==4)]['TYPE 1'].count())\n    print('Number of LEGENDARY POKEMONS For the fifth generation : \\n',df[(df['LEGENDARY']==True)&(df['GENERATION']==5)]['TYPE 1'].count())\n    print('Number of LEGENDARY POKEMONS For the sixth generation : \\n',df[(df['LEGENDARY']==True)&(df['GENERATION']==6)]['TYPE 1'].count())\n\n    fig,ax = plt.subplots(2,figsize=(15,15),dpi=200)\n    sns.countplot(data=df,x='GENERATION',hue='LEGENDARY',ax=ax[0])\n    sns.countplot(data=df,x='TYPE 1',hue='LEGENDARY',ax=ax[1] )\n    \nnumb_legendary_pokemons()","2a378940":"**Let's quickly compare both LEGENDARY and Non-LEGENDARY Pokemons using boxplots:**","b80e2dd2":"<a id=\"1.2\"><\/a>\n### 1.2. Basic Summary of the data ","fa9cd62d":"**Wow, huge surprise that the most common combination of Pokemon types 1 and type 2 is Normal-Flying, followed by the Grass-Poison type.**\n\n**How many combinations of type 1 and type 2 exist?**","05f2127b":"**This time the psychic type beats the dragon type, having practically the same median and the psychic type having the highest Q3.**","0e7e631b":"<a id=\"3.6\"><\/a>\n### 3.6. Best Type for each variable\n\n**Let's determine what the best type of Pokemon for each variable using Boxplots**\n","e036fd92":"<a id=\"5.\"><\/a>\n## 5. References","95ea086b":"**In total there are 136 combinations between TYPE1 and TYPE 2 Pokemons**\n\n**Given the 136 and for the purpose of simplicity, let's plot the top 10 most common combinations found.**","bcc37122":"<a id=\"1.\"><\/a>\n\n## 1. Basic info from the Dataset","10f36ac2":"<a id=\"3.8\"><\/a>\n### 3.8. Comparing Pokemon's Generations","1ccd862c":"**Once again the dragon type seems to have on average the strongest attacks, having the highest median and the highest Q3.**","67d75e75":"**It's worth mentioning We could've used Seaborn to plot both columns TYPE 1 and TYPE 2, here's a quick example.**","d446f139":"<a id=\"3.4\"><\/a>\n### 3.4. Distribution for Legendary and non-Legendary Pokemons","e3d8f04e":"* [1. Basic Information from the Dataset.](#1.)\n    - [1.1. Variable information.](#1.1)\n    - [1.2. Basic summary of the dataset.](#1.2)\n* [2.Cleaning the DataFrame.](#2.)\n* [3.Data analysis.](#3.)\n    - [3.1. Type 1.](#3.1)\n    - [3.2. Type 1-2.](#3.2)\n    - [3.3. Type 1-2 Combined.](#3.3)\n    - [3.4. Distribution for Legendary and non-Legendary Pokemons.](#3.4)\n    - [3.5. Density plots LEGENDARY VS NON-LEGENDARY Pokemons.](#3.5)\n    - [3.6. Best Type for each variable.](#3.6)\n    - [3.7. TOP 10 Pokemons per stat.](#3.7)\n    - [3.8. Comparing Pokemon's Generations.](#3.8)\n    - [3.9. Number of Pokemons by generation.](#3.9)\n    - [3.10. Number of Legendary Pokemons by Generation.](#3.10)\n* [4. Summary.](#4.)\n* [5. References.](#5.)","bae25fe6":"<a id=\"3.3\"><\/a>\n### 3.3. Type 1-2 Combined","6e0d74ce":"**The following books**\n\n   **1. Wes McKinney(2017),Python for Data Analysis, 2nd Edition**\n    \n   **2. Jake VanderPlas(2016),Python Data Science Handbook: Essential Tools for Working with Data**\n   \n   **3. Andrew Bruce(2017),Practical Statistics for Data Scientists: 50+ Essential Concepts Using R and Python**\n    \n   **4. Hands-On Exploratory Data Analysis with Python: Perform EDA techniques to understand, summarize, and investigate your data by Suresh Kumar Mukhiya and Usman Ahmed.**\n\n**And the following notebooks served as reference as well:**\n   \n   **1. Plotting with Python: learn 80 plots STEP by STEP: https:\/\/www.kaggle.com\/python10pm\/plotting-with-python-learn-80-plots-step-by-step**\n   \n   **2. Analyzing a Pok\u00e9mon data set (My first kernel) by the great Xavier Vivancos : https:\/\/www.kaggle.com\/xvivancos\/analyzing-a-pok-mon-data-set-my-first-kernel#header**\n    \n   **3.Learn Pandas with Pokemons by Ashwini Swain: https:\/\/www.kaggle.com\/ash316\/learn-pandas-with-pokemons**\n\n\n","d4e2c5d8":"**Now let's follow the same procedure for LEGENDARY POKEMONS**","bdc962b0":"<a id=\"3.2\"><\/a>\n### 3.2. Type 2","388cb3d0":"**Undoubtedly the Legendary Pokemons are far better than the non-Legendary Pokemons.**","7bf131d1":"**Undoubtedly the flying type are is the speediest type of Pokemon having the highest median and Q3 and also their data is grouped tightly, meaning the standard deviation is surely not much.**","ae3ffe80":"**In the data analysis section,  We'll be analyzing the characteristics and employing  data visualization methods?**","33e5692b":"In this section I'll focus on getting the basic insights out of the data to get a general sense of what We are working with.","0f079b1a":"**Let's classify quickly who the strongest Pokemons by each variable\/stat :**\n\n*Legendary Pokemons were not included*","f194b433":"<a id=\"3.5\"><\/a>\n### 3.5. Density plots LEGENDARY VS NON-LEGENDARY Pokemons.\n\n**Now let's compare them more closely using density plots and Seaborn**","dd2a930c":"**The psychic type and the dragon type have on average the best SP.ATK. In the pokemon series. **","7b7a7b34":"**Hello Kaggle, this is my first ever kernel after been a longtime lurker in this platform , I've put a lot effort into it and been inspired by many others notebooks which I'll mention and the end of this Kernel.**","7aa92045":"<a id=\"2.\"><\/a>\n## 2. Cleaning the DataFrame","9be7e073":"**The dragon type seems to have the higher HP with the highest median\/Q2 and surely the highest mean. The outliers are LEGENDARY Pokemons.**","82aa1ce0":"**Now let's proceed to analyze what the best generations are using the Violin Plot and the variable TOTAL**","e09e9b5a":"**Once the all the columns have been changed to Uppercase letters, let's proceed with the removal of some unnecessary repetitive words, specifically the Mega prefix in the Name column. Then We'll proceed to set a new index, meaning changing the column 'NAME' to be the new index**","9cd38429":"**It's quite clear that the best Pokemons came from the 4th generation,having the highest mean and median, therefore concluding the strongest Pokemons on average belong to the 4th Generation of Pokemons.**","0c320a43":"<a id=\"1.1\"><\/a>\n### 1.1.  Variable Information","3a8ad139":"<a id=\"4.\"><\/a>\n## 4. Summary\n\n   *1. Regarding the basic info from the dataset, everything was in order except the NaN values   due to some Pokemons having only one type.*** \n    \n   *2. There are many takeaways from the Data Analysis section: the number of types of Pokemon was the same in both Type 1 and Type 2, with the only difference of the NaN values. When combined both types, there are 136 different combinations of types of Pokemons, being the Flying-Normal the most common combination with 24. The distribution and density plots made it clear that the Legendary Pokemons were far stronger than the non-Legendary Pokemons. When reviewing what the best type of Pokemon for each variable , It was concluded that the Pokemon Type were the strongest on average.**\n    \n   *3. When comparing the six different Generations of Pokemons, It was concluded the 4 Generation had on average the strongest Pokemons and that in the first and fifth Generation the most Pokemons were integrated.*","50660174":"**Finally, after comparing all the Pokemons in each variable, and also with the final and best indicator, We are able to conclude the dragon type is the strongest type of Pokemon in the videogame series, except in Flying and Defense type.**","6aad8806":"**We are able to observe that the type Water, followed  by the Normal type of Pokemons, are the largest in the column TYPE 1.** \n\n**Now that the first questions regarding the column TYPE 1, let's follow the same procedure with the second column, TYPE 2**","5d46cfec":"**We can to observe that the type Flying, followed closely by the Ground type of Pokemon, are the largest in the column TYPE 2.**\n\n**Regarding the type of Pokemons in columns TYPE 1 and TYPE 2 the only remarkable difference is the presence of Nan values in the column  TYPE 2, as mentioned before, It's due to fact that some Pokemons don't really have a second type.**\n","016c0c55":"**Out of all the info something that jumps out immediately is the 414 non null values in TYPE 2, that is something due to the fact that many Pokemons don't really have a second TYPE,only type such as grass, water etc. Except the 386 NaN values in TYPE 2, everything else seems to be sorted.**","35414bed":"**Now let's go through some histograms to analyze 7 different variables from 'TOTAL' to 'ATTACK (FOR NON LEGENDARY POKEMONS)'**","610adbcc":"<a id=\"3.7\"><\/a>\n### 3.7. TOP 10 Pokemons per stat.","5fe4f663":"**The density plots clearly show the LEGENDARY POKEMONS have overall greater stats than the non-LEGENDARY POKEMONS.**","b732d90e":"<a id=\"3.1\"><\/a>\n### 3.1. Type 1\n\n**How many different types of Pokemons are there in the TYPE 1 column?**\n","7fa2d92e":"<a id=\"3.10\"><\/a>\n### 3.10. Number of Legendary Pokemons by Generation","08d35867":"**The steel type is the strongest type of Pokemon regarding DEFENSE, having the median higher than Q3 of all the other types and of course having the highest mean and Q3**","42332cd5":"![image.png](attachment:image.png)","fc429307":"<a id=\"3.9\"><\/a>\n### 3.9. Number of Pokemons by generation","354cf339":"**We knew before hand that the LEGENDARY Pokemons were stronger than non legendary Pokemons but the histograms clearly confirm that case** \n","d4b02c1f":"**Now let's proceed to combine both TYPE 1 and TYPE 2 columns to extract as much information as possible.**","1d587639":"**#**: Each Pokemon's ID.\n\n**Name**: Name of each pokemon\n\n**Type 1**: The primary type of each Pokemon which determines their strengths and weaknesses.\n\n**Type 2**: The secundary type for each Pokemon, which determines their secondary strengths and weaknesses.\n\n**Total**: The sum of all the other stats \n\n**HP**: hit points, or health, defines how much damage a pokemon can withstand before fainting.\n\n**Attack**: the base modifier for normal attacks (eg. Scratch, Punch).\n\n**Defense**: the base damage resistance against normal attacks.\n\n**SP Atk**: special attack, the base modifier for special attacks (e.g. fire blast, bubble beam).\n\n**SP Def**: the base damage resistance against special attacks.\n\n**Speed**: determines which pokemon attacks first each round.","93750e1d":"Let's proceed to do a Data cleaning, meaning the process of fixing or removing incorrect, corrupted, incorrectly formatted, duplicate, or incomplete data within the dataset.\nWhen combining multiple data sources, there are many opportunities for data to be duplicated or mislabeled. If data is incorrect, outcomes and algorithms are unreliable.\n\n**Let's start with making all the columns uppercase so that when they are called We won't be constantly going from uppercase to lowercase**","00057cb1":"**From the dataset W have been able to draw the following premiliminary conclusions  :** \n\n   1. This dataset is related the **Pokemon** videogame series having 12 **variables** and 800 **observations** throughout 6 generations across different consoles such as DS, Gamecube, Nintendo 64, Nintendo Switch etc.\n   \n   \n   2. Regarding the dataset, as mentioned before except for **386 NaN** values in TYPE 2 the rest of dtypes seem perfect and there are different types of data available such as **booleans(LEGENDARY column),integers and objects.**\n   \n   \n   3. Descriptive analysis shows there aren't any unexplainable data values such as 0 max values or 0 minimum values, therefore the Dataset is perfect.\n        ","036da7b1":"<a id=\"3.\"><\/a>\n## 3. Data Analysis","183cfc63":"**Let's observe both the TYPE 1 and TYPE 2 Pokemons in a stacked Barplot**"}}