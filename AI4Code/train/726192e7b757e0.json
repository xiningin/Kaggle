{"cell_type":{"b81dde32":"code","e58b53b7":"code","f3fa7a52":"code","067a874d":"code","118bedb3":"code","8a22a4ad":"code","8e57be1b":"code","dbe590a2":"code","60f455c2":"code","21f95e25":"code","a3e07392":"code","887c8e75":"code","1d69adc8":"code","e3818755":"markdown","8e504f4b":"markdown"},"source":{"b81dde32":"import time\nimport os\nimport skimage.io\nimport numpy as np\nimport pandas as pd\nimport cv2\nimport rasterio\nfrom rasterio.windows import Window\nimport matplotlib.pyplot as plt\n#from tqdm import tqdm_notebook as tqdm\nfrom tqdm.notebook import tqdm\n#from lookahead import Lookahead\n#from radam import *\nfrom utils import rle_decode, make_grid","e58b53b7":"data_dir = 'E:\/data\/hubmap-kidney-segmentation\/'\n\ntiledir = 'E:\/data\/hubmap-kidney-segmentation\/tiles\/'\n\nimage_size = 1024\noverlap = 128\nthreshold = 0\ncontent_threshold = 0.2","f3fa7a52":"def read_from_slice(dataset, x1, x2, y1, y2):\n    if dataset.count == 3:\n        image = dataset.read([1, 2, 3], window=Window.from_slices((x1, x2), (y1, y2)))\n        image = np.moveaxis(image, 0, -1)\n    else:\n        subdatasets = dataset.subdatasets\n        if len(subdatasets) > 0:\n            image = np.zeros((image_size, image_size, len(subdatasets)), dtype=np.uint8)\n            for i, subdataset in enumerate(subdatasets, 0):\n                with rasterio.open(subdataset) as layer:\n                    image[:,:,i] = layer.read(1, window=Window.from_slices((x1, x2), (y1, y2)))\n    return image","067a874d":"# https:\/\/www.kaggle.com\/gilfernandes\/pytorch-unet-efficientnet-b6-1024-2shifted-slices\n# Used to filter tiles with enough color information in it\ndef is_tile_contains_info(img, pixel_limits=(50, 220), content_threshold=content_threshold, expected_shape=(image_size, image_size, 3)):\n    \"\"\"\n    img: np.array\n    pixel_limits: tuple\n    content_threshold: float percents\n    expected_shape: tuple\n    \"\"\"\n    \n    left_limit = np.prod(img > pixel_limits[0], axis=-1)\n    right_limit =  np.prod(img < pixel_limits[1], axis=-1)\n\n    if img.shape != expected_shape:\n        print('img.shape != expected_shape', img.shape)\n        return False, 0.\n\n    percent_of_pixels = np.sum(left_limit*right_limit) \/ (img.shape[0] * img.shape[1])\n    return  percent_of_pixels > content_threshold, percent_of_pixels","118bedb3":"df = pd.read_csv(data_dir + 'train.csv');df.shape","8a22a4ad":"df = df.set_index('id')","8e57be1b":"identity = rasterio.Affine(1, 0, 0, 0, 1, 0)\nskipped = 0\nvalid = 0\nfor i, filename in enumerate(tqdm(df.index.values, desc=\"build_slices\")):\n    filename = filename.split('.')[0]\n    os.makedirs(tiledir + filename + '\/images\/', exist_ok=True)\n    os.makedirs(tiledir + filename + '\/masks\/', exist_ok=True)\n    filepath = os.path.join(data_dir, 'train', filename + '.tiff')\n    with rasterio.open(filepath, transform=identity) as dataset:\n        masks = rle_decode(df.loc[filename, 'encoding'], dataset.shape)\n        slices = make_grid(dataset.shape, window=image_size, min_overlap=overlap)\n        for slc in slices:\n            x1, x2, y1, y2 = slc\n            tile = read_from_slice(dataset, x1, x2 , y1, y2)\n            mask = masks[x1:x2, y1:y2]\n            info = is_tile_contains_info(tile)\n            if mask.sum() > threshold or info[0]:  # those has mask piexls > threshold AND those has mask piexls < threshold, but has color info, usefull for aug\n                cv2.imwrite(os.path.join(tiledir, filename, 'images', f'{filename}_{valid}.png'), tile)\n                cv2.imwrite(os.path.join(tiledir, filename, 'masks', f'{filename}_{valid}.jpg'), mask*255)\n                # npy is faster for loading\n                #np.save(os.path.join(tiledir, filename, 'images', f'{filename}_{valid}.npy'), tile)\n                #np.save(os.path.join(tiledir, filename, 'masks', f'{filename}_{valid}.npy'), mask*255)\n                valid += 1\n#             elif  info[0]:  # only those has mask piexls < threshold, but has color info, usefull for aug\n#                 cv2.imwrite(os.path.join(tiledir, filename, 'images', f'{filename}_{number}.png'), tile)\n#                 cv2.imwrite(os.path.join(tiledir, filename, 'masks', f'{filename}_{number}.jpg'), mask)\n#                 valid += 1\n            else:\n                skipped += 1\nprint(f'skiped: {skipped}, total: {valid}')","dbe590a2":"# 0.08: skip: 18423, valid: 55741\n# 0.1: skip: 18670, valid: 55494\n# 0.2: skip: 19559, valid: 54605","60f455c2":"# 1024 - 128\n# skiped: 5333, total: 16045","21f95e25":"folders = os.listdir(tiledir)","a3e07392":"tiff_id = []\nimage_id = []\npth = []\n\nfor folder in folders:\n    sub_pth = os.path.join(tiledir, folder)\n    image_pth = os.path.join(sub_pth, 'images')\n    image_files = os.listdir(image_pth)\n    for image_file in image_files:\n        tiff_id.append(folder)\n        image_id.append(image_file.split('.')[0])\n        pth.append(os.path.join(image_pth, image_file))\n        \ndf = pd.DataFrame({\n    'id':tiff_id,\n    'image_id':image_id,\n    'path':pth\n})\n\ndf.to_csv(f'disk_train_{image_size}-{overlap}.csv', index=False)","887c8e75":"from sklearn.model_selection import GroupKFold","1d69adc8":"#df = pd.read_csv('disk_train.csv')\ngfold = GroupKFold(n_splits=5)\ndf['fold'] = -1\nfor fold, (tr_idx, val_idx) in enumerate(gfold.split(df, groups=df.id.values)):\n    df.loc[val_idx, 'fold'] = fold\n\ndf.to_csv(f'disk_folds_{image_size}-{overlap}.csv', index=False)","e3818755":"## make fold","8e504f4b":"# Config"}}