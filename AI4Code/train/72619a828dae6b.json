{"cell_type":{"a12be26b":"code","3c3aeb1f":"code","06fe0581":"code","741353e2":"code","3ba4f279":"code","8257485f":"code","00bab7b5":"code","a6d7bcee":"code","5e0595db":"code","128b4bb3":"markdown","b6cae886":"markdown","540b96d7":"markdown","88caa076":"markdown"},"source":{"a12be26b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","3c3aeb1f":"inputs = [\n({'level':'Senior', 'lang':'Java', 'tweets':'no', 'phd':'no'},     False),\n({'level':'Senior', 'lang':'Java', 'tweets':'no', 'phd':'yes'},    False),\n({'level':'Mid', 'lang':'Python', 'tweets':'no', 'phd':'no'},      True),\n({'level':'Junior', 'lang':'Python', 'tweets':'no', 'phd':'no'},   True),\n({'level':'Junior', 'lang':'R', 'tweets':'yes', 'phd':'no'},       True),\n({'level':'Junior', 'lang':'R', 'tweets':'yes', 'phd':'yes'},      False),\n({'level':'Mid', 'lang':'R', 'tweets':'yes', 'phd':'yes'},         True),\n({'level':'Senior', 'lang':'Python', 'tweets':'no', 'phd':'no'},   False),\n({'level':'Senior', 'lang':'R', 'tweets':'yes', 'phd':'no'},       True),\n({'level':'Junior', 'lang':'Python', 'tweets':'yes', 'phd':'no'},  True),\n({'level':'Senior', 'lang':'Python', 'tweets':'yes', 'phd':'yes'}, True),\n({'level':'Mid', 'lang':'Python', 'tweets':'no', 'phd':'yes'},     True),\n({'level':'Mid', 'lang':'Java', 'tweets':'yes', 'phd':'no'},       True),\n({'level':'Junior', 'lang':'Python', 'tweets':'no', 'phd':'yes'},  False)\n]\n\nfrom collections import defaultdict\nfrom collections import Counter\nfrom functools import partial\nimport math\n\ndef entropy(class_probabilities):\n    \"\"\"dada uma lista de probabilidades de classe, compute a entropia\"\"\"\n    return sum(-p * math.log(p, 2)\n               for p in class_probabilities if p) # ignora probabilidades zero\n\ndef class_probabilities(labels):\n    total_count = len(labels)\n    return [count \/ total_count\n          for count in Counter(labels).values()]\n\ndef data_entropy(labeled_data):\n    labels = [label for _, label in labeled_data]\n    probabilities = class_probabilities(labels)\n    return entropy(probabilities)\n\ndef partition_entropy(subsets):\n    \"\"\"encontre a entropia desta divis\u00e3o de dados em subconjuntos\n    subconjunto \u00e9 uma lista de listas de dados rotulados\"\"\"\n    total_count = sum(len(subset) for subset in subsets)\n    return sum( data_entropy(subset) * len(subset) \/ total_count\n               for subset in subsets )\n\ndef partition_by(inputs, attribute):\n    \"\"\"cada entrada \u00e9 um par (attribute_dict, label).\n    retorna uma dict: attribute_value ->inputs\"\"\"\n    groups = defaultdict(list)\n    for input in inputs:\n          key = input[0][attribute]  # pega o valor do atributo especificado\n          groups[key].append(input)  # ent\u00e3o adiciona essa entrada \u00e0 lista correta\n    return groups\n\ndef partition_entropy_by(inputs, attribute):\n    \"\"\"computa a entropia correspondente \u00e0 parti\u00e7\u00e3o dada\"\"\"\n    partitions = partition_by(inputs, attribute)\n    return partition_entropy(partitions.values())\n\nfor key in ['level','lang','tweets','phd']:\n    print (key, partition_entropy_by(inputs, key))","06fe0581":"senior_inputs = [(input, label)\n                 for input, label in inputs if input[\"level\"] == \"Senior\"]\n\nfor key in ['lang', 'tweets', 'phd']:\n    print (key, partition_entropy_by(senior_inputs, key))","741353e2":"def classify(tree, input):\n    \"\"\"classifica a entrada usando a \u00e1rvore de decis\u00e3o fornecida\"\"\"\n    # se for um n\u00f3 folha, retorna seu valor\n    if tree in [True, False]:\n        return tree\n    # sen\u00e3o, esta \u00e1rvore consiste de uma caracter\u00edstica para dividir\n    # e um dicion\u00e1rio cujas chaves s\u00e3o valores daquela caracter\u00edstica\n    # e cujos valores s\u00e3o sub-\u00e1rvores para considerar depois\n    attribute, subtree_dict = tree\n    subtree_key = input.get(attribute)   # None se estiver faltando caracter\u00edstica\n    if subtree_key not in subtree_dict:  # se n\u00e3o h\u00e1 sub-\u00e1rvore para chave,\n        subtree_key = None            # usaremos a sub-\u00e1rvore None\n    subtree = subtree_dict[subtree_key]  # escolha a sub-\u00e1rvore apropriada\n    return classify(subtree, input)     # e use para classificar a entrada\n\ndef build_tree_id3(inputs, split_candidates=None):\n    # se este \u00e9 nosso primeiro passo,\n    # todas as chaves da primeira entrada s\u00e3o candidatos divididos\n    if split_candidates is None:\n        split_candidates = inputs[0][0].keys()\n    # conta Trues e Falses nas entradas\n    num_inputs = len(inputs)\n    num_trues = len([label for item, label in inputs if label])\n    num_falses = num_inputs - num_trues\n    if num_trues == 0: return False      # nenhum True? Retorne uma folha \u201cFalse\u201d\n    if num_falses == 0: return True      # nenhum False? Retorne uma folha \u201cTrue\u201d\n    if not split_candidates:             # se n\u00e3o houver mais candidatos a dividir\n        return num_trues >= num_falses   # retorne a folha majorit\u00e1ria\n    # sen\u00e3o, divida com base na melhor caracter\u00edstica\n    best_attribute = min(split_candidates,\n                         key=partial(partition_entropy_by, inputs))\n    partitions = partition_by(inputs, best_attribute)\n    new_candidates = [a for a in split_candidates\n                      if a != best_attribute]\n    # recursivamente constr\u00f3i as sub-\u00e1rvores\n    subtrees = { attribute_value : build_tree_id3(subset, new_candidates)\n                for attribute_value, subset in partitions.items() }\n    subtrees[None] = num_trues > num_falses     # caso padr\u00e3o\n    return (best_attribute, subtrees)\n\n","3ba4f279":"tree = build_tree_id3(inputs)","8257485f":"classify(tree, { \"level\" : \"Junior\",\n                \"lang\" : \"Java\",\n                \"tweets\" : \"yes\",\n                \"phd\" : \"no\"} )             # True","00bab7b5":"classify(tree, { \"level\" : \"Junior\",\n                \"lang\" : \"Java\",\n                \"tweets\" : \"yes\",\n                \"phd\" : \"yes\"} )           # False","a6d7bcee":"classify(tree, { \"level\" : \"Intern\" } ) # True","5e0595db":"classify(tree, { \"level\" : \"Senior\" } ) # False","128b4bb3":"# Juntando Tudo","b6cae886":"# Criando uma \u00c1rvore de Decis\u00e3o\nA vice-presidente forneceu dados dos entrevistados, que consistem de (por sua especifica\u00e7\u00e3o) pares (input, label) em que cada input \u00e9 um dict de caracter\u00edsticas de candidatos e cada r\u00f3tulo \u00e9 True (o candidato fez boa entrevista) ou False (o candidato fez entrevista ruim). Em espec\u00edfico, voc\u00ea possui o n\u00edvel de cada candidato, sua linguagem favorita, se \u00e9 ativo no Twitter e se possui PhD:\n\n```python\ninputs = [\n({'level':'Senior', 'lang':'Java', 'tweets':'no', 'phd':'no'},     False),\n({'level':'Senior', 'lang':'Java', 'tweets':'no', 'phd':'yes'},    False),\n({'level':'Mid', 'lang':'Python', 'tweets':'no', 'phd':'no'},      True),\n({'level':'Junior', 'lang':'Python', 'tweets':'no', 'phd':'no'},   True),\n({'level':'Junior', 'lang':'R', 'tweets':'yes', 'phd':'no'},       True),\n({'level':'Junior', 'lang':'R', 'tweets':'yes', 'phd':'yes'},      False),\n({'level':'Mid', 'lang':'R', 'tweets':'yes', 'phd':'yes'},         True),\n({'level':'Senior', 'lang':'Python', 'tweets':'no', 'phd':'no'},   False),\n({'level':'Senior', 'lang':'R', 'tweets':'yes', 'phd':'no'},       True),\n({'level':'Junior', 'lang':'Python', 'tweets':'yes', 'phd':'no'},  True),\n({'level':'Senior', 'lang':'Python', 'tweets':'yes', 'phd':'yes'}, True),\n({'level':'Mid', 'lang':'Python', 'tweets':'no', 'phd':'yes'},     True),\n({'level':'Mid', 'lang':'Java', 'tweets':'yes', 'phd':'no'},       True),\n({'level':'Junior', 'lang':'Python', 'tweets':'no', 'phd':'yes'},  False)\n]\n```","540b96d7":"![A \u00e1rvore de decis\u00e3o para contrata\u00e7\u00e3o](https:\/\/marc-queiroz.github.io\/pos-uel-big-data\/fundamentos-big-data\/images\/figura17-3-DSZ.png \"A \u00e1rvore de decis\u00e3o para contrata\u00e7\u00e3o\")","88caa076":"# O Que \u00c9 uma \u00c1rvore de Decis\u00e3o?\n\nUma \u00e1rvore de decis\u00e3o usa uma estrutura de \u00e1rvore para representar um n\u00famero de poss\u00edveis caminhos de decis\u00e3o e um resultado para cada caminho.\n\nSe voc\u00ea j\u00e1 jogou Vinte Perguntas, j\u00e1 est\u00e1 familiarizado com \u00e1rvores de decis\u00e3o. \n\nPor exemplo:\n* \u201cEstou pensando em um animal.\u201d\n* \u201cEle possui mais de cinco pernas?\u201d\n* \u201cN\u00e3o.\u201d\n* \u201c\u00c9 delicioso?\u201d\n* \u201cN\u00e3o.\u201d\n* \u201cEle aparece na parte de tr\u00e1s da moeda de cinco centavos australiana?\u201d\n* \u201cSim.\u201d\n* \u201c\u00c9 um equidna?\u201d\n* \u201cSim!\u201d\n\nIsso corresponde ao caminho:\n\n\u201cN\u00e3o mais do que 5 pernas\u201d \u2192 \u201cN\u00e3o delicioso\u201d \u2192 \u201cNa moeda de 5 centavos\u201d \u2192 \u201cEquidna!\u201d"}}