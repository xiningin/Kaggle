{"cell_type":{"61c42ad1":"code","e1d15dd0":"code","64c72545":"code","54068980":"code","c70d6074":"code","2c46ffc8":"code","327da4fc":"code","cea8a677":"code","1e174de3":"code","d2ea7246":"code","292c7b92":"code","974aaba2":"code","ee2fbc7b":"code","a76ba7ee":"code","4f13e08f":"code","99103976":"code","2d612733":"code","f187018d":"code","49418f78":"code","280ab62a":"markdown","91e65165":"markdown","2c7a11c1":"markdown","f79a31cb":"markdown","a5aa49ba":"markdown","7124f172":"markdown","202f9b1e":"markdown","d922a012":"markdown","aca5d993":"markdown","e8f32f32":"markdown","b650f806":"markdown","a2740f14":"markdown","39421ab5":"markdown","5c338fdb":"markdown","802f99d3":"markdown","885cecca":"markdown","243ed96e":"markdown","c5e1897a":"markdown","52f49f39":"markdown","787906f5":"markdown","57d297cc":"markdown","1774defd":"markdown","8a1d5201":"markdown","7bb8f4c9":"markdown","3aaa980b":"markdown","eb864fbd":"markdown"},"source":{"61c42ad1":"import os\nimport numpy as np\nimport pandas as pd\nimport xgboost as xgb\nimport matplotlib.pyplot as plt\nfrom xgboost import plot_importance, plot_tree\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.model_selection import train_test_split, GridSearchCV\n\n# Chart drawing\nimport plotly as py\nimport plotly.io as pio\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\n\n# Mute sklearn warnings\nfrom warnings import simplefilter\nsimplefilter(action='ignore', category=FutureWarning)\nsimplefilter(action='ignore', category=DeprecationWarning)\n\n# Show charts when running kernel\ninit_notebook_mode(connected=True)\n\n# Change default background color for all visualizations\nlayout=go.Layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(250,250,250,0.8)')\nfig = go.Figure(layout=layout)\ntemplated_fig = pio.to_templated(fig)\npio.templates['my_template'] = templated_fig.layout.template\npio.templates.default = 'my_template'","e1d15dd0":"from plotly.subplots import make_subplots","64c72545":"import plotly.graph_objects as go","54068980":"STOCK_NAME = 'AAPL'\nSTOCK_DIRECTORY = '..\/input\/price-volume-data-for-all-us-stocks-etfs\/Stocks\/'\n\ndf = pd.read_csv(os.path.join(STOCK_DIRECTORY, STOCK_NAME.lower() + '.us.txt'), sep=',')\n\ndf['Date'] = pd.to_datetime(df['Date'])\ndf = df[(df['Date'].dt.year >= 2010)].copy()\ndf.index = range(len(df))\n\ndf.head()","c70d6074":"fig = make_subplots(rows=2, cols=1)\n\nfig.add_trace(go.Ohlc(x=df.Date,\n                      open=df.Open,\n                      high=df.High,\n                      low=df.Low,\n                      close=df.Close,\n                      name='Price'), row=1, col=1)\n\nfig.add_trace(go.Scatter(x=df.Date, y=df.Volume, name='Volume'), row=2, col=1)\n\nfig.update(layout_xaxis_rangeslider_visible=False)\nfig.show()","2c46ffc8":"df['EMA_9'] = df['Close'].ewm(9).mean().shift()\ndf['SMA_5'] = df['Close'].rolling(5).mean().shift()\ndf['SMA_10'] = df['Close'].rolling(10).mean().shift()\ndf['SMA_15'] = df['Close'].rolling(15).mean().shift()\ndf['SMA_30'] = df['Close'].rolling(30).mean().shift()\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=df.Date, y=df.EMA_9, name='EMA 9'))\nfig.add_trace(go.Scatter(x=df.Date, y=df.SMA_5, name='SMA 5'))\nfig.add_trace(go.Scatter(x=df.Date, y=df.SMA_10, name='SMA 10'))\nfig.add_trace(go.Scatter(x=df.Date, y=df.SMA_15, name='SMA 15'))\nfig.add_trace(go.Scatter(x=df.Date, y=df.SMA_30, name='SMA 30'))\nfig.add_trace(go.Scatter(x=df.Date, y=df.Close, name='Close', opacity=0.2))\nfig.show()","327da4fc":"def relative_strength_idx(df, n=14):\n    close = df['Close']\n    delta = close.diff()\n    delta = delta[1:]\n    pricesUp = delta.copy()\n    pricesDown = delta.copy()\n    pricesUp[pricesUp < 0] = 0\n    pricesDown[pricesDown > 0] = 0\n    rollUp = pricesUp.rolling(n).mean()\n    rollDown = pricesDown.abs().rolling(n).mean()\n    rs = rollUp \/ rollDown\n    rsi = 100.0 - (100.0 \/ (1.0 + rs))\n    return rsi\n\ndf['RSI'] = relative_strength_idx(df).fillna(0)\n\nfig = go.Figure(go.Scatter(x=df.Date, y=df.RSI, name='RSI'))\nfig.show()","cea8a677":"EMA_12 = pd.Series(df['Close'].ewm(span=12, min_periods=12).mean())\nEMA_26 = pd.Series(df['Close'].ewm(span=26, min_periods=26).mean())\ndf['MACD'] = pd.Series(EMA_12 - EMA_26)\ndf['MACD_signal'] = pd.Series(df.MACD.ewm(span=9, min_periods=9).mean())\n\nfig = make_subplots(rows=2, cols=1)\nfig.add_trace(go.Scatter(x=df.Date, y=df.Close, name='Close'), row=1, col=1)\nfig.add_trace(go.Scatter(x=df.Date, y=EMA_12, name='EMA 12'), row=1, col=1)\nfig.add_trace(go.Scatter(x=df.Date, y=EMA_26, name='EMA 26'), row=1, col=1)\nfig.add_trace(go.Scatter(x=df.Date, y=df['MACD'], name='MACD'), row=2, col=1)\nfig.add_trace(go.Scatter(x=df.Date, y=df['MACD_signal'], name='Signal line'), row=2, col=1)\nfig.show()","1e174de3":"df['Close'] = df['Close'].shift(-1)","d2ea7246":"df = df.iloc[33:]\ndf = df[:-1]  \n\ndf.index = range(len(df))","292c7b92":"test_size  = 0.15\nvalid_size = 0.15\n\ntest_split_idx  = int(df.shape[0] * (1-test_size))\nvalid_split_idx = int(df.shape[0] * (1-(valid_size+test_size)))\n\ntrain_df  = df.loc[:valid_split_idx].copy()\nvalid_df  = df.loc[valid_split_idx+1:test_split_idx].copy()\ntest_df   = df.loc[test_split_idx+1:].copy()\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=train_df.Date, y=train_df.Close, name='Training'))\nfig.add_trace(go.Scatter(x=valid_df.Date, y=valid_df.Close, name='Validation'))\nfig.add_trace(go.Scatter(x=test_df.Date,  y=test_df.Close,  name='Test'))\nfig.show()","974aaba2":"drop_cols = ['Date', 'Volume', 'Open', 'Low', 'High', 'OpenInt']\n\ntrain_df = train_df.drop(drop_cols, 1)\nvalid_df = valid_df.drop(drop_cols, 1)\ntest_df  = test_df.drop(drop_cols, 1)","ee2fbc7b":"y_train = train_df['Close'].copy()\nX_train = train_df.drop(['Close'], 1)\n\ny_valid = valid_df['Close'].copy()\nX_valid = valid_df.drop(['Close'], 1)\n\ny_test  = test_df['Close'].copy()\nX_test  = test_df.drop(['Close'], 1)\n\nX_train.info()","a76ba7ee":"parameters = {\n    'n_estimators': [100, 200, 300, 400],\n    'learning_rate': [0.001, 0.005, 0.01, 0.05],\n    'max_depth': [8, 10, 12, 15],\n    'gamma': [0.001, 0.005, 0.01, 0.02],\n    'random_state': [42]\n}\n\neval_set = [(X_train, y_train), (X_valid, y_valid)]\nmodel = xgb.XGBRegressor(eval_set=eval_set, objective='reg:squarederror', verbose=False)\nclf = GridSearchCV(model, parameters)\n\nclf.fit(X_train, y_train)\n\nprint(f'Best params: {clf.best_params_}')\nprint(f'Best validation score = {clf.best_score_}')","4f13e08f":"model = xgb.XGBRegressor(**clf.best_params_, objective='reg:squarederror')\nmodel.fit(X_train, y_train, eval_set=eval_set, verbose=False)","99103976":"plot_importance(model);","2d612733":"y_pred = model.predict(X_test)\nprint(f'y_true = {np.array(y_test)[:5]}')\nprint(f'y_pred = {y_pred[:5]}')","f187018d":"print(f'mean_squared_error = {mean_squared_error(y_test, y_pred)}')","49418f78":"predicted_prices = df.loc[test_split_idx+1:].copy()\npredicted_prices['Close'] = y_pred\n\nfig = make_subplots(rows=2, cols=1)\nfig.add_trace(go.Scatter(x=df.Date, y=df.Close,\n                         name='Truth',\n                         marker_color='LightSkyBlue'), row=1, col=1)\n\nfig.add_trace(go.Scatter(x=predicted_prices.Date,\n                         y=predicted_prices.Close,\n                         name='Prediction',\n                         marker_color='MediumPurple'), row=1, col=1)\n\nfig.add_trace(go.Scatter(x=predicted_prices.Date,\n                         y=y_test,\n                         name='Truth',\n                         marker_color='LightSkyBlue',\n                         showlegend=False), row=2, col=1)\n\nfig.add_trace(go.Scatter(x=predicted_prices.Date,\n                         y=y_pred,\n                         name='Prediction',\n                         marker_color='MediumPurple',\n                         showlegend=False), row=2, col=1)\n\nfig.show()","280ab62a":"Je calcule quelques moyennes mobiles \u00e0 utiliser comme fonctionnalit\u00e9s: SMA5, SMA10, SMA15, SMA30 et EMA9.\n- SMA = Simple Moving Average (Moyenne Mobile Simple) : Une moyenne mobile simple (SMA) calcule la moyenne d'une fourchette de prix s\u00e9lectionn\u00e9e, g\u00e9n\u00e9ralement des cours de cl\u00f4ture, par le nombre de p\u00e9riodes de cette fourchette.\n- EMA = Exponential Moving Average (Moyenne Mobile Exponentielle) : Une moyenne mobile exponentielle (EMA) est un type de moyenne mobile qui accorde un poids et une signification plus importants aux points de donn\u00e9es les plus r\u00e9cents.\n\nUne p\u00e9riode de temps basse (5, 9, 10) represente une tendance sur le court-terme et est donc plus volatile.\n\nUne p\u00e9riode de temps haute (30 et plus) represente une tendance sur le long-terme et est donc moins volatile.","91e65165":"## Divise en fonctionnalit\u00e9s et en \u00e9tiquettes","2c7a11c1":"Je commence par dessiner un graphique OHLC (open \/ high \/ low \/ close) pour avoir une id\u00e9e des prix historiques. Sous OHLC, je dessine un graphique de volume qui montre le nombre d'actions \u00e9chang\u00e9es chaque jour.","f79a31cb":"L'indicateur RSI mesure le rapport des mouvements ascendants et descendants, et normalise le calcul afin que l'indice soit exprim\u00e9 dans une plage de 0 \u00e0 100.\n\n- Si le RSI se situe autour du niveau 70, on suppose que l'instrument est sur-achet\u00e9. C'est une situation dans laquelle les prix ont augment\u00e9 de mani\u00e8re forte, et que le mouvement risque de s'affaiblir.\n- Si le RSI est autour du niveau 30, c'est un signal technique traduisant que l'instrument est sur-vendu. Dans ce cas, c'est une situation dans laquelle les prix ont fortement chut\u00e9, et que le mouvement pourrait d\u00e9sormais perdre de la force.\n- Si l'indicateur oscille horizontalement autour du seuil 50, cela signifie que le march\u00e9 manque de tendance. Le niveau 50 est la ligne m\u00e9diane qui s\u00e9pare les territoires haussiers et baissiers de l'indicateur","a5aa49ba":"## Supprime les colonnes inutiles","7124f172":"### MACD (Moving Average Convergence Divergence)\n\nMACD est un indicateur de suivi de tendance qui montre la relation entre deux moyennes mobiles du prix d'un titre.","202f9b1e":"## Lecture de l'historique des prix","d922a012":"Moving Averages (Moyennes mobiles)\n\nUne moyenne mobile est un calcul utilis\u00e9 pour analyser des points de donn\u00e9es en cr\u00e9ant une s\u00e9rie de moyennes de diff\u00e9rents sous-ensembles de l'ensemble de donn\u00e9es complet.","aca5d993":"## D\u00e9calage de l'\u00e9tiquette de colonne","e8f32f32":"## Supprime les \u00e9chantillons non valides","b650f806":"### Relative Strength Index (RSI) (Indice de force relative)","a2740f14":"On va utilier les MAs afin de pr\u00e9dire les mouvements et retournements de tendance d'AAPL.","39421ab5":"## Calculer et visualiser les pr\u00e9dictions","5c338fdb":"## Indicateurs techniques","802f99d3":"## OHLC Chart","885cecca":"Je lis la base de donn\u00e9es historiques pour un stock choisi (ici APPLE) que je vais analyser. L'ensemble de donn\u00e9es de la Bourse de New York (New York Stock Exchange) fournit un historique des prix au jour le jour rassembl\u00e9 sur plus de 10 ans. J'ai d\u00e9cid\u00e9 de recadrer le dataframe et de le d\u00e9marrer \u00e0 partir de l'ann\u00e9e 2010 pour r\u00e9duire la quantit\u00e9 de donn\u00e9es \u00e0 traiter.","243ed96e":"## Librairie","c5e1897a":"On va utiliser le RSI pour pr\u00e9dire si l'action AAPL est sur-achet\u00e9 ou sur-vendue.","52f49f39":"## Ajuste XGBoostRegressor","787906f5":"Mon objectif \u00e9tant de pr\u00e9dire le prix du jour suivant, apr\u00e8s avoir calcul\u00e9 toutes les fonctionnalit\u00e9s pour le jour $D_{i}$, je d\u00e9cale la colonne de prix Close de -1.\n\nApr\u00e8s cela, pour le jour $D_{i}$, nous avons des fonctionnalit\u00e9s du m\u00eame temps, par exemple $RSI_{i}$, mais le prix $C_{i+1}$ du jour \u00e0 venir.","57d297cc":"L'indicateur MACD vient en compl\u00e9ment du MA et du RSI et permet de confirmer ou non la pertinence d'un signal d'achat ou de vente.","1774defd":"Legende :\n- Open = Prix de l'action \u00e0 l'ouverture du march\u00e9\n- High = Prix le plus haut atteint de l'action durant la session\n- Low = Prix le plus bas atteint de l'action durant la session\n- Close = Prix de l'action \u00e0 la fermeture du march\u00e9\n- Volume = Le nombre d'action \u00e9chang\u00e9es par session","8a1d5201":"Ici, je divise la dataframe de donn\u00e9es boursi\u00e8res en trois sous-ensembles: les ensembles de formation ($70\\%$), de validation ($15\\%$) et de test ($15\\%$). \n\nJe calcule les indices de fractionnement et cr\u00e9\u00e9 trois cadres s\u00e9par\u00e9s (train_df, valid_df, test_df). Les trois cadres ont \u00e9t\u00e9 repr\u00e9sent\u00e9s dans le graphique ci-dessous.","7bb8f4c9":"Un des probl\u00e8mes provoquant \"la mani\u00e8re de pr\u00e9diction inf\u00e9rieure au prix\" est que les algorithmes bas\u00e9s sur des arbres (comme XGBRegressor utilis\u00e9 ici) ne peuvent pas imaginer \/ inventer \/ supposer les donn\u00e9es. Si on regarde le plot avec des donn\u00e9es fractionn\u00e9es, tout ce qu'un algorithme voit lors du training est \u00e9videmment le train set. Pour l'algorithme, les limites du train set sont les limites totales pour le reste des donn\u00e9es.\n\nPar cons\u00e9quent, si l'ensemble de validation ou le test set atteint une valeur sup\u00e9rieure \u00e0 la valeur maximale de l'ensemble du training set, les classes bas\u00e9es sur l'arborescence ne peuvent pas les pr\u00e9dire correctement. Ils pr\u00e9diront la valeur comme \u00e9tant le maximum dont ils ont connaissance.\n\nL'auteur original de ce notebook pr\u00e9cise que ce probl\u00e8me peut \u00eatre r\u00e9gl\u00e9 en prenant un data set dont la plus haute valeur est dans le training set, ce qui signifie qu'il faudrait choisir un actif dont le prix reste \"stable\", ce qui est non r\u00e9aliste represente une limite \u00e0 cette attente \u00e0 utiliser le machine learning pour pr\u00e9dire le prix des actifs sur les march\u00e9s financiers.","3aaa980b":"On peut observer que l'EMA9 suivie du RSI et MACD sont les caract\u00e9ristiques les plus importante.","eb864fbd":"En raison du calcul des moyennes mobiles et du d\u00e9calage de l'\u00e9tiquette de colonne, peu de lignes auront des valeurs invalides, c'est-\u00e0-dire que nous n'avons pas calcul\u00e9 $SMA_{10}$ pour les 10 premiers jours. De plus, apr\u00e8s avoir d\u00e9cal\u00e9 la colonne de prix de cl\u00f4ture, le prix de la derni\u00e8re ligne est \u00e9gal \u00e0 0, ce qui n'est pas vrai. La suppression de ces exemples devrait aider."}}