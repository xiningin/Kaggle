{"cell_type":{"c1602ebc":"code","b8cfe9f8":"code","6c72d894":"code","b22d3c92":"code","dee0d7d3":"code","304c30b3":"code","22e73774":"code","76c4a7ed":"code","d5fa2f01":"code","5d8e5fd0":"markdown","dc216ab9":"markdown","3813cb85":"markdown","b77c5d5c":"markdown","bb9a4e6d":"markdown","5fdf40bb":"markdown","f6291973":"markdown","3509085c":"markdown","2a9be6f4":"markdown"},"source":{"c1602ebc":"# 1. Enable Internet in the Kernel (Settings side pane)\n\n# 2. Curl cache may need purged if v0.1.6 cannot be found. \n!curl -X PURGE https:\/\/pypi.org\/simple\/kaggle-environments\n\n# 3. Register is in all versions of kaggle-environments\n!pip install 'kaggle-environments>=0.1.6'\n\n# 4. Import register to define the environment and make to create it.\nfrom kaggle_environments import make, register","b8cfe9f8":"specification = {\n  \"name\": \"tictactoe2\",\n  \"title\": \"Tic Tac Toe\",\n  \"description\": \"Classic Tic Tac Toe\",\n  \"version\": \"1.0.0\",\n  \"agents\": [2],\n  \"configuration\": {\n    \"steps\": {\n      \"description\": \"Maximum number of steps the environment can run.\",\n      \"type\": \"integer\",\n      \"minimum\": 10,\n      \"default\": 10\n    }\n  },\n  \"reward\": {\n    \"description\": \"0 = Lost, 0.5 = Draw, 1 = Won\",\n    \"enum\": [0, 0.5, 1],\n    \"default\": 0.5\n  },\n  \"observation\": {\n    \"board\": {\n      \"description\": \"Serialized 3x3 grid. 0 = Empty, 1 = X, 2 = O\",\n      \"type\": \"array\",\n      \"default\": [0, 0, 0, 0, 0, 0, 0, 0, 0],\n      \"minItems\": 9,\n      \"maxItems\": 9\n    },\n    \"mark\": {\n      \"description\": \"Mark for the agent to use\",\n      \"enum\": [1, 2]\n    }\n  },\n  \"action\": {\n    \"description\": \"Position to place a mark on the board.\",\n    \"type\": \"integer\",\n    \"minimum\": 0,\n    \"maximum\": 8\n  },\n  \"reset\": {\n    \"status\": [\"ACTIVE\", \"INACTIVE\"],\n    \"observation\": [{ \"mark\": 1 }, { \"mark\": 2 }],\n    \"reward\": 0.5\n  }\n}","6c72d894":"# Copyright 2020 Kaggle Inc\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nfrom os import path\nfrom random import choice\n\nchecks = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n]\n\nEMPTY = 0\n\ndef interpreter(state, env):\n    # Specification can fully handle the reset.\n    if env.done:\n        return state\n\n    # Isolate the active and inactive agents.\n    active = state[0] if state[0].status == \"ACTIVE\" else state[1]\n    inactive = state[0] if state[0].status == \"INACTIVE\" else state[1]\n    if active.status != \"ACTIVE\" or inactive.status != \"INACTIVE\":\n        active.status = \"DONE\" if active.status == \"ACTIVE\" else active.status\n        inactive.status = \"DONE\" if inactive.status == \"INACTIVE\" else inactive.status\n        return state\n\n    # Keep the board in sync between both agents.\n    board = active.observation.board\n    inactive.observation.board = board\n\n    # Illegal move by the active agent.\n    if board[active.action] != EMPTY:\n        active.status = f\"Invalid move: {active.action}\"\n        inactive.status = \"DONE\"\n        return state\n\n    # Mark the position.\n    board[active.action] = active.observation.mark\n\n    # Check for a win.\n    if any(all(board[p] == active.observation.mark for p in c) for c in checks):\n        active.reward = 1\n        active.status = \"DONE\"\n        inactive.reward = 0\n        inactive.status = \"DONE\"\n        return state\n\n    # Check for a tie.\n    if all(mark != EMPTY for mark in board):\n        active.status = \"DONE\"\n        inactive.status = \"DONE\"\n        return state\n\n    # Swap active and inactive agents to switch turns.\n    active.status = \"INACTIVE\"\n    inactive.status = \"ACTIVE\"\n\n    return state","b22d3c92":"def renderer(state, env):\n    row_bar = \"\\n---+---+---\\n\"\n    marks = [\" \", \"X\", \"O\"]\n\n    def print_pos(pos):\n        str = \"\"\n        if pos % 3 == 0 and pos > 0:\n            str += row_bar\n        if pos % 3 != 0:\n            str += \"|\"\n        return str + f\" {marks[state[0].observation.board[pos]]} \"\n\n    return \"\".join(print_pos(p) for p in range(9))","dee0d7d3":"%%writefile html_renderer.js\n\nasync function renderer(context) {\n  const {\n    act,\n    agents,\n    environment,\n    frame,\n    height = 400,\n    interactive,\n    isInteractive,\n    parent,\n    step,\n    update,\n    width = 400,\n  } = context;\n\n  \/\/ Common Dimensions.\n  const canvasSize = Math.min(height, width);\n  const unit = 8;\n  const offset = canvasSize > 400 ? canvasSize * 0.1 : unit \/ 2;\n  const cellSize = (canvasSize - offset * 2) \/ 3;\n\n  \/\/ Canvas Setup.\n  let canvas = parent.querySelector(\"canvas\");\n  if (!canvas) {\n    canvas = document.createElement(\"canvas\");\n    parent.appendChild(canvas);\n\n    if (interactive) {\n      canvas.addEventListener(\"click\", evt => {\n        if (!isInteractive()) return;\n        const rect = evt.target.getBoundingClientRect();\n        const x = evt.clientX - rect.left - offset;\n        const y = evt.clientY - rect.top - offset;\n        act(Math.floor(x \/ cellSize) + Math.floor(y \/ cellSize) * 3);\n      });\n    }\n  }\n  canvas.style.cursor = isInteractive() ? \"pointer\" : \"default\";\n\n  \/\/ Canvas setup and reset.\n  let c = canvas.getContext(\"2d\");\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  const drawStyle = ({\n    lineWidth = 1,\n    lineCap,\n    strokeStyle = \"#FFF\",\n    shadow,\n  }) => {\n    c.lineWidth = lineWidth;\n    c.strokeStyle = strokeStyle;\n    if (lineCap) c.lineCap = lineCap;\n    if (shadow) {\n      c.shadowOffsetX = shadow.offsetX || 0;\n      c.shadowOffsetY = shadow.offsetY || 0;\n      c.shadowColor = shadow.color || strokeStyle;\n      c.shadowBlur = shadow.blur || 0;\n    }\n  };\n\n  const drawLine = ({ x1, y1, x2, y2, style }) => {\n    c.beginPath();\n    drawStyle(style || {});\n    c.moveTo((x1 || 0) + offset, (y1 || 0) + offset);\n    c.lineTo((x2 || x1) + offset, (y2 || y1) + offset);\n    c.stroke();\n  };\n\n  const drawArc = ({ x, y, radius, sAngle, eAngle, style }) => {\n    drawStyle(style || {});\n    c.beginPath();\n    c.arc(x, y, radius, sAngle, eAngle);\n    c.stroke();\n  };\n\n  \/\/ Draw the Grid.\n  const gridFrame = step === 0 ? frame : 1;\n  const drawGridLine = ({\n    x1s = 0,\n    y1s = 0,\n    x2s,\n    y2s,\n    x1o = 0,\n    x2o = 0,\n    y1o = 0,\n    y2o = 0,\n  }) =>\n    drawLine({\n      x1: x1s * cellSize + x1o * unit,\n      x2: (x2s || x1s) * cellSize + x2o * unit,\n      y1: y1s * cellSize + y1o * unit,\n      y2: (y2s || y1s) * cellSize + y2o * unit,\n      style: { strokeStyle: \"#046BBF\" },\n    });\n\n  \/\/ Vertical.\n  drawGridLine({ x1s: 1, y1s: 0, y2s: gridFrame, y2o: -1 });\n  drawGridLine({ x1s: 2, y1s: 0, y2s: gridFrame, y2o: -1 });\n  drawGridLine({ x1s: 1, y1s: 1, y2s: 1 + gridFrame, y1o: 1, y2o: -1 });\n  drawGridLine({ x1s: 2, y1s: 1, y2s: 1 + gridFrame, y1o: 1, y2o: -1 });\n  drawGridLine({ x1s: 1, y1s: 2, y2s: 2 + gridFrame, y1o: 1 });\n  drawGridLine({ x1s: 2, y1s: 2, y2s: 2 + gridFrame, y1o: 1 });\n\n  \/\/ Horizontal.\n  drawGridLine({ x1s: 0, y1s: 1, x2s: gridFrame, x2o: -1 });\n  drawGridLine({ x1s: 1, y1s: 1, x2s: 1 + gridFrame, x1o: 1, x2o: -1 });\n  drawGridLine({ x1s: 2, y1s: 1, x2s: 2 + gridFrame, x1o: 1 });\n  drawGridLine({ x1s: 0, y1s: 2, x2s: gridFrame, x2o: -1 });\n  drawGridLine({ x1s: 1, y1s: 2, x2s: 1 + gridFrame, x1o: 1, x2o: -1 });\n  drawGridLine({ x1s: 2, y1s: 2, x2s: 2 + gridFrame, x1o: 1 });\n\n  \/\/ Draw the Pieces.\n  const drawX = (cell, cellFrame) => {\n    const part = cellSize \/ 4;\n    const gap = Math.min(Math.sqrt((unit * unit) \/ 2), canvasSize \/ 50);\n    const row = Math.floor(cell \/ 3);\n    const col = cell % 3;\n\n    const drawXLine = ({ x1, y1, x2, y2 }) =>\n      drawLine({\n        x1: col * cellSize + x1,\n        y1: row * cellSize + y1,\n        x2: col * cellSize + x2,\n        y2: row * cellSize + y2,\n        style: {\n          strokeStyle: \"#FF0\",\n          lineWidth: 2,\n          lineCap: \"round\",\n          shadow: { blur: 8 },\n        },\n      });\n\n    drawXLine({\n      x1: part,\n      y1: part,\n      x2: part + part * 2 * cellFrame,\n      y2: part + part * 2 * cellFrame,\n    });\n    if (Math.round(cellFrame) === 1) {\n      drawXLine({\n        x1: part,\n        y1: part * 3,\n        x2: part * 2 - gap,\n        y2: part * 2 + gap,\n      });\n      drawXLine({\n        x1: part * 2 + gap,\n        y1: part * 2 - gap,\n        x2: part * 3,\n        y2: part,\n      });\n    }\n  };\n  const drawO = (cell, cellFrame) => {\n    const row = Math.floor(cell \/ 3);\n    const col = cell % 3;\n    const radius = cellSize \/ 4 + 1; \/\/ +1 is for optical illusion.\n    const gap =\n      (Math.acos((2 * (radius ^ 2) - (unit ^ 2)) \/ (2 * radius * radius)) \/\n        180) *\n      Math.PI *\n      unit;\n    const x = cellSize * col + cellSize \/ 2 + offset;\n    const y = cellSize * row + cellSize \/ 2 + offset;\n\n    const drawOArc = (sAngle, eAngle) =>\n      drawArc({\n        x,\n        y,\n        radius,\n        sAngle,\n        eAngle,\n        style: {\n          lineWidth: 2,\n          strokeStyle: \"#F0F\",\n          shadow: { blur: 8 },\n        },\n      });\n\n    drawOArc(\n      -Math.PI \/ 2 + gap,\n      -Math.PI \/ 2 + gap + (Math.PI - gap * 2) * cellFrame\n    );\n    drawOArc(\n      Math.PI \/ 2 + gap,\n      Math.PI \/ 2 + gap + (Math.PI - gap * 2) * cellFrame\n    );\n  };\n\n  const board = environment.steps[step][0].observation.board;\n\n  board.forEach((value, cell) => {\n    const cellFrame =\n      step <= 1 ||\n      environment.steps[step - 1][0].observation.board[cell] !== value\n        ? frame\n        : 1;\n    if (value === 1) drawX(cell, cellFrame);\n    if (value === 2) drawO(cell, cellFrame);\n  });\n\n  \/\/ Draw the winning line.\n  \/\/ [cell1, cell2, cell3, x1, y1, x2, y2]\n  const checks = [\n    [0, 1, 2, 1 \/ 19, 1 \/ 6, 18 \/ 19, 1 \/ 6],\n    [3, 4, 5, 1 \/ 19, 1 \/ 2, 18 \/ 19, 1 \/ 2],\n    [6, 7, 8, 1 \/ 19, 5 \/ 6, 18 \/ 19, 5 \/ 6],\n    [0, 3, 6, 1 \/ 6, 1 \/ 19, 1 \/ 6, 18 \/ 19],\n    [1, 4, 7, 1 \/ 2, 1 \/ 19, 1 \/ 2, 18 \/ 19],\n    [2, 5, 8, 5 \/ 6, 1 \/ 19, 5 \/ 6, 18 \/ 19],\n    [0, 4, 8, 1 \/ 19, 1 \/ 19, 18 \/ 19, 18 \/ 19],\n    [2, 4, 6, 18 \/ 19, 1 \/ 19, 1 \/ 19, 18 \/ 19],\n  ];\n  for (const check of checks) {\n    if (\n      board[check[0]] !== 0 &&\n      board[check[0]] === board[check[1]] &&\n      board[check[0]] === board[check[2]]\n    ) {\n      const x1 = check[3] * (cellSize * 3);\n      const y1 = check[4] * (cellSize * 3);\n      const winFrame = frame < 0.5 ? 0 : (frame - 0.5) \/ 0.5;\n      if (winFrame > 0) {\n        drawLine({\n          x1,\n          y1,\n          x2: x1 + (check[5] * (cellSize * 3) - x1) * winFrame,\n          y2: y1 + (check[6] * (cellSize * 3) - y1) * winFrame,\n          style: {\n            strokeStyle: \"#FFF\",\n            lineWidth: 3 * winFrame,\n            shadow: { blur: 8 * winFrame },\n          },\n        });\n      }\n      break;\n    }\n  }\n\n  \/\/ Upgrade the legend.\n  if (agents.length && (!agents[0].color || !agents[0].image)) {\n    const getPieceImage = drawFn => {\n      const pieceCanvas = document.createElement(\"canvas\");\n      parent.appendChild(pieceCanvas);\n      pieceCanvas.style.marginLeft = \"10000px\";\n      pieceCanvas.width = cellSize + offset * 2;\n      pieceCanvas.height = cellSize + offset * 2;\n      c = pieceCanvas.getContext(\"2d\");\n      drawFn(0, 1);\n      const dataUrl = pieceCanvas.toDataURL();\n      parent.removeChild(pieceCanvas);\n      return dataUrl;\n    };\n\n    agents.forEach(agent => {\n      agent.color = agent.index === 0 ? \"#0FF\" : \"#FFF\";\n      agent.image = getPieceImage(agent.index === 0 ? drawX : drawO);\n    });\n    update({ agents });\n  }\n}\n","304c30b3":"def html_renderer():\n    with open(\"\/kaggle\/working\/html_renderer.js\") as f:\n        return f.read()","22e73774":"from random import choice\n\nchecks = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n]\n\nEMPTY = 0\n\n\ndef random_agent(obs):\n    return choice([c for c in range(len(obs.board)) if obs.board[c] == EMPTY])\n\n\ndef reaction_agent(obs):\n    # Connect 3 in a row to win.\n    for check in checks:\n        left = list(filter(lambda c: obs.board[c] != obs.mark, check))\n        if len(left) == 1 and obs.board[left[0]] == EMPTY:\n            return left[0]\n\n    # Block 3 in a row to prevent loss.\n    opponent = 2 if obs.mark == 1 else 1\n    for check in checks:\n        left = list(filter(lambda c: obs.board[c] != opponent, check))\n        if len(left) == 1 and obs.board[left[0]] == EMPTY:\n            return left[0]\n\n    # No 3-in-a-rows, return random unmarked.\n    return choice(list(filter(lambda m: m[1] == EMPTY, enumerate(obs.board))))[0]\n\n\nagents = {\"random\": random_agent, \"reaction\": reaction_agent}","76c4a7ed":"register(specification[\"name\"], {\n    \"agents\": agents,\n    \"html_renderer\": html_renderer,\n    \"interpreter\": interpreter,\n    \"renderer\": renderer,\n    \"specification\": specification,\n})","d5fa2f01":"env = make(specification[\"name\"], debug=True)\nenv.run([\"random\", \"reaction\"])\nenv.render(mode=\"ipython\")","5d8e5fd0":"# 7. Register as specification name","dc216ab9":"# 1. Import kaggle-environments","3813cb85":"This example demonstrates how to create the [TicTacToe Environment](https:\/\/github.com\/Kaggle\/kaggle-environments\/tree\/master\/kaggle_environments\/envs\/tictactoe) directly in a notebook.","b77c5d5c":"# 4. Create Ansi Renderer ","bb9a4e6d":"# 2. Define Specification","5fdf40bb":"# 3. Create State\/Action Interpreter","f6291973":"# 5. Create HTML Renderer (Optional)","3509085c":"# 6. Include Default Agents (Optional)","2a9be6f4":"# 8. Make and Test the Environment"}}