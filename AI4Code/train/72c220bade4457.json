{"cell_type":{"327aa830":"code","5ffb2903":"code","25cbafde":"code","b847f611":"code","672a2b2a":"code","eff394e5":"code","3c7896d6":"code","134ac845":"code","6435de0b":"code","61d797e5":"code","b0e7aa43":"code","c196234b":"code","19819247":"code","6cfadd64":"code","bcdfc1c2":"code","2790f7d0":"code","84be7483":"code","681127d8":"code","983a8cd6":"code","50e43471":"code","aa896328":"code","b8bf5045":"code","61444676":"code","6e42663c":"code","6539d6d6":"code","7875cc61":"code","d3496630":"code","8f2ef3b7":"code","3e4f27ae":"code","e22e9801":"code","45c7f958":"code","b36561af":"code","c1340854":"code","2ce0ad34":"markdown","01fc4b17":"markdown","74c64e83":"markdown","dba13250":"markdown","fcac064d":"markdown","3425a503":"markdown"},"source":{"327aa830":"import numpy as np \nimport pandas as pd \n\nimport os\n\nfrom IPython.core.display import display\nfrom sklearn.datasets import fetch_20newsgroups","5ffb2903":"print(os.listdir(\"..\/input\"))","25cbafde":"competition_path = '20-newsgroups-ciphertext-challenge'","b847f611":"test = pd.read_csv('..\/input\/' + competition_path + '\/test.csv').rename(columns={'ciphertext' : 'text'})","672a2b2a":"train_p = fetch_20newsgroups(subset='train')\ntest_p = fetch_20newsgroups(subset='test')","eff394e5":"df_p = pd.concat([pd.DataFrame(data = np.c_[train_p['data'], train_p['target']],\n                                   columns= ['text','target']),\n                      pd.DataFrame(data = np.c_[test_p['data'], test_p['target']],\n                                   columns= ['text','target'])],\n                     axis=0).reset_index(drop=True)","3c7896d6":"df_p['text'] = df_p['text'].map(lambda x: x.replace('\\r\\n','\\n').replace('\\r','\\n').replace('\\n','\\n '))","134ac845":"df_p.loc[df_p['text'].str.endswith('\\n '),'text'] = df_p.loc[df_p['text'].str.endswith('\\n '),'text'].map(lambda x: x[:-1])","6435de0b":"df_p['target'] = df_p['target'].astype(np.int8)","61d797e5":"cipher_path = 'cipher-1-cipher-2-full-solutions'\ncipher1_map = pd.read_csv('..\/input\/'+ cipher_path + '\/cipher1_map.csv')\ntranslation_1 = str.maketrans(''.join(cipher1_map['cipher']), ''.join(cipher1_map['plain']))","b0e7aa43":"test.loc[40]","c196234b":"c_text = test.loc[40,'text']","19819247":"t_text = test.loc[40,'text'].translate(translation_1)","6cfadd64":"t_text","bcdfc1c2":"df_p.loc[[4473,7227],'text'].str.contains(t_text,regex=False)","2790f7d0":"df_p.loc[[4473,7227],'target']","84be7483":"df_p_extract = df_p[df_p['text'].str.contains(t_text,regex=False)]","681127d8":"df_p_extract","983a8cd6":"p_text_chunk_list = []\np_text_index_list = []\n\nchunk_size = 300\n\nfor p_index, p_row in df_p_extract.iterrows():\n    p_text = p_row['text']\n    p_text_len = len(p_text)\n    if p_text_len > chunk_size:\n        for j in range(p_text_len \/\/ chunk_size):\n            p_text_chunk_list.append(p_text[chunk_size*j:chunk_size*(j+1)])\n            p_text_index_list.append(p_index)\n        if p_text_len%chunk_size > 0:\n            p_text_chunk_list.append(p_text[chunk_size*(p_text_len \/\/ chunk_size):(chunk_size*(p_text_len \/\/ chunk_size)+p_text_len%chunk_size)])\n            p_text_index_list.append(p_index)\n    else:\n        p_text_chunk_list.append(p_text)\n        p_text_index_list.append(p_index)","50e43471":"df_p_chunked = pd.DataFrame({'text' : p_text_chunk_list, 'p_index' : p_text_index_list})","aa896328":"df_p_chunked = pd.merge(df_p_chunked, df_p.reset_index().rename(columns={'index' : 'p_index'})[['p_index','target']],on='p_index',how='left')","b8bf5045":"df_p_chunked[df_p_chunked['text'].str.contains(t_text,regex=False)]","61444676":"test.loc[31525]","6e42663c":"t_text = test.loc[31525,'text'].translate(translation_1)","6539d6d6":"t_text","7875cc61":"df_p_extract = df_p.loc[[11001,13188]]","d3496630":"p_text_chunk_list = []\np_text_index_list = []\n\nchunk_size = 300\n\nfor p_index, p_row in df_p_extract.iterrows():\n    p_text = p_row['text']\n    p_text_len = len(p_text)\n    if p_text_len > chunk_size:\n        for j in range(p_text_len \/\/ chunk_size):\n            p_text_chunk_list.append(p_text[chunk_size*j:chunk_size*(j+1)])\n            p_text_index_list.append(p_index)\n        if p_text_len%chunk_size > 0:\n            p_text_chunk_list.append(p_text[chunk_size*(p_text_len \/\/ chunk_size):(chunk_size*(p_text_len \/\/ chunk_size)+p_text_len%chunk_size)])\n            p_text_index_list.append(p_index)\n    else:\n        p_text_chunk_list.append(p_text)\n        p_text_index_list.append(p_index)","8f2ef3b7":"df_p_chunked = pd.DataFrame({'text' : p_text_chunk_list, 'p_index' : p_text_index_list})","3e4f27ae":"df_p_chunked = pd.merge(df_p_chunked, df_p.reset_index().rename(columns={'index' : 'p_index'})[['p_index','target']],on='p_index',how='left')","e22e9801":"df_p_chunked[df_p_chunked['p_index'] == 11001]","45c7f958":"df_p_chunked[df_p_chunked['p_index'] == 13188]","b36561af":"df_p_chunked[df_p_chunked['p_index'] == 11001].iloc[-1]['text'] == df_p_chunked[df_p_chunked['p_index'] == 13188].iloc[-1]['text']","c1340854":"df_p_chunked[df_p_chunked['p_index'] == 11001].iloc[-1]['text'] == t_text","2ce0ad34":"This kernel just wants to show why luck (or repeated submissions) may play a part in getting a perfect score: \n* some cipher texts match mutliple targets... \n* however if you have the right chunking, you can guess sometimes guess the right target...\n* and sometimes you cannot as some identical plaintext chunks belong to different targets\n\nHat tip to RS Turley for all the great material he shares on this competition","01fc4b17":"# Showing an Example Cipher in the Test Set that Matches Exactly Multiple Targets","74c64e83":"# Loading the Dataset (competition & 20newsgroup original)","dba13250":"# However Using Chunked Plaintexts Point to the Right Target","fcac064d":"# But in some cases we cannot do better","3425a503":"# Loading the Cipher #1 Substitution Map"}}