{"cell_type":{"4e9be447":"code","24553a38":"code","ba7c7a1e":"code","0493a4fc":"code","35b9ac2a":"code","542777e8":"markdown","0849b7f4":"markdown","3f33b854":"markdown","00aee3b1":"markdown"},"source":{"4e9be447":"pip install flaml","24553a38":"def reduce_dtypes(df, verbose=True):\n    \"\"\"\n    reduces the datatype of numerical columns to smallest possible. \n    dtypes: \"int8\", \"int16\", \"int32\", \"int64\", \"float16\", \"float32\", \"float64\"\n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024 ** 2\n    \n    numerics = [\"int8\", \"int16\", \"int32\", \"int64\", \"float16\", \"float32\", \"float64\"]\n    int_types = [np.int8, np.int16, np.int32, np.int64]\n    float_types = [np.float16, np.float32, np.float64]\n    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                for int_type in int_types:\n                    if c_min > np.iinfo(int_type).min and c_max < np.iinfo(int_type).max:\n                        df[col] = df[col].astype(int_type)\n                        break\n            else:\n                for float_type in float_types:\n                    if c_min > np.finfo(float_type).min and c_max < np.finfo(float_type).max:\n                        df[col] = df[col].astype(float_type)\n                        break\n    if verbose:\n        end_mem = df.memory_usage().sum() \/ 1024 ** 2\n        print(f\"Mem. usage decreased to {end_mem:.2f} Mb ({100*(start_mem - end_mem)\/start_mem:.1f}% reduction)\")\n    return df","ba7c7a1e":"import numpy as np\nimport pandas as pd\n\nrng = 1337\n\ntrain = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/train.csv', index_col='id')\ntest = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/test.csv', index_col='id')\n\nreduce_dtypes(train)\nreduce_dtypes(test)\n\nX_train, y_train = train.drop('target', axis=1), train[['target']].values.flatten()\nX_test = test","0493a4fc":"from flaml import AutoML\n\nautoml = AutoML()\n\nautoml_settings = {\n    \"time_budget\": 60 * 60 * 2, #2h\n    \"metric\": 'roc_auc',\n    \"task\": 'classification',\n    \"log_file_name\": \"oct.log\",\n    \"estimator_list\": ['lgbm', 'xgboost', 'catboost', 'rf', 'extra_tree'],\n    \"ensemble\": True,\n    \"seed\": rng,\n    \"n_jobs\": 1, # stacking crashes with -1\n}\n\nautoml.fit(X_train=X_train, y_train=y_train, **automl_settings)","35b9ac2a":"preds = automl.predict_proba(X_test)\nsubmission = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/sample_submission.csv')\nsubmission[\"target\"] = preds[:, -1]\nsubmission.to_csv(\"submission.csv\", index=False)","542777e8":"## Predict","0849b7f4":"## Load Data","3f33b854":"## Fit the Model","00aee3b1":"# **Quick low effort AutoML Solution using FLAML**\n\nFor this minimal solution, I entered the data as is into FLAML and let the library ran different models for 120 minutes to find a solid solution.\nThis fourth version after running all the models takes the best version of each algorithm and builds a stacked model.\n\nhttps:\/\/github.com\/microsoft\/FLAML"}}