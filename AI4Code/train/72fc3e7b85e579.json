{"cell_type":{"3360ca9b":"code","7f6b6c6d":"code","98577ff5":"code","2ca4b4f4":"code","a6231c3e":"code","99d3fc77":"code","dd520ef3":"code","7549ea68":"markdown","4d838482":"markdown","2cee834f":"markdown","77373ead":"markdown","4b754f3f":"markdown"},"source":{"3360ca9b":"import numpy as np\nimport pandas as pd \n\ntrain_raw = pd.read_csv('\/kaggle\/input\/cat-in-the-dat-ii\/train.csv')","7f6b6c6d":"train_raw.info()","98577ff5":"old_memory_usage = train_raw.memory_usage(deep = True)","2ca4b4f4":"ordinality_of_cats = train_raw.describe(include = [np.object]).T.sort_values('unique')\nordinality_of_cats","a6231c3e":"train_less_memory = train_raw.copy()\nlow_card_cols = ordinality_of_cats.query('unique < 300').index.tolist()\nfor col in low_card_cols:\n    train_less_memory[col] = train_raw[col].astype('category')","99d3fc77":"train_less_memory.dtypes","dd520ef3":"train_less_memory.memory_usage(deep = True)\/old_memory_usage","7549ea68":"# Save your Ram!\n\nThe point of the competition is to work with categorical data. However, pandas automatically reads any string column as a `dtype = object` column, which is notoriously inefficient. However, pandas' own `dtype`, `category`, can help us to save any column. ","4d838482":"There are 17 columns with `dtype` `object`. These are very memory inefficient. We might, however, cast them into categorical types if they have a reasonably low number of unique values. Let's check that:","2cee834f":"The categorical columns now take less than 3% of their original memory! ","77373ead":"Let's turn all of the columns with less than 300 unique values into categoricals.","4b754f3f":"Let's confirm that pandas is reading the categorical columns as object dtypes. "}}