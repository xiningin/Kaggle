{"cell_type":{"8d225da2":"code","7c604cb8":"code","5856628b":"code","60e5812b":"code","430a8cb3":"code","14992b9a":"code","59e507e4":"code","f17e1386":"code","a1b6bc8f":"code","ac8b0a45":"code","99004b3c":"code","d4ca3464":"code","d9fb2e62":"code","38948e33":"code","ea8a8a87":"code","b64a953a":"code","36172468":"code","15d1d0e8":"code","3106b4e6":"code","cd1ee230":"code","9dcc3d25":"code","5f198409":"code","99eab972":"code","cfddb36c":"code","93812e14":"code","541175dd":"code","a697d144":"code","b6080e62":"code","5ac460a2":"code","c23657c5":"markdown","775aea7d":"markdown","f599a8f8":"markdown","7b26b596":"markdown","95fdea4f":"markdown","c545debd":"markdown","78a372d6":"markdown","38120dce":"markdown","66ed4a3f":"markdown","07c17adf":"markdown"},"source":{"8d225da2":"!pip install ase==3.17 schnetpack","7c604cb8":"import numpy as np\nimport pandas as pd\nmolecules = pd.read_csv('..\/input\/structures.csv')\nmolecules = molecules.groupby('molecule_name')\nmagnetic_shielding_tensors = pd.read_csv('..\/input\/magnetic_shielding_tensors.csv')","5856628b":"magnetic_shielding_tensors.head(10)","60e5812b":"x = magnetic_shielding_tensors.columns.values[2:]\nx = magnetic_shielding_tensors[x].values\nx = x.reshape(-1,3,3)\nx = x + np.transpose(x,(0,2,1))\nx = 0.5 * x\nw, v = np.linalg.eigh(x)","430a8cb3":"sigma_iso = np.sum(w, axis=1)\/3 ","14992b9a":"omega = w[:,2] - w[:,0]","59e507e4":"kappa = 3 * (sigma_iso - w[:,1])\/omega","f17e1386":"magnetic_shielding_parameters = magnetic_shielding_tensors[magnetic_shielding_tensors.columns.values[:2]]\nmagnetic_shielding_parameters = pd.DataFrame(magnetic_shielding_parameters)\nmagnetic_shielding_parameters[\"sigma_iso\"] = sigma_iso\nmagnetic_shielding_parameters[\"omega\"] = omega\nmagnetic_shielding_parameters[\"kappa\"] = kappa\n\nmagnetic_shielding_parameters.head(10)","a1b6bc8f":"_ = magnetic_shielding_parameters.sigma_iso.hist(bins=100)","ac8b0a45":"_ = magnetic_shielding_parameters.omega.hist(bins=100)","99004b3c":"_ = magnetic_shielding_parameters.kappa.hist(bins=100)","d4ca3464":"train = pd.read_csv('..\/input\/train.csv')\ntrain_molecule_names = train.molecule_name.unique()\n\nmsp = magnetic_shielding_parameters.groupby('molecule_name')","d9fb2e62":"from ase import Atoms\nfrom ase.db import connect\n\ndef create_db(db_path, molecule_names):\n    with connect(db_path) as db:\n        for name in molecule_names:\n            mol = molecules.get_group(name)\n            atoms = Atoms(symbols=mol.atom.values,\n                          positions=[(row.x,row.y,row.z) for row in mol.itertuples()])\n            try:\n                mol_msp = msp.get_group(name)\n                sigma_iso = mol_msp['sigma_iso'].values.reshape(-1,1)\n                omega = mol_msp['omega'].values.reshape(-1,1)\n                kappa = mol_msp['kappa'].values.reshape(-1,1)\n            except KeyError:\n                sigma_iso, omega, kappa = [None] * 3\n            db.write(atoms, name=name,\n                     data=dict(sigma_iso=sigma_iso, omega=omega, kappa=kappa)\n                    )","38948e33":"champs_path = 'CHAMPS_train.db'\ndataset_size = len(train_molecule_names) # 40000\ndataset_molecule_names = train_molecule_names[:dataset_size]\ncreate_db(db_path=champs_path, molecule_names=dataset_molecule_names)","ea8a8a87":"with connect(champs_path) as db:\n    print(len(db))","b64a953a":"import schnetpack\ndataset = schnetpack.data.AtomsData(champs_path,\n                properties=['sigma_iso', 'omega', 'kappa'])","36172468":"len(dataset)","15d1d0e8":"import pandas as pd\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.optim import Adam\n\nimport schnetpack as spk\nimport schnetpack.atomistic as atm\nimport schnetpack.representation as rep\nfrom schnetpack.datasets import *\n\ndevice = torch.device(\"cuda\")","3106b4e6":"# This function comes from the following script:\n# https:\/\/github.com\/atomistic-machine-learning\/schnetpack\/blob\/v0.2.1\/src\/scripts\/schnetpack_qm9.py\ndef evaluate_dataset(metrics, model, loader, device):\n    for metric in metrics:\n        metric.reset()\n\n    with torch.no_grad():\n        for batch in loader:\n            batch = {\n                k: v.to(device)\n                for k, v in batch.items()\n            }\n            result = model(batch)\n\n            for metric in metrics:\n                metric.add_batch(batch, result)\n\n    results = [\n        metric.aggregate() for metric in metrics\n    ]\n    return results","cd1ee230":"from schnetpack.data import Structure\n\nclass MagneticShielding(atm.Atomwise):\n    def __init__(self, property):\n        super(MagneticShielding, self).__init__(return_contributions=True)\n        self.property = property\n        \n    def forward(self, inputs):\n        result = super().forward(inputs)\n        \n        atom_mask = inputs[Structure.atom_mask].byte()\n        \n        yi = inputs[self.property]\n        yi = torch.masked_select(yi.squeeze(dim=2), atom_mask)\n        inputs[self.property+'_true'] = yi\n        \n        yi = result['yi']\n        yi = torch.masked_select(yi.squeeze(dim=2), atom_mask)\n        result[self.property+'_pred'] = yi\n        \n        return result","9dcc3d25":"def schnet_model(property):\n    reps = rep.SchNet(n_interactions=6)\n    output = MagneticShielding(property=property)\n    model = atm.AtomisticModel(reps, output)\n    model = model.to(device)\n    return model","5f198409":"def train_model(property, max_epochs=500):\n    # split in train and val\n    n_dataset = len(dataset)\n    n_val = n_dataset \/\/ 10\n    train_data, val_data, test_data = dataset.create_splits(n_dataset-n_val*2, n_val)\n    train_loader = spk.data.AtomsLoader(train_data, batch_size=128, num_workers=2)\n    val_loader = spk.data.AtomsLoader(val_data, batch_size=256, num_workers=2)\n\n    # create model\n    model = schnet_model(property)\n\n    # create trainer\n    target_key = property+'_true'\n    output_key = property+'_pred'\n    opt = Adam(model.parameters(), lr=1e-4)\n    loss = lambda b, p: F.mse_loss(p[output_key], b[target_key])\n    metrics = [\n        spk.metrics.MeanAbsoluteError(target_key, output_key, name='MAE_'+property),\n        spk.metrics.RootMeanSquaredError(target_key, output_key, name='RMSE_'+property),\n    ]\n    hooks = [\n        spk.train.MaxEpochHook(max_epochs),\n        spk.train.CSVHook(property+'\/log', metrics, every_n_epochs=1),\n    ]\n    trainer = spk.train.Trainer(property+'\/output', model, loss,\n                            opt, train_loader, val_loader, hooks=hooks)\n\n    # start training\n    trainer.train(device)\n    \n    # evaluation\n    model.load_state_dict(torch.load(property+'\/output\/best_model'))\n    test_loader = spk.data.AtomsLoader(test_data, batch_size=256, num_workers=2)\n    model.eval()\n\n    df = pd.DataFrame()\n    df['metric'] = ['MAE', 'RMSE']\n    df['training'] = evaluate_dataset(metrics, model, train_loader, device)\n    df['validation'] = evaluate_dataset(metrics, model, val_loader, device)\n    df['test'] = evaluate_dataset(metrics, model, test_loader, device)\n    display(df)\n    \n    return test_data","99eab972":"def show_history(property):\n    df = pd.read_csv(property+'\/log\/log.csv')\n    display(df.tail())\n    max_value = None # df['RMSE_'+property].min()*5\n    _ = df[['MAE_'+property,'RMSE_'+property]].plot(ylim=(0,max_value))","cfddb36c":"def test_prediction(dataset, property):\n    # create model\n    model = schnet_model(property)\n    \n    # load best parameters\n    model.load_state_dict(torch.load(property+'\/output\/best_model'))\n    loader = spk.data.AtomsLoader(dataset, batch_size=256, num_workers=2)\n    model.eval()\n    \n    # predict shielding parameters\n    targets = []\n    predictions = []\n    with torch.no_grad():\n        for batch in loader:\n            batch = {\n                k: v.to(device)\n                for k, v in batch.items()\n            }\n            result = model(batch)\n            targets += batch[property+'_true'].tolist()\n            predictions += result[property+'_pred'].tolist()\n    return targets, predictions","93812e14":"def show_predictions(dataset, property):\n    targets, predictions = test_prediction(dataset, property)\n    df_pred = pd.DataFrame()\n    df_pred['Target'] = targets\n    df_pred['Prediction'] = predictions\n    df_pred.plot.scatter(x='Target', y='Prediction', title=property)","541175dd":"used_test_data = dict()\nfor p in ['sigma_iso', 'omega', 'kappa']:\n    print(p)\n    used_test_data[p] = train_model(p, max_epochs=50)\n    show_history(p)","a697d144":"for p in ['sigma_iso', 'omega', 'kappa']:\n    show_predictions(used_test_data[p], p)","b6080e62":"!mv kappa\/log\/log.csv log_kappa.csv\n!mv omega\/log\/log.csv log_omega.csv\n!mv sigma_iso\/log\/log.csv log_sigma_iso.csv\n!mv kappa\/output\/best_model best_model_kappa\n!mv omega\/output\/best_model best_model_omega\n!mv sigma_iso\/output\/best_model best_model_sigma_iso\n!rm -r kappa\n!rm -r omega\n!rm -r sigma_iso","5ac460a2":"!ls","c23657c5":"The isotropic shielding value is defined as:\n\n![Isotropic shielding tensor](https:\/\/user-images.githubusercontent.com\/11532812\/60358900-75536800-9a12-11e9-850c-654dc81fc258.png)","775aea7d":"![span](https:\/\/user-images.githubusercontent.com\/11532812\/60359189-45589480-9a13-11e9-9016-42f8a90c1ddd.png)\n\nThs span (Omega) describes the magnitude of the shielding anisotropy.","f599a8f8":"We need `ASE 3.17` for `SchNetPack 0.2.1`.","7b26b596":"![skew](https:\/\/user-images.githubusercontent.com\/11532812\/60359338-c57efa00-9a13-11e9-9619-17ebd4f44ac8.png)\n\nThe skew (kappa) describes degree of axial symmetry of the shielding tensor.","95fdea4f":"# ASE Database","c545debd":"## Results","78a372d6":"# Chemical Shielding\n\nCORY M. WIDDIFIELD, ROBERT W. SCHURKO.\n\"Understanding Chemical Shielding Tensors Using Group Theory, MO Analysis, and Modern Density- Functional Theory\"\n*Concepts in Magnetic Resonance Part A (Bridging Education and Research). (2009)\nhttps:\/\/onlinelibrary.wiley.com\/doi\/pdf\/10.1002\/cmr.a.20136\n\nThe chemical shielding Hamiltonian:\n\n![Hamiltonian](https:\/\/user-images.githubusercontent.com\/11532812\/60358602-78018d80-9a11-11e9-894f-60b8122e8a4c.png)\n\nwhere gamma is the gyromagnetic ratio, I^ is the nuclear spin operator, and sigma is the magnetic shielding tensor.","38120dce":"# Shielding Parameter Prediction\n\n## SchNet Model","66ed4a3f":"Please see LibreTexts [Chemical Shift][1] if you want to understand the meaning of the parameters.\n\n[1]: https:\/\/chem.libretexts.org\/Bookshelves\/Physical_and_Theoretical_Chemistry_Textbook_Maps\/Supplemental_Modules_(Physical_and_Theoretical_Chemistry)\/Spectroscopy\/Magnetic_Resonance_Spectroscopies\/Nuclear_Magnetic_Resonance\/NMR%3A_Theory\/NMR_Interactions\/Chemical_Shift_(Shielding)","07c17adf":"The magnetic shielding tensor:\n![Magnetic shielding tensor](https:\/\/user-images.githubusercontent.com\/11532812\/60358839-3ae9cb00-9a12-11e9-8f3a-0236f7bc072d.png)\n\nThe symmetric portion of the shielding tensor can be diagonalized into its own principal axis system (PAS):\n\n![PAS](https:\/\/user-images.githubusercontent.com\/11532812\/60359035-c95e4c80-9a12-11e9-897d-2e422e0f2e83.png)"}}