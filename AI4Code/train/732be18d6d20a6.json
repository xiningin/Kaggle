{"cell_type":{"5a6c76cb":"code","d6c16f08":"code","6b2b1d41":"code","b7409875":"code","2dc99265":"code","a7f67db8":"code","8689bda9":"code","676a0686":"code","fc307e6b":"code","0c3b0fbc":"code","ed18ccb5":"markdown","bdb4170f":"markdown","83882201":"markdown"},"source":{"5a6c76cb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d6c16f08":"from kaggle_environments import make\nfrom kaggle_environments.envs.halite.helpers import *\n\nimport json\nimport sys","6b2b1d41":"%%writefile submission.py\nimport numpy as np\nimport pandas as pd\nfrom random import choice\nfrom kaggle_environments import make\nfrom kaggle_environments.envs.halite.helpers import *\nfrom copy import deepcopy\n\ndef get_distance(pos1,pos2,context):\n    size = context['board'].configuration.size\n    distance_east = min(abs(pos2[0]-pos1[0]),abs(pos2[0]-pos1[0]+size),abs(pos2[0]-pos1[0]-size))\n    distance_north = min(abs(pos2[1]-pos1[1]),abs(pos2[1]-pos1[1]+size),abs(pos2[1]-pos1[1]-size))\n    return distance_east + distance_north\n\ndef cell_safety_check(cell,context):\n    board = context['board']\n    me = context['board'].current_player\n    \n    return 'safe'\n    \ndef move_to_verification(ship_position,heading,context):\n    board = context['board']\n    current_player = context['board'].current_player\n    current_cell = board.cells[ship_position]\n    current_ship = [ship for ship in board.ships.values() if ship.position == ship_position][0]\n    \n    if heading == 'north':\n        heading_cell = current_cell.north\n    elif heading == 'south':\n        heading_cell = current_cell.south\n    elif heading == 'east':\n        heading_cell = current_cell.east\n    elif heading == 'west':\n        heading_cell = current_cell.west\n    else:\n        heading_cell = current_cell\n        \n    if (heading_cell.ship is None) and (heading_cell.shipyard is None):\n        return 'empty'\n    elif (heading_cell.ship is not None) and (heading_cell.ship.player_id == current_player.id):\n        return 'friendly_ship'\n    elif (heading_cell.ship is not None) and (heading_cell.ship.player_id != current_player.id):\n        if heading_cell.ship.halite <= current_ship.halite:\n            return 'danger_enemy_ship'\n        else:\n            return 'target_enemy_ship'\n    elif (heading_cell.ship is None) and (heading_cell.shipyard.player_id == current_player.id):\n        return 'friendly_shipyard'\n    elif (heading_cell.ship is None) and (heading_cell.shipyard.player_id != current_player.id):\n        return 'enemy_shipyard'\n    else:\n        pass\n    return 'empty'\n    \ndef move_to(ship_position,target_position,context):\n    \n    east_move = target_position[0] - ship_position[0]\n    if abs(east_move) > context['board'].configuration.size \/ 2 + 1:\n        east_move = -1 * east_move\n        \n    north_move = target_position[1] - ship_position[1]\n    if abs(north_move) > context['board'].configuration.size \/ 2 + 1:\n        north_move = -1 * north_move\n    \n    #\u9996\u5148\u5bf9\u5468\u8fb94\u4e2acell\u8fdb\u884c\u5360\u7528\u60c5\u51b5\u8bc4\u4f30\n    ver_list = [move_to_verification(ship_position,heading,context) for heading in ['east','south','west','north']]\n    prob_list = np.array([(ver in ['target_enemy_ship','friendly_shipyard','empty','enemy_shipyard']) * 1 for ver in ver_list])\n    if north_move > 0 and east_move == 0 and prob_list.sum() > 0:\n        prob_list[3] = prob_list[3] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    elif north_move > 0 and east_move > 0 and prob_list.sum() > 0:\n        prob_list[3] = prob_list[3] * 20\n        prob_list[0] = prob_list[0] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    elif north_move > 0 and east_move < 0 and prob_list.sum() > 0:\n        prob_list[3] = prob_list[3] * 20\n        prob_list[1] = prob_list[1] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    elif north_move < 0 and east_move == 0 and prob_list.sum() > 0:\n        prob_list[1] = prob_list[1] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    elif north_move < 0 and east_move > 0 and prob_list.sum() > 0:\n        prob_list[1] = prob_list[1] * 20\n        prob_list[0] = prob_list[0] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    elif north_move < 0 and east_move < 0 and prob_list.sum() > 0:\n        prob_list[1] = prob_list[1] * 20\n        prob_list[2] = prob_list[2] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    elif north_move == 0 and east_move == 0 and prob_list.sum() > 0:\n        return None\n    elif north_move == 0 and east_move > 0 and prob_list.sum() > 0:\n        prob_list[0] = prob_list[0] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    elif north_move == 0 and east_move < 0 and prob_list.sum() > 0:\n        prob_list[2] = prob_list[2] * 20\n        prob_list = prob_list \/ prob_list.sum()\n        return np.random.choice([ShipAction.EAST,ShipAction.SOUTH,ShipAction.WEST,ShipAction.NORTH],p=prob_list)\n    else:\n        return None\n    return None\n\n\ndef shipyard_convert_decision(context):\n    board = context['board']\n    current_player = context['board'].current_player\n    shipyard_building = False\n    #\u5982\u679c\u5f53\u524d\u6ca1\u6709\u8239\u575e\uff0c\u8bbe\u6cd5\u5efa\u9020\u4e00\u4e2a\n    if (len(current_player.shipyards)) == 0:\n        #\u627e\u5230\u5e93\u5b58\u6700\u591a\u7684\u98de\u8239,\u5c06\u5176\u8f6c\u5316\u4e3a\u8239\u575e\n        cargos = np.array([ship.halite for ship in current_player.ships])\n        for ship in current_player.ships:\n            if ship.halite == cargos.max():\n                ship.next_action = ShipAction.CONVERT\n                shipyard_building = True\n                return context\n            \n    #\u5982\u679c\u8239\u53ea\u6570\/\u8239\u575e>=6\uff0c\u90a3\u4e48\u9020\u7b2c\u4e8c\u8239\u575e\n    num_shipyard = len(current_player.shipyards)\n    num_ship = len(current_player.ships)\n    if (num_ship >= num_shipyard * 6) and (shipyard_building == False) and (current_player.halite >= 2000):\n        #\u627e\u5230\u8ddd\u79bb\u548c\u8d1f\u8f7d\u5408\u9002\u7684\u98de\u8239,\u5c06\u5176\u8f6c\u5316\u4e3a\u8239\u575e\n        base_ship_list = []\n        for ship in current_player.ships:\n            distance_to_shipyards = [get_distance(ship.position,shipyard.position,context) for shipyard in current_player.shipyards]\n            if np.min(distance_to_shipyards) >= 4:\n                base_ship_list.append(ship)\n        if len(base_ship_list) >= 1:\n            ship_cargos = [ship.halite for ship in base_ship_list]\n            for ship in base_ship_list:\n                if ship.halite == np.max(ship_cargos) and shipyard_building == False:\n                    ship.next_action = ShipAction.CONVERT\n                    shipyard_building = True\n    return context\n\ndef find_nearest_halite(ship,frange,context):  \n    board = context['board']\n    nearby_cells = [cell for cell in board.cells.values() if get_distance(ship.position,cell.position,context) <= frange]\n    nearby_empty_cells = [cell for cell in nearby_cells if cell.ship is None]\n    nearby_empty_cell_halites = [cell.halite for cell in nearby_empty_cells]\n    highest_halite_empty_cells = [cell for cell in nearby_empty_cells if cell.halite == np.max(nearby_empty_cell_halites)]\n    target_cell = choice(highest_halite_empty_cells)\n    return target_cell\n\ndef ship_mining_decision(context):\n    board = context['board']\n    current_player = context['board'].current_player\n    for n,ship in enumerate(current_player.ships):\n        current_cell = board.cells[ship.position[0],ship.position[1]]\n        mining_cell = find_nearest_halite(ship,2,context)\n        #\u5982\u679c\u98de\u8239\u8f7d\u8d27\u91cf\u5927\u4e8e1500\uff0c\u90a3\u4e48\u5c31\u5730\u8f6c\u4e3a\u8239\u575e\n        if (ship.halite >= 1500) and (ship.next_action is None):\n            ship.next_action = ShipAction.CONVERT\n        #\u5982\u679c\u98de\u8239\u8f7d\u8d27\u91cf\u5927\u4e8e300\uff0c\u90a3\u4e48\u5c31\u56de\u6700\u8fd1\u7684\u8239\u575e\u5378\u8d27\n        elif ship.halite >= 300 and ship.next_action!=ShipAction.CONVERT:\n            pos = ship.position\n            shipyards = current_player.shipyards\n            shipyard_distances = np.array([get_distance(pos,shipyard.position,context) for shipyard in shipyards])\n            for shipyard in shipyards:\n                if get_distance(pos,shipyard.position,context) == np.min(shipyard_distances):\n                    ship.next_action = move_to(ship.position,shipyard.position,context)\n\n        #\u5982\u679c\u7ade\u8d5b\u63a5\u8fd1\u7ed3\u675f\uff0c\u90a3\u4e48\u5c31\u56de\u6700\u8fd1\u7684\u8239\u575e\u5378\u8d27\n        elif (board.configuration.episode_steps - board.step <= 12) and (ship.next_action!=ShipAction.CONVERT):\n            pos = ship.position\n            shipyards = current_player.shipyards\n            shipyard_distances = np.array([get_distance(pos,shipyard.position,context) for shipyard in shipyards])\n            for shipyard in shipyards:\n                if get_distance(pos,shipyard.position,context) == np.min(shipyard_distances):\n                    ship.next_action = move_to(ship.position,shipyard.position,context)\n        \n        #\u5982\u679c\u9644\u8fd1\u6709\u4e00\u4e2a\u5bcc\u77ff\u6bd4\u5f53\u524dhalite\u542b\u91cf\u5927150\u4ee5\u4e0a\uff0c\u90a3\u4e48\u5c31\u8f6c\u79fb\n        elif (mining_cell.halite*0.25 - current_cell.halite*0.25*2 > 50) and (ship.next_action!=ShipAction.CONVERT):\n            ship.next_action = move_to(ship.position,mining_cell.position,context)\n        elif current_cell.halite > 200 and (ship.next_action!=ShipAction.CONVERT):\n            ship.next_action = None\n        elif ship.next_action!=ShipAction.CONVERT:\n            p = [0.2,0.2,0.2,0.2]\n            p[n%4] += 0.2\n            ship.next_action = np.random.choice([ShipAction.NORTH,ShipAction.SOUTH,ShipAction.WEST,ShipAction.EAST],p=p)\n        else:\n            pass\n\n    return context\n\ndef get_ship_next_cell(ship,context):\n    board = context['board']\n    if ship.next_action == ShipAction.NORTH:\n        return ship.cell.north\n    elif ship.next_action == ShipAction.SOUTH:\n        return ship.cell.south\n    elif ship.next_action == ShipAction.EAST:\n        return ship.cell.east\n    elif ship.next_action == ShipAction.WEST:\n        return ship.cell.west\n    elif ship.next_action is None:\n        return ship.cell\n    else:\n        return None\n    \ndef self_collision_check(context):\n    board = context['board']\n    current_player = context['board'].current_player\n    next_cells = []\n    idle_ships = [ship for ship in current_player.ships if ship.next_action is None]\n    moving_ships = [ship for ship in current_player.ships if ship.next_action is not None]\n    next_cells = [get_ship_next_cell(ship,context) for ship in idle_ships]\n    for ship in moving_ships:\n        next_cell = get_ship_next_cell(ship,context)\n        if next_cell in next_cells:\n            ship.next_action = None\n            next_cells.append(ship.cell)\n        else:\n            next_cells.append(next_cell)\n    return context\n\ndef shipyard_collision_check(shipyard,context):\n    board = context['board']\n    current_player = context['board'].current_player\n    next_cells = []\n    if len(current_player.ships) == 0:\n        return 'shipyard available'\n    for ship in current_player.ships:\n        next_cells.append(get_ship_next_cell(ship,context))\n    if shipyard.cell in next_cells:\n        return 'ship incoming'\n    else:\n        return 'shipyard available'\n    return 'shipyard available'\n\ndef short_range_attack(context):\n    board = context['board']\n    for myship in board.current_player.ships:\n        next_cells = [cell for cell in board.cells.values() if get_distance(myship.position,cell.position,context)==1]\n        next_ships = [cell.ship for cell in next_cells if cell.ship is not None]\n        enemy_ships = [ship for ship in next_ships if ship.player_id != board.current_player.id]\n        target_ships = [ship for ship in enemy_ships if myship.halite < ship.halite]\n        if len(target_ships) >= 1:\n            origional_action = myship.next_action\n            attack_move = move_to(myship.position,target_ships[0].position,context)\n            myship.next_action = np.random.choice([origional_action,attack_move])\n    return context\n\ndef shipyard_attack(context,attack_range,attack_player_id = None,attack_ship_number = 1):\n    board = context['board']\n    current_player = context['board'].current_player\n    attackships = [ship for ship in current_player.ships if ship.halite <= 80]\n    attacking_ship = 0\n    if attack_player_id is None:\n        enemy_shipyards = [shipyard for shipyard in board.shipyards.values() if shipyard.player_id != current_player.id]\n    else:\n        enemy_shipyards = [shipyard for shipyard in board.shipyards.values() if shipyard.player_id == attack_player_id]\n    \n    for ship in attackships:\n        #\u9009\u53d6\u5728\u653b\u51fb\u8303\u56f4\u5185\u7684\u654c\u65b9\u8239\u575e\n        enemy_shipyards_in_range = [shipyard for shipyard in enemy_shipyards if get_distance(ship.position,shipyard.position,context)<=attack_range]\n        #\u8ba1\u7b97\u6240\u6709\u653b\u51fb\u8303\u56f4\u5185\u654c\u65b9\u8239\u575e\u7684\u8ddd\u79bb\n        target_ranges = [get_distance(ship.position,shipyard.position,context) for shipyard in enemy_shipyards_in_range]\n        #\u9009\u53d6\u8ddd\u79bb\u6700\u8fd1\u7684\u654c\u65b9\u8239\u575e\n        target_shipyards = [shipyard for shipyard in enemy_shipyards_in_range if get_distance(ship.position,shipyard.position,context)==np.min(target_ranges)]\n        #\u5982\u679c\u5408\u9002\u76ee\u6807>=1\uff0c\u4e0b\u8fbe\u653b\u51fb\u6307\u4ee4\n        if len(target_shipyards) >= 1 and attacking_ship < attack_ship_number:\n            ship.next_action = move_to(ship.position,target_shipyards[0].position,context)\n            attacking_ship += 1\n    return context\n\ndef ship_building(context):\n    board = context['board']\n    current_player = context['board'].current_player\n    num_shipyard = len(current_player.shipyards)\n    num_ship = len(current_player.ships)\n    ship_building = 'not allow'\n    if num_shipyard == 0:\n        return context\n    \n    #\u5982\u679c\u5f53\u524dship\u5f88\u5c11\uff0c\u90a3\u4e48\u8865\u5145ship\n    if num_ship <= 1:\n        ship_building = 'allow'\n    elif board.step <= 7 and current_player.halite > 500:\n        ship_building = 'allow'\n    #\u5982\u679c\u50a8\u5907\u8d44\u6e90\u592a\u5c11\uff0c\u90a3\u4e48\u6682\u505c\u9020\u8239\n    elif current_player.halite <= 1000:\n        ship_building = 'not allow'\n    #\u5982\u679c\u8239\u961f\u89c4\u6a21\u8f83\u5927\uff0c\u800c\u4e14\u63a5\u8fd1\u7ec8\u5c40\uff0c\u90a3\u4e48\u505c\u6b62\u9020\u8239\n    elif num_ship >= 10 and (board.configuration.episode_steps - board.step <= 15):\n        ship_building = 'not allow'\n    #\u5982\u679c\u8239\u961f\u89c4\u6a21\u5c0f\u4e8e\u8239\u575e\u627f\u8f7d\u80fd\u529b\uff0c\u4e14\u6709\u8db3\u591f\u50a8\u5907\u8d44\u91d1\u548c\u5269\u4f59\u56de\u5408\u6570\uff0c\u90a3\u4e48\u5f00\u59cb\u9020\u8239\n    elif (num_ship <= num_shipyard * 6) and (board.configuration.episode_steps - board.step >= 20) and (current_player.halite >= 1500):\n        ship_building = 'allow'\n    else:\n        return context\n    \n    for shipyard in current_player.shipyards:\n        if ship_building == 'allow':\n            pass\n        else:\n            break\n        ship_incoming_check = shipyard_collision_check(shipyard,context)\n        if (ship_incoming_check=='shipyard available') and (ship_building == 'allow'):\n            shipyard.next_action = ShipyardAction.SPAWN\n            ship_building = 'ongoing'\n    return context\n\ndef get_target_player_id(context):\n    board = context['board']\n    current_player = context['board'].current_player\n    df_player_rank = pd.DataFrame()\n    df_player_rank['player_id'] = [player.id for player in board.players.values()]\n    df_player_rank['player_halite'] = [player.halite for player in board.players.values()]\n    df_player_rank['player_cargo'] = [len(player.shipyards) for player in board.players.values()]\n    df_player_rank['player_ships'] = [len(player.ships) for player in board.players.values()]\n    df_player_rank['player_shipyards'] = [len(player.shipyards) for player in board.players.values()]\n    df_player_rank.sort_values(by = 'player_halite', ascending=False, inplace=True)\n    df_player_rank.reset_index(inplace=True,drop=True)\n\n    if df_player_rank.loc[0,'player_id'] == current_player.id:\n        attack_player_id = df_player_rank.loc[1,'player_id']\n    else:\n        attack_player_id = df_player_rank.loc[0,'player_id']\n    return attack_player_id\n\ndef ship_retreat(context):\n    board = context['board']\n    me = context['board'].current_player\n    for ship in me.ships:\n        ver_list = [move_to_verification(ship.position,heading,context) for heading in ['east','south','west','north']]\n        #\u5982\u679c\u8eab\u8fb9\u51fa\u73b0\u654c\u65b9\u653b\u51fb\u98de\u8239\uff0c\u90a3\u4e48\u5c31\u5f80\u8001\u5bb6\u8dd1\n        if 'danger_enemy_ship' in var_list:\n            shipyard_distances = np.array([get_distance(ship.position,shipyard.position,context) for shipyard in me.shipyards])\n            for shipyard in shipyards:\n                if get_distance(ship.position,shipyard.position,context) == np.min(shipyard_distances):\n                    ship.next_action = move_to(ship.position,shipyard.position,context)\n                    if ship.next_action is None and ship.halite >= 200 and me.halite >= 500:\n                        ship.next_action = ShipAction.CONVERT\n        \n\ndef agent(obs,config):\n    board = Board(obs,config)\n    size = board.configuration.size\n    max_steps = board.configuration.episode_steps\n    current_player = board.current_player\n    context = {}\n    context['board'] = board\n    context['current_player'] = board.current_player\n    context = shipyard_convert_decision(context)\n    context = ship_mining_decision(context)\n    context = short_range_attack(context)\n    \n    attacks = round(len(current_player.ships)\/5)\n    if board.step <= max_steps \/ 4:\n        attacks = round(len(current_player.ships)\/5)\n        context = shipyard_attack(context,attack_range = size\/4, attack_player_id = None, attack_ship_number = attacks)\n    elif board.step >= max_steps \/ 4 * 3:\n        attack_player_id = get_target_player_id(context)\n        attacks = round(len(current_player.ships)\/3)\n        context = shipyard_attack(context,attack_range = size\/2, attack_player_id = attack_player_id, attack_ship_number = attacks)\n    else:\n        attacks = round(len(current_player.ships)\/5)\n        context = shipyard_attack(context,attack_range = size\/3, attack_player_id = None, attack_ship_number = attacks)\n        \n    context = self_collision_check(context)\n    context = self_collision_check(context)\n    context = self_collision_check(context)\n    context = ship_building(context)\n    \n    return context['board'].current_player.next_actions","b7409875":"BOARD_SIZE = 13\nAGENT_COUNT = 2\nenv = make('halite',debug=True,configuration = {'size':BOARD_SIZE,'agent_count':2})","2dc99265":"env.run([\"\/kaggle\/working\/submission.py\", \"\/kaggle\/working\/submission.py\"])\nprint(\"EXCELLENT SUBMISSION!\" if env.toJSON()[\"statuses\"] == [\"DONE\", \"DONE\"] else \"MAYBE BAD SUBMISSION?\")\n\n# Play as the first agent against default \"shortest\" agent.\nenv.run([\"\/kaggle\/working\/submission.py\", \"random\"])\nenv.render(mode=\"ipython\", width=750, height=550)","a7f67db8":"BOARD_SIZE = 8\nAGENT_COUNT = 2\nenv = make('halite',debug=True,configuration = {'size':BOARD_SIZE,'agent_count':3})\nenv.reset(AGENT_COUNT)\nenv.render(mode=\"ipython\", width=200, height=160)\nstate = env.state[0]","8689bda9":"board = Board(state.observation, env.configuration)\ncontext = {}\ncontext['board'] = board\ncurrent_player = board.current_player\n","676a0686":"cells = [ship.cell for ship in board.ships.values()]\nacell = cells[0]\ncells.append(acell)","fc307e6b":"acell in set(cells)","0c3b0fbc":"board.configuration.episode_steps","ed18ccb5":"# Submission codes","bdb4170f":"# Testing codes\nthe code below can be ignored","83882201":"submission tips:\nSave Version, go to output section, download the submission.py file, and then submit manully at the submit page."}}