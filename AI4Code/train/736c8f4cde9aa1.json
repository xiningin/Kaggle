{"cell_type":{"0ccedd0a":"code","076896d7":"code","d8165a8f":"code","1d931377":"code","89b2b3ba":"code","aaff57ed":"code","c02f8c0c":"code","6a7459cc":"code","ab5f1bf2":"code","33b910a8":"code","bb9ef4de":"code","de67ef73":"code","3c022bfe":"code","0e318d8d":"code","6a2b6404":"code","a94da147":"markdown","ab687573":"markdown","9cd7aa65":"markdown"},"source":{"0ccedd0a":"# import das bibliotecas\nimport numpy as np\nimport pandas as pd\nimport cv2\nfrom glob import glob \nimport os\nimport matplotlib.pyplot as plt\nimport tqdm\n\nfrom sklearn.metrics import classification_report, log_loss, accuracy_score, roc_curve, auc, roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\nimport xgboost as xgb\n\nnp.random.seed(42)","076896d7":"path = \"\/kaggle\/input\/histopathologic-cancer-detection\/\" \nlabels = pd.read_csv(path + 'train_labels.csv')\ntrain_path = path + 'train\/'","d8165a8f":"df = pd.DataFrame({'path': glob(os.path.join(train_path,'*.tif'))})\ndf['id'] = df.path.map(lambda x: ((x.split(\"n\")[-1].split('.')[0])[1:]))\ndf = df.merge(labels, on = \"id\")\ndf.head(3)","1d931377":"IMG_SIZE = 96\nBATCH_SIZE = 128","89b2b3ba":"plt.title(\"Distribui\u00e7\u00e3o das classes\");\n\nplt.pie(df['label'].value_counts(), labels=['Sem cancer',\n          'Com Cancer'], startangle=180, autopct='%1.1f', \n           colors=['#00ff99','#FF96A7'], shadow=True);\nplt.figure(figsize=(16,16));\nplt.show();","aaff57ed":"df.head()","c02f8c0c":"df.shape","6a7459cc":"X = []\ny = []\nfor idx in tqdm.tqdm(range(df.shape[0])):\n\n    X.append(cv2.imread(df.iloc[idx]['path']))\n    y.append(df.iloc[idx]['label'])\n    if idx == 10000:\n        break\nX = np.array(X)\ny = np.array(y)","ab5f1bf2":"plt.title(\"Primeira imagem do dataset\")\nimagem = cv2.imread(df['path'][0], cv2.IMREAD_GRAYSCALE)\nplt.imshow(imagem);","33b910a8":"# Dividindo o dataset\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)","bb9ef4de":" xg_clf = xgb.XGBClassifier(objective ='reg:squarederror', colsample_bytree = 0.3, learning_rate = 0.1,\n                max_depth = 5, alpha = 10, n_estimators = 10)","de67ef73":"X_train = X_train.reshape(len(X_train),3 * 96 * 96)\nX_test = X_test.reshape(len(X_test),3 * 96 * 96)","3c022bfe":"xg_clf.fit(X_train,y_train)","0e318d8d":"predictions  = xg_clf.predict(X_test)\nfalse_positive_rate, true_positive_rate, threshold = roc_curve(y_test, predictions)\narea_under_curve = auc(false_positive_rate, true_positive_rate)\n\nplt.plot([0, 1], [0, 1], 'k--')\nplt.plot(false_positive_rate, true_positive_rate, label='AUC = {:.3f}'.format(area_under_curve))\nplt.xlabel('False positive rate')\nplt.ylabel('True positive rate')\nplt.title('ROC curve')\nplt.legend(loc='best')\nplt.savefig('ROC_PLOT.png', bbox_inches='tight')\nplt.show()\n\n","6a2b6404":"print(accuracy_score(y_test, predictions))","a94da147":"## Sobre o Classificador\n\nO XGBoost  (e**X**treme **G**radient **Boost**ing) \u00e9 um algoritmo de classifica\u00e7\u00e3o (possui vers\u00e3o pra regress\u00e3o tamb\u00e9m) baseado em \u00e1rvore de decis\u00e3o com Gradient Boosting (Aumento de gradiente).\n\n### Sobre Gradient Boosting\n\nGradient Boosting \u00e9 uma t\u00e9cnica que utiliza de *ensemble* de modelos considerados fracos, no caso do XGBoost \u00e9 utilizado \u00e1rvore de decis\u00e3o","ab687573":"## Visualizado as m\u00e9tricas","9cd7aa65":"### Realizando o a leitura do dataset\n\nLeitura do dataset, no momento estamos realizando testes com apenas 10 mil imagens."}}