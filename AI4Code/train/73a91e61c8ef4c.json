{"cell_type":{"9c3fab5a":"code","8ac78c4f":"code","15b51290":"code","fa5bd8d9":"code","73ce43d9":"code","aada9680":"code","83c0523b":"code","2706debd":"code","8d2750c7":"code","e233fdf1":"code","6c75f977":"code","8fa00059":"code","8c46cdb4":"markdown","59eb447e":"markdown","cf87d615":"markdown","b3bdc4fc":"markdown","f97c18b7":"markdown","5dcd2c24":"markdown"},"source":{"9c3fab5a":"# import packages\nimport glob\nimport os.path as osp\nimport random\nimport numpy as np\nimport json\nfrom PIL import Image\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.utils.data as data\nimport torchvision\nfrom torchvision import models, transforms","8ac78c4f":"# setting random number seed. Arbitrary seed is OK.\ntorch.manual_seed(1234)\nnp.random.seed(1234)\nrandom.seed(1234)\n\n# preprocess class for each image\nclass ImageTransform():\n\n    def __init__(self, resize, mean, std):\n        self.data_transform = {\n            'train': transforms.Compose([\n                # data augmentation\n                transforms.RandomResizedCrop(\n                   resize, scale=(0.5, 1.0)),\n                transforms.RandomHorizontalFlip(), \n                # convert to tensor for PyTorch\n                transforms.ToTensor(),\n                # color normalization\n                transforms.Normalize(mean, std)\n            ]),\n            'val': transforms.Compose([\n                transforms.CenterCrop(resize),\n                transforms.ToTensor(),\n                transforms.Normalize(mean, std)\n            ])\n        }\n\n    def __call__(self, img, phase='train'):\n\n        return self.data_transform[phase](img)\n\n","15b51290":"# Showing one result of the preprocess\n\nimage_file_path = '..\/input\/chest-xray-pneumonia\/chest_xray\/test\/PNEUMONIA\/person100_bacteria_479.jpeg'\n\nimg_originalsize = Image.open(image_file_path)   # [height][width][color RGB]\nimg = img_originalsize.resize((256, 256))\n\nimg = img.convert(\"L\").convert(\"RGB\")\n\n# original image\nplt.imshow(img)\nplt.show()\n\n# after preprocess\nsize = 256\nmean = (0.485, 0.456, 0.406)\nstd = (0.229, 0.224, 0.225)\n\ntransform = ImageTransform(size, mean, std)\nimg_transformed = transform(img, phase=\"train\")  # torch.Size([3, 224, 224])\n\n# (color, height, width) -> (height, width, color), normalize colors in the range (0 - 1)\nimg_transformed = img_transformed.numpy().transpose((1, 2, 0))\nimg_transformed = np.clip(img_transformed, 0, 1)\nplt.imshow(img_transformed)\nplt.show()\n","fa5bd8d9":"# making file path list\ndef make_datapath_list(phase=\"train\"):\n    \n    rootpath = \"..\/input\/chest-xray-pneumonia\/chest_xray\/\"\n    \n    target_path = osp.join(rootpath+phase+'\/**\/*.jpeg')\n    print(target_path)\n\n    path_list = []\n\n    # getting file paths\n    for path in glob.glob(target_path):\n        path_list.append(path)\n\n    return path_list\n\n\ntrain_list = make_datapath_list(phase=\"train\")\nval_list = make_datapath_list(phase=\"val\")","73ce43d9":"# making dataset\n\nclass lungDataset(data.Dataset):\n\n    def __init__(self, file_list, transform=None, phase='train'):\n        self.file_list = file_list\n        self.transform = transform\n        self.phase = phase\n\n    def __len__(self):\n        return len(self.file_list)\n\n    def __getitem__(self, index):\n\n        # load image\n        img_path = self.file_list[index]\n        \n        img_originalsize = Image.open(img_path)\n        # resize\n        img = img_originalsize.resize((256, 256))\n        \n        # grey -> color\n        img = img.convert(\"L\").convert(\"RGB\")\n\n        # preprocess\n        img_transformed = self.transform(\n            img, self.phase)  # torch.Size([3, 224, 224])\n\n        # picking up labels\n        if self.phase == \"train\":\n            label = img_path[47:53]\n\n        elif self.phase == \"val\":\n            label = img_path[45:51]\n\n        # label char -> number\n        if label == \"NORMAL\":\n            label = 0\n\n        elif label == \"PNEUMO\":\n            label = 1\n\n        return img_transformed, label\n\n\n# run\ntrain_dataset = lungDataset(\n    file_list=train_list, transform=ImageTransform(size, mean, std), phase='train')\n\nval_dataset = lungDataset(\n    file_list=val_list, transform=ImageTransform(size, mean, std), phase='val')\n\n# motion check\n# index = 0\n# print(train_dataset.__getitem__(index)[0].size())\n# print(train_dataset.__getitem__(index)[1])\n\n# print(val_dataset.__getitem__(index)[0].size())\n# print(val_dataset.__getitem__(index)[1])\n","aada9680":"batch_size = 32\n\n# making dataloader\ntrain_dataloader = torch.utils.data.DataLoader(\n    train_dataset, batch_size=batch_size, shuffle=True)\n\nval_dataloader = torch.utils.data.DataLoader(\n    val_dataset, batch_size=batch_size, shuffle=False)\n\n# put dataloader into dictionary type\ndataloaders_dict = {\"train\": train_dataloader, \"val\": val_dataloader}\n\n# motion check\n# batch_iterator = iter(dataloaders_dict[\"train\"])\n\n# inputs, labels = next(\n#     batch_iterator)  # pick up first element\n# print(inputs.size())\n# print(labels)\n","83c0523b":"# load pretrained vgg16 from PyTorch as an instance\n# need to make setting 'internet' to 'On'.\nuse_pretrained = True\nnet = models.vgg16(pretrained=use_pretrained)\n\n# Replace output layer for 2 class classifier, 'NORMAL' and 'PNEUMONIA'.\nnet.classifier[6] = nn.Linear(in_features=4096, out_features=2)\n\nnet.train()","2706debd":"# setting of loss function\ncriterion = nn.CrossEntropyLoss()\n\n# setting fine tuned parameters\n\nparams_to_update_1 = []\nparams_to_update_2 = []\nparams_to_update_3 = []\n\n# Not only output layer, \"features\" layers and other classifier layers are tuned.\nupdate_param_names_1 = [\"features\"]\nupdate_param_names_2 = [\"classifier.0.weight\",\n                        \"classifier.0.bias\", \"classifier.3.weight\", \"classifier.3.bias\"]\nupdate_param_names_3 = [\"classifier.6.weight\", \"classifier.6.bias\"]\n\n# store parameters in list\nfor name, param in net.named_parameters():\n    if update_param_names_1[0] in name:\n        param.requires_grad = True\n        params_to_update_1.append(param)\n        #print(\"params_to_update_1:\", name)\n\n    elif name in update_param_names_2:\n        param.requires_grad = True\n        params_to_update_2.append(param)\n        #print(\"params_to_update_2:\", name)\n\n    elif name in update_param_names_3:\n        param.requires_grad = True\n        params_to_update_3.append(param)\n        #print(\"params_to_update_3:\", name)\n\n    else:\n        param.requires_grad = False\n        #print(\"no learning\", name)\n\n# print(\"-----------\")\n# print(params_to_update_1)\n\n# Learning Rates\noptimizer = optim.SGD([\n    {'params': params_to_update_1, 'lr': 1e-4},\n    {'params': params_to_update_2, 'lr': 5e-4},\n    {'params': params_to_update_3, 'lr': 1e-3}\n], momentum=0.9)\n","8d2750c7":"# training function\ndef train_model(net, dataloaders_dict, criterion, optimizer, num_epochs):\n    \n    accuracy_list = []\n    loss_list = []\n    \n    # Precondition : Accelerator GPU -> 'On'\n    device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n    print(\"using device\uff1a\", device)\n\n    # put betwork into GPU\n    net.to(device)\n    torch.backends.cudnn.benchmark = True\n\n    # epoch loop\n    for epoch in range(num_epochs):\n        print('Epoch {}\/{}'.format(epoch+1, num_epochs))\n        print('-------------')\n\n        for phase in ['train', 'val']:\n            if phase == 'train':\n                net.train()  # set network 'train' mode\n            else:\n                net.eval()   # set network 'val' mode\n\n            epoch_loss = 0.0\n            epoch_corrects = 0\n\n            # Before training\n            if (epoch == 0) and (phase == 'train'):\n                continue\n            \n                      \n            # batch loop\n            for inputs, labels in tqdm(dataloaders_dict[phase]):\n                   \n                # send data to GPU\n                inputs = inputs.to(device)\n                labels = labels.to(device)\n                \n                # initialize optimizer\n                optimizer.zero_grad()\n\n                # forward\n                with torch.set_grad_enabled(phase == 'train'):\n                    outputs = net(inputs)\n\n                    loss = criterion(outputs, labels)  #calcurate loss\n                    _, preds = torch.max(outputs, 1)  # predict\n  \n                    # back propagtion\n                    if phase == 'train':\n                        loss.backward()\n                        optimizer.step()\n\n                    # update loss summation\n                    epoch_loss += loss.item() * inputs.size(0)  \n                    # update correct prediction summation\n                    epoch_corrects += torch.sum(preds == labels.data)\n\n            # loss and accuracy for each epoch loop\n            epoch_loss = epoch_loss \/ len(dataloaders_dict[phase].dataset)\n            epoch_acc = epoch_corrects.double(\n            ) \/ len(dataloaders_dict[phase].dataset)\n            \n            print('{} Loss: {:.4f} Acc: {:.4f}'.format(\n                phase, epoch_loss, epoch_acc))\n            \n            if phase == 'val':\n                accuracy_list.append(epoch_acc.item())\n                loss_list.append(epoch_loss)\n            \n    return accuracy_list, loss_list\n","e233fdf1":"# start training\nnum_epochs=10\naccuracy_list, loss_list = train_model(net, dataloaders_dict, criterion, optimizer, num_epochs=num_epochs)","6c75f977":"# To save trained model\n# save_path = '.\/weights_fine_tuning.pth'\n# torch.save(net.state_dict(), save_path)\n","8fa00059":"epoch_num = list(range(10))\nfig, ax = plt.subplots(facecolor=\"w\")\nax.plot(epoch_num, accuracy_list, label=\"accuracy\")\nax.plot(epoch_num, loss_list, label=\"loss\")\nplt.xticks(epoch_num) \n\nax.legend()\n\nplt.show()","8c46cdb4":"In folowing training function, 'training_model', have accuracy_list and losslist.\nThey are for plot learing model in later phase.","59eb447e":"PyTorch dataloader needs dataset includinig label and data itself.\n\nIn the training phase, dataloader provide 'batch_size' data automatically.","cf87d615":"To avoid over learning, I think that around epoch 5~6 may be good model. Train accuracy will be better for a while. But validation accuracy keep around 90%.\n\nIn this time, I used common technics but accuray is not bad.\nHonestly, it's my first submission and first try of PyTorch. I leave behind motion check and comments.\n\nI hope they are useful for beginners.\n\nI refer to \n\n'\u3064\u304f\u308a\u306a\u304c\u3089\u5b66\u3076\uff01\u3000PyTorch\u306b\u3088\u308b\u767a\u5c55\u30c7\u30a3\u30fc\u30d7\u30e9\u30fc\u30cb\u30f3\u30b0\u3000\u682a\u5f0f\u4f1a\u793e\u30de\u30a4\u30ca\u30d3\u51fa\u7248'\nISBN:978-4-8399-7025-3","b3bdc4fc":"As the preprocess, I do random crop and color normalization for training data.\n\nChest X-ray images are taken from almost same angle. So preprocess is not so difficult.\n\nOne pneumonia example before and after preprocess is shown. \n\nIn 'PNEUMONIA' image, There is white area (seems pneumonia area), so it tends to be emphasized.\nOn the other hand, in 'NOMAL' image, ribs are clearly shown.","f97c18b7":"This is a kernel to make classifier of 'NORMAL' or 'PNEUMONIA'.\n\nI do transfer learning and finetuning. It's based on vgg16 model and replace output layer for 2 classes classifier.\nI apply finetuning to its parameters.\n\nI import PyTorch to do deep learning. Pretrained model is from PyTorch library.\nFollowing script is not so complex, but the result is not bad.\n\nI frequently insert simple comments. I hope this kernel is useful for PyTorch deep learning beginner.","5dcd2c24":"For PyTorch dataloader, I prepare file path list and dataset.\n\nLabels are made from file path. For PyTorch beginner, motion check raws are useful to debug."}}