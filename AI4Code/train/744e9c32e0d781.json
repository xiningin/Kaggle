{"cell_type":{"99868210":"code","1af225c3":"code","95532326":"code","d88aae13":"code","978e9f0c":"code","f89e5f86":"code","2f71e5ea":"code","3196bda4":"code","235b580f":"code","111f2f61":"code","0740b0b4":"code","f1a1b17e":"code","de4838ec":"code","3b3271f8":"code","f65dfea3":"code","372aa590":"code","f60205fc":"code","b9ace1e3":"code","cc63e02b":"code","6cf5c893":"code","79ce3097":"code","cc3cd4b3":"code","fe19c3ff":"code","1b50f5b4":"code","875e60c3":"code","d48fc873":"markdown","188ea25b":"markdown","168a8bb5":"markdown","1e7730a8":"markdown","62363109":"markdown","6227c747":"markdown","d254df4b":"markdown","f08e7f1d":"markdown","cc1bffa8":"markdown","2e0892f6":"markdown"},"source":{"99868210":"#libraries\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nfrom functools import reduce","1af225c3":"#read main dataset and turn it into geodataframe\ndf = pd.read_csv('..\/input\/world-cities\/worldcities.csv', low_memory = False)\n#turn dataframe into geodataframe\ngdf = gpd.GeoDataFrame(df, \n                       geometry = gpd.points_from_xy(df.lng, df.lat),\n                       crs = 'epsg:4326').dropna(axis = 0, subset = ['population']).drop_duplicates()\n\ntot_db_pop = gdf['population'].sum()\nurb_db_pop = gdf.loc[gdf['population']>10000]['population'].sum()\nurb_pc = round(urb_db_pop\/tot_db_pop*100, 2)\nprint(str(tot_db_pop) + ' total database inhabitants')\nprint(str(urb_db_pop) + ' total database urban inhabitants')\nprint(str(urb_pc) + ' % urban inhabitants')\nprint(str(len(gdf)) + ' cities all over the world')","95532326":"#read auxiliar data\n#regions and country names with codes for being able to merge the different datasets\ncodes = pd.read_csv('..\/input\/country-mapping-iso-continent-region\/continents2.csv')\ncodes.drop(columns= ['iso_3166-2', 'intermediate-region', 'region-code', 'sub-region-code', 'intermediate-region-code'], inplace = True)\n\n#matching data formats\ngdf.rename(columns = {'iso2': 'alpha-2'}, inplace = True)\ngdf_codes = gdf.merge(codes, on = 'alpha-2', how = 'left')","d88aae13":"un_pop = pd.read_csv('..\/input\/un-work-population-prospects\/UN_countries_pop.csv', sep = ';')\nun_pop.rename(columns = {'Country code': 'country-code'}, inplace =True)\n\n#transforming data formats\nun_pop['2020'] = un_pop['2020'].str.replace(' ', '')\np = un_pop['2020']\nun_pop['pop_2020'] = pd.to_numeric(p, errors = 'coerce')*1000\n\nprint(str(un_pop['pop_2020'].sum()) + (' estimated world inhabitants in 2020'))","978e9f0c":"#cities classification by size dictionary\nclass_dict = {'small': 10000, 'cimes': 50000, 'big': 1000000}\n\nfor key in class_dict:\n    gdf_codes.loc[gdf_codes['population'] >= class_dict[key], 'city_class'] = key\n    \n#number of cities by type and country\nn_cities = []\npop_cities = []\n\nfor key in class_dict:\n    n = gdf_codes.loc[gdf_codes['city_class'] == key].groupby('alpha-2')['city'].count().reset_index()\n    n.rename(columns = {'city': f'n_{key}'}, inplace = True)\n    n_cities.append(n)\n    \n    pop = gdf_codes.loc[gdf_codes['city_class'] == key].groupby('alpha-2')['population'].sum().reset_index()\n    pop.rename(columns = {'population': f'pop_{key}'}, inplace = True)\n    pop_cities.append(pop)\n    \nn_pop = n_cities + pop_cities \ncity_stats = reduce(lambda  left, right:  pd.merge(left, right,  on = ['alpha-2'],  how = 'left'),  n_pop)\ncity_stats.fillna({'n_big': 0, 'pop_big': 0 ,\n                   'n_cimes': 0, 'pop_cimes': 0,\n                   'n_small': 0, 'pop_small': 0}, inplace = True)\n\ncity_stats.head()","f89e5f86":"#retrieve world dataset to plot context\nworld = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))\n\njoined = gpd.sjoin(gdf_codes, world[['continent', 'geometry']])\n\nbig = joined.loc[(joined['city_class'] == 'big')]\ncimes = joined.loc[(joined['city_class'] == 'cimes')]\nsmall = joined.loc[(joined['city_class'] == 'small')]\n\nsizes = [small, cimes, big]\n\nfor size in sizes:\n    ax = world[world.name!=\"Antarctica\"].plot(color='#eeeeee', figsize = (30, 20), alpha = 0.75)\n    size.plot(ax=ax, color='red', markersize = size['population']\/10000, alpha = 0.1)\n    ax.set_axis_off()\n    plt.savefig(f\"{size.index[0]}.png\", dpi=300)\n    plt.show()\n    \n    print(str(size['population'].sum()) +  ' inhabitants')\n    print(str(round(size['population'].sum()\/un_pop['pop_2020'][0].sum()*100, 2)) + \n              '% of the world population in ' + str(round(size['city'].count(), 0)) + ' cities')","2f71e5ea":"china_cimes = cimes.loc[cimes['name'] == 'China']\n\nax = world[world.name==\"China\"].plot(color='#eeeeee', figsize = (15, 10))\n\nchina_cimes.plot(ax=ax, color = 'red', markersize = size['population']\/100000, alpha = 0.25)\nax.set_axis_off()\nplt.savefig('capitals.png')\nplt.show()\n\nprint('China: ' + str(china_cimes['city'].count()) + ' cimes with an average population of ' + \n     str(round(china_cimes['population'].mean(), 2)) + ' inhabitants')","3196bda4":"ger_cimes = cimes.loc[cimes['name'] == 'Germany']\n\nax = world[world.name==\"Germany\"].plot(color='#eeeeee', figsize = (15, 10))\n\nger_cimes.plot(ax=ax, color = 'red', markersize = size['population']\/100000, alpha = 0.25)\nax.set_axis_off()\nplt.savefig('capitals.png')\nplt.show()\n\nprint('Germany: ' + str(ger_cimes['city'].count()) + ' cimes with an average population of ' + \n     str(round(ger_cimes['population'].mean(), 2)) + ' inhabitants')","235b580f":"ax = world[world.name!=\"Antarctica\"].plot(color='#eeeeee', figsize = (30, 20))\n\nfor size in [small, big]:\n    size.plot(ax=ax, color = 'black', markersize = size['population']\/10000, alpha = 0.2)  \ncimes.plot(ax=ax, color = 'red', markersize = cimes['population']\/10000, alpha = 0.1)   \nax.set_axis_off()\nplt.savefig('all.png')\nplt.show()\n\nprint(str(joined.loc[joined['population'] > 10000]['population'].sum()) +  ' inhabitants')\nprint(str(round(joined.loc[joined['population'] > 10000]['population'].sum()\/un_pop['pop_2020'][0].sum()*100, 2)) + \n              '% of the world population in ' + str(round(joined.loc[joined['population'] > 10000]['city'].count(), 0)) + ' cities')","111f2f61":"data = joined[joined['city_class'] == 'cimes'].groupby(['name', 'continent'])['population'].sum().reset_index()\ndata.sort_values('population', ascending = False, inplace = True)\n\ncont_list = ['Europe', 'Asia', 'Africa', 'South America', 'North America', 'Oceania']\n\nfor continent in cont_list:\n    \n    ax = world[(world['name'] !=\"Antarctica\") & (world['continent'] == continent )].plot(color='#eeeeee', figsize = (15, 10))\n    \n    for size in [small, big]:\n        \n        plot_size = size.loc[size['continent'] == continent]\n        plot_size.plot(ax=ax, color = 'black',\n                       markersize = plot_size['population']\/10000,\n                       alpha = 0.2)\n        \n    plot_cimes = cimes.loc[cimes['continent'] == continent]\n    plot_cimes.plot(ax=ax, color = 'red',\n                    markersize = plot_cimes['population']\/10000,\n                    alpha = 0.2)\n    \n    ax.set_axis_off()\n    plt.savefig(f\"{continent}.png\")\n    plt.show()\n    \n    fig, axes = plt.subplots(figsize=(15, 4), sharey=True)\n    #fig.suptitle(\"Cimes population by Country\")\n    sns.set_theme(style=\"whitegrid\")\n    sns.barplot(ax = axes,  data = data[data['continent'] == continent].head(40), \n                x = 'name', y = 'population', \n                color = 'black')\n    axes.set_title('Cimes population by country in ' + continent)\n    axes.set_ylim([0, 2e8])\n    plt.xticks(rotation=90)\n    sns.despine(ax = axes, top=True, right=True, left=True, bottom=False, offset=None, trim=True)\n    plt.show()\n    \n    urban_join = joined.loc[(joined['population'] > 10000) & (joined['continent'] == continent)]\n    print(continent + ' has ' + str(urban_join['population'].sum()) +  ' total urban inhabitants')\n    print(str(round(urban_join['population'].sum()\/un_pop['pop_2020'][0].sum()*100, 2)) + \n              '% of the world population in ' + str(round(urban_join['city'].count(), 0)) + ' cities')","0740b0b4":"data = joined.groupby(['city_class', 'continent'])['population'].sum().reset_index()\norder = ['small', 'cimes', 'big']\n\nfig, axes = plt.subplots(1, 6, figsize=(15, 3.5), sharey=True)\nfig.suptitle(\"Total population by city Type by Region\")\n\nfor i in range(0, len(cont_list)):\n    sns.set_theme(style=\"whitegrid\")\n    sns.barplot(ax = axes[i], \n                data=data.loc[data['continent'] == cont_list[i]], \n                x = 'city_class', y = 'population', \n                color = 'black',\n               order = order)\n    axes[i].set_title(cont_list[i])\n    sns.despine(ax = axes[i], top=True, right=True, left=True, bottom=False, offset=None, trim=False)\n    \nplt.tight_layout()    \nplt.show()","f1a1b17e":"data = joined.groupby(['city_class', 'continent'])['city'].count().reset_index()\nfig, axes = plt.subplots(1, 6, figsize=(15, 3.5), sharey=True)\nfig.suptitle(f'no. of population cities by region')\n\nfor i in range(0, len(cont_list)):\n    sns.set_theme(style=\"whitegrid\")\n    sns.barplot(ax = axes[i], \n                data=data.loc[data['continent'] == cont_list[i]], \n                x = 'city_class', y = 'city', \n                color = 'black',\n               order = order)\n    axes[i].set_title(cont_list[i])\n    sns.despine(ax = axes[i], top=True, right=True, left=True, bottom=False, offset=None, trim=False)  # quitamos linea superior del marco\n    \nplt.tight_layout()\nplt.show()","de4838ec":"#urbanization ratio\nurb = pd.read_csv('..\/input\/proportion-of-urban-population-by-country\/UN_urban_proportion_prospect.csv', sep = ';')\nurb.rename(columns = {'Country\\ncode': 'country-code', '2016': 'urb_2016'}, inplace = True)\n\nsel_urb = urb[['country-code', 'urb_2016']]\nsel_urb['urb_2016'] = sel_urb['urb_2016'].str.replace(',', '.')\nc = sel_urb['urb_2016']\nsel_urb['urb_2016'] = c.astype(float)\n\n\n#world development sustainability indicators\nwdi_sus = pd.read_csv('..\/input\/world-development-indicators-by-countries\/sustainability.csv')\nsel_sus = wdi_sus[['Country',\n                   'Ambient PM2.5 air pollution mean annual exposure micrograms per cubic meter 2016']]\n\n#world development health risk indicators\nwdi_hlthr = pd.read_csv('..\/input\/world-development-indicators-by-countries\/Health_Risk_factors.csv')\nsel_hlthr = wdi_hlthr[['Country', \n                       'Prevalence of diabetes  % of population ages 20 to 79 2019', \n                       'Cause of death Communicable diseases and maternal, prenatal, and nutrition conditions % of population 2016',\n                       'Cause of death Non-communicable diseases % of population 2016']]\n\n#world development health system indicators\nwdi_hlths = pd.read_csv('..\/input\/world-development-indicators-by-countries\/health_system.csv')\nsel_hlths = wdi_hlths[['Country', \n                       'Health expenditure Current % of GDP 2016',\n                       'Health expenditure Public % of current 2016']]\n\n#world development life expectancy indicators\nwdi_ind = pd.read_csv('..\/input\/d\/kaggle\/world-development-indicators\/Indicators.csv')\nwdi_ind.rename(columns = {'CountryCode': 'alpha-3', 'Value': 'lf_exp_2013'}, inplace = True)\n\nsel_ind = wdi_ind[['alpha-3', 'IndicatorName', 'Year', 'lf_exp_2013']].loc[(wdi_ind['IndicatorName'] == 'Life expectancy at birth, total (years)') &\n                                                                     (wdi_ind['Year'] == 2013)]\nsel_ind.drop(columns= ['IndicatorName', 'Year'], inplace = True)\n\n#GDP by country\ngdp = pd.read_csv('..\/input\/gdp-annual-growth-for-each-country-1960-2020\/GDP_annual_growth.csv')\ngdp.rename(columns = {'Country Code': 'alpha-3', '2016': 'gdp_2016'}, inplace = True )\nsel_gdp = gdp[['alpha-3', 'Indicator Name', 'gdp_2016']]","3b3271f8":"#merge data\ndata_list = [codes, city_stats]\nmerged1 = reduce(lambda  left, right:  pd.merge(left, right,  on = ['alpha-2'],  how = 'left'),  data_list)\n\nwdi_list = [sel_sus, sel_hlthr, sel_hlths]\nmerged2 = reduce(lambda  left, right:  pd.merge(left, right,  on = ['Country'],  how = 'outer'),  wdi_list)\nmerged2['name'] = merged2['Country']\n\ngdp_list = [codes, sel_gdp, sel_ind]\nmerged3 = reduce(lambda  left, right:  pd.merge(left, right,  on = ['alpha-3'],  how = 'outer'),  gdp_list)\n\npop_list = [codes, un_pop, sel_urb]\nmerged4 = reduce(lambda  left, right:  pd.merge(left, right,  on = ['country-code'],  how = 'outer'),  pop_list)","f65dfea3":"#this dict comes from an. humiliating background selection task\nrplc_dict = {'Bahamas, The': 'Bahamas',\n             'Bosnia and Herzegovina': 'Bosnia And Herzegovina',\n             'Channel Islands': np.nan,\n             'Hong Kong SAR, China': 'Hong Kong',\n             'Macao SAR, China': 'Macao',\n             'Congo, Dem. Rep.': 'Congo (Democratic Republic Of The)',\n             'Congo, Rep.': 'Congo',\n             \"Cote d'Ivoire\": \"C\u00f4te D'Ivoire\",\n             'Curacao': 'Cura\u00e7ao',\n             'Egypt, Arab Rep.': 'Egypt',\n             'Gambia, The': 'Gambia',\n             'Guinea-Bissau': 'Guinea Bissau',\n             'Iran, Islamic Rep.': 'Iran',\n             'Korea, Dem. People\u2019s Rep.': 'Korea, Republic of',\n             'Korea, Rep.': 'South Korea',\n             'Kosovo': np.nan,\n             'Kyrgyz Republic': 'Kyrgyzstan',\n             'Lao PDR': 'Laos',\n             'North Macedonia': np.nan,\n             'Micronesia, Fed. Sts.': 'Micronesia (Federated States of)',\n             'Russian Federation': 'Russia',\n             'Slovak Republic': 'Slovakia',\n             'St. Kitts and Nevis': 'Saint Kitts and Nevis',\n             'St. Lucia': 'Saint Lucia',\n             'St. Martin (French part)': 'Saint Martin (French part)',\n             'St. Vincent and the Grenadines': 'Saint Vincent and the Grenadines',\n             'Syrian Arab Republic': 'Syria',\n             'Venezuela, RB': 'Venezuela',\n             'West Bank and Gaza': np.nan,\n             'Yemen, Rep.': 'Yemen'}\n\nfor key in rplc_dict:\n    merged2.loc[merged2['Country'] == key, 'name'] = rplc_dict[key]\n\nname_merge = codes.merge(merged2, on = 'name', how = 'left')\nname_merge.drop(columns = ['name', 'alpha-2', 'country-code','region','sub-region', 'Country'], inplace = True)\nname_merge.head()","372aa590":"df_list = [merged1, \n           merged3[['alpha-3', 'gdp_2016', 'lf_exp_2013']], \n           merged4[['alpha-3', 'pop_2020', 'urb_2016']]]\nalpha_merge = reduce(lambda  left, right: pd.merge(left, right,  on = ['alpha-3'],  how = 'outer'),  df_list)\nalpha_merge.dropna(axis = 0, subset = ['pop_2020', 'name'], inplace = True)\nalpha_merge.head()","f60205fc":"final_merge = alpha_merge.merge(name_merge, on = 'alpha-3', how = 'left')\nfinal_merge.rename( columns = {'Renewable energy consumption  % of total final energy consumption 2015': '%_green_energy_2015',\n                               'Ambient PM2.5 air pollution mean annual exposure micrograms per cubic meter 2016': 'pm_2.5_mcg\/m3_2016',\n                               'Carbon dioxide emissions per capita metric tons 2014': 'co2_cap_2014',\n                               'Prevalence of diabetes  % of population ages 20 to 79 2019': '%_diabetes_2019', \n                               'Cause of death Communicable diseases and maternal, prenatal, and nutrition conditions % of population 2016': '%_comm_deaths_2016', \n                               'Cause of death Non-communicable diseases % of population 2016': '%_uncomm_deaths_2016', \n                               'Health expenditure Current % of GDP 2016': '%_gdp_health_exp_2016', \n                               'Health expenditure Public % of current 2016': '%_public_health_2016'}, \n                   inplace = True)\n\n\nfn = final_merge.copy()\nfn['gdp_pc'] = round(fn['gdp_2016']\/fn['pop_2020']*100, 2)\nfn['%_pop_small'] = round(fn['pop_small']\/fn['pop_2020']*100, 2)\nfn['%_pop_cimes'] = round(fn['pop_cimes']\/fn['pop_2020']*100, 2)\nfn['%_pop_big'] = round(fn['pop_big']\/fn['pop_2020']*100, 2)\nfn.head()","b9ace1e3":"sel_list = ['%_pop_small', '%_pop_cimes', '%_pop_big',\n            'region', 'gdp_pc', 'lf_exp_2013', 'urb_2016',\n            '%_gdp_health_exp_2016', '%_public_health_2016', 'pm_2.5_mcg\/m3_2016', \n            '%_diabetes_2019', '%_comm_deaths_2016', '%_uncomm_deaths_2016']\n\nsel_fn = fn[sel_list]\n\ncorr = sel_fn.corr(method='pearson')\nfig, ax = plt.subplots(figsize=(15,10)) \nsns.heatmap(corr, annot=True, annot_kws={\"size\": 10}, cmap = 'RdGy', ax=ax)","cc63e02b":"#params\nsel = fn[sel_list]\nclas_list = ['small','cimes', 'big']\nrg_list = ['Asia', 'Europe', 'Americas', 'Africa', 'Oceania']\ncolors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff']","6cf5c893":"for clas in clas_list:\n    fig, axes = plt.subplots(1, 5, figsize=(25, 4.5), sharey=True, sharex = True)\n    fig.suptitle(f'Correlation % of population living {clas.capitalize()} Cities and GDP per capita by Region')\n    data = fn.loc[fn[f'%_pop_{clas}'] > 0]\n    field = f'%_pop_{clas}'\n    \n    for i in range(0, len(rg_list)):\n        sns.set_theme(style=\"whitegrid\")\n        sns.regplot(ax=axes[i], \n                    x=data.loc[data['region'] == rg_list[i]][field], \n                    y=data.loc[data['region'] == rg_list[i]]['gdp_pc'],\n                    color = colors[i], \n                    ci = None, \n                    truncate = False)\n        axes[i].set_xlim([0, 100])\n        axes[i].set_ylim([0, 2e7])\n        \n        axes[i].set_title(rg_list[i])\n        \n    plt.show()","79ce3097":"for clas in clas_list:\n    fig, axes = plt.subplots(1, 5, figsize=(25, 4.5), sharey=True, sharex = True)\n    fig.suptitle(f'Correlation % population living in {clas.capitalize()} Cities and Life Expectancy by Region')\n    data = fn.loc[fn[f'%_pop_{clas}'] > 0]\n    field = f'%_pop_{clas}'\n    \n    for i in range(0, len(rg_list)):\n        sns.set_theme(style=\"whitegrid\")\n        sns.regplot(ax=axes[i], \n                    x=data.loc[data['region'] == rg_list[i]][field], \n                    y=data.loc[data['region'] == rg_list[i]]['lf_exp_2013'],\n                    color = colors[i], \n                    ci = None, \n                    truncate = False)\n        axes[i].set_xlim([0, 100])\n        axes[i].set_ylim([0, 100])\n        axes[i].set_title(rg_list[i])\n        \n    plt.show()","cc3cd4b3":"for clas in clas_list:\n    fig, axes = plt.subplots(1, 5, figsize=(25, 5), sharey=True, sharex = True)\n    sns.set_theme(style=\"whitegrid\")\n    fig.suptitle(f'Correlation % population Living in {clas.capitalize()} Cities and PM 2.5 emissions (mcg\/m3) by Region')\n    data = fn.loc[fn[f'%_pop_{clas}'] > 0]\n    field = f'%_pop_{clas}'\n    \n    for i in range(0, len(rg_list)):\n        sns.regplot(ax=axes[i], \n                    x=data.loc[data['region'] == rg_list[i]][field], \n                    y=data.loc[data['region'] == rg_list[i]]['pm_2.5_mcg\/m3_2016'],\n                    color = colors[i],\n                    ci = None, \n                    truncate = False)\n        axes[i].set_xlim([0, 100])\n        axes[i].set_ylim([0, 100])\n        axes[i].set_title(rg_list[i])\n        \n    plt.show()","fe19c3ff":"for clas in clas_list:\n    fig, axes = plt.subplots(1, 5, figsize=(25, 4.5), sharey=True, sharex = True)\n    sns.set_theme(style=\"whitegrid\")\n    fig.suptitle(f'Correlation % population living in {clas.capitalize()} Cities and % of Communicable Deaths by Region')\n    data = fn.loc[fn[f'%_pop_{clas}'] > 0]\n    field = f'%_pop_{clas}'\n    \n    for i in range(0, len(rg_list)):\n        sns.regplot(ax=axes[i], \n                    x=data.loc[data['region'] == rg_list[i]][field], \n                    y=data.loc[data['region'] == rg_list[i]]['%_comm_deaths_2016'],\n                    color = colors[i], \n                    ci = None,\n                    truncate = False)\n        axes[i].set_xlim([0, 100])\n        axes[i].set_ylim([0, 100])\n        axes[i].set_title(rg_list[i])\n        \n    plt.show()","1b50f5b4":"for clas in clas_list:\n    fig, axes = plt.subplots(1, 5, figsize=(25, 4.5), sharey=True)\n    sns.set_theme(style=\"whitegrid\")\n    fig.suptitle(f'Correlation between % population living in {clas.capitalize()} Cities and % of Uncommunicable Deaths by Region')\n    data = fn.loc[fn[f'%_pop_{clas}'] > 0]\n    field = f'%_pop_{clas}'\n    \n    for i in range(0, len(rg_list)):\n        sns.regplot(ax=axes[i], \n                    x=data.loc[data['region'] == rg_list[i]][field], \n                    y=data.loc[data['region'] == rg_list[i]]['%_uncomm_deaths_2016'],\n                    color = colors[i], \n                    ci = None,\n                    truncate = False)\n        axes[i].set_xlim([0, 100])\n        axes[i].set_ylim([0, 100])\n        axes[i].set_title(rg_list[i])\n        \n    plt.show()","875e60c3":"#params\n\nclas_list = ['small','cimes', 'big']\nrg_list = list(sel['region'].unique())\ncolors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff']\n\n\nfor clas in clas_list:\n    fig, axes = plt.subplots(1, 5, figsize=(25, 4.5), sharey=True, sharex = True)\n    fig.suptitle(f'Correlation % population living in {clas.capitalize()} Cities and Prevalence of Diabetes')\n    data = fn.loc[fn[f'%_pop_{clas}'] > 0]\n    field = f'%_pop_{clas}'\n    \n    for i in range(0, len(rg_list)):\n        sns.set_theme(style=\"whitegrid\")\n        sns.regplot(ax=axes[i], \n                    x=data.loc[data['region'] == rg_list[i]][field], \n                    y=data.loc[data['region'] == rg_list[i]]['%_diabetes_2019'],\n                    color = colors[i],\n                    truncate = False,\n                    ci = None)\n        axes[i].set_xlim([0, 100])\n        axes[i].set_ylim([0, 100])\n        axes[i].set_title(rg_list[i])\n        \n    plt.show()","d48fc873":"# Maps by world region","188ea25b":"# Exploring relationships between city types and health indicators with regression plots","168a8bb5":"# Part II. Data Analysis\n\nThe purpose of this part of the notebook is to dicover relationships and trends between global health indicators and city sizes stated in the first part. \nThe selected health indicators are: \n* Life expentancy\n* Health expenditure Current % of GDP\n* Health expenditure Public % of current\n* Ambient PM2.5 air pollution mean annual exposure micrograms per cubic meter\n* Prevalence of diabetes  % of population ages 20 to 79\n* Cause of death Communicable diseases and maternal, prenatal, and nutrition conditions % of population\n* Cause of death Non-communicable diseases % of population\n\nIn addition we included the country urbanisation ratio and GDP per capita to have some more context in the survey.","1e7730a8":"# Plotting cities by size in the world","62363109":"# World population by country","6227c747":"# Intermediary Cities (CIMES) World Stats (work in progress).\n\nIntermediary cities are defined as those with population between 1,000,000 and 50,000 people. This wide range is due to the broad existent context around the world. Is not the same a city with one million inhabitants in China than, for instance, a provincial capital city in the European continent. But even so it's considered that they share especific characteristics related to proximity, provision of services or intermediation between rural land and larger trade centers.\n\nFor further information visit: https:\/\/www.researchgate.net\/publication\/333623025_Las_ciudades_intermedias_concepto_y_dimensiones\n\nThe main purpose of this notebook is to gather material for a masterclass in the postgraduate course Urbanism and Health (https:\/\/bit.ly\/3aYioo5) exploring relationships between city sizes and health indicators.","d254df4b":"## Cimes are not (only) related to size\nThe main charatetistics of intermediary cities are their capacities to intermediate between different realities: rural-urban, admin heirarchies, local-global... for this reason we state that the size doesn't strictly matter.","f08e7f1d":"# Part I. Mapping","cc1bffa8":"# Getting the whole urban picture","2e0892f6":"# Cities classification by size"}}