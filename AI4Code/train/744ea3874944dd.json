{"cell_type":{"ff31a566":"code","e3276db3":"markdown"},"source":{"ff31a566":"import random\nimport csv\nimport time\nimport scipy.optimize\nimport numpy as np\nimport pandas as pd\nimport statsmodels.api as sm\nfrom numba import njit\nfrom ortools.linear_solver import pywraplp\n\nNMB_DAYS = 100\nNMB_FAMILIES = 5000\nMAX_PEOPLE_PERDAY = 300\nMIN_PEOPLE_PERDAY = 125\n\n# only top 5 (0-4) preferences are allowed for assignment\n# this decreases size of the model\nMAX_PREF_ALLOWED = 4\n\n#**************** solution representation *********************\n#current solution cost\ncost_ = 0\n\n#[I] is the day family I is assigned to\nassignment_ = [-1 for i in range(NMB_FAMILIES)]\n\n#[d] is number of people assigned to day d\nnmb_people_assigned_to_day_ = [0 for i in range(NMB_DAYS)]\n\n#[d] is the list of families assigned to day d\nfamilies_assigned_to_day_ = []\nfor i in range(NMB_DAYS):\n  families_assigned_to_day_.append([])   \n#**************************************************************\n\ndef get_penalty(n, choice):\n    penalty = None\n    if choice == 0:\n        penalty = 0\n    elif choice == 1:\n        penalty = 50\n    elif choice == 2:\n        penalty = 50 + 9 * n\n    elif choice == 3:\n        penalty = 100 + 9 * n\n    elif choice == 4:\n        penalty = 200 + 9 * n\n    elif choice == 5:\n        penalty = 200 + 18 * n\n    elif choice == 6:\n        penalty = 300 + 18 * n\n    elif choice == 7:\n        penalty = 300 + 36 * n\n    elif choice == 8:\n        penalty = 400 + 36 * n\n    elif choice == 9:\n        penalty = 500 + 36 * n + 199 * n\n    else:\n        penalty = 500 + 36 * n + 398 * n\n    return penalty\n\ndef GetAssignmentCostMatrix(data):\n    cost_matrix = np.zeros((NMB_FAMILIES, NMB_DAYS), dtype=np.int64)\n    for i in range(NMB_FAMILIES):\n        desired = data.values[i, :-1]\n        cost_matrix[i, :] = get_penalty(FAMILY_SIZE[i], 10)\n        for j, day in enumerate(desired):\n            cost_matrix[i, day-1] = get_penalty(FAMILY_SIZE[i], j)\n    return cost_matrix\n\ndef GetAccountingCostMatrix():\n    ac = np.zeros((1000, 1000), dtype=np.float64)\n    for n in range(ac.shape[0]):\n        for n_p1 in range(ac.shape[1]):\n            diff = abs(n - n_p1)\n            ac[n, n_p1] = max(0, (n - 125) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n    return ac\n\ndef GetPreferenceMatrix(data):\n    pref_matrix = np.zeros((NMB_FAMILIES, NMB_DAYS), dtype=np.int64)\n    for i in range(NMB_FAMILIES):\n        desired = data.values[i, :-1]\n        pref_matrix[i, :] = 10\n        for j, day in enumerate(desired):\n            pref_matrix[i, day-1] = j\n    return pref_matrix\n\ndef GetPreferenceForFamiliesMatrix(data):\n    pref_matrix = np.zeros((NMB_FAMILIES, NMB_DAYS), dtype=np.int64)\n    pref_matrix2 = np.zeros((NMB_FAMILIES, 10), dtype=np.int64)\n    for i in range(NMB_FAMILIES):\n        desired = data.values[i, :-1]\n        pref_matrix[i, :] = 10\n        for j, day in enumerate(desired):\n            pref_matrix[i, day-1] = j\n    for i in range(NMB_FAMILIES):\n      for j in range(NMB_DAYS):\n        if(pref_matrix[i][j] < 10):\n           pref_matrix2[i][pref_matrix[i][j]] = j         \n    return pref_matrix2\n\n# to speed up the local search\n# [D1][D2] is the list of families currently assigned to \n# D1 that can be swapped with something on day D2\nswap_candidates_ = []   \nfor i in range(NMB_DAYS):\n    swap_candidates_.append([])\n    for j in range(NMB_DAYS):\n        swap_candidates_[i].append([])\n\n        \n# drop some assignment possibilities in order to reduce problem size\ndef preprocessing():\n\n    # nbTopForBinN[P, D] represents the number of people (people, not families) that have day D in top P + 1 preferences\n    # we will eliminate some assignment posibilities\n    # for example, if more than 300 people have day D as preference 0 then we only allow preferences 0 and 1 for this day\n    # the only purpose of having this elimination is to reduce the number of variables for MIP\n    # but algorithm should work fine without this reduction\n\n    nbTopForBinN = {}\n    for i in range(10):\n        for j in range(NMB_DAYS):\n           nbTopForBinN[i, j] = 0\n\n    for F in range(NMB_FAMILIES):\n        for i in range(MAX_PREF_ALLOWED + 1):\n             D = PREFERENCES_FOR_FAMILY[F][i]\n             for p in range(i, MAX_PREF_ALLOWED + 1):\n                 nbTopForBinN[p, D] += FAMILY_SIZE[F]\n    \n    nmbVarsDROPPED = 0\n\n    for i in range(NMB_DAYS):\n       if nbTopForBinN[0, i] < 100:\n           for F in range(NMB_FAMILIES):\n               if PREFERENCES_FOR_FAMILY[F][0] == i:\n                  for P in range(1, MAX_PREF_ALLOWED + 1):\n                    if PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] < 10:\n                       nmbVarsDROPPED += 1\n                       PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] = 10\n\n    for D in range(NMB_DAYS):\n        if nbTopForBinN[0, D] >= 300:\n           for F in range(NMB_FAMILIES):\n               for P in range(2, MAX_PREF_ALLOWED + 1):\n                   if PREFERENCES_FOR_FAMILY[F][P] == D:\n                      if PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] < 10:\n                         nmbVarsDROPPED += 1\n                         PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] = 10\n\n    for D in range(NMB_DAYS):\n        if nbTopForBinN[1, D] >= 300 and nbTopForBinN[0, D] < 300:\n           for F in range(NMB_FAMILIES):\n               for P in range(3, MAX_PREF_ALLOWED + 1):\n                   if PREFERENCES_FOR_FAMILY[F][P] == D:\n                      if PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] < 10:\n                         nmbVarsDROPPED += 1\n                         PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] = 10\n\n\n    for D in range(NMB_DAYS):\n        if nbTopForBinN[2, D] >= 300 and nbTopForBinN[0, D] < 300 and nbTopForBinN[1, D] < 300:\n           for F in range(NMB_FAMILIES):\n               for P in range(4, MAX_PREF_ALLOWED + 1):\n                   if PREFERENCES_FOR_FAMILY[F][P] == D:\n                      if PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] < 10:\n                         nmbVarsDROPPED += 1\n                         PREFERENCE_MATRIX[F, PREFERENCES_FOR_FAMILY[F][P]] = 10\n\n    \n# calculate current solution cost\ndef calculate_solution_cost():\n    global cost_\n    cost_ = 0\n    assign_cost = 0\n    account_cost = 0\n    for i in range(NMB_FAMILIES):\n       cost_ += ASSIGNMENT_COST_MATRIX[i][assignment_[i]]\n    assign_cost = cost_\n    for d in range(NMB_DAYS):\n        today_count = nmb_people_assigned_to_day_[d]\n        yesterday_count = today_count\n        if(d < NMB_DAYS - 1):\n           yesterday_count = nmb_people_assigned_to_day_[d + 1]\n        cost_ += ACCOUNTING_COST_MATRIX[today_count][yesterday_count]\n        account_cost += ACCOUNTING_COST_MATRIX[today_count][yesterday_count]\n    return cost_, assign_cost, account_cost\n\n# accept a given assignment as a new one\ndef update_solution(assign):\n    global cost_ \n    global nmb_people_assigned_to_day_ \n    global assignment_    \n    for i in range(NMB_DAYS):\n       nmb_people_assigned_to_day_[i] = 0\n       families_assigned_to_day_[i] = []\n       for j in range(NMB_DAYS):\n           swap_candidates_[i][j] = []\n            \n    for F in range(NMB_FAMILIES):\n       day = assign[F] \n       assignment_[F] = day\n       nmb_people_assigned_to_day_[day] += FAMILY_SIZE[F]\n       families_assigned_to_day_[day].append(F)\n    \n       for k in range(MAX_PREF_ALLOWED + 1):\n            DD = PREFERENCES_FOR_FAMILY[F][k]\n            if(PREFERENCE_MATRIX[F][DD] <= MAX_PREF_ALLOWED):\n               swap_candidates_[day][DD].append(F);\n    \n    calculate_solution_cost()  \n\n# calculate accounting cost for a given occupacy list and given days\n# used when evaluating moves\ndef calculate_accounting_cost(nmb_people_assigned_to_day_, days_to_calc):\n    accounting_cost = 0\n    for d in days_to_calc:\n        today_count = nmb_people_assigned_to_day_[d]\n        yesterday_count = nmb_people_assigned_to_day_[d]\n        if(d < NMB_DAYS - 1):\n           yesterday_count = nmb_people_assigned_to_day_[d + 1]\n        accounting_cost += ACCOUNTING_COST_MATRIX[today_count][yesterday_count]    \n    return accounting_cost\n\n# check if move is feasible\ndef check_move(F1, F2, D2):\n    global cost_ \n    global nmb_people_assigned_to_day_ \n    global assignment_  \n    D1 = assignment_[F1]\n    N1 = FAMILY_SIZE[F1]\n    N2 = 0\n    if(F2 >= 0):\n        N2 = FAMILY_SIZE[F2]\n    if(nmb_people_assigned_to_day_[D1] - N1 + N2 < MIN_PEOPLE_PERDAY):\n        return False\n    if(nmb_people_assigned_to_day_[D1] - N1 + N2 > MAX_PEOPLE_PERDAY):\n        return False\n    if(nmb_people_assigned_to_day_[D2] - N2 + N1 < MIN_PEOPLE_PERDAY):\n        return False\n    if(nmb_people_assigned_to_day_[D2] - N2 + N1 > MAX_PEOPLE_PERDAY):\n        return False\n    return True\n\ndef calculate_assignment_cost_diff_with_move(F1, F2, D2):\n    D1 = assignment_[F1]\n    cost_diff = 0\n    cost_diff += (ASSIGNMENT_COST_MATRIX[F1][D2] - ASSIGNMENT_COST_MATRIX[F1][D1])\n    if(F2 >= 0):\n        cost_diff += (ASSIGNMENT_COST_MATRIX[F2][D1] - ASSIGNMENT_COST_MATRIX[F2][D2])\n    return cost_diff\n\ndef calculate_accounting_cost_diff_with_move(F1, F2, D2):\n    D1 = assignment_[F1]\n    N1 = FAMILY_SIZE[F1]\n    N2 = 0\n    if(F2 >= 0):\n        N2 = FAMILY_SIZE[F2]\n    accounting_cost_diff = 0\n    accounting_cost_old = 0\n    accounting_cost_new = 0\n    days_to_calc = {D1, D2}\n    if(D1 > 0):\n       days_to_calc.add(D1 - 1)\n    if(D2 > 0):\n       days_to_calc.add(D2 - 1)\n    accounting_cost_old = calculate_accounting_cost(nmb_people_assigned_to_day_, days_to_calc)\n    nmb_people_assigned_to_day_new_ = list(nmb_people_assigned_to_day_)\n    nmb_people_assigned_to_day_new_[D1] += (N2 - N1)\n    nmb_people_assigned_to_day_new_[D2] += (N1 - N2)\n    accounting_cost_new = calculate_accounting_cost(nmb_people_assigned_to_day_new_, days_to_calc)\n    accounting_cost_diff = accounting_cost_new - accounting_cost_old\n    return accounting_cost_diff\n\n\ndef perform_move(F1, F2, D2):\n    global cost_ \n    global nmb_people_assigned_to_day_ \n    global assignment_  \n    D1 = assignment_[F1]\n    N1 = FAMILY_SIZE[F1]\n    N2 = 0\n    if(F2 >= 0):\n        N2 = FAMILY_SIZE[F2]\n        \n    assignment_[F1] = D2\n    families_assigned_to_day_[D2].append(F1)\n    families_assigned_to_day_[D1].remove(F1)\n    \n    for k in range(MAX_PREF_ALLOWED + 1):\n        DD = PREFERENCES_FOR_FAMILY[F1][k]\n        if(PREFERENCE_MATRIX[F1][DD] <= MAX_PREF_ALLOWED):\n            swap_candidates_[D2][DD].append(F1);\n            swap_candidates_[D1][DD].remove(F1);\n                                        \n    if(F2 >= 0):\n       assignment_[F2] = D1\n       families_assigned_to_day_[D1].append(F2)\n       families_assigned_to_day_[D2].remove(F2)\n\n       for k in range(MAX_PREF_ALLOWED + 1):\n           DD = PREFERENCES_FOR_FAMILY[F2][k]\n           if(PREFERENCE_MATRIX[F2][DD] <= MAX_PREF_ALLOWED):\n                swap_candidates_[D1][DD].append(F2);\n                swap_candidates_[D2][DD].remove(F2);\n                \n    nmb_people_assigned_to_day_[D1] += (N2 - N1)\n    nmb_people_assigned_to_day_[D2] += (N1 - N2)\n    \n    calculate_solution_cost()\n\n\n# once in 1000 times accept move that increases the cost (by not more than 50) \nTOLRAND = 1000\nTOL = 50\nassCostDiffTOL = 10000000\n\ndef local_search_shift_and_swap(nmbIters):\n    iter = 0\n    while iter < nmbIters:\n        iter+=1\n        F1 = random.randint(0, NMB_FAMILIES - 1)\n        D1 = assignment_[F1]\n        r = random.randint(0, MAX_PREF_ALLOWED)\n        D2 = PREFERENCES_FOR_FAMILY[F1][r]\n        if(D1 == D2):\n            continue\n        if(PREFERENCE_MATRIX[F1][D2] > MAX_PREF_ALLOWED):\n           continue\n        F2 = -1 # shift\n        if(random.randint(0, 100) < 10): #swap                        \n            if len(swap_candidates_[D2][D1]) == 0:\n                continue            \n            r = random.randint(0, len(swap_candidates_[D2][D1]) - 1)\n            F2 = swap_candidates_[D2][D1][r]                        \n            if(PREFERENCE_MATRIX[F2][D1] > MAX_PREF_ALLOWED):\n               continue\n\n        if(check_move(F1, F2, D2) == False):\n           continue\n\n        ass_cost_diff = calculate_assignment_cost_diff_with_move(F1, F2, D2)\n        if(ass_cost_diff > assCostDiffTOL):\n           continue\n        acc_cost_diff = calculate_accounting_cost_diff_with_move(F1, F2, D2)\n        cost_diff = ass_cost_diff + acc_cost_diff\n        tol = 0\n        if(random.randint(0, TOLRAND) == 1):            \n            tol = TOL\n\n        if(cost_diff <= tol and ass_cost_diff <= assCostDiffTOL):\n            perform_move(F1, F2, D2)\n\n\ndef LocalSearch(timeLimit, maxIters):\n    startTime = time.time()\n    iter = 0\n    global assCostDiffTOL\n    assCostDiffTOL = 0\n    best_assignment = {}\n    for i in range(NMB_FAMILIES):\n        best_assignment[i] = assignment_[i]\n    bestCost = cost_\n\n    while(iter < maxIters):\n        if(time.time() - startTime >= timeLimit):\n            break\n        iter+=1\n        if(iter % 5 == 0):    \t \n           update_solution(best_assignment)\n\n        local_search_shift_and_swap(20000)\n\n        #print(cost_, bestCost)\n        if(cost_ < bestCost):\n            bestCost = cost_\n            print(iter, bestCost, int(time.time() - startTime))\n            for i in range(NMB_FAMILIES):\n               best_assignment[i] = assignment_[i]\n\n        assCostDiffTOL += 1\n\n    update_solution(best_assignment)\n\n\n#linear regression (3D plane fitting)\ndef reg_m(y, x):\n    ones = np.ones(len(x[0]))\n    X = sm.add_constant(np.column_stack((x[0], ones)))\n    for ele in x[1:]:\n        X = sm.add_constant(np.column_stack((ele, X)))\n    results = sm.OLS(y, X).fit()\n    return results\n\nDELTA = 1\nLINEARIZE = False\n\n# calculate linear regression for each day ()\ndef linearize():\n  resultABC = []\n  for d in range(NMB_DAYS):\n    resultABC.append([])\n\n  for D in range(NMB_DAYS):\n     x = []\n     x.append([])\n     x.append([])\n     y = []\n     LB = max(MIN_PEOPLE_PERDAY, nmb_people_assigned_to_day_[D] - DELTA)\n     UB = min(MAX_PEOPLE_PERDAY, nmb_people_assigned_to_day_[D] + DELTA)\n     dom1 = {LB}\n     for i in range (LB + 1, UB + 1):\n       dom1.add(i)\n\n     if D < NMB_DAYS - 1:\n        LB = max(MIN_PEOPLE_PERDAY, nmb_people_assigned_to_day_[D + 1] - DELTA)\n        UB = min(MAX_PEOPLE_PERDAY, nmb_people_assigned_to_day_[D + 1] + DELTA)\n        dom2 = {LB}\n        for i in range (LB + 1, UB + 1):\n          dom2.add(i)\n        for i in dom1:\n          for j in dom2:\n            x[0].append(i)\n            x[1].append(j)\n            y.append(ACCOUNTING_COST_MATRIX[i, j])\n     else:\n        for i in dom1:\n             x[0].append(i)\n             x[1].append(i)\n             y.append(ACCOUNTING_COST_MATRIX[i, i])\n\n     result = reg_m(y,x)\n\n     if(nmb_people_assigned_to_day_[D] == 125):\n        result.params[0] = 0\n        result.params[1] = 10000\n        result.params[2] = -125 * 10000\n\n     resultABC[D] = result.params\n     p = resultABC[D][0]\n     resultABC[D][0] = resultABC[D][1]\n     resultABC[D][1] = p\n\n  return resultABC\n\n# mixed integer program to solve the problem\n# if LINEARIZED is false then it basically solves a classical assignment problem\n# othervise we also take into account the accounting cost by linearizing it\n# only few possibilities are allowed for daily occupancy so linearization is possible\ndef MIP(timeLimit):\n    \n    # Create the mip solver with the CBC backend.\n    solver = pywraplp.Solver('simple_mip_program', pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)\n\n    x = {}\n    C = {}\n    key = {} # key[i, j] is the index od variable that corresponds to the edge (i, j)\n    K = 0\n    for i in range(NMB_FAMILIES):\n        for j in range(NMB_DAYS):\n          if PREFERENCE_MATRIX[i, j] <= MAX_PREF_ALLOWED:\n              key[i, j] = K\n              x[K] = solver.BoolVar('x[%i,%i]' % (i, j))\n              C[K] = ASSIGNMENT_COST_MATRIX[i, j]\n              K = K + 1        \n          else:\n              key[i, j] = -1\n\n    nmbvar = solver.NumVariables()\n    print('Number of variables =', solver.NumVariables())\n\n    # Constraints\n\n    # exactely one day for each family\n    for i in range(NMB_FAMILIES):       \n        expr = 0\n        for j in range(NMB_DAYS):\n           if key[i, j] >= 0:\n              expr = expr + x[key[i, j]]\n        solver.Add(expr == 1)\n\n    # occupancy\n    occ = {}\n    for i in range(NMB_DAYS):        \n        occ[i] = solver.IntVar(0.0, 1000.0, 'occ[%i,%i]' % (i, 0))\n\n    for i in range(NMB_DAYS):\n        expr = 0\n        for j in range(NMB_FAMILIES):\n           if key[j, i] >= 0:\n              expr += (x[key[j, i]] * FAMILY_SIZE[j])\n        LB = MIN_PEOPLE_PERDAY\n        UB = MAX_PEOPLE_PERDAY\n        if LINEARIZE:\n            LB = max(nmb_people_assigned_to_day_[i] - DELTA, MIN_PEOPLE_PERDAY)\n            UB = min(nmb_people_assigned_to_day_[i] + DELTA, MAX_PEOPLE_PERDAY)\n        solver.Add(expr >= LB)\n        solver.Add(expr <= UB)\n        solver.Add(occ[i] == expr)\n\n    print('Number of constraints =', solver.NumConstraints())\n   \n    # Objective\n    obj = solver.Sum([C[i] * x[i] for i in range(nmbvar)])\n    \n    #2nd objective - linearized\n    if LINEARIZE == True:\n        obj2 = 0\n        ABC = linearize()\n        for D in range(NMB_DAYS - 1):\n           a = ABC[D][0]\n           b = ABC[D][1]\n           c = ABC[D][2]                      \n           if D < NMB_DAYS - 1:\n              obj2 = obj2 + (a * occ[D] + b * occ[D + 1] + c)\n           else:\n              obj2 = obj2 + (a * occ[D] + b * occ[D] + c)\n        obj = obj + 1 * obj2\n    \n    solver.Minimize(obj)\n\n    #params\n    solver.SetTimeLimit(1000 * timeLimit) ## time limit\n    \n    #solving\n    status = solver.Solve()\n\n    print('MIP Objective value =', solver.Objective().Value())      \n    print('Problem solved in %f milliseconds' % solver.wall_time())\n\n    #update solution\n    assign = {}\n    for i in range(NMB_FAMILIES):\n        for j in range(NMB_DAYS):\n            if key[i, j] >= 0:\n               if x[key[i, j]].solution_value() > 0.99:\n                  assign[i] = j\n\n    update_solution(assign)\n\n#main\n\nrandom.seed(52) \n\ndata = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/family_data.csv', index_col='family_id')\n\nFAMILY_SIZE = data.n_people.values\nASSIGNMENT_COST_MATRIX = GetAssignmentCostMatrix(data) # Preference cost matrix\nACCOUNTING_COST_MATRIX = GetAccountingCostMatrix()     # Accounting cost matrix\nPREFERENCE_MATRIX = GetPreferenceMatrix(data)          # Preference Matrix\nPREFERENCES_FOR_FAMILY = GetPreferenceForFamiliesMatrix(data) \n\n# preprocessing to reduce the number of possible assignments (roughly 50% of assignments is eliminated)\npreprocessing()\n\nstartTime = time.time()\n\n# MIP to minimize assignment cost (don't care about accounting cost)\n# gives assignment cost of cca 43,700 and does not take much time, so 60 seconds is more than enough\n# accounting cost is huge\nMIP(60)\nprint(calculate_solution_cost())\n\n\n# local search to improve solution (we can improve a lot since accounting cost is huge)\n# search is very simple: only shift (reallocate) and swap moves are performed\n# shift move changes assignment of a single family\n# swap move exchanges assignments of two families\n# moves that increase the cost are accepted ocasionally (implemented in a very simple way), but not very often - just not to be stack quickly\n# in the early phase of the local search we try to not increase the assignment cost too much\n# (this is done by imposing the treshold on assignment cost change, which increases gradually as the search progresses)\n# implementation could be better, but in c++ it was quite ok\n# arrives to 72k-74k, depending on the seed and running time\n# other types of local search can improve the cost, but we try to keep it simple here, it is used just to build a reasonable starting point for \n# the MIP that will be called later\nLocalSearch(3600, 2000)\nprint(calculate_solution_cost())\n\n# MIP with linearization for accounting cost\n# occupancy of each day has to be in [current_occupacy - DELTA, current_occupacy + DELTA]\n# linearization of accounting cost is done by approximating it with linear regression \n# approximation is done for each pair of days (D, D + 1) by computing linear regression for 9 points (DELTA = 1)\n# approximation seems to be quite good when DELTA = 1\n# other possibility is to make better approximation with quadratic function and then use MIQP (tried this in C++ and improved a bit)\n# smaller running time limit should also work (maybe 5 minutes)\nDELTA = 1\nLINEARIZE = True\nMIP(5 * 60)\nprint(calculate_solution_cost())\n\n# try to improve obtained result by Local Search again\nLocalSearch(10 * 3600, 500)\n\nbest_assignment = {}\nfor i in range(NMB_FAMILIES):\n    best_assignment[i] = assignment_[i]\nbestCost = cost_\n\n         \n# MIP can be called again starting from the new solution\n# might improve a bit more\n# you can try more if you want\nfor i in range(5):\n    MIP(5 * 60)\n    print(calculate_solution_cost())\n    LocalSearch(3600, 100)\n    print(calculate_solution_cost())\n    if(cost_ < bestCost):\n        bestCost = cost_\n        print(\"bestCost: \", bestCost, \" time: \", time.time() - startTime)\n        for i in range(NMB_FAMILIES):\n           best_assignment[i] = assignment_[i]\n       \nupdate_solution(best_assignment)\n\nprint(\"Best Solution: \", bestCost)\nprint(\"LocalSearch...\")\n\nLocalSearch(3600, 1000)\n\nprint(\"Final Solution: \", cost_)\n\n#write solution\nwith open('submission.csv', mode='w') as csv_file:\n   fieldnames = ['family_id', 'assigned_day']\n   writer = csv.DictWriter(csv_file, fieldnames=fieldnames)\n   writer.writeheader()\n   for i in range(NMB_FAMILIES):\n      writer.writerow({'family_id': i, 'assigned_day': assignment_[i] + 1})","e3276db3":"This is a simple solution consisting of simple Local Search and Integer Programming. Initial solution is built by solving classical assignment problem (ignoring accounting cost). Simple local search is used to improve this solution a bit. Finally, Integer Program is solved again, with constraint of daily occupancy being very close to the one in current solution, which makes it possible to approximate the accounting cost with linear function. Never coded in python before, I hope the code is readable."}}