{"cell_type":{"8b186d0e":"code","ffef84dd":"code","2b48018c":"code","4115f439":"code","23ad616d":"code","a36380d5":"code","43ec6851":"code","6ca6893d":"code","c4cd3ba9":"code","f84ee7e4":"code","e8f46339":"code","4075be4d":"code","b59bf60e":"code","92e1df03":"code","80732c42":"code","988e352e":"code","2f4e6fdb":"code","fcd32aab":"code","d9077d9f":"code","3952457f":"code","534a7ee9":"code","1be66c1c":"code","6f7981fb":"code","20a506cc":"code","0906baa6":"code","673bdb28":"code","f77e0b18":"code","f20408f1":"markdown","11d25e89":"markdown","2556d830":"markdown","039c3b84":"markdown","61b5af52":"markdown","b8ffd8a2":"markdown"},"source":{"8b186d0e":"import pandas as pd\nimport numpy as np\nimport altair as alt\nfrom sklearn import metrics\n\nalt.data_transformers.disable_max_rows()","ffef84dd":"# Cargamos los datos del fichero .csv\n\ncredit_g = pd.read_csv('..\/input\/datos-credito-bancario-alemania-csv\/credit-g.csv')","2b48018c":"# Informaci\u00f3n general del contenido de los datos\n\ncredit_g.info()","4115f439":"credit_g.describe()","23ad616d":"credit_g.describe(include = 'object')","a36380d5":"# Cambiamos las columnas con pocos valores posibles a tipo categ\u00f3rico\n\ncolumnas_num = ['duration', 'credit_amount', 'age']\ncolumnas_cat = credit_g.select_dtypes(include = 'object').columns.to_list() + \\\n               ['installment_commitment', 'residence_since', 'existing_credits', 'num_dependents']\n\nfor field in columnas_cat:\n    credit_g[field] = credit_g[field].astype('category')","43ec6851":"credit_g.info()","6ca6893d":"# Podemos hacer unos boxplot para ver la distribuci\u00f3n de valores de las variables continuas para\n# los casos de buen cr\u00e9dito y mal cr\u00e9dito.\n# Como se puede ver en los gr\u00e1ficos, los prestamos de mayor duraci\u00f3n y de mayor cantidad tienen un\n# riesgo mayor (\u00a1en este caso!), y cuanto menor edad, m\u00e1s probabilidad de mal cr\u00e9dito\n\nalt.Chart(credit_g).mark_boxplot().encode(y = alt.X('class:N', title = None), \n                                         x = alt.Y(alt.repeat(\"row\"), type='quantitative'),\n                                         color = alt.Color('class:N', legend = None))\\\n                                  .repeat(row=columnas_num)\\\n                                  .resolve_scale(x = 'independent')","c4cd3ba9":"# Para las variables categ\u00f3ricas, una opci\u00f3n es mostrar el porcentaje de mal cr\u00e9dito para cada uno\n# de los valores posibles de cada una de esas variables\n# Como se ve en los gr\u00e1ficos, no hay ninguna variable individual con gran capacidad predictiva,\n# aunque algunas parecen dar buenas pistas\n\ndef get_data_chunk(field):\n    return credit_g.groupby(field)['class'].apply(lambda x: (x == 'bad').mean())\\\n                   .rename('percentage bad')\\\n                   .reset_index()\\\n                   .rename(columns = {field : 'value'})\\\n                   .assign(var = field)\n\nmal_credito_por_valor = pd.concat([get_data_chunk(field) for field in columnas_cat if field != 'class'])\n\nalt.Chart(mal_credito_por_valor, title = 'Porcentaje de casos con mal cr\u00e9dito').mark_bar()\\\n                        .encode( x = 'percentage bad:Q', y = alt.Y('value:N', title = None), row = 'var:N')\\\n                        .resolve_scale(y = 'independent')","f84ee7e4":"# La variable 'foreign_worker' parece tener bastante capadidad predictiva, pero si hacemos un gr\u00e1fico para sus distintos\n# valores, vemos lo que pasa: es cierto que los casos que no corresponden a 'foreing_worker' son, muy mayoritariamente, de\n# buen cr\u00e9digo, pero es un porcentaje muy peque\u00f1o del total de casos.\n\nalt.Chart(credit_g).mark_bar().encode(x = alt.X('class:N', title = None), \n                                         y = 'count(foreign_worker):Q', \n                                         color = alt.Color('class:N', legend = None),\n                                         column = 'foreign_worker:O')","e8f46339":"# Otras variables paracen m\u00e1s interesantes para predecir la calidad del cr\u00e9dito en muchos casos...\n\nalt.Chart(credit_g).mark_bar().encode(x = alt.X('class:N', title = None), \n                                         y = 'count(checking_status):Q', \n                                         color = alt.Color('class:N', legend = None),\n                                         column = 'checking_status:O')","4075be4d":"alt.Chart(credit_g).mark_bar().encode(x = alt.X('class:N', title = None), \n                                         y = 'count(credit_history):Q', \n                                         color = alt.Color('class:N', legend = None),\n                                         column = 'credit_history:O')","b59bf60e":"# A partir de las observaciones del apartado anterior, podemos crear diversos modelos predictivos sencillos\n# y calcular c\u00f3mo de bien funcionan. Por ejemplo, un modelo podr\u00eda consistir en hacer la media de los porcentajes\n# de mal cr\u00e9dito que corresponden a los valores de las variables para un caso","92e1df03":"def modelo1(caso):\n    porcentajes = [mal_credito_por_valor[(mal_credito_por_valor['var'] == field) & \n                                         (mal_credito_por_valor['value'] == caso[field])]['percentage bad'].tolist()[0] \\\n                   for field in columnas_cat if field != 'class']\n    return np.mean(porcentajes)","80732c42":"score1 = credit_g.apply(lambda x: modelo1(x), axis = 1)","988e352e":"# Podemos comprobar si este modelo tiene alg\u00fan poder predictivo calculando el AUC ROC\n\nfrom sklearn.metrics import roc_auc_score\n\nroc_auc_score((credit_g['class'] == 'bad'), score1)","2f4e6fdb":"# Un modelo m\u00e1s sencillo ser\u00eda, por ejemplo, utilizar una cascada de criterios espec\u00edficos\n# (que es un m\u00e9todo que, sorprendentemente, se utiliza en much\u00edsimas ocasiones)","fcd32aab":"def modelo2(caso):\n    if caso['duration'] >= 50 or caso['checking_status'] in(['\\'<0\\'', '\\'0<=X<200\\'']) or caso['credit_history'] in(['\\'all paid\\'', '\\'no credits\/all paid\\'']):\n        return 1\n    else:\n        return 0","d9077d9f":"score2 = credit_g.apply(lambda x: modelo2(x), axis = 1)","3952457f":"# Calculamos el poder predictivo de un modelo de este tipo y vemos que es m\u00e1s limitado\n\nroc_auc_score((credit_g['class'] == 'bad'), score2)","534a7ee9":"# En el caso del modelo2, como el resultado es binario, simplemente se puede hacer una tabla de contingencia\n\ntc_2 = pd.crosstab(score2, credit_g['class'])\ntc_2","1be66c1c":"# Podemos hacer una tabla con el coste de cada tipo de casos, para multiplicarla por la tabla de contigencia...\n\ncoste = pd.DataFrame([[5, 0], [0, 1]], columns=tc_2.columns, index=tc_2.index)\ncoste","6f7981fb":"# El coste de usar el modelo 2 ser\u00eda...\n\n(tc_2 * coste).sum().sum()","20a506cc":"# Para el modelo 1, como nos da una escala de certeza de la predicci\u00f3n, hay que seleccionar un umbral a partir del cual\n# considerar\u00edamos el caso como 'malo'\n\ndef tc_1(umbral):\n    return pd.crosstab(score1 > umbral, credit_g['class'])\n\ntc_1(0.30)","0906baa6":"def coste_1(umbral):\n    return (tc_1(umbral) * coste).sum().sum()\n\ncoste_1(0.4)","673bdb28":"# Podemos generar una gr\u00e1fica del coste que tendr\u00edan los errores de predicci\u00f3n, en funci\u00f3n del umbral elegido...\n\nx = np.linspace(0.2, 0.5, 100)\ndata = pd.DataFrame({\n  'umbral': x,\n  'coste': np.vectorize(coste_1)(x)\n})\n\nalt.Chart(data).mark_line().encode(x = 'umbral:Q', y = 'coste:Q')","f77e0b18":"# Se aprecia como el m\u00ednimo est\u00e1 alrededor de 0.29 y, naturalmente, como el modelo tiene mejor capacidad predictiva,\n# el coste por errores de predicci\u00f3n es menor que en el caso del otro modelo.\n\ncoste_1(0.29)","f20408f1":"# Caso pr\u00e1ctico de resumen (datos de cr\u00e9ditos bancarios)","11d25e89":"## 2. An\u00e1lisis de la capacidad predictiva de cada variable","2556d830":"## 1. Carga de datos, an\u00e1lisis exploratorio y preproceso","039c3b84":"En este nootbook podemos ver un analisis pre Machine Learning para entender un poco la idea que se busca mediante la aplicacion de aprendizaje automatico. ","61b5af52":"## 3. Modelos predictivos","b8ffd8a2":"## 4. Coste de los errores cometidos por los modelos"}}