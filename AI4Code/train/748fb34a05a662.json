{"cell_type":{"f9c8bcbb":"code","26e3d50e":"code","03f8042a":"code","93d27432":"code","07e374c8":"code","ad97b829":"code","0d691654":"code","9d358585":"code","51beb630":"code","608951a5":"code","9df3f22c":"code","8ced221a":"code","eecfba7d":"code","f113a7c9":"code","f29a7dcc":"markdown","89555829":"markdown","ee55043e":"markdown","58c51491":"markdown","cd5ace52":"markdown","fed0b4d5":"markdown","ebba60ae":"markdown","e4a72574":"markdown","558aa30e":"markdown","9f1a87e4":"markdown","2cfd15a7":"markdown","c12dc2a2":"markdown","e007262b":"markdown"},"source":{"f9c8bcbb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","26e3d50e":"# Sample Space\ncards = 52\n\n# Outcomes\naces = 4\n\n# Divide possible outcomes by the sample set\nace_probability = aces \/ cards\n\n# Print probability rounded to two decimal places\nprint(round(ace_probability, 2))\n\n# Ace Probability Percent Code\nace_probability_percent = ace_probability * 100\n\n# Print probability percent rounded to one decimal place\nprint(str(round(ace_probability_percent, 0)) + '%')","03f8042a":"# Create function that returns probability percent rounded to one decimal place\ndef event_probability(event_outcomes, sample_space):\n    probability = (event_outcomes \/ sample_space) * 100\n    return round(probability, 1)\n\n# Sample Space\ncards = 52\n\n# Determine the probability of drawing a heart\nhearts = 13\nheart_probability = event_probability(hearts, cards)\n\n# Determine the probability of drawing a face card\nface_cards = 12\nface_card_probability = event_probability(face_cards, cards)\n\n# Determine the probability of drawing the queen of hearts\nqueen_of_hearts = 1\nqueen_of_hearts_probability = event_probability(queen_of_hearts, cards)\n\n# Print each probability\nprint(\"Probability of Heart :- \",str(heart_probability) + '%')\nprint(\"Probability of Face Card :- \",str(face_card_probability) + '%')\nprint(\"Probability of Queen of Hearts :- \",str(queen_of_hearts_probability) + '%')","93d27432":"# Permutations Code\nimport math\nn = 4\nk = 2\n\n# Determine permutations and print result\nPermutations = math.factorial(n) \/ math.factorial(k)\nprint(Permutations)","07e374c8":"# Combinations Code\nn = 52\nk = 2\n\n# Determine Permutations\nPermutations = math.factorial(n) \/ math.factorial(n - k)\n\n# Determine Combinations and print result\nCombinations = Permutations \/ math.factorial(k)\nprint(Combinations)","ad97b829":"# Seed the random number generator\n# Initialize random numbers: random_numbers\nrandom_numbers = np.empty(100000)\n\n# Generate random numbers by looping over range(100000)\nfor i in range(100000):\n    random_numbers[i] = np.random.random()\n\n# Plot a histogram\n_ = plt.hist(random_numbers)\n\n# Show the plot\nplt.show()\n","0d691654":"# Import plotting modules\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\niris = pd.read_csv('..\/input\/iris.data.csv')\n\nprint(iris.head())\n\n#Create 3 DataFrame for each Species\nsetosa = iris[iris.iloc[:,4]=='Iris-setosa']\nversicolor = iris[iris.iloc[:,4]=='Iris-versicolor']\nvirginica = iris[iris.iloc[:,4]=='Iris-virginica']\n\nversicolor_petal_length = versicolor.iloc[:,0]\nsetosa_petal_length = setosa.iloc[:,0]\nvirginica_petal_length = virginica.iloc[:,0]\n\n# Set default Seaborn style\nsns.set()\n\n# Plot histogram of versicolor petal lengths\nplt.hist(versicolor_petal_length)\n\n# Show histogram\nplt.show()\n","9d358585":"def ecdf(data):\n    \"\"\"Compute ECDF for a one-dimensional array of measurements.\"\"\"\n    # Number of data points: n\n    n=len(data)\n\n\n    # x-data for the ECDF: x\n    x = np.sort(data)\n\n\n    # y-data for the ECDF: y\n    y = np.arange(1, len(x)+1) \/ n\n\n    return x, y\n","51beb630":"# Compute ECDF for versicolor data: x_vers, y_vers\nx_vers, y_vers = ecdf(versicolor_petal_length)\n\n# Generate plot\nplt.plot(x_vers,y_vers, marker='.',linestyle='none')\n\n# Label the axes\nplt.xlabel('Petal Length')\nplt.ylabel('ECDF')\n\n\n# Display the plot\nplt.show()\n","608951a5":"# Compute ECDFs\nx_set, y_set = ecdf(setosa_petal_length)\nx_vers, y_vers = ecdf(versicolor_petal_length)\nx_virg, y_virg = ecdf(virginica_petal_length)\n\n# Plot all ECDFs on the same plot\nplt.plot(x_set,y_set, marker='.',linestyle='none')\nplt.plot(x_vers,y_vers, marker='.',linestyle='none')\nplt.plot(x_virg,y_virg, marker='.',linestyle='none')\n\n\n\n# Annotate the plot\nplt.legend(('setosa', 'versicolor', 'virginica'), loc='lower right')\n_ = plt.xlabel('petal length (cm)')\n_ = plt.ylabel('ECDF')\n\n# Display the plot\nplt.show()\n","9df3f22c":"def perform_bernoulli_trials(n, p):\n    \"\"\"Perform n Bernoulli trials with success probability p and return number of successes.\"\"\"\n    \n    # Initialize number of successes: n_success\n    n_success = 0\n\n\n    # Perform trials\n    for i in range(n):\n        # Choose random number between zero and one: random_number\n        random_number = np.random.random() \n\n        # If less than p, it's a success so add one to n_success\n        if random_number<p:\n            n_success+=1\n\n    return n_success\n","8ced221a":"# Seed random number generator\nnp.random.seed(42)\n\n# Initialize the number of defaults: n_defaults\nn_defaults = np.empty(1000)\n\n# Compute the number of defaults\nfor i in range(1000):\n    n_defaults[i] = perform_bernoulli_trials(100,0.05)\n\n\n# Plot the histogram with default number of bins; label your axes\n_ = plt.hist(n_defaults, normed=True)\n_ = plt.xlabel('number of defaults out of 100 loans')\n_ = plt.ylabel('probability')\n\n# Show the plot\nplt.show()\n","eecfba7d":"# Compute ECDF: x, y\nx,y=ecdf(n_defaults)\n\n# Plot the ECDF with labeled axes\nplt.plot(x,y, marker='.',linestyle='none')\nplt.xlabel('ECDF')\nplt.ylabel('Probability')\n\n\n# Show the plot\nplt.show()\n\n# Compute the number of 100-loan simulations with 10 or more defaults: n_lose_money\nn_lose_money=np.sum(n_defaults>=10)\n\n# Compute and print probability of losing money\nprint('Probability of losing money =', n_lose_money \/ len(n_defaults))\n","f113a7c9":"# Draw 100000 samples from Normal distribution with stds of interest: samples_std1, samples_std3, samples_std10\nsamples_std1=np.random.normal(20, 1, size=100000)\nsamples_std3=np.random.normal(20, 3, size=100000)\nsamples_std10=np.random.normal(20, 10, size=100000)\n\n# Make histograms\nplt.hist(samples_std1,normed=True, bins=100, histtype='step')\nplt.hist(samples_std3,normed=True, bins=100, histtype='step')\nplt.hist(samples_std10,normed=True, bins=100, histtype='step')\n\n# Make a legend, set limits and show plot\n_ = plt.legend(('std = 1', 'std = 3', 'std = 10'))\nplt.ylim(-0.01, 0.42)\nplt.show()\n","f29a7dcc":"Now that you have seen examples where you calculated probabilities, it's easy to assume that you might build out your probability calculations to determine, for example, the probability of drawing a card that is a Heart, a face card (such as Jacks, Queens, or Kings), or a combination of both, such as a Queen of Hearts.","89555829":"**The Normal PDF**\n\nIn this exercise, you will explore the Normal PDF and also learn a way to plot a PDF of a known distribution using hacker statistics. Specifically, you will plot a Normal PDF for various values of the variance.\n\n**INSTRUCTIONS**\n\n\u2022 Draw 100,000 samples from a Normal distribution that has a mean of\u00a020\u00a0and a standard deviation of\u00a01. \n\nDo the same for Normal distributions with standard deviations of\u00a03\u00a0and\u00a010, each still with a mean of\u00a020. Assign the results to\u00a0samples_std1,\u00a0samples_std3\u00a0and\u00a0samples_std10, respectively.\n\n\u2022 Plot a histograms of each of the samples; for each, use 100 bins, also using the keyword arguments\u00a0normed=True\u00a0and\u00a0histtype='step'. The latter keyword argument makes the plot look much like the smooth theoretical PDF. You will need to make 3\u00a0plt.hist()\u00a0calls.\n\n\u2022 Hit 'Submit Answer' to make a legend, showing which standard deviations you used, and show your plot! There is no need to label the axes because we have not defined what is being described by the Normal distribution; we are just looking at shapes of PDFs.\n","ee55043e":"# Combinations\n\nTo determine the number of combinations, simply divide the number of permutations by the factorial of the size of the subset. Try finding the number of starting hand combinations that can be dealt in Texas Hold\u2019em.","58c51491":"**How many defaults might we expect?**\n\nLet's say a bank made 100 mortgage loans. It is possible that anywhere between 0 and 100 of the loans will be defaulted upon. You would like to know the probability of getting a given number of defaults, given that the probability of a default is\u00a0p = 0.05. To investigate this, you will do a simulation. You will perform 100 Bernoulli trials using the\u00a0perform_bernoulli_trials()\u00a0function you wrote in the previous exercise and record how many defaults we get. Here, a success is a default. (Remember that the word \"success\" just means that the Bernoulli trial evaluates to\u00a0True, i.e., did the loan recipient default?) You will do this for another 100 Bernoulli trials. And again and again until we have tried it 1000 times. Then, you will plot a histogram describing the probability of the number of defaults.\n\n**INSTRUCTIONS**\n\n\t\u2022 Seed the random number generator to 42.\n\t\u2022 Initialize\u00a0n_defaults, an empty array, using\u00a0np.empty(). It should contain 1000 entries, since we are doing 1000 simulations.\n\t\u2022 Write a\u00a0for\u00a0loop with\u00a01000\u00a0iterations to compute the number of defaults per 100 loans using the\u00a0perform_bernoulli_trials()\u00a0function. It accepts two arguments: the number of trials\u00a0n\u00a0- in this case 100 - and the probability of success\u00a0p\u00a0- in this case the probability of a default, which is\u00a00.05. On each iteration of the loop store the result in an entry of\u00a0n_defaults.\n\t\u2022 Plot a histogram of\u00a0n_defaults. Include the\u00a0normed=Truekeyword argument so that the height of the bars of the histogram indicate the probability.\n\t\u2022 Show your plot.\n","cd5ace52":"**The np.random module and Bernoulli trials**\n\nYou can think of a Bernoulli trial as a flip of a possibly biased coin. Specifically, each coin flip has a probability\u00a0pp\u00a0of landing heads (success) and probability\u00a01\u2212p1\u2212p\u00a0of landing tails (failure). In this exercise, you will write a function to perform\u00a0n\u00a0Bernoulli trials,\u00a0perform_bernoulli_trials(n, p), which returns the number of successes out of\u00a0n\u00a0Bernoulli trials, each of which has probability\u00a0p\u00a0of success. To perform each Bernoulli trial, use the\u00a0np.random.random()\u00a0function, which returns a random number between zero and one.\n\n**INSTRUCTIONS**\n\n\t\u2022 Define a function with signature\u00a0perform_bernoulli_trials(n, p).\n\t\t\u25cb Initialize to zero a variable\u00a0n_success\u00a0the counter of\u00a0Trues, which are Bernoulli trial successes.\n\t\t\u25cb Write a\u00a0for\u00a0loop where you perform a Bernoulli trial in each iteration and increment the number of success if the result is\u00a0True. Perform\u00a0n\u00a0iterations by looping over\u00a0range(n).\n\t\t\t\u00a7 To perform a Bernoulli trial, choose a random number between zero and one using\u00a0np.random.random(). If the number you chose is less than\u00a0p, increment\u00a0n_success(use the\u00a0+= 1\u00a0operator to achieve this).\n\t\t\u25cb The function returns the number of successes\u00a0n_success.\n","fed0b4d5":"**Comparison of ECDFs**\n\nECDFs also allow you to compare two or more distributions (though plots get cluttered if you have too many). Here, you will plot ECDFs for the petal lengths of all three iris species. You already wrote a function to generate ECDFs so you can put it to good use!\nTo overlay all three ECDFs on the same plot, you can use\u00a0plt.plot()\u00a0three times, once for each ECDF. Remember to include\u00a0marker='.'\u00a0and\u00a0linestyle='none'\u00a0as arguments inside\u00a0plt.plot().\n\n**INSTRUCTIONS**\n\t\n\t\u2022 Compute ECDFs for each of the three species using your\u00a0ecdf()\u00a0function. The variables\u00a0setosa_petal_length,\u00a0versicolor_petal_length, and\u00a0virginica_petal_length\u00a0are all in your namespace. Unpack the ECDFs into\u00a0x_set, y_set,\u00a0x_vers, y_vers\u00a0and\u00a0x_virg, y_virg, respectively.\n\t\u2022 Plot all three ECDFs on the same plot as dots. To do this, you will need three\u00a0plt.plot()commands. Assign the result of each to\u00a0_.\n\t\u2022 A legend and axis labels have been added for you, so hit 'Submit Answer' to see all the ECDFs!\n","ebba60ae":"# Plotting a Histogram of Iris Data\n\nFor the exercises in this section, you will use a classic data set collected by botanist Edward Anderson and made famous by Ronald Fisher, one of the most prolific statisticians in history. Anderson carefully measured the anatomical properties of samples of three different species of iris,\u00a0Iris setosa,\u00a0Iris versicolor, and\u00a0Iris virginica. The full data set is\u00a0available as part of scikit-learn. Here, you will work with his measurements of petal length.\n\nPlot a histogram of the petal lengths of his 50 samples of\u00a0Iris versicolor\u00a0using matplotlib\/seaborn's default settings. Recall that to specify the default seaborn style, you can use\u00a0sns.set(), where\u00a0sns\u00a0is the alias that\u00a0seaborn\u00a0is imported as.\n\nThe subset of the data set containing the\u00a0Iris versicolor\u00a0petal lengths in units of centimeters (cm) is stored in the NumPy array\u00a0versicolor_petal_length.\n\nIn the video, Justin plotted the histograms by using the\u00a0pandas\u00a0library and indexing the DataFrame to extract the desired column. Here, however, you only need to use the provided NumPy array. Also, Justin assigned his plotting statements (except for\u00a0plt.show()) to the dummy variable\u00a0_. This is to prevent unnecessary output from being displayed. It is not required for your solutions to these exercises, however it is good practice to use it. Alternatively, if you are working in an interactive environment such as a Jupyter notebook, you could use a\u00a0;\u00a0after your plotting statements to achieve the same effect. Justin prefers using\u00a0_. Therefore, you will see it used in the solution code.\n\n**INSTRUCTIONS**\n\n\t\u2022 Import\u00a0matplotlib.pyplot\u00a0and\u00a0seaborn\u00a0as their usual aliases (plt\u00a0and\u00a0sns).\n\t\u2022 Use\u00a0seaborn\u00a0to set the plotting defaults.\n\t\u2022 Plot a histogram of the\u00a0Iris versicolor\u00a0petal lengths using\u00a0plt.hist()\u00a0and the provided NumPy array\u00a0versicolor_petal_length.\n\t\u2022 Show the histogram using\u00a0plt.show().\n","e4a72574":"# Permutations\n\nConsider another example with Aces. There are four Aces in a deck of cards, and these are all the different combinations of pocket Aces;\n\na). Ace Hearts \/ Ace Diamonds\n\nb). Ace Hearts \/ Ace Clubs\n\nc). Ace Hearts \/ Ace Spades\n\nd). Ace Diamonds \/ Ace Clubs\n\ne). Ace Diamonds \/ Ace Spades\n\nf). Ace Clubs \/ Ace Spades\n\nThere are six combinations of pocket Aces. To find the number of combinations, you first must find the number of permutations:","558aa30e":"# Probability\n\nThere are 52 cards In a standard deck of cards and of those 52 cards, 4 are Aces. If you follow the example of the coin flipping from above to know the probability of drawing an Ace, you'll divide the number of possible event outcomes (4), by the sample space (52)","9f1a87e4":"# Generating random numbers using the np.random module\n\nWe will be hammering the\u00a0np.random\u00a0module for the rest of this course and its sequel. Actually, you will probably call functions from this module more than any other while wearing your hacker statistician hat. Let's start by taking its simplest function,\u00a0np.random.random()\u00a0for a test spin. The function returns a random number between zero and one. Call\u00a0np.random.random()\u00a0a few times in the IPython shell. You should see numbers jumping around between zero and one.\n\nIn this exercise, we'll generate lots of random numbers between zero and one, and then plot a histogram of the results. If the numbers are truly random, all bars in the histogram should be of (close to) equal height.\n\nYou may have noticed that, in the video, Justin generated 4 random numbers by passing the keyword argument\u00a0size=4\u00a0to\u00a0np.random.random(). Such an approach is more efficient than a\u00a0for\u00a0loop: in this exercise, however, you will write a\u00a0for\u00a0loop to experience hacker statistics as the practice of repeating an experiment over and over again.\n\n**INSTRUCTIONS**\n\n\t\u2022 Seed the random number generator using the seed\u00a042.\n\t\u2022 Initialize an empty array,\u00a0random_numbers, of 100,000 entries to store the random numbers. Make sure you use\u00a0np.empty(100000)\u00a0to do this.\n\t\u2022 Write a\u00a0for\u00a0loop to draw 100,000 random numbers using\u00a0np.random.random(), storing them in the\u00a0random_numbers array. To do so, loop over\u00a0range(100000).\n\t\u2022 Plot a histogram of\u00a0random_numbers. It is not necessary to label the axes in this case because we are just checking the random number generator. Hit 'Submit Answer' to show your plot.\n","2cfd15a7":"**Plotting the ECDF**\n\nYou will now use your\u00a0ecdf()\u00a0function to compute the ECDF for the petal lengths of Anderson's\u00a0Iris versicolor\u00a0flowers. You will then plot the ECDF. Recall that your\u00a0ecdf()function returns two arrays so you will need to unpack them. An example of such unpacking is\u00a0x, y = foo(data), for some function\u00a0foo().\n\n**INSTRUCTIONS**\n\n\n\t\u2022 Use\u00a0ecdf()\u00a0to compute the ECDF of\u00a0versicolor_petal_length. Unpack the output intox_vers\u00a0and\u00a0y_vers.\n\t\u2022 Plot the ECDF as dots. Remember to include\u00a0marker = '.'\u00a0and\u00a0linestyle = 'none'\u00a0in addition to\u00a0x_vers\u00a0and\u00a0y_vers\u00a0as arguments inside\u00a0plt.plot().\n\t\u2022 Label the axes. You can label the y-axis\u00a0'ECDF'.\n\t\u2022 Show your plot.\n","c12dc2a2":"**Computing the ECDF**\n\nIn this exercise, you will write a function that takes as input a 1D array of data and then returns the\u00a0x\u00a0and\u00a0y\u00a0values of the ECDF. You will use this function over and over again throughout this course and its sequel. ECDFs are among the most important plots in statistical analysis. You can write your own function,\u00a0foo(x,y)\u00a0according to the following skeleton:\n\ndef foo(a,b):\n    \"\"\"State what function does here\"\"\"\n    # Computation performed here\n    return x, y\n\nThe function\u00a0foo()\u00a0above takes two arguments\u00a0a\u00a0and\u00a0b\u00a0and returns two values\u00a0x\u00a0and\u00a0y. The function header\u00a0def foo(a,b):\u00a0contains the function signature\u00a0foo(a,b), which consists of the function name, along with its parameters. For more on writing your own functions, see DataCamp's course\u00a0Python Data Science Toolbox (Part 1) here!\n\n**INSTRUCTIONS**\n\t\n\t\u2022 Define a function with the signature\u00a0ecdf(data). Within the function definition,\n\t\t\u25cb Compute the number of data points,\u00a0n, using the\u00a0len()\u00a0function.\n\t\t\u25cb The\u00a0xx-values are the sorted data. Use the\u00a0np.sort()\u00a0function to perform the sorting.\n\t\t\u25cb The\u00a0yy\u00a0data of the ECDF go from\u00a01\/n\u00a0to\u00a01\u00a0in equally spaced increments. You can construct this using\u00a0np.arange(). Remember, however, that the end value in\u00a0np.arange()\u00a0is not inclusive. Therefore,\u00a0np.arange()\u00a0will need to go from\u00a01\u00a0to\u00a0n+1. Be sure to divide this by\u00a0n.\n\t\t\u25cb The function returns the values\u00a0x\u00a0and\u00a0y.\n","e007262b":"**Will the bank fail?**\n\nPlot the number of defaults you got from the previous exercise, in your namespace as\u00a0n_defaults, as a CDF. The\u00a0ecdf() function you wrote in the first chapter is available.\n\nIf interest rates are such that the bank will lose money if 10 or more of its loans are defaulted upon, what is the probability that the bank will lose money?\n\n**INSTRUCTIONS**\n\n\t\u2022 Compute the\u00a0x\u00a0and\u00a0y\u00a0values for the ECDF of\u00a0n_defaults.\n\t\u2022 Plot the ECDF, making sure to label the axes. Remember to include\u00a0marker = '.'\u00a0and\u00a0linestyle = 'none'\u00a0in addition to\u00a0x\u00a0and\u00a0y\u00a0in your call\u00a0plt.plot().\n\t\u2022 Show the plot.\n\t\u2022 Compute the total number of entries in your\u00a0n_defaults\u00a0array that were greater than or equal to 10. To do so, compute a boolean array that tells you whether a given entry of\u00a0n_defaults\u00a0is\u00a0>= 10. Then sum all the entries in this array using\u00a0np.sum(). For example,\u00a0np.sum(n_defaults <= 5)would compute the number of defaults with 5 or\u00a0fewer\u00a0defaults.\n\t\u2022 The probability that the bank loses money is the fraction of\u00a0n_defaults\u00a0that are greater than or equal to 10. Print this result by hitting 'Submit Answer'!\n"}}