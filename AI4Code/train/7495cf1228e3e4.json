{"cell_type":{"d72de778":"code","17116f1a":"code","ad7e8ce3":"code","e090811b":"code","e384113a":"code","103996b3":"code","66b8e0b4":"code","cf22f3c5":"code","ba1d9cc1":"code","ebfab665":"code","ee658362":"code","b7bd5d66":"code","1acf069c":"code","e3cc6891":"code","2d4d876d":"markdown"},"source":{"d72de778":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sklearn.model_selection import train_test_split # function for splitting data to train and test sets\n\nimport nltk\nfrom nltk.corpus import stopwords\nfrom nltk.classify import SklearnClassifier\n\nfrom wordcloud import WordCloud,STOPWORDS\nimport matplotlib.pyplot as plt","17116f1a":"data = pd.read_csv('..\/input\/twitter-sentiment\/Sentiment.csv')\n# Keeping only the neccessary columns\ndata = data[['text','sentiment']]","ad7e8ce3":"data.head()","e090811b":"data.shape","e384113a":"# Splitting the dataset into train and test set\ntrain, test = train_test_split(data,test_size = 0.2, shuffle=True, stratify=data.sentiment,random_state=42)","103996b3":"train_pos = train[ train['sentiment'] == 'Positive']\ntrain_pos = train_pos['text']\ntrain_neg = train[ train['sentiment'] == 'Negative']\ntrain_neg = train_neg['text']\ntrain_neutral = train[ train['sentiment'] == 'Neutral']\ntrain_neutral = train_neutral['text']","66b8e0b4":"def wordcloud_draw(data, color = 'black'):\n    words = ' '.join(data)\n    cleaned_word = \" \".join([word for word in words.split()\n                            if 'http' not in word\n                                and not word.startswith('@')\n                                and not word.startswith('#')\n                                and word != 'RT'\n                            ])\n    wordcloud = WordCloud(stopwords=STOPWORDS,\n                      background_color=color,\n                      width=2500,\n                      height=2000\n                     ).generate(cleaned_word)\n    plt.figure(1,figsize=(13, 13))\n    plt.imshow(wordcloud)\n    plt.axis('off')\n    plt.show()\n    ","cf22f3c5":"print(\"Neaural words\")\nwordcloud_draw(train_neutral,'grey')","ba1d9cc1":"print(\"Positive words\")\nwordcloud_draw(train_pos,'white')","ebfab665":"print(\"Negative words\")\nwordcloud_draw(train_neg)","ee658362":"tweets = []\nstopwords_set = set(stopwords.words(\"english\"))\n\nfor index, row in train.iterrows():\n    words_filtered = [e.lower() for e in row.text.split() if len(e) >= 3]\n    words_cleaned = [word for word in words_filtered\n        if 'http' not in word\n        and not word.startswith('@')\n        and not word.startswith('#')\n        and word != 'RT']\n    words_without_stopwords = [word for word in words_cleaned if not word in stopwords_set]\n    tweets.append((words_without_stopwords, row.sentiment))\n\ntest_pos = test[ test['sentiment'] == 'Positive']\ntest_pos = test_pos['text']\ntest_neg = test[ test['sentiment'] == 'Negative']\ntest_neg = test_neg['text']\ntest_neutral = test[ test['sentiment'] == 'Neutral']\ntest_neutral = test_neutral['text']","b7bd5d66":"# Extracting word features\ndef get_words_in_tweets(tweets):\n    all = []\n    for (words, sentiment) in tweets:\n        all.extend(words)\n    return all\n\ndef get_word_features(wordlist):\n    wordlist = nltk.FreqDist(wordlist)\n    features = wordlist.keys()\n    return features\nw_features = get_word_features(get_words_in_tweets(tweets))\n\ndef extract_features(document):\n    document_words = set(document)\n    features = {}\n    for word in w_features:\n        features['contains(%s)' % word] = (word in document_words)\n    return features","1acf069c":"# Training the Naive Bayes classifier\ntraining_set = nltk.classify.apply_features(extract_features,tweets)\nclassifier = nltk.NaiveBayesClassifier.train(training_set)","e3cc6891":"neg_cnt = 0\npos_cnt = 0\nneutral_cnt=0\nfor obj in test_neg: \n    res =  classifier.classify(extract_features(obj.split()))\n    if(res == 'Negative'): \n        neg_cnt = neg_cnt + 1\nfor obj in test_pos: \n    res =  classifier.classify(extract_features(obj.split()))\n    if(res == 'Positive'): \n        pos_cnt = pos_cnt + 1\nfor obj in test_neutral: \n    res =  classifier.classify(extract_features(obj.split()))\n    if(res == 'Neutral'): \n        neutral_cnt = neutral_cnt + 1        \nprint('[Negative]: %s\/%s '  % (len(test_neg),neg_cnt))        \nprint('[Positive]: %s\/%s '  % (len(test_pos),pos_cnt)) \nprint('[Neutral]: %s\/%s '  % (len(test_neutral),neutral_cnt))   ","2d4d876d":"Twitter Sentiment Analysis is the process of computationally identifying and categorizing tweets expressed in a piece of text, especially in order to determine whether the writer\u2019s attitude towards a particular topic, product, etc. is positive, negative, or neutral."}}