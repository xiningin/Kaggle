{"cell_type":{"3211d9b1":"code","84826b00":"code","67ca1d23":"code","599ade59":"code","5522f9e4":"code","1eb12105":"code","065e4c92":"code","a94c6a59":"code","16a15a49":"code","2aa84802":"code","c8e178fc":"code","2004bc46":"code","a9a2e7a7":"code","61bb200a":"code","03d2204f":"code","b67094dc":"code","913ce43c":"code","a722af6e":"code","ea034784":"code","11aa54f9":"code","c3bf4dbb":"code","76063b0d":"code","84b553b5":"code","00422462":"code","fdf61a45":"code","821ec91d":"markdown","5966d904":"markdown","4a70c7b4":"markdown","de959ab1":"markdown","43acb90c":"markdown","be58eb15":"markdown","45833dcb":"markdown"},"source":{"3211d9b1":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom tqdm.notebook import tqdm","84826b00":"from datetime import datetime\n\ndef log_now():\n    print(datetime.now())","67ca1d23":"TEST = False\nTEST = True # uncomment to test that all the notebook is ok before commit","599ade59":"import tensorflow as tf\n\nimport keras.backend as K\n\nfrom keras.layers import Input, Dense, Bidirectional, Conv1D, SpatialDropout1D, Embedding, Concatenate, GRU, Cropping1D, LSTM, AveragePooling1D, ZeroPadding1D\nfrom tensorflow.keras.activations import swish\nfrom keras.models import Model\nfrom keras.optimizers import Adam\nfrom keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau\nfrom sklearn.model_selection import train_test_split\n\nimport matplotlib.pyplot as plt\n\n# https:\/\/www.kaggle.com\/c\/stanford-covid-vaccine\/discussion\/183211\ndef MCRMSE(y_true, y_pred):\n    colwise_mse = tf.reduce_mean(tf.square(y_true - y_pred), axis=1)\n    return tf.reduce_mean(tf.sqrt(colwise_mse), axis=1)\n\nclass BiGRUModel():\n    \n    def __init__(self, testmode):\n        self.type = 'BiGru'\n        self.n_features = 3\n        \n        self.lr = 0.0015\n        self.epochs = 5 if testmode else 100\n        self.batch_size = 32\n        \n        self.train_verbose = 1 if testmode else 0\n\n        self.checkpoint = ModelCheckpoint(self.type + \".hdf5\", \n                                          monitor='val_loss',\n                                          verbose=self.train_verbose,\n                                          save_best_only=True,\n                                          mode='auto',\n                                          period=1)\n        self.es = EarlyStopping(monitor='val_loss', patience = 10, mode = 'min', restore_best_weights=True)\n        self.reduce_lr = ReduceLROnPlateau(patience=5)\n\n    def create_model(self):\n        # based on https:\/\/www.kaggle.com\/tuckerarrants\/openvaccine-gru-lstm\n        seq_len = 107\n        pred_len = 68\n        seq_dim = 14\n        ltype_dim = 14\n        structure_dim = 14\n        embed_dim = 200\n        dropout = .2\n        sp_dropout = dropout\n        conv_dim = 512\n        conv_ksize = 3\n        hidden_dim = 256\n        crop = (0,seq_len-pred_len)\n        out_dim = 5\n        \n        iseq = Input(shape = (seq_len))\n        iltype = Input(shape = (seq_len))\n        istructure = Input(shape = (seq_len))\n        ibpp = Input(shape= (seq_len,seq_len))\n        \n        eseq = Embedding(input_dim=seq_dim,output_dim=embed_dim)(iseq)\n        eltype = Embedding(input_dim=ltype_dim,output_dim=embed_dim)(iltype)\n        estructure = Embedding(input_dim=structure_dim,output_dim=embed_dim)(istructure)\n        \n        x = Concatenate(axis=2)([eseq,eltype,estructure,ibpp])\n        x = ZeroPadding1D(padding=(0,29))(x)\n\n        x = SpatialDropout1D(sp_dropout)(x)\n        x = Conv1D(conv_dim, conv_ksize, padding='same', activation=swish)(x)\n        \n        x = Bidirectional(GRU(hidden_dim, dropout=dropout, return_sequences=True))(x)        \n        x = Bidirectional(GRU(hidden_dim, dropout=dropout, return_sequences=True))(x)        \n        x = Bidirectional(LSTM(hidden_dim, dropout=dropout, return_sequences=True))(x)        \n        \n        x = AveragePooling1D(pool_size=2)(x)\n\n        #x = Cropping1D(cropping=crop)(x)\n        \n        out = Dense(out_dim, activation='linear')(x)\n\n        self.model = Model(inputs = [iseq, iltype, istructure, ibpp], outputs = out)\n    \n    def compile_model(self):\n        opt = Adam(lr = self.lr)\n        self.model.compile(loss = MCRMSE, optimizer = opt)\n    \n    def create_and_compile(self):\n        if self.train_verbose == 1:\n            print('Create Model...')\n        self.create_model()\n        \n        if self.train_verbose == 1:\n            print('Compile Model...')\n        self.compile_model()\n        \n        if self.train_verbose == 1:\n            self.print()\n\n\n    def print(self):\n        print(self.model.summary())\n        \n    def fit(self, X_seq, X_ltype, X_structure, X_bpp, Y):\n        X_seq_train, X_seq_valid, X_ltype_train, X_ltype_valid, X_structure_train, X_structure_valid, X_bpp_train, X_bpp_valid, Y_train, Y_valid = train_test_split(X_seq, X_ltype, X_structure, X_bpp, Y)\n\n        self.history = self.model.fit([X_seq_train, X_ltype_train, X_structure_train, X_bpp_train],\n                                      Y_train,\n                                      validation_data = ([X_seq_valid, X_ltype_valid, X_structure_valid, X_bpp_valid], Y_valid),\n                                      epochs = self.epochs,\n                                      batch_size = self.batch_size,\n                                      callbacks = [self.checkpoint, self.es, self.reduce_lr],\n                                      verbose = self.train_verbose)\n\n    def predict(self, X_seq, X_ltype, X_structure, X_bpp):\n        return self.model.predict([X_seq, X_ltype, X_structure, X_bpp])\n    \n    def load_weights(self):\n        self.model.load_weights(self.type + \".hdf5\")\n    \n    def plot(self):\n        plt.figure(figsize=(20,5))\n\n        # summarize history for loss\n        plt.plot(self.history.history['loss'])\n        plt.plot(self.history.history['val_loss'])\n        plt.title('model loss')\n        plt.ylabel('loss')\n        plt.xlabel('epoch')\n        plt.legend(['train', 'test'], loc='upper left')\n\n        plt.show()","5522f9e4":"train = pd.read_json('\/kaggle\/input\/stanford-covid-vaccine\/train.json', lines=True)\ntest = pd.read_json('\/kaggle\/input\/stanford-covid-vaccine\/test.json', lines=True)","1eb12105":"if TEST:\n    train = train.head(32*40)\n\ntlen = train.shape[0]","065e4c92":"def get_bpp(id):\n    return np.load('..\/input\/stanford-covid-vaccine\/bpps\/' + id + '.npy')","a94c6a59":"from sklearn import preprocessing\n\nE = preprocessing.LabelEncoder()\nE.fit([b'S', b'M', b'I', b'B', b'H', b'E', b'X', b'.', b'(', b')',b'A', b'C', b'G', b'U'])\n\ndef encode(code):\n    return E.transform(np.array(code, 'c'))\n\ndef generate_X_data(train):\n    x_seq = np.empty((0,107))\n    x_ltype = np.empty((0,107))\n    x_structure = np.empty((0,107))\n    x_bpp = np.empty((0,107,107))\n    for index, row in tqdm(train.iterrows(), total=train.shape[0]):\n        x_seq = np.append(x_seq, [encode(row.sequence)], axis=0)\n        x_ltype = np.append(x_ltype, [encode(row.predicted_loop_type)], axis=0)\n        x_structure = np.append(x_structure, [encode(row.structure)], axis=0)\n        x_bpp = np.append(x_bpp, [get_bpp(row.id)], axis=0)\n                \n    return x_seq, x_ltype, x_structure, x_bpp","16a15a49":"def generate_Y_data(train):\n    Y = np.empty((0,68,5))\n    for index, row in tqdm(train.iterrows(), total=train.shape[0]):\n        Y = np.append(Y, [np.array([row.reactivity,row.deg_Mg_pH10,row.deg_pH10,row.deg_Mg_50C,row.deg_50C]).T], axis=0)\n    return Y","2aa84802":"log_now()","c8e178fc":"X_seq, X_ltype, X_structure, X_bpp = generate_X_data(train)\n\nassert X_seq.shape == (tlen,107)\nassert X_ltype.shape == (tlen,107)\nassert X_structure.shape == (tlen,107)\nassert X_bpp.shape == (tlen,107,107)","2004bc46":"Y = generate_Y_data(train)\nassert Y.shape == (tlen,68,5)\n","a9a2e7a7":"assert X_seq.shape[0] == X_ltype.shape[0] == X_structure.shape[0] == X_bpp.shape[0] == Y.shape[0]","61bb200a":"log_now()","03d2204f":"m = BiGRUModel(TEST)\nm.create_and_compile()","b67094dc":"m.fit(X_seq, X_ltype, X_structure, X_bpp, Y)\nm.plot()","913ce43c":"log_now()","a722af6e":"m.load_weights()","ea034784":"Y_pred = m.predict(X_seq, X_ltype, X_structure, X_bpp)\nprint(\"MCRMSE  = \", np.mean(MCRMSE(Y,Y_pred)))","11aa54f9":"log_now()","c3bf4dbb":"submission = pd.DataFrame({\n                \"id_seqpos\" :  [],\n                \"reactivity\":  [],\n                \"deg_Mg_pH10\": [],\n                \"deg_pH10\":    [],\n                \"deg_Mg_50C\":  [],\n                \"deg_50C\":     []\n            })","76063b0d":"for index, row in tqdm(test.iterrows(), total=test.shape[0]):\n    X_seq = np.array([encode(row.sequence)])[:,:107]\n    X_ltype = np.array([encode(row.predicted_loop_type)])[:,:107]\n    X_structure = np.array([encode(row.structure)])[:,:107]\n    X_bpp = np.array([get_bpp(row.id)])[:,:107,:107]\n\n    predicted = m.predict(X_seq, X_ltype, X_structure, X_bpp)\n\n    df = pd.DataFrame(data=predicted[0], columns=[\"reactivity\", \"deg_Mg_pH10\", \"deg_pH10\", \"deg_Mg_50C\", \"deg_50C\"])\n    dfz = pd.DataFrame(data=np.zeros((row.seq_length-df.shape[0],5)), columns=[\"reactivity\", \"deg_Mg_pH10\", \"deg_pH10\", \"deg_Mg_50C\", \"deg_50C\"])\n    df = df.append(dfz) # complete with zeros\n    df = df.reset_index(drop=True)\n    df[\"id_seqpos\"] = df.apply(lambda r : f\"{row.id}_{r.name}\", axis = 1) \n\n    submission = submission.append(df)\n","84b553b5":"assert submission.shape[0] == 457953","00422462":"submission.to_csv(\"submission.csv\", index = False)","fdf61a45":"log_now()","821ec91d":"# PREDICT","5966d904":"# FEATURES","4a70c7b4":"# DATA","de959ab1":"# FIT","43acb90c":"# MODEL","be58eb15":"# EVALUATE","45833dcb":"### Checking file before submission"}}