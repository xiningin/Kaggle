{"cell_type":{"1a6ecf14":"code","9f6c478f":"code","e382476f":"code","830d4b63":"code","309b8993":"code","6e4342bc":"code","7b9e6e2e":"code","9812a771":"code","bd174909":"code","e0d624b2":"code","adc1b75c":"code","30e8d48c":"code","86068ba8":"code","7712daea":"code","6446c51d":"code","0b64d66e":"code","681d27bf":"markdown"},"source":{"1a6ecf14":"!pip uninstall kaggle\n!pip install --upgrade pip\n!pip install kaggle==1.5.6\n\n!mkdir -p ~\/.kaggle\n!cp kaggle.json ~\/.kaggle\n!ls -lha kaggle.json\n!chmod 600 ~\/.kaggle\/kaggle.json","9f6c478f":"! kaggle competitions download -c 18011854kbopredicton\n\n!unzip 18011854kbopredicton.zip","e382476f":"import pandas as pd\nimport numpy as np\nimport torch\nimport torchvision.datasets as data\nimport torchvision.transforms as transforms\nimport random\nfrom sklearn import preprocessing","830d4b63":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\n\nrandom.seed(777)\ntorch.manual_seed(777)\nif device=='cuda':\n  torch.cuda.manual_seed_all(777)","309b8993":"learning_rate=0.0001\ntraining_epochs=1800\nbatch_size=100\nScaler = preprocessing.StandardScaler()","6e4342bc":"train_data=pd.read_csv('kbo_train.csv',header=None,skiprows=1,usecols=range(0,9))\ntest_data=pd.read_csv('kbo_test.csv',header=None,skiprows=1,usecols=range(0,8))","7b9e6e2e":"x_train_data=train_data.loc[:,0:7]\ny_train_data=train_data.loc[:,[8]]\n\nx_train_data=np.array(x_train_data)\ny_train_data=np.array(y_train_data)\nx_train_data=Scaler.fit_transform(x_train_data)\n\nx_train_data=torch.FloatTensor(x_train_data)\ny_train_data=torch.FloatTensor(y_train_data)","9812a771":"train_dataset=torch.utils.data.TensorDataset(x_train_data,y_train_data)\ndata_loader=torch.utils.data.DataLoader(dataset=train_dataset,batch_size=batch_size,shuffle=True,drop_last=True)","bd174909":"linear1 = torch.nn.Linear(8, 512,bias=True)\nlinear2 = torch.nn.Linear(512, 512,bias=True)\nlinear3 = torch.nn.Linear(512, 1,bias=True)\nrelu = torch.nn.ReLU()\n\ntorch.nn.init.xavier_uniform_(linear1.weight)\ntorch.nn.init.xavier_uniform_(linear2.weight)\ntorch.nn.init.xavier_uniform_(linear3.weight)\n\nmodel = torch.nn.Sequential(linear1,relu,\n                            linear2,relu,\n                            linear3).to(device)","e0d624b2":"loss=torch.nn.MSELoss().to(device)\noptimizer=torch.optim.RMSprop(model.parameters(),lr=learning_rate)","adc1b75c":"total_batch=len(data_loader)\nfor epoch in range(training_epochs):\n  avg_cost=0\n\n  for x, y in data_loader:\n    x=x.to(device)\n    y=y.to(device)\n\n    optimizer.zero_grad()\n    hypo=model(x)\n    cost=loss(hypo,y)\n    cost.backward()\n    optimizer.step()\n    avg_cost+=cost\/total_batch\n  if(epoch%50==0):\n    print('epoch:','%04d'%(epoch),'cost=','{:.9f}'.format(avg_cost))\nprint('Learning finished')","30e8d48c":"with torch.no_grad():\n  x_test_data=test_data.loc[:,:]\n  x_test_data=np.array(x_test_data)\n  x_test_data=Scaler.transform(x_test_data)\n  x_test_data=torch.from_numpy(x_test_data).float().to(device)\n\n  prediction=model(x_test_data)","86068ba8":"correct=prediction.cpu().numpy().reshape(-1,1)","7712daea":"submit=pd.read_csv('submit_sample.csv')","6446c51d":"for i in range(len(correct)):\n  submit['Expected'][i]=correct[i].item()\nsubmit","0b64d66e":"submit.to_csv('defense_baseline.csv',index=False,header=True)\nfrom google.colab import files\n\nfiles.download('defense_baseline.csv')","681d27bf":"# \ubaa8\ub378 \uc124\uacc4 \ubc29\uc2dd\n* DNN \uc0ac\uc6a9\n* learning_rate=0.0001, training_epochs=1800, batch_size=100 \uc640 \uac19\uc774 \ud559\uc2b5 \ud30c\ub77c\ubbf8\ud130 \uc124\uc815\n* Data\uc804\ucc98\ub9ac\n* NN strucutre : 8->512->1 \ub85c \uc124\uacc4\n* optimizer : RMSproop\uc0ac\uc6a9"}}