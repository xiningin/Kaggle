{"cell_type":{"311181cb":"code","ff01345f":"code","8a3565a2":"code","e7cab083":"code","f6b8ab52":"code","503938c0":"code","ae29a738":"code","bc6aed1b":"code","3f8472e6":"code","14ccd169":"code","10cea4cc":"code","05bbaa1f":"code","94df4eae":"code","a8e25f70":"code","6f20d524":"code","484bca60":"code","39f98cf6":"code","d0cc7420":"code","8820a378":"code","f9fc11c3":"code","349acab8":"code","22545bc3":"code","c211cee4":"code","4108906c":"markdown","920b12be":"markdown","5fae5965":"markdown","05ef5769":"markdown","c3d40130":"markdown","cd7ff245":"markdown","ca60924e":"markdown","fbdc4b30":"markdown"},"source":{"311181cb":"%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm_notebook\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torchvision\nimport torchvision.transforms as transforms\nimport torch.nn as nn\nimport torch.nn.functional as F","ff01345f":"torch.__version__","8a3565a2":"from torch.autograd import Variable\nuse_gpu = torch.cuda.is_available()\nuse_gpu","e7cab083":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nprint(device)","f6b8ab52":"!ls ..\/input\/cifar10-python\/","503938c0":"!tar -zxvf ..\/input\/cifar10-python\/cifar-10-python.tar.gz","ae29a738":"!ls .","bc6aed1b":"transform = transforms.Compose(\n    [transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])\n\ntrainset = torchvision.datasets.CIFAR10(root='.', train=True,\n                                        download=False, transform=transform)\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=4,\n                                          shuffle=True, num_workers=2)\n\ntestset = torchvision.datasets.CIFAR10(root='.\/', train=False,\n                                       download=True, transform=transform)\ntestloader = torch.utils.data.DataLoader(testset, batch_size=4,\n                                         shuffle=False, num_workers=2)\n\nclasses = ('plane', 'car', 'bird', 'cat',\n           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')","3f8472e6":"def imshow(img):\n    img = img \/ 2 + 0.5     # unnormalize\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n\n\n# get some random training images\ndataiter = iter(trainloader)\nimages, labels = dataiter.next()\n\n# show images\nimshow(torchvision.utils.make_grid(images))\n# print labels\nprint(' '.join('%5s' % classes[labels[j]] for j in range(4)))","14ccd169":"class Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 10, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(10, 20, 5)\n        self.fc1 = nn.Linear(20 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 20 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n\nnet = Net()\nnet.to(device)","10cea4cc":"import torch.optim as optim\n\ncriterion = nn.CrossEntropyLoss()\ncriterion.to(device)\noptimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)","05bbaa1f":"# loop over the dataset multiple times\nfor epoch in tqdm_notebook(range(10)):  \n\n    running_loss = 0.0\n    for i, data in tqdm_notebook(enumerate(trainloader, 0)):\n        # get the inputs\n        inputs, labels = data\n        inputs, labels = inputs.to(device), labels.to(device)\n        \n        # zero the parameter gradients\n        optimizer.zero_grad()\n\n        # forward + backward + optimize\n        outputs = net(inputs)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n\n        # print statistics\n        running_loss += loss.data[0]\n        if i % 2000 == 1999:    # print every 2000 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss \/ 2000))\n            running_loss = 0.0\n\nprint('Finished Training')","94df4eae":"dataiter = iter(testloader)\nimages, labels = dataiter.next()\n\n# print images\nimshow(torchvision.utils.make_grid(images))\nprint('GroundTruth: ', ' '.join('%5s' % classes[labels[j]] for j in range(4)))","a8e25f70":"# in PyTorch 0.4.0 you won't need the Variable wrapper\noutputs = net(Variable(images).cuda()) if use_gpu else net(Variable(images))\n#outputs = net(images)","6f20d524":"_, predicted = torch.max(outputs.data, 1)\n\nprint('Predicted: ', ' '.join('%5s' % classes[predicted[j]]\n                              for j in range(4)))","484bca60":"all_pred = np.empty((0, 10), float)","39f98cf6":"for data in tqdm_notebook(testloader):\n    images, _ = data\n    if use_gpu:\n        images = images.to(device)\n    outputs = net(Variable(images))\n    curr_pred = F.softmax(outputs).data.cpu().numpy()\n    all_pred = np.vstack([all_pred, curr_pred])","d0cc7420":"all_pred.shape","8820a378":"pd.DataFrame(all_pred, columns=classes).to_csv('..\/input\/baseline.csv', index_label='id')","f9fc11c3":"!ls ..\/","349acab8":"!ls ..\/input","22545bc3":"!ls baseline.csv","c211cee4":"import pandas as pd\n\ndf = pd.read_csv(\"..\/input\/baseline.csv\")\n\ndf.head(10)","4108906c":"**Train with mini-batches, 10 epochs.**","920b12be":"Currently GPU's are supported in Kernels for this version of PyTorch:","5fae5965":"**Now prediction for the whole test set.**","05ef5769":"Thus, we also need Variable. See changes [here](https:\/\/pytorch.org\/2018\/04\/22\/0_4_0-migration-guide.html).","c3d40130":"**Prediction for first mini-batch**","cd7ff245":"**Untar and load data**\n\nThere is a bug with Kaggle kernels: freshly added data is not seen, so I've added a new \"Data Source\" CIFAR-10-Python.[](http:\/\/)","ca60924e":"**Define net architecture.**","fbdc4b30":"**Define loss and optimizer. With GPU available, loss will also be caclulated on GPU.**"}}