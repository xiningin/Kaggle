{"cell_type":{"61939fef":"code","efc801f3":"code","2bfce3da":"code","0d7089ad":"code","6cd3274a":"code","c8583c70":"code","454ce01e":"code","b5b3003b":"code","8ea2d613":"code","5111fd72":"code","121627d1":"code","a2038eeb":"code","99b7ec93":"code","78f6fa5d":"code","56252373":"code","01343254":"code","7e5b698b":"code","aeb56cd5":"code","5280c4e3":"code","88afd626":"code","4249a63b":"code","a81a9f9e":"code","ab4fe86f":"code","929f2881":"code","dca6ba3d":"code","083783ca":"code","426fc791":"code","8e4bf51c":"code","85cc1d69":"code","716f62d1":"code","6882a5a8":"code","f427be4f":"code","508ac2b1":"code","c869d207":"code","6df46c2f":"code","54feaeb8":"markdown","91d22867":"markdown","e2a3d5f5":"markdown","d9371eb2":"markdown","cfe7b614":"markdown","9f868e22":"markdown","e781832e":"markdown","cf291a53":"markdown","0ed70a36":"markdown","03c4fd4c":"markdown","f84eb2e8":"markdown","f60b90f8":"markdown","60c39884":"markdown","92a07dce":"markdown","b191de58":"markdown","5a8f0a14":"markdown","cf0ece60":"markdown","d5a53228":"markdown","7aed5e2b":"markdown","459d4134":"markdown","079b2458":"markdown","18214d36":"markdown","14a2f1d0":"markdown","1ce3431b":"markdown","c115dc79":"markdown"},"source":{"61939fef":"!pip install skorch","efc801f3":"%matplotlib inline","2bfce3da":"from copy import deepcopy\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import GridSearchCV\nfrom skorch import NeuralNetClassifier\nimport torch\nfrom torch.optim import Adam\nfrom torchvision.models import resnet18","0d7089ad":"seaborn.set(style=\"darkgrid\", context=\"notebook\", palette=\"muted\")\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")","6cd3274a":"seed = 7\nnp.random.seed(seed)\ntorch.manual_seed(seed)\nif torch.cuda.is_available():\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False","c8583c70":"train = pd.read_csv(\"..\/input\/train.csv\")\ntest = pd.read_csv(\"..\/input\/test.csv\")","454ce01e":"print(train.shape)\ntrain.head()","b5b3003b":"print(test.shape)\ntest.head()","8ea2d613":"x_train = train.drop([\"label\"], axis=1) \nx_test = deepcopy(test)\nx_train.shape","5111fd72":"seaborn.distplot(x_train[4:5], kde=False, rug=True)","121627d1":"x_train = x_train \/ 255.0\nx_test = x_test \/ 255.0","a2038eeb":"seaborn.distplot(x_train[4:5], kde=False, rug=True)","99b7ec93":"print(\"train.shape=%s, test.shape=%s\" % (x_train.shape, x_test.shape))","78f6fa5d":"x_train = x_train.values.reshape(-1, 1, 28, 28)\nx_test = x_test.values.reshape(-1, 1, 28, 28)","56252373":"print(\"train.shape=%s, test.shape=%s\" % (x_train.shape, x_test.shape))","01343254":"x_train = torch.from_numpy(x_train).type('torch.FloatTensor')\nx_test = torch.from_numpy(x_test).type('torch.FloatTensor')","7e5b698b":"y_train = train[\"label\"]","aeb56cd5":"y_train = torch.Tensor(y_train).type('torch.LongTensor')","5280c4e3":"y_train[3]","88afd626":"plt.imshow(x_train[3][0,:,:])","4249a63b":"network = resnet18()\nnetwork","a81a9f9e":"network.conv1 = torch.nn.Conv2d(1, 64,\n                                kernel_size=(7, 7),\n                                stride=(2, 2),\n                                padding=(3, 3),\n                                bias=False)\nnetwork.fc = torch.nn.Linear(in_features=512,\n                             out_features=10,\n                             bias=True)\nnetwork.add_module(\"softmax\",\n                   torch.nn.Softmax(dim=-1))\nnetwork","ab4fe86f":"network.zero_grad()\nclassifier = NeuralNetClassifier(\n    network,\n    max_epochs=20,\n    lr=0.01,\n    batch_size=256,\n    optimizer=torch.optim.Adam,\n    device=device,\n    criterion=torch.nn.CrossEntropyLoss,\n    train_split=None\n)\nclassifier.fit(x_train, y_train)","929f2881":"pred_train = classifier.predict(x_train)\npred_train.shape","dca6ba3d":"pred_train[4]","083783ca":"plt.imshow(x_train[4][0,:,:])","426fc791":"cm = confusion_matrix(y_train.numpy(), pred_train) \ncm_df = pd.DataFrame(cm, columns=np.unique(y_train.numpy()), index = np.unique(y_train.numpy()))\ncm_df.index.name = \"True Label\"\ncm_df.columns.name = \"Predicted Label\"\ncm_df","8e4bf51c":"seaborn.heatmap(cm_df,\n                annot=True,\n                cmap=\"Blues\",\n                fmt=\"d\")","85cc1d69":"errors = (pred_train - y_train.numpy() != 0)\npred_train_errors = pred_train[errors]\nx_train_errors = x_train.numpy()[errors]\ny_train_errors = y_train.numpy()[errors]","716f62d1":"pred_train_errors = pred_train_errors[:6]\nx_train_errors = x_train_errors[:6]\ny_train_errors = y_train_errors[:6]","6882a5a8":"fig, ax = plt.subplots(2, 3, sharex=True, sharey=True)\nfor row in range(2):\n    for col in range(3):\n        idx = 3 * row + col\n        ax[row][col].imshow(x_train_errors[idx][0])\n        args = (pred_train_errors[idx], y_train_errors[idx])\n        title = \"Predict:%s,True:%s\" % args\n        ax[row][col].set_title(title)","f427be4f":"pred_test = classifier.predict(x_test)\npred_test.shape","508ac2b1":"pred_test[4]","c869d207":"plt.imshow(x_test[4][0,:,:])","6df46c2f":"result = pd.DataFrame({\"ImageId\" : range(1,28001),\n                       \"Label\" : pred_test})\nresult.to_csv(\"result.csv\",index=False)","54feaeb8":"## Predict from Testing Images","91d22867":"## Try Showing 4th Training Image","e2a3d5f5":"# 1. Preparation","d9371eb2":"## Load Images","cfe7b614":"# 3. Training and Prediction","9f868e22":"## Create Training Images `x_train` and Testing Images `x_test`\nWe separate pixels from `train`, while not separate from `test` because it has only pixels.","e781832e":"## Check the 5th Training Image Prediction","cf291a53":"By checking `torchvision.models.resnet18`, we have to modify as follows.  \n* Change `conv1` layer from 3 channels to 1\n* Change `fc` layer from 1000 output features to 10\n* Add a softmax layer after `fc` layer","0ed70a36":"# 5. Submitting","03c4fd4c":"## Plot Confusion Matrix","f84eb2e8":"## Convert `x_train` and `x_test` from `numpy.array` to `torch.FloatTensor`","f60b90f8":"## Reshape `x_train` and `x_test` from (1, 784) to (1, 28, 28)\nConvert to (channel x width x height).\nGray-scale is defined by only 1 channel.","60c39884":"# 2. Handling Data\n* `train`, `test` : CSV Row Data\n* `x_train` : Training Input Data\n* `y_train` : Training Label Data\n* `x_test` : Testing Input Data","92a07dce":"## Check the 5th Testing Image Prediction","b191de58":"We crerate all error-predicted images, and narrow 6 down.","5a8f0a14":"# 4. Evaluating Training","cf0ece60":"## Create CSV File","d5a53228":"## Scale `x_train` and `x_test` from [0, 255] to [0, 1]","7aed5e2b":"This kernel is forked by [Introduction to CNN Keras - 0.997 (top 6%](https:\/\/www.kaggle.com\/yassineghouzam\/introduction-to-cnn-keras-0-997-top-6).","459d4134":"## Predict from Training Images","079b2458":"## Create Training Labels `y_train`\nWe separate labels from `train`.","18214d36":"## Check Top 6 Error-Predicted Images","14a2f1d0":"## Train","1ce3431b":"### Convert `y_train` from `pandas.DataFrame` to `torch.LongTensor`","c115dc79":"## Crerate and Modify ResNet18"}}