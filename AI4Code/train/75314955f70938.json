{"cell_type":{"b87c3795":"code","28e0be77":"code","1d950d7f":"code","884f1261":"code","7db15f41":"code","59b3d7f3":"code","9574105e":"code","473812ee":"code","7dfd4726":"code","d6932009":"code","a2505a96":"code","58b0fe98":"code","b11a4f5f":"code","5dfba82d":"code","12a632f5":"code","7aadcb57":"code","43f48e1c":"code","7b2321b0":"markdown","0d2a1bf9":"markdown"},"source":{"b87c3795":"#importing libraries\nimport numpy as np\nimport tensorflow as tf\nfrom keras.applications.resnet_v2 import ResNet50V2\nfrom tensorflow import keras\nfrom keras.preprocessing.image import ImageDataGenerator\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt","28e0be77":"#defining directories\ntrain_path = '..\/input\/dog-breed-identification\/train'\ntest_path = '..\/input\/dog-breed-identification\/test'\n\n#reading dataset labels\ntrain_labels = pd.read_csv('..\/input\/dog-breed-identification\/labels.csv')\ntest_labels = pd.read_csv('..\/input\/dog-breed-identification\/sample_submission.csv')","1d950d7f":"train_labels.head()","884f1261":"test_labels.head()","7db15f41":"#in train_labels ids are not in jpg format, hence converting them to jpg\ntrain_labels['id'] = train_labels['id'].apply(lambda x: x + \".jpg\")\ntest_labels['id'] = test_labels['id'].apply(lambda x: x + \".jpg\")","59b3d7f3":"#here i am training model for selected,training all breeds will take hours\n\nx = train_labels.breed.unique()\ninclude = ['beagle', 'chihuahua', 'doberman','french_bulldog', 'golden_retriever', 'malamute', 'pug', 'saint_bernard', 'scottish_deerhound','tibetan_mastiff']\nfor i in x :\n    if i not in include:\n        train_labels = train_labels.drop(train_labels[ train_labels['breed'] == i ].index)\nprint(train_labels.shape)\ntrain_labels.head()","9574105e":"plt.figure(figsize=(18,4))\ncp = sns.countplot(x = 'breed', data = train_labels)\n","473812ee":"#train_datagen is used for feature scaling and image augmentation (image augmentation is applied to avoid overfitting).\ntrain_datagen = ImageDataGenerator(\n                                   rescale = 1.\/255, \n                                   validation_split = 0.2,\n                                   shear_range = 0.2, \n                                   zoom_range = 0.2, horizontal_flip = True, \n                                   width_shift_range = 0.2,\n                                   height_shift_range = 0.2,\n                                   rotation_range = 20,\n                                   brightness_range=[0.2,1.0])\n\n#defining training set, here size of image is reduced to 224x224, batch of images is kept as 32 and class is defined as 'categorical'.\ntrain_set = train_datagen.flow_from_dataframe(dataframe = train_labels,\n                                                 directory = train_path,\n                                                 x_col = \"id\",\n                                                 y_col = \"breed\",\n                                                 batch_size = 16,\n                                                 subset=\"training\",\n                                                 class_mode = \"categorical\",\n                                                 target_size = (224,224),\n                                                 seed = 42,\n                                                 shuffle = True)","7dfd4726":"#defining validation set, here size of image is reduced to 224x224, batch of images is kept as 32 and class is defined as 'categorical' and subset as 'validation'.\nvalidate_set = train_datagen.flow_from_dataframe(dataframe = train_labels,\n                                                 directory = train_path,\n                                                 x_col = \"id\",\n                                                 y_col = \"breed\",\n                                                 batch_size = 16,\n                                                 subset=\"validation\",\n                                                 class_mode = \"categorical\",\n                                                 target_size = (224,224),\n                                                 seed = 42,\n                                                 shuffle = True)","d6932009":"#only rescaling is applied\ntest_datagen = ImageDataGenerator(rescale=1.\/255)\n\n#defining test set\ntest_set = test_datagen.flow_from_dataframe(dataframe = test_labels,\n                                                 directory = test_path,\n                                                 x_col = \"id\",\n                                                 y_col = None,\n                                                 batch_size = 16,\n                                                 class_mode = None,\n                                                 seed = 42,\n                                                 shuffle=False,\n                                                 target_size = (224,224))","a2505a96":"train_set.batch_size","58b0fe98":"1e-4","b11a4f5f":"#defining resnet50v2\nresnet = ResNet50V2(input_shape = [224,224,3], weights = 'imagenet', include_top = False)\n\n#we have to take pre trained weights, we don't want to train the weights again\nfor layer in resnet.layers:\n    layer.trainable = False\n\n#flattening the output of resnet for fully connected layer.\nx = keras.layers.Flatten()(resnet.output)\n\n#dropping out 40% to avoid overfitting\nx = keras.layers.Dropout(0.4)(x)\n\n#final layer will have 10 neurons\npred = keras.layers.Dense(10, activation='softmax')(x)\n\n#creating the model \nmodel = tf.keras.models.Model(inputs=resnet.input, outputs=pred)\n\n#taking learning rate as 0.00001\nopt = tf.keras.optimizers.Adam(learning_rate = 1e-5)\nmodel.compile(optimizer=opt,loss='categorical_crossentropy',metrics=['accuracy'])\n\n#defining train step and validate step (total value\/batch size)\ntrain_step = train_set.n\/\/train_set.batch_size\nvalidate_step = validate_set.n\/\/validate_set.batch_size\n\n#training model\nresnet50 = model.fit(train_set,validation_data = validate_set,epochs = 30,steps_per_epoch = train_step, validation_steps = validate_step)","5dfba82d":"#evaluating model\nmodel.evaluate(validate_set)","12a632f5":"#predicting output\nSTEP_SIZE_TEST=test_set.n\/\/test_set.batch_size\n\n#if we don't reset we'll get output in an unordered complex manner\ntest_set.reset()\n\npred=model.predict(test_set,steps=STEP_SIZE_TEST,verbose=1)","7aadcb57":"plt.plot(resnet50.history['accuracy'])\nplt.plot(resnet50.history['val_accuracy'])\nplt.title('Model accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Test'], loc='upper left')\nplt.show()\n\nplt.plot(resnet50.history['loss'])\nplt.plot(resnet50.history['val_loss'])\nplt.title('Model loss')\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Test'], loc='upper left')\nplt.show()","43f48e1c":"#pred will be only probabilities, therefore take=ing class of highest probability.\npredicted_class_indices=np.argmax(pred,axis=1)\n\n#labels include class indices of train set\nlabels = (train_set.class_indices)\n\n#creating a dictionery\nlabels = dict((v,k) for k,v in labels.items())\n\n#predictions include names of predictions instead of number\npredictions = [labels[k] for k in predicted_class_indices]","7b2321b0":"**CLASSIFYING DOG BREEDS USING TRANFER LEARNING MODEL RESNET50V2.**\n\n**HERE I HAVE TAKEN ONLY 10 SELECTED CLASSES,BUT THIS MODEL CAN BE USED FOR ENTIRE SET ALSO**\n","0d2a1bf9":"**NOTE:TRAINING AND VAILDATING WAS DONE FOR 10 CLASSES ONLY BUT WE ARE TESTING IT ON DATASET CONTAINING ALL THE CLASSES(TOTOAL 120).**\n\n**THEREFORE WE'LL BE GETTING BAD VALUES FOR THE CLASSES WHICH AREN'T TRAINED**"}}