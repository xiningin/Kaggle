{"cell_type":{"f26b66bb":"code","9c25b4b7":"code","8ff5299b":"code","0f2b7305":"code","95c83743":"code","bae0348a":"code","909a0c98":"code","efaa9e8d":"code","d3b8ce58":"code","71cf2beb":"code","72f3bdd3":"code","f526b6c2":"code","a15d9cf2":"code","16a3fcf0":"code","77d92e67":"code","fd8c8842":"code","f9a71956":"code","976e6c23":"code","5310318b":"code","8d78e5b1":"code","528a6597":"code","12b8eaea":"code","f9f1bc9e":"code","a70f9860":"code","8932eefb":"code","1d556d67":"code","9d9a31d1":"code","3436bcee":"code","c02a972c":"code","c0405685":"code","9c0b7c16":"code","cd7738ba":"code","29d14be4":"code","ca526a3d":"code","c2d86f73":"code","8333e5f2":"code","51a7f620":"code","3f2798f0":"code","974615a3":"code","ad6a73bb":"code","0f613041":"code","2bb27610":"code","4433b146":"code","89a30ee3":"code","b2dedac3":"code","92cab3e5":"code","a02f377f":"code","9fa8c44b":"code","469b1a40":"code","a554bd52":"code","dfba6cba":"code","f2bca5a8":"code","6a3d7da4":"code","84cd2dfe":"code","81519e32":"code","9edc6a1b":"markdown","5c8e04de":"markdown","b6c822c3":"markdown","41f45dd9":"markdown","9ce939e5":"markdown","cc6bb632":"markdown","31d3350f":"markdown","bbf496d2":"markdown","94fd9497":"markdown","7785542f":"markdown","43d7dcb2":"markdown","fbc172b1":"markdown","9ebf101f":"markdown","4c9f0549":"markdown","1d6cba13":"markdown","493cbe50":"markdown","370d5c04":"markdown","035c7ee6":"markdown"},"source":{"f26b66bb":"!conda install -y -c rdkit rdkit","9c25b4b7":"#-- Run twice ...\napi.competition_download_file('bms-molecular-translation','sample_submission.csv')\napi.competition_download_file('bms-molecular-translation','train_labels.csv')\n\n!mkdir '.\/bms-mol_v3'\n!mv '.\/sample_submission.csv.zip' '.\/bms-mol_v3'\n!mv '.\/train_labels.csv.zip' '.\/bms-mol_v3'\n##!unzip '.\/bms-mol_v3\/train_labels.csv.zip'\n##!ls .\/bms-mol_v3\n\nDATA_labels1='.\/bms-mol_v3\/train_labels.csv.zip'\n### only this number of rows for testing purposes\nnrows1=1000\n\n#### loading the data ---\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport requests, zipfile\ndata1 = pd.read_csv(DATA_labels1,nrows=nrows1,compression='zip')\n\nfilenames = data1['image_id'].apply(\n    lambda x: \"\/train\/{}\/{}\/{}\/{}.png\".format(\n        x[0], x[1], x[2], x))\nfilenames\n\nfor filename in filenames:\n    api.competition_download_file('bms-molecular-translation', filename)\n\n!mv *.png .\/bms-mol_v3\/\n\n!ls .\/bms-mol_v3\/","8ff5299b":"!ls .\/bms-mol_v3\/","0f2b7305":"import numpy as np \n##import pandas as pd \nfrom tqdm.auto import tqdm\ntqdm.pandas()\n#### For plots #################\nimport skimage.io as io\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom collections import Counter, defaultdict\nimport cv2\nimport Levenshtein\n#################################\n\nfrom sklearn.model_selection import train_test_split\nimport rdkit\nfrom rdkit.Chem.Descriptors import MolWt\nfrom rdkit.Chem import Descriptors\nimport shutil\nfrom sklearn.metrics import jaccard_score\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Activation, Flatten, Dropout, BatchNormalization\nfrom keras.layers import Conv2D, MaxPooling2D\nfrom keras import regularizers, optimizers\nfrom keras.layers import Dropout\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","95c83743":"DATA_labels='..\/input\/dataset-bms-mol-v3\/train_labels.csv'\n## only this number of rows for testing purposes\nnrows1=nrows1\n\n#### loading the data ---\n##import pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\ndata = data1 #pd.read_csv(DATA_labels,nrows=nrows1)\n\n#### for submission files etc,etc...\n##ss = pd.read_csv('..\/input\/dataset-bms-mol-v3\/sample_submission.csv', index_col = 0)\nss = pd.read_csv('.\/bms-mol_v3\/sample_submission.csv.zip', index_col = 0,compression='zip')\n\n\n# Let's add the path of the images to de DF...\ndata['path'] = data['image_id'].progress_apply(\n    lambda x: \".\/bms-mol_v3\/{}.png\".format(x))\n##    lambda x: \"..\/input\/dataset-bms-mol-v3\/train\/{}\/{}\/{}\/{}.png\".format(\n##        x[0], x[1], x[2], x))\n\n### Prepare to create only 2 Parts InChI --- Later adding more --\nlabel_splited2 = data['InChI'].progress_apply(lambda x: x.split('\/'))\n# Data Frame with label parts\nlabel_parts2 = pd.DataFrame.from_records(label_splited2.values)\nlabel_parts2.columns = np.array(label_parts2.columns + 1)\nlabel_parts2 = label_parts2.add_prefix('Part_')\n## important to add\nlabel_parts2['path'] = data['path']\nlabel_parts2.head()","bae0348a":"train_sample = label_parts2 #.sample(nrows1)\n#train_sample['img_tensor'] = train_sample['path'].progress_apply(lambda x: io.imread(x))\ntrain_sample['InChI2p']= train_sample['Part_2']+\"\/\"+train_sample['Part_4'] ## Part_3 is complex, coming back later...\n\n#train_sample.drop(columns=['Part_1', 'Part_2', 'Part_3', 'Part_4', 'Part_5', 'Part_6', 'Part_7', 'Part_8'], inplace=True)\nParts2dropMax=max([len(i) for i in label_splited2])+1 # for the InChI=1S\/\nParts2drop=['Part_'+str(i) for i in range(1,Parts2dropMax)]\ntrain_sample.drop(columns=Parts2drop,inplace=True)\n\ntrain_sample = train_sample.reset_index()\ntrain_sample.head()","909a0c98":"train_sample.shape","efaa9e8d":"class FeatureExtractorRDKIT():\n        \n    def __init__(self, df):\n        self.df = df\n        self.extract_features()\n             \n    def _get_mol_object(self):\n        self.df['MOL'] = self.df.SMILES.apply(lambda x: rdkit.Chem.MolFromSmiles(x))\n        \n    def _add_h_atoms(self):\n        self.df['MOL'] = self.df.MOL.apply(lambda x: rdkit.Chem.AddHs(x))\n    \n    def get_ring_info(self, x):\n        ri = x.GetRingInfo()\n        return ri.AtomRings()\n\n    def _num_of_rings(self):\n        self.df['num_of_rings'] = self.df.MOL.apply(lambda x: len(self.get_ring_info(x)))\n        \n    def _num_of_atoms_in_mol(self):\n        self.df['num_of_atoms_in_mol'] = self.df.MOL.apply(lambda x: x.GetNumAtoms())\n    \n    def _num_of_heavy_atoms_in_mol(self):\n        self.df['num_of_heavy_atoms_in_mol'] = self.df.MOL.apply(lambda x: x.GetNumHeavyAtoms())\n\n    def _lipophilicity(self):\n        self.df['logP'] = self.df.MOL.apply(lambda x: rdkit.Chem.Crippen.MolLogP(x))\n        \n    def _max_abs_estate(self):\n        self.df['max_abs_estate'] = self.df.MOL.apply(lambda x: rdkit.Chem.EState.EState.MaxAbsEStateIndex(x))\n        \n    def _min_abs_estate(self):\n        self.df['min_abs_estate'] = self.df.MOL.apply(lambda x: rdkit.Chem.EState.EState.MinAbsEStateIndex(x))\n        \n    def _min_estate(self):\n        self.df['min_estate'] = self.df.MOL.apply(lambda x: rdkit.Chem.EState.EState.MinEStateIndex(x))\n        \n    def _ether_oxygen(self):\n        self.df['ether_oxygen'] = self.df.MOL.apply(lambda x: rdkit.Chem.Fragments.fr_ether(x))\n        \n    def _aliphatic_carboxylic_acid(self):\n        self.df['aliphatic_carboxylic_acid'] = self.df.MOL.apply(lambda x: rdkit.Chem.Fragments.fr_Al_COO(x))\n        \n    def _carboxylic_acid_1(self):\n        self.df['carboxylic_acid_1'] = self.df.MOL.apply(lambda x: rdkit.Chem.Fragments.fr_COO(x))\n        \n    def _carboxylic_acid_2(self):\n        self.df['carboxylic_acid_2'] = self.df.MOL.apply(lambda x: rdkit.Chem.Fragments.fr_COO2(x))\n        \n    def _num_of_esters(self):\n        self.df['num_of_esters'] = self.df.MOL.apply(lambda x: rdkit.Chem.Fragments.fr_ester(x))\n        \n    def _num_of_aldehyde(self):\n        self.df['num_of_aldehyde'] = self.df.MOL.apply(lambda x: rdkit.Chem.Fragments.fr_aldehyde(x))\n        \n    def _num_of_ketone(self):\n        self.df['num_of_ketone'] = self.df.MOL.apply(lambda x: rdkit.Chem.Fragments.fr_ketone(x))\n            \n    def _molMR(self):\n        self.df['molMR'] = self.df.MOL.apply(lambda x: rdkit.Chem.Crippen.MolMR(x))\n        \n    def _len_smiles(self):\n        self.df['len_smiles'] = self.df.SMILES.apply(lambda x: len(list(x)))\n        \n    def _number_of_atoms(self):\n        atom_list = ['C', 'O', 'N', 'Cl', 'Br', 'F', 'S']\n        for atom in atom_list:\n            self.df['num_of_{}_atoms'.format(atom)] = self.df.MOL.apply(lambda x: len(x.GetSubstructMatches(rdkit.Chem.MolFromSmiles(atom))))\n\n    def _tpsa(self):\n        self.df['tpsa'] = self.df.MOL.apply(lambda x: Descriptors.TPSA(x))\n        \n    def _mol_w(self):\n        self.df['mol_w'] = self.df.MOL.apply(lambda x: Descriptors.ExactMolWt(x))\n        \n    def _num_valence_electrons(self):\n        self.df['num_valence_electrons'] = self.df.MOL.apply(lambda x: Descriptors.NumValenceElectrons(x))\n    \n    def _num_heteroatoms(self):\n        self.df['num_heteroatoms'] = self.df.MOL.apply(lambda x: Descriptors.NumHeteroatoms(x))\n        \n    def drop_for_train(self):\n        self.df = self.df.drop(['SMILES', 'MOL', 'SENTENCE'], axis=1)\n        \n    def drop_for_test(self):\n        self.df = self.df.drop(['SMILES', 'MOL'], axis=1)\n        \n    def return_data(self):\n        return self.df\n    \n    def extract_features(self):\n        self._get_mol_object()\n        self._add_h_atoms()\n        self._num_of_rings()\n        self._num_of_atoms_in_mol()\n        self._num_of_heavy_atoms_in_mol()\n        self._lipophilicity()\n#         self._max_abs_estate()\n#         self._min_abs_estate()\n#         self._min_estate()\n#         self._ether_oxygen()\n#         self._aliphatic_carboxylic_acid()\n#         self._carboxylic_acid_1()\n#         self._carboxylic_acid_2()\n#         self._num_of_esters()\n#         self._num_of_aldehyde()\n#         self._num_of_ketone()\n#         self._molMR()\n        self._len_smiles()\n        self._number_of_atoms()\n        self._tpsa()\n        self._mol_w()\n        self._num_valence_electrons()\n        self._num_heteroatoms()","d3b8ce58":"'''Extraxt information from MOL graph.'''\n\nclass MOLGraphToMatrix:\n    \n    class ConnectivityMatrix():\n        \n        def __init__(self, df):\n            self.df = df\n            self.extract_features()\n            \n        def _get_mol_object(self):\n            if 'MOL' not in self.df:\n                self.df['MOL'] = self.df.SMILES.apply(lambda x: rdkit.Chem.MolFromSmiles(x))\n        \n        def _add_h_atoms(self):\n            if 'MOL' in self.df:\n                self.df['MOL'] = self.df.MOL.apply(lambda x: rdkit.Chem.AddHs(x))\n            \n        def connectivity_matrix(self, mol):\n            mol = rdkit.Chem.AddHs(mol)\n            matrix = rdkit.Chem.GetAdjacencyMatrix(mol)\n            if matrix.shape[0] <= 50:\n                padding_size = 50 - matrix.shape[0]\n                matrix = np.pad(matrix, (0, padding_size), 'constant', constant_values=(0))\n                return matrix\n            else:\n                return []\n            \n        def _make_connectivity_matrix(self):\n            self.df['connectivity_matrix'] = self.df.MOL.apply(lambda x: self.connectivity_matrix(x))\n            \n        def _len_connectivity_matrix(self):\n            self.df['len_con_matrix'] = self.df.connectivity_matrix.apply(lambda x: len(x))\n            \n        def extract_features(self):\n            self._get_mol_object()\n            self._add_h_atoms()\n            self._make_connectivity_matrix()\n            self._len_connectivity_matrix()\n        \n        def return_data(self):\n            return self.df\n        \n    class DistanceMatrix():\n        \n        def __init__(self, df):\n            self.df = df\n            self.extract_features()\n            \n        def _get_mol_object(self):\n            if 'MOL' not in self.df:\n                self.df['MOL'] = self.df.SMILES.apply(lambda x: rdkit.Chem.MolFromSmiles(x))\n        \n        def _add_h_atoms(self):\n            if 'MOL' in self.df:\n                self.df['MOL'] = self.df.MOL.apply(lambda x: rdkit.Chem.AddHs(x))\n            \n        def distance_matrix(self, mol):\n            mol = rdkit.Chem.AddHs(mol)\n            matrix = rdkit.Chem.GetDistanceMatrix(mol)\n            if matrix.shape[0] <= 50:\n                padding_size = 50 - matrix.shape[0]\n                matrix = np.pad(matrix, (0, padding_size), 'constant', constant_values=(0))\n                return matrix\n            else:\n                return []\n            \n        def _make_distance_matrix(self):\n            self.df['distance_matrix'] = self.df.MOL.apply(lambda x: self.distance_matrix(x))\n            \n        def extract_features(self):\n            self._get_mol_object()\n            self._add_h_atoms()\n            self._make_distance_matrix()\n        \n        def return_data(self):\n            return self.df\n        \n    class NodeFeaturesMatrix():\n        \n        def __init__(self, df):\n            self.df = df\n           \n        def _get_all_atom_types(self):\n            pass\n        \n        def _get_atom_type(self):\n            pass\n        \n        def _get_formal_charge(self):\n            pass\n        \n        def _get_implicit_Hs(self):\n            pass\n            \n        def _make_node_features_matrix(self):\n            pass\n        \n        def return_data(self):\n            return self.df\n        \n    class EdgeFeaturesMatrix():\n        \n        def __init__(self, df):\n            self.df = df\n            \n        def _get_all_bonds_in_df(self):\n            pass\n        \n        def _encode_smiles_bonds(self):\n            pass\n        \n        def _make_edge_featurs_matrix(self):\n            pass\n            \n        def return_data(self):\n            return self.df","71cf2beb":"inchis = data['InChI'].iloc[0:nrows1]\ninchis","72f3bdd3":"## you can send a direct request to get the SMILES representation \nHOST = \"http:\/\/www.chemspider.com\"\nOperation = \"\/InChI.asmx\/InChIToInChIKey?inchi=\"\n\nIn2res=[]\nfor inchi in inchis:\n    request = requests.get('{}{}{}'.format(HOST, Operation, inchi))\n    if request.ok:\n        res = str(request.text.replace('<?xml version=\"1.0\" encoding=\"utf-8\"?>\\r\\n<string xmlns=\"http:\/\/www.chemspider.com\/\">', '').replace('<\/string>', '').strip())\n        In2res.append(res)\n    else:\n        print (\"provide a valid inchi!\")\n        In2res.append('None')\n\nprint(In2res)","f526b6c2":"!pip install bioservices","a15d9cf2":"#get information about the Molecular\nfrom bioservices import *\ninfo = UniChem()\n\ncids=[]\nfor res in In2res:\n    cid = info.get_src_compound_ids_from_inchikey(res)\n    cids.append(cid)\n\n\n#####\n#####\n# Now let us go to SMILES using another service for FUN \ndef get_smiles_from_inchikey(inchikey):\n    request = requests.get(f'https:\/\/pubchem.ncbi.nlm.nih.gov\/rest\/pug\/compound\/inchikey\/{inchikey}\/property\/CanonicalSMILES\/JSON').json()\n    return request['PropertyTable']['Properties'][0]['CanonicalSMILES']\n\n#####\n#####","16a3fcf0":"#cid0=info.get_src_compound_ids_from_inchikey(In2res[0])\n#cid1=info.get_src_compound_ids_from_inchikey(In2res[1])\nprint(cids)\n#type(cids[1])","77d92e67":"SMILESdf=[]\nfor i,res in tqdm(enumerate(In2res)):\n    print(res)\n    if cids[i]!=404:\n        smiles_pres=get_smiles_from_inchikey(res)\n        SMILESdf.append(smiles_pres)\n        print(smiles_pres)\n    else: SMILESdf.append('None')","fd8c8842":"SMILESdf","f9a71956":"# new library ))\n#!pip install -U chembl_webresource_client","976e6c23":"# go back from InChiKey to In Chi\nfrom chembl_webresource_client.unichem import unichem_client as unichem\nret = unichem.inchiFromKey(res)\nprint (ret[0]['standardinchi'])\nprint(inchi)","5310318b":"print(train_sample.shape)\nprint(len(SMILESdf))","8d78e5b1":"train_sample['SMILES']=[i for i in SMILESdf]\ntrain_sample=train_sample[train_sample['SMILES']!='None']\ntrain_sample.head()\n#rdkit.Chem.AddHs(rdkit.Chem.MolFromSmiles(SMILESdf[2]))","528a6597":"cm_train = MOLGraphToMatrix().ConnectivityMatrix(train_sample)\ntrain = cm_train.return_data()\ntrain = train.query('len_con_matrix > 0')\ntrain = train.reset_index(drop=True)","12b8eaea":"train.head()","f9f1bc9e":"train_path = \"\/kaggle\/working\/train\"\ntest_path = \"\/kaggle\/working\/test\"\n\nif os.path.exists(train_path):\n    shutil.rmtree(train_path)\n    \nif os.path.exists(test_path):\n    shutil.rmtree(test_path)\n\nos.mkdir(train_path)\nos.mkdir(test_path)","a70f9860":"def train_image_InchI_df(df):\n    df['image_id'] = np.nan\n    l = list()\n    for i, smiles in enumerate(df.SMILES):\n        _id = \".\/train\/image_{0}.png\".format(i)\n        l.append(_id)\n    df['image_id'] = l\n    images_df = pd.DataFrame(columns=[\"image_id\", \"SMILES\", \"InChI2p\"])\n    images_df.image_id = df.image_id\n    images_df.InChI2p = df.InChI2p\n    images_df.SMILES = df.SMILES\n    #images_df.InChI2p = images_df.InChI2p.apply(lambda x: x.split(\"\/\"))\n    return images_df\n\n### Check if the connectivity matrix is cero and remove it from the dataset -- Look later..\ntrain_sampleWOconnec=train_sample[train_sample[\"connectivity_matrix\"].str.len() != 0]\ntrain_images_df = train_image_InchI_df(train_sampleWOconnec)","8932eefb":"def make_image_from_smiles(idx, dataset_name, df):\n    arr = df.connectivity_matrix.iloc[idx]\n    arr = np.asarray(arr)\n    rescaled = (255.0 \/ arr.max() * (arr - arr.min())).astype(np.uint8)\n    path = \"\/kaggle\/working\/{0}\".format(dataset_name)\n    plt.imsave(\"\/kaggle\/working\/{0}\/image_{1}.png\".format(dataset_name, idx), rescaled)\n\nfor idx, smiles in tqdm(enumerate(train_sampleWOconnec.SMILES)): \n    make_image_from_smiles(idx, \"train\", train_sampleWOconnec)","1d556d67":"train_sampleWOconnec.head()","9d9a31d1":"!ls .\/train","3436bcee":"def image_viz(image_id, title, figsize=(12,6)):\n    \"\"\"\n    Function for image visualization.\n    Takes image tensor, plot title (label) and figsize.\n    \"\"\"\n    image = cv2.imread(image_id)\n    plt.figure(figsize = figsize)\n    plt.imshow(image)\n    plt.title(title, size = 16)\n    plt.axis('off')\n    plt.show()\n    \n# ref: https:\/\/www.kaggle.com\/ihelon\/molecular-translation-exploratory-data-analysis \ndef convert_image_id_2_path(image_id: str) -> str:\n        return \".\/bms-mol_v3\/{}.png\".format(image_id\n##    return \"..\/input\/dataset-bms-mol-v3\/train\/{}\/{}\/{}\/{}.png\".format(\n##        image_id[0], image_id[1], image_id[2], image_id \n    )\n\n#ref: https:\/\/www.kaggle.com\/ihelon\/molecular-translation-exploratory-data-analysis\ndef visualize_train_image(image_id, label):\n    plt.figure(figsize=(5, 5))\n    print(image_id)\n    image = cv2.imread(convert_image_id_2_path(image_id))\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    plt.imshow(image)\n    plt.title(f\"{label}\", fontsize=14)\n    plt.axis(\"off\")\n    \n    plt.show()","c02a972c":"sample_row = data.iloc[0]\nvisualize_train_image(\n        sample_row[\"image_id\"], sample_row[\"InChI\"]\n    )","c0405685":"sample_row =train_sampleWOconnec.iloc[0]\nimage_viz(sample_row['image_id'], sample_row['SMILES'])","9c0b7c16":" train_images_df.tail","cd7738ba":"idx=3\nsample_row = train_sampleWOconnec.iloc[idx]\n\ndisplay(\n        ### synthetic\n        rdkit.Chem.MolFromSmiles(sample_row.SMILES),\n        \n        #### dataset\n        image_viz(\n        sample_row.path, sample_row.InChI2p\n    ))","29d14be4":"from rdkit import Chem\nfrom rdkit.Chem import Draw, AllChem\nimport matplotlib.pyplot as plt\n\ndef draw_structure(mol_smiles_string, template_smiles_string, ax=None):\n    if not ax:\n        f, ax = plt.subplots()\n    m = Chem.MolFromSmiles(mol_smiles_string, sanitize=False)\n    m.UpdatePropertyCache()\n    Chem.SetHybridization(m)\n    t = Chem.MolFromSmiles(template_smiles_string, sanitize=False)\n    t.UpdatePropertyCache()\n    Chem.SetHybridization(t)\n    AllChem.Compute2DCoords(t)\n    AllChem.GenerateDepictionMatching2DStructure(m, t)\n    img = Draw.MolToImage(m)\n    return ax.imshow(img, interpolation='bessel')\n\nfig = plt.figure(figsize=(10,5))\nax1 = plt.subplot2grid((1, 3), (0, 0))\nax2 = plt.subplot2grid((1, 3), (0, 1))\ndraw_structure(mol_smiles_string=sample_row.SMILES,\ntemplate_smiles_string=sample_row.SMILES, ax=ax1)\ndraw_structure(mol_smiles_string=sample_row.SMILES,\ntemplate_smiles_string=sample_row.SMILES, ax=ax2)\nimage_viz(\n        sample_row.path, sample_row.InChI2p\n    )\nplt.tight_layout()\nplt.show()","ca526a3d":"train_sample.head()#InChI2p.iloc[250]","c2d86f73":"plt.figure(figsize = (14, 14))\nfor i in range(3):\n    image = cv2.imread(train_sampleWOconnec.path.iloc[i])\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    image1 = cv2.imread(train_sampleWOconnec.image_id.iloc[i])\n    image1 = cv2.cvtColor(image1, cv2.COLOR_BGR2RGB)\n    \n    ax1 = plt.subplot(4, 3, 3*i+1)\n    ax1.imshow(image)\n    plt.title(train_sample.InChI2p.iloc[i][0:15]+'...', size = 10)\n    ax2 = plt.subplot(4, 3, 3*i+2)\n    ax2.imshow(image1)\n    ax3 = plt.subplot(4, 3, 3*i+3)\n    ax3.imshow(Draw.MolToImage(Chem.MolFromSmiles(train_sampleWOconnec['SMILES'].iloc[i])))\n    plt.title(train_sampleWOconnec['SMILES'].iloc[i][0:15]+'...', size = 10)\n    #plt.axis('off')\n\nplt.show()","8333e5f2":"import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nw=10\nh=10\nfig=plt.figure(figsize=(10, 10))\ncolumns = 4\nrows = 5\nfor i in range(1, 10):\n    file = os.listdir('\/kaggle\/working\/train\/')[i]\n    img = mpimg.imread(os.path.join('\/kaggle\/working\/train\/', file))\n    fig.add_subplot(rows, columns, i)\n    plt.imshow(img)\nplt.show()","51a7f620":"plt.figure(figsize=(15,5))\neda_train = train_sampleWOconnec.copy()\neda_train['len_smiles'] = train_sampleWOconnec.SMILES.apply(lambda x: len(x))\nax = sns.distplot(eda_train['len_smiles']).set_title(\"SMILES length in train dataset\")","3f2798f0":"print(train_sample.shape,train_images_df.shape)","974615a3":"import tensorflow as tf\nimport keras\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.experimental import CosineDecay\nfrom tensorflow.keras.callbacks import ModelCheckpoint\nfrom tensorflow.keras.models import Sequential, load_model\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.layers import GlobalAveragePooling2D, Dense, Conv2D, BatchNormalization, MaxPool2D, Dropout\nimport Levenshtein","ad6a73bb":"def train_trans_func(image):\n    return image \/ 255.\n\ndef val_trans_func(image):\n    return image \/ 255.\n\ndatagen_train = ImageDataGenerator(preprocessing_function = train_trans_func)\ndatagen_val = ImageDataGenerator(preprocessing_function = val_trans_func)","0f613041":"exploreSize = train_images_df.copy()\nexploreSize['img_tensor'] =train_images_df['image_id'].progress_apply(lambda x: io.imread(x))\n# Let's exlore the dimensions of images to take an \"average number...\"\nexploreSize['img_height'] = exploreSize['img_tensor'].progress_apply(lambda x: np.shape(x)[0])\nexploreSize['img_width'] = exploreSize['img_tensor'].progress_apply(lambda x: np.shape(x)[1])","2bb27610":"sns.jointplot(x = exploreSize['img_width'].astype('float32'), \n              y = exploreSize['img_height'].astype('float32'),\n              height = 4, color = '#930077')\nplt.show()","4433b146":"img_size=50\nclass_mode = \"raw\"\ninterpolation = \"nearest\"\nshuffle = False ## I want the map to be \"untouchable\"for now...\ncolor_mode = \"grayscale\"\nbatch_size_Run =16\nler_rat=0.005\n    \ndef create_train_set(train):\n    train_set = datagen_train.flow_from_dataframe(train,\n                                                  directory = None,\n                                                  seed = 12345,\n                                                  x_col = \"image_id\",\n                                                  y_col = 'SMILES',\n                                                  target_size = (img_size, img_size),\n                                                  class_mode = class_mode,\n                                                  interpolation = interpolation,\n                                                  shuffle = shuffle,\n                                                  color_mode = color_mode,\n                                                  batch_size = batch_size_Run,\n                                                  #######\n#                                                    rotation_range=40,\n#                                                    width_shift_range=0.2,\n#                                                    shear_range=0.2,\n#                                                    zoom_range=0.2,\n#                                                    horizontal_flip=True,\n                                                 )\n    return train_set\n    \ndef create_val_set(val):\n    val_set = datagen_val.flow_from_dataframe(val,\n                                              directory = None,\n                                              seed=12345,\n                                              x_col = \"image_id\",\n                                              y_col = 'SMILES',\n                                              target_size = (img_size, img_size),\n                                              class_mode = class_mode,\n                                              interpolation = interpolation,\n                                              shuffle = shuffle,\n                                              color_mode = color_mode,\n                                              batch_size = batch_size_Run)\n    return val_set","89a30ee3":"from sklearn.model_selection import train_test_split\n\n## It does not matter if is not perftly organized. Yoy will receive dfs in return...\n\ntrain, val = train_test_split(train_images_df, test_size=0.2, random_state=12345)\n\n\n########\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder, OrdinalEncoder\n\n# prepare input data\ndef prepare_target(train_y_no):\n    le = LabelEncoder()\n    le.fit(train_y_no)\n    train_y = le.transform(train_y_no)\n    return train_y\n\ntrain['SMILES'] = prepare_target(train['SMILES'])\nval['SMILES'] = prepare_target(val['SMILES']) \nprint ('(Training, TEST)- TARGET shape:', train.shape, val.shape)\n########\n\n\n\nvalid_set = create_val_set(val)\ntrain_set = create_train_set(train)","b2dedac3":"train_images_df['SMILES'].head","92cab3e5":"import collections\nprint([item for item, count in collections.Counter(train_images_df['SMILES']).items() if count > 1])","a02f377f":"n_CLASS=len(train_images_df['SMILES'].unique())\nn_CLASS","9fa8c44b":"def create_model():\n    model = Sequential()\n    model.add(Conv2D(16, 3, activation=\"relu\", padding=\"same\", input_shape=(img_size, img_size, 1)))\n    model.add(Conv2D(16, 3, activation=\"relu\", padding=\"same\"))\n    model.add(BatchNormalization())\n    model.add(MaxPool2D(pool_size=(2, 2), strides=None, padding=\"valid\"))    \n    model.add(GlobalAveragePooling2D())\n    model.add(Dense(n_CLASS, activation=\"relu\"))\n\n    return model\n\nmodel = create_model()\nmodel.summary()","469b1a40":"step_size_train = train_set.n \/\/ train_set.batch_size\nstep_size_valid = valid_set.n \/\/ valid_set.batch_size\nprint(step_size_train,step_size_valid)","a554bd52":"from tensorflow.keras.callbacks import EarlyStopping\n\nearly_stopping = EarlyStopping(\n    patience=5,\n    min_delta=0.001,\n    restore_best_weights=True,\n)\n\nepochs=20\nmodel = create_model()\n#model.load_weights(\"..\/input\/kaggle-api\/bms_formula_model.h5\")\n#model.load_weights(\".\/bms_formula_model.h5\")\n\nlr = CosineDecay(initial_learning_rate = ler_rat,\n                 decay_steps = step_size_train * epochs)\n\nmodel.compile(optimizer = Adam(learning_rate=  ler_rat),\n              loss='MAE',\n              metrics=['MAE'])\n#              loss=\"mean_squared_error\",\n#              metrics=[\"mean_squared_error\"])\n\n## checking --\ncheckpoint_cb = ModelCheckpoint(\"bms_formula_best_model.h5\",\n                                save_best_only=True,\n                                monitor=\"val_loss\",\n                                mode=\"min\")\n\n## Training --\nhistory = model.fit(train_set,\n                    validation_data = valid_set,\n                    epochs = epochs,\n                    batch_size = batch_size_Run,\n                    steps_per_epoch = step_size_train,\n                    validation_steps = step_size_valid,\n                    callbacks=[checkpoint_cb, early_stopping]) # checkpoint_cb,\n\n## saving --\nmodel.save(\"bms_formula_model.h5\")","dfba6cba":"history_df = pd.DataFrame(history.history)\nhistory_df.loc[:, ['loss','val_loss']].plot(title=\"MSE\") #,'val_loss'","f2bca5a8":"for i, (imgArr, smilesArr) in enumerate(tqdm(train_set)):\n    if i >= 1:\n        break\n    Myimg=imgArr\n    Mysmiles=smilesArr\n    print(smilesArr)","6a3d7da4":"def image_viz2(image_id, title, figsize=(12,6)):\n    \"\"\"\n    Function for image visualization.\n    Takes image tensor, plot title (label) and figsize.\n    \"\"\"\n    image = image_id\n    plt.figure(figsize = figsize)\n    plt.imshow(image)\n    plt.title(title, size = 16)\n    plt.axis('off')\n    plt.show()","84cd2dfe":"## Checking somethings ...\nidx=10\nprint(inchis[idx])\nprint(data['InChI'][idx])","81519e32":"idx=10\nsample_row = train_sample.iloc[idx]\n\nprint(train['InChI2p'][idx])\nprint('InChI=1S\/'+train['InChI2p'][idx] in inchis) ## Of course our label InChI2p is not in the list!\n\n\nimage_viz2(Myimg[idx], Mysmiles[idx])\n#####\n\nimage_viz(\n        sample_row[\"path\"], sample_row[\"SMILES\"]\n    )","9edc6a1b":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">\n    \ud83d\udccc &nbsp; \n\n## Let's try to begin from something synthetic\n    \n<\/div>","5c8e04de":"# Now let's add SMILEs to our dataset","b6c822c3":"# Directing to Labels","41f45dd9":"# Preparing data","9ce939e5":"1) https:\/\/www.kaggle.com\/ammarali32\/inchi-2-inchikey2-smiles","cc6bb632":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">\n    \ud83d\udccc &nbsp; \n\n## to be continue...\n    \n<\/div>","31d3350f":"# Extracting features","bbf496d2":"# We are prepare to see both: \n\n# 1) Our draws, and \n# 2) SMILES pics. ","94fd9497":"## References","7785542f":"# We can work outside","43d7dcb2":"## Removing the unresolved SMILEs","fbc172b1":"# BMS competition\n\n![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/e\/e7\/L-Ascorbic_acid.svg)\n\nCredit: Wikipedia\n\n<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:110%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n\nIn a technology-forward world, sometimes the best and easiest tools are still pen and paper. Organic chemists frequently draw out molecular work with the Skeletal formula, a structural notation used for centuries. Recent publications are also annotated with machine-readable chemical descriptions (InChI), but there are decades of scanned documents that can't be automatically searched for specific chemical depictions. Automated recognition of optical chemical structures, with the help of machine learning, could speed up research and development efforts.\n\nUnfortunately, most public data sets are too small to support modern machine learning models. Existing tools produce 90% accuracy but only under optimal conditions. Historical sources often have some level of image corruption, which reduces performance to near zero. In these cases, time-consuming, manual work is required to reliably convert scanned chemical structure images into a machine-readable format.\n\nBristol-Myers Squibb is a global biopharmaceutical company working to transform patients' lives through science. Their mission is to discover, develop, and deliver innovative medicines that help patients prevail over serious diseases.\n    \n<\/p>\n<\/div>","9ebf101f":"# MOL extract","4c9f0549":"## The generator","1d6cba13":"<h5 style=\"text-align: center; font-family: Verdana; font-size: 12px; font-style: normal; font-weight: bold; text-decoration: None; text-transform: none; letter-spacing: 1px; color: black; background-color: #ffffff;\">BY: Jos\u00e9 Manuel Ram\u00edrez <\/h5>","493cbe50":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">\n    \ud83d\udccc &nbsp; \n\n# Using CNN techniques\n    \n<\/div>","370d5c04":"## Well, well ... long strings with ~ 40 characters...","035c7ee6":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">\n    \ud83d\udccc &nbsp; \n\n## The model\n    \n<\/div>"}}