{"cell_type":{"03a1bb5f":"code","2ed986c1":"code","ea41f28c":"code","f6b8e9d1":"code","7a800038":"code","56f200ad":"markdown","bbbda57d":"markdown"},"source":{"03a1bb5f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt # For data visualization\nfrom scipy.io import loadmat # For manipulate our data because it is in the type of mat\nimport seaborn as sb\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","2ed986c1":"# Initializing automatically centroids\ndef init_centroids(X, k):\n    \n    m, n = X.shape\n    centroids = np.zeros( (k, n) )\n    random_indices = np.random.randint(0, m, k)\n    \n    for i in range(k):\n        centroids[i, :] = X[ random_indices[i], : ]\n        \n    return centroids\n\n\n# To give me a list of the indices of the closest centroid for each point\ndef find_closest_centroids(X, centroids):\n    \n    m = X.shape[0]\n    k = centroids.shape[0]\n    relate_to = np.zeros(m)\n    \n    for i in range(m):\n        \n        min_dist = float(\"inf\")\n        for j in range(k):\n            \n            cur_dist = np.sum( ( X[i, :] - centroids[j, :] ) ** 2 )\n            if cur_dist < min_dist:\n                \n                min_dist = cur_dist\n                relate_to[i] = j\n                \n    return relate_to\n\n\n\n\n# To Know the new location of the centroids after one displacement\ndef compute_centroids(X, idx, k):\n    \n    m, n = X.shape\n    centroids = np.zeros((k, n))\n    for i in range(k):\n        \n        indices = np.where(idx == i)\n        centroids[i, :] =  ( np.sum(X[indices, :], axis=1) \/ len(indices[0]) ).ravel()\n   \n    return centroids\n\n\n\n# To run the process many times k-means\ndef run_k_means(X, init_centroids, max_iters):\n    \n    m = X.shape[0]\n    centroids = init_centroids\n    idx = np.zeros(m)\n    k = centroids.shape[0]\n    for _ in range(max_iters):\n        \n        idx = find_closest_centroids(X, centroids)\n        centroids = compute_centroids(X, idx, k)\n        \n    return idx, centroids\n","ea41f28c":"path = '..\/input\/ex7data2\/ex7data2.mat'\ndata = loadmat(path)\n\n# This is the Selection Step\nX = data['X']\ninitial_centroids = init_centroids(X, 3) # In this case we choosed  it automatically, but we can choose it manually by choose any indices in X\nidx = find_closest_centroids(X, initial_centroids)\nprint('X : ')\nX[:10, :]","f6b8e9d1":"idx, centroids = run_k_means(X, initial_centroids, 0)\n# draw it\n   \ncluster1 = X[np.where(idx == 0)[0],:]\ncluster2 = X[np.where(idx == 1)[0],:]\ncluster3 = X[np.where(idx == 2)[0],:]\n\nfig, ax = plt.subplots(figsize=(9,6))\n\nax.scatter(cluster1[:,0], cluster1[:,1], s=30, color='k')\nax.scatter(cluster2[:,0], cluster2[:,1], s=30, color='k')\nax.scatter(cluster3[:,0], cluster3[:,1], s=30, color='k')\n\nax.legend()\nax.set_title('The graph with out doing any thing')","7a800038":"for mra in range(6):\n    \n    \n    idx, centroids = run_k_means(X, initial_centroids, mra)\n    # draw it\n   \n    cluster1 = X[np.where(idx == 0)[0],:]\n    cluster2 = X[np.where(idx == 1)[0],:]\n    cluster3 = X[np.where(idx == 2)[0],:]\n\n    fig, ax = plt.subplots(figsize=(9,6))\n    ax.scatter(cluster1[:,0], cluster1[:,1], s=30, color='r', label='Cluster 1')\n    ax.scatter(centroids[0,0],centroids[0,1],s=300, color='r')\n\n    ax.scatter(cluster2[:,0], cluster2[:,1], s=30, color='g', label='Cluster 2')\n    ax.scatter(centroids[1,0],centroids[1,1],s=300, color='g')\n\n    ax.scatter(cluster3[:,0], cluster3[:,1], s=30, color='b', label='Cluster 3')\n    ax.scatter(centroids[2,0],centroids[2,1],s=300, color='b')\n\n    ax.legend()\n    ax.set_title('The graph when doing ' + str(mra) + ' - means')","56f200ad":"> # Functions Cell\n![function-machine-clipart-3.png](attachment:15422abd-8d3e-4c86-9e77-165dc958c29b.png)\n","bbbda57d":">  #                                                    Loading Data and Selection Step\n![R.gif](attachment:84f7883f-b50e-4d18-a49a-6e30b538d25b.gif)"}}