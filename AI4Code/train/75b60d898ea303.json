{"cell_type":{"f369ddbd":"code","d08b3a67":"code","c458704e":"code","1935c7f5":"code","5bb7dd5b":"code","54aafd81":"code","5896061d":"code","88ea98f1":"code","928ec3b3":"code","84d2b9b7":"code","73151a46":"code","bd7e2330":"code","c7d62c32":"code","7e36a7f4":"code","1a9a0ff9":"code","d1da898e":"code","a9e7d65c":"code","082b1dbe":"code","e04ae586":"code","f50d5ed8":"code","78d02439":"code","f5f93a2b":"code","bad0deb9":"code","fdd75e1b":"code","047c824c":"code","0fd8f819":"code","c6fe2e3f":"code","504b9821":"code","dab27503":"code","085ff0b5":"code","2e252b5e":"code","b7555298":"code","d65776e9":"code","75926197":"code","9abc154e":"code","c0314933":"code","99b5db60":"code","5a2f828c":"code","cb1ec937":"code","aaa47f83":"markdown","20a770d8":"markdown","e9ed84fb":"markdown","915dc066":"markdown","5a5f6606":"markdown","ec95779f":"markdown","d3a77915":"markdown","70124bdd":"markdown","018c3a5c":"markdown","32da7ae5":"markdown","dbca3b6f":"markdown","85142c09":"markdown","1eec8487":"markdown","660ce648":"markdown","b82d97bb":"markdown","7fd4f148":"markdown","19a4084f":"markdown","18a7ddb4":"markdown","fd9bde6f":"markdown","1c107b26":"markdown","2b34d415":"markdown","957583e3":"markdown","250ecc2d":"markdown","133c62d6":"markdown","17dbd78e":"markdown","7b07f391":"markdown","5fbe2cbd":"markdown","75823661":"markdown","ac4d6ffe":"markdown","48a72d86":"markdown","e13ceab7":"markdown","1eec4cd1":"markdown"},"source":{"f369ddbd":"from keras.applications.vgg16 import VGG16\nfrom keras.preprocessing.image import load_img\nfrom keras.preprocessing.image import img_to_array\nfrom keras.applications.vgg16 import preprocess_input\nfrom keras.models import Model\nimport os","d08b3a67":"image_dataset_path = '..\/input\/flickr8k-imageswithcaptions\/Flickr8k_Dataset\/Flicker8k_Dataset'\ncaption_dataset_path = '..\/input\/flickr8k-imageswithcaptions\/Flickr8k_text\/Flickr8k.token.txt'","c458704e":"from IPython.display import Image\nImage('..\/input\/flickr8k-imageswithcaptions\/Flickr8k_Dataset\/Flicker8k_Dataset\/1000268201_693b08cb0e.jpg')","1935c7f5":"# load the caption file & read it\ndef load_caption_file(path):\n    \n    # dictionary to store captions\n    captions_dict = {}\n    \n    # iterate through the file\n    for caption in open(path):\n    \n        # caption has format-> 1000268201_693b08cb0e.jpg#0  A child in a pink dress is climbing up a set of stairs in an entry way .\n        tokens = caption.split()\n        caption_id, caption_text = tokens[0].split('.')[0], tokens[1:]\n        caption_text = ' '.join(caption_text)\n        \n        # save it in the captions dictionary\n        if caption_id not in captions_dict:\n            captions_dict[caption_id] = caption_text\n        \n    return captions_dict\n\n# call the function\ncaptions_dict = load_caption_file(caption_dataset_path)","5bb7dd5b":"# clean the captions\nimport string\n\n# dictionary to store the cleaned captions\nnew_captions_dict = {}\n\n# prepare translation table for removing punctuation. third argument is the list of punctuations we want to remove\ntable = str.maketrans('', '', string.punctuation)\n\n# loop through the dictionary\nfor caption_id, caption_text in captions_dict.items():\n    # tokenize the caption_text\n    caption_text = caption_text.split()\n    # convert it into lower case\n    caption_text = [token.lower() for token in caption_text]\n    # remove punctuation from each token\n    caption_text = [token.translate(table) for token in caption_text]\n    # remove all the single letter tokens like 'a', 's'\n    caption_text = [token for token in caption_text if len(token)>1]\n    # store the cleaned captions\n    new_captions_dict[caption_id] = 'startseq ' + ' '.join(caption_text) + ' endseq'\n    ","54aafd81":"# delete unwanted \ndel captions_dict","5896061d":"print('\"' + list(new_captions_dict.keys())[0] + '\"' + ' : ' + new_captions_dict[list(new_captions_dict.keys())[0]])","88ea98f1":"len(new_captions_dict)","928ec3b3":"caption_images_list = []\n\nimage_index = list(new_captions_dict.keys())\n\ncaption_images_list = [ image.split('.')[0] for image in os.listdir(image_dataset_path) if image.split('.')[0] in image_index ]","84d2b9b7":"caption_images_list[0]","73151a46":"len(caption_images_list)","bd7e2330":"train_validate_images = caption_images_list[0:8081]  ","c7d62c32":"test_images = caption_images_list[8081:8091]\ntest_images","7e36a7f4":"# extract features from each photo in the directory\ndef extract_features(directory, image_keys):\n    # load the model\n    model = VGG16()\n    \n    # re-structure the model\n    model = Model(inputs=model.inputs, outputs=model.layers[-2].output)\n    \n    # summarize\n    print(model.summary())\n    \n    # extract features from each photo\n    features = dict()\n    \n    for name in image_keys:\n        \n        # load an image from file\n        filename = directory + '\/' + name + '.jpg'\n        \n        # load the image and convert it into target size of 224*224\n        image = load_img(filename, target_size=(224, 224))\n        \n        # convert the image pixels to a numpy array\n        image = img_to_array(image)\n        \n        # reshape data for the model\n        image = image.reshape((1, image.shape[0], image.shape[1], image.shape[2]))\n        \n        # prepare the image for the VGG model\n        image = preprocess_input(image)\n        \n        # get features\n        feature = model.predict(image, verbose=0)\n        \n        # get image id\n        image_id = name.split('.')[0]\n        \n        # store feature\n        features[image_id] = feature\n        \n#         print('>%s' % name)\n        \n\n    return features","1a9a0ff9":"# extracting image features for train_validate_images\ntrain_validate_features = extract_features(image_dataset_path, train_validate_images)","d1da898e":"print(\"{} : {}\".format(list(train_validate_features.keys())[0], train_validate_features[list(train_validate_features.keys())[0]] ))","a9e7d65c":"len(train_validate_features)","082b1dbe":"from pickle import dump\ndump(train_validate_features, open('.\/train_validate_features.pkl', 'wb'))","e04ae586":"# load libraries\nimport numpy as np\nfrom keras.models import Model, load_model\nfrom keras.layers import Input, Dense, Dropout, LSTM, Embedding\nfrom keras.preprocessing.text import Tokenizer\nfrom keras.preprocessing.sequence import pad_sequences\nfrom keras.utils import to_categorical, plot_model\nfrom keras.layers.merge import add\nfrom keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau","f50d5ed8":"# make a dictionary of image with caption for train_validate_images\ntrain_validate_image_caption = {}\n\nfor image, caption in new_captions_dict.items():\n    \n    # check whether the image is available in both train_validate_images list and train_validate_features dictionary\n    if image in train_validate_images and image in list(train_validate_features.keys()):\n        \n         train_validate_image_caption.update({image : caption})\n\nlen(train_validate_image_caption)","78d02439":"list(train_validate_image_caption.values())[1]","f5f93a2b":"Image(image_dataset_path+'\/'+list(train_validate_image_caption.keys())[1]+'.jpg')","bad0deb9":"# initialise tokenizer\ntokenizer = Tokenizer()\n\n# create word count dictionary on the captions list\ntokenizer.fit_on_texts(list(train_validate_image_caption.values()))\n\n# how many words are there in the vocabulary? store the total length in vocab_len and add 1 because word_index starts with 1 not 0 \nvocab_len = len(tokenizer.word_index) + 1\n\n# store the length of the maximum sentence\nmax_len = max(len(train_validate_image_caption[image].split()) for image in train_validate_image_caption)\n\ndef prepare_data(image_keys):\n    \n    # x1 will store the image feature, x2 will store one sequence and y will store the next sequence\n    x1, x2, y = [], [], []\n\n    # iterate through all the images \n    for image in image_keys:\n\n        # store the caption of that image\n        caption = train_validate_image_caption[image]\n\n        # split the image into tokens\n        caption = caption.split()\n\n        # generate integer sequences of the\n        seq = tokenizer.texts_to_sequences([caption])[0]\n\n        length = len(seq)\n\n        for i in range(1, length):\n\n            x2_seq, y_seq = seq[:i] , seq[i]  \n\n            # pad the sequences\n            x2_seq = pad_sequences([x2_seq], maxlen = max_len)[0]\n\n\n            # encode the output sequence                \n            y_seq = to_categorical([y_seq], num_classes = vocab_len)[0]\n\n            x1.append( train_validate_features[image][0] )\n\n            x2.append(x2_seq)\n\n            y.append(y_seq)\n               \n    return np.array(x1), np.array(x2), np.array(y)","fdd75e1b":"train_x1, train_x2, train_y = prepare_data( train_validate_images[0:7081] )\nvalidate_x1, validate_x2, validate_y = prepare_data( train_validate_images[7081:8081] )","047c824c":"len(train_x1)","0fd8f819":"len(validate_x1)","c6fe2e3f":"# feature extractor model\ninput_1 = Input(shape=(4096,))\ndroplayer = Dropout(0.5)(input_1)\ndenselayer = Dense(256, activation='relu')(droplayer)\n\n# sequence model\ninput_2 = Input(shape=(max_len,))\nembedding = Embedding(vocab_len, 256, mask_zero=True)(input_2)\ndroplayer_ = Dropout(0.5)(embedding)\nlstm = LSTM(256)(droplayer_)\n\n# decoder model\ndecoder1 = add([denselayer, lstm])\ndecoder2 = Dense(256, activation='relu')(decoder1)\noutputs = Dense(vocab_len, activation='softmax')(decoder2)\n\n# tie it together [image, seq] [word]\nmodel = Model(inputs=[input_1, input_2], outputs=outputs)\nmodel.compile(loss='categorical_crossentropy', optimizer='adam')\n\n# summarize model\nprint(model.summary())","504b9821":"plot_model(model, to_file='model.png', show_shapes=True)","dab27503":"# define checkpoint callback\nfilepath = '.\/model-ep{epoch:02d}-loss{loss:.3f}-val_loss{val_loss:.3f}.h5'\n\ncallbacks = [\n             ModelCheckpoint(filepath= filepath, save_best_only=True, monitor='val_loss') ]\n","085ff0b5":"print(\"shape of train_x1 \", train_x1.shape)\nprint(\"shape of train_x2 \", train_x2.shape)\nprint(\"shape of train_y \", train_y.shape)\nprint()\nprint(\"shape of validate_x1 \", validate_x1.shape)\nprint(\"shape of validate_x2 \", validate_x2.shape)\nprint(\"shape of validate_y \", validate_y.shape)","2e252b5e":"# fit model\nhistory = model.fit([train_x1, train_x2],  \n                    train_y,              \n                    verbose = 1,            \n                    epochs = 20,            \n                    callbacks = callbacks, \n                    validation_data=([validate_x1, validate_x2], validate_y)) ","b7555298":"# plot training loss and validation loss\nimport matplotlib.pyplot as plt\n\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epochs')\nplt.legend(['training', 'validation'], loc='upper right')\nplt.show()","d65776e9":"# saving the model with last parameter \nmodel.save('.\/latest_model.h5')","75926197":"# extract features from each photo in the directory\ndef extract_feat(filename):\n    # load the model\n    model = VGG16()\n    # re-structure the model\n    model = Model(inputs=model.inputs, outputs=model.layers[-2].output)\n    # load the photo\n    image = load_img(filename, target_size=(224, 224))\n    # convert the image pixels to a numpy array\n    image = img_to_array(image)\n    # reshape data for the model\n    image = image.reshape((1, image.shape[0], image.shape[1], image.shape[2]))\n    # prepare the image for the VGG model\n    image = preprocess_input(image)\n    # get features\n    feature = model.predict(image, verbose=0)\n    return feature\n\n# map an integer to a word\ndef word_for_id(integer, tokenizr):\n    for word, index in tokenizr.word_index.items():\n        if index == integer:\n            return word\n    return None\n ","9abc154e":"# generate a description for an image\ndef generate_desc(model, tokenizer, photo, max_length):\n    # seed the generation process\n    in_text = 'startseq'\n    # iterate over the whole length of the sequence\n    for i in range(max_length):\n        # integer encode input sequence\n        sequence = tokenizer.texts_to_sequences([in_text])[0]\n        # pad input\n        sequence = pad_sequences([sequence], maxlen=max_length)\n        # predict next word\n        yhat = model.predict([photo,sequence], verbose=0)\n        # convert probability to integer\n        yhat = np.argmax(yhat)\n        # map integer to word\n        word = word_for_id(yhat, tokenizer)\n        # stop if we cannot map the word\n        if word is None:\n            break\n        # append as input for generating the next word\n        in_text += ' ' + word\n        # stop if we predict the end of the sequence\n        if word == 'endseq':\n            break\n    return in_text","c0314933":"from keras.models import load_model\n# load the model\nmodl = load_model('.\/latest_model.h5')\n\n# generate description\ntokenizr = Tokenizer()\ntokenizr.fit_on_texts([caption for image, caption in new_captions_dict.items() if image in train_validate_images])\nmax_length = 34\n\nfor count in range(10):\n\n    photo = extract_feat('{}.jpg'.format(image_dataset_path+'\/'+train_validate_images[count]))  \n\n    # generate description\n    description = generate_desc(modl, tokenizr, photo, max_length)\n    print(\"Predicted caption -> \", description)\n    print()\n    print(\"Actual caption -> \", new_captions_dict[train_validate_images[count]])\n    print('*********************************************************************')\n    print()","99b5db60":"# load the model\nmodl = load_model('.\/latest_model.h5')\n\n# generate description\ntokenizr = Tokenizer()\ntokenizr.fit_on_texts([caption for image, caption in new_captions_dict.items() if image in test_images])\nmax_length = 34\n\nfor count in range(10):\n\n    photo = extract_feat('{}.jpg'.format(image_dataset_path+'\/'+test_images[count]))  \n\n    # generate description\n    description = generate_desc(modl, tokenizr, photo, max_length)\n    print(\"Predicted caption -> \", description)\n    print()\n    print(\"Actual caption -> \", new_captions_dict[test_images[count]])\n    print('*********************************************************************')\n    print()\n","5a2f828c":"# load the model\nmodl = load_model('.\/model-ep03-loss3.859-val_loss4.235.h5')\n\n# generate description\ntokenizr = Tokenizer()\ntokenizr.fit_on_texts([caption for image, caption in new_captions_dict.items() if image in test_images])\nmax_length = 34\n\nfor count in range(10):\n\n    photo = extract_feat('{}.jpg'.format(image_dataset_path+'\/'+test_images[count]))  \n\n    # generate description\n    description = generate_desc(modl, tokenizr, photo, max_length)\n    print(\"Predicted caption -> \", description)\n    print()\n    print(\"Actual caption -> \", new_captions_dict[test_images[count]])\n    print('*********************************************************************')\n    print()","cb1ec937":"# load the model\nmodl = load_model('.\/model-ep03-loss3.859-val_loss4.235.h5')\n\n# generate description\ntokenizr = Tokenizer()\ntokenizr.fit_on_texts([caption for image, caption in new_captions_dict.items() if image in train_validate_images])\nmax_length = 34\n\nfor count in range(10):\n\n    photo = extract_feat('{}.jpg'.format(image_dataset_path+'\/'+train_validate_images[count]))  \n\n    # generate description\n    description = generate_desc(modl, tokenizr, photo, max_length)\n    print(\"Predicted caption -> \", description)\n    print()\n    print(\"Actual caption -> \", new_captions_dict[train_validate_images[count]])\n    print('*********************************************************************')\n    print()","aaa47f83":"This Notebook shows how to make a deep learning Model for generating caption for any given image. The model will have three parts:\n\n**Image Feature Extractor** - 16 layer VGG model which is pretrained on ImageNet dataset. We will remove the outer 2 dense layer from the architecture and will use the feature extractor part of VGG to preprocess our image dataset.\n\n**Caption Processor** - This model will have one embedding layer with LSTM to process our captions text.\n\n**Image_Caption_Combination** - We will prepare the input dictionary to feed to the final model by mapping the image and text.\n\n**Final Model** - This is the final model in which we input the image features extracted by the \"Image Feature Extractor\" and text features extracted by the \"Caption Processor\" and train it to generate captions for any given image.\n\nWe will go step by step in training the model from worst to best. \n","20a770d8":"### taking 7081 images for training, 1000 for validation and rest 10 for testing","e9ed84fb":"## ALERT: Following piece of code takes time ","915dc066":"# Make training, validation and test data","5a5f6606":"### Not bad ","ec95779f":"## Evaluation on the test images with model with val_loss 4.235","d3a77915":"# Training Model - Part 1 ","70124bdd":"## Model architecture","018c3a5c":"# Image Feature Extractor","32da7ae5":"## Preparing the input data","dbca3b6f":"### make sure the correct caption is mapped with the correct image","85142c09":"# Preprocess the captions","1eec8487":"Latest model has training loss 2.38 and validation loss as 6.04, i.e. it has overfitted so we can expect that it will perform better on the training images than the test images","660ce648":"## Evaluation on the training images with model with validation loss 4.23","b82d97bb":"## Make a list of only those images who has caption","7fd4f148":"\n\n1) Convert the captions into lowercase\n\n2) Tokenize the captions into different tokens\n\n3) Remove all the punctuations from the tokens\n\n4) add \"start_index\" and \"end_index\" as pointers to tell the model start of the caption and end of the caption","19a4084f":"## Reducing Overfitting","18a7ddb4":"# Data Preparation","fd9bde6f":"## Plot the model architecture","1c107b26":"## Train the model using training data and validation data","2b34d415":"# Final Model","957583e3":"## Evaluating model on training images using the latest model","250ecc2d":"Each caption will be split into words. The model will be provided one word and the photo and generate the next word. Then the first two words of the description will be provided to the model as input with the image to generate the next word. This is how the model will be trained. So we will have two features, x1 (image) , x2 (text_sequence) and one target variable, y (generated_word).\n\nImage,\t\t   text sequence, \t\t\t\t\t\tgenerated_word\n\nphoto\t         startseq, \t\t\t\t\t\t\t\t\tlittle\n\nphoto\t       startseq, little,\t\t\t\t\t\t\tgirl\n\nphoto\t       startseq, little, girl, \t\t\t\t\trunning\n\nphoto\t       startseq, little, girl, running, \t\t\tin\n\nphoto\t       startseq, little, girl, running, in, \t\tfield\n\nphoto\t       startseq, little, girl, running, in, field, endseq","133c62d6":"### Make sure feature data and target data share the same first dimension","17dbd78e":"# Evaluate the model  - Part 1","7b07f391":"But still model has performed very bad, lets tune model to perform better","5fbe2cbd":"### Very Bad ...as expected","75823661":"## Evaluating model on test images using the latest model","ac4d6ffe":"**extract_features** function extracts the important features out of the images passed using VGG16 model.","48a72d86":"# Caption Processor","e13ceab7":"### Very poor","1eec4cd1":"# Introduction"}}