{"cell_type":{"05d00e08":"code","6b82dc7a":"code","26468503":"code","9bda0a23":"code","eacd1e15":"code","60b5025c":"code","e7448361":"code","fca6cc53":"code","e206292a":"code","963b763b":"code","a0d99193":"code","1ee53d4f":"code","8e928e8d":"code","c5fc6ace":"code","b816e138":"code","0142e13f":"code","ad447766":"code","09b3f2fa":"code","3fa63fbf":"code","8f2e0756":"markdown","fb3d55b7":"markdown"},"source":{"05d00e08":"import numpy as np\nimport pandas as pd \nimport seaborn as sns\nimport plotly.express as px\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport matplotlib as mpl\nfrom scipy import stats\nimport statsmodels.api as sm\nfrom itertools import product\nfrom datetime import datetime\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","6b82dc7a":"# Setting environment to ignore future warnings\nimport warnings\nwarnings.simplefilter('ignore')","26468503":"df = pd.read_csv(\"\/kaggle\/input\/all-crypto-currencies\/crypto-markets.csv\", parse_dates=[\"date\"], index_col=\"date\")\ndf = df[df.symbol==\"BTC\"]\ndf.tail()","9bda0a23":"# Dropping unnecessary columns\ndf = df.drop([\"slug\", \"symbol\", \"name\", \"ranknow\", \"close_ratio\", \"spread\"], axis=1)\ndf.head()","eacd1e15":"#I will be adding a feature to improve the model.\ndf['weighted_price'] = (df['open'] + df['high'] + df['low'] + df['close']) \/ 4\ndf.head()","60b5025c":"# Resampling to daily frequency\ndf = df.resample('D').mean()\n\n# Resampling to monthly frequency\ndf_month = df.resample('M').mean()\n\n# Resampling to annual frequency\ndf_year = df.resample('A-DEC').mean()\n\n# Resampling to quarterly frequency\ndf_Q = df.resample('Q-DEC').mean()","e7448361":"#Now we will be using timestamp converted to months for our analysis out of all the above conversion\ndf_month.head()","fca6cc53":"\n# PLOTS the timestamped data, in various different forms - days, months, quaters, yearly\nfig = plt.figure(figsize=[15, 7])\nplt.suptitle('Bitcoin exchanges, mean USD', fontsize=22)\n\nplt.subplot(221)\nplt.plot(df.weighted_price, '-', label='By Days')\nplt.legend()\n\nplt.subplot(222)\nplt.plot(df_month.weighted_price, '-', label='By Months')\nplt.legend()\n\nplt.subplot(223)\nplt.plot(df_Q.weighted_price, '-', label='By Quarters')\nplt.legend()\n\nplt.subplot(224)\nplt.plot(df_year.weighted_price, '-', label='By Years')\nplt.legend()\n\n# plt.tight_layout()\nplt.show()","e206292a":"# splitting dataset in 2\/3 for training and 1\/3 for testing purpose\n\nsplit = 50\ndf_train = df_month[:split]\ndf_test = df_month[split:len(df_month)]","963b763b":"def test_stationary(data, window=12):\n    data_mean = data.rolling(window=window).mean()\n    data_std = data.rolling(window=window).std()\n    \n    # Rolling Statistics Method to check Stationarity\n    print(\"Result by Rolling Method\")\n    plt.figure(figsize=(16,8))\n    plt.plot(data, color=\"blue\", label=\"Original Data\")\n    plt.plot(data_mean, color=\"red\", label=\"Rolling Mean\")\n    plt.plot(data_std, color=\"black\", label=\"Rolling Standard Deviation\")\n    plt.title(\"Rolling Mean & Standard Deviation\")\n    plt.legend(loc=\"best\")\n    plt.show()\n    \n    # AdFuller test to check Stationarity\n    print(\"\\n\\n\\n\", \"AdFuller Test Results\\n\")\n    from statsmodels.tsa.stattools import adfuller\n    res = adfuller(data)\n    print(\"\\tStatistics ADF : \", res[0])\n    print(\"\\tP-Value        : \", res[1])\n    print(\"\\n\\n\\n\")","a0d99193":"temp = df[\"weighted_price\"]\ntest_stationary(temp)","1ee53d4f":"# Now we are performing Box-Cox transform and then check whether the dataset has become stationary or not\n\n# Box-Cox Transformations \n\ndf_train['Weighted_Price_box'], lmbda = stats.boxcox(df_train.weighted_price)\n\n# Stationary Check again the value is more than 0.05\n\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_train.weighted_price)[1])","8e928e8d":"#Now we are performing Seasonal\n\n#Seasonal differentiation\n\ndf_train['prices_box_diff'] = df_train.Weighted_Price_box - df_train.Weighted_Price_box.shift(12)\n\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_train.prices_box_diff[12:])[1])","c5fc6ace":"# Regular differentiation\n\ndf_train['prices_box_diff2'] = df_train.prices_box_diff - df_train.prices_box_diff.shift(1)\n\n\n# STL-decomposition\nplt.figure(figsize=(15,7))\nsm.tsa.seasonal_decompose(df_train.prices_box_diff2[13:]).plot()   \nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_train.prices_box_diff2[13:])[1])\n\nplt.show()","b816e138":"# Initial approximation of parameters\n\nQs = range(0, 2)\nqs = range(0, 3)\nPs = range(0, 3)\nps = range(0, 3)\nD=1\nd=1\nparameters = product(ps, qs, Ps, Qs)\nparameters_list = list(parameters)\n# print(parameters_list)\nlen(parameters_list)\n\n# Model Selection\nresults = []\nbest_aic = float(\"inf\")\nwarnings.filterwarnings('ignore')\nfor param in parameters_list:\n    try:\n        model=sm.tsa.statespace.SARIMAX(df_train.Weighted_Price_box, order=(param[0], d, param[1]), \n                                        seasonal_order=(param[2], D, param[3], 12)).fit(disp=-1)\n    except ValueError:\n        continue\n    aic = model.aic\n    # print(aic)\n    if aic < best_aic:\n        best_model = model\n        best_aic = aic\n        best_param = param\n    results.append([param, model.aic])","0142e13f":"# Best Models\n\nresult_table = pd.DataFrame(results)\nresult_table.columns = ['parameters', 'aic']\nprint(result_table.sort_values(by = 'aic', ascending=True).head())\n\nprint(best_model.summary())","ad447766":"# STL-decomposition\n\nfrom pandas import Series\nfrom matplotlib import pyplot\n\nplt.figure(figsize=(15,7))\nplt.subplot(211)\nbest_model.resid[13:].plot()\nplt.ylabel(u'Residuals')\n\nprint(\"Dickey\u2013Fuller test:: p=%f\" % sm.tsa.stattools.adfuller(best_model.resid[13:])[1])\n\npyplot.show()","09b3f2fa":"\n#Prediction \n\n# Inverse Box-Cox Transformation Function\ndef invboxcox(y,lmbda):\n   if lmbda == 0:\n      return(np.exp(y))\n   else:\n      return(np.exp(np.log(lmbda*y+1)\/lmbda))","3fa63fbf":"df_month2 = df_month[['weighted_price']]\n\ndf_month2['forecast'] = invboxcox(best_model.predict(start=0, end=100), lmbda)\n\nplt.figure(figsize=(15,7))\ndf_month2.weighted_price.plot()\ndf_month2.forecast.plot(color='r', ls='--', label='Predicted Weighted_Price')\nplt.legend()\nplt.title('Bitcoin exchanges, by months')\nplt.ylabel('mean USD')\nplt.show()","8f2e0756":"## Extracting Usefull Data","fb3d55b7":"P-value is greater than 0.05 so data is not stationarity"}}