{"cell_type":{"fae96e8a":"code","7ad5efb2":"code","15ea1b97":"code","cd2fa81c":"code","6a59e57a":"code","f9d424ab":"code","2cd86871":"code","44f16af1":"code","4f59f9d6":"code","01456b38":"code","b0e5bc33":"code","8bf3cd17":"code","8a4ddeed":"code","311d5cc6":"code","6d32fa6f":"code","0e743dde":"code","3fb2ef78":"code","becb3e58":"code","08b39ba9":"code","a6b40504":"code","c0c3eae9":"code","b7283da4":"code","b8b8ba7f":"code","e6088cb6":"code","14609017":"code","de6b12e5":"code","e3e1765f":"code","27b06223":"markdown","46668868":"markdown","2d80079e":"markdown","506cadda":"markdown","0e453085":"markdown","be7d941d":"markdown","ce983b9d":"markdown","c248b8f3":"markdown","71091652":"markdown","eddf6b68":"markdown","a9e132c3":"markdown","f9685ff3":"markdown","43974550":"markdown","743489f4":"markdown","2ba85de5":"markdown","17fc0721":"markdown","0b07e3a8":"markdown","8b696539":"markdown","f613b66d":"markdown","356c4325":"markdown","c0914326":"markdown","8399e25e":"markdown","9a260cb7":"markdown","50d0d06d":"markdown","2d502d66":"markdown","810c4117":"markdown","7995676f":"markdown","de5fdee0":"markdown"},"source":{"fae96e8a":"from csv import reader\n\n# Google Play\nopened_file = open('..\/input\/google-play-store-apps\/googleplaystore.csv')\nread_file = reader(opened_file)\nandroid = list(read_file)\nandroid_header = android[0]\nandroid = android[1:]\n\n# App Store\nopened_file = open('..\/input\/app-store-apple-data-set-10k-apps\/AppleStore.csv')\nread_file = reader(opened_file)\nios = list(read_file)\nios_header = ios[0]\nios = ios[1:]","7ad5efb2":"def explore_data(dataset, start, end, rows_and_columns=False):\n    dataset_slice = dataset[start:end]    \n    for row in dataset_slice:\n        print(row)\n        print('\\n') # adds a new (empty) line between rows\n        \n    if rows_and_columns:\n        print('Number of rows:', len(dataset))\n        print('Number of columns:', len(dataset[0]))","15ea1b97":"print(android_header)\nprint('\\n')\nexplore_data(android, 0, 3, True)","cd2fa81c":"del(ios_header[0])\nprint(ios_header)\nprint('\\n')\nexplore_data(ios, 0, 3, True)","6a59e57a":"print(android[10472])\nprint(android_header)","f9d424ab":"del android[10472]\nprint(len(android))","2cd86871":"for app in ios:\n    del(app[0])\nexplore_data(ios, 0, 3, True)","44f16af1":"for app in android:\n    name = app[0]\n    if name == 'Instagram':\n        print(app)","4f59f9d6":"duplicates = []\nunique = []\n\nfor app in android:\n    name = app[0]\n    if name in unique:\n        duplicates.append(name)\n    else:\n        unique.append(name)\nprint('Number of duplicates: ', len(duplicates))\nprint('\\n')\nprint('Examples of duplicates: ', duplicates[:10])","01456b38":"max_reviews = {}\n\nfor app in android:\n    name = app[0]\n    n_reviews = float(app[3])\n    \n    if name in max_reviews and max_reviews[name] < n_reviews:\n        max_reviews[name] = n_reviews\n    elif name not in max_reviews:\n        max_reviews[name] = n_reviews","b0e5bc33":"print('Expected length: ', len(android) - 1181)\nprint('Actual length: ', len(max_reviews))","8bf3cd17":"android_clean = []\nalready_added = []\n\nfor app in android:\n    name = app[0]\n    n_reviews = float(app[3])\n    if (n_reviews == max_reviews[name]) and (name not in already_added):\n        android_clean.append(app)\n        already_added.append(name)","8a4ddeed":"explore_data(android_clean, 0, 3, True)","311d5cc6":"def check_english(str):\n    for char in str:\n        if ord(char) > 127:\n            return False\n    return True\n\nprint(check_english('Instagram'))\nprint(check_english('\u7231\u5947\u827aPPS -\u300a\u6b22\u4e50\u98822\u300b\u7535\u89c6\u5267\u70ed\u64ad'))\n    ","6d32fa6f":"def check_english(str):\n    special_chars = 0\n    for char in str:\n        if ord(char) > 127:\n            special_chars += 1\n    if special_chars > 3:\n        return False\n    else:\n        return True\n\nprint(check_english('Docs To Go\u2122 Free Office Suite'))\nprint(check_english('Instachat \ud83d\ude1c'))","0e743dde":"android_english = []\nios_english = []\n\nfor app in android_clean:\n    name = app[0]\n    if check_english(name):\n        android_english.append(app)\nfor app in ios:\n    name = app[1]\n    if check_english(name):\n        ios_english.append(app)\n\nexplore_data(android_english, 0, 3, True)\nprint('\\n')\nexplore_data(ios_english, 0, 3, True)","3fb2ef78":"android_final = []\nios_final = []\n\nfor app in android_english:\n    price = app[7]\n    if price == '0':\n        android_final.append(app)\nfor app in ios_english:\n    price = app[4]\n    if price == '0':\n        ios_final.append(app)\n      \nexplore_data(android_final, 0, 3, True)\nprint('\\n')\nexplore_data(ios_final, 0, 3, True)","becb3e58":"def freq_table(dataset, index):\n    table = {}\n    total = 0\n    \n    for row in dataset:\n        total += 1\n        value = row[index]\n        if value in table:\n            table[value] += 1\n        else:\n            table[value] = 1\n    table_percentage = {}\n    for key in table:\n        percent = (table[key] \/ total) * 100\n        table_percentage[key] = percent\n    return table_percentage\n\ndef display_table(dataset, index):\n    table = freq_table(dataset, index)\n    table_display = []\n    for key in table:\n        key_val_as_tuple = (table[key], key)\n        table_display.append(key_val_as_tuple)\n    table_sorted = sorted(table_display, reverse = True)\n    for entry in table_sorted:\n        print(entry[1], ':', entry[0])\n\nprint(display_table(ios_final, 11))","08b39ba9":"print(display_table(android_final, 1)) #Category","a6b40504":"print(display_table(android_final, 9)) #Category","c0c3eae9":"ios_genres = freq_table(ios_final, 11)\n\nfor genre in ios_genres:\n    total = 0\n    len_genre = 0\n    \n    for app in ios_final:\n        genre_app = app[11]\n        if genre_app == genre:\n            total += float(app[5])\n            len_genre += 1\n    avg_rating = total \/ len_genre\n    print(genre, ':', avg_rating)","b7283da4":"for app in ios_final:\n    if app[11] == 'Navigation':\n        print(app[1], ':', app[5])","b8b8ba7f":"for app in ios_final:\n    if app[11] == 'Reference':\n        print(app[1], ':', app[5])","e6088cb6":"for app in ios_final:\n    if app[11] == 'Productivity':\n        print(app[1], ':', app[5])","14609017":"display_table(android_final, 5) #installs column","de6b12e5":"android_categories = freq_table(android_final, 1)\n\nfor category in android_categories:\n    total = 0\n    len_category = 0\n    for app in android_final:\n        category_app = app[1]\n        if category_app == category:\n            n_installs = app[5]\n            n_installs = n_installs.replace(',', '')\n            n_installs = n_installs.replace('+', '')\n            total += float(n_installs)\n            len_category += 1\n    avg_n_installs = total \/ len_category\n    print(category, ':', avg_n_installs)","e3e1765f":"for app in android_final:\n    if app[1] == 'PRODUCTIVITY' and (app[5] == '1,000,000,000+'\n                                            or app[5] == '500,000,000+'\n                                            or app[5] == '100,000,000+'\n                                            or app[5] == '1,000,000+'\n                                            or app[5] == '5,000,000+'\n                                            or app[5] == '10,000,000+'\n                                            or app[5] == '50,000,000+'):\n        print(app[0], ':', app[5])","27b06223":"The Google Play data set has 10,841 rows and 13 columns. Browsing the column names, the ones that appear to be most useful for our analysis are ```App```, ```Category```, ```Reviews```, ```Installs```, ```Type```, ```Price```, and ```Genres```\n\nLet's examine the App Store data set:","46668868":"Below we will use the ```check_english()``` function to filter out non-English apps for both Google and iOS data sets:","2d80079e":"There are 8,864 Android apps and 3,222 iOS apps left to analyze. These are the cleaned data sets consisting of non-duplicate, English developed, and free apps","506cadda":"Our goal is to find popular app genres but some of these apps may seem more poular than they are. Many categories such as Navigation, Social Networking, and Music are dominated by a few highly influential apps (Facebook, Twitter, Spotify etc.). \n\nReference apps have 74,942 ratings. A majority of these are coming from 2 large apps, the Bible and Dictionary.com","0e453085":"## Removing Non-English Apps\n\nWe'd like to only analyze apps developed for English speaking audiences. Both the data sets contain apps developed for non-English speaking audiences. We should remove the apps that contain non-English titles. The best way to do this is to look for any non-English characters in the app name and compare that to the ASCII system. Any character greater than an ASCII value of 127 should reveal that the app name has a non-English title.\n\nWe can use the built in Python function ```ord()``` to get the corresponding encoded value for a character in a string. We will loop through each title and check the ASCII value of each character. ","be7d941d":"The ```Genres``` column is much more granular than the ```Category``` column. We don't need the granular genres for our analysis right now so we will stick with using ```Category``` going forward. The Apple Store is dominated by apps designed for fun and games, while the Google Play store has a blend of for-fun and practical apps. Next in our analysis will be to determine which tpyes of apps have the most users.\n\n## Most Popular Apps by Genre\n\nThe easiest way to determine popularity of an app is to calculate the average number of installs per category. We can use the ```Installs``` column for the Google Play data but unfortunately iOS does not have a similar column. We can use the number of user ratings as a proxy. This number can be found in the ```rating_count_tot``` column.\n\nBelow I'll calculate the average number of user ratings \/ installs per app on the App Store:","ce983b9d":"There are actually 1,181 duplicate apps in the data set:","c248b8f3":"Practical applications appear to be better represented in the Google Play store. We can confirm this further by examing the frequency table for the ```Genres``` column","71091652":"## Common Apps by Genre\nMy aim is to find the apps that attract the most amount of users. Free apps that have in-app advertisements are dependent upon amount of users to be profitable. My validation strategy for an app idea will have 3 steps:\n1. Build a minimal Android version of the app, and add it to Google Play.\n2. If the app has a good response from users, we then develop it further.\n3. If the app is profitable after six months, we also build an iOS version of the app and add it to the App Store.\n\nWe need to find apps that are successful in both Android and Apple markets. I'll begin the analysis by generating a frequency table for the ```prime_genre``` column in the iOS data and ```Genres``` and ```Category``` columns of the Google Play data.\n\nI'll build 2 functions:\n* One to generate frequency tables that show percentages\n* One to display the tables in desc order","eddf6b68":"Previously we found that there are 1,181 duplicate rows. The length of the ```max_reviews``` dictionary should be equal to the data set minus 1,181","a9e132c3":"## Duplicate Entries\n\nSome apps in the Google Play data set have more than one entry. For example, if we search for Instagram there are 4 rows for a single app:","f9685ff3":"Some apps in the data set are English but have non-English characters in them such as emoji's and specialized characters. To minimize data loss, we will only remove the app from the data set if it contains 3 or more non-English ASCII characters","43974550":"Examing the duplicate entries for Instagram above shows us the main difference between the entries is in the 4th column which is the number of reviews. Rather than remove entries at random, we'll keep the row with the highest number of reviews as that row will give us the more reliable data.\n\nTo achieve this we will create a dictionary consisting of the app name and the max reviews of that app.","743489f4":"In the iOS data set, the first column is the index for the row. This is not useful to our analysis. I will remove the index column from the data set:","2ba85de5":"To perform calculations, we will need to transform the installs column for each row into a float data type. Doing so will require removing commas and the '+' characters. We'll calculate the install averages in the same for loop:","17fc0721":"There is no category for row 10,472. We will delete this row and then print the length of the data set to cofirm that the row is gone. This command should only be run once","0b07e3a8":"Navigation has the highest number of reviews, but that figure is being skewed by a few large apps like Google Maps and Waze:","8b696539":"# Free App Profiles on Google Play and App Store\nMy goal in this project is to analyze apps that are free but also profitable from in-app advertisements. This analyzation consists of app data from both the Google Play and Apple App Store markets.\n\nFree app revenue is determined by the number of active users of that app. I want to analyze the data and determine what type of apps are profitable to help developers understand the apps categories that are likely to attract the most users. \n\n## The Data\nAs of 2018 there were 2 million iOS apps on the App Store and 2.1 million on the Google Play Store. To avoid the time and cost of collecting data on 4 million+ apps, we will use sample data from 2 separate data sets:\n\n* A [data set](https:\/\/www.kaggle.com\/lava18\/google-play-store-apps) containing data about approximately ten thousand Android apps from Google Play.\n* A [data set](https:\/\/www.kaggle.com\/ramamet4\/app-store-apple-data-set-10k-apps) containing data about approximately seven thousand iOS apps from the App Store.\n\nI will start by opening the 2 data sets to prepare for exploration:","f613b66d":"There are 7,197 iOS apps in this data set. The column names that seem useful for analysis are ```track_name```, ```currency```, ```price```, ```rating_count_tot```, ```rating_count_ver```, and ```prime_genre```.","356c4325":"## Isolating Free Apps\n\nOur goal with this analysis is to identify the trends related to free apps that have in-app adds. We need to remove any apps in the data sets that have a cost to download:","c0914326":"## Conclusion\nThe productivity genre appears to be a promising market as this category has high install numbers in both the Google Play and iOS ecosystems.\n\nThe market is quite saturated, so the app would need to have distinguishing features that set it apart. Some type of notetaking, calendar manager, or file manager application would yield promising numbers based on this analysis.","8399e25e":"I'll write a function to explore the 2 data sets to be used further on in our analysis","9a260cb7":"We can now use the max_reviews dictionary to remove the duplicate rows throughout the data set. We'll only keep the entries that contain the highest number of reviews.\n* Create 2 lists, ```android_clean``` and ```already_added```\n* Loop through the app rows\n* For each row, assign the variable 'name' to the name of the app\n* Convert the number of reviews to a float and assign to n_reviews\n* If n_reviews equals the same amount as the ```max_reviews``` and ```name``` is not alreay in the ```already_added``` list, append the row to ```android_clean```\n* Append the app name to already_added to keep track of the already added apps","50d0d06d":"The Books and Reference category is quite popular as well in the Google Play Store. If you recall, the Reference genre had a high number of reviews\/installs in the iOS data set as well.","2d502d66":"We will quickly explore our ```android_clean``` list to confirm the number of rows is 9,569","810c4117":"Let's review the number of installs by category on the Google Play Store. One thing to note about how this data set calculates install numbers is they are not exact, rather it is a tiered structure. See below:","7995676f":"Of the free English apps in the iOS data, more than 58% are ```Games```. The next closest genre is ```Entertainment``` with close to 8%, followed by ```Photo & Video``` with almost 5%. \n\nThe App Store is dominated by apps developed for fun, not as many for practical use. But just because these apps have the highest frequencies does not imply that they have as many users. \n\nWe'll continue our analysis with the Google Play data set:","de5fdee0":"## Data Cleaning\n\nThe data set for the Google Play apps has a discussion session. A user posted that there is a missing entry for 'Category' on row 10,472. We will print that row below to see if the user is correct."}}