{"cell_type":{"4c7a3ffd":"code","864d200e":"code","593e3e23":"code","174871b6":"code","4d0c1071":"code","fc3f7a7d":"code","b02b57de":"code","efbf95e2":"code","65cf04d4":"markdown","3165657d":"markdown","014437f3":"markdown","eb0cd016":"markdown"},"source":{"4c7a3ffd":"from abc import ABCMeta, abstractmethod, abstractproperty\nimport enum\n\nimport numpy as np\nnp.set_printoptions(precision=3)\nnp.set_printoptions(suppress=True)\n\nimport pandas\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline","864d200e":"class BernoulliBandit:\n    def __init__(self, n_actions=5):\n        self._probs = np.random.random(n_actions)\n        \n    @property\n    def action_count(self):\n        return len(self._probs)\n    \n    def pull(self, action):\n        if np.any(np.random.random() > self._probs[action]):\n            return 0.0\n        return 1.0\n    \n    def optimal_reward(self):\n        \"\"\" Used for regret calculation\n        \"\"\"\n        return np.max(self._probs)\n    \n    def step(self):\n        \"\"\" Used in nonstationary version\n        \"\"\"\n        pass\n    \n    def reset(self):\n        \"\"\" Used in nonstationary version\n        \"\"\"","593e3e23":"class AbstractAgent(metaclass=ABCMeta):   \n    def init_actions(self, n_actions):\n        self._successes = np.zeros(n_actions)\n        self._failures = np.zeros(n_actions)\n        self._total_pulls = 0\n    \n    @abstractmethod\n    def get_action(self):\n        \"\"\"\n        Get current best action\n        :rtype: int\n        \"\"\"\n        pass\n    \n    def update(self, action, reward):\n        \"\"\"\n        Observe reward from action and update agent's internal parameters\n        :type action: int\n        :type reward: int\n        \"\"\"\n        self._total_pulls += 1\n        if reward == 1:\n            self._successes[action] += 1\n        else:\n            self._failures[action] += 1\n    \n    @property\n    def name(self):\n        return self.__class__.__name__\n\n\nclass RandomAgent(AbstractAgent):    \n    def get_action(self):\n        return np.random.randint(0, len(self._successes))","174871b6":"class EpsilonGreedyAgent(AbstractAgent):\n    def __init__(self, epsilon = 0.01):\n        self._epsilon = epsilon\n    def get_action(self):\n        return np.random.randint(len(self._successes)) if np.random.random() < self._epsilon else np.argmax(self._successes\/(self._successes+self._failures))\n    @property\n    def name(self):\n        return self.__class__.__name__ + \"(epsilon={})\".format(self._epsilon)","4d0c1071":"import math\nclass UCBAgent(AbstractAgent):\n    def get_action(self):\n        n_actions = self._successes+self._failures\n        ucb = np.sqrt(2*np.log10(self._total_pulls)\/n_actions)\n        p = self._successes\/(n_actions) + ucb\n        \n        return np.argmax(p)\n    @property\n    def name(self):\n        return self.__class__.__name__","fc3f7a7d":"class ThompsonSamplingAgent(AbstractAgent):\n    def get_action(self):\n        theta = np.array([np.random.beta(self._successes[i], self._failures[i]) if self._successes[i]!=0 and self._failures[i]!=0 else np.random.random() for i in range(len(self._successes))])\n        return np.argmax(theta)\n    @property\n    def name(self):\n        return self.__class__.__name__","b02b57de":"from collections import OrderedDict\n\ndef get_regret(env, agents, n_steps=5000, n_trials=50):\n    scores = OrderedDict({\n        agent.name: [0.0 for step in range(n_steps)] for agent in agents\n    })\n\n    for trial in range(n_trials):\n        env.reset()\n\n        for a in agents:\n            a.init_actions(env.action_count)\n\n        for i in range(n_steps):\n            optimal_reward = env.optimal_reward()\n\n            for agent in agents:\n                action = agent.get_action()\n                reward = env.pull(action)\n                agent.update(action, reward)\n                scores[agent.name][i] += optimal_reward - reward\n\n            env.step()  # change bandit's state if it is unstationary\n\n    for agent in agents:\n        scores[agent.name] = np.cumsum(scores[agent.name]) \/ n_trials\n\n    return scores\n\ndef plot_regret(agents, scores):\n    for agent in agents:\n        plt.plot(scores[agent.name])\n\n    plt.legend([agent.name for agent in agents])\n\n    plt.ylabel(\"regret\")\n    plt.xlabel(\"steps\")\n\n    plt.show()","efbf95e2":"# Uncomment agents\nagents = [\n    EpsilonGreedyAgent(),\n    UCBAgent(),\n    ThompsonSamplingAgent()\n]\n\nregret = get_regret(BernoulliBandit(), agents, n_steps=10000, n_trials=10)\nplot_regret(agents, regret)","65cf04d4":"### Thompson sampling\n\nUCB1 algorithm does not take into account actual distribution of rewards. If we know the distribution - we can do much better by using Thompson sampling:\n\n> **for** $t = 1,2,...$ **do**\n>> **for** $k = 1,...,K$ **do**\n>>> Sample $\\hat\\theta_k \\sim beta(\\alpha_k, \\beta_k)$\n\n>> **end for** \n\n>> $x_t \\leftarrow argmax_{k}\\hat\\theta$\n\n>> Apply $x_t$ and observe $r_t$\n\n>> $(\\alpha_{x_t}, \\beta_{x_t}) \\leftarrow (\\alpha_{x_t}, \\beta_{x_t}) + (r_t, 1-r_t)$\n\n> **end for**\n \n\nMore on Tompson Sampling:\nhttps:\/\/web.stanford.edu\/~bvr\/pubs\/TS_Tutorial.pdf","3165657d":"### UCB Agent\nEpsilon-greedy strategy heve no preference for actions. It would be better to select among actions that are uncertain or have potential to be optimal. One can come up with idea of index for each action that represents otimality and uncertainty at the same time. One efficient way to do it is to use UCB1 algorithm:\n\n> **for** $t = 1,2,...$ **do**\n>> **for** $k = 1,...,K$ **do**\n>>> $w_k \\leftarrow \\alpha_k \/ (\\alpha_k + \\beta_k) + \\sqrt{2log\\ t \\ \/ \\ (\\alpha_k + \\beta_k)}$\n\n>> **end for** \n\n>> $x_t \\leftarrow argmax_{k}w$\n\n>> Apply $x_t$ and observe $r_t$\n\n>> $(\\alpha_{x_t}, \\beta_{x_t}) \\leftarrow (\\alpha_{x_t}, \\beta_{x_t}) + (r_t, 1-r_t)$\n\n> **end for**\n\n\n__Note:__ in practice, one can multiply $\\sqrt{2log\\ t \\ \/ \\ (\\alpha_k + \\beta_k)}$ by some tunable parameter to regulate agent's optimism and wilingness to abandon non-promising actions.\n\nMore versions and optimality analysis - https:\/\/homes.di.unimi.it\/~cesabian\/Pubblicazioni\/ml-02.pdf","014437f3":"## Bernoulli Bandit\n\nWe are going to implement several exploration strategies for simplest problem - bernoulli bandit.\n\nThe bandit has $K$ actions. Action produce 1.0 reward $r$ with probability $0 \\le \\theta_k \\le 1$ which is unknown to agent, but fixed over time. Agent's objective is to minimize regret over fixed number $T$ of action selections:\n\n$$\\rho = T\\theta^* - \\sum_{t=1}^T r_t$$\n\nWhere $\\theta^* = \\max_k\\{\\theta_k\\}$\n\n**Real-world analogy:**\n\nClinical trials - we have $K$ pills and $T$ ill patient. After taking pill, patient is cured with probability $\\theta_k$. Task is to find most efficient pill.\n\nA research on clinical trials - https:\/\/arxiv.org\/pdf\/1507.08025.pdf","eb0cd016":"### Epsilon-greedy agent\n\n> **for** $t = 1,2,...$ **do**\n>> **for** $k = 1,...,K$ **do**\n>>> $\\hat\\theta_k \\leftarrow \\alpha_k \/ (\\alpha_k + \\beta_k)$\n\n>> **end for** \n\n>> $x_t \\leftarrow argmax_{k}\\hat\\theta$ with probability $1 - \\epsilon$ or random action with probability $\\epsilon$\n\n>> Apply $x_t$ and observe $r_t$\n\n>> $(\\alpha_{x_t}, \\beta_{x_t}) \\leftarrow (\\alpha_{x_t}, \\beta_{x_t}) + (r_t, 1-r_t)$\n\n> **end for**\n\nImplement the algorithm above in the cell below:"}}