{"cell_type":{"f47fc902":"code","f9001b02":"code","aefce95b":"code","fb4fc9b7":"code","99571816":"code","490049ce":"code","dafddbdc":"code","a2c4dfab":"code","b5060dfa":"code","fceb18b6":"code","a08b681f":"code","d4e5e087":"code","16b577ab":"code","c70d5bcb":"code","78fad0a6":"code","7210f66e":"code","1819e548":"code","73199e11":"code","b66e610c":"code","66ef16ba":"code","af5bcb43":"code","e328807f":"code","b8d970e3":"markdown","e17c86a6":"markdown","d08eac88":"markdown","9e999e06":"markdown","5937e6ad":"markdown","718dc0cb":"markdown","8af13bad":"markdown","62885129":"markdown","fbfa592e":"markdown","506b6c6f":"markdown","dca1bb0e":"markdown","6ef586b6":"markdown"},"source":{"f47fc902":"#!pip install ast\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom ast import literal_eval ","f9001b02":"#reading the main file\nmovies=pd.read_csv('\/kaggle\/input\/the-movies-dataset\/movies_metadata.csv',low_memory=False)\n\n# taking a look at on line in the data set\nmovies.iloc[4]\n","aefce95b":"#size of the data set\ndim = movies.shape\nprint(f\"The main movie dataset has {dim[0]} rows and {dim[1]} columns \")\n","fb4fc9b7":"#Let's list all columns name of our data sets\ncolumns =movies.columns.values\nprint(f\"Here is the list of all columns: \\n {columns} \")","99571816":"movies=movies.drop(['poster_path','production_companies','spoken_languages','belongs_to_collection','homepage','production_countries','status','original_title'], axis=1)","490049ce":"movies.dtypes","dafddbdc":"original_memory=movies.memory_usage(deep=True)\nmovies.memory_usage(deep=True)","a2c4dfab":"print(movies['adult'].value_counts())","b5060dfa":"def to_boolean(x):\n    '''Take an object value and convert into boolean\n       return NaN is the the value is incorrect\n    '''\n    try:\n        x = bool(x)\n    except:\n        x= np.nan\n    return x\n\n#creating a function to convert to int\ndef to_int(num):\n    try:\n        num=int(num)\n    except:\n        num=np.nan\n    return num\n\n# converting a column to float\ndef to_float(num):\n    '''Take an object type and convert to float\n       return NaN for non numeric values\n    '''\n    try:\n        num=float(num)\n    except:\n        num=np.nan\n    return num\n\n#converting a column as category\ndef to_category(num):\n    '''Take an object type and convert to categorical\n       return NaN if convertion fails\n    '''\n    try:\n        num=category(num)\n    except:\n        num=np.nan\n    return num\n\n#converting a column as int\ndef to_int(num):\n    '''Take an object type and convert to int\n       return NaN if convertion fails\n    '''\n    try:\n        num=int(num)\n    except:\n        num=np.nan\n    return num","fceb18b6":"#converting the adult column in movie boolean\nmovies['adult']=movies['adult'].apply(to_boolean)\n\n#converting the video column in movie boolean\nmovies['video']=movies['video'].apply(to_boolean)\n\n\n#converting the budget column to float\nmovies['budget']=movies['budget'].apply(to_float)\n\n#converting the popularity column to float\nmovies['popularity']=movies['popularity'].apply(to_float)\n\n#converting the budget column to float\nmovies['revenue']=movies['revenue'].apply(to_float)\n\n#converting the vote_count column to float\nmovies['vote_count']=movies['vote_count'].apply(to_float)\n\n#converting the vote_average column to float\nmovies['vote_average']=movies['vote_average'].apply(to_float)\n\n#converting the Id column to int\nmovies['id']=movies['id'].apply(to_int)\n\n#converting the Id column to categorical\nmovies['original_language']=movies['original_language'].apply(to_category)\n\n#convert release_date to datetime\nmovies['release_date']=pd.to_datetime(movies['release_date'], errors='coerce')\n\nprint(movies['runtime'].describe())\nmovies['runtime']=movies['runtime'].apply(to_int)\n","a08b681f":"\n#getting the current memory size and compare with the original\ncurrent_memory=movies.memory_usage(deep=True)\n(1-current_memory\/original_memory)*100\n#movies.dtypes","d4e5e087":"print(movies.iloc[0]['genres'])\nprint(type(movies.iloc[0]['genres']))","16b577ab":"#let us fill all the genres with non value by an empty list.\n\nmovies['genres']=movies['genres'].fillna('[]')\n\n#evaluating the column and return the right object\nmovies['genres']=movies['genres'].apply(literal_eval)\n\n#then convert the colum to a list of genres\nmovies['genres']=movies['genres'].apply(lambda genre : [x['name'] for x in genre] if isinstance(genre,list) else [])\nmovies.iloc[0]['genres']","c70d5bcb":"tempgenre=movies.apply(lambda x: pd.Series(x['genres']), axis=1).stack().reset_index(level=1,drop=True)\ntempgenre.name='genre'\ntempgenre.head()","78fad0a6":"# new data set\nmovie_gen=movies.drop('genres', axis=1).join(tempgenre)\nmovie_gen.head(2)","7210f66e":"print(f' The new dataset has {movie_gen.shape[0]} rows and {movie_gen.shape[1]} columns')","1819e548":"credits = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/credits.csv')\ncredits.head(3)","73199e11":"credits['crew'].fillna('[]', inplace=True)\ncredits['cast'].fillna('[]', inplace=True)\ncredits['crew']=credits['crew'].apply(literal_eval)\ncredits['cast']=credits['cast'].apply(literal_eval)\n","b66e610c":"def get_actor(namedict):\n    result={}\n    try:\n        result['actor_1_name']=[x['name'] for x in namedict if x['order']==0][0]\n        result['actor_2_name']=[x['name'] for x in namedict if x['order']==1][0]\n        result['actor_3_name']=[x['name'] for x in namedict if x['order']==2][0]\n               \n    except:\n        name=np.nan\n    return result\n        \ndef get_director(namedict):\n    try:\n        name=[x['name'] for x in namedict if x['job']=='Director'][0]\n    except:\n        name=np.nan\n    return name\n        \n#Creating two additional  columns for director and actor    \ncredits['director']=credits['crew'].apply(get_director)\n\n#creating the 3 main actors for the movie\ncredits['actor_1_name']   =credits['cast'].apply(get_actor).apply(lambda x :x.get('actor_1_name',''))\ncredits['actor_2_name']   =credits['cast'].apply(get_actor).apply(lambda x :x.get('actor_2_name',''))\ncredits['actor_3_name']   =credits['cast'].apply(get_actor).apply(lambda x :x.get('actor_3_name',''))\n","66ef16ba":"#Dropping cast and cast and crew columns as no longer needed\ncredits.drop(['cast','crew'], inplace=True, axis=1)","af5bcb43":"#Merging the two new columns to the main dataset\ncombine_data =pd.merge(movie_gen,credits, on='id', how='inner')\ncombine_data.head(3)","e328807f":"combine_data.to_csv('combine_data.csv')","b8d970e3":"Now that all genres are list, we can explode that column to have each genre on its own row. This will incresase the size of our dataframe. \nWe will drop the original column and just keep the newly generated one.","e17c86a6":"**#### Checking the current memory size\nAs we can see below, changing the data type has signicantly reduce our memory footprint.","d08eac88":"Looking at the sample column above, it looks like we have a lot of column to pre-process such as:\n- belongs_to_collection    \n- genres                                      \n- spoken_languages\n- production_companies \n- production_countries","9e999e06":"### Removing some columns \nWe are going to remove some columns not very intersting for our analyis. if necessary, we will add them later. especially we will be scraping more information using the homepage for the **Natural language processing ** part.","5937e6ad":"### **Converting columns**","718dc0cb":"### Adding actors and directors name\nThe actors and directors name are in a different file called **credits**. In this section, we will extract those name and add them in our movie dataset","8af13bad":"### **Introduction and problem statement**\nThe movie dataset is a very interesting dataset. Not only it can allow us to explore many machine learning domains such as recommender system, regression,NLP, classification etc, but the dataset is complex enough to apply many data pre-processing techniques.\n\nWe are going to divide our exploration in many parts:\n- 1: [Data preprocessing ](https:\/\/www.kaggle.com\/mbothe7\/movie-dataset-analysis-part-1)\n- 2: [Data processing and Data analysis](https:\/\/www.kaggle.com\/mbothe7\/movie-dataset-analysis-part-2)\n- 3: Box office prediction\n- 4: Recommender system\n\n### 1-  Data Pre-processing\nIn this first part of our analysis. We are going to gatter from the different files provided all columns we will be using. Then merge them into one file before moving to the next step.\nThe main file that we will be using is the **kaggle\/input\/the-movies-dataset\/movies_metadata.csv** that has most raw data. We will be extracted the Director name and the actor name from the **credits.csv** file, then combine both files that will be the result of this phase.","62885129":"### Processing the genres column\nAs we can see below, a movie has many genres, and all genres are all combined in the same column. We have to split this into multiple. We see that each instance of genre is a string, but the underline structure is a list of dictionary. \nWe are going to use the **ast** package that has **literal_eval** module that parses a string and return the right python object.\n\nWe are going to create a function that will get all the genres for each movie, then add the genre as column with a binary value that indicates whether or not the movie is of that type.","fbfa592e":"As we can see, the column adult seems to be a boolean column with few incorrect values. Therefore, we will cast this column as boolean and set the incorrect values to NaN.\n","506b6c6f":"We see that many attributes have object data types.\nLet's check the memory footprint","dca1bb0e":"### Reducing memory by changing data types\npandas essentially load data in memory. To easier our data processing, we are going to make sure our columns have the appropriate data types","6ef586b6":"### Saving final file to csv\nWe are saving the final file top a csv file, that will be the input of the next phase"}}