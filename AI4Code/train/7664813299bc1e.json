{"cell_type":{"c838f7e1":"code","acbebdfd":"code","509a5f27":"code","6c366763":"code","dc354394":"code","f55e46ee":"code","4dcba70c":"code","11d6bd17":"code","f6db78f7":"code","33c5fb1c":"code","01426e7a":"code","b9742967":"code","3e59cc46":"code","eabc3e2b":"code","447757a1":"code","94a0686d":"code","81a8b03a":"code","7568b487":"code","b2ad974a":"code","3489e4d9":"code","13ca1cf8":"code","4bb8c5a3":"markdown"},"source":{"c838f7e1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","acbebdfd":"import matplotlib.pyplot as plt","509a5f27":"# data implement\ndata = pd.read_csv(\"\/kaggle\/input\/breast-cancer-wisconsin-data\/data.csv\")\n# data.head()\n# data cleaning\ndata.drop([\"Unnamed: 32\",\"id\"], axis=1, inplace=True)","6c366763":"data.diagnosis = [ 1 if each == \"M\" else 0 for each in data.diagnosis]\n# print(data.info())","dc354394":"\ny = data.diagnosis.values\nx_data = data.drop([\"diagnosis\"], axis = 1)","f55e46ee":"# normalization\nx = (x_data - np.min(x_data)) \/ (np.max(x_data) - np.min(x_data)).values\n","4dcba70c":"# %% Train test split\n\nfrom sklearn.model_selection import train_test_split\n\n# %25 test, %75 train\nx_train, x_test, y_train, y_test = train_test_split(x,y, test_size = 0.25, random_state = 42)\nx_train = x_train.T\nx_test = x_test.T\ny_train = y_train.T\ny_test = y_test.T","11d6bd17":"#%% initialize parameter \n\ndef initialize_weight_bias(dimension):\n    \n    w = np.full((dimension,1),0.01)  # weight\n    b = 0.0                          # bias \n    return w,b\n","f6db78f7":"#%% sigmoid function \n\ndef sigmoid(z):\n    \n    y_head = 1\/(1 + np.exp(-z))\n    return y_head","33c5fb1c":"# %%\n    \ndef forward_backward_propagation(w,b,x_train,y_train):\n    # forward propagation\n    z = np.dot(w.T,x_train) + b\n    y_head = sigmoid(z)\n    loss = -y_train*np.log(y_head)-(1-y_train)*np.log(1-y_head)\n    cost = (np.sum(loss))\/x_train.shape[1]      # x_train.shape[1]  is for scaling\n    \n    # backward propagation\n    derivative_weight = (np.dot(x_train,((y_head-y_train).T)))\/x_train.shape[1] # x_train.shape[1]  is for scaling\n    derivative_bias = np.sum(y_head-y_train)\/x_train.shape[1]                 # x_train.shape[1]  is for scaling\n    gradients = {\"derivative_weight\": derivative_weight, \"derivative_bias\": derivative_bias}\n    \n    return cost,gradients\n\n","01426e7a":"#%% Updating(learning) parameters\n    \ndef update(w, b, x_train, y_train, learning_rate,number_of_iterarion):\n    cost_list = []\n    cost_list2 = []\n    index = []\n    \n    # updating(learning) parameters is number_of_iterarion times\n    for i in range(number_of_iterarion):\n        # make forward and backward propagation and find cost and gradients\n        cost,gradients = forward_backward_propagation(w,b,x_train,y_train)\n        cost_list.append(cost)\n        # lets update\n        w = w - learning_rate * gradients[\"derivative_weight\"]\n        b = b - learning_rate * gradients[\"derivative_bias\"]\n        if i % 10 == 0:\n            cost_list2.append(cost)\n            index.append(i)\n            print (\"Cost after iteration %i: Cost %f\" %(i, cost))\n            \n    # we update(learn) parameters weights and bias\n    parameters = {\"weight\": w,\"bias\": b}\n    plt.plot(index,cost_list2)\n    plt.xticks(index,rotation='vertical')\n    plt.xlabel(\"Number of Iterarion\")\n    plt.ylabel(\"Cost\")\n    plt.show()\n    return parameters, gradients, cost_list\n    \n","b9742967":"#%%  # prediction\n    \ndef predict(w,b,x_test):\n    # x_test is a input for forward propagation\n    z = sigmoid(np.dot(w.T,x_test)+b)\n    Y_prediction = np.zeros((1,x_test.shape[1]))\n    # if z is bigger than 0.5, our prediction is sign one (y_head=1),\n    # if z is smaller than 0.5, our prediction is sign zero (y_head=0),\n    for i in range(z.shape[1]):\n        if z[0,i]<= 0.5:\n            Y_prediction[0,i] = 0\n        else:\n            Y_prediction[0,i] = 1\n\n    return Y_prediction\n","3e59cc46":"# %% logistic_regression\n    \ndef logistic_regression(x_train, y_train, x_test, y_test, learning_rate ,  num_iterations):\n    # initialize\n    dimension =  x_train.shape[0]  # that is 30\n    w,b = initialize_weight_bias(dimension)\n    # do not change learning rate\n    parameters, gradients, cost_list = update(w, b, x_train, y_train, learning_rate,num_iterations)\n    \n    y_prediction_test = predict(parameters[\"weight\"],parameters[\"bias\"],x_test)\n\n    # Print test Errors\n    print(\"test accuracy: {} %\".format(100 - np.mean(np.abs(y_prediction_test - y_test)) * 100))\n    ","eabc3e2b":"logistic_regression(x_train, y_train, x_test, y_test,learning_rate = 1, num_iterations = 400)   ","447757a1":"#%%   LR with Sklearn\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import classification_report, confusion_matrix\n\n","94a0686d":"\nlr = LogisticRegression(random_state = 42, max_iter = 400,)\nlr.fit(x_train.T,y_train.T)\n","81a8b03a":"\np_pred = lr.predict_proba(x_test.T)\ny_pred = lr.predict(x_test.T)\nscore_ = lr.score(x_test.T,y_test.T)\nconf_m = confusion_matrix(y_test.T, y_pred).T\nreport = classification_report(y_test, y_pred)\n","7568b487":"print(\"Test proba:\\n\", p_pred )\n\n","b2ad974a":"print(\"Test accuracy {}\".format(score_))\n\n","3489e4d9":"print(\"Confusion matrix:\\n\",conf_m )\n\n","13ca1cf8":"print(\"Test report:\\n\", report )","4bb8c5a3":"   \u00d6ncelikle g\u00f6g\u00fcs kanseri veri setini kulland\u0131m bu veri seti UCI taraf\u0131ndan 1995 y\u0131l\u0131nda olu\u015fturulmu\u015f,32 attribute ve 569 sample var. Diagnosis attributte B = Benign M = Malignant olmak \u00fczere 2 s\u0131n\u0131fland\u0131rma yap\u0131lm\u0131\u015f.Verisetini y\u00fckleme, temizleme ve normalize i\u015flemlerini yapt\u0131m. Datam\u0131 %25test %75train olarak par\u00e7alad\u0131ktan sonra i\u015flemlerimi iki farkl\u0131 \u015fekilde yapt\u0131m. \u0130lk ba\u015fta haz\u0131r k\u00fct\u00fcphane kullanmadan fonksiyonlar\u0131 kendim yazarak egittim ikinci olarak ise sklearn k\u00fct\u00fcphanesini kullanarak egitim yapt\u0131m initialize_weight_bias fonksiyonu ile ba\u015flang\u0131\u00e7 ag\u0131rl\u0131\u011f\u0131n\u0131 ve bias degerini veri seti boyutlar\u0131na uygun \u015fekilde \u00fcretmi\u015f oldum, ag\u0131rl\u0131k degerini 0 olursa sonsuz d\u00f6ng\u00fcye gireceginden 0 yak\u0131n deger 0.01 olarak belirledim.\n    sigmoid fonksiyonunu, sigmoid fonksiyonunu hesaplaplamak i\u00e7in kulland\u0131m.\n    forward_backward_propagation fonksiyonu a\u011f\u0131rl\u0131klara ve bias a g\u00f6re degerlerimi hesaplay\u0131p loss ve cost degerlerini, back propagation yaparak da t\u00fcrev, gradient degerlerini hesaplay\u0131p geri d\u00f6nd\u00fcrd\u00fc.\n    update fonksiyonu parametre olarak ald\u0131g\u0131 iterasyon say\u0131s\u0131 kadar forward-backward yap\u0131p ag\u0131rl\u0131k ve bias degerlerini g\u00fcncelledi ve her iterasyon i\u00e7in cost degerini grafik ile \u00e7izdirdi. iterasyon say\u0131s\u0131 artt\u0131k\u00e7a cost 0'a yakla\u015ft\u0131 ama belli bir iterasyon say\u0131s\u0131ndan sonra cost degerinin degi\u015fimi \u00e7ok azald\u0131, bu y\u00fczden iterasyonu 400 olarak belirledim.\n    predict fonksiyonu sigmoid fonksiyonundan d\u00f6nen test verilerimi threshold degeri ile kar\u015f\u0131la\u015ft\u0131r\u0131p deger threshold degerinden b\u00fcy\u00fckse 1,k\u00fc\u00e7\u00fckse 0 olarak d\u00f6nd\u00fcrd\u00fc.\n    logistic_regression fonksiyonu t\u00fcm i\u015flemleri yapt\u0131g\u0131m\u0131z ana foksiyon i\u015flevinde, ba\u015flang\u0131\u00e7 fonksiyonu ile ba\u015flang\u0131\u00e7 degerlerini verip, update fonksiyonu train verileri ile iterasy\u0131n kadar forward-backward yaparak ag\u0131rl\u0131k degerlerimizi g\u00fcncelleyip egitimi yapm\u0131\u015f, predict fonksiyonu ile test verileri g\u00f6nderip sonu\u00e7lar\u0131 elde etmi\u015f ve accuracy degerini elde etmi\u015f olduk.\n    \u0130kinci a\u015famada ise sklearn k\u00fct\u00fcphanesini kullanarak ayn\u0131 test ve train setleri ile i\u015flemleri yapt\u0131m iterasyon say\u0131s\u0131n\u0131 yukar\u0131daki ile ayn\u0131(400) ama ba\u015far\u0131 sonu\u00e7lar\u0131 biraz farkl\u0131 oldu, sklearn k\u00fct\u00fcphanesi daha farkl\u0131 parametreler ve daha hassas degerler kulland\u0131\u011f\u0131 i\u00e7in oldugunu d\u00fc\u015f\u00fcn\u00fcyorum.\n\n198229002007 - BA\u015eAK \u00d6ZT\u00dcRK\n    "}}