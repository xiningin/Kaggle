{"cell_type":{"e2d2d5e5":"code","54914f8d":"code","7249b832":"code","efcf222b":"code","2f8eddbf":"code","6d6c52cb":"code","33e7371c":"code","13d913f1":"code","f34d699c":"code","700da305":"code","a41dabe8":"code","e9d7baba":"code","43b87576":"code","d7493ffb":"code","ced41d49":"code","4c07374b":"code","a7a219f4":"code","3d2f5ed2":"code","f9fabec7":"code","b5b046a0":"code","719f62e4":"code","c03bc04c":"markdown","01fb59c5":"markdown","a6cc42e4":"markdown","7f2680aa":"markdown","bbc54503":"markdown","55abc695":"markdown","03c5f27d":"markdown","883d2d72":"markdown","fe2a136c":"markdown","44497e45":"markdown","a0927db5":"markdown","b23da86b":"markdown","3549bda4":"markdown","cecd6bf0":"markdown","eec99922":"markdown","b59f7c00":"markdown","d65e0b2d":"markdown","6b7a4e0c":"markdown","a87e5025":"markdown"},"source":{"e2d2d5e5":"%tensorflow_version 2.x","54914f8d":"import tensorflow as tf\nprint(tf.__version__)","7249b832":"import os\nimport pathlib","efcf222b":"try:\n  tpu = tf.distribute.cluster_resolver.TPUClusterResolver()  # TPU detection\n  print('Running on TPU ', tpu.cluster_spec().as_dict()['worker'])\nexcept ValueError:\n  raise BaseException('ERROR: Not connected to a TPU runtime; please see the previous cell in this notebook for instructions!')\n\ntf.config.experimental_connect_to_cluster(tpu)\ntf.tpu.experimental.initialize_tpu_system(tpu)\ntpu_strategy = tf.distribute.experimental.TPUStrategy(tpu)\n\nAUTO = tf.data.experimental.AUTOTUNE","2f8eddbf":"# Clone the tensorflow models repository if it doesn't already exist\nif \"models\" in pathlib.Path.cwd().parts:\n  while \"models\" in pathlib.Path.cwd().parts:\n    os.chdir('..')\nelif not pathlib.Path('models').exists():\n  !git clone --depth 1 https:\/\/github.com\/tensorflow\/models","6d6c52cb":"# Install the Object Detection API\n%%bash\ncd models\/research\n# Compile protos.\nprotoc object_detection\/protos\/*.proto --python_out=.\n# Install TensorFlow Object Detection API.\ncp object_detection\/packages\/tf2\/setup.py .\npython -m pip install .","33e7371c":"# Test the installation.\n%%bash\ncd models\/research\npython object_detection\/builders\/model_builder_tf2_test.py","13d913f1":"import matplotlib\nimport matplotlib.pyplot as plt\n\nimport random\nimport io\nimport imageio\nimport glob\nimport scipy.misc\nimport numpy as np\nfrom six import BytesIO\nfrom PIL import Image, ImageDraw, ImageFont\nfrom IPython.display import display, Javascript\nfrom IPython.display import Image as IPyImage\n\nfrom object_detection.utils import label_map_util\nfrom object_detection.utils import config_util\nfrom object_detection.utils import visualization_utils as viz_utils\nfrom object_detection.utils import colab_utils\nfrom object_detection.builders import model_builder\nfrom tensorflow.keras import  losses, metrics\n\n%matplotlib inline","f34d699c":"def load_image_into_numpy_array(path):\n  \"\"\"Load an image from file into a numpy array.\n\n  Puts image into numpy array to feed into tensorflow graph.\n  Note that by convention we put it into a numpy array with shape\n  (height, width, channels), where channels=3 for RGB.\n\n  Args:\n    path: a file path.\n\n  Returns:\n    uint8 numpy array with shape (img_height, img_width, 3)\n  \"\"\"\n  img_data = tf.io.gfile.GFile(path, 'rb').read()\n  image = Image.open(BytesIO(img_data))\n  (im_width, im_height) = image.size\n  return np.array(image.getdata()).reshape(\n      (im_height, im_width, 3)).astype(np.uint8)\n\ndef plot_detections(image_np,\n                    boxes,\n                    classes,\n                    scores,\n                    category_index,\n                    figsize=(12, 16),\n                    image_name=None):\n  \"\"\"Wrapper function to visualize detections.\n\n  Args:\n    image_np: uint8 numpy array with shape (img_height, img_width, 3)\n    boxes: a numpy array of shape [N, 4]\n    classes: a numpy array of shape [N]. Note that class indices are 1-based,\n      and match the keys in the label map.\n    scores: a numpy array of shape [N] or None.  If scores=None, then\n      this function assumes that the boxes to be plotted are groundtruth\n      boxes and plot all boxes as black with no classes or scores.\n    category_index: a dict containing category dictionaries (each holding\n      category index `id` and category name `name`) keyed by category indices.\n    figsize: size for the figure.\n    image_name: a name for the image file.\n  \"\"\"\n  image_np_with_annotations = image_np.copy()\n  viz_utils.visualize_boxes_and_labels_on_image_array(\n      image_np_with_annotations,\n      boxes,\n      classes,\n      scores,\n      category_index,\n      use_normalized_coordinates=True,\n      min_score_thresh=0.8)\n  if image_name:\n    plt.imsave(image_name, image_np_with_annotations)\n  else:\n    plt.imshow(image_np_with_annotations)","700da305":"# Load images and visualize\ntrain_image_dir = 'models\/research\/object_detection\/test_images\/ducky\/train\/'\ntrain_images_np = []\nfor i in range(1, 6):\n  image_path = os.path.join(train_image_dir, 'robertducky' + str(i) + '.jpg')\n  train_images_np.append(load_image_into_numpy_array(image_path))\n\nplt.rcParams['axes.grid'] = False\nplt.rcParams['xtick.labelsize'] = False\nplt.rcParams['ytick.labelsize'] = False\nplt.rcParams['xtick.top'] = False\nplt.rcParams['xtick.bottom'] = False\nplt.rcParams['ytick.left'] = False\nplt.rcParams['ytick.right'] = False\nplt.rcParams['figure.figsize'] = [14, 7]\n\nfor idx, train_image_np in enumerate(train_images_np):\n  plt.subplot(2, 3, idx+1)\n  plt.imshow(train_image_np)\nplt.show()","a41dabe8":"gt_boxes = []\ncolab_utils.annotate(train_images_np, box_storage_pointer=gt_boxes)","e9d7baba":" gt_boxes = [\n             np.array([[0.436, 0.591, 0.629, 0.712]], dtype=np.float32),\n             np.array([[0.539, 0.583, 0.73, 0.71]], dtype=np.float32),\n             np.array([[0.464, 0.414, 0.626, 0.548]], dtype=np.float32),\n             np.array([[0.313, 0.308, 0.648, 0.526]], dtype=np.float32),\n             np.array([[0.256, 0.444, 0.484, 0.629]], dtype=np.float32)\n ]","43b87576":"# By convention, our non-background classes start counting at 1.  Given\n# that we will be predicting just one class, we will therefore assign it a\n# `class id` of 1.\nduck_class_id = 1\nnum_classes = 1\n\ncategory_index = {duck_class_id: {'id': duck_class_id, 'name': 'rubber_ducky'}}\n\n# Convert class labels to one-hot; convert everything to tensors.\n# The `label_id_offset` here shifts all classes by a certain number of indices;\n# we do this here so that the model receives one-hot labels where non-background\n# classes start counting at the zeroth index.  This is ordinarily just handled\n# automatically in our training binaries, but we need to reproduce it here.\nlabel_id_offset = 1\ntrain_image_tensors = []\ngt_classes_one_hot_tensors = []\ngt_box_tensors = []\nfor (train_image_np, gt_box_np) in zip(\n    train_images_np, gt_boxes):\n  train_image_tensors.append(tf.expand_dims(tf.convert_to_tensor(\n      train_image_np, dtype=tf.float32), axis=0))\n  gt_box_tensors.append(tf.convert_to_tensor(gt_box_np, dtype=tf.float32))\n  zero_indexed_groundtruth_classes = tf.convert_to_tensor(\n      np.ones(shape=[gt_box_np.shape[0]], dtype=np.int32) - label_id_offset)\n  gt_classes_one_hot_tensors.append(tf.one_hot(\n      zero_indexed_groundtruth_classes, num_classes))\nprint('Done prepping data.')","d7493ffb":"dummy_scores = np.array([1.0], dtype=np.float32)  # give boxes a score of 100%\n\nplt.figure(figsize=(30, 15))\nfor idx in range(5):\n  plt.subplot(2, 3, idx+1)\n  plot_detections(\n      train_images_np[idx],\n      gt_boxes[idx],\n      np.ones(shape=[gt_boxes[idx].shape[0]], dtype=np.int32),\n      dummy_scores, category_index)\nplt.show()","ced41d49":"#!rm -r models\/research\/object_detection\/test_data\/*","4c07374b":"# Download the checkpoint and put it into models\/research\/object_detection\/test_data\/\n#wget http:\/\/download.tensorflow.org\/models\/object_detection\/tf2\/20200711\/efficientdet_d1_coco17_tpu-32.tar.gz\n\n%%bash\n\nwget http:\/\/download.tensorflow.org\/models\/object_detection\/tf2\/20200711\/ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.tar.gz\ntar -xf ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.tar.gz\nmv ssd_resnet50_v1_fpn_640x640_coco17_tpu-8\/checkpoint models\/research\/object_detection\/test_data\/","a7a219f4":"tf.keras.backend.clear_session()\n\nprint('Building model and restoring weights for fine-tuning...', flush=True)\nnum_classes = 1\nGSC_PATH = 'gs:\/\/kds-7890ecf1bbc467f900e0bbadcca863a7e5659f12d384783bfc3c449d\/ssd_resnet50_v1_fpn_640x640_coco17_tpu-8\/'\npipeline_config = 'models\/research\/object_detection\/configs\/tf2\/ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.config'\ncheckpoint_path = GSC_PATH +'checkpoint\/ckpt-0'\n\n# Load pipeline config and build a detection model.\n#\n# Since we are working off of a COCO architecture which predicts 90\n# class slots by default, we override the `num_classes` field here to be just\n# one (for our new rubber ducky class).\nconfigs = config_util.get_configs_from_pipeline_file(pipeline_config)\nmodel_config = configs['model']\nmodel_config.ssd.num_classes = num_classes\nmodel_config.ssd.freeze_batchnorm = True\nwith tpu_strategy.scope():\n  detection_model = model_builder.build(\n        model_config=model_config, is_training=True)\n\n  # Set up object-based checkpoint restore --- RetinaNet has two prediction\n  # `heads` --- one for classification, the other for box regression.  We will\n  # restore the box regression head but initialize the classification head\n  # from scratch (we show the omission below by commenting out the line that\n  # we would add if we wanted to restore both heads)\n  fake_box_predictor = tf.train.Checkpoint(\n      _base_tower_layers_for_heads=detection_model._box_predictor._base_tower_layers_for_heads,\n      # _prediction_heads=detection_model._box_predictor._prediction_heads,\n      #    (i.e., the classification head that we *will not* restore)\n      _box_prediction_head=detection_model._box_predictor._box_prediction_head,\n      )\n  fake_model = tf.train.Checkpoint(\n            _feature_extractor=detection_model._feature_extractor,\n            _box_predictor=fake_box_predictor)\n  ckpt = tf.train.Checkpoint(model=fake_model)\n  ckpt.restore(checkpoint_path).expect_partial()\n\n  # Run model through a dummy image so that variables are created\n  image, shapes = detection_model.preprocess(tf.zeros([1, 640, 640, 3]))\n  prediction_dict = detection_model.predict(image, shapes)\n  _ = detection_model.postprocess(prediction_dict, shapes)\n  print('Weights restored!')","3d2f5ed2":"tf.keras.backend.set_learning_phase(True)\n\n# These parameters can be tuned; since our training set has 5 images\n# it doesn't make sense to have a much larger batch size, though we could\n# fit more examples in memory if we wanted to.\nbatch_size = 5\nlearning_rate = 0.01\nsteps = 1000\n\n# Select variables in top layers to fine-tune.\ntrainable_variables = detection_model.trainable_variables\nto_fine_tune = []\nprefixes_to_train = [\n  'WeightSharedConvolutionalBoxPredictor\/WeightSharedConvolutionalBoxHead',\n  'WeightSharedConvolutionalBoxPredictor\/WeightSharedConvolutionalClassHead']\nfor var in trainable_variables:\n  if any([var.name.startswith(prefix) for prefix in prefixes_to_train]):\n    to_fine_tune.append(var)\n\n# Set up forward + backward pass for a single train step.\ndef get_model_train_step_function(model, optimizer, vars_to_fine_tune):\n  \"\"\"Get a tf.function for training step.\"\"\"\n\n  # Use tf.function for a bit of speed.\n  # Comment out the tf.function decorator if you want the inside of the\n  # function to run eagerly.\n  @tf.function\n  def train_step_fn(image_tensors,\n                    groundtruth_boxes_list,\n                    groundtruth_classes_list):\n    \"\"\"A single training iteration.\n\n    Args:\n      image_tensors: A list of [1, height, width, 3] Tensor of type tf.float32.\n        Note that the height and width can vary across images, as they are\n        reshaped within this function to be 640x640.\n      groundtruth_boxes_list: A list of Tensors of shape [N_i, 4] with type\n        tf.float32 representing groundtruth boxes for each image in the batch.\n      groundtruth_classes_list: A list of Tensors of shape [N_i, num_classes]\n        with type tf.float32 representing groundtruth boxes for each image in\n        the batch.\n\n    Returns:\n      A scalar tensor representing the total loss for the input batch.\n    \"\"\"\n\n    shapes = tf.constant(batch_size * [[640, 640, 3]], dtype=tf.int32)\n    model.provide_groundtruth(\n        groundtruth_boxes_list=groundtruth_boxes_list,\n        groundtruth_classes_list=groundtruth_classes_list)\n    with tf.GradientTape() as tape:\n      preprocessed_images = tf.concat(\n        [\n          model.preprocess(image_tensor)[0]\n          for image_tensor in image_tensors\n        ], axis=0\n      )\n      \n      prediction_dict = model.predict(preprocessed_images, shapes)\n      losses_dict = model.loss(prediction_dict, shapes)\n      total_loss = losses_dict['Loss\/localization_loss'] + losses_dict['Loss\/classification_loss']\n    gradients = tape.gradient(total_loss, vars_to_fine_tune)\n    optimizer.apply_gradients(zip(gradients, vars_to_fine_tune))\n    # update metrics\n    train_loss.update_state(total_loss * tpu_strategy.num_replicas_in_sync) \n\n    return total_loss\n\n  return train_step_fn\n\n\n\nwith tpu_strategy.scope():\n  train_step_fn = get_model_train_step_function(\n      detection_model, optimizer, to_fine_tune)\n  optimizer = tf.keras.optimizers.Adamax(learning_rate=learning_rate)\n\n  train_accuracy = metrics.CategoricalAccuracy()\n  valid_accuracy = metrics.CategoricalAccuracy()\n  train_loss = metrics.Sum()\n  valid_loss = metrics.Sum()\n\n  print('Start fine-tuning!', flush=True)\n  for step in range(steps):\n    # Grab keys for a random subset of examples\n    all_keys = list(range(len(train_images_np)))\n    random.shuffle(all_keys)\n    example_keys = all_keys[:batch_size]\n    \n    # Note that we do not do data augmentation in this demo.  If you want a\n    # a fun exercise, we recommend experimenting with random horizontal flipping\n    # and random cropping :)\n    gt_boxes_list = [gt_box_tensors[key] for key in example_keys]\n    gt_classes_list = [gt_classes_one_hot_tensors[key] for key in example_keys]\n    image_tensors = [train_image_tensors[key] for key in example_keys]\n\n    # Training step (forward pass + backwards pass)\n    # total_loss = train_step_fn(image_tensors, gt_boxes_list, gt_classes_list)\n    tpu_strategy.run(train_step_fn,  args = (image_tensors, gt_boxes_list, gt_classes_list) )\n    #if step % 10 == 0:\n    #  print(\"=\", end =\"\")\n\n    if step % 100 == 0:\n      print('Step ' + str(step) + ' of ' + str(steps), flush=True)\n\nprint('Done fine-tuning!')","f9fabec7":"print('Loss ' + str(train_loss.result().numpy()\/(batch_size*steps)))","b5b046a0":"test_image_dir = 'models\/research\/object_detection\/test_images\/ducky\/test\/'\ntest_images_np = []\nfor i in range(1, 50):\n  image_path = os.path.join(test_image_dir, 'out' + str(i) + '.jpg')\n  test_images_np.append(np.expand_dims(\n      load_image_into_numpy_array(image_path), axis=0))\n\n# Again, uncomment this decorator if you want to run inference eagerly\n@tf.function\ndef detect(input_tensor):\n  \"\"\"Run detection on an input image.\n\n  Args:\n    input_tensor: A [1, height, width, 3] Tensor of type tf.float32.\n      Note that height and width can be anything since the image will be\n      immediately resized according to the needs of the model within this\n      function.\n\n  Returns:\n    A dict containing 3 Tensors (`detection_boxes`, `detection_classes`,\n      and `detection_scores`).\n  \"\"\"\n  preprocessed_image, shapes = detection_model.preprocess(input_tensor)\n  prediction_dict = detection_model.predict(preprocessed_image, shapes)\n  return detection_model.postprocess(prediction_dict, shapes)\n\n# Note that the first frame will trigger tracing of the tf.function, which will\n# take some time, after which inference should be fast.\n\nlabel_id_offset = 1\nwith tpu_strategy.scope():\n  for i in range(len(test_images_np)):\n    input_tensor = tf.convert_to_tensor(test_images_np[i], dtype=tf.float32 )\n    detections = detect(input_tensor)\n\n    plot_detections(\n        test_images_np[i][0],\n        detections['detection_boxes'][0].numpy(),\n        detections['detection_classes'][0].numpy().astype(np.uint32)\n        + label_id_offset,\n        detections['detection_scores'][0].numpy(),\n        category_index, figsize=(15, 20), image_name=\"gif_frame_\" + ('%02d' % i) + \".jpg\")","719f62e4":"imageio.plugins.freeimage.download()\n\nanim_file = 'duckies_test.gif'\n\nfilenames = glob.glob('gif_frame_*.jpg')\nfilenames = sorted(filenames)\nlast = -1\nimages = []\nfor filename in filenames:\n  image = imageio.imread(filename)\n  images.append(image)\n\nimageio.mimsave(anim_file, images, 'GIF-FI', fps=5)\n\ndisplay(IPyImage(open(anim_file, 'rb').read()))","c03bc04c":"### Building model and restoring weights for fine-tuning","01fb59c5":"# Requirements\n[![Python 3.6](https:\/\/img.shields.io\/badge\/Python-3.6-3776AB)](https:\/\/www.python.org\/downloads\/release\/python-360\/)\n[![TensorFlow 2.2](https:\/\/img.shields.io\/badge\/TensorFlow-2.2-FF6F00?logo=tensorflow)](https:\/\/github.com\/tensorflow\/tensorflow\/releases\/tag\/v2.2.0)\n[![Protobuf Compiler >= 3.0](https:\/\/img.shields.io\/badge\/ProtoBuf%20Compiler-%3E3.0-brightgreen)](https:\/\/grpc.io\/docs\/protoc-installation\/#install-using-a-package-manager)","a6cc42e4":"##Specifying the TensorFlow version\n\nRunning `import tensorflow` will import the default version (currently 2.x). You can use 1.x by running a cell with the `tensorflow_version` magic **before** you run `import tensorflow`.","7f2680aa":"### In case you didn't want to label...\nRun this cell only if you didn't annotate anything above and would prefer to just use our preannotated boxes. Don't forget to uncomment.","bbc54503":"### Let's just visualize the rubber duckies as a sanity check\n","55abc695":"## Annotate images with bounding boxes\nIn this cell you will annotate the rubber duckies --- draw a box around the rubber ducky in each image; click next image to go to the next image and submit when there are no more images.\n\nIf you'd like to skip the manual annotation step, we totally understand. In this case, simply skip this cell and run the next cell instead, where we've prepopulated the groundtruth with pre-annotated bounding boxes.","03c5f27d":"## Rubber Ducky data\nWe will start with some toy (literally) data consisting of 5 images of a rubber ducky. Note that the [coco](https:\/\/cocodataset.org\/#explore) dataset contains a number of animals, but notably, it does not contain rubber duckies (or even ducks for that matter), so this is a novel class.","883d2d72":"## Eager mode custom training loop\n","fe2a136c":"# Eager Few Shot Object Detection Colab\nWelcome to the Eager Few Shot Object Detection Colab --- in this colab we demonstrate fine tuning of a (TF2 friendly) RetinaNet architecture on very few examples of a novel class after initializing from a pre-trained COCO checkpoint. Training runs in eager mode.# ","44497e45":"## Imports","a0927db5":"## Install TensorFlow Object Detection API\nYou can install the TensorFlow Object Detection API either with Python Package Installer (pip) or Docker. For local runs we recommend using Docker and for Google Cloud runs we recommend using pip.\n\nClone the TensorFlow Models repository and proceed to one of the installation options.","b23da86b":"## Utilities","3549bda4":"### Python Package Installation\n","cecd6bf0":"#Load test images and run inference with new model!\n","eec99922":"## Create model and restore weights for all but last layer\nIn this cell we build a single stage detection architecture (RetinaNet) and restore all but the classification layer at the top (which will be automatically randomly initialized).\n\nFor simplicity, we have hardcoded a number of things in this colab for the specific RetinaNet architecture at hand (including assuming that the image size will always be 640x640), however it is not difficult to generalize to other model configurations.","b59f7c00":"\n##Background\nColab has two versions of TensorFlow pre-installed: a 2.x version and a 1.x version. Colab uses TensorFlow 2.x by default, though you can switch to 1.x by the method shown below.\n\nWe use the Keras framework, new to TPUs in TF 2.1.0.\n","d65e0b2d":"## Enabling and testing the TPU\n\nFirst, you'll need to enable TPUs for the notebook:\n\n- Navigate to Edit\u2192Notebook Settings\n- select TPU from the Hardware Accelerator drop-down\n\nNext, we'll confirm that we can connect to the TPU with tensorflow:","6b7a4e0c":"## Prepare data for training\nBelow we add the class annotations (for simplicity, we assume a single class in this colab; though it should be straightforward to extend this to handle multiple classes). We also convert everything to the format that the training loop below expects (e.g., everything converted to tensors, classes converted to one-hot representations, etc.).","a87e5025":"Once you have specified a version via this magic, you can run `import tensorflow` as normal and verify which version was imported as follows:"}}