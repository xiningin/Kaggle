{"cell_type":{"9e5a82ef":"code","5726a844":"code","74fea5df":"code","27f89755":"code","a0e2dc4f":"code","c5f888d5":"code","70e17b9d":"code","b68b3d4e":"code","e272c24e":"code","02c97c9f":"code","9cbc7c96":"code","e4e89658":"code","7cee789f":"code","3e5093ba":"code","e6774334":"code","53e36f59":"code","c300da1d":"code","dabae2c4":"code","111ce6d0":"code","8268e9d9":"code","f3df73ad":"markdown","e0c025d4":"markdown","47cfb938":"markdown","81ef4332":"markdown","af342604":"markdown","38025238":"markdown","ba01af71":"markdown"},"source":{"9e5a82ef":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","5726a844":"df = pd.read_csv('..\/input\/new-york-city-airbnb-open-data\/AB_NYC_2019.csv') ","74fea5df":"df.dtypes","27f89755":"import matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline","a0e2dc4f":"sns.histplot(df.price[df.price < 6000], bins = 50)","c5f888d5":"price_logs = np.log1p(df.price)","70e17b9d":"sns.histplot(price_logs, bins = 50)","b68b3d4e":"df = df.loc[:, df.columns.intersection(['latitude', 'longitude', 'price','minimum_nights',\n                                        'number_of_reviews','reviews_per_month','calculated_host_listings_count','availability_365'])]\n","e272c24e":"df.isnull().sum()","02c97c9f":"df.minimum_nights.median()","9cbc7c96":"n = len(df)\n\nn_val = int( n * 0.2)\nn_test = int( n * 0.2)\nn_train = n - n_val - n_test","e4e89658":"df_train = df.iloc[:n_train]\ndf_val = df.iloc[n_train:n_val + n_train]\ndf_test = df.iloc[n_val + n_train:]\n\nidx = np.arange(n)\nnp.random.seed(42)\nnp.random.shuffle(idx)\n\ndf_train = df.iloc[idx[:n_train]]\ndf_val = df.iloc[idx[n_train:n_val + n_train]]\ndf_test = df.iloc[idx[n_val + n_train:]]\n\ny_train_orig = df_train.price.values\ny_val_orig = df_val.price.values\ny_test_orig = df_test.price.values\n\ny_train = np.log1p(df_train.price.values)\ny_val = np.log1p(df_val.price.values)\ny_test = np.log1p(df_test.price.values)\n\ndel df_train['price']\ndel df_val['price']\ndel df_test['price']","7cee789f":"def train_linear_regression(X, y):\n    ones = np.ones(X.shape[0])\n    X = np.column_stack([ones, X])\n\n    XTX = X.T.dot(X)\n    XTX_inv = np.linalg.inv(XTX)\n    w = XTX_inv.dot(X.T).dot(y)\n    \n    return w[0], w[1:]","3e5093ba":"def rmse(y, y_pred):\n    error = y_pred - y\n    mse = (error ** 2).mean()\n    return np.sqrt(mse)","e6774334":"X_train = df_train.fillna(0).values\nw0, w = train_linear_regression(X_train, y_train)\ny_pred = w0 + X_train.dot(w)\n\nsns.histplot(y_pred, color = 'red', alpha = 0.5, bins = 50)\nsns.histplot(y_train, color = 'blue', alpha = 0.5, bins = 50)\n\nscore_with_zeros = round(rmse(y_train, y_pred), 2)\nprint(score_with_zeros)","53e36f59":"mean = df_train.reviews_per_month.mean()\nX_train = df_train.fillna(mean).values\nw0, w = train_linear_regression(X_train, y_train)\ny_pred = w0 + X_train.dot(w)\n\nsns.histplot(y_pred, color = 'red', alpha = 0.5, bins = 50)\nsns.histplot(y_train, color = 'blue', alpha = 0.5, bins = 50)\n\nscore_with_mean = round(rmse(y_train, y_pred), 2)\nprint(score_with_mean)","c300da1d":"def train_linear_regression_reg(X, y, r=0.0):\n    ones = np.ones(X.shape[0])\n    X = np.column_stack([ones, X])\n\n    XTX = X.T.dot(X)\n    reg = r * np.eye(XTX.shape[0])\n    XTX = XTX + reg\n\n    XTX_inv = np.linalg.inv(XTX)\n    w = XTX_inv.dot(X.T).dot(y)\n    \n    return w[0], w[1:]","dabae2c4":"X_train = df_train.fillna(0).values\n\nfor r in [0, 0.000001, 0.0001, 0.001, 0.01, 0.1, 1, 5, 10]:\n    w_0, w = train_linear_regression_reg(X_train, y_train, r=r)\n    y_pred = w0 + X_train.dot(w)\n    score = round(rmse(y_train, y_pred), 2)\n    print('with value r {}, the score was {}'.format(r, score))","111ce6d0":"scores_col = []\n\nfor seed_val in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]:\n    n = len(df)\n    n_val = int( n * 0.2)\n    n_test = int( n * 0.2)\n    n_train = n - n_val - n_test\n    \n    df_train = df.iloc[:n_train]\n    df_val = df.iloc[n_train:n_val + n_train]\n    df_test = df.iloc[n_val + n_train:]\n    \n    idx = np.arange(n)\n    np.random.seed(seed_val)\n    np.random.shuffle(idx)\n    df_train = df.iloc[idx[:n_train]]\n    df_val = df.iloc[idx[n_train:n_val + n_train]]\n    df_test = df.iloc[idx[n_val + n_train:]]\n    \n    y_train = np.log1p(df_train.price.values)\n    y_val = np.log1p(df_val.price.values)\n    y_test = np.log1p(df_test.price.values)\n    \n    del df_train['price']\n    del df_val['price']\n    del df_test['price']   \n    \n    X_train = df_train.fillna(0).values\n    X_val = df_val.fillna(0).values\n    w_0, w = train_linear_regression(X_train, y_train)\n    \n    y_pred = w0 + X_val.dot(w)\n    score = round(rmse(y_pred, y_val), 2)\n    print('with seed {}, the score was {}'.format(seed_val, score))\n    scores_col.append(score)\n    \nprint(scores_col)\nscores_col = np.array(scores_col)\n\nprint(\"std: \", round(np.std(scores_col),3))","8268e9d9":"n = len(df)\nn_val = int( n * 0.2)\nn_test = int( n * 0.2)\nn_train = n - n_val - n_test\n    \ndf_train = df.iloc[:n_train]\ndf_val = df.iloc[n_train:n_val + n_train]\ndf_test = df.iloc[n_val + n_train:]\n    \nidx = np.arange(n)\nnp.random.seed(9)\nnp.random.shuffle(idx)\ndf_train = df.iloc[idx[:n_train]]\ndf_val = df.iloc[idx[n_train:n_val + n_train]]\ndf_test = df.iloc[idx[n_val + n_train:]]\n\n#combining df_train and df_val\n\ndf_train = df_train.append(df_val)\n\ny_train = np.log1p(df_train.price.values)\ny_test = np.log1p(df_test.price.values)\n\ndel df_train['price']\ndel df_test['price']   \n\n\nX_train = df_train.fillna(0).values\nX_test = df_test.fillna(0).values\n\nw_0, w = train_linear_regression_reg(X_train, y_train, r=0.001)\n\ny_pred = w0 + X_test.dot(w)\nscore = round(rmse(y_test, y_pred), 2)\nprint(score)","f3df73ad":"**Median Value of \"Minimum Nights**","e0c025d4":"**Q5**","47cfb938":"**Linear Regression**","81ef4332":"**Validation Framework**","af342604":"**Q6**","38025238":"reveiew per month has missing values, it has 10052 missing values","ba01af71":"Using 0 values to fill"}}