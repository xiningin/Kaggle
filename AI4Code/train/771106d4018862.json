{"cell_type":{"4b34de90":"code","26968670":"code","6f37c67f":"code","da025476":"code","64e91f20":"code","a349d0a1":"code","1b9a459e":"code","e8a22268":"code","2e595403":"code","a9c1a3b4":"code","f0576a9f":"code","a966de71":"code","f8c94fba":"code","0fdadf70":"code","00d304f7":"code","233b7eee":"code","a10d1d76":"code","b4763088":"code","2c100d70":"code","c74bad35":"code","d2f3a627":"code","7c1521a2":"code","495a6b74":"code","3f4333b2":"code","5d82c507":"code","fb18a69e":"markdown","c03fb22a":"markdown","b3f8b88b":"markdown","89f0226a":"markdown","8d0e2b9b":"markdown","06848277":"markdown","6a08577d":"markdown","735f76fa":"markdown","a53e7c6d":"markdown","71016bbc":"markdown","787662b0":"markdown","674a0462":"markdown","1c287e89":"markdown","bd6aa6ab":"markdown","6985a97c":"markdown"},"source":{"4b34de90":"import time\nimport gc\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport pandas as pd\nimport numpy as np\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\nfrom scipy.stats import mode\n\nSEED = 2311","26968670":"def compress(df):\n    numeric = ['int8', 'int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    \n    start_mem = df.memory_usage().sum() \/ (2 ** 20) #memory in MB\n    \n    for col in df.columns: \n        col_type = df[col].dtypes\n        \n        if col_type in numeric:\n            c_min, c_max = df[col].min(), df[col].max()\n            \n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)\n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    \n    end_mem = df.memory_usage().sum() \/ (2 ** 20)\n    percent_reduction = 100 * (start_mem - end_mem) \/ start_mem\n    \n    print(f'Memory usage decreased from {start_mem:5.2f} Mb to {end_mem:5.2f} Mb ({percent_reduction:.2f}% reduction)')\n    \n    return df","6f37c67f":"%%time\ntrain = compress(pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/train.csv'))\ntest = compress(pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/test.csv'))","da025476":"train.head()","64e91f20":"train.info()","a349d0a1":"train.shape, test.shape","1b9a459e":"train.isna().sum().sum(), test.isna().sum().sum()","e8a22268":"train['Cover_Type'].nunique(), train['Cover_Type'].unique()","2e595403":"train['Cover_Type'].value_counts()","a9c1a3b4":"features = [f for f in train.columns if f not in ('Id', 'Cover_Type', 'fold')]","f0576a9f":"train[features].var()","a966de71":"train['Soil_Type7'].var(), train['Soil_Type15'].var()","f8c94fba":"test['Soil_Type7'].var(), test['Soil_Type15'].var()","0fdadf70":"train.drop(['Soil_Type7', 'Soil_Type15'], axis=1, inplace=True)\ntest.drop(['Soil_Type7', 'Soil_Type15'], axis=1, inplace=True)\n\nfeatures.remove('Soil_Type7')\nfeatures.remove('Soil_Type15')","00d304f7":"corr = train[features + ['Cover_Type']].corr()","233b7eee":"corr['Cover_Type'].sort_values(ascending=False, key=lambda x: abs(x))[1:]","a10d1d76":"train['fold'] = -1\n\nskf_10 = StratifiedKFold(n_splits=10, shuffle=True, random_state=SEED)\n\nfor fold, (tid, vid) in enumerate(skf_10.split(X=train, y=train['Cover_Type'])):\n    train.loc[vid, 'fold'] = fold","b4763088":"compress(train).to_csv('tps-dec21-10folds.csv', index=False)","2c100d70":"train['fold'] = -1\n\nskf_5 = StratifiedKFold(n_splits=5, shuffle=True, random_state=SEED)\n\nfor fold, (tid, vid) in enumerate(skf_5.split(X=train, y=train['Cover_Type'])):\n    train.loc[vid, 'fold'] = fold","c74bad35":"compress(train).to_csv('tps-dec21-5folds.csv', index=False)","d2f3a627":"test.to_csv('compressed-test.csv', index=False)","7c1521a2":"gc.collect()","495a6b74":"N_SPLITS = 5\n\ndef custom_cross_val_predict(train, test, features):\n    oof_preds = {}\n    test_preds = []\n    scores = []\n    \n    cv_start = time.time()\n    \n    for fold in range(N_SPLITS):\n        xtrain = train[train.fold != fold].reset_index(drop=True)\n\n        xval = train[train.fold == fold].reset_index(drop=True)    \n        val_idx = xval.Id.values.tolist()\n        \n        fold_start = time.time()\n        \n        model = RandomForestClassifier(\n            n_estimators=50,\n            max_depth=10,\n            class_weight='balanced',\n            n_jobs=-1,\n            random_state=SEED\n        )\n        \n        model.fit(xtrain[features], xtrain.Cover_Type)\n        \n        val_preds = model.predict(xval[features])    \n        oof_preds.update(dict(zip(val_idx, val_preds)))\n        acc = accuracy_score(xval.Cover_Type, val_preds)\n        scores.append(acc)\n        \n        fold_end = time.time()\n        \n        print(f'Fold #{fold}: Accuracy = {acc:.5f}\\t[Time: {fold_end - fold_start:.2f} secs]')\n        \n        test_preds.append(model.predict(test[features]))\n        \n        del xtrain, xval, model\n        gc.collect()\n        \n    cv_end = time.time()\n    print(f'Average Accuracy = {np.mean(scores):.5f} with std. dev. = {np.std(scores):.5f}')\n    print(f'[Total time: {cv_end - cv_start:.2f} secs]')\n    \n    oof_preds = pd.DataFrame.from_dict(oof_preds, orient='index').reset_index()\n    \n    test_preds = mode(np.column_stack(test_preds), axis=1).mode\n    \n    return oof_preds, test_preds","3f4333b2":"oof_preds, test_preds = custom_cross_val_predict(train, test, features)","5d82c507":"oof_preds.columns = ['Id', 'oof1']\noof_preds.to_csv('oof1.csv', index=False)\n\noutput = pd.DataFrame({'Id': test.Id, 'Cover_Type': test_preds.ravel()})\noutput.to_csv('sub1.csv', index=False)\n\n!head sub1.csv","fb18a69e":"# Basic EDA","c03fb22a":"**Feature correlation with target variable:**","b3f8b88b":"**Feature variance:**","89f0226a":"**Time to submit!**","8d0e2b9b":"**Function for reducing memory usage:** *compress*","06848277":"# Imports","6a08577d":"### 5-folds","735f76fa":"**Target variable:**","a53e7c6d":"# Random Forest baseline","71016bbc":"### **Dataset:** [TPS Dec'21 Folds](https:\/\/www.kaggle.com\/stiwar1\/tps-dec21-folds)","787662b0":"**Missing values:**","674a0462":"# Creating folds","1c287e89":"We cannot compare variances without scaling the data but we can weed out features which have zero variance, since they would have no impact on the target variable.","bd6aa6ab":"Greatly imbalanced! We can explore SMOTE or class-weights to handle this imbalance later.","6985a97c":"### 10-folds"}}