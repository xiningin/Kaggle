{"cell_type":{"0e56753d":"code","d1aa33c3":"code","c69084bf":"code","fbcca21a":"code","87607cd7":"code","6301b821":"code","b4075abc":"code","85507100":"code","44052c0b":"code","2ced049c":"code","de25679c":"code","69fb8a8f":"code","aa3e2642":"code","df6d396c":"code","4659e48c":"code","ce2b7bf5":"code","fd9b5ab6":"code","b7a7705e":"code","77054c82":"code","6402f9ea":"code","b5a8d173":"code","99ccce37":"markdown","91d26b45":"markdown","8e728ff9":"markdown","d10427fb":"markdown"},"source":{"0e56753d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\ni=0\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        if i<1:\n            print(os.path.join(dirname, filename))\n        else:\n            pass\n        i+=1\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d1aa33c3":"import tensorflow as tf\ndevice_name = tf.test.gpu_device_name()\nif device_name != '\/device:GPU:0':\n  raise SystemError('GPU device not found')\nprint('Found GPU at: {}'.format(device_name))","c69084bf":"import pandas as pd\nimport numpy as np\nimport wfdb\nimport ast","fbcca21a":"path = \"\/kaggle\/input\/ptbxl-original-dataset\/ptb-xl-a-large-publicly-available-electrocardiography-dataset-1.0.1\/\"","87607cd7":"#Load Annotation data\nY =pd.read_csv(path+'ptbxl_database.csv', index_col='ecg_id')","6301b821":"Y.columns","b4075abc":"# Checkin meta data of a single patient\nY.iloc[0]","85507100":"# Evaluate data on scp_codes column\nY.scp_codes = Y.scp_codes.apply(lambda x: ast.literal_eval(x))","44052c0b":"#load ecg data for patient Y.iloc[0]\n# wfdb.rdsamp() returns actual signal data and data information \ntest_data,meta_data = wfdb.rdsamp(path+Y.iloc[0].filename_lr)","2ced049c":"meta_data","de25679c":"print(\"test_data contains data of {1} leads where each lead has {0} samples\".format(*test_data.shape))","69fb8a8f":"\ndef load_raw_data(df, sampling_rate, path):\n    # Loading all data with signal and meta information\n    if sampling_rate == 100:\n        data = [wfdb.rdsamp(path+f) for f in df.filename_lr]\n    else:\n        data = [wfdb.rdsamp(path+f) for f in df.filename_hr]\n    \n    # Eliminating meta information. We are selecting only signal value of 12 leads \n    data = np.array([signal for signal, meta in data])\n    return data\n\n\nsampling_rate=100\n\n# Load raw signal data\nX = load_raw_data(Y, sampling_rate, path)","aa3e2642":"X.shape","df6d396c":"print(\"X has total {0} records of {2} leads having {1} samples in each lead\".format(*X.shape))","4659e48c":"# Getting Superclass data\nagg_df = pd.read_csv(path+'scp_statements.csv', index_col=0)","ce2b7bf5":"# Let's check the columns\nagg_df.columns","fd9b5ab6":"# Checking Single Data\nagg_df.iloc[0]","b7a7705e":"# Only keep the rows that has agg_df.diagnostic == 1, this means diagnostinc report available\nagg_df = agg_df[agg_df.diagnostic == 1]","77054c82":"def aggregate_diagnostic(y_dic):\n    tmp = []\n    for key in y_dic.keys():\n        if key in agg_df.index:\n            tmp.append(agg_df.loc[key].diagnostic_class)\n    return list(set(tmp))\n\n# Apply diagnostic superclass\n\"\"\"\nIf the dict keys in Y.scp_codes are available in agg_diff index, put them in diagnostic_superclass\n - This means scp_statements.csv contains diagnostic class in the first column\n\"\"\"\nY['diagnostic_superclass'] = Y.scp_codes.apply(aggregate_diagnostic)","6402f9ea":"# Let's look at shape of X and Y data\nprint(X.shape, Y.shape)\nprint(\"This means that each ecg_id in Y has corresponding indetical signal in X\")","b5a8d173":"# let's pick an arbitrary signal and it's information from Y index_column\necg_record = 1239\nLead_II_data = X[ecg_record][1] # Index of Lead. It is available in meta_data information\necg_info = Y.iloc[ecg_record]\npd.DataFrame(Lead_II_data).plot()\nprint(ecg_info)","99ccce37":"## Let's load data using the provided example script example_physionet.py","91d26b45":"#### Meta data contains all informations about patient including the signal file names and patient_id. Using these informations, we can easily find signals for the specific patient_id.","8e728ff9":"## Adding diagnostic superclass to y data","d10427fb":"## Plotting A signle ECG example"}}