{"cell_type":{"b05a664b":"code","0b90a5b3":"code","8e40b451":"code","15a625a2":"code","c4571b80":"code","5ccd8d7d":"code","eb017df3":"code","f27abc2f":"code","3cd99476":"code","0b1cee37":"code","11d8489b":"code","0ed0ec69":"code","214bf61c":"code","4cc4b0d6":"code","321589ef":"code","4af9d2d9":"code","509933f7":"code","3b0cfc71":"code","401a1d0c":"markdown","d0faf96a":"markdown","e42c40a9":"markdown","02325427":"markdown","70a5602a":"markdown","69cb5cb9":"markdown","3ee51a24":"markdown","ff4d7fc5":"markdown","f7c992cb":"markdown","92b5f1c1":"markdown","ab174fb2":"markdown","d87eae59":"markdown","b6faf1a0":"markdown"},"source":{"b05a664b":"import pandas as pd\nimport numpy as np\nfrom sklearn.datasets import load_iris\n\nir = load_iris()\n# adding column names for iris data\niris = pd.DataFrame(ir.data, columns= (ir.feature_names))\niris.head()","0b90a5b3":"# removing two columns and going to work on other two columns\niris.drop(['sepal length (cm)','sepal width (cm)'], axis='columns',  inplace=True)\niris.head()","8e40b451":"from sklearn.preprocessing import MinMaxScaler\nfrom sklearn.cluster import KMeans\nimport matplotlib.pyplot as plt\n%matplotlib inline","15a625a2":"#scatter plot with existing data\nplt.scatter(iris['petal length (cm)'], iris['petal width (cm)'] )","c4571b80":"km = KMeans(n_clusters= 2)\nkm\ny_pre = km.fit_predict(iris[['petal length (cm)','petal width (cm)']])","5ccd8d7d":"# adding new column as cluster with predicted cluster data\niris['cluster'] = y_pre\niris.head()","eb017df3":"iris1 = iris[iris['cluster']==0] \niris2 = iris[iris['cluster']==1] ","f27abc2f":"plt.scatter(iris1['petal length (cm)'], iris1['petal width (cm)'] )\nplt.scatter(iris2['petal length (cm)'], iris2['petal width (cm)'] )","3cd99476":"scaler = MinMaxScaler()\nscaler.fit(iris[['petal width (cm)']])\niris['petal width (cm)'] = scaler.transform(iris[['petal width (cm)']])\n\n\nscaler = MinMaxScaler()\nscaler.fit(iris[['petal length (cm)']])\niris['petal length (cm)'] = scaler.transform(iris[['petal length (cm)']])\n\niris.head()","0b1cee37":"km = KMeans(n_clusters= 2)\nkm\ny_pre = km.fit_predict(iris[['petal length (cm)','petal width (cm)']])","11d8489b":"iris['cluster'] = y_pre\niris.head()","0ed0ec69":"iris1 = iris[iris['cluster']==0] \niris2 = iris[iris['cluster']==1] ","214bf61c":"plt.scatter(iris1['petal length (cm)'], iris1['petal width (cm)'], label = 'petal width (cm)' )\nplt.scatter(iris2['petal length (cm)'], iris2['petal width (cm)'], label = 'petal width (cm)')\nplt.legend()","4cc4b0d6":"# to check centroid values for clusters \nkm.cluster_centers_","321589ef":"plt.figure(figsize = (12,6))\nplt.scatter(iris1['petal length (cm)'], iris1['petal width (cm)'], label = 'petal width (cm)' )\nplt.scatter(iris2['petal length (cm)'], iris2['petal width (cm)'], label = 'petal width (cm)')\nplt.scatter(km.cluster_centers_[:,0], km.cluster_centers_[:,1] , color = 'r', marker = '*', label ='centroid', s = 100 )\nplt.legend()","4af9d2d9":"k_rng = range(1,10)\nssr = []\nfor k in k_rng:\n    km = KMeans(n_clusters= k)\n    km.fit(iris)\n    ssr.append(km.inertia_)","509933f7":"# to see ssr values\nssr","3b0cfc71":"plt.figure(figsize = (12,6))\nplt.plot(k_rng, ssr)\nplt.ylabel('sum of squared error', fontsize = 14)\nplt.xlabel('Range', fontsize = 14)","401a1d0c":"K Means Clustering","d0faf96a":"Scatter Plot with cluster data","e42c40a9":"creating diffrenct dataframes with cluster data","02325427":"After checking above plot we need to adjust scalling and below scalling for two columns.","70a5602a":"After checking above plot we can decide it as two clusters and preparing model","69cb5cb9":"Adding centroids for each clusters in scatter plot","3ee51a24":"model with scalling data","ff4d7fc5":"sum of squared error and Elbow - criterion:","f7c992cb":"Feel free to comment with suggestions or any clarifications for further active discussions. \n\nName: Mahesh Kumar\ne-mailid: mcommahesh@gmail.com\n","92b5f1c1":"In the above plot no. of opitimal clusters are 3 that means K =3","ab174fb2":"Scatter Plot with cluster scalling data","d87eae59":"So the goal is to choose a small value of k that still has a low SSE, and the elbow usually represents where we start to have diminishing returns by increasing k","b6faf1a0":"creating diffrenct dataframes with cluster scalling data"}}