{"cell_type":{"8fccd8cb":"code","a2216beb":"code","f4a8ad66":"code","ae4864ef":"code","d50f46b3":"code","40449a7a":"code","69f9faf5":"code","97a00cb7":"code","46afbc03":"code","5527db89":"code","bf4c5c4b":"code","1c50071d":"code","8b664986":"code","f0c27474":"code","09b95f6c":"code","15656fea":"code","a1cd23b7":"code","1939e61c":"code","2e308379":"code","0b0b8ab7":"code","189939d3":"code","7aaf27b8":"markdown","6cceb35a":"markdown","339aea81":"markdown","d05c0d67":"markdown","ef8f6801":"markdown","5bfa3b52":"markdown","d9275455":"markdown","e573f0fa":"markdown","d8622761":"markdown","a10c0857":"markdown","79e95c97":"markdown","de6ffc10":"markdown","32fb2472":"markdown"},"source":{"8fccd8cb":"import math\nimport numpy as np\nimport pandas as pd\nimport time\nfrom sklearn.svm import SVC\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.decomposition import PCA\nimport cv2\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.neighbors import KNeighborsClassifier","a2216beb":"df = pd.read_csv('\/kaggle\/input\/fer2013\/fer2013.csv')","f4a8ad66":"df.head()","ae4864ef":"emotion_label_to_text = {0:'anger', 1:'disgust', 2:'fear', 3:'happiness', 4: 'sadness', 5: 'surprise', 6: 'neutral'}","d50f46b3":"df.emotion.value_counts()","40449a7a":"fig = plt.figure(1, (14, 14))\n\nk = 0\nfor label in sorted(df.emotion.unique()):\n    for j in range(1):\n        px = df[df.emotion==label].pixels.iloc[k]\n        px = np.array(px.split(' ')).reshape(48, 48).astype('float32')\n\n        k += 1\n        ax = plt.subplot(7, 7, k)\n        ax.imshow(px , cmap='gray')\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_title(emotion_label_to_text[label])\n        plt.tight_layout()","69f9faf5":"X = df.pixels.apply(lambda x: np.array(x.split(' ')).astype('float32'))\nX = np.stack(X, axis=0)\nY = np.array(df['emotion'])","97a00cb7":"X.shape","46afbc03":"Y.shape","5527db89":"face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\neye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_eye.xml')","bf4c5c4b":"def face_align(gray):\n  sz = gray.shape\n  # Creating variable eyes\n  eyes = eye_cascade.detectMultiScale(gray, 1.3, 5)\n  if len(eyes) > 1 :\n    index=0\n    # Creating for loop in order to divide one eye from another\n    for (ex , ey,  ew,  eh) in eyes:\n      if index == 0:\n        eye_1 = (ex, ey, ew, eh)\n      elif index == 1:\n        eye_2 = (ex, ey, ew, eh)\n      index += 1\n    if eye_1[0] < eye_2[0]:\n      left_eye = eye_1\n      right_eye = eye_2\n    else:\n      left_eye = eye_2\n      right_eye = eye_1\n        \n    # Calculating coordinates of a central points of the rectangles\n    left_eye_center = (int(left_eye[0] + (left_eye[2] \/ 2)), int(left_eye[1] + (left_eye[3] \/ 2)))\n    left_eye_x = left_eye_center[0] \n    left_eye_y = left_eye_center[1]\n        \n    right_eye_center = (int(right_eye[0] + (right_eye[2]\/2)), int(right_eye[1] + (right_eye[3]\/2)))\n    right_eye_x = right_eye_center[0]\n    right_eye_y = right_eye_center[1]\n\n    if left_eye_y > right_eye_y:\n      A = (right_eye_x, left_eye_y)\n      # Integer -1 indicates that the image will rotate in the clockwise direction\n      direction = -1 \n    else:\n      A = (left_eye_x, right_eye_y)\n      # Integer 1 indicates that image will rotate in the counter clockwise direction\n      direction = 1 \n        \n    delta_x = right_eye_x - left_eye_x\n    delta_y = right_eye_y - left_eye_y\n    angle=np.arctan(delta_y\/delta_x)\n    angle = (angle * 180) \/ np.pi\n\n    # Width and height of the image\n    h, w = gray.shape[:2]\n    # Calculating a center point of the image\n    # Integer division \"\/\/\"\" ensures that we receive whole numbers\n    center = (w \/\/ 2, h \/\/ 2)\n    # Defining a matrix M and calling\n    # cv2.getRotationMatrix2D method\n    M = cv2.getRotationMatrix2D(center, (angle), 1.0)\n    # Applying the rotation to our image using the\n    # cv2.warpAffine method\n    gray = cv2.warpAffine(gray, M, (w, h))\n\n    #Again detecting face\n    faces = face_cascade.detectMultiScale(gray, 1.3, 5)\n    if len(faces) > 0 : \n      (x,y,w,h) = faces[0]\n      gray = gray[y:y+h, x:x+w]\n\n  gray = cv2.resize(gray,sz) \n  return gray","1c50071d":"X_new = []\nfor j in range(X.shape[0]):\n  px = np.array(X[j]).reshape(48,48)\n  px = np.array(px, dtype='uint8')\n  px = face_align(px)\n  X_new.append(np.array(px).reshape(48*48))\nX = np.array(X_new)","8b664986":"# Plot confusion matrix \n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ndef create_confmat(true_labels, predicted_labels, columns, colour = 'Greens', size = (20,14)):\n    sns.set(font_scale=1.5)\n    cm = confusion_matrix(true_labels, predicted_labels) \n    cm_df = pd.DataFrame(cm,\n    index = [col for col in columns], \n    columns = [col for col in columns])\n    plt.figure(figsize=(18,16))\n    sns.heatmap(cm_df, annot = True, cmap = colour, fmt='g', linewidths=.2)\n    plt.title('Confusion Matrix', fontsize = 20)\n    plt.ylabel('True label', fontsize = 18)\n    plt.xlabel('Predicted label', fontsize = 18)\n    plt.tick_params(axis='both', labelsize=14)\n    plt.show()","f0c27474":"X_train, X_valid, y_train, y_valid = train_test_split(X, Y,\n                                                    shuffle=True, stratify=Y,\n                                                    test_size=0.2, random_state=2)\nX_train.shape, X_valid.shape, y_train.shape, y_valid.shape","09b95f6c":"scaler = StandardScaler()\nX_train = scaler.fit_transform(X_train.astype(np.float32))\nX_valid = scaler.transform(X_valid.astype(np.float32))\npca = PCA(n_components=.95)\npca.fit(X_train)\nX_test_p = pca.transform(X_valid)\nX_train_p = pca.transform(X_train)\nscaler = StandardScaler()\nX_train_p = scaler.fit_transform(X_train_p.astype(np.float32))\nX_test_p = scaler.transform(X_test_p.astype(np.float32))\nX_train_p.shape ,X_test_p.shape \n","15656fea":"model = SVC(kernel = 'linear')\nmodel.fit(X_train_p,y_train)\nmodel.score(X_test_p , y_valid)","a1cd23b7":"model = SVC(kernel ='rbf')\nmodel.fit(X_train_p,y_train)\nmodel.score(X_test_p , y_valid)","1939e61c":"from sklearn.neighbors import KNeighborsClassifier\nclassifier = KNeighborsClassifier(n_neighbors=1)\nclassifier.fit(X_train, y_train)\nclassifier.score(X_valid,y_valid)","2e308379":"start_time = time.time()\ny_pred = classifier.predict(X_valid)\nprint(\"Time Taken : %s seconds \" % (time.time() - start_time))","0b0b8ab7":"cnt = 0\nfor i in range(X_valid.shape[0]):\n   cnt += y_pred[i] == y_valid[i]\nprint(\"Accuracy :\", cnt\/X_valid.shape[0]*100, \"%\")","189939d3":"knn = KNeighborsClassifier()\nknn.fit(X_train_p ,y_train)\nknn.score(X_test_p,y_valid)","7aaf27b8":"### Input and Output Data","6cceb35a":"#### Confusion Matrix","339aea81":"### Visualize Dataset","d05c0d67":"# Preprocessing\nFace Alignment ","ef8f6801":"# KNN","5bfa3b52":"####Using Linear kernel","d9275455":"# SVM","e573f0fa":"### Importing Dataset","d8622761":"###PCA to retain 95% variation and reduce dataset size","a10c0857":"####KNN using default parameters","79e95c97":"####Using rbf kernel","de6ffc10":"### Importing Libraries","32fb2472":"### Train and Test Split for KNN and SVM\n"}}