{"cell_type":{"c15d7ccf":"code","45b94ced":"code","30d51b98":"code","1f270dd8":"code","b572a3b5":"code","b4991053":"code","ea78d784":"code","64acbb24":"code","ffcc0159":"code","aaf8d57b":"code","319f67cd":"code","3febc821":"code","c735b0de":"code","65ab0a1e":"code","1c2ff495":"code","75bf8b13":"code","cc4a91ce":"code","bc0d2884":"code","746b56b2":"code","819770d9":"code","63172457":"code","b8528f4f":"code","f03fba43":"code","45c843d5":"code","84be9c74":"code","6e1ddf06":"code","56ee137d":"code","c440d561":"code","a69c8b91":"code","1147ac52":"code","eed1e2d1":"code","80156fd1":"code","bc0a08c4":"code","53ce61d6":"code","8ebd1cc7":"code","8a425a12":"code","108b73a0":"code","a96b9af2":"code","69e7364c":"code","b89fc501":"code","d930c9da":"code","b62ad113":"code","3bbc0d60":"code","b1bc3155":"markdown","0bbbfa8d":"markdown","240baf1c":"markdown","e124ddfd":"markdown","0071209e":"markdown","65355d9c":"markdown","2b1148c3":"markdown","414ac9ec":"markdown","3f9712d3":"markdown","01529292":"markdown","c860f3c3":"markdown","4e509eef":"markdown","be8d3ac0":"markdown","503b7b27":"markdown","51390a73":"markdown","0f52b79a":"markdown","2e090350":"markdown","c07f012e":"markdown","b928748b":"markdown","a1f25923":"markdown","2da7738a":"markdown","f3e572c1":"markdown","31831f59":"markdown","4ef24e93":"markdown","4c9e5869":"markdown","1b495420":"markdown","ef1c2eb4":"markdown","a12ebf29":"markdown","5d642dbb":"markdown","d3f66de9":"markdown","f3a60c5e":"markdown","95c63837":"markdown","8f8bc146":"markdown","55e3a45a":"markdown","8212f59f":"markdown","8fe677cf":"markdown","a8cc8642":"markdown","e29a9ac3":"markdown","55c4604f":"markdown","1ec1bb7f":"markdown","efe3a1ad":"markdown"},"source":{"c15d7ccf":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.preprocessing import StandardScaler\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n%matplotlib inline\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","45b94ced":"df_S = pd.read_csv(\"..\/input\/spotify-dataset-19212020-160k-tracks\/data.csv\")\ndf_G = pd.read_csv(\"..\/input\/spotify-dataset-19212020-160k-tracks\/data_by_genres.csv\")\ndf_A = pd.read_csv(\"..\/input\/spotify-dataset-19212020-160k-tracks\/data_w_genres.csv\")\ndf_G = df_G.drop(index=1)\ndf_A = df_A[df_A['genres']!='[]']\ndf_A = df_A.reset_index().drop(['index'], axis = 1)","30d51b98":"genres1 = []\nfor i in range(len(df_S.index)):\n    genres1.append([])\n\ndf_S['genres'] = genres1","1f270dd8":"df_S.head()","b572a3b5":"df_A.head()","b4991053":"df_G.head()","ea78d784":"artistList = df_A['artists'].tolist()\nfor i in range(len(artistList)):\n    artistList[i] = artistList[i].replace(\" \",\"\")\n    \nsongArtists0 = df_S['artists'].tolist()\nfor i in range(len(songArtists0)):\n    songArtists0[i] = songArtists0[i].replace(\" \",\"\")\n    \nsongArtists = []\nfor i in range(len(songArtists0)):\n    artist = songArtists0[i].replace('[','').replace(']','').split(',')\n    for j in range(len(artist)):\n        artist[j] = artist[j].replace(\"'\",\"\")\n    songArtists.append(artist)\n    \nabsentArtists = []    \nfor i in range(len(songArtists)):\n    for j in range(len(songArtists[i])):\n        if not(songArtists[i][j] in artistList):\n            absentArtists.append(songArtists[i][j])\n","64acbb24":"df_S['artists'] = songArtists\n\npresentArtist = []\nfor i in range(len(df_S)):\n    print(i)\n    artsong = df_S.iloc[i,1]\n    for j in range(len(artsong)):\n        realArtists = []\n        if not(artsong[j] in absentArtists):\n            realArtists.append(artsong[j])\n    presentArtist.append(realArtists)\nA = presentArtist    \n        \n            ","ffcc0159":"df_S['artists'] = A\nnew_df_S = df_S\nL = df_S['artists'].tolist()\nfor i in range(len(df_S)):\n    print(i)\n    if L[i] == []:\n        new_df_S = new_df_S.drop(index=i)","aaf8d57b":"artistList2 = []\nfor i in range(len(artistList)):\n    artistList2.append(artistList[i].replace(\"'\",\"\"))\ndf_A['artists'] = artistList2","319f67cd":"# union(A,B): list(any) , list(any) -> list(any)\n# elle re\u00e7oit deux listes et les r\u00e9unit sans dupliquer les \u00e9l\u00e9ments qui se trouvent sur les deux listes.\n# ex: L1 = [1,2,3], L2 = [2,3,4] -> union(L1,L2) = [1,2,3,4]\ndef union(A,B):\n    C = A\n    for i in range(len(B)):\n        if not( B[i] in A):\n            C.append(B[i])\n    return C","3febc821":"df_S2 = new_df_S.reset_index().drop(['index'], axis = 1)\nsongArtist2 = df_S2['artists'].tolist()\n\nsongGenres = []\nfor i in range(len(songArtist2)):\n    print(i)\n    auxgen = []\n    for j in range(len(songArtist2[i])):\n        artistName = songArtist2[i][j]\n        strGenre = df_A[df_A['artists'] == artistName]['genres'].tolist()[0]\n        auxlist = strGenre.replace(\"[\",\"\").replace(\"]\",\"\").replace(\"'\",\"\").split(\",\")\n        auxgen = union(auxgen,auxlist)\n    songGenres.append(auxgen)\n","c735b0de":"songGenres","65ab0a1e":"for i in range(len(songGenres)):\n    for j in range(len(songGenres[i])):\n        if songGenres[i][j][0] == ' ':\n            songGenres[i][j] = songGenres[i][j][1:]\nsongGenres   ","1c2ff495":"df_S2['genres'] = songGenres","75bf8b13":"artistGenres = []\nfor i in range(len(df_A)):\n    auxgen = df_A['genres'].tolist()[i].replace(\"[\",\"\").replace(\"]\",\"\").replace(\"'\",\"\").split(\",\")\n    artistGenres.append(auxgen)\n","cc4a91ce":"artistGenres","bc0d2884":"for i in range(len(artistGenres)):\n    for j in range(len(artistGenres[i])):\n        if artistGenres[i][j][0] == ' ':\n            artistGenres[i][j] = artistGenres[i][j][1:]\nartistGenres    ","746b56b2":"technical = ['acousticness','danceability','energy','instrumentalness',\n 'key','liveness','loudness','mode','speechiness',\n 'tempo','valence']\n\nsongValues = df_S2[technical]\nartistValues = df_A[technical]\ngenreValues = df_G[technical]\n","819770d9":"# normalizeVectors: list(list(float)) -> nparray(nparray(float))\n# ll re\u00e7oit une liste python o\u00f9 chaque \u00e9l\u00e9ment est une liste de nombres r\u00e9els (float), il retourne un nparray \n# (matrice de m\u00eame dimension) avec les vecteurs normalis\u00e9s (chaque vecteur est soustrait de sa moyenne \n# et divis\u00e9 par son \u00e9cart-type).\n\ndef normalizeVectors(M):\n    ncol = len(M.columns)\n    nM = np.zeros([len(M),ncol])\n    for i in range(ncol):\n        nM[:,i] = (np.array(M.iloc[:,i].tolist()) - np.array(M.iloc[:,i].tolist()).mean()) \/ np.array(M.iloc[:,i].tolist()).std()\n    return nM","63172457":"song_data = normalizeVectors(songValues)\nartist_data = normalizeVectors(artistValues)\ngenre_data = normalizeVectors(genreValues)","b8528f4f":"song_data","f03fba43":"# math: nparray(float), nparray(float) -> float\n# re\u00e7oit deux vecteurs, renvoie la distance entre ceux-ci.\n\nimport math\ndef dist(u,v):\n    dif = u - v\n    res = 0\n    for i in range(len(dif)):\n        res += dif[i]**2\n    return math.sqrt(res)\n","45c843d5":"# closest_index: array(float), array(array(float)), int -> array(int)\n# re\u00e7oit un vecteur, une liste de vecteurs et un entier \"n\", renvoie les indexes des \"n\" vecteurs de la liste \n# la plus proche du premier vecteur livr\u00e9.\n\ndef closest_index(song,songList,n):\n    distances = []\n    for i in range(len(songList)):\n        distances.append(dist(song,songList[i]))\n    closest_index = []\n    maxD = max(distances)\n    for i in range(n):\n        minD = min(distances)\n        indexMin = distances.index(minD)\n        closest_index.append(indexMin)\n        distances[indexMin] = maxD\n    return closest_index\n    ","84be9c74":"df_S2[df_S2['name']=='Creep'].head(2)","6e1ddf06":"creep = song_data[24998]\ncreep_rec = closest_index(creep, song_data, 5)\ncreep_rec","56ee137d":"df_S2.iloc[creep_rec,:]","c440d561":"#songGenres\n#artistGenres\nlistGenres = []\nfor i in range(len(artistGenres)):\n    listGenres = union(listGenres,artistGenres[i])\nlistGenres","a69c8b91":"# filter_by_genre: array(str), array(int), int -> array(int)\n# Il re\u00e7oit une liste des genres d'une chanson, une liste des index des chansons \u00e0 filtrer et un nombre \n# entier \"n\". Il renvoie une liste avec les index (par rapport \u00e0 la deuxi\u00e8me liste livr\u00e9e) des chansons qui \n# ont au moins \"n\" genres en commun avec la liste des genres livr\u00e9s.\n\ndef filter_by_genre(genreList,songList_ind,n): #return indexes\n    filtered_index = []\n    for i in range(len(songList_ind)):\n        genresTestedSong = df_S2.iloc[i,-1]\n        counter = 0\n        for j in range(len(genresTestedSong)):\n            if genresTestedSong[j] in genreList:\n                counter += 1\n        if counter >= n:\n            filtered_index.append(songList_ind[i])\n    return filtered_index\n","1147ac52":"genresCreep = df_S2.iloc[24998,:]['genres']\nfilteredCreep = filter_by_genre(genresCreep,range(len(df_S2)),len(genresCreep)-2)\nfilteredCreep","eed1e2d1":"df_S2.iloc[filteredCreep,[1,12,19]]","80156fd1":"# subList: list(any), list(int) -> list(any)\n# re\u00e7oit une liste de quoi que ce soit et une liste d'index de la liste pr\u00e9c\u00e9dente, il renvoie une sous-liste \n# de la premi\u00e8re selon les index livr\u00e9s.\n\ndef subList(List,IndexList):\n    sub = []\n    for i in range(len(IndexList)):\n        sub.append(List[IndexList[i]])\n    return sub\n","bc0a08c4":"closest_to_creep_data = subList(song_data,filteredCreep)\nclosest_to_creep_data","53ce61d6":"creep_index = closest_index(creep,closest_to_creep_data,10)\ncreep_index","8ebd1cc7":"real_index = subList(filteredCreep,creep_index)\nreal_index","8a425a12":"df_S2.iloc[real_index,[1,12,19]]","108b73a0":"# filter_artist: str, array(int) -> array(int)\n#re\u00e7oit un artiste (sous forme de \"str\") et une liste d'index de chansons, renvoie une sous-liste de la premi\u00e8re \n# o\u00f9 ne se trouvent que les index des chansons auxquelles l'artiste livr\u00e9 ne participe pas.\n\ndef filter_artist(artist,songList_ind): #return indexes\n    filtered_index = []\n    for i in range(len(songList_ind)):\n        if not(artist in df_S2.iloc[songList_ind[i],1]):\n            filtered_index.append(songList_ind[i])\n    return filtered_index\n    ","a96b9af2":"real_index2 = filter_artist('Radiohead',real_index)\nreal_index2\n","69e7364c":"df_S2.iloc[real_index2,[1,12,19]]","b89fc501":"# voirTableauParChanson: str -> None\n# re\u00e7oit le nom d'une chanson, imprime \u00e0 l'\u00e9cran les index et les artistes des chansons qui sont ainsi appel\u00e9es.\n\ndef voirTableauParChanson(nom):\n    print(df_S2[df_S2['name'] == nom].iloc[:,[1,12]])\n    \nvoirTableauParChanson('Last Kiss')","d930c9da":"songList = df_S2['name'].tolist()","b62ad113":"# searchSong: None -> None\n# programme interactif de recommandation de chansons Spotify\n\ndef searchSong():\n    print(\"Bienvenue dans le programme interactif de recommandation de musique de Spotify\")\n    print(\"Entrez le nom d'une chanson:\")\n    nom = input()\n    if not(nom in songList):\n        print(\"Nom invalide\")\n    print(\"Sauvegarder l'index de la chanson souhait\u00e9e\")\n    voirTableauParChanson(nom)\n    print(\"Saisissez l'index souhait\u00e9\")\n    indSong = int(input())\n    dataSong = song_data[indSong]\n    genresSong = songGenres[indSong]\n    artist_of_song = df_S2.iloc[indSong,:]['artists'][0]\n    print(\"Combien de genres musicaux de diff\u00e9rance voulez-vous ?\")\n    ngen = int(input())\n    filteredIndex = filter_by_genre(genresSong,range(len(songList)),len(genresSong)-ngen)\n    filtered_vectors = subList(song_data,filteredIndex)\n    print(\"Combien de recommandations voulez-vous ?\")\n    nrec = int(input())\n    index2 = closest_index(dataSong,filtered_vectors,nrec)\n    index3 = subList(filteredIndex,index2)\n    print(\"Vous souhaitez supprimer des chansons d'un m\u00eame artiste ? (1 : oui \/ toute cl\u00e9 : non)\")\n    memeArt = input()\n    if memeArt == '1':\n        index4 = filter_artist(artist_of_song,index3)\n        print(df_S2.iloc[index4,[1,12]])\n    else:\n        print(df_S2.iloc[index3,[1,12]])\n        \n    return\n   \n    ","3bbc0d60":"searchSong()","b1bc3155":"Tout d'abord, l'index de la chanson est recherch\u00e9 dans df_S2.","0bbbfa8d":"Cr\u00e9ation d'une fonction de filtrage par genre musical","240baf1c":"## Construction de l'algorithme.","e124ddfd":"Les r\u00e9sultats sont affich\u00e9s. on peut voir qu'il s'agit de r\u00e9sultats relativement coh\u00e9rents, les genres musicaux n'\u00e9tant pas si \u00e9loign\u00e9s, mais cela pourrait \u00eatre bien mieux. \n\nPour cela, on proc\u00e9de \u00e0 la mise en place d'un filtre par genre.","0071209e":"## Programme de recommandation musicale","65355d9c":"Pour tester le programme, on peut ex\u00e9cuter la cellule suivante.","2b1148c3":"Ensuite, une liste des genres de chaque artiste est cr\u00e9\u00e9e (\u00e0 partir de df_A), en travaillant les donn\u00e9es du texte comme auparavant (supprimer les guillemets, les parenth\u00e8ses, etc.). Ces informations sont sauvegard\u00e9es dans artistGenres (comme toujours, en sauvegardant les m\u00eames index que son homologue \"dataframe\").","414ac9ec":"Pour continuer avec l'exemple, Radiohead est filtr\u00e9 \u00e0 partir des index (real_index) des chansons pr\u00e9c\u00e9demment filtr\u00e9es. Ces nouveaux indices sont enregistr\u00e9s dans real_index2","3f9712d3":"# Syst\u00e8me de Recommandation de Musique Spotify","01529292":"Ensuite, les index (par rapport \u00e0 la liste nouvellement cr\u00e9\u00e9e) des 10 chansons les plus proches de Creep sont sauvegard\u00e9s (dans une liste appel\u00e9e creep_index). ","c860f3c3":"Cr\u00e9ation de la fonction \"closest_index\":","4e509eef":"Pour visualiser comment l'algorithme est cr\u00e9\u00e9 et comment les fonctions sont utilis\u00e9es, la chanson \"Creep\" de Radiohead est utilis\u00e9e comme exemple.\n\n","be8d3ac0":"Enfin, les r\u00e9sultats obtenus sont indiqu\u00e9s (uniquement les informations pertinentes). On peut maintenant v\u00e9rifier une recommandation acceptable (au moins pour \"Creep\").","503b7b27":"On cr\u00e9e d'abord une liste qui contient les noms des colonnes de la \"dataframe\" qui contiennent des informations techniques sur les chansons, les artistes et les genres. A partir de l\u00e0, 3 dataframes sont cr\u00e9\u00e9es (songValues, artistValues et genreValues) qui contiennent uniquement les donn\u00e9es techniques de chaque dataframe, dans le m\u00eame ordre et en conservant les index des donn\u00e9es de leurs dataframes pr\u00e9c\u00e9dentes.","51390a73":"Une fois que les donn\u00e9es sont pr\u00eates, l'algorithme de recommandation des chansons commence \u00e0 \u00eatre construit.\n\n","0f52b79a":"Le but est maintenant de cr\u00e9er une liste contenant les genres de chaque chanson (puisque la base de donn\u00e9es import\u00e9e ne poss\u00e8de pas les chansons class\u00e9es par genre, ce qui rend tr\u00e8s difficile la cr\u00e9ation du programme de classification). \nD'abord, on ajoute les donn\u00e9es des artistes arrang\u00e9s dans df_S2 (copie de df_S1, \u00e0 partir d'ici on travail avec celui-ci), et de m\u00eame pour la liste des chansons (qui est sauvegard\u00e9e dans songArtist2), ceci est fait pour mettre \u00e0 jour les index des artistes et garder le m\u00eame ordre.\n\nEnfin, en it\u00e9rant sur les listes travaill\u00e9es, il est possible de cr\u00e9er la liste songGenres, o\u00f9 chaque \u00e9l\u00e9ment correspond \u00e0 la liste des genres d'une chanson (pour chaque chanson). Cela a \u00e9t\u00e9 fait en attribuant \u00e0 chaque chanson les genres des artistes qui y participent (donn\u00e9es pr\u00e9sentes dans df_A).\n\nIl s'agit \u00e9galement d'un algorithme co\u00fbteux, alors l'index est aussi imprim\u00e9 pour voir sa progression.","2e090350":"Les citations sont supprim\u00e9es des noms dans la liste des artistes et la colonne des noms d'artistes dans df_A est mise \u00e0 jour.","c07f012e":"Ensuite, \"creep\" repr\u00e9sente le vecteur normalis\u00e9 de la chanson, tir\u00e9 de song_data. Ensuite, les index des 5 chansons les plus proches de Creep de la liste song_data sont enregistr\u00e9s dans creep_rec (ces index repr\u00e9sentent donc directement les index des chansons dans df_S2).","b928748b":"Ici on peut voir songGenres","a1f25923":"Une fonction auxiliaire est cr\u00e9\u00e9e pour normaliser les vecteurs d'information. Cela est fait parce qu'un des crit\u00e8res \u00e0 utiliser pour d\u00e9terminer la proximit\u00e9 entre les chansons sera la distance entre les vecteurs de donn\u00e9es techniques de celles-ci, il est donc n\u00e9cessaire de normaliser les vecteurs car sinon, les donn\u00e9es n'auraient pas le m\u00eame poids.","2da7738a":"## Traitement des donn\u00e9es","f3e572c1":"Une fonction auxilaire est cr\u00e9\u00e9e pour joindre les listes sans r\u00e9p\u00e9ter les \u00e9l\u00e9ments.","31831f59":"Ensuite, on travaille sur les donn\u00e9es des artistes dans df_S et df_A : leurs noms sont standardis\u00e9s. Dans df_A, les espaces sont supprim\u00e9s et les guillemets dans les noms des artistes sont fixes, tandis que dans df_S, la m\u00eame chose est faite, mais en plus, les noms des artistes participant \u00e0 une chanson sont \u00e9galement entr\u00e9s dans une liste (pour chaque chanson, les donn\u00e9es sont transform\u00e9es comme : \"[x,y,z]\" -> [\"x\",\"y\",\"z\"]).\n\nCes donn\u00e9es sont stock\u00e9es dans des listes : artistList pour les artistes df_A et songArtist pour les artistes de chaque chanson df_S (tout cela en gardant le m\u00eame ordre que leurs \"dataframes\").\n\nEn outre, il arrive aussi qu'il y ait plus d'artistes dans df_S (qui participent aux chansons) que dans df_A (naturellement, puisqu'il y a beaucoup d'artistes qui participent seulement aux chansons mais qui n'ont pas leurs propres chansons ou ne sont simplement pas enregistr\u00e9s). Pour rem\u00e9dier \u00e0 cela, \u00e0 partir des listes ci-dessus, une liste appel\u00e9e AbsentArtistes est cr\u00e9\u00e9e qui correspond aux artistes de df_S qui ne sont pas enregistr\u00e9s dans df_A. ","4ef24e93":"Finalement, les r\u00e9sultats sont imprim\u00e9s, ils sont bien meilleurs.","4c9e5869":"Enfin, un programme interactif est cr\u00e9\u00e9, dans lequel tout ce qui est montr\u00e9 ci-dessus est appliqu\u00e9 : d'abord, l'utilisateur doit \u00e9crire le nom de la chanson (correctement), ensuite le programme imprime un tableau avec les index et les artistes des chansons qui sont ainsi appel\u00e9es, puis l'utilisateur doit choisir la chanson qu'il veut et entrer son index. Il sera ensuite demand\u00e9 \u00e0 l'utilisateur combien de genres de diff\u00e9rence il souhaite que les chansons aient (par rapport \u00e0 la chanson livr\u00e9e), par exemple s'il en livre 0, les chansons livr\u00e9es auront toutes les m\u00eames genres que la chanson choisie par l'utilisateur, s'il en place 2, les chansons livr\u00e9es peuvent avoir jusqu'\u00e0 2 genres de diff\u00e9rence (il est recommand\u00e9 de ne pas en placer plus de 2). Ensuite, on demande \u00e0 l'utilisateur jusqu'\u00e0 combien de recommandations il veut et enfin on lui demande s'il veut \u00e9liminer les recommandations qui ont le m\u00eame artiste.","1b495420":"## Importation de donn\u00e9es","ef1c2eb4":"Cependant, ces index ne sont pas les vrais (ceux de df_S2), doncon r\u00e9cupere les index r\u00e9els avec subList dans \"real_index\".","a12ebf29":"Une colonne \"genres\" est ensuite ajout\u00e9e \u00e0 df_S, assignant \u00e0 chaque chanson une liste vide.","5d642dbb":"Ensuite, on rappelle que song_data poss\u00e8de les vecteurs d'information standardis\u00e9s de toutes les chansons, donc avec la fonction auxiliaire subList on peut prendre seulement (et dans l'ordre d\u00e9sir\u00e9) les donn\u00e9es des chansons des index de filteredCreep. Ces informations sont stock\u00e9es dans la liste \"closest_to_creep_data\":","d3f66de9":"La fonction est appliqu\u00e9e aux \"dataframes\" nouvellement cr\u00e9\u00e9es et enregistr\u00e9es dans 3 listes diff\u00e9rentes.","f3a60c5e":"Toutefois, il serait peut-\u00eatre pr\u00e9f\u00e9rable que le programme ne recommande pas des chansons du m\u00eame artiste que celui qu'on utilise comme r\u00e9f\u00e9rence, car g\u00e9n\u00e9ralement, une personne qui veut conna\u00eetre la musique pr\u00e9f\u00e8re qu'on lui montre quelque chose qui n'est pas du m\u00eame artiste (cela pourrait \u00eatre fait par lui-m\u00eame).\n\n","95c63837":"Les donn\u00e9es sont d'abord import\u00e9es et enregistr\u00e9es dans 3 \"dataframes\" diff\u00e9rents : df_S, df_A et df_G. Dans chacun d'eux, on dispose d'informations techniques en fonction des chansons, des artistes et des genres respectivement. Ensuite, le genre \"[]\" (qui correspond au vide) est supprim\u00e9 de df_A et df_G.","8f8bc146":"Pour suivre l'exemple,on prend les genres de Creep, et avec ceux-cion filtre sur toutes les chansons en ne gardant que celles qui n'ont pas plus de 2 genres de diff\u00e9rence. Les index des chansons sont sauvegard\u00e9s dans filteredCreep\n\nSeules les informations pertinentes sont affich\u00e9es.","55e3a45a":"Cette liste, est ajout\u00e9e sur la colonne \"genres\" qui a \u00e9t\u00e9 pr\u00e9c\u00e9demment cr\u00e9\u00e9e sur df_S (df_S2 dans ce cas).","8212f59f":"Ensuite, la colonne \"artistes\" de df_S est mise \u00e0 jour avec la liste presentArtist nouvellement cr\u00e9\u00e9e et toutes les chansons qui n'ont plus d'artistes sont supprim\u00e9es.","8fe677cf":"Cr\u00e9ation d'une fonction auxiliaire de sous-liste.","a8cc8642":"Ensuite, \u00e0 partir de ce qui pr\u00e9c\u00e8de, onpeut cr\u00e9er la liste presentArtist qui correspond \u00e0 la liste o\u00f9 chaque \u00e9l\u00e9ment correspond \u00e0 la liste des artistes participant \u00e0 une chanson (pour toutes les chansons en df_S), sauf que on ne garde que les artistes qui sont en df_A.\n\nCet algorithme est tr\u00e8s co\u00fbteux car il a un ordre de : (longueur des chansons (160k+) * longueur de la liste des artistes de chaque chanson (~[1;4]) * longueur des absentArtist), donc pour voir sa progression est ajout\u00e9 une impression de l'index qui ex\u00e9cute l'algorithme.","e29a9ac3":"L'existence de songGenres et artistGenres est rappel\u00e9e, et la listeGenres est cr\u00e9\u00e9e \u00e0 partir de tous les genres pr\u00e9sents dans les artistes.","55c4604f":"Ici, on peut voir \u00e0 quoi ressemble song_data:","1ec1bb7f":"Une fonction est cr\u00e9\u00e9e pour mesurer la distance entre deux vecteurs.","efe3a1ad":"Comme le programme complet fonctionne \u00e0 travers les index des chansons, il est n\u00e9cessaire de conna\u00eetre l'index de la chanson dans laquelle on veut chercher des recommandations. Ensuite, pour faciliter cette t\u00e2che, une fonction est cr\u00e9\u00e9e qui imprime les index et les artistes de toutes les chansons qui sont appel\u00e9es d'une mani\u00e8re (\u00e0 mettre par l'utilisateur). C'est \u00e9galement tr\u00e8s utile car souvent, diff\u00e9rents artistes ont des chansons qui s'appellent les m\u00eames, donc avec cette m\u00e9thode on s'assure que l'utilisateur peut choisir la bonne chanson.\n"}}