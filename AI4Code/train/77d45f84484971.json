{"cell_type":{"e8ad8a4b":"code","a1e86f57":"code","a8b989be":"code","0a70d22a":"code","8a6be05e":"code","3a0591be":"code","d4131577":"code","c22998f6":"code","cb4dedb9":"code","5b7ce818":"markdown","8c7b7a8b":"markdown","bd8b1362":"markdown","edaf50c7":"markdown","c279e776":"markdown","c8457724":"markdown"},"source":{"e8ad8a4b":"import os\nimport pandas as pd\nimport numpy as np\nimport keras\nimport tensorflow as tf\nimport cv2\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom keras.models import Model,Sequential\nfrom keras.layers import Conv2D,Dense,Flatten,Dropout,MaxPooling2D,Input,GlobalAveragePooling2D\nfrom keras.layers import add,Activation,BatchNormalization\nfrom keras.layers.advanced_activations import LeakyReLU\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.regularizers import l2\nfrom keras.utils import to_categorical\nfrom keras.optimizers import SGD\n%matplotlib inline\n\nconfig = tf.ConfigProto( device_count = {'GPU': 1 , 'CPU': 4} ) \nsess = tf.Session(config=config) \nkeras.backend.set_session(sess)\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nnp.random.seed(0)","a1e86f57":"image_width=150\nimage_height=150\nbatch_size=64\n\ntrain_normal = os.listdir('..\/input\/chest_xray\/chest_xray\/train\/NORMAL\/')\ntrain_pneumonia = os.listdir('..\/input\/chest_xray\/chest_xray\/train\/PNEUMONIA\/')\n\nlabels = 'Normal', 'Pneumonia'\nsizes = [len(train_normal), len(train_pneumonia)]\ncolors = ['green', 'red']\nexplode = (0.1,0)\n# Plot\nplt.pie(sizes, labels=labels,\n        colors=colors,\n       explode=explode)\n \nplt.axis('equal')\nplt.show()","a8b989be":"# borrowed from faizunnabi, thanks!\ntrain_dir = Path(\"..\/input\/chest_xray\/chest_xray\/train\/\")\ntest_dir =  Path(\"..\/input\/chest_xray\/chest_xray\/test\/\")\n\ntrain_datagen = ImageDataGenerator(rescale=1.\/255,\n                                   shear_range=0.2,\n                                   zoom_range=0.2,\n                                   horizontal_flip=True)\n\ntest_datagen = ImageDataGenerator(rescale=1.\/255)\n\ntraining_set = train_datagen.flow_from_directory('..\/input\/chest_xray\/chest_xray\/train',\n                                                 target_size=(image_width, image_height),\n                                                 batch_size=batch_size,\n                                                 class_mode='binary')\n\ntest_set = test_datagen.flow_from_directory('..\/input\/chest_xray\/chest_xray\/test',\n                                            target_size=(image_width, image_height),\n                                            batch_size=batch_size,\n                                            class_mode='binary')","0a70d22a":"def conv2d_unit(x, filters, kernels, strides=1):\n    x = Conv2D(filters, kernels,\n               padding='same',\n               strides=strides,\n               activation='linear',\n               kernel_regularizer=l2(5e-4))(x)\n    x = BatchNormalization()(x)\n    x = LeakyReLU(alpha=0.1)(x)\n    return x\n\ndef residual_block(inputs, filters):\n    x = conv2d_unit(inputs, filters, (1, 1))\n    x = conv2d_unit(x, 2 * filters, (3, 3))\n    x = add([inputs, x])\n    x = Activation('linear')(x)\n    return x\n\ndef stack_residual_block(inputs, filters, n):\n    x = residual_block(inputs, filters)\n    for i in range(n - 1):\n        x = residual_block(x, filters)\n    return x","8a6be05e":"def darknet_base(inputs):\n    x = conv2d_unit(inputs, 32, (3, 3))\n    x = conv2d_unit(x, 64, (3, 3), strides=2)\n    for _ in range(20):\n        x = stack_residual_block(x, 32, n=1)\n        x = conv2d_unit(x, 64, (3, 3), strides=2)\n    return x\ndef darknet():\n    inputs = Input(shape=(image_width, image_height, 3))\n    x = darknet_base(inputs)\n    x = GlobalAveragePooling2D()(x)\n    x = Dense(1, activation='softmax')(x)\n    model = Model(inputs, x)\n    return model","3a0591be":"model = darknet()\nsgd = SGD(lr=0.015, \n          decay=1e-6, \n          momentum=0.8, \n          nesterov=True)\nmodel.compile(loss='binary_crossentropy',\n              optimizer=sgd,\n              metrics=['accuracy'])","d4131577":"# thanks again to faizunnabi, for this snippet\nnum_epochs=50\n\nhistory = model.fit_generator(training_set,\n                    steps_per_epoch=5216\/\/batch_size,\n                    epochs=num_epochs,\n                    validation_data=test_set,\n                    validation_steps=624\/\/batch_size)","c22998f6":"plt.plot(history.history['acc'])\nplt.plot(history.history['val_acc'])\nplt.ylabel(\"accuracy\")\nplt.xlabel(\"epoch\")\nplt.legend(['train', 'test'])\nplt.show()","cb4dedb9":"loss, score = model.evaluate_generator(test_set)\nprint(\"Loss:     \", loss)\nprint(\"Accuracy: \", score)","5b7ce818":"Each line of the darknet_base function calls an auxiliary function from the cell above. It's mostly made of Conv2D units and a LeakyReLU. If you trace the code, you'll see that `stack_residual_block()` is just a loop for making `residual_block()`, which makes an arrangement of `conv2d_unit()`.","8c7b7a8b":"## Fitting the DarkNet","bd8b1362":"## Load the Data\nThe data seems to be plentiful enough, the skewedness is not awful.","edaf50c7":"## Creating the deep network","c279e776":"Let's see how well training went:","c8457724":"## Testing the DarkNet"}}