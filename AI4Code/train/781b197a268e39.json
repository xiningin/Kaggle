{"cell_type":{"e479b84a":"code","3265ca9e":"code","97c1dade":"markdown","0a1ffd3d":"markdown","a803a5cf":"markdown"},"source":{"e479b84a":"import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndef new_X(x_coordinate, play_direction):\n        if play_direction == 'left':\n            return 120.0 - x_coordinate\n        else:\n            return x_coordinate\n\ndef new_line(rush_team, field_position, yardline):\n    if rush_team == field_position:\n            # offense starting at X = 0 plus the 10 yard endzone plus the line of scrimmage\n        return 10.0 + yardline\n    else:\n        return 60.0 + (50 - yardline)\n\ndef new_orientation(angle, play_direction):\n    if play_direction == 'left':\n        new_angle = 360.0 - angle\n        if new_angle == 360.0:\n            new_angle = 0.0\n        return new_angle\n    else:\n        return angle\n\ndef euclidean_distance(x1,y1,x2,y2):\n    x_diff = (x1-x2)**2\n    y_diff = (y1-y2)**2\n    return np.sqrt(x_diff + y_diff)\n\ndef back_direction(orientation):\n    if orientation > 180.0:\n        return 1\n    else:\n        return 0\n\n\ndef update_yardline(df):\n    new_yardline = df[df['NflId'] == df['NflIdRusher']]\n    new_yardline['YardLine'] = new_yardline[['PossessionTeam','FieldPosition','YardLine']].apply(lambda x: new_line(x[0],x[1],x[2]), axis=1)\n    new_yardline = new_yardline[['GameId','PlayId','YardLine']]\n    return new_yardline\n\ndef update_orientation(df, yardline):\n    df['X'] = df[['X','PlayDirection']].apply(lambda x: new_X(x[0],x[1]), axis=1)\n    df['Orientation'] = df[['Orientation','PlayDirection']].apply(lambda x: new_orientation(x[0],x[1]), axis=1)\n    df['Dir'] = df[['Dir','PlayDirection']].apply(lambda x: new_orientation(x[0],x[1]), axis=1)\n    df = df.drop('YardLine', axis=1)\n    df = pd.merge(df, yardline, on=['GameId','PlayId'], how='inner')\n    return df\n\n\ndef get_update_orientarion():\n    train = pd.read_csv('\/kaggle\/input\/nfl-big-data-bowl-2020\/train.csv', dtype={'WindSpeed': 'object'})\n    yards = train.Yards\n    yardline = update_yardline(train)\n    train = update_orientation(train, yardline)\n    return train\n\ntrain = get_update_orientarion()","3265ca9e":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import Voronoi\nfrom shapely.geometry import box, Polygon\n\n\ndef display_formation(train, PlayId, visualize=True):\n    train_pl = train.loc[train.loc[:,'PlayId']==PlayId,:]\n    rusher = (train_pl.loc[train_pl.loc[:,'NflId']==train_pl.loc[:,'NflIdRusher'],:]).index[0]\n    yard = train_pl.loc[rusher,'Yards']\n    of = train_pl.loc[rusher,'Team']\n    \n    train_of = train_pl.loc[train_pl.loc[:,'Team']==of,:]\n    train_df = train_pl.loc[train_pl.loc[:,'Team']!=of,:]\n    if visualize:\n        plt.figure(figsize=(25,12))\n        plt.xlim(0,120+80)\n        plt.ylim(0,53.3)\n        plt.scatter(train_of.loc[:,'X'],train_of.loc[:,'Y'])\n        plt.scatter(train_df.loc[:,'X'],train_df.loc[:,'Y'])\n    for ii,i in enumerate(train_of.index):\n        if visualize:\n            plt.annotate(train_of.loc[i,'Position'],(train_of.loc[i,'X'],train_of.loc[i,'Y']))\n            plt.annotate('', xy=[train_of.loc[i,'X']+0.5*np.sin(train_of.loc[i,'Dir']\/180*np.pi)*train_of.loc[i,'S'],\n                                 train_of.loc[i,'Y']+0.5*np.cos(train_of.loc[i,'Dir']\/180*np.pi)*train_of.loc[i,'S']], \n                         xytext=[train_of.loc[i,'X'],train_of.loc[i,'Y']],\n                         arrowprops=dict(shrink=0, width=1, headwidth=3, headlength=3, \n                         connectionstyle='arc3',facecolor='gray', edgecolor='green'))\n    for i in train_df.index:\n        if visualize:\n            plt.annotate(train_df.loc[i,'Position'],(train_df.loc[i,'X'],train_df.loc[i,'Y']))\n            plt.annotate('', xy=[train_df.loc[i,'X']+0.5*np.sin(train_df.loc[i,'Dir']\/180*np.pi)*train_df.loc[i,'S'],\n                                 train_df.loc[i,'Y']+0.5*np.cos(train_df.loc[i,'Dir']\/180*np.pi)*train_df.loc[i,'S']], \n                         xytext=[train_df.loc[i,'X'],train_df.loc[i,'Y']],\n                         arrowprops=dict(shrink=0, width=1, headwidth=3, headlength=3, \n                         connectionstyle='arc3',facecolor='gray', edgecolor='black'))\n    rusher = (train_pl.loc[train_pl.loc[:,'NflId']==train_pl.loc[:,'NflIdRusher'],:]).index[0]\n    yard = train_pl.loc[rusher,'Yards']\n    team = train_pl.loc[rusher,'Team']\n    x,y = train_pl.loc[rusher,['X','Y']]\n    for i,c in enumerate(train_pl.columns[:25]):\n        if visualize:\n            plt.annotate(c+'  '+str(train_pl.loc[rusher,c]),(125,51.5-i*2),size=12)\n    for i,c in enumerate(train_pl.columns[25:]):\n        if visualize:\n            plt.annotate(c+'  '+str(train_pl.loc[rusher,c]),(160,51-i*2),size=12)\n    #if train_pl.loc[train_pl.index[0],'PossessionTeam'] == train_pl.loc[train_pl.index[0],'FieldPosition']:\n    if visualize:\n        plt.plot((train_pl.loc[train_pl.index[0],'YardLine'],train_pl.loc[train_pl.index[0],'YardLine']),(0,53.3))\n        plt.plot((train_pl.loc[train_pl.index[0],'YardLine']+yard,train_pl.loc[train_pl.index[0],'YardLine']+yard),(0,53.3),color='red')\n    #else:\n        #plt.plot((110-train_pl.loc[train_pl.index[0],'YardLine'],110-train_pl.loc[train_pl.index[0],'YardLine']),(0,53.3))\n    if visualize:\n        plt.savefig('formation.png')\n        plt.show()\n    return train_of.loc[:,['X','Y']].values, train_df.loc[:,['X','Y']].values, x, y, train_of.loc[rusher,:]\n    #print(train_home.head())\n    #print(train_away.head())\nplay_ls = list(set(train.loc[:,'PlayId']))\nvs = []\nprint(len(play_ls))\nxy_pair = [[5,10],[10,10],[20,10]]\narea_feature = pd.DataFrame(columns=(['PlayId']+\\\n                                     ['areaup_{0}_{1}'.format(str(x),str(y)) for x,y in xy_pair]+['areadown_{0}_{1}'.format(str(x),str(y)) for x,y in xy_pair]))\n\n\ndef C_finite_polygons_2d(vor, radius=None):\n\n    if vor.points.shape[1] != 2:\n        raise ValueError(\"Requires 2D input\")\n\n    new_regions = []\n    new_vertices = vor.vertices.tolist()\n\n    center = vor.points.mean(axis=0)\n    if radius is None:\n        radius = vor.points.ptp().max()\n\n    # Construct a map containing all ridges for a given point\n    all_ridges = {}\n    for (p1, p2), (v1, v2) in zip(vor.ridge_points, vor.ridge_vertices):\n        all_ridges.setdefault(p1, []).append((p2, v1, v2))\n        all_ridges.setdefault(p2, []).append((p1, v1, v2))\n\n    # Reconstruct infinite regions\n    for p1, region in enumerate(vor.point_region):\n        vertices = vor.regions[region]\n\n        if all(v >= 0 for v in vertices):\n            # finite region\n            new_regions.append(vertices)\n            continue\n\n        # reconstruct a non-finite region\n        ridges = all_ridges[p1]\n        new_region = [v for v in vertices if v >= 0]\n\n        for p2, v1, v2 in ridges:\n            if v2 < 0:\n                v1, v2 = v2, v1\n            if v1 >= 0:\n                # finite ridge: already in the region\n                continue\n\n            # Compute the missing endpoint of an infinite ridge\n\n            t = vor.points[p2] - vor.points[p1] # tangent\n            t \/= np.linalg.norm(t)\n            n = np.array([-t[1], t[0]])  # normal\n\n            midpoint = vor.points[[p1, p2]].mean(axis=0)\n            direction = np.sign(np.dot(midpoint - center, n)) * n\n            far_point = vor.vertices[v2] + direction * radius\n\n            new_region.append(len(new_vertices))\n            new_vertices.append(far_point.tolist())\n\n        # sort region counterclockwise\n        vs = np.asarray([new_vertices[v] for v in new_region])\n        c = vs.mean(axis=0)\n        angles = np.arctan2(vs[:,1] - c[1], vs[:,0] - c[0])\n        new_region = np.array(new_region)[np.argsort(angles)]\n\n        # finish\n        new_regions.append(new_region.tolist())\n\n    return new_regions, np.asarray(new_vertices)\n\ndef cover_area(of,df,x,y, xy_size=[[5.01,5.01]], visualize=True):\n    pts = np.concatenate([of,df],axis=0)\n    vor = Voronoi(pts)\n    regions, vertices = C_finite_polygons_2d(vor,1000)\n    if visualize:\n        plt.figure(figsize=(10,10))\n    vs = []\n    for x_size, y_size in xy_size:\n        area = Polygon(np.array([[x,y-y_size\/2],[x+x_size,y-y_size\/2],[x+x_size,y+y_size\/2],[x,y+y_size\/2]]))\n        v = 0\n        for region in regions[:11]:\n            polygon = vertices[region]\n            p = Polygon(polygon)\n            if p.intersects(area):\n                p = Polygon(p.intersection(area))\n                v += p.area\n                xx, yy = p.exterior.coords.xy\n                if visualize:\n                    plt.fill(xx,yy, alpha=0.4, color='green')\n        if visualize:\n            plt.scatter(pts[:11,0], pts[:11,1],c='blue')\n            plt.scatter(pts[11:,0], pts[11:,1],c='red')\n            plt.xlim(vor.min_bound[0] - 10, vor.max_bound[0] + 10)\n            plt.ylim(vor.min_bound[1] - 10, vor.max_bound[1] + 10)\n            plt.savefig('area.png')\n            plt.show()\n        vs.append(v)\n    return vs\n\nplay_ls = list(set(train.loc[:,'PlayId']))\nof, df, x, y,rusher = display_formation(train, play_ls[0], visualize=False)\nv = cover_area(of,df,x,y,xy_size=[[10.01,10.01]], visualize = True)","97c1dade":"## Voronoi area in front of the rusher\nI referred to these site https:\/\/gist.github.com\/pv\/8036995 and https:\/\/www.kaggle.com\/bestpredict\/location-eda-8eb410. \nIn this kernel, I write how to calculate \"Voronoi area in front of the rusher\" written in https:\/\/www.kaggle.com\/c\/nfl-big-data-bowl-2020\/discussion\/119487#latest-683907.","0a1ffd3d":"## Preprocessing","a803a5cf":"## Calculating Voronoi area in front of the rusher "}}