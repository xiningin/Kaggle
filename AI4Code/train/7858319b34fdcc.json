{"cell_type":{"09fbd590":"code","6e6183ed":"code","ece49de1":"code","6ff182a9":"code","dbb5290b":"code","bd54fbee":"code","07cac905":"code","5b95ae4b":"code","f10a55a8":"code","afe5bbfb":"code","ad90255a":"code","f3ff8ff1":"code","c4c8944f":"code","cfda1354":"code","05ed4f64":"code","698d07cf":"code","64a95170":"code","4485dfc5":"code","33a12cc1":"code","21977e86":"markdown","d2271b89":"markdown","3e9caa9e":"markdown","16a00dee":"markdown","d07a2870":"markdown","e3c71e13":"markdown","4ab6ee72":"markdown"},"source":{"09fbd590":"import pandas as pd\nimport numpy as np\nfrom scipy.optimize import leastsq\nimport pylab as plt\nimport time\n\n# print the time of last run\nprint('last run of this notebook:')\ntime.strftime(\"%a, %d %b %Y %H:%M:%S\", time.localtime())\n","6e6183ed":"!pip install openpyxl","ece49de1":"# test function\nN = 1000 # number of data points\nt = np.linspace(0, 4*np.pi, N)\ndata = 3.0*np.sin(t+0.001) + 0.5 + np.random.randn(N) # create artificial data with noise\n\nguess_mean = np.mean(data)\nguess_std = 3*np.std(data)\/(2**0.5)\nguess_phase = 0\n\n# we'll use this to plot our first estimate. This might already be good enough for you\ndata_first_guess = guess_std*np.sin(t+guess_phase) + guess_mean\n\n# Define the function to optimize, in this case, we want to minimize the difference\n# between the actual data and our \"guessed\" parameters\noptimize_func = lambda x: x[0]*np.sin(t+x[1]) + x[2] - data\nest_std, est_phase, est_mean = leastsq(optimize_func, [guess_std, guess_phase, guess_mean])[0]\n\n# recreate the fitted curve using the optimized parameters\ndata_fit = est_std*np.sin(t+est_phase) + est_mean\nplt.figure(figsize=(20,5))\nplt.plot(data, '.')\nplt.plot(data_fit, label='after fitting')\nplt.plot(data_first_guess, label='first guess')\nplt.legend()\nplt.grid()","6ff182a9":"importfile = '..\/input\/cbs-statline-gas-usage\/CBS Statline Gas Usage.xlsx'\ndf = pd.read_excel(importfile, sheet_name='Month', skiprows=1)\ndf.drop(['Onderwerpen_1', 'Onderwerpen_2', 'Perioden'], axis=1, inplace=True)\ndf.head()","dbb5290b":"# transpose\ndf = df.transpose()\ndf.head()","bd54fbee":"new_header = df.iloc[0]\ndf = df[1:]\ndf.rename(columns = new_header, inplace=True)\ndf.head()","07cac905":"x = range(len(df.index))\ndf['Via regionale netten'].plot(figsize=(18,5))\nplt.xticks(x, df.index, rotation='vertical')\nplt.grid()","5b95ae4b":"df.info()","f10a55a8":"df.describe()","afe5bbfb":"N = 84 # number of data points\nt = np.linspace(0, 83, N)\n#data = b + m*(.5 * (1 + np.cos((t\/6)*np.pi))) + 100*np.random.randn(N) # create artificial data with noise\ndata = np.array(df['Via regionale netten'].values, dtype=np.float64)\n\nguess_mean = np.mean(data)\nguess_std = 2695.9075546 #2*np.std(data)\/(2**0.5)\nguess_phase = 0\n\n# we'll use this to plot our first estimate. This might already be good enough for you\ndata_first_guess = guess_mean + guess_std*(.5 * (1 + np.cos((t\/6)*np.pi + guess_phase)))\n\n# Define the function to optimize, in this case, we want to minimize the difference\n# between the actual data and our \"guessed\" parameters\noptimize_func = lambda x: x[0]*(.5 * (1 + np.cos((t\/6)*np.pi+x[1]))) + x[2] - data\nest_std, est_phase, est_mean = leastsq(optimize_func, [guess_std, guess_phase, guess_mean])[0]\n\n# recreate the fitted curve using the optimized parameters\ndata_fit = est_mean + est_std*(.5 * (1 + np.cos((t\/6)*np.pi + est_phase)))\nplt.figure(figsize=(20,5))\nplt.plot(data, '.')\nplt.plot(data_fit, label='after fitting')\nplt.plot(data_first_guess, label='first guess')\nplt.legend()\nplt.grid()\n\n","ad90255a":"print('Via regionale netten')\nprint('max_demand:  %s' %(est_std))\nprint('phase_shift: %s' %(est_phase))\nprint('base_demand: %s' %(est_mean))","f3ff8ff1":"data = np.array(df['Elektriciteitscentrales'].values, dtype=np.float64)\n\nguess_mean = np.mean(data)\nguess_std = 3*np.std(data)\/(2**0.5)\nguess_phase = 0\n\n# we'll use this to plot our first estimate. This might already be good enough for you\ndata_first_guess = guess_mean + guess_std*(.5 * (1 + np.cos((t\/6)*np.pi + guess_phase)))\n\n# Define the function to optimize, in this case, we want to minimize the difference\n# between the actual data and our \"guessed\" parameters\noptimize_func = lambda x: x[0]*(.5 * (1 + np.cos((t\/6)*np.pi+x[1]))) + x[2] - data\nest_std, est_phase, est_mean = leastsq(optimize_func, [guess_std, guess_phase, guess_mean])[0]\n\n# recreate the fitted curve using the optimized parameters\ndata_fit = est_mean + est_std*(.5 * (1 + np.cos((t\/6)*np.pi + est_phase)))\nplt.figure(figsize=(20,5))\nplt.plot(data, '.')\nplt.plot(data_fit, label='after fitting')\nplt.plot(data_first_guess, label='first guess')\nplt.legend()\nplt.grid()\n","c4c8944f":"print('Elektriciteitscentrales')\nprint('max_demand:  %s' %(est_std))\nprint('phase_shift: %s' %(est_phase))\nprint('base_demand: %s' %(est_mean))","cfda1354":"data = np.array(df['Overige verbruikers'].values, dtype=np.float64)\n\nguess_mean = np.mean(data)\nguess_std = 3*np.std(data)\/(2**0.5)\nguess_phase = 0\nguess_saving = .997\n\n# we'll use this to plot our first estimate. This might already be good enough for you\ndata_first_guess = (guess_mean + guess_std*(.5 * (1 + np.cos((t\/6)*np.pi + guess_phase)))) #* np.power(guess_saving,t)\n\n# Define the function to optimize, in this case, we want to minimize the difference\n# between the actual data and our \"guessed\" parameters\noptimize_func = lambda x: x[0]*(.5 * (1 + np.cos((t\/6)*np.pi+x[1]))) + x[2] - data\nest_std, est_phase, est_mean = leastsq(optimize_func, [guess_std, guess_phase, guess_mean])[0]\n\n# recreate the fitted curve using the optimized parameters\ndata_fit = est_mean + est_std*(.5 * (1 + np.cos((t\/6)*np.pi + est_phase)))\nplt.figure(figsize=(20,5))\nplt.plot(data, '.')\nplt.plot(data_fit, label='after fitting')\nplt.plot(data_first_guess, label='first guess')\nplt.legend()\nplt.grid()\n","05ed4f64":"print('Overige verbruikers')\nprint('max_demand:  %s' %(est_std))\nprint('phase_shift: %s' %(est_phase))\nprint('base_demand: %s' %(est_mean))\n","698d07cf":"inputexcel = '..\/input\/cbs-statline-gas-usage\/TTFDA.xlsx'\noutputexcel = '.\/pythonoutput.xlsx'\n\nprice = pd.read_excel(inputexcel, sheet_name='Sheet1', index_col=0)\nquantity = pd.read_excel(inputexcel, sheet_name='Sheet2', index_col=0)\n\nprice.index = pd.to_datetime(price.index, format=\"%d-%m-%y\")\nquantity.index = pd.to_datetime(quantity.index, format=\"%d-%m-%y\")\n\npq = pd.concat([price, quantity], axis=1)\npq = pq.reindex(price.index)\npqna = pq.dropna()\npqna.head()","64a95170":"year = np.arange(2008,2017,1)\n\ncoefficientyear = []\n\nfor i in year:\n    plt.figure(figsize=(20,5))\n    x= pqna['Volume'].sort_index().loc[\"%s\"%i]\n    y= pqna['Last'].sort_index().loc[\"%s\"%i]\n    #plot the trendline\n    plt.plot(x,y,'o')\n    plt.grid()\n    # calc the trendline\n    z = np.polyfit(x, y, 1)\n    p = np.poly1d(z)\n    plt.plot(x,p(x),\"r--\", label=\"%s\"%i)\n    plt.xlabel(\"Volume\")\n    plt.ylabel(\"Price Euro per MWH\")\n    plt.title('%s: y=%.10fx+(%.10f)'%(i,z[0],z[1]))\n    # plt.savefig('%s.png' %i)\n    plt.show()\n    # the line equation:\n    print(\"y=%.10fx+(%.10f)\"%(z[0],z[1]))\n    # save the variables in a list\n    coefficientyear.append([i, z[0], z[1]])\n","4485dfc5":"len(year)","33a12cc1":"init_buyer = {'elec_eu':{'b':400, 'm' : 673, 'lb_price': 10, 'ub_price' : 20, 'type' : 2, 'market' : ['eu']},\n              'indu_eu':{'b':400, 'm':1171, 'lb_price': 10, 'ub_price' : 20, 'type' : 3, 'market' : ['eu']},\n              'home_eu':{'b': 603, 'm': 3615, 'lb_price': 10, 'ub_price' : 20, 'type' : 1, 'market' : ['eu']},\n              'elec_us':{'b':400, 'm' : 673, 'lb_price': 10, 'ub_price' : 20, 'type' : 2, 'market' : ['us']},\n              'indu_us':{'b':400, 'm':1171, 'lb_price': 10, 'ub_price' : 20, 'type' : 3, 'market' : ['us']},\n              'elec_as':{'b':400, 'm' : 673, 'lb_price': 10, 'ub_price' : 20, 'type' : 2, 'market' : ['as']},\n              'indu_as':{'b':400, 'm':1171, 'lb_price': 10, 'ub_price' : 20, 'type' : 3, 'market' : ['as']}}\n\nfor i in init_buyer: \n    if i!= 'indu_as':\n        print(i)\nprint('indu_as')","21977e86":"## Import data for our model","d2271b89":"In order to estimate willingness to sell en willingness to buy we look at historical data over the past view years. We look at the DayAhead market at the TTF. Altough this data does not reflect real consumption necessarily","3e9caa9e":"ABM market model based on the natural gas market written in Python. The model is created to run a simulation for roughly 35 years and represents a time frame of the year 2013 to 2050. ","16a00dee":"This is data imported from statline CBS webportal.","d07a2870":"# Price Forming","e3c71e13":"# Data Analytics","4ab6ee72":"Within this notebook we do some data analytics on historical data to feed some real numbers into the model. Since we assume the consumer data to be resemble a sinus, due to the fact that demand is seasonal, we will focus on fitting data to this kind of curve."}}