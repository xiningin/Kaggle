{"cell_type":{"7c2f579e":"code","55dac157":"code","ffc02557":"code","d959c903":"code","cff0dc5a":"code","bc906f1d":"code","95321f94":"code","a05a8272":"code","878c36bf":"code","3d7ce0b5":"code","bfa9ffe2":"code","f895891c":"code","cf7841f0":"code","5c3f23e3":"code","9e0113df":"code","ae404766":"code","54f6651a":"code","e227b53e":"code","f6cf1835":"code","cf6ea4c2":"code","62d21a02":"code","700f1640":"code","3bdfa6be":"code","9f668afb":"code","3b0456ca":"code","d836f779":"code","40a4ce15":"code","150ab128":"code","33734132":"code","864709d4":"code","0f0f301a":"code","53f83607":"code","26076a28":"code","1419b0a9":"code","64814e8c":"code","f93739e1":"code","893086cf":"code","34333d3b":"markdown","0470c44f":"markdown","0f8708ea":"markdown","07edc9e0":"markdown","3a877b73":"markdown","0e901242":"markdown","3e488a43":"markdown","ecd9202b":"markdown","5c655988":"markdown","95257bba":"markdown","9584ff33":"markdown","413e5071":"markdown","ba4f87c7":"markdown","62152b14":"markdown","4fc2e02b":"markdown","efee4edd":"markdown","e54249eb":"markdown","46275800":"markdown","6d6b06a4":"markdown"},"source":{"7c2f579e":"import os\nimport sys\nimport time\nimport random\nimport logging\nimport typing as tp\nfrom pathlib import Path\nfrom contextlib import contextmanager\n\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nimport numpy as np\nimport pandas as pd\n\nimport category_encoders as ce\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import mean_squared_log_error, mean_squared_error\n\nimport xgboost as xgb\nimport lightgbm as lgb\nfrom catboost import CatBoost, Pool\n\n%matplotlib inline","55dac157":"ROOT = Path.cwd().parent\nINPUT = ROOT \/ \"input\"\nDATA = INPUT \/ \"tabular-playground-series-feb-2021\"\nWORK = ROOT \/ \"working\"\n\nfor path in DATA.iterdir():\n    print(path.name)","ffc02557":"train = pd.read_csv(DATA \/ \"train.csv\")\ntest = pd.read_csv(DATA \/ \"test.csv\")\nsmpl_sub = pd.read_csv(DATA \/ \"sample_submission.csv\")\nprint(\"train: {}, test: {}, sample sub: {}\".format(\n    train.shape, test.shape, smpl_sub.shape\n))","d959c903":"train.head().T","cff0dc5a":"@contextmanager\ndef timer(logger=None, format_str='{:.3f}[s]', prefix=None, suffix=None):\n    if prefix: format_str = str(prefix) + format_str\n    if suffix: format_str = format_str + str(suffix)\n    start = time.time()\n    yield\n    d = time.time() - start\n    out_str = format_str.format(d)\n    if logger:\n        logger.info(out_str)\n    else:\n        print(out_str)","bc906f1d":"def rmse(y_true, y_pred):\n    \"\"\"\"\"\"\n    return np.sqrt(np.mean((y_true - y_pred) ** 2))","95321f94":"class TreeModel:\n    \"\"\"Wrapper for LightGBM\/XGBoost\/CATBoost\"\"\"\n    def __init__(self, model_type: str):\n        self.model_type = model_type\n        self.trn_data = None\n        self.val_data = None\n        self.model = None\n\n    def train(self,\n              params: dict,\n              X_train: pd.DataFrame, y_train: np.ndarray,\n              X_val: pd.DataFrame, y_val: np.ndarray,\n              train_weight: tp.Optional[np.ndarray] = None,\n              val_weight: tp.Optional[np.ndarray] = None,\n              train_params: dict = None,\n              cat_cols: list = None,\n            ):\n        if self.model_type == \"lgb\":\n            self.trn_data = lgb.Dataset(X_train, label=y_train, weight=train_weight)\n            self.val_data = lgb.Dataset(X_val, label=y_val, weight=val_weight)\n            self.model = lgb.train(params=params,\n                                   train_set=self.trn_data,\n                                   valid_sets=[self.trn_data, self.val_data],\n                                   **train_params)\n        elif self.model_type == \"xgb\":\n            self.trn_data = xgb.DMatrix(X_train, y_train, weight=train_weight)\n            self.val_data = xgb.DMatrix(X_val, y_val, weight=val_weight)\n            self.model = xgb.train(params=params,\n                                   dtrain=self.trn_data,\n                                   evals=[(self.trn_data, \"train\"), (self.val_data, \"val\")],\n                                   **train_params)\n        elif self.model_type == \"cat\":\n            self.trn_data = Pool(\n                X_train, label=y_train, cat_features=cat_cols)  #, group_id=[0] * len(X_train))\n            self.val_data = Pool(\n                X_val, label=y_val, cat_features=cat_cols)  #, group_id=[0] * len(X_val))\n            self.model = CatBoost(params)\n            self.model.fit(\n                self.trn_data, eval_set=[self.val_data], use_best_model=True, **train_params)\n        else:\n            raise NotImplementedError\n\n    def predict(self, X: pd.DataFrame):\n        if self.model_type == \"lgb\":\n            return self.model.predict(\n                X, num_iteration=self.model.best_iteration)  # type: ignore\n        elif self.model_type == \"xgb\":\n            X_DM = xgb.DMatrix(X)\n            return self.model.predict(\n                X_DM, ntree_limit=self.model.best_ntree_limit)  # type: ignore\n        elif self.model_type == \"cat\":\n            return self.model.predict(X)\n        else:\n            raise NotImplementedError\n\n    @property\n    def feature_names_(self):\n        if self.model_type == \"lgb\":\n            return self.model.feature_name()\n        elif self.model_type == \"xgb\":\n            return list(self.model.get_score(importance_type=\"gain\").keys())\n        elif self.model_type == \"cat\":\n             return self.model.feature_names_\n        else:\n            raise NotImplementedError\n\n    @property\n    def feature_importances_(self):\n        if self.model_type == \"lgb\":\n            return self.model.feature_importance(importance_type=\"gain\")\n        elif self.model_type == \"xgb\":\n            return list(self.model.get_score(importance_type=\"gain\").values())\n        elif self.model_type == \"cat\":\n            return self.model.feature_importances_\n        else:\n            raise NotImplementedError","a05a8272":"ID_COL = \"id\"\nCAT_COLS= [f\"cat{i}\" for i in range(10)]\nCONT_COLS = [f\"cont{i}\" for i in range(14)]\nTGT_COL = \"target\"\n\nN_SPLITS = 10\nRANDOM_SEED_LIST = [\n    42, 2021, 2,\n]\n","878c36bf":"use_feat_cols = []\ntrain_feat = train[[ID_COL]].copy()\ntest_feat = test[[ID_COL]].copy()","3d7ce0b5":"ord_enc = ce.OrdinalEncoder(cols=CAT_COLS)\ntrain_cat_feat = ord_enc.fit_transform(train[CAT_COLS])\ntest_cat_feat = ord_enc.transform(test[CAT_COLS])","bfa9ffe2":"train_feat = pd.concat([\n    train_feat, train_cat_feat], axis=1)\ntest_feat = pd.concat([\n    test_feat, test_cat_feat], axis=1)\nuse_feat_cols.extend(train_cat_feat.columns)","f895891c":"train_cont_feat = train[CONT_COLS]\ntest_cont_feat = test[CONT_COLS]","cf7841f0":"train_feat = pd.concat([\n    train_feat, train_cont_feat], axis=1)\ntest_feat = pd.concat([\n    test_feat, test_cont_feat], axis=1)\nuse_feat_cols.extend(CONT_COLS)","5c3f23e3":"train_feat.head().T","9e0113df":"test_feat.head().T","ae404766":"def run_train_and_inference(\n    X, X_test, y, use_model, model_params, train_params, seed_list, n_splits, cat_cols=None\n):\n    \n    oof_pred_arr = np.zeros(len(X))\n    test_pred_arr = np.zeros(len(X_test))\n    feature_importances = pd.DataFrame()\n    score_list = []\n    \n    for seed in seed_list:\n        if use_model == \"cat\":\n            model_params['random_state'] = seed\n        else:\n            model_params[\"seed\"] = seed\n        kf = KFold(n_splits=n_splits, shuffle=True, random_state=seed)\n        tmp_oof_pred = np.zeros(len(X))\n        tmp_test_pred = np.zeros(len(X_test))\n\n        for fold, (trn_idx, val_idx) in enumerate(kf.split(X, y)):\n            print(\"*\" * 100)\n            print(f\"Seed: {seed} - Fold: {fold}\")\n            X_trn = X.loc[trn_idx].reset_index(drop=True)\n            X_val = X.loc[val_idx].reset_index(drop=True)\n            y_trn = y[trn_idx]\n            y_val = y[val_idx]\n\n            model = TreeModel(model_type=use_model)\n            with timer(prefix=\"Model training\"):\n                model.train(\n                    params=model_params, X_train=X_trn, y_train=y_trn,\n                    X_val=X_val, y_val=y_val, train_params=train_params, cat_cols=cat_cols\n                )\n            with timer(prefix=\"Get Feature Importance\"):\n                fi_tmp = pd.DataFrame()\n                fi_tmp[\"feature\"] = model.feature_names_\n                fi_tmp[\"importance\"] = model.feature_importances_\n                fi_tmp[\"fold\"] = fold\n                fi_tmp[\"seed\"] = seed\n                feature_importances = feature_importances.append(fi_tmp)\n\n            with timer(prefix=\"Predict Valid\"):\n                val_pred = model.predict(X_val)\n                score = mean_squared_error(y_val, val_pred, squared=False)\n                # score = rmse(y_val, val_pred)\n                print(f\"score: {score:.5f}\")\n                score_list.append([seed, fold, score])\n                tmp_oof_pred[val_idx] = val_pred\n                tmp_test_pred += model.predict(X_test)\n            \n        oof_score = mean_squared_error(y, tmp_oof_pred, squared=False)\n        # oof_score = rmse(y, tmp_oof_pred)\n        print(f\"oof score: {oof_score: 5f}\")\n        score_list.append([seed, \"oof\", oof_score])\n\n        oof_pred_arr += tmp_oof_pred\n        test_pred_arr += tmp_test_pred \/ n_splits\n\n    oof_pred_arr \/= len(seed_list)\n    test_pred_arr \/= len(seed_list)\n    \n    oof_score = mean_squared_error(y, oof_pred_arr, squared=False)\n    # oof_score = rmse(y, oof_pred_arr)\n    score_list.append([\"avg\", \"oof\", oof_score])\n    score_df = pd.DataFrame(\n        score_list, columns=[\"seed\", \"fold\", \"rmse score\"])\n    \n    return oof_pred_arr, test_pred_arr, score_df, feature_importances","54f6651a":"X = train_feat[use_feat_cols]\nX_test = test_feat[use_feat_cols]\n\ny = train[TGT_COL].values\n\nprint(f\"train_feat: {X.shape}, test_feat: {X_test.shape}\")","e227b53e":"X_cat = X.copy()\nX_cat[CAT_COLS] = train[CAT_COLS]\nX_test_cat = X_test.copy()\nX_test_cat = test[CAT_COLS]","f6cf1835":"MODEL_PARAMS = {\n    \"lgb\": {\n        \"objective\": \"root_mean_squared_error\",\n        \"boosting\": \"gbdt\",\n        \"max_depth\": 8,\n        \"learning_rate\": 0.005,\n        \"colsample_bytree\": 0.2,\n        \"subsample\": 0.8,\n        \"subsample_freq\": 6,\n        \"reg_alpha\": 20,\n        \"min_data_in_leaf\": 200,\n        \"n_jobs\": 2,\n        \"seed\": RANDOM_SEED_LIST[0],\n        # \"device\": \"gpu\",\n        # \"gpu_device_id\": 0\n    },\n    \"xgb\": {\n        \"objective\": \"reg:squarederror\",\n        \"max_depth\": 8,\n        \"learning_rate\": 0.003,\n        \"colsample_bytree\": 0.2,\n        \"subsample\": 0.8,\n        \"reg_alpha\" : 6,\n        \"min_child_weight\": 200,\n        \"n_jobs\": 2,\n        \"seed\": RANDOM_SEED_LIST[0],\n        'tree_method': \"gpu_hist\",\n        \"gpu_id\": 0,\n    },\n    \"cat\": {\n        'loss_function': 'RMSE',\n        \"max_depth\": 4,\n        'learning_rate': 0.03,\n        \"bootstrap_type\": 'Poisson',\n        \"subsample\": 0.8,\n        \"border_count\": 512,\n        \"l2_leaf_reg\": 200,\n        'random_state': RANDOM_SEED_LIST[0],\n        \"thread_count\": 2,\n        \"task_type\": \"GPU\",\n        \"devices\" : \"0\",\n        'num_boost_round': 50000,\n    }\n}\nTRAIN_PARAMS = {\n    \"lgb\": {\n        \"num_boost_round\": 50000,\n        \"early_stopping_rounds\": 200,\n        \"verbose_eval\": 200,\n    },\n    \"xgb\": {\n        \"num_boost_round\": 50000,\n        \"early_stopping_rounds\": 200,\n        \"verbose_eval\":  200,\n    },\n    \"cat\": {\n        'early_stopping_rounds': 200,\n        'verbose_eval': 200,\n    }\n}","cf6ea4c2":"oof_pred_lgb, test_pred_lgb, score_lgb, feat_imps_lgb = run_train_and_inference(\n    X, X_test, y, \"lgb\", MODEL_PARAMS[\"lgb\"], TRAIN_PARAMS[\"lgb\"], RANDOM_SEED_LIST, N_SPLITS)","62d21a02":"score_lgb","700f1640":"score_lgb.loc[score_lgb.fold == \"oof\"]","3bdfa6be":"order = list(feat_imps_lgb.groupby(\"feature\").mean().sort_values(\"importance\", ascending=False).index)\nplt.figure(figsize=(10, 10))\nsns.barplot(x=\"importance\", y=\"feature\", data=feat_imps_lgb, order=order)\nplt.title(\"{} importance\".format(\"lgb\"))\nplt.tight_layout()","9f668afb":"oof_pred_xgb, test_pred_xgb, score_xgb, feat_imps_xgb = run_train_and_inference(\n    X, X_test, y, \"xgb\", MODEL_PARAMS[\"xgb\"], TRAIN_PARAMS[\"xgb\"], RANDOM_SEED_LIST, N_SPLITS)","3b0456ca":"score_xgb","d836f779":"score_xgb.loc[score_xgb.fold == \"oof\"]","40a4ce15":"order = list(feat_imps_xgb.groupby(\"feature\").mean().sort_values(\"importance\", ascending=False).index)\nplt.figure(figsize=(10, 10))\nsns.barplot(x=\"importance\", y=\"feature\", data=feat_imps_xgb, order=order)\nplt.title(\"{} importance\".format(\"xgb\"))\nplt.tight_layout()","150ab128":"oof_pred_cat, test_pred_cat, score_cat, feat_imps_cat = run_train_and_inference(\n    X, X_test, y, \"cat\", MODEL_PARAMS[\"cat\"], TRAIN_PARAMS[\"cat\"],\n    RANDOM_SEED_LIST, N_SPLITS,)  #cat_cols=list(range(10)))","33734132":"score_cat","864709d4":"score_cat.loc[score_cat.fold == \"oof\"]","0f0f301a":"order = list(feat_imps_cat.groupby(\"feature\").mean().sort_values(\"importance\", ascending=False).index)\nplt.figure(figsize=(10, 10))\nsns.barplot(x=\"importance\", y=\"feature\", data=feat_imps_cat, order=order)\nplt.title(\"{} importance\".format(\"cat\"))\nplt.tight_layout()","53f83607":"model_names = [\"lgb\", \"xgb\", \"cat\"]","26076a28":"# # prediction for oof\npd.DataFrame(\n    np.corrcoef([\n        oof_pred_lgb,\n        oof_pred_xgb,\n        oof_pred_cat\n    ]),\n    columns=model_names, index=model_names)","1419b0a9":"# # prediction for test\npd.DataFrame(\n    np.corrcoef([\n        test_pred_lgb,\n        test_pred_xgb,\n        test_pred_cat\n    ]),\n    columns=model_names, index=model_names)","64814e8c":"oof_pred_avg = (oof_pred_lgb + oof_pred_xgb + oof_pred_cat) \/ 3\noof_score_avg = mean_squared_error(y, oof_pred_avg, squared=False)\n\nprint(f\"oof score avg: {oof_score_avg:.5f}\")\n\ntest_pred_avg = (test_pred_lgb + test_pred_xgb + test_pred_cat) \/ 3","f93739e1":"weights = [0.5, 0.4, 0.1]\n\noof_pred_wavg = weights[0] * oof_pred_lgb + weights[1] * oof_pred_xgb + weights[2] * oof_pred_cat\noof_score_wavg = mean_squared_error(y, oof_pred_wavg, squared=False)\n\nprint(f\"oof score weighted avg: {oof_score_wavg:.6f}\")\n\ntest_pred_wavg = weights[0] * test_pred_lgb + weights[1] * test_pred_xgb + weights[2] * test_pred_cat","893086cf":"sub = smpl_sub.copy()\n# sub[TGT_COL] = test_pred_avg\nsub[TGT_COL] = test_pred_wavg\n\nsub.to_csv(\"submission.csv\", index=False)\n\nsub.head()","34333d3b":"### weighted averaging","0470c44f":"### for continuous features\n\nUse them as they are","0f8708ea":"## import libraries","07edc9e0":"### simple averaging","3a877b73":"### LightGBM","0e901242":"# About\n\nI reused my notebook in Tabular Playground Series - Jan 2021:  \nhttps:\/\/www.kaggle.com\/ttahara\/tps-jan-2021-gbdts-baseline\n\n<br>\n\n* GBDT Models baseline\n    * LightGBM, XGBoost, CatBoost\n    * each model is trained by 10 folds cross validation using 3 seeds.\n\n\n* feature engineering\n    * **label-encoding** for category features\n    * no feature engineering for continuous features\n\n\n* inference test by **weighted** averaging 3 GBDT Models(10 folds & 3 seeds averaging)\n\n<br>\n\nThere is a lot of room for improvement such as feature engineering, parameter tuning, other models, and so on. enjoy ;) \n","3e488a43":"## Make submission","ecd9202b":"## read data","5c655988":"## Config ","95257bba":"# Training & Inference","9584ff33":"### Ensemble LGB, XGB, Cat","413e5071":"# Prepare","ba4f87c7":"## Training","62152b14":"### check correlation","4fc2e02b":"## Definition","efee4edd":"### for categorical features\n\napply label encoding using [`category_encoders.OrdinalEncoder`](https:\/\/contrib.scikit-learn.org\/category_encoders\/ordinal.html)","e54249eb":"## Feature Engineering","46275800":"### XGBoost","6d6b06a4":"### CatBoost"}}