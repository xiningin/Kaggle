{"cell_type":{"007a87ed":"code","f7862659":"code","d0399325":"code","5fa7eb4e":"code","e271924c":"code","1bfd4970":"code","a60c0de3":"code","4df6baa8":"code","860913bc":"code","929efc3c":"code","385083b0":"code","388e9b63":"code","b65e3f4e":"code","92ca7477":"code","1fdf5e43":"code","3f263314":"code","5a891c9a":"code","e2c105df":"code","45a1676e":"code","b181a692":"code","f00a7d72":"code","00750640":"code","957c5733":"code","29666110":"markdown"},"source":{"007a87ed":"## Switch\ndef LEFT(a):\n    def f(b):\n        return a\n    return f\n\ndef RIGHT(a):\n    def f(b):\n        return b\n    return f","f7862659":"LEFT(\"5v\")(\"ground\")  ## 2 arguments are curried","d0399325":"RIGHT(\"5v\")(\"ground\")","5fa7eb4e":"## Boolean variables\ndef TRUE(x):\n    '''\n    Return the 1st argument\n    '''\n    return lambda y: x\n\ndef FALSE(x):\n    '''\n    Return the second argument\n    '''\n    return lambda y: y","e271924c":"TRUE(1)(2) ","1bfd4970":"FALSE(0)(1)","a60c0de3":"## NOT gate\ndef NOT(x):\n    return x(FALSE)(TRUE)","4df6baa8":"NOT(TRUE)","860913bc":"NOT(FALSE)","929efc3c":"## AND & OR gates\ndef AND(x):\n    '''\n    If 1st argument is true, return 2nd argument\n    If 1st argument is false, return false\n    x is also a single argument function\n    Curry 2 args using lambda of y\n    '''\n    return lambda y : x(y)(x)\n    \n    \ndef OR(x):\n    '''\n    If 1st argument is true, return true\n    If 1st argument is false, return 2nd argument\n    '''\n    return lambda y : x(x)(y)","385083b0":"AND(TRUE)(FALSE)","388e9b63":"AND(TRUE)(TRUE)","b65e3f4e":"OR(FALSE)(TRUE)","92ca7477":"OR(FALSE)(FALSE)","1fdf5e43":"## Numbers with functions\n## Church Numerals\nONE = lambda f : lambda x : f(x)\nTWO = lambda f : lambda x : f(f(x))\nTHREE = lambda f : lambda x : f(f(f(x)))","3f263314":"ONE","5a891c9a":"TWO","e2c105df":"## How to use Church numerals as functions ?\n## We'll cheat for a bit by using `+` and the number 1. But this is only for illustration purposes. \ndef incr(x): \n    return x + 1\nincr(0)","45a1676e":"ONE(incr)(0)","b181a692":"TWO(incr)(0)","f00a7d72":"THREE(incr)(0)","00750640":"## Exponentiation\nTHREE(TWO)(incr)(0)\n## Start from outermost THREE as THREE has closure\n## incr & TWO don't have closure yet to be evaluated !!\n## TWO(TWO(TWO(incr)))(0)\n## Expanding outermost TWO as it has closure\n## TWO(TWO(incr))(TWO(TWO(incr))(0))\n## Now expanding inner TWO, 3rd from left as it has closure, ie 2 args curried\n## TWO(TWO(incr))(TWO(incr)(TWO(incr)(0))\n## Rightmost TWO has closure now so evaluating that\n## TWO(TWO(incr))(TWO(incr)(2))\n## Again, 3rd or rightmost TWO has closure\n## TWO(TWO(incr))(4)\n## Leftmost TWO has closure now\n## TWO(incr)(TWO(incr)(4))\n## Rightmost TWO has closure\n## TWO(incr)(6)\n## Final TWO has closure now\n## 8","957c5733":"## How do you implement ZERO ?\nZERO = lambda f : lambda x : x\n\nZERO(incr)(0)","29666110":"Working through the Lambda Calculus [tutorial](https:\/\/www.youtube.com\/watch?v=5C6sv7-eTKg&t=1016s) from PyCon 2019 by [David Beazly](https:\/\/twitter.com\/dabeaz).\n\nUsing single argument functions only.\nNothing else.\nNo libraries, numbers, strings, data structures, operators, control flow structures."}}