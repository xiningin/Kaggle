{"cell_type":{"65060890":"code","a7cb27a7":"code","b1af84b6":"code","19d65c94":"code","d9a36562":"code","39c89b63":"code","b961ffce":"code","0f40f161":"code","f3021bd3":"code","f8b3c113":"code","5ead7dcc":"code","942ac266":"code","784c48d6":"code","a53eee42":"code","f0b10b79":"code","ffb31d70":"code","167b86bd":"code","4bb63688":"code","fdeecdde":"code","af718e53":"code","7769c4fc":"code","80ccef3c":"code","3f3bef44":"code","62e146f8":"code","c47dfc9f":"code","2cce49ef":"code","32b4d185":"code","31213dfd":"code","022ee66f":"code","417b01bf":"code","28c187b9":"code","10493cc1":"code","44b7fe13":"code","6e8c4b88":"code","516545be":"code","58b1d279":"code","1485ffb4":"code","815ef152":"code","a633a31d":"code","9d61a78c":"code","ea0f86f6":"code","92663fb1":"code","b0ba2409":"code","0749c8a3":"code","8d0fa514":"markdown","faa2fcf9":"markdown","ea552c89":"markdown","98d01270":"markdown","700f9687":"markdown","a04fb0a4":"markdown","a80abeb1":"markdown","6ef94762":"markdown","2029e0c8":"markdown","f6a5d70e":"markdown","0f57ba73":"markdown","a5165e5d":"markdown","d8fe4757":"markdown","3f291b85":"markdown","02bec88f":"markdown","5ea08010":"markdown","c12c06b4":"markdown","526ff420":"markdown","060260d5":"markdown","1963bf24":"markdown","445d4ce7":"markdown","101adf01":"markdown","dd94e7cf":"markdown","d4d0e2ae":"markdown","72b15070":"markdown","eee28f99":"markdown","c120c6f9":"markdown","b05a16ce":"markdown","1d8c116f":"markdown","28aec63a":"markdown","a620001d":"markdown","c944d9cf":"markdown","2995e550":"markdown","ca951fb4":"markdown"},"source":{"65060890":"import numpy as np \nimport pandas as pd \nimport sys\n\nfrom sklearn import preprocessing\nimport matplotlib.pyplot as plt \nplt.rc(\"font\", size=14)\nimport seaborn as sns\nsns.set(style=\"dark\") #white background style for seaborn plots\nsns.set(style=\"darkgrid\", color_codes=True)\nRED   = \"\\033[1;31m\"  \nBLUE  = \"\\033[1;34m\"\nCYAN  = \"\\033[1;36m\"\nGREEN = \"\\033[0;32m\"\n#sklearn imports source: https:\/\/towardsdatascience.com\/building-a-logistic-regression-in-python-step-by-step-becd4d56c9c8","a7cb27a7":"# get titanic & test csv files as a DataFrame\n\n#developmental data (train)\ntitanic_df = pd.read_csv(\"..\/input\/titanic\/train.csv\")\n\n#cross validation data (hold-out testing)\ntest_df    = pd.read_csv(\"..\/input\/titanic\/test.csv\")\n\n# preview developmental data\ntitanic_df.head(5)\n","b1af84b6":"test_df.head(5)","19d65c94":"a=sum(pd.isnull(titanic_df['Age'])) # COUNT Missing Values in age\nb=round(a\/(len(titanic_df[\"PassengerId\"])),4) # proportion of \"Age\" missing in percent\nsys.stdout.write(GREEN)\nprint(\"Count of missing Values : {} , The Proportion of this values with dataset is {}\\n\".format(a,b*100))\nsys.stdout.write(CYAN)\nprint(\"visualization AGE\")\nax = titanic_df[\"Age\"].hist(bins=15, color='#34495e', alpha=0.9)\nax.set(xlabel='Age', ylabel='Count')\nplt.show()","d9a36562":"m1=titanic_df[\"Age\"].median(skipna=True)\nm2=titanic_df[\"Age\"].mean(skipna=True)\nsys.stdout.write(CYAN)\nprint(\"Median: {} and Mean: {} | Median age is 28 as compared to mean which is ~30\".format(m1,m2))","39c89b63":"# proportion of \"Embarked\" missing\na=round(2\/len(titanic_df[\"PassengerId\"]),4)\nsys.stdout.write(CYAN)\nprint('proportion of \"Embarked\" missing is {}'.format(a*100))","b961ffce":"sys.stdout.write(CYAN)\nprint('visualization Embarked')\nsns.countplot(x='Embarked',data=titanic_df,palette='Set1')\nplt.show()","0f40f161":"train_data = titanic_df\ntrain_data[\"Age\"].fillna(28, inplace=True)\ntrain_data[\"Embarked\"].fillna(\"S\", inplace=True)\ntrain_data.drop('Cabin', axis=1, inplace=True)","f3021bd3":"## Create categorical variable for traveling alone\ntrain_data['TravelBuds']=train_data[\"SibSp\"]+train_data[\"Parch\"]\ntrain_data['TravelAlone']=np.where(train_data['TravelBuds']>0, 0, 1)\n\ntrain_data.drop('SibSp', axis=1, inplace=True)\ntrain_data.drop('Parch', axis=1, inplace=True)\ntrain_data.drop('TravelBuds', axis=1, inplace=True)\n\n#create categorical variable for Pclass || ONE HOT ENCODING\ntrain2 = pd.get_dummies(train_data, columns=[\"Pclass\"])\n\ntrain3 = pd.get_dummies(train2, columns=[\"Embarked\"])\n\ntrain4=pd.get_dummies(train3, columns=[\"Sex\"])\ntrain4.drop('Sex_female', axis=1, inplace=True)\n\n#Drop Unwanted\ntrain4.drop('PassengerId', axis=1, inplace=True)\ntrain4.drop('Name', axis=1, inplace=True)\ntrain4.drop('Ticket', axis=1, inplace=True)\ntrain4.head(5)\ndf_final = train4","f8b3c113":"test_df[\"Age\"].fillna(28, inplace=True)\ntest_df[\"Fare\"].fillna(14.45, inplace=True)\ntest_df.drop('Cabin', axis=1, inplace=True)","5ead7dcc":"test_df['TravelBuds']=test_df[\"SibSp\"]+test_df[\"Parch\"]\ntest_df['TravelAlone']=np.where(test_df['TravelBuds']>0, 0, 1)\n\ntest_df.drop('SibSp', axis=1, inplace=True)\ntest_df.drop('Parch', axis=1, inplace=True)\ntest_df.drop('TravelBuds', axis=1, inplace=True)\n\ntest2 = pd.get_dummies(test_df, columns=[\"Pclass\"])\ntest3 = pd.get_dummies(test2, columns=[\"Embarked\"])\n\ntest4=pd.get_dummies(test3, columns=[\"Sex\"])\ntest4.drop('Sex_female', axis=1, inplace=True)\n\ntest4.drop('PassengerId', axis=1, inplace=True)\ntest4.drop('Name', axis=1, inplace=True)\ntest4.drop('Ticket', axis=1, inplace=True)\nfinal_test = test4","942ac266":"final_test.head(5)","784c48d6":"sys.stdout.write(GREEN)\nprint(\"Density Plot of Age for Surviving Population and Deceased Population\")\nplt.figure(figsize=(15,8))\nsns.kdeplot(titanic_df[\"Age\"][df_final.Survived == 1], color=\"darkturquoise\", shade=True)\nsns.kdeplot(titanic_df[\"Age\"][df_final.Survived == 0], color=\"lightcoral\", shade=True)\nplt.legend(['Survived', 'Died'])\nplt.title('Density Plot of Age for Surviving Population and Deceased Population')\nplt.show()\n","a53eee42":"plt.figure(figsize=(25,8))\navg_survival_byage = df_final[[\"Age\", \"Survived\"]].groupby(['Age'],as_index=False).mean()\ng = sns.barplot(x='Age', y='Survived', data=avg_survival_byage, color=\"LightSeaGreen\")\n","f0b10b79":"df_final['IsMinor']=np.where(train_data['Age']<=16, 1, 0)","ffb31d70":"final_test['IsMinor']=np.where(final_test['Age']<=16, 1, 0)","167b86bd":"plt.figure(figsize=(15,8))\nsns.kdeplot(df_final[\"Fare\"][titanic_df.Survived == 1], color=\"#e74c3c\", shade=True)\nsns.kdeplot(df_final[\"Fare\"][titanic_df.Survived == 0], color=\"#3498db\", shade=True)\nplt.legend(['Survived', 'Died'])\nplt.title('Density Plot of Fare for Surviving Population and Deceased Population')\n# limit x axis to zoom on most information. there are a few outliers in fare. \nplt.xlim(-20,200)\nplt.show()","4bb63688":"sns.barplot('Pclass', 'Survived', data=titanic_df, color=\"#2ecc71\")\nplt.show()","fdeecdde":"sns.barplot('Embarked', 'Survived', data=titanic_df, color=\"#2ecc71\")\nplt.show()","af718e53":"sns.barplot('TravelAlone', 'Survived', data=df_final, color=\"#2ecc71\")\nplt.show()","7769c4fc":"cols=[\"Age\", \"Fare\", \"TravelAlone\", \"Pclass_1\", \"Pclass_2\",\"Embarked_C\",\"Embarked_S\",\"Sex_male\",\"IsMinor\"] \nX=df_final[cols]\nY=df_final['Survived']","80ccef3c":"import statsmodels.api as sm\nfrom scipy import stats\nstats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)\nlogit_model=sm.Logit(Y,X)\nresult=logit_model.fit()\nsys.stdout.write(GREEN)\nprint(result.summary())","3f3bef44":"cols2=[\"Age\", \"Pclass_1\", \"Pclass_2\",\"Embarked_C\",\"Embarked_S\",\"Sex_male\"]  \nX2=df_final[cols2]\nY=df_final['Survived']\n\nlogit_model=sm.Logit(Y,X2)\nresult=logit_model.fit()\nsys.stdout.write(GREEN)\nprint(result.summary())","62e146f8":"from sklearn.linear_model import LogisticRegression\n\nlogreg = LogisticRegression()\nlogreg.fit(X2, Y)\n\nprint(\"Model Accuracy : {:.2f}%\".format(logreg.score(X2, Y)*100))","c47dfc9f":"from sklearn.model_selection import train_test_split\ntrain, test = train_test_split(df_final, test_size=0.25)","2cce49ef":"#re-fit logistic regression on new train sample\n\ncols2=[\"Age\", \"Pclass_1\", \"Pclass_2\",\"Embarked_C\",\"Embarked_S\",\"Sex_male\"] \nX3=train[cols2]\nY3=train['Survived']\nlogit_model3=sm.Logit(Y3,X3)","32b4d185":"from sklearn.linear_model import LogisticRegression\nfrom sklearn import metrics\n\nlogreg = LogisticRegression()\nlogreg.fit(X3, Y3)\nsys.stdout.write(GREEN)\nprint(\"Model Accuracy : {:.2f}%\".format(logreg.score(X3, Y3)*100))","31213dfd":"from sklearn import metrics\nlogreg.fit(X3, Y3)\n\nX3_test = test[cols2]\nY3_test = test['Survived']\n\nY3test_pred = logreg.predict(X3_test)\nsys.stdout.write(GREEN)\nprint('Accuracy of logistic regression classifier on test set: {:.2f}'.format(logreg.score(X3_test, Y3_test)*100))","022ee66f":"# Model's in sample AUC\n\nfrom sklearn.metrics import roc_auc_score\nlogreg.fit(X3, Y3)\nY3_pred = logreg.predict(X3)\n\ny_true = Y3\ny_scores = Y3_pred\nsys.stdout.write(GREEN)\nprint(\"Model ROC_AUC : {:.2f}%\".format(roc_auc_score(y_true, y_scores)))","417b01bf":"#Visualizing the model's ROC curve (**source for graph code given below the plot)\nfrom sklearn.metrics import roc_curve, auc\nlogreg.fit(X3, Y3)\n\ny_test = Y3_test\nX_test = X3_test\n \n# Determine the false positive and true positive rates\nFPR, TPR, _ = roc_curve(y_test, logreg.predict_proba(X_test)[:,1])\n \n# Calculate the AUC\nsys.stdout.write(GREEN)\nroc_auc = auc(FPR, TPR)\nprint ('ROC AUC: %0.3f' % roc_auc )\n \n# Plot of a ROC curve\nplt.figure(figsize=(10,10))\nplt.plot(FPR, TPR, label='ROC curve (area = %0.3f)' % roc_auc)\nplt.plot([0, 1], [0, 1], 'k--')\nplt.xlim([-0.05, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('ROC Curve (Test Sample Performance)')\nplt.legend(loc=\"lower right\")\nplt.show()","28c187b9":"from sklearn.ensemble import RandomForestClassifier\n\ncols=[\"Age\", \"Fare\", \"TravelAlone\", \"Pclass_1\", \"Pclass_2\",\"Embarked_C\",\"Embarked_S\",\"Sex_male\",\"IsMinor\"] \nX=df_final[cols]\nY=df_final['Survived']\n\nrandom_forest = RandomForestClassifier(n_estimators=100)\nrandom_forest.fit(X, Y)\nsys.stdout.write(GREEN)\nprint ('ROC AUC: %0.3f' % random_forest.score(X, Y) )","10493cc1":"final_test_RF=final_test[cols]\nY_pred_RF = random_forest.predict(final_test_RF)","44b7fe13":"submission = pd.DataFrame({\n        \"PassengerId\": test_df[\"PassengerId\"],\n        \"Survived\": Y_pred_RF\n    })\nsubmission.to_csv('titanic_RF.csv', index=False)","6e8c4b88":"from sklearn import tree\nimport graphviz\ntree1 = tree.DecisionTreeClassifier(criterion='gini', splitter='best',max_depth=3, min_samples_leaf=20)","516545be":"cols=[\"Age\", \"Fare\", \"TravelAlone\", \"Pclass_1\", \"Pclass_2\",\"Embarked_C\",\"Embarked_S\",\"Sex_male\",\"IsMinor\"] \nX_DT=df_final[cols]\nY_DT=df_final['Survived']\n\ntree1.fit(X_DT, Y_DT)","58b1d279":"import graphviz \ntree1_view = tree.export_graphviz(tree1, out_file=None, feature_names = X_DT.columns.values, rotate=True) \ntree1viz = graphviz.Source(tree1_view)\ntree1viz","1485ffb4":"final_test_DT=final_test[cols]\nY_pred_DT = tree1.predict(final_test_DT)\n\nsubmission = pd.DataFrame({\n       \"PassengerId\": test_df[\"PassengerId\"],\n       \"Survived\": Y_pred_DT\n   })\nsubmission.to_csv('titanic_DT.csv', index=False)","815ef152":"submission = pd.DataFrame({\n        \"PassengerId\": test_df[\"PassengerId\"],\n        \"Survived\": Y_pred_RF* 0.8 + Y_pred_DT*0.2 #ensmeble of two models\n    })\nsubmission.to_csv('titanic_ensemble.csv', index=False)","a633a31d":"from sympy import simplify, cos, sin, Symbol, Function, tanh, pprint, init_printing, exp\nfrom sympy.functions import Min,Max","9d61a78c":"# the winner variables with former values after the hashtag\nA = 0.058823499828577    \nB = 0.841127 # 0.885868\nC = 0.138462007045746 \nD = 0.31830988618379069\nE = 2.810815 # 2.675679922103882 \nF = 0.63661977236758138\nG = 5.428569793701172   \nH = 3.1415926535897931\nI = 0.592158 #0.623655974864960\nJ = 4.869778 #  2.770736 # 2.212120056152344\nK = 0.063467 # 1.5707963267948966\nL = -0.091481 # 0.094339601695538 \nM = 0.0821533 \nN = 0.720430016517639\nO = 0.230145 \nP = 9.89287 \nQ = 785 \nR = 1.07241 \nS = 281\nT = 734\nU = 5.3\nV = 67.0\nW = 2.484848\nX = 8.48635 \nY = 63\nZ = 12.6275 \nAA = 0.735354 # 0.7\nAB = 727\nAC = 2.5\nAD = 2.6 \nAE = 0.3\nAF = 3.0\nAG = 0.226263 #0.1\nAH = 2.0\nAI = 12.4148\nAJ = 96\nAK = 0.130303 # 0.2\nAL = 176\nAM = 3.2\nBIG = [A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM]","ea0f86f6":"# Now may I present: The winning gen function, Inspired by Akshat's notebook:\n# https:\/\/www.kaggle.com\/akshat113\/titanic-dataset-analysis-level-2\ndef GeneticFunction(data,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM):\n    return ((np.minimum( ((((A + data[\"Sex\"]) - np.cos((data[\"Pclass\"] \/ AH))) * AH)),  ((B))) * AH) +\n            np.maximum( ((data[\"SibSp\"] - AC)),  ( -(np.minimum( (data[\"Sex\"]),  (np.sin(data[\"Parch\"]))) * data[\"Pclass\"]))) +\n            (AG * ((np.minimum( (data[\"Sex\"]),  (((data[\"Parch\"] \/ AH) \/ AH))) * data[\"Age\"]) - data[\"Cabin\"])) +\n            np.minimum( ((np.sin((data[\"Parch\"] * ((data[\"Fare\"] - AA) * AH))) * AH)),  ((data[\"SibSp\"] \/ AH))) +\n            np.maximum( (np.minimum( ( -np.cos(data[\"Embarked\"])),  (C))),  (np.sin(((data[\"Cabin\"] - data[\"Fare\"]) * AH)))) +\n            -np.minimum( ((((data[\"Age\"] * data[\"Parch\"]) * data[\"Embarked\"]) + data[\"Parch\"])),  (np.sin(data[\"Pclass\"]))) +\n            np.minimum( (data[\"Sex\"]),  ((np.sin( -(data[\"Fare\"] * np.cos((data[\"Fare\"] * W)))) \/ AH))) +\n            np.minimum( ((O)),  (np.sin(np.minimum( (((V \/ AH) * np.sin(data[\"Fare\"]))),  (D))))) +\n            np.sin((np.sin(data[\"Cabin\"]) * (np.sin((Z)) * np.maximum( (data[\"Age\"]),  (data[\"Fare\"]))))) +\n            np.sin(((np.minimum( (data[\"Fare\"]),  ((data[\"Cabin\"] * data[\"Embarked\"]))) \/ AH) *  -data[\"Fare\"])) +\n            np.minimum( (((AD * data[\"SibSp\"]) * np.sin(((AJ) * np.sin(data[\"Cabin\"]))))),  (data[\"Parch\"])) +\n            np.sin(np.sin((np.maximum( (np.minimum( (data[\"Age\"]),  (data[\"Cabin\"]))),  ((data[\"Fare\"] * AK))) * data[\"Cabin\"]))) +\n            np.maximum( (np.sin(((AI) * (data[\"Age\"] \/ AH)))),  (np.sin((-AF * data[\"Cabin\"])))) +\n            (np.minimum( (np.sin((((np.sin(((data[\"Fare\"] * AH) * AH)) * AH) * AH) * AH))),  (data[\"SibSp\"])) \/ AH) +\n            ((data[\"Sex\"] - data[\"SibSp\"]) * (np.cos(((data[\"Embarked\"] - AA) + data[\"Age\"])) \/ AH)) +\n            ((np.sin(data[\"Cabin\"]) \/ AH) - (np.cos(np.minimum( (data[\"Age\"]),  (data[\"Embarked\"]))) * np.sin(data[\"Embarked\"]))) +\n            np.minimum( (AE),  ((data[\"Sex\"] * (J * (N - np.sin((data[\"Age\"] * AH))))))) +\n            (np.minimum( (np.cos(data[\"Fare\"])),  (np.maximum( (np.sin(data[\"Age\"])),  (data[\"Parch\"])))) * np.cos((data[\"Fare\"] \/ AH))) +\n            np.sin((data[\"Parch\"] * np.minimum( ((data[\"Age\"] - K)),  ((np.cos((data[\"Pclass\"] * AH)) \/ AH))))) +\n            (data[\"Parch\"] * (np.sin(((data[\"Fare\"] * (I * data[\"Age\"])) * AH)) \/ AH)) +\n            (D * np.cos(np.maximum( ((0.5 * data[\"Fare\"])),  ((np.sin(N) * data[\"Age\"]))))) +\n            (np.minimum( ((data[\"SibSp\"] \/ AH)),  (np.sin(((data[\"Pclass\"] - data[\"Fare\"]) * data[\"SibSp\"])))) * data[\"SibSp\"]) +\n            np.tanh((data[\"Sex\"] * np.sin((U * np.sin((data[\"Cabin\"] * np.cos(data[\"Fare\"]))))))) +\n            (np.minimum( (data[\"Parch\"]),  (data[\"Sex\"])) * np.cos(np.maximum( ((np.cos(data[\"Parch\"]) + data[\"Age\"])),  (AM)))) +\n            (np.minimum( (np.tanh(((data[\"Cabin\"] \/ AH) + data[\"Parch\"]))),  ((data[\"Sex\"] + np.cos(data[\"Age\"])))) \/ AH) +\n            (np.sin((np.sin(data[\"Sex\"]) * (np.sin((data[\"Age\"] * data[\"Pclass\"])) * data[\"Pclass\"]))) \/ AH) +\n            (data[\"Sex\"] * (np.cos(((data[\"Sex\"] + data[\"Fare\"]) * ((X) * (Y)))) \/ AH)) +\n            np.minimum( (data[\"Sex\"]),  ((np.cos((data[\"Age\"] * np.tanh(np.sin(np.cos(data[\"Fare\"]))))) \/ AH))) +\n            (np.tanh(np.tanh( -np.cos((np.maximum( (np.cos(data[\"Fare\"])),  (L)) * data[\"Age\"])))) \/ AH) +\n            (np.tanh(np.cos((np.cos(data[\"Age\"]) + (data[\"Age\"] + np.minimum( (data[\"Fare\"]),  (data[\"Age\"])))))) \/ AH) +\n            (np.tanh(np.cos((data[\"Age\"] * ((-AH + np.sin(data[\"SibSp\"])) + data[\"Fare\"])))) \/ AH) +\n            (np.minimum( (((S) - data[\"Fare\"])),  (np.sin((np.maximum( ((AL)),  (data[\"Fare\"])) * data[\"SibSp\"])))) * AH) +\n            np.sin(((np.maximum( (data[\"Embarked\"]),  (data[\"Age\"])) * AH) * (((Q) * H) * data[\"Age\"]))) +\n            np.minimum( (data[\"Sex\"]),  (np.sin( -(np.minimum( ((data[\"Cabin\"] \/ AH)),  (data[\"SibSp\"])) * (data[\"Fare\"] \/ AH))))) +\n            np.sin(np.sin((data[\"Cabin\"] * (data[\"Embarked\"] + (np.tanh( -data[\"Age\"]) + data[\"Fare\"]))))) +\n            (np.cos(np.cos(data[\"Fare\"])) * (np.sin((data[\"Embarked\"] - ((T) * data[\"Fare\"]))) \/ AH)) +\n            ((np.minimum( (data[\"SibSp\"]),  (np.cos(data[\"Fare\"]))) * np.cos(data[\"SibSp\"])) * np.sin((data[\"Age\"] \/ AH))) +\n            (np.sin((np.sin((data[\"SibSp\"] * np.cos((data[\"Fare\"] * AH)))) + (data[\"Cabin\"] * AH))) \/ AH) +\n            (((data[\"Sex\"] * data[\"SibSp\"]) * np.sin(np.sin( -(data[\"Fare\"] * data[\"Cabin\"])))) * AH) +\n            (np.sin((data[\"SibSp\"] * ((((G + V) * AH) \/ AH) * data[\"Age\"]))) \/ AH) +\n            (data[\"Pclass\"] * (np.sin(((data[\"Embarked\"] * data[\"Cabin\"]) * (data[\"Age\"] - (R)))) \/ AH)) +\n            (np.cos((((( -data[\"SibSp\"] + data[\"Age\"]) + data[\"Parch\"]) * data[\"Embarked\"]) \/ AH)) \/ AH) +\n            (D * np.sin(((data[\"Age\"] * ((data[\"Embarked\"] * np.sin(data[\"Fare\"])) * AH)) * AH))) +\n            ((np.minimum( ((data[\"Age\"] * A)),  (data[\"Sex\"])) - F) * np.tanh(np.sin(data[\"Pclass\"]))) +\n            -np.minimum( ((np.cos(((AB) * ((data[\"Fare\"] + data[\"Parch\"]) * AH))) \/ AH)),  (data[\"Fare\"])) +\n            (np.minimum( (np.cos(data[\"Fare\"])),  (data[\"SibSp\"])) * np.minimum( (np.sin(data[\"Parch\"])),  (np.cos((data[\"Embarked\"] * AH))))) +\n            (np.minimum( (((data[\"Fare\"] \/ AH) - E)),  (C)) * np.sin((K * data[\"Age\"]))) +\n            np.minimum( ((M)),  (((np.sin(data[\"Fare\"]) + data[\"Embarked\"]) - np.cos((data[\"Age\"] * (P)))))))","92663fb1":"def CleanData(data):\n    # Sex\n    data.drop(['Ticket', 'Name'], inplace=True, axis=1)\n    data.Sex.fillna('0', inplace=True)\n    data.loc[data.Sex != 'male', 'Sex'] = 0\n    data.loc[data.Sex == 'male', 'Sex'] = 1\n    # Cabin\n    data.Cabin.fillna('0', inplace=True)\n    data.loc[data.Cabin.str[0] == 'A', 'Cabin'] = 1\n    data.loc[data.Cabin.str[0] == 'B', 'Cabin'] = 2\n    data.loc[data.Cabin.str[0] == 'C', 'Cabin'] = 3\n    data.loc[data.Cabin.str[0] == 'D', 'Cabin'] = 4\n    data.loc[data.Cabin.str[0] == 'E', 'Cabin'] = 5\n    data.loc[data.Cabin.str[0] == 'F', 'Cabin'] = 6\n    data.loc[data.Cabin.str[0] == 'G', 'Cabin'] = 7\n    data.loc[data.Cabin.str[0] == 'T', 'Cabin'] = 8\n    # Embarked\n    data.loc[data.Embarked == 'C', 'Embarked'] = 1\n    data.loc[data.Embarked == 'Q', 'Embarked'] = 2\n    data.loc[data.Embarked == 'S', 'Embarked'] = 3\n    data.Embarked.fillna(0, inplace=True)\n    data.fillna(-1, inplace=True)\n    return data.astype(float)\n\n# This function rounds values to either 1 or 0, because the GeneticFunction below returns floats and no\n# definite values\ndef Outputs(data):\n    return np.round(1.-(1.\/(1.+np.exp(-data))))","b0ba2409":"raw_train = pd.read_csv('..\/input\/titanic\/train.csv')\nraw_test = pd.read_csv('..\/input\/titanic\/test.csv')\n\ncleanedTrain = CleanData(raw_train)\ncleanedTest = CleanData(raw_test)\n# run a check on the Training dataset. See section \"Programm your own gen. algorithm\" below on how to \n# construct your own genetic algorithm\nthisArray = BIG.copy()\ntestPredictions = Outputs(GeneticFunction(cleanedTrain,thisArray[0],thisArray[1],thisArray[2],thisArray[3],thisArray[4],thisArray[5],thisArray[6],thisArray[7],thisArray[8],thisArray[9],thisArray[10],thisArray[11],thisArray[12],thisArray[13],thisArray[14],thisArray[15],thisArray[16],thisArray[17],thisArray[18],thisArray[19],thisArray[20],thisArray[21],thisArray[22],thisArray[23],thisArray[24],thisArray[25],thisArray[26],thisArray[27],thisArray[28],thisArray[29],thisArray[30],thisArray[31],thisArray[32],thisArray[33],thisArray[34],thisArray[35],thisArray[36],thisArray[37],thisArray[38]))\npdcheck = pd.DataFrame({'Survived': testPredictions.astype(int)})\nret = pdcheck.Survived.where(pdcheck[\"Survived\"].values==cleanedTrain[\"Survived\"].values).notna()\nt,f = ret.value_counts()\nscore = 100\/(t+f)*t\nprint(\"Training set score: \",score)","0749c8a3":"testPredictions = Outputs(GeneticFunction(cleanedTest,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM))\npdtest = pd.DataFrame({'PassengerId': cleanedTest.PassengerId.astype(int),\n                        'Survived': testPredictions.astype(int)})\npdtest.to_csv('submission_GA.csv', index=False)\npdtest.head()","8d0fa514":"## 3. Exploratory Data Analysis <a class=\"anchor\" id=\"3-bullet\"><\/a>","faa2fcf9":"> Individuals traveling without family were more likely to die in the disaster than those with family aboard.  Given the era, it's likely that individuals traveling alone were likely male.","ea552c89":"## 1. Import Data & Python Packages <a class=\"anchor\" id=\"1-bullet\"><\/a>","98d01270":"### 2.3 Final Adjustments to Data (Train & Test) <a class=\"anchor\" id=\"2.3-bullet\"><\/a>\n\n> Based on my assessment of the missing values in the dataset, I'll make the following changes to the data:\n> * If \"Age\" is missing for a given row, I'll impute with 28 (median age).\n> * If \"Embark\" is missing for a riven row, I'll impute with \"S\" (the most common boarding port).\n> * I'll ignore \"Cabin\" as a variable.  There are too many missing values for imputation.  Based on the information available, it appears that this value is associated with the passenger's class and fare paid.","700f9687":"> Unsurprisingly, being a first class passenger was safest.","a04fb0a4":"## 3.3 Exploration of Passenger Class <a class=\"anchor\" id=\"3.3-bullet\"><\/a>","a80abeb1":"### Assessing the model's performance based on Cross Validation ROC\/AUC ","6ef94762":"> Our Logistic Regression is effective and easy to interpret, but there are other ML techniques which could provide a more accurate prediction.  Random forests, a tree-based machine learning technique, often provide more accurate results than Logistic Regression classifier models.  With respect to tree growth, performance tends to taper off after a certain number of trees are grown. <br> <br>\n> A random forest is a meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting. ","2029e0c8":"<center><font size=\"10\">\ud83d\udea2\ud83c\udfca\ud83c\udffb\u200d\u2640\ufe0fTitanic Start Here: A GENTLE Introduction<\/font><\/center>\n<br>\n<center><font size=\"3\">Introdution<\/font><\/center>\n> In this Kernel we will see 3 approaches to the classification task in detail.\n> 1. [Import Data & Python Packages](#1-bullet) <br>\n> 2. [Missing Value Handling](#2-bullet)<br>\n>     * [2.1 Age - Missing Values](#2.1-bullet) <br>\n>     * [2.2 Embarked - Missing Values](#2.2-bullet) <br>\n>     * [2.3 Final Adjustments to Data](#2.3-bullet) <br>\n>     * [2.4 Additional Variables](#2.4-bullet) <br> \n> 3. [Exploratory Data Analysis](#3-bullet) <br>\n> 4. [Alternate Approach 1 :Logistic Regression](#4-bullet) <br>\n> 5. [Alternate Approach 2 : Random Forest Estimation](#5-bullet) <br>\n> 6. [Alternate Approach 3: Decision Tree](#6-bullet) <br>\n> 7. [Ensemble](#7-bullet)\n> 8. [TOP 1% Solution GA](#8-bullet)","f6a5d70e":"## 4.3 Using 75-25 Split for Cross Validation <a class=\"anchor\" id=\"4.3-bullet\"><\/a>","0f57ba73":"## 3.1 Exploration of Age <a class=\"anchor\" id=\"3.1-bullet\"><\/a>","a5165e5d":"> Since \"Age\" is (right) skewed, using the mean might give us biased results by filling in ages that are older than desired.  To deal with this, we'll use the median to impute the missing values. ","d8fe4757":"## 4. Logistic Regression <a class=\"anchor\" id=\"4-bullet\"><\/a>","3f291b85":"## 3.2 Exploration of Fare <a class=\"anchor\" id=\"3.2-bullet\"><\/a>","02bec88f":"## 6. Decision Tree <a class=\"anchor\" id=\"6-bullet\"><\/a>","5ea08010":"> An AUC score of 0.5 is effectively as good as the flip of a coin, and means that the model really has no classification power at all between the positive and negative occurences. The AUC for both the test and train samples when run on my logistic regression demonstrates relatively strong power of separation between positive and negative occurences (survived - 1, died - 0).","c12c06b4":"## 2. Data Quality & Missing Value Assessment <a class=\"anchor\" id=\"2-bullet\"><\/a>","526ff420":"## 5. Random Forest Estimation <a class=\"anchor\" id=\"5-bullet\"><\/a>","060260d5":"# 4.5 Logistic Regression Conclusion<br> <a class=\"anchor\" id=\"4.5-bullet\"><\/a>\n> Based on my analysis, if you were to be aboard the Titanic, your chances of survival were best if you fit the following criteria:<br>\n> * Female\n> * Young\n> * In First Class \n> * Embarked in Cherbourg France\n","1963bf24":"### Apply the same changes to the test data. <br>\n","445d4ce7":"> The score for the new training sample (75% of original) is very close to the original performance, which is good!<br>\n> Let's assess how well it scores on the 25% hold-out sample.","101adf01":"### 2.2 Embarked - Missing Values <a class=\"anchor\" id=\"2.2-bullet\"><\/a>","dd94e7cf":"> The age distribution for survivors and deceased is actually very similar.  One notable difference is that, of the survivors, a larger proportion were children.  The passengers evidently made an attempt to save children by giving them a place on the life rafts. ","d4d0e2ae":"## 3.5 Exploration of Traveling Alone vs. With Family <a class=\"anchor\" id=\"3.5-bullet\"><\/a>","72b15070":"> Nearly all variables are significant at the 0.05 alpha level, but we'll run the model again without Fare and TravelAlone (removed one at a time, results didn't change much.  In the end removed both).  I also removed \"IsMinor\" from this regression, as the information provided is redundant to the Age variable.","eee28f99":"## 7. Ensemble <a class=\"anchor\" id=\"7-bullet\"><\/a>\n\n> Ensemble Learning is a process using which multiple machine learning models (such as classifiers) are strategically constructed to solve a particular problem.\n> \n> Ensemble methods are meta-algorithms that combine several machine learning techniques into one predictive model in order to decrease variance (bagging), bias (boosting), or improve predictions (stacking).","c120c6f9":"## 3.4 Exploration of Embarked Port <a class=\"anchor\" id=\"3.4-bullet\"><\/a>","b05a16ce":"> Let's try another method- a decision tree.  There is a tradeoff for the additional complexity of utilizing a decision tree as compared to a logistic regression: growing your number of trees too much can subject your model to overfitting and reduce the predictive power of the model.  I've set parameters within the DecisionTreeClassifier from sklearn to help make sure my model is not overfit (too many branches based on the train data).  Some trial and error went into this to determine the optimal number of branches to \"prune\" to achieve strong out-of-sample results.<br><br>\n> *Note*: Again, I used the same variables for the decision tree as I did in my first logistic regression and in my random forest.","1d8c116f":"## 8. TOP 1% Solution Genetic Algorithm <a class=\"anchor\" id=\"8-bullet\"><\/a>","28aec63a":"# 4.4 Out-of-sample Assessment <br> <a class=\"anchor\" id=\"4.4-bullet\"><\/a>","a620001d":"### 2.4 Additional Variables <a class=\"anchor\" id=\"2.4-bullet\"><\/a>\n\n> According to the Kaggle data dictionary, both SibSp and Parch relate to traveling with family.  For simplicity's sake (and to account for possible multicollinearity), we will combine the effect of these variables into one categorical predictor: whether or not that individual was traveling alone.","c944d9cf":"## Final RF Submission","2995e550":"### 2.1    Age - Missing Values <a class=\"anchor\" id=\"2.1-bullet\"><\/a>","ca951fb4":"> Considering the survival rate of passengers under 16, I'll also include another categorical variable in my dataset: \"Minor\""}}