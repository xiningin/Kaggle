{"cell_type":{"9c62590e":"code","45c63406":"code","9d8b5d1c":"code","a60325fb":"code","b00b9a2c":"code","9c1deb8a":"code","4e0fc544":"code","e5e2a75d":"code","5fefc298":"code","e710893c":"code","b710a126":"code","962fbd2d":"code","9473c662":"code","aa63ab38":"code","84c51ceb":"code","2fbff7b3":"markdown","87afc773":"markdown","913c3d0d":"markdown","bb2f4ff7":"markdown","37295991":"markdown","e30e696d":"markdown","7e8505a7":"markdown","1df8cc82":"markdown","00bfabf2":"markdown","c648d706":"markdown","8accbe00":"markdown","9dee7c6e":"markdown"},"source":{"9c62590e":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport igraph","45c63406":"\ndef partition_data(Xcp, NodePositions, MaxBlockSize = 10**6,SquaredXcp= None,\n                  TrimmingRadius=float('inf')):\n    '''\n    # Partition the data by proximity to graph nodes\n    # (same step as in K-means EM procedure)\n    #\n    # Inputs:\n    #   X is n-by-m matrix of datapoints with one data point per row. n is\n    #       number of data points and m is dimension of data space.\n    #   NodePositions is k-by-m matrix of embedded coordinates of graph nodes,\n    #       where k is number of nodes and m is dimension of data space.\n    #   MaxBlockSize integer number which defines maximal number of\n    #       simultaneously calculated distances. Maximal size of created matrix\n    #       is MaxBlockSize-by-k, where k is number of nodes.\n    #   SquaredX is n-by-1 vector of data vectors length: SquaredX = sum(X.^2,2);\n    #   TrimmingRadius (optional) is squared trimming radius.\n    #\n    # Outputs\n    #   partition is n-by-1 vector. partition[i] is number of the node which is\n    #       associated with data point X[i, ].\n    #   dists is n-by-1 vector. dists[i] is squared distance between the node with\n    #       number partition[i] and data point X[i, ].\n    '''\n    if SquaredXcp is None:\n      SquaredXcp = np.sum(Xcp**2,1)[:,np.newaxis]\n    NodePositionscp = np.asarray(NodePositions)\n    n = Xcp.shape[0]\n    partition = np.zeros((n, 1), dtype=int)\n    dists = np.zeros((n, 1))\n    all_dists = np.zeros((n, NodePositions.shape[0] ))\n    # Calculate squared length of centroids\n    cent = NodePositionscp.T\n    centrLength = (cent**2).sum(axis=0)\n    # Process partitioning without trimming\n    for i in range(0, n, MaxBlockSize):\n        # Define last element for calculation\n        last = i+MaxBlockSize\n        if last > n:\n            last = n\n        # Calculate distances\n        d = SquaredXcp[i:last] + centrLength-2*np.dot(Xcp[i:last, ], cent)\n        tmp = d.argmin(axis=1)\n        partition[i:last] = tmp[:, np.newaxis]\n        dists[i:last] = d[np.arange(d.shape[0]), tmp][:, np.newaxis]\n        all_dists[i:last,:] = d\n    # Apply trimming\n    if not np.isinf(TrimmingRadius):\n        ind = dists > (TrimmingRadius**2)\n        partition[ind] = -1\n        dists[ind] = TrimmingRadius**2\n    \n    \n    return np.asarray(partition), np.asarray(dists), np.asarray(all_dists)\n\n\n\ndef find_branches( graph, verbose = 0 ):\n  '''\n  #' Computes \"branches\" of the graph, i.e. paths from branch vertex (or terminal vertex)  to branch vertex (or terminal vertex)\n  #' Can process disconnected graphs. Stand-alone point - is \"branch\".\n  #' Circle is exceptional case - each circle (can be several connected components) is \"branch\"\n  #'\n  #' @param g - graph (igraph) \n  #' @param verbose - details output\n  #' \n  #' @examples\n  #' import igraph\n  #' g = igraph.Graph.Lattice([3,3], circular = False ) \n  #' dict_output = find_branches(g, verbose = 1000)\n  #' print( dict_output['branches'] )\n  '''\n  #verbose = np.inf\n  #\n  g = graph\n  n_vertices_input_graph =   g.vcount()  \n  set_vertices_input_graph = set( range( n_vertices_input_graph  ) ) \n\n  dict_output = {}\n  #dict_output['branches'] = found_branches.copy()\n\n  # Main variables for process: \n  found_branches = []\n  processed_edges = []\n  processed_vertices = set()\n\n  ############################################################################################################################################\n  # Connected components loop:\n  count_connected_components = 0 \n  while True: # Need loop if graph has several connected components, each iteration - new component\n    count_connected_components += 1\n\n    def find_start_vertex(g, processed_vertices ): \n      '''\n      #' Find starting vertex for branches-search algorithm. \n      #' It should be either branching vertex (i.e. degree >2) or terminal vertex (i.e. degree 0 or 1), in special case when unprocessed part of graph is union of circles - processed outside function\n      '''\n      n_vertices = n_vertices_input_graph #  = g.count()# \n      if n_vertices == len( processed_vertices ):\n        return -1,-1 # All vertices proccessed\n      flag_found_start_vertex = 0 \n      for v in set_vertices_input_graph: \n        if v in processed_vertices: continue\n        if g.degree(v) != 2:\n          flag_found_start_vertex = 1\n          return v, flag_found_start_vertex\n      return -1, 0 # All unprocessed vertices are of degree 2, that means graph is circle of collection or collection of circles\n\n    ############################################################################################################################################\n    # Starting point initialization. End process condtion.\n    #\n    # Set correctly the starting vertex for the algorithm\n    # That should be branch vertex or terminal vertex, only in case graph is set of circles(disconnected) we take arbitrary vertex as initial, each circle will be a branch\n    initial_vertex, flag_found_start_vertex = find_start_vertex(g, processed_vertices )\n    if   flag_found_start_vertex > 0:\n      current_vertex  = initial_vertex\n    elif flag_found_start_vertex == 0: # All unprocessed vertices are of degree 2, that means graph is circle of collection or collection of circles\n      # Take any unprocessed element \n      tmp_set = set_vertices_input_graph  - processed_vertices\n      current_vertex = tmp_set.pop()\n    else:\n      # No vertices to process \n      if verbose >= 10:\n        print('Process finished')\n      dict_output['branches'] = found_branches.copy()\n      return dict_output\n      #break\n\n    ############################################################################################################################################\n    # Core function implementing \"Breath First Search\" like algorithm\n    # with some updates in storage, since we need to arrange edges into \"branches\"\n    def find_branches_core( current_vertex , previous_vertex, current_branch  ):\n      core_call_count[0] = core_call_count[0] + 1\n      if verbose >= 1000:\n        print(core_call_count[0], 'core call.', 'current_vertex', current_vertex , 'previous_vertex', previous_vertex,'found_branches',found_branches, 'current_branch',current_branch )\n\n      processed_vertices.add(current_vertex)\n      neis = g.neighbors(current_vertex) \n      if len(neis) == 0: # current_vertex is standalone vertex\n        found_branches.append( [current_vertex] )\n        return \n      if len(neis) == 1: # current_vertex is terminal vertex\n        if neis[0] == previous_vertex:\n          current_branch.append( current_vertex  )\n          found_branches.append( current_branch.copy() )\n          # processed_edges.append(  set([current_vertex , previous_vertex])  )  \n          return \n        else:\n          # That case may happen if we just started from that vertex\n          # Because it has one neigbour, but it is not previous_vertex, so it is None, which is only at start \n          current_branch = [current_vertex] # , neis[0] ] # .append( current_vertex  )\n          processed_edges.append(  set([current_vertex , neis[0] ])  )\n          find_branches_core( current_vertex = neis[0] , previous_vertex = current_vertex, current_branch = current_branch )  \n          return\n      if len(neis) == 2: # \n        # continue the current branch:\n        current_branch.append( current_vertex  )\n        next_vertex = neis[0]\n        if next_vertex == previous_vertex: next_vertex = neis[1]\n        if next_vertex in processed_vertices: # Cannot happen for trees, but may happen if graph has a loop\n          if set([current_vertex , next_vertex]) not in processed_edges:\n            current_branch.append( next_vertex  )\n            found_branches.append( current_branch.copy() )\n            processed_edges.append(  set([current_vertex , next_vertex])  )\n            return \n          else:\n            return\n        processed_edges.append(  set([current_vertex , next_vertex])  )          \n        find_branches_core( current_vertex=next_vertex , previous_vertex = current_vertex, current_branch = current_branch )\n        return\n      if len(neis)  > 2 : #Branch point\n        if  previous_vertex is not None:\n          # Stop current branch\n          current_branch.append( current_vertex  )\n          found_branches.append(current_branch.copy())\n        for next_vertex in neis:\n            if next_vertex ==  previous_vertex:    continue\n            if next_vertex in  processed_vertices: # Cannot happen for trees, but may happen if graph has a loop\n              if set([current_vertex , next_vertex]) not in processed_edges:\n                processed_edges.append(  set([current_vertex , next_vertex])  )\n                found_branches.append( [current_vertex, next_vertex ] )\n              continue\n            current_branch = [current_vertex]\n            processed_edges.append(  set([current_vertex , next_vertex])  )\n            find_branches_core( current_vertex = next_vertex , previous_vertex = current_vertex , current_branch = current_branch)\n      return\n\n    ############################################################################################################################################\n    # Core function call. It should process the whole connected component\n    if verbose >= 10:\n      print('Start process count_connected_components', count_connected_components, 'initial_vertex', current_vertex)\n    processed_vertices.add(current_vertex)\n    core_call_count = [0]\n    find_branches_core( current_vertex = current_vertex , previous_vertex = None , current_branch = [])\n\n    ############################################################################################################################################\n    # Output of results for connected component\n    if verbose >=10:\n      print('Connected component ', count_connected_components, ' processed ')\n      print('Final found_branches',found_branches)\n      print('N Final found_branches', len( found_branches) )\n\n\ndef branch_labler( X , graph, nodes_positions, verbose = 0 ):\n  '''\n  #' Labels points of the dataset X by \"nearest\"-\"branches\" of graph.\n  #' \n  #'\n  #' @examples\n  # X = np.array( [[0.1,0.1], [0.1,0.2], [1,2],[3,4],[5,0]] )\n  # nodes_positions = np.array( [ [0,0], [1,0], [0,1], [1,1] ]  ) \n  # import igraph\n  # g = igraph.Graph(); g.add_vertices(  4  )\n  # g.add_edges([[0,1],[0,2],[0,3]])\n  # vec_labels_by_branches = branch_labler( X , g, nodes_positions )\n  '''\n  #####################################################################################\n  # Calculate branches and clustering by vertices of graph \n  dict_output = find_branches(graph, verbose = verbose )\n  if verbose >=100:\n    print('Function find_branches results branches:',  dict_output['branches'] )\n  vec_labels_by_vertices, dists, all_dists = partition_data(X, nodes_positions) # np.array([[1,2,3,4], [1,2,3,4], [1,2,3,4], [10,20,30,40]]), [[1,2,3,4], [10,20,30,40]], 10**6)#,SquaredX)\n  vec_labels_by_vertices = vec_labels_by_vertices.ravel()\n  if verbose >=100:\n    print('Function partition_data returns: vec_labels_by_vertices.shape, dists.shape, all_dists.shape', vec_labels_by_vertices.shape, dists.shape, all_dists.shape )\n  #####################################################################################\n\n  n_vertices = len( nodes_positions)\n  branches = dict_output['branches']\n\n  #####################################################################################\n  # Create dictionary vertex to list of branches it belongs to  \n  dict_vertex2branches = {}\n  for i,b in enumerate( branches):\n    for v in b:\n      if v in dict_vertex2branches.keys():\n        dict_vertex2branches[v].append(i)\n      else:\n        dict_vertex2branches[v] = [i]\n  if verbose >=100:\n    print( 'dict_vertex2branches', dict_vertex2branches )\n\n\n  #####################################################################################\n  # create list of branch and non-branch vertices\n  list_branch_vertices = []\n  list_non_branch_vertices = []\n  for v in dict_vertex2branches:\n    list_branches = dict_vertex2branches[v]\n    if len(list_branches) == 1:\n      list_non_branch_vertices.append(v)\n    else:\n      list_branch_vertices.append(v)\n  if verbose >=100:  \n    print('list_branch_vertices, list_non_branch_vertices', list_branch_vertices, list_non_branch_vertices)\n\n  #####################################################################################\n  # First stage of creation of final output - create labels by branches vector \n  # After that step it will be only correct for non-branch points \n  vec_vertex2branch = np.zeros(  n_vertices  ) \n  for i in range( n_vertices  ):\n    vec_vertex2branch[i] = dict_vertex2branches[i][0]\n  vec_labels_by_branches = vec_vertex2branch[ vec_labels_by_vertices ] \n  if verbose >= 100:\n    print('branches', branches)\n    print('vec_labels_by_branches', vec_labels_by_branches)\n\n  #####################################################################################\n  # Second stage of creation of final output - \n  # make correct calculation for branch-vertices create labels by correct branches \n  for branch_vertex in list_branch_vertices:\n    if verbose >= 100:\n      print('all_dists.shape', all_dists.shape)\n    def labels_for_one_branch_vertex( branch_vertex , vec_labels_by_vertices,  all_dists ):\n      '''\n      #' For the branch_vertex re-labels points of dataset which were labeled by it to label by \"correct branch\".\n      #' \"Correct branch\" label is a branch 'censored'-nearest to given point. \n      #' Where 'censored'-nearest means the minimal distance between the point  and all points of the branch except the given branch_vertex\n      #'\n      #' Function changes vec_labels_by_branches defined above\n      #' Uses vec_labels_by_vertices defined above - vector of same length as dataset, which contains labels by vertices \n      '''\n\n      mask = vec_labels_by_vertices.ravel() == branch_vertex # Select part of the dataset which is closest to branch_vertex\n\n      # Allocate memory for array: first coordinate - point of dataset[mask],  second coordinate - branch number , for all branches contianing given vertex (i.e. branch_vertex) \n      # For each point of dataset[mask] it contains 'censored'-distances to \"branches\" adjoint to \"branch_vertex\", \n      # 'censored' means minimal over vertices belonging to  distance to branches (excluding branch_vertex)\n      dist2branches = np.zeros( [ mask.sum(), len(dict_vertex2branches[branch_vertex] )  ] )\n      list_branch_ids = [] # that will be necessary to renumerate local number to branch_ids \n      for i,branch_id in enumerate( dict_vertex2branches[branch_vertex] ):\n        list_branch_ids.append(branch_id)\n        # Create list of vertices of current branch, with EXCLUSION of branch_vertex\n        branch_vertices_wo_given_branch_vertex = [v for v in branches[branch_id] if v != branch_vertex ]\n        # For all points of dataset[mask] calculate minimal distances to given branch (with exclusion of branch_point), i.e. mininal difference for  \n        if verbose >= 1000:\n          print('mask.shape, all_dists.shape', mask.shape, all_dists.shape)\n        dist2branches[ : ,i ] = np.min( all_dists[mask,:][:,branch_vertices_wo_given_branch_vertex], 1 ).ravel()\n\n      vec_labels_by_branches[mask] = np.array(list_branch_ids)[ np.argmin( dist2branches, 1) ]\n    labels_for_one_branch_vertex( branch_vertex, vec_labels_by_vertices,  all_dists  )\n\n    if verbose >= 10:    \n      print('Output: vec_labels_by_branches', vec_labels_by_branches)\n\n\n  return vec_labels_by_branches\n","9d8b5d1c":"\n\n# Create test graph:\ng = igraph.Graph()\ng.add_vertices(7)\ng.add_edges([(0,1), (1,2), (2,3),(3,4) , (2,5), (5,6)]) # Add list of edges \n\n# Launch find_branches\ndict_output = find_branches(g, verbose = 0)# 1000)\n\n# Print main results of find_branches\nprint('Type of main output:', type(dict_output['branches'] ) )\nprint( 'Main output:', dict_output['branches'] )\nfor i,list_nodes_in_each_branch in enumerate( dict_output['branches'] ) :\n    print('Nodes in %d-th branch:'%(i) ,list_nodes_in_each_branch  )\n    \n    \n# Plot graph\nlayout = g.layout('kk') # kk - Kamada-Kawai layout - one of the most popular layouts  # List of possible layouts is here: https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#layout\nvisual_style = {}\n#visual_style[\"vertex_color\"] = ['green' for v in g.vs]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 20\nigraph.plot(g, layout = layout, **visual_style, bbox = (300,200) )\n\n","a60325fb":"g = igraph.Graph.Lattice([3,3], circular = False ) \n\n# Launch find_branches\ndict_output = find_branches(g, verbose = 0)# 1000)\n\n# Print main results of find_branches\nprint('Type of main output:', type(dict_output['branches'] ) )\nprint( 'Main output:', dict_output['branches'] )\nfor i,list_nodes_in_each_branch in enumerate( dict_output['branches'] ) :\n    print('Nodes in %d-th branch:'%(i) ,list_nodes_in_each_branch  )\n    \n    \n# Plot graph\nlayout = g.layout('kk') # kk - Kamada-Kawai layout - one of the most popular layouts  # List of possible layouts is here: https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#layout\nvisual_style = {}\n#visual_style[\"vertex_color\"] = ['green' for v in g.vs]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 20\nigraph.plot(g, layout = layout, **visual_style, bbox = (300,200) )\n","b00b9a2c":"g = igraph.Graph.Lattice([5,1], circular = False ) \n\n# Launch find_branches\ndict_output = find_branches(g, verbose = 0)# 1000)\n\n# Print main results of find_branches\nprint('Type of main output:', type(dict_output['branches'] ) )\nprint( 'Main output:', dict_output['branches'] )\nfor i,list_nodes_in_each_branch in enumerate( dict_output['branches'] ) :\n    print('Nodes in %d-th branch:'%(i) ,list_nodes_in_each_branch  )\n    \n    \n# Plot graph\nlayout = g.layout('kk') # kk - Kamada-Kawai layout - one of the most popular layouts  # List of possible layouts is here: https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#layout\nvisual_style = {}\n#visual_style[\"vertex_color\"] = ['green' for v in g.vs]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 20\nigraph.plot(g, layout = layout, **visual_style, bbox = (300,100) )\n","9c1deb8a":"g = igraph.Graph.Lattice([5,1], circular = True ) \n\n# Launch find_branches\ndict_output = find_branches(g, verbose = 0)# 1000)\n\n# Print main results of find_branches\nprint('Type of main output:', type(dict_output['branches'] ) )\nprint( 'Main output:', dict_output['branches'] )\nfor i,list_nodes_in_each_branch in enumerate( dict_output['branches'] ) :\n    print('Nodes in %d-th branch:'%(i) ,list_nodes_in_each_branch  )\n    \n    \n# Plot graph\nlayout = g.layout('kk') # kk - Kamada-Kawai layout - one of the most popular layouts  # List of possible layouts is here: https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#layout\nvisual_style = {}\n#visual_style[\"vertex_color\"] = ['green' for v in g.vs]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 20\nigraph.plot(g, layout = layout, **visual_style, bbox = (300,200) )\n","4e0fc544":"\n\n# Create test graph:\ng = igraph.Graph()\ng.add_vertices(8)\ng.add_edges([(0,1), (1,2), (2,3),(3,4), (5,6) ]) # Add list of edges \n\n# Launch find_branches\ndict_output = find_branches(g, verbose = 0)# 1000)\n\n# Print main results of find_branches\nprint('Type of main output:', type(dict_output['branches'] ) )\nprint( 'Main output:', dict_output['branches'] )\nfor i,list_nodes_in_each_branch in enumerate( dict_output['branches'] ) :\n    print('Nodes in %d-th branch:'%(i) ,list_nodes_in_each_branch  )\n    \n    \n# Plot graph\nlayout = g.layout('kk') # kk - Kamada-Kawai layout - one of the most popular layouts  # List of possible layouts is here: https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#layout\nvisual_style = {}\n#visual_style[\"vertex_color\"] = ['green' for v in g.vs]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 20\nigraph.plot(g, layout = layout, **visual_style, bbox = (300,200) )\n\n","e5e2a75d":"\ng = igraph.Graph.Tree(12,2)# Lattice([3,3], circular = False ) \n\n# Launch find_branches\nprint('Turn on verbose output for find_branches ')\nprint()\ndict_output = find_branches(g, verbose =  1000)\nprint()\n\n# Print main results of find_branches\nprint('Type of main output:', type(dict_output['branches'] ) )\nprint( 'Main output:', dict_output['branches'] )\nfor i,list_nodes_in_each_branch in enumerate( dict_output['branches'] ) :\n    print('Nodes in %d-th branch:'%(i) ,list_nodes_in_each_branch  )\n    \n    \n# Plot graph\nlayout = g.layout('kk') # kk - Kamada-Kawai layout - one of the most popular layouts  # List of possible layouts is here: https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#layout\nvisual_style = {}\n#visual_style[\"vertex_color\"] = ['green' for v in g.vs]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 20\nigraph.plot(g, layout = layout, **visual_style, bbox = (300,200) )\n","5fefc298":"from sklearn.decomposition import PCA\ntry :\n    import umap\nexcept:\n    print('cannot import umap')\n\ndef plot_graph(edges, nodes_positions, data = None, dim_reduction = 'PCA', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = 'tab:red', data_transparency_alpha = 0.9,\n               umap_n_neighbors = 50, umap_min_dist = 0.99):\n  '''\n  #' Plots graphs defined by edges and nodes_positions, optionally - scatter plot the \"data\" on the same plot,\n  #' Optionally performs PCA\/etc (depending on dim_reduction)\n  #'\n  #' @param edges Nx2-shape matrix with edges ends, i.e. edges[k,0], edges[k,1] - ends of k-th edge  \n  #' @param nodes_positions  matrix of nodes positions \n  #' @param data  \"original dataset\", basically arbitrary dataset for scatter plot, it should have same shape[1] as nodes_positions\n  #' @param plot_data  True\/False - to scatterplot or not data\n  #' @param dim_reduction  'PCA', 'plot_first2axis', 'umap'\n  #' @param data_color can be a vector or predefined color - argument for c = data_color in scatter\n\n  #' @examples\n  # edges = np.array([ [0,1],[1,2],[2,0] ] )\n  # nodes_positions = np.random.rand(3,10) # 3 points in 10d space\n  # plot_graph(edges, nodes_positions)\n  #\n  # t = elpigraph_output\n  # edges = t[0]['Edges'][0]\n  # nodes_positions = t[0]['NodePositions']\n  # plot_graph(edges, nodes_positions)\n  '''\n  str_dim_reduction = dim_reduction\n  if dim_reduction in ['PCA', 'umap' ]: #  not 'plot_first2axis':\n    if dim_reduction.upper() == 'PCA':\n      reducer = PCA()\n    elif dim_reduction.lower() == 'umap':\n      n_neighbors = umap_n_neighbors#  50\n      min_dist= umap_min_dist # 0.99\n      #n_components=n_components\n      reducer = umap.UMAP( n_neighbors=n_neighbors,        min_dist=min_dist, n_components = 2)\n\n    if data is not None:\n      data2 = reducer.fit_transform(data)\n      if plot_data == True:\n        if data_color is None:\n          plt.scatter(data2[:,0],data2[:,1], linewidth = data_linewidth , alpha = data_transparency_alpha)# ,cmap=plt.cm.Paired) # ,c=np.array(irx) \n          plt.xlabel(str_dim_reduction+'1')\n          plt.ylabel(str_dim_reduction+'2')\n        else:\n          plt.scatter(data2[:,0],data2[:,1] ,cmap=plt.cm.Paired,c= data_color, linewidth = data_linewidth, alpha = data_transparency_alpha ) \n          plt.xlabel(str_dim_reduction+'1')\n          plt.ylabel(str_dim_reduction+'2')\n    else:\n      reducer.fit(nodes_positions)\n\n    nodes_positions2 = reducer.transform( nodes_positions )\n  else:\n    if plot_data == True:\n      if data is not None:\n        if data_color is None:\n          plt.scatter(data[:,0],data[:,1] , linewidth = linewidth, alpha = data_transparency_alpha )# ,cmap=plt.cm.Paired) # ,c=np.array(irx) \n        else:\n          plt.scatter(data[:,0],data[:,1] ,cmap=plt.cm.Paired,c= data_color , linewidth = data_linewidth, alpha = data_transparency_alpha ) \n    nodes_positions2 = nodes_positions\n\n  plt.scatter(nodes_positions2[:,0],nodes_positions2[:,1],c = graph_color, linewidth = graph_linewidth)#, cmap=plt.cm.Paired)\n\n  edgeCount = edges.shape[0]\n  for k in range(edgeCount):\n    n0 = edges[k,0]\n    n1 = edges[k,1]\n    x_line = [ nodes_positions2[n0,0],  nodes_positions2[n1,0] ]\n    y_line = [ nodes_positions2[n0,1],  nodes_positions2[n1,1] ]\n    plt.plot(x_line, y_line, graph_color, linewidth = graph_linewidth) # 'black')\n\n    \nedges = np.array([ [0,1],[1,2],[2,0] ] )\nnodes_positions = np.random.rand(3,10) # 3 points in 10d space\nplot_graph(edges, nodes_positions)    ","e710893c":"# Create random points in square [0,1]^2\nX = np.random.rand(1000,2)\n\n# Create graph \ng = igraph.Graph()\ng.add_vertices(5)\nlist_edges = [(0,1), (0,2), (0,3),(0,4) ]\ng.add_edges( list_edges ) # Add list of edges \nnodes_positions = np.array([[0.5,0.5],[0.5,0],[0.5,1],[0,0.5],[1,0.5]])\n\n# \nvec_labels_by_branches = branch_labler( X , g, nodes_positions )\nprint('vec_labels_by_branches type:', type(vec_labels_by_branches), ' ; vec_labels_by_branches shape:',  vec_labels_by_branches.shape )\n\nplot_graph(np.array(g.get_edgelist()), nodes_positions, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches, data_transparency_alpha = 0.9 )\n","b710a126":"# Create random points in square [0,1]^2\nX = np.random.rand(1000,2)\n\n# Create graph \ng = igraph.Graph()\ng.add_vertices(7)\nlist_edges = [(0,1), (1,2), (2,3),(3,4), (2,5) , (5,6) ]\ng.add_edges( list_edges ) # Add list of edges \nnodes_positions = np.array([[0,0],[0.25,0],[0.5,0], [0.75,0],[1,0], [0.5,0.5], [0.5,1]    ])\n\n# \nvec_labels_by_branches = branch_labler( X , g, nodes_positions )\nprint('vec_labels_by_branches type:', type(vec_labels_by_branches), ' ; vec_labels_by_branches shape:',  vec_labels_by_branches.shape )\n\nplot_graph(np.array(g.get_edgelist()), nodes_positions, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches, data_transparency_alpha = 0.9 )\n","962fbd2d":"# Create random points in square [0,1]^2\nX = np.random.rand(1000,2)\n\n# Create graph \ng = igraph.Graph()\ng.add_vertices(7)\nlist_edges = [(0,1), (1,2), (2,3),(3,4), (2,5) , (5,6) ]\ng.add_edges( list_edges ) # Add list of edges \nnodes_positions = np.array([[0,0],[0.25,0],[0.5,0], [0.75,0],[1,0], [0.5,0.5], [0.5,1]    ])\n\n# \nvec_labels_by_branches = branch_labler( X , g, nodes_positions )\nprint('vec_labels_by_branches type:', type(vec_labels_by_branches), ' ; vec_labels_by_branches shape:',  vec_labels_by_branches.shape )\n\nvec_labels_by_branches  = []\n# Create figure\nfig = plt.figure(figsize=(20, 6))\nn_subplots_x = 3\n\n\nfig.add_subplot(1, n_subplots_x , 1) \n\n# Create graph \ng = igraph.Graph()\ng.add_vertices(7)\nlist_edges = [(0,1), (1,2), (2,3),(3,4), (2,5) , (5,6) ]\ng.add_edges( list_edges ) # Add list of edges \nnodes_positions = np.array([[0,0],[0.25,0],[0.5,0], [0.75,0],[1,0], [0.5,0.5], [0.5,1]    ])\n\nvec_labels_by_branches1 = branch_labler( X , g, nodes_positions )\n\nplot_graph(np.array(g.get_edgelist()), nodes_positions, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches1, data_transparency_alpha = 0.9 )\nplt.title('Clustering 1')\n\n\nfig.add_subplot(1, n_subplots_x , 2) \n\n# Create graph \ng = igraph.Graph()\ng.add_vertices(7)\nlist_edges = [(0,1), (1,2), (2,3),(3,4), (2,5) , (5,6) ]\ng.add_edges( list_edges ) # Add list of edges \nnodes_positions2 = np.array([[0,0],[0.25,0.1],[0.5,0.1], [0.75,0.1],[1,0], [0.5,0.5], [0.5,1]    ])\n\nvec_labels_by_branches2 = branch_labler( X , g, nodes_positions2 )\n\nplot_graph(np.array(g.get_edgelist()), nodes_positions2, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches2, data_transparency_alpha = 0.9 )\nplt.title('Clustering 2')\n\nfig.add_subplot(1, n_subplots_x , 3) \n\ng = igraph.Graph()\ng.add_vertices(7)\nlist_edges = [(0,1), (1,2), (2,3),(3,4), (2,5) , (5,6) ]\ng.add_edges( list_edges ) # Add list of edges \nnodes_positions3 = np.array([[0,0],[0.25,0.4],[0.5,0.4], [0.75,0.4],[1,0], [0.5,0.5], [0.5,1]    ])\n\nvec_labels_by_branches3 = branch_labler( X , g, nodes_positions3 )\n\nplot_graph(np.array(g.get_edgelist()), nodes_positions3, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches3, data_transparency_alpha = 0.9 )\nplt.title('Clustering 3')\n\n\n\nplt.show()\n\nfrom sklearn import metrics\n\ndf = pd.DataFrame()\ndf.loc['between 1 and 2' , 'Adjusted Rand Index Score'] =   metrics.adjusted_rand_score(vec_labels_by_branches1,vec_labels_by_branches2 ) \ndf.loc['between 1 and 3' , 'Adjusted Rand Index Score'] =   metrics.adjusted_rand_score(vec_labels_by_branches1,vec_labels_by_branches3 ) \ndf.loc['between 2 and 3' , 'Adjusted Rand Index Score'] =   metrics.adjusted_rand_score(vec_labels_by_branches2,vec_labels_by_branches3 ) \n \n\ndf.loc['between 1 and 2' , 'Adjusted Mutual Information Score'] =   metrics.adjusted_mutual_info_score(vec_labels_by_branches1,vec_labels_by_branches2 ) \ndf.loc['between 1 and 3' , 'Adjusted Mutual Information Score'] =   metrics.adjusted_mutual_info_score(vec_labels_by_branches1,vec_labels_by_branches3 ) \ndf.loc['between 2 and 3' , 'Adjusted Mutual Information Score'] =   metrics.adjusted_mutual_info_score(vec_labels_by_branches2,vec_labels_by_branches3 ) \n\ndf.loc['between 1 and 2' , 'Fowlkes-Mallows Score'] =   metrics.fowlkes_mallows_score(vec_labels_by_branches1,vec_labels_by_branches2 ) \ndf.loc['between 1 and 3' , 'Fowlkes-Mallows Score'] =   metrics.fowlkes_mallows_score(vec_labels_by_branches1,vec_labels_by_branches3 ) \ndf.loc['between 2 and 3' , 'Fowlkes-Mallows Score'] =   metrics.fowlkes_mallows_score(vec_labels_by_branches2,vec_labels_by_branches3 ) \n\ndf.loc['between 1 and 2' , 'V-measure Score'] =   metrics.v_measure_score(vec_labels_by_branches1,vec_labels_by_branches2 ) \ndf.loc['between 1 and 3' , 'V-measure Score'] =   metrics.v_measure_score(vec_labels_by_branches1,vec_labels_by_branches3 ) \ndf.loc['between 2 and 3' , 'V-measure Score'] =   metrics.v_measure_score(vec_labels_by_branches2,vec_labels_by_branches3 ) \n\n\ndf","9473c662":"print('Adjusted Rand Index ')\nprint('between 1 and 2:', metrics.adjusted_rand_score(vec_labels_by_branches1,vec_labels_by_branches2 ) )\nprint('between 1 and 3:', metrics.adjusted_rand_score(vec_labels_by_branches1,vec_labels_by_branches3 ) )\nprint('between 2 and 3:', metrics.adjusted_rand_score(vec_labels_by_branches2,vec_labels_by_branches3 ) )\nprint('Adjusted Mutual Information ')\nprint('between 1 and 2:', metrics.adjusted_mutual_info_score(vec_labels_by_branches1,vec_labels_by_branches2 ) )\nprint('between 1 and 3:', metrics.adjusted_mutual_info_score(vec_labels_by_branches1,vec_labels_by_branches3 ) )\nprint('between 2 and 3:', metrics.adjusted_mutual_info_score(vec_labels_by_branches2,vec_labels_by_branches3 ) )\nprint('Fowlkes-Mallows Score ')\nprint('between 1 and 2:', metrics.fowlkes_mallows_score(vec_labels_by_branches1,vec_labels_by_branches2 ) )\nprint('between 1 and 3:', metrics.fowlkes_mallows_score(vec_labels_by_branches1,vec_labels_by_branches3 ) )\nprint('between 2 and 3:', metrics.fowlkes_mallows_score(vec_labels_by_branches2,vec_labels_by_branches3 ) )\n","aa63ab38":"def make_dumbbell(n_layers = 1, n_features = 2,  sigma_noise = 10.0, n_samples4base = 200,\n                  n_samples4branches = [100,100,100,100] , angles = [np.pi\/4,-np.pi\/4,3*np.pi\/4,-3*np.pi\/4] ):\n  '''\n  '''\n\n  \"\"\"\n  n_layers = 2\n  n_features = 2\n  sigma_noise = 10.0\n  plot_mode = 'PCA'\n  n_samples4base = 200\n  n_samples4branches = [100,100,100,100]\n  angles = [np.pi\/4,-np.pi\/4,3*np.pi\/4,-3*np.pi\/4]\n  \"\"\"\n\n  X_noiseless = np.zeros( (0,n_features))\n  y_final = np.zeros( 0 )\n  for layer in range(n_layers):\n    current_label = 0 \n    X = np.zeros( (n_samples4base, n_features) )\n    X[:,0] = np.arange(n_samples4base)\n    y = current_label * np.ones( n_samples4base )\n    v_last_base_point_save = X[-1,:].copy()\n    v_first_base_point_save = X[0,:].copy()\n\n    # Make branches\n    n_branches = len ( n_samples4branches )\n    for c_branch in range( n_branches ) : # n_branches\n      n_sample4branch = n_samples4branches[c_branch]\n      current_label += 1\n      y_branch = current_label * np.ones( n_sample4branch )\n      angle = angles[c_branch] \n      if c_branch < n_branches\/ 2:\n        v_initial = v_last_base_point_save\n      else:\n        v_initial = v_first_base_point_save  \n      X_branch = np.zeros( (n_sample4branch,  n_features)  ) #  [:2] = (np.cos(angle), np.sin(angle) )  \n      v_direction = np.zeros( n_features)\n      v_direction[0] = np.cos(angle)\n      v_direction[1] = np.sin(angle)\n      X_branch += v_direction # Broadcast vector to the whole array over axis 0 \n      X_branch *= np.arange( 1, X_branch.shape[0] +1 ).reshape(X_branch.shape[0], 1 ) # Broadcast - mutiply each column by  by column = 1,2,3, ... \n      X_branch += v_initial # \n      X = np.concatenate( (X,X_branch) , axis = 0 )\n      y = np.concatenate( (y, y_branch ))\n    X_noiseless = np.concatenate( (X_noiseless,X) , axis = 0 )\n    y_final = np.concatenate( (y_final,y) ) \n    \n  X_noisy = X_noiseless + sigma_noise * np.random.randn( X_noiseless.shape[0], X_noiseless.shape[1] )\n\n\n  y = y_final\n  X = X_noisy\n\n  if 0:\n    print(X.shape, y.shape)\n    r = X_noisy\n    plt.scatter(r[:,0],r[:,1], c =y)\n    plt.show()\n  \n  return X,y\n\nX,y = make_dumbbell(n_layers = 1, n_features = 2,  sigma_noise = 10.0, n_samples4base = 200,\n                  n_samples4branches = [100,100,100,100] , angles = [np.pi\/4,-np.pi\/4,3*np.pi\/4,-3*np.pi\/4] )\nif 1:\n  print(X.shape, y.shape)\n  r = X\n  plt.scatter(r[:,0],r[:,1], c =y)\n  plt.axis(\"equal\")\n  plt.grid()\n  plt.show()\n","84c51ceb":"from sklearn import metrics\nfrom sklearn.cluster import  KMeans\nfrom sklearn.neighbors import kneighbors_graph\nfrom scipy.sparse.csgraph import minimum_spanning_tree\nimport pandas as pd \n\n\nX,y = make_dumbbell(n_layers = 1, n_features = 2,  sigma_noise = 10.0, n_samples4base = 200,\n                  n_samples4branches = [100,100,100,100] , angles = [np.pi\/4,-np.pi\/4,3*np.pi\/4,-3*np.pi\/4] )\n\n#print(X.shape,'shape of output array X.', y.shape, 'shape of output y' )\n\ndf_scores_info = pd.DataFrame()\n\nfig = plt.figure(figsize=(20, 6))\nn_subplots_x = 3\nc = 0 \n\nc+=1 ; fig.add_subplot(1, n_subplots_x , c) \n\n\n# Create graph \ng = igraph.Graph()\ng.add_vertices(8)\nlist_edges = [(0,1), (1,2),(1,3), (0,4),(0,5),(0,6),(6,7),(7,1) ]\ng.add_edges( list_edges ) # Add list of edges \nnodes_positions = np.array([[0,0],[200,0], (250,50), (250,-50) , (-50,50), (-50,-50), (50,0), (150,0)])\n\nvec_labels_by_branches = branch_labler( X , g, nodes_positions )\n\nplot_graph(np.array(g.get_edgelist()), nodes_positions, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches, data_transparency_alpha = 0.9 )\nplt.grid()\n\ns = 'Graph with '+str(g.vcount()) +' nodes '\nplt.title(s)\nm = metrics.silhouette_score(X, vec_labels_by_branches, metric='euclidean')\ndf_scores_info.loc['silhouette score', s] = m\nm = metrics.davies_bouldin_score(X, vec_labels_by_branches)\ndf_scores_info.loc['Davies-Bouldin score', s] = m\nm = metrics.calinski_harabasz_score(X, vec_labels_by_branches)\ndf_scores_info.loc['Calinski-Harabasz score', s] = m\n\n\n\n\nc+=1 ; fig.add_subplot(1, n_subplots_x , c) \n\nclustering = KMeans(n_clusters=40, random_state=0).fit(X)\ncluster_centers_ = clustering.cluster_centers_\npredicted_clusters = clustering.labels_ # kmeans.predict(X)\n# sklearn.neighbors.kneighbors_graph(X, n_neighbors, mode='connectivity', metric='minkowski', p=2, metric_params=None, include_self=False, n_jobs=None)[source]\u00b6\ncsr_knn = kneighbors_graph(cluster_centers_, n_neighbors= 10, mode= 'distance', include_self=True) # mode=  'connectivity'\n\ncsr_mst = minimum_spanning_tree(csr_knn)\n\ng = igraph.Graph().Adjacency((csr_mst.todense() != 0).astype(int).tolist())\ng.to_undirected(mode = 'collapse')\n\nvec_labels_by_branches = branch_labler( X , g, cluster_centers_ )\n\n\nplot_graph(np.array(g.get_edgelist()), cluster_centers_, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches, data_transparency_alpha = 0.9 )\nplt.grid()\n\ns = 'Graph with '+str(g.vcount()) +' nodes '\nplt.title(s)\nm = metrics.silhouette_score(X, vec_labels_by_branches, metric='euclidean')\ndf_scores_info.loc['silhouette score', s] = m\nm = metrics.davies_bouldin_score(X, vec_labels_by_branches)\ndf_scores_info.loc['Davies-Bouldin score', s] = m\nm = metrics.calinski_harabasz_score(X, vec_labels_by_branches)\ndf_scores_info.loc['Calinski-Harabasz score', s] = m\n\n\nc+=1 ; fig.add_subplot(1, n_subplots_x , c) \n\nclustering = KMeans(n_clusters=60, random_state=0).fit(X)\ncluster_centers_ = clustering.cluster_centers_\npredicted_clusters = clustering.labels_ # kmeans.predict(X)\n# sklearn.neighbors.kneighbors_graph(X, n_neighbors, mode='connectivity', metric='minkowski', p=2, metric_params=None, include_self=False, n_jobs=None)[source]\u00b6\ncsr_knn = kneighbors_graph(cluster_centers_, n_neighbors= 10, mode= 'distance', include_self=True) # mode=  'connectivity'\n\ncsr_mst = minimum_spanning_tree(csr_knn)\n\ng = igraph.Graph().Adjacency((csr_mst.todense() != 0).astype(int).tolist())\ng.to_undirected(mode = 'collapse')\n\nvec_labels_by_branches = branch_labler( X , g, cluster_centers_ )\n\nplot_graph(np.array(g.get_edgelist()), cluster_centers_, data = X, dim_reduction = 'plot_first2axis', graph_color = 'black', graph_linewidth=2, \n               plot_data = True, data_linewidth = 1,  data_color = vec_labels_by_branches, data_transparency_alpha = 0.9 )\nplt.grid()\n\ns = 'Graph with '+str(g.vcount()) +' nodes '\nplt.title(s)\nm = metrics.silhouette_score(X, vec_labels_by_branches, metric='euclidean')\ndf_scores_info.loc['silhouette score', s] = m\nm = metrics.davies_bouldin_score(X, vec_labels_by_branches)\ndf_scores_info.loc['Davies-Bouldin score', s] = m\nm = metrics.calinski_harabasz_score(X, vec_labels_by_branches)\ndf_scores_info.loc['Calinski-Harabasz score', s] = m\n\nplt.show()\n\n\ndf_scores_info\n","2fbff7b3":"# Score calculation for graphs similiraty via clustering ","87afc773":"# Examples find_branches usage on different graph","913c3d0d":"## Example 2 ","bb2f4ff7":"## Example with disconnected graph ","37295991":"## Auxilliary plot function ","e30e696d":"# Example 1 ","7e8505a7":"## Example - lattice graph ","1df8cc82":"## Example tree like graph.  Verbose turned on.  ","00bfabf2":"## Line graph - just one branch","c648d706":"# Examples - clustering data by graph branches - function branch_labler","8accbe00":"## Simplest three-branch graph","9dee7c6e":"## Special example - cycle graph\n\nIt is rather a matter of convention what to call by branch for case of circle graph.\nWe will consider the whole circle as a branch, and to distinguish it from the line graph,\nwe orginaze the output such that the firth element is repeated at the end of the output. (Choice of the \"first\" element is, of course, arbitrary). "}}