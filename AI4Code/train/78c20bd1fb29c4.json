{"cell_type":{"d90c9910":"code","f218a488":"code","6901e09f":"code","6be0e62c":"code","3d34b4ec":"code","9f3e623d":"code","fafc595a":"code","74efc7cf":"code","61ff6c44":"code","8d40682b":"code","e36aa47a":"code","9b41de96":"code","a15609bf":"code","6a6403b3":"code","1337063f":"code","2541d09d":"code","1cd997af":"code","e6b5ad93":"code","65421cba":"code","92a7368d":"code","8daf865c":"code","a5fbdad1":"code","97787316":"code","9cbeb094":"code","bf777c46":"code","d77fdcba":"code","6bb0f737":"code","ab4a24bf":"markdown","2d5ce435":"markdown","f9e7b24b":"markdown","fa5ce4c2":"markdown","7c8b0906":"markdown","7f64107d":"markdown","984e3fd5":"markdown","5b10c96f":"markdown","8da060a2":"markdown","d51c6319":"markdown","a0393aef":"markdown","c4128903":"markdown","076d393f":"markdown"},"source":{"d90c9910":"#Load the liberaries\n\nimport numpy as np\nimport pandas as pd \npd.set_option('display.max_columns' ,500)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f218a488":"#Helper functions code\n\n\ndef investigate_continues_variable(df , column , bins =30 ):\n    \"\"\"\n    Function to devide the continues varibales into equal bins \n    then plot a chart showing the \n    counts of popular and un-popular songs \n    accross deffrinet continues numrical variables\n    and line chart showing the percentage of the popularity across the selected bins\n    \n    input : \n        original data frame  -pandas df\n        column name - str\n        bins number  - int\n    \n    output :\n        chart - matplotlib.pyplot\n    \n    \"\"\"\n    \n    \n    #Create new data frame using cross tap between the song popularity and the variables bins\n    df_plot = df.copy()\n    df_plot =df_plot.reset_index()\n    df_plot['bins'] = pd.cut(df_plot[column] , bins = bins ,\n                                  labels=range(0,bins))\n    df_plot1 = pd.DataFrame(pd.crosstab(df_plot['bins'],df_plot['song_popularity']),)\n    df_plot1['Popularity_Percenatge'] = df_plot1[1] \/ (df_plot1[1] + df_plot1[0]) * 100\n    \n    \n    \n    \n    #plot the distribution using matplotlib.pyplot\n    ind = np.arange(bins)\n    width = 0.3\n\n    fig, ax1 = plt.subplots(figsize = (15 ,5))\n    ax2 = ax1.twinx()\n    ax2.plot(df_plot1.index ,  df_plot1.Popularity_Percenatge  ,label='Percentage of Popularity'  ,\n                   ls =':' , lw = 2 , color = 'red' , zorder = 100)\n    \n    ax2.set_ylim(0,100)\n    ax2.set_ylabel(\"Percentage of Popularity\" , color = 'red' , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax2.tick_params(axis='y', colors='red')\n    ax2.spines['right'].set_color('red')\n    ax2.spines['top'].set_visible(False)\n    \n    #ax1 setup\n    ax1.set_title(f'Percentage of songs Popularity Accross {column}'.title() , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax1.set_xlim(1,bins-1)\n\n    ax1.bar(ind, df_plot1[1] , width, label='Counts of  Popular songs' , color  = '#23a108' ,\n                  edgecolor  = 'black' ,hatch =  '*')\n    ax1.bar(ind+width, df_plot1[0] , width , label='Counts of un-Popular Songs' , color  = '#8ea389' ,\n                  edgecolor  = 'black' )\n\n    ax1.set_xlabel(f\"Range of {column} from {round(df[column].min() , 3)} to {round(df[column].max(),3)} divided to {bins} equivilant Bins\" ,\n                  fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax1.set_ylabel(\"Counts Per each Bin\" , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax1.spines['top'].set_visible(False)\n    ax1.spines['right'].set_color('red')\n    ax1.set_xticks([])\n    \n    fig.legend( bbox_to_anchor=(0.2, 1.02, 0.6, .102), loc='lower left',\n                      ncol=3, mode=\"expand\", borderaxespad=0.)\n    plt.show()\n    \n\n\n    \ndef investigate_discrete_Variables (df , column):\n    \"\"\"\n    Function to plot a bar chart showing the \n    counts of popular and un-popular songs \n    accross deffrinet continues numrical variables\n    \n    input : \n        original data frame  -pandas df\n        column name - str\n    \n    output :\n        chart - matplotlib.pyplot\n    \n    \n    \"\"\"\n    new = df.groupby([column , 'song_popularity']).size().reset_index()\n    pop = new[new.song_popularity == 1]\n    unpop = new[new.song_popularity  == 0]\n    \n    pop[column].apply(str)\n    unpop[column].apply(str)\n    \n    \n    ind = np.arange(len(pop[column]))\n    width = 0.3\n\n\n    fig, ax1 = plt.subplots(figsize = (15 ,5))\n    \n    #ax1 setup\n    ax1.set_title(f'Counts of Popular and non-Popular songs Accross {column}'.title() , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n\n    ax1.bar(ind, pop[0] , width, label='Counts of  Popular songs' , color  = '#23a108' ,\n                  edgecolor  = 'black' ,hatch =  '*')\n   \n    ax1.bar(ind+width, unpop[0] , width , label='Counts of un-Popular Songs' , color  = '#8ea389' ,\n                  edgecolor  = 'black' )\n\n    \n\n    ax1.set_ylabel(\"Counts \" , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax1.spines['top'].set_visible(False)\n    ax1.spines['right'].set_visible(False)\n    \n    ax1.set_xticks(pop[column])\n    \n    fig.legend( bbox_to_anchor=(0.2, 1.02, 0.6, .102), loc='lower left',\n                      ncol=3, mode=\"expand\", borderaxespad=0.)\n    ax1.grid(axis = 'y' , zorder =-1 , linestyle =\":\")\n    plt.show()\n","6901e09f":"train = pd.read_csv('\/kaggle\/input\/song-popularity-prediction\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/song-popularity-prediction\/test.csv')\ntest['song_popularity'] = np.nan\ndf = pd.concat([train, test])\n\ndisplay(df)","6be0e62c":"\"\"\"\n\n!pip install sweetviz\nimport sweetviz\nreport = sweetviz.analyze([train,'df'],target_feat='song_popularity')\nreport.show_html('report.html')\n\n\"\"\"\nprint('Pass')","3d34b4ec":"\n#Reload the Data frame\ndf = pd.concat([train, test])\n\n#df.id\ndf.drop(['id' , 'instrumentalness' ] ,axis  = 1 , inplace = True)\n\n\n#df.song_duration_ms\ndf.song_duration_ms.fillna(df.song_duration_ms.mean() , inplace = True)\ndf.song_duration_ms = df.song_duration_ms.apply(lambda x: df.tempo.mean() if x >400000 else x)\n\n#df.acousticness\nfrom sklearn.preprocessing import PowerTransformer\nPower_Transfrom_acous = PowerTransformer(method='yeo-johnson')\ndf.acousticness = Power_Transfrom_acous.fit_transform(df.acousticness.values.reshape(-1, 1))\ndf.acousticness.fillna(df.acousticness.mode()[0] , inplace = True)\n\n\n#df.danceability\ndf.danceability.fillna(df.danceability.mean() , inplace = True)\n\n\n#df.energy\ndf.energy.fillna(df.energy.mean() , inplace = True)\n\n\n#df.liveness\ndf.liveness = df.liveness.apply(lambda x: df.liveness.mean() if x>0.75 else x)\nPower_Transfrom_liv = PowerTransformer(method='yeo-johnson')\ndf.liveness = Power_Transfrom_liv.fit_transform(df.liveness.values.reshape(-1, 1))\ndf.liveness.fillna(df.liveness.mode()[0] , inplace = True)\n\n#df.loudness\nPower_Transfrom_loud = PowerTransformer(method='yeo-johnson')\ndf.loudness= Power_Transfrom_loud.fit_transform(df.loudness.values.reshape(-1, 1))\ndf.loudness.fillna(df.loudness.mean() , inplace = True)\n\n\n\n#df.speechiness\ndf.speechiness = df.speechiness.apply(lambda x: df.speechiness.mean() if x>0.45 else x)\nPower_Transfrom_speac= PowerTransformer(method='yeo-johnson')\ndf.speechiness = Power_Transfrom_speac.fit_transform(df.speechiness.values.reshape(-1, 1))\ndf.speechiness.fillna(df.speechiness.mode()[0] , inplace = True)\n\n\n#df.tempo\ndf.tempo = df.tempo.apply(lambda x: df.tempo.mean() if x >190 else x)\ndf.tempo.fillna(df.tempo.mean() , inplace = True)\n\n#df.audio_valence\ndf.audio_valence.fillna(df.audio_valence.mean() , inplace = True)\n\n#df.key\ndf.key.fillna(12 , inplace = True)\n\n\n","9f3e623d":"fig , ax = plt.subplots(3,4 , figsize = (10,10))\nfor column  , axes in zip(df.columns , ax.flatten()):\n    axes.boxplot(df[column] , patch_artist=True , boxprops=dict(facecolor='#23a108', edgecolor  = 'black' ,hatch =  '*'))\n    axes.set_title(column)\n\nplt.tight_layout()\nplt.show()","fafc595a":"\"\"\"\n\n\n!pip install sweetviz\nimport sweetviz\ntrain = df[df.song_popularity.notnull()]\nreport = sweetviz.analyze([train,'df'],target_feat='song_popularity')\nreport.show_html('report.html')\n\n\"\"\"\nprint ('pass')","74efc7cf":"Continues_numerical = ['song_duration_ms','acousticness','danceability', 'energy',\n                       'liveness', 'loudness', 'speechiness', 'tempo', 'audio_valence']\n\n\n\nfor column in Continues_numerical:\n    investigate_continues_variable(df , column  , bins = 25)\n","61ff6c44":"popular = []\nunpopular = []\nfor column in Continues_numerical:\n    popular.append(df[df.song_popularity == 1][column].mean())\n    unpopular.append(df[df.song_popularity == 0][column].mean())\n\nind = 1\nwidth = 0.3  \nfig , ax = plt.subplots(3,3 , figsize  = (15 ,15))\nfor column , pop , unpop , axes in zip (Continues_numerical , popular , unpopular , ax.flatten()):\n    \n    axes.bar(ind, pop , width, label='Average of  Popular songs' , color  = '#23a108' ,\n                  edgecolor  = 'black' ,hatch =  '*' )\n    axes.bar(ind+width+0.1, unpop , width , label='Average un-Popular Songs' , color  = '#8ea389' ,\n                  edgecolor  = 'black' )\n    axes.set_title(column ,fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold' )\n    axes.spines['top'].set_visible(False)\n    axes.spines['right'].set_visible(False)\n    axes.set_xticks([])\n\n    \nfont = {'family':'serif','weight':'bold','style':'normal', 'size':12}\n\nfig.suptitle('Compasion between the average of Continues Variables accross the popularity'.title(), \n             fontsize = 16 , fontfamily = 'serif' , fontweight = 'bold')\nax[0,0].legend(bbox_to_anchor=(0.2, 1.2, 3, .102), loc='lower left',\n                      ncol=2, mode=\"expand\", borderaxespad=0. , prop = font)\nplt.show();","8d40682b":"descrite_numerical = [ 'key','audio_mode','time_signature']\nfor column in descrite_numerical:\n    investigate_discrete_Variables (df , column)","e36aa47a":"corr_df = df.drop('song_popularity', axis=1).corrwith(df.song_popularity).sort_values().reset_index().rename(columns = {'index':'feature' ,0:'correlation'})\n\nfig , ax = plt.subplots(figsize  = (5,8))\nax.barh(y =corr_df.feature , width = corr_df.correlation ,\n        color  = '#23a108' ,edgecolor  = 'black' ,hatch =  '*' )\nax.set_title('correlation between featuer and target'.title() ,\n            fontsize = 16 , fontfamily = 'serif' , fontweight = 'bold')\nplt.show();","9b41de96":"df.drop(['tempo' , 'audio_mode' ,'song_duration_ms',  'key' ] , axis = 1 , inplace = True)","a15609bf":"np.random.seed(42)\n\n\ntrain = df[df.song_popularity.notnull()]\n\nfrom sklearn.preprocessing import StandardScaler\nSC = StandardScaler()\n\ntrain_scale = SC.fit_transform(train)\n\n\nfrom sklearn.decomposition import PCA\npca = PCA(n_components=3)\nprincebal_componants_array = pca.fit_transform(train_scale)\n\nfrom sklearn.cluster import KMeans\nmodel42 = KMeans(n_clusters=10 , random_state=42)\nmodel42.fit(princebal_componants_array)\n\nlabels = model42.labels_\n\ntrain ['labels'] = labels\n\n    \n    \ncorr_df = train.drop('song_popularity', axis=1).corrwith(train.song_popularity).sort_values().reset_index().rename(columns = {'index':'feature' ,0:'correlation'})\nfig , ax = plt.subplots(figsize  = (5,8))\nax.barh(y =corr_df.feature , width = corr_df.correlation ,\n        color  = '#23a108' ,edgecolor  = 'black' ,hatch =  '*' )\nax.set_title('correlation between featuer and target after adding the labels'.title() ,\n            fontsize = 16 , fontfamily = 'serif' , fontweight = 'bold')\nplt.show();","6a6403b3":"def investigate_continues_variable_7_2 (df ,label ,  column , bins =30 , ax1=None ):\n    \"\"\"\n    Function to devide the continues varibales into equal bins \n    then plot a chart showing the \n    counts of popular and un-popular songs \n    accross deffrinet continues numrical variables\n    and line chart showing the percentage of the popularity across the selected bins\n    \n    input : \n        original data frame  -pandas df\n        column name - str\n        bins number  - int\n    \n    output :\n        chart - matplotlib.pyplot\n    \n    \"\"\"\n    \n    \n    #Create new data frame using cross tap between the song popularity and the variables bins\n    df_plot = df.copy()\n    df_plot =df_plot.reset_index()\n    df_plot = df_plot[df_plot.labels == label]\n    df_plot['bins'] = pd.cut(df_plot[column] , bins = bins ,\n                                  labels=range(0,bins))\n    df_plot1 = pd.DataFrame(pd.crosstab(df_plot['bins'],df_plot['song_popularity']),)\n    df_plot1['Popularity_Percenatge'] = df_plot1[1] \/ (df_plot1[1] + df_plot1[0]) * 100\n    \n    \n    \n    \n    #plot the distribution using matplotlib.pyplot\n    ind = np.arange(bins)\n    width = 0.3\n\n    \n    ax2 = ax1.twinx()\n    ax2.plot(df_plot1.index ,  df_plot1.Popularity_Percenatge  ,label='Percentage of Popularity'  ,\n                   ls =':' , lw = 2 , color = 'red' , zorder = 100)\n    \n    ax2.set_ylim(0,100)\n    ax2.set_ylabel(\"Percentage of Popularity\" , color = 'red' , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax2.tick_params(axis='y', colors='red')\n    ax2.spines['right'].set_color('red')\n    ax2.spines['top'].set_visible(False)\n    \n    #ax1 setup\n    ax1.set_title(f'Percentage of songs Popularity Accross {column} Label number {label}'.title() , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax1.set_xlim(1,bins-1)\n\n    ax1.bar(ind, df_plot1[1] , width, label='Counts of  Popular songs' , color  = '#23a108' ,\n                  edgecolor  = 'black' ,hatch =  '*')\n    ax1.bar(ind+width, df_plot1[0] , width , label='Counts of un-Popular Songs' , color  = '#8ea389' ,\n                  edgecolor  = 'black' )\n\n    ax1.set_xlabel(f\"Range of {column} from {round(df[column].min() , 3)} to {round(df[column].max(),3)} divided to {bins} equivilant Bins\" ,\n                  fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax1.set_ylabel(\"Counts Per each Bin\" , fontsize = 12 , fontfamily = 'serif' , fontweight = 'bold')\n    ax1.spines['top'].set_visible(False)\n    ax1.spines['right'].set_color('red')\n    ax1.set_xticks([])\n    \n    \n    ","1337063f":"train ['labels'] = labels\nfor label in train.labels.unique().tolist():\n    print (label, \" :  mean of popularity \" , round(train[train.labels ==label].song_popularity.mean() , 2) , \" & Count per label \" , train[train.labels ==label].song_popularity.count())\n    print ('_________________________')","2541d09d":"train.labels = train.labels.apply(lambda x: 100 if x in [2, 9 , 5 , 4 ] else x)\ntrain.labels = train.labels.apply(lambda x: 200 if x in [0 , 3 , 8 ] else x)\ntrain.labels = train.labels.apply(lambda x: 300 if x in [1 , 7 , 6 ] else x)","1cd997af":"for label in train.labels.unique().tolist():\n    print (\"label number\" ,label, \" :  mean of song popularity \" , round(train[train.labels ==label].song_popularity.mean() , 2) , \" & Count per label \" , train[train.labels ==label].song_popularity.count())\n    print ('_________________________')","e6b5ad93":"fig , ax = plt.subplots(2,2 , figsize = (15,10))\n\n\n\ninvestigate_continues_variable_7_2 (train ,100 ,  column = 'energy' , bins =15 , ax1=ax[0,0] )\ninvestigate_continues_variable_7_2 (train ,300 ,  column = 'energy' , bins =15 , ax1=ax[0,1] )\ninvestigate_continues_variable_7_2 (train ,100,  column = 'speechiness' , bins =15 , ax1=ax[1,0] )\ninvestigate_continues_variable_7_2 (train ,300 ,  column = 'speechiness' , bins =15 , ax1=ax[1,1] )\nplt.tight_layout()","65421cba":"train.head()","92a7368d":"from sklearn.preprocessing import StandardScaler\nSC = StandardScaler()\n\ntrain['energy_double'] = train.energy * 10\ntrain['speechiness_double'] = train.speechiness *10\n\ntrain_after_clsuster = train.drop(['song_popularity' , 'labels'] , axis = 1).values\ntrain_after_clsuster = SC.fit_transform(train_after_clsuster)\n\n\n\ntarget = train.labels.values\n\n\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(train_after_clsuster, target, test_size=0.25, random_state=42)\n\n\n\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import accuracy_score\n\nneural_network = MLPClassifier()\nneighbors = KNeighborsClassifier()\nsvm = SVC()\nkernels = RBF()\ntree = DecisionTreeClassifier()\nRandomForestClassifier = RandomForestClassifier()\nAdaBoostClassifier = AdaBoostClassifier()\nnaive_bayes = GaussianNB()\ndiscriminant_analysis = QuadraticDiscriminantAnalysis()\n\nclfs = [neural_network ,neighbors ,  svm   ]\nnames = ['neural_network' ,'neighbors' ,  'svm'  ]\n\n\nfor clf , name in zip (clfs , names):\n    clf.fit(X_train, y_train)\n    predict_train = clf.predict(X_train)\n    predict_test = clf.predict(X_test)\n    \n    print (name)\n    print ('train ROC : ' , accuracy_score(y_train , predict_train))\n    print ('test ROC : ' , accuracy_score(y_test , predict_test))\n    print ('_________________________')","8daf865c":"clfs = [tree ,  \n        RandomForestClassifier , AdaBoostClassifier , naive_bayes ,discriminant_analysis  ]\nnames = ['tree' ,  \n        'RandomForestClassifier' , 'AdaBoostClassifier' , 'naive_bayes' ,'discriminant_analysis'  ]\n\n\nfor clf , name in zip (clfs , names):\n    clf.fit(X_train, y_train)\n    predict_train = clf.predict(X_train)\n    predict_test = clf.predict(X_test)\n    \n    print (name)\n    print ('train ROC : ' , accuracy_score(y_train , predict_train))\n    print ('test ROC : ' , accuracy_score(y_test , predict_test))\n    print ('_________________________')","a5fbdad1":"test = df[df.song_popularity.isnull()].drop('song_popularity' , axis = 1)\ntest['energy_double'] = test.energy * 10\ntest['speechiness_double'] = test.speechiness *10\ntest_scaled = SC.transform(test.values)\ntest_labels = neural_network.predict(test_scaled)\n\ntest['labels'] = test_labels\ntest.head()","97787316":"train.head()","9cbeb094":"X = train.drop('song_popularity' , axis = 1).values\ny = train.song_popularity.values\nX = SC.fit_transform(X)\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)\n\n\n\nimport os\nimport pandas as pd\nfrom pandas import DataFrame,Series\nfrom sklearn import tree\nimport matplotlib\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import svm\nfrom sklearn.preprocessing import StandardScaler\nimport statsmodels.formula.api as smf\nimport statsmodels.api as sm\nfrom mpl_toolkits.mplot3d import Axes3D\nimport seaborn as sns\nfrom sklearn import neighbors\nfrom sklearn import linear_model\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.ensemble import RandomForestRegressor\n%matplotlib inline\n\n\nmodel=linear_model.Ridge()\nknn=neighbors.KNeighborsRegressor()\nreg = linear_model.BayesianRidge()\ndec = tree.DecisionTreeRegressor(max_depth=1)\nsvm_reg=svm.SVR()\nreg_random_forest = RandomForestRegressor()\n\n\n\nregs = [model ,knn , reg ,dec  ]\nnames = ['model' ,'knn' , 'reg' ,'dec'  ]\n\nfor reg , name in zip (regs , names):\n    reg.fit(X_train, y_train)\n    predict_train = reg.predict(X_train)\n    predict_test = reg.predict(X_test)\n    \n    print (name)\n    print ('train ROC : ' , roc_auc_score(y_train , predict_train))\n    print ('test ROC : ' , roc_auc_score(y_test , predict_test))\n    print ('_________________________')","bf777c46":"from sklearn.neural_network import MLPClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom sklearn.metrics import roc_auc_score\n\nneural_network = MLPClassifier()\nneighbors = KNeighborsClassifier()\nsvm = SVC()\nkernels = RBF()\ntree = DecisionTreeClassifier()\nRandomForestClassifier = RandomForestClassifier()\nAdaBoostClassifier = AdaBoostClassifier()\nnaive_bayes = GaussianNB()\ndiscriminant_analysis = QuadraticDiscriminantAnalysis()\n\nclfs = [neural_network ,neighbors ,  svm   ]\nnames = ['neural_network' ,'neighbors' ,  'svm'  ]\n\n\nfor clf , name in zip (clfs , names):\n    clf.fit(X_train, y_train)\n    predict_train = clf.predict(X_train)\n    predict_test = clf.predict(X_test)\n    \n    print (name)\n    print ('train ROC : ' , roc_auc_score(y_train , predict_train))\n    print ('test ROC : ' , roc_auc_score(y_test , predict_test))\n    print ('_________________________')","d77fdcba":"clfs = [tree ,  \n        RandomForestClassifier , AdaBoostClassifier , naive_bayes ,discriminant_analysis  ]\nnames = ['tree' ,  \n        'RandomForestClassifier' , 'AdaBoostClassifier' , 'naive_bayes' ,'discriminant_analysis'  ]\n\n\nfor clf , name in zip (clfs , names):\n    clf.fit(X_train, y_train)\n    predict_train = clf.predict(X_train)\n    predict_test = clf.predict(X_test)\n    \n    print (name)\n    print ('train ROC : ' , roc_auc_score(y_train , predict_train))\n    print ('test ROC : ' , roc_auc_score(y_test , predict_test))\n    print ('_________________________')","6bb0f737":"test = SC.transform(test)\nsubmision_prediction = knn.predict(test)\nsubmission = pd.read_csv('\/kaggle\/input\/song-popularity-prediction\/sample_submission.csv')\nsubmission['song_popularity'] =submision_prediction\nsubmission.to_csv('knn.scv' , index = False)","ab4a24bf":"# Submission","2d5ce435":"# Predict the new labels in the test dataset","f9e7b24b":"# Adding labels to the test dataset","fa5ce4c2":"# Data Cleaning Pipe Line ","7c8b0906":"# Song Popularity Prediction Notebook","7f64107d":"# Regressor","984e3fd5":"# Visualize the continues numirical variables","5b10c96f":"# Predict the song popularity according to the new features","8da060a2":"# Check the coorrelation with the song popularity","d51c6319":"# Classifier Comparasion","a0393aef":"# Inverstigate the Descrete columns","c4128903":"# Checking the outliers after data cleaning","076d393f":"# Try PCA and clustring of the train data"}}