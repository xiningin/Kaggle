{"cell_type":{"17585e41":"code","c10cced0":"code","fd939ce7":"code","9b21c66c":"code","912db405":"code","5eda2f11":"code","ddcccbf3":"code","bb68fcdd":"code","42945017":"code","c648c40e":"code","1928c306":"code","04213558":"code","5ca5839e":"code","713b1287":"markdown","b0b1df25":"markdown","a97a9bd8":"markdown","af0de376":"markdown","619558d9":"markdown","8d337282":"markdown","012727a4":"markdown","e6c6d020":"markdown"},"source":{"17585e41":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.\nimport random\nimport math\nimport plotly.express as px","c10cced0":"# PARAMETRES : \n\n# Nombre d'agents \npopulation = 500\n\n# Proportion de la population infectee a l'etat initial\nprop_infected_depart = 0.15\n\n# Probabilite qu'un 'clean' se fasse infecter lorsqu'il est sur la meme cellule qu'un 'sick'\ninfectiousness = 0.98\n\n# Taille de la grille (carree)\ngrid_size = 40\n\n# Probabilite de mourir au prochain mois lorsqu'on a le virus \nproba_die = 0.05\n\n# Probabilite de guerir au prochain mois lorsqu'on a le virus\nproba_heal = 0.05\n\n# Probabilite de rester malade au prochain mois \nproba_remain = 1-proba_die-proba_heal\n\n# Parametres de la loi normale qui sert a generer les ages a la situation initiale \nmu_lifetime_years = 80\nsigma_lifetime_years = 10\n\n# Proportion de nouveaux nes tous les mois par rapport a la population qui a plus de 18 ans \n #(explications dans le rapport)\nbirths_per_month_part = 0.02\n\n# Nombre de mois generes par le model (10 ans)\nduration_model_months = 10*12\n","fd939ce7":"agent_id = range(1,population+1)\npos_x = np.random.randint(1, grid_size+1, size = population)\npos_y = np.random.randint(1, grid_size+1, size = population)\nstatus = np.concatenate((np.repeat(\"sick\", prop_infected_depart*population), np.repeat(\"clean\", np.ceil(population-(prop_infected_depart*population)))), axis=None)\nage_months = np.random.randint(0,((12*80)+1), size = population)\nlifetime_months = np.floor(np.random.normal(mu_lifetime_years*12, sigma_lifetime_years*12, population))\ntime = np.repeat(0, population)\n\ndata = {'agent_id': agent_id, 'pos_x': pos_x, 'pos_y': pos_y, 'status': status, \n        'age_months': age_months, 'lifetime_months': lifetime_months, 'time': time} \ndf_0 = pd.DataFrame(data)\n\n# Au cas o\u00f9 il y ait des ages superieurs a l'age limite \ndf_0.age_months.where(age_months < lifetime_months, 0, inplace = True)","9b21c66c":"df_0.dtypes","912db405":"df_0 = df_0.astype({\"time\": 'int32', \"lifetime_months\": 'int32', \n                   \"agent_id\": 'int16', \"pos_x\": 'int16', \n                   \"pos_y\": 'int16', \"age_months\": 'int32', \"agent_id\": 'int16'})\ndf_0.dtypes","5eda2f11":"df = df_0\ndf","ddcccbf3":"liste = []\nliste.append(df_0)\nliste[0]","bb68fcdd":"for i in range(1, duration_model_months+1) : \n    \n    liste.append(liste[i-1].copy())\n    \n    # Ajout d'un mois pour le monde (time) : \n    liste[i].time += 1\n    \n    # Ajout d'un mois d'age pour chaque agent : \n    liste[i].age_months += 1\n    \n    # Naissances : \n    births_per_month = int(np.ceil(len(liste[i-1].loc[liste[i-1].age_months > 18*12])*births_per_month_part))\n    agent_id = range(max(liste[i-1].agent_id)+1, max(liste[i-1].agent_id)+1+births_per_month)\n    pos_x = np.random.randint(1, grid_size+1, size = births_per_month)\n    pos_y = np.random.randint(1, grid_size+1, size = births_per_month)\n    status = np.repeat(\"clean\", births_per_month) \n    age_months = np.repeat(0, births_per_month)\n    lifetime_months = np.floor(np.random.normal(mu_lifetime_years*12, sigma_lifetime_years*12, births_per_month)) \n    time = np.repeat(max(liste[i-1].time)+1, births_per_month)\n    data = {'agent_id': agent_id, 'pos_x': pos_x, 'pos_y': pos_y, 'status': status, \n            'age_months': age_months, 'lifetime_months': lifetime_months, 'time': time} \n    df1 = pd.DataFrame(data)\n    df1 = df1.astype({\"time\": 'int32', \"lifetime_months\": 'int32', \n                      \"agent_id\": 'int16', \"pos_x\": 'int16', \n                      \"pos_y\": 'int16', \"age_months\": 'int32'})\n    liste[i] = pd.concat([liste[i], df1], ignore_index=True)\n    \n    # Sortir les morts de la grille : \n    liste[i].loc[(liste[i].status == \"dead_other\") | (liste[i].status == \"dead_virus\"), 'pos_x'] = grid_size+1\n    liste[i].loc[(liste[i].status == \"dead_other\") | (liste[i].status == \"dead_virus\"), 'pos_y'] = grid_size+1\n    \n    # Si un agent depasse son 'lifetime_months', alors il meurt de vieillesse : \n    liste[i].loc[liste[i].age_months >= liste[i].lifetime_months, 'status'] = \"dead_other\"\n    \n    # Markov Chain : probabilit\u00e9s de changer d'\u00e9tat lorsqu'on est malade : \n    for agent in range(0, len(liste[i])) : \n        if liste[i].loc[agent, 'status'] == \"sick\" : \n            liste[i].loc[agent, 'status'] = random.choices(['sick', 'dead_virus', 'immunized'], weights=[proba_remain, proba_die, proba_heal], k=1)\n#    liste[i].loc[liste[i].status == \"sick\", 'status'] = random.choices(['sick', 'dead_virus', 'immunized'], weights=[proba_remain, proba_die, proba_heal], k=1)\n    \n    # Random walk sauf pour les morts : haut, bas, gauche, droite, haut-droite, haut-gauche, bas-droite, bas-gauche : \n    #CHECKPOINT \n    for j in range(0, len(liste[i])) :\n        if liste[i].loc[j, 'status'] not in [\"dead_other\", \"dead_virus\"] : \n            liste[i].loc[j, 'pos_x'] += np.random.randint(-1, 2)\n            liste[i].loc[j, 'pos_y'] += np.random.randint(-1, 2)\n        \n    \n    # Si un agent sort du carr\u00e9, il revient par l'autre cot\u00e9 : \n    \n    liste[i].loc[(liste[i].status != \"dead_other\") & (liste[i].status != \"dead_virus\") & (liste[i].pos_x == grid_size+1), 'pos_x'] = 1\n    liste[i].loc[(liste[i].status != \"dead_other\") & (liste[i].status != \"dead_virus\") & (liste[i].pos_x == 0), 'pos_x'] = grid_size\n    liste[i].loc[(liste[i].status != \"dead_other\") & (liste[i].status != \"dead_virus\") & (liste[i].pos_y == grid_size+1), 'pos_y'] = 1\n    liste[i].loc[(liste[i].status != \"dead_other\") & (liste[i].status != \"dead_virus\") & (liste[i].pos_y == 0), 'pos_y'] = grid_size\n    \n    \n    \n    \n  # Si deux agents sont sur les memes coordonn\u00e9es, alors le non-malade a une proba 'infectiousness' d'etre contamin\u00e9 : \n    a = liste[i].loc[(liste[i].duplicated(['pos_x', 'pos_y'], keep=False))].reset_index()\n    for row in range(0, (len(a)-1)) :\n        for row1 in range(row+1, len(a)) : \n            if (a.loc[row, 'pos_x'] == a.loc[row1, 'pos_x']) and (a.loc[row, 'pos_y'] == a.loc[row1, 'pos_y']) : \n                if (a.loc[row, 'status'] == \"clean\") and (a.loc[row1, 'status'] == \"sick\") :\n                    liste[i].loc[liste[i].agent_id == a.loc[row, 'agent_id'], 'status'] = random.choices(['sick', 'clean'], weights = [infectiousness, 1-infectiousness], k=1)\n                if (a.loc[row1, 'status'] == \"clean\") and (a.loc[row, 'status'] == \"sick\") : \n                    liste[i].loc[liste[i].agent_id == a.loc[row1, 'agent_id'], 'status'] = random.choices(['sick', 'clean'], weights = [infectiousness, 1-infectiousness], k=1)\n            elif (a.loc[row, 'pos_x'] in [a.loc[row1, 'pos_x']-1, a.loc[row1, 'pos_x']+1]) and (a.loc[row, 'pos_y'] in [a.loc[row1, 'pos_y']-1, a.loc[row1, 'pos_y']+1]) : \n                if (a.loc[row, 'status'] == \"clean\") and (a.loc[row1, 'status'] == \"sick\") :\n                    liste[i].loc[liste[i].agent_id == a.loc[row, 'agent_id'], 'status'] = random.choices(['sick', 'clean'], weights = [infectiousness\/2, 1-infectiousness], k=1)\n                if (a.loc[row1, 'status'] == \"clean\") and (a.loc[row, 'status'] == \"sick\") : \n                    liste[i].loc[liste[i].agent_id == a.loc[row1, 'agent_id'], 'status'] = random.choices(['sick', 'clean'], weights = [infectiousness\/2, 1-infectiousness], k=1)\n\n","42945017":"df = pd.concat(liste, ignore_index=True)","c648c40e":"#status = np.repeat(df['status'].unique(), len(np.repeat(range(0, duration_model_months+1), len(df['status'].unique())))\/len(df['status'].unique()))\nstatus = np.tile(df['status'].unique(), int(len(np.repeat(range(0, duration_model_months+1), len(df['status'].unique())))\/len(df['status'].unique())))\nagent_id = np.repeat(len(df.index) + 1, len(status))\npos_x = np.repeat(grid_size+1, len(status))\npos_y = np.repeat(grid_size+1, len(status))\nage_months = np.repeat(0, len(status))\nlifetime_months = np.repeat(1, len(status))\ntime = np.repeat(range(0, duration_model_months+1), len(df['status'].unique()))\n\n\ndata = {'agent_id': agent_id, 'pos_x': pos_x, 'pos_y': pos_y, 'status': status, \n        'age_months': age_months, 'lifetime_months': lifetime_months, 'time': time} \ndf1 = pd.DataFrame(data)\n\n\ndf = pd.concat([df, df1], ignore_index=True)","1928c306":"px.scatter(df, x=\"pos_x\", y=\"pos_y\", animation_frame=\"time\", animation_group=\"agent_id\",\n           color=\"status\", hover_name=\"agent_id\",\n           log_x=False, range_x=[1,grid_size], range_y=[1,grid_size], \n          color_discrete_map = {\"sick\": \"red\", \"clean\": \"deepskyblue\", \"immunized\":\"lawngreen\", \"dead_virus\":\"fuchsia\", \"dead_other\":\"black\"})","04213558":"evol = df.groupby([\"time\", \"status\"]).size().reset_index(name=\"count\")\n\n# Suppression des agents fictifs :\nevol['count'] = evol['count']-1","5ca5839e":"px.line(evol, x=\"time\", y=\"count\", color='status', \n        color_discrete_map = {\"sick\": \"red\", \"clean\": \"deepskyblue\", \"immunized\":\"lawngreen\", \"dead_virus\":\"fuchsia\", \"dead_other\":\"black\"})","713b1287":"# Constrution de la population \u00e0 l'\u00e9tat initial : ","b0b1df25":"# Concatener les donnees en un seul dataframe","a97a9bd8":"# Graphique dynamique pour voir l'evolution de la population au cours du temps ","af0de376":"### Creer des agents fictifs pour que plotly fonctionne correctement, mais ils n'apparaissent pas sur le plan (car ils sont a l'exterieur du plan). C'est seulement pour que le graphique fonctionne, cela n'altere en rien le modele. ","619558d9":"# Generer les donnees de tous les mois","8d337282":"# Importation des packages n\u00e9cessaires","012727a4":"## Evolution du nombre d'agents dans chaque \u00e9tat","e6c6d020":"# Initialisation des param\u00e8tres du mod\u00e8le"}}