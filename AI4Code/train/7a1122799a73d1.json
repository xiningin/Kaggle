{"cell_type":{"3fb05a97":"code","14431fbd":"code","da7395a9":"code","5098b636":"code","d7aa6f53":"code","33993c0a":"code","604a2351":"code","b274af3a":"code","e39901c7":"code","da8e0634":"code","45044ae7":"code","97eaae1b":"code","dfb0a7a8":"code","22731844":"code","62a2c777":"code","6ca62d05":"code","01fb5974":"code","fcd98499":"code","f281ceda":"code","79511767":"code","71a0c613":"code","98ee79af":"code","47ab4247":"code","caa508cd":"code","1f0ff358":"code","96ffd939":"code","135faafd":"markdown","abc02262":"markdown","f9a264f6":"markdown"},"source":{"3fb05a97":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","14431fbd":"from IPython.display import Image\nImage(filename='..\/input\/mc-regular-ising-supplementary\/Pseudocode.PNG')","da7395a9":"# 1. Generating initial configurations, with the amount element and box length\n\ndef initgrid(box,ratio):\n    matrix = np.random.randint(2, size=(box, box))      \n    sum = np.sum(matrix)\n    if sum == box**2*ratio:\n        return matrix\n    else:\n        return initgrid(box,ratio)","5098b636":"from PIL import Image\n\ndef display_regular_field(field):\n    return Image.fromarray(np.uint8(field * 255)) #","d7aa6f53":"# swap: 1st debug on detecting element **location to swap**, initial **value, local energy, microstate**\ndef debug_1():\n    print('Element 1:', (rdm1,rdm2),'Element 2:',(rdm3,rdm4))\n    print('Initial Value 1:', matrix_1[rdm1,rdm2],'Initial Value 2:',matrix_1[rdm3,rdm4])\n    print('Initial 1:', local_energy(matrix_1,rdm1,rdm2),'Element 2:',local_energy(matrix_1,rdm3,rdm4))\n    print(matrix_1)\n    print('-------------------------')\n    \n# swap: 2nd debug on detecting element final **microstate, value, local energy**\ndef debug_2():\n    print(matrix_1)\n    print('Final Value 1:', matrix_1[rdm1,rdm2],'Final Value 2:',matrix_1[rdm3,rdm4])            \n    print('Final 1:', local_energy(matrix_1,rdm1,rdm2),'Final 2:',local_energy(matrix_1,rdm3,rdm4))\n","33993c0a":"box,ratio = 24,0.5\ndef next_(i):\n    if i < box-1:\n        return i+1\n    else:\n        return 0\n\ndef prec(i):\n    if i >= 1:\n        return i-1\n    else:\n        return box-1","604a2351":"from ipywidgets import interact\n\ndef display_regular_sequence(images):\n    def _show(frame=(0, len(images) - 1)):\n        return display_regular_field(images[frame])\n    return interact(_show)\n\ndef display_ising_sequence(images):\n    def _show(frame=(0, len(images) - 1)):\n        return display_spin_field(images[frame])\n    return interact(_show)","b274af3a":"import random\ndef swap_(matrix_1,beta=0.5):\n    #Creating 2 random row and column for swapping\n    rdm1 = random.randint(0,box)\n    rdm2 = random.randint(0,box)\n    rdm3 = random.randint(0,box)\n    rdm4 = random.randint(0,box)\n  \n    #Creating 2 random row and column for swapping  \n    if matrix_1[rdm1,rdm2] != matrix_1[rdm3,rdm4]:\n        total = 0\n        \n        Ei_1 = abs(4*matrix_1[rdm1,rdm2] - (matrix_1[next_(rdm1),rdm2] + matrix_1[prec(rdm1),rdm2] + matrix_1[rdm1,prec(rdm2)] + matrix_1[rdm1,next_(rdm2)]))\n        Ei_2 = abs(4*matrix_1[rdm3,rdm4] - (matrix_1[next_(rdm3),rdm4] + matrix_1[prec(rdm3),rdm4] + matrix_1[rdm3,prec(rdm4)] + matrix_1[rdm3,next_(rdm4)]))\n        Ei = 2 * (Ei_1+Ei_2)\n        \n        Ef_1 = abs(4*matrix_1[rdm3,rdm4] - (matrix_1[next_(rdm1),rdm2] + matrix_1[prec(rdm1),rdm2] + matrix_1[rdm1,prec(rdm2)] + matrix_1[rdm1,next_(rdm2)]))\n        Ef_2 = abs(4*matrix_1[rdm1,rdm2] - (matrix_1[next_(rdm3),rdm4] + matrix_1[prec(rdm3),rdm4] + matrix_1[rdm3,prec(rdm4)] + matrix_1[rdm3,next_(rdm4)]))\n        Ef = 2 * (Ef_1+Ef_2)\n        \n        dE = Ef-Ei\n        \n        if dE <= 0 or np.exp(-dE * beta) > np.random.rand():\n            #print(rdm1,rdm2)\n            #print(rdm3,rdm4)\n            \n            store = matrix_1[rdm3,rdm4]\n            matrix_1[rdm3,rdm4] = matrix_1[rdm1,rdm2]\n            matrix_1[rdm1,rdm2] = store\n\n            return matrix_1\n        \n        else:\n            return swap_(matrix_1,beta=0.5)\n    else:\n        return swap_(matrix_1,beta=0.5)","e39901c7":"def random_regular_field(N, M):\n    return np.random.choice([0, 1], size=(N, M))\n\nfrom tqdm import tqdm\nregular_images = [random_regular_field(box+1, box+1)]\nfor i in tqdm(range(1000**2)):\n    regular_images.append(swap_(regular_images[-1].copy()))","da8e0634":"display_regular_sequence(regular_images);","45044ae7":"display_regular_field(regular_images[0]).resize(size=(250, 250))","97eaae1b":"display_regular_field(regular_images[-1]).resize(size=(250, 250))","dfb0a7a8":"def swap_general(matrix_1,beta=0.5):\n    #Creating 2 random row and column for swapping\n    rdm1 = random.randint(0,box)\n    rdm2 = random.randint(0,box)\n    rdm3 = random.randint(0,box)\n    rdm4 = random.randint(0,box)\n  \n    #Creating 2 random row and column for swapping  \n    if matrix_1[rdm1,rdm2] != matrix_1[rdm3,rdm4]:\n        total = 0\n        \n        Ei_1 = abs(4*matrix_1[rdm1,rdm2] - (matrix_1[next_(rdm1),rdm2] + matrix_1[prec(rdm1),rdm2] + matrix_1[rdm1,prec(rdm2)] + matrix_1[rdm1,next_(rdm2)]))\n        Ei_2 = abs(4*matrix_1[rdm3,rdm4] - (matrix_1[next_(rdm3),rdm4] + matrix_1[prec(rdm3),rdm4] + matrix_1[rdm3,prec(rdm4)] + matrix_1[rdm3,next_(rdm4)]))\n        Ei = 2 * (Ei_1+Ei_2)\n        \n        Ef_1 = abs(4*matrix_1[rdm3,rdm4] - (matrix_1[next_(rdm1),rdm2] + matrix_1[prec(rdm1),rdm2] + matrix_1[rdm1,prec(rdm2)] + matrix_1[rdm1,next_(rdm2)]))\n        Ef_2 = abs(4*matrix_1[rdm1,rdm2] - (matrix_1[next_(rdm3),rdm4] + matrix_1[prec(rdm3),rdm4] + matrix_1[rdm3,prec(rdm4)] + matrix_1[rdm3,next_(rdm4)]))\n        Ef = 2 * (Ef_1+Ef_2)\n        \n        dE = Ef-Ei\n        \n        if dE <= 0 or np.exp(-dE * beta) > np.random.rand():\n            #print(rdm1,rdm2)\n            #print(rdm3,rdm4)\n            \n            store = matrix_1[rdm3,rdm4]\n            matrix_1[rdm3,rdm4] = matrix_1[rdm1,rdm2]\n            matrix_1[rdm1,rdm2] = store\n\n            return matrix_1\n        \n        else:\n            return matrix_1\n    else:\n        return matrix_1","22731844":"from tqdm import tqdm\nregular_images_general = [random_regular_field(box+1, box+1)]\nfor i in tqdm(range(1000**2)):\n    regular_images.append(swap_general(regular_images_general[-1].copy()))","62a2c777":"display_regular_sequence(regular_images_general);","6ca62d05":"display_regular_field(regular_images_general[-1]).resize(size=(250, 250))","01fb5974":"from IPython.display import Image\nImage(filename='..\/input\/mc-regular-ising-supplementary\/Regular Part 1.PNG')","fcd98499":"Image(filename='..\/input\/mc-regular-ising-supplementary\/Regular Part 2.PNG')","f281ceda":"from IPython.display import YouTubeVideo\nYouTubeVideo('Wy9YoEYv-fA', width=600, height=350)","79511767":"# 1. Generating initial configurations\ndef random_spin_field(N, M):\n    return np.random.choice([-1\/2, 1\/2], size=(N, M))\n\ninitial_ising = random_spin_field(10, 10)\ninitial_ising","71a0c613":"# Supplementary 1\nfrom PIL import Image\n\ndef display_spin_field(field):\n    return Image.fromarray(np.uint8((field*2 + 1) * 0.5 * 255))  # 0 ... 255\n\ndisplay_spin_field(random_spin_field(10, 10))","98ee79af":"# 2. Creating initial steps of the Ising Model\ndef ising_step(field, beta=2):\n    N, M = field.shape\n    for n_offset in range(2):\n        for m_offset in range(2):\n            for n in range(n_offset, N, 2):\n                for m in range(m_offset, M, 2):\n                    _ising_update(field, n, m, beta)\n    return field\n\n# 2. Creating initial steps of the Ising Model\ndef _ising_update(field, n, m, beta):\n    total = 0\n    N, M = field.shape\n    for i in range(n-1, n+2):\n        for j in range(m-1, m+2):\n            if i == n and j == m:\n                continue\n            total += field[i % N, j % M]\n    dE = 2 * field[n, m] * total\n    if dE <= 0:\n        field[n, m] *= -1\n    elif np.exp(-dE * beta) > np.random.rand():\n        field[n, m] *= -1","47ab4247":"display_spin_field(ising_step(random_spin_field(200, 200)))","caa508cd":"from tqdm import tqdm\n\nimages = [random_spin_field(200, 200)]\nfor i in tqdm(range(1000)):\n    images.append(ising_step(images[-1].copy()))","1f0ff358":"from PIL import Image\ndisplay_ising_sequence(images);","96ffd939":"from IPython.display import Image\nImage(filename='..\/input\/mc-regular-ising-supplementary\/Ising.PNG')","135faafd":"## Ising Model\nPrior to modelling execution, it's good to understand the Physics intuition of the Ising Model, as the basic foundation of Quantum Computing. Ising Model are defined by two interaction of the nearest neighbour, which in this stage is spin-up and spin-down that act as the subdomain of the magnet. The energy calculation of the Ising model derived from the:\n1. Multiplication of nearest neighbour and additional coefficient as coupling factor if there is any medium in between that reduce interaction energy\n2. The sum of the spin-up\/spin-down comes imply the effect of external magnetic field that change the spin-up\/spin-down direction, which further effect the energy interaction. \n\nMore details are explained here:\n1. QUBO, https:\/\/en.wikipedia.org\/wiki\/Quadratic_unconstrained_binary_optimization","abc02262":"1. Initial Attempt: https:\/\/www.kaggle.com\/darisdzakwanhoesien2\/mc-regular-ising\n2. Successful regular model: https:\/\/www.kaggle.com\/darisdzakwanhoesien2\/mc-regular\n\n\n1. There are 2 model discussed, which is Regular Model and Ising Model\n2. Both of them require analysis of the lowest-highest temperature, average energy, specific heat\n3. **Regular Model**: Learn the probability distribution of the local energy, understaning the transition temperature, estimate the transition temperature at different values of density\n4. **Ising Model**: Magnetization average and suspectibility, and plot the probability distribution of the average magnetization per spin in k-th simulation at selected temperatures\n","f9a264f6":"## Regular Model"}}