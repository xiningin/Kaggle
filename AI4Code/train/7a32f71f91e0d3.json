{"cell_type":{"9a2fae7e":"code","98b33428":"code","3a0c26f4":"code","40e40fe4":"code","503662f5":"code","c0f64a46":"code","7d34da10":"code","1b438364":"markdown","27aceb8d":"markdown","b1f35d62":"markdown","c1d73a8f":"markdown","ef14daa2":"markdown","76b9b60e":"markdown"},"source":{"9a2fae7e":"!pip install git+https:\/\/github.com\/EasyArray\/phosphorus#egg=phosphorus\n%load_ext phosphorus","98b33428":"tree[_A B C]","3a0c26f4":"tree[_Number [_Digit SEVEN]]\ntree[_Number [_Number [_Digit THREE]] [_Digit ONE]]\ntree[_Number [_Number [_Number [_Digit THREE]] [_Digit ONE]] [_Digit ONE]]","40e40fe4":"lex ZERO  = 0\nlex ONE   = 1\nlex TWO   = 2\nlex THREE = 3\nlex FOUR  = 4\nlex FIVE  = 5\nlex SIX   = 6 \nlex SEVEN = 7\nlex EIGHT = 8\nlex NINE  = 9\n\n\nlex[THREE]","503662f5":"rule DIGIT  \u27e6tree[_Digit \u03b1]\u27e7    = lex[\u03b1]\nrule SINGLE \u27e6tree[_Number \u03b1]\u27e7   = \u27e6\u03b1\u27e7\nrule BRANCH \u27e6tree[_Number \u03b1 \u03b2]\u27e7 = \u27e6\u03b1\u27e7*10+\u27e6\u03b2\u27e7\n\ntree1 = tree[_Number [_Digit THREE] [_Digit SEVEN]]\ntree1\n\u27e6tree1\u27e7\n\ntree2 = tree[_Number [_Digit THREE]]\ntree2\n\u27e6tree2\u27e7\n\ntree3 = tree[_Number tree2]\ntree3\n\u27e6tree3\u27e7","c0f64a46":"t1 = tree[_Number [_Digit SEVEN]]\nt2 = tree[_Number [_Number [_Digit THREE]] [_Digit ONE]]\nt3 = tree[_Number [_Number [_Digit THREE] [_Digit ONE]] [_Digit ONE]]\n\nwrong = tree[_Number [_Digit THREE] [_Number [_Number [_Digit ONE]] [_Digit ONE]]]\n\nt1\n\u27e6t1\u27e7\nt2\n\u27e6t2\u27e7\nt3\n\u27e6t3\u27e7\nwrong\n\u27e6wrong\u27e7","7d34da10":"lex NEXT = [\u03bbx . x+1]\nlex PLUS = [\u03bbx . [\u03bby . x+y]]\n    \nrule OP      \u27e6tree[_Operator \u03c9]\u27e7  = lex[\u03c9]\nrule OPLEFT  \u27e6tree[_OpLeft \u03c9 \u03b2]\u27e7  = \u27e6\u03c9\u27e7(\u27e6\u03b2\u27e7)\nrule OPRIGHT \u27e6tree[_OpRight \u03b2 \u03c9]\u27e7 = \u27e6\u03c9\u27e7(\u27e6\u03b2\u27e7)\n\nplus26 = tree[_OpRight [_Digit TWO] [_OpLeft [_Operator PLUS] [_Digit SIX]]]\nplus26\n\u27e6plus26\u27e7\n\nnext9 = tree[_OpLeft [_Operator NEXT] [_Digit NINE]]\nnext9\n\u27e6 next9 \u27e7","1b438364":"# Formal Languages\n\nA *formal language* is a formal system used only to determine well-formed expressions and formulas (wffs). The wffs derived in a formal language are the theorems of that language, but they are not true or false in any relevant sense. Thus, a formal language is a syntax, only generating forms without assigning any meaning to them. \n\n## Context-free languages\nCertain classes of formal languages will pair strings with trees (a process called parsing). In some cases, the trees themselves become more important to semantic interpretation than the strings they correspond to. For example, *context-free grammars* generate formal languages with rules like the following:\n\nA &rightarrow; B C\n\nThis rule means that an item of category B followed by an item of category C together form an A. When this occurs, it can be visualized in a tree diagram:","27aceb8d":"### Interpreting Formal Languages\nIf formal languages correspond to syntax, an *interpretation* usually provides their semantics. Interpretations may take many forms, but in natural language semantics, they usually consist of:\n\n1. One or more sets or *domains* of possible semantic values.\n2. A lexicon assigning values to (certain) terminal nodes.\n3. A series of rules defining an *interpretation function* which assigns values to all other nodes.\n\nIn the cell below, the lexicon for our Number system is defined using a python object called a *dictionary* where *keys* are associated with *values*. Values may be retrieved by putting the key inside square brackets after the dictionary: `value = dictionary[key]`. Phosphorus provides a special dictory for the lexicon called `lex` that can be set via the `lex` keyword as shown below.\n\nThe cells below contains an interpretation of our formal language above. The (single) domain of values is whole positive numbers.","b1f35d62":"### Extending the system. \n\nThe next cell introduces interpretations for two new terminal nodes: \n* **NEXT** (for next number\/successor) and \n* **PLUS** (for addition)\n\nAnd three new non-terminal nodes:\n* **Operator**\n* **OpLeft** and \n* **OpRight**\n\n<mark> \ud83d\udcdd Answer the following questions by editing this cell or the cell below, as appropriate.<\/mark>\n1. Write appropriate grammar rules for the new nodes. Remember that items *in* the formal language, including non-terminal nodes, should be in boldface.\n2. Notice that I did not include the **Number** and **Digit** nodes over the digit terminal nodes below. What are the advantages and disadvantages to abbreviating the tree this way?\n2. Why do we need both **OpLeft** and **OpRight** node types?\n2. Add a tree using the new `NEXT` operator and see if it is interpreted correctly.\n2. Add a tree using both new operators and see if it is interpreted correctly.\n2. Extend the system in one new way and test your new extension.","c1d73a8f":"### Formalizing digits and numbers\n\nConsider the following grammar for base-ten numbers:\n\n**Digit &rightarrow; ZERO &ensp; Digit &rightarrow; ONE &ensp; Digit &rightarrow; TWO &emsp; &nbsp;\nDigit &rightarrow; THREE &ensp; Digit &rightarrow; FOUR** <br>\n**Digit &rightarrow; FIVE &emsp; Digit &rightarrow; SIX &emsp; Digit &rightarrow; SEVEN &ensp;\nDigit &rightarrow; EIGHT &emsp; Digit &rightarrow; NINE**\n\n**Number &rightarrow; Digit &emsp; Number &rightarrow; Number Digit** &emsp; &#9654; **Number**\n\n\nThe digits **ZERO** ... **NINE** are the *terminal nodes* of this grammar, while **Digit** and **Number** are the *non-terminal nodes*. The symbol &#9654; indicates that **Number** is a special non-terminal node known as the *start symbol*. All trees in the grammar must have **Number** as their topmost, or *root* node.\n\n\nThe next cell contains three trees that fit in this grammar. \n\n<mark>\ud83d\udcdd Write two more trees conforming to this grammar, without just replacing the terminal nodes of my three trees.<\/mark>","ef14daa2":"The interpretation function, represented by double brackets `\u27e6 \u27e7`, is defined by rules as shown in the next cell. To type double brackets, enter `\\[` or `\\]` then tab. After the `rule` keyword and the name of the rule as before, there comes a pattern inside double brackets. Just like before, Greek letters in the pattern are variables that may match other phosphorus objects, like trees and constants. After an equals sign, the rule defines the output of the interpretation function `\u27e6 \u27e7` whenever the input matches the pattern.\n\nFor instance the first rule below is named `DIGIT` and is triggered by any unary\/non-branching node named `Digit`. The semantic value of the single child `\u03b1` of this node is looked up in the `lex` dictionary defined above. Finally, the semantic value for the node as a whole is this value, retrieved from `lex`.\n\nOnce the rules are defined, trees in our Number formal language can be interpreted as shown:","76b9b60e":"### Practice\n\nThe interpretation defined above will correctly assign numbers to well-formed trees in our Number formal language. However, it will also assign values to certain ill-formed trees, such as the fourth below.\n\n<mark>\ud83d\udcdd (Edit this cell to answer:) What is wrong, syntactically, with this fourth tree? Why is the semantic value not what would be expected, given the string of non-terminals?<\/mark>"}}