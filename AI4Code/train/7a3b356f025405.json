{"cell_type":{"725f29bb":"code","da986c8f":"code","1dde5829":"code","3912370b":"code","c5af449e":"code","db0722bd":"code","fee73179":"code","c8c5a2f7":"code","80e2ef31":"code","957a7d1a":"code","dd7f741b":"code","8e977907":"code","2d55922b":"code","13acb503":"code","11c52cdd":"code","f037594f":"code","0c7c39c0":"code","eb7caf19":"code","7790ca90":"code","f96500d2":"code","2ef1264e":"code","015e29c9":"code","807a69a3":"code","34fcffde":"code","0b60edf4":"code","f13838f7":"code","e6452bcb":"code","248f27b4":"code","c97a941a":"code","14349862":"code","da3d2379":"markdown","925d8242":"markdown","cde81a00":"markdown","e745ce02":"markdown","08ac6e0c":"markdown","6c830b5b":"markdown","29cf18e5":"markdown","572c5975":"markdown","90a2f2b2":"markdown","8b32a7d0":"markdown","38be577f":"markdown","ab47ed2e":"markdown","12613d57":"markdown","bb878298":"markdown"},"source":{"725f29bb":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# %matplotlib inline # is this really needed if I always use plt.show()?\npd.plotting.register_matplotlib_converters() # modifies global matplotlib.units.registry dictionary (time\/date related)\npd.set_option('max_rows', 50) # max rows to display by whatever I set\npd.set_option('max_columns', 25)\n# pd.reset_option('display.max_rows') # resets to default of 60\n# pd.reset_option('all') # resets all changed options\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","da986c8f":"# adjustText prevents overlapping annotations text, which will make plots more readable:\n\n!pip install adjustText\n# https:\/\/adjusttext.readthedocs.io\/en\/latest\/\n# https:\/\/stackoverflow.com\/questions\/8850142\/matplotlib-overlapping-annotations\n# https:\/\/stackoverflow.com\/questions\/19073683\/matplotlib-overlapping-annotations-text","1dde5829":"# gapminder_filepath = '..\/input\/gapminder-dataset\/gapminder_data.csv' # probably won't use - missing too many values\ncountry_vac_filepath = '..\/input\/d\/gpreda\/covid-world-vaccination-progress\/country_vaccinations.csv'\nmanufacturer_vac_filepath = '..\/input\/d\/gpreda\/covid-world-vaccination-progress\/country_vaccinations_by_manufacturer.csv' # might not use - has only a fraction of countries\n\nincome_per_capita_filepath = '..\/input\/d\/nickwilliams\/gapminder-dataset\/income_per_person_gdppercapita_ppp_inflation_adjusted.csv'\npopulation_filepath = '..\/input\/d\/nickwilliams\/gapminder-dataset\/population_total.csv'\nlife_expetancy_filepath ='..\/input\/d\/nickwilliams\/gapminder-dataset\/life_expectancy_years.csv'\ngini_filepath = '..\/input\/income-inequality\/gini.csv'\n\n# gapminder = pd.read_csv(gapminder_filepath)\ncvacc_df = pd.read_csv(country_vac_filepath, parse_dates=['date'])\nmvacc_df = pd.read_csv(manufacturer_vac_filepath, parse_dates=['date'])\n\nincome = pd.read_csv(income_per_capita_filepath, usecols=['country','2021'])\npopulation = pd.read_csv(population_filepath, usecols=['country','2021'])\nlife_expectancy = pd.read_csv(life_expetancy_filepath, usecols=['country','2021'])\ngini = pd.read_csv(gini_filepath, usecols=['country','2021'])","3912370b":"# combine the 2021 world stats we extracted from seperate csv's into one df\n\nfrom functools import reduce\ndataframes = [income,gini,population,life_expectancy]\ncountries_df = reduce(lambda left, right: pd.merge(left, right, on=['country'],how='outer'),dataframes)\ncountries_df.columns = ['country','income','gini','population','expectancy']\n# countries_df.head()","c5af449e":"# need to get the names of the countries to be the same. Start by looking at what is already the same, and what is different:\n\nsame = list(set(cvacc_df.country.unique()).intersection(countries_df.country.unique()))\n\nin_cvacc_not_countries = list(set(cvacc_df.country.unique()).difference(set(countries_df.country.unique()))) # present in cvacc but not countries\nin_countries_not_cvacc = list(set(countries_df.country.unique()).difference(set(cvacc_df.country.unique()))) # present in countries but not cvacc\n\nsame.sort()\nin_cvacc_not_countries.sort()\nin_countries_not_cvacc.sort()\n\n# print(same, '\\n')\n# print(in_cvacc_not_countries, '\\n')\n# print(in_countries_not_cvacc)","db0722bd":"# if two countries have different names, then rename the country in countries df to be the same as cvacc df:\n\nname_pairs = {'Congo, Dem. Rep.': 'Democratic Republic of Congo',\n              'Congo, Rep.': 'Congo',\n              'Czech Republic': 'Czechia',\n              'Kyrgyz Republic': 'Kyrgyzstan',\n              'Lao': 'Laos',\n              'Slovak Republic': 'Slovakia',\n              'St. Kitts and Nevis': 'Saint Kitts and Nevis',\n              'St. Lucia': 'Saint Lucia',\n              'St. Vincent and the Grenadines': 'Saint Vincent and the Grenadines',\n              'Timor-Leste': 'Timor'}\ncountries_df[\"country\"] = countries_df[\"country\"].replace(name_pairs)\n\n# the rest of the names are mismatching countries or portions of countries so . . .\n# drop the mismatched countries\n\nin_cvacc_not_countries = list(set(cvacc_df.country.unique()).difference(set(countries_df.country.unique()))) # present in cvacc but not countries\nin_countries_not_cvacc = list(set(countries_df.country.unique()).difference(set(cvacc_df.country.unique()))) # present in countries but not cvacc\n\ncountries_df = countries_df[~countries_df['country'].isin(in_countries_not_cvacc)]\ncvacc_df = cvacc_df[~cvacc_df['country'].isin(in_cvacc_not_countries)]\n# mvacc_df = mvacc_df[~mvacc_df['location'].isin(in_cvacc_not_countries)]","fee73179":"# the result is 2 dfs with the same number of countries, and the same names for the countries:\n\nsame = list(set(cvacc_df.country.unique()).intersection(countries_df.country.unique()))\nin_cvacc_not_countries = list(set(cvacc_df.country.unique()).difference(set(countries_df.country.unique()))) # present in cvacc but not countries\nin_countries_not_cvacc = list(set(countries_df.country.unique()).difference(set(cvacc_df.country.unique()))) # present in countries but not cvacc\n\nsame.sort()\nin_cvacc_not_countries.sort()\nin_countries_not_cvacc.sort()\n\n# print(same, '\\n')\n# print(in_cvacc_not_countries, '\\n')\n# print(in_countries_not_cvacc, '\\n')\n\n# print('countries in cvacc df: ', cvacc_df.country.nunique())\n# print('countries in mvacc df: ', mvacc_df.location.nunique())\n# print('countries in countries df: ', countries_df.country.nunique())","c8c5a2f7":"def print_n_per_line(items, n_cols, char_width=20):\n    n_rows = int(len(items)\/n_cols) + 1\n    padding_needed = n_rows * n_cols - len(items)\n#     print(\"need padding of: \", padding_needed)\n    for p in range(padding_needed):\n        items = np.append(items,[' '])\n    items_2D = (np.array(items).reshape(-1, n_rows)).T\n    for row in items_2D:\n        for i in row:\n            print(\" \" + i[:char_width] + ''.join([' ' for j in range(char_width - len(i))]), end='')\n        print()","80e2ef31":"# # display(cvacc.info())\n# display(cvacc_df.shape)\n# display(cvacc_df.head())\n# print('countries: ', cvacc_df.country.nunique())\n# print_n_per_line(cvacc_df.country.unique(), 5, 26)\n# # cvacc_df.country.value_counts()\n# # cvacc_df[cvacc_df['country']=='United States']","957a7d1a":"# The only country without an income - so I looked it up:\ncountries_df.loc[countries_df.index[countries_df['country']=='Liechtenstein'], 'income'] = 95000.0\n\n# The only country without a gini - so I looked it up (not sure how accurate it is):\ncountries_df.loc[countries_df.index[countries_df['country']=='Eswatini'], 'gini'] = 54.6\n\n# countries_df[countries_df.expectancy.isna()]\n# And I looked up the 8 countries missing life expectancy (1st 4 from https:\/\/data.worldbank.org\/indicator\/SP.DYN.LE00.IN)\n\nlife_expectancy_dict = {'Dominica': 77.0,\n                        'Liechtenstein': 83.0,\n                        'San Marino': 85.0,\n                        'Saint Kitts and Nevis': 71.0,\n                        'Andorra': 81.2,\n                        'Monaco': 86.5,\n                        'Nauru': 59.7,\n                        'Tuvalu': 68.0}\n\nfor country_key, expectancy_value in life_expectancy_dict.items():\n    countries_df.loc[countries_df.index[countries_df['country']==country_key], 'expectancy'] = expectancy_value","dd7f741b":"countries_df.isna().sum()","8e977907":"plt.figure(figsize=(15,5))\nplt.title(\"% of Entire Population Fully Vaccinated for COVID-19\", fontsize=16)\nplt.ylabel(\"% Fully Vaccinated\", fontsize=14)\nplt.xlabel(\"Date\", fontsize=14)\nplt.tight_layout()\n\nfor country in ['United States', 'United Kingdom', 'Iceland', 'Israel', 'Saudi Arabia']:\n    ax = sns.lineplot(data=cvacc_df[cvacc_df['country']==country], x='date', y='people_fully_vaccinated_per_hundred', label=country)\n\nplt.show()","2d55922b":"# The book Factfulness found it useful to divide countries into 4 income groups, as described here:\n# https:\/\/www.gapminder.org\/fw\/income-levels\/\n# Gapminder uses different \"level\" definitions for different applications. I roughly match the latest bubble chart,\n# as shown here: https:\/\/www.gapminder.org\/tools\/#$chart-type=bubbles&url=v1\n# and described here: https:\/\/www.gapminder.org\/news\/gapminder-tools-are-coming\/\n# The following formula assigns each country a level based on its projected 2021 median income\n# (using levels assigned to latest gapminder bubble chart):\n\ninc_level_dict = {1: 0, 2: 2700, 3: 8000, 4: 24000, 5: 120000}\npop_level_dict = {1: 0, 2: 5000000, 3: 50000000, 4: 1500000000}\ngini_level_dict = {1: 0, 2: 33, 3: 40, 4: 44, 5: 70}\n\ninc_level_words_dict = {1: \"VERY LOW\", 2: \"LOW\", 3: \"MEDIUM\", 4: \"HIGH\"}\npop_level_words_dict = {1: \"LOW\", 2: \"MEDIUM\", 3: \"HIGH\"}\ngini_level_words_dict = {1: \"HIGHLY EGALITARIAN\", 2: \"NORMAL EQUALITY\", 3: \"SOMEWHAT UNEQUAL\", 4: \"VERY UNEQUAL\"}\n\ncountries_df['inc_level'] = 1 + 1*(countries_df.income >= inc_level_dict[2]) + 1*(countries_df.income >= inc_level_dict[3]) + 1*(countries_df.income >= inc_level_dict[4])\ncountries_df['pop_level'] = 1 + 1*(countries_df.population >= pop_level_dict[2]) + 1*(countries_df.population >= pop_level_dict[3])\ncountries_df['gini_level'] = 1 + 1*(countries_df.gini >= gini_level_dict[2]) + 1*(countries_df.gini >= gini_level_dict[3]) + 1*(countries_df.gini >= gini_level_dict[4])\ncountries_df.tail(10)\n\n# Notes to self:\n\n# data from gapminder can be confusing as sometimes they transform income data, sometimes not\n# Not sure but I think GDP per capita income level is sometimes divided further by average household size\n# But it isn't in this particular data set or the famous bubble chart\n\n# here are some sources to look at to better understand the gapminder calculations:\n\n# https:\/\/www.gapminder.org\/data\/\n# https:\/\/www.gapminder.org\/data\/documentation\/income-mountains-dataset\/\n# https:\/\/docs.google.com\/spreadsheets\/d\/1B-LfIcW3fL1emhJ1e3OcyukQlDIRpmMARXaOhPyhQFE\/edit#gid=0\n\n# https:\/\/www.gapminder.org\/news\/gapminder-tools-are-coming\/\n# https:\/\/www.gapminder.org\/tools\/#$chart-type=bubbles&url=v1\n# https:\/\/www.gapminder.org\/fw\/income-levels\/\n# https:\/\/www.gapminder.org\/tag\/map\/\n# https:\/\/www.gapminder.org\/data\/documentation\/\n# https:\/\/www.python-graph-gallery.com\/341-python-gapminder-animation","13acb503":"def create_levels_summary_df(df, lev_type, level_words_dict, level_dict):\n    summary_df = df[lev_type + '_level'].value_counts().sort_index().rename_axis(lev_type + '_level').reset_index(name='counts')\n    summary_df[lev_type + '_level_label'] = summary_df[lev_type + '_level'].map(level_words_dict)\n    summary_df[lev_type + '_min'] = summary_df[lev_type + '_level'].map(level_dict)\n    summary_df[lev_type + '_max'] = summary_df[lev_type + '_level'].transform(lambda x: x + 1).map(level_dict) # transform adds 1 to input for mapped dict\n    return summary_df\n\ninc_summary_df = create_levels_summary_df(countries_df, 'inc', inc_level_words_dict, inc_level_dict)\npop_summary_df = create_levels_summary_df(countries_df, 'pop', pop_level_words_dict, pop_level_dict)\ngini_summary_df = create_levels_summary_df(countries_df, 'gini', gini_level_words_dict, gini_level_dict)\n\ndisplay(inc_summary_df, pop_summary_df, gini_summary_df)\n\n# inc_level_dict = {1: 0, 2: 2700, 3: 8000, 4: 24000, 5: 120000}\n# pop_level_dict = {1: 0, 2: 5000000, 3: 50000000, 4: 1500000000}\n# gini_level_dict = {1: 0, 2: 33, 3: 40, 4: 44, 5: 70}\n\n# inc_level_words_dict = {1: \"VERY LOW\", 2: \"LOW\", 3: \"MEDIUM\", 4: \"HIGH\"}\n# pop_level_words_dict = {1: \"LOW\", 2: \"MEDIUM\", 3: \"HIGH\"}\n# gini_level_words_dict = {1: \"HIGHLY EGALITARIAN\", 2: \"NORMAL EQUALITY\", 3: \"SOMEWHAT UNEQUAL\", 4: \"VERY UNEQUAL\"}\n\n# # inc_summary_df = countries_df.inc_level.map(countries_df.inc_level.value_counts()) # cool but not what I want\n# # inc_summary_df = countries_df.groupby('inc_level', as_index=False)['inc_level'].transform(lambda s: s.count())\n# inc_summary_df = countries_df.inc_level.value_counts().sort_index().rename_axis('inc_level').reset_index(name='counts')\n# inc_summary_df['inc_label'] = inc_summary_df['inc_level'].map(inc_level_words_dict)\n# inc_summary_df['inc_min'] = inc_summary_df['inc_level'].map(inc_level_dict)\n# inc_summary_df['inc_max'] = inc_summary_df['inc_level'].transform(lambda x: x + 1).map(inc_level_dict) # transform adds 1 to input for mapped dict\n\n# countries_df.index[countries_df.country=='China'][0]\n# inc_summary_df['inc_max'].transform(np.log).to_list()\n# countries_df[countries_df.country=='Argentina']\n# countries_df[countries_df.country=='Somalia']","11c52cdd":"# %%time\nfrom adjustText import adjust_text\n\nsns.set_style(\"whitegrid\")\n\nplt.figure(figsize=(24,24))\nplt.xlabel(\"GDP per Capita ($\/year, price adjusted)\", fontsize=16, labelpad=10)\nplt.ylabel(\"Life Expectancy\", fontsize=13)\n\ngini_color_alpha = .65\nax = sns.scatterplot(x=countries_df[\"income\"],\n                     y=countries_df[\"expectancy\"],\n                     size=countries_df[\"population\"], sizes=(100, 10000),\n                     hue=countries_df[\"gini\"], palette='RdYlGn_r', alpha=gini_color_alpha, hue_norm=(26,60))\n# stretch out gini coefficient color range by setting hue_norm tighter than full 25-65 range (and keep alpha high)\nax.set(xscale='log')\nax.set(xticks=inc_summary_df['inc_max'].to_list())\nax.set(xticklabels=inc_summary_df['inc_max'].to_list())\nax.tick_params(labelright=True)\nax.set_xticks([1050,4550,13400,56000], minor=True)\nax.set_xticklabels(['Income Level 1','Level 2','Level 3','Level 4'], minor=True)\n\n# the code below puts in custom values for population to solve two issues:\n# 1) poorly chosen population values without units\n# 2) croweded legend\npop_handles = [80, 150, 450, 1200, 7000]\npop_labels = ['\\n\\nPopulation', '  < 1 Million', '    10 Million', '    50 Million', '\\n  200 Million\\n', '\\n      1 Billion']\ngini_labels = ['gini\\ncoefficient', '32 (> equal)', '40', '48', '56 (< equal)']\nhandles, labels = ax.get_legend_handles_labels()\nfor i in range(11):\n    if i < 5: # gini\n        handles[i].set_sizes([180])\n        handles[i].set_alpha(gini_color_alpha)\n        labels[i] = gini_labels[i]\n    if i >= 5: # population\n        handles[i].set_sizes([pop_handles[i-6]])\n        labels[i] = pop_labels[i-5]\n\nplt.legend(handles, labels, loc='upper left', labelspacing=1.8, fontsize=15)\n\n# greatly reduces overlapping annotations text\ntexts = []\nfor x, y, text, text_size in zip(countries_df.income.values,\n                                 countries_df.expectancy.values,\n                                 countries_df.country.values,\n                                 countries_df.population.transform(np.log10).values):\n    texts.append(ax.text(x, y, text, fontsize=max(text_size*2.0, 7))) # if you think the text is too small for the smallest countries, change 7 to a higher number\nadjust_text(texts, force_text=(.2,.7), ha=\"left\", autoalign=False, lim=10,\n            arrowprops=dict(arrowstyle=\"-|>\",color='r', alpha=0.3))\nplt.show()","f037594f":"countries_df[countries_df.country=='Nigeria']","0c7c39c0":"print('countries: ', countries_df.country.nunique())\nprint_n_per_line(countries_df.country.unique(), 5, 25)","eb7caf19":"df = pd.merge(countries_df, cvacc_df, how=\"outer\", on=[\"country\"])\n\n# the sort order matters for most plots: legend order (and line thickness) is determined by the first sort key\n# df.sort_values(by=['gini', 'population', 'date'], ascending=[False, False, True], inplace=True)\ndf.sort_values(by=['population', 'date'], ascending=[False, True], inplace=True)\ndf.head()\n# df.shape\n# cvacc_df.shape","7790ca90":"# df.groupby(['inc_level', 'date']).people_fully_vaccinated_per_hundred.agg([min, max, np.nanmean])\nlevels = df.groupby(['inc_level', 'pop_level'], dropna=False).mean()\nlevels","f96500d2":"monthly_by_inc_level = df.groupby([pd.Grouper(key=\"date\", freq=\"1M\"),\n                               'inc_level']).mean().reset_index()\n\nweekly_by_inc_level = df.groupby([pd.Grouper(key=\"date\", freq=\"1W\"),\n                               'inc_level']).mean().reset_index()\n\nweekly_by_gini_level = df.groupby([pd.Grouper(key=\"date\", freq=\"1W\"),\n                               'gini_level']).mean().reset_index()","2ef1264e":"# df[df['inc_level']==1].country.unique()\nmonthly_by_inc_level","015e29c9":"# plot full vaccination over time by income level\n\nsns.set_style(\"whitegrid\")\nplt.figure(figsize=(12,8))\nplt.title(\"% of Entire Population Fully Vaccinated for COVID-19 by Income Level (4 is wealthiest)\", fontsize=16)\nplt.ylabel(\"% Fully Vaccinated\", fontsize=14)\nplt.xlabel(\"Date\", fontsize=14)\nplt.tight_layout()\n\nax = sns.lineplot(x='date', y='people_fully_vaccinated_per_hundred', data=weekly_by_inc_level, hue='inc_level', size='inc_level')\n# how I figured this out: https:\/\/stackoverflow.com\/questions\/62083824\/how-do-you-make-a-seaborn-line-plot-from-a-pandas-multiindex\nax.tick_params(labelright=True)\n\nplt.show()","807a69a3":"# plot full vaccination over time by gini level\n\nsns.set_style(\"whitegrid\")\nplt.figure(figsize=(12,8))\nplt.title(\"% of Entire Population Fully Vaccinated for COVID-19 by Gini Level (4 is most unequal)\", fontsize=16)\nplt.ylabel(\"% Fully Vaccinated\", fontsize=14)\nplt.xlabel(\"Date\", fontsize=14)\nplt.tight_layout()\n\nax = sns.lineplot(x='date', y='people_fully_vaccinated_per_hundred', data=weekly_by_gini_level, hue='gini_level', size='gini_level')\n# how I figured this out: https:\/\/stackoverflow.com\/questions\/62083824\/how-do-you-make-a-seaborn-line-plot-from-a-pandas-multiindex\nax.tick_params(labelright=True)\n\nplt.show()","34fcffde":"plt.figure(figsize=(12,8))\nplt.title(\"% of Entire Population Fully Vaccinated for COVID-19 in Very Low Income Countries\", fontsize=16)\nplt.ylabel(\"% Fully Vaccinated\", fontsize=14)\nplt.xlabel(\"Date\", fontsize=14)\nplt.tight_layout()\n\nmax_percent = 2.0\nfew_vaccinated = []\nfor country in df[df['inc_level']==1].country.unique():\n    if df[df['country']==country].people_fully_vaccinated_per_hundred.max() > max_percent:\n        ax = sns.lineplot(data=df[df['country']==country], x='date', y='people_fully_vaccinated_per_hundred', label=country)\n    else:\n        few_vaccinated.append(country)\nax.tick_params(labelright=True)\nplt.show()\nprint(\"NOTE: less than\", max_percent, \"% of people have been vaccinated in:\")\nprint(few_vaccinated)","0b60edf4":"import math\nimport re\nfrom decimal import Decimal\n\n# https:\/\/lost-stats.github.io\/Presentation\/Figures\/line_graph_with_labels_at_the_beginning_or_end.html\ndef label_end_of_lines(ax, fig, lines, extra_txts):\n    for line, name, extra_txt in zip(ax.lines, lines, extra_txts):\n        y = line.get_ydata()[-1]\n        x = line.get_xdata()[-1]\n        if not np.isfinite(y):\n            y=next(reversed(line.get_ydata()[~line.get_ydata().mask]),float(\"nan\"))\n        if not np.isfinite(y) or not np.isfinite(x):\n            continue\n        text = ax.annotate(name + \" \" + extra_txt,\n                           xy=(x, y),\n                           xytext=(20, 15),\n                           color=line.get_color(),\n                           xycoords=(ax.get_xaxis_transform(),\n                                     ax.get_yaxis_transform()),\n                           arrowprops=dict(arrowstyle=\"->\", color=line.get_color()),\n                           textcoords=\"offset points\")\n        text_width = (text.get_window_extent(fig.canvas.get_renderer()).transformed(ax.transData.inverted()).width)\n        if np.isfinite(text_width):\n            ax.set_xlim(ax.get_xlim()[0], text.xy[0] + text_width * 1.05)\n            \n\n# https:\/\/github.com\/azaitsev\/millify\/tree\/master\/millify\ndef remove_exponent(d):\n    return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize()\n\ndef millify(n, precision=1, drop_nulls=True, prefixes=[]):\n    millnames = ['', 'k', 'M', 'B', 'T', 'P', 'E', 'Z', 'Y']\n    if prefixes:\n        millnames = ['']\n        millnames.extend(prefixes)\n    n = float(n)\n    millidx = max(0, min(len(millnames) - 1,\n                         int(math.floor(0 if n == 0 else math.log10(abs(n)) \/ 3))))\n    result = '{:.{precision}f}'.format(n \/ 10**(3 * millidx), precision=precision)\n    if drop_nulls:\n        result = remove_exponent(Decimal(result))\n    return '{0}{dx}'.format(result, dx=millnames[millidx])\n\n# would be nice if I could figure out how to use adjustText to prevent overlapping annotations text\n# !pip install adjustText\n# https:\/\/adjusttext.readthedocs.io\/en\/latest\/\n# https:\/\/stackoverflow.com\/questions\/8850142\/matplotlib-overlapping-annotations\n# https:\/\/stackoverflow.com\/questions\/19073683\/matplotlib-overlapping-annotations-text","f13838f7":"for inc_level_to_plot in range(1,5): # country per capita income levels range from richest (4) to poorest (1)\n    country_list = list(df[df['inc_level']==inc_level_to_plot].country.unique())\n    countries_to_plot = df[df['inc_level']==inc_level_to_plot].country\n\n    fig, ax = plt.subplots(figsize=(15,15))\n    plt.title(\"% of Entire Population Fully Vaccinated for COVID-19 for Countries at Level \" + str(inc_level_to_plot), fontsize=16)\n    plt.ylabel(\"% Fully Vaccinated\", fontsize=14)\n    plt.xlabel(\"Date\", fontsize=14)\n    plt.tight_layout()\n    palette = sns.color_palette('hls', len(country_list))\n    sns.lineplot(ax=ax, data=df[df['inc_level']==inc_level_to_plot], x='date', y='people_fully_vaccinated_per_hundred', hue=countries_to_plot, size=countries_to_plot, palette=palette)\n    # df was sorted in advance by [population, date] so that high populations have thick lines. This helps readability.\n    # Possible but harder to do without advance df sort: https:\/\/seaborn.pydata.org\/generated\/seaborn.lineplot.html\n    extra_text_annotations = []\n    for cty in country_list:\n        extra_text_annotations.append(str(millify(countries_df[countries_df.country==cty].population.values[0])) + \" pop, \" +\n                                      str(millify(int(countries_df[countries_df.country==cty].income.values[0]))) + \" $\/yr\")\n    label_end_of_lines(ax, fig, country_list, extra_text_annotations)\n    ax.tick_params(labelright=True)\n    plt.legend(loc=\"upper left\")\n    plt.show()","e6452bcb":"for inc_level_to_plot in range(1,5): # country per capita income levels range from poorest (1) to richest (4)\n    for pop_level_to_plot in range(1,4): # population levels range from lowest (1) to highest (3)\n        df_plot_data = df[(df['inc_level']==inc_level_to_plot) & (df['pop_level']==pop_level_to_plot)]\n        country_list = list(df_plot_data.country.unique())\n        countries_to_plot = df_plot_data.country\n\n        fig, ax = plt.subplots(figsize=(15,15))\n        plt.title(\"% of Entire Country Population Fully Vaccinated for COVID-19 for:\\n\"\n                  + inc_level_words_dict[inc_level_to_plot] + \" Annual Income Per Capita (\"\n                  + str(inc_level_dict[inc_level_to_plot]\/1000) + \" to \" + str(inc_level_dict[inc_level_to_plot+1]\/1000) + \" Thousand)\\n\"\n                  + pop_level_words_dict[pop_level_to_plot] + \" Population (\"\n                  + str(pop_level_dict[pop_level_to_plot]\/1000000) + \" to \" + str(pop_level_dict[pop_level_to_plot+1]\/1000000) + \" Million)\",\n                  fontsize=16)\n\n        plt.ylabel(\"% Fully Vaccinated\", fontsize=14)\n        plt.xlabel(\"Date\", fontsize=14)\n        plt.tight_layout()\n        palette = sns.color_palette('hls', len(country_list))\n        sns.lineplot(ax=ax, data=df_plot_data, x='date', y='people_fully_vaccinated_per_hundred', hue=countries_to_plot, size=countries_to_plot, palette=palette)\n        # df was sorted in advance by [population, date] so that high populations have thick lines. This helps readability.\n        # Without doing this sort in advance, it's still possible but more work: https:\/\/seaborn.pydata.org\/generated\/seaborn.lineplot.html\n\n        extra_text_annotations = []\n        for cty in country_list:\n            extra_text_annotations.append(str(millify(int(countries_df[countries_df.country==cty].income.values[0]))) + \" $\/yr, \" +\n                                          str(millify(countries_df[countries_df.country==cty].population.values[0])) + \" pop\")\n        label_end_of_lines(ax, fig, country_list, extra_text_annotations)\n        ax.tick_params(labelright=True)\n        plt.legend(loc=\"upper left\")\n        plt.show()","248f27b4":"for inc_level_to_plot in range(1,5): # country per capita income levels range from poorest (1) to richest (4)\n    for gini_level_to_plot in range(1,5): # gini levels range from most EQUAL (1) to most UNEQUAL (4)\n        df_plot_data = df[(df['inc_level']==inc_level_to_plot) & (df['gini_level']==gini_level_to_plot)]\n        country_list = list(df_plot_data.country.unique())\n        countries_to_plot = df_plot_data.country\n\n        fig, ax = plt.subplots(figsize=(15,15))\n        plt.title(\"% of Entire Country Population Fully Vaccinated for COVID-19 for:\\n\"\n                  + inc_level_words_dict[inc_level_to_plot] + \" Annual Income Per Capita (\"\n                  + str(inc_level_dict[inc_level_to_plot]\/1000) + \" to \" + str(inc_level_dict[inc_level_to_plot+1]\/1000) + \" Thousand)\\n\"\n                  + gini_level_words_dict[gini_level_to_plot] + \" Income Distribution (\"\n                  + str(gini_level_dict[gini_level_to_plot]) + \" to \" + str(gini_level_dict[gini_level_to_plot+1]) + \" Gini Coefficient)\",\n                  fontsize=16)\n\n        plt.ylabel(\"% Fully Vaccinated\", fontsize=14)\n        plt.xlabel(\"Date\", fontsize=14)\n        plt.tight_layout()\n        palette = sns.color_palette('hls', len(country_list))\n        sns.lineplot(ax=ax, data=df_plot_data, x='date', y='people_fully_vaccinated_per_hundred', hue=countries_to_plot, size=countries_to_plot, palette=palette)\n        # df was sorted in advance by [population, date] so that high populations have thick lines. This helps readability.\n        # Possible but harder to do without advance df sort: https:\/\/seaborn.pydata.org\/generated\/seaborn.lineplot.html\n\n        extra_text_annotations = []\n        for cty in country_list:\n            extra_text_annotations.append(str(millify(int(countries_df[countries_df.country==cty].income.values[0]))) + \" $\/yr, \" +\n                                          str(millify(countries_df[countries_df.country==cty].population.values[0])) + \" pop, \" +\n                                          str(countries_df[countries_df.country==cty].gini.values[0]) + \" gini coeff\")\n        label_end_of_lines(ax, fig, country_list, extra_text_annotations)\n        ax.tick_params(labelright=True)\n        plt.legend(loc=\"upper left\")\n        plt.show()","c97a941a":"display(inc_summary_df, pop_summary_df, gini_summary_df)","14349862":"# countries_df.inc_level.value_counts().sort_index()\n# countries_df.gini_level.value_counts().sort_index()\n# countries_df.pop_level.value_counts().sort_index()\n\n# pop_sorted_countries = countries_df.sort_values(by=['population', 'inc_level'], ascending=[False, False])\n# pop_sorted_countries.describe()\n# pop_sorted_countries[pop_sorted_countries['country'] == 'Spain']","da3d2379":"Examining data about nearly 200 countries presents various visualization challenges. The easy way to overcome this challenge is to combine the countries into a small number of categories. The hard way is to encourage examination of every individual country.\n\nThis notebook takes on the harder task using two different techniques to examine all countries. The focus is on 2021 data for world stats and for COVID-19 vaccination progress over time.\n\nThe two techniques used are:\n\n1) Bubble graphs that were made famous by the book Factfulness and its companion website, [gapminder](https:\/\/www.gapminder.org\/tag\/map\/).\n\n2) Dividing country data into segments (or sometimes segmenting1 x segmenting2) and examining richly annotated multi-line graphs for all countries in each segment.\n\nI hide the next few cells which load environment, load adjustText library, and load data from several files, followed by prep\/cleaning\/merging operations. That way you can start by looking quickly skimming your way down to the plotted data. But all the code is there if you want to copy this notebook and play with the data in different ways.\n\nFeel free to drop in comments on anything - how the plots could be improved, what you interpret from the plots, or links to any of your own country data experiments.","925d8242":"Some of those plots were too crowded with two many lines. So the next two cells generate plots in more segments. It makes it easy to compare countries in similar situations (very low income, low population countries is the first chart, and a later chart shows medium income, high population countries).\n\nNote how the line coloring and thickness holds meaning - the thickest, red lines have the highest population and the lines gradually shift color and become thinner as the population decreases:","cde81a00":"With added code, we can add more information to the plot. The next cell adds some functions and then the next 3 cells thereafter put up multiple, segmented plots using these functions (you need to wait 20-60 seconds for each of the cells to draw all the plots):","e745ce02":"To look at COVID-19 vaccination data by country, we need to merge two dataframes together, as so:","08ac6e0c":"You can learn quite a bit studying the above graphs. One of the most striking findings is how some wealthy nations with great access to vaccines such as Israel and the United States started off much ahead of other countries with vaccination rates . . . but once other countries had as much access to the vaccines, they caught up and in many instances passed up these two countries. In fact, both U.S. and Isreal appear to be stalling out due to large portions of the population choosing refusing to take a COVID-19 vaccine.\n\nThe prior set of plots was segmented by income and population. The next set is segmented by income and gini coeffecient:","6c830b5b":"So we see that wealthier countries have higher vaccination rates. This makes sense as they can use their wealth to more easily secure their supplies.\n\nWhat is a little surprising is that, for the most part, the more unequal the income distribution, the lower the vaccination rates. There is virtually no correlation between income levels and how widely that income is distributed. Highly uneven (or more equal) distribution of income can happen at any wealth level. So this is an independent variable from income. It is not as highly predictive about vaccine distribution as income levels, but it is still a relatively strong predictor.\n\nNow let's look at invidual countries within segments. This first plot was not too complicated to figure out:","29cf18e5":"We can do some simple, big picture analysis by grouping together some data and then plotting it:","572c5975":"But . . . if we prepare the data and then use more sophisticated plotting techniques, we can look at all 188 countries in a variety of interesting ways.\n\nFirst we segment several of the continuous variables into levels: income per capita, population, and gini coefficient (The higher the gini coefficient, the more unequally income is distributed).\n\nFor income, I used the same levels as used by gapminder.com (Factfulness):","90a2f2b2":"Preparing dataframes to summarize each of these segmentations is useful for debugging and sometimes for segmenting information with complex plots:","8b32a7d0":"Both the bubble size and text size of each country varies by population size. If you can't make out the tiny name of the country, the list printed 2 cells below may help.\n\nYou could also change 7 to a higher number in fontsize=max(text_size*2, 7)) . . . but if it gets to be too big, the plot gets very crowded and hard to read.\n\nYou can also examine an individual country's stats with the following cell, replacing the country name with whichever one you want to examine:","38be577f":"I thought is was somewhat interesting that many of the countries with more equal distribution of wealth are doing better about getting their population vaccinated. I thought it was particularly interesting that in 2021, there is no such thing as a nation with relatively even distribution of wealth that is extremely poor.","ab47ed2e":"The data is now loaded, merged, and missing values have been filled in (as verified by the above zeros). Also, while I didn't yet merge the country dataframe with the COVID-19 vaccination rate dataframe, I did compare their country lists. Some countries were renamed, and others were dropped so that when we merge the data later, the country list will shrink to 188 countries.\n\nI think any time you work with multiple country databases, this kind of work will be required as different database creators have different names, and different conventions for considering whether a country is one or a collection of several (i.e. United Kingdom).\n\nSo now let's look at the data in various ways.\n\nThe simplest way is to look at specific countries that may be of interest to you. For example:","12613d57":"I end by again displaying the segment information in df form as that information was used so heavily in prior, segmented groups of charts.\n\nIt should be straightforward to employ these same methods to visualize other types of information about countries, using either gapminder-styled bubble charts, or choosing 2 levels of segments to break up countries into similar groups for comparison. There are of course many other ways to segment 188 countries than the ways I chose. Feel free to copy this notebook, experiment, and let me know in comments what interesting discoveries you make!","bb878298":"For the first of the fancy plots, we take inspiration from Gapminder.com (companion site to the book Factfulness). This version has one key difference - the colors of the bubbles relate to Gini coefficient (on gapminder, the color relates to geographical region).\n\nChoosing a color scheme that made it easy to interpret the gini coefficient bubble colors proved to be challenging. With earlier versions, the darker the color of the bubble, the more unequal income distribution. With experimentation, Red\/Yellow\/Green seemed easier to interpret. So now, the darker the red, the more unequal. The darker the green, the more equally income is distributed. Pure yellow is in the middle, but as it tends towards orange (then red) it gets more unequal. At least for my eyes, living in a country with Red\/Yellow\/Green traffic lights, this felt untuitive and easier to grasp, as more equally distributed incomes tend to be associated with many positive societal outcomes (better health, better educated populace, higher life satisfaction, etc.).\n\nSeveral advanced plotting techniques are used to transform the plot from messy to something that is easy to interpret. Figuring out how to make this one plot come out well took many hours, but it was worth it as these techniques can be used in the future for other projects.\n\nTHE PLOT TAKES NEARLY 30 SECONDS to generate. Most of the time is adjustText moving the text around to prevent overlapping - you can reduce lim=10 to a lower number to save time but there will be more text overlap. You can also make it look slightly nicer by increasing beyond 10."}}