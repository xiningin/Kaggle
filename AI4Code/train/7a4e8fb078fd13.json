{"cell_type":{"3e02878f":"code","97d8eb5e":"code","37e7ad3d":"code","f72885ed":"code","e3e1e403":"code","63968a85":"code","bcdbb752":"code","154f5b7a":"code","e25af5a9":"code","c36f5e86":"code","8b98e32a":"code","2b866135":"code","83aa9725":"code","940c021f":"code","c78a86ce":"code","2f841df9":"code","1ed3fc4c":"code","5de0c437":"code","4ef40e8f":"code","f39a49f4":"code","75e1f4e9":"code","92f0b149":"code","dcf06875":"code","3aa48ca3":"code","9e3d72f8":"code","91f6d112":"code","637647d2":"code","2c6afeef":"code","7e0d2aff":"code","0f4f59a7":"code","16297a12":"code","9857e1b8":"code","e9f1a1b5":"code","ebe6d164":"code","a0efd4ad":"code","74eea39e":"code","df851755":"code","55079087":"code","4a738a85":"code","37d660be":"code","14e4c3d6":"code","71d4ea4a":"code","eabb209d":"code","b13d23e2":"code","8444ead1":"code","a6b16ff2":"markdown"},"source":{"3e02878f":"try:\n  # Use the %tensorflow_version magic if in colab.\n  %tensorflow_version 2.x\nexcept Exception:\n  pass\n# for creating some Baseline models\nimport tensorflow as tf\nimport os\n# for in-built face detection module, that can be used to preprocess the images in order to crop-put everything else excepty the faces.\nimport dlib\n# fo image pre-processing\nimport cv2\nimport time\nimport math\nimport datetime\nimport matplotlib.pyplot as plt\nimport os\nimport pickle\nimport numpy as np\n#to load mat files into python.\nimport scipy.io\nimport bz2\nfrom random import randint\nimport plotly.express as px\n","97d8eb5e":"import string # library used to deal with some text data\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns # data visualization library\npd.set_option('display.max_columns', 100) # Setting pandas to display a N number of columns\npd.set_option('display.max_rows', 100) # Setting pandas to display a N number rows\npd.set_option('display.width', 1000) # Setting pandas dataframe display width to N\nimport plotly.graph_objs as go # interactive plotting library\nimport plotly.express as px # interactive plotting library\nfrom itertools import cycle # used for cycling colors at plotly graphs\nimport matplotlib.pyplot as plt # plotting library\n","37e7ad3d":"#downloading the WIKI dataset.\ndataset_url = 'https:\/\/data.vision.ee.ethz.ch\/cvl\/rrothe\/imdb-wiki\/static\/wiki_crop.tar'\nannotation_folder = \"wiki_crop\"\nif not os.path.exists(os.path.abspath('.') + annotation_folder):\n    annotation_zip = tf.keras.utils.get_file('wiki.tar',\n                                            cache_subdir=os.path.abspath('.'),\n                                            origin = dataset_url,\n                                            extract = True)\n    os.remove(annotation_zip)\ndata_key = 'wiki'\nmat_file = 'wiki.mat'","f72885ed":"#downloading the IMDB dataset.\ndataset_url = 'https:\/\/data.vision.ee.ethz.ch\/cvl\/rrothe\/imdb-wiki\/static\/imdb_crop.tar'\nannotation_folder1 = \"imdb_crop\"\nif not os.path.exists(os.path.abspath('.') + annotation_folder1):\n    annotation_zip1 = tf.keras.utils.get_file('imdb.tar',\n                                            cache_subdir=os.path.abspath('.'),\n                                            origin = dataset_url,\n                                            extract = True)\n    os.remove(annotation_zip1)\ndata_key1 = 'imdb'\nmat_file1 = 'imdb.mat'","e3e1e403":"#loading the Mat files containing the meta information i.e. the date of birth(dob),gender and image path and other kind of meta information about \n#the images such as face score which indicates whether an image has a face or not.\nmat_wiki = scipy.io.loadmat(annotation_folder+'\/'+mat_file)\nmat_imdb = scipy.io.loadmat(annotation_folder1+'\/'+mat_file1)","63968a85":"#storing the total number of instances present in each dataset.\ninstances_wiki = mat_wiki['wiki'][0][0][0].shape[1]\ninstances_imdb = mat_imdb['imdb'][0][0][0].shape[1] ","bcdbb752":"#This piece of code shows how the data is structued within the .mat file, here each element in mat_wiki['wiki'][0][0][i][0] represensts one column\n#in our dataframe which we append using the function defined in the next cell \"convertintodf\".\nfor i in range(len(mat_wiki['wiki'][0][0])):\n    print(mat_wiki['wiki'][0][0][i][0])","154f5b7a":"# A function that takes in column names as a list, dataframe name,corresponding .mat file, total instances of the data and name of dataset \n# and returns a pandas dataframe.\ndef convertintodf(columns,df,instances,matlabfile,name):\n \n  df = pd.DataFrame(index = range(0,instances), columns = columns)\n  \n  for i in matlabfile:\n    if i == name:\n      current_array = matlabfile[i][0][0]\n  for j in range(len(current_array)):\n    df[columns[j]] = pd.DataFrame(current_array[j][0])\n  return df","e25af5a9":"columns_im = [\"dob\", \"photo_taken\", \"full_path\", \"gender\", \"name\", \"face_location\", \"face_score\", \"second_face_score\",\"x1\",\"x2\"]\ncolumns_wi = [\"dob\", \"photo_taken\", \"full_path\", \"gender\", \"name\", \"face_location\", \"face_score\", \"second_face_score\"]\ndf_imdb = pd.DataFrame()\ndf_wiki = pd.DataFrame()","c36f5e86":"df_imdb = convertintodf(columns_im,df_imdb,instances_imdb,mat_imdb,\"imdb\")","8b98e32a":"#finally we have our .mat file converted into pandas CSV.\ndf_imdb","2b866135":"df_wiki = convertintodf(columns_wi,df_wiki,instances_wiki,mat_wiki,\"wiki\")\ndf_wiki","83aa9725":"#But there are a lot of columns that we dont need for this particular assignment such as Face_location, face_score, second_face_score, but they\n#will definitely come in handy when preprocessing the dataset.\ndef dropcol(df,columns):\n  df = df.drop(columns, axis = 1, inplace = True)\n  return df","940c021f":"columns_w = [\"name\", \"face_location\", \"face_score\", \"second_face_score\"]\ncolumns_i = [\"name\", \"face_location\", \"face_score\", \"second_face_score\",\"x1\",\"x2\"]","c78a86ce":"#Calling the dropcol function\ndropcol(df_imdb,columns_i)\ndropcol(df_wiki,columns_w)","2f841df9":"#a much more cleaner CSV\ndf_imdb","1ed3fc4c":"df_wiki","5de0c437":"#Lets combine the two CSV's into one i.e. df_imdb and df_wiki using the concat function.\ndf_comb = pd.concat([df_imdb, df_wiki], ignore_index=True, sort=False)\ndf_comb","4ef40e8f":"#Now there is one small problem here, in the .mat file the date of birth i.e. the \"dob\" column has the date of birth in the matlab datenum format\n#and we need to convert it to the python datetime format, which can be done as defined in the following function, but one thing to take care of\n#is the fact that matlab datetime starts the calendar with 0AD(1st January) while in python the calendar starts at 1AD(1st January), so if \n#I am born in 1960 in matlab, while converting it to python it will be of by 366 days, that is it will come out as 1961, so wee need to subtarct\n#366, why 366 because apparently the OAD year had 366 days, I don't know how accurate this information is.\n\nfrom datetime import datetime, timedelta\ndef datenum_to_datetime(datenum):\n    \n    try:\n        days = datenum % 1\n        hours = days % 1 * 24\n        minutes = hours % 1 * 60\n        seconds = minutes % 1 * 60\n        exact_date = datetime.fromordinal(int(datenum)) \\\n           + timedelta(days=int(days)) \\\n           + timedelta(hours=int(hours)) \\\n           + timedelta(minutes=int(minutes)) \\\n           + timedelta(seconds=round(seconds)) \\\n           - timedelta(days=366)#(subtracting the 1year differnce fere form the total time )\n    \n        return exact_date.year#we only requuire year to calculate the age.\n    \n    except(ValueError, TypeError, OverflowError):\n        \n        return np.nan","f39a49f4":"#applying the datenum_to_datetime function on all our dataframes.\ndf_wiki['date_of_birth'] = df_wiki['dob'].apply(datenum_to_datetime) \ndf_imdb['date_of_birth'] = df_imdb['dob'].apply(datenum_to_datetime)\ndf_comb['date_of_birth'] = df_comb['dob'].apply(datenum_to_datetime)","75e1f4e9":"df_comb['age'] = df_comb['photo_taken'] - df_comb['date_of_birth']","92f0b149":"print(df_comb)\nprint(df_imdb)\nprint(df_wiki)","dcf06875":"#let us see the distribution plot for age, we can see there are some people who were borth in the 16th century and are still alive, I wonder if da\n#vinci is  also on this list, anyways we need to get rid of these \"outliers\"\nhistogram_age = df_comb['age'].hist(bins=df_comb['age'].nunique())\n#histogram_gender = df_comb['gender'].hist(bins=df_comb['gender'].nunique())","3aa48ca3":"#let us also see the gender distribution though it may not be that haphazart as it is only a binary variable.\nhistogram_gender = df_comb['gender'].hist(bins=df_comb['gender'].nunique())","9e3d72f8":"#so let us remove all the instances(rows) of the dataset that are greater than 100 and less than 0, so that we have 101 age classes varying from 0 \n#to 101.\ndf_comb = df_comb[df_comb['age'] <= 100]\ndf_comb = df_comb[df_comb['age'] >= 0]","91f6d112":"#Now it looks nice and the distribution though right skewed has a sort of \"normal appearnace\".But the plot is quite dull and we cannot even see \n#which age has the highest number of images associated with it, we need something that is more visually appealing and interactive.\nhistogram_age1 = df_comb['age'].hist(bins=df_comb['age'].nunique())","637647d2":"#As good as the above plots look, they are not very informative and we need something very infomrative and interactive and plotly and cufflinks\n#just provide us with the right thing\nimport numpy as np\nfrom plotly import __version__\n%matplotlib inline\n\nimport plotly.offline as pyo\nimport plotly.graph_objs as go\nfrom plotly.offline import iplot\n\nimport cufflinks as cf\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot \n\n\ncf.go_offline()","2c6afeef":"#if one happens to run plotly in colab, they need to execute this function and call it in every cell in which the plot is being plotted.\ndef enable_plotly_in_cell():\n  import IPython\n  from plotly.offline import init_notebook_mode\n  display(IPython.core.display.HTML('''<script src=\"\/static\/components\/requirejs\/require.js\"><\/script>'''))\n  init_notebook_mode(connected=False)","7e0d2aff":"#age distribution using plotly.\n#enable_plotly_in_cell()\ndf_comb[\"age\"].iplot(kind=\"histogram\", bins=101, theme=\"white\", title=\"age distribution\",xTitle='Ages', yTitle='Count')","0f4f59a7":"#gender distribution\ndf_comb[\"gender\"].iplot(kind=\"histogram\", bins=2, theme=\"white\", title=\"gender distribution\",xTitle='gender', yTitle='Count')","16297a12":"#pie chart for number of images for every age category.\n#enable_plotly_in_cell()\nfig = px.pie(df_comb, values='age', names='age', title='pie chart for all the ages')\nfig.show()","9857e1b8":"#age distribution as per gender\nenable_plotly_in_cell()\ndf_comb[\"male_age\"]=df_comb[df_comb[\"gender\"]==1][\"age\"]\ndf_comb[\"female_age\"]=df_comb[df_comb[\"gender\"]==0][\"age\"]\ndf_comb[[\"male_age\",\"female_age\"]].iplot(kind=\"histogram\", bins=101, theme=\"white\", title=\"age distribution by gender\",\n         xTitle='Ages', yTitle='Count')","e9f1a1b5":"df_comb","ebe6d164":"df_e = df_comb.drop(['dob','full_path','photo_taken'], axis=1)\ndf_e.fillna(0, inplace = True) \ndf_e.to_csv('file2.csv',encoding = 'utf-8') ","a0efd4ad":"#Answer to Question 2, number of people belonging to the age group of 15 to 25, although this is a general function which takes in the range of \n#age group in which the size of population is to be calculated.\ndef countofpeople(lower, upper,df):\n  count = 0\n  for i in df.age:\n    if lower <= i <= upper:\n      count = count + 1\n  print(count)","74eea39e":"#calling the above function.\ncountofpeople(15,25,df_comb)","df851755":"#seeing the age count.\ndf_comb['age'].value_counts()","55079087":"df = df_comb[(df_comb['age'] >= 15) & (df_comb['age'] <=25 )]\ndf\n","4a738a85":"#plotting the age distribution for the bucket 15 to 25.\n#enable_plotly_in_cell()\ndf[\"age\"].iplot(kind=\"histogram\", bins=20, theme=\"white\", title=\"age distribution between 15 and 25\",xTitle='Ages', yTitle='Count')","37d660be":"#pie chart of the above plot.\n#enable_plotly_in_cell()\nfig = px.pie(df, values='age',names = 'age' , title ='pie chart for the bucket between  ages 15 and 25')\nfig.show()","14e4c3d6":"#answer to question number 3\ndf_male_30 = df_comb[(df_comb['age'] == 30) & (df_comb['gender'] ==1 )]\nx = (len(df_male_30)\/len(df_comb))*100\nprint('The percentage of 30 year old males in the given population is {:.2f} percent'.format(x))","71d4ea4a":"df_male_30","eabb209d":"#downloading the dlib face detector module\nif not os.path.exists(os.path.abspath('.') + 'mmod_human_face_detector.dat.bz2'):\n    annotation_zip = tf.keras.utils.get_file('mmod_human_face_detector.dat.bz2',\n                            cache_subdir=os.path.abspath('.'),\n                            origin = \"http:\/\/dlib.net\/files\/mmod_human_face_detector.dat.bz2\")\n# Using pythons bz2 package to read the bz2 file in binary format and write it into a .dat file\nwith bz2.open(\"mmod_human_face_detector.dat.bz2\", \"rb\") as f:\n    content = f.read()\n\n    with open(\"mmod_human_face_detector.dat\", \"wb\") as weights_file:\n        weights_file.write(content)\n\nos.remove(annotation_zip)","b13d23e2":"#defining the variables to be used for dlib face detector\nmat = scipy.io.loadmat(annotation_folder+'\/'+mat_file)\ndata = mat[data_key]\nroute = data[0][0][2][0]\nname = []\nage = []\ngender = []\nimages = []\ntotal = 0","8444ead1":"#creating and implementing the dlib face detector on IMDBWIKI face dataset.\ncnn_face_detector = dlib.cnn_face_detection_model_v1(\"mmod_human_face_detector.dat\")\nplt.figure()\ni = 1\n\nwhile(i <= 4):\n    index = randint(0, len(route))\n    if((math.isnan(data[0][0][6][0][index]) == False and data[0][0][6][0][index] > 0)):\n        img = cv2.imread('wiki_crop\/'+data[0][0][2][0][index][0])\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        faces_cnn = cnn_face_detector(img, 1)\n\n        for face in faces_cnn:\n            offset_x , offset_y  = max(faces_cnn[0].rect.left(),0),max(faces_cnn[0].rect.top(),0)\n            target_width, target_height = faces_cnn[0].rect.right() - offset_x, faces_cnn[0].rect.bottom() - offset_y\n            target_width = min(target_width, img.shape[1]-offset_x)\n            target_height = min(target_height, img.shape[0]-offset_y)\n            # drawing box over the faces\n            face_img = tf.image.crop_to_bounding_box(img, \n                                                    offset_y, offset_x, \n                                                    target_height,target_width)\n            cv2.rectangle(img, (offset_x,offset_y), (offset_x+target_width,offset_y+target_height), (0,255,0), 2)\n            face_img = tf.image.resize(face_img, (32, 32), method=tf.image.ResizeMethod.BICUBIC, antialias=True)\n            face_img = tf.dtypes.cast(face_img, tf.int32)\n            # Plotting the images\n            plt.subplot(2, 2, i)\n            plt.imshow(img)\n            plt.title(data[0][0][4][0][index][0])\n            plt.subplot(2,2, i+1)\n            plt.imshow(face_img)\n            i += 2","a6b16ff2":"# IMDB-WIKI Face Dataset Analysis:\n1) Lets import the required libraries"}}