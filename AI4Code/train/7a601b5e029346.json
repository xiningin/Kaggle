{"cell_type":{"ce19b925":"code","4adfcf2c":"code","606c09c0":"code","94fe2452":"code","ee2b187f":"code","228a0890":"code","354d6f33":"code","d2323956":"code","1e63fcc9":"code","60d8bb5a":"code","5e385422":"code","3eb82f63":"markdown","66740293":"markdown"},"source":{"ce19b925":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\n","4adfcf2c":"import re\n##split the text file to be used as csv\ndef parse_txt_file(filepath, filename):\n    \"\"\"Parse the txt file containing image relative paths, name, and boxes data to a list \"\"\"\n    file = open(filepath + filename)\n    items = file.read().strip().split(\"\\n\")\n    item_regex = r'(^[\\w\\s]+\\\\(?:[\\w\\s]+\\\\)*G\\d+\\.bmp)\\s+(\\d+)\\s+((?:\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s*)+)'\n    \n    def parse_item(item):\n        match = re.match(item_regex, item)\n        img_path = match.group(1).replace('.bmp', '.JPG') #txt says bmp but images are actually jpg\n        img_name = re.search(r'G\\d+\\.JPG', img_path).group()\n        num_boxes = int(match.group(2))\n        values = re.findall(r'\\d+', match.group(3))\n        boxes = [tuple([ int(values[i*4+j]) for j in range(0,4)]) for i in range(0,num_boxes)]\n        \n        return img_name,num_boxes,boxes\n    \n    return [parse_item(item) for item in items]","606c09c0":"##the images are split into based on their number of boxes and their dimension\n\ntext_Extract=parse_txt_file('\/kaggle\/input\/nienaber-potholes-2-complex\/Dataset 2 (Complex)\/','complexTestFullSizeAllPotholes.txt')\ndf_data=pd.DataFrame(text_Extract)\ndf_data.columns=['Image','count','Dim']\ndf_data=df_data.explode('Dim')\ndf_data.reset_index(inplace=True,drop=True)\ndf_data.head()","94fe2452":"##splitting x,y,w,h seperately \ndummy=pd.DataFrame(df_data.Dim.tolist(), index= df_data.index)\ndf_data_2=pd.concat([df_data.drop('Dim',1),dummy],axis=1)\ndf_data_2.columns=['filename','count','xmin','ymin','w','h']\ndf_data_2['class']='pothole'\ndf_data_2.head()","ee2b187f":"##the box are converting into diagonal point xmax,ymax,xmin,ymin\ndf_data_2['xmax'] = df_data_2['xmin'] + df_data_2['w']\ndf_data_2['ymax'] = df_data_2['ymin'] + df_data_2['h']\ndf_data_2.head()","228a0890":"df_data_2.shape","354d6f33":"## write it to csv\ndf_data_2.to_csv('train.csv',index=False)","d2323956":"!pip install tensorflow-object-detection-api","1e63fcc9":"from __future__ import division\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\nimport os\nimport io\nimport pandas as pd\nimport tensorflow as tf\n\nfrom PIL import Image\nfrom object_detection.utils import dataset_util\nfrom collections import namedtuple, OrderedDict\n","60d8bb5a":"##label to index coversion , the label will be written as number and the text\ndef class_text_to_int(row_label):\n    if row_label == 'pothole':\n        return 1\n    else:\n        None\n\n\n\ndef split(df, group):\n    data = namedtuple('data', ['filename', 'object'])\n    gb = df.groupby(group)\n    return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]\n\n\n##each image is serialised, along with the parameters in the csv\ndef create_tf_example(group, path):\n    with tf.compat.v1.gfile.GFile(os.path.join(path, '{}'.format(group.filename)), 'rb') as fid:\n        encoded_jpg = fid.read()\n    encoded_jpg_io = io.BytesIO(encoded_jpg)\n    image = Image.open(encoded_jpg_io)\n\n    width, height = image.size\n\n    filename = group.filename.encode('utf8')\n    print(filename)\n    image_format = b'jpg'\n    xmins = []\n    xmaxs = []\n    ymins = []\n    ymaxs = []\n    classes_text = []\n    classes = []\n\n    for index, row in group.object.iterrows():\n        xmins.append(row['xmin'] \/ width)\n        xmaxs.append(row['xmax'] \/ width)\n        ymins.append(row['ymin'] \/ height)\n        ymaxs.append(row['ymax'] \/ height)\n        classes_text.append(row['class'].encode('utf8'))\n        classes.append(class_text_to_int(row['class']))\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature={\n        'image\/height': dataset_util.int64_feature(height),\n        'image\/width': dataset_util.int64_feature(width),\n        'image\/filename': dataset_util.bytes_feature(filename),\n        'image\/source_id': dataset_util.bytes_feature(filename),\n        'image\/encoded': dataset_util.bytes_feature(encoded_jpg),\n        'image\/format': dataset_util.bytes_feature(image_format),\n        'image\/object\/bbox\/xmin': dataset_util.float_list_feature(xmins),\n        'image\/object\/bbox\/xmax': dataset_util.float_list_feature(xmaxs),\n        'image\/object\/bbox\/ymin': dataset_util.float_list_feature(ymins),\n        'image\/object\/bbox\/ymax': dataset_util.float_list_feature(ymaxs),\n        'image\/object\/class\/text': dataset_util.bytes_list_feature(classes_text),\n        'image\/object\/class\/label': dataset_util.int64_list_feature(classes),\n    }))\n    return tf_example","5e385422":"###conversion to tfrecord\n\n##specify the directory where images are\nimage_dir='..\/input\/nienaber-potholes-2-complex\/Dataset 2 (Complex)\/Train data\/Positive data'\n\n##change the out file here\noutput_file_path='train.tfrecord'\nwriter = tf.compat.v1.python_io.TFRecordWriter(output_file_path)\n\n##read in the saved csv(uncomment below)\n# df_data_2=pd.read_csv('train.csv')\n\npath = os.path.join(image_dir)\n##group based on filename \ngrouped = split(df_data_2, 'filename')\n\nfile_errors = 0\n\n#files are written one at a time\nfor group in grouped:\n    try:\n        tf_example = create_tf_example(group, path)\n        writer.write(tf_example.SerializeToString())\n    except:\n\n        file_errors +=1\n        pass\n\nwriter.close()\n\nprint(\"FINISHED. There were %d errors\" %file_errors)","3eb82f63":"### TF record conversion","66740293":"### CSV file creation"}}