{"cell_type":{"220b114d":"code","d0d329da":"code","098c9b03":"code","b84834de":"code","5f3d1616":"code","32b01063":"code","d22125a1":"code","8ad053f2":"code","6f1da80f":"code","63d3f208":"code","2f3ed36c":"code","0aa021b0":"code","30ddcaf6":"code","a774f7f1":"code","7b520278":"code","efc39900":"code","36ab61be":"code","6d393b03":"code","e1e3cc5a":"code","c0dd1f38":"code","cd27f89a":"code","59fe7cfa":"code","25e10aba":"code","dca954cf":"code","5a5c63a2":"code","ee170bc7":"markdown","8ab70b10":"markdown","54fcd02f":"markdown","ffacab5c":"markdown","66117919":"markdown"},"source":{"220b114d":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np \nimport pandas as pd \nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings(\"ignore\")","d0d329da":"import pandas as pd \npinkFlam = pd.read_csv ('..\/input\/catch-the-pink-flamingo\/catchThePinkFlamingo.csv')\npinkFlam = pinkFlam.rename(columns=lambda x: x.strip()) #removes whitespaces from headers if exists","098c9b03":"#pinkFlam.fillna(pinkFlam.mean(), inplace=True)\nprint('Samples with Purchases : ' + str(pinkFlam['avg_price'].count()) + ' from  the total samples : ' + str(pinkFlam['userId'].count())) ","b84834de":"pinkFlam.info()","5f3d1616":"from matplotlib import pyplot\npd.DataFrame.hist(pinkFlam[['avg_price']])","32b01063":"plt.figure(figsize=(12,10), dpi= 80)\nsns.heatmap(pinkFlam.corr(), xticklabels=pinkFlam.corr().columns, yticklabels=pinkFlam.corr().columns, cmap='RdYlGn', center=0, annot=True)\n\n# Decorations\nplt.title('Correlogram of Pink Flamingo', fontsize=22)\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.show()","d22125a1":"corr = pinkFlam.corr()\ncorr","8ad053f2":"#Determine pivot table\nimpute_grps = pinkFlam.pivot_table(values=[\"avg_price\"], index=[\"platformType\",\"count_gameclicks\",\"count_hits\"], aggfunc=len) # default aggfunc=np.mean\nimpute_grps.head()","6f1da80f":"sns.catplot(x=\"avg_price\",y=\"platformType\",kind='box',data=pinkFlam)","63d3f208":"pinkFlam.replace(\"\", np.nan, inplace=True)\npinkFlam = pinkFlam[np.isfinite(pinkFlam['count_buyId'])]\npinkFlam['user_category'] = np.where(pinkFlam['avg_price']> 5, 'HighRollers', 'PennyPinchers')\npinkFlam.head()","2f3ed36c":"sns.scatterplot(x='platformType',y='count_gameclicks',hue='user_category',data=pinkFlam)","0aa021b0":"import seaborn as sns\nsns.countplot(x=\"platformType\", hue=\"user_category\", data=pinkFlam)","30ddcaf6":"# userId --> Since the objective is to predict which user is likely to purchase bigticket items, \n# and the attribute \u201cuserId\u201d has no effect on it, so it\u2019s removed.\n\n# userSessionId --> Since the objective is to predict which user is likely to purchase bigticket items, and the attribute \n# \u201cuserSessionId\u201d has no effect on it, so it\u2019s removed.\n\n# avg_price --> Since a new attribute \u201cuser_category\u201d has been created, which was\n# generated from the attribute \u201cavg_price\u201d, so we can remove it\npinkFlam = pinkFlam.drop(['userId' , 'userSessionId' , 'avg_price'], axis = 1)\npinkFlam.head()","a774f7f1":"sns.catplot(x=\"count_gameclicks\",y=\"platformType\",kind='box',data=pinkFlam)","7b520278":"sns.catplot(x=\"platformType\",y=\"count_hits\",kind='box',data=pinkFlam)","efc39900":"pinkFlam_Project_summary = pinkFlam.describe()\npinkFlam_Project_summary = pinkFlam_Project_summary.T\npinkFlam_Project_summary","36ab61be":"pinkFlam_grouped = pinkFlam.groupby ('platformType').mean()\npinkFlam_grouped","6d393b03":"from sklearn.preprocessing import LabelEncoder\nenc = LabelEncoder()\nlabel_encoder = enc.fit(pinkFlam['platformType'])\nprint (\"Categorical classes:\", label_encoder.classes_)\ninteger_classes = label_encoder.transform(label_encoder.classes_)\nprint (\"Integer classes:\", integer_classes)\nt = label_encoder.transform(pinkFlam['platformType'])\npinkFlam['EncPlatformType'] = t\n# pinkFlam[['OS1', 'OS2', 'OS3', 'OS4' , 'OS5']] = pd.get_dummies(pinkFlam['platformType'])","e1e3cc5a":"from sklearn import tree\nfrom sklearn.metrics import accuracy_score\nfrom sklearn import svm\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn import neighbors\n\nclf = tree.DecisionTreeClassifier()\n\nclf1 = svm.SVC()\nclf2 = GaussianNB()\nclf3 = neighbors.KNeighborsClassifier()\n\nX = pinkFlam[['teamLevel' ,'count_gameclicks' , 'count_hits','count_buyId' , 'EncPlatformType']][0:846]\n\nY = pinkFlam['user_category'][0:846]\n\n\n#CHALLENGE - ...and train them on our data\nclf = clf.fit(X , Y)\n\n#Support Vector classifier\nclf1 = clf1.fit(X,Y)\n\n#Naive Bayes\nclf2 = clf2.fit(X,Y)\n\n#K neighbors classifier\nclf3 = clf3.fit(X,Y)\n\n#test data\nX_test = pinkFlam[['teamLevel' ,'count_gameclicks' , 'count_hits','count_buyId' , 'EncPlatformType']][846:1411]\n\nY_test = pinkFlam['user_category'][846:1411]\n\n\nY_prediction  = clf.predict(X_test)\nY_prediction1 = clf1.predict(X_test)\nY_prediction2 = clf2.predict(X_test)\nY_prediction3 = clf3.predict(X_test)\n\n#CHALLENGE compare their reusults and print the best one!\n\nprint(\"Prediction for Naive Bayes : \",Y_prediction2)\n\nprint(\"Accuracy for Decision Tree : \",accuracy_score(Y_test,Y_prediction))\n\nprint(\"Accuracy for SVM : \",accuracy_score(Y_test,Y_prediction1))\n\nprint(\"Accuracy for K neighbors : \",accuracy_score(Y_test,Y_prediction3))","c0dd1f38":"Y_prediction  = clf.predict(X_test)\nnp.unique(Y_prediction)\npinkFlam_evaluation = pinkFlam[846:1411]\npinkFlam_evaluation['Predicted_UserCategory'] = Y_prediction\npinkFlam_evaluation[['Predicted_UserCategory' , 'user_category' ]] \ny_true = pinkFlam_evaluation['user_category'] \ny_pred = pinkFlam_evaluation['Predicted_UserCategory']","cd27f89a":"from sklearn.metrics import confusion_matrix\ntn, fp, fn, tp = confusion_matrix([0, 1, 0, 1], [1, 1, 1, 0]).ravel()","59fe7cfa":"import numpy as np\nunique_label = np.unique(y_true)\nprint(pd.DataFrame(confusion_matrix(y_true, y_pred, labels=unique_label), \n                   index=['true:{:}'.format(x) for x in unique_label], \n                   columns=['pred:{:}'.format(x) for x in unique_label]))","25e10aba":"cm = pd.DataFrame(confusion_matrix(y_true, y_pred, labels=unique_label), \n                   index=['true:{:}'.format(x) for x in unique_label], \n                   columns=['pred:{:}'.format(x) for x in unique_label])\n\nsns.heatmap(cm, annot=True,\n         fmt='.2f',\n         xticklabels = [\"Left\", \"No Left\"] , yticklabels = [\"Left\", \"No Left\"] )\n\nplt.ylabel('True User Category')\nplt.xlabel('Predicted User Category')","dca954cf":"pip install pydotplus","5a5c63a2":"# in commanda promopt : conda install -c conda-forge pydotplus or pip install pydotplus\nimport pydotplus as pdot\nfrom sklearn.tree import export_graphviz, export\n\nexport_graphviz( clf,\n              out_file = \"pinkFlamingo_tree.odt\",\n              feature_names = X.columns )\n\nchd_tree_graph = pdot.graphviz.graph_from_dot_file( 'pinkFlamingo_tree.odt' )\nchd_tree_graph.write_jpg( 'pinkFlamingo_tree.jpg' )\n\nfrom IPython.display import Image\nImage(filename='pinkFlamingo_tree.jpg')","ee170bc7":"We used \u201ccatchThePinkFlamingo.csv\u201d, and classified users with Decision Tree in Python to identify big spenders in the game. The objective is to predict which user is likely to purchase big-ticket items while playing game. Using the file \u201ccatchThePinkFlamingo.csv\u201d, we defined two categories for price: HighRollers, who spend more than 5.00 dollars  \nto buy the items, and PennyPinchers, who spend 5.00 dollars or less to buy the items. In this graph, red stands for the PennyPinchers, blue stands for the HighRollers.\n","8ab70b10":"# [B] Data Preparing For models","54fcd02f":"# [C] Predicitive analysis","ffacab5c":"# [A] Descriptive analysis","66117919":"**Recommendations**\n* Offer more products to iPhone users.\n* Offer some promotions to PennyPinchers for attracting their consommation.\n"}}