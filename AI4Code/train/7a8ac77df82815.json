{"cell_type":{"5435a073":"code","16c7d627":"code","8145a5de":"code","cf15f64e":"code","df03fbc0":"code","89435a56":"code","d9124a9b":"code","f3e8816e":"code","97f1a06f":"code","9356b0a4":"code","911bd90c":"code","841e2d76":"code","7e9e5df8":"code","af898140":"code","49629a9c":"code","f92a4af0":"code","9f3f5863":"code","8d08437b":"code","7def8975":"code","9390303b":"code","d811502b":"code","6468e8cc":"code","af8cece4":"code","1f97cf74":"code","763c63b0":"code","c3986028":"code","700bc636":"code","8eb239dd":"markdown","e30772a8":"markdown","0a5a2fc4":"markdown","1b346def":"markdown","6ed63c94":"markdown","d0a222ff":"markdown","2dcabd12":"markdown","855e29cc":"markdown","4dafaf81":"markdown","4db3db1b":"markdown","5f48cba8":"markdown","4bd09081":"markdown"},"source":{"5435a073":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","16c7d627":"import pandas_summary as ps\n\nfrom plotly.offline import init_notebook_mode, plot, iplot\nimport plotly.graph_objs as go\ninit_notebook_mode(connected=True)\n\nfrom surprise import Reader\nfrom surprise import Dataset\nfrom surprise.model_selection import cross_validate\nfrom surprise import SVD, SlopeOne, NMF\nfrom surprise.accuracy import rmse\nfrom surprise import accuracy\nfrom surprise.model_selection import train_test_split","8145a5de":"pd.set_option('display.max_rows', 500)\npd.set_option('display.max_columns', 500)","cf15f64e":"folder = '\/kaggle\/input\/anime-recommendations-database\/'\nanime_df = pd.read_csv(folder+'anime.csv')\nrate_df = pd.read_csv(folder+'rating.csv')","df03fbc0":"print('anime: ', anime_df.shape)\nprint('rating: ', rate_df.shape)","89435a56":"anime_df.head()","d9124a9b":"rate_df.head()","f3e8816e":"full_df = rate_df.merge(anime_df, how='left', left_on=['anime_id'], right_on=['anime_id'])\ndf = full_df[full_df['rating_x'] != -1]\ndf.head()","97f1a06f":"full_df.shape, df.shape","9356b0a4":"dfs = ps.DataFrameSummary(full_df)\nprint('categoricals: ', dfs.categoricals.tolist())\nprint('numerics: ', dfs.numerics.tolist())\ndfs.summary()","911bd90c":"dfs = ps.DataFrameSummary(df)\nprint('categoricals: ', dfs.categoricals.tolist())\nprint('numerics: ', dfs.numerics.tolist())\ndfs.summary()","841e2d76":"data = df['rating_x'].value_counts().sort_index(ascending=False)\ntrace = go.Bar(x = data.index,\n               text = ['{:.1f} %'.format(val) for val in (data.values \/ df.shape[0] * 100)],\n               textposition = 'auto',\n               textfont = dict(color = '#000000'),\n               y = data.values,\n               )\nlayout = dict(title = 'Distribution Of {} anime-ratings'.format(df.shape[0]),\n              xaxis = dict(title = 'Rating'),\n              yaxis = dict(title = 'Count'))\nfig = go.Figure(data=[trace], layout=layout)\niplot(fig)","7e9e5df8":"data = df.groupby('user_id')['rating_x'].count().clip(upper=250)\n\ntrace = go.Histogram(x = data.values,\n                     name = 'Ratings',\n                     xbins = dict(start = 0,\n                                  end = 250,\n                                  size = 2))\nlayout = go.Layout(title = 'Distribution Of Number of Ratings Per User (Clipped at 250)',\n                   xaxis = dict(title = 'Ratings Per User'),\n                   yaxis = dict(title = 'Count'),\n                   bargap = 0.2)\n\nfig = go.Figure(data=[trace], layout=layout)\niplot(fig)","af898140":"data = df.groupby('anime_id')['rating_x'].count().clip(upper=250)\n\ntrace = go.Histogram(x = data.values,\n                     name = 'Ratings',\n                     xbins = dict(start = 0,\n                                  end = 250,\n                                  size = 2))\nlayout = go.Layout(title = 'Distribution Of Number of Ratings Per anime_id (Clipped at 250)',\n                   xaxis = dict(title = 'Ratings Per anime_id'),\n                   yaxis = dict(title = 'Count'),\n                   bargap = 0.2)\n\nfig = go.Figure(data=[trace], layout=layout)\niplot(fig)","49629a9c":"data = df.groupby('genre')['rating_x'].count().clip(upper=250)\n\ntrace = go.Histogram(x = data.values,\n                     name = 'Ratings',\n                     xbins = dict(start = 0,\n                                  end = 250,\n                                  size = 2))\nlayout = go.Layout(title = 'Distribution Of Number of Ratings Per Anime (Clipped at 250)',\n                   xaxis = dict(title = 'Number of Ratings Per Anime'),\n                   yaxis = dict(title = 'Count'),\n                   bargap = 0.2)\n\nfig = go.Figure(data=[trace], layout=layout)\niplot(fig)","f92a4af0":"min_anime_ratings = 250\nfilter_anime = df['anime_id'].value_counts() > min_anime_ratings\nfilter_anime = filter_anime[filter_anime].index.tolist()\n\nmin_user_ratings = 250\nfilter_users = df['user_id'].value_counts() > min_user_ratings\nfilter_users = filter_users[filter_users].index.tolist()\n\ndf_new = df[(df['anime_id'].isin(filter_anime)) & (df['user_id'].isin(filter_users))]\nprint('The original data frame shape:\\t{}'.format(df.shape))\nprint('The new data frame shape:\\t{}'.format(df_new.shape))","9f3f5863":"reader = Reader(rating_scale=(0, 10))\ndata = Dataset.load_from_df(df_new[['user_id', 'anime_id', 'rating_x']], reader)","8d08437b":"benchmark = []\nfor algorithm in [SVD(biased=False), SlopeOne(), NMF()]:\n    results = cross_validate(algorithm, data, measures=['RMSE'], cv=5, verbose=False)\n    \n    tmp = pd.DataFrame.from_dict(results).mean(axis=0)\n    tmp = tmp.append(pd.Series([str(algorithm).split(' ')[0].split('.')[-1]], index=['Algorithm']))\n    benchmark.append(tmp)","7def8975":"%time\nsurprise_results = pd.DataFrame(benchmark).set_index('Algorithm').sort_values('test_rmse')","9390303b":"surprise_results","d811502b":"%time\nalgo = SVD(biased=False)\ncross_validate(algo, data, measures=['RMSE'], cv=5, verbose=False)","6468e8cc":"%time\ntrainset, testset = train_test_split(data, test_size=0.25)\nalgo = SVD()\npredictions = algo.fit(trainset).test(testset)\naccuracy.rmse(predictions)","af8cece4":"def get_Iu(uid):\n    try:\n        return len(trainset.ur[trainset.to_inner_uid(uid)])\n    except ValueError: \n        return 0\n    \ndef get_Ui(iid):\n    try: \n        return len(trainset.ir[trainset.to_inner_iid(iid)])\n    except ValueError:\n        return 0\n    \ndf_ = pd.DataFrame(predictions, columns=['uid', 'iid', 'rui', 'est', 'details'])\ndf_['Iu'] = df_.uid.apply(get_Iu)\ndf_['Ui'] = df_.iid.apply(get_Ui)\ndf_['err'] = abs(df_.est - df_.rui)","1f97cf74":"df_.head()","763c63b0":"%time\ndata_pred = []\nfor row in full_df[full_df['rating_x'] == -1].itertuples():\n    tmp_pred = algo.predict(row[1], row[2])\n    data_pred.append((tmp_pred[0], tmp_pred[1], round(tmp_pred[3], 2)))\ndata_pred = pd.DataFrame(data_pred, columns=['user_id', 'anime_id', 'rating'])","c3986028":"data_pred.head()","700bc636":"data_pred.to_csv('submission.csv', index=False)","8eb239dd":"# Predict","e30772a8":"### Recommendations for: https:\/\/www.kaggle.com\/CooperUnion\/anime-recommendations-database","0a5a2fc4":"# EDA","1b346def":"### SVD algorithm showed the best test rmse","6ed63c94":"![SVD.png](attachment:SVD.png)","d0a222ff":"# Cross Validation & Algorithm selection","2dcabd12":"SVD cannot be directly applied, since there are a lot of missing values (more precisely, you can somehow fill them out, but the quality is not very good).\nTherefore, the optimization problem is formulated according to well-known estimates $K$:\n\n$$ min_{p, q} \\sum_{u,i \\in K} (r_{ui} - q_i^T p_u)^2 + \\lambda (||q_i||^2 + ||p_u||^2)$$","855e29cc":"# Clip it","4dafaf81":"# Import","4db3db1b":"# Fit","5f48cba8":"For any user, you can predict ratings that he has not yet set. You need to train the model so that it gives the smallest errors for already known models.\n\nPrediction is the scalar product of a vector for a user and a vector for an object.\n\nWith this approach, much less model parameters need to be trained.","4bd09081":"A recommender system, or a recommendation system, is a subclass of information filtering system that seeks to predict the \"rating\" or \"preference\" a user would give to an item. They are primarily used in commercial applications.\n\nRecommender systems are utilized in a variety of areas and are most commonly recognized as playlist generators for video and music services like Netflix, YouTube and Spotify, product recommenders for services such as Amazon, or content recommenders for social media platforms such as Facebook and Twitter. These systems can operate using a single input, like music, or multiple inputs within and across platforms like news, books, and search queries. There are also popular recommender systems for specific topics like restaurants and online dating. Recommender systems have also been developed to explore research articles and experts, collaborators, and financial services."}}