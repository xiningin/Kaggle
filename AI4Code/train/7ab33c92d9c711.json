{"cell_type":{"130b6e0d":"code","bdc7b5c8":"code","fbc722a9":"code","7d433b87":"code","06845abb":"code","93b25bf2":"markdown"},"source":{"130b6e0d":"import matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nfrom sklearn.utils import shuffle\nfrom keras.models import Sequential\nfrom keras import layers\nfrom keras.layers import Input, Dense, Activation, ZeroPadding2D, Flatten, Conv2D\nfrom keras.layers import MaxPooling2D, Dropout\nfrom sklearn.model_selection import KFold\nfrom keras.models import Model\nfrom PIL import Image\nimport cv2\nimport IPython\n","bdc7b5c8":"print(os.listdir('..\/input'))","fbc722a9":"# load all images in a directory\n\nphoto_array=[]\ntarget=[]\nsize=100\nfrom os import listdir\nfrom matplotlib import image\nloaded_images = list()\nfor filename in listdir('..\/input\/dogcat\/dogcat\/trainA'):\n    image = Image.open('..\/input\/dogcat\/dogcat\/trainA\/' + filename)\n    img_resized = np.array(image.resize((size,size)))\n    photo_array.append(img_resized) \n    target.append(0)\nfor filename in listdir('..\/input\/dogcat\/dogcat\/trainB'):\n    image = Image.open('..\/input\/dogcat\/dogcat\/trainB\/' + filename)\n    img_resized = np.array(image.resize((size,size)))\n    photo_array.append(img_resized) \n    target.append(1)\n    \nfor filename in listdir('..\/input\/dogcat\/dogcat\/testA'):\n    image = Image.open('..\/input\/dogcat\/dogcat\/testA\/' + filename)\n    img_resized = np.array(image.resize((size,size)))\n    photo_array.append(img_resized)  \n    target.append(0)\n    \nfor filename in listdir('..\/input\/dogcat\/dogcat\/testB'):\n    image = Image.open('..\/input\/dogcat\/dogcat\/testB\/' + filename)\n    img_resized = np.array(image.resize((size,size)))\n    photo_array.append(img_resized) \n    target.append(1)\n    \nX=np.array(photo_array)\ny=np.array(target)\nX=X[:,:,:,:]\/255","7d433b87":"X,y=shuffle(X,y,random_state=44)","06845abb":"kfold = KFold(n_splits=10, shuffle=False, random_state=22)\ncvscores = []\nfor train, test in kfold.split(X, y):\n    size=X.shape[1]\n    model = Sequential()\n    model.add(ZeroPadding2D(2, input_shape=(size, size, 3)))\n    model.add(Conv2D(32, (7, 7),strides=(1, 1),padding=\"valid\", kernel_initializer='random_uniform',\n                bias_initializer='zeros',activation=\"relu\"))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Conv2D(64, (3, 3),strides=(1, 1),padding=\"valid\", activation=\"relu\"))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Conv2D(128, (3,3),strides=(1, 1),padding=\"valid\", activation=\"relu\"))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.2))\n    model.add(Conv2D(256, (1,1),strides=(1, 1),padding=\"valid\", activation=\"relu\"))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.2))\n    model.add(Flatten())\n    model.add(Dense(1, activation=\"sigmoid\")) \n    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n    model.fit(X[train], y[train],batch_size = 128, epochs=30,verbose=0 )\n    scores = model.evaluate(X[test], y[test], verbose=0)\n    print(\"%s: %.2f%%\" % (model.metrics_names[1], scores[1]*100))\n    cvscores.append(scores[1] * 100)\nprint(\"%.2f%% (+\/- %.2f%%)\" % (np.mean(cvscores), np.std(cvscores)))    ","93b25bf2":"## Conclusion\nThe model classifies images with average accuracy of 83%. "}}