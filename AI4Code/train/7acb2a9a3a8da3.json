{"cell_type":{"043dd5eb":"code","90dd6696":"code","5b3dde80":"code","323c6752":"code","2d0a4af9":"code","c0f6fd8c":"code","c21e50e1":"code","462f523b":"code","617b2137":"code","159a0dfd":"code","8e44b591":"code","f5ff1873":"code","1b2f67e3":"code","df485bd3":"code","00c41189":"markdown","b21b161a":"markdown"},"source":{"043dd5eb":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_auc_score\n\n# instantiate labelencoder object\nle = LabelEncoder()\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n","90dd6696":"# function used from this notebook - kaggle.com\/sunilsj99\/fraud-detection-ieee\/notebook\n\ndef reduce_mem_usage(props):\n    start_mem_usg = props.memory_usage().sum() \/ 1024**2 \n    print(\"Memory usage of properties dataframe is :\",start_mem_usg,\" MB\")\n    NAlist = [] # Keeps track of columns that have missing values filled in. \n    for col in props.columns:\n        if props[col].dtype != object:  # Exclude strings\n            \n            # Print current column type\n#             print(\"******************************\")\n#             print(\"Column: \",col)\n#             print(\"dtype before: \",props[col].dtype)\n            \n            # make variables for Int, max and min\n            IsInt = False\n            mx = props[col].max()\n            mn = props[col].min()\n            \n            # Integer does not support NA, therefore, NA needs to be filled\n            if not np.isfinite(props[col]).all(): \n                NAlist.append(col)\n                props[col].fillna(mn-1,inplace=True)  \n                   \n            # test if column can be converted to an integer\n            asint = props[col].fillna(0).astype(np.int64)\n            result = (props[col] - asint)\n            result = result.sum()\n            if result > -0.01 and result < 0.01:\n                IsInt = True\n\n            \n            # Make Integer\/unsigned Integer datatypes\n            if IsInt:\n                if mn >= 0:\n                    if mx < 255:\n                        props[col] = props[col].astype(np.uint8)\n                    elif mx < 65535:\n                        props[col] = props[col].astype(np.uint16)\n                    elif mx < 4294967295:\n                        props[col] = props[col].astype(np.uint32)\n                    else:\n                        props[col] = props[col].astype(np.uint64)\n                else:\n                    if mn > np.iinfo(np.int8).min and mx < np.iinfo(np.int8).max:\n                        props[col] = props[col].astype(np.int8)\n                    elif mn > np.iinfo(np.int16).min and mx < np.iinfo(np.int16).max:\n                        props[col] = props[col].astype(np.int16)\n                    elif mn > np.iinfo(np.int32).min and mx < np.iinfo(np.int32).max:\n                        props[col] = props[col].astype(np.int32)\n                    elif mn > np.iinfo(np.int64).min and mx < np.iinfo(np.int64).max:\n                        props[col] = props[col].astype(np.int64)    \n            \n            # Make float datatypes 32 bit\n            else:\n                props[col] = props[col].astype(np.float32)\n            \n            # Print new column type\n#             print(\"dtype after: \",props[col].dtype)\n#             print(\"******************************\")\n    \n    # Print final result\n    print(\"___MEMORY USAGE AFTER COMPLETION:___\")\n    mem_usg = props.memory_usage().sum() \/ 1024**2 \n    print(\"Memory usage is: \",mem_usg,\" MB\")\n    print(\"This is \",100*mem_usg\/start_mem_usg,\"% of the initial size\")\n    return props","5b3dde80":"train_identity = pd.read_csv(\"\/kaggle\/input\/ieee-fraud-detection\/train_identity.csv\", index_col='TransactionID')\ntrain_transaction = pd.read_csv(\"\/kaggle\/input\/ieee-fraud-detection\/train_transaction.csv\", index_col='TransactionID')\ntest_identity = pd.read_csv(\"\/kaggle\/input\/ieee-fraud-detection\/test_identity.csv\", index_col='TransactionID')\ntest_transaction = pd.read_csv(\"\/kaggle\/input\/ieee-fraud-detection\/test_transaction.csv\", index_col='TransactionID')\n\n\n# let's combine the data and work with the whole dataset\ntrain = pd.merge(train_transaction, train_identity, on='TransactionID', how='left')\ntest = pd.merge(test_transaction, test_identity, on='TransactionID', how='left')\n\nprint(f'Train dataset has {train.shape[0]} rows and {train.shape[1]} columns.')\nprint(f'Test dataset has {test.shape[0]} rows and {test.shape[1]} columns.')","323c6752":"del train_identity, train_transaction, test_identity, test_transaction","2d0a4af9":"train = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)","c0f6fd8c":"null_percent = (train.isnull().sum()\/train.shape[0])*100\ncolumns_to_drop = np.array(null_percent[null_percent > 50].index)\n\ncolumns_to_drop","c21e50e1":"# Drop columns \n\ntrain.drop(columns_to_drop, axis=1, inplace=True)\n\nprint(train.shape)\n","462f523b":"# Fill columns with null values\nnull_percent = (train.isnull().sum()\/train.shape[0])*100\ncolumns_to_fill = np.array(null_percent[null_percent > 0].index) \ncolumns_to_fill","617b2137":"# Fill columns with mode value (because all are categorical feautres i.e. dtype=object)\n\nfor i in columns_to_fill:\n    train[i] = train[i].replace(np.nan, train[i].mode()[0])\n    test[i]  = test[i].replace(np.nan, test[i].mode()[0])","159a0dfd":"cat_data = train.select_dtypes(include='object')\ncat_cols = cat_data.columns.values\ncat_cols","8e44b591":"train[cat_cols] = train[cat_cols].apply(lambda col: le.fit_transform(col))\ntrain","f5ff1873":"X_train = train.drop('isFraud', axis=1)\ny_train = train['isFraud']\n\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size = 0.25, random_state=42)\n\nprint(X_train.shape)\nprint(X_val.shape)","1b2f67e3":"model = RandomForestClassifier(\n    max_depth=20, \n    min_samples_leaf=4,\n    min_samples_split=10, \n    max_features='sqrt',\n    n_jobs=-1, \n    n_estimators=600\n)\n\nmodel.fit(X_train, y_train)\n\nprint(roc_auc_score(y_val,model.predict_proba(X_val)[:,1] ))","df485bd3":"N = 10\nimportances = model.feature_importances_\nstd = np.std([tree.feature_importances_ for tree in model.estimators_],\n             axis=0)\n\n# create a dataframe\nimportances_df = pd.DataFrame({'variable':X_train.columns, 'importance': importances})\n\ntop_N = importances_df.sort_values(by=['importance'], ascending=False).head(N)\n\ntop_N","00c41189":"## Random Forest Classifier","b21b161a":"## Categorical Data"}}