{"cell_type":{"64aa2b81":"code","3fb53806":"code","88c8a311":"code","6cb558bb":"code","dc4ad548":"code","80ff7ca3":"code","d440ef65":"code","7ad1e338":"code","334715ef":"code","ccb706cd":"code","f1d19823":"code","1ed958e6":"code","76a0f508":"code","3775fe26":"code","43f287b7":"code","e92bb940":"code","a084ecad":"code","ffc86a5b":"code","a1306f3f":"code","69eb61db":"code","b63b0d14":"code","455086f0":"code","0b4a0dfe":"code","1cfd7247":"code","600e7d4d":"code","9d067a5a":"code","472745e7":"code","d4751674":"code","b30646bb":"code","32785c98":"code","43dcded8":"code","603291ee":"code","242da5f9":"code","17762f00":"code","dcb4d91c":"markdown","f07bbd71":"markdown","17c4fbd0":"markdown","70dd7940":"markdown","631c2092":"markdown","479e2a01":"markdown","5141dff2":"markdown","51b507f9":"markdown","0f47ffa4":"markdown","f0811152":"markdown","6a7d40e7":"markdown","21e5d928":"markdown","4247c827":"markdown","db52803b":"markdown","b2b346f8":"markdown","09b36662":"markdown","7e8fe2d7":"markdown","5f03d644":"markdown","9927c5b0":"markdown","e2ef4693":"markdown","4090acfa":"markdown","7f26f358":"markdown","2b19d19a":"markdown","94b77819":"markdown","e733964b":"markdown","27f29dbf":"markdown","aceb5f21":"markdown","ec16aa36":"markdown","a6462f71":"markdown","4c339f7e":"markdown","e8bb697e":"markdown","b595fb31":"markdown","7f90e179":"markdown","f1b04cef":"markdown","e5c1fd13":"markdown","db4f5321":"markdown","8f0def8f":"markdown","7c33aa0c":"markdown","844db609":"markdown"},"source":{"64aa2b81":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import norm,skew\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.ensemble import RandomForestRegressor , GradientBoostingRegressor , StackingRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.svm import SVR\nfrom sklearn.linear_model import Ridge,Lasso,LinearRegression\nfrom sklearn.model_selection import KFold,cross_val_score, GridSearchCV\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom xgboost import XGBRegressor\nimport warnings\nwarnings.filterwarnings(\"ignore\")","3fb53806":"train = pd.read_csv(\"..\/input\/house-prices-advanced-regression-techniques\/train.csv\")\ntest = pd.read_csv(\"..\/input\/house-prices-advanced-regression-techniques\/test.csv\")","88c8a311":"print(\"Dimensions of train set are:-\",train.shape[0],\",\",train.shape[1])\nprint(\"Dimensions of test set are:-\",test.shape[0],\",\",test.shape[1])","6cb558bb":"pd.set_option(\"display.max_columns\",81)","dc4ad548":"train.head()","80ff7ca3":"corr = train.corr()","d440ef65":"corr[\"SalePrice\"].sort_values(ascending=False)","7ad1e338":"x=corr[\"SalePrice\"].sort_values(ascending=False)[:11].index\nmask = np.zeros_like(corr.loc[x,x])\nmask[np.triu_indices_from(mask)]=True\n\nsns.heatmap(corr.loc[x,x],mask=mask,annot=True,cmap=\"coolwarm\")","334715ef":"sns.pairplot(train[x[0:6]],x_vars=list(x[1:6]),y_vars=[x[0]],diag_kind=\"kde\")","ccb706cd":"f,ax = plt.subplots(1,2,figsize=(15,8))\nsns.boxplot(\"OverallQual\",\"SalePrice\",data=train,ax=ax[0])\nsns.boxplot(\"GarageCars\",\"SalePrice\",data=train,ax=ax[1])","f1d19823":"index = len(train)\ny=train[\"SalePrice\"]\ntrain.drop(\"SalePrice\",axis=1,inplace=True)\ndataset = pd.concat([train,test]).reset_index(drop=True)","1ed958e6":"dataset.isnull().sum()[dataset.isnull().sum()>0].sort_values(ascending=False)","76a0f508":"df_mszon=dataset.groupby([\"Neighborhood\",\"MSZoning\"])[\"Id\"].count().reset_index().groupby([\"Neighborhood\"])\nmaximum_mszon = df_mszon.max()\nmaximum_mszon= maximum_mszon.drop(\"Id\",axis=1)\n\nmax_dict_mszon = maximum_mszon.to_dict()\ndef mapper_mszon(x):\n    for index,val in zip(max_dict_mszon,max_dict_mszon.values()):\n        for index1,val1 in val.items():\n            if(x==index1):\n                return val1\n\ndataset.loc[dataset[\"MSZoning\"].isnull(),\"MSZoning\"] = dataset.loc[dataset[\"MSZoning\"].isnull(),\"Neighborhood\"].apply(lambda x: mapper_mszon(x))","3775fe26":"df_lotf=dataset.groupby([\"Neighborhood\",\"LotConfig\"])[\"LotFrontage\"].mean()\n\nmax_dict_lotf = df_lotf.to_dict()\ndef mapper_lotf(x1,x2):\n    for index,val in zip(max_dict_lotf,max_dict_lotf.values()):\n        if((x1==index[0]) & (x2==index[1])):\n            return val\n\ndataset.loc[dataset[\"LotFrontage\"].isnull(),\"LotFrontage\"] = dataset.loc[dataset[\"LotFrontage\"].isnull(),[\"Neighborhood\",\"LotConfig\"]].apply(lambda x: mapper_lotf(x[0],x[1]),axis=1)\ndataset[\"LotFrontage\"] = dataset.groupby([\"Neighborhood\"])[\"LotFrontage\"].transform(lambda x: x.median())","43f287b7":"dataset[\"Alley\"].fillna(\"NA\",inplace=True)\ndataset[\"Utilities\"].fillna(\"NA\",inplace=True)\ndataset[\"Exterior1st\"].fillna(\"NA\",inplace=True)\ndataset[\"Exterior2nd\"].fillna(\"NA\",inplace=True)\ndataset[\"MasVnrType\"].fillna(\"NA\",inplace=True)\ndataset[\"MasVnrArea\"].fillna(0,inplace=True)\ndataset[\"BsmtQual\"].fillna(\"NA\",inplace=True)\ndataset[\"BsmtCond\"].fillna(\"NA\",inplace=True)\ndataset[\"BsmtExposure\"].fillna(\"No\",inplace=True)\ndataset[\"BsmtFinType1\"].fillna(\"NA\",inplace=True)\ndataset[\"BsmtFinSF1\"].fillna(0,inplace=True)\ndataset[\"BsmtFinType2\"].fillna(\"NA\",inplace=True)\ndataset[\"BsmtFinSF2\"].fillna(0,inplace=True)\ndataset[\"BsmtUnfSF\"].fillna(0,inplace=True)\ndataset[\"TotalBsmtSF\"].fillna(0,inplace=True)\ndataset[\"BsmtFullBath\"].fillna(0,inplace=True)\ndataset[\"BsmtHalfBath\"].fillna(0,inplace=True)\ndataset[\"FireplaceQu\"].fillna(\"NA\",inplace=True)\ndataset[\"GarageType\"].fillna(\"NA\",inplace=True)\ndataset[\"GarageYrBlt\"].fillna(0,inplace=True)\ndataset[\"GarageFinish\"].fillna(\"NA\",inplace=True)\ndataset[\"GarageCars\"].fillna(0,inplace=True)\ndataset[\"GarageArea\"].fillna(0,inplace=True)\ndataset[\"GarageQual\"].fillna(\"NA\",inplace=True)\ndataset[\"GarageCond\"].fillna(\"NA\",inplace=True)\ndataset[\"PoolQC\"].fillna(\"NA\",inplace=True)\ndataset[\"Fence\"].fillna(\"NA\",inplace=True)\ndataset[\"MiscFeature\"].fillna(\"NA\",inplace=True)","e92bb940":"dataset[\"Functional\"].fillna(\"Typ\",inplace=True)\ndataset[\"Electrical\"].fillna(dataset[\"Electrical\"].mode()[0],inplace=True)\ndataset[\"KitchenQual\"].fillna(dataset[\"KitchenQual\"].mode()[0],inplace=True)\ndataset[\"SaleType\"].fillna(\"Oth\",inplace=True)","a084ecad":"dataset[\"MSSubClass\"]=dataset[\"MSSubClass\"].astype(\"category\")","ffc86a5b":"x=sns.distplot(y)\nx.set_title(\"Distribution plot for Sale Price\")","a1306f3f":"x=sns.distplot(np.log1p(y),fit=norm)\nx.set_title(\"Distribution plot for Sale Price\")","69eb61db":"y= np.log1p(y)","b63b0d14":"dataset = dataset.replace({\"Alley\" : {\"Grvl\" : 1, \"Pave\" : 2,\"NA\":0},\n                       \"BsmtCond\" : {\"NA\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \"Gd\" : 4, \"Ex\" : 5},\n                       \"BsmtExposure\" : {\"No\" : 0, \"Mn\" : 1, \"Av\": 2, \"Gd\" : 3},\n                       \"BsmtQual\" : {\"NA\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\": 3, \"Gd\" : 4, \"Ex\" : 5},\n                       \"ExterCond\" : {\"Po\" : 1, \"Fa\" : 2, \"TA\": 3, \"Gd\": 4, \"Ex\" : 5},\n                       \"ExterQual\" : {\"Po\" : 1, \"Fa\" : 2, \"TA\": 3, \"Gd\": 4, \"Ex\" : 5},\n                       \"FireplaceQu\" : {\"NA\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \"Gd\" : 4, \"Ex\" : 5},\n                       \"Functional\" : {\"Sal\" : 1, \"Sev\" : 2, \"Maj2\" : 3, \"Maj1\" : 4, \"Mod\": 5, \n                                       \"Min2\" : 6, \"Min1\" : 7, \"Typ\" : 8},\n                       \"GarageCond\" : {\"NA\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \"Gd\" : 4, \"Ex\" : 5},\n                       \"GarageQual\" : {\"NA\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \"Gd\" : 4, \"Ex\" : 5},\n                       \"GarageFinish\" : {\"Fin\" : 3, \"RFn\" : 2, \"Unf\" : 1, \"NA\" : 0},\n                       \"HeatingQC\" : {\"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \"Gd\" : 4, \"Ex\" : 5},\n                       \"KitchenQual\" : {\"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \"Gd\" : 4, \"Ex\" : 5},\n                       \"PavedDrive\" : {\"N\" : 0, \"P\" : 1, \"Y\" : 2},\n                       \"PoolQC\" : {\"NA\" : 0, \"Fa\" : 1, \"TA\" : 2, \"Gd\" : 3, \"Ex\" : 4},\n                       \"Street\" : {\"Grvl\" : 1, \"Pave\" : 2, \"NA\":0},\n                       \"Utilities\" : {\"ELO\" : 1, \"NASeWa\" : 2, \"NASewr\" : 3, \"AllPub\" : 4}}\n                     )","455086f0":"cats = [\"basement_flag\",\"fire_flag\",\"wooddeck_flag\",\"garage_flag\",\"pool_flag\",\"fence_flag\"]\ndataset[\"basement_flag\"]=np.where(dataset[\"TotalBsmtSF\"]>0,1,0)\ndataset[\"fire_flag\"]=np.where(dataset[\"Fireplaces\"]>0,1,0)\ndataset[\"wooddeck_flag\"]=np.where(dataset[\"WoodDeckSF\"]>0,1,0)\ndataset[\"garage_flag\"]=np.where(dataset[\"GarageArea\"]>0,1,0)\ndataset[\"porch_flag\"]=np.where((dataset[\"OpenPorchSF\"]+dataset[\"EnclosedPorch\"]+dataset[\"3SsnPorch\"]\\\n                                +dataset[\"ScreenPorch\"])>0,1,0)\ndataset[\"pool_flag\"] = np.where(dataset[\"PoolArea\"]>0,1,0)\ndataset[\"fence_flag\"] = np.where(dataset[\"Fence\"]==\"NA\",1,0)\ndataset[cats]=dataset[cats].astype(\"category\")","0b4a0dfe":"dataset['TotalSF'] = dataset['TotalBsmtSF'] + dataset['1stFlrSF'] + dataset['2ndFlrSF']","1cfd7247":"outlier_features = [\"GrLivArea\",\"TotalSF\",\"GarageArea\"]\n\nmeans,sds = np.mean(dataset[outlier_features]),np.std(dataset[outlier_features])\nlower,upper = means - 2.5*sds , means + 2.5*sds\ndef compare(x):\n    count=0\n    for col in outlier_features:\n        if x[col]>lower[col] and x[col]<upper[col]:\n            count=count+1\n    if count==len(outlier_features):\n        return True\n    else: \n        return False\n\ny= y.array\nsub_data = dataset.loc[:index-1]  \ntest_1 = dataset.loc[index:,:]\n\ndata_train_new = sub_data.loc[sub_data.apply(lambda x: compare(x),axis=1)]\ny= y[sub_data.apply(lambda x: compare(x),axis=1)]\n\nindex = len(data_train_new)\ndataset = pd.concat([data_train_new,test_1]).reset_index(drop=True)","600e7d4d":"numeric_feats = dataset.dtypes[(dataset.dtypes != \"object\") & (dataset.dtypes != \"category\")].index\nskewed_feats = dataset[numeric_feats].apply(lambda x: skew(x)).sort_values(ascending=False)\nskewness = pd.DataFrame({'Skew' :skewed_feats})\nskewness = skewness[abs(skewness) > 0.5]\n\nskewed_features = skewness.index\ndataset[skewed_features] = np.log1p(dataset[skewed_features])","9d067a5a":"dataset.drop(\"Id\",axis=1,inplace=True)","472745e7":"dataset = pd.get_dummies(dataset, drop_first= True)\ntrain_1 = dataset.loc[:index-1,:]\ntest_1 = dataset.loc[index:,:]","d4751674":"from sklearn.model_selection import train_test_split\nX_train,X_test,y_train,y_test = train_test_split(train_1,y,test_size=0.2, random_state=42)","b30646bb":"from sklearn.preprocessing import RobustScaler\nrs = RobustScaler()\nX_train= rs.fit_transform(X_train)\nX_test = rs.transform(X_test)\nX_submit = rs.transform(test_1.values)","32785c98":"kf = KFold(n_splits=10,shuffle=True,random_state=42)\nrf = RandomForestRegressor(n_estimators=500)\nxgb = XGBRegressor()\ngb= GradientBoostingRegressor()\nsvr =SVR(C=70,epsilon=.115)\nridge = Ridge(alpha=1.75,solver =\"lsqr\")\nlasso = Lasso(alpha=.0009)\n\nclf=[\\\n     (\"XGBoost\",xgb,{\"n_estimators\":[200],\"max_depth\":[3],\"learning_rate\":[.1],\"subsample\":[1],\"colsample_bytree\":[1],\"gamma\":[0],\"lambda\":[.001,.01]})\\\n     ,(\"Gradient Boost\",gb,{})\\\n     ,(\"SVR\",svr,{\"C\":[60,65,70,75,80],\"epsilon\":[.11,.115,.12]})\\\n    ,(\"Ridge\",ridge,{\"alpha\":[1.4,1.5,1.6,1.75,1.8]})\\\n     ,(\"Lasso\",lasso,{\"alpha\":[.0005,.0006,.0007,.001,.01,.1]})]\n\nest=[]\nresults_data=pd.DataFrame(columns=[\"Name\",\"Train_Score\",\"Test_Score\"])\n\ni=0\nfor name,reg,param_grid in clf:\n    gs= GridSearchCV(reg,param_grid=param_grid,cv=kf,scoring=\"neg_mean_squared_error\")\n    gs.fit(X_train,y_train)\n    y_pred = gs.best_estimator_.predict(X_test)\n    test_score = np.sqrt(mean_squared_error(y_test, y_pred))\n    results_data.loc[i,]= [name,-gs.best_score_,test_score]\n    i=i+1\n    est.append([name,gs.best_estimator_])\n    \nsc = StackingRegressor(estimators=est[1:],final_estimator= ridge,cv=kf)\nsc.fit(X_train,y_train)\ny_trn= sc.predict(X_train)\ny_tst= sc.predict(X_test)    \ntrain_score = np.sqrt(mean_squared_error(y_train, y_trn))\ntest_score = np.sqrt(mean_squared_error(y_test, y_tst))\nresults_data.loc[i,]= [\"Stack\",train_score,test_score]","43dcded8":"results_data","603291ee":"y_submit= np.expm1(sc.predict(X_submit))","242da5f9":"data_submit= pd.DataFrame({\"Id\":test.Id,\"SalePrice\":y_submit})","17762f00":"data_submit.to_csv(\"submit_housing.csv\",index=False)","dcb4d91c":"Similarly we impute the values for LotFrontage using Neighborhood and LotConfig as indicators. We taken the median of similar Neighborhood and LotFrontage values.","f07bbd71":"\n\n## 4. Outlier Handling \nOutlier handling is done using the mean and the standard deviation. We have taken three features which have highest correlation to the sale price based on which outliers have been removed.\n    \n","17c4fbd0":"<a id=\"link1\"><\/a>","70dd7940":"\n## 2. Handling missing values\n\n\nChecking for null values in our new combined dataset.\n    \n","631c2092":"\n\n## 5. Modelling\n\nWe use 10 fold KFold for cross validation.\n\nWe have used the following models:-\n1. Random Forest\n2. XGBoost\n3. Gradient Boosting\n4. Support Vector\n5. Ridge (L2)\n6. Lasso (L1)\n\nWe have run these models individually using a grid search for the right set of parameters.\nThen we have used the best models in all of them and used them in our stacking model.\n    \n","479e2a01":"Let us check the distribution of our dependent variable. It doesnt seem to be a normal distribution and leans towards a positive skewed distribution.","5141dff2":"Now we can zoom in to the 10 most important variables according to the pearson correlation coefficient and check the matrix.","51b507f9":"<a id=\"link5\"><\/a>","0f47ffa4":"We are dropping the Id feature since it would not add any useful information to the model.","f0811152":"For features that can't be missing we have taken the mode and the default value as per data description.","6a7d40e7":"Let us pair the 5 most important variables according to our matrix with sale price.\\n\nWe can see some outliers, which we will take care of later.\n\nThe OverallQual and GarageCars plot with Sale Price will be better respresented with box plots, since they are ordinal features.\n","21e5d928":"OverallQual and GarageCards have a positive correlation with the Sale Price. Price for houses with 4 garages are lower which seems to be an anomaly or there might be some other feature which is impacting the . We have only 5 records with 4 Garage cars which can cause such cases.","4247c827":"Exporting our submission dataset to a csv file.","db52803b":"We should check the dimensions of these dataframes before proceeding.\nWe have 1460 and 1459 rows in the train and test set respectively. We have 80 features in both the train and test set. The extra column in the train set would be the prediction.","b2b346f8":"Since the SubClass are categories and not of numeric data type we covert the feature to category type.","09b36662":"Let us now split out train set further in to train and test sets for validation.","7e8fe2d7":"# Housing Prices Prediction - Stacking,Feature Engineering & Outlier Handing\n\nWe would follow the below major steps:-\n\n1. EDA\n\n2. Handling missing  values\n\n3. Feature Engineering\n\n4. Outlier handling\n\n5. Modelling\n\nThere are various steps other than the ones listed above which you would encounter in the notebook.\n\nPS - Would suggest everyone to please check the Outlier Handling section as I haven't seen many notebooks using this method. Most of the notebooks have used manual methods. Cheers !!\n\nAlso please leave your suggestions to improve this notebook in the comments. Would be of great help in learning.\n\n### Edit - For some interesting hyperparameter tuning techniques, check out the link below:-\n\nhttps:\/\/www.kaggle.com\/ankur123xyz\/advanced-hyperparameter-tuning-techniques\n\nLet us start of by importing all the necessary packages.","5f03d644":"For all the numeric features we have checked for skew and have log transformed those features which have high skew (greater than 0.5 in our case) to get a normal distribtuion.","9927c5b0":"Having a look at the correlation of different numerical feature with SalePrice.","e2ef4693":"Having a peek at the train set we can see all features along with the value we have to predict - SalePrice","4090acfa":"We import both the train and test sets into different dataframes","7f26f358":"Creating a dataset which would be submitted for evaluation.","2b19d19a":"Since we have a high number of variables and is prone to have outliers as we worked only on a few features we should opt for Robust Scaler transformation to handle the outliers.\nBelow is a good read on different scaling methods:-\nhttps:\/\/scikit-learn.org\/stable\/auto_examples\/preprocessing\/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py","94b77819":"Base on the definition of these features give in the data description we impute the rest of the values to NA or 0 which signifies absence of that feature.","e733964b":"Let's expand our column view since we have 81 columns in the train set.","27f29dbf":"<a id=\"link2\"><\/a>","aceb5f21":"Since stacking gave us the best scores we would used that to get the predictions to be used to submit our scores.\nWe would do an inverse log transform since we had log transformed the SalePrice earlier.","ec16aa36":"Let us log transform it and recheck. Post log transform it is close to a normal distribution.","a6462f71":"Checking the train and test results for all the models.","4c339f7e":"We create a TotalSF feature which includes the surface area for basement, 1st floor and the 2nd floor.","e8bb697e":"We impute the missing values for zone using neighborhood as an indicator.","b595fb31":"\n## 1. Exploratory Data Analysis\n\nTo get a sense of which features are important and from where do we start we can create a correlation matrix. By default it uses the pearson correlation coefficent.\n","7f90e179":"<a id=\"link3\"><\/a>","f1b04cef":"We log transform SalePrice as we have seen earlier it helps in getting a normal distribution.","e5c1fd13":"We have created flags for different feature of the house to check if it is available or not.","db4f5321":"<a id=\"link4\"><\/a>","8f0def8f":"Now it is time to combine our train and test sets since we need to preprocess it the same way so that we can feed it later into our model.\n\nAlso we would drop the SalePrice column before merging and copy it to another series - y.","7c33aa0c":"We one hot encode the dataset and then split it to the orginal train set (with outliers removed) and the test set(all records intact).","844db609":"\n\n## 3. Feature Engineering\n\nWe have seen quite a few of the non numerical features have ordinal nature. We have transformed them below to numeric type to maintain the ordinal relation.\n    \n    \n"}}