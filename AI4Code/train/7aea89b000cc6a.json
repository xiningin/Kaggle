{"cell_type":{"6af4ce26":"code","42c2c326":"code","e814a3b4":"code","274640ac":"code","c60f6cf7":"code","6226af60":"code","a3ec3ba5":"code","a3069202":"code","0a1f0f6b":"code","0363ef37":"code","ecb46d6f":"code","13b1cd4a":"code","ae356e10":"code","f71e85fb":"code","07f3a4a8":"code","c97c32fe":"code","e12bbdec":"code","3d6a5f32":"code","7817459b":"markdown","f82ed18f":"markdown","13cb65dd":"markdown","ba1b8e2b":"markdown","52a1a35c":"markdown","71331836":"markdown","cecbce1e":"markdown","3084b7cb":"markdown","d33f224b":"markdown","bf285874":"markdown"},"source":{"6af4ce26":"import pandas as pd\nimport numpy as np\n\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\nfrom tensorflow.keras.optimizers import RMSprop\nfrom tensorflow.keras.models import load_model\n\nimport itertools\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.model_selection import train_test_split\n","42c2c326":"train = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\n\nprint(\"Quantidade de elementos de treino: {}\". format(len(train)))\nprint(train.head())","e814a3b4":"Y = train[\"label\"]\nX = train.drop(labels = [\"label\"],axis = 1)\nprint(X.head())","274640ac":"print(X.shape)","c60f6cf7":"plt.imshow(X.values[0].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Label: {}'.format(Y[0]))","6226af60":"x = X.values.reshape(42000, 28, 28, 1)\nx = x.astype('float32')\nx \/= 255","a3ec3ba5":"num_classes = 10\n\ny = keras.utils.to_categorical(Y, num_classes)","a3069202":"x_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.1, random_state=5)\nprint('Qtde de treino: {}'.format(len(x_train)))\nprint('Qtde de valida\u00e7\u00e3o: {}'.format(len(x_val)))","0a1f0f6b":"model = Sequential()\nmodel.add(Conv2D(40, kernel_size=(3, 3),\n                 activation='relu',\n                 input_shape=(28,28,1)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(60, kernel_size=(3,3), activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dense(50, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(50, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(num_classes, activation='softmax'))\nmodel.summary()","0363ef37":"model.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy'])","ecb46d6f":"batch_size = 64\nepochs = 30\n\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n]\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    callbacks = callbacks_list,\n                    verbose=1,\n                    validation_data=(x_val, y_val))","13b1cd4a":"fig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","ae356e10":"model = load_model('model.h5')\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","f71e85fb":"# Testando uma entrada qualquer\nprint(y_train[10])\nprint(model.predict(x_train[10].reshape((1,28,28,1))))\nprint(model.predict_classes(x_train[10].reshape((1,28,28,1))))","07f3a4a8":"def plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","c97c32fe":"y_pred = model.predict_classes(x_val)\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","e12bbdec":"\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Qtde de testes: {}\".format(len(test)))\n\nx_test = test.values.reshape(len(test),28,28,1)\nx_test = x_test.astype('float32')\nx_test \/= 255\n\ny_pred = model.predict_classes(x_test)\n\ni = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Previsto: {}'.format(y_pred[i]))\n\nresults = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(submission.head(10))\n\nsubmission.to_csv(\"mlp_mnist_v1.csv\",index=False)","3d6a5f32":"mean = 0.\nstddev = 0.2\nnoise = np.random.normal(mean, stddev, (4200, 28, 28,1))\nx_te = x_val + noise\nx_te = np.clip(x_te, 0., 1.)\n\nplt.imshow(x_te.reshape(4200, 28,28)[0], cmap=plt.cm.binary)\nplt.show()\n\nscore = model.evaluate(x_te, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","7817459b":"# Gerando Sa\u00edda","f82ed18f":"#### Batch_size alterado de 32 para 64\n#### epochs alterado de 20 para 30","13cb65dd":"#### Alterado primeira camada convolucional de 20 neur\u00f4nios para 40\n#### Alterado segunda camada convolucional de 40 neur\u00f4nios para 60\n#### Adicionada camada de rede neurais ap\u00f3s a camada de Flatten, com 50 neur\u00f4nicos, ativa\u00e7\u00e3o 'relu' e conex\u00e3o com pr\u00f3xima camada com dropout de 20%","ba1b8e2b":"Com ru\u00eddo, percebemos que a acur\u00e1cia dos exemplos de valida\u00e7\u00e3o caiu, mas muito menos que o modelo MLP cl\u00e1ssico (ver exemplo de MLP).\nUm modelo Convolucional (CNN) captura melhor regi\u00f5es, ou padr\u00f5es espaciais de pixels, tornando o modelo mais robusto.","52a1a35c":"# Introdu\u00e7\u00e3o","71331836":"# Teste Adicional: Com ru\u00eddo","cecbce1e":"**Resumo:**\n\nO exemplo aqui desenvolvido tem como objetivo apresentar conceitos iniciais de implementa\u00e7\u00e3o de redes neurais com python e tensorflow\/keras. Esse modelo apresenta um modelo de Rede Neural Convolucional (CNN) b\u00e1sico que pode ser expandido mudando o n\u00famero de neur\u00f4nios e camadas. Em adapta\u00e7\u00f5es mais avan\u00e7adas, pode-se estudar possibilidade de otimiza\u00e7\u00e3o de hyperpar\u00e2metros e outras t\u00e9cnincas como aumento de dados.\n\n**N\u00e3o \u00e9 objetivo nosso desenvolver e otimizar o modelo de classifica\u00e7\u00e3o**. O exemplo tem objetivo meramente did\u00e1tico.\n\n---\n\n**Para saber mais:**\n* [Palestras e cursos do Ocean](http:\/\/www.oceanbrasil.com\/)\n* Fran\u00e7ois Chollet. Deep Learning with Python. Manning Publications, 2017.\n* Ian Goodfellow and Yoshua Bengio and Aaron Courville. [Deep Learning](https:\/\/www.deeplearningbook.org\/). MIT Press, 2016.","3084b7cb":"# Avaliando o Modelo","d33f224b":"# Importando bibliotecas","bf285874":"# Criando e treinando o Modelo"}}