{"cell_type":{"1de81942":"code","7068cb32":"code","5b3b73b6":"code","7dbbe195":"code","4ccec7dc":"code","329a5098":"code","5419c850":"code","39787fe3":"code","60413300":"code","02e2cc3f":"code","b818cd6d":"code","216ba1a8":"code","b8ae9a4f":"code","b50f716c":"code","89e8386a":"code","6f013a32":"code","450bcf53":"code","944e2ace":"code","d032e643":"code","a393b8f7":"code","a76669c6":"markdown","05e3d2b1":"markdown","94b8f80c":"markdown","7729982a":"markdown","50306065":"markdown","83c326a7":"markdown","0f894bd2":"markdown","a5d772fb":"markdown","a3209e0f":"markdown","c9dc463c":"markdown","c9195c45":"markdown","fa798029":"markdown"},"source":{"1de81942":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom numpy import linalg\nimport sys\nimport matplotlib.animation as animation\nfrom IPython.display import HTML\n\nimport cv2","7068cb32":"def svd(A, tol=1e-5):\n    #singular values and right singular vectors coming from eigenvalues and eigenvectors of A' x A\n    eigs, V = linalg.eig(A.T.dot(A))\n\n    #singular values are the square root of the eigenvalues\n    sing_vals = np.sqrt(eigs)\n\n    #sort both sigular values and right singular vector\n    idx = np.argsort(sing_vals)\n\n    sing_vals = sing_vals[idx[::-1]]\n    V = V[:, idx[::-1]]\n\n    #remove zero singular values below tol\n    sing_vals_trunc = sing_vals[sing_vals>tol]\n    V = V[:, sing_vals>tol]\n\n    #is not necessary to store the entire sigma matrix, so only the diagonal is returned\n    sigma = sing_vals_trunc\n\n    #evaluate U matrix\n    U = A @ V \/sing_vals_trunc\n    \n    return U.real, sigma.real, V.T.real","5b3b73b6":"def truncate(U, S, V, k):\n    U_trunc = U[:, :k]\n    S_trunc = S[:k]\n    V_trunc = V[:k, :]\n    return U_trunc, S_trunc, V_trunc","7dbbe195":"from sklearn.datasets import load_iris\nimport seaborn as sns\nimport pandas as pd\n\niris = load_iris()\niris.keys()","4ccec7dc":"data = pd.DataFrame(iris.data)\nfeature_names = iris[\"feature_names\"]\ndata.columns = feature_names\ndata[\"labels\"] = iris.target","329a5098":"def custom_pairplot(data, feature_names, labels):\n    plt.figure(figsize=(10, 10))\n    plt.subplots_adjust(left = 0, right=1.5, bottom=0, top=1.5)\n    n_features = len(feature_names)\n    \n    for i in range(len(feature_names)):\n        for j in range(len(feature_names)):\n            plt.subplot(n_features, n_features, i*n_features+j+1)\n            if i==j:\n                sns.violinplot(data=data, x=labels, y=feature_names[i])\n            else:\n                plt.scatter(data[feature_names[i]], data[feature_names[j]], c=data[labels])\n                plt.xlabel(feature_names[i])\n                plt.ylabel(feature_names[j])","5419c850":"custom_pairplot(data, feature_names=feature_names, labels=\"labels\")","39787fe3":"k = 2\n\nA = data[feature_names].values\n\nU, S, Vt = svd(A)\nU_trunc, S_trunc, Vt_trunc = truncate(U, S, Vt, k)\n\ntrunc_A = U_trunc @ np.diag(S_trunc)\nreduced_data = pd.DataFrame(trunc_A)\nplt.figure(figsize=(5, 5))\nplt.barh(feature_names[::-1], S[::-1])\nplt.title(f\"Singular values, (first {k} are kept)\")\nplt.gca().xaxis.grid(True)","60413300":"plt.figure(figsize=(5, 5))\nplt.scatter(reduced_data[0], reduced_data[1], c = iris.target)\nplt.xlabel(\"First feature\")\nplt.ylabel(\"Second feature\");","02e2cc3f":"def im2double(im):\n    info = np.iinfo(im.dtype)\n    return im.astype(np.float)\/info.max","b818cd6d":"# grayscale image (is still saved with 3 channels so I take the first one)\nimg = plt.imread(\"..\/input\/random\/WhatsApp Image 2021-10-07 at 16.08.57.jpeg\")[:,:,0]","216ba1a8":"gray_channel = im2double(img)\n\n#my implementation\nU, S, V = svd(gray_channel)\n\n#linalg library implementation\nU_, S_, V_ = np.linalg.svd(gray_channel)","b8ae9a4f":"#number of singular values kept\nk = 20\n\nfig = plt.figure(figsize=(15,15))\n\nax1 = plt.subplot(1, 3, 1)\nax2 = plt.subplot(1, 3, 2)\nax3 = plt.subplot(1, 3, 3)\n\nplt.ion()\n\nfig.canvas.draw()\n\nU_trunc, S_trunc, Vt_trunc = truncate(U, S, V, k)\n_U_trunc, _S_trunc, _Vt_trunc = truncate(U_, S_, V_, k)\n\nmy_channel = 255 * U_trunc @ np.diag(S_trunc) @ Vt_trunc\nlinalg_channel = 255 * _U_trunc @ np.diag(_S_trunc) @ _Vt_trunc\n\nax1.title.set_text(f\"Original image\")\nax1.imshow(gray_channel, cmap='gray')\n    \nax2.title.set_text(f\"Custom svd implementation, k={k}\")\nax2.imshow(my_channel, cmap='gray')\n\n\nax3.title.set_text(f\"Numpy linalg svd implementation, k={k}\")\nax3.imshow(linalg_channel, cmap='gray')\n       \n","b50f716c":"plt.rcParams['animation.embed_limit'] = 2**128\nfps = 30\nstep = 5\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\n\nax2.axis(\"off\")\n\n#set figure dimension\nfig.set_size_inches(10, 5)\n\n#set first frame for the first plot (single values)\nax1.set_yscale(\"log\")\nax1.plot(S)\nax1.grid()\n\n\n#set first frame for the second plot (image)\nim = ax2.imshow(gray_channel, interpolation='none', vmin=0, vmax=1, cmap='gray');\nplt.tight_layout()\n\ndef animate_func(i):\n    #set next frame for single value truncation\n    k = len(S)-i*step\n    ax1.clear()\n    ax1.set_yscale(\"log\")\n    ax1.axvline(x=k, ymin=0, ymax=1, c=\"gray\", linestyle=\"--\")\n    ax1.plot(S)\n    ax1.legend([f\"Truncation k={k}\", \"Log10 of singular value\"])\n    \n    ax1.grid()\n        \n    #truncate svd decomposition and set new frame\n    U_trunc, S_trunc, Vt_trunc = truncate(U, S, V, k)\n    new_channel = U_trunc @ np.diag(S_trunc) @ Vt_trunc\n    im.set_array(new_channel)\n    return [fig]\n\nanim = animation.FuncAnimation(\n                               fig, \n                               animate_func, \n                               frames = len(S)\/\/step+1,\n                               interval = 100 \/ fps, # in ms\n                               );\n","89e8386a":"HTML(anim.to_jshtml())","6f013a32":"#getting image channels\nrgb_img = plt.imread(\"..\/input\/random\/WhatsApp Image 2021-10-07 at 16.09.00.jpeg\")\n\n#separate them\nred_channel = im2double(rgb_img[:, :, 0])\ngreen_channel = im2double(rgb_img[:, :, 1])\nblue_channel = im2double(rgb_img[:, :, 2])\n\n#get SVD factorization\nr_U, r_S, r_V = svd(red_channel)\ng_U, g_S, g_V = svd(green_channel)\nb_U, b_S, b_V = svd(blue_channel)","450bcf53":"fig, (ax1, ax2) = plt.subplots(1, 2)\n\nax2.axis(\"off\")\n\n#set figure dimension\nfig.set_size_inches(10, 5)\n\n#set first frame for the first plot (single values)\nax1.set_yscale(\"log\")\nax1.plot(S)\nax1.grid()\n\n#set first frame for the second plot (image)\nim = ax2.imshow(cv2.merge((red_channel, green_channel, blue_channel)).clip(0.0, 1.0),\n                interpolation='none', vmin=0, vmax=1)\n\nplt.tight_layout()\n\ndef animate_func(i):\n    #set next frame for single value truncation\n    k = len(S)-i*step\n    ax1.clear()\n    ax1.set_yscale(\"log\")\n    ax1.axvline(x=k, ymin=0, ymax=1, linestyle='--', c=\"gray\")\n    \n    ax1.plot(r_S, c=\"red\", linewidth=1)\n    ax1.plot(g_S, c=\"green\", linewidth=1)\n    ax1.plot(b_S, c=\"blue\", linewidth=1)\n\n    ax1.legend([f\"Truncation k={k}\", \"Log10 of RED singular value\",\n                \"Log10 of GREEN singular value\", \"Log10 of BLUE singular value\"])\n    ax1.grid()\n    \n    #truncate svd decomposition and set new frame\n    r_U_trunc, r_S_trunc, r_Vt_trunc = truncate(r_U, r_S, r_V, k)\n    g_U_trunc, g_S_trunc, g_Vt_trunc = truncate(g_U, g_S, g_V, k)\n    b_U_trunc, b_S_trunc, b_Vt_trunc = truncate(b_U, b_S, b_V, k)\n\n    r_new_channel = r_U_trunc @ np.diag(r_S_trunc) @ r_Vt_trunc\n    g_new_channel = g_U_trunc @ np.diag(g_S_trunc) @ g_Vt_trunc\n    b_new_channel = b_U_trunc @ np.diag(b_S_trunc) @ b_Vt_trunc\n\n    im.set_array(cv2.merge((r_new_channel, g_new_channel, b_new_channel)).clip(0.0, 1.0))\n    return [fig]\n\nanim = animation.FuncAnimation(\n                               fig, \n                               animate_func, \n                               frames = len(S)\/\/step+1,\n                               interval = 100 \/ fps, # in ms\n                               )\n","944e2ace":"HTML(anim.to_jshtml())","d032e643":"original_size = np.prod(rgb_img.shape) #evaluated in float numbers (dimension on disk is different)\n\ncompressed_size = []\n\nstart_dim = np.linalg.matrix_rank(red_channel)\n\nfor k in range(1, start_dim+1):\n    # evaluation is done for red channel and then multiplied by 3\n    r_U_trunc, r_S_trunc, r_Vt_trunc = truncate(r_U, r_S, r_V, k)\n    compressed_size.append((np.prod(r_U_trunc.shape)+k+np.prod(r_Vt_trunc.shape)) * 3)\n\ntot_var = sum(r_S**2)+sum(g_S**2)+sum(b_S**2)\n\nr_S_padded = np.pad(r_S, (0, start_dim-len(r_S)))\ng_S_padded = np.pad(g_S, (0, start_dim-len(g_S)))\nb_S_padded = np.pad(b_S, (0, start_dim-len(b_S)))\n\n\nexplained = np.cumsum(r_S_padded**2)+np.cumsum(g_S_padded**2)+np.cumsum(b_S_padded**2)\nexplained \/= tot_var","a393b8f7":"plt.figure(figsize=(12, 5))\n\nplt.subplot(1, 2, 1)\nplt.plot(original_size\/compressed_size)\nplt.yscale(\"log\")\nplt.grid()\nplt.xlabel(\"Number of singular values\")\nplt.ylabel(\"Compression ratio\")\n\nplt.subplot(1, 2, 2)\nplt.plot(explained)\nplt.xscale(\"log\")\nplt.grid()\nplt.xlabel(\"Number of singular values\")\nplt.ylabel(\"Explained variability\");\n","a76669c6":"The resulting image can be stored as the three truncated matrices. So we can define the compression ratio as the ratio between uncompressed size and compressed.<br>\n$$Compression\\ ratio=\\frac{Uncompressed\\ size}{Compressed\\ size}$$\n\nIt's also possible to compute the percentage of explained variability<br>\n\n$$Explained\\ variability = \\frac{\\sum_{j=1}^{k}{\\sigma_j^2}}{\\sum_{j=1}^{n}{\\sigma_j^2}}$$\n\nWhere sigma j is the j-th singular value.<br> There is a rule of thumb that suggests to keep enough singular values to have 85% of variability explained","05e3d2b1":"The proposed implementation of SVD consists of evaluating eigenvalues and eigenvectors of A\\*A with numpy library *linalg.eig* to get V and the singular values<br>\nThen the singular values are sorted, and so the singular vectors in V<br>\nWe consider only non-zero singular values<br>\nThen U is computed solving the linear equation with A, V and \u03a3.\n","94b8f80c":"Side by side with my svd implementation there is also the *numpy.linalg* algorithm *svd*","7729982a":"We can see how the image changes with k with this animation.","50306065":"As we can see, keeping two dimensions leads to quite well separated classes.<br>\nIn this case working on 4 features instead of 2 is not a problem but in other context dimensionality reductions is almost mandatory","83c326a7":"Let's apply SVD decomposition to keep only two dimensions (k=2)<br>","0f894bd2":"The singular values stored inside \u03a3 have very different values, they indicates how much \"relevant\" that singular values are.<br>\nSo we can just take the first k singular values, truncating \u03a3 and consequently V and U.<br>\nIn this way the matrix product is still doable and the resulting matrix has the same shape as the original.<br>\nIf we use svd for dimensionality reduction we just need to keep U and \u03a3, because V is just used to *project the lower rank matrix **U\u03a3** into the previous dimension*.","a5d772fb":"This is a custom version of the *sns.pairplot* with violins instead of histograms and scatters colored according to the class","a3209e0f":"# SVD for dimensionality reduction\nWe can see how svd decomposition applies to dimensionality reduction, in this example, using the **Iris dataset** available directly from library *sklearn*","c9dc463c":"The same technique can be applied to RGB images, the only difference is that SVD needs to be applied 3 times, one for every channel.","c9195c45":"# SVD for Image Compression\nNow we can see how to apply svd to image compression<br>","fa798029":"# SVD decomposition and applications\n\nSVD is a factorization used for solving linear equations, dimensionality reduction, data compression and so on.<br>\nIt's based on the following decomposition:\n$$A = U\\Sigma V^*$$\n<br>\nIn which the matrix A *(m x n)* can be factorized into three matrices:<br>\n**U** *(m x m)* unitary matrix <br>\n**\u03a3** *(m x n)* rectangular diagonal matrix <br>\n**V** *(n x n)* unitary matrix <br>\n\nColumns of **V** are the eigenvectors of **A\\*A** called singular vectors<br>\nColumns of **U** are the eigenvectors of **AA*** called singular vectors<br>\nThe elements on the diagonal of **\u03a3** are the ordered non-zero eigenvalues of both **A*A** and **AA*** called *singular values*<br>"}}