{"cell_type":{"4c98fcd8":"code","8f372bfa":"code","7291db92":"code","41af5998":"code","90ee591b":"code","87719782":"code","ae804433":"code","22cea102":"code","0a472389":"code","8048e2b8":"code","c0ffc25e":"code","59602369":"code","3fdcbd6d":"code","c861c852":"code","d2f3a6e0":"code","1985b040":"code","506ff3c3":"code","743fb23e":"code","efd63fb1":"code","eb9d3713":"code","83a4b7dd":"code","10c758c8":"code","9b9d987f":"code","93717ab9":"code","df62b139":"code","7174a036":"code","45d93973":"code","96204d8c":"code","728c5cbf":"code","12215ae4":"code","0d81b207":"code","df5be534":"code","fb0a1584":"code","b1ed02e2":"code","ada28e3e":"code","830ed483":"code","c99ff74b":"code","53217010":"code","442c5d30":"code","eaeaf442":"code","998ea051":"code","b1a2bb5f":"markdown","cbf02609":"markdown","7a1bbaee":"markdown","601ebcf7":"markdown","6da1dfa7":"markdown","cdb60770":"markdown","f897a4b1":"markdown","aa030250":"markdown","d2da69cc":"markdown","9f0c1f8c":"markdown","212adfdd":"markdown","9048d59f":"markdown","58bf6a04":"markdown","1b847cee":"markdown","ec1b5501":"markdown","7b218989":"markdown","4f80ae86":"markdown","df730dd2":"markdown","83e10de8":"markdown","20864886":"markdown","311ed44f":"markdown"},"source":{"4c98fcd8":"# Basic libraries\nimport pandas as pd\nimport numpy as np\n\n# Visualization libraries\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","8f372bfa":"df = pd.read_csv(\"\/kaggle\/input\/water-potability\/water_potability.csv\")\ndf.head()","7291db92":"print(f\"This data frame has {df.shape[0]} rows and {df.shape[1]} columns.\")","41af5998":"df.info()","90ee591b":"df.describe()","87719782":"df.isna().sum()","ae804433":"df = df.dropna()\ndf.isna().sum()","22cea102":"print(f\"After drop all NA values, we have {df.shape[0]} rows.\")","0a472389":"plt.figure(figsize=(10, 8))\nplot = sns.countplot(x=\"Potability\", data=df)\nplt.xticks(ticks=[0, 1], labels=[\"Not Potable\", \"Potable\"])\nplt.title(\"Quantity of potable water\")\nplt.show()","8048e2b8":"plt.figure(figsize=(10, 8))\nsns.violinplot(x=\"Potability\", y=\"ph\", data=df)\nplt.title(\"Ph values in water potability\")\nplt.show()","c0ffc25e":"df[\"Potability\"].value_counts()","59602369":"not_potable = df[df['Potability']==0]\npotable = df[df['Potability']==1]\n\nfrom sklearn.utils import resample\ndf_minority_upsampled = resample(potable, replace = True, n_samples = 1200) \n\ndf = pd.concat([not_potable, df_minority_upsampled])\n\nfrom sklearn.utils import shuffle\ndf = shuffle(df)\n\ndf.Potability.value_counts()","3fdcbd6d":"plt.figure(figsize=(10, 8))\nheatmap = sns.heatmap(df.corr(), linewidths=.5, annot=True)\nplt.show()","c861c852":"corr = df.corr()\ncorr[\"Potability\"].sort_values(ascending=False)","d2f3a6e0":"# Machine Learning libraries\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score, confusion_matrix","1985b040":"X = df.drop([\"Potability\"], axis = 1)\ny = df[\"Potability\"]","506ff3c3":"from sklearn.preprocessing import StandardScaler\nnormalize = StandardScaler()\nfeatures= X.columns\nX[features] = normalize.fit_transform(X[features])\n\nX[features].head()","743fb23e":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size = 0.2)","efd63fb1":"lr_model = LogisticRegression(max_iter=120, n_jobs=25, random_state=1)\nlr_model.fit(X_train, y_train)","eb9d3713":"lr_predict = lr_model.predict(X_test)","83a4b7dd":"lr = accuracy_score(y_test, lr_predict)\nprint(f\"Logistic Regression accuracy: {lr}\")","10c758c8":"cm_lr = confusion_matrix(y_test, lr_predict)\nsns.heatmap(cm_lr\/np.sum(cm_lr), annot = True, fmt=  \"0.2%\")\nplt.show()","9b9d987f":"cm_lr","93717ab9":"kn_neighbors = KNeighborsClassifier(n_neighbors=9, leaf_size=20)\nkn_neighbors.fit(X_train, y_train)","df62b139":"kn_predict = kn_neighbors.predict(X_test)","7174a036":"kn = accuracy_score(y_test, kn_predict)\nprint(f\"K-Nearest Neighbor accuracy: {kn}\")","45d93973":"cm_kn = confusion_matrix(y_test, kn_predict)\nsns.heatmap(cm_kn\/np.sum(cm_kn), annot = True, fmt=  \"0.2%\")\nplt.show()","96204d8c":"cm_kn","728c5cbf":"decision_tree = DecisionTreeClassifier(max_depth=4, random_state=1)\ndecision_tree.fit(X_train, y_train)","12215ae4":"dt_predict = decision_tree.predict(X_test)","0d81b207":"dt = accuracy_score(y_test, dt_predict)\nprint(f\"Decision tree accuracy: {dt}\")","df5be534":"cm_dt = confusion_matrix(y_test, dt_predict)\nsns.heatmap(cm_dt\/np.sum(cm_dt), annot=True, fmt=\".2%\")\nplt.show()","fb0a1584":"cm_dt","b1ed02e2":"random_forest = RandomForestClassifier(n_estimators=110, max_depth=5, random_state=1)\nrandom_forest.fit(X_train, y_train)","ada28e3e":"rf_predict = random_forest.predict(X_test)","830ed483":"rf = accuracy_score(y_test, rf_predict)\nprint(f\"Random forest accuracy: {rf}\")","c99ff74b":"cm_rf = confusion_matrix(y_test, rf_predict)\nsns.heatmap(cm_rf\/np.sum(cm_rf), annot=True, fmt=\".2%\")\nplt.show()","53217010":"cm_rf","442c5d30":"models = pd.DataFrame({\"Model\": [\"Logistic Regression\", \"KNN\", \"Decision Tree\", \"Random Forest\"],\n                      \"Accuracy\": [lr, kn, dt, rf]})\nmodels = models.sort_values(by='Accuracy', ascending=False)\nmodels","eaeaf442":"plt.figure(figsize=(8, 6))\nsns.barplot(data=models, x=\"Accuracy\", y=\"Model\")\nplt.title(\"Models accuracy score\")\nplt.show()","998ea051":"import plotly.express as px\n\nfig = px.bar(models, x=\"Accuracy\", y=\"Model\", color=\"Model\", orientation=\"h\", title=\"Models accuracy score\")\nfig.show()","b1a2bb5f":"![image.png](attachment:99363d0b-34ae-44e6-8a2a-e4af234de829.png)","cbf02609":"## 1. Import modules\n<a id=\"modules\"><\/a>","7a1bbaee":"### 5.2 K-Nearest Neighbors\n<a id=\"knn\"><\/a>","601ebcf7":"## 3. Data info\n<a id=\"info\"><\/a>","6da1dfa7":"If you want, you can **fill** all NA values, with the mean of each column.\n<br>\n*df['ph'].fillna((df['ph'].mean()), inplace=True)*","cdb60770":"### 5.4 Random Forest\n<a id=\"randomforest\"><\/a>","f897a4b1":"# **Water quality**","aa030250":"### 5.1 Logistic Regression\n<a id=\"logistic\"><\/a>","d2da69cc":"# Index\n\n* [1.Import modules](#modules)\n* [2. Read data](#read)\n* [3. Data info](#info)\n    * [3.1. NA Values](#navalues)\n* [4. Plots](#plots)\n* [5. Machine Learning Models](#models)\n    * [5.1 Logistic Regression](#logistic)\n    * [5.2 K-Nearest Neighnors](#knn)\n    * [5.3 Decision Tree](#decisiontree)\n    * [5.4 Random forest](#randomforest)\n* [6. Conclusion](#conclusion)","9f0c1f8c":"We have more not potable values to potable, so we need to balance the data to prevent bias.","212adfdd":"**X** -> All variables, except what we want to predict, to train our model\n<br>\n**y** -> Variable to predict","9048d59f":"We will use *StandardScaler* to **normalize** the data","58bf6a04":"![image.png](attachment:3e38d33c-6df4-4e8d-b484-6367651a984f.png)","1b847cee":"**Solids** has the highest correlation with *Potability*","ec1b5501":"### 3.1 NA Values\n<a id=\"navalues\"><\/a>","7b218989":"### 5.3 Decision Tree\n<a id=\"decisiontree\"><\/a>","4f80ae86":"## 4. Plots\n<a id=\"plots\"><\/a>","df730dd2":"We have 2 models with respectable accuracy, almost *70%* and very close to each other.\n<br>\n* **KNN** (K-Neares Neighbors)\n* **Random Forest**","83e10de8":"## 6. Conclusion\n<a id=\"conclusion\"><\/a>","20864886":"## 2. Read data\n<a id=\"read\"><\/a>","311ed44f":"## 5. Machine Learning Models\n<a id=\"models\"><\/a>"}}