{"cell_type":{"61e60e16":"code","00ae3251":"code","1b87934e":"code","c34c02ff":"code","c1f0fdf1":"code","00103175":"markdown","ead430a4":"markdown"},"source":{"61e60e16":"import numpy as np\nimport pandas as pd\nfrom math import sqrt, acos, pi\nfrom scipy.spatial.transform import Rotation as R","00ae3251":"thres_rot = [50, 45, 40, 35, 30, 25, 20, 15, 10, 5]\nthres_pos = [0.1, 0.09, 0.08, 0.07, 0.06, 0.05, 0.04, 0.03, 0.02, 0.01]","1b87934e":"def trans_dist(p1, p2):\n    dx = p1[0] - p2[0]\n    dy = p1[1] - p2[1]\n    dz = p1[2] - p2[2]\n    return sqrt(dx * dx + dy * dy + dz * dz)\n\ndef rot_dist(true, pred):\n    x, y, z = true\n    true = [z, x, y]\n    x, y, z = pred\n    pred = [z, x, y]\n    q1 = R.from_euler('zyx', true)\n    q2 = R.from_euler('zyx', pred)\n    diff = R.inv(q2) * q1\n    W = np.clip(diff.as_quat()[-1], -1., 1.)\n    W = (acos(W) * 360) \/ pi\n    if W > 180:\n        W = 360 - W\n    return W\n\ndef get_acc(true, pred):\n    pred_rot = pred[:-3]\n    true_rot = true[:-3]\n    pred_pos = pred[3:]\n    true_pos = true[3:]\n  \n    rot_d = rot_dist(true_rot, pred_rot)\n    tran_d = trans_dist(true_pos, pred_pos)\n    print(rot_d, tran_d)\n\n    thres = []\n    for t in thres_rot:\n        if rot_d < t:\n            thres.append(1)\n        else:\n            thres.append(0)\n    for t in thres_pos:\n        if tran_d < t:\n            thres.append(1)\n        else:\n            thres.append(0)\n    print(thres)\n    true_thres = np.ones((20))\n\n    return apk(true_thres, thres, k=20)\n\n'''Ref: https:\/\/github.com\/benhamner\/Metrics\/blob\/master\/Python\/ml_metrics\/average_precision.py'''\ndef apk(actual, predicted, k=10):\n    if len(predicted)>k:\n        predicted = predicted[:k]\n\n    score = 0.0\n    num_hits = 0.0\n\n    for i,p in enumerate(predicted):\n        # if p in actual and p not in predicted[:i]:\n        if p == actual[i]:\n            num_hits += 1.0\n#             score += 1 \/ (i+1.0)\n            score += num_hits \/ (i+1.0)\n\n    if len(actual) == 0:\n        return 0.0\n\n    return score \/ min(len(actual), k)\n\ndef mapk(actual, predicted, k=10):\n    return np.mean([apk(a,p,k) for a,p in zip(actual, predicted)])","c34c02ff":"pred = [0.15, -3.1, -3.1, 8.09433326, 5.27078698, 21.43466666]\ntrue = [0.169198, -3.11164, -3.08562, 7.42949, 4.99111, 20.2823]\n\nprint(get_acc(true, pred))","c1f0fdf1":"'''Ref: https:\/\/www.kaggle.com\/pestipeti\/explanation-of-map5-scoring-metric'''\ndef map_per_set(labels, predictions, k=1):\n    scores = []\n    for idx,l in enumerate(labels):\n        try:\n            scores.append(1 \/ (predictions[:k].index(l) + 1.))\n        except ValueError:\n            scores.append(0)\n    return np.mean(scores)","00103175":"Here are some local CV functions I made for validation. Sharing them to get some feed back on whether they are accurate or not.  \nDistance functions and thresholds based on this competition's official evaluation.","ead430a4":"Its tricky making a CV that works like the PB leaderboard, the less cars given the higher the score..."}}