{"cell_type":{"8e307033":"code","2b9b4dd9":"code","863e0819":"code","a4c2958b":"code","f793b48e":"code","4d8b8839":"code","cbfbfb12":"code","ad19bec0":"code","f70eabdd":"code","ffac6b03":"code","25c349bf":"code","5de17f4a":"code","f3144ac4":"code","16f3f28d":"code","5a77e66f":"code","bcb7b5e2":"code","74a22ce4":"code","9ccf2b16":"code","1282a170":"code","84682c02":"code","e558355e":"code","8dd33dbd":"code","1d394f69":"code","7706cd40":"code","529fde03":"code","5a711cdf":"code","79fa8a6f":"code","0b425ba2":"code","a8488e14":"code","27596544":"code","3d3b1bdd":"code","92f03f3d":"code","e67d3158":"code","54b1f5ff":"code","e2c603f3":"code","ce217c1a":"code","eb73e71c":"code","089b9351":"code","bfabe1d1":"code","7605f4f9":"code","dc2715e3":"code","01e43af2":"code","8556c080":"code","7130590e":"code","c922c96a":"code","43d7feb5":"code","2b71f180":"code","fc176350":"code","d5d07100":"code","4fbb5a3f":"code","ac908cc7":"code","760d8572":"code","093e7620":"code","ab701a73":"code","43e5bf28":"code","54ca0b9c":"code","1130a6a0":"code","11f38b7e":"code","cc8bad47":"code","a9bf7ba7":"code","ed32d75e":"code","77c9207c":"code","8fa0938a":"code","4395bb9f":"code","171e857c":"code","479dc666":"code","fce072cb":"code","c747843a":"code","97ceb5c6":"code","68c0cb64":"code","a46df9ce":"code","0551f4ac":"code","f05cd42e":"code","031b3b6c":"markdown","34d3febd":"markdown","20fe6b34":"markdown","17ae1b5d":"markdown","22987419":"markdown","de0f5fdf":"markdown","56607d74":"markdown","d28587f2":"markdown","3002cbd0":"markdown","e8a7792b":"markdown","d790bc97":"markdown","61b7b83b":"markdown","82407ab7":"markdown","ba096a4f":"markdown","69e7553d":"markdown","af8da3ae":"markdown","699c6c0f":"markdown","880bd4ad":"markdown","a6569674":"markdown","c8cada32":"markdown","9773679b":"markdown","26703995":"markdown","bbbf719e":"markdown","64a927b4":"markdown","55bf8d38":"markdown","ad8aea04":"markdown","f790ee4b":"markdown","a320d264":"markdown","463ac775":"markdown","1ea4c648":"markdown","d8f51db6":"markdown","b25cf6eb":"markdown","05ae5b26":"markdown"},"source":{"8e307033":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys\nnp.set_printoptions(threshold=sys.maxsize)","2b9b4dd9":"path_train = 'covid19-global-forecasting-week-1\/train-2.csv'\npath_test = 'covid19-global-forecasting-week-1\/test.csv'\npath_sbumit = 'covid19-global-forecasting-week-1\/submission.csv'\n\ntrain_kaggle = '\/kaggle\/input\/covid19-global-forecasting-week-1\/train.csv'\ntest_kaggle = '\/kaggle\/input\/covid19-global-forecasting-week-1\/test.csv'\nsubmit_kaggle = '\/kaggle\/input\/covid19-global-forecasting-week-1\/submission.csv'\n\ndf_train = pd.read_csv(train_kaggle)\ndf_test = pd.read_csv(test_kaggle)","863e0819":"df_train.info()","a4c2958b":"df_test.info()","f793b48e":"# Dataset Dimesnions\nprint('Train shape', df_train.shape)\nprint('Test shape', df_test.shape)\n# Missing\/Null Values\nprint('\\nTrain Missing\\n', df_train.isnull().sum())\nprint('\\nTest Missing\\n', df_test.isnull().sum())","4d8b8839":"lst = df_train['Country\/Region'].unique()\nprint('Total_Countries\\n:', len(lst))\nfor i in lst:\n    print(i)","cbfbfb12":"print(df_train['Date'].min(), ' - ', df_train['Date'].max())","ad19bec0":"# GroupBy syntax (columns to group by in list)[Columns to aggregate, apply function to] . aggregation functions on it \ntrain_cases_conf = df_train.groupby(['Date'])['ConfirmedCases'].sum()\ntrain_cases_conf","f70eabdd":"train_cases_conf.plot(figsize = (10,8), title = 'Worldwide Confirmed Cases')","ffac6b03":"train_fatal = df_train.groupby(['Date'])['Fatalities'].sum()\ntrain_fatal","25c349bf":"train_fatal.plot(figsize = (10,8), title = 'Worldwide Fatalaties')","5de17f4a":"def country_stats(country, df):\n    country_filt = (df['Country\/Region'] == country)\n    df_cases = df.loc[country_filt].groupby(['Date'])['ConfirmedCases'].sum()\n    df_fatal = df.loc[country_filt].groupby(['Date'])['Fatalities'].sum()\n    fig, axes = plt.subplots(nrows = 2, ncols= 1, figsize=(15,15))\n    df_cases.plot(ax = axes[0])\n    df_fatal.plot(ax = axes[1])\n    \ncountry_stats('US', df_train)","f3144ac4":"# grouping using same Country filter to get fatalities on each date (grouped by date)\n# groupby([list of columns to groupby]) [which columns to apply aggregate fx to ]. (aggregate function)\n# To Do - Fix Ticks \n\ndef country_stats_log(country, df):\n    count_filt =(df_train['Country\/Region'] == country)\n    df_count_case = df_train.loc[count_filt].groupby(['Date'])['ConfirmedCases'].sum()\n    df_count_fatal = df_train.loc[count_filt].groupby(['Date'])['Fatalities'].sum()\n    plt.figure(figsize=(15,10))\n    plt.axes(yscale = 'log')\n    plt.plot(df_count_case.index, df_count_case.tolist(), 'b', label = country +' Total Confirmed Cases')\n    plt.plot(df_count_fatal.index, df_count_fatal.tolist(), 'r', label = country +' Total Fatalities')\n    plt.title(country +' COVID Cases and Fatalities (Log Scale)')\n    plt.legend()\n    \n\ncountry_stats_log('US', df_train)","16f3f28d":"# as_index = False to not make the grouping column the index, creates a df here instead of series, preserves\n# Confirmedcases column\n\ntrain_case_country = df_train.groupby(['Country\/Region'], as_index=False)['ConfirmedCases'].max()\n\n# Sorting by number of cases\ntrain_case_country.sort_values('ConfirmedCases', ascending=False, inplace = True)\ntrain_case_country","5a77e66f":"plt.figure(figsize=(8,6))\nplt.bar(train_case_country['Country\/Region'][:5], train_case_country['ConfirmedCases'][:5], color = ['red', 'yellow','black','blue','green'])","bcb7b5e2":"# Confirmed Cases till a particular day by country\n\ndef case_day_country (Date, df):\n    df = df.groupby(['Country\/Region', 'Date'], as_index = False)['ConfirmedCases'].sum()\n    date_filter = (df['Date'] == Date)\n    df = df.loc[date_filter]\n    df.sort_values('ConfirmedCases', ascending = False, inplace = True)\n    sns.catplot(x = 'Country\/Region', y = 'ConfirmedCases' , data = df.head(10), height=5,aspect=3, kind = 'bar')\n    \n    \ncase_day_country('2020-03-23', df_train)","74a22ce4":"df_train.Date = pd.to_datetime(df_train['Date'])\nprint(df_train['Date'].max())\nprint(df_test['Date'].min())","9ccf2b16":"date_filter = df_train['Date'] < df_test['Date'].min()\ndf_train = df_train.loc[date_filter]","1282a170":"# Dropping ID and getting rid of Province\/State with NULL values \ndf_train.info()","84682c02":"# lets get Cumulative sum of ConfirmedCases and Fatalities for each country on each data (same as original data)\n# Doing to create copy without ID and \n\ntrain_country_date = df_train.groupby(['Country\/Region', 'Date', 'Lat', 'Long'], as_index=False)['ConfirmedCases', 'Fatalities'].sum()","e558355e":"print(train_country_date.info())\nprint(train_country_date.isnull().sum())","8dd33dbd":"train_country_date.info()","1d394f69":"# Adding day, month, day of week columns \n\ntrain_country_date['Month'] = train_country_date['Date'].dt.month\ntrain_country_date['Day'] = train_country_date['Date'].dt.day\ntrain_country_date['Day_Week'] = train_country_date['Date'].dt.dayofweek\ntrain_country_date['quarter'] = train_country_date['Date'].dt.quarter\ntrain_country_date['dayofyear'] = train_country_date['Date'].dt.dayofyear\ntrain_country_date['weekofyear'] = train_country_date['Date'].dt.weekofyear","7706cd40":"train_country_date.head()","529fde03":"train_country_date.info()","5a711cdf":"# First drop Province\/State\ndf_test.drop('Province\/State', axis = 1, inplace = True)\n\n# Converting Date Object to Datetime type\n\ndf_test.Date = pd.to_datetime(df_test['Date'])\ndf_test.head(2)","79fa8a6f":"# adding Month, DAy, Day_week columns Using Pandas Series.dt.month\n\ndf_test['Month'] = df_test['Date'].dt.month\ndf_test['Day'] = df_test['Date'].dt.day\ndf_test['Day_Week'] = df_test['Date'].dt.dayofweek\ndf_test['quarter'] = df_test['Date'].dt.quarter\ndf_test['dayofyear'] = df_test['Date'].dt.dayofyear\ndf_test['weekofyear'] = df_test['Date'].dt.weekofyear","0b425ba2":"df_test.info()","a8488e14":"# train_country_date\n# df_test\n# Lets select the Common Labels and concatenate.\n\nlabels = ['Country\/Region', 'Lat', 'Long', 'Date', 'Month', 'Day', 'Day_Week','quarter', 'dayofyear', 'weekofyear']\n\ndf_train_clean = train_country_date[labels]\ndf_test_clean = df_test[labels]\n\ndata_clean = pd.concat([df_train_clean, df_test_clean], axis = 0)","27596544":"data_clean.info()","3d3b1bdd":"from sklearn.preprocessing import LabelEncoder","92f03f3d":"# Label Encoder for Countries \n\nenc = LabelEncoder()\ndata_clean['Country'] = enc.fit_transform(data_clean['Country\/Region'])\ndata_clean","e67d3158":"# Dropping Country\/Region and Date\n\ndata_clean.drop(['Country\/Region', 'Date'], axis = 1, inplace=True)","54b1f5ff":"index_split = df_train.shape[0]\ndata_train_clean = data_clean[:index_split]","e2c603f3":"data_test_clean = data_clean[index_split:]","ce217c1a":"data_train_clean.tail(5)","eb73e71c":"x = data_train_clean[['Lat', 'Long', 'Month', 'Day', 'Day_Week','quarter', 'dayofyear', 'weekofyear', 'Country']]\ny_case = df_train['ConfirmedCases']\ny_fatal = df_train['Fatalities']","089b9351":"from sklearn.model_selection import train_test_split\n\nx_train, x_test, y_train, y_test = train_test_split(x, y_case, test_size = 0.3, random_state = 42)","bfabe1d1":"from sklearn.model_selection import train_test_split\n\nx_train_fatal, x_test_fatal, y_train_fatal, y_test_fatal = train_test_split(x, y_fatal, test_size = 0.3, random_state = 42)","7605f4f9":"from sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error","dc2715e3":"rf = RandomForestRegressor(n_estimators =100)\nrf.fit(x_train, y_train.values.ravel())","01e43af2":"rf.score(x_train, y_train)","8556c080":"rf.score(x_test, y_test)","7130590e":"# Predicted Values and MSE\ny_pred_train = rf.predict(x_train)\nprint(mean_squared_error(y_train, y_pred_train))","c922c96a":"# Training on entire set and predict values.\n\nrf.fit(x, y_case.values.ravel())","43d7feb5":"# Predicted ConfirmedCases\nrf_pred_case = rf.predict(data_test_clean)","2b71f180":"plt.figure(figsize=(15,8))\nplt.plot(rf_pred_case)","fc176350":"rf.fit(x, y_fatal.values.ravel())","d5d07100":"rf_pred_fatal = rf.predict(data_test_clean)","4fbb5a3f":"plt.figure(figsize=(20,8))\nplt.plot(rf_pred_fatal)","ac908cc7":"# Saving to Submission.csv\n\n#submission = pd.read_csv(path_sbumit)\n#submission['ConfirmedCases'] = rf_pred_case\n#submission['Fatalities'] = rf_pred_fatal\n\n#submission.to_csv('submission.csv', index = False)","760d8572":"import xgboost as xgb\nfrom sklearn.metrics import mean_squared_error","093e7620":"reg = xgb.XGBRegressor(n_estimators=1000)","ab701a73":"reg.fit(x_train, y_train)","43e5bf28":"reg.score(x_train, y_train)","54ca0b9c":"reg_y_pred = reg.predict(x_train)","1130a6a0":"mean_squared_error(y_train, reg_y_pred)","11f38b7e":"reg.score(x_test, y_test)","cc8bad47":"# Slightly Better than Random Forest \nreg_y_test_pred = reg.predict(x_test)\nmean_squared_error(y_test, reg_y_test_pred)","a9bf7ba7":"reg.fit(x, y_case)","ed32d75e":"y_train_pred = reg.predict(x)","77c9207c":"plt.plot(y_case)","8fa0938a":"plt.plot(y_train_pred)","4395bb9f":"mean_squared_error(y_case, y_train_pred)","171e857c":"xgb_pred_case = reg.predict(data_test_clean)","479dc666":"plt.plot(xgb_pred_case)","fce072cb":"reg.fit(x, y_fatal)","c747843a":"# Checking MSE for Fatalities\n\nprint(mean_squared_error(y_fatal, reg.predict(x)))","97ceb5c6":"plt.plot(reg.predict(x))","68c0cb64":"plt.plot(y_fatal)","a46df9ce":"xgb_pred_fatal = reg.predict(data_test_clean)","0551f4ac":"plt.plot(xgb_pred_fatal)","f05cd42e":"# Saving to Submission.csv\n\nsubmission = pd.read_csv(submit_kaggle)\nsubmission['ConfirmedCases'] = xgb_pred_case\nsubmission['Fatalities'] = xgb_pred_fatal\n\nsubmission.to_csv('submission.csv', index = False)","031b3b6c":"### Date Range for the Dataset ","34d3febd":"### Checking Daily Worldwide Confirmed Cases and Fatalities ","20fe6b34":"### Check Confirmed cases and fatalities for a country \nscale = \"linear\", \"log\"","17ae1b5d":"#### Councatenating Train-Test to Label encode Country\/Region Categorical Variable.\n1. Make copy of train data without Confirmed Cases and Fatalities. Index - 0 to 17608\n2. Concatenate train, test.\n3. Label Encode Countries.\n4. Add back Cofirmed Cases, Fatalities columns to clean_train_data.\n5. Modelling\n6. Saving Predicted Values with ForecastID","22987419":"# Beginner Attempt:\n<p>\nThis is an attempt at performing some EDA and predicting ConfirmedCases and Fatalities using a RandomForest, XGBoost Regressor model. <br>\n    There is overlapping Data in the Test and Train sets, predicting without the overlap predictably results in a lower score. <br> \n    Will appreciate any advice.\n    ","de0f5fdf":"#### For Fatalities","56607d74":"#### For ConfirmedCases","d28587f2":"#### Fatalities and Confirmed Cases by Country (Log Scale)","3002cbd0":"#### For Fatalities","e8a7792b":"### Adding Back Confirmed Cases and Fatalities\nUsing original df_train, check shape is same, head, tail have same values. ORDER NEEDS TO BE SAME.","d790bc97":"### Train-Test Split - Fatalities","61b7b83b":"#### Predict on Test Set","82407ab7":"## EDA","ba096a4f":"### Train-Test Split - Confirmed Cases","69e7553d":"### Splitting Back into Train and Test","af8da3ae":"### Unique countries in the dataset ","699c6c0f":"## 5. XGBoost Regressor\n<p> With Leaky Data - Train MSE <br>\nSubmission RMSLE -  <\/p>\n<p> Without Leaky Data - Train MSE 10064.67200159855, 4.047602533022124 <br>\n    Submission RMSLE - 2.27873 <\/p>","880bd4ad":"### Visualising predictions error on entire train set","a6569674":"### Creating Features and Two Labels","c8cada32":"#### No. of Cases on a Particular Day, (Not Increase, Cumulative)","9773679b":"#### Using Pandas Series.dt.month\nThe month as January=1, December=12.","26703995":"###  Most Affected Countries","bbbf719e":"#### Same Feature Engineering for Test Set","64a927b4":"### Need to Exclude Leaky Data, the same Dates are in both train and test set.\n1. First convert object to python datetime type <br>\nUsing pd.to_datetime() <br>\nCheck Getting converted to float, because haven't converted to date before comparison, still object.","55bf8d38":"## About the Data \n1. Contains Daily Reports of Number of Cases and Fatalities for countries.\n2. [Missing Data]Contains some entries with Province\/State Information Missing - Dropped.\n3. Contains latitude and longitude for entries, Can Plot on map.\n4. Date - 22nd Feb to 23nd March. (Getting Updated Continuosly)\n5. Country\/Region - 163","ad8aea04":"### Truncate df_train by date < df_test['Date'].min()","f790ee4b":"#### For ConfirmedCases","a320d264":"## Preparing Data For Models - LabelEncode Country","463ac775":"## Modeling - Regression Problem \nUsing features Country\/Region, Lat, Long, Month, Day, Day_week, quarter, dayofyear, weekofyear.<br>\nTo predict ConfirmedCases, Fatalities.\n### To predict 2 Different Target Variables, Train two classifiers, one for each.","1ea4c648":"# Modelling\n1. Linear Regression - Worse than baseline model. \n2. Logistic Regression (Will need GridSearchCV for Max_iter) - Absolute Trash.\n3. Polynomial Regression - Not Tried\n4. SVM Regressor - Very bad performance with a poly kernel and some variation of c and eta. (read up more)\n4. RandomForest Regressor - Gives 1.7 RMSE, With data leak removed gives - 2.18417 RMSE.\n5. GradientBoost Regressor - Gives slightly lower performance than RF","d8f51db6":"# Data Wrangling\/ Pre-processing\/ Cleaning \n1. Identifying and Handling missing values.\n2. Data Formating.\n3. Data Normalization(centering and scaling).\n4. Data bining.\n5. Turning categorical values into numerical values.","b25cf6eb":"## 3. RandomForest Regressor\n<p> With Leaky Data - Train MSE 284698.84113318456 <br>\nSubmission RMSLE - 1.70407 <\/p>\n<p> Without Leaky Data - Test MSE 291078.15156607644 <br>\n    Submission RMSLE - 2.18417 <\/p>","05ae5b26":"### Feature Engineering\nSplitting Date into day, month, day of week. <br>\nCheck if Date is in python datetime format. Else, convert object to python datetime type <br>\nUsing pd.to_datetime()"}}