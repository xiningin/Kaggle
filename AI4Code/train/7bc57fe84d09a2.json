{"cell_type":{"5d5353d4":"code","b869c534":"code","e6f9a904":"code","f314ea5c":"code","c1a04941":"code","523a4b83":"code","a0671c14":"code","74a689b5":"code","dcd196d3":"code","dadf8d45":"code","f8b58aad":"code","c7f32f53":"code","bc1e365d":"code","eb735679":"code","10a4d65e":"code","38c937e0":"code","698d3de5":"code","1c4ecc54":"code","0428d4c9":"code","d83abcc6":"code","9e5f98c1":"code","3c7c6ecf":"code","0c03af99":"markdown","c30d6026":"markdown","de6163c9":"markdown","d177297d":"markdown","6b65febc":"markdown","fe82eae6":"markdown","fb515cc1":"markdown","7233dfc0":"markdown","f616917a":"markdown","eac83015":"markdown","1948385b":"markdown","e2151007":"markdown","70e3ae7f":"markdown","15f5385f":"markdown","2cbc4622":"markdown","e0fa4bed":"markdown","97b45a51":"markdown","d7d1b523":"markdown","277150f0":"markdown","cbc68a38":"markdown","eaac1a5c":"markdown","67743a8f":"markdown","46c2baac":"markdown","87966889":"markdown","0e0fbf67":"markdown","6e20750c":"markdown","dedb7bcd":"markdown","f5209978":"markdown","10ec523a":"markdown","29988b20":"markdown","44aec9ec":"markdown","fa3f470a":"markdown","10e11cd2":"markdown","b08186f6":"markdown","fdc5104f":"markdown","c9768faf":"markdown","e3746374":"markdown","573dd685":"markdown","77d3f8a7":"markdown","48d2bbe2":"markdown","0443baf9":"markdown","57ca05a4":"markdown"},"source":{"5d5353d4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b869c534":"import numpy as np\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Activation, Dense, Flatten, BatchNormalization, Conv2D, MaxPool2D\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.metrics import categorical_crossentropy\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import KFold\nimport itertools\nimport os\nimport shutil\nimport random\nimport glob\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n%matplotlib inline","e6f9a904":"train_path = '\/kaggle\/input\/cat-and-dog\/training_set\/training_set'\n# valid_path = 'data\/dogs-vs-cats\/valid'\ntest_path = '..\/input\/cat-and-dog\/test_set\/test_set'","f314ea5c":"train_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \\\n    .flow_from_directory(directory=train_path, target_size=(224,224), classes=['cats', 'dogs'], batch_size=10)\ntest_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \\\n    .flow_from_directory(directory=test_path, target_size=(224,224), classes=['cats', 'dogs'], batch_size=10, shuffle=False)","c1a04941":"imgs, labels = next(train_batches)","523a4b83":"def plotImages(images_arr):\n    fig, axes = plt.subplots(1, 10, figsize=(20,20))\n    axes = axes.flatten()\n    for img, ax in zip( images_arr, axes):\n        ax.imshow(img)\n        ax.axis('off')\n    plt.tight_layout()\n    plt.show()","a0671c14":"plotImages(imgs)\nprint(labels)","74a689b5":"model = Sequential([\n    Conv2D(filters=32, kernel_size=(3, 3), activation='relu', padding = 'same', input_shape=(224,224,3)),\n    MaxPool2D(pool_size=(2, 2), strides=2),\n    Conv2D(filters=64, kernel_size=(3, 3), activation='relu', padding = 'same'),\n    MaxPool2D(pool_size=(2, 2), strides=2),\n    Flatten(),\n    Dense(units=2, activation='softmax')\n])","dcd196d3":"model.summary()","dadf8d45":"model.compile(optimizer=Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])","f8b58aad":"model.fit(x=train_batches, epochs=5, verbose=2)","c7f32f53":"model.save('my_model.h5')\n!ls","bc1e365d":"test_imgs, test_labels = next(test_batches)","eb735679":"plotImages(test_imgs)\nprint(test_labels)","10a4d65e":"predictions = model.predict(x=test_batches, verbose=0)","38c937e0":"np.round(predictions)","698d3de5":"cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.argmax(predictions, axis=-1))","1c4ecc54":"cm","0428d4c9":"def plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n            horizontalalignment=\"center\",\n            color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","d83abcc6":"test_batches.class_indices","9e5f98c1":"cm_plot_labels = ['cat','dog']\nplot_confusion_matrix(cm=cm, classes=cm_plot_labels, title='Confusion Matrix')","3c7c6ecf":"no_classes = 100\nno_epochs = 5\n# optimizer = Adam()\nverbosity = 1\nnum_folds = 5\n# Define per-fold score containers\nacc_per_fold = []\nloss_per_fold = []\n\n# Define the K-fold Cross Validator\nkfold = KFold(n_splits=num_folds, shuffle=True)\n\n# K-fold Cross Validation model evaluation\nfold_no = 1\nfor train, test in kfold.split(imgs, labels):\n\n  # Define the model architecture\n    model = Sequential([\n    Conv2D(filters=32, kernel_size=(3, 3), activation='relu', padding = 'same', input_shape=(224,224,3)),\n    MaxPool2D(pool_size=(2, 2), strides=2),\n    Conv2D(filters=64, kernel_size=(3, 3), activation='relu', padding = 'same'),\n    MaxPool2D(pool_size=(2, 2), strides=2),\n    Flatten(),\n    Dense(units=2, activation='softmax')])\n\n  # Compile the model\n    model.compile(optimizer=Adam(learning_rate=0.0001),\n                  loss='categorical_crossentropy', metrics=['accuracy'])\n\n\n  # Generate a print\n    print('------------------------------------------------------------------------')\n    print(f'Training for fold {fold_no} ...')\n\n  # Fit data to model\n    history = model.fit(x=train_batches, epochs=5, verbose=2)\n\n  # Generate generalization metrics\n    scores = model.evaluate(imgs[test], labels[test], verbose=0)\n    print(f'Score for fold {fold_no}: {model.metrics_names[0]} of {scores[0]}; {model.metrics_names[1]} of {scores[1]*100}%')\n    acc_per_fold.append(scores[1] * 100)\n    loss_per_fold.append(scores[0])\n\n  # Increase fold number\n    fold_no = fold_no + 1\n\n# == Provide average scores ==\nprint('------------------------------------------------------------------------')\nprint('Score per fold')\nfor i in range(0, len(acc_per_fold)):\n    print('------------------------------------------------------------------------')\n    print(f'> Fold {i+1} - Loss: {loss_per_fold[i]} - Accuracy: {acc_per_fold[i]}%')\nprint('------------------------------------------------------------------------')\nprint('Average scores for all folds:')\nprint(f'> Accuracy: {np.mean(acc_per_fold)} (+- {np.std(acc_per_fold)})')\nprint(f'> Loss: {np.mean(loss_per_fold)}')\nprint('------------------------------------------------------------------------')\n","0c03af99":"The first layer in the model is a 2-dimensional convolutional layer. This layer will have `32` output filters each with a kernel size of `3x3`, and we\u2019ll use the `relu` activation function.\n\nNote that the choice for the number of output filters specified is arbitrary, and the chosen kernel size of `3x3` is generally a very common size to use. You can experiment by choosing different values for these parameters.\n\nWe enable zero-padding by specifying `padding = 'same'`.\n\nOn the first layer only, we also specify the `input_shape`, which is the shape of our data. Our images are `224` pixels high and `224` pixels wide and have `3` color channels: RGB. This gives us an `input_shape` of `(224,224,3)`.\n\nWe then add a `max pooling` layer to pool and reduce the dimensionality of the data.\n\nWe follow this by adding another convolutional layer with the exact specs as the earlier one, except for this second `Conv2D` layer has `64` filters. The choice of 64 here is again arbitrary, but the general choice of having more filters in later layers than in earlier ones is common. This layer is again followed by the same type of `MaxPool2D` layer\n\nWe then `Flatten` the output from the convolutional layer and pass it to a `Dense` layer. This `Dense` layer is the output layer of the network, and so it has `2` nodes, one for cat and one for dog. We\u2019ll use the `softmax` activation function on our output so that the output for each sample is a probability distribution over the outputs of cat and dog.\n\nWe can check out a summary of the model by calling `model.summary()`.","c30d6026":"We\u2019ll now run `next(test_batches)` to extract a batch of images and their corresponding labels from the test set.","de6163c9":"Just as we saw before, cats are labeled with a one-hot encoding of `[1,0]`, and dogs are labeled as `[0,1]`.\n\nNote, because we chose to not shuffle our test set when we originally created it, the first half of the test data is all cats, and the second half is all dogs. Also, recall that the color data appears skewed due to the VGG16 preprocessing we specified when we created the data sets.","d177297d":"Now that we have a general understanding for how to build and work with a CNN using Keras, we'll now move on to working with a pre-trained model on this data set, which we will see will generalize much better!","6b65febc":"Note that when we have only two classes, we could instead configure our output layer to have only one output, rather than two, and use `binary_crossentropy` as our loss, rather than `categorical_crossentropy`. Both options work equally well and achieve the exact same result.\n\nWith `binary_crossentropy`, however, the last layer would need to use <font color='orange'>sigmoid<\/font>, rather than <font color='dark pink'>softmax<\/font>, as its activation function.","fe82eae6":"Using the `plotImages()` function we previously introduced, we can see what this batch of test data looks like","fb515cc1":"### <font color = 'green'>Preparing the Test Data<\/font>","7233dfc0":"We\u2019re now all set up to work with this data!, we\u2019ll now use this data to train a convolutional neural network.","f616917a":"Now it\u2019s time to train the model.\n\nWe've already introduced the `model.fit()` function to train a model in above cells. We'll be using it in the same fashion here, except for now, we'll be passing in our newly introduced `DirectoryIterators` `train_batches`to train the model.","eac83015":"We can then inspect the `class_indices` for the labels so that we know in which order to pass them to our confusion matrix.","1948385b":"# Build A Simple CNN","e2151007":"We\u2019re specifying `5` as the number of `epochs` we\u2019d like to run, and setting the `verbose` parameter to `2`, which just specifies the verbosity of the log output printed to the console during training.","70e3ae7f":"After running the predictions, we can print our the rounded predictions see what they look like.","15f5385f":"This is what the first processed random batch from the training set looks like. Notice that the color appears to be distorted. This has to do with the VGG16 processing we applied to the data sets, which we'll talk about in few minutes. Don't worry about it for now, just know that the RGB pixel data has been processed in such a way that the image data now looks like this before being passed to the network.","2cbc4622":"To build the CNN, we\u2019ll use a Keras Sequential model. Recall, we first introduced a Sequential model in an earlier [tutorial](https:\/\/www.kaggle.com\/bavalpreet26\/keras-nb1)","e0fa4bed":"these all tutorials are inspired from this [channel](https:\/\/www.youtube.com\/watch?v=LhEMXbjGV_4&list=PLZbbT5o_s2xrwRnXk_yCPtnqqo4_u2YGL&index=11)","97b45a51":"We then use this plotting function obtained from `TensorFlow's documentation` to plot the processed images within our Jupyter notebook.","d7d1b523":"To get a better visualization of these results, we\u2019ll plot them in a confusion matrix.","277150f0":"Now we\u2019ll use our previously built model and call model.predict() to have the model predict on the test set.","cbc68a38":"From this output, we can see the performance of this simple model on the training set is great, with accuracy reaching almost 100% and loss nearing almost 0,we can see that our model is vastly overfitting the training data.\n\nAt this point, we could continue to work on this model to combat overfitting, or we could try another approach of using a pre-trained model on this data. We'll explore the latter in the upcoming cells.","eaac1a5c":"# optional - how to do cross validation?","67743a8f":"### <font color = 'green'>Preparing the Train Data<\/font>","46c2baac":"Note, we can access the unshuffled true labels for the test set by calling `test_batches.classes`.","87966889":"We transform the one-hot encoded predicted labels to be in the same format as the true labels by only selecting the element with the highest value for each prediction using `np.argmax(predictions, axis=-1)`.","0e0fbf67":"Libraries","6e20750c":"We can see that the model correctly predicted that an image was a cat `620` times when it actually was a cat, and it incorrectly predicted that an image was a cat `391` times when it was not a cat. It correctly predicted that an image was a dog `768` times, and incorrectly predicted that an image was a dog `244` times.","dedb7bcd":"# Visualize the data\n\nWe now call `next(train_batches)` to generate a batch of images and labels from the training set. Note that the size of this batch is determined by the `batch_size` we set when we created `train_batches`.","f5209978":"# Train A Simple CNN","10ec523a":"To the confusion matrix, we pass the true labels of the test set, along with the predicted labels for the test set from the model.","29988b20":"#### Finally, we plot the confusion matrix.","44aec9ec":"This is part 2 for keras series click here for [part1](https:\/\/www.kaggle.com\/bavalpreet26\/keras-nb1)","fa3f470a":"1. <font color='red'>ImageDataGenerator.flow_from_directory()<\/font> creates a DirectoryIterator, which generates batches of normalized tensor image data from the respective data directories.\n2. Notice, to ImageDataGenerator for each of the data sets, we specify <font color='red'>preprocessing_function=tf.keras.applications.vgg16.preprocess_input<\/font>. For now, just understand this does an additional processing step on the images. We'll cover what exactly this processing is when we work with the pre-trained VGG16 CNN in a future episode.\n3. To <font color = 'red'>flow_from_directory()<\/font>, we first specify the path for the data. We then specify the target_size of the images, which will resize all images to the specified size. The size we specify here is determined by the input size that the neural network expects.\n4. The <font color = 'red'>classes<\/font> parameter expects a list that contains the underlying class names, and lastly, we specify the batch_size.\n5. We also specify <font color = 'red'>shuffle=False<\/font> only for <font color = 'red'>test_batches<\/font>. That's because, later when we plot the evaluation results from the model to a <font color = 'red'>confusion matrix<\/font>,we'll need to able to access the unshuffled labels for the test set. By default, the data sets are shuffled\n6. <font color = 'blue'>Note, in the case where you do not know the labels for the test data, you will need to modify the `test_batches` variable. Specifically, the change will be to set the parameters `classes = None` and `class_mode = None` in `flow_from_directory()`.<\/font>","10e11cd2":"Note that dogs are represented with the `one-hot encoding` of `[0,1]`, and cats are represented by `[1,0]`","b08186f6":"These are the labels that the model is predicting for our images.","fdc5104f":"# Plotting Predictions With A Confusion Matrix","c9768faf":"# Make Predictions With A Keras CNN Image Classifier","e3746374":"We create the confusion matrix using `scikit-learn`","573dd685":"# Predicting On The Test Data","77d3f8a7":"![](https:\/\/keras.io\/img\/logo.png)","48d2bbe2":"Now that the model is built, we `compile` the model using the `Adam optimizer` with a learning rate of `0.0001`, a loss of `categorical_cross_entropy`, and we\u2019ll look at `accuracy` as our performance metric. ","0443baf9":"We now use the plot_confusion_matrix() function that is copied directly from scikit-learn","57ca05a4":"We pass in the test set, `test_batches`, and set `verbose=0` to see no output during the evaluation process."}}