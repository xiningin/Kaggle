{"cell_type":{"90a776ff":"code","9f5f3099":"code","3e4cc21f":"code","882cf35a":"code","746640d5":"code","6c9534d1":"code","f0e9930a":"code","aa132720":"code","0d8a0b83":"code","205f9d62":"code","a708323c":"code","b180cf09":"code","96499776":"code","034347f3":"code","8533792b":"code","d4af88df":"code","49bde7ba":"code","6c099cb3":"code","580ca068":"code","762d3115":"code","81dcb1c6":"code","ca4fcd2b":"code","375fe33e":"code","aecc4c68":"code","f93aa6d8":"code","b9fadf1c":"code","dfe3a0de":"markdown"},"source":{"90a776ff":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\noutfile = open('out.txt','w')\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        outfile.write(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9f5f3099":"import os\nimport cv2\nfrom os import listdir\nfrom os.path import isfile, join\nimport matplotlib.pyplot as plt\nimport os\nfrom os import listdir\nfrom os.path import isfile, join","3e4cc21f":"os.makedirs('Out\/')","882cf35a":"n = 20","746640d5":"l = 1\n\nmypath = \"\/kaggle\/input\/maize-seed\/dataset\/dataset\/training_set\/Worst\/\"\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n\n\nprint(len(onlyfiles))\n\nfor f in onlyfiles:\n    f1 = mypath + f\n    #print(f1)\n    image = cv2.imread(f1)\n    img_h, img_w = image.shape[:2]\n    bl_w, bl_h = 612, 612\n    for i in range(int(img_h\/bl_h)):\n        for j in range(int(img_w\/bl_w)):\n            cropped = image[i*bl_h:(i+1)* bl_h-100, j*bl_w:(j+1)*bl_w-100]\n            cv2.imwrite(\"\/kaggle\/working\/Out\/{}_t.png\".format(str(l)), cropped, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n            l += 1\n    if l > n*16:\n        break","6c9534d1":"mypath = \"\/kaggle\/working\/Out\/\"\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n\n\nprint(len(onlyfiles))\n","f0e9930a":"# Split \n\nl = len(onlyfiles)+1\nl1 = l\nmypath = \"\/kaggle\/input\/maize-seed\/dataset\/dataset\/training_set\/Excellent\/\"\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n\n\nprint(len(onlyfiles))\n\nfor f in onlyfiles:\n    f1 = mypath + f\n    #print(f1)\n    image = cv2.imread(f1)\n    img_h, img_w = image.shape[:2]\n    bl_w, bl_h = 612, 612\n    for i in range(int(img_h\/bl_h)):\n        for j in range(int(img_w\/bl_w)):\n            cropped = image[i*bl_h:(i+1)* bl_h-100, j*bl_w:(j+1)*bl_w-100]\n            cv2.imwrite(\"\/kaggle\/working\/Out\/{}_t.png\".format(str(l)), cropped, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n            l += 1\n    if l > 2*n*16:\n        break","aa132720":"import cv2\nimport numpy as np\n\nimg = cv2.imread(\"\/kaggle\/working\/Out\/2_t.png\")\n## displaying data loaded by our function\nprint(img)","0d8a0b83":"import cv2\nimport numpy as np\n\nimg = cv2.imread(\"\/kaggle\/working\/Out\/2_t.png\")\n\nhsv_min = np.array((54, 99, 0), np.uint8)\nhsv_max = np.array((255, 255, 255), np.uint8)\n\n\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV )\nthresh = cv2.inRange(hsv, hsv_min, hsv_max)\n\n#cv2.imshow('result', thresh)\n\n#cv2.imwrite(\"C:\/Users\/Machenike\/demoEnv\/GAN\/Maize\/Mask\/0_t.png\", thresh, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n\nr = g = ~np.zeros((512, 512),dtype=np.uint8)\n\n\n\nfor l1 in range(1,321):\n    in1 = \"\/kaggle\/working\/Out\/\" + str(l1) +\"_t.png\"\n    img = cv2.imread(in1)\n\n\n\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV )\n    thresh = cv2.inRange(hsv, hsv_min, hsv_max)\n\n    \n\n    #cv2.imshow('result', thresh)\n    imgMerged = cv2.merge((thresh,thresh,r))\n    imgMerged = ~imgMerged\n    out1 = \"\/kaggle\/working\/Out\/\" + str(l1) + \"_i2.png\"\n    cv2.imwrite(out1, imgMerged, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n\n\n","205f9d62":"import cv2\nimport numpy as np\n\nimg = cv2.imread(\"\/kaggle\/working\/Out\/1_t.png\")\n\nhsv_min = np.array((54, 99, 0), np.uint8)\nhsv_max = np.array((255, 255, 255), np.uint8)\n\n\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV )\nthresh = cv2.inRange(hsv, hsv_min, hsv_max)\n\n#cv2.imshow('result', thresh)\n\n#cv2.imwrite(\"C:\/Users\/Machenike\/demoEnv\/GAN\/Maize\/Mask\/0_t.png\", thresh, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n\nr = g = ~np.zeros((512, 512),dtype=np.uint8)\n\n\n\nfor l1 in range(320,641):\n    in1 = \"\/kaggle\/working\/Out\/\" + str(l1) +\"_t.png\"\n    img = cv2.imread(in1)\n\n\n\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV )\n    thresh = cv2.inRange(hsv, hsv_min, hsv_max)\n\n    \n\n    #cv2.imshow('result', thresh)\n    imgMerged = cv2.merge((r,thresh,r))\n    imgMerged = ~imgMerged\n    out1 = \"\/kaggle\/working\/Out\/\" + str(l1) + \"_i2.png\"\n    cv2.imwrite(out1, imgMerged, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n\n\n","a708323c":"## Making essential imports\nimport os\nimport numpy as np\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\nimport cv2\nimport tensorflow as tf","b180cf09":"## defining a frame for image and mask storage\nframObjTrain = {'img' : [],\n           'mask' : []\n          }\n\n## defining data Loader function\ndef LoadData( frameObj = None, imgPath = None, maskPath = None, shape = 128):\n    imgNames = os.listdir(imgPath)\n    \n    names = []\n    maskNames = []\n    unames = []\n    \n    for i in range(len(imgNames)):\n        unames.append(imgNames[i].split('_')[0])\n    \n    unames = list(set(unames))\n    \n    for i in range(len(unames)):\n        names.append(unames[i]+'_t.png')\n        maskNames.append(unames[i]+'_i2.png')\n    \n    imgAddr = imgPath + '\/'\n    maskAddr = maskPath + '\/'\n    \n    for i in range (len(names)):\n        img = plt.imread(imgAddr + names[i])\n        mask = plt.imread(maskAddr + maskNames[i])\n        \n        img = cv2.resize(img, (shape, shape)) \n        mask = cv2.resize(mask, (shape, shape))\n        \n        frameObj['img'].append(img)\n        frameObj['mask'].append(mask)\n        \n    return frameObj","96499776":"framObjTrain = LoadData( framObjTrain, imgPath = '\/kaggle\/working\/Out'\n                        , maskPath = '\/kaggle\/working\/Out'\n                         , shape = 128)","034347f3":"## displaying data loaded by our function\nplt.figure(figsize = (7, 5))\nplt.subplot(1,2,1)\nplt.imshow(framObjTrain['img'][14])\nplt.subplot(1,2,2)\nplt.imshow(framObjTrain['mask'][14])\nplt.show()","8533792b":"# this block essentially performs 2 convolution\n\ndef Conv2dBlock(inputTensor, numFilters, kernelSize = 3, doBatchNorm = True):\n    #first Conv\n    x = tf.keras.layers.Conv2D(filters = numFilters, kernel_size = (kernelSize, kernelSize),\n                              kernel_initializer = 'he_normal', padding = 'same') (inputTensor)\n    \n    if doBatchNorm:\n        x = tf.keras.layers.BatchNormalization()(x)\n        \n    x =tf.keras.layers.Activation('relu')(x)\n    \n    #Second Conv\n    x = tf.keras.layers.Conv2D(filters = numFilters, kernel_size = (kernelSize, kernelSize),\n                              kernel_initializer = 'he_normal', padding = 'same') (x)\n    if doBatchNorm:\n        x = tf.keras.layers.BatchNormalization()(x)\n        \n    x = tf.keras.layers.Activation('relu')(x)\n    \n    return x\n\n\n# Now defining Unet \ndef GiveMeUnet(inputImage, numFilters = 16, droupouts = 0.1, doBatchNorm = True):\n    # defining encoder Path\n    c1 = Conv2dBlock(inputImage, numFilters * 1, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p1 = tf.keras.layers.MaxPooling2D((2,2))(c1)\n    p1 = tf.keras.layers.Dropout(droupouts)(p1)\n    \n    c2 = Conv2dBlock(p1, numFilters * 2, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p2 = tf.keras.layers.MaxPooling2D((2,2))(c2)\n    p2 = tf.keras.layers.Dropout(droupouts)(p2)\n    \n    c3 = Conv2dBlock(p2, numFilters * 4, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p3 = tf.keras.layers.MaxPooling2D((2,2))(c3)\n    p3 = tf.keras.layers.Dropout(droupouts)(p3)\n    \n    c4 = Conv2dBlock(p3, numFilters * 8, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p4 = tf.keras.layers.MaxPooling2D((2,2))(c4)\n    p4 = tf.keras.layers.Dropout(droupouts)(p4)\n    \n    c5 = Conv2dBlock(p4, numFilters * 16, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    # defining decoder path\n    u6 = tf.keras.layers.Conv2DTranspose(numFilters*8, (3, 3), strides = (2, 2), padding = 'same')(c5)\n    u6 = tf.keras.layers.concatenate([u6, c4])\n    u6 = tf.keras.layers.Dropout(droupouts)(u6)\n    c6 = Conv2dBlock(u6, numFilters * 8, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    u7 = tf.keras.layers.Conv2DTranspose(numFilters*4, (3, 3), strides = (2, 2), padding = 'same')(c6)\n    \n    u7 = tf.keras.layers.concatenate([u7, c3])\n    u7 = tf.keras.layers.Dropout(droupouts)(u7)\n    c7 = Conv2dBlock(u7, numFilters * 4, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    u8 = tf.keras.layers.Conv2DTranspose(numFilters*2, (3, 3), strides = (2, 2), padding = 'same')(c7)\n    u8 = tf.keras.layers.concatenate([u8, c2])\n    u8 = tf.keras.layers.Dropout(droupouts)(u8)\n    c8 = Conv2dBlock(u8, numFilters * 2, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    u9 = tf.keras.layers.Conv2DTranspose(numFilters*1, (3, 3), strides = (2, 2), padding = 'same')(c8)\n    u9 = tf.keras.layers.concatenate([u9, c1])\n    u9 = tf.keras.layers.Dropout(droupouts)(u9)\n    c9 = Conv2dBlock(u9, numFilters * 1, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    output = tf.keras.layers.Conv2D(3, (1, 1), activation = 'sigmoid')(c9)\n    model = tf.keras.Model(inputs = [inputImage], outputs = [output])\n    return model","d4af88df":"## instanctiating model\ninputs = tf.keras.layers.Input((128, 128, 3))\nmyTransformer = GiveMeUnet(inputs, droupouts= 0.07)\nmyTransformer.compile(optimizer = 'Adam', loss = 'binary_crossentropy', metrics = ['accuracy'] )","49bde7ba":"retVal = myTransformer.fit(np.array(framObjTrain['img']), np.array(framObjTrain['mask']), epochs = 1000, verbose = 1, batch_size=32)","6c099cb3":"#plt.plot(retVal.history['loss'], label = 'training_loss')\nplt.plot(retVal.history['accuracy'], label = 'training_accuracy')\nplt.legend()\nplt.grid(True)","580ca068":"## function for getting 16 predictions\ndef predict16 (valMap, model, shape = 256):\n    ## getting and proccessing val data\n    img = valMap['img']\n    mask = valMap['mask']\n    mask = mask[0:16]\n    \n    imgProc = img [0:16]\n    imgProc = np.array(img)\n    \n    predictions = model.predict(imgProc)\n    for i in range(len(predictions)):\n        predictions[i] = cv2.merge((predictions[i,:,:,0],predictions[i,:,:,1],predictions[i,:,:,2]))\n    \n    return predictions, imgProc, mask\n\n\ndef Plotter(img, predMask, groundTruth):\n    plt.figure(figsize=(20,10))\n    \n    plt.subplot(1,3,1)\n    plt.imshow(img)\n    plt.title('Maize Image')\n    \n    ## Adding Image sharpening step here\n    ## it is a sharpening filter\n    filter = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]) \n    imgSharpen = cv2.filter2D(predMask,-1,filter)\n    \n    plt.subplot(1,3,2)\n    plt.imshow(predMask)\n    plt.title('Predicted Maize Mask')\n    \n    plt.subplot(1,3,3)\n    plt.imshow(groundTruth)\n    plt.title('Actual Terrain Mask')","762d3115":"for  k in range(1,16):\n    sixteenPrediction, actuals, masks = predict16(framObjTrain, myTransformer)\n    Plotter(actuals[k], sixteenPrediction[k], masks[k])","81dcb1c6":"\nos.makedirs('Test1\/')\n\nn=1","ca4fcd2b":"l = 1\n\nmypath = \"\/kaggle\/input\/maize-seed\/dataset\/dataset\/test_set\/Average\/\"\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n\n\nprint(len(onlyfiles))\n\nfor f in onlyfiles:\n    f1 = mypath + f\n    #print(f1)\n    image = cv2.imread(f1)\n    img_h, img_w = image.shape[:2]\n    bl_w, bl_h = 612, 612\n    for i in range(int(img_h\/bl_h)):\n        for j in range(int(img_w\/bl_w)):\n            cropped = image[i*bl_h:(i+1)* bl_h-100, j*bl_w:(j+1)*bl_w-100]\n            cv2.imwrite(\"\/kaggle\/working\/Test1\/{}_t.png\".format(str(l)), cropped, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n            l += 1\n    if l > n*16:\n        break","375fe33e":"import cv2\nimport numpy as np\n\nimg = cv2.imread(\"\/kaggle\/working\/Test1\/2_t.png\")\n\nhsv_min = np.array((54, 99, 0), np.uint8)\nhsv_max = np.array((255, 255, 255), np.uint8)\n\n\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV )\nthresh = cv2.inRange(hsv, hsv_min, hsv_max)\n\n#cv2.imshow('result', thresh)\n\n#cv2.imwrite(\"C:\/Users\/Machenike\/demoEnv\/GAN\/Maize\/Mask\/0_t.png\", thresh, [cv2.IMWRITE_PNG_COMPRESSION, 9] )\n\nr = g = ~np.zeros((512, 512),dtype=np.uint8)\n\n\n\nfor l1 in range(1,17):\n    in1 = \"\/kaggle\/working\/Test1\/\" + str(l1) +\"_t.png\"\n    img = cv2.imread(in1)\n\n\n\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV )\n    thresh = cv2.inRange(hsv, hsv_min, hsv_max)\n\n    \n\n    #cv2.imshow('result', thresh)\n    imgMerged = cv2.merge((thresh,thresh,r))\n    imgMerged = ~imgMerged\n    out1 = \"\/kaggle\/working\/Test1\/\" + str(l1) + \"_i2.png\"\n    cv2.imwrite(out1, imgMerged, [cv2.IMWRITE_PNG_COMPRESSION, 9] )","aecc4c68":"## defining a frame for image and mask storage\nframObjTrain = {'img' : [],\n           'mask' : []\n          }","f93aa6d8":"framObjTrain = LoadData( framObjTrain, imgPath = '\/kaggle\/working\/Test1'\n                        , maskPath = '\/kaggle\/working\/Test1'\n                         , shape = 128)","b9fadf1c":"for  k in range(1,16):\n    sixteenPrediction, actuals, masks = predict16(framObjTrain, myTransformer)\n    Plotter(actuals[k], sixteenPrediction[k], masks[k])","dfe3a0de":"**This is my first attemp of public notebook :)**\n"}}