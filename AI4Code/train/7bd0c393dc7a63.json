{"cell_type":{"51bd1756":"code","a8ae2614":"code","ed00984f":"code","5f4daeac":"code","ea91742f":"code","663fcd5d":"code","391218e2":"code","5fbf5476":"code","ebdf032f":"code","4d3b8f57":"code","a44fb5f8":"code","7717ff7c":"code","9f66189c":"markdown","703d5bfa":"markdown","c5727e12":"markdown","c2068b0b":"markdown","4e670d8e":"markdown","90a801b2":"markdown","afbf456d":"markdown","6fb44598":"markdown","d63611b1":"markdown","004b2c87":"markdown","cb495865":"markdown","56f80e12":"markdown","212aa6c8":"markdown"},"source":{"51bd1756":"%%time\nimport cudf\n\ntypes = {\n        'row_id': 'int64',\n        'timestamp': 'int64',\n        'user_id': 'int32',\n        'content_id': 'int16',\n        'content_type_id': 'int8',\n        'task_container_id': 'int16',\n        'user_answer': 'int8',\n        'answered_correctly': 'int8',\n        'prior_question_elapsed_time': 'float32',\n        'prior_question_had_explanation': 'int8'\n}\ndatapath = '\/kaggle\/input\/riiid-test-answer-prediction\/train.csv'\n\ntrain_X = cudf.read_csv(datapath, dtype=types)\ntrain_X = train_X[train_X['content_type_id'] == 0]\nfeat_float = train_X.groupby(['user_id', 'content_id'])['answered_correctly'].mean().astype('float32')\nfeat_int = train_X.groupby(['user_id', 'content_id'])['answered_correctly'].count().astype('int16')\n# del train_X\n\nprint('number of keys : ', len(feat_int))\nfeat_float.reset_index().to_csv('user_content_wise_float.csv', index=False)\nfeat_int.reset_index().to_csv('user_content_wise_int.csv', index=False)","a8ae2614":"train_X.user_id.nunique(), train_X.content_id.nunique()","ed00984f":"!pip install memory_profiler\n%load_ext memory_profiler","5f4daeac":"def all_dict():\n    num_user_id = len(feat_float.index.get_level_values(level=0).unique())\n    \n    print('num_user_id :', num_user_id)\n\n    feat_dict = dict()\n    for cnt, (user_id, data) in enumerate(feat_float.groupby(level=0)):\n        df = data.to_frame().to_pandas()\n        feat_dict[user_id] = df.reset_index().drop('user_id',axis=1).set_index('content_id').to_dict()['answered_correctly']\n        del df\n    return feat_dict\n\n%memit feat_dict = all_dict()\ndel feat_dict","ea91742f":"del feat_float, feat_int\n\npath_to_parallelmap_folder = \"\/kaggle\/input\/parallel-hashmap\"\npath_to_cppfile = \"\/kaggle\/input\/pybind11demo\/mydicts.cpp\"\nmodule_name = \"my_module\"","663fcd5d":"!c++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` $path_to_cppfile -I$path_to_parallelmap_folder -o $module_name`python3-config --extension-suffix`","391218e2":"!ls","5fbf5476":"from my_module import my_dict_int, my_dict_float","ebdf032f":"%%time\n%memit user_content_feat_float = my_dict_float(\"\/kaggle\/working\/user_content_wise_float.csv\")","4d3b8f57":"%%time\n%memit user_content_feat_int = my_dict_int(\"\/kaggle\/working\/user_content_wise_int.csv\")","a44fb5f8":"%timeit user_content_feat_int.setval(user_id=5, content_id=16, value=123)\n%timeit user_content_feat_int.getval(user_id=5, content_id=16)\n\nprint(user_content_feat_int.getval(user_id=5, content_id=16))\n\n%timeit user_content_feat_float.setval(user_id=5, content_id=16, value=123.193)\n%timeit user_content_feat_float.getval(user_id=5, content_id=16)\n\nprint(user_content_feat_float.getval(user_id=5, content_id=16))","7717ff7c":"print(user_content_feat_int.getval(user_id=2147482888, content_id=9788))\n\nassert user_content_feat_int.getval(user_id=2147482888, content_id=9788) == user_content_feat_int.getval(2147482888, 9788)","9f66189c":"## positional\/keyword arguments","703d5bfa":"We can use both positional and keyword arguments, thanks to pybind11:","c5727e12":"We first need to compile the cpp file with the following command, and no, I don't fully understand what this long command does neither. See [pybind11 tutorial](https:\/\/pybind11.readthedocs.io\/en\/stable\/basics.html) for details.","c2068b0b":"## Compiling and importing","4e670d8e":"We have a huge dict with the number of keys 86867031, and the estimated RAM usage with Python dict (64-bit float value) is 8588MiB.\n\nIt is hard to put this data on RAM as a usual Python dict, but we can borrow the power of parallel-hashmap implemented in C++ through pybind11 to put it on RAM.","90a801b2":"[The parallel hashmap](https:\/\/github.com\/greg7mdp\/parallel-hashmap) is really RAM-friendly: \n\n* ~700MiB for each 16-bit integer (user_id \u00d7 content_id)-wise feature\n* ~1300MiB for each 32-bit float (user_id \u00d7 content_id)-wise feature","afbf456d":"To instantiate the hash map, we pass the datapath of csv to the constuctor. Then, on C++ side, the csv file is parsed, and the hash map is constructed.\n\nIn ``mydicts.cpp``, I defined two operations:\n\n* ``setval(user_id, content_id, value)`` of my_dict_int\/float \u21d4 ``update({(user_id, content_id): value})`` of Python 3 dict\n* ``getval(user_id, content_id)`` of my_dict_int\/float \u21d4 ``setdefault((user_id, content_id), 0\/0.0)`` of Python 3 dict\n\nThese operations just reflect my taste; you can modify the cpp file (mydicts.cpp) and use any API you prefer.\n\nAlso, you can use any data format (not only csv) if you can parse it on C++ side. You need to modify the constructor in ``mydicts.cpp`` of each class accordingly.","6fb44598":"## Motivation","d63611b1":"Suppose we have (user_id \u00d7 content_id)-wise features saved as csv files:","004b2c87":"Now we can import the classes defined in the cpp file (``mydicts.cpp``).","cb495865":"## memory\/time efficiency","56f80e12":"## How to use","212aa6c8":"Accessing and modifying the value is very fast:"}}