{"cell_type":{"4b8d9246":"code","fe0a0e0b":"code","9e831e8a":"code","4e0174a5":"code","18cf379b":"code","6d7e680d":"code","0779b805":"code","686cc72f":"code","5f8bedd9":"code","9e7bd709":"code","1f6a3bb8":"code","44975aa8":"code","603d32ae":"markdown","b4d8b6c6":"markdown","87061ff1":"markdown","bc39eb53":"markdown"},"source":{"4b8d9246":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O\nimport matplotlib.pyplot as plt # Import matplotlib for data visualisation\nimport seaborn as sns\nimport pandas_profiling as pp\nimport os\nfrom collections import defaultdict\n\n","fe0a0e0b":"print(os.listdir(\"..\/input\"))\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","9e831e8a":"train = pd.read_csv('..\/input\/train.csv')\nsample_df = pd.read_csv(\"..\/input\/sample_submission.csv\")\ntrain.head(), sample_df.head()","4e0174a5":"train['defect'] = train['EncodedPixels'].notnull()\ntrain['ClassId'] = train['ImageId_ClassId'].str[-1:]\ntrain['ImageId'] = train['ImageId_ClassId'].str[:-2]\ntrain = train[['ImageId','ClassId','defect','EncodedPixels']]\ntrain.head()","18cf379b":"# lets create a dict with class id and encoded pixels and group all the defaults per image\ntrain['ClassId_EncodedPixels'] = train.apply(lambda x: (x['ClassId'], x['EncodedPixels']), axis = 1)\ngrouped_EncodedPixels = train.groupby('ImageId')['ClassId_EncodedPixels'].apply(list)\ngrouped_EncodedPixels","6d7e680d":"train_def = train.groupby(['ImageId'])['defect'].sum().astype('uint8').to_frame(name='NumDef').reset_index()\ntrain_def","0779b805":"labels, counts = np.unique(train_def.NumDef, return_counts=True)\nplt.bar(labels, counts, align='center')\nplt.gca().set_xticks(labels)\nplt.gca().set_title('Num. Defects by Images')\nfor i in range(len(counts)):\n    plt.text(x = i-0.1 , y = counts[i]+50, s = counts[i], size = 12, color='r')\nplt.show()","686cc72f":"\nfrom PIL import Image\n\ntrain_size_dict = defaultdict(int)\ntrain_path = Path(\"..\/input\/train_images\/\")\n\nfor img_name in train_path.iterdir():\n    img = Image.open(img_name)\n    train_size_dict[img.size] += 1","5f8bedd9":"train_size_dict","9e7bd709":"test_size_dict = defaultdict(int)\ntest_path = Path(\"..\/input\/test_images\/\")\n\nfor img_name in test_path.iterdir():\n    img = Image.open(img_name)\n    test_size_dict[img.size] += 1","1f6a3bb8":"test_size_dict","44975aa8":"submissionCSV = pd.read_csv(\n    '..\/input\/sample_submission.csv',\n    converters={'EncodedPixels': lambda e: ''})\nprint(submissionCSV.head())\nsubmissionCSV.to_csv('submission.csv', index=False)","603d32ae":"## How many classes do each image have?","b4d8b6c6":"# Check image data","87061ff1":"Predicting the location and type of defects found in steel manufacturing. \nImages are named with a unique ImageId. \nEach image may have no defects, a defect of a single class, or defects of multiple classes. (ClassId = [1, 2, 3, 4]).\n\nFile description : \n\n* train_images\/ - folder of training images\n* test_images\/ - folder of test images (you are segmenting and classifying these images)\n* train.csv - training annotations which provide segments for defects (ClassId = [1, 2, 3, 4])\n* sample_submission.csv - a sample submission file in the correct format; note, each ImageId 4 rows, one for each of the 4 defect classes","bc39eb53":"#1 : IMPORTING DATA"}}