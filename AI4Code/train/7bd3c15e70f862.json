{"cell_type":{"468306d2":"code","d0b1ce23":"code","cf21c67c":"code","8648add5":"code","2fede2b8":"code","554476b6":"code","3ba1cf60":"code","6042ec88":"code","6b41a744":"code","83a831c3":"code","7d03cb4a":"code","323be791":"code","32217859":"code","d9bc3b27":"code","b6c5d213":"code","dd9c70e5":"code","a0a7c271":"code","179503b2":"code","7b3470ce":"code","c20d1e21":"code","bce89f85":"code","9466304b":"code","fff400cd":"code","e6f099c2":"code","4c5545a9":"code","6649e349":"code","b2617458":"code","d51521f4":"code","f832f181":"code","008ea678":"code","bf59f082":"code","26e57206":"code","5d08ecd5":"code","b9b14e92":"code","2aff3d41":"code","61e4d669":"code","8328e195":"code","3732c1d1":"code","11b44250":"code","bb86e2f9":"code","48c41b69":"code","1e4d7b8e":"code","abfd99d7":"code","2a3527db":"markdown","27952cf1":"markdown","4d761847":"markdown","fc671d02":"markdown","97660061":"markdown","f56eb350":"markdown","203021e2":"markdown","1e848068":"markdown","2f1bfee1":"markdown","2efe8b43":"markdown","2e1f64f9":"markdown","0bdfa667":"markdown","35df7bc8":"markdown","8c1d17f6":"markdown","7694fb2c":"markdown","186864f4":"markdown","9dcf1c35":"markdown","d799be4c":"markdown","03675a2f":"markdown","911bb8e2":"markdown","bf611499":"markdown","12b74342":"markdown","e31e2045":"markdown","0f20f881":"markdown","dd7857ad":"markdown","30920aa6":"markdown","a2011e1f":"markdown","fcadb68c":"markdown","e1c19cf5":"markdown","111c58dd":"markdown","5060f5af":"markdown","4e1f6a23":"markdown","1a48b85a":"markdown","82f9f279":"markdown","0bb1b5f4":"markdown","91af6656":"markdown","8a2c0371":"markdown","32084e53":"markdown","8b39a5f0":"markdown","b662006e":"markdown","8066f6c6":"markdown","3febe517":"markdown","3fc88eb8":"markdown","0a275ef6":"markdown","abd42b62":"markdown","62f2dd02":"markdown","2e0ad341":"markdown","6e60768d":"markdown"},"source":{"468306d2":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport seaborn as sns\nimport plotly.express as px\n%matplotlib inline\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Make Plotly work in your Jupyter Notebook\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot \ninit_notebook_mode(connected = True)\n\nimport cufflinks as cf\n\n# Use Plotly locally\ncf.go_offline()","d0b1ce23":"df_detect = pd.read_csv(\"\/kaggle\/input\/electrical-fault-detection-and-classification\/detect_dataset.csv\")\ndf_detect.head()","cf21c67c":"df_detect.info()","8648add5":"df_detect = df_detect.drop(columns=[\"Unnamed: 7\", \"Unnamed: 8\"])","2fede2b8":"df_detect[\"Output (S)\"].value_counts()","554476b6":"fig = px.line(df_detect, x = \"Ib\", y = \"Vb\", facet_col=\"Output (S)\", color = \"Output (S)\")\n\n\nfor annotation in fig.layout.annotations:\n    annotation.text = \"\"\n\nfor axis in fig.layout:\n    if type(fig.layout[axis]) == go.layout.YAxis:\n        fig.layout[axis].title.text = ''\n    if type(fig.layout[axis]) == go.layout.XAxis:\n        fig.layout[axis].title.text = ''\n        \n\n\nfig.update_layout(\n    plot_bgcolor = \"#ECECEC\",\n    title = \"<b>Current and Voltage in line b<\/b>\",\n    title_font_size = 16,\n    title_font_color = \"black\",\n    title_pad_t = 5,\n    title_pad_l = 20,\n    yaxis = dict(\n        title_text = \"<b> Voltage <\/b>\",\n        titlefont = dict(size = 12)\n    ),\n    \n    hoverlabel=dict(\n        bgcolor=\"white\",\n        font_size=16,\n        font_family=\"Rockwell\"\n    )\n)\n\nfig.update_yaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\nfig.update_xaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\",\n                title_text = \"<b>Current<\/b>\")\n\n\n\nfig.show()","3ba1cf60":"x_a = df_detect[df_detect[\"Output (S)\"] == 0][\"Ia\"]\ny_a = df_detect[df_detect[\"Output (S)\"] == 0][\"Va\"]\n\nx_b = df_detect[df_detect[\"Output (S)\"] == 0][\"Ib\"]\ny_b = df_detect[df_detect[\"Output (S)\"] == 0][\"Vb\"]\n\nx_c = df_detect[df_detect[\"Output (S)\"] == 0][\"Ic\"]\ny_c = df_detect[df_detect[\"Output (S)\"] == 0][\"Vc\"]\n\n\nx_a1 = df_detect[df_detect[\"Output (S)\"] == 1][\"Ia\"]\ny_a1 = df_detect[df_detect[\"Output (S)\"] == 1][\"Va\"]\n\nx_b1 = df_detect[df_detect[\"Output (S)\"] == 1][\"Ib\"]\ny_b1 = df_detect[df_detect[\"Output (S)\"] == 1][\"Vb\"]\n\nx_c1 = df_detect[df_detect[\"Output (S)\"] == 1][\"Ic\"]\ny_c1 = df_detect[df_detect[\"Output (S)\"] == 1][\"Vc\"]\n\nfig = go.Figure()\n\nfig = make_subplots(rows=3, cols=2,\n                    subplot_titles=(\"No Fault\", \"Fault\"))\n\nfig.add_trace(go.Scatter(x = x_a, y = y_a, mode = \"lines+markers\", legendgroup = 'A',name = \"A line\",\n                        line=dict(color='#EC2781', width=2)), row = 1, col = 1)\nfig.add_trace(go.Scatter(x = x_b, y = y_b, mode = \"lines+markers\", legendgroup = 'B',name = \"B line\",\n                        line=dict(color='#3C8DD6', width=2)), row = 2, col = 1)\nfig.add_trace(go.Scatter(x = x_c, y = y_c, mode = \"lines+markers\", legendgroup = 'C',name = \"C line\",\n                        line=dict(color='black', width=2)), row = 3, col = 1)\nfig.add_trace(go.Scatter(x = x_a1, y = y_a1, mode = \"lines+markers\", legendgroup = 'A', showlegend = False,\n                        line=dict(color='#EC2781', width=2)), row = 1, col = 2)\nfig.add_trace(go.Scatter(x = x_b1, y = y_b1, mode = \"lines+markers\", legendgroup = 'B', showlegend = False,\n                        line=dict(color='#3C8DD6', width=2)), row = 2, col = 2)\nfig.add_trace(go.Scatter(x = x_c1, y = y_c1, mode = \"lines+markers\", legendgroup = 'C', showlegend = False,\n                        line=dict(color='black', width=2)), row = 3, col = 2)\n\n\n\nfig.update_layout(\n    height=800, width=900,\n    plot_bgcolor = \"#ECECEC\",\n    title = \"<b>Current and Voltage in line a, b, c under no fault condition<\/b>\",\n    title_font_size = 16,\n    title_font_color = \"black\",\n    title_pad_t = 5,\n    title_pad_l = 20,\n    \n    hoverlabel=dict(\n        bgcolor=\"white\",\n        font_size=16,\n        font_family=\"Rockwell\"\n    ),\n    annotations = list(fig.layout.annotations) + \n    [go.layout.Annotation(\n            x=-0.07,\n            y=0.5,\n            font=dict(\n                size=12\n            ),\n            text=\"<b> Votage <\/b>\",\n            textangle=-90,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ] +\n    [go.layout.Annotation(\n            x=0.5,\n            y=-0.08,\n            font=dict(\n                size=12, color = 'black'\n            ),\n            showarrow=False,\n            text=\"<b> Current <\/b>\",\n            textangle=-0,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ]\n    \n)\n\nfig.update_yaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\nfig.update_xaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\n\n\n\n\nfig.show()","6042ec88":"df_class = pd.read_csv(\"\/kaggle\/input\/electrical-fault-detection-and-classification\/classData.csv\")\ndf_class.head()","6b41a744":"df_class['FaultType'] = df_class['G'].astype('str') + df_class['C'].astype('str') + df_class['B'].astype('str') + df_class['A'].astype('str')\ndf_class.head()","83a831c3":"df_class.info()","7d03cb4a":"df_class[\"FaultType\"].unique()","323be791":"df_class[\"FaultType\"].value_counts()","32217859":"df_no_fault = df_class.loc[df_class[\"FaultType\"] == \"0000\"]\ndf_LL_fault = df_class.loc[df_class[\"FaultType\"] == \"0110\"]\ndf_LG_fault = df_class.loc[df_class[\"FaultType\"] == \"1001\"]\ndf_LLG_fault = df_class.loc[df_class[\"FaultType\"] == \"1011\"]\ndf_LLLG_fault = df_class.loc[df_class[\"FaultType\"] == \"1111\"]\ndf_LLL_fault = df_class.loc[df_class[\"FaultType\"] == \"0111\"]\n","d9bc3b27":"\n\nfig = go.Figure()\n\nfig = make_subplots(rows=2, cols=3,\n                    subplot_titles=(\"No Fault\", \"LL Fault\", \"LLL Fault\", \"LG Fault\",\n                                   \"LLG Fault\", \"LLLG Fault\"))\n\nfig.add_trace(\n    go.Scatter(x=df_no_fault[\"Ia\"], y=df_no_fault[\"Va\"], name = \"Line A\", legendgroup = 'A', \n               line=dict(color='#EC2781')),\n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=df_no_fault[\"Ib\"], y=df_no_fault[\"Vb\"], name = \"Line B\", legendgroup = 'B', \n               line=dict(color='#3C8DD6')),\n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=df_no_fault[\"Ic\"], y=df_no_fault[\"Vc\"], name = \"Line C\", legendgroup = 'C', \n               line=dict(color='black')),\n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(x=df_LL_fault[\"Ia\"], y=df_LL_fault[\"Va\"], legendgroup = 'A',\n    showlegend = False,line=dict(color='#EC2781')),\n    row=1, col=2\n)\nfig.add_trace(\n    go.Scatter(x=df_LL_fault[\"Ib\"], y=df_LL_fault[\"Vb\"],legendgroup = 'B',\n    showlegend = False, line=dict(color='#3C8DD6')),\n    row=1, col=2\n)\nfig.add_trace(\n    go.Scatter(x=df_LL_fault[\"Ic\"], y=df_LL_fault[\"Vc\"], legendgroup = 'C',\n    showlegend = False, line=dict(color='black')),\n    row=1, col=2\n)\n\n\n\nfig.add_trace(\n    go.Scatter(x=df_LLL_fault[\"Ia\"], y=df_LLL_fault[\"Va\"],legendgroup = 'A',\n    showlegend = False, line=dict(color='#EC2781')),\n    row=1, col=3\n)\nfig.add_trace(\n    go.Scatter(x=df_LLL_fault[\"Ib\"], y=df_LLL_fault[\"Vb\"], legendgroup = 'B',\n    showlegend = False, line=dict(color='#3C8DD6')),\n    row=1, col=3\n)\nfig.add_trace(\n    go.Scatter(x=df_LLL_fault[\"Ic\"], y=df_LLL_fault[\"Vc\"], legendgroup = 'C',\n    showlegend = False, line=dict(color='black')),\n    row=1, col=3\n)\n\n\n\nfig.add_trace(\n    go.Scatter(x=df_LG_fault[\"Ia\"], y=df_LG_fault[\"Va\"], legendgroup = 'A',\n    showlegend = False, line=dict(color='#EC2781')),\n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(x=df_LG_fault[\"Ib\"], y=df_LG_fault[\"Vb\"], legendgroup = 'B',\n    showlegend = False, line=dict(color='#3C8DD6')),\n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(x=df_LG_fault[\"Ic\"], y=df_LG_fault[\"Vc\"], legendgroup = 'C',\n    showlegend = False, line=dict(color='black')),\n    row=2, col=1\n)\n\n\n\n\nfig.add_trace(\n    go.Scatter(x=df_LLG_fault[\"Ia\"], y=df_LLG_fault[\"Va\"], legendgroup = 'A',\n    showlegend = False, line=dict(color='#EC2781')),\n    row=2, col=2\n)\nfig.add_trace(\n    go.Scatter(x=df_LLG_fault[\"Ib\"], y=df_LLG_fault[\"Vb\"], legendgroup = 'B',\n    showlegend = False, line=dict(color='#3C8DD6')),\n    row=2, col=2\n)\nfig.add_trace(\n    go.Scatter(x=df_LLG_fault[\"Ic\"], y=df_LLG_fault[\"Vc\"], legendgroup = 'C',\n    showlegend = False, line=dict(color='black')),\n    row=2, col=2\n)\n\n\nfig.add_trace(\n    go.Scatter(x=df_LLLG_fault[\"Ia\"], y=df_LLLG_fault[\"Va\"], legendgroup = 'A',\n    showlegend = False, line=dict(color='#EC2781')),\n    row=2, col=3\n)\nfig.add_trace(\n    go.Scatter(x=df_LLLG_fault[\"Ib\"], y=df_LLLG_fault[\"Vb\"], legendgroup = 'B',\n    showlegend = False, line=dict(color='#3C8DD6')),\n    row=2, col=3\n)\nfig.add_trace(\n    go.Scatter(x=df_LLLG_fault[\"Ic\"], y=df_LLLG_fault[\"Vc\"], legendgroup = 'C',\n    showlegend = False, line=dict(color='black')),\n    row=2, col=3\n)\n\n\n\nfig.update_layout(\n    plot_bgcolor = \"#ECECEC\",\n    title = \"<b>Current and Voltage in line a, b, c under different conditions<\/b>\",\n    title_font_size = 16,\n    title_font_color = \"black\",\n    title_pad_t = 5,\n    title_pad_l = 20,\n    hoverlabel=dict(\n        bgcolor=\"white\",\n        font_size=16,\n        font_family=\"Rockwell\",\n    \n    ),\n    annotations = list(fig.layout.annotations) + \n    [go.layout.Annotation(\n            x=-0.07,\n            y=0.5,\n            font=dict(\n                size=12\n            ),\n            text=\"<b> Votage <\/b>\",\n            textangle=-90,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ] +\n    [go.layout.Annotation(\n            x=0.5,\n            y=-0.1,\n            font=dict(\n                size=12, color = 'black'\n            ),\n            showarrow=False,\n            text=\"<b> Current <\/b>\",\n            textangle=-0,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ]\n)\n\nfig.update_yaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\nfig.update_xaxes(showline = True, linewidth = 2, linecolor = \"black\")\n\nfig.show()","b6c5d213":"fig = go.Figure()\n\nx_no_a = df_no_fault[\"Ia\"]\ny_no_a = df_no_fault[\"Va\"]\nx_no_b = df_no_fault[\"Ib\"]\ny_no_b = df_no_fault[\"Vb\"]\nx_no_c = df_no_fault[\"Ic\"]\ny_no_c = df_no_fault[\"Vc\"]\n\n\n\nfig.add_trace(go.Scatter(x = x_no_a, y = y_no_a, mode = \"lines+markers\", name = \"A line\",\n                        line=dict(color='#EC2781', width=2)))\nfig.add_trace(go.Scatter(x = x_no_b, y = y_no_b, mode = \"lines+markers\", name = \"B line\",\n                        line=dict(color='#3C8DD6', width=2)))\nfig.add_trace(go.Scatter(x = x_no_c, y = y_no_c, mode = \"lines+markers\", name = \"C line\",\n                        line=dict(color='black', width=2)))\n\n\n\nfig.update_layout(\n    plot_bgcolor = \"#ECECEC\",\n    title = \"<b>Current and Voltage in lina a, b, c under no fault condition<\/b>\",\n    title_font_size = 16,\n    title_font_color = \"black\",\n    title_pad_t = 5,\n    title_pad_l = 20,\n     xaxis = dict(\n        title_text = \"<b> Current <\/b>\",\n        titlefont = dict(size = 12)\n    ),\n    yaxis = dict(\n        title_text = \"<b> Voltage <\/b>\",\n        titlefont = dict(size = 12)\n    ),\n    \n    hoverlabel=dict(\n        bgcolor=\"white\",\n        font_size=16,\n        font_family=\"Rockwell\"\n    )\n)\n\nfig.update_yaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\nfig.update_xaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\n\n\n\nfig.show()","dd9c70e5":"import plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Create figure with secondary y-axis\n\nx_no_a = df_no_fault[\"Ia\"]\ny_no_a = df_no_fault[\"Va\"]\n\nx_LL_a = df_LL_fault[\"Ia\"]\ny_LL_a = df_LL_fault[\"Va\"]\n\nx_LG_a = df_LG_fault[\"Ia\"]\ny_LG_a = df_LG_fault[\"Va\"]\n\nx_LLG_a = df_LLG_fault[\"Ia\"]\ny_LLG_a = df_LLG_fault[\"Va\"]\n\nx_LLLG_a = df_LLLG_fault[\"Ia\"]\ny_LLLG_a = df_LLLG_fault[\"Va\"]\n\nx_LLL_a = df_LLL_fault[\"Ia\"]\ny_LLL_a = df_LLL_fault[\"Va\"]\n\n\n\nfig = make_subplots()\nfig.add_trace(go.Scatter(x = x_no_a, y = y_no_a, mode = \"lines+markers\", name = \"No Fault\",\n                        line=dict(color='#EC2781', width=2)))\n\nfig.add_trace(go.Scatter(x = x_LL_a, y = y_LL_a, mode = \"lines+markers\", name = \"LL Fault\",\n                        line=dict(color='#3C8DD6', width=2)))\n\nfig.add_trace(go.Scatter(x = x_LG_a, y = y_LG_a, mode = \"lines+markers\", name = \"LG Fault\",\n                        line=dict(color='black', width=2)))\n\nfig.add_trace(go.Scatter(x = x_LLG_a, y = y_LLG_a, mode = \"lines+markers\", name = \"LLG Fault\",\n                        line=dict(color='blue', width=2)))\n\nfig.add_trace(go.Scatter(x = x_LLLG_a, y = y_LLLG_a, mode = \"lines+markers\", name = \"LLLG Fault\",\n                        line=dict(color='magenta', width=2)))\n\nfig.add_trace(go.Scatter(x = x_LLL_a, y = y_LLL_a, mode = \"lines+markers\", name = \"LLL Fault\",\n                        line=dict(color='green', width=2)))\n\n                       \n\n\nfig.update_layout(\n    plot_bgcolor = \"#ECECEC\",\n    title = \"<b>Current and Voltage in line A under different conditions<\/b>\",\n    title_font_size = 16,\n    title_font_color = \"black\",\n    title_pad_t = 5,\n    title_pad_l = 20,\n     xaxis = dict(\n        title_text = \"<b> Current <\/b>\",\n        titlefont = dict(size = 12)\n    ),\n    yaxis = dict(\n        title_text = \"<b> Voltage <\/b>\",\n        titlefont = dict(size = 12)\n    ),\n    \n    hoverlabel=dict(\n        bgcolor=\"white\",\n        font_size=16,\n        font_family=\"Rockwell\"\n    )\n)\n\nfig.update_yaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\nfig.update_xaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\n\n\n\nfig.show()","a0a7c271":"features = ['Ia', 'Ib','Ic','Va','Vb','Vc']\n\ndetection_data_X = df_detect[features]\ndetection_data_Y = df_detect['Output (S)']","179503b2":"class_data_X = df_class[features]\nclass_data_Y = df_class['FaultType']\n\n# Encoding multiclass label\nfrom sklearn.preprocessing import LabelEncoder \nle = LabelEncoder()\n\nclass_data_Y = le.fit_transform(class_data_Y)\n","7b3470ce":"from sklearn.model_selection import train_test_split","c20d1e21":"X_train_b, X_test_b, y_train_b, y_test_b = train_test_split(detection_data_X,\n                                                        detection_data_Y,test_size=0.33,random_state=1)","bce89f85":"X_train_m, X_test_m, y_train_m, y_test_m = train_test_split(class_data_X, class_data_Y, \n                                                            test_size=0.33,random_state=1)","9466304b":"from sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom xgboost import XGBClassifier\nfrom sklearn import model_selection\nfrom sklearn.utils import class_weight\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.svm import LinearSVC  \nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neural_network import MLPClassifier","fff400cd":"\ndef run_exps(X_train, X_test, y_train, y_test):    \n    '''\n    Lightweight script to test many models and find winners\n    :param X_train: training split\n    :param y_train: training target vector\n    :param X_test: test split\n    :param y_test: test target vector\n    :return: DataFrame of predictions\n    '''\n    \n    dfs = []\n    \n    \n    models = [\n          ('LogReg', LogisticRegression()), \n          ('RF', RandomForestClassifier()),\n          ('KNN', KNeighborsClassifier()),\n          ('SVM', SVC()), \n          ('GNB', GaussianNB()),\n          ('XGB', XGBClassifier())\n        ]\n    results = []\n    names = []\n    scoring = ['accuracy', 'precision_weighted', 'recall_weighted', 'f1_weighted', 'roc_auc']\n    target_names = ['Fault', 'No Fault']\n    \n    classification_report_df = []\n    classification_report_list = []\n    \n    y_pred_df = []\n    y_pred_list = []\n    accuracy = []\n    error = []\n    \n    for name, model in models:\n        #final = []\n        kfold = model_selection.KFold(n_splits=5, shuffle=True, random_state=90210)\n        cv_results = model_selection.cross_validate(model, X_train, y_train, cv=kfold, scoring=scoring)\n        clf = model.fit(X_train, y_train)\n        \n        \n        y_pred = clf.predict(X_test)\n        y_pred_list.append(y_pred)\n        this_y_pred_df = pd.DataFrame(y_pred)\n        this_y_pred_df[\"model\"] = name\n        y_pred_df.append(this_y_pred_df)\n        \n        \n        results.append(cv_results)\n        names.append(name)\n        \n        \n        accuracy.append((model.score(X_test,y_test)))\n        error.append(mean_squared_error(y_test,y_pred))\n        \n        classification_report_result = classification_report(y_test, y_pred, target_names=target_names,\n                                                            output_dict=True)\n        classification_report_list.append(classification_report_result)\n        this_classification_report_df = pd.DataFrame(classification_report_result).transpose()\n        this_classification_report_df[\"model\"] = name\n        classification_report_df.append(this_classification_report_df)\n        \n        \n        this_df = pd.DataFrame(cv_results)\n        this_df['model'] = name\n        dfs.append(this_df)\n        final = pd.concat(dfs, ignore_index=True)\n    \n    return final, classification_report_df, y_pred_df, accuracy, error\n\n","e6f099c2":"binary_final, binary_classification_report_df, y_pred_df, binary_accuracy, binary_error = run_exps(X_train_b, \n                                                                            X_test_b, y_train_b, y_test_b)","4c5545a9":"binary_classification_report_df_final = pd.concat(binary_classification_report_df, ignore_index=True)","6649e349":"y_pred_df_final = pd.concat(y_pred_df, ignore_index=True)\ny_pred_df_final.rename(columns = {\n    0 : \"y_pred\"\n}, inplace = True )","b2617458":"fig = go.Figure()\n\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\nfig.add_trace(go.Scatter(\n    y=binary_accuracy,\n    name='Accuracy',\n    line=dict(color=\"firebrick\", width = 2)\n),  secondary_y=False,)\nfig.add_trace(go.Scatter(\n    y=binary_error,\n    name='Error',\n    line=dict(color=\"#ffe119\", width = 2)\n),  secondary_y=True,)\n\nfig.update_layout(\n    title_text=\"<b>Accuracy and error in binary Classifiaction<\/b>\",\n    plot_bgcolor = \"#ECECEC\",\nxaxis = dict(\n        title_text = \"<b> Model <\/b>\",\n        titlefont = dict(size = 12),\n        tickvals = [0,1,2,3,4,5],\n        ticktext=['Logistic', 'RF','KNN', 'SVM','GNB', \"XGB\"]\n    \n    ),\n)\n\nfig.update_yaxes(title_text=\"<b>Accuracy<\/b>\", secondary_y=False)\nfig.update_yaxes(title_text=\"<b>Error<\/b>\", secondary_y=True)\n\nfig.update_yaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\nfig.update_xaxes(showline = True, linewidth = 2, linecolor = \"black\")\n\nfig.show()","d51521f4":"bootstraps = []\nfor model in list(set(binary_final.model.values)):\n    model_df = binary_final.loc[binary_final.model == model]\n    #bootstrap = model_df.sample(n=30, replace=True)\n    bootstraps.append(model_df)\n        \nbinary_bootstrap_df = pd.concat(bootstraps, ignore_index=True)\nbinary_results_long = pd.melt(binary_bootstrap_df,id_vars=['model'],var_name='metrics', value_name='values')\ntime_metrics = ['fit_time','score_time']\n\n\nbinary_results_long_nofit = binary_results_long.loc[~binary_results_long['metrics'].isin(time_metrics)] \nbinary_results_long_nofit = binary_results_long_nofit.sort_values(by='values')\n\n\nbinary_results_long_fit = binary_results_long.loc[binary_results_long['metrics'].isin(time_metrics)] \nbinary_results_long_fit = binary_results_long_fit.sort_values(by='values')","f832f181":"fig = px.box(x = binary_results_long_nofit['model'], y = binary_results_long_nofit['values'],\n            color = binary_results_long_nofit['metrics'])\n\nfig.update_layout(\n    title_text=\"<b>Comparison of Model by Classification Metric<\/b>\",\n    plot_bgcolor = \"#ECECEC\",\nxaxis = dict(\n        title_text = \"<b> Model <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\nyaxis = dict(\n        title_text = \"<b> Values <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\n)\n\n\nfig.show()","008ea678":"metrics = list(set(binary_results_long_nofit.metrics.values))\nbinary_bootstrap_df.groupby(['model'])[metrics].agg([np.std, np.mean])\n","bf59f082":"fig = px.box(x = binary_results_long_fit['model'], y = binary_results_long_fit['values'],\n            color = binary_results_long_fit['metrics'])\n\nfig.update_layout(\n    title_text=\"<b>Comparison of Model by Fit and Score Time<\/b>\",\n    plot_bgcolor = \"#ECECEC\",\nxaxis = dict(\n        title_text = \"<b> Model <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\nyaxis = dict(\n        title_text = \"<b> Values <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\n)\n\nfig.show()","26e57206":"time_metrics = list(set(binary_results_long_fit.metrics.values))\nbinary_bootstrap_df.groupby(['model'])[time_metrics].agg([np.std, np.mean])","5d08ecd5":"from sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import LinearSVC  \nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.linear_model import LogisticRegression \nfrom sklearn import model_selection\nfrom sklearn.utils import class_weight\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nimport numpy as np\nimport pandas as pd\n\ndef run_exps(X_train, X_test, y_train, y_test):    \n    '''\n    Lightweight script to test many models and find winners\n    :param X_train: training split\n    :param y_train: training target vector\n    :param X_test: test split\n    :param y_test: test target vector\n    '''\n    \n    dfs = []\n    \n    \n    models = [\n           \n          ('KNN', KNeighborsClassifier()),\n          ('SVM', LinearSVC(multi_class=\"crammer_singer\")), \n          ('GNB', GaussianNB()),\n          ('D-Tree', DecisionTreeClassifier()),\n          (\"MLP\", MLPClassifier())\n        ]\n    results = []\n    names = []\n    scoring = ['accuracy', 'precision_weighted', 'recall_weighted', 'f1_weighted']\n    target_names = ['No Fault', \"LL\", \"LLL\", \"LG\", \"LLG\", \"LLLG\"]\n    \n    classification_report_df = []\n    classification_report_list = []\n    \n    y_pred_df = []\n    y_pred_list = []\n    accuracy = []\n    error = []\n    \n    for name, model in models:\n        kfold = model_selection.KFold(n_splits=5, shuffle=True, random_state=90210)\n        cv_results = model_selection.cross_validate(model, X_train, y_train, cv=kfold, scoring=scoring)\n        clf = model.fit(X_train, y_train)\n        \n        \n        y_pred = clf.predict(X_test)\n        y_pred_list.append(y_pred)\n        this_y_pred_df = pd.DataFrame(y_pred)\n        this_y_pred_df[\"model\"] = name\n        y_pred_df.append(this_y_pred_df)\n        \n        \n        results.append(cv_results)\n        names.append(name)\n        \n        \n        accuracy.append((model.score(X_test,y_test)))\n        error.append(mean_squared_error(y_test,y_pred))\n        \n        classification_report_result = classification_report(y_test, y_pred, target_names=target_names,\n                                                            output_dict=True)\n        classification_report_list.append(classification_report_result)\n        this_classification_report_df = pd.DataFrame(classification_report_result).transpose()\n        this_classification_report_df[\"model\"] = name\n        classification_report_df.append(this_classification_report_df)\n        \n        \n        this_df = pd.DataFrame(cv_results)\n        this_df['model'] = name\n        dfs.append(this_df)\n        final = pd.concat(dfs, ignore_index=True)\n    \n    return final, classification_report_df, y_pred_df, accuracy, error","b9b14e92":"type(y_train_m)","2aff3d41":"multi_final, multi_classification_report_df, y_pred_df, multi_accuracy, multi_error = run_exps(X_train_m,\n                                                                            X_test_m, y_train_m, y_test_m)","61e4d669":"multi_classification_report_df = pd.concat(multi_classification_report_df, ignore_index=True)","8328e195":"y_pred_df_final = pd.concat(y_pred_df, ignore_index=True)\ny_pred_df_final.rename(columns = {\n    0 : \"y_pred\"\n}, inplace = True )","3732c1d1":"fig = go.Figure()\n\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\nfig.add_trace(go.Scatter(\n    y=multi_accuracy,\n    name='Accuracy',\n    line=dict(color=\"firebrick\",  width=2) #line=dict(color='#EC2781', width=2)\n),  secondary_y=False,)\nfig.add_trace(go.Scatter(\n    y=multi_error,\n    name='Error',\n    line=dict(color=\"#ffe119\", width=2)\n),  secondary_y=True,)\n\nfig.update_layout(\n    title_text=\"<b>Accuracy and error of different models<\/b>\",\n    plot_bgcolor = \"#ECECEC\",\nxaxis = dict(\n        title_text = \"<b> Model <\/b>\",\n        titlefont = dict(size = 12),\n        tickvals = [0,1,2,3,4,5],\n        ticktext=[ 'KNN','SVM','GNB', 'D-Tree', \"MLP\"]\n    ),\n)\n\n\n# Set y-axes titles\nfig.update_yaxes(title_text=\"<b>Accuracy<\/b>\", secondary_y=False)\nfig.update_yaxes(title_text=\"<b>Error<\/b>\", secondary_y=True)\n\nfig.update_yaxes(showticklabels = True, showline = True, linewidth = 2, linecolor = \"black\")\nfig.update_xaxes(showline = True, linewidth = 2, linecolor = \"black\")\n\nfig.show()","11b44250":"bootstraps = []\nfor model in list(set(multi_final.model.values)):\n    model_df = multi_final.loc[multi_final.model == model]\n    bootstrap = model_df.sample(n=30, replace=True)\n    bootstraps.append(bootstrap)\n        \nmulti_bootstrap_df = pd.concat(bootstraps, ignore_index=True)\nmulti_results_long = pd.melt(multi_bootstrap_df,id_vars=['model'],var_name='metrics', value_name='values')\ntime_metrics = ['fit_time','score_time'] # fit time metrics\n\n## PERFORMANCE METRICS\nmulti_results_long_nofit = multi_results_long.loc[~multi_results_long['metrics'].isin(time_metrics)] \nmulti_results_long_nofit = multi_results_long_nofit.sort_values(by='values')\n\n## TIME METRICS\nmulti_results_long_fit = multi_results_long.loc[multi_results_long['metrics'].isin(time_metrics)] \nmulti_results_long_fit = multi_results_long_fit.sort_values(by='values')","bb86e2f9":"fig = px.box(x = multi_results_long_nofit['model'], y = multi_results_long_nofit['values'],\n            color = multi_results_long_nofit['metrics'])\n\nfig.update_layout(\n    title_text=\"<b>Comparison of Model by Classification Metric<\/b>\",\n    plot_bgcolor = \"#ECECEC\",\nxaxis = dict(\n        title_text = \"<b> Model <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\nyaxis = dict(\n        title_text = \"<b> Values <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\n)\n\n\nfig.show()","48c41b69":"metrics = list(set(multi_results_long_nofit.metrics.values))\nmulti_bootstrap_df.groupby(['model'])[metrics].agg([np.std, np.mean])","1e4d7b8e":"fig = px.box(x = multi_results_long_fit['model'], y = multi_results_long_fit['values'],\n            color = multi_results_long_fit['metrics'])\n\nfig.update_layout(\n    title_text=\"<b>Comparison of Model by Fit and Score Time<\/b>\",\n    plot_bgcolor = \"#ECECEC\",\nxaxis = dict(\n        title_text = \"<b> Model <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\nyaxis = dict(\n        title_text = \"<b> Values <\/b>\",\n        titlefont = dict(size = 12),\n        \n    \n    ),\n)\n\nfig.show()","abfd99d7":"time_metrics = list(set(multi_results_long_fit.metrics.values))\nmulti_bootstrap_df.groupby(['model'])[time_metrics].agg([np.std, np.mean])","2a3527db":"# Binary Classification","27952cf1":"### Multiclass classification data split","4d761847":"### Information about columns","fc671d02":" ### Creating dataframe according to metrices","97660061":"### Creating dataframe according to metrices","f56eb350":"### Fit and Score Time Plot","203021e2":"## Assign the dataframe\nWe create the dataframe according to their label. It will help us for visualization purposes.","1e848068":"## Splitting the variables into train and test data","2f1bfee1":"We can see that we have 6 different type of output. Hence we can say it is a case of multiclass classification problem.","2efe8b43":"Similar with binary classification we can see that under no fault condition we have some relationship between current and voltage in all three lines. However under faulty condition their is distortion of this relationship. The LLL and LLLG fault graph shows some similarity between them. ","2e1f64f9":"### Count the different labels","0bdfa667":"## Read the data","35df7bc8":"<h1><center><font size=\"6\">Electrical Fault Prediction<\/font><\/center><\/h1>\n\n<center><img src=\"https:\/\/images.unsplash.com\/photo-1474314243412-cd4a79f02c6a?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1351&q=80\"><\/img><\/center>\nPhoto by <a href=\"https:\/\/unsplash.com\/@marius?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Marius Masalar<\/a> on <a href=\"https:\/\/unsplash.com\/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash<\/a>","8c1d17f6":"## Model Creation For Multi class classification","7694fb2c":"From above we see that all columns except \"Unnamed: 7\" and \"Unnamed: 8\" are non null. Since they does not contain any information it is best to drop these columns.","186864f4":"### Binary Data","9dcf1c35":"We can say that all the columns are non-null columns. Also their dtype is correct according to the values.","d799be4c":"The faults have been classified as follows:<br>\n\n1. Line-Line(LL) fault,\n\n2. Line-Ground(LG) fault,\n\n3. Line-Line-Ground(LLG) fault,\n\n4. Line-Line-Line-Ground(LLLG) fault,\n\n5. Line-Line-Line(LLL) fault\n\n\nIa, Ib, Ic and Va, Vb, Vc denotes current and voltage in line A, line B,  line C respectively.<br>\n\n\n\nG, C, B, A denotes Ground, fault at line C, B, and A respectively.<br>\n\n\n0 0 0 0 - No Fault<br>\n\n1 0 0 1 - LG fault (Between Phase A and Gnd)<br>\n\n0 1 1 0 - LL fault (Between Phase B and Phase C)<br>\n\n1 0 1 1 - LLG Fault (Between Phases A, B, and ground)<br>\n\n0 1 1 1 - LLL Fault(Between all three phases)<br>\n\n1 1 1 1 - LLLG fault( Three phase symmetrical fault)  <br>\n\n","03675a2f":"## Visualization","911bb8e2":"If you have any sugesstion about the notebook please comment. If you find the work useful and intresting please do upvote!!","bf611499":"## Seperating labels and features in different variables.","12b74342":"# Multiclass Classification","e31e2045":"## Read data","0f20f881":"### Current and voltage relationship under no fault condition","dd7857ad":"### Plotting accuracy and error of different models","30920aa6":"### Classification Metric Plot","a2011e1f":"Electrical powers system is growing in size and complexity in all sectors such as generation, transmission, distribution and load systems. Types of faults like short circuit condition in power system network results in severe economic losses and reduces the reliability of the electrical system.<br>\nElectrical fault is an abnormal condition, caused by equipment failures such as transformers and rotating machines, human errors and environmental conditions. Theses faults cause interruption to electric flows, equipment damages and even cause death of humans, birds and animals.<br>\n<b>Types of Faults<\/b><br>\nElectrical fault is the deviation of voltages and currents from nominal values or states. Under normal operating conditions, power system equipment or lines carry normal voltages and currents which results in a safer operation of the system.<br>\n\nBut when fault occurs, it causes excessively high currents to flow which causes the damage to equipments and devices. Fault detection and analysis is necessary to select or design suitable switchgear equipments, electromechanical relays, circuit breakers and other protection devices.<br>\n\nThere are mainly two types of faults in the electrical power system:\n1. Symmetrical Faults\n2. Unsymmetrical Faults.\n\n<b>Symmetrical faults<\/b><br>\nThese are very severe faults and occur infrequently in the power systems. These are also called as balanced faults and are of two types namely line to line to line to ground <b>(L-L-L-G)<\/b> and line to line to line <b>(L-L-L)<\/b>.<br>\nOnly 2-5 percent of system faults are symmetrical faults. If these faults occur, system remains balanced but results in severe damage to the electrical power system equipments. Analysis of these faults is easy and usually carried by per phase basis. Three phase fault analysis or information is required for selecting set-phase relays, rupturing capacity of the circuit breakers and rating of the protective switchgear.\n\n<b>Unsymmetrical faults<\/b><br>\nThese are very common and less severe than symmetrical faults. There are mainly three types namely line to ground <b>(L-G)<\/b>, line to line <b>(L-L)<\/b> and double line to ground <b>(LL-G)<\/b> faults.<br>\nLine to ground fault (L-G) is most common fault and 65-70 percent of faults are of this type.<br>\nIt causes the conductor to make contact with earth or ground. 15 to 20 percent of faults are double line to ground(LL-G) and causes the two conductors to make contact with ground. Line to line faults (L-L) occur when two conductors make contact with each other mainly while swinging of lines due to winds and 5- 10 percent of the faults are of this type.<br>\nThese are also called unbalanced faults since their occurrence causes unbalance in the system. Unbalance of the system means that that impedance values are different in each phase causing unbalance current to flow in the phases. These are more difficult to analyze and are carried by per phase basis similar to three phase balanced faults.<br>","fcadb68c":"### Accuracy and error relationship","e1c19cf5":"### Metric Visualization","111c58dd":"## Developing the function for binary classification ","5060f5af":"# Model Designing","4e1f6a23":"## See the labels","1a48b85a":"### Binary Classification","82f9f279":"## Visualization","0bb1b5f4":"1. <b>fit_time:<\/b> <br>\nThe time for fitting the estimator on the train set for each cv split.\n\n2. <b>score_time:<\/b> <br>\nThe time for scoring the estimator on the test set for each cv split.","91af6656":"### Current and voltage inline A under different conditions","8a2c0371":"## About column","32084e53":"The output is only present as 0 and 1. So we can safely categorize it as binary classification problem. Before proceeding for the model designing let us first see the behaviour of current and voltage in faulty and non-faulty condition.","8b39a5f0":"### Current and voltage relationship under different condition","b662006e":"Above graphs shows us the relationship between current and voltage in different line A, B and C under faulty and non-faulty condition. ","8066f6c6":"The above plot shows the relationship between the current and voltage under no fault (0) and faulty (1) conditions. We can see that in first graph there is nearly a smooth relationship between current and voltage but that is not the case in second graph. The variation between the two is completely incoherent.","3febe517":"### Create a coulmn called \"FaultType\" which has different output joined together","3fc88eb8":"### Unique values in FaultType","0a275ef6":"## Importing libraries","abd42b62":"### Multiclass data","62f2dd02":"### Time taken visualization","2e0ad341":"## Drop the columns","6e60768d":"### Classification metric in short\n1. <b>Accuracy:<\/b> <br>\nAccuracy is the proportion of true results among the total number of cases examined. Accuracy is a valid choice of evaluation for classification problems which are well balanced and not skewed or No class imbalance.<br>\n\n2. <b>Precision:<\/b> <br>\nPrecision is a valid choice of evaluation metric when we want to be very sure of our prediction.<br>\n\n3. <b>Recall:<\/b> <br>\nRecall is a valid choice of evaluation metric when we want to capture as many positives as possible. <br>\n\n4. <b>F1 score:<\/b> <br>\nThe F1 score is a number between 0 and 1 and is the harmonic mean of precision and recall. F1 score maintains a balance between the precision and recall for classifier. If your precision is low, the F1 is low and if the recall is low again your F1 score is low.<br>\n\n5. <b>AUC ROC:<\/b> <br>\nAUC ROC indicates how well the probabilities from the positive classes are separated from the negative classes. <br>"}}