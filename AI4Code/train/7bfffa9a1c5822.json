{"cell_type":{"9944a9d3":"code","fec74e51":"code","7830f734":"code","5fef3bd8":"code","1fa92be4":"code","d9201abf":"code","91f79296":"code","d6187768":"code","75a06e22":"code","b02f5fcd":"code","c374b6ca":"code","5690f85e":"code","afc02fa1":"code","6733d87b":"markdown","c1e39d4f":"markdown","cc99916a":"markdown","c8994787":"markdown","504a02a5":"markdown","901160b6":"markdown","f81bfcd3":"markdown","b0ed28bb":"markdown","7a211db1":"markdown","a54aec48":"markdown","2cd4adfa":"markdown","a404e70d":"markdown","a5c49233":"markdown","69d2fe06":"markdown"},"source":{"9944a9d3":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pickle    \nimport matplotlib\nimport matplotlib.pyplot as plt\ncolor_map = plt.cm.winter\nfrom matplotlib.patches import RegularPolygon\nimport math \n\n# Needed for custom colour mapping!\nfrom matplotlib.colors import ListedColormap, LinearSegmentedColormap\nimport matplotlib.colors as mcolors\nc = mcolors.ColorConverter().to_rgb\npositive_cm = ListedColormap([c('#e1e5e5'),c('#e78c79'),c('#d63b36')]) # Positive map\nnegative_cm = ListedColormap([c('#e1e5e5'), c('#a1ceee'),c('#28aee4')]) # Negative map\n\nfrom PIL import Image","fec74e51":"with open('..\/input\/nhl-data\/2019FullDataset.pkl', 'rb') as f:\n    game_data = pickle.load(f)","7830f734":"# Lets make a dictionary to capture all of the needed data\nleague_data = {};\nleague_data['Shot'] = {};league_data['Shot']['x'] = [];league_data['Shot']['y'] = [];\nleague_data['Goal'] = {};league_data['Goal']['x'] = [];league_data['Goal']['y'] = [];\n\n# We are only looking for shot and goal type events to count toward the SOG %\nevent_types = ['Shot','Goal']\nfor data in game_data:\n    if 'liveData' not in data: # Make sure the data is valid\n        continue\n    \n    # Capture all of the plays for the game\n    plays = data['liveData']['plays']['allPlays']\n    for play in plays: # For each play get all of the events and capture the Shot and Goals\n        for event in event_types:\n            if play['result']['event'] in [event]:\n                if 'x' in play['coordinates']:\n                    league_data[event]['x'].append(play['coordinates']['x'])\n                    league_data[event]['y'].append(play['coordinates']['y'])","5fef3bd8":"# Get the player SOG % \nfull_name = 'Auston Matthews'\nplayer_data = {};\nplayer_data['Shot'] = {};player_data['Shot']['x'] = [];player_data['Shot']['y'] = [];\nplayer_data['Goal'] = {};player_data['Goal']['x'] = [];player_data['Goal']['y'] = [];\nevent_types = ['Shot','Goal']\nfor data in game_data:\n    if 'liveData' not in data:\n        continue\n    plays = data['liveData']['plays']['allPlays']\n    for play in plays:\n        if 'players' in play:\n            for player in play['players']:\n                # Here we do the filtering on who was involved in the play and who took the shot or scored.\n                if player['player']['fullName'] in [full_name] and player['playerType'] in [\"Shooter\",\"Scorer\"]:\n                    for event in event_types:\n                        if play['result']['event'] in [event]:\n                            if 'x' in play['coordinates']:\n                                player_data[event]['x'].append(play['coordinates']['x'])\n                                player_data[event]['y'].append(play['coordinates']['y'])\n","1fa92be4":"player_total_shots = len(player_data['Shot']['x']) + len(player_data['Goal']['x'])\nplayer_goal_pct = len(player_data['Goal']['x'])\/player_total_shots\nleague_total_shots = len(league_data['Shot']['x']) + len(league_data['Goal']['x'])\nleague_goal_pct = len(league_data['Goal']['x'])\/league_total_shots\nPL_e_spread = player_goal_pct-league_goal_pct\n\n\nprint(\"Player Total Shots: \" + str(player_total_shots))\nprint(\"Player Total Goals: \" + str(len(player_data['Goal']['x'])))\nprint(\"Player SOG %: \" + str(player_goal_pct))\n\n\nprint(\"League Total Shots: \" + str(league_total_shots))\nprint(\"League SOG %: \" + str(league_goal_pct))\n\n# Get the average spread on shot efficiency\nprint(\"Player Vs League SOG% Spread: \" + str(PL_e_spread))","d9201abf":"xbnds = np.array([-100.,100.0])\nybnds = np.array([-100,100])\nextent = [xbnds[0],xbnds[1],ybnds[0],ybnds[1]]\ngridsize= 30;mincnt=0","91f79296":"league_x_all_shots = league_data['Shot']['x'] + league_data['Goal']['x'];league_y_all_shots = league_data['Shot']['y'] + league_data['Goal']['y']\n\n# If we need to flip the x coordinate then we need to also flip the y coordinate!\nleague_x_all_shots_normalized = [];league_y_all_shots_normalized=[]\nfor i,s in enumerate(league_x_all_shots):\n    if league_x_all_shots[i] <0:\n        league_x_all_shots_normalized.append(-league_x_all_shots[i])\n        league_y_all_shots_normalized.append(-league_y_all_shots[i])\n    else:\n        league_x_all_shots_normalized.append(league_x_all_shots[i])\n        league_y_all_shots_normalized.append(league_y_all_shots[i])\n        \n# If we need to flip the x coordinate then we need to also flip the y coordinate!\nleague_x_goal_normalized = [];league_y_goal_normalized=[]\nfor i,s in enumerate(league_data['Goal']['x']):\n    if league_data['Goal']['x'][i] <0:\n        league_x_goal_normalized.append(-league_data['Goal']['x'][i])\n        league_y_goal_normalized.append(-league_data['Goal']['y'][i])\n    else:\n        league_x_goal_normalized.append(league_data['Goal']['x'][i])\n        league_y_goal_normalized.append(league_data['Goal']['y'][i])\n","d6187768":"league_hex_data = plt.hexbin(league_x_all_shots_normalized,league_y_all_shots_normalized,gridsize=gridsize,extent=extent,mincnt=mincnt,alpha=0.0)\nleague_verts = league_hex_data.get_offsets();\nleague_shot_frequency = league_hex_data.get_array();\nleague_goal_hex_data = plt.hexbin(league_x_goal_normalized,league_y_goal_normalized,gridsize=gridsize,extent=extent,mincnt=mincnt,alpha=0.0)\nleague_goal_frequency = league_goal_hex_data.get_array();","75a06e22":"# Create a new figure for plotting\nfig=plt.figure(figsize=(10,10))\nax = fig.add_subplot(111)\nax.set_facecolor(\"white\")\nfig.patch.set_facecolor(\"white\")\nfig.patch.set_alpha(0.0)\nax.set_xticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\nax.set_yticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\n\n# Using pillow to get the rink image and rescale the data base on the image size\nI = Image.open('..\/input\/nhl-images\/half.png')\nax.imshow(I);width, height = I.size\nscalingx=width\/100-0.6;scalingy=height\/100+0.5;x_trans=33;y_trans=height\/2\nS = 3.8*scalingx;\n\n# Loop over the locations and draw the hex\nfor i,v in enumerate(league_verts):\n    if league_shot_frequency[i] < 1:continue\n        \n    scaled_league_shot_frequency = league_shot_frequency[i]\/max(league_shot_frequency)\n    radius = S*math.sqrt(scaled_league_shot_frequency)\n    # Scale the radius to the number of goals made in that area\n    hex = RegularPolygon((x_trans+v[0]*scalingx, y_trans-v[1]*scalingy), \\\n                         numVertices=6, radius=radius, orientation=np.radians(0), \\\n                          alpha=0.5, edgecolor=None)\n    ax.add_patch(hex) \n","b02f5fcd":"player_x_all_shots = player_data['Shot']['x'] + player_data['Goal']['x'];player_y_all_shots = player_data['Shot']['y'] + player_data['Goal']['y']\n\n# If we need to flip the x coordinate then we need to also flip the y coordinate!\nplayer_x_all_shots_normalized = [];player_y_all_shots_normalized=[]\nfor i,s in enumerate(player_x_all_shots):\n    if player_x_all_shots[i] <0:\n        player_x_all_shots_normalized.append(-player_x_all_shots[i])\n        player_y_all_shots_normalized.append(-player_y_all_shots[i])\n    else:\n        player_x_all_shots_normalized.append(player_x_all_shots[i])\n        player_y_all_shots_normalized.append(player_y_all_shots[i])\n        \n# If we need to flip the x coordinate then we need to also flip the y coordinate!\nplayer_x_goal_normalized = [];player_y_goal_normalized=[]\nfor i,s in enumerate(player_data['Goal']['x']):\n    if player_data['Goal']['x'][i] <0:\n        player_x_goal_normalized.append(-player_data['Goal']['x'][i])\n        player_y_goal_normalized.append(-player_data['Goal']['y'][i])\n    else:\n        player_x_goal_normalized.append(player_data['Goal']['x'][i])\n        player_y_goal_normalized.append(player_data['Goal']['y'][i])\n\n        \n        \n        \nplayer_hex_data = plt.hexbin(player_x_all_shots_normalized,player_y_all_shots_normalized,gridsize=gridsize,extent=extent,mincnt=mincnt,alpha=0.0)\nplayer_verts = player_hex_data.get_offsets();\nplayer_shot_frequency = player_hex_data.get_array();\nplayer_goal_hex_data = plt.hexbin(player_x_goal_normalized,player_y_goal_normalized,gridsize=gridsize,extent=extent,mincnt=mincnt,alpha=0.0)\nplayer_goal_frequency = player_goal_hex_data.get_array();\n\n# Create a new figure for plotting\nfig=plt.figure(figsize=(10,10))\nax = fig.add_subplot(111)\nax.set_facecolor(\"white\")\nfig.patch.set_facecolor(\"white\")\nfig.patch.set_alpha(0.0)\nax.set_xticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\nax.set_yticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\n\n# Using pillow to get the rink image and rescale the data base on the image size\nI = Image.open('..\/input\/nhl-images\/half.png')\nax.imshow(I);width, height = I.size\nscalingx=width\/100-0.6;scalingy=height\/100+0.5;x_trans=33;y_trans=height\/2\nS = 3.8*scalingx;\n\n# Loop over the locations and draw the hex\nfor i,v in enumerate(player_verts):\n    if player_shot_frequency[i] < 1:continue\n    \n    scaled_player_shot_frequency = player_shot_frequency[i]\/max(player_shot_frequency)\n    radius = S*math.sqrt(scaled_player_shot_frequency)\n    hex = RegularPolygon((x_trans+v[0]*scalingx, y_trans-v[1]*scalingy), \\\n                         numVertices=6, radius=radius, orientation=np.radians(0), \\\n                          facecolor='#0000FF',alpha=0.1, edgecolor=None)\n    ax.add_patch(hex)\n    \n    \n    scaled_player_goal_frequency = player_goal_frequency[i]\/max(player_goal_frequency)\n    radius = S*math.sqrt(scaled_player_goal_frequency)\n    # Scale the radius to the number of goals made in that area\n    hex = RegularPolygon((x_trans+v[0]*scalingx, (y_trans-v[1]*scalingy)), \\\n                         numVertices=6, radius=radius, orientation=np.radians(0), \\\n                         facecolor='#00FF00', alpha=0.9, edgecolor=None)\n    ax.add_patch(hex) ","c374b6ca":"league_efficiency = []\nplayer_efficiency = []\nrelative_efficiency = []\nfor i in range(0,len(league_shot_frequency)):\n    if league_shot_frequency[i]<2 or player_shot_frequency[i]<2:\n        continue\n    league_efficiency.append(league_goal_frequency[i]\/league_shot_frequency[i])\n    player_efficiency.append(player_goal_frequency[i]\/player_shot_frequency[i])\n    relative_efficiency.append((player_goal_frequency[i]\/player_shot_frequency[i])-(league_goal_frequency[i]\/league_shot_frequency[i]))\n\nmax_league_efficiency = max(league_efficiency)\nmax_player_efficiency = max(player_efficiency)\nmax_relative_efficiency = max(relative_efficiency)\nmin_relative_efficiency = min(relative_efficiency)","5690f85e":"\n# Create a new figure for plotting\nfig=plt.figure(figsize=(10,10))\nax = fig.add_subplot(111)\nax.set_facecolor(\"white\")\nfig.patch.set_facecolor(\"white\")\nfig.patch.set_alpha(0.0)\nax.set_xticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\nax.set_yticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\n\n# Using pillow to get the rink image and rescale the data base on the image size\nI = Image.open('..\/input\/nhl-images\/half.png')\nax.imshow(I);width, height = I.size\nscalingx=width\/100-0.6;scalingy=height\/100+0.5;x_trans=33;y_trans=height\/2\nS = 3.8*scalingx;\n\n# Loop over the locations and draw the hex\nfor i,v in enumerate(player_verts):\n    if player_shot_frequency[i] < 1:continue\n    \n    \n    scaled_player_shot_frequency = player_shot_frequency[i]\/max(player_shot_frequency)\n    radius = S*math.sqrt(scaled_player_shot_frequency)\n    \n    player_efficiency = player_goal_frequency[i]\/player_shot_frequency[i]\n    league_efficiency = league_goal_frequency[i]\/league_shot_frequency[i]\n    relative_efficiency = player_efficiency - league_efficiency\n  \n    if relative_efficiency>0:\n        colour = positive_cm(math.pow(relative_efficiency,0.1))\n    else:\n        colour = negative_cm(math.pow(-relative_efficiency,0.1))\n    \n    hex = RegularPolygon((x_trans+v[0]*scalingx, y_trans-v[1]*scalingy), \\\n                         numVertices=6, radius=radius, orientation=np.radians(0), \\\n                          facecolor=colour,alpha=1, edgecolor=None)\n    ax.add_patch(hex)\n    \n    ","afc02fa1":"fig=plt.figure(figsize=(50,50))\nax = fig.add_subplot(111)\nax.set_facecolor(\"white\")\nfig.patch.set_facecolor(\"white\")\nfig.patch.set_alpha(0.0)\nax.set_xticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\nax.set_yticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\n\n# Using pillow to get the rink image and rescale the data base on the image size\nI = Image.open('..\/input\/nhl-images\/half.png')\nax.imshow(I);width, height = I.size\nscalingx=width\/100-0.6;scalingy=height\/100+0.5;x_trans=33;y_trans=height\/2\nS = 3.8*scalingx;\n# Loop over the locations and draw the hex\nfor i,v in enumerate(player_verts):\n    if player_shot_frequency[i] < 4:continue\n    \n    \n    scaled_player_shot_frequency = player_shot_frequency[i]\/max(player_shot_frequency)\n    radius = S*math.sqrt(scaled_player_shot_frequency)\n    \n    player_efficiency = player_goal_frequency[i]\/player_shot_frequency[i]\n    league_efficiency = league_goal_frequency[i]\/league_shot_frequency[i]\n    relative_efficiency = player_efficiency - league_efficiency\n  \n    if relative_efficiency>0:\n        colour = positive_cm(math.pow(relative_efficiency,0.1))\n    else:\n        colour = negative_cm(math.pow(-relative_efficiency,0.1))\n    \n    hex = RegularPolygon((x_trans+v[0]*scalingx, y_trans-v[1]*scalingy), \\\n                         numVertices=6, radius=radius, orientation=np.radians(0), \\\n                          facecolor=colour,alpha=1, edgecolor=None)\n    ax.add_patch(hex)\n    \nax.set_xlim([0,width])\nax.set_ylim([0,height])\nfor spine in ax.spines.values():\n    spine.set_edgecolor('white')\nplt.grid(False)\n","6733d87b":"As a final step we can just increase the threshold of data points to look at.  Let's only look at locations where he took more than 4 shots in the season.","c1e39d4f":"Now that we have the leauge data we can do the same things for a given player.  The only difference is that we will filter for the Shooter sub event type when doing the data extraction.\n\nLet's do it for **Alex Ovechkin**!","cc99916a":"Very cool!  We can see that he is very active on the left side above the ring!  After consulting with my hockey friends it turns out that this is really his spot!  But now we should look at his efficiency on the ice.  Is this his spot because he just shoots a lot there?\n\nTo do this I am going to make the size of the hex the shooting frequency and the colour represent his efficiency!","c8994787":"Perfect!  Nice and clean and ready for post processing! \n\nHope you enjoyed!","504a02a5":"Using the NHL data I wanted to look at where players are taking their most efficient (Goal %) shots compared to the league averages.  To start, lets import all of the required packages.  Note I am using matplotlib for all of my plotting.  I also installed pillow to import the image data.\n\nIf you do not have pillow installed go to the kernel and run pip install pillow.","901160b6":"# Calculating Basic Statistics\nBefore we plot the location data I wanted to calculate the high level stats on the player compared to the leauge averages.","f81bfcd3":"Now that we have that settled lets load the pickle data file for the 2019 regular season which has all of the event data for every game.","b0ed28bb":"Wow!  A beautiful empty plot!  This is because we actually just want to use the raw data and we simply are setting the alpha to zero to ignore this data.  Now that we have something we want to take a look at the league shot distribution over the ice.  To do this we will also include a properly to scale image of the half of the rink (I made this custom) and scale the matplotlib image to match.","7a211db1":"Cool.  Now for the money!  Calling the hexbin plot and extracting the counts and locations.","a54aec48":"Here we have our first result.  We can compare this to official numbers and it matches.  We can see that the spread of 5.8 for Ovechkin means he is an efficient scorer.  But is this true at all points on the ice?  Does he have a dominant side, or any weakness?  Now we can move onto the location analysis.\n\n# Shot Location Analysis and Plotting\nWhat we are going to do first is set up a binning grid.  Even if we have every location we would like to understand more spatially averaged shot data.  This way we can make more insigtful and visual representations.  The position data extends from -100 to 100 in the x and -42.5 to 42.5 in the y axis.  For our binning we are using hex plots from matplotlib to extract the raw binning data and will use drawn rectangles (again matplotlib) for the final visuals.\n\nTo start we define our figure dimensions and grid size:","2cd4adfa":"Cool!  Keep in mind that the translation factors set in the plotting above were done by eye, so if we do change things up later we might have to re-adjust.\n\nNow lets do the same things for the player data to confirm things look reasonable!","a404e70d":"Finally for the plotting!","a5c49233":"Next we will find the efficiency of the league at each location on the ice.  To do this we call the hexbin method and extract the location vertex and count data.  Once thing to note is that since the scorer never scores on their own net we must make sure the negative locations are flipped correctly to always represent the attacking side.  This is all because every period the player switch sides and the coordinate system is fixed.","69d2fe06":"# Calculating the Average Shooting %\nWith the data loaded I want to first calculate the league average shooting percent at each point on the ice.  The data comes in using events and coordinate objects.  So we will find these for the **\"Shot\"** and **\"Goal\"** type events.  These are what count toward the final percentages on the official pages."}}