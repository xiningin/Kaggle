{"cell_type":{"5305beda":"code","3649ed21":"code","c04a2e78":"code","ba6a15b2":"code","4c6e77e3":"code","92ff988f":"code","cfaca977":"code","1f30455b":"code","1948f506":"code","c7f6bf67":"code","a76e61cf":"code","5f7e9fd1":"code","18464108":"code","8d9f30cd":"code","89be967c":"code","8dfcc9a4":"code","8eabfe6c":"code","918716a6":"code","20c82320":"code","fdf48ccf":"code","e83eb4fd":"code","8b33168e":"code","ee2fc500":"code","8f5ba15b":"code","229ead41":"markdown","da6178fc":"markdown","0d092492":"markdown","69bd2082":"markdown","1be07684":"markdown","71f5baf9":"markdown","9bf043de":"markdown","ff5606ee":"markdown","79e2c1a9":"markdown"},"source":{"5305beda":"from IPython.display import HTML\nHTML('<iframe width=\"720\" height=\"480\" src=\"https:\/\/www.youtube.com\/embed\/ysBaZO8YmX8\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>')","3649ed21":"!pip install pytorch-tabnet","c04a2e78":"import numpy as np \nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom pandas_profiling import ProfileReport\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import mean_squared_error, classification_report\nfrom sklearn.preprocessing import LabelEncoder\n\nfrom sklearn.model_selection import train_test_split\nfrom pytorch_tabnet.tab_model import TabNetClassifier\nimport os\nimport torch\n       \nimport gc\nimport matplotlib.pyplot as plt\n\nfrom sklearn import metrics\npd.set_option('max_rows', 300)\nimport re\n\n\npd.set_option('display.max_columns', 300)\nnp.random.seed(566)\npd.set_option('display.max_rows', 200)\npd.set_option('display.width', 1000)\npd.set_option('display.float_format', '{:20,.2f}'.format)\npd.set_option('display.max_colwidth', -1)","ba6a15b2":"TARGET_COL = \"diabetes_mellitus\"\ndf = pd.read_csv(\"\/kaggle\/input\/widsdatathon2021\/TrainingWiDS2021.csv\")\nprint(df.shape)\ntest = pd.read_csv(\"\/kaggle\/input\/widsdatathon2021\/UnlabeledWiDS2021.csv\")\nprint(test.shape)","4c6e77e3":"trainprofile = ProfileReport(df,'EDA')","92ff988f":"trainprofile","cfaca977":"## Print the categorical columns\nprint([c for c in df.columns if (1<df[c].nunique()) & (df[c].dtype != np.number)& (df[c].dtype != int) ])\ncategorical_cols =  ['hospital_id',\n 'ethnicity', 'gender', 'hospital_admit_source', 'icu_admit_source', 'icu_stay_type', 'icu_type']","1f30455b":"## Handle na values\ndf[categorical_cols] = df[categorical_cols].fillna(\"\")\ntest[categorical_cols] = test[categorical_cols].fillna(\"\")\n\ndf[categorical_cols].isna().sum()","1948f506":"for col in df.columns[df.dtypes == 'float64']:\n    df.fillna(df[col].mean(), inplace=True)\n    test.fillna(test[col].mean(), inplace=True)","c7f6bf67":"unused_feat = ['encounter_id', 'hospital_id', 'Unnamed: 0']\n\nfeatures = [ col for col in df.columns if col not in unused_feat+[TARGET_COL]] \n","a76e61cf":"categorical_columns = ['ethnicity', 'gender', 'hospital_admit_source', 'icu_admit_source', 'icu_stay_type', 'icu_type']\ncategorical_dims =  {}\nfor col in categorical_columns:\n    print(col, df[col].nunique())\n    l_enc = LabelEncoder()\n    df[col] = df[col].fillna(\"VV_likely\")\n    test[col] = test[col].fillna(\"VV_likely\")\n    l_enc = l_enc.fit(np.unique(np.concatenate((df[col].unique(), test[col].unique()), axis=None)))\n    df[col] = l_enc.transform(df[col].values)\n    test[col] = l_enc.transform(test[col].values)\n    categorical_dims[col] = len(l_enc.classes_)\n","5f7e9fd1":"\ncat_idxs = [ i for i, f in enumerate(features) if f in categorical_columns]\n\ncat_dims = [ categorical_dims[f] for i, f in enumerate(features) if f in categorical_columns]","18464108":"clf = TabNetClassifier(\n    n_d=64, n_a=64, n_steps=5,\n    gamma=1.5, n_independent=2, n_shared=2,\n    cat_idxs=cat_idxs,\n    cat_dims=cat_dims,\n    cat_emb_dim=1,\n    lambda_sparse=1e-4, momentum=0.3, clip_value=2.,\n    optimizer_fn=torch.optim.Adam,\n    optimizer_params=dict(lr=2e-2),\n    scheduler_params = {\"gamma\": 0.95,\n                     \"step_size\": 20},\n    scheduler_fn=torch.optim.lr_scheduler.StepLR, epsilon=1e-15,\n    mask_type=\"sparsemax\"\n)\n","8d9f30cd":"n_total = len(df)\n\ntrain_indices, valid_indices = train_test_split(\n    range(n_total), test_size=0.1, random_state=0)","89be967c":"## Train Test split and remove Target values\n\n\nX_train = df[features].values[train_indices]\ny_train = df[TARGET_COL].values[train_indices]\n\nX_valid = df[features].values[valid_indices]\ny_valid = df[TARGET_COL].values[valid_indices]\n","8dfcc9a4":"max_epochs = 5000 if not os.getenv(\"CI\", False) else 2","8eabfe6c":"clf.fit(\n    X_train=X_train, y_train=y_train,\n    eval_set=[(X_train, y_train), (X_valid, y_valid)],\n    eval_name=['train', 'valid'],\n    eval_metric = [ 'auc','balanced_accuracy', 'logloss'],\n    max_epochs=max_epochs, patience=150,\n    batch_size=16384, virtual_batch_size=256\n)\n\n","918716a6":"# plot losses\nplt.plot(clf.history['loss'])","20c82320":"# To get final results you may need to use a mapping for classes \n# as you are allowed to use targets like [\"yes\", \"no\", \"maybe\", \"I don't know\"]\n\npreds_mapper = { idx : class_name for idx, class_name in enumerate(clf.classes_)}\n\npreds = clf.predict_proba(X_valid)\n\ny_pred = np.vectorize(preds_mapper.get)(np.argmax(preds, axis=1))\n\nvalid_acc = accuracy_score(y_pred=y_pred, y_true=y_valid)\n\nprint(f\"BEST MODEL FOR widsdatathon2021 : {clf.best_cost}\")\nprint(f\"FINAL VALID SCORE FOR widsdatathon2021 : {valid_acc}\")","fdf48ccf":"clf.feature_importances_","e83eb4fd":"explain_matrix, masks = clf.explain(X_valid)","8b33168e":"fig, axs = plt.subplots(1, 5, figsize=(20,20))\n\nfor i in range(5):\n    axs[i].imshow(masks[i][:50])\n    axs[i].set_title(f\"mask {i}\")","ee2fc500":"test[TARGET_COL] = clf.predict_proba(test[features].values)[:,1]","8f5ba15b":"test[[\"encounter_id\",\"diabetes_mellitus\"]].to_csv(\"submission.csv\",index=False)","229ead41":"#### Nan Values in numerical columns","da6178fc":"#### Train\/Test split","0d092492":"### EDA with Pandas profiling:","69bd2082":"#### Defining TabNat model","1be07684":"##### Categorical Encoding","71f5baf9":"![](https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/22359\/logos\/header.png?t=2020-12-29-21-53-27)","9bf043de":"# WiDS Datathon 2021: TabNet starter\n### Goal:\nPredecting **Diabetes Mellitus** (a particular type of diabetes) of patient based on the data from the first 24 hours of intensive care of a patient.\n### Credit:\nThanks to [Ruchi Bahtia](https:\/\/www.kaggle.com\/ruchi798) and [Tensor Girl](https:\/\/www.kaggle.com\/usharengaraju) for their starter notebooks, be sure to check and upvote them!\n### Methode: \nI am trying the [TabNet](https:\/\/github.com\/dreamquark-ai\/tabnet) library fot the first time with just basic preprocessing of the competiton data. Check out the github repo and the great talk with  [Abhishek Thakur](https:\/\/www.kaggle.com\/abhishek) on youtube [Here](https:\/\/www.youtube.com\/watch?v=ysBaZO8YmX8)\n","ff5606ee":"### Preprocessing:\n#### Nan Values in categorical columns","79e2c1a9":"#### Train"}}