{"cell_type":{"323b27ea":"code","88ea910c":"code","000e08e5":"code","6d65f5f7":"code","ce381972":"code","b1370874":"code","cfa490a9":"code","6958a454":"code","39ed7d95":"code","bf90df84":"code","848ffd12":"code","30b67e16":"code","9f0f6344":"code","d76a259d":"code","380e4403":"markdown","fbf37f17":"markdown","84c019b5":"markdown","93c98751":"markdown","f51a752b":"markdown","dd810313":"markdown","a113fc82":"markdown","9dff608b":"markdown","1ce93989":"markdown","fbd259bb":"markdown","65149d25":"markdown","dc0bac01":"markdown","47679fd6":"markdown"},"source":{"323b27ea":"import numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport glob\nimport os\n\n# Deep learning\nfrom keras import backend as K\nfrom keras.preprocessing.image import ImageDataGenerator,load_img, img_to_array\nfrom keras.models import Sequential, Model\nfrom keras.layers import Conv2D, MaxPooling2D,GlobalAveragePooling2D, Conv3D, MaxPooling3D,GlobalAveragePooling3D\nfrom keras.layers import Activation, Dropout, BatchNormalization, Flatten, Dense, AvgPool2D,MaxPool2D\nfrom keras.applications.vgg16 import VGG16, preprocess_input\nfrom keras.optimizers import Adam, SGD, RMSprop\nimport tensorflow as tf \nfrom tensorflow.keras.preprocessing import image","88ea910c":"path = []\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        if (filename[-3:] == 'png'):\n            path.append(os.path.join(dirname, filename))\n            \nfullpath = \"..\/input\/covid19-radiography-database\/COVID-19_Radiography_Dataset\"\nos.listdir(fullpath)            ","000e08e5":"normal_images = []\nimages_together = []\n\ncount = 0\n\nfor img_path in glob.glob(fullpath + \"\/Normal\/*\"):\n    count += 1\n    normal_images.append(image.load_img(str(img_path), target_size = (150,150,3)))\n   \n    if count >1000:\n        break\n      \ncovid_images = []\ncount = 0\n\nfor img_path in glob.glob(fullpath + \"\/COVID\/*\"):\n    count += 1\n    covid_images.append(image.load_img(str(img_path), target_size = (150,150,3)))\n    if count > 1000:\n        break\nLung_opcaity = []\ncount = 0\n\nfor img_path in glob.glob(fullpath + \"\/Lung_Opacity\/*\"):\n    count += 1\n    Lung_opcaity.append(image.load_img(str(img_path), target_size = (150,150,3)))\n    if count > 1000:\n        break\nViral_pneumonia = []\ncount = 0\n\nfor img_path in glob.glob(fullpath + \"\/Viral Pneumonia\/*\"):\n    count += 1\n    Viral_pneumonia.append(image.load_img(str(img_path), target_size = (150,150,3)))\n    if count >1000:\n        break","6d65f5f7":"y=[]\n\nfor i in normal_images:\n    images_together.append(img_to_array(i))\n    y.append(0)\n\nfor i in covid_images:\n    images_together.append(img_to_array(i))\n    y.append(1)\n\nfor i in Lung_opcaity:\n    images_together.append(img_to_array(i))\n    y.append(2)\nfor i in Viral_pneumonia:\n    images_together.append(img_to_array(i))\n    y.append(3)\n\nprint(\"Lenth of all images \",len(images_together))\nprint(\"Lenth of y \",len(y))\nfrom tensorflow.keras.utils import to_categorical\ny=to_categorical(y)\n","ce381972":"\nimages_together = np.array(images_together)\nprint(\"shape of images together: \",images_together.shape)\nfrom sklearn.model_selection import train_test_split\nX_train, x_test, y_train, y_test = train_test_split(images_together, y, test_size=0.25, stratify=y)\n\nimages_together = np.concatenate((X_train, x_test))\ny = np.concatenate((y_train, y_test))","b1370874":"\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 32, kernel_size =(3,3), activation = \"relu\", input_shape=(150,150,3), kernel_initializer='he_normal',))\nmodel.add(MaxPool2D(pool_size = (2,2)))\nmodel.add(Conv2D(filters = 64, kernel_size =(3,3), activation = \"relu\"))\nmodel.add(MaxPool2D(pool_size = (2,2)))\nmodel.add(Conv2D(filters = 128, kernel_size =(3,3), activation = \"relu\"))\nmodel.add(MaxPool2D(pool_size = (2,2), strides = (1,1)))\nmodel.add(Dropout(0.25))\n#fully connected\nmodel.add(Flatten())\n# we have 4 classes\nmodel.add(Dense(4, activation = \"softmax\"))\n# compile \nmodel.compile(loss = \"categorical_crossentropy\",\n             optimizer = \"adam\",\n             metrics = [\"accuracy\"])","cfa490a9":"print(model.summary())","6958a454":"from keras.preprocessing.image import ImageDataGenerator,load_img, img_to_array\ntrain_datagen = ImageDataGenerator(rescale = 1.\/255,\n                                  shear_range = 0.2,\n                                  zoom_range = 0.2,\n                                  horizontal_flip = True,\n                                  validation_split = 0.25)\n\n\ntrain_generator = train_datagen.flow(\nimages_together, y,\nbatch_size = 40,\nsubset = \"training\")\n\nvalidation_generator = train_datagen.flow(\nimages_together, y,\nbatch_size = 40,\nshuffle = False,\nsubset = \"validation\")\n\n#fitting\n# use model.fit insted of model.fit_generator\n#`Model.fit_generator` is deprecated and will be removed in a future version. Please use `Model.fit`, which supports generators.\nhistory = model.fit(\ntrain_generator,\nsteps_per_epoch = 20,\nvalidation_data = validation_generator,\nepochs = 75)","39ed7d95":"fig, ax = plt.subplots(1, 2, figsize=(22, 8))\nax = ax.ravel()\n\nfor i, met in enumerate(['accuracy', 'loss']):\n    ax[i].plot(history.history[met])\n    ax[i].plot(history.history['val_' + met])\n    ax[i].set_title('Model {}'.format(met))\n    ax[i].set_xlabel('epochs')\n    ax[i].set_ylabel(met)\n    ax[i].legend(['train', 'val'])","bf90df84":"plt.plot(history.history['val_loss'], label = 'training loss')\nplt.plot(history.history['val_accuracy'], label = 'training accuracy')\nplt.legend()","848ffd12":"test_loss,test_acc=model.evaluate(x_test,y_test)","30b67e16":"from sklearn.metrics import classification_report\nprediction = model.predict(x_test, batch_size=40)\nprediction = np.argmax(prediction, axis=1)\nprint(classification_report(y_test.argmax(axis=1), prediction, digits = 3))","9f0f6344":"from sklearn.metrics import confusion_matrix\ncm = confusion_matrix(y_test.argmax(axis=1), prediction)\nprint(cm)","d76a259d":"from sklearn import linear_model\nfrom mlxtend.plotting import plot_confusion_matrix\nfrom sklearn.metrics import accuracy_score\nimport seaborn as sns\nimport sklearn as skplt\ndf_cm = pd.DataFrame(cm, \n                     index = [i for i in range(0,4)], columns = [i for i in range(0,4)])\nplt.figure(figsize=(10,4))\nsns.heatmap(df_cm, annot=True)\nplt.title(' CNN Model  \\nAccuracy:{0:.3f}'.format(accuracy_score(y_test.argmax(axis=1), prediction)))\nplt.ylabel('True label')\nplt.xlabel('Predicted label')\n","380e4403":"# Data Proccessing ","fbf37f17":"# Learning Proccess","84c019b5":"*I got approximate accuracy 84%*","93c98751":"# Importing Data Path","f51a752b":"# Model Summary","dd810313":"# *Importing Libraries*","a113fc82":" *We are going to classify three classes : Normal, COVID, Lung_Copacity and Viral Pneumonia*\n \n* taking from each class 1000 images","9dff608b":"# Plotting Loss and Accuracy Vector","1ce93989":"If you have any advise for this moddel please share it ","fbd259bb":"> I tried 750 picture from Covid and Lung Opacity and Viral Pneumonia and I got better accuracy 87% ","65149d25":"# Implementing Confusing Matrix","dc0bac01":"**NOTE Use to_categorical Otherwise you will have a really bad accuracy**","47679fd6":"*Buidling A CNN model with a NonLinaer activation Function becuase We have three classess                               \nand A softmask at the output layer for Multi class Classification*\n\n**image size is 150x150  with 3 channels**"}}