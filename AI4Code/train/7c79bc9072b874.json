{"cell_type":{"df0c3910":"code","365f0288":"code","7d285faf":"code","7d7b5d86":"code","bfea0457":"code","18922a10":"code","1252f6a4":"code","5310e096":"code","acde7845":"code","256b9e3f":"code","3d45fc9d":"code","fd712555":"code","097b08f5":"code","85605e69":"code","bcb9eba4":"code","dc779c4e":"code","f53d1a18":"code","91974172":"code","1d609841":"code","764b3d73":"code","b68c303a":"markdown","c4e5db52":"markdown","cd6aff76":"markdown"},"source":{"df0c3910":"import pandas as pd\nimport numpy as np\nfrom sklearn import preprocessing, metrics\nfrom sklearn.model_selection import StratifiedKFold\nfrom imblearn.over_sampling import SMOTE\nfrom xgboost.sklearn import XGBClassifier","365f0288":"\"\"\"\n1) id: unique identifier\n2) gender: \"Male\", \"Female\" or \"Other\"\n3) age: age of the patient\n4) hypertension: 0 if the patient doesn't have hypertension, 1 if the patient has hypertension\n5) heart_disease: 0 if the patient doesn't have any heart diseases, 1 if the patient has a heart disease\n6) ever_married: \"No\" or \"Yes\"\n7) work_type: \"children\", \"Govt_jov\", \"Never_worked\", \"Private\" or \"Self-employed\"\n8) Residence_type: \"Rural\" or \"Urban\"\n9) avg_glucose_level: average glucose level in blood\n10) bmi: body mass index (have NaN)\n11) smoking_status: \"formerly smoked\", \"never smoked\", \"smokes\" or \"Unknown\"*\n12) stroke: 1 if the patient had a stroke or 0 if not\n*Note: \"Unknown\" in smoking_status means that the information is unavailable for this patient\n\"\"\"\n# read data\ndata = pd.read_csv('..\/input\/stroke-prediction-dataset\/healthcare-dataset-stroke-data.csv')\ndata.head()","7d285faf":"data[\"gender\"].value_counts()","7d7b5d86":"data[\"age\"].plot(kind=\"hist\", bins=50)","bfea0457":"data[\"hypertension\"].value_counts()","18922a10":"data[\"heart_disease\"].value_counts()","1252f6a4":"data[\"ever_married\"].value_counts()","5310e096":"data[\"work_type\"].value_counts()","acde7845":"data[\"Residence_type\"].value_counts()","256b9e3f":"data[\"avg_glucose_level\"].plot(kind=\"hist\", bins=50)","3d45fc9d":"data[\"bmi\"].plot(kind=\"hist\", bins=50)","fd712555":"data[\"smoking_status\"].value_counts()","097b08f5":"# deal with category features\ndata.drop([\"id\"], axis=1, inplace=True)\ndata[\"ever_married\"] = data[\"ever_married\"].map({\"Yes\": 1, \"No\": 0})\ndata[\"smoking_status_Unknown\"] = (data[\"smoking_status\"] == \"Unknown\").astype(int)\ndata[\"smoking_status\"] = data[\"smoking_status\"].map({\"never smoked\": 0,\n                                                     \"formerly smoked\": 1,\n                                                     \"smokes\": 2,\n                                                     \"Unknown\": 0})\ndata = pd.get_dummies(data)\ndata.head()","85605e69":"data.isnull().sum(axis=0)","bcb9eba4":"data.loc[data[\"bmi\"].isnull(), ][\"stroke\"].value_counts()","dc779c4e":"data.loc[data[\"bmi\"].notnull(), ][\"stroke\"].value_counts()","f53d1a18":"# solution 3: fill with median\ndata_fill = data.fillna(data[\"bmi\"].median())\ndata_fill[\"stroke\"].value_counts()","91974172":"data_fill[\"bmi\"].plot(kind=\"hist\", bins=50)\ndata[\"bmi\"].plot(kind=\"hist\", bins=50)","1d609841":"X = data_fill[data_fill.columns.drop([\"stroke\"])]\ny = data_fill[\"stroke\"]\n\nfold = 5\nresult_acc = np.zeros(fold)\nresult_f1 = np.zeros(fold)\n\nsfolder = StratifiedKFold(n_splits=fold, random_state=0, shuffle=True)\ni=0\nfor train, test in sfolder.split(data_fill, data_fill['stroke']):\n    X_train = X.iloc[train, :]\n    X_test = X.iloc[test, :]\n    y_train = y.iloc[train]\n    y_test = y.iloc[test]\n\n    pos_weigth = np.unique(y_train, return_counts=True)[1][0] \/ np.unique(y_train, return_counts=True)[1][1]\n\n    xgb = XGBClassifier(objective='binary:logitraw', \n                        n_estimators=200,\n                        max_depth=3,\n                        min_child_weight=7,\n\n                        scale_pos_weight=pos_weigth, seed=0, use_label_encoder=False)\n    xgb.fit(X_train, y_train)\n\n    y_test_result = xgb.predict(X_test)\n    result_acc[i] = metrics.accuracy_score(y_test, y_test_result)\n    result_f1[i] = metrics.f1_score(y_test, y_test_result)\n    i += 1\nprint(\"accuracy_score: {score}+-{std}\".format(score=round(result_acc.mean(), 3), std=round(result_acc.std(), 3)))\nprint(\"f1_score: {score}+-{std}\".format(score=round(result_f1.mean(), 3), std=round(result_f1.std(), 3)))","764b3d73":"X = data_fill[data_fill.columns.drop([\"stroke\"])]\ny = data_fill[\"stroke\"]\n\nfold = 5\nresult_acc = np.zeros(fold)\nresult_f1 = np.zeros(fold)\nsfolder = StratifiedKFold(n_splits=fold, random_state=0, shuffle=True)\ni=0\nfrom sklearn.preprocessing import StandardScaler \n\nfor train, test in sfolder.split(data_fill, data_fill['stroke']):\n    X_train = X.iloc[train, :].values\n    y_train = y.iloc[train].values\n\n    sm = SMOTE(random_state=0)\n    X_train, y_train = sm.fit_resample(X_train, y_train)\n    X_train = pd.DataFrame(X_train, columns=data_fill.columns.drop(\"stroke\"))\n\n    binary_features = X_train.columns.drop([\"age\", \"avg_glucose_level\", \"bmi\", \"smoking_status\"])\n    X_train[binary_features] = X_train[binary_features].apply(lambda x: x>0.5)\n    X_train[\"smoking_status\"] = X_train[\"smoking_status\"].apply(lambda x: 2 if x > 1.5 else 1 if x > 0.5 else 0)\n\n    X_test = X.iloc[test, :]\n    y_test = y.iloc[test].values\n    \n    sc = StandardScaler()\n    X_train = sc.fit_transform(X_train)\n    X_test = sc.transform(X_test)\n\n    pos_weigth = np.unique(y_train, return_counts=True)[1][0] \/ np.unique(y_train, return_counts=True)[1][1]\n    xgb = XGBClassifier(objective='binary:logitraw', \n                        n_estimators=200,\n                        max_depth=2,\n                        min_child_weight=7,\n                        gamma=1,\n                        subsample=1,\n                        reg_alpha=0,\n                        reg_lambda=1,\n                        learning_rate=0.3,\n                        scale_pos_weight=pos_weigth, seed=0, use_label_encoder=False)\n    xgb.fit(X_train, y_train)\n\n    y_test_result = xgb.predict(X_test)\n    result_acc[i] = metrics.accuracy_score(y_test, y_test_result)\n    result_f1[i] = metrics.f1_score(y_test, y_test_result)\n    i += 1\n    \nprint(\"accuracy_score: {score}+-{std}\".format(score=round(result_acc.mean(), 3), std=round(result_acc.std(), 3)))\nprint(\"f1_score: {score}+-{std}\".format(score=round(result_f1.mean(), 3), std=round(result_f1.std(), 3)))","b68c303a":"data preprocessing\n----","c4e5db52":"xgboost\n--","cd6aff76":"xgboost + SMOTE\n--"}}