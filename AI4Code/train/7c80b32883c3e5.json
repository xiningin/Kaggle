{"cell_type":{"f7899cca":"code","92cf0333":"code","4467ad1f":"code","625cda2d":"code","f7251618":"code","3cf581be":"code","42545705":"code","03f2fca9":"code","3ee52121":"code","d81d759a":"code","19c4d92e":"code","8407229d":"code","43c78761":"code","77e7cfe5":"code","02cfd2bc":"code","c98cd5b9":"code","33f9a4c8":"code","a562e761":"code","d0ce9b7c":"code","5707c54c":"code","49e2dde5":"code","8d1f9004":"code","72b705de":"code","eb2e2bb1":"code","afbcea97":"code","6015c921":"code","deabd8d6":"code","a4f1b790":"code","8093be69":"code","29757d9d":"code","885dbd27":"markdown","749b8825":"markdown","2f971c30":"markdown","15778577":"markdown","c45f936d":"markdown","18e592a3":"markdown","2fdc5b58":"markdown","90e0ce67":"markdown","94c9db3b":"markdown","a035796d":"markdown","b48f9b91":"markdown","20bca091":"markdown","340fdc78":"markdown","4c6d9885":"markdown","03a9e8a7":"markdown","91752261":"markdown","d11c43e7":"markdown","53de25ae":"markdown","a41a379f":"markdown","e8551c02":"markdown","bfafb4cf":"markdown","83a25b1c":"markdown","e60996b5":"markdown","39bd7de4":"markdown","0b300c8e":"markdown","12b221ff":"markdown","36d05b47":"markdown","f4513f6a":"markdown","26aba37b":"markdown","fc72de08":"markdown","91e06958":"markdown","ee9c49ee":"markdown"},"source":{"f7899cca":"%matplotlib inline\nimport numpy as np\nimport pandas as pd\nimport re\nimport math\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport itertools\n\nplt.style.use('seaborn-whitegrid')","92cf0333":"# Data about countries\ncountries = pd.read_csv('..\/input\/global-education-statistics\/EdStatsCountry.csv')\n\n# Data about each indicator (unit, date, ...)\nindicators = pd.read_csv('..\/input\/global-education-statistics\/EdStatsSeries.csv')\n\n# Data containing values of each indicators for each country and year\ninitial_data = pd.read_csv('..\/input\/global-education-statistics\/EdStatsData.csv')\n# Creating a copy to work on\ndata = initial_data.copy(deep=True)\n\n# We load the 2 other files but we don't use them\nseries = pd.read_csv('..\/input\/global-education-statistics\/EdStatsCountry-Series.csv', delimiter=',', doublequote=True)\nfootnotes = pd.read_csv('..\/input\/global-education-statistics\/EdStatsFootNote.csv')","4467ad1f":"# Minimum population of the countries we keep in the dataset\nMINIMUM_POPULATION = 2000000\n\n# Maximum difference between the country revenue and the revenue of the reference country (France) - In percents (%)\nMAX_REVENUE_PERCENT_DIFF = 20\n\n# Minimum year to keep in the dataset (has been choosen by analysing the data below)\nMIN_YEAR = 2005\nMAX_YEAR = 2015\n\n# Reference country code\nREF_COUNTRY_CODE = \"FRA\"","625cda2d":"def format_percentage(value):\n    '''\n    Format a percentage with 1 digit after comma \n    '''\n    return \"{0:.1f}%\".format(value * 100)\n\n\n# We create a table containing all information about the 5 files\nfiles_description = pd.DataFrame(columns = [\"Nb lignes\", \"Nb colonnes\", \"Taux remplissage moyen\", \"Doublons\", \"Description\"],\n                                 index = [\"EdStatsCountry.csv\", \n                                          \"EdStatsSeries.csv\", \n                                          \"EdStatsData.csv\", \n                                          \"EdStatsCountry-Series.csv\", \n                                          \"EdStatsFootNote.csv\"])\n\n# Filling the total number rows in each file\nfiles_description[\"Nb lignes\"] = [\n    len(countries.index),\n    len(indicators.index),\n    len(initial_data.index),\n    len(series.index),\n    len(footnotes.index)\n]\n\n# Filling the number of columns in each file\nfiles_description[\"Nb colonnes\"] = [\n    len(countries.columns),\n    len(indicators.columns),\n    len(initial_data.columns),\n    len(series.columns),\n    len(footnotes.columns)\n]\n\n# Filling the fill-percentile of each file\n# We use the mean() function twice to calculate the mean for each columns, and then the mean for the whole file\nfiles_description[\"Taux remplissage moyen\"] = [\n    format_percentage(countries.notna().mean().mean()),\n    format_percentage(indicators.notna().mean().mean()),\n    format_percentage(initial_data.notna().mean().mean()),\n    format_percentage(series.notna().mean().mean()),\n    format_percentage(footnotes.notna().mean().mean())\n]\n\n# FIlling the number of duplicate keys for each file\nfiles_description[\"Doublons\"] = [\n    countries.duplicated(subset=[\"Country Code\"]).sum(),\n    indicators.duplicated(subset=[\"Indicator Name\"]).sum(),\n    initial_data.duplicated(subset=[\"Country Code\", \"Indicator Name\"]).sum(),\n    series.duplicated(subset=[\"CountryCode\", \"SeriesCode\"]).sum(),\n    footnotes.duplicated(subset=[\"CountryCode\", \"SeriesCode\", \"Year\"]).sum(),\n]\n\n# Finally adding a short description for each file\nfiles_description[\"Description\"] = [\n    \"Liste des pays avec leurs donn\u00e9es principales\",\n    \"Liste des indicateurs avec description, unit\u00e9, p\u00e9riode, etc...\",\n    \"Donn\u00e9es de chaque indicateur par pays et par ann\u00e9e\",\n    \"Description des diff\u00e9rentes s\u00e9ries de donn\u00e9es (majoritairement provenance)\",\n    \"Commentaire pour chaque couple s\u00e9rie de donn\u00e9es \/ pays\"\n]\n\n\nfiles_description","f7251618":"# Preparing a list that will contains all the indicator codes we want to keep\nchoosen_indicators = []","3cf581be":"population_indicators = [\"SP.POP.TOTL\", \"SP.POP.GROW\", \"SP.POP.1524.TO.UN\", \"SP.SEC.TOTL.IN\", \"SP.SEC.UTOT.IN\", \n                         \"SP.TER.TOTL.IN\"]","42545705":"internet_indicators = [\"IT.NET.USER.P2\", \"IT.CMP.PCMP.P2\"]","03f2fca9":"revenue_indicators = [\"NY.GDP.PCAP.PP.CD\"]","3ee52121":"choosen_indicators.extend(population_indicators)\nchoosen_indicators.extend(internet_indicators)\nchoosen_indicators.extend(revenue_indicators)\nchoosen_indicators","d81d759a":"# Filtering the data set on the selected indicators\ndata = data[data[\"Indicator Code\"].isin(choosen_indicators)]\n\n# Displaying a warning if one choosen indicator is not in the dataset\nif len(choosen_indicators) > len(data[\"Indicator Code\"].unique()):\n    print(\"ATTENTION : certains indicateurs n'ont pas \u00e9t\u00e9 trouv\u00e9 dans le tableau de donn\u00e9es\")\n    \n# Also removing columns that are not useful for the moment (we keep the keys columns)\ndata = data.drop([\"Country Name\", \"Indicator Name\"], axis=1, errors=\"ignore\")\n\ndata","19c4d92e":"data.dropna(axis=1, how=\"all\", inplace=True)","8407229d":"# Step 0 - Retrieving the population data from the main dataset\ncountries_populations = data[data[\"Indicator Code\"] == \"SP.POP.TOTL\"]\n\n# Step 1 - Removing columns where all values are NaN\ncountries_populations.reset_index(inplace=True)\ncountries_populations.set_index(\"Country Code\", inplace=True)\n\n# Step 2 - Calculating the mean population for each country\ncountries_populations = countries_populations.mean(axis=1).to_frame()\ncountries_populations.columns = [\"Population\"]\n\n# Step 3 - Keeping countries codes\nbiggest_countries_codes = countries_populations[countries_populations[\"Population\"] >= MINIMUM_POPULATION].index.values\n\n# Finally filtering data\ndata = data[data[\"Country Code\"].isin(biggest_countries_codes)]","43c78761":"# For the next filterings, want to know the global \"filling percentage\" of all selected indicators merged\nyear_filling = data.drop(columns=[\"Country Code\", \"Indicator Code\"]).notnull().sum(axis=0).to_frame()\n\n# We calculate it as a percentile (max possible values per year = nb of countries * nb of indicators)\nmax_values = len(choosen_indicators) * len(data[\"Country Code\"].unique())\nyear_filling = 100 * year_filling \/ max_values\n\nfig1 = plt.figure(figsize=(15,5))\nplt.title(\"Taux de remplissage par ann\u00e9e (tous pays confondus, sur les indicateurs s\u00e9lectionn\u00e9s)\")\nplt.xticks(rotation = 90)\nplt.ylim(ymin=0, ymax=100)\nplt.ylabel(\"Taux de remplissage (%)\")\nplt.plot(year_filling.index.values, year_filling[0], color=\"dodgerblue\", linewidth=3)","77e7cfe5":"# The MIN_YEAR variable has been defined at the beginning of the notebook\n\n# We save the data before filtering it because we need it below\ndata_before_year_filtering = data.copy(deep=True)\n\n# Isolating the columns we want to drop from the DF\nyears = list(filter(lambda x: re.match(\"^\\d{4}$\", x), data.columns.values))\ndropped_years = [year for year in years if int(year) < MIN_YEAR or int(year) > MAX_YEAR]\n\n# Finally removing the unwanted values\ndata = data.drop(columns=dropped_years)\n\ndata","02cfd2bc":"# We count how many values (non NaN) we have for each indicator and we devide it by the number of countries\nindicator_filling = (data\n                     .drop(columns=[\"Country Code\"])\n                     .set_index(\"Indicator Code\")\n                     .notnull()\n                     .groupby(\"Indicator Code\")\n                     .sum())\nindicator_filling = 100 * indicator_filling \/ len(data[\"Country Code\"].unique())\n\n# Plotting the result\nfig2 = plt.figure(figsize=(15,5))\nplt.title(\"Taux de remplissage global de chacun des indicateurs s\u00e9lectionn\u00e9s\")\nplt.xticks(rotation = 90)\nplt.ylabel(\"Taux de remplissage (%)\")\nplt.bar(indicator_filling.index.values, indicator_filling.mean(axis=1))","c98cd5b9":"# We calculate the filling percentage of the given indicator for each year > 0\npcmp_filling = data_before_year_filtering[data_before_year_filtering[\"Indicator Code\"] == \"IT.CMP.PCMP.P2\"]\npcmp_filling = (pcmp_filling\n                .drop(columns=[\"Country Code\"])\n                .set_index(\"Indicator Code\")\n                .notnull()\n                .groupby(\"Indicator Code\")\n                .sum())\npcmp_filling = pcmp_filling \/ len(data_before_year_filtering[\"Country Code\"].unique())\npcmp_filling = pcmp_filling.loc[:, (pcmp_filling != 0).any(axis=0)]\n\n# We plot the results\nfig3 = plt.figure(figsize=(15,5))\nplt.title(\"Taux de remplissage de l'indicateur IT.CMP.PCMP.P2 par ann\u00e9e\")\nplt.xticks(rotation = 90)\nplt.ylim(ymin=0, ymax=100)\nplt.plot(pcmp_filling.columns.values, 100 * pcmp_filling.loc[\"IT.CMP.PCMP.P2\"], color=\"orange\", linewidth=3)","33f9a4c8":"# Step 1 - We isolate country code and region from country file and kipping only on our selected countries\nregions = (countries[countries[\"Country Code\"].isin(biggest_countries_codes)]\n           .set_index(\"Country Code\")\n           .filter(items=[\"Region\"]))\n\n# Step 2 - We also calculate how many countries we have per region in order to calculate our percentile \ncountry_per_region = (regions\n                      .reset_index()\n                      .set_index(\"Region\")\n                      .notnull()\n                      .groupby(\"Region\")\n                      .sum())\ncountry_per_region.columns = [\"Total countries\"]\n\n# Step 3 - We count how many indicators are filled for each Region\ngeographical_data = data.copy(deep=True)\ngeographical_data = (geographical_data\n                     .merge(regions, how=\"left\", on=\"Country Code\")\n                     .drop(columns=[\"Country Code\", \"Indicator Code\"])\n                     .dropna(axis=0, how=\"any\", subset=[\"Region\"])\n                     .set_index(\"Region\")\n                     .notnull()\n                     .groupby(\"Region\")\n                     .sum())\nnb_of_years = len(geographical_data.columns)\nprint(geographical_data)\ngeographical_data = geographical_data.sum(axis=1).to_frame().astype(\"float\")\n\n\n# Step 4 - We divide the number of filled indicators by the number of theoretical indicators per region\nfor region, total in geographical_data.itertuples():\n    region_max = country_per_region.loc[region][\"Total countries\"] * nb_of_years * len(choosen_indicators)\n    geographical_data.loc[region][0] = geographical_data.loc[region][0] \/ region_max\n\n# Step 5 - We sort the results to improve chart readability\ngeographical_data.sort_values(by=[0], axis=0, ascending=False, inplace=True)\n\n# We plot the results\nfig4 = plt.figure(figsize=(15,5))\nplt.title(\"Taux de remplissage global par zone g\u00e9ographique\")\nplt.xticks(rotation = 90)\nplt.bar(geographical_data.index.values, 100 * geographical_data[0], color=\"chocolate\")","a562e761":"# We create a table with the mean value of each indicator for each country\nfinal_indicators_values = (\n                           (data[data[\"Indicator Code\"].isin(choosen_indicators)]\n                            .groupby([\"Country Code\", \"Indicator Code\"])\n                            .mean()\n                           )\n                           .mean(axis=1)\n                           .to_frame()\n                           .unstack(level=1)\n                           .droplevel(0, axis=1)\n                           .drop(columns=[\"IT.CMP.PCMP.P2\"]))\n\n# Now we have to fill the IT.CMP.PCMP.P2 indicator with the 2011-2005 years\npcmp_data = initial_data.copy(deep=True)\nkept_years = [\"2001\", \"2002\", \"2003\", \"2004\", \"2005\"]\npcmp_data = (pcmp_data[(pcmp_data[\"Indicator Code\"] == \"IT.CMP.PCMP.P2\") \n                       & (pcmp_data[\"Country Code\"].isin(biggest_countries_codes))]\n             .drop(columns=[\"Country Name\", \"Indicator Name\", \"Indicator Code\"])\n             .set_index(\"Country Code\")\n             .filter(items=kept_years)\n             .mean(axis=1)\n             .to_frame())\npcmp_data.columns = [\"IT.CMP.PCMP.P2\"]\n\n# And we merge it with the previous dataframe\nfinal_indicators_values = final_indicators_values.merge(pcmp_data, how=\"left\", left_index=True, right_index=True)\n\nfinal_indicators_values","d0ce9b7c":"# At first we calculate the mean GDP PPP of our reference country (France)\nfra_gdp_ppp = (data[(data[\"Country Code\"] == \"FRA\") & (data[\"Indicator Code\"] == \"NY.GDP.PCAP.PP.CD\")]\n               .drop(columns=[\"Country Code\", \"Indicator Code\"])\n               .mean(axis=1)\n               .values[0])\n\n# Now we calculate the min GDP PPP we want \nmin_gdp_ppp = fra_gdp_ppp * (1 - (MAX_REVENUE_PERCENT_DIFF \/ 100))\n\nfinal_indicators_values = final_indicators_values[final_indicators_values[\"NY.GDP.PCAP.PP.CD\"] >= min_gdp_ppp]\n\nprint(\"Apr\u00e8s filtrage par PIB, il reste \" + str(len(final_indicators_values)) + \" pays.\")\nfinal_indicators_values","5707c54c":"pop_1524 = (final_indicators_values.merge(countries[[\"Country Code\", \"Short Name\"]].set_index(\"Country Code\"), \n                              left_index=True, \n                              right_index=True))[[\"SP.POP.1524.TO.UN\", \"Short Name\"]]\n\npop_1524[pop_1524[\"SP.POP.1524.TO.UN\"].isnull()]","49e2dde5":"indicators_names = {\n    'IT.NET.USER.P2': 'Utilisateurs Internet (%)', \n    'NY.GDP.PCAP.PP.CD': 'PIB par hab (PPA)', \n    'SP.POP.1524.TO.UN': 'Population 15-24 ans',\n    'SP.POP.GROW': 'Croissance pop. (%)',\n    'IT.CMP.PCMP.P2': 'Possesseurs PC (%)',\n    'Short Name': 'Country Name'\n}\n\nfinal_indicators_values = (final_indicators_values\n                           .dropna(subset=[\"SP.POP.1524.TO.UN\"])\n                           .drop(columns=[\"SP.POP.TOTL\", \"SP.SEC.TOTL.IN\", \"SP.SEC.UTOT.IN\", \"SP.TER.TOTL.IN\"], errors=\"ignore\")\n                           .merge(countries[[\"Country Code\", \"Short Name\"]].set_index(\"Country Code\"), \n                              left_index=True, \n                              right_index=True)\n                           .rename(columns=indicators_names))\n\nfinal_indicators = indicators_names.keys()\nfinal_indicators_values","8d1f9004":"indicator_analysis_base_data = initial_data.copy(deep=True)\n\nindicator_analysis_base_data = (indicator_analysis_base_data[indicator_analysis_base_data[\"Indicator Code\"].isin(final_indicators)]\n                           .drop(columns=[\"Country Name\", \"Indicator Name\"])\n                           .reset_index())\n\n# We add the geographic region\nregions = (countries[countries[\"Country Code\"].isin(biggest_countries_codes)]\n           .set_index(\"Country Code\")\n           .filter(items=[\"Region\"]))\nindicator_analysis_base_data = indicator_analysis_base_data.merge(regions, left_on=\"Country Code\", right_index=True)","72b705de":"# We use the initial data for that \nindicator_analysis = indicator_analysis_base_data.copy(deep=True)\n\nindicator_analysis = (indicator_analysis\n                           .drop(columns=[\"index\", \"Country Code\"], errors=\"ignore\")\n                           .groupby([\"Indicator Code\", \"Region\"]).mean())\n\n# Calculating the main statistic indicators\nindicator_analysis_mean = indicator_analysis.mean(axis=1).to_frame()\nindicator_analysis_std = indicator_analysis.std(axis=1).to_frame()\nindicator_analysis_med = indicator_analysis.median(axis=1).to_frame()\n\nindicator_analysis_mean = indicator_analysis_mean.merge(indicator_analysis_std, left_index=True, right_index=True)\nindicator_analysis_mean = indicator_analysis_mean.merge(indicator_analysis_med, left_index=True, right_index=True)\n\nindicator_analysis_mean.columns = [\"Mean\", \"Std\", \"Median\"]\n\nindicator_analysis_mean","eb2e2bb1":"indicator_analysis_data = indicator_analysis_base_data.copy(deep=True)\n\n# Calculating means\nindicator_analysis_data = (indicator_analysis_data\n                           .drop(columns=[\"Country Code\"], errors=\"ignore\")\n                           .groupby([\"Region\", \"Indicator Code\"])\n                           .mean()).reset_index().drop(columns=[\"index\"])\n\ncolors = [\"#d43737\", \"#d48b37\", \"#cfd437\", \"#42d435\", \"#35d4c9\", \"#3848d6\", \"#c22ed9\"]\nlegend = {}\n\n# Preparing the plot\nx_ticks = []\nx_ticks_labels = []\nfor column_name in indicator_analysis_data.columns:\n    if re.match('r\/^\\d{4}$\/', column_name):\n        x_ticks.append(int(year))\n        if year.endswith('0'):\n            x_ticks_labels.append(str(year))\n        else:\n            x_ticks_labels.append(\"\")\n        \nindicators = indicator_analysis_data[\"Indicator Code\"].unique()\nfig10, axes = plt.subplots(nrows=math.ceil(len(indicators)\/2), ncols=2, figsize=(15,5*len(indicators)\/2))\ni = 0\nfor indicator in indicators:\n    subdata = indicator_analysis_data[indicator_analysis_data[\"Indicator Code\"] == indicator]\\\n                .dropna(how=\"any\", axis=1)\\\n                .drop(columns=[\"Indicator Code\"])\\\n                .set_index(\"Region\")\n    row_number = 0\n    for row in subdata.iterrows():\n        axes[math.floor(i\/2), i%2].title.set_text(indicators_names[indicator])\n        axes[math.floor(i\/2), i%2].set_xticks(x_ticks)\n        axes[math.floor(i\/2), i%2].set_xticklabels(x_ticks_labels)\n        axes[math.floor(i\/2), i%2].plot(subdata.columns, subdata.iloc[row_number].values, color=colors[row_number])    \n        \n        # Storing the association serie\/color for the legend\n        legend[subdata.index[row_number]] = colors[row_number]\n        row_number += 1\n    i+=1\n\n    \n    \nfig10.legend(legend.keys(), labelcolor=legend.values(), loc=\"upper center\")\n","afbcea97":"def calculate_scores(coefficients, plot=False, score_name=None, return_index=False):\n    \"\"\" Plot a bar chart with the scores calculated using the given coefficients\n    \n    Parameters:\n    coefficient (dict): dictionnary of column_name: coefficient\n    \n    Returns:\n    DataFrame: the scores sorted by DESC order or the list of sorted index\n    \n    \"\"\"\n    \n    # We work on a copy of the data \n    scoring_data = final_indicators_values.copy(deep=True)\n    score_column_name = \"Score\"\n\n    # Dividing all columns by its max value to have [0;1] values\n    scoring_data.iloc[:,:-1] = scoring_data.iloc[:,:-1].apply(lambda x: x \/ x.max())\n    \n    # For each row of the dataframe, we calculate the score\n    for country_code, row in scoring_data.iterrows():\n        score = 0\n        for column, coef in coefficients.items():\n            score += row[column] * coef\n        scoring_data.at[country_code, score_column_name] = score\n\n   \n    # Dividing by the reference country score to easily get the highest potential countries\n    ref_score = scoring_data.loc[REF_COUNTRY_CODE][score_column_name]\n    scoring_data[score_column_name] = scoring_data[score_column_name] \/ ref_score\n\n     # Sorting the results by score desc    \n    scoring_data = scoring_data.sort_values(score_column_name, ascending=False)\n    subset = scoring_data[score_column_name].to_frame()\n    \n    # Renaming the score column if asked\n    if score_name != None:\n        subset = subset.rename(columns={score_column_name: score_name})\n        score_column_name = score_name\n\n    # Returning the result and plotting the result if asked\n    if plot:\n        plt.xticks(rotation = 90)\n        plt.bar(scoring_data[\"Country Name\"], subset[score_column_name], color=\"goldenrod\", edgecolor=\"#333333\")\n\n    if return_index:\n        subset = subset.astype(\"string\")\n        for country_code, row in subset.iterrows():\n            subset.at[country_code, score_column_name] = country_code\n        subset = subset.reset_index().drop(columns=[\"Country Code\"])\n        \n    return subset","6015c921":"fig8 = plt.figure(figsize=(15,7))\nplt.title(\"Classement de r\u00e9f\u00e9rence\")\nplt.ylabel(\"Score du pays\")\n\nscores = calculate_scores({\n    'Utilisateurs Internet (%)': 1,\n    'PIB par hab (PPA)': 1,\n    'Population 15-24 ans': 1,\n    'Croissance pop. (%)': 1,\n    'Possesseurs PC (%)': 1\n}, plot=True)","deabd8d6":"# Step 1 : we generate all possible indicator\/weight possibilities\nindicators = [\n    'Utilisateurs Internet (%)',\n    'PIB par hab (PPA)',\n    'Population 15-24 ans',\n    'Croissance pop. (%)',\n    'Possesseurs PC (%)'\n]\nweights = [3,2]\n\nall_coefficients = []\nfor combination in itertools.permutations(indicators, len(weights)):\n    new_coefficients = {}\n    for index, indicator in enumerate(indicators):\n        if indicator in combination:\n            new_coefficients[indicator] = weights[combination.index(indicator)]\n        else: \n            new_coefficients[indicator] = 1\n    all_coefficients.append(new_coefficients)\n    \nprint(\"Les \" + str(len(all_coefficients)) + \" cas possibles ont \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9s\")\n\nj=0\nfor coefficients in all_coefficients:\n    print(\"\\n\")\n    print(\"Classement #\" + str(j) + \" : \")\n    for indic, coef in coefficients.items():\n        if coef > 1:\n            print(str(indic) + \" : \" + str(coef))\n    \n    j += 1","a4f1b790":"# Step 2 : we generate all rakings\nreference_coefficients = {\n    'Utilisateurs Internet (%)': 1,\n    'PIB par hab (PPA)': 1,\n    'Population 15-24 ans': 1,\n    'Croissance pop. (%)': 1,\n    'Possesseurs PC (%)': 1\n}\n\n# We initialize a dataframe with all the coefficients to weight 1 \nrankings = calculate_scores(reference_coefficients, score_name=\"Reference score\", return_index=True)\ntop_10 = rankings[\"Reference score\"].head(15).tolist()\n\nfor index, coefficient_case in enumerate(all_coefficients):\n    weighted_scores = calculate_scores(coefficient_case, \n                                       score_name=\"CASE_\" + str(index), \n                                       return_index=True)\n    rankings = rankings.merge(weighted_scores, left_index=True, right_index=True)\n\n\n# Coloring the dataframe to highlight the top 10 of the reference ranking and see the differences\nrankings_colors = rankings.copy(deep=True)\nrankings_colors = rankings_colors.isin(top_10)\n\ndef color_cells(value):\n    if value == True:\n        return 'text-align:center; width: 120px; background-color:#ffefe0; font-weight:bold; border:1px solid #fac28e;'\n    else:\n        return 'text-align:center; width: 120px; '\n\nprint(\"Les couleurs nous permettent de visualiser que le Top 10 de r\u00e9f\u00e9rence ne changent pas beaucoup\")\nrankings.style.apply(lambda x: rankings_colors.applymap(color_cells), axis=None)","8093be69":"scores = {}\nMAX_SCORE = 15\n\nfor index, row in enumerate(rankings.values.tolist()):\n    for country in row:\n        if not country in scores:\n            scores[country] = 0\n        score = MAX_SCORE - index\n        scores[country] += max([score, 0])\n\n# Sorting by score DESC\nscores = dict(sorted(scores.items(), key=lambda item: item[1], reverse=True))\n\nscores","29757d9d":"# Renaming the country code by the country name and keeping only scores > 0\nnamed_scores = {}\nfor country_code, score in scores.items():\n    if score > 0:\n        country_name = countries[countries[\"Country Code\"] == country_code][\"Short Name\"].values[0]\n        named_scores[country_name] = score\n\nfig9 = plt.figure(figsize=(15,7))\nplt.xticks(rotation = 90)\nplt.title(\"Classement final des pays\")\nplt.ylabel(\"Score du pays\")\nplt.bar(named_scores.keys(), named_scores.values(), color=\"gold\", edgecolor=\"black\")","885dbd27":"<a name=\"small-countries\"><\/a>\n### Suppression des pays trop petits\nAfin de faciliter le travail d'analyse \u00e0 venir et r\u00e9duire significativement le nombre de ligne, nous allons commencer par \u00e9liminer les pays \u00e0 la population trop faible.\n\n**Rappel** : la population minimale retenue ici est indiqu\u00e9e en d\u00e9but de Notebook au niveau des param\u00e8tres.","749b8825":"**CONCLUSION** : pour les indicateurs s\u00e9lectionn\u00e9s, on ne note pas de disparit\u00e9 particuli\u00e8re en terme de remplissage. **Toutes les zones g\u00e9ographiques peuvent donc \u00eatre analys\u00e9es.**","2f971c30":"### Langue principale\nApr\u00e8s \u00e9tude d\u00e9taill\u00e9e des indicateurs, aucun ne semble actuellement nous renseigner sur la langue principale parl\u00e9e dans le pays. C'est \u00e9ventuellement une donn\u00e9e que nous pourrons int\u00e9grer \u00e0 posteriori pour d\u00e9partager 2 pays tr\u00e8s proches en termes de score.\n\n### R\u00e9capitulatif des indicateurs","15778577":"<a name=\"fillings\"><\/a>\n### Taux de remplissage global de chaque indicateur\nOn v\u00e9rifie maintenant les taux de remplissage de nos indicateurs sur les ann\u00e9es s\u00e9lectionn\u00e9es.","c45f936d":"<a name=\"description\"><\/a>\n### Description des donn\u00e9es\nPour chacun des DataFrame ci-dessus j'utilise la m\u00e9thode `.info()` qui nous permet de lister le nombre de lignes, le nombre de colonne, et pour chaque colonne, le nombre de valeur nulles.","18e592a3":"<a name=\"final-data\"><\/a>\n### Remise au propre des donn\u00e9es finales\nOn peut maintenant conserver uniquement nos 5 indicateurs finaux et remettre ainsi nos donn\u00e9es au propre en ajoutant au passage le nom de chaque pays afin de mieux s'y retrouver.","2fdc5b58":"<a name=\"reference-ranking\"><\/a>\n### Classement des pays avec des coefficients \u00e9gaux (r\u00e9f\u00e9rence)","90e0ce67":"### Revenu moyen du pays\nM\u00eame si cet indicateur sera probablement fortement li\u00e9 \u00e0 l'acc\u00e8s \u00e0 un ordinateur personnel, il nous permettra de savoir si la population a, ou non, sensiblement le m\u00eame pouvoir d'achat que notre pays de r\u00e9f\u00e9rence.\n\nLe dataset nous donne acc\u00e8s au **PNB par habitant** ainsi qu'au **PIB par habitant**. Ce dernier est le plus repr\u00e9sentatif du niveau de vie moyen du pays, surtout qu'il est ici exprim\u00e9 en \"Parit\u00e9 de Pouvoir d'Achat\" (**PPA** ou en anglais PPP) ce qui signifie qu'on tient compte du co\u00fbt de la vie dans le pays. Cela permet d'avoir une comparaison plus fiable entre les pays.\n* **NY.GDP.MKTP.PP.CD** :  PIB (PPP - Current US Dollar)\n* **NY.GDP.PCAP.PP.CD** : PIB par habitant (PPP - Current US Dollar)\n\nPour nous, cet indicateur sera **obligatoire** : on supprimera du dataset tous les pays pour lesquels il n'est pas renseign\u00e9.","94c9db3b":"<a name=\"B\"><\/a>\n## B - Import et compr\u00e9hension des donn\u00e9es\n### Import des donn\u00e9es","a035796d":"<a name=\"prefilter\"><\/a>\n## D - Pr\u00e9-filtrage des donn\u00e9es\nLe pr\u00e9-filtrage effectu\u00e9 ici est une succession d'op\u00e9ration de filtrages facile \u00e0 appliquer. Le but est de venir amputer le Dataset d'un grand nombre de lignes afin de faciliter les op\u00e9rations de filtrages plus minutieuses \u00e0 venir ensuite.\n<a name=\"removing\"><\/a>\n### Suppression des indicateurs non retenus\nOn ne conserve maintenant que les lignes des indicateurs qui nous int\u00e9ressent et on supprime \u00e9galement les colonnes non utiles tel que les noms de pays et les noms des indicateurs.","b48f9b91":"<a name=\"years\"><\/a>\n### Suppression des ann\u00e9es trop anciennes et mal renseign\u00e9es\nOn va maintenant analyser le taux de remplissage des donn\u00e9es de nos indicateurs retenus, par ann\u00e9e, ce qui nous permettra d'en supprimer une partie.","20bca091":"<a name=\"conclusion\"><\/a>\n## I - Conclusion\nIl ne nous reste plus qu'\u00e0 tracer les scores sur un graphiques : ","340fdc78":"<a name=\"filtering\"><\/a>\n## F - Second filtrage des donn\u00e9es\n<a name=\"poor-countries\"><\/a>\n### Suppression des pays trop pauvres\nNous allons \u00e0 pr\u00e9sent enlever du dataset les pays dont le PIB est trop inf\u00e9rieur \u00e0 celui **de la France** qui est notre pays de r\u00e9f\u00e9rence.\n\nNous pouvons nous appuyer sur le **PNB par habitant PPA** car nous avons v\u00e9rif\u00e9 (lors de l'\u00e9tape suivante) que c'\u00e9tait un indicateur fiable dans notre set d'ann\u00e9es et de pays.","4c6d9885":"### Evolution des indicateurs choisis","03a9e8a7":"<a name=\"geoanalysis\"><\/a>\n## G - Etude des indicateurs par r\u00e9gion g\u00e9ographique\nMaintenant que nous avons s\u00e9lectionn\u00e9 nos 5 indicateurs principaux, nous allons \u00e9tudier leurs indicateurs statistiques pour les diff\u00e9rentes zones g\u00e9ographiques.\n","91752261":"### Population \u00e9tudiante\nPlusieurs indicateurs peuvent nous aider \u00e0 cibler la population qui nous int\u00e9resse, sachant que l'on cherche \u00e0 chiffrer l'effectif de la population lyc\u00e9e\/universit\u00e9, soit environ la tranche d'\u00e2ge 15-25 ans.\n* **SP.POP.TOTL** : population totale \u00e0 la mi-ann\u00e9e d\u00e9compos\u00e9e en **SP.POP.TOTL.FE.IN** (femmes) et **SP.POP.TOTL.MA.IN** (hommes)\n* **SP.POP.GROW** : taux de croissance de la population -> utile pour les projections futures\n* **SP.POP.1524.TO.UN** : population totale de la tranche 15-24 ans\n* **SP.SEC.TOTL.IN** : population totale ayant l'\u00e2ge d'entrer en \u00e9ducation secondaire (secondary ed.)\n* **SP.SEC.UTOT.IN** : population totale ayant l'\u00e2ge d'entrer en \u00e9ducation secondaire \u00e9lev\u00e9e (upper secondary ed.)\n* **SP.TER.TOTL.IN** : population totale ayant l'\u00e2ge d'entrer en \u00e9ducation tertiaire (tertiary ed.)\n\nOn va **tous les conserver dans un premier temps** et on analysera ensuite lequel (ou lesquels) sont les plus pertinents et les plus fiables pour notre utilisation (voir [plus bas dans le fichier](#population)).","d11c43e7":"On constate que, \u00e0 part Puerto Rico, les autres lignes ne sont pas des pays mais des regroupement de pays. \nDans la suite de cette analyse, on fait donc les choix suivants : \n* Ignorer Puerto Rico\n* Ne conserver comme indicateur de population que cet indicateur **SP.POP.1524.TO.UN**","53de25ae":"<a name=\"grouping\"><\/a>\n## E - Regroupement des indicateurs\nLe but de cette partie est de cr\u00e9er un tableau qui contient une ligne par pays, et une colonne par indicateur avec la valeur finale conserv\u00e9e pour celui-ci. On va traiter s\u00e9par\u00e9ment notre indicateur **IT.CMP.PCMP.P2** qui n'a pas de valeur pour les ann\u00e9es s\u00e9lectionn\u00e9es.","a41a379f":"<a name=\"dropna\"><\/a>\n### Suppression des colonnes enti\u00e8rement vides","e8551c02":"### Param\u00e8tres globaux\nCette section regroupe les param\u00e8tres qui influent directement sur la fa\u00e7on dont sont pr\u00e9-filtr\u00e9es et filtr\u00e9es les donn\u00e9es.","bfafb4cf":"**CONCLUSION** : pour cet indicateur-l\u00e0, nous allons prendre une moyenne sur les ann\u00e9es **2001-2005**.","83a25b1c":"On constate que tous les indicateurs sont **tr\u00e8s bien renseign\u00e9s** \u00e0 l'exception de \"**IT.CMP.PCMP.P2**\".\n\nCet indicateur est \u00e0 0% de remplissage sur les ann\u00e9es s\u00e9lectionn\u00e9es, ce qui est g\u00eanant car c'est un indicateur primordial pour la suite de notre \u00e9tude. \n\nNous allons voir \u00e0 quel point il est rempli dans les autres ann\u00e9es.","e60996b5":"On constate plusieurs choses : \n* Les ann\u00e9es **apr\u00e8s 2016** avaient d\u00e9j\u00e0 \u00e9t\u00e9 supprim\u00e9es, ce qui signifie qu'elles \u00e9taient vides pour nos indicateurs. ON va toutefois exclure en plus l'ann\u00e9e 2016 qui est significativement moins renseign\u00e9e que 2015.\n* Les ann\u00e9es **avant 1990** sont moins remplies, et nous int\u00e9ressent peu car internet n'est apparu qu'en 1991.\n\nDe plus, au vu de l'\u00e9volution rapide des nouvelles technologies, **il parait peut pertinent de conserver les ann\u00e9es ant\u00e9rieures \u00e0 2005** (apparition de Youtube, Facebook, essor des r\u00e9seaux sociaux et des plateformes de streaming) car elles sont peu repr\u00e9sentatives des nouvelles technologies, et risqueraient ainsi de faire chuter nos indicateurs \"technologiques\" (acc\u00e8s internet et acc\u00e8s \u00e0 des ordinateurs).\n\n**CONCLUSION** : on ne conserve que **les ann\u00e9es apr\u00e8s 2005 (inclue) et avant 2016 (exclue)**.\n\nCes 2 ann\u00e9es sont mises en param\u00e8tre en d\u00e9but de Notebook.","39bd7de4":"<a name=\"scoring\"><\/a>\n## H - Scoring des pays\nLa strat\u00e9gie de scoring est la suivante : \n* On divise chaque valeur **par le maximum de sa colonne** de fa\u00e7on \u00e0 avoir des valeurs entre 0 et 1.\n* On va ensuite calculer la **somme pond\u00e9r\u00e9e** des colonnes pour avoir le score du pays.\n\nConcernant les pond\u00e9rations : \n* Dans un premier temps on applique une **pond\u00e9ration similaire** \u00e0 tous les indicateurs,\n* Ensuite on fera **varier les pond\u00e9ration** afin de voir si le classement change de mani\u00e8re significative.\n\n","0b300c8e":"### Acc\u00e8s \u00e0 internet\nEn terme de communication, deux indicateurs nous indiquent le pourcentage d'ordinateurs personnels et de connexion internet pour 100 habitants :\n\n* **IT.NET.USER.P2** : pourcentage d'utilisateurs d'internet\n* **IT.CMP.PCMP.P2** : pourcentage de possesseur d'un ordinateur personnel\n\nJ'ai \u00e9galement recherch\u00e9 des indicateurs concernant les **comp\u00e9tences informatique** mais si plusieurs sont indiqu\u00e9s dans la documentation de la banque mondiale, aucun n'est pr\u00e9sent dans le dataset.","12b221ff":"### Indicateurs principaux : moyenne, m\u00e9diane, \u00e9cart-type","36d05b47":"<a name=\"indicators\"><\/a>\n## C - Choix des indicateurs\nL'id\u00e9e est maintenant de trouver les indicateurs qui nous int\u00e9ressent parmi les 3665 propos\u00e9s. Pour r\u00e9pondre \u00e0 notre probl\u00e9matique, on va tout d'abord se focaliser sur les id\u00e9es suivantes : \n* D\u00e9finir la **quantit\u00e9 d'\u00e9tudiants** par pays en se basant, par exemple, sur la population par tranche d'\u00e2ge.\n* D\u00e9finir l'**acc\u00e8s \u00e0 internet**  : acc\u00e8s des \u00e9tudiants \u00e0 un ordinateur et une connexion internet correcte.\n* D\u00e9finir le **revenu moyen** du pays afin de savoir si les \u00e9tudiants auront de quoi payer les cours en ligne.\n* D\u00e9finir la **langue principale du pays** : le fran\u00e7ais et l'anglais \u00e9tant plus facile \u00e0 traduire.\n\nJ'utilise la [liste des indicateurs](http:\/\/datatopics.worldbank.org\/education\/) afin de les trouver plus facilement.\n","f4513f6a":"Maintenant on part de ce tableau et on calcule le score de chaque pays : ","26aba37b":"# Projet 2 - Analysez des donn\u00e9es de syst\u00e8mes \u00e9ducatifs\n\n## Table des mati\u00e8res\n* [A - Analyse et reformulation de l'\u00e9nonc\u00e9](#A)\n* [B - Import et compr\u00e9hension des donn\u00e9es](#B)\n    * [Description des donn\u00e9es](#description)\n* [C - Choix des indicateurs](#indicators)\n* [D - Pr\u00e9-filtrage des donn\u00e9es](#prefilter)\n    * [Suppression des autres indicateurs](#removing)\n    * [Suppression des colonnes enti\u00e8rement vides](#dropna)\n    * [Suppression des pays trop petits](#small-countries)\n    * [Suppression des ann\u00e9es mal renseign\u00e9es](#years)\n    * [Taux de remplissage global de chaque indicateur](#fillings)\n    * [Taux de remplissage par r\u00e9gion g\u00e9ographique](#geofillings)\n* [E - Regroupement des indicateurs](#grouping)\n* [F - Second filtrage des donn\u00e9es](#filtering)\n    * [Suppression des pays trop pauvres](#poor-countries)\n    * [S\u00e9lection du bon indicateur de population](#population)\n    * [Remise au propre des donn\u00e9es finales](#final-data)\n* [G - Etude des indicateurs par r\u00e9gion g\u00e9ographique](#geoanalysis)\n* [H - Scoring des pays](#scoring)\n    * [Classement des pays avec des coefficients \u00e9gaux (r\u00e9f\u00e9rence)](#reference-ranking)\n    * [Impact de la modification des pond\u00e9rations - M\u00e9thode Borda](#borda)\n* [I - Conclusion](#conclusion)\n\n<a name=\"A\"><\/a>\n## A - Analyse et reformulation de l'\u00e9nonc\u00e9\n<ins>**Donn\u00e9es issues de l'\u00e9nonc\u00e9**<\/ins> : \n* Domaine de la **EdTech** pour Educational Technology (technologies de l'\u00e9ducation).\n* Academy est une **start-up** qui fournit des formation **en ligne** pour des niveaux **lyc\u00e9e et universit\u00e9**.\n* Projet d'expansion \u00e0 l'**international**.\n* Les donn\u00e9es sont fournies par la banque mondiale rubrique \"[EdStats](https:\/\/datatopics.worldbank.org\/education\/)\"\n\n<ins>**Probl\u00e9matique**<\/ins> : analyser les [donn\u00e9es](https:\/\/datacatalog.worldbank.org\/dataset\/education-statistics) de la banque mondiale afin de d\u00e9terminer quels sont les pays avec les plus forts pontentiels **actuel et futur** d'expansion de Academy et d\u00e9terminer **dans quels pays op\u00e9rer en priorit\u00e9**.","fc72de08":"<a name=\"geofillings\"><\/a>\n### Taux de remplissage par r\u00e9gion g\u00e9ographique\nOn veut maintenant regarder si les indicateurs sont mieux remplis dans certaines portions du monde, ce qui nous permettrait d'\u00e9liminer certains continent si les indicateurs y sont tr\u00e8s mal renseign\u00e9s.\n\nPour cela, on utilise la colonne \"Region\" du fichier des pays ; et on calcul un pourcentage au prorata du nombre de pays dans chaque continent (pour \u00e9viter d'avoir, par exemple, l'Am\u00e9rique du Noed avec un score faible, du fait qu'elle ne contient que 2 pays).","91e06958":"<a name=\"population\"><\/a>\n### S\u00e9lection du bon indicateur de population\nIl nous reste \u00e0 pr\u00e9sent \u00e0 choisir l'indicateur de population le plus efficace. Le plus pratique serait le nombre d'habitants de la tranche 15-24 ans mais on avait vu plus haut qu'il n'est pas tr\u00e8s bien renseign\u00e9. Regardons \u00e0 pr\u00e9sent \u00e0 quel point il est fiable sur les derniers pays restants.\n\nPour cela on va afficher la liste des pays pour lesquels il n'est pas renseign\u00e9 et regarder si ces pays sont importants pour nous ou non.","ee9c49ee":"<a name=\"borda\"><\/a>\n### Impact de la modification des pond\u00e9rations - M\u00e9thode Borda\nOn va maintenant regarder si notre classement est sensible ou non \u00e0 une modification des pond\u00e9rations.\nPour cela on va utiliser la m\u00e9thode **Borda** : \n* On va appliquer un coefficient de 3 \u00e0 un indicateur, 2 \u00e0 un autre, et 1 \u00e0 tous les indicateurs restants\n* Pour 5 indicateurs, on va ainsi obtenir 20 classements diff\u00e9rents de nos pays\n* On applique alors la m\u00e9thode Borda en consid\u00e9rant qu'on veut le classement des 10 meilleurs pays\n\nAinsi, pour chaque classement, le premier pays recevra 10 points, le second 9 points, etc... A partir du 11e, ils re\u00e7oivent tous 0 points.\n\nEn sommant, pour chaque pays, ses points obtenus \u00e0 chaque classement, on obtiendra un classement global."}}