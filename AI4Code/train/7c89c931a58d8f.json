{"cell_type":{"c916c2a4":"code","91ceef70":"code","0a3b10f4":"code","052714cb":"code","9c94aed3":"code","4cae63fd":"code","ac7ad4bd":"code","262ea138":"code","82715f39":"code","8caefb67":"code","173d5686":"code","2ab46913":"code","2dcf27b3":"code","460b183a":"code","727b42ed":"code","41b30f73":"code","bc33a99c":"code","913c5997":"code","8984213d":"code","5db3b4ea":"code","468b8a0f":"code","b07ec073":"code","9feefe27":"code","8b0e892b":"code","b21515b9":"code","da394469":"code","d8438d81":"code","07d65bbc":"code","817a8724":"code","db861ea2":"code","0b511f26":"code","d5a4e65e":"code","c1861642":"code","982f9ed7":"code","c7913f95":"code","9172a1e0":"code","50c848ee":"code","b28d0bb2":"code","69713d0c":"code","31f8a499":"code","f0e6d8e3":"code","9dec3c63":"code","255afd44":"code","d4ad8a14":"code","9b23cca2":"code","7758475c":"code","92d7c0a4":"markdown","d0854963":"markdown","181d0fe6":"markdown","603d85ba":"markdown","68fa573f":"markdown","ff819010":"markdown","50b063b5":"markdown","007cb99c":"markdown","f5029e91":"markdown","2282cadc":"markdown","193a301d":"markdown","d9c5e317":"markdown","ce24259b":"markdown"},"source":{"c916c2a4":"#import the reqired libraries\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\nimport numpy as np\nimport pandas as pd\nimport math\nimport json\nimport time\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import NearestNeighbors\n#from sklearn.externals import joblib\nimport scipy.sparse\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import svds\nimport warnings; warnings.simplefilter('ignore')\n%matplotlib inline","91ceef70":"columns=['userId', 'productId', 'ratings','timestamp']\nelectronics_df=pd.read_csv(\"..\/input\/csv-data\/Electronics.csv\",names=columns)","0a3b10f4":"electronics_df.head()","052714cb":"electronics_df.drop('timestamp',axis=1,inplace=True)","9c94aed3":"electronics_df.info()\n","4cae63fd":"#Check the number of rows and columns\nrows,columns=electronics_df.shape\nprint('Number of rows: ',rows)\nprint('Number of columns: ',columns)","ac7ad4bd":"#Check the datatypes\nelectronics_df.dtypes","262ea138":"#Taking subset of the dataset\nelectronics_df1=electronics_df.iloc[:50000,0:]","82715f39":"electronics_df1['ratings'].describe().transpose()","8caefb67":"#Find the minimum and maximum ratings\nprint('Minimum rating is: %d' %(electronics_df1.ratings.min()))\nprint('Maximum rating is: %d' %(electronics_df1.ratings.max()))","173d5686":"#Check for missing values\nprint('Number of missing values across columns: \\n',electronics_df.isnull().sum())","2ab46913":"# Check the distribution of the rating\nwith sns.axes_style('white'):\n    g = sns.factorplot(\"ratings\", data=electronics_df1, aspect=2.0,kind='count')\n    g.set_ylabels(\"Total number of ratings\")","2dcf27b3":"# Number of unique user id  in the data\nprint('Number of unique users in Raw data = ', electronics_df1['userId'].nunique())\n# Number of unique product id  in the data\nprint('Number of unique product in Raw data = ', electronics_df1['productId'].nunique())","460b183a":"#Check the top 10 users based on ratings\nmost_rated=electronics_df1.groupby('userId').size().sort_values(ascending=False)[:10]\nprint('Top 10 users based on ratings: \\n',most_rated)","727b42ed":"counts=electronics_df1.userId.value_counts()\nelectronics_df1_final=electronics_df1[electronics_df1.userId.isin(counts[counts>=15].index)]\nprint('Number of users who have rated 25 or more items =', len(electronics_df1_final))\nprint('Number of unique users in the final data = ', electronics_df1_final['userId'].nunique())\nprint('Number of unique products in the final data = ', electronics_df1_final['userId'].nunique())","41b30f73":"#constructing the pivot table\nfinal_ratings_matrix = electronics_df1_final.reset_index().pivot_table(index = 'userId', columns ='productId', values = 'ratings').fillna(0)\nfinal_ratings_matrix.head()","bc33a99c":"print('Shape of final_ratings_matrix: ', final_ratings_matrix.shape)","913c5997":"#Calucating the density of the rating marix\ngiven_num_of_ratings = np.count_nonzero(final_ratings_matrix)\nprint('given_num_of_ratings = ', given_num_of_ratings)\npossible_num_of_ratings = final_ratings_matrix.shape[0] * final_ratings_matrix.shape[1]\nprint('possible_num_of_ratings = ', possible_num_of_ratings)\ndensity = (given_num_of_ratings\/possible_num_of_ratings)\ndensity *= 100\nprint ('density: {:4.2f}%'.format(density))","8984213d":"#Split the data randomnly into train and test datasets into 70:30 ratio\ntrain_data, test_data = train_test_split(electronics_df1_final, test_size = 0.3, random_state=0)\ntrain_data.head()","5db3b4ea":"print('Shape of training data: ',train_data.shape)\nprint('Shape of testing data: ',test_data.shape)","468b8a0f":"#Count of user_id for each unique product as recommendation score \ntrain_data_grouped = train_data.groupby('productId').agg({'userId': 'count'}).reset_index()\ntrain_data_grouped.rename(columns = {'userId': 'score'},inplace=True)\ntrain_data_grouped.head(10)","b07ec073":"#Sort the products on recommendation score \ntrain_data_sort = train_data_grouped.sort_values(['score', 'productId'], ascending = [0,1]) \n      \n#Generate a recommendation rank based upon score \ntrain_data_sort['rank'] = train_data_sort['score'].rank(ascending=0, method='first') \n          \n#Get the top 5 recommendations \npopularity_recommendations = train_data_sort.head(5) \npopularity_recommendations","9feefe27":"# Use popularity based recommender model to make predictions\ndef recommend(user_id):     \n    user_recommendations = popularity_recommendations \n          \n    #Add user_id column for which the recommendations are being generated \n    user_recommendations['userId'] = user_id \n      \n    #Bring user_id column to the front \n    cols = user_recommendations.columns.tolist() \n    cols = cols[-1:] + cols[:-1] \n    user_recommendations = user_recommendations[cols] \n          \n    return user_recommendations","8b0e892b":"find_recom = [10,100,150]   # This list is user choice.\nfor i in find_recom:\n    print(\"The list of recommendations for the userId: %d\\n\" %(i))\n    print(recommend(i))    \n    print(\"\\n\")","b21515b9":"electronics_df_CF = pd.concat([train_data, test_data]).reset_index()\nelectronics_df_CF.head()","da394469":"# Matrix with row per 'user' and column per 'item' \npivot_df = electronics_df_CF.reset_index().pivot_table(index = 'userId', columns ='productId', values = 'ratings').fillna(0)\npivot_df.head()","d8438d81":"print('Shape of the pivot table: ', pivot_df.shape)","07d65bbc":"#define user index from 0 to 10\npivot_df['user_index'] = np.arange(0, pivot_df.shape[0], 1)\npivot_df.head()","817a8724":"pivot_df.set_index(['user_index'], inplace=True)\n# Actual ratings given by users\npivot_df.head()\n","db861ea2":"# Singular Value Decomposition\nU, sigma, Vt = svds(pivot_df, k = 10)","0b511f26":"print('Left singular matrix: \\n',U)","d5a4e65e":"print('Sigma: \\n',sigma)","c1861642":"# Construct diagonal array in SVD\nsigma = np.diag(sigma)\nprint('Diagonal matrix: \\n',sigma)","982f9ed7":"print('Right singular matrix: \\n',Vt)","c7913f95":"#Predicted ratings\nall_user_predicted_ratings = np.dot(np.dot(U, sigma), Vt) \n# Convert predicted ratings to dataframe\npreds_df = pd.DataFrame(all_user_predicted_ratings, columns = pivot_df.columns)\npreds_df.head()","9172a1e0":"# Recommend the items with the highest predicted ratings\n\ndef recommend_items(userID, pivot_df, preds_df, num_recommendations):\n    # index starts at 0  \n    user_idx = userID-1 \n    # Get and sort the user's ratings\n    sorted_user_ratings = pivot_df.iloc[user_idx].sort_values(ascending=False)\n    #sorted_user_ratings\n    sorted_user_predictions = preds_df.iloc[user_idx].sort_values(ascending=False)\n    #sorted_user_predictions\n    temp = pd.concat([sorted_user_ratings, sorted_user_predictions], axis=1)\n    temp.index.name = 'Recommended Items'\n    temp.columns = ['user_ratings', 'user_predictions']\n    temp = temp.loc[temp.user_ratings == 0]   \n    temp = temp.sort_values('user_predictions', ascending=False)\n    print('\\nBelow are the recommended items for user(user_id = {}):\\n'.format(userID))\n    print(temp.head(num_recommendations))","50c848ee":"userID = 4\nnum_recommendations = 5\nrecommend_items(userID, pivot_df, preds_df, num_recommendations)","b28d0bb2":"userID = 6\nnum_recommendations = 5\nrecommend_items(userID, pivot_df, preds_df, num_recommendations)","69713d0c":"userID = 8\nnum_recommendations = 5\nrecommend_items(userID, pivot_df, preds_df, num_recommendations)","31f8a499":"# Actual ratings given by the users\nfinal_ratings_matrix.head()","f0e6d8e3":"# Average ACTUAL rating for each item\nfinal_ratings_matrix.mean().head()","9dec3c63":"# Predicted ratings \npreds_df.head()","255afd44":"# Average PREDICTED rating for each item\npreds_df.mean().head()","d4ad8a14":"rmse_df = pd.concat([final_ratings_matrix.mean(), preds_df.mean()], axis=1)\nrmse_df.columns = ['Avg_actual_ratings', 'Avg_predicted_ratings']\nprint(rmse_df.shape)\nrmse_df['item_index'] = np.arange(0, rmse_df.shape[0], 1)\nrmse_df.head()","9b23cca2":"RMSE = round((((rmse_df.Avg_actual_ratings - rmse_df.Avg_predicted_ratings) ** 2).mean() ** 0.5), 5)\nprint('\\nRMSE SVD Model = {} \\n'.format(RMSE))","7758475c":"# Enter 'userID' and 'num_recommendations' for the user #\nuserID = 9\nnum_recommendations = 5\nrecommend_items(userID, pivot_df, preds_df, num_recommendations)","92d7c0a4":"# **Exploratory Data Analysis******","d0854963":"****User Based Collaborative Filtering model****","181d0fe6":"****As this is a sparse matrix we will use SVD****","603d85ba":"# **Taking the subset of dataset to make it less sparse\/denser.******","68fa573f":"# **handling missing data******","ff819010":"# **Build recommender model**********","50b063b5":"# **Getting top - K ( K = 5) recommendations.******","007cb99c":"# **Ratings analysis in final dataset******","f5029e91":"# ******Import necessary libraries and modules **","2282cadc":"# **Evaluation of Collabrative recommendation model******","193a301d":"# **Read data file from path************","d9c5e317":"# **Building Collaborative Filtering recommender model******","ce24259b":"****"}}