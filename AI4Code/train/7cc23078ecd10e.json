{"cell_type":{"fc29efb6":"code","38e31c43":"code","d1b4f822":"code","17c2878d":"code","726a2a60":"code","57b78626":"code","12e4faf7":"markdown"},"source":{"fc29efb6":"!conda install -c conda-forge gdcm -y","38e31c43":"import os\nimport cv2\nimport random\nimport pydicom\nimport warnings\nimport numpy as np\nimport pandas as pd\nfrom glob import glob\nfrom tqdm import tqdm\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.utils import get_custom_objects\n\nwarnings.filterwarnings('ignore')\nprint('Tensorflow version : {}'.format(tf.__version__))","d1b4f822":"def get_segmentation_model():\n    \n    class FixedDropout(tf.keras.layers.Dropout):\n        def _get_noise_shape(self, inputs):\n            if self.noise_shape is None:\n                return self.noise_shape\n\n            symbolic_shape = tf.keras.backend.shape(inputs)\n            noise_shape = [symbolic_shape[axis] if shape is None else shape\n                           for axis, shape in enumerate(self.noise_shape)]\n            return tuple(noise_shape)\n\n    def DiceCoef(y_trues, y_preds, smooth=1e-5, axis=None):\n        intersection = tf.reduce_sum(y_trues * y_preds, axis=axis)\n        union = tf.reduce_sum(y_trues, axis=axis) + tf.reduce_sum(y_preds, axis=axis)\n        return tf.reduce_mean((2*intersection+smooth) \/ (union + smooth))\n\n    def DiceLoss(y_trues, y_preds):\n        return 1.0 - DiceCoef(y_trues, y_preds)\n\n    get_custom_objects().update({'swish': tf.keras.layers.Activation(tf.nn.swish)})\n    get_custom_objects().update({'FixedDropout':FixedDropout})\n    get_custom_objects().update({'DiceCoef' : DiceCoef})\n    get_custom_objects().update({'DiceLoss' : DiceLoss})\n    \n    print('Load segmentation model...')\n    model = tf.keras.models.load_model('..\/input\/lung-ct-segmentation-pretrain\/osic_segmentation_model.h5')\n    return model","17c2878d":"model = get_segmentation_model()","726a2a60":"def Load_random_ct_scan(BS=8):\n    \n    DIM = 256\n    CT_PATH = '..\/input\/osic-pulmonary-fibrosis-progression\/train\/'\n    patients = os.listdir(CT_PATH)\n    images = np.zeros((BS, DIM, DIM, 3), dtype=np.uint8)\n    \n    for idx in range(BS):\n        random_patient = np.random.choice(patients, 1)[0]\n        fns = os.listdir(os.path.join(CT_PATH, random_patient))\n        random_fn = np.random.choice(fns, 1)[0]\n        \n        dcm = pydicom.dcmread(os.path.join(os.path.join(CT_PATH, random_patient), random_fn))\n        image = dcm.pixel_array\n        image = ((image - np.min(image)) \/ (np.max(image) - np.min(image)) * 255).astype(np.uint8)\n\n        if image.shape[0] != 512 or image.shape[1] != 512:\n            old_x, old_y = image.shape[0], image.shape[1]\n            x = (image.shape[0] - 512) \/\/ 2\n            y = (image.shape[1] - 512) \/\/ 2\n            image = image[x : old_x-x, y : old_y-y]\n            image = image[:512, :512]\n\n        image = cv2.resize(image, (DIM,DIM), cv2.INTER_AREA)\n        image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)\n        images[idx] = image\n    \n    return images \/ 255.0","57b78626":"DEMO_BATCH = 8\nfor idx in range(DEMO_BATCH):\n    images = Load_random_ct_scan()\n    pred_masks = model.predict(images, verbose=0)\n    pred_masks = (pred_masks>0.5).astype(np.float32)\n    \n    plt.figure(figsize=(24,12))\n    for idx, (image, mask) in enumerate(zip(images, pred_masks)):\n        plt.subplot(1,8,idx+1)\n        plt.imshow(image)\n        plt.imshow(mask[:,:,0], alpha=0.35)\n        plt.xticks([])\n        plt.yticks([])\n    plt.show()","12e4faf7":"## Some thoughts\n\nSince most of the people were only using the tabular data provided by host to train their model. <br \/>\nBut it is obvious that this isn't enough to solve the current problem. <br \/>\nI'm pretty sure most of the people were just fitting the LB score by prediting the linear decay of FVC. <br \/>\nAlthough I joined the competition pretty late, but I already tried lots of methods to make the model do the right thing. <br \/>\nBut to be honest, I start to think this is a lottery competition for me, which means I already ran out of ideas. <br \/>\nSo I would like to public my lung segmentaion model for other kaggles and hope this might help you to solve the problem correctly. <br \/>\nI think the performance of this model is okay enough to segment most of the lung info from CT scan. <br \/>\nAnyway, good luck in the private score. <br \/>"}}