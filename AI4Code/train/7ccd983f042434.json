{"cell_type":{"fdb5a4dc":"code","b872f0ca":"code","8bb005b4":"code","89d7ada5":"code","96ef0731":"code","24160057":"code","b2b312ef":"code","c00c309d":"code","74cc7bc1":"code","0749092c":"markdown","9c614328":"markdown","5dbc0665":"markdown","439769f9":"markdown","7c24eb81":"markdown","61ee44df":"markdown","50b91c23":"markdown"},"source":{"fdb5a4dc":"import os\nimport random\nfrom typing import List\nfrom collections import defaultdict, Counter\n\nimport pandas as pd\nimport numpy as np\nimport pytorch_lightning as pl\nimport matplotlib.pyplot as plt\n\nfrom torch.utils.data import Dataset, DataLoader, Sampler, SubsetRandomSampler\n\nDATASET_PATH = '..\/input\/ddsm-cbis-patch'","b872f0ca":"def stratified_group_k_fold(X, y, groups, k, seed=None) -> (np.ndarray, np.ndarray):\n    \"\"\"\n    Borrowed from https:\/\/www.kaggle.com\/jakubwasikowski\/stratified-group-k-fold-cross-validation\n    :param X:\n    :param y:\n    :param groups:\n    :param k:\n    :param seed:\n    :return:\n    \"\"\"\n    labels_num = np.max(y) + 1\n    y_counts_per_group = defaultdict(lambda: np.zeros(labels_num))\n    y_distr = Counter()\n    for label, g in zip(y, groups):\n        y_counts_per_group[g][label] += 1\n        y_distr[label] += 1\n\n    y_counts_per_fold = defaultdict(lambda: np.zeros(labels_num))\n    groups_per_fold = defaultdict(set)\n\n    def eval_y_counts_per_fold(y_counts, fold):\n        y_counts_per_fold[fold] += y_counts\n        std_per_label = []\n        for label in range(labels_num):\n            label_std = np.std([y_counts_per_fold[i][label] \/ y_distr[label] for i in range(k)])\n            std_per_label.append(label_std)\n        y_counts_per_fold[fold] -= y_counts\n        return np.mean(std_per_label)\n\n    groups_and_y_counts = list(y_counts_per_group.items())\n    random.Random(seed).shuffle(groups_and_y_counts)\n\n    for g, y_counts in sorted(groups_and_y_counts, key=lambda x: -np.std(x[1])):\n        best_fold = None\n        min_eval = None\n        for i in range(k):\n            fold_eval = eval_y_counts_per_fold(y_counts, i)\n            if min_eval is None or fold_eval < min_eval:\n                min_eval = fold_eval\n                best_fold = i\n        y_counts_per_fold[best_fold] += y_counts\n        groups_per_fold[best_fold].add(g)\n\n    all_groups = set(groups)\n    for i in range(k):\n        train_groups = all_groups - groups_per_fold[i]\n        test_groups = groups_per_fold[i]\n\n        train_indices = [i for i, g in enumerate(groups) if g in train_groups]\n        test_indices = [i for i, g in enumerate(groups) if g in test_groups]\n\n        yield np.array(train_indices), np.array(test_indices)","8bb005b4":"class PatchDatasetElementNames:\n    IMAGE = 'image'\n    LABEL = 'label'\n    METADATA = 'metadata'\n\n\nclass MetadataUsefulColumnNames:\n    LABEL = 'new_labels'  # the same value as in labels.npy\n    PATIENT_ID = 'patient_id'  # useful for dividing into k folds\n\n    ABNORMALITY_TYPE = 'abnormality_type'  # 'MALIGNANT' or 'BENIGN'\n    PATHOLOGY = 'pathology'  # 'calcification' of 'mass\n\n    IMAGE_VIEW = 'image_view'  # 'CC' 'MLO', read https:\/\/radiopaedia.org\/articles\/mammography-views\n    LEFT_OR_RIGHT_BREAST = 'left_or_right_breast'\n\n    BREAST_DENSITY = 'breast_density'  # integer in [1,2,3,4]\n\n    # Folowing ones describe types of abnormality\n    # present if ABNORMALITY_TYPE=='calcification', otherwise are nan\n    CALCIFICATION_DISTRIBUTION = 'calc_distribution'\n    CALCIFICATION_TYPE = 'calc_type'\n    # present if ABNORMALITY_TYPE=='mass', otherwise are nan\n    MASS_MARGINS = 'mass_margins'\n    MASS_SHAPE = 'mass_shape'\n\n\n    all = [\n        LABEL, PATIENT_ID, ABNORMALITY_TYPE, PATHOLOGY, IMAGE_VIEW, LEFT_OR_RIGHT_BREAST, BREAST_DENSITY,\n        CALCIFICATION_DISTRIBUTION, CALCIFICATION_TYPE, MASS_MARGINS, MASS_SHAPE,\n    ]\n    \n    \nclass PatchDataset(Dataset):\n    def __init__(self, data_directory: str, prefix: str = 'train', image_shape=(900, 900)):\n        super().__init__()\n\n        assert len(image_shape) == 2, 'Image shape can only contain 2 elements, image width and height.'\n\n        self._data_directory = data_directory\n        self._prefix = prefix\n        self._image_shape = image_shape\n\n        self.data, self.labels, self.metadata = self.load_data(prefix)\n\n    def load_data(self, prefix: str = 'train') -> (np.ndarray, np.ndarray, pd.DataFrame):\n        metadata: pd.DataFrame = self._get_metadata()\n\n        data_shape = (len(metadata), self._image_shape[0], self._image_shape[1])\n        data = self._get_npy(f'{prefix}_data.npy', data_shape)\n\n        labels = self._get_npy(f'{prefix}_labels.npy', shape=(len(metadata),))\n\n        assert len(data) == len(labels) == len(\n            metadata), 'Data has different number of elements for images, labels and metadata.'\n\n        return data, labels, metadata\n\n    def __getitem__(self, index):\n        return {\n            PatchDatasetElementNames.IMAGE: self.data[index],\n            PatchDatasetElementNames.LABEL: self.labels[index],\n            PatchDatasetElementNames.INDEX: index\n        }\n\n    def __len__(self):\n        return len(self.metadata)\n\n    def _get_npy(self, file_name: str, shape: tuple, dtype: str = 'uint8') -> np.ndarray:\n        \"\"\"Helper method for memmap loading\"\"\"\n        return np.array(np.memmap(os.path.join(self._data_directory, file_name), dtype=dtype,\n                                  mode='r', shape=shape))\n\n    def _get_metadata(self) -> pd.DataFrame:\n        \"\"\"Helper method for metadata loading\"\"\"\n        name = f'{self._prefix}_meta.h5'\n        path = os.path.join(self._data_directory, name)\n\n        # noinspection PyTypeChecker\n        return pd.read_hdf(path, key='data')[MetadataUsefulColumnNames.all]\n\n    def get_k_fold_ids(self, k: int = 5, seed: int = 42, by_patients: bool = True) -> List[np.ndarray]:\n        \"\"\"\n        Get division of indexes into k folds.\n\n        :param k: defines number of folds\n        :param seed: is used to fix randomness\n        :param by_patients: when is True, one patient can only appear in one fold\n        :return: list of k np.ndarrays, each containing ids of it;s fold\n        \"\"\"\n        ids = np.arange(0, self.__len__())\n\n        if by_patients: # one patient can only appear in one fold\n            ids = np.arange(self.__len__())\n            groups = np.array(self.metadata[MetadataUsefulColumnNames.PATIENT_ID].values)\n            folds = list(np.array(val_ids) for _, val_ids in stratified_group_k_fold(ids, self.labels, groups, k=k, seed=seed))\n        else:\n            # fix random seed used to create folds\n            np.random.seed(seed)\n            np.random.shuffle(ids)\n            folds = np.array_split(ids, k)\n\n\n        # TODO: ballance classes counts\n\n        return folds\n\n    def show_item(self, index: int):\n        label = self.labels[index]\n        plt.title(f'Pattern id: {index}, label:{label}, {self.label_as_text(label)}')\n        plt.imshow(self.data[index])\n        plt.show()\n        plt.close()\n\n    def get_item_metadata(self, index: int):\n        \"\"\"Use MetadataUsefulColumnNames to access values\"\"\"\n        assert 0 <= index < self.__len__()\n        return self.metadata[index:index + 1]\n\n    def label_as_text(self, label: int):\n        if label == 0:\n            return 'BENIGN MASS'\n        elif label == 1:\n            return 'BENIGN CALCIFICATION'\n        elif label == 2:\n            return 'MALIGNANT MASS'\n        elif label == 3:\n            return 'MALIGNANT CALCIFICATION'","89d7ada5":"class PatchDataModule(pl.LightningDataModule):\n\n    def __init__(self, train_batch_size: int, eval_batch_size: int, number_of_folds: int = 9,\n                 data_directory: str = DATASET_PATH):\n        super().__init__()\n        self.data_directory = data_directory\n        self.number_of_folds = number_of_folds\n\n        self.train_batch_size = train_batch_size\n        self.eval_batch_size = eval_batch_size\n\n        self.current_fold = 0\n\n    def setup(self, stage=None):\n        self.ddsm_full = PatchDataset(self.data_directory, 'train')\n        self.ddsm_test = PatchDataset(self.data_directory, 'test')\n\n        # can be useful for cross validation\n        self.folds = self.ddsm_full.get_k_fold_ids(self.number_of_folds)\n        self.train_ids = np.concatenate([self.folds[:self.current_fold] + self.folds[self.current_fold + 1:]])\n        self.validation_ids = self.folds[self.current_fold]\n\n    def train_dataloader(self):\n        train_sampler = SubsetRandomSampler(self.train_ids)\n        return DataLoader(self.ddsm_full, batch_size=self.train_batch_size, sampler=train_sampler)\n\n    def val_dataloader(self):\n        val_sampler = SubsetRandomSampler(self.validation_ids)\n        return DataLoader(self.ddsm_full, batch_size=self.eval_batch_size, sampler=val_sampler)\n\n    def test_dataloader(self):\n        return DataLoader(self.ddsm_test, batch_size=self.eval_batch_size)\n\n","96ef0731":"data_module = PatchDataModule(train_batch_size=10, eval_batch_size=50)\ndata_module.setup()\n\ntrain_loader = data_module.train_dataloader()\nvalidation_loader = data_module.train_dataloader()\ntest_loader = data_module.train_dataloader()\n\n#################################\n# for batch in train_loader\n#    model.train_batch(x=batch[PatchDatasetElementNames.IMAGE], y=batch[PatchDatasetElementNames.LABEL])\n","24160057":"train_loader.dataset.show_item(index=0)","b2b312ef":"train_loader.dataset.show_item(index=35)","c00c309d":"train_loader.dataset.show_item(index=1109)","74cc7bc1":"train_loader.dataset.get_item_metadata(index=1109)","0749092c":"#### Following notebook contains implementation of pytorch_lightning DataModule for DDSM_CBIS_Patch data set","9c614328":"### Helper classes:","5dbc0665":"## Examples of images:","439769f9":"## Example of usage:\nTo better understand how to use or modify this class look at \n\n\nhttps:\/\/pytorch-lightning.readthedocs.io\/en\/latest\/datamodules.html ","7c24eb81":"### imports:","61ee44df":"### Helper function borrowed from \nhttps:\/\/www.kaggle.com\/jakubwasikowski\/stratified-group-k-fold-cross-validation ","50b91c23":"## Lightning DataModule implementation:"}}