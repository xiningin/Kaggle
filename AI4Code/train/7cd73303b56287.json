{"cell_type":{"c657cb13":"code","9c3ecc5d":"code","0fe293ff":"code","8ee9dcdb":"code","0e47fde8":"code","3d226539":"code","d3ff9ca1":"code","ac2d6a39":"code","e381d6b1":"code","8cdd547b":"code","45871bf8":"code","618431aa":"code","2ad5652b":"code","655b1e41":"code","3f72dbb0":"code","fd93ce96":"code","f7d1bcaf":"code","32f98bf2":"code","17c209f8":"code","0961dc8e":"code","0d286f2b":"markdown","63c844ee":"markdown","a7c8b53d":"markdown","41bd6391":"markdown","911f77cc":"markdown","f63cb1cc":"markdown"},"source":{"c657cb13":"# load libraries\nimport numpy as np\nimport pandas as pd\nimport time\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom sklearn.model_selection import KFold, StratifiedKFold","9c3ecc5d":"# set parameters\nNUM_FOLD = 5\nSEED = 42","0fe293ff":"# fix random seed\nnp.random.seed(SEED)","8ee9dcdb":"# load data\ndf_train = pd.read_csv(\"..\/input\/train_curated.csv\")\ndf_test = pd.read_csv(\"..\/input\/sample_submission.csv\")\n\n# preprocess labels\nlabels = df_test.columns[1:].tolist()\nNUM_CLASS = len(labels)\n\nfor label in labels:\n    df_train[label] = df_train['labels'].apply(lambda x: label in x)\nprint(df_train.shape)\ndf_train.head()","0e47fde8":"# try KFold\nfolds = list(KFold(n_splits=NUM_FOLD, shuffle=True, random_state=SEED).split(np.arange(len(df_train))))\ndf_train['fold'] = 0\nfor i in range(NUM_FOLD):\n    df_train['fold'][folds[i][1]] = i","3d226539":"# Check how well the folds are stratified.\nprint(\"fold                                         1    2    3    4    5   total\")\nprint(\"==========================================================================\")\nfor label in labels:\n    label_padded = label + \" \"*(40-len(label))\n    dist = \": \"\n    for i in range(NUM_FOLD):\n        dist += \"{:4d} \".format(df_train[label][folds[i][1]].sum())\n    dist += \"{:4d} \".format(df_train[label].sum())\n    print(label_padded + dist)\nlabel_padded = \"total\" + \" \"*(40-len(\"total\"))\ndist = \": \"\nfor i in range(NUM_FOLD):\n    dist += \"{:4d} \".format(df_train.iloc[folds[i][1]].shape[0])\ndist += \"{:4d} \".format(df_train.shape[0])\nprint(label_padded + dist)","d3ff9ca1":"# calculate number of positive label for each sample\ndf_train['num_labels'] = df_train[labels].values.sum(axis=1)\ndf_train.loc[:,['labels', 'num_labels']].head(10)","ac2d6a39":"# extract data sample with single label and do StratifiedKFold\n\ndf_train_single = df_train[df_train['num_labels']==1].reset_index(drop=True)\nsingle_folds = list(StratifiedKFold(n_splits=NUM_FOLD, shuffle=True, random_state=SEED).split(\n    np.arange(len(df_train_single)), df_train_single[labels].values.argmax(axis=1)))\ndf_train_single['fold'] = 0\nfor i in range(NUM_FOLD):\n    df_train_single['fold'][single_folds[i][1]] = i","e381d6b1":"# Check how well the folds are stratified.\nprint(\"fold                                         1    2    3    4    5   total\")\nprint(\"==========================================================================\")\nfor label in labels:\n    label_padded = label + \" \"*(40-len(label))\n    dist = \": \"\n    for i in range(NUM_FOLD):\n        dist += \"{:4d} \".format(df_train_single[label][df_train_single['fold']==i].sum())\n    dist += \"{:4d} \".format(df_train_single[label].sum())\n    print(label_padded + dist)\nlabel_padded = \"total\" + \" \"*(40-len(\"total\"))\ndist = \": \"\nfor i in range(NUM_FOLD):\n    dist += \"{:4d} \".format(df_train_single[df_train_single['fold']==i].shape[0])\ndist += \"{:4d} \".format(df_train_single.shape[0])\nprint(label_padded + dist)","8cdd547b":"# extract data sample with multi labels\ndf_train_multi = df_train[df_train['num_labels']!=1].reset_index(drop=True)\n\n# count each label\nlabel_counts = []\nfor i in range(NUM_CLASS):    \n    label = labels[i] + \" \"*(40-len(labels[i]))\n    label_counts.append(df_train_multi[labels[i]].sum())\n    print(\"{:2d} {} {}\".format(i, label, label_counts[i]))","45871bf8":"reduced_label = np.zeros(len(df_train_multi), np.uint8)\nfor i in range(NUM_CLASS):\n    target_idx = np.argsort(label_counts)[i]\n    reduced_label[df_train_multi[labels[target_idx]]==1] = target_idx","618431aa":"# Do StratifiedKFold using reduced label\nmulti_folds = list(StratifiedKFold(n_splits=NUM_FOLD, shuffle=True, random_state=SEED).split(\n    np.arange(len(df_train_multi)), reduced_label))\nfor i in range(NUM_FOLD):\n    df_train_multi['fold'][multi_folds[i][1]] = i","2ad5652b":"# Check how well the folds are stratified.\nprint(\"fold                                         1    2    3    4    5   total\")\nprint(\"==========================================================================\")\nfor label in labels:\n    label_padded = label + \" \"*(40-len(label))\n    dist = \": \"\n    for i in range(NUM_FOLD):\n        dist += \"{:4d} \".format(df_train_multi[label][df_train_multi['fold']==i].sum())\n    dist += \"{:4d} \".format(df_train_multi[label].sum())\n    print(label_padded + dist)\nlabel_padded = \"total\" + \" \"*(40-len(\"total\"))\ndist = \": \"\nfor i in range(NUM_FOLD):\n    dist += \"{:4d} \".format(df_train_multi[df_train_multi['fold']==i].shape[0])\ndist += \"{:4d} \".format(df_train_multi.shape[0])\nprint(label_padded + dist)","655b1e41":"# concatenate single-label data and multi-label data\ndf_train2 = pd.concat([df_train_single, df_train_multi]).reset_index(drop=True)","3f72dbb0":"# Check how well the folds are stratified.\nprint(\"fold                                         1    2    3    4    5   total\")\nprint(\"==========================================================================\")\nfor label in labels:\n    label_padded = label + \" \"*(40-len(label))\n    dist = \": \"\n    for i in range(NUM_FOLD):\n        dist += \"{:4d} \".format(df_train2[label][df_train2['fold']==i].sum())\n    dist += \"{:4d} \".format(df_train2[label].sum())\n    print(label_padded + dist)\nlabel_padded = \"total\" + \" \"*(40-len(\"total\"))\ndist = \": \"\nfor i in range(NUM_FOLD):\n    dist += \"{:4d} \".format(df_train2[df_train2['fold']==i].shape[0])\ndist += \"{:4d} \".format(df_train2.shape[0])\nprint(label_padded + dist)","fd93ce96":"def calc_score(df):\n    score = np.zeros([5,NUM_CLASS+1])\n    for i in range(5):\n        score[i] = df.loc[df.fold==i, labels+['num_labels']].values.sum(axis=0)\n    score = score.std(axis=0).mean()\n    return score\nscore = calc_score(df_train)\nprint(\"KFold score: {:.6f}\".format(calc_score(df_train)))\nprint(\"StratifiedKFold score: {:.6f}\".format(calc_score(df_train2)))","f7d1bcaf":"def do_optimize(df, size, steps):\n    \"\"\"\n    df: dataframe to optimize folds\n    size: number of data to change fold\n    steps: number of for loop\n    \"\"\"\n    starttime = time.time()\n    score = calc_score(df)\n    for i in range(steps):\n        # select index to change fold\n        change_idx = np.random.choice(np.arange(df.shape[0]), size, replace=False)\n        # change fold randomly\n        change_fold = np.random.randint(0, NUM_FOLD, size)\n        df_new = df.copy()\n        df_new['fold'][change_idx] = change_fold\n\n        score_new = calc_score(df_new)\n        if score_new < score: # if score getting small, folds will be update\n            score = score_new\n            df = df_new\n        if i%100==0:\n            print(\"step: {:4d}, change size: {:2d}, score: {:.6f}, sec: {:.1f}\".format(\n                i, size, score, time.time()-starttime))\n    return df","32f98bf2":"# Let's do optimization with randomized algorithm.\ndf_train3 = df_train2.copy()\ndf_train3 = do_optimize(df_train3, size=64, steps=1000)\ndf_train3 = do_optimize(df_train3, size=32, steps=1000)\ndf_train3 = do_optimize(df_train3, size=16, steps=1000)\ndf_train3 = do_optimize(df_train3, size=8, steps=1000)\ndf_train3 = do_optimize(df_train3, size=4, steps=1000)\ndf_train3 = do_optimize(df_train3, size=2, steps=1000)\ndf_train3 = do_optimize(df_train3, size=1, steps=10000)\n\nprint(\"StratifiedKFold with randomized algorithm score: {:.6f}\".format(calc_score(df_train3)))","17c209f8":"# Check how well the folds are stratified.\nprint(\"fold                                         1    2    3    4    5   total\")\nprint(\"==========================================================================\")\nfor label in labels:\n    label_padded = label + \" \"*(40-len(label))\n    dist = \": \"\n    for i in range(NUM_FOLD):\n        dist += \"{:4d} \".format(df_train3[label][df_train3['fold']==i].sum())\n    dist += \"{:4d} \".format(df_train3[label].sum())\n    print(label_padded + dist)\nlabel_padded = \"total\" + \" \"*(40-len(\"total\"))\ndist = \": \"\nfor i in range(5):\n    dist += \"{:4d} \".format(df_train3[df_train3['fold']==i].shape[0])\ndist += \"{:4d} \".format(df_train3.shape[0])\nprint(label_padded + dist)","0961dc8e":"# save\ndf_train3.to_csv(\"train_stratified.csv\", index=None)","0d286f2b":"I'm not so familiar with the randomized algorithm.  \nIf you know a smarter way, please tell me.","63c844ee":"All labels of multi-label data cannot be stratified.  \nLabel with more counts should be more stratified.  \nTherefore, let's select a label with more counts and remove others.  ","a7c8b53d":"You can see the folds are not stratified well.  \nOK. Let's do the more sophisticated splitting.","41bd6391":"You can see the folds are more stratified well, but still, it's not perfect.  \nThen, let's do the randomized algorithm.  \n  \nIf each fold is well stratified, std of the number of labels will become small.  \nSo Let's define a score to optimize as the mean of each fold's std of labels' count.  \nThe std of all label's count also should be small.  ","911f77cc":"OK. Now we've got well-stratified folds.","f63cb1cc":"You know, StratifiedKFold of scikit-learn cannot deal with multi-label data.  \nSo, here I would like to get stratified folds using the randomized algorithm. "}}