{"cell_type":{"3098b1c4":"code","62e07342":"code","d77f0f87":"code","af2482e6":"code","b9a72be6":"code","e142addb":"code","d750a64b":"code","bd566f82":"code","2adfed29":"code","72ef9ab0":"code","0051c0a9":"markdown","64ef0465":"markdown","5e70dcab":"markdown","911c5630":"markdown","ef29435d":"markdown","a881fdf1":"markdown","56d1c8dd":"markdown","3f4e3d34":"markdown","fe18788e":"markdown","45bb7835":"markdown","7567b854":"markdown","598242d7":"markdown"},"source":{"3098b1c4":"def bubbleSort(arr):\n\tn = len(arr)\n\n\t# Traverse through all array elements\n\tfor i in range(n):\n\n\t\t# Last i elements are already in place\n\t\tfor j in range(0, n-i-1):\n\n\t\t\t# traverse the array from 0 to n-i-1\n\t\t\t# Swap if the element found is greater\n\t\t\t# than the next element\n\t\t\tif arr[j] > arr[j+1] :\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Driver code to test above\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubbleSort(arr)\n\nprint (\"Sorted array is:\")\nfor i in range(len(arr)):\n\tprint (\"%d\" %arr[i]),","62e07342":"# Sorts numbers in ascending order\nstr_input = input(\"Please enter numbers separated by spaces: \")\n \n# split the string into numbers & create a list of numbers\nnumbers = [int(x) for x in str_input.split()]\n \ncount = len(numbers)\n \nfor outer in range(count-1): # bubbles each number to the end\n    for i in range(count-outer-1):\n        if numbers[i] > numbers[i+1]:\n            # swap numbers!\n            numbers[i],numbers[i+1] = numbers[i+1],numbers[i]\n \nprint(numbers)","d77f0f87":"def QuickSort(arr):\n\n    elements = len(arr)\n    \n    #Base case\n    if elements < 2:\n        return arr\n    \n    current_position = 0 #Position of the partitioning element\n\n    for i in range(1, elements): #Partitioning loop\n         if arr[i] <= arr[0]:\n              current_position += 1\n              temp = arr[i]\n              arr[i] = arr[current_position]\n              arr[current_position] = temp\n\n    temp = arr[0]\n    arr[0] = arr[current_position] \n    arr[current_position] = temp #Brings pivot to it's appropriate position\n    \n    left = QuickSort(arr[0:current_position]) #Sorts the elements to the left of pivot\n    right = QuickSort(arr[current_position+1:elements]) #sorts the elements to the right of pivot\n\n    arr = left + [arr[current_position]] + right #Merging everything together\n    \n    return arr\n\n\n\narray_to_be_sorted = [4,2,7,3,1,6]\nprint(\"Original Array: \",array_to_be_sorted)\nprint(\"Sorted Array: \",QuickSort(array_to_be_sorted))","af2482e6":"def partition(sort_list, low, high):\n    i = (low -1)\n    pivot = sort_list[high]\n    for j in range(low, high):\n        if sort_list[j] <= pivot:\n            i += 1\n            sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n    sort_list[i+1],sort_list[high] = sort_list[high], sort_list[i+1]\n    return (i+1)\n            \ndef quick_sort(sort_list, low, high):\n    if low < high:\n        pi = partition(sort_list, low, high)\n        quick_sort(sort_list, low, pi-1)\n        quick_sort(sort_list, pi+1, high)\n \nlst = []\nsize = int(input(\"Enter size of the list: \"))\n \nfor i in range(size):\n    elements = int(input(\"Enter an element\"))\n    lst.append(elements)\n \nlow = 0\nhigh = len(lst) - 1\nquick_sort(lst, low, high)\nprint(lst)","b9a72be6":"# Function to do insertion sort\ndef insertionSort(arr):\n\n\t# Traverse through 1 to len(arr)\n\tfor i in range(1, len(arr)):\n\n\t\tkey = arr[i]\n\n\t\t# Move elements of arr[0..i-1], that are\n\t\t# greater than key, to one position ahead\n\t\t# of their current position\n\t\tj = i-1\n\t\twhile j >=0 and key < arr[j] :\n\t\t\t\tarr[j+1] = arr[j]\n\t\t\t\tj -= 1\n\t\tarr[j+1] = key\n\n\n# Driver code to test above\narr = [12, 11, 13, 5, 6]\ninsertionSort(arr)\nprint (\"Sorted array is:\")\nfor i in range(len(arr)):\n\tprint (\"%d\" %arr[i])","e142addb":"def insertion_sort(sort_list):\n    for i in range(1, len(sort_list)):\n        key = sort_list[i]\n        j = i - 1\n        while j >= 0 and key < sort_list[j]:\n            sort_list[j + 1] = sort_list[j]\n            j -= 1\n        sort_list[j + 1] = key\n    print('\\nThe sorted list: \\t', sort_list)\n    print('\\n')\n    \nlst = []\nsize = int(input(\"\\nEnter size of the list: \\t\"))\n\nfor i in range(size):\n    elements = int(input(\"Enter the element: \\t\"))\n    lst.append(elements)\n  \ninsertion_sort(lst)","d750a64b":"A = [64, 25, 12, 22, 11]\n  \n# Traverse through all array elements\nfor i in range(len(A)):\n      \n    # Find the minimum element in remaining \n    # unsorted array\n    min_idx = i\n    for j in range(i+1, len(A)):\n        if A[min_idx] > A[j]:\n            min_idx = j\n              \n    # Swap the found minimum element with \n    # the first element        \n    A[i], A[min_idx] = A[min_idx], A[i]\n  \n# Driver code to test above\nprint (\"Sorted array\")\nfor i in range(len(A)):\n    print(\"%d\" %A[i]), ","bd566f82":"def selection_sort(sort_list):\n    for i in range(len(sort_list)):\n        smallest_element = min(sort_list[i:])\n        index_of_smallest = sort_list.index(smallest_element)\n        sort_list[i], sort_list[index_of_smallest] = sort_list[index_of_smallest], sort_list[i]\n        print('\\nPASS :', i + 1, sort_list)\n    print ('\\n\\nThe sorted list: \\t', sort_list)\n    \nlst = []\nsize = int(input(\"\\nEnter size of the list: \\t\"))\n\nfor i in range(size):\n    elements = int(input(\"Enter the element: \\t\"))\n    lst.append(elements)\n    \nselection_sort(lst)","2adfed29":"# To heapify subtree rooted at index i.\n# n is size of heap\ndef heapify(arr, n, i):\n\tlargest = i # Initialize largest as root\n\tl = 2 * i + 1\t # left = 2*i + 1\n\tr = 2 * i + 2\t # right = 2*i + 2\n\n\t# See if left child of root exists and is\n\t# greater than root\n\tif l < n and arr[i] < arr[l]:\n\t\tlargest = l\n\n\t# See if right child of root exists and is\n\t# greater than root\n\tif r < n and arr[largest] < arr[r]:\n\t\tlargest = r\n\n\t# Change root, if needed\n\tif largest != i:\n\t\tarr[i],arr[largest] = arr[largest],arr[i] # swap\n\n\t\t# Heapify the root.\n\t\theapify(arr, n, largest)\n\n# The main function to sort an array of given size\ndef heapSort(arr):\n\tn = len(arr)\n\n\t# Build a maxheap.\n\t# Since last parent will be at ((n\/\/2)-1) we can start at that location.\n\tfor i in range(n \/\/ 2 - 1, -1, -1):\n\t\theapify(arr, n, i)\n\n\t# One by one extract elements\n\tfor i in range(n-1, 0, -1):\n\t\tarr[i], arr[0] = arr[0], arr[i] # swap\n\t\theapify(arr, i, 0)\n\n# Driver code to test above\narr = [ 12, 11, 13, 5, 6, 7]\nheapSort(arr)\nn = len(arr)\nprint (\"Sorted array is\")\nfor i in range(n):\n\tprint (\"%d\" %arr[i]),","72ef9ab0":"def heapsort(alist):\n    build_max_heap(alist)\n    for i in range(len(alist) - 1, 0, -1):\n        alist[0], alist[i] = alist[i], alist[0]\n        max_heapify(alist, index=0, size=i)\n \ndef parent(i):\n    return (i - 1)\/\/2\n \ndef left(i):\n    return 2*i + 1\n \ndef right(i):\n    return 2*i + 2\n \ndef build_max_heap(alist):\n    length = len(alist)\n    start = parent(length - 1)\n    while start >= 0:\n        max_heapify(alist, index=start, size=length)\n        start = start - 1\n \ndef max_heapify(alist, index, size):\n    l = left(index)\n    r = right(index)\n    if (l < size and alist[l] > alist[index]):\n        largest = l\n    else:\n        largest = index\n    if (r < size and alist[r] > alist[largest]):\n        largest = r\n    if (largest != index):\n        alist[largest], alist[index] = alist[index], alist[largest]\n        max_heapify(alist, largest, size)\n \n \nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\nheapsort(alist)\nprint('Sorted list: ', end='')\nprint(alist)","0051c0a9":"# References\n\nTo learn about more algorithms, check out:\n\nhttps:\/\/www.geeksforgeeks.org\/sorting-algorithms\/","64ef0465":"# Bubble sort\n\nBubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.","5e70dcab":"**With user input**","911c5630":"# Quicksort\n\nQuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot.\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.","ef29435d":"**With user input**","a881fdf1":"**With user input**","56d1c8dd":"# Insertion Sort\n\nInsertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.","3f4e3d34":"**With user input**","fe18788e":"**A Sorting Algorithm is used to rearrange a given array or list elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of element in the respective data structure.**","45bb7835":"**With user input**","7567b854":"# Heap Sort\n\nHeap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the minimum element and place the minimum element at the beginning. We repeat the same process for the remaining elements.\n\nHeap Sort Algorithm for sorting in increasing order: \n1. Build a max heap from the input data. \n2. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of the tree. \n3. Repeat step 2 while the size of the heap is greater than 1.","598242d7":"# Selection Sort\n\nThe selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array.\n1) The subarray which is already sorted. \n2) Remaining subarray which is unsorted.\nIn every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray."}}