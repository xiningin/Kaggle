{"cell_type":{"4ce11531":"code","140ab96a":"code","8b1ed287":"code","482d9411":"code","cc4109e3":"code","1dade809":"code","ad150a02":"code","be67b01d":"code","59e53100":"code","0e444a5b":"code","19f523b9":"code","7b77e395":"code","a7d43aab":"code","32496980":"code","1328adc2":"code","95185ba7":"code","377b66c2":"code","6f9f8b0b":"code","c9c74e51":"code","24ebca82":"code","a39107c9":"code","f5bb10b1":"code","2f99453c":"code","036f09d8":"code","31b77d29":"code","e71694b9":"code","56727f20":"code","1cc08275":"code","c18c26ad":"code","02deb71b":"code","3ce82d76":"code","292faf10":"code","f2fdd32a":"code","ec431e23":"code","18776a59":"code","075f3ede":"code","c7edd315":"code","54479f41":"code","ee8b4f69":"code","2731cc87":"code","28f94d96":"code","517024c8":"code","c2513fa6":"code","512db3eb":"code","693c8efa":"code","7397b983":"code","cc2577c7":"code","de4a7a8a":"code","1185f0c4":"code","3fb4f2e2":"code","c013c70e":"code","153cc896":"code","59667709":"code","9dc19b4a":"code","3f847a59":"code","9a98f98f":"code","7dd62721":"code","2f548928":"markdown","c9c37892":"markdown","322af97d":"markdown","922c6c96":"markdown","cc5cc25e":"markdown","c02293fd":"markdown","55bb5189":"markdown","8f25d6db":"markdown","6a16c469":"markdown","d6bb2ce3":"markdown","2a9a5063":"markdown","b0fea53c":"markdown","6156afaf":"markdown","4b7571e3":"markdown","94039c64":"markdown","e5203abc":"markdown"},"source":{"4ce11531":"# Import libraries\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sb\n#sb.set_style(\"whitegrid\")\nplt.style.use('seaborn-poster')\nplt.rcParams[\"figure.figsize\"] = (15,7)\n\nfrom scipy import stats\nimport statsmodels.api as sm\nfrom itertools import product\nfrom datetime import datetime\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n","140ab96a":"# CODE SECTION\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\ndef eval_metrics(actual, pred):\n    mae = mean_absolute_error(actual, pred)\n    mse = mean_squared_error(actual, pred)\n    rmse = np.sqrt(mean_squared_error(actual, pred))\n    R2_score = r2_score(actual, pred)\n    print(\"------------------------------------\")\n    print(f\"R2_score \\t: {R2_score}\")\n    print(f\"MAE \\t\\t: {mae}\")\n    print(f\"MSE \\t\\t: {mse}\")\n    print(f\"RMSE \\t\\t: {rmse}\")\ndef evals_():\n    print(\"y_train \/ y_train_pred \")\n    eval_metrics(y_train, y_train_pred)\n    #print(\"y_test \/ y_test_pred \")\n    #eval_metrics(y_test, y_test_pred)\ndef rms_() :   #  RMS\n    trainscore = int(math.sqrt(mean_squared_error(y_train, y_train_pred)))\n    print(\"Train Score: %.f RMSE\" % (trainscore))\n    #testscore = int(math.sqrt(mean_squared_error(y_test, y_test_pred)))\n    #print(\"Test Score: %.f RMSE\" % (testscore))\n\n\n# Visualising the results\ndef ploty(real,predicted)  :\n    plt.plot(real,      color = 'red' , label = '  Real Price'     )   # Real Stock price\n    plt.plot(predicted, color = 'blue', label = '  Predicted Price')\n    plt.xlabel('Day') ; plt.ylabel(' Price') ; plt.legend()\n    plt.show()\ndef plot_():\n    #ploty(y_train,y_train_pred)    # TRAIN\n    ploty(y_test,y_test_pred)       # TEST","8b1ed287":"# Load data\ndf = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2021-03-31.csv')\ndf.head()","482d9411":"# Unix-time to \ndf.Timestamp = pd.to_datetime(df.Timestamp, unit='s')\ndf.head(2)","cc4109e3":"df.index = df.Timestamp\ndf_day= df.resample('D').mean()","1dade809":"df_day.head(2)","ad150a02":"len(df_day)","be67b01d":"df_day = df_day.iloc[1200:,:]","59e53100":"df_day.isnull().sum().sum()","0e444a5b":"#df.dropna(inplace=True)","19f523b9":"# Resampling to monthly frequency\ndf_month = df_day.resample('M').mean()\n\n# Resampling to quarterly frequency\ndf_Q = df_day.resample('Q-DEC').mean()\n\n# Resampling to annual frequency\ndf_year = df_day.resample('A-DEC').mean()","7b77e395":"df_day.tail(2)","a7d43aab":"df_month.tail(2)","32496980":"df_year.tail(2)","1328adc2":"# PLOTS\nfig = plt.figure(figsize=[15, 7])\nplt.suptitle('Bitcoin exchanges, mean USD', fontsize=22)\nplt.subplot(221)\nplt.plot(df_day.Weighted_Price, '-', label='By Days')\nplt.legend()\nplt.subplot(222)\nplt.plot(df_month.Weighted_Price, '-', label='By Months')\nplt.legend()\nplt.subplot(223)\nplt.plot(df_Q.Weighted_Price, '-', label='By Quarters')\nplt.legend()\nplt.subplot(224)\nplt.plot(df_year.Weighted_Price, '-', label='By Years')\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n# Let's predict bitcoin prices by months.","95185ba7":"plt.figure(figsize=[15,7])\nsm.tsa.seasonal_decompose(df_month.Weighted_Price).plot()\nplt.show()","377b66c2":"print(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_month.Weighted_Price)[1])","6f9f8b0b":"# Box-Cox Transformations\ndf_month['Weighted_Price_box'], lmbda = stats.boxcox(df_month.Weighted_Price)\ndf_month.tail(2)","c9c74e51":"print(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_month.Weighted_Price_box)[1])","24ebca82":"# Seasonal differentiation\ndf_month['prices_box_diff'] = df_month.Weighted_Price_box - df_month.Weighted_Price_box.shift(12)\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_month.prices_box_diff[12:])[1])","a39107c9":"# Regular differentiation\ndf_month['prices_box_diff2'] = df_month.prices_box_diff - df_month.prices_box_diff.shift(1)\ndf_month.head(15)","f5bb10b1":"# STL-decomposition\nplt.figure(figsize=(15,7))\nsm.tsa.seasonal_decompose(df_month.prices_box_diff2[13:]).plot()   \nplt.show()","2f99453c":"print(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_month.prices_box_diff2[13:])[1])","036f09d8":"# Initial approximation of parameters using Autocorrelation and Partial Autocorrelation Plots\nplt.figure(figsize=(15,7))\nax = plt.subplot(211)\nsm.graphics.tsa.plot_acf(df_month.prices_box_diff2[13:].values.squeeze(), lags=20, ax=ax)\nax = plt.subplot(212)\nsm.graphics.tsa.plot_pacf(df_month.prices_box_diff2[13:].values.squeeze(), lags=20, ax=ax)\nplt.tight_layout()\nplt.show()","31b77d29":"# Initial approximation of parameters\nQs = range(0, 2)\nqs = range(0, 3)\nPs = range(0, 3)\nps = range(0, 3)\nD=1\nd=1\nparameters = product(ps, qs, Ps, Qs)\nparameters_list = list(parameters)\nlen(parameters_list)\n\n# Model Selection\nresults = []\nbest_aic = float(\"inf\")\nwarnings.filterwarnings('ignore')\nfor param in parameters_list:\n    try:\n        model=sm.tsa.statespace.SARIMAX(df_month.Weighted_Price_box, order=(param[0], d, param[1]), \n              seasonal_order=(param[2], D, param[3], 12)).fit(disp=-1)\n    except ValueError:\n        print('wrong parameters:', param)\n        continue\n    aic = model.aic\n    if aic < best_aic:\n        best_model = model\n        best_aic = aic\n        best_param = param\n    results.append([param, model.aic])","e71694b9":"# Best Models\nresult_table = pd.DataFrame(results)\nresult_table.columns = ['parameters', 'aic']\nprint(result_table.sort_values(by = 'aic', ascending=True).head())\nprint(best_model.summary())","56727f20":"# STL-decomposition\nplt.figure(figsize=(15,7))\nplt.subplot(211)\nbest_model.resid[13:].plot()\nplt.ylabel(u'Residuals')\nax = plt.subplot(212)\nsm.graphics.tsa.plot_acf(best_model.resid[13:].values.squeeze(), lags=20, ax=ax)\n\nprint(\"Dickey\u2013Fuller test:: p=%f\" % sm.tsa.stattools.adfuller(best_model.resid[13:])[1])\n\nplt.tight_layout()\nplt.show()","1cc08275":"print(\"Dickey\u2013Fuller test:: p=%f\" % sm.tsa.stattools.adfuller(best_model.resid[13:])[1])","c18c26ad":"# Inverse Box-Cox Transformation Function\ndef invboxcox(y,lmbda):\n    if lmbda == 0:\n        return(np.exp(y))\n    else:\n        return(np.exp(np.log(lmbda*y+1)\/lmbda))","02deb71b":"# Prediction\ndf_month2 = df_month[['Weighted_Price']]\ndate_list = [datetime(2021, 3, 31), datetime(2021, 4, 30), datetime(2021, 5, 31), datetime(2021, 6, 30), \n             datetime(2021,7, 31), datetime(2021, 8, 31)]\nfuture = pd.DataFrame(index=date_list, columns= df_month.columns)\ndf_month2 = pd.concat([df_month2, future])\ndf_month2['forecast'] = invboxcox(best_model.predict(start=0, end=76), lmbda)\nplt.figure(figsize=(15,7))\ndf_month2.Weighted_Price.plot()\ndf_month2.forecast.plot(color='r', ls='--', label='Predicted Weighted_Price')\nplt.legend()\nplt.title('Bitcoin exchanges by months, future predicton')\nplt.ylabel('mean USD')\nplt.show()","3ce82d76":"df_month2.forecast.tail(8)","292faf10":"# X_train=df_day[:-30]     # X_train    \n# X_test=df_day[-30:]      # X_test   , last 30 days","f2fdd32a":"## Stationarity check and STL-decomposition of the series\nplt.figure(figsize=[15,7])\nsm.tsa.seasonal_decompose(df_day.Weighted_Price).plot()\nplt.show()\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_day.Weighted_Price)[1])","ec431e23":"#### The series are not stationary.","18776a59":"## Box-Cox Transformations\n# Box-Cox Transformations\ndf_day['Weighted_Price_box'], lmbda = stats.boxcox(df_day.Weighted_Price)\ndf_day.head(2)\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_day.Weighted_Price_box)[1])","075f3ede":"#### The series are not stationary.","c7edd315":"## Seasonal differentiation\n# Seasonal differentiation\ndf_day['prices_box_diff'] = df_day.Weighted_Price_box - df_day.Weighted_Price_box.shift(7)\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_day.prices_box_diff[7:])[1])","54479f41":"#### The series are stationary.","ee8b4f69":"## Regular differentiation\n# Regular differentiation\ndf_day['prices_box_diff2'] = df_day.prices_box_diff - df_day.prices_box_diff.shift(1)\ndf_day.head(10)","2731cc87":"# STL-decomposition\nplt.figure(figsize=(15,7))\nsm.tsa.seasonal_decompose(df_day.prices_box_diff[7:]).plot()   \nplt.show()","28f94d96":"# STL-decomposition\nplt.figure(figsize=(15,7))\nsm.tsa.seasonal_decompose(df_day.prices_box_diff2[8:]).plot()   \nplt.show()","517024c8":"# STL-decomposition  # Last 90 days \nplt.figure(figsize=(15,7))\nsm.tsa.seasonal_decompose(df_day.prices_box_diff2[-90:]).plot()   \nplt.show()","c2513fa6":"# STL-decomposition  # Last 30 days \nplt.figure(figsize=(15,7))\nsm.tsa.seasonal_decompose(df_day.prices_box_diff2[-30:]).plot()   \nplt.show()","512db3eb":"print(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(df_day.prices_box_diff2[8:])[1])","693c8efa":"#### The series are stationary.\n## ACF Autocorrelation Function Plot\n# Initial approximation of parameters using Autocorrelation and Partial Autocorrelation Plots\nplt.figure(figsize=(15,7))\nax = plt.subplot(211)\nsm.graphics.tsa.plot_acf(df_day.prices_box_diff2[8:].values.squeeze(), lags=48, ax=ax)\nax = plt.subplot(212)\nsm.graphics.tsa.plot_pacf(df_day.prices_box_diff2[8:].values.squeeze(), lags=48, ax=ax)\nplt.tight_layout()\nplt.show()","7397b983":"## Model Selection\n# Initial approximation of parameters\nQs = range(0, 2)\nqs = range(0, 3)\nPs = range(0, 3)\nps = range(0, 3)\nD=1\nd=1\nparameters = product(ps, qs, Ps, Qs)\nparameters_list = list(parameters)\nlen(parameters_list)\n\n# Model Selection\nresults = []\nbest_aic = float(\"inf\")\nwarnings.filterwarnings('ignore')\nfor param in parameters_list:\n    try:\n        model=sm.tsa.statespace.SARIMAX(df_day.Weighted_Price_box, order=(param[0], d, param[1]), \n              seasonal_order=(param[2], D, param[3], 7)).fit(disp=-1)\n    except ValueError:\n        print('wrong parameters:', param)\n        continue\n    aic = model.aic\n    if aic < best_aic:\n        best_model = model\n        best_aic = aic\n        best_param = param\n    results.append([param, model.aic])","cc2577c7":"# Model Selection\n# Initial approximation of parameters\ndef model_():\n    Qs = range(0, 2)\n    qs = range(0, 3)\n    Ps = range(0, 3)\n    ps = range(0, 3)\n    D=1\n    d=1\n    parameters = product(ps, qs, Ps, Qs)\n    parameters_list = list(parameters)\n    len(parameters_list)\n\n    # Box-Cox Transformations\n    df_day['Weighted_Price_box'], lmbda = stats.boxcox(df_day.Weighted_Price)\n    df_day['prices_box_diff'] = df_day.Weighted_Price_box - df_day.Weighted_Price_box.shift(7)\n    df_day['prices_box_diff2'] = df_day.prices_box_diff - df_day.prices_box_diff.shift(1)\n    \n    # Model Selection\n    results = []\n    best_aic = float(\"inf\")\n    warnings.filterwarnings('ignore')\n    for param in parameters_list:\n        try:\n            model=sm.tsa.statespace.SARIMAX(df_day.Weighted_Price_box, order=(param[0], d, param[1]), \n              seasonal_order=(param[2], D, param[3], 7)).fit(disp=-1)\n        except ValueError:\n            print('wrong parameters:', param)\n            continue\n        aic = model.aic\n        if aic < best_aic:\n            best_model = model\n            best_aic = aic\n            best_param = param\n        results.append([param, model.aic])","de4a7a8a":"# Best Models\nresult_table = pd.DataFrame(results)\nresult_table.columns = ['parameters', 'aic']\nprint(result_table.sort_values(by = 'aic', ascending=True).head())\nprint(best_model.summary())","1185f0c4":"## Analysis of residues\n# STL-decomposition\nplt.figure(figsize=(15,7))\nplt.subplot(211)\nbest_model.resid[8:].plot()\nplt.ylabel(u'Residuals')\nax = plt.subplot(212)\nsm.graphics.tsa.plot_acf(best_model.resid[8:].values.squeeze(), lags=48, ax=ax)\n\nprint(\"Dickey\u2013Fuller test:: p=%f\" % sm.tsa.stattools.adfuller(best_model.resid[13:])[1])\n\nplt.tight_layout()\nplt.show()","3fb4f2e2":"print(\"Dickey\u2013Fuller test:: p=%f\" % sm.tsa.stattools.adfuller(best_model.resid[13:])[1])","c013c70e":"def invboxcox(y,lmbda):\n    if lmbda == 0:\n        return(np.exp(y))\n    else:\n        return(np.exp(np.log(lmbda*y+1)\/lmbda))","153cc896":"end_=len(df_day)\nend_","59667709":"# TRAIN Prediction\ndf2 = df_day[['Weighted_Price']]\ndf2['forecast'] = invboxcox(best_model.predict(start=8, end=end_), lmbda)\nplt.figure(figsize=(15,7))\ndf2.Weighted_Price.plot()\ndf2.forecast.plot(color='r', ls='--', label='Predicted Weighted_Price')\nplt.legend()\nplt.title(' Bitcoin exchanges,Train Prediction  by days')\nplt.ylabel('mean USD')\nplt.show()\ndf2","9dc19b4a":"# TRAIN Prediction   Last 30 days of Train prediction\ndf3= df_day[['Weighted_Price']][-30:]\ndf3['forecast'] = invboxcox(best_model.predict(start=end_-60, end=end_), lmbda)\nplt.figure(figsize=(15,7))\ndf3.Weighted_Price.plot()\ndf3.forecast.plot(color='r', ls='--', label='Predicted Weighted_Price')\nplt.legend()\nplt.title(' Bitcoin exchanges, Train prediction last month by days')\nplt.ylabel('mean USD')\nplt.show()\n","3f847a59":"y_train=df3.Weighted_Price\ny_train_pred=df3.forecast\nevals_()","9a98f98f":"# Prediction  for next 3 days\ndf3 = df_day[['Weighted_Price']][-30:]\ndate_list =[datetime(2021, 4,1), datetime(2021,4,2), datetime(2021,4,3)]\nfuture = pd.DataFrame(index=date_list, columns= df.columns)\ndf3 = pd.concat([df3, future])\ndf3['forecast'] = invboxcox(best_model.predict(start=2149, end=2181), lmbda)\nplt.figure(figsize=(15,7))\ndf3.Weighted_Price.plot()\ndf3.forecast.plot(color='r', ls='--', label='Predicted Weighted_Price')\nplt.legend()\nplt.title('Bitcoin   prediction  next 3 days')\nplt.ylabel('mean USD')\nplt.show()\n","7dd62721":"df3[[\"Weighted_Price\",\"forecast\"]].tail(5) # The last 3 days are forecasted days","2f548928":"#### The series are not stationary.","c9c37892":"# Prediction","322af97d":"# Autoregressive Integrated Moving Average (ARIMA)","922c6c96":"# Prediction","cc5cc25e":"## Model Selection","c02293fd":"## Seasonal differentiation","55bb5189":"## Regular differentiation","8f25d6db":"# bitcoin price prediction by day.","6a16c469":"## Analysis of residues","d6bb2ce3":"## Stationarity check and STL-decomposition of the series","2a9a5063":"There are Seasonal and Non-seasonal ARIMA models that can be used for forecasting\n\nStationary: series without trend or seasonality    \n\nIn an ARIMA model we transform a time series into stationary one, using differencing. \n\nStationary time series is when the mean and variance are constant over time. It is easier to predict when the series is stationary.\nDifferencing is a method of transforming a non-stationary time series into a stationary one.This is an important step in preparing data to be used in an ARIMA model.\n\nD = Refers to the number of differencing transformations required by the time series to get stationary.\n\nThe first differencing value is the difference between the current time period and the previous time period. \nIf these values fail to revolve around a constant mean and variance then we find the second differencing using the values of the first differencing.\nWe repeat this until we get a stationary series.\n(The best way to determine whether or not the series is sufficiently differenced is to plot the differenced series and check to see if there is a constant mean and variance.)\n\nDickey\u2013Fuller test:  to determine a series is stationary or not: \nif  p-value <= 0.05: (%5) that it means that  the data does not have a unit root and is stationary\n\nQ = This variable denotes the lag of the error component, where error component is a part of the time series not explained by trend or seasonality\n\nAutocorrelation function plot (ACF):\nAutocorrelation refers to how correlated a time series is with its past values whereas the ACF is the plot used to see the correlation between the points, up to and including the lag unit. \nIn ACF, the correlation coefficient is in the x-axis whereas the number of lags is shown in the y-axis.\nThe Autocorrelation function plot will let you know how the given time series is correlated with itself","b0fea53c":"#### The series are stationary.","6156afaf":"## ACF Autocorrelation Function Plot","4b7571e3":"#### The series are not stationary.","94039c64":"## Inverse Box-Cox Transformation Function","e5203abc":"#### The series are not stationary.\n\n## Box-Cox Transformations"}}