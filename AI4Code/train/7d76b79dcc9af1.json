{"cell_type":{"212163eb":"code","a9b72d32":"code","ef6199d8":"code","095063b4":"code","ff91920b":"code","96eade6b":"code","0b040736":"code","c96f6343":"code","0ab6f643":"code","483bef2a":"code","5105b812":"code","f6d792e9":"code","9455047e":"code","7e960de8":"code","ff1d68b7":"code","fb441750":"code","9955fccd":"code","fe45c3d4":"code","1ea22635":"code","9863551e":"code","b01d4e73":"code","07c5c256":"code","843d416f":"code","1dbced8c":"code","ea26e8eb":"code","420c1772":"code","704f365f":"code","6b780f28":"code","3368a905":"code","08e734bf":"code","fe2121bd":"code","ed4ecfe9":"code","dd3f68bc":"code","4cda6c0a":"code","6a9c447a":"code","4b9ac728":"code","ba0e0291":"code","a65588f5":"code","f8f9513a":"markdown","7c44e5dd":"markdown","b59a83b5":"markdown","4a429633":"markdown","50da04f1":"markdown","b5f8e597":"markdown","a5548768":"markdown","a5e2597a":"markdown","8b7d0616":"markdown","c2b674b2":"markdown","cc167d0b":"markdown","4c1e3b8a":"markdown","7cb43972":"markdown","fd58c7a5":"markdown","fd4ff283":"markdown","a55ff3c1":"markdown","f3b4fd3f":"markdown"},"source":{"212163eb":"import pandas as pd\nimport numpy as np\nimport math\nimport time\nimport os\nfrom skimage import io, transform\nimport PIL","a9b72d32":"%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nimport matplotlib.pyplot as plt\n\nimport torch\nfrom torchvision import datasets, transforms, models\n\nfrom torch import nn, optim\nimport torch.nn.functional as F\nfrom torch.optim.lr_scheduler import ExponentialLR\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.sampler import SubsetRandomSampler","ef6199d8":"# Config\ndata_dir = '..\/input\/petfinder-pawpularity-score\/'\nmodel_dir = '..\/input\/convnext-pretrained-model-v2\/'\nweights_dir = '..\/input\/convnext-pretrained-weights-2-stage\/'\nworking_dir = '.\/'\nglobal_batch_size = 64\nworkers = 2\nnp.random.seed(10)\nprint(os.listdir(data_dir))\nprint(os.listdir(f'{data_dir}train')[0:4])","095063b4":"train_df = pd.read_csv(f'{data_dir}train.csv')","ff91920b":"train_df.head()","96eade6b":"train_df.info()","0b040736":"# Annotations\nnp.array(train_df.iloc[2, 1:13])","c96f6343":"# Scores\ntrain_df.iloc[2, 13]","0ab6f643":"n, bins, patches = plt.hist(train_df.iloc[:, 13], 50, density=True, facecolor='g', alpha=0.75)\n\nplt.xlabel('Pawpularity')\nplt.ylabel('Frequency')\nplt.title('Pawpularity Histogram')\nplt.xlim(0, 100)\n# plt.ylim(0, 0.03)\nplt.grid(True)\nplt.show()","483bef2a":"class PawpularityDataset(Dataset):\n    \"\"\"Dataset connecting animal images to the score and annotations\"\"\"\n\n    def __init__(self, csv_file, img_dir, transform=transforms.ToTensor()):\n        \"\"\"\n        Args:\n            csv_file (string): Path to the csv file with annotations.\n            img_dir (string): Directory with all the images.\n            transform (callable, optional): Optional transform to be applied\n                on a sample.\n        \"\"\"\n\n        self.annotations_csv = pd.read_csv(csv_file)\n        self.img_dir = img_dir\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.annotations_csv)\n\n    def __getitem__(self, idx):\n        if torch.is_tensor(idx):\n            idx = idx.tolist()\n\n        img_name = os.path.join(self.img_dir,\n                                self.annotations_csv.iloc[idx, 0])\n\n        # load each image in PIL format for compatibility with transforms\n        image = PIL.Image.open(img_name + '.jpg')\n        \n        # Columns 1 to 12 contain the annotations\n        annotations = np.array(self.annotations_csv.iloc[idx, 1:13])\n        annotations = annotations.astype('float')\n        # Column 13 has the scores\n        score = np.array(self.annotations_csv.iloc[idx, 13])\n        score = torch.tensor(score.astype('float')).view(1).to(torch.float32)\n\n        # Apply the transforms\n        image = self.transform(image)\n\n        sample = [image, annotations, score]\n        return sample","5105b812":"# Test out the transforms on an image (images need to be made the same size for the dataset to work)\n# Apply some image augmentation on the training set (rotation, flip)\n# Normalize using imagenet RGB mean and std\n\nimg_transforms = transforms.Compose([transforms.Resize(255),\n                                     transforms.CenterCrop(224),\n                                     transforms.RandomHorizontalFlip(),\n                                     transforms.RandomRotation(20),\n                                     transforms.ToTensor(),\n                                     transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                                                          std=[0.229, 0.224, 0.225])])\n\nimg_transforms_valid = transforms.Compose([transforms.Resize(255),\n                                           transforms.CenterCrop(224),\n                                           transforms.ToTensor(),\n                                           transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                                                                std=[0.229, 0.224, 0.225])])","f6d792e9":"# Load and set up the final training and validation dataset (use different transforms)\n# Return a list of train\/valid dataloaders with different train\/test splits for cross validation\nfrom sklearn.model_selection import KFold\n\n# Create two versions of the dataset with and without image augmentation\naugmented_data = PawpularityDataset(f'{data_dir}train.csv', f'{data_dir}train', transform=img_transforms)\nbase_transform_data = PawpularityDataset(f'{data_dir}train.csv', f'{data_dir}train', transform=img_transforms_valid)\n\ndef get_cv_dataloaders(augmented_data, base_transform_data, folds=5, cv_shuffle=True, rands=10):\n    \n    num_images = len(augmented_data)\n    indices = list(range(num_images))\n    \n    dataloaders = []\n    \n    # use sklearn kfold to split into random training\/validation indices\n    cv = KFold(n_splits=folds, random_state=rands, shuffle=cv_shuffle)\n    for train_idx, valid_idx in cv.split(indices):\n        # define samplers for obtaining training and validation batches\n        train_sampler = SubsetRandomSampler(train_idx)\n        valid_sampler = SubsetRandomSampler(valid_idx)\n\n        # create dataloaders using the cv indexes\n        train_loader = torch.utils.data.DataLoader(augmented_data, batch_size=global_batch_size,\n                                                   sampler=train_sampler, num_workers=workers,\n                                                   pin_memory=True) \n        # sample the validation dataset from a separate dataset the doesn't include the image aug transformations.\n        valid_loader = torch.utils.data.DataLoader(base_transform_data, batch_size=global_batch_size,\n                                                   sampler=valid_sampler, num_workers=workers,\n                                                   pin_memory=True) \n\n        # print('Train length: ', len(train_loader)*global_batch_size)\n        # print('Valid length: ', len(valid_loader)*global_batch_size)\n        \n        dataloaders.append((train_loader, valid_loader))\n        \n    return dataloaders\n\n        \n","9455047e":"cv_dataloaders = get_cv_dataloaders(augmented_data=augmented_data, \n                                base_transform_data=base_transform_data,\n                                folds=3, \n                                cv_shuffle=True)","7e960de8":"# Batch size of 64\ntl = cv_dataloaders[0][1]\nimages, annotations, scores = next(iter(tl))\nprint(images.shape)\nprint(scores.shape)\nprint(annotations.shape)","ff1d68b7":"# Helper function to unnormalize and plot images\ndef im_convert(tensor):\n    \"\"\" Display a tensor as an image. \"\"\"\n    \n    image = tensor.to(\"cpu\").clone().detach()\n    image = image.numpy().squeeze()\n    image = image * np.array((0.229, 0.224, 0.225)).reshape(3, 1, 1) + np.array((0.485, 0.456, 0.406)).reshape(3, 1, 1)\n    img = (image * 255).astype(np.uint8) # unnormalize\n    \n\n    return plt.imshow(np.transpose(img, (1, 2, 0)))","fb441750":"im_numpy = images.numpy() # convert images to numpy for display\n\n# plot the images in the batch, along with the corresponding labels\nfig = plt.figure(figsize=(20, 10))\n# display 20 images\nfor idx in np.arange(8):\n    ax = fig.add_subplot(2, 4, idx+1, xticks=[], yticks=[])\n    im_convert(images[idx])\n    ax.set_title(scores[idx].item())","9955fccd":"import torch.nn as nn\nimport torch.nn.functional as func\nimport torch.optim as optim","fe45c3d4":"# Pytorch implementation of convnext\n# Source: https:\/\/github.com\/facebookresearch\/ConvNeXt\/blob\/dc7823d8a2ecc554fcd57ff6cdb7748011bcdedd\/models\/convnext.py\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport sys\nsys.path.append('..\/input\/timm-pytorch-image-models\/pytorch-image-models-master')\nfrom timm.models.layers import trunc_normal_, DropPath\nfrom timm.models.registry import register_model\n\nclass Block(nn.Module):\n    r\"\"\" ConvNeXt Block. There are two equivalent implementations:\n    (1) DwConv -> LayerNorm (channels_first) -> 1x1 Conv -> GELU -> 1x1 Conv; all in (N, C, H, W)\n    (2) DwConv -> Permute to (N, H, W, C); LayerNorm (channels_last) -> Linear -> GELU -> Linear; Permute back\n    We use (2) as we find it slightly faster in PyTorch\n    \n    Args:\n        dim (int): Number of input channels.\n        drop_path (float): Stochastic depth rate. Default: 0.0\n        layer_scale_init_value (float): Init value for Layer Scale. Default: 1e-6.\n    \"\"\"\n    def __init__(self, dim, drop_path=0., layer_scale_init_value=1e-6):\n        super().__init__()\n        self.dwconv = nn.Conv2d(dim, dim, kernel_size=7, padding=3, groups=dim) # depthwise conv\n        self.norm = LayerNorm(dim, eps=1e-6)\n        self.pwconv1 = nn.Linear(dim, 4 * dim) # pointwise\/1x1 convs, implemented with linear layers\n        self.act = nn.GELU()\n        self.pwconv2 = nn.Linear(4 * dim, dim)\n        self.gamma = nn.Parameter(layer_scale_init_value * torch.ones((dim)), \n                                    requires_grad=True) if layer_scale_init_value > 0 else None\n        self.drop_path = DropPath(drop_path) if drop_path > 0. else nn.Identity()\n\n    def forward(self, x):\n        input = x\n        x = self.dwconv(x)\n        x = x.permute(0, 2, 3, 1) # (N, C, H, W) -> (N, H, W, C)\n        x = self.norm(x)\n        x = self.pwconv1(x)\n        x = self.act(x)\n        x = self.pwconv2(x)\n        if self.gamma is not None:\n            x = self.gamma * x\n        x = x.permute(0, 3, 1, 2) # (N, H, W, C) -> (N, C, H, W)\n\n        x = input + self.drop_path(x)\n        return x\n\nclass ConvNeXt(nn.Module):\n    r\"\"\" ConvNeXt\n        A PyTorch impl of : `A ConvNet for the 2020s`  -\n          https:\/\/arxiv.org\/pdf\/2201.03545.pdf\n    Args:\n        in_chans (int): Number of input image channels. Default: 3\n        num_classes (int): Number of classes for classification head. Default: 1000\n        depths (tuple(int)): Number of blocks at each stage. Default: [3, 3, 9, 3]\n        dims (int): Feature dimension at each stage. Default: [96, 192, 384, 768]\n        drop_path_rate (float): Stochastic depth rate. Default: 0.\n        layer_scale_init_value (float): Init value for Layer Scale. Default: 1e-6.\n        head_init_scale (float): Init scaling value for classifier weights and biases. Default: 1.\n    \"\"\"\n    def __init__(self, in_chans=3, num_classes=1000, \n                 depths=[3, 3, 9, 3], dims=[96, 192, 384, 768], drop_path_rate=0., \n                 layer_scale_init_value=1e-6, head_init_scale=1.,\n                 ):\n        super().__init__()\n\n        self.downsample_layers = nn.ModuleList() # stem and 3 intermediate downsampling conv layers\n        stem = nn.Sequential(\n            nn.Conv2d(in_chans, dims[0], kernel_size=4, stride=4),\n            LayerNorm(dims[0], eps=1e-6, data_format=\"channels_first\")\n        )\n        self.downsample_layers.append(stem)\n        for i in range(3):\n            downsample_layer = nn.Sequential(\n                    LayerNorm(dims[i], eps=1e-6, data_format=\"channels_first\"),\n                    nn.Conv2d(dims[i], dims[i+1], kernel_size=2, stride=2),\n            )\n            self.downsample_layers.append(downsample_layer)\n\n        self.stages = nn.ModuleList() # 4 feature resolution stages, each consisting of multiple residual blocks\n        dp_rates=[x.item() for x in torch.linspace(0, drop_path_rate, sum(depths))] \n        cur = 0\n        for i in range(4):\n            stage = nn.Sequential(\n                *[Block(dim=dims[i], drop_path=dp_rates[cur + j], \n                layer_scale_init_value=layer_scale_init_value) for j in range(depths[i])]\n            )\n            self.stages.append(stage)\n            cur += depths[i]\n\n        self.norm = nn.LayerNorm(dims[-1], eps=1e-6) # final norm layer\n        self.head = nn.Linear(dims[-1], num_classes)\n\n        self.apply(self._init_weights)\n        self.head.weight.data.mul_(head_init_scale)\n        self.head.bias.data.mul_(head_init_scale)\n\n    def _init_weights(self, m):\n        if isinstance(m, (nn.Conv2d, nn.Linear)):\n            trunc_normal_(m.weight, std=.02)\n            nn.init.constant_(m.bias, 0)\n\n    def forward_features(self, x):\n        for i in range(4):\n            x = self.downsample_layers[i](x)\n            x = self.stages[i](x)\n        return self.norm(x.mean([-2, -1])) # global average pooling, (N, C, H, W) -> (N, C)\n\n    def forward(self, x):\n        x = self.forward_features(x)\n        x = self.head(x)\n        return x\n\nclass LayerNorm(nn.Module):\n    r\"\"\" LayerNorm that supports two data formats: channels_last (default) or channels_first. \n    The ordering of the dimensions in the inputs. channels_last corresponds to inputs with \n    shape (batch_size, height, width, channels) while channels_first corresponds to inputs \n    with shape (batch_size, channels, height, width).\n    \"\"\"\n    def __init__(self, normalized_shape, eps=1e-6, data_format=\"channels_last\"):\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(normalized_shape))\n        self.bias = nn.Parameter(torch.zeros(normalized_shape))\n        self.eps = eps\n        self.data_format = data_format\n        if self.data_format not in [\"channels_last\", \"channels_first\"]:\n            raise NotImplementedError \n        self.normalized_shape = (normalized_shape, )\n    \n    def forward(self, x):\n        if self.data_format == \"channels_last\":\n            return F.layer_norm(x, self.normalized_shape, self.weight, self.bias, self.eps)\n        elif self.data_format == \"channels_first\":\n            u = x.mean(1, keepdim=True)\n            s = (x - u).pow(2).mean(1, keepdim=True)\n            x = (x - u) \/ torch.sqrt(s + self.eps)\n            x = self.weight[:, None, None] * x + self.bias[:, None, None]\n            return x\n\n\nmodel_urls = {\n    \"convnext_tiny_1k\": \"https:\/\/dl.fbaipublicfiles.com\/convnext\/convnext_tiny_1k_224_ema.pth\",\n    \"convnext_small_1k\": \"https:\/\/dl.fbaipublicfiles.com\/convnext\/convnext_small_1k_224_ema.pth\",\n    \"convnext_base_1k\": \"https:\/\/dl.fbaipublicfiles.com\/convnext\/convnext_base_1k_224_ema.pth\",\n    \"convnext_large_1k\": \"https:\/\/dl.fbaipublicfiles.com\/convnext\/convnext_large_1k_224_ema.pth\",\n    \"convnext_base_22k\": \"https:\/\/dl.fbaipublicfiles.com\/convnext\/convnext_base_22k_224.pth\",\n    \"convnext_large_22k\": \"https:\/\/dl.fbaipublicfiles.com\/convnext\/convnext_large_22k_224.pth\",\n    \"convnext_xlarge_22k\": \"https:\/\/dl.fbaipublicfiles.com\/convnext\/convnext_xlarge_22k_224.pth\",\n}\n\n@register_model\ndef convnext_tiny(pretrained=False, **kwargs):\n    model = ConvNeXt(depths=[3, 3, 9, 3], dims=[96, 192, 384, 768], **kwargs)\n    if pretrained:\n        url = model_urls['convnext_tiny_1k']\n        checkpoint = torch.hub.load_state_dict_from_url(url=url, map_location=\"cpu\", check_hash=True)\n        model.load_state_dict(checkpoint[\"model\"])\n    return model\n\n@register_model\ndef convnext_small(pretrained=False, **kwargs):\n    model = ConvNeXt(depths=[3, 3, 27, 3], dims=[96, 192, 384, 768], **kwargs)\n    if pretrained:\n        url = model_urls['convnext_small_1k']\n        checkpoint = torch.hub.load_state_dict_from_url(url=url, map_location=\"cpu\", check_hash=True)\n        model.load_state_dict(checkpoint[\"model\"])\n    return model\n\n@register_model\ndef convnext_base(pretrained=False, in_22k=False, **kwargs):\n    model = ConvNeXt(depths=[3, 3, 27, 3], dims=[128, 256, 512, 1024], **kwargs)\n    if pretrained:\n        url = model_urls['convnext_base_22k'] if in_22k else model_urls['convnext_base_1k']\n        checkpoint = torch.hub.load_state_dict_from_url(url=url, map_location=\"cpu\", check_hash=True)\n        model.load_state_dict(checkpoint[\"model\"])\n    return model\n\n@register_model\ndef convnext_large(pretrained=False, in_22k=False, **kwargs):\n    model = ConvNeXt(depths=[3, 3, 27, 3], dims=[192, 384, 768, 1536], **kwargs)\n    if pretrained:\n        url = model_urls['convnext_large_22k'] if in_22k else model_urls['convnext_large_1k']\n        checkpoint = torch.hub.load_state_dict_from_url(url=url, map_location=\"cpu\", check_hash=True)\n        model.load_state_dict(checkpoint[\"model\"])\n    return model\n\n@register_model\ndef convnext_xlarge(pretrained=False, in_22k=False, **kwargs):\n    model = ConvNeXt(depths=[3, 3, 27, 3], dims=[256, 512, 1024, 2048], **kwargs)\n    if pretrained:\n        url = model_urls['convnext_xlarge_22k'] if in_22k else model_urls['convnext_xlarge_1k']\n        checkpoint = torch.hub.load_state_dict_from_url(url=url, map_location=\"cpu\", check_hash=True)\n        model.load_state_dict(checkpoint[\"model\"])\n    return model","1ea22635":"# Load the pretrained resnet50 from a file\n\ndef load_model(path):\n\n    model = torch.load(path)\n\n    # Disable gradients on all model parameters to freeze the weights\n    for param in model.parameters():\n        param.requires_grad = False\n\n    # Replace the final fully connected resnet layer with a 2 fc layer network and sigmoid output\n    # Also use the annotations\n    model.head = nn.Sequential(nn.Linear(1024, 256),\n                             nn.ReLU(),\n                             nn.Linear(256, 1),\n                             nn.Sigmoid())\n\n\n\n    for param in model.head.parameters():\n        param.requires_grad = True\n\n    # Unfreeze the last stage\n    for param in model.stages[3].parameters():\n        param.requires_grad = True\n    \n    return model\n\nmodel = load_model(f'{model_dir}convnext_base_pretrained_v2.pt')","9863551e":"print(model)","b01d4e73":"def initialize_optimizer(starting_lr, lambd):\n    \n    # Loss function using MSE (the goal)\n    criterion = nn.MSELoss(reduction='sum')\n\n    #Adam with L2 regularization\n    optimizer = optim.AdamW(model.parameters(), lr=starting_lr, weight_decay=lambd)\n\n    # Learning rate decay\n    scheduler = optim.lr_scheduler.MultiStepLR(optimizer, milestones = [1, 2, 6], gamma=0.5)\n    \n    return criterion, optimizer, scheduler\n\ncriterion, optimizer, scheduler = initialize_optimizer(0.000025, 100)","07c5c256":"# Test out the forward pass on a single batch\n\nimages, annotations, scores = next(iter(cv_dataloaders[0][1]))\nwith torch.no_grad():\n    train_loss = 0.0\n    output = model(images)*100 # convert sigmoid output to pawpularity scale\n    loss = criterion(output, scores)\n    RMSE = math.sqrt(loss.item()\/global_batch_size)\n\nprint(scores.dtype)\nprint(output.dtype)\nprint('Starting Prediction: ', torch.mean(output))\nprint('Starting RMSE: ', RMSE)\nprint('Prediction Standard Deviation: ', torch.std(output))","843d416f":"# Training and validation loop\n\ndef train_validation_loop(fold, model, train_loader, valid_loader, train_on_gpu, n_epochs=6):\n\n    if train_on_gpu:\n        model.cuda()\n\n    valid_loss_min = np.Inf # track change in validation loss\n\n    train_losses, valid_losses = [], []\n\n    for epoch in range(1, n_epochs+10):\n\n        start = time.time()\n        current_lr = scheduler.get_last_lr()[0]\n\n        # keep track of training and validation loss\n        train_loss = 0.0\n        valid_loss = 0.0\n\n        # Stop training the convolutional layers after a certain point\n        #if epoch > 4:\n        #    for param in model.layer3.parameters():\n        #        param.requires_grad = False\n        \n        #if epoch > 5:\n        #    for param in model.layer4.parameters():\n        #        param.requires_grad = False\n\n        ###################\n        # train the model #\n        ###################\n        # put in training mode (enable dropout)\n        model.train()\n        for images, annotations, scores in train_loader:\n            # move tensors to GPU if CUDA is available\n            if train_on_gpu:\n                images, annotations, scores = images.cuda(), annotations.cuda(), scores.cuda()\n            # clear the gradients of all optimized variables\n            optimizer.zero_grad()\n            # forward pass: compute predicted outputs by passing inputs to the model\n            output = model(images)*100 # multiply by 100 the sigmoid output to 0-100 pawpularity scale\n            # print(output.dtype)\n            # print(scores.dtype)\n            # calculate the batch loss\n            loss = criterion(output, scores)\n            # backward pass: compute gradient of the loss with respect to model parameters\n            loss.backward()\n            # perform a single optimization step (parameter update)\n            optimizer.step()\n            # update training loss\n            train_loss += loss.item()\n\n        ######################    \n        # validate the model #\n        ######################\n        # eval mode (no dropout)\n        model.eval()\n        with torch.no_grad():\n            for images, annotations, scores in valid_loader:\n                # move tensors to GPU if CUDA is available\n                if train_on_gpu:\n                    images, annotations, scores = images.cuda(), annotations.cuda(), scores.cuda()\n                # forward pass: compute predicted outputs by passing inputs to the model\n                output = model(images)*100 # multiply by 100 the sigmoid output to 0-100 pawpularity scale\n                # calculate the batch loss\n                loss = criterion(output, scores)\n                # update average validation loss \n                valid_loss += loss.item()\n\n        # calculate RMSE\n        train_loss = math.sqrt(train_loss\/len(train_loader.sampler))\n        valid_loss = math.sqrt(valid_loss\/len(valid_loader.sampler))\n\n        train_losses.append(train_loss)\n        valid_losses.append(valid_loss)\n\n        # increment learning rate decay\n        scheduler.step()\n\n        # print training\/validation statistics \n        # print(f'Epoch: {e}, {float(time.time() - start):.3f} seconds, lr={optimizer.lr}')\n        print('Epoch: {}, time: {:.1f}s, lr: {:.7f} \\tTraining Loss: {:.3f} \\tValidation Loss: {:.3f}'.format(\n            epoch, float(time.time() - start), current_lr, train_loss, valid_loss))\n\n        # save model if validation loss has decreased\n        if valid_loss <= valid_loss_min:\n            print('Validation loss decreased ({:.3f} --> {:.3f}).  Saving model ...'.format(\n            valid_loss_min,\n            valid_loss))\n            model_name = f'{working_dir}pawpularity_best_model_fold{fold}.pt'\n            torch.save(model.state_dict(), model_name)\n            valid_loss_min = valid_loss\n        \n        # Stop early if the min epochs is satisfied and score isn't improving\n        if valid_loss > valid_loss_min+0.04 and epoch >= n_epochs:\n            break\n    \n    # Plot the losses\n    fig = plt.figure()\n    ax = plt.axes()\n    ax.plot(list(range(0, len(train_losses))), train_losses[0:])\n    ax.plot(list(range(0, len(valid_losses))), valid_losses[0:]);\n    print(f'best score: {valid_loss_min}')\n        \n    return (model_name, valid_loss_min)","1dbced8c":"# check if CUDA is available and set the training device\n\ntrain_on_gpu = torch.cuda.is_available()\ndevice = torch.cuda.get_device_name()\n\nif not train_on_gpu:\n    print('CUDA is not available.  Training on CPU ...')\nelse:\n    print(f'CUDA is available!  Training on GPU {device}...')","ea26e8eb":"# Train for all of the cv folds\n\ncv_folds = 10\nepochs = 7\nstarting_lr = 0.00005\nlambd = 7 # Regularization \n\ncv_dataloaders = get_cv_dataloaders(augmented_data=augmented_data, \n                                    base_transform_data=base_transform_data,\n                                    folds=cv_folds, \n                                    cv_shuffle=True)\n\n# Skip training in the submission notebook\n'''\nsaved_models = []\n\nfor i, (train_loader, valid_loader) in enumerate(cv_dataloaders):\n    print('Starting Fold', i)\n    \n    # Reset the model and schedulers for each new dataset\n    model = load_model(f'{model_dir}convnext_base_pretrained.pt')\n    criterion, optimizer, scheduler = initialize_optimizer(starting_lr=starting_lr, lambd=lambd)\n    \n    # Run the training loop and add the best model's filepath\n    saved_models.append(train_validation_loop(i, model, train_loader, valid_loader, train_on_gpu, n_epochs=epochs))\n    \n    #if i >= 2:\n    #   break\n    print('\\n')\n'''","420c1772":"# Load the best performing model from the first fold\nmodel = load_model(f'{model_dir}convnext_base_pretrained_v2.pt')\nmodel.load_state_dict(torch.load(f'{weights_dir}pawpularity_best_model_fold4.pt'))\n\nif train_on_gpu:\n    model.cuda()","704f365f":"# get the distribution of predictions\n\npredictions = []\nscore_list = []\n\nmodel.eval()\nwith torch.no_grad():\n    for images, annotations, scores in cv_dataloaders[4][1]: # fold 4, validation dataset\n        # move tensors to GPU if CUDA is available\n        if train_on_gpu:\n            images, annotations, scores = images.cuda(), annotations.cuda(), scores.cuda()\n        # forward pass: compute predicted outputs by passing inputs to the model\n        output = model(images)*100\n        predictions.extend(list(output.cpu().detach().numpy().reshape(len(output),)))\n        score_list.extend(list(scores.cpu().detach().numpy().reshape(len(scores),)))\n        \n\npreds_df = pd.DataFrame({'preds': predictions})\npreds_df.describe()","6b780f28":"# Manually Check RMSE\n\ndiffs = np.array(score_list) - np.array(predictions)\nprint(math.sqrt((diffs @ diffs)\/len(cv_dataloaders[4][1].sampler)))","3368a905":"# Histogram of validation predictions - if this is too narrow that's an issue\n\nn, bins, patches = plt.hist(predictions, 50, density=True, facecolor='g', alpha=0.75)\n\nplt.xlabel('Pawpularity')\nplt.ylabel('Frequency')\nplt.title('Predicted Pawpularity Histogram')\nplt.xlim(0, 100)\nplt.ylim(0, .2)\nplt.grid(True)\nplt.show()","08e734bf":"output_plot = model(images).cpu()*100\nimages, annotations, scores = images.cpu(), annotations.cpu(), scores.cpu()","fe2121bd":"# plot the images in the batch, along with the corresponding labels and predictions\n\nfig = plt.figure(figsize=(20, 10))\n# display 20 images\nfor idx in np.arange(12):\n    ax = fig.add_subplot(3, 4, idx+1, xticks=[], yticks=[])\n    im_convert(images[idx])\n    ax.set_title(f'Act: {round(scores[idx].item())} Pred: {round(output_plot[idx].item())}')","ed4ecfe9":"test_df = pd.read_csv(f'{data_dir}test.csv')\ntest_df.head(10)","dd3f68bc":"class PawpularityTestDataset(Dataset):\n    \"\"\"Dataset connecting dog images to the score and annotations\"\"\"\n\n    def __init__(self, csv_file, img_dir, transform=transforms.ToTensor()):\n        \"\"\"\n        Args:\n            csv_file (string): Path to the csv file with annotations.\n            img_dir (string): Directory with all the images.\n            transform (callable, optional): Optional transform to be applied\n                on a sample.\n        \"\"\"\n\n        self.annotations_csv = pd.read_csv(csv_file)\n        self.img_dir = img_dir\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.annotations_csv)\n\n    def __getitem__(self, idx):\n        if torch.is_tensor(idx):\n            idx = idx.tolist()\n\n        img_name = os.path.join(self.img_dir,\n                                self.annotations_csv.iloc[idx, 0])\n\n        # load each image in PIL format for compatibility with transforms\n        image = PIL.Image.open(img_name + '.jpg')\n\n        annotations = np.array(self.annotations_csv.iloc[idx, 1:13])\n        annotations = annotations.astype('float')\n\n        # Apply the transforms\n        image = self.transform(image)\n\n        sample = [image, annotations]\n        return sample","4cda6c0a":"## Load the test dataset (careful to use validation transforms without img augmentation)\n\ntest_data = PawpularityTestDataset(f'{data_dir}test.csv', f'{data_dir}test', transform=img_transforms_valid)\n\nbatch_size = min(len(test_data), global_batch_size)\n\ntest_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, num_workers=workers) ","6a9c447a":"# Step through with a reasonable batch size and build up the output dataset\n\n\ndef test_predictions(model, test_loader, model_path, test_df):\n    \n    # Load a set of trained weights into the model\n    model.load_state_dict(torch.load(model_path))\n    \n    # Move to gpu if necessary\n    if train_on_gpu:\n        model.cuda()\n    \n    # Put in evaluation mode\n    model.eval()\n    \n    # Run predictions for each batch in the test dataset\n    preds = []\n    for images, annotations in test_loader:\n        # move tensors to GPU if CUDA is available\n        if train_on_gpu:\n            images, annotations = images.cuda(), annotations.cuda()\n        # get predictions\n        test_pred = model(images)*100\n        # add predictions from the current batch\n        preds.extend(list(test_pred.cpu().detach().numpy().reshape(len(test_pred),)))\n\n    # Get the list of image filenames from the test annotations file\n    img_names = np.array(test_df.iloc[:, 0].values)\n    \n    # Round the outputs\n    preds = [round(x, 2) for x in preds]\n    \n    # return a tuple with the image names and model predictions\n    return (img_names, np.array(preds))","4b9ac728":"print('Using pre uploaded saved models')\nmodel_list = [(f'{weights_dir}pawpularity_best_model_fold0.pt', 17.75550977922519),\n              (f'{weights_dir}pawpularity_best_model_fold1.pt', 17.055042532540423),\n              (f'{weights_dir}pawpularity_best_model_fold2.pt', 17.723917203277402),\n              (f'{weights_dir}pawpularity_best_model_fold3.pt', 17.506054498891437),\n              (f'{weights_dir}pawpularity_best_model_fold4.pt', 16.693078011850073),\n              (f'{weights_dir}pawpularity_best_model_fold5.pt', 18.116734056509916),\n              (f'{weights_dir}pawpularity_best_model_fold6.pt', 17.94325075614874),\n              (f'{weights_dir}pawpularity_best_model_fold7.pt', 17.84976622654215),\n              (f'{weights_dir}pawpularity_best_model_fold8.pt', 17.56859209356934),\n              (f'{weights_dir}pawpularity_best_model_fold9.pt', 18.29225659309586)]\nmodel_list","ba0e0291":"# Set up the model structure\nmodel = load_model(f'{model_dir}convnext_base_pretrained_v2.pt')\n\n# Iterate through saved models and calculate predictions for each one on the test data\noutputs = []\nfor best_model, rmse in model_list:\n    img_names, preds = test_predictions(model, test_loader, best_model, test_df)\n    outputs.append(preds)\n    \n# Get image names\nimg_list = img_names\n\n# Take the average of the outputs from each model's preds\nmean_outputs = np.mean(np.stack(outputs, axis=1), axis=1)\n\n# Join into a dataset\noutput_df = pd.DataFrame({'Id': img_list,'Pawpularity' : mean_outputs})\noutput_df.head(10)","a65588f5":"# Write the output in the required format\noutput_df.to_csv('submission.csv', index=False)","f8f9513a":"**Look at some images**","7c44e5dd":"### Load Dependencies","b59a83b5":"**Look at the annotations**","4a429633":"**Load and check out the datasets and create kfold dataloaders**","50da04f1":"## Pawpularity ConvNext Transfer Learning Approach in Pytorch\n\nThis notebook implements the new convnext architecture ([A ConvNet for the 2020s](https:\/\/arxiv.org\/abs\/2201.03545)) with pre-trained weights, replacing the output layer and re-training the last stage of convlutional layers to predict a pawpularity score bounded between 0 and 100.  Everything is implemented in pytorch.  Training is also reasonably fast with only ~7 epochs per fold necessary to get to maximum performance on the validation set.  \n\n- A custom pytorch dataset class is implemented to attach scores to each image file, as well as the annotations.  Currently only the images are being used to train the model.  \n- The model is a convnext architecture where the final fully connected layer is replaced with two fully connected layers and output 1 value.\n- The model starts with pretrained weights for all of the convolutional layers, and the final set of layers in the model (stage 3) is unfrozen to allow it to learn a feature representation more specifi to this task. \n- The final activation is sigmoid to bound the output between 1 and 0, and output is multiplied by 100 in the training loop to give it a bounded output between 0 and 100 which matches the range of pawpularity scores.  \n- The model is optimising for mean squared error(MSE), using Adam with weight decay to reduce overfitting.\n- This uses 10 folds, and trains 10 models, keeping the weights from epoch that performed the best on the validation set for each.  The test dataset is predicted by running it through each of these 10 models and taking the average of the score predictions.\n- The final competition evaluation metric is the square root of MSE or \n$ \\textrm{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2} $\n","b5f8e597":"### Diagnostics and performance","a5548768":"### Train the model","a5e2597a":"**Load the model, replace the output layer, and choose which layers to freeze\/train**\n\nI'm replacing the final fully connected layer of the convnext model with my own feed forward network, and also unfreezing the last stage of convnext to allow weights there to be trained.  Currently I'm not using the annotations in the model at all. ","8b7d0616":"**Skip the training step in this notebook and use model files already uploaded**\n\nThis makes submission much faster.  ","c2b674b2":"**Define global image transforms**","cc167d0b":"**Custom dataset class to attach annotations and scores to the images**\n\nThis is a critical step to attach the classes and annotations to the image files and allow this to be put into a pytorch dataloader.  ","4c1e3b8a":"### Show examples of images and predicted vs. actual scores","7cb43972":"**Downloading the pretrained model**\n\nTo access the pretrained model in a kaggle notebook, download it via pytorch on a local notebook, save the model using torch.save.  Then upload it to your kaggle notebook as a dataset which you can then load via torch.load without having to connect to the internet.\n\nFor the convnext model, I downloaded the [model definition](https:\/\/github.com\/facebookresearch\/ConvNeXt\/blob\/dc7823d8a2ecc554fcd57ff6cdb7748011bcdedd\/models\/convnext.py) (which includes url paths for pretrained weights) to a file, and uploaded this as a dataset to use in my kaggle notebook.  \n\nI'm also using the a [timm dataset](https:\/\/www.kaggle.com\/kozodoi\/timm-pytorch-image-models) to load the timm module which is required for ConvNext.  ","fd58c7a5":"### Load and Explore data","fd4ff283":"**Model training loop**\n\nRun the training and validation steps for a fixed number of epochs, and save the model anytime the validation loss decreases.  ","a55ff3c1":"### Use the model to predict the test dataset\n\nDo inference on the best model from each fold, and then take the prediction for each value in the test set.  ","f3b4fd3f":"### Set up the model structure"}}