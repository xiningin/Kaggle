{"cell_type":{"bb2d9274":"code","61b273a1":"code","d7aec3e4":"code","2fdbb840":"code","b7c0a339":"code","21e48266":"code","55c8a82f":"code","d1e66683":"code","84bf0d37":"code","fadb32d6":"code","8ca3d149":"code","d7fa0646":"code","d11dd102":"code","1fe52d8f":"code","f4a52a9f":"code","e960f99a":"code","f57b9abc":"code","a14fa0c0":"code","6700adc9":"code","55962cfb":"code","bdba97e9":"code","41e31305":"code","d30a7296":"code","e1485999":"code","df7b9150":"code","ce873fc5":"code","efea18a3":"code","d50056b0":"code","ace7e8d5":"code","79d97d37":"code","a03abd38":"code","2c43a635":"code","cd782ca6":"code","6b9e0474":"code","685cd8da":"code","408f3d51":"code","03ef8e29":"code","c38b5abe":"code","8064bc48":"code","282bdf7a":"code","3f2ef52b":"code","18c4f444":"code","4350857c":"code","3c4b9b32":"code","9f8ddba3":"code","30bdb3f5":"code","9246c9d8":"code","64c200be":"code","94a29dae":"code","407013a5":"code","b67aff61":"code","f58c6b00":"code","e8c94807":"code","f200d194":"code","0064d44c":"code","731399e7":"code","bae66927":"code","b6d091c1":"code","bbafff6e":"code","c903e9d9":"code","55217437":"code","2e33185d":"code","a64c3638":"code","285bd8bb":"code","d66c8bd8":"code","0a249d72":"code","ffc6aa59":"code","2c1c372c":"code","731c2bdd":"code","68c75a7a":"code","fbe56ef9":"code","47433816":"code","58ffba08":"code","e21a6ad9":"code","9ba0fb52":"code","95a3f3bc":"code","654b1b2f":"code","f05c1ddc":"code","073a76ba":"code","65007b03":"code","bec2df0b":"code","c6670c8a":"code","0e3df30b":"code","a564bbcf":"code","d12df213":"code","f5ccb614":"code","42e256de":"code","bff2ddad":"code","320a82c7":"code","95373a4f":"code","040cad1f":"code","1b377dc9":"markdown","6f262887":"markdown","bff7107d":"markdown","55d9e0cc":"markdown","df626a20":"markdown","9af9415c":"markdown","21cff65d":"markdown","d99a3f50":"markdown","3f82a017":"markdown","65a7e445":"markdown","84aa5d03":"markdown","1485d103":"markdown","3a5deb2e":"markdown","77e62af8":"markdown","9bc1ad58":"markdown","85e95109":"markdown","9c0448fd":"markdown","70178c80":"markdown","2e571ac9":"markdown","56bae189":"markdown","32ff8489":"markdown","9a677076":"markdown","24424234":"markdown","79d8788d":"markdown","c2394dc4":"markdown"},"source":{"bb2d9274":"!pip install hvplot","61b273a1":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport hvplot.pandas","d7aec3e4":"ted = pd.read_csv(\"\/kaggle\/input\/ted-talks\/ted_main.csv\")\nted.head()","2fdbb840":"# rows, columns\nted.shape","b7c0a339":"# object columns are usually strings, but can also be arbitrary Python objects (lists, dictionaries)\nted.dtypes","21e48266":"ted.info()","55c8a82f":"# count the number of missing values in each column\nted.isna().sum()","d1e66683":"# fill the miising values. In the general case if the missing values type is numerique\n# we fill it with mean values. if its an object we fill missing values with mode.\nted['speaker_occupation'] = ted.speaker_occupation.fillna(ted.speaker_occupation.mode()[0])","84bf0d37":"ted.isna().sum()","fadb32d6":"ted.describe()","8ca3d149":"ted.hvplot.hist(subplots=True, height=250, width=250, shared_axes=False, value_label='Rate').cols(4)","d7fa0646":"plt.figure(figsize=(12, 10))\nsns.heatmap(ted.corr(), annot=True)","d11dd102":"ted.hvplot.hist(y='languages', height=350, width=450)","1fe52d8f":"# sort by the number of first-level comments, though this is biased in favor of older talks\nted.sort_values('comments').tail()","f4a52a9f":"# creating a new column 'comments_per_view'\nted['comments_per_view'] = ted.comments \/ ted.views\n\n# interpretation: for every view of the same-sex marriage talk, there are 0.002 comments\nted.sort_values('comments_per_view').tail()","e960f99a":"# make this more interpretable by inverting the calculation\nted['views_per_comment'] = ted.views \/ ted.comments\n\n# interpretation: 1 out of every 450 people leave a comment\nted.sort_values('views_per_comment').head()","f57b9abc":"ted.hvplot.line(y='views', height=350, width=550)","a14fa0c0":"# line plot is not appropriate here (use it to measure something over time)\nted.hvplot.hist(y='comments', bins=50, height=350, width=550)","6700adc9":"# check how many observations we removed from the plot\nted[ted.comments >= 1000].shape","55962cfb":"ted[ted.comments < 1000].hvplot.hist(y='comments', bins=50, height=350, width=550)","bdba97e9":"# event column does not always include the year\nted.event.sample(10)","41e31305":"# dataset documentation for film_date says \"Unix timestamp of the filming\"\nted.film_date.head()","d30a7296":"# results don't look right\npd.to_datetime(ted.film_date).head()","e1485999":"# now the results look right\npd.to_datetime(ted.film_date, unit='s').head()","df7b9150":"ted['film_datetime'] = pd.to_datetime(ted.film_date, unit='s')\n\n# verify that event name matches film_datetime for a random sample\nted[['event', 'film_datetime']].sample(5)","ce873fc5":"# new column uses the datetime data type (this was an automatic conversion)\nted.dtypes","efea18a3":"# datetime columns have convenient attributes under the dt namespace\nted.film_datetime.dt.year.head()","d50056b0":"# count the number of talks each year using value_counts()\nted.film_datetime.dt.year.value_counts()","ace7e8d5":"# points are plotted and connected in the order you give them to pandas\nted.film_datetime.dt.year.value_counts().hvplot.line(height=350, width=550)","79d97d37":"# need to sort the index before plotting\nted.film_datetime.dt.year.value_counts().sort_index().hvplot.line(height=350, width=550)","a03abd38":"# we only have partial data for 2017\nted.film_datetime.max()","2c43a635":"def clean_event(event):\n    years = list(range(1990, 2018, 1))\n    \n    for year in years:\n        if str(year) in event:\n            return f\"TED_{year}\"\n    else:\n        return event","cd782ca6":"print(ted.event.nunique())\nprint(ted.event.apply(clean_event).nunique())","6b9e0474":"ted['event'] = ted.event.apply(clean_event)","685cd8da":"# count the number of talks (great if you value variety, but they may not be great talks)\nted.event.value_counts().head()","408f3d51":"# use views as a proxy for \"quality of talk\"\nted.groupby('event').views.mean().head()","03ef8e29":"# find the largest values, but we don't know how many talks are being averaged\nted.groupby('event').views.mean().sort_values().tail()","c38b5abe":"# show the number of talks along with the mean (events with the highest means had only 1 or 2 talks)\nted.groupby('event').views.agg(['count', 'mean']).sort_values('mean').tail()","8064bc48":"# calculate the total views per event\nted.groupby('event').views.agg(['count', 'mean', 'sum']).sort_values('sum').tail()","282bdf7a":"ted.event.value_counts()[:20].hvplot.barh()","3f2ef52b":"ted.groupby('event').views.mean().sort_values(ascending=False)[:20].hvplot.barh()","18c4f444":"# previously, users could tag talks on the TED website (funny, inspiring, confusing, etc.)\nted.ratings.head()","4350857c":"# two ways to examine the ratings data for the first talk\nted.loc[0, 'ratings']\nted.ratings[0]","3c4b9b32":"# this is a string not a list\ntype(ted.ratings[0])","9f8ddba3":"# convert this into something useful using Python's ast module (Abstract Syntax Tree)\nimport ast\n\n# literal_eval() allows you to evaluate a string containing a Python literal or container\nast.literal_eval('[1, 2, 3]')\n\n# if you have a string representation of something, you can retrieve what it actually represents\ntype(ast.literal_eval('[1, 2, 3]'))","30bdb3f5":"# unpack the ratings data for the first talk\nast.literal_eval(ted.ratings[0])","9246c9d8":"# now we have a list (of dictionaries)\ntype(ast.literal_eval(ted.ratings[0]))","64c200be":"# define a function to convert an element in the ratings Series from string to list\ndef str_to_list(ratings_str):\n    return ast.literal_eval(ratings_str)","94a29dae":"# test the function\nstr_to_list(ted.ratings[0])","407013a5":"# Series apply method applies a function to every element in a Series and returns a Series\nted.ratings.apply(str_to_list).head()","b67aff61":"# lambda is a shorter alternative\nted.ratings.apply(lambda x: ast.literal_eval(x)).head()","f58c6b00":"# an even shorter alternative is to apply the function directly (without lambda)\nted.ratings.apply(ast.literal_eval).head()","e8c94807":"ted['ratings_list'] = ted.ratings.apply(lambda x: ast.literal_eval(x))","f200d194":"# check that the new Series looks as expected\nted.ratings_list[0]","0064d44c":"# each element in the Series is a list\ntype(ted.ratings_list[0])","731399e7":"# data type of the new Series is object\nted.ratings_list.dtype","bae66927":"# object is not just for strings\nted.dtypes","b6d091c1":"ted.ratings_list[0]","bbafff6e":"# start by building a simple function\ndef get_num_ratings(list_of_dicts):\n    return list_of_dicts[0]","c903e9d9":"# pass it a list, and it returns the first element in the list, which is a dictionary\nget_num_ratings(ted.ratings_list[0])","55217437":"# modify the function to return the vote count\ndef get_num_ratings(list_of_dicts):\n    return list_of_dicts[0]['count']","2e33185d":"# pass it a list, and it returns a value from the first dictionary in the list\nget_num_ratings(ted.ratings_list[0])","a64c3638":"# modify the function to get the sum of count\ndef get_num_ratings(list_of_dicts):\n    num = 0\n    for d in list_of_dicts:\n        num = num + d['count']\n    return num","285bd8bb":"# looks about right\nget_num_ratings(ted.ratings_list[0])","d66c8bd8":"# check with another record\nted.ratings_list[1]","0a249d72":"# looks about right\nget_num_ratings(ted.ratings_list[1])","ffc6aa59":"# apply it to every element in the Series\nted.ratings_list.apply(get_num_ratings).head()","2c1c372c":"# another alternative is to use a generator expression\nsum((d['count'] for d in ted.ratings_list[0]))","731c2bdd":"# use lambda to apply this method\nted.ratings_list.apply(lambda x: sum((d['count'] for d in x))).head()","68c75a7a":"# another alternative is to use pd.DataFrame()\npd.DataFrame(ted.ratings_list[0])['count'].sum()","fbe56ef9":"# use lambda to apply this method\nted.ratings_list.apply(lambda x: pd.DataFrame(x)['count'].sum()).head()","47433816":"ted['num_ratings'] = ted.ratings_list.apply(get_num_ratings)","58ffba08":"# do one more check\nted.num_ratings.describe()","e21a6ad9":"# \"Funny\" is not always the first dictionary in the list\nted.ratings_list.head()","9ba0fb52":"# check ratings (not ratings_list) to see if \"Funny\" is always a rating type\nted.ratings.str.contains('Funny').value_counts()","95a3f3bc":"# write a custom function\ndef get_funny_ratings(list_of_dicts):\n    for d in list_of_dicts:\n        if d['name'] == 'Funny':\n            return d['count']","654b1b2f":"# examine a record in which \"Funny\" is not the first dictionary\nted.ratings_list[3]","f05c1ddc":"# check that the function works\nget_funny_ratings(ted.ratings_list[3])","073a76ba":"# apply it to every element in the Series\nted['funny_ratings'] = ted.ratings_list.apply(get_funny_ratings)\nted.funny_ratings.head()","65007b03":"# check for missing values\nted.funny_ratings.isna().sum()","bec2df0b":"ted['funny_rate'] = ted.funny_ratings \/ ted.num_ratings","c6670c8a":"# \"gut check\" that this calculation makes sense by examining the occupations of the funniest talks\nted.sort_values('funny_rate').speaker_occupation.tail(20)","0e3df30b":"# examine the occupations of the least funny talks\nted.sort_values('funny_rate').speaker_occupation.head(20)","a564bbcf":"# calculate the mean funny rate for each occupation\nted.groupby('speaker_occupation').funny_rate.mean().sort_values().tail()","d12df213":"# however, most of the occupations have a sample size of 1\nted.speaker_occupation.describe()","f5ccb614":"# count how many times each occupation appears\nted.speaker_occupation.value_counts()","42e256de":"# value_counts() outputs a pandas Series, thus we can use pandas to manipulate the output\noccupation_counts = ted.speaker_occupation.value_counts()\ntype(occupation_counts)","bff2ddad":"# show occupations which appear at least 10 times\noccupation_counts[occupation_counts >= 10].hvplot.barh()","320a82c7":"# save the index of this Series\ntop_occupations = occupation_counts[occupation_counts >= 5].index\ntop_occupations","95373a4f":"# filter DataFrame to include only those occupations\nted_top_occupations = ted[ted.speaker_occupation.isin(top_occupations)]\nted_top_occupations.shape","040cad1f":"# redo the previous groupby\nted_top_occupations.groupby('speaker_occupation').funny_rate.mean().sort_values()[:20].hvplot.barh()","1b377dc9":"After filtering the data we lose only a small amount of data. This process is called excluding outliers.","6f262887":"## \ud83e\uddfe **Lessons:**\n\n> 1. Write your code in small chunks, and check your work as you go\n> 2. Lambda is best for simple functions","bff7107d":"## \ud83e\uddfe **Lessons:**\n\n> 1. Read the documentation\n> 2. Use the datetime data type for dates and times\n> 3. Check your work as you go\n> 4. Consider excluding data if it might not be relevant","55d9e0cc":"# \ud83e\uddee Count the total number of ratings received by each talk\n\n**Bonus exercises:**\n\n> - for each talk, calculate the percentage of ratings that were negative\n> - for each talk, calculate the average number of ratings it received per day since it was published","df626a20":"## \u2714\ufe0f Step 1: Count the number of funny ratings","9af9415c":"From the heatmap, the number of views correlates well with language and comments.","21cff65d":"## \ud83e\uddfe **Lessons:**\n\n> 1. Check your assumptions about your data\n> 2. Check whether your results are reasonable\n> 3. Take advantage of the fact that pandas operations often output a DataFrame or a Series\n> 4. Watch out for small sample sizes\n> 5. Consider the impact of missing data\n> 6. Data scientists are hilarious","d99a3f50":"# \ud83d\udce4 Unpack the ratings data","3f82a017":"## \u2714\ufe0f Step 3: Analyze the funny rate by occupation","65a7e445":"## \ud83e\uddfe **Lessons:**\n\n> 1. Pay attention to data types in pandas\n> 2. Use apply any time it is necessary","84aa5d03":"## \ud83e\uddfe **Lessons:**\n\n> 1. Choose your plot type based on the question you are answering and the data type(s) you are working with\n> 2. Use pandas one-liners to iterate through plots quickly\n> 3. Try modifying the plot defaults\n> 4. Creating plots involves decision-making","1485d103":"## \ud83e\uddfe **Lessons:**\n\n> 1. Consider the limitations and biases of your data when analyzing it\n> 2. Make your results understandable","3a5deb2e":"## \u2714\ufe0f Step 5: Re-analyze the funny rate by occupation (for top occupations only)","77e62af8":"We can't rely on `event` Feature, because most of the events don't have a year.","9bc1ad58":"# \ud83d\udcc9 Plot the number of talks that took place each year","85e95109":"## \u2714\ufe0f Step 2: Calculate the percentage of ratings that are funny","9c0448fd":"# \ud83d\udcbb Data Science Best Practices with pandas\n---\n# \ud83d\udcdd Introduction to the TED Talks dataset\n\n> This is a kernel follows the talk from `PyCon 2019` of `Kevin Markham`.\n> - \ud83d\udccd PyCon: [Full Conference](https:\/\/www.youtube.com\/watch?v=ZjrUmNq41Eo&t=3778s)\n> - \ud83d\udccd Youtube channel: [Data School](https:\/\/www.youtube.com\/user\/dataschool)\n---\n\n# \ud83d\udd0d Exploratory Data Analysis\n> Exploratory Data Analysis is all about answering a specific question. In this notebook we will try to answer the following questions:\n> 1. Which talks provoke the most online discussion?\n> 2. What were the \"best\" events in TED history to attend?\n> 3. Which occupations deliver the funniest TED talks on average?","70178c80":"# \ud83e\udd47 What were the \"best\" events in TED history to attend?","2e571ac9":"## \ud83d\udccc Limitations of this approach: \n> 1. sub comments (nested comments).\n> 2. how long its being online.\n\n## \ud83d\udccf To correct this behavior, one solution is to normalise comments by views.","56bae189":"# \ud83d\udcca Visualize the distribution of comments","32ff8489":"# \ud83d\udce2 Which talks provoke the most online discussion?","9a677076":"## \u2714\ufe0f Step 4: Focus on occupations that are well-represented in the data","24424234":"# \u274c Missing Values\n> In `machine learning`, we need to handle `missing values`. There are many types of missing values:\n> - `Standard Missing Values`: These are missing values that Pandas can detect.\n> - `Non-Standard Missing Values`: Sometimes it might be the case where there\u2019s missing values that have different formats.\n> - `Unexpected Missing Values`: For example, if our feature is expected to be a string, but there\u2019s a numeric type, then technically this is also a missing value.\n\n---\n\n> It\u2019s important to understand these different types of missing data from a `statistics point of view`. The type of missing data will influence how you deal with filling in the missing values.\n> - Sometimes you\u2019ll simply want to delete those rows, other times you\u2019ll replace them.\n> - A very common way to replace missing values is using a median (for objects) or mean (for numerique values). \n\n---\n\n> But those are weak appraoch, some times we need `domain knowledge` about the data and `statical study` to fill the missing values.","79d8788d":"## \ud83e\uddfe **Lessons:**\n\n> 1. Think creatively for how you can use the data you have to answer your question\n> 2. Watch out for small sample sizes","c2394dc4":"# \ud83e\udd39 Which occupations deliver the funniest TED talks on average?\n\nBonus exercises:\n\n> - for each talk, calculate the most frequent rating\n> - for each talk, clean the occupation data so that there's only one occupation per talk"}}