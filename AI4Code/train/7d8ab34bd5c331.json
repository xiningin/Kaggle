{"cell_type":{"e52a1bbd":"code","61a16dfc":"code","addfb592":"code","a4205f58":"code","bc5b3911":"code","e34b8dc5":"code","64fcf3fa":"code","b777d559":"code","d8238997":"code","3d04d040":"code","8f61b64b":"code","e02348a3":"code","6daa8592":"code","24a33518":"code","8d54518f":"code","23164c96":"code","ecf8aebb":"code","aacd554e":"markdown","f95f42c8":"markdown","da01b8b2":"markdown","67c5ff7e":"markdown","a33a6f9b":"markdown","10e40081":"markdown","b2ead8f2":"markdown","fa6dbdd1":"markdown","7f639a24":"markdown","6e4e7ab1":"markdown","0bf444ee":"markdown","969aeea5":"markdown","c5cd739f":"markdown","c0a1d420":"markdown","e520eed9":"markdown","166ac8cb":"markdown","5ba5f703":"markdown","fc82b3f0":"markdown","bc1c0e71":"markdown","61fbe794":"markdown","2dad62b8":"markdown","79ad7ae9":"markdown","9a1e6873":"markdown","2c3c0731":"markdown","0bbead87":"markdown","a038f467":"markdown","cf9d6b4d":"markdown","20983aef":"markdown"},"source":{"e52a1bbd":"import pandas as pd\nimport numpy as np\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport bq_helper\nfrom bq_helper import BigQueryHelper\n# https:\/\/www.kaggle.com\/sohier\/introduction-to-the-bq-helper-package\nstackOverflow = bq_helper.BigQueryHelper(active_project=\"bigquery-public-data\",\n                                   dataset_name=\"stackoverflow\")\ndef del_order_mark(df):\n    new_Reputation = []\n    for i in range(len(df)): # delete the order mark in \"repulation\"\n        new_Reputation.append(df['Reputation'][i][1:])\n    df.Reputation = new_Reputation\n    return df","61a16dfc":"bq_assistant = BigQueryHelper(\"bigquery-public-data\", \"stackoverflow\")\nbq_assistant.list_tables()","addfb592":"# How many users are questioner ?\nquery1 = '''\nselect count(distinct q.owner_user_id)\nfrom `bigquery-public-data.stackoverflow.posts_questions` q\nleft join `bigquery-public-data.stackoverflow.posts_answers` a\non q.owner_user_id = a.owner_user_id\nwhere a.owner_user_id is null\n'''\n\n# How many users are answerer ?\nquery2 = '''\nselect count(distinct a.owner_user_id)\nfrom `bigquery-public-data.stackoverflow.posts_answers` a\nleft join `bigquery-public-data.stackoverflow.posts_questions` q\non a.owner_user_id = q.owner_user_id\nwhere q.owner_user_id is null\n'''\n\n# How many users are question-and-answerer ?\nquery3='''\nselect count( distinct q.owner_user_id)\nfrom `bigquery-public-data.stackoverflow.posts_questions` q\ninner join `bigquery-public-data.stackoverflow.posts_answers` a \non q.owner_user_id = a.owner_user_id\n'''\n\n# How many users are do-nothinger ?\nquery4='''\nselect count(id)\nfrom `bigquery-public-data.stackoverflow.users` u\nleft join (\n    select distinct owner_user_id\n    from `bigquery-public-data.stackoverflow.posts_answers`\n    union all\n    select distinct owner_user_id\n    from `bigquery-public-data.stackoverflow.posts_questions`) b\non u.id = b.owner_user_id\nwhere b.owner_user_id is null\n'''\n\n# Execute the queries\nquestioner = stackOverflow.query_to_pandas_safe(query1).iat[0,0]\nanswerer = stackOverflow.query_to_pandas_safe(query2).iat[0,0]\nquestion_and_answerer = stackOverflow.query_to_pandas_safe(query3).iat[0,0]\ndo_nothinger = stackOverflow.query_to_pandas_safe(query4).iat[0,0]\nnum_user = stackOverflow.query_to_pandas_safe(\"select count(*) from `bigquery-public-data.stackoverflow.users` \").iat[0,0]\n\n# Show result\nuser_type_df = pd.DataFrame({\"Number of Users\": [questioner, answerer, question_and_answerer, do_nothinger, num_user]})\nuser_type_df[\"Percentage(%)\"] = round(user_type_df[\"Number of Users\"] \/ num_user * 100,2)\nuser_type_df.index = [\"Questioner\", \"Answerer\", \"Question-and-answerer\", \"Do-nothinger\", \"Total\"]\ndisplay(user_type_df)","a4205f58":"query1 = '''\nSELECT\n    rep_range AS Reputation,\n    COUNT(*) AS Users,\n    SUM(asked) AS Asked_question,\n    SUM(unanswered) AS Unanswered_question,\n    SUM(answered) AS Contributed_answer\nFROM(\n    SELECT \n        CASE\n            WHEN reputation BETWEEN 1 AND 100 THEN '11- 100'\n            WHEN reputation BETWEEN 101 AND 1000 THEN '2101- 1000'\n            WHEN reputation BETWEEN 1001 AND 10000 THEN '31001- 10000'\n            WHEN reputation BETWEEN 10001 AND 100000 THEN '410001- 100000'\n            WHEN reputation > 100000 THEN '5> 100000'\n        END AS rep_range,\n        asked,\n        answered,\n        unanswered\n    FROM(    \n        SELECT id AS user_id, reputation, asked, answered, unanswered\n        FROM `bigquery-public-data.stackoverflow.users` u\n        LEFT JOIN(\n            SELECT owner_user_id AS user_id, COUNT(*) AS asked\n            FROM `bigquery-public-data.stackoverflow.posts_questions`\n            GROUP BY user_id\n        ) q ON u.id = q.user_id\n        LEFT JOIN(\n            SELECT owner_user_id AS user_id, COUNT(*) AS answered\n            FROM `bigquery-public-data.stackoverflow.posts_answers`\n            GROUP BY user_id\n        ) a ON u.id = a.user_id\n        LEFT JOIN(\n            SELECT owner_user_id AS user_id, COUNT(*) AS unanswered \n            FROM (\n                SELECT owner_user_id\n                FROM `bigquery-public-data.stackoverflow.posts_questions`\n                WHERE answer_count=0\n            )\n            GROUP BY user_id\n        ) ua ON u.id = ua.user_id\n    )\n)\nGROUP BY rep_range\nORDER BY rep_range\n'''\n\nprofile = del_order_mark(stackOverflow.query_to_pandas_safe(query1))\nprofile.index = [\"Level 1\", \"Level 2\", \"Level 3\", \"Level 4\", \"Level 5\"]\ndisplay(profile)\n\n# normalize the profile\nprofile_per = profile.copy()\nprofile_per.Users = round(100 * profile_per.Users \/ profile_per.Users.sum(),5)\nprofile_per.Asked_question = round(100 * profile_per.Asked_question \/ profile_per.Asked_question.sum(),2)\nprofile_per.Unanswered_question = round(100 * profile_per.Unanswered_question \/ profile_per.Unanswered_question.sum(),2)\nprofile_per.Contributed_answer = round(100 * profile_per.Contributed_answer \/ profile_per.Contributed_answer.sum(),)\nprofile_per.rename(columns = {'Users':'Users(%)','Asked_question':'Asked_question(%)','Unanswered_question':'Unanswered_question(%)','Contributed_answer':'Contributed_answer(%)'},inplace=True)\ndisplay(profile_per)","bc5b3911":"query1 = '''\nselect a.rep_range as Reputation, (num_ans + num_que) as num_post\nfrom(\n    select rep_range, sum(num_ans) as num_ans\n    from(\n        select \n            case\n                when reputation between 1 and 100 then '11- 100'\n                when reputation between 101 and 1000 then '2101- 1000'\n                when reputation between 1001 and 10000 then '31001- 10000'\n                when reputation between 10001 and 100000 then '410001- 100000'\n                when reputation > 100000 THEN '5> 100000'\n            end as rep_range,\n            num_ans\n        from(\n        select reputation, num_ans\n        from `bigquery-public-data.stackoverflow.users`\n        inner join(\n            select owner_user_id, count(*) as num_ans\n            from `bigquery-public-data.stackoverflow.posts_answers`\n            group by owner_user_id)\n        on id = owner_user_id)\n        )\n    group by rep_range) a\ninner join(\n    select rep_range, sum(num_que) as num_que\n    from(\n        select \n            case\n                when reputation between 1 and 100 then '11- 100'\n                when reputation between 101 and 1000 then '2101- 1000'\n                when reputation between 1001 and 10000 then '31001- 10000'\n                when reputation between 10001 and 100000 then '410001- 100000'\n                when reputation > 100000 THEN '5> 100000'\n            end as rep_range,\n            num_que\n        from(\n        select reputation, num_que\n        from `bigquery-public-data.stackoverflow.users`\n        inner join(\n            select owner_user_id, count(*) as num_que\n            from `bigquery-public-data.stackoverflow.posts_questions`\n            group by owner_user_id)\n        on id = owner_user_id)\n        )\n    group by rep_range) b\non a.rep_range = b.rep_range\norder by Reputation\n'''\nnum_post = del_order_mark(stackOverflow.query_to_pandas_safe(query1))\nnum_post.index = [\"Level 1\", \"Level 2\", \"Level 3\", \"Level 4\", \"Level 5\"]\nnum_post[\"per_user\"] = num_post.num_post \/ profile.Users \nnum_post[\"per_user_per_month\"] = num_post[\"per_user\"] \/ (11 * 12+5) # the oldest post is 2008.7.31, the latest is 2019.12.1\ndisplay(num_post)","e34b8dc5":"query1 = \"\"\"SELECT\n  EXTRACT(YEAR FROM creation_date) AS Year,\n  COUNT(*) AS Number_of_Questions,\n  ROUND(100 * SUM(IF(answer_count > 0, 1, 0)) \/ COUNT(*), 1) AS Percent_Questions_with_Answers\nFROM\n  `bigquery-public-data.stackoverflow.posts_questions`\nGROUP BY\n  Year\nORDER BY\n  Year;\n        \"\"\"\nanswer_rate = stackOverflow.query_to_pandas_safe(query1)\ndisplay(answer_rate)\nfig = plt.figure()\nplt.xticks(fontsize=14)\nplt.yticks(fontsize=14)\nplt.grid()\nplt.rc('grid', linestyle=\"dotted\", color='gray')\nplt.xlabel('Year', fontsize=15)\nplt.ylabel('Answer rate', fontsize=15)\nplt.plot(answer_rate['Year'], answer_rate['Percent_Questions_with_Answers'],'ro-')\nfig.set_size_inches(16, 8)","64fcf3fa":"profile_per[\"Answer_rate(%)\"] = round((profile[\"Asked_question\"] - profile[\"Unanswered_question\"]) \/ profile[\"Asked_question\"] * 100, 2)\ndisplay(profile_per)","b777d559":"# the distribution of comment number\n\nquery1 = '''\nselect comment_count, count(*) as num\nfrom `bigquery-public-data.stackoverflow.posts_questions`\nwhere answer_count = 0\ngroup by comment_count\norder by comment_count asc\n'''\n\nquery2 = '''\nselect comment_count, count(*) as num\nfrom `bigquery-public-data.stackoverflow.posts_questions`\nwhere answer_count > 0\ngroup by comment_count\norder by comment_count asc\n'''\n\n\ncomment_count_unanswered = stackOverflow.query_to_pandas_safe(query1)\ncomment_count_answered = stackOverflow.query_to_pandas_safe(query2)\n\n\nlabelsize = 15\nplt.figure(figsize=(16,8))\nplt.xticks(fontsize=14)\nplt.yticks(fontsize=14)\n\nx1 = comment_count_answered.comment_count\ny1 = comment_count_answered.num\n\nx2 = comment_count_unanswered.comment_count\ny2 = comment_count_unanswered.num\n\nplt.plot(x1,y1, label=\"answered question\",linestyle='--')\nplt.plot(x2,y2, label=\"unanswered question\")\n# plt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.xlabel('Comment count',fontsize = labelsize)\nplt.ylabel('Number of question',fontsize = labelsize)\nplt.grid(True)\nplt.legend(fontsize=15)\nplt.title(\"Frequency distribution of comment count\", fontsize=labelsize)\n","d8238997":"labelsize = 15\nplt.figure(figsize=(16,8))\nplt.xticks(fontsize=14)\nplt.yticks(fontsize=14)\n\nx1 = comment_count_answered.comment_count\ny1 = np.cumsum(comment_count_answered.num)\ny1 = 100 * y1 \/ y1.max()\n\nx2 = comment_count_unanswered.comment_count\ny2 = np.cumsum(comment_count_unanswered.num)\ny2 = 100 * y2 \/ y2.max()\n\nplt.plot(x1,y1, label=\"answered question\",linestyle='--')\nplt.plot(x2,y2, label=\"unanswered question\")\n# plt.xscale(\"log\")\n# plt.yscale(\"log\")\nplt.xlabel('Comment count',fontsize = labelsize)\nplt.ylabel('CDF(%)',fontsize = labelsize)\nplt.grid(True)\nplt.legend(fontsize=15)\nplt.title(\"Cumulative distribution function of comment count\", fontsize=labelsize)","3d04d040":"# Reputation of the user making comments to answered questions\nquery1 = '''\nselect \n    case\n        when uc.reputation between 1 and 100 then '11- 100'\n        when uc.reputation between 101 and 1000 then '2101- 1000'\n        when uc.reputation between 1001 and 10000 then '31001- 10000'\n        when uc.reputation between 10001 and 100000 then '410001- 100000'\n        when uc.reputation > 100000 THEN '5> 100000'\n    end as Reputation,\n    sum(uc.num) as num\nfrom(    \nselect u.reputation, count(*) as num\nfrom `bigquery-public-data.stackoverflow.users` u\ninner join(\n    select c.user_id\n    from `bigquery-public-data.stackoverflow.comments` c\n    inner join (\n        select id from `bigquery-public-data.stackoverflow.posts_questions`\n        where answer_count > 0) q\n    on post_id = q.id)\non id = user_id\ngroup by reputation\norder by reputation asc) uc\ngroup by Reputation\norder by Reputation\n'''\n\ntemp = stackOverflow.query_to_pandas(query1)\ntemp = del_order_mark(temp)\n\nlabels = temp.Reputation\nsizes = round(100 * temp.num \/ temp.num.sum(),2)\ncolors = ['#ff9999','#66b3ff','#99ff99','#ffcc99','#ff6666']\nexplode = (0.05,0.05,0.05,0.05,0.05)\n\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, colors = colors, labels=labels, autopct='%1.1f%%', startangle=90, explode=explode)\nax1.axis('equal')  \nplt.tight_layout()\nplt.title(\"Reputation of the user making comments to answered questions\", fontsize = 14)\n","8f61b64b":"# Reputation of the user making comments to unanswered questions\nquery2 = '''\nselect \n    case\n        when uc.reputation between 1 and 100 then '11- 100'\n        when uc.reputation between 101 and 1000 then '2101- 1000'\n        when uc.reputation between 1001 and 10000 then '31001- 10000'\n        when uc.reputation between 10001 and 100000 then '410001- 100000'\n        when uc.reputation > 100000 THEN '5> 100000'\n    end as Reputation,\n    sum(uc.num) as num\nfrom(    \nselect u.reputation, count(*) as num\nfrom `bigquery-public-data.stackoverflow.users` u\ninner join(\n    select c.user_id\n    from `bigquery-public-data.stackoverflow.comments` c\n    inner join (\n        select id from `bigquery-public-data.stackoverflow.posts_questions`\n        where answer_count = 0) q\n    on post_id = q.id)\non id = user_id\ngroup by reputation\norder by reputation asc) uc\ngroup by Reputation\norder by Reputation\n'''\n\ntemp2 = stackOverflow.query_to_pandas(query2)\ntemp2 = del_order_mark(temp2)\n\nlabels = temp2.Reputation\nsizes = round(100 * temp2.num \/ temp2.num.sum(),2)\ncolors = ['#ff9999','#66b3ff','#99ff99','#ffcc99','#ff6666']\nexplode = (0.05,0.05,0.05,0.05,0.05)\n\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, colors = colors, labels=labels, autopct='%1.1f%%', startangle=90, explode=explode)\nax1.axis('equal')  \nplt.tight_layout()\nplt.title(\"Reputation of the user making comments to unanswered questions\", fontsize = 14)","e02348a3":"# pick out top 25 tags\nquery1 = '''\nselect tag_name, count\nfrom `bigquery-public-data.stackoverflow.tags`\norder by count desc\nlimit 25\n'''\n\n# pick out top 50 tags\nquery2 = '''\nselect tag_name, count\nfrom `bigquery-public-data.stackoverflow.tags`\norder by count desc\nlimit 50\n'''\n\n# pick out top 100 tags\nquery3 = '''\nselect tag_name, count\nfrom `bigquery-public-data.stackoverflow.tags`\norder by count desc\nlimit 100\n'''\n\ntop_25_tag = stackOverflow.query_to_pandas(query1)\ntop_50_tag = stackOverflow.query_to_pandas(query2)\ntop_100_tag = stackOverflow.query_to_pandas(query3)\n\ntop_25_list = top_25_tag.tag_name.tolist()\ntop_50_list = top_50_tag.tag_name.tolist()\ntop_100_list = top_100_tag.tag_name.tolist()\n\n\n# The following command are used for SQL query (I know it is kinda brute force......)\ntop_25_query_command = ''\nfor s in top_25_list:\n    top_25_query_command += 'tags like \\'%%|%s|%%\\' or tags like \\'%%|%s\\' or tags like \\'%s|%%\\' or ' % (s,s,s)\n\ntop_50_query_command = ''\nfor s in top_50_list:\n    top_50_query_command += 'tags like \\'%%|%s|%%\\' or tags like \\'%%|%s\\' or tags like \\'%s|%%\\' or ' % (s,s,s)\n\ntop_100_query_command = ''\nfor s in top_100_list:\n    top_100_query_command += 'tags like \\'%%|%s|%%\\' or tags like \\'%%|%s\\' or tags like \\'%s|%%\\' or ' % (s,s,s)\n\n    \n# Delete the ' or ' at the end of the command\ntop_25_query_command = top_25_query_command[:-4]\ntop_50_query_command = top_50_query_command[:-4]\ntop_100_query_command = top_100_query_command[:-4]\n  \n    \n# Feel free to have a look at the query statement\n# print(top_25_query_command,end='\\n\\n')\n# print(top_50_query_command,end='\\n\\n')\n# print(top_100_query_command,end='\\n\\n')\n\n\nquery_top_25 = '''\nselect count(*) as num\nfrom `bigquery-public-data.stackoverflow.posts_questions`\nwhere  %s''' % top_25_query_command\n\nquery_top_50 = '''\nselect count(*) as num\nfrom `bigquery-public-data.stackoverflow.posts_questions`\nwhere  %s''' % top_50_query_command\n\nquery_top_100 = '''\nselect count(*) as num\nfrom `bigquery-public-data.stackoverflow.posts_questions`\nwhere  %s''' % top_100_query_command\n\nquery_num_question='''\nselect count(*) as num\nfrom `bigquery-public-data.stackoverflow.posts_questions`\n'''\ntop_25_num = stackOverflow.query_to_pandas(query_top_25).iat[0,0]\ntop_50_num = stackOverflow.query_to_pandas(query_top_50).iat[0,0]\ntop_100_num = stackOverflow.query_to_pandas(query_top_100).iat[0,0]\nnum_question = stackOverflow.query_to_pandas(query_num_question).iat[0,0]\n\ntemp = pd.DataFrame({\"Top_N_tag\":[25,50,100], \"Number of Relevant Questions\":[top_25_num, top_50_num, top_100_num]})\ntemp[\"Percentage(%)\"] = round(temp[\"Number of Relevant Questions\"] \/ num_question * 100, 2)\ndisplay(temp)","6daa8592":"print('Top 25 tags: \\n',top_25_list)\n\n# Feel free to check out top 50 tags and top 100 tags\n# print('Top 50 tags: \\n',top_50_list)\n# print('Top 100 tags: \\n',top_100_list)","24a33518":"# ================= !!! NOTE !!! ==============\n# The code in this part is not efficient at all. \n# Running the code for the top 6 tags('javascript', 'java', 'c#', 'python', 'php','android') is okay \n# but doing it for all the top 25 tags is very time-consuming\n\nimport datetime\nfrom dateutil.relativedelta import *\n\n# tag_list = ['javascript', 'java', 'c#', 'python', 'php', 'android', 'jquery', 'html', 'c++', 'css', 'ios', 'mysql', 'sql', 'asp.net', 'r', 'c', 'arrays', 'ruby-on-rails', 'node.js', '.net', 'objective-c', 'json', 'sql-server', 'angularjs', 'swift']\ntag_list = ['javascript', 'java', 'c#', 'python', 'php','android']\n\nresult = pd.DataFrame()\ndate_string_list = []\n\nfor tag in tag_list:\n    start_date = datetime.datetime(2008,8,1)\n    end_date = datetime.datetime(2008,11,1)\n    final_date = datetime.datetime(2019,12,1)\n    print('Now working on %s ......'%tag)\n    \n    temp = []\n    while end_date < final_date:\n        start_date_string = start_date.strftime('%Y-%m-%d')\n        end_date_string = end_date.strftime('%Y-%m-%d')\n        \n        date_string_list.append(start_date_string)\n        \n        query = '''\n        select count(*) as num\n        from `bigquery-public-data.stackoverflow.posts_questions`\n        where (tags like '%%|%s|%%' or tags like '%%|%s' or tags like '%s|%%')\n        and date(creation_date) >= '%s' and date(creation_date) < '%s'\n        ''' % (tag, tag, tag,start_date_string ,end_date_string)\n        temp.append(stackOverflow.query_to_pandas(query).iat[0,0])\n        \n        start_date += relativedelta(months=+3)\n        end_date += relativedelta(months=+3)\n        \n    result[tag] = temp\nresult.index = date_string_list[:len(date_string_list) \/\/ len(tag_list)]\nprint('Complete')\n","8d54518f":"# Plot the topcial trend\n\nmatplotlib.style.use('default')\nlabelsize = 15\ntag_list = result.columns.tolist()\nx = result.index.tolist()\n\nNUM_COLORS = len(tag_list)\nLINE_STYLES = ['solid', 'dashed', 'dashdot', 'dotted']\nNUM_STYLES = len(LINE_STYLES)\n\ncm = plt.get_cmap('tab10')\nfig = plt.figure()\nax = fig.add_subplot(111)\nfig.set_size_inches(18.5, 10.5)\nfor i in range(NUM_COLORS):\n    lines = ax.plot(x,result[tag_list[i]])\n    lines[0].set_color(cm(i\/\/NUM_STYLES*float(NUM_STYLES)\/NUM_COLORS))\n    lines[0].set_linestyle(LINE_STYLES[i%NUM_STYLES])\n\nplt.setp(ax.xaxis.get_majorticklabels(), rotation=70 )\nplt.legend(fontsize=11.38)\nplt.grid(True)\nplt.title(\"Number of question of Top 25 tags\", fontsize=labelsize)\nplt.xlabel('time',fontsize = labelsize)\nplt.ylabel('Number of question',fontsize = labelsize)\nplt.savefig('Number of question of Top 25 tags c')","23164c96":"# plot percentage of each tag in every three months\nlabelsize = 15\n\ntag_list = result.columns.tolist()\nx = result.index.tolist()\nresult_new = result.div(result.sum(axis=1), axis=0) * 100 # normalize \n\nNUM_COLORS = len(tag_list)\nLINE_STYLES = ['solid', 'dashed', 'dashdot', 'dotted']\nNUM_STYLES = len(LINE_STYLES)\n\ncm = plt.get_cmap('tab10')\nfig = plt.figure()\nax = fig.add_subplot(111)\nfig.set_size_inches(18.5, 10.5)\nfor i in range(NUM_COLORS):\n\n    lines = ax.plot(x,result_new[tag_list[i]])\n    lines[0].set_color(cm(i\/\/NUM_STYLES*float(NUM_STYLES)\/NUM_COLORS))\n    lines[0].set_linestyle(LINE_STYLES[i%NUM_STYLES])\n\nplt.setp(ax.xaxis.get_majorticklabels(), rotation=70 )\nplt.legend(fontsize=11.38, bbox_to_anchor=(1, 1))\nplt.grid(True)\nplt.title(\"Percentage of question of Top 25 tags\", fontsize=labelsize)\nplt.xlabel('time',fontsize = labelsize)\nplt.ylabel('Percentage of question(%)',fontsize = labelsize)\nplt.savefig('Percentage of question of Top 25 tags')","ecf8aebb":"# ================= !!! NOTE !!! ==============\n# The code in this part is even less efficient than the previous part. \n# Running the code may run out of your quota of query in the current month\n# You may need more than one kaggle account to work out the complete result yourself\n# Or you can try impoving the code yourself. I am not really good at sql :p\n\nimport datetime\nfrom dateutil.relativedelta import *\n\n# tag_list = ['javascript', 'java', 'c#', 'python', 'php', 'android', 'jquery', 'html', 'c++', 'css', 'ios', 'mysql', 'sql', 'asp.net', 'r', 'c', 'arrays', 'ruby-on-rails', 'node.js', '.net', 'objective-c', 'json', 'sql-server', 'angularjs', 'swift']\ntag_list = ['javascript', 'java', 'c#', 'python', 'php','android']\n\nresult_var = pd.DataFrame()\ndate_string_list = []\n\nfor tag in tag_list:\n    start_date = datetime.datetime(2008,8,1)\n    end_date = datetime.datetime(2008,9,1)\n    final_date = datetime.datetime(2019,12,1)\n    print('Now working on %s ......'%tag)\n    \n    temp = []\n    while end_date < final_date:\n        start_date_string = start_date.strftime('%Y-%m-%d')\n        end_date_string = end_date.strftime('%Y-%m-%d')\n        \n        date_string_list.append(start_date_string)\n        \n        query = '''\n        select variance(num) as var\n        from(\n            select creation_date, count(*) as num\n            from(\n                select date(creation_date) as creation_date\n                from `bigquery-public-data.stackoverflow.posts_questions`\n                where (tags like '%%|%s|%%' or tags like '%%|%s' or tags like '%s|%%')\n                and date(creation_date) >= '%s' and date(creation_date) < '%s')\n            group by creation_date\n            )\n        ''' % (tag, tag, tag,start_date_string ,end_date_string)\n        temp.append(stackOverflow.query_to_pandas(query).iat[0,0])\n        \n        start_date += relativedelta(days=+7)\n        end_date += relativedelta(days=+7)\n        \n    result_var[tag] = temp\nresult_var.index = date_string_list[:len(date_string_list) \/\/ len(tag_list)]\nprint('Complete')\nresult_var.to_csv('result_var.csv')\nprint('Save Complete')","aacd554e":"[1] Asaduzzaman, M., Mashiyat, A.S., Roy, C.K. and Schneider, K.A., 2013, May. Answering questions about unanswered questions of stack overflow. In 2013 10th Working Conference on Mining Software Repositories (MSR) (pp. 97-100). IEEE.<br\/><br\/>\n[2]  Anderson, A., Huttenlocher, D., Kleinberg, J. and Leskovec, J., 2012, August. Discovering value from community activity on focused question answering sites: a case study of stack overflow. In Proceedings of the 18th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 850-858).<br\/><br\/>\n[3]  Cheng, J., Danescu-Niculescu-Mizil, C. and Leskovec, J., 2014, May. How community feedback shapes user behavior. In Eighth International AAAI Conference on Weblogs and Social Media.<br\/><br\/>\n[4]  Wang, S., Lo, D. and Jiang, L., 2013, March. An empirical study on developer interactions in StackOverflow. In Proceedings of the 28th Annual ACM Symposium on Applied Computing (pp. 1019-1024).<br\/><br\/>\n[5]  Movshovitz-Attias, D., Movshovitz-Attias, Y., Steenkiste, P. and Faloutsos, C., 2013, August. Analysis of the reputation system and user contributions on a question answering website: Stackoverflow. In 2013 IEEE\/ACM International Conference on Advances in Social Networks Analysis and Mining (ASONAM 2013) (pp. 886-893). IEEE.<br\/><br\/>\n[6]  Barua, A., Thomas, S.W. and Hassan, A.E., 2014. What are developers talking about? an analysis of topics and trends in stack overflow. Empirical Software Engineering, 19(3), pp.619-654.","f95f42c8":"![variance_based_event_detection+mechanism.jpg](attachment:variance_based_event_detection+mechanism.jpg)","da01b8b2":"The result shows that 60% answered questions are from level 3 and 4 users and 76% unanswered questions are from level 1 and 2 users.\n<br\/><br\/>level 1 user has most question (33.69%), but least amount of answered questions (9.56%) are originally raised by them. Besides, almost half of the unanswered questions are raised by level 1 user. \n<br\/><br\/>Level 2 user has similar amount of questions as level 1 user, but the relative amount of answered question of them is 10% higher than that of level user and the unanswered questions from them is 16% less. One could assume that level 2 user are better at asking question and getting themselves understood.\n<br\/><br\/>In fact, it is noticeable that questions from higher-level user are more likely to be answered (as answer rate increases from level 1 user to level 5 user). This is reasonable as higher-level user is supposed to be asking a clear question, which increase the possibility of the question to be answered.\n<br\/><br\/>Although there are already many guidelines of how to ask a good question in SO, they do not seem to work well since level 1 and 2 users are still the main source of unanswered questions. Thus, to improve the answer rate, SO could make special guideline exclusively for those novice users.\n","67c5ff7e":"# 2. QUSESTION-BASED ANALYSIS\nQuestion is no doubt one of the most important components of SO. 86% questions on SO are answered in the past 11 years, which is relatively good, but the answer rate of each year is decreasing as shown below","a33a6f9b":"Based on the table above, only the top 25 tags are discussed in this part as they covered more than 60% questions and increasing the number of tags does not make much difference. By the way, the top 25 tags are listed below","10e40081":"## 1.3 User Posting Frequency\nBased on the result from last section, reputation of the user does have an impact on his post. This section is trying to answer the question as \u201cHow often do users of each level post?\u201d The result is shown below","b2ead8f2":"### What is the reputation of the user making comments to answered and unanswered questions? ","fa6dbdd1":"Based on the graph above, javascript used to be the most popular tag. Python has been receiving more and more attention over the years and surpassed javascript on 08-01-2018, becoming the hottest topic.<br\/><br\/>\nBesides, Php curve, c# curve and android curve share similar shape. This indicates that the three tags are often used to label a same question, which is reasonable as it is very possible to run into a problem associated with php, c# and android at the same time when developing an android-based web application.<br\/><br\/>\nOne should be aware that the growing number of questions is the result of two factors: one is the growing number of users and the other is the tag itself becoming more and more popular. In order to cancel the influence brought by growing number of users and focus on the tag itself, the same result is normalized by the total number of questions within each 3 months and shown below","7f639a24":"[Complete topical trend for all 25 tags](https:\/\/imgur.com\/airHRBw)","6e4e7ab1":"# 1.USER-BASED ANALYSIS\n## 1.1 User Type\nUsers can be classified based on their behavior in SO. There are four types of user defined in this section, i.e. questioner, answerer, question-and-answerer, and do-nothinger.<br\/> * Questioner is defined to be the user who only asks questions. <br\/> * Answerer refers to the user only answering questions. <br\/>*  Question-and-answerer is the user who both ask and answer questions. <br\/> * Do-Nothinger, as the name suggests, never asks or answers any question. <br\/><br\/>Please note that do-nothingers are not really doing nothing in SO, they do not ask or answer question, but they would vote on other questions or answers. The distribution of the four types of users is shown below","0bf444ee":"The window is fixed to be three-month long where the number of questions of each tag is counted. The window starts from 08-01-2008 and move 3 months forward at a time until it reaches 12-01-2019. The topical trend obtained by this method is shown below","969aeea5":"Level 1 user is the largest group in SO. They are asking most questions but provide least amount of answers. However, the amount of questions from this group (34.60%) is roughly the same as that of level 2 user (31.01%) whose amount is far fewer than level 1 user. Therefore, it is possible that most level 1 users are do-nothingers. In a word, level 1 users ask the most but answer the least.\n<br\/><br\/>There are only 1.67288% professional users (level 3, 4, 5) in SO. The amount of question from these groups are much fewer than that of level 1 and 2 users but they provide more than 70% answers. In a word, professional users ask the least but answer the most.\n<br\/><br\/>Level 2 user has almost the same amount of question as level 1 user, but they provide more answers than that of level 1 user. Thus, level 2 user has the characteristic of both level 1 user and professional user. In other words, they ask fairly a lot of questions like level 1 user but also provide many answers like professional user.\n","c5cd739f":"[Complete result for all top 25 tags here](https:\/\/imgur.com\/ClH6pjb)","c0a1d420":"[Complete result for all top 25 tags here](https:\/\/imgur.com\/yewJEfk)","e520eed9":"Now it is clear that c# used to be even more popular than any nowadays popular language, which is not easy to be noticed before normalization. However, developers\u2019 focus is gradually changing from c# to javascript and python possibly because dynamic language like javacript and python are easier to learn and use.<br\/><br\/>\nJava curve is steady over the years with its relative number remaining around 10%. This suggests that java is always an important topic for developers. However, c is not the same fortunate as java, which has been decreasing from 15% to 1.7%.\n\n(By the way, the topical trend for all the top 25 tags is shown below. You may need more than one account to work out the same result yourself)","166ac8cb":"### I dont really have good analysis for the following part. I will just leave the code without analysis","5ba5f703":"# 3.TAG-BASED ANALYSIS\nWhen asking a question, the questioner can choose up to 5\ntags to label the question. A tag is a word or phrase that\ndescribes the topic of the question, which is a mean of\nconnecting experts with questions they will be able to\nanswer by sorting questions into specific, well-defined\ncategories. Thus, tag can be used as an indicator of what\ndevelopers care about.\n\n## 3.1 Topical Trend\nThere are more than 50,000 tags in SO. Some tags like\njavascript are very popular among developer while the other\nreceive much less attention. The number of questions related\nto the top 25, 50 and 100 tags are shown below","fc82b3f0":"It is similar with the sliding time window schema as in the previous part. The time window is 1 month long where instead of counting the amount of questions of each tag, the variance of the amount of question is computed. The time window is moving forward 1 week at a time with 2 weeks overlapping with the previous window. The event is supposed to be detected at the time when there is a variance peak. The result is shown below","bc1c0e71":"# ABSTRACT\nStack Overflow (SO) is a community-based question answering service that targets developers and software engineers and has achieved significant success. This notebook explored the characteristics of SO in terms of its users, questions and tags with the data provided. The main findings of this work include the polarization of SO users, the question-answering pyramid of SO and the topical trend in the last decade.\n\n### NOTE: Kaggle is updating the data. Your result of running the code could be different","61fbe794":"To reflect the topical trend over the 11 years, a sliding time\nwindow schema shown below is used","2dad62b8":"For javascript, the strongest peak is around the May and June in 2015 probably because at that time an important framework for javascript called Polymer is released by google, and in the following month ECMAScript 6 is also released, which is a standard for scripting language like javascript.<br\/><br\/>\nPython curve has many prominent peaks which could be the turning point where python receives more attention. However, it is difficult to find out what events cause the variance peaks. There are thousands of hundreds of questions within each time window, which is infeasible for me alone to summarize the questions based on their semantic.<br\/><br\/>\nThis event-detecting algorithm is simple and intuitive, but it just tells us there should be an event or some events. In fact, it is very difficult to find out which event(s) lead to the variance peak because on the one hand, it is tedious to manually summarize the question based on their semantic and developing a program to automate this process would be extremely challenging. On the other hand, we do not know beforehand the variance is the result of a single strong event or multiple weak events. To interpret the result requires the knowledge out o data analysis, so this notebook just ends up here without any further exploration.","79ad7ae9":"# Reference","9a1e6873":"It is helpful to know the source of answered and unanswered question or, in other words, \u201cWhere are the answered and unanswered questions from?\u201d\nThe relative amount of answered and unanswered question from each level of user is shown below\n","2c3c0731":"The result is surprising in terms of the percentage of do-nothinger. There are 61.55% users being inactive all the time never asking or answering any question whereas only 38.46% active users have asked or answered at least one question. One possible explanation of the fact that most users are inactive is that for most users they can always find similar questions in SO, which results in no need for them to post a new question. On the other hand, they are not professional enough to provide answers to other questions, so they are eventually doing nothing. \n<br\/><br\/>However, SO is still successful even though there are only relatively small part of users being active. The posting frequency of them is expected to be high enough to cancel the negative impact brought by inactive users. The posting frequency will be discussed later\n","0bbead87":"## 4.2 Variation-based event detection\nBased on the result in the last section, some nowadays popular tags were not the same popular in the past. That means some events must have happened where those tags gain their popularity. This is the motivation of this section, to detect the event that makes a change. \n<br\/><br\/>If some event happens, for example python 3.0 is released, the amount of python questions is expected to be much more than before as python 3.0 is not compatible with its older version. After some time, users have run out of the question related to this event so that the amount of python question should return to normal level. In other words, the variance of the amount of the question is supposed to be higher than usual when an event happens. This is the key assumption of the variance-based event detection algorithm employed in this section. The mechanism of it is shown below","a038f467":"Although level 1 user is the largest group in SO, they post far less often than any other group. This verifies the assumption that most level 1 users are do-nothingers.\n<br\/><br\/>Level 5 user stands out from the table as each user has more than 3429 posts on average, which is 925 times greater than the average, and the posting frequency is 913 times higher than the average. This is good news to SO community because they post very often (almost 1 post \/ day) to help less professional user with their questions.\n\n## 1.4 Summary\nBased on the observation of this part, we can conclude that users of SO community are highly polarized in the sense that: 1) In terms of user type, there are 38% doers but 62% do-nothingers; 2) More than 90% users are novice user while there are only 1.7% professional users; 3) Tiny part of users (level 5 users) are posting much frequently than other users.\n","cf9d6b4d":"![time_window_schema.jpg](attachment:time_window_schema.jpg)","20983aef":"## 1.2 User Reputation\nThe three most important activities in SO are asking, answering, and editing. A user gains reputation when his post is voted up or the suggested edit is accepted by other users. Basically, the more reputation a user has, the more professional he is.\n<br\/><br\/>In this section, every user is labeled as level 1, level 2, level 3, level 4, and level 5 if his reputation is in the range of 1-100, 101-1000, 1001-10000, 10001-10000 or >100000. The level of the user is expected to has an effect on the relative number of the question and answer of that group. The result is shown in Table 2.2\n"}}