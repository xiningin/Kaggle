{"cell_type":{"9b349f7d":"code","7f16bbf6":"code","88fa187a":"code","8123b290":"code","fef3c295":"code","7587df84":"code","5de55133":"code","12996321":"code","af34b19a":"code","7356cf39":"code","ab77ac9e":"code","f66513d8":"code","37055891":"code","5f3cf93a":"code","ea730f39":"code","a9012b74":"code","9b71de51":"code","1b261618":"code","c14439ec":"code","4811839c":"code","6aeceda4":"code","2c69459a":"code","2e9e3a73":"code","9e9bd6d8":"code","5282c807":"code","b97f0c24":"code","87b667fa":"code","b426422d":"code","1affcb74":"code","8546e26c":"code","df39155f":"code","d309fb0d":"code","ce9ea92a":"code","f4aff948":"code","5cf82c1a":"code","c96f8b2e":"code","d56c955b":"code","ccbbdd8f":"code","d8c577e1":"code","771b7a98":"code","714abf11":"code","0fd1cbec":"code","3bfd2241":"code","af57c2fe":"code","0d58744a":"code","4ce8d3b6":"code","2b3b7efe":"code","9d6b3ac5":"code","330b6209":"code","fe0421b8":"code","b9f9793a":"code","18502aec":"code","069bf7d9":"code","adc7636c":"code","ce75bec7":"code","4ed86790":"code","664a5dcd":"code","5cf0c3a7":"code","a6be393a":"code","c87dcfe2":"code","c77d02e1":"code","471f0fc5":"code","6e14bf9e":"code","5ba93713":"code","a9637c4f":"code","2c7194f0":"code","09bb7d89":"code","12d0be8e":"code","8f847eab":"code","1e0fcb3d":"code","ff35ed97":"code","5543d41a":"code","bfcb773f":"code","0c5cd99b":"code","8f992250":"code","8195b5e4":"code","a14e77a6":"code","7d70cc02":"code","83718e32":"code","369f5c97":"markdown","2f52720b":"markdown","3d3df961":"markdown","54c56079":"markdown","2cfa3c79":"markdown","e8c4e76f":"markdown","659d314a":"markdown","7c2470fa":"markdown","306cb6c6":"markdown","47365c9f":"markdown","0dd4b225":"markdown","5724267b":"markdown","6f4d8e98":"markdown","84fa9e88":"markdown","167a8bb5":"markdown","f81cdd9b":"markdown","73f5e7b3":"markdown","7e27251d":"markdown","6c153077":"markdown","fe126486":"markdown","bbeb7b34":"markdown","c9e1fea9":"markdown","b10d2bca":"markdown","71732b06":"markdown","ea4737c8":"markdown","64ca97c2":"markdown","586f2049":"markdown","f75e7f0d":"markdown","f400670e":"markdown","8a0d824c":"markdown","93f191cb":"markdown","f035e811":"markdown"},"source":{"9b349f7d":"import pandas as pd\nimport os\nimport numpy as np\nimport random\n\nfrom matplotlib import pyplot as plt\n\nfrom math import radians, cos, sin, asin, sqrt\n\n#Nicer style :)\nplt.style.use('seaborn')\n\nimport ssl\nssl._create_default_https_context = ssl._create_unverified_context","7f16bbf6":"os.listdir('..\/input')","88fa187a":"#Load dataset\ntrain = pd.read_csv('..\/input\/train.csv', nrows=800_000)","8123b290":"# Drop rows which contain NaN values\ntrain = train.dropna()\n# Drop wrong fare rows. Minimum amount is 2.50 (http:\/\/www.nyc.gov\/html\/tlc\/html\/passenger\/taxicab_rate.shtml)\ntrain = train[train['fare_amount'] > 2] \n# Must have  between 0, 5 (+1 child)\n# https:\/\/www1.nyc.gov\/nyc-resources\/faq\/484\/how-many-passengers-are-allowed-in-a-taxi\ntrain = train[(train['passenger_count'] > 0)  & (train['passenger_count'] < 6)]","fef3c295":"train.head()","7587df84":"#work in a copy\ntrain2 = train.copy()","5de55133":"\"\"\"\n    Auxiliar function to calculate distance between two coordinates.\n    You could also install harvesine python package.\n    Returns distance in kilometers.\n    \n    Found on StackOverflow\n\"\"\"\ndef haversine(lon1, lat1, lon2, lat2):\n    # Convert decimal degrees to radians \n    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])\n\n    # Haversine formula \n    dlon = lon2 - lon1 \n    dlat = lat2 - lat1 \n    a = sin(dlat\/2)**2 + cos(lat1) * cos(lat2) * sin(dlon\/2)**2\n    c = 2 * asin(sqrt(a)) \n    r = 6371 # Probed radius of earth in kilometers.\n    return c * r","12996321":"#Convert \"objects\" to \"datetime\"\ntrain2['key'] = pd.to_datetime(train['key'])\ntrain2['pickup_datetime'] = pd.to_datetime(train['key'])","af34b19a":"train2.dtypes","7356cf39":"#Free memory\ndel(train)","ab77ac9e":"ax = train2.plot.scatter(x ='pickup_longitude', y = 'pickup_latitude', s=10)\ntrain2.plot.scatter(x ='dropoff_longitude', y = 'dropoff_latitude', color='Red', s=9, ax=ax)","f66513d8":"train2.describe()","37055891":"#Limit to the New York area.\ntrain2 = train2[(train2['pickup_latitude'] < 41.1) & (train2['pickup_latitude'] > 40)]\ntrain2 = train2[(train2['dropoff_latitude'] < 41.1) & (train2['dropoff_latitude'] > 40)]\ntrain2 = train2[(train2['pickup_longitude'] < -50) & (train2['pickup_longitude'] > - 80)]\ntrain2 = train2[(train2['dropoff_longitude'] < -50) & (train2['dropoff_longitude'] > - 80)]","5f3cf93a":"ax = train2.plot.scatter(x ='pickup_longitude', y = 'pickup_latitude', s=9)\ntrain2.plot.scatter(x ='dropoff_longitude', y = 'dropoff_latitude', color='Red', s=9, ax=ax)","ea730f39":"\nny_img_map = plt.imread('https:\/\/i.imgur.com\/zrZwViw.png')\n\n\nplt.rcParams[\"figure.figsize\"] = (11,10)\n\nax = train2.plot.scatter(x ='pickup_longitude', y = 'pickup_latitude', s=0.7, zorder=1)\ntrain2.plot.scatter(x ='dropoff_longitude', y = 'dropoff_latitude', color='Red', s=0.2, zorder=1, ax=ax)\nax.imshow(ny_img_map, zorder=0, extent=[-75.354559, -72.856968, 40.121653, 41.087085])\n","a9012b74":"# I wrote this  function based on https:\/\/www.kaggle.com\/breemen\/nyc-taxi-fare-data-exploration kernel.\n# Previously I tried doing it with shapefiles but it took arround 3.5sec to analyze each point. This method\n# is faster\ndef is_in_water(map_mask, left_top, right_bottom, coord):\n    width = map_mask.shape[1]\n    height = map_mask.shape[0]\n    array_sea_color = np.array([0., 0. , 0.], dtype='float32')\n    \n    #Delta distance in limits\n    dist_x = (right_bottom[0] - left_top[0]) \n    dist_y = (left_top[1] - right_bottom[1])\n\n    #Map delta distance to pixels\n    pix_x = ((coord[0] - left_top[0]) \/ dist_x) * width\n    pix_y = ((coord[1] - right_bottom[1]) \/ dist_y) * height\n\n    if pix_x < 0 or pix_y < 0 or pix_x > width or pix_y > height:\n        return True #coord outside bounds\n    \n    #Get the color of the pixel\n    color = map_mask[ height- int(pix_y), int(pix_x)]\n    \n    #Is in sea?  (compare color)\n    return np.array_equal(color, array_sea_color)","9b71de51":"#Custom mask made quickly with photoshop. Black pixels will be considered sea,\nny_img_mask = plt.imread('https:\/\/i.imgur.com\/ov0cDqP.png')\n#Bounds of the area\nleft_top = (-74.8, 41.1)\nright_bottom = (-72.8, 40.092)","1b261618":"#Drop all the points in the water.\ntrain2['is_water'] = train2.apply(lambda row: \\\n                                   is_in_water(ny_img_mask, left_top, right_bottom, \\\n                                               (row.pickup_longitude, row.pickup_latitude)), axis=1)\ntrain2 =train2[train2['is_water'] == False]\ntrain2['is_water'] = train2.apply(lambda row: \\\n                                   is_in_water(ny_img_mask, left_top, right_bottom, \\\n                                               (row.dropoff_longitude, row.dropoff_latitude)), axis=1)\ntrain2 =train2[train2['is_water'] == False]","c14439ec":"ny_img_map = plt.imread('https:\/\/i.imgur.com\/IqJFL8l.png')\n#ny_img_map = plt.imread('https:\/\/i.imgur.com\/ov0cDqP.png') #Show mask in figure instead of the map.\n\n\nplt.rcParams[\"figure.figsize\"] = (18,15)\n\nax = train2.plot.scatter(x ='pickup_longitude', y = 'pickup_latitude', s=1, zorder=1)\ntrain2.plot.scatter(x ='dropoff_longitude', y = 'dropoff_latitude', color='Red', s=0.01, zorder=1, ax=ax)\nax.imshow(ny_img_map, zorder=0, extent=[-74.8, -72.8, 40.092, 41.1])","4811839c":"#Remove old column\ntrain2 = train2.drop('is_water', axis=1)","6aeceda4":"#Visualize the city\nfig, ax = plt.subplots(2,1, figsize=(16,16))\ntrain2[(train2['pickup_longitude'] > -74.2) & (train2['pickup_longitude'] < -73.85) &\n       (train2['pickup_latitude'] < 40.9) & (train2['pickup_latitude'] > 40.6)]\\\n        .plot.scatter(x ='pickup_longitude', y = 'pickup_latitude', s=0.1, ax=ax[0])\n\ntrain2[(train2['dropoff_longitude'] > -74.2) & (train2['dropoff_longitude'] < -73.85) &\n       (train2['dropoff_latitude'] < 40.9) & (train2['dropoff_latitude'] > 40.6)]\\\n        .plot.scatter(x ='dropoff_longitude', y = 'dropoff_latitude', s=0.1, ax=ax[1], c='red')","2c69459a":"#Add derived column with the distance traveled\ntrain2['distance'] = train2.apply(lambda row: haversine(row.pickup_longitude, row.pickup_latitude, \n                        row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\n#If some distance traveled is less than 100 meters I will take that row as invalid.\ntrain2 = train2[train2['distance'] > 0.1]\n#Long trips can have agreed fares, so they are outliers. I will take trips shorter than 50km\ntrain2 = train2[train2['distance'] <= 50]","2e9e3a73":"#Some stats of the dataset\ntrain2.describe()","9e9bd6d8":"fig, ax = plt.subplots(1,2, figsize=(16,8))\ntrain2[train2['distance'] <= 6.6][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3,\n                                                                           ax=ax[0])\ntrain2[train2['distance'] > 6.6][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3, ax=ax[1])","5282c807":"#Both together\ntrain2[['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3)","b97f0c24":"def airport_trip(pick_lon, pick_lat, drop_lon, drop_lat):     \n    #Airport coords\n    la_guardia_coords = (-73.872192, 40.774210)\n    jfk_coords = (-73.786932, 40.645753)\n    newark_coords = (-74.182634, 40.692509)\n    \n    #La guardia airport\n    if haversine(pick_lon,pick_lat, la_guardia_coords[0], la_guardia_coords[1]) < 3 or \\\n        haversine(drop_lon,drop_lat, la_guardia_coords[0], la_guardia_coords[1]) < 3:\n            return 1\n    #JFK airport\n    if haversine(pick_lon,pick_lat, jfk_coords[0], jfk_coords[1]) < 3 or \\\n        haversine(drop_lon,drop_lat, jfk_coords[0], jfk_coords[1]) < 3:\n            return 2\n    #Newark airport\n    if haversine(pick_lon,pick_lat, newark_coords[0], newark_coords[1]) < 3 or \\\n        haversine(drop_lon,drop_lat, newark_coords[0], newark_coords[1]) < 3:\n            return 3\n    #Trip is no from\/to airport\n    return 0","87b667fa":"train2['airport'] = train2.apply(lambda row: airport_trip(row.pickup_longitude, row.pickup_latitude, row.dropoff_longitude, row.dropoff_latitude), axis=1)","b426422d":"print(\"LAG: \" +  str(len(train2[train2['airport'] == 1])))\nprint('JFK: ' + str(len(train2[train2['airport'] == 2])))\nprint('NEW: ' + str(len(train2[train2['airport'] == 3])))\nprint('NONE: '+ str(len(train2[train2['airport'] == 0])))","1affcb74":"# Trips outside of the city may have a agreed fare. We should remove them.\n# http:\/\/www.nyc.gov\/html\/tlc\/html\/passenger\/taxicab_rate.shtml\n\n#Let's define a point in the \"center\" of all trips. It represents the center of NYC. (It's Manhattan btw).\nnyc_center_coords = (-73.972500, 40.769804) \n\n#Add a column to the DF. to see how far from the center are the dropoff points.\ntrain2['distance_center'] = train2.apply(lambda row: \n                                         haversine(nyc_center_coords[0], nyc_center_coords[1],\n                                                   row.dropoff_longitude, row.dropoff_latitude), axis=1)\n#train2 = train2[train2['distance_center'] < 50]","8546e26c":"fig, ax = plt.subplots(1,3, figsize=(16,8))\ntrain2[train2['airport'] == 1][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3, ax=ax[0])\ntrain2[train2['airport'] == 2][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3, ax=ax[1])\ntrain2[train2['airport'] == 3][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3, ax=ax[2])\ntrain2[train2['airport'] == 0][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3)","df39155f":"train2[(train2['airport'] == 0) & (train2['fare_amount'] > 56.75)& (train2['fare_amount'] < 57)][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=10)","d309fb0d":"tmp = train2[(train2['airport'] == 0) & (train2['fare_amount'] > 56.75)& (train2['fare_amount'] < 57)]","ce9ea92a":"#Where are the dropoff points?\nny_img_map = plt.imread('https:\/\/i.imgur.com\/IqJFL8l.png')\n\nplt.rcParams[\"figure.figsize\"] = (18,15)\n\nax = tmp.plot.scatter(x ='pickup_longitude', y = 'pickup_latitude', s=10, zorder=1)\ntmp.plot.scatter(x ='dropoff_longitude', y = 'dropoff_latitude', color='Red', s=20, zorder=1, ax=ax)\nax.imshow(ny_img_map, zorder=0, extent=[-74.8, -72.8, 40.092, 41.1])","f4aff948":"#def haversine(lon1, lat1, lon2, lat2):\ndef is_to_center(pick_lon, pick_lat, drop_lon, drop_lat):\n    if haversine(nyc_center_coords[0], nyc_center_coords[1], drop_lon, drop_lat) < 2 and \\\n    haversine(nyc_center_coords[0], nyc_center_coords[1], pick_lon, pick_lat)  > 9:\n        return 1\n    else:\n        return 0","5cf82c1a":"train2['to_center'] = train2.apply(lambda row: is_to_center(row.pickup_longitude, row.pickup_latitude, row.dropoff_longitude, row.dropoff_latitude), axis=1)","c96f8b2e":"#Free memory\ndel(tmp)","d56c955b":"from sklearn.cluster import KMeans","ccbbdd8f":"pickups_arr = np.array(train2[['pickup_longitude', 'pickup_latitude']])\ndropoffs_arr = np.array(train2[['dropoff_longitude', 'dropoff_latitude']])","d8c577e1":"kmeans_picks = KMeans(n_clusters=30, random_state=0).fit(pickups_arr)\nkmeans_drops = KMeans(n_clusters=30, random_state=0).fit(dropoffs_arr)","771b7a98":"#Visualize the centers in the map\nfig, ax = plt.subplots(1,1, figsize=(16,8))\nax.scatter(x=kmeans_picks.cluster_centers_[:,0], y=kmeans_picks.cluster_centers_[:,1])\nax.scatter(x=kmeans_drops.cluster_centers_[:,0], y=kmeans_drops.cluster_centers_[:,1], c='red')\nax.imshow(ny_img_map, zorder=0, extent=[-74.8, -72.8, 40.092, 41.1])","714abf11":"del(pickups_arr, dropoffs_arr) # Free memory","0fd1cbec":"def predict_clusters(dataframe, kmeans_picks, kmeans_drops):\n    #arr_picks = kmeans_picks.predict(np.array(dataframe[['pickup_longitude', 'pickup_latitude']]))\n    #arr_drops = kmeans_drops.predict(np.array(dataframe[['dropoff_longitude', 'dropoff_latitude']]))\n    copy = dataframe.copy()\n    copy['cluster_pick'] = kmeans_picks.predict(np.array(copy[['pickup_longitude', 'pickup_latitude']]))\n    copy['cluster_drop'] = kmeans_drops.predict(np.array(copy[['dropoff_longitude', 'dropoff_latitude']]))\n    return copy","3bfd2241":"train2 = predict_clusters(train2, kmeans_picks, kmeans_drops)","af57c2fe":"train2","0d58744a":"#Hour of the trip\ntrain2['hour'] = train2.apply(lambda row: row.pickup_datetime.hour, axis=1)\n#Day of week\ntrain2['dow'] = train2.apply(lambda row: row.pickup_datetime.weekday(), axis=1)\n#fare_per_km\ntrain2['fare_per_km'] = train2['fare_amount'] \/ train2['distance']","4ce8d3b6":"#Study the average fare by hour in each week day\ndf = train2.groupby(['dow', 'hour'])['fare_amount'].mean()\nfig, ax = plt.subplots(1,2, figsize=(16,8))\n\nax[0].set_title('avg. Fare amount on each weekday')\nplt.title('avg. Fare amount on each weekday')\nfor i in range(7):\n    df[i].plot(ax=ax[0], label=\"DAY {}\".format(i))\nax[0].legend()    \n\ndf = train2.groupby(['dow', 'hour'])['fare_per_km'].mean()\n\nplt.title('avg. Fare per km on each weekday')\nfor i in range(7):\n    df[i].plot(ax=ax[1], label=\"DAY {}\".format(i))\n    \nax[1].legend()","2b3b7efe":"del(df)","9d6b3ac5":"train2['work_day'] = 0\ntrain2['peak_hour'] = 0\ntrain2.loc[(train2['dow'] >= 0) & (train2['dow'] < 5), ['work_day']] = 1\ntrain2.loc[(train2['hour'] > 5) & (train2['hour'] < 20), ['peak_hour']] = 1","330b6209":"train2.describe()","fe0421b8":"fig, ax = plt.subplots(3,1, figsize=(16,8))\ntrain2[(train2['distance'] <= 1) & (train2['fare_per_km'] < 500)][['fare_per_km', 'distance']].plot.scatter('distance', 'fare_per_km', s=3, ax=ax[0])\n\ntrain2[train2['distance'] <= 1][['fare_per_km', 'distance']].plot.scatter('distance', 'fare_per_km', s=3, ax=ax[1])\n\ntrain2[['fare_per_km', 'distance']].plot.scatter('distance', 'fare_per_km', s=3, ax=ax[2])","b9f9793a":"train2 = train2[train2['fare_per_km'] < 150]","18502aec":"train2.describe()","069bf7d9":"fig, ax = plt.subplots(3,1, figsize=(16,8))\ntrain2[(train2['distance'] <= 1) & (train2['fare_per_km'] < 500)][['fare_per_km', 'distance']].plot.scatter('distance', 'fare_per_km', s=3, ax=ax[0])\n\ntrain2[train2['distance'] <= 1][['fare_per_km', 'distance']].plot.scatter('distance', 'fare_per_km', s=3, ax=ax[1])\n\ntrain2[['fare_per_km', 'distance']].plot.scatter('distance', 'fare_per_km', s=3, ax=ax[2])","adc7636c":"from sklearn import linear_model","ce75bec7":"model = linear_model.LinearRegression()\n#Train only with 6000 samples\nmodel.fit(np.array(train2.head(6000).distance).reshape(-1,1), np.array(train2.head(6000).fare_amount).reshape(-1,1))\n\n#Make the line\npred = model.predict(np.arange(40).reshape(-1,1))","4ed86790":"fig,ax = plt.subplots(1,1, figsize=(10,10))\ntrain2[train2.distance < 35][['fare_amount', 'distance']].plot.scatter('distance', 'fare_amount', s=3, ax=ax)\nax.plot(pred, color='red')\n","664a5dcd":"train3 = train2.copy()\ntrain3['pred'] = train3.apply(lambda row: model.predict(np.array([row.distance]).reshape(1,-1))[0][0],  axis=1)","5cf0c3a7":"# Score the prediction\n((train3.fare_amount - train3.pred) ** 2).mean() ** .5","a6be393a":"corr = train2.copy()\ncorr = corr.drop(['key', 'pickup_datetime'], axis=1)","c87dcfe2":"import matplotlib.ticker as ticker\nplt.style.use('default')\nfig, ax = plt.subplots(1, 1, figsize=(15,15))\ncax = ax.matshow(corr.corr(), interpolation='nearest', origin='upper')\n\nax.set_xticklabels([''] + corr.columns.tolist(), rotation=45)\nax.set_yticklabels([''] + corr.columns.tolist())\n\nax.xaxis.set_major_locator(ticker.MultipleLocator(1))\nax.yaxis.set_major_locator(ticker.MultipleLocator(1))\n\nplt.style.use('seaborn')\n\nfig.colorbar(cax)\n#","c77d02e1":"corr.corr().head(1)","471f0fc5":"train3 = train2.copy()","6e14bf9e":"import xgboost as xgb\nimport math","5ba93713":"#Split 20% of the dataset for evaluating the model\ntest_size = math.floor(train3.count()[0]*0.2)\n\ndata_train = train3.head(train3.count()[0] - test_size)\ndata_train_fare = data_train['fare_amount']\n\ndata_test = train3.tail(test_size)\ndata_test_fare = data_test['fare_amount']\n\ndata_train= data_train.drop(['key', 'pickup_datetime', 'fare_amount', 'fare_per_km', 'hour', 'dow', 'passenger_count'], axis=1)\ndata_test= data_test.drop(['key', 'pickup_datetime', 'fare_amount', 'fare_per_km', 'hour', 'dow', 'passenger_count'], axis=1)\n\n#Build and train model\nmodel = xgb.train(params={'objective':'reg:linear','eval_metric':'rmse', 'max_depth':'6', 'n_estimators':'300'},\n                    dtrain=xgb.DMatrix(data_train, label=data_train_fare),\n                    num_boost_round=170, \n                    early_stopping_rounds=10,evals=[(xgb.DMatrix(data_test, label=data_test_fare),'test')])\n","a9637c4f":"#Load test dataset\ntest_eval_base = pd.read_csv('..\/input\/train.csv', nrows=1_600_000)[800_000:]\ntest_eval = test_eval_base.copy()\n\n#Convert \"objects\" to \"datetime\"\ntest_eval['key'] = pd.to_datetime(test_eval['key'])\ntest_eval['pickup_datetime'] = pd.to_datetime(test_eval['key'])\n\n\ntest_eval['distance'] = test_eval.apply(lambda row: haversine(row.pickup_longitude, row.pickup_latitude, \n                        row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\n#Airport\ntest_eval['airport'] = test_eval.apply(lambda row: airport_trip(row.pickup_longitude, row.pickup_latitude, row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\ntest_eval['distance_center'] = test_eval.apply(lambda row: \n                                         haversine(nyc_center_coords[0], nyc_center_coords[1],\n                                                   row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\n#test_data = predict_clusters(test_data, kmeans_picks, kmeans_drops)\n\n#Hour of the trip\ntest_eval['hour'] = test_eval.apply(lambda row: row.pickup_datetime.hour, axis=1)\n#Day of week\ntest_eval['dow'] = test_eval.apply(lambda row: row.pickup_datetime.weekday(), axis=1)\n#Is a trip to NYC center?\ntest_eval['to_center'] = test_eval.apply(lambda row: is_to_center(row.pickup_longitude, row.pickup_latitude, row.dropoff_longitude, row.dropoff_latitude), axis=1)\n#Drop passenger count\ntest_eval = test_eval.drop(['passenger_count', 'fare_amount'], axis=1)\n\ntest_eval['work_day'] = 0\ntest_eval['peak_hour'] = 0\ntest_eval.loc[(test_eval['dow'] >= 0) & (test_eval['dow'] < 5), ['work_day']] = 1\ntest_eval.loc[(test_eval['hour'] > 5) & (test_eval['hour'] < 20), ['peak_hour']] = 1\ntest_eval.loc[(test_eval['dow'] >= 0) & (test_eval['dow'] < 5), ['work_day']] = 1\ntest_eval.loc[(test_eval['hour'] > 5) & (test_eval['hour'] < 20), ['peak_hour']] = 1\n\ntest_eval= test_eval.drop(['key', 'pickup_datetime', 'dow', 'hour'], axis=1)\nresults = model.predict(xgb.DMatrix(test_eval))","2c7194f0":"#Evaluate model (RMSE)\ntest_eval_base['pred'] = results\n((test_eval_base.fare_amount - test_eval_base.pred) ** 2).mean() ** .5","09bb7d89":"#Free memory\ndel(test_eval, test_eval_base)","12d0be8e":"import keras as k","8f847eab":"nn = k.Sequential()\nnn.add(k.layers.Dense(10, input_shape=(10,)))\nnn.add(k.layers.Dense(20, activation='tanh'))\nnn.add(k.layers.Dense(100, activation='selu'))\nnn.add(k.layers.Dense(80, activation='tanh'))\nnn.add(k.layers.Dense(10, activation='sigmoid'))\nnn.add(k.layers.Dense(10, activation='sigmoid'))\nnn.add(k.layers.Dense(1, activation='relu'))","1e0fcb3d":"nn.compile(k.optimizers.Adam(), loss='mae')","ff35ed97":"test_size = math.floor(train3.count()[0]*0.2)\n\ndata_train = train3.head(train3.count()[0] - test_size)\ndata_train_fare = data_train['fare_amount']\n\ndata_test = train3.tail(test_size)\ndata_test_fare = data_test['fare_amount']\n\ndata_train= data_train.drop(['key', 'pickup_datetime', 'fare_amount', 'fare_per_km'], axis=1)\ndata_test= data_test.drop(['key', 'pickup_datetime', 'fare_amount', 'fare_per_km'], axis=1)","5543d41a":"d_train = np.array(data_train)\nd_train_l = np.array(data_train_fare)\n\nd_test = np.array(data_test)\nd_test_l = np.array(data_test_fare)","bfcb773f":"nn.fit(x=d_train, y=d_train_l, batch_size=32, validation_split=0.2, epochs=100,     \n       callbacks=[k.callbacks.EarlyStopping(monitor='val_loss')])","0c5cd99b":"test_data = pd.read_csv('..\/input\/test.csv')","8f992250":"#Convert \"objects\" to \"datetime\"\ntest_data['key'] = pd.to_datetime(test_data['key'])\ntest_data['pickup_datetime'] = pd.to_datetime(test_data['key'])\n\n\ntest_data['distance'] = test_data.apply(lambda row: haversine(row.pickup_longitude, row.pickup_latitude, \n                        row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\n#Airport\ntest_data['airport'] = test_data.apply(lambda row: airport_trip(row.pickup_longitude, row.pickup_latitude, row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\ntest_data['distance_center'] = test_data.apply(lambda row: \n                                         haversine(nyc_center_coords[0], nyc_center_coords[1],\n                                                   row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\n#test_data = predict_clusters(test_data, kmeans_picks, kmeans_drops)\n\n#Hour of the trip\ntest_data['hour'] = test_data.apply(lambda row: row.pickup_datetime.hour, axis=1)\n#Day of week\ntest_data['dow'] = test_data.apply(lambda row: row.pickup_datetime.weekday(), axis=1)\n#Is a trip to NYC center?\ntest_data['to_center'] = test_data.apply(lambda row: is_to_center(row.pickup_longitude, row.pickup_latitude, row.dropoff_longitude, row.dropoff_latitude), axis=1)\n\ntest_data['work_day'] = 0\ntest_data['peak_hour'] = 0\ntest_data.loc[(test_data['dow'] >= 0) & (test_data['dow'] < 5), ['work_day']] = 1\ntest_data.loc[(test_data['hour'] > 5) & (test_data['hour'] < 20), ['peak_hour']] = 1\n\n#Drop passenger count\ntest_data = test_data.drop(['passenger_count', 'hour', 'dow'], axis=1)","8195b5e4":"data_test= test_data.drop(['key', 'pickup_datetime'], axis=1)\nresults = model.predict(xgb.DMatrix(data_test))","a14e77a6":"results","7d70cc02":"#An error uploading the .csv if not done this way\nsample_sub = pd.read_csv('..\/input\/sample_submission.csv')\nsample_sub['fare_amount'] = results","83718e32":"sample_sub.to_csv('air_submission.csv', index=False)","369f5c97":"Looks like there is a fixed fare for going to the center. We can mark this trips.","2f52720b":"This part has been discarted","3d3df961":"Lets plot the pickup and dropoff points","54c56079":"### NOTE: After several submissions, this part has been discarted\nWe can cluster the pickups and dropoffs and add them as a feature. They can give some light to fixed fare on recurrent trips.","2cfa3c79":"The peak hours match with the higher prices.","e8c4e76f":"## Using version 2\n### Generating submission","659d314a":"Better data viz on the map","7c2470fa":"# Read test.csv and make submission","306cb6c6":"There are some wrong values (look at the latitudes and longitudes... Too far from NYC. Aren't they?).","47365c9f":"In the last plot (no airport trip) there are still fixed fares.","0dd4b225":"We also can plot the data points and get the map of the city","5724267b":"# Creating more features\n\nLets add a derived column: **distance** (traveled) and study it","6f4d8e98":"# Version 2. XGBoost\nMaybe I can use XGBoost algorithm for better regression.\n\nLets find the most important features","84fa9e88":"### Clustering has been discarted","167a8bb5":"It would take a fare to be more than 20 dollars for a 0.2km trip. I will remove those outliers","f81cdd9b":"Lets get wether Day of week and distance affect the fare","73f5e7b3":"# Predicting NYC taxi fare amount","7e27251d":"Looks like that the average trip is short (3.3 km). Looking at the above plot, most of the movements are in the city center.\n\nLets get the avg fare amount of short trips, 6.6 km or less (mean+std).","6c153077":"# Some spatial data visualization","fe126486":"Lets view again the fare \/ distance plots.","bbeb7b34":"Looks like there is a obvious linear pattern. \nBut this is intuitive. The less distance, the less fare. \n\nNevertheless, there are some outliers (high distance and low fare_amount).\n\nAlso, as suggested by Albert van Breemen (https:\/\/www.kaggle.com\/breemen\/nyc-taxi-fare-data-exploration), the \n\"horizontal lines\" are from fixed fares.\n","c9e1fea9":"Let's study the fare  by hour","b10d2bca":"I will remove the **short trips which have too high fare_amount**.","71732b06":"### Let's analyze data","ea4737c8":"Thats better :)","64ca97c2":"# Clean data","586f2049":"DoW, Hour and passengers seem to have almost 0 correlation. I will drop them","f75e7f0d":"there is a fixed amount per trip.","f400670e":"There are some points in the ocean. They sould be removed.","8a0d824c":"Kaggle challenge: https:\/\/www.kaggle.com\/c\/new-york-city-taxi-fare-prediction\nAIR - 2018\n** SCORE: **","93f191cb":"# Version 3. Deep Learning","f035e811":"# First version. Simple linear regression"}}