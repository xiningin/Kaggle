{"cell_type":{"c6194533":"code","cb991555":"code","832d506f":"code","0c2021a4":"code","8fffa310":"code","02ebc648":"code","7462f693":"code","6c668245":"code","a3cf42e8":"code","db02dcfb":"code","4633fac3":"code","20a5c6fb":"code","95443fab":"code","eb0ccc20":"code","d8ebc713":"code","1791671e":"code","6b4ebe8b":"code","567d941d":"code","c1a50e4d":"code","a6b7af43":"code","c1f56527":"code","00fea178":"code","3d6200bb":"code","9d1798b2":"code","e3c6e483":"code","3dfffa6d":"code","444cd6a6":"code","b957a74a":"code","af908c2e":"code","6833ff56":"code","65996dfb":"code","a5abd2ab":"code","312ceb34":"code","f2529be5":"code","eb653c3d":"code","3a65d800":"code","f95946fa":"code","651a2911":"code","078bd085":"code","e2127b01":"code","3c2b02f8":"code","c1be5b91":"code","9a319b92":"code","76d7ed1b":"code","fb93ad74":"code","29582bff":"code","62278b49":"code","f14b6f8b":"code","680eda0e":"code","e05e6231":"code","e20d9f7b":"code","c4e5a7ab":"code","e80f53ab":"code","e1dbc5b2":"code","06baf621":"code","7fd301e0":"markdown","a5c3e002":"markdown","64d755c8":"markdown","9542d7d1":"markdown","4b36c1df":"markdown","0cab193a":"markdown","22bd6414":"markdown","cda4d339":"markdown","e4f316b8":"markdown","1d8600f3":"markdown","f71dd6ff":"markdown","902c6e85":"markdown","c8dd5cb6":"markdown","01462da1":"markdown"},"source":{"c6194533":"import pandas as pd\nimport numpy as np\nimport os\nfrom os.path import join\n\nimport PIL.Image\nfrom PIL import ImageOps\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom tensorflow import keras\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.models import Sequential, load_model, Model\nfrom tensorflow.keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, Dropout\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.applications.inception_resnet_v2 import InceptionResNetV2, preprocess_input\n\nimport itertools\nfrom sklearn.metrics import classification_report, confusion_matrix\n\nimport warnings\nwarnings.filterwarnings('ignore')","cb991555":"# Local dos dados de treino e teste\ntrain_dir = '..\/input\/dog-breed-identification\/train'\ntest_dir = '..\/input\/dog-breed-identification\/test'","832d506f":"# Tamanho dos dados de treino e teste\ntrain_img_fpaths = [join(train_dir, f) for f in os.listdir(train_dir)]\ntest_img_fpaths = [join(test_dir, f) for f in os.listdir(test_dir)]\n\ntrain_size = len(train_img_fpaths)\ntest_size = len(test_img_fpaths)\n\ntrain_size,test_size","0c2021a4":"# Dataframe de treino\ndf_train = pd.read_csv('..\/input\/dog-breed-identification\/labels.csv')\ndf_train.head()","8fffa310":"# Quantidade de ra\u00e7as\nlen(df_train.breed.unique())","02ebc648":"# Reorganizando dataframe\ndf_train.rename(columns = {\"breed\": \"label\"}, inplace = True)\ndf_train[\"id\"] = df_train[\"id\"].apply(lambda x: x+\".\"+\"jpg\")\ndf_train.head()","7462f693":"test_files = os.listdir(test_dir)\ndf_test = pd.DataFrame({\"id\": test_files, \"label\": \"boston_bull\"})\ndf_test.head()","6c668245":"# Tamanho dos dataframes de treino e teste\n\ntrain_size = len(df_train)\ntest_size = len(df_test)\n\ntrain_size,test_size","a3cf42e8":"# Dados de Treino\ntrain_data_gen = ImageDataGenerator(rescale = 1.\/255, validation_split = 0.2)\ntrain_generator = train_data_gen.flow_from_dataframe(df_train, train_dir, x_col = 'id', y_col = 'label', subset = 'training',\n                                                     color_mode = 'rgb', class_mode = 'categorical', target_size = (299, 299),\n                                                     batch_size = 32, shuffle = True, seed = 123)","db02dcfb":"# Dados de Valida\u00e7\u00e3o\nval_data_generator = ImageDataGenerator(rescale = 1.\/255, validation_split = 0.2)\nvalidation_generator = val_data_generator.flow_from_dataframe(df_train, train_dir, x_col = 'id', y_col = 'label',\n                                                              subset = 'validation', color_mode = 'rgb',\n                                                              class_mode = 'categorical', target_size = (299, 299),\n                                                              batch_size = 32, shuffle = True, seed = 123)","4633fac3":"# Fun\u00e7\u00e3o para transformar imagens em array\ndef image_preocessing(path):\n    image = PIL.Image.open(path)\n    size = (299, 299)\n    image = ImageOps.fit(image, size, PIL.Image.ANTIALIAS) #Retorna uma vers\u00e3o redimensionada e recortada da imagem, recortada no propor\u00e7\u00e3o e tamanho solicitados.\n    image_array = np.asarray(image)\n    \n    return image_array","20a5c6fb":"df_train_aux = df_train.copy()\ndf_train_aux['img_path'] = train_dir + '\/' + df_train_aux['id']\ndf_train_aux","95443fab":"# Transformando imagens em arrays\ndogs = []\nlabel_names=[]\n\nfor i in range(0, len(df_train_aux)):\n    label = df_train_aux.iloc[i,1]\n    filename = df_train_aux.iloc[i,2]\n    image = image_preocessing(filename)\n    dogs.append(image)\n    label_names.append(label)\n    \nprint(np.shape(label_names))\nprint(np.shape(dogs))","eb0ccc20":"# Visualizando algumas imagens\nplt.figure(figsize = (15,15))\nfor i in range(9):\n    plt.subplot(330 + 1 + i)\n    image = dogs\n    plt.imshow(image[i])\nplt.show()","d8ebc713":"model = Sequential()\n\nmodel.add(Conv2D(32, kernel_size = (3, 3), activation = 'selu', input_shape=(299, 299, 3)))\nmodel.add(MaxPooling2D(pool_size = (2, 2)))\nmodel.add(Conv2D(64, kernel_size = (3,3), activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size = (2, 2)))\nmodel.add(Conv2D(128, kernel_size = (3,3), activation = 'selu'))\nmodel.add(Flatten())\nmodel.add(Dense(40, activation = 'relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(20, activation = 'relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(len(list(train_generator.class_indices.keys())), activation = 'softmax'))\n\nmodel.summary()","1791671e":"# Compila o modelo\nmodel.compile(loss = 'categorical_crossentropy', optimizer = Adam(), metrics = ['accuracy'])","6b4ebe8b":"# Salvando melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(filepath = 'my_model.h5',monitor = 'val_loss', save_best_only = True, verbose = 1),\n    keras.callbacks.EarlyStopping(monitor = 'val_loss', patience = 10,verbose = 1)\n]","567d941d":"history = model.fit(train_generator,\n                    steps_per_epoch = train_generator.samples \/\/ 32,\n                    epochs = 20,\n                    callbacks = callbacks_list,\n                    validation_data = validation_generator,\n                    verbose = 1,\n                    validation_steps = validation_generator.samples \/\/ 32)","c1a50e4d":"history_dict = history.history\nloss_values = history_dict['loss']\nval_loss_values = history_dict['val_loss']\n\nepochs_x = range(1, len(loss_values) + 1)\nplt.figure(figsize=(10,10))\nplt.subplot(2,1,1)\nplt.plot(epochs_x, loss_values, 'bo', label='Training loss')\nplt.plot(epochs_x, val_loss_values, 'b', label='Validation loss')\nplt.title('Training and validation Loss and Acc')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\nplt.subplot(2,1,2)\nacc_values = history_dict['accuracy']\nval_acc_values = history_dict['val_accuracy']\nplt.plot(epochs_x, acc_values, 'bo', label='Training acc')\nplt.plot(epochs_x, val_acc_values, 'b', label='Validation acc')\n#plt.title('Training and validation accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Acc')\nplt.legend()\nplt.show()","a6b7af43":"# Load the best saved model\nmodel = load_model('my_model.h5')","c1f56527":"# Using the validation dataset\nscore = model.evaluate_generator(validation_generator)\nprint('Val loss:', score[0])\nprint('Val accuracy:', score[1])","00fea178":"test_data_gen = ImageDataGenerator(rescale = 1.\/255)\ntest_generator = test_data_gen.flow_from_dataframe(df_test, test_dir, x_col = 'id', y_col = 'label', color_mode = 'rgb',\n                                                   class_mode = 'categorical', target_size = (299, 299), batch_size = 32, shuffle = False,\n                                                   seed = 123)","3d6200bb":"# Using the test dataset\nscore = model.evaluate_generator(test_generator)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","9d1798b2":"label_map = (train_generator.class_indices)\nlabel_map_inv = {v: k for k, v in label_map.items()}","e3c6e483":"ypreds = model.predict_generator(generator = test_generator, steps = len(test_generator), verbose = 1)\nypreds","3dfffa6d":"ypred = ypreds.argmax(axis = -1)\nypred","444cd6a6":"submission = pd.read_csv('..\/input\/dog-breed-identification\/sample_submission.csv')\nsubmission.head()","b957a74a":"test_dir_files = os.listdir(test_dir)\ntest_gen_files = test_generator.filenames\nsubmission_files = submission[\"id\"]\nlen(submission_files)","af908c2e":"submission_files","6833ff56":"m = {}\nl = len(test_gen_files)\nfor i in range(l):\n    m[test_gen_files[i]] = ypreds[i] ","65996dfb":"labels = (train_generator.class_indices)\nlabels = list(labels.keys())","a5abd2ab":"ypreds_sync = []\nfor f in submission_files:\n    ypreds_sync.append(m[f+\".jpg\"])","312ceb34":"test_df = pd.DataFrame(data = ypreds_sync, columns = labels)\ntest_df.head()","f2529be5":"test_df[\"id\"] = submission_files\n\ncols = test_df.columns.tolist()\ncols = cols[-1:] + cols[:-1]\ntest_df = test_df[cols]\ntest_df.head()","eb653c3d":"# Dados de Treino\ntrain_data_gen = ImageDataGenerator(preprocessing_function = preprocess_input, validation_split = 0.2)\ntrain_generator = train_data_gen.flow_from_dataframe(df_train, train_dir, x_col = 'id', y_col = 'label', subset = 'training',\n                                                     color_mode = 'rgb', class_mode = 'categorical', target_size = (299, 299),\n                                                     batch_size = 32, shuffle = True, seed = 123)","3a65d800":"# Dados de Valida\u00e7\u00e3o\nval_data_generator = ImageDataGenerator(preprocessing_function = preprocess_input, validation_split = 0.2)\nvalidation_generator = val_data_generator.flow_from_dataframe(df_train, train_dir, x_col = 'id', y_col = 'label',\n                                                              subset = 'validation', color_mode = 'rgb',\n                                                              class_mode = 'categorical', target_size = (299, 299),\n                                                              batch_size = 32, shuffle = True, seed = 123)","f95946fa":"base_model = InceptionResNetV2(weights = 'imagenet', include_top = False, input_shape = ((299,299, 3)))\n\nx = base_model.output\nx = Flatten()(x)\nx = Dense(100, activation = 'relu')(x)\npredictions = Dense(len(list(train_generator.class_indices.keys())), activation = 'softmax',\n                    kernel_initializer = 'random_uniform')(x)\n\nmodel = Model(inputs = base_model.input, outputs = predictions)\n\n# Freezing pretrained layers\nfor layer in base_model.layers:\n    layer.trainable = False\n    \noptimizer = Adam()\nmodel.compile(optimizer=  optimizer,loss = 'categorical_crossentropy',metrics = ['accuracy'])","651a2911":"# Salvando melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(filepath = 'my_model.h5',monitor = 'val_loss', save_best_only = True, verbose = 1),\n    keras.callbacks.EarlyStopping(monitor = 'val_loss', patience = 10,verbose = 1)\n]","078bd085":"history = model.fit(train_generator,\n                    steps_per_epoch = train_generator.samples \/\/ 32,\n                    epochs = 50,\n                    callbacks = callbacks_list,\n                    validation_data = validation_generator,\n                    verbose = 1,\n                    validation_steps = validation_generator.samples \/\/ 32)","e2127b01":"history_dict = history.history\nloss_values = history_dict['loss']\nval_loss_values = history_dict['val_loss']\n\nepochs_x = range(1, len(loss_values) + 1)\nplt.figure(figsize = (10,10))\nplt.subplot(2,1,1)\nplt.plot(epochs_x, loss_values, 'bo', label = 'Training loss')\nplt.plot(epochs_x, val_loss_values, 'b', label = 'Validation loss')\nplt.title('Training and validation Loss and Acc')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\nplt.subplot(2,1,2)\nacc_values = history_dict['accuracy']\nval_acc_values = history_dict['val_accuracy']\nplt.plot(epochs_x, acc_values, 'bo', label = 'Training acc')\nplt.plot(epochs_x, val_acc_values, 'b', label = 'Validation acc')\n#plt.title('Training and validation accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Acc')\nplt.legend()\nplt.show()","3c2b02f8":"# Load the best saved model\nmodel = load_model('my_model.h5')","c1be5b91":"# Using the validation dataset\nscore = model.evaluate_generator(validation_generator)\nprint('Val loss:', score[0])\nprint('Val accuracy:', score[1])","9a319b92":"test_data_gen = ImageDataGenerator(preprocessing_function = preprocess_input)\ntest_generator = test_data_gen.flow_from_dataframe(df_test, test_dir, x_col = 'id', y_col = 'label', color_mode = 'rgb',\n                                                   class_mode = 'categorical', target_size = (299, 299), batch_size = 32, shuffle = False,\n                                                   seed = 123)","76d7ed1b":"# Using the test dataset\nscore = model.evaluate_generator(test_generator)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","fb93ad74":"label_map = (train_generator.class_indices)\nlabel_map_inv = {v: k for k, v in label_map.items()}","29582bff":"ypreds = model.predict_generator(generator = test_generator, steps = len(test_generator), verbose = 1)\nypreds","62278b49":"ypred = ypreds.argmax(axis = -1)\nypred","f14b6f8b":"submission = pd.read_csv('..\/input\/dog-breed-identification\/sample_submission.csv')\nsubmission.head()","680eda0e":"test_dir_files = os.listdir(test_dir)\ntest_gen_files = test_generator.filenames\nsubmission_files = submission[\"id\"]\nlen(submission_files)","e05e6231":"submission_files","e20d9f7b":"m = {}\nl = len(test_gen_files)\nfor i in range(l):\n    m[test_gen_files[i]] = ypreds[i] ","c4e5a7ab":"labels = (train_generator.class_indices)\nlabels = list(labels.keys())","e80f53ab":"ypreds_sync = []\nfor f in submission_files:\n    ypreds_sync.append(m[f+\".jpg\"])","e1dbc5b2":"test_df = pd.DataFrame(data = ypreds_sync, columns = labels)\ntest_df.head()","06baf621":"test_df[\"id\"] = submission_files\n\ncols = test_df.columns.tolist()\ncols = cols[-1:] + cols[:-1]\ntest_df = test_df[cols]\ntest_df.head()","7fd301e0":"# 2 - Image Generator Treino e Valida\u00e7\u00e3o","a5c3e002":"# 1 - Dataset","64d755c8":"# 3 - Processando imagens","9542d7d1":"## 1.2 Teste","4b36c1df":"## 1.1 Treino","0cab193a":"## 4.2 Predi\u00e7\u00e3o","22bd6414":"# Resultado","cda4d339":"# 4 - CNN","e4f316b8":"### *O modelo desenvolvido manualmente apresentou um comportamento estranho durante a predi\u00e7\u00e3o dos dados de teste. Al\u00e9m disso, apresentou acur\u00e1cia baixa para dados de valida\u00e7\u00e3o e acur\u00e1cia 0 para o dados de teste. J\u00e1 o modelo baseado em arquiteturas cl\u00e1ssicas e transfer learning apresentou um resultado mais razo\u00e1vel com acur\u00e1cia de 84 %. No entanto, ambos os modelos apresentaram overfitting.*","1d8600f3":"## 5.2 Predi\u00e7\u00e3o","f71dd6ff":"## 5.1 - Image Generator Treino e Valida\u00e7\u00e3o","902c6e85":"## 5.1 Avaliando o modelo","c8dd5cb6":"## 4.1 Avaliando o modelo","01462da1":"# 5 - Transfer Learning from a Deep Model"}}