{"cell_type":{"6231ede5":"code","f9b3d32a":"code","d0c60427":"code","719423c2":"code","8502a40d":"code","196673de":"code","f3479aeb":"code","63b9f131":"code","d70fbd93":"code","610575da":"code","0dd5ec16":"code","b4552211":"code","f94d4ad4":"code","722a1373":"code","03559896":"code","1702c633":"code","1aa4bb7c":"markdown","f7d843fb":"markdown","5f151128":"markdown","87e98913":"markdown","5ce1740f":"markdown","ed669417":"markdown","4f02de33":"markdown","dbe714a6":"markdown","8de31a3b":"markdown","8cad769b":"markdown","0bb955e8":"markdown","39ff437a":"markdown","4152c903":"markdown","6279f546":"markdown","71c8c5aa":"markdown","c66e9364":"markdown","b293b215":"markdown","9561e177":"markdown","d758aedf":"markdown","ebb5d010":"markdown","58fd4914":"markdown","7ffc4f58":"markdown","d2782ed5":"markdown","6ce9bc7b":"markdown","91211743":"markdown","15429778":"markdown","65921ca0":"markdown"},"source":{"6231ede5":"!pip install joblib\n!pip install Pillow","f9b3d32a":"from joblib import Parallel, delayed","d0c60427":"from PIL import ImageDraw, Image\nimport numpy as np\nfrom pathlib import Path\nfrom time import sleep, time\nfrom multiprocessing import cpu_count","719423c2":"size_w = size_h = 512","8502a40d":"def draw_rectangles(img_index, save_dir, n, m):\n    image = Image.new(mode = 'RGB', size = (n, m), color = (255, 255, 255))\n    draw = ImageDraw.Draw(image)\n    sleep(3.0)\n    x1 = np.random.randint(low=0, high=n\/\/2)\n    x2 = np.random.randint(low=n\/\/2 + 1, high=n)\n    \n    y1 = np.random.randint(low=0, high=m\/\/2)\n    y2 = np.random.randint(low=m\/\/2 + 1, high=m)\n    \n    draw.rectangle(xy=[(x1,y1), (x2,y2)], outline=(255, 0, 0))\n    image_name = img_index + '.png'\n    image.save(save_dir.joinpath(image_name).as_posix())\n    return image_name","196673de":"save_dir_no_parallel_process = Path('.\/no_parallel_process')\nsave_dir_no_parallel_process.mkdir(parents=True, exist_ok=True)","f3479aeb":"start_time = time()\n\n\nfor image_index in range(10):\n    image_name = draw_rectangles(img_index=str(image_index+1), save_dir=save_dir_no_parallel_process, n=size_w, m=size_h)\n    print(\"Image Name: \", image_name)\n\n\nsequential_execution_time = time() - start_time\n\n\nprint(\"Execution Time: \", sequential_execution_time)","63b9f131":"save_dir_parallel_process = Path('.\/parallel_process')\nsave_dir_parallel_process.mkdir(parents=True, exist_ok=True)","d70fbd93":"start_time = time()\n\n\nprint(\"Number of jobs: \",int(cpu_count()))\n\n# Use multiple CPUs (Multi Processing)\nimage_filenames = Parallel(n_jobs=int(cpu_count()), prefer='processes')(\n    delayed(draw_rectangles)(img_index=str(image_index+1), save_dir=save_dir_parallel_process, n=size_w, m=size_h) \n    for image_index in range(10)\n)\n\nparallel_execution_time = time() - start_time\n\n\nprint(\"Execution Time: \", parallel_execution_time)","610575da":"for img_index in image_filenames:\n    print(img_index)","0dd5ec16":"save_dir_parallel_threads = Path('.\/parallel_threads')\nsave_dir_parallel_threads.mkdir(parents=True, exist_ok=True)","b4552211":"start_time = time()\n\n\nprint(\"Number of threads: \",10)\n\n# Use multiple CPUs (Multi Processing)\nimage_filenames = Parallel(prefer='threads', n_jobs=10)(\n    delayed(draw_rectangles)(img_index=str(image_index+1), save_dir=save_dir_parallel_threads, n=size_w, m=size_h) \n    for image_index in range(10)\n)\n\nparallel_execution_time_threading = time() - start_time\n\n\nprint(\"Execution Time: \", parallel_execution_time_threading)","f94d4ad4":"shared_list = []","722a1373":"def add_to_list(x):\n    sleep(3.0)\n    shared_list.append(x)","03559896":"start_time = time()\n\nresult = Parallel(n_jobs=cpu_count(), require='sharedmem')(delayed(add_to_list)(i) for i in range(10))\n\nprint(\"Execution Time: \", time()-start_time)","1702c633":"shared_list","1aa4bb7c":"<br>","f7d843fb":"#### Update the shared object parallelly","5f151128":"This tutorial showcases, how to use [Joblib](joblib.readthedocs.io) to parallelize `loops` without using any other heavy modules like apache spark etc which usually have a creational overhead.\n\n- [Part 1](#Lets-start-with-a-simple-example) - Shows a simple example on how to parallelize `for loop` using `Parallel` class. It highlights the difference in execution time for parallel vs squential approach.\n- [Part 2](#1.-Choose-backend) - Shows different available backends (multi-processing and multi-threading) in Joblib and how to choose a particluar backend.\n- [Part 3](#2.-Updating-shared-memory-in-parallel-processing) - Shows how we can interact with shared memory objects.\n","87e98913":"<br>","5ce1740f":"## Looking forward for your feedback in the comments section below\n### If you liked this kernel please hit the Upvote button.","ed669417":"<span style=\"color:red\">Note the time difference in the cell execution time of parallel vs non-parallel<\/span>","4f02de33":"## 1. Choose backend","dbe714a6":"#### Shared object","8de31a3b":"### Define a function","8cad769b":"#### Function to update the shared object","0bb955e8":"# Parallelize embarrassing  for loops using [Joblib](joblib.readthedocs.io\/)","39ff437a":"#### if the parallel function needs to rely on the shared memory semantics of threads, it should be made explicit with `require='sharedmem'`","4152c903":"# Summary","6279f546":"### Let's see an example","71c8c5aa":"#### [Here](#With-Joblib-Parallel-processing), I had already showing an example of multi-processing with `loky` backend\n### Let's choose `threading` backend with argument `prefer='threads'`","c66e9364":"### Without Parallel processing","b293b215":"#### Let's check if our shared object has been updated","9561e177":"### Import other modules","d758aedf":"## Let's start with a simple example","ebb5d010":"### With Joblib `Parallel`","58fd4914":"## Next: Try Disk caching and save lot of computation time using Joblib: https:\/\/www.kaggle.com\/karanpathak\/disk-caching-using-joblib","7ffc4f58":"## We can do a lot with Joblib `Parallel`:\n#### 1. [Thread-based parallelism vs process-based parallelism](https:\/\/joblib.readthedocs.io\/en\/latest\/parallel.html#thread-based-parallelism-vs-process-based-parallelism)\n#### 2. [Shared-memory](https:\/\/joblib.readthedocs.io\/en\/latest\/parallel.html#shared-memory-semantics)\n#### 3. [Working with numerical data in shared memory (memmapping)](https:\/\/joblib.readthedocs.io\/en\/latest\/parallel.html#working-with-numerical-data-in-shared-memory-memmapping)","d2782ed5":"### Parallelism can be achieved in two ways: multi-threading and multi-processing\n\n#### In Joblib, we can specify the backend type and backend:\n\n<img src=\"https:\/\/raw.githubusercontent.com\/karanpathak\/blog\/master\/joblib\/imgs\/joblib_backends.png\" alt=\"Joblib backend and backend type\" width=\"500\" height=\"500\"\/>\n\n> By default, Joblib `Parallel` uses `loky` backend\n\n**<u>P.S.<\/u>** - We can also use dask backend for parallelizing.","6ce9bc7b":"### In this tutorial I will be discussing the first two points, as these are the ones we encounter the most in daily routine work","91211743":"#### Let's print the result","15429778":"## 2. Updating shared memory in parallel processing ","65921ca0":"### Import the `Parallel` class"}}