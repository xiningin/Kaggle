{"cell_type":{"ab295351":"code","8bbf56a1":"code","279f921b":"code","a2ca6560":"code","6c459b96":"code","c7456376":"code","915f278f":"code","62b14045":"code","fe8eddb6":"code","d6187df3":"code","37ff078d":"code","d66935d7":"markdown","e3721afe":"markdown","376f2517":"markdown","e818ed51":"markdown","6c15b2e0":"markdown","4617aaf3":"markdown","e6394eeb":"markdown","427327ab":"markdown"},"source":{"ab295351":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import classification_report,confusion_matrix\nfrom sklearn.naive_bayes import MultinomialNB","8bbf56a1":"df = pd.read_csv('..\/input\/spamraw.csv')\ndf.head()","279f921b":"#Find count and unique messages count of all the messages\ndf.describe()","a2ca6560":"#Extract SPAM messages\nspam_messages = df[df[\"type\"]==\"spam\"]\nspam_messages.head() ","6c459b96":"#Find count and unique messages count of SPAM messages.\nspam_messages.describe()","c7456376":"#Plot the counts of HAM (non SPAM) vs SPAM\ndf.type.value_counts().plot.bar()","915f278f":"data_train, data_test, labels_train, labels_test = train_test_split(df.text,df.type,test_size=0.2,random_state=0) ","62b14045":"vectorizer = CountVectorizer()\ndata_train_count = vectorizer.fit_transform(data_train)\ndata_test_count  = vectorizer.transform(data_test)","fe8eddb6":"clf = MultinomialNB()\nclf.fit(data_train_count, labels_train)\npredictions = clf.predict(data_test_count)","d6187df3":"print (\"accuracy_score : \", accuracy_score(labels_test, predictions))","37ff078d":"print (\"confusion_matrix : \\n\", confusion_matrix(labels_test, predictions))","d66935d7":"**Splitting the SMS data into Test and Train data**","e3721afe":"**Import SMS Data**","376f2517":"**Confusion Matrix**\n\n\n*A confusion matrix is a table that is often used to describe the performance of a classification model (or \u201cclassifier\u201d) on a set of test data for which the true values are known. It allows the visualization of the performance of an algorithm.*","e818ed51":"Multinomial Naive Bayes is a specialized version of Naive Bayes that is designed more for text documents. Whereas simple naive Bayes would model a document as the presence and absence of particular words, multinomial naive bayes explicitly models the word counts and adjusts the underlying calculations to deal with in.\n\nIt is a classification technique based on Bayes' Theorem with an assumption of independence among predictors. In simple terms, a Naive Bayes classifier assumes that the presence of a particular feature in a class is unrelated to the presence of any other feature.","6c15b2e0":"**Modelling & training**","4617aaf3":"**Import Python libraries**","e6394eeb":"**Exploratory Data Analysis (EDA)**","427327ab":"**Extraction & CountVectorize**\n\n\n*The CountVectorizer provides a simple way to both tokenize a collection of text documents and build a vocabulary of known words, but also to encode new documents using that vocabulary.*"}}