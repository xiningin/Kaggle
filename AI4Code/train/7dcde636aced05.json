{"cell_type":{"90d9e672":"code","b966ea57":"code","6499d4af":"code","c44373b0":"code","9cc98cc9":"code","dd79f396":"code","67e31588":"code","728bec0c":"code","ac5cda68":"code","48ae8b41":"code","09ee52cc":"code","3457f8e6":"code","950e09ef":"code","573e6e9b":"code","45534ca6":"code","4cca399f":"code","cb707c4d":"code","66de3cd7":"code","088a05d8":"code","ee4de0a8":"code","46f25846":"code","29fd7370":"markdown","5b7ba655":"markdown","d70644cb":"markdown","e082e3ea":"markdown","8e28bc5f":"markdown","825d813f":"markdown","ab7ccecb":"markdown","84f8a9b3":"markdown","7cc40e4e":"markdown","ac06b2b6":"markdown","88cccb5b":"markdown","50d62b5d":"markdown","cfb33ecc":"markdown","4310c16a":"markdown","a7fe8917":"markdown","018ff783":"markdown","a87ee321":"markdown","44efac4f":"markdown","737eeede":"markdown","353e0bce":"markdown","888e130d":"markdown","a1cb4d3e":"markdown","fd470db8":"markdown","0bb2ced1":"markdown"},"source":{"90d9e672":"import numpy as np\nimport pandas as pd\npd.set_option(\"display.max_colwidth\", 50)\n    \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport glob\nimport os\nimport sys\nimport math\nimport gc\nimport json \nimport re\nfrom tqdm import tqdm\n\nimport warnings # Supress warnings \nwarnings.filterwarnings('ignore')\n\nPATH = '..\/input\/indoor-location-navigation\/'\n\nsubmission = pd.read_csv(f'{PATH}sample_submission.csv')","b966ea57":"#  The following code is copied and edited https:\/\/github.com\/location-competition\/indoor-location-competition-20\nfrom dataclasses import dataclass\n\n@dataclass\nclass ReadData:\n    # Removed other signal info acquisition for simplicity reasons ...\n    ibeacon: np.ndarray\n    waypoint: np.ndarray\n\n\ndef read_data_file(data_filename):\n    # Removed other signal info acquisition for simplicity reasons ...\n    ibeacon = []\n    waypoint = []\n\n    with open(data_filename, 'r', encoding='utf-8') as file:\n        lines = file.readlines()\n\n    for line_data in lines:\n        line_data = line_data.strip()\n        if not line_data or line_data[0] == '#':\n            continue\n\n        line_data = line_data.split('\\t')\n\n        # Removed other signal info acquisition for simplicity reasons ...\n\n        if line_data[1] == 'TYPE_BEACON':\n            ts = line_data[0]\n            uuid = line_data[2]\n            major = line_data[3]\n            minor = line_data[4]\n            rssi = line_data[6]\n            distance = line_data[7] # Newly added\n            \n            ibeacon_data = [ts, '_'.join([uuid, major, minor]), rssi, distance]\n            \n            ibeacon.append(ibeacon_data)\n            continue\n\n        if line_data[1] == 'TYPE_WAYPOINT':\n            waypoint.append([int(line_data[0]), float(line_data[2]), float(line_data[3])])\n\n    # Removed other signal info acquisition for simplicity reasons ...\n\n    ibeacon = np.array(ibeacon)\n    waypoint = np.array(waypoint)\n\n    return ReadData(ibeacon, waypoint)","6499d4af":"\"\"\"\n### Help Functions ###\n\nHere we are setting up help functions that will be used in the following.\n\n## Git Repository ##\nhttps:\/\/github.com\/location-competition\/indoor-location-competition-20\n\nThe `read_data_file` function from the repository returns a class `ReadData` with the following attributes: `acce`, `acce_uncali`, `gyro`, `gyro_uncali`, `magn`, `magn_uncali`, `ahrs`, `wifi`, `ibeacon`, `waypoint`.\n\n## Further Utility Functions ##\nfrom https:\/\/www.kaggle.com\/jiweiliu\/wifi-label-encode\n\"\"\"\n\ndef encode_floor(floor):\n    \"\"\"\n    Encodes floor string to integer\n    \"\"\"\n    # Get floor number\n    encoded_floor = int(re.findall('[0-9]+', floor)[0])\n    \n    if floor.find('B') == 0:\n        # Multiply with -1 incase of B floor\n        encoded_floor = (-1)*encoded_floor\n    else: \n        # Subtract one floor to start at 0 for F1\n        encoded_floor = encoded_floor -1\n        \n    return encoded_floor\n\n# The following code is copied and edited from https:\/\/www.kaggle.com\/jiweiliu\/wifi-label-encode\nACOLS = ['timestamp','x','y','z']\n        \nFIELDS = {\n    'acce': ACOLS,\n    'acce_uncali': ACOLS,\n    'gyro': ACOLS,\n    'gyro_uncali': ACOLS,\n    'magn': ACOLS,\n    'magn_uncali': ACOLS,\n    'ahrs': ACOLS,\n    'wifi': ['timestamp','ssid','bssid','rssi','last_timestamp'],\n    'ibeacon': ['timestamp','id','rssi', 'distance'],\n    'waypoint': ['timestamp','x','y']\n}\n\ndef create_dummy_df(cols):\n    \"\"\"\n    Edited from https:\/\/www.kaggle.com\/jiweiliu\/wifi-label-encode\n    \"\"\"\n    df = pd.DataFrame()\n    for col in cols:\n        df[col] = [0]\n        if col in ['ssid','bssid']:\n            df[col] = df[col].map(str)\n    return df\n\ndef to_frame(data, col):    \n    \"\"\"\n    Edited from https:\/\/www.kaggle.com\/jiweiliu\/wifi-label-encode\n    \"\"\"\n    cols = FIELDS[col]\n    if data.shape[0]>0:\n        df = pd.DataFrame(data, columns=cols)\n    else:\n        df = create_dummy_df(cols)\n    for col in df.columns:\n        if 'timestamp' in col:\n            df[col] = df[col].astype('int64')\n    return df","c44373b0":"# Edited from https:\/\/www.kaggle.com\/devinanzelmo\/wifi-features\nsubmission['building'] = submission[\"site_path_timestamp\"].apply(lambda x: x.split(\"_\")[0])\nprint(f\"The test set convers {submission['building'].nunique()} buildings with {len(submission)} pathes to predict.\")\nused_buildings = list(submission['building'].unique())","9cc98cc9":"train_df = pd.DataFrame()\nbuilding_dict = {}\nfor building in used_buildings:\n    building_dict['building'] = building\n    for floor in os.listdir(f\"{PATH}\/train\/{building}\"):\n        building_dict['floor'] = floor\n        building_dict['floor_enc'] = encode_floor(floor)\n        for path in os.listdir(f\"{PATH}\/train\/{building}\/{floor}\"):\n            building_dict['path'] = path\n            train_df = train_df.append(building_dict, ignore_index=True)\n\ndisplay(train_df.head().style.set_caption('Training Data'))\ntrain_df.to_csv(\"train_df.csv\", index=False)\n\n# Visualize\nbuilding_overview_df = train_df.groupby(['building', 'floor_enc']).path.nunique().to_frame().reset_index(drop=False)\nbuilding_overview_df = building_overview_df.pivot(index='building', columns='floor_enc')['path'].fillna(0)\nbuilding_overview_df.style.background_gradient(cmap='Blues', vmin=0, vmax=150).format(\"{:.0f}\").set_caption('Number Training Pathes per Floor for Buildings in Test Set')","dd79f396":"sample_building = '5a0546857ecc773753327266'\nsample_floor = 'B1'\nsample_path = f'{PATH}train\/{sample_building}\/{sample_floor}\/5e15731fa280850006f3d013.txt'\nprint(f\"Sample path: {sample_path}\")\n\npath = read_data_file(sample_path)\n\nibeacon_df = to_frame(path.ibeacon,'ibeacon')\ndisplay(ibeacon_df.head().style.set_caption('DataFrame Head of iBecon Data'))\ndisplay(ibeacon_df.id.value_counts())\n\nwaypoint_df = to_frame(path.waypoint,'waypoint')\ndisplay(waypoint_df.head().style.set_caption('DataFrame Head of Waypoint Data'))","67e31588":"# Get iBeacon timestamps\nibeacon_df_grouped = ibeacon_df.groupby('timestamp')['id'].unique().to_frame().reset_index(drop=False)\ndisplay(ibeacon_df_grouped.head().style.set_caption(\"iBeacon Timestamps\"))\n\n# Combine with waypoint data\nwaypoint_ble_combined = pd.concat([ibeacon_df_grouped, waypoint_df])\nwaypoint_ble_combined = waypoint_ble_combined.sort_values(by='timestamp').reset_index(drop=True)\n\ndisplay(waypoint_ble_combined.head().style.set_caption('Combined Dataframe of Waypoint and iBeacon Timestamps Sorted by Time'))\n\nfig, ax = plt.subplots(nrows=2, ncols=1, figsize=(14, 6))\nsns.lineplot(x=waypoint_ble_combined.timestamp, y=waypoint_ble_combined.x, marker='o', ax=ax[0], label = 'before interpolation', color='orange')\nsns.lineplot(x=waypoint_ble_combined.timestamp, y=waypoint_ble_combined.y, marker='o', ax=ax[1], label = 'before interpolation', color='orange')\n\n# Interpolate waypoint\nwaypoint_ble_combined.x = waypoint_ble_combined.x.interpolate()\nwaypoint_ble_combined.y = waypoint_ble_combined.y.interpolate()\n\nsns.lineplot(x=waypoint_ble_combined.timestamp, y=waypoint_ble_combined.x, marker='o', ax=ax[0], label = 'after interpolation', color='blue')\nsns.lineplot(x=waypoint_ble_combined.timestamp, y=waypoint_ble_combined.y, marker='o', ax=ax[1], label = 'afte interpolationr', color='blue')\n\nplt.show()\n\ndisplay(waypoint_ble_combined.head().style.set_caption(\"Lookup Table with Interpolated Waypoint Data for iBeacon Timestamps\"))","728bec0c":"ble_df_with_waypoint = ibeacon_df.merge(waypoint_ble_combined[['timestamp', 'x', 'y']], on='timestamp', how='left')\ndisplay(ble_df_with_waypoint.head().style.set_caption(\"iBeacon Dataframe with added waypoint data\"))","ac5cda68":"ble_list = pd.DataFrame()\ndf = train_df[train_df.building == sample_building]\n\nfiles = df[df.floor == sample_floor].path.unique()\n\nfor file in (files):\n\n    path = read_data_file(f\"{PATH}train\/{sample_building}\/{sample_floor}\/{file}\")\n    \n    # Get path's wifi and waypoint data\n    ibeacon_df = to_frame(path.ibeacon,'ibeacon')\n    waypoint_df = to_frame(path.waypoint,'waypoint')\n\n    # Combine wifi and waypoint dataframe to one dataframe\n    ibeacon_df_grouped = ibeacon_df.groupby('timestamp')['id'].nunique().to_frame().reset_index(drop=False)\n    waypoint_ble_combined = pd.concat([ibeacon_df_grouped, waypoint_df])\n    waypoint_ble_combined = waypoint_ble_combined.sort_values(by='timestamp').reset_index(drop=True)\n\n    # Interpolate waypoint data for wifi timestamps\n    waypoint_ble_combined.x = waypoint_ble_combined.x.interpolate()\n    waypoint_ble_combined.y = waypoint_ble_combined.y.interpolate()\n\n    # Map wifi timestamps to wifi dataframe\n    ble_df_with_waypoint = ibeacon_df.merge(waypoint_ble_combined[['timestamp', 'x', 'y']], on='timestamp', how='left')\n\n\n    # Append to dataframe holding all wifi data for this floor\n    ble_list = ble_list.append(ble_df_with_waypoint)\n\ndisplay(ble_list.head().style.set_caption(f\"All iBeacon data for floor {sample_floor} in building {sample_building}\"))\n","48ae8b41":"display(ble_list.id.value_counts().to_frame().head(10))","09ee52cc":"def plot_ibeacon_signal(path, building, floor, identifier):\n    \"\"\"\n    Copied and edited from https:\/\/www.kaggle.com\/robikscube\/indoor-navigation-snap-to-grid-post-processing\n     \n    For every available position the distance to a selected beacon is plotted as a circle.\n    The circles center is the corresponding x,y position.\n    The circles radius is the corresponding distance.\n    The x, y, and distance as scaled to match the maps dimensions for the visualization.\n    \n    Arg in:\n    * path: data directory for the floor images and floor info\n    * building: target building to be plotted\n    * floor: target floor in target building to be plotted\n    * identifier: selected beacon's ID to which the distances shall be plotted\n    \n    Output:\n    A visualization of the target building's target floor with circles representing the distances.\n    \"\"\"\n\n    # Prepare width_meter & height_meter (taken from the .json file)\n    floor_plan_filename = f\"{path}\/metadata\/{building}\/{floor}\/floor_image.png\"\n    json_plan_filename = f\"{path}\/metadata\/{building}\/{floor}\/floor_info.json\"\n\n    # Load and extract floor dimensions in meter\n    with open(json_plan_filename) as json_file:\n        json_data = json.load(json_file)\n\n    width_meter = json_data[\"map_info\"][\"width\"]\n    height_meter = json_data[\"map_info\"][\"height\"]\n\n    # Load floor map as image\n    floor_img = plt.imread(f\"{path}\/metadata\/{sample_building}\/{sample_floor}\/floor_image.png\")\n\n    # Get datapoints for single beacon\n    ble_df = ble_list[ble_list.id ==identifier]\n\n    # Scale x, y, and distance to match floor with sclaer = floor_img.shape[0] \/ height_meter = floor_img.shape[1] \/ width_meter)\n    ble_df[\"x_scaled\"] = ble_df[\"x\"] * floor_img.shape[0] \/ height_meter\n    ble_df[\"y_scaled\"] = (ble_df[\"y\"] * -1 * floor_img.shape[1] \/ width_meter) + floor_img.shape[0]\n    ble_df[\"distance_scaled\"] = ble_df[\"distance\"].astype(float) * floor_img.shape[0] \/ height_meter\n\n    # Plot distance to beacon from x,y position as circle \n    fig, ax = plt.subplots(figsize=(12, 12))\n    plt.imshow(floor_img)\n    for i in range(len(ble_df)):\n        circle=plt.Circle((ble_df[\"x_scaled\"].values[i], ble_df[\"y_scaled\"].values[i]), ble_df[\"distance_scaled\"].values[i], color='dodgerblue', fill=False)\n        ax.add_patch(circle)\n    ax.set_title(f\"Building {building}, Floor {floor} \\n Beacon ID {identifier}\")\n    plt.show()\n","3457f8e6":"plot_ibeacon_signal(PATH, sample_building, sample_floor, \"89cb11b04122cef23388b0da06bd426c1f48a9b5_cfc84f0752adc96b489f71195d91a946c5f6d3e8_8159618423dfa22f1ca0b62543e2f18eef630ce8\")","950e09ef":"path = PATH\nbuilding = sample_building\nfloor = sample_floor\nidentifier = \"89cb11b04122cef23388b0da06bd426c1f48a9b5_cfc84f0752adc96b489f71195d91a946c5f6d3e8_8159618423dfa22f1ca0b62543e2f18eef630ce8\"\n\n\n# Prepare width_meter & height_meter (taken from the .json file)\nfloor_plan_filename = f\"{path}\/metadata\/{building}\/{floor}\/floor_image.png\"\njson_plan_filename = f\"{path}\/metadata\/{building}\/{floor}\/floor_info.json\"\n\nwith open(json_plan_filename) as json_file:\n    json_data = json.load(json_file)\n\nwidth_meter = json_data[\"map_info\"][\"width\"]\nheight_meter = json_data[\"map_info\"][\"height\"]\n\nfloor_img = plt.imread(f\"{PATH}\/metadata\/{sample_building}\/{sample_floor}\/floor_image.png\")\n\nble_df = ble_list[ble_list.id ==identifier]\nble_df.distance = ble_df.distance.astype(float)\nble_df[\"x_\"] = ble_df[\"x\"] * floor_img.shape[0] \/ height_meter\nble_df[\"y_\"] = (ble_df[\"y\"] * -1 * floor_img.shape[1] \/ width_meter) + floor_img.shape[0]\nble_df[\"distance_\"] = ble_df[\"distance\"].astype(float) * floor_img.shape[0] \/ height_meter\n\nble_df = ble_df[ble_df.distance < 3]\ndisplay(ble_df.head().style.set_caption(\"iBeacon datapoints in close approximity (< 3m)\"))\nfig, ax = plt.subplots(figsize=(12, 12))\nplt.imshow(floor_img)\nfor i in range(len(ble_df)):\n    circle=plt.Circle((ble_df[\"x_\"].values[i], ble_df[\"y_\"].values[i]), ble_df[\"distance_\"].values[i], color='dodgerblue', fill=False)\n    ax.add_patch(circle)\n    \ncircle=plt.Circle((480, 320), 60, color='red', fill=False)\nax.add_patch(circle)\n\ncircle=plt.Circle((140, 70), 50, color='red', fill=False)\nax.add_patch(circle)\n\ncircle=plt.Circle((340, 120), 75, color='red', fill=False)\nax.add_patch(circle)\n\nax.set_title(f\"Building {building}, Floor {floor} \\n Beacon ID {identifier}\")\nplt.show()\n","573e6e9b":"#plot_ibeacon_signal(PATH, sample_building, sample_floor, \"4e9d3569a79dcbd102831d1bd587aa4e868ae797_2be4ebd5d986f25c1c84ff3d1536595914dab649_6b742085bcd69795bc6f371a635f62f3b2e3e2c5\")\npath = PATH\nbuilding = sample_building\nfloor = sample_floor\nidentifier = \"4e9d3569a79dcbd102831d1bd587aa4e868ae797_2be4ebd5d986f25c1c84ff3d1536595914dab649_6b742085bcd69795bc6f371a635f62f3b2e3e2c5\"\n\n\n# Prepare width_meter & height_meter (taken from the .json file)\nfloor_plan_filename = f\"{path}\/metadata\/{building}\/{floor}\/floor_image.png\"\njson_plan_filename = f\"{path}\/metadata\/{building}\/{floor}\/floor_info.json\"\n\nwith open(json_plan_filename) as json_file:\n    json_data = json.load(json_file)\n\nwidth_meter = json_data[\"map_info\"][\"width\"]\nheight_meter = json_data[\"map_info\"][\"height\"]\n\nfloor_img = plt.imread(f\"{PATH}\/metadata\/{sample_building}\/{sample_floor}\/floor_image.png\")\n\nble_df = ble_list[ble_list.id ==identifier]\n\nble_df[\"x_\"] = ble_df[\"x\"] * floor_img.shape[0] \/ height_meter\nble_df[\"y_\"] = (ble_df[\"y\"] * -1 * floor_img.shape[1] \/ width_meter) + floor_img.shape[0]\nble_df[\"distance_\"] = ble_df[\"distance\"].astype(float) * floor_img.shape[0] \/ height_meter\n\nfig, ax = plt.subplots(figsize=(12, 12))\nplt.imshow(floor_img)\nfor i in range(len(ble_df)):\n    circle=plt.Circle((ble_df[\"x_\"].values[i], ble_df[\"y_\"].values[i]), ble_df[\"distance_\"].values[i], color='dodgerblue', fill=False)\n    ax.add_patch(circle)\n    \ncircle=plt.Circle((335, 195), 5, color='red')\nax.add_patch(circle)\n\n\nax.set_title(f\"Building {building}, Floor {floor} \\n Beacon ID {identifier}\")\nplt.show()\n","45534ca6":"plot_ibeacon_signal(PATH, sample_building, sample_floor, \"7545e168924d7dd838162d5ba572786e2c47c7ff_b6589fc6ab0dc82cf12099d1c2d40ab994e8410c_ef92237676503daee4b9f2c7f3ffce1a980fc403\")","4cca399f":"ble_list = pd.DataFrame()\ndf = train_df[train_df.building == sample_building]\n\nfor floor in tqdm(df.floor.unique()):\n    files = df[df.floor == floor].path.unique()\n\n    for file in (files):\n\n        path = read_data_file(f\"{PATH}train\/{sample_building}\/{floor}\/{file}\")\n\n        # Get path's wifi and waypoint data\n        ibeacon_df = to_frame(path.ibeacon,'ibeacon')\n        waypoint_df = to_frame(path.waypoint,'waypoint')\n\n        # Combine wifi and waypoint dataframe to one dataframe\n        ibeacon_df_grouped = ibeacon_df.groupby('timestamp')['id'].nunique().to_frame().reset_index(drop=False)\n        waypoint_ble_combined = pd.concat([ibeacon_df_grouped, waypoint_df])\n        waypoint_ble_combined = waypoint_ble_combined.sort_values(by='timestamp').reset_index(drop=True)\n\n        # Interpolate waypoint data for wifi timestamps\n        waypoint_ble_combined.x = waypoint_ble_combined.x.interpolate()\n        waypoint_ble_combined.y = waypoint_ble_combined.y.interpolate()\n\n        # Map wifi timestamps to wifi dataframe\n        ble_df_with_waypoint = ibeacon_df.merge(waypoint_ble_combined[['timestamp', 'x', 'y']], on='timestamp', how='left')\n\n        ble_df_with_waypoint['floor'] = floor\n        # Append to dataframe holding all wifi data for this floor\n        ble_list = ble_list.append(ble_df_with_waypoint)\n\nble_list.distance = ble_list.distance.astype(float)\ndisplay(ble_list.head().style.set_caption(f\"All iBeacon data for building {sample_building}\"))","cb707c4d":"ble_list.groupby('id').floor.nunique().to_frame().sort_values(by='floor', ascending=False).reset_index(drop=False).head(10)","66de3cd7":"ble_list[ble_list.distance < 3].groupby('id').floor.nunique().to_frame().sort_values(by='floor', ascending=False).reset_index(drop=False).head(10)","088a05d8":"beacon_floor_mapping = ble_list[ble_list.distance < 3].groupby(['id', 'floor']).floor.count().to_frame()\nbeacon_floor_mapping.columns = ['num_signals']\nbeacon_floor_mapping = beacon_floor_mapping.reset_index(drop=False)\nbeacon_floor_mapping = beacon_floor_mapping.pivot(index = 'id', columns='floor').num_signals.fillna(0)\nbeacon_floor_mapping['located_on'] = beacon_floor_mapping.idxmax(axis=1)\nbeacon_floor_mapping.reset_index(drop=False, inplace=True)\nbeacon_floor_mapping.style.set_properties(subset=['id'], **{'width': '300px'}).background_gradient(subset=[\"B1\", \"F1\", \"F2\", \"F3\", \"F4\"], cmap='Blues', vmin=0, vmax=1500).format({\"B1\": \"{:.0f}\", \"F1\": \"{:.0f}\", \"F2\": \"{:.0f}\", \"F3\": \"{:.0f}\", \"F4\": \"{:.0f}\", \"F5\": \"{:.0f}\", }).set_caption('Number Strong iBeacon Signals in Sample Building')","ee4de0a8":"path = read_data_file(sample_path)\n\n# Get path's wifi and waypoint data\nibeacon_df = to_frame(path.ibeacon,'ibeacon')\nwaypoint_df = to_frame(path.waypoint,'waypoint')\n\n# Combine wifi and waypoint dataframe to one dataframe\nibeacon_df_grouped = ibeacon_df.groupby('timestamp')['id'].nunique().to_frame().reset_index(drop=False)\nwaypoint_ble_combined = pd.concat([ibeacon_df_grouped, waypoint_df])\nwaypoint_ble_combined = waypoint_ble_combined.sort_values(by='timestamp').reset_index(drop=True)\n\n# Interpolate waypoint data for wifi timestamps\nwaypoint_ble_combined.x = waypoint_ble_combined.x.interpolate()\nwaypoint_ble_combined.y = waypoint_ble_combined.y.interpolate()\n\n# Map wifi timestamps to wifi dataframe\nble_df_with_waypoint = ibeacon_df.merge(waypoint_ble_combined[['timestamp', 'x', 'y']], on='timestamp', how='left')\n\n# Merge with lookup table\nX = ble_df_with_waypoint.merge(beacon_floor_mapping[['id', 'located_on']], on='id', how='left')\nX.distance = X.distance.astype(float)\ndisplay(X.head())","46f25846":"display(X.located_on.value_counts())\ndisplay(X[X.distance < 3].located_on.value_counts())","29fd7370":"Next we will map the waypoint data from the lookup table to the iBeacon dataframe to the corresponding timestamp.","5b7ba655":"Below you can see on how many floors an identifier's signal is received. Although ideally, we would want an identifier's signal to be received only on one floor, we can expected a beacons signal to be received in th floor above or below as well. This means, that we would expected a maximum of three floors for a beacon's signal to be received. However, below we can see two beacons whose signals are received on five floors. This seems suspicious.","d70644cb":"We collect each training path in the preselected 24 test buildings in a dataframe called `train_df`. It is also saved to the output if you would like to further use it.","e082e3ea":"In the below example, there were 2340 datapoints available. However, we might wonder how it is even possible to have a BLE signal when at the top left corner and at the same time at middle.","8e28bc5f":"# Summary\n* iBeacon technology is only be capable of providing room-level accuracy [2]\n* Kagglers have reported that adding iBeacon data seems to worsen the precision (see [discussion topic \"How much value is TYPE_BEACON adding?\"](https:\/\/www.kaggle.com\/c\/indoor-location-navigation\/discussion\/222488))\n* Analysis showed that it does not seem to be feasible to determine the position of the beacons in the training data as an additional feature.\n* iBeacon data could be used to support floor level classification. However, it is not recommended to use it on its own but instead combine it at least with WiFi data.","825d813f":"# Room Level Accuracy\nBased on the above information, I would like to find out if it is possible to **locate the iBeacon devices based on the training data**. Then we could use the information of the **iBeacon locations as additional features**.","ab7ccecb":"### 2. Gather all iBeacon distance \/ position pairs for each beacon.\nLet's repeat above step for all training files in the given building on the given floor.","84f8a9b3":"Let's see what happens if we only use strong signals from beacons in close approximity (< 3m). We still have the two entries with strong signals on all five floors. This seems implausible. However, we now have fewer beacons whose signals are received on multiple floors.","7cc40e4e":"## Data Preparation\n\nBefore we begin, we will prepare the data for easier handling afterwards. The test set only covers 24 buildings. Therefore, we will only consider this reduced number of buildings to create our new features. ","ac06b2b6":"### 3. Use lateration to determine the beacons position in the building\n\nBefore we begin, let's plot a few BLE signals to get a feeling for the data.","88cccb5b":"Below, I have gathered all iBeacon signals on each floor for the sample building.","50d62b5d":"Now, if we use the `value_counts()` function, we can see that this path could either be located on B1 or F4. However, if we only look at the iBeacon signals in clsoe approximity (<3m), we can say with high confidence that the sample path is located on B1, which is in fact correct. One pitfall to note here, is that the lookup table contains information from the sample path as well. If you would want to evaluate the accuracy of this method, it would be better to create a lookup table excluding the validation data.\n\nSince the aim of this notebook is only to evaluate the feasibility of iBeacon data usage, I will not determine the accuracy of this method. However, I think it is save to say that the **iBeacon data could be used to support floor level classification. However, I would not recommend to use it on its own but instead combine it at least with WiFi**.","cfb33ecc":"Let's see if the above lookup table can be used as an additional feature. We will merge the `located_on` feature to the dataframe of your sample path.","4310c16a":"## Methodology\n\nThe **general idea** is as follows:  \n1. Assign each iBeacon distance to a waypoint position in building. \n2. Gather all iBeacon distance \/ position pairs for each beacon.\n3. Use lateration as shown below to determine the beacons position in the building\n![Trilateration.png](attachment:Trilateration.png)\n*Image from [Wikipedia: Lateration](https:\/\/de.wikipedia.org\/wiki\/Lateration)*\n4. Repeat previous steps for all known beacons in selected buildings\n\n### 1. Assign each iBeacon distance to a waypoint position in building.\nFor a sample path, we get the following **iBeacon and waypoint data**.","a7fe8917":"Below you can see the frequency of each beacon. One beacon has over 26,000 datapoints, while there are two beacons with only 1 datapoint.","018ff783":"Let's look at one more beacon. This time we only have 12 datapoints. In theory, this should be enough for trilateration. However, if you look at the below figure, it is difficult to visually estimate the position of the beacon.","a87ee321":"However, if we visualize the beacons' signals, we can at least roughly evaluate on which level the beacon must be located. Note, that the below shown lookup table does not include all beacons in the building.","44efac4f":"We can see that the waypoint data and the iBeacon data have different timestamps. Therefore, we cannot map a position to the iBeacon data directly.\nInstead, we will create a **lookup table to distinguish the position for each timestamp. Note that this method is NOT precise** but sufficient for the intended purpose.  \n\nThe lookup table is created by combining the iBeacon DataFrame with the waypoint DataFrame. Then the new combined dataframe is sorted by timestamps. Finally, the **waypoint data for the iBeacon timestamps is imputed by interpolation**.","737eeede":"For sanity reasons, let's check another beacon. For the below beacon, it looks like we could apply some form of lateration. If you search for where most of the circles are intersecting, you could guess that the beacons position could be roughly located at the position of the red dot. This one gives us a little bit of hope that our idea is feasible.","353e0bce":"# References\n[1] https:\/\/en.wikipedia.org\/wiki\/IBeacon\n\n[2] https:\/\/developer.apple.com\/ibeacon\/Getting-Started-with-iBeacon.pdf\n\n[3] https:\/\/github.com\/location-competition\/indoor-location-competition-20\n\n[4] https:\/\/de.wikipedia.org\/wiki\/Lateration\n\n# Code References\nhttps:\/\/github.com\/location-competition\/indoor-location-competition-20\n\nhttps:\/\/www.kaggle.com\/jiweiliu\/wifi-label-encode\n\nhttps:\/\/www.kaggle.com\/devinanzelmo\/wifi-features\n\nhttps:\/\/www.kaggle.com\/robikscube\/indoor-navigation-snap-to-grid-post-processing\n\nhttps:\/\/www.kaggle.com\/nigelhenry\/simple-99-accurate-floor-model","888e130d":"At this stage, **it does not seem to be feasible to determine the position of the beacons in the training data as an additional feature**. \n\n# Floor Level Accuracy\nLet's see if the iBeacon data can at least support determining the floor in a building. For this purpose, we will follow the simple recipe demonstrated in the notebook [Simple \ud83d\udc4c 99% Accurate Floor Model \ud83d\udcaf](https:\/\/www.kaggle.com\/nigelhenry\/simple-99-accurate-floor-model). The notebook by [@nigelhenry](https:\/\/www.kaggle.com\/nigelhenry) follows the following steps for the WiFi signal to determine floor.\n> 1. Construct a floor-bssid-max(RSSI) frequency table for each site\n2. Give each floor 1 point for every bssid-RSSI pair that falls within the max(RSSI) previously observed on that floor\n3. Take the highest-voted floor.\nLet's evaluate if the same steps can be applied to the iBeacon data.\n\n","a1cb4d3e":"One reason might be that the weaker the signal the less confident we can be in the signals accuracy. Therefore, let's look at the signals in close approximity only (< 3m). However, we can see that even with this stricter selection of iBeacon data, it still looks like there are **three (and a half) possible positions of the beacon**.\n\nAt this stage, it either looks like the identifier is not uniquely identifying a single beacon or the beacons are changing positions or the BLE RSSI is not realible.","fd470db8":"# iBeacon Features \nAs described on the [competitions GitHub page](https:\/\/github.com\/location-competition\/indoor-location-competition-20), the provided iBeacon data contains following features:\n* UUID: Identifier specific to the app and deployment use case [2]\n* MajorID: Further specification for iBeacon and use case [2]\n* MinorID: Further specification of region or use case [2]\n* TxPower\n* RSSI\n* Distance: The distance is calculated from TxPower and RSSI\n* MAC Address\n\n\"The UUID, major and minor values provide the identifying information for the iBeacon\" [2]\n\nThe following function is edited from [the repository's](https:\/\/github.com\/location-competition\/indoor-location-competition-20\/blob\/master\/io_f.py) original function ` read_data_file(data_filename)` with a focus on iBeacon data. While the original function only exracted timestamp, identifier (joined from UUID, MajorID and MinorID) and RSSI, we will be **also extracting the distance**.","0bb2ced1":"# iBeacon Understanding and Feature Engineering\n\nThe aim of this notebook is to get a better understanding of the iBeacon technology. According to [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/IBeacon) \"iBeacon is a protocol developed by Apple [...] in 2013. Various vendors have since made iBeacon-compatible hardware transmitters \u2013 typically called beacons \u2013 a class of **Bluetooth Low Energy (BLE) devices** that broadcast their identifier to nearby portable electronic devices.\"\n\nIn regards to using the iBeacon technology for precise indoor localization, the [Apple developers' guide ](https:\/\/developer.apple.com\/ibeacon\/Getting-Started-with-iBeacon.pdf) states: \"Due to the issues around signal strength and the variabilities in deployment environments, **iBeacon technology is not intended to be used for specific location identification. It should be capable of providing room-level accuracy**, but there are many factors that need to be considered to build a successful deployment.\"\n\nThe fact that iBeacon technology is not precise at meter-level is also reflected in this [discussion topic \"How much value is TYPE_BEACON adding?\"](https:\/\/www.kaggle.com\/c\/indoor-location-navigation\/discussion\/222488). Nonetheless, let's explore this topic a little bit."}}