{"cell_type":{"5de62543":"code","9c6bb09b":"code","ef703fef":"code","c10506f7":"code","3bcdf8f3":"code","2e9846e0":"code","d2e57e78":"code","10246e15":"code","149dda12":"code","62a192ce":"code","74319799":"code","caf2e515":"code","6499dcf7":"code","a1e59b04":"code","ae61f214":"code","a051024d":"code","068b47ea":"code","7c4ba473":"code","16f57769":"code","1c914bce":"code","263aaaec":"code","7c815318":"code","9166d3b1":"code","46b18a50":"code","dcc7e6ac":"code","19e15a7a":"markdown","94801d55":"markdown","a05aa268":"markdown","a01a7d6d":"markdown","bc50fcfe":"markdown","95bf041d":"markdown","92a3238c":"markdown","fa93b3f6":"markdown","0a11a735":"markdown","6088ea5f":"markdown","ae55c5e6":"markdown","db59e9f7":"markdown","87955262":"markdown","13b20b9c":"markdown","11da4743":"markdown","a6a778bd":"markdown","6e1c97b1":"markdown","3d0bf58d":"markdown","219851fb":"markdown","b8cad88a":"markdown","4434d560":"markdown","574f43b6":"markdown","79d8a363":"markdown","bcf100b6":"markdown","970a4db8":"markdown","d8bd56fd":"markdown","8668d9dc":"markdown","e76900fb":"markdown"},"source":{"5de62543":"import pandas as pd\nimport numpy as np\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.model_selection import GridSearchCV\n\nfrom sklearn.base import BaseEstimator, TransformerMixin\n\nfrom sklearn.metrics import mean_absolute_error\n\n%matplotlib inline","9c6bb09b":"# Read the data\nX_full = pd.read_csv('..\/input\/titanic\/train.csv')\nX_test_full = pd.read_csv('..\/input\/titanic\/test.csv')\n\n# Remove rows with missing target, separate target from predictors\nX_full.dropna(axis=0, subset=['Survived'], inplace=True)\ny = X_full.Survived\nX_full.drop(['PassengerId'], axis=1, inplace=True)\n\n# Break off validation set from training data\nX_train_full, X_valid_full, y_train, y_valid = train_test_split(X_full, y, \n                                                                train_size=0.7, test_size=0.3,\n                                                                random_state=2)\n\nfig, (train, test) = plt.subplots(ncols=2, sharey=True, figsize=(15,5))\nsns.heatmap(data=X_full.isnull(), ax=train)\nsns.heatmap(data=X_test_full.isnull(), ax=test)","ef703fef":"categorical_cols = ['Sex', 'Embarked']\nnumerical_cols = ['Pclass', 'SibSp', 'Parch']\nage_col = ['Age']\nfare_col = ['Fare']\ncomplex_cols = ['Name','Ticket','Cabin']\n\n# Keep selected columns only\nmy_cols = categorical_cols + numerical_cols + age_col + fare_col + complex_cols\nX_train = X_train_full[my_cols].copy()\nX_valid = X_valid_full[my_cols].copy()\nX_test = X_test_full[my_cols].copy()\n\nX_train.head()","c10506f7":"avg_survival_chance = X_full['Survived'].mean()\navg_survival_chance_male = X_full[X_full['Sex']=='male']['Survived'].mean()\navg_survival_chance_female = X_full[X_full['Sex']=='female']['Survived'].mean()\nprint('all: {}, male {}, female {}'.format(avg_survival_chance, avg_survival_chance_male, avg_survival_chance_female))","3bcdf8f3":"ticket_survival = X_full[['Ticket','Survived']].copy()\nticket_survival['TicketCode'] = ticket_survival['Ticket'].map(lambda c : c.split()[0])\nticket_survival['TicketCode'] = ticket_survival['TicketCode'].map(lambda c : 'NUM' if c.isdigit() else c)\nticket_survival = ticket_survival.groupby('TicketCode').mean().sort_values(by='Survived')['Survived']\nticket_survival","2e9846e0":"code_dict = {}\ndef split_ticket_codes(surv):\n    if surv < 0.05:\n        return 1\n    elif surv < 0.15:\n        return 2\n    elif surv < 0.3:\n        return 3\n    elif surv < 0.4:\n        return 4\n    elif surv < 0.48:\n        return 5\n    elif surv < 0.6:\n        return 6\n    elif surv < 0.8:\n        return 7\n    return 8\n\nfor i in ticket_survival.index:\n    code_dict[i] = split_ticket_codes(ticket_survival[i])\ncode_dict['Y'] = split_ticket_codes(avg_survival_chance)","d2e57e78":"cabin_survival = X_full[['Cabin','Survived']].copy()\ncabin_survival['Code'] = cabin_survival['Cabin'].map(lambda c : str(c)[0])\ncabin_survival = cabin_survival.groupby('Code').mean().sort_values(by='Survived')\ncabin_survival","10246e15":"cabin_dict = {'T':1, 'n':2, 'A': 3, 'G':4, 'C':5, 'F':6, 'B':7, 'E':8, 'D':9}","149dda12":"title_survival = X_full[['Name','Survived']].copy()\ntitle_survival['Title'] = title_survival['Name'].map(lambda name : name.split(',')[1].split('.')[0].strip())\ntitle_survival = title_survival.groupby('Title').mean().sort_values(by='Survived')\ntitle_survival","62a192ce":"title_dict = {'Capt':0, 'Don':1, 'Jonkheer':2, 'Rev':3,\n                'Mr':4,\n                'Dr':7,\n                'Col':8, 'Major':9, 'Master':10,\n                'Miss':11,\n                'Mrs':15, \n                'Mme':16, 'Sir':17, 'Ms':18, 'Lady':19, 'Mlle':20, 'the Countess':21,\n              #only in test data - avg survival rate for male\/female\n              #male 0.18890814558058924, female 0.7420382165605095:\n                  'Don':5, 'Jonkheer':6, \n                  'Dona':12, 'Lady':13}","74319799":"train_age = X_train[['Age','Name']].append(X_test[['Age','Name']])","caf2e515":"def get_title(name):\n    return name.split(',')[1].split('.')[0].strip()\n    \ndef get_title_id(title):\n    return title_dict[title] if title in title_dict else 9\n    \ndef get_age_per_title(x):\n    x['Title'] = x.Name.map(lambda x : get_title(x))\n    return x.groupby('Title').Age.mean()\n    \navg_age_per_title = get_age_per_title(train_age) ","6499dcf7":"train_fare = X_train[['Fare','Pclass']].append(X_test[['Fare','Pclass']])","a1e59b04":"def get_fare_per_pclass(x):\n    avg_fare = []\n    \n    for i in range(1,4):\n        avg_fare.append(x[x['Pclass']==i]['Fare'].mean())\n\n    print('avg_fare: {}'.format(avg_fare))\n    \n    return avg_fare\n\navg_fare = get_fare_per_pclass(train_fare)","ae61f214":"class NameAgeFeaturesTransformer(BaseEstimator, TransformerMixin):\n    def __init__(self):\n        return\n        \n    def fit(self, x, y=None):\n        return self\n\n    def omit_garbage(self, name):\n        #make sure there is space before and after parenthes\n        name = name.replace('(', ' (')\n        name = name.replace(')', ' )')\n        parts = name.split()\n        \n        idx_start = -1\n        idx_end = -1\n        has_nick = 0\n        for p in parts:\n            i = p.find('(')\n            j = p.find(')')\n            if i >= 0:\n                idx_start = i\n            if j >= 0:\n                idx_end = j\n                \n            i = p.find('\"')\n            if i >= 0:\n                has_nick = 1\n        comp_len = idx_end - idx_start\n        return len(parts) - comp_len - has_nick\n            \n        \n    def transform(self, x):\n        x['Title'] = x['Name'].map(lambda name : get_title(name))\n        #x['Company'] = x['Name'].map(lambda name : 0 if name.find('(') >= 0 else 1)\n        x['NameLen'] = x['Name'].map(lambda name : self.omit_garbage(name))\n        \n        x['Age'] = x.apply(lambda x : avg_age_per_title[x['Title']] if pd.isnull(x['Age']) else x['Age'], axis=1)\n        x['Title'] = x['Title'].map(lambda title : title_dict[title])\n        \n        x.drop('Name', axis=1, inplace=True)\n    \n        return x.values","a051024d":"class CabinFeaturesTransformer(BaseEstimator, TransformerMixin):\n    def __init__(self):\n        return\n        \n    def fit(self, x, y=None):\n        return self\n\n    def transform(self, x):\n        x.Cabin.fillna('n0', inplace=True)\n        \n        x['CabinCode'] = x['Cabin'].map(lambda c : str(c)[0])\n        x['CabinCode'] = x['CabinCode'].map(lambda c : int(cabin_dict[c]))\n        x.drop('Cabin', axis=1, inplace=True)\n    \n        return x.values","068b47ea":"class FareFeaturesTransformer(BaseEstimator, TransformerMixin):\n    def __init__(self):\n        return\n        \n    def fit(self, x, y=None):\n        return self\n\n    def fillEmpty(self, fare, pclass):\n        if pd.isnull(fare):\n            return avg_fare[int(pclass)-1]\n        return fare\n    \n    def transform(self, x):\n        x['Fare'] = x.apply(lambda c :  self.fillEmpty(c['Fare'], c['Pclass']), axis=1)\n        x.drop('Pclass', axis=1, inplace=True)\n        \n        return x.values","7c4ba473":"class TicketFeaturesTransformer(BaseEstimator, TransformerMixin):\n    def __init__(self):\n        return\n        \n    def fit(self, x, y=None):\n        return self\n\n    def transform(self, x):\n        x.Ticket.fillna('NUM 0', inplace=True)\n        \n        x['TicketCode'] = x['Ticket'].map(lambda c : c.split()[0])\n        x['TicketCode'] = x['TicketCode'].map(lambda c : c if not(c.isdigit()) else 'NUM')\n        x['TicketCode'] = x['TicketCode'].map(lambda c : int(code_dict[c]) if c in code_dict else code_dict['Y'])\n        x['TicketNum'] = x['Ticket'].map(lambda c : c.split()[-1])\n        x['TicketNum'] = x['TicketNum'].map(lambda c : int(c) if c.isdigit() else 0)\n        x.drop('Ticket', axis=1, inplace=True)\n    \n        return x.values","16f57769":"# Preprocessing for categorical data\ncategorical_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='most_frequent')),\n    ('onehot', OneHotEncoder(handle_unknown='ignore'))\n])\n\n# Define model\nmodel = RandomForestClassifier(random_state=2)\n\n# Bundle preprocessing for numerical and categorical data\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('ticket', TicketFeaturesTransformer(), ['Ticket']),\n        ('names', NameAgeFeaturesTransformer(), ['Name','Age']),\n        ('cabin', CabinFeaturesTransformer(), ['Cabin']),\n        ('fare', FareFeaturesTransformer(), ['Fare','Pclass']),\n        ('cat', categorical_transformer, ['Embarked'])#categorical_cols)\n    ])\n\n\n# Bundle preprocessing and modeling code in a pipeline\npipeline = Pipeline(steps=[('preprocessor', preprocessor)\n                            ,('model', model)\n                          ])\n\npipeline.fit(X_train, y_train)","1c914bce":"trans_train = pd.DataFrame(preprocessor.fit_transform(X_train, y_train))\ntrans_train.columns = ['TicketCode', 'TicketNum', \n                       'Age', 'Title', #'Company',\n                       'NameLen', \n                       'CabinCode', 'Fare',\n                       #'SexA', 'SexB', \n                       'EmbarkedA', 'EmbarkedB', 'EmbarkedC']\ntrans_train['Survived'] = y_train\nsns.heatmap(trans_train.corr())","263aaaec":"parameters = { \n    'model__n_estimators': [560, 580, 600, 620, 640],\n}\n\ngrid_search = GridSearchCV(pipeline, parameters, scoring = 'neg_mean_absolute_error', n_jobs= 1, cv=3)\n#grid_search.fit(X_train, y_train)\ngrid_search.fit(X_full, y)","7c815318":"print(grid_search.best_params_) #450\nprint(-1 * grid_search.best_score_) #16722783389450058#0.16610549943883277","9166d3b1":"model = RandomForestClassifier(random_state=2, n_estimators=580)\npipeline = Pipeline(steps=[('preprocessor', preprocessor)\n                            ,('model', model)\n                          ])\n\npipeline.fit(X_full.drop(['Survived'], axis=1), y)#train, y_train)\npredict = pipeline.predict(X_test_full.drop(['PassengerId'], axis=1))","46b18a50":"out = pd.DataFrame({'PassengerId': X_test_full['PassengerId'], 'Survived': predict})\nout['Survived'] = out.apply(lambda x : int(x['Survived']), axis=1)\nout.to_csv('titanicOut.csv', index=False)","dcc7e6ac":"out = pd.read_csv('titanicOut.csv')\nout","19e15a7a":"# Clean","94801d55":"# Define groups","a05aa268":"at the end I will try to find best parameters. It happened there is only one, but probably there will be another as I'll explore this field more. Just be carefull as it takes reaaalllly long time to process","a01a7d6d":"get average *Fare* in given *Pclass* from both datasets (test\/train)","bc50fcfe":"Format the result into the file requested by competition rules","95bf041d":"First transformer takes *Name* and *Age* columns. It takes both of them because imputed *Age* depends on *Title* which will be extracted from *Name*, there I process them together.\n*Name* column will provide information about *Title* mentioned before. Also it creates column *Company* which held 0\/1 value depending if there is some other name given in parentheses. Last info I used from name feature is *NameLen* which indicates word number ","92a3238c":"*Fare* column is missing only in one case, but for clean code I've made them transformer too.\nIt takes average *Fare* per *Pclass* as was precomputed earlier","fa93b3f6":"make dictionary based on listed values. it will translate each ticket type into one of survival group","0a11a735":"get average survival chance. we will use them for values which are only in testdata","6088ea5f":"Create dataframe which connects both train and test data and prepare array of average age per each title.\nI have decided to split titles into male and female columns to provide another kind of information","ae55c5e6":"Next line will show results of grid search. Parameters shown will be used in my final step","db59e9f7":"Create columns group we want to deal with","87955262":"# Define custom transformers for columns we want to work with in a special way","13b20b9c":"there was obvious huge correlation between Sex and Title so I drop Sex column as Title says much more.<br>\nHuge correlation seems to be between Company vs Title and between NameLend vs Company. Omitting Company should solve both problems<br>\ncorrelation between different Embarked version is logical","11da4743":"Finaly put it all together into whole pipeline and get prediction for test dataset","a6a778bd":"crate groups for categorical columns with huge number of options. Group them by their chance to survive","6e1c97b1":"*Ticket* transformer split its column into character *TicketCode* and number *TicketNum*.\nAs there is huge number of different *TicketCodes*, I tried to group them by their common substrings manualy.\nThose groups have asigned integer value from dictionary. At the end I have values 0-9 in *TicketCodes*.","3d0bf58d":"# Read data\nRead all the data and split it into train\/test part\nSee all the empty spaces in train\/test data","219851fb":"And visualy check that there's no nonsense","b8cad88a":"Import everithing we need at one place","4434d560":"In next step I will create pipeline consisting of transformers defined above and RandomForest model","574f43b6":"sort cabin values by their survival chances to make its function less bumpy","79d8a363":"Most of the *Cabin* info is missing, little bit of *Fare* an significant amount of *Age*.\nI will try to impute *Age* according to specific age groups which will arise from title given in *Name* column.\n*Fare* will be mean of Fares in the same *Pclass*\nEmpty *Cabin* info will have specific constant value.","bcf100b6":"just check how does the final dataframe look","970a4db8":"# Params search","d8bd56fd":"# Pipeline","8668d9dc":"# Predict and save output","e76900fb":"*Cabin* feature is quit often null in both datasets. Missing values are filled with constant and other are left only with their first letter indicating cabin group. Numbers doesn't seem usefull for me"}}