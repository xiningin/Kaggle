{"cell_type":{"cf88021d":"code","77aa9712":"code","c026f536":"code","ab1d7adb":"code","fb0c3387":"code","9d84a306":"code","b2a3ef79":"code","17445004":"code","793f97c3":"code","12341102":"code","005e8bfe":"code","78e0cc79":"code","8eb6e060":"code","582dba2a":"code","5b8e55b8":"markdown","adfa9f48":"markdown"},"source":{"cf88021d":"import numpy as np\nimport pandas as pd\n\nimport os\nimport json\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors\nimport math\nfrom pathlib import Path\n\n\ndata_path = Path('\/kaggle\/input\/abstraction-and-reasoning-challenge')\ntraining_path = data_path \/ 'training'\nevaluation_path = data_path \/ 'evaluation'\ntest_path = data_path \/ 'test'\n\ntraining_tasks = sorted(os.listdir(training_path))\nevaluation_tasks = sorted(os.listdir(evaluation_path))\ntest_tasks = sorted(os.listdir(test_path))\n","77aa9712":"def plot_one(img, pred, correct):\n    cmap = colors.ListedColormap(\n        ['#000000', '#0074D9', '#FF4136', '#2ECC40', '#FFDC00',\n         '#AAAAAA', '#F012BE', '#FF851B', '#7FDBFF', '#870C25'])\n    norm = colors.Normalize(vmin=0, vmax=9)\n\n    fig, axs = plt.subplots(3, 1, figsize=(3 * 1, 3 * 3))\n    ax = axs[0]\n    input_matrix = img\n\n    ax.imshow(input_matrix, cmap=cmap, norm=norm)\n    ax.grid(True, which='both', color='lightgrey', linewidth=0.5)\n    ax.set_yticks([x - 0.5 for x in range(1 + len(input_matrix))])\n    ax.set_xticks([x - 0.5 for x in range(1 + len(input_matrix[0]))])\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n    ax.set_title(\"test input\")\n\n    ax = axs[1]\n    # print(pred)\n    # print(pred)\n    input_matrix = pred\n    ax.imshow(input_matrix, cmap=cmap, norm=norm)\n    ax.grid(True, which='both', color='lightgrey', linewidth=0.5)\n    ax.set_yticks([x - 0.5 for x in range(1 + len(input_matrix))])\n    ax.set_xticks([x - 0.5 for x in range(1 + len(input_matrix[0]))])\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n    ax.set_title(\"test pred\")\n    # plt.show()\n\n    ax = axs[2]\n    # print(correct)\n    input_matrix = correct\n    ax.imshow(input_matrix, cmap=cmap, norm=norm)\n    ax.grid(True, which='both', color='lightgrey', linewidth=0.5)\n    ax.set_yticks([x - 0.5 for x in range(1 + len(input_matrix))])\n    ax.set_xticks([x - 0.5 for x in range(1 + len(input_matrix[0]))])\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n    ax.set_title(\"test correct\")\n    plt.show()\n","c026f536":"def hokan_tate(img, check_color):\n    \"\"\"\n    \u7e26\u306b\u5207\u308a\u307e\u3059\n    \"\"\"\n    print(check_color, \"check color\")\n    img_old = img.copy()\n    print(np.where(img == 0, 1, 0).sum())\n    for j in range(4, img.shape[1]):\n        data = img[:, :j]\n        # print(data)\n        # if j % 2 == 0:\n        data1 = data[:, :j \/\/ 2]\n        if j % 2 == 0:\n            data2 = data[:, j \/\/ 2:][:, ::-1]\n        else:\n            data2 = data[:, j \/\/ 2 + 1:][:, ::-1]\n\n        # data2 = data[:, j\/\/2:][:, ::-1]\n        not_diff = np.where(data1 == data2, 1, 0)\n        # print(len(data1))\n        # print(not_diff)\n        wariai = not_diff.sum() \/ not_diff.size\n        # print(wariai)\n        if wariai > 0.8:\n            # print(wariai)\n            print(data1.shape)\n            for k in range(data1.shape[0]):\n                for l in range(data1.shape[1]):\n\n                    d1 = data1[k, l]\n                    d2 = data2[k, l]\n                    print(d1, d2, \"------------\")\n                    if d1 == check_color and d2 != check_color:\n                        img[k, l] = d2\n                    elif d2 == check_color and d1 != check_color:\n                        # print(d1, d2, \"-------------------\")\n                        # o = math.floor(l)\n                        x = data1.shape[1] - l + data.shape[1] - 1\n                        # print(k, x)\n                        img[k, x] = d1\n    # print(img)\n    # plot_one(img_old, img)\n    print(np.where(img == 0, 1, 0).sum())\n    # return img\n    # assert 0\n    print(\"-\" * 30)\n\n    for j in range(img.shape[1], 5, -1):\n        # data = img[:, h - j:]\n        h = img.shape[0]\n        data = img[:, h - j:]\n        # print(data)\n        data1 = data[:, :j \/\/ 2]\n        if j % 2 == 0:\n            data2 = data[:, j \/\/ 2:][:, ::-1]\n        else:\n            data2 = data[:, j \/\/ 2 + 1:][:, ::-1]\n\n        # data2 = data[:, j\/\/2:][:, ::-1]\n        not_diff = np.where(data1 == data2, 1, 0)\n        # print(len(data1))\n        # print(not_diff)\n        wariai = not_diff.sum() \/ not_diff.size\n        print(wariai)\n        if wariai > 0.8:\n            # print(wariai)\n            print(\"\u6b63\u89e3\")\n            print(data1.shape)\n            for k in range(data1.shape[0]):\n                for l in range(data1.shape[1]):\n                    d1 = data1[k, l]\n                    d2 = data2[k, l]\n                    if d1 == check_color and d2 != check_color:\n                        x = h + l - data1.shape[1] * 2\n                        # print(wariai, \"---------------\u3042\u3042\u3042\u3042\u3042\")\n                        # print(j, k, l, d1, d2, \"-----------\")\n                        # print(data1)\n                        # print(data2)\n                        # print(d1)\n                        # print(d2)\n                        img[k, x] = d2\n\n                    elif d2 == check_color and d1 != check_color:\n                        # print(j, k, l)\n\n                        x = h - l - 1\n                        img[k, x] = d1\n    # print(img)\n    print(np.where(img == 0, 1, 0).sum())\n\n    if np.where(img == 0, 1, 0).sum() == 0:\n        # print(img)\n        return img\n    else:\n        return img\n\n\ndef hokan_naname(img, check_color):\n    \"\"\"\n    \u6b63\u65b9\u5f62\u3092\u53d6\u3063\u3066\u304d\u3066x, y\u53cd\u8ee2\n    \"\"\"\n    print(check_color, \"check color\")\n    print(\"\u659c\u3081\")\n    img_old = img.copy()\n    print(np.where(img == 0, 1, 0).sum())\n    for j in range(4, img.shape[1]):\n        data = img[img.shape[1] - j:, :j]\n        # rint(data.shape)\n        # print(data)\n        # if j % 2 == 0:\n        data1 = np.zeros_like(data)\n        data2 = data.copy()\n        for x in range(data.shape[0]):\n            for y in range(data.shape[1]):\n                data1[y, x] = data[x, y]\n\n        # print(data1)\n        # print(data2)\n\n        # data2 = data[:, j\/\/2:][:, ::-1]\n        not_diff = np.where(data1 == data2, 1, 0)\n        # print(len(data1))\n        # print(not_diff)\n        wariai = not_diff.sum() \/ not_diff.size\n        # print(wariai)\n        if wariai > 0.8:\n            # print(wariai)\n            print(\"\u6b63\u89e3\")\n            # print(data)\n            # print(data1.shape)\n            for k in range(data1.shape[0]):\n                for l in range(data1.shape[1]):\n\n                    d1 = data1[k, l]\n                    d2 = data2[k, l]\n                    # print(d1, d2)\n                    # print(d1, d2, \"------------\")\n                    if d1 == check_color and d2 != check_color:\n                        data[l, k] = d2\n                        img[img.shape[1] - j:, :j] = data.copy()\n\n                    elif d2 == check_color and d1 != check_color:\n                        # print(d1, d2, \"-------------------\")\n                        # o = math.floor(l)\n                        x = data1.shape[1] - l + data.shape[1] - 1\n                        # print(k, x)\n                        data[k, l] = d1\n                        img[img.shape[1] - j:, :j] = data.copy()\n\n    # print(img)\n    # plot_one(img_old, img)\n    print(np.where(img == 0, 1, 0).sum())\n    # return img\n    # assert 0\n    print(\"-\" * 30)\n\n    for j in range(img.shape[1], 4, -1):\n        # data = img[:, h - j:]\n        h = img.shape[0]\n        data = img[:j, :j]\n        # print(data)\n        # if j % 2 == 0:\n        data1 = np.zeros_like(data)\n        data2 = data.copy()\n        for x in range(data.shape[0]):\n            for y in range(data.shape[1]):\n                data1[y, x] = data[x, y]\n        # data2 = data[:, j\/\/2:][:, ::-1]\n        not_diff = np.where(data1 == data2, 1, 0)\n        # print(len(data1))\n        # print(not_diff)\n        wariai = not_diff.sum() \/ not_diff.size\n        print(wariai)\n        if wariai > 0.8:\n            # print(wariai)\n            print(\"\u6b63\u89e3\")\n            print(data1.shape)\n            for k in range(data1.shape[0]):\n                for l in range(data1.shape[1]):\n                    d1 = data1[k, l]\n                    d2 = data1[l, k]\n                    if d1 == check_color and d2 != check_color:\n                        img[l, k] = d2\n\n                    elif d2 == check_color and d1 != check_color:\n\n                        img[k, l] = d1\n    # print(img)\n    print(np.where(img == 0, 1, 0).sum())\n\n    if np.where(img == 0, 1, 0).sum() == 0:\n        # print(img)\n        return img\n    else:\n        return img\n\n\ndef hokan_yoko(img, check_color):\n    \"\"\"\n    \u6a2a\u306b\u5207\u308a\u307e\u3059\n    \"\"\"\n    print(check_color, \"check color\")\n    print(\"Yokonikiruo\")\n    new = np.rot90(img)\n    new = hokan_tate(new, check_color)\n    # print(new, \"new\u3060\u304a\")\n    new = np.rot90(new, 3)\n    return new","ab1d7adb":"def complement(img, checkcolor):\n    i = 0\n    while np.where(img == checkcolor, 1, 0).sum() != 0 and i < 3:\n        img = hokan_naname(img, checkcolor)\n        img = hokan_tate(img, checkcolor)\n        img = hokan_yoko(img, checkcolor)\n        i += 1\n    return img","fb0c3387":"class Features:\n    def __init__(self, task):\n        self.task = task\n        self.df = pd.DataFrame()\n\n    def features(self):\n        # print(self.task[\"train\"])\n        for j, t in enumerate(self.task[\"train\"]):\n            t_in, t_out = np.array(t[\"input\"]), np.array(t[\"output\"])\n\n            \"\"\"\n            \u547d\u540d\u898f\u5247\u306f\u30ce\u30ea\u304c\u591a\u3044\u304c\u3001input\u3068output\u3067\u540c\u3058\u7279\u5fb4\u91cf\u3092\u4f5c\u6210\u3059\u308b\u3068\u304d\u306f\u982d\u306bin out\u3092\u3064\u3051\u308b\n            \n            A_eq_B\u306fA\u3068B\u304c\u7b49\u3057\u3044\u304b\u3069\u3046\u304b\n            \n            \u306a\u3069\u7b97\u8853\u8a18\u53f7\u306f\u30ce\u30ea\u304c\u591a\u3044\u306e\u3067\u611f\u899a\u3067\u8aad\u3093\u3067\u3082\u3089\u3044\u305f\u3044\u304c\u30ce\u30ea\u3067\u8aad\u3081\u306a\u3044\u3082\u306e\u306b\u306f\u30b3\u30e1\u30f3\u30c8\u3092\u4ed8\u3051\u3066\u3044\u308b\n            \"\"\"\n\n            \"\"\"\n            \u30b5\u30a4\u30ba\u306b\u95a2\u3059\u308b\u7279\u5fb4\u91cf\n            \"\"\"\n\n            self.df.loc[j, \"in_height\"] = t_in.shape[0]\n            self.df.loc[j, \"in_width\"] = t_in.shape[1]\n            self.df.loc[j, \"out_height\"] = t_out.shape[0]\n            self.df.loc[j, \"out_width\"] = t_out.shape[1]\n\n            self.df.loc[j, \"in_height_eq_width\"] = t_in.shape[0] == t_in.shape[1]\n            self.df.loc[j, \"out_height_eq_width\"] = t_out.shape[0] == t_out.shape[1]\n\n            self.df.loc[j, \"in_out_height_eq\"] = t_in.shape[0] == t_out.shape[0]\n            self.df.loc[j, \"in_out_width_eq\"] = t_in.shape[1] == t_out.shape[1]\n\n            self.df.loc[j, \"height_out_div_in_R\"] = t_out.shape[0] % t_in.shape[0]\n            self.df.loc[j, \"width_out_div_in_R\"] = t_out.shape[1] % t_in.shape[1]\n\n            \"\"\"\n            \u8272\u306b\u95a2\u3059\u308b\u7279\u5fb4\u91cf\n            \"\"\"\n            in_uq = np.unique(t_in)\n            out_uq = np.unique(t_out)\n            self.df.loc[j, \"in_unique_colors\"] = len(in_uq)\n            self.df.loc[j, \"out_unique_colors\"] = len(out_uq)\n\n            self.df.loc[j, \"in_unique_colors_off_black\"] = len(in_uq[in_uq != 0])\n            self.df.loc[j, \"out_unique_colors_off_black\"] = len(out_uq[out_uq != 0])\n\n            # self.df.loc[j, \"in_unique_colors\"] = in_uq\n            # self.df.loc[j, \"out_unique_colors\"] = out_uq\n            for i in range(10):\n                name = \"colors_diff_\" + str(i)\n                self.df.loc[j, name] = not (i in in_uq) ^ (i in out_uq)\n\n            \"\"\"\n            \u30d6\u30ed\u30c3\u30af\u306b\u95a2\u3059\u308b\u7279\u5fb4\u91cf\n            \"\"\"\n            in_blocks = np.where(t_in == 0, 0, 1)\n            out_blocks = np.where(t_out == 0, 0, 1)\n            self.df.loc[j, \"in_blocks_num\"] = np.sum(in_blocks)\n            self.df.loc[j, \"out_blocks_num\"] = np.sum(out_blocks)\n            # \u30d6\u30ed\u30c3\u30af\u6570\u3068\u5168\u4f53\u306e\u30de\u30b9\u306e\u6bd4\u7387\n            self.df.loc[j, \"in_blocks_ratio\"] = np.sum(in_blocks) \/ len(in_blocks)\n            self.df.loc[j, \"out_blocks_ratio\"] = np.sum(out_blocks) \/ len(out_blocks)\n\n            self.df.loc[j, \"ratio_in_eq_out\"] = (np.sum(in_blocks) \/ len(in_blocks)) == (\n                    np.sum(out_blocks) \/ len(out_blocks))\n\n        all_true_columns = np.zeros(len(self.df.columns))\n\n        for i, x in enumerate(self.df.columns):\n            if self.df[x].all():\n                all_true_columns[i] = 1\n\n        self.df.loc[len(self.task[\"train\"]), :] = all_true_columns\n        # print(all_true_columns)\n        # print(self.df)\n\n        return self.df\n\n    def tentaisho(self, img):\n        o_x, o_y = img.shape[0] \/ 2, img.shape[1] \/ 2\n        new = np.zeros_like(img)\n        for i in range(img.shape[0]):\n            for j in range(img.shape[1]):\n                x = o_x + o_x - i\n                y = o_y + o_y - i\n                new[i, j] = img[x, y]\n        return new\n\n\ndef rule(data_old, test_task):\n    test_task = np.array(test_task)\n    data = data_old.iloc[:-1]\n    bool_data = data_old.iloc[-1]\n    if np.all(bool_data.iloc[:6] == 1):\n        if data.loc[0, \"in_height\"] > 15:\n            print(\"\u88dc\u5b8c\u3067\u3059\u306d\")\n            check_color = 0\n            for j in range(10):\n                name = \"colors_diff_\" + str(j)\n                # print(name)\n\n                if bool_data[name] == 0:\n                    check_color += j\n                    break\n            # plot_one(test_task, test_task, test_task)\n            img = complement(test_task, check_color)\n            # return img\n            return img\n        return test_task\n    return test_task\n","9d84a306":"def main(i):\n    path = training_tasks[i]\n    task_file = str(training_path \/ path)\n\n    with open(task_file, \"r\") as f:\n        task = json.load(f)\n\n    fea = Features(task)\n    test_task = task[\"test\"][0][\"input\"]\n    bool_fe = fea.features()\n    pred = rule(bool_fe, test_task)\n    test_y = np.array(task[\"test\"][0][\"output\"])\n    print((test_y == pred).all())\n    print(\"DONE\")\n    \n    return test_task, pred, test_y","b2a3ef79":"test_task, pred, test_y = main(16)","17445004":"plot_one(test_task, pred, test_y)","793f97c3":"test_task, pred, test_y = main(60)","12341102":"plot_one(test_task, pred, test_y)","005e8bfe":"test_task, pred, test_y = main(174)","78e0cc79":"plot_one(test_task, pred, test_y)","8eb6e060":"test_task, pred, test_y = main(73)","582dba2a":"plot_one(test_task, pred, test_y)","5b8e55b8":"# Test","adfa9f48":"# Our approach about complement\nWe focused on line symmetry. \n\n1. We focused on line symmetry. Creates line symmetry with vertical, horizontal and oblique axes.\n2. Find the match rate of each paired block.(We have set the threshold to 70%.)\n3. Complement.\n\nThe blocks to be complemented take the difference between the input and output colors.\n\nWe submitted using this method, but the score was 1.00.\n\nMy code is dirty...Sorry"}}