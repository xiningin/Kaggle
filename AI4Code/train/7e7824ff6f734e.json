{"cell_type":{"ee461cc0":"code","a3851b3a":"code","7fd0094b":"code","6908ce0a":"code","37997aae":"code","1d3ca3d1":"code","d8c55b96":"code","630034de":"code","88bd0aa0":"code","fcf1977e":"code","10695ba8":"code","39cceeb1":"code","3ba4587e":"code","5b3f1ef2":"code","143083b9":"code","bd792bce":"code","151b0238":"code","99ee7a92":"markdown","56a5fb03":"markdown"},"source":{"ee461cc0":"import pandas as pd\nimport numpy as np\nimport tensorflow as tf\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport os\nimport cv2","a3851b3a":"\nos.listdir('\/kaggle\/input\/lego-minifigures-classification\/')\n","7fd0094b":"index=pd.read_csv('..\/input\/lego-minifigures-classification\/index.csv')\nindex.head()","6908ce0a":"metadata=pd.read_csv('..\/input\/lego-minifigures-classification\/metadata.csv')\nmetadata.head()","37997aae":"df = pd.merge(index, metadata[['class_id', 'minifigure_name']], on='class_id')\ndf.head()\n","1d3ca3d1":"#CHECKING IF THE IS ANY MISSING VALUES\ndf.isnull().sum()","d8c55b96":"hero_name=df['minifigure_name'].unique()\nhero_name","630034de":"count=df['minifigure_name'].value_counts()\ncount","88bd0aa0":"\nplt.figure(figsize=(12,10))\nsns.barplot(x=hero_name, y=count,palette='rocket')\n\nplt.xticks(rotation= 90)\nplt.xlabel('SUPERHERO')\nplt.ylabel('Count')\nplt.title('Dataset Analysis')\nplt.show()","fcf1977e":"HERO=tf.keras.models.Sequential([tf.keras.layers.Conv2D(16,(3,3),activation='relu',input_shape=(512,512,3)),\n                                tf.keras.layers.MaxPooling2D(2,2),\n                                tf.keras.layers.Dropout(0.2),\n                                tf.keras.layers.Conv2D(32,(3,3),activation='relu'),\n                                tf.keras.layers.MaxPooling2D(2,2),\n                                tf.keras.layers.Dropout(0.2),\n                                 tf.keras.layers.Conv2D(32,(3,3),activation='relu'),\n                                tf.keras.layers.MaxPooling2D(2,2),\n                                tf.keras.layers.Dropout(0.2),\n                                  tf.keras.layers.Conv2D(64,(3,3),activation='relu'),\n                                tf.keras.layers.MaxPooling2D(2,2),\n                                tf.keras.layers.Dropout(0.2),\n                                  tf.keras.layers.Conv2D(64,(3,3),activation='relu'),\n                                tf.keras.layers.MaxPooling2D(2,2),\n                                tf.keras.layers.Dropout(0.2),\n                                \n                                tf.keras.layers.Conv2D(128,(3,3),activation='relu'),\n                                tf.keras.layers.MaxPooling2D(2,2),\n                                tf.keras.layers.Dropout(0.2),\n                                tf.keras.layers.Flatten(),\n                                tf.keras.layers.Dense(512,activation='relu'),\n                                tf.keras.layers.Dense(31,activation='softmax')])\nHERO.summary()","10695ba8":"#Splitting into train and validation\n\ntraining = df[df[\"train-valid\"] == 'train']\nvalidation = df[df[\"train-valid\"] == 'valid']\n","39cceeb1":"trainD = np.zeros((training.shape[0], 512, 512, 3))\n\nfor i in range(training.shape[0]):\n    \n    image = cv2.imread('..\/input\/lego-minifigures-classification\/' + training[\"path\"].values[i])\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    image = cv2.resize(image, (512,512))\n    \n\n    trainD[i] = image \/ 255.0\n\ntrainL = np.array(training[\"class_id\"])-1","3ba4587e":"\n\nvalidD = np.zeros((validation.shape[0], 512, 512, 3))\n\nfor i in range(validation.shape[0]):\n    \n    image = cv2.imread('..\/input\/lego-minifigures-classification\/' + validation[\"path\"].values[i])\n    \n    #Converting BGR to RGB \n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    \n    #Resizing image to (512 x 512)\n    image = cv2.resize(image, (512,512))\n    \n    #Normalizing pixel values to [0,1]\n    validD[i] = image \/ 255.0\n\nvalidL = np.array(validation[\"class_id\"])-1\n","5b3f1ef2":"class mycallbacks(tf.keras.callbacks.Callback):\n    def on_epoch_end(self,epochs,logs={}):\n        if(logs.get('accuracy')>1.0):\n            self.model.stop_training=True","143083b9":"def create_model(input_shape):\n    # initialize the base model as VGG16 model with input shape as (512,512,3)\n    base_model = tf.keras.applications.MobileNetV2(input_shape = input_shape,\n                       include_top = False,\n                       weights = 'imagenet')\n\n    # we do not have to train all of the layers\n    for layer in base_model.layers:\n        layer.trainable = False\n        \n    x = tf.keras.layers.Flatten()(base_model.output)\n    x = tf.keras.layers.Dense(512, activation = 'relu')(x)\n    x = tf.keras.layers.Dropout(0.6)(x)\n    x = tf.keras.layers.Dense(31, activation = 'softmax')(x)\n    \n    return tf.keras.models.Model(base_model.input,x)\nmodel = create_model((512,512,3))","bd792bce":"callbacks=mycallbacks()\nmodel.compile(optimizer=tf.keras.optimizers.Adam(lr=0.0001),\n             loss='sparse_categorical_crossentropy',\n    metrics=['accuracy'])\nhistory=model.fit(trainD,trainL,epochs=200,validation_data=(validD, validL),callbacks=[callbacks],shuffle=True,batch_size=5)","151b0238":"acc = history.history['accuracy']\nval_acc = history.history['val_accuracy']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nepochs = range(len(acc))\n\nplt.plot(epochs, acc, 'r', label='Training accuracy')\nplt.plot(epochs, val_acc, 'b', label='Validation accuracy')\nplt.title('Training and validation accuracy')\n\nplt.figure()\n\nplt.plot(epochs, loss, 'r', label='Training Loss')\nplt.plot(epochs, val_loss, 'b', label='Validation Loss')\nplt.title('Training and validation loss')\nplt.legend()\n\nplt.show()","99ee7a92":"#  BUILDING THE MODEL","56a5fb03":"# **READING THE DATA** "}}