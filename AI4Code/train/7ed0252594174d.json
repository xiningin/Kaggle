{"cell_type":{"8739a5c9":"code","6d4fac92":"code","76a7efd3":"code","16a41ba5":"code","daa79dcd":"code","771bef8f":"code","211eebcb":"code","d98381a5":"code","b976414e":"code","9cb4f6e1":"code","9bd3f86c":"code","392b659f":"code","a1c13fe6":"code","bd4565f7":"code","e9ad1c29":"code","d331ecc2":"markdown","d13a742a":"markdown","f40b5796":"markdown","5e1699c0":"markdown","efda4e8c":"markdown"},"source":{"8739a5c9":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom xgboost import XGBClassifier\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder, FunctionTransformer\nfrom sklearn import metrics","6d4fac92":"df = pd.read_csv('\/kaggle\/input\/ethereum-frauddetection-dataset\/transaction_dataset.csv')\ndf.columns = [x.lower() for x in df.columns]","76a7efd3":"ax = (df.groupby('flag')[['index']].count()\/df[['index']].count()).T.plot(\n    kind = 'barh',\n    stacked = True\n)","16a41ba5":"cols_to_drop = [\n    ' erc20 most sent token type',\n    ' erc20_most_rec_token_type',\n    'address',\n    'index',\n    'unnamed: 0'\n]\n\nfeatures = [x for x in df.columns if (x != 'flag' and x not in cols_to_drop)]","daa79dcd":"df.info()","771bef8f":"features","211eebcb":"unique_values = df.nunique()\n\nfeatures = [x for x in features if x in unique_values.loc[(unique_values>1)]]\n\nunique_values","d98381a5":"df[features].info()","b976414e":"from sklearn.base import BaseEstimator, TransformerMixin\n\n\nclass BasePipeStep(BaseEstimator, TransformerMixin):\n    \n    def __init__(self, columns):\n        self.columns = columns\n        \n    def fit(self, X, y=None):\n        return self\n    \n    def transform(self, X):\n        X = X.copy()\n        return X\n    \nclass SelectColumns(BasePipeStep):\n    \n    def transform(self, X):\n        X = X.copy()\n        return X[self.columns]\n    \nclass FillNumericData(BasePipeStep):\n    \n    def fit(self, X, y=None):\n        self.means = { col: X[col].mean() for col in self.columns}\n        return self\n        \n    def transform(self, X):\n        X = X.copy()\n        for col in self.columns:\n            X[col] = X[col].fillna(self.means[col])\n        return X\n\n\nclass ScaleNumeric(BasePipeStep):\n    \n    def fit(self, X, y=None):\n        self.scaler = StandardScaler()\n        self.scaler.fit(X[self.columns])\n        return self\n        \n    def transform(self, X):\n        X = X.copy()\n        X[self.columns] = self.scaler.transform(X[self.columns])\n        return X\n    \n","9cb4f6e1":"preprocessing = Pipeline([\n    ('feature_selection', SelectColumns(features)),\n    ('fill_missing', FillNumericData(features)),\n    ('standard_scaling', ScaleNumeric(features)),\n])\n\npipeline = Pipeline([\n    ('preprocessing', preprocessing),\n#     ('create_new_features', features),\n    ('learning', XGBClassifier(random_state=42, eval_metric='auc',\n              objective='binary:logistic') )\n])","9bd3f86c":"X = df[features]\ny = df['flag']\n\nX_train, X_test, y_train, y_test = train_test_split(\n     X, y, test_size=0.33, random_state=42)","392b659f":"pipeline.fit(X_train, y_train)\n","a1c13fe6":"from sklearn.model_selection import cross_val_score\n\n","bd4565f7":"test_prediction = pipeline.predict_proba(X_test)[:,1]\n\nscore = metrics.roc_auc_score(y_test, test_prediction)\n\nprint(f'Area under ROC of Model On Test Set - {score:,.2%}')","e9ad1c29":"test_prediction = pipeline.predict(X_test)\n\ndisp = metrics.plot_confusion_matrix(pipeline, X_test, y_test,\n#                                  display_labels=class_names,\n                                 cmap=plt.cm.Blues,\n                                 normalize='true')","d331ecc2":"# Ethereum Fraud Detection\n\nHere is a description of the rows of the dataset:\n- Index: the index number of a row\n- Address: the address of the ethereum account\n- FLAG: whether the transaction is fraud or not\n- Avg min between sent tnx: Average time between sent transactions for account in minutes\n- Avgminbetweenreceivedtnx: Average time between received transactions for account in minutes\n- TimeDiffbetweenfirstand_last(Mins): Time difference between the first and last transaction\n- Sent_tnx: Total number of sent normal transactions\n- Received_tnx: Total number of received normal transactions\n- NumberofCreated_Contracts: Total Number of created contract transactions\n- UniqueReceivedFrom_Addresses: Total Unique addresses from which account received transactions\n- UniqueSentTo_Addresses20: Total Unique addresses from which account sent transactions\n- MinValueReceived: Minimum value in Ether ever received\n- MaxValueReceived: Maximum value in Ether ever received\n- AvgValueReceived5Average value in Ether ever received\n- MinValSent: Minimum value of Ether ever sent\n- MaxValSent: Maximum value of Ether ever sent\n- AvgValSent: Average value of Ether ever sent\n- MinValueSentToContract: Minimum value of Ether sent to a contract\n- MaxValueSentToContract: Maximum value of Ether sent to a contract\n- AvgValueSentToContract: Average value of Ether sent to contracts\n- TotalTransactions(IncludingTnxtoCreate_Contract): Total number of transactions\n- TotalEtherSent:Total Ether sent for account address\n- TotalEtherReceived: Total Ether received for account address\n- TotalEtherSent_Contracts: Total Ether sent to Contract addresses\n- TotalEtherBalance: Total Ether Balance following enacted transactions\n- TotalERC20Tnxs: Total number of ERC20 token transfer transactions\n- ERC20TotalEther_Received: Total ERC20 token received transactions in Ether\n- ERC20TotalEther_Sent: Total ERC20token sent transactions in Ether\n- ERC20TotalEtherSentContract: Total ERC20 token transfer to other contracts in Ether\n- ERC20UniqSent_Addr: Number of ERC20 token transactions sent to Unique account addresses\n- ERC20UniqRec_Addr: Number of ERC20 token transactions received from Unique addresses\n- ERC20UniqRecContractAddr: Number of ERC20token transactions received from Unique contract addresses\n- ERC20AvgTimeBetweenSent_Tnx: Average time between ERC20 token sent transactions in minutes\n- ERC20AvgTimeBetweenRec_Tnx: Average time between ERC20 token received transactions in minutes\n- ERC20AvgTimeBetweenContract_Tnx: Average time ERC20 token between sent token transactions\n- ERC20MinVal_Rec: Minimum value in Ether received from ERC20 token transactions for account\n- ERC20MaxVal_Rec: Maximum value in Ether received from ERC20 token transactions for account\n- ERC20AvgVal_Rec: Average value in Ether received from ERC20 token transactions for account\n- ERC20MinVal_Sent: Minimum value in Ether sent from ERC20 token transactions for account\n- ERC20MaxVal_Sent: Maximum value in Ether sent from ERC20 token transactions for account\n- ERC20AvgVal_Sent: Average value in Ether sent from ERC20 token transactions for account\n- ERC20UniqSentTokenName: Number of Unique ERC20 tokens transferred\n- ERC20UniqRecTokenName: Number of Unique ERC20 tokens received\n- ERC20MostSentTokenType: Most sent token for account via ERC20 transaction\n- ERC20MostRecTokenType: Most received token for account via ERC20 transactions","d13a742a":"# data inspection\n\nSome of the features have missing values - the missing values may contain information, we might want to consider this when building a model.\n\nA few of the features only ever have one value. This may not be that useful","f40b5796":"# Group Sizes\n\nWe have quite an imbalanced data set, with about 70% of transactions not being fraudulante. We could experiment with SMOTE during training to handle this.","5e1699c0":"# Building a baseline model","efda4e8c":"# Load data"}}