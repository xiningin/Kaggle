{"cell_type":{"f443434d":"code","c56bd99e":"code","42dd8900":"code","8a593073":"code","ff1b1457":"code","a339dd7e":"code","9ef5197f":"code","60e950c4":"code","be04d721":"code","79aa86f2":"markdown"},"source":{"f443434d":"# -- Import Libraries -- \nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sklearn.datasets as datasets \nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, confusion_matrix","c56bd99e":"def plt_iris_data(iris):\n    plt.title('Iris Dataset')\n    \n    plt.scatter(iris.data[:, 0], iris.data[:, 1], c=iris.target)\n    plt.xlabel(iris.feature_names[0])\n    plt.ylabel(iris.feature_names[1])\n    \n    formatter = plt.FuncFormatter(lambda i, *args: iris.target_names[int(i)])\n    plt.colorbar(ticks=[0, 1, 2], format=formatter)\n    \n    plt.tight_layout()\n    plt.show()","42dd8900":"# -- handling the data -- \nimport pandas as pd\niris = datasets.load_iris() \nX = iris.data\nX = pd.DataFrame(X, columns=iris.feature_names)\nX.head()","8a593073":"X = iris.data\ny = iris.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, \n                                                                    test_size=0.2, \n                                                                    shuffle=True)","ff1b1457":"# -- plot iris data -- \nplt_iris_data(iris)","a339dd7e":"# -- define KNN model --\nclass KNN:\n    def __init__(self, X_train, Y_train, k):\n        self.X_train = X_train\n        self.Y_train = Y_train\n        self.k = k\n        \n    def euclidean_distance(self, inst1, inst2):\n        '''\n        calculate the euclidean distance between 2 rows in the dataset\n        \n        distance = sqrt( sum ( (inst1[i] - inst2[i])^2 ))\n        \n        Parameters\n        ----------\n        inst1 : array like\n        inst2 : array like\n    \n        Returns\n        -------\n        distance: float\n            the euclidean distance between 2 vectors.\n            \n        '''\n        distance = np.linalg.norm(inst1-inst2)\n        return distance\n    \n    def get_k_neighbors(self, inst1):\n        '''\n        This function return k most close neighbors of inst1\n        \n        Parameters\n        ----------\n        inst1 : array like\n        k : int\n        dataset : array like\n    \n        Returns\n        -------\n        k_neighbors : list\n        \n        '''\n        # calc distances from inst\n        distances = []\n        for inst2 in self.X_train:\n            distances.append(self.euclidean_distance(inst1, inst2))\n        \n        distances = np.asarray(distances)\n        \n        # argpartition will sort the array and return thier indices in the original array, \n        # (it will place the smalles values in the first k places, and will not continue to sort the rest of the values)\n        indices = np.argpartition(distances,self.k)\n        \n        # return the first k neighbors indices\n        k_first_indices = indices[:self.k]  \n        \n        return k_first_indices\n    \n    def predict_class(self, inst1):\n        '''\n\n        Parameters\n        ----------\n        inst1 : array like\n            a vector that we try to predict its class\n\n        Returns\n        -------\n        mode : int\n            the class of inst1\n\n        '''\n        knn_indices = self.get_k_neighbors(inst1)\n        knn_labels = []\n        for i in knn_indices:\n            knn_labels.append(self.Y_train[i])\n        \n        # count number of occurrences of each value\n        occurrences = np.bincount(knn_labels)\n        \n        # clac inst1 label by finding the mode \n        mode = np.argmax(occurrences)\n        \n        return mode\n    \n    def get_accuracy(self, y_test, predictions):\n        correct = y_test == predictions\n        acc = ( np.sum(correct) \/ y_test.shape[0] ) * 100.0\n        return acc\n","9ef5197f":"# -- try for different values of k -- \nK = [1, 5, 10, 50]\n    \nfor k in K:\n    classifier = KNN(X_train, y_train, k)\n        \n    # -- Test Acc -- \n    predictions=[]\n    for inst in X_test:\n        predictions.append(classifier.predict_class(inst))\n        \n    acc = classifier.get_accuracy(y_test, predictions)\n        \n    print(\"accuracy for k=\", k, \": \", acc, \"%\")","60e950c4":"print(confusion_matrix(y_test, predictions))","be04d721":"print(classification_report(y_test, predictions))","79aa86f2":"# **Iris classification - using KNN**"}}