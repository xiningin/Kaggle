{"cell_type":{"70fd252c":"code","3f49f86f":"code","6bb944f4":"code","6843482c":"code","995c22a5":"code","f43fbbbb":"code","da5743f8":"markdown","0c3d1c87":"markdown","1562496f":"markdown","6d3f35ee":"markdown","8b29e318":"markdown","265f3339":"markdown","4cc6e067":"markdown","9a952a5f":"markdown","ce2fb664":"markdown","b7e39b14":"markdown","51d22727":"markdown","b36b1965":"markdown"},"source":{"70fd252c":"def fib_tree(n):\n    if n in [0,1]:\n        return n\n    else:\n        return (fib_tree(n-1) + fib_tree(n-2))\n\nfib_tree(5)","3f49f86f":"%%time\nfib_tree(40)","6bb944f4":"def fib_iter(n): \n    def helper(a, b, counter):\n        #print(f\"Calling loop for counter = {counter}\")\n        if counter == 0:\n            return b\n        else:\n            return helper(a+b, a, counter-1)\n    return helper(1, 0, n)","6843482c":"%%time\nfib_iter(40)","995c22a5":"def fib_memo(n):\n    memo = {0:0, 1:1}\n    def helper(x):\n        if x in memo:\n            return memo[x]\n        else:\n            memo[x] = helper(x-1) + helper(x-2)\n            return memo[x]\n    return helper(n)","f43fbbbb":"%%time\nfib_memo(40)","da5743f8":"Now, let's get back to measuring the running time for calculating the 40th Fibonacci no:","0c3d1c87":"Here's the iterative (tail-recursive) solution from SICP:\n```scheme\n(define (fib_iter n)\n    (define (helper a b count)\n          (if (= count 0)\n              b\n              (helper (+ a b) a (- count 1))))\n    (helper 1 0 n))\n```\n\nNotice, how we again define an internal helper function and state variables like we did for the iterative factorial procedure above. Next, I'll convert the code into Python & see if we can improve the performance.","1562496f":"Alright then, if you are one of those people that get excited about concepts like recursion, and want to explore functional programming more, I'd highly encourage you to read SICP. I've written another blog post on my experience with studying SICP [here](https:\/\/pritesh-shrivastava.github.io\/blog\/2020\/08\/30\/sicp-so-far). If you're more of a MOOC person, the [Programming Languages](https:\/\/www.coursera.org\/learn\/programming-languages) course by Prof Dan Grossman on Coursera is really amazing, do check it out!","6d3f35ee":"As we can see from the figure, we end up doing a lot of redundant computation to calculate `(fib_tree 5)`. This process blows up exponentially with the input `n`. Below, I've implemented the same tree recursive procedure, `fib_tree`, in Python:","8b29e318":"### Memoization\n\nNotice the missing \"r\" :D Memoization is a programming idiom that can help improve the performance of recursive procedures by storing intermediate results into a cache (memo). So if we end up calling a function with some common values, duplicate function calls that we saw in the figure above can be avoided.\n\nWriting memoization in a functional language like Scheme though looks awkward, as it veers away from \"pure\" functional programming by mutating the value of the cache:\n\n```scheme\n(define fib_memo\n    (letrec\n            ( (memo null)\n              (f (lambda (x)\n                  (let ((ans (assoc x memo)))\n                       (if ans (cdr ans)\n                               (let ((new-ans (if (or (= x 1) (= x 2))\n                                                  1\n                                                  (+ (f (- x 1))(f (- x 2))))))\n                                                  (begin (set! memo (cons (cons x new-ans) memo))\n                                                         new-ans)))))])\n            f))\n```","265f3339":"I've added the Python implementation below which admittedly looks much easier to read. I've made 1 important change though. Instead of the list data structure, I'm using the Python dictionary, an abstract data type that's implemented as a hash table, and so should add some performance benefit in lookup. I've also initialized the dictionary (memo) for the nos 0 & 1, ie, the base cases.","4cc6e067":"Let's see the time taken by this exponential process takes to compute the 40th Fibonacci no:","9a952a5f":"![Fib(5](http:\/\/www.sicpdistilled.com\/images\/fib5-c4308cf0.png)","ce2fb664":"In this post, I want to talk about 2 very interesting concepts of tree recursion & memoization, which I've been exploring in the wonderful book, [SICP](https:\/\/sarabander.github.io\/sicp\/html\/index.xhtml#SEC_Contents) ([here's why](https:\/\/gist.github.com\/jrajav\/4076068)). I've also tried to re-implement these concepts from the language Scheme, used in SICP, to Python, to reinforce my understanding of these concepts & also to explore functional programming paradigm in Python.\n\nBefore we dive in, here's a very short primer on one of my favorite concepts in programming, [recursion](https:\/\/www.google.com\/search?q=recursion),\n\n### Recursion\n\nOne of the quintessential examples of a recursive procedure is the factorial function. Here's the Lisp (Scheme) code from [SICP](https:\/\/sarabander.github.io\/sicp\/html\/1_002e2.xhtml#g_t1_002e2_002e1) to describe factorial, a function that calls itself recursively:\n```scheme\n(define (factorial n)\n  (if (= n 1) \n      1 \n      (* n (factorial (- n 1)))))\n```\n\nRecursive procedures for functions like factorial are often intuitive to write due to their similarity with the mathematical definitions. However, their performance is not always optimal (Consider the no. of delayed multiplications that keep getting added to the stack until we reach the base case). To overcome this challenge, we can re-write these procedures using state variables that describe each intermediate state completely, ie, using iteration. We can define such iterative processes using recursive procedures as well, by using tail recursion. Here's the tail recursive (iterative) procudure for implementing factorial from SICP in Scheme:\n```scheme\n(define (factorial n) \n    (define (helper product counter max-count)\n      (if (> counter max-count)\n          product\n          (helper (* counter product)\n                     (+ counter 1)\n                     max-count)))\n    (helper 1 1 n))\n```\n\n### Tree Recursion\nAlright, so now let's focus on a special kind of recursive procedure, tree recursion, where each function call can spawn mutliple recursive function calls. The most classic example for this is the function to compute Fibanacci numbers. [Here's](https:\/\/sarabander.github.io\/sicp\/html\/1_002e2.xhtml#g_t1_002e2_002e2) the Scheme code from SICP:\n```scheme\n(define (fib_tree n)\n  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        (else (+ (fib_tree (- n 1))\n                 (fib_tree (- n 2))))))\n```\nWhile this is a mathematically intuitive way to write the function, the function `fib_tree` calls itself twice each time it is invoked. The tree-recursive process generated while computing the 5th Fiboncci no is shown below (courtesy SICP):","b7e39b14":"*37 s!* That's clearly a terrible way to compute Fibonacci nos. We can improve the time complexity of this process if we use tail recursion instead.\n\n    ","51d22727":"61 $\\mu$s is slightly more than the 26.7 $\\mu$s taken by the tail recurisve procedure but still 10<sup>6<\/sup> orders of magnitude faster than the tree recursive procedure !! That's because once we compute Fibonacci(5) say and store it to our cache, the subsequent calls will access it's value in near constant time from the Python dictionary.","b36b1965":"26 x 10<sup>-6<\/sup>s vs 36.8 s!\nThis is faster than the tree recursive procedure by 10<sup>6<\/sup> orders of magnitude !! But we can see that designing a tail recursive procedure is not always the most [intuitive solution](https:\/\/www.explainxkcd.com\/wiki\/index.php\/1270:_Functional). So, let's look at another trade-off instead."}}