{"cell_type":{"dc3b5fd1":"code","ac7af545":"code","0d024029":"code","17a5a090":"code","fee05245":"code","2ecb1c70":"code","eb7f0102":"code","84231b0b":"code","7ccaa4ae":"code","9d33032c":"code","2a583e73":"code","f8230ead":"code","2843ffb1":"code","a4d08034":"code","79aad269":"code","d72f5e4e":"code","58a1c6fe":"code","ce326aaa":"markdown","8450001a":"markdown","9c51c414":"markdown"},"source":{"dc3b5fd1":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom matplotlib import pyplot as plt\nimport os\nimport cv2\nimport pydicom\nimport timeit\nimport seaborn as sns\nplt.style.use('seaborn-talk')\nimport glob\nfrom pathlib import Path\nfrom tqdm import tqdm\nfrom matplotlib import animation, rc\nimport joblib\nimport difflib\n","ac7af545":"def normalize_by_img_max(img):\n#     print(img.min(), img.max(), img.dtype)\n    img_max = max(1, img.max())\n    return (img \/ img_max * 255).astype('uint8')\n\ndef read_dcm(dcm_name, normalize=True):\n    np_img = pydicom.read_file(dcm_name).pixel_array\n    if normalize:\n        np_img = normalize_by_img_max(np_img)\n    return np_img\n\nread_dcm('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00000\/FLAIR\/Image-273.dcm', normalize=False)","0d024029":"def compare_two_dicom_headers(file1, file2):\n    datasets = tuple([pydicom.dcmread(filename, force=True)\n                  for filename in (file1, file2)])\n\n    rep = []\n    for dataset in datasets:\n        lines = str(dataset).split(\"\\n\")\n        lines = [line + \"\\n\" for line in lines]  # add the newline to end\n        rep.append(lines)\n\n\n    diff = difflib.Differ()\n    for line in diff.compare(rep[0], rep[1]):\n        if line[0] != \"?\" and line[0] in ['-', '+']:\n            print(line)\n    \nfile_name1 = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00000\/FLAIR\/Image-273.dcm'\nfile_name2 = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00000\/FLAIR\/Image-272.dcm'\n\ncompare_two_dicom_headers(file_name1, file_name2)","17a5a090":"pydicom.read_file('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00031\/T1w\/Image-33.dcm')","fee05245":"data_path = \"..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00031\/T1w\"\ng = glob.glob(data_path + '\/*.dcm')\n\n# Print out the first 5 file names to verify we're in the right folder.\nprint (\"Total of %d DICOM images.\\nFirst 5 filenames:\" % len(g))\nprint(g[:5])","2ecb1c70":"def load_scan(path):\n    slices = [pydicom.read_file(path + '\/' + s) for s in os.listdir(path)]\n    slices.sort(key = lambda x: int(x.InstanceNumber))\n\n    slice_thickness = np.abs(slices[0].SliceLocation - slices[1].SliceLocation)\n    print(slice_thickness)\n    for s in slices:\n        s.SliceThickness = slice_thickness\n        \n    return slices\n\ndef get_pixels_hu(scans):\n    image = np.stack([s.pixel_array for s in scans])\n    # Convert to int16 (from sometimes int16), \n    # should be possible as values should always be low enough (<32k)\n    image = image.astype(np.int16)\n\n    # Set outside-of-scan pixels to 1\n    # The intercept is usually -1024, so air is approximately 0\n    image[image == -2000] = 0\n    \n    # Convert to Hounsfield units (HU)\n    intercept = scans[0].RescaleIntercept\n    slope = scans[0].RescaleSlope\n    \n    if slope != 1:\n        image = slope * image.astype(np.float64)\n        image = image.astype(np.int16)\n        \n    image += np.int16(intercept)\n    \n    return np.array(image, dtype=np.int16)\n\nid=0\npatient = load_scan(data_path)\nimgs = get_pixels_hu(patient)\nprint(imgs.shape)\nnp.save(\"fullimages_%d.npy\" % (id), imgs)","eb7f0102":"file_used=\"fullimages_%d.npy\" % id\n\nimgs_to_process = np.load(file_used).astype(np.float64) \n\nplt.hist(imgs_to_process.flatten(), bins=50, color='c')\nplt.xlabel(\"Hounsfield Units (HU)\")\nplt.ylabel(\"Frequency\")\nplt.show()","84231b0b":"print(\"Slice Thickness: \", patient[0].SliceThickness)\nprint(\"Pixel Spacing (row, col):\",  (patient[0].PixelSpacing[0], patient[0].PixelSpacing[1]))","7ccaa4ae":"import scipy\nid = 0\nimgs_to_process = np.load('fullimages_{}.npy'.format(id))\ndef resample(image, scan, new_spacing=[1,1,1]):\n    # Determine current pixel spacing\n    spacing = map(float, ([scan[0].SliceThickness] + list(scan[0].PixelSpacing)))\n    spacing = np.array(list(spacing))\n    resize_factor = spacing \/ new_spacing\n    print(resize_factor)\n    new_real_shape = image.shape * resize_factor\n    print(new_real_shape)\n    new_shape = np.round(new_real_shape)\n    real_resize_factor = new_shape \/ image.shape\n    new_spacing = spacing \/ real_resize_factor\n    \n    image = scipy.ndimage.interpolation.zoom(image, real_resize_factor)\n    \n    return image, new_spacing\n\nprint(\"Shape before resampling\\t\", imgs_to_process.shape)\nimgs_after_resamp, spacing = resample(imgs_to_process, patient, [1,1,1])\nprint(\"Shape after resampling\\t\", imgs_after_resamp.shape)","9d33032c":"spacing","2a583e73":"def plot_volume_axis(volume):\n    fig = plt.figure(figsize=(20, 20))\n    ax1 = fig.add_subplot(1, 3, 1)\n    ax1.imshow(volume[volume.shape[0]\/\/2], cmap='gray')\n    \n    ax2 = fig.add_subplot(1, 3, 2)\n    ax2.imshow(volume[:, volume.shape[1]\/\/2], cmap='gray')\n    \n    ax3 = fig.add_subplot(1, 3, 3)\n    ax3.imshow(volume[:, :, volume.shape[2]\/\/2], cmap='gray')\n    fig.show()\n\nplot_volume_axis(imgs_after_resamp)","f8230ead":"from skimage import measure\nimport plotly\nimport plotly.express as px\nfrom plotly.offline import  iplot\nfrom plotly.tools import FigureFactory as FF\n\n\ndef make_mesh(image, threshold=-300, step_size=1):\n\n    print(\"Transposing surface\")\n    p = image.transpose(2,1,0)\n    \n    print(\"Calculating surface\")\n    verts, faces, norm, val = measure.marching_cubes(p, threshold, step_size=step_size, allow_degenerate=True) \n    return verts, faces\n\ndef plotly_3d(verts, faces):\n    x,y,z = zip(*verts) \n    \n    print(\"Drawing\")\n    # Make the colormap single color since the axes are positional not intensity. \n#    colormap=['rgb(255,105,180)','rgb(255,255,51)','rgb(0,191,255)']\n    colormap= px.colors.sequential.Brwnyl\n    backgroundcolor = 'slategray'\n    fig = FF.create_trisurf(x=x,\n                        y=y, \n                        z=z, \n                        plot_edges=False,\n                        colormap=colormap,\n                        simplices=faces,\n                        backgroundcolor=backgroundcolor,\n                        title=\"Interactive Visualization\")\n    iplot(fig)\n\n    \nv, f = make_mesh(imgs_after_resamp, threshold=10, step_size=10)\nplotly_3d(v, f)\n","2843ffb1":"def get_image_plane(data):\n    x1, y1, _, x2, y2, _ = [round(j) for j in data.ImageOrientationPatient]\n    cords = [x1, y1, x2, y2]\n\n    if cords == [1, 0, 0, 0]:\n        return 'Coronal'\n    elif cords == [1, 0, 0, 1]:\n        return 'Axial'\n    elif cords == [0, 1, 0, 0]:\n        return 'Sagittal'\n    else:\n        return 'Unknown'\n    \ndcm_img = pydicom.read_file('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00031\/T1w\/Image-22.dcm')\nplane = get_image_plane(dcm_img)\nplt.imshow(dcm_img.pixel_array, cmap='gray')\nplane","a4d08034":"def get_volume(study_dir):\n    imgs = []\n    dcm_dir = Path(study_dir)\n    dcm_paths = sorted(dcm_dir.glob(\"*.dcm\"), key=lambda x: int(x.stem.split(\"-\")[-1]))\n    positions = []\n    \n    for dcm_path in dcm_paths:\n        img = pydicom.dcmread(str(dcm_path))\n        imgs.append(img.pixel_array)\n        positions.append(img.ImagePositionPatient)\n        \n    plane = get_image_plane(img)\n    volume = np.stack(imgs)\n    \n    # reorder planes if needed and rotate volume\n    if plane == \"Coronal\":\n        if positions[0][1] < positions[-1][1]:\n            volume = volume[::-1]\n            print(f\"{study_id} {scan_type} {plane} reordered\")\n        volume = volume.transpose((1, 0, 2))\n    elif plane == \"Sagittal\":\n        if positions[0][0] < positions[-1][0]:\n            volume = volume[::-1]\n            print(f\"{study_id} {scan_type} {plane} reordered\")\n        volume = volume.transpose((1, 2, 0))\n        volume = np.rot90(volume, 2, axes=(1, 2))\n    elif plane == \"Axial\":\n        if positions[0][2] > positions[-1][2]:\n            volume = volume[::-1]\n            print(f\"{study_id} {scan_type} {plane} reordered\")\n        volume = np.rot90(volume, 2)\n    else:\n        raise ValueError(f\"Unknown plane {plane}\")\n    return volume, plane","79aad269":"from skimage.transform import rescale, resize, downscale_local_mean\n\n\ndef calc_padding_inds(keep, padding):\n    s_edge_ind = np.argmax(keep)\n    e_edge_ind = np.argmax(keep[::-1])\n    keep_s = max(0, s_edge_ind-padding)\n    keep_e = min(len(keep)-e_edge_ind+padding, len(keep))\n    return keep_s, keep_e\n\ndef crop_volume(volume, padding=40):\n    if volume.sum() == 0:\n        return volume\n    keep = (volume.mean(axis=(0, 1)) > 0)\n    keep_s, keep_e = calc_padding_inds(keep, padding)\n    volume = volume[:, :, keep_s:keep_e]\n    \n    \n    keep = (volume.mean(axis=(0, 2)) > 0)\n    keep_s, keep_e = calc_padding_inds(keep, padding)\n    volume = volume[:, keep_s:keep_e]\n    \n    \n    keep = (volume.mean(axis=(1, 2)) > 0)\n    keep_s, keep_e = calc_padding_inds(keep, padding)\n\n    volume = volume[keep_s:keep_e]\n    return volume\n\ndef resize_volume(volume, sz=128, interpolation=cv2.INTER_LINEAR):\n    output = np.zeros((sz, sz, sz), dtype=np.float32)\n\n    if np.argmax(volume.shape) == 0:\n        for i, s in enumerate(np.linspace(0, volume.shape[0] - 1, sz)):\n            output[i] = cv2.resize(volume[int(s)], (sz, sz), interpolation=interpolation)\n\n    elif np.argmax(volume.shape) == 1:\n        for i, s in enumerate(np.linspace(0, volume.shape[1] - 1, sz)):\n            output[:, i] = cv2.resize(volume[:, int(s)], (sz, sz), interpolation=interpolation)\n\n    elif np.argmax(volume.shape) == 2:\n        for i, s in enumerate(np.linspace(0, volume.shape[2] - 1, sz)):\n            output[:, :, i] = cv2.resize(volume[:, :, int(s)], (sz, sz), interpolation=interpolation)\n\n    return output","d72f5e4e":"!pip install --upgrade https:\/\/github.com\/VincentStimper\/mclahe\/archive\/numpy.zip\nfrom mclahe import mclahe","58a1c6fe":"volume, _ = get_volume(\"..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00045\/FLAIR\")\nprint(volume.shape, volume.max())\n\nvolume = crop_volume(volume, padding=5)\nvolume = resize_volume(volume)\n\nprint(volume.shape, volume.max())\n\nvolume = mclahe(volume, n_bins=64)\nprint(volume.shape, volume.max())\n\nplot_volume_axis(volume)\nv, f = make_mesh(volume, threshold=0, step_size=2)\nplotly_3d(v, f)\n","ce326aaa":"<h1> Volume preprocessing Pipeline","8450001a":"<h2><b><i> Pipeline <\/i> <\/b><\/h2>","9c51c414":"# <h1> Resample volume  1x1x1mm volumes"}}