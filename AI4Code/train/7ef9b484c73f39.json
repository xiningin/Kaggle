{"cell_type":{"4449ef60":"code","02d8ef03":"code","b8c7ed6c":"code","0e65cc66":"code","da94f4d0":"code","17cebb25":"code","5b8a762e":"code","766a8497":"code","a1bc687c":"code","fcba30cc":"code","3ff38586":"code","91237bab":"code","63741da2":"code","3a9b9a2e":"code","f1985866":"code","982df6d3":"code","03e7364a":"code","76db8685":"code","c4f4ee50":"code","0cef2dec":"code","34fdda95":"code","290cf753":"code","8ee96ded":"code","e6ae6480":"code","8e261a21":"code","d799f002":"code","d8c71809":"code","39ec870b":"code","e45f4db7":"code","3299c02b":"code","98ce678c":"code","528f258e":"code","b6104858":"code","51015114":"code","49c7851c":"code","68156ca0":"code","eeb07ead":"markdown","70e21a0f":"markdown","505e387e":"markdown","cd436b0f":"markdown","fe6f4df5":"markdown","670e7c2b":"markdown","110d3d77":"markdown","758a9cfb":"markdown","5043f34f":"markdown","90246850":"markdown","1914f826":"markdown","63126271":"markdown","1d75a1b9":"markdown","7fcc6255":"markdown","ac119d85":"markdown","10e075a5":"markdown","221a22b7":"markdown","e468cab5":"markdown","8075902a":"markdown","97c04b3e":"markdown"},"source":{"4449ef60":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nimport plotly.graph_objects as go\n\nfrom datetime import date, timedelta\nfrom fbprophet import Prophet\nfrom fbprophet.make_holidays import make_holidays_df\nfrom fbprophet.diagnostics import cross_validation, performance_metrics\nfrom fbprophet.plot import plot_cross_validation_metric\nimport holidays\n\nimport pycountry\nimport plotly.express as px\nfrom collections import namedtuple\n\nimport warnings\nwarnings.simplefilter('ignore')","02d8ef03":"df = pd.read_csv('..\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv',parse_dates=['Last Update'])\ndf.rename(columns={'ObservationDate':'Date', 'Country\/Region':'Country'}, inplace=True)\ndf_confirmed = pd.read_csv(\"\/kaggle\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_confirmed.csv\")\ndf_confirmed.rename(columns={'Country\/Region':'Country'}, inplace=True)","b8c7ed6c":"df[\"Country\"].unique()","0e65cc66":"df_confirmed[\"Country\"].unique()","da94f4d0":"np.array(set(df[\"Country\"].unique()).difference(set(df_confirmed[\"Country\"].unique())))","17cebb25":"# Convert name of countries to ISO 3166 and equivalence of country names in dataframes df and df_confirmed\ndf[\"Country\"].replace({'UK': 'United Kingdom'}, inplace=True)\ndf[\"Country\"].replace({'US': 'United States'}, inplace=True)\ndf[\"Country\"].replace({'Russia': 'Russian Federation'}, inplace=True)\ndf[\"Country\"].replace({'South Korea': 'Korea, Republic of'}, inplace=True)\ndf[\"Country\"].replace({'Mainland China': 'China'}, inplace=True)\ndf[\"Country\"].replace({'Czech Republic': 'Czechia'}, inplace=True)\ndf_confirmed[\"Country\"].replace({'UK': 'United Kingdom'}, inplace=True)\ndf_confirmed[\"Country\"].replace({'US': 'United States'}, inplace=True)\ndf_confirmed[\"Country\"].replace({'Russia': 'Russian Federation'}, inplace=True)\ndf_confirmed[\"Country\"].replace({'Korea, South': 'Korea, Republic of'}, inplace=True)","5b8a762e":"df_countries = df['Country'].unique()\ndf_countries","766a8497":"df_confirmed.head()","a1bc687c":"df","fcba30cc":"df_confirmed = df_confirmed[[\"Province\/State\",\"Lat\",\"Long\",\"Country\"]]\ndf_temp = df.copy()\ndf_latlong = pd.merge(df_temp, df_confirmed, on=[\"Country\", \"Province\/State\"])","3ff38586":"df2 = df.groupby([\"Date\", \"Country\"])[['Date', 'Country', 'Confirmed']].sum().reset_index()\nconfirmed = df2.groupby(['Date', 'Country']).sum()[['Confirmed']].reset_index()","91237bab":"latest_date = confirmed['Date'].max()\nlatest_date","63741da2":"confirmed = confirmed[(confirmed['Date']==latest_date)][['Country', 'Confirmed']]","3a9b9a2e":"confirmed2 = confirmed.copy()","f1985866":"# Thanks to dataset https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries\nholidays_df = pd.read_csv('..\/input\/covid19-holidays-of-countries\/holidays_df_of_67_countries_for_covid_19.csv')\nholidays_df","982df6d3":"holidays_df['country'].unique()","03e7364a":"holidays_df_code_countries = holidays_df['code'].unique()\nholidays_df_code_countries","76db8685":"def dict_code_countries_with_holidays(list_name_countries: list,\n                                      holidays_df: pd.DataFrame()):\n    \"\"\"\n    Defines a dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    in the dataset \"COVID-19: Holidays of countries\" \n    \n    Returns: \n    - countries: dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    - holidays_df_identificated: DataFrame with holidays data for countries from dictionary 'countries'\n    \n    Args: \n    - list_name_countries: list of the name of countries (name or common_name or official_name or alha2 or alpha3 codes from ISO 3166)\n    - holidays_df: DataFrame with holidays \"COVID-19: Holidays of countries\"\n    \"\"\"\n    \n    import pycountry\n    \n    # Identification of countries for which there are names according to ISO\n    countries = {}\n    dataset_all_countries = list(holidays_df['code'].unique())\n    list_name_countries_identificated = []\n    list_name_countries_not_identificated = []\n    for country in list_name_countries:\n        try: \n            country_id = pycountry.countries.get(alpha_2=country)\n            if country_id.alpha_2 in dataset_all_countries:\n                countries[country] = country_id.alpha_2\n        except AttributeError:\n            try: \n                country_id = pycountry.countries.get(name=country)\n                if country_id.alpha_2 in dataset_all_countries:\n                    countries[country] = country_id.alpha_2\n            except AttributeError:\n                try: \n                    country_id = pycountry.countries.get(official_name=country)\n                    if country_id.alpha_2 in dataset_all_countries:\n                        countries[country] = country_id.alpha_2\n                except AttributeError:\n                    try: \n                        country_id = pycountry.countries.get(common_name=country)\n                        if country_id.alpha_2 in dataset_all_countries:\n                            countries[country] = country_id.alpha_2\n                    except AttributeError:\n                        try: \n                            country_id = pycountry.countries.get(alpha_3=country)\n                            if country_id.alpha_2 in dataset_all_countries:\n                                countries[country] = country_id.alpha_2\n                        except AttributeError:\n                            list_name_countries_not_identificated.append(country)\n    holidays_df_identificated = holidays_df[holidays_df['code'].isin(countries.values())]\n    \n    print(f'Thus, the dataset has holidays in {len(countries)} countries from your list with {len(list_name_countries)} countries')\n    if len(countries) == len(dataset_all_countries):\n        print('All available in this dataset holiday data is used')\n    else:\n        print(\"Holidays are available in the dataset for such countries (if there are countries from your list, then it's recommended making changes to the list)\")\n        print(np.array(holidays_df[~holidays_df['code'].isin(countries.values())].country_official_name.unique()))\n        \n    return countries, holidays_df_identificated","c4f4ee50":"countries_dict, holidays_df = dict_code_countries_with_holidays(df_countries,holidays_df)","0cef2dec":"def adaption_df_to_holidays_df_for_prophet(df, col, countries_dict):\n    # Adaptation the dataframe df (by column=col) to holidays_df by list of countries in dictionary countries_dict\n    \n    # Filter df for countries which there are in the dataset with holidays\n    df = df[df[col].isin(list(countries_dict.keys()))].reset_index(drop=True)\n    \n    # Add alpha_2 (code from ISO 3166) for each country\n    df['iso_alpha'] = None\n    for key, value in countries_dict.items():\n        df.loc[df[col] == key, 'iso_alpha'] = value    \n    \n    return df","34fdda95":"df2 = adaption_df_to_holidays_df_for_prophet(df2, 'Country', countries_dict)\ndf2","290cf753":"df2.columns","8ee96ded":"print(\"Number of countries\/regions with data: \" + str(len(df2.Country.unique())))","e6ae6480":"df2.describe()","8e261a21":"df2.head()","d799f002":"df2.tail()","d8c71809":"prior_scale_list = [0.05, 0.5, 1, 2, 5, 10, 15, 20, 40]","39ec870b":"days_to_forecast = 14 # changable\nfirst_forecasted_date = sorted(list(set(df2['Date'].values)))[-days_to_forecast]\n\nprint('The first date to perform forecasts for is: ' + str(first_forecasted_date))","e45f4db7":"confirmed_df = df2[['Date', 'Country', 'Confirmed', 'iso_alpha']]\nconfirmed_df","3299c02b":"all_countries = confirmed_df['Country'].unique()\nall_countries","98ce678c":"def make_forecasts(all_countries, confirmed_df, holidays_df, days_to_forecast, first_forecasted_date):\n    \n    def eval_error(forecast_df, country_df_val, first_forecasted_date, title):\n        # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n        forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n        result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n        result_val_df = result_df.merge(country_df_val, on=['ds'])\n        result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat']).abs()\n        relative_error = [sum(result_val_df['rel_diff'].values)*100\/result_val_df['y'].sum()]\n        \n        # Check the output\n        print(f'Result_val_df {title}:')\n        print(relative_error[0], \"% \\n\")\n        \n        return relative_error\n    \n    def model_training_forecasting(holidays_df=None):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, \n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = 0.1,\n                        seasonality_mode = 'multiplicative')\n        model.add_seasonality(name='weekly', period=7, fourier_order=10, mode = 'additive')\n        model.fit(country_df)\n        future = model.make_future_dataframe(periods=days_to_forecast)\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    \n    forecast_dfs = []\n    relative_errors = []\n    forecast_holidays_dfs = []\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Country', 'Conf_real', 'Conf_pred', 'Conf_pred_h', 'n_h', 'err', 'err_h', 'prior_scale', 'how_less, %'])\n    \n    for j in range(len(all_countries)):\n        country = all_countries[j]\n        if country in confirmed_df['Country'].values:\n            print(f'Country {str(country)} is listed')\n            country_df = confirmed_df[confirmed_df['Country'] == country].reset_index(drop=True)\n            country_iso_alpha = country_df['iso_alpha'][0]\n            country_holidays_df = holidays_df[holidays_df['code'] == country_iso_alpha][['ds', 'holiday', 'lower_window', 'upper_window', 'prior_scale']].reset_index(drop=True)\n            country_dfs = []            \n            \n            # Data preparation for forecast with Prophet\n            country_df = country_df[['Date', 'Confirmed']]\n            country_df.columns = ['ds','y']\n            country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n            # Set training and validation datasets\n            country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n            country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n            # Without holidays\n            # Model training and forecasting without holidays\n            model, forecast = model_training_forecasting()\n            #fig1 = model.plot_components(forecast)\n\n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_df = forecast[['ds', 'yhat']].copy()\n            relative_errors += eval_error(forecast_df, country_df_val, first_forecasted_date, 'without holidays')\n\n            # With holidays\n            # Model training with tuning prior_scale and forecasting\n            relative_error_holidays_min = relative_errors[-1]\n            for i in range(len(prior_scale_list)):\n                country_holidays_df['prior_scale'] = prior_scale_list[i]\n                number_holidays = len(country_holidays_df[(country_holidays_df['ds'] > '2020-01-21') & (country_holidays_df['ds'] < '2020-07-21')])\n                model_holidays, forecast_holidays = model_training_forecasting(country_holidays_df)\n\n                # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n                forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n                relative_error_holidays = eval_error(forecast_holidays_df, country_df_val, first_forecasted_date, 'with holidays impact')\n                \n                # Save results\n                if i == 0:\n                    relative_error_holidays_min = relative_error_holidays\n                    forecast_holidays_df_best = forecast_holidays\n                    model_holidays_best = model_holidays\n                    prior_scale_best = prior_scale_list[0]\n                    \n                elif (relative_error_holidays[0] < relative_error_holidays_min[0]):\n                    relative_error_holidays_min = relative_error_holidays\n                    forecast_holidays_df_best = forecast_holidays\n                    model_holidays_best = model_holidays\n                    prior_scale_best = prior_scale_list[i]\n                    \n                print('prior_scale =', prior_scale_list[i], 'relative_error_holidays_min',relative_error_holidays_min[0])\n            \n            # Results visualization\n            print('The best errors of model with holidays is', relative_error_holidays_min[0], 'with prior_scale', str(prior_scale_best))\n            relative_errors_holidays += relative_error_holidays_min\n            \n            if relative_errors[-1] < relative_errors_holidays[-1]:\n                # The forecast without taking into account the holidays is the best\n                forecast_plot = model.plot(forecast_holidays_df_best, ylabel='Confirmed in '+ country + ' (forecasting without holidays)')\n            else:\n                # The forecast taking into account the holidays is the best\n                forecast_plot = model_holidays_best.plot(forecast_holidays_df_best, ylabel='Confirmed in '+ country + ' (forecasting with holidays)')            \n\n            # Save results to dataframe with all dates\n            forecast_holidays_df_best['Country'] = country\n            forecast_holidays_df_best.rename(columns={'yhat':'Confirmed'}, inplace=True)\n            forecast_holidays_dfs += [forecast_holidays_df_best.tail(days_to_forecast)]\n\n            # Save results to dataframe with result for the last date\n            results.loc[j,'Country'] = country\n            confirmed_real_last = country_df_val.tail(1)['y'].values[0].astype('int')\n            results.loc[j,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = round(forecast_df.tail(1)['yhat'].values[0]).astype('int')\n            results.loc[j,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = round(forecast_holidays_df_best.tail(1)['Confirmed'].values[0],0).astype('int')\n            results.loc[j,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[j,'n_h'] = number_holidays\n            results.loc[j,'err'] = relative_errors[-1]\n            results.loc[j,'err_h'] = relative_errors_holidays[-1]\n            results.loc[j,'prior_scale'] = prior_scale_best\n            results.loc[j,'how_less, %'] = round((relative_errors[-1]-relative_errors_holidays[-1])*100\/relative_errors[-1],1)\n            if round((relative_errors[-1]-relative_errors_holidays[-1])*100\/relative_errors[-1],1) > 1:\n                model_holidays_best.plot_components(forecast_holidays_df_best)\n                \n                if relative_errors_holidays[-1] < 1:\n                    # Diagnostics by cross-validation\n                    forecast_holidays_dfs_cv = cross_validation(model_holidays_best, initial= str(len(country_df)-28) +' days', period='7 days', horizon = '14 days')\n                    forecast_holidays_dfs_cv_diagn = performance_metrics(forecast_holidays_dfs_cv, metrics=['mape'], rolling_window=1)\n                    forecast_holidays_dfs_cv_diagn.rename(columns={'mape':'MAPE, %'}, inplace=True)\n                    display(forecast_holidays_dfs_cv_diagn.head())\n                    fig = plot_cross_validation_metric(forecast_holidays_dfs_cv, metric='mape')\n\n        else:\n            print('Country ' + str(country) + ' is not listed! ')\n            continue\n            \n    return forecast_holidays_dfs, relative_errors_holidays, results","528f258e":"forecast_holidays_dfs, relative_errors_holidays, results = make_forecasts(all_countries, confirmed_df, holidays_df, days_to_forecast, first_forecasted_date)","b6104858":"print('Countries with the significant impact of holidays')\ndisplay(results[results['how_less, %'] > 1].sort_values(by=['how_less, %'], ascending=False))","51015114":"print('Number of these countries is', len(results[results['how_less, %'] > 1]))","49c7851c":"print('Countries without the significant impact of holidays')\ndisplay(results[results['how_less, %'] <= 1].sort_values(by=['how_less, %'], ascending=False))","68156ca0":"print('Number of these countries is', len(results[results['how_less, %'] <= 1]))","eeb07ead":"Forecasting Confirmed Cases Worldwide with Prophet by Country","70e21a0f":"It would be more correct to call this list \"Country\/Regions\"","505e387e":"## 1. Import libraries<a class=\"anchor\" id=\"1\"><\/a>\n\n[Back to Table of Contents](#0.1)","cd436b0f":"## Earliest Cases","fe6f4df5":"I hope you find this kernel useful and enjoyable.","670e7c2b":"## 4. EDA<a class=\"anchor\" id=\"4\"><\/a>\n\n[Back to Table of Contents](#0.1)","110d3d77":"### Thank to dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries)","758a9cfb":"# Acknowledgements\n\n- very good notebook [COVID-19 Novel Coronavirus EDA & Forecasting Cases](https:\/\/www.kaggle.com\/khoongweihao\/covid-19-novel-coronavirus-eda-forecasting-cases) from [@Wei Hao Khoong](https:\/\/www.kaggle.com\/khoongweihao)\n- this dataset [Novel Corona Virus 2019 Dataset](https:\/\/www.kaggle.com\/sudalairajkumar\/novel-corona-virus-2019-dataset)\n- my dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) - it is recommended to follow the updates\n- https:\/\/facebook.github.io\/prophet\/\n- https:\/\/facebook.github.io\/prophet\/docs\/\n- https:\/\/github.com\/facebook\/prophet\n- https:\/\/plot.ly\/python\/bubble-maps\/","5043f34f":"## 3. Selection of countries with data on holidays<a class=\"anchor\" id=\"3\"><\/a>\n\n[Back to Table of Contents](#0.1)","90246850":"## 2. Download data<a class=\"anchor\" id=\"2\"><\/a>\n\n[Back to Table of Contents](#0.1)","1914f826":"Downloading and clearning data","63126271":"# [Novel Corona Virus 2019 Dataset](https:\/\/www.kaggle.com\/sudalairajkumar\/novel-corona-virus-2019-dataset)\n## Day level information on covid-19 affected cases","1d75a1b9":"## 5. Model training, forecasting and evaluation<a class=\"anchor\" id=\"5\"><\/a>\n\n[Back to Table of Contents](#0.1)","7fcc6255":"[Go to Top](#0)","ac119d85":"## Latest Cases","10e075a5":"There are many studies in the field of coronavirus forecasting. Many researchers use **Prophet** (from Facebook). But for some reason, no one takes into account the holidays impact. After all, despite all the prohibitions, it is difficult for people to stay at home and they still somehow celebrate the **holidays** to which they are accustomed. The desire to celebrate is especially strong when people are sitting at home all the time looking for something to do. In my opinion, the impact of the holidays is manifested in the fact that within 4-10 days after these holidays there may be a jump in the number of confirmed cases, due to the fact that people went shopping, and even visiting each other, perhaps even in violation of quarantine requirements. \n\nAt the same time, I do not see the point in forecasting the number of deaths and the number of recovering by time series. The number of **confirmed cases** can really be predicted, as there are certain statistical patterns in their formation. But the number of **deaths** and those who have **recovered** is more due to the state of health of patients, detailed information about which is not published (the age and sex of patients are very little information for analysis!). And therefore number of deaths and recovered are can't be reliably predicted. \n\nThe Prophet contains [information about the main holidays](https:\/\/github.com\/dr-prodigy\/python-holidays) of 62 countries from this dataset, but not all, and it package has some disadvantages. Then I creation more perfect own dataset and plan to update it periodically. Now my dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) has holidays for 67 countries from this dataset.\n\nI will limit myself to forecasting only those countries for which there is information about holidays for Prophet.","221a22b7":"# COVID-19 Novel Coronavirus: EDA & Forecasting with holidays impact for confirmed cases. Prophet with prior_scale optimization","e468cab5":"Import libraries and packages","8075902a":"<a class=\"anchor\" id=\"0.1\"><\/a>\n## Table of Contents\n\n1. [Import libraries](#1)\n1. [Download data](#2)\n1. [Selection of countries with data on holidays](#3)\n1. [EDA](#4)\n1. [Model training, forecasting and evaluation](#5)\n","97c04b3e":"Your comments and feedback are most welcome."}}