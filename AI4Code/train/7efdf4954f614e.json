{"cell_type":{"6cc973bf":"code","1e9513aa":"code","8a118ffc":"code","15400295":"code","8ee3769b":"code","0c2ff888":"code","ee0b2541":"code","f6782205":"code","31b4c048":"code","2b8e8dbf":"code","6de906e4":"code","85b53bfe":"code","cc734355":"code","8d3d715a":"code","9ab65e9d":"code","ffedd869":"code","6982b8e9":"code","6f060e3c":"code","4f6c8dd5":"code","b518d966":"code","90c09cdc":"code","73789519":"code","77a4128c":"code","5dbec9ba":"code","fba001c0":"code","aa64d13b":"code","caea9d27":"code","9632a352":"code","63513503":"code","6e998c44":"code","78f9f4a5":"code","6003aea5":"code","26cbeaf9":"code","213cfa76":"code","0ad0a10b":"code","3e569082":"code","9d89d689":"code","4f8c94c5":"code","00c79579":"code","aaa1baec":"markdown","c263cf1c":"markdown","eb9d7255":"markdown","d388599a":"markdown","b95665ae":"markdown","4806e400":"markdown","c5f9f070":"markdown","f7340eea":"markdown","30026835":"markdown","13f9ddf1":"markdown","9edcf195":"markdown","82794872":"markdown","b3503d98":"markdown","c04f7dd7":"markdown","f07b402d":"markdown","66635e23":"markdown","afd6a377":"markdown","29d393b8":"markdown","e1789698":"markdown","bd219145":"markdown","f9ca58ce":"markdown","a44af75f":"markdown","cc26a18a":"markdown","412bd70e":"markdown","8fd9dd9b":"markdown","8b998bb8":"markdown","e9185e2d":"markdown"},"source":{"6cc973bf":"import os\nimport torch\nimport torchvision\nfrom torch.utils.data import random_split\nimport torchvision.models as models\nimport torch.nn as nn\nimport torch.nn.functional as F","1e9513aa":"data_dir  = '..\/input\/indoor-scenes-cvpr-2019\/indoorCVPR_09\/Images'\n\nclasses = os.listdir(data_dir)\nprint(classes)","8a118ffc":"len(classes)","15400295":"from torchvision.datasets import ImageFolder\nimport torchvision.transforms as transforms\n\ntransformations = transforms.Compose([transforms.Resize((256, 256)), transforms.ToTensor()])\n\ndataset = ImageFolder(data_dir, transform = transformations)","8ee3769b":"import matplotlib.pyplot as plt\n%matplotlib inline\n\ndef show_sample(img, label):\n    print(\"Label:\", dataset.classes[label], \"(Class No: \"+ str(label) + \")\")\n    plt.imshow(img.permute(1, 2, 0))","0c2ff888":"img, label = dataset[50]\nshow_sample(img, label)","ee0b2541":"random_seed = 42\ntorch.manual_seed(random_seed)","f6782205":"len(dataset)","31b4c048":"train_ds, val_ds, test_ds = random_split(dataset, [13000, 2000, 620])\nlen(train_ds), len(val_ds), len(test_ds)","2b8e8dbf":"from torch.utils.data.dataloader import DataLoader\nbatch_size = 25","6de906e4":"train_dl = DataLoader(train_ds, batch_size, shuffle = True, num_workers = 4, pin_memory = True)\nval_dl = DataLoader(val_ds, batch_size*2, num_workers = 4, pin_memory = True)","85b53bfe":"from torchvision.utils import make_grid\n\ndef show_batch(dl):\n    for images, labels in dl:\n        fig, ax = plt.subplots(figsize=(12, 6))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.imshow(make_grid(images, nrow = 16).permute(1, 2, 0))\n        break","cc734355":"show_batch(train_dl)","8d3d715a":"show_batch(val_dl)","9ab65e9d":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))\n\nclass ImageClassificationBase(nn.Module):\n    def training_step(self, batch):\n        images, labels = batch \n        out = self(images)                  # Generate predictions\n        loss = F.cross_entropy(out, labels) # Calculate loss\n        return loss\n    \n    def validation_step(self, batch):\n        images, labels = batch \n        out = self(images)                    # Generate predictions\n        loss = F.cross_entropy(out, labels)   # Calculate loss\n        acc = accuracy(out, labels)           # Calculate accuracy\n        return {'val_loss': loss.detach(), 'val_acc': acc}\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch {}: train_loss: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}\".format(\n            epoch+1, result['train_loss'], result['val_loss'], result['val_acc']))","ffedd869":"class ResNet(ImageClassificationBase):\n    def __init__(self):\n        super().__init__()\n        # Use a pretrained model\n        self.network = models.resnet18(pretrained=True)\n        # Replace last layer\n        num_ftrs = self.network.fc.in_features\n        self.network.fc = nn.Linear(num_ftrs, len(dataset.classes))\n    \n    def forward(self, xb):\n        return torch.sigmoid(self.network(xb))\n\nmodel = ResNet()","6982b8e9":"def get_default_device():\n    \"\"\"Pick GPU if available, else CPU\"\"\"\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')\n    \ndef to_device(data, device):\n    \"\"\"Move tensor(s) to chosen device\"\"\"\n    if isinstance(data, (list,tuple)):\n        return [to_device(x, device) for x in data]\n    return data.to(device, non_blocking=True)\n\nclass DeviceDataLoader():\n    \"\"\"Wrap a dataloader to move data to a device\"\"\"\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        \"\"\"Yield a batch of data after moving it to device\"\"\"\n        for b in self.dl: \n            yield to_device(b, self.device)\n\n    def __len__(self):\n        \"\"\"Number of batches\"\"\"\n        return len(self.dl)","6f060e3c":"device = get_default_device()\ndevice","4f6c8dd5":"train_dl = DeviceDataLoader(train_dl, device)\nval_dl = DeviceDataLoader(val_dl, device)\nto_device(model, device)","b518d966":"@torch.no_grad()\ndef evaluate(model, val_loader):\n    model.eval()\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        model.train()\n        train_losses = []\n        for batch in train_loader:\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","90c09cdc":"model = to_device(ResNet(), device)","73789519":"evaluate(model, val_dl)","77a4128c":"num_epochs = 10\nopt_func = torch.optim.Adam\nlr = 6e-5\n\nhistory = fit(num_epochs, lr, model, train_dl, val_dl, opt_func)","5dbec9ba":"def plot_accuracies(history):\n    accuracies = [x['val_acc'] for x in history]\n    plt.plot(accuracies, '-x')\n    plt.xlabel('epoch')\n    plt.ylabel('accuracy')\n    plt.title('Accuracy vs. No. of epochs');\n\nplot_accuracies(history)","fba001c0":"def plot_losses(history):\n    train_losses = [x.get('train_loss') for x in history]\n    val_losses = [x['val_loss'] for x in history]\n    plt.plot(train_losses, '-bx')\n    plt.plot(val_losses, '-rx')\n    plt.xlabel('epoch')\n    plt.ylabel('loss')\n    plt.legend(['Training', 'Validation'])\n    plt.title('Loss vs. No. of epochs');\n\nplot_losses(history)","aa64d13b":"evaluate(model, val_dl)","caea9d27":"def predict_image(img, model):\n    # Convert to a batch of 1\n    xb = to_device(img.unsqueeze(0), device)\n    # Get predictions from model\n    yb = model(xb)\n    # Pick index with highest probability\n    prob, preds  = torch.max(yb, dim=1)\n    # Retrieve the class label\n    return dataset.classes[preds[0].item()]","9632a352":"img, label = test_ds[17]\nplt.imshow(img.permute(1, 2, 0))\nprint('Label:', dataset.classes[label], ', Predicted:', predict_image(img, model))","63513503":"img, label = test_ds[23]\nplt.imshow(img.permute(1, 2, 0))\nprint('Label:', dataset.classes[label], ', Predicted:', predict_image(img, model))","6e998c44":"img, label = test_ds[51]\nplt.imshow(img.permute(1, 2, 0))\nprint('Label:', dataset.classes[label], ', Predicted:', predict_image(img, model))","78f9f4a5":"import urllib.request\nurllib.request.urlretrieve(\"https:\/\/images.squarespace-cdn.com\/content\/v1\/5a7497e29f8dcee376b70f7e\/1591630503059-FBBWAYXPWYOK9BTIBMZY\/ke17ZwdGBToddI8pDm48kA_SSaoz4elkj-HsZd8gX3Z7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1UWPwZyNcweDIvdeL5kotwkIXjs9g0WibSO_cU-Ijy4Pwg6poS-6WGGnXqDacZer4yQ\/74586587_10157705983079085_1307946016988725248_o+%281%29.jpg?format=2500w\", \"bar.jpg\")\nurllib.request.urlretrieve(\"https:\/\/www.bocadolobo.com\/en\/inspiration-and-ideas\/wp-content\/uploads\/2018\/03\/Discover-the-Ultimate-Master-Bedroom-Styles-and-Inspirations-6_1.jpg\", \"bedroom.jpg\")    \nurllib.request.urlretrieve(\"https:\/\/sika.scene7.com\/is\/image\/sika\/glo-elevator-appliances?wid=1280&crop=0%2C80%2C4615%2C3212\", \"elevator.jpg\") \nurllib.request.urlretrieve(\"https:\/\/i.pinimg.com\/originals\/2b\/15\/9d\/2b159da035e4e3aaa30c03ec8ba7816c.jpg\", \"gameroom.jpg\")\nurllib.request.urlretrieve(\"https:\/\/i.pinimg.com\/originals\/a6\/d9\/d7\/a6d9d743da7017a7bcf4a53e46d22f81.jpg\", \"inside_bus.jpg\")\nurllib.request.urlretrieve(\"https:\/\/s.wsj.net\/public\/resources\/images\/ON-CE927_moviet_B1280_20170714200426.jpg\", \"theatre.jpg\")","6003aea5":"loaded_model = model","26cbeaf9":"from PIL import Image\nfrom pathlib import Path\n\ndef predict_external_image(image_name):\n    image = Image.open(Path('.\/' + image_name))\n\n    example_image = transformations(image)\n    plt.imshow(example_image.permute(1, 2, 0))\n    print(\"The image resembles\", predict_image(example_image, loaded_model) + \".\")","213cfa76":"predict_external_image('bar.jpg')","0ad0a10b":"predict_external_image('bedroom.jpg')","3e569082":"predict_external_image('elevator.jpg')","9d89d689":"predict_external_image('gameroom.jpg')","4f8c94c5":"predict_external_image('inside_bus.jpg')","00c79579":"predict_external_image('theatre.jpg')","aaa1baec":"This is the function for fitting the model.","c263cf1c":"Let's start training the model:","eb9d7255":"# Indoor Scene Recognition using PyTorch\n\nIndoor scene recognition is a challenging open problem in high level vision. Most scene recognition models that work well for outdoor scenes perform poorly in the indoor domain. The main difficulty is that while some indoor scenes (e.g. corridors) can be well characterized by global spatial properties, others (e.g., bookstores) are better characterized by the objects they contain. More generally, to address the indoor scenes recognition problem we need a model that can exploit local and global discriminative information.\n\n![Garbage Bins](https:\/\/media.springernature.com\/original\/springer-static\/image\/chp%3A10.1007%2F978-3-030-61705-9_64\/MediaObjects\/500677_1_En_64_Fig1_HTML.png)\n\n\nIn this notebook we'll use PyTorch for classifying the indoor scene into various categories like bakery, casino, etc.","d388599a":"Let us see the classes present in the dataset:","b95665ae":"Let's create a helper function to see the image and its corresponding label:","4806e400":"# Visualizing Predictions:","c5f9f070":"## Transformations:","f7340eea":"## Porting to GPU:","30026835":"### If you liked the kernel, don't forget to show some appreciation :)","13f9ddf1":"Now, let's apply transformations to the dataset and import it for use.","9edcf195":"Let us see the model's predictions on the test dataset:","82794872":"# Predicting External Images:","b3503d98":"This is a helper function to visualize batches:","c04f7dd7":"GPUs tend to perform faster calculations than CPU. Let's take this advantage and use GPU for computation:","f07b402d":"Let's create the model base:","66635e23":"We'll split the dataset into training, validation and test sets:","afd6a377":"# Training the Model:","29d393b8":"Let us start by importing the libraries:","e1789698":"Let's now test with external images.\n\nI'll use `urllib` for downloading external images.","bd219145":"# Model Base:","f9ca58ce":"Let us load the model. You can load an external pre-trained model too!","a44af75f":"This function takes the image's name and prints the predictions:","cc26a18a":"We'll be using ResNet18 for classifying images:","412bd70e":"# Loading and Splitting Data:","8fd9dd9b":"# Conclusion:\n\nOur model is able to classify indoor with **76% accuracy (max)**!\n\nIt's great to see the model's predictions on the test set. It works pretty good on external images too!\n\nYou can try experimenting with more images and see the results!","8b998bb8":"Now, we'll create training and validation dataloaders using `DataLoader`.","e9185e2d":"# Database\n\nThe database contains 67 Indoor categories, and a total of 15620 images. The number of images varies across categories, but there are at least 100 images per category. All images are in jpg format. The images provided here are for research purposes only."}}