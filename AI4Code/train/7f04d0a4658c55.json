{"cell_type":{"1aa4e885":"code","907cefec":"code","aaf049da":"code","4de49c81":"code","f41930c6":"code","cd1ad919":"code","9bfb5389":"code","da8bd60b":"code","88c34b28":"code","ea8e00d8":"code","fd5997ca":"code","deccb295":"code","fbf16dfe":"code","3bf801ee":"code","834cdaf2":"code","70400ef5":"markdown","9c1b2496":"markdown","46526d0b":"markdown","01a62553":"markdown"},"source":{"1aa4e885":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\npd.set_option('display.max_columns', 500)\npd.set_option('display.max_rows', 500)\n# Standard plotly imports\n#import plotly as py\n#import plotly.graph_objs as go\n#import plotly.tools as tls\n#from plotly.offline import iplot, init_notebook_mode\n#import cufflinks\n#import cufflinks as cf\n#import plotly.figure_factory as ff\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n#from sklearn import preprocessing\nfrom sklearn.metrics import roc_auc_score\n#from sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, roc_auc_score, confusion_matrix\nimport xgboost as xgb\nfrom xgboost import XGBClassifier\nimport gc\nimport cudf","907cefec":"%%time\ndata = cudf.read_csv('\/kaggle\/input\/jane-street-market-prediction\/train.csv')\nprint (\"Data is loaded!\")","aaf049da":"data.head(10)","4de49c81":"data = data.fillna(-99)\nfeatures = [c for c in data.columns if 'feature' in c]\ndata[\"feature_x1\"] = data[\"feature_129\"] \/ data[\"feature_127\"] # just ....\ndata[\"feature_x2\"] = data[\"feature_125\"] \/ data[\"feature_123\"] # nothing special !! \n\n#data = data.astype('float32')\ndata = data[data.weight != 0]\ndata['action'] = (data['resp']>0)*1\n\n \ntrain = data[(data.date <= 450)]\n\nvalid = data[data.date > 450]\nweights = train[\"weight\"]\n\nX_train = train.loc[:, features]\ny_train = train.loc[:, 'action']\n\nX_valid = valid.loc[:, features]\ny_valid = valid.loc[:, 'action']\ndel train, data\ngc.collect()","f41930c6":"print(\"train shape\", X_train.shape)\nprint(\"valid shape\", X_valid.shape)","cd1ad919":"# Prepare data and train xgboost on GPU\nparams = dict(\n    objective='binary:logistic',\n    max_depth=10,\n    learning_rate=0.05,\n    eval_metric = 'auc',\n    colsample_bytree=0.7,\n    missing=-99,\n    random_state=2020,\n    tree_method='gpu_hist')\n\ndtrain = xgb.DMatrix(X_train, y_train)\ndvalid = xgb.DMatrix(X_valid, y_valid)","9bfb5389":"clf = xgb.train(\n    params, dtrain, \n    num_boost_round=500, \n    verbose_eval=50,\n    early_stopping_rounds=100,\n    evals=[(dtrain, 'train'), (dvalid, 'eval')],\n)","da8bd60b":"def utility_scoring(df):\n    \"\"\"\n    To get the utility score used in the challenge.\n    \"\"\"\n    from math import sqrt\n    u = 0\n    Pi = []\n    Pis = []\n    count_i = len(df['date'].unique())\n    for i in list(df['date'].unique()):\n        #print(\"date value= \", i)\n        #print(10*\"=\")\n        tmp = df[df['date'] == i][[\"date\",\"weight\",\"resp\",\"actionv\"]]\n        tmp[\"mult\"] = tmp['weight'] * tmp['resp'] * tmp['actionv']\n        Pi.append(tmp[\"mult\"].sum())\n        Pis.append((tmp[\"mult\"].sum())**2)\n    \n    t =  sum(Pi)\/sqrt(sum(Pis)) * sqrt(250\/count_i)\n    u = min(max(t,0),6)*sum(Pi)\n    return u","88c34b28":"best_i = 0\nbest_u = 0\nfor i in [0.41, 0.45,0.49,0.5, 0.51,0.52, 0.55, 0.6,0.63, 0.65]:\n    \n    valid['actionv'] = (clf.predict(dvalid).round(4) > i)*1\n    u = utility_scoring(valid.to_pandas())\n    print(u)\n    if u > best_u:\n        best_u = u\n        best_i = i","ea8e00d8":"best_u","fd5997ca":"best_i","deccb295":"valid['actionv'] = (clf.predict(dvalid).round() > 0.51)*1","fbf16dfe":"utility_scoring(valid.to_pandas())","3bf801ee":"valid.action.value_counts()","834cdaf2":"valid.actionv.value_counts()","70400ef5":"# 2. Import Data","9c1b2496":"# 4 - utility scoring function","46526d0b":"# 1. Import packages","01a62553":"# 3 - XGBoost model"}}