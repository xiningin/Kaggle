{"cell_type":{"0cee27f3":"code","cdc4bb22":"code","2f734784":"code","a45f05bf":"code","2e155a8e":"code","d6f58ada":"code","5118bf68":"code","b382becf":"code","16fce9da":"code","87141f35":"code","2a6ec3ed":"code","2481cc0b":"code","4f0dacc6":"code","c118af30":"code","2b844b08":"code","446a62fe":"code","61b9b7e8":"code","977f1a7a":"markdown","1f9937e1":"markdown","104114c9":"markdown","6c601ff8":"markdown"},"source":{"0cee27f3":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         if 'jpg' in filename:\n#             continue\n#         print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","cdc4bb22":"import gc\nimport os\nimport time\nimport random\nimport collections\nimport uuid\n\nfrom glob import glob\nfrom datetime import datetime\n\nimport cv2\nimport torch\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nSEED = 42\n\ndef seed_everything(seed):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = True\n\nseed_everything(SEED)","2f734784":"!ls \/kaggle\/input\/check-clean-big-small-bboxes\/train_clean.csv","a45f05bf":"df = pd.read_csv('\/kaggle\/input\/check-clean-big-small-bboxes\/train_clean.csv')\n\nbboxs = np.stack(df['bbox'].apply(lambda x: np.fromstring(x[1:-1], sep=',')))\nfor i, column in enumerate(['x', 'y', 'w', 'h']):\n    df[column] = bboxs[:,i]\ndf.drop(columns=['bbox'], inplace=True)","2e155a8e":"df.head(5)","d6f58ada":"def adjust_bbox_in_image(\n    i_w,\n    i_h,\n    bbox,\n    min_bbox_size=20):\n    \"\"\"crop bbox if it cover the edge of the cropped image\"\"\"\n    \n    x, y, w, h = bbox\n    if x < 0:\n        w += x\n        x = 0\n    if y < 0:\n        h += y\n        y = 0\n    if i_w < x+w:\n        w -= (x+w-i_w)\n    if i_h < y+h:\n        h -= (y+h-i_h)\n    \n    on_border = x < 3 or y < 3 or i_w-3 < (x+w) or i_h-3 < (y+h)\n    under_min_size = w < min_bbox_size or h < min_bbox_size\n    if on_border and under_min_size:\n        return None\n    \n    return (x, y, w, h)\n\n\ndef make_puzzles(\n    image_id,\n    bboxes,\n    min_bbox_size=20,\n    image_root='\/kaggle\/input\/global-wheat-detection\/train\/'):\n    \"\"\"divide given image into 4 pieces with bboxes\"\"\"\n\n    img_path = os.path.join(image_root, '{}.jpg'.format(image_id))\n    \n    image = cv2.imread(img_path)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    \n    row, col, _ = image.shape\n    \n    y_div = int(row\/2)\n    x_div = int(col\/2)\n    lt = image[:y_div, :x_div] # left top\n    rt = image[:y_div, x_div:] # right top\n    lb = image[y_div:, :x_div] # left bottom\n    rb = image[y_div:, x_div:] # right bottom\n    \n    lt_bboxes, rt_bboxes, lb_bboxes, rb_bboxes = [], [], [], []\n    \n    for bbox in bboxes:\n        x, y, w, h = bbox\n        \n        # Quandrant-2\n        lt_x, lt_y = x, y\n        if lt_y < y_div and lt_x < x_div:\n            _bbox = adjust_bbox_in_image(col\/2, row\/2, bbox, min_bbox_size=min_bbox_size)\n            if _bbox:\n                lt_bboxes.append(_bbox)\n        \n        # Quandrant-1\n        rt_x, rt_y = x+w-1, y\n        if rt_y < y_div and x_div <= rt_x:\n            _bbox = (bbox[0]-col\/2, bbox[1], bbox[2], bbox[3])\n            _bbox = adjust_bbox_in_image(col\/2, row\/2, _bbox, min_bbox_size=min_bbox_size)\n            if _bbox:\n                rt_bboxes.append(_bbox)\n            \n        # Quandrant-3\n        lb_x, lb_y = x, y+h-1\n        if y_div <= lb_y and lb_x < x_div:\n            _bbox = (bbox[0], bbox[1]-row\/2, bbox[2], bbox[3])\n            _bbox = adjust_bbox_in_image(col\/2, row\/2, _bbox, min_bbox_size=min_bbox_size)\n            if _bbox:\n                lb_bboxes.append(_bbox)\n        \n        # Quandrant-4\n        rb_x, rb_y = x+w-1, y+h-1\n        if y_div <= rb_y and x_div <= rb_x:\n            _bbox = (bbox[0]-col\/2, bbox[1]-row\/2, bbox[2], bbox[3])\n            _bbox = adjust_bbox_in_image(col\/2, row\/2, _bbox, min_bbox_size=min_bbox_size)\n            if _bbox:\n                rb_bboxes.append(_bbox)\n    \n    puzzle_bbox_pairs = [\n        (lt, lt_bboxes),\n        (rt, rt_bboxes),\n        (lb, lb_bboxes),\n        (rb, rb_bboxes)\n    ]\n    \n    return puzzle_bbox_pairs\n\n\ndef merge_random_4_puzzles(puzzle_bbox_pairs):\n    lt_img, lt_bboxes = puzzle_bbox_pairs[0]\n    rt_img, rt_bboxes = puzzle_bbox_pairs[1]\n    lb_img, lb_bboxes = puzzle_bbox_pairs[2]\n    rb_img, rb_bboxes = puzzle_bbox_pairs[3]\n    \n    row, col, ch = lt_img.shape\n    x_div = col\n    y_div = row\n    \n    empty_img = np.zeros((row*2, col*2, ch), np.uint8)\n    \n    empty_img[:y_div,:x_div,:] = lt_img\n    empty_img[:y_div,x_div:,:] = rt_img\n    empty_img[y_div:,:x_div,:] = lb_img\n    empty_img[y_div:,x_div:,:] = rb_img\n    \n    _lt_bboxes = lt_bboxes[:]\n    _rt_bboxes = rt_bboxes[:]\n    for i, bbox in enumerate(_rt_bboxes):\n        x, y, w, h = bbox\n        _rt_bboxes[i] = (x+x_div, y, w, h)\n    \n    _lb_bboxes = lb_bboxes[:]\n    for i, bbox in enumerate(_lb_bboxes):\n        x, y, w, h = bbox\n        _lb_bboxes[i] = (x, y+y_div, w, h)\n    \n    _rb_bboxes = rb_bboxes[:]\n    for i, bbox in enumerate(_rb_bboxes):\n        x, y, w, h = bbox\n        _rb_bboxes[i] = (x+x_div, y+y_div, w, h)\n        \n    merged_bbox = _lt_bboxes + _rt_bboxes + _lb_bboxes + _rb_bboxes\n    \n    return (empty_img, merged_bbox)\n    \n\ndef visualize_4_image_bbox(puzzle_bbox_pairs):\n    fig, ax = plt.subplots(2, 2, figsize=(12, 12))\n    ax = ax.flatten()\n\n    labels = ['left top', 'right top', 'left bot', 'right bot']\n\n    for i in range(4):\n        image, bboxes = puzzle_bbox_pairs[i]\n        for row in bboxes:\n            x, y, w, h = (int(n) for n in row)\n            cv2.rectangle(image,\n                          (x, y),\n                          (x+w, y+h),\n                          (220, 0, 0), 3)\n        ax[i].set_axis_off()\n        ax[i].imshow(image)\n        ax[i].set_title(labels[i], color='yellow')\n\n        \ndef visualize_image_bbox(image, bboxes):\n    fig, ax = plt.subplots(1, 1, figsize=(12, 12))\n\n    for row in bboxes:\n        x, y, w, h = (int(n) for n in row)\n        cv2.rectangle(image,\n                      (x, y),\n                      (x+w, y+h),\n                      (220, 0, 0), 3)\n    ax.imshow(image)\n","5118bf68":"from tqdm import tqdm","b382becf":"pool = []\nimage_ids = set(df.image_id.values)\n\nfor i, image_id in tqdm(enumerate(image_ids)):\n    \n    filtered = df[df['image_id'] == image_id]\n    bboxes = filtered[['x', 'y', 'w', 'h']].values\n    \n    puzzles = make_puzzles(image_id, bboxes, min_bbox_size=20)\n    \n    pool += puzzles","16fce9da":"k = 3300","87141f35":"AugData = collections.namedtuple('AugData', 'image_id,width,height,source,x,y,w,h')","2a6ec3ed":"aug_data = []\n\nos.makedirs('.\/merged_puzzles', exist_ok=True)\n\nfor i in tqdm(range(k)):\n    random.shuffle(pool)\n    a = ([bbox for img, bbox in pool[:4]])\n    merged_image, merged_bboxes = merge_random_4_puzzles(pool[:4])\n    ih, iw, ch = merged_image.shape\n    image_id = str(uuid.uuid4())\n    for bbox in merged_bboxes:\n        x, y, w, h = bbox\n        aug_data.append(AugData(image_id=image_id, width=iw, height=ih, source='aug', x=x, y=y, w=w, h=h))\n    merged_image = cv2.cvtColor(merged_image, cv2.COLOR_RGB2BGR)\n    cv2.imwrite('.\/merged_puzzles\/{}.jpg'.format(image_id), merged_image)        ","2481cc0b":"aug_data[:2]","4f0dacc6":"aug_df = pd.DataFrame(data=aug_data)\naug_df.to_csv('merged_puzzles.csv', index=False)","c118af30":"import re\ntrain_df = aug_df \n# train_df['x'] = -1\n# train_df['y'] = -1\n# train_df['w'] = -1\n# train_df['h'] = -1\n\n# def expand_bbox(x):\n#     r = np.array(re.findall(\"([0-9]+[.]?[0-9]*)\", x))\n#     if len(r) == 0:\n#         r = [-1, -1, -1, -1]\n#     return r\n\n# train_df[['x', 'y', 'w', 'h']] = np.stack(train_df['bbox'].apply(lambda x: expand_bbox(x)))\n# train_df.drop(columns=['bbox'], inplace=True)\ntrain_df['x'] = train_df['x'].astype(np.float)\ntrain_df['y'] = train_df['y'].astype(np.float)\ntrain_df['w'] = train_df['w'].astype(np.float)\ntrain_df['h'] = train_df['h'].astype(np.float)\n\ntrain_df.head(5)","2b844b08":"import matplotlib.pyplot as plt\nimport cv2\nimport matplotlib.patches as patches\ndef get_bbox(bboxes, col, color='red', bbox_format='coco'):\n    \n    for i in range(len(bboxes)):\n            rect = patches.Rectangle(\n                (bboxes[i][0], bboxes[i][1]),\n                bboxes[i][2], \n                bboxes[i][3], \n                linewidth=1, \n                edgecolor=color, \n                facecolor='none')\n\n            col.add_patch(rect)","446a62fe":"ids = train_df.image_id.unique()","61b9b7e8":"import os\nBASE_DIR = '\/kaggle\/working\/merged_puzzles'\nfig, ax = plt.subplots(nrows=10, ncols=1, figsize=(60, 60))\nk = 10\nfor i in range(k,k+10):\n    image_id = ids[i]\n    boxes = train_df[train_df['image_id'] == image_id][['x', 'y', 'w', 'h']].astype(np.int32).values\n    image = cv2.imread(os.path.join(BASE_DIR, f'{image_id}.jpg'), cv2.IMREAD_COLOR)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB).astype(np.float32)\n    image = image\/255\n    get_bbox(boxes, ax[i-k], color='red', bbox_format='coco')\n    ax[i-k].imshow(image)\n    ax[i-k].title.set_text(i)\nplt.show()","977f1a7a":"## Make puzzle pool","1f9937e1":"## Augmentation\n1. divide an image into 4 pieces(puzzles) with bbox\n2. make pool of puzzles of all original images (in train_data)\n3. sample 4 pieces & merge (repeat k-times)\n4. save as a dataframe & jpg images","104114c9":"This code is from [@shonenkov\/training-efficientdet](https:\/\/www.kaggle.com\/shonenkov\/training-efficientdet\/data)\n\n\nhttps:\/\/www.kaggle.com\/raininbox\/check-clean-big-small-bboxes","6c601ff8":"## Generate Augmented k-Images"}}