{"cell_type":{"9398e766":"code","c5ab3a55":"code","2ce94e2f":"code","06bde9cb":"code","e4ceded5":"code","9c479cad":"code","f84e7b2e":"code","f2a46367":"code","35ee4650":"code","e4a320bd":"code","4d650e3a":"code","63623316":"code","37bd8726":"code","4313fbbe":"markdown","7d4d524a":"markdown","6737e310":"markdown","c2c1743d":"markdown","4da7b708":"markdown","1e660b79":"markdown","fd01dde7":"markdown","47277f5c":"markdown","f8ef89d3":"markdown","52be5484":"markdown","bcb4abd6":"markdown","ce5ed5cd":"markdown","e742501b":"markdown","c6c3a3b5":"markdown","d3416669":"markdown"},"source":{"9398e766":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c5ab3a55":"# import the dataset\ndf = pd.read_csv('..\/input\/browser-trends\/multiTimeline.csv', parse_dates=['Month'], index_col='Month')\ndisplay(df)\ndf.plot(figsize=(8,6))","2ce94e2f":"# window parameter usage:\n#     Size of the moving window.\n#     If an integer, the fixed number of observations used for each window.\n#     If an offset, the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes. \n\n\nrolling_six = df.rolling(window=6).mean()\ndisplay(rolling_six)","06bde9cb":"# bigger plot elements suitable for giving talks\nsns.set_context(\"talk\")\n# set figure size\nplt.figure(figsize=(12,9))\n# Time series plot with Seaborn lineplot()\nsns.lineplot(x=\"Month\", y='Firefox: (Worldwide)', \n            data=rolling_six, ci=None)\nsns.lineplot(x=\"Month\", y='Safari: (Worldwide)', \n            data=rolling_six, ci=None)\nsns.lineplot(x=\"Month\", y='Google Chrome: (Worldwide)', \n            data=rolling_six, ci=None)\nsns.lineplot(x=\"Month\", y='Internet Explorer: (Worldwide)', \n            data=rolling_six, ci=None)\nsns.lineplot(x=\"Month\", y='Opera: (Worldwide)', data=rolling_six, ci=None)\n# axis labels\nplt.xlabel(\"Date\", size=14)\nplt.ylabel(\"Monthly increase in browser trends\", size=14)\n\nplt.legend(labels=[\"Firefox: (Worldwide)\",\"Safari: (Worldwide)\", \"Google Chrome: (Worldwide)\", \"Internet Explorer: (Worldwide)\", \"'Opera: (Worldwide)'\"])\n# save image as PNG file\nplt.savefig(\"Time_Series_Plot_with_Seaborn.png\",\n                    format='png',\n                    dpi=200)","e4ceded5":"# pd.DataFrame.pct_change() usage:\n# Percentage change between the current and a prior element.\n# Computes the percentage change from the immediately previous row by default. This is useful in comparing the percentage of change in a time series of elements.\n\npct_change_quaterly = df.pct_change(3)*100\npct_change_quaterly = pct_change_quaterly.loc['2009':]\ndisplay(pct_change_quaterly)\npct_change_quaterly.plot(subplots=True, figsize=(12,9))","9c479cad":"# save the years in a list\nyears = ['2009', '2012', '2016', '2018', '2021']\n# create a new data-frame\nchrome_trends = pd.DataFrame()\n#iterate over the years and concat the data from the browser column and display the data  \nfor year in years:\n    chrome_trends_yearly = df.loc[year, ['Google Chrome: (Worldwide)']].reset_index(drop=True)\n    chrome_trends_yearly.rename(columns={'Google Chrome: (Worldwide)': year}, inplace=True)\n    chrome_trends = pd.concat([chrome_trends, chrome_trends_yearly], axis=1)\ndisplay(chrome_trends)\nchrome_trends.plot(title=\"Chrome Search Performance in 2009, 2012, 2016, 2018, 2021\", figsize=(12,9))","f84e7b2e":"years = ['2009', '2012', '2016', '2018', '2021']\nfirefox_trends = pd.DataFrame()\nfor year in years:\n    firefox_trends_yearly = df.loc[year, ['Firefox: (Worldwide)']].reset_index(drop=True)\n    firefox_trends_yearly.rename(columns={'Firefox: (Worldwide)': year}, inplace=True)\n    firefox_trends = pd.concat([firefox_trends, firefox_trends_yearly], axis=1)\ndisplay(firefox_trends)\nfirefox_trends.plot(title=\"Firefox Search Performance in 2009, 2012, 2016, 2018, 2021\", figsize=(12,9))","f2a46367":"    \nyears = ['2009', '2012', '2016', '2018', '2021']\nie_trends = pd.DataFrame()\nfor year in years:\n    ie_trends_yearly = df.loc[year, ['Internet Explorer: (Worldwide)']].reset_index(drop=True)\n    ie_trends_yearly.rename(columns={'Internet Explorer: (Worldwide)': year}, inplace=True)\n    ie_trends = pd.concat([ie_trends, ie_trends_yearly], axis=1)\ndisplay(ie_trends)\nie_trends.plot(title=\"Internet Explorer Search Performance in 2009, 2012, 2016, 2018, 2021\", figsize=(12,9))","35ee4650":"dfi = pd.read_csv('..\/input\/browsertrends\/india-specific.csv', parse_dates=['Month'], index_col='Month')\ndisplay(dfi)\ndfi.plot(title=\"India specific browser trends\", figsize=(12,9))","e4a320bd":"rolling_six_ind = dfi.rolling(6).mean()\ndisplay(rolling_six_ind)\nrolling_six_ind.plot(title=\"rolling avg browser trends\", figsize=(12,9))","4d650e3a":"pct_change_quaterly_ind = dfi.pct_change(3)*100\npct_change_quaterly_ind = pct_change_quaterly_ind.loc['2009':]\ndisplay(pct_change_quaterly)\npct_change_quaterly_ind.plot(subplots=True, figsize=(12,9))","63623316":"years = ['2009', '2012', '2016', '2018', '2021']\ngc_trends_ind = pd.DataFrame()\nfor year in years:\n    gc_trends_yearly_ind = dfi.loc[year, ['Google Chrome: (India)']].reset_index(drop=True)\n    gc_trends_yearly_ind.rename(columns={'Google Chrome: (India)': year}, inplace=True)\n    gc_trends_ind = pd.concat([gc_trends_ind, gc_trends_yearly_ind], axis=1)\ndisplay(firefox_trends_ind)\ngc_trends_ind.plot(title=\"Google Chrome Search Performance in 2009, 2012, 2016, 2018, 2021\", figsize=(12,9))","37bd8726":"years = ['2009', '2012', '2016', '2018', '2021']\nfirefox_trends_ind = pd.DataFrame()\nfor year in years:\n    firefox_trends_yearly_ind = dfi.loc[year, ['Firefox: (India)']].reset_index(drop=True)\n    firefox_trends_yearly_ind.rename(columns={'Firefox: (India)': year}, inplace=True)\n    firefox_trends_ind = pd.concat([firefox_trends_ind, firefox_trends_yearly_ind], axis=1)\ndisplay(firefox_trends_ind)\nfirefox_trends_ind.plot(title=\"Firefox Search Performance in 2009, 2012, 2016, 2018, 2021\", figsize=(12,9))","4313fbbe":"# Google defines the values of search interest as:\n\n> Numbers represent search interest relative to the highest point on the chart for the given region and time. A value of 100 is the peak popularity for the term. A value of 50 means that the term is half as popular. A score of 0 means there was not enough data for this term.","7d4d524a":"# **Comparing browser trends using time series analysis**\n\n\n> *In the mid 1990s, the First Browser War began with Netscape Navigator and Microsoft Internet Explorer fighting for dominance. By 2001, Internet Explorer was the clear winner, but it was not long before the Second Browser Wars began (2004-2017). This coincided with the rise of smartphones, which emphasized the need and competitiveness for more mobile-friendly versions of browsers.*","6737e310":"# Rolling average","c2c1743d":"-------------------------------------------------------------------------------------------------------------------------","4da7b708":"# **Google Chrome (World wide)**","1e660b79":"# Rolling average ?\n\n> *In statistics, a moving average (rolling average or running average) is a calculation to analyze data points by creating a series of averages of different subsets of the full data set. It is also called a moving mean or rolling mean and is a type of finite impulse response filter.*","fd01dde7":"# Problem statements:\n*   Find the six month rolling average.\n*   Find the percentage change from the previous quarter for each date and browser.\n*   compare annual Google Trends of browser performance in 2009, 2012, 2016, 2018, 2021\n*   Analyze browser trends of India","47277f5c":"# **Browser trends India specific**","f8ef89d3":"First lets start by importing the datset and plotting the data which we have recieved. The data is condensed and is a bit hard to work with. So lets perform a six month rolling average on the dataset to recieve a more refined data to work with. The results have been plotted below.","52be5484":"# Comparison of annual Google Trends of browser performance in 2009, 2012, 2016, 2018, 2021\n\n> *Now lets see how each of the top and most used browsers have aged in usage over the specified years above*","bcb4abd6":"# **Fire Fox (World Wide)**","ce5ed5cd":"# **Internet Explorer (World Wide)**","e742501b":"# Percentage change is the previous quarter:\n\n> Here the percentage change from the previous quarter for each date and browser is calculated. Considering chrome was launched after 2009, values have been taken from dates after 2009.\n\n","c6c3a3b5":"# annual Google Trends of browser performance in 2009, 2012, 2016, 2018, 2021 specific to India","d3416669":"# Quarterly subset analysis"}}