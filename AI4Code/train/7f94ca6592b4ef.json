{"cell_type":{"a68bc0cf":"code","ec425f88":"code","b791fb17":"code","167d1b83":"code","26901cc9":"code","63afa48a":"markdown","b6ce0924":"markdown","73716bea":"markdown","c059cd53":"markdown"},"source":{"a68bc0cf":"# imports\nimport os\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.utils import compute_class_weight\nfrom imblearn.under_sampling import NearMiss\nfrom imblearn.over_sampling import SMOTE\nfrom imblearn.combine import SMOTETomek\n\nos.environ[\"WANDB_API_KEY\"] = \"0\" ## to silence warning","ec425f88":"fullDf = pd.read_csv('\/kaggle\/input\/drug-classification\/drug200.csv')","b791fb17":"# Helper methods...\n\ndef encode_cat(series):\n    \"\"\"Encodes categorical series into numeric values.\n    \n    Args:\n        series (Pandas.Series): The series to encode.\n    \n    Returns:\n        a Tuple containing Pandas.Series of the encoded values and a mapping dictionary.\n    \"\"\"\n    le = LabelEncoder()\n    encoded=le.fit_transform(series)\n    \n    return encoded, get_integer_mapping(le)\n\n\ndef get_integer_mapping(le):\n    '''Gets a dict mapping labels to their integer values from an SKlearn LabelEncoder.\n    \n    Args:\n        le (LabelEncoder): A fitted label encoder.\n        \n    Returns:\n        Mapping Dictionary.\n    '''\n    res = {}\n    for cl in le.classes_:\n        res.update({cl:le.transform([cl])[0]})\n\n    return res\n\n\ndef get_key(mapping_dict, val):\n    \"\"\"Gets key for a given value in a dictionary\n    \n    Args:\n        mapping_dict ({<category name>:<numeric value>}): The dictionary containing the category name and it's numeric repersentation.\n        \n        val (int): the desired value.\n        \n    Returns:\n        The category name for that requested value.\n    \"\"\"\n    for key, value in mapping_dict.items():\n        if val == value:\n            return key\n        \n\ndef get_class_weights(series, class_map=None):\n    \"\"\"Calculates weights for each class.\n    \n    Args:\n        series (Pandas.Series): The series containing the categories to compute.\n        \n        class_map (mapping dictionary)(optional): A mapping dict used to map the class names to their numeric value.\n        \n    Returns:\n        {'<category>':'<weight>'}\n    \n    \"\"\"\n    \n    class_weight = compute_class_weight('balanced', series.unique() , series)\n\n    return_dict = {}\n    \n    for index, weight in enumerate(class_weight):\n        if class_map == None:\n            return_dict[index] = weight\n        else:\n            return_dict[get_key(class_map, index)] = weight\n        \n    return return_dict\n\n\ndef undersample_set(x_train_features, x_train_labels):\n    \"\"\"Undersamples dataset using NearMiss\n    \n    Args:\n        x_train_features (numpy.array): Array containing the variables.\n        \n        x_train_labels (numpy.array): Array containing the labels for the set.\n        \n    Returns:\n        Tuple containing the resampled variables and labels.\n    \"\"\"\n\n    near = NearMiss(sampling_strategy=\"not minority\")\n\n    return near.fit_resample(x_train, y_train)\n\n\ndef oversample_set(x_train_features, x_train_labels):\n    \"\"\"Oversamples dataset using SMOTE\n    \n    Args:\n        x_train_features (numpy.array): Array containing the variables.\n        \n        x_train_labels (numpy.array): Array containing the labels for the set.\n        \n    Returns:\n        Tuple containing the resampled variables and labels.\n    \"\"\"\n\n    smote = SMOTE(sampling_strategy='minority')\n\n    # fit the object to our training data\n    return smote.fit_resample(x_train_features, x_train_labels)\n\n\ndef resample_set(x_train_features, x_train_labels):\n    \"\"\"Oversamples and Undersamples dataset using SMOTETomek\n    \n    Args:\n        x_train_features (numpy.array): Array containing the variables.\n        \n        x_train_labels (numpy.array): Array containing the labels for the set.\n        \n    Returns:\n        Tuple containing the resampled variables and labels.\n    \"\"\"\n    \n    smotemek = SMOTETomek(sampling_strategy='auto')\n\n    return smotemek.fit_resample(x_train, y_train)","167d1b83":"# Fix types...\ncat_vars = ['Sex', 'BP', 'Cholesterol', 'Drug']\n\nfor var in cat_vars:\n    fullDf[var] = fullDf[var].astype('category')\n    \n# Encode...\nenc_sex, sex_map = encode_cat(fullDf.Sex)\nenc_cho, cho_map = encode_cat(fullDf.Cholesterol)\nenc_BP, bp_map = encode_cat(fullDf.BP)\nenc_drug, drug_map = encode_cat(fullDf.Drug)\n\n# Join encoded values back to set...\n#fullDf['enc_sex'] = enc_sex The model was overfitting slightly when sex was included in the set...\nfullDf['enc_cho'] = enc_cho\nfullDf['enc_BP'] = enc_BP\nfullDf['enc_drug'] = enc_drug\n\n# Drop unencoded columns...\nfullDf.drop('Sex', axis=1, inplace=True)\nfullDf.drop('Cholesterol', axis=1, inplace=True)\nfullDf.drop('BP', axis=1, inplace=True)\nfullDf.drop('Drug', axis=1, inplace=True)\n\n# Split the sets... \nx_train, x_test, y_train, y_test = train_test_split(fullDf.loc[ : , fullDf.columns != 'enc_drug'], fullDf.enc_drug, test_size=0.33, random_state=42)\n\n# resample\nx_train_resampled, y_train_resampled = resample_set(x_train, y_train)","26901cc9":"# Encoded FullDf\nfullDf.to_csv('\/kaggle\/working\/Fact_Encoded_fullDf.csv')\n\n# Imbalanced train\/test feaures and labels\nx_train.to_csv('\/kaggle\/working\/Fact_imb_train_features.csv')\ny_train.to_csv('\/kaggle\/working\/Fact_imb_train_labels.csv')\n\nx_test.to_csv('\/kaggle\/working\/Fact_imb_test_features.csv')\ny_test.to_csv('\/kaggle\/working\/Fact_imb_test_labels.csv')\n\n# Resampled train features and labels\nx_train_resampled.to_csv('\/kaggle\/working\/Fact_resampled_train_features.csv')\ny_train_resampled.to_csv('\/kaggle\/working\/Fact_resampled_train_labels.csv')","63afa48a":"## Transform \/ Cleaning\n\nCorrect data types, encodes categorical fields, resamples, and splits data as required... ","b6ce0924":"## Load\n\nWrites training and testing facts to file.","73716bea":"# Drug Classification ETL\n\nThis notebook contains the Extract Transform (and cleaning) Load workflow for the Drug Classification project.","c059cd53":"## Extract\n\nReads in data from csv, validates import."}}