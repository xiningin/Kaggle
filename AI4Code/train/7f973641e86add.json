{"cell_type":{"52ea8660":"code","c4c3dfdd":"code","a3e2ecfb":"code","4770652e":"code","1535f9ec":"code","fd8a28dc":"code","678dd6dc":"code","b018afff":"code","df0a792c":"code","b47bacf0":"code","5c40f5bf":"markdown","537a875f":"markdown","d8f779ff":"markdown","52a1a15d":"markdown","c3529301":"markdown","631807c7":"markdown","430bb475":"markdown","6398e306":"markdown"},"source":{"52ea8660":"import os\n\nfrom numba import njit\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm_notebook as tqdm","c4c3dfdd":"base_path = '\/kaggle\/input\/santa-2019-workshop-scheduling\/'\ndata = pd.read_csv(base_path + 'family_data.csv', index_col='family_id')\nsubmission = pd.read_csv(base_path + 'sample_submission.csv', index_col='family_id')","a3e2ecfb":"N_DAYS = 100\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125","4770652e":"def build_choice_array(data, n_days):\n    choice_array_num = np.full((data.shape[0], n_days + 1), -1)\n\n    for i, choice in enumerate(choice_matrix):\n        for d, day in enumerate(choice):\n            choice_array_num[i, day] = d\n    \n    return choice_array_num","1535f9ec":"def precompute_accounting(max_day_count=MAX_OCCUPANCY, max_diff=MAX_OCCUPANCY):\n    accounting_matrix = np.zeros((max_day_count+1, max_diff+1))\n    # Start day count at 1 in order to avoid division by 0\n    for today_count in range(1, max_day_count+1):\n        for diff in range(max_diff+1):\n            accounting_cost = (today_count - 125.0) \/ 400.0 * today_count**(0.5 + diff \/ 50.0)\n            accounting_matrix[today_count, diff] = max(0, accounting_cost)\n    \n    return accounting_matrix","fd8a28dc":"def precompute_penalties(choice_array_num, family_size):\n    penalties_array = np.array([\n        [\n            0,\n            50,\n            50 + 9 * n,\n            100 + 9 * n,\n            200 + 9 * n,\n            200 + 18 * n,\n            300 + 18 * n,\n            300 + 36 * n,\n            400 + 36 * n,\n            500 + 36 * n + 199 * n,\n            500 + 36 * n + 398 * n\n        ]\n        for n in range(family_size.max() + 1)\n    ])\n    \n    penalty_matrix = np.zeros(choice_array_num.shape)\n    N = family_size.shape[0]\n    for i in range(N):\n        choice = choice_array_num[i]\n        n = family_size[i]\n        \n        for j in range(penalty_matrix.shape[1]):\n            penalty_matrix[i, j] = penalties_array[n, choice[j]]\n    \n    return penalty_matrix","678dd6dc":"@njit\ndef cost_function(prediction, family_size, days_array, penalty_matrix, accounting_matrix):\n    N = family_size.shape[0]\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = np.zeros(len(days_array)+1, dtype=np.int64)\n    penalty = 0\n    \n    # Looping over each family; d is the day, n is size of that family\n    for i in range(N):\n        n = family_size[i]\n        d = prediction[i]\n        \n        daily_occupancy[d] += n\n        penalty += penalty_matrix[i, d]\n\n    # for each date, check total occupancy \n    # (using soft constraints instead of hard constraints)\n    # Day 0 does not exist, so we do not count it\n    relevant_occupancy = daily_occupancy[1:]\n    incorrect_occupancy = np.any(\n        (relevant_occupancy > MAX_OCCUPANCY) | \n        (relevant_occupancy < MIN_OCCUPANCY)\n    )\n    \n    if incorrect_occupancy:\n        return 100000000\n\n    # Calculate the accounting cost\n    # The first day (day 100) is treated special\n    init_occupancy = daily_occupancy[days_array[0]]\n    accounting_cost = (init_occupancy - 125.0) \/ 400.0 * init_occupancy**(0.5)\n    # using the max function because the soft constraints might allow occupancy to dip below 125\n    accounting_cost = max(0, accounting_cost)\n    \n    # Loop over the rest of the days_array, keeping track of previous count\n    yesterday_count = init_occupancy\n    for day in days_array[1:]:\n        today_count = daily_occupancy[day]\n        diff = abs(today_count - yesterday_count)\n        accounting_cost += accounting_matrix[today_count, diff]\n        yesterday_count = today_count\n\n    penalty += accounting_cost\n\n    return penalty","b018afff":"family_size = data.n_people.values\ndays_array = np.arange(N_DAYS, 0, -1)\nchoice_matrix = data.loc[:, 'choice_0': 'choice_9'].values\n\n# Precompute matrices needed for our cost function\nchoice_array_num = build_choice_array(data, N_DAYS)\npenalty_matrix = precompute_penalties(choice_array_num, family_size)\naccounting_matrix = precompute_accounting()\n\n# Start with the sample submission values\nbest = submission['assigned_day'].values\n\nstart_score = cost_function(best, family_size, days_array, penalty_matrix, accounting_matrix)","df0a792c":"%timeit cost_function(best, family_size, days_array, penalty_matrix, accounting_matrix)","b47bacf0":"new = best.copy()\n# loop over each family\nfor fam_id in tqdm(range(len(best))):\n    # loop over each family choice\n    for pick in range(10):\n        day = choice_matrix[fam_id, pick]\n        temp = new.copy()\n        temp[fam_id] = day # add in the new pick\n        score = cost_function(temp, family_size, days_array, penalty_matrix, accounting_matrix)\n        if score < start_score:\n            new = temp.copy()\n            start_score = score\n\nscore = cost_function(new, family_size, days_array, penalty_matrix, accounting_matrix)\nprint(f'Score: {score}')\nsubmission['assigned_day'] = new\nsubmission.to_csv(f'submission_{score}.csv')","5c40f5bf":"# Simple Optimization Approach\n\nFor each family, loop over their choices, and if keep it if the score improves. There's a lot of easy improvement that can be made to this code.","537a875f":"# About this kernel\n\nThe `cost_function` in this kernel is roughly 600x faster compared to the original kernel. Each function call takes roughly 23 \u00b5s.\n\n## Reference\n\n* (Excellent) Original Kernel: https:\/\/www.kaggle.com\/inversion\/santa-s-2019-starter-notebook\n* First kernel that had the idea to use Numba: https:\/\/www.kaggle.com\/nickel\/250x-faster-cost-function-with-numba-jit\n* Another great cost function optimization: https:\/\/www.kaggle.com\/sekrier\/fast-scoring-using-c-52-usec\n* ","d8f779ff":"## Load Data","52a1a15d":"## Helper Functions","c3529301":"# Cost Function","631807c7":"# Preliminary","430bb475":"## Constants","6398e306":"Let's see how fast it is:"}}