{"cell_type":{"20cb1190":"code","1e8672bc":"code","f9edc05b":"code","1d373b1b":"code","50e22269":"code","c4ec8760":"code","38d73595":"code","04d18e3a":"code","0f017a9e":"code","192a6ca2":"code","50c082a1":"code","f9d2fd28":"code","dee1b993":"code","48620a32":"code","a83e4871":"code","fe6c5533":"code","907c97a7":"code","f968714e":"code","3c5bbe62":"code","48bb8e45":"code","1340ce7c":"markdown","63b79ea8":"markdown","832bd988":"markdown","02f03727":"markdown","46ceb331":"markdown","8206fa7b":"markdown","d38fc441":"markdown","399238dc":"markdown","9982581a":"markdown","7da08b8f":"markdown","dc7517ed":"markdown","fc92e8e4":"markdown","79308235":"markdown","ee8f5a85":"markdown","662e4878":"markdown","78f53c4e":"markdown","bfd188ec":"markdown","f17fc272":"markdown","6d4a85e5":"markdown","dc5b8cb3":"markdown","8c98cce2":"markdown","35eeef06":"markdown","1ae17bb3":"markdown","73afc40f":"markdown","6f5b3ec0":"markdown","1fcae957":"markdown","9481f7a8":"markdown"},"source":{"20cb1190":"import numpy as np\nimport matplotlib.pyplot as plt\nimport csv\n","1e8672bc":"file_name = \"Example1.csv\"\nDataInput = []\nIndexMax = 10000\nf = lambda x: 3*np.sin(3*x\/IndexMax*2*np.pi)\n\nfor i in range(IndexMax) :\n    DataInput.append(f(i))","f9edc05b":"# Export of the fonction in a folder \nout_file = open(file_name, 'w', newline='')\nwrt = csv.writer(out_file)\nwrt.writerow(DataInput)\nout_file.close()\n","1d373b1b":"\n# Re-importation of the fonction and draw of it\nin_file = open(file_name, 'r')\nreader = list(csv.reader(in_file, quoting=csv.QUOTE_NONNUMERIC))\nDataInput = reader[0]\nin_file.close()","50e22269":"plt.plot(DataInput)\nplt.show()","c4ec8760":"# LSTM pour une variable simple\nfrom numpy import array\nimport math\nimport random\nimport matplotlib.pyplot as plt\nimport csv\nimport numpy as np\nfrom keras.models import Sequential\nfrom keras.layers import Flatten\nfrom keras.layers import Dense","38d73595":"n_steps = 1 # number of neurones for the NN\nn_features = 1 # reshape value \n\nfile_name = \"Example1.csv\"\n\nData_output=np.zeros([10000,1]) # Initialisation of databases for further using\nBDDtrain=np.zeros([2000,10000])\nBDDytarget=np.zeros([2000,8])\n\n","04d18e3a":"#BDD des differents cas nominaux :\n\nfor i in range(250):               #Loop for the first 1000 nominal cases - category 1\n    for j in range (10000):\n        BDDtrain[i,j] = DataInput[j] + random.random()\n\nfor i in range(250):               #Loop for the  1000 nominal cases - category 2\n    for j in range (10000):\n        BDDtrain[i + 250 ,j] = 1.25 * DataInput[j] + random.random()\n\nfor i in range(250):               #Loop for the  1000 nominal cases - category 3\n    for j in range (10000):\n        BDDtrain[i + 500 ,j] = 2 * DataInput[j] + random.random()\n\nfor i in range(250):               #Loop for the  1000 nominal cases - category 4\n    for j in range (10000):\n        BDDtrain[i + 750 ,j] =  DataInput[j]\n","0f017a9e":"##BDD d'anomalies :\nfor i in range(250):               #Loop for the  1000 Anomaly cases - category 1\n    for j in range (10000):\n        BDDtrain[i + 1000, j] =   DataInput[j] + (random.random()*10)\n\nfor i in range(250):               #Loop for the  1000 Anomaly cases - category 2\n    for j in range (10000):\n        BDDtrain[i + 1250, j] =   math.cos(j\/500)\n\nfor i in range(250):               #Loop for the  1000 Anomaly cases - category 3\n    for j in range (10000):\n        BDDtrain[i + 1500, j] =   (DataInput[j]\/10) + random.random()\n\nfor i in range(250):               #Loop for the  1000 Anomaly cases - category 4\n    for j in range (10000):\n        if j <= 2500:\n            BDDtrain[i + 1750, j] = 0\n        else:\n            BDDtrain[i + 1750, j] = DataInput[j] + random.random()\n","192a6ca2":"# Transform inputs in under-series of n_steps size\ndef shape_data(sequence):\n\n    X, y = list(), list()                                         # create into new list\n    seq_x = sequence[0:len(sequence)]\n    X.append(seq_x)                         #append x and y during the process\n    #for i in range (len(sequence)):\n    seq_y = 0\n    y.append(seq_y)\n    seq_y =1\n    y.append(seq_y)\n\n    return array(X), array(y)   # return the new shape inputs","50c082a1":"#Display of the 4 kinds of nominal types and the 4 types of anomaly 4.\n\n\nplt.subplot(2, 2, 1)\nplt.title('Nominal type 1');\nplt.plot(BDDtrain[200,:])\n\n#plt.show()\nplt.subplot(2, 2, 2)\nplt.title('Nominal type 2');\nplt.plot(BDDtrain[400,:])\n#plt.show()\nplt.subplot(2, 2, 3)\nplt.xlabel('Nominal type 3');\nplt.plot(BDDtrain[600,:])\n#plt.show()\nplt.subplot(2, 2, 4)\nplt.xlabel('Nominal type 4');\nplt.plot(BDDtrain[800,:])\nplt.show()\n\n\n\n\n#display of the 4 anomalies\nplt.subplot(2, 2, 1)\nplt.title('Anomaly 1');\nplt.plot(BDDtrain[1200,:])\n\n#plt.show()\nplt.subplot(2, 2, 2)\nplt.title('Anomaly 2');\nplt.plot(BDDtrain[1400,:])\n#plt.show()\nplt.subplot(2, 2, 3)\nplt.xlabel('Anomaly 3');\nplt.plot(BDDtrain[1600,:])\n#plt.show()\nplt.subplot(2, 2, 4)\nplt.xlabel('Anomaly 4');\nplt.plot(BDDtrain[1800,:])\nplt.show()","f9d2fd28":"# labelisation of the signals in 8 categories\nfor i in range (2000):\n    if i < 250:\n        BDDytarget[i, 0] = 1\n    if  250 <=  i  < 500:\n        BDDytarget[i, 1] = 1\n    if  500 <=  i  < 750:\n        BDDytarget[i, 2] = 1\n    if  750 <=  i  < 1000:\n        BDDytarget[i, 3] = 1\n    if  1000 <=  i  < 1250:\n        BDDytarget[i, 4] = 1\n    if  1250 <=  i  < 1500:\n        BDDytarget[i, 5] = 1\n    if  1500 <=  i  < 1750:\n        BDDytarget[i, 6] = 1\n    if  1750 <=  i  < 2000:\n        BDDytarget[i, 7] = 1\n","dee1b993":"X, y = shape_data(DataInput)   # call of the reshape function defined before","48620a32":"#reshape the database to give it a NN compatible shape\n\nX = BDDtrain.reshape((2000, 10000, n_features)) #reshape pour avoir un format d'entr\u00e9e de NN\ny = y.reshape(1,2)","a83e4871":"# creation of the model and its structure\nmodel = Sequential()\n\nmodel.add(Dense(5, activation='relu',input_shape=(10000, 1)))       \nmodel.add(Dense(3))\nmodel.add(Dense(3))\nmodel.add(Flatten())\nmodel.add(Dense(8,activation = \"softmax\"))\n\n\n","fe6c5533":"model.summary()","907c97a7":"#optimisation parameters\nmodel.compile(optimizer='adam', loss='binary_crossentropy',metrics = ['accuracy'])    ","f968714e":"model.fit(X, BDDytarget, epochs=10, verbose=1)      ","3c5bbe62":"#Application of the trained NN\n\nlisttemp =np.zeros([10000,1])\n\n\n#Reshape before prediction\nx_input = listtemp.reshape((1, 10000, n_features))     #reshape pour entr\u00e9e en NN\n\n\n#Prediction of the kind(anomaly or no)\nprediction = model.predict(x_input, verbose=0)\nscore = prediction[0,1]\nscore","48bb8e45":"#UTilisation of a test database\n\nBDDtest=np.zeros([10,10000])            # 10 for the number of signal we test\n                                        \npredictiontest = np.zeros([1000,2])\nfor i in range(10):               #loop to create one kind of signal\n    for j in range (10000):\n        BDDtest[i,j] =  2 * DataInput[j] + random.random()\n        \n\n\n\nBDDtest = BDDtest.reshape((10, 10000, n_features))     #reshape to get to the NN\n\n#Test and visualisation of the results\npredictiontest= model.predict(BDDtest, verbose=1)\nprint(predictiontest)\n\n#Hist plot and visualisation of the tested signal\nplt.bar(range(8), 100*predictiontest[1], color=\"#3DBA38\")\nplt.show()\nplt.plot(BDDtest[1,:])\nplt.show()\n","1340ce7c":"# Export the function to csv format","63b79ea8":"#  Import back the function from csv format","832bd988":"# Neural Network \/ model creation with keras","02f03727":"# Creation of databases that will be usefull later in the programme","46ceb331":"# Creation of a main fonction to create all of the signals","8206fa7b":"# Creation of 8 databases of signals with 4 considered as normal signals and 4 as anomaly","d38fc441":" # The notebook is presented as followed: \n \n* Creation of a main fonction to create all of the signals\n* Tuto to export the function to csv format\n* Tuto to import back the function from csv format\n* Librairies import\n* Creation of 8 databases of signals with 4 considered as normal signals and 4 as anomaly\n* Display of one signal of every category\n* Labelisation of the signals\n* Data reshaping for NN compatibility\n* Neural Network \/ model creation with keras\n* Visualisation of this NN architecture and its training + parameter choices\n* Application on an example\n* Application of the trained NN on new signal to see if it classified it into the good category\n* Conlusion\n\nAs i am begining with Kaggle notebooks, any recommandations, questions, comments, limits highlights and upvote will be very welcome!\n\n\n","399238dc":"# Using Neural Networks to classify signals in 8 categories  ","9982581a":"# labelisation of the signals","7da08b8f":"# Application of the trained NN on new signal to see if it classified it into the good category","dc7517ed":"# Data reshaping for NN compatibility","fc92e8e4":"# Librairies import","79308235":"1. The 4 nominal\/ normal signals : ","ee8f5a85":"2. The 4 Anomaly categories","662e4878":"# Conclusion","78f53c4e":"## The purpose of this notebook is to show how to use Neural networks to classify physical - signals, it can be used to detect signal presenting anomalies.","bfd188ec":"# Subject: \n","f17fc272":"# Application on an example","6d4a85e5":"Creation of a fonction to reshape the databases","dc5b8cb3":"# Visualisation of this NN architecture and its training + parameter choices","8c98cce2":"# Display of one signal of every category","35eeef06":"## 8 databases of signals will be created, in 8 categories. A NN will be use to classify any new signal in the good category regarding the training.\nThe databes are declined in 4 supposed nominal signals and 4 supposed anomaly signals, it is to give a clue on how to use this kind of application to detect anomaly detection**","1ae17bb3":"This function is used to show the parameters and architecture of the NN model you create","73afc40f":"# Plot of the function ","6f5b3ec0":"## The NN is able to classify the signal in the good category; of course the accuracy can be optimised but it is not the subject of this notebook. \n## It is possible to change the kind of signal we want to test ( line 6 in the last cell) to test of the algorithm is able to classify any kind of signal in the good category","1fcae957":"## This approach could allow you to classify signals, times series into categories or to use it to detect anormal times series - Anomaly detection","9481f7a8":"the label is coded in a 8 values vector, a 1 is set on the good category and 0 for all other values."}}