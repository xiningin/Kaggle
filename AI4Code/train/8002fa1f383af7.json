{"cell_type":{"723ea74b":"code","13fcc117":"code","be69a21b":"markdown"},"source":{"723ea74b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","13fcc117":"%macro base_01(mes_inicio,mes_fim);\n\t%meses(&mes_inicio,&mes_fim);\n\n\t%do i = &&ordem_&mes_inicio %to &&ordem_&mes_fim;\n\n\t\tproc sql;\n\t\tcreate table libname.blabla&&mes_&i. as select distinct\n\t\t\t a.*\n\t\t\t,b.variavel\n\t\tfrom base_left&&mes_&i. as a \n\t\tleft join base_right.PAP_&&mes_&i. as b\n\t\ton a.chave=b.chave\n\t\t;quit;\n\n\t%end;\n%mend;","be69a21b":"%macro hold_on(base_aguardada,sleep_segundos,chamada_macro);\n     %x:;\n     %if %sysfunc(exist(&base_aguardada.)) %then %do;\n          %&chamada_macro.;\n     %end;\n     %else %do;\n          data _NULL_;\n                slp = sleep(&sleep_segundos.,1);\n          run;\n          %goto x;\n     %end;\n%mend;\n\n%macro SALVA_SQL(base_orig,base_sql);\n\/*     %sql();*\/\n     %if %sysfunc(exist(DBF2762.&base_sql.)) %then %do;\n          PROC DELETE DATA=DBF2762.&base_sql.; RUN;\n     %end;\n     DATA DBF2762.&base_sql.;\n          SET\n                &base_orig.\n          ;\n     RUN;\n%mend SALVA_SQL;\n\n%macro SOMA_DATA(INICIO,SOMA,VAR);\n     %GLOBAL &VAR.;\n     %LET &VAR. = ;\n     %LET &VAR = %EVAL((%SYSFUNC(YEAR( %SYSFUNC(INTNX(month,%SYSFUNC(MDY(%SYSFUNC(MOD(&INICIO.,100)),1,%SYSFUNC(INT(&INICIO.\/100)))),&SOMA,sameday)) )))*100 + %SYSFUNC(MONTH( %SYSFUNC(INTNX(month,%SYSFUNC(MDY(%SYSFUNC(MOD(&INICIO.,100)),1,%SYSFUNC(INT(&INICIO.\/100)))),&SOMA,sameday)) ) );\n%mend SOMA_DATA;\n\n\/*MESES*\/\n%macro meses(mes_inicial, mes_final, ref_inicial=0, nome_mes= mes, nome_ordem= ordem);\n      %local i j k mesref ordena;\n      %global qtd_&nome_mes incrementa;\n      %if &mes_final le 1000\n            %then %let mes_final = %intnx(month, &mes_inicial,&mes_final);\n      %put mes_inicial = &mes_inicial;\n      %put mes_final = &mes_final;\n      %if &mes_inicial le &mes_final %then %let ordena= crescente;\n      %else %let ordena= decrescente;\n      %if &ordena = decrescente %then %let incrementa= -1;\n      %else %do;\n            %let incrementa= 1;\n            %if &ordena ne crescente %then %put ********* Erro Inesperado! Ordenacao crescente foi utilizada! *********;\n      %end;\n      %let k= %eval(&ref_inicial-1);\n      %do i=%sysevalf(%sysfunc(int((&mes_inicial)\/100))) %to %sysevalf(%sysfunc(int(&mes_final\/100))) %by &incrementa;\n            %do j=%sysevalf(6.5-5.5*&incrementa) %to %sysevalf(6.5+5.5*&incrementa) %by &incrementa;\n            %let mesref= %eval(&i*100 + &j);\n                  %if (&incrementa*&mes_inicial le &incrementa*&mesref and &incrementa*&mesref le &incrementa*&mes_final) %then %do;\n                        %let k= %eval(&k + 1);\n                        %global &nome_mes._&k &nome_ordem._&mesref;\n                        %let &nome_mes._&k = &mesref;\n                        %let &nome_ordem._&mesref = &k;\n                  %end;\n            %end;\n      %end;\n      %let qtd_&nome_mes= %eval(&k - &ref_inicial + 1);\n      %put qtd_&nome_mes = &&qtd_&nome_mes;\n      %put incrementa = &incrementa;\n      %do i= &ref_inicial %to &ref_inicial + &&qtd_&nome_mes - 1;\n            %put &nome_ordem._&&&nome_mes._&i = &&&&&nome_ordem._&&&nome_mes._&i;\n      %end;\n      %do i= &ref_inicial %to &ref_inicial + &&qtd_&nome_mes - 1;\n            %put &nome_mes._&i = &&&&&nome_mes._&i;\n      %end;\n%mend meses;\n\n\/*TRANSP*\/\n%macro transp (basein, baseout, var, ini, fim, id= mob, keep=, sort= 0);\n      %local i;\n      \/*Identifica se eh ano-mes. Se for, normaliza*\/\n      %if &ini. ge 100000\n            %then %do;\n                  %meses(&ini., &fim., ref_inicial= 0, nome_mes= tmes, nome_ordem= tordem)\n                  %let mes_ini = &ini.;\n                  %let mes_fim = &fim.;\n                  %let ini = &&tordem_&mes_ini..;\n                  %let fim = &&tordem_&mes_fim..;\n            %end;\n      %else\n            %do;\n                  %let mes_ini = ;\n                  %let mes_fim = ;\n            %end;\n            %put ini = &ini;\n            %put fim = &fim;\n            %put mes_ini = &mes_ini;\n            %put mes_fim = &mes_fim;\n      \/*Se o sort estiver setado, ordena*\/\n      %if &sort. ne 0 and &keep. ne \n            %then %do;\n                  proc sort data=&basein.;\n                        by &keep.;\n                  run;\n            %end;\n      \/*transpose das PDs*\/\n      %let i= 1;\n      data &baseout.\n            \/*se o keep estiver setado, mantem as variaveis do keep e as novas, se nao, joga fora as variaveis transpostas*\/\n            (%if &keep ne %then keep = &keep. &var. &id.;\n             %else drop= i %do %while  (%scan(&var,&i) ne ); %scan(&var.,&i.)_: %let i = %eval(&i+1); %end;\n            );\n            set &basein.\n                  \/*se eh ano-mes, normaliza os nomes das variaveis atraves de rename*\/\n                  %if &mes_ini. ne \n                        %then %do;\n                             (rename=\n                                   (\n                                         %do j=&ini. %to &fim.; \n                                               %let i= 1;\n                                               %do %while  (%scan(&var,&i) ne );\n                                                     %scan(&var.,&i.)_&&tmes_&j = %scan(&var.,&i.)_&j.\n                                                     %let i = %eval(&i+1);\n                                               %end;\n                                         %end;\n                                   )\n                             )\n                        %end;\n            ;\n            %let i= 1;\n            %do %while  (%scan(&var,&i) ne );\n                  array %scan(&var.,&i.)v {%eval(&fim.-&ini.+1)} %scan(&var.,&i.)_&ini.  - %scan(&var.,&i.)_&fim.;\n                  %let i = %eval(&i+1);\n            %end;\n            do i = 1 to &fim.-&ini.+1;\n                  \/*Se eh ano-mes, o id desnormaliza os sufixos, se nao, permanece*\/\n                  %if &mes_ini. ne\n                        %then &id. = symget(compress(\"tmes_\"||put(i-1,8.)))*1;\n                  %else\n                        &id. = i-1+&ini.;\n                  ;\n                  %let i= 1;\n                  %do %while  (%scan(&var,&i) ne );\n                        %scan(&var.,&i.) = %scan(&var.,&i.)v{i};\n                        %let i = %eval(&i+1);\n                  %end;\n                  output;\n            end;  \n      run;\n%mend transp;\n\n\/*DIA UTIL*\/\n%macro dia_util(dataini, datafim, baseout);\nDATA &baseout.;\n      FORMAT DATA DDMMYY10. ANO_UTIL Z4. MES_UTIL Z2.;\n      RETAIN MES_AUX 0 ANO_AUX 0;  \n      DO DATA = &dataini. TO &datafim.;\n            ANO_UTIL = YEAR(DATA);  \n            MES_UTIL = MONTH(DATA);\n            C = INT(ANO_UTIL\/100);\n            N = ANO_UTIL - (19*INT(ANO_UTIL\/19));\n            K = (C - 17)\/25;\n            I = C - C\/4 - INT((C-K)\/3) +(19*N) + 15;\n            I = I - (30*INT(I\/30));\n            I = I - (INT(I\/28)*(1-INT(I\/28))*INT(29\/(I+1))*INT((21-N)\/11));\n            J = ANO_UTIL + INT(ANO_UTIL\/4) + I + 2 -C + INT(C\/4);\n            J = J - (7*INT(J\/7));\n            L = I - J;\n            M = 3 + INT((L+40)\/44);\n            D = L + 28 - (31*INT(M\/4));\n            PASCOA = MDY(M,D,ANO_UTIL);                    \n            CARNAVAL_SEGUNDA = PASCOA - 48;\n            CARNAVAL_TERCA = PASCOA - 47;\n            SEXTA_SANTA = PASCOA - 2;          \n            CORPUS_CHRISTI = PASCOA + 60;\n            CONFRAT_UNIV = MDY(1,1,ANO_UTIL);\n            TIRADENTES = MDY(4,21,ANO_UTIL);\n            TRABALHO = MDY(5,1,ANO_UTIL);\n            JULHO_9 = MDY(7,9,ANO_UTIL);\n            INDEPENDENCIA = MDY(9,7,ANO_UTIL);\n            APARECIDA = MDY(10,12,ANO_UTIL);\n            FINADOS = MDY(11,2,ANO_UTIL);\n            REPUBLICA = MDY(11,15,ANO_UTIL);\n            CONSC_NEGRA = MDY(11,20,ANO_UTIL);\n            NATAL = MDY(12,25,ANO_UTIL);                   \n            IF    WEEKDAY(DATA) IN (7 1) \n                        OR DATA = CARNAVAL_SEGUNDA \n                        OR DATA = CARNAVAL_TERCA \n                        OR DATA = SEXTA_SANTA \n                        OR DATA = CORPUS_CHRISTI \n                        OR DATA = CONFRAT_UNIV\n                        OR DATA = TIRADENTES\n                        OR DATA = TRABALHO\n                        OR DATA = JULHO_9\n                        OR DATA = INDEPENDENCIA\n                        OR DATA = APARECIDA\n                        OR DATA = FINADOS\n                        OR DATA = REPUBLICA\n                        OR DATA = CONSC_NEGRA\n                        OR DATA = NATAL  THEN DO;                \n                  MES_UTIL = MES_AUX;\n                  ANO_UTIL = ANO_AUX;\n            END;\n            ELSE IF DAY(DATA) = 1 OR DAY(DATA) <= DIA_UTIL THEN DIA_UTIL = 1;      \n            ELSE DIA_UTIL + 1;\n            MES_AUX = MES_UTIL;\n            ANO_AUX = ANO_UTIL;          \n            IF DIA_UTIL <> 0 THEN OUTPUT;\n      END;  \n      KEEP DATA ANO_UTIL MES_UTIL DIA_UTIL;\nRUN;\n%mend dia_util;\n\n\/*ITERLIST*\/\n%macro iterlist(item,list) ;  \n  %*** DELETA AS MACRO VARI\u00c1VEIS EXISTENTES COM O NOME &&ITEM&I ;      \n  %GLOBAL N&item.;      \n  %if  %length(&&N&item.) ne 0  %then %do ; \n      %do j = 1 %to &&N&item. ; \n      %SYMDEL &item.&j. ;\n      %end;\n  %end;           \n  %*** Atribui a cada item na lista a uma macro vari\u00e1vel indexada: &&ITEM&I ; \n  %let i = 1; \n  %do %while (%cmpres(%scan(&list., &i.)) ne ); \n      %GLOBAL &item.&i.;\n    %let &item.&i. = %cmpres(%scan(&list., &i.));  \n    %let i = %eval(&i. + 1);  \n  %end; \n  %*** Guarda a contagem do n\u00famero de itens em uma vari\u00e1vel de macro: &N&item.; \n  %let N&item. = %eval(&i. - 1);  \n%mend  iterlist;\n\n\/*FORMAT*\/\n%macro cria_format(borig , nome_formato, nome_start=start, nome_label=label);\n      data &nome_formato (keep = start label fmtname);\n                 set &borig.;\n                 start = &nome_start;\n                 label = &nome_label;\n                 fmtname = \"$&nome_formato.\";\n            run;\n      proc format library= work cntlin= &nome_formato;\n      run;\n       proc delete data = &nome_formato; run;\n%mend cria_format;\n\n\/*Verifica Campos*\/\n%macro verifica_campos(mes_inicio, mes_fim, base);\n      PROC CONTENTS DATA= &base._&mes_inicio\n                    OUT= campos (KEEP = name RENAME=(name = aux_&mes_inicio)); \n      RUN;    \n\n      DATA campos;\n            SET campos;\n           LENGTH completo $32.;\n           completo = aux_&mes_inicio;\n      RUN;\n\n      %meses(&mes_inicio, &mes_fim);\n      %DO i= &&ordem_&mes_inicio + 1 %TO &&ordem_&mes_fim;\n      PROC CONTENTS DATA= &base._&&mes_&i \n                    OUT= aux_&&mes_&i(KEEP = name RENAME=(NAME = aux_&&mes_&i )); \n      RUN;    \n\n      PROC SQL;\n        CREATE TABLE campos AS\n        SELECT\n          a.completo, \n          a.*,\n          b.*\n        FROM campos AS a FULL JOIN aux_&&mes_&i AS b\n      ON (a.completo = b.aux_&&mes_&i);\n      QUIT;\n\n      DATA campos;\n           SET campos;\n          IF completo = '' THEN completo = aux_&&mes_&i;\n      RUN;\n      PROC DELETE DATA = aux_&&mes_&i; RUN;\n   %END;\n%mend;\n\n\/*Macro FTP*\/\n%macro ftp (path_origem, base_origem, path_destino, base_destino, server_destino, user_orig, password_orig, user_dest, password_dest);\n      %if &server_destino eq spubd063 %then %let server_origem = spubd068; %else %let server_origem = spubd063;\n       \/*Origem*\/\n      filename indir ftp  \"&path_origem\" DIR\n            recfm=f host=\"&server_origem\"\n            user=\"&user_orig\" pass=\"&password_orig\" prompt;\n      \/*Destino*\/\n      filename outdir ftp \"&path_destino\" DIR\n            recfm=f host=\"&server_destino\"\n            user=\"&user_dest\" pass=\"&password_dest\" prompt;\n      \/*Transfer\u00eacia*\/\n      data _null_;\n            infile indir(%lowcase(&base_origem).sas7bdat) truncover;\n            input;\n            file outdir(%lowcase(&base_destino).sas7bdat);\n            put _infile_;\n      run;\n%mend;\n\n\n%macro lastday(mes_ini,mes_fim);\n     \/**** Dias \u00dateis - Final do m\u00eas ******\/\n\n     %dia_util(%sysfunc(MDY(%substr(&mes_ini.,5,2),01,%substr(&mes_ini.,1,4))),%sysfunc(MDY(%substr(&mes_fim.,5,2),01,%substr(&mes_fim.,1,4))) ,aux_01);\n\n     proc sort data=aux_01 nodupkey;\n          by ano_util mes_util descending dia_util;\n     run;\n\n     proc sort data=aux_01 nodupkey;\n          by ano_util descending mes_util ;\n     run;\n\n     proc sort data=aux_01 ;\n          by ano_util mes_util ;\n     run;\n\n     data aux_01;\n          set aux_01;\n          lastday = compress(put(ano_util,z4.)!!put(mes_util,z2.)!!put(day(DATA),z2.));\n     run;\n\n     proc sql noprint;\n         select lastday into: lastday separated by \" \"\n         from aux_01\n     ;quit;\n\n     %iterlist(lastday,&lastday.);\n\n\/*   proc delete data = aux_01; run;*\/\n%mend;\n\n\n\n%macro gunzip(path_source, path_destination, data);\nx \"cp &path_source.\/&data..sas7bdat.gz &path_destination.\";\nx \"gunzip &path_destination.\/&data..sas7bdat.gz\";\n%mend;\n%macro gunzip2(path_source, path_destination, data);\nx \"gunzip &path_destination.\/&data..sas7bdat.gz\";\n%mend;\n%macro gzip(path_source, path_destination, data);\nx \"gzip &path_destination.\/&data..sas7bdat\";\n%mend;\n%macro bunzip(path_source, path_destination, data);\nx \"cp &path_source.\/&data..sas7bdat.bz2 &path_destination.\";\nx \"bunzip2 &path_destination.\/&data..sas7bdat.bz2\";\n%mend;\n\n%macro descompacta_tudo(caminho);\n     %let saswork =%sysfunc(pathname(work));\n     %let posi_barra= %index(&caminho.,\/);\n     %if &posi_barra. ne 0 %then %do;\n          %let base = %sysfunc(substr(&caminho.,%eval(&posi_barra. + 1)));\n     %end; %else %do;\n          %let base = &caminho.;\n          %let caminho = &saswork.\/&base.;\n     %end;\n     %do %while (&posi_barra. ne 0);\n          %let posi_barra= %index(&base.,\/);\n          %let base = %sysfunc(substr(&base.,%eval(&posi_barra. + 1)));\n     %end;\n     %let len_base= %sysfunc(length(&base.));\n     %let len_caminho= %sysfunc(length(&caminho.)); \n     %let caminho2 = %sysfunc(substr(&caminho.,1,%eval(&len_caminho. - &len_base.)));\n\n     %let base2 =%lowcase(&base.);\n     %put descompactar -----> &caminho2.&base2..sas7bdat;\n\n     x \"cp &caminho2.&base2..sas7bdat &saswork.\";\n\n     x \"cp &caminho2.&base2..sas7bdat.bz2.bz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.bz.bz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz2.bz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz.bz2 &saswork.\";\n\n     x \"cp &caminho2.&base2..sas7bdat.bz2.bz &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.bz.bz &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz2.bz &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz.bz &saswork.\";\n\n     x \"cp &caminho2.&base2..sas7bdat.bz2.gz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.bz.gz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz2.gz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz.gz2 &saswork.\";\n\n     x \"cp &caminho2.&base2..sas7bdat.bz2.gz &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.bz.gz &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz2.gz &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz.gz &saswork.\";\n\n     x \"cp &caminho2.&base2..sas7bdat.bz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.bz &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz2 &saswork.\";\n     x \"cp &caminho2.&base2..sas7bdat.gz &saswork.\";\n\n     x \"bunzip2 &saswork.\/&base2..sas7bdat.bz2.bz2\";\n     x \"bunzip2 &saswork.\/&base2..sas7bdat.bz.bz2\";\n     x \"bunzip2 &saswork.\/&base2..sas7bdat.gz2.bz2\";\n     x \"bunzip2 &saswork.\/&base2..sas7bdat.gz.bz2\";\n\n     x \"bunzip &saswork.\/&base2..sas7bdat.bz2.bz\";\n     x \"bunzip &saswork.\/&base2..sas7bdat.bz.bz\";\n     x \"bunzip &saswork.\/&base2..sas7bdat.gz2.bz\";\n     x \"bunzip &saswork.\/&base2..sas7bdat.gz.bz\";\n\n     x \"gunzip2 &saswork.\/&base2..sas7bdat.bz2.gz2\";\n     x \"gunzip2 &saswork.\/&base2..sas7bdat.bz.gz2\";\n     x \"gunzip2 &saswork.\/&base2..sas7bdat.gz2.gz2\";\n     x \"gunzip2 &saswork.\/&base2..sas7bdat.gz.gz2\";\n\n     x \"gunzip &saswork.\/&base2..sas7bdat.bz2.gz\";\n     x \"gunzip &saswork.\/&base2..sas7bdat.bz.gz\";\n     x \"gunzip &saswork.\/&base2..sas7bdat.gz2.gz\";\n     x \"gunzip &saswork.\/&base2..sas7bdat.gz.gz\";\n\n     x \"bunzip2 &saswork.\/&base2..sas7bdat.bz2\";\n     x \"bunzip &saswork.\/&base2..sas7bdat.bz\";\n     x \"gunzip2 &saswork.\/&base2..sas7bdat.gz2\";\n     x \"gunzip &saswork.\/&base2..sas7bdat.gz\";\n\n%mend descompacta_tudo;\n\n\/*Formata Produtos*\/\n%macro format_prod (mes_ref);\n     \/*--> Produto:*\/\n     DATA familia;\n          SET depara.prod_%substr(&mes_ref.,3,4) \n                (keep = cod_produto cod_familia nome_familia nome_produto);\n          prod = put(cod_produto,z8.);\n          fami = put(cod_familia,z8.);\n     RUN;\n     PROC SORT DATA=familia;BY prod;RUN;\n     %cria_format(familia , prod, nome_start=prod      ,   nome_label=nome_familia); \n     PROC SORT DATA=familia (keep = fami nome_familia) nodupkey;BY fami;RUN;\n     %cria_format(familia , fami, nome_start=fami      ,   nome_label=nome_familia);\n     PROC DELETE DATA = familia; RUN;\n%mend;\n"}}