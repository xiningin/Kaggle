{"cell_type":{"bd83645e":"code","9e295779":"code","0cdc4489":"code","a391c0b0":"code","34a58b27":"code","56515a75":"code","56c8f73f":"code","685daa23":"code","b6983138":"code","17e93950":"code","03d861df":"code","46732132":"code","bdfaa223":"code","6be41a80":"code","94bb3e0a":"code","7e30cdfe":"code","dda98135":"code","06a600ec":"code","db31b6be":"code","f08d3224":"code","c4ec5129":"code","fc5cb2b7":"code","1cd41e6c":"code","c7065e9e":"code","0d138b65":"code","54abc217":"code","d81bb976":"code","c14fe524":"code","67aa840b":"markdown","740718d9":"markdown","e66fbe12":"markdown","c90f2a91":"markdown","9759c66f":"markdown","c4b774a7":"markdown","840b309d":"markdown","220a4e22":"markdown","debf92fd":"markdown","5ab8188c":"markdown","b3cac2ea":"markdown","44a877ea":"markdown","77dd6146":"markdown","da4cd8c7":"markdown","6f416335":"markdown","1adfa44e":"markdown","5fa79009":"markdown","cab16878":"markdown","f830f852":"markdown","a2dbaf6b":"markdown","1f4b357a":"markdown","fff63d7d":"markdown","75defa79":"markdown","f8f01c81":"markdown","6ade4f8d":"markdown","362bff0b":"markdown","4e66045a":"markdown","814d634f":"markdown"},"source":{"bd83645e":"import numpy as np","9e295779":"##Inicializado arranjos:\n\n#Vetor 1D, dtype deifinido como int16\na = np.array([1,2,3], dtype = 'int16') \nprint('Vetor a: ', a)\n\n#Matrix 2D, sem defini\u00e7\u00e3o de tipo ele por padr\u00e3o opter\u00e1 pelo m\u00ednimo requerido\nb = np.array([[1.0,2.0,3.0,4.0,5.0],[6.0, 7.0, 8.0,9.0,10.0]])\nprint('\\nMatriz b: \\n', b)\n\n#Tensor 3D\nc = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])\nprint('\\nTensor c: \\n', c)","0cdc4489":"#Gerando arranjos\n\n##Preenchido com 0\nprint('Zeros: ', np.zeros(2))\n\n##Preenchido com 1\nprint('Ones: \\n', np.ones([3,3]))\n\n##Preenchido com valor X: obrigat\u00f3rio shape e valor\nprint('Full: \\n', np.full([4,4],42))\n\n##Preenchido com valor X e de forma igual a de outro arranjo\nprint('Full like: ', np.full_like(a,7))\n\n##Vazio: o conte\u00fado inicial \u00e9 aleat\u00f3rios e depende da mem\u00f3ria. Em geral, mais r\u00e1pido que 'zeros'\nprint('Vazio:', np.empty(2))\n\n##Por uma faixa de valores: obrigat\u00f3rio especificar \"in\u00edcio\", \"final\" e \"passo\"\nprint('Faixa:', np.arange(0, 10, 2))\n\n##Por intervalor linearmente esp\u00e7ado: \nprint('Linear:', np.linspace(0, 10, num = 5))\n\n##Repte um ndarray determinada quantidade de vezes\norig = np.array([[1,2,3]])\nrepeat = np.repeat([[0,1,2,3]],3, axis=0)\nprint('Repeti\u00e7\u00e3o: \\n', repeat)\n\n##Arranjo bidimensional com 1 na diagonal e 0 em outros locais\nprint('Eyes: \\n', np.eye(3))\n","a391c0b0":"##Matriz identidade\nprint('Identidade: \\n', np.identity(3))\n\n##MAtriz diagonal\nprint('Diagonal: \\n', np.diag([7,7,7]))\n\n##N\u00fameros alet\u00f3rios da distribui\u00e7\u00e3o uniforme [0,1)\nprint('Random [0,1): \\n', np.random.rand(4,2))\n\n##Fun\u00e7\u00e3o similar a random.rand, cuja diferen\u00e3 \u00e9 o argumento de entrada\nprint('Random Sample: \\n', np.random.random_sample([4,2]))\n\n##N\u00fameros inteiros aleat\u00f3rios do mais baixo (inclusivo) ao mais alto (exclusivo)\n##Recebe (low, high=None, size=None, dtype)\n\nprint('Random inteiro: \\n', np.random.randint(-10,10, size=(3,3)))\n","34a58b27":"##Verificando os atributos dos arranjos a, b e c\n\n#Extraindo as dimens\u00f5es\ndimension_a = a.ndim\ndimension_b = b.ndim\ndimension_c = c.ndim\n\n#Extraindo a forma\nshape_a = a.shape\nshape_b = b.shape\nshape_c = c.shape\n\n#Extraindo o tipo\ntype_a = a.dtype\ntype_b = b.dtype\ntype_c = c.dtype\n\n#Extraindo o tipo\nsize_a = a.size\nsize_b = b.size\nsize_c = c.size\n\nprint('Vetor  a -> Dimens\u00e3o: {} | Shape: {} | Tipo: {} | Tamanho: {}'.format(dimension_a,shape_a, type_a, size_a))\nprint('Matriz b -> Dimens\u00e3o: {} | Shape: {} | Tipo: {} | Tamanho: {}'.format(dimension_b,shape_b, type_b, size_b))\nprint('Tensor c -> Dimens\u00e3o: {} | Shape: {} | Tipo: {} | Tamanho: {}'.format(dimension_c,shape_c, type_c, size_c))","56515a75":"#Acessando os atributos para o arranjo b\n\nprint('Atributos da Matriz b: \\nTransposto:\\n {}'.format(b.T, b.nbytes))\nprint('\\nNbytes: {} \\nData: {}'.format(b.nbytes, b.data))\nprint('\\nFlags: \\n{} \\nFlat: {}'.format(b.flags, b.flat))\nprint('\\nImag: \\n{} \\n \\nReal: \\n{}'.format(b.imag, b.real))\nprint('\\nItemsize: {} \\nStrides: {}'.format(b.itemsize, b.strides))\nprint('Ctypes: {} \\nBase: {}'.format(b.ctypes, b.base))\n","56c8f73f":"#Exemplos de acesso\n\nex1 = np.array([10,11,22,23])\nex2 = np.array([[0,1],[2,3]])\n\n##Indexa\u00e7\u00e3o t\u00edpica\nprint('Elementos 0 e 3 do vetor: {}, {}\\n'.format(ex1[0], ex1[3]))\nprint('1\u00aa linha, 2\u00aa coluna: {} | 2\u00aa, 2\u00aa coluna: {}\\n'.format(ex2[0][1], ex2[1][1]))\n\n#Indexia\u00e7\u00e3o multidimensional\nprint('1\u00aa linha, 2\u00aa coluna: {} | 2\u00aa, 2\u00aa coluna: {}'.format(ex2[0,1], ex2[1,1]))","685daa23":"#Exemplos de slicing e striding\nex3 = np.array([10,11,22,23,33,34])\nex4 = np.array([[0,1,2,3],[4,5,6,7],[8,9,10,11]])\nex5 = np.array([[20,21,22,23,24],[30,31,32,33,34],[40,41,42,43,44]])\n\n##Slicing\nprint('Do 2\u00ba ao 4\u00ba elemento:',ex3[1:4])\nprint('\\nDa 1\u00aa \u00e0 2\u00aa linha, da 1\u00ba \u00e0 3\u00ba coluna:\\n',ex4[0:2,0:3])\nprint('\\nPrimeira linha:', ex5[0,:])\nprint('\\nPrimeira coluna', ex5[:,0])\n\n#Stride\nprint('\\nDo 1\u00ba ao 4\u00ba, a cada 2:',ex3[0:5:2])\n\n","b6983138":"#Indexando por arranjo\nex6 = np.arange(1,20,2)\nprint('Exemplo:', ex6)\n\n##Passando um ndarray como index\nprint('1) Indexando por arranjo:', ex6[np.array([5,4,1,7,7])])\n\n##Com valores negativos\nprint('2) Indexando por arranjo:', ex6[np.array([-1,9,-2,8,-3,7])])\n\n##Passando arranho multidimensional como index\nprint('3) Indexando por arranjo:\\n', ex6[np.array([[0,0],[1,1],[2,2]])])\n","17e93950":"#Indexando por opera\u00e7\u00e3o\n\nex7 = np.array([0,1,0,3,0,5,0,7,0,9])\nex8 = np.arange(30).reshape(2,3,5)\n\n##Opera\u00e7\u00f5es booleanas\nprint('Elementos maiores que 7:  ', ex7[ex7 > 1])\nprint('Elementos menores que 0:  ', ex7[ex7 < 0])\nprint('Elementos diferentes de 0:', ex7[ex7 != 0])\nprint('Elementos iguais a 0:     ', ex7[ex7 == 0])\n\n##Arranjo boleano multidimensional de dimens\u00f5es menores que o original\n##Utilizando uma ndarray 2D (2,3) em um ndarray 3D (2,3,5) obtemos um array 2D (4,5)\nb = np.array([[True, True, False], [False, True, True]])\nprint('Combinando arranjos multidimensionais:\\n',ex8[b])","03d861df":"#Editando elementos\n\nex9 = np.arange(10)\nex10 = np.arange(21).reshape(3,7)\n\n##Um elemento\nex9[0] = 99\n\n##Slice\nex9[3:7] = 100\n\n##ndarray\nex9[np.array([8,9])] = -1\n\n\nprint('Novos elementos:', ex9)\n\n#Todos os elementos de uma linha\nex10[0,:] = 0\n#Todos os elementos de uma coluna\nex10[:,6] = 100\n\n\nprint('\\n2D Array: \\n',ex10)\n","46732132":"#Adicionando itens ao arranjo\nex11 = np.arange(10)\n\n##Append retorna uma c\u00f3pia do ndarray com os elementos inclu\u00eddos ao final\nprint('Acrescido: ', np.append(ex11,[100,200]))\n\n##Inser retorna uma c\u00f3pia do ndarray com os elementos acrescentados ap\u00f3s o index informado\nprint('Inserido: ', np.insert(ex11,3, [100,200], axis = 0))","bdfaa223":"#Ordenando um ndarray\nex12 = np.array([9, 5, 1, 2, 3, 6, 8, 7, 4])\n\n##Ordena\u00e7\u00e3o simples\nprint('Ordem simples: ', np.sort(ex11))","6be41a80":"#Copiar, Concatenar, Empilhar e Dividir ndarrays\nex12 = np.arange(10)\nex13 = np.arange(11,21,1)\n\n##Copy cria uma c\u00f3pia dos elementos em um novo endere\u00e7o\ncopia = np.copy(ex12)\nprint(\"C\u00f3pia de ex12: \", copia)\n\n##Concatenando dois arranjos ao longo de determinado eixo\nprint('\\nConcatenando ex12 e ex13: ', np.concatenate((ex12, ex13), axis=0))\n\n##Empilhando ndarrays em sequ\u00eancia, horizontalmente\nprint('\\nEmpilhando horizontalmente', np.hstack((ex12, ex13)))\n\n##Empilhando ndarrays em sequ\u00eancia, verticalmente\nprint('\\nEmpilhando verticalmente: \\n', np.vstack((ex12, ex13)))\n\n##Dividindo ndarrays horizontalmente\nprint('\\nDividindo horizontalmente: \\n', np.hsplit(ex12, 2))\n\n##Dividindo ndarrays verticalmente\nprint('\\nDividindo verticalmente: \\n', np.vsplit(ex12.reshape(2,5), 2))\n","94bb3e0a":"#Alterando o formato (shape)\n##O novo formato deve ser compat\u00edivel com o original\nex14 = np.arange(10)\n\nprint('Antes: ', ex14)\nprint('\\nDepois (5x2):\\n', ex14.reshape(5,2))\nprint('\\nDepois (2x5):\\n', ex14.reshape(2,5))\n\n##O m\u00e9todo flatten retorna uma c\u00f3pia do arranjo em uma s\u00f3 dimens\u00e3o\nprint('\\nAchatado:\\n', ex14.reshape(2,5).flatten())","7e30cdfe":"#Removendo elementos de um ndarray\nex15 = np.arange(10)\n\n##S\u00e3o passados o arranjo e o index dos elementos, recebendo como retorno um novo array\nprint('Removendo elementos: ', np.delete(ex15, [2,3,4,5], axis = 0))\n\n","dda98135":"#Criando visualiza\u00e7\u00e3o com par\u00e2mtros distintos\nprint(ex12.view(dtype=np.short, type=np.matrix))","06a600ec":"##https:\/\/docs.scipy.org\/doc\/numpy\/reference\/routines.math.html\n\na = np.array([1,2,3,4])\n\n#Exemplos das opera\u00e7\u00f5es b\u00e1sicas:\n\nprint(a+2)\nprint(a-2)\nprint(a*2)\nprint(a\/2)\nprint(a**2)\nprint(a%2)\n\n#Exemplos de fun\u00e7\u00f5es matem\u00e1ticas:\n\nprint('\\nExponencial:',np.exp(a))\nprint('Logar\u00edtmo  :',np.log(a))\nprint('Raiz       :',np.sqrt(a))\nprint('Absoluto   :',np.absolute(a))","db31b6be":"#\u00c9 poss\u00edvel realizar opera\u00e7\u00e3o entre arranjos\n\nb = np.array([1,2,3,4])\na - b","f08d3224":"#O Numpy possui uma s\u00e9rie de fun\u00e7\u00f5es, que se aplicam a elemento a elemento (element-wise) do arranjo\n##Exemplos:\nc = ([-1,0.5,3.1415926535])\n\n#Trigonom\u00e9tricas\nprint('Seno   :',np.sin(c))\nprint('Cosseno:', np.cos(c))\n\n#Arredondamento\nprint('Arredondar:',np.around(c))\nprint('Para Baixo:',np.floor(c))\nprint('Para Cima :',np.ceil(c))","c4ec5129":"#Possui tamb\u00e9m fun\u00e7\u00f5es que aplic\u00e1veis a todos os elementos do arranjo, em geral ao longo de um determinado eixo\n\nprint('Soma   :',np.sum(c, axis = 0))\nprint('Produto:',np.prod(c))","fc5cb2b7":"##As opera\u00e7\u00f5es l\u00f3gicas s\u00e3o aplicadas elemento a elemento (element-wise)\n\na = np.array([1,2,3,4])\nb = np.array([3,2,1,0])\n\n#Opera\u00e7\u00f5es b\u00e1sicas: \nprint(a == 2)\nprint(a != 1)\nprint(a > 2)\nprint(a < 3)\n\n#O mesmo se aplica entre arranjos\n\nprint(a == b)\nprint(a > b)\n\n#Isso permite realiar opera\u00e7\u00f5es \u00fateis com uma s\u00e9ria de elementos, como por exemplo:\n\na[a < 3] = -1\nprint(a)","1cd41e6c":"##Al\u00e9m disso, o NumPy conta com uma s\u00e9rie de fun\u00e7\u00f5es l\u00f3gicas\n\nc = np.array([True, True, False, False])\nd = np.array([False, False, True, True])\n\n#Teste de valores\nprint('Todos positivos:', np.all(c))\nprint('Algum positivos:', np.any(c))\n\n#Teste de conte\u00fado\nprint('\u00c9 NaN:', np.isnan(c))\n\n#Teste de tipo\nprint('\u00c9 real:', np.isreal(c))\n\n#Operadores l\u00f3gicos:\nprint(\"AND: \",np.logical_and(c,d))\nprint(\"OR : \",np.logical_or(c,d))\nprint(\"NOT: \",np.logical_not(c,d))\nprint(\"XOR: \",np.logical_xor(c,d))\nprint(\"Equal: \",np.equal(c,d))","c7065e9e":"## Reference docs (https:\/\/docs.scipy.org\/doc\/numpy\/reference\/routines.linalg.html)\n#O NumPy possui um subm\u00f3dulo para a realiza\u00e7\u00e3o de opera\u00e7\u00f5es de \u00c1lgebra Linear (linalg)\n\n# Determinante\n# Tra\u00e7o\n# Norma Matricial\n# Maarix Inversa\n# Etc...\n\n#Examplos:\n\na = np.ones((2,3))\nprint(a)\nb = np.full((3,2), 2)\nprint(b)\nc = np.identity(3)\nprint(c)","0d138b65":"#Multiplica\u00e7\u00e3o de Matrizes\nprint(a@b) #tamb\u00e9m poss\u00edvel utilizar a fun\u00e7\u00e3o np.matmul(a,b)\n\n#Fun\u00e7\u00f5es: \nprint('Tra\u00e7o de a       :', np.trace(a))\nprint('Determinante de c:', np.linalg.det(c))\n\n\n","54abc217":"##https:\/\/numpy.org\/doc\/stable\/reference\/routines.statistics.html\n#O NumPy conta com uma s\u00e9rie de fun\u00e7\u00f5es estat\u00edsticas quanto os elementos do arranjo\n\na = np.array([[1,2,3],[4,5,6]])\nb = np.array([[3,4,5],[6,7,8]])","d81bb976":"print('M\u00e1ximo:',np.max(a))\nprint('M\u00ednimo:',np.min(a))\nprint('Percentil:',np.percentile(a,1))\nprint('Quantil:',np.quantile(a,1))\n\nprint('M\u00e1ximo entre 2 arrays:\\n', np.maximum(a,b))\nprint('M\u00ednimo entre 2 arrays:\\n', np.minimum(a,b))","c14fe524":"print('Mediana:',np.median(a))\nprint('Desvio Padr\u00e3o:',np.std(a))\nprint('Vari\u00c2ncia:',np.var(a))\nprint('M\u00e9dia  ponderada:',np.average(a))\nprint('M\u00e9dia  aritim\u00e9tica:',np.mean(a))","67aa840b":"**-> Slicing:**\n\n* \u00c9 poss\u00edvel utilizar *slicing* e *striding* nos arranjos\n\n* Funciona do mesmo modo que em listas ou tuplas, exceto que podem ser aplicados \u00e0 diversas dimens\u00f5es\n\n* Utilizamos colchetes e define-se o in\u00edcio (inclusivo), o fim (exclusivo) e o passo:\n        . [in\u00edcio:fim:passo]\n        \n* Por meio dessas t\u00e9cnicas, \u00e9 poss\u00edvel escolher determinadas linhas ou colunas do arranho:\n        . Linha espec\u00edfica:  [i,:]\n        . Coluna espec\u00edfica: [:,j]\n* Essa t\u00e9cnica n\u00e3o cria uma c\u00f3pia do arranjo, mas t\u00e3o somente produz uma nova vis\u00e3o dos dados.","740718d9":"**-> Estat\u00edstica**","e66fbe12":"**-> Inicializando um Arranjo:**\n* O arranjo pode ser inicializado atrav\u00e9s do m\u00e9todo *np.array()*. Par\u00e2metros:\n        . Object (obrigat\u00f3rio)\n        . dtype\n        . copy\n        . order\n        . subok\n        . ndmin","c90f2a91":"![](https:\/\/numpy.org\/devdocs\/_static\/numpylogo.svg)\n______","9759c66f":"**-> Editando elementos**\n* Por meio do acesso por index, \u00e9 poss\u00edvel atribuir valores a determinado \u00edndice do arranjo\n* O index pode ser acessado usando todas as regras de indexa\u00e7\u00e3o supramencionadas\n* O valor atribu\u00eddo deve ser consistente:\n        . Mesmo formato ou 'broadcastable'\n","c4b774a7":"**-> Adicionando, removendo e ordenando elementos**\n* NumPy conta com uma s\u00e9rie de fun\u00e7\u00f5es para adicionar, remover e ordenar os arranjos:\n","840b309d":"**->Arranjos pr\u00e9-definidos**\n* O NumPy possui diversas fun\u00e7\u00f5es para cria\u00e7\u00e3o de arranjos pr\u00e9-definidos:\n            . np.zeros()\n            . np.empty()\n            . np.ones()\n            . np.empty()\n            . np.arange()\n            . np.linespace()\n            . np.full()\n            . np.full_like()\n            . np.identity()\n            . np.random.rand()\n            \n* Em geral, passa-se obrigat\u00f3riamente a para a fun\u00e7\u00e3o a forma (*shape*)","220a4e22":"**-> Opera\u00e7\u00f5es B\u00e1sicas**","debf92fd":"_________________________\n","5ab8188c":"**-> Indexando por arranjo**\n* Os arranjos podem ser indexados n\u00e3o s\u00f3 por n\u00fameros inteiros, mas tamb\u00e9m por outros arranjos\n* No entanto, estes ndarrays devem ser do tipo inteiro\n        . x[np.array([1,2,3])]\n* Nesse caso, o retorno ser\u00e1 uma c\u00f3pia dos dados originais (diferentemente do caso de slices)\n* A c\u00f3pia retorna ter\u00e1 a mesma forma de o arranjo de \u00edndice\n* No caso do arranjos multidimensionais, \u00e9 poss\u00edvel utilizar diversos arranjos:\n        .y[np.array([1,2,3]),np.array([4,5,6])]","b3cac2ea":"**-> Indexando por opera\u00e7\u00e3o**\n* \u00c9 poss\u00edvel fazer a indexa\u00e7\u00e3o por meio de opera\u00e7\u00f5es booleanas\n* Nesse caso, passa-se um arranjo booleano como index, que dever\u00e1 ter a mesma forma que as dimens\u00f5es inicais a serem indexadas\n* O resultado ser\u00e1 arranho contedo todos os elementos que satisfazem a condi\u00e7\u00e3o\n","44a877ea":"**-> Acessando elementos (indexing):**\n* o NumPy conta com muitas op\u00e7\u00f5es de indexa\u00e7\u00e3o\n\n* O acesso, de forma simples, \u00e9 feito por meio de colchetes\n        .[linhas, colunas]\n\n* ndarrays permitem indexa\u00e7\u00e3o multidimensional para arranjos multidimensionais\n        .x[0][2] = [0,2]","77dd6146":"* **Adcionar**:\n            . np.append()\n            . np.insert()","da4cd8c7":"# 1. **O que \u00e9 NumPy?**\n\n- NumPy (Numerical Python) \u00e9 uma biblioteca para a linguagem Python que objetiva trabalhar com arranjos multidimensionais (multidimensional array objects).\n\n- A base da biblioteca \u00e9 o arranjo n-dimensional (ndarray object) de tipo homog\u00eaneo.\n__________________________\n**->Arranjo n-dimensional**\n\n*- Caracter\u00edsticas:*\n    - Tipo fixo e homog\u00eaneo\n            . Int32 por padr\u00e3o\n            . Requerem o mesmo tamanho, exceto no caso de vetores de objetos\n    - Tamanho fixo\n            . Possuem tamanho fixo\n            . A mudan\u00e7a de tamanho gera a cria\u00e7\u00e3o de um novo e exclus\u00e3o do original\n    - Espa\u00e7o cont\u00edguo de mem\u00f3ria\n            . As listas do Python cont\u00eam ponteiros para a informa\u00e7\u00e3o, espalhada na mem\u00f3ria.\n            . O vetor Numpy, por outro lado, se armazena a informa\u00e7\u00e3o em um espa\u00e7o cont\u00edguo da mem\u00f3ria.\n            . Isso permite a utiliza\u00e7\u00e3o efetiva do cache\n            . Utilizam tamb\u00e9m menos mem\u00f3ria que as listas padr\u00e3o, agilizando a leitura e checagem\n\n*- Aplica\u00e7\u00f5es:*\n    - Oferece uma gama maior de opera\u00e7\u00f5es que as listas\n    - Por conta da sua velocidade e versatilidade, \u00e9 utilizado em diversos campos:  \n            . Ci\u00eancia de Dados\n            . Machine Learning\n            . Matem\u00e1tica\n            . Computa\u00e7\u00e3o cient\u00edfica\n________________","6f416335":"**-> Atributos de um arranjo:**\n\n* Dimens\u00f5es (*dimensions*):\n        . Em NumPy, chamadas de eixos (*axes*)\n        . Pode ser acessado com:\n            - np.ndarray.ndim\n        \n* Formato (*shape*):\n        . Uma tupla de inteiros n\u00e3o negativos\n        . Identificam o tamanho de cada dimens\u00e3o\n        . Pode ser acessado com:\n            - np.ndarray.shape\n\n* Tipo (*dtype*):\n        . Tipo de dados os elementos\n        . Pode ser acessado com:\n            - np.ndarray.dtype\n\n* Tamanho (*size*):\n        . N\u00famero de elementos no vetor\n        . Pode ser acesso com:\n            - np.ndarray.size****\n\n","1adfa44e":"* **Copiar, Concatenar, Empilhar e Dividir**:\n            . np.copy()\n            . np.concatenate()\n            . np.vstack()\n            . np.hstack()\n            . np.split()","5fa79009":"* Al\u00e9m dos tr\u00eas principais, a classe *ndarray* possui ainda os seguintes atributos:\n        . T\n        . data\n        . flags\n        . flat\n        . imag\n        . real\n        . itemsize\n        . nbytes\n        . strides\n        . ctypes\n        . base","cab16878":"**-> Algebra Linear**","f830f852":"**-> Opera\u00e7\u00f5es L\u00f3gicas**","a2dbaf6b":"* O arranjo multidimensional (*ndarray*) \u00e9 a estrutura central da biblioteca NumPy\n* O classe ndarray \u00e9 usada pelo NumPy para representar tanto:\n        . Vetores (1D array)\n        . Matrizes (2D array)\n        . Tensores (3D ou mais)\n        \n* \u00c9 uma grade de elementos do mesmo tipo (array dtype) que contem informa\u00e7\u00f5es sobre:\n        . Elementos\n        . Como localizar um elemento\n        . Como interpretar um elemento\n\n* O arranjo multidimensional pode ser indexado por:\n        . Inteiros\n        . Booleanos\n        . Tupla de inteiros n\u00e3o negativos\n        . Outro vetor\n \n* O arranjo multidimensional possui:\n        . Rank: n\u00famero de dimens\u00f5es do arranjo\n        . Sahpe: uma tupla de inteiros com o tamanho do arranjo ao longo de cada dimens\u00e3o","1f4b357a":"# *NumPy*: Uma Introdu\u00e7\u00e3o\n\n- O objetivo deste trabalho \u00e9 realizar resumo sobre a biblioteca NumPy para estudo e consulta futura\n- Contribui\u00e7\u00f5es e cr\u00edticas s\u00e3o bem vindas!\n- Fontes:\n            1. https:\/\/numpy.org\/devdocs\/user\/whatisnumpy.html\n            2. http:\/\/www.opl.ufc.br\/pt\/post\/numpy\/            \n            3. https:\/\/en.wikipedia.org\/wiki\/NumPy\n            4. https:\/\/pt.wikipedia.org\/wiki\/Arranjo_(computa%C3%A7%C3%A3o)\n            5. https:\/\/www.youtube.com\/watch?v=r-uOLxNrNk8\n            6. https:\/\/www.youtube.com\/watch?v=QUT1VHiLmmI\n____________","fff63d7d":"* Reorganizando o Arranjo\n        . np.reshape()\n        . np.flatten()","75defa79":"____________\n# 2. Cria\u00e7\u00e3o e Atribudos do Arranjo (*ndarray*)\n\n- O primeiro passo para utilizar a biblioteca \u00e9 import\u00e1-la \n- Assim, tornaremos suas fun\u00e7\u00f5es acess\u00edveis\n- Por conven\u00e7\u00e3o utiliza-se a abrevia\u00e7\u00e3o 'np'\n","f8f01c81":"* Um conceito importante do NumPy \u00e9 o de visualiza\u00e7\u00e3o\n* Como j\u00e1 visto em outras ocasi\u00f5es, com frequ\u00eancia m\u00e9todos retornam uma visualiza\u00e7\u00e3o e n\u00e3o uma c\u00f3pia, mas sim uma nova vis\u00e3o do ndarray\n* Isso permite ganhar em velocidade e economizar mem\u00f3ria\n* O classe ndarray possui um m\u00e9todo para visualiza\u00e7\u00e3o\n        . ndarray.view()","6ade4f8d":"-----------------\n# 4. Opera\u00e7\u00f5es e Estat\u00edsticas\n\n* O NumPY permite a realiza\u00e7\u00e3o de uma s\u00e9rie de opera\u00e7\u00f5es matem\u00e1ticas com os arranjos\n* \u00c9 poss\u00edvel realizar opera\u00e7\u00f5es elemento a elemento (element-wise)\n* Por meio do \"broadcasting\", arranjos de menor tamanho s\u00e3o \"transmitidos\" ao longo do arranjo de maior tamanho, ,de forma que tenham formas compat\u00edveis.\n* O broadicasting permite a vetoriza\u00e7\u00e3o das opera\u00e7\u00f5es, diminuindo as restri\u00e7\u00f5es ","362bff0b":"* **Ordenar**:\n            . np.sort()\n            . np.argsord()\n            . np.lexsort()\n            . np.searchsorted()\n            . np.partition()","4e66045a":"-----------------\n# 3. Acessando, adicionado, removendo e organizando elementos de um arranjo\n\n\n","814d634f":"* **Remover**:\n            . np.delete()"}}