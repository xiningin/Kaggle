{"cell_type":{"eb69ae0d":"code","69f665b1":"code","18a0ef17":"code","898e59d2":"code","045e4282":"code","b71179f0":"code","27edfebc":"code","4ed573e9":"code","8b9504ed":"code","7b921ad9":"code","0979b976":"code","05c169dd":"code","75b972ab":"code","efd54c35":"code","3512daf5":"code","022a49df":"code","4bf3406a":"code","0392aaaf":"code","442b0126":"code","84c82a24":"code","3b1b538b":"code","1143a87d":"code","501ed974":"code","e4601810":"code","e4b88711":"code","06cf759d":"code","ba5aad10":"code","1cdbf3cf":"code","6f51e0f0":"code","acae3de0":"code","a9e0acf9":"code","bfe1b6b1":"code","6d267e45":"code","cddf45d7":"code","47ddbc83":"code","c0701147":"code","92e64871":"code","06be9c44":"code","884bc90e":"code","8f043c38":"code","5941e074":"code","c7b17d61":"code","cff68bbb":"code","e4bf3c18":"code","8f4bc742":"code","56100371":"code","963b91e9":"code","6b4afeee":"code","1fb4015b":"code","3ec90ffd":"code","48f4ddc0":"code","3825fe00":"code","5feaa824":"code","64654905":"code","ef91e226":"code","2964e228":"code","f363d87c":"code","47ff3d13":"code","8383fc53":"code","e46cba3e":"code","97d342d0":"code","920cb0db":"code","10a293af":"code","37b8eb17":"code","a732f025":"code","4e53c4b3":"code","d0cbefd4":"code","ceaa3c3b":"code","ae1d669b":"code","77d5fa28":"code","d0550989":"code","f67c5ad6":"code","33837d47":"code","62efd778":"code","79908784":"code","a5131e24":"code","47ea06fc":"code","85e86573":"code","4e29569d":"code","7e061264":"code","b645ef54":"code","37048ad8":"code","ba68ce0e":"code","e91d0100":"code","ed38f7f1":"code","4090ab1b":"code","ade8f484":"code","302e7ff2":"code","b29a55c9":"code","95dd5c6c":"code","9f0bdf8f":"code","f8a77c2e":"code","d0752cb6":"code","9ea6b9ca":"code","956af2e6":"code","17b9f951":"code","781bcded":"code","af1138f4":"code","ba853a49":"code","01b76bc3":"code","c8d024d9":"code","45a71c08":"code","e01d6ac4":"code","ba8a5d19":"code","781c7ee5":"code","1e6aba1b":"code","a9f761b5":"code","cba245dd":"code","878a3557":"code","6b0e88d5":"code","9b40c88d":"code","7c572d08":"code","b3503e74":"code","afcb3206":"code","e0104210":"code","d906df16":"code","1be2bf19":"code","e90a3b4a":"code","a920948a":"code","b8959c06":"code","141c2bb0":"code","afa26c0c":"code","0bfdf0b2":"code","d3730f41":"code","4e137172":"code","28bd16ec":"code","40f609d2":"code","1a99dc91":"code","1158a898":"markdown","6d9a2082":"markdown","9b976ab7":"markdown","13b92042":"markdown","b000c56b":"markdown","084b6d7c":"markdown","519b91cd":"markdown","8eb6e082":"markdown","ea46df05":"markdown","194470de":"markdown","08462cb5":"markdown","0474d4fe":"markdown","8f4cdcd9":"markdown","a721ce2d":"markdown","7db088d4":"markdown","0ca965c7":"markdown","101424da":"markdown","cc113622":"markdown","5b111f13":"markdown","c9f65253":"markdown","22e2928a":"markdown","ed723379":"markdown","89276b38":"markdown","a31ec863":"markdown","c08923fa":"markdown","bb28d66b":"markdown","64b42dce":"markdown","11aaa643":"markdown","aaee914f":"markdown","978c3f39":"markdown","9f522944":"markdown","78efed73":"markdown","c970eec8":"markdown","8ede4ddd":"markdown","e26fff25":"markdown","931fd43e":"markdown","80717734":"markdown","60745777":"markdown","cad96fe7":"markdown","98c54335":"markdown","e9390944":"markdown","8297881a":"markdown","40b0f005":"markdown","e6bde014":"markdown","4dab3a01":"markdown","22fdc9d1":"markdown","b1e0c904":"markdown","3a3eb820":"markdown","0112e66d":"markdown","db063bdf":"markdown","ff4dcbec":"markdown","2b62d81f":"markdown","d7ffff2f":"markdown","76f2b734":"markdown","69602597":"markdown","a04bbc60":"markdown","94acdf2f":"markdown","ee9f8f44":"markdown","5fad8a0a":"markdown","5402763d":"markdown","fe994d92":"markdown","5516d26c":"markdown","21737c17":"markdown","e5fa5088":"markdown","b820d0f2":"markdown","2e164a5b":"markdown","16b207bb":"markdown","b5e37bdc":"markdown","c92ed0e1":"markdown","0386820f":"markdown","dd0c8593":"markdown","9b21bc7d":"markdown","770feb5c":"markdown","362ed31f":"markdown","91d2ec55":"markdown","b154894d":"markdown","23549722":"markdown","e0746aa9":"markdown","970b0e5c":"markdown","c84e1c03":"markdown","4203ecac":"markdown"},"source":{"eb69ae0d":"#libraries\nimport numpy as np \nimport pandas as pd \nimport os\nimport seaborn as sns \nimport matplotlib.pyplot as plt\n%matplotlib inline\nplt.style.use('ggplot')\nimport lightgbm as lgb\nimport xgboost as xgb\nimport time\nimport datetime\n\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import StratifiedKFold, KFold, TimeSeriesSplit\nfrom sklearn.metrics import mean_squared_error, roc_auc_score\nfrom sklearn.linear_model import LogisticRegression, LogisticRegressionCV\nimport gc\nfrom catboost import CatBoostClassifier\nfrom tqdm import tqdm_notebook\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport logging\n\nlogging.basicConfig(filename='log.txt',level=logging.DEBUG, format='%(asctime)s %(message)s')\n\npd.set_option('max_colwidth', 500)\npd.set_option('max_columns', 500)\npd.set_option('max_rows', 100)\nimport os\nprint(os.listdir(\"..\/input\/\"))\n","69f665b1":"#https:\/\/www.kaggle.com\/theoviel\/load-the-totality-of-the-data\ndtypes = {\n        'MachineIdentifier':                                    'category',\n        'ProductName':                                          'category',\n        'EngineVersion':                                        'category',\n        'AppVersion':                                           'category',\n        'AvSigVersion':                                         'category',\n        'IsBeta':                                               'int8',\n        'RtpStateBitfield':                                     'float16',\n        'IsSxsPassiveMode':                                     'int8',\n        'DefaultBrowsersIdentifier':                            'float16',\n        'AVProductStatesIdentifier':                            'float32',\n        'AVProductsInstalled':                                  'float16',\n        'AVProductsEnabled':                                    'float16',\n        'HasTpm':                                               'int8',\n        'CountryIdentifier':                                    'int16',\n        'CityIdentifier':                                       'float32',\n        'OrganizationIdentifier':                               'float16',\n        'GeoNameIdentifier':                                    'float16',\n        'LocaleEnglishNameIdentifier':                          'int8',\n        'Platform':                                             'category',\n        'Processor':                                            'category',\n        'OsVer':                                                'category',\n        'OsBuild':                                              'int16',\n        'OsSuite':                                              'int16',\n        'OsPlatformSubRelease':                                 'category',\n        'OsBuildLab':                                           'category',\n        'SkuEdition':                                           'category',\n        'IsProtected':                                          'float16',\n        'AutoSampleOptIn':                                      'int8',\n        'PuaMode':                                              'category',\n        'SMode':                                                'float16',\n        'IeVerIdentifier':                                      'float16',\n        'SmartScreen':                                          'category',\n        'Firewall':                                             'float16',\n        'UacLuaenable':                                         'float32',\n        'Census_MDC2FormFactor':                                'category',\n        'Census_DeviceFamily':                                  'category',\n        'Census_OEMNameIdentifier':                             'float16',\n        'Census_OEMModelIdentifier':                            'float32',\n        'Census_ProcessorCoreCount':                            'float16',\n        'Census_ProcessorManufacturerIdentifier':               'float16',\n        'Census_ProcessorModelIdentifier':                      'float16',\n        'Census_ProcessorClass':                                'category',\n        'Census_PrimaryDiskTotalCapacity':                      'float32',\n        'Census_PrimaryDiskTypeName':                           'category',\n        'Census_SystemVolumeTotalCapacity':                     'float32',\n        'Census_HasOpticalDiskDrive':                           'int8',\n        'Census_TotalPhysicalRAM':                              'float32',\n        'Census_ChassisTypeName':                               'category',\n        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',\n        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',\n        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',\n        'Census_PowerPlatformRoleName':                         'category',\n        'Census_InternalBatteryType':                           'category',\n        'Census_InternalBatteryNumberOfCharges':                'float32',\n        'Census_OSVersion':                                     'category',\n        'Census_OSArchitecture':                                'category',\n        'Census_OSBranch':                                      'category',\n        'Census_OSBuildNumber':                                 'int16',\n        'Census_OSBuildRevision':                               'int32',\n        'Census_OSEdition':                                     'category',\n        'Census_OSSkuName':                                     'category',\n        'Census_OSInstallTypeName':                             'category',\n        'Census_OSInstallLanguageIdentifier':                   'float16',\n        'Census_OSUILocaleIdentifier':                          'int16',\n        'Census_OSWUAutoUpdateOptionsName':                     'category',\n        'Census_IsPortableOperatingSystem':                     'int8',\n        'Census_GenuineStateName':                              'category',\n        'Census_ActivationChannel':                             'category',\n        'Census_IsFlightingInternal':                           'float16',\n        'Census_IsFlightsDisabled':                             'float16',\n        'Census_FlightRing':                                    'category',\n        'Census_ThresholdOptIn':                                'float16',\n        'Census_FirmwareManufacturerIdentifier':                'float16',\n        'Census_FirmwareVersionIdentifier':                     'float32',\n        'Census_IsSecureBootEnabled':                           'int8',\n        'Census_IsWIMBootEnabled':                              'float16',\n        'Census_IsVirtualDevice':                               'float16',\n        'Census_IsTouchEnabled':                                'int8',\n        'Census_IsPenCapable':                                  'int8',\n        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',\n        'Wdft_IsGamer':                                         'float16',\n        'Wdft_RegionIdentifier':                                'float16',\n        'HasDetections':                                        'int8'\n        }\n\ndef reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage(deep=True).sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage(deep=True).sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","18a0ef17":"numerics = ['int8', 'int16', 'int32', 'int64', 'float16', 'float32', 'float64']\nnumerical_columns = [c for c,v in dtypes.items() if v in numerics]\ncategorical_columns = [c for c,v in dtypes.items() if v not in numerics]","898e59d2":"%%time\ntrain = pd.read_csv('..\/input\/train.csv', dtype=dtypes)","045e4282":"train = reduce_mem_usage(train)","b71179f0":"stats = []\nfor col in train.columns:\n    stats.append((col, train[col].nunique(), train[col].isnull().sum() * 100 \/ train.shape[0], train[col].value_counts(normalize=True, dropna=False).values[0] * 100, train[col].dtype))\n    \nstats_df = pd.DataFrame(stats, columns=['Feature', 'Unique_values', 'Percentage of missing values', 'Percentage of values in the biggest category', 'type'])\nstats_df.sort_values('Percentage of missing values', ascending=False)","27edfebc":"good_cols = list(train.columns)\nfor col in train.columns:\n    rate = train[col].value_counts(normalize=True, dropna=False).values[0]\n    if rate > 0.9:\n        good_cols.remove(col)","4ed573e9":"train = train[good_cols]","8b9504ed":"test_dtypes = {k: v for k, v in dtypes.items() if k in good_cols}\ntest = pd.read_csv('..\/input\/test.csv', dtype=test_dtypes, usecols=good_cols[:-1])\ntest.loc[6529507, 'OsBuildLab'] = '17134.1.amd64fre.rs4_release.180410-1804'\ntest['OsBuildLab'] = test['OsBuildLab'].fillna('17134.1.amd64fre.rs4_release.180410-1804')\ntest = reduce_mem_usage(test)","7b921ad9":"train.head()","0979b976":"# function to plot data\ndef plot_categorical_feature(col, only_bars=False, top_n=10, by_touch=False):\n    top_n = top_n if train[col].nunique() > top_n else train[col].nunique()\n    print(f\"{col} has {train[col].nunique()} unique values and type: {train[col].dtype}.\")\n    print(train[col].value_counts(normalize=True, dropna=False).head())\n    if not by_touch:\n        if not only_bars:\n            df = train.groupby([col]).agg({'HasDetections': ['count', 'mean']})\n            df = df.sort_values(('HasDetections', 'count'), ascending=False).head(top_n).sort_index()\n            data = [go.Bar(x=df.index, y=df['HasDetections']['count'].values, name='counts'),\n                    go.Scatter(x=df.index, y=df['HasDetections']['mean'], name='Detections rate', yaxis='y2')]\n\n            layout = go.Layout(dict(title = f\"Counts of {col} by top-{top_n} categories and mean target value\",\n                                xaxis = dict(title = f'{col}',\n                                             showgrid=False,\n                                             zeroline=False,\n                                             showline=False,),\n                                yaxis = dict(title = 'Counts',\n                                             showgrid=False,\n                                             zeroline=False,\n                                             showline=False,),\n                                yaxis2=dict(title='Detections rate', overlaying='y', side='right')),\n                           legend=dict(orientation=\"v\"))\n\n        else:\n            top_cat = list(train[col].value_counts(dropna=False).index[:top_n])\n            df0 = train.loc[(train[col].isin(top_cat)) & (train['HasDetections'] == 1), col].value_counts().head(10).sort_index()\n            df1 = train.loc[(train[col].isin(top_cat)) & (train['HasDetections'] == 0), col].value_counts().head(10).sort_index()\n            data = [go.Bar(x=df0.index, y=df0.values, name='Has Detections'),\n                    go.Bar(x=df1.index, y=df1.values, name='No Detections')]\n\n            layout = go.Layout(dict(title = f\"Counts of {col} by top-{top_n} categories\",\n                                xaxis = dict(title = f'{col}',\n                                             showgrid=False,\n                                             zeroline=False,\n                                             showline=False,),\n                                yaxis = dict(title = 'Counts',\n                                             showgrid=False,\n                                             zeroline=False,\n                                             showline=False,),\n                                ),\n                           legend=dict(orientation=\"v\"), barmode='group')\n        \n        py.iplot(dict(data=data, layout=layout))\n        \n    else:\n        top_n = 10\n        top_cat = list(train[col].value_counts(dropna=False).index[:top_n])\n        df = train.loc[train[col].isin(top_cat)]\n\n        df1 = train.loc[train['Census_IsTouchEnabled'] == 1]\n        df0 = train.loc[train['Census_IsTouchEnabled'] == 0]\n\n        df0_ = df0.groupby([col]).agg({'HasDetections': ['count', 'mean']})\n        df0_ = df0_.sort_values(('HasDetections', 'count'), ascending=False).head(top_n).sort_index()\n        df1_ = df1.groupby([col]).agg({'HasDetections': ['count', 'mean']})\n        df1_ = df1_.sort_values(('HasDetections', 'count'), ascending=False).head(top_n).sort_index()\n        data1 = [go.Bar(x=df0_.index, y=df0_['HasDetections']['count'].values, name='Nontouch device counts'),\n                go.Scatter(x=df0_.index, y=df0_['HasDetections']['mean'], name='Detections rate for nontouch devices', yaxis='y2')]\n        data2 = [go.Bar(x=df1_.index, y=df1_['HasDetections']['count'].values, name='Touch device counts'),\n                go.Scatter(x=df1_.index, y=df1_['HasDetections']['mean'], name='Detections rate for touch devices', yaxis='y2')]\n\n        layout = go.Layout(dict(title = f\"Counts of {col} by top-{top_n} categories for nontouch devices\",\n                            xaxis = dict(title = f'{col}',\n                                         showgrid=False,\n                                         zeroline=False,\n                                         showline=False,\n                                         type='category'),\n                            yaxis = dict(title = 'Counts',\n                                         showgrid=False,\n                                         zeroline=False,\n                                         showline=False,),\n                                    yaxis2=dict(title='Detections rate', overlaying='y', side='right'),\n                            ),\n                       legend=dict(orientation=\"v\"), barmode='group')\n\n        py.iplot(dict(data=data1, layout=layout))\n        layout['title'] = f\"Counts of {col} by top-{top_n} categories for touch devices\"\n        py.iplot(dict(data=data2, layout=layout))","05c169dd":"train['HasDetections'].value_counts()","75b972ab":"plot_categorical_feature('Census_IsTouchEnabled', True)","efd54c35":"plot_categorical_feature('EngineVersion', by_touch=True)","3512daf5":"plot_categorical_feature('AppVersion')","022a49df":"plot_categorical_feature('AvSigVersion')","4bf3406a":"plot_categorical_feature('AVProductStatesIdentifier', True, 10)","0392aaaf":"train['AVProductStatesIdentifier'] = train['AVProductStatesIdentifier'].astype('category')\ntest['AVProductStatesIdentifier'] = test['AVProductStatesIdentifier'].astype('category')","442b0126":"plot_categorical_feature('AVProductsInstalled', True)","84c82a24":"# train.loc[train['AVProductsInstalled'].isin([1, 2]) == False, 'AVProductsInstalled'] = 3\n# test.loc[test['AVProductsInstalled'].isin([1, 2]) == False, 'AVProductsInstalled'] = 3","3b1b538b":"train['AVProductsInstalled'] = train['AVProductsInstalled'].astype('category')\ntest['AVProductsInstalled'] = test['AVProductsInstalled'].astype('category')","1143a87d":"plot_categorical_feature('AVProductsInstalled', True, by_touch=True)","501ed974":"plot_categorical_feature('CountryIdentifier', True, 20)","e4601810":"train['CountryIdentifier'] = train['CountryIdentifier'].astype('category')\ntest['CountryIdentifier'] = test['CountryIdentifier'].astype('category')","e4b88711":"plot_categorical_feature('CityIdentifier', True, 20)","06cf759d":"train['CityIdentifier'] = train['CityIdentifier'].astype('category')\ntest['CityIdentifier'] = test['CityIdentifier'].astype('category')","ba5aad10":"plot_categorical_feature('OrganizationIdentifier', True)","1cdbf3cf":"# train.loc[train['OrganizationIdentifier'].isin([27, 18]) == False, 'OrganizationIdentifier'] = 48\n# test.loc[test['OrganizationIdentifier'].isin([27, 18]) == False, 'OrganizationIdentifier'] = 48","6f51e0f0":"train['OrganizationIdentifier'] = train['OrganizationIdentifier'].astype('category')\ntest['OrganizationIdentifier'] = test['OrganizationIdentifier'].astype('category')","acae3de0":"plot_categorical_feature('OrganizationIdentifier', True, by_touch=True)","a9e0acf9":"plot_categorical_feature('GeoNameIdentifier', True)","bfe1b6b1":"train['GeoNameIdentifier'] = train['GeoNameIdentifier'].astype('category')\ntest['GeoNameIdentifier'] = test['GeoNameIdentifier'].astype('category')","6d267e45":"plot_categorical_feature('LocaleEnglishNameIdentifier', True)","cddf45d7":"train['LocaleEnglishNameIdentifier'] = train['LocaleEnglishNameIdentifier'].astype('category')\ntest['LocaleEnglishNameIdentifier'] = test['LocaleEnglishNameIdentifier'].astype('category')","47ddbc83":"plot_categorical_feature('OsPlatformSubRelease', True, by_touch=True)","c0701147":"plot_categorical_feature('OsBuildLab', True)","92e64871":"plot_categorical_feature('IeVerIdentifier', True)","06be9c44":"train['IeVerIdentifier'] = train['IeVerIdentifier'].astype('category')\ntest['IeVerIdentifier'] = test['IeVerIdentifier'].astype('category')","884bc90e":"plot_categorical_feature('Census_OEMNameIdentifier', True)","8f043c38":"train['Census_OEMNameIdentifier'] = train['Census_OEMNameIdentifier'].astype('category')\ntest['Census_OEMNameIdentifier'] = test['Census_OEMNameIdentifier'].astype('category')","5941e074":"plot_categorical_feature('Census_OEMModelIdentifier', True)","c7b17d61":"train['Census_OEMModelIdentifier'] = train['Census_OEMModelIdentifier'].astype('category')\ntest['Census_OEMModelIdentifier'] = test['Census_OEMModelIdentifier'].astype('category')","cff68bbb":"plot_categorical_feature('Census_ProcessorCoreCount', True, by_touch=True)","e4bf3c18":"# train.loc[train['Census_ProcessorCoreCount'].isin([2, 4, 8, 12]) == False, 'Census_ProcessorCoreCount'] = 1\n# test.loc[test['Census_ProcessorCoreCount'].isin([2, 4, 8, 12]) == False, 'Census_ProcessorCoreCount'] = 1","8f4bc742":"plot_categorical_feature('Census_ProcessorModelIdentifier', True)","56100371":"train['Census_ProcessorModelIdentifier'] = train['Census_ProcessorModelIdentifier'].astype('category')\ntest['Census_ProcessorModelIdentifier'] = test['Census_ProcessorModelIdentifier'].astype('category')","963b91e9":"plot_categorical_feature('Census_PrimaryDiskTotalCapacity', True)","6b4afeee":"plot_categorical_feature('Census_SystemVolumeTotalCapacity', True)","1fb4015b":"plot_categorical_feature('Census_TotalPhysicalRAM', True, by_touch=True)","3ec90ffd":"# top_10 = train['Census_TotalPhysicalRAM'].value_counts(dropna=False, normalize=True).cumsum().index[:10]\n# train.loc[train['Census_TotalPhysicalRAM'].isin(top_10) == False, 'Census_TotalPhysicalRAM'] = 1000\n# test.loc[test['Census_TotalPhysicalRAM'].isin(top_10) == False, 'Census_TotalPhysicalRAM'] = 1000","48f4ddc0":"plot_categorical_feature('Census_InternalPrimaryDiagonalDisplaySizeInInches', True, by_touch=True)","3825fe00":"plot_categorical_feature('Census_InternalPrimaryDisplayResolutionHorizontal', True, by_touch=True)","5feaa824":"plot_categorical_feature('Census_InternalPrimaryDisplayResolutionVertical', True, by_touch=True)","64654905":"plot_categorical_feature('Census_InternalBatteryNumberOfCharges', True, by_touch=True)","ef91e226":"train['Census_InternalBatteryNumberOfCharges'] = train['Census_InternalBatteryNumberOfCharges'].astype('category')\ntest['Census_InternalBatteryNumberOfCharges'] = test['Census_InternalBatteryNumberOfCharges'].astype('category')","2964e228":"plot_categorical_feature('Census_OSVersion', True)","f363d87c":"plot_categorical_feature('Census_OSBranch', True)","47ff3d13":"plot_categorical_feature('Census_OSBuildNumber', True)","8383fc53":"train['Census_OSBuildNumber'] = train['Census_OSBuildNumber'].astype('category')\ntest['Census_OSBuildNumber'] = test['Census_OSBuildNumber'].astype('category')","e46cba3e":"plot_categorical_feature('Census_OSBuildRevision', True)","97d342d0":"train['Census_OSBuildRevision'] = train['Census_OSBuildRevision'].astype('category')\ntest['Census_OSBuildRevision'] = test['Census_OSBuildRevision'].astype('category')","920cb0db":"plot_categorical_feature('Census_FirmwareManufacturerIdentifier', True)","10a293af":"train['Census_FirmwareManufacturerIdentifier'] = train['Census_FirmwareManufacturerIdentifier'].astype('category')\ntest['Census_FirmwareManufacturerIdentifier'] = test['Census_FirmwareManufacturerIdentifier'].astype('category')","37b8eb17":"plot_categorical_feature('Census_FirmwareVersionIdentifier', True)","a732f025":"train['Census_FirmwareVersionIdentifier'] = train['Census_FirmwareVersionIdentifier'].astype('category')\ntest['Census_FirmwareVersionIdentifier'] = test['Census_FirmwareVersionIdentifier'].astype('category')","4e53c4b3":"plot_categorical_feature('OsBuild', True)","d0cbefd4":"train['OsBuild'] = train['OsBuild'].astype('category')\ntest['OsBuild'] = test['OsBuild'].astype('category')","ceaa3c3b":"plot_categorical_feature('Census_ChassisTypeName', True, by_touch=True)","ae1d669b":"# https:\/\/www.kaggle.com\/youhanlee\/my-eda-i-want-to-see-all\n# grouping battary types by name\ndef group_battery(x):\n    x = x.lower()\n    if 'li' in x:\n        return 1\n    else:\n        return 0\n    \ntrain['Census_InternalBatteryType'] = train['Census_InternalBatteryType'].apply(group_battery)\ntest['Census_InternalBatteryType'] = test['Census_InternalBatteryType'].apply(group_battery)","77d5fa28":"plot_categorical_feature('Census_InternalBatteryType', True)","d0550989":"def rename_edition(x):\n    x = x.lower()\n    if 'core' in x:\n        return 'Core'\n    elif 'pro' in x:\n        return 'pro'\n    elif 'enterprise' in x:\n        return 'Enterprise'\n    elif 'server' in x:\n        return 'Server'\n    elif 'home' in x:\n        return 'Home'\n    elif 'education' in x:\n        return 'Education'\n    elif 'cloud' in x:\n        return 'Cloud'\n    else:\n        return x","f67c5ad6":"train['Census_OSEdition'] = train['Census_OSEdition'].astype(str)\ntest['Census_OSEdition'] = test['Census_OSEdition'].astype(str)\ntrain['Census_OSEdition'] = train['Census_OSEdition'].apply(rename_edition)\ntest['Census_OSEdition'] = test['Census_OSEdition'].apply(rename_edition)\ntrain['Census_OSEdition'] = train['Census_OSEdition'].astype('category')\ntest['Census_OSEdition'] = test['Census_OSEdition'].astype('category')","33837d47":"plot_categorical_feature('Census_OSEdition', True, by_touch=True)","62efd778":"train['Census_OSSkuName'] = train['Census_OSSkuName'].astype(str)\ntest['Census_OSSkuName'] = test['Census_OSSkuName'].astype(str)\ntrain['Census_OSSkuName'] = train['Census_OSSkuName'].apply(rename_edition)\ntest['Census_OSSkuName'] = test['Census_OSSkuName'].apply(rename_edition)\ntrain['Census_OSSkuName'] = train['Census_OSSkuName'].astype('category')\ntest['Census_OSSkuName'] = test['Census_OSSkuName'].astype('category')","79908784":"plot_categorical_feature('Census_OSSkuName', True, by_touch=True)","a5131e24":"plot_categorical_feature('Census_OSInstallLanguageIdentifier', True)","47ea06fc":"train['Census_OSInstallLanguageIdentifier'] = train['Census_OSInstallLanguageIdentifier'].astype('category')\ntest['Census_OSInstallLanguageIdentifier'] = test['Census_OSInstallLanguageIdentifier'].astype('category')","85e86573":"plot_categorical_feature('Census_OSUILocaleIdentifier', True)","4e29569d":"train['Census_OSUILocaleIdentifier'] = train['Census_OSUILocaleIdentifier'].astype('category')\ntest['Census_OSUILocaleIdentifier'] = test['Census_OSUILocaleIdentifier'].astype('category')","7e061264":"plot_categorical_feature('Census_OSUILocaleIdentifier', True)","b645ef54":"plot_categorical_feature('OsSuite', True)","37048ad8":"train['OsSuite'] = train['OsSuite'].astype('category')\ntest['OsSuite'] = test['OsSuite'].astype('category')","ba68ce0e":"plot_categorical_feature('Wdft_RegionIdentifier', True)","e91d0100":"train['Wdft_RegionIdentifier'] = train['Wdft_RegionIdentifier'].astype('category')\ntest['Wdft_RegionIdentifier'] = test['Wdft_RegionIdentifier'].astype('category')","ed38f7f1":"train['SkuEdition'].value_counts(dropna=False, normalize=True)","4090ab1b":"# train.loc[train['SkuEdition'] != 'Home', 'SkuEdition'] = 'Pro'\n# test.loc[test['SkuEdition'] != 'Home', 'SkuEdition'] = 'Pro'\n\n# train['SkuEdition'] = train['SkuEdition'].cat.remove_unused_categories()\n# test['SkuEdition'] = test['SkuEdition'].cat.remove_unused_categories()","ade8f484":"pd.crosstab(train['SkuEdition'], train['Census_OSEdition'], normalize='columns')","302e7ff2":"train['SmartScreen'].value_counts(dropna=False, normalize=True).cumsum()","b29a55c9":"# train.loc[train['SmartScreen'].isnull(), 'SmartScreen'] = 'ExistsNotSet'\n# test.loc[test['SmartScreen'].isnull(), 'SmartScreen'] = 'ExistsNotSet'\n# train.loc[train['SmartScreen'].isin(['RequireAdmin', 'ExistsNotSet', 'Off', 'Warn']) == False, 'SmartScreen'] = 'Prompt'\n# test.loc[test['SmartScreen'].isin(['RequireAdmin', 'ExistsNotSet', 'Off', 'Warn']) == False, 'SmartScreen'] = 'Prompt'\n\n# train['SmartScreen'] = train['SmartScreen'].cat.remove_unused_categories()\n# test['SmartScreen'] = test['SmartScreen'].cat.remove_unused_categories()","95dd5c6c":"sns.set(rc={'figure.figsize':(15, 8)})\nsns.countplot(x=\"SmartScreen\", hue=\"HasDetections\",  palette=\"PRGn\", data=train)\nplt.title(\"SmartScreen counts\")\nplt.xticks(rotation='vertical')\nplt.show()","9f0bdf8f":"train['Census_MDC2FormFactor'].value_counts(dropna=False, normalize=True).cumsum()","f8a77c2e":"# top_cats = list(train['Census_MDC2FormFactor'].value_counts().index[:5])\n# train.loc[train['Census_MDC2FormFactor'].isin(top_cats) == False, 'Census_MDC2FormFactor'] = 'PCOther'\n# test.loc[test['Census_MDC2FormFactor'].isin(top_cats) == False, 'Census_MDC2FormFactor'] = 'PCOther'\n\n# train['Census_MDC2FormFactor'] = train['Census_MDC2FormFactor'].cat.remove_unused_categories()\n# test['Census_MDC2FormFactor'] = test['Census_MDC2FormFactor'].cat.remove_unused_categories()","d0752cb6":"plot_categorical_feature('Census_MDC2FormFactor', True)","9ea6b9ca":"sns.catplot(x=\"Census_PrimaryDiskTypeName\", hue=\"HasDetections\", col=\"Census_MDC2FormFactor\",\n                data=train, kind=\"count\",col_wrap=3);","956af2e6":"train['Census_PrimaryDiskTypeName'].value_counts(dropna=False, normalize=True).cumsum()","17b9f951":"# train.loc[train['Census_PrimaryDiskTypeName'].isin(['HDD', 'SSD']) == False, 'Census_PrimaryDiskTypeName'] = 'UNKNOWN'\n# test.loc[test['Census_PrimaryDiskTypeName'].isin(['HDD', 'SSD']) == False, 'Census_PrimaryDiskTypeName'] = 'UNKNOWN'\n\n# train['Census_PrimaryDiskTypeName'] = train['Census_PrimaryDiskTypeName'].cat.remove_unused_categories()\n# test['Census_PrimaryDiskTypeName'] = test['Census_PrimaryDiskTypeName'].cat.remove_unused_categories()","781bcded":"train['Census_ProcessorManufacturerIdentifier'].value_counts(dropna=False, normalize=True).cumsum()","af1138f4":"# train.loc[train['Census_ProcessorManufacturerIdentifier'].isin([5.0, 1.0]) == False, 'Census_ProcessorManufacturerIdentifier'] = 0.0\n# test.loc[test['Census_ProcessorManufacturerIdentifier'].isin([5.0, 1.0]) == False, 'Census_ProcessorManufacturerIdentifier'] = 0.0\n\n# train['Census_ProcessorManufacturerIdentifier'] = train['Census_ProcessorManufacturerIdentifier'].astype('category')\n# test['Census_ProcessorManufacturerIdentifier'] = test['Census_ProcessorManufacturerIdentifier'].astype('category')","ba853a49":"plot_categorical_feature('Census_ProcessorManufacturerIdentifier', True)","01b76bc3":"train['Census_PowerPlatformRoleName'].value_counts(dropna=False, normalize=True).cumsum()","c8d024d9":"# train.loc[train['Census_PowerPlatformRoleName'].isin(['Mobile', 'Desktop', 'Slate']) == False, 'Census_PowerPlatformRoleName'] = 'UNKNOWN'\n# test.loc[test['Census_PowerPlatformRoleName'].isin(['Mobile', 'Desktop', 'Slate']) == False, 'Census_PowerPlatformRoleName'] = 'UNKNOWN'\n\n# train['Census_PowerPlatformRoleName'] = train['Census_PowerPlatformRoleName'].cat.remove_unused_categories()\n# test['Census_PowerPlatformRoleName'] = test['Census_PowerPlatformRoleName'].cat.remove_unused_categories()","45a71c08":"plot_categorical_feature('Census_PowerPlatformRoleName', True)","e01d6ac4":"plot_categorical_feature('Census_OSInstallTypeName', True)","ba8a5d19":"# top_cats = list(train['Census_OSWUAutoUpdateOptionsName'].value_counts().index[:3])\n# train.loc[train['Census_OSWUAutoUpdateOptionsName'].isin(top_cats) == False, 'Census_OSWUAutoUpdateOptionsName'] = 'Off'\n# test.loc[test['Census_OSWUAutoUpdateOptionsName'].isin(top_cats) == False, 'Census_OSWUAutoUpdateOptionsName'] = 'Off'\n\n# train['Census_OSWUAutoUpdateOptionsName'] = train['Census_OSWUAutoUpdateOptionsName'].cat.remove_unused_categories()\n# test['Census_OSWUAutoUpdateOptionsName'] = test['Census_OSWUAutoUpdateOptionsName'].cat.remove_unused_categories()","781c7ee5":"# train.loc[train['Census_GenuineStateName'] == 'UNKNOWN', 'Census_GenuineStateName'] = 'OFFLINE'\n# test.loc[test['Census_GenuineStateName'] == 'UNKNOWN', 'Census_GenuineStateName'] = 'OFFLINE'\n\n# train['Census_GenuineStateName'] = train['Census_GenuineStateName'].cat.remove_unused_categories()\n# test['Census_GenuineStateName'] = test['Census_GenuineStateName'].cat.remove_unused_categories()","1e6aba1b":"# train.loc[train['Census_ActivationChannel'].isin(['Retail', 'OEM:DM']) == False, 'Census_ActivationChannel'] = 'Volume:GVLK'\n# test.loc[test['Census_ActivationChannel'].isin(['Retail', 'OEM:DM']) == False, 'Census_ActivationChannel'] = 'Volume:GVLK'\n\n# train['Census_ActivationChannel'] = train['Census_ActivationChannel'].cat.remove_unused_categories()\n# test['Census_ActivationChannel'] = test['Census_ActivationChannel'].cat.remove_unused_categories()","a9f761b5":"train.head()","cba245dd":"train['OsBuildLab'] = train['OsBuildLab'].cat.add_categories(['0.0.0.0.0-0'])\ntrain['OsBuildLab'] = train['OsBuildLab'].fillna('0.0.0.0.0-0')\ntest['OsBuildLab'] = test['OsBuildLab'].cat.add_categories(['0.0.0.0.0-0'])\ntest['OsBuildLab'] = test['OsBuildLab'].fillna('0.0.0.0.0-0')","878a3557":"def fe(df):\n    df['EngineVersion_2'] = df['EngineVersion'].apply(lambda x: x.split('.')[2]).astype('category')\n    df['EngineVersion_3'] = df['EngineVersion'].apply(lambda x: x.split('.')[3]).astype('category')\n\n    df['AppVersion_1'] = df['AppVersion'].apply(lambda x: x.split('.')[1]).astype('category')\n    df['AppVersion_2'] = df['AppVersion'].apply(lambda x: x.split('.')[2]).astype('category')\n    df['AppVersion_3'] = df['AppVersion'].apply(lambda x: x.split('.')[3]).astype('category')\n\n    df['AvSigVersion_0'] = df['AvSigVersion'].apply(lambda x: x.split('.')[0]).astype('category')\n    df['AvSigVersion_1'] = df['AvSigVersion'].apply(lambda x: x.split('.')[1]).astype('category')\n    df['AvSigVersion_2'] = df['AvSigVersion'].apply(lambda x: x.split('.')[2]).astype('category')\n\n    df['OsBuildLab_0'] = df['OsBuildLab'].apply(lambda x: x.split('.')[0]).astype('category')\n    df['OsBuildLab_1'] = df['OsBuildLab'].apply(lambda x: x.split('.')[1]).astype('category')\n    df['OsBuildLab_2'] = df['OsBuildLab'].apply(lambda x: x.split('.')[2]).astype('category')\n    df['OsBuildLab_3'] = df['OsBuildLab'].apply(lambda x: x.split('.')[3]).astype('category')\n    # df['OsBuildLab_40'] = df['OsBuildLab'].apply(lambda x: x.split('.')[-1].split('-')[0]).astype('category')\n    # df['OsBuildLab_41'] = df['OsBuildLab'].apply(lambda x: x.split('.')[-1].split('-')[1]).astype('category')\n\n    df['Census_OSVersion_0'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[0]).astype('category')\n    df['Census_OSVersion_1'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[1]).astype('category')\n    df['Census_OSVersion_2'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[2]).astype('category')\n    df['Census_OSVersion_3'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[3]).astype('category')\n\n    # https:\/\/www.kaggle.com\/adityaecdrid\/simple-feature-engineering-xd\n    df['primary_drive_c_ratio'] = df['Census_SystemVolumeTotalCapacity']\/ df['Census_PrimaryDiskTotalCapacity']\n    df['non_primary_drive_MB'] = df['Census_PrimaryDiskTotalCapacity'] - df['Census_SystemVolumeTotalCapacity']\n\n    df['aspect_ratio'] = df['Census_InternalPrimaryDisplayResolutionHorizontal']\/ df['Census_InternalPrimaryDisplayResolutionVertical']\n\n    df['monitor_dims'] = df['Census_InternalPrimaryDisplayResolutionHorizontal'].astype(str) + '*' + df['Census_InternalPrimaryDisplayResolutionVertical'].astype('str')\n    df['monitor_dims'] = df['monitor_dims'].astype('category')\n\n    df['dpi'] = ((df['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + df['Census_InternalPrimaryDisplayResolutionVertical']**2)**.5)\/(df['Census_InternalPrimaryDiagonalDisplaySizeInInches'])\n\n    df['dpi_square'] = df['dpi'] ** 2\n\n    df['MegaPixels'] = (df['Census_InternalPrimaryDisplayResolutionHorizontal'] * df['Census_InternalPrimaryDisplayResolutionVertical'])\/1e6\n\n    df['Screen_Area'] = (df['aspect_ratio']* (df['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2))\/(df['aspect_ratio']**2 + 1)\n\n    df['ram_per_processor'] = df['Census_TotalPhysicalRAM']\/ df['Census_ProcessorCoreCount']\n\n    df['new_num_0'] = df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] \/ df['Census_ProcessorCoreCount']\n\n    df['new_num_1'] = df['Census_ProcessorCoreCount'] * df['Census_InternalPrimaryDiagonalDisplaySizeInInches']\n    \n    df['Census_IsFlightingInternal'] = df['Census_IsFlightingInternal'].fillna(1)\n    df['Census_ThresholdOptIn'] = df['Census_ThresholdOptIn'].fillna(1)\n    df['Census_IsWIMBootEnabled'] = df['Census_IsWIMBootEnabled'].fillna(1)\n    df['Wdft_IsGamer'] = df['Wdft_IsGamer'].fillna(0)\n    \n    return df","6b0e88d5":"train = fe(train)\ntest = fe(test)","9b40c88d":"cat_cols = [col for col in train.columns if col not in ['MachineIdentifier', 'Census_SystemVolumeTotalCapacity', 'HasDetections'] and str(train[col].dtype) == 'category']\nlen(cat_cols)","7c572d08":"more_cat_cols = []\nadd_cat_feats = [\n 'Census_OSBuildRevision',\n 'OsBuildLab',\n 'SmartScreen',\n'AVProductsInstalled']\nfor col1 in add_cat_feats:\n    for col2 in add_cat_feats:\n        if col1 != col2:\n            train[col1 + '__' + col2] = train[col1].astype(str) + train[col2].astype(str)\n            train[col1 + '__' + col2] = train[col1 + '__' + col2].astype('category')\n            \n            test[col1 + '__' + col2] = test[col1].astype(str) + test[col2].astype(str)\n            test[col1 + '__' + col2] = test[col1 + '__' + col2].astype('category')\n            more_cat_cols.append(col1 + '__' + col2)\n            \ncat_cols = cat_cols + more_cat_cols","b3503e74":"to_encode = []\nfor col in cat_cols:\n    if train[col].nunique() > 1000:\n        print(col, train[col].nunique())\n        to_encode.append(col)","afcb3206":"train = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)\ngc.collect()","e0104210":"def frequency_encoding(variable):\n    t = pd.concat([train[variable], test[variable]]).value_counts().reset_index()\n    t = t.reset_index()\n    t.loc[t[variable] == 1, 'level_0'] = np.nan\n    t.set_index('index', inplace=True)\n    max_label = t['level_0'].max() + 1\n    t.fillna(max_label, inplace=True)\n    return t.to_dict()['level_0']","d906df16":"for col in tqdm_notebook(to_encode):\n    freq_enc_dict = frequency_encoding(col)\n    train[col] = train[col].map(lambda x: freq_enc_dict.get(x, np.nan))\n    test[col] = test[col].map(lambda x: freq_enc_dict.get(x, np.nan))\n    cat_cols.remove(col)","1be2bf19":"%%time\nindexer = {}\nfor col in cat_cols:\n    # print(col)\n    _, indexer[col] = pd.factorize(train[col].astype(str), sort=True)\n    \nfor col in tqdm_notebook(cat_cols):\n    # print(col)\n    train[col] = indexer[col].get_indexer(train[col].astype(str))\n    test[col] = indexer[col].get_indexer(test[col].astype(str))\n    \n    train = reduce_mem_usage(train, verbose=False)\n    test = reduce_mem_usage(test, verbose=False)","e90a3b4a":"del indexer","a920948a":"train.head()","b8959c06":"y = train['HasDetections']\ntrain = train.drop(['HasDetections', 'MachineIdentifier'], axis=1)\ntest = test.drop(['MachineIdentifier'], axis=1)\ngc.collect()\ntrain.sort_values('AvSigVersion')\ntrain1 = train[:4000000]\ntrain = train[4000000:8000000]\n\ny1 = y[:4000000]\ny = y[4000000:8000000]","141c2bb0":"n_fold = 5\nfolds = StratifiedKFold(n_splits=n_fold, shuffle=True, random_state=15)\n# folds = TimeSeriesSplit(n_splits=5)","afa26c0c":"from numba import jit\n# fast roc_auc computation: https:\/\/www.kaggle.com\/c\/microsoft-malware-prediction\/discussion\/76013\n@jit\ndef fast_auc(y_true, y_prob):\n    y_true = np.asarray(y_true)\n    y_true = y_true[np.argsort(y_prob)]\n    nfalse = 0\n    auc = 0\n    n = len(y_true)\n    for i in range(n):\n        y_i = y_true[i]\n        nfalse += (1 - y_i)\n        auc += y_i * nfalse\n    auc \/= (nfalse * (n - nfalse))\n    return auc\n\ndef eval_auc(preds, dtrain):\n    labels = dtrain.get_label()\n    return 'auc', fast_auc(labels, preds), True\n\n# idea from this kernel: https:\/\/www.kaggle.com\/fabiendaniel\/detecting-malwares-with-lgbm\ndef predict_chunk(model, test):\n    initial_idx = 0\n    chunk_size = 1000000\n    current_pred = np.zeros(len(test))\n    while initial_idx < test.shape[0]:\n        final_idx = min(initial_idx + chunk_size, test.shape[0])\n        idx = range(initial_idx, final_idx)\n        current_pred[idx] = model.predict(test.iloc[idx], num_iteration=model.best_iteration)\n        initial_idx = final_idx\n    #predictions += current_pred \/ min(folds.n_splits, max_iter)\n    return current_pred\n\n\ndef train_model(X=train, X_test=test, y=y, params=None, folds=folds, model_type='lgb', plot_feature_importance=False, averaging='usual', make_oof=False):\n    result_dict = {}\n    if make_oof:\n        oof = np.zeros(len(X))\n    prediction = np.zeros(len(X_test))\n    scores = []\n    feature_importance = pd.DataFrame()\n    for fold_n, (train_index, valid_index) in enumerate(folds.split(X, y)):\n        gc.collect()\n        print('Fold', fold_n + 1, 'started at', time.ctime())\n        X_train, X_valid = X.iloc[train_index], X.iloc[valid_index]\n        y_train, y_valid = y.iloc[train_index], y.iloc[valid_index]\n        \n        \n        if model_type == 'lgb':\n            train_data = lgb.Dataset(X_train, label=y_train, categorical_feature = cat_cols)\n            valid_data = lgb.Dataset(X_valid, label=y_valid, categorical_feature = cat_cols)\n            \n            model = lgb.train(params,\n                    train_data,\n                    num_boost_round=2000,\n                    valid_sets = [train_data, valid_data],\n                    verbose_eval=500,\n                    early_stopping_rounds = 200,\n                    feval=eval_auc)\n\n            del train_data, valid_data\n            \n            y_pred_valid = model.predict(X_valid, num_iteration=model.best_iteration)\n            del X_valid\n            gc.collect()\n            # print('predicting on test')\n            # y_pred = model.predict(X_test, num_iteration=model.best_iteration)\n            y_pred = predict_chunk(model, X_test)\n            # print('predicted')\n            \n        if model_type == 'xgb':\n            train_data = xgb.DMatrix(data=X_train, label=y_train)\n            valid_data = xgb.DMatrix(data=X_valid, label=y_valid)\n\n            watchlist = [(train_data, 'train'), (valid_data, 'valid_data')]\n            model = xgb.train(dtrain=train_data, num_boost_round=20000, evals=watchlist, early_stopping_rounds=200, verbose_eval=500, params=params)\n            y_pred_valid = model.predict(xgb.DMatrix(X_valid), ntree_limit=model.best_ntree_limit)\n            #y_pred = model.predict(xgb.DMatrix(X_test), ntree_limit=model.best_ntree_limit)\n            y_pred = predict_chunk(model, xgb.DMatrix(X_test))\n            \n        if model_type == 'lcv':\n            model = LogisticRegressionCV(scoring='roc_auc', cv=3)\n            model.fit(X_train, y_train)\n\n            y_pred_valid = model.predict(X_valid)\n            # y_pred = model.predict(X_test)\n            y_pred = predict_chunk(model, X_test)\n            \n        if model_type == 'cat':\n            model = CatBoostRegressor(iterations=20000,  eval_metric='AUC', **params)\n            model.fit(X_train, y_train, eval_set=(X_valid, y_valid), cat_features=[], use_best_model=True, verbose=False)\n\n            y_pred_valid = model.predict(X_valid)\n            # y_pred = model.predict(X_test)\n            y_pred = predict_chunk(model, X_test)\n        \n        if make_oof:\n            oof[valid_index] = y_pred_valid.reshape(-1,)\n            \n        scores.append(fast_auc(y_valid, y_pred_valid))\n        print('Fold roc_auc:', roc_auc_score(y_valid, y_pred_valid))\n        print('')\n        \n        if averaging == 'usual':\n            prediction += y_pred\n        elif averaging == 'rank':\n            prediction += pd.Series(y_pred).rank().values\n        \n        if model_type == 'lgb':\n            # feature importance\n            fold_importance = pd.DataFrame()\n            fold_importance[\"feature\"] = X.columns\n            fold_importance[\"importance\"] = model.feature_importance()\n            fold_importance[\"fold\"] = fold_n + 1\n            feature_importance = pd.concat([feature_importance, fold_importance], axis=0)\n\n    prediction \/= n_fold\n    \n    print('CV mean score: {0:.4f}, std: {1:.4f}.'.format(np.mean(scores), np.std(scores)))\n    \n    if model_type == 'lgb':\n        \n        if plot_feature_importance:\n            feature_importance[\"importance\"] \/= n_fold\n            cols = feature_importance[[\"feature\", \"importance\"]].groupby(\"feature\").mean().sort_values(\n                by=\"importance\", ascending=False)[:50].index\n\n            best_features = feature_importance.loc[feature_importance.feature.isin(cols)]\n            logging.info('Top features')\n            for f in best_features.sort_values(by=\"importance\", ascending=False)['feature'].values:\n                logging.info(f)\n\n            plt.figure(figsize=(16, 12));\n            sns.barplot(x=\"importance\", y=\"feature\", data=best_features.sort_values(by=\"importance\", ascending=False));\n            plt.title('LGB Features (avg over folds)');\n            \n            result_dict['feature_importance'] = feature_importance\n            \n    result_dict['prediction'] = prediction\n    if make_oof:\n        result_dict['oof'] = oof\n    \n    return result_dict","0bfdf0b2":"# params from https:\/\/www.kaggle.com\/fabiendaniel\/detecting-malwares-with-lgbm\nparams = {'num_leaves': 256,\n         'min_data_in_leaf': 42,\n         'objective': 'binary',\n         'max_depth': 7,\n         'learning_rate': 0.05,\n         \"boosting\": \"gbdt\",\n         \"feature_fraction\": 0.8,\n         \"bagging_freq\": 3,\n         \"bagging_fraction\": 0.8,\n         \"bagging_seed\": 11,\n         \"lambda_l1\": 0.15,\n         \"lambda_l2\": 0.15,\n         \"random_state\": 42,          \n         \"verbosity\": -1}","d3730f41":"del stats_df, freq_enc_dict","4e137172":"result_dict1 = train_model(X=train1, X_test=test, y=y1, params=params, model_type='lgb', plot_feature_importance=True, averaging='rank')","28bd16ec":"del train1, y1","40f609d2":"# params = {'num_leaves': 64,\n#          'min_data_in_leaf': 20,\n#          'objective': 'binary',\n#          'max_depth': 5,\n#          'learning_rate': 0.05,\n#          \"boosting\": \"gbdt\",\n#          \"feature_fraction\": 0.9,\n#          \"bagging_freq\": 5,\n#          \"bagging_fraction\": 0.7,\n#          \"bagging_seed\": 11,\n#          \"lambda_l1\": 0.2,\n#          \"lambda_l2\": 0.2,\n#          \"random_state\": 13,          \n#          \"verbosity\": -1}\n# result_dict = train_model(X=train, X_test=test, y=y, params=params, model_type='lgb', plot_feature_importance=False, averaging='rank')","1a99dc91":"submission = pd.read_csv('..\/input\/sample_submission.csv')\n\n# submission['HasDetections'] = (result_dict['prediction'] + result_dict1['prediction'] + result_dict2['prediction']) \/ 3\n# submission['HasDetections'] = (result_dict['prediction'] + result_dict1['prediction']) \/ 2\nsubmission['HasDetections'] = result_dict1['prediction']\nsubmission.to_csv('lgb_rank.csv', index=False)","1158a898":"### Census_InternalPrimaryDisplayResolutionVertical","6d9a2082":"### IeVerIdentifier","9b976ab7":"### Census_ProcessorModelIdentifier","13b92042":"### OsPlatformSubRelease","b000c56b":"### SmartScreen","084b6d7c":"### Census_OEMModelIdentifier","519b91cd":"### AVProductsInstalled","8eb6e082":"## Loading data\nLet's try loading data in a naive way","ea46df05":"It seems that Home Sku edition corresponds to Core OS Edition, and Pro Sku edition corresponts to all other OS editions.","194470de":"### OsBuild","08462cb5":"### Census_OSUILocaleIdentifier","0474d4fe":"### SkuEdition","8f4cdcd9":"Once again anonymized variable.","a721ce2d":"### Census_PrimaryDiskTotalCapacity","7db088d4":"### Census_OSBuildRevision","0ca965c7":"### AvSigVersion","101424da":"### Census_ProcessorManufacturerIdentifier","cc113622":"We can see that two categories take 84% of all values. The difference in detection rates is noticable. Other categories have different detection rate, but it is simply due to the low number of samples in them.\nPatterns for touch and non-touch devices are quite similar.","5b111f13":"### Census_ProcessorCoreCount","c9f65253":"### Census_FirmwareVersionIdentifier","22e2928a":"Hm, interesting. If a computer has an antivirus, it is less likely to be infected. But having two antiviruses has an opposite effect. Maybe those who install 2 antiviruses tend to have less experience with working on PC?\nAlso other categories have really low samples, let's combine them.","ed723379":"The target is balanced, which is nice.","89276b38":"### Label Encoding","a31ec863":"### LocaleEnglishNameIdentifier","c08923fa":"### Census_InternalBatteryType","bb28d66b":"### Wdft_RegionIdentifier","64b42dce":"### CityIdentifier\nThe same situation for cities.","11aaa643":"I'm really surprised that most computers have 15 inch screens. And this is a rare situation, when for some categories detection rate on PC is higher than on touch devices.","aaee914f":"We can see several interesting things here:\n* PuaMode and Census_ProcessorClass have 99%+ missing values, which means that these columns are useless and should be dropped;\n* In DefaultBrowsersIdentifier column 95% values belong to one category, so I think this columns is also useless;\n* Census_IsFlightingInternal is strange, but maybe analysis of it will make sense;\n* There are 26 columns in total in which one category contains 90% values. I think that these imbalanced columns should be removed from the dataset;\n* One more important point is that there are many columns which are considered to be numerical (from this kernel: #https:\/\/www.kaggle.com\/theoviel\/load-the-totality-of-the-data), but I think they are categorical - like CityIdentifier. We'll see more in EDA below;\n\n\nI see that all columns except Census_SystemVolumeTotalCapacity are categorical. \nAlso there are 3 columns, where most of the values are missing. Let's drop them.","978c3f39":"### Census_PowerPlatformRoleName","9f522944":"This is quuite strange. 2 organizations cover ~66% of all computers, while unknown organizations have 30% more. Maybe these are some specific industries? Let's combine values.","78efed73":"Once again we have a categorical column which was defined as numerical. While most countries have rate of detections ~50%, there are some countries where there are much more infected devices.","c970eec8":"It is interesting that most computers have Windows 10 (rs*). I suppose Microsoft specifically chose them, so that we would work with modern devices?","8ede4ddd":"### Census_OSVersion","e26fff25":"## Idea of training on all data\nLet's try training model on three subsets of train data separately and blend the predictions.","931fd43e":"### Census_MDC2FormFactor","80717734":"### OrganizationIdentifier","60745777":"### Census_FirmwareManufacturerIdentifier","cad96fe7":"## EngineVersion","98c54335":"### Census_InternalBatteryNumberOfCharges","e9390944":"### OsBuildLab","8297881a":"Most computers have 2, 4 or 8 cores. For touch deviced 4 cores are much more common than other configurations. And these 3 variants cover 95% of all samples,","40b0f005":"### Census_OEMNameIdentifier","e6bde014":"Interesting and somewhat strange results. It is expected that most PCs have 0 charges. 4.294967e+09 seems to be some kind of technical value. But having several charges for PC is strange. Anyway, this is definitely a categorical variable.","4dab3a01":"### Variables with high amount of unique values\nAt first I'll have a look at variables  with a lot of categories. Then I'll move to more interesting variables with a limited amount of categories.","22fdc9d1":"### OsSuite","b1e0c904":"As expected Microsoft has much more computers that touch devices. The rate of infections is lower for touch devices, but not by much.","3a3eb820":"### Census_InternalPrimaryDisplayResolutionHorizontal","0112e66d":"## Data exploration","db063bdf":"### Census_OSBuildNumber","ff4dcbec":"This is definitely a categorical variable.","2b62d81f":"In this case we have one main category with 0.53 detection rate, other categories are much smaller.","d7ffff2f":"### Census_OSInstallTypeName","76f2b734":"## Feature engineering and transformation","69602597":"### CountryIdentifier","a04bbc60":"### AVProductStatesIdentifier","94acdf2f":"### AppVersion","ee9f8f44":"This feature has a huge amount of categories, it seems this is a version of an often updated software.","5fad8a0a":"### Census_SystemVolumeTotalCapacity","5402763d":"Home and Pro editions together give 97.9%+ of all values. Condidering that other categories are for Enterprise mostly, I combine them with Pro.","fe994d92":"It is interesting, that even on touch devices people sometimes install 2 antiviruses.","5516d26c":"I think that this is a first truly numerical variable. Census_PrimaryDiskTotalCapacity could be numerical, but it has too little unique values and every category could be considered a separate disk model.","21737c17":"### Census_OSSkuName\nAlmost the same as previous variable","e5fa5088":"### Modelling\n\nAdded possibility to do rank averaging.","b820d0f2":"Quite interesting that most computers have <=8 Gb RAM.","2e164a5b":"### Census_OSEdition\n\nI'll combine similar versions into one.","16b207bb":"### Frequency encoding\n\nFrom this kernel:  https:\/\/www.kaggle.com\/fabiendaniel\/detecting-malwares-with-lgbm\n\nI do frequency and label encoding on the full train dataset, because I think I'll get more correct values this way.","b5e37bdc":"Now we can read test data.","c92ed0e1":"### Census_IsTouchEnabled","0386820f":"### Census_OSBranch","dd0c8593":"### Census_OSUILocaleIdentifier","9b21bc7d":"## Microsoft Malware Prediction\n\nThe goal of this competition is to predict a Windows machine\u2019s probability of getting infected by various families of malware, based on different properties of that machine. It is really important to find out whether the computer is infected and cure it.\n\nWe have a huge dataset of data, where most features are categorical. I think that correct mean encoding should be important. Also the number of columns is quite high so it could be tempting to make some automatical processing for all columns. I personally think that it is important to analyze each variable and it could help to do a better processing.\n\nIn this kernel I'll do a detailed EDA, feature engineering and modelling.\n\n![](https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/10683\/logos\/thumb76_76.png?t=2018-09-19-16-55-15)","770feb5c":"### Census_InternalPrimaryDiagonalDisplaySizeInInches","362ed31f":"It is nice to see that these two variables interact reasonably.\nDetachable devices usually have SSD, desktop PC have HDD and SDD and Notebooks usually have HDD.","91d2ec55":"### Census_TotalPhysicalRAM","b154894d":"### GeoNameIdentifier","23549722":"### Census_OSInstallLanguageIdentifier\nSadly we don't know what mean these numbers.","e0746aa9":"As per description: If the value exists but is blank, the value \"ExistsNotSet\" is sent in telemetry.\nSo missing values and ExistsNotSet are in fact the same. This category + RequireAdmin + Off + Warn are 99.3% of all values. I'll combine all other values into Prompt.","970b0e5c":"### Target","c84e1c03":"For some reason slates have quite a low rate of detections. Maybe no hackers are interested in them? :)","4203ecac":"### Census_ChassisTypeName"}}