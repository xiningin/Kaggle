{"cell_type":{"63b0cbcf":"code","621df6c2":"code","c4af0e34":"code","b00ff03f":"code","76b047cb":"code","f5c487cb":"code","ccc3c935":"code","1cd4e538":"code","9d609b56":"code","a40a5fe0":"code","b3fec7bf":"code","60b28003":"code","e749f396":"code","f43113b5":"code","2f7e4a6f":"code","502c635e":"code","f5b27e29":"code","585ca4a7":"code","774da069":"code","1e573f9c":"code","f9db02e4":"code","ed57d3b3":"code","69960f0c":"code","a11c1aa5":"code","337683b1":"code","0519c74d":"code","d5e86a2f":"code","b92508ce":"code","15480bce":"code","b1376110":"code","cb6d6666":"code","7890e198":"code","90fac5b6":"code","b3881dae":"code","60545508":"code","83e49a56":"code","c4404028":"code","08f57c81":"code","c59ff3c8":"code","7a4041a4":"code","bf9d53f6":"code","5ffe52a1":"code","5cfefbb9":"code","b63795a5":"code","c03d7208":"code","6baf4b24":"code","d650e7b0":"code","857590e3":"code","0ab1fc2b":"code","253a64c3":"code","74de846e":"code","03db338f":"code","47dd0725":"code","a9fe3dd6":"code","7b86f78a":"code","fd973700":"code","d76d2aa3":"code","16917386":"code","367e8152":"code","68241e9c":"code","4ffdab4b":"code","c68fba81":"code","5ef2ca25":"code","9c2518f7":"code","d1ab9999":"code","e5d88e33":"code","e5ab4f03":"code","ca9b0f97":"code","945574ed":"code","eb6ed223":"code","221dded1":"code","d80d7d81":"code","acdc2a5e":"code","c66ec4ce":"code","06ed5bb5":"markdown","0a88fe2e":"markdown","70f6f2ad":"markdown","e3fb89b4":"markdown","a6dbf147":"markdown","5ed3b712":"markdown","7b31af84":"markdown","e22bd91c":"markdown","4571b766":"markdown","f911d048":"markdown","36d6b389":"markdown","e0c62baf":"markdown","434657ff":"markdown","c7aa60fe":"markdown","0aaf93a7":"markdown","7f2fb74d":"markdown","8fa1325c":"markdown","e8012d21":"markdown"},"source":{"63b0cbcf":"\nimport numpy as np\nimport pandas as pd\npd.set_option('display.max_columns', None)\n#pd.set_option('display.max_rows', None)\npd.set_option('display.float_format', lambda x: '%.5f' % x)\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport warnings\nimport seaborn as sns\nfrom operator import attrgetter\nimport matplotlib.colors as mcolors\nimport datetime as dt\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\n","621df6c2":"pip install openpyxl","c4af0e34":"df_ =  pd.read_excel('..\/input\/kaagle2010\/online_retail_II_kaggle2010.xlsx')","b00ff03f":"df_.head(5)","76b047cb":"# after permanent changes, we might want to come back, lets copy the main data\n\ndf = df_.copy()","f5c487cb":"df.columns\n# there are 8 variables (columns)","ccc3c935":"# some invoice starts with 'C', this means these orders have been cancelled. We should drop them.\n\ndf[\"Invoice\"] = df[\"Invoice\"].apply( lambda x: str(x))","1cd4e538":"df = df[~df[\"Invoice\"].str.contains(\"C\", na=False)]\n","9d609b56":"df.head()","a40a5fe0":"df.isnull().sum() \n\n# how many empty elements in variables ?","b3fec7bf":"df.dropna(inplace=True)\n# empty ones blown away","60b28003":"df.isnull().sum() \n\n# now there is no any empty value.\n","e749f396":"df.shape[0]","f43113b5":"df.head()","2f7e4a6f":"df[\"TotalPrice\"] = df[\"Quantity\"] * df[\"Price\"]\n\n# To have monetary metric of RFM, total income has been calculated for one purchase.\n","502c635e":"today_date = dt.datetime(2012, 12, 11)\n\n# To have receny metric of RFM, need information on how long has passed between last order and today date.\n\n# IMPORTANT  \n    # When calculate recency always 2 days should be added. Otherwise when substract last order date from today date result can be minus or zero","f5b27e29":"df.head()","585ca4a7":"rfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda date: (today_date - date.max()).days,\n                                     'Invoice':'count',\n                                     'TotalPrice': 'sum'})\nrfm.head()\n\n## With this code, we'll have three columns dataframe. InvoiceDate (RECENCY), Invoice (FREQUENCY) and totalprice(MONETARY)\n# CustomerID assigned as index.","774da069":"# Another way to get RFM metrics,\n\nrfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda date: (today_date - date.max()).days,\n                                     'Invoice': lambda num: len(num),\n                                     'TotalPrice': lambda TotalPrice: TotalPrice.sum()})","1e573f9c":"# Columns names have been changed to suit with thr RFM metrics\n\nrfm.columns = ['Recency', 'Frequency', 'Monetary']\n","f9db02e4":"# InvoiceDate, Invoice and TotalPrice can't have negative value\n# In case they have negative value, following code should be used\n\nrfm = rfm[(rfm[\"Monetary\"]) > 0 & (rfm[\"Frequency\"] > 0)]","ed57d3b3":"# Checking whether there are ngative values\n\n(rfm < 0).any().sum()","69960f0c":"rfm.head()","a11c1aa5":"# Calculating RFM Scores\n\nrfm[\"recency_score\"] = pd.qcut(rfm['Recency'], 5, labels=[5, 4, 3, 2, 1])\nrfm[\"frequency_score\"] = pd.qcut(rfm[\"Frequency\"].rank(method=\"first\"), 5, labels=[1, 2, 3, 4, 5])","337683b1":"# All scores need to add each other as string so it can be used with regex.\n\nrfm['rfm_segment'] = rfm['recency_score'].astype(str) + rfm['frequency_score'].astype(str)","0519c74d":"rfm.head()","d5e86a2f":"# Assign names (with regex)\n\nseg_map = {\n    r'[1-2][1-2]': 'Hibernating',\n    r'[1-2][3-4]': 'At_Risk',\n    r'[1-2]5': 'Cant_Loose',\n    r'3[1-2]': 'About_to_Sleep',\n    r'33': 'Need_Attention',\n    r'[3-4][4-5]': 'Loyal_Customers',\n    r'41': 'Promising',\n    r'51': 'New_Customers',\n    r'[4-5][2-3]': 'Potential_Loyalists',\n    r'5[4-5]': 'Champions'}\n\nrfm['Segment'] = rfm['rfm_segment'].replace(seg_map, regex=True)\n","b92508ce":"rfm.head()","15480bce":"# To get CLTV value,  number of purchase (invoice), quantity and total price are required.\n\ncltv_df = df.groupby('Customer ID').agg({'Invoice': lambda x: len(x),\n                                         'Quantity': lambda x: x.sum(),\n                                         'TotalPrice': lambda x: x.sum()})\n","b1376110":"# New columns names\n\ncltv_df.columns = ['total_transaction', 'total_unit', 'total_price']","cb6d6666":"cltv_df.head()\n","7890e198":"# 1. Calculate Average Order Value (Total_Revenue \/ Total_Number_of_Orders)\n\ncltv_df['avg_order_value'] = cltv_df['total_price'] \/ cltv_df['total_transaction']\n","90fac5b6":"# 2. Calculate Purchase Frequency\n\ncltv_df[\"purchase_frequency\"] = cltv_df['total_transaction'] \/ cltv_df.shape[0]\n","b3881dae":"# 3. Calculate Repeat Rate and Churn Rate\n\nrepeat_rate = cltv_df[cltv_df.total_transaction > 1].shape[0] \/ cltv_df.shape[0]\nchurn_rate = 1 - repeat_rate","60545508":"# 4. Calculate Profit Margin\n\ncltv_df['profit_margin'] = cltv_df['total_price'] * 0.05\n","83e49a56":"# 5. Calculate Customer Lifetime Value, CLTV \n\ncltv_df['CV'] = (cltv_df['avg_order_value'] * cltv_df[\"purchase_frequency\"]) \/ churn_rate\ncltv_df['CLTV'] = cltv_df['CV'] * cltv_df['profit_margin']","c4404028":"cltv_df.head()","08f57c81":"cltv_df.sort_values(\"CLTV\", ascending=False).head(15)\n","c59ff3c8":"from sklearn.preprocessing import MinMaxScaler\n\n# Optimization\n\nscaler = MinMaxScaler(feature_range=(1, 100))\nscaler.fit(cltv_df[[\"CLTV\"]])\ncltv_df[\"SCALED_CLTV\"] = scaler.transform(cltv_df[[\"CLTV\"]])\n\n# Now it is much easier to evaluate the data  \n","7a4041a4":"# Segmentation\n\ncltv_df[\"segment\"] = pd.qcut(cltv_df[\"SCALED_CLTV\"], 4, labels=[\"D\", \"C\", \"B\", \"A\"])\n\n# scaled_cltv has been split 4 segments","bf9d53f6":"cltv_df.head(10)","5ffe52a1":"# Before created RFM and cltv merged so it is easy to see each customer's relationship with purchase.\n\nrfm_cltv_c = rfm.merge(cltv_df, on = 'Customer ID', how = 'left' )","5cfefbb9":"rfm_cltv_c.drop(['rfm_segment', 'total_transaction'],axis =1, inplace = True)  \n\n# same meaning columns have been removed","b63795a5":"rfm_cltv_c.head()","c03d7208":"pip install Lifetimes==0.11.3","6baf4b24":"import lifetimes \nfrom lifetimes import BetaGeoFitter\nfrom lifetimes import GammaGammaFitter","d650e7b0":"lifetimes.__version__","857590e3":"# RFM table is already created for calculated cltv however predicted cltv needs slightly different RFM table with slighlty different metrics.\n# So, new one (RFM1) has been created with user spesific RECENCY metric.  \n\ndf.dropna(inplace=True)\ndf = df[~df[\"Invoice\"].str.contains(\"C\", na=False)]\ndf = df[df[\"Quantity\"] > 0]\ndf[\"TotalPrice\"] = df[\"Quantity\"] * df[\"Price\"]","0ab1fc2b":"today_date = dt.datetime(2011, 12, 11)","253a64c3":"\nrfm1 = df.groupby('Customer ID').agg({'InvoiceDate': [lambda date: (date.max() - date.min()).days,\n                                                     lambda date: (today_date - date.min()).days],\n                                     'Invoice': 'count',\n                                     'TotalPrice':sum})","74de846e":"rfm1.head()","03db338f":"rfm1.columns = rfm1.columns.droplevel(0)                            # To prevent complicated column name, all column names have been blown out\n\n\nrfm1.columns = ['recency_cltv_p', 'T', 'frequency', 'monetary']     # New column names have been added.\n\nrfm1[\"monetary_avg\"] = rfm1[\"monetary\"] \/ rfm1[\"frequency\"]         # To be able to evaluate outputs with different angles average monetary has been added.    ","47dd0725":"# BG\/NBD works with weekly date info so dates have been converted.\n\nrfm1[\"recency_weekly_p\"] = rfm1[\"recency_cltv_p\"] \/ 7\nrfm1[\"T_weekly\"] = rfm1[\"T\"] \/ 7","a9fe3dd6":"rfm1.head()","7b86f78a":"# Elimination of negative values\n\nrfm1 = rfm1[rfm1[\"monetary_avg\"] > 0]\nrfm1 = rfm1[rfm1[\"recency_weekly_p\"] > 0]\nrfm1 = rfm1[rfm1[\"T_weekly\"] > 0]\nrfm1 = rfm1[rfm1[\"T\"] > 0]\nrfm1 = rfm1[(rfm1['frequency'] > 1)]\n\nrfm1[\"frequency\"] = rfm1[\"frequency\"].astype(int)    # BG\/NBD and GAMA GAMA models JUST accept integer","fd973700":"rfm1.head()","d76d2aa3":"bgf = BetaGeoFitter(penalizer_coef=0.001)\n\nbgf.fit(rfm1['frequency'],\n        rfm1['recency_weekly_p'],\n        rfm1['T_weekly'])","16917386":"rfm1.head()","367e8152":"# Expected number of purchases for 4 WEEK\n\n\nbgf.conditional_expected_number_of_purchases_up_to_time(4,\n                                                        rfm1['frequency'],\n                                                        rfm1['recency_weekly_p'],\n                                                        rfm1['T_weekly']).sort_values(ascending=False).head(10)\n","68241e9c":"# Expected number of purchases for 1 month (4 weeks)\n\n\nrfm1[\"expected_number_of_purchases_1months\"] = bgf.predict(4,\n                                                  rfm1['frequency'],\n                                                  rfm1['recency_weekly_p'],\n                                                  rfm1['T_weekly'])\n","4ffdab4b":"ggf = GammaGammaFitter(penalizer_coef=0.01)\nggf.fit(rfm1['frequency'], rfm1['monetary_avg'])","c68fba81":"\nggf.conditional_expected_average_profit(rfm1['frequency'],\n                                        rfm1['monetary_avg']).sort_values(ascending=False).head(10)\n\nrfm1[\"expected_average_profit\"] = ggf.conditional_expected_average_profit(rfm1['frequency'],\n                                                                         rfm1['monetary_avg'])","5ef2ca25":"rfm1.head()","9c2518f7":"\ncltv_p_6months = ggf.customer_lifetime_value(bgf,\n                                   rfm1['frequency'],\n                                   rfm1['recency_weekly_p'],\n                                   rfm1['T_weekly'],\n                                   rfm1['monetary_avg'],\n                                       time=6,       # for 6 months\n                                       freq=\"W\",     # Frequency info for T_weekly \n                                   discount_rate=0.01)\n","d1ab9999":"cltv_p_6months = cltv_p_6months.reset_index()","e5d88e33":"cltv_p_6months.head()","e5ab4f03":"cltv_p_6months.rename(columns = {'clv':'clv_p_6months'}, inplace =True)","ca9b0f97":"cltv_p_6months.head()","945574ed":"rfm1.head()","eb6ed223":"rfm_cltv_p = rfm1.merge(cltv_p_6months, on=\"Customer ID\", how=\"left\")\nrfm_cltv_p.head()","221dded1":"rfm_cltv_c.head()","d80d7d81":"crm_final = rfm_cltv_c.merge(rfm_cltv_p, on=\"Customer ID\", how=\"left\")\ncrm_final.head()","acdc2a5e":"crm_final.drop(['total_price', 'frequency'], axis = 1, inplace = True)","c66ec4ce":"crm_final.sort_values('clv_p_6months', ascending  = False).head()","06ed5bb5":" <a id = '9' ><\/a>\n\n# GAMA GAMA\n    # Recency and Monetary values are required.\n    \n    # Calculates Expected profit.\n    ","0a88fe2e":"* BG\/NBD and GAMA GAMA MODELS will use.\n* For frequencey vales , these models don't accept float, should be integer","70f6f2ad":"# INTRODUCTION\nAn e-commerce company wants to segment its customers and determine marketing strategies according to these segments.  \nApply RFM analysis to the sheet named \"Year 2010-2011\" of the online_retail_II.xlsx data set.\n\n\n## Project Goal:\n Select the customer IDs belonging to the Loyal Customers class, calculate cltv value\n\n\n\n## We will follow the steps below:\n\n1. [UNDERSTANDING DATA](#1):\n2. [PREPARING DATA](#2):\n3. [CALCULATING RFM METRICS](#3):\n4. [CALCULATING RFM SCORES and NAMING ](#4):\n5. [CUSTOMER LIFE TIME VALUE (CLTV)](#5):\n    1. [CALCULATED CUSTOMER LIFE TIME VALUE](#6)\n    2. [PREDICTED CUSTOMER LIFE TIME VALUE](#7)\n        1. [BG\/NBD](#8)\n        2. [GAMA GAMA](#9)\n6.[FINAL CUSTOMER RELATIONSHIP MANAGEMENT (RFM + CLTV)](#10)       ","e3fb89b4":"### Recency, frequency, monetary.\n\n![Incontent_image.png](attachment:3636243b-e558-4c03-aff0-f6f78b33e271.png)","a6dbf147":" <a id = '10' ><\/a>\n\n## FINAL CUSTOMER RELATIONSHIP MANAGEMENT (RFM + CLTV)\n\nRfm, calculated and predicted cltv we already obtained now will be gathered under the one single table.","5ed3b712":"## Variables\n* InvoiceNo: Unique number for each order\n        * If it starts with 'C' which means it has been cancelled\n* StockCode: Unique number for each order\n* Description: Name of the product sold\n* Quantity: Number of products\n* InvoiceDate: Date of invoice\n* UnitPrice: Price (Pound)\n* CustomerID: Unique customer number\n* Country: Country of order\n","7b31af84":" <a id = '8' ><\/a>\n\n# BG\/NBD \n    # Recency and frequency values are required.\n    \n    # BG\/NBD Calculates Expected Number of Purchases.\n    ","e22bd91c":"<a id = '4' ><\/a>\n\n# CALCULATING RFM SCORES and NAMING\n","4571b766":"### Calculation Predicted CLTV with BG\/NDD and GAMA GAMA\n\nBgf and ggf should be used together for predicted cltv. ","f911d048":"![rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr.jpg](attachment:ee074a33-c952-45cb-978e-724eadffb947.jpg)","36d6b389":"<a id = '2' ><\/a>\n\n# PREPARING DATA","e0c62baf":"<a id = '3' ><\/a>\n\n# Calculating RFM Metrics","434657ff":"<a id = '6' ><\/a>\n\n#### A. CALCULATED CUSTOMER LIFE TIME VALUE\n","c7aa60fe":"<a id = '1' ><\/a>\n\n# UNDERSTANDING DATA:","0aaf93a7":"![0_JJBP4ToZiaw0HVPN.png](attachment:14b6cf74-60c3-405c-b680-161e699e09ad.png)","7f2fb74d":" <a id = '7' ><\/a>\n\n #### B. PREDICTED CUSTOMER LIFE TIME VALUE","8fa1325c":"#### CLTV = (Customer_Value \/ Churn_Rate) x Profit_margin.\n\n\n##### Customer_Value = Average_Order_Value * Purchase_Frequency \n\n##### Average_Order_Value = Total_Revenue \/ Total_Number_of_Orders\n\n##### Purchase_Frequency =  Total_Number_of_Orders \/ Total_Number_of_Customers\n\n##### Churn_Rate = 1 - Repeat_Rate\n\n##### Profit_margin = Profit margin for each customer\n","e8012d21":"<a id = '5' ><\/a>\n# CUSTOMER LIFE TIME VALUE (CLTV)\n\nCustomer lifetime value is the total amount a customer will spend from acquisition through the end of the relationship with a business.\n### A. CALCULATED CUSTOMER LIFE TIME VALUE\n\n### B. PREDICTED CUSTOMER LIFE TIME VALUE"}}