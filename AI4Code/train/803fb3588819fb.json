{"cell_type":{"7f59458d":"code","bded6781":"code","af4bf01d":"code","6ce5b2f0":"code","0d0ab636":"code","95df15cb":"code","e2a95e62":"code","d03b8f6c":"code","d5c88d66":"code","d0748052":"code","55783719":"code","2af010de":"code","d3c8cdb2":"code","00fa2956":"code","fc1e7ecc":"markdown","46e87ce6":"markdown","3234688c":"markdown","1572b877":"markdown","27177f8c":"markdown","c5ad9ac9":"markdown"},"source":{"7f59458d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom PIL import Image\nimport os\nfrom sklearn.model_selection import train_test_split\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.layers import Dense, Dropout, MaxPool2D, Conv2D, Flatten\nfrom tensorflow.keras import Sequential\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","bded6781":"def get_image(image_path):\n    \"\"\"\n    This function takes the address of the image as input and returns the pixesl values of the image\n    \"\"\"\n    image = Image.open(image_path, \"r\").convert('RGB')\n    image = image.resize((300 ,300))\n    width, height = image.size\n    pixel_values = list(image.getdata())\n    if image.mode == \"RGB\":\n        channels = 3\n    elif image.mode == \"L\":\n        channels = 1\n    else:\n        print(\"Unknown mode: %s\" % image.mode)\n        return None\n    pixel_values = np.array(pixel_values).reshape((height, width, channels))\n    return pixel_values","af4bf01d":"# Here we are passing every image address to the function to generate pixels\n\na=[]\nb=[]\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        s = str(os.path.join(dirname, filename))\n        img = get_image(s)\n        a.append(img)\n        b.append(0 if dirname.split('\/')[-1]=='no' else 1)","6ce5b2f0":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        s = str(os.path.join(dirname, filename))\n        print(dirname.split('\/')[-1])\n        img = get_image(s)\n        plt.imshow(img)\n        plt.show()\n        break","0d0ab636":"# Converting the lists to numpy arrays\na = np.array(a, dtype='float32')\nb = np.array(b)","95df15cb":"X = a\ny = b\n\n# Normalizing pixal values so that the pixels will be in the range of [0, 1]\nX\/=255","e2a95e62":"# Creating a Sequential model with 2 Con2D and MaxPool2d Layers\n\nmodel = Sequential()\nmodel.add(Conv2D(64, (3, 3), activation='relu', input_shape=X[0].shape))\nmodel.add(MaxPool2D((3,3)))\nmodel.add(Conv2D(32, (3, 3), activation='relu', input_shape=X[0].shape))\nmodel.add(MaxPool2D((3,3)))\nmodel.add(Flatten(input_shape = X[0].shape))\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))","d03b8f6c":"model.summary()","d5c88d66":"model.compile(loss=tf.keras.losses.binary_crossentropy, optimizer='adam', metrics=['accuracy'])","d0748052":"history = model.fit(X, y, validation_split=0.25, epochs=20, batch_size=32)","55783719":"# Summarize history for accuracy\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()\n# summarize history for loss\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","2af010de":"test = []\ntest.append(X[100])\ntest = np.array(test)\nround(model.predict(test)[0][0])","d3c8cdb2":"plt.imshow(X[100])\nplt.show()","00fa2956":"y[100]","fc1e7ecc":"### Few Images of Xrays","46e87ce6":"### Tesing With a Random Sample","3234688c":"### Few Images of Xrays","1572b877":"### Converting Images to pixels","27177f8c":"##### So this is our Brain Tumer Prediction with 100% accuracy using deep learning and convolutions.","c5ad9ac9":"# Brain Tumer Image Classification\n\nGoal of this project is classifying the X-ray images and predicting the precense of brain tumer"}}