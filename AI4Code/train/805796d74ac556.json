{"cell_type":{"a4cf0bef":"code","033490a3":"code","4684b549":"code","2950d12e":"code","af2f0a6c":"code","1ad4c2cd":"code","9a4a5960":"code","056f5be5":"code","11d71e52":"code","fac3dfee":"code","a4817c5f":"code","5fd1e06b":"code","967b1ed9":"code","bfd44ac0":"code","4995f5eb":"code","b0e0d664":"code","2960ad4b":"code","093ef5b2":"code","d39c4ad7":"code","19ad6b5e":"code","9b118c4a":"code","7c7aaed1":"markdown","255dad7d":"markdown","461064a6":"markdown","1643a8d9":"markdown","15217eb9":"markdown","aa1ba1d5":"markdown","b0594302":"markdown","bd26ecfd":"markdown","4f2e2787":"markdown","d41362cd":"markdown","0048c92b":"markdown"},"source":{"a4cf0bef":"import glob\nfrom skimage import measure\n","033490a3":"%matplotlib inline\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pydicom\nimport os\nimport scipy.ndimage\nimport matplotlib.pyplot as plt\n\nfrom skimage import measure, morphology\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection","4684b549":"train = pd.read_csv('..\/input\/osic-pulmonary-fibrosis-progression\/train.csv')\ntest = pd.read_csv('..\/input\/osic-pulmonary-fibrosis-progression\/test.csv')\nsubmission = pd.read_csv('..\/input\/osic-pulmonary-fibrosis-progression\/sample_submission.csv')","2950d12e":"def myfunc(e):\n    return e[-6:] ","af2f0a6c":"patient_list = train.Patient.unique()\ndata_path = '..\/input\/osic-pulmonary-fibrosis-progression\/train\/'\n\npatient = pd.DataFrame()\npid = []\ncount = []\npath = []\nfor pat in patient_list:\n    \n    data_list = glob.glob(data_path + pat + '\/*.dcm')\n    data_list.sort(key=myfunc)\n    pid.append(pat)\n    path.append(data_list)\n    count.append(len(data_list))\n    \npatient['pid']=pid\npatient['path']= path\npatient['count']=count","1ad4c2cd":"patient.head()","9a4a5960":"patient.path[0]","056f5be5":"slices = [pydicom.read_file(s) for s in patient.path[0]] #lets read metadeta of pydiacom file\nprint('The total no of ct scan associated with 1st patient',len(slices))\nprint(slices[3])","11d71e52":"slices.sort(key = lambda x: int(x.InstanceNumber)) # order the slice serially\n","fac3dfee":"slice_thickness = np.abs(slices[0].ImagePositionPatient[2] - slices[1].ImagePositionPatient[2])\nprint(slice_thickness)","a4817c5f":"#lets create a function for above task\ndef load_scan(path):\n    slices = [pydicom.read_file(path +'\/'+ s) for s in os.listdir(path)]\n    slices.sort(key = lambda x: int(x.InstanceNumber))\n    try:\n        slice_thickness = np.abs(slices[0].ImagePositionPatient[2] - slices[1].ImagePositionPatient[2])\n    except:\n        slice_thickness = np.abs(slices[0].SliceLocation - slices[1].SliceLocation)\n        \n    for s in slices:\n        s.SliceThickness = slice_thickness\n        \n    return slices \n","5fd1e06b":"def get_pixels_hu(slices):\n    image = np.stack([s.pixel_array for s in slices])\n    # Convert to int16 (from sometimes int16), \n    # should be possible as values should always be low enough (<32k)\n    image = image.astype(np.int16)\n\n    # Set outside-of-scan pixels to 0\n    # The intercept is usually -1024, so air is approximately 0\n    image[image == -2000] = 0\n    \n    # Convert to Hounsfield units (HU)\n    for slice_number in range(len(slices)):\n        \n        intercept = slices[slice_number].RescaleIntercept\n        slope = slices[slice_number].RescaleSlope\n        \n        if slope != 1:\n            image[slice_number] = slope * image[slice_number].astype(np.float64)\n            image[slice_number] = image[slice_number].astype(np.int16)\n            \n        image[slice_number] += np.int16(intercept)\n    \n    return np.array(image, dtype=np.int16)\n","967b1ed9":"#lets take alook at patient\npatient = load_scan('..\/input\/osic-pulmonary-fibrosis-progression\/train\/ID00007637202177411956430')\nimgs = get_pixels_hu(patient)\nplt.hist(imgs.flatten(), bins=80, color='c')\nplt.xlabel(\"Hounsfield Units (HU)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n\n\nplt.imshow(imgs[29], cmap=plt.cm.gray)\nplt.show()\n","bfd44ac0":"print(\"Slice Thickness: %f\" % patient[0].SliceThickness)\nprint(\"Pixel Spacing (row, col): (%f, %f) \"% (patient[0].PixelSpacing[0], patient[0].PixelSpacing[1]))","4995f5eb":"def resample(image, scan, new_spacing=[1,1,1]):\n    # Determine current pixel spacing\n    spacing = map(float, ([scan[0].SliceThickness] + list(scan[0].PixelSpacing)))\n    spacing = np.array(list(spacing))\n    \n    resize_factor = spacing \/ new_spacing\n    new_real_shape = image.shape * resize_factor\n    new_shape = np.round(new_real_shape)\n    real_resize_factor = new_shape \/ image.shape\n    new_spacing = spacing \/ real_resize_factor\n    \n    image = scipy.ndimage.interpolation.zoom(image, real_resize_factor, mode='nearest')\n    \n    return image, new_spacing","b0e0d664":"pix_resampled, spacing = resample(imgs, patient, [1,1,1])\nprint(\"Shape before resampling\\t\", imgs.shape)\nprint(\"Shape after resampling\\t\", pix_resampled.shape)","2960ad4b":"plt.hist(pix_resampled.flatten(), bins=80, color='c')\nplt.xlabel(\"Hounsfield Units (HU)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n\n\nplt.imshow(imgs[29], cmap=plt.cm.gray)\nplt.show()","093ef5b2":"def plot_3d(image, threshold=-300):\n    \n    # Position the scan upright, \n    # so the head of the patient would be at the top facing the camera\n    \n    p = image.transpose(2,1,0) #get image in order(h,w,c)\n    \n    verts, faces = measure.marching_cubes_classic(p, threshold)\n\n    fig = plt.figure(figsize=(10, 10))\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Fancy indexing: `verts[faces]` to generate a collection of triangles\n    mesh = Poly3DCollection(verts[faces], alpha=0.70)\n    face_color = [0.45, 0.45, 0.75]\n    mesh.set_facecolor(face_color)\n    ax.add_collection3d(mesh)\n\n    ax.set_xlim(0, p.shape[0])\n    ax.set_ylim(0, p.shape[1])\n    ax.set_zlim(0, p.shape[2])\n\n    plt.show()","d39c4ad7":"plot_3d(pix_resampled, 400)\n","19ad6b5e":"MIN_BOUND = -1000.0\nMAX_BOUND = 400.0\n    \ndef normalize(image):\n    image = (image - MIN_BOUND) \/ (MAX_BOUND - MIN_BOUND)\n    image[image>1] = 1.\n    image[image<0] = 0.\n    return image","9b118c4a":"PIXEL_MEAN = 0.25\n\ndef zero_center(image):\n    image = image - PIXEL_MEAN\n    return image","7c7aaed1":"The unit of measurement in CT scans is the Hounsfield Unit (HU), which is a measure of radiodensity. CT scanners are carefully calibrated to accurately measure this. From Wikipedia:\n\n![4rlyReh.png](attachment:4rlyReh.png)\n\nBy default however, the returned values are not in this unit. Let's fix this.\n\nSome scanners have cylindrical scanning bounds, but the output image is square. The pixels that fall outside of these bounds get the fixed value -2000. The first step is setting these values to 0, which currently corresponds to air. Next, let's go back to HU units, by multiplying with the rescale slope and adding the intercept (which are conveniently stored in the metadata of the scans!).","255dad7d":"With these steps your images are ready for consumption by your CNN or other ML method ","461064a6":"ACKNOWLEDGEMENT\n* https:\/\/www.kaggle.com\/gzuidhof\/full-preprocessing-tutorial\n* https:\/\/www.raddq.com\/dicom-processing-segmentation-visualization-in-python\/\n","1643a8d9":"Slice Thickness is a parameter that can be selected by the technologist.  This will change the thickness of our slice in millimeters.  By increasing the slice thickness, many more different types of tissues will be collected in our 2D slice.  This can cause blurring in our image also known as partial voluming.\nPicture\nCoverage\n\nBy increasing the slice thickness we will increase our coverage. \n![1.jpg](attachment:1.jpg)","15217eb9":"# Normalization\n\nOur values currently range from -1024 to around 2000. Anything above 400 is not interesting to us, as these are simply bones with different radiodensity. A commonly used set of thresholds in the LUNA16 competition to normalize between are -1000 and 400. Here's some code you can use:","aa1ba1d5":"Although we have each individual slices, it is not immediately clear how thick each slice is.\n\nSlice Thickness: 10.000000\nPixel Spacing (row, col): (0.652344, 0.652344) \nThis means we have 10.00 mm slices, and each voxel represents 0.652344 mm.\n\nBecause a CT slice is typically reconstructed at 512 x 512 voxels, each slice represents approximately 370 mm of data in length and width.\n\nUsing the metadata from the DICOM we can figure out the size of each voxel as the slice thickness. In order to display the CT in 3D isometric form (which we will do below), and also to compare between different scans, it would be useful to ensure that each slice is resampled in 1x1x1 mm pixels and slices.","b0594302":"   \n# 3D Plotting","bd26ecfd":"# Zero centering\n\nAs a final preprocessing step, it is advisory to zero center your data so that your mean value is 0. To do this you simply subtract the mean pixel value from all pixels.\n\nTo determine this mean you simply average all images in the whole dataset. If that sounds like a lot of work, we found this to be around 0.25 in the LUNA16 competition.\n\nWarning: Do not zero center with the mean per image (like is done in some kernels on here). The CT scanners are calibrated to return accurate HU measurements. There is no such thing as an image with lower contrast or brightness like in normal pictures.","4f2e2787":"Loading the files\n\n\nDicom is the de-facto file standard in medical imaging.  These files contain a lot of metadata (such as the pixel size, so how long one pixel is in every dimension in the real world).\n\nThis pixel size\/coarseness of the scan differs from scan to scan (e.g. the distance between slices may differ), which can hurt performance of CNN approaches. We can deal with this by isomorphic resampling, which we will do later.\n","d41362cd":"In this notebook, we learn\n\n* Loading DICOM data using pydicom\n\n* Used 1D (histogram), 2D, and 3D plots to display DICOM images.\n* Pre-processed data for future machine learning projects\n* Conversion of pixel value to Hundsfeld units\n* Resampling for isotropy\n* normalization\n* zero centering","0048c92b":"# Resampling\n\nA scan may have a pixel spacing of [2.5, 0.5, 0.5], which means that the distance between slices is 2.5 millimeters. For a different scan this may be [1.5, 0.725, 0.725], this can be problematic for automatic analysis (e.g. using ConvNets)!\n\nA common method of dealing with this is resampling the full dataset to a certain isotropic resolution. If we choose to resample everything to 1mm1mm1mm pixels we can use 3D convnets without worrying about learning zoom\/slice thickness invariance.\n\nWhilst this may seem like a very simple step, it has quite some edge cases due to rounding. Also, it takes quite a while.\n\nBelow code worked well for us (and deals with the edge cases):"}}