{"cell_type":{"cbe866d3":"code","388c6fe7":"code","76be8b91":"code","8a2182fc":"code","3162db99":"code","ae306ace":"code","2b3fc395":"code","7db1cb55":"code","e69919d9":"code","23cd42a9":"code","df06d892":"code","901f31a9":"code","77a8319e":"code","3b5c1e4e":"code","c8919a9b":"code","d1f4e8ad":"code","631a95c4":"code","680063ac":"code","25fc2c06":"code","09b13595":"code","78f055e6":"code","1366beb7":"code","7542eb14":"code","f2dd4cde":"code","72f1655b":"code","9b769913":"code","c1b42e22":"markdown","14df97e5":"markdown","33b877ed":"markdown","cb198e21":"markdown","0fe80853":"markdown","177f2588":"markdown","bb2f43c9":"markdown","23f5c0ad":"markdown","cc6ace5b":"markdown","a791a535":"markdown","411b43f4":"markdown","c5d4bad2":"markdown"},"source":{"cbe866d3":"import numpy as np\nimport pandas as pd\nimport torch\nimport os\nimport matplotlib.pyplot as plt\nimport torch.nn.functional as F \nfrom torch import nn,optim\nfrom torchvision import transforms as T,datasets,models\nfrom torchvision.utils import make_grid\nfrom torch.utils.data import DataLoader\nfrom collections import OrderedDict\nfrom tqdm import tqdm\npd.options.plotting.backend = \"plotly\"","388c6fe7":"data_dir = \"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\"\nTEST = 'test'\nTRAIN = 'train'\nVAL ='val'","76be8b91":"def data_transforms(phase = None):\n    \n    if phase == TRAIN:\n\n        data_T = T.Compose([\n            \n                T.Resize(size = (256,256)),\n                T.RandomRotation(degrees = (-20,+20)),\n                T.CenterCrop(size=224),\n                T.ToTensor(),\n                T.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])\n        ])\n    \n    elif phase == TEST or phase == VAL:\n\n        data_T = T.Compose([\n\n                T.Resize(size = (224,224)),\n                T.ToTensor(),\n                T.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])\n        ])\n        \n    return data_T","8a2182fc":"trainset = datasets.ImageFolder(os.path.join(data_dir, TRAIN),transform = data_transforms(TRAIN))\ntestset = datasets.ImageFolder(os.path.join(data_dir, TEST),transform = data_transforms(TEST))\nvalidset = datasets.ImageFolder(os.path.join(data_dir, VAL),transform = data_transforms(VAL))","3162db99":"class_names = trainset.classes\nprint(class_names)\nprint(trainset.class_to_idx)","ae306ace":"def plot_class_count(classes,name = None):\n    pd.DataFrame(classes,columns = [name]).groupby([classes]).size().plot(kind = 'bar',title = name).show()","2b3fc395":"def get_class_count(dataset,name = None):\n    classes = []\n    for _,label in dataset:\n        if label == 0:\n            classes.append(class_names[label])\n            \n        elif label == 1:\n            classes.append(class_names[label])\n            \n    return classes","7db1cb55":"trainset_class_count = get_class_count(trainset,name = 'trainset_classes_count')\nplot_class_count(trainset_class_count,name = 'trainset_classes_count')","e69919d9":"testset_class_count = get_class_count(testset,name = 'testset_classes_count')\nplot_class_count(testset_class_count,name = 'testset_classes_count')","23cd42a9":"validset_class_count = get_class_count(validset,name = 'validset_classes_count')\nplot_class_count(validset_class_count,name = 'validset_classes_count')","df06d892":"trainloader = DataLoader(trainset,batch_size = 16,shuffle = True)\nvalidloader = DataLoader(validset,batch_size = 8,shuffle = True)\ntestloader = DataLoader(testset,batch_size = 8,shuffle = True)","901f31a9":"def show_image(image,title = None,get_denormalize = False):\n    \n    image = image.permute(1,2,0)\n    mean = torch.FloatTensor([0.485, 0.456, 0.406])\n    std = torch.FloatTensor([0.229, 0.224, 0.225])\n    \n    image = image*std + mean\n    image = np.clip(image,0,1)\n    \n    if get_denormalize == False:\n        plt.figure(figsize=[15, 15])\n        plt.imshow(image)\n\n        if title != None:\n            plt.title(title)\n            \n    else : \n        return image","77a8319e":"dataiter = iter(trainloader)\nimages,labels = dataiter.next()\n\nout = make_grid(images,nrow=4)\n\nshow_image(out, title=[class_names[x] for x in labels])","3b5c1e4e":"device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\ndevice","c8919a9b":"model = models.vgg16()\nmodel.load_state_dict(torch.load(\"..\/input\/pretrained-model-weights-pytorch\/vgg16-397923af.pth\"))","d1f4e8ad":"for param in model.parameters():\n    param.requires_grad = False\n\n\n\n\nclassifier = nn.Sequential(OrderedDict([('fc1', nn.Linear(25088, 4096)),\n                                         ('relu', nn.ReLU()),\n                                         ('dropout',nn.Dropout(0.3)),\n                                         ('fc2', nn.Linear(4096, 4096)),\n                                         ('relu', nn.ReLU()),\n                                         ('drop', nn.Dropout(0.3)),\n                                         ('fc3', nn.Linear(4096, 2)), \n                                         ('output', nn.LogSoftmax(dim = 1))]))\n\nmodel.classifier = classifier\nmodel.to(device)","631a95c4":"criterion = nn.NLLLoss()\noptimizer = optim.Adam(model.parameters(),lr = 0.001)\nschedular = optim.lr_scheduler.ReduceLROnPlateau(optimizer,factor = 0.1,patience = 5)\nepochs = 15\nvalid_loss_min = np.Inf","680063ac":"def accuracy(y_pred,y_true):\n    y_pred = torch.exp(y_pred)\n    top_p,top_class = y_pred.topk(1,dim = 1)\n    equals = top_class == y_true.view(*top_class.shape)\n    return torch.mean(equals.type(torch.FloatTensor))","25fc2c06":"for i in range(epochs):\n    \n    train_loss = 0.0\n    valid_loss = 0.0\n    train_acc = 0.0\n    valid_acc = 0.0 \n    \n    \n    model.train()\n    \n    for images,labels in tqdm(trainloader):\n        \n        images = images.to(device)\n        labels = labels.to(device)\n        \n        ps = model(images)\n        loss = criterion(ps,labels)\n        \n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        \n        train_acc += accuracy(ps,labels)\n        train_loss += loss.item()\n        \n    avg_train_acc = train_acc \/ len(trainloader)\n    avg_train_loss = train_loss \/ len(trainloader)\n        \n    model.eval()\n    with torch.no_grad():\n        \n        for images,labels in tqdm(validloader):\n            \n            images = images.to(device)\n            labels = labels.to(device)\n            \n            ps = model(images)\n            loss = criterion(ps,labels)\n            \n            valid_acc += accuracy(ps,labels)\n            valid_loss += loss.item()\n            \n            \n        avg_valid_acc = valid_acc \/ len(validloader)\n        avg_valid_loss = valid_loss \/ len(validloader)\n        \n        schedular.step(avg_valid_loss)\n        \n        if avg_valid_loss <= valid_loss_min:\n            print('Validation loss decreased ({:.6f} --> {:.6f}).   Saving model ...'.format(valid_loss_min,avg_valid_loss))\n            torch.save({\n                'epoch' : i,\n                'model_state_dict' : model.state_dict(),\n                'optimizer_state_dict' : optimizer.state_dict(),\n                'valid_loss_min' : avg_valid_loss\n            },'Pneumonia_model.pt')\n            \n            valid_loss_min = avg_valid_loss\n            \n            \n    print(\"Epoch : {} Train Loss : {:.6f} Train Acc : {:.6f}\".format(i+1,avg_train_loss,avg_train_acc))\n    print(\"Epoch : {} Valid Loss : {:.6f} Valid Acc : {:.6f}\".format(i+1,avg_valid_loss,avg_valid_acc))","09b13595":"model.eval()\n\ntest_loss = 0\ntest_acc = 0\n\nfor images,labels in testloader:\n    \n    images = images.to(device)\n    labels = labels.to(device)\n    \n    pred = model(images)\n    loss = criterion(pred,labels)\n    \n    test_loss += loss.item()\n    test_acc += accuracy(pred,labels)\n    \navg_test_loss = test_loss\/len(testloader)\navg_test_acc = test_acc\/len(testloader)\n\nprint(\"Test Loss : {:.6f} Test Acc : {:.6f}\".format(avg_test_loss,avg_test_acc))","78f055e6":"def view_classify(img,ps,label):\n    \n    class_name = ['NORMAL', 'PNEUMONIA']\n    classes = np.array(class_name)\n\n    ps = ps.cpu().data.numpy().squeeze()\n    img = show_image(img,get_denormalize = True)\n    \n    \n\n    fig, (ax1, ax2) = plt.subplots(figsize=(8,12), ncols=2)\n    ax1.imshow(img)\n    ax1.set_title('Ground Truth : {}'.format(class_name[label]))\n    ax1.axis('off')\n    ax2.barh(classes, ps)\n    ax2.set_aspect(0.1)\n    ax2.set_yticks(classes)\n    ax2.set_yticklabels(classes)\n    ax2.set_title('Predicted Class')\n    ax2.set_xlim(0, 1.1)\n\n    plt.tight_layout()\n\n    return None","1366beb7":"image,label = testset[0]\n\nps = torch.exp(model(image.to(device).unsqueeze(0)))\nview_classify(image,ps,label)","7542eb14":"image,label = testset[36]\n\nps = torch.exp(model(image.to(device).unsqueeze(0)))\nview_classify(image,ps,label)","f2dd4cde":"image,label = testset[330]\n\nps = torch.exp(model(image.to(device).unsqueeze(0)))\nview_classify(image,ps,label)","72f1655b":"image,label = testset[49]\n\nps = torch.exp(model(image.to(device).unsqueeze(0)))\nview_classify(image,ps,label)","9b769913":"image,label = testset[56]\n\nps = torch.exp(model(image.to(device).unsqueeze(0)))\nview_classify(image,ps,label)","c1b42e22":"By the end of this notebook, you will be able to classify Chext X-Ray Images(diseases like Pnuemonia). You are going to create model which classify pneumonia or normal class.\n\nWe will see how to :\n\n- Load dataset and apply transforms(for Data Augmentation)\n- Class Count Plots\n- Load Dataset into batches \n- Plot Images \n- Fine-Tuning VGG-16 Model\n- Train Model\n- Testset Results\n- Actual vs Predicted Plotting ","14df97e5":"# Chest X-Ray Images (Pneumonia)\n\n","33b877ed":"# Testset Results","cb198e21":"# Plot Images","0fe80853":"## Fine-Tuning VGG-16","177f2588":"# Loading Dataset and Applying Transforms","bb2f43c9":"# Training Model","23f5c0ad":"# Class Count Plot","cc6ace5b":"## Hi, Welcome to my kernel ","a791a535":"# Loading Dataset into batches","411b43f4":"# Finally, *UPVOTE* this kernel if you found it useful, feel free in comments.","c5d4bad2":"# Actual vs Predicted Plotting "}}