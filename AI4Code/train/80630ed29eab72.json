{"cell_type":{"fb698d73":"code","ba8d7330":"code","0fe256ec":"code","c1a455d4":"code","8ae6f92c":"code","8c5e2d97":"code","b4a62a13":"code","c44c084a":"code","7207f9c8":"code","d902d1a7":"code","61d8f1aa":"code","4368aa0c":"code","aa31a0be":"code","02283aaf":"code","d657112f":"code","e921080d":"code","dc66cde6":"code","b4e936c6":"code","a3b356aa":"code","46c98161":"code","a5ad6895":"code","397df402":"code","e18e0a99":"code","016c7816":"markdown","c9d73d0c":"markdown"},"source":{"fb698d73":"import os, cv2, re, random\nimport numpy as np\nimport pandas as pd\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.preprocessing.image import img_to_array, load_img\nfrom keras import layers, models, optimizers\nfrom keras import backend as K\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\nimport itertools\n\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport seaborn as sns\n%matplotlib inline","ba8d7330":"img_width = 150\nimg_height = 150\nTRAIN_DIR = '..\/input\/train\/'\nTEST_DIR = '..\/input\/test\/'\ntrain_images_dogs_cats = [TRAIN_DIR+i for i in os.listdir(TRAIN_DIR)] # use this for full dataset\ntest_images_dogs_cats = [TEST_DIR+i for i in os.listdir(TEST_DIR)]","0fe256ec":"print(len(train_images_dogs_cats))\nprint(len(test_images_dogs_cats))","c1a455d4":"def atoi(text):\n    return int(text) if text.isdigit() else text\n\ndef natural_keys(text):\n    return [ atoi(c) for c in re.split('(\\d+)', text) ]","8ae6f92c":"train_images_dogs_cats.sort(key=natural_keys)\ntrain_images_dogs_cats_trim = train_images_dogs_cats[0:1300]\ntrain_images_dogs_cats_trim += train_images_dogs_cats[12500:13800] \n\ntest_images_dogs_cats.sort(key=natural_keys)","8c5e2d97":"print(len(train_images_dogs_cats_trim))","b4a62a13":"def prepare_data(list_of_images):\n    \"\"\"\n    Returns two arrays: \n        x is an array of resized images\n        y is an array of labels\n    \"\"\"\n    x = [] # images as arrays\n    y = [] # labels\n    \n    for image in list_of_images:\n        x.append(cv2.resize(cv2.imread(image), (img_width,img_height), interpolation=cv2.INTER_CUBIC))\n    \n    for i in list_of_images:\n        if 'dog' in i:\n            y.append(1)\n        elif 'cat' in i:\n            y.append(0)\n        #else:\n            #print('neither cat nor dog name present in images')\n            \n    return x, y","c44c084a":"X, Y = prepare_data(train_images_dogs_cats_trim)\n\n# First split the data in two sets, 80% for training, 20% for Val\/Test)\nX_train, X_val, Y_train, Y_val = train_test_split(X,Y, test_size=0.2, random_state=1)","7207f9c8":"nb_train_samples = len(X_train)\nnb_validation_samples = len(X_val)\nbatch_size = 16","d902d1a7":"model = models.Sequential()\n\nmodel.add(layers.Conv2D(32, (3, 3), input_shape=(img_width, img_height, 3)))\nmodel.add(layers.Activation('relu'))\nmodel.add(layers.MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(layers.Conv2D(32, (3, 3)))\nmodel.add(layers.Activation('relu'))\nmodel.add(layers.MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(layers.Conv2D(64, (3, 3)))\nmodel.add(layers.Activation('relu'))\nmodel.add(layers.MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(64))\nmodel.add(layers.Activation('relu'))\nmodel.add(layers.Dropout(0.5))\nmodel.add(layers.Dense(1))\nmodel.add(layers.Activation('sigmoid'))","61d8f1aa":"model.compile(loss='binary_crossentropy',\n              optimizer='rmsprop',\n              metrics=['accuracy'])\n\nmodel.summary()","4368aa0c":"train_datagen = ImageDataGenerator(\n    rescale=1. \/ 255,\n    shear_range=0.2,\n    zoom_range=0.2,\n    horizontal_flip=True)\n\nval_datagen = ImageDataGenerator(\n    rescale=1. \/ 255,\n    shear_range=0.2,\n    zoom_range=0.2,\n    horizontal_flip=True)","aa31a0be":"train_generator = train_datagen.flow(np.array(X_train), Y_train, batch_size=batch_size)\nvalidation_generator = val_datagen.flow(np.array(X_val), Y_val, batch_size=batch_size)","02283aaf":"visualize_acc_loss = model.fit_generator(\n    train_generator, \n    steps_per_epoch=nb_train_samples \/\/ batch_size,\n    epochs=40,\n    validation_data=validation_generator,\n    validation_steps=nb_validation_samples \/\/ batch_size\n)","d657112f":"# Plot the loss and accuracy curves for training and validation \nfig, ax = plt.subplots(2,1)\nax[0].plot(visualize_acc_loss.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(visualize_acc_loss.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(visualize_acc_loss.history['acc'], color='b', label=\"Training accuracy\")\nax[1].plot(visualize_acc_loss.history['val_acc'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","e921080d":"X_test, Y_test = prepare_data(test_images_dogs_cats) #Y_test in this case will be []","dc66cde6":"test_datagen = ImageDataGenerator(rescale=1. \/ 255)","b4e936c6":"def plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    \n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","a3b356aa":"# Predict the values from the validation dataset\nY_pred = model.predict(np.array(X_val))\n\nY_pred_labels = [] # labels    \n    \nfor i in range(0,len(Y_pred)):\n    if Y_pred[i, 0] >= 0.5: \n        Y_pred_labels.append(1)\n    else:\n        Y_pred_labels.append(0)\n\n# Convert predictions classes to one hot vectors \nY_pred_classes = np.argmax(Y_pred) \n\n# compute the confusion matrix\nconfusion_mtx = confusion_matrix(Y_val, Y_pred_labels) \n\n# plot the confusion matrix\nplot_confusion_matrix(confusion_mtx, classes = range(1))","46c98161":"Y_pred = model.predict(np.array(X_val))\n\n#####predict cat | predict dog\nfor i in range(0,5):\n    if Y_pred[i, 0] >= 0.5: \n        print('I am {:.2%} sure this is a Dog'.format(Y_pred[i][0]))\n    else: \n        print('I am {:.2%} sure this is a Cat'.format(1-Y_pred[i][0]))\n        \n    plt.imshow(X_val[i])    \n    plt.show()","a5ad6895":"test_generator = val_datagen.flow(np.array(X_test), batch_size=batch_size)\nprediction_probabilities = model.predict_generator(test_generator, verbose=1)","397df402":"counter = range(1, len(test_images_dogs_cats) + 1)\nsolution = pd.DataFrame({\"id\": counter, \"label\":list(prediction_probabilities)})\ncols = ['label']\n\nfor col in cols:\n    solution[col] = solution[col].map(lambda x: str(x).lstrip('[').rstrip(']')).astype(float)\n\nsolution.to_csv(\"dogsVScats.csv\", index = False)","e18e0a99":"# Validating the score on validation data \nscore = model.evaluate_generator(validation_generator)\nprint('Test score:', score[0])\nprint('Test accuracy:', score[1])","016c7816":"## Validation of the Model","c9d73d0c":"### Plot the Loss and Accuracy of Model"}}