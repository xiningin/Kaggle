{"cell_type":{"48c54a8c":"code","7bb3c043":"code","18e64394":"code","5e2f7a69":"code","2b5e2564":"code","954b8b93":"code","ff37c363":"code","90f11294":"code","ea8a7c73":"code","ef076b00":"code","ff041d62":"code","0ade7fc4":"code","081c5c30":"code","085776d1":"code","6ba0a891":"code","48951082":"code","42dcc106":"code","2dc17f08":"code","7a8e9580":"code","d9132bed":"code","5719dcbf":"code","efa99a18":"markdown","f46affe0":"markdown","8ac9abb3":"markdown","20f9c7c6":"markdown","98768f42":"markdown","9a8113ae":"markdown","84fc52ba":"markdown","70d26f58":"markdown","d941f52a":"markdown","aa832870":"markdown","cd410d2f":"markdown","8b7f5291":"markdown","acc7ac12":"markdown","ddded1ca":"markdown","ac6d6a77":"markdown","75f8e319":"markdown","b4b4ca8d":"markdown","17a1dc4d":"markdown","3b943005":"markdown","57ebf5bd":"markdown","2e148dcd":"markdown","3d7fe7e1":"markdown","82b000f2":"markdown"},"source":{"48c54a8c":"import pandas as pd\nreviews = pd.read_csv(\"..\/input\/winemag-data-130k-v2.csv\", index_col=0)\npd.set_option(\"display.max_rows\", 5)","7bb3c043":"reviews.country","18e64394":"reviews['country']","5e2f7a69":"reviews['country'][0]","2b5e2564":"reviews.iloc[0]","954b8b93":"reviews.iloc[:, 0]","ff37c363":"reviews.iloc[:3, 0]","90f11294":"reviews.iloc[1:3, 0]","ea8a7c73":"reviews.iloc[[0, 1, 2], 0]","ef076b00":"reviews.iloc[-5:]","ff041d62":"reviews.loc[0, 'country']","0ade7fc4":"reviews.loc[:, ['taster_name', 'taster_twitter_handle', 'points']]","081c5c30":"reviews.set_index(\"title\")","085776d1":"reviews.country == 'Italy'","6ba0a891":"reviews.loc[reviews.country == 'Italy']","48951082":"reviews.loc[(reviews.country == 'Italy') & (reviews.points >= 90)]","42dcc106":"reviews.loc[(reviews.country == 'Italy') | (reviews.points >= 90)]","2dc17f08":"reviews.loc[reviews.country.isin(['Italy', 'France'])]","7a8e9580":"reviews.loc[reviews.price.notnull()]","d9132bed":"reviews['critic'] = 'everyone'\nreviews['critic']","5719dcbf":"reviews['index_backwards'] = range(len(reviews), 0, -1)\nreviews['index_backwards']","efa99a18":"## Conditional selection\n\nSo far you've indexed data using locations or values. But you'll often want to ask questions based on conditions. \n\nFor example, suppose that you're interested specifically in better-than-average wines produced in Italy.\n\nWe can start by asking each wine if it's Italian or not:","f46affe0":"## Label-based selection\n\nYou can use the `loc` operator for **label-based selection**. This uses the data index value, not its position.\n\nFor example, to get the first entry in `reviews`, we would now do the following:","8ac9abb3":"## Manipulating the index\n\nLabel-based selection derives its power from the labels in the index. What if you want to select on a different field than the current index?\n\nThe `set_index` method will help you here. For example, you can make `title` the index field with the command:","20f9c7c6":"## Assigning data\n\nGoing the other way, assigning data to a `DataFrame` is easy. You can assign either a constant value:","98768f42":"Suppose we'll buy any wine that's made in Italy _or_ which is rated above average. For this we use a pipe (`|`):","9a8113ae":"This produced a `Series` of `True`\/`False` booleans based on the `country` of each record.  This result can then be used inside of `loc` to select the relevant data:","84fc52ba":"On its own the `:` operator, which also comes from native Python, means \"everything\". When combined with other selectors, however, it can be used to indicate a range of values. For example, to select the `country` column from just the first, second, and third row, we would do:","70d26f58":"Performing a `set_index` is useful if you can come up with an index for the dataset which is better than the current one.","d941f52a":"## Index-based selection\n\nThe indexing operator and attribute selection are nice because they look like things you've seen before. But `pandas` also has accessor operators, `loc` and `iloc` that are useful for more complex operations.\n\n`pandas` indexing works in one of two paradigms. The first is **index-based selection**: selecting data based on its numerical position in the data. You'll use `iloc` for this.\n\nHere is how to select the first row of data:","aa832870":"Or, to select just the second and third entries, we would do:","cd410d2f":"Similarly, you are likely familiar with the \"bracket\" access to dictionary objects. You can access DataFrame columns in a similar way with the indexing (`[]`) operator. This \"just works\":","8b7f5291":"# Introduction\n\nSelecting specific values of a `pandas` `DataFrame` or `Series` to work on is an implicit step in almost any data operation you'll run. Hence a solid understanding of how to slice and dice a dataset is vital. You'll see it with the familiar wine review dataset.","acc7ac12":"Both `loc` and `iloc` are row-first, column-second. So, you get a column with `iloc` with the following:","ddded1ca":"Doesn't a `pandas` `Series` look kind of like a fancy `dict`? It pretty much is, so it's no surprise that, to drill down to a single specific value, we need only use the indexing operator `[]` once more:","ac6d6a77":"It's also possible to pass a list:","75f8e319":"Or with an iterable of values:","b4b4ca8d":"`pandas` comes with a few pre-built conditional selectors, two of which we will highlight here. The first is `isin`. `isin` is lets you select data whose value \"is in\" a list of values. For example, here's how we can use it to select wines only from Italy or France:","17a1dc4d":"With `iloc` we treat the dataset like a big matrix (a list of lists), one that we have to index into by position. \n\nSince your dataset usually has meaningful indices, it's frequently easier to use `loc`. For example, here's one operation that's much easier using `loc`:","3b943005":"Finally, it's worth knowing that negative numbers can be used in selection. This will start counting forwards from the _end_ of the values. So for example here are the last five elements of the dataset.","57ebf5bd":"The second is `isnull` (and its companion `notnull`). These methods let you highlight values which are or are not empty (`NaN`). For example, to filter out wines lacking a price tag in the dataset, here's what we would do:","2e148dcd":"This `DataFrame` has ~20,000 rows. The original had ~130,000. That means that around 15% of wines originate from Italy.\n\nWe also wanted to know which ones are better than average. Wines are reviewed on a 80-to-100 point scale, so this could mean wines that accrued at least 90 points.\n\nWe can use the ampersand (`&`) to bring the two questions together:","3d7fe7e1":"We will see much more `DataFrame` assignment going on in later sections of this tutorial.","82b000f2":"## Easy Ways to Access Series from A DataFrame\n\nYou're probably familiar with a general Python pattern of accessing an object attribute: If a `book` object has a `title` property, you can access it by calling `book.title`. Columns in a `DataFrame` work the same way. \n\nSo you can access the `country` property of our `reviews` with"}}