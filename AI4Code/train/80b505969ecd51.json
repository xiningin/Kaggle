{"cell_type":{"03a3f34b":"code","8aadb035":"code","49254c38":"code","ea66e3cb":"code","43615680":"code","25f540f9":"code","7a891ecd":"code","f0da3521":"code","e045e32d":"code","100387df":"markdown","9c05c76b":"markdown","f5071685":"markdown","28001ecb":"markdown","b7eaf4e9":"markdown","144279bf":"markdown","306c9e5b":"markdown","4953fcb1":"markdown"},"source":{"03a3f34b":"!pip install git+https:\/\/github.com\/EasyArray\/phosphorus#egg=phosphorus\n\n%load_ext phosphorus","8aadb035":"rule I:   M\u03b1I => M\u03b1IU\nrule II:  M\u03b1 => M\u03b1\u03b1\nrule III: M\u03b1III\u03b2 => M\u03b1U\u03b2\nrule IV:  M\u03b1UU\u03b2 => M\u03b1\u03b2\n\n\"-----------------------------------\"\nrules\nrules[I]\n\n\"-----------------------------------\"\nrules[I].run(MI)\nrules[III].run(MIIIIIIII)","49254c38":"rules[I].run(MI)\nstep(MI)\nstep(MIU)\nstep(MIIII) \nstep(MIIIIIIII)","ea66e3cb":"one = step(MI)\none\nstep(one)\nstep(step(MI))","43615680":"repeat(step,MI,1)\nrepeat(step,MI,2)\nrepeat(step,MI,3)\nrepeat(step,MI,4)\n\n\"-----------------------------------\"\nrepeat(step,MI,1,True)\nrepeat(step,MI,2,True)\nrepeat(step,MI,3,True)\nrepeat(step,MI,4,True)\n","25f540f9":"def maketree(name,children):\n    return tree[(\"_\"+name) (*children)]\n\nmaketree(MI, step(MI))\n\n#The children here are two trees inside a list [] :\nmaketree(MI, [maketree(MIU,step(MIU)),maketree(MII,step(MII))])\n","7a891ecd":"def growtree(x):\n    if not x.type() == \"tree\":\n        return maketree(x,step(x))\n    # The rest only runs when we do have a tree:\n    newchildren = []\n    for child in x:\n        newchildren += [growtree(child)]\n    return maketree(x.name,newchildren)\n\ngrowtree(growtree(MI))\nrepeat(growtree,MI,3)\nrepeat(growtree,MI,4)","f0da3521":"Rule.deregister() #Deletes all rules\nrule I: M\u03b1I => M\u03b1IU\nrule II: M\u03b1 => M\u03b1\u03b1\nrule III: M\u03b1III\u03b2 => M\u03b1U\u03b2\nrule IV: M\u03b1UU\u03b2 => M\u03b1\u03b2\n\n# Could be useful for #2 -- play around with this\nrepeat(growtree,MIU,3)","e045e32d":"Rule.deregister() #Deletes all rules\n\n# BACKWARDS version of MIU\nrule I: M\u03b1IU => M\u03b1I\nrule II: M\u03b1\u03b1 => M\u03b1\nrule III: M\u03b1U\u03b2 => M\u03b1III\u03b2\nrule IV: M\u03b1\u03b2 => M\u03b1UU\u03b2\n\nstep(MIIUU)\nstep(step(MIIUU))\nrepeat(step,MIIUU,3)\n\n#filtering by length could help:\n[x | x\u2208repeat(step,MIIUU,3), len(x) < 7]","100387df":"# MIU in Phosphorus\n\nThis notebook introduces the apparatus necessary to calculate Hofstadter's formal systems using Phosphorus. This is also the first notebook you will need to edit.","9c05c76b":"### Writing rules in phosphorus\n\nTo write a formal system rule in phosphorus, we use a special command `rule`, as shown below. A rule consistents of a name, an input, and an output. After the rule command is evaluated, the rule is stored in a python structure called a *dictionary*, shown right below the dotted line with the name `rules`. You can retrieve items from a dictionary with brackets `[ ]` surrounding a *key*. For the rules dictionary, the key is the name of the rule.\n\nNotes:\n* The Greek letters in rules are variables representing, in this case, strings of letters. Phosphorus recognizes Greek letters only as variables inside other strings.\n* To enter a Greek letter, type a backslash `\\` followed immediately by the name of the letter, and then hit tab. For instance `\\alpha` plus tab.\n* To run a rule on an input, use the `.run()` function, as shown at the bottom of the next cell. This returns a list of all outputs from applying that rule to that input. The `.` is a python operator that accessed a function associated especially with one type of object, like a rule in this case.","f5071685":"#### \ud83e\udd14 Exercises\nEdit this cell to answer the following questions. Feel free to use the following cell to do helpful calculations. The cell after that might be useful for the top-down derivation, since it defines a backwards version of MIU.\n\n1.\tComplete full top-down and bottom-up derivations for the formula **MIIUU**:\n\n*Bottom-up*\n\n\\# | Step | Justification\n-- | -- | --\n1 | **MI** | Axiom\n2 | **MII** | Rule II applied to 1 (*x*=**I**)\n3 |\n\n*Top-down*\n\n\\# | Step | Justification\n-- | -- | --\n1 | **MIIUU** is theorem if **MIIUIII** is | Rule III (*x*=**MIIU**, *y*=**&epsilon;**)\n2 |\n\n\n2. Can any rule but (II) apply to any theorem derived from **MIU** or **MIIU**?\n\n    <!-- Put your answers between the questions -->\n    \n\n\n3. Is the number of **I**\u2019s in any theorem (besides **MI**) odd? even? a multiple of three?\n\n\n\n4. Is **MU** a theorem?\n\n\n","28001ecb":"### The whole system at once: the `step` function\n\nPhosphorus also includes a handy `step` function that runs all defined rules on input strings at the same time. Notice that Jupyter notebooks save information from one cell to the next, so the rules defined above work below.\n\n\ud83e\udd14 Why are the first two outputs different?","b7eaf4e9":"Phosphorus provides a funciton `repeat(f,x,n)` that applies a function `f` to an argument `x` exactly `n` times. An optional fourth argument determines whether to show all values accumulated along the way, only those reached via exactly `n` steps. Notice the use of python's built-in value `True`. (Its opposite is `False`.)","144279bf":"Of course, it gets tedious to keep adding calls to `maketree`, so why not make a function that applies `step` to each leaf node of a tree? That function `growtree` is defined below. It shows a few more features of python and phosphorus (but don't worry if you don't totally understand these!):\n\n* If `x` is a phosphorus object, `x.type()` returns its phosphorus type as a string.\n* Python `if` statements have a true\/false expression followed by a colon. If the expression is true, the lines indented after the colon are run.\n* Python `for` statements loop over an object like a list. Phosphorus trees act like lists of their children, so the `for` statement below loops over the children of the input `x`.\n* If `x` is a phosphorus tree, `x.name` is its name.\n* This is an example of a recursive function, because it calls itself. \ud83e\udd14 Why?\n    \nFinally, notice that we can use `repeat` to grow our trees a few times in a row.","306c9e5b":"### Visualizing output\n\nWe can view the outputs as trees, if we want! I've included a helper function here called `maketree` that makes it easier to create a tree from a parent name and a list of children. In python, you define a function with the keyword `def`, then the function name, then the arguments in parentheses. A colon separates this *signature* from the code of the function. Finally the `return` keyword determines what the output of the function will be.\n\n(For those who are interested, `*children` replaces the list `children` with its members. This expression and the previous one are in parentheses so they are evaluated before being entered in the tree.)","4953fcb1":"The `step` function can also take multiple inputs, so we can chain together calls to step.\n\n> Note that `one = step(MI)` declares `one` to be a variable and assigns it a value equal to the output of `step(MI)`. When `one` is used alone on the next line, this value is printed, instead of simply `one` as a constant.\n\n\ud83e\udd14 Which line(s) involve `step` taking multiple inputs?"}}