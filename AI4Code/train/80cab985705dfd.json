{"cell_type":{"0949a5c6":"code","dab7da1f":"code","5d4afce6":"code","30504534":"code","1c0a6e7d":"code","f835a7e7":"code","23491700":"code","bfc9b5d5":"code","d846eb42":"code","8c5d2aab":"code","019e2921":"code","6fa8a947":"code","5cbf82b3":"code","2742f135":"code","5480d97e":"code","773b8b4d":"code","e3b0774b":"code","8ef98c0e":"code","a8a37646":"code","20f72777":"code","e190d12d":"code","3418c773":"code","baa0115c":"code","3dfd645b":"code","181d3e7d":"code","828c4cc2":"code","3ecef92e":"code","c4b54c0a":"code","ee4df03d":"code","4ff6abe4":"code","92783cde":"code","e99264a8":"code","943bc1c4":"code","7951b506":"code","a640e940":"code","6e0e3b61":"code","bd5f09bb":"code","70e7a154":"code","016f6930":"code","af816e00":"code","57dad79f":"code","a3ab9866":"code","1e7b1b12":"code","eb7197cd":"code","07babd6c":"code","981be346":"code","3fa043e2":"code","0da8f517":"code","304e4b45":"code","5b14f331":"code","e7049abe":"code","0fc6b80e":"code","cee86d35":"code","e2c6aaf8":"code","56b628a7":"code","778d2720":"code","2fe1d267":"markdown","a04de925":"markdown","120197c9":"markdown","5e9e1415":"markdown","f08b171e":"markdown","25891bea":"markdown","49fc9b65":"markdown","cb8dab4a":"markdown","02c50877":"markdown","5a421b7a":"markdown","ecd5b645":"markdown","14664901":"markdown","d753000e":"markdown","08a16a22":"markdown","b8ebc1fb":"markdown","85444bfd":"markdown","cda668bb":"markdown","a8540c2d":"markdown","60d98eee":"markdown","80522e44":"markdown","6be1507a":"markdown","c1c9e18a":"markdown","d93eeecb":"markdown","61b14a83":"markdown","4ade72d0":"markdown","f65966c8":"markdown","5bb8d89d":"markdown","75abc9df":"markdown","ffb5b4ca":"markdown","432d436b":"markdown","0b75cc58":"markdown","921228e5":"markdown","725980ad":"markdown","353c6474":"markdown","19004a96":"markdown","17348aef":"markdown","e215e0df":"markdown","20358783":"markdown","80822e06":"markdown","c7e62bbb":"markdown","91761fa8":"markdown","c367904e":"markdown","3a1f7f75":"markdown","05efa2d8":"markdown","9c94f622":"markdown"},"source":{"0949a5c6":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nsns.set()\n%config InlineBackend.figure_format = 'svg'\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 5, 4\nimport warnings\nwarnings.simplefilter('ignore')","dab7da1f":"import os\nprint(os.listdir(\"..\/input\"))","5d4afce6":"df_full = pd.read_csv(\"..\/input\/forex-strategy-results-first\/kaggle_USD_United_States_Consumer_Price_Index_Ex_Food__Energy_YoY_USDJPY.csv\")\ndf_full.columns","30504534":"df = df_full[['enabledOrderDirection', 'pointsAway', 'stopLoss', 'trailingStop', 'maxSlippage', 'finishDep']].copy()\ndf.sort_values(by='finishDep', ascending=False).head()","1c0a6e7d":"df.loc[df['enabledOrderDirection'] == 'LONG', 'enabledOrderDirection'] = 1\ndf.loc[df['enabledOrderDirection'] == 'SHORT', 'enabledOrderDirection'] = -1\ndf.head()","f835a7e7":"print(df.shape)\nprint(df.info())","23491700":"df.describe()","bfc9b5d5":"df.loc[df['finishDep'] > 1000, 'finishDep'].count() \/ df.shape[0]","d846eb42":"df.loc[df['finishDep'] < 1000, 'finishDep'].count() \/ df.shape[0]","8c5d2aab":"df.loc[df['finishDep'] == 1000, 'finishDep'].count() \/ df.shape[0]","019e2921":"df['isInProfit'] = df['finishDep'].map(lambda x: (x > 1000))\ndf.head()","6fa8a947":"pd.crosstab(df['enabledOrderDirection'], df['isInProfit'], margins=True)","5cbf82b3":"sns.countplot(x='enabledOrderDirection', hue='isInProfit', data=df);","2742f135":"fig, ax = plt.subplots(figsize=(14,5))\nsns.distplot(df[df['enabledOrderDirection']==-1]['finishDep'], ax=ax, color='r', bins=range(0, 1500, 10), hist_kws=dict(alpha=0.5))\nsns.distplot(df[df['enabledOrderDirection']==1]['finishDep'], ax=ax, color='g', bins=range(0, 1500, 10), hist_kws=dict(alpha=0.5))\nax.axvline(1000, color='k', linestyle='--')\nax.set_xlim(700, 1300);","5480d97e":"plt.scatter(df['pointsAway'], df['trailingStop'])\nplt.xlabel('pointsAway')\nplt.ylabel('trailingStop');","773b8b4d":"heatmapShort_data = pd.pivot_table(df[df['enabledOrderDirection']==-1], values='finishDep', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nheatmapLong_data = pd.pivot_table(df[df['enabledOrderDirection']==1], values='finishDep', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(14,6))\nsns.heatmap(heatmapShort_data, ax=ax1, vmin=700, vmax=1300, cmap=\"seismic\")\nsns.heatmap(heatmapLong_data, ax=ax2, vmin=700, vmax=1300, cmap=\"seismic\")","e3b0774b":"heatmapShort_data = pd.pivot_table(df[df['enabledOrderDirection']==-1], values='isInProfit', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nheatmapLong_data = pd.pivot_table(df[df['enabledOrderDirection']==1], values='isInProfit', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(14,6))\nsns.heatmap(heatmapShort_data, ax=ax1, cmap=\"seismic\")\nsns.heatmap(heatmapLong_data, ax=ax2, cmap=\"seismic\")","8ef98c0e":"heatmapSL_data = pd.pivot_table(df[df['enabledOrderDirection']==1], values='isInProfit', \n                     index=['pointsAway'], \n                     columns='stopLoss')\nheatmapMS_data = pd.pivot_table(df[df['enabledOrderDirection']==1], values='isInProfit', \n                     index=['pointsAway'], \n                     columns='maxSlippage')\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(14,6))\nsns.heatmap(heatmapSL_data, ax=ax1, cmap=\"seismic\")\nsns.heatmap(heatmapMS_data, ax=ax2, cmap=\"seismic\")","a8a37646":"swarms = ['pointsAway', 'trailingStop', 'stopLoss', 'maxSlippage']\nfor hue in swarms:\n    sns.catplot(x=\"enabledOrderDirection\", y=\"finishDep\", hue=hue, data=df, \n            size=5, aspect=2, palette=\"inferno\", s=4, kind='swarm')\n","20f72777":"df_long = df.loc[df['enabledOrderDirection'] == 1]\nprint(df_long.shape)\ndf_long.head()","e190d12d":"df_full = pd.read_csv(\"..\/input\/forex-strategy-results-next\/kaggleB_USD_United_States_Consumer_Price_Index_Ex_Food__Energy_YoY_USDJPY.csv\")\ndf_full.columns","3418c773":"df_full = df_full.loc[df_full['enabledOrderDirection'] =='LONG']\ndf_full.shape","baa0115c":"df = df_full[['pointsAway', 'stopLoss', 'trailingStop', 'breakevenTrigger', 'breakevenDistance', 'maxSlippage', 'finishDep', 'profitNb', 'orderPercent', 'profitPercent', 'avrPLclosedorder', 'PLrateCom', 'profitNbWithComm']].copy()\ndf['isInProfit'] = df['finishDep'].map(lambda x: (x > 1000))\ndf.sort_values(by='finishDep', ascending=False).head()","3dfd645b":"plt.scatter(df['pointsAway'], df['finishDep'])\nplt.xlabel('pointsAway')\nplt.ylabel('finishDep');","181d3e7d":"heatmapTS_data = pd.pivot_table(df, values='isInProfit', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nheatmapBT_data = pd.pivot_table(df, values='isInProfit', \n                     index=['pointsAway'], \n                     columns='breakevenTrigger')\nheatmapBD_data = pd.pivot_table(df, values='isInProfit', \n                     index=['pointsAway'], \n                     columns='breakevenDistance')\nheatmapFD_data = pd.pivot_table(df, values='finishDep', \n                     index=['pointsAway'], \n                     columns='breakevenDistance')\nf, (ax1, ax2, ax3, ax4) = plt.subplots(1, 4, sharey=True, figsize=(16,4))\nsns.heatmap(heatmapTS_data, ax=ax1, cmap=\"seismic\")\nsns.heatmap(heatmapBT_data, ax=ax2, cmap=\"seismic\")\nsns.heatmap(heatmapBD_data, ax=ax3, cmap=\"seismic\")\nsns.heatmap(heatmapFD_data, ax=ax4, cmap=\"seismic\", center=1000)","828c4cc2":"dfs=df.sample(n=500, replace=False, random_state=1)\nsns.swarmplot(y=dfs[\"finishDep\"], hue=dfs[\"breakevenTrigger\"], x=[\"\"]*len(dfs), size=5, palette=\"inferno\", s=4)","3ecef92e":"from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.model_selection import GridSearchCV, StratifiedKFold","c4b54c0a":"skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=5)\nrf = RandomForestClassifier(n_estimators=100, n_jobs=-1, random_state=42, \n                            class_weight='balanced')\nparameters = {'max_features': [2, 4, 6], 'min_samples_leaf': [3, 5, 7, 9], 'max_depth': [5,10,15]}\n\nX = df[['pointsAway', 'stopLoss', 'trailingStop', 'breakevenTrigger', 'breakevenDistance', 'maxSlippage']]\ny_IIP = df['isInProfit']","ee4df03d":"%%time\nrf_IIP = GridSearchCV(rf, parameters, n_jobs=-1, scoring='roc_auc', cv=skf, verbose=True)\nrf_IIP = rf_IIP.fit(X, y_IIP)\nprint(rf_IIP.best_score_)\nprint(rf_IIP.best_estimator_.feature_importances_)","4ff6abe4":"df['iip_est'] = rf_IIP.best_estimator_.predict(X)","92783cde":"heatmapIIP_data = pd.pivot_table(df, values='isInProfit', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nheatmapPRED_data = pd.pivot_table(df, values='iip_est', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(14,6))\nsns.heatmap(heatmapIIP_data, ax=ax1, cmap=\"seismic\")\nsns.heatmap(heatmapPRED_data, ax=ax2, cmap=\"seismic\")","e99264a8":"from sklearn.model_selection import train_test_split, cross_val_score\nfrom sklearn.metrics.regression import mean_squared_error\n\ny_FD = df['finishDep']\ny_PNC = df['profitNbWithComm']","943bc1c4":"X_train, X_holdout, y_train, y_holdout = train_test_split(X, y_FD)\nrf_FD = GridSearchCV(RandomForestRegressor(n_jobs=-1, random_state=17), \n                                 parameters, \n                                 scoring='neg_mean_squared_error',  \n                                 n_jobs=-1, cv=5,\n                                  verbose=True)\nrf_FD.fit(X_train, y_train)","7951b506":"rf_FD.best_params_, rf_FD.best_score_","a640e940":"print(\"Mean squared error (cv): %.3f\" % np.mean(np.abs(cross_val_score(rf_FD.best_estimator_,\n                                                        X_train, y_train, \n                                                        scoring='neg_mean_squared_error'))))\nprint(\"Mean squared error (test): %.3f\" % mean_squared_error(y_holdout, \n                                                             rf_FD.predict(X_holdout)))","6e0e3b61":"rf_FD.best_estimator_.feature_importances_","bd5f09bb":"df['fd_est'] = rf_FD.best_estimator_.predict(X)","70e7a154":"heatmapFD_data = pd.pivot_table(df, values='finishDep', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nheatmapPRED_data = pd.pivot_table(df, values='fd_est', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(14,6))\nsns.heatmap(heatmapFD_data, ax=ax1, cmap=\"seismic\", center=1000)\nsns.heatmap(heatmapPRED_data, ax=ax2, cmap=\"seismic\", center=1000)","016f6930":"X_train, X_holdout, y_train, y_holdout = train_test_split(X, y_PNC)\nrf_PNC = GridSearchCV(RandomForestRegressor(n_jobs=-1, random_state=17), \n                                 parameters, \n                                 scoring='neg_mean_squared_error',  \n                                 n_jobs=-1, cv=5,\n                                  verbose=True)\nrf_PNC.fit(X_train, y_train)","af816e00":"rf_PNC.best_params_, rf_PNC.best_score_","57dad79f":"rf_PNC.best_estimator_.feature_importances_","a3ab9866":"df['pnc_est'] = rf_PNC.best_estimator_.predict(X)","1e7b1b12":"heatmapPNC_data = pd.pivot_table(df, values='profitNbWithComm', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nheatmapPRED_data = pd.pivot_table(df, values='pnc_est', \n                     index=['pointsAway'], \n                     columns='trailingStop')\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(14,6))\nsns.heatmap(heatmapPNC_data, ax=ax1, cmap=\"seismic\", center=1.5)\nsns.heatmap(heatmapPRED_data, ax=ax2, cmap=\"seismic\", center=1.5)","eb7197cd":"# check the max and min of the parameters we want vary\nX.describe()","07babd6c":"# use logspace for better resolution on smaller scales\n# don't extrapolate with estimators, so grid is between the minmax of the test parameters\n# logspace for better resolution with smaller numbers\n# pointsAway is the most important, it determines where I open my pending orders, so it has the best resolution\nx0 = np.logspace(np.log10(1.5), np.log10(30), num=50)\n# stopLoss\nx1 = np.logspace(np.log10(2), np.log10(12.5), num=6)\n# trailingStop\nx2 = np.logspace(np.log10(1.5), np.log10(20), num=25)\n# breakevenTrigger 0.0 means no break even mechanism, and the breakEvenTrigger distances are between 2 and 12,5\nx3 = np.concatenate(([0.0], np.logspace(np.log10(2), np.log10(12.5), num=5)), axis=None)\n# breakevenDistance 0.0 means set stopLoss to the open price, so normal logspace\nx4 = np.concatenate(([0.0], np.logspace(np.log10(0.5), np.log10(9.6), num=5)), axis=None)\n# maxSlippage only want to select combinations where maxSlippage is 50 - I need this feature for the grid, because the eastimators were trained with it.\nx5 = [50.0]","981be346":"# build grid\nx0v, x1v, x2v, x3v, x4v, x5v = np.meshgrid(x0, x1, x2, x3, x4, x5, sparse=False)","3fa043e2":"X_grid = np.array([x0v, x1v, x2v, x3v, x4v, x5v]).reshape(6, -1).T\nX_grid.shape","0da8f517":"df_grid = pd.DataFrame(X_grid, columns=['pointsAway', 'stopLoss', 'trailingStop', 'breakevenTrigger', 'breakevenDistance', 'maxSlippage'])","304e4b45":"df_grid['iip_est'] = rf_IIP.best_estimator_.predict(X_grid)\ndf_grid['fd_est'] = rf_FD.best_estimator_.predict(X_grid)\ndf_grid['pnc_est'] = rf_PNC.best_estimator_.predict(X_grid)\ndf_grid.head()","5b14f331":"# only profitable trades\ndf_grid = df_grid.loc[(df_grid['iip_est'] == True)]\n# almost same as above, but for the regression values\ndf_grid = df_grid.loc[(df_grid['fd_est'] > 1000)]\n# breakevenDistance and breakevenTrigger are relative to the open price, a large breakevenDistance would kick out the position\ndf_grid = df_grid.loc[(df_grid['breakevenDistance'] < df_grid['breakevenTrigger'])]\ndf_grid.shape","e7049abe":"# new metric of profit relative to the open deposite\ndf_grid['gainRate'] = (df_grid['fd_est']\/1000)-1","0fc6b80e":"df_grid['score'] = df_grid['gainRate'] * np.sqrt(df_grid['pnc_est'])","cee86d35":"df_grid['prob'] = df_grid['gainRate'] \/ df_grid['gainRate'].sum()\ndf_grid.head()","e2c6aaf8":"df_sample = df_grid.sample(n=100, weights='prob')","56b628a7":"ax = sns.scatterplot(df_sample['trailingStop'], df_sample['pointsAway'])\nax.invert_yaxis()","778d2720":"df_sample.to_csv(\"trading_sample.csv\", index=True)","2fe1d267":"When selecting our parameter combinations for trading I want to decrease the chance of the combinations which have low probability to be filled, so I fit for profitNbWithComm and later use it for altering the probabilities. profitNbWithComm: number of filled positions in profit after subtracting commission.","a04de925":"During test, our starting deposit is 1000 USD, so if our finishDep is larger than 1000 USD we have profit.\nThe first test parameters were chosen well, and the United States Consumer Price Index Ex Food Energy YoY event seems promissing, 23 percent of our combinations resulted in profit.","120197c9":"Now I fit some random forest estimators to different metrics like isInProfit, finishDep and profitPercent.\nFirst fit for isInProfit.","5e9e1415":"The histograms say the same story, don't trade SHORT.","f08b171e":"I drop the SHORT positions of the first test run.","25891bea":"### Label profitNbWithComm","49fc9b65":"We don't want to trade combinations where the model estimates that it will not be in profit (classifier) or estimates negative profit (finished deposite < 1000), or breakEvenDistance >= breakEvenTrigger. Instead of giving them zero probabilities later we just drop them.","cb8dab4a":"I have two test phases. First I run my tests changing only the most important parameters. This is a manual selection based on some statistics of the historical volatility of the news event. In my strategy the single most important parameter is the pointsAway, this determines how far from the zero-time-price I open my pending orders (you can read more about the strategy in the earlier articles, here I focus on the test results and parameter selection). I vary some other important parameters as well. In the dataframe I keep the finishDep (finished deposite) metric as well (from now on I call every number metric which are results of the trade and aren't predefined parameters.). I will use this metrics and others to find the best combinations for phase 2 tests.\n\nI run phase 1 and phase 2 tests on 2014-2016 data, then I select the parameter combinations for trade, and I will show how they perform on 2017 data. \n\nWe can imagine the parameters as a multi-dimensional space, and the goal is to find the part of this space where the strategy perfoms well. ","02c50877":"# Estimating metrics over the denser grid","5a421b7a":"### Label finishDep","ecd5b645":"<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/jan.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/feb.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/mar.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/apr.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/may.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/jun.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/jul.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/aug.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/sep.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/okt.JPG\" \/>\n<img src=\"https:\/\/raw.githubusercontent.com\/sinusgamma\/FOREX-strategy-parameter-selection\/master\/nov.JPG\" \/>","14664901":"I will select the parameter combinations for trading based on the gainRate, but I want to decrease the chance of the combinations where there were less profitable trades. So I multiply this gainRate with the pnc_est (estimated number of the trades in profit) parameter (the square root of it not to punish rarer combinations too much). ","d753000e":"# A better approach","08a16a22":"The probability of each parameter combination could be calculated from this score. But here I used gainRate, so the probability of a combination isn't related to the profitNumberComm parameter.","b8ebc1fb":"### Label isInProfit","85444bfd":"I build a grid wich has more grid points than the testgrid.","cda668bb":"Checking the maxSlippage shows that the larger maximum slippage is better. During test I use only 5 and 50 pips as maxSlippage. 50 is so large that this practically means that I shouldn't care about maximum slippage.","a8540c2d":"First I examine only the parameters which are changing during phase 1 tests.","60d98eee":"# EDA of the first test phase","80522e44":"Let's see some projections with our new parameters. The breakEvenTrigger 0 means no break even mechanism, and no break even seems worse than any break even triggers distance.","6be1507a":"For selecting the parameter combinations of the trade I will use different metrics, not only the finishDep.","c1c9e18a":"The heatmaps below show how the pointsAway\/trailingStop combinations performed during phase 1 tests. The first column is the SHORT position, the second is the LONG position. First, we can see the average finishDep, later the average isInProfit. A large part of the LONG combinations has potential and worth to further test that area.","d93eeecb":"The best estimator for isInProfit gives us a very similar space compared to the original data.","61b14a83":"During test pointsAway and trailingStop had the best \"resolution\", this is the pointsAway\/trailingStop grid.","4ade72d0":"The above system helps a lot but could be better. I run too many tests where the strategy will fail or doesn't even fill orders. The idea is that instead of a grid based system I could use a random parameter selection system. First I would start a test with one parameter combination, and if the test runs I randomly choose another parameter combination. After every tested parameter combination I would calculate a minimum distance for that point in the parameter space. Any new combination should be further from all earlier points than their minimum distances. This distance could be smaller if the parameter combination was in profit, and shouldn't be the same in the different parameter directions, so I need would require some thinking to find a good distance calculation. Maybe later I will try to build it.","f65966c8":"Swarm plots are great for visualization and notice interesting behaviors. Here the most interesting is the stopLoss plot. Smaller stopLoss results in higher profit or higher loss, while larger stopLoss trades are closer to the starting deposit. The explanation can be that with smaller stopLoss you are earlier stopped out if your filled position is on the wrong side of the main move, but you can be stopped out too early as well.","5bb8d89d":"The LONG(1) and SHORT(-1) positions don't have an equal chance to be in profit. Only checking this cross table I should avoid all SHORT trading for this news event, but for some intuition, I will examine both sides a bit more.","75abc9df":"My FOREX trade system and strategy has lots of parameters. Because of the number of parameters, the combinations of the possible test scenarios easily can reach very large numbers. To test all promising scenarios would require a very very and really very long time. For example, if I want to change only six parameters, all of them with 10 different numbers gives 1 million combinations, this means 1 million test runs.\n\nIf I want to run tests and trade my strategy in this century I need some techniques to reduce the number of test scenarios :) Here I show how I try to find the best parameter combinations for the tests and how I choose the combinations for trade.\n\nThe main idea is to build a sparse grid of parameter combinations in two steps, where the grid is denser in the space where the strategy has a better chance to be in profit. After that, I fit some estimators to this grid where the labels are different metrics of the trade. I use random forest classifiers and regressors because they gave a good fit. Then I build a more dense grid of parameters, where the metrics (for example finished deposit) are estimated by the random forest models. With different metrics, I build a score for each grid. This score is proportional to the chance that the parameter combination (or the grid point) will be selected for trade. Obviously better performing combinations will have a higher score, and losing combinations will have zero scores. From the score with a simple transformation, we get the probability mass function of the grid for selecting the given grid point. I randomly select multiple parameter combinations based on this probabilities and test them on a different year than the tests were run.\n\nMy trade system and the strategy:<br>\nhttps:\/\/medium.com\/@istvan.veber\/forex-news-trader-785ad0a1394c<br>\nhttps:\/\/medium.com\/@istvan.veber\/trade-the-news-but-make-your-forex-research-part-2-analysis-and-strategy-e0f2c84a3bdd<br>\nhttps:\/\/github.com\/sinusgamma\/Forex-News-Trader-Dukascopy-API\n\n","ffb5b4ca":"After the isInProfit classifier fit random forest regression model for finishDep.","432d436b":"After the above examinations, I run a new test without the SHORT positions and only one maxSlippage parameter, but I added new parameters: breakEvenTrigger and breakEvenDistance. Here I load the results of the first test run combined with the second test run.","0b75cc58":"# Selecting the parameters for trade","921228e5":"We add a new column to the database for later examinations: 'isInProfit'. I made some ML model to evaluate the 'finisDep' based on the parameters, but they don't contain enough information and weren't so good. But the binary classification of the isInProfit parameter was far better. We will use both later. ","725980ad":"# The dense grid of parameters","353c6474":"The best estimator for finishDep gives us a very similar space compared to the original data.","19004a96":"# The main idea","17348aef":"The earlier tests to build the grid were run on 2014-2016 data. The randomly sampled parameters were run on 2017 data. There were only 11 United States Consumer Price Index Ex Food Energy YoY events, and examining this event alone isn't enough to show if the strategy works or not. I need more examinations with more events and time-frames. But here I only wanted to show the parameter combination selection process. \n\nThe tests on 2017 data based on the 2014-2016 parameter grid were really well in the case of United States Consumer Price Index Ex Food Energy YoY. The behavior of the tick price was smooth and without jigsaw patterns (most of the time). In the Dukascopy tester the default was 50000 USD, and I forgot to change, and I used the minimum trade amount for the tests. \n\ndate          finished    profit<br>\n2017-01-18 13:30___50016.48___16.48<br>\n2017-02-15 13:30___50112.27___112.27<br>\n2017-03-15 12:30___50022.45___22.45<br>\n2017-04-14 12:30___49997.12___-2.88<br>\n2017-05-12 12:30___50000___0<br>\n2017-06-14 12:30___50000___0<br>\n2017-07-14 12:30___50000___0<br>\n2017-08-11 12:30___50000___0<br>\n2017-09-14 12:30___50116.99___116.99<br>\n2017-10-13 12:30___50000___0<br>\n2017-11-15 13:30___49965.85___-34.15<br>","e215e0df":"The pointsAway alone doesn't show noticable linear association with the finishDep.","20358783":"# Results","80822e06":"In this kernel I will examine the United States Consumer Price Index Ex Food Energy YoY news events for the USD\/JPY pair. I chose this event because it often has high volatility and according to my former examinations the USD\/JPY is the best for high-frequency news trading. (At least for USD related news with my strategy.)","c7e62bbb":"## Random Forest based probabilistic parameter selection for algorithmic traiding system","91761fa8":"Let's select the parameters for our trade:<br>\n(Weights doesn't need real probabilities, it would scale any column, I just wanted to see them.)","c367904e":"# EDA of the second test phase","3a1f7f75":"The new df_grid dataframe will contain the grid values and the estimated metrics of the grid.","05efa2d8":"# Fitting random forest models","9c94f622":"We can see that the pointsAway is the most important feature and trailingStop helped a lot as well, and breakevenTrigger seems a useful parameter."}}