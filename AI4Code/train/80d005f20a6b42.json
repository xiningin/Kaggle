{"cell_type":{"f0165686":"code","855f9541":"code","dfbf1b1a":"code","9aa71aff":"code","39f5b09c":"code","07a8bb7e":"code","65969f4c":"code","c8cb7fd9":"code","1fee34d4":"code","1dc881e6":"code","6853106f":"code","0331e58c":"code","6a190668":"code","5abf231c":"code","1455fb13":"code","d353d26d":"code","33179831":"code","8cbdbe9a":"code","e62b5a9d":"code","bae9e1ec":"code","58b6ea35":"code","373f1aee":"code","606b78d5":"code","197146c0":"code","fcc4b654":"code","e7b72738":"code","4abcfa61":"code","cf91b4e3":"code","1c85a367":"code","69a8a3cb":"code","445df20f":"code","750143d4":"code","8b2a58ea":"code","0044268d":"code","772e155b":"code","468b0cba":"code","39c7dcfa":"code","316660da":"code","f1b8cb02":"code","2a2f9e26":"code","2b8770c0":"code","e1cb96ea":"code","8768c1ce":"code","b163c305":"code","26ab1411":"code","c2a0eba5":"code","5bf9582a":"markdown","f86c6d27":"markdown","1e6c7f61":"markdown","f4de5302":"markdown","ae6f92e9":"markdown","61d2732c":"markdown","fe153907":"markdown","ef84223f":"markdown","77ede0b5":"markdown","f4faf09d":"markdown","b8cbf114":"markdown","1db8ebfa":"markdown","bc96a2db":"markdown","695722a3":"markdown","d85a72bd":"markdown","7cf03b3e":"markdown","8d977773":"markdown","4266d8fe":"markdown","4bdf9ea3":"markdown","afef0045":"markdown","9608e279":"markdown"},"source":{"f0165686":"# Importing Libs\n\nimport pandas as pd\nimport numpy as np\nfrom nltk.corpus import stopwords\nfrom nltk.tokenize import word_tokenize, sent_tokenize\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer\nfrom scipy.sparse import csr_matrix\nfrom tqdm import tqdm","855f9541":"# Loading train and Test datasets\n\ntrain = pd.read_csv('..\/input\/nlp-getting-started\/train.csv')\ntest = pd.read_csv('..\/input\/nlp-getting-started\/test.csv')","dfbf1b1a":"train.head(3)","9aa71aff":"test.head(3)","39f5b09c":"train.info()","07a8bb7e":"test.info()","65969f4c":"stop_words_nltk = list(stopwords.words('english'))\ncount_vectorizer = CountVectorizer(stop_words='english')\ncount_train = count_vectorizer.fit_transform(train['text'].values)","c8cb7fd9":"csr_matrix(count_train).toarray()","1fee34d4":"# Picking a sentence to be tokenized\n\ntrain['text'].values[10]","1dc881e6":"# Checking the tokenized sentence\n\nword_tokenize(train['text'][10])","6853106f":"from nltk.tokenize import TweetTokenizer\n\ndef tweet_tokenize_column(df, column):\n    \"\"\"     \n        This function gets the Dataframe and the name of a column (String) containing texts (Strings) and returns\n        a list of lists containing the tokenized text. It also turns every token to it's lower form and excludes\n        stopwords.\n        \n        Essa funcao recebe o Dataframe e o nome de uma coluna (String) contendo textos (Strings), e retorna uma lista\n        de listas contendo o texto tokenizado. A funcao tambem transforma todas as letras maiusculas em minusculas e \n        exclui stopwords.\n        \n        Input: Pandas DataFrame, String\n        Return: Nested List\n    \"\"\"\n    \n    tweet_tokenizer = TweetTokenizer()\n    \n    # List of sentences \/ Lista de sentencas\n    list_sent = [tweet_tokenizer.tokenize(sent) for sent in df[column].values]\n    \n    # List of sentences excluding stopword tokens \/ Lista de sentencas excluindo stopwords\n    list_sent_no_stop = [[token.lower() \n                           for token in sent \n                           if token not in stopwords.words('english')] \n                           for sent in list_sent]\n    \n    return list_sent_no_stop","0331e58c":"# Using the function on train and test datasets\n\ntokenized_sent_train = tweet_tokenize_column(train,'text')\ntokenized_sent_test = tweet_tokenize_column(test,'text')","6a190668":"tokenized_sent_train[:2]","5abf231c":"tokenized_sent_test[:2]","1455fb13":"tokenized_sent_all = tokenized_sent_train + tokenized_sent_test","d353d26d":"# Auxiliar function to bypass the tokenizer, as this step had already been done\n\ndef identity_tokenizer(text):\n    return text\n\ntfidf_all = TfidfVectorizer(tokenizer=identity_tokenizer, stop_words='english', lowercase=False)    \ntfidf_all_fit = tfidf_all.fit_transform(tokenized_sent_all)\n\ntfidf_all.get_feature_names()[1000:1002]\n","33179831":"# Creating an unified dataframe. The firs 'n' lines there are data about the train dataset, and on the 'm' following\n# lines we have data from the test dataset. 'm' is the number of train documents and 'n' is the number of test \n# documents.\n\ntfidf_all_df = pd.DataFrame(tfidf_all_fit.toarray(), columns=tfidf_all.get_feature_names())","8cbdbe9a":"tfidf_all_df.head()","e62b5a9d":"# Splitting the aggregated dataframe into train and test\n\ntfidf_train_df = tfidf_all_df[:len(train)]\n\ntfidf_test_df = tfidf_all_df[len(train):]\n","bae9e1ec":"# Including target column on the TF-IDF train dataset\n\ntfidf_train_df[\"target_column\"] = train['target']","58b6ea35":"from sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split, cross_val_score\n\nX = tfidf_train_df.drop(\"target_column\", axis=1)\ny = tfidf_train_df[\"target_column\"]\n\n# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=16)\n\nclf = LogisticRegression(random_state=16)\n\nscores_logistic = cross_val_score(clf, X, y, cv=5)","373f1aee":"scores_logistic.mean()","606b78d5":"from sklearn.metrics import accuracy_score\n\nclf.fit(X,y)\n\ny_pred = clf.predict(X)\n\nprint('Training accuracy is {}'.format(accuracy_score(y, y_pred)))","197146c0":"# Submission 0.78547\n\nsample_submission = pd.read_csv('..\/input\/nlp-getting-started\/sample_submission.csv')\n\ny_sub = clf.predict(tfidf_test_df)","fcc4b654":"sub = sample_submission.copy()\nsub['target'] = y_sub\nsub.set_index('id',inplace=True)","e7b72738":"sub.head()","4abcfa61":"sub.to_csv(\".\/sub_01.csv\")","cf91b4e3":"from sklearn.feature_selection import mutual_info_classif, chi2\n\n# mi = mutual_info_classif(tfidf_train_df_int.drop(\"target_column\", axis=1), tfidf_train_df_int[\"target_column\"])\n# mi = pd.Series(mi)\n# mi.index = intersect_columns\n# mi.sort_values(ascending=False, inplace=True) \n\nchi = chi2(X,y)\nchi = pd.Series(chi[0])\nchi.index = X.columns\nchi.sort_values(ascending=False, inplace=True)    \n","1c85a367":"chi[:5]","69a8a3cb":"chi.to_csv(\".\/chi.csv\")","445df20f":"atts = np.linspace(100,10000,100)\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=16)\n\n","750143d4":"clf.fit(X_train[chi[:3800].index],y_train)\n\ny_pred = clf.predict(X_test[chi[:3800].index])\n\nacc = accuracy_score(y_test , y_pred)","8b2a58ea":"y_sub_chi = clf.predict(tfidf_test_df[chi[:3800].index])","0044268d":"sub_chi = sample_submission.copy()\n\nsub_chi['target'] = y_sub_chi\n\nsub_chi.set_index('id',inplace=True)","772e155b":"# Chi^2 feature selection submission\n\nsub_chi.to_csv(\".\/sub_chi.csv\")","468b0cba":"from sklearn.svm import SVC\n\nclf_svc = SVC()\nclf_svc.fit(X_train[chi[:3800].index],y_train)\ny_pred = clf_svc.predict(X_test[chi[:3800].index])\nacc = accuracy_score(y_test , y_pred)\n\nprint('Training accuracy is {}'.format(acc))","39c7dcfa":"clf_svc.fit(tfidf_train_df[chi[:3800].index],y)","316660da":"y_sub_svc = clf_svc.predict(tfidf_test_df[chi[:3800].index])","f1b8cb02":"sub_svc = sample_submission.copy()\nsub_svc['target'] = y_sub_svc\nsub_svc.set_index('id',inplace=True)\n\nsub_svc.to_csv(\".\/sub_svc_overfit.csv\")","2a2f9e26":"# atts = [1000,3000,5000]\n# list_scores_svc = []\n\n# for att in tqdm(atts):\n#     clf_svc.fit(X_train[chi[:int(att)].index],y_train)\n#     y_pred = clf_svc.predict(X_test[chi[:int(att)].index])\n#     acc = accuracy_score(y_test , y_pred)\n    \n#     list_scores_svc.append(acc)","2b8770c0":"import spacy \n\nnlp = spacy.load('en_core_web_lg')\n\nwith nlp.disable_pipes():\n    train_vecs = pd.DataFrame(np.array([nlp(text).vector for text in train.text])) # doc vectors for training set\n    test_vecs = pd.DataFrame(np.array([nlp(text).vector for text in test.text])) # doc vectors for testing set","e1cb96ea":"mi = mutual_info_classif(train_vecs,train.target)\nmi = pd.Series(mi)\nmi.index = train_vecs.columns\nmi.sort_values(ascending=False, inplace=True)    ","8768c1ce":"X_word_vec_train, X_word_vec_test, y_word_vec_train, y_word_vec_test = train_test_split(train_vecs, train.target.values, test_size=0.33, random_state=16)","b163c305":"svc = SVC()\n\natts = np.linspace(1, 299, 299)\nlist_scores_svc = []\n\nfor att in tqdm(atts):\n    svc.fit(X_word_vec_train[mi[:int(att)].index].values, y_word_vec_train)\n    y_pred = svc.predict(X_word_vec_test[mi[:int(att)].index].values)\n    acc = accuracy_score(y_word_vec_test , y_pred)\n    \n    list_scores_svc.append(acc)","26ab1411":"import seaborn as sns\nimport matplotlib.pyplot as plt\n\nint_atts = [int(att) for att in atts]\n\nsns.set()\nplt.figure(figsize=(14,7))\nsns.lineplot(y=list_scores_svc, x=atts)\nplt.show()","c2a0eba5":"svc.fit(train_vecs.values, train.target)\ny_pred = svc.predict(test_vecs.values)\n\nsub_svc = sample_submission.copy()\nsub_svc['target'] = y_pred\nsub_svc.set_index('id',inplace=True)\n\nsub_svc.to_csv(\".\/sub_svc_word_vec.csv\")","5bf9582a":"![Logo](https:\/\/raw.githubusercontent.com\/marcelo-campa\/Analytica-Kaggle-NLP\/main\/img\/logo_desafio.png)","f86c6d27":"The `'Keyword'` column has some potential, as it hasn't much missing values. However, we will start our analysis with solutions focused on the content of documents.","1e6c7f61":"As a way to try to reduce the overfit and improve the performance of our classifier, we chose to use the $\\chi^{2}$ and Mutual Information scores in order to select the most \"important\" variables for our model, reducing also the dimensionality of the problem.","f4de5302":"### Suppor Vector Classifier (SVC)","ae6f92e9":"## TF-IDF\n\nThe TF-IDF (Term Frequency - Inverse Document Frequency) is a numerical statistic that gives us the importance of a given word in a set of documents (corpus). Intuitively, a word (token) has a high TF-IDF score if\n\n- It has a high number of occurrences on a single document\ne\n- It has a low number of ocurrences on all documents\n\nThis 'number' is a result of the product of the 'TF' and the 'IDF', which are calculated as follows\n\n\\begin{align}\n    \\operatorname{tf}(t, d)&=\\frac{f_{t, d}}{\\sum_{t^{\\prime} \\in d} f_{t^{\\prime}, d}}\\\\\\\\\n    \\operatorname{idf}(t, D)&=\\log \\frac{N}{|\\{d \\in D: t \\in d\\}|}\\\\\\\\\n    \\operatorname{tfidf}(t, d, D)&=\\operatorname{tf}(t, d) \\cdot \\operatorname{idf}(t, D)\n\\end{align}\n\nAll terms can be seen in depth on [this link](https:\/\/en.wikipedia.org\/wiki\/Tf%E2%80%93idf).\n\nNow, let's apply the TF-IDF.","61d2732c":"We noticed a considerable gap between the cross-validation scores and the accuracy score. We note that this may have to do with overfit, when we train on the entire training dataset, and underfit when we separate the training and testing, datasets as we train with much smaller data.\n\nThe submission to Kaggle gave us a public score of 78,547%","fe153907":"Tokenizers are tools that helps us transforming sentences into separate words. As an example, the sentence `'Three people died from the heat wave so far'`, picked from the train dataset, is transformed in a list, in which every word is a token. The result is\n\n```['Three', 'people', 'died', 'from', 'the', 'heat', 'wave', 'so', 'far']```\n","ef84223f":"## Default Tokenizer","77ede0b5":"We can see the difference of the tokenizers. On this one, we observe that the tokenization of hashtags were improved.","f4faf09d":"Note that because TF-IDF was done on all documents both from the train and test datasets, we calculate the scores by treating this aggregated list as a new corpus. This is positive as we will have this score based on more data, tending to give us a more realistic information.\n","b8cbf114":"# Natural Language Processing with Disaster Tweets Challenge","1db8ebfa":"### Logistic Regression","bc96a2db":"We will create a list of lists containing all tokenized tweets from both training and testing. This is a way to ensure an unified analysis by TF-IDF, which will be explained later.","695722a3":"## To-Do\n\n- Test other models ( NaiveBayes, RidgeClassifier, ...)\n- Use GridSearch to tune Hyperparameters\n","d85a72bd":"Having in mind the solution through tokenization with TF-IDF, let's now move on to another type of abstraction, the Word Vectors. This abstraction allows us to map words as multidimensional vectors, indicating the mapping of that word not only in terms of quantity like TF-IDF, but also taking context into account.\n\nAs an example, the image below represents the two most important coordinates of a series of 300 dimension word vectors (which represent words in a given context).\n\n<img src=\"https:\/\/raw.githubusercontent.com\/marcelo-campa\/Analytica-Kaggle-NLP\/main\/img\/word_vectors_map.png\" alt=\"Vetor de Palavras\" width=\"600\"\/>\n\nCredits to [this website](https:\/\/dzone.com\/articles\/introduction-to-word-vectors).\n","7cf03b3e":"The Brazilian Portuguese version of this notebook can be found on [this link](https:\/\/github.com\/marcelo-campa\/Analytica-Kaggle-NLP) \n\nThe [challenge](https:\/\/www.kaggle.com\/c\/nlp-getting-started) consists of a text classification problem. More specifically, it deals with tweets classification, which can be related to real disasters or not. For this, we will use Natural Language Processing (NLP) tools, as well as Machine Learning.\n\nOn this notebook, we'll deal with\n\n- \"Tweet Tokenizer\" for tweets tokenization \n- \"Word Vectors\"\n- SVC and Logistic Regression as classifiers\n\nWe'll also explain future improvements at the end of this document. Some parts were inspired by [this notebook](https:\/\/www.kaggle.com\/pranjalchatterjee\/word-vectors-svc-on-nlp-with-disaster-tweets) from @pranjalchatterjee ","8d977773":"# Word Vectors","4266d8fe":"## Tweet tokenizer","4bdf9ea3":"The tokenizer mentioned above was made with common texts in mind. However, we know that tweets have their own characteristics, such as the use of emojis, hashtags and various abbreviations.\n\nWith that in mind, we opted to test the Tweet Tokenizer, a tokenizer in the NLTK library optimized for analyzing Twitter texts.","afef0045":"## Classifiers","9608e279":"# Feature Selection"}}