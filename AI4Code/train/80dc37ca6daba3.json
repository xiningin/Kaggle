{"cell_type":{"efa2ae9c":"code","11587b5b":"code","fd7eb982":"code","14828e6a":"code","22d3e49e":"code","09a4e641":"code","b9331154":"code","81cd0572":"code","67f4d262":"code","39bc3715":"code","618a5e00":"code","10fd6b43":"code","51a61839":"code","2a4b2533":"code","3522bde7":"code","4e7e5d32":"code","a401f218":"code","695fc6ef":"code","c2dc52c5":"code","f66f9e6a":"code","a90b99d1":"code","02105508":"code","8f8951b8":"code","f5bdbd55":"code","17641026":"code","cf10c0e4":"code","3a202702":"code","0a156ade":"code","b0e62c07":"code","80f3ed3a":"code","c97b0816":"code","2dc7909f":"code","648e59f0":"code","8014bdd6":"code","9e090f8e":"code","fe6e4011":"code","36be4e5b":"code","5126a6b6":"code","925e1cb0":"code","d4ecfbc9":"code","e7ba7c5a":"code","59a46197":"code","fb3cc8a2":"code","873184df":"code","ee3442bb":"code","86b490e9":"code","0886f2d9":"code","5a89470c":"code","8839599b":"code","d50aa60f":"code","c803f83f":"code","29eef764":"code","ae036317":"code","633675c6":"code","2e627a50":"code","a3780a69":"code","2c2a1350":"code","d95d50a5":"code","e875c5a5":"code","b991351e":"code","4b9e6b2e":"code","f490cdf9":"code","36901cae":"code","f9cde803":"code","4e419f81":"code","e467c14d":"code","3124a4b5":"code","05e4c84f":"code","43ccf381":"code","c879271f":"code","7892eebb":"code","585384b4":"code","a7986a43":"code","0d887814":"code","0c68b333":"markdown","79143841":"markdown","13279b45":"markdown","36037ba4":"markdown","a8e68f84":"markdown","97807c64":"markdown","7493f326":"markdown","72878b2b":"markdown","b0ca7ed0":"markdown","0960f846":"markdown","968be083":"markdown","59c0f016":"markdown","05c2df8f":"markdown","5fa897aa":"markdown","6c445b42":"markdown","331f88b2":"markdown","92dd2dd3":"markdown","fb47bb5b":"markdown","9d320ab8":"markdown","d06bfce6":"markdown","c27ccb3b":"markdown","0ce7c71c":"markdown"},"source":{"efa2ae9c":"import numpy as np # linear algebra\nimport pandas as pd\nimport re\n\nfrom itertools import combinations\n\nimport dask.dataframe as dd\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom IPython.display import display\n\nfrom plotly.offline import iplot\nimport plotly as py\nfrom plotly import tools\nimport plotly.express as px\n\nimport cufflinks as cf\ncf.go_offline()\ncf.set_config_file(offline = False, world_readable = True)\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder, LabelBinarizer\nfrom sklearn.metrics import accuracy_score, auc, f1_score, classification_report\n\nplt.rcParams[\"figure.figsize\"] = (12, 8)\nplt.rcParams['axes.titlesize'] = 16\nsns.set_palette('Set3_r')\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nimport warnings\nwarnings.simplefilter('ignore')\n\nfrom time import time, strftime, gmtime\nstart = time()\nimport datetime\nprint(str(datetime.datetime.now()))","11587b5b":"users = dd.read_csv('\/kaggle\/input\/movielens-case-studyuniversity-of-minnesota\/Data science with Python 1\/users.dat', sep = '::')\nusers.columns = ['UserID', 'Gender', 'Age', 'Occupation', 'Zip-code']\nusers.head()","fd7eb982":"ratings = dd.read_csv('\/kaggle\/input\/movielens-case-studyuniversity-of-minnesota\/Data science with Python 1\/ratings.dat', sep = '::', )\nratings.columns = ['UserID', 'MovieID', 'Rating', 'Timestamp']\nratings.head()","14828e6a":"movies = dd.read_csv('\/kaggle\/input\/movielens-case-studyuniversity-of-minnesota\/Data science with Python 1\/movies.dat', \n                     sep = '::', encoding = 'latin-1')\nmovies.columns = ['MovieID','Title','Genres']\nmovies.head()","22d3e49e":"titles_map = dict(zip(movies['MovieID'], movies['Title']))","09a4e641":"df = dd.merge(movies, ratings, on = 'MovieID', how = 'left')\ndf.head()","b9331154":"df = dd.merge(df, users, on = 'UserID', how = 'inner')\ndf.head()","81cd0572":"df = df.compute()\nprint(df.shape)\ndf.head()","67f4d262":"df.describe().T","39bc3715":"df.info()","618a5e00":"print(f\"No. of unique MovieID: {df['MovieID'].nunique()}\")\nprint(f\"No. of unique MovieID: {df['Title'].nunique()}\")\n\nprint(f\"No. of unique UserID: {df['UserID'].nunique()}\")\nprint(f\"No. of unique Ratings: {df['Rating'].nunique()}\")","10fd6b43":"ax = sns.countplot(data = df, x = 'Rating')\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), (p.get_x() * 1.005, p.get_height() * 1.005))\nplt.title('Ratings CountPlot');","51a61839":"ax = sns.countplot(data = df, x = 'Gender')\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), (p.get_x() * 1.005, p.get_height() * 1.005))\nplt.title('Gender CountPlot');","2a4b2533":"ax = sns.countplot(data = df, x = 'Occupation')\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), (p.get_x() * 1.005, p.get_height() * 1.005))\nplt.title('Occupation CountPlot');","3522bde7":"genre = pd.DataFrame(df['Genres'].str.split('|', expand = True))\ngenre.columns = ['Genre_1', 'Genre_2', 'Genre_3', 'Genre_4', 'Genre_5', 'Genre_6']\ngenre.head(2)","4e7e5d32":"#Join with orignal df\n#df = df.drop('Genres', axis = 1)\ndf = df.join(genre)","a401f218":"regex = re.compile(r\"\\((\\d+)\\)\")\ndf['year_of_release'] = df['Title'].apply(lambda x: regex.findall(x)[0])\ndf.head()","695fc6ef":"df['total_words'] = df['Title'].apply(lambda x: len(x.split()) - 1)\nsns.distplot(df['total_words']);","c2dc52c5":"avg_rating = pd.pivot_table(data = df, values = 'Rating', columns = 'MovieID', aggfunc = 'mean').T\navg_rating.columns = avg_rating.columns.ravel()\n#avg_rating = avg_rating.sort_values(by = 'Rating', ascending = False)","f66f9e6a":"df['Age'].unique()","a90b99d1":"print(f\"No. of Titles with top rating (>= 3.5) {len(avg_rating[avg_rating['Rating'] >= 3.5])}\")\nprint(f\"No. of Titles with low rating (<= 2.5) {len(avg_rating[avg_rating['Rating'] <= 2.5])}\")","02105508":"print(f\"Random 20 Titles with Highest Ratings: \")\n[titles_map[x] for x in avg_rating[avg_rating['Rating'] >= 4.0].sample(20).index]","8f8951b8":"print(f\"Random 20 Titles with High Ratings: \")\n[titles_map[x] for x in avg_rating[avg_rating['Rating'] >= 3.5].sample(20).index]","f5bdbd55":"print(f\"Random 20 Titles with Low Ratings: \")\n[titles_map[x] for x in avg_rating[avg_rating['Rating'] <= 2.5].sample(20).index]","17641026":"print(f\"Random 20 Titles with Lowest Ratings: \")\n[titles_map[x] for x in avg_rating[avg_rating['Rating'] <= 1.0].sample(20).index]","cf10c0e4":"pd.pivot_table(data = df, index = 'Rating', \n               values = 'Age', \n               aggfunc = 'mean').iplot(kind = 'line', theme = 'pearl', \n                                       title = 'Average Age of Users giving the Ratings', \n                                       xTitle = 'Rating',\n                                       yTitle = 'Avg. Age',\n                                      asFigure = True)","3a202702":"fig_array = []\nfig1 = pd.pivot_table(data = df[df['Gender'] == 'M'], index = 'Rating', \n               values = 'Age', \n               aggfunc = 'mean').figure(kind = 'line', color = 'red', xTitle = 'Rating',\n                                       yTitle = 'Avg. Age')\nfig_array.append(fig1)\n\nfig2 = pd.pivot_table(data = df[df['Gender'] == 'F'], index = 'Rating', \n               values = 'Age', \n               aggfunc = 'mean').figure(kind = 'line', color = 'teal', xTitle = 'Rating',\n                                       yTitle = 'Avg. Age')\nfig_array.append(fig2)\n\nfig = cf.subplots(fig_array, shape = (1, 2), subplot_titles = ['Avg. Age of Men giving Ratings', \n                                                               'Avg. Age of Women giving Ratings'])\nfig['layout'].update(showlegend = False)\niplot(fig)","0a156ade":"df.groupby('year_of_release')['Title'].nunique().sort_values().iplot(kind = 'bar', \n                                                       color = 'purple', \n                                                       title = 'Num of Movie release per year',\n                                                        xTitle = 'Release Year',\n                                                       yTitle = 'Count')","b0e62c07":"df.groupby('Genre_1')['Title'].nunique().sort_values().iplot(kind = 'bar', \n                                                       color = 'green', \n                                                       title = 'Movie release by Genre - Main', \n                                                        xTitle = 'Genre',\n                                                        yTitle = 'Count')","80f3ed3a":"df.groupby(['Genre_1', 'Genre_2'])['Title'].nunique().sort_values(ascending = False).iplot(kind = 'bar', \n                                                            orientation = 'h',\n                                                       color = 'green', \n                                                       title = 'Movie release by Genre - Sub1', \n                                                        xTitle = 'Count',\n                                                        yTitle = 'Genre1-Genre2')","c97b0816":"ratings_year = df.groupby(['Rating', 'year_of_release'])['Title']","2dc7909f":"fig_array = []\nfig1 = ratings_year.nunique()[1.0][:].sort_values().figure(kind = 'bar', color = 'purple')\nfig_array.append(fig1)\n\nfig2 = ratings_year.nunique()[5.0][:].sort_values().figure(kind = 'bar', color = 'green')\nfig_array.append(fig2)\n\nfig = cf.subplots(fig_array, shape = (1, 2), subplot_titles = ['Num of Releases\/year with Rating 1.0', \n                                                               'Num of Releases\/year with Rating 5.0'])\nfig['layout'].update(showlegend = False)\niplot(fig)","648e59f0":"def visualization_helper(year = None):\n    colors = ['green', 'purple', 'blue', 'red', 'orange']\n    ratings_list = [5.0, 4.0, 3.0, 2.0, 1.0]\n    if year:\n        df_year = df[df['year_of_release'] == year]\n    else:\n        df_year = df\n        year = 'dataset'\n    fig_array = []\n    title_list = []\n    for i, r in enumerate(ratings_list):\n        #Movies with rating\n        fig = df_year[df_year['Rating'] == r]['Title'].value_counts()[:20].figure(kind = 'bar', color = colors[i], \n                                                                                 orientation = 'h')\n        fig_array.append(fig)\n        title_list.append(f\"Top 20 movies of {year} with Rating {r}\")\n\n    fig = cf.subplots(fig_array, shape = (5, 1),\n                      subplot_titles = title_list, vertical_spacing = 0.05)\n    \n    # Adjust height and add overall title\n    fig['layout']['height'] = len(ratings_list) * 250\n    #fig['layout']['width'] = \n    fig['layout']['title'] = 'Movie Rating by Users'\n    \n    fig['layout'].update(showlegend = False)\n    iplot(fig)","8014bdd6":"visualization_helper()","9e090f8e":"visualization_helper('1998')","fe6e4011":"def visualization_combo1(year = None):\n    colors = ['green', 'purple', 'blue', 'red', 'orange', 'teal', 'grey']\n    ratings_list = [5.0, 4.0, 3.0, 2.0, 1.0]\n    rating_combo = list(combinations(ratings_list, 2))\n    if year:\n        df_year = df[df['year_of_release'] == year]\n    else:\n        df_year = df\n        year = 'dataset'\n    fig_array = []\n    title_list = []\n    for i, r in enumerate(rating_combo):\n        #Movies with rating\n        fig = df_year[(df_year['Rating'] == r[0]) | (df_year['Rating'] == r[1])]['Title'].value_counts()[:20].figure(kind = 'bar', \n                                                                                                                     color = np.random.choice(colors, 1)[0], \n                                                                                                                     orientation = 'h')\n        fig_array.append(fig)\n        title_list.append(f\"Top 20 movies of {year} with Ratings {r[0]}, {r[1]}\")\n\n    fig = cf.subplots(fig_array, shape = (len(rating_combo), 1),\n                      subplot_titles = title_list, vertical_spacing = 0.03)\n    \n    # Adjust height and add overall title\n    fig['layout']['height'] = len(rating_combo) * 200\n    #fig['layout']['width'] = \n    fig['layout']['title'] = 'Movie with 2 Ratings by Users'\n    \n    fig['layout'].update(showlegend = False)\n    iplot(fig)","36be4e5b":"visualization_combo1('1988')","5126a6b6":"def visualization_combo2(year = None):\n    colors = ['green', 'purple', 'blue', 'red', 'orange', 'teal', 'grey']\n    ratings_list = [5.0, 4.0, 3.0, 2.0, 1.0]\n    rating_combo = list(combinations(ratings_list, 3))\n    if year:\n        df_year = df[df['year_of_release'] == year]\n    else:\n        df_year = df\n        year = 'dataset'\n    fig_array = []\n    title_list = []\n    for i, r in enumerate(rating_combo):\n        #Movies with rating\n        fig = df_year[(df_year['Rating'] == r[0]) | (df_year['Rating'] == r[1]) | (df_year['Rating'] == r[2])]['Title'].value_counts()[:20].figure(kind = 'bar', \n                                                                                                                     color = np.random.choice(colors, 1)[0], \n                                                                                                                     orientation = 'h')\n        fig_array.append(fig)\n        title_list.append(f\"Top 20 movies of {year} with Ratings {r[0]}, {r[1]}, {r[2]}\")\n\n    fig = cf.subplots(fig_array, shape = (len(rating_combo), 1),\n                      subplot_titles = title_list, vertical_spacing = 0.03)\n    \n    # Adjust height and add overall title\n    fig['layout']['height'] = len(rating_combo) * 200\n    #fig['layout']['width'] = \n    fig['layout']['title'] = 'Movie with 3 Ratings by Users'\n    \n    fig['layout'].update(showlegend = False)\n    iplot(fig)","925e1cb0":"visualization_combo2('2000')","d4ecfbc9":"def visualization_combo3(year = None):\n    colors = ['green', 'purple', 'blue', 'red', 'orange', 'teal', 'grey']\n    ratings_list = [5.0, 4.0, 3.0, 2.0, 1.0]\n    rating_combo = list(combinations(ratings_list, 4))\n    if year:\n        df_year = df[df['year_of_release'] == year]\n    else:\n        df_year = df\n        year = 'dataset'\n    fig_array = []\n    title_list = []\n    for i, r in enumerate(rating_combo):\n        #Movies with rating\n        fig = df_year[(df_year['Rating'] == r[0]) | (df_year['Rating'] == r[1]) | (df_year['Rating'] == r[2]) | (df_year['Rating'] == r[3])]['Title'].value_counts()[:20].figure(kind = 'bar', \n                                                                                                                     color = np.random.choice(colors, 1)[0], \n                                                                                                                     orientation = 'h')\n        fig_array.append(fig)\n        title_list.append(f\"Top 20 movies of {year} with Ratings {r[0]}, {r[1]}, {r[2]}, {r[3]}\")\n\n    fig = cf.subplots(fig_array, shape = (len(rating_combo), 1),\n                      subplot_titles = title_list, vertical_spacing = 0.04)\n    \n    # Adjust height and add overall title\n    fig['layout']['height'] = len(rating_combo) * 200\n    #fig['layout']['width'] = \n    fig['layout']['title'] = 'Movie with 4 Ratings by Users'\n    \n    fig['layout'].update(showlegend = False)\n    iplot(fig)","e7ba7c5a":"visualization_combo3(year = '1977')","59a46197":"df['Title'].value_counts()[:20].iplot(kind = 'bar', \n                                        color = 'grey', \n                                        orientation = 'h',\n                                        title = 'Movies with highest number of Rating', \n                                        xTitle = 'Num of Rating', \n                                        yTitle = 'Movie Title')","fb3cc8a2":"age_map = {1: 'Under 18', 18: '18 - 24', 25: '25 - 34', 35: '35 - 44', 45: '45 - 59', 50: '50 - 55', 56: '56+'}\ndf['Age'] = df['Age'].map(age_map)","873184df":"age_count = df.groupby('Age')['Title'].count()\nage_count.iplot(kind = 'bar', \n               xTitle = 'Age Group',\n               yTitle = 'Num of Movies Watched',\n               title = 'Which Age group watches more movies?')","ee3442bb":"age_title = df.groupby('Age')['Title'].unique()","86b490e9":"import itertools\nimport collections\nfrom collections import Counter\n\nfrom wordcloud import WordCloud\n\ndef plot_wordcloud(data, text = None):\n    #all_words = [word for each in data for word in each.split(' ')]\n    word_freq = Counter(data)\n\n    wordcloud = WordCloud(width = 900,\n                          height = 500,\n                          max_words = 200,\n                          max_font_size = 100,\n                          relative_scaling = 0.5,\n                          background_color = \"rgba(255, 255, 255, 0)\", \n                          mode = \"RGBA\",\n                          normalize_plurals = True).generate_from_frequencies(word_freq)\n    plt.figure(figsize = (18, 16))\n    plt.imshow(wordcloud, interpolation = 'bilinear')\n    plt.title(text, fontsize = 20, color = 'gray', y = 1.05)\n    plt.axis(\"off\")\n    plt.show()","0886f2d9":"plot_wordcloud(age_title['Under 18'], text = 'Movies watched by Under 18s')","5a89470c":"plot_wordcloud(age_title['25 - 34'], text = 'Movies watched by Age Group 25 - 34')","8839599b":"fig = px.bar(x = df['UserID'].value_counts().index[:20].astype(str), y = df['UserID'].value_counts().values[:20], \n            labels = {'x': 'UserID', 'y': 'Num of Movies Watched'}, \n             title = 'Top 20 Users with number of Movies Watched'\n            )\nfig.show()","d50aa60f":"occupation_map = {0: \"other\",\n1: \"academic\/educator\",\n2: \"artist\",\n3: \"clerical\/admin\",\n4: \"college\/grad student\",\n5: \"customer service\",\n6: \"doctor\/health care\",\n7: \"executive\/managerial\",\n8: \"farmer\",\n9: \"homemaker\",\n10: \"K-12 student\",\n11: \"lawyer\",\n12: \"programmer\",\n13: \"retired\",\n14: \"sales\/marketing\",\n15: \"scientist\",\n16: \"self-employed\",\n17: \"technician\/engineer\",\n18: \"tradesman\/craftsman\",\n19: \"unemployed\",\n20: \"writer\"}\n\ndf['Occupation'] = df['Occupation'].map(occupation_map)","c803f83f":"occupation_count = df['Occupation'].value_counts()\noccupation_count.iplot(kind = 'bar', xTitle = \"Users' Occupation\", \n                      yTitle = 'Num of Movies Wathced', \n                      title = 'Num of Movies watched by Occupation')","29eef764":"df.groupby('Occupation')['Age'].unique()","ae036317":"age_genres = df.groupby('Age')['Genres'].unique()","633675c6":"plot_wordcloud(age_genres['Under 18'], text = 'Genres watched by Under 18s')","2e627a50":"plot_wordcloud(age_genres['56+'], text = 'Genres watched by 56+')","a3780a69":"df.head(2)","2c2a1350":"df.drop(['Timestamp', 'Zip-code', 'Genres'], axis = 1, inplace = True)\ndf.shape","d95d50a5":"#Change dtype of UserID\ndf['UserID'] = df['UserID'].astype(str)","e875c5a5":"for c in ['UserID', 'MovieID', 'year_of_release', 'Occupation']:\n    print(f\"Frequency Encoding: {c} - {df[c].nunique()}\")\n    freq = df[c].value_counts()\n    df[c] = df[c].apply(lambda x: freq[x])","b991351e":"for c in ['Gender', 'Age', 'Genre_1', 'Genre_2', 'Genre_3', 'Genre_4', 'Genre_5', 'Genre_6', 'Rating']:\n    print(f\"Label Encoding: {c} - {df[c].nunique()}\")\n    le = LabelEncoder()\n    df[c] = le.fit_transform(df[c])","4b9e6b2e":"#For now we don't use the Title feature (we can vectorize the text and use it)\n#df = df.drop(['Title'], axis = 1)\ndf.shape","f490cdf9":"from nltk.corpus import stopwords\nfrom sklearn.feature_extraction.text import TfidfVectorizer","36901cae":"tfid = TfidfVectorizer(max_features = 8, analyzer = 'word', stop_words = 'english', \n                      binary = False, ngram_range = (1, 2))\ntitle_vectors = pd.DataFrame(tfid.fit_transform(df['Title']).toarray(), \n                          columns = ['nc_{}'.format(i) for i in range(8)])\ntitle_vectors.head()","f9cde803":"#Drop the Title feature\ndf = df.drop('Title', axis = 1)\n\n#join title vectors with original df\ndf = pd.concat([df, title_vectors], axis = 1)\ndf.shape","4e419f81":"df = df.sample(frac = 0.1).reset_index(drop = True) #Running the model on 10% data\ndf.shape","e467c14d":"Xtrain, Xvalid, ytrain, yvalid = train_test_split(df.drop('Rating', axis = 1), df['Rating'], test_size = 0.3, stratify = df['Rating'])\nXtrain.shape, ytrain.shape, Xvalid.shape, yvalid.shape","3124a4b5":"import lightgbm as lgbm\n\nparams = {\n          \"objective\" : \"multiclass\",\n          \"num_class\" : 5,\n          \"num_leaves\" : 100,\n          \"max_depth\": -1,\n          \"learning_rate\" : 0.01,\n          \"bagging_fraction\" : 0.9,  # subsample\n          \"feature_fraction\" : 0.9,  # colsample_bytree\n          \"bagging_freq\" : 5,        # subsample_freq\n          \"bagging_seed\" : 2021,\n          \"verbosity\" : -1 }","05e4c84f":"import xgboost as xgb\nfrom xgboost import plot_importance, plot_tree\n\nparams = {\n     'eta': 0.3,  \n     'objective': 'multi:softprob',  # error evaluation for multiclass tasks\n     'num_class': 5,  # number of classes to predic\n     'colsample_bytree': 0.55,\n     'subsample': 0.7,\n     'learning_rate': 0.015,\n     'max_depth': 9,\n     'seed': 2020, \n     'min_child_weight': 257\n    }  \nnum_round = 15000\n\nxtrain = xgb.DMatrix(Xtrain, label = ytrain)\nxvalid = xgb.DMatrix(Xvalid, label = yvalid)\n\nmodel = xgb.train(params, xtrain, num_round, verbose_eval = 500,\n                              evals = [(xtrain, 'train'), (xvalid, 'valid')],\n                              early_stopping_rounds = 100)\n\nplot_importance(model)","43ccf381":"xpreds = model.predict(xvalid)\nprint(np.argmax(xpreds, axis = 1))","c879271f":"print(classification_report(yvalid, np.argmax(xpreds, axis = 1)))","7892eebb":"import shap\n\nshap.initjs()","585384b4":"explainer = shap.TreeExplainer(model)\nshap_values = explainer.shap_values(Xvalid)","a7986a43":"shap.summary_plot(shap_values, Xvalid)","0d887814":"finish = time()\nprint(strftime(\"%H:%M:%S\", gmtime(finish - start)))","0c68b333":"Ratings for the full dataset","79143841":"Since the Categorical Features have high cardinality, it's better we choose Frequency\/Mean Encoding instead of simple Label Encoding or One-Hot Encoding.\n- Label Encoding is not recommended for high cardinal features\n- One-Hot Encoding will lead to high dimensionality for high cardinality features\n- We try Frequency Encoding first below","13279b45":"- Highest number of releases happened in 1998","36037ba4":"## Frequency Encoding\n__Frequency Encoding__ is nothing but getting each category's count in the dataset and mapping that count to it","a8e68f84":"Map Occupation integer to their respective Occupations","97807c64":"#### Convert dask dataframe to pandas df","7493f326":"From above its clear that there is mismatch between age groups and respective occupation. For eg. age group 35-44, 56+, 25-34 are in K-12 Occupation category, there are Under 18s in lawyer, retired category.","72878b2b":"# Label Encoding Categorical and Target Features","b0ca7ed0":"## Task\n\n1. Explore the datasets using visual representations (graphs or tables)\n2. Feature Engineering\n3. Determine the features affecting the ratings of any particular movie\n4. Develop an appropriate model to predict the movie ratings","0960f846":"Let's check the 'Other' group","968be083":"#### Merge 3 dataframes into single dataset","59c0f016":"##### Movies with high\/low Ratings","05c2df8f":"Let's check the user ratings received by movies released in 1998","5fa897aa":"# Conclusion\n1. Movie ID which is at endocing of movie names is the major influencer in deciding the Ratings\n2. Year of Release is the 2nd most the influencer followed by the main Genre\n3. The title vectors (TFIDF) doesn't influence the Ratings while length of the movie title has some effect\n\n## Top 3 Features:\n1. Movie ID\n2. year_of_release\n3. Genre 1","6c445b42":"Mapping Age to thier category","331f88b2":"#### Feature Engineering\n\n- Create Sub Genres from Genre feature\n- Create new year of release feature from Titles\n- Numerical feature from Title","92dd2dd3":"## Label Encoding","fb47bb5b":"#### Read dataset as dask dataframes to avoid memory issue while merging","9d320ab8":"# Simple Modeling","d06bfce6":"%%time\nltrain = lgbm.Dataset(Xtrain, ytrain)\nlvalid = lgbm.Dataset(Xvalid, yvalid)\n\nclf = lgbm.train(params, ltrain, 20000, valid_sets = [ltrain, lvalid], \n                early_stopping_rounds = 100, verbose_eval = 500)\npreds = clf.predict(Xvalid)\nprint(classification_report(yvalid, np.argmax(preds, axis = 1)))","c27ccb3b":"#### Number of movie releases per year","0ce7c71c":"#### Number of movie releases by Genre"}}