{"cell_type":{"e99cdf78":"code","ac8d7c47":"code","0f26c589":"code","87991b1e":"code","484b678e":"code","617710d7":"code","df449250":"code","675047b8":"code","a6e41666":"code","0ecbd42b":"code","52422efd":"markdown","5f5b4ed5":"markdown","d5865df4":"markdown","bf02a6c1":"markdown","32c750db":"markdown","a02be2ad":"markdown","b874b5e5":"markdown","814225d7":"markdown","fd50d2c7":"markdown","32788ce8":"markdown","fe98924b":"markdown"},"source":{"e99cdf78":"def cooks_agent(obs, config): \n    import random\n    import numpy as np\n\n    # Gets board at next step if agent drops piece in selected column\n    def drop_piece(grid, col, mark, config):\n        next_grid = grid.copy()\n        for row in range(config.rows-1, -1, -1):\n            if next_grid[row][col] == 0:\n                break\n        next_grid[row][col] = mark\n        return next_grid\n\n    # Helper function for get_heuristic: checks if window satisfies heuristic conditions\n    def check_window(window, num_discs, piece, config):\n        return (window.count(piece) == num_discs and window.count(0) == config.inarow-num_discs)\n\n    # Helper function for get_heuristic: counts number of windows satisfying specified heuristic conditions\n    def count_windows(grid, num_discs, piece, config):\n        num_windows = 0\n        # horizontal\n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[row, col:col+config.inarow])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(grid[row:row+config.inarow, col])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if check_window(window, num_discs, piece, config):\n                    num_windows += 1\n        return num_windows\n\n    def get_heuristic(grid, mark, config):\n        num_threes = count_windows(grid, 3, mark, config)\n        num_fours = count_windows(grid, 4, mark, config)\n        num_threes_opp = count_windows(grid, 3, mark%2+1, config)\n        num_fours_opp = count_windows(grid, 4, mark%2+1, config)\n        score = num_threes - 1e2*num_threes_opp - 1e4*num_fours_opp + 1e6*num_fours\n        return score\n\n    def score_move(grid, col, mark, config, nsteps):\n        next_grid = drop_piece(grid, col, mark, config)\n        score = minimax(next_grid, nsteps-1, False, mark, config)\n        return score\n\n    # Helper function for minimax: checks if agent or opponent has four in a row in the window\n    def is_terminal_window(window, config):\n        return window.count(1) == config.inarow or window.count(2) == config.inarow\n\n    # Helper function for minimax: checks if game has ended\n    def is_terminal_node(grid, config):\n        # Check for draw \n        if list(grid[0, :]).count(0) == 0:\n            return True\n        # Check for win: horizontal, vertical, or diagonal\n        # horizontal \n        for row in range(config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[row, col:col+config.inarow])\n                if is_terminal_window(window, config):\n                    return True\n        # vertical\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns):\n                window = list(grid[row:row+config.inarow, col])\n                if is_terminal_window(window, config):\n                    return True\n        # positive diagonal\n        for row in range(config.rows-(config.inarow-1)):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row+config.inarow), range(col, col+config.inarow)])\n                if is_terminal_window(window, config):\n                    return True\n        # negative diagonal\n        for row in range(config.inarow-1, config.rows):\n            for col in range(config.columns-(config.inarow-1)):\n                window = list(grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])\n                if is_terminal_window(window, config):\n                    return True\n        return False\n\n    # Minimax implementation\n    def minimax(node, depth, maximizingPlayer, mark, config):\n        is_terminal = is_terminal_node(node, config)\n        valid_moves = [c for c in range(config.columns) if node[0][c] == 0]\n        if depth == 0 or is_terminal:\n            return get_heuristic(node, mark, config)\n        if maximizingPlayer:\n            value = -np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark, config)\n                value = max(value, minimax(child, depth-1, False, mark, config))\n            return value\n        else:\n            value = np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark%2+1, config)\n                value = min(value, minimax(child, depth-1, True, mark, config))\n            return value\n    \n    \n    \n    N_STEPS = 3\n    # Get list of valid moves\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)    ","ac8d7c47":"def my_leaner_Agent(obs, config): \n    import numpy as np\n\n    def drop_piece(grid, col, mark, config):\n        next_grid = grid.copy()\n        for row in range(config.rows-1, -1, -1):\n            if next_grid[row][col] == 0:\n                break\n        next_grid[row][col] = mark\n        return next_grid\n\n    def createNcheck_windows(grid, piece):\n        my_3,my_4,op_3,op_4 = 0,0,0,0\n        # horizontal\n        for row in range(6):\n            for col in range(4):\n                window = list(grid[row, col:col+4])                \n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1       \n        # vertical\n        for row in range(3):\n            for col in range(7):\n                window = list(grid[row:row+4, col])\n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1\n        # positive diagonal\n        for row in range(3):\n            for col in range(4):\n                window = list(grid[range(row, row+4), range(col, col+4)])\n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1\n        # negative diagonal\n        for row in range(3, 6):\n            for col in range(4):\n                window = list(grid[range(row, row-4, -1), range(col, col+4)])\n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1\n\n        is_term = ((my_4 != 0) or (op_4!=0))  \n\n        return is_term,my_3,my_4,op_3,op_4 \n\n\n    # Helper function for minimax: calculates value of heuristic for grid\n    def get_heuristic(my_3,my_4,op_3,op_4):        \n        score = 10*my_3 - 15*op_3 - 1e4*op_4 + 1e6*my_4\n        return score\n\n    # Uses minimax to calculate value of dropping piece in selected column\n    def score_move(grid, col, mark, config, nsteps):\n        next_grid = drop_piece(grid, col, mark, config)\n        score = minimax(next_grid, nsteps-1, False, mark, config)\n        return score\n\n    # Minimax implementation with alfabeta pruning\n    def minimax(node, depth, maximizingPlayer, mark, config):\n        is_term,my_3,my_4,op_3,op_4 = createNcheck_windows(node,mark)#mark being my piece\n        is_terminal = is_term\n        valid_moves = [c for c in range(config.columns) if node[0][c] == 0]\n        if is_terminal:\n            value = get_heuristic(my_3,my_4,op_3,op_4)\n            if value > 1e5:\n                value= 1e5+ 1e5*(depth)\n            if value < - 1e3:\n                value= -(1e4- 1e3*(depth))\n            return value\n        if depth == 0  or len(valid_moves)== 0 :\n            return get_heuristic(my_3,my_4,op_3,op_4)\n            \n\n        if maximizingPlayer:\n            value = -np.Inf\n\n            for col in valid_moves:\n                child = drop_piece(node, col, mark, config)\n                miniv =minimax(child, depth-1, False, mark, config)\n                value = max(value, miniv)\n                if value > 1e5:##ALFA BETA PRUNING\n                    winning_depth = (value -1e5)%1e5\n                    if winning_depth>=  (depth-1):\n                        break\n\n            return value\n        else:\n            value = np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark%2+1, config)\n                miniv = minimax(child, depth-1, True, mark, config)\n                value = min(value,miniv )\n    #                 if value<=-1e3:##ALFA BETA PRUNING no alfa beta pruning fighting to the end (furthest away poss.)\n    # #                     winning_depth = (value +1e4)%1e3\n    # #                     if winning_depth>=  (depth-1):\n    # #                         break\n\n            return value\n\n\n    # Your code here: Amend the agent!\n    # Get list of valid moves\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    N_STEPS=3       \n   \n\n    scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    \n    \n    # Select at random from the maximizing columns \n    return max_cols[len(max_cols)\/\/2]","0f26c589":"from kaggle_environments import make, evaluate\nimport time\nenv = make(\"connectx\")\n\ndef speedcheck (Magent):\n    start = time.time()\n    actions=[];\n    for i in range (3):\n        moves= env.run([Magent, \"random\"]) \n        [actions.append(moves[i][0]['action']) for i in range (1,len(moves),2)]\n    end = time.time()\n    print('Ran game simulations in {} s \\n now have {} moves in dataset '.format((end - start),len(actions)))  \n    print('{} seconds per move'.format((end - start)\/len(actions)))","87991b1e":"speedcheck(cooks_agent)","484b678e":"speedcheck(my_leaner_Agent)","617710d7":"def my_007(obs, config): \n    import numpy as np\n\n    def drop_piece(grid, col, mark, config):\n        next_grid = grid.copy()\n        for row in range(config.rows-1, -1, -1):\n            if next_grid[row][col] == 0:\n                break\n        next_grid[row][col] = mark\n        return next_grid\n\n    def createNcheck_windows(grid, piece):\n        my_3,my_4,op_3,op_4 = 0,0,0,0\n        # horizontal\n        for row in range(6):\n            for col in range(4):\n                window = list(grid[row, col:col+4])                \n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1       \n        # vertical\n        for row in range(3):\n            for col in range(7):\n                window = list(grid[row:row+4, col])\n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1\n        # positive diagonal\n        for row in range(3):\n            for col in range(4):\n                window = list(grid[range(row, row+4), range(col, col+4)])\n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1\n        # negative diagonal\n        for row in range(3, 6):\n            for col in range(4):\n                window = list(grid[range(row, row-4, -1), range(col, col+4)])\n                if (window.count(piece) == 3 and window.count(0) == 1):\n                    my_3 += 1\n                elif (window.count(piece%2+1) == 3 and window.count(0) == 1):\n                    op_3 += 1\n                elif (window.count(piece) == 4 and window.count(0) == 0):\n                    my_4 += 1\n                elif (window.count(piece%2+1) == 4 and window.count(0) == 0):\n                    op_4 += 1\n\n        is_term = ((my_4 != 0) or (op_4!=0))  \n\n        return is_term,my_3,my_4,op_3,op_4 \n\n\n    # Helper function for minimax: calculates value of heuristic for grid\n    def get_heuristic(my_3,my_4,op_3,op_4):        \n        score = 10*my_3 - 15*op_3 - 1e4*op_4 + 1e6*my_4\n        return score\n\n    # Uses minimax to calculate value of dropping piece in selected column\n    def score_move(grid, col, mark, config, nsteps):\n        next_grid = drop_piece(grid, col, mark, config)\n        score = minimax(next_grid, nsteps-1, False, mark, config)\n        return score\n\n    # Minimax implementation with alfabeta pruning\n    def minimax(node, depth, maximizingPlayer, mark, config):\n        is_term,my_3,my_4,op_3,op_4 = createNcheck_windows(node,mark)#mark being my piece\n        is_terminal = is_term\n        valid_moves = [c for c in range(config.columns) if node[0][c] == 0]\n        if is_terminal:\n            value = get_heuristic(my_3,my_4,op_3,op_4)\n            if value > 1e5:\n                value= 1e5+ 1e5*(depth)\n            if value < - 1e3:\n                value= -(1e4- 1e3*(depth))\n            return value\n        if depth == 0  or len(valid_moves)== 0 :\n            return get_heuristic(my_3,my_4,op_3,op_4)\n            \n\n        if maximizingPlayer:\n            value = -np.Inf\n\n            for col in valid_moves:\n                child = drop_piece(node, col, mark, config)\n                miniv =minimax(child, depth-1, False, mark, config)\n                value = max(value, miniv)\n                if value > 1e5:##ALFA BETA PRUNING\n                    winning_depth = (value -1e5)%1e5\n                    if winning_depth>=  (depth-1):\n                        break\n\n            return value\n        else:\n            value = np.Inf\n            for col in valid_moves:\n                child = drop_piece(node, col, mark%2+1, config)\n                miniv = minimax(child, depth-1, True, mark, config)\n                value = min(value,miniv )\n    #                 if value<=-1e3:##ALFA BETA PRUNING no alfa beta pruning fighting to the end (furthest away poss.)\n    # #                     winning_depth = (value +1e4)%1e3\n    # #                     if winning_depth>=  (depth-1):\n    # #                         break\n\n            return value\n\n\n    # Your code here: Amend the agent!\n    # Get list of valid moves\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    if len(valid_moves)  == 7 :\n        N_STEPS=2\n    elif len(valid_moves)  == 6 :\n        N_STEPS=3\n    elif len(valid_moves)  == 5 :\n        N_STEPS=3       \n    elif len(valid_moves)  == 4 :\n        N_STEPS=4\n    elif len(valid_moves)  == 3 :\n        N_STEPS=5   \n    elif len(valid_moves)  == 2 :\n        N_STEPS=8   \n    else :\n        return valid_moves[0]\n\n    scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    \n    \n    # Select at random from the maximizing columns \n    return max_cols[len(max_cols)\/\/2]","df449250":"# def get_win_percentages(agent1, agent2, n_rounds=20):\n#     # Use default Connect Four setup\n#     config = {'rows': 6, 'columns': 7, 'inarow': 4}\n#     # Agent 1 goes first (roughly) half the time          \n#     outcomes = evaluate(\"connectx\", [agent1, agent2], config, [], n_rounds\/\/2)\n#     # Agent 2 goes first (roughly) half the time      \n#     outcomes += [[b,a] for [a,b] in evaluate(\"connectx\", [agent2, agent1], config, [], n_rounds-n_rounds\/\/2)]\n#     print(\"Agent 1 Win Percentage:\", np.round(outcomes.count([1,-1])\/len(outcomes), 2))\n#     print(\"Agent 2 Win Percentage:\", np.round(outcomes.count([-1,1])\/len(outcomes), 2))\n#     print(\"Number of Invalid Plays by Agent 1:\", outcomes.count([None, 0]))\n#     print(\"Number of Invalid Plays by Agent 2:\", outcomes.count([0, None]))\n    ","675047b8":"# get_win_percentages(agent1=my_agent2, agent2=my_agent3)\n# get_win_percentages(agent1=my_agent2, agent2=my_agent3a)","a6e41666":"import inspect\nimport os\n\ndef write_agent_to_file(function, file):\n    with open(file, \"a\" if os.path.exists(file) else \"w\") as f:\n        f.write(inspect.getsource(function))\n        print(function, \"written to\", file)\n\nwrite_agent_to_file(my_007, \"submission.py\")","0ecbd42b":"import sys\nfrom kaggle_environments import utils\nfrom kaggle_environments import agent\nout = sys.stdout\n\nsubmission = utils.read_file(\"\/kaggle\/working\/submission.py\")\nmy_agent = agent.get_last_callable (submission)\nsys.stdout = out\n\nenv = make(\"connectx\", debug=True)\nenv.run([my_agent, my_agent])\nprint(\"Success!\" if env.state[0].status == env.state[1].status == \"DONE\" else \"Failed...\")","52422efd":"# Insigth Number 1 : Depth of foresight\n\nHow many steps i look ahead should therefore ( from what presented in the diagrams above )be vaiable and depend on the base of the exponent\nI.E the number of places i can Go ! \nlook up to 8 moves into the future !! on the same time restraint.","5f5b4ed5":"Lean, Fast, Insightfull, Deadly","d5865df4":"![Minimax.jpg](attachment:Minimax.jpg)","bf02a6c1":"# Test","32c750db":"# More than twice as Fast !!\njust like in a pit fight lighting speed is necessary, here it is too. The Faster i am the more i can do ..\nImmagine before if i did 6^3 - 216 scenarios ( Six say because one column is already full) . That would take too long, \nor would it ?? With the old sistem yes. With the New ? no ! i have halfed the time it takes. I can do it. so why not ?","a02be2ad":"# Learner And Much Meaner Agent !!!","b874b5e5":"**notice the elif statements at the bottom ! Up to 8 Steps Ahead**\n","814225d7":"**REASONABLE START POINT **\nhttps:\/\/www.kaggle.com\/alexisbcook\/n-step-lookahead#Code\n\nThe starting point of the getting started Competition. Does a good lot of the footwork in the code writing and explains Minimax a bit. Though not as well as This MIT professor who phenominal and a pleasure to watch. https:\/\/www.youtube.com\/watch?v=STjW3eH0Cik.\n# \n# Alexis Cooks n-step-lookahead Agent\n# \n\n**One Problem ! Now with the new Time restraints this does not work !! **\n\n**It is slow, and three steps loookahead is not possible any longer. \nShould the number of steps we foresee be Fixed ? ? **\n\n\n**With three moves possible. For 1 step lookahead i have 3 options : ***\n![](http:\/\/i.imgur.com\/aAYyy2I.png)\n\n\n\n**Below, with 2 moves possible 3 steps ahead i have 2^3= 8 options:***\n![](https:\/\/i.imgur.com\/BrRe7Bu.png)\n\n\n**It  is Exponential; And in these Cases the base counts a lot. It is esy for the speed to be bogged down with a huge number of calc. and possibilities. Witch would cause a Time Out Error.**\n![Thinking%20Brain.jpg](attachment:Thinking%20Brain.jpg)\n","fd50d2c7":"# Alg. with Mod 1+2\n","32788ce8":"# Insight Number 2:  Speedup. Leaner N menaer Alg\nThis algorthim  Has many parts, count_windows, is_terminal, get heuristics, drop_piece, minimax. \nAt a glance count windows and is_terminal in the agent are very similar. \nRepeating twice the process of going through all the board looking for pieces in a row is heavy. It can be done just Once as i do in my_leaner_Agent below. \nI test the speed Up with this adjustment below :","fe98924b":"Speed, calculations and foresight are the weapons of Minimax ! For every action there is a reaction is the principle Minimax is based on. How many actions and reactions we can calculate is Fondamental for Our score.\n"}}