{"cell_type":{"32ac73e4":"code","ac343715":"code","f18ecb90":"code","19150afc":"code","2d614abf":"code","dfa96d4e":"code","f072e31b":"code","46df9454":"code","ca52bec5":"code","8ae18322":"code","b197f965":"code","52708778":"code","3b2f0fc6":"code","22061206":"code","dc43f7c6":"code","d7bd510f":"code","2d1cfa23":"code","09984022":"code","37af60da":"code","ba9b7799":"code","b2210ce7":"code","07c72f54":"code","0cda0f6e":"code","e6e9e819":"code","07c2972b":"code","3df36a30":"code","35ddf8ac":"code","2fd7457f":"code","025c0d18":"markdown","f536c540":"markdown","7892eae1":"markdown","2cf51b1f":"markdown","6d6046bf":"markdown","0050439b":"markdown","cecfffc4":"markdown","79b61025":"markdown","55a9358e":"markdown","500b09aa":"markdown","79df8386":"markdown"},"source":{"32ac73e4":"import seaborn as sns\nfrom datetime import datetime\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n","ac343715":"train_data = pd.read_csv('\/kaggle\/input\/g-research-crypto-forecasting\/train.csv')\nasset_ID = pd.read_csv('\/kaggle\/input\/g-research-crypto-forecasting\/asset_details.csv')","f18ecb90":"asset_ID","19150afc":"Bitcoin_Cash = train_data[train_data['Asset_ID'] == 2]\nBinance_Coin = train_data[train_data['Asset_ID'] == 0]\nBitcoin = train_data[train_data['Asset_ID'] == 1]\nEOS_IO = train_data[train_data['Asset_ID'] == 5]\nEthereum_Classic = train_data[train_data['Asset_ID'] == 6]\nEthereum = train_data[train_data['Asset_ID'] == 6]\nLitecoin = train_data[train_data['Asset_ID'] == 9]\nMonero = train_data[train_data['Asset_ID'] == 11]\nTRON = train_data[train_data['Asset_ID'] == 13]\nStellar = train_data[train_data['Asset_ID'] == 12]\nCardano = train_data[train_data['Asset_ID'] == 3]\nIOTA = train_data[train_data['Asset_ID'] == 8]\nMaker = train_data[train_data['Asset_ID'] == 10]\nDogecoin = train_data[train_data['Asset_ID'] == 4]","2d614abf":"Bitcoin_Cash = Bitcoin_Cash.reindex(range(Bitcoin_Cash.index[0], Bitcoin_Cash.index[-1], 60), method = 'pad')\nBinance_Coin = Binance_Coin.reindex(range(Binance_Coin.index[0], Binance_Coin.index[-1], 60), method = 'pad')\nBitcoin = Bitcoin.reindex(range(Bitcoin.index[0], Bitcoin.index[-1], 60), method = 'pad')\nEOS_IO = EOS_IO.reindex(range(EOS_IO.index[0], EOS_IO.index[-1], 60), method = 'pad')\nEthereum_Classic = Ethereum_Classic.reindex(range(Ethereum_Classic.index[0], Ethereum_Classic.index[-1], 60), method = 'pad')\nEthereum = Ethereum.reindex(range(Ethereum.index[0], Ethereum.index[-1], 60), method = 'pad')\nLitecoin = Litecoin.reindex(range(Litecoin.index[0], Litecoin.index[-1], 60), method = 'pad')\nMonero = Monero.reindex(range(Monero.index[0], Monero.index[-1], 60), method = 'pad')\nTRON = TRON.reindex(range(TRON.index[0], TRON.index[-1], 60), method = 'pad')\nStellar = Stellar.reindex(range(Stellar.index[0], Stellar.index[-1], 60), method = 'pad')\nCardano = Cardano.reindex(range(Cardano.index[0], Cardano.index[-1], 60), method = 'pad')\nIOTA = IOTA.reindex(range(IOTA.index[0], IOTA.index[-1], 60), method = 'pad')\nMaker = Maker.reindex(range(Maker.index[0], Maker.index[-1], 60), method = 'pad')\nDogecoin = Dogecoin.reindex(range(Dogecoin.index[0], Dogecoin.index[-1], 60), method = 'pad')","dfa96d4e":"Bit_coin = Bitcoin.copy()","f072e31b":"Bitcoin = Bitcoin.Close.fillna(method = 'pad')","46df9454":"import math\nBitcoin_Target = Bitcoin.values\ntrain_len = math.ceil(len(Bitcoin_Target) * 0.8)","ca52bec5":"Bitcoin_Target = Bitcoin_Target.reshape(-1, 1)","8ae18322":"from sklearn.preprocessing import MinMaxScaler\nNormalize = MinMaxScaler(feature_range=(0, 1))\nBitcoin_Target = Normalize.fit_transform(Bitcoin_Target)","b197f965":"bit_train_data, bit_test_data = Bitcoin_Target[0:train_len, :], Bitcoin_Target[train_len:len(Bitcoin_Target), :1]","52708778":"x_train = []\ny_train = []\nfor i in range(100, len(bit_train_data)):\n   x_train.append(bit_train_data[i-100:i, 0])\n   y_train.append(bit_train_data[i, 0])\nx_train, y_train = np.array(x_train), np.array(y_train)","3b2f0fc6":"x_train = x_train.reshape(x_train.shape[0], x_train.shape[1], 1)","22061206":"x_test = []\ny_test = []\nfor i in range(100, len(bit_test_data)):\n   x_test.append(bit_test_data[i-100:i, 0])\n   y_test.append(bit_test_data[i, 0])\nx_test, y_test = np.array(x_test), np.array(y_test)","dc43f7c6":"x_test = x_test.reshape(x_test.shape[0], x_test.shape[1], 1)","d7bd510f":"x_train.shape","2d1cfa23":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Dropout, Conv1D, MaxPooling1D, TimeDistributed, Flatten\nfrom tensorflow.keras.utils import plot_model\nmodel = Sequential()\nmodel.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1], 1)))\nmodel.add(LSTM(50, return_sequences=True))\nmodel.add(LSTM(50))\nmodel.add(Dense(25))\nmodel.add(Dense(1))\nmodel.compile(loss = 'mse', optimizer = 'adam')\nhistory = model.fit(x_train,y_train, batch_size = 512 , epochs = 30)","09984022":"sns.set()\ndf_history = pd.DataFrame(history.history)\nsns.lineplot(x = df_history.index, y = df_history.loss)","37af60da":"import matplotlib.pyplot as plt\ny_pred = model.predict(x_test)\nplt.scatter(y_test, y_pred)\nplt.plot([x for x in range(2)], [x for x in range(2)], color = 'r')\nplt.xlabel(\"Reality MinMax\")\nplt.ylabel(\"Predicted MinMax\")\nplt.title('Bitcoin')\nplt.show()\nplt.clf()","ba9b7799":"y_pred = model.predict(x_test)\ny_test = y_test.reshape(-1, 1)\ny_pred = Normalize.inverse_transform(y_pred)\ny_test = Normalize.inverse_transform(y_test)\ny_pred = y_pred.reshape(len(y_pred), 1)\ny_test = y_test.reshape(len(y_pred), 1)","b2210ce7":"plt.scatter(y_test, y_pred)\nplt.plot([10000*x for x in range(2, 8)], [10000*x for x in range(2, 8)], color = 'r')\nplt.xlabel(\"Reality Prices\")\nplt.ylabel(\"Predicted prices\")\nplt.title('Bitcoin')\nplt.show()\nplt.clf()","07c72f54":"df_pred = pd.DataFrame(y_pred, columns = ['Prediction'], index = Bitcoin.index[train_len +100:])\ndf_pred['Reality'] = y_test","0cda0f6e":"df_pred","e6e9e819":"def log_return(close):\n    return np.log(close).diff(periods = 15)","07c2972b":"Bitcoin_Target[train_len:len(Bitcoin_Target), :1]","3df36a30":"df_pred['Log_return_prediction'] = log_return(df_pred['Prediction'])[15: ]\ndf_pred['Log_return_reality'] = log_return(df_pred['Reality'])[15: ]","35ddf8ac":"plt.figure(figsize=(20,10))\nplt.plot(df_pred['Log_return_prediction'], color = 'r' , label = 'Prediction', alpha = 0.5)\nplt.plot(df_pred['Log_return_reality'], color = 'b', label = 'Reality', alpha = 0.5)\nplt.title('Log_Return Between the Prediction and Reality')\nplt.legend()\nplt.show()","2fd7457f":"plt.figure(figsize = (30, 15))\nsns.lineplot(x = Bitcoin.index[-100000:], y = Bitcoin.values[-100000:], label = f'The Bitcoin Close')\nsns.lineplot(x = df_pred.index, y = df_pred.Prediction, label = 'Prediction', color = 'r')\nsns.lineplot(x = df_pred.index, y = df_pred.Reality, label = 'Reality', color = 'g')\nplt.legend()\nplt.show()","025c0d18":"### the Bitcoin prediction and reality comparsion","f536c540":"## Prepare the Time series data\nThe data from No.0 to No.99 is x_train and predicting No.100's data is y_train","7892eae1":"# **2. Data exploration**\n## **Take the Bitcoin data**\nTake the each Asset_ID data, the Bitcoin is Asset_ID == 1","2cf51b1f":"The data from No.0 to No.99 is x_test and predicting No.100's data is y_test","6d6046bf":"# **4. Data Preprocessing for Deep Learning Model**\n## Split the train_data and test_data\nI prepare the bit_train_data and bit_test_data.\nthe first 8 of 19 is bit_train_data, remaining the data as bit_test_data\n","0050439b":"# **5. Deep Learning LSTM Model**","cecfffc4":"# **3. Data Clean**\nAdd the row which is NaN (More information can search the G-Research Crypto Forecasting notebook)","79b61025":"#### No MinMaxScaler comparsion between prediction(y_pred) price and reality(y_test) price","55a9358e":"## Scaler the train, test data\n\nI ues the MinMaxScaler method to scale the data","500b09aa":"# 1. Read the Data\n\nRead the datasets from 'g-research-crypto-forecasting datasets","79df8386":"# **6. The Comparsion between Reality and Pridiction data**\n\n#### After MinMaxScaler comparsion between prediction(y_pred) and reality(y_test)"}}