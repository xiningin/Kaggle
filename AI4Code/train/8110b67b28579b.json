{"cell_type":{"ba02b85c":"code","2427ff8f":"code","7c994738":"code","4c727f71":"code","b0c68a8e":"code","739bec20":"code","17cdf36a":"code","2103d995":"code","6b484313":"code","e318987a":"code","711345f9":"code","dd2dbe7c":"code","799e106c":"code","187522c4":"code","8959d57d":"code","b784422f":"code","9ce5af45":"code","ff362c7e":"code","89805aa7":"code","e2519551":"code","d5316044":"code","00f03b06":"code","3653f190":"code","2c243a97":"code","9f1f992a":"code","ded84c4d":"code","7844d07a":"code","39cf0118":"code","4de91c6b":"code","d583391d":"code","0b098551":"code","405b25be":"code","ad2fdfee":"code","d6cbacc4":"code","2daf67bd":"code","6d1876ce":"code","c7568d66":"code","3af37ec4":"code","5611ed4d":"code","ec3a8cb0":"code","85ef1b4c":"code","1f2c81a4":"code","7b602690":"code","1ab23e8d":"markdown","dd519b8b":"markdown","0f00934f":"markdown","3e9256bc":"markdown","58f27cd2":"markdown","c46e5cf7":"markdown","beca60e7":"markdown","bde1b2aa":"markdown","9f8630dc":"markdown","e7b95c30":"markdown","9b41c77d":"markdown","1b08d56f":"markdown","a911280f":"markdown","2c23586f":"markdown","1d073ab9":"markdown","eb26e9b3":"markdown","784b05a4":"markdown","d9d6d648":"markdown","dd159f87":"markdown","5aca0c0b":"markdown","e21d0054":"markdown","8ab31fc3":"markdown","8df3ea09":"markdown","b9d64954":"markdown"},"source":{"ba02b85c":"# Here we are importing Library which are required \nimport pandas as pd\nimport numpy as np\nimport math\nimport datetime as dt\n\nimport matplotlib.pyplot as plt\nfrom itertools import cycle\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport seaborn as sns\n\nfrom xgboost import XGBRegressor\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error, explained_variance_score, r2_score \nfrom sklearn.metrics import mean_poisson_deviance, mean_gamma_deviance, accuracy_score\nfrom sklearn.preprocessing import MinMaxScaler\n\nfrom plotly.offline import plot, iplot, init_notebook_mode\ninit_notebook_mode(connected=True)","2427ff8f":"# Loading Dataset and remainig its columns\n\ndata=pd.read_csv('..\/input\/bitcoin-stock-data-sept-17-2014-august-24-2021\/BTC-USD.csv')\ndata = data.rename(columns={'Date': 'date','Open':'open','High':'high','Low':'low','Close':'close',\n                                'Adj Close':'adj_close','Volume':'volume'})","7c994738":"# Displaying first 5 rows of the dataset\n\ndata.head()","4c727f71":"# Displaying Last 5 rows of the dataset\n\ndata.tail()","b0c68a8e":"data.shape","739bec20":"# describe() is used to view some basic statistical details like percentile, mean, std etc. of a data frame or a series of numeric values\n\ndata.describe()","17cdf36a":"data.isnull().sum()","2103d995":"data['date'] = pd.to_datetime(data.date)\ndata.head()","6b484313":"print(\"Starting date: \",data.iloc[0][0])\nprint(\"Ending date: \", data.iloc[-1][0])\nprint(\"Duration: \", data.iloc[-1][0]-data.iloc[0][0])","e318987a":"y_2014 = data.loc[(data['date'] >= '2014-01-01')\n                     & (data['date'] < '2015-01-01')]\n\ny_2014.drop(y_2014[['adj_close','volume']],axis=1)","711345f9":"monthvise= y_2014.groupby(y_2014['date'].dt.strftime('%B'))[['open','close']].mean()\nnew_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', \n             'September', 'October', 'November', 'December']\nmonthvise = monthvise.reindex(new_order, axis=0)\nmonthvise","dd2dbe7c":"fig = go.Figure()\n\nfig.add_trace(go.Bar(\n    x=monthvise.index,\n    y=monthvise['open'],\n    name='Stock Open Price',\n    marker_color='crimson'\n))\nfig.add_trace(go.Bar(\n    x=monthvise.index,\n    y=monthvise['close'],\n    name='Stock Close Price',\n    marker_color='lightsalmon'\n))\n\nfig.update_layout(barmode='group', xaxis_tickangle=-45, \n                  title='Monthwise comparision between Stock open and close price')\nfig.show()","799e106c":"y_2014.groupby(y_2014['date'].dt.strftime('%B'))['low'].min()\nmonthvise_high = y_2014.groupby(data['date'].dt.strftime('%B'))['high'].max()\nmonthvise_high = monthvise_high.reindex(new_order, axis=0)\n\nmonthvise_low = y_2014.groupby(y_2014['date'].dt.strftime('%B'))['low'].min()\nmonthvise_low = monthvise_low.reindex(new_order, axis=0)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=monthvise_high.index,\n    y=monthvise_high,\n    name='Stock high Price',\n    marker_color='rgb(0, 153, 204)'\n))\nfig.add_trace(go.Bar(\n    x=monthvise_low.index,\n    y=monthvise_low,\n    name='Stock low Price',\n    marker_color='rgb(255, 128, 0)'\n))\n\nfig.update_layout(barmode='group', \n                  title=' Monthwise High and Low stock price')\nfig.show()","187522c4":"names = cycle(['Stock Open Price','Stock Close Price','Stock High Price','Stock Low Price'])\n\nfig = px.line(y_2014, x=y_2014.date, y=[y_2014['open'], y_2014['close'], \n                                          y_2014['high'], y_2014['low']],\n             labels={'Date': 'Date','value':'Stock value'})\nfig.update_layout(title_text='Stock analysis chart', font_size=15, font_color='black',legend_title_text='Stock Parameters')\nfig.for_each_trace(lambda t:  t.update(name = next(names)))\nfig.update_xaxes(showgrid=False)\nfig.update_yaxes(showgrid=False)\n\nfig.show()","8959d57d":"y_2020 = data.loc[(data['date'] >= '2020-01-01')\n                     & (data['date'] < '2021-01-01')]\n\ny_2020.drop(y_2020[['adj_close','volume']],axis=1)","b784422f":"monthvise= y_2020.groupby(y_2020['date'].dt.strftime('%B'))[['open','close']].mean()\nnew_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', \n             'September', 'October', 'November', 'December']\nmonthvise = monthvise.reindex(new_order, axis=0)\nmonthvise","9ce5af45":"fig = go.Figure()\n\nfig.add_trace(go.Bar(\n    x=monthvise.index,\n    y=monthvise['open'],\n    name='Stock Open Price',\n    marker_color='crimson'\n))\nfig.add_trace(go.Bar(\n    x=monthvise.index,\n    y=monthvise['close'],\n    name='Stock Close Price',\n    marker_color='lightsalmon'\n))\n\nfig.update_layout(barmode='group', xaxis_tickangle=-45, \n                  title='Monthwise comparision between Stock open and close price')\nfig.show()","ff362c7e":"y_2020.groupby(y_2020['date'].dt.strftime('%B'))['low'].min()\nmonthvise_high = y_2020.groupby(data['date'].dt.strftime('%B'))['high'].max()\nmonthvise_high = monthvise_high.reindex(new_order, axis=0)\n\nmonthvise_low = y_2020.groupby(y_2020['date'].dt.strftime('%B'))['low'].min()\nmonthvise_low = monthvise_low.reindex(new_order, axis=0)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=monthvise_high.index,\n    y=monthvise_high,\n    name='Stock high Price',\n    marker_color='rgb(0, 153, 204)'\n))\nfig.add_trace(go.Bar(\n    x=monthvise_low.index,\n    y=monthvise_low,\n    name='Stock low Price',\n    marker_color='rgb(255, 128, 0)'\n))\n\nfig.update_layout(barmode='group', \n                  title=' Monthwise High and Low stock price')\nfig.show()","89805aa7":"names = cycle(['Stock Open Price','Stock Close Price','Stock High Price','Stock Low Price'])\n\nfig = px.line(y_2020, x=y_2020.date, y=[y_2020['open'], y_2020['close'], \n                                          y_2020['high'], y_2020['low']],\n             labels={'Date': 'Date','value':'Stock value'})\nfig.update_layout(title_text='Stock analysis chart', font_size=15, font_color='black',legend_title_text='Stock Parameters')\nfig.for_each_trace(lambda t:  t.update(name = next(names)))\nfig.update_xaxes(showgrid=False)\nfig.update_yaxes(showgrid=False)\n\nfig.show()","e2519551":"y_2021 = data.loc[(data['date'] >= '2021-01-01')\n                     & (data['date'] < '2021-12-31')]\n\ny_2021.drop(y_2021[['adj_close','volume']],axis=1)","d5316044":"monthvise= y_2021.groupby(y_2021['date'].dt.strftime('%B'))[['open','close']].mean()\nnew_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', \n             'September', 'October', 'November', 'December']\nmonthvise = monthvise.reindex(new_order, axis=0)\nmonthvise","00f03b06":"fig = go.Figure()\n\nfig.add_trace(go.Bar(\n    x=monthvise.index,\n    y=monthvise['open'],\n    name='Stock Open Price',\n    marker_color='crimson'\n))\nfig.add_trace(go.Bar(\n    x=monthvise.index,\n    y=monthvise['close'],\n    name='Stock Close Price',\n    marker_color='lightsalmon'\n))\n\nfig.update_layout(barmode='group', xaxis_tickangle=-45, \n                  title='Monthwise comparision between Stock open and close price')\nfig.show()","3653f190":"y_2021.groupby(y_2021['date'].dt.strftime('%B'))['low'].min()\nmonthvise_high = y_2021.groupby(data['date'].dt.strftime('%B'))['high'].max()\nmonthvise_high = monthvise_high.reindex(new_order, axis=0)\n\nmonthvise_low = y_2021.groupby(y_2021['date'].dt.strftime('%B'))['low'].min()\nmonthvise_low = monthvise_low.reindex(new_order, axis=0)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=monthvise_high.index,\n    y=monthvise_high,\n    name='Stock high Price',\n    marker_color='rgb(0, 153, 204)'\n))\nfig.add_trace(go.Bar(\n    x=monthvise_low.index,\n    y=monthvise_low,\n    name='Stock low Price',\n    marker_color='rgb(255, 128, 0)'\n))\n\nfig.update_layout(barmode='group', \n                  title=' Monthwise High and Low stock price')\nfig.show()","2c243a97":"names = cycle(['Stock Open Price','Stock Close Price','Stock High Price','Stock Low Price'])\n\nfig = px.line(y_2021, x=y_2021.date, y=[y_2021['open'], y_2021['close'], \n                                          y_2021['high'], y_2021['low']],\n             labels={'Date': 'Date','value':'Stock value'})\nfig.update_layout(title_text='Stock analysis chart', font_size=15, font_color='black',legend_title_text='Stock Parameters')\nfig.for_each_trace(lambda t:  t.update(name = next(names)))\nfig.update_xaxes(showgrid=False)\nfig.update_yaxes(showgrid=False)\n\nfig.show()","9f1f992a":"y_overall=data\ny_overall.drop(y_overall[['adj_close','volume']],axis=1)","ded84c4d":"monthvise= y_overall.groupby(y_overall['date'].dt.strftime('%B'))[['open','close']].mean()\nnew_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', \n             'September', 'October', 'November', 'December']\nmonthvise = monthvise.reindex(new_order, axis=0)","7844d07a":"names = cycle(['Stock Open Price','Stock Close Price','Stock High Price','Stock Low Price'])\n\nfig = px.line(y_overall, x=y_overall.date, y=[y_overall['open'], y_overall['close'], \n                                          y_overall['high'], y_overall['low']],\n             labels={'Date': 'Date','value':'Stock value'})\nfig.update_layout(title_text='Stock analysis chart', font_size=15, font_color='black',legend_title_text='Stock Parameters')\nfig.for_each_trace(lambda t:  t.update(name = next(names)))\nfig.update_xaxes(showgrid=False)\nfig.update_yaxes(showgrid=False)\n\nfig.show()","39cf0118":" closedf = data[['date','close']]\nprint(\"Shape of close dataframe:\", closedf.shape)","4de91c6b":"closedf = closedf[closedf['date'] > '2020-09-13']\nclose_stock = closedf.copy()\nprint(\"Total data for prediction: \",closedf.shape[0])","d583391d":"del closedf['date']\nscaler=MinMaxScaler(feature_range=(0,1))\nclosedf=scaler.fit_transform(np.array(closedf).reshape(-1,1))\nprint(closedf.shape)","0b098551":"training_size=int(len(closedf)*0.70)\ntest_size=len(closedf)-training_size\ntrain_data,test_data=closedf[0:training_size,:],closedf[training_size:len(closedf),:1]\nprint(\"train_data: \", train_data.shape)\nprint(\"test_data: \", test_data.shape)","405b25be":"fig, ax = plt.subplots(figsize=(15, 6))\nsns.lineplot(x = close_stock['date'][:241], y = close_stock['close'][:241], color = 'black')\nsns.lineplot(x = close_stock['date'][241:], y = close_stock['close'][241:], color = 'red')\n\n# Formatting\nax.set_title('Train & Test data', fontsize = 20, loc='center', fontdict=dict(weight='bold'))\nax.set_xlabel('Date', fontsize = 16, fontdict=dict(weight='bold'))\nax.set_ylabel('Weekly Sales', fontsize = 16, fontdict=dict(weight='bold'))\nplt.tick_params(axis='y', which='major', labelsize=16)\nplt.tick_params(axis='x', which='major', labelsize=16)\nplt.legend(loc='upper right' ,labels = ('train', 'test'))\nplt.show()","ad2fdfee":"# convert an array of values into a dataset matrix\ndef create_dataset(dataset, time_step=1):\n    dataX, dataY = [], []\n    for i in range(len(dataset)-time_step-1):\n        a = dataset[i:(i+time_step), 0]   \n        dataX.append(a)\n        dataY.append(dataset[i + time_step, 0])\n    return np.array(dataX), np.array(dataY)","d6cbacc4":"time_step = 21\nX_train, y_train = create_dataset(train_data, time_step)\nX_test, y_test = create_dataset(test_data, time_step)\n\nprint(\"X_train: \", X_train.shape)\nprint(\"y_train: \", y_train.shape)\nprint(\"X_test: \", X_test.shape)\nprint(\"y_test\", y_test.shape)","2daf67bd":"# Biulding Model\n\nmy_model = XGBRegressor(n_estimators=1000)\nmy_model.fit(X_train, y_train, verbose=False)","6d1876ce":"predictions = my_model.predict(X_test)\nprint(\"Mean Absolute Error - MAE : \" + str(mean_absolute_error(y_test, predictions)))\nprint(\"Root Mean squared Error - RMSE : \" + str(math.sqrt(mean_squared_error(y_test, predictions))))","c7568d66":"train_predict=my_model.predict(X_train)\ntest_predict=my_model.predict(X_test)\n\ntrain_predict = train_predict.reshape(-1,1)\ntest_predict = test_predict.reshape(-1,1)\n\nprint(\"Train data prediction:\", train_predict.shape)\nprint(\"Test data prediction:\", test_predict.shape)","3af37ec4":"# Transform back to original form\n\ntrain_predict = scaler.inverse_transform(train_predict)\ntest_predict = scaler.inverse_transform(test_predict)\noriginal_ytrain = scaler.inverse_transform(y_train.reshape(-1,1)) \noriginal_ytest = scaler.inverse_transform(y_test.reshape(-1,1)) ","5611ed4d":"# shift train predictions for plotting\n\nlook_back=time_step\ntrainPredictPlot = np.empty_like(closedf)\ntrainPredictPlot[:, :] = np.nan\ntrainPredictPlot[look_back:len(train_predict)+look_back, :] = train_predict\nprint(\"Train predicted data: \", trainPredictPlot.shape)\n\n# shift test predictions for plotting\ntestPredictPlot = np.empty_like(closedf)\ntestPredictPlot[:, :] = np.nan\ntestPredictPlot[len(train_predict)+(look_back*2)+1:len(closedf)-1, :] = test_predict\nprint(\"Test predicted data: \", testPredictPlot.shape)\n\nnames = cycle(['Original close price','Train predicted close price','Test predicted close price'])\n\nplotdf = pd.DataFrame({'date': close_stock['date'],\n                       'original_close': close_stock['close'],\n                      'train_predicted_close': trainPredictPlot.reshape(1,-1)[0].tolist(),\n                      'test_predicted_close': testPredictPlot.reshape(1,-1)[0].tolist()})\n\nfig = px.line(plotdf,x=plotdf['date'], y=[plotdf['original_close'],plotdf['train_predicted_close'],\n                                          plotdf['test_predicted_close']],\n              labels={'value':'Close price','date': 'Date'})\nfig.update_layout(title_text='Comparision between original close price vs predicted close price',\n                  plot_bgcolor='white', font_size=15, font_color='black',legend_title_text='Close Price')\nfig.for_each_trace(lambda t:  t.update(name = next(names)))\n\nfig.update_xaxes(showgrid=False)\nfig.update_yaxes(showgrid=False)\nfig.show()","ec3a8cb0":"x_input=test_data[len(test_data)-time_step:].reshape(1,-1)\ntemp_input=list(x_input)\ntemp_input=temp_input[0].tolist()\n\nfrom numpy import array\n\nlst_output=[]\nn_steps=time_step\ni=0\npred_days = 10\nwhile(i<pred_days):\n    \n    if(len(temp_input)>time_step):\n        \n        x_input=np.array(temp_input[1:])\n        #print(\"{} day input {}\".format(i,x_input))\n        x_input=x_input.reshape(1,-1)\n        \n        yhat = my_model.predict(x_input)\n        #print(\"{} day output {}\".format(i,yhat))\n        temp_input.extend(yhat.tolist())\n        temp_input=temp_input[1:]\n       \n        lst_output.extend(yhat.tolist())\n        i=i+1\n        \n    else:\n        yhat = my_model.predict(x_input)\n        \n        temp_input.extend(yhat.tolist())\n        lst_output.extend(yhat.tolist())\n        \n        i=i+1\n        \nprint(\"Output of predicted next days: \", len(lst_output))","85ef1b4c":"last_days=np.arange(1,time_step+1)\nday_pred=np.arange(time_step+1,time_step+pred_days+1)\nprint(last_days)\nprint(day_pred)","1f2c81a4":"temp_mat = np.empty((len(last_days)+pred_days+1,1))\ntemp_mat[:] = np.nan\ntemp_mat = temp_mat.reshape(1,-1).tolist()[0]\n\nlast_original_days_value = temp_mat\nnext_predicted_days_value = temp_mat\n\nlast_original_days_value[0:time_step+1] = scaler.inverse_transform(closedf[len(closedf)-time_step:]).reshape(1,-1).tolist()[0]\nnext_predicted_days_value[time_step+1:] = scaler.inverse_transform(np.array(lst_output).reshape(-1,1)).reshape(1,-1).tolist()[0]\n\nnew_pred_plot = pd.DataFrame({\n    'last_original_days_value':last_original_days_value,\n    'next_predicted_days_value':next_predicted_days_value\n})\n\nnames = cycle(['Last 15 days close price','Predicted next 10 days close price'])\n\nfig = px.line(new_pred_plot,x=new_pred_plot.index, y=[new_pred_plot['last_original_days_value'],\n                                                      new_pred_plot['next_predicted_days_value']],\n              labels={'value': 'Close price','index': 'Timestamp'})\nfig.update_layout(title_text='Compare last 15 days vs next 10 days',\n                  plot_bgcolor='white', font_size=15, font_color='black',legend_title_text='Close Price')\nfig.for_each_trace(lambda t:  t.update(name = next(names)))\nfig.update_xaxes(showgrid=False)\nfig.update_yaxes(showgrid=False)\nfig.show()","7b602690":"my_model=closedf.tolist()\nmy_model.extend((np.array(lst_output).reshape(-1,1)).tolist())\nmy_model=scaler.inverse_transform(my_model).reshape(1,-1).tolist()[0]\n\nnames = cycle(['Close Price'])\n\nfig = px.line(my_model,labels={'value': 'Close price','index': 'Timestamp'})\nfig.update_layout(title_text='Plotting whole closing price with prediction',\n                  plot_bgcolor='white', font_size=15, font_color='black',legend_title_text='Stock')\nfig.for_each_trace(lambda t:  t.update(name = next(names)))\nfig.update_xaxes(showgrid=False)\nfig.update_yaxes(showgrid=False)\nfig.show()","1ab23e8d":"# 2. What is XGBoost?\n> XGBoost is a decision-tree-based ensemble Machine Learning algorithm that uses a gradient boosting framework. In prediction problems involving unstructured data (images, text, etc.) artificial neural networks tend to outperform all other algorithms or frameworks. However, when it comes to small-to-medium structured\/tabular data, decision tree based algorithms are considered best-in-class right now. Please see the chart below for the evolution of tree-based algorithms over the years.\n\n> XGBoost algorithm was developed as a research project at the University of Washington. Tianqi Chen and Carlos Guestrin presented their paper at SIGKDD Conference in 2016 and caught the Machine Learning world by fire. Since its introduction, this algorithm has not only been credited with winning numerous Kaggle competitions but also for being the driving force under the hood for several cutting-edge industry applications. As a result, there is a strong community of data scientists contributing to the XGBoost open source projects with ~350 contributors and ~3,600 commits on GitHub\n\n![](https:\/\/miro.medium.com\/max\/1400\/1*QJZ6W-Pck_W7RlIDwUIN9Q.jpeg)\n\nFor more information [Click Here](https:\/\/towardsdatascience.com\/https-medium-com-vishalmorde-xgboost-algorithm-long-she-may-rein-edd9f99be63d) ","dd519b8b":"Finding the duration of dataset","0f00934f":"# **Table of Content** \ud83d\udcdd\n> ### 1. Introduction\n> ### 2. What is XGBoost ??\n> ### 3. Importing Library\n> ### 4. Loading Dataset\n> ### 5. Checking for Null Values\n> ### 6. EDA\n> ### 7. Splitting Data\n> ### 8. Building XGBoost Model\n> ### 9. Predicting Next 10 Days\n> ### 10. Conclusion","3e9256bc":"# 8. Import XGBRegressor module and Fit X_train and y_train for training model","58f27cd2":"# Prepare train data for time series analysis","c46e5cf7":"### Visualizing Dataset for Year 2020","beca60e7":"# 7. Separate data for Train and Test \ud83c\udfac","bde1b2aa":"# 6. EDA  \ud83d\udcca \ud83d\udcc8 \ud83d\udcc9\n- EDA in Python uses data visualization to draw meaningful patterns and insights. It also involves the preparation of data sets for analysis by removing irregularities in the data. Based on the results of EDA, companies also make business decisions, which can have repercussions later","9f8630dc":"# 3. Importing Library \ud83d\udcda","e7b95c30":"### About Data\n> 1. Date - Date.\n> 2. Open - It is the price at which the financial security opens in the market when trading begins.\n> 3. High - The high is the highest price at which a stock traded during a period.\n> 4. Low - Low is the minimum price of a stock in a period.\n> 5. Close - Closing price generally refers to the last price at which a stock trades during a regular trading session.\n> 6. Adj Close - The adjusted closing price amends a stock's closing price to reflect that stock's value after accounting for any\n> 7. Volume - Volume measures the number of shares traded in a stock or contracts traded in futures or options. ","9b41c77d":"### Normalizing close price value","1b08d56f":"# 4. Loading Dataset \ud83d\udcda\n> ### Dataset: [Click Here](https:\/\/www.kaggle.com\/meetnagadia\/bitcoin-stock-data-sept-17-2014-august-24-2021)","a911280f":"### Overall Analysis from ","2c23586f":"Convert date field from string to Date format ","1d073ab9":"### Visualizing Dataset for Year 2021","eb26e9b3":"### Since our data start from 2014-09-17 thats why its showing Nan before Semptember","784b05a4":"![](https:\/\/thumbor.forbes.com\/thumbor\/960x0\/https%3A%2F%2Fspecials-images.forbesimg.com%2Fimageserve%2F1196863012%2FA-physical-imitation-of-a-Bitcoin%2F960x0.jpg%3Ffit%3Dscale)","d9d6d648":"### Creating new dataframe of Bitcoin data containing only date and closing price","dd159f87":"# 9. Prediction next 10 days","5aca0c0b":"# 5. Checking for null values","e21d0054":"#### Since we had data till September, so after September its showing NaN","8ab31fc3":"# 10. Conclusion \ud83d\udccc\n\n> ### This Notebook is all about Predicting Bitcion Price using XGBoost.\n> ### Since the data was preprocessed there were no missing Values as well as not null values.\n> ### One thing to note is that, the Starting date and the Ending date of the dataset, these contains from where data is starting date and the ending data.\n> ### Then I did EDA on the dataset to Visualize trend in the data as well as draw meaningful patterns and insights, I have Visulaized for Year 2014,2020,2021.\n> ### Then we splitted our data into training data and testing.\n> ### After that we created XGBoost model using sklearn libray and then we feed the model with data (training data).\n> ### Now that our Model is Created now its time to do prediction .\n> ### We also calculated MSE and RSME for the predicted data.\n> ### Then we plot the Predicted 10 days chart with the overall Closed price with prediction  chart\n> ### Check out my other projects: [Click Here](https:\/\/www.kaggle.com\/meetnagadia)\n> ### Bitcoin Price Prediction using LSTM: [Click Here](https:\/\/www.kaggle.com\/meetnagadia\/bitcoin-price-prediction-using-lstm)\n> ### Reference: [Click Here](https:\/\/www.kaggle.com\/ysthehurricane\/bitcoin-dogecoin-etc-price-prediction-xgboost) ~ [@ysthehurricane](https:\/\/www.kaggle.com\/ysthehurricane)","8df3ea09":"## Visualizing Dataset for Year 2014","b9d64954":"# 1. Introduction \ud83d\udcce\n\n## This Notebook is all about Bitcoin Price Prediction using XGBoost Algorithm\n##  Bitcoin, often described as a cryptocurrency, a virtual currency or a digital currency - is a type of money that is completely virtual. It's like an online version of cash. Each Bitcoin is basically a computer file which is stored in a 'digital wallet' app on a smartphone or computer.\n##  XGBoost is a decision-tree-based ensemble Machine Learning algorithm that uses a gradient boosting framework. In prediction problems involving unstructured data (images, text, etc.) A wide range of applications: Can be used to solve regression, classification, ranking, and user-defined prediction problems.\n\n### To know more about Bitcoin: [Click Here](https:\/\/en.wikipedia.org\/wiki\/Bitcoin) \n### To know more about XGBoost: [Click Here](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.ensemble.GradientBoostingClassifier.html)"}}