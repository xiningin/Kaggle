{"cell_type":{"f79cca1c":"code","4bfc8873":"code","e2bd538b":"code","8fe12c8b":"code","d7694dfd":"code","21fcb2cb":"code","2add7239":"code","a1d6fae5":"code","2581a5b3":"code","2fbe322b":"code","ecf4dead":"code","d4346638":"code","56433be4":"code","9501275c":"code","8cddd65e":"code","ba1e8526":"code","bc3fa4ef":"code","5a262659":"code","4050cd28":"code","46e30d73":"code","523c650c":"code","6b69fb70":"code","ddba0f6f":"code","2bcc0a0f":"code","62fc40fc":"code","ffe4ad5b":"code","d6b38e64":"code","69ff5abe":"code","ca440491":"code","ede0623e":"code","d36977f8":"code","126b0139":"code","b4c2eb37":"code","f8c0a8b6":"code","f9ba25ca":"code","ea4e36a8":"code","756c7da2":"code","e082d0e8":"code","74fe6467":"code","96039541":"code","8b568f63":"code","9080dff7":"code","64e2d0a5":"code","2a174f0d":"code","0efb11d3":"code","b11a8b66":"code","d4dde5d3":"code","1b2d0e83":"code","43977ece":"code","d85742fa":"code","73a62f12":"code","16b85153":"code","3bee8edb":"code","fa942012":"code","c71cacf2":"code","7f558ff3":"code","c49fac10":"code","bf777837":"code","e76274b3":"code","3ea92def":"code","8d6b1aea":"code","e465b42a":"code","84052691":"code","6161f3af":"markdown","157d7eea":"markdown","38d55047":"markdown","4df558a3":"markdown","e4c9a860":"markdown","e724e20f":"markdown"},"source":{"f79cca1c":"# Importando as bibliotecas\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.core.pylabtools import figsize\nimport seaborn as sns\nimport warnings\n\n%matplotlib inline\nwarnings.filterwarnings(\"ignore\")","4bfc8873":"# Carregando os arquivos\ndf = pd.read_csv('..\/input\/train.csv')\n\ndf_energia = pd.read_csv('..\/input\/potential_energy.csv')\ndf_charges = pd.read_csv('..\/input\/mulliken_charges.csv')\ndf_estrutura = pd.read_csv('..\/input\/structures.csv')\n\ndf.head(5)","e2bd538b":"df_teste = pd.read_csv('..\/input\/test.csv')","8fe12c8b":"# Mostrando as estruturas dos Datasets\ndf.info()","d7694dfd":"# Mostrando as estruturas dos Datasets - Energia\ndf_energia.info()","21fcb2cb":"# Mostrando as estruturas dos Datasets - Estrutura\ndf_estrutura.info()","2add7239":"#Checando valores NA nos dados\ndf.isna().any()[lambda x: x]","a1d6fae5":"df_teste.isna().any()[lambda x: x]","2581a5b3":"df_estrutura.isna().any()[lambda x: x]","2fbe322b":"df_energia.isna().any()[lambda x: x]","ecf4dead":"# Coletando os dados - Merge \/ Mesclagem dos DataSets\ndf = pd.merge(df, df_energia, how = 'left',\n                  left_on  = ['molecule_name'],\n                  right_on = ['molecule_name'])\n\ndf = pd.merge(df, df_charges, how = 'left',\n                  left_on  = ['molecule_name','atom_index_0'],\n                  right_on = ['molecule_name','atom_index'])\n\ndf = df.drop('atom_index', axis=1)\n","d4346638":"df = pd.merge(df, df_charges, how = 'left',\n                  left_on  = ['molecule_name','atom_index_1'],\n                  right_on = ['molecule_name','atom_index'])\n","56433be4":"df = df.drop('atom_index', axis=1)\ndf.head(10)","9501275c":"#Replicando para os dados de Teste\ndf_teste = pd.merge(df_teste, df_energia, how = 'left',\n                  left_on  = ['molecule_name'],\n                  right_on = ['molecule_name'])\n\ndf_teste = pd.merge(df_teste, df_charges, how = 'left',\n                  left_on  = ['molecule_name','atom_index_0'],\n                  right_on = ['molecule_name','atom_index'])\n\ndf_teste = df_teste.drop('atom_index', axis=1)\n\ndf_teste = pd.merge(df_teste, df_charges, how = 'left',\n                  left_on  = ['molecule_name','atom_index_1'],\n                  right_on = ['molecule_name','atom_index'])\n\ndf_teste = df_teste.drop('atom_index', axis=1)","8cddd65e":"# Coletando os dados - Merge \/ Mesclagem dos DataSets - Parte 2\ndf = pd.merge(df, df_estrutura, how = 'left',\n                  left_on  = ['molecule_name','atom_index_0'],\n                  right_on = ['molecule_name','atom_index'])\n\ndf = df.rename(columns={'atom': 'atom_0',\n                            'x': 'x_0',\n                            'y': 'y_0',\n                            'z': 'z_0'})\n\ndf = df.drop('atom_index', axis=1)\n","ba1e8526":"\ndf = pd.merge(df, df_estrutura, how = 'left',\n                 left_on  = ['molecule_name','atom_index_1'],\n                 right_on = ['molecule_name','atom_index'])\n\ndf = df.rename(columns={'atom': 'atom_1',\n                            'x': 'x_1',\n                            'y': 'y_1',\n                            'z': 'z_1'})\n\ndf = df.drop('atom_index', axis=1)\n\n","bc3fa4ef":"df.head(10)","5a262659":"# Replicando - Parte 2 para o Teste\ndf_teste = pd.merge(df_teste, df_estrutura, how = 'left',\n                  left_on  = ['molecule_name','atom_index_0'],\n                  right_on = ['molecule_name','atom_index'])\n\ndf_teste = df_teste.rename(columns={'atom': 'atom_0',\n                            'x': 'x_0',\n                            'y': 'y_0',\n                            'z': 'z_0'})\n\ndf_teste = df_teste.drop('atom_index', axis=1)\n\ndf_teste = pd.merge(df_teste, df_estrutura, how = 'left',\n                 left_on  = ['molecule_name','atom_index_1'],\n                 right_on = ['molecule_name','atom_index'])\n\ndf_teste = df_teste.rename(columns={'atom': 'atom_1',\n                            'x': 'x_1',\n                            'y': 'y_1',\n                            'z': 'z_1'})\n\ndf_teste = df_teste.drop('atom_index', axis=1)","4050cd28":"df.dtypes","46e30d73":"# Criando nova coluna do type\ndf['type1'] = df['type'].apply(lambda x: x[0])\n","523c650c":"df_teste['type1'] = df_teste['type'].apply(lambda x: x[0])","6b69fb70":"df.head(10)","ddba0f6f":"df['atom_0'].unique()","2bcc0a0f":"df['atom_1'].unique()","62fc40fc":"# Radius dos \u00e1tomos - Nova Coluna\ndf['rad'] = df['atom_0'].map({'H':0.43, 'C':0.82, 'N':0.8, 'O':0.78, 'F':0.76})\ndf['rad_1'] = df['atom_1'].map({'H':0.43, 'C':0.82, 'N':0.8, 'O':0.78, 'F':0.76})\n\n# Nova coluna de Eletrons negativos\ndf['electro'] = df['atom_0'].map({'H':2.2, 'C':2.55, 'N':3.04, 'O':3.44, 'F':3.98})\ndf['electro1'] = df['atom_1'].map({'H':2.2, 'C':2.55, 'N':3.04, 'O':3.44, 'F':3.98})\n","ffe4ad5b":"df_teste.dtypes","d6b38e64":"# Radius dos \u00e1tomos - Nova Coluna - TESTE\ndf_teste['rad'] = df_teste['atom_0'].map({'H':0.43, 'C':0.82, 'N':0.8, 'O':0.78, 'F':0.76})\ndf_teste['rad_1'] = df_teste['atom_1'].map({'H':0.43, 'C':0.82, 'N':0.8, 'O':0.78, 'F':0.76})\n\n# Nova coluna de Eletrons negativos  - TESTE\ndf_teste['electro'] = df_teste['atom_0'].map({'H':2.2, 'C':2.55, 'N':3.04, 'O':3.44, 'F':3.98})\ndf_teste['electro1'] = df_teste['atom_1'].map({'H':2.2, 'C':2.55, 'N':3.04, 'O':3.44, 'F':3.98})","69ff5abe":"df.head(5)","ca440491":"#Limpando a Mem\u00f3ria\ndel([df_energia, df_charges, df_estrutura])\n","ede0623e":"# Calculando a distancia entre os 2 at\u00f3mos - Nova coluna\ndf[\"distance\"] = ((df['x_0']-df['x_1'])**2 + (df['y_0']-df['y_1'])**2 + (df['z_0']-df['z_1'])**2) ** (1\/2)\n# Calculando o mulliken entre os 2 at\u00f3mos - Nova coluna\ndf['charge'] = ((df['mulliken_charge_x'] - df['mulliken_charge_y']) **2) ** (1\/2)","d36977f8":"# Calculando a distancia entre os 2 at\u00f3mos - Nova coluna - TESTE\ndf_teste[\"distance\"] = ((df_teste['x_0']-df_teste['x_1'])**2 + (df_teste['y_0']-df_teste['y_1'])**2 + (df_teste['z_0']-df_teste['z_1'])**2) ** (1\/2)\n# Calculando o mulliken entre os 2 at\u00f3mos - Nova coluna\ndf_teste['charge'] = ((df_teste['mulliken_charge_x'] - df_teste['mulliken_charge_y']) **2) ** (1\/2)","126b0139":"#Calculando a distancia por mol\u00e9cula individualmente e calculo a diferen\u00e7a entre as duas\ndf[\"distance_0\"] = 1 \/ (((df['x_0']**2) + (df['y_0']**2) + (df['z_0']**2)) ** (1\/2) ** 3 )\ndf[\"distance_1\"] = 1 \/ (((df['x_1']**2) + (df['y_1']**2) + (df['z_1']**2)) ** (1\/2) ** 3 )\ndf[\"distance_dif\"] = (df[\"distance_0\"] * df[\"distance_1\"]) \/ (df[\"distance_0\"] + df[\"distance_1\"])\n\n#Calculando a distancia por mol\u00e9cula individualmente e calculo a diferen\u00e7a entre as duas utilizando o radios das mol\u00e9culas\ndf[\"distance_0_Rad\"] = 1\/((df[\"distance_0\"]-df[\"rad\"])** (1\/2) ** 3 )\ndf[\"distance_1_Rad\"] = 1\/((df[\"distance_1\"]-df[\"rad_1\"])** (1\/2) ** 3 )\ndf[\"distance_dif_Rad\"] = (df[\"distance_0_Rad\"] * df[\"distance_1_Rad\"]) \/ (df[\"distance_0_Rad\"] + df[\"distance_1_Rad\"]) \n\n#Calculo dos eletrons\ndf[\"distance_0_Elec\"] = (df[\"distance_0\"]*df[\"electro\"])** 3\ndf[\"distance_1_Elec\"] = (df[\"distance_1\"]*df[\"electro1\"])** 3\ndf[\"distance_dif_Elec\"] = (df[\"distance_0_Elec\"] * df[\"distance_1_Elec\"]) \/ (df[\"distance_0_Elec\"] + df[\"distance_1_Elec\"]) \n","b4c2eb37":"#Replicando para o TESTE\ndf_teste[\"distance_0\"] = 1 \/ (((df_teste['x_0']**2) + (df_teste['y_0']**2) + (df_teste['z_0']**2)) ** (1\/2) ** 3 )\ndf_teste[\"distance_1\"] = 1 \/ (((df_teste['x_1']**2) + (df_teste['y_1']**2) + (df_teste['z_1']**2)) ** (1\/2) ** 3 )\ndf_teste[\"distance_dif\"] = (df_teste[\"distance_0\"] * df_teste[\"distance_1\"]) \/ (df_teste[\"distance_0\"] + df_teste[\"distance_1\"])\n\n#Calculando a distancia por mol\u00e9cula individualmente e calculo a diferen\u00e7a entre as duas utilizando o radios das mol\u00e9culas\ndf_teste[\"distance_0_Rad\"] = 1\/((df_teste[\"distance_0\"]-df_teste[\"rad\"])** (1\/2) ** 3 )\ndf_teste[\"distance_1_Rad\"] = 1\/((df_teste[\"distance_1\"]-df_teste[\"rad_1\"])** (1\/2) ** 3 )\ndf_teste[\"distance_dif_Rad\"] = (df_teste[\"distance_0_Rad\"] * df_teste[\"distance_1_Rad\"]) \/ (df_teste[\"distance_0_Rad\"] + df_teste[\"distance_1_Rad\"]) \n\n#Calculo dos eletrons\ndf_teste[\"distance_0_Elec\"] = (df_teste[\"distance_0\"]*df_teste[\"electro\"])** 3\ndf_teste[\"distance_1_Elec\"] = (df_teste[\"distance_1\"]*df_teste[\"electro1\"])** 3\ndf_teste[\"distance_dif_Elec\"] = (df_teste[\"distance_0_Elec\"] * df_teste[\"distance_1_Elec\"]) \/ (df_teste[\"distance_0_Elec\"] + df_teste[\"distance_1_Elec\"]) \n","f8c0a8b6":"#Checando valores NA nos dados\ndf.isna().any()[lambda x: x]","f9ba25ca":"df_teste.isna().any()[lambda x: x]","ea4e36a8":"#Preenchendo NAs\ndf['distance_1_Rad'].fillna((df['distance_1_Rad'].mean()), inplace=True)\ndf['distance_dif_Rad'].fillna((df['distance_dif_Rad'].mean()), inplace=True)\n","756c7da2":"#Preenchendo NAs\ndf_teste['distance_1_Rad'].fillna((df_teste['distance_1_Rad'].mean()), inplace=True)\ndf_teste['distance_dif_Rad'].fillna((df_teste['distance_dif_Rad'].mean()), inplace=True)\ndf_teste['potential_energy'].fillna((df_teste['potential_energy'].mean()), inplace=True)\ndf_teste['mulliken_charge_x'].fillna((df_teste['mulliken_charge_x'].mean()), inplace=True)\ndf_teste['mulliken_charge_y'].fillna((df_teste['mulliken_charge_y'].mean()), inplace=True)\ndf_teste['charge'].fillna((df_teste['charge'].mean()), inplace=True)\n","e082d0e8":"# Separando as colunas que n\u00e3o ser\u00e3o usadas no modelo\ndf = df.drop('id', axis=1)\ndf = df.drop('molecule_name', axis=1)\ndf = df.drop('atom_index_0', axis=1)\ndf = df.drop('atom_index_1', axis=1)\ndf = df.drop('type', axis=1)\ndf = df.drop('atom_0', axis=1)\ndf = df.drop('atom_1', axis=1)\n","74fe6467":"df_teste = df_teste.drop('id', axis=1)\ndf_teste = df_teste.drop('molecule_name', axis=1)\ndf_teste = df_teste.drop('atom_index_0', axis=1)\ndf_teste = df_teste.drop('atom_index_1', axis=1)\ndf_teste = df_teste.drop('type', axis=1)\ndf_teste = df_teste.drop('atom_0', axis=1)\ndf_teste = df_teste.drop('atom_1', axis=1)","96039541":"df_treino = df","8b568f63":"del(df)","9080dff7":"# Correla\u00e7\u00e3o com a Variavel TARGET => scalar_coupling_constant\ndf_treino[df_treino.columns.drop('scalar_coupling_constant')].corrwith(df_treino.scalar_coupling_constant)\n","64e2d0a5":"# Visualizando e analisando os dados\n\n# Construindo um gr\u00e1fico de HEATMAP\nf, ax = plt.subplots(figsize=(15, 12))\nsns.heatmap(df_treino.corr(),linewidths=.5, ax=ax)","2a174f0d":"# Histogramas\n#df_treino.plot(kind = 'hist', subplots = True, layout = (7,4), sharex = False, figsize=(20,70))\n#plt.show()","0efb11d3":"# Box-Plot\ndf_treino.plot(kind = 'box', subplots = True, layout = (7,4), sharex = False, sharey = False, figsize=(20,70))\nplt.show()","b11a8b66":"df_treino.shape","d4dde5d3":"df_teste.shape","1b2d0e83":"# Ajustando e padronizando as escalas - Normaliza\u00e7\u00e3o\nfrom sklearn.preprocessing import MinMaxScaler\n\narray = df_treino.values\n\n# Separando o array em componentes de input (X) e output (Y)\nX = array[:,1:26]\nX_sub = df_teste.values\nY = array[:,0]\n","43977ece":"#Limpando a Mem\u00f3ria\ndel(df_teste)","d85742fa":"# Gerando a nova escala (normalizando os dados)\nscaler = MinMaxScaler(feature_range = (0, 1))\nrescaledX = scaler.fit_transform(X)\nrescaledX_teste = scaler.fit_transform(X_sub)\n","73a62f12":"# Comecando o modelo - Versao 1 - Mais basico e simples\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.linear_model import LinearRegression\n\n# Divide os dados em treino e teste\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.30, random_state = 5)\n","16b85153":"# Criando o modelo\nmodelo = LinearRegression()\n\n# Treinando o modelo\nmodelo.fit(X_train, Y_train)\n\n# Fazendo previs\u00f5es\nY_pred = modelo.predict(X_test)\n\n# Resultado\nmae = mean_absolute_error(Y_test, Y_pred)\nprint('Modelo 1 - Regressao Linear => MAE = %0.4f' % mae)","3bee8edb":"# Modelo 2 - lightgbm simples\nimport lightgbm as lgb\n\ngbm = lgb.LGBMRegressor(num_leaves=50,\n                        learning_rate=0.05,\n                        n_estimators=100)\ngbm.fit(X_train, Y_train,\n        eval_set=[(X_test, Y_test)],\n        eval_metric='l1',\n        early_stopping_rounds=100,\n        verbose=0\n       )\n","fa942012":"Y_pred = gbm.predict(X_test, num_iteration=gbm.best_iteration_)\n\n# Resultado\nmae = np.log(mean_absolute_error(Y_test, Y_pred))\nprint('Modelo 2 - LightGBM => MAE = %0.4f' % mae)","c71cacf2":"# Funcoes utilitaria\n# Treinamento e resultado do modelo - funcao generica\ndef treine_e_avalie(model, X, y, X_test, y_test):\n    \n    # Predicao\n    model_pred = treino_e_predicao(model, X, y, X_test)\n    #Performance\n    model_mae = np.log(mean_absolute_error(y_test, model_pred))\n    \n    # Retorno da Performance do modelo\n    return model_mae\n\ndef treino_e_predicao(model, X, y, X_test):\n    \n    # FIT\n    model.fit(X, y)\n    # Predicao\n    return model.predict(X_test)\n","7f558ff3":"# Importando mais modelos \nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\nfrom sklearn.neighbors import KNeighborsRegressor","c49fac10":"# Modelo 3 - KNN\nknn = KNeighborsRegressor(n_neighbors=5)\nknn_mae = treine_e_avalie(knn, X_train, Y_train, X_test, Y_test)\n\nprint('Modelo 3 - KNN => MAE = %0.4f' % knn_mae)","bf777837":"# Modelo 4 - GradientBoostingRegressor\ngradient_boosted = GradientBoostingRegressor(random_state=60)\ngradient_boosted_mae = treine_e_avalie(gradient_boosted, X_train, Y_train, X_test, Y_test)\n\nprint('Modelo 4 - GradientBoostingRegressor = %0.4f' % gradient_boosted_mae)\n","e76274b3":"#Otimizando o modelo 2\n#from sklearn.model_selection import GridSearchCV\n\n#estimator = lgb.LGBMRegressor()\n\n#param_grid = {\n#    'learning_rate': [0.005,0.05, 0.1, 1],\n#    'n_estimators': [100],\n#    'num_leaves': [50],\n#    'boosting_type' : ['gbdt','dart'],\n#    'objective' : ['regression'],\n#    'colsample_bytree' : [0.65, 0.66],\n#    'subsample' : [0.7,0.75],\n#    'reg_alpha' : [1,1.2],\n#    'reg_lambda' : [1,1.2,1.4]    \n#}\n\n#gbm1 = GridSearchCV(estimator, param_grid, cv=5, verbose=0)\n#gbm1.fit(X_train, Y_train)\n\n#print('Melhores parametros:', gbm1.best_params_)\n#print('Melhor score:', gbm1.best_score_)","3ea92def":"# Modelo 5 - otimizado\ngbm = lgb.LGBMRegressor(num_leaves=100,\n                        learning_rate=1.10,\n                        n_estimators=500,\n                        boosting_type='dart',\n                        metric='mae',\n                        objective='regression_l1',\n                        #max_depth=19,\n                        #subsample=0.75,\n                        verbosity=-0,\n                        reg_alpha=1.2,\n                        reg_lambda=1,\n                        #sub_feature = 0.75,\n                        #sub_row = 0.50,\n                        #bagging_freq = 1,                        \n                        #colsample_bytree=0.65\n                        )\ngbm.fit(X_train, Y_train,\n        eval_set=[(X_test, Y_test)],\n        eval_metric='l1',\n        early_stopping_rounds=200,\n        verbose=1\n       )\n\nY_pred = gbm.predict(X_test, num_iteration=gbm.best_iteration_)\n\n# Resultado\nmae = np.log(mean_absolute_error(Y_test, Y_pred))\nprint('Modelo 5 - LightGBM - Otimizado => MAE = %0.4f' % mae)","8d6b1aea":"#Features mais importantes do modelo\n#sorted(zip(gbm.feature_importances_, df_treino.columns), reverse=True)\n","e465b42a":"#Gerando os dados de submissao e predi\u00e7\u00e3o\ndf_submission = pd.read_csv('..\/input\/sample_submission.csv')\nresultado = gbm.predict(X_sub, num_iteration=gbm.best_iteration_)\ndf_submission['scalar_coupling_constant'] = resultado","84052691":"#Gravando Arquivo de Submissao\ndf_submission.to_csv('submission.csv', index=False)","6161f3af":"## FIM\n\n## OBRIGADO","157d7eea":"## Objetivo\nThis challenge aims to predict interactions between atoms. The main task is develop an algorithm that can predict the magnetic interaction between two atoms in a molecule (i.e., the scalar coupling constant)\n\nIn this competition, you will be predicting the scalar_coupling_constant between atom pairs in molecules, given the two atom types (e.g., C and H), the coupling type (e.g., 2JHC), and any features you are able to create from the molecule structure (xyz) files.","38d55047":"# Calculo das Distancias entre os Atomos","4df558a3":"Usado alguns pontos do kernel. https:\/\/www.kaggle.com\/seriousran\/just-speed-up-calculate-distance-from-benchmark","e4c9a860":"## Competi\u00e7\u00e3o Kaggle de Machine Learning - Julho\/2019\nPredicting Molecular Properties\nhttps:\/\/www.kaggle.com\/c\/champs-scalar-coupling\/\n## MARCIO DE LIMA\nAs submiss\u00f5es para esta competi\u00e7\u00e3o ser\u00e3o avaliadas pelo MAE.\nFor this metric, the MAE for any group has a floor of 1e-9, so that the minimum (best) possible score for perfect predictions is approximately -20.7232.\n\nObserva\u00e7\u00f5es importantes => N\u00e3o entendo nada de qu\u00edmica molecular kkkk.  \n\n** SE ESSE CODIGO FOR UTIL, VOTE , POR FAVOR **","e724e20f":"# ESCOLHIDO MODELO 2 - LIGHTGBM - MENOR MAE"}}