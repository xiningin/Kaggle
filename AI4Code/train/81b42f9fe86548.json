{"cell_type":{"d4cdcd7a":"code","01536ea4":"code","2b0e592f":"code","e2a90e23":"code","8373f663":"code","20ac3df3":"code","38501c96":"code","91fba930":"code","e6f6d641":"code","47019b6d":"code","9b18ab1c":"code","7f59dda9":"code","7a482614":"code","68dc5fe9":"code","c667cae7":"code","1201e8b9":"code","a9aa1e6f":"code","14e92732":"markdown"},"source":{"d4cdcd7a":"import tensorflow as tf","01536ea4":"# Load in the data\nfrom sklearn.datasets import load_breast_cancer","2b0e592f":"# load the data\ndata = load_breast_cancer()","e2a90e23":"type(data)","8373f663":"# note: it is a Bunch object\n# this basically acts like a dictionary where you can treat the keys like attributes\ndata.keys()","20ac3df3":"# 'data' (the attribute) means the input data\ndata.data.shape\n# it has 569 samples, 30 features","38501c96":"# 'targets'\ndata.target\n# note how the targets are just 0s and 1s\n# normally, when you have K targets, they are labeled 0..K-1","91fba930":"# their meaning is not lost\ndata.target_names","e6f6d641":"# there are also 569 corresponding targets\ndata.target.shape","47019b6d":"data.feature_names","9b18ab1c":"#splitting the data\nfrom sklearn.model_selection import train_test_split\n\n\n# split the data into train and test sets\n# this lets us simulate how our model will perform in the future\nX_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.33)\nN, D = X_train.shape","7f59dda9":"# Scale the data\nfrom sklearn.preprocessing import StandardScaler\n\nscaler = StandardScaler()\nX_train = scaler.fit_transform(X_train)\nX_test = scaler.transform(X_test)","7a482614":"# Build the model\n\nmodel = tf.keras.models.Sequential([\n  tf.keras.layers.Input(shape=(D,)),\n  tf.keras.layers.Dense(1, activation='sigmoid')\n])\n\n# Alternatively, you can do:\n# model = tf.keras.models.Sequential()\n# model.add(tf.keras.layers.Dense(1, input_shape=(D,), activation='sigmoid'))\n\nmodel.compile(optimizer='adam',\n              loss='binary_crossentropy',\n              metrics=['accuracy'])\n\n\n# Train the model\nr = model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=100)\n\n\n# Evaluate the model - evaluate() returns loss and accuracy\nprint(\"Train score:\", model.evaluate(X_train, y_train))\nprint(\"Test score:\", model.evaluate(X_test, y_test))","68dc5fe9":"import matplotlib.pyplot as plt\nplt.plot(r.history['loss'], label='loss')\nplt.plot(r.history['val_loss'], label='val_loss')\nplt.legend()","c667cae7":"p = model.predict(X_test)\nprint(p)","1201e8b9":"import numpy as np\nP = np.round(P).flatten()\nprint(P)","a9aa1e6f":"print(\"Manually calculated accuracy:\", np.mean(P == y_test))\nprint(\"Evaluate output:\", model.evaluate(X_test, y_test))","14e92732":"**HELLO GUYS I TRIED TO WORK ON BREAST CANCER DATASET, IT ALSO HAS 98% ACCURACY , DO UPVOTE IF IT IS USEFUL AND SUGGEST CHANGES**"}}