{"cell_type":{"eb8464fc":"code","d9238ebe":"code","26c690b0":"code","893d1eac":"code","f2b48dbd":"code","77e1322f":"code","687feedb":"code","b37419a8":"code","9f82930a":"code","eccc8c58":"code","8cfe1ffe":"code","bb9a3c39":"code","1dfd9b19":"code","8022cd63":"code","73ce3525":"code","d8c26a42":"code","1a19cf96":"code","78c1024b":"code","3ed716ae":"code","e833f077":"code","beb3b019":"code","da799019":"code","846ac349":"markdown","953f4b14":"markdown","7d13a77e":"markdown","e1bec837":"markdown","920d7f33":"markdown","81e5e51f":"markdown"},"source":{"eb8464fc":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pingouin as pg","d9238ebe":"from sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, classification_report, confusion_matrix\nfrom sklearn import linear_model, preprocessing","26c690b0":"train_data = pd.read_csv(\"train.csv\")","893d1eac":"train_data.info()","f2b48dbd":"train_data.corr().ADDCONTAMNT","77e1322f":"train_after = train_data.drop(['TRAN_DATE','ACCMVMTAVG', 'ACCACVNUM12', 'ACCAMNTAVG12', 'CARDDINSUM12', \n                               'DISTNUM12', 'INTPHNNUM03', 'INTLOGNUM12', 'DEMINFO1', 'DEMINFO2', 'ASTAVGDIF0312',\n                               'EFTAMNTSUM12', 'MAXMATEVR', 'DEBTAVG00', 'LSTPRDCNUM', 'CONTPAIDAMNT07', 'CONTDEBTNUM',\n                               'MAXTIMECONTR', 'LASTAUTOPAYTIME'], axis=1)","687feedb":"train_after.isnull().sum()","b37419a8":"train_after.describe().astype(int)","9f82930a":"train_after.mode()","eccc8c58":"train_after.fillna(value={'ACCAMNTAVG03': 100, 'BLNAMNT03': 100, 'CRRASTALL': 100, 'CONTPAIDAMNT00': 0,\n                         'CONTPAIDAMNT01': 0, 'CONTPAIDAMNT02': 0, 'CONTPAIDAMNT03': 0, 'CONTPAIDAMNT04': 0,\n                         'CONTPAIDAMNT05': 0, 'CONTPAIDAMNT06': 0, 'CONTPAIDAMNT08': 0, 'CONTPAIDAMNT09': 0,\n                         'CONTPAIDAMNT10': 0, 'CONTPAIDAMNT11': 0, 'TIMEDEPAVG12': 3137}, inplace=True)","8cfe1ffe":"pg.pairwise_corr(train_after, columns= ['ADDCONTAMNT']).sort_values(by=['r'])[['X', 'Y', 'r', 'p-unc']]","bb9a3c39":"df1 = train_after.set_index('CUSTNBR')\ndf2 = df1.copy()\ndf2.loc[df2.ADDCONTAMNT > 0, 'ADDCONTAMNT'] = 1","1dfd9b19":"y = df2.iloc[:, 0]\nx = df2.iloc[:, 1:20]\nx = preprocessing.StandardScaler().fit(x).transform(x)\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=1)","8022cd63":"log_reg = linear_model.LogisticRegression()\nlog_reg.fit(x_train, y_train)\nyhat = log_reg.predict(x_test)","73ce3525":"print(classification_report(y_test, yhat))","d8c26a42":"import itertools\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","1a19cf96":"# Compute confusion matrix\ncnf_matrix = confusion_matrix(y_test, yhat, labels=[1,0])\nnp.set_printoptions(precision=2)\n\n\n# Plot non-normalized confusion matrix\nplt.figure()\nplot_confusion_matrix(cnf_matrix, classes=['ADDCONTAMNT=1','ADDCONTAMNT=0'], normalize= False,  title='Confusion matrix')","78c1024b":"y1 = df1.ADDCONTAMNT\nx1 = df1.iloc[:, 1:20]\nx1 = preprocessing.StandardScaler().fit(x1).transform(x1)\nx1_train, x1_test, y1_train, y1_test = train_test_split(x1, y1, test_size=0.2, random_state=1)","3ed716ae":"lin_reg = linear_model.LinearRegression()\nlin_reg.fit(x1_train, y1_train)\npred = lin_reg.predict(x1_test)","e833f077":"np.sqrt(mean_squared_error(y1_test, pred))","beb3b019":"ytdf = pd.DataFrame(y1_test)\nytdf['yhat'] = yhat\nytdf['pred'] = pred\nytdf.loc[ytdf.yhat == 0, 'pred'] = 0\nytdf","da799019":"np.sqrt(mean_squared_error(ytdf.ADDCONTAMNT, ytdf.pred))","846ac349":"# Garanti BBVA Teknoloji Data Science Challenge\n\n### Individual Pension Plan (IPP) \u2013 Additional Contribution Predicting\n\n#### Which customers will pay additional contribution, how much additional contribution amount will be paid by those customers? \n\n#### Problem lojistik ve do\u011frusal regresyon kullan\u0131larak iki a\u015famal\u0131 \u00e7\u00f6z\u00fcld\u00fc.","953f4b14":"#### de\u011fi\u015fkenler aras\u0131 korelasyon anlaml\u0131","7d13a77e":"#### de\u011fi\u015fken istatistiklerine nazaran bo\u015f de\u011ferleri doldurdum","e1bec837":"#### accuracy = 0.9","920d7f33":"#### veri k\u00fcmesinde doldurulmas\u0131 gereken bo\u015f de\u011ferler g\u00f6z\u00fck\u00fcyor","81e5e51f":"#### korelasyon katsay\u0131s\u0131 0.1'den k\u00fc\u00e7\u00fck olan de\u011fi\u015fkeni att\u0131m"}}