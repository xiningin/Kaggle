{"cell_type":{"31ce0b54":"code","1fd2ffbb":"code","fa787485":"code","9681363f":"code","b06dd7c2":"code","9a3df1d9":"code","dddb114c":"code","1f80c404":"code","adb15be2":"code","bdb8c7c4":"code","c6762c87":"code","d178c202":"code","dfaa8bba":"code","4be7c703":"code","b1966500":"code","0be2a109":"code","84a3c5ef":"markdown","b439da4a":"markdown","2e81edaf":"markdown","f33507fd":"markdown","c2ef70b9":"markdown","e90880d1":"markdown","67d5bd7c":"markdown"},"source":{"31ce0b54":"# Bibliotecas necess\u00e1rias\n# Manipula\u00e7\u00e3o de dados\nimport pandas as pd\nimport numpy as np\n# Redes Neurais\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout\nfrom tensorflow.keras.optimizers import RMSprop, Adam\nfrom sklearn.model_selection import train_test_split\n# Plot\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# Avalia\u00e7\u00e3o\nfrom sklearn.metrics import classification_report, confusion_matrix","1fd2ffbb":"# Lendo o dataset Kaggle\ntrain = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")","fa787485":"# Separando x_train e y_train\nY = train[\"label\"]\nX = train.drop(labels = [\"label\"],axis = 1)\nprint('TRAIN DATASET')\nprint(X.head())\nprint('TRAIN LABELS')\nprint(Y)","9681363f":"# Transformando a imagem 2d em um numpy array (imagem 28*28 = 784 pixels)\nx = X.values.reshape(42000, 784)\n\n#Normalizando para valores entre 0 e 1\nx = x.astype('float32')\nx \/= 255\n\nprint(x[0])","b06dd7c2":"# Vamos ajustar o formato da saida\nnum_classes = 10\n\n# Convertendo para um vetor de saida com 10 dimensoes\n# ex. 8 => [0,0,0,0,0,0,0,0,1,0]\ny = keras.utils.to_categorical(Y, num_classes)\nprint(y[0])","9a3df1d9":"# Separando uma parte para treino (70%) e outra para valida\u00e7\u00e3o (30%)\nx_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.3, random_state=9)\nprint('Qtde de treino: {}'.format(len(x_train)))\nprint('Qtde de valida\u00e7\u00e3o: {}'.format(len(x_val)))","dddb114c":"# Criando o modelo Sequential\n\nmodel = Sequential()\n# Camada com 40 neur\u00f4nios\nmodel.add(Dense(40, activation='relu', input_shape=(784,)))\n# Dropout de 20%\nmodel.add(Dropout(0.2))\n# Camada de 30 neur\u00f4nios\nmodel.add(Dense(30, activation='relu'))\n# Dropout de 20%\nmodel.add(Dropout(0.2))\n# Camada de 20 neur\u00f4nios\nmodel.add(Dense(20, activation='relu'))\n# Dropout de 20%\nmodel.add(Dropout(0.2))\n# Camda de classifica\u00e7\u00e3o final, com 1 neur\u00f4nio para cada classe de sa\u00edda. Softmax divide a probabilidade de cada classe.\nmodel.add(Dense(num_classes, activation='softmax'))\n\nmodel.summary()","1f80c404":"# Compila o modelo\n\nmodel.compile(loss='mean_squared_error',\n              optimizer=Adam(),\n              metrics=['accuracy'])","adb15be2":"# Treina com os parte dos dados\n\nbatch_size = 32\nepochs = 50\nhistory = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    verbose=1,\n                    validation_data=(x_val, y_val))","bdb8c7c4":"fig, ax = plt.subplots(1,2, figsize=(16,8))\n\n# Loss\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"Validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\n# Accuracy\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","c6762c87":"# Testa com os dados de valida\u00e7\u00e3o\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","d178c202":"Y[100]","dfaa8bba":"# Testando uma entrada qualquer\n\n# Pequena modifica\u00e7\u00e3o para visualizar melhor o resultado do teste\nexpected_label = np.where(y_train[10] == 1.)[0]\nlabel = model.predict_classes(x_train[10].reshape((1,784)))\nprint(expected_label, label, expected_label == label)","4be7c703":"import itertools\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","b1966500":"# Vendo alguns reports\n# Usando sklearn\nimport numpy as np\n\n# Classificando toda base de teste\ny_pred = model.predict_classes(x_val)\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Confution Matrix\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","0be2a109":"# Gerando sa\u00edda para dataset de teste\n\n#Carrega dataset de teste\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Qtde de testes: {}\".format(len(test)))\n# Bota no formato numpy e normaliza\nx_test = test.values.reshape(len(test),784)\nx_test = x_test.astype('float32')\nx_test \/= 255\n\n# Faz classifica\u00e7\u00e3o para dataset de teste\ny_pred = model.predict_classes(x_test)\n\n# Verficando algum exemplo\ni = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Previsto: {}'.format(y_pred[i]))\n\n# Botando no formato de sa\u00edda (competi\u00e7\u00e3o Kaggle)\nresults = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(submission.head(10))\n#Salvando Arquivo\nsubmission.to_csv(\"mlp_mnist_v1.csv\",index=False)","84a3c5ef":"# Testando e Avaliando o modelo","b439da4a":"\n**AQUI FOI MODIFICADA A EXECU\u00c7\u00c3O DO MODELO**\n\nS\u00e3o 50 \u00e9pocas no total\n","2e81edaf":"**AQUI FOI MODIFICADA A EXECU\u00c7\u00c3O DO MODELO**\n\n\n- A fun\u00e7\u00e3o loss \u00e9 a Mean Square Error\n- O otimizador \u00e9 o Adam","f33507fd":"# Modelo","c2ef70b9":"# Bibliotecas; leitura e procecessamento de dados.","e90880d1":"**AQUI FORAM FEITAS AS MODIFICA\u00c7\u00c3O NA ARQUITETURA DO MODELO**\n\nS\u00c3O 4 CAMADAS:\n- a primiera com 40 neur\u00f4nios\n- a segunda com 30 neur\u00f4nios\n- a terceira com 20 neur\u00f4nios\n- e a camada de sa\u00edda","67d5bd7c":"### Matriz de confus\u00e3o"}}