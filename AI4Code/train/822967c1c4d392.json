{"cell_type":{"b615fff2":"code","41552abe":"code","ae57cb86":"code","b7ed686e":"code","a225c6ba":"code","ad8885d8":"code","fa8e7079":"code","a93ab2ce":"code","7c90702c":"code","134d3b3f":"code","d0ff38cc":"code","c914c04e":"code","0cff4716":"code","4c4e8f1a":"code","b1a8ef55":"markdown","23db1bed":"markdown","8ff4029d":"markdown","31f97284":"markdown","862b01a3":"markdown"},"source":{"b615fff2":"import numpy as np\n\nimport torch\nfrom torch import nn\nimport torch.optim as optim\nimport torch.nn.functional as F\n\nimport matplotlib.pyplot as plt\nfrom sklearn.utils import shuffle\nimport os\n\nfrom scipy import signal\nfrom scipy.io import wavfile","41552abe":"dog_train_path = \"..\/input\/audio-cats-and-dogs\/cats_dogs\/train\/dog\/\"\ndog_test_path = \"..\/input\/audio-cats-and-dogs\/cats_dogs\/test\/test\/\"\n\ncat_train_path = \"..\/input\/audio-cats-and-dogs\/cats_dogs\/train\/cat\/\"\ncat_test_path = \"..\/input\/audio-cats-and-dogs\/cats_dogs\/test\/cats\/\"","ae57cb86":"labels_to_idx = { \"cat\" : [1, 0], \"dog\" : [0, 1] }","b7ed686e":"def get_waveforms_labels(path, label):\n    \n    features = []\n    labels = []\n    \n    for filename in os.listdir(path):\n        sample_rate, samples = wavfile.read(path+filename)\n        frequencies, times, spectrogram = signal.spectrogram(samples, sample_rate)\n        features.append(spectrogram)\n        labels.append(labels_to_idx[label])\n        \n    return features, labels","a225c6ba":"dog_train_features, dog_train_labels = get_waveforms_labels(dog_train_path, \"dog\")\ndog_test_features, dog_test_labels = get_waveforms_labels(dog_test_path, \"dog\")\n\ncat_train_features, cat_train_labels = get_waveforms_labels(cat_train_path, \"cat\")\ncat_test_features, cat_test_labels = get_waveforms_labels(cat_test_path, \"cat\")","ad8885d8":"def pad_spec(spectrogram, max_length):\n    return np.pad(spectrogram, ((0,0),(0,max_length-spectrogram.shape[1])), mode='mean')","fa8e7079":"max_length = max([s.shape[1] for s in dog_train_features]+[s.shape[1] for s in cat_train_features]+[s.shape[1] for s in dog_test_features]+[s.shape[1] for s in cat_test_features])","a93ab2ce":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")","7c90702c":"X_train = torch.tensor([pad_spec(s, max_length) for s in dog_train_features]+[pad_spec(s, max_length) for s in cat_train_features], dtype=torch.float32).to(device)\ny_train = torch.tensor(dog_train_labels + cat_train_labels, dtype=torch.float32).to(device)\n\nX_test = torch.tensor([pad_spec(s, max_length) for s in dog_test_features]+[pad_spec(s, max_length) for s in cat_test_features], dtype=torch.float32).to(device)\ny_test = torch.tensor(dog_test_labels + cat_test_labels, dtype=torch.float32).to(device)","134d3b3f":"X_train, y_train = shuffle(X_train, y_train, random_state=0)\nX_test, y_test = shuffle(X_test, y_test, random_state=0)","d0ff38cc":"class Model(nn.Module):\n    def __init__(self):\n        super(Model, self).__init__()\n        self.conv1 = nn.Conv1d(129, 128, 3)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.dropout = nn.Dropout(0.2)\n        self.conv2 = nn.Conv1d(64, 32, 3)\n        self.conv3 = nn.Conv1d(16, 8, 3)\n        self.fc1 = nn.Linear(4 * 158, 512)\n        self.fc2 = nn.Linear(512, 256)\n        self.fc3 = nn.Linear(256, 128)\n        self.fc4 = nn.Linear(128, 64)\n        self.fc5 = nn.Linear(64, 2)\n        \n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = self.pool(x)\n        x = self.dropout(x)\n        x = F.relu(self.conv2(x))\n        x = self.pool(x)\n        x = self.dropout(x)\n        x = F.relu(self.conv3(x))\n        x = self.pool(x)\n        x = self.dropout(x)\n        x = x.view(-1, 4 * 158)\n        x = torch.tanh(self.fc1(x))\n        x = torch.tanh(self.fc2(x))\n        x = torch.tanh(self.fc3(x))\n        x = torch.tanh(self.fc4(x))\n        x = torch.tanh(self.fc5(x))\n        \n        return x","c914c04e":"model = Model().to(device)\n\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)","0cff4716":"epoch_losses = {}\n\nfor epoch in range(3000):\n    \n    losses = []\n    for i, X in enumerate(torch.split(X_train, 8)):\n        \n        if((i+8) < len(X_train)):\n            x, y = X_train[i:i+8], y_train[i:i+8]\n        else:\n            x, y = X_train[i:], y_train[i:]\n            \n        optimizer.zero_grad()\n        \n        out = model(x)\n        loss = criterion(out, torch.max(y, 1)[1])\n        loss.backward()\n        \n        optimizer.step()\n        \n        losses.append(loss)\n    \n    losses = np.array(losses).astype(np.float32).mean()\n    epoch_losses[epoch] = losses\n    \n    if (epoch+1) % 250 == 0:\n        \n        print(\"Epoch:{0:3d}, Loss-train:{1:1.3f}\"\n              .format((epoch+1), epoch_losses[epoch]))\n    ","4c4e8f1a":"plt.title(\"Loss\")\nplt.plot([epoch_losses[i] for i in range(len(epoch_losses.keys()))])","b1a8ef55":"# Pytorch Dog vs Cat","23db1bed":"# Training","8ff4029d":"# Pytorch Model","31f97284":"# Prepare Data","862b01a3":"# Plot losses"}}