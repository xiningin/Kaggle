{"cell_type":{"f9f0ea36":"code","447667a4":"code","b3a926a9":"code","c13e9f0c":"code","61a9024a":"code","93cde1c1":"code","33f3bba5":"code","9d938ea6":"code","00545cff":"code","2de7b2ce":"code","06870215":"code","a288130d":"code","3d5b5d0c":"code","18b41b7d":"code","f10ce097":"code","79bd1b8c":"code","9ca8ca63":"code","26b7dbd7":"markdown","04666a0b":"markdown","f585d560":"markdown","63e1a420":"markdown","a2fc99ad":"markdown","0b1ca8e8":"markdown","e1cf65cb":"markdown","1e1659c1":"markdown","0c95b9bf":"markdown","a1bc85cc":"markdown"},"source":{"f9f0ea36":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","447667a4":"import cv2\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output, Image, display\n%matplotlib inline","b3a926a9":"image =cv2.cvtColor(cv2.imread(\"..\/input\/road-image-with-lanes\/test_image.jpg\"), cv2.COLOR_BGR2RGB) \n\nplt.imshow(image)\nplt.show()","c13e9f0c":"import numpy as np\n\nlane_image = np.copy(image)\nlane_image.shape","61a9024a":"gray = cv2.cvtColor(lane_image, cv2.COLOR_RGB2GRAY)\n\nplt.imshow(gray,cmap='gray')\nplt.show()","93cde1c1":"blur = cv2.GaussianBlur(gray, (5,5), 0)\n\nplt.imshow(blur)\nplt.show()","33f3bba5":"canny = cv2.Canny(blur, 50,150)\n\nplt.imshow(canny)\nplt.show()","9d938ea6":"# put all the previous 3 steps in one function \n# gray scale conversion ==> applying gaussian blur ==> applying canny function\n\ndef Canny(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    blur = cv2.GaussianBlur(gray, (5,5), 0)\n    canny = cv2.Canny(blur, 50, 150)\n    \n    return canny","00545cff":"image = cv2.imread(\"..\/input\/road-image-with-lanes\/test_image.jpg\")\nlane_image = np.copy(image)\ncanny = Canny(lane_image)\n\nplt.imshow(canny)\nplt.show()","2de7b2ce":"# make a function to find region of interest. \n# then, apply bitwise AND operation in order to select just the region of interest\n\ndef region_of_interest(image):\n    height = 700\n    polygons = np.array([[(250,height), (1000,height), (600,250)]])\n    mask = np.zeros_like(image)\n    cv2.fillPoly(mask, polygons, 255)\n    masked_region = cv2.bitwise_and(image, mask)\n    \n    return masked_region","06870215":"# function which draws lines as detected lanes in the black image\n\ndef display_lines(image, lines):\n    line_image = np.zeros_like(image)\n    if lines is not None:\n        for line in lines:\n            x1, y1, x2, y2 = line.reshape(4)\n            cv2.line(line_image, (x1,y1), (x2,y2), (255,0,0), 10)\n    return line_image","a288130d":"# reading the image and then calling all the functions one by one. \n\nimage = cv2.imread(\"..\/input\/road-image-with-lanes\/test_image.jpg\")\n\nlane_image = np.copy(image)\ncanny_image = Canny(lane_image)\ncropped_image = region_of_interest(canny_image)\n\nlines = cv2.HoughLinesP(cropped_image, 2, np.pi\/180, 100, np.array([]), 40, 5)\nline_image = display_lines(lane_image, lines)\n\nplt.imshow(line_image)\nplt.show()","3d5b5d0c":"# final step: put it all together\n# now combine the above immage containing just the lines in a black image with our original image\n\ncombo_image = cv2.addWeighted(lane_image, 1, line_image, 1, 1)\n\nplt.imshow(combo_image)\nplt.show()","18b41b7d":"def make_coordinates(image, line_parameters):\n    slope, intercept = line_parameters\n    y1 = image.shape[0]\n    y2 = int(y1*(3\/5))\n    x1 = int((y1-intercept)\/slope)\n    x2 = int((y2-intercept)\/slope)\n    return np.array([x1,y1,x2,y2])","f10ce097":"def average_slope_intercept(image, lines):\n    left_fit = []\n    right_fit = []\n    \n    for line in lines:\n        x1, y1, x2, y2 = line.reshape(4)\n        parameters = np.polyfit((x1,x2), (y1,y2), 1)\n        \n        slope = parameters[0]\n        intercept = parameters[1]\n        \n        if slope < 0:\n            left_fit.append((slope, intercept))\n        elif slope >= 0:\n            right_fit.append((slope, intercept))\n            \n    left_fit_average = np.average(left_fit, axis=0)\n    right_fit_average = np.average(right_fit, axis=0)\n        \n    left_line = make_coordinates(image, left_fit_average)\n    right_line = make_coordinates(image, right_fit_average)\n        \n    return np.array([left_line, right_line])","79bd1b8c":"# reading the image and then calling all the functions one by one. \n\nimage = cv2.imread(\"..\/input\/road-image-with-lanes\/test_image.jpg\")\n\nlane_image = np.copy(image)\ncanny_image = Canny(lane_image)\ncropped_image = region_of_interest(canny_image)\n\nlines = cv2.HoughLinesP(cropped_image, 2, np.pi\/180, 100, np.array([]), 40, 5)\naveraged_lines = average_slope_intercept(lane_image, lines)\nline_image = display_lines(lane_image, averaged_lines)\n\n# final step: put it all together\n# now combine the above immage containing just the lines in a black image with our original image\n\ncombo_image = cv2.addWeighted(lane_image, 1, line_image, 1, 1)\n\nplt.imshow(combo_image)\nplt.show()","9ca8ca63":"cap = cv2.VideoCapture(\"..\/input\/video-file-for-lane-detection-project\/test_video.mp4\")\n\n#while (cap.isOpened()):\n#    _, frame = cap.read()\n#    canny_image = Canny(frame)\n#    cropped_image = region_of_interest(canny_image)\n#    lines = cv2.HoughLinesP(cropped_image, 2, np.pi\/180, 100, np.array([]), 40, 5)\n#    averaged_lines = average_slope_intercept(frame, lines)\n#    line_image = display_lines(frame, averaged_lines)\n#    combo_image = cv2.addWeighted(frame, 1, line_image, 1, 1)\n    \n#    cv2.imshow(\"result\", combo_image)\n#    if cv2.waitKey(1) == ord(\"q\"):\n#        break\n#cap.release()\n#cv2.destroyAllWindows()","26b7dbd7":"again doing all the steps","04666a0b":"make a function to find region of interest.\n\nthe region where we wanna find the lanes\n\nthen, apply bitwise AND operation in order to select just the region of interest\n\nhough transform in order to find straight lines in the image","f585d560":"Step:1\n\nload the file and show","63e1a420":"now apply the same methods on a video file\n\nwhich will take each frame of the video file\n\n and detect the lanes in each frame\n \n finally play all the frames showing lanes detected in a video.","a2fc99ad":"Do some optimization to refine the detection of lanes","0b1ca8e8":"Step 2:\n\nGray scale conversion of the image","e1cf65cb":"Step 4:\n\napply canny method ","1e1659c1":"Step 3:\n\nApply Gausian Blur to reduce the noise in the gray scale image\n","0c95b9bf":"Reference:\nhttps:\/\/www.youtube.com\/watch?v=eLTLtUVuuy4&t=1560s","a1bc85cc":" * i have commented the lines above, since the kernal dies whenever i try to play video in kaggle notebook,\n  but if u run this in pycharm or any other IDE, it works fine.\n  \n  basically output file shows every frame for 1 ms with lanes detected, and hence the lanes are detected in the video."}}