{"cell_type":{"82eb0dce":"code","d21423c9":"code","57f9c232":"code","bfcb50e5":"code","8fa85269":"code","096a8f2e":"code","6c0cb350":"code","9ae21051":"code","25cf7f2d":"code","b5f7dc1c":"code","63898232":"code","c946a99f":"code","2c087370":"code","0468a178":"code","06eb81b6":"code","ea0a426a":"code","ecab27e1":"code","60bfad2c":"code","158071ed":"code","b81260c1":"markdown","b54af4f8":"markdown","3f9079d1":"markdown","2d5549eb":"markdown","7a019c4e":"markdown","4a3bf11f":"markdown","d0fdaf47":"markdown","ed4bc94a":"markdown","5e8567b2":"markdown","857af820":"markdown","888c2b25":"markdown","37e914c4":"markdown"},"source":{"82eb0dce":"!pip install spotipy","d21423c9":"# Basic data science packages\nimport pandas as pd\nimport numpy as np\n\n# Auxiliary packages from standard library\nimport json\nimport sys\nimport itertools\n\n# Machine learning and data visualization tools\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom sklearn.preprocessing import MinMaxScaler\nimport matplotlib.pyplot as plt\n\n# Wrappers for the Spotify API\nimport spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\nfrom spotipy.oauth2 import SpotifyOAuth\nimport spotipy.util as util","57f9c232":"tracks_df = pd.read_csv('\/kaggle\/input\/spotify-dataset-19212020-160k-tracks\/data.csv')\ngenre_df = pd.read_csv('\/kaggle\/input\/spotify-dataset-19212020-160k-tracks\/data_w_genres.csv')","bfcb50e5":"tracks_df.head()","8fa85269":"genre_df.head()","096a8f2e":"genre_df.dtypes","6c0cb350":"genre_df['genres'].values[0][0]","9ae21051":"def string_to_list(input_string):\n    list_of_strings = list()\n    \n    if len(input_string) == 2:  # Skip empty lists \n        return list_of_strings\n\n    strings = input_string[1:-1]  # Cut off the brackets\n    \n    strings = strings.split(', ')\n    for string in strings:\n        string = string.replace(' ', '_')\n        string = string[1:-1]  # Cut off the apostrophes\n        list_of_strings.append(string)\n    \n    return list_of_strings\n\n\ngenre_df['genres_upd'] = genre_df['genres'].apply(string_to_list)\ngenre_df['genres_upd'].values[0][0]","25cf7f2d":"tracks_df['artists_upd'] = tracks_df['artists'].apply(string_to_list)\ntracks_df['artists_upd'].values[0][0]","b5f7dc1c":"def concatenate_artist_song(row):\n    artist = row['artists_upd'][0]\n    song = row['name']\n    \n    return artist + song    \n    \n\noriginal_df_lenght = len(tracks_df['artists_upd'])\n\ntracks_df['artists_song'] = tracks_df.apply(concatenate_artist_song, axis=1)\n\ntracks_df.drop_duplicates('artists_song', inplace=True)\n\nremoved_duplicates = original_df_lenght - len(tracks_df['artists_song'])\n\nprint(f\"Removed {removed_duplicates} duplicates from the dataset\")","63898232":"artists_exploded = tracks_df[['artists_upd','id']].explode('artists_upd')\nartists_exploded_merged = artists_exploded.merge(genre_df, \n                                                 how = 'left', \n                                                 left_on = 'artists_upd',\n                                                 right_on = 'artists')\n\n# Remove rows without genre\nartists_exploded_merged_nonnull = artists_exploded_merged[~artists_exploded_merged.genres_upd.isnull()]","c946a99f":"def consolidate_list(genres):\n    # Flatten the genres list\n    genres = itertools.chain.from_iterable(genres)\n              \n    # Remove duplicates\n    genres = set(genres)\n    \n    return list(genres)\n\nartists_genres_consolidated = artists_exploded_merged_nonnull.groupby('id')['genres_upd'].apply(list).reset_index()\nartists_genres_consolidated['consolidates_genre_lists'] = artists_genres_consolidated['genres_upd'].apply(consolidate_list)\n\n\nartists_genres_consolidated.head()","2c087370":"tracks_df = tracks_df.merge(artists_genres_consolidated[['id','consolidates_genre_lists']], \n                            on='id',\n                            how='left')\ntracks_df.head()","0468a178":"def normalize_floats(df):\n    float_cols = df.dtypes[df.dtypes == 'float64'].index.values\n\n    #scale float columns\n    floats = df[float_cols].reset_index(drop=True)\n    scaler = MinMaxScaler()\n    floats_scaled = pd.DataFrame(scaler.fit_transform(floats), \n                                 columns=floats.columns) * 0.2\n    \n    return floats_scaled\n\nfloats_scaled = normalize_floats(tracks_df)\n\nfloats_scaled.head()","06eb81b6":"def get_year(release_date):\n    year, *_ = release_date.split('-')\n    \n    return year\n\ntracks_df['year'] = tracks_df['release_date'].apply(get_year)\ntracks_df['year'].head()","ea0a426a":"# Divide popularity into 10 categories\ntracks_df['popularity_red'] = tracks_df['popularity'].apply(\n    lambda genre: genre \/\/ 10\n)\n\ntracks_df['popularity_red'].unique()","ecab27e1":"def ohe_prep(df, column, new_name): \n    tf_df = pd.get_dummies(df[column])\n    feature_names = tf_df.columns\n    \n    tf_df.columns = [f\"{new_name}|{feature}\" for feature in feature_names]\n    tf_df.reset_index(drop=True, \n                      inplace=True)    \n    \n    return tf_df\n\nyear_ohe = ohe_prep(tracks_df, 'year','year') * 0.5\npopularity_ohe = ohe_prep(tracks_df, 'popularity_red','pop') * 0.15\n\nohe_features = pd.concat([year_ohe, popularity_ohe], axis=1)\nohe_features.columns","60bfad2c":"def tfidf_feature(df):\n    #tfidf genre lists\n    tfidf = TfidfVectorizer()\n    tfidf_matrix =  tfidf.fit_transform(df['consolidates_genre_lists'].apply(\n        lambda genres: \" \".join(genres)\n    ))\n    \n    genre_df = pd.DataFrame(tfidf_matrix.toarray())\n    \n    genre_df.columns = [f\"genre|{feature}\" for feature in tfidf.get_feature_names()]\n    genre_df.reset_index(drop = True, inplace=True)\n    \n    return genre_df\n\n# TF-IDF can't handle NULL values, so they must be replaced by empty lists\ntracks_df['consolidates_genre_lists'] = tracks_df['consolidates_genre_lists'].apply(\n    lambda genres: genres if isinstance(genres, list) else list()\n)\n\ngenre_df = tfidf_feature(tracks_df)\ngenre_df.head()","158071ed":"complete_feature_set = pd.concat([genre_df, floats_scaled, ohe_features], axis=1)\ncomplete_feature_set['id'] = tracks_df['id'].values\n\ncomplete_feature_set.head()","b81260c1":"To work with the list of genres as intended, we must convert the string to a list of strings.","b54af4f8":"There are also duplicate songs from the same artist that must be removed.","3f9079d1":"## Data exploration & feature engineering","2d5549eb":"# Spotify Recomendation Engine","7a019c4e":"Then, it's necessary to explode the artist feature so it can be merged with the genre dataset.","4a3bf11f":"Finally, we are going to create TF-IDF features off of the artist genres.\n\nTF-IDF consists in an OHE method that balances the feature weights based on how often they appear on the dataset. An uncommon genre should have a bigger impact on the recommended tracks than a common one.","d0fdaf47":"### Installing and importing dependecies","ed4bc94a":"Now that we have explored and merged the datasets, it's time to start the **feature engineering** proccess.\n\nFirst, we are going to normalize the `float64` features.","5e8567b2":"The `genres` feature is actually a string made to look like a list. This can be proven by the indexing the first value of the first row.","857af820":"Similarly, we must convert the `artist` feature to a list of names.","888c2b25":"Now that we have all the features we can combine them in a single dataset.","37e914c4":"Then we need to OHE the year and popularity features."}}