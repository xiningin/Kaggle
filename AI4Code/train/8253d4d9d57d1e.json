{"cell_type":{"abb71062":"code","a549051c":"code","f89c1854":"code","69d9a940":"code","85b71244":"code","ea6f9e70":"code","a35b309a":"code","751d588e":"code","43506a27":"code","5844c91f":"code","8fa2f773":"code","a681955d":"code","03be07d9":"code","47c272b3":"code","a65c1087":"code","ebf448c8":"code","66f8562d":"markdown","1c4b4825":"markdown","6c4aeadc":"markdown","320699d1":"markdown","1d9df57e":"markdown","c717f295":"markdown","275078c3":"markdown","4fbd381e":"markdown","dc3e5c3e":"markdown","c8fba536":"markdown"},"source":{"abb71062":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport re\nimport seaborn as sns\nfrom scipy import stats\nfrom math import sqrt\n\nP_inf = 0.2\n\nN = 10\nn_days = 90\n\nP_latent = [0.01, 0.03, 0.05, 0.2, 0.6, 0.1, 0.01]\nP_active = [0.005, 0.02, 0.04, 0.015, 0.02, 0.035, 0.15, 0.5, 0.09, 0.04, 0.04, 0.02, 0.02, 0.005]\nP_die = [0.01, 0.01, 0.03, 0.05, 0.07, 0.12, 0.18, 0.2, 0.1, 0.07, 0.05, 0.05, 0.04, 0.02]\n\nx_die = [x+1 for x in range(len(P_die))]\nx_latent = [x+1 for x in range(len(P_latent))]\nx_active = [x+1 for x in range(len(P_active))]\n\nlatent_series = pd.DataFrame({'Day': x_latent, 'Prob': P_latent}).set_index('Day')\nactive_series = pd.DataFrame({'Day': x_active, 'Prob': P_active}).set_index('Day')\ndie_series = pd.DataFrame({'Day': x_die, 'Prob': P_die}).set_index('Day')","a549051c":"def simulation(number):\n    #create a daily information table for each family member\n    global family_model\n    family_model = pd.DataFrame({'Day': [x for x in range(n_days+1)]}).set_index('Day')\n    \n    for n in range(N):\n        family_model[f'N{n+1}'] = 'he'\n\n    #initialization of the first family member in the latent period\n    start_chlen = np.random.randint(N)\n    all_family = list(family_model.columns)\n    \n    family_model.iloc[0, start_chlen] = 'l0'\n    \n    #associated counters and arrays for each type of family member\n    n_he = N-1\n    n_he_array = [n_he]\n    \n    global all_h, all_de, all_a, all_re, all_l\n    all_h = all_family.copy()\n    all_h.remove(family_model.columns.values[start_chlen])\n    \n    n_de = n_a = n_re = 0\n    n_de_acc = n_a_acc = 0\n    all_de = list()\n    all_a = list()\n    all_re = list()\n    \n    n_re_array = [0]\n    n_de_array = [0] \n    n_a_array = [0]\n    n_de_acc_array = [0] \n    n_a_acc_array = [0]\n    \n    n_l = n_l_acc = 1\n    n_l_array = [n_l]\n    n_l_acc_array = [n_l_acc]\n    all_l = list()\n    all_l.append(family_model.columns.values[start_chlen])\n    \n    #experiment simulation\n    for day in range(0, n_days, 1):\n        for user in range(N):\n            cur = family_model.iloc[day, user]\n            \n            #latent\n            if re.findall(r'\\w', cur)[0]=='l':\n                id = int(re.findall(r'\\d+', cur)[0])\n                check_nextday = np.random.rand()\n                if id<len(P_latent):\n                    #every day a new random value and check\n                    #if the random value is greater than the value in the series, then the next day the latent phase continues\n                    if check_nextday >= latent_series.Prob.iloc[id]:\n                        family_model.iloc[day+1, user] = f'l{id+1}'\n                    #otherwise goes into the active phase\n                    else:\n                        family_model.iloc[day+1, user] = 'a1'\n                        n_l = n_l - 1\n                        all_l.remove(family_model.columns.values[user])\n                        n_a = n_a + 1\n                        n_a_acc = n_a_acc + 1\n                        all_a.append(family_model.columns.values[user])\n                #if all the days have passed, then we ourselves determine that the person goes into the active phase       \n                else:\n                    family_model.iloc[day+1, user] = 'a1'\n                    n_l = n_l - 1\n                    all_l.remove(family_model.columns.values[user])\n                    n_a = n_a + 1\n                    n_a_acc = n_a_acc + 1\n                    all_a.append(family_model.columns.values[user])\n            \n            #active\n            if re.findall(r'\\w', cur)[0]=='a':\n                id = int(re.findall(r'\\d+', cur)[0])\n                check_nextday = np.random.rand()\n                check_die = np.random.rand()\n                \n                #every day a new random value and check\n                #if the random value is greater than the value in the series, then the next day the latent phase continues\n                if id<len(P_active):\n                    if check_nextday >= active_series.Prob.iloc[id]:\n                        family_model.iloc[day+1, user] = f'a{id+1}'\n                    #otherwise either dies or recovered\n                    else:\n                        if check_die < die_series.Prob.iloc[id]:\n                            family_model.iloc[day+1:, user] = 'de'\n                            n_a = n_a - 1\n                            all_a.remove(family_model.columns.values[user])\n                            n_de = n_de + 1\n                            n_de_acc = n_de_acc + 1\n                            all_de.append(family_model.columns.values[user])\n                        else:\n                            family_model.iloc[day+1:, user] = 're'\n                            n_a = n_a - 1\n                            all_a.remove(family_model.columns.values[user])\n                            n_re = n_re + 1\n                            all_re.append(family_model.columns.values[user])\n                #the period of the active phase has passed and the person has not died, so he recovered      \n                else:\n                    family_model.iloc[day+1:, user] = 're'\n                    n_a = n_a - 1\n                    all_a.remove(family_model.columns.values[user])\n                    n_re = n_re + 1\n                    all_re.append(family_model.columns.values[user])\n                        \n                        \n                #the generation of new infections\n                check_inf = np.random.rand()\n                #check whether someone can be infected\n                if len(all_h)!=0: \n                    \n                    if check_inf < (1-(1-P_inf)**(n_a)):\n                        #choose whom to infect\n                        select_victim = np.random.randint(n_he)\n                        victim = all_h[select_victim]\n                        family_model[victim].iloc[day+1]='l1'\n                        all_l.append(victim)\n                        n_l = n_l + 1\n                        n_l_acc = n_l_acc + 1\n                        all_h.remove(victim)\n                        n_he = n_he - 1\n        #update the values of arrays at the end of each day         \n        n_l_array.append(n_l)\n        n_l_acc_array.append(n_l_acc)\n        n_he_array.append(n_he)\n        n_de_array.append(n_de)\n        n_de_acc_array.append(n_de_acc)\n        n_re_array.append(n_re)\n        n_a_array.append(n_a)\n        n_a_acc_array.append(n_a_acc)\n\n    return n_a_array, n_he_array, n_l_array, n_de_array, n_re_array, n_a_acc_array, n_l_acc_array, n_de_acc_array","f89c1854":"times=100\nsim = []\n\nfor id in range(times):\n    sim.append(simulation(id+1))","69d9a940":"def stats_array_by_case(array, days, n, case):\n    mean_case_by_days = []\n    std_case_by_days = []\n    for day in range(days):\n        array_day = []\n        for i in range(n):\n            array_day.append(array[i][case][day])\n        array_day = np.array(array_day)\n        mean_case_by_days.append(array_day.mean())\n        std_case_by_days.append(array_day.std(ddof=1))\n        \n    return np.array(mean_case_by_days), np.array(std_case_by_days)","85b71244":"mean_a_days, std_a_days = stats_array_by_case(sim, n_days, times, 0)\nmean_he_days, std_he_days = stats_array_by_case(sim, n_days, times, 1)\nmean_l_days, std_l_days = stats_array_by_case(sim, n_days, times, 2)\nmean_de_days, std_de_days = stats_array_by_case(sim, n_days, times, 3)\nmean_re_days, std_re_days = stats_array_by_case(sim, n_days, times, 4)\nmean_a_acc_days, std_a_acc_days = stats_array_by_case(sim, n_days, times, 5)\nmean_l_acc_days, std_l_acc_days = stats_array_by_case(sim, n_days, times, 6)\nmean_de_acc_days, std_de_acc_days = stats_array_by_case(sim, n_days, times, 7)","ea6f9e70":"def stats_graph(n_a, n_he, n_l, n_de, n_re, name, acc, ind):\n    accomodation = 'without accumulation'\n    indent = '(expected value)'\n    if (acc==1):\n        accomodation = 'with accumulation'\n    if (ind==1):\n        indent = '(standard deviation)'\n    plt.grid(alpha=0.4)\n    plt.plot(n_a, c='r', label='Active inf case')    \n    plt.plot(n_he, c='g', label='Healthy case')\n    plt.plot(n_l, c='y', label='Latention case')\n    plt.plot(n_de, c='k', label='Die case')\n    plt.plot(n_re, c='c', label='Recover case')\n    plt.title(name+f'\\n (case {accomodation})')\n    plt.xlabel('Days after first infection')\n    plt.ylabel('Number of members')\n    plt.legend(loc = 'best')\n    plt.savefig(f\"lineplot {accomodation} {indent}.png\") \n    plt.show()","a35b309a":"stats_graph(mean_a_days, mean_he_days, mean_l_days, mean_de_days, mean_re_days, 'Monte-Carlo results after '+str(times)+' simulation (expected value)', 0, 0)","751d588e":"stats_graph(mean_a_acc_days, mean_he_days, mean_l_acc_days, mean_de_acc_days, mean_re_days, 'Monte-Carlo results after '+str(times)+' simulation (expected value)', 1, 0)","43506a27":"stats_graph(std_a_days, std_he_days, std_l_days, std_de_days, std_re_days, 'Monte-Carlo results after '+str(times)+' simulation (standard deviation)', 0, 1)","5844c91f":"df = pd.DataFrame({'Day': [x+1 for x in range(n_days)],\n                       'Healthy cases': mean_he_days,\n                       'Latent cases': mean_l_days,\n                       'Active cases': mean_a_days,\n                       'Die cases': mean_de_days,\n                       'Recover cases': mean_re_days})\ndf.to_csv('Expected value without accomodation.csv', index=False)\n\ndf_acc = pd.DataFrame({'Day': [x+1 for x in range(n_days)],\n                       'Healthy cases': mean_he_days,\n                       'Latent cases': mean_l_acc_days,\n                       'Active cases': mean_a_acc_days,\n                       'Die cases': mean_de_acc_days,\n                       'Recover cases': mean_re_days})\ndf_acc.to_csv('Expected value with accomodation.csv', index=False)","8fa2f773":"def conf_interval(mean, std_mean, dof, alpha):\n    tcrit = stats.t.ppf(1 - alpha \/ 2., dof)\n    lower = mean - tcrit * std_mean\/sqrt(dof)\n    upper = mean + tcrit * std_mean\/sqrt(dof)\n    return round(lower, 5), round(upper, 5), tcrit","a681955d":"day_check=15\nprint('Enter the day number for which you want to see statistics: ', day_check)\n\neps=0.05\nprint('Enter the (1-p) of confidence interval: ', eps)\n    \nprint(f'\\nActual Active case mean in {day_check} day: ', mean_a_days[day_check])\nt_actual = conf_interval(mean_a_days[day_check], std_a_days[day_check]\/sqrt(len(std_a_days)), times-1, eps)\nprint(f'Active case mean {int((1-eps)*100)}% confidence interval in {day_check} day: ', t_actual[:2])\n    \nprint(f'\\nActual Heath case mean in {day_check} day: ', mean_he_days[day_check])\nt_heath = conf_interval(mean_he_days[day_check], std_he_days[day_check]\/sqrt(len(std_a_days)), times-1, eps)\nprint(f'Heath case mean {int((1-eps)*100)}% confidence interval in {day_check} day: ', t_heath[:2])\n\nprint(f'\\nActual Latent case mean in {day_check} day: ', mean_l_days[day_check])\nt_latent = conf_interval(mean_l_days[day_check], std_l_days[day_check]\/sqrt(len(std_a_days)), times-1, eps)\nprint(f'Latent case mean {int((1-eps)*100)}% confidence interval in {day_check} day: ', t_latent[:2])\n\nprint(f'\\nActual Die case mean in {day_check} day: ', mean_de_days[day_check])\nt_die = conf_interval(mean_de_days[day_check], std_de_days[day_check]\/sqrt(len(std_a_days)), times-1, eps)\nprint(f'Die case mean {int((1-eps)*100)}% confidence interval in {day_check} day: ', t_die[:2])\n\nprint(f'\\nActual Recover case mean in {day_check} day: ', mean_re_days[day_check])\nt_recover = conf_interval(mean_re_days[day_check], std_re_days[day_check]\/sqrt(len(std_a_days)), times-1, eps)\nprint(f'Recover case mean {int((1-eps)*100)}% confidence interval in {day_check} day: ', t_recover[:2])","03be07d9":"def conf_interval_graph(t_a, t_he, t_l, t_de, t_re, day, n_a, n_he, n_l, n_de, n_re, name):\n    \n    plt.grid(alpha=0.4)\n    plt.plot(n_a, c='r', label='Active inf case')\n    plt.plot(day, t_a[0], marker = 6, markersize=5, c='r')\n    plt.plot(day, t_a[1], marker = 7, markersize=5, c='r')    \n    plt.plot(n_he, c='g', label='Healthy case')\n    plt.plot(day, t_he[0], marker = 6, markersize=5, c='g')\n    plt.plot(day, t_he[1], marker = 7, markersize=5, c='g')\n    plt.plot(n_l, c='y', label='Latention case')\n    plt.plot(day, t_l[0], marker = 6, markersize=5, c='y')\n    plt.plot(day, t_l[1], marker = 7, markersize=5, c='y')\n    plt.plot(n_de, c='k', label='Die case')\n    plt.plot(day, t_de[0], marker = 6, markersize=5, c='k')\n    plt.plot(day, t_de[1], marker = 7, markersize=5, c='k')\n    plt.plot(n_re, c='c', label='Recover case')\n    plt.plot(day, t_re[0], marker = 6, markersize=5, c='c')\n    plt.plot(day, t_re[1], marker = 7, markersize=5, c='c')\n    \n    plt.xlim(day-day\/2, day+(n_days-day)\/4)\n    plt.title(name)\n    plt.xlabel('Days after first infection')\n    plt.ylabel('Number of members')\n    plt.legend(loc = 'best')\n    plt.savefig(\"conf_interval.png\")\n    plt.show()","47c272b3":"conf_interval_graph(t_actual, t_heath, t_latent, t_die, t_recover, day_check, mean_a_days, mean_he_days, mean_l_days, mean_de_days, mean_re_days, 'Confidence intervals of cases')","a65c1087":"def conf_find_number(mean, std_mean, tcrit, eps):\n    n = (tcrit*std_mean\/eps)**2\n    return int(n)+1","ebf448c8":"e=0.01\nprint('Enter the length of half-interval: ',e)\n\nn_actual = conf_find_number(mean_a_days[day_check], std_a_days[day_check], t_actual[2], e)\nprint(f'Number of exp for Active case in {day_check} day with {2*e} length interval: ', n_actual)\n\nn_health = conf_find_number(mean_he_days[day_check], std_he_days[day_check], t_heath[2], e)\nprint(f'Number of exp for Health case in {day_check} day with {2*e} length interval: ', n_health)\n\nn_latent = conf_find_number(mean_l_days[day_check], std_l_days[day_check], t_latent[2], e)\nprint(f'Number of exp for Latent case in {day_check} day with {2*e} length interval: ', n_latent)\n\nn_die = conf_find_number(mean_de_days[day_check], std_de_days[day_check], t_die[2], e)\nprint(f'Number of exp for Die case in {day_check} day with {2*e} length interval: ', n_die)\n\nn_recover = conf_find_number(mean_re_days[day_check], std_re_days[day_check], t_recover[2], e)\nprint(f'Number of exp for Recover case in {day_check} day with {2*e} length interval: ', n_recover)","66f8562d":"# Estimating using the t-interval","1c4b4825":"# Conclusions\n* The study allows, depending on the input parameters to simulate the situation without the actual fact of infection\n* The results of the model help to understand the need for quarantine restrictions within the family\n* In practice, it was possible to apply such knowledge of mathematical statistics as: Monte Carlo method and Law of large numbers (estimation of mathematical expectation), central limit theorem (approximation of the distribution by normal distribution), confidence intervals (construction of estimation of mathematical expectation).\n\nP.S Also you can check our research on topic [\"Prediction of Ukrainian hryvnia exchange rate\"](https:\/\/www.kaggle.com\/imgremlin\/prediction-of-ukrainian-hryvnia-exchange-rate)","6c4aeadc":"We simulate our experiment 100 times (the more we set the value, the more accurate the result will be, but we sacrifice time)\n\nThe probabilities of all events in the experiment are generated as the probability of success or failure:\n<img src=\"https:\/\/github.com\/imgremlin\/Photos\/blob\/master\/Screenshot%20(25).png?raw=true\" width=\"250px\">","320699d1":"At the end program shows several plots - the dynamics of the next n_days days since the first case of coronavirus in the family (without and with accumulation), the standard deviation of each day and a graphical illustration of confidence intervals.\n\n**Plots explanation:**\n* The green curve shows the number of healthy people.\n* Orange curve - the number of people with the disease in the latent period.\n* Red curve - the number of people with the disease during the period of active infection.\n* Black curve - the number of deaths.\n* Blue curve - the number of people who were cured.","1d9df57e":"* Enter the day number for which you want to calculate the intervals\n* And also (1-level of trust).\n\nWe are looking for the number of tests to achieve the size of the interval (specify the average, std, the definition of the quantile, the size of the half-interval)","c717f295":"**Internal functions of the program:**\n* stats_graph - function for plotting\n* conf_interval_graph - illustration of confidence intervals\n* simulation - simulation of a certain number of experiments\n* stats_array_by_case - calculation of the sample mean and deviation for each day\n* conf_interval - calculation of confidence intervals\n* conf_find_number - counting the number of experiments for a given interval length\n\n**Internal designations:**\n* he := healthy person (not sick)\n* de := dead person\n* l{i} := latent person on {i} day of this period of illness\n* a{i} := actively contagious person on {i} days of this period of illness\n* re := the person recovered and gained immunity","275078c3":"And also calculation of **confidence intervals:**\n* Enter the day number for which you want to see statistics\n* Enter the (1-p) of confidence interval","4fbd381e":"# Implementation\n**Features of the model:** does not involve recurrent diseases; cured and healthy are counted separately; if the latent period (tabular data) has passed, and the person has not yet passed to active, it passes automatically\n\n**Input data**\n* P_inf - likelihood of becoming infected from an already infected person\n* P_latent - probability distribution to go from latent to active period of the disease\n* P_active - probability distribution to get out of the active phase of the disease (recover or die)\n* P_die - \u0440\u043e\u0437\u043f\u043e\u0434\u0456\u043b \u0439\u043c\u043e\u0432\u0456\u0440\u043d\u043e\u0441\u0442\u0456 \u0441\u043c\u0435\u0440\u0442\u0456 \u0445\u0432\u043e\u0440\u043e\u0457 \u043b\u044e\u0434\u0438\u043d\u0438 of a sick person to die\n* N - number of people\n* n_days - number of days for simulation","dc3e5c3e":"<img src=\"https:\/\/www.uzhnu.edu.ua\/uploads\/news\/20200404_1320_covid-19-2-1140x450.jpg\" width=\"1000px\"> \n# Simulation of the spread of COVID-19 indoors\n\n**by team GORNYAKI (Tsepa Oleksii and Samoshin Andriy [Ukraine, KPI, IASA])**\n\n**The task** is to create a model of virus spread among people indoors based on some parameters and to determine the confidence intervals for the mathematical expectations of each category of people at time t with a confidence level of 95%.\n\n**Input parameters:**\n* Time when a person is infected but not contagious - latency period (tabular data)\n* Time from the beginning of contagion to the end of contagion - the period of active infection (tabular data)\n* Distribution of probabilities of death during the period of active infection (tabular data)\n* The value of the probability of becoming infected from an already infected person\n\n**Practical value:** provided that the input parameters reflect the real situation, we can simulate the situation when a family member \"brought\" the virus home, and understand how critical the consequences can be depending on the number of family members and quarantine measures within the family.","c8fba536":"# Description and substantiation of the approach to model construction\nWe model the dynamics of the virus in the family using the Monte Carlo method. This method is based on a large number of computer simulations based on input parameters. Using this method and the law of large numbers, we obtain the approximate value of the mathematical expectation, since n is the number of simulations, a large number.\n<img src=\"https:\/\/github.com\/imgremlin\/Photos\/blob\/master\/Screenshot%20(22).png?raw=true\" width=\"220px\">\nWe do not know the distribution of each group of people, but according to the central limit theorem, the distribution of the sample mean is approximately normal (because the number experiments large enough n>100) with an unknown standard deviation. Therefore, to construct confidence intervals, we use the formula:\n<img src=\"https:\/\/github.com\/imgremlin\/Photos\/blob\/master\/Screenshot%20(23).png?raw=true\" width=\"115px\">\nwhere \ud835\udc4b\u0305 is the sample mean, \ud835\udc50 is the tabular value of the t-distribution corresponding to 1 \u2212 \ud835\udefc\/2, with n-1 degrees of freedom, \ud835\udc46\ud835\udc5b is the sample standard deviation.\nAs a result, we have point estimates for mathematical expectations and confidence intervals.\nThe value that is added and subtracted from the sample mean is equal to half the length of the interval.\n<img src=\"https:\/\/github.com\/imgremlin\/Photos\/blob\/master\/Screenshot%20(24).png?raw=true\" width=\"135px\">\nSolving the equation with respect to n, we obtain the following:\n<img src=\"https:\/\/github.com\/imgremlin\/Photos\/blob\/master\/Screenshot%20(26).png?raw=true\" width=\"150px\">\nWe use this formula to determine the required number of experiments for a given length of confidence intervals.\n\n**The initial input data:**\nwe believe that the virus does not change over time, so we use estimates of virus parameters that have already been made by scientists before modeling. The only thing that can change for each family is the extent to which it is quarantined (if everyone is sitting in their own rooms, the probability of getting sick from another family member is much lower). Also, the model does not take into account the possibility of infection from the outside (shops, churches, etc.).\n\n\nWhen we know all the parameters, **model predicts** :\n* increase and decrease in morbidity\n* approximate peak time\n* the number of people in each category at a particular time"}}