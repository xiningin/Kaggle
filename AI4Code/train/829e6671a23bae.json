{"cell_type":{"892a0ef3":"code","9299ed62":"code","47d2a63e":"code","be888bc8":"code","bf6c23d8":"code","7dc488a7":"code","a39bfb0e":"code","24adc404":"code","4317cfc6":"code","faab2c85":"code","cefe3c66":"code","68d7e031":"code","d39f2c24":"code","d2909903":"markdown","ab3b533b":"markdown","ffff9f5c":"markdown","3bf1413e":"markdown","de76880e":"markdown","e9c9137a":"markdown","eecd00f6":"markdown","912c699c":"markdown","c986d6c1":"markdown","c11dcee4":"markdown","99076b70":"markdown","5774062e":"markdown","00d31f2b":"markdown","a89fce17":"markdown"},"source":{"892a0ef3":"# data analysis\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\ntrain = pd.read_csv(\"\/kaggle\/input\/titanic\/train.csv\")\ntest = pd.read_csv(\"\/kaggle\/input\/titanic\/test.csv\")\ncombined = [train, test]","9299ed62":"# Interesting, two different persons with the same name !\nfull = train.append(test)\nfull[full.Name == \"Connolly, Miss. Kate\"]","47d2a63e":"#let's drop columns that we won't use for an easier reading\nto_drop = [\"SibSp\", \"Parch\", \"Cabin\", \"Embarked\"] #I'm leaving Pclass, Age and Fare because it will help some later choices.\ntest.drop(columns=to_drop, inplace=True)\ntrain.drop(columns=to_drop, inplace=True)","be888bc8":"#Extracting Title feature and converting into Mr, Mrs, Miss and Master\ntrain['Title'] = train.Name.str.extract(' ([A-Za-z]+)\\.', expand=False)\ntrain['Title'] = train['Title'].replace([\"Capt\", 'Col','Don', 'Dr', 'Major', 'Rev', 'Sir', 'Jonkheer'], 'Mr') #one doctor is female, but we'll ignore it\ntrain['Title'] = train['Title'].replace(['Mlle', \"Ms\", \"Lady\"], 'Miss')\ntrain['Title'] = train['Title'].replace(['Mme', \"Dona\", \"Countess\"], 'Mrs')\n\n#Extracting Surname feature\ntrain['Surname'] = train.Name.str.extract(\"^([A-Za-z\\s\\-\\']+)\\,\", expand= False)\n\n#Creating GroupId feature and counting occurrences in GroupFreq\ntrain['GroupId'] = train.Surname + \" \" + train.Pclass.astype(\"str\") + \" \" + train.Ticket.str[:-2] + \"XX\"\ntrain.loc[train.Title == \"Mr\", \"GroupId\"] = np.nan\ntrain[\"GroupFreq\"] = train.groupby(\"GroupId\")[\"GroupId\"].transform(\"size\")\n\n#Additional code\n#train['Cab'] = train.Cabin.str.extract(r'(^[A-Z])', expand = False)\n#train['Maiden'] = train.Name.str.extract('([A-Za-z]+)\\)', expand=False)\n#train['FamSize'] = train.SibSp + train.Parch + 1\n\ndisplay(train[train.Surname ==\"Dodge\"])\ndisplay(test[test.Ticket ==\"33638\"])","bf6c23d8":"#extract ticket occurrences without counting \"Mr\"\ntrain[\"TicketId\"] = train.Ticket.copy()\ntrain.loc[train.Title == \"Mr\", \"TicketId\"] = np.nan\ntrain[\"TicketFreq\"] = train.groupby(\"TicketId\")[\"TicketId\"].transform(\"size\")\n\n#assign the same GroupId for female passengers with the same Ticket and increment GroupFreq+1\ngroupId = train.columns.get_loc(\"GroupId\")\nticket = train.columns.get_loc(\"Ticket\")\ngroupFreq = train.columns.get_loc(\"GroupFreq\")\ngroup_set = set()\nfor i in train[(train.Title != \"Mr\") & (train.GroupFreq == 1) & (train.TicketFreq > 1)].index.tolist():\n    train.iloc[i, groupId] = train.loc[train.Ticket == train.iloc[i, ticket], \"GroupId\"].sort_values().iloc[0]\n    train.iloc[i, groupFreq] += 1\n    group_set.add(train.iloc[i, groupId])\nprint(\"GroupId of female passengers with a non-unique Ticket:\\n\", \"\\n \".join(group_set), \"\\n\\nTwo examples: Allison 1 1137XX and Hays 1 117XX\")\n\n    \ndisplay(train[train.GroupId == \"Allison 1 1137XX\"])\ndisplay(train[train.GroupId == \"Hays 1 117XX\"])\n#display(train[train.GroupId == \"Madill 1 2416X\"])","7dc488a7":"#understand whether the cabin position gives some information\n#train[\"C\"] = train.Cabin.str.extract(r'(^[A-Z])', expand = False)\n#display(train.groupby([\"C\", \"Title\"])[\"Survived\"].agg([\"mean\", \"sum\", \"count\"]))\n#train[train.C == \"E\"].sort_values(\"Cabin\")\n#train.groupby(\"Cabin\")[\"Survived\"].agg([\"mean\",\"count\"]).sort_values([\"mean\", \"count\"], ascending=False).head(55)","a39bfb0e":"train[\"SurvivalG\"] = train.groupby(\"GroupId\").Survived.transform(\"mean\")\ntrain[\"SurvivalT\"] = train.groupby(\"TicketId\").Survived.transform(\"mean\")\ndisplay(train.tail())","24adc404":"#Extracting Title feature and converting into Mr, Mrs, Miss and Master\ntest['Title'] = test.Name.str.extract(' ([A-Za-z]+)\\.', expand=False)\ntest['Title'] = test['Title'].replace([\"Capt\", 'Col','Don', 'Dr', 'Major', 'Rev', 'Sir', 'Jonkheer'], 'Mr') #one doctor is female, but we'll ignore it\ntest['Title'] = test['Title'].replace(['Mlle', \"Ms\", \"Lady\"], 'Miss')\ntest['Title'] = test['Title'].replace(['Mme', \"Dona\", \"Countess\"], 'Mrs')\n\n#Extracting Surname feature\ntest['Surname'] = test.Name.str.extract(\"^([A-Za-z\\s\\-\\']+)\\,\", expand= False)\n\n#Creating GroupId feature and counting occurrences in GroupFreq\ntest['GroupId'] = test.Surname + \" \" + test.Pclass.astype(\"str\") + \" \" + test.Ticket.str[:-2] + \"XX\"\ntest.loc[test.Title == \"Mr\", \"GroupId\"] = np.nan\ntest[\"GroupFreq\"] = test.groupby(\"GroupId\")[\"GroupId\"].transform(\"size\")\n\n#extract ticket occurrences without counting \"Mr\"\ntest[\"TicketId\"] = test.Ticket.copy()\ntest.loc[test.Title == \"Mr\", \"TicketId\"] = np.nan\ntest[\"TicketFreq\"] = test.groupby(\"TicketId\")[\"TicketId\"].transform(\"size\")\n\n#assign the same GroupId for female passengers with the same Ticket and increment GroupFreq+1\ngroupId = test.columns.get_loc(\"GroupId\")\nticket = test.columns.get_loc(\"Ticket\")\ngroupFreq = test.columns.get_loc(\"GroupFreq\")\ngroup_set = set()\nfor i in test[(test.Title != \"Mr\") & (test.GroupFreq == 1) & (test.TicketFreq > 1)].index.tolist():\n    test.iloc[i, groupId] = test.loc[test.Ticket == test.iloc[i, ticket], \"GroupId\"].sort_values().iloc[0]\n    test.iloc[i, groupFreq] += 1\n    group_set.add(test.iloc[i, groupId])\nprint(\"GroupId of female passengers with a non-unique Ticket:\\n\", \"\\n \".join(group_set))","4317cfc6":"#default submission\ntest.loc[test.Sex == 'male', 'Survived'] = 0\ntest.loc[test.Sex == 'female', 'Survived'] = 1\nprint('Number of passengers that are predicted to live with gender submission:')\nprint(test.groupby(\"Title\").Survived.sum())\n\n#obtain set of groups from train set\ngroupIds = set(train['GroupId'].fillna('noGroup'))\nticketIds = set(train['TicketId'].fillna('noTicket'))\n\n#updating test set with survival rate\nfor index, row in test[test.Title != \"Mr\"].iterrows():\n    if row.GroupId in groupIds:\n        test.at[index,'Survived'] = int(train[train.GroupId == row.GroupId][\"SurvivalG\"].iloc[0]>=0.5)\n        #print('{} prediction by its GroupId: {}'.format(index, row.GroupId))\n    else:\n        if row.TicketId in ticketIds:\n            test.at[index,'Survived'] = int(train[train.TicketId == row.TicketId][\"SurvivalT\"].iloc[0]>=0.5)\n            #print('{} prediction by its ticket {}: {}'.format(index, row.TicketId, int(train[train.TicketId == row.TicketId][\"SurvivalT\"].iloc[0]>0.5)))\n        elif (row.GroupFreq > 1) & (row.Pclass == 3):\n            test.at[index,'Survived'] = 0\n            #print('{} dies because of its class. GroupId: {}'.format(index, row.GroupId))\n\ntest['Survived'] = (test['Survived'] > 0).astype('int')\nprint('\\nNumber of passengers that are predicted to live with new survival rates:')\nprint(test.groupby(\"Title\").Survived.sum())","faab2c85":"display('Boys that are predicted to live:')\ndisplay(test[(test.Sex =='male') & (test.Survived == 1)][['PassengerId', 'Name', 'Age', 'Ticket', 'GroupId']])\n\ndisplay('Female passengers that are predicted to die')\ndisplay(test[(test.Sex == 'female') & (test.Survived == 0)][['PassengerId', 'Name', 'Age', 'Ticket', 'GroupId']])","cefe3c66":"display(test[test.Surname == 'Khalil'])\ndisplay(train[train.Surname == 'Zabour'])\ndisplay(train[train.Surname == 'Elias'])\n#display(test[test.Surname == 'Elias'])","68d7e031":"display(test[test.Surname == 'Asplund'])\ndisplay(train[train.Surname == 'Asplund'])\ndisplay(test[test.Surname == 'Daniels'])\ndisplay(train[train.Ticket == '113781'])","d39f2c24":"# make predictions and save in an output\npredictions = test[['PassengerId', 'Survived']]\npredictions.to_csv('submission.csv', index=False)\nprint(\"Your submission was successfully saved!\")","d2909903":"### TicketId\nA possible way to find more people that belong to a same group, is looking at the \"Ticket\" feature: if a person has the same ticket of a group, then it is likely that they bought the ticket together and that they know each other. Observe that members of the same family can have different tickets (explaining why we use the \"TickeX\" feature). This was remarked in [Chris Deotte: Titanic Mega Model - [0.84210]](https:\/\/www.kaggle.com\/cdeotte\/titantic-mega-model-0-84210),  and in [Erik Bruin: Titanic: 2nd degree families and majority voting](https:\/\/www.kaggle.com\/erikbruin\/titanic-2nd-degree-families-and-majority-voting).\n\n#### Relation with other notebooks\nContrary to the cited notebooks, not only I'm updating the GroupId feature for passengers having the same ticket of an existent GroupId-family, but also considering TicketId for non-adult-male travellers. Apriori, there can be a group of friends that bought the ticket together but are not family-related (a posteriori it turns out not to be the case and the analysis is identical to the one of Chris and Erik).","ab3b533b":"Good news here :-) : 0.811 score\n\n![image](https:\/\/i.ibb.co\/ggYG1XK\/Screen-Shot-2020-09-02-at-12-05-20.png)","ffff9f5c":"# Titanic with families and friends\nThis notebook is a work-in-progress and it surfes on the same wave of WCG (woman-child group) notebooks, namely:\n- 2018 notebooks by Chris Deotte: [Titanic Mega Model - [0.84210]](https:\/\/www.kaggle.com\/cdeotte\/titantic-mega-model-0-84210) and [Titanic using Name only [0.81818]](https:\/\/www.kaggle.com\/cdeotte\/titanic-using-name-only-0-81818)\n- 2018 notebook by Erik Bruin: [Titanic: 2nd degree families and majority voting](https:\/\/www.kaggle.com\/erikbruin\/titanic-2nd-degree-families-and-majority-voting)\n\nIn this current version, no machine learning algorithms are used. The survival feature is predicted using only three simple rules:\n> rule (A) all male passengers die except boys whose family members\/friends survive\n>\n> rule (B) all female passengers live except those whose family members\/friends do not survive\n>\n> rule (C) a family in class 3 dies if no information is present in the train set\n    \nFor \"family\" and \"friends\", I mean group of people with the same surname+ticket (family) or same ticket (friends). More details in the ## Feature Engineering subsection.\n\nThis is my first notebook on Kaggle and also my first deep dive into coding after a few years. I've tried to write a code as clean-simple-smart as possible and you are very welcome to comment on mistakes or possible improvements. Have a nice reading!\n\n## Aim of this notebook\nAfter trying a few machine learning models (and feature combinations), and always scoring less than 0.80% with a cross validation score of 0.84%, I've decided to stop trying random combinations and to start looking at what other people were doing\/did. The top scores are probably given by:\n- 2018 notebook [Titanic Mega Model - [0.84210]](https:\/\/www.kaggle.com\/cdeotte\/titantic-mega-model-0-84210) (see also the references therein)\n- 2019 notebook by Chris Deotte: [Titanic WCG+XGBoost [0.84688]](https:\/\/www.kaggle.com\/cdeotte\/titanic-wcg-xgboost-0-84688)\n- 2020 notebook by Gunes Evitan: [Titanic - Advanced Feature Engineering Tutorial](https:\/\/www.kaggle.com\/gunesevitan\/titanic-advanced-feature-engineering-tutorial)\n- 2020 notebook by Massimiliano Viola: [Titanic WCG + KNNs Ensemble [0.82775] (top 1%)](https:\/\/www.kaggle.com\/mviola\/titanic-wcg-knns-ensemble-0-82775-top-1)\n\nIn many of the previous cases, some information is extracted from the test set before engineering features in the train set: it's ok, their goal is to be the best notebooks and they want to **overfit the test set**!\n\nI would like to perform a **clean work on the train set**, without (formally) using any apriori information from the test set: this notebook is an attempt to do so. I'm going to closely follow the analysis in Chris Deotte's notebooks and putting in practice (in Python!) his same ideas but in a different fashion. Moreover, I try to understand why some passengers were predicted to live or to die in other notebooks (e.g., Asplund, Khalil, Daniels) but not in this one, although the guide ideas are the same.\n\n#### On the top scores\nPlease observe that, as remarked by Massimo Viola in the discussion [Titanic Old vs New LB comparison and Top Scores!\n](https:\/\/www.kaggle.com\/c\/titanic\/discussion\/179147), the new public leaderboard has shifted scores and old notebooks score less than in the past (around -0.02 +- 0.01%).","3bf1413e":"### Predicting\nFrom the train set, we obtain a list of GroupId and TicketId. We check whether the GroupId\/TicketId in the test set match one the values in the train set: in case it does, we predict the Survived feature either with SurvivalG or with SurvivalT.\n\nPS the following, is the only *for* in the notebook :-)","de76880e":"#### Probability shades: Asplund and Daniels\nAsplund boys are here predicted to live since their survival rate is high as 0.75. Daniels is predicting to die since her survival rate is 0.5O. Other notebooks seem to take a different point of view.","e9c9137a":"## Work in progress\nAs said in the introduction, this notebook is a work in progress. In particular, the following points will be probably addressed in the near feature:\n - adult-male passenger who survive with cabin information;\n - machine learning algorithms for male and female passengers with no group identification;\n - cross validation.","eecd00f6":"### EDA: Exploratory Data Analysis\nThere are many great notebooks on EDA for the titanic competition and they all show - more or less - the same concept: women, children and first class were prioritized in the rescue (as in the movie ;-)). I'm completely skipping this part and refer to the references in the introduction.\n\nOne thing that I've not found in other notebooks, is that there is a homonym ! *This is the only apriori information that I'm \"using\" ;-).*","912c699c":"## Preparing for Submission\nI'm preparing the test set features and later predict the missing values.\n\n\n### Feature engineering\nThis part does not use any information from the train set, it only consists in feature engineering: creating GroupId, GroupFreq, TicketId.","c986d6c1":"### GroupId feature\nThe feature \"GroupId\" is composed of Surname + Class + TickeX (the ticket where the last two digits are replaced by \"XX\"). This feature is set to NaN for all \"Mr\" and for adult (i.e., Age > 14) female solo-travelers (i.e., whenever it represents an unique value in the column). Observe that I'm not imputing the age feature so that I'm considering adult any Miss with NaN Age.\n\n\n#### Relation with known notebooks\nI'm mostly following [Chris Deotte: Titanic Mega Model - [0.84210]](https:\/\/www.kaggle.com\/cdeotte\/titantic-mega-model-0-84210) and [Chris Deotte: Titanic using Name only [0.81818]](https:\/\/www.kaggle.com\/cdeotte\/titanic-using-name-only-0-81818). But some inspiration comes also from other notebooks on \"families\", as: [Erik Bruin: Titanic: 2nd degree families and majority voting](https:\/\/www.kaggle.com\/erikbruin\/titanic-2nd-degree-families-and-majority-voting). In particular:\n\n* I'm adding a non-null \"GroupId\" feature for \"Master\" and young \"Miss\" (Age <= 14) travelling alone: it is unlikely that a child is travelling alone, their parents are probably in the unseen data, as for Master Dodge (Id 445). This is not done in [Chris Deotte: Titanic using Name only [0.81818]](https:\/\/www.kaggle.com\/cdeotte\/titanic-using-name-only-0-81818) although he recovers this information by working on the train and test set simultaneously.\n* The GroupId feature is not purely related to families but also to women who bought the same ticket, as in [Chris Deotte: Titanic Mega Model - [0.84210]](https:\/\/www.kaggle.com\/cdeotte\/titantic-mega-model-0-84210) and [Erik Bruin: Titanic: 2nd degree families and majority voting](https:\/\/www.kaggle.com\/erikbruin\/titanic-2nd-degree-families-and-majority-voting). In other words, a passenger has a non-null GroupId if \n    - their title is Mrs, Miss or Master\n    - they are travelling with a family (non-unique surname-class-ticket) or related to an existing family by having the same ticket.\n\n#### Additional (commented) code is available for adding extra futures as:\n- Maiden names and family size\n- Cabin postion (taking values in A, B, ..., G) (later work on this feature)\n","c11dcee4":"## Feature engineering: survival rates\nFrom GroupId and TicketId, we can now compute the average survivale rate for each group (recall that no man except boys belong to groups!). The respective features are called:\n- SurvivalG: the survival rate by grouping on the  GroupId feature\n- SurvivalT: the survival rate by grouping on the TicketId feature","99076b70":"## Predictions\nFinal steps...","5774062e":"## Preparing the court\n### Setting the playground\nWe start by loading the modules used throughout the notebook and the dataframes.","00d31f2b":"## Feature engineering: groups\nIn this section we engineer two features called \"GroupId\" and \"TicketId\" respectively. The value of the first one consists in a string formatted as \"Surname Pclass Ticket\", while the second one is just a copy of the Ticket feature but ignoring male passengers. We aim at grouping families and friends(<- people with the same ticket). The main scope of this notebook is to identify groups of people who stayed together and, depeding on the average survival rate per group, predicting the \"Survived\" label in the test set.\n\nWomen and children were prioritized in the rescue, so that we are not going to assign a GroupId or a TicketId to male passengers, unless they are children (this information can be extracted from the \"Title\" Master in the name). Indeed, **we are ignoring all information coming from adult male passengers** and predicting that they all die.\n\nPlease observe that I'm rather interested in **understanding whether a female passenger does not survive** (e.g., when her family\/female friends do not survive). From the later analysis on the train set, one can see that the number of Mr who survived is less than the number of Mrs\/Miss\/Master who died, not only in percentage (0.16% < 0.28%) but also in absolute value ( 88 < 98).\n\nLet's analyse the two features more closely.","a89fce17":"### Differences with other WCG notebooks\nIf one compares the previous lists with the ones in [Titanic Mega Model - [0.84210]](https:\/\/www.kaggle.com\/cdeotte\/titantic-mega-model-0-84210) or in [Titanic WCG + KNNs Ensemble [0.82775] (top 1%)](https:\/\/www.kaggle.com\/mviola\/titanic-wcg-knns-ensemble-0-82775-top-1), they will find some differences (remember that we are using the same receipt). The aim of this subsection is to bring some light on these discrepancies.\n\n#### Family relation: Khalil, Zabour and Betros\nKhalil and Zabour families are not likely to be related (they just paid the same Fare but have different Ticket) but using this information Khalil family is predicted to die. For me, it is more probable that Khalil is related to Elias family which is her Maiden name (which still predicts the family to die). Indeed:"}}