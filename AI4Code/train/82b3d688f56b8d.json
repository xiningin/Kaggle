{"cell_type":{"ff7fa20c":"code","bdcb35df":"code","5ddae32c":"code","563576fe":"code","c95f7576":"code","bab57a0a":"code","94f25e5c":"code","e52d810c":"code","90fea0bd":"code","8d4818db":"code","30337ee1":"code","6235b1d3":"code","d7fdb969":"code","9c79100d":"code","c97e6098":"code","92e61010":"code","685adf04":"code","154219bc":"code","be6ec1c6":"code","0fec2626":"markdown"},"source":{"ff7fa20c":"import pandas as pd\nimport random\nfrom time import time","bdcb35df":"random.seed(42)","5ddae32c":"N_MINUTES = 10\n# log_search = True\nverbose = 1","563576fe":"distance_matrix = pd.read_csv('\/kaggle\/input\/santa-2021\/distance_matrix.csv', index_col='Permutation')\npermutations = pd.read_csv('\/kaggle\/input\/santa-2021\/permutations.csv')","c95f7576":"s1_options = []\ns2_options = []\ns3_options = []\nall_options = []\nfor permutation in permutations['Permutation']:\n    if permutation.startswith('\ud83c\udf85\ud83e\udd36'):\n        s1_options.append(permutation)\n        s2_options.append(permutation)\n        s3_options.append(permutation)\n    else:\n        all_options.append(permutation)","bab57a0a":"class String:\n    def __init__(self, s, cost):\n        self.s = s\n        self.cost = cost","94f25e5c":"s1 = s1_options.copy()\ns2 = s2_options.copy()\ns3 = s3_options.copy()\n\nfor option in all_options:\n    index = random.randint(0, 2)\n    if index == 0:\n        s1.append(option)\n    elif index == 1:\n        s2.append(option)\n    else:\n        s3.append(option)","e52d810c":"def calculate_cost(s):\n    cost = sum([distance_matrix.loc[s[i], s[i+1]] for i in range(len(s)-1)])\n    cost += 14\n    cost -= distance_matrix.loc[s[0], s[1]]\n    cost -= distance_matrix.loc[s[-2], s[-1]]\n    \n    return cost","90fea0bd":"cost1 = calculate_cost(s1)\ncost2 = calculate_cost(s2)\ncost3 = calculate_cost(s3)","8d4818db":"strings = [\n    String(s1, cost1),\n    String(s2, cost2),\n    String(s3, cost3),\n]","30337ee1":"def swap_in_string(string):\n    attempts = 0\n    while attempts < 5:\n        two_indices = random.randint(0, len(string.s)-1), random.randint(0, len(string.s)-1)\n\n        new_cost = string.cost\n\n        if two_indices[0] != 0:\n            new_cost -= distance_matrix.loc[string.s[two_indices[0]-1], string.s[two_indices[0]]]\n        if two_indices[0] != len(string.s)-1:\n            new_cost -= distance_matrix.loc[string.s[two_indices[0]], string.s[two_indices[0]+1]]\n\n        if two_indices[1] != 0:\n            new_cost -= distance_matrix.loc[string.s[two_indices[1]-1], string.s[two_indices[1]]]\n        if two_indices[1] != len(string.s)-1:\n            new_cost -= distance_matrix.loc[string.s[two_indices[1]], string.s[two_indices[1]+1]]\n            \n        string.s[two_indices[0]], string.s[two_indices[1]] = string.s[two_indices[1]], string.s[two_indices[0]]\n            \n        if two_indices[0] != 0:\n            new_cost += distance_matrix.loc[string.s[two_indices[0]-1], string.s[two_indices[0]]]\n        if two_indices[0] != len(string.s)-1:\n            new_cost += distance_matrix.loc[string.s[two_indices[0]], string.s[two_indices[0]+1]]\n\n        if two_indices[1] != 0:\n            new_cost += distance_matrix.loc[string.s[two_indices[1]-1], string.s[two_indices[1]]]\n        if two_indices[1] != len(string.s)-1:\n            new_cost += distance_matrix.loc[string.s[two_indices[1]], string.s[two_indices[1]+1]]\n        \n        if new_cost >= string.cost:\n            string.s[two_indices[0]], string.s[two_indices[1]] = string.s[two_indices[1]], string.s[two_indices[0]]\n        if new_cost < string.cost:\n            string.cost = new_cost\n            return string, True\n        \n        attempts += 1\n        \n    return string, False","6235b1d3":"def swap_bw_strings(string1, string2):\n    attempts = 0\n    while attempts < 10:\n        two_indices = random.randint(0, len(string1.s)-1), random.randint(0, len(string2.s)-1)\n        \n        if string1.s[two_indices[0]] not in all_options or string2.s[two_indices[1]] not in all_options:\n            continue\n\n        new_cost_1 = string1.cost\n        new_cost_2 = string2.cost\n\n        if two_indices[0] != 0:\n            new_cost_1 -= distance_matrix.loc[string1.s[two_indices[0]-1], string1.s[two_indices[0]]]\n        if two_indices[0] != len(string1.s)-1:\n            new_cost_1 -= distance_matrix.loc[string1.s[two_indices[0]], string1.s[two_indices[0]+1]]\n        if two_indices[0] != 0:\n            new_cost_1 += distance_matrix.loc[string1.s[two_indices[0]-1], string2.s[two_indices[1]]]\n        if two_indices[0] != len(string1.s)-1:\n            new_cost_1 += distance_matrix.loc[string2.s[two_indices[1]], string1.s[two_indices[0]+1]]\n\n        if two_indices[1] != 0:\n            new_cost_2 -= distance_matrix.loc[string2.s[two_indices[1]-1], string2.s[two_indices[1]]]\n        if two_indices[1] != len(string2.s)-1:\n            new_cost_2 -= distance_matrix.loc[string2.s[two_indices[1]], string2.s[two_indices[1]+1]]\n        if two_indices[1] != 0:\n            new_cost_2 += distance_matrix.loc[string2.s[two_indices[1]-1], string1.s[two_indices[0]]]\n        if two_indices[1] != len(string2.s)-1:\n            new_cost_2 += distance_matrix.loc[string1.s[two_indices[0]], string2.s[two_indices[1]+1]]\n\n        if sum((new_cost_1, new_cost_2)) < sum((string1.cost, string2.cost)):\n            string1.s[two_indices[0]], string2.s[two_indices[1]] = string2.s[two_indices[1]], string1.s[two_indices[0]]\n            string1.cost = new_cost_1\n            string2.cost = new_cost_2\n            return string1, string2, True\n        \n        attempts += 1\n        \n    return string1, string2, False","d7fdb969":"def transfer_bw_strings(string1, string2):\n    attempts = 0\n    while attempts < 10:\n        two_indices = random.randint(0, len(string1.s)-1), random.randint(0, len(string2.s)-1)\n        \n        if string1.s[two_indices[0]] not in all_options:\n            continue\n\n        new_cost_1 = string1.cost\n        new_cost_2 = string2.cost\n\n        if two_indices[0] != 0:\n            new_cost_1 -= distance_matrix.loc[string1.s[two_indices[0]-1], string1.s[two_indices[0]]]\n        if two_indices[0] != len(string1.s)-1:\n            new_cost_1 -= distance_matrix.loc[string1.s[two_indices[0]], string1.s[two_indices[0]+1]]\n        if two_indices[0] != 0 and two_indices[0] != len(string1.s)-1:\n            new_cost_1 += distance_matrix.loc[string1.s[two_indices[0]-1], string1.s[two_indices[0]+1]]\n\n        if two_indices[1] != 0:\n            new_cost_2 -= distance_matrix.loc[string2.s[two_indices[1]-1], string2.s[two_indices[1]]]\n        if two_indices[1] != 0:\n            new_cost_2 += distance_matrix.loc[string2.s[two_indices[1]-1], string1.s[two_indices[0]]]\n        new_cost_2 += distance_matrix.loc[string1.s[two_indices[0]], string2.s[two_indices[1]]]\n\n        if sum((new_cost_1, new_cost_2)) < sum((string1.cost, string2.cost)):\n            string2.s.insert(two_indices[1], string1.s[two_indices[0]])\n            string1.s.pop(two_indices[0])\n            string1.cost = new_cost_1\n            string2.cost = new_cost_2\n            return string1, string2, True\n        \n        attempts += 1\n        \n    return string1, string2, False","9c79100d":"start = time()\n\nif verbose != 0:\n    print('Starting Search')\n    print(f'Initial Cost: s1={strings[0].cost}, s2={strings[1].cost}, s3={strings[2].cost}, total={max(strings[0].cost, strings[1].cost, strings[2].cost)}')\nloop_count = 0\nwhile time()-start <= N_MINUTES*60:\n    loop_count += 1\n    option = random.randint(0, 2)\n    if option == 0:\n        index = random.randint(0, 2)\n        strings[index], updated = swap_in_string(strings[index])\n    elif option == 1:\n        index1, index2 = random.sample([0, 1, 2], k=2)\n        strings[index1], strings[index2], updated = swap_bw_strings(strings[index1], strings[index2])\n    elif option == 2:\n        index1, index2 = random.sample([0, 1, 2], k=2)\n        strings[index1], strings[index2], updated = transfer_bw_strings(strings[index1], strings[index2])\n                \n    if not updated:\n        continue\n    if verbose == 1 and loop_count % 20 == 0:\n        print(f'Cost: s1={strings[0].cost}, s2={strings[1].cost}, s3={strings[2].cost}, total={max(strings[0].cost, strings[1].cost, strings[2].cost)}')\n    elif verbose == 2:\n        print(f'Cost: s1={strings[0].cost}, s2={strings[1].cost}, s3={strings[2].cost}, total={max(strings[0].cost, strings[1].cost, strings[2].cost)}')","c97e6098":"def create_result(s):\n    result = s[0]\n    for permutation in s[1:]:\n        joined = False\n        for index in range(1, len(permutation)+1):\n            if permutation[:index] == result[-index:]:\n                assert len(permutation[index:]) == distance_matrix.loc[result[-7:], permutation], f'{result}\\n{permutation}'\n                result += permutation[index:]\n                joined = True\n                break\n        if not joined:\n            result += permutation\n        \n    return result","92e61010":"result1 = create_result(s1)\nresult2 = create_result(s2)\nresult3 = create_result(s3)","685adf04":"submission = pd.Series(\n    [result1,\n     result2,\n     result3],\n    name='schedule'\n)\n\nsubmission","154219bc":"# Evaluating score\n\nmax(map(len, submission.to_list()))","be6ec1c6":"submission.to_csv('submission.csv', index=False)","0fec2626":"# Local Search"}}