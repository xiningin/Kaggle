{"cell_type":{"d3147ea4":"code","1184f8ac":"code","1a4d6b0a":"code","40cbc9b7":"code","fa5035fe":"code","0bc2fef7":"code","9135e497":"code","5a214d63":"markdown","62462f4a":"markdown","fb21872b":"markdown","4cb6046c":"markdown","d834a90c":"markdown","6f085949":"markdown","f73b2780":"markdown","aa5a8493":"markdown"},"source":{"d3147ea4":"import IPython\nIPython.display.Video('dbscan-example-blobs.mp4',embed=True,html_attributes=\"loop autoplay controls style='width: 100%'\")","1184f8ac":"import random\nimport math\nimport numpy as np\nimport pandas as pd\nimport scipy\nimport time     \n        \ndef fit_dbscan_iterable( X, minPts=3, radius=1, verbose=True, anim=True, animFrames=100, animFramesAfter=40, animFramesBefore=10  ):\n    \"\"\"Find clusters using dbscan algorithm\n    \n    Parameters\n    ----------\n    X : list of points\n        array of points to find the clusters in (accept: list, numpy or pandas)\n    minPts : int (default=3)\n        minimum points to be considered a core \n    radius : float (default=1)\n        radius to find neighbors\n    verbose : bool (default=True)\n        print some messages during processing\n    anim : bool (default=True)\n        return intermediary frames to make a animation\n        \n    Returns\n    -------\n    generator object -> (y, cores, cursor)\n        returns a generator object (iterable) that will\n        return a tuple of (y, cores and cursor) for\n        each frame   \n        \n    \"\"\"\n    \n    # padroniza\u00e7\u00e3o dos dados de entrada\n    radius = float(radius)\n    \n    if isinstance( X, pd.DataFrame ):\n        X = X.to_numpy()    \n    \n    # Esta fun\u00e7\u00e3o localiza os vizinhos do ponto X1\n    def locate_neigbors( x1 ):\n        nonlocal X, radius\n        result = []\n        \n        for x2i, x2 in enumerate( X ):\n            d = scipy.spatial.distance.euclidean( x1, x2 )\n            if d < radius:\n                result.append( [ x2i, x2 ] )\n                \n        return result; \n    \n    # calcula o interval entre frames para que a anima\u00e7\u00e3o tenha ~ 100 frames\n    animEach = len(X)\/animFrames\n    animFrame = 0;\n    \n    # dados gerais\n    cluster_id = 0    \n    y = [ 0 for _ in X ]\n    cores = [ 0 for _ in X ]    \n        \n    # se for necess\u00e1rio processar em ordem aleat\u00f3ria: \n    #    random.sample(list(enumerate(X)),len(X))\n    \n    # em modo de anima\u00e7\u00e3o, repete a \u00faltima imagem algumas vezes para dar um delay antes de repetir a anima\u00e7\u00e3o\n    if anim:      \n        for i in range(animFramesBefore):                                                                                                      \n            yield (y, cores, None)    \n    \n    # visita todos os pontos do conjunto\n    for x1i, x1 in enumerate(X):      \n        \n        # se o ponto xli ainda n\u00e3o foi processado        \n        if y[ x1i ] == 0:                            \n            \n            # localiza todos os vizinhos\n            N = locate_neigbors( x1 )        \n            \n            # se o ponto tem acima de {minPts} vizinhos\n            if len(N) >= minPts:             \n                \n                # cria um novo cluster_id\n                cluster_id = cluster_id + 1          \n                \n                # visita todos os vizinhos                    \n                visited = []                                         \n                while len(N) > 0:            \n                    (x2i, x2) = N.pop()      \n                    \n                    # evita tratamento duplicado do mesmo ponto\n                    if x2i in visited: continue      \n                    visited.append(x2i)              \n\n                    # retorna uma frame intermedi\u00e1ria para anima\u00e7\u00e3o\n                    animFrame = animFrame + 1        \n                    if ( animFrame % animEach ) == 0:                        \n                        if anim: yield (y, cores, x2) \n                    \n                    # vizinho n\u00e3o \u00e9 um core (portanto pode ser sobrescito)\n                    if cores[ x2i ] == 0:            \n                        \n                        # absorve vizinho ao cluster\n                        y[ x2i ] = cluster_id        \n                        \n                        # localiza vizinhos2 do vizinhos\n                        N2 = locate_neigbors( x2 )   \n                        \n                        # vizinho \u00e9 um core\n                        if( len(N2) >= minPts ):     \n                            cores[ x2i ] = 1\n\n                            # adiciona vizinhos na lista de vizinhos a visitar\n                            for x3i, x3 in N2:       \n                            \n                                if y[ x3i ] != cluster_id and cores[ x3i ] == 0:\n                                \n                                    N.insert( 0, [ x3i, x3 ] )                                   \n    \n    # em modo de anima\u00e7\u00e3o, repete a \u00faltima imagem algumas vezes para dar um delay antes de repetir a anima\u00e7\u00e3o\n    if anim:      \n        for i in range(animFramesAfter):                                                                                                      \n            yield (y, cores, None)                                                                       \n                                    \n    # finalizado, retorna \u00faltima frame                                    \n    yield (y, cores, None)                           \n        \n        \ndef fit_dbscan(X, minPts=3, radius=1, verbose=True, anim=False):\n    \"\"\"Find clusters using dbscan algorithm\n    \n    Parameters\n    ----------\n    X : list of points\n        array of points to find the clusters in (accept: list, numpy or pandas)        \n    minPts : int (default=3)\n        minimum points to be considered a core \n    radius : float (default=1)\n        radius to find neighbors\n    verbose : bool (default=True)\n        print some messages during processing\n    anim : bool (default=True)\n        return intermediary frames to make a animation\n        \n    Returns\n    -------\n    if anim=False:\n        tuple (y, cores, cursor):\n            y: list of scalars\n                the clusterids which each point belongs to\n            cores: list of scalars\n                1 if the corresponding X is a core\n            cursor: tensor (point)\n                None in the last frame\n    if anim=True:\n        list of tuples (y, cores, cursor)\n        \n    \"\"\"\n    \n    if anim:\n        return list( fit_dbscan_iterable(X, minPts, radius, verbose, anim=True ) )\n    else:\n        return next( fit_dbscan_iterable(X, minPts, radius, verbose, anim=False ) )\n    \n    ","1a4d6b0a":"help(fit_dbscan)","40cbc9b7":"def bloco():\n    \n    %matplotlib inline\n    from sklearn import datasets;\n    import matplotlib.pyplot as plt\n    from matplotlib.animation import FuncAnimation\n    import IPython\n    \n    random.seed(13)\n    \n    X, yTrue = datasets.make_blobs(\n        n_samples=1000,\n        centers=[ [random.uniform(0,32), random.uniform(0,15) ] for i in range(7)], \n        n_features=2,\n        random_state=5        \n    )        \n\n    fig = plt.figure(\n        figsize=(12,5),\n        dpi=100,\n        frameon=False\n    ) \n\n    hsv = plt.cm.get_cmap('hsv', 10)\n\n    def anim_init():\n        print('init')\n        #ax.yaxis.get_major_locator().set_params(integer=True)    \n\n    def anim_update( data ):     \n        y, cores, cursor = data \n        print(cursor, end=';')\n\n        #fig.patch.set_visible(False)        \n        \n        plt.clf()\n        plt.title( f\"Teste do DBScan com makeblobs (valida\u00e7\u00e3o da rotina desenvolvida)\")      \n        #plt.xticks(())\n        #plt.yticks(())\n        #plt.box(False)\n\n        ax = fig.subplots()\n        ax.set_axis_off()\n        plt.subplots_adjust(left=-0.001, right=1.001, top=1.005, bottom=-0.005)\n        fig.patch.set_visible(False)\n        ax.patch.set_visible(False)\n        #ax.get_xaxis().set_ticks([])\n        #ax.get_yaxis().set_ticks([])\n        #ax.set_xlabel('random y (makeblobs)')\n        #ax.set_ylabel('random y (makeblobs)')\n\n        res = []\n\n        ax.scatter(        \n            [ X[j][0] for j in range(len(X)) if y[j]==0 ],\n            [ X[j][1] for j in range(len(X)) if y[j]==0 ],        \n            color='#c0c0c0',\n            label='Outlier',\n            marker='o',\n            s=16\n        )\n\n        for i in range(1,10):\n            ax.scatter(        \n                [ X[j][0] for j in range(len(X)) if y[j]==i and cores[j]==0 ],\n                [ X[j][1] for j in range(len(X)) if y[j]==i and cores[j]==0 ],        \n                color=hsv(i),\n                marker='o',\n                s=4\n            )\n            ax.scatter(        \n                [ X[j][0] for j in range(len(X)) if y[j]==i and cores[j]==1 ],\n                [ X[j][1] for j in range(len(X)) if y[j]==i and cores[j]==1 ],        \n                color=hsv(i),\n                label=f'Cluster {i}',\n                marker='o',\n                s=32\n            )\n\n        if not( cursor is None ):\n            ax.scatter(        \n                [ cursor[0] ],\n                [ cursor[1] ],        \n                color='#000000',\n                label='Cursor',\n                marker='o',\n                s=128\n            )    \n\n        ax.legend()\n\n    anim = FuncAnimation(\n        fig=fig,\n        func=anim_update,\n        frames=fit_dbscan_iterable(X,animFrames=100,animFramesAfter=30,animFramesBefore=10),\n        save_count=140,\n        interval=200,\n        blit=False\n    )\n    video = anim.save('dbscan-example-blobs.mp4')\n    #video = anim.to_html5_video()\n    #html = IPython.display.HTML(video)\n    IPython.display.clear_output(wait=True)       \n    #IPython.display.display(html)\n\n    plt.close() \n    \n    IPython.display.clear_output(wait=True)       \n    \nbloco()","fa5035fe":"def bloco():\n    \n    global df\n    \n    from datetime import datetime\n    import pandas as pd\n    import os\n    pd.options.display.max_columns = None\n        \n    if os.path.isfile('\/kaggle\/input\/us-counties-covid-19-dataset\/us-counties.csv'):\n        file = '\/kaggle\/input\/us-counties-covid-19-dataset\/us-counties.csv'\n    elif os.path.isfile( 'data\/us-counties-covid-19-dataset.csv' ):\n        file = 'data\/us-counties-covid-19-dataset.csv'\n    else:\n        raise Exception('Por favor, inclua o arquivo de dados em data\/us-counties-covid-19-dataset.csv')\n        \n    df = pd.read_csv( file,\n             #nrows=1000 \n        )\n\n    df.insert( 1, \"wday\", df['date'].apply( lambda x: int(datetime.strptime(x,'%Y-%m-%d').strftime('%w')) ) )\n    df.insert( 1, \"mday\", df['date'].apply( lambda x: int(datetime.strptime(x,'%Y-%m-%d').strftime('%d')) ) )\n    #df.insert( 1, \"month\", df['date'].apply( lambda x: int(datetime.strptime(x,'%Y-%m-%d').strftime('%m')) ) )\n\n    df = df.dropna()\n    df = df.sample( 1500 )\n    \n    #df['wday'] = (df['wday'] - df['wday'].mean())\/df['wday'].std()\n    #df['cases'] = (df['cases'] - df['cases'].mean())\/df['cases'].std()\n    #df['deaths'] = (df['deaths'] - df['deaths'].mean())\/df['deaths'].std()\n    \n    return df\n    \nbloco()","0bc2fef7":"def bloco():\n    \n    %matplotlib inline\n    from sklearn import datasets;\n    import matplotlib.pyplot as plt\n    from matplotlib.animation import FuncAnimation\n    import IPython\n    \n    X = df[ [ 'cases','deaths' ] ].to_numpy()    \n    y, cores, cursor = fit_dbscan(X,radius=20,minPts=5,anim=False)\n    \n    fig = plt.figure(figsize=(12,5),dpi=300)\n\n    hsv = plt.cm.get_cmap('hsv', 10)\n\n    plt.clf()\n    plt.title( f\"Covid-19 casos x mortes\")      \n    plt.xticks(())\n    plt.yticks(())\n\n    ax = fig.subplots()\n    ax.yaxis.get_major_locator().set_params(integer=True)    \n    ax.set_xlabel('casos (log)')\n    ax.set_ylabel('mortes (log)')\n\n    plt.subplots_adjust(left=0.05, right=0.95, top=0.9, bottom=0.1)\n    fig.patch.set_visible(False)\n    ax.patch.set_visible(False)\n\n    #plt.xlim(-0.5,5)\n    #plt.ylim(-0.5,5)\n    plt.yscale('log')\n    plt.xscale('log')        \n    res = []\n\n    ax.scatter(        \n        [ X[j][0] for j in range(len(X)) if y[j]==0 ],\n        [ X[j][1] for j in range(len(X)) if y[j]==0 ],        \n        color='#c0c0c0',\n        label='Outlier',\n        marker='o',\n        s=16\n    )\n\n    for i in range(1,10):\n        ax.scatter(        \n            [ X[j][0] for j in range(len(X)) if y[j]==i and cores[j]==0 ],\n            [ X[j][1] for j in range(len(X)) if y[j]==i and cores[j]==0 ],        \n            color=hsv(i),\n            marker='o',\n            s=4\n        )\n        ax.scatter(        \n            [ X[j][0] for j in range(len(X)) if y[j]==i and cores[j]==1 ],\n            [ X[j][1] for j in range(len(X)) if y[j]==i and cores[j]==1 ],        \n            color=hsv(i),\n            label=f'Cluster {i}',\n            marker='o',\n            s=32\n        )\n\n    if not( cursor is None ):\n        ax.scatter(        \n            [ cursor[0] ],\n            [ cursor[1] ],        \n            color='#000000',\n            label='Cursor',\n            marker='o',\n            s=128\n        )    \n\n    ax.legend()\n\n    plt.show()\n    \nbloco()","9135e497":"import os\nos.remove(\"dbscan-example-blobs.mp4\")","5a214d63":"# O Algoritmo DBScan","62462f4a":"## 1. Introdu\u00e7\u00e3o\n\n\u00c9 meio evidente que existem 4 grupos distintos na figura acima e o algoritmo DBScan \u00e9 uma das muitas formas de tentar dotar as m\u00e1quinas desse n\u00edvel de percep\u00e7\u00e3o e neste notebook vamos explicar como ele funciona. \n\nO diferencial de ensinar a m\u00e1quina a fazer este tipo de associa\u00e7\u00e3o \u00e9 que a mesma t\u00e9cnica pode ser aplicada em conjuntos de dados com milh\u00f5es de registros e\/ou com milhares de v\u00e1riaveis, algo que n\u00f3s - seres humanos - n\u00e3o conseguimos fazer em tempo h\u00e1bil. \n\n### 1.1. Funcionamento do Algoritmo\n\nA figura abaixo demonstra como o DBScan alcan\u00e7a este resultado.\n\n![dbscan-explanation-01.png](attachment:c6bb9584-742c-4f56-9b47-b55f6f703dde.png)\n\nEm resumo o algoritmo encontra pontos n\u00e3o processados, verifica se a densidade \u00e9 suficiente, se for o caso navega para os vizinhos dentro do circulo fazendo o mesmo c\u00e1lculo at\u00e9 que n\u00e3o sejam encontrados mais vizinhos. \n\n### 1.2. Outras implementa\u00e7\u00f5es e refer\u00eancias\n\nEste notebook cont\u00e9m uma implementa\u00e7\u00e3o desse algoritmo para fins did\u00e1ticos. Para uso em produ\u00e7\u00e3o, sugerimos usar uma implementa\u00e7\u00e3o mais madura como o [sklearn.cluster.DBSCAN][1]. O artigo [Wikipedia DBSCAN article][2] tem uma boa explica\u00e7\u00e3o do algoritmo DBSCAN, bem como varia\u00e7\u00f5es e refer\u00eancias para maiores detalhes. \n\n  [1]: https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.cluster.DBSCAN.html\n  [2]: https:\/\/en.wikipedia.org\/wiki\/DBSCAN\n","fb21872b":"### 2.2. Considera\u00e7\u00f5es sobre a performance\n\n![quadtree-explicacao.png](attachment:312f2401-9f50-4214-ad78-d155ec731853.png)\n\nNossa implementa\u00e7\u00e3o \u00e9 lenta pois foi constru\u00edda para ser did\u00e1tica, mas existem formas de implementa-la com uma velocidade maior. Entre outras coisas, \u00e9 poss\u00edvel implementar um [QuadTree][1] para acelerar a consulta aos n\u00f3s vizinhos. Da forma que o algoritmo foi constru\u00eddo, cada consulta aos n\u00f3s vizinhos precisar\u00e1 computar a dist\u00e2ncia do ponto x1 para cada outro ponto do conjunto e o algoritmo ter\u00e1 uma performance similar a $O(n^2)$. Um QuadTree exigira $O(log_{4} n}$ opera\u00e7\u00f5es para ser montado e $O(log_{4} n)$ opera\u00e7\u00f5es para cada consulta. Desta forma o algoritmo passaria a ter uma performance similar a $O(n \\times log_{4} n)$. A figura acima permite entender o porque: Neste exemplo, em uma pesquisa sequencial s\u00e3o 64 c\u00e9lulas, em uma pesquisa por \u00e1rvore s\u00e3o 4 n\u00edveis. Para 1 milh\u00e3o de registros seriam 20 n\u00edveis e isto d\u00e1 uma ideia da acelera\u00e7\u00e3o que um indexador como este pode oferecer.\n  \n[1]: https:\/\/en.wikipedia.org\/wiki\/Quadtree","4cb6046c":"## 4. Exemplo COVID19\n\nNo exemplo abaixo, procuramos agrupamentos entre casos e mortes.\n\nA anima\u00e7\u00e3o abaixo ilustra como os pontos v\u00e3o se reposicionando. Em cada itera\u00e7\u00e3o o modelo encontra os pontos mais pr\u00f3ximos do centroide e reposiciona o centroide no centro dos pontos selecionados. Isto faz o modelo espalhar os pontos.\n","d834a90c":"## 2. Funcionamento do Algoritmo\n\nEm resumo, o algoritmo funciona da seguinte forma:\n\n    Par\u00e2metros:\n       X - conjunto de pontos para c\u00e1lculo dos agrupamentos\n       minPts - n\u00famero m\u00ednimo de pontos dentro do circulo       \n       radius - raio do ciculo\n    Resultados:\n       Y     - lista de cluster_id gerados pelo modelo \n               (0=outlier)\n       cores - lista de indicadores de core\/borda gerados pelo modelo \n               (0=outlier\/borda; 1=core)\n              \n    cluster_id = 0\n        \n    LOOP1: Para cada ponto \"x1\" no conjunto \"X\":\n     |\n     |  SE x1 j\u00e1 foi tratado, ignora o resto deste bloco e \n     |    passa ao tratamento do proximo elemento do LOOP1\n     |\n     |  N1 = lista de pontos em \"X\" com dist\u00e2ncia para \"x1\" menor que \"radius\"\n     |\n     |  SE N1 cont\u00e9m mais de \"minPts\" pontos:\n     |   |\n     |   |  incrementa \"cluster_id\"\n     |   |\n     |   |  marca \"x1\" como \"core\" do cluster \"cluster_id\"\n     |   |\n     |   |  LOOP2: Para cada ponto \"x2\" no conjunto \"N1\":\n     |   |   |                     o conjunto N1 ir\u00e1 crescer a medida que novos\n     |   |   |                     vizinhos s\u00e3o descobertos no corpo desse loop\n     |   |   |\n     |   |   |  SE \"x2\" \u00e9 um \"core\" de outro cluster ignora o resto deste bloco e \n     |   |   |                                 passa ao pr\u00f3ximo elemento do LOOP2\n     |   |   |\n     |   |   |  \"N2\" = lista de pontos em \"X\" com dist\u00e2ncia para \"x2\" menor que \"radius\"\n     |   |   |  \n     |   |   |  SE \"N2\" cont\u00e9m mais de \"minPts\" pontos:\n     |   |   |   |\n     |   |   |   |  marca \"x2\" como um \"core\" do cluster \"cluster_id\"\n     |   |   |   |\n     |   |   |   |  adiciona os pontos \"N2\" aos vizinhos \"N1\" (ignorando duplicatas)\n     |   |   |   |                 estes vizinhos s\u00e3o inclu\u00eddos em \"N1\" para que o \n     |   |   |   |                 LOOP2 continue enquanto houverem pontos pr\u00f3ximos\n     |   |   |   |                 aos n\u00facleos desse cluster. \n     |   |   |   |\n     |   |   |  CASO CONTR\u00c1RIO\n     |   |   |   |\n     |   |   |   |  marca \"x2\" como uma \"borda\" do cluster \"cluster_id\"\n    \n     \n   \n### 2.1 Implementa\u00e7\u00e3o Python\n\nAbra a c\u00e9lula abaixo para ver o c\u00f3digo fonte.","6f085949":"## 3. Exemplo com a base de casos e mortes de covid-19 por munic\u00edpio nos Estados Unidos\n\nOs dados usados usados nesta demonstra\u00e7\u00e3o s\u00e3o de casos e mortes por covid19 por munic\u00edpio dos Estados Unidos. ","f73b2780":"### 2.1 Ajuda\n\nImplementar uma informa\u00e7\u00e3o geral do funcionamento do algoritmo \u00e9 sempre uma boa ideia para ajudar os usu\u00e1rios de suas bibliotecas. Isto \u00e9 feito inserindo uma string logo ap\u00f3s a abertura da fun\u00e7\u00e3o\/classe.","aa5a8493":"## 2.3. Testes da implementa\u00e7\u00e3o\n\nO c\u00f3digo abaixo gera o v\u00eddeo no in\u00edcio deste documento."}}