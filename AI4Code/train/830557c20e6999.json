{"cell_type":{"d1ebb4b7":"code","e6c7ca3e":"code","f430ff2a":"code","7a6bcd61":"code","3fef9ee9":"code","3397a3ee":"code","e4004bba":"code","38685906":"code","1543955b":"code","18d7c99e":"code","9f2f6192":"code","7198304c":"code","0c10ab35":"code","a4ee380b":"code","71fed34c":"code","e8d4accb":"code","e0b76184":"markdown","4f6f1e1b":"markdown","327532df":"markdown","74deb531":"markdown","120384f6":"markdown","1e42e6eb":"markdown","0f3fa97b":"markdown","df9480de":"markdown"},"source":{"d1ebb4b7":"import numpy as np\nnp.random.seed(44)\nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()","e6c7ca3e":"df=pd.read_csv('\/kaggle\/input\/breast-cancer-prediction-dataset\/Breast_cancer_data.csv')\ndf.head()","f430ff2a":"X= df.drop(['diagnosis'],axis=1).values\ny= df['diagnosis'].values.reshape(-1,1)","7a6bcd61":"from sklearn.model_selection import train_test_split\nX_train,X_test,y_train,y_test= train_test_split(X,y,random_state=0,test_size=0.2)","3fef9ee9":"from sklearn.preprocessing import StandardScaler\nscaler= StandardScaler()\nX_train_sc= scaler.fit_transform(X_train)\nX_test_sc = scaler.transform(X_test) ","3397a3ee":"from sklearn.linear_model import LogisticRegression\nclf= LogisticRegression(max_iter=1000)\nclf.fit(X_train_sc,y_train)\n\nprint('Testing Accuracy: ', clf.score(X_test_sc, y_test))","e4004bba":"# features = X_train_sc\n# target = y_train.values.reshape(-1,1)","38685906":"# Activation (sigmoid) function\ndef sigmoid(x):\n    return 1 \/ (1 + np.exp(-x))\n\ndef sigmoid_prime(x):\n    return sigmoid(x) * (1-sigmoid(x))\n\ndef error_formula(y, output):\n    return - y*np.log(output) - (1 - y) * np.log(1-output)","1543955b":"def feedforward(features, weights):\n    return sigmoid(np.dot(features, weights))\n\ndef calc_loss (target, output):\n    return np.mean(error_formula(target, output))\n\ndef update_weights(weights, features, target, output, learn_rate=0.01):\n    dE = - np.dot(features.T, (target - output))\n    weights -= learn_rate * dE\n    return weights\n\ndef train(features, target, epochs=1000, learn_rate=0.01):\n    n_features = features.shape[1]\n    n_output = target.shape[1]\n    weights = np.random.normal(scale=1 \/ n_features**0.5, size=(n_features, n_output))\n    for e in range (epochs):\n        output = feedforward(features, weights)\n        loss = calc_loss (target, output)\n        weights = update_weights(weights, features, target, output, learn_rate=0.01)\n        if e%100 == 0:\n            print(\" Epoch No. \", e, \" , Loss= \", loss)\n    return weights","18d7c99e":"final_weights = train(X_train_sc, y_train, epochs=1000, learn_rate=0.01)","9f2f6192":"y_pred = feedforward(X_test_sc, final_weights) >0.5","7198304c":"from sklearn.metrics import accuracy_score\n\naccuracy_score(y_pred, y_test)","0c10ab35":"def feedforward(features, weights_ih, weights_ho):\n    hidden = sigmoid(np.dot(features, weights_ih))\n    return sigmoid(np.dot(hidden, weights_ho))\n\ndef calc_loss (target, output):\n    return np.mean(error_formula(target, output))\n\ndef update_weights(weights_ih, weights_ho, features, target, output, learn_rate=0.01):\n    hidden = np.dot(features, weights_ih)\n    dE2 = - np.dot(sigmoid(hidden).T, (target - output))\n    \n    \n    z= - np.dot((target - output), weights_ho.T)\n    dE1 =  np.dot (features.T, z * sigmoid_prime(hidden))\n    \n    weights_ih -= learn_rate * dE1\n    weights_ho -= learn_rate * dE2\n    return weights_ih, weights_ho\n\ndef train(features, target, n_hidden = 100, epochs=1000, learn_rate=0.01):\n    n_features = features.shape[1]\n    n_output = target.shape[1]\n    weights_ih = np.random.normal(scale=1 \/ n_features**0.5, size=(n_features, n_hidden))\n    weights_ho = np.random.normal(scale=1 \/ n_hidden**0.5, size=(n_hidden, n_output))\n    for e in range (1,epochs+1):\n        output = feedforward(features, weights_ih, weights_ho)\n        loss = calc_loss (target, output)\n        if e%100 == 0:\n            print(\" Epoch No. \", e, \" , Loss= \", loss)\n        weights_ih, weights_ho = update_weights(weights_ih, weights_ho, features, target, output, learn_rate=0.01)\n    return weights_ih, weights_ho","a4ee380b":"w_ih, w_ho = train(X_train_sc, y_train, n_hidden = 50, epochs=500, learn_rate=0.01)","71fed34c":"y_pred = feedforward(X_test_sc, w_ih, w_ho) >0.5","e8d4accb":"from sklearn.metrics import accuracy_score\n\naccuracy_score(y_pred, y_test)","e0b76184":"![](https:\/\/drive.google.com\/uc?id=1UGbD1VcNhFIaOUaZQ8LFi7KdGXz9Jbw0)","4f6f1e1b":"# Helper Functions","327532df":"**I hope you found it useful**\n\n**Any Feedback is appreciated**","74deb531":"![](https:\/\/drive.google.com\/uc?id=1NCoSsj1Bn9kb84PNFWw4QPSjfiJbSxiH)\n![](https:\/\/drive.google.com\/uc?id=1wqxTwJiU8kOt_88D8Sr9kZBzwhWKTv7P)","120384f6":"# Logistic Regression\n","1e42e6eb":"## Scaling","0f3fa97b":"# Single Layer Neural Network","df9480de":"# Two Layers Neural Network"}}