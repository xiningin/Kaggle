{"cell_type":{"a9bdc9fe":"code","625e04be":"code","a88f6db8":"code","d861776f":"code","f006817a":"code","29a18333":"code","2fe5e367":"markdown","bb64183e":"markdown","3ef6c859":"markdown","e6b19e12":"markdown","337a6ac4":"markdown","44963f56":"markdown","605bedc0":"markdown","bc78e88c":"markdown","95939708":"markdown","bf055678":"markdown","01b0c48a":"markdown","87d12455":"markdown"},"source":{"a9bdc9fe":"import numpy as np\nimport matplotlib.image as mpimg\nimport matplotlib.pyplot as plt","625e04be":"orig_img = np.array(mpimg.imread('..\/input\/origimg.jpg')).astype(int)\norig_img[orig_img<128] = -1\norig_img[orig_img>=128] = 1\n\nplt.figure()\nplt.axis('off')\nplt.imshow(orig_img, cmap='binary_r')\n\nnoisy_img = np.array(mpimg.imread('..\/input\/noisyimg.jpg')).astype(int)\nnoisy_img[noisy_img<128] = -1\nnoisy_img[noisy_img>=128] = 1\n\nplt.figure()\nplt.axis('off')\nplt.imshow(noisy_img, cmap='binary_r')\nprint ('Image:')\n","a88f6db8":"# compute the error rate between the noisy image and the original image\ndef compute_error_rate(img1, img2):\n    err = abs(img1 - img2) \/ 2\n    return np.sum(err) \/ np.size(img2) * 100\n\nprint ('Percentage of mismatched pixels in noisy image: %.6f%%' % compute_error_rate(orig_img, noisy_img))","d861776f":"def compute_prob(X, Y, i, j, m, n, beta, eta, x_value):\n    \n    result = beta * Y[i][j] * x_value\n    \n    if i > 0:\n        result += eta * x_value * X[i-1][j]\n    if i < m-1:\n        result += eta * x_value * X[i+1][j]\n    if j > 0:\n        result += eta * x_value * X[i][j-1]\n    if j < n-1:\n        result += eta * x_value * X[i][j+1]\n    \n    \n    return result","f006817a":"def denoise_image(Y, orig, beta, eta):\n    m, n = np.shape(Y)\n    X = np.copy(Y)\n    max_iter = 5\n    \n    for k in range(max_iter):\n        for i in range(m):\n            for j in range(n):\n                \n                p_pos = compute_prob(X, Y, i, j, m, n, beta, eta, 1)\n                p_neg = compute_prob(X, Y, i, j, m, n, beta, eta, -1)\n                \n                if p_pos > p_neg:\n                    X[i][j] = 1\n                else:\n                    X[i][j] = -1\n                    \n        print('Iteration number:', k+1)\n        print ('Percentage of mismatched pixels: %.6f%%' % compute_error_rate(orig, X))\n    return X","29a18333":"beta = 1.0\neta = 2.1\ndenoised_img = denoise_image(noisy_img, orig_img, beta, eta)\n\nplt.figure()\nplt.axis('off')\nplt.imshow(denoised_img, cmap='binary_r')\nprint ('Percentage of mismatched pixels in denoised image: %.6f%%' % compute_error_rate(orig_img, denoised_img))\nprint ('Denoised Image:')","2fe5e367":"**Clique factorization:**\n![image.png](attachment:image.png)\n\nLet $C$ denote a clique and the set of variables in it as ${\\bf x}_C$\n$$p({\\bf x})=\\frac{1}{Z}\\prod_C \\psi_C({\\bf x}_C)$$\nwhere $\\psi_C({\\bf x}_C)$ is called potential function and $Z$ is the normalization factor.\n\nThe definition is equivalent if only maximal cliques are used.","bb64183e":"Boltzmann distribution:\n$$\\psi_C({\\bf x}_C)=\\exp\\{-E({\\bf x}_C)\\}$$\nwhere $E({\\bf x}_C)$ is called energy function.\n$$p({\\bf x})=\\frac{1}{Z}\\prod_C \\psi_C({\\bf x}_C)=\\frac{1}{Z}\\exp\\{-\\sum_C E({\\bf x}_C)\\}$$","3ef6c859":"Energy function:\n$$E({\\bf x},{\\bf y})=-\\beta\\sum_{i,j}x_{ij}y_{ij}-\\eta\\sum_{\\{ij,kl\\}}x_{ij}x_{kl}$$\nwhere (i,j) and (k,l) in the third term are adjacent pixels.","e6b19e12":"## Image Denoising","337a6ac4":"![image.png](attachment:image.png)","44963f56":"![image.png](attachment:image.png)","605bedc0":"####  Iterated Conditional Modes (ICM) \n1. Initialize $x_{ij}$ to their noisy values $y_{ij}$.\n\n2. Iterate through each $x_{ij}$ and check whether setting it\u2019s value to +1 or -1 leads to a lower energy (higher probability).","bc78e88c":"**Problem Description**:\n\nSuppose we have an image consisting of a 2-dimensional array of pixels, where each pixel value is binary. Assume it got corrupted by random noise, where each pixel in the image is flipped with 10% probability.\nOur goal is to recover the original image.","95939708":"\\begin{equation}\n\\begin{split}\n\\arg\\max_{\\bf x} p({\\bf x}|{\\bf y})&=\\arg\\max_{\\bf x} p({\\bf x},{\\bf y})\\\\\n&=\\arg\\max_{\\bf x} \\frac{1}{Z}\\exp\\{-E({\\bf x},{\\bf y})\\}\\\\\n&=\\arg\\min_{\\bf x} E({\\bf x},{\\bf y})\\\\\n&= \\arg\\min_{\\bf x} -\\beta\\sum_{i,j}x_{ij}y_{ij}-\\eta\\sum_{\\{ij,kl\\}}x_{ij}x_{kl}\\\\\n&= \\arg\\max_{\\bf x} \\beta\\sum_{i,j}x_{ij}y_{ij}+\\eta\\sum_{\\{ij,kl\\}}x_{ij}x_{kl}\n\\end{split}\n\\end{equation}","bf055678":"A Markov network is a set of random variables having a Markov property described by an undirected graph.\n\n**Markov property**: Any two subsets of variables are conditionally independent given a separating subset.","01b0c48a":"### Model\n\n**Observed variables**: each pixel in the noisy image, $y_{ij}\\in \\{-1,+1\\}$\n\n**Unobserved variables**: each pixel in the ground truth image, $x_{ij}\\in \\{-1,+1\\}$\n\n**Assumptions**:\n\n1. There is a strong correlation between $x_{ij}$ and $y_{ij}$\n\n2. There is a strong correlation between neighboring pixels, i.e., $x_{ij}$ and $x_{i+1,j}$, $x_{i-1,j}$, $x_{i,j+1}$, $x_{i,j-1}$","87d12455":"## Markov Network"}}