{"cell_type":{"827a043f":"code","ea162dbd":"code","6be422ed":"code","01f9c0ba":"code","29c6df32":"code","ad8afde2":"code","9e5e314b":"code","d128398c":"markdown","c2c5166e":"markdown","01e29e48":"markdown","62bf175d":"markdown","6dff9ac1":"markdown","038545d7":"markdown","1eebb7ec":"markdown","8bd9a4f7":"markdown"},"source":{"827a043f":"import os\nimport skimage\nimport numpy as np\nimport pandas as pd\nimport skimage.segmentation\nimport matplotlib.pyplot as plt\nfrom skimage.morphology import label as labeling\nimport random","ea162dbd":"def decode(rle_mask, shape):\n\n    \"\"\"\n    Decode run-length encoded segmentation mask string into 2d array\n    Parameters\n    ----------\n    rle_mask (str): Run-length encoded segmentation mask string\n    shape (tuple): Height and width of the mask\n    Returns\n    -------\n    mask [numpy.ndarray of shape (height, width)]: Decoded 2d segmentation mask\n    \"\"\"\n    rle_mask = rle_mask.split()\n    starts, lengths = [np.asarray(x, dtype=int) for x in (rle_mask[0:][::2], rle_mask[1:][::2])]\n    starts -= 1\n    ends = starts + lengths\n\n    mask = np.zeros((shape[0] * shape[1]), dtype=np.uint8)\n    \n    for start, end in zip(starts, ends):\n        mask[start:end] = 1\n\n    mask = mask.reshape(shape[0], shape[1], 1)\n    return mask\n\n\ndef rle_encoding(x):\n    dots = np.where(x.T.flatten() == 1)[0] # this is as we can find it in several succesful notebooks\n    run_lengths = []\n    prev = -2\n    for b in dots:\n        if (b>prev+1): run_lengths.extend((b + 1, 0))\n        run_lengths[-1] += 1\n        prev = b\n    return run_lengths\n\n\ndef rle_encoding_no_t(x):\n    dots = np.where(x.flatten() == 1)[0]\n    run_lengths = []\n    prev = -2\n    for b in dots:\n        if (b>prev+1): run_lengths.extend((b + 1, 0))\n        run_lengths[-1] += 1\n        prev = b\n    return run_lengths\n\ndef prob_to_rles(x, cutoff=0.5):\n    lab_img = labeling(x > cutoff)\n    for i in range(1, lab_img.max() + 1):\n        yield rle_encoding(lab_img == i)\n        \n    \ndef prob_to_rles_no_t(x, cutoff=0.5):\n    lab_img = labeling(x > cutoff)\n    for i in range(1, lab_img.max() + 1):\n        yield rle_encoding_no_t(lab_img == i)\n        ","6be422ed":"example = np.array([[0,1,1,1,1,1,1] , [0,0,0,0,0,0,0] , [0,1,1,1,1,1,1] , [0,1,1,1,1,1,1] , [0,1,1,1,1,1,1] ])\nprint(example)\nprint(example.shape)\nplt.figure(figsize=(15, 10))\nplt.imshow(example, cmap = \"gray\")\nplt.axis(False)\nplt.show()","01f9c0ba":"def get_submission():\n\n    \n    # submission df\n    sample_submission = pd.read_csv('..\/input\/sartorius-cell-instance-segmentation\/sample_submission.csv')\n    df_submission = pd.DataFrame(data = None, columns = sample_submission.columns)\n\n    # lits for submission df\n    list_test_ids = []\n    list_rles = []\n\n    count = 0\n    id_ = \"example\"\n\n\n    # store rles and ids in lists for df \n    rle = list(prob_to_rles(example))      \n    list_test_ids.extend([id_] * len(rle)) # extend id for every class in its masks\n    list_rles.extend(rle)\n\n    # store lists in df submission\n    df_submission['id'] = list_test_ids\n    df_submission['predicted'] = pd.Series(list_rles).apply(lambda x: ' '.join(str(y) for y in x))\n\n    # write submission to csv\n    df_submission.to_csv('submission.csv', index = False)\n    df_test = pd.read_csv('submission.csv')\n    \n    print(df_test)\n    \nget_submission()","29c6df32":"df_test = pd.read_csv('submission.csv')\n\nprint(example.shape)\nmask1  = example \nprint(mask1)\nprint(mask1.shape)\nmask__1 = np.zeros((5, 7, 1))\nprint(\"\")\n\nid_ = \"example\"\nmasks_df_id = df_test[df_test[\"id\"]==id_]\nprint(masks_df_id)          \n\n#loop over annotations per id\nfor _, row in masks_df_id.iterrows():    \n    mask__1 += decode(row[\"predicted\"], (5,7,1))\n    \nprint(\"\")\nprint(\"outputted mask:\", mask__1[:,:,0])\n\nprint(\"\")\nplt.figure(figsize=(15, 10))\nplt.imshow(mask__1, cmap = \"gray\")\nplt.axis(False)\nplt.show()\n","ad8afde2":"def get_submission():\n\n    \n    # submission df\n    sample_submission = pd.read_csv('..\/input\/sartorius-cell-instance-segmentation\/sample_submission.csv')\n    df_submission = pd.DataFrame(data = None, columns = sample_submission.columns)\n\n    # lits for submission df\n    list_test_ids = []\n    list_rles = []\n\n    count = 0\n    id_ = \"example\"\n\n\n    # store rles and ids in lists for df \n    rle = list(prob_to_rles_no_t(example))      \n    list_test_ids.extend([id_] * len(rle)) # extend id for every class in its masks\n    list_rles.extend(rle)\n\n    # store lists in df submission\n    df_submission['id'] = list_test_ids\n    df_submission['predicted'] = pd.Series(list_rles).apply(lambda x: ' '.join(str(y) for y in x))\n\n    # write submission to csv\n    df_submission.to_csv('submission.csv', index = False)\n    df_test = pd.read_csv('submission.csv')\n    \n    print(df_test)\n    \nget_submission()","9e5e314b":"df_test = pd.read_csv('submission.csv')\n\nprint(example.shape)\nmask2  = example \nprint(mask2)\nprint(mask2.shape)\nprint(\"\")\nmask__2 = np.zeros((5, 7, 1))\n\nmasks_df_id = df_test[df_test[\"id\"]==id_]\nprint(masks_df_id)          \n\n#loop over annotations per id\nfor _, row in masks_df_id.iterrows():    \n    mask__2 += decode(row[\"predicted\"], (5,7,1))\n\nprint(\"outputted mask:\", mask__2[:,:,0])\n\nprint(\"\")\nplt.figure(figsize=(15, 10))\nplt.imshow(mask__2, cmap = \"gray\")\nplt.axis(False)\nplt.show()","d128398c":"# Functions","c2c5166e":"# Example Run Length De- \/ Encoding with Transpose","01e29e48":"- outputted mask from run length is destroyed","62bf175d":"## Ground truth Example","6dff9ac1":"- functions of other notebooks","038545d7":"# Example Run Length De- \/ Encoding no Transpose","1eebb7ec":"- outputted mask from run length as expected","8bd9a4f7":"# Scenario:\n# When encoding a mask with the provided functions (see other notebooks) and decoding it back to an mask, the mask doesnt look like its input?\n# only if I change it to delete the transpose command, then it looks as it should.\n# Would be nice to hear your thoughts?\n# Is it okay, because the competitions hosts are encoding the masks in a other as we do our trainig masks?\n# Thx"}}