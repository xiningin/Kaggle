{"cell_type":{"a319c834":"code","092dce8b":"code","39e2cb5b":"code","6b04cf67":"code","3ac61ed9":"code","cc6190d0":"code","70e3ad7f":"code","358769e2":"code","e5e2f189":"code","56251c4a":"code","c812440a":"code","5ba466d7":"code","273b0288":"code","caa6c51c":"code","ac4d8dfa":"code","1ea1d133":"code","ba4f59d0":"code","8ac35e19":"code","5a37643f":"code","dfd79a05":"code","be3b3717":"markdown","a5e26071":"markdown"},"source":{"a319c834":"# Ignore  the warnings\nimport warnings\nwarnings.filterwarnings('always')\nwarnings.filterwarnings('ignore')","092dce8b":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport os\nfrom skimage import io\n\n#!pip install efficientnet_pytorch torchtoolbox\nimport copy\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import Dataset, DataLoader, random_split\n#import torchtoolbox.transform as transforms\n\nimport torchvision\nfrom torchvision import datasets, models, transforms\n\nfrom sklearn.metrics import accuracy_score, roc_auc_score\nfrom sklearn.model_selection import StratifiedKFold, GroupKFold\nimport gc\nimport cv2\nimport time\nimport datetime\nimport warnings\nimport random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom tqdm import tqdm\n%matplotlib inline\n\nfrom PIL import Image\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")","39e2cb5b":"def seed_everything(seed):\n    \"\"\"\n    Seeds basic parameters for reproductibility of results\n    \n    Arguments:\n        seed {int} -- Number of the seed\n    \"\"\"\n    # random.seed(seed)\n    # os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\nseed_everything(42)","6b04cf67":"def make_CNN(model_name, num_classes):\n    # Initialize these variables which will be set in this if statement. Each of these\n    # variables is model specific.\n    # The model (nn.Module) to return\n    model_ft = None\n    # The input image is expected to be (input_size, input_size)\n    input_size = 0\n    \n    # You may NOT use pretrained models!! \n    use_pretrained = True\n    \n    # By default, all parameters will be trained (useful when you're starting from scratch)\n    # Within this function you can set .requires_grad = False for various parameters, if you don't want to learn them\n\n    if model_name == \"resnet\":\n        \"\"\" Resnet18\n        \"\"\"\n        model_ft = models.resnet18(pretrained=use_pretrained)\n        num_ftrs = model_ft.fc.in_features\n        model_ft.fc = nn.Linear(num_ftrs, 1)\n        input_size = 224\n        \n    elif model_name == \"vgg16\":\n        \"\"\" VGG16_bn\n        \"\"\"\n        model_ft = models.vgg16_bn(pretrained=use_pretrained)\n        num_ftrs = model_ft.classifier[6].in_features\n        model_ft.classifier[6] = nn.Linear(num_ftrs, 1)\n        input_size = 224\n\n    elif model_name == \"squeezenet\":\n        \"\"\" Squeezenet\n        \"\"\"\n        model_ft = models.squeezenet1_0(pretrained=use_pretrained)\n        model_ft.classifier[1] = nn.Conv2d(512, 1, kernel_size=(1,1), stride=(1,1))\n        model_ft.num_classes = num_classes\n        input_size = 224\n\n    elif model_name == \"densenet\":\n        \"\"\" Densenet\n        \"\"\"\n        model_ft = models.densenet121(pretrained=use_pretrained)\n        num_ftrs = model_ft.classifier.in_features\n        model_ft.classifier = nn.Linear(num_ftrs, 1)\n        input_size = 224\n        \n    else:\n        raise Exception(\"Invalid model name!\")\n    \n    return model_ft, input_size","3ac61ed9":"class Melanoma_Net(nn.Module):\n    \"\"\"\n    fc1: number of neurons in the hidden fully connected layer\n    \"\"\"\n    def __init__(self, cnn_model_name, num_classes, num_multimodal_features=9, fc1_out=32):\n        #num_classes = 1\n        #num_multimodal_features= 9\n        super(Melanoma_Net, self).__init__()\n        self.cnn, self.input_size = make_CNN(cnn_model_name, num_classes)#models.vgg11(pretrained=False, progress = True)\n        #define output layers\n        self.fc1 = nn.Linear(num_classes + num_multimodal_features, fc1_out) #takes in input of CNN and multimodal input\n        self.fc2 = nn.Linear(fc1_out, num_classes)\n        \n    def forward(self, image, data):\n        x1 = self.cnn(image)\n        #print(\"x1\", x1.shape)\n        x2 = data\n        #print(\"x2\", x2.shape)\n        #print(\"x1: \", x1, type(x1))\n        #print(\"x2: \", x2, type(x2))\n        #x = torch.cat((x1, x2), dim=1)  \n        x = torch.cat((x1.float(), x2.float()), dim=1) ### ???\n        #print(\"concat\", x.shape)\n        x = F.relu(self.fc1(x))\n        #print(\"relu\", x.shape)\n        x = self.fc2(x)\n        #print('forward output: ', x)\n        #print(\"fc2\", x.shape)\n        return x.double() ### ???","cc6190d0":"class AdvancedHairAugmentation:\n    \"\"\"\n    Impose an image of a hair to the target image\n\n    Args:\n        hairs (int): maximum number of hairs to impose\n        hairs_folder (str): path to the folder with hairs images\n    \"\"\"\n\n    def __init__(self, hairs: int = 5, hairs_folder: str = \"\"):\n        self.hairs = hairs\n        self.hairs_folder = hairs_folder\n\n    def __call__(self, img_path):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to draw hairs on.\n\n        Returns:\n            PIL Image: Image with drawn hairs.\n        \"\"\"\n        img = cv2.imread(img_path)\n        n_hairs = random.randint(1, self.hairs)\n        \n        if not n_hairs:\n            return img\n        \n        height, width, _ = img.shape  # target image width and height\n        hair_images = [im for im in os.listdir(self.hairs_folder) if 'png' in im]\n        \n        for _ in range(n_hairs):\n            hair = cv2.imread(os.path.join(self.hairs_folder, random.choice(hair_images)))\n            hair = cv2.flip(hair, random.choice([-1, 0, 1]))\n            hair = cv2.rotate(hair, random.choice([0, 1, 2]))\n\n            h_height, h_width, _ = hair.shape  # hair image width and height\n            roi_ho = random.randint(0, img.shape[0] - hair.shape[0])\n            roi_wo = random.randint(0, img.shape[1] - hair.shape[1])\n            roi = img[roi_ho:roi_ho + h_height, roi_wo:roi_wo + h_width]\n\n            # Creating a mask and inverse mask\n            img2gray = cv2.cvtColor(hair, cv2.COLOR_BGR2GRAY)\n            ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)\n            mask_inv = cv2.bitwise_not(mask)\n\n            # Now black-out the area of hair in ROI\n            img_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)\n\n            # Take only region of hair from hair image.\n            hair_fg = cv2.bitwise_and(hair, hair, mask=mask)\n\n            # Put hair in ROI and modify the target image\n            dst = cv2.add(img_bg, hair_fg)\n\n            img[roi_ho:roi_ho + h_height, roi_wo:roi_wo + h_width] = dst\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #converts image color back to regular color (instead of producing blue tinted image)        \n        return img\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}(hairs={self.hairs}, hairs_folder=\"{self.hairs_folder}\")'","70e3ad7f":"class MultimodalDataset(Dataset):\n    \"\"\"\n    Custom dataset definition\n    \"\"\"\n    def __init__(self, csv_path, img_path, mode='train', transform=None):\n        \"\"\"\n        \"\"\"\n        self.df = pd.read_csv(csv_path)\n        self.img_path = img_path\n        self.mode= mode\n        self.transform = transform\n        \n            \n    def __getitem__(self, index):\n        \"\"\"\n        \"\"\"\n        img_name = self.df.iloc[index][\"image_name\"] + \".jpg\"\n        img_path = os.path.join(self.img_path, img_name)\n        image = Image.open(img_path)\n\n        dtype = torch.cuda.FloatTensor if torch.cuda.is_available() else torch.FloatTensor # ???\n        \n        if self.mode == 'train':\n            #augments malignant images with hair twice\n            if self.df.iloc[index][\"augmented\"]==1:\n                image = AdvancedHairAugmentation(hairs_folder=\"..\/input\/melanoma-hairs\")(img_path)\n                image = Image.fromarray(image, 'RGB')\n            elif self.df.iloc[index][\"augmented\"]==2:\n                image = AdvancedHairAugmentation(hairs_folder=\"..\/input\/melanoma-hairs\")(img_path)\n                image = Image.fromarray(image, 'RGB')\n            else:  \n                image = image.convert(\"RGB\")\n                \n            image = np.asarray(image)\n            if self.transform is not None:\n                image = self.transform(image)\n            labels = torch.tensor(self.df.iloc[index][\"target\"], dtype = torch.float64)\n            \n            features = np.fromstring(self.df.iloc[index][\"features\"][1:-1], sep=\",\") #turns features into an array\n            features = torch.from_numpy(features.astype(\"float\")) #turns the features array into a vector\n            return image, features, labels\n            \n        elif self.mode == 'val':\n            image = np.asarray(image)\n            if self.transform is not None:\n                image = self.transform(image)\n            labels = torch.tensor(self.df.iloc[index][\"target\"], dtype = torch.float64)\n            \n            features = np.fromstring(self.df.iloc[index][\"features\"][1:-1], sep=\",\") #turns features into an array\n            features = torch.from_numpy(features.astype(\"float\")) #turns the features array into a vector\n            return image, features, labels\n        \n        else: #when self.mode=='test'\n            image = np.asarray(image)\n            if self.transform is not None:\n                image = self.transform(image)\n            features = np.fromstring(self.df.iloc[index][\"features\"][1:-1], sep=\",\") #turns features into an array\n            features = torch.from_numpy(features.astype(\"float\")) #turns the features array into a vector\n            return image, features, self.df.iloc[index][\"image_name\"]\n\n    def __len__(self):\n        return len(self.df)","358769e2":"image_path_dict = {'train': \"..\/input\/jpeg-melanoma-256x256\/train\",\n                  'val': \"..\/input\/jpeg-melanoma-256x256\/train\" ,\n                  'test': \"..\/input\/jpeg-melanoma-256x256\/test\"}","e5e2f189":"def get_dataloaders(input_size, batch_size, augment=False, shuffle = True):\n    # How to transform the image when you are loading them.\n    # you'll likely want to mess with the transforms on the training set.\n    \n    # For now, we resize\/crop the image to the correct input size for our network,\n    # then convert it to a [C,H,W] tensor, then normalize it to values with a given mean\/stdev. These normalization constants\n    # are derived from aggregating lots of data and happen to produce better results.\n    data_transforms = {\n        'train': transforms.Compose([\n            transforms.ToPILImage(),\n            transforms.Resize(input_size),\n            transforms.CenterCrop(input_size),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5], [0.225])\n        ]),\n        'val': transforms.Compose([\n            transforms.ToPILImage(),\n            transforms.Resize(input_size),\n            transforms.CenterCrop(input_size),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5], [0.225])\n        ]),\n        'test': transforms.Compose([\n            transforms.ToPILImage(),\n            transforms.Resize(input_size),\n            transforms.CenterCrop(input_size),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5], [0.225])\n        ])\n    }\n    # Create training and validation datasets\n    data_subsets = {x: MultimodalDataset(csv_path=\"..\/input\/melanoma\/\" + x + \".csv\", \n                                         img_path = image_path_dict[x],\n                                         mode = x,\n                                         transform=data_transforms[x]) for x in data_transforms.keys()}\n    \n    # Create training and validation dataloaders\n    # Never shuffle the test set\n    dataloaders_dict = {x: DataLoader(data_subsets[x], batch_size=batch_size, shuffle=False if x != 'train' else shuffle, num_workers=4) for x in data_transforms.keys()}\n    return dataloaders_dict","56251c4a":"from sklearn.metrics import confusion_matrix\nimport seaborn as sns\nimport matplotlib.pyplot as pl","c812440a":"val_df = pd.read_csv(\"..\/input\/melanoma\/val.csv\")\nval_real = []\nfor i in range(val_df.shape[0]):\n    val_real.append(val_df['target'].iloc[i])","5ba466d7":"def train_model(model, dataloaders, criterion, optimizer, \n                scheduler, model_name=str(datetime.datetime.now()), \n                save_dir = None, num_epochs=25):\n    import time\n    start_time = time.time()\n    \n    # Take out if just starting to train\n    checkpoint = torch.load(\"..\/input\/pretrained-multimodal\/resnet_weights_225.pt\")\n    model.load_state_dict(checkpoint['state_dict'])\n    optimizer.load_state_dict(checkpoint['optimizer'])\n    epoch_before = checkpoint['epoch']\n\n    train_losses = []\n    test_losses = []\n    train_auc=[]\n    val_auc=[]\n    train_pred = []\n    train_real = []\n    val_pred = []\n    val_real = []\n    for epoch in range(num_epochs):\n\n        train_preds=[]\n        train_targets=[]\n        auc_train=[]\n        loss_epoch_train=[]\n        loss_epoch_test=[]\n        # Run the training batches\n        for inputs, features, labels in tqdm(dataloaders['train']):\n            inputs = inputs.to(device)\n            features = features.to(device)\n            labels = labels.to(device)\n            \n            outputs = model(inputs, features)\n            outputs = torch.squeeze(outputs)\n            #outputs = torch.as_tensor(outputs.tolist())\n            preds = (outputs > 0).type(torch.float64)\n            train_real.extend(labels.tolist())\n            train_pred.extend(preds.tolist())\n            \n            labels = torch.squeeze(labels)\n            loss = criterion(torch.sigmoid(outputs.type(torch.FloatTensor)), labels.type(torch.FloatTensor))\n            loss_epoch_train.append(loss.item())\n                \n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n        auc_train=roc_auc_score(labels.detach().cpu().numpy(),torch.sigmoid(outputs).detach().cpu().numpy())\n        #auc_train=roc_auc_score(y_train.detach().to(device).numpy(),torch.sigmoid(y_pred).detach().to(device).numpy())\n        \n        train_losses.append(np.mean(loss_epoch_train))\n        train_auc.append(auc_train)\n        \n        print(f'Epoch: {epoch:2} Train Loss: {np.mean(loss_epoch_train):10.8f} AUC: {auc_train:10.8f} ')\n        df_confusion = confusion_matrix(train_real, train_pred)\n        df_conf_norm = df_confusion \/ df_confusion.sum(axis=1, keepdims = True)\n        print(df_conf_norm)\n        \n        # Run the testing batches\n        with torch.no_grad():\n            for inputs, features, labels in tqdm(dataloaders['val']):\n                inputs = inputs.to(device)\n                features = features.to(device)\n                labels = labels.to(device)\n                \n                outputs = model(inputs, features)\n                outputs = torch.squeeze(outputs)\n                #print(outputs)\n                preds = (outputs > 0).type(torch.float64)\n                val_real.extend(labels.tolist())\n                val_pred.extend(preds.tolist())\n                \n                #outputs = torch.as_tensor(outputs.tolist())\n                #print('new outs', outputs)\n                labels = torch.squeeze(labels)\n                loss = criterion(torch.sigmoid(outputs.type(torch.FloatTensor)), labels.type(torch.FloatTensor))\n                loss_epoch_test.append(loss.item())\n                                          \n        auc_val=roc_auc_score(labels.detach().cpu().numpy(),torch.sigmoid(outputs).detach().cpu().numpy())\n        \n        test_losses.append(np.mean(loss_epoch_test))\n        val_auc.append(auc_val)\n        \n        print(f'Epoch: {epoch} Val Loss: {np.mean(loss_epoch_test):10.8f} AUC: {auc_val:10.8f} ')\n        df_confusion = confusion_matrix(val_real, val_pred)\n        df_conf_norm = df_confusion \/ df_confusion.sum(axis=1, keepdims = True)\n        print(df_conf_norm)\n        \n        \n        model_file = { 'epoch': epoch,\n                      'state_dict': model.state_dict(),\n                      'optimizer' : optimizer.state_dict()}\n        torch.save(model_file, \"{}_weights_{}.pt\".format(model_name, epoch))\n        #epoch if just started training\n        #epoch + epoch_before + 1 afterwards\n    print(f'\\nDuration: {time.time() - start_time:.0f} seconds') # print the time elapsed\n    return train_auc, val_auc","273b0288":"class FocalLoss(nn.Module):\n    def __init__(self, alpha=0.25, gamma=2.0, logits=False, reduce=True):\n        super(FocalLoss, self).__init__()\n        self.alpha = alpha\n        self.gamma = gamma\n        self.logits = logits\n        self.reduce = reduce\n\n    def forward(self, inputs, targets):\n        if self.logits:\n            BCE_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduce=False)\n        else:\n            BCE_loss = F.binary_cross_entropy(inputs, targets, reduce=False)\n        pt = torch.exp(-BCE_loss)\n        F_loss = self.alpha * (1-pt)**self.gamma * BCE_loss\n\n        if self.reduce:\n            return torch.mean(F_loss)\n        else:\n            return F_loss","caa6c51c":"def make_optimizer(model):\n    # Get all the parameters\n    params_to_update = model.parameters()\n    print(\"Params to learn:\")\n    for name, param in model.named_parameters():\n        if param.requires_grad == True:\n            print(\"\\t\",name)\n\n    # Use SGD\n    optimizer = optim.SGD(params_to_update, lr=0.01, momentum=0.9)\n    return optimizer\n\n \ndef get_loss(num_classes,device):\n    # Create an instance of the loss function\n    # We could set weights to account for unbalanced data but we have augmented the data to be even in benign count and malignant count\n    \n    #pos_weight = torch.tensor(np.ones(num_classes))\n    #pos_weight = pos_weight.to(device)\n    criterion = nn.BCEWithLogitsLoss()\n    \n    #criterion = FocalLoss()\n    return criterion\n","ac4d8dfa":"# Models to choose from [resnet, vgg16, squeezenet, densenet]\n# You can add your own, or modify these however you wish!\nmodel_name = 'resnet'\n\n# Number of classes in the dataset\nnum_classes = 1\n\n# Batch size for training (change depending on how much memory you have)\n# You should use a power of 2.\nbatch_size = 64\n\n# Shuffle the input data?\nshuffle_datasets = True\n\n# Number of epochs to train for \nnum_epochs = 20\n\n# Directory to save weights to\n#save_dir = \"weights\"\n#os.makedirs(save_dir, exist_ok=True)","1ea1d133":"torch.cuda.is_available() ","ba4f59d0":"gc.collect()","8ac35e19":"# Initialize the model for this run\nmodel = Melanoma_Net(cnn_model_name = model_name, num_classes = num_classes)\ninput_size = model.input_size\n    \ndataloaders = get_dataloaders(input_size, batch_size, shuffle = shuffle_datasets)\ncriterion = get_loss(num_classes=num_classes,device=device)\n\n# Move the model to the gpu if needed\nmodel = model.to(device)\n\noptimizer = make_optimizer(model)\nscheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=30, gamma=0.1)\n#scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[5,10],gamma=0.1)\n\n# Train the model!\ntrain_auc, val_auc = train_model(model=model,\n            dataloaders=dataloaders, criterion=criterion, optimizer=optimizer,\n            scheduler=scheduler, model_name=model_name, num_epochs=num_epochs)","5a37643f":"model = Melanoma_Net(cnn_model_name = model_name, num_classes = num_classes)\ncheckpoint = torch.load('.\/resnet_weights_3.pt')\nmodel.load_state_dict(checkpoint['state_dict'])\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\ninput_size = model.input_size\ndataloaders = get_dataloaders(input_size, batch_size, shuffle = shuffle_datasets)\ntest_loader = dataloaders['test']\n\nif torch.cuda.is_available():\n    model.cuda()\nmodel.eval()\n\nfn_list = []\npred_list = []\n\nfor inputs, features, fn in test_loader:\n    inputs = inputs.to(device)\n    features = features.to(device)\n    output = model(inputs, features)\n    a=torch.sigmoid(output).cpu().detach().numpy()\n    for i in a:\n        pred_list.append(i[0])\n    #pred = (output > 0).type(torch.float64)\n    fn_list += fn\n    #pred_list += [p.item() for p in pred]\n\nsubmission = pd.DataFrame({\"image_name\":fn_list, \"target\":pred_list})\nsubmission.to_csv('test_predictions.csv', index=False)","dfd79a05":"submission.head(50)","be3b3717":"# Train!","a5e26071":"# Predict on Test CSV"}}