{"cell_type":{"a7c1e7bc":"code","c8d6d4aa":"code","46890282":"code","f8c7f0c0":"code","76fba5de":"code","1593ad8e":"code","3635d13e":"code","c6f8748c":"code","726ede5c":"code","e3c1ba5e":"code","8cb4064a":"code","b4aa0fdf":"code","01fbf75b":"code","0d44c7f0":"code","fe9cc87d":"code","aca30758":"code","f704ee24":"code","e4cedcbb":"code","68c453b5":"code","c2364edb":"code","4eb7b08b":"code","04c1051b":"code","c5c1fa73":"code","aea02ab3":"code","18973016":"code","8a635812":"code","9df986ae":"code","06f63d68":"markdown","e3b507ee":"markdown","08ded422":"markdown","15d54e9f":"markdown","3700920d":"markdown","2f83ca98":"markdown","0686e607":"markdown","777e3218":"markdown","3c9f0ddf":"markdown","94215420":"markdown","95844724":"markdown","ccfa52e9":"markdown","68c0a64b":"markdown","7cdeaa12":"markdown","7f59d00f":"markdown","183238b3":"markdown","86cbe8a6":"markdown","3d7b0e0a":"markdown"},"source":{"a7c1e7bc":"%pylab inline\nfrom matplotlib import style\nstyle.use('https:\/\/raw.githubusercontent.com\/JoseGuzman\/minibrain\/master\/minibrain\/paper.mplstyle') # my custom plots\nimport pandas as pd","c8d6d4aa":"# Load waveforms\nmypath = '..\/input\/waveforms\/waveforms.csv'\nwaveforms = pd.read_csv(mypath, index_col = 'uid')\n\nprint(f'{waveforms.shape[0]} observations and {waveforms.shape[1]-1} samples (features)')\n\nwaveforms.organoid.value_counts()","46890282":"# define some custom colors for visualization\nmycolors = {'TSCp5_30s':     '#FFA500', # orange\n          'TSCp5_32s':       '#4169E1', # royalblue\n          'TSCp5_30s_CHIR':  '#FF4500', # orange red\n          'TSCp5_32s_CHIR':  '#9400D3', #darkviolet\n          'DLX_bluered':     '#32CD32', # limegreen \n          'DLX_Cheriff':     '#228B22', # forestgreen\n          'DLX_H9' :         '#006400', # darkgreen \n          'AP_ctrl':         '#00BFFF', # deepskyblue \n          'AP_drug':         '#DC143C'  # crimson\n    }","f8c7f0c0":"# Add color to the DataFrame\nwaveforms['color'] = waveforms['organoid'].apply(lambda orgID: mycolors[orgID])\n","76fba5de":"def plot_waveform(index, ax = None):\n    \"\"\"\n    Returns an axis with the normalized waveform,\n    together with its color and tissue name. It \n    requires trace (2D NumPy array with the vectors\n    of spikes) and waveforms (pandas DataFrame).\n    \n    Arguments\n    ---------\n    index (int)\n        the index of the waveform to be selected in the\n        Pandas object.\n    ax (matplotlib axis object)\n        If None, use current axis object\n    \"\"\"\n    if ax is None:\n        myax = plt.gca()\n    else:\n        myax = ax\n    \n    # waveforms is a DataFrame and must be previously defined\n    df = waveforms.drop(['organoid', 'color'], axis = 1, inplace=False)\n    trace = df.values # 2D array\n    \n    myax.plot(trace[index], color = waveforms.iloc[index].color)\n    myax.text(x = 5, y= 0.75, s=waveforms.iloc[index].organoid, fontsize=10, color=waveforms.iloc[index].color)\n    \n    return myax\n\n    ","1593ad8e":"fig, ax = plt.subplots(1,8, figsize=(12,3))\nfig.suptitle('Example waveforms')\n\nax[0] = plot_waveform(index = 15,  ax = ax[0])\nax[1] = plot_waveform(index = 555, ax = ax[1])\nax[2] = plot_waveform(index = 400, ax = ax[2])\nax[3] = plot_waveform(index = 300, ax = ax[3])\nax[4] = plot_waveform(index = 321, ax = ax[4])\nax[5] = plot_waveform(index = 93,  ax = ax[5])\nax[6] = plot_waveform(index = 262,  ax = ax[6])\nax[7] = plot_waveform(index = 200,  ax = ax[7])\n\nax[7].text(x = 120, y= -1, s='1 ms', fontsize=10)\nax[7].hlines(y = -1.1, xmin =120, xmax = 150, lw=2, color='k') # 30 samples -> 1ms\n\nfor myax in ax:\n    myax.set_ylim(-1.3,1.3)\n    myax.grid()\n    myax.axis('off')\n#plt.savefig('spikes.png', dpi = 300)","3635d13e":"# we select numerical values \ndf = waveforms.drop(['organoid', 'color'], axis = 1)\ntrace = df.values[:, 30:] # remove first 30 samples (1 ms) of waveform baseline","c6f8748c":"from sklearn.decomposition import PCA\n\nN_components = 10\nmypca = PCA(n_components=N_components)\nPC = mypca.fit(trace)\n\nfig, ax = plt.subplots(figsize=(4,2))\nx = np.arange(1, N_components+1, step=1)\ny = np.cumsum(mypca.explained_variance_ratio_)\n\n\nplt.plot(x, y, '-', color='gray', alpha = 0.4)\nplt.plot(x, y, 'o', color='k')\n\nplt.ylim(0.0,1.2)\n\nplt.xlabel('Principal components')\nplt.xticks(np.arange(0, 11, step=1)) #change from 0-based array index to 1-based human-readable label\nplt.ylabel('Cumulative variance')\n\nplt.axhline(y = 0.95, color = 'brown', linestyle = '--')\nplt.hlines(y = y[1], xmin = 0, xmax = 2, color = 'C0', linestyle = '--')\nplt.text(0.5, 1, '95% $\\sigma$', color = 'brown', fontsize=12)\nplt.text(0.5, y[1]+0.05, s=f'{y[1]*100:1.2f}%', color = 'C0', fontsize= 12)\nplt.show()","726ede5c":"mypca = PCA(n_components=2)\nPC = mypca.fit_transform(trace)\n\nwaveforms['PC1'] = PC[:,0]\nwaveforms['PC2'] = PC[:,1]\nvar1, var2 = mypca.explained_variance_ratio_*100 # variance in percentage\nprint('Explained variation by the two first principal components: {:2.2f}%, {:2.2f}%'.format(var1, var2))","e3c1ba5e":"# visualize\nfig, ax = plt.subplots(1,1, figsize=(4,4))\n\nax.scatter(x = waveforms.PC1, y = waveforms.PC2, s=4, c=waveforms.color)\nax.set_xlabel(f'PC$_1$ = {var1:2.1f} %');\nax.set_ylabel(f'PC$_2$ = {var2:2.1f} %');\nax.set_xlim(-3,3), ax.set_ylim(-3,3)\nax.set_yticks([-2,0,2]), ax.set_xticks([-2,0,2])\n\nmarkers = [plt.Line2D([],[], color= i, marker = 'o', linestyle = '') for i in mycolors.values()]\n\nax.legend(markers, mycolors.keys(), numpoints = 10,  title = 'Tissue', bbox_to_anchor=(1.05, 1), loc='upper left')","8cb4064a":"# visualize\n\n\n    \nfig, ax = plt.subplots(2,4, figsize=(8,4), sharex=True, sharey = True)\nfig.tight_layout()\nfig.suptitle('Tissues')\n\ndef plot_ax(organoidtype, loc=(0,0)):\n    \"\"\"\n    Auxiliary plot function to return subplot axis\n    of the two first PCA projections of a tissue.\n    \n    Argument:\n    organoidtype:  (str)\n        The type of tissue we want to plot\n    \n    loc: (list)\n        The x,y location of the axis object in the subplot\n    \"\"\"\n    x = waveforms[waveforms.organoid==organoidtype].PC1\n    y = waveforms[waveforms.organoid==organoidtype].PC2\n    \n    i,j = loc\n    return ax[i,j].scatter(x, y, color=mycolors[organoidtype], s = 5, label=organoidtype)\n\n\nplot_ax('DLX_Cheriff', loc=(0,0))\nplot_ax('DLX_bluered', loc=(1,0))\n\nplot_ax('TSCp5_30s', loc=(0,1))\nplot_ax('TSCp5_32s', loc=(1,1))\n\nplot_ax('TSCp5_30s_CHIR', loc=(0,2))\nplot_ax('TSCp5_32s_CHIR', loc=(1,2))\n\nplot_ax('AP_ctrl', loc=(0,3))\nplot_ax('AP_drug', loc=(1,3))\n\n\n#x = waveforms[waveforms.organoid=='DLX_H9'].PC1\n#y = waveforms[waveforms.organoid=='DLX_H9'].PC2\n#ax[0,1].scatter(x, y, color=mycolors['DLX_H9'], s = 5, label='DLX_H9')\n\n\nfor myax in ax.flatten():\n    myax.scatter(x = waveforms.PC1, y = waveforms.PC2, c='gray', s = 4, alpha = 0.2)\n    #myax.set_xlabel(f'PC$_1$ = {var1:2.1f} %');\n    #myax.set_ylabel(f'PC$_2$ = {var2:2.1f} %');\n    myax.legend(loc='upper center', fontsize=10, frameon=False)\n    myax.axis('off')","b4aa0fdf":"from sklearn.cluster import KMeans","01fbf75b":"inertia = list() # sum of squared error\n\nfor k in range(1,21):\n    km = KMeans(n_clusters=k, init='k-means++', random_state = 42)\n    km = km.fit(PC)\n    inertia.append(km.inertia_)","0d44c7f0":"idx = np.arange(1, len(inertia) + 1)\n\nfig, ax = plt.subplots(2, 1, figsize=(4,4), sharex=True)\n\nax[0].plot(idx, inertia, '-', color='gray', alpha = 0.4)\nax[0].plot(idx, inertia, 'ko', ms=6)\nax[0].set_xticks([1,2,3,4,5, 10, 15])\n\nax[0].set_ylabel('Inertia');\n\nacceleration = np.diff(np.sqrt(inertia), 2)  # 2nd derivative of the distances\n\nax[1].plot(idx[:-2] + 1, acceleration, 'g-', ms=8)\nax[1].set_ylabel('Acceleration')\nax[1].set_xlabel('K-clusters')\n#ax[1].set_yticks(np.arange(-1,7))\n\n# calculate clusters\n\nk = acceleration.argmax() + 2  # if idx 0 is the max of this we want 2 clusters\nax[0].vlines(x = k, ymin = 0, ymax = inertia[k-1], color='brown', linestyle='--')\nax[1].vlines(x = k, ymin = 0, ymax = acceleration[k-2], color='gray', linestyle='--', alpha=0.7)\n\nprint(f'Number of k-clusters:{k}')\n","fe9cc87d":"# define colors according to the cluster label\nmyKmeans = KMeans(n_clusters=3, init='k-means++', random_state = 42)\nmyKmeans.fit(PC)\nkcolors = pd.DataFrame(myKmeans.labels_, columns=['Ktype'])\n\nkcolors['color'] = kcolors['Ktype'].map({1: 'green', 0:'orange', 2:'purple'})\n","aca30758":"from scipy.spatial.distance import cdist\n\ndef plot_radii(mykmeans, X, ax = None):\n    \"\"\"\n    Plots k-centroids from a kmeans model\n    \n    Arguments\n    ---------\n    kmeans (Kmeans object)\n        (sklearn.sklearn.cluster.Kmeans model)\n    \n    X (2D-Numpy array)\n        The observations ith the observations)\n    \n    ax (an axis object)\n    \"\"\"\n    # plot the input data\n    ax = ax or plt.gca()\n    \n    labels = mykmeans.labels_ # read labels\n\n    centers = mykmeans.cluster_centers_ # centroids\n    radii = [cdist(X[labels == i], [center]).max() for i, center in enumerate(centers)]\n    \n    for c, r in zip(centers, radii):\n        ax.add_patch(plt.Circle(c, r, fc='gray', lw=1, alpha=0.05, zorder=1))","f704ee24":"fig, ax = plt.subplots(1,1, figsize=(4,4))\n\nax.scatter(x = waveforms.PC1, y = waveforms.PC2, s=4, c=kcolors.color)\nax.set_xlabel(f'PC$_1$ = {var1:2.1f} %');\nax.set_ylabel(f'PC$_2$ = {var2:2.1f} %');\nax.set_xlim(-3,3), ax.set_ylim(-3,3)\nax.set_yticks([-2,0,2]), ax.set_xticks([-2,0,2]);\nplot_radii(mykmeans = myKmeans, X = PC, ax = ax)","e4cedcbb":"# calculate percentages (just for fun with different NumPY methods :P)\nprop_0 = 100 * np.count_nonzero(myKmeans.labels_==0) \/ len (myKmeans.labels_)\nprop_1 = 100 * np.count_nonzero(myKmeans.labels_==1) \/ len (myKmeans.labels_)\nprop_2 = 100 * np.sum(myKmeans.labels_==2)           \/len(myKmeans.labels_)\n","68c453b5":"# visualize\n# To learn how to use multiple plots, use this https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/04.08-multiple-subplots.html\n\ngrid = plt.GridSpec(1, 5, wspace=0.4, hspace=0.4)\n\nfig = plt.figure(figsize=(12, 4))\npca_plot = fig.add_subplot(grid[0, 0:2])\n\npca_plot.scatter(x = waveforms.PC1, y = waveforms.PC2, s=4, c=kcolors.color)\npca_plot.set_xlabel(f'PC$_1$ = {var1:2.1f} %');\npca_plot.set_ylabel(f'PC$_2$ = {var2:2.1f} %');\npca_plot.set_yticks([-2,0,2]), ax.set_xticks([-2,0,2]);\npca_plot.set_xlim(-3,3), ax.set_ylim(-3,3)\nplot_radii(myKmeans, PC, ax = pca_plot)\n\nwave0 = fig.add_subplot(grid[0, 2])\nwave = list()\nidx = np.where(kcolors.Ktype==1)\nfor i in idx[0]:\n    mytrace = trace[i]\n    wave0.plot(mytrace, lw=0.5, color='green', alpha=0.05)\n    wave.append(mytrace)\nwave0.plot(np.mean(wave, axis=0), color='green')\nwave0.text(x = 0, y = .5, s = f'{prop_1:2.2f}%', color='green')\n\n\nwave1 = fig.add_subplot(grid[0, 3])\nwave = list()\nidx = np.where(kcolors.Ktype==0)\nfor i in idx[0]:\n    mytrace = trace[i]\n    wave1.plot(mytrace, lw=0.5, color='orange', alpha=0.05)\n    wave.append(mytrace)\nwave1.plot(np.mean(wave, axis=0), color='orange')\nwave1.text(x = 0, y = .5, s = f'{prop_0:2.2f}%', color='orange')\n\n\nwave2 = fig.add_subplot(grid[0, 4])\nwave = list()\nidx = np.where(kcolors.Ktype==2)\nfor i in idx[0]:\n    mytrace = trace[i]\n    wave2.plot(mytrace, lw=0.5, color='purple', alpha=0.05)\n    wave.append(mytrace)\nwave2.plot(np.mean(wave, axis=0), color='indigo')\nwave2.text(x = 0, y = .5, s = f'{prop_2:2.2f}%', color='indigo')\n\n\nwave2.text(x = 75, y= -1, s='1 ms', fontsize=10)\nwave2.hlines(y = -1.1, xmin =75, xmax = 105, lw=2, color='k') \n\n\nfor wave in [wave0,wave1,wave2]:\n    wave.set_ylim(-1.3,1.0)\n    wave.axis('off')","c2364edb":"from scipy.cluster.hierarchy import dendrogram, linkage","4eb7b08b":"Z = linkage(PC, method = 'ward')\n\npmax = Z[:,2].max()\nfig, ax = plt.subplots(1, 1, figsize = (12,3))\nd = dendrogram(Z, truncate_mode = 'lastp', p = 50, leaf_rotation = 90, leaf_font_size = 8, show_contracted = True, ax = ax)\nax.set_ylabel('Euclidean distances'), ax.set_xlabel('Spike Waveforms')\nax.set_yticks(np.arange(0,25,5))\nax.axhline(y = 0.7*pmax, color='k', linestyle= '--')\nax.text(y = 0.7*pmax +1, x = 10, s='70% of max. distance')\n","04c1051b":"distance = Z[-20:, 2] # get distances the latest 20 distances\nselection = distance[::-1]\nidx = np.arange(1, len(selection) + 1)\n\nfig, ax = plt.subplots(2, 1, figsize=(4,4), sharex=True)\nax[0].plot(idx, selection, '-', color='gray', alpha = 0.4)#ms=8)\nax[0].plot(idx, selection, 'ko', ms = 6)\nax[0].set_xticks([1,2,3,4,5, 10, 15])\n\n\nacceleration = np.diff(selection, 2)  # 2nd derivative of the distances\n\nax[1].plot(idx[:-2] + 1, acceleration, 'g-', ms=8)\nax[1].set_ylabel('Acceleration')\nax[1].set_xlabel('Clusters')\n#ax[1].set_yticks(np.arange(-1,7))\nax[0].set_ylabel('Distance')\n\nk = acceleration.argmax() + 2  # if idx 0 is the max of this we want 2 clusters\nax[0].vlines(x = k, ymin = 0, ymax = selection[k-1], color='brown', linestyle='--')\nax[1].vlines(x = k, ymin = np.min(acceleration), ymax = acceleration[k-2], color='gray', linestyle='--', alpha=0.7)\n\nprint(f'clusters:{k}')","c5c1fa73":"from scipy.cluster.hierarchy import fcluster","aea02ab3":"mylabels = fcluster(Z, 3, criterion='maxclust')-1 # zero based","18973016":"# calculate percentages (just for fun with different NumPY methods :P)\nprop_0 = 100 * np.sum(mylabels ==0) \/ len (mylabels)\nprop_1 = 100 * np.sum(mylabels ==1) \/ len (mylabels)\nprop_2 = 100 * np.sum(mylabels ==2) \/len(mylabels)\nprop_0, prop_1, prop_2\n","8a635812":"# adjust colors\ndcolors = pd.DataFrame(mylabels, columns=['Dtype'])\n\ndcolors['color'] = dcolors['Dtype'].map({0: 'green', 1:'orange', 2:'purple'})","9df986ae":"# visualize\n\ngrid = plt.GridSpec(1, 5, wspace=0.4, hspace=0.4)\n\nfig = plt.figure(figsize=(12, 4))\npca_plot = fig.add_subplot(grid[0, 0:2])\n\npca_plot.scatter(x = waveforms.PC1, y = waveforms.PC2, s=4, c=dcolors.color)\npca_plot.set_xlabel(f'PC$_1$ = {var1:2.1f} %');\npca_plot.set_ylabel(f'PC$_2$ = {var2:2.1f} %');\npca_plot.set_yticks([-2,0,2]), pca_plot.set_xticks([-2,0,2]);\npca_plot.set_xlim(-3,3), pca_plot.set_ylim(-3,3)\nplot_radii(myKmeans, PC, ax = pca_plot)\n\nwave0 = fig.add_subplot(grid[0, 2])\nwave = list()\nidx = np.where(mylabels==0)\nfor i in idx[0]:\n    mytrace = trace[i]\n    wave0.plot(mytrace, lw=0.5, color='green', alpha=0.05)\n    wave.append(mytrace)\nwave0.plot(np.mean(wave, axis=0), color='green')\nwave0.text(x = 0, y = .5, s = f'{prop_0:2.2f}%', color='green')\n\n\nwave1 = fig.add_subplot(grid[0, 3])\nwave = list()\nidx = np.where(mylabels==1)\nfor i in idx[0]:\n    mytrace = trace[i]\n    wave1.plot(mytrace, lw=0.5, color='orange', alpha=0.05)\n    wave.append(mytrace)\nwave1.plot(np.mean(wave, axis=0), color='orange')\nwave1.text(x = 0, y = .5, s = f'{prop_1:2.2f}%', color='orange')\n\n\nwave2 = fig.add_subplot(grid[0, 4])\nwave = list()\nidx = np.where(mylabels==2)\nfor i in idx[0]:\n    mytrace = trace[i]\n    wave2.plot(mytrace, lw=0.5, color='purple', alpha=0.05)\n    wave.append(mytrace)\nwave2.plot(np.mean(wave, axis=0), color='indigo')\nwave2.text(x = 0, y = .5, s = f'{prop_2:2.2f}%', color='indigo')\n\n\nwave2.text(x = 75, y= -1, s='1 ms', fontsize=10)\nwave2.hlines(y = -1.1, xmin =75, xmax = 105, lw=2, color='k') \n\n\nfor wave in [wave0,wave1,wave2]:\n    wave.set_ylim(-1.3,1.0)\n    wave.axis('off')","06f63d68":"<a id=\"section3\"><\/a>\n# 3. Visualize waveforms","e3b507ee":"\n\n# Cluster calculation\nTo determine the optimal number of clusters, we need to compute the cluster after which the distortion\/inertia start decreasing linearly.  The distortion or inertia of a K-Means clustering result is the sum of squared differences between an observation and it's corresponding centroid.\n\n**Inertia**: is the sum of squared errors. Thus, the inertia is the sum of squared euclidian distances for each point to its closed centroid.\n<math>\n$$ \\sum_{i = 1}^{n}{d(x_i, c_k)^2} ,$$\n<\/math>\n\nwhere $n$ is the number of points,  $c_k$ is the k-centroid, and $d()$ is the euclidian distance.\n\nTo detect the minimal number of clusters, we can compute the second derivative of the inertia.\n\n","08ded422":"<a id=\"section2\"><\/a>\n# 2. Loading the dataset\n\nThe dataset contains spike waveforms obtained from different neural tissues. In Neuroscience\/Electrophysiology, we tend to use the word samples similar as features in Machine Learning.","15d54e9f":"To identify waveforms from different tissues, we will use a color code from a python dictionary, called *mycolors*.","3700920d":"<a id=\"section5\"><\/a>\n# 5. Hierarchical clustering\n\nWe will plot the distances of merges during hierarchical clustering with a dendogram. Learn the details of this method in [this blog entry](https:\/\/joernhees.de\/blog\/2015\/08\/26\/scipy-hierarchical-clustering-and-dendrogram-tutorial\/)","2f83ca98":"<a id=\"section5.2\"><\/a>\n## 5.2 Visualization","0686e607":"# Table of Contents\n\n1. [Importing necesary libraries](#section1)\n2. [Loading the dataset](#section2)\n3. [Visualization waveforms](#section3)\n4. [Dimensionality reduction and K-means clustering](#section4)\n      * [4.1 Principal Components Analysis (PCA)](#section4.1)\n      * [4.2 K-means clustering](#section4.2)\n5. [Hierarchical clustering](#section5)\n      * [5.1 Elbow method](#section5.1)\n      * [5.2 Visualization](#section5.2)\n","777e3218":"Let's plot the first two projections for visualization","3c9f0ddf":"<a id=\"section1\"><\/a>\n# 1. Importing necessary libraries\n\nThe [Waveforms dataset](https:\/\/www.kaggle.com\/joseguzman\/waveforms) is freely availabe in Kaggle, but also [in GitHub](https:\/\/github.com\/JoseGuzman\/minibrain). I will use the GitHub link to have some custom plotting.","94215420":"<a id=\"section4\"><\/a>\n# 4 Dimensionality reduction and clustering\n\nEvery waveform (observation) contain 150 samples (or features). We want to reduce the number of measurements to a minimun necessary to perform a further classification (ideally to keep 95% of the variance).","95844724":"<a id=\"section4.1\"><\/a>\n## 4.1 Principal Components Analysis (PCA)","ccfa52e9":"We can use the 70% of maximal distance to detect clusters","68c0a64b":"We now calculate the percentage of waveforms in every cluster.","7cdeaa12":"We use scipy.spatial.distance.cdist compute distance between each pair of collections of inputs.","7f59d00f":"<a id=\"section4.2\"><\/a>\n## 4.2 K-means clustering\n\nWe now use the first two-principal components to perform an umbiassed K-means clustering. We will calculate the minimal number of clusters we need to perform an umbiassed classification.","183238b3":"<a id=\"section5.1\"><\/a>\n## 5.1 Elbow method ","86cbe8a6":"<CENTER><H1>Spike classification based on extracellular waveforms<\/H1><\/CENTER>\n\n<HR>   \n<img src=\"https:\/\/raw.githubusercontent.com\/JoseGuzman\/minibrain\/master\/img\/spikes.png\">\n\n<P>This notebook classifies different electrical waveforms from the brain called spikes. Spikes are electrical signals generated by neurons for communication. Different spike waveforms correspond to different cell types or different neuron morphologies.<\/P>\n\n","3d7b0e0a":"We add a column *color* in our Pandas DataFrame that includes the corresponding tissue color in RBG."}}