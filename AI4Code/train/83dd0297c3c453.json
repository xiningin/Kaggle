{"cell_type":{"f79a6219":"code","36ca42ef":"code","c1aae45a":"code","311f66af":"code","cea06d5a":"code","5a65971a":"code","a1e7331e":"code","2980317f":"code","e4a9cee7":"code","08e8cf61":"code","99490a19":"code","4f19edd4":"code","5d94b7e9":"code","abccfcae":"code","0b47e6c1":"code","49956e94":"code","daf30f15":"code","e48d0b59":"code","328e48d6":"code","7cbfe9d3":"code","d36d5ad4":"code","8a97cb7e":"code","7fd543db":"code","7fd13f51":"code","47ad5af1":"code","8fabbdd3":"code","d2219453":"code","1ed7e418":"code","4bcbe3c9":"code","50e4ae94":"code","74d9c43f":"code","bd1c2c2c":"code","d2df31e4":"code","a4ae049c":"code","ab21eaa1":"code","4961ed5b":"code","7525079f":"code","6ba8e17c":"code","064f8c28":"code","d3792c6c":"code","34b1c56c":"code","32a840f7":"code","167e3cf6":"code","e5b77c7b":"code","f47ae04a":"code","30737405":"code","59b2c1bb":"code","ad3fd120":"markdown","9cec97a0":"markdown","d1461dc7":"markdown","a1b7b269":"markdown","64012d14":"markdown","0f4ca886":"markdown","54d09456":"markdown","92b24b9c":"markdown","f07751fc":"markdown","90c5b98e":"markdown","c2ad5dc3":"markdown","b3409cab":"markdown","41a55fc2":"markdown","dfb6da21":"markdown","d5be79b0":"markdown","59b5aca4":"markdown","ba9064d3":"markdown","fa016114":"markdown","0120dbac":"markdown","edfd49af":"markdown","3bf958e4":"markdown","a5bd092d":"markdown","dce46378":"markdown","bfac228e":"markdown","12a8d562":"markdown","d65b6067":"markdown","47e863aa":"markdown","268e2a1b":"markdown","d9d7ae2d":"markdown","a77a5241":"markdown","0034d511":"markdown"},"source":{"f79a6219":"!pip install tweepy","36ca42ef":"import numpy as np # linear algebra\nimport pandas as pd # data processing\nimport os\nimport tweepy as tw #for accessing Twitter API\n\n\n#For Preprocessing\nimport re    # RegEx for removing non-letter characters\nimport nltk  #natural language processing\nnltk.download(\"stopwords\")\nfrom nltk.corpus import stopwords\nfrom nltk.stem.porter import *\n\n# For Building the model\nfrom sklearn.model_selection import train_test_split\nimport tensorflow as tf\nimport seaborn as sns\n\n#For data visualization\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n%matplotlib inline\n\npd.options.plotting.backend = \"plotly\"","c1aae45a":"# Load Tweet dataset\ndf1 = pd.read_csv('..\/input\/twitter-and-reddit-sentimental-analysis-dataset\/Twitter_Data.csv')\n# Output first five rows\ndf1.head()","311f66af":"# Load Tweet dataset\ndf2 = pd.read_csv('..\/input\/appletwittersentimenttexts\/apple-twitter-sentiment-texts.csv')\ndf2 = df2.rename(columns={'text': 'clean_text', 'sentiment':'category'})\ndf2['category'] = df2['category'].map({-1: -1.0, 0: 0.0, 1:1.0})\n# Output first five rows\n\ndf2.head()","cea06d5a":"# Load Tweet dataset\ndf3 = pd.read_csv('..\/input\/twitterdata\/finalSentimentdata2.csv')\ndf3 = df3.rename(columns={'text': 'clean_text', 'sentiment':'category'})\ndf3['category'] = df3['category'].map({'sad': -1.0, 'anger': -1.0, 'fear': -1.0, 'joy':1.0})\ndf3 = df3.drop(['Unnamed: 0'], axis=1)\n# Output first five rows\ndf3.head()","5a65971a":"# Load Tweet dataset\ndf4 = pd.read_csv('..\/input\/twitter-airline-sentiment\/Tweets.csv')\ndf4 = df4.rename(columns={'text': 'clean_text', 'airline_sentiment':'category'})\ndf4['category'] = df4['category'].map({'negative': -1.0, 'neutral': 0.0, 'positive':1.0})\ndf4 = df4[['category','clean_text']]\n# Output first five rows\ndf4.head()","a1e7331e":"df = pd.concat([df1, df2, df3, df4], ignore_index=True)","2980317f":"# Check for missing data\ndf.isnull().sum()","e4a9cee7":"# drop missing rows\ndf.dropna(axis=0, inplace=True)","08e8cf61":"# dimensionality of the data\ndf.shape","99490a19":"# Map tweet categories\ndf['category'] = df['category'].map({-1.0:'Negative', 0.0:'Neutral', 1.0:'Positive'})\n\n# Output first five rows\ndf.head()","4f19edd4":"# The distribution of sentiments\ndf.groupby('category').count().plot(kind='bar')","5d94b7e9":"# Calculate tweet lengths\ntweet_len = pd.Series([len(tweet.split()) for tweet in df['clean_text']])\n\n# The distribution of tweet text lengths\ntweet_len.plot(kind='box')","abccfcae":"fig = plt.figure(figsize=(14,7))\ndf['length'] = df.clean_text.str.split().apply(len)\nax1 = fig.add_subplot(122)\nsns.histplot(df[df['category']=='Positive']['length'], ax=ax1,color='green')\ndescribe = df.length[df.category=='Positive'].describe().to_frame().round(2)\n\nax2 = fig.add_subplot(121)\nax2.axis('off')\nfont_size = 14\nbbox = [0, 0, 1, 1]\ntable = ax2.table(cellText = describe.values, rowLabels = describe.index, bbox=bbox, colLabels=describe.columns)\ntable.set_fontsize(font_size)\nfig.suptitle('Distribution of text length for positive sentiment tweets.', fontsize=16)\n\nplt.show()","0b47e6c1":"fig = plt.figure(figsize=(14,7))\ndf['length'] = df.clean_text.str.split().apply(len)\nax1 = fig.add_subplot(122)\nsns.histplot(df[df['category']=='Negative']['length'], ax=ax1,color='red')\ndescribe = df.length[df.category=='Negative'].describe().to_frame().round(2)\n\nax2 = fig.add_subplot(121)\nax2.axis('off')\nfont_size = 14\nbbox = [0, 0, 1, 1]\ntable = ax2.table(cellText = describe.values, rowLabels = describe.index, bbox=bbox, colLabels=describe.columns)\ntable.set_fontsize(font_size)\nfig.suptitle('Distribution of text length for Negative sentiment tweets.', fontsize=16)\n\nplt.show()","49956e94":"import plotly.express as px\nfig = px.pie(df, names='category', title ='Pie chart of different sentiments of tweets')\nfig.show()","daf30f15":"df.drop(['length'], axis=1, inplace=True)\ndf.head","e48d0b59":"#### Visualizing data into wordclouds\n\n\nfrom wordcloud import WordCloud, STOPWORDS\n\ndef wordcount_gen(df, category):\n    '''\n    Generating Word Cloud\n    inputs:\n       - df: tweets dataset\n       - category: Positive\/Negative\/Neutral\n    '''\n    # Combine all tweets\n    combined_tweets = \" \".join([tweet for tweet in df[df.category==category]['clean_text']])\n                          \n    # Initialize wordcloud object\n    wc = WordCloud(background_color='white', \n                   max_words=50, \n                   stopwords = STOPWORDS)\n\n    # Generate and plot wordcloud\n    plt.figure(figsize=(10,10))\n    plt.imshow(wc.generate(combined_tweets))\n    plt.title('{} Sentiment Words'.format(category), fontsize=20)\n    plt.axis('off')\n    plt.show()\n    \n# Positive tweet words\nwordcount_gen(df, 'Positive')\n     \n# Negative tweet words\nwordcount_gen(df, 'Negative')\n     \n# Neutral tweet words\nwordcount_gen(df, 'Neutral')\n     \n","328e48d6":"def tweet_to_words(tweet):\n    ''' Convert tweet text into a sequence of words '''\n    \n    # convert to lowercase\n    text = tweet.lower()\n    # remove non letters\n    text = re.sub(r\"[^a-zA-Z0-9]\", \" \", text)\n    # tokenize\n    words = text.split()\n    # remove stopwords\n    words = [w for w in words if w not in stopwords.words(\"english\")]\n    # apply stemming\n    words = [PorterStemmer().stem(w) for w in words]\n    # return list\n    return words\n\nprint(\"\\nOriginal tweet ->\", df['clean_text'][0])\nprint(\"\\nProcessed tweet ->\", tweet_to_words(df['clean_text'][0]))","7cbfe9d3":"# Apply data processing to each tweet\nX = list(map(tweet_to_words, df['clean_text']))","d36d5ad4":"from sklearn.preprocessing import LabelEncoder\n\n# Encode target labels\nle = LabelEncoder()\nY = le.fit_transform(df['category'])","8a97cb7e":"print(X[0])\nprint(Y[0])","7fd543db":"y = pd.get_dummies(df['category'])\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.25, random_state=1)","7fd13f51":"from sklearn.feature_extraction.text import CountVectorizer\n#from sklearn.feature_extraction.text import TfidfVectorizer\n\nvocabulary_size = 5000\n\n# Tweets have already been preprocessed hence dummy function will be passed in \n# to preprocessor & tokenizer step\ncount_vector = CountVectorizer(max_features=vocabulary_size,\n#                               ngram_range=(1,2),    # unigram and bigram\n                                preprocessor=lambda x: x,\n                               tokenizer=lambda x: x) \n#tfidf_vector = TfidfVectorizer(lowercase=True, stop_words='english')\n\n# Fit the training data\nX_train = count_vector.fit_transform(X_train).toarray()\n\n# Transform testing data\nX_test = count_vector.transform(X_test).toarray()","47ad5af1":"#import sklearn.preprocessing as pr\n\n# Normalize BoW features in training and test set\n#X_train = pr.normalize(X_train, axis=1)\n#X_test  = pr.normalize(X_test, axis=1)","8fabbdd3":"# print first 200 words\/tokens\nprint(count_vector.get_feature_names()[0:200])","d2219453":"# Plot the BoW feature vector\nplt.plot(X_train[2,:])\nplt.xlabel('Word')\nplt.ylabel('Count')\nplt.show()","1ed7e418":"from keras.preprocessing.text import Tokenizer\nfrom keras.preprocessing.sequence import pad_sequences\n\nmax_words = 5000\nmax_len=50\n\ndef tokenize_pad_sequences(text):\n    '''\n    This function tokenize the input text into sequnences of intergers and then\n    pad each sequence to the same length\n    '''\n    # Text tokenization\n    tokenizer = Tokenizer(num_words=max_words, lower=True, split=' ')\n    tokenizer.fit_on_texts(text)\n    # Transforms text to a sequence of integers\n    X = tokenizer.texts_to_sequences(text)\n    # Pad sequences to the same length\n    X = pad_sequences(X, padding='post', maxlen=max_len)\n    # return sequences\n    return X, tokenizer\n\nprint('Before Tokenization & Padding \\n', df['clean_text'][0])\nX, tokenizer = tokenize_pad_sequences(df['clean_text'])\nprint('After Tokenization & Padding \\n', X[0])","4bcbe3c9":"import pickle\n\n# saving\nwith open('tokenizer.pickle', 'wb') as handle:\n    pickle.dump(tokenizer, handle, protocol=pickle.HIGHEST_PROTOCOL)\n\n# loading\nwith open('tokenizer.pickle', 'rb') as handle:\n    tokenizer = pickle.load(handle)","50e4ae94":"y = pd.get_dummies(df['category'])\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.25, random_state=1)\nprint('Train Set ->', X_train.shape, y_train.shape)\nprint('Validation Set ->', X_val.shape, y_val.shape)\nprint('Test Set ->', X_test.shape, y_test.shape)","74d9c43f":"import keras.backend as K\n\ndef f1_score(precision, recall):\n    ''' Function to calculate f1 score '''\n    \n    f1_val = 2*(precision*recall)\/(precision+recall+K.epsilon())\n    return f1_val","bd1c2c2c":"from keras.models import Sequential\nfrom keras.layers import Embedding, Conv1D, MaxPooling1D, Bidirectional, LSTM, Dense, Dropout\nfrom keras.metrics import Precision, Recall\nfrom keras.optimizers import SGD\nfrom keras.optimizers import RMSprop\nfrom keras import datasets\n\nfrom keras.callbacks import LearningRateScheduler\nfrom keras.callbacks import History\n\nfrom keras import losses\n\nvocab_size = 5000\nembedding_size = 32\nepochs=20\nlearning_rate = 0.1\ndecay_rate = learning_rate \/ epochs\nmomentum = 0.8\n\nsgd = SGD(lr=learning_rate, momentum=momentum, decay=decay_rate, nesterov=False)\n# Build model\nmodel= Sequential()\nmodel.add(Embedding(vocab_size, embedding_size, input_length=max_len))\nmodel.add(Conv1D(filters=32, kernel_size=3, padding='same', activation='relu'))\nmodel.add(MaxPooling1D(pool_size=2))\nmodel.add(Bidirectional(LSTM(32)))\nmodel.add(Dropout(0.4))\nmodel.add(Dense(3, activation='softmax'))","d2df31e4":"import tensorflow as tf\ntf.keras.utils.plot_model(model, show_shapes=True)","a4ae049c":"print(model.summary())\n\n# Compile model\nmodel.compile(loss='categorical_crossentropy', optimizer=sgd, \n               metrics=['accuracy', Precision(), Recall()])\n\n# Train model\n\nbatch_size = 64\nhistory = model.fit(X_train, y_train,\n                      validation_data=(X_val, y_val),\n                      batch_size=batch_size, epochs=epochs, verbose=1)","ab21eaa1":"# Evaluate model on the test set\nloss, accuracy, precision, recall = model.evaluate(X_test, y_test, verbose=0)\n# Print metrics\nprint('')\nprint('Accuracy  : {:.4f}'.format(accuracy))\nprint('Precision : {:.4f}'.format(precision))\nprint('Recall    : {:.4f}'.format(recall))\nprint('F1 Score  : {:.4f}'.format(f1_score(precision, recall)))","4961ed5b":"def plot_training_hist(history):\n    '''Function to plot history for accuracy and loss'''\n    \n    fig, ax = plt.subplots(1, 2, figsize=(10,4))\n    # first plot\n    ax[0].plot(history.history['accuracy'])\n    ax[0].plot(history.history['val_accuracy'])\n    ax[0].set_title('Model Accuracy')\n    ax[0].set_xlabel('epoch')\n    ax[0].set_ylabel('accuracy')\n    ax[0].legend(['train', 'validation'], loc='best')\n    # second plot\n    ax[1].plot(history.history['loss'])\n    ax[1].plot(history.history['val_loss'])\n    ax[1].set_title('Model Loss')\n    ax[1].set_xlabel('epoch')\n    ax[1].set_ylabel('loss')\n    ax[1].legend(['train', 'validation'], loc='best')\n    \nplot_training_hist(history)","7525079f":"from sklearn.metrics import confusion_matrix\n\ndef plot_confusion_matrix(model, X_test, y_test):\n    '''Function to plot confusion matrix for the passed model and the data'''\n    \n    sentiment_classes = ['Negative', 'Neutral', 'Positive']\n    # use model to do the prediction\n    y_pred = model.predict(X_test)\n    # compute confusion matrix\n    cm = confusion_matrix(np.argmax(np.array(y_test),axis=1), np.argmax(y_pred, axis=1))\n    # plot confusion matrix\n    plt.figure(figsize=(8,6))\n    sns.heatmap(cm, cmap=plt.cm.Blues, annot=True, fmt='d', \n                xticklabels=sentiment_classes,\n                yticklabels=sentiment_classes)\n    plt.title('Confusion matrix', fontsize=16)\n    plt.xlabel('Actual label', fontsize=12)\n    plt.ylabel('Predicted label', fontsize=12)\n    \nplot_confusion_matrix(model, X_test, y_test)","6ba8e17c":"# Save the model architecture & the weights\nmodel.save('best_model.h5')\nprint('Best model saved')","064f8c28":"from keras.models import load_model\n\n# Load model\nmodel = load_model('best_model.h5')\n\ndef predict_class(text):\n    '''Function to predict sentiment class of the passed text'''\n    \n    sentiment_classes = ['Negative', 'Neutral', 'Positive']\n    max_len=50\n    \n    # Transforms text to a sequence of integers using a tokenizer object\n    xt = tokenizer.texts_to_sequences(text)\n    # Pad sequences to the same length\n    xt = pad_sequences(xt, padding='post', maxlen=max_len)\n    # Do the prediction using the loaded model\n    yt = model.predict(xt).argmax(axis=1)\n    # Print the predicted sentiment\n    print('The predicted sentiment is', sentiment_classes[yt[0]])","d3792c6c":"predict_class(['\"I hate when I have to call and wake people up'])","34b1c56c":"predict_class(['The food was meh'])","32a840f7":"predict_class(['He is a best minister india ever had seen'])","167e3cf6":"#Getting authorization\nconsumer_key= 'yourkeyhere'\nconsumer_secret= 'yourkeyhere'\naccess_token= 'yourkeyhere'\naccess_token_secret= 'yourkeyhere'\n\nauth = tw.OAuthHandler(consumer_key, consumer_key_secret)\nauth.set_access_token(access_token, access_token_secret)\napi = tw.API(auth, wait_on_rate_limit=True)","e5b77c7b":"# Define the search term and the date_since date as variables\nsearch_words = \"#WorkFromHome\"\ndate_since = \"2021-06-10\"","f47ae04a":"# Collect tweets\ntweets = tw.Cursor(api.search,\n              q=search_words,\n              lang=\"en\",\n              since=date_since).items(10)\n\n# Iterate and print tweets\nfor tweet in tweets:\n    print(tweet.text)\n    predict_class([tweet.text]) #predicting sentiment\n    print(\"\")","30737405":"for tweet in api.search(q=\"elonmusk\", lang=\"en\", rpp=10):\n    print(f\"{tweet.user.name}:{tweet.text}\")\n    predict_class([tweet.text]) #predicting sentiment\n    print(\"\")","59b2c1bb":"posts = api.user_timeline(screen_name=\"elonmusk\", count = 10, lang =\"en\", tweet_mode=\"extended\")\n\nl=[] \ni=1\n\nfor tweet in posts[:10]:\n    l.append(tweet.full_text) \n    i=i+1\nfor j in range (0,9):\n    print(l[j])\n    predict_class([l[j]])  #predicting sentiment\n    print(\"\\n\")","ad3fd120":"### Model Confusion Matrix","9cec97a0":"Plotting the Pie chart of the percentage of different sentiments of all the tweets","d1461dc7":"### 3. Searching for a username\n\nThe `user_timeline()` method of the API class in Tweepy module is used to get the most recent statuses posted from the authenticating user or the user specified.\n\n* `screen_name` = user id name of the twitter user\n* `count` = no. of tweets to be fetched\n* `lang` = language of tweet \n* `tweet_mode = 'extended'` swaps the text index for full_text, and prevents a primary tweet longer than 140 characters from being truncated.\n\n\nThe below query pulls 10 tweets from Twitter user @ of english language and predicts its sentiments.","a1b7b269":"## Overview \n\nThis script performs EDA and then preprocesses multiple datasets to train a bidirectional LSTM model which is in turn used to predict the sentiments behind tweets fetched in real time using `tweepy` and classify them as positive negative or neutral.\n\nThe model is then integrated with streamlit and deployed as a web-app.\n\n**Checkout the web-app:** [Sententia](https:\/\/share.streamlit.io\/kritanjalijain\/twitter_sentiment_analysis\/main\/app.py)","64012d14":"## Bidirectional LSTM Using NN","0f4ca886":"Data Visualisation-","54d09456":"### Model save and load for the prediction","92b24b9c":"### Bag of words (BOW) feature extraction","f07751fc":"To use the 'tweepy' API, you need to create an account with Twitter Developer. After creating the account, go to 'Get Started' option and navigate to the 'Create an app' option. After you create the app, note down the below required credentials from there.","90c5b98e":"### 1. Searching for a hashtag from a specified date\n\nNow you are ready to search Twitter for recent tweets! You will use the `.Cursor` method to get an object containing tweets containing the hashtag #wildfires.\n\nTo create this query, you will define the:\n\n   * Search term - in this case #WorkFromHome\n   * the start date of your search","c2ad5dc3":"### Train & Test Split","b3409cab":"The `category` column has 3 values:\n1. 0 Indicating it is a Neutral Sentiment\n2. 1 Indicating a Postive Sentiment\n3. -1 Indicating a Negative Sentiment","41a55fc2":"### 2. Searching for a keyword\n\nYou can pass the keyword of your interest here and the number of tweets (in this case 10) to be downloaded through the tweepy API.","dfb6da21":"### Cleaning and prepping dataset","d5be79b0":"Plotting the distribution of tweet lengths","59b5aca4":"## Exploratory Data Analysis","ba9064d3":"## Data Preprocessing","fa016114":"### Tokenizing & Padding","0120dbac":"## Exploratory Data Analysis","edfd49af":"### Saving tokenized data","3bf958e4":"## Installing and importing dependencies","a5bd092d":"Plotting the Distribution of text length for Negative sentiment tweets.","dce46378":"You can restrict the number of tweets returned by specifying a number in the `.items()` method. `.items(10)` will return 10 of the most recent tweets.","bfac228e":"To fetch tweets from twitter, we need to install the tweepy library. We will be using this package to pull tweets on which our model will make predictions.","12a8d562":"After installing and importing `tweepy` package (already done in the beginning),to access the Twitter API, you will need 4 things from the your Twitter App page. These keys are located in your Twitter app settings in the Keys and Access Tokens tab.\n\n    consumer key\n    consumer seceret key\n    access token key\n    access token secret key\n\nDo not share these with anyone else because these values are specific to your app.","d65b6067":"### Authorization","47e863aa":"## Fetching data from twitter\n\nTo get started, you\u2019ll need to do the following things:\n\n  * Set up a Twitter account if you don\u2019t have one already.\n  * Using your Twitter account, you will need to apply for Developer Access and then create an application that will generate the API credentials that you will use to access Twitter from Python.\n  *  Import the `tweepy` package.","268e2a1b":"Plotting the distribution of text length for positive sentiment tweets","d9d7ae2d":"### Train and test split","a77a5241":"## Search Twitter for Tweets","0034d511":"### Model Accuracy & Loss"}}