{"cell_type":{"a4850dec":"code","e17ed498":"code","2241bcdd":"code","fb18d226":"markdown","83445852":"markdown"},"source":{"a4850dec":"import math\nimport random\nimport numpy as np\nimport pandas as pd\nfrom math import exp\nfrom copy import deepcopy\nfrom matplotlib import pyplot as plt\nplt.style.use('ggplot')\n\n# veriseti dahil etme\ndata_frame = pd.read_csv('..\/input\/testverim\/xclara.csv',index_col=False)\ncols = [1,2]\ndata = data_frame[data_frame.columns[cols]]\n\nlen_data_points = data.shape[0]\nprint(\"Number of data points : {}\".format(len_data_points))\n\nmax_list = []\nmin_list = []\n\nv1_max = data['V1'].max()\nv1_min = data['V1'].min()\nv2_max = data['V2'].max()\nv2_min = data['V2'].min()\n\nmax_list.append(v1_max)\nmax_list.append(v2_max)\nmin_list.append(v1_min)\nmin_list.append(v2_min)\n\nprint(\"v1 max : {}, v1 min : {}, v2 max : {}, v2 min : {}\".format(v1_max,v1_min,v2_max,v2_min))\n\nv1_values = data['V1'].values\nv2_values = data['V2'].values\nX = np.array(list(zip(v1_values, v2_values)))\n# noktalar\u0131n g\u00f6rselle\u015ftirilmesi\nplt.scatter(v1_values, v2_values, c = 'black', s = 7)\nplt.show()\n\nmax_generation = 10 # iterasyon, nesil say\u0131s\u0131\nk = 3 # k\u00fcme say\u0131s\u0131\n\n# atesb\u00f6cegi matrisi olusturma\nfirefly_swarm_size= 5\nfirefly_swarm_matrice = np.zeros((firefly_swarm_size,k,2), dtype=np.float64)\n\nfor i in range(firefly_swarm_size):\n    centroid_x_location_list = np.random.randint(0, 200, size=k)\n    centroid_y_location_list = np.random.randint(0, 200, size=k)\n    Y = np.array(list(zip(centroid_x_location_list, centroid_y_location_list)), dtype=np.float32)\n    firefly_swarm_matrice[i] = Y\n\nprint(\"Ba\u015flang\u0131\u00e7 Ate\u015fb\u00f6ce\u011fi Matrisi : \" + \"\\n\",firefly_swarm_matrice)\n\n# objektif fonksiyon hesab\u0131\nJ = np.zeros((firefly_swarm_size), dtype=np.float64)\n\ndef cal_objective(num):\n    arr = np.ones((len_data_points, k), dtype=np.float64)\n    for j in range(len_data_points):\n        for i in range(k):\n            try:\n              dis = math.sqrt(((float(X[j][0] )- firefly_swarm_matrice[num][i][0]) ** 2) + ((float(X[j][1]) - firefly_swarm_matrice[num][i][1]) ** 2))\n              arr[j][i] = dis\n            except ValueError:\n                continue\n    # en yak\u0131n mesafeler k\u00fcmesi\n    min_dist_cluster_0 = np.ones((len_data_points), dtype=np.float64)\n\n    for j in range(len_data_points):\n        min = 0\n        val=0\n        for i in range(k):\n            if arr[j][i] < arr[j][min]:\n                    val = arr[j][i]\n                    min = i\n\n        min_dist_cluster_0[j] = val\n    sum=0\n    for i in range(len_data_points):\n        sum=sum+min_dist_cluster_0[i]\n\n    J[num]=math.sqrt(sum)\n    return J[num]\n\nfor i in range(firefly_swarm_size):\n    J[i]=cal_objective(i)\n\nprint(J)\n# atesbocegi parametreleri\nalpha = 0.5\nbeta = 0\nbeta_0 = 1\ngamma = 1\n\n# en iyi atesb\u00f6cegi optimizasyonunu bul\nobj=[]\nfor gen in range(max_generation):\n    for i in range(5):\n        scale = abs((max_list[0] - min_list[0])+(max_list[1]-max_list[1]))\n        for j in range(5):\n            if(J[i]>J[j]):\n                r=0\n                for l in range(k):\n                    r=r+(firefly_swarm_matrice[i][l][0] - firefly_swarm_matrice[j][l][0]) + (firefly_swarm_matrice[i][l][1] - firefly_swarm_matrice[j][l][1])\n                r = abs(r)\n                r = math.sqrt(r)\n                betamin=0.2\n                gamma=1.0\n                beta0 = 1.0\n                beta = (beta0 - betamin) * \\\n                       math.exp(-gamma * math.pow(r, 2.0)) + betamin\n                beta = beta_0 * (exp(-gamma) * (r** 2))\n                for l in range(k):\n                    r = random.uniform(0, 1)\n                    tmpf = alpha * (r - 0.5) * scale\n                    firefly_swarm_matrice[i][l][0] = firefly_swarm_matrice[i][l][0] * (1.0 - beta) +firefly_swarm_matrice[j][l][0] * beta + tmpf\n                    firefly_swarm_matrice[i][l][1] = firefly_swarm_matrice[i][l][1] * (1.0 - beta) + firefly_swarm_matrice[j][l][1] * beta + tmpf\n\n            temp = np.zeros((k, 2), dtype=np.float64)\n            temp = firefly_swarm_matrice[i]\n            for l in range(k):\n                for s in range(2):\n                    if temp[l][s] < min_list[s]:\n                        temp[l][s] = random.uniform(min_list[s],max_list[s])\n\n                    if temp[l][s] > max_list[s]:\n                        temp[l][s] = random.uniform(min_list[s],max_list[s])\n\n\n            firefly_swarm_matrice[i] = temp\n            arr = np.zeros((len_data_points, k), dtype=np.float64)\n            for n in range(len_data_points):\n                for m in range(k):\n                    try:\n\n                        dis = math.sqrt(((float(X[n][0]) - firefly_swarm_matrice[i][m][0]) ** 2) + ((float(X[n][1]) - firefly_swarm_matrice[i][m][1]) ** 2))\n                        arr[n][m] = dis\n                    except ValueError:\n                        continue\n            min_dist_clus = np.zeros((len_data_points), dtype=np.float64)\n            for n in range(len_data_points):\n                min = 0\n                val=0\n                for m in range(k):\n                    if arr[n][m] < arr[n][min]:\n                            val = arr[n][m]\n                            min= m\n\n                min_dist_clus[n] = val\n\n            sum = 0\n            for n in range(len_data_points):\n                sum = sum + min_dist_clus[n]\n            J[i]= math.sqrt(sum)\n\n    obj.append(np.amin(J))\n    for i in range(1,5):\n        if(J[i-1]<J[i]):\n            best=i\n\nprint(\"En iyi ate\u015f b\u00f6ce\u011fi matrisi : \" + \"\\n\",firefly_swarm_matrice[best])\n\n# \u00f6klid mesafe hesaplama\ndef dist(v1_max, v1_min, ax=1):\n    return np.linalg.norm(v1_max - v1_min, axis=ax)\n\n# k means k\u0131sm\u0131\n\n# Centroid de\u011fer tan\u0131mlanmas\u0131\ncentroid_values = firefly_swarm_matrice[best]\nprint(\"Ba\u015flang\u0131\u00e7 Centroid De\u011ferleri : \" + \"\\n\",centroid_values)\ncentroid_x_location_list = []\ncentroid_y_location_list = []\n\nfor i in range(k):\n    centroid_x_location_list.append(centroid_values[i][0])\n    centroid_y_location_list.append(centroid_values[i][1])\n\n# g\u00fcncellenen de\u011ferleri saklamak i\u00e7in\nC_old = np.zeros(centroid_values.shape)\n# k\u00fcmeler\nclusters = np.zeros(len(X))\n\n# hata fonksiyonu eski centroidler ve yeni centroidler\nerror = dist(centroid_values, C_old, None)\n\n# D\u00f6ng\u00fc hata s\u0131f\u0131r olana kadar \u00e7al\u0131\u015facakt\u0131r\nk_obj=[]\nx_axis=[]\nx_val=[]\nval=200\ncount=0\nwhile error != 0:\n    x_axis.append(count)\n    x_val.append(val)\n    count += 1\n    val+=1\n\n    arr = np.ones((len_data_points, k), dtype=np.float64)\n    for j in range(len_data_points):\n        for i in range(k):\n            try:\n                dis = math.sqrt(((float(X[j][0]) - centroid_values[i][0]) ** 2) + ((float(X[j][1]) - centroid_values[i][1]) ** 2))\n                arr[j][i] = dis\n            except ValueError:\n                continue\n\n    min_dist_cluster_0 = np.ones((len_data_points), dtype=np.float64)  # en yak\u0131n k\u00fcme mesafesini hesaplar.\n    for j in range(len_data_points):\n        min = 0\n        val = 0\n        for i in range(k):\n            if arr[j][i] < arr[j][min]:\n                val = arr[j][i]\n                min = i\n\n        min_dist_cluster_0[j] = val\n\n    sum = 0\n    for i in range(len_data_points):\n        sum = sum + min_dist_cluster_0[i]\n\n    J= math.sqrt(sum)\n    obj.append(J)\n    # de\u011ferleri en yak\u0131n k\u00fcmeye ata\n    for i in range(len(X)):\n        distances = dist(X[i], centroid_values)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n\n    # eski centroid verilerini depola.\n    C_old = deepcopy(centroid_values)\n\n    # ortalama de\u011ferleri bularak yeni centroidleri bul\n    for i in range(k):\n        points = [X[j] for j in range(len(X)) if clusters[j] == i]\n        centroid_values[i] = np.mean(points, axis=0)\n    error = dist(centroid_values, C_old, None)\nprint (centroid_values)\n\n# kmeans k\u00fcmelemesinde, en merkez noktalar\u0131n ate\u015fb\u00f6ce\u011fi centroid verileri ile bulunmas\u0131\ncolors = ['r', 'g', 'b', 'y', 'c', 'm']\nfig, ax = plt.subplots()\nfor i in range(k):\n        points = np.array([X[j] for j in range(len(X)) if clusters[j] == i])\n        ax.scatter(points[:, 0], points[:, 1], s=7, c=colors[i])\nax.scatter(centroid_values[:, 0], centroid_values[:, 1], marker='*', s=200, c='#050505')\nplt.show()","e17ed498":"import math\nimport random\nimport numpy as np\nimport pandas as pd\nfrom math import exp\nfrom copy import deepcopy\nfrom matplotlib import pyplot as plt\nplt.style.use('ggplot')\n\n# veriseti dahil etme\ndata_frame = pd.read_csv('..\/input\/testverim\/xclara.csv',index_col=False)\ncols = [1,2]\ndata = data_frame[data_frame.columns[cols]]\n\nlen_data_points = data.shape[0]\nprint(\"Number of data points : {}\".format(len_data_points))\n\nmax_list = []\nmin_list = []\n\nv1_max = data['V1'].max()\nv1_min = data['V1'].min()\nv2_max = data['V2'].max()\nv2_min = data['V2'].min()\n\nmax_list.append(v1_max)\nmax_list.append(v2_max)\nmin_list.append(v1_min)\nmin_list.append(v2_min)\n\nprint(\"v1 max : {}, v1 min : {}, v2 max : {}, v2 min : {}\".format(v1_max,v1_min,v2_max,v2_min))\n\nv1_values = data['V1'].values\nv2_values = data['V2'].values\nX = np.array(list(zip(v1_values, v2_values)))\n# noktalar\u0131n g\u00f6rselle\u015ftirilmesi\nplt.scatter(v1_values, v2_values, c = 'black', s = 7)\nplt.show()\n\nmax_generation = 10 # iterasyon, nesil say\u0131s\u0131\nk = 3 # k\u00fcme say\u0131s\u0131\n\n# atesb\u00f6cegi matrisi olusturma\nfirefly_swarm_size= 5\nfirefly_swarm_matrice = np.zeros((firefly_swarm_size,k,2), dtype=np.float64)\n\nfor i in range(firefly_swarm_size):\n    centroid_x_location_list = np.random.randint(0, 200, size=k)\n    centroid_y_location_list = np.random.randint(0, 200, size=k)\n    Y = np.array(list(zip(centroid_x_location_list, centroid_y_location_list)), dtype=np.float32)\n    firefly_swarm_matrice[i] = Y\n\nprint(\"Ba\u015flang\u0131\u00e7 Ate\u015fb\u00f6ce\u011fi Matrisi : \" + \"\\n\",firefly_swarm_matrice)\n\n# objektif fonksiyon hesab\u0131\nJ = np.zeros((firefly_swarm_size), dtype=np.float64)\n\ndef cal_objective(num):\n    arr = np.ones((len_data_points, k), dtype=np.float64)\n    for j in range(len_data_points):\n        for i in range(k):\n            try:\n              dis = math.sqrt(((float(X[j][0] )- firefly_swarm_matrice[num][i][0]) ** 2) + ((float(X[j][1]) - firefly_swarm_matrice[num][i][1]) ** 2))\n              arr[j][i] = dis\n            except ValueError:\n                continue\n    # en yak\u0131n mesafeler k\u00fcmesi\n    min_dist_cluster_0 = np.ones((len_data_points), dtype=np.float64)\n\n    for j in range(len_data_points):\n        min = 0\n        val=0\n        for i in range(k):\n            if arr[j][i] < arr[j][min]:\n                    val = arr[j][i]\n                    min = i\n\n        min_dist_cluster_0[j] = val\n    sum=0\n    for i in range(len_data_points):\n        sum=sum+min_dist_cluster_0[i]\n\n    J[num]=math.sqrt(sum)\n    return J[num]\n\nfor i in range(firefly_swarm_size):\n    J[i]=cal_objective(i)\n\nprint(J)\n# atesbocegi parametreleri\nalpha = 0.5\nbeta = 0\nbeta_0 = 1\ngamma = 1\n\n# en iyi atesb\u00f6cegi optimizasyonunu bul\nobj=[]\nfor gen in range(max_generation):\n    for i in range(5):\n        scale = abs((max_list[0] - min_list[0])+(max_list[1]-max_list[1]))\n        for j in range(5):\n            if(J[i]>J[j]):\n                r=0\n                for l in range(k):\n                    r=r+(firefly_swarm_matrice[i][l][0] - firefly_swarm_matrice[j][l][0]) + (firefly_swarm_matrice[i][l][1] - firefly_swarm_matrice[j][l][1])\n                r = abs(r)\n                r = math.sqrt(r)\n                betamin=0.2\n                gamma=1.0\n                beta0 = 1.0\n                beta = (beta0 - betamin) * \\\n                       math.exp(-gamma * math.pow(r, 2.0)) + betamin\n                beta = beta_0 * (exp(-gamma) * (r** 2))\n                for l in range(k):\n                    r = random.uniform(0, 1)\n                    tmpf = alpha * (r - 0.5) * scale\n                    firefly_swarm_matrice[i][l][0] = firefly_swarm_matrice[i][l][0] * (1.0 - beta) +firefly_swarm_matrice[j][l][0] * beta + tmpf\n                    firefly_swarm_matrice[i][l][1] = firefly_swarm_matrice[i][l][1] * (1.0 - beta) + firefly_swarm_matrice[j][l][1] * beta + tmpf\n\n            temp = np.zeros((k, 2), dtype=np.float64)\n            temp = firefly_swarm_matrice[i]\n            for l in range(k):\n                for s in range(2):\n                    if temp[l][s] < min_list[s]:\n                        temp[l][s] = random.uniform(min_list[s],max_list[s])\n\n                    if temp[l][s] > max_list[s]:\n                        temp[l][s] = random.uniform(min_list[s],max_list[s])\n\n\n            firefly_swarm_matrice[i] = temp\n            arr = np.zeros((len_data_points, k), dtype=np.float64)\n            for n in range(len_data_points):\n                for m in range(k):\n                    try:\n\n                        dis = math.sqrt(((float(X[n][0]) - firefly_swarm_matrice[i][m][0]) ** 2) + ((float(X[n][1]) - firefly_swarm_matrice[i][m][1]) ** 2))\n                        arr[n][m] = dis\n                    except ValueError:\n                        continue\n            min_dist_clus = np.zeros((len_data_points), dtype=np.float64)\n            for n in range(len_data_points):\n                min = 0\n                val=0\n                for m in range(k):\n                    if arr[n][m] < arr[n][min]:\n                            val = arr[n][m]\n                            min= m\n\n                min_dist_clus[n] = val\n\n            sum = 0\n            for n in range(len_data_points):\n                sum = sum + min_dist_clus[n]\n            J[i]= math.sqrt(sum)\n\n    obj.append(np.amin(J))\n    for i in range(1,5):\n        if(J[i-1]<J[i]):\n            best=i\n\nprint(\"En iyi ate\u015f b\u00f6ce\u011fi matrisi : \" + \"\\n\",firefly_swarm_matrice[best])\n\n# \u00f6klid mesafe hesaplama\ndef dist(v1_max, v1_min, ax=1):\n    return np.linalg.norm(v1_max - v1_min, axis=ax)\n\n# k means k\u0131sm\u0131\n\n# Centroid de\u011fer tan\u0131mlanmas\u0131\ncentroid_values = firefly_swarm_matrice[best]\nprint(\"Ba\u015flang\u0131\u00e7 Centroid De\u011ferleri : \" + \"\\n\",centroid_values)\ncentroid_x_location_list = []\ncentroid_y_location_list = []\n\nfor i in range(k):\n    centroid_x_location_list.append(centroid_values[i][0])\n    centroid_y_location_list.append(centroid_values[i][1])\n\n# g\u00fcncellenen de\u011ferleri saklamak i\u00e7in\nC_old = np.zeros(centroid_values.shape)\n# k\u00fcmeler\nclusters = np.zeros(len(X))\n\n# hata fonksiyonu eski centroidler ve yeni centroidler\nerror = dist(centroid_values, C_old, None)\n\n# D\u00f6ng\u00fc hata s\u0131f\u0131r olana kadar \u00e7al\u0131\u015facakt\u0131r\nk_obj=[]\nx_axis=[]\nx_val=[]\nval=200\ncount=0\nwhile error != 0:\n    x_axis.append(count)\n    x_val.append(val)\n    count += 1\n    val+=1\n\n    arr = np.ones((len_data_points, k), dtype=np.float64)\n    for j in range(len_data_points):\n        for i in range(k):\n            try:\n                dis = math.sqrt(((float(X[j][0]) - centroid_values[i][0]) ** 2) + ((float(X[j][1]) - centroid_values[i][1]) ** 2))\n                arr[j][i] = dis\n            except ValueError:\n                continue\n\n    min_dist_cluster_0 = np.ones((len_data_points), dtype=np.float64)  # en yak\u0131n k\u00fcme mesafesini hesaplar.\n    for j in range(len_data_points):\n        min = 0\n        val = 0\n        for i in range(k):\n            if arr[j][i] < arr[j][min]:\n                val = arr[j][i]\n                min = i\n\n        min_dist_cluster_0[j] = val\n\n    sum = 0\n    for i in range(len_data_points):\n        sum = sum + min_dist_cluster_0[i]\n\n    J= math.sqrt(sum)\n    obj.append(J)\n    # de\u011ferleri en yak\u0131n k\u00fcmeye ata\n    for i in range(len(X)):\n        distances = dist(X[i], centroid_values)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n\n    # eski centroid verilerini depola.\n    C_old = deepcopy(centroid_values)\n\n    # ortalama de\u011ferleri bularak yeni centroidleri bul\n    for i in range(k):\n        points = [X[j] for j in range(len(X)) if clusters[j] == i]\n        centroid_values[i] = np.mean(points, axis=0)\n    error = dist(centroid_values, C_old, None)\nprint (centroid_values)\n\n# kmeans k\u00fcmelemesinde, en merkez noktalar\u0131n ate\u015fb\u00f6ce\u011fi centroid verileri ile bulunmas\u0131\ncolors = ['r', 'g', 'b', 'y', 'c', 'm']\nfig, ax = plt.subplots()\nfor i in range(k):\n        points = np.array([X[j] for j in range(len(X)) if clusters[j] == i])\n        ax.scatter(points[:, 0], points[:, 1], s=7, c=colors[i])\nax.scatter(centroid_values[:, 0], centroid_values[:, 1], marker='*', s=200, c='#050505')\nplt.show()","2241bcdd":"import math\nimport random\nimport numpy as np\nimport pandas as pd\nfrom math import exp\nfrom copy import deepcopy\nfrom matplotlib import pyplot as plt\n\n\nplt.rcParams['figure.figsize'] = (16, 9)\nplt.style.use('ggplot')\n\n###.........data import ...........##\n\ndata_frame = pd.read_csv('..\/input\/testverim\/xclara.csv',index_col=False)\ncols = [1,2]\ndata = data_frame[data_frame.columns[cols]]\n\n\nlen_data_points=data.shape[0]               #total no. of data poins\nprint(\"Number of data points : {}\".format(len_data_points))\n\n\n###...............max_list min_list................\nmax_list = []\nmin_list = []\n\nv1_max = data['V1'].max()\nv1_min = data['V1'].min()\nv2_max = data['V2'].max()\nv2_min = data['V2'].min()\n\nmax_list.append(v1_max)\nmax_list.append(v2_max)\n\nmin_list.append(v1_min)\nmin_list.append(v2_min)\n\nprint(\"v1 max : {}, v1 min : {}, v2 max : {}, v2 min : {}\".format(v1_max,v1_min,v2_max,v2_min))\n\n\n#####............data plotting..........###\nv1_values = data['V1'].values\nv2_values = data['V2'].values\nX = np.array(list(zip(v1_values, v2_values)))\n\nplt.scatter(v1_values, v2_values, c = 'black', s = 7)\nplt.show()\n\n##.......max gen..........##\nmaxgen = 10\n\n##.......no of cluster...... ###\nk = 3\n\n###.......firefly creation...........##\nfirefly_swarm_size= 5\nfirefly_swarm_matrice = np.zeros((firefly_swarm_size,k,2), dtype=np.float64)\n\n\nfor i in range(firefly_swarm_size):\n    centroid_x_location_list = np.random.randint(0, 200, size=k)\n    centroid_y_location_list = np.random.randint(0, 200, size=k)\n    Y = np.array(list(zip(centroid_x_location_list, centroid_y_location_list)), dtype=np.float32)\n    firefly_swarm_matrice[i] = Y\n\nprint(\"Initial firefly\")\nprint(firefly_swarm_matrice)\n\n####.......plotting firefly..........#####\nfor i in range(firefly_swarm_size):\n    plt.scatter(firefly_swarm_matrice[i][:,0],firefly_swarm_matrice[i][:,1], label='True Position',s=150)\n    plt.show()\n\n#####......objective function calculation...........####\n\nJ=np.zeros((firefly_swarm_size), dtype=np.float64)\n\ndef cal_objective(num):\n    arr = np.ones((len_data_points, k), dtype=np.float64)\n    for j in range(len_data_points):\n        for i in range(k):\n            try:\n              dis = math.sqrt(((float(X[j][0] )- firefly_swarm_matrice[num][i][0]) ** 2) + ((float(X[j][1]) - firefly_swarm_matrice[num][i][1]) ** 2))\n              arr[j][i] = dis\n            except ValueError:\n                continue\n\n\n    min_dist_clus0 = np.ones((len_data_points), dtype=np.float64)  # stores the nearest cluster distance\n\n    for j in range(len_data_points):\n        min = 0\n        val=0\n        for i in range(k):\n            if arr[j][i] < arr[j][min]:\n                    val = arr[j][i]\n                    min = i\n\n        min_dist_clus0[j] = val\n\n\n\n    sum=0\n    for i in range(len_data_points):\n        sum=sum+min_dist_clus0[i]\n\n    J[num]=math.sqrt(sum)\n    return J[num]\n\nfor i in range(firefly_swarm_size):\n    J[i]=cal_objective(i)\n\nprint(J)\n\n####.........parameter for firefly algorithm............#####\n\nalpha = 0.5\nbeta = 0\nbeta_0 = 1\ngamma = 1\n\n####...........Best Firefly Calculation...........#######\n\nobj=[]\nfor gen in range(maxgen):\n    for i in range(5):\n        scale = abs((max_list[0] - min_list[0])+(max_list[1]-max_list[1]))\n        for j in range(5):\n            if(J[i]>J[j]):\n                r=0\n                for l in range(k):\n                    r=r+(firefly_swarm_matrice[i][l][0] - firefly_swarm_matrice[j][l][0]) + (firefly_swarm_matrice[i][l][1] - firefly_swarm_matrice[j][l][1])\n                r = abs(r)\n                r = math.sqrt(r)\n                betamin=0.2\n                gamma=1.0\n                beta0 = 1.0\n                beta = (beta0 - betamin) * \\\n                       math.exp(-gamma * math.pow(r, 2.0)) + betamin\n                beta = beta_0 * (exp(-gamma) * (r** 2))\n               # print(beta)\n                for l in range(k):\n                    r = random.uniform(0, 1)\n                    tmpf = alpha * (r - 0.5) * scale\n                    firefly_swarm_matrice[i][l][0] = firefly_swarm_matrice[i][l][0] * (1.0 - beta) +firefly_swarm_matrice[j][l][0] * beta + tmpf\n                    firefly_swarm_matrice[i][l][1] = firefly_swarm_matrice[i][l][1] * (1.0 - beta) + firefly_swarm_matrice[j][l][1] * beta + tmpf\n\n            temp = np.zeros((k, 2), dtype=np.float64)\n            temp = firefly_swarm_matrice[i]\n            for l in range(k):\n                for s in range(2):\n                    if temp[l][s] < min_list[s]:\n                        temp[l][s] = random.uniform(min_list[s],max_list[s])\n\n                    if temp[l][s] > max_list[s]:\n                        temp[l][s] = random.uniform(min_list[s],max_list[s])\n\n\n            firefly_swarm_matrice[i] = temp\n            arr = np.zeros((len_data_points, k), dtype=np.float64)\n            for n in range(len_data_points):\n                for m in range(k):\n                    try:\n\n                        dis = math.sqrt(((float(X[n][0]) - firefly_swarm_matrice[i][m][0]) ** 2) + ((float(X[n][1]) - firefly_swarm_matrice[i][m][1]) ** 2))\n                        arr[n][m] = dis\n                    except ValueError:\n                        continue\n            min_dist_clus = np.zeros((len_data_points), dtype=np.float64)\n            for n in range(len_data_points):\n                min = 0\n                val=0\n                for m in range(k):\n                    if arr[n][m] < arr[n][min]:\n                            val = arr[n][m]\n                            min= m\n\n                min_dist_clus[n] = val\n\n            sum = 0\n            for n in range(len_data_points):\n                sum = sum + min_dist_clus[n]\n            J[i]= math.sqrt(sum)\n\n    obj.append(np.amin(J))\n    for i in range(1,5):\n        if(J[i-1]<J[i]):\n            best=i\n\nprint(\"best firefly \")\nprint(firefly_swarm_matrice[best])\n\n\n\n######...........ploting best fF(firefly)........#######\n\nplt.scatter(firefly_swarm_matrice[best][:,0],firefly_swarm_matrice[best][:,1])\nplt.show()\n\n\n#####......... Euclidean Distance Calculator..............#####\ndef dist(v1_max, v1_min, ax=1):\n    return np.linalg.norm(v1_max - v1_min, axis=ax)\n\n\n############################################################\n######..............K Means.......................########\n###########################################################\n\n\n#####..............Centroid initialization...........#######\n\ncentroid_values = firefly_swarm_matrice[best]\nprint(\"intitial centroid\")\nprint(centroid_values)\ncentroid_x_location_list=[]\ncentroid_y_location_list=[]\n\nfor i in range(k):\n    centroid_x_location_list.append(centroid_values[i][0])\n    centroid_y_location_list.append(centroid_values[i][1])\n\n\n\n# #########..............Plotting along with the Centroids..................################\nplt.scatter(v1_values, v2_values, c='#050505', s=7)\nplt.scatter(centroid_x_location_list, centroid_y_location_list, marker='*', s=200, c='g')\nplt.show()\n\n\n#####....... To store the value of centroids when it updates...........########\nC_old = np.zeros(centroid_values.shape)\n# Cluster Lables(0, 1)\nclusters = np.zeros(len(X))\n\n\n\n#######......... Error func. - Distance between new centroids and old centroids.........#######\nerror = dist(centroid_values, C_old, None)\n\n# Loop will run untill the error becomes zero\nk_obj=[]\nx_axis=[]\nx_val=[]\nval=200\ncount=0\nwhile error != 0:\n    x_axis.append(count)\n    x_val.append(val)\n    count += 1\n    val+=1\n\n    arr = np.ones((len_data_points, k), dtype=np.float64)\n    for j in range(len_data_points):\n        for i in range(k):\n            try:\n                dis = math.sqrt(((float(X[j][0]) - centroid_values[i][0]) ** 2) + ((float(X[j][1]) - centroid_values[i][1]) ** 2))\n                arr[j][i] = dis\n            except ValueError:\n                continue\n\n    min_dist_clus0 = np.ones((len_data_points), dtype=np.float64)  # stores the nearest cluster distance\n\n    for j in range(len_data_points):\n        min = 0\n        val = 0\n        for i in range(k):\n            if arr[j][i] < arr[j][min]:\n                val = arr[j][i]\n                min = i\n\n        min_dist_clus0[j] = val\n\n    sum = 0\n    for i in range(len_data_points):\n        sum = sum + min_dist_clus0[i]\n\n    J= math.sqrt(sum)\n    obj.append(J)\n    # Assigning each value to its closest cluster\n    for i in range(len(X)):\n        distances = dist(X[i], centroid_values)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n\n    # Storing the old centroid values\n    C_old = deepcopy(centroid_values)\n    #print(C_old)\n    # Finding the new centroids by taking the average value\n    for i in range(k):\n        points = [X[j] for j in range(len(X)) if clusters[j] == i]\n        centroid_values[i] = np.mean(points, axis=0)\n    error = dist(centroid_values, C_old, None)\nprint (centroid_values)\n\n############............k-means plot.............##############\ncolors = ['r', 'g', 'b', 'y', 'c', 'm']\nfig, ax = plt.subplots()\nfor i in range(k):\n        points = np.array([X[j] for j in range(len(X)) if clusters[j] == i])\n        ax.scatter(points[:, 0], points[:, 1], s=7, c=colors[i])\nax.scatter(centroid_values[:, 0], centroid_values[:, 1], marker='*', s=200, c='#050505')\nplt.show()\n\n#############.............ploting objective function............########\nfor i in range(len(obj)):\n        if(i< maxgen):\n            plt.plot(i,obj[i])\n        else:\n            plt.plot(i,obj[i])\nplt.show()\n\nfig1, ax1 = plt.subplots(1,dpi = 120)\nfig1.suptitle('Costs per Iterations')\nplt.xlabel(\"Iteration\")\nplt.ylabel(\"Cost\")\nplt.grid(b = True, which = 'major', ls = '-.', lw = 0.45)\nax1.plot(obj)\nplt.show()","fb18d226":"FireFly Algorithm","83445852":"firefly"}}