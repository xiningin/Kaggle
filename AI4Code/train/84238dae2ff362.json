{"cell_type":{"240eeae4":"code","f96ee04e":"code","cd1dfa4d":"code","f0d91a60":"code","dfc5fe77":"code","3dfd5195":"code","9b663594":"code","cb60b6d4":"code","638fdce0":"code","c7793678":"code","04c7b0c3":"code","b949d092":"code","2d5c0a88":"code","fc1236f1":"code","fe72826f":"code","0f849a76":"code","5c977eb3":"code","c364e12d":"code","021fe1d2":"code","1807a30a":"code","bd9e1783":"code","72af61bf":"code","2099a1e0":"code","a273c54a":"code","3360fcec":"code","4cd35fb9":"code","cf35fe6e":"code","651b7371":"code","b14f9298":"code","c14495c9":"code","39991842":"code","b5467675":"code","eac89eb2":"code","09c65e6f":"code","dfdafb97":"code","000da4f9":"markdown","e54d0bab":"markdown","d151fc0c":"markdown","019e8dad":"markdown","4ee4c2e2":"markdown","1a967ebc":"markdown","2f7ede32":"markdown","f6b7eeb4":"markdown","21835ad3":"markdown","9f8aef74":"markdown","227ebe59":"markdown","903790ef":"markdown","ba5cd12e":"markdown","afe3bcac":"markdown","294e6029":"markdown","ec512986":"markdown","10261815":"markdown","4b3057e8":"markdown","f5d06162":"markdown","3836ec8f":"markdown","2f340671":"markdown","17b07229":"markdown","15e314bf":"markdown","01ea9028":"markdown","70ca511a":"markdown","57391e96":"markdown","738053d4":"markdown","97fdb649":"markdown","842bc7f7":"markdown","99592dde":"markdown","24498f83":"markdown"},"source":{"240eeae4":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport seaborn as sns\n%matplotlib inline\n\nnp.random.seed(2)\n\nfrom sklearn.model_selection import train_test_split\nimport itertools\n\nfrom keras.utils.np_utils import to_categorical # convert to one-hot-encoding\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D\nfrom keras.optimizers import RMSprop, Adam, SGD\nfrom keras.callbacks import History \n\n\n","f96ee04e":"train = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')","cd1dfa4d":"train.sample(10)","f0d91a60":"test.sample(10)","dfc5fe77":"train.shape","3dfd5195":"test.shape","9b663594":"train.isnull().any().describe()","cb60b6d4":"test.isnull().any().describe()","638fdce0":"Y_train = train[\"label\"]\nX_train = train.drop(labels=\"label\",axis=1)","c7793678":"print (X_train.shape)\nprint (Y_train.shape)","04c7b0c3":"X_train = X_train\/255.0\ntest = test\/255.0","b949d092":"X_train = X_train.values.reshape(-1,28,28,1)\ntest = test.values.reshape(-1,28,28,1)","2d5c0a88":"#Confirming the X_train shape we earlier predicted\nprint (X_train.shape)\n\n#confirming the test shape we earlier predicted\nprint(test.shape)","fc1236f1":"nrows = 2\nncols = 3\ni = 0\nfig, ax = plt.subplots(nrows,ncols,sharex=True,sharey=True)\nfor row in range(nrows):\n    for col in range(ncols):\n        ax[row,col].imshow(X_train[i][:,:,0])\n        ax[row,col].set_title(\"True label :{}\".format(Y_train[i]))\n        i += 1\n","fe72826f":"sns.countplot(Y_train)","0f849a76":"Y_train.value_counts()","5c977eb3":"##### num_classes = 10 because we have 10 classes from 0 to 9\nY_train = to_categorical(Y_train, num_classes=10)\n#also let's look at our modified Y_train for the  1st 6 images displayed above. Remember: index starts from 0\nY_train[0:6]","c364e12d":"random_seed = 2","021fe1d2":"X_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size = 0.1, random_state=random_seed)","1807a30a":"model = Sequential()\n\nmodel.add(Conv2D(filters = 16, kernel_size = (5,5),padding = 'Same', \n                 activation ='relu', input_shape = (28,28,1)))\nmodel.add(MaxPool2D(pool_size=(2,2)))\n\n\nmodel.add(Conv2D(filters = 32, kernel_size = (3,3),padding = 'Same', \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Flatten())\nmodel.add(Dense(128, activation = \"relu\"))\n\nmodel.add(Dense(128, activation = \"relu\"))\n\nmodel.add(Dense(10, activation = \"softmax\"))\n\n#Note: I didn't use any regularisation yet! let's see how well our model acts without regularisation like dropout! We can always iterate later :)","bd9e1783":"#For faster convergence, i've used 10 epochs. 20 epochs seems to work a bit better! Try changing it to 20 or even 30 for better accuracy\nepochs = 10\nbatch_size = 100","72af61bf":"optimizerSGD = SGD(lr=0.01, momentum=0.0, decay=0.0, nesterov=False)\noptimizerAdam = Adam(lr=0.001, beta_1=0.9, beta_2=0.999, epsilon=1e-08, decay=0.0, amsgrad=False)\noptimizerRMSprop = RMSprop(lr=0.001, rho=0.9, epsilon=1e-08, decay=0.0)\n","2099a1e0":"history = History() #to keep track of accuracy parameters, we will see it's use soon","a273c54a":"#training using SGD\nmodel.compile(optimizer = optimizerSGD , loss = \"categorical_crossentropy\", metrics=[\"accuracy\"])\nhistorySGD = model.fit(X_train, Y_train, batch_size = batch_size, epochs = epochs, \n         validation_data = (X_val, Y_val), verbose = 2)","3360fcec":"resultsSGD = model.predict(test)","4cd35fb9":"#training using RMSprop\nmodel.compile(optimizer = optimizerRMSprop , loss = \"categorical_crossentropy\", metrics=[\"accuracy\"])\nhistoryRMSprop = model.fit(X_train, Y_train, batch_size = batch_size, epochs = epochs, \n         validation_data = (X_val, Y_val), verbose = 2)","cf35fe6e":"resultsRMSProp = model.predict(test)","651b7371":"#training using Adam\nmodel.compile(optimizer = optimizerAdam , loss = \"categorical_crossentropy\", metrics=[\"accuracy\"])\nhistoryAdam = model.fit(X_train, Y_train, batch_size = batch_size, epochs = epochs, \n         validation_data = (X_val, Y_val), verbose = 2)","b14f9298":"resultsAdam = model.predict(test)","c14495c9":"SGD_acc = historySGD.history['acc']\nSGD_val_acc = historySGD.history['val_acc']\nRMSprop_acc = historyRMSprop.history['acc']\nRMSprop_val_acc = historyRMSprop.history['val_acc']\nAdam_acc = historyAdam.history['acc']\nAdam_val_acc = historyAdam.history['val_acc']","39991842":"plt.plot(SGD_acc)\nplt.plot(RMSprop_acc)\nplt.plot(Adam_acc)\nplt.legend(['SGD', 'RMSprop', 'Adam'], loc='lower right')\nplt.title('Training accuracy: SGD vs RMSprop vs Adam')\nplt.show()","b5467675":"plt.plot(SGD_val_acc)\nplt.plot(RMSprop_val_acc)\nplt.plot(Adam_val_acc)\nplt.legend(['SGD', 'RMSprop', 'Adam'], loc='lower right')\nplt.title('Validation accuracy: SGD vs RMSprop vs Adam')\nplt.show()","eac89eb2":"fig, ax = plt.subplots(1,3,sharex=True,sharey=True,figsize=(15, 5))\nax[0].plot(SGD_acc)\nax[0].plot(SGD_val_acc)\nax[0].legend(['SGD_train','SGD_val'], loc='lower right')\nax[0].set_title(\"SGD\")\n\nax[1].plot(RMSprop_acc)\nax[1].plot(RMSprop_val_acc)\nax[1].legend(['RMSprop_train','RMSprop_val'], loc='lower right')\nax[1].set_title(\"RMSprop\")\n\nax[2].plot(Adam_acc)\nax[2].plot(Adam_val_acc)\nax[2].legend(['Adam_train','Adam_val'], loc='lower right')\nax[2].set_title(\"Adam\")","09c65e6f":"results = np.argmax(resultsAdam,axis=1)\nresults = pd.Series(results,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1)","dfdafb97":"submission.to_csv(\"submission.csv\",index=False)","000da4f9":"**Let's read train and test values from the dataset. **","e54d0bab":"## Checking null values\n\n* We have 42000 data points in our train data set and 28000 in our test data set!\n\n* Next, let's look for any null values. \n* We will check null values in both train and test data set   \n<img src=\"https:\/\/pics.me.me\/obviously-31892135.png\" width=\"400px\"\/>\n \n","d151fc0c":"I hope this kernel **helped** in gaining some **insights** about **optimizers**. Feel free to fork it and experiment with it further. Also vote if you like the kernel. \n\nThank You!!\n\n<img src=\"https:\/\/albertonrecord.co.za\/wp-content\/uploads\/sites\/35\/2018\/04\/thank-you-185078737_76252.jpg\" width=\"300px\"\/>\n\n","019e8dad":"# Imbalanced Class\nGood going!! There are the digits. So what next?\n\nNow, before going further to train our model. We need to see one of the biggest factor in classification problem, i.e, imbalanced class. Let's plot a countplot and see whether we have imbalanced classes here","4ee4c2e2":"# Visualization","1a967ebc":"## Woah! What a perfect day! No null value! ;)\n\n<img src=\"https:\/\/memegenerator.net\/img\/instances\/48506203\/wow.jpg\" width=\"200px\"\/>\n","2f7ede32":"## X_train and Y_train\n\nLet's separate our train dataset into X_train and Y_train\n\nWhat is X_train and Y_train??\n\n* X_train -> It will have all our training examples without the actual\/true label of classification (num_examples,columns)\n* Y_train -> It will have all the actual\/true label for corresponding X_train value (num_examples)\n\nThus, we have 42000 images in train as whole","f6b7eeb4":"# Training Model\nLet's compile and train our models separately for different optimizers. Our metrics will be stored in history variable, which could be used later for comparation","21835ad3":"# Looking at our digit images\n\nToo much of reshaping, normalizing and everything. Where is the image???????\n\nOK! OK! Now let's look at first six images as subplots! We will also set title as the true label which is stored in corresponding Y_train","9f8aef74":"# one-hot-encoding\nApplying one hot encoding to Y_train (multi-class problem, thus we will need softmax transformtion)","227ebe59":"Cool!! Our X_train is now just 42000 by 784 i.e 42000 datapoint with 784 pixels(label column is dropped)\n\nAnd of course Y_train is just an array of the true label of 42000 images","903790ef":"# Normalization\n\nJust one last step before we reshape our data! We have to normalize our X_train and test\n\n<img src=\"https:\/\/vignette.wikia.nocookie.net\/vampirediaries\/images\/c\/ca\/But-why-meme-generator-but-why-84103d.jpg\/revision\/latest?cb=20130811194815\" width=\"400px\"\/>\n\n## Because\n\nAs we will use CNN, these models works better if the values are in [0,1], thus we divide our values with 255\n\nBut why to normalise test data??\n\nWhy not? We can't compare oranges with apples right? ","ba5cd12e":"# COMPARING SGD, RMSprop, Adam FOR DIGIT RECOGNITION USING CNN:\n\n* Stochastic Gradient Descent \n* RMSprop\n* Adam\n\nLet's see how well these optimiser help in predicting digits.","afe3bcac":"# INSIGHTS FROM VALIDATION ACURACY\n\n### Validation accuracy is the most important part because it is the measure of how well our model works on the unseen datapoints.\nI am always exited to analyse validation accuracy or validation error(1 - validation accuracy). This factor gives us insight about how well our model can be improved further!!\n\n### Things to note:\n\n* Stochastic Gradient Descent works good but of course is far away to be compared with Adam or RMSprop.\n\n* It's interesting to see the performance of Adam vs RMSprop, RMSprop seems to perform better after around 6th epoch. However, Adam wins at the end of 10th epoch.\n\n* As RMSprop seems to perform better for a considerable period of time, it's highly suggested to increase the number of epochs and analyse the performance. You can go up and change epochs to 20 or 30 and feel free to experiment further\n\n\n\n\n","294e6029":"# Intuition for Reshaping dataset for our CNN model\n\nSaid so much about that, did we see how this grayscale image looks like?? \n\n<img src=\"https:\/\/image.spreadshirtmedia.com\/image-server\/v1\/mp\/designs\/1014185688,width=178,height=178\/who-cares.png\" width=\"200px\"\/>\n\nWell, all of us care! \n\nBut first let's convert our X_train in the shape (m,pixel,pixel,channels)\n* m : number of datapoints\n* pixel : Our image is 24 by 24 pixel. pixel holds 24 in our case\n* channels : As this is grayscale image, we just have a single channel. channel = 3 for RGB images!\n\nOur X_train has 42000 data points and test has 28000. As all of you would have predicted that our final shape, which is to be fed in model is as follows:\n* X_train = (42000,28,28,1)\n* test = (28000,28,28,1)","ec512986":"<img src=\"https:\/\/memegenerator.net\/img\/instances\/48506203\/wow.jpg\" width=\"200px\"\/>\n\nWhat a day!! It looks like we have pretty balanced class. \n\nNo need to apply any resampling techniques. We are free to go forward! Let's see counts for each digits anyways!","10261815":"# Convolutional Neural Networks\n\nLet's look at LeNet-5 architecture\n\n<img src=\"https:\/\/indoml.files.wordpress.com\/2018\/03\/lenet-52.png?w=736\" width=\"600px\"\/>\n\n\nTime to use all our deep learning knowledge and ask keras to help us implement it faster!! \n\nI would highly recommend to see the [keras](http:\/\/keras.io\/) documentation, if you're new to it.\n\nP.S - This model is inspired by LeNet-5","4b3057e8":"### Let's just observe whether the overfitting reason(training performance is much better than validation) holds in our case","f5d06162":"# Defining optimizers\nHere comes the optimisers: We'll define 3 optimiser\n\n* optimizerSDG - Stochastic gradient Descent optimiser\n* optimizerRMSprop - RMSprop optimiser\n* optimizerAdam - ADaptive Moment Estimation(Adam) optimiser\n\nClick [here](http:\/\/ruder.io\/optimizing-gradient-descent\/) to know more about these optimisers","3836ec8f":"# INSIGHTS\n\n* It's pretty clear performance on training data is better than validation data. This seems normal, but the difference bridge could be decreased using either overfitting techniques or adding more data in our model\n\n# CONCLUSION\n* Looking at out hyperparameters value, we come to conclusion that Adam seems better option as of now. But feel free to increase the number of epoch, and maybe you can see RMSprop working better\n* Tuning hyperparameters like number of epochs, batch_size, etc., may result in finding better models.\n* For this kerel, let's submit the results from Adam optimizer model. ","2f340671":"## Overfitting\nIt's very crucial to observe whether we are overfitting our model. One intuition of overfitting can be thought as if your model works pretty well in training data but not so good in validation data, it can be an example of overfitting.\n\nHow to **overcome** overfitting?\n* Try to add **regularisation** like add dropout with some keep_prob\n* Observe the factors which maybe a reason for error (maybe sometimes by manually **observing** the error data points)\n\n**Note**: Different overfitting techniques could be used depending upon the problem, feel free to google and know about them","17b07229":"## Reshape\nAwesome! Let's reshape X_train and test now!","15e314bf":"# Understanding the dataset\n\n* Each data point in our train has pixel values ranging from pixel0 to pixel783. \n\n* <img src=\"https:\/\/vignette.wikia.nocookie.net\/vampirediaries\/images\/c\/ca\/But-why-meme-generator-but-why-84103d.jpg\/revision\/latest?cb=20130811194815\" width=\"400px\"\/>\n\n\n* We have 24 by 24 pixels for each data point or image in our dataset.\nSo 24 * 24 = 784. We'll see later in the notebook how to convert this into our desired shape so that it becomes an input for our convNet\n\n* And obviously label column is the true label for that particular data point. \n\nLet's look at our test dataset too!","01ea9028":"**OK! Now it's time to look how our dataset looks like. We'll randomly sample 10 values from both train and test**","70ca511a":"# Storing accuracy metrics\nTime to compare training accuracy and validation accuracy for each model with different optimiser. \n\nBut where are the accuracy values stores??\n\nWe have history of every epoch in all 3 models in history<optimizer_name>. Let's retrieve those values and compare!\n\nAnd also, i'll explain why i've used results<optimizer_name> after training every model","57391e96":"# INSIGHTS FROM TRAINING ACURACY\n\n### Things to note:\n\n*  Clearly we can observe that Adam is performing best among three.\n\n*  We also observe that RMSprop started will a lower accuracy for the first two epochs. This can be improved using bias correction,  but it started learning fast and competes closely with Adam optimizer on higher epochs. Thus we can omit bias correction(it is recommended though).\n\n* Stochastic Gradient Descent however keeps learning and becomes better that it's previous value. However it's far away to compete with Adam or RMSprop.\n\n","738053d4":"## Import libraries\nLet's import some basic libraries first","97fdb649":"## Dimensions of X_train and Y_train\n\nLet's check the shape of our X_train and Y_train!\n\n### Any guess?\n<img src=\"http:\/\/4.bp.blogspot.com\/-aE-06rRzYZE\/UWByCA1jelI\/AAAAAAAA228\/wDrgQIdFZHw\/s1600\/Any%2Bguesses%2Bas%2Bto%2Bwho%2Btrumps%2BPalestinians%2Bin%2Blibeling%2BIsrael.jpg\" width=\"200px\"\/>","842bc7f7":"# Splitting train and validation dataset\n\n<img src=\"https:\/\/medicaldialogues.in\/wp-content\/uploads\/2017\/12\/phew.jpg\" width=\"200px\"\/>\n\nPhew!! We are done with all pre processing and now we have data ready to be fed into our models!! Are you ready??\n\nAs we have balanced dataset, it's ok to split our dataset randomly. We split 90% data for training and 10% for validation. We'll judge our model on this validation data and secretly hide our test data! Let's initialize random seed to 2. Be free to change it if you need","99592dde":"So as expected we have only the grayscale pixel value for all dataset without label. Obviously, because that's what we want to predict!\n\nLet's see the shape or dimension of both train and test dataset","24498f83":"# Content\n1. Understanding dataset\n2. Checking null values\n3. Intuition about dimensions used for CNN model\n4. Normalization\n5. Looking at some image examples\n6. Imbalanced Class\n7. One-Hot-Encoding\n8. Using Keras for CNN\n9. Defining different optimizers\n10. Training CNN\n11. Visualisation and insights from them\n12. Conclusion\n"}}