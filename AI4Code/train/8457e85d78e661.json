{"cell_type":{"75121e28":"code","b843cf35":"code","3ee10ffd":"code","dc2f3bb6":"code","933b8dac":"code","dc4e1666":"code","bf1b5676":"code","153c60a0":"code","458115fb":"code","cb41659b":"code","749ec158":"code","e7270d26":"code","a713e373":"code","fce1cbda":"code","c042d044":"markdown","6b2a49af":"markdown","863ac002":"markdown","880ba1b7":"markdown","131bb9f3":"markdown","c06479b2":"markdown","9c8ab061":"markdown","1d96b1d2":"markdown","71b73fca":"markdown","b5bfd6c1":"markdown","0c75820c":"markdown","248801bb":"markdown","5d44c581":"markdown","4417f1bf":"markdown","aa3e51db":"markdown","4fb6b695":"markdown","6f3013c5":"markdown","816747bc":"markdown"},"source":{"75121e28":"import math\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom IPython.display import display, Markdown\nfrom glob2 import glob\n\nPATH = '..\/input\/full-size-sample-macro-photos\/Data'","b843cf35":"# Gaussian Function:\ndef G(x, mean, std):\n    return np.exp(-0.5*np.square((x-mean)\/std))\n\n# Membership Functions:\ndef ExtremelyDark(x, M):\n    return G(x, -50, M\/6)\n\ndef VeryDark(x, M):\n    return G(x, 0, M\/6)\n\ndef Dark(x, M):\n    return G(x, M\/2, M\/6)\n\ndef SlightlyDark(x, M):\n    return G(x, 5*M\/6, M\/6)\n\ndef SlightlyBright(x, M):\n    return G(x, M+(255-M)\/6, (255-M)\/6)\n\ndef Bright(x, M):\n    return G(x, M+(255-M)\/2, (255-M)\/6)\n\ndef VeryBright(x, M):\n    return G(x, 255, (255-M)\/6)\n\ndef ExtremelyBright(x, M):\n    return G(x, 305, (255-M)\/6)","3ee10ffd":"for M in (128, 64, 192):\n    x = np.arange(-50, 306)\n    \n    ED = ExtremelyDark(x, M)\n    VD = VeryDark(x, M)\n    Da = Dark(x, M)\n    SD = SlightlyDark(x, M)\n    SB = SlightlyBright(x, M)\n    Br = Bright(x, M)\n    VB = VeryBright(x, M)\n    EB = ExtremelyBright(x, M)\n\n    plt.figure(figsize=(20,5))\n    plt.plot(x, ED, 'k-.',label='ED', linewidth=1)\n    plt.plot(x, VD, 'k-',label='VD', linewidth=2)\n    plt.plot(x, Da, 'g-',label='Da', linewidth=2)\n    plt.plot(x, SD, 'b-',label='SD', linewidth=2)\n    plt.plot(x, SB, 'r-',label='SB', linewidth=2)\n    plt.plot(x, Br, 'c-',label='Br', linewidth=2)\n    plt.plot(x, VB, 'y-',label='VB', linewidth=2)\n    plt.plot(x, EB, 'y-.',label='EB', linewidth=1)\n    plt.plot((M, M), (0, 1), 'm--', label='M', linewidth=2)\n    plt.plot((0, 0), (0, 1), 'k--', label='MinIntensity', linewidth=2)\n    plt.plot((255, 255), (0, 1), 'k--', label='MaxIntensity', linewidth=2)\n    plt.legend()\n    plt.xlim(-50, 305)\n    plt.ylim(0.0, 1.01)\n    plt.xlabel('Pixel intensity')\n    plt.ylabel('Degree of membership')\n    plt.title(f'M={M}')\n    plt.show()","dc2f3bb6":"def OutputFuzzySet(x, f, M, thres):\n    x = np.array(x)\n    result = f(x, M)\n    result[result > thres] = thres\n    return result\n\ndef AggregateFuzzySets(fuzzy_sets):\n    return np.max(np.stack(fuzzy_sets), axis=0)\n\ndef Infer(i, M, get_fuzzy_set=False):\n    # Calculate degree of membership for each class\n    VD = VeryDark(i, M)\n    Da = Dark(i, M)\n    SD = SlightlyDark(i, M)\n    SB = SlightlyBright(i, M)\n    Br = Bright(i, M)\n    VB = VeryBright(i, M)\n    \n    # Fuzzy Inference:\n    x = np.arange(-50, 306)\n    Inferences = (\n        OutputFuzzySet(x, ExtremelyDark, M, VD),\n        OutputFuzzySet(x, VeryDark, M, Da),\n        OutputFuzzySet(x, Dark, M, SD),\n        OutputFuzzySet(x, Bright, M, SB),\n        OutputFuzzySet(x, VeryBright, M, Br),\n        OutputFuzzySet(x, ExtremelyBright, M, VB)\n    )\n    \n    # Calculate AggregatedFuzzySet:\n    fuzzy_output = AggregateFuzzySets(Inferences)\n    \n    # Calculate crisp value of centroid\n    if get_fuzzy_set:\n        return np.average(x, weights=fuzzy_output), fuzzy_output\n    return np.average(x, weights=fuzzy_output)","933b8dac":"for pixel in (64, 96, 160, 192):\n    M = 128\n    x = np.arange(-50, 306)\n    centroid, output_fuzzy_set = Infer(np.array([pixel]), M, get_fuzzy_set=True)\n    plt.figure(figsize=(20,5))\n    plt.plot(x, output_fuzzy_set, 'k-',label='FuzzySet', linewidth=2)\n    plt.plot((M, M), (0, 1), 'm--', label='M', linewidth=2)\n    plt.plot((pixel, pixel), (0, 1), 'g--', label='Input', linewidth=2)\n    plt.plot((centroid, centroid), (0, 1), 'r--', label='Output', linewidth=2)\n    plt.fill_between(x, np.zeros(356), output_fuzzy_set, color=(.9, .9, .9, .9))\n    plt.legend()\n    plt.xlim(-50, 305)\n    plt.ylim(0.0, 1.01)\n    plt.xlabel('Output pixel intensity')\n    plt.ylabel('Degree of membership')\n    plt.title(f'input_pixel_intensity = {pixel}\\nM = {M}')\n    plt.show()","dc4e1666":"means = (64, 96, 128, 160, 192)\nplt.figure(figsize=(25,5))\nfor i in range(len(means)):\n    M = means[i]\n    x = np.arange(256)\n    %time y = np.array([Infer(np.array([i]), M) for i in x])\n    plt.subplot(1, len(means), i+1)\n    plt.plot(x, y, 'r-', label='IO mapping')\n    plt.xlim(0, 256)\n    plt.ylim(-50, 355)\n    plt.xlabel('Input Intensity')\n    plt.ylabel('Output Intensity')\n    plt.title(f'M = {M}')\nplt.show()","bf1b5676":"# Proposed fuzzy method\ndef FuzzyContrastEnhance(rgb):\n    # Convert RGB to LAB\n    lab = cv2.cvtColor(rgb, cv2.COLOR_RGB2LAB)\n    \n    # Get L channel\n    l = lab[:, :, 0]\n    \n    # Calculate M value\n    M = np.mean(l)\n    if M < 128:\n        M = 127 - (127 - M)\/2\n    else:\n        M = 128 + M\/2\n        \n    # Precompute the fuzzy transform\n    x = list(range(-50,306))\n    FuzzyTransform = dict(zip(x,[Infer(np.array([i]), M) for i in x]))\n    \n    # Apply the transform to l channel\n    u, inv = np.unique(l, return_inverse = True)\n    l = np.array([FuzzyTransform[i] for i in u])[inv].reshape(l.shape)\n    \n    # Min-max scale the output L channel to fit (0, 255):\n    Min = np.min(l)\n    Max = np.max(l)\n    lab[:, :, 0] = (l - Min)\/(Max - Min) * 255\n    \n    # Convert LAB to RGB\n    return cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n\n# Traditional method of histogram equalization\ndef HE(rgb):\n    lab = cv2.cvtColor(rgb, cv2.COLOR_RGB2LAB)\n    lab[:, :, 0] = cv2.equalizeHist(lab[:, :, 0])\n    return cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n\n# Contrast Limited Adaptive Histogram Equalization\ndef CLAHE(rgb):\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n    lab = cv2.cvtColor(rgb, cv2.COLOR_RGB2LAB)\n    lab[:, :, 0] = clahe.apply(lab[:, :, 0])\n    return cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)","153c60a0":"data = np.array([cv2.cvtColor(cv2.imread(p), cv2.COLOR_BGR2RGB) for p in glob(f'{PATH}\/*')])\ndata.shape","458115fb":"for i in range(data.shape[0]):\n    img = data[i]\n    fce = FuzzyContrastEnhance(img)\n    he = HE(img)\n    clahe = CLAHE(img) \n    display(Markdown(f'### <p style=\"text-align: center;\">Sample Photo {i+1}<\/p>'))\n    plt.figure(figsize=(15, 10))\n    plt.subplot(2, 2, 1)\n    plt.imshow(data[i])\n    plt.title('Original Image')\n    \n    plt.subplot(2, 2, 2)\n    plt.imshow(fce)\n    plt.title('Fuzzy Contrast Enhance')\n    \n    plt.subplot(2, 2, 3)\n    plt.imshow(he)\n    plt.title('Traditional HE')\n    \n    plt.subplot(2, 2, 4)\n    plt.imshow(clahe)\n    plt.title('CLAHE')\n    \n    plt.show()","cb41659b":"%%time\nfor i in range(10):\n    FuzzyContrastEnhance(data[i])","749ec158":"%%time\nfor i in range(10):\n    HE(data[i])","e7270d26":"%%time\nfor i in range(10):\n    CLAHE(data[i])","a713e373":"def MSE(img1, img2):\n    return np.mean(np.square(img1 - img2))\n\ndef PSNR(Max, MSE):\n    return 10*math.log10(Max**2\/MSE)","fce1cbda":"display(Markdown(f'FCE: {PSNR(255*255, np.mean([MSE(org, FuzzyContrastEnhance(org)) for org in data]))}'))\ndisplay(Markdown(f'HE: {PSNR(255*255, np.mean([MSE(org, HE(org)) for org in data]))}'))\ndisplay(Markdown(f'CLAHE: {PSNR(255*255, np.mean([MSE(org, CLAHE(org)) for org in data]))}'))","c042d044":"## V. Evaluation","6b2a49af":"### 1. Load sample photos","863ac002":"### 1. Execution Time\n**Fuzzy Contrast Enchance**","880ba1b7":"**CLAHE**","131bb9f3":"### 2. Apply FCE on sample photos","c06479b2":"### 2. Peak Signal-to-Noise Ratio (PSNR)\n\n$PSNR = 10*\\log_{10} \\frac{MAX^2}{MSE}$","9c8ab061":"## III. Proposed fuzzy-based method","1d96b1d2":"## IV. Demonstration","71b73fca":"### 2. Fuzzification of  Pixel Intensity","b5bfd6c1":"### 3. Rule Set\n- IF input is VeryDark THEN output is ExtremelyDark\n- IF input is Dark THEN output is VeryDark\n- IF input is SlightlyDark THEN output is Dark\n- IF input is SlightlyBright THEN output is Bright\n- IF input is Bright THEN output is VeryBright\n- IF input is VeryBright THEN output is ExtremelyBright","0c75820c":"**Traditional HE**","248801bb":"# <p style=\"text-align: center;\">Image Contrast Enhancement - A Fuzzy-based Method<\/p>\n<p style=\"text-align: right;\">Author: V\u01b0\u01a1ng L\u00ea Minh Nguy\u00ean<\/p>\n<p style=\"text-align: right;\">Mentor: Th.S Tr\u1ecbnh Huy Ho\u00e0ng<\/p>","5d44c581":"## I. Introduction\n- Image enhancement is a method of improving the\nquality of an image and contrast is a major aspect. Traditional\nmethods of contrast enhancement like histogram equalization\nresults in over\/under enhancement of the image especially a\nlower resolution one.\n\n- This project aims at developing a new Fuzzy\nInference System to enhance the contrast of the\nimages overcoming the shortcomings of the traditional methods.\n\n- Results obtained using both the approaches are compared.","4417f1bf":"## II. Contrast enhancement techniques\n\n- Gray-level transformation based techniques: logarithm transformation, power-law transformation, piecewise-linear transformation, etc.\n- Histogram based processing techniques: histogram equalization (HE), histogram specification, etc.\n- The most popular method is histogram equalization, which is based on the assumption that a uniformly distributed grayscale histogram will have the best visual contrast\n- Other advanced histogram based enhancement methods include bi-histogram equalization (BHE), block-overlapped histogram equalization, multi-scale adaptive histogram equalization, shape preserving local histogram modification, etc.\n\n![image.png](attachment:image.png)\n","aa3e51db":"**Requirement:**\nglob2, numpy, matplotlib, opencv-python","4fb6b695":"### 4. Inference and Defuzzication (Mamdani's method)","6f3013c5":"## VI. References\n\n1. Image contrast enhancement using fuzzy logic <br>https:\/\/arxiv.org\/ftp\/arxiv\/papers\/1809\/1809.04529.pdf\n\n2. A fast and efficient color image enhancement method based on fuzzy-logic and histogram <br>http:\/\/dx.doi.org\/10.1016\/j.aeue.2013.08.015","816747bc":"### 1. Overall Pipeline\n\n![image.png](attachment:image.png)\n\n#### Description:\n\n- Convert input image from RGB to CIELAB, progress on L channel\n\n- Calculate the average pixel intensity - M value\n\n- **Fuzzification:** For each pixel, calculate degree of membership of each class based on pixel intensity and M value. $Intensity \\in[0, 255]$ \n\n- **Inference:** Calculate the output fuzzy set from the input pixel intensity based on the proposed rule set\n\n- **Defuzzification:** For each pixel, calculate centroid value of its output fuzzy set.  $Centroid \\in [-50, 305]$ \n\n- Normalize output pixel intensity from \\[-50, 305\\] to \\[0, 255\\]\n\n- Merge modified L channel to the original AB channels, convert output image from CIELAB to RGB."}}