{"cell_type":{"297f76b3":"code","9f4e908c":"code","ab401ed6":"code","3840b4ad":"code","191ad2b3":"code","1e8ef68d":"code","35516dcb":"code","70c60117":"code","618313c1":"code","d3b1f8dc":"code","a9ce09a9":"code","6ec1e05d":"markdown","567f2dfa":"markdown","291c72e6":"markdown"},"source":{"297f76b3":"#!pip install \"http:\/\/github.com\/raoulvm\/wcs\/archive\/main.zip\"","9f4e908c":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tensorflow as tf\nimport tensorflow_addons as tfa\nfrom tensorflow import keras\nfrom PIL import Image\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.model_selection import train_test_split\n#from wcs.google import google_drive_share\nimport math\nimport traceback\nfrom typing import Callable, List, Tuple, Union\n\nfrom PIL import ImageFile\nImageFile.LOAD_TRUNCATED_IMAGES = True\n","ab401ed6":"class Movie_poster_data:\n    \n    GENRES_MAP_TEXT={\n         28: 'Action',\n         12: 'Adventure',\n         16: 'Animation',\n         35: 'Comedy',\n         80: 'Crime',\n         99: 'Documentary',\n         18: 'Drama',\n         10751: 'Family',\n         14: 'Fantasy',\n         36: 'History',\n         27: 'Horror',\n         10402: 'Music',\n         9648: 'Mystery',\n         10749: 'Romance',\n         878: 'Science Fiction',\n         10770: 'TV Movie',\n         53: 'Thriller',\n         10752: 'War',\n         37: 'Western',\n        }\n\n    def __init__(\n        self,\n        index_filename:str='\/kaggle\/input\/moviepostergenre20212\/df.parquet.gzip',\n        image_folder_path:str='\/kaggle\/input\/moviepostergenre20212\/images\/images',\n        testset_csv_path:str='\/kaggle\/input\/moviepostergenre20212\/movies_test.csv',\n        validation_split:float=0.1,\n        lower_n_posters_only:int=None,\n        )->None:\n        self.image_folder_path = image_folder_path\n        \n        self.posterdata = pd.read_parquet(index_filename)\n        self.posterdata = self.posterdata[(self.posterdata.file_exists==True)] # remove not loaded pictures   ,,, (self.posterdata.is_holdout==False) & \n        self.posterdata = self.posterdata.set_index('id').sort_index()\n        self.lower_n_posters_only = lower_n_posters_only\n        if not lower_n_posters_only is None:\n            self.posterdata = self.posterdata.iloc[:lower_n_posters_only]\n        self.posterdata = self.posterdata.assign(\n            genres_text = self.posterdata.genre_id.apply(\n                lambda id_list: [self.GENRES_MAP_TEXT[y] for y in id_list]\n                )\n            )\n        \n        #one hot encode target\n        mlb = MultiLabelBinarizer()\n        mlb.fit(\n            [\n                [i for i in list(self.GENRES_MAP_TEXT.values())]\n            ]\n            )\n        \n        df_ohe = pd.DataFrame(\n            mlb.transform(self.posterdata.genres_text),\n            index = self.posterdata.index,\n            columns = list(self.GENRES_MAP_TEXT.values()),\n            )\n\n        # which columns are required?\n        # index\n        # poster filename\n        # genre columns\n        self.posterdata = pd.concat([\n            self.posterdata[['filename','genres_text']],\n            df_ohe],\n            axis=1\n        )\n        \n        # test set \n        \n        if not testset_csv_path is None:\n            df_test = pd.read_csv(testset_csv_path, sep=';').set_index('id')\n            self.testindex = list(df_test.index.intersection(self.posterdata.index)) # only keep those loaded, even though that is cheating\n        else:\n            self.testindex = []\n            \n        \n        # validation set\n        \n        if not validation_split is None and validation_split>0.0:\n            self.trainindex, self.validationindex = train_test_split(self.posterdata.drop(index=self.testindex).index, test_size=validation_split)\n            self.trainindex = list(self.trainindex)\n            self.validationindex = list(self.validationindex)\n        else:\n            self.trainindex = list(self.posterdata.drop(index=self.testindex).index)\n            self.validationindex = []\n        \n    def get_y(self, indices:list)->np.ndarray:\n        return self.posterdata.loc[indices][list(self.GENRES_MAP_TEXT.values())].to_numpy()\n    \n    def get_filenames(self, indices:list)->np.ndarray:\n        return self.posterdata.loc[indices]['filename'].to_numpy()\n    \n        ","3840b4ad":"# proudly copied from https:\/\/www.tensorflow.org\/api_docs\/python\/tf\/keras\/utils\/Sequence\n# and https:\/\/stanford.edu\/~shervine\/blog\/keras-how-to-generate-data-on-the-fly\nclass Movie_poster_sequence(keras.utils.Sequence):\n    \n    def __init__(\n        self,\n        movie_poster_data_object,\n        set_type:str='train',\n        batch_size:int=32,\n        image_size:tuple=(224,224),\n        colormode:str='RGB',\n        shuffle:bool=True,\n        keras_preprocessor:Callable=keras.applications.resnet50.preprocess_input\n        ):\n        \n        if set_type.lower() not in ('train','test','validation'):\n            raise ValueError(f\"set_type '{set_type}' not in ('train','test','validation')\")\n        \n        self.movie_poster_data_object = movie_poster_data_object\n        self.batch_size = batch_size\n        self.image_size = image_size\n        self.colormode = colormode\n        self.shuffle = shuffle\n        \n        #get the right index\n        if set_type.lower() == 'train':\n            self.x = movie_poster_data_object.trainindex\n        elif set_type.lower() == 'test':\n            self.x = movie_poster_data_object.testindex\n        elif set_type.lower() == 'validation':\n            self.x = movie_poster_data_object.validationindex\n        else:\n            raise AssertionError(\"Never to get here!\")\n        \n        \n    def __len__(self)->int:\n        return math.ceil(len(self.x) \/ self.batch_size)\n    \n    def __getitem__(\n        self,\n        idx):\n        \n        # create batches of indices:\n        \n        batch_x = self.x[idx * self.batch_size:(idx + 1) *\n        self.batch_size]\n        \n        y_values = self.movie_poster_data_object.get_y(batch_x)\n        x_filenames = self.movie_poster_data_object.get_filenames(batch_x)\n        \n        # Image Reader\n        x_images = []\n        for file_name in x_filenames: \n            try:\n                im = Image.open(self.movie_poster_data_object.image_folder_path +'\/'+ file_name)\n                try:\n                    npi = np.array(im.resize(self.image_size).convert(self.colormode))\n                except:\n                    print('\\nConversion failed for')\n                    print(self.movie_poster_data_object.image_folder_path +'\/'+ file_name)\n                    #traceback.print_exc()\n                    print('Continue with empty\/black picture')\n                    npi=np.zeros(shape=(self.image_size[0], self.image_size[1], 3))\n            except Exception as e:\n                print('\\nFile not readable!')\n                print(self.movie_poster_data_object.image_folder_path +'\/'+ file_name)\n                #traceback.print_exc()\n                print('Continue with empty\/black picture')\n                npi=np.zeros(shape=(self.image_size[0], self.image_size[1], 3))\n            \n            x_images.append(npi)\n        \n        return np.array(x_images),y_values    \n    \n    def on_epoch_end(self):\n        # update order of indices after each epoch\n        if self.shuffle == True:\n            np.random.shuffle(self.x)\n            \n    \n    def _image_augmentation(\n        self, \n        pil_image:Image,\n        ) -> Union[object,List[object]]:\n        \n        #dummy to be overwritten in implementation\n        return pil_image\n        ","191ad2b3":"mpd = Movie_poster_data(lower_n_posters_only=12092)\n\nimage_size=(224,224)\ncolor_mode = 'RGB'","1e8ef68d":"mps_test = Movie_poster_sequence(movie_poster_data_object=mpd,\n   set_type='test',\n   batch_size=32,\n   image_size=image_size,\n   colormode=color_mode,\n   shuffle=False,\n    )\n\n\nmps_train = Movie_poster_sequence(movie_poster_data_object=mpd,\n    set_type='train',\n    batch_size=32,\n    image_size=image_size,\n    colormode=color_mode,\n    shuffle=True,                              \n    )\n\n\nmps_validation = Movie_poster_sequence(movie_poster_data_object=mpd,\n    set_type='validation',\n    batch_size=32,\n    image_size=image_size,\n    colormode=color_mode,\n    shuffle=False,                                   \n                                       \n    )","35516dcb":"# use ResNet50 for transfer learning\n\nmodel = keras.applications.ResNet50( \n    input_shape=(image_size[1], image_size[0], 3),  # important width x height !!!\n    weights='imagenet', \n    include_top=False,\n    )\n\nmodel.trainable = False\n\n\n\n\n# connect to the model input\nl = keras.layers.Conv2D(\n    name='colorfinder_conv1x1',\n    filters=100,\n    kernel_size=(1,1),\n    bias_initializer='glorot_uniform',\n    )(model.input)\ncolor_avg = keras.layers.GlobalAveragePooling2D(name='colorfinder_average_pooling_2d')(l)\n\n# connect to model output\nresnet_avg = keras.layers.GlobalAveragePooling2D(name='resnet_average_pooling_2d')(model.output)\n\n# join both paths\nl = keras.layers.concatenate([color_avg, resnet_avg])\n\nl = keras.layers.Dense(\n    units=512,\n    activation='relu',\n    name='hidden1',\n)(l)\n\nhidden = keras.layers.Dense(\n    units=256,\n    activation='sigmoid',\n    name='hidden2',\n)(l)\n\noutput = keras.layers.Dense(\n    units=19,\n    activation='sigmoid',\n)(hidden)\n\n\nown_model = keras.Model(\n    inputs=model.input, \n    outputs=output,\n    )\n\n\n","70c60117":"own_model.compile(\n    optimizer='adam',\n    loss='binary_crossentropy',\n    metrics=[ \n        keras.metrics.Precision(name='precision'),\n        keras.metrics.Recall(name='recall'), \n        tfa.metrics.F1Score(\n            name='f1_weighted',\n            num_classes=19,\n            threshold=0.3,\n            average='weighted',\n            ),\n        tfa.metrics.F1Score(\n            name='f1_micro',\n            num_classes=19,\n            threshold=0.3,\n            average='micro',\n            ),            \n        \n    ]\n)","618313c1":"%%time\ncallbacks = [\n    keras.callbacks.ModelCheckpoint(\n        \"\/kaggle\/working\/resnet50_1x1_transfer_EPOCH_{epoch:06d}.h5\",\n        monitor='val_f1_weighted',\n        mode='max',\n        save_best_only=True,\n        ),\n]\n\n","d3b1f8dc":"%%time\nif True:\n    own_model.fit(\n        x= mps_train,\n        epochs=15,\n        validation_data=mps_validation,\n        callbacks=callbacks,\n        #batch_size=32,\n    )\nelse:\n    own_model = keras.models.load_model('\/kaggle\/input\/resnet50-result-model\/resnet50_1x1_transfer_EPOCH_000009.h5') \n    # this is the best iteration saved from Version 3\n    # ","a9ce09a9":"own_model.evaluate(x=mps_test)","6ec1e05d":"# Headline","567f2dfa":"# Some Model building","291c72e6":"# The Generator"}}