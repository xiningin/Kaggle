{"cell_type":{"fa4ccd78":"code","7e67b410":"code","17e076fa":"code","4c0e1a29":"code","35f8fd4d":"code","70b35cf0":"code","9b3d4f42":"code","8cd98b86":"code","1afc7fa9":"code","6344c744":"code","e94332a0":"code","659e47dc":"code","b4a7bf98":"code","dffbccee":"code","f0c2e2f6":"code","19ad3f27":"code","415e78a2":"code","687194e9":"code","f82ca2c3":"code","4157e30e":"code","1569a966":"code","c6653ea6":"code","4d07805e":"code","0669284c":"code","37cc0b9b":"code","431a84fb":"code","c3af1e56":"code","f098a0a4":"code","82e04653":"code","a2502cc4":"code","328bab7c":"code","ddc42fc2":"code","308f0736":"code","d538cdb7":"code","2b8507d1":"code","d4d3ec0e":"code","4060c316":"code","942c038d":"code","a7f54115":"code","fd47ec0a":"code","cca1fc58":"code","dd45f079":"code","53ef466d":"markdown","85580e25":"markdown","99e540c7":"markdown","6edb00f9":"markdown","6f506a95":"markdown","0316fc41":"markdown","b7e3b15d":"markdown","1ee4ea31":"markdown","bba2776d":"markdown","3508b35d":"markdown","d36c5112":"markdown","74bbdfce":"markdown"},"source":{"fa4ccd78":"import warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n\nfrom itertools import combinations\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression, LogisticRegressionCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix, classification_report","7e67b410":"# download the dataset from here\n# https:\/\/www.kaggle.com\/ahmettezcantekin\/beginner-datasetss\n\ndf = pd.read_csv(\"pokemon.csv\")\ndf.head(10)","17e076fa":"df.info()\n\n# null values in type 2 column...\n\n# i think fillna can handle this!","4c0e1a29":"df['Type 2'].fillna(df['Type 1'], inplace=True)","35f8fd4d":"df.head()","70b35cf0":"# random idea can you predict the type of a pokemon given its stats...?","9b3d4f42":"plt.figure(figsize=(10,8))\nax = sns.barplot(df['Type 1'].value_counts().values, df['Type 1'].value_counts().index, orient='h');\nax.set(xlabel=\"Number of pokemon as per type 1\");","8cd98b86":"plt.figure(figsize=(10,8))\nax = sns.barplot(df['Type 2'].value_counts().values, df['Type 2'].value_counts().index, orient='h');\nax.set(xlabel=\"Number of pokemon as per type 2\");","1afc7fa9":"# im not getting any clear ideas..\n# lets see correlation to get some if possible\n\nplt.figure(figsize=(10,8))\ncor = df.corr()\nsns.heatmap(cor,annot=True,cmap='Greens');","6344c744":"\nplt.figure(figsize=(10,8))\nax = sns.barplot(df.groupby(['Type 1'])['Attack'].mean().values, df.groupby(['Type 1'])['Attack'].mean().index, orient='h');\nax.set(xlabel=\"Attack as per Type 1\");","e94332a0":"# we might want to combine type 1 and 2 to create a new type\n\nall_types = pd.concat([df['Type 1'], df['Type 2']], ignore_index=True, axis=0).unique()\ncomb = combinations(all_types, 2)\n\ntype_combo = []\nfor i in list(comb):\n    type_combo.append(' '.join(i))\n\n\ndef type_clf(row):\n#     print(row)\n    if (row['Type 1'] + ' ' + row['Type 2']) in type_combo: \n        return (row['Type 1'] + ' ' + row['Type 2'])\n    elif (row['Type 2'] + ' ' + row['Type 1']) in type_combo:\n        return (row['Type 2'] + ' ' + row['Type 1'])\n    elif row['Type 1'] == row['Type 2']:\n        return row['Type 1']\n    \n    \n        \n        \n    \ndf['Type'] = df.apply(type_clf, axis=1)","659e47dc":"df.head()","b4a7bf98":"\nplt.figure(figsize=(10,25))\nax = sns.barplot(df.groupby(['Type'])['Attack'].mean().values, df.groupby(['Type'])['Attack'].mean().index, orient='h');\nax.set(xlabel=\"Attack as per Type 1\");","dffbccee":"df.groupby(['Type']).agg({'Attack': ['mean', 'min', 'max']})","f0c2e2f6":"plt.figure(figsize=(10,25))\nax = sns.barplot(df.groupby(['Type'])['HP'].mean().values, df.groupby(['Type'])['HP'].mean().index, orient='h');\nax.set(xlabel=\"HP as per Type 1\");","19ad3f27":"plt.figure(figsize=(10,25))\nax = sns.barplot(df.groupby(['Type'])['Defense'].mean().values, df.groupby(['Type'])['Defense'].mean().index, orient='h');\nax.set(xlabel=\"Defence as per Type 1\");","415e78a2":"plt.figure(figsize=(10,25))\nax = sns.barplot(df.groupby(['Type'])['Speed'].mean().values, df.groupby(['Type'])['Speed'].mean().index, orient='h');\nax.set(xlabel=\"Speed as per Type 1\");","687194e9":"# The total column represents the total of all the stats... lets see who's at the top and bottom","f82ca2c3":"df[df['Total'] == max(df['Total'])]","4157e30e":"df[df['Total'] == min\n   (df['Total'])]","1569a966":"# but i dont want legendardy for max\n\ndf[df['Total'] == max(df[df['Legendary'] == False]['Total'])][df['Legendary'] == False]","c6653ea6":"# lets see the weakest legendary\n\ndf[df['Total'] == min(df[df['Legendary'] == True]['Total'])][df['Legendary'] == True]","4d07805e":"# does belonging to a higher generation make you stronger?\n\ndf.groupby(['Generation'])['Total'].mean()\n\n# ok. ","0669284c":"df.groupby(['Generation'])['Total'].max()","37cc0b9b":"df.groupby(['Generation'])['Total'].min()","431a84fb":"# getting all data. and i realized i can't see all of it...\n\ndf.groupby(['Type'])['Total','HP' ,'Attack','Defense','Sp. Atk','Sp. Def','Speed'].describe()","c3af1e56":"df.head()","f098a0a4":"for col in df.iloc[:,4:12].columns:\n    sns.distplot(df[col])\n    plt.show()","82e04653":"\nfor col in df.iloc[:,4:12].columns:\n    sns.distplot(np.sqrt(df[col]))    # sqrt usually doesn't have a big effect but log caused left skeweness\n    plt.show()","a2502cc4":"for col in df.iloc[:,4:12].columns:\n    sns.distplot(np.log1p(df[col]))    # sqrt usually doesn't have a big effect but log caused left skeweness\n    plt.show()","328bab7c":"# lets fix our data\n\nfor col in df.iloc[:,5:11].columns:\n    df[col] = np.sqrt(df[col])   \n    ","ddc42fc2":"### except type, generation and '#' column\n\nfeatures = ['Total', 'HP', 'Attack', 'Defense',\n       'Sp. Atk', 'Sp. Def', 'Speed']\n\nX = df[features]\ny = df['Legendary'].replace({True:1,False:0})","308f0736":"y","d538cdb7":"scaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)","2b8507d1":"X_train,X_test,y_train,y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)","d4d3ec0e":"log_clf = LogisticRegression()\n\nlog_clf.fit(X_train,y_train)\n\nlog_clf.score(X_test,y_test)","4060c316":"log_clf_cv = LogisticRegressionCV(cv=5, random_state=0)\n\nlog_clf_cv.fit(X_train,y_train)\n\nlog_clf.score(X_test,y_test)","942c038d":"rf_clf = RandomForestClassifier()\nrf_clf.fit(X_train,y_train)\nrf_clf.score(X_test,y_test)","a7f54115":"df['Legendary'].value_counts()","fd47ec0a":"y_pred = log_clf.predict(X_test)","cca1fc58":"confusion_matrix(y_test,y_pred)\n\n# 6 false negative top right\n# 6 false positive bottom left","dd45f079":"print(classification_report(y_test,y_pred))","53ef466d":"### if you'd want to become a pokemon master, you clearly need to use this dataset","85580e25":"### most of our data if normalish distributed","99e540c7":"### train test split... i really need to start using other stuff like stratified k fold, cv, etc,. instead","6edb00f9":"## My aim was do dos some exploratory data analysis on this dataset and we could try to predict if a pokemon was legendary or not so i've done that as well..","6f506a95":"### imports","0316fc41":"# Thank you\n## Don't forget to leave a like or upvote if it was worth your time.","b7e3b15d":"### Models","1ee4ea31":"### Performance metrics","bba2776d":"### Ledendary shows some correlation... and some ppl have tried to predict legendary.\n\n### I will use a model on it but for now i'm gonna try and extract some data for exploration purpose","3508b35d":"### Standardize it","d36c5112":"## EDA","74bbdfce":"### Now, lets make the classificaition model"}}