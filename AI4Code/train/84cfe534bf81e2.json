{"cell_type":{"ee25f6b8":"code","ea254a50":"code","b15288cb":"code","2162dd1a":"code","1111d8a8":"code","750c72ef":"code","79ff8e53":"code","a1911fdd":"code","aa04aed0":"code","4a7ec81a":"code","c728ae8d":"code","565fa38a":"code","374db772":"code","17a0820c":"code","5088104c":"markdown","47b08dc2":"markdown","2a6029fe":"markdown","845e2804":"markdown"},"source":{"ee25f6b8":"import pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport lightgbm as lgb\nimport gc\nimport scipy.signal as signal\nimport scipy.stats as stats\nimport time\nimport warnings\nfrom tsfresh import extract_relevant_features, extract_features, select_features\nfrom tsfresh.utilities.dataframe_functions import impute\nimport logging\n\nwarnings.filterwarnings('ignore')\nlogging.basicConfig(format='%(levelname)s:%(message)s', level=logging.ERROR)\npd.set_option(\"max_columns\", 200)\npd.set_option(\"max_rows\", 200)\ngc.enable()","ea254a50":"x_train = pd.read_csv('..\/input\/X_train.csv')\ny_train = pd.read_csv('..\/input\/y_train.csv')\nx_test = pd.read_csv('..\/input\/X_test.csv')","b15288cb":"print(x_train.shape)\nx_train.head(10)","2162dd1a":"print(y_train.shape)\ny_train.head()","1111d8a8":"y_train.surface.unique()","750c72ef":"tsfresh_train = extract_features(x_train.drop('row_id', axis=1), column_id='series_id', \n                                 column_sort='measurement_number')\nimpute(tsfresh_train);","79ff8e53":"relevant_train_features = set()\nfor label in y_train['surface'].unique():\n    y_train_binary = (y_train['surface'].values == label).astype(int)\n    print('=='*20); print(y_train_binary); print('=='*20);\n    X_train_filtered = select_features(tsfresh_train, y_train_binary, fdr_level=0.382)\n    print('=='*20);\n    print(\"Number of relevant features for class {}: {}\/{}\".format(\n        label, X_train_filtered.shape[1], tsfresh_train.shape[1]))\n    print('=='*20);\n    relevant_train_features = relevant_train_features.union(set(X_train_filtered.columns))","a1911fdd":"tsfresh_test = extract_features(x_test.drop('row_id', axis=1), column_id='series_id', \n                                column_sort='measurement_number')\nimpute(tsfresh_test);\n","aa04aed0":"len(relevant_train_features)","4a7ec81a":"tsfresh_train = tsfresh_train[list(relevant_train_features)]\ntsfresh_test = tsfresh_test[list(relevant_train_features)]","c728ae8d":"print(tsfresh_train.shape)\ntsfresh_test.head()","565fa38a":"fac_surfaces, surfaces = y_train['surface'].factorize()\ntrain_data = lgb.Dataset(tsfresh_train, label=fac_surfaces)\nparams={'learning_rate': 0.1, 'objective':'multiclass', 'metric':'multi_error', \n        'num_class':9, 'verbose': 1, 'random_state':311,\n        'bagging_fraction': 0.7, 'feature_fraction': 1.0}\nnum_round = 15000\nlight = lgb.train(params, train_data, num_round)\npred = light.predict(tsfresh_test)\nfeature_importances = light.feature_importance()\nfeature_names = tsfresh_test.columns.values","374db772":"pred[:,0].shape\nfac_surfaces, surfaces = y_train['surface'].factorize()\nfinal_pred = pd.Series(np.argmax(pred, axis=1))\nsurface_dict = {}\nfor n, s in enumerate(surfaces):\n    surface_dict[n] = s\nfinal_pred = final_pred.map(surface_dict)","17a0820c":"submission = pd.DataFrame({\n        \"series_id\": list(range(3816)),\n        \"surface\": final_pred\n})\n\nsubmission.to_csv('submission.csv', index=False)","5088104c":"![](https:\/\/s3.eu-north-1.amazonaws.com\/ammar-files\/kaggle-kernels\/Help-Navigate-Robots+-+65th-Place+Solution\/robc-1.jpg)\n\nThis is my simple solution to \"CareerCon 2019 - Help Navigate Robots\" competition which achieved the 65th place on the private leaderboard. \n\nIt uses **tsfresh** to extract and select features from our time-series data. tsfresh calculates a lot of features with many parameters including the minimum value of the signal, the maximum, standard deviation, approximate entropy, skewness, number of peaks, etc. \n\nAfter that, LightGBM is used to build the model and generate predictions. The generated predictions are the probabilities of each type of surfaces for each test case. The surface with the highest probability was chosen.","47b08dc2":"# Moeling and Generating Final Preictions","2a6029fe":"# Feature Extraction and Selection Using tsfresh","845e2804":"# Importing Libraries and Reading Data"}}