{"cell_type":{"ba4d37d9":"code","ddab97de":"code","8db0038c":"code","c3eaeea3":"code","24c2c329":"code","785e7dce":"code","551663c5":"code","a522338f":"code","a1c88f94":"code","d401eadf":"code","1c443040":"code","ec001251":"markdown"},"source":{"ba4d37d9":"import matplotlib.pyplot as plt\nimport numpy as np\n\nimport torch\nimport torchvision\nfrom  torchvision.datasets import ImageFolder \nimport torchvision.transforms as transforms\nfrom torch.utils.data import DataLoader\nimport torch.nn as nn\nimport torch.optim as optim\nfrom copy import deepcopy","ddab97de":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nprint(device)","8db0038c":"transform = transforms.Compose([\n      transforms.ToTensor(),\n      transforms.Normalize((0.5,0.5,0.5), (0.5, 0.5, 0.5)),\n])\n\ntrain_set = ImageFolder('..\/input\/sports-classification\/train', transform = transform)\ntest_set = ImageFolder('..\/input\/sports-classification\/test', transform = transform)\nvalid_set = ImageFolder('..\/input\/sports-classification\/valid', transform = transform)\n","c3eaeea3":"num_classes = 73","24c2c329":"from torchvision import models","785e7dce":"!pip install efficientnet_pytorch","551663c5":"from efficientnet_pytorch import EfficientNet","a522338f":"def evaluation(dataloader, model):\n    total, correct = 0, 0\n    for data in dataloader:\n        inputs, labels = data\n        inputs, labels = inputs.to(device), labels.to(device)\n        outputs = model(inputs)\n        _, pred = torch.max(outputs.data, 1)\n        total += labels.size(0)\n        correct += (pred == labels).sum().item()\n    return 100 * correct \/ total","a1c88f94":"batch_size = 16\n\niterations = []\naccuracies = []\nlosses = []\n\ntrainloader = DataLoader(train_set, batch_size = batch_size, shuffle =  True)\nvalloader = DataLoader(valid_set, batch_size = batch_size, shuffle = True)\ntestloader = DataLoader(test_set, batch_size = batch_size, shuffle = True)\n\nmodel = EfficientNet.from_pretrained('efficientnet-b4')\n\nfor param in model.parameters():\n    param.required_grad = False\n\nin_features = model._fc.in_features\nmodel._fc = nn.Linear(in_features, num_classes)\n\nmodel = model.to(device)\nloss_fn = nn.CrossEntropyLoss()\nopt = optim.Adam(model.parameters(), lr = 0.0001)\n\nloss_epoch_arr = []\nmax_epochs = 4\n\nmin_loss = 1000000\n\nn_iters = np.ceil(10436\/batch_size)*max_epochs\niters = 0\n\nfor epoch in range(max_epochs):\n\n    for i, data in enumerate(trainloader, 0):\n        iters += 1\n        inputs, labels = data\n        inputs, labels = inputs.to(device), labels.to(device)\n\n        opt.zero_grad()\n\n        outputs = model(inputs)\n        loss = loss_fn(outputs, labels)\n        loss.backward()\n        opt.step()\n        \n        if iters % 100 == 0:\n            curAccuracy =  evaluation(valloader, model)\n            curLoss = loss.item()\n            iterations.append(iters)\n            accuracies.append(curAccuracy)\n            losses.append(curLoss)\n            print('Iteration: %d\/%d, Loss: %0.2f, Validation acc: %0.2f'%(iters,n_iters, curLoss, curAccuracy))\n        \n        del inputs, labels, outputs\n        torch.cuda.empty_cache()\n    loss_epoch_arr.append(loss.item())\n    print('Epoch: %d\/%d ended. Validation acc: %0.2f, Train acc: %0.2f' % (\n      epoch+1, max_epochs, \n      evaluation(valloader, model), \n      evaluation(trainloader, model)))\n    \nprint('\\n\\nTest Accuarcy on final model: %0.4f' % evaluation(testloader, model))","d401eadf":"plt.plot(iterations,losses)\nplt.xlabel('Iteration number')\nplt.ylabel('Loss')\nplt.title('Loss graph')\nplt.show()","1c443040":"plt.plot(iterations,accuracies)\nplt.xlabel('Iteration number')\nplt.ylabel('Accuracy')\nplt.title('Accuracy graph')\nplt.show()","ec001251":"## Author: Yaswanth Phani Kommineni\n### Model details\n#### Model: EfficientNet - b4\n#### Batch Size: 16\n#### Epochs: 4\n#### Gradient Descent Algorithm: Adam (Learning Rate = 0.0001)"}}