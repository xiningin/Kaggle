{"cell_type":{"d20c6331":"code","255cb470":"code","c57a0de3":"code","c8b2eb47":"code","163befa4":"code","1192d22d":"code","e6554e0e":"code","81c4960f":"code","7f46b7eb":"code","eb399b8b":"code","95449f1a":"code","117782dd":"code","6621d92a":"code","c0370e79":"code","30f0bc49":"code","1c7ee3ba":"code","268711d0":"code","b7e6edd4":"code","74fb658b":"code","23843d65":"code","13ae0a33":"code","a4bf613b":"code","09740e62":"code","fc879a3a":"code","5c3948f5":"code","89afbd4b":"code","8982c839":"code","3fd9ae1a":"code","cd7f8650":"code","801ce2e7":"code","1a78eddd":"code","1d7adb47":"code","82743a7a":"code","0ce01645":"code","6792769c":"code","b8dab094":"code","0466186e":"code","406a6344":"code","128eee2a":"code","42168184":"code","6da7b042":"code","7962c14f":"code","fd12d8cb":"code","70da34a2":"code","32635f49":"code","a7336640":"code","8ad3673d":"code","e7444931":"code","a737321b":"code","2d194a72":"code","ca1df326":"code","7ffada7a":"code","7d284383":"code","d5fbdd83":"code","d2503c21":"code","275d0068":"code","b88c3938":"code","4b84d3c2":"code","857048f7":"markdown","e9df0cec":"markdown","beb63617":"markdown","bfc5f929":"markdown","1f5deb87":"markdown","bd346451":"markdown","f8d803a5":"markdown","9e5dcda5":"markdown","72453739":"markdown","ab632173":"markdown","9b5eed28":"markdown","c2dfcc83":"markdown"},"source":{"d20c6331":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","255cb470":"df = pd.read_csv('..\/input\/loan-prediction-based-on-customer-behavior\/Training Data.csv')","c57a0de3":"df","c8b2eb47":"def unclean_names(col):\n    unclean_names = []\n    for name in df[str(col)].unique():\n        if name.endswith(']'):\n            unclean_names.append(name)\n    return unclean_names","163befa4":"unclean_city_names = unclean_names('CITY')\nunclean_city_names","1192d22d":"unclean_state_names = unclean_names('STATE')\nunclean_state_names","e6554e0e":"def clean_df(df,col,unclean_list):\n    for index,name in enumerate(df[col]):\n        if name in unclean_list:\n            if name.endswith(']'):\n                name_ = name.strip('[]0123456789')\n                df[col].iloc[index] = name_","81c4960f":"clean_df(df,'STATE',unclean_state_names)","7f46b7eb":"clean_df(df,'CITY',unclean_city_names)","eb399b8b":"df['Age'].plot(kind='hist',figsize=(10,8))\nplt.xlabel('Age')","95449f1a":"df['Income'].plot(kind='box')","117782dd":"df['Income'].plot(kind='hist')","6621d92a":"df['CURRENT_JOB_YRS'].plot(kind='box')","c0370e79":"df['CURRENT_HOUSE_YRS'].plot(kind='box')","30f0bc49":"df['Experience'].plot(kind='box')","1c7ee3ba":"fig = plt.figure()\nax1 = fig.add_subplot(2,1,1,anchor='C')\nplt.title('Information')\ndf.groupby('Risk_Flag').count()['Id'].plot(kind='pie',labels=['Non-Defaulter','Defaulter'],autopct='%1.1f%%',ax=ax1,figsize=(10,10))\nplt.xlabel('% of Defaulters')\nplt.ylabel('')\nplt.legend(loc='right',bbox_to_anchor=(0.7,0,1,1))\nax2 = fig.add_subplot(2,1,2,anchor='S')\ndf.groupby('Risk_Flag').count()['Id'].plot(kind='bar',ax=ax2)\nplt.xlabel('Defaulters')\nplt.ylabel('Count')\nfor index,value in enumerate(df.groupby('Risk_Flag').count()['Id']):\n    plt.text(index-0.08,value+10000,str(value))\nplt.ylim(0,250000)\nplt.show()","268711d0":"df.groupby('Married\/Single').count()['Id'].plot(kind='pie',startangle=0,labels=['Married','Single'],autopct='%1.1f%%',colors=['Pink','Teal'])\nplt.ylabel('')\nplt.xlabel('Marital Status')\nplt.title('Total % of Customers who are married\/single')\nplt.legend(loc='best',bbox_to_anchor=(1,0,0.5,0.5))\nplt.show()","b7e6edd4":"df.loc[df['Risk_Flag'] == 1].groupby('Married\/Single').count()['Id']","74fb658b":"marital_status = df.loc[df['Risk_Flag'] == 1].groupby('Married\/Single').count()['Id']\nmarital_status.plot(kind='pie',startangle=0,labels=['Married','Single'],autopct='%1.1f%%')\nplt.ylabel('')\nplt.xlabel('Marital Status')\nplt.title('Loan Defaulters % by Marital Status')\nplt.legend(loc='best',bbox_to_anchor=(1,0,0.5,0.5))\nplt.show()","23843d65":"house_ownership_count = df.groupby('House_Ownership').count()['Id']\nhouse_ownership_count = [231898,7184,12918]","13ae0a33":"sns.countplot(data=df,x='House_Ownership',hue='House_Ownership',)\nplt.text(-0.4,235000,str(231898))\nplt.text(0.9,10000,str(7184))\nplt.text(2.14,16000,str(12918))\nplt.title('House Ownership of All Customers')\nplt.ylim(0,250000)","a4bf613b":"df.loc[df['Risk_Flag'] == 1].groupby('House_Ownership').count()['Id']","09740e62":"sns.countplot(data=df.loc[df['Risk_Flag'] == 1],x='House_Ownership',hue='House_Ownership')\nplt.text(-0.4,30000,str(29121))\nplt.text(0.9,2000,str(1160))\nplt.text(2.14,1800,str(715))\nplt.ylim(0,35000)\nplt.title('House Ownership of Loan Defaulting Customers')\nplt.show()","fc879a3a":"df.groupby('House_Ownership').count()['Id'].plot(kind='pie',startangle=0,autopct='%1.1f%%',figsize=(5,5))\nplt.ylabel('')\nplt.xlabel('House Ownership')\nplt.title('House Ownership % of Customers')\nplt.legend(loc='best',bbox_to_anchor=(1,0,0.5,0.5))","5c3948f5":"df.loc[df['Risk_Flag'] == 1].groupby('House_Ownership').count()['Id'].plot(kind='pie',startangle=0,autopct='%1.1f%%',figsize=(5,5))\nplt.ylabel('')\nplt.title('House Ownership % of Loan Defaulters')\nplt.xlabel('House Ownership')\nplt.legend(loc='best',bbox_to_anchor=(1,0,0.5,0.5))","89afbd4b":"car_ownership = df.groupby('Car_Ownership').count()['Id']\ncar_ownership","8982c839":"sns.countplot(data=df,x='Car_Ownership',hue='Car_Ownership')\nplt.text(-0.3,177000,str(176000))\nplt.text(1.1,78000,str(78000))\nplt.ylim(0,200000)\nplt.title('Car Ownership of All Customers')\nplt.show()","3fd9ae1a":"car_ownership.plot(kind='pie',startangle=0,labels=['Do not Own','Own'],autopct='%1.1f%%')\nplt.ylabel('')\nplt.xlabel('Car Ownership')\nplt.title('Car Ownership % of All Customers')\nplt.legend(loc='best',bbox_to_anchor=(1,0,0.5,0.5))\nplt.show()","cd7f8650":"car_ownership_default = df.loc[df['Risk_Flag'] == 1].groupby('Car_Ownership').count()['Id']\ncar_ownership_default.plot(kind='pie',startangle=0,labels=['Do not Own','Own'],autopct='%1.1f%%')\nplt.ylabel('')\nplt.xlabel('Car Ownership')\nplt.title('Car Ownership % of Loan Defaulting Customers')\nplt.legend(loc='best',bbox_to_anchor=(1,0,0.5,0.5))\nplt.show()","801ce2e7":"df1 = df.loc[df['Risk_Flag'] == 1].groupby(['STATE','Risk_Flag']).count()\ndf1.rename(columns={'Id':'Total_Defaulters'},inplace=True)\ndf1.reset_index(inplace=True)\ndf1[['STATE','Total_Defaulters']]","1a78eddd":"df2 = df.groupby('STATE').count()\ndf2.rename(columns={'Id':'Total_Loans'},inplace=True)\ndf2.reset_index(inplace=True)","1d7adb47":"df_total_loans = df2[['STATE','Total_Loans']].sort_values(by='Total_Loans',ascending=False)[:10]\ndf_total_loans.plot(kind='bar',x='STATE',figsize=(10,8))\nplt.title('Top 10 States from where most loans were taken')\nplt.xlabel('Number of Loans')\nplt.ylabel('State')\nfor index,value in enumerate(df_total_loans['Total_Loans'][:10]):\n    plt.text(index-0.28,value+100,str(value))\nplt.show()","82743a7a":"defaulter_percent_per_state = (df1['Total_Defaulters']\/df2['Total_Loans']).round(4)*100\nstate_defaulters_percentage=pd.DataFrame(\n    data=zip(df1['STATE'],defaulter_percent_per_state),\n    columns=['STATE','Defaulter_Percentage']\n)\ndf_dps = state_defaulters_percentage.sort_values(by='Defaulter_Percentage',ascending=False)[:10]\ndf_dps.plot(kind='bar',figsize=(10,8),x='STATE')\nplt.title('Top 10 States in Defaulting Loan')\nplt.ylabel('% of Loans Defaults')\nplt.xlabel('State')\nfor index,value in enumerate(df_dps['Defaulter_Percentage'][:10]):\n    plt.text(index-0.2,value+0.2,str(round(value,2)))\nplt.legend(loc='best')\nplt.show()","0ce01645":"df3 = df.groupby('CITY').count()\ndf3.rename(columns={'Id':'Total_Loans'},inplace=True)\ndf3.reset_index(inplace=True)\ndf3[['CITY','Total_Loans']]","6792769c":"#top10 cities in number of loans\n\ndf3_ = df3[['CITY','Total_Loans']].sort_values(\n                        by='Total_Loans',ascending=False)[:10]\ndf3_.plot(kind='bar',x='CITY',figsize=(8,6))\nplt.title('Top 10 Cities with highest number of Loans taken')\nplt.xlabel('City')\nplt.ylabel('Number of Loan')\nfor index,value in enumerate(df3_['Total_Loans']):\n    plt.text(index-0.25,value+30,str(int(value)))\nplt.legend(loc='best')\nplt.show()","b8dab094":"df4 = df.loc[df['Risk_Flag'] == 1].groupby('CITY').count()\ndf4.rename(columns={'Id':'Total_Defaulters'},inplace=True)\ndf4.reset_index(inplace=True)\ndf4[['CITY','Total_Defaulters']]","0466186e":"defaulter_percent_per_city = (df4['Total_Defaulters']\/df3['Total_Loans']).round(4)*100\ncity_defaulters_percentage=pd.DataFrame(\n    data=zip(df3['CITY'],defaulter_percent_per_city),\n    columns=['CITY','Defaulter_Percentage']\n)\ncity_defaulters_percentage","406a6344":"city_defaulters_percentage.sort_values(by='Defaulter_Percentage',ascending=False)[:10].plot(kind='bar',x='CITY',figsize=(10,6))\nplt.title('Top 10 Cities in Defaulting Loans')\nplt.xlabel('City')\nplt.ylabel('% of Loan Defaults')\nplt.legend(loc='best')\ntop_10_vals = city_defaulters_percentage['Defaulter_Percentage'].sort_values(ascending=False)[:10]\nfor index,value in enumerate(top_10_vals):\n    plt.text(index-0.2,value+0.5,str(round(value,2)))\nplt.show()","128eee2a":"df_profession_loan_count = df.groupby('Profession').count()['Id'].sort_values(ascending=False)\ndf_plc = df_profession_loan_count.reset_index()\ndf_plc.rename(columns= {'Id':'Loan_Count'},inplace=True)\ndf_plc[:10].plot(kind='bar',x='Profession',figsize=(10,10))\nplt.legend(loc='best')\nplt.title('Top 10 Professions who took Loan')\nplt.xlabel('Loan Count')\nplt.ylabel('Profession')\nfor index,value in enumerate(df_plc['Loan_Count'][:10]):\n    plt.text(index-0.2,value+50,str(value))\nplt.show()   ","42168184":"profession = df.groupby(['Profession']).mean()[['Income','Risk_Flag']]","6da7b042":"#plotting top10 profession_group with higher income\n\nprofession_top10_income = profession['Income'].sort_values(ascending=False)[:15]\nprofession_top10_income.plot(kind='barh',figsize=(10,10))\nplt.title('Top 15 Profession with higher Income (mean)')\nplt.xlabel('Profession')\nplt.ylabel('Income')\n\nfor index,value in enumerate(profession_top10_income):\n    plt.text(value-900000,index-0.1,str(int(value)))\nplt.legend(loc='best')\nplt.show()","7962c14f":"df_ = df.loc[df['Risk_Flag'] == 1].groupby(['Profession']).mean()[['Income']].sort_values(by='Income',ascending=False)\ndf_.sort_values(by='Income',ascending=False)[:15].plot(kind='barh',figsize=(10,10))\nplt.title('Mean Income of Top 15 Loan Defaulting Professions') \nplt.xlabel('Income')\nplt.ylabel('Profession')\nfor index,value in enumerate(df_['Income'][:15]):\n    plt.text(value-900000,index-0.1,str(int(value)))\n\nplt.legend(loc='best')\nplt.show()","fd12d8cb":"from imblearn.over_sampling import RandomOverSampler","70da34a2":"sampler = RandomOverSampler(random_state=42,sampling_strategy=0.45)\nX = df.iloc[:,:-1]\ny = df['Risk_Flag']","32635f49":"X_sampled,y_sampled = sampler.fit_resample(X,y)","a7336640":"from collections import Counter\nprint(Counter(y),Counter(y_sampled))","8ad3673d":"df_ = pd.concat([X_sampled,y_sampled],axis=1)","e7444931":"fig = plt.figure()\nax1 = fig.add_subplot(121)\nplt.title('Defaulter % Before Sampling')\ndf.groupby('Risk_Flag').count()['Id'].plot(kind='pie',labels=['Non-Defaulter','Defaulter'],autopct='%1.1f%%',ax=ax1,figsize=(10,10))\nplt.xlabel('% of Defaulters')\nplt.ylabel('')\n\nax2 = fig.add_subplot(122)\nplt.title('Defaulter % After Sampling')\ndf_.groupby('Risk_Flag').count()['Id'].plot(kind='pie',labels=['Non-Defaulter','Defaulter'],autopct='%1.1f%%',ax=ax2,figsize=(10,10))\nplt.xlabel('% of Defaulters')\nplt.ylabel('')\nplt.legend(loc='right',bbox_to_anchor=(0.7,0,1,1))\n","a737321b":"from sklearn.preprocessing import LabelEncoder","2d194a72":"cols_to_encode= ['Married\/Single','House_Ownership','Car_Ownership','Profession','CITY','STATE']\nlabelencoder = LabelEncoder()\n\nfor col in cols_to_encode:\n    df_[col] = labelencoder.fit_transform(df_[col])","ca1df326":"df_.isna().sum()","7ffada7a":"#Dropping Id as it's not needed in prediction\ndf_.drop(['Id'],axis=1,inplace=True)","7d284383":"df_","d5fbdd83":"X = df_.iloc[:,:-1]\ny = df_['Risk_Flag']","d2503c21":"from sklearn. model_selection import train_test_split\n\nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=42)","275d0068":"from sklearn.metrics import f1_score,classification_report,plot_confusion_matrix,plot_roc_curve","b88c3938":"from sklearn.tree import DecisionTreeClassifier\n\ndt = DecisionTreeClassifier()\ndt.fit(X_train,y_train)\npred = dt.predict(X_test)\nprint(f'F1 Score: {f1_score(y_test,pred)}\\n')\nprint(classification_report(y_test,pred))\nplot_confusion_matrix(estimator=dt,X=X_test,y_true=y_test)","4b84d3c2":"plot_roc_curve(estimator=dt,X=X_test,y=y_test)\nplt.plot([0,1],[0,1],\"--\",c='black')","857048f7":"#### Now we can see that the classes are more even which makes easier for our model to predict loan defaulters ","e9df0cec":"# Encoding the Categorical data ","beb63617":"# EDA","bfc5f929":"# Splitting the dataset into training and test set","1f5deb87":"### We've achieved the Accuracy of 91% and F1 Score of 0.87 ","bd346451":"#### Checking if there is any null exists in our dataset","f8d803a5":"# Checking for any Outliers","9e5dcda5":"![Loan Prediction EDA based on Customer Behaviour](https:\/\/miro.medium.com\/max\/735\/0*lAkevA6upQBq-NCk.jpg)\n## Loan Prediction based on Customer Behaviour [EDA+Prediction]\n## Accuracy of 91% \nHey Guys, this is the first time I'm sharing a notebook please give feedback on how can I improve this. #HappyLearning ","72453739":"# Resampling the Data with Random Oversampler","ab632173":"# Data Cleaning + EDA","9b5eed28":"# Cleaning names with special characters and numbers","c2dfcc83":"# Prediction"}}