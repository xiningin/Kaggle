{"cell_type":{"ba93658b":"code","431e741e":"code","3abc529f":"code","e97ce9e6":"code","d95d5515":"code","7dde40b4":"code","300313e8":"code","c953f176":"code","16f7154d":"code","eaec9c5e":"code","76656688":"code","aaecef2a":"code","4ef31cf7":"code","56be5fe6":"code","48e006ba":"code","25289f2a":"code","8a265581":"code","d4ea87ef":"code","3ca6deb3":"code","b919caac":"code","5c0e16e1":"code","307f2f77":"code","147a10f6":"code","617a201f":"code","78f750de":"code","fc972a18":"code","c07f00e2":"code","52c40a6c":"code","1c7b4330":"code","da17cb2c":"code","652cb469":"code","d921b689":"code","e3cacd27":"code","c31be2b5":"code","11f40a35":"code","e42a5c2d":"code","80ce83fe":"code","fd27bc45":"code","d92dc429":"code","b3d50808":"code","2191ccb8":"code","cd9f58f4":"code","f177211a":"code","bf9dba30":"code","5269a6e0":"code","b50fee73":"code","0221292e":"code","879730d8":"code","a6bc58f8":"code","9bb43ad4":"code","e32db4a0":"code","115577ca":"code","9da1aa06":"code","823fd045":"code","d83dd46d":"code","2b79ee99":"code","f23197e8":"code","3dea80e5":"code","8e95e7f6":"code","0b6c68b4":"code","a49ebcb3":"code","9cf240fc":"code","126fee37":"code","05208a05":"code","7fe6c4de":"code","041e7222":"code","9f5c73d0":"code","17714b90":"markdown","d81f4b57":"markdown","e42bd6d9":"markdown","d08c6448":"markdown","36cf81e2":"markdown","7fc3d6ad":"markdown","6e0d3cc2":"markdown","fe179960":"markdown","8f86b107":"markdown","318e0511":"markdown","9472a0d1":"markdown","1257e1e8":"markdown","69ff5b14":"markdown","3631d275":"markdown","015a2623":"markdown","f110846f":"markdown","f1b66e48":"markdown","4642a106":"markdown","289b176a":"markdown","2768017d":"markdown","a5d46037":"markdown","07ba6e74":"markdown","a8efe852":"markdown","e5904e24":"markdown","7ba02f0a":"markdown","3b1dd08b":"markdown","de376a33":"markdown","0320b330":"markdown","4f865de9":"markdown","c54ec571":"markdown","d092d42f":"markdown","cb25aebc":"markdown","88afd0a5":"markdown","05b3ddde":"markdown","c0d477b7":"markdown","1451a587":"markdown","33701365":"markdown","19d4d628":"markdown","1fe275eb":"markdown","ddbf6d5e":"markdown","9b2e47d9":"markdown"},"source":{"ba93658b":"import pandas as pd  # imporing pandas\nimport numpy as np  # importing numpy","431e741e":"series_1 = pd.Series([12, -4, 6, 12])  # pd.Series() is the constructor of series\nseries_1  # on left there are indexes and on right the corresponding data we stored","3abc529f":"series_2 = pd.Series([12, -4, 6, 12], index = [\"a\", \"b\", \"c\", \"d\"])  # index = array of labels(strings)\nseries_2  # # left: labels, right: data","e97ce9e6":"print(series_2.values)  # gives values of series\nprint(series_2.index)  # gives labels","d95d5515":"print(series_2[2])  # calling element using index number, labelling does not mean values are not indexed\nprint(series_2[\"b\"])  # calling element using its label\nprint(series_2[0:2])  # slicing arrays using index\nprint(series_2[[\"a\", \"d\"]])  # selecting elements of an array","7dde40b4":"series_2[1] = 0  # assigning value to array element using index\nseries_2[\"d\"] = 0  # assigning value to array element using label\nprint(series_2)","300313e8":"np_arr = np.arange(10, 15)  # creating a numpy array\nprint(np_arr)\nseries_3 = pd.Series(np_arr)  # creating a Series from numpy array\nprint(series_3)  # created series is not a copy, just a view (passed by reference)","c953f176":"series_4 = pd.Series(series_2)  # creating a series from another series\nseries_2[0] = 1000  # changing an element of series_2\nprint(series_4)  # change replicated in series_4 as well","16f7154d":"print(series_4 == 0)  # checking each element for certain conditions\nprint(series_4[series_4 == 0])  # making an array object of elements who meet the given condition","eaec9c5e":"series_5 = pd.Series([12, -4, 6, 12], index = [\"a\", \"b\", \"c\", \"d\"])\nprint(series_5)\nseries_5 += 6  # (+, -, *, \/, etc) are applicable on Series\nprint(series_5)","76656688":"print(np.log(series_5))  # finding logarithm\nprint(np.tan(series_5))  # finding tan of angles","aaecef2a":"series_6 = pd.Series([1, 0, 1, 3, 5, 4, 7],\n                     index = [\"black\", \"white\", \"white\", \"yellow\", \"blue\", \"blue\", \"grey\"])\nprint(series_6)\nseries_6.unique()  # only checks values for duplication, not index","4ef31cf7":"series_6.value_counts()  # value_counts() return unique values and their frequency in Series","56be5fe6":"series_6.isin([0, 1])\n# isin() takes an array as argument and tells whether the values of array are contained in Series","48e006ba":"series_6[series_6.isin([0, 1])]  # can be used for filtering Series","25289f2a":"series_7 = pd.Series([5, 0, -1, np.NaN, 9])\nprint(series_7)","8a265581":"print(series_7.isnull())  # isnull() returns whether the elements are NaN or not\nprint(series_7.notnull())  # opposite of isnull(), checks of not NaN values","d4ea87ef":"print(series_7[series_7.isnull()])  # filtering\nprint(series_7[series_7.notnull()])","3ca6deb3":"my_dict = {\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\", \"key 4\": \"value 4\"}\nseries_8 = pd.Series(my_dict)\nprint(series_8)","b919caac":"key_list = [\"key 5\", \"key 4\", \"key 3\", \"key 2\"]  # no \"key 1\" in key list\nseries_9 = pd.Series(my_dict, index = key_list)  # resulted series will not have \"key 1\" and its value\nprint(series_9)","5c0e16e1":"color_dict = {\"orange\": 400, \"black\": 600, \"white\": 800, \"red\": 600}\nseries_10 = pd.Series(color_dict)  # creating first series\ncolor_dict2 = {\"white\": 300, \"black\": 600, \"yellow\": 300, \"green\": 700}\nseries_11 = pd.Series(color_dict2)  # creating second series\nprint(series_10)\nprint(series_11)\nseries_12 = series_10 + series_11  # all mathematical operations possible here\nprint(series_12)","307f2f77":"data = {\"colors\" : [\"blue\", \"green\", \"red\", \"yellow\", \"white\"],\n       \"objects\" : [\"pen\", \"carpet\", \"band\", \"jelly\", \"car\"],\n       \"prices\" : [10, 3000, 12.99, 150, 1450000]}\ndf_1 = pd.DataFrame(data)  # DataFrame() is constructor method for DataFrames\ndf_1","147a10f6":"df_2 = pd.DataFrame(data, columns = [\"objects\", \"prices\"])  # creating df with only required columns\ndf_2","617a201f":"df_3 = pd.DataFrame(data, index = [\"i\", \"ii\", \"iii\", \"iv\", \"v\"])  # exlicitly indexing of a df\ndf_3","78f750de":"data_matrix = np.arange(16).reshape(4, 4)  # creating a two dimensional matrix using numpy mehtods\nindex_array = [\"row1\", \"row2\", \"row3\", \"row4\"]\ncol_array = [\"col1\", \"col2\", \"col3\", \"col4\"]\ndf_4 = pd.DataFrame(data_matrix, index_array, col_array)\ndf_4","fc972a18":"data = {\"colors\" : [\"blue\", \"green\", \"red\", \"yellow\", \"white\"],\n       \"objects\" : [\"pen\", \"carpet\", \"band\", \"jelly\", \"car\"],\n       \"prices\" : [10, 3000, 12.99, 150, 1450000]}\ndf_5 = pd.DataFrame(data)\ndf_5","c07f00e2":"print(df_5.columns)  # returns an array containing all column names\nprint(df_5.index)  # gives an array of index attribute (row index)\nprint(df_5.values)  # gives the data matrix","52c40a6c":"print(df_5[\"prices\"])  # to select only one column from the df\nprint(df_5.prices)  # another way of doing the same","1c7b4330":"print(df_5.loc[3])  # to select a certain row, we use loc attribute as df.loc[<row index>]\nprint(df_5.loc[[1,4]])  # to select multiple rows, loc[[<row index1, row index2,...>]]","da17cb2c":"print(df_5[1:3])  # [<start index>, <end index>]","652cb469":"print(df_5[\"prices\"][4])  # [<col name>][<index>]","d921b689":"print(df_5)  # using previously defined df","e3cacd27":"df_5.index.name = \"id\"  # gives a name to the index array\ndf_5.columns.name = \"items\"  # gives a name to the column array\nprint(df_5)","c31be2b5":"data = {\"colors\" : [\"blue\", \"green\", \"red\", \"yellow\", \"white\"],\n       \"objects\" : [\"pen\", \"carpet\", \"band\", \"jelly\", \"car\"],\n       \"prices\" : [10, 3000, 12.99, 150, 1450000]}\ndf_6 = pd.DataFrame(data)  # DataFrame() is constructor method for DataFrames\ndf_6","11f40a35":"df_6[\"qty.\"] = 12  # adds a new column, since we give only one value, all indexes will have same value\nprint(df_6)","e42a5c2d":"df_6[\"qty.\"] = [10, 3, 12, 2, 1]  # to pass unique value for each index, we give an array\nprint(df_6)","80ce83fe":"df_6[\"completion\"] = np.linspace(20, 100, 5)\nprint(df_6)","fd27bc45":"df_6[\"prices\"][3] = 179\nprint(df_6)","d92dc429":"data = {\"colors\" : [\"blue\", \"green\", \"red\", \"yellow\", \"white\"],\n       \"objects\" : [\"pen\", \"carpet\", \"band\", \"jelly\", \"car\"],\n       \"prices\" : [10, 3000, 12.99, 150, 1450000]}\ndf_7 = pd.DataFrame(data)  # DataFrame() is constructor method for DataFrames\ndf_7","b3d50808":"df_7.isin([\"white\", \"band\", 150])  # like in Series, we can check for a certain value in df (returns bool)","2191ccb8":"df_7[df_7.isin([\"white\", \"band\", 150])]  # filtering on the basis of membership","cd9f58f4":"df_7","f177211a":"del df_7[\"colors\"]  # deleting column named \"colors\"\ndf_7","bf9dba30":"data = {\"colors\" : [\"blue\", \"green\", \"red\", \"yellow\", \"white\"],\n       \"objects\" : [\"pen\", \"carpet\", \"band\", \"jelly\", \"car\"],\n       \"prices\" : [10, 3000, 12.99, 150, 1450000]}\ndf_8 = pd.DataFrame(data)  # DataFrame() is constructor method for DataFrames\ndf_8","5269a6e0":"df_8[df_8.prices > 1000]  # filtering for the prices higher than 1000","b50fee73":"nest_dict = {\"red\": {1990: 20, 2000: 30, 2010: 40, 2020: 50},\n            \"blue\": {1990: 10, 2000: 30, 2010: 20, 2020: 30},\n            \"white\": {1990: 70, 2000: 40, 2010: 40, 2020: 20}}\ndf_9 = pd.DataFrame(nest_dict)  # keys of main dict: columns, keys of nested dict: rows\ndf_9","0221292e":"nest_dict = {\"red\": {1990: 20, 2010: 40, 2020: 50},\n            \"blue\": {1990: 10, 2000: 30, 2010: 20},\n            \"white\": {2000: 40, 2010: 40, 2020: 20}}\ndf_10 = pd.DataFrame(nest_dict)  # python compensates for missing key-value pair of nested dicts, with NaN\ndf_10","879730d8":"df_10.T  # columns become rows and rows become columns, method 'T' is used for this","a6bc58f8":"series_13 = pd.Series([2, 5, 0, 9, 18], index = [\"red\", \"green\", \"white\", \"blue\", \"yellow\"])\nprint(series_13.index)  # index objects are immutable (labels can be changed, index can not)","9bb43ad4":"print(series_13.idxmax())\nprint(series_13.idxmin())","e32db4a0":"series_14 = pd.Series(range(6), index = [\"white\", \"white\", \"blue\", \"green\", \"green\", \"yellow\"])\nprint(series_14)","115577ca":"series_14[\"green\"]  # returns series of elements, if there are multiple values of same label\n# same logic applies to df, it will return a data frame, instead of a line.","9da1aa06":"print(series_14.index.is_unique)  # checks for duplications in index array\nseries_15 = pd.Series(range(3), index = [1, 2, 3])\nprint(series_15.index.is_unique)","823fd045":"series_16 = pd.Series([2, 4, 6, 8], index = [\"a\", \"b\", \"c\", \"d\"])\nprint(series_16)","d83dd46d":"series_17 = series_16.reindex([\"d\", \"b\", \"f\", \"a\"])  # reindexing does not mean only changing the label\nseries_17  # reindexing changes the sequence with which values appear in the array","2b79ee99":"series_18 = pd.Series([1, 4, 6, 3], index = [0, 2, 4, 6])\nprint(series_18)\nseries_19 = series_18.reindex(range(6), method = \"ffill\")\nprint(series_19)  # missing index have the value of above available index, like index 1 has value of 0","f23197e8":"series_18 = pd.Series([1, 4, 6, 3], index = [0, 2, 4, 6])\nprint(series_18)\nseries_20 = series_18.reindex(range(6), method = \"bfill\")\nprint(series_20)  # missing index have the value of next available index, like index 1 has value of 2","3dea80e5":"data = {\"colors\" : [\"blue\", \"green\", \"red\", \"yellow\", \"white\"],\n       \"objects\" : [\"pen\", \"carpet\", \"band\", \"jelly\", \"car\"],\n       \"prices\" : [10, 3000, 12.99, 150, 1450000]}\ndf_11 = pd.DataFrame(data)\ndf_11\n\n","8e95e7f6":"df_12 = df_11.reindex(range(6), method = \"bfill\", columns = [\"objects\", \"colors\", \"prices\", \"total\"])\ndf_12","0b6c68b4":"series_21 = pd.Series(np.arange(4.), index = [\"apple\", \"banana\", \"candy\", \"dog\"])\nprint(series_21)\nseries_22 = series_21.drop(\"candy\")  # drop([\"candy\", \"banana\"]) for two or more\nprint(series_22)","a49ebcb3":"df_11 = pd.DataFrame(np.arange(16).reshape((4, 4)),\n                    index = [\"red\", \"blue\", \"green\", \"yellow\"],\n                    columns = [\"ball\", \"band\", \"basket\", \"shirt\"])\nprint(df_11)","9cf240fc":"df_12 = df_11.drop(\"green\") # to delete a row, drop([\"row1\", \"row2\"]) for multiple row drops\ndf_12","126fee37":"df_13 = df_11.drop([\"ball\", \"basket\"], axis = 1)  # for columns, we add axis = 1 in argument\ndf_13","05208a05":"series_23 = pd.Series([3,2,5,1],['white','yellow','blue','green'])\nseries_24 = pd.Series([1,4,7,2,1],['white','yellow','black','blue','brown'])","7fe6c4de":"series_23 + series_24  # resulted series will sum for common elements and for uncommon it returns NaN","041e7222":"df_14 = pd.DataFrame(np.arange(16).reshape((4, 4)),\n                    index = [\"red\", \"blue\", \"green\", \"yellow\"],\n                    columns = [\"ball\", \"band\", \"cap\", \"shirt\"])\ndf_15 = pd.DataFrame(np.arange(10, 22).reshape((3, 4)),\n                    index = [\"red\", \"white\", \"green\"],\n                    columns = [\"ball\", \"band\", \"basket\", \"shirt\"])\nprint(df_14)\nprint(df_15)","9f5c73d0":"df_14 + df_15  # for DataFrames, it will sum the values with similar labels on both, rows and columns","17714b90":"### DataFrame from Nested dict\nWe can also create a DataFrame using a nested dictionary, if we want to explicitly assign index names","d81f4b57":"### Assigning Values\nWe follow the same logic to add or change the values in it, as of selecting elements.","e42bd6d9":"### Other Functionalities on Indexes","d08c6448":"**selecting row**","36cf81e2":"**extending this concept to DataFrames**","7fc3d6ad":"## The DataFrame","6e0d3cc2":"**index with duplicate lebels** - in a series or a data frame there can be two data points having similar labels","fe179960":"The dataframe is a tabular data structure very similar to a spreadsheet. This data structure is designed to extend series to multiple dimensions.\n\nUnlike series, which have an index array containing labels associated with each element, the dataframe has two index arrays. The first index array is associated with the rows, and other with columns.\n\nA dataframe may also be understood as a dict of series, where the keys are the column names and the values are the series that will form the columns of the dataframe. Furthermore, all elements in each series are mapped according to an array of labels, called the index.","8f86b107":"## The Series\nThe series is designed to represent one-dimensional data structures.\n\nIt is composed of two arrays associated with each other. The main array holds the data (data of any NumPy dtype) to which each element is associated with a label, contained within the other array, called the index.","318e0511":"## pandas Data Structures","9472a0d1":"**Foreword:**\nHello Fellow-Kagglers, this notebook tends to give a basic understanding of Data Structures pandas provides us and how they can be used.","1257e1e8":"for mathematical functions we need to pass fuctions referenced with NumPy, 'np'","69ff5b14":"**selecting a portion of data frame**","3631d275":"#### Arithmatic and Data Allignment\npandas can align indexes coming from two different data structures. This is very helpful when we want to do operations between two data structures.","015a2623":"### Operations between Series\nIn this case, even the labels come into play. Operation will be applied on the values whose indexes are common in both operands. For uncommon indexes, resulted series will have NaN value.","f110846f":"### Transposition of DataFrame","f1b66e48":"## The Index Objects","4642a106":"**selecting columns**","289b176a":"### Filtering Values","2768017d":"### Evaluating Values\nA series may have duplicate values too, unique() method is applied to return an array(not necessarily ordered) with all unique elements of the Series.","a5d46037":"### Defining a Series from NumPy Arrays and Other Series","07ba6e74":"Another way of creating a DataFrame is to provide three constructors as an arguments of constructor method.\n1. Data matrix  2. Index array  3. Column array","a8efe852":"### Operations and Mathematical Functions:","e5904e24":"## Importing pandas","7ba02f0a":"**automatic reindexing** - when given data structure has missing labels for indexing we often need to interpolate those values","3b1dd08b":"### Filtering","de376a33":"### Series as Dictionaries\nAn alternative way to think of a Series is to think it as an object of dict(). In fact, we can create a Series using pre-defined dictionary.","0320b330":"The heart of pandas is its two primary data structures: Series & Dataframes","4f865de9":"**adding a new column**","c54ec571":"### Membership of a Value","d092d42f":"<b>index option<\/b> : we can provide index in constructor if we want to give our data meaningful labels rather than default numerical indexes.","cb25aebc":"We can index the created series from the dict ourselves as well. By doing this we can change the order of array to our index order and if for some given index there is not any value, Python will give an NaN there.","88afd0a5":"### NaN Values\nThis specific value NaN (Not a Number) is used in pandas data structures to indicate the presence of an empty field or something that\u2019s not definable numerically.\n\nThese NaN values are a problem and must be managed in some way, especially during data analysis. However, pandas allows you to explicitly define NaNs and add them to a data structure, such as a series.\n\nnp.Nan is used to enter NaN value to the array","05b3ddde":"### Defining a DataFrame\nIn fact, the most common way of creating a new dataframe is using a dict object. Keys of the dictionary will represent columns and values will be in the form array whose each element will represent data point for corresponding index of the data frame.","c0d477b7":"### Declaring a Series","1451a587":"### Selecting Elements","33701365":"**selecting single value**","19d4d628":"#### Reindexing\nWe have learnt before that index is an immutable object but we can do a similar job by using reindex() method. It gives a new series with changed index. We can change the order of indexes, add\/remove indexes,etc","1fe275eb":"**idmax() and idmin() methods on index** - return index with maximum and minimum values, respectively","ddbf6d5e":"#### Dropping\ndrop() takes label(s) as argument and return a data structure after deleting rows\/columna given.","9b2e47d9":"### Deleting a Column"}}