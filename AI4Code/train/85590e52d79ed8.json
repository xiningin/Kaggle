{"cell_type":{"5d24d668":"code","8cf99667":"code","0ccb34fa":"code","5dd4e187":"code","af5672eb":"code","8a7fae93":"code","2f6f5e74":"markdown","b539b31e":"markdown","0dda1992":"markdown","ea5b62b9":"markdown","b3ce3577":"markdown","758b7ede":"markdown","e4b92b76":"markdown","1bdb2d1a":"markdown","11b57845":"markdown"},"source":{"5d24d668":"import numpy as np\nimport pandas as pd\n\nimport time\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder, RobustScaler, StandardScaler\nfrom sklearn.linear_model import LinearRegression, ElasticNet\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\nfrom mlxtend.regressor import StackingRegressor, StackingCVRegressor","8cf99667":"# Read in data\nX = pd.read_csv('..\/input\/hdb-resale-price-prediction\/train.csv', index_col='id')\nX_test_full = pd.read_csv('..\/input\/hdb-resale-price-prediction\/test.csv', index_col='id')\ndf_add_coords = pd.read_csv('..\/input\/testing-google-maps-geocoding-api\/address_coordinates.csv')\ndf_distance = pd.read_csv('..\/input\/distance-from-hdb-block-address-to-nearest-station\/address_to_nearest_stn_dist.csv')\n# train_indices = X.index\n# test_indices = X_test_full.index\n\n# Replace C'WEALTH with COMMONWEALTH\nX['street_name'] = X['street_name'].replace('C\\'WEALTH', 'COMMONWEALTH', regex=True)\nX_test_full['street_name'] = X_test_full['street_name'].replace('C\\'WEALTH', 'COMMONWEALTH', regex=True)\n\n# Add address column to X and X_test_full\nX['address'] = X['block'] + ' ' + X['street_name']\nX_test_full['address'] = X_test_full['block'] + ' ' + X_test_full['street_name']\n\n# Add lat and long to X and X_test_full\nX = X.reset_index().merge(df_add_coords, on='address').set_index('id')\nX = X.reset_index().merge(df_distance, on='address').set_index('id')\nX_test_full = X_test_full.reset_index().merge(df_add_coords, on='address').set_index('id')\nX_test_full = X_test_full.reset_index().merge(df_distance, on='address').set_index('id')\n\n# Define dictionaries for changing labels of categorical variables\ndictionaries = [\n    {\n        'name': 'num_rooms',\n        'features': ['flat_type'],\n        'lookup': {\n            '1 ROOM': 'type1',\n            '2 ROOM': 'type2',\n            '3 ROOM': 'type3',\n            '4 ROOM': 'type4',\n            '5 ROOM': 'type5',\n            'EXECUTIVE': 'type6',\n            'MULTI-GENERATION': 'type7'\n        }\n    }\n]\n\n\nfor df in [X, X_test_full]:\n    \n    # Change flat_type\n    for dictionary in dictionaries:\n        for feature in dictionary[\"features\"]:\n            df[feature] = df[feature].map(dictionary[\"lookup\"])\n    \n    # Convert remaining lease years and storey range to numeric format\n    df['remaining_lease_years'] = pd.to_numeric(df['remaining_lease'].apply(lambda x: x.split(\" \")[0]))\n    df['storey_range_numerical'] = pd.to_numeric(df['storey_range'].apply(lambda x: x.split(\" \")[0]))\n    df.drop(['remaining_lease','storey_range'], axis=1, inplace=True)\n\n# Remove rows with missing target, separate target from predictors\nX.dropna(axis=0, subset=['resale_price'], inplace=True)\ny = np.log1p(X.resale_price)              \nX.drop(['resale_price'], axis=1, inplace=True)\n\n# Select categorical columns\ncategorical_cols = ['flat_model', 'flat_type']\n\n# Select numerical columns\nnumerical_cols = [cname for cname in X.columns if X[cname].dtype in ['int64', 'float64']]\nassert numerical_cols == [cname for cname in X_test_full.columns if\n                          X_test_full[cname].dtype in ['int64', 'float64']]\n\n# Combine to get selected columns\nselected_cols = categorical_cols + numerical_cols\n\n# Get preprocessed test set\nX_test  = X_test_full[selected_cols].copy()","0ccb34fa":"# Preprocessing for numerical data\nnumerical_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='mean')),\n    ('scale',   StandardScaler(with_mean=False))\n])\n\n# Preprocessing for categorical data (drop first class of each feature during one hot encoding)\ncategorical_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='most_frequent')),\n    ('onehot',  OneHotEncoder(handle_unknown='ignore')),\n    ('scale',   StandardScaler(with_mean=False))\n])\n\n# Bundle both preprocessing\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numerical_transformer,   numerical_cols),\n        ('cat', categorical_transformer, categorical_cols)\n    ])","5dd4e187":"metric = lambda y1_real, y2_real: np.sqrt(mean_squared_error(y1_real, y2_real))\ny_trfm = lambda y: np.expm1(y)\n\ndef get_score(model, X, y):\n    # Predict\n    preds = model.predict(X)\n    # Transform\n    preds  = y_trfm(preds)\n    y = y_trfm(y)\n    return metric(preds, y)","af5672eb":"# With CV\nela = ElasticNet(warm_start=True, precompute=True, alpha=0.001, l1_ratio=0.2)\nknn = KNeighborsRegressor(n_neighbors=7, weights='distance')\ngbr = GradientBoostingRegressor(\n    n_estimators=1000,\n    learning_rate=0.02,\n    max_depth=10,\n    max_features=0.6,\n    subsample=0.75,\n    random_state=42)\nreg = LinearRegression()\n\nnum_stacks = 5\nscores_list = list()\npreds_list = list()\ntime_start = time.time()\nfor i in range(num_stacks):\n    # Train-val split\n    X_train_full, X_val_full, y_train, y_val = train_test_split(X, y, train_size=0.8, test_size=0.2,\n                                                                random_state=i)\n    X_train = X_train_full[selected_cols].copy()\n    X_val = X_val_full[selected_cols].copy()\n    stack_cv = StackingCVRegressor(regressors=[ela, knn, gbr], meta_regressor=reg, random_state=2*i)\n    pipeline_stack_cv = Pipeline(steps=[('preprocessor', preprocessor),\n                                        ('model', stack_cv)])\n    pipeline_stack_cv.fit(X_train, y_train)\n    preds_list.append(pipeline_stack_cv.predict(X_test))\n    scores_list.append(get_score(pipeline_stack_cv, X_val, y_val))\nprint('Time taken to train stacking models: {:.2f} min'.\n      format((time.time() - time_start) \/ 60))\nprint('Average score:', np.mean(scores_list))","8a7fae93":"preds_array = np.array(preds_list)\npreds_test = np.mean(y_trfm(preds_array), axis=0)\n\noutput = pd.DataFrame({'id': X_test.index,\n                       'resale_price': preds_test})\noutput.to_csv('submission.csv', index=False)","2f6f5e74":"## Build and train model","b539b31e":"# Averaged Stacked Models\nAveraging the results from stacked models, using different training sets\n\nWith Elastic Net, K Nearest Neighbors and Gradient Boosting as base models, and Linear Regeression as meta model","0dda1992":"Define transformation pipelines","ea5b62b9":"Submission","b3ce3577":"Preprocess data (without train-val split)","758b7ede":"Define metrics","e4b92b76":"## Preprocessing","1bdb2d1a":"Import libraries","11b57845":"Build and train stackers"}}