{"cell_type":{"f4c5973d":"code","d67185dc":"code","6654a8bd":"code","f32e2431":"code","fc11161b":"code","5b0fc4e8":"code","7774a103":"code","9c423dcf":"code","dadf97e8":"code","1e47c9b5":"code","3993a88f":"code","d3fd263b":"code","7bd1b3ac":"code","e338a380":"code","b2286ee8":"code","286427b5":"code","7075a371":"code","52066991":"code","1f0587f0":"code","ef7c517e":"code","16fa07d0":"code","678abc61":"code","5da319a8":"code","5646a437":"code","f359786a":"code","42ed7f7a":"code","acd11a9a":"code","18df8e24":"code","64be28dc":"code","4aa95d76":"code","eef3af3c":"code","a74fc933":"code","783adc2e":"code","30df7105":"code","07d52f9d":"code","cb892ad5":"code","dfb99639":"code","f4e07717":"code","53c1e5c9":"code","2fd3fb4a":"code","f953826d":"code","10711313":"code","ce1c09d6":"code","31f8f478":"code","fbbae058":"code","7100fae8":"code","adb5daf8":"code","5cb74ff3":"code","40adb571":"code","2647ae21":"code","78a9ed8a":"code","63610062":"code","27e90029":"code","e4a52cc2":"code","06dcd1e8":"code","3642adec":"code","1d33d1b9":"code","65b00be0":"code","fce86896":"code","6b7e2709":"code","c03b218b":"code","9d689a44":"code","34cf326d":"code","93807400":"code","cff71f67":"code","f72cdb5b":"code","290bf6db":"code","f46c6fcf":"code","9dd5f99f":"code","37af97e9":"code","dd16b89e":"code","7b564a8e":"code","1c2c3cdf":"code","1db4c769":"code","7bc2772b":"code","898fadd0":"code","acb7fc15":"code","d212630c":"code","7eb1e959":"code","f28057c6":"code","c12944f8":"code","e948a065":"code","39f8d7f3":"markdown","e015daa6":"markdown","020e945e":"markdown","38bcd1af":"markdown","888fe2ca":"markdown","131ec8f1":"markdown","9c0db884":"markdown","74b12afa":"markdown","72acf51f":"markdown","c267d53d":"markdown","745f18cd":"markdown","58e306f4":"markdown","1d478d66":"markdown","75496d69":"markdown","10a8a316":"markdown","68cef707":"markdown","fff31633":"markdown","e59cb1ff":"markdown","c67d1aa4":"markdown","377d756f":"markdown","e476746f":"markdown","6b715b4b":"markdown","781d6d4f":"markdown","fb5e738c":"markdown","99e8b9c4":"markdown","f35432d0":"markdown","c0d3ff26":"markdown","a2062cab":"markdown","c6948e33":"markdown","fdcc15a6":"markdown","57de165b":"markdown","a6513e79":"markdown","ffa455cd":"markdown","8b47262e":"markdown","6889a9ef":"markdown","ac3f446b":"markdown","5f53bb19":"markdown","d1fe96b1":"markdown","5139d472":"markdown","aaf69a04":"markdown","5d195bfc":"markdown","be68ee10":"markdown","06a33b54":"markdown","1c11df47":"markdown","c72ca40e":"markdown","25f86e8d":"markdown","11d869af":"markdown","5f9867b9":"markdown","cedb4193":"markdown","fbd10090":"markdown","4da4c299":"markdown","72573fbc":"markdown","4835d0ff":"markdown","6fed3549":"markdown"},"source":{"f4c5973d":"import numpy as np","d67185dc":"a = np.array([1, 2, 3])  # Create a rank 1 array\nprint(type(a), a.shape, a[0], a[1], a[2])\na[0] = 5                 # Change an element of the array\nprint(a)    ","6654a8bd":"b = np.array([[1,2,3],[4,5,6]])   # Create a rank 2 array\nprint(b)","f32e2431":"print(b.shape)\nprint(b[0, 0], b[0, 1], b[1, 0])","fc11161b":"a = np.zeros((2,2))  # Create an array of all zeros\nprint(a)","5b0fc4e8":"b = np.ones((1,2))   # Create an array of all ones\nprint(b)","7774a103":"c = np.full((2,2), 7) # Create a constant array\nprint(c)","9c423dcf":"d = np.eye(2)        # Create a 2x2 identity matrix\nprint(d)","dadf97e8":"e = np.random.random((2,2)) # Create an array filled with random values\nprint(e)","1e47c9b5":"square = np.array([\n     [16, 3, 2, 13],\n     [5, 10, 11, 8],\n     [9, 6, 7, 12],\n     [4, 15, 14, 1]\n ])\n\nfor i in range(4):\n  assert square[:, i].sum() == 34\n  assert square[i, :].sum() == 34\n\n\nassert square[:2, :2].sum() == 34\n\nassert square[2:, :2].sum() == 34\n\nassert square[:2, 2:].sum() == 34\n\nassert square[2:, 2:].sum() == 34","3993a88f":"# Create the following rank 2 array with shape (3, 4)\n# [[ 1  2  3  4]\n#  [ 5  6  7  8]\n#  [ 9 10 11 12]]\na = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n\n# Use slicing to pull out the subarray consisting of the first 2 rows\n# and columns 1 and 2; b is the following array of shape (2, 2):\n# [[2 3]\n#  [6 7]]\nb = a[:2, 1:3]\nprint(b)","d3fd263b":"print(a[0, 1])\nb[0, 0] = 77    # b[0, 0] is the same piece of data as a[0, 1]\nprint(a[0, 1]) ","7bd1b3ac":"# Create the following rank 2 array with shape (3, 4)\na = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\nprint(a)","e338a380":"from numpy.linalg import matrix_rank","b2286ee8":"# In-Built function for finding rank of Matrix\nmatrix_rank(a)","286427b5":"a[1] = a[1] - (5*a[0])\na[2] = a[2] - (9*a[0])\nprint(a)","7075a371":"a[2] = a[2] - (2*a[1])\nprint(a)","52066991":"row_r1 = a[1, :]    # Rank 1 view of the second row of a  \nrow_r2 = a[1:2, :]  # Rank 2 view of the second row of a\nrow_r3 = a[[1], :]  # Rank 2 view of the second row of a\nprint(row_r1, row_r1.shape)\nprint(row_r2, row_r2.shape)\nprint(row_r3, row_r3.shape)\n","1f0587f0":"# We can make the same distinction when accessing columns of an array:\ncol_r1 = a[:, 1]\ncol_r2 = a[:, 1:2]\nprint(col_r1, col_r1.shape)\nprint()\nprint(col_r2, col_r2.shape)","ef7c517e":"a = np.array([[1,2], [3, 4], [5, 6]])\n\n# An example of integer array indexing.\n# The returned array will have shape (3,) and \nprint(a[[0, 1, 2], [0, 1, 0]])\n\n# The above example of integer array indexing is equivalent to this:\nprint(np.array([a[0, 0], a[1, 1], a[2, 0]]))","16fa07d0":"# When using integer array indexing, you can reuse the same\n# element from the source array:\nprint(a[[0, 0], [1, 1]])\n\n# Equivalent to the previous integer array indexing example\nprint(np.array([a[0, 1], a[0, 1]]))","678abc61":"# Create a new array from which we will select elements\na = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])\nprint(a)","5da319a8":"# Create an array of indices\nb = np.array([0, 2, 0, 1])\n\n# Select one element from each row of a using the indices in b\nprint(a[np.arange(4), b])  # Prints \"[ 1  6  7 11]\"","5646a437":"# Mutate one element from each row of a using the indices in b\na[np.arange(4), b] += 10\nprint(a)","f359786a":"a = np.array([[1,2], [3, 4], [5, 6]])\n\nbool_idx = (a > 2)  # Find the elements of a that are bigger than 2;\n                    # this returns a numpy array of Booleans of the same\n                    # shape as a, where each slot of bool_idx tells\n                    # whether that element of a is > 2.\n\nprint(bool_idx)","42ed7f7a":"# We use boolean array indexing to construct a rank 1 array\n# consisting of the elements of a corresponding to the True values\n# of bool_idx\nprint(a[bool_idx])\n\n# We can do all of the above in a single concise statement:\nprint(a[a > 2])","acd11a9a":"numbers = np.linspace(5, 50, 24, dtype=int).reshape(4, -1)","18df8e24":"numbers","64be28dc":"mask = numbers % 4 == 0","4aa95d76":"mask","eef3af3c":"numbers[mask]","a74fc933":"by_four = numbers[numbers % 4 == 0]","783adc2e":"by_four","30df7105":"a = np.array([1, 3, 5.5, 7.7, 9.2], dtype=np.single)\nprint(a, a.dtype)","07d52f9d":"b = np.array([1, 3, 5.5, 7.7, 9.2], dtype=np.uint8)\nprint(b, b.dtype)","cb892ad5":"names = np.array([\"bob\", \"amy\", \"han\"], dtype=str)","dfb99639":"names","f4e07717":"names.itemsize # It is returning the sum of ( size of per string + 1 )\n# bob = 3+1, amy = 3+1, han = 3+1\n# 12","53c1e5c9":"more_names = np.array([\"bobo\", \"jehosephat\"])","2fd3fb4a":"np.concatenate((names, more_names))","f953826d":"names[2] = \"jamima\"","10711313":"names","ce1c09d6":"data = np.array([\n             (\"joe\", 32, 6),\n             (\"mary\", 15, 20),\n             (\"felipe\", 80, 100),\n             (\"beyonce\", 38, 9001),\n       ], dtype=[(\"name\", str, 10), (\"age\", int), (\"power\", int)])","31f8f478":"data","fbbae058":"data[1]","7100fae8":"data['name']","adb5daf8":"data[data[\"power\"] > 9000][\"name\"]","5cb74ff3":"np.sort(data[data[\"age\"] > 20], order=\"power\")[\"name\"]","40adb571":"x = np.array([[1,2],[3,4]], dtype=np.float64)\ny = np.array([[5,6],[7,8]], dtype=np.float64)\n\n# Elementwise sum; both produce the array\nprint(x + y)\nprint(np.add(x, y))","2647ae21":"# Elementwise difference; both produce the array\nprint(x - y)\nprint(np.subtract(x, y))","78a9ed8a":"# Elementwise product; both produce the array\nprint(x * y)\nprint(np.multiply(x, y))","63610062":"# Elementwise division; both produce the array\n# [[ 0.2         0.33333333]\n#  [ 0.42857143  0.5       ]]\nprint(x \/ y)\nprint(np.divide(x, y))","27e90029":"# Elementwise square root; produces the array\n# [[ 1.          1.41421356]\n#  [ 1.73205081  2.        ]]\nprint(np.sqrt(x))","e4a52cc2":"x = np.array([[1,2],[3,4]])\ny = np.array([[5,6],[7,8]])\n\nv = np.array([9,10])\nw = np.array([11, 12])\n\n# Inner product of vectors; both produce 219\nprint(v.dot(w))\nprint(np.dot(v, w))","06dcd1e8":"print(v @ w)","3642adec":"# Matrix \/ vector product; both produce the rank 1 array [29 67]\nprint(x.dot(v))\nprint(np.dot(x, v))\nprint(x @ v)","1d33d1b9":"# Matrix \/ matrix product; both produce the rank 2 array\n# [[19 22]\n#  [43 50]]\nprint(x.dot(y))\nprint(np.dot(x, y))\nprint(x @ y)","65b00be0":"x = np.array([[1,2],[3,4]])\n\nprint(np.sum(x))  # Compute sum of all elements; prints \"10\"\nprint(np.sum(x, axis=0))  # Compute sum of each column; prints \"[4 6]\"\nprint(np.sum(x, axis=1))  # Compute sum of each row; prints \"[3 7]\"","fce86896":"print(x)\nprint(\"transpose\\n\", x.T)","6b7e2709":"v = np.array([[1,2,3]])\nprint(v )\nprint(\"transpose\\n\", v.T)","c03b218b":"temperatures = np.array([\n     29.3, 42.1, 18.8, 16.1, 38.0, 12.5,\n     12.6, 49.9, 38.6, 31.3, 9.2, 22.2\n ]).reshape(2, 2, 3)","9d689a44":"temperatures","34cf326d":"temperatures.shape","93807400":"np.swapaxes(temperatures, 1, 2)","cff71f67":"table = np.array([\n     [5, 3, 7, 1],\n     [2, 6, 7 ,9],\n     [1, 1, 1, 1],\n     [4, 3, 2, 0],\n ])","f72cdb5b":"table.max()","290bf6db":"table.max(axis=0) ","f46c6fcf":"table.max(axis=1)","9dd5f99f":"A = np.arange(32).reshape(4, 1, 8)\n","37af97e9":"A","dd16b89e":"B = np.arange(48).reshape(1, 6, 8)","7b564a8e":"B","1c2c3cdf":"A+B","1db4c769":"# We will add the vector v to each row of the matrix x,\n# storing the result in the matrix y\nx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])\nv = np.array([1, 0, 1])\ny = np.empty_like(x)   # Create an empty matrix with the same shape as x\n\n# Add the vector v to each row of the matrix x with an explicit loop\nfor i in range(4):\n    y[i, :] = x[i, :] + v\n\nprint(y)","7bc2772b":"vv = np.tile(v, (4, 1))  # Stack 4 copies of v on top of each other\nprint(vv)                # Prints \"[[1 0 1]\n                         #          [1 0 1]\n                         #          [1 0 1]\n                         #          [1 0 1]]\"","898fadd0":"y = x + vv  # Add x and vv elementwise\nprint(y)","acb7fc15":"# We will add the vector v to each row of the matrix x,\n# storing the result in the matrix y\nx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])\nv = np.array([1, 0, 1])\ny = x + v  # Add v to each row of x using broadcasting\nprint(y)","d212630c":"# Compute outer product of vectors\nv = np.array([1,2,3])  # v has shape (3,)\nw = np.array([4,5])    # w has shape (2,)\n# To compute an outer product, we first reshape v to be a column\n# vector of shape (3, 1); we can then broadcast it against w to yield\n# an output of shape (3, 2), which is the outer product of v and w:\n\nprint(np.reshape(v, (3, 1)) * w)","7eb1e959":"# Add a vector to each row of a matrix\nx = np.array([[1,2,3], [4,5,6]])\n# x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),\n# giving the following matrix:\n\nprint(x + v)","f28057c6":"# Add a vector to each column of a matrix\n# x has shape (2, 3) and w has shape (2,).\n# If we transpose x then it has shape (3, 2) and can be broadcast\n# against w to yield a result of shape (3, 2); transposing this result\n# yields the final result of shape (2, 3) which is the matrix x with\n# the vector w added to each column. Gives the following matrix:\n\nprint((x.T + w).T)","c12944f8":"# Another solution is to reshape w to be a row vector of shape (2, 1);\n# we can then broadcast it directly against x to produce the same\n# output.\nprint(x + np.reshape(w, (2, 1)))","e948a065":"# Multiply a matrix by a constant:\n# x has shape (2, 3). Numpy treats scalars as arrays of shape ();\n# these can be broadcast together to shape (2, 3), producing the\n# following array:\nprint(x * 2)","39f8d7f3":"# Numpy Tutorials","e015daa6":"## Array Math","020e945e":"### Structured Arrays","38bcd1af":"## Array\n\nA numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.\n\nWe can initialize numpy arrays from nested Python lists, and access elements using square brackets:","888fe2ca":"## References\n\n- The [NumPy documentation on ndarrays](https:\/\/numpy.org\/doc\/stable\/reference\/arrays.ndarray.html#internal-memory-layout-of-an-ndarray) has tons more resources.\n- [NumPy Tutorial: Your First Steps Into Data Science in Python](https:\/\/realpython.com\/numpy-tutorial\/#optimizing-storage-data-types)\n- [NumPy fundamentals](https:\/\/numpy.org\/doc\/stable\/user\/basics.html)\n- [Python Numpy Tutorial](https:\/\/cs231n.github.io\/python-numpy-tutorial\/)","131ec8f1":"### Masking ","9c0db884":"Numpy broadcasting allows us to perform this computation without actually creating multiple copies of v. Consider this version, using broadcasting:","74b12afa":"### String ","72acf51f":"#### Finding Rank of Matrix by Echelon Form\n\n**Steps to Find the Rank of the Matrix by Echelon Form:**\n\n**(i)** The first element of every non zero row should be 1.\n\n**(ii)** The row in which every element is zero, then that row should be below the non zero rows.\n\n**(iii)** Total number of zeroes in the next non zero row should be more than the number of zeroes in the previous non zero row.\n\nBy elementary operations, we can easily bring the given matrix to the echelon form.\n\n**Note: The rank of a matrix does not change if we perform the following elementary row operations are applied to the matrix:**\n\n**(a)** Two rows are interchanged (Ri \u2194 Rj)\n\n**(b)** A row is multiplied by a non-zero constant, (Ri \u2194 kRi) where k \u2260 0\n\n**(c)** A constant multiple of another row is added to a given row (Ri \u27f6 Ri + kRj), where i \u2260 j.","c267d53d":"Note that unlike MATLAB, * is elementwise multiplication, not matrix multiplication. We instead use the dot function to compute inner products of vectors, to multiply a vector by a matrix, and to multiply matrices. dot is available both as a function in the numpy module and as an instance method of array objects:","745f18cd":"## Datatypes\n- Numerical Types\n  - int\n  - bool\n  - float\n  - complex\n- String Types\n- Structured Arrays\n\nThe [NumPy documentation on ndarrays](https:\/\/numpy.org\/doc\/stable\/reference\/arrays.ndarray.html#internal-memory-layout-of-an-ndarray) has tons more resources.\n\nThere\u2019s also a lot more information on [dtype objects](https:\/\/numpy.org\/doc\/stable\/reference\/arrays.dtypes.html), including the different ways to construct, customize, and optimize them and how to make them more robust for all your data-handling needs.","58e306f4":"### Array Shape","1d478d66":"By default, .max() returns the largest value in the entire array, no matter how many dimensions there are. However, once you specify an axis, it performs that calculation for each set of values along that particular axis. For example, with an argument of axis=0, .max() selects the maximum value in each of the four vertical sets of values in table and returns an array that has been flattened, or aggregated into a one-dimensional array.\n\nIn fact, many of NumPy\u2019s functions behave this way: If no axis is specified, then they perform an operation on the entire dataset. Otherwise, they perform the operation in an axis-wise fashion.","75496d69":"## Array indexing\nNumpy offers several ways to index into arrays.\n\nSlicing: Similar to Python lists, numpy arrays can be sliced. Since arrays may be multidimensional, you must specify a slice for each dimension of the array:","10a8a316":"## Array Shapes and Axes","68cef707":"In both cases, the result is a list of names where the power level is over 9000.\n\nYou can even add in ORDER BY functionality by making use of np.sort():","fff31633":"This sorts the data by power before retrieving it, which rounds out your selection of NumPy tools for selecting, filtering, and sorting items just like you might in SQL!","e59cb1ff":" NumPy has a special kind of array, called a record array or structured array, with which you can specify a type and, optionally, a name on a per-column basis. This makes sorting and filtering even more powerful, and it can feel similar to working with data in Excel, CSVs, or relational databases.\n\nHere\u2019s a quick example to show them off a little:","c67d1aa4":"Basic mathematical functions operate elementwise on arrays, and are available both as operator overloads and as functions in the numpy module:","377d756f":"You can also use the `@` operator which is equivalent to numpy's `dot` operator.","e476746f":"Inside the for loop, you verify that all the rows and all the columns add up to 34. After that, using selective indexing, you verify that each of the quadrants also adds up to 34.\n\nOne last thing to note is that you\u2019re able to take the sum of any array to add up all of its elements globally with square.sum(). This method can also take an axis argument to do an axis-wise summing instead.","6b715b4b":"It doesn\u2019t work as expected and truncates your value instead. If you already have an array, then NumPy\u2019s automatic size detection won\u2019t work for you. You get three characters and that\u2019s it. The rest get lost in the void.\n\nThis is all to say that, in general, NumPy has your back when you\u2019re working with strings, but you should always keep an eye on the size of your elements and make sure you have enough space when modifying or changing arrays in place.","781d6d4f":"You can also mix integer indexing with slice indexing. However, doing so will yield an array of lower rank than the original array. Note that this is quite different from the way that MATLAB handles array slicing:\n\n","fb5e738c":"All arrays have a property called .shape that returns a tuple of the size in each dimension. It\u2019s less important which dimension is which, but it\u2019s critical that the arrays you pass to functions are in the shape that the functions expect. A common way to confirm that your data has the proper shape is to print the data and its shape until you\u2019re sure everything is working like you expect.","99e8b9c4":"### Numerical Types: int, bool, float, complex","f35432d0":"## Getting Started With Numpy\n\nFor starting using Numpy you need to import it first\n\n","c0d3ff26":"One useful trick with integer array indexing is selecting or mutating one element from each row of a matrix:","a2062cab":"A has 4 planes, each with 1 row and 8 columns. B has only 1 plane with 6 rows and 8 columns. Watch what NumPy does for you when you try to do a calculation between them!\n\nAdd the two arrays together:","c6948e33":"## Extra Points\n\n- **Vectorization** is the process of performing the same operation in the same way for each element in an array. This removes for loops from your code but achieves the same result.\n\n- **Broadcasting** is the process of extending two arrays of different shapes and figuring out how to perform a vectorized calculation between them. \n\n- The **Rank of Matrix** refers to the number of linearly independent rows or columns in the matrix. \u03c1(A) is used to denote the rank of matrix A. A matrix is said to be of rank zero when all of its elements become zero. The rank of the matrix is the dimension of the vector space obtained by its columns.\n\n- **I = eye( n , m ) returns an n -by- m matrix with ones on the main diagonal and zeros elsewhere.** I = eye( sz ) returns an array with ones on the main diagonal and zeros elsewhere. The size vector, sz , defines size(I) . \n\n  For example, eye([2,3]) returns a 2-by-3 array with ones on the main diagonal and zeros elsewhere.\n\n  **It is also known as Identity Matrix**\n\n- **Vectors**, which are one-dimensional arrays of numbers, are the least complicated to keep track of. ","fdcc15a6":"1. Using [np.linspace()](https:\/\/realpython.com\/np-linspace-numpy\/) to generate an evenly spaced array\n2. Setting the dtype of an output\n3. Reshaping an array with -1\n\n[np.linspace()](https:\/\/realpython.com\/np-linspace-numpy\/) generates n numbers evenly distributed between a minimum and a maximum, which is useful for evenly distributed sampling in scientific plotting.\n\nBecause of the particular calculation in this example, it makes life easier to have integers in the numbers array. But because the space between 5 and 50 doesn\u2019t divide evenly by 24, the resulting numbers would be floating-point numbers. You specify a dtype of int to force the function to round down and give you whole integers. You\u2019ll see a more detailed discussion of data types later on.","57de165b":"Count the number of linearly independent rows for Rank Of Matrix.\n\nHence in matrix a this will clearly visible there are only two rows which are not lineary dependent on any other row.\n\nhence the **Rank of Matrix a is 2**","a6513e79":"This works; however when the matrix x is very large, computing an explicit loop in Python could be slow. Note that adding the vector v to each row of the matrix x is equivalent to forming a matrix vv by stacking multiple copies of v vertically, then performing elementwise summation of x and vv. We could implement this approach like this:","ffa455cd":"Here\u2019s an example showing the process, first in slow motion and then how it\u2019s typically done, all in one line:","8b47262e":"### Understanding Axes","6889a9ef":"## Broadcasting","ac3f446b":"Broadcasting typically makes your code more concise and faster, so you should strive to use it where possible.","5f53bb19":"Here\u2019s a quick example. Array A has the shape (4, 1, 8), and array B has the shape (1, 6, 8). Based on the rules above, you can operate on these arrays together:\n\nIn axis 0, A has a 4 and B has a 1, so B can be broadcast along that axis.\nIn axis 1, A has a 1 and B has a 6, so A can be broadcast along that axis.\nIn axis 2, the two arrays have matching sizes, so they can operate successfully.\nAll three axes successfully follow the rule.\n\nYou can set up the arrays like this:","d1fe96b1":"Integer array indexing: When you index into numpy arrays using slicing, the resulting array view will always be a subarray of the original array. In contrast, integer array indexing allows you to construct arbitrary arrays using the data from another array. Here is an example:","5139d472":"| Name\t| # of Bits\t| Python Type\t| NumPy Type |\n|:--|:--:|:--:|--:|\n| Integer\t| 64\t| int\t| np.int_ |\n| Booleans\t| 8\t| bool\t| np.bool_ |\n| Float\t| 64\t| float\t| np.float_ |\n| Complex\t| 128\t| complex\t| np.complex_ |\n\nEvery numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:","aaf69a04":"A mask is an array that has the exact same shape as your data, but instead of your values, it holds [Boolean values](https:\/\/realpython.com\/python-boolean\/): either True or False. You can use this mask array to index into your data array in nonlinear and complex ways. It will return all of the elements where the Boolean array has a True value.","5d195bfc":"The example above shows how important it is to know not only what shape your data is in but also which data is in which axis. In NumPy arrays, axes are zero-indexed and identify which dimension is which. For example, a two-dimensional array has a vertical axis (axis 0) and a horizontal axis (axis 1). Lots of functions and commands in NumPy change their behavior based on which axis you tell them to process.\n\nThis example will show how .max() behaves by default, with no axis argument, and how it changes functionality depending on which axis you specify when you do supply an argument:","be68ee10":"For example, suppose that we want to add a constant vector to each row of a matrix. We could do it like this:","06a33b54":"Numpy provides many useful functions for performing computations on arrays; one of the most useful is sum:","1c11df47":"\nNumpy is a Python Library used for Scientific Computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays.\n\nHere are the top four benefits that NumPy can bring to your code:\n\n- **More speed**: NumPy uses algorithms written in C that complete in nanoseconds rather than seconds.\n- **Fewer loops**: NumPy helps you to reduce loops and keep from getting tangled up in iteration indices.\n- **Clearer code**: Without loops, your code will look more like the equations you\u2019re trying to calculate.\n- **Better quality**: There are thousands of contributors working to keep NumPy fast, friendly, and bug free.\n\n| Table of Content |\n| :----------------: |\n| Getting Started with Numpy |\n| Array |\n| Array Indexing|\n| DataTypes |\n| Extra Points |\n|Resources and References|\n","c72ca40e":"Broadcasting is a powerful mechanism that allows numpy to work with arrays of different shapes when performing arithmetic operations. Frequently we have a smaller array and a larger array, and we want to use the smaller array multiple times to perform some operation on the larger array.","25f86e8d":"You can find the full list of mathematical functions provided by numpy in the [documentation](http:\/\/docs.scipy.org\/doc\/numpy\/reference\/routines.math.html).\n\nApart from computing mathematical functions using arrays, we frequently need to reshape or otherwise manipulate data in arrays. The simplest example of this type of operation is transposing a matrix; to transpose a matrix, simply use the T attribute of an array object:\n\n","11d869af":"The line `y = x + v` works even though `x` has shape `(4, 3)` and `v` has shape `(3,)` due to broadcasting; this line works as if v actually had shape `(4, 3)`, where each row was a copy of `v`, and the sum was performed elementwise.\n\nBroadcasting two arrays together follows these rules:\n\n1. If the arrays do not have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.\n2. The two arrays are said to be compatible in a dimension if they have the same size in the dimension, or if one of the arrays has size 1 in that dimension.\n3. The arrays can be broadcast together if they are compatible in all dimensions.\n4. After broadcasting, each array behaves as if it had shape equal to the elementwise maximum of shapes of the two input arrays.\n5. In any dimension where one array had size 1 and the other array had size greater than 1, the first array behaves as if it were copied along that dimension\n\nIf this explanation does not make sense, try reading the explanation from the [documentation](http:\/\/docs.scipy.org\/doc\/numpy\/user\/basics.broadcasting.html) or this [explanation](http:\/\/wiki.scipy.org\/EricsBroadcastingDoc).\n\nFunctions that support broadcasting are known as universal functions. You can find the list of all universal functions in the [documentation](http:\/\/docs.scipy.org\/doc\/numpy\/reference\/ufuncs.html#available-ufuncs).\n\nHere are some applications of broadcasting:","5f9867b9":"NumPy automatically converts your platform-independent type np.single to whatever fixed-size type your platform supports for that size. In this case, it uses np.float32. If your provided values don\u2019t match the shape of the dtype you provided, then NumPy will either fix it for you or raise an error.","cedb4193":"The way broadcasting works is that NumPy duplicates the plane in B three times so that you have a total of four, matching the number of planes in A. It also duplicates the single row in A five times for a total of six, matching the number of rows in B. Then it adds each element in the newly expanded A array to its counterpart in the same location in B. The result of each calculation shows up in the corresponding location of the output.\n\n---\n\n\n**Note:** This is a good way to create an array from a range using arange()!\n\n\n---\n\n","fbd10090":"Boolean array indexing: Boolean array indexing lets you pick out arbitrary elements of an array. Frequently this type of indexing is used to select the elements of an array that satisfy some condition. Here is an example:","4da4c299":"You created an array, except each item is a tuple with a name, an age, and a power level. For the dtype, you actually provide a list of tuples with the information about each field: name is a 10-character Unicode field, and both age and power are standard 4-byte or 8-byte integers.","72573fbc":"A slice of an array is a view into the same data, so modifying it will modify the original array.","4835d0ff":"Numpy also provides many functions to create arrays:","6fed3549":"When you combine that with an array that has a larger item to create a new array, NumPy helpfully figures out how big the new array\u2019s items need to be and grows them all to size < U10.\n\nBut here\u2019s what happens when you try to modify one of the slots with a value larger than the capacity of the dtype:"}}