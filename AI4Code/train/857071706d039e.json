{"cell_type":{"b738dc01":"code","98efdf2b":"code","c06815b3":"code","09abcad9":"code","0dd2e267":"code","8c04c89d":"code","ac2a8a83":"code","456fb600":"code","8eb6f602":"code","ced36bb2":"code","50b89bf8":"code","751740f9":"code","43700dbf":"code","199b7c80":"code","3ca8ae4f":"code","04859408":"code","b4898d2d":"code","a8e3c548":"code","b1bb276e":"code","092e8045":"code","ee349f95":"markdown","debd0b84":"markdown","0b5f8cd8":"markdown","95987be3":"markdown","f586e071":"markdown","0e937c2a":"markdown","b57c665f":"markdown","c4e06e17":"markdown","87aaaef6":"markdown"},"source":{"b738dc01":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","98efdf2b":"import re\nimport pandas as pd\nimport numpy as np\nimport re\nimport glob\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport seaborn as sns\nfrom plotly import tools\nfrom plotly.offline import init_notebook_mode, iplot\n%matplotlib inline","c06815b3":"print(os.listdir(\"..\/input\/data-science-for-good-city-of-los-angeles\"))\n","09abcad9":"rx_dict = {\n    'TITLE': re.compile(r'(?P<title>.*)(\\n+.*Class Code:)'),\n    'Class Code': re.compile(r'(Class Code:)(?P<classcode>.*)(\\n)'),\n    'Open Date': re.compile(r'(Open Date:)(?P<open_date>.*)(\\n)'),\n    'Annual Salary': re.compile(r'ANNUAL\\s*SALARY\\s*\\n*\\s*(?P<Lowerend>\\$\\d*,\\d*)(\\s*to\\s*(?P<Upperend>\\$\\d*,\\d*)|.*)'),\n    'Salary DWP': re.compile(r'ANNUAL\\s*SALARY(.|\\n)*?.*Department of Water and Power.*(?P<Lowerend>\\$\\d*,\\d*)(\\s*to\\s*(?P<Upperend>\\$\\d*,\\d*))'),\n    'DUTIES': re.compile(r'(DUTIES(?P<Duties>(.|\\n)*?))(SELECTION PROCESS|APPLICATION DEADLINE|WHERE TO APPLY|MINIMUM\\s*QUALIFICATIONS|QUALIFICATIONS|REQUIREMENTS|QUALIFICATION|REQUIREMENT|\\Z)'),\n    'REQUIREMENTS': re.compile(r'((REQUIREMENT|REQUIREMENT\/MINIMUM QUALIFICATION|QUALIFICATION|QUALIFICATIONS)(?P<Requirement>(.|\\n)*?))(SELECTION PROCESS|APPLICATION DEADLINE|WHERE TO APPLY|\\Z)'),\n    'WHERE TO APPLY': re.compile(r'(WHERE TO APPLY(?P<WheretoApply>(.|\\n)*?))(SELECTION PROCESS|APPLICATION DEADLINE|\\Z)'),\n    'APPLICATION DEADLINE': re.compile(r'(APPLICATION DEADLINE(?P<ApplicationDeadline>(.|\\n)*?))(SELECTION PROCESS|\\Z)'),\n    'SELECTION PROCESS': re.compile(r'(SELECTION PROCESS(?P<SelectionProcess>(.|\\n)*?))(\\Z)'),\n    'ALL':re.compile(r'(DUTIES(?P<Duties>(.|\\n)*))((REQUIREMENTS|REQUIREMENTS\\\\MINIMUM QUALIFICATIONS|QUALIFICATIONS|REQUIREMENT|QUALIFICATION)(?P<Requirements>(.|\\n)*))(WHERE TO APPLY(?P<Wheretoapply>(.|\\n)*))(APPLICATION DEADLINE(?P<ApplicationDeadline>(.|\\n)*))(SELECTION PROCESS(?P<SelectionProcess>(.|\\n)*))')\n}","0dd2e267":"def convert_jobs_to_df(\n    path='..\/input\/data-science-for-good-city-of-los-angeles\/cityofla\/CityofLA\/Job Bulletins\/*.txt',\n    raw_text_col_name='raw_job_text'):\n    \n    \"\"\"\n    Convert each text file in job bulletins to pandas dataframe\n    \n    -----------\n    Returns\n        Pandas Dataframe\n            ------------------------------------\n            |    index     |  raw_text         |\n            |-----------------------------------\n            |     0    |  raw_job_descriptions | \n            ____________________________________\n    \"\"\"\n    \n    \n    job_list = []\n    \n    files = glob.glob(path)\n    for file in files:\n        with open(file, 'r', errors='replace') as f:\n            content = f.read()\n            job_list.append(content)\n            \n    return pd.DataFrame({raw_text_col_name:job_list})","8c04c89d":"def _whole_clean_text(text):\n    return text.replace(\"\\n\",\"\").replace(\"\\t\",\"\").strip()\n\ndef pre_processing(dataframe):\n    # remove all first new line charecters from text\n    dataframe['raw_job_text'] = dataframe['raw_job_text'].apply(\n        lambda x: x.lstrip())\n    return dataframe\n\ndef extract_job_title(dataframe):\n    # split at newline charecter, then grab first text\n    # and that is the title\n    dataframe['JOB_CLASS_TITLE'] = dataframe['raw_job_text'].apply(\n        lambda x: x.split('\\n', 1)[0])\n    dataframe['JOB_CLASS_TITLE'] = dataframe['JOB_CLASS_TITLE'].apply(\n        lambda x: _whole_clean_text(x))\n    return dataframe\n\ndef extract_class_code(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    # find class code\n    dataframe['JOB_CLASS_NO'] = temp.apply(lambda x: _class_code_apply(x))\n    return dataframe\n\ndef extract_open_date(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['OPEN_DATE'] = temp.apply(lambda x: _open_date_apply(x))\n    return dataframe\n\ndef extract_exam_type(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['TEMP_EXAM_TYPE'] = temp.apply(lambda x: _exam_type_apply(x))\n    return dataframe\n\ndef extract_salary(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['TEMP_SALARY'] = temp.apply(lambda x: _salary_apply(x))\n    return dataframe\n\n\ndef extract_duties(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['JOB_DUTIES'] = temp.apply(lambda x: _duties_apply(x))\n    return dataframe\n\ndef extract_requirements(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['TEMP_REQUIREMENTS'] = temp.apply(lambda x: _requirements_apply(x))\n    return dataframe\n\ndef extract_where_to_apply(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['WHERE_TO_APPLY'] = temp.apply(lambda x: _where_to_apply(x))\n    return dataframe\n\ndef extract_deadline(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['DEADLINE'] = temp.apply(lambda x: _deadline_apply(x))\n    return dataframe\n\ndef extract_selection_process(dataframe):\n    # remove all extra white spaces\n    temp = dataframe['raw_job_text'].apply(lambda x: ' '.join(x.split()))\n    \n    dataframe['SELECTION_PROCESS'] = temp.apply(lambda x: _selection_process_apply(x))\n    return dataframe","ac2a8a83":"def _class_code_apply(text):\n    \"\"\"\n    This class extract job class code\n    \"\"\"\n    match = re.search('Class Code: (\\d+)', text)\n    class_code = None\n    try:\n        class_code = match.group(1)\n    except:\n        class_code = None\n    return class_code\n        \n\ndef _open_date_apply(text):\n    \n    \"\"\"\n    Extract entire job open date section\n    \"\"\"\n    \n    open_date = ''\n    result= re.search(\n        \"(Class Code:|Class  Code:)(.*)(ANNUAL SALARY|ANNUALSALARY)\",\n        text)\n    \n    shortContent=''\n    if result:\n        shortContent=result.group(2).strip()\n        result= re.search(\n            \"Open Date:(.*)REVISED\",\n            shortContent,flags=re.IGNORECASE)\n        if result:\n            open_date=result.group(1).strip()\n        if open_date=='':\n            result= re.search(\n                \"Open Date:(.*)\\(Exam\",\n                shortContent,flags=re.IGNORECASE)\n            if result:\n                open_date=result.group(1).strip()\n        if open_date=='':\n            result= re.search(\n                \"Open Date:(.*)\",\n                shortContent,flags=re.IGNORECASE)\n            if result:\n                open_date=result.group(1).strip()\n    return open_date\n\n\ndef _exam_type_apply(text):\n    \n    \"\"\"\n    Extract entire exam type section\n    \"\"\"\n    \n    exam_type = \"\"\n    result= re.search(\n        \"(Class Code:|Class  Code:)(.*)(ANNUAL SALARY|ANNUALSALARY)\",\n        text)\n    \n    shortContent=''\n    if result:\n        shortContent=result.group(2).strip()\n        result= re.search(\n            \"\\(+(.*?)\\)\", shortContent,flags=re.IGNORECASE)\n        if result:\n            exam_type=result.group(1).strip()\n    return exam_type\n\n\ndef _salary_apply(text):\n    \"\"\"\n    Extract entire salary section\n    \"\"\"\n    salary = ''\n    salary_notes = ''\n    result=re.search(\n        \"(ANNUAL SALARY|ANNUALSALARY)(.*?)DUTIES\", text)\n    if result:\n        salContent= result.group(2).strip()\n        if \"NOTE:\" in salContent or \"NOTES:\" in salContent:\n            result=re.search(\n                \"(.*?)(NOTE:|NOTES:)\",\n                salContent,flags=re.IGNORECASE)\n            if result:\n                salary=result.group(1).strip()  \n            result= re.search(\n                \"(NOTE:|NOTES:)(.*)\",\n                salContent,flags=re.IGNORECASE)\n            if result:\n                salary_notes= result.group(2).strip()\n        else:\n            salary = salContent\n    else:\n        result=re.search(\n            \"(ANNUAL SALARY|ANNUALSALARY)(.*?)REQUIREMENT\",\n            text,flags=re.IGNORECASE)\n        if result:\n            salContent= result.group(2).strip()\n            if \"NOTE:\" in salContent or \"NOTES:\" in salContent:\n                result=re.search(\n                    \"(.*?)(NOTE:|NOTES:)\",\n                    salContent,flags=re.IGNORECASE)\n                if result:\n                    salary=result.group(1).strip()  \n                result= re.search(\n                    \"(NOTE:|NOTES:)(.*)\",\n                    salContent,flags=re.IGNORECASE)\n                if result:\n                    salary_notes= result.group(2).strip()\n            else:\n                salary= salContent\n    salary_text = \"|||||||||||||||\".join([salary, salary_notes])\n    return salary_text\n\n\ndef _duties_apply(text):\n    \"\"\"\n    Extract job duties section\n    \"\"\"\n    duties=''\n    result=duties= re.search(\"DUTIES(.*?)REQUIREMENT\", text)\n    if result:\n        duties= result.group(1).strip()\n    return duties\n\ndef _requirements_apply(text):\n    \"\"\"\n    Extract entire job requirements section\n    \"\"\"\n    req='|'.join([\"REQUIREMENT\/MIMINUMUM QUALIFICATION\",\n                  \"REQUIREMENT\/MINUMUM QUALIFICATION\",\n                  \"REQUIREMENT\/MINIMUM QUALIFICATION\",\n                  \"REQUIREMENT\/MINIMUM QUALIFICATIONS\",\n                  \"REQUIREMENT\/ MINIMUM QUALIFICATION\",\n                  \"REQUIREMENTS\/MINUMUM QUALIFICATIONS\",\n                  \"REQUIREMENTS\/ MINIMUM QUALIFICATIONS\",\n                  \"REQUIREMENTS\/MINIMUM QUALIFICATIONS\",\n                  \"REQUIREMENTS\/MINIMUM REQUIREMENTS\",\n                  \"REQUIREMENTS\/MINIMUM QUALIFCATIONS\",\n                  \"MINIMUM REQUIREMENTS:\",\n                  \"REQUIREMENTS\",\n                  \"REQUIREMENT\"])\n    \n    result= re.search(f\"({req})(.*)(WHERE TO APPLY|HOW TO APPLY)\", text)\n    requirements=''\n    if result:\n        requirements = result.group(2).strip()\n    return requirements\n\n\ndef _where_to_apply(text):\n    \n    \"\"\"\n    Extract entire 'WHERE TO APPLY' section\n    \"\"\"\n    \n    where_to_apply = ''\n    result= re.search(\n        \"(HOW TO APPLY|WHERE TO APPLY)(.*)(APPLICATION DEADLINE|APPLICATION PROCESS)\",\n        text)\n    if result:\n        where_to_apply= result.group(2).strip()\n    else:\n        result= re.search(\n            \"(HOW TO APPLY|WHERE TO APPLY)(.*)(SELECTION PROCESS|SELELCTION PROCESS)\",\n            text)\n        if result:\n            where_to_apply= result.group(2).strip()\n    return where_to_apply\n\ndef _deadline_apply(text):\n    \"\"\"\n    Extract entire deadline section\n    \"\"\"\n    \n    deadline=''\n    result= re.search(\n        \"(APPLICATION DEADLINE|APPLICATION PROCESS)(.*?)(SELECTION PROCESS|SELELCTION PROCESS)\",\n        text)\n    if result:\n        deadline= result.group(2).strip()\n    else:\n        result= re.search(\n            \"(APPLICATION DEADLINE|APPLICATION PROCESS)(.*?)(Examination Weight:)\",\n            text)\n        if result:\n            deadline= result.group(2).strip()\n            \n    return deadline\n\ndef _selection_process_apply(text):\n    \n    \"\"\"\n    Extract selectioin process section\n    \"\"\"\n    \n    selection_process=''\n    result=selection_process= re.search(\n        \"(SELECTION PROCESS|Examination Weight:)(.*)(APPOINTMENT|APPOINTMENT IS SUBJECT TO:)\",\n        text)\n    if result:\n        selection_process= result.group(2).strip()\n    else:\n        result=selection_process= re.search(\n            \"(SELECTION PROCESS|Examination Weight:)(.*)\",\n            text)\n        if result:\n            selection_process= result.group(2).strip()\n            \n    return selection_process","456fb600":"# first let's convert folder of raw text job bulletins\n# to pandas dataframe\ndata = convert_jobs_to_df()\n\n# do some initial text cleaning\ndata = pre_processing(data)\n\n###############################\n# Here is actual extraction of main section begin\n# we just call the function\n###############################\ndata = extract_job_title(data) # extract job title\n\ndata = extract_class_code(data) # extract class code\n\ndata = extract_open_date(data) # extract open date\n\ndata = extract_exam_type(data) # extract exam type section\n\ndata = extract_salary(data) # extract salary section\n\ndata = extract_duties(data) # extract duties section\n\ndata = extract_requirements(data) # extract requirements section\n\ndata = extract_where_to_apply(data) # extract where to apply section\n\ndata = extract_deadline(data) # extract deadline section\n\ndata = extract_selection_process(data) # extract selectin pro section\n\n# create a new column containing whole text but clean from new line and tab \ndata['raw_clean_job_text'] = data['raw_job_text'].apply(\n    lambda x: _whole_clean_text(x))\n\n# finally let's see what we have got\ndata.head()","8eb6f602":"data.tail()","ced36bb2":"data.shape","50b89bf8":"female = [\n    \"agree\",\"affectionate\",\"child\",\"cheer\",\"collab\",\"commit\",\"communal\",\n    \"compassion\",\"connect\",\"considerate\",\"cooperat\",\"co-operat\",\n    \"depend\",\"emotiona\",\"empath\",\"feel\",\"flatterable\",\"gentle\",\n    \"honest\",\"interpersonal\",\"interdependen\",\"interpersona\",\"inter-personal\",\n    \"inter-dependen\",\"inter-persona\",\"kind\",\"kinship\",\"loyal\",\"modesty\",\n    \"nag\",\"nurtur\",\"pleasant\",\"polite\",\"quiet\",\"respon\",\"sensitiv\",\n    \"submissive\",\"support\",\"sympath\",\"tender\",\"together\",\"trust\",\"understand\",\n    \"warm\",\"whin\",\"enthusias\",\"inclusive\",\"yield\",\"share\",\"sharin\"\n]\n\nmasculine = [\n    \"active\",\"adventurous\",\"aggress\",\"ambitio\",\n    \"analy\",\"assert\",\"athlet\",\"autonom\",\"battle\",\"boast\",\"challeng\",\n    \"champion\",\"compet\",\"confident\",\"courag\",\"decid\",\"decision\",\"decisive\",\n    \"defend\",\"determin\",\"domina\",\"dominant\",\"driven\",\"fearless\",\"fight\",\n    \"force\",\"greedy\",\"head-strong\",\"headstrong\",\"hierarch\",\"hostil\",\n    \"impulsive\",\"independen\",\"individual\",\"intellect\",\"lead\",\"logic\",\n    \"objective\",\"opinion\",\"outspoken\",\"persist\",\"principle\",\"reckless\",\n    \"self-confiden\",\"self-relian\",\"self-sufficien\",\"selfconfiden\",\n    \"selfrelian\",\"selfsufficien\",\"stubborn\",\"superior\",\"unreasonab\"\n]\n\nhyphenated_coded_words = [\n    \"co-operat\",\"inter-personal\",\"inter-dependen\",\"inter-persona\",\n    \"self-confiden\",\"self-relian\",\"self-sufficien\"\n]\n\npossible_codings = (\n    \"strongly feminine-coded\",\"feminine-coded\",\"neutral\",\n    \"masculine-coded\",\"strongly masculine-coded\"\n)","751740f9":"def base_info(data):\n  print(f' Zero \\n:{data.isnull().sum()}\\n')\n  print(f'NaN :\\n {data.isna().sum()}\\n')\n  print(f\"type of data:\\n {data.dtypes}\\n\")","43700dbf":"base_info(data)","199b7c80":"data.info","3ca8ae4f":"data['JOB_CLASS_NO'].fillna(0, inplace=True)","04859408":"data['JOB_CLASS_NO'] = data['JOB_CLASS_NO'].astype(str).astype(int)","b4898d2d":"data['JOB_CLASS_NO'].describe()","a8e3c548":"data.JOB_CLASS_TITLE.str.contains(r'gender_words').sum()  ","b1bb276e":"for i in masculine:\n    sum = data.JOB_CLASS_TITLE.str.contains(r'i').sum() + data.TEMP_EXAM_TYPE.str.contains(r'i').sum() + data.TEMP_REQUIREMENTS.str.contains(r'i').sum() + data.SELECTION_PROCESS   .str.contains(r'i').sum()\n    print(f'{i} : {sum}')","092e8045":"for i in masculine:\n    sum = data.JOB_CLASS_TITLE.str.contains(r'i').sum() + data.TEMP_EXAM_TYPE.str.contains(r'i').sum() + data.TEMP_REQUIREMENTS.str.contains(r'i').sum() + data.SELECTION_PROCESS\t.str.contains(r'i').sum()\n    print(f'{i} : {sum}')","ee349f95":"large std","debd0b84":"the same number of featured words is everywhere","0b5f8cd8":"**Analytics**","95987be3":"Let's divide the words by gender","f586e071":"JOB_CLASS_NO must be int!","0e937c2a":"Problem Description: The city of LA provided a folder full of plain text job postings. There are 683 job postings in the folder. Each job posting is a text file containing raw job description. The goal is that we have to extract particular important information from the raw text file and store those in a CSV file (A row of the CSV is single job information). For example, we can extract a job's salary, open date, requirements and store each of the info in a separate column in the CSV. The city of LA also provides a data dictionary containing general information about what information we should extract from the job postings.\n\nLet's see an example of job posting first for better understanding.","b57c665f":"**Let's go**\n1. Upload the data and convert it to csv","c4e06e17":"Delete nan","87aaaef6":"From May 8, 2019, to June 22, 2019, Kaggle host an analytics competition named \"Data Science for Good: City of Los Angeles\". The goal of this competition is \"Help the City of Los Angeles to structure and analyze its job descriptions\".\n\nThe City of Los Angeles faces a big hiring challenge: 1\/3 of its 50,000 workers are eligible to retire by July of 2020. The city has partnered with Kaggle to create a competition to improve the job bulletins that will fill all those open positions.\n\nThe City of LA provided some important datasets for this competition. 600+ job bulletins as a text file, and other additional data. The goal is to convert a folder full of plain-text job postings into a single structured CSV file and then to use this data to:"}}