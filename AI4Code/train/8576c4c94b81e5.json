{"cell_type":{"eff72270":"code","f6adde76":"code","e56532e0":"code","cd4dc4b5":"code","aae9011f":"code","7447e171":"code","b5ad8c55":"code","f76a8544":"code","ae58a59b":"code","fe784aa4":"code","2884ee53":"code","22618944":"code","1c5f10f1":"markdown","4d93c6e6":"markdown","e01eb616":"markdown","e060dd73":"markdown","645530a3":"markdown","57733c89":"markdown","3496d76a":"markdown","bcd1c419":"markdown"},"source":{"eff72270":"\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","f6adde76":"import matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import subplot\nfrom skimage.color import rgb2hsv\nfrom skimage import data\nfrom skimage.color import rgb2gray\nplt.rcParams[\"figure.figsize\"] = (15,15)\nimport warnings\nwarnings.filterwarnings('ignore')\nimport numpy as np\n","e56532e0":"\ndef read_image(fn):\n    # save the image\n    image = plt.imread(fn)\n\n    # display\n    plt.subplot(2, 1, 1)\n    plt.title('Original Image')\n    plt.axis('off')\n    plt.imshow(image)\n\n    # Extract 2-D arrays of the RGB channels: red, blue, green\n    red, blue, green = image[:, :, 0], image[:, :, 1], image[:, :, 2]\n\n    # Flatten the 2-D arrays of the RGB channels into 1-D\n    red_pixels = red.flatten()\n    blue_pixels = blue.flatten()\n    green_pixels = green.flatten()\n\n    # Overlay histograms of the pixels of each color in the bottom subplot\n    plt.subplot(2, 1, 2)\n    plt.title('RBG Histogram of the image')\n    plt.xlim((0, 256))\n    sns.distplot(red_pixels, bins=64,  color='red', hist_kws=dict(edgecolor=\"k\"))\n    sns.distplot(blue_pixels, bins=64,  color='blue', hist_kws=dict(edgecolor=\"k\"))\n    sns.distplot(green_pixels, bins=64,  color='green', hist_kws=dict(edgecolor=\"k\"))\n    # Display the plot\n    plt.show()","cd4dc4b5":"read_image('\/kaggle\/input\/ferrari.jpg')","aae9011f":"read_image('\/kaggle\/input\/audi.jpg')","7447e171":"def color_to_bw(fn):\n    image = plt.imread(fn)\n    greyscale = rgb2gray(image)\n    fig, axes = plt.subplots(1, 2, figsize=(30, 30))\n    ax = axes.ravel()\n    ax[0].imshow(image)\n    ax[0].set_title(\"Original\")\n    ax[1].imshow(greyscale, cmap=plt.cm.gray)\n    ax[1].set_title(\"Grayscale\")\n\n    fig.tight_layout()\n    plt.show()\n","b5ad8c55":"color_to_bw('\/kaggle\/input\/ferrari.jpg')","f76a8544":"def color_to_negative(fn):\n    image = plt.imread(fn)\n    negative =255- image # neg = (L-1) - img\n    fig, axes = plt.subplots(1, 2, figsize=(30, 30))\n    ax = axes.ravel()\n\n    ax[0].imshow(image)\n    ax[0].set_title(\"Original\")\n    ax[1].imshow(negative, cmap=plt.cm.gray)\n    ax[1].set_title(\"negative\")\n\n    fig.tight_layout()\n    plt.show()","ae58a59b":"color_to_negative('\/kaggle\/input\/ferrari.jpg')","fe784aa4":"import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom skimage import color, data, restoration\n\nastro = color.rgb2gray(plt.imread('\/kaggle\/input\/ferrari.jpg'))\nfrom scipy.signal import convolve2d as conv2\npsf = np.ones((5, 5)) \/ 25\nastro = conv2(astro, psf, 'same')\nastro += 0.1 * astro.std() * np.random.standard_normal(astro.shape)\n\ndeconvolved, _ = restoration.unsupervised_wiener(astro, psf)\n\nfig, ax = plt.subplots(nrows=1, ncols=2, figsize=(20, 20),\n                       sharex=True, sharey=True)\n\nplt.gray()\n\nax[0].imshow(astro, vmin=deconvolved.min(), vmax=deconvolved.max())\nax[0].axis('off')\nax[0].set_title('Original in BW')\n\nax[1].imshow(deconvolved)\nax[1].axis('off')\nax[1].set_title('Enhanced')\n\nfig.tight_layout()\n\nplt.show()","2884ee53":"from skimage import data, io, segmentation, color\nfrom skimage.future import graph\nimport numpy as np\n\n\ndef _weight_mean_color(graph, src, dst, n):\n    \"\"\"Callback to handle merging nodes by recomputing mean color.\n\n    The method expects that the mean color of `dst` is already computed.\n\n    Parameters\n    ----------\n    graph : RAG\n        The graph under consideration.\n    src, dst : int\n        The vertices in `graph` to be merged.\n    n : int\n        A neighbor of `src` or `dst` or both.\n\n    Returns\n    -------\n    data : dict\n        A dictionary with the `\"weight\"` attribute set as the absolute\n        difference of the mean color between node `dst` and `n`.\n    \"\"\"\n\n    diff = graph.nodes[dst]['mean color'] - graph.nodes[n]['mean color']\n    diff = np.linalg.norm(diff)\n    return {'weight': diff}\n\n\ndef merge_mean_color(graph, src, dst):\n    \"\"\"Callback called before merging two nodes of a mean color distance graph.\n\n    This method computes the mean color of `dst`.\n\n    Parameters\n    ----------\n    graph : RAG\n        The graph under consideration.\n    src, dst : int\n        The vertices in `graph` to be merged.\n    \"\"\"\n    graph.nodes[dst]['total color'] += graph.nodes[src]['total color']\n    graph.nodes[dst]['pixel count'] += graph.nodes[src]['pixel count']\n    graph.nodes[dst]['mean color'] = (graph.nodes[dst]['total color'] \/\n                                      graph.nodes[dst]['pixel count'])\n\n\nimg = plt.imread('\/kaggle\/input\/ferrari.jpg')\nlabels = segmentation.slic(img, compactness=30, n_segments=400)\ng = graph.rag_mean_color(img, labels)\n\nlabels2 = graph.merge_hierarchical(labels, g, thresh=35, rag_copy=False,\n                                   in_place_merge=True,\n                                   merge_func=merge_mean_color,\n                                   weight_func=_weight_mean_color)\n\nout = color.label2rgb(labels2, img, kind='avg', bg_label=0)\nout = segmentation.mark_boundaries(out, labels2, (0, 0, 0))\nio.imshow(out)\nio.show()","22618944":"from skimage import data, segmentation, filters, color\nfrom skimage.future import graph\nfrom matplotlib import pyplot as plt\n\n\ndef weight_boundary(graph, src, dst, n):\n    \"\"\"\n    Handle merging of nodes of a region boundary region adjacency graph.\n\n    This function computes the `\"weight\"` and the count `\"count\"`\n    attributes of the edge between `n` and the node formed after\n    merging `src` and `dst`.\n\n\n    Parameters\n    ----------\n    graph : RAG\n        The graph under consideration.\n    src, dst : int\n        The vertices in `graph` to be merged.\n    n : int\n        A neighbor of `src` or `dst` or both.\n\n    Returns\n    -------\n    data : dict\n        A dictionary with the \"weight\" and \"count\" attributes to be\n        assigned for the merged node.\n\n    \"\"\"\n    default = {'weight': 0.0, 'count': 0}\n\n    count_src = graph[src].get(n, default)['count']\n    count_dst = graph[dst].get(n, default)['count']\n\n    weight_src = graph[src].get(n, default)['weight']\n    weight_dst = graph[dst].get(n, default)['weight']\n\n    count = count_src + count_dst\n    return {\n        'count': count,\n        'weight': (count_src * weight_src + count_dst * weight_dst)\/count\n    }\n\n\ndef merge_boundary(graph, src, dst):\n    \"\"\"Call back called before merging 2 nodes.\n\n    In this case we don't need to do any computation here.\n    \"\"\"\n    pass\n\nimg = plt.imread('\/kaggle\/input\/ferrari.jpg')\nedges = filters.sobel(color.rgb2gray(img))\nlabels = segmentation.slic(img, compactness=30, n_segments=400)\ng = graph.rag_boundary(labels, edges)\n\ngraph.show_rag(labels, g, img)\nplt.title('Initial RAG')\n\nlabels2 = graph.merge_hierarchical(labels, g, thresh=0.08, rag_copy=False,\n                                   in_place_merge=True,\n                                   merge_func=merge_boundary,\n                                   weight_func=weight_boundary)\n\ngraph.show_rag(labels, g, img)\nplt.title('RAG after hierarchical merging')\n\nplt.figure()\nout = color.label2rgb(labels2, img, kind='avg', bg_label=0)\nplt.imshow(out)\nplt.title('Final segmentation')\n\nplt.show()","1c5f10f1":"\nThis example demonstrates how to perform hierarchical merging on region boundary Region Adjacency Graphs (RAGs). Region boundary RAGs can be constructed with the skimage.future.graph.rag_boundary() function. The regions with the lowest edge weights are successively merged until there is no edge with weight less than thresh. The hierarchical merging is done through the skimage.future.graph.merge_hierarchical() function. For an example of how to construct region boundary based RAGs, see Region Boundary based RAGs.","4d93c6e6":"# image resolution enhancement","e01eb616":"# **Convert Color image to Negative**","e060dd73":"# RAG Merging","645530a3":"# Hierarchical Merging of Region Boundary RAGs","57733c89":"# **Convert Color Image to Black & White**","3496d76a":"\nThis example constructs a Region Adjacency Graph (RAG) and progressively merges regions that are similar in color. Merging two adjacent regions produces a new region with all the pixels from the merged regions. \nRegions are merged until no highly similar region pairs remain","bcd1c419":"# Read an image and get its RGB distribution"}}