{"cell_type":{"f23be38e":"code","7c0065fb":"code","e3b77a53":"code","48f25988":"code","58330f42":"code","aaf15848":"code","4f164ffd":"code","a4463139":"code","6fe8acc8":"code","c172132f":"code","4e498b5e":"code","b3adf029":"code","9bc3dba1":"code","dc2318de":"code","a3aed151":"code","252874d2":"code","0a948a33":"code","ecc8ad41":"code","a71845f0":"code","f3d2b671":"code","c2ea968b":"code","8aeca376":"code","26ffba20":"code","66f17965":"code","ba66390e":"code","d4e83eed":"code","7d9f9fbe":"markdown","07d8e40a":"markdown","8f5642a0":"markdown","22d0e1e5":"markdown","7e2615fc":"markdown","02d1c60f":"markdown","00e1d44a":"markdown","5abb09c4":"markdown","facca2c4":"markdown","d7d4600c":"markdown","8089ec48":"markdown","69bc9c61":"markdown","482a3a5d":"markdown","ae051cf8":"markdown","20e207a6":"markdown","c178748f":"markdown","14a26eea":"markdown","df1b7f29":"markdown","79ba879a":"markdown","3fed0968":"markdown","05a819c9":"markdown"},"source":{"f23be38e":"import numpy as np # linear algebra\nimport pandas as pd\npd.set_option(\"display.max_rows\", 101)\nimport os\nprint(os.listdir(\"..\/input\"))\nimport cv2\nimport json\nimport matplotlib.pyplot as plt\n%matplotlib inline\nplt.rcParams[\"font.size\"] = 15\nimport seaborn as sns\nfrom collections import Counter\nfrom PIL import Image\nimport math\nimport seaborn as sns\nfrom collections import defaultdict\nfrom pathlib import Path\nimport cv2\nfrom tqdm import tqdm","7c0065fb":"input_dir = \"..\/input\/\"","e3b77a53":"train_df = pd.read_csv(\"..\/input\/train.csv\")\nsample_df = pd.read_csv(\"..\/input\/sample_submission.csv\")","48f25988":"train_df.head()","58330f42":"sample_df.head()","aaf15848":"class_dict = defaultdict(int)\n\nkind_class_dict = defaultdict(int)\n\nno_defects_num = 0\ndefects_num = 0\n\nfor col in range(0, len(train_df), 4):\n    img_names = [str(i).split(\"_\")[0] for i in train_df.iloc[col:col+4, 0].values]\n    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):\n        raise ValueError\n        \n    labels = train_df.iloc[col:col+4, 1]\n    if labels.isna().all():\n        no_defects_num += 1\n    else:\n        defects_num += 1\n    \n    kind_class_dict[sum(labels.isna().values == False)] += 1\n        \n    for idx, label in enumerate(labels.isna().values.tolist()):\n        if label == False:\n            class_dict[idx+1] += 1","4f164ffd":"print(\"the number of images with no defects: {}\".format(no_defects_num))\nprint(\"the number of images with defects: {}\".format(defects_num))","a4463139":"fig, ax = plt.subplots()\nsns.barplot(x=list(class_dict.keys()), y=list(class_dict.values()), ax=ax)\nax.set_title(\"the number of images for each class\")\nax.set_xlabel(\"class\")\nclass_dict","6fe8acc8":"fig, ax = plt.subplots()\nsns.barplot(x=list(kind_class_dict.keys()), y=list(kind_class_dict.values()), ax=ax)\nax.set_title(\"Number of classes included in each image\");\nax.set_xlabel(\"number of classes in the image\")\nkind_class_dict","c172132f":"train_size_dict = defaultdict(int)\ntrain_path = Path(\"..\/input\/train_images\/\")\n\nfor img_name in train_path.iterdir():\n    img = Image.open(img_name)\n    train_size_dict[img.size] += 1","4e498b5e":"train_size_dict","b3adf029":"test_size_dict = defaultdict(int)\ntest_path = Path(\"..\/input\/test_images\/\")\n\nfor img_name in test_path.iterdir():\n    img = Image.open(img_name)\n    test_size_dict[img.size] += 1","9bc3dba1":"test_size_dict","dc2318de":"palet = [(249, 192, 12), (0, 185, 241), (114, 0, 218), (249,50,12)]","a3aed151":"def name_and_mask(start_idx):\n    col = start_idx\n    img_names = [str(i).split(\"_\")[0] for i in train_df.iloc[col:col+4, 0].values]\n    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):\n        raise ValueError\n\n    labels = train_df.iloc[col:col+4, 1]\n    mask = np.zeros((256, 1600, 4), dtype=np.uint8)\n\n    for idx, label in enumerate(labels.values):\n        if label is not np.nan:\n            mask_label = np.zeros(1600*256, dtype=np.uint8)\n            label = label.split(\" \")\n            positions = map(int, label[0::2])\n            length = map(int, label[1::2])\n            for pos, le in zip(positions, length):\n                mask_label[pos-1:pos+le-1] = 1\n            mask[:, :, idx] = mask_label.reshape(256, 1600, order='F')\n    return img_names[0], mask","252874d2":"def show_mask_image(col):\n    name, mask = name_and_mask(col)\n    img = cv2.imread(str(train_path \/ name))\n    fig, ax = plt.subplots(figsize=(15, 15))\n\n    for ch in range(4):\n        contours, _ = cv2.findContours(mask[:, :, ch], cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)\n        for i in range(0, len(contours)):\n            cv2.polylines(img, contours[i], True, palet[ch], 2)\n    ax.set_title(name)\n    ax.imshow(img)\n    plt.show()","0a948a33":"fig, ax = plt.subplots(1, 4, figsize=(15, 5))\nfor i in range(4):\n    ax[i].axis('off')\n    ax[i].imshow(np.ones((50, 50, 3), dtype=np.uint8) * palet[i])\n    ax[i].set_title(\"class color: {}\".format(i+1))\nfig.suptitle(\"each class colors\")\n\nplt.show()","ecc8ad41":"idx_no_defect = []\nidx_class_1 = []\nidx_class_2 = []\nidx_class_3 = []\nidx_class_4 = []\nidx_class_multi = []\nidx_class_triple = []\n\nfor col in range(0, len(train_df), 4):\n    img_names = [str(i).split(\"_\")[0] for i in train_df.iloc[col:col+4, 0].values]\n    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):\n        raise ValueError\n        \n    labels = train_df.iloc[col:col+4, 1]\n    if labels.isna().all():\n        idx_no_defect.append(col)\n    elif (labels.isna() == [False, True, True, True]).all():\n        idx_class_1.append(col)\n    elif (labels.isna() == [True, False, True, True]).all():\n        idx_class_2.append(col)\n    elif (labels.isna() == [True, True, False, True]).all():\n        idx_class_3.append(col)\n    elif (labels.isna() == [True, True, True, False]).all():\n        idx_class_4.append(col)\n    elif labels.isna().sum() == 1:\n        idx_class_triple.append(col)\n    else:\n        idx_class_multi.append(col)","a71845f0":"for idx in idx_no_defect[:5]:\n    show_mask_image(idx)","f3d2b671":"for idx in idx_class_1[:5]:\n    show_mask_image(idx)","c2ea968b":"for idx in idx_class_2[:5]:\n    show_mask_image(idx)","8aeca376":"for idx in idx_class_3[:5]:\n    show_mask_image(idx)","26ffba20":"for idx in idx_class_4[:5]:\n    show_mask_image(idx)","66f17965":"for idx in idx_class_multi[:5]:\n    show_mask_image(idx)","ba66390e":"for idx in idx_class_triple:\n    show_mask_image(idx)","d4e83eed":"for col in tqdm(range(0, len(train_df), 4)):\n    name, mask = name_and_mask(col)\n    if (mask.sum(axis=2) >= 2).any():\n        show_mask_image(col)","7d9f9fbe":"* All pixels have 1 or less label.","07d8e40a":"## images with no defect","8f5642a0":"## images with defect(label: 1)","22d0e1e5":"## images with defect(label: 2)","7e2615fc":"# Is there the pixel that have multi label?","02d1c60f":"### How many classes do each image have?","00e1d44a":"## import modules and define models","5abb09c4":"# Thank you very much for reading my post through to the end.\nPlease tell me when I make mistakes in program and English.  \nI hope this kernel will help.  \nIf you think this kernel is useful, please upvote.  ","facca2c4":"* All image have same shape, (1600, 256).","d7d4600c":"# Let's visualization masks!","8089ec48":"## read all text data\n#### file description\n* train_images\/ - folder of training images\n* test_images\/ - folder of test images (you are segmenting and classifying these images)\n* train.csv - training annotations which provide segments for defects (ClassId = [1, 2, 3, 4])\n* sample_submission.csv - a sample submission file in the correct format; note, **each ImageId 4 rows, one for each of the 4 defect classes**","69bc9c61":"* We can see 4 type defect","482a3a5d":"## images with defect(contain 3 type label)","ae051cf8":"## images with defect(label: 4)","20e207a6":"## images with defect(contain multi label)","c178748f":"## images with defect(label: 3)","14a26eea":"# Let's Detect Steel Defect!","df1b7f29":"* almost image have no defect or one kind of defect","79ba879a":"### First, check the number of each class.","3fed0968":"* There are similar numbers of images with and without defects.\n* class is imbalanced","05a819c9":"## check image data\n### image size"}}