{"cell_type":{"545c2a26":"code","ffac0ce0":"code","df77d910":"code","cef2c38e":"code","4d6bf2dc":"code","cc03f2a3":"code","a4c4a1f4":"markdown","81094509":"markdown","4d9a3f5d":"markdown","6b4091dc":"markdown","653d1bcb":"markdown"},"source":{"545c2a26":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom PIL import Image\nfrom scipy.misc import imread\nimport tensorflow as tf\nsns.set()\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\ndata_train_dir = r'..\/input\/human-protein-atlas-image-classification\/train'\nanswer_file_path = r'..\/input\/human-protein-atlas-image-classification\/train.csv'\n\nchannels = ['_yellow', '_red', '_green', '_blue']","ffac0ce0":"def make_rgb_image_from_four_channels(channels: list, image_width=512, image_height=512) -> np.ndarray:\n    \"\"\"\n    It makes literally RGB image from source four channels, \n    where yellow image will be yellow color, red will be red and so on  \n    \"\"\"\n    rgb_image = np.zeros(shape=(image_height, image_width, 3), dtype=np.float)\n    yellow = np.array(Image.open(channels[0]))\n    # yellow is not added as red + bleu\n    rgb_image[:, :, 0] += yellow\/2   \n    rgb_image[:, :, 2] += yellow\/2\n    # loop for R,G and B channels\n    for index, channel in enumerate(channels[1:]):\n        current_image = Image.open(channel)\n        rgb_image[:, :, index] += current_image\n    \n    rgb_image = np.clip(rgb_image,0,255)\n    return rgb_image.astype(np.uint8)","df77d910":"df_duplicates = pd.read_csv(\"..\/input\/duplicatesproposal\/duplicates-personnal.csv\")\ndf_duplicates","cef2c38e":"one_time_list = []\ndf_duplicate_uniq = pd.DataFrame(columns=['Keep','Remove'])\nfor i in range(len(df_duplicates)):\n    if not ( df_duplicates.iloc[i,0] in one_time_list or df_duplicates.iloc[i,1] in one_time_list):\n        one_time_list = one_time_list + [df_duplicates.iloc[i,0]] + [df_duplicates.iloc[i,1]]\n        df_duplicate_uniq = df_duplicate_uniq.append({'Keep':df_duplicates.iloc[i,0],'Remove':df_duplicates.iloc[i,1]}, ignore_index=True)\n        \n# df_duplicate_uniq.iloc[99,0] and [129,0] are malformed image\ndf_duplicate_uniq.iloc[99,0], df_duplicate_uniq.iloc[99,1] = df_duplicate_uniq.iloc[99,1], df_duplicate_uniq.iloc[99,0] \ndf_duplicate_uniq.iloc[129,0], df_duplicate_uniq.iloc[129,1] = df_duplicate_uniq.iloc[129,1], df_duplicate_uniq.iloc[129,0] \n\nprint(df_duplicate_uniq.head())\nprint(\"len(df_duplicates)\",len(df_duplicates))\nprint(\"len(df_duplicate_uniq)\",len(df_duplicate_uniq))","4d6bf2dc":"rg = np.arange(95,115,1)\nfor i in rg:\n    current_line = df_duplicate_uniq.loc[i]\n    image_names_1 = [os.path.join(data_train_dir, current_line[0]) \n                   + x + '.png' for x in channels]\n    image_names_2 = [os.path.join(data_train_dir, current_line[1]) \n                   + x + '.png' for x in channels]\n    rgb_image_1 = make_rgb_image_from_four_channels(image_names_1)\n    rgb_image_2 = make_rgb_image_from_four_channels(image_names_2)\n    fig, ax = plt.subplots(nrows = 1, ncols=2, figsize=(29,29))\n    ax[0].imshow(rgb_image_1)\n    ax[1].imshow(rgb_image_2)","cc03f2a3":"df_duplicate_uniq.to_csv(\"duplicates_final_list.csv\")","a4c4a1f4":"# Save","81094509":"# Functions for visualization","4d9a3f5d":"# Displaying","6b4091dc":"# Remove duplicates in duplicate list ","653d1bcb":"# From the great work of Tilii and Brian\nhttps:\/\/www.kaggle.com\/c\/human-protein-atlas-image-classification\/discussion\/72534\n\n### This kernel unite and check their findings\n### It produces an unique list of duplicates from their lists"}}