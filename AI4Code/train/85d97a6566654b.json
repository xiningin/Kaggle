{"cell_type":{"fa852930":"code","32151462":"code","7690e0d0":"code","8d01e608":"code","245fe2df":"code","0f28e0b9":"code","9a829528":"code","b292cc19":"code","87e8ac65":"code","c1926fe7":"code","eb45a83c":"code","2226fb49":"code","ef62efa6":"code","da32811c":"code","e177b011":"code","c889c1af":"code","51ca5867":"code","74309d09":"code","75fc580a":"code","3700e2f1":"code","42e7d047":"code","a0b70ed4":"code","352a535a":"code","00b75673":"code","41277fe4":"code","0f2727de":"code","ac77ccc8":"code","4f71b67d":"code","4e4b76f5":"code","828f2282":"code","9c365576":"code","21898584":"code","22971292":"code","11e582a1":"code","e10d0280":"code","7aa0922f":"code","6bf60395":"code","c68da4f1":"code","f6261ef4":"code","cb66e500":"code","5879fe13":"code","9d830fb2":"code","e1b6bd49":"code","926d6973":"code","47fd4368":"code","dbaef26a":"code","8171a05a":"code","1b6ef1b4":"code","c94d2d58":"code","6fa5f937":"code","2b45ec0b":"code","d6522d27":"code","cd053c50":"code","c9dc7a4b":"code","7acef362":"code","e865fd67":"code","f6ff2e65":"code","91381155":"code","069dd6ba":"code","b76bea60":"code","454590b3":"code","78632f4d":"code","78b34308":"code","4c3784db":"markdown","5a466c0e":"markdown","c9b8e2f3":"markdown","ce56672d":"markdown","b5b1e5ce":"markdown","43f17652":"markdown","6d71e4fc":"markdown","1efca7cf":"markdown","536b6ead":"markdown","fe32996a":"markdown","972c30b3":"markdown","8aefef84":"markdown","d10929ff":"markdown","00318c47":"markdown","a242cec7":"markdown","1830375f":"markdown","d448ba48":"markdown","38398a19":"markdown","97714a77":"markdown","123717ae":"markdown","4ff99bea":"markdown","e25c72fd":"markdown","6539ada3":"markdown","ca57f876":"markdown"},"source":{"fa852930":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","32151462":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport math\nimport random\nfrom IPython.display import display, clear_output\nfrom copy import deepcopy","7690e0d0":"def init_env(shape):\n    \"\"\"Returns an empty square domain:\n\n    >>> init_env(5) or init_env((5,5))\n    array([[ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.]])\n    \"\"\"\n    if type(shape) is tuple:\n        return np.zeros(shape)\n    if type(shape) is int:\n        return np.zeros((shape,shape))\n    else:\n        raise TypeError","8d01e608":"def x(a):\n    \"\"\"Return the first element of a 2-tuple.\n    >>> x([1,2])\n    1\n    \"\"\"\n    return a[0]\n\n\ndef y(a):\n    \"\"\"Return the second element of a 2-tuple.\n    >>> y([1,2])\n    2\n    \"\"\"\n    return a[1]\n\ndef distance(a,b):\n    \"\"\"Euclidean distance (in pixels).\n\n    >>> distance( (1,1),(2,2) ) == math.sqrt(2)\n    True\n    \"\"\"\n    return np.sqrt( (x(a)-x(b))**2 + (y(a)-y(b))**2 )","245fe2df":"def coverage(domain, sensors, Rs):\n    \"\"\"Set a given domain's cells to on if they are visible\n    from one of the given sensors at the given sensor_range.\n\n    >>> coverage(np.zeros((5,5)),[(2,2)],2)\n    array([[0.        , 0.        , 0.        , 0.        , 0.        ],\n          [0.        , 0.58578644, 0.66666667, 0.58578644, 0.        ],\n          [0.        , 0.66666667, 1.        , 0.66666667, 0.        ],\n          [0.        , 0.58578644, 0.66666667, 0.58578644, 0.        ],\n          [0.        , 0.        , 0.        , 0.        , 0.        ]])\n    \"\"\"\n    for py in range(len(domain)):\n        for px in range(len(domain[py])):\n            p = (py,px)\n            if domain[p] >= 0: #if the case isn't a wall\n                for sensor in sensors:\n                    if domain[y(sensor),x(sensor)] >= 0:  #check if sensors isn't on a wall                   \n                        if distance(sensor,(px,py)) < Rs: #if it is in range of a sensor\n                            walls_encountered = [domain[p] for p in bresenham(y(sensor),x(sensor),py, px) if domain[p]<0] \n                            exp = 1\n                            for Rd in walls_encountered:\n                                exp *= math.exp(-Rd)\n                            domain[p] = max(domain[p], Rs\/(distance(sensor,(px,py))*exp+Rs))\n    return domain","0f28e0b9":"def bresenham(x0, y0, x1, y1):\n    \"\"\"Compute the set of pixels (integer coordinates) of the line\n    between the given line (x0,y0) -> (x1,y1).\n    Use the Bresenham's algorithm.\n    This make a generator that yield the start and the end points.\n\n    >> [p for p in bresenham(1, 0, 5, 3)]\n    [(1, 0), (2, 1), (3, 2), (4, 2), (5, 3)]\n    \"\"\"\n    dx = x1 - x0\n    dy = y1 - y0\n\n    xsign = 1 if dx > 0 else -1\n    ysign = 1 if dy > 0 else -1\n\n    dx = abs(dx)\n    dy = abs(dy)\n\n    #orientation\n    if dx > dy:\n        xx, xy, yx, yy = xsign, 0, 0, ysign\n    else:\n        dx, dy = dy, dx\n        xx, xy, yx, yy = 0, ysign, xsign, 0\n\n    decision = 2*dy - dx\n    \n    y = 0\n    for x in range(dx + 1):\n        yield x0 + x*xx + y*yx, y0 + x*xy + y*yy\n        if decision >= 0:\n            y += 1\n            decision -= 2*dx\n        decision += 2*dy","9a829528":"def add_walls(domain, list_coord, R = None, obstacle_type=\"brick\"):\n    \"\"\"Add walls to a domain by taking in the start \n    and end coordinate of each wall\n\n    >>> add_walls(np.zeros((5,5)),[((2,2),(2,0)),((4,4),(3,4))])\n    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ],\n          [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ],\n          [-1.28, -1.28, -1.28,  0.  ,  0.  ],\n          [ 0.  ,  0.  ,  0.  ,  0.  , -1.28],\n          [ 0.  ,  0.  ,  0.  ,  0.  , -1.28]])\n    \"\"\" \n    #Value given by the paper\n    if R is None:\n        if obstacle_type == \"brick\":\n            R = 1.28\n        elif obstacle_type == \"wood\":\n            R = 0.46\n        elif obstacle_type == \"glass\":\n            R = 0.43\n        else:\n            raise ValueError(\"This type of obstacle isn't known.\")\n    for wall in list_coord:\n        l = bresenham(x(wall[0]), y(wall[0]), x(wall[1]), y(wall[1]))\n        for p in l:\n            domain[p] = -R\n    return domain","b292cc19":"def Fcov(domain):\n    \"\"\"Set a given domain's cells to on if they are visible\n    from one of the given sensors at the given sensor_range.\n\n    >>> score(2 * np.eye(5) - np.ones((5,5)))\n    5\n    \"\"\"\n    return sum(x for x in domain.flatten() if x > 0)","87e8ac65":"def Fcos(domain):\n    \"\"\"Set a given domain's cells to on if they are visible\n    from one of the given sensors at the given sensor_range.\n\n    >>> score(2 * np.eye(5) - np.ones((5,5)))\n    5\n    \"\"\"\n    return (domain == 2).sum()","c1926fe7":"def highlight_sensors(domain, sensors, val=2):\n    \"\"\"Add twos to the given domain, in the cells where the given\n    sensors are located.\n\n    >>> highlight_sensors( [[0,0],[1,1]], [(0,0),(1,1)] )\n    [[2, 0], [1, 2]]\n    \"\"\"\n    for s in sensors:\n        # `coverage` fills the domain with ones,\n        # adding twos will be visible in an image.\n        domain[y(s)][x(s)] = val\n    return domain\n\ndef show(domain):\n    fig = plt.figure()\n    plt.imshow(domain)\n    plt.show()","eb45a83c":"###HYPERPARAMETERS\nRs = 5.5\nenv_size = 30\nnumber_sensors_random = 2","2226fb49":"domain = init_env(env_size)","ef62efa6":"sensors = [(6,3),(5,15)]","da32811c":"walls_brick = [((2,10),(2,0)),((14,4),(8,4))]\ndomain = add_walls(domain, walls_brick, obstacle_type=\"brick\")","e177b011":"walls_glass = [((8,18),(8,25)),((20,15),(20,20))]\ndomain = add_walls(domain, walls_glass, obstacle_type=\"glass\")","c889c1af":"domain = coverage(domain,sensors,Rs)","51ca5867":"domain = highlight_sensors(domain, sensors)\nshow(domain)\nprint(f\"Fcov = \", Fcov(domain))\nprint(f\"Fcos = \", Fcos(domain))","74309d09":"fig = plt.figure(figsize=(8,8))\n\nim = plt.imshow(domain)\ntxt_iter = plt.text(0.5, 0.5, 'Iteration : 0')\ntxt_score = plt.text(22, 28, 'F_cov : 0')\n\ndef animate_func(i):\n    if i%10==0: #Affichage\n        domain = init_env(30)\n        sensors = [(6,3),(5,15)]\n        for _ in range(number_sensors_random):\n            sensors.append(tuple(np.random.randint(env_size, size=2)))\n        walls_brick = [((2,10),(2,0)),((14,4),(8,4))]\n        domain = add_walls(domain, walls_brick, obstacle_type=\"brick\")\n        walls_glass = [((8,18),(8,25)),((20,15),(20,20))]\n        domain = add_walls(domain, walls_glass, obstacle_type=\"glass\")\n        domain = coverage(domain,sensors,Rs)\n        domain = highlight_sensors(domain, sensors)\n        im.set_array(domain)\n        txt_iter.set_text(f'Iteration :{i\/\/10}')\n        txt_score.set_text(f'F_cov = {Fcov(domain):.2f}')\n\nanim = animation.FuncAnimation(\n                               fig, \n                               animate_func, \n                               frames=100, #affichage\n                               repeat=False,\n                               )\n\nfrom IPython.display import HTML\nHTML(anim.to_html5_video())","75fc580a":"def func_obj(domain, sensors, Rs):\n    \"\"\"\n    Returns the number of squares covered by the sensors in a domain \n    This function doesn't apply the placement on the domain and doesn't\n    take in account the specific values of the domain covered !\n    \"\"\"\n    domain_copy = deepcopy(domain)\n    domain_coveraged = coverage(domain_copy, sensors, Rs)\n    return np.sum(np.array(domain_coveraged) > 0)","3700e2f1":"def func_obj(domain, sensors, Rs):\n    \"\"\"\n    Returns the score of the coverage of the sensors in a domain \n    This function doesn't apply the placement on the domain\n    \"\"\"\n    domain_copy = deepcopy(domain)\n    domain_coveraged = coverage(domain_copy, sensors, Rs)\n    return Fcov(domain_coveraged)  ","42e7d047":"def init_sol(env_size, nb_sensors=0):\n    \"\"\"\n    Returns a random solution according to the size of the environment\n    Use nb_sensors to lock this parameter for the rest of the problem\n    \"\"\"\n    if nb_sensors == 0:\n        nb_sensors = np.random.randint(1,env_size)\n    sensors = []\n    for _ in range(nb_sensors):\n        sensors.append(tuple(np.random.randint(env_size, size=2)))\n    return sensors","a0b70ed4":"def cross_over(parents):\n    \"\"\"\n    Cross Over : Randomly select sensors from both parents to generate a child\n    The child always has the minimum of both parents' number of sensors\n    \"\"\"\n    parent1_nb_sensors, parent2_nb_sensors = len(parents[0]), len(parents[1])\n    child = []\n    for i in range(min(parent1_nb_sensors,parent2_nb_sensors)\/\/2):\n        child.append(parents[0][i])\n    for i in range(min(parent1_nb_sensors,parent2_nb_sensors)\/\/2, min(parent1_nb_sensors,parent2_nb_sensors)):\n        child.append(parents[1][i])\n    return child","352a535a":"def mutate(parent, env_size, scale=0.3, probability_lose_sensor=0):\n    \"\"\"\n    Mutation : Randomly move the sensor in a square of scale*env_size\n    probability_lose_sensor: not activited by default, chance to\n    remove a random sensor of the solution\n    \"\"\"\n    sol = np.array(parent)\n    al = np.random.random(sol.size).reshape(sol.shape)\n    side = env_size * scale\n    new = sol + (al * side - side\/2)\n    new = list(map(tuple, new.astype(int).clip(0,env_size - 1)))\n    if probability_lose_sensor>random.random() and len(new)>1 :\n        new.pop(random.randrange(len(new)))\n    return new","00b75673":"def is_neighboor(domain, sensor1, sensor2, threshold, random_impact=1):\n    \"\"\"\n    Returns a boolean if two sensors are linked according to a threshold\n    This method fully relies on the paper by Kacou and al. 'Multi-wall and \n    Multi-frequency Home Environment Path Loss Characterization and Modeling'\n    doi=10.1049\/cp.2018.0464\n    This project is focused on LoRa bandwith, which is Sub-band 1 in the paper\n    \"\"\"\n    #IoT Sub-band 1\n    PL0 = 31.61\n    sigma = 2.99\n  \n    d = distance(sensor1, sensor2)\n    Li = 0\n    walls_encountered = [domain[p] for p in bresenham(y(sensor1),x(sensor1),y(sensor2), x(sensor2)) if domain[p]<0]\n    for wall in walls_encountered:\n        if -wall == 1.28: #brick considered as within the BW group\n            Li += 3.07\n        elif -wall == 0.46: #wood considered as within the DW group\n            Li += 1.03\n        elif -wall == 0.43: #glass considered as within the DW group\n            Li += 1.03\n    if d!=0: #avoid domain error when the sensor1==sensor2 \n        if random_impact:\n            PL = PL0 + math.log(d) + Li + random.gauss(0, sigma)\n        else:\n            PL = PL0 + math.log(d) + Li\n    else:\n        return False\n    return -PL>threshold\n","41277fe4":"class GraphSensors():\n    \"\"\"\n    Class for the graph representation of the sensors inspired by:\n    https:\/\/www.codespeedy.com\/kargers-algorithm-for-minimum-cut-in-python\/\n    \"\"\"\n    \n    def __init__(self, domain, sensors, threshold, random_impact=1):\n        \"\"\"\n        Creates a graph according to the position of the sensors and the threshold of the minimum signal attenuation accepted\n  \n        domain: The domain of the problem\n        sensors: List of the sensors' position\n        threshold: Minimum value returned by is_neighboor() to link two sensors\n        random_impact: As is_neighboor() contains random, it is possible that some links are only one directional,\n        if 1, the link from only one sensor to another is kept and becomes a two sided link\n        if 0, the link is removed\n       \n        \"\"\"\n        self.domain = domain\n        self.sensors = sensors\n        self.graph = {}\n        self.edges = 0\n        self.vertex_count = 0\n        for i in range(len(sensors)):\n            vertex_edges = [j for j in range(len(sensors)) if is_neighboor(domain, sensors[i], sensors[j], threshold=threshold, random_impact=random_impact)]\n            self.graph[i] = vertex_edges\n            self.edges+=len(vertex_edges)\n            self.vertex_count+=1\n        if random_impact:\n            for i in range(len(sensors)):\n                 for j in range(len(sensors)):\n                    if i!=j:\n                        if (j in self.graph[i]) and (i not in self.graph[j]):\n                            self.graph[j].append(i)\n                            self.edges += 1\n                            self.vertex_count+=1\n        else:\n            for i in range(len(sensors)):\n                for j in range(len(sensors)):\n                    if i!=j:\n                        if (j in self.graph[i]) and (i not in self.graph[j]):\n                            self.graph[i].remove(j)\n                            self.edges -= 1\n                            self.vertex_count-=1\n\n        self.supervertices = {}\n        for key in self.graph:\n            self.supervertices[key] = [key]\n    \n    def is_connected(self):\n        \"\"\"\n        Returns a boolean to know if the graph is connected (no isolated node)\n        \"\"\"\n        for node in list(self.graph.keys()):\n            if not self.graph[node]:\n                return False\n        return True\n\n    def search_min_cut(self):\n        \"\"\"\n        Uses the Karger algorithm to find the minimum cut, this algorithm is probabilistic\n        which means that it doesn't always give the good answer\n        \"\"\"\n        minimumcut = 0\n        while len(self.graph)>2:\n            # Now we  Pick a random edge\n            vertice1, vertice2 = self.select_random_edge()\n            self.edges -= len(self.graph[vertice1])\n            self.edges -= len(self.graph[vertice2])\n            # Then we  merge the edges\n            self.graph[vertice1].extend(self.graph[vertice2])\n            # Update every references from v2 to point to v1\n            for vertex in self.graph[vertice2]:\n                if vertice2 in self.graph[vertex]:\n                    self.graph[vertex].remove(vertice2) \n                    self.graph[vertex].append(vertice1)\n            # Remove the  self loop\n            self.graph[vertice1] = [x for x in self.graph[vertice1] if x != vertice1]\n            # Update total edges of graph\n            self.edges += len(self.graph[vertice1])\n            self.graph.pop(vertice2)\n            #  Update cut grouping in the graph\n            self.supervertices[vertice1].extend(self.supervertices.pop(vertice2))\n        #  we now Calculate the minimum cut\n        for edges in self.graph.values():\n            minimumcut = len(edges)\n        #  finally return min cut and the two supervertices\n        return minimumcut,self.supervertices      \n    \n    def select_random_edge(self):\n        \"\"\"\n        Returns a random selection of edges to fuse\n        \"\"\"\n        rand_edge = random.randint(0, self.edges-1)\n        for vertex, vertex_edges in self.graph.items():\n            if len(vertex_edges) == rand_edge & len(vertex_edges) == 0:\n                rand_edge+=1 #Avoid error, to fix\n            if len(vertex_edges) < rand_edge:\n                rand_edge -= len(vertex_edges)\n            else:\n                from_vertex = vertex\n                to_vertex = vertex_edges[rand_edge-1]\n                return from_vertex, to_vertex\n    \n    def print_graph(self):\n      \"\"\"\n      Prints the graph in a pretty format\n      \"\"\"\n      for clue in self.graph:\n            print(\"{} :{}\".format(clue, self.graph[clue]))","0f2727de":"def karger_algorithm(graph, iterations, max_counter = None):\n    \"\"\"\n    Multiple runs of the Karger algorithm and returns the minimum found\n\n    graph: Graph of the problem, use the GraphSensors class\n    iterations: Number of iterations\n    max_counter: If the minimum stays the same for max_couter times, the algorithm\n    stops and returns the minimum\n    \"\"\"\n    graph_copy = deepcopy(graph)\n    output = graph_copy.search_min_cut()\n    minimumcut = output[0]\n    supervertices = output[1]\n    counter_break = 0\n    for i in range(iterations):\n        graph_copy = deepcopy(graph)\n        output = graph_copy.search_min_cut()\n        if output[0] < minimumcut:\n            minimumcut = output[0]\n            supervertices = output[1]\n            counter_break = 0\n        if counter_break is not None:\n            if output[0] >= minimumcut:\n                counter_break +=1\n                if counter_break == max_counter:\n                    return minimumcut, supervertices\n    return minimumcut, supervertices","ac77ccc8":"def satisfy_MWPLM(domain, sensors, k_connectivity=1, threshold=-60, iterations=len(sensors)*100, max_counter = None, random_impact = 1 ,verbose=False):\n    \"\"\"\n    Returns a boolean if the sensor deployment satisfies the contraint of connectivity\n\n    domain: Domain of the problem\n    sensors: List of the sensors' position\n    k_connectivity: Constraint on the connectivity of the graph\n    threshold: Minimum value returned by is_neighboor() to link two sensors\n      the default value is selected according to https:\/\/www.metageek.com\/training\/resources\/wifi-signal-strength-basics.html\n    iterations: Number of iterations of the Karger algorithm\n    max_counter: If the minimum stays the same for max_couter times, the algorithm\n    stops and returns the minimum\n    random_impact: As is_neighboor() contains random, it is possible that some links are only one directional,\n        if 1, the link from only one sensor to another is kept and becomes a two sided link\n        if 0, the link is removed\n     \"\"\"\n    graph = GraphSensors(domain, sensors, threshold=threshold, random_impact=random_impact)\n  \n    if verbose:\n        print('Graph:')\n        graph.print_graph()\n  \n    if not graph.is_connected():\n        if verbose:\n            print(\"The graph isn't connected\")\n        return False\n \n    connectivity = karger_algorithm(graph, iterations, max_counter)[0]\n    if connectivity < k_connectivity:\n        if verbose:\n            print(f\"The connectivity is too small: {connectivity} < {k_connectivity}\")\n        return False\n  \n    if verbose:\n        print(f\"The connectivity is large enough: {connectivity}\")\n    return True","4f71b67d":"#HYPERPARAMETER\nk_connectivity=3\nthreshold= -35\n\ndomain = init_env(30)\nsensors = [(6,3),(5,15)]\nfor _ in range(number_sensors_random):\n    sensors.append(tuple(np.random.randint(env_size, size=2)))\nwalls_brick = [((2,10),(2,0)),((14,4),(8,4))]\ndomain = add_walls(domain, walls_brick, obstacle_type=\"brick\")\nwalls_glass = [((8,18),(8,25)),((20,15),(20,20))]\ndomain = add_walls(domain, walls_glass, obstacle_type=\"glass\")\ndomain = coverage(domain,sensors,Rs)\ndomain = highlight_sensors(domain, sensors)\nshow(domain)\nprint(sensors)\nprint(f\"Does it satisfy the MWPLM contraint ({k_connectivity}) ? {satisfy_MWPLM(domain, sensors, threshold=threshold, k_connectivity=k_connectivity, verbose=True)}\")","4e4b76f5":"def pareto_front_ranking(costs):\n    \"\"\"\n    Find the pareto-efficient points and returns a list of indexes representing \n    the F_n as in this image : \n    https:\/\/i.ytimg.com\/vi\/RFJ3tsrFgyA\/maxresdefault.jpg\n    \"\"\"\n    Fn=[]\n    copy_cost = costs.copy()\n    while len(copy_cost)>0:\n        is_efficient = np.ones(copy_cost.shape[0], dtype = bool)\n        for i, c in enumerate(copy_cost):\n            if is_efficient[i]:\n                is_efficient[is_efficient] = np.any(copy_cost[is_efficient]<c, axis=1)  # Keep any point with a lower cost\n                is_efficient[i] = True  # And keep self\n        Fn.append([i for i in range(len(copy_cost)) if is_efficient[i]])\n        copy_cost = np.array([copy_cost[i].tolist() for i in range(len(copy_cost)) if not is_efficient[i]])\n    return Fn","828f2282":"def ISOD_NSGA(domain, MaxGener, Nb_indiv, Offspring_Pop, Rs, prob_mutate_or_crossover=0.5, probability_lose_sensor=0, threshold=-60, k_connectivity=None, random_impact=1, verbose=True):\n    \"\"\"\n    ISOD_NGSA Algorithm as proposed in the paper by Dahmane et al. 'A BIM-based \n    framework for an Optimal WSN Deployment in Smart Building'\n    doi=10.1109\/NoF50125.2020.9249099\n\n    domain: environment used for the problem (empty or with walls)\n    MaxGener: Number of generation\/iteration of the algorithm\n    Nb_indiv: Number of individuals (deployments) kept at each iterations\n    Offspring_Pop: Number of individuals added at each iterations before selection\n    Rs: Range of a sensor\n    prob_mutate_or_crossover: Probability for either mutation or crossover\n    probability_lose_sensor: Not activited by default, chance to\n    remove a random sensor of the solution\n    threshold: Minimum value returned by is_neighboor() to link two sensors\n    k_connectivity: Constraint on the connectivity of the graph\n    \"\"\"\n    pop = []\n    for _ in range(Nb_indiv): #1.Random deployments\n        sol = init_sol(domain.shape[0])\n        val = func_obj(domain, sol, Rs)\n        pop.append([sol, val]) #2.Calculate the rank for all chromosomes\n    for i in range(MaxGener):  #3. MaxGener is the number of generation\n        if k_connectivity is not None: #Remove connectivity contraint\n            pop = [indiv for indiv in pop if satisfy_MWPLM(domain, indiv[0], threshold=threshold, k_connectivity=k_connectivity, random_impact = random_impact)] #4.Satisfy MWPLM and k-connectivity constraints..\n            if len(pop)<2:\n                print(\"The k_connectivity criterium is too high or the random initialization is a very unlucky roll.\")\n                return None\n        for _ in range(Offspring_Pop):\n            if (np.random.random() < prob_mutate_or_crossover):\n                parents = (pop[np.random.randint(len(pop))][0],\n                           pop[np.random.randint(len(pop))][0])  #Parents are two random chosen good solutions\n                sol = cross_over(parents)\n            else:\n                parent = pop[np.random.randint(len(pop))][0]\n                sol = mutate(parent, domain.shape[0], scale=0.3, probability_lose_sensor=probability_lose_sensor)\n            val = func_obj(domain, sol, Rs) #8. Calculate the rank for each obtained chromosomes.\n            pop.append([sol, val])\n        objectives = np.array([(-i[1],len(i[0])) for i in pop]) #Rank(parents + Offsprings)\n        Fn = pareto_front_ranking(objectives)\n        new_pop = []\n        while len(new_pop)<Nb_indiv & len(Fn)>0:\n            for k in Fn[0]:\n                new_pop.append(pop[k])\n            pop = [pop[i] for i in range(len(pop)) if i not in Fn[0]]\n            Fn = Fn[1:]\n        while len(new_pop)<Nb_indiv: #Proposition to add random solutions, not in the paper\n            sol = init_sol(domain.shape[0])\n            val = func_obj(domain, sol, Rs)\n            new_pop.append([sol, val])\n        pop = new_pop[:Nb_indiv] #Reject Offspring population\n        if verbose:\n            clear_output(wait=True)\n            display(f\"Iteration {i+1} \/ {MaxGener} : F_cov_mean = {np.mean([l[1] for l in pop]):.3f}, F_cos_mean = {np.mean([len(l[0]) for l in pop])}\")\n    return pop","9c365576":"##HYPERPARAMETERS\nRs = 5.5\nenv_size = 30\n\nMaxGener = 400\nNb_indiv = 50\nOffspring_Pop = 20\nprob_mutate_or_crossover = 0.7\nprobability_lose_sensor = 0.5\nk_connectivity = None","21898584":"domain = init_env(env_size)","22971292":"solutions = ISOD_NSGA(domain, MaxGener = MaxGener, Nb_indiv = Nb_indiv, Offspring_Pop = Offspring_Pop, Rs = Rs, probability_lose_sensor=probability_lose_sensor, prob_mutate_or_crossover=prob_mutate_or_crossover, k_connectivity=k_connectivity)","11e582a1":"#Plot best solutions\nFn = pareto_front_ranking(np.array([(-i[1],len(i[0])) for i in solutions]))\nbest_sols = []\nbest_sols.append([solutions[i] for i in Fn[0]])\nbest_sols = [item for sublist in best_sols for item in sublist]\nscore = [(-i[1],len(i[0])) for i in best_sols]\nplt.scatter([i[0] for i in score], [i[1] for i in score])\nplt.show()\n\nfig, axs = plt.subplots(2, len(best_sols)\/\/2,figsize=(50,10))\nbest_sols.sort(key=lambda x: x[1], reverse=True)\nfor i in range(2):\n    for j in range(len(best_sols)\/\/2):\n        domain = init_env(env_size)\n        domain = coverage(domain,best_sols[j*(i+1)][0],Rs)\n        domain = highlight_sensors(domain, best_sols[j*(i+1)][0])\n  \n        axs[i,j].imshow(domain)","e10d0280":"##HYPERPARAMETERS\nRs = 5.5\nenv_size = 30\n\nMaxGener = 200\nNb_indiv = 30\nOffspring_Pop = 15\nprob_mutate_or_crossover = 0.7\nprobability_lose_sensor = 0.5\nk_connectivity = 3\nthreshold = -35\nrandom_impact = 1","7aa0922f":"domain = init_env(env_size)","6bf60395":"solutions = ISOD_NSGA(domain, MaxGener = MaxGener, Nb_indiv = Nb_indiv, Offspring_Pop = Offspring_Pop, Rs = Rs, prob_mutate_or_crossover=prob_mutate_or_crossover, probability_lose_sensor=probability_lose_sensor, threshold=threshold, k_connectivity=k_connectivity, random_impact=random_impact)","c68da4f1":"Fn = pareto_front_ranking(np.array([(-i[1],len(i[0])) for i in solutions]))\nbest_sols = []\nbest_sols.append([solutions[i] for i in Fn[0]])\nbest_sols = [item for sublist in best_sols for item in sublist]\nscore = [(-i[1],len(i[0])) for i in best_sols]\nplt.scatter([i[0] for i in score], [i[1] for i in score])\nscore.sort(key=lambda x: x[0])\nplt.show()","f6261ef4":"fig, axs = plt.subplots(2, len(best_sols)\/\/2,figsize=(40,10))\nbest_sols.sort(key=lambda x: x[1], reverse=True)\nfor i in range(2):\n    for j in range(len(best_sols)\/\/2):\n        domain = init_env(env_size)\n        domain = coverage(domain,best_sols[j*(i+1)][0],Rs)\n        domain = highlight_sensors(domain, best_sols[j*(i+1)][0])\n\n        axs[i,j].imshow(domain)","cb66e500":"##HYPERPARAMETER\nenv_size = 30","5879fe13":"domain = init_env(env_size)","9d830fb2":"walls_brick = [((9,10),(9,19)),((21,10),(21,19)),((12,7),(18,7)),((12,23),(18,23))]\ndomain = add_walls(domain, walls_brick, obstacle_type=\"brick\")","e1b6bd49":"show(domain)","926d6973":"##HYPERPARAMETERS\nRs = 5.5\nMaxGener = 200\nNb_indiv = 30\nOffspring_Pop = 15\nprob_mutate_or_crossover = 0.7\nprobability_lose_sensor = 0.5\nk_connectivity = None","47fd4368":"solutions = ISOD_NSGA(domain, MaxGener = MaxGener, Nb_indiv = Nb_indiv, Offspring_Pop = Offspring_Pop, Rs = Rs, prob_mutate_or_crossover=prob_mutate_or_crossover,probability_lose_sensor=probability_lose_sensor, k_connectivity=k_connectivity)","dbaef26a":"#Plot best solutions\nFn = pareto_front_ranking(np.array([(-i[1],len(i[0])) for i in solutions]))\nbest_sols = []\nbest_sols.append([solutions[i] for i in Fn[0]])\nbest_sols = [item for sublist in best_sols for item in sublist]\nscore = [(-i[1],len(i[0])) for i in best_sols]\nplt.scatter([i[0] for i in score], [i[1] for i in score])\nplt.show()\n\nfig, axs = plt.subplots(2, len(best_sols)\/\/2,figsize=(40,10))\nbest_sols.sort(key=lambda x: x[1], reverse=True)\nfor i in range(2):\n    for j in range(len(best_sols)\/\/2):\n        domain = init_env(env_size)\n        walls_brick = [((9,10),(9,19)),((21,10),(21,19)),((12,7),(18,7)),((12,23),(18,23))]\n        domain = add_walls(domain, walls_brick, obstacle_type=\"brick\")\n        domain = coverage(domain,best_sols[j*(i+1)][0],Rs)\n        domain = highlight_sensors(domain, best_sols[j*(i+1)][0])\n  \n        axs[i,j].imshow(domain)","8171a05a":"##HYPERPARAMETERS\nRs = 5.5\n\nMaxGener = 200\nNb_indiv = 30\nOffspring_Pop = 15\nprob_mutate_or_crossover = 0.7\nk_connectivity = 3\nthreshold = -35\nrandom_impact = 1\nprobability_lose_sensor = 0.5","1b6ef1b4":"solutions = ISOD_NSGA(domain, MaxGener = MaxGener, Nb_indiv = Nb_indiv, Offspring_Pop = Offspring_Pop, Rs = Rs, prob_mutate_or_crossover=prob_mutate_or_crossover, probability_lose_sensor=probability_lose_sensor, threshold=threshold, k_connectivity=k_connectivity, random_impact=random_impact)","c94d2d58":"Fn = pareto_front_ranking(np.array([(-i[1],len(i[0])) for i in solutions]))\nbest_sols = []\nbest_sols.append([solutions[i] for i in Fn[0]])\nbest_sols = [item for sublist in best_sols for item in sublist]\nscore = [(-i[1],len(i[0])) for i in best_sols]\nplt.scatter([i[0] for i in score], [i[1] for i in score])\nscore.sort(key=lambda x: x[0])\nplt.show()","6fa5f937":"fig, axs = plt.subplots(2, len(best_sols)\/\/2,figsize=(50,10))\nbest_sols.sort(key=lambda x: x[1], reverse=True)\nfor i in range(2):\n    for j in range(len(best_sols)\/\/2):\n        domain = init_env(env_size)\n        walls_brick = [((9,10),(9,19)),((21,10),(21,19)),((12,7),(18,7)),((12,23),(18,23))]\n        domain = add_walls(domain, walls_brick, obstacle_type=\"brick\")\n        domain = coverage(domain,best_sols[j*(i+1)][0],Rs)\n        domain = highlight_sensors(domain, best_sols[j*(i+1)][0])\n    \n        axs[i,j].imshow(domain)","2b45ec0b":"##HYPERPARAMETERS\nRs = 5.5\nenv_size = 30","d6522d27":"domain = init_env(env_size)","cd053c50":"horizontal_walls_brick = [((12,0),(12,6)),((18,0),(18,6)),((12,9),(12,16)),((18,9),(18,16)),((12,19),(12,26)),((18,19),(18,26)),((12,29),(12,29)),((18,29),(18,29))]\ndomain = add_walls(domain, horizontal_walls_brick, obstacle_type=\"brick\")","c9dc7a4b":"vertical_walls_brick = [((0,10),(12,10)), ((18,10),(29,10)), ((0,20),(12,20)), ((18,20),(29,20))]\ndomain = add_walls(domain, vertical_walls_brick, obstacle_type=\"brick\")","7acef362":"walls_wood = [((12,7),(12,8)),((18,7),(18,8)),((12,17),(12,18)),((18,17),(18,18)),((12,27),(12,28)),((18,27),(18,28))]\ndomain = add_walls(domain, walls_wood, obstacle_type=\"wood\")","e865fd67":"show(domain)","f6ff2e65":"##HYPERPARAMETERS\nRs = 5.5\nenv_size = 30\n\nMaxGener = 400\nNb_indiv = 50\nOffspring_Pop = 20\nprob_mutate_or_crossover = 0.7\nprobability_lose_sensor = 0.5\nk_connectivity = None","91381155":"solutions = ISOD_NSGA(domain, MaxGener = MaxGener, Nb_indiv = Nb_indiv, Offspring_Pop = Offspring_Pop, Rs = Rs, prob_mutate_or_crossover=prob_mutate_or_crossover,probability_lose_sensor=probability_lose_sensor, k_connectivity=k_connectivity)","069dd6ba":"#Plot best solutions\nFn = pareto_front_ranking(np.array([(-i[1],len(i[0])) for i in solutions]))\nbest_sols = []\nbest_sols.append([solutions[i] for i in Fn[0]])\nbest_sols = [item for sublist in best_sols for item in sublist]\nscore = [(-i[1],len(i[0])) for i in best_sols]\nplt.scatter([i[0] for i in score], [i[1] for i in score])\nplt.show()\n\nfig, axs = plt.subplots(2, len(best_sols)\/\/2,figsize=(40,10))\nbest_sols.sort(key=lambda x: x[1], reverse=True)\nfor i in range(2):\n    for j in range(len(best_sols)\/\/2):\n        domain = init_env(env_size)\n        horizontal_walls_brick = [((12,0),(12,6)),((18,0),(18,6)),((12,9),(12,16)),((18,9),(18,16)),((12,19),(12,26)),((18,19),(18,26)),((12,29),(12,29)),((18,29),(18,29))]\n        domain = add_walls(domain, horizontal_walls_brick, obstacle_type=\"brick\")\n        vertical_walls_brick = [((0,10),(12,10)), ((18,10),(29,10)), ((0,20),(12,20)), ((18,20),(29,20))]\n        domain = add_walls(domain, vertical_walls_brick, obstacle_type=\"brick\")\n        walls_wood = [((12,7),(12,8)),((18,7),(18,8)),((12,17),(12,18)),((18,17),(18,18)),((12,27),(12,28)),((18,27),(18,28))]\n        domain = add_walls(domain, walls_wood, obstacle_type=\"wood\")\n        domain = coverage(domain,best_sols[j*(i+1)][0],Rs)\n        domain = highlight_sensors(domain, best_sols[j*(i+1)][0])\n\n        axs[i,j].imshow(domain)","b76bea60":"##HYPERPARAMETERS\nRs = 5.5\n\nMaxGener = 200\nNb_indiv = 30\nOffspring_Pop = 15\nprob_mutate_or_crossover = 0.7\nprobability_lose_sensor = 0.5\nk_connectivity = 3\nthreshold = -40\nrandom_impact = 1","454590b3":"solutions = ISOD_NSGA(domain, MaxGener = MaxGener, Nb_indiv = Nb_indiv, Offspring_Pop = Offspring_Pop, Rs = Rs, prob_mutate_or_crossover=prob_mutate_or_crossover, probability_lose_sensor=probability_lose_sensor, threshold=threshold, k_connectivity=k_connectivity, random_impact=random_impact)","78632f4d":"Fn = pareto_front_ranking(np.array([(-i[1],len(i[0])) for i in solutions]))\nbest_sols = []\nbest_sols.append([solutions[i] for i in Fn[0]])\nbest_sols = [item for sublist in best_sols for item in sublist]\nscore = [(-i[1],len(i[0])) for i in best_sols]\nplt.scatter([i[0] for i in score], [i[1] for i in score])\nscore.sort(key=lambda x: x[0])\nplt.show()\n\nfig, axs = plt.subplots(2, len(best_sols)\/\/2,figsize=(40,10))\nbest_sols.sort(key=lambda x: x[1], reverse=True)\nfor i in range(2):\n    for j in range(len(best_sols)\/\/2):\n        domain = init_env(env_size)\n        horizontal_walls_brick = [((12,0),(12,6)),((18,0),(18,6)),((12,9),(12,16)),((18,9),(18,16)),((12,19),(12,26)),((18,19),(18,26)),((12,29),(12,29)),((18,29),(18,29))]\n        domain = add_walls(domain, horizontal_walls_brick, obstacle_type=\"brick\")\n        vertical_walls_brick = [((0,10),(12,10)), ((18,10),(29,10)), ((0,20),(12,20)), ((18,20),(29,20))]\n        domain = add_walls(domain, vertical_walls_brick, obstacle_type=\"brick\")\n        walls_wood = [((12,7),(12,8)),((18,7),(18,8)),((12,17),(12,18)),((18,17),(18,18)),((12,27),(12,28)),((18,27),(18,28))]\n        domain = add_walls(domain, walls_wood, obstacle_type=\"wood\")\n        domain = coverage(domain,best_sols[j*(i+1)][0],Rs)\n        domain = highlight_sensors(domain, best_sols[j*(i+1)][0])\n  \n        axs[i,j].imshow(domain)","78b34308":"Fcos_lock = score[len(score)\/\/2][1]\n\nFcos_lock_scores = [-score[len(score)\/\/2][0]]\n\ndomain = init_env(env_size)\nhorizontal_walls_brick = [((12,0),(12,6)),((18,0),(18,6)),((12,9),(12,16)),((18,9),(18,16)),((12,19),(12,26)),((18,19),(18,26)),((12,29),(12,29)),((18,29),(18,29))]\ndomain = add_walls(domain, horizontal_walls_brick, obstacle_type=\"brick\")\nvertical_walls_brick = [((0,10),(12,10)), ((18,10),(29,10)), ((0,20),(12,20)), ((18,20),(29,20))]\ndomain = add_walls(domain, vertical_walls_brick, obstacle_type=\"brick\")\nwalls_wood = [((12,7),(12,8)),((18,7),(18,8)),((12,17),(12,18)),((18,17),(18,18)),((12,27),(12,28)),((18,27),(18,28))]\ndomain = add_walls(domain, walls_wood, obstacle_type=\"wood\")\ndomain = coverage(domain,best_sols[len(score)\/\/2][0],Rs)\ndomain = highlight_sensors(domain, best_sols[len(score)\/\/2][0])\nshow(domain)\n\nfor i in range(14):\n    domain = init_env(30)\n    horizontal_walls_brick = [((12,0),(12,6)),((18,0),(18,6)),((12,9),(12,16)),((18,9),(18,16)),((12,19),(12,26)),((18,19),(18,26)),((12,29),(12,29)),((18,29),(18,29))]\n    domain = add_walls(domain, horizontal_walls_brick, obstacle_type=\"brick\")\n    vertical_walls_brick = [((0,10),(12,10)), ((18,10),(29,10)), ((0,20),(12,20)), ((18,20),(29,20))]\n    domain = add_walls(domain, vertical_walls_brick, obstacle_type=\"brick\")\n    walls_wood = [((12,7),(12,8)),((18,7),(18,8)),((12,17),(12,18)),((18,17),(18,18)),((12,27),(12,28)),((18,27),(18,28))]\n    domain = add_walls(domain, walls_wood, obstacle_type=\"wood\")\n    new_random_sol = init_sol(domain.shape[0],nb_sensors=Fcos_lock)\n    Fcos_lock_scores.append(func_obj(domain, new_random_sol, Rs=5.5))\n\ny_pos = [i for i in range(len(Fcos_lock_scores))]\nbarlist = plt.bar(y_pos, Fcos_lock_scores, align='center', alpha=0.5)\nbarlist[0].set_color('r')\nplt.title(f'The coverage ratio comparison for Fcos={Fcos_lock}')\n\nplt.show()","4c3784db":"# Imports","5a466c0e":"# Run : Open Space - Brick","c9b8e2f3":"## Run without taking connectivity in account","ce56672d":"The purpose of this notebook is to implement the ISOD_NGSA Algorithm as proposed in the paper by Dahmane et al. ['A BIM-based \n  framework for an Optimal WSN Deployment in Smart Building'](https:\/\/ieeexplore.ieee.org\/document\/9249099)","b5b1e5ce":"## Run without taking connectivity in account","43f17652":"# Run : Free Space","6d71e4fc":"## Animation","1efca7cf":"## Graph environment (k-connectivity, MWPLM)","536b6ead":"## Run with the connectivity constraint","fe32996a":"Place randomly two sensors to see the impact of the walls on the coverage","972c30b3":"# Environment","8aefef84":"The solution after 200 iterations of the algorithm is better than random solutions.","d10929ff":"## Run without taking connectivity in account","00318c47":"# Chart","a242cec7":"## Run with the connectivity constraint","1830375f":"# Run : Closed Space - Brick and wood","d448ba48":"# Optimization environment","38398a19":"## Run with the connectivity constraint","97714a77":"Objective functions: please load only one of the two","123717ae":"### Example","4ff99bea":"# Introduction","e25c72fd":"## Genetical algorithm environment","6539ada3":"# Example run","ca57f876":"## ISOD_NSGA"}}