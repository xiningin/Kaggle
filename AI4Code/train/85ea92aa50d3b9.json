{"cell_type":{"d9e55b86":"code","980cb9a4":"code","04ba6dd2":"code","dd0c84af":"code","40570ddd":"code","740cccf8":"code","b86aabe9":"code","13aed6da":"code","6ee4b0a7":"code","ece8761b":"code","4308f97d":"markdown","a77042ed":"markdown","a6f45e6f":"markdown","5e37d93b":"markdown","65747669":"markdown","58f0843a":"markdown"},"source":{"d9e55b86":"import pandas as pd\nimport seaborn as sns\nimport gc\nimport numpy as np\n\ndtypes = {\n        'MachineIdentifier':                                    'category',\n        'ProductName':                                          'category',\n        'EngineVersion':                                        'category',\n        'AppVersion':                                           'category',\n        'AvSigVersion':                                         'category',\n        'IsBeta':                                               'int8',\n        'RtpStateBitfield':                                     'float16',\n        'IsSxsPassiveMode':                                     'int8',\n        'DefaultBrowsersIdentifier':                            'float16',\n        'AVProductStatesIdentifier':                            'float32',\n        'AVProductsInstalled':                                  'float16',\n        'AVProductsEnabled':                                    'float16',\n        'HasTpm':                                               'int8',\n        'CountryIdentifier':                                    'int16',\n        'CityIdentifier':                                       'float32',\n        'OrganizationIdentifier':                               'float16',\n        'GeoNameIdentifier':                                    'float16',\n        'LocaleEnglishNameIdentifier':                          'int8',\n        'Platform':                                             'category',\n        'Processor':                                            'str',\n        'OsVer':                                                'category',\n        'OsBuild':                                              'int16',\n        'OsSuite':                                              'int16',\n        'OsPlatformSubRelease':                                 'category',\n        'OsBuildLab':                                           'category',\n        'SkuEdition':                                           'category',\n        'IsProtected':                                          'float16',\n        'AutoSampleOptIn':                                      'int8',\n        'PuaMode':                                              'category',\n        'SMode':                                                'float16',\n        'IeVerIdentifier':                                      'float16',\n        'SmartScreen':                                          'category',\n        'Firewall':                                             'float16',\n        'UacLuaenable':                                         'float32',\n        'Census_MDC2FormFactor':                                'category',\n        'Census_DeviceFamily':                                  'category',\n        'Census_OEMNameIdentifier':                             'float16',\n        'Census_OEMModelIdentifier':                            'float32',\n        'Census_ProcessorCoreCount':                            'float16',\n        'Census_ProcessorManufacturerIdentifier':               'float16',\n        'Census_ProcessorModelIdentifier':                      'float16',\n        'Census_ProcessorClass':                                'category',\n        'Census_PrimaryDiskTotalCapacity':                      'float32',\n        'Census_PrimaryDiskTypeName':                           'category',\n        'Census_SystemVolumeTotalCapacity':                     'float32',\n        'Census_HasOpticalDiskDrive':                           'int8',\n        'Census_TotalPhysicalRAM':                              'float32',\n        'Census_ChassisTypeName':                               'category',\n        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',\n        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',\n        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',\n        'Census_PowerPlatformRoleName':                         'category',\n        'Census_InternalBatteryType':                           'category',\n        'Census_InternalBatteryNumberOfCharges':                'float32',\n        'Census_OSVersion':                                     'category',\n        'Census_OSArchitecture':                                'str',\n        'Census_OSBranch':                                      'category',\n        'Census_OSBuildNumber':                                 'int16',\n        'Census_OSBuildRevision':                               'int32',\n        'Census_OSEdition':                                     'category',\n        'Census_OSSkuName':                                     'category',\n        'Census_OSInstallTypeName':                             'category',\n        'Census_OSInstallLanguageIdentifier':                   'float16',\n        'Census_OSUILocaleIdentifier':                          'int16',\n        'Census_OSWUAutoUpdateOptionsName':                     'category',\n        'Census_IsPortableOperatingSystem':                     'int8',\n        'Census_GenuineStateName':                              'category',\n        'Census_ActivationChannel':                             'category',\n        'Census_IsFlightingInternal':                           'float16',\n        'Census_IsFlightsDisabled':                             'float16',\n        'Census_FlightRing':                                    'category',\n        'Census_ThresholdOptIn':                                'float16',\n        'Census_FirmwareManufacturerIdentifier':                'float16',\n        'Census_FirmwareVersionIdentifier':                     'float32',\n        'Census_IsSecureBootEnabled':                           'int8',\n        'Census_IsWIMBootEnabled':                              'float16',\n        'Census_IsVirtualDevice':                               'float16',\n        'Census_IsTouchEnabled':                                'int8',\n        'Census_IsPenCapable':                                  'int8',\n        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',\n        'Wdft_IsGamer':                                         'float16',\n        'Wdft_RegionIdentifier':                                'float16',\n        'HasDetections':                                        'int8'\n        }","980cb9a4":"train_df = pd.read_csv('..\/input\/microsoft-malware-prediction\/train.csv', dtype=dtypes)","04ba6dd2":"def category_and_version(category_col, version_col, df):\n    aux = df[[category_col, 'HasDetections']].groupby(category_col).agg(['sum', 'count'])\n    aux['infected_rate'] = aux['HasDetections']['sum'] \/ aux['HasDetections']['count']\n    aux['sum'] = aux['HasDetections']['sum']\n    aux['count'] = aux['HasDetections']['count']\n    aux = aux[['infected_rate', 'sum', 'count']].reset_index().sort_values('infected_rate', ascending=False)        \n    \n    category_vals = aux[category_col]\n    \n    print(aux)\n    \n    gc.collect()\n    \n    aux1 = df[[version_col, category_col, 'HasDetections']]\n    \n    for i_cat in category_vals:\n        aux = aux1[aux1[category_col] == i_cat]\n        ordered_levels = np.sort(np.unique(aux[version_col]))\n\n        aux = aux[[version_col, 'HasDetections']].groupby(version_col).agg(['sum','count'])\n        aux['infected_rate'] = aux['HasDetections']['sum'] \/ aux['HasDetections']['count']\n        aux['sum'] = aux['HasDetections']['sum']\n        aux['count'] = aux['HasDetections']['count']\n        aux = aux[['infected_rate', 'sum', 'count']].reset_index()\n\n        sns.utils.plt.figure(figsize=(15, 10))\n        ax = sns.pointplot(x=version_col, y='infected_rate', palette=\"YlGnBu_d\", #hue = 'count', \n                           data=aux, join=False, order=ordered_levels)\n        ax.set_xticklabels(ax.get_xticklabels(),rotation=90)\n#         sns.utils.plt.legend(loc='upper left',bbox_to_anchor=(1, 1))\n        ax.set_title(category_col + ' = ' + str(i_cat) + ', ' + str(version_col) + ' ordered')\n        sns.utils.plt.show()","dd0c84af":"category_and_version('ProductName', 'EngineVersion', train_df)","40570ddd":"category_and_version('ProductName', 'AppVersion', train_df)","740cccf8":"category_and_version('Platform', 'OsSuite', train_df)","b86aabe9":"# data_dtypes.py\nDTYPES = {\n        'MachineIdentifier':                                    'category',\n        'ProductName':                                          'category', \n        'EngineVersion':                                        'category',\n        'AppVersion':                                           'category',\n        'AvSigVersion':                                         'category',\n        'IsBeta':                                               'int8', \n        'RtpStateBitfield':                                     'float16',\n        'IsSxsPassiveMode':                                     'int8', \n        'DefaultBrowsersIdentifier':                            'float16', \n        'AVProductStatesIdentifier':                            'float32',\n        'AVProductsInstalled':                                  'float16',\n        'AVProductsEnabled':                                    'float16', \n        'HasTpm':                                               'int8', \n        'CountryIdentifier':                                    'int16',\n        'CityIdentifier':                                       'float32',\n        'OrganizationIdentifier':                               'float16', \n        'GeoNameIdentifier':                                    'float16', \n        'LocaleEnglishNameIdentifier':                          'int8', \n        'Platform':                                             'category', \n        'Processor':                                            'category', \n        'OsVer':                                                'category', \n        'OsBuild':                                              'int16', \n        'OsSuite':                                              'int16', \n        'OsPlatformSubRelease':                                 'category', \n        'OsBuildLab':                                           'category', \n        'SkuEdition':                                           'category', \n        'IsProtected':                                          'float16', \n        'AutoSampleOptIn':                                      'int8', \n        'PuaMode':                                              'category', \n        'SMode':                                                'float16', \n        'IeVerIdentifier':                                      'float16',\n        'SmartScreen':                                          'category',\n        'Firewall':                                             'float16', \n        'UacLuaenable':                                         'float32', \n        'Census_MDC2FormFactor':                                'category', \n        'Census_DeviceFamily':                                  'category', \n        'Census_OEMNameIdentifier':                             'float16',\n        'Census_OEMModelIdentifier':                            'float32',\n        'Census_ProcessorCoreCount':                            'float16', \n        'Census_ProcessorManufacturerIdentifier':               'float16', \n        'Census_ProcessorModelIdentifier':                      'float16',\n        'Census_ProcessorClass':                                'category', \n        'Census_PrimaryDiskTotalCapacity':                      'float32',\n        'Census_PrimaryDiskTypeName':                           'category', \n        'Census_SystemVolumeTotalCapacity':                     'float32',\n        'Census_HasOpticalDiskDrive':                           'int8', \n        'Census_TotalPhysicalRAM':                              'float32',\n        'Census_ChassisTypeName':                               'category', \n        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',\n        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16', \n        'Census_InternalPrimaryDisplayResolutionVertical':      'float16', \n        'Census_PowerPlatformRoleName':                         'category', \n        'Census_InternalBatteryType':                           'category', \n        'Census_InternalBatteryNumberOfCharges':                'float32',\n        'Census_OSVersion':                                     'category', \n        'Census_OSArchitecture':                                'category', \n        'Census_OSBranch':                                      'category',\n        'Census_OSBuildNumber':                                 'int16', \n        'Census_OSBuildRevision':                               'int32',\n        'Census_OSEdition':                                     'category', \n        'Census_OSSkuName':                                     'category',\n        'Census_OSInstallTypeName':                             'category',\n        'Census_OSInstallLanguageIdentifier':                   'float16', \n        'Census_OSUILocaleIdentifier':                          'int16', \n        'Census_OSWUAutoUpdateOptionsName':                     'category', \n        'Census_IsPortableOperatingSystem':                     'int8', \n        'Census_GenuineStateName':                              'category', \n        'Census_ActivationChannel':                             'category',\n        'Census_IsFlightingInternal':                           'float16', \n        'Census_IsFlightsDisabled':                             'float16', \n        'Census_FlightRing':                                    'category', \n        'Census_ThresholdOptIn':                                'float16', \n        'Census_FirmwareManufacturerIdentifier':                'float16', \n        'Census_FirmwareVersionIdentifier':                     'float32',\n        'Census_IsSecureBootEnabled':                           'int8', \n        'Census_IsWIMBootEnabled':                              'float16', \n        'Census_IsVirtualDevice':                               'float16', \n        'Census_IsTouchEnabled':                                'int8', \n        'Census_IsPenCapable':                                  'int8', \n        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16', \n        'Wdft_IsGamer':                                         'float16',\n        'Wdft_RegionIdentifier':                                'float16',\n        'HasDetections':                                        'int8'\n        }","13aed6da":"# feature_engineering.py\nimport numpy as np \nimport pandas as pd \nfrom data_dtypes import DTYPES\nfrom tqdm import tqdm\n\nTRAIN_OUTPUT_PATH = '.\/train_kaggle_feature_engineered.pickle'\nTEST_OUTPUT_PATH = '.\/test_kaggle_feature_engineered.pickle'\n\n# https:\/\/gist.github.com\/eherrerosj\/fdac2b3761a10332da163b1c90367890\ndef reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df\n\ndef frequency_encoding(variable):\n    t = pd.concat([train[variable], test[variable]]).value_counts().reset_index()\n    t = t.reset_index()\n    t.loc[t[variable] == 1, 'level_0'] = np.nan\n    t.set_index('index', inplace=True)\n    max_label = t['level_0'].max() + 1\n    t.fillna(max_label, inplace=True)\n    return t.to_dict()['level_0']\n\ncols_to_use = ['MachineIdentifier', 'HasDetections', \n               'EngineVersion', 'AppVersion', 'RtpStateBitfield', 'AVProductsInstalled', 'IeVerIdentifier', \n               'SmartScreen', 'Census_OEMNameIdentifier', 'Census_ProcessorModelIdentifier', \n               'Census_PrimaryDiskTotalCapacity', 'Census_SystemVolumeTotalCapacity', 'Census_TotalPhysicalRAM', \n               'Census_InternalPrimaryDiagonalDisplaySizeInInches', 'Census_InternalBatteryNumberOfCharges', \n               'Census_OSBranch', 'Census_OSBuildRevision', 'Census_OSSkuName', 'Census_OSInstallTypeName', \n               'Census_ActivationChannel', 'Wdft_IsGamer', 'Wdft_RegionIdentifier']\n\ncategorical_features = ['SmartScreen', 'Census_OSInstallTypeName', 'Census_ActivationChannel',\n                        'Census_OSBranch', 'Census_OSSkuName']\n\ntrain = pd.read_csv('.\/train.csv', dtype = DTYPES, usecols=cols_to_use)\ncols_to_use.remove('HasDetections')\ntest = pd.read_csv('.\/test.csv', dtype = DTYPES, usecols=cols_to_use)\n\nfrequency_encoded_variables = [\n    'Census_ProcessorModelIdentifier',\n    'Census_OEMNameIdentifier',\n    'AppVersion', \n    'EngineVersion'\n]\n\nfor variable in tqdm(frequency_encoded_variables):\n    freq_enc_dict = frequency_encoding(variable)\n    train[variable] = train[variable].map(lambda x: freq_enc_dict.get(x, np.nan))\n    test[variable] = test[variable].map(lambda x: freq_enc_dict.get(x, np.nan))\n    train[variable] = train[variable].astype('float16')\n    test[variable] = test[variable].astype('float16')   \n\nindexer = {}\nfor col in tqdm(categorical_features):\n    print(col)\n    if col == 'MachineIdentifier': continue\n    _, indexer[col] = pd.factorize(train[col])\n    \nfor col in tqdm(categorical_features):\n    if col == 'MachineIdentifier': continue\n    train[col] = indexer[col].get_indexer(train[col])\n    test[col] = indexer[col].get_indexer(test[col])\n\ntrain = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)\n\ntrain.to_pickle(TRAIN_OUTPUT_PATH)\ntest.to_pickle(TEST_OUTPUT_PATH)\n","6ee4b0a7":"# train_and_predict.py\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport lightgbm as lgb\nimport gc\nimport seaborn as sns\nfrom joblib import load, dump\nfrom sklearn.model_selection import ShuffleSplit\nfrom sklearn.metrics import roc_auc_score\n\nTRAIN_OUTPUT_PATH = '.\/train_kaggle_feature_engineered.pickle'\nTEST_OUTPUT_PATH = '.\/test_kaggle_feature_engineered.pickle'\n\n# Reading previously feature engineered train dataset\ntrain = pd.read_pickle(TRAIN_OUTPUT_PATH)\n\ntarget = train['HasDetections']\ndel train['HasDetections']\n\n# Creating splits\nshuffle_split_tr = ShuffleSplit(n_splits=1, test_size=0.3, random_state=22)\nshuffle_split_tr.get_n_splits(train, target)\ntrain_idx, val_idx = next(shuffle_split_tr.split(train, target)) \n\nshuffle_split_val_test = ShuffleSplit(n_splits=1, test_size=0.5, random_state=22)\nshuffle_split_val_test.get_n_splits(val_idx, target[val_idx])\nval_idx, tst_idx = next(shuffle_split_val_test.split(val_idx, target[val_idx])) \n\nfeatures = [c for c in train.columns if c not in ['MachineIdentifier']]\n\n# Training stage\ncategorical_features = ['SmartScreen', 'Census_OSInstallTypeName', 'Census_ActivationChannel',\n                        'Census_OSBranch', 'Census_OSSkuName', 'Wdft_RegionIdentifier', \n                        'Census_OSBuildRevision', 'IeVerIdentifier']\n\ntrain_lgb = lgb.Dataset(train.iloc[train_idx][features],\n                        label=target.iloc[train_idx],\n                        categorical_feature = categorical_features\n                       )\n\nval_lgb = lgb.Dataset(train.iloc[val_idx][features],\n                      label=target.iloc[val_idx],\n                      categorical_feature = categorical_features\n                     )\n\nparams = {'num_leaves': 60,\n          'min_data_in_leaf': 60, \n          'objective':'binary',\n          'max_depth': 8,\n          'learning_rate': 0.1,\n          'boosting': 'gbdt',\n          'feature_fraction': 0.8,\n          'bagging_freq': 1,\n          'bagging_fraction': 0.8 ,\n          'bagging_seed': 11,\n          'metric': 'auc',\n          'lambda_l1': 0.50,\n          'random_state': 133,\n          'verbosity': -1}\n\nnum_round = 3000\nmodel = lgb.train(params,\n                  train_lgb,\n                  num_round,\n                  valid_sets = [train_lgb, val_lgb],\n                  verbose_eval = 100,\n                  early_stopping_rounds = 200)                                                                                                                                                                          \n\ndump(model, '.\/malware_model_lgbm.pkl')\n\ndel train_lgb\ndel val_lgb\n\n# Simple assessment\nprint('Training dataset:')\nprint( roc_auc_score(target[train_idx], model.predict(train.iloc[train_idx][features])) )\n\nprint('Validation dataset:')\nprint( roc_auc_score(target[val_idx], model.predict(train.iloc[val_idx][features])) )\n\nprint('Test dataset:')\nprint( roc_auc_score(target[tst_idx], model.predict(train.iloc[tst_idx][features])) )\n\ndel train\n\n# Predicting probabilities for the submission dataset\ntest = pd.read_pickle(TEST_OUTPUT_PATH)\nprobs = model.predict(test[features], num_iteration=model.best_iteration)\n\nsub_df = pd.DataFrame({'MachineIdentifier': test['MachineIdentifier'].values})\nsub_df['HasDetections'] = probs\n\nsub_df.to_csv('.\/malware_probs_submission.csv', index=False)","ece8761b":"model = load('..\/input\/malware_detection_challenge_8th_place_solutions\/malware_model_lgbm.pkl')\n\nimportance_df = pd.DataFrame()\nimportance_df[\"feature\"] = model.feature_name()\nimportance_df[\"importance\"] = model.feature_importance(importance_type='gain')\npd.set_option('display.max_rows', 500)\nimportance_df.sort_values(ascending=False, by='importance')","4308f97d":"I didn't spend many time tweaking the model hyperparameters, to be honest: in this challenge I wanted to test some things I learnt at work: the data is the core of everything and working toe to tow with it can have a bigger impact in results than focusing on tweaking hyperparameters.\n\nMaybe if I used k-fold Cross Validation I could have gotten better results.\n\nConstructive criticism and feedback is well appreciated. Thank you!","a77042ed":"Hello. This is the 8th place solution. I'm sorry for posting the solution this *late*.\n\nMy path through this competition had 2 main stages. One important thing to have in mind is that in this competition I used my laptop, which has a limited hardware (Intel i5-5200U, 16 GB) so I always tried to minimize the number of columns, choose the right types and store partial results in pickle files to avoid my computer hang.\n\nI'll briefly explain the first stage:\n\nAt first I promised myself to work with this paradigm: let's explore de data, let's formulate an hypothesis on how the data works and let's have it in mind the whole time because this could help me to detect bugs and making better decision on what things to try and what not.\n\nMy first thought was that the different version variables (software versions, database version, etc) could be an important key to predict Malware correctly, because they might hide some temporary information.","a6f45e6f":"Here's the code that trains the model and predicts the probabilities for the submission dataset:","5e37d93b":"Here I only plotted some variables, but in some cases (specially in those with most observations) I can see the infection rate is slightly higher for the oldest versions and for the newest versions too. Plus, in these cases infection rates through versions are close.\n\nSo given this information, I decided that one way to encode categorical variables could be creating a count variable, a infection rate variable and rolling window features (window size = 5) like mean and standard deviation infection rate. \n\nI did so, and the first stage I mentioned before had this way of encoding categorical variables was the core of my approach. I used other numerical variables too, plus I added variables to have in mind the order of the versions. I fitted a Gradient Boosting Machine and... \n\nI got bad results, ~0.64 as a public score.\n\nSome things I tried too and didn't work:\n- I created other variables like discretize variables using k-means or a decision tree\n- I created new variables like display diagonal, display aspect rate, squared or rectangular screen shape, binary variables that say if two variables are equal or not (Census_OSArchitecture vs Processor, OsBuild vs Census_OSBuildRevision and SkuEdition vs Census_OSSkuName. \n- I even scrapped this site 'https:\/\/www.microsoft.com\/en-us\/wdsi\/definitions\/antimalware-definition-release-notes' to get more info about versions (severities and threat types)\n- I got information from Google Trends for the topic 'malware' from 2012 to 2017.\n\nStill, none of this worked.\n\nWhen I reached this point I said to myself: \"Okay, none of this worked so let's turn the 'competition mode' on\". And this is the second stage.\n\nI began by taking a look at other people kernels and I got this ideas:\n- I wasn't using many categorical variables, plus my way of encoding variables wasn't the best \n- Many people could be overfitting\n- The training and test distributions could be different\n\nAmong many kernels, this was the most useful for me: https:\/\/www.kaggle.com\/fabiendaniel\/detecting-malwares-with-lgbm \n\nThanks to this kernel I discovered that I could use categorical columns without creating dummy variables, making the categorical variables encoding process way more easy and maybe even keeping almost all the \"raw information power\". Another thing I was doing differently compared to this kernel is that this kernel is that I was only using the training dataset when calculating count variables and Fabien uses both the traning and the test datasets (this is what made me thought that train and test distributions could be different and maybe using both datasets for this task could be an advantage).\n\nGiven all this, my main goal was not to overfit. How did I do this?\n- I focused on not having big differences between the ROC AUC values from the different dataset splits \n- Manually choosing which variables should be used in the model (and which categorical features should be encoded as counts, this was key too)\n- I felt comfortable with a 0.66 ROC AUC as public score. I distrusted higher public score values because when I got those values I had big differences between my train and validation splits, and sometimes this happened at the cost of adding more variables because adding only one variable caused very little improvement.\n\nHere's the code that creates the desired variables for train and test datasets:","65747669":"Variable importance:","58f0843a":"Census_ProcessorModelIdentifier, Census_OEMNameIdentifier, AppVersion and EngineVersion were encoded as counts by category."}}