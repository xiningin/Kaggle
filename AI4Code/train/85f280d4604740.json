{"cell_type":{"bd27a1a1":"code","2fc2fd01":"code","0315f638":"code","3a868a79":"code","0832cd0f":"code","588c5215":"code","f3e31556":"markdown","90ecfbc4":"markdown","c578cb9f":"markdown"},"source":{"bd27a1a1":"import numpy as np\nfrom scipy.optimize import linear_sum_assignment\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom PIL import Image","2fc2fd01":"def iou(bbox1, bbox2):\n    bbox1 = [float(x) for x in bbox1]\n    bbox2 = [float(x) for x in bbox2]\n\n    (x0_1, y0_1, x1_1, y1_1) = bbox1\n    (x0_2, y0_2, x1_2, y1_2) = bbox2\n\n    # get the overlap rectangle\n    overlap_x0 = max(x0_1, x0_2)\n    overlap_y0 = max(y0_1, y0_2)\n    overlap_x1 = min(x1_1, x1_2)\n    overlap_y1 = min(y1_1, y1_2)\n\n    # check if there is an overlap\n    if overlap_x1 - overlap_x0 <= 0 or overlap_y1 - overlap_y0 <= 0:\n            return 0\n\n    # if yes, calculate the ratio of the overlap to each ROI size and the unified size\n    size_1 = (x1_1 - x0_1) * (y1_1 - y0_1)\n    size_2 = (x1_2 - x0_2) * (y1_2 - y0_2)\n    size_intersection = (overlap_x1 - overlap_x0) * (overlap_y1 - overlap_y0)\n    size_union = size_1 + size_2 - size_intersection\n\n    return size_intersection \/ size_union","0315f638":"def precision_calc(gt_boxes, pred_boxes):\n    cost_matix = np.ones((len(gt_boxes), len(pred_boxes)))\n    for i, box1 in enumerate(gt_boxes):\n        for j, box2 in enumerate(pred_boxes):\n            dist = abs(box1[0]-box2[0])\n            if dist > 4:\n                continue\n            iou_score = iou(box1[1:], box2[1:])\n\n            if iou_score < 0.35:\n                continue\n            else:\n                cost_matix[i,j]=0\n\n    row_ind, col_ind = linear_sum_assignment(cost_matix)\n    fn = len(gt_boxes) - row_ind.shape[0]\n    fp = len(pred_boxes) - col_ind.shape[0]\n    tp=0\n    for i, j in zip(row_ind, col_ind):\n        if cost_matix[i,j]==0:\n            tp+=1\n        else:\n            fp+=1\n            fn+=1\n    return tp, fp, fn","3a868a79":"gt_boxes = [[0, 50,60, 120, 130], [0, 40, 20, 110, 80], [0, 140, 20, 190, 80]]\npred_boxes = [[0, 55, 30, 130, 110], [0, 60, 90, 135, 140], [0, 70, 120, 155, 190]]\n\nim = np.array(Image.new('RGB', (224, 224)))\nfig,ax = plt.subplots(1)\nax.imshow(im)\n\nfor box in gt_boxes:\n    rect = patches.Rectangle((box[1],box[2]),box[3]-box[1],box[4]-box[2],linewidth=1,edgecolor='g',facecolor='none')\n    ax.add_patch(rect)\n    \nfor box in pred_boxes:\n    rect = patches.Rectangle((box[1],box[2]),box[3]-box[1],box[4]-box[2],linewidth=1,edgecolor='r',facecolor='none')\n    ax.add_patch(rect)","0832cd0f":"tp, fp, fn = precision_calc(gt_boxes, pred_boxes)\nprint(f'TP: {tp}, FP: {fp} FN: {fn}')","588c5215":"#Calculating CV score.\ntestdata = np.load('..\/input\/test-metrics\/testdata.npy', allow_pickle=True)\nftp, ffp, ffn = [], [], []\nfor count, data in enumerate(testdata):\n    pred_boxes = data['data']['preds']\n    gt_boxes = data['data']['gt']\n    tp, fp, fn = precision_calc(gt_boxes, pred_boxes)\n    ftp.append(tp)\n    ffp.append(fp)\n    ffn.append(fn)\n\ntp = np.sum(ftp)\nfp = np.sum(ffp)\nfn = np.sum(ffn)\nprecision = tp \/ (tp + fp + 1e-6)\nrecall =  tp \/ (tp + fn +1e-6)\nf1_score = 2*(precision*recall)\/(precision+recall+1e-6)\nprint(f'TP: {tp}, FP: {fp}, FN: {fn}, PRECISION: {precision:.4f}, RECALL: {recall:.4f}, F1 SCORE: {f1_score}')","f3e31556":"# Calculating CV score","90ecfbc4":"I am sharing my script for calculating my CV score. In this notebook, I use hungarian matching algorithm to maximize F1 score. I hope there won't be much different between mine and competition metric. Please feel free to correct me if I make a mistake.\n\nBy using this script I get a CV of 0.368 and LB 0.4","c578cb9f":"# Testing algorithm\nboxes format: frame_index, xmin, ymin, xmax, ymax"}}