{"cell_type":{"2f6b84fd":"code","cd8f6219":"code","7bbc23a1":"code","96316392":"code","f296f805":"code","fcaa10e9":"code","4a430f09":"code","68f660e2":"code","c46ca45e":"code","6161fb0e":"code","4f2dc3dc":"markdown","c00ac2c0":"markdown","59708842":"markdown","1c28dd35":"markdown","c161564c":"markdown","0eabae88":"markdown","21781cec":"markdown","d14e89e9":"markdown","5e2a5e55":"markdown"},"source":{"2f6b84fd":"# Use these libraries only for your exercise.\n\nimport numpy as np\nimport librosa\nimport pickle as pk\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport time\nimport soundfile as sf\nimport IPython\nfrom scipy.fft import fft, ifft\nfrom pydub import AudioSegment","cd8f6219":"high_freq_noise_audio_file = '..\/input\/caproject-data\/noisy_air_talk.wav'\n\n# Digital samples extraction from the audio file.\nnoisy_wave, sampling_freq = sf.read(high_freq_noise_audio_file)\n\nIPython.display.Audio(high_freq_noise_audio_file)","7bbc23a1":"# Import package used for plotting charts\nimport matplotlib.pyplot as plt\n\n# Create the figure and axis handles for the plot\nfig, ax = plt.subplots(figsize=(30,15))\n\n# Create time axis.\ntime = np.arange(len(noisy_wave))   # This creates an array starting from 0, 1, .. length of the signal-1.\ntime = time\/sampling_freq        # Divides each element by the sampling frequency to obtain seconds.\n\n# Plot the Noisy Sigmals\nax.plot(time, noisy_wave)\nax.set(xlabel = 'Time\/s',\n       ylabel = 'Amp',\n       title = 'Noisy signal')\n\nplt.show()","96316392":"# Carry out FFT here.\n\n# We obtain the fft module from the SCIPY package.\nfrom scipy.fft import fft\n\n# Create the frequency axis. \nfrequency = np.arange(len(noisy_wave))*(sampling_freq\/len(noisy_wave))\n\n# Carry out the FFT on the noisy signal.\nspectrum = fft(noisy_wave)\n\n# Take magnitude of the spectrum.\nspectrum_abs = np.abs(spectrum)\n\n# Plot audio signal amplitude versus frequency.\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(frequency, spectrum_abs)\nax.set(xlabel = 'Frequency\/Hz',\n      ylabel = 'Amp',\n      title = 'Spectrum of Noisy Signal')\n\nplt.show()\n\n# Identity location of peaks.\nthreshold = np.max(spectrum_abs)\/2.0\nindices = np.argwhere(spectrum_abs > threshold)\nprint(\"Frequencies of interest\/Hz:\\n %s\" % frequency[indices])","f296f805":"# Process spectrum and convert back to the time domain signal.\n\nnoisespectrum = spectrum.copy()\nremovalspectrum = spectrum.copy()\n\n# To visualise noise spectrum\nfor i in range(len(noisespectrum)):\n    if np.abs(noisespectrum[i]) < threshold:\n        noisespectrum[i] = 0\n        \n\n# Plotting the noise spectrum.\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(frequency, np.abs(noisespectrum))\nax.set(xlabel = 'Frequency\/Hz',\n      ylabel = 'Amp',\n      title = 'Noise Spectrum')\n\nplt.show()\n\n#filtering the spectrum to remove noise\nfor i in range(len(removalspectrum)):\n    if np.abs(removalspectrum[i]) > threshold:\n        removalspectrum[i-500:i+1000] = 0\n\n#plotting the final filtered spectrum\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(frequency, np.abs(removalspectrum))\nax.set(xlabel = 'Frequency\/Hz',\n      ylabel = 'Amp',\n      title = 'Spectrum of Signal with Noise Removed')\n\nplt.show()\n\n# Inverse FFT to convert to time domain\nfft_filtered = ifft(removalspectrum)\nfft_filtered = np.int16(fft_filtered * (32767 \/ fft_filtered.max()))\n\n# Write fft_filtered to a wav file and play it back.\nsf.write('filtered_audio.wav', fft_filtered, sampling_freq)\nIPython.display.Audio('filtered_audio.wav')","fcaa10e9":"clean_audio_file = '..\/input\/caproject-data\/short_wave.wav'\n\n# Extract the clean audio waveform.\noriginal, sampling_freq = sf.read(clean_audio_file)\n\n# Listen to audio here.\nIPython.display.Audio(clean_audio_file)","4a430f09":"# Noise generating method.\ndef noise_wave(input):\n    noise = np.random.uniform(-1.0, 1.0, len(input)).reshape(input.shape)\n    output = input + noise\n    return output, noise\n\nnoisy_wave, noise = noise_wave(original)","68f660e2":"# Corrupt the noise to simulate an imperfect noise reference.\n# Note that there is a change in noise amplitude as a result of the noise source moving away from the microphone.\ndef corrupt_noise_reference(noise):\n    split = round(len(noise)\/2)\n    remain = len(noise) - split\n    noise_ref = np.append(0.5*noise[:split], 0.25*noise[remain:])\n    return noise_ref\n    \nnoise_ref = corrupt_noise_reference(noise)","c46ca45e":"# Subtract noise directly from the signal.\nnaive_reconstruct = noisy_wave - noise_ref\n\n# Plot the required charts.\n\n# Plot for Noisy Wave\n# Create time axis.\ntime = np.arange(len(noisy_wave))   # This creates an array starting from 0, 1, .. length of the signal-1.\ntime = time\/sampling_freq        # Divides each element by the sampling frequency to obtain seconds.\n\n# Plot the signals\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(time, noisy_wave)\nax.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Noisy Wave')\n\nplt.show()\n\n# Plot for Noise\n# Create time axis.\ntime = np.arange(len(noise))   # This creates an array starting from 0, 1, .. length of the signal-1.\ntime = time\/sampling_freq        # Divides each element by the sampling frequency to obtain seconds.\n\n# Plot the signals\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(time, noise)\nax.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Noise')\n\nplt.show()\n\n# Plot for Noise Ref\n# Create time axis.\ntime = np.arange(len(noise_ref))   # This creates an array starting from 0, 1, .. length of the signal-1.\ntime = time\/sampling_freq        # Divides each element by the sampling frequency to obtain seconds.\n\n# Plot the signals\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(time, noise_ref)\nax.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Noise Ref')\n\nplt.show()\n\n# Plot for Naive Reconstruct\n# Create time axis.\ntime = np.arange(len(naive_reconstruct))   # This creates an array starting from 0, 1, .. length of the signal-1.\ntime = time\/sampling_freq        # Divides each element by the sampling frequency to obtain seconds.\n\n# Plot the signals\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(time, naive_reconstruct)\nax.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Naive Reconstruct')\n\nplt.show()\n\n# Play back audio naive_reconstruct\n# Write audio naive_reconstruct to a wav file\nsf.write('audio naive_reconstruct.wav', naive_reconstruct, sampling_freq)\n# Listen to the audio\nIPython.display.Audio('audio naive_reconstruct.wav')","6161fb0e":"# Adaptive filter code here.\n# Import the filter design package.\nfrom scipy import signal\n\n# Filter parameters.\nN = 4                                               # Filter order.\ncutOff = 2600.0\/(sampling_freq\/2)          # Cut-Off frequency in rad\/s.\nbtype = 'low'\n\n# Obtain filter coefficients here.\nb, a = signal.butter(N, cutOff, btype)\n\n# Use the filter here.\nfiltered = signal.filtfilt(b, a, naive_reconstruct)\n\n# Plot the filtered signal here. Compare that visually with the original signal.\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(30,15))\n\nax1.plot(time, naive_reconstruct)\nax1.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Noisy Signal')\n\nax2.plot(time, filtered)\nax2.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Filtered Signal')\n\nplt.show()\n\n\n# Play back the filtered signal.\n# Write filteredsignal to a wav file\nsf.write('filteredsignal.wav', filtered, sampling_freq)\n# Listen to the audio\nIPython.display.Audio('filteredsignal.wav')","4f2dc3dc":"Since the noise spectrum is not well defined and overlapped with the desired signal, we cannot make use of a conventional filter with fixed coefficients to clean the signal enough for us. However, we can still remove the noise if we can obtain the noise reference using a second microphone. This is usually imperfect because the amplitude of the noise reference is not the same as the original noise. We simulate this scenario by 'corrupting' the noise signal. ","c00ac2c0":"# **MA4705 Continual Assessment 1** \nGroup: DSP 33\n\nMembers: Lee Wen Hui Jamie (A180051), Amber Voo E Ning (AMBE0002) \n\n# **Cleaning Air Talk**\n\nHuman speech lies roughly within the spectrum of 20 Hz to 4 kHz. In this exercise, your job is to clean up noisy conversations between the control tower and pilots. Please make use of ONLY the libraries\/packages below to complete this exercise. Otherwise, marks will be deducted.","59708842":"## High Frequency Noise \n\nAdd the following audio clips 'noisy_air_talk.wav' to your notebook environment. Play back the audio clip using the method shown below. Notice the high frequency buzz in the background. Let's extract the audio to a variable named 'sig'.","1c28dd35":"### a. Spectral analysis of the signal via Fast Fourier Transform (FFT) [4 marks]\n\nPerform a Fast Fourier Transform on the signal and identify the noise spectrum. ","c161564c":"### b. By means of the inverse FFT, implement the noise removal method and play back the reconstructed waveform. [6 marks]","0eabae88":"### d. Using the imperfect 'noise_ref' and 'noisy_wave', design an adaptive filter to remove the noise. Plot the original clean signal and the final filtered signal. Write code to play back the filtered signal. [5 marks]","21781cec":"## Noise\n\nAdd the following audio clip 'short_wave.wav' to your notebook environment. This is the clean and crisp audio clip of the conversations. Listen to it and extract the raw samples from the file to a variable named 'original'.","d14e89e9":"Let's add some noise to clean audio. Since random samples are drawn from a uniform distribution to create a noisy wave. This noise is then added to the original signal.","5e2a5e55":"### c. Recover the original signal by subtracting 'noise_ref' from 'noisy_wave' to obtain signal 'naive_reconstruct'. Plot the signals 'noisy_wave', 'noise', 'noise_ref', and 'naive_reconstruct'. Play back the naive_reconstruct signal. [5 marks]   "}}