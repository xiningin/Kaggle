{"cell_type":{"ea6cb727":"code","4d337c92":"code","d9f9c0ae":"code","dfc4e918":"code","a91ca828":"code","a7be60d4":"code","ecdfaa7f":"code","b9d40f92":"code","8e58284c":"code","d661ced3":"markdown","73ee9a06":"markdown","ba7f98ac":"markdown","7b9b7ea0":"markdown","0f9f9855":"markdown","eb6203cb":"markdown","8758de86":"markdown"},"source":{"ea6cb727":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom torch import nn\nfrom torch.utils import model_zoo\nimport torch\nimport torchvision\nimport torchvision.transforms as transforms\nimport torch.nn.functional as F\nfrom torch.utils.data.sampler import SubsetRandomSampler","4d337c92":"\n\nclass AlexNet(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(AlexNet, self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(3, 64, 11, stride=4),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(3, stride=2),\n            nn.Conv2d(64, 192, 5, padding=2),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(3, stride=2),\n            nn.Conv2d(192, 384, 3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(384, 256, 3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(256, 256, 3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(3, stride=2),\n        )\n        self.avgpool = nn.AdaptiveAvgPool2d((6, 6))\n        self.classifier = nn.Sequential(\n            nn.Dropout(),\n            nn.Linear(256 * 6 * 6, 4096),\n            nn.ReLU(inplace=True),\n            nn.Dropout(),\n            nn.Linear(4096, 4096),\n            nn.ReLU(inplace=True),\n            nn.Linear(4096, num_classes),\n        )\n\n    def forward(self, x):\n        x = self.features(x)\n        x = self.avgpool(x)\n        x = torch.flatten(x, 1)\n        x = self.classifier(x)\n        return x","d9f9c0ae":"def alexnet_classifier(num_classes):\n    classifier = nn.Sequential(\n            nn.Dropout(),\n            nn.Linear(256 * 6 * 6, 128),\n            nn.ReLU(inplace=True),\n            nn.Dropout(),\n            nn.Linear(128, 64),\n            nn.ReLU(inplace=True),\n            nn.Linear(64, num_classes),\n            nn.Softmax(),\n        )\n    return classifier\n\ndef alexnet(num_classes, pretrained=False, **kwargs):\n    \"\"\"AlexNet model architecture from the\n    `\"One weird trick...\" `_ paper.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = AlexNet(**kwargs)\n    if pretrained:\n        model.load_state_dict(model_zoo.load_url('https:\/\/download.pytorch.org\/models\/alexnet-owt-4df8aa71.pth'))\n        for p in model.features.parameters():\n            p.requires_grad=False\n    classifier = alexnet_classifier(num_classes)\n    model.classifier = classifier\n    \n    return model","dfc4e918":"torchvision.transforms.functional.resize\ntransform = transforms.Compose(\n    [\n     transforms.Resize(size=(224, 224)),\n     transforms.ToTensor(),\n     transforms.Normalize((0.5,), (0.5,)),\n])\n     \n\nbatch_size = 64\n\nidx_train = np.arange(50000)\nnp.random.shuffle(idx_train)\nidx_train = idx_train[:1000]\n\ntrainset = torchvision.datasets.CIFAR10(root=\".\/data\", train=True, transform=transform, download=True)\ntrainloader = torch.utils.data.DataLoader(trainset,batch_size=batch_size,shuffle=False,num_workers=2,\n                                         sampler=SubsetRandomSampler(idx_train))\n\nidx_test = np.arange(10000)\nnp.random.shuffle(idx_test)\nidx_test = idx_train[:1000]\n\ntestset = torchvision.datasets.CIFAR10(root=\".\/data\", train=False, transform=transform, download=True)\ntestloader = torch.utils.data.DataLoader(trainset,batch_size=batch_size,shuffle=False,num_workers=2)\n\n\ndef imshow(img):\n    img = img \/ 2 + 0.5     # unnormalize\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n    plt.show()\n\n\n# get some random training images\ndataiter = iter(trainloader)\nimages, labels = dataiter.next()\n\n# show images\nimshow(torchvision.utils.make_grid(images))","a91ca828":"def show_weights(model, i=0):\n    filter = model.features[i].weight.cpu().data\n    filter = (1 \/ (2 * filter.max())) * filter + 0.5 #Normalizing the values to [0,1]\n    print(filter.shape)\n    img = torchvision.utils.make_grid(filter)\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n    plt.show()\n    imshow(img)","a7be60d4":"show_weights(alexnet(10, True))","ecdfaa7f":"criterion = nn.CrossEntropyLoss()\n\ndef accuracy(net, test_loader, cuda=True):\n    net.eval()\n    correct = 0\n    total = 0\n    loss = 0\n    with torch.no_grad():\n        for data in test_loader:\n            images, labels = data\n            if cuda:\n                images = images.type(torch.cuda.FloatTensor)\n                labels = labels.type(torch.cuda.LongTensor)\n            outputs = net(images)\n            # loss+= criterion(outputs, labels).item()\n            _, predicted = torch.max(outputs.data, 1)\n            total += labels.size(0)\n            correct += (predicted == labels).sum().item()\n            # if total > 100:\n                # break\n    net.train()\n    print('Accuracy of the network on the test images: %d %%' % (\n        100 * correct \/ total))\n    # return (100.0 * correct \/ total, loss\/total)\n    return 100.0 * correct \/ total\n\ndef train(net, optimizer, train_loader, test_loader, loss,  n_epoch = 5,\n          train_acc_period = 100, test_acc_period = 5, cuda=True):\n    loss_train = []\n    loss_test = []\n    total = 0\n    for epoch in range(n_epoch):  # loop over the dataset multiple times\n        running_loss = 0.0\n        running_acc = 0.0\n        for i, data in enumerate(train_loader, 0):\n            # get the inputs\n            inputs, labels = data\n            if cuda:\n                inputs = inputs.type(torch.cuda.FloatTensor)\n                labels = labels.type(torch.cuda.LongTensor)\n            # print(inputs.shape)\n            # zero the parameter gradients\n            optimizer.zero_grad()\n\n            # forward + backward + optimize\n            outputs = net(inputs)\n          \n            loss = criterion(outputs, labels)\n            loss.backward()\n            optimizer.step()\n            total += labels.size(0)\n            # print statistics\n            running_loss = 0.33*loss.item()\/labels.size(0) + 0.66*running_loss\n            _, predicted = torch.max(outputs.data, 1)\n            correct = (predicted == labels).sum().item()\/labels.size(0)\n            running_acc = 0.3*correct + 0.66*running_acc\n            if i % train_acc_period == train_acc_period-1:\n                print('[%d, %5d] loss: %.3f' %(epoch + 1, i + 1, running_loss))\n                print('[%d, %5d] acc: %.3f' %(epoch + 1, i + 1, running_acc))\n                running_loss = 0.0\n                total = 0\n                # break\n        if epoch % test_acc_period == test_acc_period-1:\n            cur_acc, cur_loss = accuracy(net, test_loader, cuda=cuda)\n            print('[%d] loss: %.3f' %(epoch + 1, cur_loss))\n            print('[%d] acc: %.3f' %(epoch + 1, cur_acc))\n      \n    print('Finished Training')","b9d40f92":"net = alexnet(num_classes=10, pretrained=False)\n\nuse_cuda = True\nif use_cuda and torch.cuda.is_available():\n    print(\"using cuda\")\n    net.cuda()\nlearning_rate = 1e-3\noptimizer = torch.optim.Adam(net.parameters(),lr=learning_rate)\ntrain(net, optimizer, trainloader, testloader, criterion,  n_epoch = 50,\n      train_acc_period = 10, test_acc_period = 1000)\nshow_weights(net)\naccuracy(net, testloader, cuda=use_cuda)","8e58284c":"transnet = alexnet(num_classes=10, pretrained=True)\n\nuse_cuda = True\nif use_cuda and torch.cuda.is_available():\n    print(\"using cuda\")\n    transnet.cuda()\nlearning_rate = 1e-3\noptimizer = torch.optim.Adam(transnet.parameters(),lr=learning_rate)\ntrain(transnet, optimizer, trainloader, testloader, criterion,  n_epoch = 50,\n      train_acc_period = 10, test_acc_period = 1000)\nshow_weights(transnet)\naccuracy(transnet, testloader, cuda=use_cuda)","d661ced3":"## Downloading CIFAR10 dataset","73ee9a06":"## Train function for CIFAR10","ba7f98ac":"## Visualizing weights of AlexNet","7b9b7ea0":"From https:\/\/www.enseignement.polytechnique.fr\/informatique\/INF473V\/TD\/6\/INF473V-td_6-1.php\n\nArticle: https:\/\/papers.nips.cc\/paper\/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf","0f9f9855":"## Using pre-trained net","eb6203cb":"## Training from zero","8758de86":"## Defining AlexNet"}}