{"cell_type":{"4f1f4c5f":"code","f587d58e":"code","ab7ae24d":"code","c0be9971":"code","17a0198e":"code","488107d4":"code","12d4d267":"code","6784c915":"code","b9f1f59e":"code","fc8641f9":"code","2ab04dc1":"code","e5033f73":"code","64d8bb2d":"code","39a782cf":"code","3cb565c3":"code","78c66d24":"markdown","f06451c3":"markdown","eb34792a":"markdown","96901366":"markdown","631f760a":"markdown","a0065b4b":"markdown","b72911e8":"markdown"},"source":{"4f1f4c5f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f587d58e":"import cv2\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Conv2D, MaxPool2D, Flatten,MaxPooling2D\nfrom sklearn.model_selection import train_test_split\nfrom keras.applications.resnet import ResNet101\nfrom keras.applications.xception import Xception\nfrom keras.applications.vgg19 import VGG19\n","ab7ae24d":"dataframe = pd.read_csv(\"..\/input\/lfw-people-flatten-data\/lfwpeople.csv\")","c0be9971":"target_mappings = dataframe[[\"target_classes\",\"target_names\"]].set_index([\"target_classes\"]).to_dict()\ntarget_mappings[\"target_names\"]","17a0198e":"for idx,i in enumerate(range(len(set(dataframe['target_classes'])))):\n    rows, cols = 2, 3\n    plt.subplot(rows, cols, idx+1)\n    plt.imshow(dataframe[dataframe['target_classes'] ==i].iloc[:1,2:].values.reshape(62,47))","488107d4":"pixcels = dataframe.iloc[:,2:]\ndef rename_cols(pixcel): \n    columns = list()\n    for i in range(pixcel.shape[1]):\n        columns.append(\"col_\"+str(i))   \n    img_data = dataframe.iloc[:,2:].rename(columns = dict(zip(dataframe.iloc[:,2:].columns.tolist(),columns)))\n    label_data = dataframe.iloc[:,:2]\n    data = label_data.join(img_data)\n    return data\ndata = rename_cols(pixcels)\n\n#X_train = np.array(data.iloc[:500,2:])\n#X_test = np.array(data.iloc[500:,2:])\n\n#y_train =  np.array(data.iloc[:500,1:2])\n#y_test = np.array(data.iloc[500:,1:2])","12d4d267":"train,val = train_test_split(dataframe,test_size=0.2,stratify=dataframe.iloc[:,1].values)","6784c915":"X_train = train.iloc[:,2:].values\ny_train = train.iloc[:,1].values\nX_test = val.iloc[:,2:].values\ny_test = val.iloc[:,1].values","b9f1f59e":"def dim_increase(pixcels):\n    dim_3d = list()\n    for pixcel in pixcels:\n        one_img = pixcel.reshape(62,47)\n        merge_img = cv2.merge([one_img,one_img,one_img])\n        dim_3d.append(merge_img.astype('float32')\/255.0)\n    return dim_3d\nX_train = np.array(dim_increase(X_train))\nX_test = np.array(dim_increase(X_test))","fc8641f9":"model = Sequential()\n# The first two layers with 32 filters of window size 3x3\nmodel.add(Conv2D(32, (3, 3), padding='same', activation='relu', input_shape=(62,47,3)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(64, (3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(64, (3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.25))\n\nmodel.add(Flatten())\nmodel.add(Dense(512, activation='relu'))\nmodel.add(Dense(5, activation='softmax'))\n\n\nmodel.summary()","2ab04dc1":"model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])","e5033f73":"model.fit(X_train, y_train, batch_size=10, epochs=50, validation_data=(X_test,y_test))","64d8bb2d":"plt.plot(model.history.history['accuracy'])\nplt.plot(model.history.history['val_accuracy'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'val'], loc='upper left')\nplt.show()","39a782cf":"plt.plot(model.history.history['loss'])\nplt.plot(model.history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","3cb565c3":"idx = 1\nfor idx in range(10,15):\n    input_img = X_test[idx,:]\n    label = val.iloc[idx,0]\n    print(\"Real : {}\".format(label))\n    cls = model.predict(input_img.reshape(1,62,47,3))\n    print(\"Predicted : {}\".format(target_mappings[\"target_names\"][np.argmax(cls[0])]))\n    print(\"-\"*50)\n    plt.imshow(input_img.reshape(62,47,3))\n    plt.show()","78c66d24":"# **Modelling** ","f06451c3":"# **Predict**","eb34792a":"# **Plotting** ","96901366":"# **Load The Data Using Pandas**","631f760a":"# **Training Model**","a0065b4b":"# **Preprocessing The Data**","b72911e8":"# **Installing The Requirements**"}}