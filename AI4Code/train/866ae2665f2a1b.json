{"cell_type":{"3d1fee4b":"code","6b853474":"code","ba8623a3":"code","efadd4a6":"code","1be8e6de":"code","5fc90869":"code","ec189323":"code","fb38a353":"code","c93db802":"code","e229e893":"code","08641072":"code","fb808f39":"code","e20c5975":"code","7bd2e994":"code","40c94223":"code","530ae61d":"code","b54d2dc6":"code","e56ff917":"code","6d607516":"code","8a91c4b0":"code","4192cbf5":"code","72386c2b":"markdown","1346fdf1":"markdown","47328d5e":"markdown","948e0b5d":"markdown","72007e4b":"markdown","13b6f18e":"markdown","d85a8641":"markdown","9c6e3e5b":"markdown","6e02078b":"markdown","55350a81":"markdown","175811ec":"markdown"},"source":{"3d1fee4b":"import json\n\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport tensorflow.keras.layers as L\nimport tensorflow as tf\nfrom sklearn.model_selection import train_test_split","6b853474":"tf.random.set_seed(2020)\nnp.random.seed(2020)","ba8623a3":"# This will tell us the columns we are predicting\npred_cols = ['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C', 'deg_pH10', 'deg_50C']","efadd4a6":"y_true = tf.random.normal((32, 68, 3))\ny_pred = tf.random.normal((32, 68, 3))","1be8e6de":"def MCRMSE(y_true, y_pred):\n    colwise_mse = tf.reduce_mean(tf.square(y_true - y_pred), axis=1)\n    return tf.reduce_mean(tf.sqrt(colwise_mse), axis=1)","5fc90869":"def gru_layer(hidden_dim, dropout):\n    return L.Bidirectional(L.GRU(\n        hidden_dim, dropout=dropout, return_sequences=True, kernel_initializer='orthogonal'))","ec189323":"def build_model(embed_size, seq_len=107, pred_len=68, dropout=0.5, \n                sp_dropout=0.2, embed_dim=200, hidden_dim=256, n_layers=3):\n    inputs = L.Input(shape=(seq_len, 3))\n    embed = L.Embedding(input_dim=embed_size, output_dim=embed_dim)(inputs)\n    \n    reshaped = tf.reshape(\n        embed, shape=(-1, embed.shape[1],  embed.shape[2] * embed.shape[3])\n    )\n    hidden = L.SpatialDropout1D(sp_dropout)(reshaped)\n    \n    for x in range(n_layers):\n        hidden = gru_layer(hidden_dim, dropout)(hidden)\n    \n    # Since we are only making predictions on the first part of each sequence, \n    # we have to truncate it\n    truncated = hidden[:, :pred_len]\n    out = L.Dense(5, activation='linear')(truncated)\n    \n    model = tf.keras.Model(inputs=inputs, outputs=out)\n    model.compile(tf.optimizers.Adam(), loss=MCRMSE)\n    \n    return model","fb38a353":"def pandas_list_to_array(df):\n    \"\"\"\n    Input: dataframe of shape (x, y), containing list of length l\n    Return: np.array of shape (x, l, y)\n    \"\"\"\n    \n    return np.transpose(\n        np.array(df.values.tolist()),\n        (0, 2, 1)\n    )","c93db802":"def preprocess_inputs(df, token2int, cols=['sequence', 'structure', 'predicted_loop_type']):\n    return pandas_list_to_array(\n        df[cols].applymap(lambda seq: [token2int[x] for x in seq])\n    )","e229e893":"data_dir = '\/kaggle\/input\/stanford-covid-vaccine\/'\ntrain = pd.read_json(data_dir + 'train.json', lines=True)\ntest = pd.read_json(data_dir + 'test.json', lines=True)\nsample_df = pd.read_csv(data_dir + 'sample_submission.csv')","08641072":"train = train.query(\"signal_to_noise >= 1\")","fb808f39":"# We will use this dictionary to map each character to an integer\n# so that it can be used as an input in keras\ntoken2int = {x:i for i, x in enumerate('().ACGUBEHIMSX')}\n\ntrain_inputs = preprocess_inputs(train, token2int)\ntrain_labels = pandas_list_to_array(train[pred_cols])","e20c5975":"x_train, x_val, y_train, y_val = train_test_split(\n    train_inputs, train_labels, test_size=.1, random_state=34, stratify=train.SN_filter)","7bd2e994":"public_df = test.query(\"seq_length == 107\")\nprivate_df = test.query(\"seq_length == 130\")\n\npublic_inputs = preprocess_inputs(public_df, token2int)\nprivate_inputs = preprocess_inputs(private_df, token2int)","40c94223":"model = build_model(embed_size=len(token2int))\nmodel.summary()","530ae61d":"history = model.fit(\n    x_train, y_train,\n    validation_data=(x_val, y_val),\n    batch_size=64,\n    epochs=75,\n    verbose=2,\n    callbacks=[\n        tf.keras.callbacks.ReduceLROnPlateau(patience=5),\n        tf.keras.callbacks.ModelCheckpoint('model.h5')\n    ]\n)","b54d2dc6":"fig = px.line(\n    history.history, y=['loss', 'val_loss'],\n    labels={'index': 'epoch', 'value': 'MCRMSE'}, \n    title='Training History')\nfig.show()","e56ff917":"# Caveat: The prediction format requires the output to be the same length as the input,\n# although it's not the case for the training data.\nmodel_public = build_model(seq_len=107, pred_len=107, embed_size=len(token2int))\nmodel_private = build_model(seq_len=130, pred_len=130, embed_size=len(token2int))\n\nmodel_public.load_weights('model.h5')\nmodel_private.load_weights('model.h5')","6d607516":"public_preds = model_public.predict(public_inputs)\nprivate_preds = model_private.predict(private_inputs)","8a91c4b0":"preds_ls = []\n\nfor df, preds in [(public_df, public_preds), (private_df, private_preds)]:\n    for i, uid in enumerate(df.id):\n        single_pred = preds[i]\n\n        single_df = pd.DataFrame(single_pred, columns=pred_cols)\n        single_df['id_seqpos'] = [f'{uid}_{x}' for x in range(single_df.shape[0])]\n\n        preds_ls.append(single_df)\n\npreds_df = pd.concat(preds_ls)\npreds_df.head()","4192cbf5":"submission = sample_df[['id_seqpos']].merge(preds_df, on=['id_seqpos'])\nsubmission.to_csv('submission.csv', index=False)","72386c2b":"## Load and preprocess data","1346fdf1":"## Load models and make predictions","47328d5e":"## Evaluate training history\n\nLet's use Plotly to quickly visualize the training and validation loss throughout the epochs.","948e0b5d":"## Build and train model\n\nWe will train a bi-directional GRU model. It has three layer and has dropout. To learn more about RNNs, LSTM and GRU, please see [this blog post](https:\/\/colah.github.io\/posts\/2015-08-Understanding-LSTMs\/).","72007e4b":"Public and private sets have different sequence lengths, so we will preprocess them separately and load models of different tensor shapes. This is possible because RNN models can accept sequences of varying lengths as inputs.","13b6f18e":"Public and private sets have different sequence lengths, so we will preprocess them separately and load models of different tensor shapes.","d85a8641":"This notebook shows you how to build a model for predicting degradation at various locations along RNA sequence. \n* We will first pre-process and tokenize the sequence, secondary structure and loop type. \n* Then, we will use all the information to train a model on degradations recorded by the researchers from OpenVaccine. \n* Finally, we run our model on the public test set (shorter sequences) and the private test set (longer sequences), and submit the predictions.\n\nFor more details, please see [this discussion post](https:\/\/www.kaggle.com\/c\/stanford-covid-vaccine\/discussion\/182303).\n\n---\n\nUpdates:\n\n* V7: Updated kernel initializer, embedding dimension, and added spatial dropout. Changed epochs and validation split. All based on [Tucker's excellent kernel](https:\/\/www.kaggle.com\/tuckerarrants\/openvaccine-gru-lstm#Training) (go give them an upvote!).\n* V8-9: Changed loss from MSE to M-MCRMSE, which is the official competition metric. See [this post](https:\/\/www.kaggle.com\/c\/stanford-covid-vaccine\/discussion\/183211) for more details. Changed number of epochs to 100.\n* V10: loss function: M-MCRMSE -> MCRMSE\n* V11: Filter `signal_to_noise` to be greater than 1, since the same was applied to private set. See [this post](https:\/\/www.kaggle.com\/c\/stanford-covid-vaccine\/discussion\/183992). \n* V12: Loss function: MCRMSE -> M-MCRMSE.\n* V13: Decrease and stratify validation set based on `SN_filter`. Increase embedding size, GRU dimensions, number of layers. All inspired from Tucker's work again.","9c6e3e5b":"## Post-processing and submit","6e02078b":"## Set seed to ensure reproducibility","55350a81":"## Helper functions and useful variables","175811ec":"For each sample, we take the predicted tensors of shape (107, 5) or (130, 5), and convert them to the long format (i.e. $629 \\times 107, 5$ or $3005 \\times 130, 5$):"}}