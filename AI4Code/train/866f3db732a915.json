{"cell_type":{"c659ea05":"code","e6b91455":"code","45f089d1":"code","85c7be7b":"code","31480329":"code","f7ec9cf4":"code","f8b9fd53":"code","9ac4e803":"markdown"},"source":{"c659ea05":"import gc\nimport pickle\nimport numpy as np\n\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import KFold\nfrom sklearn.preprocessing import StandardScaler\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\n\nimport ubiquant\n\ndevice_name = tf.test.gpu_device_name()\nif \"GPU\" not in device_name:\n    print(\"GPU device not found\")\nprint('Found GPU at: {}'.format(device_name))","e6b91455":"class GCF:\n    MODEL_ROOT = \"\/kaggle\/input\/k\/takamichitoda\/ump-train-1dcnn-on-tpu\"\n    SCALER_PATH = \"\/kaggle\/input\/ump-npy-dataset\/std_scaler.pkl\"\n    \n    N_FOLDS = 5\n    FEAT_COLS = [f\"f_{i}\" for i in range(300)]","45f089d1":"models = []\nfor fold in range(GCF.N_FOLDS):\n    model = tf.keras.models.load_model(f\"{GCF.MODEL_ROOT}\/ump_1dcnn_f{fold}.h5\", compile=False)\n    models.append(model)\nmodels[0].summary()","85c7be7b":"scaler = pickle.load(open(GCF.SCALER_PATH, \"rb\"))\nscaler","31480329":"def get_weighted(n):\n    w = []\n    for j in range(1, n + 1):\n        j = 2 if j == 1 else j\n        w.append(1 \/ (2**(n + 1 - j)))\n    return w","f7ec9cf4":"%%time\nenv = ubiquant.make_env()   # initialize the environment\niter_test = env.iter_test()    # an iterator which loops over the test set and sample submission\nfor (test_df, sample_prediction_df) in iter_test:\n    x = scaler.transform(test_df[GCF.FEAT_COLS].values)\n    \n    preds = []\n    for model in models:\n        with tf.device('\/GPU:0'):\n            pred = model.predict(x)\n        preds.append(pred)\n    #pred_avg = np.hstack(preds).mean(1)\n    #pred_avg = np.average(np.hstack(preds), weights=[1,1,1,3,4], axis=1)\n    pred_avg = np.average(np.hstack(preds), weights=get_weighted(5), axis=1)\n    \n    sample_prediction_df['target'] = pred_avg  # make your predictions here\n    env.predict(sample_prediction_df)   # register your predictions","f8b9fd53":"sample_prediction_df","9ac4e803":"# Infer 1DCNN\n\n\nThe training code is [here](https:\/\/www.kaggle.com\/takamichitoda\/ump-train-1dcnn-on-tpu), and standerd scaler model is [here](https:\/\/www.kaggle.com\/takamichitoda\/ump-npy-dataset).\n\n\n`update`\n\n- Version 7: baseline, CV=0.9105 \/ LB=0.135\n- Version 8: add dropout, CV=0.9101 \/ LB=0.132\n- Version 9: dropout ratio 0.2 -> 0.1, CV=0.9135 \/ LB=0.117\n- Version 10: dropout ratio 0.1 -> 0.4, CV=0.9142 \/ LB=0.124\n- Version 11: [MC dropout](https:\/\/arxiv.org\/pdf\/1506.02142.pdf), CV: 0.9142 \/ LB=0.125\n- Version 12: remove dropout & [add lag feature](https:\/\/www.kaggle.com\/takamichitoda\/ump-lag-freatures), CV=0.9046\n- Version 13: emove lag feature & use small batch, StratifiedKFold, ReduceLROnPlateau\n- Version 14: batch=4096, use correlationLoss\n- Version 15: use MSE loss, small model(param 1\/4)\n- Version 16: TimeSeriesSplit\n- Version 17: MC Dropout(0.75), large model\n- Version 19: MC Dropout(0.75), small model, correlationLoss\n- Version 20: use MC Dropout\n- Version 21: skip connect model\n- Version 22: skip connect model, only fold-4\n- Version 23: skip connect model, only fold-3\n- Version 24: skip connect model, only fold-2\n- Version 25: skip connect model, only fold-1\n- Version 26: skip connect model, only fold-0\n- Version 27: weight average\n- Version 28: early stopping correlationLoss\n- Version 29: weight average: https:\/\/www.kaggle.com\/c\/ubiquant-market-prediction\/discussion\/303916"}}