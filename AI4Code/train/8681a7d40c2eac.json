{"cell_type":{"6551b9dd":"code","7476d96b":"code","304b68d5":"code","a9b27c42":"code","1e2c4f9c":"code","7fc5c49a":"code","4657f2de":"code","3dd469dc":"code","955c239a":"code","2f0af29f":"code","835a7435":"code","907dcc24":"code","cc2ccf7c":"code","28aa07ef":"code","aabe1f07":"code","30fbd928":"code","ac485d2e":"code","ff8636dd":"markdown","3a51c7f9":"markdown","73093ee0":"markdown","3069ff07":"markdown","2d96c609":"markdown","55efc40f":"markdown","9b997933":"markdown","2e7fbb6c":"markdown","a2e33e42":"markdown","9bb441d1":"markdown","d0ea2b3c":"markdown","33d23253":"markdown","b49a777e":"markdown","2eac9dfa":"markdown","43a8c5c2":"markdown","84c737ee":"markdown","60e8c04f":"markdown","bb4476b2":"markdown","5fa3bcb1":"markdown","8eb90b59":"markdown","6adc1bb4":"markdown","866fda6f":"markdown"},"source":{"6551b9dd":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport cufflinks as cf\nfrom plotly.offline import download_plotlyjs, init_notebook_mode,plot,iplot\ninit_notebook_mode(connected = True)\ncf.go_offline()\n%matplotlib inline","7476d96b":"df = pd.read_csv('..\/input\/d\/maca11\/all-pokemon-dataset\/Pokemon.csv')\ndf.head()\n","304b68d5":"types = pd.unique(df['Type 1'])\n\nfinal_result = 1.0\ndf_replaced = df.replace(0,1) #We will consider that a inmunity doesn't affect the overall result\n\nfor i in types:\n    final_result = final_result * df_replaced['Against {}'.format(i)]\n \nfinal_result = np.array(final_result)","a9b27c42":"df.iloc[np.where(final_result == np.max(final_result))]","1e2c4f9c":"df.iloc[np.where(final_result == np.min(final_result[np.nonzero(final_result)]))]","7fc5c49a":"df1 = pd.DataFrame(df.groupby('Generation')['Type 1'].value_counts())\ndf1.columns = ['Count']\ndf1 = df1.reset_index()\ndf1.columns = ['Generation','Type','Count']\n\n\ndf2 = pd.DataFrame(df.groupby('Generation')['Type 2'].value_counts())\ndf2.columns = ['Count']\ndf2 = df2.reset_index()\ndf2.columns = ['Generation','Type','Count']\n\ndf2 = df2.set_index(['Generation','Type']).unstack().swaplevel(0,1,1).sort_index(1)\ndf1 = df1.set_index(['Generation','Type']).unstack().swaplevel(0,1,1).sort_index(1)\ndf_type_by_gen = pd.DataFrame(df2.add(df1, fill_value=0))\n\n\ndf_type_by_gen.fillna(value = 0, inplace = True)\n\nfig, ax = plt.subplots(figsize=(15,15))\nsns.heatmap(df_type_by_gen, annot = True, cmap = 'viridis')\nax.set_xlabel('Type')\nax.set_title('Number of Pokemon per generation', fontsize = 20)\nplt.show()\nplt.close()","4657f2de":"tc = df.groupby('Type 1')['Type 2'].value_counts().unstack('Type 2',  fill_value=0)\nfig, ax = plt.subplots(figsize=(15,15))\nsns.heatmap(tc, annot = True, cmap = 'RdBu_r')\nax.set_title('Number of Pokemon by Double Type', fontsize = 20)\nplt.show()\nplt.close()","3dd469dc":"total_types = tc + tc.transpose()\ntotal_types = total_types.fillna(0)\n\nmask = np.zeros_like(total_types)\nmask[np.triu_indices_from(mask)] = True\nwith sns.axes_style(\"white\"):\n    f, ax = plt.subplots(figsize=(15,15))\n    ax = sns.heatmap(total_types, mask=mask, annot = True, cmap = 'RdBu_r')\nax.set_title('Number of Pokemon by Double Type', fontsize = 20)\nplt.show()\nplt.close()","955c239a":"Ser1 = df[df['Legendary']==1]['Type 2'].value_counts() \nSer2 = df[df['Legendary']==1]['Type 1'].value_counts() \n\n\n\ndf_legend_types = pd.DataFrame(Ser1.add(Ser2, fill_value=0))\ndf_legend_types = df_legend_types.reset_index()\ndf_legend_types = df_legend_types.sort_values(by = 0, ascending = False)\ndf_legend_types.columns = ['Type', 'Count']\n\ndf_legend_types.iplot(kind = 'bar', x = 'Type',y = 'Count',title=\"Number of Legendaries by Type\")","2f0af29f":"pokemon_stats = df[(df['Final Evolution']==1)&(df['Legendary']==0)&(df['Mega Evolution']==0)][['HP', 'Att', 'Def', 'Spa', 'Spd', 'Spe']]\n\ng = sns.PairGrid(pokemon_stats)\ng.map(sns.regplot,scatter_kws = {'alpha': 0.5,'s':3})\nplt.show()\nplt.close()","835a7435":"Ser1 = df[(df['Final Evolution']==1)&(df['Mega Evolution']==0)&(df['Legendary']==0)].groupby('Type 1')['BST'].mean()\/2.0\nSer2 = df[(df['Final Evolution']==1)&(df['Mega Evolution']==0)&(df['Legendary']==0)].groupby('Type 2')['BST'].mean()\/2.0\n\n\ndf_meanBST_type = pd.DataFrame(Ser1.add(Ser2, fill_value=0))\n\ndf_meanBST_type = df_meanBST_type.reset_index()\ndf_meanBST_type.columns = ['Type', 'Mean BST']\ndf_meanBST_type= df_meanBST_type.sort_values(by = 'Mean BST', ascending = False)\n\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(15,10))\nsns.barplot(data = df_meanBST_type, x = 'Type', y = 'Mean BST' )\nax.set_title('Mean BST of non-legendary fully evolved pokemon by type')\nplt.show()\nplt.close()\n\n\ndf_meanBST_type","907dcc24":"labels=np.array(['HP','Sp.Atk','Sp. Def','Speed','Defense','Attack'])\nangles=np.linspace(0,2*np.pi, len(labels), endpoint=False)\nangles=np.concatenate((angles,[angles[0]]))\n\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, nrows = 3, ncols = 6, figsize=(25,25))\nfig.patch.set_facecolor('white')\ncounter = 0\nncols = 6\n\ncolors = {'Fire':'red', 'Water':'royalblue', 'Grass':'green','Poison':'darkviolet','Steel':'grey','Bug':'palegreen','Normal':'silver','Dark':'k','Electric':'yellow','Ground':'sandybrown','Rock':'saddlebrown','Ice':'aqua','Fairy':'fuchsia','Fighting':'lightsalmon','Psychic':'pink','Ghost':'darkslateblue','Dragon':'mediumslateblue','Flying':'paleturquoise'}\n\nfor i in df_meanBST_type.sort_values(by = 'Mean BST', ascending = False)['Type']:\n\n    type_df=df[((df['Type 1']==i) | ((df['Type 2'])==i)) & (df['Final Evolution']==1)&(df['Mega Evolution']==0)&(df['Legendary']==0)][['HP', 'Att', 'Def', 'Spa', 'Spd', 'Spe']]\n    type_mean_df = type_df.mean(axis = 0)\n\n    j =  counter % ncols\n    k = (counter-j) \/\/ ncols\n        \n    stats = [type_mean_df.values[0],type_mean_df.values[3],type_mean_df.values[4],type_mean_df.values[5],type_mean_df.values[2],type_mean_df.values[1]]\n    stats=np.concatenate((stats,[stats[0]]))\n        \n    ax[k,j].set_theta_zero_location(\"N\")\n    ax[k,j].plot(angles, stats, 'o-', linewidth=2,color = colors[i])\n    ax[k,j].fill(angles, stats, alpha=0.25, color = colors[i])\n    ax[k,j].set_rticks([0,20,40,60,80,100,120])\n    ax[k,j].set_rlabel_position(-90.0)\n    ax[k,j].set_thetagrids((angles * 180\/np.pi)[0:6], labels)\n    ax[k,j].set_title(i, fontweight='bold',fontsize= 15)\n    ax[k,j].grid(True)\n    ax[k,j].set_facecolor('white')\n    counter  = counter +1\n    plt.tight_layout()\n        \n        \n\nplt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.05, hspace=None)\nplt.tight_layout()\n\nplt.show()\nplt.close()","cc2ccf7c":"labels=np.array(['HP','Sp.Atk','Sp. Def','Speed','Defense','Attack'])\nangles=np.linspace(0,2*np.pi, len(labels), endpoint=False)\nangles=np.concatenate((angles,[angles[0]]))\n\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, nrows = 2, ncols = 4, figsize=(25,25))\nfig.patch.set_facecolor('white')\ncounter = 0\nncols = 4\n\n\n\nfor i in np.sort(df['Generation'].unique()):\n        generation_df=df[(df['Generation']==i) & (df['Final Evolution']==1)&(df['Legendary']==0)&(df['Mega Evolution']==0)][['HP', 'Att', 'Def', 'Spa', 'Spd', 'Spe']]\n        generation_mean_df = generation_df.mean(axis = 0)\n\n        j =  counter % ncols\n        k = (counter-j) \/\/ ncols\n        \n        \n        \n        stats = [generation_mean_df.values[0],generation_mean_df.values[3],generation_mean_df.values[4],generation_mean_df.values[5],generation_mean_df.values[2],generation_mean_df.values[1]]\n        \n        stats=np.concatenate((stats,[stats[0]]))\n        \n        ax[k,j].set_theta_zero_location(\"N\")\n        ax[k,j].plot(angles, stats, 'o-', linewidth=2)\n        ax[k,j].fill(angles, stats, alpha=0.25)\n        ax[k,j].set_rticks([0,20,40,60,80,100,120])\n        ax[k,j].set_rlabel_position(-90.0)\n        ax[k,j].set_thetagrids((angles * 180\/np.pi)[0:6], labels)\n        ax[k,j].set_title('Generation '+str(i), fontweight='bold',fontsize= 15)\n        ax[k,j].grid(True)\n        ax[k,j].set_facecolor('white')\n        counter  = counter +1\n        plt.tight_layout()\n        \n        \n\nplt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.05, hspace=None)\nplt.tight_layout()\n\nplt.show()\nplt.close()","28aa07ef":"from sklearn.linear_model import SGDClassifier, ElasticNet\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, classification_report, mean_absolute_error\nfrom sklearn.svm import LinearSVC","aabe1f07":"X = df[['HP', 'Att', 'Def', 'Spa', 'Spd','Spe', 'BST','Standard Deviation', 'Catch Rate']]\ny = df['Legendary']\n\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=32)\n\nclf = make_pipeline(StandardScaler(),LinearSVC(random_state=0, tol=1e-5,max_iter = 100000))\nclf.fit(X_train, y_train)\n\ny_pred = clf.predict(X_test)\n\nprint(confusion_matrix(y_test,y_pred))\n\nfig, ax = plt.subplots(figsize=(5,5))\nsns.heatmap(confusion_matrix(y_test,y_pred), annot = True, cmap = 'viridis',  fmt='g')\nax.set_ylabel('Real Values')\nax.set_xlabel('Predicted Values')\nax.set_title('Legendary confusion matrix')\nplt.show()\nplt.close()\nprint(classification_report(y_test, y_pred))","30fbd928":"X = df[['HP', 'Att', 'Def', 'Spa', 'Spd','Spe', 'BST','Standard Deviation']]\ny = df['Final Evolution']\n# Always scale the input. The most convenient way is to use a pipeline.\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=32)\n\nclf = make_pipeline(StandardScaler(),LinearSVC(random_state=0, tol=1e-5,max_iter = 100000))\nclf.fit(X_train, y_train)\n\ny_pred = clf.predict(X_test)\n\nprint(confusion_matrix(y_test,y_pred))\n\nfig, ax = plt.subplots(figsize=(5,5))\nsns.heatmap(confusion_matrix(y_test,y_pred), annot = True, cmap = 'viridis',  fmt='g')\nax.set_ylabel('Real Values')\nax.set_xlabel('Predicted Values')\nax.set_title('Final Evolution confusion matrix')\nplt.show()\nplt.close()\n\n\nprint(classification_report(y_test, y_pred))","ac485d2e":"fig, ax = plt.subplots(figsize=(8,24), ncols = 2, nrows = 6)\n\nagainst = []\nfor i in types:\n    against.append('Against {}'.format(i))\n\n\n\nstats = ['HP', 'Att', 'Def', 'Spa', 'Spd','Spe']\nX = df[['Catch Rate','Final Evolution','Legendary','Mega Evolution','Experience to level 100']+against]\n\nline = np.linspace(0,150,1000)\n\nfor i in range(6):\n    y = df[stats[i]]\n\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)\n\n    regr = make_pipeline(StandardScaler(),ElasticNet(random_state=4,tol=1e-2))\n    regr.fit(X_train, y_train)\n\n    y_pred = regr.predict(X_test)\n\n    print(stats[i], 'mean absolute error is',  mean_absolute_error(y_pred,y_test))\n\n    sns.histplot(y_pred-y_test, ax = ax[i,0], element=\"step\", fill=False, label = stats[i])\n    ax[i,0].set_xlim(-51,51)\n    ax[i,0].set_ylim(0,60)\n    ax[i,0].axvline(x = 0, color = 'red')\n    ax[i,0].set_xlabel('Error {}'.format(stats[i]))\n\n    ax[i,1].plot(line,line, color = 'red', linewidth=0.5)  \n    ax[i,1].scatter(y_test, y_pred, s = 7,color = 'c', edgecolor = 'b', linewidth = 0.5, marker = \"o\")\n    ax[i,1].set_xlim(0,150)\n    ax[i,1].set_ylim(0,150)\n    ax[i,1].set_xlabel('Real {}'.format(stats[i]))\n    ax[i,1].set_ylabel('Predicted {}'.format(stats[i]))\n    \n    \nplt.subplots_adjust(hspace=.4, wspace = 0.4)\nplt.show()\nplt.close()","ff8636dd":"This plot is ordered by mean BST. We clearly see that in general Dragon Pokemons have the higher stats.\n\nAs an example, the fastest Pokemon types are Flying and Electric, while the slowest is Rock.","3a51c7f9":"# Count of Pokemons by Generations by Type\n\nEach generation add diferent number of Pokemons with different types. In this count we have to take into account the primary and the secondary typing, since a pokemon is of a certain type independently if it is in the primary or the sencondary typing.\n\nWe need to group the typings by Generations and add them. Then we can visualize it perfectly in a heatmap.","73093ee0":"# Legendary Pokemons by Type\n\nIn this section we will see which type is the most common amongst Legendary Pokemons. We will have to group typings by legendary and count them. ","3069ff07":"# Relationship between stats\n\nIs there any relationship between stats? For example, the higher the base attack the higher is the defense?","2d96c609":"# Predicting Final Evolution\n\nAs with Legendary Pokemons, final evolutions tend to have higher base statistics than non evolved pokemons. It is the exact same problem as before, hence we are using the exact same algorithm.\n","55efc40f":"# Count of Pokemon by Double Type\n\nSome Pokemons have dual typing such as Bug-Water.In this section we will see which double type is the most common.\nIn this plot we are considering that Primary and Secondary types are't exchangable, which means that a Bug-Water Pokemon doesn't count as a Water-Bug Pokemon.\n","9b997933":"We can do the same but instead of comparing by Type comparing by Generation","2e7fbb6c":"# Type Weaknesses\n\nThe Against_{} columns tell us the efectiveness of a type against a certain Pokemon. Hence each combination of types has certain weaknesses or resistances. We will respond which Pokemon combination of types has the most weaknesses? And the most resistances?\n\nTo answer this questions we can multiply all the Against_{} columns and check the maximum and the minimum values.","a2e33e42":"The model in general is very satisfactory, being the worst value a $0.83$ recall for the Legendary Pokemons, meaning that the model usually detects legendary pokemons as non-legendary. However for the true non-legendary pokemons it achieves really high precision and recall. The main reason it achieves such a high recall for the Legendary Pokemons is the catch rate, if we remove it and we only train the model using the base stats it drops to $0.5$. ","9bb441d1":"As well as before the model is satisfactory. Using only base stats we can predict if a Pokemon is a final evolution or not with high accuracy.","d0ea2b3c":"The mean absolute error for each stat is too high to predict them accurately. For example for a Pokemon with a base HP of $80$, a mean absolute error of $14.45$ would represent an error of $20\\%$ which is too high. ","33d23253":"The Pokemon with the most weaknesses is the one with the maximum efectiveness multiplyer, and the one with less weaknesses has the minimum efectiveness multiplyer","b49a777e":"# Which Type is the best?\n\nWe can measure how good is a typing by the BST. To do so we can calculate the mean BST of each Type. We will need to group by Type 1 and Type 2 and get the mean BST. Then, as it doesn't matter if it a type is primary or secondary we will add this values. I won't take into account Megas and Legendaries in this study because they bias a lot the results. There are $36$ legendary Psychic pokemons while only $3$ Bug legendary pokemons, hence it is more fair to don't take them into account.","2eac9dfa":"If we suppose that primary and secondary type are exchangable, for example a Water-Rock Pokemon counts also as a Rock-Water, the plot transforms to this one:","43a8c5c2":"Instead of only using the BST to compare types we can use all their mean base stats. To do it we have to group by typings and get the mean values of each stat. We will visualize it as in the Pokemon games, in an hexagon grid.","84c737ee":"In this Notebook we are going to explore some Pokemon data such as number of legendary pokemons by type, number of pokemons by double type, etc. Then we will try to predict if a pokemon is legendary or final evolution using machine learning.","60e8c04f":"# Predicting Base Stats\n\nThis is a harder problem, we will try to predict each base stat using the Catch rate, the experience it takes the pokemon to reach level 100, their weaknesses, etc. Since we are trying to predict a quantity we have a regression problem, we have a lot of features that can be important, so we are using a Elastic Net. ","bb4476b2":"# Machine Learning with Pokemon\n\nIn this section we will use Machine Learning to predict predict if a Pokemon is Legendary with their stats to predict, or to predict if it is a final evolution. Finally we will try to predict a Pokemon stats.","5fa3bcb1":"The best type is Dragon followed by Fire, while the worst typing is Normal","8eb90b59":"# Predicting Legendary\n\nWe will create a model to predict if a Pokemon is Legendary or not. Typically Legendary Pokemons have really high stats and a low catch rate, hence we will use them in our model. Data will be separed in training and test sets. Since we have access to the legendary labels this is a supervised classification problem, hence we use a Linear Support Vector Classification model. ","6adc1bb4":"We can see that in Generation 1 there aren't Dark Type Pokemons and only two steel types. That's because the dark and steel types were introduced in Generation 2.\n\nSomething similar happens with Fairys in Generations 4 and 5. This is because Fairy type was introduced in Generation 6.\n","866fda6f":"The most repeated double type is Normal-Flying, and there is a lot of double types that we haven't seen yet, for example Dragon-Bug or Fire-Fairy."}}