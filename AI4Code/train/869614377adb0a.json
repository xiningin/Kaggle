{"cell_type":{"7f04cb61":"code","60350533":"code","53d56a94":"code","69f23b4e":"code","ebda0702":"code","37154402":"code","221f9499":"code","a5f383b9":"code","a414a19d":"code","8d4070d4":"code","73864107":"markdown","ac1d667d":"markdown","95a62615":"markdown","03ae35ec":"markdown","ca415e3f":"markdown","566d7f60":"markdown"},"source":{"7f04cb61":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport sklearn.cluster as cls\nfrom sklearn.decomposition import PCA\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","60350533":"members = pd.read_csv(\"..\/input\/house-of-representatives-congress-116\/house_members_116.csv\", index_col=\"name_id\")\nattendance = pd.read_csv(\"..\/input\/house-of-representatives-congress-116\/house_rollcall_info_116.csv\")\nvotes = pd.read_csv(\"..\/input\/house-of-representatives-congress-116\/house_rollcall_votes_116.csv\", index_col=\"name_id\")\n\ndef summarize(df):\n    print(\"Columns:\")\n    print(df.columns)\n    print(\"\\n\\n\\n\\n\\nFirst 5 entries:\")\n    print(df.head())\n    print(\"\\n\\n\\n\\n\\nDescriptive Stats:\")\n    print(df.describe())\n    print(\"\\n\\n\\n\\n\\nMissing Info:\")\n    print(df.info())","53d56a94":"summarize(members)","69f23b4e":"summarize(attendance)","ebda0702":"summarize(votes)","37154402":"attendance = attendance[['rollcall_id', 'bill_id']].dropna()\n\nimport re\np = re.compile(\"[HS].((R.)|(j.res.))?[0-9]*.$\",re.IGNORECASE)\nattendance = attendance[attendance[\"bill_id\"].apply(lambda x: pd.notnull(p.match(x)))]\nprint(attendance.head())","221f9499":"print(votes.head())\n\nvotes = votes[attendance[\"rollcall_id\"]] # filter out the votes on non-law things\n\n# What are all the unique terms for voting? We need to convert strings to booleans\nls = []\nfor col in votes.columns:\n    ls += list(pd.unique(votes[col]))\nls = pd.unique(ls)\nprint(ls)\n\n\n# turn strings to booleans\ndef simplify_strings(x):\n    votes_to_bool = {1: [\"Aye\", \"Yea\"], -1: [\"No\", \"Nay\"], 0:[np.nan, \"Not Voting\", \"Present\"]}\n    for key, ls in votes_to_bool.items():\n        if x in ls:\n            return key\n\nfor col in votes.columns:\n    votes[col] = votes[col].apply(simplify_strings)","a5f383b9":"votes","a414a19d":"pca = PCA()\npca_votes = pca.fit_transform(votes)\n#print(pca_votes.shape)\n#print(votes.shape)\npca_votes = pd.DataFrame(pca_votes[:,:2], index = votes.index)\n\nsns.set_style(\"darkgrid\")\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize = (15,15))\nsns.lineplot(data = np.cumsum(pca.explained_variance_ratio_), ax=ax1)\nsns.scatterplot(x=pca_votes[0], y=pca_votes[1], ax=ax2)#, hue = members.loc[pca_votes.index, \"current_party\"])\n\nax1.set_title(\"cumulative explained variance\")\nax2.set_title(\"politician location on first two principal components\")\nfig.show()\n","8d4070d4":"from bokeh.io import output_notebook, show\nfrom bokeh.plotting import figure\nfrom bokeh.models.tools import HoverTool\nfrom bokeh.models import ColumnDataSource\n\noutput_notebook()\n# Basic plot setup\np = figure(width=1200, height=600, title='Politicians in voting space')\n\na = ColumnDataSource.from_df(pca_votes) # dictionary of arrays {colname:np.array(colvals)}, includes index\na[\"0\"] = a[0]\na['1'] = a[1]\ndel a[0]\ndel a[1]\na['current_party'] = np.array(members.loc[votes.index, \"current_party\"])\na['name']  = np.array(members.loc[votes.index, \"name\"])\na['state'] = np.array(members.loc[votes.index, \"state\"])\ncolors = {\"Republican\": \"firebrick\", \"Democratic\":\"navy\", \"Independent\": \"green\"}\na['color'] = np.array([colors[i] for i in members.loc[votes.index, \"current_party\"]])\n\nTOOLTIPS = [\n    (\"name\", \"@name\"),\n    (\"state\", \"@state\"),\n    (\"party\", \"@current_party\")\n]\ncr = p.circle(x=\"0\", y=\"1\", radius=0.3,\n              hover_fill_color=\"cyan\",\n              fill_alpha=0.8, hover_alpha=0.8, fill_color='color',\n              line_color=\"white\", hover_line_color=\"white\", source=a)\n\np.add_tools(HoverTool(tooltips=TOOLTIPS, renderers=[cr]))\n\nshow(p)","73864107":"# 2. Cleaning\nOkay, since we've now got basic summaries of each of the files we're concerned about, we can start cleaning. This will involve removing unneeded columns, changing votes to numbers, and removing the votes on bills that are not legally impactful.","ac1d667d":"## Procedural votes removed\n# 3. Dimension Reduction and Analysis\nThis leaves us with about 500 recorded votes that have legal impact. However, many of these are uncontroversial, and generally agreed upon. So they are essentially noise. To get to the deeper patterns, I want to focus on which attributes most strongly put representatives into clusters, which suggests a PCA for dimensionality reduction. This also has the benefit of making the information easier to visualize, by compressing the information into as few dimensions as possible.","95a62615":"# How do members of congress tend to vote in relation to each other?\n### I'm hoping to see how similar individual house members votes' tend to be.\nThere's a good chance that I'll see two major groupings, since politically, votes tend to be distributed along party lines. But more than that, I want to be able to connect names to other names. If Representative 1 votes yes, does that imply that Representative 2 will also vote yes?\n\nThe original thought was to use clustering methods, but I wanted to get more granular than that. And after visualizing the data, it was clear that there were only two obvious clusters, clearly delineated by political party. Instead, I went for an interactive display that shows name, party, and state for each representative in the voting space. Before constructing this, I want to ensure that the data is cleaned, and that the votes being analyzed are those that have legal impact. This means removing many of the votes, since many of those are on day to day procedural events. ","03ae35ec":"It's worth noting that the remaining (unvisualized) dimesions from the PCA still contain a fair amount of information, which could concievably be used to cluster the politicians more granularly, but I view that as unlikely, since per the definition of a PCA, they have less variance than the two shown.","ca415e3f":"The above plot suggests that the members of the 116th house of representatives of congress vote very closely along party lines. However, there are some outliers from the clusters, particularly Nancy Pelosi, Tom Marino, Walter Jones, Dan Bishop, Gregory Murphy, and Brian Fitzpatrick, who appear more willing to compromise, and\/or have more moderate views. It appears that the Republican party votes are more diverse than those of the Democratic party. However, one should be very cautious about reading into that, since the axes do not have clear meaning, due to the difficulty in interpreting the bills that were being voted on, and the information compression from the PCA.","566d7f60":"# 1. Files overview"}}