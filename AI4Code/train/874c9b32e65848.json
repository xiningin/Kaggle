{"cell_type":{"54274b02":"code","b926b812":"code","6691700e":"code","ba0ef0d5":"code","b1a3053b":"code","04f9c071":"code","c1d37235":"code","65d21076":"code","74a415b2":"code","2197ba62":"code","99a057c4":"code","a7763c70":"code","9a45fa9f":"code","90c68a15":"code","c7e994fc":"code","2ca998aa":"code","92bf2585":"code","f8e4cbea":"code","9572dbc3":"markdown","019d80c4":"markdown","1d0946eb":"markdown","c185ceed":"markdown","45fac6d5":"markdown","a0e31ac3":"markdown","71e3c9ba":"markdown","24524e16":"markdown","1c97c6f2":"markdown","c5b11ae6":"markdown","1c66d430":"markdown","b3827e8c":"markdown","2d2a12a9":"markdown"},"source":{"54274b02":"import numpy as np \nimport pandas as pd\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split","b926b812":"train = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-aug-2021\/train.csv\")\ntest = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-aug-2021\/test.csv\")","6691700e":"train.head()","ba0ef0d5":"train.shape","b1a3053b":"train.describe().transpose()","04f9c071":"corr_score = train.corr()","c1d37235":"corr_score[\"loss\"].sort_values(ascending=False)","65d21076":"train.pop(\"id\")\ntest_ids = test.pop(\"id\")","74a415b2":"train_mean = train.mean()\ntrain_std = train.std()","2197ba62":"train_targets_mean = train_mean.pop(\"loss\")\ntrain_targets_std = train_std.pop(\"loss\")","99a057c4":"validation_split = 0.2","a7763c70":"train_features, validation_features = train_test_split(train, test_size=validation_split)","9a45fa9f":"train_targets, validation_targets = train_features.pop(\"loss\"),  validation_features.pop(\"loss\")","90c68a15":"should_scale = True\nif should_scale == True:\n    train_features = (train_features - train_mean) \/ train_std\n    validation_features = (validation_features - train_mean) \/ train_std\n    test_features = (test - train_mean) \/ train_std\n    print(test_features.head())\n    print(train_features.head())\n    print(validation_features.head())","c7e994fc":"early_stop = tf.keras.callbacks.EarlyStopping(patience=5)\ncheckpoint_path = \"model.h5\"\ncheckpoint = tf.keras.callbacks.ModelCheckpoint(checkpoint_path, monitor=\"val_rmse\", mode=\"min\", save_best_only=True)\nrmse = tf.keras.metrics.RootMeanSquaredError(name=\"rmse\")\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Input((train_features.shape[-1])),\n    tf.keras.layers.Dense(32, activation=\"elu\"),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(32, activation=\"elu\"),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(32, activation=\"elu\"),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(1, activation=\"elu\")\n])\nmodel.compile(loss=\"mse\", optimizer=\"adam\", metrics=[\"mae\", rmse])\nhistory = model.fit(train_features, train_targets, epochs=100, batch_size=1000, validation_data=(validation_features, validation_targets), callbacks=[early_stop, checkpoint])","2ca998aa":"for key in [\"loss\", \"rmse\", \"mae\"]:\n    pd.DataFrame(history.history, columns=[key, \"val_\" + key]).plot()\n    plt.show()","92bf2585":"model.load_weights(checkpoint_path)\nloss_pred = model.predict(test_features)\nprint(loss_pred[:10])","f8e4cbea":"submission = pd.DataFrame({\"id\": test_ids, \"loss\": loss_pred.reshape(-1)})\nsubmission.to_csv(\"submission.csv\", index=False)","9572dbc3":"## EDA","019d80c4":"# Tabular Playground Series Prediction","1d0946eb":"There isn't an obvious correlation between features and target values.","c185ceed":"### Train Validation Split","45fac6d5":"## Load datasets","a0e31ac3":"## Drop id column","71e3c9ba":"#### Loss and Accuracy over time","24524e16":"## Data Preprocessing","1c97c6f2":"### Submission","c5b11ae6":"## Model Development\n### Using DNN","1c66d430":"### Model Evaluation","b3827e8c":"### Data Scaling","2d2a12a9":"## Import Packages"}}