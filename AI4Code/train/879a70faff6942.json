{"cell_type":{"f91d264d":"code","1a0bb66f":"code","0b02ddfd":"code","1551018d":"code","d832a82b":"code","5781e52b":"code","ed152055":"code","b36642bd":"code","d7bc89bf":"code","fb17fefb":"code","66018232":"code","4e9bbc54":"code","1fcf0cdc":"code","7c3119a7":"code","552458aa":"code","f6b8419e":"code","d2ac59c5":"code","b3467a4e":"markdown","44b10159":"markdown","02bb80da":"markdown","03622df1":"markdown","bac80dd7":"markdown","b9320add":"markdown","332673ec":"markdown","22052f4f":"markdown","2d6b69a5":"markdown","42721693":"markdown","9f3c5f80":"markdown","90935156":"markdown"},"source":{"f91d264d":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom dataclasses import dataclass\n\nimport matplotlib.pyplot as plt # visualization\nplt.rcParams.update({'font.size': 14})\nimport seaborn as sns # visualization\n\nimport warnings # Supress warnings \nwarnings.filterwarnings('ignore')\n\nfrom tqdm import tqdm\n\nimport json\nimport plotly.graph_objs as go\nfrom PIL import Image","1a0bb66f":"!head -n 15 \"..\/input\/indoor-location-navigation\/train\/5a0546857ecc773753327266\/F2\/5dccf516c04f060006e6e3c9.txt\"","0b02ddfd":"# copy from https:\/\/github.com\/location-competition\/indoor-location-competition-20\/blob\/master\/io_f.py\n\n@dataclass\nclass ReadData:\n    acce: np.ndarray\n    acce_uncali: np.ndarray\n    gyro: np.ndarray\n    gyro_uncali: np.ndarray\n    magn: np.ndarray\n    magn_uncali: np.ndarray\n    ahrs: np.ndarray\n    wifi: np.ndarray\n    ibeacon: np.ndarray\n    waypoint: np.ndarray\n\n\ndef read_data_file(data_filename):\n    acce = []\n    acce_uncali = []\n    gyro = []\n    gyro_uncali = []\n    magn = []\n    magn_uncali = []\n    ahrs = []\n    wifi = []\n    ibeacon = []\n    waypoint = []\n\n    with open(data_filename, 'r', encoding='utf-8') as file:\n        lines = file.readlines()\n\n    for line_data in lines:\n        line_data = line_data.strip()\n        if not line_data or line_data[0] == '#':\n            continue\n\n        line_data = line_data.split('\\t')\n\n        if line_data[1] == 'TYPE_WAYPOINT':\n            waypoint.append([int(line_data[0]), float(line_data[2]), float(line_data[3])])\n            continue\n       \n        if line_data[1] == 'TYPE_ACCELEROMETER':\n            acce.append([int(line_data[0]), float(line_data[2]), float(line_data[3]), float(line_data[4])])\n            continue\n        \n        if line_data[1] == 'TYPE_ACCELEROMETER_UNCALIBRATED':\n            acce_uncali.append([int(line_data[0]), float(line_data[2]), float(line_data[3]), float(line_data[4])])\n            continue\n        \n        if line_data[1] == 'TYPE_GYROSCOPE':\n            gyro.append([int(line_data[0]), float(line_data[2]), float(line_data[3]), float(line_data[4])])\n            continue\n\n        if line_data[1] == 'TYPE_GYROSCOPE_UNCALIBRATED':\n            gyro_uncali.append([int(line_data[0]), float(line_data[2]), float(line_data[3]), float(line_data[4])])\n            continue\n        \n        if line_data[1] == 'TYPE_MAGNETIC_FIELD':\n            magn.append([int(line_data[0]), float(line_data[2]), float(line_data[3]), float(line_data[4])])\n            continue\n\n        if line_data[1] == 'TYPE_MAGNETIC_FIELD_UNCALIBRATED':\n            magn_uncali.append([int(line_data[0]), float(line_data[2]), float(line_data[3]), float(line_data[4])])\n            continue\n\n        if line_data[1] == 'TYPE_ROTATION_VECTOR':\n            ahrs.append([int(line_data[0]), float(line_data[2]), float(line_data[3]), float(line_data[4])])\n            continue\n\n        if line_data[1] == 'TYPE_WIFI':\n            sys_ts = line_data[0]\n            ssid = line_data[2]\n            bssid = line_data[3]\n            rssi = line_data[4]\n            lastseen_ts = line_data[6]\n            wifi_data = [sys_ts, ssid, bssid, rssi, lastseen_ts]\n            wifi.append(wifi_data)\n            continue\n\n        if line_data[1] == 'TYPE_BEACON':\n            ts = line_data[0]\n            uuid = line_data[2]\n            major = line_data[3]\n            minor = line_data[4]\n            rssi = line_data[6]\n            ibeacon_data = [ts, '_'.join([uuid, major, minor]), rssi]\n            ibeacon.append(ibeacon_data)\n            continue\n        \n    \n    acce = np.array(acce)\n    acce_uncali = np.array(acce_uncali)\n    gyro = np.array(gyro)\n    gyro_uncali = np.array(gyro_uncali)\n    magn = np.array(magn)\n    magn_uncali = np.array(magn_uncali)\n    ahrs = np.array(ahrs)\n    wifi = np.array(wifi)\n    ibeacon = np.array(ibeacon)\n    waypoint = np.array(waypoint)\n    \n    return ReadData(acce, acce_uncali, gyro, gyro_uncali, magn, magn_uncali, ahrs, wifi, ibeacon, waypoint)\n\nsample_file = read_data_file(\"..\/input\/indoor-location-navigation\/train\/5a0546857ecc773753327266\/F2\/5dccf516c04f060006e6e3c9.txt\")\n\nprint('acce shape:', sample_file.acce.shape)\nprint('acce_uncali shape:', sample_file.acce_uncali.shape)\nprint('gyro shape:', sample_file.gyro.shape)\nprint('gyro_uncali shape:', sample_file.gyro_uncali.shape)\nprint('magn shape:', sample_file.magn.shape)\nprint('magn_uncali shape:',sample_file.magn_uncali.shape)\nprint('ahrs shape:', sample_file.ahrs.shape)\nprint('wifi shape:', sample_file.wifi.shape)\nprint('ibeacon shape:', sample_file.ibeacon.shape)\nprint('waypoint shape:', sample_file.waypoint.shape)","1551018d":"from datetime import datetime\nstart_time = 1573713056850\nend_time = 1573713091483\n\nprint(datetime.fromtimestamp(start_time\/1000.0))\nprint(datetime.fromtimestamp(end_time\/1000.0))\nprint(datetime.fromtimestamp(end_time\/1000.0)-datetime.fromtimestamp(start_time\/1000.0))","d832a82b":"waypoint_df = pd.DataFrame(sample_file.waypoint)\nwaypoint_df.columns = ['timestamp', 'waypoint_x','waypoint_y']\ndisplay(waypoint_df.style.set_caption('Waypoint'))","5781e52b":"def visualize_trajectory(trajectory, floor_plan_filename, width_meter, height_meter, title=None, mode='lines + markers + text', show=False):\n    \"\"\"\n    Copied from from https:\/\/github.com\/location-competition\/indoor-location-competition-20\/blob\/master\/visualize_f.py\n\n    \"\"\"\n    fig = go.Figure()\n\n    # add trajectory\n    size_list = [6] * trajectory.shape[0]\n    size_list[0] = 10\n    size_list[-1] = 10\n\n    color_list = ['rgba(4, 174, 4, 0.5)'] * trajectory.shape[0]\n    color_list[0] = 'rgba(12, 5, 235, 1)'\n    color_list[-1] = 'rgba(235, 5, 5, 1)'\n\n    position_count = {}\n    text_list = []\n    for i in range(trajectory.shape[0]):\n        if str(trajectory[i]) in position_count:\n            position_count[str(trajectory[i])] += 1\n        else:\n            position_count[str(trajectory[i])] = 0\n        text_list.append('        ' * position_count[str(trajectory[i])] + f'{i}')\n    text_list[0] = 'Start 0'\n    text_list[-1] = f'End {trajectory.shape[0] - 1}'\n\n    fig.add_trace(\n        go.Scattergl(\n            x=trajectory[:, 0],\n            y=trajectory[:, 1],\n            mode=mode,\n            marker=dict(size=size_list, color=color_list),\n            line=dict(shape='linear', color='lightgrey', width=3, dash='dash'),\n            text=text_list,\n            textposition=\"top center\",\n            name='trajectory',\n        ))\n\n    # add floor plan\n    floor_plan = Image.open(floor_plan_filename)\n    fig.update_layout(images=[\n        go.layout.Image(\n            source=floor_plan,\n            xref=\"x\",\n            yref=\"y\",\n            x=0,\n            y=height_meter,\n            sizex=width_meter,\n            sizey=height_meter,\n            sizing=\"contain\",\n            opacity=1,\n            layer=\"below\",\n        )\n    ])\n\n    # configure\n    fig.update_xaxes(autorange=False, range=[0, width_meter])\n    fig.update_yaxes(autorange=False, range=[0, height_meter], scaleanchor=\"x\", scaleratio=1)\n    fig.update_layout(\n        title=go.layout.Title(\n            text=title or \"No title.\",\n            xref=\"paper\",\n            x=0,\n        ),\n        autosize=True,\n        width=800,\n        height=  800 * height_meter \/ width_meter,\n        template=\"plotly_white\",\n    )\n\n    if show:\n        fig.show()\n\n    return fig\n\ndef visualize_train_trajectory(path):\n    \"\"\"\n    Edited from \n    https:\/\/www.kaggle.com\/ihelon\/indoor-location-exploratory-data-analysis\n    \"\"\"\n    _id, floor = path.split(\"\/\")[:2]\n    \n    train_floor_data = read_data_file(f\"..\/input\/indoor-location-navigation\/train\/{path}\")\n    with open(f\"..\/input\/indoor-location-navigation\/metadata\/{_id}\/{floor}\/floor_info.json\") as f:\n        train_floor_info = json.load(f)\n\n    return visualize_trajectory(\n        train_floor_data.waypoint[:, 1:3], \n        f\"..\/input\/indoor-location-navigation\/metadata\/{_id}\/{floor}\/floor_image.png\",\n        train_floor_info[\"map_info\"][\"width\"], \n        train_floor_info[\"map_info\"][\"height\"],\n        f\"Visualization of {path}\"\n    )\n#visualize_train_trajectory(\"5a0546857ecc773753327266\/F2\/5d8f094bd5bae80006eb8db0.txt\")\n#visualize_train_trajectory(\"5a0546857ecc773753327266\/F2\/5d8f094bb6e29d0006fb8c03.txt\")\n#visualize_train_trajectory(\"5a0546857ecc773753327266\/F2\/5dccf511c04f060006e6e3c6.txt\")\nvisualize_train_trajectory(\"5a0546857ecc773753327266\/F2\/5dccf516c04f060006e6e3c9.txt\")\n\n","ed152055":"temp = np.concatenate([sample_file.acce, \n                       sample_file.acce_uncali[:, 1:],\n                       sample_file.gyro[:, 1:],\n                       sample_file.gyro_uncali[:, 1:],\n                       sample_file.magn[:, 1:],\n                       sample_file.magn_uncali[:, 1:],\n                       sample_file.ahrs[:, 1:],\n                      ], axis=1)\n\nimu_df = pd.DataFrame(temp)\n\nimu_df.columns = ['timestamp', 'acce_x','acce_y', 'acce_z','acce_uncali_x','acce_uncali_y', 'acce_uncali_z',\n              'gyro_x','gyro_y', 'gyro_z','gyro_uncali_x','gyro_uncali_y', 'gyro_uncali_z',\n              'magn_x','magn_y', 'magn_z','magn_uncali_x','magn_uncali_y', 'magn_uncali_z',\n              'ahrs_x','ahrs_y', 'ahrs_z']\n\ndisplay(imu_df.head(8).style.set_caption('IMU Data'))","b36642bd":"def plot_imu_signals(col, uncali = True):\n    fig, ax = plt.subplots(nrows=3, ncols=1, figsize=(14, 9))\n    ax[0].set_ylabel(f\"{col}_x\")\n    ax[1].set_ylabel(f\"{col}_y\")\n    ax[2].set_ylabel(f\"{col}_z\")\n    if uncali:\n        sns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_uncali_x\"], ax=ax[0], label = 'uncali', color='orange')\n        sns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_uncali_y\"], ax=ax[1], label = 'uncali', color='orange')\n        sns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_uncali_z\"], ax=ax[2], label = 'uncali', color='orange')\n        ax[0].set_ylabel(f\"{col}_x \\n(calib.\/uncalib.)\")\n        ax[1].set_ylabel(f\"{col}_y \\n(calib.\/uncalib.)\")\n        ax[2].set_ylabel(f\"{col}_z \\n(calib.\/uncalib.)\")\n    \n    sns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_x\"], ax=ax[0], label='cali', color='cornflowerblue')\n    sns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_y\"], ax=ax[1], label='cali', color='cornflowerblue')\n    sns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_z\"], ax=ax[2], label='cali', color='cornflowerblue')\n\n    for i in range(3):\n        ax[i].set_xlim([start_time, end_time])\n    plt.tight_layout()\n    plt.show()\n    \nplot_imu_signals('acce')\n    \n","d7bc89bf":"imu_df.acce_z.mean()","fb17fefb":"# > Therefore, to measure the real acceleration of the device, the contribution of the force of gravity must be removed from the accelerometer data. \n# This can be achieved by applying a high-pass filter. Conversely, a low-pass filter can be used to isolate the force of gravity. \n# The following example shows how you can do this -[Android Developer Docs: Motion Sensors](https:\/\/developer.android.com\/guide\/topics\/sensors\/sensors_motion#java)\n\n# In this example, alpha is calculated as t \/ (t + dT),\n# where t is the low-pass filter's time-constant and\n# dT is the event delivery rate.\n\nalpha = 0.8;\n\nimu_df['g_x'] = 0\nimu_df['g_y'] = 0\nimu_df['g_z'] = 9.81\n\n# Isolate the force of gravity with the low-pass filter.\nimu_df['g_x'] = alpha * imu_df['g_x'] + (1 - alpha) * imu_df['acce_x'];\nimu_df['g_y'] = alpha * imu_df['g_y'] + (1 - alpha) * imu_df['acce_y'];\nimu_df['g_z'] = alpha * imu_df['g_z']  + (1 - alpha) * imu_df['acce_z'];\n\n# Remove the gravity contribution with the high-pass filter.\nimu_df['lin_acce_x'] = imu_df['acce_x'] - imu_df['g_x'];\nimu_df['lin_acce_y'] = imu_df['acce_y'] - imu_df['g_y'];\nimu_df['lin_acce_z'] = imu_df['acce_z'] - imu_df['g_z'];\n\n#imu_df['lin_acce_y'].iloc[0]\nfig, ax = plt.subplots(nrows=1, ncols=1, figsize=(14, 3))\n\nsns.lineplot(x=imu_df.timestamp, y=imu_df[\"acce_x\"], label = 'orgi')\nsns.lineplot(x=imu_df.timestamp, y=imu_df[\"lin_acce_x\"], label='lin')\nsns.lineplot(x=imu_df.timestamp, y=imu_df[\"g_x\"], label='grav')\nplt.show()","66018232":"def calc_from_pos(timestamp, pos):\n    df = pd.DataFrame({'timestamp' : timestamp, 'position' : pos})\n    df['timestamp_ms'] = df['timestamp'].apply(lambda x: datetime.fromtimestamp(x\/1000.0))\n    df['timedelta_ms'] = df['timestamp_ms'].diff()\n    df['timedelta_s'] = df['timedelta_ms'].apply(lambda x: x.total_seconds()).fillna(0)\n    df['velocity'] = (df['position'].diff() \/ df['timedelta_s']).fillna(0)\n    df['acceleration'] = (df['velocity'].diff() \/ df['timedelta_s']).fillna(0)\n\n    return df[['timestamp', 'timestamp_ms', 'timedelta_s', 'position', 'velocity', 'acceleration']]\n\ndef calc_from_acce(timestamp, acce, p_0):\n    df = pd.DataFrame({'timestamp' : timestamp, 'acceleration' : acce})\n    df['timestamp_ms'] = df['timestamp'].apply(lambda x: datetime.fromtimestamp(x\/1000.0))\n    df['timedelta_ms'] = df['timestamp_ms'].diff()\n    df['timedelta_s'] = df['timedelta_ms'].apply(lambda x: x.total_seconds()).fillna(0)\n    df['velocity'] = (df['acceleration']*df['timedelta_s']).cumsum()\n    df['position'] = p_0 + (df['velocity']*df['timedelta_s']).cumsum()\n\n    return df[['timestamp', 'timestamp_ms', 'timedelta_s', 'position', 'velocity', 'acceleration']]\n\na_df = calc_from_acce(pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) * 1000 + start_time, \n               pd.Series([0, 0, 1.2, 1.2, 1.2, 0, 0, 0, -1.2, -1.2, -1.2, 0, 0]), -6)\ndisplay(a_df.style.set_caption('Calculated Position and Velocity from Acceleration'))\n\nb_df = calc_from_pos(a_df.timestamp, a_df.position)\ndisplay(b_df.style.set_caption('Calculated Acceleration and Velocity from Position'))\n\nfig, ax = plt.subplots(nrows=1, ncols=1, figsize=(14, 6))\nsns.lineplot(x=a_df.timestamp, y=a_df.position, ax=ax, color='cornflowerblue', marker='o', label='Position ($m$)')\nsns.lineplot(x=a_df.timestamp, y=a_df.velocity, ax=ax, color='blue', marker='o', label='Velocity ($m\/s$)')\nsns.lineplot(x=a_df.timestamp, y=a_df.acceleration, ax=ax, color='seagreen', marker='o', label='Acceleration ($m\/s^2$)')\n\nplt.show()","4e9bbc54":"imu_df_temp = calc_from_acce(imu_df.timestamp, \n                      (-1)*imu_df.acce_x, \n                      waypoint_df.waypoint_x.iloc[0])\n\ndisplay(imu_df_temp.head(5).style.set_caption('Calculated Position and Velocity from acce_x'))\n\nwaypoint_df_temp = calc_from_pos(waypoint_df.timestamp, waypoint_df.waypoint_x)\ndisplay(waypoint_df_temp.style.set_caption('Calculated Acceleration and Velocity from waypoint_x'))\n\n\nfig, ax = plt.subplots(nrows=3, ncols=1, figsize=(14, 14))\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.position, ax=ax[0], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.position, ax=ax[0], color='cornflowerblue', label='acce_x')\nax[0].set_ylabel('Position x \\n($m$)')\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.velocity, ax=ax[1], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.velocity, ax=ax[1], color='cornflowerblue', label='acce_x')\nax[1].set_ylabel('Velocity x \\n($m\/s$)')\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.acceleration, ax=ax[2], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.acceleration, ax=ax[2], color='cornflowerblue', label='acce_x')\nax[2].set_ylabel('Acceleration x \\n($m\/s^2$)')\n\nplt.show()","1fcf0cdc":"# Resampled\nimu_df_resampled = imu_df[['timestamp', 'acce_x' ]].copy()\nimu_df_resampled.index = imu_df_resampled['timestamp'].apply(lambda x: datetime.fromtimestamp(x\/1000.0))\nimu_df_resampled = imu_df_resampled.resample('1S').mean().reset_index(drop=True)\nimu_df_resampled.acce_x.iloc[0] = 0\nimu_df_resampled.head()\n\nimu_df_temp_resampled = calc_from_acce(imu_df_resampled.timestamp, \n                      (-1)*imu_df_resampled.acce_x, \n                      waypoint_df.waypoint_x.iloc[0])\n\ndisplay(imu_df_temp_resampled.head(5).style.set_caption('Calculated Position and Velocity from resampled acce_x'))\n\nfig, ax = plt.subplots(nrows=3, ncols=1, figsize=(14, 14))\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.position, ax=ax[0], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.position, ax=ax[0], color='cornflowerblue', label='acce_x')\nsns.lineplot(x=imu_df_temp_resampled.timestamp, y=imu_df_temp_resampled.position, ax=ax[0], color='green', marker='o', label='resampled acce_x')\nax[0].set_ylabel('Position x \\n($m$)')\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.velocity, ax=ax[1], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.velocity, ax=ax[1], color='cornflowerblue', label='acce_x')\nsns.lineplot(x=imu_df_temp_resampled.timestamp, y=imu_df_temp_resampled.velocity, ax=ax[1], color='green', marker='o', label='resampled acce_x')\n\nax[1].set_ylabel('Velocity x \\n($m\/s$)')\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.acceleration, ax=ax[2], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.acceleration, ax=ax[2], color='cornflowerblue', label='acce_x')\nsns.lineplot(x=imu_df_temp_resampled.timestamp, y=imu_df_temp_resampled.acceleration, ax=ax[2], color='green', marker='o', label='resampled acce_x')\n\nax[2].set_ylabel('Acceleration x \\n($m\/s^2$)')\n\nplt.show()","7c3119a7":"imu_df_temp = calc_from_acce(imu_df.timestamp, \n                      imu_df.acce_y - 3.208404, \n                      waypoint_df.waypoint_y.iloc[0])\n\ndisplay(imu_df_temp.head(5).style.set_caption('Calculated Position and Velocity from acce_y'))\n\nwaypoint_df_temp = calc_from_pos(waypoint_df.timestamp, waypoint_df.waypoint_y)\ndisplay(waypoint_df_temp.style.set_caption('Calculated Acceleration and Velocity from waypoint_y'))\n\n\nfig, ax = plt.subplots(nrows=3, ncols=1, figsize=(14, 14))\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.position, ax=ax[0], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.position, ax=ax[0], color='cornflowerblue', label='acce_y')\nax[0].set_ylabel('Position y \\n($m$)')\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.velocity, ax=ax[1], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.velocity, ax=ax[1], color='cornflowerblue', label='acce_y')\nax[1].set_ylabel('Velocity y \\n($m\/s$)')\n\nsns.lineplot(x=waypoint_df_temp.timestamp, y=waypoint_df_temp.acceleration, ax=ax[2], color='orange', marker='o', label='waypoint')\nsns.lineplot(x=imu_df_temp.timestamp, y=imu_df_temp.acceleration, ax=ax[2], color='cornflowerblue', label='acce_y')\nax[2].set_ylabel('Acceleration y \\n($m\/s^2$)')\n\nplt.show()","552458aa":"plot_imu_signals('gyro')\nplot_imu_signals('magn')\n\nfig, ax = plt.subplots(nrows=3, ncols=1, figsize=(14, 9))\ncol = 'ahrs'\nsns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_x\"], ax=ax[0], label='cali', color='cornflowerblue')\nsns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_y\"], ax=ax[1], label='cali', color='cornflowerblue')\nsns.lineplot(x=imu_df.timestamp, y=imu_df[f\"{col}_z\"], ax=ax[2], label='cali', color='cornflowerblue')\nfor i in range(3):\n    ax[i].set_xlim([start_time, end_time])\n\nplt.tight_layout()\nplt.show()","f6b8419e":"wifi_df = pd.DataFrame(sample_file.wifi)\nwifi_df.columns = ['timestamp', 'ssid', 'bssid', 'rssi', 'last_seen_timestamp']\nwifi_df = wifi_df.pivot(index='timestamp', columns=['ssid', 'bssid'])['rssi']\nwifi_df.reset_index(drop=False, inplace=True)\nwifi_df.style.set_caption('WiFi')","d2ac59c5":"fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(20, 8))\n\nfor i, c in enumerate(wifi_df.columns):\n    if c != ('timestamp', ''):\n        sns.lineplot(x=wifi_df.timestamp.astype(int), y=wifi_df[c].replace('NaN', np.nan).astype(float), ax=ax, marker='o', label=c)\n    if i == 8:\n        break\nax.set_xlim([start_time, end_time])\nax.set_ylim([-80, 0])\n\nax.set_ylabel('RSSI')\nax.set_title('8 Sample RSSI')\nplt.show()","b3467a4e":"The first thing, we can notice is that the mean value of acce_z looks familiarly close to the standard gravity $g=9.80665 m\/s^2$. In contrast to the above picture, the phone is not help upright during the trace but instead it is\n> [...] is held flat in front of the surveyors body [...]. \n\nThat is why the value of the z-axis corresponds to $g$.","44b10159":"To retrieve the data, we will go through the file line by line and append the relevant data to its assigned array. Below, we can see that each array has a different shape. For example, we only has 6 data points for waypoint, while we have 1743 datapoints from the acceleration sensor.\n\nThe following code is copied and edited from [@ihelon's notebook](https:\/\/www.kaggle.com\/ihelon\/indoor-location-exploratory-data-analysis) and is originally from the [competition's Github page](https:\/\/github.com\/location-competition\/indoor-location-competition-20\/blob\/master\/io_f.py).","02bb80da":"Now let's try to make sense of the x and y components of the acceleration. For this we will calculate the velocity and position from the acceleration and then cross check it with the actual position. To avoid mistakes, we will first play with a little high school level example :)","03622df1":"\n\n# Waypoint\nLet's plot the trace of the waypoint on the map first to get a feeling for this example.\n\nThe following code is also copied and edited from [@ihelon's notebook](https:\/\/www.kaggle.com\/ihelon\/indoor-location-exploratory-data-analysis) and is originally from the [competition's Github page](https:\/\/github.com\/location-competition\/indoor-location-competition-20\/blob\/master\/visualize_f.py).","bac80dd7":"Let's have a first look at one of the trace files to get a rough feeling for the data. Unfortunately, this time we don't have the comfort of .csv format. Instead, we are provided text files. The **text files** start with a header and end with a footer containing some meta information. The **header and footer are lines which start with a has sign ('#')**. In between, we have the sensor data. The sensor data is **delimited with a tab** ('\\t'). Each row starts with a **timestamp, followed by the sensor name and the sensor values**. However, if you try to read it with pandas and a specified delimiter, you will notice that the **number of columns in each row can vary depending on the sensor**. ","b9320add":"Let's apply this to the sample data (Unhide output to see dataframe -->).\n\nAlthough, we were able to see from the example above that the functions seem to be correct, the `waypoint` data and the `acce` data don't match. This could be caused by the signal's noise. By integrating over the acceleration, we will also integrate the error for each sample, which can quickly accumulate and cause large deviations, as we can see.\n","332673ec":"Let's have a look at the acceleration first.","22052f4f":"Let's see what happens if we **resample** `acce_x` to 1s samples instead of 0.02s samples. This way, we could smooth out some noise.\n\nUnfortunately, as you can see, the values still seem inplausible. **Analysis is on-going...**","2d6b69a5":"# WiFi\n* Service set ID (SSID): name identifier for wireless networks (can be changed)\n* Basic Service Set ID (BSSID): MAC address of the access point (cannot be changed)\n* Received signal strength indication (RSSI)\n","42721693":"# Introduction\n\nYou probably have experienced this before: You are in an underground carpark and you have just activated your navigation system. But the navigation system has trouble locating you on the map due to poor GPS signal quality caused by the concrete walls. Although, in this use case a better accuracy would only be a \"nice to have\", in other cases it could become a necessity for indoor applications.\n\nTo **improve the accuracy of indoor positioning systems**, we are asked to predict the indoor position of smartphones based on real-time sensor data in this competition.\n\nThe aim of this notebook is to give you an **introduction to the topic** and making you **familiar with the data**.\n\n# Dataset Overview\n\nThe dataset we are working with is provided by the Chinese company XYZ10 specialized in indoor positioning technology. The dataset consists of path trace recordings of a person walking from one point to another. During the walk, the following sensor signals are recorded:\n* accelerometer\n* magnetic field\n* gyroscope\n* rotation vector\n* WiFi\n* Bluetooth iBeacon\n* ground truths (waypoint locations)\n\nAdditional information on the data can be found on the [competition's Github page](https:\/\/github.com\/location-competition\/indoor-location-competition-20). There, you will also find some [webinar slides](https:\/\/github.com\/location-competition\/indoor-location-competition-20\/blob\/master\/webinar.pdf).","9f3c5f80":"# Unix Timestamp\nThe first column is the **Unix Time in milliseconds**. If you are not familiar with Unix time, then I recommend reading up on it on [wikipedia](https:\/\/en.wikipedia.org\/wiki\/Unix_time). But in short, the unix time is the time elapsed since 00:00:00 UTC on 1 January 1970. \n\nAt this point, I am not yet sure if we really need to convert Unix timestamps to human understandable timestamps but here is the conversion - just in case. Since we are working with milliseconds, we need to divide the timestamps by 1000. The above sample starts at 1573713056850 and ends at 1573713091483, which corresponds to a short 34.633 s long trace done on November 14th 2019.","90935156":"# Inertial Measurement Unit (IMU)\nThe inertial measurement unit (IMU) is a sensor that measures the force, angular rate and orientation of a body. In this case, the body is a phone. These values are measured by accelerometers, gyroscopes, and in this case also magnetometers. \n* **Accelerometer**: Measures change in velocity ($m\/s^2$) \n* **Gyroscopes**: Measures change in rotation ($rad\/s$)\n* **Magnetometer**: Measures magnetic field ($\\mu T$)\n\nThe IMU sensor data has the same shape in this case. Note, that this is true for a lot of traces but not all of them. We can concatenate them to a dataframe for the initial analysis of the data.\n\n![10421a93-a1dd-41a8-a9c0-7147d3f47f27.png](attachment:10421a93-a1dd-41a8-a9c0-7147d3f47f27.png)\nImage Source: https:\/\/developer.apple.com\/documentation\/coremotion\/getting_processed_device-motion_data\/understanding_reference_frames_and_device_attitude\n\n"}}