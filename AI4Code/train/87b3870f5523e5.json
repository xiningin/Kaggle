{"cell_type":{"7e1e2335":"code","13b8464e":"code","3fe0d64b":"code","c4c89095":"code","4c9c0a45":"code","104edc41":"code","ec251344":"code","ed63721d":"code","9b065c3a":"code","aad3a839":"code","4b05c634":"code","68dbc70f":"code","cd600580":"code","ebe76fc2":"code","9c61af6d":"code","bac89357":"code","43183e1b":"code","7c368658":"code","a69dfeb5":"code","520caca9":"code","c815fa34":"markdown","0c7ea8a9":"markdown","7137ca3d":"markdown","7f874922":"markdown","0eecf925":"markdown","a7109b25":"markdown","5be13602":"markdown","26755f6b":"markdown","1e8cfe06":"markdown","cc4fdc59":"markdown","e5b33637":"markdown","be9e2ba3":"markdown","8b91dcb8":"markdown","0603e551":"markdown","4d4886ca":"markdown","156a6a43":"markdown","91e8cf1e":"markdown"},"source":{"7e1e2335":"# Importar las librer\u00edas necesarias\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt","13b8464e":"# Cargar en memoria los datos de entrenamiento.\ntrain_df = pd.read_csv(\"..\/input\/mobile-price-classification\/train.csv\")\n# Imprimir las primeras 5 filas. \ntrain_df.head()","3fe0d64b":"# Imprimir una descripci\u00f3n de los datos.\ntrain_df.describe().T","c4c89095":"# Gr\u00e1fico de correlaci\u00f3n\nplt.figure(figsize=(14,10))\nsns.heatmap(train_df.corr(), annot=True, fmt=\".2f\");","4c9c0a45":"# Gr\u00e1fico de puntos RAM x Rango de precios\nsns.pointplot(y=\"ram\", x=\"price_range\", data=train_df)","104edc41":"# Convertir la tabla a un arreglo de numpy y separar la columna de rangos de precio\nX = train_df.iloc[:,:20].values\ny = train_df.iloc[:,20:21].values","ec251344":"from sklearn.preprocessing import StandardScaler\nsc = StandardScaler()\nX = sc.fit_transform(X)\nprint(X[0])","ed63721d":"from sklearn.preprocessing import OneHotEncoder\nohe = OneHotEncoder()\ny = ohe.fit_transform(y).toarray()\nprint('Arreglo codificado de 1s:')\nprint(y[0:5])","9b065c3a":"from sklearn.model_selection import train_test_split\nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size = 0.1)","aad3a839":"# Librer\u00edas\nimport keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense\n\n# Red neural\nmodel = Sequential()\nmodel.add(Dense(16, input_dim=20, activation='relu'))\nmodel.add(Dense(12, activation='relu'))\nmodel.add(Dense(4, activation='softmax'))","4b05c634":"# Compilar el modelo \nmodel.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])","68dbc70f":"history = model.fit(X_train, y_train, validation_data = (X_test,y_test), epochs=100, batch_size=64)","cd600580":"y_pred = model.predict(X_test)","ebe76fc2":"# Convertir las predicciones a sus respectivas etiquetas\ndef pred_to_label(y_pred):\n    pred = list()\n    for i in range(len(y_pred)):\n        pred.append(np.argmax(y_pred[i]))\n    return pred","9c61af6d":"from sklearn.metrics import accuracy_score\n\npred = pred_to_label(y_pred)\n    \n# Convertir las etiquetas codificadas como arreglos de 0 y 1 a sus etiquetas originales\ntest = list()\nfor i in range(len(y_test)):\n    test.append(np.argmax(y_test[i]))\n    \n\n# Imprimir la precisi\u00f3n del modelo\na = accuracy_score(pred,test)\nprint(f'La precisi\u00f3n del modelo es del {a*100}%')","bac89357":"import matplotlib.pyplot as plt\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('Precisi\u00f3n del Modelo')\nplt.ylabel('Precisi\u00f3n')\nplt.xlabel('\u00c9poca')\nplt.legend(['Entrenamiento', 'Prueba'], loc='upper left')\nplt.show()","43183e1b":"plt.plot(history.history['loss']) \nplt.plot(history.history['val_loss']) \nplt.title('P\u00e9rdida del Modelo') \nplt.ylabel('P\u00e9rdida') \nplt.xlabel('\u00c9poca') \nplt.legend(['Entrenamiento', 'Prueba'], loc='upper left') \nplt.show()","7c368658":"# Fila a probar\nrow_to_test = 3","a69dfeb5":"# Cargar en memoria los datos de prueba.\ntest_df = pd.read_csv(\"..\/input\/mobile-price-classification\/test.csv\")\n# Imprimir la fila que se utilizar\u00e1 para estimar el rango de precios\ntest_df.loc[[row_to_test]]","520caca9":"test_x = test_df.iloc[:,1:21].values\ntest_x = sc.fit_transform(test_x)\n\nsel_row = np.array([test_x[row_to_test]])\n\nnew_pred = model.predict(sel_row)\npred = pred_to_label(new_pred)\n    \nprint(f'Rango de precios estimado: {pred[0]}')","c815fa34":"# Ejemplo de Redes Neuronales\n---\n## Integrantes:\n* Alexis B\u00e1ez\n* Ricardo Baquero\n* Wladimir Gualoto","0c7ea8a9":"#### Codificaci\u00f3n de la clasificaci\u00f3n en arreglos de 0 y 1","7137ca3d":"#### Probar el modelo\nUtilizaremos los datos de prueba que fueron extra\u00eddos de los datos de entrenamiento. ","7f874922":"**Sequential** especifica a la librer\u00eda \"Keras\" que estamos creando un modelo secuencialmente y el resultado de cada capa son los argumentos de entrada de la siguiente.\n\n**model.add** se utiliza para agregar una capa a nuestra red neural. Se debe especificar que tipo de capa necesitamos.\nUtilizamos **Dense** para especificar que es una capa completamente conectada.","0eecf925":"## Entrenamiento del modelo mediante Redes Neuronales\n### Preprocesamiento de los datos","a7109b25":"Utilizamos como funci\u00f3n \"loss\" categorical_crossentropy la cual especifica que tenemos m\u00faltiples clases.","5be13602":"Examinando el gr\u00e1fico, es evidente que existe una alta correlaci\u00f3n entre la cantidad de memoria RAM y el rango de precio del dispositivo.","26755f6b":"#### Entrenar el modelo","1e8cfe06":"Se utilizar\u00e1 un 10% de los datos de entrenamiento como datos de prueba para mejorar el modelo.","cc4fdc59":"## Visualizaci\u00f3n de datos\n","e5b33637":"## Visualizaci\u00f3n del entrenamiento","be9e2ba3":"#### Separar datos de entrenamiento y prueba","8b91dcb8":"#### Normalizaci\u00f3n de los datos","0603e551":"### Construcci\u00f3n del Modelo\n\nPara nuestra red neural, utilizamos dos capas ocultas de dimensi\u00f3n 12 y 16.","4d4886ca":"Se requiere especificar: los datos de entrada, las etiquetas de los datos, los datos de validaci\u00f3n y sus etiquetas, la cantidad de \u00e9pocas (iteraciones) y el tama\u00f1o de lote (cuantos datos se prueban al mismo tiempo).","156a6a43":"## Descripci\u00f3n\nLa base de datos de entrenamiento contiene informaci\u00f3n de 2000 celulares. El prop\u00f3sito del an\u00e1lisis es determinar el rango de precio de un celular utilizando sus caracter\u00edsticas.\n### Rangos de precios:\n* 0: costo bajo\n* 1: costo medio\n* 2: costo alto\n* 3: costo muy alto\n\n### Caracter\u00edsticas de los celulares:\n* id: ID\n* battery_power: Cantidad total de energ\u00eda de la bater\u00eda en mAh\n* blue: Posee bluetooth o no\n* clock_speed: Velocidad del reloj del procesador\n* dual_sim: Tiene soporte de doble sim\n* fc: Mega pixeles de la c\u00e1mara frontal\n* four_g: Posee 4G o no\n* int_memory: Memoria interna en Gigabytes\n* m_dep: Profundidad del tel\u00e9fono en  cm\n* mobile_wt: Peso del celular\n* n_cores: N\u00famero de n\u00facleos del procesador\n* pc: Mega pixeles de la c\u00e1mara principal\n* px_height: Resoluci\u00f3n vertical en pixeles\n* px_width: Resoluci\u00f3n horizontal en pixeles\n* ram: Memoria RAM en MB\n* sc_h: Altura de la pantalla en cm\n* sc_w: Anchura de la pantalla en cm\n* talk_time: mayor cantidad de tiempo que la bater\u00eda totalmente cargada funcionar\u00e1\n* three_g: Posee 3G o no\n* touch_screen: Posee pantalla t\u00e1ctil o no\n* wifi: Posee wifi o no","91e8cf1e":"## Validaci\u00f3n arbitraria\n\nResultado del modelo utilizando cualquier fila o datos arbitrarios."}}