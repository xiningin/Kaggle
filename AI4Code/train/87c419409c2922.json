{"cell_type":{"78df20d5":"code","17bec4d1":"markdown","711ba703":"markdown"},"source":{"78df20d5":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n#%matplotlib inline\ndf_train = pd.read_csv('..\/input\/train.csv')\ndf_test = pd.read_csv('..\/input\/test.csv')\ndf_train.head()\n\ndef concat_df(train_data, test_data):\n    # Returns a concatenated df of training and test set on axis 0\n    return pd.concat([train_data, test_data]).reset_index(drop=True)\n\ndf_all = concat_df(df_train, df_test)\n\ndf_train.name = 'Training Set'\ndf_test.name = 'Test Set'\ndf_all.name = 'All Set' \n\ndfs = [df_train, df_test]\n\nprint('Number of Training Examples = {}'.format(df_train.shape[0]))\nprint('Number of Test Examples = {}\\n'.format(df_test.shape[0]))\nprint('Training X Shape = {}'.format(df_train.shape))\nprint('Training y Shape = {}\\n'.format(df_train['Survived'].shape[0]))\nprint('Test X Shape = {}'.format(df_test.shape))\nprint('Test y Shape = {}\\n'.format(df_test.shape[0]))\nprint(df_train.columns)\nprint(df_test.columns)\n\n#Below function is for trying if this strategy works, but it doesn't work standalone, we tried to further decipher from the generated code.\ndef fill_cabin_of_spouse(dset):\n    for i in range(len(dset)): \n        name = str(dset.loc[i, \"Name\"])\n        cab = str(dset.loc[i, \"Cabin\"])\n        names = name.split(',');\n        lastname = names[0]\n        if (cab == \"nan\"):\n            for j in range(len(dset)):\n                if (j == i):\n                    continue\n                else:\n                    name2 = str(dset.loc[j, \"Name\"])\n                    names2 = name2.split(',');\n                    lastname2 = names2[0]\n                    if (lastname2 == lastname):\n                        dset.loc[i, \"Cabin\"] = dset.loc[j, \"Cabin\"]\n                        break\n    return dset\n\n#Filling the mising value of cabin with the value of Spouse's\ndf_all = fill_cabin_of_spouse(df_all)\n#df_all['Cabin'] = df_all['Cabin'].fillna(\"Unknown\")\n\nage_by_class_sex = df_all.groupby(['Sex', 'Pclass']).median()['Age']\n\nfor pclass in range(1, 4):\n    for sex in ['female', 'male']:\n        print('Median age of Pclass {} {}s: {}'.format(pclass, sex, age_by_class_sex[sex][pclass]))\nprint('Median age of all passengers: {}'.format(df_all['Age'].median()))\n\n# Filling the missing values in Age with the medians of Sex and Pclass attributes\ndf_all['Age'] = df_all.groupby(['Sex', 'Pclass'])['Age'].apply(lambda x: x.fillna(x.median()))\n\n\n# Creating Deck column from the first letter of the Cabin column (M stands for Missing)\ndf_all['Deck'] = df_all['Cabin'].apply(lambda s: s[0] if pd.notnull(s) else 'M')\n\ndf_all_decks = df_all.groupby(['Deck', 'Pclass']).count().drop(['Survived', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked', 'Cabin', 'PassengerId', 'Ticket'], axis=1).rename({'Name': 'Count'}).transpose()\n\ndef get_pclass_dist(df):\n    \n    # Creating a dictionary for every passenger class count in every deck\n    deck_counts = {'A': {}, 'B': {}, 'C': {}, 'D': {}, 'E': {}, 'F': {}, 'G': {}, 'M': {}, 'T': {}}\n    decks = df.columns.levels[0]    \n    \n    for deck in decks:\n        for pclass in range(1, 4):\n            try:\n                count = df[deck][pclass][0]\n                deck_counts[deck][pclass] = count \n            except KeyError:\n                deck_counts[deck][pclass] = 0\n                \n    df_decks = pd.DataFrame(deck_counts)    \n    deck_percentages = {}\n\n    # Creating a dictionary for every passenger class percentage in every deck\n    for col in df_decks.columns:\n        deck_percentages[col] = [(count \/ df_decks[col].sum()) * 100 for count in df_decks[col]]\n        \n    return deck_counts, deck_percentages\n\ndef display_pclass_dist(percentages):\n    \n    df_percentages = pd.DataFrame(percentages).transpose()\n    deck_names = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'M', 'T')\n    bar_count = np.arange(len(deck_names))  \n    bar_width = 0.50\n    \n    pclass1 = df_percentages[0]\n    pclass2 = df_percentages[1]\n    pclass3 = df_percentages[2]\n    \n    plt.figure(figsize=(20, 10))\n    plt.bar(bar_count, pclass1, color='#ff726f', edgecolor='white', width=bar_width, label='Lower')\n    plt.bar(bar_count, pclass2, bottom=pclass1, color='#add8e6', edgecolor='white', width=bar_width, label='Middle')\n    plt.bar(bar_count, pclass3, bottom=pclass1 + pclass2, color='#90ee90', edgecolor='white', width=bar_width, label='Upper')\n\n    plt.xlabel('Deck', size=12)\n    plt.ylabel('Passenger Class Percentage', size=12)\n    plt.xticks(bar_count, deck_names)    \n    plt.tick_params(axis='x', labelsize=15)\n    plt.tick_params(axis='y', labelsize=15)\n    \n    plt.legend(loc='upper left', bbox_to_anchor=(1, 1), prop={'size': 10})\n    plt.title('Passenger Class Distribution in Decks', size=12, y=1.05)   \n    \n    plt.show()    \n\nprint(df_all_decks.head())\ndeck_count, deck_percent = get_pclass_dist(df_all_decks)\ndisplay_pclass_dist(deck_percent)\n\n#idx = df_all[df_all['Deck'] == 'T'].index\n#df_all.loc[idx, 'Deck'] = 'A'\n\ndf_all_decks_survived = df_all.groupby(['Deck', 'Survived']).count().drop(['Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked', 'Pclass', 'Cabin', 'PassengerId', 'Ticket'],axis=1).rename({'Name': 'Count'}).transpose()\n\ndef get_survived_dist(df):\n    \n    # Creating a dictionary for every survival count in every deck\n    surv_counts = {'A':{}, 'B':{}, 'C':{}, 'D':{}, 'E':{}, 'F':{}, 'G':{}, 'M':{}, 'T':{}}\n    decks = df.columns.levels[0]    \n\n    for deck in decks:\n        for survive in range(0, 2):\n            if (survive in df[deck]):\n                surv_counts[deck][survive] = df[deck][survive][0]\n            \n    df_surv = pd.DataFrame(surv_counts)\n    surv_percentages = {}\n\n    for col in df_surv.columns:\n        surv_percentages[col] = [(count \/ df_surv[col].sum()) * 100 for count in df_surv[col]]\n        \n    return surv_counts, surv_percentages\n\ndef display_surv_dist(percentages):\n    \n    df_survived_percentages = pd.DataFrame(percentages).transpose()\n    deck_names = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'M', 'T')\n    bar_count = np.arange(len(deck_names))  \n    bar_width = 0.50  \n\n    not_survived = df_survived_percentages[0.0]\n    survived = df_survived_percentages[1.0]\n    \n    plt.figure(figsize=(20, 10))\n    plt.bar(bar_count, not_survived, color='#b5ffb9', edgecolor='white', width=bar_width, label=\"Not Survived\")\n    plt.bar(bar_count, survived, bottom=not_survived, color='#f9bc86', edgecolor='white', width=bar_width, label=\"Survived\")\n \n    plt.xlabel('Deck', size=15, labelpad=20)\n    plt.ylabel('Survival Percentage', size=15, labelpad=20)\n    plt.xticks(bar_count, deck_names)    \n    plt.tick_params(axis='x', labelsize=15)\n    plt.tick_params(axis='y', labelsize=15)\n    \n    plt.legend(loc='upper left', bbox_to_anchor=(1, 1), prop={'size': 15})\n    plt.title('Survival Percentage in Decks', size=18, y=1.05)\n    \n    plt.show()\n\nprint(df_all_decks_survived.head())\nall_surv_count, all_surv_per = get_survived_dist(df_all_decks_survived)\ndisplay_surv_dist(all_surv_per)\n\n#Grouped the similar decks from the distribution graph, leaving M and T as such\ndf_all['Deck'] = df_all['Deck'].replace(['A', 'G'], 'AG')\ndf_all['Deck'] = df_all['Deck'].replace(['B', 'C', 'F'], 'BCF')\ndf_all['Deck'] = df_all['Deck'].replace(['D', 'E'], 'DE')\n\n\ndf_all['Deck'].value_counts()\n\n#now we can drop the cabin attribute\ndf_all.drop(['Cabin'], inplace=True, axis=1)\n\ndf_all.head()","17bec4d1":"First of all let's import basic libraries to load, edit and visualize the dataset","711ba703":"# Titanic Dataset Preprocessing\n"}}