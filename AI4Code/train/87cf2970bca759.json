{"cell_type":{"324697ab":"code","cf3d298b":"code","e92b3ab8":"code","c9329519":"code","884d27f4":"code","38523713":"code","fa6fe8f8":"code","ebd271ef":"code","9e67950d":"code","11d56b10":"code","4acf5c10":"code","fcd976b5":"code","9c17757e":"code","c3c3e774":"code","b6900aaa":"code","0efcc780":"code","df991e72":"code","ec4682a3":"code","3be7d461":"code","6e12edfe":"code","172afe8d":"code","ac023211":"code","7d9f663a":"code","28fc8a7d":"code","61788ee1":"code","fa79ab1d":"code","6caccda4":"code","1e1e094d":"code","3c3881f3":"code","e2f896f8":"code","12f374dd":"code","1f03692d":"code","ac1cb0e6":"code","b2fed27b":"code","6ce48f3b":"code","4f0dc213":"code","94f86423":"code","be0042fe":"code","20af3831":"code","a0716d46":"code","3680ce80":"code","980b769b":"code","211ba7d3":"code","aeae78b5":"code","726fcf1d":"code","436a76de":"code","1fdbddd7":"code","abb80f0f":"code","83257314":"code","8f32a1cd":"code","334f1c69":"code","b72bab01":"code","c00088d2":"code","4429a59a":"code","ef43bb14":"code","7199100c":"code","5f588cb0":"code","00c7b636":"code","86eb2694":"code","70a38deb":"code","fda5c5fb":"code","35268e4d":"code","e530ece5":"markdown"},"source":{"324697ab":"pip install yfinance","cf3d298b":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nimport yfinance as yf\nimport statsmodels.api as sm","e92b3ab8":"start = pd.to_datetime('2015-01-01')\nend = pd.to_datetime('2021-01-01')","c9329519":"tcs = yf.download('TCS',start,end)\ninfy = yf.download('INFY',start,end)\nwipro = yf.download('WIPRO.NS',start,end)\niex = yf.download('iex',start,end)","884d27f4":"tcs","38523713":"infy","fa6fe8f8":"wipro","ebd271ef":"iex","9e67950d":"tcs.iloc[0]['Adj Close']","11d56b10":"for stock_df in (tcs, infy, wipro, iex):\n    stock_df['Normed Return'] = stock_df['Adj Close'] \/ stock_df.iloc[0]['Adj Close']","4acf5c10":"iex.head()","fcd976b5":"#30% in tcs\n#20% in infosys\n#10% in wipro\n#40% in indian energy exchange","9c17757e":"list(zip((tcs, infy, wipro, iex), [0.3, 0.2, 0.1, 0.4]))","c3c3e774":"for stock_df, allocation in zip((tcs, infy, wipro, iex), [0.3, 0.2, 0.1, 0.4]):\n    stock_df['Allocation'] = stock_df['Normed Return'] * allocation","b6900aaa":"tcs.head()","0efcc780":"for stock_df in (tcs, infy, wipro, iex):\n    stock_df['Position Values'] = stock_df['Allocation']*1000000 ","df991e72":"iex.head()","ec4682a3":"all_position_vals = [tcs['Position Values'], infy['Position Values'],\n                    wipro['Position Values'], iex['Position Values']]\nportfolio_val = pd.concat(all_position_vals, axis = 1) ","3be7d461":"portfolio_val","6e12edfe":"portfolio_val.columns =['TCS Pos', 'INFOSYS Pos', 'WIPRO Pos', 'IEX Pos']","172afe8d":"portfolio_val","ac023211":"portfolio_val['Total Pos'] = portfolio_val.sum(axis= 1)","7d9f663a":"portfolio_val","28fc8a7d":"portfolio_val.drop('Total Pos', axis= 1).plot(figsize= (10,8))","61788ee1":"#Market Capitalisation\ntcs['MarktCap'] = tcs['Open'] * tcs['Volume']\ninfy['MarktCap'] = infy['Open'] * infy['Volume']\nwipro['MarktCap'] = wipro['Open'] * wipro['Volume']\niex['MarktCap'] = iex['Open'] * iex['Volume']\ntcs['MarktCap'].plot(label = 'TCS', figsize = (15,7))\ninfy['MarktCap'].plot(label = 'Infosys')\nwipro['MarktCap'].plot(label = 'Wipro')\niex['MarktCap'].plot(label= 'IEX')\nplt.title('Market Cap')\nplt.legend()","fa79ab1d":"portfolio_val['Daily_Return'] = portfolio_val['Total Pos'].pct_change(1)","6caccda4":"portfolio_val.head()","1e1e094d":"portfolio_val['Daily_Return'].mean()","3c3881f3":"portfolio_val['Daily_Return'].std()","e2f896f8":"portfolio_val['Daily_Return'].plot(kind= 'hist', bins= 100)","12f374dd":"portfolio_val['Daily_Return'].plot(kind= 'kde')","1f03692d":"cumulative_return = 100 * (portfolio_val['Total Pos'][-1] \/ portfolio_val['Total Pos'][0] - 1)","ac1cb0e6":"cumulative_return","b2fed27b":"Sharpe_ratio = portfolio_val['Daily_Return'].mean() \/ portfolio_val['Daily_Return'].std()\nSharpe_ratio","6ce48f3b":"# The inventors always looking for risk adjusting return (risk free rate),\n# Sharp ratio is annualize ratio , when using the equation of mean over standard deviation\n# Therefore, 252 trading days we are going to calculate Annualized Sharpe Ratio","4f0dc213":"Annualized_sharpe_ratio = (252 ** 0.5) * Sharpe_ratio\nAnnualized_sharpe_ratio","94f86423":"# Generally Sharpe ratio Greater than 1 is acceptable depending on their risk tolerance\n# Ratio hiwgher than 2 is rated as very good\n# Ratio higher than 3 is rated as excellent","be0042fe":"#NOW LETS OPTIMIZE THE PORTFOLIO BY MONTE CARLO SIMULATION\n# WE ARE GOING TO PLOT THE VOLATILITY VS RETURN \n# WE ARE GOING TO USE SCIPY OPTIMIZE ALGORITHIM FOR PLOTTING BORDERLINE\n# CALLED EFFICIENT FRONTIER","20af3831":"stocks = pd.concat([tcs['Close'], infy['Close'], wipro['Close'], iex['Close']], axis= 1)\nstocks.columns = ['tcs', 'infy', 'wipro', 'iex']","a0716d46":"stocks","3680ce80":"stocks.pct_change(1).mean()","980b769b":"stocks.pct_change(1).corr()","211ba7d3":"#LOGARITHMIC RETURN OF THE STOCKS\nlog_ret = np.log(stocks\/stocks.shift(1))\nlog_ret.head()","aeae78b5":"log_ret.hist(bins=100, figsize= (12, 8))\nplt.tight_layout()","726fcf1d":"#COVARIANCE OF LOGARITHMIC RETURNS\nlog_ret.cov() * 252","436a76de":"np.random.seed(42)\nnum_ports = 6000\nall_weights = np.zeros((num_ports, len(stocks.columns)))\nret_arr = np.zeros(num_ports)\nvol_arr = np.zeros(num_ports)\nsharpe_arr = np.zeros(num_ports)\n\nfor ind in range(num_ports):\n    # Weights\n    weights = np.array(np.random.random(4))\n    weights = weights\/np.sum(weights)\n    \n    # Save weights\n    all_weights[ind,:] = weights\n    \n    # Expected return\n    ret_arr[ind] = np.sum( (log_ret.mean() * weights * 252))\n    \n    # Expected volatility\n    vol_arr[ind] = np.sqrt(np.dot(weights.T, np.dot(log_ret.cov()*252, weights)))\n    \n    # Sharpe Ratio\n    sharpe_arr[ind] = ret_arr[ind]\/vol_arr[ind]","1fdbddd7":"sharpe_arr.max()","abb80f0f":"sharpe_arr.argmax()","83257314":"max_sr_ret = ret_arr[sharpe_arr.argmax()]\nmax_sr_vol = vol_arr[sharpe_arr.argmax()]","8f32a1cd":"plt.figure(figsize=(12,8))\nplt.scatter(vol_arr, ret_arr, c=sharpe_arr, cmap='inferno')\nplt.colorbar(label='Sharpe Ratio')\nplt.xlabel('Volatility')\nplt.ylabel('Return')\nplt.scatter(max_sr_vol, max_sr_ret,c='red', s=50, edgecolors= 'black') # red dot\nplt.show()","334f1c69":"def get_ret_vol_sr(weights):\n    weights = np.array(weights)\n    ret = np.sum(log_ret.mean() * weights) * 252\n    vol = np.sqrt(np.dot(weights.T, np.dot(log_ret.cov()*252, weights)))\n    sr = ret\/vol\n    return np.array([ret, vol, sr])\n\ndef neg_sharpe(weights):\n# the number 2 is the sharpe ratio index from the get_ret_vol_sr\n    return get_ret_vol_sr(weights)[2] * -1\n\ndef check_sum(weights):\n    #return 0 if sum of the weights is 1\n    return np.sum(weights)-1","b72bab01":"cons = ({'type': 'eq', 'fun': check_sum})\nbounds = ((0,1), (0,1), (0,1), (0,1))\ninit_guess  = [0.25, 0.25, 0.25, 0.25]","c00088d2":"from scipy.optimize import minimize","4429a59a":"opt_results = minimize(neg_sharpe, init_guess, method= 'SLSQP', bounds= bounds, constraints= cons)","ef43bb14":"opt_results","7199100c":"opt_results.x","5f588cb0":"get_ret_vol_sr(opt_results.x)","00c7b636":"frontier_y = np.linspace(0,0.2,100)","86eb2694":"frontier_y","70a38deb":"def minimize_volatility(weights):\n    return get_ret_vol_sr(weights)[1]","fda5c5fb":"frontier_volatility = []\n\nfor possible_return in frontier_y:\n    cons = ({'type':'eq', 'fun':check_sum},\n            {'type':'eq', 'fun': lambda w: get_ret_vol_sr(w)[0] - possible_return})\n    \n    result = minimize(minimize_volatility,init_guess,method='SLSQP', bounds=bounds, constraints=cons)\n    frontier_volatility.append(result['fun'])","35268e4d":"plt.figure(figsize=(12,8))\nplt.scatter(vol_arr, ret_arr, c=sharpe_arr, cmap='inferno')\nplt.colorbar(label='Sharpe Ratio')\nplt.xlabel('Volatility')\nplt.ylabel('Return')\nplt.plot(frontier_volatility,frontier_y, 'g--', linewidth=3)\nplt.savefig('cover.png')\nplt.show()","e530ece5":"**IF YOU LIKE THIS CODE,PLS FEEL FREE TO UPVOTE AND**\n*ANY SUGGESTION, PLS FEEL FREE TO SHARE**"}}