{"cell_type":{"f25c5f18":"code","eccf7314":"code","eb92683c":"code","fdbe6475":"code","a5bfbd1a":"code","b7a61a50":"code","4eeaa054":"code","50bf072f":"code","1c510d07":"code","70408ddd":"code","8f41b298":"code","6633d5fb":"code","eb1d29fb":"code","ed471755":"code","e8bbc991":"code","6fdd4fbf":"code","1a4d2a72":"code","f94dd671":"code","3ba69a6c":"code","aa31a898":"code","f9dd0a33":"code","a258e2f4":"code","50454916":"code","41470140":"code","4f66e42d":"code","59a3b72a":"code","4862762d":"code","6c359b30":"code","debcaf7d":"code","7f6c23db":"code","55293c37":"code","586524c0":"code","cedff786":"code","cff88032":"code","809366d7":"code","8b144796":"code","dee7b493":"code","069a8c19":"code","a081a157":"code","b56169b0":"code","ce8b3c65":"code","ce80d36b":"code","fb70b8ff":"code","6f520b65":"code","a5596453":"code","522184f5":"code","5b33632d":"code","05d2ea6d":"code","8aeee828":"code","16a4dcd5":"code","3aaa5e70":"code","abbf92fa":"code","6d3a9e30":"code","9f5cc5e9":"code","53daa9a0":"code","25be4336":"code","cc9e2aea":"code","659ac351":"code","75c90251":"code","f180a6ba":"code","78e75a10":"code","5ed9f08c":"code","183f3df6":"code","421ff4aa":"code","bfcd5657":"code","03ee0aae":"code","11544162":"code","6aa29632":"code","7bba7923":"code","d8046829":"code","4f9b624f":"code","4fb14c18":"code","98846bf9":"code","d0a73c72":"code","f46a4efc":"code","1be1dff8":"code","f45f224b":"code","1785ad09":"code","30165b62":"code","18adc8bc":"code","38905921":"code","8809d7e6":"code","4fb6dc55":"code","d55a0f1a":"code","87a686fa":"code","0488da64":"code","90f8b13c":"code","0afbfd75":"code","0538b953":"code","df8e8425":"code","621fb4b1":"code","60d9a9b5":"code","7621a55c":"code","03bf78fc":"code","f22a4e1c":"code","84e118ca":"code","2dbc172c":"code","91e0b964":"code","b407fee6":"code","9fccd1c8":"code","98c083c3":"code","ba395d82":"code","3f0159bd":"code","c3040042":"code","96d1687a":"code","121b889a":"code","1b61f4ee":"code","39d54a91":"markdown","3ef5d463":"markdown","3ebb79a0":"markdown","2aaefe51":"markdown","64625c78":"markdown","339c3afe":"markdown","6c5fa168":"markdown","6d4dc35f":"markdown","ea879c64":"markdown","8c1df55a":"markdown","2111cff5":"markdown","67a7fe18":"markdown","b6aeab2e":"markdown","182bc544":"markdown","7ddbcfb4":"markdown","522ae64e":"markdown","9e88a848":"markdown","2b0bdea1":"markdown","5ce61348":"markdown","818d1191":"markdown","c367d96f":"markdown","e344b985":"markdown","565e3db5":"markdown","8829996b":"markdown","e6f2bbb2":"markdown","3f1c421e":"markdown","ffcb88f0":"markdown","b84b9cdf":"markdown","a9c59175":"markdown"},"source":{"f25c5f18":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\nimport seaborn as sns\nimport matplotlib\nmatplotlib.rcParams['axes.unicode_minus'] = False\nplt.style.use('ggplot')\nfrom sklearn.preprocessing import scale, minmax_scale\nimport os\nimport xgboost as xgb\nimport lightgbm as lgb\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import mean_absolute_error as mae\nfrom sklearn.preprocessing import OneHotEncoder\nimport gc","eccf7314":"def print_expand():\n    pd.set_option('display.max_columns', None)  # or 1000\n    pd.set_option('display.max_rows', 100)  # or 1000\n    pd.set_option('display.max_colwidth', -1)  # or 199\ndef print_basic():\n    pd.set_option('display.max_columns', 30)  # or 1000\n    pd.set_option('display.max_rows', 30)  # or 1000\n    pd.set_option('display.max_colwidth', 50)  # or 199\nprint_expand()","eb92683c":"os.listdir('..\/input\/pubg-finish-placement-prediction')","fdbe6475":"train = pd.read_csv('..\/input\/pubg-finish-placement-prediction\/train_V2.csv')\ntest = pd.read_csv('..\/input\/pubg-finish-placement-prediction\/test_V2.csv')\nsub = pd.read_csv('..\/input\/pubg-finish-placement-prediction\/sample_submission_V2.csv')","a5bfbd1a":"# def reduce_mem_usage(df, verbose=True):\n#     numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n#     start_mem = df.memory_usage().sum() \/ 1024**2    \n#     for col in df.columns:\n#         col_type = df[col].dtypes\n#         if col_type in numerics:\n#             c_min = df[col].min()\n#             c_max = df[col].max()\n#             if str(col_type)[:3] == 'int':\n#                 if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n#                     df[col] = df[col].astype(np.int8)\n#                 elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n#                     df[col] = df[col].astype(np.int16)\n#                 elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n#                     df[col] = df[col].astype(np.int32)\n#                 elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n#                     df[col] = df[col].astype(np.int64)  \n#             else:\n#                 if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n#                     df[col] = df[col].astype(np.float16)\n#                 elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n#                     df[col] = df[col].astype(np.float32)\n#                 else:\n#                     df[col] = df[col].astype(np.float64)    \n#     end_mem = df.memory_usage().sum() \/ 1024**2\n#     if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n#     return df","b7a61a50":"# train = reduce_mem_usage(train)\n# test = reduce_mem_usage(test)","4eeaa054":"print('train shape :', train.shape)\ntrain.head()","50bf072f":"print('test shape :', test.shape)\ntest.head()","1c510d07":"print('sample_submission shape :', sub.shape)\nsub.head()","70408ddd":"train.isna().sum()","8f41b298":"test.isna().sum()","6633d5fb":"train[train['winPlacePerc'].isna()==True]\n# must be delete","eb1d29fb":"train = train.dropna()\ntrain.shape","ed471755":"train.describe()","e8bbc991":"train.describe(include=['O'])","6fdd4fbf":"train[train['winPlacePerc'] == 1].shape","1a4d2a72":"train[train['matchType']=='solo-fpp']['DBNOs'].max()","f94dd671":"train[train['matchId'] == \"b30f3d87189aa6\"].head()","3ba69a6c":"d = train['groupId'].value_counts()\nd = d[d > 4]\nprint('length :', len(d), 'max :', np.max(d), 'min :', np.min(d))\nd[:5]","aa31a898":"train[train['groupId'] == '23b79fb17aeaad']","f9dd0a33":"def quan(x):\n    print('quantile of {}'.format(x.name))\n    for i in [i\/10 for i in range(0, 10)]:\n        print(f'{i} :', x.quantile(i))\n    print('0.99 :', x.quantile(0.99))\n    print('1.0 :', x.max())","a258e2f4":"train.columns","50454916":"cols = train.columns[3:]\ncols = cols.delete(12)\nfor col in cols:\n    quan(train[col])\n# maxPlace\ub294 \ucd5c\ub300\ub4f1\uc218(\uaf34\ub4f1)\uc774\uc9c0\ub9cc numGroup\uacfc \ub2e4\ub97c \uc218 \uc788\ub2e4.","41470140":"def plot0(df, col, p='dist', c=1):\n    if p == 'dist':\n        if c == 0:\n            fig, ax = plt.subplots(1, 2, figsize=(16, 7))\n            sns.distplot(df[col], kde=False, ax=ax[0]).set(title = f'{col} dist.')\n            sns.distplot(df[df[col] > 0][col], kde=False, ax=ax[1]).set(title = f'{col} > 0 dist.')\n        elif c == 1:\n            plt.figure(figsize=(15, 7))\n            sns.distplot(df[col], kde=False).set(title = f'{col} dist.')\n        else:\n            print('c, E R R O R !')\n    elif p == 'count':\n        if c == 0:\n            fig, ax = plt.subplots(1, 2, figsize=(16, 7))\n            sns.countplot(df[col], ax=ax[0]).set(title = f'{col} dist.')\n            sns.countplot(df[df[col] > 0][col], ax=ax[1]).set(title = f'{col} > 0 dist.')\n        elif c == 1:\n            plt.figure(figsize=(15, 7))\n            sns.countplot(df[col]).set(title = f'{col} dist.')\n        else:\n            print('c, E R R O R !')\n    else:\n        print('p, E R R O R !')\n        \ndef bplot(df, col1, col2):\n    plt.figure(figsize=(15, 7))\n    sns.boxplot(col1, col2, data=df).set(title = f'{col2} boxplot by {col1}')","4f66e42d":"plot0(train, 'winPlacePerc')","59a3b72a":"plot0(train, 'maxPlace', p='count')","4862762d":"plt.figure(figsize=(15, 7))\nsns.countplot(train[((train['maxPlace'] >=20) & (train['maxPlace'] <= 30)) | ((train['maxPlace'] >= 45) & (train['maxPlace'] <= 55)) | ((train['maxPlace'] >= 90))]['maxPlace']).set(title = 'maxPlace range cut dist.')","6c359b30":"plot0(train, 'numGroups', p='count')","debcaf7d":"train[train['maxPlace'] == 100].shape","7f6c23db":"train[train['numGroups'] == 100].shape","55293c37":"train[(train['maxPlace'] == 100) & (train['numGroups'] == 100)].shape","586524c0":"7 + 33 + 35 + 28 + 17 + 6 + 2 + 2 + 1\n# \ud56d\uc0c1 maxPlace\uac00 numGroups\ubcf4\ub2e4 \ud06c\uac70\ub098 \uac19\uc740\ub4ef","cedff786":"train[train['numGroups'] == 100]['matchId'].nunique()","cff88032":"train[train['maxPlace'] == 100]['matchId'].nunique()","809366d7":"tt = train[train['matchType'].str.contains('solo') == False]\nprint('not solo :', tt.shape)\ntt.head()","8b144796":"plot0(tt, 'assists', p='count', c=0)","dee7b493":"bplot(tt, 'assists', 'winPlacePerc')","069a8c19":"plot0(tt, 'DBNOs', p='count', c=0)","a081a157":"bplot(tt, 'DBNOs', 'winPlacePerc')","b56169b0":"plot0(tt, 'revives', p='count', c=0)","ce8b3c65":"bplot(tt, 'revives', 'winPlacePerc')","ce80d36b":"del tt\ngc.collect()","fb70b8ff":"plot0(train, 'boosts', p='count', c=0)","6f520b65":"bplot(train, 'boosts', 'winPlacePerc')","a5596453":"plot0(train, 'heals', p='count', c=0)","522184f5":"bplot(train, 'heals', 'winPlacePerc')","5b33632d":"plot0(train, 'damageDealt', c=0)","05d2ea6d":"plot0(train, 'kills', p='count', c=0)","8aeee828":"plot0(train, 'kills', p='count')","16a4dcd5":"bplot(train, 'kills', 'winPlacePerc')","3aaa5e70":"plot0(train, 'killPlace', p='count')","abbf92fa":"bplot(train, 'killPlace', 'winPlacePerc')","6d3a9e30":"plot0(train, 'killStreaks', p='count', c=0)","9f5cc5e9":"bplot(train, 'killStreaks', 'winPlacePerc')","53daa9a0":"train['killStreaks'].value_counts()","25be4336":"test['killStreaks'].value_counts()","cc9e2aea":"plot0(train, 'headshotKills', p='count', c=0)","659ac351":"bplot(train, 'headshotKills', 'winPlacePerc')","75c90251":"plot0(train, 'longestKill', c=0)","f180a6ba":"plot0(train, 'roadKills', p='count', c=0)","78e75a10":"plot0(train, 'teamKills', p='count', c=0)","5ed9f08c":"plot0(train, 'matchDuration')","183f3df6":"plt.figure(figsize=(15, 7))\nsns.distplot(train[(train['matchDuration'] >= 1100) & (train['matchDuration'] <= 2200)]['matchDuration'], kde=False).set(title = 'matchDuration range cut dist.')","421ff4aa":"plt.figure(figsize=(15, 7))\nsns.distplot(test['matchDuration'], kde=False)","bfcd5657":"train['matchDuration'].mean()","03ee0aae":"train['matchType'].value_counts()","11544162":"plot0(train, 'killPoints', c=0)","6aa29632":"plot0(train, 'rankPoints', c=0)","7bba7923":"train[train['rankPoints'] == 0].shape","d8046829":"plot0(train, 'winPoints', c=0)","4f9b624f":"fig, ax = plt.subplots(1, 3, figsize=(16, 6))\nsns.scatterplot('killPoints', 'winPlacePerc', data = train, ax=ax[0]).set(title = 'killPoints & winPlacePerc')\nsns.scatterplot('rankPoints', 'winPlacePerc', data = train, ax=ax[1]).set(title = 'rankPoints & winPlacePerc')\nsns.scatterplot('winPoints', 'winPlacePerc', data = train, ax=ax[2]).set(title = 'winPoints & winPlacePerc')","4fb14c18":"plot0(train, 'rideDistance', c=0)","98846bf9":"plot0(train, 'swimDistance', c=0)","d0a73c72":"plot0(train, 'walkDistance')","f46a4efc":"plt.figure(figsize=(15, 7))\nsns.scatterplot('walkDistance', 'winPlacePerc', data=train)","1be1dff8":"plt.figure(figsize=(15, 7))\nsns.scatterplot('walkDistance', 'rideDistance', data=train)","f45f224b":"plot0(train, 'vehicleDestroys', p='count', c=0)","1785ad09":"plt.figure(figsize=(15, 7))\nsns.boxplot('vehicleDestroys', 'winPlacePerc', data = train)","30165b62":"plt.figure(figsize=(14, 12))\nsns.heatmap(train.iloc[:, 3:].corr(), annot=True, fmt='.2f')","18adc8bc":"train.columns","38905921":"train['matchType'].value_counts()","8809d7e6":"# \uc2e4\ud328\uc791,,\n# train.query(\"'squad' in matchType\").shape\n\n# tt = train[train['matchType'].str.contains('squad')]\n# tt.head()\n\n# squad4 = (tt.groupby('groupId')['Id'].count()[tt.groupby('groupId')['Id'].count() == 4]).index\n# # size() \uc4f0\uba74 \ub428\n\n# train4 = tt[tt['groupId'].isin(squad4)]\n# print(train4.shape)\n# train4.head()\n\n# train4[train4['winPlacePerc'] == 1].shape\n\n# plt.figure(figsize = (15, 7))\n# sns.distplot(train4['winPlacePerc'])\n\n# train['winPlacePerc'].nunique()\n\n# train4[train4['groupId'] == '4d4b580de459be']\n\n# # train[train['matchId'] == 'a10357fd1a4a91'].sort_values('groupId')\n\n# # train[train['groupId'] == '128b07271aa012']\n\n# plt.figure(figsize = (15, 10))\n# sns.heatmap(train.drop(['Id', 'groupId', 'matchId'], axis = 1).corr(), annot = True, fmt = '.2f')\n\n# gb = train4.groupby('groupId')\n\n# kill = gb['kills'].std()\n# win = gb['winPlacePerc'].mean()\n\n# walk = gb['walkDistance'].std()\n# d = walk.reset_index()\n# tr = train4.copy()\n# d = pd.merge(tr, walk, on = 'groupId', how = 'left')\n# d.head()\n\n# np.sum(d['walkDistance_x'] < d['walkDistance_y'])\n# # \uc6d0\ub370\uc774\ud130\ubcf4\ub2e4 \ud45c\uc900\ud3b8\ucc28\uac00 \ub354 \uc791\uc740 \uacbd\ud5a5\n\n# def csplot(col, sv = 'std'):\n#     if sv == 'std':\n#         c = gb[col].std()\n#         win = gb['winPlacePerc'].mean()\n#         df = pd.concat([c, win], axis = 1)\n#         fig, ax = plt.subplots(2, 2, figsize = (15, 10))\n#         sns.heatmap(df.corr(), annot = True, fmt = '.2f', ax = ax[0, 0]).set(title = f\"Groupby groupId({sv}) corr\")\n#         sns.heatmap(train4[[col, 'winPlacePerc']].corr(), annot = True, fmt = '.2f', ax = ax[0, 1]).set(title = \"All data corr\")\n#         sns.scatterplot(x = 'winPlacePerc', y = col, data = df, ax = ax[1, 0]).set(title = f\"Groupby groupId({sv}) plot\")\n#         sns.scatterplot(x = 'winPlacePerc', y = col, data = train4, ax = ax[1, 1]).set(title = \"All data plot\")\n#         plt.tight_layout()\n#         plt.show()\n#     elif sv == 'var':\n#         c = gb[col].std() ** 2\n#         win = gb['winPlacePerc'].mean()\n#         df = pd.concat([c, win], axis = 1)\n#         fig, ax = plt.subplots(2, 2, figsize = (15, 10))\n#         sns.heatmap(df.corr(), annot = True, fmt = '.2f', ax = ax[0, 0]).set(title = f\"Groupby groupId({sv}) corr\")\n#         sns.heatmap(train4[[col, 'winPlacePerc']].corr(), annot = True, fmt = '.2f', ax = ax[0, 1]).set(title = \"All data corr\")\n#         sns.scatterplot(x = 'winPlacePerc', y = col, data = df, ax = ax[1, 0]).set(title = f\"Groupby groupId({sv}) plot\")\n#         sns.scatterplot(x = 'winPlacePerc', y = col, data = train4, ax = ax[1, 1]).set(title = \"All data plot\")\n#         plt.tight_layout()\n#         plt.show()\n#     else:\n#         print(\"error\")\n\n# csplot('kills')\n\n# csplot('kills', 'var')\n\n# csplot('damageDealt')\n\n# csplot('damageDealt', 'var')\n\n# csplot('boosts')\n\n# csplot('boosts', 'var')\n\n# csplot('walkDistance')\n\n# csplot('walkDistance', 'var')","4fb6dc55":"plt.figure(figsize=(15, 7))\nsns.countplot(train['maxPlace'])","d55a0f1a":"np.sum(test['maxPlace'] == 2)","87a686fa":"# Feature Engineering","0488da64":"# \ud0c8\uac83\uc744 \ud30c\uad34 \ud588\ub2e4 \uc548\ud588\ub2e4\ub85c \ubc14\uafb8\uae30\n# \ucc28\ub97c \ud0d4\ub2e4 \uc548\ud0d4\ub2e4 \ubc14\uafb8\uae30\n# \uc774\ub3d9 \uc218\ub2e8 \uc0c1\uad00\uc5c6\uc774 \uac70\ub9ac \ub2e4 \ud569\uce58\uae30\n# ELO\ub294 \ub9e4\uce58\ubcc4\ub85c minmax \ud558\uae30\n# killPlace\ub294 \ub9e4\uce58\ubcc4\ub85c minmax \ud558\uae30\n# matchType\uc740 squad, squad-fpp, duo, duo-fpp, solo, solo-fpp, \uadf8 \uc678 \ub098\uba38\uc9c0\n# killStreaks\ub294 4\uc774\uc0c1 \ud1b5\ud569\ud558\uae30\n# DBNOs\ub294 6\uc774\uc0c1 \ud1b5\ud569\ud558\uae30\n# headshotKills\ub294 4\uc774\uc0c1 \ud1b5\ud569\ud558\uae30\n# kills\ub294 8\uc774\uc0c1 \ud1b5\ud569\ud558\uae30\n# \uadf8\ub8f9\ubcc4 \ubcc0\uc218\uac00 \ubb54\uac00 \uc911\uc694\ud55c \uac83 \uac19\uc740 \ub290\ub08c -> \uc544\uc608 \uadf8\ub8f9\uc758 \ud569\ud0ac, \ud569\ub51c, \ud3c9\uade0\ub51c, \ud3c9\uade0\ud0ac \uac19\uc740 \uac70?????\n# \uac1c\uc778\ubcf4\ub2e4 \ud300\uc131\uacfc\uc600\uc74c (\uac19\uc740 \uadf8\ub8f9\uc774\uba74 \ub4f1\uc218\uac00 \uac19\uae30 \ub54c\ubb38)","90f8b13c":"headshot = train[['kills', 'headshotKills', 'winPlacePerc']]\nheadshot['headshotrate'] = 0\nheadshot['headshotrate'][headshot['kills'] > 0] = headshot['kills'] \/ headshot['headshotKills']\nheadshot.corr()","0afbfd75":"# del train, test\n# gc.collect()","0538b953":"# def data_transform(df, is_train=True):\n# #     if is_train:\n# #         df = pd.read_csv('..\/input\/pubg-finish-placement-prediction\/train_V2.csv')\n# #         df = df.dropna()\n# #     else:\n# #         df = pd.read_csv('..\/input\/pubg-finish-placement-prediction\/test_V2.csv')\n        \n#     print('make features..')\n#     df['headshotRate'] = 0\n#     df['headshotRate'][df['kills'] > 0] = df['headshotKills'] \/ df['kills']\n#     df['killStreaksPerc'] = 0\n#     df['killStreaksPerc'][df['kills'] > 0] = df['killStreaks'] \/ df['kills']\n#     df['roadKillPerc'] = 0\n#     df['roadKillPerc'][df['kills'] > 0] = df['roadKills'] \/ df['kills']\n#     df['matchDuration'] = df['matchDuration'].map(lambda x: 0 if x < 1600 else 1)\n#     for c in ['vehicleDestroys', 'teamKills']:\n#         df[c] = df[c].map(lambda x: 1 if x > 0 else 0)\n    \n#     l1 = ['assists', 'boosts', 'damageDealt', 'DBNOs', 'headshotKills', 'heals',\n#           'kills', 'killStreaks', 'longestKill', 'revives', 'rideDistance', 'roadKills',\n#           'swimDistance', 'teamKills', 'vehicleDestroys', 'walkDistance', 'weaponsAcquired',\n#           'headshotRate', 'killStreaksPerc', 'roadKillPerc']\n#     l2 = ['assists', 'boosts', 'damageDealt', 'DBNOs', 'headshotKills', 'heals',\n#           'kills', 'killStreaks', 'longestKill', 'revives', 'rideDistance', 'roadKills',\n#           'swimDistance', 'teamKills', 'vehicleDestroys', 'walkDistance', 'weaponsAcquired',\n#           'headshotRate', 'killStreaksPerc', 'roadKillPerc', 'killPlacePerc', 'Points']\n#     l3 = [['squad-fpp', 'normal-squad-fpp', 'squad', 'normal-squad'],\n#           ['duo', 'duo-fpp', 'normal-duo-fpp', 'normal-duo'],\n#           ['solo-fpp', 'solo', 'normal-solo-fpp', 'normal-solo'],\n#           ['crashfpp', 'flaretpp', 'flarefpp', 'crashtpp']]\n#     dic1 = {}\n#     for i in range(len(l3)):\n#         for j in range(len(l3[i])):\n#             dic1[l3[i][j]] = i\n#     df['matchType'] = df['matchType'].map(lambda x: dic1[x])\n    \n#     gb_mg = df.groupby(['matchId', 'groupId'])\n#     gb_m = df.groupby('matchId')\n    \n#     if is_train:\n#         y_train = gb_mg['winPlacePerc'].mean().values\n#     else:\n#         y_train = None\n    \n#     df['killPlacePerc'] = gb_m['killPlace'].rank(pct=True, ascending=False).values\n#     df['Points'] = df['killPoints'] + df['rankPoints'] + df['winPoints']\n#     df['Points'] = gb_m['Points'].rank(pct=True, ascending=False).values\n#     df_n = gb_mg.size().reset_index().rename(columns = {0:'n_team'})\n#     df = df.merge(df_n, how='left', on=['matchId', 'groupId'])\n    \n#     print('make group mean features')\n#     agg = gb_mg[l1].agg('mean')\n#     agg_rank = agg.groupby('matchId')[l1].rank(pct=True).reset_index()\n    \n#     if is_train == True: output = agg.reset_index()[['matchId', 'groupId']]\n#     else: output = df[['matchId', 'groupId']]\n    \n#     output = output.merge(agg.reset_index(), how='left', on=['matchId', 'groupId'])\n#     output = output.merge(agg_rank, suffixes=[\"_mean\", \"_mean_rank\"], how='left', on=['matchId', 'groupId'])\n    \n#     print('make group sum features')\n#     agg = gb_mg[l1].agg('sum')\n#     agg_rank = agg.groupby('matchId')[l1].rank(pct=True).reset_index()\n#     output = output.merge(agg.reset_index(), how='left', on=['matchId', 'groupId'])\n#     output = output.merge(agg_rank, suffixes=[\"_sum\", \"_sum_rank\"], how='left', on=['matchId', 'groupId'])\n    \n#     print('make group min features')\n#     agg = gb_mg[l2].agg('min')\n#     agg_rank = agg.groupby('matchId')[l2].rank(pct=True).reset_index()\n#     output = output.merge(agg.reset_index(), how='left', on=['matchId', 'groupId'])\n#     output = output.merge(agg_rank, suffixes=[\"_min\", \"_min_rank\"], how='left', on=['matchId', 'groupId'])\n    \n#     print('make group max features')\n#     agg = gb_mg[l2].agg('max')\n#     agg_rank = agg.groupby('matchId')[l2].rank(pct=True).reset_index()\n#     output = output.merge(agg.reset_index(), how='left', on=['matchId', 'groupId'])\n#     output = output.merge(agg_rank, suffixes=[\"_max\", \"_max_rank\"], how='left', on=['matchId', 'groupId'])\n    \n#     print('matchType transform & make n_team & maxPlace & matchDuration')\n#     output = output.merge(gb_mg.size().reset_index(name='n_team'), how='left', on=['matchId', 'groupId'])\n#     output = output.merge(gb_m[['matchType', 'maxPlace', 'matchDuration']].agg('mean').reset_index(), how='left', on='matchId')\n    \n#     print('make match mean features')\n#     agg = gb_m[l1].agg('mean').reset_index()\n#     output = output.merge(agg, suffixes=[\"\", \"_match_mean\"], how='left', on=['matchId'])\n    \n#     print('make match max features')\n#     agg = gb_m[l1].agg('max').reset_index()\n#     output = output.merge(agg, suffixes=[\"\", \"_match_max\"], how='left', on=['matchId'])\n    \n#     output.drop([\"matchId\", \"groupId\"], axis=1, inplace=True)\n\n#     del df, df_n, l1, l2, l3, gb_mg, gb_m\n#     gc.collect()\n#     print('complete!')\n    \n#     return output, y_train","df8e8425":"# %%time\n# x_train, y_train = data_transform(train)\n# x_test, _ = data_transform(test, False)","621fb4b1":"# print('transformed train shape :', x_train.shape)\n# x_train.head()","60d9a9b5":"# print('transformed test shape :', x_test.shape)\n# x_test.head()","7621a55c":"# print('y_train length', len(y_train))\n# y_train[:5]","03bf78fc":"# ohe = OneHotEncoder(handle_unknown = 'ignore')\n# ohe_train = pd.DataFrame(ohe.fit_transform(train[['matchType']]).toarray())\n# ohe_test = pd.DataFrame(ohe.transform(test[['matchType']]).toarray())\n# ohe_train.head()","f22a4e1c":"# ohe_train = pd.DataFrame(ohe.fit_transform(train[['matchType']]).toarray())\n# ohe_test = pd.DataFrame(ohe.transform(test[['matchType']]).toarray())","84e118ca":"# train.to_csv('train_preprocessing.csv', index=False)\n# test.to_csv('test_preprocessing.csv', index=False)","2dbc172c":"# Modeling","91e0b964":"# x_train = train.drop(['Id', 'groupId', 'matchId', 'winPlacePerc'], axis = 1)\n# y_train = train['winPlacePerc']\n# x_test = test.drop(['Id', 'groupId', 'matchId'], axis = 1)\n# x_train.head()","b407fee6":"# xgb_params={'eta':0.1,\n#             'max_depth':6,\n#             'objective':'reg:squarederror',\n#             'eval_metric':'mae',\n#             'seed':74,\n#             'tree_method':'gpu_hist',\n#             'predictor':'gpu_predictor'}","9fccd1c8":"# %%time\n\n# kf = KFold(n_splits=3, shuffle=True, random_state=42)\n# oof = np.zeros(len(train))\n# predictions = np.zeros(len(test))\n\n# for fold_, (trn_idx, val_idx) in enumerate(kf.split(x_train, y_train)):\n#     print(\"fold num_: {}\".format(fold_))\n#     trn_data = xgb.DMatrix(x_train.iloc[trn_idx], label=y_train.iloc[trn_idx])\n#     val_data = xgb.DMatrix(x_train.iloc[val_idx], label=y_train.iloc[val_idx])\n    \n#     watchlist = [(trn_data, 'train'), (val_data, 'valid')]\n#     num_round = 10000\n#     model = xgb.train(params = xgb_params,\n#                       dtrain = trn_data,\n#                       num_boost_round  = num_round,\n#                       evals = watchlist,\n#                       verbose_eval = 100,\n#                       early_stopping_rounds = 50\n#                 )\n#     oof[val_idx] = model.predict(xgb.DMatrix(x_train.iloc[val_idx]), ntree_limit = model.best_iteration)\n\n    \n#     predictions += model.predict(xgb.DMatrix(x_test), ntree_limit = model.best_iteration) \/ 5\n    \n# print('\\nCross Validation Is Complete')\n# print(\"CV score: {:<8.5f}\".format(mae(y_train, oof)))","98c083c3":"# fig,ax = plt.subplots(figsize = (10,10))\n# xgb.plot_importance(model, ax = ax)\n# plt.show()","ba395d82":"# param = {'num_leaves': 31,\n#          'learning_rate': 0.1,\n#          'max_depth': 7,\n#          'seed': 2020,\n#          'objective': 'regression',\n#          'boosting_type': 'gbdt',\n#          'metric': 'mae'}","3f0159bd":"# %%time\n\n# kf = KFold(n_splits=3, shuffle=True, random_state=42)\n# oof_lgb = np.zeros((len(train)))\n# lgb_pred = np.zeros((len(test)))\n\n# for fold_, (trn_idx, val_idx) in enumerate(kf.split(x_train, y_train)):\n#     print(\"fold num_: {}\".format(fold_))\n#     trn_data = lgb.Dataset(x_train.iloc[trn_idx], label=y_train[trn_idx])\n#     val_data = lgb.Dataset(x_train.iloc[val_idx], label=y_train[val_idx])\n    \n#     num_round = 15000\n#     model = lgb.train(param, trn_data, num_round, valid_sets = [trn_data, val_data], verbose_eval=1000, early_stopping_rounds = 50)\n#     oof_lgb[val_idx] = model.predict(x_train.iloc[val_idx], num_iteration=model.best_iteration)    \n#     lgb_pred += model.predict(x_test, num_iteration=model.best_iteration) \/ 5\n    \n# print('\\nCross Validation Is Complete')\n# print(\"CV score: {:<8.5f}\".format(mae(y_train, oof_lgb)))","c3040042":"# fig, ax = plt.subplots(figsize=(10, 10))\n# lgb.plot_importance(model, ax=ax, max_num_features=50)\n# plt.show()","96d1687a":"# sub['winPlacePerc'] = lgb_pred\n# sub.head()","121b889a":"# sub['winPlacePerc'] = sub['winPlacePerc'].map(lambda x: 1 if x >= 1 else x)\n# sub['winPlacePerc'] = sub['winPlacePerc'].map(lambda x: 0 if x <= 0 else x)\n# sub.head()","1b61f4ee":"# sub.to_csv('submission.csv', index = False)","39d54a91":"### winPlacePerc","3ef5d463":"PLAYERUNKNOWN'S BATTLEGROUNDS is so fun.","3ebb79a0":"- \uc0ac\ub179\uacfc \uc5d0\ub780\uac94 \ud639\uc740 \ud328\uce58 \uc804\ud6c4\ub85c \uc608\uc0c1 \ub428.","2aaefe51":"![](https:\/\/pmcvariety.files.wordpress.com\/2018\/04\/pubg.jpg?w=1000&h=563&crop=1)","64625c78":"- \uc5b4\ucc28\ud53c \uc774 \ub370\uc774\ud130\ub85c \uc54c \uc218 \uc788\ub294 \ubc29\ubc95\uc774 \uc5c6\ub2e4. \uc2e0\uacbd \uc548\uc4f0\ub294\uac8c \ud3b8\ud560\ub4ef,,","339c3afe":"### matchDuration & matchType","6c5fa168":"assists, DBNOs, revives\ub294 \uc194\ub85c\uc5d0\ub294 \uc5c6\ub2e4.","6d4dc35f":"# Data","ea879c64":"### kills & killPlace & killStreaks","8c1df55a":"### killPoints & rankPoints & winPoints","2111cff5":"### damageDealt","67a7fe18":"- \ub300\ubd80\ubd84 0\uc5d0 \uc3e0\ub824\uc788\ub2e4.","b6aeab2e":"### rideDistance & swimDistance & walkDistance","182bc544":"- \uadf8\ub8f9\uc544\uc774\ub514 1\uac1c\uac00 74\uac1c\uac00 \uc788\ub2e4\ub294 \uac83\uc774 \uc774\uc0c1\ud558\ub2e4. \uc880\ube44\ubaa8\ub4dc\uc778\uac00?\n\n### \uc7a0\uc2dc \uc0b4\ud3b4\ubcf4\uae30","7ddbcfb4":"### Heatmap","522ae64e":"### assists & DBNOs & revives","9e88a848":"- \uc0dd\uac01\ud574\ubcf4\uba74 \ud790\ud15c\uacfc \ubd80\uc2a4\ud2b8\ud15c\uc740 \ubcf4\ud1b5 \uac19\uc774\uc4f0\uc9c0\uc54a\ub098\n- \ub530\ub85c \uc4f8 \ub54c\ub294 \ud558\ub098\uac00 \uc5c6\uac70\ub098 \ub6f0\uc5b4\uac08 \ub54c?","2b0bdea1":"### Quantile","5ce61348":"- 25+-5, 50+-5, 100-10\uc73c\ub85c \ubc94\uc704 \ub098\ub220\uc11c \uadf8\ub798\ud504 \uadf8\ub824\ubd04","818d1191":"### headshotKills & longestKill & roadKills & teamKills","c367d96f":"- vehiclDestroys, teamKills\ub294 0, 1\ub85c \ubc14\uafc8\n- \ub098\uba38\uc9c0 \ubcc0\uc218\ub4e4\uc740 \uadf8\ub8f9\ubc14\uc774 \ud574\uc11c \ubbfc \ub9e5\uc2a4 \ud3c9\uade0 \uc378 4\uac1c \ub9cc\ub4e4\uc5b4\uc90c\n- ELO\ub4e4\uc740 \ub9e4\uce58\ubcc4\ub85c \uc21c\uc704 \ub9cc\ub4e4\uc5b4\uc8fc\uace0 \ubbfc \ub9e5\uc2a4\n\n\n- \ub2e4\uc911\ud0ac\ube44\uc728\n- \ud5e4\ub4dc\uc0f7\ube44\uc728\n- \ub85c\ub4dc\ud0ac\ube44\uc728\n- \uadf8\ub8f9\uc6d0 \uc218\n- \ud0ac\ud50c\ub808\uc774\uc2a4 0~1\ud574\uc11c \ud300\uc6d0\ub4e4\uc758 \uc21c\uc704\ub97c \uc5f4\ub85c \ub123\uc5b4\uc90c -> \ubbfc\ub9e5\uc2a4\ub9cc\n- \ub9e4\uce58\ud0c0\uc785","e344b985":"### boosts & heals","565e3db5":"- \uc2e0\uacbd \uc548\uc368\ub3c4 \ub420 \uac83 \uac19\ub2e4\n- maxPlace\uac00 \uc124\uba85\uc0c1 \ub354 \uc815\ud655\ud55c \uac83 \uac19\uc74c","8829996b":"- rankPoints\ub294 -1\ub3c4 \uc788\uace0 0\ub3c4 \uc788\ub2e4.","e6f2bbb2":"# EDA","3f1c421e":"### vehicleDestroys","ffcb88f0":"# Data feilds\n- Id - Player\u2019s Id\n- groupId - ID to identify a group within a match. If the same group of players plays in different matches, they will have a different groupId each time.\n- matchId - ID to identify match. There are no matches that are in both the training and testing set.\n- assists - Number of enemy players this player damaged that were killed by teammates.\n- boosts - Number of boost items used.\n- damageDealt - Total damage dealt. Note: Self inflicted damage is subtracted.\n- DBNOs - Number of enemy players knocked.\n- headshotKills - Number of enemy players killed with headshots.\n- heals - Number of healing items used.\n- killPlace - Ranking in match of number of enemy players killed.\n- killPoints - Kills-based external ranking of player. (Think of this as an Elo ranking where only kills matter.) If there is a value other than -1 in rankPoints, then any 0 in killPoints should be treated as a \u201cNone\u201d.\n- killStreaks - Max number of enemy players killed in a short amount of time.\n- kills - Number of enemy players killed.\n- longestKill - Longest distance between player and player killed at time of death. This may be misleading, as downing a player and driving away may lead to a large longestKill stat.\n- matchDuration - Duration of match in seconds.\n- matchType - String identifying the game mode that the data comes from. The standard modes are \u201csolo\u201d, \u201cduo\u201d, \u201csquad\u201d, \u201csolo-fpp\u201d, \u201cduo-fpp\u201d, and \u201csquad-fpp\u201d; other modes are from events or custom matches.\n- rankPoints - Elo-like ranking of player. This ranking is inconsistent and is being deprecated in the API\u2019s next version, so use with caution. Value of -1 takes place of \u201cNone\u201d.\n- revives - Number of times this player revived teammates.\n- rideDistance - Total distance traveled in vehicles measured in meters.\n- roadKills - Number of kills while in a vehicle.\n- swimDistance - Total distance traveled by swimming measured in meters.\n- teamKills - Number of times this player killed a teammate.\n- vehicleDestroys - Number of vehicles destroyed.\n- walkDistance - Total distance traveled on foot measured in meters.\n- weaponsAcquired - Number of weapons picked up.\n- winPoints - Win-based external ranking of player. (Think of this as an Elo ranking where only winning matters.) If there is a value other than -1 in rankPoints, then any 0 in winPoints should be treated as a \u201cNone\u201d.\n- numGroups - Number of groups we have data for in the match.\n- maxPlace - Worst placement we have data for in the match. This may not match with numGroups, as sometimes the data skips over placements.\n- winPlacePerc - The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.","b84b9cdf":"### maxPlace & numGroups","a9c59175":"\ub9e4\uce58\ubcc4\ub85c \ubcc0\uc218\ub4e4\uc744 \ud37c\uc13c\ud2b8\ub85c \ub9cc\ub4e4\uc5b4\uc904\uc218\ub3c4\uc788\uc744\ub4ef(\ub9e4\uce58\ubcc4\ub85c \ud45c\uc900\ud654 \ub290\ub08c)(y\uac12\ucc98\ub7fc)  \n\uc774\ub3d9\uac70\ub9ac\ub294 \uc774\ub3d9\uc218\ub2e8\uc5d0 \ub530\ub978 \uc774\ub3d9\uc774 \uac01\uac01 \ud2b9\uc9d5\uc774 \uc5c6\ub2e4\uba74 \ud569\uccd0\ub3c4 \ub420 \ub4ef  \n"}}