{"cell_type":{"51492ee9":"code","44254c08":"code","20be3d75":"code","1b6568ea":"code","490f499f":"code","6dc23412":"code","e8e9af11":"code","712b7f17":"code","355ed446":"code","428d4ce8":"code","b9cc0fc3":"code","5ce69335":"code","be829cbb":"code","674cd71c":"code","0f5bb04c":"code","d3a3f006":"code","a008e80e":"code","390adf99":"code","76f93f61":"code","dfeea134":"code","678cc7cf":"code","0eb8d35c":"code","e1e8dd85":"code","c66bca8a":"code","e8bac671":"code","70de4f48":"code","26fdae64":"code","68cb8154":"code","759bb764":"code","623c1851":"code","16bbe961":"code","430457a4":"code","0c629e3b":"code","09023b7f":"code","d67e9b14":"code","5c8ad61d":"code","afeb2180":"code","3657825b":"code","96e85747":"code","a1d667cf":"code","112950be":"code","fed89c0f":"code","043219ff":"code","4cc79309":"code","eee02eb6":"code","fe56dac2":"code","2deb7cd6":"code","22b4f155":"code","2f9c3a86":"code","b2134117":"code","1fb41eeb":"code","d2452201":"code","cb276131":"code","eeccf1b1":"code","071cb0b2":"code","2356fa6c":"code","d265d7c2":"code","adb9f9d9":"code","48d13741":"code","b95ee4db":"code","19ab214a":"code","7c3935f8":"code","140647d1":"code","10a4e5a7":"code","b7a2fc35":"code","4cd78928":"code","580261ca":"code","287b1e7a":"code","9e74a5ef":"code","6dd71f76":"code","36169dda":"code","ebff1172":"code","6a4d292f":"code","6857bad4":"code","e6810501":"code","30148d7d":"code","4d016a9a":"code","82929e24":"code","db2b2824":"code","59a9f5f1":"code","b61466df":"markdown","a3082600":"markdown","847f0d31":"markdown","f272e5ee":"markdown","9a61868b":"markdown","be35500f":"markdown","e6dd5e98":"markdown","6fdc662c":"markdown","a0319f0c":"markdown","9224a07e":"markdown","4a286588":"markdown","88e9ab53":"markdown","8b040f0d":"markdown","d3a1ea2d":"markdown","f14b3551":"markdown","936ea9fb":"markdown","5f94d88e":"markdown","957e2f30":"markdown","7678f5f9":"markdown","bbcd3631":"markdown","4679ab91":"markdown","b93d813d":"markdown","29706f17":"markdown","7741d4b8":"markdown","a1cf73ec":"markdown","933ecb00":"markdown","507c6733":"markdown","06c2191d":"markdown","7d5d69bb":"markdown","9f5499a4":"markdown","2ee600f0":"markdown","3612ee67":"markdown","ec90baf2":"markdown","7316a8d7":"markdown","f27f394b":"markdown","c1541a35":"markdown","8eae99c4":"markdown","e6cca4dd":"markdown","2e559df7":"markdown","1b05628b":"markdown","e23c046b":"markdown","e8726184":"markdown","ed9c9cc8":"markdown","7aafaace":"markdown","7079f176":"markdown","d8bad16d":"markdown","2e09fe06":"markdown","2dc0613e":"markdown","6ba06b10":"markdown","4026b245":"markdown","2662fcd3":"markdown","e6bb551b":"markdown","099b05c2":"markdown","134ae740":"markdown","a28e47c7":"markdown","794e9c6f":"markdown","d8fc89b0":"markdown","3bc230ea":"markdown","a03fb3c9":"markdown","199652f6":"markdown","0a737311":"markdown","c1307c10":"markdown","64870e15":"markdown","c300cbed":"markdown","1345160c":"markdown","1fd9d486":"markdown","e80a307b":"markdown","7e2a2d9f":"markdown","b1948219":"markdown","161d908a":"markdown","23e2c799":"markdown","90fd522b":"markdown","d11e0884":"markdown","2f2d7eee":"markdown","7c29bffb":"markdown","435a9f82":"markdown","f0d0b984":"markdown","62f7aae4":"markdown","229e166d":"markdown","e5e7fc71":"markdown","f413b5c6":"markdown","37bfbecb":"markdown","d1a8305b":"markdown","d24cf5a2":"markdown","105e4262":"markdown","e9bb7883":"markdown","27178408":"markdown","d4aae871":"markdown","10e5b06a":"markdown","97aa068d":"markdown","d15836a2":"markdown","87cee470":"markdown","33eb6425":"markdown","cf4f0b94":"markdown","a1481ddd":"markdown","9fe4d081":"markdown","962fa233":"markdown","7a814640":"markdown","441be65d":"markdown","0fe35cf0":"markdown","b86913cd":"markdown","d4e66b88":"markdown","dda144a8":"markdown","f10f27cd":"markdown","f0a9f6c2":"markdown","5ca7ee2b":"markdown","25dd4738":"markdown","6cd52872":"markdown","d3668320":"markdown","1d74ba9e":"markdown","65410772":"markdown","0fa1ad8e":"markdown","86dccfa3":"markdown","b4e24b22":"markdown","a8bc712a":"markdown","1cc13aaa":"markdown","4b40e732":"markdown","7957c1d7":"markdown","19b7a8cd":"markdown","81e27d5c":"markdown","62adf13e":"markdown","ea6830e5":"markdown","8bd8d62a":"markdown","9669284c":"markdown","fc4331d1":"markdown"},"source":{"51492ee9":"%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nimport matplotlib.pyplot as plt\n\nplt.style.use('ggplot')\nimport matplotlib.cm as cm\nimport seaborn as sns\n\nimport pandas as pd\nimport numpy as np\nfrom numpy import percentile\nfrom scipy import stats\nfrom scipy.stats import skew\nfrom scipy.special import boxcox1p\n\nimport os, sys\nimport calendar\n\nfrom sklearn.preprocessing import StandardScaler, RobustScaler\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.dummy import DummyRegressor\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline, make_pipeline\nfrom sklearn.model_selection import cross_val_score, cross_validate\nfrom sklearn.model_selection import GridSearchCV, KFold\nfrom sklearn.decomposition import PCA\nfrom sklearn.metrics import mean_squared_log_error, make_scorer\nfrom sklearn.metrics.scorer import neg_mean_squared_error_scorer\n\nfrom sklearn.linear_model import LinearRegression, ElasticNet, Lasso, Ridge, RidgeCV\nfrom sklearn.svm import SVR\nfrom sklearn.kernel_ridge import KernelRidge\nfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\n\nimport xgboost as xgb\nimport lightgbm as lgb\n\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nplt.rc('font', size=18)        \nplt.rc('axes', titlesize=22)      \nplt.rc('axes', labelsize=18)      \nplt.rc('xtick', labelsize=12)     \nplt.rc('ytick', labelsize=12)     \nplt.rc('legend', fontsize=12)   \n\nplt.rcParams['font.sans-serif'] = ['Verdana']\n\n# function that converts to thousands\n# optimizes visual consistence if we plot several graphs on top of each other\ndef format_1000(value, tick_number):\n    return int(value \/ 1_000)\n\npd.options.mode.chained_assignment = None\npd.options.display.max_seq_items = 500\npd.options.display.max_rows = 500\npd.set_option('display.float_format', lambda x: '%.5f' % x)\n\nBASE_PATH = \"\/kaggle\/input\/house-prices-advanced-regression-techniques\/\"","44254c08":"df = pd.read_csv(f\"{BASE_PATH}train.csv\")\ndf_test = pd.read_csv(f\"{BASE_PATH}test.csv\")\ndf.head()","20be3d75":"df.info(verbose=True, null_counts=True)","1b6568ea":"missing = [(c, df[c].isna().mean()*100) for c in df]\nmissing = pd.DataFrame(missing, columns=[\"column_name\", \"percentage\"])\nmissing = missing[missing.percentage > 0]\ndisplay(missing.sort_values(\"percentage\", ascending=False))","490f499f":"plt.figure(figsize=(16,5))\ndf.SalePrice.plot(kind=\"hist\", bins=100, rwidth=0.9)\nplt.title(\"Sales Price value distribution\")\nplt.xlabel(\"Sales Price\")\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,5))\ndf.SalePrice.plot(kind=\"box\", vert=False)\nplt.title(\"Sales Price value distribution\")\nplt.xlabel(\"Sales Price\")\nplt.yticks([0], [''])\nplt.ylabel(\"SalePrice\\n\", rotation=90)\nplt.tight_layout()\nplt.show()","6dc23412":"# calculate percentiles and IQR\nq25 = percentile(df.SalePrice, 25)\nq75 = percentile(df.SalePrice, 75)\niqr = q75 - q25\n\n# calculate normal and extreme upper and lower cut off\ncut_off = iqr * 3\nlower = q25 - cut_off \nupper = q75 + cut_off\n\nprint(f'Percentiles:\\n25th  =  {q25}\\n75th  =  {q75}\\n\\nIQR   =   {iqr}\\nlower = {lower}\\nupper =  {upper}')","e8e9af11":"df[df.SalePrice > upper]","712b7f17":"print(f\"The skewness of SalePrice is: {df.SalePrice.skew():.2f}\")\n\nplt.figure(figsize=(16,9))\n_ = stats.probplot(df['SalePrice'], plot=plt)\nplt.title(\"Probability plot: SalePrice\")\nplt.show()","355ed446":"display(df.select_dtypes(\"number\").skew().sort_values(ascending=False))","428d4ce8":"plt.figure(figsize=(16, 9))\n_ = stats.probplot(df['LotArea'], plot=plt)\nplt.title(\"Probability plot: LotArea\")\nplt.show()","b9cc0fc3":"logSalePrice = np.log1p(df.SalePrice.values)\nprint(f\"Skewness of log transformed sale prices: {pd.DataFrame(logSalePrice).skew().values[0]:.2f}\")\n\nplt.figure(figsize=(16,5));\nplt.hist(logSalePrice, bins=100, rwidth=0.9)\nplt.title(\"SalePrice log transformed\")\nplt.xlabel(\"SalePrice distribution \u2013 log transformed\")\nplt.show()","5ce69335":"display(df.SalePrice.describe())","be829cbb":"# we drop Id (not relevant)\ncorr = df.drop([\"Id\"], axis=1).select_dtypes(include=\"number\").corr()\n\nplt.figure(figsize=(16,16));\ncorr[\"SalePrice\"].sort_values(ascending=True)[:-1].plot(kind=\"barh\")\nplt.title(\"Correlation of numerical features to SalePrice\")\nplt.xlabel(\"Correlation to SalePrice\")\nplt.tight_layout()\nplt.show()","674cd71c":"# sort by SalePrice to make more sense in row order\nplt.subplots(figsize=(16,16));\nsns.heatmap(corr, cmap=\"RdBu\", square=True, cbar_kws={\"shrink\": .7})\nplt.title(\"Correlation matrix of all numerical features\\n\")\nplt.tight_layout()\nplt.show()","0f5bb04c":"# OverallQual: Rates the overall material and finish of the house\nplt.figure(figsize=(16,5));\ndf.groupby(\"OverallQual\")[\"SalePrice\"].count().plot(kind=\"bar\")\nplt.title(\"Count of observations in overall quality categories (\u00abOverallQual\u00bb)\")\nplt.ylabel(\"Count\")\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,10));\nax = sns.boxplot(x=\"OverallQual\", y=\"SalePrice\", data=df)\nplt.title(\"Distribution of sale prices in overall quality categories (\u00abOverallQual\u00bb)\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.tight_layout()\nplt.show()","d3a3f006":"# OverallCond: Rates the overall condition of the house\nplt.figure(figsize=(16,5));\ndf.groupby(\"OverallCond\")[\"SalePrice\"].count().plot(kind=\"bar\")\nplt.title(\"Count of observations in overall condition categories (\u00abOverallCond\u00bb)\")\nplt.ylabel(\"Count\")\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,9));\nax = sns.boxplot(x=\"OverallCond\", y=\"SalePrice\", data=df)\nplt.title(\"Distribution of sale prices in overall condition categories (\u00abOverallCond\u00bb)\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.tight_layout()\nplt.show()","a008e80e":"plt.figure(figsize=(16,9));\nsns.swarmplot(x=\"OverallQual\", y=\"SalePrice\", data=df)\nplt.title(\"Swarm plot: Distribution & count of sale prices in overall *quality* categories\")\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,9));\nsns.swarmplot(x=\"OverallCond\", y=\"SalePrice\", data=df)\nplt.title(\"Swarm plot: Distribution & count of sale prices in overall *condition* categories\")\nplt.tight_layout()\nplt.show()","390adf99":"plt.figure(figsize=(16,5));\nsns.scatterplot(x=\"GrLivArea\", y=\"SalePrice\", data=df, linewidth=0.2, alpha=0.9)\nplt.title(f\"SalePrice vs. GrLivArea\")\nplt.tight_layout()\nplt.show()","76f93f61":"plt.figure(figsize=(16,5));\nsns.scatterplot(x=\"GrLivArea\", y=\"SalePrice\", hue=\"OverallQual\", data=df, \n                legend=\"full\", linewidth=0.2, alpha=0.9)\nplt.title(f\"SalePrice vs. GrLivArea\")\nplt.legend(bbox_to_anchor=(1, 1), loc=2)\nplt.tight_layout()\nplt.show()","dfeea134":"df_cut = pd.DataFrame(pd.cut(np.log(df.GrLivArea), bins=10, labels=np.arange(0,10)))\ndf_comb = pd.concat([df_cut, df.SalePrice], axis=1)\n\nplt.figure(figsize=(16,5));\ndf_comb.groupby(\"GrLivArea\").SalePrice.count().plot(kind=\"bar\")\nplt.title(\"Count of observations in living area (binned values)\")\nplt.ylabel(\"Count\")\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,9));\nax = sns.boxplot(x=\"GrLivArea\", y=\"SalePrice\", data=df_comb)\nplt.title(\"Distribution of observations in living area (binned values)\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.tight_layout()\nplt.show()","678cc7cf":"features = [\"GarageArea\", \"TotalBsmtSF\", \"1stFlrSF\", \"LotArea\"]\n\nfor feature in features:\n    plt.figure(figsize=(16,5));\n    sns.scatterplot(x=feature, y=\"SalePrice\", hue=\"OverallQual\", data=df, \n                legend=\"full\", linewidth=0.2, alpha=0.9)\n    plt.legend(bbox_to_anchor=(1, 1), loc=2)\n    plt.title(f\"SalePrice vs {feature}\")\n    plt.show()","0eb8d35c":"plt.figure(figsize=(16,5));\ndf.groupby(\"YearBuilt\").SalePrice.count().plot(kind=\"bar\")\nplt.title(\"Count of observations in build year\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"YearBuilt\", y=\"SalePrice\", data=df)\nplt.axis(ymin=0, ymax=800000)\nplt.title(\"Distribution of SalePrice in build year\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()","e1e8dd85":"# bin years to decades since plotting every single year would clutter the plot\ndecades = np.arange(1870, 2015, 10)\ndf_cut = pd.cut(df.YearBuilt, bins=decades, labels=decades[:-1])\ndf_comb = pd.concat([df_cut, df.SalePrice], axis=1)\n\nplt.figure(figsize=(16,5));\ndf_comb.groupby(\"YearBuilt\").SalePrice.count().plot(kind=\"bar\")\nplt.title(\"Count of observations in build year (binned values to decades)\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"YearBuilt\", y=\"SalePrice\", data=df_comb)\nplt.axis(ymin=0, ymax=800000)\nplt.title(\"Distribution of SalePrice in build year (binned values to decades)\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()","c66bca8a":"plt.figure(figsize=(16,5));\ndf.groupby(\"YrSold\").SalePrice.count().plot(kind=\"bar\")\nplt.title(\"Count of observations in years of sale\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"YrSold\", y=\"SalePrice\", data=df)\nplt.axis(ymin=0, ymax=800000)\nplt.title(\"Distribution of SalePrice in years of sale\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nmonths_names = calendar.month_name[1:13]\n\nplt.figure(figsize=(16,5));\ndf.groupby(\"MoSold\").SalePrice.count().plot(kind=\"bar\")\nplt.title(\"Count of observations in months of sale\")\nplt.ylabel(\"Count\")\nplt.xticks(ticks=np.arange(0, 12), labels=months_names, rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"MoSold\", y=\"SalePrice\", data=df)\nplt.axis(ymin=0, ymax=800000)\nplt.title(\"Distribution of SalePrice in months of sale\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(ticks=np.arange(0, 12), labels=months_names, rotation=45)\nplt.tight_layout()\nplt.show()","e8bac671":"df[\"Age\"] = df.YrSold - df.YearBuilt\nprint(df.Age.describe())","70de4f48":"decades = np.arange(0, 136, 10)\ndf_cut = pd.cut(df.Age, bins=decades, labels=decades[:-1])\ndf_comb = pd.concat([df_cut, df.SalePrice], axis=1)\n\nplt.figure(figsize=(16,5));\ndf_comb.groupby(\"Age\").SalePrice.count().plot(kind=\"bar\")\nplt.title(\"Count of observations of property age (binned to decades)\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.gca().invert_xaxis()\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"Age\", y=\"SalePrice\", data=df_comb)\nplt.axis(ymin=0, ymax=800000)\nplt.title(\"Distribution of SalePrice respective property age (binned to decades)\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.gca().invert_xaxis()\nplt.tight_layout()\nplt.show()","26fdae64":"# MSSubClass: Identifies the type of dwelling involved in the sale.\norder = df.groupby(\"MSSubClass\").SalePrice.mean().sort_values(ascending=False).index\n\nplt.figure(figsize=(16,5));\ndf_g = df.groupby(\"MSSubClass\").SalePrice.count()\ndf_g = df_g.reindex(order)\ndf_g.plot(kind=\"bar\")\nplt.title(\"Count of observations for type of dwelling\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"MSSubClass\", y=\"SalePrice\", data=df, order=order)\nplt.axis(ymin=0, ymax=800000)\nplt.title(f\"Distribution of SalePrice for type of dwelling\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()","68cb8154":"# BldgType: Type of dwelling\norder = df.groupby(\"BldgType\").SalePrice.mean().sort_values(ascending=False).index\n\nplt.figure(figsize=(16,5));\ndf_g = df.groupby(\"BldgType\").SalePrice.count()\ndf_g = df_g.reindex(order)\ndf_g.plot(kind=\"bar\")\nplt.title(\"Count of observations for type of dwelling (\u00abBldgType\u00bb)\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"BldgType\", y=\"SalePrice\", data=df, order=order)\nplt.axis(ymin=0, ymax=800000)\nplt.title(f\"Distribution of SalePrice for type of dwelling (\u00abBldgType\u00bb)\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()","759bb764":"# create descending list of neighborhood names according to mean of sale price\n# used to sort columns in plots\norder = df.groupby(\"Neighborhood\").SalePrice.mean().sort_values(ascending=False).index\n\nplt.figure(figsize=(16,5));\ndf_g = df.groupby(\"Neighborhood\").SalePrice.count().sort_values(ascending=False)\ndf_g = df_g.reindex(order)\ndf_g.plot(kind=\"bar\")\nplt.title(\"Neighborhood, count of observations\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"Neighborhood\", y=\"SalePrice\", data=df, order=order)\nplt.axis(ymin=0, ymax=800000)\nplt.title(f\"Neighborhood, distribution of SalePrice\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()","623c1851":"order = df.groupby(\"SaleType\").SalePrice.mean().sort_values(ascending=False).index\n\nplt.figure(figsize=(16,5));\ndf_g = df.groupby(\"SaleType\").SalePrice.count().sort_values(ascending=False)\ndf_g = df_g.reindex(order)\ndf_g.plot(kind=\"bar\")\nplt.title(\"SaleType, count of observations\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"SaleType\", y=\"SalePrice\", data=df, order=order)\nplt.axis(ymin=0, ymax=800000)\nplt.title(f\"SaleType, distribution of SalePrice\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()","16bbe961":"order = df.groupby(\"SaleCondition\").SalePrice.mean().sort_values(ascending=False).index\n\nplt.figure(figsize=(16,5));\ndf_g = df.groupby(\"SaleCondition\").SalePrice.count().sort_values(ascending=False)\ndf_g = df_g.reindex(order)\ndf_g.plot(kind=\"bar\")\nplt.title(\"SaleCondition, count of observations\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\nplt.figure(figsize=(16,8));\nax = sns.boxplot(x=\"SaleCondition\", y=\"SalePrice\", data=df, order=order)\nplt.axis(ymin=0, ymax=800000)\nplt.title(f\"SaleCondition, distribution of SalePrice\")\nax.yaxis.set_major_formatter(plt.FuncFormatter(format_1000))\nplt.ylabel(\"SalePrice (in 1000)\")\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()","430457a4":"# start fresh with again reading in the data\ndf = pd.read_csv(f\"{BASE_PATH}train.csv\")\ndf_test = pd.read_csv(f\"{BASE_PATH}test.csv\")\n\n# concat all samples to one dataframe for cleaning\n# need to be careful not to leak data from test to training set! \n# e.g. by filling missing data with mean of *all* samples rather than training samples only\nfeat = pd.concat([df, df_test]).reset_index(drop=True).copy()","0c629e3b":"fig, axes = plt.subplots(nrows=18, ncols=2, figsize=(16,36))\nnum = feat.drop([\"Id\", \"SalePrice\"], axis=1).select_dtypes(\"number\")\n\nfor idx, column in enumerate(num.columns[1:]):\n    num[column].plot(kind=\"hist\", bins=100, rwidth=.9, title=column, ax=axes[idx\/\/2, idx%2])\n    ax=axes[idx\/\/2, idx%2].yaxis.label.set_visible(False)\n\nplt.tight_layout()\nplt.show()","09023b7f":"# get columns with NaN values\nmissing = feat.columns[feat.isna().any()]\nprint(missing)","d67e9b14":"# fix missing values in features\n\n# Alley: NA means no alley acces so we fill with string \u00abNone\u00bb\nfeat.Alley = feat.Alley.fillna(\"None\")\n\n# BsmtQual et al \u2013 NA for features means \"no basement\", filling with string \"None\"\nbsmt_cols = ['BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2', 'BsmtQual']\nfor col in bsmt_cols:\n    feat[col] = feat[col].fillna(\"None\")\n\n# Basement sizes: NaN likely means 0, can be set to int\nfor col in ['BsmtFullBath', 'BsmtHalfBath', 'BsmtUnfSF', 'BsmtFinSF1', 'BsmtFinSF2', 'TotalBsmtSF']:\n    feat[col] = feat[col].fillna(0).astype(int)\n    \n# Electrical: NA likely means unknown, filling with most frequent value SBrkr\nfeat.Electrical = feat.Electrical.fillna(\"SBrkr\")\n\n# Exterior1st: NA likely means unknown, filling with most frequent value VinylSd\nfeat.Exterior1st = feat.Exterior1st.fillna(\"VinylSd\")\n\n# Exterior2nd: NA likely means no 2nd material, filling with \u00abNone\u00bb\nfeat.Exterior2nd = feat.Exterior2nd.fillna(\"None\")\n\n# Fence: NA means \u00abNo Fence\u00bb filling with \u00abNone\u00bb\nfeat.Fence = feat.Fence.fillna(\"None\")\n\n# FireplaceQu: NA means \u00abNo Fireplace\u00bb filling with \u00abNone\u00bb\nfeat.FireplaceQu = feat.FireplaceQu.fillna(\"None\")\n\n# Functional: NA means \u00abtypical\u00bb filling with \u00abTyp\u00bb\nfeat.Functional = feat.Functional.fillna(\"Typ\")\n\n# GarageType et al \u2013 NA means \"no garage\", filling with string \"None\"\ngrg_cols = ['GarageCond', 'GarageFinish', 'GarageQual', 'GarageType']\nfor col in grg_cols:\n    feat[col] = feat[col].fillna(\"None\")\n\n# Garage sizes: NaN means \u00abno garage\u00bb == 0, unsure if build year should be 0?\nfor col in ['GarageArea', 'GarageCars', 'GarageYrBlt']:\n    feat[col] = feat[col].fillna(0).astype(int)\n\n# fix one outlier GarageYrBlt == 2207\nto_fix = feat[feat.GarageYrBlt == 2207].index\nfeat.loc[to_fix, \"GarageYrBlt\"] = int(feat.GarageYrBlt.mean())\n    \n# KitchenQual: filling NaNs with most frequent value \u00abTypical\/Average\u00bb (\u00abTA\u00bb)\nfeat.KitchenQual = feat.KitchenQual.fillna(\"TA\")\n\n# LotFrontage can be set to integer, filling missing values with 0\nfeat.LotFrontage = feat.LotFrontage.fillna(0).astype(int)\n\n# MSZoning filling NaNs with most frequent value \u00abRL\u00bb (residental low density)\nfeat.MSZoning = feat.MSZoning.fillna(\"RL\")\n\n# MSSubClass is encoded numerical but actually categorical\nfeat.MSSubClass = feat.MSSubClass.astype(str)\n\n# Masonry: NA very likely means no masonry so we fill with string \u00abNone\u00bb or 0 for size\nfeat.MasVnrType = feat.MasVnrType.fillna(\"None\")\nfeat.MasVnrArea = feat.MasVnrArea.fillna(0).astype(int)\n\n# MiscFeature means likely no feature, filling with None\nfeat.MiscFeature = feat.MiscFeature.fillna(\"None\")\n\n# PoolQC means likely no pool, filling with None\nfeat.PoolQC = feat.PoolQC.fillna(\"None\")\n\n# SaleType: NaNs likely mean unknown, filling with most frequent value \u00abWD\u00bb\nfeat.SaleType = feat.SaleType.fillna(\"WD\")\n\n# Utilities: NaNs likely mean unknown, filling with most frequent value \u00abAllPub\u00bb\nfeat.Utilities = feat.Utilities.fillna(\"AllPub\")","5c8ad61d":"# label encode ordinal features where there is order in categories\n# unfortunately can't use LabelEncoder or pd.factorize() since strings do not contain order of values\n\nfeat = feat.replace({  \"Alley\":        {\"None\" : 0, \"Grvl\" : 1, \"Pave\" : 2},\n                       \"BsmtCond\":     {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \n                                        \"Gd\" : 4, \"Ex\" : 5},\n                       \"BsmtExposure\": {\"None\" : 0, \"No\" : 2, \"Mn\" : 2, \"Av\": 3, \n                                        \"Gd\" : 4},\n                       \"BsmtFinType1\": {\"None\" : 0, \"Unf\" : 1, \"LwQ\": 2, \"Rec\" : 3, \n                                        \"BLQ\" : 4, \"ALQ\" : 5, \"GLQ\" : 6},\n                       \"BsmtFinType2\": {\"None\" : 0, \"Unf\" : 1, \"LwQ\": 2, \"Rec\" : 3, \n                                        \"BLQ\" : 4, \n                                         \"ALQ\" : 5, \"GLQ\" : 6},\n                       \"BsmtQual\":     {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\": 3, \n                                        \"Gd\" : 4, \"Ex\" : 5},\n                       \"CentralAir\":   {\"None\" : 0, \"N\" : 1, \"Y\" : 2},\n                       \"ExterCond\":    {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\": 3, \n                                        \"Gd\": 4, \"Ex\" : 5},\n                       \"ExterQual\":    {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\": 3, \n                                        \"Gd\": 4, \"Ex\" : 5},\n                       \"Fence\":        {\"None\" : 0, \"MnWw\" : 1, \"GdWo\" : 2, \"MnPrv\": 3, \n                                        \"GdPrv\" : 4},\n                       \"FireplaceQu\":  {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \n                                        \"Gd\" : 4, \"Ex\" : 5},\n                       \"Functional\":   {\"None\" : 0, \"Sal\" : 1, \"Sev\" : 2, \"Maj2\" : 3, \n                                        \"Maj1\" : 4, \"Mod\": 5, \"Min2\" : 6, \"Min1\" : 7, \n                                        \"Typ\" : 8},\n                       \"GarageCond\":   {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \n                                        \"Gd\" : 4, \"Ex\" : 5},\n                       \"GarageQual\":   {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \n                                        \"Gd\" : 4, \"Ex\" : 5},\n                       \"GarageFinish\": {\"None\" : 0, \"Unf\" : 1, \"RFn\" : 2, \"Fin\" : 3},\n                       \"HeatingQC\":    {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \n                                        \"Gd\" : 4, \"Ex\" : 5},\n                       \"KitchenQual\":  {\"None\" : 0, \"Po\" : 1, \"Fa\" : 2, \"TA\" : 3, \n                                        \"Gd\" : 4, \"Ex\" : 5},\n                       \"LandContour\":  {\"None\" : 0, \"Low\" : 1, \"HLS\" : 2, \"Bnk\" : 3, \n                                        \"Lvl\" : 4},\n                       \"LandSlope\":    {\"None\" : 0, \"Sev\" : 1, \"Mod\" : 2, \"Gtl\" : 3},\n                       \"LotShape\":     {\"None\" : 0, \"IR3\" : 1, \"IR2\" : 2, \"IR1\" : 3, \n                                        \"Reg\" : 4},\n                       \"PavedDrive\":   {\"None\" : 0, \"N\" : 0, \"P\" : 1, \"Y\" : 2},\n                       \"PoolQC\":       {\"None\" : 0, \"Fa\" : 1, \"TA\" : 2, \"Gd\" : 3, \n                                        \"Ex\" : 4},\n                       \"Street\":       {\"None\" : 0, \"Grvl\" : 1, \"Pave\" : 2},\n                       \"Utilities\":    {\"None\" : 0, \"ELO\" : 1, \"NoSeWa\" : 2, \"NoSewr\" : 3, \n                                        \"AllPub\" : 4}}\n                     )\n\nfeat.BsmtCond = feat.BsmtCond.astype(int)","afeb2180":"# only one hot encode \u00abtrue\u00bb categoricals...  \n# ... rather than ordinals, where order matters and we already label encoded in the previous cells\n\ndef onehot_encode(data):\n    df_numeric = data.select_dtypes(exclude=['object'])\n    df_obj = data.select_dtypes(include=['object']).copy()\n\n    cols = []\n    for c in df_obj:\n        dummies = pd.get_dummies(df_obj[c])\n        dummies.columns = [c + \"_\" + str(x) for x in dummies.columns]\n        cols.append(dummies)\n    df_obj = pd.concat(cols, axis=1)\n\n    data = pd.concat([df_numeric, df_obj], axis=1)\n    data.reset_index(inplace=True, drop=True)\n    return data\n\nfeat = onehot_encode(feat)","3657825b":"# map months to seasons: 0 == winter, 1 == spring etc.\nseasons = {12 : 0, 1 : 0, 2 : 0, \n           3 : 1, 4 : 1, 5 : 1,\n           6 : 2, 7 : 2, 8 : 2, \n           9 : 3, 10 : 3, 11 : 3}\n\nfeat[\"SeasonSold\"]     = feat[\"MoSold\"].map(seasons)\nfeat[\"YrActualAge\"]    = feat[\"YrSold\"] - feat[\"YearBuilt\"]\n\nfeat['TotalSF1']       = feat['TotalBsmtSF'] + feat['1stFlrSF'] + feat['2ndFlrSF']\nfeat['TotalSF2']       = (feat['BsmtFinSF1'] + feat['BsmtFinSF2'] + feat['1stFlrSF'] + feat['2ndFlrSF'])\nfeat[\"AllSF\"]          = feat[\"GrLivArea\"] + feat[\"TotalBsmtSF\"]\nfeat[\"AllFlrsSF\"]      = feat[\"1stFlrSF\"] + feat[\"2ndFlrSF\"]\nfeat[\"AllPorchSF\"]     = feat[\"OpenPorchSF\"] + feat[\"EnclosedPorch\"] + feat[\"3SsnPorch\"] + feat[\"ScreenPorch\"]\n\nfeat['TotalBath']      = 2 * (feat['FullBath'] + (0.5 * feat['HalfBath']) + feat['BsmtFullBath'] + (0.5 * feat['BsmtHalfBath']))\nfeat[\"TotalBath\"]      = feat[\"TotalBath\"].astype(int)\nfeat['TotalPorch']     = (feat['OpenPorchSF'] + feat['3SsnPorch'] + feat['EnclosedPorch'] + feat['ScreenPorch'] + feat['WoodDeckSF'])\nfeat[\"OverallScore\"]   = feat[\"OverallQual\"] * feat[\"OverallCond\"]\nfeat[\"GarageScore\"]    = feat[\"GarageQual\"] * feat[\"GarageCond\"]\nfeat[\"ExterScore\"]     = feat[\"ExterQual\"] * feat[\"ExterCond\"]\nfeat[\"KitchenScore\"]   = feat[\"KitchenAbvGr\"] * feat[\"KitchenQual\"]\nfeat[\"FireplaceScore\"] = feat[\"Fireplaces\"] * feat[\"FireplaceQu\"]\nfeat[\"GarageScore\"]    = feat[\"GarageArea\"] * feat[\"GarageQual\"]\nfeat[\"PoolScore\"]      = feat[\"PoolArea\"] * feat[\"PoolQC\"]\n\nfeat['hasPool']        = feat['PoolArea'].apply(lambda x: 1 if x > 0 else 0)\nfeat['has2ndFloor']    = feat['2ndFlrSF'].apply(lambda x: 1 if x > 0 else 0)\nfeat['hasGarage']      = feat['GarageArea'].apply(lambda x: 1 if x > 0 else 0)\nfeat['hasBsmt']        = feat['TotalBsmtSF'].apply(lambda x: 1 if x > 0 else 0)\nfeat['hasFireplace']   = feat['Fireplaces'].apply(lambda x: 1 if x > 0 else 0)","96e85747":"# create new ordinal features by binning continuous features\n# log transform values before binning taking into account skewed distributions\n\ncut_cols = [\"LotArea\", \"YearBuilt\", \"YearRemodAdd\", \"MasVnrArea\", 'BsmtFinSF1',\n            'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF', '1stFlrSF', '2ndFlrSF',\n            'LowQualFinSF', 'GrLivArea', \"GarageYrBlt\", 'GarageArea', 'WoodDeckSF', 'OpenPorchSF']\nframes = []\nfor cut_col in cut_cols:\n    tmp = pd.DataFrame(pd.cut(np.log1p(feat[cut_col]), bins=10, labels=np.arange(0,10)))\n    tmp.columns = [cut_col + \"_binned\"]\n    frames.append(tmp)\n    \nbinned = pd.concat(frames, axis=1).astype(int)\nfeat = pd.concat([feat, binned], axis=1)","a1d667cf":"df = pd.read_csv(f\"{BASE_PATH}train.csv\")\ndf_test = pd.read_csv(f\"{BASE_PATH}test.csv\")\n\ndtrain = feat[feat.SalePrice.notnull()].copy()\ndtest  = feat[feat.SalePrice.isnull()].copy()\ndtest  = dtest.drop(\"SalePrice\", axis=1).reset_index(drop=True)\nprint(f\"Raw data shape   : {df.shape}  {df_test.shape}\")\nprint(f\"Clean data shape : {dtrain.shape} {dtest.shape}\")","112950be":"X = df\ny = df.SalePrice\nmetric = 'neg_mean_squared_log_error'\nclf = DummyRegressor(\"median\")\nkfold = KFold(n_splits=10, shuffle=True, random_state=1)\nprint(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")","fed89c0f":"X = df[[\"GrLivArea\"]]\ny = df.SalePrice\nmetric = 'neg_mean_squared_log_error'\nclf = LinearRegression()\nkfold = KFold(n_splits=10, shuffle=True, random_state=1)\nprint(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")","043219ff":"X = df[[\"OverallCond\"]]\ny = df.SalePrice\nmetric = 'neg_mean_squared_log_error'\nclf = LinearRegression()\nkfold = KFold(n_splits=10, shuffle=True, random_state=1)\nprint(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")","4cc79309":"try:\n    X = df[[\"OverallQual\"]]\n    y = df.SalePrice\n    metric = 'neg_mean_squared_log_error'\n    clf = LinearRegression()\n    kfold = KFold(n_splits=10, shuffle=True, random_state=1)\n    print(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")\nexcept Exception as e:\n    print(\"Oh no... An error has occured...\")\n    print(e)","eee02eb6":"feature = \"OverallCond\"\nplt.figure(figsize=(16,5))\nsns.regplot(x=feature, y=\"SalePrice\", data=df)\nplt.title(f\"{feature}\")\nplt.show()\n\nfeature = \"OverallQual\"\nplt.figure(figsize=(16,5))\nax = sns.regplot(x=feature, y=\"SalePrice\", data=df)\nplt.title(f\"{feature}\")\nax.annotate('Negative values!', xy=(1.5, 5_000), xytext=(3, 500_000), \n            arrowprops=dict(facecolor='darkred'))\nplt.show()","fe56dac2":"feature = \"OverallQual\"\nplt.figure(figsize=(16,5))\nsns.regplot(x=feature, y=\"SalePrice\", data=df[df[feature] >= 3])\nplt.title(f\"{feature}\")\nplt.show()","2deb7cd6":"X = df[df.OverallQual >= 3][[\"OverallQual\"]]\ny = df[df.OverallQual >= 3].SalePrice\nmetric = 'neg_mean_squared_log_error'\nclf = LinearRegression()\nkfold = KFold(n_splits=10, shuffle=True, random_state=1)\nprint(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")","22b4f155":"# we select all the categorical data for crossvalidation\nX = df.select_dtypes(\"object\")\ny = df.SalePrice\nmetric = 'neg_mean_squared_log_error'\n\n# use make_pipeline to automatically fill missing values and one hot encode\nclf = make_pipeline(SimpleImputer(strategy='most_frequent', fill_value='missing'), \n                    OneHotEncoder(handle_unknown=\"ignore\"), LinearRegression())\nkfold = KFold(n_splits=10, shuffle=True, random_state=1)\nprint(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")","2f9c3a86":"# again fix OverallQual in order to not crash crossvalidation with our metric\ndf_fixed = df[df.OverallQual >= 3]\n\n# we select all the numerical data for crossvalidation\nX = df_fixed.select_dtypes(\"number\").drop([\"SalePrice\"], axis=1)\ny = df_fixed.SalePrice\nmetric = 'neg_mean_squared_log_error'\nclf = make_pipeline(SimpleImputer(), StandardScaler(), LinearRegression())\nkfold = KFold(n_splits=10, shuffle=True, random_state=1)\nprint(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")","b2134117":"X = df.select_dtypes(\"number\").drop([\"SalePrice\"], axis=1)\n\n# log transform SalePrice to fix skewed distribution\n# we also now can skip removing the samples with OverallQual < 3\ny = np.log1p(df.SalePrice)\nmetric = 'neg_mean_squared_error'\n\nclf = make_pipeline(SimpleImputer(), StandardScaler(), LinearRegression())\nkfold = KFold(n_splits=10, shuffle=True, random_state=1)\nprint(f\"{np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f} Log Error\")","1fb41eeb":"classifiers = [\n               Ridge(), \n               Lasso(), \n               ElasticNet(),\n               KernelRidge(),\n               SVR(),\n               RandomForestRegressor(),\n               GradientBoostingRegressor(),\n               lgb.LGBMRegressor(),\n               xgb.XGBRegressor(objective=\"reg:squarederror\"),\n]\n\nclf_names = [\n            \"ridge      \",\n            \"lasso      \",\n            \"elastic    \",\n            \"kernlrdg   \",\n            \"svr        \",\n            \"rndmforest \", \n            \"gbm        \", \n            \"lgbm       \", \n            \"xgboost    \",\n]","d2452201":"X = dtrain.drop([\"SalePrice\"], axis=1)\ny = np.log1p(dtrain.SalePrice)\nmetric = 'neg_mean_squared_error'\n\nfor clf_name, clf in zip(clf_names, classifiers):\n    kfold = KFold(n_splits=5, shuffle=True, random_state=1)\n    print(f\"{clf_name} {np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f}\")","cb276131":"X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1)\ny = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\nmetric = 'neg_mean_squared_error'\n\nfor clf_name, clf in zip(clf_names, classifiers):\n    kfold = KFold(n_splits=5, shuffle=True, random_state=1)\n    print(f\"{clf_name} {np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f}\")","eeccf1b1":"X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1)\n# we carefully reduce dimensionality from 271 features to 250 dimensions\npca = PCA(n_components=250)\nX_pca = pca.fit_transform(X)\ny = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\nmetric = 'neg_mean_squared_error'\n\nfor clf_name, clf in zip(clf_names, classifiers):\n    kfold = KFold(n_splits=5, shuffle=True, random_state=1)\n    print(f\"{clf_name} {np.sqrt(-cross_val_score(clf, X_pca, y, cv=kfold, scoring=metric)).mean():.4f}\")","071cb0b2":"X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1).copy()\n\nsk = pd.DataFrame(X.iloc[:, :60].skew(), columns=[\"skewness\"])\nsk = sk[sk.skewness > .75]\nfor feature_ in sk.index:\n    X[feature_] = boxcox1p(X[feature_], 0.15)\n\ny = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\nmetric = 'neg_mean_squared_error'\n\nfor clf_name, clf in zip(clf_names, classifiers):\n    kfold = KFold(n_splits=5, shuffle=True, random_state=1)\n    print(f\"{clf_name} {np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f}\")","2356fa6c":"X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1).copy()\ny = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\n\n# again we apply the boxcox transformation\nsk = pd.DataFrame(X.iloc[:, :60].skew(), columns=[\"skewness\"])\nsk = sk[sk.skewness > .75]\nfor feature_ in sk.index:\n    X[feature_] = boxcox1p(X[feature_], 0.15)\n\nclf = xgb.XGBRegressor(objective=\"reg:squarederror\", n_jobs=-1)\ncoeffs = clf.fit(X, y).feature_importances_\ndf_co = pd.DataFrame(coeffs, columns=[\"importance_\"])\ndf_co.index = X.columns\ndf_co.sort_values(\"importance_\", ascending=True, inplace=True)\n\nplt.figure(figsize=(16,9))\ndf_co.iloc[250:, :].importance_.plot(kind=\"barh\")\nplt.title(f\"XGBoost feature importance\")\nplt.show()","d265d7c2":"# use only the most promising classifiers\nclassifiers = [\n               Ridge(), \n               Lasso(), \n               ElasticNet(),\n               KernelRidge(),\n               GradientBoostingRegressor(),\n               lgb.LGBMRegressor(),\n               xgb.XGBRegressor(objective=\"reg:squarederror\"),\n]\n\nclf_names = [\n            \"ridge      \",\n            \"lasso      \",\n            \"elastic    \",\n            \"kernlrdg   \",\n            \"gbm        \", \n            \"lgbm       \", \n            \"xgboost    \",\n]","adb9f9d9":"X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1).copy()\ny = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\nX_test = dtest.copy()\n\nsk = pd.DataFrame(X.iloc[:, :60].skew(), columns=[\"skewness\"])\nsk = sk[sk.skewness > .75]\nfor feature_ in sk.index:\n    X[feature_] = boxcox1p(X[feature_], 0.15)\n    X_test[feature_] = boxcox1p(X_test[feature_], 0.15)","48d13741":"# for clf_name, clf in zip(clf_names, classifiers):\n#     kfold = KFold(n_splits=5, shuffle=True, random_state=1)\n#     print(f\"{clf_name} {np.sqrt(-cross_val_score(clf, X, y, cv=kfold, scoring=metric)).mean():.4f}\")","b95ee4db":"predictions = []\n\nfor clf_name, clf in zip(clf_names, classifiers):\n    clf.fit(X, y)\n    preds = clf.predict(X_test)\n    # reverse log transform predicted sale prices with np.expm1()\n    predictions.append(np.expm1(preds))","19ab214a":"print(df.SalePrice.describe())","7c3935f8":"p_stats = [df.SalePrice.describe()]\n\nfor idx, clf_name in zip(range(0,7), clf_names):\n    plt.figure(figsize=(16,5))\n    p_tmp = pd.DataFrame(predictions[idx], columns=[\"preds\"])\n    sns.distplot(df.SalePrice)\n    sns.distplot(p_tmp)\n    plt.legend([\"sales prices: trained\", \"sales price: predicted\"])\n    plt.xlim(0, 400_000)\n    plt.title(f\"{clf_name.strip()}: distributions of trained and predicted values\")\n    plt.tight_layout()\n    plt.show()\n    print(f\"{clf_name.strip()} min\/max of predicted sales prices\")\n    print(f\"{p_tmp.min().values[0]:.0f} {p_tmp.max().values[0]:.0f}\")\n    p_stats.append(p_tmp.describe())","140647d1":"for idx, clf_name in enumerate(clf_names):\n    p = pd.DataFrame(predictions[idx])\n    # filter all values beyond max sale price in training data\n    p_out = p[p[0] > 755_000].astype(int) \n    if len(p_out) > 0:\n        p_out.columns = [f\"{clf_name.strip().capitalize()} _ predicted SalePrice\"]\n        display(p_out)","10a4e5a7":"dtest.loc[1089][[\"YearBuilt\", \"YrSold\", \"YrActualAge\"]]","b7a2fc35":"X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1)\n\nsk = pd.DataFrame(X.iloc[:, :60].skew(), columns=[\"skewness\"])\nsk = sk[sk.skewness > .75]\nfor feature_ in sk.index:\n    X[feature_] = boxcox1p(X[feature_], 0.15)\n\ny = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\nmetric = 'neg_mean_squared_error'\n\npredictions = []\n# create an array for stats, set stats of training set as first column\npred_stats = [df.SalePrice.describe()]\n\nfor clf_name, clf in zip(clf_names, classifiers):\n    clf.fit(X, y)\n    preds = clf.predict(X_test)\n    # reverse log transform predicted sale prices with np.expm1()\n    predictions.append(np.expm1(preds))\n    pred_stats.append(pd.DataFrame(np.expm1(preds)).describe())\n\n# calculate correlations of predicted values between each of the models\npr_corr = pd.DataFrame(predictions).T.corr()\npr_corr.columns = [x.strip() for x in clf_names]\npr_corr.index = [x.strip() for x in clf_names]\nplt.figure(figsize=(16,9))\nsns.heatmap(pr_corr, cmap=\"RdBu\", square=True, cbar_kws={\"shrink\": .8})\nplt.title(\"Correlation of predictions of trained models\")\nplt.tight_layout()\nplt.show()","4cd78928":"p = pd.concat(pred_stats, axis=1)\ncols = [\"training data\"]\ncols.extend(clf_names)\np.columns = cols\nplt.figure(figsize=(16,9))\nsns.heatmap(p.corr(), cmap=\"RdBu\", square=True, cbar_kws={\"shrink\": .8})\nplt.title(\"Correlation of statistics of trained models\")\nplt.tight_layout()\nplt.show()","580261ca":"# X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1)\n# y = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\n# metric = 'neg_mean_squared_error'\n\n# sk = pd.DataFrame(X.iloc[:, :60].skew(), columns=[\"skewness\"])\n# sk = sk[sk.skewness > .75]\n# for feature_ in sk.index:\n#     X[feature_] = boxcox1p(X[feature_], 0.15)","287b1e7a":"# # GridSearchCV Ridge\n# ridge = make_pipeline(RobustScaler(), Ridge(alpha=15, random_state=1))\n# param_grid = {\n#     'ridge__alpha' : np.linspace(12, 18, 10),\n#     'ridge__max_iter' : np.linspace(10, 200, 5),\n# }\n# search = GridSearchCV(ridge, param_grid, cv=5, scoring=metric, n_jobs=-1)\n# search.fit(X, y)\n# print(f\"{search.best_params_}\")\n# print(f\"{np.sqrt(-search.best_score_):.4}\")","9e74a5ef":"# # GridSearchCV Lasso\n# lasso = make_pipeline(RobustScaler(), Lasso(alpha=0.00044, random_state=1))\n# param_grid = {'lasso__alpha' : np.linspace(0.00005, 0.001, 30)}\n# search = GridSearchCV(lasso, param_grid, cv=5, scoring=metric, n_jobs=-1)\n# search.fit(X, y)\n# print(f\"{search.best_params_}\")\n# print(f\"{np.sqrt(-search.best_score_):.4}\")","6dd71f76":"# # GridSearchCV ElasticNet\n# elastic = make_pipeline(RobustScaler(), ElasticNet(alpha=0.0005, l1_ratio=1, random_state=1))\n# param_grid = {\n#     'elasticnet__alpha' : np.linspace(0.0001, 0.001, 10),\n#     'elasticnet__l1_ratio' : np.linspace(0.5, 1, 10),\n# }\n# search = GridSearchCV(elastic, param_grid, cv=5, scoring=metric, n_jobs=-1)\n# search.fit(X, y)\n# print(f\"{search.best_params_}\")\n# print(f\"{np.sqrt(-search.best_score_):.4}\")","36169dda":"# # GridSearchCV KernelRidge\n# kernel = KernelRidge(alpha=1)\n# param_grid = {'alpha' : np.linspace(0.001, 1, 30)}\n# search = GridSearchCV(kernel, param_grid, cv=5, scoring=metric, n_jobs=-1)\n# search.fit(X, y)\n# print(f\"{search.best_params_}\")\n# print(f\"{np.sqrt(-search.best_score_):.4}\")","ebff1172":"# # GridSearchCV GBM\n# # huber loss is considered less sensitive to outliers\n# gbm = GradientBoostingRegressor(n_estimators=2500, learning_rate=0.04,\n#                                    max_depth=2, max_features='sqrt',\n#                                    min_samples_leaf=15, min_samples_split=10, \n#                                    loss='huber', random_state=1)\n# param_grid = {\n#     'n_estimators' : [2500],\n#     'learning_rate' : [0.03, 0.04, 0.05],\n#     'max_depth' : [2],\n# }\n# search = GridSearchCV(gbm, param_grid, cv=5, scoring=metric, n_jobs=-1)\n# search.fit(X, y)\n# print(f\"{search.best_params_}\")\n# print(f\"{np.sqrt(-search.best_score_):.4}\")","6a4d292f":"# # GridSearchCV LightGBM\n# lgbm = lgb.LGBMRegressor(objective='regression', num_leaves=5,\n#                         learning_rate=0.03, n_estimators=8000,\n#                         max_bin=55, bagging_fraction=0.8,\n#                         bagging_freq=5, feature_fraction=0.23,\n#                         feature_fraction_seed=9, bagging_seed=9,\n#                         min_data_in_leaf=6, min_sum_hessian_in_leaf=11)\n# param_grid = {\n#     'n_estimators' : [8000],\n#     'learning_rate' : [0.03],\n# }\n# search = GridSearchCV(clf, param_grid, cv=5, scoring=metric, n_jobs=-1)\n# search.fit(X, y)\n# print(f\"{search.best_params_}\")\n# print(f\"{np.sqrt(-search.best_score_):.4}\")","6857bad4":"# # GridSearchCV XGBoost\n# xgbreg = xgb.XGBRegressor(objective=\"reg:squarederror\",\n#                              colsample_bytree=0.46, gamma=0.047, \n#                              learning_rate=0.04, max_depth=2, \n#                              min_child_weight=0.5, n_estimators=2000,\n#                              reg_alpha=0.46, reg_lambda=0.86,\n#                              subsample=0.52, random_state=1, n_jobs=-1)\n\n# param_grid = {\n#     'xgbregressor__max_depth' : [2],\n#     'xgbregressor__estimators' : [1600, 1800, 2000],\n#     \"xgbregressor__learning_rate\" : [0.02, 0.03, 0.04],\n#     \"xgbregressor__min_child_weight\" : [0.2, 0.3, 0.4],\n#     }\n# search = GridSearchCV(clf, param_grid, cv=3, scoring=metric, n_jobs=-1)\n# search.fit(X, y)\n# print(f\"{search.best_params_}\")\n# print(f\"{np.sqrt(-search.best_score_):.4}\")","e6810501":"# # try a stacked regressor on top of the seven tuned classifiers \n# # leaving out xgboost in the stack for now since it seems to crash the stacked regressor\n# clf_to_stack = [lasso, ridge, elastic, kernel, gbm, lgbm]\n\n# stack = StackingCVRegressor(regressors=(clf_to_stack),\n#                             meta_regressor=xgb.XGBRegressor(objective=\"reg:squarederror\", n_jobs=-1), \n#                             use_features_in_secondary=True)\n\n# print(f\"{np.sqrt(-cross_val_score(stack, X, y, scoring=metric)).mean():.4f} Log Error\")","30148d7d":"X = dtrain[dtrain.GrLivArea < 4000].drop([\"SalePrice\"], axis=1)\ny = np.log1p(dtrain[dtrain.GrLivArea < 4000].SalePrice)\n\nX_test = dtest\n# fixing the outlier where YrSold is earlier than YrBuilt\nX_test.loc[1089][\"YrSold\"] = 2009\nX_test.loc[1089][\"YrActualAge\"] = 0\n\nmetric = 'neg_mean_squared_error'","4d016a9a":"# apply box cox transformation on numerical features\n# skipping the one hot encoded features as well as engineered ones\nsk = pd.DataFrame(X.iloc[:, :60].skew(), columns=[\"skewness\"])\nsk = sk[sk.skewness > .75]\nfor feature_ in sk.index:\n    X[feature_] = boxcox1p(X[feature_], 0.15)\n    X_test[feature_] = boxcox1p(X_test[feature_], 0.15)","82929e24":"ridge   = make_pipeline(RobustScaler(), Ridge(alpha=15, random_state=1))\nlasso   = make_pipeline(RobustScaler(), Lasso(alpha=0.0005, random_state=1))\nelastic = make_pipeline(RobustScaler(), ElasticNet(alpha=0.0005, \n                                                   l1_ratio=1, random_state=1))\nkernel  = KernelRidge(alpha=1.0)\n\ngbm = GradientBoostingRegressor(n_estimators=2500, learning_rate=0.04,\n                                   max_depth=2, max_features='sqrt',\n                                   min_samples_leaf=15, min_samples_split=10, \n                                   loss='huber', random_state=1)\n\nlgbm = lgb.LGBMRegressor(objective='regression', num_leaves=5,\n                        learning_rate=0.03, n_estimators=8000,\n                        max_bin=55, bagging_fraction=0.8,\n                        bagging_freq=5, feature_fraction=0.23,\n                        feature_fraction_seed=9, bagging_seed=9,\n                        min_data_in_leaf=6, min_sum_hessian_in_leaf=11)\n\nxgbreg = xgb.XGBRegressor(objective=\"reg:squarederror\",\n                             colsample_bytree=0.46, gamma=0.047, \n                             learning_rate=0.04, max_depth=2, \n                             min_child_weight=0.5, n_estimators=2000,\n                             reg_alpha=0.46, reg_lambda=0.86,\n                             subsample=0.52, random_state=1, n_jobs=-1)","db2b2824":"classifiers = [ridge, lasso, elastic, kernel, gbm, lgbm, xgbreg]\nclf_names   = [\"ridge  \", \"lasso  \", \"elastic\", \"kernel \", \"gbm    \", \"lgbm   \", \"xgbreg \"]\n\npredictions_exp = []\n\nfor clf_name, clf in zip(clf_names, classifiers):\n    print(f\"{clf_name} {np.sqrt(-cross_val_score(clf, X, y, scoring=metric).mean()):.5f}\")\n    clf.fit(X, y)\n    preds = clf.predict(X_test)\n    predictions_exp.append(np.expm1(preds))","59a9f5f1":"prediction_final = pd.DataFrame(predictions_exp).mean().T.values\nsubmission = pd.DataFrame({'Id': df_test.Id.values, 'SalePrice': prediction_final})\nsubmission.to_csv(f\"submission.csv\", index=False)","b61466df":"Amazing!! Just removing 4 observations yields much better results for almost all classifiers. We are now ready to choose the classifiers, tune hyperparameters and make a submission. \n\nBefore that let's conduct a last experiment and **find out, what the classifiers like about our data...**","a3082600":"Oh yes. Great step forward. Just **log transforming y gets us to rank #3000.** ","847f0d31":"The correlation is clearly noticable. \n\nWe also can observe some of **the hefty outliers that Dean De Cock has warned us** about. There are two data points of very high living area and low sale price and two with a rather high sale price.\n\nWe try to improve the visualisation by adding the overall condition as hue to the plot. ","f272e5ee":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 04: Finally using cleaned data and trying other classifiers","9a61868b":"**Progress!** Let's try just all the categoricals instead.","be35500f":"<font color=\"darkgreen\"> \n## \ud83d\ude0e Conclusions from experiments...","e6dd5e98":"Most observations are:\n\n- \u00ab1-STORY 1946 & NEWER ALL STYLES\u00bb (MSSubClass == 20)\n- \u00ab2-STORY 1946 & NEWER\u00bb (60) or\n- \u00ab1-1\/2 STORY FINISHED ALL AGES\u00bb (50)\n\n2-story buildings (60) yield the highest prices on average among these.\n\nA similar feature that describes the type of dwelling is `BldgType`.","6fdc662c":"<font color=\"purple\"> \n## Experiment 10: How do we pick the most diverse set of models for an ensemble?","a0319f0c":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 03: Un-sk(r)ew the distribution of SalePrice","9224a07e":"Makes sense: low overall quality data points plot with light hue in lower ranges of living area and sale price. \n\nWhat if we **bin the continuous feature `GrLivArea` to a categorical** and plot again counts and distribution?","4a286588":"<font color=\"purple\"> \n## Experiment 08: Which features do the classifiers pick up?","88e9ab53":"Let's examine our target variable \u2013 `SalePrice` and at the same time derive information from many corresponding features. We will basically explore the data from the perspective of price.","8b040f0d":"# 1. Exploratory data analysis","d3a1ea2d":"**4 features have more than 50% missing values**. We could think about dropping these and will examine this later.","f14b3551":"<span style=\"color:darkgreen\">\n**Pros:**\n- I was really surprised to see **how much effect removing just a few outliers and fixing the skewed distribution of the target variable had.**\n- A lot of the gains I seem to have derived from trying, combining and tuning various classifiers rather than from feature engineering.\n- **Most of my insights and learning came from making mistakes and fixing these.** Especially be visualizing the relevant parts of the data.\n- The Ames Housing data set is comfortably small to allow for fast iteration and experimentation. \n- At the same time the data feels sufficiently complex to learn a lot. \n    \n<span style=\"color:darkred\">\n**Cons:**\n- I am **not satisfied with the results of the data cleaning and feature engineering.** The results are pretty close to what I can achieve with [my automated sklearn Pipeline playground](https:\/\/www.kaggle.com\/chmaxx\/sklearn-pipeline-playground-for-10-classifiers). Either I have made mistakes that spoiled the efforts. Or there is not much that we can gain on this data with cleaning and creating new variables.\n- I am **disappointed with the results of the StackingCV classifier.** Ensembling by simply averaging brought quite some improvement. I would have expected the Stacking Regressor to be more valuable. Again: I suspect my mistakes being the culprit. Others seem to have made much more progress employing stacking.","936ea9fb":"Finally let's have a **look at sale types and conditions**.","5f94d88e":"We see \n\n- 1267 \u00abWarranty Deed \u2013 Conventional\u00bb (WD) sales\n- 122 properties that were sold as \u00abNew\u00bb\n- 43 \u00abCourt Officer Deed\/Estate\u00bb (COD)\n\nNew houses sell on average for the highest prices.","957e2f30":"![](https:\/\/i.imgur.com\/VV8pvil.jpg)\nPhoto by Oliver Hale","7678f5f9":"# Boston Reloaded \u2013 The Ames Housing Data Set \ud83c\udfe1","bbcd3631":"![](https:\/\/i.imgur.com\/DPq4YkX.jpg)\nPhoto by Patryk Gradys","4679ab91":"## \ud83d\udd0d Oh... And where is Ames, actually?","b93d813d":"# 2. Data cleaning and formatting","29706f17":"`LotArea` looks relevant and is one of the most skewed features.","7741d4b8":"Again: Many correlations makes sense on a first glance. E.g. `OverallQual` sticks out highly correlated regarding `SalePrice`. Which is interesting since it is \"the overall material and finish of the house\" rather than the \u201coverall condition of the house\" `OverallCond`.  \n\nThere are many details too that we could follow up, just for curiosities sake. E.g. Enclosed porches seem to have fallen out of favor \u2013 `YearBuilt` is negatively correlated to `EnclosedPorc`.\n\nTo examine the relevant correlations more thoroughly we plot `SalePrice` vs `OverallQual`. The latter is a categorical ranging from \u00abVery poor\u00bb = 1 to \u00abVery Excellent\u00bb = 10. **Rather than a scatter plot we use box plots for categoricals.**\n\n><span style=\"color:darkred\">Interpreting box plots we have to be very careful to **not confuse width of distribution with count of observations!** A long box in the plot might visually suggest many values, which is misleading. \n    \nLet's validate that by plotting bars for counts first.","a1cf73ec":"---\n\n**\ud83d\udce3 First I'd like to shout out and say thanks to [Pedro Marcelino](https:\/\/www.kaggle.com\/pmarcelino\/comprehensive-data-exploration-with-python), [Serigne](https:\/\/www.kaggle.com\/serigne\/stacked-regressions-top-4-on-leaderboard) and [juliencs](https:\/\/www.kaggle.com\/juliencs\/a-study-on-regression-applied-to-the-ames-dataset) for sharing their impressive work on the dataset.** Very cool and informative kernels and\/or ideas too from [Kirill Aleksandrovich](https:\/\/www.kaggle.com\/aleksandrovich\/top-8-ensemble-of-models), [maasguantity](https:\/\/www.kaggle.com\/massquantity\/all-you-need-is-pca-lb-0-11421-top-4#Ensemble-Methods), [Aleksandrs Gehsbargs](https:\/\/www.kaggle.com\/agehsbarg\/top-10-0-10943-stacking-mice-and-brutal-force), [deja vu](https:\/\/www.kaggle.com\/dejavu23\/house-prices-eda-to-ml-beginner\/notebook) and many others.\n\n>*If you use parts of this notebook in your own scripts or kernels, please give credit (for example link back, upvote and send flowers). Thanks! \nAnd I very much appreciate your feedback or comments! Thanks for that too. \ud83d\udc4d*\n\nFor an [easy playground for 10+ classifiers on the Ames Housing data have a look here](https:\/\/www.kaggle.com\/chmaxx\/sklearn-pipeline-playground-for-10-classifiers\/edit\/run\/20665600).\n\n---","933ecb00":"Let's compare this to the predicted values.","507c6733":"There is **some logical order in the columns**. They roughly seem to go **from general to detail** and describe the outside first (e.g. Zoning, Street, LotArea), then the inside going from basement and floors to functional rooms and areas. Lastly we get information about the sale. The provided data description text file conveniently follows this exact order. \n\nSeveral features have **missing values**. Let's dig deeper into this.","06c2191d":"## \ud83e\udd14 Let's get started \u2013 the Problem Definition","7d5d69bb":"**Even more improvement. Just training on the raw numerical values gets us around #3600 on the Leaderboard.**","9f5499a4":"Now back to sale price. Let's log transform the values and pot again.","2ee600f0":"- The wide mayority of properties are \u00abSingle-family Detached\u00bb. \n- Townhouse End Units (TwhnsE) come second pricewise and are more expensive than Inside Units (Twhns). Makes sense...\n- \u00abTwo-family Conversions, originally built as one-family dwelling\u00bb are the least expensives properties on average.\n\n**How do neighborhood and zoning affect prices?**","3612ee67":"So there is one single observation in the test data with the index 1089, that very likely can't accurately be predicted by the linear classifiers. \n\nI have looked at the features and **found a possible error in the test data: The house was sold BEFORE it was built...** \ud83d\ude03","ec90baf2":"Several [Kagglers](https:\/\/www.kaggle.com\/serigne\/stacked-regressions-top-4-on-leaderboard) **apply a [box cox transformation](http:\/\/onlinestatbook.com\/2\/transformations\/box-cox.html) to skewed numerical features**. Cool idea worth persuing too. \n\nLet's quickly validate this with our data.","7316a8d7":"<span style=\"color:darkgreen\">\n- We get **astonishingly decent results from training on raw data and single features only.**\n- We get **decent results too, if we just train on either raw numerical or categorical data.**\n- We **achieved *some* improvement by data cleaning and feature engineering, but not that much.** Doea that change if we tune hyperparameters? \n- **Log transforming SalePrice is very effective as well as box cox transforming several other skewed features.**\n- **Removing the outliers beyond 4000 square feet in `GrLivArea` is super effective too.**\n- Looking closely at predictions is valuable. We found a hefty outlier that we need to fix before submission.\n- We have identified the differences in our trained models which will help us building an ensemble.\n- Applying PCA didn't help in any way to reduce possible collinearity.\n\nPromising scores from \n- Ridge \n- Lasso\n- ElasticNet\n- KernelRidge\n- GBM\n- LightGBM\n- XGBoost \n\nLinearRegression, Support Vector and Random Forest Regression do not seem to work well on the engineered data. There might be too much collinearity in the expanded features or in the data set in general.\n\n<\/span>","f27f394b":"# References","c1541a35":"So we should either cap the prediction for that observations to reasonable maximum or correct the erroneous feature in the test set.","8eae99c4":"By the way: **If we want to visually _combine count and distribution_ we can use a [swarmplot](https:\/\/seaborn.pydata.org\/generated\/seaborn.swarmplot.html#seaborn.swarmplot).** ","e6cca4dd":"The least expensive area \u2013 Meadow village \u2013 in turn lies southwest of the centre, very close to the highway and the airport. So it might be quite noisy there.","2e559df7":"# 0. Import libraries and set globals","1b05628b":"**Ridge, Lasso, ElasticNet and KernelRidge predict a maximum value of way more than 1 million USD** which doesn't seem right at all. \n\nLet's see where the outlier(s) come from.","e23c046b":"Oops... What's happening here? \n\n**The Linear Regressor predicts negative values for SalePrice** and that crashes crossvalidation scoring with our metric (R2 scores would be working). \n\nBut why negative values at all? Let's dig deeper by visualizing the relationship between the two variables and getting a regression line with seaborn's `regplot`.","e8726184":"[Pedro Marcelino](https:\/\/www.kaggle.com\/pmarcelino\/comprehensive-data-exploration-with-python)<br>\n[Serigne](https:\/\/www.kaggle.com\/serigne\/stacked-regressions-top-4-on-leaderboard)<br>\n[juliencs](https:\/\/www.kaggle.com\/juliencs\/a-study-on-regression-applied-to-the-ames-dataset)<br>\n[Kirill Aleksandrovich](https:\/\/www.kaggle.com\/aleksandrovich\/top-8-ensemble-of-models)<br>\n[maasguantity](https:\/\/www.kaggle.com\/massquantity\/all-you-need-is-pca-lb-0-11421-top-4#Ensemble-Methods)<br>\n[Alexandru Papiu](https:\/\/www.kaggle.com\/apapiu\/regularized-linear-models)<br>\n[MJ Bahmani](https:\/\/www.kaggle.com\/mjbahmani\/the-data-scientist-s-toolbox-tutorial-1)<br>\n[SonniHS](https:\/\/www.kaggle.com\/sonnihs\/house-prices)<br>\n[Aleksandrs Gehsbargs](https:\/\/www.kaggle.com\/agehsbarg\/top-10-0-10943-stacking-mice-and-brutal-force)<br>\n[deja vu](https:\/\/www.kaggle.com\/dejavu23\/house-prices-eda-to-ml-beginner\/notebook)<br>\n\n[DanB](https:\/\/www.kaggle.com\/dansbecker\/xgboost)<br>\n[OnlineStatBook](http:\/\/onlinestatbook.com\/2\/index.html)<br>\n[Google ML Guides](https:\/\/developers.google.com\/machine-learning\/crash-course\/ml-intro)<br>\n[Jake VanderPlas's Data Science Handbook](https:\/\/nbviewer.jupyter.org\/github\/jakevdp\/PythonDataScienceHandbook\/blob\/master\/notebooks\/00.00-Preface.ipynb)\n\n[Blog Post NYT Data Science Academy](https:\/\/nycdatascience.com\/blog\/student-works\/predicting-house-price-in-ames-iowa-using-machine-learning\/)","ed9c9cc8":"![](https:\/\/i.imgur.com\/4ujY3Q8.jpg)\nPhoto by VanveenJF","7aafaace":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 07: Use boxcox transform numerical features to improve score?","7079f176":"- On average the properties were 37 years old at the time of sale (with a mean of 35 very close to that).\n- On average houses can be +\/- 30 years older or younger than that at time of sale.\n- The oldest house was 136 years old and we have sales of house that were built in the year of sale. ","d8bad16d":"Not surprisingly most positively correlated features are e.g. the overall quality, living area, number and area of garages. ","2e09fe06":"## \u26a0\ufe0f Warning: Outliers!","2dc0613e":"![](https:\/\/i.imgur.com\/3cuLUjm.jpg)\nPhoto by Michael Mroczek","6ba06b10":"Let's get more **detailed stats about the distribution**.","4026b245":"## \ud83d\udee0 For what was the dataset created?","2662fcd3":"How are **numerical features correlated to `SalePrice`**? ","e6bb551b":"We are asked to **predict sale prices for residential real estate properties** from describing features. We have a training set with 1460 observations and corresponding prices. We need to make predictions for 1459 observations where the price is not known to us.\n\n><span style=\"color:darkgreen\">**Our goal is to use the Ames Housing data set to build a machine learning model that can predict the sale price of a residential property.**\n\nThe data in the training set includes the sale price, which makes this **a supervised regression machine learning task**:\n\n>**Supervised**: We have access to both the features and the target and our goal is to train a model that can learn a mapping between the two.\n>**Regression**: The sale price is a continuous variable.\n\nIdeally we want to develop a model that is both **accurate** \u2014\u200ait can predict the sale price close to the true value\u200a\u2014\u200aand **interpretable**\u200a\u2014\u200awe can understand the model predictions. ","099b05c2":"## \ud83e\udd11 It's all about the money \u2013 examining our target variable","134ae740":"Job done... On to training on the full data set and submission...","a28e47c7":"Let's see how far we get with **just one single feature and simple Linear Regression.** I choose the size of the living area `GrLivArea` because we have seen during EDA that this has a strong correlation to `SalePrice`.","794e9c6f":"- The pure linear models Ridge, Lasso and ElasticNet are highly correlated. \n- The other obvious group seems to GBM, LightGBM and XGBoost. \n- KernelRidge sticks out in itself.\n\nLet's do the same \u2013 but now based on the statistics of the predicted values rather than on the values itself.","d8fc89b0":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 06: Use PCA to reduce collinearity?","3bc230ea":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 0: Get a baseline with the DummyRegressor","a03fb3c9":"## How it all began...","199652f6":"And thats a map of **Ames' residental areas** (neighborhoods) provided again by Dean De Cock ([full size PDF here](https:\/\/ww2.amstat.org\/publications\/jse\/v19n3\/decock\/AmesResidential.pdf)):\n![](https:\/\/i.imgur.com\/FM0XoQy.jpg)","0a737311":"The north of Ames seems particularly pricey. A quick look on the map reveals parks, a lake and \u2013 golf clubs...","c1307c10":"![](https:\/\/i.imgur.com\/UKwOY5z.png)","64870e15":"![](https:\/\/i.imgur.com\/oZLcu99.png)","c300cbed":"This gives us some more insight:\n\n* Prices **range from 34'900 USD to a hefty 755'000**.\n* The **average sale price (the mean) is 180'921 USD**. \n* The **median is lower: 163'000 USD**. This is to be expected since the _mean_ is sensitive to outliers and in this case pulled towards outlying higher values. \n* The **standard deviation** is around 79k. So on average, prices in the dataset tend to vary by this amount around the mean of ~180k.","1345160c":"We observe that:\n- A higher overall quality results in higher sale price (obviously).\n- **The higher the quality the wider the price range.** Poor & very poor quality buildings have almost the same price range while very good to excellent properties have a much wider range of possible sale prices.\n- **Most sales range from average to very good (5-8).**\n- There are only very few sales on the tails (1-3, 9-10). \n- In most categories we seem to have some outliers on both ends.\n\nLet's plot the **overall condition** in comparison.","1fd9d486":"We are now **examining the relation of our target variable to other interesting correlated features** and start with several numerical **features of size.**","e80a307b":"We observe that:\n\n- Most of the house were built 1950 and later.\n- A good third of all properties was built 1990 and later.\n- Newer houses tend to yield a little higher mean of sale price.\n- House from 1870 to 1880 have an unusual variance in sale price \u2013 again very likely to outliers\n\nLet's have a look at the time of sales...","7e2a2d9f":"![](https:\/\/i.imgur.com\/4gagR4C.jpg)\nPhoto by Erico Marcelino","b1948219":"## Congrats! We made it... ","161d908a":"# 3. Feature engineering","23e2c799":"We see that:\n- Only very few properties are rated below average (5). \n- Average (5) is the category value of overall condition that has by far the most counts.\n- **The mean sale price for \u00abAverage\u00bb is higher than for \u00abAbove Average\u00bb and higher.**\n\nOne possible explanation could be that as long as the house is in average condition it can be fixed to a higher condition without that much additional cost. If the base materials and finish are not good, than a prospective owner would have much more difficulties upping the property. ","90fd522b":"Let's see how far we get with **just categorical or just numerical features.** We will automate our data cleaning with a pipeline.","d11e0884":"Cool. Much better. Already sth. **around rank #4000 on the Leaderboard with just one feature!** \n\nLet's try a categorical instead.","2f2d7eee":"## Machine Learning Methodology \u2013 step by step","7c29bffb":"We again have a look at the basic statistics of sales prices in our training data in order to compare these to stats of predicted values. \n\nWe have a mean of 180k, a minimum of around 35k and a maximum sale price of 755k.","435a9f82":"# 5. Hypertuning the engines","f0d0b984":"Kernel by [chmaxx](https:\/\/www.kaggle.com\/chmaxx) \u2013 September 2019\n\n![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/3\/3d\/Ames_Iowa_Main_Street_%28bannerportada_esvoy%29.jpg)\n###### *Main street in downtown Ames, Photo by Tim Kiser*","62f7aae4":"The lower bound is negative and therefore can be ignored. \n\n**The upper bound is 466'075 USD.** So let's filter out samples beyond that cut off.","229e166d":"We will follow these steps:\n\n1. Exploratory data analysis (EDA)\n2. Data cleaning and formatting\n3. Feature engineering\n4. Try and compare various machine learning models on a performance metric\n5. Perform hyperparameter tuning for most promising models\n6. Train best models on full data set and submit predictions\n\nIn **data cleaning and formatting** will especially take care of:\n\n- Missing values\n- Wrong values\n- Wrong datatypes\n- Outliers\n- Skewed distributions\n\n","e5e7fc71":"> <span style=\"color:darkred\">Skip ahead to the next chapter (6.) if you don't want to find **new** parameters.\n\nFor each of the promising classifiers we now try to find optimal hyperparameters with a search grid and sklearn's `GridSearchCV()`. (*commented out to allow for faster execution of whole kernel*)\n\nAs a starting point I looked into several of the kernels that I already have mentioned and tuned based on their findings.\n","f413b5c6":"Next step is to create new features by combining existing ones.","37bfbecb":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 05: Removing the outliers we were warned about...","d1a8305b":"Main finding: **The more living area the more variance we have in the distribution of sale prices.** In the top range of living area we find unusual high variance \u2013 very likely due to the outliers.","d24cf5a2":"Now that we have identified outliers, **let's see how skewed the distribution is**. The measure is [**skewness**](https:\/\/en.wikipedia.org\/wiki\/Skewness). \n\nA normal distribution has a skewness of `0`. A positive value of skewness means that the tail is on the right, and vice versa with negative values. \n\nPandas provides a convenient function. We add a probability plot to visualize the skewness of the sale prices.","105e4262":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 01: Training with just one feature","e9bb7883":"Remember the outliers Dean De Cock warned us about? Removing these now...","27178408":"How about our **cleaned data** and **some other classifiers**?","d4aae871":"- We notice the three groups we have identified in the last heatmap. \n- We see also that the statistics of sales prices in the training data is more accurately replicated by the non-linear models.","10e5b06a":"# 4. Try out and compare various classifiers","97aa068d":"In this step we will:\n    \n- find and fix missing and\/or wrong values\n- set correct datatypes\n- remove outliers\n\nWe start by **plotting all numeric features according to the current pandas dtypes.**","d15836a2":"Dean De Cock warns us about outliers:\n\n> Potential Pitfalls (Outliers): \u2026 <span style=\"color:darkred\">**There are five observations that an instructor may wish to remove from the data set before giving it to students**<\/span> (a plot of SALE PRICE versus GR LIV AREA will quickly indicate these points). Three of them are true outliers (Partial Sales that likely don\u2019t represent actual market values) and two of them are simply unusual sales (very large houses priced relatively appropriately). <span style=\"color:darkred\">**I would recommend removing any houses with more than 4000 square feet from the data set (which eliminates these five unusual observations)** before assigning it to students.","87cee470":"Less good. How about `OverallQual`?","33eb6425":"Problem fixed. **Take away: Visualizing the data is almost always superhelpful...**\n\nNow we try again with our metric.","cf4f0b94":"![](https:\/\/i.imgur.com\/JRhGeDh.jpg)\nPhoto by Pedro de Sousa","a1481ddd":"We clearly observe the positive correlation of the features and again various outliers.\n\nLet's look at the **time related features like building year, year and month of sale.**","9fe4d081":"<font color=\"purple\"> \n## Experiment 09: Do our predictions actually make any sense at all?","962fa233":"Hilarious. Just one single categorical yields a not-so-bad result. And an even better one than what we got from continuous `GrLivArea`.","7a814640":"We immediately notice that some features of `dtype == \"number\"` are categorical, many values are zeros and almost all value distributions seem skewed. From the initial `df.info()` we also can derive that there are float where ints should be. It's basically a mess.\n\nLet's fix the features one by one.","441be65d":"<font color=\"purple\"> \n## \ud83e\udd16 Experiment 02: Training with only categorical or numerical raw data","0fe35cf0":"This looks much better. Again \u2013 we keep that in mind for later, when we actually prepare the data.","b86913cd":"Interesting but **hard to decipher**. Let's **bin the data to decades**.","d4e66b88":">We know that **many numerical distributions are skewed**. Several Kagglers have fixed this in various interesting ways. <span style=\"color:darkred\">**I'm unsure if this really improves the models accuracy or even might be of disadvantage. I will skip this for now and try during model training.**","dda144a8":"# 7. Conclusion","f10f27cd":"Fellow Kaggler [massquantity suggests here](https:\/\/www.kaggle.com\/massquantity\/all-you-need-is-pca-lb-0-11421-top-4#Ensemble-Methods) that we can reduce the collinearity that we have in the data and even might have increased with feature engineering by applying PCA to the whole data set. I think it's a cool idea worth persuing. \n\nLet's try to quickly validate this with our data (which is significantly different from his in terms of feature cleaning and engineering).","f0a9f6c2":"We observe two things:\n\n- OverallQual indeed will predict negative sale prices if OverallQual is 2 or less (\u00abpoor\u00bb or \u00abvery poor\u00bb). \n- OverallCond has a negative trendline. The higher the condition the less is the predicted sales price. Seems wrong too. \n\nLet's fix this by removing samples with these low values for quality and condition.","5ca7ee2b":"# 6. Train and submit","25dd4738":"The box cox transformation seems to improve our models only slightly and only for some of the classifiers.","6cd52872":"Top correlated features like GarageCars, OverallQual are still very informative to the algorithm. Some of our engineered features like `TotalSF(1,2)`, `TotalBath` and `OverallScore` rank very high too. \n\nIt seems that feature engineering was effective, at least inasmuch some created featured rank among the relevant ones.","d3668320":"Now checking 4 more features of size.","1d74ba9e":"The more different the models that we choose for an ensemble the better it'll perform. We'll set up a correlation matrix and examine the correlations with a heatmap.","65410772":"The **distribution of `SalePrice` is quite skewed**. The values don't seem normally distributed at all. \n\nWe too can observe a lot of **outliers** on the upper end of the price spectrum. **But what exactly is an outlier?** And **can we isolate the outliers with statistical methods?**\n\n[Taken from machinelearningmastery.com:](https:\/\/machinelearningmastery.com\/how-to-use-statistics-to-identify-outliers-in-data\/)\n\n>**An outlier is an observation that is unlike the other observations.** It is rare, or distinct, or does not fit in some way. \n\n>_Outliers can have many causes, such as: Measurement or input error, data corruption or true outlier observation (e.g. Michael Jordan in basketball).\n**There is no precise way to define and identify outliers in general because of the specifics of each dataset.** Instead, you, or a domain expert, must interpret the raw observations and decide whether a value is an outlier or not.\nNevertheless, we can use statistical methods to identify observations that appear to be rare or unlikely given the available data._ \n\nOutliers will very likely decrease our models accuracy \u2013 since they make no sense and do not follow any regularities that can be learned by the algorithm. They are wrong and have to be excluded from the training data. \n\nA sound practical approach for _normally distributed data_ is to filter values that lie beyond 3 standard deviations from the mean. Since our sale price variable is not normally distributed we can use the **Interquartile Range Method**.  \n\nThe IQR is the difference between the 25th and 75th percentile range (e.g. the width of the box in the boxplot above). The outer bounds of a regular distribution are 1.5 * IQR. **A factor (called \u00abk\u00bb) of 3 or more can be used to identify values that are extreme outliers.** So let's try that.\n\n","0fa1ad8e":"The [Ames Housing Data Set](http:\/\/jse.amstat.org\/v19n3\/decock.pdf) is an **interesting and modern alternative** to the famous [Boston Housing Data Set from 1978](https:\/\/www.kaggle.com\/c\/boston-housing). The Ames Housing Data Set was collected by [Dean De Cock](https:\/\/www.linkedin.com\/in\/dean-de-cock-b5336537), Professor of Statistics at Truman State University, in 2011. \n\nThe dataset contains **data of individual residential properties in Ames, Iowa from 2006 to 2010**. The full dataset consists of 2930 samples with 80 features. \n\nIn this Kaggle competition we  **just work on a subset with only 1460 of the observations (for training)** and 1459 observations where we do not have the sale price (the test set). \n\n> <span style=\"color:darkred\">To get this out of our way \u2013 **everybody could possibly cheat** by e.g. simply training a model on [the full dataset](https:\/\/www.kaggle.com\/prevek18\/ames-housing). And obviously some scores on the leaderboard seem to good to be true. Anyway... \ud83e\udd37\u200d\u2640\ufe0f ","86dccfa3":"To get a baseline for all other experiments, we setup a dummy regressor, that simply \u00abpredicts\u00bb a constant that we define, e.g. the median of all the sale price values in our training data.","b4e24b22":"Observations:\n    \n- Fewer sales in 2010. Could be either because less samples were collected. Or the financial crisis of 2009 hit the market.\n- Most sales in summer months. Could be valuable to bin seasons to additional variables during feature engineering.\n\nSince most of the house were built during the two decades before 2010 let's take this into account and **analyze the actual age of the house in the year of sale**.","a8bc712a":"![](https:\/\/i.imgur.com\/bizOcnq.jpg)\nPhoto by Jakob Owens","1cc13aaa":"Dean De Cock created the dataset for his students as a final project in an undergraduate regression course. De Cock's [detailed description](http:\/\/jse.amstat.org\/v19n3\/decock.pdf) already gives a lot of useful information and hints in addition to the [features description that we have in the Kaggle data package and that can also be downloaded from here](http:\/\/www.amstat.org\/v19n3\/decock\/DataDocumentation.txt).\n\nWe get for example these details:\n* **80 variables in total**: 23 nominal, 23 ordinal, 14 discrete and 20 continuous\n* 20 **continuous**: relate to various area dimensions (e.g. lot size, total dwelling square footage etc.)\n* 14 **discrete**: quantify number of items occurring in the house (e.g. kitchens, baths, etc.)\n* 46 **categorical** ranging from 2 to 28 classes (e.g. smallest STREET, largest NEIGHBORHOOD)\n\nWith the **Parcel Identification Number (PID)** of the full\/original dataset we can get [very detailed additional information for every property via this link](http:\/\/beacon.schneidercorp.com\/). ","4b40e732":"How about log transforming the skewed distribution of `SalePrice`? Will we get a better score?","7957c1d7":"Always predicting the median of SalePrice with **the Dummy regressor gets us something like rank #4160 of around 4500 submissions** (at time of writing). This btw. is very close to the sample submission benchmark.","19b7a8cd":"We only observe a notable difference for newer houses. E.g. the median of price for houses between 0 and 19 years of age is almost the same now. \n\nLastly we visualize some categoricals in regard to sale price.","81e27d5c":"We have 81 columns. `SalePrice` is the target variable that we want to predict. `Id` is just an index that we can ignore. So we have **79 features to predict from**.","62adf13e":"What features are relevant for the classifiers? Was feature engineering worth our while?\n\nWe'll get the feature importance of XGBoost as an example.","ea6830e5":"Now we'll look at the predictions in detail.","8bd8d62a":"So at first glance this doesn't work here. **Did you have more sucess with PCA? Happy to hear your thoughts in the comments...**","9669284c":"We are definitely on track. **Scores of less than 0.13 (GBM, XGBoost) should pull us close toward a rank in the top third of the leaderboard.**","fc4331d1":"As expected the skewness is a positive value. From the plot we can observe the deviations from the expected, theoretical values of normal distribution. These also makes sense \u2013 they tend to be higher than expected on the right end \u2013 making it a long tail.\n\nJust for the fun of it let's examine the skewness of all numerical values."}}