{"cell_type":{"92b4ad1f":"code","20063a55":"code","1bbd49bf":"code","132b13b1":"code","e784dcbe":"code","63043950":"code","93247af1":"code","8d661531":"code","ecfe37ed":"code","900f844a":"code","be61d38d":"code","efb466fb":"code","3d47f898":"code","358d4cf5":"code","c063958f":"code","fad89df7":"markdown","0d59d9df":"markdown","f44ea8ee":"markdown","295200fe":"markdown","c8a5f7af":"markdown","c81534c9":"markdown","fd83bb98":"markdown","ee22cd99":"markdown","eb0f6070":"markdown","11a5b87d":"markdown"},"source":{"92b4ad1f":"!pip install dfply\n!pip install plotly\n\nimport os\nimport pandas as pd\nimport numpy as np\nfrom dfply import *\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nfrom random import randint\nfrom glob import glob\nimport plotly.express as px\nfrom plotly.offline import init_notebook_mode, iplot\nfrom tensorflow.random import set_seed\n\ninit_notebook_mode(connected=True)\nnp.random.seed(2)\nset_seed(2)\n\nimport tensorflow\nfrom  tensorflow import keras\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import *\nfrom tensorflow.keras import models\nfrom tensorflow.keras.losses import CategoricalCrossentropy, SparseCategoricalCrossentropy\nfrom tensorflow import convert_to_tensor\n\nfrom sklearn.metrics import confusion_matrix, classification_report\n\nplot_templ = \"seaborn\"\nplot_width_small = 600\nplpt_width_normal = 800\nclr_conti = px.colors.diverging.RdYlGn\nclr_conti_r = px.colors.diverging.RdYlGn_r\nclr_discrete = px.colors.qualitative.Set1\nclr_discrete_r = px.colors.qualitative.Set1_r\n\n%matplotlib inline\n\nprint('TensorFlow version:',tensorflow.__version__)\nprint('Keras version:',keras.__version__)","20063a55":"class MriDataset:\n    \n    def __init__(self, \n                 train_folder='..\/input\/brain-tumor-classification-mri\/Training', \n                 test_folder='..\/input\/brain-tumor-classification-mri\/Testing', \n                 val_size=0.2, \n                 class_map=None):                \n        self.train_folder = train_folder\n        self.test_folder = test_folder\n        self.dataset = tensorflow.data.Dataset.list_files(\n            os.path.join(os.getcwd(), train_folder, '*\/*')\n        )\n        self.testset = tensorflow.data.Dataset.list_files(\n            os.path.join(os.getcwd(), test_folder, '*\/*')\n        )\n        self.data_count = len(glob(os.path.join(os.getcwd(), train_folder, '*\/*.jpg')))\n        self.val_size = val_size\n        self.class_map = class_map\n        self.input_width=96\n        self.input_height=96        \n\n    def configure_dataset(self, dataset, batch_size=30):\n        dataset = dataset.cache()\n        dataset = dataset.shuffle(buffer_size=1000, reshuffle_each_iteration=False) \n        dataset = dataset.batch(batch_size)                \n        dataset = dataset.prefetch(buffer_size=tensorflow.data.AUTOTUNE) \n        return dataset    \n\n    def get_train_data(self):\n        skip = self.data_count * self.val_size\n        skip = int(skip)\n        data = self.dataset.skip(skip)   \n        data = data.map(self.process_path, num_parallel_calls=tensorflow.data.AUTOTUNE)  \n        return data\n\n    def get_val_data(self):\n        take = self.data_count * self.val_size\n        take = int(take)\n        data = self.dataset.take(take)\n        data = data.map(self.process_path, num_parallel_calls=tensorflow.data.AUTOTUNE)                  \n        return data\n\n    def get_test_data(self):\n        data = self.testset.map(self.process_path, num_parallel_calls=tensorflow.data.AUTOTUNE)                  \n        return data                \n\n    def get_labels(self):\n        if self.class_map == None:\n            train_labels = os.listdir(os.path.join(os.getcwd(), self.train_folder))\n        else:\n            train_labels = list(set(self.class_map.values()))                 \n        train_labels.sort()            \n        return train_labels\n\n    def get_shape(self):\n        return (self.input_height, self.input_width, 3)\n    \n    @tensorflow.function\n    def process_path(self, file_path):\n        @tensorflow.function\n        def get_label(path, classes):\n            parts = tensorflow.strings.split(file_path, os.path.sep)\n            lab = parts[-2]                      \n            one_hot = parts[-2] == classes\n            return tensorflow.argmax(one_hot)\n        @tensorflow.function            \n        def get_label_map(path, class_map):\n            parts = tensorflow.strings.split(file_path, os.path.sep)\n            lab = parts[-2]        \n            val = table.lookup(lab)                  \n            return val \n        @tensorflow.function          \n        def decode_img(img, h, w):\n            img = tensorflow.io.decode_jpeg(img, channels=3)\n            return tensorflow.image.resize(img, [h, w])\n        @tensorflow.function  \n        def convert_dic(item_dict):\n            keys_tensor = tensorflow.constant(list(item_dict.keys()))\n            vals_tensor = tensorflow.constant(list(item_dict.values()))\n            init = tensorflow.lookup.KeyValueTensorInitializer(keys_tensor, vals_tensor)\n            table = tensorflow.lookup.StaticHashTable(init, default_value=-1)  \n            return table                           \n\n        if self.class_map == None:\n            label = get_label(file_path, np.array(self.get_labels()))\n        else:\n            table = convert_dic(self.class_map)           \n            label = get_label_map(file_path, table)  \n\n        img = tensorflow.io.read_file(file_path)        \n        img = decode_img(img, self.input_height, self.input_width)       \n        return img, label\n    \n    def plot_counts(self, sample_from=\"train\"):\n        wkdir = os.getcwd()\n        folder_path = os.path.join(wkdir, self.train_folder)\n\n        if(sample_from != \"train\"):\n            folder_path = os.path.join(wkdir, self.test_folder) \n\n        counts = {}\n        classes = os.listdir(folder_path)       \n\n        for class_item in classes:\n            img_paths = os.listdir(os.path.join(folder_path, class_item))\n            counts[class_item] = len(img_paths)\n             \n        fig  = px.bar(\n            x=counts.keys(), \n            y=counts.values(),\n            labels={\"y\":\"Count\", \"x\":\"Class\"},\n            text=counts.values(),\n            template=plot_templ)           \n        fig.update_layout(\n            title_text = \"Count of examples per class - Tumor MRIs\",\n            template = plot_templ,\n            width=600,\n            height=400)\n        fig.show()\n      \n    def plot_samples(self, sample_from=\"train\"):\n        wkdir = os.getcwd()\n        folder_path = os.path.join(wkdir, self.train_folder)\n\n        if(sample_from != \"train\"):\n            folder_path = os.path.join(wkdir, self.test_folder)\n\n        train_fig = plt.figure(figsize=(16, 24))\n        cnt = 0\n        classes = os.listdir(folder_path)\n        classes.sort()\n        for subdir in os.listdir(folder_path):\n            cnt+=1\n            sub_path = os.path.join(folder_path, subdir)\n            img_file = os.listdir(sub_path)[0]\n            image = mpimg.imread(os.path.join(sub_path,img_file))\n            a=train_fig.add_subplot(1, len(classes), cnt)\n            a.axis('off')\n            imgplot = plt.imshow(image)\n            a.set_title(subdir+'-'+img_file)\n\n        plt.show()\n        ","1bbd49bf":"ds = MriDataset()\nds.plot_counts()","132b13b1":"ds.plot_counts(sample_from=\"test\")","e784dcbe":"print(\"Samples from training directory\")\nds.plot_samples()","63043950":"print(\"Samples from test directory\")\nds.plot_samples(sample_from=\"test\")","93247af1":"tensorflow.config.run_functions_eagerly(True)\ntensorflow.data.experimental.enable_debug_mode()\n\nclass MRIClassifier:\n\n    def __init__(self, train_generator=None, val_generator=None):\n        self.model = None\n        self.train_generator = train_generator\n        self.val_generator = val_generator        \n\n    def build(self, input_shape, num_classes):    \n        loss = SparseCategoricalCrossentropy()\n        self.model = Sequential()\n        self.model.add(tensorflow.keras.Input(shape=input_shape, name=\"Layer1\"))\n        self.model.add(Rescaling(1.\/255, name=\"Layer2\"))\n        self.model.add(Conv2D(16, (3,3), activation=\"relu\", name=\"Layer3\"))\n        self.model.add(BatchNormalization())\n        self.model.add(MaxPooling2D(pool_size=(2,2)))\n        self.model.add(Dropout(0.2))\n        self.model.add(Conv2D(32, (6,6), activation=\"relu\", name=\"Layer4\"))\n        self.model.add(BatchNormalization())\n        self.model.add(MaxPooling2D(pool_size=(2,2)))   \n        self.model.add(Dropout(0.2))\n        self.model.add(Conv2D(32, (6,6), activation=\"relu\", name=\"Layer5\"))\n        self.model.add(BatchNormalization())\n        self.model.add(MaxPooling2D(pool_size=(2,2)))    \n        self.model.add(Dropout(0.2))\n        self.model.add(Flatten(name=\"Layer6\"))   \n        self.model.add(Dense(64, activation=\"relu\", name=\"Layer7\"))\n        self.model.add(Dense(num_classes, activation=\"softmax\", name=\"Layer8\"))\n        self.model.compile(\n            loss=loss,\n            optimizer=\"adam\",\n            metrics=[\"accuracy\"],\n            run_eagerly=True\n        )\n        return self.model\n    \n    def print_summary(self):\n        print(\"\\nMRI CNN model architecture summary:\\n\\n\")\n        print(self.model.summary())\n\n    def train(self, epochs=10):\n        callback = tensorflow.keras.callbacks.EarlyStopping(monitor='val_loss', patience=4)\n\n        self.history = self.model.fit(                        \n            self.train_generator,\n            validation_data=self.val_generator,\n            epochs=epochs,\n            callbacks=[callback]            \n        )\n        return self.history\n\n    def save(self, file_path=\"_output\/mri_classifier.h5\"):\n        self.model.save(file_path)\n        return self.model\n\n    def load(self, file_path=\"_output\/mri_classifier.h5\"):\n        if self.model is not None:\n            del self.model\n            \n        self.model = models.load_model(file_path)    \n        return self.model\n\n    def predict(self, img_array_batch):\n        probs = self.model.predict(img_array_batch)\n        return np.argmax(probs, axis=1)\n\n    def plot_history(self):        \n        train_loss = self.history.history[\"loss\"]\n        val_loss = self.history.history[\"val_loss\"]\n        epochs_nums = range(1, len(self.history.history[\"loss\"]) + 1)\n\n        data = {\n            \"epochs\":epochs_nums, \n            \"training\":model.history.history[\"loss\"],\n            \"validation\":model.history.history[\"val_loss\"]\n        }\n        vis_data = pd.DataFrame(data=data)\n        vis_data = (vis_data >> gather(\"var\", \"val\", [\"training\", \"validation\"]))\n\n        fig = px.line(\n            vis_data, \n            x=\"epochs\",\n            y=\"val\",\n            color=\"var\",\n            labels={\"val\":\"Loss\", \"var\":\"Loss\"},\n            template=plot_templ\n        )\n        fig.update_layout(\n            legend_traceorder=\"reversed\",\n            width=600,\n            height=500\n        )\n        fig.show()\n","8d661531":"class_mapping = {\n    'glioma_tumor':1, \n    'meningioma_tumor':1, \n    'no_tumor':0, \n    'pituitary_tumor':1\n}\nds = MriDataset(class_map=class_mapping)\nbatch_size = 30\nepochs = 18\nmodel = MRIClassifier(\n    train_generator=ds.configure_dataset(ds.get_train_data()), \n    val_generator=ds.configure_dataset(ds.get_val_data()))\nmodel.build(ds.get_shape(), len(ds.get_labels()))\nmodel.print_summary()\n","ecfe37ed":"model.train(epochs=epochs)","900f844a":"model.save()\nprint(\"MRI CNN model saved to disk\")","be61d38d":"def frame_report(actual, predicted, labels=[0,1], names=[\"None\", \"Tumor\"]):\n    report = classification_report(\n        actual, \n        predicted, \n        labels=labels, \n        target_names=names, \n        output_dict=True)\n    df_report = pd.DataFrame.from_dict(report).transpose()\n    style = df_report.style.set_caption('<b>Classification Report<\/b>').background_gradient(\n        cmap='viridis', subset=pd.IndexSlice[names, :'f1-score']) \n    return style    \n\ndef frame_matrix(actual, predicted, cols=[\"None\", \"Tumor\"]):\n    cm = confusion_matrix(actual, predicted)\n    frame = pd.DataFrame(cm, index=cols, columns=cols)    \n    style = frame.style.set_caption('<b>Confusion Matrix<b\/>').background_gradient(cmap='viridis') \n    return style","efb466fb":"model.plot_history()","3d47f898":"ds = MriDataset(class_map=class_mapping)\ntest = ds.get_test_data()\ntest = ds.configure_dataset(test)\n\nclassifier = MRIClassifier()\nclassifier.load()\n\nactual = []\npredictions = []\n\nfor img, labs in test:    \n    preds_idx = classifier.predict(img.numpy())\n    predictions.extend(preds_idx)\n    actual.extend(labs.numpy().tolist())\n\nprint(\"Testing MRI CNN Model on unseen data complete\")","358d4cf5":"report = frame_report(actual, predictions)\nreport","c063958f":"cm = frame_matrix(actual=actual, predicted=predictions)\ncm","fad89df7":"The plot above is used to investigate 2 critical training issues namely underfitting and overfitting. The training loss is significantly reduced at the start of the training process and shows a general trend of decreasing loss toward 0. The validation loss also significantly decreases toward 0. ","0d59d9df":"The training data has approximately an equal number of observations for positive examples ( glioma_tumor, meningioma_tumor, pituitary_tumor ) whilst the negative samples far fewer (almost 50% less)","f44ea8ee":"# 3. Modelling\n\nIn this section the training data is used to implement a simple CNN deep learning model to classify an MRI image as either 'Tumor' (positive example) or 'None' (negative example). The aim of this experiment is to implement a binary classification model for the MRI dataset. The MRI images that are positive examples (glioma_tumor, meningioma_tumor, pituitary_tumor) are relabelled as 'Tumor' and negative examples (no_tumor) are relabelled as 'None'.\n\n**Preprocessing**\n- MRI images are resized to be 96x96 pixels\n- Pixel rgb values are rescaled to be between 1 and 0 (CNN layer)\n\n**CNN Architecture**\n- 3 Convolution 2d layers (16, 32, 32) with ReLU activation\n- 3 Batch normalization layers\n- 3 Max pooling 2d layers\n- 3 Dropout layers\n- 2 Dense layers (64 and 2)\n- Sparse categorical crossentropy loss function and ADAM optimizer\n\nImages are fed to the CNN network in batches of 30 for 18 epochs. Early stopping is set on the validation loss with a patience of 4.\n","295200fe":"# 2. Data Understanding\n\nThe dataset can be found on [here](https:\/\/www.kaggle.com\/sartajbhuvaji\/brain-tumor-classification-mri) and consist sub folders with the following:\n- Training folder which consists of MRI images to be used for training\n- Test folder which consist of MRI images to be used for testing\n- The training and test folder have MRI images of respective tumor classes (in directories)\n- The classes (folders) are glioma_tumor, meningioma_tumor, no_tumor, pituitary_tumor \n","c8a5f7af":"The number of test data observations are almost the same for the classes glioma_tumor, meningioma_tumor and no_tumor (~100) and class with the least is pituitary_tumor with 74 examples","c81534c9":"**Basic explorations**\n\nA couple of checks are performed on the dataset to verify the data is correct and to check the quality:\n- Check data balance in training samples\n- Check data balance in test samples\n- Verify classes and labels \n- Look at sample images","fd83bb98":"# 4. Conclusion\n\nEveryday millions of people suffer from various diseases, illnesses and conditions. Many of these medical challenges can be managed through medical care and treatment whilst others have little to no treatment at all. At the forefront of these health challenges are doctors, researchers, nurses and other health professionals. Many of these individuals rely on tools to assist them with diagnosing diseases and developing treatments for patients. \n\nThe experiment in this notebook was to conceptualize a simple machine learning model to detect brain tumors from MRI images. A simple CNN deep learning model classified a MRI image as either 'Tumor' (positive example) or 'None' (negative example) and achieved an **macro average F1 Score of ~0.86** on the test dataset. The model has lots of room for improvement, specifically the Recall of the 'Tumor' label and the Precision of the 'None' label. \n\nA more advanced machine learning model could be incorporated into existing diagnosis tools and software used by medical specialists and medical professionals. The classifier presented here is simple and future experiments could investigate the benefit of using additional patient data, more examples of brain tumor MRI images, data augmentation and transfer learning.","ee22cd99":"**Model Evaluation**\n\nA machine learning model that performance well is that which can generalize well to new and unseen data. Evaluating the performance of the MRI CNN model consists of the following:\n\n- Check the MRI CNN model training process for issues\n- Test the model on unseen images and report performance with metrics such as F1 score, Precision and Recall\n- Check errors of the model via Confusion Matrix\n","eb0f6070":"# 1. Introduction\n\nA brain tumor is a mass of irregular cells in the brain. Some brain tumors can be fatal, some can be treated and others are be benign. Symptoms of brain tumors include headaches, confusion, seizures, loss of balance, weakness and fatigue to name a few. According to [braintumor.org](https:\/\/braintumor.org\/brain-tumor-information\/brain-tumor-facts\/) about 700 000 Americans are living with a primary brain tumor, the average survival rate is about 75% for primary brain tumor patients and the median age at diagnosis for a primary brain tumor is 60 years. Typically diagnosis would involve lab tests and imaging of the brain. Implementing tools and software such as Machine learning models could potentially aid with diagnosis of brain tumors. In the following notebook binary classification is explored and performed on MRI scans to detect brain tumors.","11a5b87d":"Recollect that the expirement is a binary classification model for MRI images of tumors. Relabelling the MRI images that are positive examples (glioma_tumor, meningioma_tumor, pituitary_tumor) as 'Tumor' and negative examples (no_tumor) as 'None' has resulted in an imbalanced dataset. Hence, the model is evaluated on the **macro average scores** displayed in the classification report above. The binary classifier achieved a **macro average F1 Score of ~0.86**. The confusion matrix shows that out of 105 negative samples 2 were classified incorrectly and out of 289 positive samples 43 were classified incorrectly."}}