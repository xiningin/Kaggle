{"cell_type":{"989ed75d":"code","aa5a697c":"code","7c9d7b89":"code","159263ae":"code","0d8658a3":"code","31ef21d0":"code","4c0d95bd":"code","089c4484":"code","144c7f3e":"code","3e70d2fa":"code","067cc142":"code","2ff1d2d1":"code","4b322420":"code","ee6b43e6":"code","a0c94951":"code","cd6c3df8":"code","0acff8d7":"code","0cdcea3a":"code","b7b1e3c7":"code","bb02e5ac":"code","fe078881":"code","c881c96d":"code","27db0962":"code","85e4244b":"code","d5d9a020":"code","c66d518e":"code","7efa8ed4":"code","56e17cd4":"code","2cf59422":"code","1be817e2":"markdown","169d9c7e":"markdown","d80be1be":"markdown","ae3f2dbe":"markdown","dcbb68c0":"markdown","ba5c830a":"markdown","9258510a":"markdown","d8c8ba18":"markdown","91fda313":"markdown","dc35bbe6":"markdown","287e9395":"markdown","2487ed77":"markdown","915fe5a0":"markdown","287e3449":"markdown","67acf9c3":"markdown","374715bb":"markdown","f2094b4e":"markdown"},"source":{"989ed75d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# 3 option for print all columns in the dataframes\npd.set_option('display.max_rows', 500)\npd.set_option('display.max_columns', 500)\npd.set_option('display.width', 1000)\n\nimport copy\nfrom datetime import datetime, timedelta\nfrom scipy import stats\n\nimport plotly.express as px\ntemplate = 'plotly_dark'\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","aa5a697c":"# import the dataset\ndpc_covid19_ita_regioni = pd.read_csv(\"..\/input\/covid19-italy-regional-data\/dpc-covid19-ita-regioni.csv\")\n\n# rename the columns \ndf = dpc_covid19_ita_regioni.rename(columns={'data':'date',\n                                             'stato': 'country',\n                                             'codice_regione': 'region_id',\n                                             'denominazione_regione':'region',\n                                             'ricoverati_con_sintomi':'hospitalized_with_symptoms',\n                                             'terapia_intensiva':'intensive_therapy',\n                                             'totale_ospedalizzati':'tot_hospitalized',\n                                             'isolamento_domiciliare':'home_quarantine',\n                                             'totale_attualmente_positivi':'tot_now_positive',\n                                             'nuovi_attualmente_positivi':'new_positive',\n                                             'dimessi_guariti':'recovered',\n                                             'deceduti':'deaths',\n                                             'totale_casi':'confirmed',\n                                             'tamponi':'swabs'})","7c9d7b89":"class color:\n   PURPLE = '\\033[95m'\n   CYAN = '\\033[96m'\n   DARKCYAN = '\\033[36m'\n   BLUE = '\\033[94m'\n   GREEN = '\\033[92m'\n   YELLOW = '\\033[93m'\n   RED = '\\033[91m'\n   BOLD = '\\033[1m'\n   UNDERLINE = '\\033[4m'\n   END = '\\033[0m'\n\nprint(color.BOLD + max(df['date']) + color.END)","159263ae":"# convert the date from string in datetime format for time series analysis\ndf['date'] = pd.to_datetime(df['date'].str[:10],\nformat='%Y-%m-%d')\nita = df.copy()\ndf","0d8658a3":"# import the dataset\ndpc_covid19_ita_province = pd.read_csv(\"..\/input\/covid19-italy-regional-data\/dpc-covid19-ita-province.csv\")\ndpc_covid19_ita_province[dpc_covid19_ita_province['denominazione_provincia']=='Torino']\n\nprov = dpc_covid19_ita_province.rename(columns={'data':'date',\n                                             'stato': 'country',\n                                             'codice_regione': 'region_id',\n                                             'denominazione_regione':'region',\n                                             'codice_provincia':'province_id',\n                                             'denominazione_provincia':'province',\n                                             'sigla_provincia':'province_code',\n                                             'totale_casi':'confirmed'})\n# Delete these row indexes from dataFrame\nprov.drop(prov[ prov['date'] ==  'data' ].index , inplace=True)\nprov.drop(prov[ prov['province_code'].isnull()].index , inplace=True)\nprov['confirmed'] = prov['confirmed'].astype(int)\nprov['lat'] = prov['lat'].astype(float)\nprov['long'] = prov['long'].astype(float)\nprov['date'] = pd.to_datetime(prov['date'].str[:10],format='%Y-%m-%d')\n\n# prov.groupby(by=['region']).sum()\n#\nprov\n# prov['confirmed'] = prov.groupby(['region']).cumsum()\n# prov[prov['date'] == max(prov['date'])]","31ef21d0":"# select the last and most updated data from the dataset for statistics and display it\ndf_max = df[df['date']==max(df['date'])].sort_values(['confirmed'], ascending=[False])\n\ndf_max.columns","4c0d95bd":"ita = ita.groupby(by=['date'], as_index=False).sum().sort_values(['date'], ascending=[True])\nita = ita.rename(columns={'region_code':'country'})\nita['country'] = 'ITA'\nita[['date', 'country','confirmed','recovered','deaths']].sort_values(['date'], ascending=[False])","089c4484":"import matplotlib.pyplot as plt\n\n\nplt.figure(figsize=(12,7))\n\n# gca stands for 'get current axis'\nax = plt.gca()\n\nita.plot(x ='date', y='confirmed', color='blue', kind = 'line',ax=ax)\nita.plot(x ='date', y='deaths', color='red', kind = 'line',ax=ax)\nita.plot(x ='date', y='recovered', color='green', kind = 'line',ax=ax)\n\nplt.legend(['confirmed', 'deaths','recovered'], loc='upper left')\nplt.rcParams['figure.facecolor'] = 'xkcd:white'\n\ndict_style_title = {'fontsize':30,\n                    'fontweight' : 'bold',\n                    'color' : 'black',\n                    'verticalalignment': 'baseline'}\n\nplt.title('Italy', fontdict = dict_style_title)\nplt.show()","144c7f3e":"df2 = df.copy()\n# convert date in the target format for plotting the map\ndf2['date'] = df2['date'].dt.strftime('%m\/%d\/%Y')\ndf[df['date']==max(df['date'])][['date','region','confirmed','deaths','recovered']].sort_values(['confirmed'], ascending=[False])","3e70d2fa":"fig = px.scatter_geo(df2, \n                     lat = df2[\"lat\"].astype(str), lon = df2[\"long\"].astype(str),\n                     color=\"confirmed\", size=\"confirmed\", hover_name=\"region\", \n                     range_color= [0, max(df2['confirmed'])+2],  color_continuous_scale='Bluered',\n                     projection=\"natural earth\", animation_frame=\"date\", scope = 'europe', height = 700, size_max  = 70,# template = template,\n                     title='Spread in Italy over time: Regions')\n\n\n\nfig.show()","067cc142":"dfp = prov.copy()\n# convert date in the target format for plotting the map\ndfp['date'] = dfp['date'].dt.strftime('%m\/%d\/%Y')","2ff1d2d1":"# for now unused\n# link source data: -> https:\/\/gist.github.com\/datajournalism-it\/f1abb68e718b54f6a0fe\nimport geojson\nwith open(\"..\/input\/covid19-italy-regional-data\/regioni-con-trento-bolzano.geojson\") as f:\n    gj = geojson.load(f)\ngj[\"features\"][0]","4b322420":"# it can be defined either with color_continuous_scale=px.colors.sequential.Bluered\n# for revere the color scheme simply append _r at the end of the name of the color schema  .ex  'Bluered_r'\n# style informations: -> https:\/\/plot.ly\/python\/map-configuration\/\n\n#     Valid properties:\n#         bgcolor\n#             Set the background color of the map\n#         center\n#             plotly.graph_objects.layout.geo.Center instance or dict\n#             with compatible properties\n#         coastlinecolor\n#             Sets the coastline color.\n#         coastlinewidth\n#             Sets the coastline stroke width (in px).\n#         countrycolor\n#             Sets line color of the country boundaries.\n#         countrywidth\n#             Sets line width (in px) of the country boundaries.\n#         domain\n#             plotly.graph_objects.layout.geo.Domain instance or dict\n#             with compatible properties\n#         fitbounds\n#             Determines if this subplot's view settings are auto-\n#             computed to fit trace data. On scoped maps, setting\n#             `fitbounds` leads to `center.lon` and `center.lat`\n#             getting auto-filled. On maps with a non-clipped\n#             projection, setting `fitbounds` leads to `center.lon`,\n#             `center.lat`, and `projection.rotation.lon` getting\n#             auto-filled. On maps with a clipped projection, setting\n#             `fitbounds` leads to `center.lon`, `center.lat`,\n#             `projection.rotation.lon`, `projection.rotation.lat`,\n#             `lonaxis.range` and `lonaxis.range` getting auto-\n#             filled. If \"locations\", only the trace's visible\n#             locations are considered in the `fitbounds`\n#             computations. If \"geojson\", the entire trace input\n#             `geojson` (if provided) is considered in the\n#             `fitbounds` computations, Defaults to False.\n#         framecolor\n#             Sets the color the frame.\n#         framewidth\n#             Sets the stroke width (in px) of the frame.\n#         lakecolor\n#             Sets the color of the lakes.\n#         landcolor\n#             Sets the land mass color.\n#         lataxis\n#             plotly.graph_objects.layout.geo.Lataxis instance or\n#             dict with compatible properties\n#         lonaxis\n#             plotly.graph_objects.layout.geo.Lonaxis instance or\n#             dict with compatible properties\n#         oceancolor\n#             Sets the ocean color\n#         projection\n#             plotly.graph_objects.layout.geo.Projection instance or\n#             dict with compatible properties\n#         resolution\n#             Sets the resolution of the base layers. The values have\n#             units of km\/mm e.g. 110 corresponds to a scale ratio of\n#             1:110,000,000.\n#         rivercolor\n#             Sets color of the rivers.\n#         riverwidth\n#             Sets the stroke width (in px) of the rivers.\n#         scope\n#             Set the scope of the map.\n#         showcoastlines\n#             Sets whether or not the coastlines are drawn.\n#         showcountries\n#             Sets whether or not country boundaries are drawn.\n#         showframe\n#             Sets whether or not a frame is drawn around the map.\n#         showlakes\n#             Sets whether or not lakes are drawn.\n#         showland\n#             Sets whether or not land masses are filled in color.\n#         showocean\n#             Sets whether or not oceans are filled in color.\n#         showrivers\n#             Sets whether or not rivers are drawn.\n#         showsubunits\n#             Sets whether or not boundaries of subunits within\n#             countries (e.g. states, provinces) are drawn.\n#         subunitcolor\n#             Sets the color of the subunits boundaries.\n#         subunitwidth\n#             Sets the stroke width (in px) of the subunits\n#             boundaries.\n#         uirevision\n#             Controls persistence of user-driven changes in the view\n#             (projection and center). Defaults to\n#             `layout.uirevision`.\n#         visible\n#             Sets the default visibility of the base layers.\n\nfig = px.scatter_geo(dfp, \n                     lat = dfp[\"lat\"].astype(str), lon = dfp[\"long\"].astype(str),\n                     color=\"confirmed\", size=\"confirmed\", hover_name=\"province\", \n                     range_color= [0, max(dfp['confirmed'])+2], color_continuous_scale='Bluered',\n                     projection=\"natural earth\", animation_frame=\"date\", scope = 'europe', height = 700, size_max  = 70,# template = template,\n                     title='Spread in Italy over time: Provinces')\n\n# fig.update_geos(visible=True,oceancolor = 'grey',showocean = True, showland = False,countrycolor = 'white', countrywidth = 2, bgcolor ='black', showcountries = True, resolution = 50\n#                ,lonaxis={\"range\":[30, 45]}, lataxis={\"range\":[37, 50]\n    #)\n# fig.update_layout(margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\n\n\n\nfig.show()","ee6b43e6":"full_table = pd.read_csv('..\/input\/corona-virus-report\/covid_19_clean_complete.csv', \n                         parse_dates=['Date'])\nformated_gdf = full_table.groupby(['Date', 'Country\/Region'])['Confirmed', 'Deaths', 'Recovered'].max()\nformated_gdf = formated_gdf.reset_index()\nformated_gdf['Date'] = pd.to_datetime(formated_gdf['Date'])\nformated_gdf.groupby(['Country\/Region']).max().sort_values(['Confirmed'], ascending=[False]).head(10)  # commenta a cambia head (25) per vedere ad esempio i primi 25","a0c94951":"formated_gdf['Date'] = formated_gdf['Date'].dt.strftime('%m\/%d\/%Y')\n\nfig = px.scatter_geo(formated_gdf, \n                     locations=\"Country\/Region\", locationmode='country names', \n                     color=\"Confirmed\", size='Confirmed', hover_name=\"Country\/Region\", \n                     range_color= [0, max(formated_gdf['Confirmed'])+2], color_continuous_scale='Bluered',# template = template,\n                     projection=\"natural earth\", animation_frame=\"Date\", size_max = 70, height=800,\n                     title='Spread World wide over time')\n\nfig.update_yaxes(automargin=True)\nfig.show()","cd6c3df8":"ita = ita.groupby(by=['date'], as_index=False).sum().sort_values(['date'], ascending=[True])\nita = ita.rename(columns={'region_code':'country'})\nita['country'] = 'ITA'\nita = ita[['date', 'country','confirmed','recovered','deaths']]\nita.head(5)","0acff8d7":"from scipy.optimize import curve_fit\nimport datetime as dt\n\n\ndef exp_func(x, a, b, c):\n    return a * np.exp(-b * x) + c\n#   return a * np.log(b * x) + c\n\nx = ita[['date']]\nx = np.array(x['date'].map(dt.datetime.toordinal), dtype=float) #transform your data in a numpy array of floats \nx_scale = x - x[0] # 0 \u00e8 il giorno attuale se ordino desc per data... se ordino in ordide crescente allora x_scale[1] \u00e8 oggi\ny = ita[['confirmed']]\ny = np.array(y['confirmed'], dtype=float) #so the curve_fit can work\n\n\n\npopt, pcov = curve_fit(exp_func, x_scale, y, p0= (0,0,0))\na, b, c = copy.deepcopy(popt)\n\nplt.figure(figsize=(15, 5))\nplt.subplot(121)\nplt.plot(x_scale, y, 'ko', label=\"Original Confirmed Cases\")\nplt.plot(x_scale, exp_func(x_scale, *popt), 'r-', label=\"Fitted Curve\")\nplt.legend()\nplt.title('Actual Trend of Confirmed Cases')\n\n# After the uarantine measure\n\nx_scale_q = copy.deepcopy(x_scale[:17])\ny_q = copy.deepcopy(y[:17])\n\npopt_q, pcov_q = curve_fit(exp_func, x_scale_q, y_q, p0= (0,0,0))\na_q, b_q, c_q = copy.deepcopy(popt_q)\nplt.subplot(122)\nplt.plot(x_scale_q, y_q, 'ko', label=\"Original Confirmed Cases\")\nplt.plot(x_scale_q, exp_func(x_scale_q, *popt_q), 'r-', label=\"Fitted Curve\")\nplt.legend()\nplt.title('Before Quarantine Trend of Confirmed Cases')\n\nplt.show()\n #index 16 \u00e8 la data del calo sul grafioc ma 15 quella del rate","0cdcea3a":"def predict_confirmed_x_day_from_now(day_from_now):\n    #return a np.array of value x for plotting, the prediction\n    x = day_from_now + x_scale[-1]\n    return [np.arange(x_scale[-1] + float(day_from_now)), a * np.exp(-b * x) + c]\n\n\ndef predict_confirmed_x_day_from_start_bq_curve(day_from_start):\n    # start counting from 0\n    # return a np.array of value x for plotting, the prediction\n    x = day_from_start\n    return [np.arange(x), a_q * np.exp(-b_q * x) + c_q]\n\ndef predict_confirmed_x_day_from_start(day_from_start):\n    # start counting from 0\n    # return a np.array of value x for plotting, the prediction\n    x = day_from_start\n    return [np.arange(x), a * np.exp(-b * x) + c]\n\n\nplt.figure()\nplt.plot(x_scale, y, 'ko', label=\"Original Confirmed Cases\")\nx_new, y_pred = predict_confirmed_x_day_from_start(24)\nx_new_bq, y_pred_bq = predict_confirmed_x_day_from_start_bq_curve(24)\nplt.plot(x_new, exp_func(x_new, a, b, c), 'r-', label=\"Fitted Curve extended\", color='purple')\nplt.plot(x_new_bq, exp_func(x_new_bq, a_q, b_q, c_q), 'r-', label=\"Fitted Curve extended Before Quarantine\", color='yellow')\nplt.legend()\nplt.show()\nprint(\"Num Confirmed Predicted at 18\/03\/2020: \" +\n      str(y_pred) + \"\\nNum Confirmed Predicted at 18\/03\/2020 BQ Curve : \" +\n      str(y_pred_bq) +\"\\nNum Confirmed Real at 18\/03\/2020: \" + \n      str(ita.iloc[24]['confirmed']) +\"\\nx_new: \" +str(x_new))","b7b1e3c7":"r2_actual = 1. - sum((exp_func(x_scale, *popt) - y) ** 2) \/ sum((y - np.mean(y)) ** 2)\nr2_bq = 1. - sum((exp_func(x_scale_q, *popt_q) - y_q) ** 2) \/ sum((y_q - np.mean(y_q)) ** 2)\nprint(\"r2 Actual: \" + str(r2_actual) + \"\\nr2 Before Quarantine: : \" + str(r2_bq))","bb02e5ac":"ita_r = ita.sort_values(['date'], ascending=[True])\ns = pd.DataFrame(columns = ['date' , 'rate'])\nprec = 0\nfor x, row in  ita_r.iterrows():\n    prec = prec\n    if x != 0:\n        s  = s.append({'date':row['date'], 'rate':row['confirmed']\/prec}, ignore_index = True)\n        prec = row['confirmed']\n    else:\n        prec = row['confirmed']\ns.head(5)","fe078881":"# rate\nx_r = s[['date']]\ny_r = s[['rate']]\nplt.figure()\nplt.plot(x_r, y_r, 'ko', label=\"rate\")\n# plt.plot(x, func(x, *popt), 'r-', label=\"Fitted Curve\")\nplt.xticks(rotation = 60)\nplt.legend()\nplt.show()","c881c96d":"stats.ks_2samp(np.array(y_r[14:]['rate']), np.array(y_r[6:14]['rate'])) #  devo rifiutare che siano uguali le due distribuzioni dei rate","27db0962":"# I for infected\nita['I'] = ita['confirmed']-ita['recovered']-ita['deaths']\nita.head(4)","85e4244b":"from scipy.optimize import curve_fit\nimport datetime as dt\n\n\nx = ita[['date']]\nx = np.array(x['date'].map(dt.datetime.toordinal), dtype=float) #transform your data in a numpy array of floats \nx_scale = x - x[0] # 0 \u00e8 il giorno attuale se ordino desc per data... se ordino in ordide crescente allora x_scale[1] \u00e8 oggi\ny = ita[['I']]\ny = np.array(y['I'], dtype=float) #so the curve_fit can work\n\n# a0 = v[-1]\n# b0 = v[0]\n# alpha0 = 1\/t_scale[-1]\n\npopt, pcov = curve_fit(exp_func, x_scale, y, p0= (0,0,0))\n\nplt.figure()\nplt.plot(x_scale, y, 'ko', label=\"Original Confirmed Cases\")\nplt.plot(x_scale, exp_func(x_scale, *popt), 'r-', label=\"Fitted Curve\")\nplt.legend()\nplt.show()\npcov\na, b, c = copy.deepcopy(popt)","d5d9a020":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import integrate, optimize\nfrom scipy.integrate import odeint\n\n\nt = np.arange(460)\n\n# The SIR model differential equations.\ndef deriv(y, t, N, beta, gamma):\n    if t<=14:\n        S, I, R = y\n        dSdt = -beta * S * I \/ N\n        dIdt = beta * S * I \/ N - gamma * I\n        dRdt = gamma * I\n    else:\n        S, I, R = y\n        dSdt = -beta * S * I \/ (N)\n        dIdt = beta * S * I \/ (N) - gamma * I\n        dRdt = gamma * I \n    return dSdt, dIdt, dRdt\n\ndef sir_model(y, x, beta, gamma):\n    S, I, R = y\n    dSdt = -beta * S * I \/ N\n    dIdt = beta * S * I \/ N - gamma * I\n    dRdt = gamma * I\n#     S = -beta * y[0] * y[1] \/ N\n#     R = gamma * y[1]\n#     I = -(S + R)\n    return dSdt, dIdt, dRdt\n\ndef fit_odeint(x, beta):\n    return integrate.odeint(sir_model, (S0, I0, R0), x, args=(beta, gamma))[:,1]\n\n#N = 76335\n# N = 23905757\nN = 60000000\n# N = 23905757 # suppongo che siano a riscio 1 terzo della poolazione del nord italia\nI0 = y[0]\nS0 = N - I0\nR0 = 8.\ngamma = 1.\/27\n\npopt, pcov = optimize.curve_fit(fit_odeint, x_scale[:14], y[:14])\nfitted = fit_odeint(x_scale, *popt)\n\nplt.plot(x_scale, y, 'o')\nplt.plot(x_scale, fitted)\nplt.show()","c66d518e":"beta = copy.deepcopy(popt)\nprint(\"beta: \" + str(beta) + \"\\ngamma: \"+ str(gamma))","7efa8ed4":"# Initial conditions vector\ny0 = S0, I0, R0\n# gamma = 1.\/37\n# prova a rendere variabile beta a aseconda di t \n# Integrate the SIR equations over the time grid, t. \nret = odeint(deriv, y0, t, args=(N, beta, gamma))\nS, I, R = ret.T\n\nt_plot = np.arange(160)\n\nfig = plt.figure(facecolor='w', figsize=(7, 5))\nax = fig.add_subplot(111, facecolor='#dddddd', axisbelow=True)\nax.plot(x_scale, y, 'ko', label=\"Original Confirmed Cases\")\nx_new, y_pred = predict_confirmed_x_day_from_now(7)\nax.plot(x_new, exp_func(x_new, a, b, c), 'r-', label=\"Fitted Curve extended\", color='purple')\n\nax.plot(t_plot, S[:len(t_plot)], 'b', alpha=0.5, lw=2, label='Susceptible')\nax.plot(t_plot, I[:len(t_plot)], 'r', alpha=0.5, lw=2, label='Infected')\nax.plot(t_plot, R[:len(t_plot)], 'g', alpha=0.5, lw=2, label='Recovered with immunity')\nax.grid(b=True, which='major', c='w', lw=2, ls='-')\nax.title.set_text('Forecast in Italy without Quarantine measures')\nplt.legend()\nplt.savefig('SIR.png')\nplt.show()\npeak = int(t[np.where(I == max(I))[0][0]])\n# questo sarebbe da tramutare in data\npeak_date = ita['date'][0] + timedelta(days=peak)\n\nI_drop = I[t[np.where(I == max(I))[0][0]]:] # dal picco quando vale meno di  ... TOT\nend = int(t[np.where(I == I_drop[I_drop < 50][0])])\nend_date = ita['date'][0] + timedelta(days=end)\nprint(\"PEAK OF INFETED CASE: \" + str(max(I)) + \"\\nPEAK DATE : \" + str(peak_date) + \"\\nEND DATE: \" + str(end_date))","56e17cd4":"def deriv_quarantine(y, t, N, beta, gamma, q, p):\n    if t<=14:\n        S, I, R = y\n        dSdt = -beta * S * I \/ N\n        dIdt = beta * S * I \/ N - gamma * I\n        dRdt = gamma * I\n    else:\n        S, I, R = y\n        dSdt = -beta * p * S * I \/ N\n        dIdt = beta  * q * S * I \/ N - gamma * I\n        dRdt = gamma * I \n    return dSdt, dIdt, dRdt\n\ndef simulate_quarantine (q, p, t_plot):\n    \n    ret_Q = odeint(deriv_quarantine, y0, t, args=(N, beta, gamma, q, p))\n    S_Q, I_Q, R_Q = ret_Q.T\n\n    x_new, y_pred = predict_confirmed_x_day_from_now(7)\n\n    fig = plt.figure(facecolor='w', figsize=(16, 11))\n    # fig, (ax1,ax2) = plt.subplots(12, figsize=(10,4), facecolor = 'w')\n    ax1 = fig.add_subplot(221, facecolor='#dddddd', axisbelow=True)\n    ax1.plot(x_scale, y, 'ko', label=\"Original Confirmed Cases\")\n    ax1.plot(x_new, exp_func(x_new, a, b, c), 'r-', label=\"Fitted Curve extended\", color='purple')\n    ax1.plot(t_plot, S_Q[:len(t_plot)], 'b', alpha=0.5, lw=2, label='Susceptible')\n    ax1.plot(t_plot, I_Q[:len(t_plot)], 'r', alpha=0.5, lw=2, label='Infected')\n    ax1.plot(t_plot, R_Q[:len(t_plot)], 'g', alpha=0.5, lw=2, label='Recovered with immunity')\n    ax1.grid(b=True, which='major', c='w', lw=2, ls='-')\n    ax1.legend()\n    ax1.title.set_text('Italy SIRqp')\n\n    ax2 = fig.add_subplot(222, facecolor='#dddddd', axisbelow=True)\n    ax2.plot(x_scale, y, 'ko', label=\"Original Confirmed Cases\")\n    ax2.plot(x_new, exp_func(x_new, a, b, c), 'r-', label=\"Fitted Curve extended\", color='purple')\n    # ax.plot(t, S_Q, 'b', alpha=0.5, lw=2, label='Susceptible')\n    ax2.plot(t_plot, I_Q[:len(t_plot)], 'r', alpha=0.5, lw=2, label='Infected')\n    ax2.plot(t_plot, R_Q[:len(t_plot)], 'g', alpha=0.5, lw=2, label='Recovered with immunity')\n    ax2.grid(b=True, which='major', c='w', lw=2, ls='-')\n    ax2.legend()\n    ax2.title.set_text('Italy SIRqp Model detail')\n\n    t_detail = np.arange(30)\n\n    ax3 = fig.add_subplot(223, facecolor='#dddddd', axisbelow=True)\n    ax3.plot(x_scale, y, 'ko', label=\"Original Confirmed Cases\")\n    ax3.plot(x_new, exp_func(x_new, a, b, c), 'r-', label=\"Fitted Curve extended\", color='purple')\n    # ax.plot(t, S_Q, 'b', alpha=0.5, lw=2, label='Susceptible')\n    ax3.plot(t_detail, I_Q[:len(t_detail)], 'r', alpha=0.5, lw=2, label='Infected')\n    ax3.plot(t_detail, R_Q[:len(t_detail)], 'g', alpha=0.5, lw=2, label='Recovered with immunity')\n    ax3.grid(b=True, which='major', c='w', lw=2, ls='-')\n    ax3.legend()\n    ax3.title.set_text('Detail of the shit for the quarantine in I curve')\n\n    plt.show()\n    \n    return [S_Q, I_Q, R_Q]\n\n\ndef sir_model_qp(y, x, beta, gamma, q, p):\n    S, I, R = y\n    dSdt = -beta * p * S * I \/ N\n    dIdt = beta * q * S * I \/ N - gamma * I\n    dRdt = gamma * I\n    return dSdt, dIdt, dRdt\n\ndef fit_odeint_qp(x, q):\n    return integrate.odeint(sir_model_qp, (S0_qp, I0_qp, R0_qp), x, args=(beta, gamma, q, p))[:,1]\n\n# set initial conditions\nI0_qp = y[14]\nS0_qp = N - I0_qp\nR0_qp = 1187\ngamma = 1.\/27\n\n# q = 4.5\/7 # quaratine for the infected\np = 7\/2 # quarantine for the susceptibles supponendo che in media una persona in quarantena esca giorni in una settimana\np = 56 \/ 6 # considerando 7 giorni * 8 ore \/ 6 ore in media di uscita a settimana durante la quarantena\n\n# Initial conditions vector\ny0_qp = S0_qp, I0_qp, R0_qp\n\npopt_qp, pcov_qp = optimize.curve_fit(fit_odeint_qp, x_scale[14:]-x_scale[14], y[14:])\n\nfitted = fit_odeint_qp(x_scale[14:]-x_scale[14], *popt_qp)\nq = copy.deepcopy(popt_qp)\n\nplt.plot(x_scale[14:]-x_scale[14], y[14:], 'o')\nplt.plot(x_scale[14:]-x_scale[14], fitted)\nplt.show()","2cf59422":"# supponendo che in una settimana per 5 giorni una persona S sia in casa... aumentato di 5 volte il tasso di riduzione dei S\n# tasso q di incremento dei I diminuito di un fatto re 5\/7\nt_plot = np.arange(160)\nS_Q, I_Q,R_Q = simulate_quarantine(q, p, t_plot)\n\npeak = int(t[np.where(I_Q == max(I_Q))[0][0]])\n# questo sarebbe da tramutare in data\npeak_date = ita['date'][0] + timedelta(days=peak)\n\nI_drop = I_Q[t[np.where(I_Q == max(I_Q))[0][0]]:]  # dal picco quando vale meno di  ... TOT\nend = int(t[np.where(I_Q == I_drop[I_drop < 50][0])])  # dal picco quando vale meno di  ... TOT\nend_date = ita['date'][0] + timedelta(days=end)\nprint(\"p: \" + str(p) +\"\\nq: \" + str(q) + \"\\nPEAK OF INFECTED CASE: \" + str(max(I_Q)) + \"\\nPEAK DATE : \" + str(peak_date) + \"\\nEND DATE: \" + str(end_date))","1be817e2":"Is Computed the Kolmogorov-Smirnov statistic on 2 samples before and after the Dpcm 9 Marzo -> 09\/03\/2020.\nThis is a two-sided test for the null hypothesis that 2 independent samples are drawn from the same continuous distribution.","169d9c7e":"It's noticeable how the quarantine measures push forward in time the max peak of Infected people, also dropping the total number of Infected.\nThe SIR_qp shows also a closer end of the deseas in the Country.\n\nFrom further simulations appears that the **p** factor is responsible for possible improvements in the forecasts outcomes. The more peaple stay home (reducing virtualy the population of Susceptibles), the more the spread of Covid-19 will come soon to an end.","d80be1be":"The model is defined like:\n\n\\begin{equation}\n\\left\\{\\begin{matrix}\\frac{\\mathrm{d} S}{\\mathrm{d} t} = -\\beta \\cdot \\frac{S \\cdot I}{N}\n\\\\ \\frac{\\mathrm{d} I}{\\mathrm{d} t} = \\beta \\cdot \\frac{S \\cdot I}{N} - \\gamma I\n\\\\ \\frac{\\mathrm{d} R}{\\mathrm{d} t} = \\gamma I\n\\\\\n\\end{matrix}\\right.\n\\end{equation} \n\n\nWhere: \n\n* S     -> Number of **Susceptible**\n* I     -> Number of **Infected**\n* R     -> Number of ** Recovered**\n* Beta\t-> The parameter controlling how often a susceptible-infected contact results in a new infection.\n* Gamma\t-> The rate an infected recovers and moves into the resistant phase.\n\nGamma = 1\/27 from scientific evidence.\nBeta is extimated fitting the model.\nThis brings to the Forecast with no quarantine plan.\n\n\nP.S.\nThe function is fitted on the experimental data before the 09\/03\/2020\n","ae3f2dbe":"# SIR_qp Model\n\nForecast considering quarantine for people of Italy:\n\n\\begin{equation}\n\\left\\{\\begin{matrix}\\frac{\\mathrm{d} S}{\\mathrm{d} t} = -\\beta \\cdot p \\cdot \\frac{S \\cdot I}{N}\n\\\\ \\frac{\\mathrm{d} I}{\\mathrm{d} t} = \\beta \\cdot q \\cdot \\frac{S \\cdot I}{N} - \\gamma I\n\\\\ \\frac{\\mathrm{d} R}{\\mathrm{d} t} = \\gamma I\n\\\\\n\\end{matrix}\\right.\n\\end{equation} \n\n\n* p = is the rate for the quarantine of the Susceptibles \n* q = is the rate of quarantine for the Infected\n\n## Fitting the new distribution\n\n* Value p is setted at p = 56 \/ 6. It represents the hours spent away from home on average by a person\n* Firstly, the new distribution is fitted to obtain the q value.","dcbb68c0":"# Summary of activities\n\n* Dynamic Maps\n  * Italy (Regions, Provinces)\n  * World\n* Exponential fit\n* SIR Model\n* SIR_qp Model","ba5c830a":"If the KS statistic is small or the p-value is high, then we cannot reject the hypothesis that the distributions of the two samples are the same.\nIn this case the ****distributions are statistically different****,  we can reject the null hypothesis since the pvalue is below 1%","9258510a":"# Trend analysis in Italy\n\nThe data is aggregated at country level.\n","d8c8ba18":"Here, an overview of the main insight from the dataset is given","91fda313":"# An overview on Italy \n\n![image.png](attachment:image.png)\n\nThe Dipartimento della Protezione Civile, uploads everyday at 18:30 an update on the spread of the Covid-19 in Italy.\n\nYou can found the raw data used in this analysis following the link: -> https:\/\/github.com\/pcm-dpc\/COVID-19","dc35bbe6":"## Scope\n\nIn the first section this work tries to provide the reader the right data vizualization tools for boost the comprehension of the global and local spread of the Covid-19.\n\nIn the second part, predictive models on the spread of the virus will be given.","287e9395":"The difference in the two exponential curves is noticeable but it's statistically relevant?\nFor addressing this question the rate of propagation is computed","2487ed77":"# World comparison\nThe global situation is taken from the dataset [covid_19_clean_complete.csv](https:\/\/www.kaggle.com\/imdevskp\/corona-virus-report)","915fe5a0":"It is noticeable that the trand prensent a drop after the 9 of March, start date of the [quarantine measure](http:\/\/www.governo.it\/it\/articolo\/firmato-il-dpcm-9-marzo-2020\/14276)  take by Italy as a country.","287e3449":"# SIR Model\n\nHere a simple SIR Model is fitted and plotted.\nThe fisrt step is to calculate the Infected -> ****I**** \n\nlike Confirmed - Recovered - Deaths\n","67acf9c3":"## Exponential approximation\n\nHence, it's easy by plotting the confirmed cases data to notice that they could be approximated by an exponential curve.\n\nIt's also noticeable a change in the curve after the [Dpcm 9 Marzo 2020](http:\/\/www.governo.it\/it\/articolo\/firmato-il-dpcm-9-marzo-2020\/14276) ","374715bb":"## Last Update\n\u2193\u2193\u2193\n","f2094b4e":"Then the SIR_qp Model is computed"}}