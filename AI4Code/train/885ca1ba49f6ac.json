{"cell_type":{"bf120e3f":"code","b6558763":"code","4bc545ee":"code","3b1c7326":"code","498cb378":"code","fe980dcb":"code","e35c9dec":"code","3b4d821f":"code","5a8131a9":"code","a65d9e70":"code","0beb510c":"code","dc72c6e9":"code","4d1ba69a":"code","1c33c1e6":"code","6a3a82fb":"code","2cedbf79":"code","d06ff4a2":"code","05d7b5c6":"code","a6553839":"code","3b3056ef":"code","2ce598c7":"code","10175fd1":"code","3933e1dc":"code","7212ef55":"code","96e8706a":"code","bf6f0536":"code","26b59638":"code","a56d41f7":"code","0e5048f6":"code","7b0ef142":"code","f5693e43":"code","5439d8e7":"code","490a815d":"code","cdd54bee":"code","be97eb81":"code","2b76d866":"code","e71a0ae6":"code","bb58c1bc":"code","f07214c7":"code","1be14d38":"code","da9599da":"code","c37552d0":"code","1b4e599b":"markdown","46d5af48":"markdown","4a961c2b":"markdown","ed1099d9":"markdown","7c7eefb0":"markdown","8567ff8b":"markdown","ddd2913e":"markdown","9bfbe31a":"markdown","21936ee3":"markdown","8c3aaffc":"markdown","d7993d6d":"markdown","0859518e":"markdown","5cf46f0e":"markdown","4c9064e1":"markdown","0ba9ab62":"markdown","97222144":"markdown","4986b642":"markdown","d452ea51":"markdown","388f4440":"markdown","64611077":"markdown","3e815bbd":"markdown"},"source":{"bf120e3f":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\nimport time","b6558763":"df = pd.read_csv('..\/input\/new-york-city-airbnb-open-data\/AB_NYC_2019.csv')","4bc545ee":"df.head()","3b1c7326":"df.info()","498cb378":"print(\"Number of houses with non positive price (data quality issue): \", (df.price <= 0).sum())","fe980dcb":"df = df[df.price > 0]","e35c9dec":"df.nunique()","3b4d821f":"print(\"Number of houses with a non unique position: \", df[df.duplicated([\"latitude\", \"longitude\"], keep = False)].shape[0])\nprint(\"Number of unique positions within this segment: \", df[df.duplicated([\"latitude\", \"longitude\"], keep = False)].drop_duplicates([\"latitude\", \"longitude\"]).shape[0])","5a8131a9":"df.room_type.value_counts()","a65d9e70":"sns.scatterplot(data = df,\n                x = \"longitude\",\n                y = \"latitude\",\n                size = .5,\n                legend = False)\n\nplt.axis(\"off\")\n\nplt.show()","0beb510c":"import  geopandas as gpd\n\nny = gpd.read_file(\"..\/input\/neighborhoods-in-new-york\/ZillowNeighborhoods-NY.shp\")\n\nny = ny[ny.City == \"New York\"]\n\nny.head()","dc72c6e9":"ny[\"Area\"] = ny.geometry.area","4d1ba69a":"gdf = gpd.GeoDataFrame(\n    df, geometry=gpd.points_from_xy(df.longitude, df.latitude),\n    crs={'init':'epsg:4326'})","1c33c1e6":"gdf.head()","6a3a82fb":"fig, ax = plt.subplots(1, 2, figsize = (15,10))\ngdf.plot(\"neighbourhood_group\", markersize = .7, ax = ax[0], legend = True)\nny.plot(column = \"County\", legend = True, alpha = .4, ax = ax[1])\n\nplt.plot()","2cedbf79":"ny[\"County\"].replace({\"New York\": \"Manhattan\",\n                     \"Kings\": \"Brooklyn\",\n                     \"Richmond\": \"Staten Island\"\n                    }, inplace = True)","d06ff4a2":"fig, ax = plt.subplots(figsize = (15,10))\n\nny.plot(column = \"County\", legend = True, alpha = .4, ax = ax)\ngdf.plot(markersize = .7, ax = ax)\n\nplt.axis(\"off\")\n\nplt.plot()","05d7b5c6":"gdf = gpd.sjoin(gdf[[\"neighbourhood_group\", \"neighbourhood\", \"price\", \"minimum_nights\", \"geometry\"]], \n                ny[[\"County\", \"Name\", \"Area\", \"geometry\"]])\n\ngdf.head()","a6553839":"d = gdf.groupby([\"Name\"]).size().reset_index()\nd.columns = [\"Name\", \"N_Houses\"]\n\nd.head()","3b3056ef":"d = ny.merge(d,\n         how = \"left\",\n         on = \"Name\"\n        )\n\nd[\"Density\"] = d[\"N_Houses\"]\/d[\"Area\"]\n\nd.head()","2ce598c7":"fig, ax = plt.subplots(figsize=(10,8))\nd.plot(ax = ax,\n        cmap = sns.cubehelix_palette(start = 2.5, \n                                     rot = .1, \n                                     gamma = .7,\n                                     hue = .7, \n                                     light = .8,\n                                     dark = 0, \n                                     as_cmap = True\n                                    ),\n        column = \"Density\",\n       edgecolor = \"#ffffff\"\n       )\n\nplt.axis(\"off\")\n\nplt.show()","10175fd1":"import matplotlib.cm as cm\nfrom matplotlib.colors import Normalize ","3933e1dc":"df.head()","7212ef55":"df.price.describe()","96e8706a":"df.price.quantile(np.arange(0., 1.01, .05))","bf6f0536":"norm = Normalize(vmin=0,\n                 vmax=250,\n                 clip=True\n                 )","26b59638":"fig, ax = plt.subplots(1, figsize=(15,10))\n\nny.plot(ax = ax, edgecolor = \"#a6a6a6\", color = \"white\")\n\nsns.scatterplot(data = df,\n                y = \"latitude\",\n                x = \"longitude\", \n                hue = \"price\", \n                palette = \"magma\",\n                size = .3,\n                hue_norm = norm,\n                legend = False, ax = ax\n               )\n\ncbar = cm.ScalarMappable(norm=norm, cmap='magma')\ncbar = fig.colorbar(cbar, \n                   ticks = [0,\n                            50,\n                            100,\n                            150,\n                            200,\n                            250\n                           ], \n                    ax = ax)\n\nplt.axis(\"off\")\n\ncbar.ax.set_yticklabels([\"\u20ac0\", \"\u20ac50\", \"\u20ac100\", \"\u20ac150\", \"\u20ac200\", \"more than \u20ac250\"], fontsize = 15)\n\nax.set_title(\"Map of airbnb house prices in NY\", fontsize = 15)\n\nplt.show()\n\n\n\n# plt.xlim(-74.5, -73)\n# plt.ylim(40.5,41)","a56d41f7":"df.room_type.unique()","0e5048f6":"np.seterr(under='ignore')\nsns.set(font_scale=2)\nfg = sns.FacetGrid(data = df[df.price < 500], col = \"neighbourhood_group\", col_wrap = 3, height = 9)\nfg.map(sns.violinplot, \"room_type\", \"price\")\nplt.show()","7b0ef142":"fig, ax = plt.subplots(2, 2, figsize=(20,20))\n\nfor a in ax.reshape(-1)[:3]:\n    a.axis(\"off\")\n    ny.plot(ax = a, edgecolor = \"#a6a6a6\", color = \"white\")\n    \nax[1,1].axis(\"off\")\n\nsns.scatterplot(data = df[df.room_type == \"Shared room\"],\n                y = \"latitude\",\n                x = \"longitude\", \n                hue = \"price\", \n                palette = \"magma\",\n                size = .3,\n                hue_norm = norm,\n                legend = False, ax = ax[0,0]\n               )\n\nsns.scatterplot(data = df[df.room_type == \"Private room\"],\n                y = \"latitude\",\n                x = \"longitude\", \n                hue = \"price\", \n                palette = \"magma\",\n                size = .3,\n                hue_norm = norm,\n                legend = False, ax = ax[0,1]\n               )\n\nsns.scatterplot(data = df[df.room_type == \"Entire home\/apt\"],\n                y = \"latitude\",\n                x = \"longitude\", \n                hue = \"price\", \n                palette = \"magma\",\n                size = .3,\n                hue_norm = norm,\n                legend = False, ax = ax[1,0]\n               )\n\n\ncbar = cm.ScalarMappable(norm=norm, cmap='magma')\ncbar = fig.colorbar(cbar, \n                   ticks = [0,\n                            50,\n                            100,\n                            150,\n                            200,\n                            250\n                           ], \n                    ax = ax[1, 1])\n\n\n\ncbar.ax.set_yticklabels([\"\u20ac0\", \"\u20ac50\", \"\u20ac100\", \"\u20ac150\", \"\u20ac200\", \"more than \u20ac250\"], fontsize = 15)\n\nax[0, 0].set_title(\"Prices of Shared Rooms\", fontsize = 15)\nax[0, 1].set_title(\"Prices of Private Rooms\", fontsize = 15)\nax[1, 0].set_title(\"Prices of Entire homes or apartments\", fontsize = 15)\n\nplt.show()","f5693e43":"subway = gpd.read_file(\"..\/input\/ny-geodata\/geo_export_3aa73ff9-4ce9-4951-8d6c-2fd706580916.shp\", crs={\"init\": \"epsg:4326\"})","5439d8e7":"subway.head()","490a815d":"gdf = gpd.GeoDataFrame(\n    df, geometry=gpd.points_from_xy(df.longitude, df.latitude),\n    crs={'init':'epsg:4326'})\n\n# Creation of the projected data frames\nsubway_xy = subway.to_crs(epsg = 3763)\ngdf_xy = gdf.to_crs(epsg=3763)\n\n# Creation of three data frames representing the areas near the subway stations\nsubway_xy200 = gpd.GeoDataFrame({\"200mt\": [1]*473, \"geometry\": subway_xy.buffer(200)})\nsubway_xy500 = gpd.GeoDataFrame({\"500mt\": [1]*473, \"geometry\": subway_xy.buffer(500)})\nsubway_xy1 = gpd.GeoDataFrame({\"1km\": [1]*473, \"geometry\": subway_xy.buffer(1000)})","cdd54bee":"# House data frame is merged with the data of subway proximity. Notice that it is possible that an house might be \n# within 1000 (or 500 or 200) metres away from multiple subway stations. Hence duplicated id must be removed\n\ngdf_xy = gpd.sjoin(gdf_xy, subway_xy200, how = \"left\")\ngdf_xy.drop(\"index_right\", axis = 1, inplace = True)\n\ngdf_xy = gpd.sjoin(gdf_xy, subway_xy500, how = \"left\")\ngdf_xy.drop(\"index_right\", axis = 1, inplace = True)\n\ngdf_xy = gpd.sjoin(gdf_xy, subway_xy1, how = \"left\")\ngdf_xy.drop(\"index_right\", axis = 1, inplace = True)\n\ngdf_xy[[\"200mt\", \"500mt\", \"1km\"]] = gdf_xy[[\"200mt\", \"500mt\", \"1km\"]].fillna(0)\n\ngdf_xy = gdf_xy.groupby(\"id\").agg({\"200mt\": \"max\",\n                          \"500mt\": \"max\",\n                          \"1km\": \"max\",\n                        })\n\n# These new features are merged in the original geo data frame\ngdf = gdf.merge(gdf_xy, how = \"left\", on = \"id\")","be97eb81":"gdf_xy.head()","2b76d866":"display(gdf[\"200mt\"].value_counts())\ndisplay(gdf[\"500mt\"].value_counts())\ndisplay(gdf[\"1km\"].value_counts())","e71a0ae6":"# Some data quality check (if the nearest subway station is within 200 meters, it must be also within 1000 meters)\ndisplay(gdf.loc[gdf[\"200mt\"] == 1, \"500mt\"].value_counts())\ndisplay(gdf.loc[gdf[\"200mt\"] == 1, \"1km\"].value_counts())\ndisplay(gdf.loc[gdf[\"500mt\"] == 1, \"1km\"].value_counts())","bb58c1bc":"gdf[\"SubwayLoc\"] = \"No Near Subways\"\ngdf.loc[gdf[\"1km\"] == 1, \"SubwayLoc\"] = \"Subway within 1km\"\ngdf.loc[gdf[\"500mt\"] == 1, \"SubwayLoc\"] = \"Subway within 500mt\"\ngdf.loc[gdf[\"200mt\"] == 1, \"SubwayLoc\"] = \"Subway within 200mt\"","f07214c7":"gdf.SubwayLoc.value_counts()","1be14d38":"gdf[\"P\"] = gdf[\"price\"]\n\ngdf.loc[gdf[\"P\"] > 500, \"P\"] = 500","da9599da":"np.seterr(under='ignore')\nsns.set(font_scale=2)\nfg = sns.FacetGrid(data = gdf, col = \"room_type\", col_wrap = 3, height = 9)\nfg.map(sns.violinplot, \"SubwayLoc\", \"P\")\nfg.set_xticklabels(rotation=30)\nplt.show()","c37552d0":"np.seterr(under='ignore')\nsns.set(font_scale=2)\nfg = sns.FacetGrid(data = gdf[gdf[\"neighbourhood_group\"] == \"Manhattan\"], col = \"room_type\", col_wrap = 3, height = 9)\nfg.map(sns.violinplot, \"SubwayLoc\", \"P\")\nfg.set_xticklabels(rotation=30)\nplt.show()","1b4e599b":"## 1. Import<a id='import'><\/a>\n[Back to table of contents](#toc)","46d5af48":"### 3.2.1 Price for each Room Type<a id='room_type'><\/a>\n[Back to table of contents](#toc)","4a961c2b":"In order to match the neighbourhood shapefile with house data frame, the latter has to be transformed into a geo data frame, by giving a point geometry to the latitude-longitude coordinates. This procedure is easily done by the following cell:","ed1099d9":"<a id = \"area\"><\/a>","7c7eefb0":"## 3. Geographical Analysis<a id='geographical_analysis'><\/a>\n[Back to table of contents](#toc)\n\nHow can we represent Airbnb houses on a map? Latitude (y) and longitude (x) can be seen as standard coordinates in a cartesian plane. So the question above might be answered by just plotting the points with a standard Python library!","8567ff8b":"Until now I have never talked about the coordinate system. The canonical way we intent it is latitude-longitude pair. However, the coordinates are expressed in term of angular distance. This does not allow to compute distance in terms of meters! In order to make it possible, the coordinate system must be changed. In particular in the next cells we will create *subway_xy* and *gdf_xy*, that represent the maps of houses and subways in a projection where the unit of measure is meter. Then we are going to create *subway_xy200, subway_xy500, subway_xy1*, where the geometry is a series of circles with radius 200, 500 and 1000 meters (respectively), centered in each subway station.  \nThese data frames are used to map the proximity property of each house. Eventually the prices of the houses in different areas are visualized via violinplot","ddd2913e":"### 3.2 Price Analysis<a id='price'><\/a>\n[Back to table of contents](#toc)","9bfbe31a":"## 2. Data Exploration<a id='data_exploration'><\/a>\n[Back to table of contents](#toc)\n\n**Outline of the section:**  \nThis section won't go in depth with technical details and explanations, since the internet is full of excellent tutorials about standard data exploration. But it is quite interesting to higlight some observation about latitude, longitude and price (the most important variables for this analysis):\n* As far as coordinates are concerned, there is no data quality issue, since no missing data about them. In the following sections, we will see wether all coordinates lie in New York;  \n* It is interesting to notice that there are 23 locations where multiple houses\/rooms are being offered;\n* Price variable has 11 rows with a non positive value. These are surely impossible! Hence these rows are deleted.  \n\nOne other variable that will be used is *room_type*. It has only 3 unique values: *Private room*, *Entire home\/apt* and *Shared room*.","21936ee3":"### 3.1 Density Analysis<a id='density'><\/a>\n[Back to table of contents](#toc)","8c3aaffc":"<a id = \"shapefile\"><\/a>Ok. That is nice. But is it really New York? Can we do more with coordinates?  \nHere comes the trick. Imagine we want to determine in which neighbourhood a point (i.e. a house) lies. Would you be able to do it with the plot above? Even for a New York expert, this task is pretty challenging. But what about the following graph?\n![Img_GeoData.png](attachment:Img_GeoData.png)\nNow it is easy to see that the red dot lies in the Williamsburg neighbourhood. Under the hood, what we do is intersecting the dot with Williamsburg geometry and see that there is a match!  \nHow can this methodology be translated and generalized into code? Here comes shapefile. This data format allows you to work with geometries, by coupling the standard data frame structure with a geometric feature.\n![image.png](attachment:image.png)\nTh .shp attribute can be anything: it could be a simple surface (e.g. circles and polygons), a line or a point, but also a more complex *multipolygon* that could represent an entire country, for example Unated States. When looking at a shapefile, you can notice that it always comes with at least three files:\n* .shp &#8594; the file containing the geometries;\n* .shx &#8594; the file containing the indexes associated with each geometry. It is used to couple geometries with the data frame;\n* .dbf &#8594; the data frame file;  \n\nThere are often other files other than these used for other extensions. For example files with .prj extension are used to specifiy the coordinate system of the data.  \n\n**In Python** the most used library for working with shapefiles is **geopandas**. It is a versatile library, that easily integrates with its classic version: pandas. In particular, geopandas enables all methods used in pandas and its only difference is that it requires a *geometry* column. Moreover the operations that return just the data frame (without the geometry column) output a pandas data frame. Thus we could imagine a geopandas data frame as a pandas data frame with a geometry column and vice versa.\n\nIn the next cells, a shapefile whose geometries represent NY's neighborhoods is imported, and for each neighbourhood [the area is computed](#area).","d7993d6d":"# <font id = \"toc\" size=\"5\">Table of contents<\/font>\n\n[1. Import](#import)  \n[2. Data Exploration](#data_exploration)  \n[3. Geographical Analysis](#geographical_analysis)  \n&emsp;[3.1 Density](#density)  \n&emsp;[3.2 Price](#price)  \n&emsp;&emsp;[3.2.1 For room type](#room_type)  \n[4. Proximity analysis](#proximity)","0859518e":"**About this notebook:**  \nWelcome to my first puclic notebook! In this file, I am exploring the dataset from a geographical point of view and I am showing some basic concept of geographical analysis through *geopandas* library. We are going to have fun with distributions, densities and plots!  \n\nIn the first part of the notebook, I am going to have a quick overview on the dataset, then I will work on the geographical properties of the data through geopandas, by first introducing [shapefiles](#shp), then by considering distributions, areas, geometrical operations (e.g. union) and densities. Eventually ([section 4](#proximity)), I am going to explain how *distance* works in geopandas and how this functionality can be used in this dataset, by combining house locations and subway stations.\n\nI hope my code and explanations will be clear and easy to understand! Otherwise, I hope to receive some feedback!","5cf46f0e":"## 4. Proximity Analysis<a id='proximity'><\/a>\n[Back to table of contents](#toc)","4c9064e1":"#### Map of house prices for each room type","0ba9ab62":"Since the violinplot do not show any particular difference (quite surprisingly to me), I am going to make the same exact plot just for the Manhattan area..","97222144":"Now, pay attention to the output above. If we plotted the price with a gradient colouring, less than 5% of the houses would be mapped as *high price*. Most importantly, 95% of the houses would be of a similar color. To say, the difference between a 10\\\\$ house and 350\\\\$ one is insignificant compared to the difference between a 350\\\\$ and a 10000\\\\$ house. Thus I decided to create the gradient between 0\\\\$ and 250\\\\$, and all houses with an higher price will be plotted with the same color of a 250\\\\$ apartment","4986b642":"<a id = \"density_result\"><\/a>","d452ea51":"This subsection tries to highlight in which neighbourhood there is the highest number of houses. In particular, after merging  the house geo data frame with the geo data frame of New York (by intersecting the geometries), the number of houses in each neighbourhood is divided by the total area.  \n[The result](#density_result) shows that the areas with the higher offer are Manhattan and the upper side of Brooklyn.","388f4440":"It is plausible that the price can be influenced by the proximity of some attraction or utility. For example the following cells aims at investigating the relationship between the price of the house and the proximity to a subway station. One may suppose that the nearer a subway is, the more comfortable the apartment is for a tourist! So first of all, let's import the shapefile of the subway stations","64611077":"It is nice to see that the areas with an higher density are also the ones with an higher price","3e815bbd":"Now, let's start to have fun! First of all, let's plot the Counties in two different ways: \n1. using the house data frame, grouping by *neighbourhood_group*;\n2. using the shapefile, with color determined by *County*."}}