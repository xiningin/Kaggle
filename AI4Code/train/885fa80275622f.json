{"cell_type":{"39f13661":"code","80a1e326":"code","357c2d8d":"code","a959575d":"code","e1d17eee":"code","0d2e25b3":"code","b83e89aa":"code","070268ee":"code","9d06e323":"code","e8adcaec":"code","56117881":"code","6497104b":"code","26e3b484":"code","e14dbec2":"code","415ab283":"code","530e2548":"code","773bca2d":"code","f3bc813c":"code","704860aa":"code","45d134f5":"code","3965242d":"code","1a1f23d8":"code","6fdf26fc":"code","43cb96d9":"code","1d502f43":"code","acef6ba1":"code","9f5f3714":"code","1dda0c64":"code","b92be09f":"code","7f43ec49":"code","09adc0be":"code","2d858caa":"code","c937e26d":"code","2777d0b8":"code","9e23a7ee":"code","0668a3c3":"code","016a70da":"code","2d6da5e7":"code","ce47a48f":"code","7578452a":"code","ca9c50b1":"code","1a08cd2d":"markdown","1b08ce4a":"markdown","a1f71515":"markdown","8723979b":"markdown","b99d9092":"markdown"},"source":{"39f13661":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nFILEPATH = \"..\/input\/iris\/Iris.csv\"","80a1e326":"import matplotlib.pyplot as plt\nplt.rcParams[\"figure.figsize\"] = (8,8)","357c2d8d":"from sklearn.model_selection import train_test_split","a959575d":"IRIS_DATA = pd.read_csv(FILEPATH)\nIRIS_DATA","e1d17eee":"\nGROUPS = IRIS_DATA.groupby(\"Species\")\n\n# iris_data.grouby(\"Species\") \"groups\" rows by the name of each distinct value in the \"Species\" column\n# Each \"group\" is \"like\" a dataframe itself (just like iris_data, mostly)\n# groupby also names each group by the corresponding value in the \"grouping\" column.\n","0d2e25b3":"i = 0\nfor x, y in GROUPS:\n    i = i + 1\n    # Each var is a tuple of two objects: (var[0], var[1])\n    print(f\"Object# {i}\", x, type(y))\n    \n    # Those interested can look up the term \"Duck typing\".\n","b83e89aa":"# Can iterables have tuples of different sizes?\ncollection = [(1, 2), (\"a\", \"b\", 1), (\"e\",), (True, False, 1, 3, 5)] #Single element tuples might need a comma!\n\nfor x in collection:\n    print(x[0])","070268ee":"fig, axis = plt.subplots()\nfor name, group in GROUPS:\n    print(name)\n    axis.plot(\n        group[\"SepalLengthCm\"],\n        group[\"SepalWidthCm\"],\n        label = name.replace(\"-\", \" \"),\n        marker = \"o\",\n        linestyle=\"\"\n    )\n    \naxis.set_xlabel(\"Sepal Length (cm)\")\naxis.set_ylabel(\"Sepal Width (cm)\")\n\naxis.legend()","9d06e323":"IRIS_TRAIN, IRIS_TEST = train_test_split(IRIS_DATA, train_size = 0.6)","e8adcaec":"IRIS_TRAIN","56117881":"# We need to keep potting again and again, so let us introduce a function to encapsulate this code\n\ndef plot_iris_like_data(iris_like_df):\n    fig, axis = plt.subplots()\n    groups = iris_like_df.groupby(\"Species\")\n    \n    for name, group in groups:\n        axis.plot(\n            group[\"SepalLengthCm\"],\n            group[\"SepalWidthCm\"],\n            label = name.replace(\"-\", \" \"),\n            marker = \"o\",\n            linestyle=\"\"\n        )\n\n    axis.set_xlabel(\"Sepal Length (cm)\")\n    axis.set_ylabel(\"Sepal Width (cm)\")\n    axis.legend()\n    #return fig, axis\n","6497104b":"plot_iris_like_data(IRIS_TRAIN)","26e3b484":"IRIS_MATRIX_DATA = IRIS_TRAIN[[\"SepalLengthCm\", \"SepalWidthCm\"]].to_numpy()\n#print(\"Shape is {IRIS_MATRIX_DATA.shape}\")  #Tuple which says how may rows and columns the matrix has.\nprint(f\"Shape is {IRIS_MATRIX_DATA.shape}\")  #Tuple which says how may rows and columns the matrix has.\nIRIS_MATRIX_DATA\n\n","e14dbec2":"# Creat a column of ones\nones = np.ones((IRIS_MATRIX_DATA.shape[0], 1))  #Good not to use \"magic numbers\": makes maintaining the code much easier\n# We want to 'horizontally\" stack this column to the right of the matrix.\nIRIS_MATRIX_DATA = np.hstack((IRIS_MATRIX_DATA, ones ))\n# NOTICE: np.hstack takes only one argument, which is all tuples of all the matrices in the order in which they have to be stacked.","415ab283":"IRIS_MATRIX_DATA","530e2548":"#Since we will have to repeat this for the test data also, instead of copying code, let us make this a function\n\ndef array_from_data(iris_df):\n    matrix_data = iris_df[[\"SepalLengthCm\", \"SepalWidthCm\"]].to_numpy()\n    matrix_data_dim = matrix_data.shape  #Tuple which says how may rows and columns the matrix has.\n    ones = np.ones((matrix_data_dim[0], 1))  #Good not to use \"magic numbers\": makes maintaining the code much easier\n    # We want to 'horizontally\" stack this column to the right of the matrix.\n    return np.hstack((matrix_data, ones))\n    # NOTICE: np.hstack takes only one argument, which is a tuple of all the matrices in the order in which they have to be stacked.\n","773bca2d":"array_from_data(IRIS_TRAIN)\n#Always a good idea to CAPITALIZE all global variables.","f3bc813c":"# We also need the labels\n\n#\n\n# We want to work in terms of signs  (+1\/-1)\n\ndef sign_encode(species_name):\n    #If the species name is \"Iris-setosa\" it should return 1 else -1\n    if species_name == \"Iris-setosa\":\n        # \"==\" is for checkign equality.  \"=\" is for assigning values to variables.\n        return 1.0\n    else:\n        return -1.0\n\nsign_encode(\"my_favourite_species\")\nIRIS_LABELS = np.vectorize(sign_encode)(IRIS_TRAIN[\"Species\"].to_numpy())","704860aa":"IRIS_MATRIX_DATA","45d134f5":"IRIS_LABELS","3965242d":"import math\ndef perceptron_evaluate(w, x):\n    \"\"\"Returns the sign label of x as predicted by the perceptron w.\n    In other wordes, return sign(w\u00b7x), where \u00b7 represents the inner product of w and x.\n    \"\"\"\n    return np.sign(np.dot(x, w)) #np.dot(w, x) will be wrong when x has more than one data point!\n\n\n    #sum = 0\n    #l = len(w)\n    #for i in range(l):\n        #sum += w[i]*x[i]   #This can already cause problems!  Read `Kahan Summation` article on Wikipedia.\n    #return math.sign(sum)","1a1f23d8":"perceptron_evaluate(np.array([1, 2]), np.array([3, 4]))","6fdf26fc":"def perceptron_update(w, index, iris_matrix, iris_labels):\n    \"\"\"Evalue the perceptron on the `index`th row of `iris_matrix`,\n    and if the prediction does not match the `index`th row of `iris_labels`,\n    then update w using the perceptron equations discussed in class. \n    \n    Returns the new w, and a flag which is True if the prediction was incorrect.\n    \"\"\"\n    \n    x = iris_matrix[index, :] #Should be the indexth row of the iris_matrix\n    prediction = perceptron_evaluate(w, x)\n    if prediction != iris_labels[index]:\n        return w + iris_labels[index]*x, True\n        #return w - prediction*x\n        # The difference between the two is that when prediction == 0, only the first one makes an update.\n    else:\n        return w, False","43cb96d9":"perceptron_update([1,1,0], 0, IRIS_MATRIX_DATA, IRIS_LABELS)","1d502f43":"def perceptron_round(w, iris_matrix, iris_labels):\n    nrows = iris_matrix.shape[0]\n    round_update = False\n    for index in range(nrows): #Goes from 0 to nrows - 1, as we want\n        w, updated = perceptron_update(w, index, iris_matrix, iris_labels)\n        if updated:\n            round_update = True\n    return w, round_update","acef6ba1":"perceptron_round([1,1,0], IRIS_MATRIX_DATA, IRIS_LABELS)","9f5f3714":"def perceptron(w, iris_matrix, iris_labels):\n    round_count = 1\n    while True:\n        print(f\"Round# {round_count}\")\n        w, updated = perceptron_round(w, iris_matrix, iris_labels)\n        print(w)\n        if not updated:\n            break\n        round_count += 1\n    return w","1dda0c64":"final_w = perceptron([1,1,0], IRIS_MATRIX_DATA, IRIS_LABELS)","b92be09f":"from sklearn.metrics import accuracy_score","7f43ec49":"final_w","09adc0be":"np.sign(IRIS_MATRIX_DATA@final_w)","2d858caa":"perceptron_evaluate(final_w, IRIS_MATRIX_DATA) == np.sign(IRIS_MATRIX_DATA@final_w)","c937e26d":"accuracy_score(IRIS_LABELS, perceptron_evaluate(final_w, IRIS_MATRIX_DATA))","2777d0b8":"IRIS_TEST_MATRIX = array_from_data(IRIS_TEST)","9e23a7ee":"IRIS_TEST_LABELS = np.vectorize(sign_encode)(IRIS_TEST[\"Species\"].to_numpy())","0668a3c3":"IRIS_TEST_MATRIX.shape","016a70da":"IRIS_TEST_PREDICTIONS = perceptron_evaluate(final_w, IRIS_TEST_MATRIX)","2d6da5e7":"accuracy_score(IRIS_TEST_LABELS, IRIS_TEST_PREDICTIONS)","ce47a48f":"final_w.shape","7578452a":"IRIS_MATRIX_DATA.shape","ca9c50b1":"IRIS_MATRIX_DATA@final_w","1a08cd2d":"# Converting to a `numpy` array (matrix)","1b08ce4a":"`GROUPS` is an `iterable`: it can be looped over.\n\nOne way of iterating over `iterable` objects in `python` is through a `for` loop.","a1f71515":"# Variables\n\n1. Must start with a letter ('a'-'z', 'A'-'Z')\n2. Inside, it can contain letters, digits and underscore `_`.","8723979b":"# Train and test\n\nWe do not want to use up the whole data for training: otherwise, for example, we cannot detect overfitting.\n\nWe must dvide the dataset into two parts the `training` set and the `testing` set, and then use only the `training` set for \"learning\" the \"classifier\".\n\nLet us say we assume that we will use 60% of the data for training.\n\n**Question: Which 60%?**\n\n\nHow about first 90\/150?  -- Will completely miss the third species!!\n\nChoosing with a predifined rule might inherit some idiosyncarcy of the order in which the data was collected.\n\nTo get rid of this we want to *randomly* pick the some 90 elements.\n\n\n**But**\n\n- Randomness can be tricky to get right! (In this case it is not so bad, but stil...)\n\n- Since this is a common operation, there probably already exists code doing this.\n    - *well-vetted* and *well-tested* code doing this.\n\n- Do not try to reinvent the wheel for such commmon operations.\n\nWe will use the `train_test_split` function from https:\/\/scikit-learn.org\/stable\/user_guide.html","b99d9092":"We want to adda column of ones to this matrix"}}