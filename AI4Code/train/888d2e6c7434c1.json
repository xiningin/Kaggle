{"cell_type":{"324247fc":"code","c98a6f5f":"code","29c255b6":"code","a3b78e08":"code","13b4903f":"code","56e812da":"code","7dbf46e1":"code","b703685b":"code","32879d9d":"code","088aea5a":"code","accaf230":"code","d372e59d":"code","a6af3c51":"code","6e8ac936":"code","f19c45e6":"code","874cbaff":"code","65c064d8":"code","c800762b":"code","7a5d0a21":"code","5999aec0":"code","2a027bfc":"code","807f384d":"code","78ea0b5d":"code","9864a1fb":"code","e63b87ab":"code","1ff17315":"code","79a0820e":"code","cc549d26":"code","5a08ca4a":"code","ab063807":"code","25535017":"code","15b66859":"code","919dd3d4":"code","9e61092f":"code","d2ce0961":"code","5fb27a14":"code","fb03bad0":"code","b08c29b4":"code","e6edd367":"code","61d3b808":"code","27e8280a":"code","04367e72":"code","d8c7150a":"code","d6e6b194":"code","4910d4df":"code","cf06b34b":"markdown","f1886297":"markdown","a9b35b46":"markdown","4e32be1e":"markdown","97ca3e64":"markdown","1ef9ef3c":"markdown","cccbfd83":"markdown","73d3a922":"markdown","330d72bc":"markdown","b72a60df":"markdown","b0a515be":"markdown","95ba0235":"markdown","f00b4f02":"markdown","52f5d04b":"markdown","bd8fa185":"markdown","e49b7460":"markdown","86139017":"markdown","0159b6c4":"markdown","f0f56a3c":"markdown","7aec9a36":"markdown","7df7a442":"markdown","236bb6d7":"markdown","18ba56a5":"markdown","19e22801":"markdown","74184db4":"markdown","0619f02a":"markdown","02bf4c1d":"markdown","c4fad8d2":"markdown","2b52d469":"markdown","239eeb87":"markdown","4c5ab530":"markdown","c9d5cc86":"markdown","48bf9310":"markdown","9b399843":"markdown","28bcaed3":"markdown","c4d737f2":"markdown"},"source":{"324247fc":"import os\nimport pandas as pd\n\nPATH_TO_DATA = '..\/input\/'\n\ndf_train_features = pd.read_csv(os.path.join(PATH_TO_DATA, \n                                             'train_features.csv'), \n                                    index_col='match_id_hash')\ndf_train_targets = pd.read_csv(os.path.join(PATH_TO_DATA, \n                                            'train_targets.csv'), \n                                   index_col='match_id_hash')","c98a6f5f":"df_train_features.shape","29c255b6":"df_train_features.head()","a3b78e08":"df_train_targets.head()","13b4903f":"X = df_train_features.values\ny = df_train_targets['radiant_win'].values","56e812da":"from sklearn.model_selection import train_test_split\n\nX_train, X_valid, y_train, y_valid = train_test_split(X, y, \n                                                      test_size=0.3, \n                                                      random_state=17)","7dbf46e1":"%%time\nfrom sklearn.ensemble import RandomForestClassifier\nmodel = RandomForestClassifier(n_estimators=100, n_jobs=4, random_state=17)\nmodel.fit(X_train, y_train)","b703685b":"y_pred = model.predict_proba(X_valid)[:, 1]","32879d9d":"y_pred","088aea5a":"from sklearn.metrics import roc_auc_score\n\nvalid_score = roc_auc_score(y_valid, y_pred)\nprint('Validation ROC-AUC score:', valid_score)","accaf230":"from sklearn.metrics import accuracy_score\n\nvalid_accuracy = accuracy_score(y_valid, y_pred > 0.5)\nprint('Validation accuracy of P>0.5 classifier:', valid_accuracy)","d372e59d":"df_test_features = pd.read_csv(os.path.join(PATH_TO_DATA, 'test_features.csv'), \n                                   index_col='match_id_hash')\n\nX_test = df_test_features.values\ny_test_pred = model.predict_proba(X_test)[:, 1]\n\ndf_submission = pd.DataFrame({'radiant_win_prob': y_test_pred}, \n                                 index=df_test_features.index)","a6af3c51":"df_submission.head()","6e8ac936":"import datetime\nsubmission_filename = 'submission_{}.csv'.format(\n    datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S'))\ndf_submission.to_csv(submission_filename)\nprint('Submission saved to {}'.format(submission_filename))","f19c45e6":"from sklearn.model_selection import ShuffleSplit, KFold\ncv = ShuffleSplit(n_splits=5, test_size=0.3, random_state=17)","874cbaff":"from sklearn.model_selection import cross_val_score","65c064d8":"%%time\n\nmodel_rf1 = RandomForestClassifier(n_estimators=100, n_jobs=4,\n                                   max_depth=None, random_state=17)\n\n# calcuate ROC-AUC for each split\ncv_scores_rf1 = cross_val_score(model_rf1, X, y, cv=cv, scoring='roc_auc')","c800762b":"%%time\n\nmodel_rf2 = RandomForestClassifier(n_estimators=100, n_jobs=4,\n                                   min_samples_leaf=3, random_state=17)\n\ncv_scores_rf2 = cross_val_score(model_rf2, X, y, cv=cv, \n                                scoring='roc_auc', n_jobs=-1)","7a5d0a21":"cv_scores_rf1","5999aec0":"cv_scores_rf2","2a027bfc":"print('Model 1 mean score:', cv_scores_rf1.mean())\nprint('Model 2 mean score:', cv_scores_rf2.mean())","807f384d":"cv_scores_rf2 > cv_scores_rf1","78ea0b5d":"import json\n\nwith open(os.path.join(PATH_TO_DATA, 'train_matches.jsonl')) as fin:\n    # read the 18-th line\n    for i in range(18):\n        line = fin.readline()\n    \n    # read JSON into a Python object \n    match = json.loads(line)","9864a1fb":"#match","e63b87ab":"player = match['players'][2]","1ff17315":"player['kills'], player['deaths'], player['assists']","79a0820e":"player['ability_uses']","cc549d26":"%matplotlib inline\nfrom matplotlib import pyplot as plt","5a08ca4a":"for player in match['players']:\n    plt.plot(player['times'], player['gold_t'])\n    \nplt.title('Gold change for all players');","ab063807":"import os\n\ntry:\n    import ujson as json\nexcept ModuleNotFoundError:\n    import json\n    print ('Please install ujson to read JSON oblects faster')\n    \ntry:\n    from tqdm import tqdm_notebook\nexcept ModuleNotFoundError:\n    tqdm_notebook = lambda x: x\n    print ('Please install tqdm to track progress with Python loops')\n\ndef read_matches(matches_file):\n    \n    MATCHES_COUNT = {\n        'test_matches.jsonl': 10000,\n        'train_matches.jsonl': 39675,\n    }\n    _, filename = os.path.split(matches_file)\n    total_matches = MATCHES_COUNT.get(filename)\n    \n    with open(matches_file) as fin:\n        for line in tqdm_notebook(fin, total=total_matches):\n            yield json.loads(line)","25535017":"for match in read_matches(os.path.join(PATH_TO_DATA, 'train_matches.jsonl')):\n    match_id_hash = match['match_id_hash']\n    game_time = match['game_time']\n    \n    # processing each game\n    \n    for player in match['players']:\n        pass  # processing each player","15b66859":"def add_new_features(df_features, matches_file):\n    \n    # Process raw data and add new features\n    for match in read_matches(matches_file):\n        match_id_hash = match['match_id_hash']\n\n        # Counting ruined towers for both teams\n        radiant_tower_kills = 0\n        dire_tower_kills = 0\n        for objective in match['objectives']:\n            if objective['type'] == 'CHAT_MESSAGE_TOWER_KILL':\n                if objective['team'] == 2:\n                    radiant_tower_kills += 1\n                if objective['team'] == 3:\n                    dire_tower_kills += 1\n\n        # Write new features\n        df_features.loc[match_id_hash, 'radiant_tower_kills'] = radiant_tower_kills\n        df_features.loc[match_id_hash, 'dire_tower_kills'] = dire_tower_kills\n        df_features.loc[match_id_hash, 'diff_tower_kills'] = radiant_tower_kills - dire_tower_kills\n        \n        # ... here you can add more features ...\n        ","919dd3d4":"# copy the dataframe with features\ndf_train_features_extended = df_train_features.copy()\n\n# add new features\nadd_new_features(df_train_features_extended, \n                 os.path.join(PATH_TO_DATA, \n                              'train_matches.jsonl'))","9e61092f":"df_train_features_extended.head()","d2ce0961":"%%time\n\nfrom sklearn.ensemble import RandomForestClassifier\n\nmodel = RandomForestClassifier(n_estimators=100, n_jobs=4, random_state=17)\n\ncv_scores_base = cross_val_score(model, X, y, cv=cv, scoring='roc_auc', n_jobs=-1)\ncv_scores_extended = cross_val_score(model, df_train_features_extended.values, y, \n                                     cv=cv, scoring='roc_auc', n_jobs=-1)","5fb27a14":"print('Base features: mean={} scores={}'.format(cv_scores_base.mean(), \n                                                cv_scores_base))\nprint('Extended features: mean={} scores={}'.format(cv_scores_extended.mean(), \n                                                    cv_scores_extended))","fb03bad0":"cv_scores_extended > cv_scores_base","b08c29b4":"%%time\n# Build the same features for the test set\ndf_test_features_extended = df_test_features.copy()\nadd_new_features(df_test_features_extended, \n                 os.path.join(PATH_TO_DATA, 'test_matches.jsonl'))","e6edd367":"model = RandomForestClassifier(n_estimators=100, n_jobs=4, random_state=17)\nmodel.fit(X, y)\ndf_submission_base = pd.DataFrame(\n    {'radiant_win_prob': model.predict_proba(df_test_features.values)[:, 1]}, \n    index=df_test_features.index,\n)\ndf_submission_base.to_csv('submission_base_rf.csv')","61d3b808":"model_extended = RandomForestClassifier(n_estimators=100, n_jobs=4, random_state=17)\nmodel_extended.fit(df_train_features_extended.values, y)\ndf_submission_extended = pd.DataFrame(\n    {'radiant_win_prob': model_extended.predict_proba(df_test_features_extended.values)[:, 1]}, \n    index=df_test_features.index,\n)\ndf_submission_extended.to_csv('submission_extended_rf.csv')","27e8280a":"# this one will be used as a final submission in this kernel\n!cp submission_extended_rf.csv submission.csv","04367e72":"import collections\n\nMATCH_FEATURES = [\n    ('game_time', lambda m: m['game_time']),\n    ('game_mode', lambda m: m['game_mode']),\n    ('lobby_type', lambda m: m['lobby_type']),\n    ('objectives_len', lambda m: len(m['objectives'])),\n    ('chat_len', lambda m: len(m['chat'])),\n]\n\nPLAYER_FIELDS = [\n    'hero_id',\n    \n    'kills',\n    'deaths',\n    'assists',\n    'denies',\n    \n    'gold',\n    'lh',\n    'xp',\n    'health',\n    'max_health',\n    'max_mana',\n    'level',\n\n    'x',\n    'y',\n    \n    'stuns',\n    'creeps_stacked',\n    'camps_stacked',\n    'rune_pickups',\n    'firstblood_claimed',\n    'teamfight_participation',\n    'towers_killed',\n    'roshans_killed',\n    'obs_placed',\n    'sen_placed',\n]\n\ndef extract_features_csv(match):\n    row = [\n        ('match_id_hash', match['match_id_hash']),\n    ]\n    \n    for field, f in MATCH_FEATURES:\n        row.append((field, f(match)))\n        \n    for slot, player in enumerate(match['players']):\n        if slot < 5:\n            player_name = 'r%d' % (slot + 1)\n        else:\n            player_name = 'd%d' % (slot - 4)\n\n        for field in PLAYER_FIELDS:\n            column_name = '%s_%s' % (player_name, field)\n            row.append((column_name, player[field]))\n            \n    return collections.OrderedDict(row)\n    \ndef extract_targets_csv(match, targets):\n    return collections.OrderedDict([('match_id_hash', match['match_id_hash'])] + [\n        (field, targets[field])\n        for field in ['game_time', 'radiant_win', 'duration', 'time_remaining', 'next_roshan_team']\n    ])","d8c7150a":"%%time\n\ndf_new_features = []\ndf_new_targets = []\n\nfor match in read_matches(os.path.join(PATH_TO_DATA, 'train_matches.jsonl')):\n    match_id_hash = match['match_id_hash']\n    features = extract_features_csv(match)\n    targets = extract_targets_csv(match, match['targets'])\n    \n    df_new_features.append(features)\n    df_new_targets.append(targets)\n    ","d6e6b194":"df_new_features = pd.DataFrame.from_records(df_new_features).set_index('match_id_hash')\ndf_new_targets = pd.DataFrame.from_records(df_new_targets).set_index('match_id_hash')","4910d4df":"df_new_features.head()","cf06b34b":"Some statistics on player abilities:","f1886297":"#### Example: time series for each player's gold.","a9b35b46":"#### Function to read files with game descriptions\n\nThe following function `read_matches(filename)`, can be used to read raw data on Dota 2 games.\n\nWe recommend to install two Python packages: `ujson` and `tqdm`, it'll make the execution faster and ","4e32be1e":"#### Let's construct a feature matrix `X` and a target vector `y`","97ca3e64":"KDA: the number of kills, deaths, and assists to alleys.","1ef9ef3c":"The second model is preferred. Look, there's a caveat here: the second model is actually better for 4 splits out of 5. So if we were to perform only one train\/test split, there would've been a 20% probability to make a wrong conclusion that the first model is better.","cccbfd83":"## How to build initial features from scratch\n\nNow we diclose the code that we used to build initial features `train_features.csv` and `test_features.csv`. You can modify the following code to add more features.\n\nIn a nutshell:\n\n1. the  `extract_features_csv(match)` function extracts features from game descriptions and writes them into a dictionary\n2. the `extract_targets_csv(match, targets)` function extracts the target variable `radiant_win`\n3. iterating through the file with raw data, we collect all features\n4. with `pandas.DataFrame.from_records()` we create dataframes with new features","73d3a922":"##### Let's explore a single entry","330d72bc":"Let's take a look:","b72a60df":"## Feature engineering","b0a515be":"## Preparing a submission\n\nNow the same for test data.","95ba0235":"#### Make predictions for the holdout set\n\nWe need to predict probabilities of class 1 - that Radiant wins, thus we need index 1 in the matrix returned by the `predict_proba` method.","f00b4f02":"#### Train the Random Forest model","52f5d04b":"Save the submission file, it's handy to include current datetime in the filename. ","bd8fa185":"Let's compare average ROC-AUC among all splits for both models.","e49b7460":"#### Perform  a train\/test split (a simple validation scheme)","86139017":"#### New submission","0159b6c4":"#### Let's evaluate prediction quality with the holdout set\n\nWe'll calculate ROC-AUC.","f0f56a3c":"#### Player description","7aec9a36":"#### Reading data in a loop\n\nReading data on all games might take some 2-3 minutes. Thus you'd better stick to the following approach:\n\n1. Read a small amount (10-100) of games\n2. Write code to extract features from these JSON objects\n3. Make sure the code works fine\n4. Run the code with all available data\n5. Save results to a `pickle` file so that you don't need to run all computations from scratch next time ","7df7a442":"We see new features added to the right.","236bb6d7":"We have ~ 40k games, each described by `match_id_hash` (game id) and 245 features. Also `game_time` is given - time (in secs) when the game was over. ","18ba56a5":"## Go on!\n\n- Discuss new ideas in Slack \n- Create new features\n- Try new models and ensembles\n- Submit predictions\n- Go and win!","19e22801":"## Training and evaluating a model","74184db4":"## Features created by organizers\n\nThese are basic features which include simple players' statistics. Scroll to the end to see how to build these features from raw json files.","0619f02a":"## Data description\n\nWe have the following files:\n\n- `sample_submission.csv`: example of a submission file\n- `train_matches.jsonl`, `test_matches.jsonl`: full \"raw\" training data \n- `train_features.csv`, `test_features.csv`: features created by organizers\n- `train_targets.csv`: results of training games (including the winner)","02bf4c1d":"Out if curiosiry, we can calculate accuracy of a classifier which predicts class 1 if predicted probability is higher than 50%. ","c4fad8d2":"#### CV results\n\nThe result returned by `cross_val_score` is an array with metric values (ROC-AUC) for each split:","2b52d469":"## Cross-validation\n\nAs we already know, cross-validation is a more reliable validation technique than just one train\/test split. Here we'll resort to `ShuffleSplit` to create 5 70%\/30% splits. ","239eeb87":"#### Evaluating new features\n\nLet's run cross-validation with a fixed model but with two different datasets:\n\n1. with features built by organizers (base)\n2. with new features that we've added (extended)","4c5ab530":"As we see, `RandomForestClassifier` shows better cross-validation results in case of the extended dataset. Looks reasonable, that's what we build features for.","c9d5cc86":"## Working with all available information on Dota games\nRaw data descriptions for all games are given in files `train_matches.jsonl` and `test_matches.jsonl`. Each file has one entry for each game in [JSON](https:\/\/en.wikipedia.org\/wiki\/JSON) format. You only need to know that it can be easily converted to Python objects via the `json.loads` method.","48bf9310":"#### Run cross-validation\n\nWe'll train 2 versions of the  `RandomForestClassifier` model - first with default capacity (trees are not limited in depth), second - with `min_samples_leaf`=3, i.e. each leave is obliged to have at least 3 instances. ","9b399843":"The `match` object is now a big Python dictionary. In `match['players']` we have a description of each player.\n\nYou might think that this `match` object look ugly. You're right! That's actually the real data. And it's the ability to extract nice features from raw data that makes good Data Scientists stand out. You might even be unfamiliar with Dota (or any other application domain) but still be able to construct a good model via feature engineering. It's art and craftmanship at the same time.   ","28bcaed3":"We are interested in the `radiant_win` column in `train_targets.csv`. All these features are not known during the game (they come \"from future\" as compared to `game_time`), so we have these features only for training data. ","c4d737f2":"# <center> Dota 2 winner prediction\n\n<img src='https:\/\/habrastorage.org\/webt\/ua\/vn\/pq\/uavnpqfoih4zwwznvxubu33ispy.jpeg'>\n\n#### <center> Originally done by Peter Romov, translated and adapted by Yury Kashnitskiy (@yorko)\n    \n### Quick start\n\nGrab features prepared by organizers, train a model and submit. \n\n1. [Data description](#Data-description)\n2. [Features created by organizers](#Features-created-by-organizers)\n3. [Training and evaluating a model](#Training-and-evaluating-a-model)\n4. [Preparing a submission](#Preparing-a-submission)\n\n### Now do it as a real Data Scientist\n\n5. [Cross-validation](#Cross-validation)\n6. [Working with all available information on Dota games](#Working-with-all-available-information-on-Dota-games)\n7. [Feature engineering](#Feature-engineering)\n8. [How to build initial features from scratch](#How-to-build-initial-features-from-scratch)"}}