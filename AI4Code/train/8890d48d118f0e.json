{"cell_type":{"bc7f9c5b":"code","69c0ca88":"code","2ddecb9d":"code","b8848a03":"code","3b646a3b":"code","90286cfb":"code","acbdb177":"code","01b70f58":"markdown","ec90b310":"markdown","ae6e0f0f":"markdown"},"source":{"bc7f9c5b":"%reload_ext autoreload\n%autoreload 2\n%matplotlib inline\n\nimport numpy as np\nimport torch\nimport cv2\nimport os\nfrom fastai.vision import *","69c0ca88":"nfolds = 4\nMASKS = '..\/input\/siimacr-pneumothorax-segmentation-data-256\/masks'\nDATA = '..\/input\/hypercolumns-pneumothorax-fastai-0-819-lb'\n\npreds0, items = [], []\nfor fold in range(nfolds):\n    preds0.append(torch.load(os.path.join(DATA,'preds_fold'+str(fold)+'.pt')))\n    items.append(np.load(os.path.join(DATA,'items_fold'+str(fold)+'.npy'), \n                         allow_pickle=True))\npreds0 = torch.cat(preds0)\npred_sum = preds0.view(preds0.shape[0],-1).int().sum(-1)\nitems = np.concatenate(items)\n\nys = []\nfor item in items:\n    img = cv2.imread(str(item).replace('train', 'masks'),0)\n    img = torch.Tensor(img).byte().unsqueeze(0)\n    img = (img > 127)\n    ys.append(img)\nys = torch.cat(ys)\nyl = (ys.view(ys.shape[0],-1).int().sum(-1) > 0).byte()","2ddecb9d":"def dice_overall(preds, targs):\n    n = preds.shape[0]\n    preds = preds.view(n, -1)\n    targs = targs.view(n, -1)\n    intersect = (preds * targs).float().sum(-1)\n    union = (preds+targs).float().sum(-1)\n    u0 = union==0\n    intersect[u0] = 1\n    union[u0] = 2\n    return (2. * intersect \/ union)\n    \ndices = dice_overall(preds0[yl==1] > 0.22, ys[yl==1])","b8848a03":"#write list of negative examples sorted by their dificulty (number of predicted pixels)\n#and positive examples sorted by dice\nvals_n, sorted_idxs = torch.sort(pred_sum[yl==0], descending=True)\nfile_ids_n = [p.stem for p in items[to_np(yl==0).astype(bool)][sorted_idxs]]\nvals_p, sorted_idxs = torch.sort(dices)\nfile_ids_p = [p.stem for p in items[to_np(yl==1).astype(bool)][sorted_idxs]]","3b646a3b":"import json\nwith open('items_p.txt', 'w') as f:  \n    json.dump(file_ids_p, f)\nwith open('items_n.txt', 'w') as f:  \n    json.dump(file_ids_n, f)\n    \n#how to read the file\nwith open('items_p.txt', 'r') as f:  \n    p = json.load(f)\nwith open('items_n.txt', 'r') as f:  \n    n = json.load(f)","90286cfb":"#it looks that selection of 2379 most difficult negative examples makes sense\n#for remaining example the number of predicted pixels is less than ~10\nimport matplotlib.pyplot as plt\nprint('n_pos = ', len(file_ids_p), ', n_neg = ', len(file_ids_n))\nprint('n_FP = ', int((vals_n > 255*300.0).sum()))\nplt.plot(np.arange(len(vals_n)), vals_n.float()\/255)\nplt.yscale('log')\nplt.xlabel('index')\nplt.ylabel('number of pixels')\n#threshold used for removal of FP\nplt.axhline(300.0, linestyle='--', color='red')\nplt.text(4000,400.0,'noise_th') \nplt.show()","acbdb177":"print('mean true dice = ', float(vals_p.mean()))\nplt.plot(np.arange(len(vals_p)), vals_p)\nplt.xlabel('index')\nplt.ylabel('dice')\nplt.show()","01b70f58":"### Overview\nTo avoid training of model on the majority of negative examples with only a few positives, sometimes it makes sense to select only a fraction of negative examples. In particular, this strategy was very effective in  [Airbus Ship Detection Challenge](https:\/\/www.kaggle.com\/c\/airbus-ship-detection). The kernel below provides lists of positive and negative examples sorted according to their difficulty based on the model trained in [this kernel](https:\/\/www.kaggle.com\/iafoss\/hypercolumns-pneumothorax-fastai-0-819-lb).","ec90b310":"### Writing lists of sorted positive and negative examples","ae6e0f0f":"### Load validation predictions and masks"}}