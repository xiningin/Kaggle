{"cell_type":{"5f83cb0c":"code","c15f91dc":"code","1bed3c63":"code","6f50d894":"code","88a8d2a9":"code","dee1ab2f":"code","c2d803f6":"code","c2ffa820":"code","1f8ac7a8":"code","d6ffbb31":"code","0fbf0bf4":"code","9a956e08":"code","170fd709":"code","88ac10fb":"code","972f8fd4":"markdown","7922da74":"markdown","22f7a52b":"markdown","000cdd92":"markdown","1a28758b":"markdown","88c6ecbc":"markdown","44d8733a":"markdown","d74b2e06":"markdown"},"source":{"5f83cb0c":"!python -c \"import torch; print(torch.__version__)\"\n!python -c \"import torch; print(torch.version.cuda)\"","c15f91dc":"### For CPU ###\n\n# ! pip -qq install torch==1.5.1+cpu torchvision==0.6.1+cpu -f https:\/\/download.pytorch.org\/whl\/torch_stable.html\n# ! pip -qq install torch-scatter==latest+cpu -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n# ! pip -qq install torch-sparse==latest+cpu -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n# ! pip -qq install torch-cluster==latest+cpu -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n# ! pip -qq install torch-spline-conv==latest+cpu -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n# ! pip -qq install torch-geometric","1bed3c63":"### For GPU ###\n\n! pip -qq install torch-scatter==latest+cu101 -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n! pip -qq install torch-sparse==latest+cu101 -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n! pip -qq install torch-cluster==latest+cu101 -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n! pip -qq install torch-spline-conv==latest+cu101 -f https:\/\/pytorch-geometric.com\/whl\/torch-1.5.0.html\n! pip -qq install torch-geometric","6f50d894":"from typing import Union, Tuple\nfrom torch_geometric.typing import OptPairTensor, Adj, Size\n\nfrom torch import Tensor\nfrom torch.nn import Linear\nimport torch.nn.functional as F\nfrom torch_sparse import SparseTensor, matmul\nfrom torch_geometric.nn.conv import MessagePassing","88a8d2a9":"import warnings\nwarnings.filterwarnings(\"ignore\")","dee1ab2f":"import os\nimport time\nimport random\nfrom tqdm.notebook import tqdm\nimport pandas as pd\nimport numpy as np\nfrom sklearn.metrics import roc_auc_score as roc\nimport matplotlib.pyplot as plt\n\nfrom joblib import Parallel, delayed\n\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\n\nimport torch\nimport torch.nn.functional as F\nimport torch_geometric.nn as gnn\nfrom torch_geometric.nn import MessagePassing\nfrom torch_geometric.data import Dataset, Data, DataLoader\nfrom torch_geometric.nn import global_mean_pool as gap, global_max_pool as gmp\nfrom torch_geometric.utils import softmax","c2d803f6":"data = np.concatenate([np.load('..\/input\/higgs-dataset-v1\/train_'+str(i)+'.npy') for i in range(21)]+[np.load('..\/input\/higgs-dataset-v1\/test.npy')])\nx_data, y_data = data[:,1:], data[:,0]\nscaler = StandardScaler()\nx_data = scaler.fit_transform(x_data)","c2ffa820":"grps = [[0,1,2],\n        [3,4],\n        [5,6,7,8],\n        [9,10,11,12],\n        [13,14,15,16],\n        [17,18,19,20]]\n\nedge_index = [(i,j) for i in range(21) for j in range(21,28)]\nedge_index += [(j,i) for i in range(21) for j in range(21,28)]\nfor a in grps:\n    edge_index+=[(i, j) for i in a for j in a if i!=j]\n\n\nedge_index = torch.tensor(edge_index, dtype=torch.long).T\ndef process_data(i):\n  graph = x_data[i].reshape(1,-1).T\n  y = y_data[i]\n  data = Data(x=torch.tensor(graph, dtype=torch.float), y=torch.tensor(y, dtype=torch.float), edge_index=edge_index)\n  return data","1f8ac7a8":"class HiggsDataset(Dataset):\n    def __init__(self, root, indexes=list(range(10000000)), transform=None, pre_transform=None):\n        super(HiggsDataset, self).__init__(root, transform, pre_transform)\n        self.indexes = indexes\n        self.length = len(self.indexes)\n\n    @property\n    def raw_file_names(self):\n        return ['vgc']\n\n    @property\n    def processed_file_names(self):\n        return ['vghv']\n\n    def download(self):\n        return None\n\n    def process(self):\n        return None\n\n    def len(self):\n        return self.length\n\n    def get(self, idx):\n        return process_data(self.indexes[idx])","d6ffbb31":"class MPL(MessagePassing):\n    def __init__(self, in_channels, out_channels):\n        super(MPL, self).__init__(aggr='add')\n        self.mlp1 = torch.nn.Linear(in_channels*2, out_channels)\n        self.mlp2 = torch.nn.Linear(in_channels, out_channels)\n        self.mlp3 = torch.nn.Linear(2*out_channels, 1)\n        self.mlp4 = torch.nn.Linear(2*out_channels, 1)\n        self.mlp5 = torch.nn.Linear(in_channels,16)\n        self.mlp6 = torch.nn.Linear(out_channels,16)\n        self.mlp7 = torch.nn.Linear(16,1)\n\n    def forward(self, x, edge_index):\n\n        msg = self.propagate(edge_index, x=x)\n        x = F.relu(self.mlp2(x))\n        w1 = F.sigmoid(self.mlp3(torch.cat([x,msg], dim=1)))\n        w2 = F.sigmoid(self.mlp4(torch.cat([x,msg], dim=1)))\n        out = w1*msg + w2*x\n        \n        return out\n\n    def message(self, x_i, x_j, edge_index):\n        msg = F.relu(self.mlp1(torch.cat([x_i, x_j], dim=1)))\n        w1 = F.tanh(self.mlp5(x_i))\n        w2 = F.tanh(self.mlp6(msg))\n        w = self.mlp7(w1*w2)\n        w = softmax(w, edge_index[0])\n        return msg*w","0fbf0bf4":"class MPNN(torch.nn.Module):\n    def __init__(self):\n      super(MPNN, self).__init__()\n      self.conv1 = MPL(32,32 )\n      self.conv2 = MPL(32, 32)\n      self.conv3 = MPL(32, 32)\n      self.conv4 = MPL(32, 32)\n      self.lin0 = torch.nn.Linear(1, 32)\n      self.lin1 = torch.nn.Linear(64, 128)\n      self.lin2 = torch.nn.Linear(128, 16)\n      self.lin4 = torch.nn.Linear(16, 1)\n      self.global_att_pool1 = gnn.GlobalAttention(torch.nn.Sequential(torch.nn.Linear(16, 1)))\n      self.global_att_pool2 = gnn.GlobalAttention(torch.nn.Sequential(torch.nn.Linear(16, 1)))\n    \n    def forward(self, data):\n      x, edge_index, batch = data.x, data.edge_index, data.batch\n      x = F.relu(self.lin0(x))\n      x = F.relu(self.conv1(x, edge_index))\n      x = F.relu(self.conv2(x, edge_index))\n      x1 = self.global_att_pool1(x, batch)\n      x = F.relu(self.conv3(x, edge_index))\n      x = F.relu(self.conv4(x, edge_index))\n      x2 = self.global_att_pool2(x, batch)\n      x_out = torch.cat([x1, x2], dim=1)\n      x = F.relu(self.lin1(x_out))\n      x = F.relu(self.lin2(x))\n      x = F.sigmoid(self.lin4(x).squeeze(1))\n\n      return x","9a956e08":"batch_size = 512\nepochs = 9\nprogress_bar=False\n# progress_bar=True","170fd709":"device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\ndef train_fn():\n    scale = 0\n    bce = torch.nn.BCELoss()\n    test_auc = []\n    val_auc = []\n    train_auc = []\n\n#     train_loader = DataLoader(HiggsDataset('.\/',list(range(10000000))), batch_size=batch_size, shuffle=True, num_workers = 4)\n    val_loader = DataLoader(HiggsDataset('.\/',list(range(10000000, 10500000))), batch_size=batch_size)\n    test_loader = DataLoader(HiggsDataset('.\/',list(range(10500000, 11000000))), batch_size=batch_size)\n    train_loader = DataLoader(HiggsDataset('.\/',list(range(10000000))), batch_size=batch_size, shuffle=True, num_workers = 4)\n#     train_loader = DataLoader(HiggsDataset('.\/',list(range(5000))), batch_size=batch_size, shuffle=True, num_workers = 4)\n#     val_loader = DataLoader(HiggsDataset('.\/',list(range(10000, 15000))), batch_size=batch_size)\n#     test_loader = DataLoader(HiggsDataset('.\/',list(range(15000, 20000))), batch_size=batch_size)\n\n    model = MPNN().to(device)\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)\n#     lr_scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, verbose=True, patience=0, factor=0.75)\n    lr_scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda=[lambda x: x**0.95])\n    \n    m_train_loss = []\n    m_val_loss = []\n    m_test_loss = []\n    min_val_loss = float('inf')\n    for epoch in range(epochs):\n      train_loss = 0\n      val_loss = 0\n      if progress_bar:\n          pbar = tqdm(train_loader)\n      else:\n          pbar = train_loader\n            \n      true = []\n      preds = []\n      for data in pbar:\n        data = data.to(device)\n        optimizer.zero_grad()\n        outputs = model(data)\n        labels = data.y\n        true += list(labels.detach().cpu().numpy())\n        preds += list(outputs.detach().cpu().numpy())\n        loss = bce(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        if progress_bar:\n          pbar.set_description('BCELoss: '+str(loss.detach().cpu().numpy()))\n        train_loss += loss.detach().cpu().numpy()\/len(train_loader)\n      train_auc.append(roc(true, preds))\n\n      true = []\n      preds = []\n      for data in val_loader:\n        data = data.to(device)\n        optimizer.zero_grad()\n        outputs = model(data)\n        labels = data.y\n        true += list(labels.detach().cpu().numpy())\n        preds += list(outputs.detach().cpu().numpy())\n        loss = bce(outputs, labels)\n        val_loss += loss.detach().cpu().numpy()\/len(val_loader)\n      val_auc.append(roc(true, preds))\n      if val_loss<min_val_loss:\n        min_val_loss = val_loss\n        torch.save(model.state_dict(), 'model.pth')\n#       lr_scheduler.step(val_loss)\n      lr_scheduler.step(epoch)\n      print('Epoch: ', str(epoch+1)+'\/'+str(epochs),'| Training BCELoss: ', train_loss, '| Val BCELoss: ', val_loss, '| Train AUC: ', train_auc[-1], '| Val AUC: ', val_auc[-1])\n      m_train_loss.append(train_loss)\n      m_val_loss.append(val_loss)\n      if epoch>20 and min(m_val_loss[-7:])>min_val_loss+0.0001:\n        break\n    \n    if progress_bar==False:\n        plt.plot(range(1,len(m_val_loss)+1), m_val_loss, label='val_loss')\n        plt.plot(range(1,len(m_train_loss)+1), m_train_loss, label='train_loss')\n        plt.xlabel('epoch')\n        plt.ylabel('Loss')\n        plt.legend()\n        plt.show()\n    model = MPNN().to(device)\n    model.load_state_dict(torch.load('model.pth'))\n    test_loss = 0\n    true = []\n    preds = []\n    for data in test_loader:\n      data = data.to(device)\n      optimizer.zero_grad()\n      outputs = model(data)\n      labels = data.y\n      true += list(labels.detach().cpu().numpy())\n      preds += list(outputs.detach().cpu().numpy())\n      loss = bce(outputs, labels)\n      test_loss += loss.detach().cpu().numpy()\/len(test_loader)\n    test_auc.append(roc(true, preds))\n    print('Test BCELoss: ', test_loss,' | AUC:', test_auc[-1])\n    OOF_preds = pd.DataFrame()\n    OOF_preds['true_value'] = true\n    OOF_preds['preds'] = preds\n    OOF_preds.to_csv('OOF_preds.csv')\n    return 0","88ac10fb":"train_fn()","972f8fd4":"# Download and install required libraries","7922da74":"# PyTorch Geometric Dataset Class","22f7a52b":"# Pre-processing","000cdd92":"# Training Parameters","1a28758b":"# Import Libraries","88c6ecbc":"# GNN Architecture","44d8733a":"# Custom MPL","d74b2e06":"# Training function"}}