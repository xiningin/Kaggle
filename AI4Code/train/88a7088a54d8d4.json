{"cell_type":{"eb694575":"code","5bdbd7fc":"code","e4abf33a":"code","20dcaf6c":"code","7d2333ec":"markdown","af8f5933":"markdown","de39fcf0":"markdown"},"source":{"eb694575":"import numpy as np ","5bdbd7fc":"def parity(sequence):\n    k = 1\n    for bit in sequence:\n        if(bit == 0):\n            bit = -1\n        k*= bit\n    if(k == -1):\n        return 0\n    return 1\n\ndef generate_sequence(n):\n    bit_seq = []\n    for i in range(n):\n        bit = np.random.randint(0,2)\n        bit_seq.append(bit)\n    return bit_seq\n\ndef generate_set(m,n):\n    #m = no of bit sequences\n    #n = length of each bit sequence\n    dataset = []\n    for i in range(m):\n        dataset.append(generate_sequence(n))\n    return dataset\n\ndef create_weight_matrix(n_input_neurons,n_output_neurons):\n    #Initialize a zero matrix of appropriate dimension and then change some values to 1 and -1\n    #so that every neuron computes difference between two neurons from previous layer.\n    weights = np.zeros((n_output_neurons,n_input_neurons))\n    for i in range(n_output_neurons):\n        weights[i,2*i:2*(i+1)] = [1,-1]\n    return weights\n\ndef activation(x):\n    return np.abs(x)\n\ndef forward_network(X):\n    z1 = np.dot(l1_weights,X)\n    a1 = activation(z1)\n    z2 = np.dot(l2_weights,a1)\n    a2 = activation(z2)\n    z3 = np.dot(l3_weights,a2)\n    a3 = activation(z3)\n    z4 = np.dot(l4_weights,a3)\n    a4 = activation(z4)\n    z5 = np.dot(l5_weights,a4)\n    a5 = activation(z5)\n    z6 = np.dot(l6_weights,a5)\n    a6 = 1 - activation(z6) # 1 means even and 0 means odd\n    return a6","e4abf33a":"l1_weights = create_weight_matrix(64,32)\nl2_weights = create_weight_matrix(32,16)\nl3_weights = create_weight_matrix(16,8)\nl4_weights = create_weight_matrix(8,4)\nl5_weights = create_weight_matrix(4,2)\nl6_weights = create_weight_matrix(2,1)","20dcaf6c":"test_set = generate_set(1000,64)\n\ncorrect = 0\ncount = 0\nfor sequence in test_set:\n    network_output = forward_network(sequence)\n    y = parity(sequence)\n    if(y==network_output):\n        correct += 1\n    count += 1\nprint(\"No of test sequences predicted correct: \",correct,\"\/\",count)","7d2333ec":"# Functions\n\n1. generate_sequence(n) - Generating a bit sequence of length n\n2. parity(sequence) - Checks the parity of a bit sequence (Returns 1 if even, 0 if odd)\n3. generate_set(m,n) - Creates a dataset of m points which are bit sequences of length n\n4. create_weight_matrix - Construct the appropriate weight matrix to calculate difference of two units from previous layer\n5. activation - Takes absolute values of hidden neurons, thereby calculating absolute difference between two unit values from previous layer\n6. forward_network - Function to send the data through the network and provide an output","af8f5933":"# Create Weight Matrices","de39fcf0":"# Pass Data Through the Network and Find Accuracy"}}