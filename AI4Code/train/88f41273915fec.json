{"cell_type":{"5036696f":"code","d15b95cd":"code","99256ce0":"code","cb49d569":"code","42d8fcf7":"code","e8d62c63":"code","10c1084a":"code","cb618516":"code","ced64fbb":"code","dba5c6f3":"code","ab215cce":"code","6ac1b557":"code","162b02ae":"code","3d497933":"code","537807b2":"code","ae34f956":"code","31522985":"code","0521e411":"code","7704f3a3":"code","79fb0696":"code","35552aa0":"code","8938ee2d":"code","87b50c86":"code","1adcb0c1":"code","8f40d00b":"code","0af2b140":"code","08a7dd52":"code","e72ce6a3":"code","49bf13f6":"code","4f88d421":"code","c6b692e9":"code","52909bd4":"code","c2bd0e33":"code","cd326807":"code","9ba111dd":"code","0fb571bc":"markdown","81b6029a":"markdown","3bcf604e":"markdown","3b073702":"markdown","0f361b01":"markdown","98ea955f":"markdown","443cc9b3":"markdown","4b35fcad":"markdown","767f80d9":"markdown","c9a6fb15":"markdown","a281c3b8":"markdown","dc9f4b6c":"markdown"},"source":{"5036696f":"import numpy as np \nimport pandas as pd \nimport os\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import LabelEncoder\nfrom xgboost import XGBClassifier\nfrom sklearn.model_selection import train_test_split","d15b95cd":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","99256ce0":"train_id = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/train_identity.csv')\ntrain_trans = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/train_transaction.csv')\ntest_id = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/test_identity.csv')\ntest_trans = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/test_transaction.csv')","cb49d569":"train = pd.merge(train_trans, train_id, on='TransactionID', how='left')\ntest = pd.merge(test_trans, test_id, on='TransactionID', how='left')","42d8fcf7":"def memory_usage_mb(train, *args, **kwargs):\n    \"\"\"Dataframe memory usage in MB. \"\"\"\n    return train.memory_usage(*args, **kwargs).sum() \/ 1024**2\n\ndef reduce_memory_usage(train, deep=True, verbose=True):\n    # All types that we want to change for \"lighter\" ones.\n    # int8 and float16 are not include because we cannot reduce\n    # those data types.\n    # float32 is not include because float16 has too low precision.\n    numeric2reduce = [\"int16\", \"int32\", \"int64\", \"float64\"]\n    start_mem = 0\n    if verbose:\n        start_mem = memory_usage_mb(train, deep=deep)\n\n    for col, col_type in train.dtypes.iteritems():\n        best_type = None\n        if col_type in numeric2reduce:\n            downcast = \"integer\" if \"int\" in str(col_type) else \"float\"\n            train[col] = pd.to_numeric(train[col], downcast=downcast)\n            best_type = train[col].dtype.name\n        # Log the conversion performed.\n        if verbose and best_type is not None and best_type != str(col_type):\n            print(f\"Column '{col}' converted from {col_type} to {best_type}\")\n\n    if verbose:\n        end_mem = memory_usage_mb(train, deep=deep)\n        diff_mem = start_mem - end_mem\n        percent_mem = 100 * diff_mem \/ start_mem\n        print(f\"Memory usage decreased from\"\n              f\" {start_mem:.2f}MB to {end_mem:.2f}MB\"\n              f\" ({diff_mem:.2f}MB, {percent_mem:.2f}% reduction)\")\n        \n    return train","e8d62c63":"def memory_usage_mb(test, *args, **kwargs):\n    \"\"\"Dataframe memory usage in MB. \"\"\"\n    return train.memory_usage(*args, **kwargs).sum() \/ 1024**2\n\ndef reduce_memory_usage(test, deep=True, verbose=True):\n    # All types that we want to change for \"lighter\" ones.\n    # int8 and float16 are not include because we cannot reduce\n    # those data types.\n    # float32 is not include because float16 has too low precision.\n    numeric2reduce = [\"int16\", \"int32\", \"int64\", \"float64\"]\n    start_mem = 0\n    if verbose:\n        start_mem = memory_usage_mb(test, deep=deep)\n\n    for col, col_type in test.dtypes.iteritems():\n        best_type = None\n        if col_type in numeric2reduce:\n            downcast = \"integer\" if \"int\" in str(col_type) else \"float\"\n            test[col] = pd.to_numeric(test[col], downcast=downcast)\n            best_type = test[col].dtype.name\n        # Log the conversion performed.\n        if verbose and best_type is not None and best_type != str(col_type):\n            print(f\"Column '{col}' converted from {col_type} to {best_type}\")\n\n    if verbose:\n        end_mem = memory_usage_mb(test, deep=deep)\n        diff_mem = start_mem - end_mem\n        percent_mem = 100 * diff_mem \/ start_mem\n        print(f\"Memory usage decreased from\"\n              f\" {start_mem:.2f}MB to {end_mem:.2f}MB\"\n              f\" ({diff_mem:.2f}MB, {percent_mem:.2f}% reduction)\")\n        \n    return test","10c1084a":"del train_id, train_trans, test_id, test_trans","cb618516":"train.columns","ced64fbb":"train.dropna(thresh = 0.5*len(train),how ='all', axis=1, inplace = True)","dba5c6f3":"train.isnull().sum()","ab215cce":"list(train.dtypes)","6ac1b557":"train_cat =train.select_dtypes(include=['object', 'O']).copy()\ntrain_num =train.select_dtypes(exclude=['object', 'O']).copy()","162b02ae":"mm_scaler = MinMaxScaler()\nmm_scaler.fit_transform(train_num)","3d497933":"train_cat.isnull().sum()","537807b2":"for col in train_cat:\n   train_cat[col] = train_cat[col].replace(np.nan, train_cat[col].mode()[0])","ae34f956":"for col in train_num:\n   train_num[col] = train_num[col].replace(np.nan, train_num[col].mean())","31522985":"train_num = reduce_memory_usage(train_num, deep=True, verbose=True)\nprint(train_num.head(10))","0521e411":"dummy = LabelEncoder()\ntrain_catg = train_cat.apply(dummy.fit_transform)\ntrain_catg.head()","7704f3a3":"corr_matrix = train_num.corr()\nupper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))","79fb0696":"plt.matshow(train_num.corr())","35552aa0":"to_drop = [column for column in upper.columns if any(upper[column] > 0.95)]","8938ee2d":"train_num.drop(train_num[to_drop], axis=1, inplace=True)","87b50c86":"train_num.drop(['isFraud'], axis=1, inplace=True)","1adcb0c1":"frames = [train_catg,train_num]\nfeatures = pd.concat(frames, axis=1)","8f40d00b":"features","0af2b140":"target = train['isFraud']","08a7dd52":"test = pd.get_dummies(test)","e72ce6a3":"X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.33, random_state=42)","49bf13f6":"xgboost_classifier = XGBClassifier()","4f88d421":"xgboost_classifier.fit(X_train, y_train)","c6b692e9":"predictions = xgboost_classifier.predict(X_test)","52909bd4":"test[\"isFraud\"] = xgboost_classifier.predict_proba(test)[:,1]","c2bd0e33":"from sklearn.metrics import confusion_matrix, classification_report\nprint(confusion_matrix(predictions, y_test))","cd326807":"print(classification_report(predictions, y_test))","9ba111dd":"submission = test[[\"TransactionID\", \"isFraud\"]]\nsubmission.head()\nsubmission.to_csv(\"submission.csv\", index = False)","0fb571bc":"**Splitting data into numeric and categorical columns**","81b6029a":"**Test Data**","3bcf604e":"**Reducing Memory usage**","3b073702":"**Treating Missing Values**","0f361b01":"**Replacing Null Values**","98ea955f":"Select upper triangle of correlation matrix","443cc9b3":"**Creating dummy values for the categorical column values**","4b35fcad":"**Importing packages**","767f80d9":"**Merging the two datasets**","c9a6fb15":"**Dropping columns with correlation greater than 0.95**","a281c3b8":"**Data Modelling**","dc9f4b6c":"**Defining the target and the features**"}}