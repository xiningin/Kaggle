{"cell_type":{"1febeee0":"code","d65e92be":"code","5cbc48bd":"code","0827c98c":"code","a3b53b66":"code","b27d320c":"code","cd153bdd":"code","c0afd73c":"code","08937ee8":"code","43462421":"code","e9192dac":"code","e421a0de":"code","db455f8a":"code","ffc00711":"code","24b0152e":"code","227bc33d":"code","911142d1":"code","b4ba9dcc":"code","a554c8bc":"code","67a7c42d":"code","6c233922":"code","c20d8b71":"code","7250dbf9":"code","3f62a196":"code","0adc29c8":"code","e2c42885":"code","23661769":"code","e0a5ff6d":"code","db91efc8":"code","797a5ad5":"code","33fb3ede":"code","097d9daa":"code","fa9bcf19":"code","64fb30b9":"code","972042d9":"code","a84f59d8":"code","294c8da8":"code","7fc8ba63":"code","94207970":"code","5cf1b390":"code","d35b77f2":"code","63b44aa6":"code","e7028f44":"markdown","0b9ebe06":"markdown","58e8cd05":"markdown","39dcd435":"markdown","15330b50":"markdown","fb3c91bb":"markdown","75aff8b0":"markdown","66ef1be1":"markdown","77deae94":"markdown","a2e2a0d5":"markdown","60b57376":"markdown","8cdecb01":"markdown","37763d4a":"markdown","74c941ca":"markdown","ecdc4e32":"markdown","4374e9e2":"markdown","9139b78d":"markdown"},"source":{"1febeee0":"import pandas as pd\nimport numpy as np\nimport xgboost as xgb\nimport tqdm as tqdm #for progress bars\nfrom sklearn.svm import SVC\nfrom keras.models import Sequential\nfrom keras.layers.recurrent import GRU, LSTM\nfrom keras.layers.core import Dense, Activation, Dropout\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.utils import np_utils # array and list manipulation \nfrom sklearn import preprocessing, decomposition, model_selection, metrics, pipeline\n#The purpose of the pipeline is to assemble several steps that can be cross-validated \n#together while setting different parameters.\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer\nfrom sklearn.decomposition import TruncatedSVD #Dimensionality reduction\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import MultinomialNB #suitable for classification with discrete features \nfrom keras.layers import Bidirectional, GlobalAvgPool1D, Conv1D, Flatten, SpatialDropout1D, MaxPooling1D\nfrom keras.preprocessing import sequence, text\nfrom keras.callbacks import EarlyStopping\nfrom nltk import word_tokenize\nfrom nltk.corpus import stopwords\nstop_words = stopwords.words('english')\n","d65e92be":"train = pd.read_csv('..\/input\/spooky-author-identification\/train.csv')\ntest = pd.read_csv('..\/input\/spooky-author-identification\/test.csv')","5cbc48bd":"train.head(5)","0827c98c":"def multiclass_logloss(actual, predicted, eps = 1e-15):\n    #We have to make sure actual is binary \n    if(len(actual.shape) == 1):\n        actual2 = np.zeros((actual.shape[0], predicted.shape[1]))\n        for i, val in enumerate(actual):\n            actual2[i, val] = 1\n        actual = actual2\n    clip = np.clip(predicted, eps, 1-eps)\n    rows = actual.shape[0]\n    vsota = np.sum(actual * np.log(clip))\n    return -1.0\/rows * vsota","a3b53b66":"lbl_enc = preprocessing.LabelEncoder()\ny = lbl_enc.fit_transform(train.author.values)\nset(y)","b27d320c":"xtrain, xvalid, ytrain, yvalid = train_test_split(train.text.values, y, stratify = y, random_state=42, test_size=0.1, shuffle=True)","cd153bdd":"print(xtrain.shape, xvalid.shape)","c0afd73c":"tfv = TfidfVectorizer(min_df = 3, max_features=None, strip_accents='unicode', analyzer='word', token_pattern = r'\\w{1,}',\n                     ngram_range=(1,3), use_idf = 1, smooth_idf = 1, sublinear_tf = 1, stop_words = 'english')","08937ee8":"# Fitting TF-IDF to both training and test sets (semi-supervised learning)\ntfv.fit(list(xtrain) + list(xvalid))\nxtrain_tfv = tfv.transform(xtrain)\nxvalid_tfv = tfv.transform(xvalid)","43462421":"#so basically it coverts your words into int and also give it's frequencies along with it's IDF\nfor x in xtrain_tfv:\n    print(x)\n    break","e9192dac":"clf = LogisticRegression(C=1.0)\nclf.fit(xtrain_tfv, ytrain)\npredictions = clf.predict_proba(xvalid_tfv)\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))\n","e421a0de":"ctv = CountVectorizer(analyzer='word',token_pattern=r'\\w{1,}',\n            ngram_range=(1, 3), stop_words = 'english')\nctv.fit(list(xtrain) + list(xvalid))\nxtrain_ctv = ctv.transform(xtrain)\nxvalid_ctv = ctv.transform(xvalid)","db455f8a":"clf = LogisticRegression(C=1.0)\nclf.fit(xtrain_ctv, ytrain)\npredictions = clf.predict_proba(xvalid_ctv)\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))","ffc00711":"clf = MultinomialNB()\nclf.fit(xtrain_tfv, ytrain)\npredictions = clf.predict_proba(xvalid_tfv)\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))","24b0152e":"#On count vector\nclf = MultinomialNB()\nclf.fit(xtrain_ctv, ytrain)\npredictions = clf.predict_proba(xvalid_ctv)\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))","227bc33d":"# Apply SVD, I chose 120 components. 120-200 components are good enough for SVM model.\nsvd = decomposition.TruncatedSVD(n_components=120)\nsvd.fit(xtrain_tfv)\nxtrain_svd = svd.transform(xtrain_tfv)\nxvalid_svd = svd.transform(xvalid_tfv)\n","911142d1":"# Scale the data obtained from SVD. Renaming variable to reuse without scaling.\nscl = preprocessing.StandardScaler()\nscl.fit(xtrain_svd)\nxtrain_svd_scl = scl.transform(xtrain_svd)\nxvalid_svd_scl = scl.transform(xvalid_svd)","b4ba9dcc":"clf = SVC(C=1.0, probability=True)\nclf.fit(xtrain_svd_scl, ytrain)\npredictions = clf.predict_proba(xvalid_svd_scl)\n\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))","a554c8bc":"# Fitting a simple xgboost on tf-idf\nclf = xgb.XGBClassifier(max_depth=7, n_estimators=200, colsample_bytree=0.8, \n                        subsample=0.8, nthread=10, learning_rate=0.1)\nclf.fit(xtrain_tfv.tocsc(), ytrain)\npredictions = clf.predict_proba(xvalid_tfv.tocsc())\n\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))\n\n# Fitting a simple xgboost on tf-idf\nclf = xgb.XGBClassifier(max_depth=7, n_estimators=200, colsample_bytree=0.8, \n                        subsample=0.8, nthread=10, learning_rate=0.1)\nclf.fit(xtrain_ctv.tocsc(), ytrain)\npredictions = clf.predict_proba(xvalid_ctv.tocsc())\n\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))\n\n# Fitting a simple xgboost on tf-idf svd features\nclf = xgb.XGBClassifier(max_depth=7, n_estimators=200, colsample_bytree=0.8, \n                        subsample=0.8, nthread=10, learning_rate=0.1)\nclf.fit(xtrain_svd, ytrain)\npredictions = clf.predict_proba(xvalid_svd)\n\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))\n\n# Fitting a simple xgboost on tf-idf svd features\nclf = xgb.XGBClassifier(nthread=10)\nclf.fit(xtrain_svd, ytrain)\npredictions = clf.predict_proba(xvalid_svd)\n\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))","67a7c42d":"mll_scorer = metrics.make_scorer(multiclass_logloss, greater_is_better=False, needs_proba=True)\n","6c233922":"# Initialize SVD\nsvd = TruncatedSVD()\n    \n# Initialize the standard scaler \nscl = preprocessing.StandardScaler()\n\n# We will use logistic regression here..\nlr_model = LogisticRegression()\n\n# Create the pipeline \nclf = pipeline.Pipeline([('svd', svd),\n                         ('scl', scl),\n                         ('lr', lr_model)])","c20d8b71":"param_grid = {'svd__n_components' : [120, 180],\n              'lr__C': [0.1, 1.0, 10], \n              'lr__penalty': ['l1', 'l2']}","7250dbf9":"model = GridSearchCV(estimator=clf, param_grid=param_grid, scoring=mll_scorer, verbose=10, iid = True, n_jobs=-1, refit=True, cv = 2)\nmodel.fit(xtrain_tfv, ytrain)\nprint(\"Best score: %0.3f\" % model.best_score_)\nprint(\"Best parameters set:\")\nbest_parameters = model.best_estimator_.get_params()\nfor param_name in sorted(param_grid.keys()):\n    print(\"\\t%s: %r\" % (param_name, best_parameters[param_name]))","3f62a196":"nb_model = MultinomialNB()\n\n# Create the pipeline \nclf = pipeline.Pipeline([('nb', nb_model)])\n\n# parameter grid\nparam_grid = {'nb__alpha': [0.001, 0.01, 0.1, 1, 10, 100]}\n\n# Initialize Grid Search Model\nmodel = GridSearchCV(estimator=clf, param_grid=param_grid, scoring=mll_scorer,\n                                 verbose=10, n_jobs=-1, iid=True, refit=True, cv=2)\n\n# Fit Grid Search Model\nmodel.fit(xtrain_tfv, ytrain)  # we can use the full data here but im only using xtrain. \nprint(\"Best score: %0.3f\" % model.best_score_)\nprint(\"Best parameters set:\")\nbest_parameters = model.best_estimator_.get_params()\nfor param_name in sorted(param_grid.keys()):\n    print(\"\\t%s: %r\" % (param_name, best_parameters[param_name]))","0adc29c8":"!wget  http:\/\/www-nlp.stanford.edu\/data\/glove.840B.300d.zip","e2c42885":"!ls ..\/input\/glove840b300dtxt\/","23661769":"embeddings_index = {}\nf = open('..\/input\/glove840b300dtxt\/glove.840B.300d.txt')\nfor line in tqdm.tqdm(f):\n    values = line.split()\n    word = ''.join(values[:-300])\n    coefs = np.asarray(values[-300:], dtype='float32')\n    embeddings_index[word] = coefs\nf.close()\n\nprint('Found %s word vectors.' % len(embeddings_index))","e0a5ff6d":"# this function creates a normalized vector for the whole sentence\ndef sent2vec(s):\n    words = str(s).lower()\n    words = word_tokenize(words)\n    words = [w for w in words if not w in stop_words]\n    words = [w for w in words if w.isalpha()]\n    M = []\n    for w in words:\n        try:\n            M.append(embeddings_index[w])\n        except:\n            continue\n    M = np.array(M)\n    v = M.sum(axis=0)\n    if type(v) != np.ndarray:\n        return np.zeros(300)\n    return v \/ np.sqrt((v ** 2).sum())","db91efc8":"# create sentence vectors using the above function for training and validation set\nxtrain_glove = [sent2vec(x) for x in tqdm.tqdm(xtrain)]\nxvalid_glove = [sent2vec(x) for x in tqdm.tqdm(xvalid)]","797a5ad5":"xtrain_glove = np.array(xtrain_glove)\nxvalid_glove = np.array(xvalid_glove)","33fb3ede":"# Fitting a simple xgboost on glove features\nclf = xgb.XGBClassifier(nthread=10, silent=False)\nclf.fit(xtrain_glove, ytrain)\npredictions = clf.predict_proba(xvalid_glove)\n\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))","097d9daa":"# Fitting a simple xgboost on glove features\nclf = xgb.XGBClassifier(max_depth=7, n_estimators=200, colsample_bytree=0.8, \n                        subsample=0.8, nthread=10, learning_rate=0.1, silent=False)\nclf.fit(xtrain_glove, ytrain)\npredictions = clf.predict_proba(xvalid_glove)\n\nprint (\"logloss: %0.3f \" % multiclass_logloss(yvalid, predictions))","fa9bcf19":"# scale the data before any neural net:\nscl = preprocessing.StandardScaler()\nxtrain_glove_scl = scl.fit_transform(xtrain_glove)\nxvalid_glove_scl = scl.transform(xvalid_glove)","64fb30b9":"# we need to binarize the labels for the neural net\nytrain_enc = np_utils.to_categorical(ytrain)\nyvalid_enc = np_utils.to_categorical(yvalid)","972042d9":"# create a simple 3 layer sequential neural net\nmodel = Sequential()\n\nmodel.add(Dense(300, input_dim=300, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(BatchNormalization())\n\nmodel.add(Dense(300, activation='relu'))\nmodel.add(Dropout(0.3))\nmodel.add(BatchNormalization())\n\nmodel.add(Dense(3))\nmodel.add(Activation('softmax'))\n\n# compile the model\nmodel.compile(loss='categorical_crossentropy', optimizer='adam')","a84f59d8":"model.fit(xtrain_glove_scl, y=ytrain_enc, batch_size=64, \n          epochs=15, verbose=1, \n          validation_data=(xvalid_glove_scl, yvalid_enc))","294c8da8":"# using keras tokenizer here\ntoken = text.Tokenizer(num_words=None)\nmax_len = 70\n\ntoken.fit_on_texts(list(xtrain) + list(xvalid))\nxtrain_seq = token.texts_to_sequences(xtrain)\nxvalid_seq = token.texts_to_sequences(xvalid)\n\n# zero pad the sequences\nxtrain_pad = sequence.pad_sequences(xtrain_seq, maxlen=max_len)\nxvalid_pad = sequence.pad_sequences(xvalid_seq, maxlen=max_len)\n\nword_index = token.word_index","7fc8ba63":"# create an embedding matrix for the words we have in the dataset\nembedding_matrix = np.zeros((len(word_index) + 1, 300))\nfor word, i in tqdm.tqdm(word_index.items()):\n    embedding_vector = embeddings_index.get(word)\n    if embedding_vector is not None:\n        embedding_matrix[i] = embedding_vector","94207970":"from keras.layers.embeddings import Embedding\n\n# A simple LSTM with glove embeddings and two dense layers\nmodel = Sequential()\nmodel.add(Embedding(len(word_index) + 1,\n                     300,\n                     weights=[embedding_matrix],\n                     input_length=max_len,\n                     trainable=False))\nmodel.add(SpatialDropout1D(0.3))\nmodel.add(LSTM(100, dropout=0.3, recurrent_dropout=0.3))\n\nmodel.add(Dense(1024, activation='relu'))\nmodel.add(Dropout(0.8))\n\nmodel.add(Dense(1024, activation='relu'))\nmodel.add(Dropout(0.8))\n\nmodel.add(Dense(3))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='adam')","5cf1b390":"model.fit(xtrain_pad, y=ytrain_enc, batch_size=512, epochs=100, verbose=1, validation_data=(xvalid_pad, yvalid_enc))","d35b77f2":"# A simple bidirectional LSTM with glove embeddings and two dense layers\nmodel = Sequential()\nmodel.add(Embedding(len(word_index) + 1,\n                     300,\n                     weights=[embedding_matrix],\n                     input_length=max_len,\n                     trainable=False))\nmodel.add(SpatialDropout1D(0.3))\nmodel.add(Bidirectional(LSTM(300, dropout=0.3, recurrent_dropout=0.3)))\n\nmodel.add(Dense(1024, activation='relu'))\nmodel.add(Dropout(0.8))\n\nmodel.add(Dense(1024, activation='relu'))\nmodel.add(Dropout(0.8))\n\nmodel.add(Dense(3))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='adam')\n\n# Fit the model with early stopping callback\nearlystop = EarlyStopping(monitor='val_loss', min_delta=0, patience=3, verbose=0, mode='auto')\nmodel.fit(xtrain_pad, y=ytrain_enc, batch_size=512, epochs=100, \n          verbose=1, validation_data=(xvalid_pad, yvalid_enc), callbacks=[earlystop])","63b44aa6":"# GRU with glove embeddings and two dense layers\nmodel = Sequential()\nmodel.add(Embedding(len(word_index) + 1,\n                     300,\n                     weights=[embedding_matrix],\n                     input_length=max_len,\n                     trainable=False))\nmodel.add(SpatialDropout1D(0.3))\nmodel.add(GRU(300, dropout=0.3, recurrent_dropout=0.3, return_sequences=True))\nmodel.add(GRU(300, dropout=0.3, recurrent_dropout=0.3))\n\nmodel.add(Dense(1024, activation='relu'))\nmodel.add(Dropout(0.8))\n\nmodel.add(Dense(1024, activation='relu'))\nmodel.add(Dropout(0.8))\n\nmodel.add(Dense(3))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='adam')\n\n# Fit the model with early stopping callback\nearlystop = EarlyStopping(monitor='val_loss', min_delta=0, patience=3, verbose=0, mode='auto')\nmodel.fit(xtrain_pad, y=ytrain_enc, batch_size=512, epochs=100, \n          verbose=1, validation_data=(xvalid_pad, yvalid_enc), callbacks=[earlystop])","e7028f44":"In NLP problems, it's customary to look at word vectors. Word vectors give a lot of insights about the data. Let's dive into that.\n","0b9ebe06":"## GridSearch\n\nLet's try to search the best hyperparameter for best optimization Grid search using logistic regression.\n\nBefore starting with grid search we need to create a scoring function. This is accomplished using the make_scorer function of scikit-learn.","58e8cd05":"The score comes similar to what we had for SVM. This technique can be used to finetune xgboost or even multinomial naive bayes as below. We will use the tfidf data here","39dcd435":"### Let's try out basic model\nLet's do tfifd followed by Logistic Regression","15330b50":"We imporved 0.1 that's a significant change\n\nNow let's try out naive bias\n\nOn tfidf","fb3c91bb":"## Wrod Vector\nWithout going into too much details, I would explain how to create sentence vectors and how can we use them to create a machine learning model on top of it. I am a fan of GloVe vectors, word2vec and fasttext. In this post, I'll be using the GloVe vectors. You can download the GloVe vectors from here http:\/\/www-nlp.stanford.edu\/data\/glove.840B.300d.zip","75aff8b0":"Does't do we'll\n\nLet's apply xgboost","66ef1be1":"And there we go. We have our first model with a multiclass logloss of 0.626.\n\nNow let's use wordcount as a feature, this can be done by countvectorizer ","77deae94":"That's a very good score\n\nNow let's try SVM\n\nAs SVM takes a lot of time so let's reduce the number of features using  Singular Value Decomposition ","a2e2a0d5":"We'll use label encoder to convert text to label -> 'a','b','c' = 0,1,2 etc\n\nHere we'll convert our authors to integer\n\nEAP,HPL,MWS => 0,1,2","60b57376":"### Let's load the dataset","8cdecb01":"## Deep learning\nLet's first scale the data","37763d4a":"Finally you can give a try with ensemble of all these models","74c941ca":"### This notebook is completely inspired from [Approaching Any Problem of NLP](https:\/\/www.kaggle.com\/abhishek\/approaching-almost-any-nlp-problem-on-kaggle)\n\nAll the steps covered in that notebook will be replicated here with changes and meaning to each and every step we take.\n\nThis notebook is for all those like me, who want to get started with NLP\n\n### The book is going to Cover the following points\n* TFIDF\n* Count Features\n* Logistic Regression\n*  Naive Bais\n* SVM\n* xgboost\n* GridSearch\n* word vectors\n* LSTM\n* GRU\n* Ensembling\n\nWe'll cover all these points and let's have our dataset from Spooky Author Identification\n\n### Imports","ecdc4e32":"### What is the problem and what are we expected to do ?\nSo the problem given is 'Given a text sentence we have to identifiy which author might have written it'\n\nAs described in the Overview, 3 Authors are there EAP, HPL and MWS so basically we have the task of classifiying between 3 authors - text classification between 3 classes\n\n### Metric\n\nFor this problem we have given metric as multiclass log loss as our evaluation metric  - http:\/\/wiki.fast.ai\/index.php\/Log_Loss#Multi-class_Classification\n\n (taken from: https:\/\/github.com\/dnouri\/nolearn\/blob\/master\/nolearn\/lasagne\/util.py)","4374e9e2":"It does't do we'll ","9139b78d":"To move further, i.e. with LSTMs we need to tokenize the text data\n"}}