{"cell_type":{"e1a14161":"code","761d9b8c":"code","ebec169a":"code","10204066":"code","69eb7fea":"code","184e0bae":"code","87c1b114":"code","8564bb27":"code","02c4b2bc":"code","49950b3f":"code","d2257231":"code","6b1f0651":"code","be2128b7":"code","00c747fc":"code","ce99a0c5":"code","cbdd8426":"code","3557e617":"code","ae26780b":"code","25c57823":"code","595a4767":"code","5ddb900a":"code","5e2d8938":"code","d3f068a6":"code","278b8ecb":"code","10fa2c06":"code","80b26eee":"code","3829be46":"code","9dea2292":"code","8a7f34b7":"code","66bcb856":"code","b5798976":"code","9c4d359a":"code","ca4761cb":"code","60c43272":"markdown","344b0d9f":"markdown","6a3af5e3":"markdown","6a3b7472":"markdown","7e65e2fc":"markdown","62a47c8c":"markdown","d840700c":"markdown","05636335":"markdown","ae015095":"markdown","932e17f3":"markdown","2262e22f":"markdown","6379d181":"markdown","54da6708":"markdown","189cd243":"markdown","cf71b763":"markdown","99457a71":"markdown","38d27548":"markdown","efa3ac19":"markdown","ae681017":"markdown","2e6b38f7":"markdown","fc5ac56b":"markdown","4e96c5d4":"markdown","8c03552d":"markdown","69e5239e":"markdown","f521c06a":"markdown","6bf6dc08":"markdown","63684c06":"markdown","720c17b1":"markdown","62a0d847":"markdown","512d0006":"markdown","c974b2f3":"markdown"},"source":{"e1a14161":"import numpy as np\nimport scipy\nfrom scipy.integrate import odeint \nimport matplotlib.pyplot as plt\nfrom random import expovariate\nimport seaborn as sns\n#sns.set()\nplt.rcParams['figure.figsize'] = (6.4,4.8)\n","761d9b8c":"def bifur(N , R0):#function for bifurcation\n  if R0> 1:\n\n    x = N*(1 - (1\/R0))\n    y = N\/R0\n\n  elif R0< 1:\n    x = 0\n    y = N\n  return x,y","ebec169a":"list_R0 = np.linspace(0.1,5,1000)#different values of R0 between 0.1 and 5\nB = []\nA = []\n\nfor i in list_R0:\n  \n  B.append(bifur(1000,i)[0])#appends different values of B* for different value of R0\n  A.append(bifur(1000,i)[1])#appends different values of A* for different value of R0\n\n","10204066":"#ploting both A* and B* as the function of R0\nplt.plot(list_R0,B)\nplt.plot(list_R0,A)\nlabel = ['B*','A*']\nplt.title('Bifurcation plot')\nplt.legend(label)\nplt.xlabel('R0 value')\nplt.ylabel('Equilibrium Population')\nplt.show()","69eb7fea":"def B_t(N,B0,gamma,R0,t= np.linspace(0,200,1000)): #all the parameters should be strictly non negative\n  b_t_list = []\n  a_t_list = []\n  beta = gamma*R0\n  if R0 != 1:#funciton B[t] while R0 != 1\n    for i in t:\n      e = B0*np.exp((R0-1)*gamma*i)\n      a = R0\/(N*(R0-1))\n      b = 1\n      k=e\/(a*e + b - a*B0)\n      b_t_list.append(k)\n      a_t_list.append(N-k)\n\n  elif R0 ==  1:#funciton B[t] while R0 = 1 (explanation given in the analytical part)\n    for i in t:\n\n      k = N\/(beta *i + (N\/B0))\n      b_t_list.append(k)\n      a_t_list.append(N - k)\n  if R0>1:\n    eq_point = 1\/a \n  elif R0<1:\n    eq_point = 0\n  \n  print('For N = {} and R0 = {} \\n equilibrium value of [B](t) is {}'.format(N,R0,eq_point))\n  return (b_t_list,a_t_list)","184e0bae":"N = 1000\nB0 = 300\n\ngamma = 0.5\n\nplt.subplots_adjust(1,0,2.5,0.5)\nplt.subplot(121)\nR0 = 1.5\nk=B_t(N,B0,gamma,R0)[0]\nplt.plot(np.linspace(0,200,1000),k)\nplt.xlabel('time (s)')\nplt.ylabel('population')\nlabel = ['R0 = 1.5']\nplt.legend(label, loc ='best')\nplt.grid()\n\nplt.subplot(122)\nR0 = 0.8\nk=B_t(N,B0,gamma,R0)[0]\nplt.plot(np.linspace(0,200,1000),k)\nlabel = ['R0 = 0.8']\nplt.xlabel('time (s)')\nplt.ylabel('B[t]')\nplt.legend(label, loc = 'best')\nplt.grid()\n\nplt.show()","87c1b114":"def B_t(N,B0,gamma,R0,t= np.linspace(0,200,1000)): #all the parameters should be strictly non negative\n  b_t_list = []\n  a_t_list = []\n  beta = gamma*R0\n  if R0 != 1:#funciton B[t] while R0 != 1\n    for i in t:\n      e = B0*np.exp((R0-1)*gamma*i)\n      a = R0\/(N*(R0-1))\n      b = 1\n      k=e\/(a*e + b - a*B0)\n      b_t_list.append(k)\n      a_t_list.append(N-k)\n\n  elif R0 ==  1:#funciton B[t] while R0 = 1 \n    for i in t:\n\n      k = N\/(beta *i + (N\/B0))\n      b_t_list.append(k)\n      a_t_list.append(N - k)\n  if R0>1:\n    eq_point = 1\/a \n  elif R0<1:\n    eq_point = 0\n  \n  #print('For N = {} and R0 = {} \\n equilibrium value of [B](t) is {}'.format(N,R0,eq_point))\n  return (b_t_list,a_t_list)","8564bb27":"list_b_t_list =[]\nfor i in range(0,N,250):\n  gamma = 0.2\n  R0 = 1.5\n  \n  k = B_t(N,i,gamma,R0,t = np.linspace(0,50,1000))\n  list_b_t_list.append(k[0])","02c4b2bc":"for i in range(len(list_b_t_list)):\n  plt.plot(np.linspace(0,50,1000),list_b_t_list[i])\nlabel = ['B0 = 0','B0 = 250', 'B0 = 500', 'B0 = 750']\nplt.legend(label, loc = 'best')\nplt.title('[B](t) for different values of B0 \\n where R0 > 1 \\n without changing N and R0')\nplt.xlabel('time (s)')\nplt.ylabel('B[t]')\nplt.show()\n","49950b3f":"list_b_t_list1 =[]\nfor i in range(0,N,250):\n  gamma = 0.2\n  R0 = 0.8\n  \n  k = B_t(N,i,gamma,R0,t = np.linspace(0,100,1000))\n  list_b_t_list1.append(k[0])","d2257231":"for i in range(len(list_b_t_list1)):\n  plt.plot(np.linspace(0,100,1000),list_b_t_list1[i])\nlabel = ['B0 = 0','B0 = 250', 'B0 = 500', 'B0 = 750']\nplt.legend(label, loc = 'best')\nplt.title('[B](t) for different values of B0 \\n where R0 < 1 \\n without changing N and R0')\nplt.xlabel('time (s)')\nplt.ylabel('B[t]')\nplt.show()","6b1f0651":"list_list_b_t_R0 = []\nfor i in [0.1,0.9,1.5,3.5,5]:#For different value of R0\n  B0 = 250\n  gamma = 0.5\n  k = B_t(N,B0,gamma,i,t = np.linspace(0,100,1000))\n  list_list_b_t_R0.append(k[0])\n","be2128b7":"#plottting B(t) for dfferent values of R0\nfor i in range(len(list_list_b_t_R0)):\n  plt.plot(np.linspace(0,100,1000),list_list_b_t_R0[i])\nlabels = ['R0 = 0.1','R0 = 0.9','R0 = 1.5','R0 = 3.5','R0 = 5']\nplt.legend(labels, loc = 'best')\nplt.title(\"[B](t) for various values of R0\")\nplt.xlabel('Time (s)')\nplt.ylabel('B[t]')\nplt.show()","00c747fc":"list_b_t_list_gamma =[]\nfor i in np.linspace(0,1.5,4):#taking different value of gamma\n  B0 = 250\n  R0 = 1.5\n  k = B_t(N,B0,i,R0,t=np.linspace(0,100,1000))\n  list_b_t_list_gamma.append(k[0])","ce99a0c5":"#plot\nfor i in range(len(list_b_t_list_gamma)):\n  plt.plot(np.linspace(0,100,1000),list_b_t_list_gamma[i])\nplt.xlabel('Time (s)')\nplt.ylabel('B[t]')\nlabels = ['gamma = 0','gamma = 0.5','gamma = 1','gamma = 1.5']\nplt.legend(labels, loc ='best')\nplt.title('[B](t) for various values of gamma by \\n keeping R0 fixed')\nplt.show()","cbdd8426":"def f1(x,t,beta = 0.72,gamma = 0.6,N =1000):#defining the slope of the curve at each point\n  dydt = (beta*x*(N-x)\/N) - (gamma*x)\n  return dydt\n","3557e617":"\ndef Euler_int():# defining Euler integration funciton\n\n    \n    \n    myfunc=lambda x,t: f1(x,t)\n    tmax = 100\n    h = 0.001 # integration time step(smaller the step, more close the curve will be to the actual curve)\n    t = np.arange(0,tmax+h,h)\n    x = np.zeros((len(t),1)) # pre-allocate x, \n    x[0]=30 # initial value of  B0\n  \n    # Euler integration\n    for i in np.arange(len(t)-1):\n        x[i+1]=x[i]+h*myfunc(x[i],t[i]) \n    \n    # Plot result\n    \n    plt.plot(t,x,'r')\n    #plt.grid()\n    plt.xlabel('Time(s)',fontsize = 11)\n    plt.ylabel('B[t]',fontsize = 11)\n    plt.title('B[t] with euler integration')\n    ","ae26780b":"Euler_int()","25c57823":"B0 = 30\nR0 = 1.2\ngamma = 0.6\nbeta = 0.72\nk = B_t(N,B0,gamma,R0, t=np.linspace(0,100,1000))\n\nplt.subplots_adjust(1,0,2.5,0.5)\n\nplt.subplot(121)\nEuler_int()\n\n\nplt.subplot(122)\nplt.xlabel('Time(s)',fontsize = 11)\nplt.ylabel('Population',fontsize = 11)\nplt.title('[B](t) with analytical integration')\nplt.plot(np.linspace(0,100,1000),k[0],'b')\n\nplt.show()","595a4767":"def system1(y,t,beta,gamma):#defining slopes for both A[t] and B[t]\n  dydt = [-(gamma*y[0]-beta*y[0]*y[1]\/(y[0]+y[1])),gamma*y[0]-beta*y[0]*y[1]\/(y[0]+y[1])]\n  return dydt","5ddb900a":"beta = 0.45\ngamma = 0.5\n\n# Initial conditions\nB0 = 300\ny0sys1 = [B0,N-B0]\n\n# Timeline\nt = np.linspace(0, 200, 2000)\n\n# Integrate\nsolsys1 = odeint(system1, y0sys1, t, args = (beta,gamma))\n\n\n# Plot\nplt.plot(t, solsys1[:, 0], 'b', label='B(t)')\n#plt.plot(t, solsys1[:, 1], 'g', label='A(t)')\nplt.legend(loc='best')\nplt.xlabel('time (s)')\nplt.ylabel('B[t]')\n#plt.grid()\nplt.show()","5e2d8938":"B0 = 30\nR0 = 1.2\ngamma = 0.6\nbeta = 0.72\nsolsys = odeint(system1,[B0,N-B0], np.linspace(0,100,1000), args = (beta,gamma))\nk = B_t(N,B0,gamma,R0, t=np.linspace(0,100,1000))\n\nplt.subplots_adjust(1,0,2.5,0.5)\n\nplt.subplot(121)\nplt.xlabel('Time(s)')\nplt.ylabel('Population')\nplt.title('[B](t) with odeint in python')\n#plt.grid()\nplt.plot(np.linspace(0,100,1000),solsys[:, 0 ])\n\nplt.subplot(122)\nplt.xlabel('Time(s)')\nplt.ylabel('Population')\nplt.title('[B](t) with analytical integration')\nplt.plot(np.linspace(0,100,1000),k[0])\n#plt.grid()\nplt.show()","d3f068a6":"def gillespie_ABA(N,B0,beta,gamma,Tmax):#gillespie algorithm\n\n    A=[N-B0] # We cannot predict how many elements there will be unfortunately\n    B=[B0]\n    T=[0] \n    state = np.random.permutation([0]*(N-B0)+[1]*B0) # Randomly allocate B0 individuals to have state B (state=1), A (state=0) otherwise \n    B_contacts = np.where(state==1)[0] # Index of individuals in state B (state=1).\n    rate_vector = B0*beta*np.ones((N,1))\/N # Set rates to be B0*beta\/N (rate for individuals in state A) to all individuals (initialisation). \n    rate_vector[B_contacts] = gamma # Update rate of B_contacts to be gamma (the rate for individuals in state B)\n    \n    time = 0\n    while time<=Tmax+0.5: # some (arbitrary) buffer after Tmax\n        rate = np.sum(rate_vector) # Total rate (refer to Gillespie algorithm for details)\n        cumrate = np.cumsum(rate_vector) # Cumulated sum of rates\n        if rate > 0.000001: # if rate is sufficiently large\n            tstep = expovariate(rate) # Pick an exponentially distributed time. Beware of difference with exprnd in Matlab where it is 1\/rate\n            T.append(T[-1]+tstep) # Time of next event\n            event = np.where(cumrate>np.random.rand()*rate)[0][0] # Find which individual will see its state change \n            if state[event]==0: # individual is in state A \n                A.append(A[-1]-1) # this state A individual becomes state B so number of state A individuals is decreased\n                B.append(B[-1]+1) # obviously, number of state B individuals is increased \n                state[event] = 1 # Update state vector\n                rate_vector[event] = gamma # Change rate of individual to B->A rate, namely gamma\n                A_contacts = np.where(state==0)[0] # List of state A individuals after change\n                rate_vector[A_contacts] += beta\/N # Update rate of state A individuals to account for the extra state B individual\n            else: # individual is in state B\n                B.append(B[-1]-1) # this state B individual becomes state A so number of state B individuals is decreased\n                A.append(A[-1]+1) # obviously, number of state A individuals is increased\n                state[event] = 0 # Update state vector\n                A_contacts = np.where(state==0)[0] # List of state A individuals after changes                                \n                rate_vector[A_contacts] = beta*len(np.where(state==1)[0])\/N # Update rate of state A individuals based on number of B individuals  \n        else: # Nothing will happen from now on so we can accelerate the process\n            time = T[-1] # current time\n            while time <= Tmax + 0.5:\n                A.append(A[-1]) # Just keep things as they are\n                B.append(B[-1])\n                T.append(T[-1]+0.5) # arbitrarily add 0.5 to clock\n                time = T[-1]\n        # Update time and proceed with loop \n        time = T[-1]         \n\n    return T,A,B    ","278b8ecb":"plt.rcParams['figure.figsize'] = (15,7.5)\n#10 stochastic simulation is used for each case\n#Small N, small B0 and Small R0\nfor i in range(10):\n  T,A,B = gillespie_ABA(50,10,0.1,1,50)\n  plt.plot(T,B, 'b', label = 'R0 = 0.1')\n  \n#Small N, Small B0 and Large R0\nfor i in range (10):\n  T,A,B = gillespie_ABA(50,10,1,0.2,50)\n  plt.plot(T,B, 'r', label = 'R0 = 5')\n  \n#small N, small B0 and R0 = 1\nfor i in range (10):\n  T,A,B = gillespie_ABA(50,10,0.5,0.5,50)\n  plt.plot(T,B, 'g',label = 'R0 = 1')\n  \n#small N, Large B0 and Small R0\nfor i in range (10):\n  T,A,B = gillespie_ABA(50,40,0.1,1,50)\n  plt.plot(T,B, 'b',label = 'R0 = 0.1')\n\n#Small N, Large B0 and Large R0\nfor i in range (10):\n  T,A,B = gillespie_ABA(50,40,1,0.2,50)\n  plt.plot(T,B, 'r',label = 'R0 = 5')\n\n#small N, Large B0 and R0 = 1\nfor i in range (10):\n  T,A,B = gillespie_ABA(50,40,0.5,0.5,50)\n  plt.plot(T,B, 'g',label = 'R0 = 1')\n\nhandles, labels = plt.gca().get_legend_handles_labels()\nby_label = dict(zip(labels, handles))\nplt.legend(by_label.values(), by_label.keys())\nplt.show()\n ","10fa2c06":"plt.rcParams['figure.figsize'] = (20,10)\nn =10\n#Large N, Large B0 and Large R0\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,2,0.4,20)\n  plt.plot(T,B, 'r' , label = \"R0 = 5\")\n  \n#Large N , Large B0 and R0 = 1  \nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,0.5,0.5,20)\n  plt.plot(T,B, 'g', label = 'R0 = 1' )\n\n#Large N, Small B0 and Small R0\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,0.1,1,20)\n  plt.plot(T,B, 'b', label = 'R0 = 0.1' )\n\n#Large N, Small B0 and Large R0\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,2,0.4,20)\n  plt.plot(T,B, 'r',  label =  'R0 = 5')\n \n#Large N, Small B0 and R0 =1\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,0.5,0.5,20)\n  plt.plot(T,B, 'g', label = 'R0 = 1')\n  \n\n#Large N, Large B0 and small R0\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,0.1,1,20)\n  plt.plot(T,B, 'b', label =  'R0 = 0.1')\n\n#Small N, small B0 and Small R0\nfor i in range(n):\n  T,A,B = gillespie_ABA(50,10,0.1,1,20)\n  plt.plot(T,B, 'b', label = 'R0 = 0.1')\n  \n#Small N, Small B0 and Large R0\nfor i in range (n):\n  T,A,B = gillespie_ABA(50,10,1,0.2,20)\n  plt.plot(T,B, 'r', label = 'R0 = 5')\n  \n#small N, small B0 and R0 = 1\nfor i in range (n):\n  T,A,B = gillespie_ABA(50,10,0.5,0.5,20)\n  plt.plot(T,B, 'g',label = 'R0 = 1')\n  \n#small N, Large B0 and Small R0\nfor i in range (n):\n  T,A,B = gillespie_ABA(50,40,0.1,1,20)\n  plt.plot(T,B, 'b',label = 'R0 = 0.1')\n\n#Small N, Large B0 and Large R0\nfor i in range (n):\n  T,A,B = gillespie_ABA(50,40,1,0.2,20)\n  plt.plot(T,B, 'r',label = 'R0 = 5')\n\n#small N, Large B0 and R0 = 1\nfor i in range (n):\n  T,A,B = gillespie_ABA(50,40,0.5,0.5,20)\n  plt.plot(T,B, 'g',label = 'R0 = 1')\n\n\n\n\n\nhandles, labels = plt.gca().get_legend_handles_labels()\nby_label = dict(zip(labels, handles))\nplt.legend(by_label.values(), by_label.keys())\nplt.xlabel('Time (s)', fontsize = 18)\nplt.ylabel('[B](t)', fontsize = 16)\nplt.show()\n \n","80b26eee":"from scipy.interpolate import interp1d #importing interpolation function","3829be46":"#Sample graph to check our implementation\nT,A,B = gillespie_ABA(1000,800,0.5,0.5,30)\nf = interp1d(T,B, kind = 'nearest')\nTnew = np.linspace(0,30,1000)\nplt.plot(T,B)\nplt.plot(Tnew,f(Tnew))\nplt.xlabel('Time(s)', fontsize = 13)\nplt.ylabel('B', fontsize = 13)\nlabels = ['original gillespie outputs','interpolated values']\nplt.legend(labels)\nplt.show()\n","9dea2292":"plt.rcParams['figure.figsize'] = (18,10)\nTnew = np.linspace(0,20,1000)\nn = 10\n#Large N, Large B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,2,0.4,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'b' , label = \"R0 = 5\")\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n  \n#Large N , Large B0 and R0 = 1  \nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'g', label = 'R0 = 1' )\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#Large N, Small B0 and Small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'r', label = 'R0 = 0.1' )\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#Large N, Small B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,2,0.4,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'b',  label =  'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#Large N, Small B0 and R0 =1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'g', label = 'R0 = 1')\n  \na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#Large N, Large B0 and small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'r', label =  'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#Small N, small B0 and Small R0\nB_list_Bnew = []\nfor i in range(n):\n  T,A,B = gillespie_ABA(100,20,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'r', label = 'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n  \n#Small N, Small B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,20,1,0.2,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'b', label = 'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#small N, small B0 and R0 = 1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,20,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n  \n#small N, Large B0 and Small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'r',label = 'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#Small N, Large B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,1,0.2,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'b',label = 'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n#small N, Large B0 and R0 = 1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)# interpolated values\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:# finding the average\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'k', linewidth = 4) \n\n\n\n\n\nhandles, labels = plt.gca().get_legend_handles_labels()#to avoid multiple labelling\nby_label = dict(zip(labels, handles))\nplt.legend(by_label.values(), by_label.keys())\nplt.xlabel('Time (s)', fontsize = 18)\nplt.ylabel('[B](t)', fontsize = 16)\n\nplt.show()","8a7f34b7":"plt.rcParams['figure.figsize'] = (18,10)\nTnew = np.linspace(0,20,1000)\nn = 10\n#Large N, Large B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,2,0.4,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b' , label = \"R0 = 5\")\n\na = 0\nfor i in B_list_Bnew:#calculating average\n  a = a+i\nB_average = a\/n  \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\nplt.plot(Tnew,B_average, 'b', linewidth = 4, label = \"R0 = 5\")\n\n\n  \n#Large N , Large B0 and R0 = 1  \nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g', label = 'R0 = 1' )\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\nplt.plot(Tnew,B_average, 'g', linewidth = 4, label = 'R0 = 1')\n\n\n\n#Large N, Small B0 and Small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'r', label = 'R0 = 0.1' )\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'r', linewidth = 4,label = 'R0 = 0.1') \n\n\n#Large N, Small B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,2,0.4,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b',  label =  'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'b', linewidth = 4, label =  'R0 = 5') \n\n\n#Large N, Small B0 and R0 =1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g', label = 'R0 = 1')\n  \na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'g', linewidth = 4,label = 'R0 = 1') \n\n\n#Large N, Large B0 and small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'r', label =  'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n  \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'r', linewidth = 4,label =  'R0 = 0.1') \n\n\n#Small N, small B0 and Small R0\nB_list_Bnew = []\nfor i in range(n):\n  T,A,B = gillespie_ABA(100,20,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'r', label = 'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'r', linewidth = 4,label = 'R0 = 0.1') \n\n\n  \n#Small N, Small B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,20,1,0.2,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b', label = 'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'b', linewidth = 4,label = 'R0 = 5') \n\n\n#small N, small B0 and R0 = 1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,20,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'g', linewidth = 4,label = 'R0 = 1') \n\n\n  \n#small N, Large B0 and Small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n # plt.plot(T,B, 'r',label = 'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'r', linewidth = 4,label = 'R0 = 0.1') \n\n\n#Small N, Large B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,1,0.2,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b',label = 'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'b', linewidth = 4,label = 'R0 = 5') \n\n\n#small N, Large B0 and R0 = 1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nvar = 0\nfor i in range(n):#calculating standard deviation\n  var += (B_average - B_list_Bnew[i])**2\n\nstd_err = (var\/n)**0.5\n\n \nplt.errorbar(Tnew, B_average, yerr = std_err)\n\nplt.plot(Tnew,B_average, 'g', linewidth = 4,label = 'R0 = 1') \n\n\n\n\n\nhandles, labels = plt.gca().get_legend_handles_labels()\nby_label = dict(zip(labels, handles))\nplt.legend(by_label.values(), by_label.keys())\nplt.xlabel('Time (s)', fontsize = 18)\nplt.ylabel('[B](t)', fontsize = 16)\nplt.title('Average and Standard deviation plot', fontsize = 20)\n\nplt.show()","66bcb856":"plt.rcParams['figure.figsize'] = (18,10)\nTnew = np.linspace(0,20,1000)\nn = 10\n#Large N, Large B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,2,0.4,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b' , label = \"R0 = 5\")\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'b', linewidth = 4,label = \"R0 = 5\")#stochastic average ploting\n\nplt.plot(Tnew,B_t(1000,800,0.4,5, t= Tnew)[0], 'k', linewidth = 3)#mean - field solution\n\n\n  \n#Large N , Large B0 and R0 = 1  \nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g', label = 'R0 = 1' )\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'g', linewidth = 4,label = 'R0 = 1') \n\nplt.plot(Tnew,B_t(1000,800,1,1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n#Large N, Small B0 and Small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'r', label = 'R0 = 0.1' )\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'r', linewidth = 4,label = 'R0 = 0.1') \n\nplt.plot(Tnew,B_t(1000,200,1,0.1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n#Large N, Small B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,2,0.4,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b',  label =  'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'b', linewidth = 4,label =  'R0 = 5') \n\nplt.plot(Tnew,B_t(1000,200,0.4,5, t= Tnew)[0], 'k', linewidth = 3)\n\n#Large N, Small B0 and R0 =1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,200,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g', label = 'R0 = 1')\n  \na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'g', linewidth = 4,label = 'R0 = 1') \n\nplt.plot(Tnew,B_t(1000,200,1,1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n#Large N, Large B0 and small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,800,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'r', label =  'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'r', linewidth = 4, label = 'R0 = 0.1') \n\nplt.plot(Tnew,B_t(1000,800,1,0.1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n#Small N, small B0 and Small R0\nB_list_Bnew = []\nfor i in range(n):\n  T,A,B = gillespie_ABA(100,20,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'r', label = 'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'r', linewidth = 4,label = 'R0 = 0.1') \n\nplt.plot(Tnew,B_t(100,20,1,0.1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n  \n#Small N, Small B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,20,1,0.2,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b', label = 'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'b', linewidth = 4, label = 'R0 = 5') \n\nplt.plot(Tnew,B_t(100,20,0.2,5, t= Tnew)[0], 'k', linewidth = 3)\n\n\n\n#small N, small B0 and R0 = 1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,20,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'g', linewidth = 4,label = 'R0 = 1') \n\nplt.plot(Tnew,B_t(100,20,1,1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n\n  \n#small N, Large B0 and Small R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,0.1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'r',label = 'R0 = 0.1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'r', linewidth = 4,label = 'R0 = 0.1') \n\nplt.plot(Tnew,B_t(100,80,1,0.1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n\n#Small N, Large B0 and Large R0\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,1,0.2,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'b',label = 'R0 = 5')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'b', linewidth = 4,label = 'R0 = 5') \n\nplt.plot(Tnew,B_t(100,80,0.2,5, t= Tnew)[0], 'k', linewidth = 3)\n\n\n\n#small N, Large B0 and R0 = 1\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(100,80,1,1,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'g', linewidth = 4,label = 'R0 = 1') \n\nplt.plot(Tnew,B_t(100,80,1,1, t= Tnew)[0], 'k', linewidth = 3)\n\n\n\n\n\n\nhandles, labels = plt.gca().get_legend_handles_labels()\nby_label = dict(zip(labels, handles))\nplt.legend(by_label.values(), by_label.keys())\nplt.xlabel('Time (s)', fontsize = 18)\nplt.ylabel('[B](t)', fontsize = 16)\n\nplt.show()","b5798976":"B_list_Bnew = []\nTnew1 = np.linspace(0,300,1000)\nfor i in range(20):# 50 realisations\n  T,A,B = gillespie_ABA(1000,1,0.5,0.1,300)\n  plt.plot(T,B)# plotting each realisation\n  \n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew1)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  \n\na = 0\nfor i in B_list_Bnew:#finding average of stochastic realisations\n  a = a+i\nB_average = a\/20  \n\nplt.plot(Tnew1,B_average, 'r', linewidth = 4, label = 'Stochastic average') #plotting average of stochastic simulations\n\nplt.plot(np.linspace(0,300,1000),B_t(1000,1,0.1,5, t=np.linspace(0,300,1000))[0], 'k', '--', linewidth = 4, label = 'mean-field solution') #plotting the mean field solution\nplt.show()","9c4d359a":"B_list_Bnew = []\nn = 100\n#N = 1000, beta = 0.51, gamma = 0.5\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,1,0.5,0.51,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'b', linewidth = 4) \n\nplt.plot(Tnew,B_t(1000,1,0.51,0.5\/0.51, t= Tnew)[0], 'g', linewidth = 3)\n\n\n#N=1000, beta = 0.95, gamma = 0.5\nB_list_Bnew = []\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,1,0.95,0.5,20)\n  T = np.array(T)\n  B = np.array(B)\n  f = interp1d(T,B, kind = 'nearest')\n  \n  Bnew = f(Tnew)\n  Bnew = np.array(Bnew)\n  B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g',label = 'R0 = 1')\n\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/n   \n\nplt.plot(Tnew,B_average, 'r', linewidth = 4) \n\nplt.plot(Tnew,B_t(1000,1,0.5,0.95\/0.5, t= Tnew)[0], 'k', linewidth = 3)\nplt.xlabel('Time (s)')\nplt.ylabel('B[t]')\nlabels = ['average stochastic beta = 0.51','mean-field solution beta = 0.51','average stochastic beta = 0.95','mean-field solution beta = 0.95']\nplt.legend(labels)\nplt.show()\n","ca4761cb":"#N=1000, beta = 0.95, gamma = 0.5\nTnew2 = np.linspace(0,50,1000)\nB_list_Bnew = []\ncount = 0\nn= 150\nfor i in range (n):\n  T,A,B = gillespie_ABA(1000,1,0.95,0.5,50)\n  T = np.array(T)\n  B = np.array(B)\n  if np.all(B) == False:# if there is zero number of individuals in state B, we drop that simulation\n        count = count+1 #to count how many such realisations are dropped\n        \n  else:#else we move forward with it as usual\n      f = interp1d(T,B, kind = 'nearest')\n\n      Bnew = f(Tnew2)\n      Bnew = np.array(Bnew)\n      B_list_Bnew.append(Bnew)\n  #plt.plot(T,B, 'g',label = 'R0 = 1')\nprint('The percentage  of realisations had to be dropped is {}%'.format((count\/n)*100))\na = 0\nfor i in B_list_Bnew:\n  a = a+i\nB_average = a\/(n-count) #while finding the average the average is found only for non zero realisations  \n\nplt.plot(Tnew2,B_average, 'r', linewidth = 4) # plotting the average of stochastic simulation\n\nplt.plot(Tnew2,B_t(1000,1,0.5,0.95\/0.5, t= Tnew2)[0], 'k', linewidth = 3)#plotting the mean-field average\nplt.xlabel('Time (s)')\nplt.ylabel('B[t]')\nplt.show() ","60c43272":"Aim : To superimpose the mean -  field solution to the stochastic realisations average.\n\nFor this for each of the case, both mean - field solution and stochastic simulations are plotted simultaniously","344b0d9f":"As we discussed in the previous question, this model assumes that all the individuals are potentially in contact with each other. But in a practical scenario, obviously all the individuals will not be in contact with each other. In practical there will be movements of individuals from different groups, like family, work etc. Also the disease spread pattern will be dependent on many other factors like social and economic patterns. Some people might be living in cities while other people might be living in rural areas.\n\nTo solve this problem, we can create different set of groups(list) in the gillespie algorithm inside the bigger list of population and we could allow movement of individuals within the groups, and between the groups and make the algorithm in such a way that, the people who are adjacent to the infected person(ie the smaller group which contains the affected person) has more probability of getting the infection than the group which doesn't have higher number of infected person.\n\nAlso, the travel rate, ie, the movement of individuals are also depended on the status of there disease, this also can be made into practical by using gillespie algorithm.\n\n\n","6a3af5e3":"From the above graph it is clear that there is no disagreement between mean-field solution and stochastic average when $\\beta = 0.51 $ and $\\gamma = 0.5$ This might be because it doesn't matter if the only one individual in the state B goes to state A since both the mean- field and the stochastic simulations are finally should reach the state with zero B. However there is a clear disagreement between the mean-field solution and the stochastic average when $\\beta = 0.95 $ and $\\gamma = 0.5$ because, as we discussed in the previous question, during the stochastic simulation, if the one and only state B individual changes to state A, then the whole system becomes in equilibrium and there wont be any further change. However, in the mean-field solution, this is not a possibility and since $R0$ value is much greater then 1 for this situation, it will be always going for the value $N(1 - 1\/R0)$\n\nThis is the reason for this disagreement between the mean-field soution and average of stochastic simulations. In order to solve this, we can avoid the simulations which results in all individuals being in state A, ie we should avoid the situation where $B = 0$ when the equilibrium value is $B^* != 0$,So that the average of stochastic simulations will not be pulled down by these random cases and there will be agreement bteweeen both mean-field solution and the stochastic average\n\nSo, I am going to remove the realisations where $B$ reaches zero in the following situation and going to take the average only for the remaining realisations. And to get a good number of non zero realisations I am increasing the repeats a bit more.","6a3b7472":"# Simulation \n\n","7e65e2fc":"The gillespie algorithm is used to create multiple stochastic simulations for For different cases with small N, Large N, small R0, Large R0, small B0 and large B0. In the following graph, different permutatiion of R0 and B0 for small N is showed.","62a47c8c":"As we can observe both the graphs almost coincide so we can use the interpolated values for calculating the average. ","d840700c":"In the above graph, the black lines represent the mean-field solution and colored lines represent the average of stochastic simulations. It is observed that, for the values and conditions we have plotted, the curves seem to be in agreement with each other.","05636335":"From the above figures it is eivdent that the function `B_t` asymptotically approach the corresponding equilibrium values ie $0$ or $N(1 - \\frac{1}{R0})$.\n\nFor $R0 \\, <1 \\longrightarrow $ equilibrium value $B^* = 0$\n\nFor $R0 \\, =1 \\longrightarrow $ equilibrium value $B^* = 0$ (already discribed analytically)\n\n\nFor $R0 \\, > 1 \\longrightarrow$ ewuilibrium value $B^* =N(1 - \\frac{1}{R0}) $","ae015095":"\n\nHere our primary aim is to plot  average and error bars for the gillespie simulation. However, we cannot directly plot the average value because we don't have exact time points at which we have values for all the multiple runs. In order to solve this I am defining my own fixed time points and I have interpolated the values of $B$ to the new time points for each run using the '**nearest**' method. This will make sure that for each new time point we have defined, the value of $B$ corresponding to the nearest time stamp will be mapped.\n\nAfter making this interpolation, now we will be in a position to find the average and to plot the error bar for multiple runs.","932e17f3":"The following function `B_t` is returning the $[B](t)$ which is calculated analytically by me","2262e22f":"From the graph again it is clear that, when $R0 = 1$ the graph seems more spread out(more variance) and the slop is less steep, which implies it takes more time to reach the equilibrium value ($B^* = 0$)","6379d181":"Now let us plot the simulations for both large and small N in the same graph. Each case is run 10 times","54da6708":"From the above simulation it is evident that for small N when $R0 = 1$ the simulations are more chaotic and it takes longer time for them to reach the value zero, compared to $R0 < 1$.","189cd243":"### By keeping $B0$ and $R0$ constant and variying $\\gamma$ we can obtain the following plots.","cf71b763":"### Comparing analytical integration with python odeint module default method","99457a71":"Since we keep the value of $R0$ and $N$ constant, the equilibrium value doesn't change wrt to different value of $\\gamma$. However, the rate at which the equilibrium is attained is changing as we change $\\gamma$ while keeping $R0$ constant.\n\nfor low value of $\\gamma$ equilibrium is attained in a lower rate and as the $\\gamma$ value is increasing, the function $B[t]$ attains equilibrium faster(higher slope).\n\nwhile $\\gamma = 0$, if we assume $R0 = constant$ it implies that $\\beta = \\infty $. By substituting $R0 = constant $ and $\\gamma = 0$, from the analytical equation for $B[t]$ we will get that $B[t] = B0$ for all values of time. From the graph we plot also it is visible that at $\\gamma = 0$, the plot is a straight line parallel to time axis, y being equal to $B0$","38d27548":"Here, we can observe a clear disagreement between mean-field solution and the stochastic average. As we can observe, there is curve ploted along $B = 0$ in the many realisations of stochastic simulation. This happens because since there is only one individual in state B, if the event of change happens at this position where there is a no individual at state B, which means B = 0 $\\implies$ the population is in equilibrium position, and there wont be any further change in the condition.\n\nIf this happens in some realisations, the remaining B values will be equal to zero, and if this doesn't happen, then the realisations will be similar to the mean - field solution.\n\nSo this is the reason why average of realisations is pulled down, since in some realisations, the population goes to the equilibrium condition by chance.","efa3ac19":"### For fixed $\\gamma$ and $B0$ lets vary the value of $R0$ and plot some graphs","ae681017":"Function for bifurcation plot\n\nIf R0 is greater than 1 then the equilibrium point is $ B^* = N(1-(1\/R0))$ and if R0 is less than 1 the equilibrium point is $B^* = 0$","2e6b38f7":"\n\nHere I have considered 100 replications for $N =1000,\\beta = 0.51 , \\gamma = 0.5 $ and 100 replications for $N = 1000, \\beta = 0.95 , \\gamma = 0.5$. For all of the situation $B0 = 1$ is considered so that we can clearly see the disagreement","fc5ac56b":"This is the remaining part of Analytical part, which is done in pdf format. To see that, visit '\\kaggle\\input\\modelling-analytical-part'","4e96c5d4":"### Now lets plot graphs for different values of $B0$ for some value of $R0 > 1$ and $R0 <1 $ seperatly","8c03552d":"By comparing the analytical function with both Euler as well as built in odeint funtion(uses LSODA) we can see that all the three types of differential equation solvers are in agreement with each other. So, our analytical function for $B[t]$ is correct.","69e5239e":"From the above graph it can be seen that the agreement between the mean-field solution and the average of stochastic solution has increased alot. Also, it can be noted that, almost half of the total stochastic realisation had to be removed, since the all were making $B=0$ which was the initial problem we faced.","f521c06a":"Here, we can use this type of mathematical modeling to model  **SIS**(Susceptable-Infective-Susceptable) type of epidemic modelling for smaller group of people(ie, for people in a small school etc). Here State A can represent a healthy individual and State B can represent a an individual who is affected with a disease which follows the SIS pattern(Tuberculosis, menengitis, gonorrhea etc).\n\nIn SIS modelling, infected individual return to the  susceptable class(individuals who can potentially get the disease) on recovery because the disease confers no immunity against infection. Here, in our modelling too, the individual who is recovered from state B to state A is not given any special considerartion and he has equal probability to get to state B again compared to a person who has never been to state B, which means our mathematical modelling stisfies **SIS** modeling requirement. Here $\\gamma$ can represent the rate at which disease is cured and $\\beta*B\/N$ represents rate at which disease is being spread in the population. If $B= 0$ which means there is no individual in the state $B$, ie, there is no disease any more, and the disease is seem to be irradicatied from the community altogather. Otherwise, there is another stabel equilibrium condition in which $B = N(1- 1\/R0)$ where this many number of people have the disease at any perticular time when have given enough time for the disease to spread (Disease - Free and Endemic equilibria and their stability)\n\n\n\nHowever, we cannot use these **SIS** (our) model for large communities, because in our model we assume that all the individuals are in contact with each other, however, it is not practical as in reality in large groups, there are sub groups and there are movement of individuals within and out of these subgroups. \n\nAnother situation in which we can use this modelling is to study the chemical reactions, which is indeed following the SIS modelling","6bf6dc08":"So, for further detailed examination of the agreement between the two, let us consider an extream situation, where $B0= 1$. ","63684c06":"In the above graph the average is calculated for each case and is ploted along the realisations. The black lines represent the average of each situation.","720c17b1":"### Comparing it with the Euler integration in Python","62a0d847":"When $B0 = 0$ the poplation is already in an equilibrium position. So there is no conversion from State A to State B and the whole population remains at state A for whole time, irrespective of $N,R0 \\, and \\, \\gamma$","512d0006":"In the above graph, the average is plotted and covering the average, the standard deviation(error plot) is also plotted.\n\n* It is noted that, for $R0 = 1$, the standard deviation is the thickest, ie, more variation.\n* While the slope is steep, every curve has least error or variation\n* for small values of N, the error(variation) is less compared to while N is large.","c974b2f3":"The thick red line shows the average of stochstic simulation for the condition and the thick black line shows the mean-filed solution for the given situation."}}