{"cell_type":{"f4369b57":"code","46f106d6":"code","14321358":"code","30b3575e":"code","c6c16f09":"code","4e3a136b":"code","35a60321":"code","cc5df5f8":"code","0e250fcd":"code","923ff86f":"code","64d297b7":"code","16459662":"code","46ca0410":"code","bbde69d3":"code","cf6c8490":"code","85c2eb89":"code","fc3de793":"code","71cdb2d6":"code","5798445f":"code","857768e2":"code","1b65f3bb":"markdown","072ce62f":"markdown","29cc22b5":"markdown","e8359cac":"markdown","2f9c883d":"markdown","f0cd5161":"markdown","6f696c52":"markdown","91d3f86b":"markdown","f2660a45":"markdown","3b049c8a":"markdown","37070421":"markdown"},"source":{"f4369b57":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')","46f106d6":"from tensorflow.keras.layers import Dense, Dropout, BatchNormalization, Input\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.callbacks import EarlyStopping\nfrom tensorflow.keras import backend as K\nfrom sklearn.model_selection import train_test_split, StratifiedKFold\nfrom sklearn.metrics import confusion_matrix, log_loss\nfrom sklearn.preprocessing import MinMaxScaler","14321358":"SEED = 2021","30b3575e":"train = pd.read_csv('..\/input\/tabular-playground-series-may-2021\/train.csv')\ntest = pd.read_csv('..\/input\/tabular-playground-series-may-2021\/test.csv')\nsample_submission = pd.read_csv('..\/input\/tabular-playground-series-may-2021\/sample_submission.csv')","c6c16f09":"train.drop('id', axis=1, inplace=True)\ntest.drop('id', axis=1, inplace=True)","4e3a136b":"XT = train.iloc[:, :-1]\nYT = train.iloc[:, -1]\nXV  = test","35a60321":"scaler = MinMaxScaler().fit(XT)\nX = scaler.transform(XT)\nZ = scaler.transform(XV)","cc5df5f8":"y = YT.map({val:idx for idx, val in enumerate(sorted(YT.unique()))})\ny = to_categorical(y.values)","0e250fcd":"Xt, Xv, yt, yv = train_test_split(X, y, test_size=.1, random_state=SEED, stratify=y)","923ff86f":"stop = EarlyStopping(monitor='val_loss', patience=2, mode='min')","64d297b7":"def mlp_model(lr):\n    model = Sequential([\n        Dense(256, input_dim=50, activation='relu', name='dense1'),\n        BatchNormalization(),\n        Dropout(0.1),\n\n        Dense(192, activation='relu', name='dense2'),\n        BatchNormalization(),\n        Dropout(0.2),\n\n        Dense(128, activation='relu', name='dense3'),\n        BatchNormalization(),\n        Dropout(0.4),\n\n        Dense(4, activation='softmax', name='fully')\n    ])\n\n    model.compile(loss='categorical_crossentropy', metrics=['accuracy'], optimizer=Adam(lr=lr))\n    return model","16459662":"model = mlp_model(25e-5)\nmodel.summary()","46ca0410":"history = model.fit(Xt, yt, validation_split=0.1, batch_size=512, epochs=128, callbacks=[stop])","bbde69d3":"model.evaluate(Xv, yv)","cf6c8490":"fig, ax = plt.subplots(figsize=(20,8))\nplt.plot(history.epoch, history.history['accuracy'])\nplt.plot(history.epoch, history.history['val_accuracy'])\nax.set_title('Learning Curve (Accuracy)')\nax.set_ylabel('Loss')\nax.set_xlabel('Epoch')\nax.legend(['train', 'val'], loc='best')\nplt.show()","85c2eb89":"fig, ax = plt.subplots(figsize=(20,8))\nplt.plot(history.epoch, history.history['loss'])\nplt.plot(history.epoch, history.history['val_loss'])\nax.set_title('Learning Curve (Loss)')\nax.set_ylabel('Loss')\nax.set_xlabel('Epoch')\nax.legend(['train', 'val'], loc='best')\nplt.show()","fc3de793":"def cv(fold, lr, EPOCHS, BATCH_SIZE):\n    skf = StratifiedKFold(n_splits=fold, shuffle=True)\n    model = mlp_model(lr)\n    losses = []\n    acc = []\n    stop = EarlyStopping(monitor='val_loss', patience=2, mode='min')\n    for i, (train_idx, val_idx) in enumerate(skf.split(X, y.argmax(1))):\n        print(f'Fold {i+1}')\n        Xt, Xv, yt, yv = X[train_idx], X[val_idx], y[train_idx], y[val_idx]\n        model.fit(Xt, yt, validation_split=0.1, epochs=EPOCHS, batch_size=BATCH_SIZE, verbose=0, callbacks=[stop])\n        score = model.evaluate(Xv, yv, verbose=0)\n        losses.append(score[0])\n        acc.append(score[1])\n        print(f'Loss ={score[0]} Accuracy = {score[1]}')\n    \n    print('CV Mean')\n    print(f'Loss ={np.mean(losses)} Accuracy ={np.mean(acc)}')","71cdb2d6":"cv(10, 25e-5, 128, 512)","5798445f":"sample_submission[['Class_1', 'Class_2', 'Class_3', 'Class_4']] = model.predict(Z)","857768e2":"sample_submission.to_csv('submission_.csv', index=False)","1b65f3bb":"# Import Libraries","072ce62f":"# Submission File","29cc22b5":"# Cross Validation","e8359cac":"# Import Data","2f9c883d":"## Plotting Learning Curve","f0cd5161":"## Model Train","6f696c52":"## Model Validation","91d3f86b":"# Preprocessing Data","f2660a45":"## Define Stopping Criteria","3b049c8a":"## Define MLP Model","37070421":"# Multi-Layer Perceptron"}}