{"cell_type":{"02e2202b":"code","0376eb96":"code","c3f58558":"code","5da2e5f9":"code","07733f14":"code","a4c3cf0e":"code","18919fa7":"code","0220305e":"code","0cc454c4":"code","f6b0b919":"code","9decae48":"code","d976118c":"code","bdb880c4":"code","33cb2e99":"code","d1637f0f":"code","c5db44cf":"code","999cd19a":"code","2aa6c757":"code","31d701f8":"code","93022b4b":"code","c9b67b09":"code","8df8e5d2":"code","4ac84076":"code","372f1531":"code","a7f915b2":"code","3ce86e6b":"code","c34e56cd":"code","59e817db":"code","59495b24":"code","ed3441de":"code","280e48bc":"markdown","e0fa37e0":"markdown","b188ac65":"markdown","c8e0d706":"markdown","cc2d3d00":"markdown","fdf3459e":"markdown","abafe46a":"markdown","d5564832":"markdown","2dca8fc6":"markdown","960e1ece":"markdown","d78c7fa8":"markdown","19cbe4ff":"markdown","770eeeeb":"markdown","72d03012":"markdown","2792d6f7":"markdown","f69e7894":"markdown","953a5b28":"markdown","05bc3b30":"markdown","9ea30ab0":"markdown","38da570a":"markdown","f0795e46":"markdown","cf8ff747":"markdown","ba9e0de4":"markdown","68f82de3":"markdown"},"source":{"02e2202b":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom numpy.linalg import norm\nfrom collections import Counter\nfrom time import time\nfrom matplotlib import collections  as mc\n\nsns.set_style('whitegrid')","0376eb96":"df = pd.read_csv(\"..\/input\/cities.csv\")","c3f58558":"df.head()","5da2e5f9":"plt.figure(figsize=(15, 10))\nplt.scatter(df.X, df.Y, s=1)\nplt.scatter(df.iloc[0: 1, 1], df.iloc[0: 1, 2], s=10, c=\"red\")\nplt.grid(False)\nplt.show()","07733f14":"nb_cities = max(df.CityId)\nprint(\"Number of cities to visit : \", nb_cities)","a4c3cf0e":"df.tail()","18919fa7":"def sieve_eratosthenes(n):\n    primes = [False, False] + [True for i in range(n-1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * 2, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes","0220305e":"primes = np.array(sieve_eratosthenes(nb_cities)).astype(int)\ndf['Prime'] = primes","0cc454c4":"penalization = 0.1 * (1 - primes) + 1","f6b0b919":"df.head()","9decae48":"plt.figure(figsize=(15, 10))\nsns.countplot(df.Prime)\nplt.title(\"Prime repartition : \" + str(Counter(df.Prime)))\nplt.show()","d976118c":"plt.figure(figsize=(15, 10))\nplt.scatter(df[df['Prime'] == 0].X, df[df['Prime'] == 0].Y, s=1, alpha=0.4)\nplt.scatter(df[df['Prime'] == 1].X, df[df['Prime'] == 1].Y, s=1, alpha=0.6, c='blue')\nplt.scatter(df.iloc[0: 1, 1], df.iloc[0: 1, 2], s=10, c=\"red\")\nplt.grid(False)\nplt.title('Visualisation of cities')\nplt.show()","bdb880c4":"def dist_matrix(coords, i, penalize=False):\n    begin = np.array([df.X[i], df.Y[i]])[:, np.newaxis]\n    mat =  coords - begin\n    if penalize:\n        return np.linalg.norm(mat, ord=2, axis=0) * penalization\n    else:\n        return np.linalg.norm(mat, ord=2, axis=0)","33cb2e99":"def get_next_city(dist, avail):\n    return avail[np.argmin(dist[avail])]","d1637f0f":"coordinates = np.array([df.X, df.Y])","c5db44cf":"current_city = 0 ","999cd19a":"left_cities = np.array(df.CityId)[1:]","2aa6c757":"path = [0]","31d701f8":"stepNumber = 1","93022b4b":"t0 = time()\n\nwhile left_cities.size > 0:\n    if stepNumber % 10000 == 0: #We print the progress of the algorithm\n        print(f\"Time elapsed : {time() - t0} - Number of cities left : {left_cities.size}\")\n    # If we are at the ninth iteration (modulo 10), we may want to go to a prime city. Note that there is an approximation here: we penalize the path to the 10th city insted of 11th\n    favorize_prime = (stepNumber % 10 == 9)\n    # Compute the distance matrix\n    distances = dist_matrix(coordinates, current_city, penalize=favorize_prime)\n    # Get the closest city and go to it\n    current_city = get_next_city(distances, left_cities)\n    # Update the list of not visited cities\n    left_cities = np.setdiff1d(left_cities, np.array([current_city]))\n    # Append the city to the path\n    path.append(current_city)\n    # Add one step\n    stepNumber += 1","c9b67b09":"print(f\"Loop lasted {(time() - t0) \/\/ 60} minutes \")","8df8e5d2":"path.append(0)","4ac84076":"print(len(path) == len(df) + 1)","372f1531":"def plot_path(path, coordinates):\n    # Plot tour\n    lines = [[coordinates[: ,path[i-1]], coordinates[:, path[i]]] for i in range(1, len(path)-1)]\n    lc = mc.LineCollection(lines, linewidths=2)\n    fig, ax = plt.subplots(figsize=(20,20))\n    ax.set_aspect('equal')\n    plt.grid(False)\n    ax.add_collection(lc)\n    ax.autoscale()","a7f915b2":"plot_path(path, coordinates)","3ce86e6b":"def get_score(path, coords, primes):\n    score = 0\n    for i in range(1, len(path)):\n        begin = path[i-1]\n        end = path[i]\n        distance = np.linalg.norm(coords[:, end] - coords[:, begin], ord=2)\n        if i%10 == 0:\n            if not primes[begin]:\n                distance *= 1.1\n        score += distance\n    return score","c34e56cd":"score = get_score(path, coordinates, primes)","59e817db":"print(\"Solution scored \", score)","59495b24":"print(score - get_score(path[:-1], coordinates, primes))","ed3441de":"submission = pd.DataFrame({\"Path\": path})\nsubmission.to_csv(\"submission.csv\", index=None)","280e48bc":"Our path starts with the north pole","e0fa37e0":"### Key functions","b188ac65":"We start at the north pole","c8e0d706":"We have all cities to visit, except the north pole","cc2d3d00":"### Plotting path","fdf3459e":"This one gets the closest city available","abafe46a":"Again, this is not very good. Let us check the influence of going back to the north pole : ","d5564832":"Ouch. Anyways, let us submit our results.","2dca8fc6":"This is kinda bad, but this is a greedy algorithm so there was not much to expect.","960e1ece":"## Getting Prime Cities","d78c7fa8":"## Results","19cbe4ff":"# Greedy Reindeer - A Starter code to the Traveling Santa Problem\n### Using a greedy algorithm to solve the problem\n\nPrime cities are taken into account","770eeeeb":"Almost a tenth of the cities is prime, which is a good because we want to visit prime a prime city every 10 cities.","72d03012":"Checking that our path is of correct length","2792d6f7":"There are prime cities approximately all around the map. Which is a good thing as well.","f69e7894":"### Initialization","953a5b28":"This first function gets the distance of all the cities to the current city.\n\nIf we decide to penalize, we multiply the distance of non-prime cities by $1.1$","05bc3b30":"## Loading Data","9ea30ab0":"## Now to the Algorithm","38da570a":"Adding the north pole to our path","f0795e46":"### Loop","cf8ff747":"#### End","ba9e0de4":"We store city coordinates in an array, for efficiency","68f82de3":"We start at 1 the first step"}}