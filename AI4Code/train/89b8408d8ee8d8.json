{"cell_type":{"a4f34aa0":"code","994f83a3":"code","a11eda43":"code","4a41a489":"code","7e358e3d":"code","7bdc5fcf":"code","06e044be":"code","346ee1de":"code","51fdff73":"code","372dbbdd":"code","87f6ff50":"code","cd0cd099":"code","70b10bf7":"code","80ef83c3":"code","12feafb5":"code","6afb2c46":"code","d4fb7929":"code","0417e4cc":"code","5c6f1023":"markdown","41fd4cb4":"markdown","ee9fd4ac":"markdown","8e7004ac":"markdown","361f8a83":"markdown","928f71df":"markdown","f114c7e2":"markdown","97e53853":"markdown","be151370":"markdown","50241954":"markdown","5b84ba30":"markdown","7b9eb640":"markdown","76733809":"markdown","010efd86":"markdown","3951d6bd":"markdown","a3856872":"markdown","7d1eef60":"markdown"},"source":{"a4f34aa0":"import numpy as np\nimport pandas as pd\n\nimport random\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.autograd import Variable\nfrom torchvision.utils import make_grid\nfrom torch.utils.data import TensorDataset, DataLoader\n\nfrom sklearn.model_selection import train_test_split\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport os\nprint(os.listdir(\"..\/input\"))","994f83a3":"train = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\n\n\nprint(train.shape)\ntrain.head()","a11eda43":"print(test.shape)\ntest.head()","4a41a489":"x_train_df = train.iloc[:,1:]\ny_train_df = train.iloc[:,0]\n\nprint(x_train_df.shape, y_train_df.shape)","7e358e3d":"x_train = x_train_df.values\/255.\ny_train = y_train_df.values\n\nx_test = test.values\/255","7bdc5fcf":"x_train = np.reshape(x_train, (-1, 1, 28,28))\nx_test = np.reshape(x_test, (-1, 1, 28,28))\n\n\nx_train.shape, x_test.shape","06e044be":"# This is to ensure reproducibility\nrandom_seed = 234\nx_train, x_val, y_train, y_val = train_test_split(x_train, y_train, test_size = 0.1, random_state=random_seed)\n\n\nx_train.shape, x_val.shape, y_train.shape, y_val.shape","346ee1de":"def display(rows, columns, images, values=[], predictions=[]):\n    fig = plt.figure(figsize=(9, 11))\n\n    ax = []\n\n    for i in range( columns*rows ):\n        img = images[i]\n        ax.append(fig.add_subplot(rows, columns, i+1))\n        \n        title = \"\"\n        \n        if(len(values) == 0):\n            title = \"Pred:\" + str(predictions[i])\n        elif(len(predictions) == 0):\n            title = \"Value:\" + str(values[i])\n        elif(len(values) != 0 and len(predictions) != 0):\n            title = \"Value:\" + str(values[i]) + \"\\nPred:\" + str(predictions[i])\n        \n        ax[-1].set_title(title)  # set title\n        plt.imshow(img)\n\n    plt.show()\n    \nidx = np.random.randint(1, 1000, size=9)\n\nimages = x_train[idx,:]\nimages = images[:,0]\n\nvalues = y_train[idx]\n\ndisplay(rows=3, columns=3, images=images, values=values, predictions=[])","51fdff73":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nprint(device)","372dbbdd":"class Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        \n        self.conv1 = nn.Conv2d(1,2,3)\n        \n        self.fc1 = nn.Linear(338,10)\n        self.fc1Size = 0\n        self.toKnowMaxPoolSize= False\n        \n    def forward(self, x):\n        x = F.max_pool2d(F.relu(self.conv1(x)),2)\n        \n        if(self.toKnowMaxPoolSize == True):\n            self.fc1Size = x.size()\n            print(x.size())\n            return\n        #now lets reshape the matrix i.e. unrolling the matrix\n        x = x.view(x.size()[0],-1)\n        x = self.fc1(x)\n        return x\n    \nnet = Net()\n\nnet.to(device)\n\nnet","87f6ff50":"criterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)","cd0cd099":"torch_x_train = torch.from_numpy(x_train).type(torch.FloatTensor)\ntorch_y_train = torch.from_numpy(y_train).type(torch.LongTensor)\n\ntrain = torch.utils.data.TensorDataset(torch_x_train,torch_y_train)\n\ntrain_loader = torch.utils.data.DataLoader(train, batch_size = 32, shuffle = False)","70b10bf7":"%%time\n\n#Seed\ntorch.manual_seed(1234)\n\nfor epoch in range(10):\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        inputs, labels = data\n        inputs, labels = inputs.to(device), labels.to(device)\n        \n        # zero the parameter gradients\n        optimizer.zero_grad()\n\n        # forward + backward + optimize\n        outputs = net(inputs)\n        outputs = F.log_softmax(outputs, dim=1)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        \n        # print statistics\n        running_loss += loss.item()\n        if i % 1000 == 999:    # print every 500 mini-batches\n            print('[%d, %5d] loss: %.3f' % (epoch + 1, i+1, loss.item()))\n#             print('[%d, %5d] loss: %.3f' % (epoch + 1, i, running_loss \/ 500))\n#             running_loss = 0.0\n\nprint('Finished Training')","80ef83c3":"#Validate trained model\ntorch_x_val = torch.from_numpy(x_val).type(torch.FloatTensor)\ntorch_y_val = torch.from_numpy(y_val).type(torch.LongTensor)\n\ntorch_x_val, torch_y_val = torch_x_val.to(device), torch_y_val.to(device)\n\nval = net(torch_x_val)\n\n_, predicted = torch.max(val.data, 1)\n\n#Get accuration\nprint('Accuracy of the network %d %%' % (100 * torch.sum(torch_y_val==predicted) \/ len(y_val)))","12feafb5":"# Get random data from the valication dataset and the predicted values\nidx = np.random.randint(1, 1000, size=9)\n\nimages = x_val[idx,:]\nimages = images[:,0]\n\nvalues = y_val[idx]\n\npredicted = predicted.cpu()\n\npredictions = predicted.data.numpy()\npredictions = predictions[idx]\n\ndisplay(rows=3, columns=3, images=images, values=values, predictions=predictions)","6afb2c46":"torch_x_test = torch.from_numpy(x_test).type(torch.FloatTensor)\n\ntorch_x_test = torch_x_test.to(device)\n\ny_test = net(torch_x_test)\n\n_, predicted = torch.max(y_test.data, 1)","d4fb7929":"idx = np.random.randint(1, 1000, size=9)\n\nimages = x_test[idx,:]\nimages = images[:,0]\n\npredicted = predicted.cpu()\n\npredictions = predicted.data.numpy()\npredictions = predictions[idx]\n\ndisplay(rows=3, columns=3, images=images, values=[], predictions=predictions)","0417e4cc":"ImageId = np.arange(1, len(x_test)+1)\nLabel = predicted.data.numpy()\n\nmy_submission = pd.DataFrame({'ImageId': ImageId, 'Label': Label})\nmy_submission.to_csv('submission.csv', index=False)\n\nmy_submission.head()","5c6f1023":"#### Define out tensors and dataloader","41fd4cb4":"#### Try the model on the validation dataset","ee9fd4ac":"#### Our model is awesome, lets use it on the test dataset","8e7004ac":"#### Lets define the optimizer and loss function","361f8a83":"# Data Acquisition\n\n#### Load the training dataset into Pandas DataFrame","928f71df":"#### Train for 100 epoch","f114c7e2":"#### Convert the data to numeric arrays and normalize the features","97e53853":"#### Reshape the test and training dataset to (28,28) image arrays","be151370":"#### Lets display a sample of the predictions on the validation dataset","50241954":"#### Save predictions to csv for submission","5b84ba30":"#### Split the training dataset to features and labels\n","7b9eb640":"#### Display predictions of the test dataset","76733809":"#### Lets define the Convolutional Neural Network Model","010efd86":"#### Split the training dataset into training and validation datasets","3951d6bd":"#### Using the GPU","a3856872":"#### Helper function to display an array of images","7d1eef60":"# MNIST Image Classification using PyTorch Convolutional Neural Network"}}