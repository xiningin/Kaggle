{"cell_type":{"759d8b0a":"code","ef682be5":"code","23c7307b":"code","db4998ff":"code","abaa45bf":"code","38d099ff":"code","252d1989":"code","17bb15e9":"code","bd14bc97":"code","282acc9f":"code","01cb9fbf":"code","d574e71d":"code","c5fc09e2":"code","c3ed3430":"code","0f24e894":"code","7557198c":"code","1be3b82a":"code","a55569eb":"code","721a0e11":"code","9ad68a59":"code","efa256ae":"code","a36e851e":"code","5b42a734":"code","bef0a07d":"code","93fc4102":"code","427824b9":"code","43ae97f0":"code","643e3123":"code","fdb0975d":"code","216259fe":"code","d8875e4e":"code","f9b2fdb9":"code","3ba0ec81":"code","52572b4f":"code","2a87d5a9":"code","9d00bfa3":"code","2c19ced6":"code","699a30d7":"code","ef7d2c6b":"code","07462b5b":"code","bd50502c":"code","6d3b4898":"code","053e2180":"code","4ba90441":"code","ff9f8696":"code","50e6a819":"code","fae61987":"code","cad95381":"code","763f8c73":"code","c56bd423":"code","e41ec389":"code","9bd499d2":"markdown","da26d0c3":"markdown","a1c191e7":"markdown","fa04f432":"markdown","73d9c0f3":"markdown","4fa3f802":"markdown","7def2104":"markdown","29a51807":"markdown","df7c1704":"markdown","7d13a9f8":"markdown","e4052e22":"markdown","24125620":"markdown","d6b5356b":"markdown","c4044b8e":"markdown","c31583dd":"markdown","031b8db0":"markdown","f7e42e8c":"markdown","1aae7811":"markdown"},"source":{"759d8b0a":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pickle\nfrom scipy.stats import mode\nfrom collections import defaultdict\nimport itertools\nfrom tqdm.notebook import tqdm\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_absolute_error\nimport warnings; warnings.filterwarnings('ignore')","ef682be5":"train = pd.read_csv('..\/input\/ventilator-pressure-prediction\/train.csv', index_col=['id'])\ntest = pd.read_csv('..\/input\/ventilator-pressure-prediction\/test.csv', index_col=['id'])","23c7307b":"MAX_PRESSURE  = PRESSURE_MAX  = 64.82099173863328\nMIN_PRESSURE  = PRESSURE_MIN  = -1.895744294564641\nDIFF_PRESSURE = PRESSURE_STEP = 0.0703021454512\nMIN_PRESSURE2 = PRESSURE_MIN2 = MIN_PRESSURE + DIFF_PRESSURE","db4998ff":"# We will be filling our matches in a submission that scores CV=0.1406 (single LSTM model)\n# You can plug in your own submission here as well.\ntrain_preds = pd.read_csv('..\/input\/ventilator-foggy\/oofs_foggy_0.1406.csv', index_col=['id'])\ntest_preds = pd.read_csv('..\/input\/ventilator-foggy\/pred_foggy_0.1406.csv', index_col=['id'])","abaa45bf":"print(f'MAE = {mean_absolute_error(train[train[\"u_out\"] == 0][\"pressure\"], train_preds[train[\"u_out\"] == 0][\"pressure\"])}')","38d099ff":"# kts, kps = set(), set()\n# for breath in tqdm(train['breath_id'].unique()):\n#     breath_df = train[train['breath_id'] == breath]\n#     in_len = np.sum(1 - breath_df['u_out'].values)\n#     X = breath_df['u_in'].values[1:in_len].reshape((-1, 1))\n#     y = breath_df['pressure'].values[1:in_len]\n\n#     lr = LinearRegression()\n#     lr.fit(X, y)\n#     if lr.score(X, y) > 0.9999:\n#         print(lr.intercept_, lr.coef_[0])\n#         kts.add(lr.intercept_)\n#         kps.add(lr.coef_[0])","252d1989":"breath = train[train['breath_id'] == 2]\nin_len = np.sum(1 - breath['u_out'])\npressure = breath['pressure'].values[1:in_len]\nu_in = breath['u_in'].values[1:in_len]\n\nfound_kt, found_kp = None, None\nfor kt in [10, 15, 20, 25, 30, 35]:\n    for kp in [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]:\n        u_in_pred = kp * (kt - pressure)\n        if np.sum(np.abs(u_in - u_in_pred)) < 1e-10:\n            print('Found match!', kt, kp)\n            found_kt = kt\n            found_kp = kp\n            \nf, ax = plt.subplots(1, 2, figsize=(18, 4))\nax[0].plot(u_in, c='b', alpha=0.5, label='u_in')\nax[0].plot(found_kp * (found_kt - pressure), c='r', alpha=0.5, label='u_in_hat')\nax[0].legend()\nax[0].set_title('pressure -> u_in')\n\nax[1].plot(pressure, c='b', alpha=0.5, label='pressure')\nax[1].plot(found_kt - (u_in \/ found_kp), c='r', alpha=0.5, label='pressure_hat')\nax[1].legend()\nax[1].set_title('u_in -> pressure')\n\nplt.show()","17bb15e9":"def match_breath(breath):\n    u_in = breath['u_in'].values\n    inspiratory_len = np.sum(1 - breath['u_out'])\n    \n    u_in = u_in[1:inspiratory_len]\n    breath_mask = (u_in > 0) & (u_in < 100)\n    \n    if np.sum(breath_mask) < 2:\n        return None, None, None, None\n        \n    for kt in [10, 15, 20, 25, 30, 35]:\n        for kp in [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]:\n            preds = (kt - u_in \/ kp)\n            preds_round = (preds-MIN_PRESSURE)\/DIFF_PRESSURE\n            tune_error = np.sum(np.abs(np.round(preds_round[breath_mask]) - \n                                       preds_round[breath_mask]))\n            if tune_error < 1e-6:\n                return preds, kt, kp, breath_mask\n            \n    return None, None, None, None\n\nbreath = train[train['breath_id'] == 2]\npreds, kt, kp, mask = match_breath(breath)\npressure = breath['pressure'].values[1:in_len]\n\nplt.figure()\nplt.plot(pressure[mask], c='b', alpha=0.5, label='pressure')\nplt.plot(preds[mask], c='r', alpha=0.5, label='pressure_hat')\nplt.title(f'MAE = {np.mean(np.abs(preds - pressure))}')\nplt.legend()\nplt.show()","bd14bc97":"matches = pickle.load(open('..\/input\/ventilator-foggy\/p_controller_train_matches.p', 'rb'))","282acc9f":"train_preds_2 = train_preds.copy()\n\nfor breath_id in tqdm(train['breath_id'].unique()):\n    if breath_id not in matches:\n        continue\n        \n    breath = train[train['breath_id'] == breath_id]\n    preds, kt, kp, mask = match_breath(breath)\n    ids = breath.index.values[1:1+len(preds)]\n          \n    if preds is not None:\n        train_preds_2.loc[ids[mask], 'pressure'] = preds[mask]","01cb9fbf":"print(f'MAE = {mean_absolute_error(train[train[\"u_out\"] == 0][\"pressure\"], train_preds_2[train[\"u_out\"] == 0][\"pressure\"])}')","d574e71d":"mae1 = mean_absolute_error(train[train[\"u_out\"] == 0][\"pressure\"], train_preds[train[\"u_out\"] == 0][\"pressure\"])\nmae2 = mean_absolute_error(train[train[\"u_out\"] == 0][\"pressure\"], train_preds_2[train[\"u_out\"] == 0][\"pressure\"])\nprint(f'MAE diff = {mae1 - mae2}')\nprint(f'MAE = {mean_absolute_error(train_preds[train[\"u_out\"] == 0][\"pressure\"], train_preds_2[train[\"u_out\"] == 0][\"pressure\"])}')","c5fc09e2":"def generate_u_in(pressure, time_step, kp, ki, kt, integral=0):\n    dt = np.diff(time_step, prepend=[0])\n    preds = []\n    for j in range(32):\n        error = kt - pressure[j]\n        integral += (error - integral) * (dt[j] \/ (dt[j] + 0.5))\n        preds.append(kp * error + ki * integral)\n    return preds\n\npressure = train[train['breath_id'] == 1]['pressure'].values \ntimestep = train[train['breath_id'] == 1]['time_step'].values\n# The parameters below (0.8, 8.0 and 20) can be found by doing a grid search\n# over all 2400 possible values and finding the parameters with minimal error.\nu_in = generate_u_in(pressure, timestep, 0.8, 8.0, 20)\nnoise = train[train['breath_id'] == 1]['u_in'].values[:32] - u_in\n\nplt.figure()\nplt.plot(timestep[:32], train[train['breath_id'] == 1]['u_in'].values[:32], label='u_in')\nplt.plot(timestep[:32], u_in, label='u_in_hat')\nplt.legend()\nplt.show()","c3ed3430":"#Let's try this for 1 specific breath & timestep.\n# Notice how we are only using pressure to check our results! So this works on test breaths too.\npressure   = train[train['breath_id'] == 1]['pressure'].values \ntimestep   = train[train['breath_id'] == 1]['time_step'].values\nu_in       = train[train['breath_id'] == 1]['u_in'].values\nkp, ki, kt = 0.8, 8.0, 20\nt = 5\ndt = timestep[t] - timestep[t - 1]","0f24e894":"%%time\n\nfor P0 in np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE):\n    for P1 in np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE):\n        I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n        I1 = I0 + (kt - P1 - I0) * (dt \/ (dt + 0.5))\n        u_in_hat = kp * (kt - P1) + ki * I1\n        if abs(u_in_hat - u_in[t]) < 1e-8:\n            print(P0, P1, pressure[t-1:t+1])","7557198c":"# Let's fix our P0 and let's take a look at how our u_in predictions evolve across every iteration.\n# We will compare this to when P0 is wrong.\nP0 = pressure[t - 1]\n\nu_in_preds1 = []\nfor P1 in np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE):\n    I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n    I1 = I0 + (kt - P1 - I0) * (dt \/ (dt + 0.5))\n    u_in_hat = kp * (kt - P1) + ki * I1\n    u_in_preds1.append(u_in_hat)\n    \nP0 = pressure[t - 1] + DIFF_PRESSURE\n\nu_in_preds2 = []\nfor P1 in np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE):\n    I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n    I1 = I0 + (kt - P1 - I0) * (dt \/ (dt + 0.5))\n    u_in_hat = kp * (kt - P1) + ki * I1\n    u_in_preds2.append(u_in_hat)\n    \nf, ax = plt.subplots(1, 2, figsize=(16, 4))\nslope1 = u_in_preds1[1] - u_in_preds1[0]\nx_intersection1 = (u_in[t] - u_in_preds1[0])\/slope1\nax[0].plot(u_in_preds1)\nax[0].axhline(u_in[t], c='k', linestyle='--', alpha=0.25)\nax[0].axvline(x_intersection1, c='k', linestyle='--', alpha=0.25)\nax[0].set_title(f'Correct P0: intersection at x={x_intersection1}')\n\nslope2 = u_in_preds2[1] - u_in_preds2[0]\nx_intersection2 = (u_in[t] - u_in_preds2[0])\/slope2\nax[1].plot(u_in_preds2)\nax[1].axhline(u_in[t], c='k', linestyle='--', alpha=0.25)\nax[1].axvline(x_intersection2, c='k', linestyle='--', alpha=0.25)\nax[1].set_title(f'Wrong P0: intersection at x={x_intersection2}')\nplt.show()","1be3b82a":"%%time\nfor P0 in np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE):\n    I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n    \n    # Calculate 2 points for P1 so we can get the slope\n    I11 = I0 + (kt - MIN_PRESSURE - I0) * (dt \/ (dt + 0.5))\n    u_in_hat1 = kp * (kt - MIN_PRESSURE) + ki * I11\n    \n    I12 = I0 + (kt - MIN_PRESSURE2 - I0) * (dt \/ (dt + 0.5))\n    u_in_hat2 = kp * (kt - MIN_PRESSURE2) + ki * I12\n    \n    slope = u_in_hat2 - u_in_hat1\n    x_intersect = (u_in[t] - u_in_hat2) \/ slope\n    if abs(np.round(x_intersect) - x_intersect) < 1e-8:\n        print(P0, MIN_PRESSURE + (x_intersect + 1) * DIFF_PRESSURE, pressure[t-1:t+1])","a55569eb":"ID = 1\npressure   = train[train['breath_id'] == ID]['pressure'].values \ntimestep   = train[train['breath_id'] == ID]['time_step'].values\nu_in       = train[train['breath_id'] == ID]['u_in'].values\nu_out      = train[train['breath_id'] == ID]['u_out'].values","721a0e11":"def match_breath(u_in, u_out, timestep, kp, ki, kt):\n    dt = np.diff(timestep)\n    dt2 = dt \/ (dt + 0.5)\n    in_len = np.sum(1 - u_out)\n    preds = np.zeros(len(u_in)) - 999\n    \n    for t in range(1, in_len):\n        # If we had a match in previous timestep, we can re-use that match\n        if preds[t - 1] != -999:\n            P0 = preds[t - 1]\n        else:\n            P0 = np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE)\n            \n        I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n\n        # Calculate 2 points for our P1\n        I11 = I0 + (kt - MIN_PRESSURE - I0) * dt2[t-1]\n        u_in_hat1 = kp * (kt - MIN_PRESSURE) + ki * I11\n\n        I12 = I0 + (kt - MIN_PRESSURE2 - I0) * dt2[t-1]\n        u_in_hat2 = kp * (kt - MIN_PRESSURE2) + ki * I12\n\n        # Get slope and intersection point\n        slope = u_in_hat2 - u_in_hat1\n        x_intersect = (u_in[t] - u_in_hat2) \/ slope\n        \n        # We want the intersection to be an integer\n        diff = np.abs(np.round(x_intersect) - x_intersect)\n        \n        if diff.min() < 1e-10:\n            pos = np.argmin(diff)\n            \n            if preds[t - 1] == -999:\n                preds[t - 1] = P0[np.argmin(diff)]\n                preds[t] = MIN_PRESSURE + int(x_intersect[pos] + 1) * DIFF_PRESSURE\n            else:\n                preds[t] = MIN_PRESSURE + (np.round(x_intersect) + 1) * DIFF_PRESSURE\n            \n    return preds","9ad68a59":"%%time\npreds = match_breath(u_in, u_out, timestep, 0.8, 8.0, 20)","efa256ae":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds), '-o', label='matches')\nplt.legend()\nplt.show()","a36e851e":"mask = preds != -999\nprint('MATCHED MAE =', mean_absolute_error(pressure[:len(preds)][mask], preds[mask]))\nprint(f'MATCHES: {np.sum(mask)}')","5b42a734":"# Let's demonstrate the issue on a breath with optimal kp = 0\nID = 4\npressure   = train[train['breath_id'] == ID]['pressure'].values \ntimestep   = train[train['breath_id'] == ID]['time_step'].values\nu_in       = train[train['breath_id'] == ID]['u_in'].values\nu_out      = train[train['breath_id'] == ID]['u_out'].values","bef0a07d":"preds = match_breath(u_in, u_out, timestep, 0., 2., 30)","93fc4102":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds), '-o', label='matches')\nplt.legend()\nplt.show()","427824b9":"mask = preds != -999\nprint('MATCHED MAE =', mean_absolute_error(pressure[:len(preds)][mask], preds[mask]))","43ae97f0":"def match_breath(u_in, u_out, timestep, kp, ki, kt):\n    dt = np.diff(timestep)\n    dt2 = dt \/ (dt + 0.5)\n    in_len = np.sum(1 - u_out)\n    preds = np.zeros(len(u_in)) - 999\n    \n    for t in range(1, in_len):\n        # If we had a match in previous timestep, we can re-use that match\n#         if preds[t - 1] != -999 and kp > 0:\n#             P0 = np.array([preds[t - 1]])\n#         else:\n        P0 = np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE)\n            \n        I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n\n        # Calculate 2 points for our P1\n        I11 = I0 + (kt - MIN_PRESSURE - I0) * dt2[t-1]\n        u_in_hat1 = kp * (kt - MIN_PRESSURE) + ki * I11\n\n        I12 = I0 + (kt - MIN_PRESSURE2 - I0) * dt2[t-1]\n        u_in_hat2 = kp * (kt - MIN_PRESSURE2) + ki * I12\n\n        # Get slope and intersection point\n        slope = u_in_hat2 - u_in_hat1\n        x_intersect = (u_in[t] - u_in_hat2) \/ slope\n        \n        # We want the intersection to be an integer\n        diff = np.abs(np.round(x_intersect) - x_intersect)\n        \n        if diff.min() < 1e-10:\n            pos = np.argmin(diff)\n            \n            if preds[t - 1] == -999 and kp > 0 and t > 1:\n                preds[t - 1] = P0[np.argmin(diff)]\n            preds[t] = MIN_PRESSURE + (np.round(x_intersect[pos]) + 1) * DIFF_PRESSURE\n                \n    return preds","643e3123":"%%time\npreds = match_breath(u_in, u_out, timestep, 0., 2., 30)","fdb0975d":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds), '-o', label='matches')\nplt.legend()\nplt.show()","216259fe":"mask = preds != -999\nprint('MATCHED MAE =', mean_absolute_error(pressure[:len(preds)][mask], preds[mask]))","d8875e4e":"# Let's demonstrate the issue on a breath with optimal kp = 0\nID = 17\npressure   = train[train['breath_id'] == ID]['pressure'].values \ntimestep   = train[train['breath_id'] == ID]['time_step'].values\nu_in       = train[train['breath_id'] == ID]['u_in'].values\nu_out      = train[train['breath_id'] == ID]['u_out'].values\npreds = match_breath(u_in, u_out, timestep, 1.0, 3.0, 30)","f9b2fdb9":"mask = preds != -999\nprint('MATCHED MAE =', mean_absolute_error(pressure[:len(preds)][mask], preds[mask]))","3ba0ec81":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds), '-o', label='matches')\nplt.legend()\nplt.show()","52572b4f":"# Let's calculate I_5\ndef generate_u_in(pressure, time_step, kp, ki, kt, integral=0):\n    dt = np.diff(time_step)\n    preds = []\n    for j in range(32):\n        error = kt - pressure[j]\n        integral += (error - integral) * (dt[j] \/ (dt[j] + 0.5))\n        preds.append(kp * error + ki * integral)\n    return preds\n\nkp, ki, kt = 1., 3., 30\nI5 = (u_in[4] - kp * (kt - pressure[4]))\/ki\nu_in_hat = generate_u_in(pressure[5:], timestep[4:], 1.0, 3.0, 30, integral=I5)\nplt.plot(timestep[5:32], u_in[5:32] - u_in_hat[:-5], '-o')\nplt.title('noise')\nplt.show()","2a87d5a9":"noise = u_in[5:32] - u_in_hat[:-5]\nprint((np.diff(noise) \/ np.diff(timestep[5:32]))[:10])","9d00bfa3":"def match_triangle(u_in, u_out, timestep, preds, kp, ki, kt):\n    dt = np.diff(timestep)\n    dt2 = dt \/ (dt + 0.5)\n    in_len = np.sum(1 - u_out)\n    \n    for j in range(1, 32):\n        if preds[j - 1] == -999:\n            found_u2 = None\n            continue\n            \n        if preds[j] != -999 or preds[j + 1] != -999 or preds[j + 2] != -999:\n            found_u2 = None\n            continue\n            \n        if 0 in [u_in[j], u_in[j + 1], u_in[j + 2]] or 100 in [u_in[j], u_in[j + 1], u_in[j + 2]]:\n            found_u2 = None\n            continue\n        \n        if found_u2 is None:\n            val = u_in[j - 1]\n            integ1 = (val - kp * (kt - preds[j - 1])) \/ ki\n        else:\n            val = found_u2\n            integ1 = (val - kp * (kt - preds[j - 1])) \/ ki\n            \n        for P2 in np.arange(PRESSURE_MIN, PRESSURE_MAX + PRESSURE_STEP, PRESSURE_STEP): #\n            integ2 = integ1 + dt2[j - 1] * (kt - P2 - integ1)\n            u2 = kp * (kt - P2) + ki * integ2\n\n            P3 = np.arange(PRESSURE_MIN, PRESSURE_MAX + PRESSURE_STEP, PRESSURE_STEP)\n            integ3 = integ2 + dt2[j] * (kt - P3 - integ2)\n            u3 = kp * (kt - P3) + ki * integ3\n\n            integ41 = integ3 + dt2[j + 1] * (kt - PRESSURE_MIN - integ3)\n            u41 = kp * (kt - PRESSURE_MIN) + ki * integ41\n            dU1 = [u2 - u_in[j], u3 - u_in[j + 1], u41 - u_in[j + 2]]\n            x1 = ((dU1[1] - dU1[0]) \/ dt[j]) - ((dU1[2] - dU1[1]) \/ dt[j + 1])\n\n            integ42 = integ3 + dt2[j + 1] * (kt - PRESSURE_MIN2 - integ3)\n            u42 = kp * (kt - PRESSURE_MIN2) + ki * integ42\n            dU2 = [u2 - u_in[j], u3 - u_in[j + 1], u42 - u_in[j + 2]]\n            x2 = ((dU2[1] - dU2[0]) \/ dt[j]) - ((dU2[2] - dU2[1]) \/ dt[j + 1])\n\n            slope = (x2 - x1)\n            x_intersect = -x1 \/ slope\n\n            if np.min(np.abs(x_intersect - np.round(x_intersect))) < 1e-10:\n                pos3 = np.where(np.abs(x_intersect - np.round(x_intersect)) < 1e-10)[0][0]\n                \n                if preds[j] == -999:\n                    preds[j] = P2\n                elif abs(preds[j] - P2) > 1e-10:\n                    continue\n                    \n                if preds[j + 1] == -999:\n                    preds[j + 1] = P3[pos3]\n                elif abs(preds[j + 1] - P3[pos3]) > 1e-10:\n                    continue\n                    \n                if preds[j + 2] == -999:\n                    preds[j + 2] = np.round(x_intersect[pos3]) * PRESSURE_STEP + PRESSURE_MIN\n                    \n                found_u2 = u2\n                    \n                break\n                \n    return preds","2c19ced6":"%%time\npreds2 = match_triangle(u_in, u_out, timestep, preds, kp, ki, kt)","699a30d7":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds2), '-o', label='matches')\nplt.legend()\nplt.show()","ef7d2c6b":"def match_triangle_backwards(u_in, u_out, timestep, preds, kp, ki, kt):\n    dt = np.diff(timestep)\n    dt2 = dt \/ (dt + 0.5)\n    in_len = np.sum(1 - u_out)\n    found = None\n    \n    for j in range(32, -1, -1):\n        if preds[j] != -999:\n            found = None\n            continue\n            \n        if found is None and preds[j + 3] == -999:\n            continue\n            \n        if 0 in [u_in[j], u_in[j + 1], u_in[j + 2], u_in[j + 3]] or 100 in [u_in[j], u_in[j + 1], u_in[j + 2], u_in[j + 3]]:\n            found = None\n            continue\n\n        if found is None:\n            P_known = preds[j + 3]\n            val = u_in[j + 3]\n        else:\n            P_known = P2\n            val = found\n\n        P0_found = False\n        for P0 in np.arange(PRESSURE_MIN, PRESSURE_MAX + PRESSURE_STEP, PRESSURE_STEP):\n\n            P1 = np.arange(PRESSURE_MIN, PRESSURE_MAX + PRESSURE_STEP, PRESSURE_STEP)\n\n            integ3 = (val - kp * (kt - P_known)) \/ ki\n            integ2 = (integ3 - dt2[j + 2] * (kt - P_known))\/(1 - dt2[j + 2])\n\n            integ11 = (integ2 - dt2[j + 1] * (kt - PRESSURE_MIN))\/(1 - dt2[j + 1])\n            integ01 = (integ11 - dt2[j + 0] * (kt - P1))\/(1 - dt2[j + 0])\n            u01 = kp*(kt - P0) + ki*integ01\n            u11 = kp*(kt - P1) + ki*integ11\n            u21 = kp*(kt - PRESSURE_MIN) + ki*integ2\n            du1 = [u01 - u_in[j], u11 - u_in[j + 1], u21 - u_in[j+2]]\n            x1 = ((du1[1] - du1[0]) \/ dt[j]) - ((du1[2] - du1[1]) \/ dt[j + 1])\n\n            integ12 = (integ2 - dt2[j + 1] * (kt - PRESSURE_MIN2))\/(1 - dt2[j + 1])\n            integ02 = (integ12 - dt2[j + 0] * (kt - P1))\/(1 - dt2[j + 0])\n            u02 = kp*(kt - P0) + ki*integ02\n            u12 = kp*(kt - P1) + ki*integ12\n            u22 = kp*(kt - PRESSURE_MIN2) + ki*integ2\n            du2 = np.array([u02 - u_in[j], u12 - u_in[j + 1], u22 - u_in[j+2]])\n            x2 = ((du2[1] - du2[0]) \/ dt[j]) - ((du2[2] - du2[1]) \/ dt[j + 1])\n\n            slope = (x2 - x1)\n            x_intersect = -x1 \/ slope\n\n            if np.min(np.abs(x_intersect - np.round(x_intersect))) < 1e-10:\n                pos3 = np.where(np.abs(x_intersect - np.round(x_intersect)) < 1e-10)[0][0]\n\n                P1 = P1[pos3]\n                P2 = np.round(x_intersect[pos3]) * PRESSURE_STEP + PRESSURE_MIN\n\n                integ1 = (integ2 - dt2[j + 1] * (kt - P2))\/(1 - dt2[j + 1])\n                integ0 = (integ1 - dt2[j + 0] * (kt - P1))\/(1 - dt2[j + 0])\n                u0 = kp*(kt - P0) + ki*integ0\n                u1 = kp*(kt - P1) + ki*integ1\n                u2 = kp*(kt - P2) + ki*integ2\n\n                if preds[j + 2] == -999:\n                    preds[j + 2] = P2\n                elif abs(preds[j + 2] - P2) > 1e-10:\n                    continue\n\n                if preds[j + 1] == -999: \n                    preds[j + 1] = P1\n                elif abs(preds[j + 1] - P1) > 1e-10:\n                    continue\n\n                if preds[j] == -999:\n                    preds[j] = P0\n\n                found = u2\n                P0_found = True\n                break\n\n        if not P0_found:\n            found = None\n            \n    return preds","07462b5b":"%%time\npreds3 = match_triangle_backwards(u_in, u_out, timestep, preds2, kp, ki, kt)","bd50502c":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds2), '-o', label='matches')\nplt.legend()\nplt.show()","6d3b4898":"# Let's demonstrate the issue on a breath with optimal kp = 0\nID = 6\npressure   = train[train['breath_id'] == ID]['pressure'].values \ntimestep   = train[train['breath_id'] == ID]['time_step'].values\nu_in       = train[train['breath_id'] == ID]['u_in'].values\nu_out      = train[train['breath_id'] == ID]['u_out'].values\npreds = match_breath(u_in, u_out, timestep, 2.0, 4.0, 10)","053e2180":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds), '-o', label='matches')\nplt.legend()\nplt.show()","4ba90441":"%%time\npreds2 = match_triangle_backwards(u_in, u_out, timestep, preds, 2.0, 4.0, 10)","ff9f8696":"plt.figure(figsize=(12, 4))\nplt.plot(pressure, '-o', label='pressure')\nplt.plot(np.maximum(-2, preds2), '-o', label='matches')\nplt.legend()\nplt.show()","50e6a819":"def match(u_in, u_out, timestep, kp, ki, kt):\n    preds = match_breath(u_in, u_out, timestep, kp, ki, kt)\n    preds = match_triangle(u_in, u_out, timestep, preds, kp, ki, kt)\n    preds = match_triangle_backwards(u_in, u_out, timestep, preds, kp, ki, kt)\n    \n    # Filtering out some potential errors\n    preds[u_out == 1] = -999\n    preds[(u_in == 0) | (u_in == 100)] = -999\n    if kp == 0:\n        preds[preds <= 0] = -999\n    \n    return preds","fae61987":"np.random.seed(42)\nparams = pickle.load(open('..\/input\/ventilator-foggy\/train_parameters.p', 'rb'))\ntrain_breaths = []\nfor ID in params:\n    if params[ID][0] != -1:\n        train_breaths.append(ID)\ntrain_breaths = np.random.choice(train_breaths, replace=False, size=1000)","cad95381":"matches = []\nground_truth = []\ntotal = 0\n\nfor i, ID in tqdm(enumerate(train_breaths), total=len(train_breaths)):\n    \n    if params[ID][0] == -1:\n        continue\n        \n    pressure   = train[train['breath_id'] == ID]['pressure'].values \n    timestep   = train[train['breath_id'] == ID]['time_step'].values\n    u_in       = train[train['breath_id'] == ID]['u_in'].values\n    u_out      = train[train['breath_id'] == ID]['u_out'].values\n    preds      = match(u_in, u_out, timestep, params[ID][0], params[ID][1], params[ID][2])\n    \n    total += np.sum(1 - u_out)\n    mask = preds != -999\n    matches.extend(preds[mask])\n    ground_truth.extend(pressure[:len(preds)][mask])\n    \n    if i > 0 and i % 100 == 0:\n        mae = mean_absolute_error(ground_truth, matches)\n        print(f'[iteration #{i}] matched {len(matches)}\/{total} values; MAE = {mae}')","763f8c73":"np.random.seed(42)\nparams = pickle.load(open('..\/input\/ventilator-foggy\/test_parameters.p', 'rb'))","c56bd423":"matches = []\nground_truth = []\ntotal = 0\n\nfor i, ID in tqdm(enumerate(test['breath_id'].unique()), total=len(test['breath_id'].unique())):\n    \n    if params[ID][0] == -1:\n        continue\n        \n    timestep   = test[test['breath_id'] == ID]['time_step'].values\n    u_in       = test[test['breath_id'] == ID]['u_in'].values\n    u_out      = test[test['breath_id'] == ID]['u_out'].values\n    ids        = test[test['breath_id'] == ID].index.values\n    \n    preds      = match(u_in, u_out, timestep, params[ID][0], params[ID][1], params[ID][2])\n    mask = preds != -999\n    test_preds.loc[ids[:len(preds)][mask], 'pressure'] = preds[mask]\n    ","e41ec389":"test_preds.to_csv('pred_foggy_0.1406_replaced.csv')","9bd499d2":"# Putting it all together\n\nBelow is the combination of all matchers. As one will notice, this code still matches too many values ($72$-$75$% instead of $66$%) and introduces a few errors because of this, but the MAE seems to be around $0.01$ which might be a better trade-off (with a model with LB $0.12$ and $75$% matched with MAE $0.01$, an LB of $0.04$).\n\nDuring the competition, our code was a lot longer (and a lot less readable) than this. I am currently cleaning the code up and integrating it in this notebook. The number of errors should drop in upcoming versions.","da26d0c3":"**Notice how the x-value where our line intersects is almost perfectly integer. This means we would have bumped into this value during our for-loop (in the 210th iteration)! If it is a floating point, the value is achieved in between iterations and is thus not aligned with discrete pressure values**","a1c191e7":"# PID Controller Matching\n\nIn this notebook we will demonstrate how we went about matching 66% of the test data by inverting PID controllers. Most of the `u_in` trajectories in the data were sampled according to a PID controller and the pressure is quite deterministic as the lung used for testing was mechanical. Therefore, if we can find pressure values that, when plugged into the PID formulas, perfectly calculate to our provided `u_in`, we have a perfect match.\n\nA PID controller is used in physical system to manipulate a controllable variable in order to keep another measureable variable around a certain target value. In our case, `u_in` is the controllable variable and `pressure` is the measureable variable. The \"vanilla\" formula of a PID (Proportional - Integral - Derivative) controller can be found in [the paper of the organizers](https:\/\/arxiv.org\/pdf\/2102.06779.pdf) in section 2:\n\n$u_t = \\alpha \\epsilon_t + \\beta \\sum^k_{i=0}\\epsilon_{t-i} + \\gamma(\\epsilon_t - \\epsilon_{t-1})$\n\nHere, $u_t$ is the controllable variable and corresponds to the `u_in` value at time $t$. $\\epsilon_t$ corresponds to the **Proportional** term and is equal to $target - p_t$ with $p_t$ the `pressure` at time $t$. $\\sum^k_{i=0}\\epsilon_{t-i}$ corresponds to the **Integral** term and $\\epsilon_t - \\epsilon_{t-1}$ the **Derivative** term. $target, \\alpha, \\beta, \\gamma$ are tuneable parameters.","fa04f432":"## Parameters\n\nThe parameters are the following:\n\n* $\\alpha$, or referred to as $k_p$ in the code: $[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]$\n* $target$, or referred to as $k_t$ in the code: $[10, 15, 20, 25, 30, 35]$\n\nPS: $\\beta$ will have the same possible parameter values later on.\n\nLet's show the matching on one breath.","73d9c0f3":"# 1. P-Controllers\n\nLet us first take a look at the easiest case: PID Controllers with `I = 0` and `D = 0`. The formula from above simplifies to:\n\n$u_t = \\alpha \\epsilon_t$\n\nThis is just a 1-dimensional Linear Regression model with $u_t$ the dependent variable, $\\epsilon_t = target - p_t$ the dependent variable and $alpha$ the only weight of our 1D model. However, we are interested in predicting $p_t$ and not $u_t$, so let's rewrite this equation:\n\n$u_t = \\alpha (target - p_t) \\iff \\frac{u_t}{\\alpha} = target - p_t \\iff p_t = target - \\frac{u_t}{\\alpha}$.\n\n$\\alpha$ and $target$ are tunable parameters. **In this competition, there are only a discrete number of possibilities for these parameters.** There are two ways to find these: \n* yeet them from the appendix of the paper \n* Run the commented code below, which fits linear regression models using training pressure & u_in. It takes roughly 10 minutes.\n\n**Important note:** both the first value and all values of the expiratory phase of every breath are noisy. Discard these!","4fa3f802":"# 2. PI-Controllers\n\nThe integral is calculated by a moving average with decay. This is not the usual implementation of a PID controller, and is the reason why it took us that long to get it working.\n\nThe formula can be found [in this presentation](https:\/\/robotics.sjtu.edu.cn\/upload\/course\/1\/files\/Lecture%2010%20PID-2(1).pdf) on slide 26, or in the [source code of the lung they used](https:\/\/github.com\/CohenLabPrinceton\/pvp\/blob\/master\/pvp\/controller\/control_module.py).\n\nWe will rewrite $\\sum^k_{i=0}\\epsilon_{t-i}$ as $I_t$:\n\n$I_t = I_{t - 1} + (\\epsilon_t - I_{t - 1}) \\frac{\\Delta_t}{\\tau + \\Delta_t}$\n\nwith $\\Delta_t = time_{t} - time_{t - 1}$ and $\\tau$ a constant equal to $0.5$. Since we now have an integral term, we also have to tune $\\beta$, or referred to as $k_i$ in the code, which can take the same values as $\\alpha$.\n\nLet's take a look at a training breath again and how we are able to model `pressure -> u_in` perfectly using this formula on some breaths.","7def2104":"# 4. Removing noise\n\nIn section 4.2 of the paper, the organizers discuss two types of noise:\n\n1. A linear decreasing noise starting at a certain value going to 0 added to the beginning of the breath (basically a line going downwards (`\\`))\n2. Triangular noise starting somewhere in the middle of the breath (`\/\\` and `\\\/`)\n\nLet's try to isolate it...","29a51807":"## Matching algorithm\n\nNow unfortunately, this does not work on all breaths. We hypothesize that this is because integral is not always initialized to $0$. \n\nLuckily, we can rework our equations a bit to isolate the integral at any point in time. This avoids us having to propagate from the beginning of the signal to the timestep we want to predict. Instead, we can just calculate the integral of the previous timestep using our `u_in` and predicted `pressure` and propagate from there.\n\n$u_t = \\alpha \\epsilon_t + \\beta I_t \\iff I_t = \\frac{u_t - \\alpha \\epsilon_t}{\\beta}$\n\nNow our matching algorithm goes as follows:\n\n1. Assume we want to fill in the pressure for timestep `t`\n2. Take two random pressure values (from the 950 possible options). Let's call them `P0` and `P1`\n3. Also take a possible parameter combination (20 options for kp, 20 options for ki and 6 options for kt --> 2400 combinations)\n4. Calculate `dt = time_step[t] - time_step[t - 1]`\n4. Calculate `I0 = (u_in[t - 1] - kp * (kt - P0))\/ki`\n5. Calculate `I1 = I0 + (kt - P1 - I0) * (dt \/ (dt + 0.5))`\n7. Calculate `u_in_hat[t] = kp * (kt - P1) + ki * I1`\n8. If `u_in_hat[t] == u_in[t]` we can fill in P1 for `pressure[t]`","df7c1704":"# 3. I-Controllers\n\nWhen the optimal `kp` parameter is $0$, a few issues arise. If we look at our brute-force matching code with `kp=0`:\n```python\nI0 = (u_in[t - 1] - 0 * (kt - P0))\/ki\nI1 = I0 + (kt - P1 - I0) * (dt \/ (dt + 0.5))\nu_in_hat = 0 * (kt - P1) + ki * I1\n```\n\nWhich basically becomes:\n```python\nI0 = u_in[t - 1] \/ ki\nI1 = I0 + (kt - P1 - I0) * (dt \/ (dt + 0.5))\nu_in_hat = ki * I1\n```\n\nWhich no longer depends on `P0`. Our code will thus find a match for any `P0`. We have not been able to fix this entirely and we decided to sacrifice some matches here as a quick solution.","7d13a9f8":"**Here's a nice little trick. If we make a cocky assumption that all of our matches are perfect and correct, you can estimate your MAE locally by calculating the difference between the old submission and the new submission.**","e4052e22":"## Forward matching algorithm\n\nWhile not a perfect triangle, we do notice points that are on the same line in the beginning and ending of our noise (their slopes are nearly identical, and they are the negative of the other half of the triangle). This is the property that we can exploit: assume a sequence of matches followed by a sequence of non-matches starting from index `j` (e.g. starting from index 6 until index 14, we have a sequence of non-matches), from here on we can brute-force 3 new possible future `pressure` values and calculate the `u_in_hat` according to these. Then we can calculate the noise `u_in - u_in_hat`, if the slope between position `j` and `j + 1` is the same as the slope between position `j + 1` and `j + 2`, we are on the triangle and found a match.\n\n1. Start from the last match of a sequence of matches, which is followed by a sequence of non-matched (e.g. index 5 in our breath). `j` is the index of the first non-match (6 here)\n2. Calculate `integ1 = (val - kp * (kt - preds[j - 1])) \/ ki`\n3. For every possible combination of (`P2`, `P3`, `P4`) pressure values\n4. Calculate `integ2 = integ1 + dt2[j - 1] * (kt - P2 - integ1)` and `u2 = kp * (kt - P2) + ki * integ2`\n5. Calculate `integ3 = integ2 + dt2[j + 0] * (kt - P3 - integ2)` and `u3 = kp * (kt - P3) + ki * integ3`\n6. Calculate `integ4 = integ3 + dt2[j + 1] * (kt - P4 - integ3)` and `u4 = kp * (kt - P4) + ki * integ4`\n7. Calculate `dU = [u_in[j] - u2, u_in[j + 1] - u3, u_in[j + 2] - u4]`\n8. If `(dU[1] - dU[0]) \/ dt[j] == (dU[2] - dU[1]) \/ dt[j + 1]`, we have a match.\n\n--> Fortunately, we have our `kp`, `ki` and `kt` parameters already found by the previous step, but we do have $950*950*950$ possible combinations. We use the same optimization as before to eliminate one of the parameters and vectorize the other to speed it up.","24125620":"## 1000x speedup\n\nThat looks like a good match! Now unfortunately, this algorithm is really slow. If we take into account the grid search, we have `20*20*6*950*950` possible combinations to try out... If we fix our parameters, we have `950*950` combinations and we see that this already takes 6 seconds... However, we can speed this up by a factor of 950! Moreover, once we found a pressure for timestep `t` we can re-use this to calculate timestep `t + 1`, so that's another 950 speedup for the timesteps after that.","d6b5356b":"## Matching algorithm\n\nHowever, we used pressure for this code. Of course, we do not have pressures for our test data. We are still able to do our matching by exploiting the discrete nature of the pressure values. If we are able to find a $k_t$ and $k_p$ parameter such that our formula calculates to values that perfectly align with the discrete pressure values, we have a match. The alignment with the discrete pressure values can be calculated as follows:\n\n$p_{ROUND} = \\frac{\\hat{p} - p_{MIN}}{p_{STEP}}$\n\n$error = \\sum | \\lfloor p_{ROUND} + 0.5 \\rfloor - p_{ROUND} |$\n\nWith $\\lfloor p_{ROUND} + 0.5 \\rfloor$ a rounding operator (`np.round(.)`)","c4044b8e":"## Quick and dirty solution\n\nSo we notice a MAE of $5.25$ now, as there are 4 matches where `PRESSURE_MIN` has been filled in incorrectly. A simple post-processing trick is to remove the matches at the beginning of a sequence of matches when `kp = 0`.","c31583dd":"**From 6 seconds to 16 ms, I'll take it!**","031b8db0":"**As you can see, this only results in a few extra matches on the first half of the triangle, we will have to rework our logic in order to work backwards in the sequence so that we can match some more**\n\nWe will rewrite our integral equation:\n\n$I_t = I_{t - 1} + (\\epsilon_t - I_{t - 1}) \\frac{\\Delta_t}{\\tau + \\Delta_t}$\n\n$\\iff I_t = I_{t - 1}(1 - \\frac{\\Delta_t}{\\tau + \\Delta_t}) + \\epsilon_t\\frac{\\Delta_t}{\\tau + \\Delta_t}$\n\n$\\iff I_{t-1} = \\frac{I_t - \\epsilon_t\\frac{\\Delta_t}{\\tau + \\Delta_t}}{1 - \\frac{\\Delta_t}{\\tau + \\Delta_t}}$\n\nThis new equation allows us to propagate integral terms from the future! These future integral terms are then calculated on timesteps for which we found a match and propagated backwards.\n\n## Backwards matching algorithm\n\n1. Pre-calculate `dt2 = dt \/ (0.5 + dt)` and take a matched position `j+3` and its corresponding pressure.\n2. Calculate `integ3 = (u_in[j+3] - kp * (kt - preds[j+3])) \/ ki`\n3. Take 3 random pressure values: (`P0`, `P1`, `P2`). Propagate this integral backwards for 3 timesteps using the equation we just derived. \n4. First: `integ2 = (integ3 - dt2[j + 2] * (kt - preds[j+3]))\/(1 - dt2[j + 2])`\n5. Calculate `integ1 = (integ2 - dt2[j + 1] * (kt - P2))\/(1 - dt2[j + 1])`\n6. Calculate `integ0 = (integ1 - dt2[j + 0] * (kt - P1))\/(1 - dt2[j + 0])`\n7. Calculate `u0 = kp*(kt - P0) + ki*integ0`, `u1 = kp*(kt - P1) + ki*integ1` and `u2 = kp*(kt - P2) + ki*integ2`.\n8. Calculate `dU = [u_in[j] - u2, u_in[j + 1] - u3, u_in[j + 2] - u4]`\n9. If `(dU[1] - dU[0]) \/ dt[j] == (dU[2] - dU[1]) \/ dt[j + 1]`, we have a match.\n","f7e42e8c":"**Woohoo! More matches** Let's show how this also works for linear noise...","1aae7811":"Let's run this on all our training data to see what the impact is. **I pre-calculated a list of matches to make the notebook run quicker. Of course you can just remove this and let it run over the entire data.**"}}