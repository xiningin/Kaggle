{"cell_type":{"fca3657b":"code","645ef360":"code","4389246d":"code","49c1a14d":"code","1be9ff94":"code","327091ce":"code","0a1a99cf":"code","72b7246f":"code","508f1788":"code","69a85cec":"code","a35afc2a":"code","a877ca14":"code","eab8e4d4":"code","1030e6bf":"code","d4cb1c2e":"code","75151ab8":"code","6a7cdf72":"code","f73da68c":"code","294c4fdf":"code","d8d4e2ac":"code","8e0447d7":"code","61b7d165":"code","671d13d1":"code","d9183072":"code","5fe15cc2":"code","7f7aadb4":"code","589e55d4":"code","0b1b0fa6":"code","970c0f87":"code","102069a2":"code","da46a508":"code","fae35c62":"code","30fc5607":"code","6c9442b8":"code","4b5822f2":"code","153d4db8":"code","64bbb4ac":"code","4609f9f3":"code","587ff8ad":"markdown","a083de8d":"markdown","151266dd":"markdown","a24c4d6e":"markdown","6d4fda47":"markdown","9e467c9f":"markdown","be5c8198":"markdown","8c271b5c":"markdown","4134840f":"markdown","c3f27150":"markdown","33c54fb6":"markdown","9c760ac4":"markdown","4e49d0c8":"markdown","50b097b6":"markdown","dc54d656":"markdown","d8d081c1":"markdown","57acf02a":"markdown","ce197282":"markdown","9502d79b":"markdown","077c541d":"markdown","61ed4b12":"markdown","6745e09b":"markdown","cf82a386":"markdown","0fb71ee6":"markdown","a6a4f3f8":"markdown","565ded19":"markdown","c12d9f06":"markdown","e9c57ceb":"markdown","e05000a5":"markdown"},"source":{"fca3657b":"# %% module imports\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# %% read in data and modify data\ntrain = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')","645ef360":"train.describe(percentiles=[0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99], include='all')","4389246d":"train.info()","49c1a14d":"test.info()","1be9ff94":"train.Name.head()","327091ce":"def extract_title(name):\n    name = name.split()\n    for w in name:\n        if '.' in w:\n            return w\n    return None\n\nall_titles = pd.concat([train, test], sort=False).Name.apply(lambda name: extract_title(name))\nall_titles.unique()","0a1a99cf":"train['title'] = train.Name.apply(lambda name: extract_title(name))\ntest['title'] = test.Name.apply(lambda name: extract_title(name))\n\ntrain.groupby('title').Survived.agg(['count', 'mean'])","72b7246f":"titlemap = {'Don.':'noble', 'Rev.':'noble', 'Dr.':'noble', 'Mme.':'Mrs.',\n            'Ms.': 'Miss.', 'Major.':'noble', 'Lady.':'noble', 'Sir.':'noble', 'Mlle.':'Miss.', \n            'Col.':'noble', 'Capt.':'noble', 'Countess.':'noble', 'Jonkheer.':'noble', 'Dona.': 'noble'}\ntrain.title.replace(titlemap, inplace=True)\ntest.title.replace(titlemap, inplace=True)","508f1788":"train.groupby('title').Survived.agg(['count', 'mean'])","69a85cec":"from sklearn.preprocessing import LabelEncoder\n\ntitle_encoder = LabelEncoder().fit(train.title)\ntrain.title = title_encoder.transform(train.title)\ntest.title = title_encoder.transform(test.title)","a35afc2a":"train.Sex.head()","a877ca14":"sex_encoder = LabelEncoder().fit(train.Sex)\n\ntrain.Sex = sex_encoder.transform(train.Sex)\ntest.Sex = sex_encoder.transform(test.Sex)","eab8e4d4":"# combine data from training and test sample \nage_translator = pd.concat([train, test], sort=False).groupby('title').Age.median().to_dict()\n\n# add missing ages to `train` sample\ntrain['completeAge'] = train.apply(lambda x: age_translator[x.title], axis=1)\ntrain.loc[train.Age.notnull(), 'completeAge'] = train.loc[train.Age.notnull(), 'Age']\n#train.completeAge, agebins = pd.cut(train.completeAge, bins=np.linspace(0, 90, 15), retbins=True, labels=False)\n\n# add missing ages to `test` sample\ntest['completeAge'] = test.apply(lambda x: age_translator[x.title], axis=1)\ntest.loc[test.Age.notna(), 'completeAge'] = test.loc[test.Age.notna(), 'Age']\n#test.completeAge = pd.cut(test.completeAge, bins=agebins, labels=False)","1030e6bf":"train['familysize'] = train.Parch + train.SibSp + 1\ntest['familysize'] = test.Parch + test.SibSp + 1\ntrain.drop(['Parch', 'SibSp'], inplace=True, axis=1)\n\ntrain['hasfamily'] = 0\ntrain.loc[train.familysize == 1, 'hasfamily'] = 1\n\ntest['hasfamily'] = 0\ntest.loc[test.familysize == 1, 'hasfamily'] = 1","d4cb1c2e":"train.Ticket.head()","75151ab8":"train['ticketno'] = train.Ticket.apply(lambda x: x.split()[-1])\ntrain.ticketno.replace('LINE', \"0\", inplace=True)  # assign 0 to single non-numeric value\ntrain.ticketno = train['ticketno'].astype(np.int)\n\ntest['ticketno'] = test.Ticket.apply(lambda x: x.split()[-1])\ntest.ticketno = test['ticketno'].astype(np.int)","6a7cdf72":"train.Cabin.head()","f73da68c":"train['decklevel'] = train.Cabin.dropna().apply(lambda x: str(x)[0])\ntest['decklevel'] = test.Cabin.dropna().apply(lambda x: str(x)[0])\n\ndecklevel_encoder = LabelEncoder().fit(train.decklevel.dropna())\ntrain.loc[train.decklevel.notna(), 'decklevel'] = decklevel_encoder.transform(train.decklevel.dropna())\ntest.loc[test.decklevel.notna(), 'decklevel'] = decklevel_encoder.transform(test.decklevel.dropna())","294c4fdf":"# fill missing value with most common label\ntrain.Embarked.fillna('S', inplace=True)\n\nembarked_encoder = LabelEncoder().fit(train.Embarked)\n\ntrain.Embarked = embarked_encoder.transform(train.Embarked)\ntest.Embarked = embarked_encoder.transform(test.Embarked)","d8d4e2ac":"## Completing `Fare` in `test`\n\ntest.loc[test.Fare.isna(), 'Fare'] = train.Fare.median()","8e0447d7":"f, ax = plt.subplots(1, 2, figsize=(10, 5))\n\ntrain.groupby('Survived').Pclass.plot.hist(alpha=0.5, legend=True, ax=ax[0])\ntrain.groupby('Survived').familysize.plot.hist(alpha=0.5, legend=True, ax=ax[1])","61b7d165":"train['rich_small_families'] = 3*train.Pclass+np.abs(train.familysize-3)\ntest['rich_small_families'] = 3*test.Pclass+np.abs(test.familysize-3)\n\ntrain.groupby('Survived').rich_small_families.plot.hist(alpha=0.5, legend=True)","671d13d1":"train.drop(['Survived', 'Embarked', 'title', 'Sex'], axis=1).corrwith(train.Survived).agg('square').plot.bar(title='Coefficient of Determination')","d9183072":"import seaborn as sns\n\nf, ax = plt.subplots(figsize=(15,10))\nsns.heatmap(train.corr(method='spearman')**2, annot=True, fmt='.2f', cmap='viridis', ax=ax)","5fe15cc2":"train.groupby('Survived').title.plot.hist(alpha=0.5, legend=True)","7f7aadb4":"train.groupby('Survived').Embarked.plot.hist(alpha=0.5, legend=True)","589e55d4":"train.groupby('Survived').Sex.plot.hist(alpha=0.5, legend=True)","0b1b0fa6":"train.groupby('Survived').completeAge.plot.hist(alpha=0.5, legend=True)","970c0f87":"train.groupby('Survived').hasfamily.plot.hist(alpha=0.5, legend=True)","102069a2":"featurelist = ['Pclass', 'Fare', 'title', 'Sex', 'Embarked', 'rich_small_families', 'completeAge', 'hasfamily']","da46a508":"train[featurelist].info()","fae35c62":"from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import GridSearchCV\n\nparameters = {'n_estimators': [40, 50, 60, 70], \n              'max_depth': [7, 10, 13], \n              'max_features': range(3, len(featurelist)),\n             'min_samples_leaf': [1, 2, 3],\n             'min_samples_split': [7, 10, 12]}\n\nmodel = RandomForestClassifier(random_state=42)\ngrid = GridSearchCV(model, param_grid=parameters, cv=5, n_jobs=-1, scoring='accuracy')\ngrid.fit(train[featurelist], train.Survived)","30fc5607":"grid.best_params_","6c9442b8":"grid.best_score_","4b5822f2":"from sklearn.metrics import classification_report, confusion_matrix\n\nprint(classification_report(grid.predict(train[featurelist]), train['Survived']))","153d4db8":"sns.heatmap(confusion_matrix(grid.predict(train[featurelist]), train['Survived']), annot=True, fmt='d', cmap='viridis')","64bbb4ac":"result = test\nresult.loc[:,'Survived'] = grid.predict(test[featurelist])\nresult.head()","4609f9f3":"result[['PassengerId', 'Survived']].to_csv('submission.csv', header=True, index=False)","587ff8ad":"Test sample:\n* `Age` incomplete: feature missing for a significant fraction of the sample\n* `Fare` mostly complete: feature missing for a single data point\n* `Cabin` highly incomplete: feature missing for the majority of the sample","a083de8d":"Do these titles carry information on survival?","151266dd":"Strip characters and extract numbers:","a24c4d6e":"### `Sex`","6d4fda47":"## Data Overview","9e467c9f":"We encode the different titles:","be5c8198":"# Modeling","8c271b5c":"### `Name`","4134840f":"## Pre-Processing\n\nThe following features are non-numerical, requiring encoding or data extraction:\n* `Name`\n* `Sex`\n* `Ticket`\n* `Cabin`\n* `Embarked`","c3f27150":"### Trends among ordinal and categorical features\n\nWe investigate trends between the categorial features and `Survived`:","33c54fb6":"### New feature `rich_small_families`","9c760ac4":"## Correlations with `Survived`\n\nWe investigate correlations of all continuous and ordinal features with `Survived` based on the coefficient of determination:","4e49d0c8":"Training sample:\n* `Age` incomplete: feature missing for a significant fraction of sample\n* `Cabin` highly incomplete: feature missing for the majority of the sample\n* `Embarked` mostly complete: feature missing for an insignificant fraction of the sample\n* `Cabin` mostly incomplete","50b097b6":"# Predicting Survival on the Titanic\n\nThis kernel combines a gridsearch with a RandomForest model to predict Titanic survivors. I try to take a quantitative approach in the selection of the features that go into the modeling.","dc54d656":"### `Ticket`","d8d081c1":"`PassengerId` plays no role in survival as do the different flavors of `Age`. The latter is somewhat surprising. We will investigate this with a histogram below. The most important features are `Pclass`, `Fare`, `rich_small_families`.\n\nFor the sake of completeness, we plot a heatmap of the pair-wise coefficients of determination for all features.","57acf02a":"# Predicting the `test` Sample","ce197282":"### `Cabin`","9502d79b":"Finding: every single person has a title attached to their name. This title might come in handy in the classification. We compile a set of all titles that occur either in the `train` or the `test` sample:","077c541d":"# Changelog\n\n* v1: using `featurelist = ['Pclass', 'sexcode', 'completeAge', 'decklevelcode', 'ticketno', 'embarkedcode']` resulting in `train` sample  accuracy of 0.85 and public score of 0.76\n* v2: using `featurelist = ['Pclass', 'sexcode', 'SibSp', 'Parch', 'completeAge', 'Fare', 'embarkedcode', 'decklevelcode']` resulting in `train` sample accuracy of 0.84 and public score of 0.75\n* v3: some minor fixes\n* v4: a major rework with a hopefully more quantitative analysis and feature selection: `featurelist = ['Pclass', 'Fare', 'title', 'Sex', 'Embarked', 'rich_small_families', 'completeAge']` resulting in `train` sample accuracy of 0.84 and public score of 0.78.\n* v5: minor changes\n* v6: added polynomial and interaction features: 0.78 `train` sample accuracy\n* v7: removed the polynomial and interaction features again as they don't have a beneficial effect on Decision Tree-based models; fixed some code; added `hasfamily` feature; resulting in `train` sample accuracy of 0.85 ","61ed4b12":"### `Parch` + `SibSp` = `familysize` + `hasfamily`\n\nWe combine the features `Parch` and `SibSp` into `familysize` as they describe very similar characteristics. In addtion to that, `hasfamily` describes whether an individual has any family on board (1) or is all by themselves (0).","6745e09b":"Where available, the cabin number provides information on which deck the corresponding person's cabin was located. We extract this information and encode it in the `decklevel` feature:","cf82a386":"### `Age`\n\nThe passenger's age is a potentially important feature - but unfortunately, it is incomplete. However, we can take advantage of `title` and fill in missing ages with the median ages of passengers carrying the same title.","0fb71ee6":"All of the plotted features seem to provide some information that is relevant for the survival of an individual passenger.\n\nThis last histogram explains the mystery of the missing correlation between `Age` and `Survival`: the survival rate is highest among young children and lowest among 20-30 yr olds. However, there is no linear trend with age. Hence, the seeming lack of correlation.  ","a6a4f3f8":"## Data Completeness","565ded19":"Yes, some titles (with significant counts) clearly  show a preference for survival, while others are biased against. We replace some of the rare titles and check again:","c12d9f06":"While first-class passengers have a significantly higher survival rate than third-class passengers, families of size 2-4 people seem to be more likely to survive. We can combine this knowledge into a new feature that I call `rich_small_families`: the value of this feature is low for low-`Pclass` passengers and passenger are part of a family with ~3 members; both groups are likely to survive:","e9c57ceb":"# Data Preparation","e05000a5":"### `Embarked`"}}