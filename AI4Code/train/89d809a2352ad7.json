{"cell_type":{"2cfbd9d8":"code","7940b710":"code","0841388d":"code","5b92ef5f":"code","1fa9a984":"code","ee96f4fb":"code","43158c4c":"code","11f3dd0e":"code","c85a8d17":"code","5ad2b143":"code","d203b401":"code","7c1cf68b":"code","bd009656":"code","1b9da6a5":"markdown","593797eb":"markdown","480d1e7f":"markdown","c1939eef":"markdown","d04465ab":"markdown","7b771d6d":"markdown","9e7f9d63":"markdown"},"source":{"2cfbd9d8":"import os\nimport cv2\nimport numpy as np \nimport matplotlib.pyplot as plt\n\ndata_dir = '\/kaggle\/input\/image-grid'\ndata_file = os.listdir(data_dir)\ndata_file.sort()\ndata_file","7940b710":"n = len(data_file)\nfig, ax = plt.subplots(1, 4, figsize=(25, 5.5))\nfor k in range(n):\n    img = cv2.imread(os.path.join(data_dir, data_file[k]))\n    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    ax[k].imshow(img, aspect=\"auto\")\n    ax[k].set_title('original image : \"%s\"'%(data_file[k]))\nplt.show()","0841388d":"def replace_pixel_chanel(ID, chanel_1, chanel_2):\n    \"\"\"\n        This function return the plug_in_chanel by another chanel\n        Input args:\n            ID (str): path to image with the original_order_chanel = [0, 1, 2]\n            chanel_1, chanel_2 (int of {0, 1, 2}): is the order_of_plug_in_chanels. \n                         For example: (chanel_1, chanel_2) = (0, 2); meant replace all pixel in chanel[0](red) to chanel[2](blue)\n            Noting that (chanel_1, chanel_2) = (0, 2) is not the same with (chanel_1, chanel_2) = (2, 0)\n    \"\"\"\n    img = cv2.imread(ID)\n    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    img[:, :, chanel_1] = img[:, :, chanel_2]\n    \n    plt.imshow(img)\n    plt.title('plug all pixel chanels_%s in chanel_%s'%(chanel_1, chanel_2))\n    plt.axis('off')","5b92ef5f":"ID1 = os.path.join(data_dir, data_file[0])\nplt.figure(figsize = (20, 15))\nfor i in range(3):\n    for j in range(3): \n        plt.subplot(3, 3, 3*i + 1 + j)\n        replace_pixel_chanel(ID1, i, j)","1fa9a984":"ID2 = os.path.join(data_dir, data_file[2])\nplt.figure(figsize = (20, 15))\nfor i in range(3):\n    for j in range(3): \n        plt.subplot(3, 3, 3*i + 1 + j)\n        replace_pixel_chanel(ID2, i, j)","ee96f4fb":"def perm_img_chanel(ID, perm_ls):\n    \"\"\"\n        This function return the plug_in_chanel by another chanel\n        Input args:\n            ID (str): path to image with the original_order_chanel = [0, 1, 2]\n            perm_ls (list of 3 intergers)\n    \"\"\"\n    img = cv2.imread(ID)\n    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    for k in range(3):\n        img[:, :, k] = img[:, :, perm_ls[k]]\n    plt.imshow(img)\n    plt.title('perm_list = %s'%(perm_ls))\n    plt.axis('off')","43158c4c":"idx = 0\nplt.figure(figsize = (25, 39))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            plt.subplot(9, 3, idx + 1)\n            perm_img_chanel(ID1, [i, j, k])\n            idx += 1","11f3dd0e":"idx = 0\nplt.figure(figsize = (25, 15))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            plt.subplot(3, 9, idx + 1)\n            perm_img_chanel(ID2, [i, j, k])\n            idx += 1","c85a8d17":"def compl_img_chanel(ID, chanels):\n    \"\"\"\n        This function returns the complement_of_pixels in the chanels\n        Input_args:\n            ID : path to image\n            chanels (list of intergers of {0, 1, 2}): chanels of the image\n    \"\"\"\n    img = cv2.imread(ID)\n    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    n = len(chanels)\n    for k in range(n):\n        img[:, :, chanels[k]] = ~img[:, :, chanels[k]]\n    plt.imshow(img)\n    plt.title('chanel_complement = %s'%(chanels))\n    plt.axis('off')","5ad2b143":"idx = 0\nplt.figure(figsize = (25, 45))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            plt.subplot(9, 3, idx + 1)\n            compl_img_chanel(ID1, [i, j, k])\n            idx += 1","d203b401":"idx = 0\nID3 = os.path.join(data_dir, data_file[-1])\nplt.figure(figsize = (25, 45))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            plt.subplot(9, 3, idx + 1)\n            compl_img_chanel(ID3, [i, j, k])\n            idx += 1","7c1cf68b":"def perm_and_compl(ID, perm_ls):\n    \"\"\"\n        This function return the plug_in_chanel by another chanel\n        Input args:\n            ID (str): path to image with the original_order_chanel = [0, 1, 2]\n            perm_ls (list of 3 intergers)\n    \"\"\"\n    img = cv2.imread(ID)\n    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    for k in range(3):\n        img[:, :, k] = ~img[:, :, perm_ls[k]]\n    plt.imshow(img)\n    plt.title('Complement(perm_list = %s)'%(perm_ls))\n    plt.axis('off')","bd009656":"idx = 0\nplt.figure(figsize = (25, 45))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            plt.subplot(9, 3, idx + 1)\n            perm_and_compl(ID1, [i, j, k])\n            idx += 1","1b9da6a5":"## 2. Replace pixel_values of a given chanel by another chanel\nRemember that\n> 1) The range of the pixel values is from 0 (dark or completely black) to 255 (bright or completely white)\n>\n> 2) We have three channels : Red, Green, and Blue! Channels can be thought of as layers of matrices. Thus we can imagine 3 layers of matrices for the three channels. Each layer of matrix has its own pixel values.\n\nNow, I want to replace all_pixel in the red chanel by the blue_chanel, that mean the `matrix_layer` in chanel red, denoted by \n\n$$A = (a_{i, j})_{1 \\leq i \\leq n; 1 \\leq j \\leq m}$$\n\nwill be replaced by the `matrix_layer` in chanel blue, denoted by \n\n$$ B = (b_{i, j})_{1 \\leq i \\leq n; 1 \\leq j \\leq m} $$","593797eb":"On the diagonal, this concides with the original images, since we asign it by itself","480d1e7f":"## 3. Permute the chanel\n\nThe original order of the images in BGR is `red, green, blue`! So what happen if we make a permuations (with and without repetition) of these chanel?","c1939eef":"## Combine both of them","d04465ab":"In this file, we will discuss how to create the image based on:\n\n        1) replacing all_pixel in a given chanel by the pixels in another chanel.\n        2) permutation the chanel_order\n        3) compplement of one or multi pixel_chanels in the images\n        \n> First of all, we will import the basic libraries and list the file_names in the input_folder","7b771d6d":"## 1. Viewing all the input_images","9e7f9d63":"## 4. How about the complement of all pixel_values in the chanels\n\n> As we known \"The range of the pixel valuesis from 0 (dark or completely black) to 255 (bright or completely white)\"\n\nNow, in the `Red_chanel` with the matrix_layer $\\mathcal{R}$, a point $P(x, y)$ has a `pixel_value = 20`, then its complements is `255 - 20 = 235`\n\nSo, for all $P \\in \\mathcal{R}$, the complement of $\\mathcal{R}$ can be implemented by\n\n                        image[:, :, 0] = ~image[:, :, 0] "}}