{"cell_type":{"3b1c2eab":"code","bb87adc1":"code","c12877c8":"code","79d403f9":"code","9474f07d":"code","185943fa":"code","5093e28f":"code","ea2b0d09":"code","7c81ef31":"code","1bc4e710":"code","65d664d3":"markdown","1389ef3d":"markdown","3fd2fdf7":"markdown","f85adceb":"markdown","8adbef46":"markdown","56127413":"markdown","7f179c33":"markdown","f54227ed":"markdown","65bb43ba":"markdown","a338c6aa":"markdown"},"source":{"3b1c2eab":"import pandas as pd\nimport numpy as np\n\nimport lightgbm as lgb\nimport xgboost as xgb\nimport catboost as cbt\nimport random, os\nimport math\n\nfrom mlxtend.regressor import StackingCVRegressor\nfrom sklearn.experimental import enable_hist_gradient_boosting\nfrom sklearn.ensemble import VotingRegressor, RandomForestRegressor, HistGradientBoostingRegressor, ExtraTreesRegressor\nfrom sklearn.linear_model import LinearRegression, Ridge, BayesianRidge\nfrom sklearn.preprocessing import StandardScaler\n\nfrom sklearn.model_selection import cross_val_score\n\nimport warnings\nwarnings.simplefilter('ignore')\n\nRANDOM_SEED = 42\n\ndef seed_everything(seed=42):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n\nseed_everything(RANDOM_SEED)","bb87adc1":"train_data = pd.read_csv('..\/input\/tabular-playground-series-jul-2021\/train.csv', parse_dates=True)\ntest_data = pd.read_csv('..\/input\/tabular-playground-series-jul-2021\/test.csv', parse_dates=True)\nsample_sub = pd.read_csv('..\/input\/tabular-playground-series-jul-2021\/sample_submission.csv')\n\ntargets = ['target_carbon_monoxide', 'target_benzene', 'target_nitrogen_oxides']\n\ntrain_data[targets] = np.log1p(train_data[targets])\n\ntargets_and_drop = {\n    'target_carbon_monoxide': ['target_benzene', 'target_nitrogen_oxides'],\n    'target_benzene': ['target_carbon_monoxide', 'target_nitrogen_oxides'],\n    'target_nitrogen_oxides': ['target_carbon_monoxide', 'target_benzene']\n}","c12877c8":"def pb_add(X):\n    X['day'] = X.date_time.dt.weekday\n    is_odd = (X['sensor_4'] < 646) & (X['absolute_humidity'] < 0.238)\n    X['is_odd'] = is_odd\n    diff = X['date_time'] - min(X['date_time'])\n    trend = diff.dt.days\n    X['f1s'] = np.sin(trend * 2 * math.pi \/ (365 * 1)) \n    X['f1c'] = np.cos(trend * 2 * math.pi \/ (365 * 1))\n    X['f2s'] = np.sin(2 * math.pi * trend \/ (365 * 2)) \n    X['f2c'] = np.cos(2 * math.pi * trend \/ (365 * 2)) \n    X['f3s'] = np.sin(2 * math.pi * trend \/ (365 * 3)) \n    X['f3c'] = np.cos(2 * math.pi * trend \/ (365 * 3)) \n    X['f4s'] = np.sin(2 * math.pi * trend \/ (365 * 4)) \n    X['f4c'] = np.cos(2 * math.pi * trend \/ (365 * 4)) \n    X['fh1s'] = np.sin(diff.dt.seconds * 2 * math.pi \/ ( 3600 * 24 * 1))\n    X['fh1c'] = np.cos(diff.dt.seconds * 2 * math.pi \/ ( 3600 * 24 * 1))\n    X['fh2s'] = np.sin(diff.dt.seconds * 2 * math.pi \/ ( 3600 * 24 * 2))\n    X['fh2c'] = np.cos(diff.dt.seconds * 2 * math.pi \/ ( 3600 * 24 * 2))\n    X['fh3s'] = np.sin(diff.dt.seconds * 2 * math.pi \/ ( 3600 * 24 * 3))\n    X['fh3c'] = np.cos(diff.dt.seconds * 2 * math.pi \/ ( 3600 * 24 * 3))\n    \n    sensor_features = [\n        'deg_C', \n        'relative_humidity', 'absolute_humidity', \n        'sensor_1', 'sensor_2', 'sensor_3', 'sensor_4', 'sensor_5' ]\n    \n    lags = [-1, -4, -24, -7 * 24]  \n    for sensor_feature in sensor_features:\n        this = X[sensor_feature]\n\n        for lag in lags:\n            feature = f'{sensor_feature}_{abs(lag)}b'\n            this_f = X[sensor_feature].shift(lag)\n            X[feature] = (this_f - this).fillna(0)\n        # look forwards\n        for lag in lags:\n            feature = f'{sensor_feature}_{abs(-lag)}f'\n            this_f = X[sensor_feature].shift(-lag)\n            X[feature] = (this_f - this).fillna(0)\n            \n    return X","79d403f9":"all_data = pd.concat([train_data, test_data])\nall_data['date_time'] = pd.to_datetime(all_data['date_time'])\nmonths = all_data[\"date_time\"].dt.month[:len(train_data)]\n\nall_data[\"hour\"] = all_data[\"date_time\"].dt.hour\nall_data[\"working_hours\"] =  all_data[\"hour\"].isin(np.arange(8, 21, 1)).astype(\"int\")\nall_data[\"is_weekend\"] = (all_data[\"date_time\"].dt.dayofweek >= 5).astype(\"int\")\nall_data['hr'] = all_data.date_time.dt.hour*60+all_data.date_time.dt.minute\nall_data['satday'] = (all_data.date_time.dt.weekday==5).astype(\"int\")\nall_data[\"SMC\"] = (all_data[\"absolute_humidity\"] * 100) \/ all_data[\"relative_humidity\"]\nall_data.drop(columns = 'hour', inplace = True)\n\n\nall_data = pb_add(all_data.copy())\n\nall_data.drop(columns = 'date_time', inplace = True)","9474f07d":"train = all_data[:len(train_data)]\ntest = all_data[len(train_data):].drop(targets, axis = 1)","185943fa":"rand_states = [2021, 1998, 42, 123]","5093e28f":"print(f\"\\nTraining regressors for carbon monoxide\")\n\n['target_carbon_monoxide', 'target_benzene', 'target_nitrogen_oxides']\n\ntarget = 'target_carbon_monoxide'\n    \nyhat = np.zeros((sample_sub.shape[0],1))\n    \nfor rand in rand_states:\n    print(f\"\\nRandom state {rand} \")\n    seed_everything(rand)\n    \n    m_lgb = lgb.LGBMRegressor(seed = rand)\n    m_ctb = cbt.CatBoostRegressor(random_seed = rand, verbose=False)\n    m_hgbr =  HistGradientBoostingRegressor(random_state = rand)\n\n    stack = StackingCVRegressor(regressors=(m_lgb, m_ctb, m_hgbr), meta_regressor = BayesianRidge(normalize = True))\n\n    regressors = ['LightGBM', 'CatBoost', 'HistGradientBoostingRegressor', 'StackingCVRegressor']\n\n    for clf, label in zip([m_lgb, m_ctb, m_hgbr, stack], regressors):\n        \n        scores = cross_val_score(clf, train.drop(targets, axis = 1), train[target], cv = 3, scoring='neg_mean_squared_error')\n        print(\"  - Neg. MSE Score: %0.4f (+\/- %0.4f) [%s]\" % (scores.mean(), scores.std(), label))\n\n    stack.fit(train.drop(targets, axis = 1), train[target])\n        \n    yhat += np.expm1(stack.predict(test)).reshape(-1, 1)\n        \nsample_sub[target] = yhat \/ len(rand_states)","ea2b0d09":"print(f\"\\nTraining regressors for benzene\")\n\ntarget = 'target_benzene'\n    \nyhat = np.zeros((sample_sub.shape[0],1))\n    \nfor rand in rand_states:\n    print(f\"\\nRandom state {rand} \")\n    seed_everything(rand)\n    \n    m_lgb = lgb.LGBMRegressor(seed = rand)\n    m_ctb = cbt.CatBoostRegressor(random_seed = rand, verbose=False)\n    m_hgbr =  HistGradientBoostingRegressor(random_state = rand)\n\n    stack = StackingCVRegressor(regressors=(m_lgb, m_ctb, m_hgbr), meta_regressor = BayesianRidge(normalize = True))\n\n    regressors = ['LightGBM', 'CatBoost', 'HistGradientBoostingRegressor', 'StackingCVRegressor']\n\n    for clf, label in zip([m_lgb, m_ctb, m_hgbr, stack], regressors):\n        \n        scores = cross_val_score(clf, train.drop(targets, axis = 1), train[target], cv = 3, scoring='neg_mean_squared_error')\n        print(\"  - Neg. MSE Score: %0.4f (+\/- %0.4f) [%s]\" % (scores.mean(), scores.std(), label))\n\n    stack.fit(train.drop(targets, axis = 1), train[target])\n        \n    yhat += np.expm1(stack.predict(test)).reshape(-1, 1)\n        \nsample_sub[target] = yhat \/ len(rand_states)","7c81ef31":"print(f\"\\nTraining regressors for nitrogen oxides\")\n\ntarget = 'target_nitrogen_oxides'\n    \nyhat = np.zeros((sample_sub.shape[0],1))\n    \nfor rand in rand_states:\n    print(f\"\\nRandom state {rand} \")\n    seed_everything(rand)\n    \n    m_lgb = lgb.LGBMRegressor(seed = rand)\n    m_ctb = cbt.CatBoostRegressor(random_seed = rand, verbose=False)\n    m_hgbr =  HistGradientBoostingRegressor(random_state = rand)\n\n    stack = StackingCVRegressor(regressors=(m_lgb, m_ctb, m_hgbr), meta_regressor = BayesianRidge(normalize = True))\n\n    regressors = ['LightGBM', 'CatBoost', 'HistGradientBoostingRegressor', 'StackingCVRegressor']\n\n    for clf, label in zip([m_lgb, m_ctb, m_hgbr, stack], regressors):\n        \n        scores = cross_val_score(clf, train.drop(targets, axis = 1), train[target], cv = 3, scoring='neg_mean_squared_error')\n        print(\"  - Neg. MSE Score: %0.4f (+\/- %0.4f) [%s]\" % (scores.mean(), scores.std(), label))\n\n    stack.fit(train.drop(targets, axis = 1), train[target])\n        \n    yhat += np.expm1(stack.predict(test)).reshape(-1, 1)\n        \nsample_sub[target] = yhat \/ len(rand_states)","1bc4e710":"sample_sub.to_csv(\"tps-ens-meta-010.csv\", index = False)\nsample_sub.head(10)","65d664d3":"### DATA SPLIT\n___","1389ef3d":"## ENSEMBLE STACKING META-REGRESSOR\n\n<div align = 'center'> <img src =\"http:\/\/rasbt.github.io\/mlxtend\/user_guide\/regressor\/StackingRegressor_files\/stackingregression_overview.png\"\/><\/div>\n\n---","3fd2fdf7":"## MODEL LEARNING\n\nI decided to split models (even code now is almost the same). Soon will be different for each targets. I will optimize model for each target.","f85adceb":"#### Nitrogen oxides\n___","8adbef46":"### DATA PREPARATION\n___","56127413":"### NEW FEATURES\n___","7f179c33":"### ENSEMBLE STACKING META-REGRESSOR\n___","f54227ed":"### SUBMISSION\n___","65bb43ba":"#### Benzene\n___","a338c6aa":"#### Carbon monoxide\n___"}}