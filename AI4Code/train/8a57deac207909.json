{"cell_type":{"e305c307":"code","48ad1a5e":"code","f2495e70":"code","11f89117":"code","fa6737b2":"code","2e72818c":"code","f1417428":"code","332c9b2c":"code","c8d67c6d":"code","caa11d56":"code","40e96535":"code","2fb75552":"code","adc170a5":"code","dbb21e4b":"code","5065a3e5":"code","a01d9d2c":"code","373cfceb":"code","309a189e":"code","cf100d7f":"code","019847e5":"code","c59441e6":"code","a4a0cac1":"code","f72192e8":"code","9543d917":"code","1787ecea":"code","0b741604":"code","ff09f004":"code","f1d80752":"code","e305f453":"code","253246cf":"code","511b097f":"code","197b3e27":"code","439d70b2":"code","5222b183":"code","02068970":"code","40ecdc14":"code","7fe36f64":"code","aa2394e4":"code","f0135ff2":"markdown","d958750d":"markdown","af08b57a":"markdown","8b03b310":"markdown","7c12fdab":"markdown","6c670c9a":"markdown","e10ee5ea":"markdown","7d889062":"markdown","b86a2e9d":"markdown","070cf6c2":"markdown","0a61c958":"markdown","575a5ea8":"markdown","5b64f265":"markdown","75a5aac1":"markdown","67fad28d":"markdown","90d1bfd8":"markdown","5f8dfe5c":"markdown","946bf4c6":"markdown","22022977":"markdown","c219dce5":"markdown","ac13472b":"markdown","129fb412":"markdown","7163b526":"markdown","55320ec3":"markdown","5c94d736":"markdown","3835f883":"markdown","721c7f44":"markdown","7b1306bc":"markdown","ccd287c0":"markdown","c993da49":"markdown","62839b7c":"markdown","3178f096":"markdown","62da070b":"markdown","dc0787fe":"markdown","1f281dea":"markdown","a7772158":"markdown","3dfd803e":"markdown","340e30a1":"markdown","5e0c8dfe":"markdown","0636d99b":"markdown","31ef89e7":"markdown","acd4d66c":"markdown","7cb6adb8":"markdown","e6b3110c":"markdown","fe23e795":"markdown","5eed904f":"markdown"},"source":{"e305c307":"import os\nimport numpy as np\nimport pandas as pd\nimport torch\nimport cv2\nimport collections\nimport albumentations as albu\nimport torch\nimport torchvision\nimport seaborn as sns\n\nfrom torchvision.models.detection.faster_rcnn import FastRCNNPredictor\nfrom torchvision.models.detection.mask_rcnn import MaskRCNNPredictor\nfrom torch.utils.data import DataLoader\nfrom sklearn.model_selection import train_test_split\nfrom glob import glob\nfrom os import path\nfrom PIL import Image\nfrom tqdm import tqdm\nfrom matplotlib import pyplot as plt\n\n%matplotlib inline","48ad1a5e":"ROOT_PATH_TRAIN = '\/kaggle\/input\/imaterialist-fashion-2019-FGVC6\/train'\nDF_PATH_TRAIN = '\/kaggle\/input\/imaterialist-fashion-2019-FGVC6\/train.csv'\nPATH_TO_MODEL_WEIGHTS = '\/kaggle\/input\/best-maskrcnn\/best_model.pth'\n\nIMAGE_SIZE = (512, 512)\nIAMGE_PREDICTION_SIZE = (256, 256)\n\nDEVICE='cuda'","f2495e70":"def rle_decode(mask_rle, shape):\n    '''\n    mask_rle: run-length as string formated: [start0] [length0] [start1] [length1]... in 1d array\n    shape: (height,width) of array to return\n    Returns numpy array according to the shape, 1 - mask, 0 - background\n    '''\n    shape = (shape[1], shape[0])\n    s = mask_rle.split()\n    # gets starts & lengths 1d arrays\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0::2], s[1::2])]\n    starts -= 1\n    # gets ends 1d array\n    ends = starts + lengths\n    # creates blank mask image 1d array\n    img = np.zeros(shape[0] * shape[1], dtype=np.uint8)\n    # sets mark pixles\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    # reshape as a 2d mask image\n    return img.reshape(shape).T","11f89117":"def rle_to_string(runs):\n    return ' '.join(str(x) for x in runs)\n\ndef rle_encode(mask):\n    pixels = mask.T.flatten()\n    # We need to allow for cases where there is a '1' at either end of the sequence.\n    # We do this by padding with a zero at each end when needed.\n    use_padding = False\n    if pixels[0] or pixels[-1]:\n        use_padding = True\n        pixel_padded = np.zeros([len(pixels) + 2], dtype=pixels.dtype)\n        pixel_padded[1:-1] = pixels\n        pixels = pixel_padded\n    rle = np.where(pixels[1:] != pixels[:-1])[0] + 2\n    if use_padding:\n        rle = rle - 1\n    rle[1::2] = rle[1::2] - rle[:-1:2]\n    return rle_to_string(rle)","fa6737b2":"def visualise_masks(image_name, real_df, predicted_df=None, r_p=ROOT_PATH_TRAIN, im_class=None):\n    # get image\n    img_path = os.path.join(r_p, image_name)\n    img = cv2.imread(img_path)\n    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)\n    img = cv2.resize(img, IMAGE_SIZE)\n    \n    # get original mask\n    if im_class is not None:\n        original_raws = real_df[(real_df['ImageId'] == image_name) & (real_df['ClassId'] == im_class)]\n    else:\n        original_raws = real_df[real_df['ImageId'] == image_name]\n                \n    o_h, o_w = int(original_raws['Height'].mean()), int(original_raws['Width'].mean())\n    \n    o_mask = np.zeros(IMAGE_SIZE)        \n        \n    for annotation in original_raws['EncodedPixels']:\n        o_mask += cv2.resize(rle_decode(annotation, (o_h, o_w)), IMAGE_SIZE)\n        \n    o_mask = (o_mask > 0.5).astype(np.uint8)\n    \n    if predicted_df is not None:\n        # get predicted mask\n        if im_class is not None:\n            predicted_raws = predicted_df[(predicted_df['ImageId'] == image_name) & (predicted_df['ClassId'] == im_class)]\n        else:\n            predicted_raws = predicted_df[predicted_df['ImageId'] == image_name]\n                \n        p_mask = np.zeros(IMAGE_SIZE)\n        \n        for annotation in predicted_raws['EncodedPixels']:\n            p_mask += rle_decode(annotation, IMAGE_SIZE)\n        \n        p_mask = (p_mask > 0.5).astype(np.uint8)\n    \n    fig=plt.figure(figsize=(20, 20))\n    fig.add_subplot(1, 3, 1)\n    plt.title('image')\n    plt.imshow(img)\n    fig.add_subplot(1, 3, 2)\n    plt.title('original_mask')\n    plt.imshow(o_mask)\n    \n    if predicted_df is not None:\n        fig.add_subplot(1, 3, 3)\n        plt.title('predicted_mask')\n        plt.imshow(p_mask)\n        plt.show()","2e72818c":"train_df = pd.read_csv(DF_PATH_TRAIN)\ntrain_df.head()","f1417428":"train_df['CategoryId'] = train_df.ClassId.apply(lambda x: str(x).split(\"_\")[0])","332c9b2c":"plt.figure(figsize=(20, 7))\nsns.countplot(train_df['CategoryId']);","c8d67c6d":"train_df[train_df['ImageId'] == '00000663ed1ff0c4e0132b9b9ac53f6e.jpg']","caa11d56":"visualise_masks('00000663ed1ff0c4e0132b9b9ac53f6e.jpg', train_df, im_class='31')","40e96535":"def get_unique_class_id_df(inital_df):\n    temp_df = inital_df.groupby(['ImageId','ClassId'])['EncodedPixels'].agg(lambda x: ' '.join(list(x))).reset_index()\n    size_df = inital_df.groupby(['ImageId','ClassId'])['Height', 'Width'].mean().reset_index()\n    temp_df = temp_df.merge(size_df, on=['ImageId','ClassId'], how='left')\n    \n    return temp_df","2fb75552":"train_df = get_unique_class_id_df(train_df)","adc170a5":"train_df[train_df['ImageId'] == '00000663ed1ff0c4e0132b9b9ac53f6e.jpg']","dbb21e4b":"visualise_masks('00000663ed1ff0c4e0132b9b9ac53f6e.jpg', train_df, im_class='31')","5065a3e5":"def create_one_represent_class(df_param):\n    v_c_df = df_param['CategoryId'].value_counts().reset_index()\n    one_represent = v_c_df.loc[v_c_df['CategoryId'] == 1, 'index'].tolist()\n    df_param.loc[df_param['CategoryId'].isin(one_represent), 'CategoryId'] = 'one_represent'\n    return df_param\n\ndef custom_train_test_split(df_param):\n    \n    df_param['CategoryId'] = df_param.ClassId.apply(lambda x: str(x).split(\"_\")[0])\n    \n    img_categ = train_df.groupby('ImageId')['CategoryId'].apply(list).reset_index()\n    img_categ['CategoryId'] = img_categ['CategoryId'].apply(lambda x: ' '.join(sorted(x)))\n    \n    img_categ = create_one_represent_class(img_categ)\n    \n    img_train, img_val  = train_test_split(img_categ, test_size=0.2, random_state=42, stratify=img_categ['CategoryId'])\n    \n    df_param = df_param.drop(columns='CategoryId')\n    \n    df_train = df_param[df_param['ImageId'].isin(img_train['ImageId'])].reset_index(drop=True)\n    df_val = df_param[df_param['ImageId'].isin(img_val['ImageId'])].reset_index(drop=True)\n    \n    return df_train, df_val","a01d9d2c":"train_df = pd.read_csv(DF_PATH_TRAIN)\ntrain_df, val_df = custom_train_test_split(train_df)\n\ntrain_df = get_unique_class_id_df(train_df)\nval_df = get_unique_class_id_df(val_df)","373cfceb":"plt.figure(figsize=(20, 7))\nplt.title('Train')\nsns.countplot(train_df['ClassId'].apply(lambda x: str(x).split(\"_\")[0]));","309a189e":"plt.figure(figsize=(20, 7))\nplt.title('Validation')\nsns.countplot(val_df['ClassId'].apply(lambda x: str(x).split(\"_\")[0]));","cf100d7f":"class MaskRCNNDataset(torch.utils.data.Dataset):\n    def __init__(self, image_dir, df, height, width, augmentation=None, preprocessing=None):\n        \n        self.preprocessing = preprocessing\n        self.augmentation = augmentation\n        \n        self.image_dir = image_dir\n        self.df = df\n        \n        self.height = height\n        self.width = width\n        \n        self.image_info = []\n        \n        self.df['CategoryId'] = self.df.ClassId.apply(lambda x: str(x).split(\"_\")[0])\n        self.num_classes = self.df['CategoryId'].nunique()\n        \n        temp_df = self.df.groupby('ImageId')['EncodedPixels', 'CategoryId'].agg(lambda x: list(x)).reset_index()\n        size_df = self.df.groupby('ImageId')['Height', 'Width'].mean().reset_index()\n        temp_df = temp_df.merge(size_df, on='ImageId', how='left')\n        \n        for index, row in tqdm(temp_df.iterrows(), total=len(temp_df)):\n            image_id = row['ImageId']\n            image_path = os.path.join(self.image_dir, image_id)\n            cur_dict = {}\n            cur_dict[\"image_id\"] = image_id\n            cur_dict[\"image_path\"] = image_path\n            cur_dict[\"width\"] = self.width\n            cur_dict[\"height\"] = self.height\n            cur_dict[\"labels\"] = row[\"CategoryId\"]\n            cur_dict[\"orig_height\"] = row[\"Height\"]\n            cur_dict[\"orig_width\"] = row[\"Width\"]\n            cur_dict[\"annotations\"] = row[\"EncodedPixels\"]\n            \n            self.image_info.append(cur_dict)\n            \n        self.img2tensor = torchvision.transforms.ToTensor()\n\n    def __getitem__(self, idx):\n        \n        img_path = self.image_info[idx][\"image_path\"]\n        \n        img = Image.open(img_path).convert(\"RGB\")\n        img = img.resize((self.width, self.height), resample=Image.BILINEAR)\n        \n        img = self.img2tensor(img)\n            \n        return img, os.path.basename(img_path)\n\n    def __len__(self):\n        return len(self.image_info)","019847e5":"num_classes = 46 + 1\ndevice = torch.device(DEVICE)\n\nmodel_ft = torchvision.models.detection.maskrcnn_resnet50_fpn(pretrained=True)\nin_features = model_ft.roi_heads.box_predictor.cls_score.in_features\nmodel_ft.roi_heads.box_predictor = FastRCNNPredictor(in_features, num_classes)\nin_features_mask = model_ft.roi_heads.mask_predictor.conv5_mask.in_channels\nhidden_layer = 256\nmodel_ft.roi_heads.mask_predictor = MaskRCNNPredictor(in_features_mask, hidden_layer, num_classes)","c59441e6":"model_ft.load_state_dict(torch.load(PATH_TO_MODEL_WEIGHTS, \n                                 map_location=torch.device(DEVICE)))","a4a0cac1":"model_ft = model_ft.to(DEVICE)\nmodel_ft.eval();","f72192e8":"test_dataset = MaskRCNNDataset(\n    ROOT_PATH_TRAIN,\n    val_df,\n    IAMGE_PREDICTION_SIZE[0],\n    IAMGE_PREDICTION_SIZE[0], \n)","9543d917":"def create_final_df(result_dict):\n    final_df = {'ImageId':[], 'EncodedPixels':[], 'ClassId':[]}\n    for im_name, im_dict in result_dict.items():\n        final_df['ImageId'] += [im_name]*len(im_dict)\n        for cls_id, enc_p in im_dict.items():\n            final_df['EncodedPixels'].append(enc_p)\n            final_df['ClassId'].append(cls_id)\n            \n    return pd.DataFrame(final_df)\n\nclass InfernceModel(object):\n    def __init__(self, nn_model, device, output_size=(512,512), threshold=0.5, size_min_mask=250):\n        self.nn_model = nn_model\n        self.output_size = output_size\n        self.threshold = threshold\n        self.size_min_mask = size_min_mask\n        self.device = device\n        \n    def __call__(self, inf_dataset):\n        result = {}\n        with torch.no_grad():\n            for batch in tqdm(inf_dataset):\n                name = batch[1]\n                batch = self.nn_model([batch[0].to(self.device)])[0]\n                result[name] = self.post_process(batch['masks'].cpu().numpy(), \n                                                 batch['labels'].cpu().numpy(), \n                                                 batch['scores'].cpu().numpy())\n                        \n        final_df = create_final_df(result) \n        final_df['Height'] = self.output_size[0]\n        final_df['Width'] = self.output_size[1]\n        final_df['ClassId'] = final_df['ClassId'].astype(str)\n                    \n        return final_df\n        \n    def post_process(self, masks, labels, scores):\n        labels -= 1\n        \n        rle_mask = {}\n        if scores.max() < 0.5:\n            cur_idx = scores.argmax()\n            \n            item_mask = (masks[cur_idx][0] > self.threshold).astype(np.uint8)\n            item_mask = cv2.resize(item_mask, self.output_size)\n            \n            if item_mask.sum() >= self.size_min_mask:\n                rle_mask[str(labels[cur_idx])] = rle_encode(item_mask)\n            \n        else:\n            \n            good_masks = masks[scores > 0.5]\n            good_labels = labels[scores > 0.5]\n        \n            for m,l in zip(masks, labels):\n\n                item_mask = (m[0] > self.threshold).astype(np.uint8)\n                item_mask = cv2.resize(item_mask, self.output_size)\n\n                if item_mask.sum() < self.size_min_mask:\n                    continue\n                else:\n                    rle_mask[str(l)] = rle_encode(item_mask)\n            \n        return rle_mask","1787ecea":"inf_model = InfernceModel(nn_model=model_ft, device=DEVICE)","0b741604":"predicted_df = inf_model(test_dataset)","ff09f004":"predicted_df.head()","f1d80752":"plt.figure(figsize=(20, 7))\nplt.title('Prediction')\nsns.countplot(predicted_df['ClassId']);","e305f453":"visualise_masks('000b3a87508b0fa185fbd53ecbe2e4c6.jpg', val_df, predicted_df)","253246cf":"visualise_masks('fffc631acce2e28e1628de685d40c980.jpg', val_df, predicted_df)","511b097f":"visualise_masks('ffec8295f37df6ea12eecbb60d2c23d4.jpg', val_df, predicted_df)","197b3e27":"visualise_masks('001039acb67251508b1b32fd37a49f43.jpg', val_df, predicted_df, im_class='31')","439d70b2":"visualise_masks('005ccdb239e2d6cfe62506dd6eb5693e.jpg', val_df, predicted_df, im_class='10')","5222b183":"visualise_masks('000cd2e13d1bdd28f480304d7bb9e1ca.jpg', val_df, predicted_df, im_class='23')","02068970":"visualise_masks('05e6ef19957d43524d972de6d2f41b57.jpg', val_df, predicted_df, im_class='45')","40ecdc14":"# mainly from here https:\/\/www.kaggle.com\/kyazuki\/calculate-evaluation-score\n\ndef IoU(A,B):\n    AorB = np.logical_or(A,B).astype('int')\n    AandB = np.logical_and(A,B).astype('int')\n    IoU = AandB.sum() \/ AorB.sum()\n    return IoU\n\ndef IoU_threshold(data):\n    # Note: This rle_to_mask should be called before loop below for speed-up! We currently implement here to reduse memory usage.\n    mask_gt = rle_decode(data['EncodedPixels_true'], (int(data['Height_true']), int(data['Width_true'])))\n    mask_pred = rle_decode(data['EncodedPixels_pred'], (int(data['Height_pred']), int(data['Width_pred'])))\\\n    \n    if (int(data['Height_true']), int(data['Width_true'])) != IMAGE_SIZE:\n        mask_gt = cv2.resize(mask_gt, IMAGE_SIZE)\n    if (int(data['Height_pred']), int(data['Width_pred'])) != IMAGE_SIZE:\n        mask_pred = cv2.resize(mask_pred, IMAGE_SIZE)\n    \n    mask_gt = mask_gt > 0.5\n    mask_pred = mask_pred > 0.5\n    \n    return IoU(mask_gt, mask_pred)\n\ndef best_metric(true_df, pred_df):\n    eval_df = pd.merge(true_df, pred_df, how='outer', on=['ImageId', 'ClassId'], suffixes=['_true', '_pred'])\n\n    # IoU for True Positive\n    idx_ = eval_df['EncodedPixels_true'].notnull() & eval_df['EncodedPixels_pred'].notnull()\n    IoU = eval_df[idx_].apply(IoU_threshold, axis=1)\n\n    # False Positive\n    fp = (eval_df['EncodedPixels_true'].isnull() & eval_df['EncodedPixels_pred'].notnull()).sum()\n\n    # False Negative\n    fn = (eval_df['EncodedPixels_true'].notnull() & eval_df['EncodedPixels_pred'].isnull()).sum()\n\n    threshold_IoU = np.arange(0.5, 1.0, 0.05)\n    scores = []\n    for th in threshold_IoU:\n        # True Positive\n        tp = (IoU > th).sum()\n        iou_fp = (IoU <= th).sum()\n\n        # False Positive (not Ground Truth) + False Positive (under IoU threshold)\n        fp = fp + iou_fp\n\n        # Calculate evaluation score\n        score = tp \/ (tp + fp + fn)\n        scores.append(score)\n\n    mean_score = sum(scores) \/ len(threshold_IoU)\n    return mean_score","7fe36f64":"images_to_count_metric = val_df['ImageId'].unique()[:100]\n\nbest_metric(val_df[val_df['ImageId'].isin(images_to_count_metric)], val_df[val_df['ImageId'].isin(images_to_count_metric)])","aa2394e4":"best_metric(val_df, predicted_df)","f0135ff2":"And now evaluate our prediction","d958750d":"Why we did not do all this stuff\n\nBecause\n\n* 30 hours per week of railway\n* one GPU per account\n* execution - up to 6 hours","af08b57a":"EVERYTHING","8b03b310":"Firstly, on some frequent","7c12fdab":"So lets fix it","6c670c9a":"# Starting points","e10ee5ea":"# Imports","7d889062":"## Model","b86a2e9d":"Lets test it","070cf6c2":"### Metric","0a61c958":"Now lets look at different CategoryID","575a5ea8":"Awesome matching !!!","5b64f265":"# Data exploration","75a5aac1":"# Train\/Test split","67fad28d":"In our Classid we have Category id and it's attributes. Predicting attributes is a really hard stuff and competion best practises showed that in most cases it will only harm the perfomence of your Neural Net. So we will lets get Category id","90d1bfd8":"* Use MaskRCNN or other appropriate architecture for biag amount of classes\n* Use bigger backbone\n* Train until Net converged\n* Use bigger augmentations\n* Tune net hyperparams\n* Use TwoHead Net\n* Use Test Time Augmentations\n* Use Blending\n\nAnd so on ....","5f8dfe5c":"Lets take a look on our categoryid distribution","946bf4c6":"Of course, it is better to have train\/validation\/test datasets. But now we will stop on train\/test. Why?\n* We do not have Early Stopping and other stuff, that will overfit us\n* Orgs did not clarify this point properly ","22022977":"We have images with different cloth parts and we have to identify cloth id and attributes","c219dce5":"# Dataloader","ac13472b":"## Evaluate results","129fb412":"Got it. Also these masks are huge enough for our week net","7163b526":"# Power Rangers Solution","55320ec3":"# Final thoughts or kozaki pishut pismo BESTu","5c94d736":"Moreover in our dataframe we have to have unique pair (ImageId, ClassId) but in our initial dataframe we have each pair for each mask segment.\nIn the following example we have duplicates with ClassId - 31, 32","3835f883":"Firstly, on all classes together","721c7f44":"![](https:\/\/zaxid.net\/resources\/photos\/news\/640x360_DIR\/201511\/1371769.jpg?201805281755)","7b1306bc":"## What can be improved","ccd287c0":"# DL part","c993da49":"![](https:\/\/pbs.twimg.com\/media\/CnN1pRvUAAA0lWq.jpg)","62839b7c":"So we get some main cloth parts","3178f096":"But as for smaller masks and less frequent","62da070b":"### Visualize","dc0787fe":"# Utils fucntions","1f281dea":"# Constants","a7772158":"## Dataset","3dfd803e":"We have trained our Net only for 2 epochs (Kaggle Kernel limitation on time)\n* With Dice Loss\n* With Horizontal and Vertical flip augmentations\n* With Adam optimizer\n* Data was normalized by ImageNet stats","340e30a1":"# Inference","5e0c8dfe":"So now we are ready for DEEEEEEEEEEEEEEEEEEEEEEEEEEEEEep Learning","0636d99b":"We will use classical Unet architecture with mobilenet backbone, pretrained on ImageNet. Why ?\n* Unet is classic\n* Backbone is light enough to train it in Kaggle Kernel","31ef89e7":"We will make train\/test split on Classid combinations ","acd4d66c":"![](http:\/\/static.issue.life\/Content\/img\/17-03-2019\/636884100747932656.png)","7cb6adb8":"![Unet](https:\/\/i.stack.imgur.com\/DjXVU.png)","e6b3110c":"We think that such format of test task is one of the worst variants. Why ?\n* This task requires Deep Learning background, which is overkill for contest, where most participants are students \n* Even if participant has Deep Learning background, he\/she will need a lot of computational resources (GPUs), which cost money or use his\/her GPU Quota on Kaggle\n* Metric and Train\/Test were not provided. So all participants will have hardly biased results. It is important, because evaluating DL\/ML\/DS tasks by 'beautiful code' or 'interesting approach' or something like this is not the best practice. Of course, these criteria should be taken into account, but main criteria is target metric !","fe23e795":"Not very good results for these masks","5eed904f":"We will use classical deep learning approach. We will use this [awesome framework](https:\/\/github.com\/qubvel\/segmentation_models.pytorch)"}}