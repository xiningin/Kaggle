{"cell_type":{"7c30f3c5":"code","3cca20cf":"code","8f4e800a":"code","955f1da6":"code","ddfef9b0":"code","b95ccfa4":"code","7ffd1b32":"code","f65f3e0c":"code","c58fa1fa":"code","96e67712":"code","236db305":"code","55441bae":"code","4b2bd801":"code","ec943c85":"code","f9fd62e1":"code","62458179":"code","83c85279":"code","68cbc5d4":"code","f4954798":"markdown","bbbdb021":"markdown","ed63b810":"markdown","f6f6b56f":"markdown","9ff6356c":"markdown","502b9ed7":"markdown","16b4c866":"markdown","f197caa1":"markdown","a1e54c5c":"markdown","c38239cf":"markdown","56eed6b1":"markdown"},"source":{"7c30f3c5":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt","3cca20cf":"df = pd.read_csv('\/kaggle\/input\/2020-russian-constitutional-referendum\/ru_vote_2020.csv')\ndf['turnout'] = df['given']\/np.maximum(1, df['nominal'])\ndf['support'] = df['yes']\/np.maximum(1, df['given'])\ndf.head()","8f4e800a":"limits = [0.2, 0.4]\nf = plt.figure(figsize=(10,10), facecolor='white')\ngs = f.add_gridspec(6, 6)\n\nax = f.add_subplot(gs[0, :-1])\nx = np.histogram(df['turnout'].values, bins=1000, range=(0,1))\nax.plot(x[1][:-2], x[0][:-1]); # Very last bin is full of 100% for tiny polling points\nax.axis('off')\nplt.xlim(limits[0], 1)\n\nax = f.add_subplot(gs[1:, -1])\nx = np.histogram(df['support'].values, bins=1000, range=(0,1))\nax.plot(x[0][:], x[1][:-1]); # Very last bin is full of 100% for tiny polling points\nax.axis('off')\nplt.ylim(limits[1], 1)\n\nax = f.add_subplot(gs[1:, :-1])\nax.plot(df['turnout'], df['support'], '.', markersize=1, alpha=0.2)\nplt.xlabel('Turnout')\nplt.ylabel('Share of pro-Party votes')\nplt.xlim(limits[0], 1)\nplt.ylim(limits[1], 1)","955f1da6":"def latinize(s):\n    \"\"\"Latinsca\"\"\"\n    a1 = '\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044d\u044e\u044f\u044c\u044a\u044b\u0439'\n    a2 = \"a b v g d e zh z i k l m n o p r s t u f h ts ch sh sch e yu ya ' ' y y\"\n    a1 = a1 + a1.upper()\n    a2 = a2 + ' ' + a2.upper()\n    a2 = a2.split(' ')\n    t = {a1[i]: a2[i] for i in range(len(a1))}\n    return ''.join([t[c] if c in t else c for c in s])","ddfef9b0":"# Distributions by region\nregions = np.unique(df['region'].values)\nif False: # If we want to sort them by party support\n    dfsum = df.groupby('region').agg({'turnout': [np.mean]})\n    ind = np.argsort(dfsum.iloc[:,0].values) # Indices from lowest mean turnout to highest\n    regions = regions[ind]\n\nplt.figure(figsize=(20,22))\nfor i in range(len(regions)):\n    region = regions[i]\n    x = np.histogram(df['turnout'][df['region']==region].values, bins=200, range=(0,1))\n    plt.subplot(10, 10, i+1)\n    plt.plot(x[1][:-2], x[0][:-1]\/np.max(x[0][:-1]))\n    plt.xticks([])\n    plt.yticks([])\n    plt.xlim(0.1)\n    plt.title(latinize(region))","b95ccfa4":"regions = ['\u041c\u043e\u0441\u043a\u0432\u0430', '\u0421\u0430\u043d\u043a\u0442-\u041f\u0435\u0442\u0435\u0440\u0431\u0443\u0440\u0433']\n\ncategory = 'support'\n\nplt.figure(figsize=(6.5, 6), facecolor='white')\nax = plt.subplot(111)\nfor region_name in regions:\n    df1 = df[:][df.region == region_name]        \n    x = np.histogram(df1[category].values, bins=300, range=(0,1))\n    plt.plot(x[1][:-1], x[0]\/np.sum(x[0]), label=latinize(region_name))\n    ax.set_xticks(np.arange(0,1.1,0.1))\n    ax.set_xticks(np.arange(0,1,0.05), minor=True)\n    plt.grid(which='minor', alpha=0.2)\n    plt.grid(which='major', alpha=0.5)\n    if category=='support':\n        plt.xlabel('Pro-Party support')\n    else:\n        plt.xlabel('Turnout')\n    plt.ylabel('Frequency')\n\nplt.xlim(0.4, 0.99)\nplt.legend(loc='upper left')","7ffd1b32":"# Selected regions only\n\nregions = ['\u0422\u0430\u0442\u0430\u0440\u0441\u0442\u0430\u043d', '\u0427\u0435\u0447\u0435\u043d\u0441\u043a\u0430\u044f']\n\nlimits = [0.2, 0.4]\nf = plt.figure(figsize=(12,5.5), facecolor='white')\n\nfor i in range(len(regions)):\n    plt.subplot(1,len(regions),i+1)\n    region = regions[i]\n    ind = (df.region == region)\n    plt.plot(df.turnout, df.support, '.', markersize=1, color='gray', alpha=0.1)\n    plt.plot(df[ind].turnout, df[ind].support, '.', markersize=1, color='blue', alpha=0.5)\n    plt.xlabel('Turnout')\n    plt.ylabel('Share of pro-Party votes')\n    plt.xlim(limits[0], 1)\n    plt.ylim(limits[1], 1)\n    plt.title(latinize(region))","f65f3e0c":"# An index of how peculiar this number is. Anti-peculiar numbers are slightly. Most peculiar are ==1 \ndef find_funny(df):\n    df['funny_turnout'] = (np.floor(np.ceil(df['given'].values\/df['nominal']*100)\/100\n                                    *df['nominal'])==df['given'])*1\n    df['funny_support'] = (np.floor(np.ceil(df['yes'].values\/df['given']*100)\/100*\n                                    df['given'])==df['yes'])*1\n    return df\n\ndf = find_funny(df)\ndf.loc[np.logical_and(df['funny_support']==1, df['received']>200)]","c58fa1fa":"# Estimate the prevalence of weird numbers\ndfsum = df.groupby('region').agg({'funny_support': [np.mean], \n                                  'funny_turnout': [np.mean],\n                                  'support': [np.mean]})\ndfsum.columns = ['fun_support', 'fun_turnout', 'support']\ndfsum['base_fun_support'] = 0\ndfsum['base_fun_turnout'] = 0\n\nnexp = 100\nsigma = 0.005 # Noisification coefficient\nfor iexp in range(nexp):\n    temp = df.copy()\n    temp['given'] = np.round(temp['nominal']*(temp['turnout']+np.random.normal(size=len(df))*sigma))\n    temp['given'] = np.maximum(0, np.minimum(temp['nominal'], temp['given'])).astype(int)\n    temp['yes'] = np.round(temp['given']*(temp['turnout']+np.random.normal(size=len(df))*sigma))\n    temp['yes'] = np.maximum(0, np.minimum(temp['given'], temp['yes'])).astype(int)\n    temp = find_funny(temp)\n    tempsum = temp.groupby('region').agg({'funny_support': [np.mean], \n                                          'funny_turnout': [np.mean]})\n    dfsum['base_fun_turnout'] = dfsum['base_fun_turnout'] + tempsum[('funny_turnout','mean')]\/nexp    \n    dfsum['base_fun_support'] = dfsum['base_fun_support'] + tempsum[('funny_support','mean')]\/nexp\n\nplt.figure(figsize=(13,4))\nplt.subplot(131)\nplt.plot(dfsum['fun_turnout']-dfsum['base_fun_turnout'], dfsum['fun_support']-dfsum['base_fun_support'], '.')\nplt.xlabel('Round %% in turnout')\nplt.ylabel('Round %% in support')\nplt.subplot(132)\nplt.plot(dfsum['fun_turnout']-dfsum['base_fun_turnout'], dfsum['support'], '.')\nplt.xlabel('Round %% in turnout')\nplt.ylabel('Party support')\nplt.subplot(133)\nplt.plot(dfsum['fun_support']-dfsum['base_fun_support'], dfsum['support'], '.')\nplt.xlabel('Round %% in support')\nplt.ylabel('Party support')","96e67712":"dfsum['weirdness'] = (dfsum.fun_support-dfsum.base_fun_support + dfsum.fun_turnout - dfsum.base_fun_turnout)\/2\n\nplt.figure(figsize=(6, 6), facecolor='white')\nplt.plot(dfsum.weirdness, dfsum.support, '.');\nplt.xlabel('Lucky numbers (both turnout and support) that yield a round %% number');\nplt.ylabel('Pro-party support');\nlabel_these = ['\u0422\u044b\u0432\u0430', '\u0427\u0435\u0447\u0435\u043d\u0441\u043a\u0430\u044f', '\u0411\u0430\u0448\u043a\u043e\u0440\u0442\u043e\u0441\u0442\u0430\u043d', '\u041a\u0440\u0430\u0441\u043d\u043e\u0434\u0430\u0440\u0441\u043a\u0438\u0439', '\u0422\u0430\u0442\u0430\u0440\u0441\u0442\u0430\u043d', \n               '\u0414\u0430\u0433\u0435\u0441\u0442\u0430\u043d', '\u041a\u0440\u044b\u043c', '\u041c\u043e\u0441\u043a\u0432\u0430', '\u041b\u0438\u043f\u0435\u0446\u043a\u0430\u044f', '\u0421\u0442\u0430\u0432\u0440\u043e\u043f\u043e\u043b\u044c\u0441\u043a\u0438\u0439']\nplt.vlines(0, 0, 1, alpha=0.4)\nplt.ylim(0.4, 1)\nfor i in range(len(dfsum)):\n    if dfsum.index.tolist()[i] in label_these:\n        plt.text(dfsum.weirdness[i], dfsum.support[i], \n                  latinize(dfsum.index.tolist()[i]))","236db305":"# One region of interest\n\ndf1 = df[:][df.region == '\u041a\u0440\u0430\u0441\u043d\u043e\u0434\u0430\u0440\u0441\u043a\u0438\u0439']\nplt.figure(figsize=(12, 6))\nax = plt.subplot(111)\nx = np.histogram(df1['turnout'].values, bins=300, range=(0,1))\nplt.plot(x[1][:-1], x[0])\nax.set_xticks(np.arange(0,1.1,0.1))\nax.set_xticks(np.arange(0,1,0.05), minor=True)\nplt.grid(which='minor', alpha=0.5)\nplt.grid(which='major', alpha=1)","55441bae":"# Noisificator from a diff notebook, not yet functional\n\ndef noisify(df1):\n    nexp = 1\n    sigma = 0.005 # Noisification coefficient\n    temp = df1.copy()\n    temp['given'] = np.round(temp['nominal']*(temp['turnout']+np.random.normal(size=len(temp))*sigma))\n    temp['given'] = np.maximum(0, np.minimum(temp['nominal'], temp['given'])).astype(int)\n    temp['yes'] = np.round(temp['given']*(temp['turnout']+np.random.normal(size=len(temp))*sigma))\n    temp['yes'] = np.maximum(0, np.minimum(temp['given'], temp['yes'])).astype(int)\n    temp['turnout'] = temp.given \/ temp.nominal\n    temp['support'] = temp.yes \/ temp.given\n    return temp\n\nplt.figure(figsize=(12, 6))\nx = np.histogram(noisify(df1)['turnout'].values, bins=300, range=(0,1))\nplt.plot(x[1][:-1], x[0])","4b2bd801":"def measure_comb(vals):\n    \"\"\"For values between 0 and 1, measure how comb-like they are.\"\"\"\n    x = np.histogram(vals, bins=np.arange(0, 1.005, 0.005)-0.002, range=(0,1))\n    # This small offset of 0.002 to account for rounding errors around 1%-level values\n    return np.sum(x[0][np.arange(50,100)*2])\/np.sum(x[0][np.arange(50,100)*2 + 1])","ec943c85":"ds = df.groupby('region').agg({'turnout': np.mean, 'support': np.mean})\nds.columns = ['turnout', 'support']\n\nregions = np.unique(df.region)\nfor i in range(len(regions)):\n    region = regions[i]\n    temp = df[df.region==region]\n    ds.loc[region, 'turn_comb'] = (measure_comb(temp.turnout) \/ \n                                   np.mean([measure_comb(noisify(temp).turnout) for i in range(50)]))\n    ds.loc[region, 'supp_comb'] = (measure_comb(temp.support) \/ \n                                   np.mean([measure_comb(noisify(temp).support) for i in range(50)]))\n    print('.', end='')","f9fd62e1":"plt.figure(figsize=(10, 10))\nplt.plot(ds.turn_comb, ds.supp_comb, '.')\nplt.grid(alpha = 0.5)\nfor i in range(len(ds)):\n    plt.text(ds.turn_comb.values[i], ds.supp_comb.values[i], latinize(ds.index.tolist()[i]))\nplt.xlabel('Turnout combness')\nplt.ylabel('Support combness')","62458179":"def digihist(s):\n    \"\"\"Histogram of digits\"\"\"\n    h = {i:0 for i in range(10)}\n    for i in s[:]:\n        if i in '1234567890':\n            h[int(i)] += 1\n    return h\n    \ndef plot_dict(h):\n    \"\"\"Now plot it\"\"\"\n    x,y = zip(*[(key,val) for key,val in h.items()])\n    y = np.array(y)\/np.sum(y)\n    plt.plot(x[1:], y[1:], '.-')\n    \nplt.figure(figsize=(8,6))\nplot_dict(digihist(''.join([str(v) for v in df.nominal.values])))\nplot_dict(digihist(''.join([str(v) for v in df.given.values])))\nplot_dict(digihist(''.join([str(v) for v in df.yes.values])))\nplt.plot(np.arange(1,10), np.log(1+1\/np.arange(1,10))\/np.log(10));\nplt.xlabel('Digit')\nplt.ylabel('Frequency')\nplt.legend(labels=['Voting point size', 'Turnout', 'Support', 'Ideal'])","83c85279":"ind = (df.nominal > 1000) # Only large polling stations\ndf1 = df.copy()[ind]\n#df1 = noisify(df)[ind]\n\ndf1['closest_achievable_turnout'] = np.round(df1.given\/df1.nominal*100)\/100*df1.nominal\nplt.figure(figsize=(12,5.5), facecolor='white')\nplt.subplot(121)\nplt.plot(df1.given-df1.closest_achievable_turnout, df1.support, '.', markersize=1, alpha=0.1)\nplt.ylim(0.4, 1)\nplt.xlim(-15, 15)\nplt.xlabel('Turnout: distance to nearest round %')\nplt.ylabel('Pro-party vote')\nplt.subplot(122)\nx = np.histogram((df1.given-df1.closest_achievable_turnout)\/df1.given*100, bins=100)\nplt.plot(x[1][:-1], x[0]\/np.sum(x[0]))\nplt.grid()\nplt.xlabel('Turnout: Distance (in %) to nearest round %')\nplt.ylabel('Frequency')","68cbc5d4":"def measure_comb(vals):\n    \"\"\"For values between 0 and 1, measure how comb-like they are.\"\"\"\n    x = np.histogram(vals, bins=np.arange(0, 1.005, 0.005)-0.002, range=(0,1))\n    # This small offset of 0.002 to account for rounding errors around 1%-level values\n    return np.sum(x[0][np.arange(50,100)*2])\/max(1,np.sum(x[0][np.arange(50,100)*2 + 1]))\n\ndf['size_percentile'] = np.argsort(np.argsort(df.nominal))\/len(df)\ndf['yes_turnout'] = df.yes \/ np.maximum(1, df.nominal)\n\ncombiness = np.zeros((10,10))\nfor i in range(10):\n    for j in range(10):\n        ind = (1*(df.size_percentile>i\/10)*(df.size_percentile<=(i+1)\/10)*\n                 (df.yes_turnout>j\/10)*(df.yes_turnout<=(j+1)\/10) == 1)\n        if np.sum(ind) < 1:\n            combiness[i,j] = 0\n        else:\n            combiness[i,j] = (measure_comb(df[ind].support)+measure_comb(df[ind].turnout))\/2\n\n#print((combiness*10).astype(int))\nplt.imshow(np.rot90(combiness))\nplt.colorbar()\nplt.xlabel('Size percentile')\nplt.ylabel('Pro-party turnout')\nplt.title('Combness')","f4954798":"# Part 5","bbbdb021":"> Some other interesting regions include Tatarstan (a semi-independent republic in Central Russia speaking a Turkic language: what's the deal with this super-blot in the middle?), and Chechnya (well, you know this one! :)","ed63b810":"# Part 1","f6f6b56f":"# Anomalies in RU2020 vote\n\nGood map of regions:\nhttps:\/\/regnum.ru\/uploads\/pictures\/news\/2019\/03\/11\/regnum_picture_15523183991313502_normal.png","9ff6356c":"> Author: https:\/\/github.com\/khakhalin\/Sketches\/tree\/master\/ru_vote_2020","502b9ed7":"# Part 2","16b4c866":"> Not surprisingly, the higher Putin-support, the closer the %% are to a nice round %. (Or rather: the closer it is to the roundest % one can get by dividing two integers, for a given voter list. Say, for 1111 voters, you can't get exactly 95%, but you can 1055\/1111=0.9496)","f197caa1":"# Part 3","a1e54c5c":"# Part 4","c38239cf":"> I also tried to find biggest cheaters by measuring the combness of histograms (compared the freq of %% slightly-above and slightly-below a whole % number), and the prevalence of \"lucky\" ballot counts that yield a round %. (H0: % were noisified with \u03c3=0.005, n=50).","56eed6b1":"> Above is the main plot (after Klimek 2012). As both turnout and support were faked, we see a corner-blob emerge from the natural blob in the middle. In RU case, it's also striated, as cheaters go for round percent values. Some by-region histograms below (see 85%, 90% & 95%)\n\n> Also note the difference between cities that had active anti-Putin opposition plant themselves at voting stations & document everything (Moscow), and cities where it didn't quite happen (St. Petersburg)."}}