{"cell_type":{"b6673d6f":"code","f2ee15c6":"code","7b88fb9c":"code","0a877879":"code","322d0731":"code","f5fd6298":"code","5c99f6a6":"code","e5740d44":"code","c37d971c":"code","bbee9fef":"code","3d9aa7e8":"code","9bfa86c5":"code","933e5513":"code","8162e1d0":"code","87add6fd":"code","bdd7bc43":"code","34cb4a93":"code","f109f31c":"code","ef07ebeb":"code","c7964aaa":"code","900fcce6":"code","f3f89f9c":"code","0f84c0af":"code","b776084e":"code","69e5af31":"code","23dca8fe":"code","9aeeda26":"code","226af44d":"code","08a7f99e":"code","5b357906":"code","894c8efa":"code","349386bd":"code","c30da69d":"code","afecaa9a":"code","9f11d7a7":"markdown","67ab5b65":"markdown","cefc21a4":"markdown","613758a5":"markdown","7af25dae":"markdown","65e5b449":"markdown","29045d24":"markdown","d4577021":"markdown","8f77124e":"markdown","d0749e63":"markdown","29551102":"markdown"},"source":{"b6673d6f":"import numpy as np\nimport pandas as pd\nimport datetime\nimport gc\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport lightgbm as lgb\nfrom sklearn.model_selection import StratifiedKFold\nimport warnings\nfrom sklearn.model_selection import GroupKFold\nfrom xgboost import XGBClassifier\nfrom lightgbm import LGBMClassifier\nfrom catboost import CatBoostClassifier\nfrom sklearn import tree\nimport xgboost\nfrom sklearn.metrics import mean_squared_error, roc_auc_score, log_loss\nwarnings.filterwarnings('ignore')\nnp.random.seed(4590)","f2ee15c6":"debug=4","7b88fb9c":"if debug == 1:\n    nrows = 50000\n    print(\"\u672c\u6b21\u7a0b\u5e8f\u8fd0\u884c\u662f\u6d4b\u8bd5debug\u7528\")\nelse:\n    nrows = None\n    print(\"\u672c\u6b21\u7a0b\u5e8f\u8fd0\u884c\u662f\u8fd0\u884c\u6570\u636e\u6a21\u578b\")","0a877879":"df_train = pd.read_csv('..\/input\/train.csv',nrows=nrows)\ndf_test = pd.read_csv('..\/input\/test.csv',nrows=nrows)\ndf_hist_trans = pd.read_csv('..\/input\/historical_transactions.csv',nrows=nrows)\ndf_new_merchant_trans = pd.read_csv('..\/input\/new_merchant_transactions.csv',nrows=nrows)","322d0731":"for df in [df_train,df_test,df_hist_trans,df_new_merchant_trans]:\n    print(df.shape)","f5fd6298":"for df in [df_hist_trans,df_new_merchant_trans]:\n    df['category_2'].fillna(1.0,inplace=True)\n    df['category_3'].fillna('A',inplace=True)\n    df['merchant_id'].fillna('M_ID_00a6ca8a8a',inplace=True)","5c99f6a6":"def get_new_columns(name,aggs):\n    return [name + '_' + k + '_' + agg for k in aggs.keys() for agg in aggs[k]]","e5740d44":"for df in [df_hist_trans,df_new_merchant_trans]:\n    df['purchase_date'] = pd.to_datetime(df['purchase_date'])\n    df['year'] = df['purchase_date'].dt.year\n    df['weekofyear'] = df['purchase_date'].dt.weekofyear\n    df['month'] = df['purchase_date'].dt.month\n    df['dayofweek'] = df['purchase_date'].dt.dayofweek\n    df['weekend'] = (df.purchase_date.dt.weekday >=5).astype(int)\n    df['hour'] = df['purchase_date'].dt.hour\n    df['authorized_flag'] = df['authorized_flag'].map({'Y':1, 'N':0})\n    df['category_1'] = df['category_1'].map({'Y':1, 'N':0}) \n    #https:\/\/www.kaggle.com\/c\/elo-merchant-category-recommendation\/discussion\/73244\n    df['month_diff'] = ((datetime.datetime.today() - df['purchase_date']).dt.days)\/\/30\n    df['month_diff'] += df['month_lag']","c37d971c":"%%time\naggs = {}\nfor col in ['month','hour','weekofyear','dayofweek','year','subsector_id','merchant_id','merchant_category_id']:\n    aggs[col] = ['nunique']\n\naggs['purchase_amount'] = ['sum','max','min','mean','var','count']\naggs['installments'] = ['sum','max','min','mean','var']\naggs['purchase_date'] = ['max','min']\naggs['month_lag'] = ['max','min','mean','var']\naggs['month_diff'] = ['mean']\naggs['authorized_flag'] = ['sum', 'mean']\naggs['weekend'] = ['sum', 'mean']\naggs['category_1'] = ['sum', 'mean']\naggs['card_id'] = ['size']\n\nfor col in ['category_2','category_3']:\n    df_hist_trans[col+'_mean'] = df_hist_trans.groupby([col])['purchase_amount'].transform('mean')\n    aggs[col+'_mean'] = ['mean']    \n\nnew_columns = get_new_columns('hist',aggs)\ndf_hist_trans_group = df_hist_trans.groupby('card_id').agg(aggs)\ndf_hist_trans_group.columns = new_columns\ndf_hist_trans_group.reset_index(drop=False,inplace=True)\ndf_hist_trans_group['hist_purchase_date_diff'] = (df_hist_trans_group['hist_purchase_date_max'] - df_hist_trans_group['hist_purchase_date_min']).dt.days\ndf_hist_trans_group['hist_purchase_date_average'] = df_hist_trans_group['hist_purchase_date_diff']\/df_hist_trans_group['hist_card_id_size']\ndf_hist_trans_group['hist_purchase_date_uptonow'] = (datetime.datetime.today() - df_hist_trans_group['hist_purchase_date_max']).dt.days\ndf_train = df_train.merge(df_hist_trans_group,on='card_id',how='left')\ndf_test = df_test.merge(df_hist_trans_group,on='card_id',how='left')\ndel df_hist_trans_group;gc.collect()","bbee9fef":"%%time\naggs = {}\nfor col in ['month','hour','weekofyear','dayofweek','year','subsector_id','merchant_id','merchant_category_id']:\n    aggs[col] = ['nunique']\naggs['purchase_amount'] = ['sum','max','min','mean','var']\naggs['installments'] = ['sum','max','min','mean','var']\naggs['purchase_date'] = ['max','min']\naggs['month_lag'] = ['max','min','mean','var']\naggs['month_diff'] = ['mean']\naggs['weekend'] = ['sum', 'mean']\naggs['category_1'] = ['sum', 'mean']\naggs['card_id'] = ['size']\n\nfor col in ['category_2','category_3']:\n    df_new_merchant_trans[col+'_mean'] = df_new_merchant_trans.groupby([col])['purchase_amount'].transform('mean')\n    aggs[col+'_mean'] = ['mean']\n    \nnew_columns = get_new_columns('new_hist',aggs)\ndf_hist_trans_group = df_new_merchant_trans.groupby('card_id').agg(aggs)\ndf_hist_trans_group.columns = new_columns\ndf_hist_trans_group.reset_index(drop=False,inplace=True)\ndf_hist_trans_group['new_hist_purchase_date_diff'] = (df_hist_trans_group['new_hist_purchase_date_max'] - df_hist_trans_group['new_hist_purchase_date_min']).dt.days\ndf_hist_trans_group['new_hist_purchase_date_average'] = df_hist_trans_group['new_hist_purchase_date_diff']\/df_hist_trans_group['new_hist_card_id_size']\ndf_hist_trans_group['new_hist_purchase_date_uptonow'] = (datetime.datetime.today() - df_hist_trans_group['new_hist_purchase_date_max']).dt.days\ndf_train = df_train.merge(df_hist_trans_group,on='card_id',how='left')\ndf_test = df_test.merge(df_hist_trans_group,on='card_id',how='left')\ndel df_hist_trans_group;gc.collect()","3d9aa7e8":"del df_hist_trans;gc.collect()\ndel df_new_merchant_trans;gc.collect()\ndf_train.head(5)","9bfa86c5":"%%time\ndf_train['outliers'] = df_train.target.apply(lambda x: 1 if x<=-30 else 0)","933e5513":"df_train['outliers'].value_counts()","8162e1d0":"%%time\nfor df in [df_train,df_test]:\n    df['first_active_month'] = pd.to_datetime(df['first_active_month'])\n    df['dayofweek'] = df['first_active_month'].dt.dayofweek\n    df['weekofyear'] = df['first_active_month'].dt.weekofyear\n    df['month'] = df['first_active_month'].dt.month\n    df['elapsed_time'] = (datetime.datetime.today() - df['first_active_month']).dt.days\n    df['hist_first_buy'] = (df['hist_purchase_date_min'] - df['first_active_month']).dt.days\n    df['new_hist_first_buy'] = (df['new_hist_purchase_date_min'] - df['first_active_month']).dt.days\n    for f in ['hist_purchase_date_max','hist_purchase_date_min','new_hist_purchase_date_max',\\\n                     'new_hist_purchase_date_min']:\n        df[f] = df[f].astype(np.int64) * 1e-9\n    df['card_id_total'] = df['new_hist_card_id_size']+df['hist_card_id_size']\n    df['purchase_amount_total'] = df['new_hist_purchase_amount_sum']+df['hist_purchase_amount_sum']\n\nfor f in ['feature_1','feature_2','feature_3']:\n    order_label = df_train.groupby([f])['outliers'].mean()\n    df_train[f] = df_train[f].map(order_label)\n    df_test[f] = df_test[f].map(order_label)\n","87add6fd":"df_train_columns = [c for c in df_train.columns if c not in ['card_id', 'first_active_month','target','outliers','outliers2']]\ny_clf = df_train['outliers']","bdd7bc43":"%%time\n\nfolds = GroupKFold(n_splits=3)\n#train_features = [_f for _f in train.columns if _f not in excluded_clf_features]\ntrain_features = df_train_columns\ntrain = df_train\ntest = df_test\n\nprint(\"train_features\u6570\u91cf\uff1a\",len(train_features))\nimportances = pd.DataFrame()\noof_clf_preds1 = np.zeros(train.shape[0])\noof_clf_preds11 = np.zeros(train.shape[0])\noof_clf_preds21 = np.zeros(train.shape[0])\nsub_clf_preds1 = np.zeros(test.shape[0])\nsub_clf_preds11 = np.zeros(test.shape[0])\nsub_clf_preds21 = np.zeros(test.shape[0])\nfor fold_, (trn_, val_) in enumerate(folds.split(df_train, y_clf, groups=train['card_id'])):\n    print(\"folder----------\",fold_)\n    trn_x, trn_y = train[train_features].iloc[trn_], y_clf.iloc[trn_]\n    val_x, val_y = train[train_features].iloc[val_], y_clf.iloc[val_]\n    \n    clf = lgb.LGBMClassifier(\n        objective='binary',\n        learning_rate=0.004,\n        n_estimators=50000,\n        max_depth=6,\n        eval_metric='auc',\n        lambda_l1=1.852,\n        lambda_l2=1.548,\n        child_weight=5.243,\n        split_gain=0.04221,\n        num_leaves=13,\n        random_state=1\n    )\n    print(\"-\"* 10 + \"LightGBM Training\" + \"-\"* 10)\n    clf.fit(\n        trn_x, trn_y,\n        eval_set=[(val_x, val_y)],\n        early_stopping_rounds=200,\n        verbose=200\n    )\n\n    xgb_params = {\n        'objective': 'binary:logistic',\n        'booster': 'gbtree',\n        'eta': 0.004,\n        'lambda_l1':0.4472,\n        'lambda_l2':0.08835,\n        'max_depth':44,\n        'child_weight':5.331,\n        'split_gain':0.0454,\n        'num_leaves':23,\n        'is_unbalance':True,\n        'random_state': 27\n    }\n    \n    print(\"-\"* 10 + \"Xgboost Training\" + \"-\"* 10)\n    xg = XGBClassifier(**xgb_params, n_estimators=200000)\n    xg.fit(\n        trn_x, trn_y,\n        eval_set=[(val_x, val_y)],\n        early_stopping_rounds=200,\n        verbose=200\n    )\n    print(\"-\"* 10 + \"Catboost Training\" + \"-\"* 10)\n    cat = CatBoostClassifier(iterations=20000,\n                             learning_rate=0.02,\n                             eval_metric='AUC',\n                             random_seed = 42,\n                             metric_period = 50,\n                             od_wait=20)\n    cat.fit(\n        trn_x, trn_y,\n        eval_set=[(val_x, val_y)],\n        use_best_model=True,\n        early_stopping_rounds=200,\n        verbose=200)\n    \n    ###\u6b64\u5904\u4ec5\u663e\u793algb\u6a21\u578b\u8bad\u7ec3\u4e0b\u7684importance\n    imp_lgb_df = pd.DataFrame()\n    imp_lgb_df['feature3'] = train_features\n    imp_lgb_df['gain3'] = clf.booster_.feature_importance(importance_type='gain')\n    imp_lgb_df['fold3'] = fold_ + 1\n    importances = pd.concat([importances, imp_lgb_df], axis=0, sort=False)\n    \n    oof_clf_preds1[val_] = clf.predict_proba(val_x, num_iteration=clf.best_iteration_)[:, 1]\n    oof_clf_preds11[val_] = xg.predict_proba(val_x)[:, 1]\n    oof_clf_preds21[val_] = cat.predict_proba(val_x)[:, 1]\n    \n    \n    print(roc_auc_score(val_y, oof_clf_preds1[val_]))\n    print(roc_auc_score(val_y, oof_clf_preds11[val_]))\n    sub_clf_preds1 += clf.predict_proba(test[train_features], num_iteration=clf.best_iteration_)[:, 1] \/ folds.n_splits\n    sub_clf_preds11 += xg.predict_proba(test[train_features])[:, 1] \/ folds.n_splits\n    sub_clf_preds21 += cat.predict_proba(test[train_features])[:, 1] \/ folds.n_splits\n    \nprint(\"LGB AUC\u6a21\u578b\u5206\u6570\uff1a\",roc_auc_score(y_clf, oof_clf_preds1))\nprint(\"XGB AUC\u6a21\u578b\u5206\u6570\uff1a\",roc_auc_score(y_clf, oof_clf_preds11))\nprint(\"CAT AUC\u6a21\u578b\u5206\u6570\uff1a\",roc_auc_score(y_clf, oof_clf_preds21))\n","34cb4a93":"import warnings\nwarnings.simplefilter('ignore', FutureWarning)\nmean_gain = importances[['gain3', 'feature3']].groupby('feature3').mean()\nimportances['mean_gain3'] = importances['feature3'].map(mean_gain['gain3'])\nplt.figure(figsize=(10, 16))\nsns.barplot(x='gain3', y='feature3', data=importances.sort_values('mean_gain3', ascending=False).iloc[:350])\nplt.savefig('lgbm_clf_importances13.png')","f109f31c":"df_train['probal_lgb'] = oof_clf_preds1\ndf_train['probal_xgb'] = oof_clf_preds11\ndf_train['probal_cat'] = oof_clf_preds21\n\ndf_test['probal_lgb'] = sub_clf_preds1\ndf_test['probal_xgb'] = sub_clf_preds11\ndf_test['probal_cat'] = sub_clf_preds21\ndf_train.head()","ef07ebeb":"lgb_min = np.min(df_train['probal_lgb'].values)\nlgb_max = np.max(df_train['probal_lgb'].values)\nxgb_min = np.min(df_train['probal_xgb'].values)\nxgb_max = np.max(df_train['probal_xgb'].values)\ncat_min = np.min(df_train['probal_cat'].values)\ncat_max = np.max(df_train['probal_cat'].values)\nprint(lgb_min)\nprint(lgb_max)","c7964aaa":"df_train['probal_lgb'] = df_train.probal_lgb.apply(lambda x:(x-lgb_min)\/(lgb_max-lgb_min))\ndf_train['probal_xgb'] = df_train.probal_xgb.apply(lambda x:(x-xgb_min)\/(xgb_max-xgb_min))\ndf_train['probal_cat'] = df_train.probal_cat.apply(lambda x:(x-cat_min)\/(cat_max-cat_min))\n\ndf_train.head()","900fcce6":"df_train['lgb_xgb'] = oof_clf_preds1 + oof_clf_preds11\ndf_train['lgb_cat'] = oof_clf_preds1 + oof_clf_preds21\ndf_train['xgb_cat'] = oof_clf_preds11 + oof_clf_preds21\ndf_train['probal_combine'] = oof_clf_preds1 + oof_clf_preds11 + oof_clf_preds21\ndf_test['lgb_xgb'] = sub_clf_preds1 + sub_clf_preds11\ndf_test['lgb_cat'] = sub_clf_preds1 + sub_clf_preds21\ndf_test['xgb_cat'] = sub_clf_preds11 + sub_clf_preds21\ndf_test['probal_combine'] = sub_clf_preds1 + sub_clf_preds11 + sub_clf_preds21","f3f89f9c":"df_train['probal_max'] = df_train[['probal_lgb','probal_xgb','probal_cat']].max(axis=1)\ndf_train['probal_min'] = df_train[['probal_lgb','probal_xgb','probal_cat']].min(axis=1)\ndf_test['probal_max'] = df_test[['probal_lgb','probal_xgb','probal_cat']].max(axis=1)\ndf_test['probal_min'] = df_test[['probal_lgb','probal_xgb','probal_cat']].min(axis=1)","0f84c0af":"df_train['larger2'] = df_train['probal_lgb'] + df_train['probal_xgb'] + df_train['probal_cat'] - df_train['probal_min']\ndf_train['less2'] = df_train['probal_lgb'] + df_train['probal_xgb'] + df_train['probal_cat'] - df_train['probal_max']\ndf_test['larger2'] = df_test['probal_lgb'] + df_test['probal_xgb'] + df_test['probal_cat'] - df_test['probal_min']\ndf_test['less2'] = df_test['probal_lgb'] + df_test['probal_xgb'] + df_test['probal_cat'] - df_test['probal_max']","b776084e":"for col in ['probal_lgb','probal_xgb','probal_cat','probal_max','probal_min',\n            'lgb_xgb','lgb_cat','xgb_cat','probal_combine','larger2','less2']:\n    df_train[col + \"_multiplication\"] = -33.219281 * df_train[col]\n    df_test[col + \"_multiplication\"] = -33.219281 * df_test[col]","69e5af31":"df_train.head(6)","23dca8fe":"x=df_train[df_train['target']<=-11]\nx=x.sort_values(by ='target',ascending=False)\nx=x[['target','outliers','probal_lgb','probal_xgb','probal_cat']]\nx","9aeeda26":"df_train_columns = [c for c in df_train.columns if c not in ['card_id', 'first_active_month','target','outliers','outliers2']]\ntarget = df_train['target']\n#del df_train['target']","226af44d":"%%time\nparam = {'num_leaves': 31,\n         'min_data_in_leaf': 30, \n         'objective':'regression',\n         'max_depth': -1,\n         'learning_rate': 0.01,\n         \"min_child_samples\": 20,\n         \"boosting\": \"gbdt\",\n         \"feature_fraction\": 0.9,\n         \"bagging_freq\": 1,\n         \"bagging_fraction\": 0.9 ,\n         \"bagging_seed\": 11,\n         \"metric\": 'rmse',\n         \"lambda_l1\": 0.1,\n         \"verbosity\": -1,\n         \"nthread\": 4,\n         \"random_state\": 4590}\nfolds = StratifiedKFold(n_splits=5, shuffle=True, random_state=4590)\noof = np.zeros(len(df_train))\npredictions = np.zeros(len(df_test))\nfeature_importance_df = pd.DataFrame()\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(df_train,df_train['outliers'].values)):\n    print(\"fold {}\".format(fold_))\n    trn_data = lgb.Dataset(df_train.iloc[trn_idx][df_train_columns], label=target.iloc[trn_idx])#, categorical_feature=categorical_feats)\n    val_data = lgb.Dataset(df_train.iloc[val_idx][df_train_columns], label=target.iloc[val_idx])#, categorical_feature=categorical_feats)\n\n    num_round = 10000\n    clf = lgb.train(param, trn_data, num_round, valid_sets = [trn_data, val_data], verbose_eval=200, early_stopping_rounds = 200)\n    oof[val_idx] = clf.predict(df_train.iloc[val_idx][df_train_columns], num_iteration=clf.best_iteration)\n    \n    fold_importance_df = pd.DataFrame()\n    fold_importance_df[\"Feature\"] = df_train_columns\n    fold_importance_df[\"importance\"] = clf.feature_importance()\n    fold_importance_df[\"fold\"] = fold_ + 1\n    feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n    \n    predictions += clf.predict(df_test[df_train_columns], num_iteration=clf.best_iteration) \/ folds.n_splits\n\nnp.sqrt(mean_squared_error(oof, target))","08a7f99e":"cols = (feature_importance_df[[\"Feature\", \"importance\"]]\n        .groupby(\"Feature\")\n        .mean()\n        .sort_values(by=\"importance\", ascending=False)[:1000].index)\n\nbest_features = feature_importance_df.loc[feature_importance_df.Feature.isin(cols)]\n\nplt.figure(figsize=(14,25))\nsns.barplot(x=\"importance\",\n            y=\"Feature\",\n            data=best_features.sort_values(by=\"importance\",\n                                           ascending=False))\nplt.title('LightGBM Features (avg over folds)')\nplt.tight_layout()\nplt.savefig('lgbm_importances.png')","5b357906":"sub_df = pd.DataFrame({\"card_id\":df_test[\"card_id\"].values})\nsub_df[\"target\"] = predictions\nif debug == 1:\n    sub_df.to_csv(\"submission_debug.csv\", index=False)\n    print(\"\u672c\u6b21\u7a0b\u5e8f\u8fd0\u884c\u662f\u6d4b\u8bd5debug\u7528\")\nelse:\n    sub_df.to_csv(\"submission_model.csv\", index=False)\n    print(\"\u672c\u6b21\u7a0b\u5e8f\u8fd0\u884c\u662f\u8fd0\u884c\u6570\u636e\u6a21\u578b\")\n","894c8efa":"df_train2 = df_train[df_train['outliers'] == 0]\ntarget = df_train2['target']\ndel df_train2['target']","349386bd":"%%time\nparam = {'num_leaves': 31,\n         'min_data_in_leaf': 30, \n         'objective':'regression',\n         'max_depth': -1,\n         'learning_rate': 0.01,\n         \"min_child_samples\": 20,\n         \"boosting\": \"gbdt\",\n         \"feature_fraction\": 0.9,\n         \"bagging_freq\": 1,\n         \"bagging_fraction\": 0.9 ,\n         \"bagging_seed\": 11,\n         \"metric\": 'rmse',\n         \"lambda_l1\": 0.1,\n         \"verbosity\": -1,\n         \"nthread\": 4,\n         \"random_state\": 4590}\nfolds = StratifiedKFold(n_splits=5, shuffle=True, random_state=4590)\noof = np.zeros(len(df_train2))\npredictions = np.zeros(len(df_test))\nfeature_importance_df2 = pd.DataFrame()\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(df_train2,df_train2['outliers'].values)):\n    print(\"fold {}\".format(fold_))\n    trn_data = lgb.Dataset(df_train2.iloc[trn_idx][df_train_columns], label=target.iloc[trn_idx])#, categorical_feature=categorical_feats)\n    val_data = lgb.Dataset(df_train2.iloc[val_idx][df_train_columns], label=target.iloc[val_idx])#, categorical_feature=categorical_feats)\n\n    num_round = 10000\n    clf = lgb.train(param, trn_data, num_round, valid_sets = [trn_data, val_data], verbose_eval=200, early_stopping_rounds = 200)\n    oof[val_idx] = clf.predict(df_train2.iloc[val_idx][df_train_columns], num_iteration=clf.best_iteration)\n    \n    fold_importance_df2 = pd.DataFrame()\n    fold_importance_df2[\"Feature2\"] = df_train_columns\n    fold_importance_df2[\"importance2\"] = clf.feature_importance()\n    fold_importance_df2[\"fold2\"] = fold_ + 1\n    feature_importance_df2 = pd.concat([feature_importance_df2, fold_importance_df2], axis=0)\n    \n    predictions += clf.predict(df_test[df_train_columns], num_iteration=clf.best_iteration) \/ folds.n_splits\n\nnp.sqrt(mean_squared_error(oof, target))","c30da69d":"cols = (feature_importance_df2[[\"Feature2\", \"importance2\"]]\n        .groupby(\"Feature2\")\n        .mean()\n        .sort_values(by=\"importance2\", ascending=False)[:1000].index)\n\nbest_features = feature_importance_df2.loc[feature_importance_df2.Feature2.isin(cols)]\n\nplt.figure(figsize=(14,25))\nsns.barplot(x=\"importance2\",\n            y=\"Feature2\",\n            data=best_features.sort_values(by=\"importance2\",\n                                           ascending=False))\nplt.title('LightGBM Features (avg over folds)')\nplt.tight_layout()\nplt.savefig('lgbm_importances2.png')","afecaa9a":"sub_df2 = pd.DataFrame({\"card_id\":df_test[\"card_id\"].values})\nsub_df2[\"target\"] = predictions\nif debug == 1:\n    sub_df2.to_csv(\"submission_debug2_without_outliers.csv\", index=False)\n    print(\"\u672c\u6b21\u7a0b\u5e8f\u8fd0\u884c\u662f\u6d4b\u8bd5debug\u7528\")\nelse:\n    sub_df2.to_csv(\"submission_model2_without_outliers.csv\", index=False)\n    print(\"\u672c\u6b21\u7a0b\u5e8f\u8fd0\u884c\u662f\u8fd0\u884c\u6570\u636e\u6a21\u578b\")\n","9f11d7a7":"from bayes_opt import BayesianOptimization\nX = df_train[df_train_columns]\ny = y_clf","67ab5b65":"#2\u3001xgboost\ndef bayes_parameter_opt_xgb(X, y, init_round=15, opt_round=25, n_folds=5, random_seed=0, n_estimators=10000,\n                            learning_rate=0.004, output_process=True):\n    # prepare data\n    train_data = xgb.Dataset(data=X, label=y, free_raw_data=False)\n\n    # parameters\n    def xgb_eval(num_leaves, max_depth, lambda_l1, lambda_l2, min_split_gain,\n                 min_child_weight):\n        params = {'application': 'binary:logistic', 'num_iterations': n_estimators, 'learning_rate': learning_rate, \n                  'early_stopping_round': 200, 'metric': 'auc'}\n        params[\"nthread\"] = 4\n        params[\"num_leaves\"] = int(round(num_leaves))\n        params['feature_fraction'] = max(min(feature_fraction, 1), 0)\n        params['bagging_fraction'] = max(min(bagging_fraction, 1), 0)\n        params['max_depth'] = int(round(max_depth))\n        params['lambda_l1'] = max(lambda_l1, 0)\n        params['lambda_l2'] = max(lambda_l2, 0)\n        params['min_split_gain'] = min_split_gain\n        params['min_child_weight'] = min_child_weight\n        params[\"silent\"] = -1\n        params[\"verbose\"] = -1\n        params[\"unbalance\"] = unbalance\n        cv_result = xgb.cv(params, train_data, nfold=n_folds, seed=random_seed, verbose_eval=200,\n                           metrics=['rmse'])\n        return max(cv_result['rmse-mean'])\n\n    # range\n    xgbBO = BayesianOptimization(xgb_eval, {'num_leaves': (24, 45),\n                                            'feature_fraction': (0.1, 0.9),\n                                            'bagging_fraction': (0.8, 1),\n                                            'max_depth': (5, 45),\n                                            'lambda_l1': (0, 5),\n                                            'lambda_l2': (0, 3),\n                                            'min_split_gain': (0.001, 0.1),\n                                            'unbalance':[True,False],\n                                            'min_child_weight': (5, 50)}, random_state=0)\n    # optimize\n    xgbBO.maximize(init_points=init_round, n_iter=opt_round)\n\n    # output optimization process\n    if output_process == True: xgbBO.points_to_csv(\"bayes_opt_result_xgb.csv\")\n\n    # return best parameters\n    return xgbBO.res['max']['max_params']\n\nxgb_opt_params = bayes_parameter_opt_xgb(X, y, init_round=5, opt_round=10, n_folds=5, random_seed=0, n_estimators=10000,\n                                     learning_rate=0.02)\nxgb_opt_params","cefc21a4":"#1\u3001lightgbm\ndef bayes_parameter_opt_lgb(X, y, init_round=15, opt_round=25, n_folds=5, random_seed=0, n_estimators=10000,\n                            learning_rate=0.002, output_process=True):\n    # prepare data\n    train_data = lgb.Dataset(data=X, label=y, free_raw_data=False)\n\n    # parameters\n    def lgb_eval(num_leaves, max_depth, lambda_l1, lambda_l2, min_split_gain,\n                 min_child_weight):\n        params = {'application': 'binary', 'num_iterations': n_estimators, 'learning_rate': learning_rate, \n                  'early_stopping_round': 200, 'metric': 'auc'}\n        params[\"nthread\"] = 4\n        params[\"num_leaves\"] = int(round(num_leaves))\n        #params['feature_fraction'] = max(min(feature_fraction, 1), 0)\n        #params['bagging_fraction'] = max(min(bagging_fraction, 1), 0)\n        params['max_depth'] = int(round(max_depth))\n        params['lambda_l1'] = max(lambda_l1, 0)\n        params['lambda_l2'] = max(lambda_l2, 0)\n        params['min_split_gain'] = min_split_gain\n        params['min_child_weight'] = min_child_weight\n        params[\"silent\"] = -1\n        params[\"verbose\"] = -1\n        params[\"unbalance\"] = unbalance\n        cv_result = lgb.cv(params, train_data, nfold=n_folds, seed=random_seed, verbose_eval=200,\n                           metrics=['auc'])\n        return max(cv_result['auc-mean'])\n\n    # range\n    lgbBO = BayesianOptimization(lgb_eval, {'num_leaves': (12, 36),\n                                            #'feature_fraction': (0.01, 0.5),\n                                            #'bagging_fraction': (0.9, 1),\n                                            'max_depth': (5, 45),\n                                            'lambda_l1': (0, 5),\n                                            'lambda_l2': (0, 3),\n                                            'min_split_gain': (0.001, 0.1),\n                                            'unbalance':[True,False],\n                                            'min_child_weight': (5, 50)}, random_state=0)\n    # optimize\n    lgbBO.maximize(init_points=init_round, n_iter=opt_round)\n\n    # output optimization process\n    if output_process == True: lgbBO.points_to_csv(\"bayes_opt_result_lgb.csv\")\n\n    # return best parameters\n    return lgbBO.res['max']['max_params']\n\nlgb_opt_params = bayes_parameter_opt_lgb(X, y, init_round=5, opt_round=10, n_folds=5, random_seed=0, n_estimators=10000,\n                                     learning_rate=0.02)\nlgb_opt_params","613758a5":"## 1.1Bayes \u4f18\u5316\u4ee3\u7801","7af25dae":"**To be continued ...**","65e5b449":"## 2\u3001\u8fdb\u884c\u56de\u5f52\u8bad\u7ec3","29045d24":"## 3\u3001\u5220\u9664outliers\u4e3a1\u7684\u6837\u672c\u540e\u8fdb\u884c\u8bad\u7ec3","d4577021":"## 1\u3001\u6dfb\u52a0\u4e8c\u5206\u7c7b\u7684\u8bad\u7ec3\n","8f77124e":"**FEEL FREE TO UPVOTE**  \uff08\uff3e\uff56\uff3e\uff09","d0749e63":"#3\u3001catboost\ndef bayes_parameter_opt_cat(X, y, init_round=15, opt_round=25, n_folds=5, random_seed=0, n_estimators=10000,\n                            learning_rate=0.1, output_process=True):\n    # prepare data\n    train_data = cat.Dataset(data=X, label=y, free_raw_data=False)\n\n    # parameters\n    def cat_eval(num_leaves, max_depth, lambda_l1, lambda_l2, min_split_gain,\n                 min_child_weight):\n        params = {'application': 'auc', 'num_iterations': n_estimators, 'learning_rate': learning_rate, \n                  'early_stopping_round': 200, 'metric': 'AUC'}\n        params[\"nthread\"] = 4\n        params[\"num_leaves\"] = int(round(num_leaves))\n        params['feature_fraction'] = max(min(feature_fraction, 1), 0)\n        params['bagging_fraction'] = max(min(bagging_fraction, 1), 0)\n        params['max_depth'] = int(round(max_depth))\n        params['lambda_l1'] = max(lambda_l1, 0)\n        params['lambda_l2'] = max(lambda_l2, 0)\n        params['min_split_gain'] = min_split_gain\n        params['min_child_weight'] = min_child_weight\n        params[\"silent\"] = -1\n        params[\"verbose\"] = -1\n        cv_result = cat.cv(params, train_data, nfold=n_folds, seed=random_seed, verbose_eval=200,\n                           metrics=['rmse'])\n        return max(cv_result['rmse-mean'])\n\n    # range\n    catBO = BayesianOptimization(cat_eval, {'num_leaves': (24, 45),\n                                            'feature_fraction': (0.1, 0.9),\n                                            'bagging_fraction': (0.8, 1),\n                                            'max_depth': (5, 45),\n                                            'lambda_l1': (0, 5),\n                                            'lambda_l2': (0, 3),\n                                            'min_split_gain': (0.001, 0.1),\n                                            'min_child_weight': (5, 50)}, random_state=0)\n    # optimize\n    catBO.maximize(init_points=init_round, n_iter=opt_round)\n\n    # output optimization process\n    if output_process == True: catBO.points_to_csv(\"bayes_opt_result_cat.csv\")\n\n    # return best parameters\n    return catBO.res['max']['max_params']\n\ncat_opt_params = bayes_parameter_opt_cat(X, y, init_round=5, opt_round=10, n_folds=5, random_seed=0, n_estimators=10000,\n                                     learning_rate=0.02)\ncat_opt_params","29551102":"### \u5f52\u4e00\u5316"}}