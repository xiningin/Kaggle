{"cell_type":{"fc2b4cc3":"code","b1bf7926":"markdown"},"source":{"fc2b4cc3":"def cleanup3(X):\n    \"\"\"\n    Fixes the categorical features. \n    \n    \n    Each feature has different specific problems, but they usually have\n    garbage values (usually 'unknown') that should really be read as NANs.\n    \n    This function cleans up garbage, clusters together different labels\n    that should be equivalent but are coded differently (e.g., different\n    spellings of the same thing), and removes labels with so few members\n    that they're unlikely to be informative.\n    \n    \n    Parameters\n    ----------\n    X : pandas.DataFrame\n        DF with raw categorical features, except for the changes\n        already included in cleanup1.\n    \n    Returns\n    ----------\n    X2 : pandas.DataFrame\n         DF with cleaned categorical features.\n    \n    \"\"\"\n    \n    # Make a clean copy, to ensure we're not changing the original DF\n    X2 = X.copy()\n    \n    # Create list of categorical features\n    categoricals = df2.select_dtypes(exclude='number').columns.tolist()\n\n    # Make all strings lowercase, to collapse together some of the categories\n    X2[categoricals] = X2[categoricals].applymap(lambda x: x.lower())\n\n    # Replace common NAN values\n    nan_list = ['not known','unknown','none','-','##','not kno','unknown installer']\n    X2 = X2.replace(nan_list, np.nan)\n\n    # Any feature values with fewer than 100 rows gets turned into a NAN\n    for feature in X2[categoricals]:\n        # Determine which feature values to keep\n        to_keep = X2[feature].value_counts()[X2[feature].value_counts() > 100].index.tolist()\n        # Turn those into NANs (using a copy, to prevent warnings)\n        feature_copy = X2[feature].copy()\n        feature_copy[~feature_copy.isin(to_keep)] = np.nan\n        X2[feature] = feature_copy\n\n    # Fix all NANs\n    X2[categoricals] = X2[categoricals].fillna('other')\n    \n    \n    return X2","b1bf7926":"A simple cleaner for your categorical columns.  Makes them manageable for future encoding."}}