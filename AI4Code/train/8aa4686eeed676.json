{"cell_type":{"1325669b":"code","72fd1824":"code","d4282f37":"code","f4a96aa4":"code","8f8d434f":"code","96a75fb5":"code","f1e41f0d":"code","42d2e650":"code","1eb64650":"code","826f9cb8":"code","d0a4aac9":"code","7240e8e4":"code","a864b5b3":"code","ea0b75eb":"code","2096e18e":"code","3f9fbdd2":"code","47e6ecf0":"code","1c90ffd5":"code","285cf6ad":"code","9bbeebd5":"code","5a9f8a20":"code","7e873276":"code","cd0a5f6d":"code","4f831f46":"code","11bf6050":"code","5164dcc6":"code","3e683c32":"code","c3976e63":"code","e44ca7ef":"code","06e034ef":"code","05b3b670":"code","74c6ed62":"code","0e20cce5":"markdown","37bf7a82":"markdown","e02386d7":"markdown","e5b526ff":"markdown","dda90bd2":"markdown","2bfdcc6f":"markdown","8573e6e4":"markdown","59f55f04":"markdown","23138e27":"markdown","3d12f1c6":"markdown","9b68f392":"markdown","c6e0956f":"markdown"},"source":{"1325669b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np\nimport pandas as pd\nimport os\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport seaborn as sns\nimport cv2\nfrom skimage.filters import prewitt_h,prewitt_v\nfrom skimage.filters import sato\nfrom skimage.filters import sobel\nfrom skimage import feature\nfrom skimage import measure\nfrom skimage.feature import hog\nfrom skimage.filters.rank import entropy\nfrom skimage.morphology import disk\nfrom skimage.measure.entropy import shannon_entropy\nfrom skimage.feature import corner_harris, corner_subpix, corner_peaks\nfrom skimage import data, segmentation, color, filters, io\nfrom skimage.future import graph\n\nfrom skimage import color\n\n# for dirname, _, filenames in os.walk('\/kaggle\/input\/lego-parts\/parts_148\/parts_148'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","72fd1824":"parts=pd.read_csv(\"\/kaggle\/input\/lego-parts\/parts.csv\")\nparts['file_name_poss']= parts['part_num']+\".png\"\nparts.head()","d4282f37":"parts.shape","f4a96aa4":"#selecting parts with both entries in csv and part drawings\nparts_files_path= \"\/kaggle\/input\/lego-parts\/parts_148\/parts_148\"\npossibilities=parts['file_name_poss'].tolist()\ndiagrams=os.listdir(parts_files_path)\ncomplete_parts=list(set(possibilities) & set(diagrams))\nlen(complete_parts)","8f8d434f":"parts_select=parts[parts['file_name_poss'].isin(complete_parts)]\nparts_select.shape\nparts_select","96a75fb5":"parts_select[parts_select.duplicated('file_name_poss')]\n# 5 part_names are duplicated","f1e41f0d":"duplicated_parts= [\"4591.png\",\"4588.png\",\"4590.png\",\"4740.png\",\"4742.png\"]\nparts_select[parts_select['file_name_poss'].isin(duplicated_parts)]","42d2e650":"parts_select.drop_duplicates(subset =\"file_name_poss\", \n                     keep = False, inplace = True)\nparts_select.shape","1eb64650":"#Distribution of data across part categories\npercent_distr = round(parts_select[\"part_cat_id\"].value_counts() \/ len(parts_select[\"part_cat_id\"]) * 100,2)\n\nprint(\"Data Percent: \")\nprint(percent_distr)","826f9cb8":"len(np.unique(parts_select[\"part_cat_id\"]))","d0a4aac9":"complete_parts = [x for x in complete_parts if x not in duplicated_parts]","7240e8e4":"len(complete_parts)","a864b5b3":"for part in complete_parts[:20]:\n    im = cv2.imread(\"\/kaggle\/input\/lego-parts\/parts_148\/parts_148\/\" + part, cv2.IMREAD_GRAYSCALE)\n    \n    plt.imshow(im, cmap='gray')\n    plt.show()","ea0b75eb":"def load_data(dir_data,part_df):\n    ''' Load each of the image files into memory \n\n    While this is feasible with a smaller dataset, for larger datasets,\n    not all the images would be able to be loaded into memory\n    '''\n    parts_df  = part_df\n    labels    = parts_df.part_cat_id.values\n    ids       = parts_df.part_num.values\n    data      = []\n    for identifier in ids:\n        fname     = dir_data + identifier + '.png'\n        image     = mpl.image.imread(fname)\n        data.append(image)\n    data = np.array(data) # Convert to Numpy array\n    return data, labels","2096e18e":"dir_images=\"..\/input\/lego-parts\/parts_148\/parts_148\/\"\ndata, labels = load_data(dir_images,parts_select)","3f9fbdd2":"# using Luminance to obtain grayscale images\n# luminance is the weighted average of RGB values\ndata_gray = [ color.rgb2gray(i) for i in data]","47e6ecf0":"hor_edges = []\nver_edges = []\nfor image in data_gray:\n    #calculating horizontal edges using prewitt kernel\n    edges_prewitt_horizontal = prewitt_h(image)\n    #calculating vertical edges using prewitt kernel\n    edges_prewitt_vertical = prewitt_v(image)\n    hor_edges.append(edges_prewitt_horizontal)\n    ver_edges.append(edges_prewitt_vertical)\n","1c90ffd5":"# plot image after applying vertical edge filter to grayscale image\nplt.imshow(ver_edges[855])\nplt.axis('off')\nplt.title('Image after applying vertical edge detector')","285cf6ad":"# plot image after applying vertical edge filter to grayscale image\nplt.imshow(hor_edges[855])\nplt.axis('off')\nplt.title('Image after applying horizontal edge detector')","9bbeebd5":"canny_edges_for_image = []\nfor image in data_gray:\n    # running this bit to get the images after canny edge detector is applied- to visualize\n    edges_sigma1 = feature.canny(image, sigma=3)\n    canny_edges_for_image.append(edges_sigma1)\n    \nlen(canny_edges_for_image)","5a9f8a20":"# plot image after applying canny edge detector to grayscale image\nplt.imshow(canny_edges_for_image[855])\nplt.axis('off')\nplt.title('Image after applying Canny Edge Detector')","7e873276":"#corner detection algos\nharris_corner_for_image = []\ncorner_peaks_res=[]\ncorner_subpix_res=[]\nfor image in data_gray:\n    coords = corner_harris(image)\n    coords_peaks = corner_peaks(corner_harris(image), min_distance=5, threshold_rel=0.02)\n    coords_subpix = corner_subpix(image, coords_peaks, window_size=13)\n    harris_corner_for_image.append(coords)\n    corner_peaks_res.append(coords_peaks)\n    corner_subpix_res.append(coords_peaks)\n    \nlen(harris_corner_for_image)","cd0a5f6d":"# plot image after applying corner detection algos\nplt.imshow(harris_corner_for_image[855])\nplt.axis('off')\nplt.title('Image after applying Harris Corner Detector')","4f831f46":"# plot image after applying corner detection algos\nplt.imshow(corner_peaks_res[855])\nplt.axis('off')\nplt.title('Image after applying Find peaks in corner measure response image')","11bf6050":"# plot image after applying corner detection algos\nplt.imshow(corner_subpix_res[855])\nplt.axis('off')\nplt.title('Image after applying subpixel position of corners')","5164dcc6":"#compute entropies- apply entropies filter\nentropies = []\nfor image in data_gray:\n    #getting images with entropy filter applied to the images\n    e1 =entropy(image, disk(10))\n    entropies.append(e1)\n    \nlen(entropies)","3e683c32":"# plot image after applying entropy filter to grayscale image\nplt.imshow(entropies[855])\nplt.axis('off')\nplt.title('Image after applying entropy filter')","c3976e63":"# apply HOG (Histogram of Oriented Gradient) transformation\nppc = 16\nhog_images = []\nhog_features = []\nfor image in data_gray:\n    # extracting hog transformed images and the feature arrays\n    fd,hog_image = hog(image, orientations=10, pixels_per_cell=(ppc,ppc),cells_per_block=(4, 4),block_norm= 'L2',visualize=True)\n    hog_images.append(hog_image)\n    hog_features.append(fd)","e44ca7ef":"# plot image after applying HOG filter to grayscale image\nplt.imshow(hog_images[855])\nplt.axis('off')\nplt.title('Image after applying HOG filter')","06e034ef":"sato_res = []\nfor image in data_gray:\n    #getting images with entropy filter applied to the images\n    st1 =sato(image)\n    sato_res.append(st1)\n    \nlen(sato_res)","05b3b670":"# plot image after applying sato tube filter\nplt.imshow(sato_res[855])\nplt.axis('off')\nplt.title('Image after applying Sato Tube filter')","74c6ed62":"# import skimage\n# for img in data_gray:\n#     labels = segmentation.slic(img)\n#     edge_map = filters.sobel(color.rgb2gray(img))\n#     rag = graph.rag_boundary(labels, edge_map)\n \n    \n# NEED TO WORK ON THIS","0e20cce5":"### Corner Detection","37bf7a82":"The information entropy is the log-base-2 of the number of possible outcomes for a message.\n\nFor an image, local entropy is related to the complexity contained in a given neighborhood, typically defined by a structuring element. The entropy filter can detect subtle variations in the local gray level distribution.\n\nSource: [skimage entropy](https:\/\/scikit-image.org\/docs\/dev\/auto_examples\/filters\/plot_entropy.html)","e02386d7":"The Canny filter is a multi-stage edge detector. It uses a filter based on the derivative of a Gaussian in order to compute the intensity of the gradients.The Gaussian reduces the effect of noise present in the image. Then, potential edges are thinned down to 1-pixel curves by removing non-maximum pixels of the gradient magnitude. Finally, edge pixels are kept or removed using hysteresis thresholding on the gradient magnitude.\n\nThe Canny has three adjustable parameters: the width of the Gaussian (the noisier the image, the greater the width), and the low and high threshold for the hysteresis thresholding.\n\nSource: [skimage canny](https:\/\/scikit-image.org\/docs\/dev\/auto_examples\/edges\/plot_canny.html)","e5b526ff":"This filter can be used to detect continuous ridges, e.g. tubes, wrinkles, rivers. It can be used to calculate the fraction of the whole image containing such objects.\n\nDefined only for 2-D and 3-D images. Calculates the eigenvectors of the Hessian to compute the similarity of an image region to tubes.\n\nSource: [skimage sato](https:\/\/scikit-image.org\/docs\/dev\/api\/skimage.filters.html#skimage.filters.sato)","dda90bd2":"### HOG (Histogram of Oriented Gradient) transformation","2bfdcc6f":"### SATO tubeness","8573e6e4":"### Canny Edge Detection","59f55f04":"### Horizontal and vertical edges","23138e27":"### Entropy Filter","3d12f1c6":"## Feature extraction","9b68f392":"## Selecting parts and prepping dataset","c6e0956f":"### Grayscale conversion"}}