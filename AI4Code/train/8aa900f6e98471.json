{"cell_type":{"6b4f0820":"code","d66b4ece":"code","8b817777":"code","e0f8a9d2":"code","e89833e2":"code","e084a566":"code","761b5ceb":"code","d8c0b47c":"code","85b5ccc7":"code","ea8ae282":"code","cbd2c041":"code","abf4e809":"code","8149fb08":"code","4f634ef5":"code","d8ed915c":"code","44e9718c":"code","3630aa9e":"code","419d6d21":"code","97927574":"code","52c8a574":"code","9f83eba1":"code","cdbefdae":"code","ecd21c73":"code","ef876639":"code","481ddb65":"code","752ffa83":"code","f3d8ce48":"code","a85f0902":"code","677d064a":"code","a8ad9f0f":"code","5800c704":"code","9eae7672":"code","af70f8f9":"code","0c0e2427":"code","d222c20c":"code","b2f957fc":"code","f240697e":"code","97db9407":"code","529371af":"code","5cef158a":"code","aeeee21c":"code","696c3ab7":"code","79d7e1bc":"code","2f762355":"code","2ba14553":"markdown","11d04b49":"markdown","8e03c318":"markdown","98b4b40a":"markdown","322aa46a":"markdown","63554e92":"markdown","f39a3038":"markdown","93abd8e1":"markdown","1273bfa2":"markdown","ccfc688c":"markdown","60ff0f1c":"markdown","6ccca903":"markdown","fe51e7b2":"markdown","684547f1":"markdown","f244a0cf":"markdown","7402576e":"markdown","f0ae187a":"markdown","49d263c0":"markdown","12635a30":"markdown","696ad206":"markdown","118f8793":"markdown","1593afd9":"markdown","a119c685":"markdown","52b0b1b3":"markdown","e6ece49e":"markdown","d59878d6":"markdown","e554b2a1":"markdown","e9121dfe":"markdown","1bf0d9bb":"markdown","0f33d483":"markdown"},"source":{"6b4f0820":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d66b4ece":"import matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.graph_objs as go # interactive plotting library\nimport plotly.express as px # interactive plotting library\nfrom plotly.subplots import make_subplots\n!pip install RapidPlot  # Library that I created. Only Contains 1 classs with 4 functions till now ;)\nimport RapidPlot\nfrom IPython.display import display\n!pip install ppscore # installing ppscore, library used to check non-linear relationships between our variables\nimport ppscore as pps # importing ppscore\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler","8b817777":"!pip install imblearn\nfrom scipy.stats import describe\nfrom imblearn.over_sampling import RandomOverSampler,SMOTE, ADASYN\nfrom imblearn.under_sampling import RandomUnderSampler\nfrom imblearn.metrics import classification_report_imbalanced\nfrom imblearn.pipeline import Pipeline as imb_Pipeline\nfrom imblearn.base import SamplerMixin","e0f8a9d2":"# Models:\n\nfrom sklearn.linear_model import LogisticRegression, SGDClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom xgboost import XGBClassifier\nfrom lightgbm import LGBMClassifier\n!pip install catboost\nfrom catboost import CatBoostClassifier\n\n# Metrics\n\nfrom sklearn.metrics import accuracy_score, roc_curve, f1_score, precision_score, recall_score, confusion_matrix\n\n\n# Model Selection:\n\nfrom sklearn.pipeline import Pipeline as sk_Pipeline\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.base import BaseEstimator, TransformerMixin\n\n# Library for plotting confusion matrix\nfrom mlxtend.plotting import plot_confusion_matrix","e89833e2":"ci_df = pd.read_csv(\"..\/input\/caravan-insurance-challenge\/caravan-insurance-challenge.csv\")\nci_df.head()","e084a566":"train_index = ci_df.ORIGIN == 'train'\ntest_index = ci_df.ORIGIN == 'test'\nci_df.drop(columns=['ORIGIN'], inplace=True)","761b5ceb":"(ci_df.isnull() == True).sum().sum()    # Checking total null-values in the dataset","d8c0b47c":"ci_df.CARAVAN.value_counts()","85b5ccc7":"scaler = StandardScaler()\npca = PCA(n_components=2)\nci_df_red = pca.fit_transform(scaler.fit_transform(ci_df.drop(columns=('CARAVAN'))))","ea8ae282":"fig = px.scatter(x=ci_df_red[:, 0], y=ci_df_red[:, 1], color=ci_df.CARAVAN)\nfig.show()","cbd2c041":"# for execution time uncomment the below line\n#%timeit ci_df_corr = ci_df.corr()\n\n# and comment this line\nci_df_corr = ci_df.corr()\n\nfig = px.imshow(ci_df_corr)\nfig.show()","abf4e809":"fig, axs = plt.subplots(figsize=(20, 7), ncols=2)\n\nsns.heatmap(ci_df_corr.iloc[:43, :43], cmap='YlGnBu', ax=axs[0])\nsns.heatmap(ci_df_corr.iloc[43:-1, 43:-1], ax=axs[1])\n\naxs[0].set_title('Upper Left')\naxs[1].set_title('Lower Right')\n\nfig.show()","8149fb08":"needed_columns = ci_df_corr.columns[~pd.Series(ci_df_corr.columns).str.startswith('A')]\n\nneeded_corr = ci_df_corr.loc[needed_columns, needed_columns]\n\nfig = px.imshow(needed_corr)\nfig.show()","4f634ef5":"corr_with_target = needed_corr.iloc[-1, :-1]\nprint(corr_with_target)\ncorr_with_target.max()","d8ed915c":"pearson_feature_vector = corr_with_target[np.abs(corr_with_target) >=0.05]\nprint(pearson_feature_vector.shape)\npearson_feature_vector","44e9718c":"# for execution time uncomment the below line\n#%timeit ci_df_pps = pps.matrix(ci_df)\n\n# and comment this line\nci_df_pps = pps.matrix(ci_df)\n\nci_df_pps","3630aa9e":"pps_val_matrix = pd.DataFrame(np.array(ci_df_pps.ppscore).reshape(len(ci_df.columns), len(ci_df.columns)),\n                              index=ci_df.columns,\n                              columns=ci_df.columns)\npps_val_matrix","419d6d21":"fig = px.imshow(pps_val_matrix)\nfig.show()","97927574":"needed_pps = pps_val_matrix.loc[needed_columns, needed_columns]\n\nfig = px.imshow(needed_pps)\nfig.show()","52c8a574":"pps_with_target = pps_val_matrix.iloc[-1, :-1]\npps_with_target","9f83eba1":"pps_with_target.max()","cdbefdae":"pps_feature_vector = pps_with_target[pps_with_target != 0]\nprint(pps_feature_vector.shape)\npps_feature_vector","ecd21c73":"# Setting random state\nrnd_state = 42","ef876639":"X = ci_df.drop(columns='CARAVAN')\ny = ci_df.CARAVAN\n\nX_train = X[train_index]\ny_train = y[train_index]\nX_test = X[test_index]\ny_test = y[test_index]","481ddb65":"for name, data in zip(('X_train', 'y_train', 'X_test', 'y_test'), (X_train, y_train, X_test, y_test)):\n    print(name)\n    print(f'Shape: {data.shape}')\n    if len(data.shape) == 1:\n        print('Balance Stats:')\n        print(data.value_counts())\n        print('\\n')","752ffa83":"# Creating Instances:\n\nros = RandomOverSampler(random_state=rnd_state)\nrus = RandomUnderSampler(random_state=rnd_state)\nsmote_sampler = SMOTE(random_state=rnd_state, n_jobs=-1)\nadasyn_sampler = ADASYN(random_state=rnd_state, n_jobs=-1)","f3d8ce48":"# Handling Imbalance:\n\nX_under,y_under = rus.fit_sample(X_train,y_train)\nX_over,y_over = ros.fit_sample(X_train,y_train)\nX_smote,y_smote = smote_sampler.fit_sample(X_train,y_train)\nX_adasyn, y_adasyn = adasyn_sampler.fit_sample(X_train, y_train)\n\n# In the paper on smote it is sugested to first undersample, then use smote, let's do that\nX_under_smote, y_under_smote = smote_sampler.fit_sample(X_under, y_under)\nX_under_adasyn, y_under_adasyn = adasyn_sampler.fit_sample(X_under, y_under)","a85f0902":"data_index = ['Unbalanced','Undersample','Oversample','SMOTE', 'ADASYN', 'Undersample then SMOTE', 'Undersample then ADASYN']\n\nimbalance_handling_stats = pd.DataFrame([*map(lambda x:describe(x)._asdict(),[y_train,y_under,y_over,y_smote, y_adasyn, y_under_smote, y_under_adasyn])],index=data_index)\nimbalance_handling_stats","677d064a":"class FeatureTransformer(BaseEstimator, TransformerMixin):\n    \n    def __init__(self, feature_vector=None):\n        self.feature_vector = feature_vector\n        \n    def fit(self, X, y):\n        return self\n    \n    def transform(self, X):\n        return X[self.feature_vector]","a8ad9f0f":"rnd_state=3\n\nmodel_list = [LogisticRegression(random_state=rnd_state),\n              SGDClassifier(random_state=rnd_state),\n              SVC(random_state=rnd_state),\n              KNeighborsClassifier(),\n              GaussianNB(),\n              DecisionTreeClassifier(random_state=rnd_state),\n              RandomForestClassifier(random_state=rnd_state),\n              GradientBoostingClassifier(random_state=rnd_state),\n              \n              # The below three models are extremely powerful but require extensive hyperparameter tuning\n              # Hence, they might not perform well here\n              XGBClassifier(random_state=rnd_state), \n              LGBMClassifier(random_state=rnd_state),\n              CatBoostClassifier(random_state=rnd_state),\n             ]","5800c704":"Main_Pipeline = imb_Pipeline([\n    ('feature_handler', FeatureTransformer(list(pearson_feature_vector.index))),\n    ('over', SMOTE()),\n    ('under', RandomUnderSampler()),\n    ('scaler', StandardScaler()),\n    ('pca', PCA(n_components=0.99)),\n    ('model', LogisticRegression()),\n])","9eae7672":"\"\"\"params_grid = [\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [LogisticRegression()], \n        'model__C': np.random.uniform(0.5, 2, 10),\n        'model__max_iter': np.random.randint(1500, 2000, 2),\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [SGDClassifier()],\n        'model__alpha': np.random.uniform(0, 1, 10),\n        'model__max_iter': np.random.randint(1500, 2000, 2),\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [SVC()],\n        'model__C': np.random.uniform(0, 2, 10),\n        'model__kernel': ['linear', 'poly', 'rbf', 'sigmoid'], \n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [KNeighborsClassifier()],\n        'model__n_neighbors': np.random.randint(2, 10, 7),\n        'model__weights': ['uniform', 'distance'],\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [GaussianNB()],\n    },\n \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [DecisionTreeClassifier()],\n        'criterion': ['gini', 'entropy'],\n        'model__max_iter': np.random.randint(1500, 2000, 2),\n        'model__max_depth': np.r_[np.random.randint(5, 15, 7), None],\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [RandomForestClassifier()],\n        'model__n_estimators': np.random.randint(90, 200, 10),\n        'model__criterion': ['gini', 'entropy'],\n        'model__max_depth': np.r_[np.random.randint(5, 15, 7), None],\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [GradientBoostingClassifier()],\n        'model__loss': ['deviance', 'exponential'],\n        'model__n_estimators': np.random.randint(90, 200, 10),\n        'model__learning_rate': np.random.uniform(0.00001, 1, 5),     # Remember, There is trade-off between learning_rate and n_estimators\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [XGBClassifier()],\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [LGBMClassifier()],\n    },\n    \n    {\n        'over': [ros, smote_sampler, adasyn_sampler],\n        'feature_handler__feature_vector': list(map(list, [pearson_feature_vector.index, pps_feature_vector.index])),\n        'pca__n_components': [1],\n        'model': [CatBoostClassifier()],\n    }\n]\"\"\"\n\n\n# param_grid for fast execution\nparams_grid = [{\n    \n    'over': [ros, smote_sampler, adasyn_sampler],\n    'feature_handler__feature_vector': list(map(list, [X.columns, pearson_feature_vector.index, pps_feature_vector.index])),\n    'model': model_list,  \n}]\n","af70f8f9":"main_grid_f1 = GridSearchCV(Main_Pipeline, params_grid, scoring='f1', cv=2, verbose=2)\nmain_grid_f1.fit(X_train, y_train)","0c0e2427":"main_grid_f1.best_estimator_","d222c20c":"f1_grid_results = pd.DataFrame(main_grid_f1.cv_results_)","b2f957fc":"f1_grid_results","f240697e":"y_pred = main_grid_f1.predict(X_test)\nprint(f1_score(y_test, y_pred))\naccuracy_score(y_test, y_pred)","97db9407":"confu_matr = confusion_matrix(y_test, y_pred)\n\nplot_confusion_matrix(conf_mat=confu_matr);","529371af":"main_grid_acc_s = GridSearchCV(Main_Pipeline, params_grid, scoring='accuracy', cv=2, verbose=2)\nmain_grid_acc_s.fit(X_train, y_train)","5cef158a":"main_grid_acc_s.best_estimator_","aeeee21c":"acc_grid_result = pd.DataFrame(main_grid_acc_s.cv_results_)","696c3ab7":"y_pred = main_grid_acc_s.predict(X_test)\naccuracy_score(y_test, y_pred)","79d7e1bc":"confu_matr = confusion_matrix(y_test, y_pred)\n\nplot_confusion_matrix(conf_mat=confu_matr);","2f762355":"f1_score(y_test, y_pred)","2ba14553":"We can perform feature selection using two methods:\n    1. Pearson's Correlation\n    2. PPscore (Predictive Power Score)\n    \n***Limitations of Pearson's corr:***\n<br>\nIt is not usefull for non-linear data (eg: y = $x^2$), this is taken care of by PPscore\n<br><br>\n***Limitations of PPscore:***\n<br>\nCalculating PPscore for a large set of features will be take a lot longer than Pearson's corr.<br>\nAlso, PPscore doesn't tell you about the type of relation (eg: directly proportional, inversely proportional), Hence, for linear relations, using Pearson's corr is a lot more useful\n\nFor more info check:<br>\nhttps:\/\/towardsdatascience.com\/rip-correlation-introducing-the-predictive-power-score-3d90808b9598\n\nGo through the entire blog, to understand when and when not to use PPscore","11d04b49":"### Checking for Imbalance:","8e03c318":"Before handling imbalance, let's first create train and test sets:","98b4b40a":"Doing same for columns starting with name 'A' and 'P', like we in Pearson's Corr.\n\nFrom this we can already see that PPscore is not looking good for our target variable.","322aa46a":"#### Important: Unlike Correlation matrix, PPscore matrix are not symmetric, the main reason for Invention of PPscore is to handle asymmetric nature of real-world data","63554e92":"##### Using Pearson's correlation, we got the above feature as important. Now, let's check using PPscore ","f39a3038":"# Handling Imbalance:","93abd8e1":"Yupp, We were are correct. The data we have is highly skewed\n\n#### We will handle this Imbalance using before feeding to the model","1273bfa2":"# Libraries:","ccfc688c":"The F1_score for Model selected using 'accuracy' as metric is abysmal. This is because the dataset is Severely Imbalanced, which causes poor sampling, even if use SMOTE and ADASYN.","60ff0f1c":"#### Loading the dataset: ","6ccca903":"We can see in _\"Lower Right\"_ Heatmap, that feature with names starting with 'A' and 'P' are very much similar.<br> (eg: $r$ = 0.9647738 for PBYSTAND & ABYSTAND, so we can obtain PBYSTAND from ABYSTAND or vice-versa)<br> Hence, having both present in the dataset is useless.\n\nLet's remove the one's starting with 'A' (psst, my name start's with 'P' :P)","fe51e7b2":"## For Model-Selection","684547f1":"We will be creating a pipeline and feeding the different Oversampling Handlers to the Grid Search","f244a0cf":"## For Pre-Processing:","7402576e":"### Checking Correlations:","f0ae187a":"#### Now that we have selected the feature using both the methods - Pearson's corr and PPscore, we will feed these feature vectors along with a vector containing all the feature into GridSearchCV. This is because many of the times it can happen, that certain features will provide unnecessary noise to the model instead of contributing towards better prediction. Now, next step is Imbalance Handling.","49d263c0":"### THANK YOU!","12635a30":"#### No null values","696ad206":"### Checking for null-values:","118f8793":"## For Handling Imbalance:","1593afd9":"# Model Selection:","a119c685":"#### We will also add a transformer which will manipulate the feature, according to Pearson's corr Feature vector, PPscore feature vector or complete feature vector.","52b0b1b3":"**Ques: What if n_components=1 in PCA?<br>\nAns: All the models except SVC(kernel='precomputed') will work perfectly fine. This is because 'precomputed' kernel requires a square matrix.**","e6ece49e":"## Performing Feature-Selection:\n\nRemember to not use **PCA** for Feature-Selection.\nLook at this blog for more info: https:\/\/towardsdatascience.com\/pca-is-not-feature-selection-3344fb764ae6","d59878d6":"#### We can clearly see two divides in the heatmap: upper-left & lower-right<br>\n#### Let's zoom in\n\nKeep the result of _timeit_ in mind, below we will also see for PPscore.","e554b2a1":"# Pre-processing:","e9121dfe":"#### PPscore:","1bf0d9bb":"#### Extracting Train and Test indices:","0f33d483":"We can see that Pearson's corr is approx 700x faster than pps, hence, for very fat datasets (large number of features) take care in using PPscore"}}