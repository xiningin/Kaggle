{"cell_type":{"de831412":"code","77d72964":"code","5db9ba2c":"code","dbae9ed3":"code","1a526d18":"code","2668e0a0":"code","bc10f308":"code","7895a640":"code","aa1e1b81":"code","f3aeaefd":"code","e140a03d":"code","325ccebd":"code","e2986764":"code","4d2d89b3":"code","50277e64":"code","77844afb":"markdown","df030473":"markdown","65dd2218":"markdown","01a9dbe2":"markdown","59a1d2f5":"markdown","fa066e12":"markdown","e68d2350":"markdown","00d9c77b":"markdown","653a1569":"markdown","c947b506":"markdown","8d18942d":"markdown","f8f2918e":"markdown"},"source":{"de831412":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\nfrom keras import backend as K\nfrom keras.applications import resnet50,inception_v3\nfrom keras.preprocessing import image\n!cp ..\/input\/testinp\/imagenetCIDS.py .\nimport imagenetCIDS\nprint(len(imagenetCIDS.idList),'imagenet classes')","77d72964":"def copyInputFile(fPathL,outDir) :\n    inFPath = os.path.join(*(['..','input']+fPathL))\n    outFPath = os.path.join(outDir,fPathL[-1])\n    if os.path.exists(outFPath) :\n        print(outFPath,'already exists')\n    else :\n        print('copying',inFPath)\n        print('->',outFPath)\n        with open(inFPath,'rb') as inF :\n            with open(outFPath,'wb') as outF :\n                outF.write(inF.read())\ndef loadKerasModel(mName,mClass,include_top=True) :\n    modelDir = os.path.expanduser(os.path.join('~', '.keras', 'models'))\n    if not os.path.exists(modelDir):\n        print('creating',modelDir)\n        os.makedirs(modelDir)\n    copyInputFile(['keras-pretrained-models','imagenet_class_index.json'],modelDir)\n    mFName = mName + '_weights_tf_dim_ordering_tf_kernels'\n    if not include_top :\n        mFName += '_notop'\n    copyInputFile(['keras-pretrained-models',mFName+'.h5'],\n                  modelDir)\n    return mClass(weights='imagenet',include_top=include_top)","5db9ba2c":"resnet = loadKerasModel('resnet50',resnet50.ResNet50)\nincept = loadKerasModel('inception_v3',inception_v3.InceptionV3)","dbae9ed3":"def displayImgArray(img,figsize=(12,10),axis='off') :\n    fig, ax = plt.subplots(1, figsize=figsize)\n    ax.imshow(img \/ 255.)\n    ax.axis(axis)\n    plt.show()\ndef checkOrigImage(fPath,disp=True,targSquareSize=224, distortToSquare=False) :\n    img = image.img_to_array(image.load_img(fPath))\n    imHeight,imWidth,_ = img.shape\n    print('original shape',img.shape)\n    if distortToSquare :\n        targWidth = targHeight = targSquareSize\n    else :\n        if imHeight <= imWidth :\n            targWidth = targSquareSize\n            targHeight = (targWidth*imHeight)\/\/imWidth\n        else :\n            targHeight = targSquareSize\n            targWidth = (targHeight*imWidth)\/\/imHeight\n    if disp :\n        displayImgArray(img)\n    return fPath,(targHeight,targWidth)\ndef loadSquareImage(origImageInfo,disp=True) :\n    fPath,targSize = origImageInfo\n    img = image.img_to_array(image.load_img(fPath, target_size=targSize))\n    if img.shape[0] != img.shape[1] :\n        squareImSize = max(img.shape[0],img.shape[1])\n        squareImg = np.zeros((squareImSize,squareImSize,img.shape[2]),img.dtype)\n        squareImg[:img.shape[0],:img.shape[1],:] = img\n        img = squareImg\n    if disp :\n        displayImgArray(img,(6,6))\n    return img","1a526d18":"origImInfo = checkOrigImage('..\/input\/testinp\/stbernard.jpg',distortToSquare=True)\nprint(origImInfo)","2668e0a0":"sqIm = loadSquareImage(origImInfo)","bc10f308":"meanVals = np.array([103.939, 116.779, 123.68]) # mean pixel values for resnet\ndef unprocessIm(img) :\n    \"\"\"undo the image preprocessing - works only with resnet!\"\"\"\n    img = img.copy()\n    for i,meanVal in enumerate(meanVals) :\n        img[..., i] += meanVal\n    img = img[...,::-1]\n    return img\ndef clipX(x) :\n    \"\"\"clip the processed image to valid bounds - works only with resnet!\"\"\"\n    np.minimum(x,255.0-meanVals,x)\n    np.maximum(x,-meanVals,x)\ndef classifyImg(img,mModule,model,doPrep=True,addLabel=None,thresh=0.05) :\n    if doPrep :\n        x = mModule.preprocess_input(np.expand_dims(img.copy(), axis=0))\n    else :\n        x = img\n    preds = model.predict(x)[0]\n    predInds = [(i,v) for i,v in enumerate(preds) if v>=thresh]\n    predInds.sort(key = lambda x : x[1], reverse=True)\n    if addLabel is not None and addLabel not in [i for i,v in predInds] :\n        predInds.append((addLabel,preds[addLabel]))\n    print([(imagenetCIDS.idList[i],v) for i,v in predInds])\n    return preds,predInds\ndef makeSpoof(img,mModule,model,spoofLabel,spoofThresh=0.1) :\n    model.compile('adam','mse')\n    print('trying to spoof',repr(imagenetCIDS.idList[spoofLabel]))\n    grads = model.optimizer.get_gradients(model.output[0][spoofLabel],model.input)\n    gradsFunc = K.function(inputs = [model.input], outputs = grads)\n    inp = np.expand_dims(img.copy(), axis=0)\n    print(inp.shape)\n    x = mModule.preprocess_input(inp)\n    for i in range(100) :\n        g = gradsFunc([x])\n        #print(np.max(g))\n        x += (1.0\/np.max(g[0]))*g[0]\n        clipX(x)\n        print(str(i)+':',end=' ')\n        preds,predInds = classifyImg(x,mModule,model,doPrep=False,addLabel=spoofLabel)\n        if spoofLabel==predInds[0][0] and preds[spoofLabel]>=spoofThresh :\n            break\n    return unprocessIm(x[0])","7895a640":"spoofIm = makeSpoof(sqIm,resnet50,resnet,spoofLabel=100) # 100 = Black Swan!","aa1e1b81":"displayImgArray(sqIm,(6,6))\n_ = classifyImg(sqIm,resnet50,resnet)\n_ = classifyImg(sqIm,inception_v3,incept)","f3aeaefd":"displayImgArray(spoofIm,(6,6))","e140a03d":"_ = classifyImg(spoofIm,resnet50,resnet)","325ccebd":"_ = classifyImg(spoofIm,inception_v3,incept)","e2986764":"diffIm = spoofIm-sqIm\nprint('min\/max pixel difference:',np.min(diffIm),np.max(diffIm))\nprint('average pixel difference:',np.average(np.abs(diffIm)))","4d2d89b3":"displayImgArray(np.abs(diffIm),(6,6))","50277e64":"displayImgArray((5.0*(diffIm-np.min(diffIm)))*(np.abs(diffIm)>=1.0),(6,6))","77844afb":"## Stats on differences between original and spoofed images","df030473":"## But is classified as a Black Swan by the spoofed NN model","65dd2218":"## Load pretrained NN models","01a9dbe2":"## Unless we bump up the contrast a lot","59a1d2f5":"## Spoofed image doesn't appear much different","fa066e12":"## Though the second NN model still says St. Bernard","e68d2350":"## Calculate the spoofed image using gradient descent on image pixels","00d9c77b":"## Directly visualizing the differences doesn't show much","653a1569":"This kernel shows a simple experiment with confusing an image classifying NN by applying gradient descent to the input image. We can apparently thoroughly confuse one NN (resnet50 in the example below) without much visible change to the image, and without confusing another NN classifier (inceptionV3 in the example below).","c947b506":"## Load St. Bernard image and resize for input to NN models","8d18942d":"## Load libraries","f8f2918e":"## Original image is classified as St. Bernard by both models"}}