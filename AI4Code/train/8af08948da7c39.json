{"cell_type":{"6dc2c618":"code","4ed56722":"code","1724521e":"code","c1d8a22c":"code","d1585dc7":"code","a3b56190":"code","6d71f2b6":"code","036e3511":"code","514e42de":"code","2ffdeb3f":"code","491b10c2":"code","d7d04c04":"code","83eab7bc":"code","8af38d80":"code","35d070d0":"code","9ad56540":"code","8f621442":"code","2415271f":"code","ad7d6d2f":"code","66c52438":"code","71ecf46c":"code","36516cd4":"code","c281a71d":"code","90dc2467":"code","cb2ac09a":"code","32cbdfc3":"code","afb86a2f":"code","c49705ee":"code","c51b8243":"code","27ffdd95":"code","d2cf97b8":"code","21e25204":"code","8e10c836":"code","edb555a4":"code","f94d8cd3":"code","062f8a16":"code","305d88ae":"code","db8a2e3d":"code","50c9c2bf":"code","35be3263":"code","1228faa8":"code","c4004798":"code","3cd41152":"code","f63ad910":"code","85640d6f":"code","3e6608fc":"code","f1594f44":"code","daa031ef":"code","4cd79842":"code","feb3e17d":"code","f555e714":"code","4bec7527":"code","3839b0f4":"code","256c5f68":"code","deec2117":"code","44412e49":"code","94caed9c":"code","c6312c70":"code","f9d10ef6":"code","8556be65":"code","e3793dfc":"code","1ce093dd":"code","0cbc240f":"code","c86eda65":"code","284479f4":"code","cb37cd67":"code","f835853b":"code","4e7c401b":"code","98cc9d21":"code","a510e5c0":"code","f7ba998e":"code","b5141601":"code","d492cf54":"code","c9900e8a":"code","d7c53aba":"code","012a15ed":"code","ecc1b247":"code","b49bafdb":"code","ebb32a8b":"code","bc6f845c":"code","cba01953":"code","d3f5479e":"code","5101b6b0":"code","c163b45b":"code","b036eecd":"code","d2f0ce2d":"code","8e7d65db":"code","03ce9fd6":"code","63b06186":"code","1654d03b":"code","df27d0de":"code","d652550f":"code","e656c8cd":"code","c4d1acf1":"code","d02dbb16":"code","4502cbbd":"code","58751fb4":"code","5bee2112":"code","0fbbe39f":"code","1e91c0d9":"code","ab40ad8e":"code","a03bcfcc":"code","eb6cc8c2":"code","de557628":"code","a3388858":"code","c09245be":"code","5cc6493c":"code","2b3b4bec":"code","e4b698d6":"code","3697b6e1":"code","387ccc84":"code","f423cc53":"markdown","de5fcced":"markdown","7fdfc8d5":"markdown","e3940046":"markdown","39e1be0f":"markdown","0833ea43":"markdown","d7385b4b":"markdown","14def311":"markdown","e6542887":"markdown","c4b4e1fe":"markdown","187fd419":"markdown","e20e724b":"markdown","5b8ee6aa":"markdown","4fc7cc49":"markdown","8e50148d":"markdown","3affe52e":"markdown","bd0950fb":"markdown","63159f2d":"markdown","b3491491":"markdown","e0ce64ed":"markdown","1c043fa1":"markdown","54061a4d":"markdown","a99589ba":"markdown","92b98ec4":"markdown","a02d1c23":"markdown","f89b05f5":"markdown","cc15c189":"markdown","d0dc070f":"markdown","dab94a0e":"markdown","f4072bff":"markdown"},"source":{"6dc2c618":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport os, re, sys\nimport time","4ed56722":"df_accidents = pd.read_csv('\/kaggle\/input\/road-accidents-belgium\/road_accidents_2005_2018.csv')","1724521e":"df_accidents.shape","c1d8a22c":"df_accidents.columns","d1585dc7":"df_accidents = df_accidents.drop(['Unnamed: 0','MS_ACCT_WITH_MORY_INJ',\n       'MS_ACCT_WITH_SERLY_INJ', 'MS_ACCT_WITH_SLY_INJ','MS_ACCT'],axis=1)","a3b56190":"cols = [c for c in df_accidents.columns if not c.endswith('FR')]\ncols\ndf_accidents=df_accidents[cols]","6d71f2b6":"df_accidents.columns","036e3511":"df_accidents.shape","514e42de":"df_accidents.head(5)","2ffdeb3f":"type(df_accidents['DT_DAY'].iloc[1])","491b10c2":"df_accidents['date'] = pd.to_datetime(df_accidents['DT_DAY'])\ndf_accidents = df_accidents.drop('DT_DAY',axis=1)","d7d04c04":"type(df_accidents['date'].iloc[1])","83eab7bc":"df_accidents['day'] = df_accidents['date'].apply(lambda date: date.day)\ndf_accidents['month'] = df_accidents['date'].apply(lambda date: date.month)\ndf_accidents['year'] = df_accidents['date'].apply(lambda date: date.year)\ndf_accidents['quarter'] = df_accidents['date'].apply(lambda date: date.quarter)","8af38d80":"df_accidents.index = pd.DatetimeIndex(df_accidents['date'])","35d070d0":"plt.figure(figsize=(15,6))\nplt.title('Distribution of accidents per day', fontsize=16)\nplt.tick_params(labelsize=14)\nsns.distplot(df_accidents.resample('D').size(), bins=60);","9ad56540":"accidents_daily = pd.DataFrame(df_accidents.resample('D').size())\naccidents_daily['MEAN'] = df_accidents.resample('D').size().mean()\naccidents_daily['STD'] = df_accidents.resample('D').size().std()\nUCL = accidents_daily['MEAN'] + 3 * accidents_daily['STD']\nLCL = accidents_daily['MEAN'] - 3 * accidents_daily['STD']\n\nplt.figure(figsize=(15,6))\ndf_accidents.resample('D').size().plot(label='Accidents per day')\nUCL.plot(color='red', ls='--', linewidth=1.5, label='UCL')\nLCL.plot(color='red', ls='--', linewidth=1.5, label='LCL')\naccidents_daily['MEAN'].plot(color='red', linewidth=2, label='Average')\nplt.title('Total accidents per day', fontsize=16)\nplt.xlabel('Day')\nplt.ylabel('Number of accidents')\nplt.tick_params(labelsize=14)\nplt.legend(prop={'size':16})","8f621442":"plt.figure(figsize=(15,6))\ndf_accidents.resample('M').size().plot(label='Total per month')\ndf_accidents.resample('M').size().rolling(window=12).mean().plot(color='red', linewidth=5, label='12-months Moving Average')\n\nplt.title('Accidents per month', fontsize=16)\nplt.xlabel('')\nplt.legend(prop={'size':16})\nplt.tick_params(labelsize=16)\n\n","2415271f":"plt.figure(figsize=(15,6))\nplt.title('Distribution of accidents per month', fontsize=16)\nplt.tick_params(labelsize=14)\nsns.distplot(df_accidents.resample('M').size(), bins=60);","ad7d6d2f":"accidents_daily = pd.DataFrame(df_accidents.resample('M').size())\naccidents_daily['MEAN'] = df_accidents.resample('M').size().mean()\naccidents_daily['STD'] = df_accidents.resample('M').size().std()\nUCL = accidents_daily['MEAN'] + 3 * accidents_daily['STD']\nLCL = accidents_daily['MEAN'] - 3 * accidents_daily['STD']\n\nplt.figure(figsize=(15,6))\ndf_accidents.resample('M').size().plot(label='Accidents per month')\nUCL.plot(color='red', ls='--', linewidth=1.5, label='UCL')\nLCL.plot(color='red', ls='--', linewidth=1.5, label='LCL')\naccidents_daily['MEAN'].plot(color='red', linewidth=2, label='Average')\nplt.title('Total accidents per month', fontsize=16)\nplt.xlabel('Month')\nplt.ylabel('Number of accidents')\nplt.tick_params(labelsize=14)\nplt.legend(prop={'size':16})","66c52438":"accidents_daily = pd.DataFrame(df_accidents.resample('Y').size())\naccidents_daily['MEAN'] = df_accidents.resample('Y').size().mean()\naccidents_daily['STD'] = df_accidents.resample('Y').size().std()\nUCL = accidents_daily['MEAN'] + 3 * accidents_daily['STD']\nLCL = accidents_daily['MEAN'] - 3 * accidents_daily['STD']\n\nplt.figure(figsize=(15,6))\ndf_accidents.resample('Y').size().plot(label='Accidents per year')\nUCL.plot(color='red', ls='--', linewidth=1.5, label='UCL')\nLCL.plot(color='red', ls='--', linewidth=1.5, label='LCL')\naccidents_daily['MEAN'].plot(color='red', linewidth=2, label='Average')\nplt.title('Total accidents per year', fontsize=16)\nplt.xlabel('Year')\nplt.ylabel('Number of accidents')\nplt.tick_params(labelsize=14)\nplt.legend(prop={'size':16})","71ecf46c":"df_accidents.columns","36516cd4":"### Remove duplicate text attributes","c281a71d":"df_accidents = df_accidents.drop(['TX_DAY_OF_WEEK_DESCR_NL','TX_BUILD_UP_AREA_DESCR_NL',\n                                 'TX_COLL_TYPE_DESCR_NL','TX_LIGHT_COND_DESCR_NL',\n                                 'TX_ROAD_TYPE_DESCR_NL','TX_MUNTY_DESCR_NL',\n                                 'TX_ADM_DSTR_DESCR_NL','TX_PROV_DESCR_NL',\n                                 'TX_RGN_DESCR_NL'],axis=1)","90dc2467":"df_accidents.columns","cb2ac09a":"df_accidents.isnull().sum()","32cbdfc3":"(df_accidents.isnull().sum())\/len(df_accidents)","afb86a2f":"attributes_missing = [att for att in df_accidents.columns if df_accidents[att].isnull().sum()>0 ]","c49705ee":"attributes_missing","c51b8243":"for att in attributes_missing:\n    \n    print(df_accidents[att].value_counts())","27ffdd95":"attributes_missing","d2cf97b8":"#replace nan's \n\nfor att in attributes_missing:\n    \n    if att == 'CD_BUILD_UP_AREA':\n        df_accidents[att].fillna(1.0, inplace = True) \n    elif att == 'CD_COLL_TYPE':\n        df_accidents[att].fillna(4.0, inplace = True) \n    elif att == 'CD_LIGHT_COND':\n        df_accidents[att].fillna(1.0, inplace = True) \n    elif att == 'CD_ROAD_TYPE':\n        df_accidents[att].fillna(2.0, inplace = True) \n    else:\n        df_accidents[att].fillna(10000.0, inplace = True)","21e25204":"df_accidents.isnull().sum()","8e10c836":"plt.figure(figsize=(15,8))\nsns.heatmap(df_accidents.corr().round(2),annot=True)","edb555a4":"df_accidents.columns","f94d8cd3":"# Create a pivot table by crossing the day number by the month and calculate the average number of accidents for each crossing\naccidents_pivot_table = df_accidents.pivot_table(values='date', index='day', columns='month', aggfunc=len)\naccidents_pivot_table_date_count = df_accidents.pivot_table(values='date', index='day', columns='month', aggfunc=lambda x: len(x.unique()))\naccidents_average = accidents_pivot_table\/accidents_pivot_table_date_count\naccidents_average.columns = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']\n\n# Using seaborn heatmap\nplt.figure(figsize=(7,9))\nplt.title('Average accidents per day and month', fontsize=14)\nsns.heatmap(accidents_average.round(), cmap='coolwarm', linecolor='grey',linewidths=0.1, cbar=False, annot=True, fmt=\".0f\")","062f8a16":"df_accidents = df_accidents.drop('date',axis=1)","305d88ae":"for att in df_accidents.columns:\n    plt.figure() #this creates a new figure on which your plot will appear\n    sns.countplot(df_accidents[att])","db8a2e3d":"df_accidents.shape","50c9c2bf":"df_accidents = df_accidents[df_accidents['MS_ACCT_WITH_DEAD_30_DAYS']!=2]","35be3263":"df_accidents = df_accidents[df_accidents['MS_ACCT_WITH_DEAD']!=2]","1228faa8":"df_accidents.shape","c4004798":"df_accidents.columns","3cd41152":"df_accidents = df_accidents.rename(index=str, columns={'CD_BUILD_UP_AREA':'where',\n                                                      'CD_COLL_TYPE':'how',\n                                                      'CD_ROAD_TYPE':'typeofroad',\n                                                      'CD_MUNTY_REFNIS':'refnismun',\n                                                      'CD_DSTR_REFNIS':'refnisdist',\n                                                      'CD_PROV_REFNIS':'refnisprov',\n                                                      'CD_RGN_REFNIS':'refnisgew',\n                                                      'CD_LIGHT_COND':'illumination',\n                                                      'MS_ACCT_WITH_DEAD':'dead',\n                                                      'MS_ACCT_WITH_DEAD_30_DAYS':'deadafter30d'})","f63ad910":"df_accidents.head()","85640d6f":"print(df_accidents['refnismun'].nunique())\nprint(df_accidents['refnisdist'].nunique())\nprint(df_accidents['refnisprov'].nunique())\nprint(df_accidents['refnisgew'].nunique())","3e6608fc":"df_accidents = df_accidents.drop(['refnisdist','refnisprov','refnisgew'],axis=1)","f1594f44":"df_accidents.head()","daa031ef":"df_accidents = df_accidents.reset_index()","4cd79842":"df_accidents = df_accidents.drop('date',axis=1)","feb3e17d":"df_accidents.head()","f555e714":"plt.figure(figsize=(10,6))\nsns.heatmap(df_accidents.corr().round(2),annot=True)","4bec7527":"df_accidents = df_accidents.drop(['deadafter30d','quarter'],axis=1)","3839b0f4":"df_accidents.head()","256c5f68":"df_accidents.columns","deec2117":"df_accidents.columns = ['hour', 'day_of_week', 'where', 'how', 'illumination',\n       'roadtype', 'refnismun', 'death', 'day_of_month', 'month', 'year']","44412e49":"df_accidents.head()","94caed9c":"df_accidents['year'] = df_accidents['year']-2000","c6312c70":"df_accidents.head()","f9d10ef6":"df_accidents = df_accidents.astype(int)","8556be65":"df_accidents.head()","e3793dfc":"df_accidents['refnismun'].unique()","1ce093dd":"plt.figure(figsize=(10,6))\nsns.heatmap(df_accidents.corr().round(2),annot=True)","0cbc240f":"# from sklearn.feature_selection import RFE #recursive feature elimination (RFE)\n# from sklearn.svm import SVR # Support Vector Regression\n# X = df_accidents.drop('death',axis=1)\n# X = X[:7000]\n# y = df_accidents['death']\n# y = y[:7000]\n# print(X.shape, y.shape)","c86eda65":"# estimator = SVR(kernel=\"linear\")\n# selector = RFE(estimator, n_features_to_select=5, step=1)","284479f4":"# selector = selector.fit(X, y)\n# selector.support_","cb37cd67":"#  selector.ranking_","f835853b":"df_accidents = df_accidents.drop('year',axis=1)","4e7c401b":"df_accidents.head()","98cc9d21":"plt.figure(figsize=(10,6))\nsns.heatmap(df_accidents.corr().round(2),annot=True)","a510e5c0":"df = df_accidents","f7ba998e":"sns.countplot(df['death'])","b5141601":"df['death'].value_counts()\/len(df)","d492cf54":"X = df.drop('death', axis=1).values\ny = df['death'].values","c9900e8a":"from imblearn.over_sampling import RandomOverSampler\n\n# define oversampling strategy\n\noversample = RandomOverSampler(sampling_strategy='minority')\n\n# fit and apply the transform\n\nX_over, y_over = oversample.fit_resample(X, y)\n\nfrom collections import Counter","d7c53aba":"# summarize class distribution\n\nprint(Counter(y))\n\n# summarize class distribution\n\nprint(Counter(y_over))","012a15ed":"fig, ((ax1, ax2)) = plt.subplots(1, 2, figsize=(14, 6), sharey=True)\nsns.countplot(df['death'], ax=ax1).set_title('Before')\nsns.countplot((y_over), ax=ax2).set_title('After')","ecc1b247":"X = X_over\ny = y_over\n\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.33, random_state=101)","b49bafdb":"from sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nscaler.fit(X_train)\n\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)","ebb32a8b":"from sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier","bc6f845c":"logmodel_over = LogisticRegression()\nlogmodel_over.fit(X_train, y_train)\n","cba01953":"rfc_over = RandomForestClassifier(n_estimators=100, verbose=100)\nrfc_over.fit(X_train,y_train)","d3f5479e":"#Predictions and Evaluations\n\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.metrics import plot_confusion_matrix","5101b6b0":"#Model performance on train dataset\n\ntraining_predictions = logmodel_over.predict(X_train)\n\nprint(classification_report(y_train, training_predictions))\nprint(confusion_matrix(y_train, training_predictions))\n\nplot_confusion_matrix(logmodel_over, X_train, y_train)","c163b45b":"plot_confusion_matrix(logmodel_over, X_train, y_train,normalize='true')","b036eecd":"#Model performance on test dataset\n\ntest_predictions = logmodel_over.predict(X_test)\n\nprint(classification_report(y_test, test_predictions))\nprint(confusion_matrix(y_test, test_predictions))\n\nplot_confusion_matrix(logmodel_over, X_test, y_test)","d2f0ce2d":"plot_confusion_matrix(logmodel_over, X_test, y_test,normalize='true')","8e7d65db":"#Model performance on train dataset\n\ntraining_predictions = rfc_over.predict(X_train)\n\nprint(classification_report(y_train, training_predictions))\nprint(confusion_matrix(y_train, training_predictions))\n\nplot_confusion_matrix(rfc_over, X_train, y_train)","03ce9fd6":"#Model performance on test dataset\n\ntest_predictions = rfc_over.predict(X_test)\n\nprint(classification_report(y_test, test_predictions))\nprint(confusion_matrix(y_test, test_predictions))\n\nplot_confusion_matrix(rfc_over, X_test, y_test)","63b06186":"X_test = df_accidents.drop('death', axis=1).values\ny_test = df_accidents['death'].values","1654d03b":"predictions_log_reg = logmodel_over.predict(X_test)\npredictions_rf = rfc_over.predict(X_test)","df27d0de":"print(classification_report(y_test, predictions_log_reg))\n\nprint(confusion_matrix(y_test, predictions_log_reg))\n\nplot_confusion_matrix(logmodel_over, X_test, y_test)\n","d652550f":"print(classification_report(y_test, predictions_rf))\n\nprint(confusion_matrix(y_test, predictions_rf))\n\nplot_confusion_matrix(rfc_over, X_test, y_test)","e656c8cd":"X = df.drop('death', axis=1).values\ny = df['death'].values","c4d1acf1":"from imblearn.under_sampling import RandomUnderSampler\n\n# define undersampling strategy\n\noversample = RandomUnderSampler(sampling_strategy='majority')\n\n# fit and apply the transform\n\nX_over, y_over = oversample.fit_resample(X, y)\n\nfrom collections import Counter","d02dbb16":"# summarize class distribution\n\nprint(Counter(y))\n\n# summarize class distribution\n\nprint(Counter(y_over))","4502cbbd":"fig, ((ax1, ax2)) = plt.subplots(1, 2, figsize=(14, 6), sharey=True)\nsns.countplot(df['death'], ax=ax1).set_title('Before')\nsns.countplot((y_over), ax=ax2).set_title('After')","58751fb4":"X = X_over\ny = y_over\n\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.33, random_state=101)","5bee2112":"from sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nscaler.fit(X_train)\n\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)","0fbbe39f":"logmodel_under = LogisticRegression()\nlogmodel_under.fit(X_train, y_train)\n\nrfc_under = RandomForestClassifier(n_estimators=100,verbose=100)\nrfc_under.fit(X_train,y_train)","1e91c0d9":"#Model performance on train dataset\n\ntraining_predictions = logmodel_under.predict(X_train)\n\nprint(classification_report(y_train, training_predictions))\nprint(confusion_matrix(y_train, training_predictions))\n\nplot_confusion_matrix(logmodel_under, X_train, y_train)","ab40ad8e":"#Model performance on test dataset\n\ntest_predictions = logmodel_under.predict(X_test)\n\nprint(classification_report(y_test, test_predictions))\nprint(confusion_matrix(y_test, test_predictions))\n\nplot_confusion_matrix(logmodel_under, X_test, y_test)","a03bcfcc":"#Model performance on train dataset\n\ntraining_predictions = rfc_under.predict(X_train)\n\nprint(classification_report(y_train, training_predictions))\nprint(confusion_matrix(y_train, training_predictions))\n\nplot_confusion_matrix(rfc_under, X_train, y_train)","eb6cc8c2":"#Model performance on test dataset\n\ntest_predictions = rfc_under.predict(X_test)\n\nprint(classification_report(y_test, test_predictions))\nprint(confusion_matrix(y_test, test_predictions))\n\nplot_confusion_matrix(rfc_under, X_test, y_test)","de557628":"X_test = df_accidents.drop('death', axis=1).values\ny_test = df_accidents['death'].values","a3388858":"predictions_log_reg = logmodel_under.predict(X_test)\npredictions_rf = rfc_under.predict(X_test)","c09245be":"print(classification_report(y_test, predictions_log_reg))","5cc6493c":"print(confusion_matrix(y_test, predictions_log_reg))","2b3b4bec":"plot_confusion_matrix(logmodel_under, X_test, y_test)","e4b698d6":"print(classification_report(y_test, predictions_rf))\n\n","3697b6e1":"print(confusion_matrix(y_test, predictions_rf))","387ccc84":"\nplot_confusion_matrix(rfc_under, X_test, y_test)","f423cc53":"Logistic regression","de5fcced":"### RF","7fdfc8d5":"* deadafter30d and dead are highly correlated. Remove deadafter30d.\n* Quarter and month is also duplicate information. Remove quarter.","e3940046":"RF","39e1be0f":"#### Explore REFNIS\n\nhttps:\/\/en.wikipedia.org\/wiki\/Provinces_of_Belgium\nThe country of Belgium is divided into three regions. Two of these regions, the Flemish Region or Flanders, and Walloon Region, or Wallonia, are each subdivided into five provinces. The third region, the Brussels-Capital Region, is not divided into provinces, as it was originally only a small part of a province itself. \n\nhttps:\/\/nl.wikipedia.org\/wiki\/NIS-code\nThe NIS code (Dutch: NIS-code, French: code INS) is an alphanumeric code for regional areas of Belgium.\nThis code is used for statistical data treatment in Belgium. This code was developed mid-1960s by the Statistics Belgium. It was first used for the census of 1970. \n\n\nhttps:\/\/statbel.fgov.be\/nl\/open-data\/refnis-code\nBelgium is classified according to a hierarchical system that the French introduced in 1796. The administrative division is based on four territorial units: regions, provinces, administrative districts and municipalities. The municipalities are the basic units, which means that each higher level territorial unit consists of different municipalities.\n\n   Level 1: 3 regions\n    Level 2: 10 provinces\n    Level 3: 43 administrative districts\n    Level 4: 581 municipalities (589 to 31\/12\/2018) --- sanity check: length of CD_MUNTY_REFNIS also 589\n    Level 5: Boroughs\n    Level 7: Statistical sectors\n\nhttps:\/\/nl.wikipedia.org\/wiki\/Arrondissement\nA district is part of the territory of the state, which is divided up for administrative or administrative reasons. Each district is an area of responsibility of colleges and civil servants (working for a government). It is originally from French and literally means completion.\n\nhttps:\/\/nl.wikipedia.org\/wiki\/Deelgemeente_(Belgi%C3%AB)\nA sub-municipality in Belgium is the territory of the former municipalities that were still independent before the major municipal redivisions in the 1960s-70s\n\nSource REFNIS file: https:\/\/statbel.fgov.be\/nl\/over-statbel\/methodologie\/classificaties\/geografie","0833ea43":"# Model ","d7385b4b":"### Predictions","14def311":"## Data source: https:\/\/statbel.fgov.be\/en\/open-data.<br>\n\n-License: 'Licentie open data' which is compatible with the Creative Commons Attribution 2.0 license <br>https:\/\/creativecommons.org\/licenses\/by\/2.0","e6542887":"# EDA","c4b4e1fe":"# Deathly road accidents Belgium (2005-2018)  ","187fd419":"RF","e20e724b":"## Training on undersampled datasets","5b8ee6aa":"#### Will focus on deadly accidents, remove other outcomes","4fc7cc49":"#### Predictions","8e50148d":"CD_BUILD_UP_AREA (where)\n\n* 1.0 = Within built-up areas (in residential area)\n* 2.0 = Outside built-up areas\n* 3.0 = Not available \n\nCD_COLL_TYPE\n\n* 1.0 = Chain collision (4 drivers or more)\n* 2.0 = Frontal impact (or when crossing)\n* 3.0 = Along the back (or side by side)\n* 4.0 = Sideways\n* 5.0 = With a pedestrian\n* 6.0 = Against an obstacle on the roadway\n* 7.0 = Against an obstacle outside the roadway\n\nCD_LIGHT_COND\n\n* 1.0 # In broad daylight\n* 3.0 # Night, public lighting turned on\n* 5.0 # Not available\n* 2.0 # Dawn - twilight\n* 4.0 # Night, no public lighting\n\nCD_ROAD_TYPE\n\n* 2.0 Regional road, provincial road or municipal road\n* 1.0 Motorway\n* 3.0 Unknown\n\nTX_RGN_DESCR_NL\n\n* Vlaams Gewest 2000                    \n*  Waals Gewest 3000                     \n* Brussels Hoofdstedelijk Gewest 4000     \n\n","3affe52e":"#### Remove french descriptions (FR columns)","bd0950fb":"RF","63159f2d":"### Fit","b3491491":"* ['hour', 'day_of_week', 'where', 'how', 'illumination', 'roadtype','refnismun', 'day_of_month', 'month', 'year']\n\n\n* 1000: array([4, 1, 1, 1, 1, 3, 1, 5, 2, 6])\n* 5000: array([5, 1, 1, 3, 1, 1, 4, 1, 2, 6])\n* 7000: array([3, 4, 1, 1, 1, 1, 5, 2, 1, 6])\n* 10000: CPU can't handle\n* 40000:45000 : CPU can't handle?! They're also 5000 instances..\n\n\n* Reocurring 1's in all 3: 'where','illumination'. But still I will use all of them to model. Can't rely on these relatively few instances used for RFE.\n* 'year' can be removed, also makes sense that the year can't influence individual instances so much.","e0ce64ed":"## Training on oversampled datasets","1c043fa1":"Logistic reg\n","54061a4d":"With only 1.5% of the dataset being deathly accidents, it will be difficult (impossible) to build an good model.","a99589ba":"Logistic reg","92b98ec4":"Cardinality refers to the number of unique values contained in a particular column, or field, of a database. ","a02d1c23":"# Test undersampled models on entire dataset","f89b05f5":"Find most informative features","cc15c189":"#### Fit","d0dc070f":"### Logistic regression","dab94a0e":"# Test oversampled models on entire dataset","f4072bff":"Let's focus on municipalities and remove district, province and region (gewest)."}}