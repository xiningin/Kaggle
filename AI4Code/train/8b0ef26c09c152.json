{"cell_type":{"70302b46":"code","7cecdfb1":"code","5460cc73":"code","39095185":"code","7b7c8e6e":"code","6c8b3609":"code","4af6604d":"code","5a70425c":"code","76d60e3b":"markdown","438acd18":"markdown","b045b00b":"markdown","4b65e16d":"markdown","4e576e5d":"markdown"},"source":{"70302b46":"# TODO: add z3-solver to kaggle-docker image\n! pip3 install -q z3-solver","7cecdfb1":"import z3\nimport numpy as np\nimport itertools\nimport sys\nimport math\nimport time\nimport timeit\nimport signal\nfrom typing import List\nfrom numba import njit\n\nnotebook_start = time.perf_counter()","5460cc73":"def generate_primes(count):\n    primes = [2]\n    for n in range(3, sys.maxsize, 2):\n        if len(primes) >= count: break\n        if all( n % i != 0 for i in range(3, int(math.sqrt(n))+1, 2) ):\n            primes.append(n)\n    return primes\n\n\n#      10 primes generated in:    0.01 ms\n#     100 primes generated in:    0.32 ms\n#    1000 primes generated in:    6.99 ms\n#  10,000 primes generated in:  153.21 ms\n# 100,000 primes generated in: 4831.97 ms\nprint( generate_primes(42) )\nprint( f'     10 primes generated in: {timeit.timeit(lambda: generate_primes(     10), number=10)\/10*1000:7.2f} ms' )\nprint( f'    100 primes generated in: {timeit.timeit(lambda: generate_primes(    100), number=10)\/10*1000:7.2f} ms' )\nprint( f'   1000 primes generated in: {timeit.timeit(lambda: generate_primes(  1_000), number=10)\/10*1000:7.2f} ms' )\nprint( f' 10,000 primes generated in: {timeit.timeit(lambda: generate_primes( 10_000), number=10)\/10*1000:7.2f} ms' )\n# print( f'100,000 primes generated in: {timeit.timeit(lambda: generate_primes(100_000), number=10)\/10*1000:7.2f} ms' )","39095185":"def z3_is_prime(x):\n    y = z3.Int(\"y\")\n    return z3.Or([\n        x == 2,              # 2 is the only even prime\n        z3.And(\n            x > 1,           # x is positive\n            x % 1 == 0,      # x is int\n            x % 2 != 0,      # x is odd\n            z3.Not(z3.Exists([y], z3.And(\n                y   > 1,     # y is positive\n                y*y < x,     # y < sqrt(x)\n                y % 2 != 0,  # y is odd\n                x % y == 0   # y is not a divisor of x\n            )))\n        )\n    ])\n\n\ndef z3_generate_primes(count):\n    output = []\n\n    number = z3.Int('prime')\n    solver = z3.Solver()\n    solver.add([ number > 1, number % 1 == 0 ])  # is positive int\n    solver.add([ z3_is_prime(number) ])          # must be a prime, obviously\n    solver.push()\n\n    domain = 2\n    while len(output) < count:\n        solver.pop()\n        solver.push()\n        solver.add([ number < domain ])  # this helps prevent unsat\n        solver.add(z3.And([ number != value for value in output ]))\n        while solver.check() == z3.sat:\n            value = solver.model()[number].as_long()\n            solver.add([ number != value ])\n            output.append( value )\n            if len(output) >= count: break\n        domain *= 2  # increment search space\n    return sorted(output)\n\nassert len(z3_generate_primes(24)) == 24\nprint( 'z3: ', z3_generate_primes(24) )\nprint( 'std:', generate_primes(24) )\n\n\n#   2 primes generated in:    12.8 ms\n#   4 primes generated in:    17.8 ms\n#   8 primes generated in:    38.0 ms\n#  16 primes generated in:    86.8 ms\n#  32 primes generated in:   246.1 ms\n#  64 primes generated in:  1655.1 ms\n# 128 primes generated in: 14740.5 ms\nfor n in [2,4,8,16,32,64,128]:\n    print( f'{n:3d} primes generated in: {timeit.timeit(lambda: z3_generate_primes(n), number=1)\/1*1000:7.1f} ms' )","7b7c8e6e":"def z3_generate_summable_primes(size=50, combinations=2, timeout=0) -> List[int]:\n    candidates = [ z3.Int(n) for n in range(size) ]\n    summations = []\n    for n_combinations in range(1,combinations+1):\n        summations += [\n            z3.Sum(group)\n            for group in itertools.combinations(candidates, n_combinations)\n        ]\n\n    solver = z3.Solver()\n    if timeout: solver.set(\"timeout\", int(timeout * 1000\/2.5))  # timeout is in milliseconds, but inexact and ~2.5x slow\n\n    solver.add([ num > 1      for num in candidates ])\n    solver.add([ num % 1 == 0 for num in candidates ])\n    solver.add([ candidates[n] < candidates[n+1] for n in range(len(candidates)-1) ])  # sorted\n\n    # solver.add([ z3_is_prime(num) for num in candidates ])\n    # primes = z3_generate_primes(128)\n\n    solver.add( z3.Distinct(candidates) )\n    solver.add( z3.Distinct(summations) )\n    solver.push()\n    domain = 2\n    while True:\n        solver.pop()\n        solver.push()\n\n        primes = generate_primes(domain)\n        solver.add([ z3.Or([ num == prime for prime in primes ])\n                     for num in candidates ])\n        solver.add([ num < domain for num in candidates ])\n\n        if solver.check() != z3.sat:\n            domain *= 2\n        else:\n            values = sorted([ solver.model()[num].as_long() for num in candidates ])\n            return list(values)","6c8b3609":"try:\n    timeout = 5*60*60\n    def raise_timeout(signum, frame): raise TimeoutError    # DOC: https:\/\/docs.python.org\/3.6\/library\/signal.html\n    signal.signal(signal.SIGALRM, raise_timeout)            # Register a function to raise a TimeoutError on the signal.\n    signal.alarm(timeout)                                   # Schedule the signal to be sent after ``time``.\n    \n    for size in range(10,50+1):\n        for combinations in [size]:  # range(2,size+1):\n            time_start      = time.perf_counter()\n            hashable_primes = z3_generate_summable_primes(size=size, combinations=combinations, timeout=timeout)\n            time_taken      = time.perf_counter() - time_start\n            print(f'size = {size:2d} | combinations = {combinations} | time = {time_taken:7.1f}s | ', hashable_primes)        \n        print()\nexcept   TimeoutError as exception: print('timeout')\nfinally: signal.alarm(0)","4af6604d":"primes_np = np.array( generate_primes(100_000), dtype=np.int64 )\n\n@njit()\ndef generate_hashable_primes(size=50, combinations=2) -> np.ndarray:\n    \"\"\"\n    Return a list of primes that have no summation collisions for N=2, for use in hashing\n    NOTE: size > 50 or combinations > 2 produces no results\n    \"\"\"\n    domain     = primes_np\n    candidates = np.zeros((0,), dtype=np.int64)\n    exclusions = set()\n    while len(candidates) < size:  # loop until we have successfully filled the buffer\n        # refill candidates ignoring exclusions\n        for n in range(len(domain)):\n            prime = np.int64( domain[n] )\n            if not np.any( candidates == prime ):\n                if prime not in exclusions:\n                    candidates = np.append( candidates, prime )\n                    if len(candidates) >= size: break\n        else:\n            return np.zeros((0,), dtype=np.int64)  # prevent infinite loop if we run out of primes\n\n        # This implements itertools.product(*[ candidates, candidates, candidates ]\n        collisions = set(candidates)\n        indexes    = np.array([ 0 ] * combinations)\n        while np.min(indexes) < len(candidates)-1:\n\n            # Sum N=combinations candidate primes and check for duplicate collisions, then exclude and try again\n            values = candidates[indexes]\n            summed = np.sum(values)\n            if summed in collisions:  # then remove the largest conflicting number from the list of candidates\n                exclude    = np.max(candidates[indexes])\n                candidates = candidates[ candidates != exclude ]\n                exclusions.add(exclude)\n                break  # pick a new set of candidates and try again\n            collisions.add(summed)\n\n            # This implements itertools.product(*[ candidates, candidates, candidates ]\n            indexes[0] += 1\n            for i in range(len(indexes)-1):\n                while np.count_nonzero( indexes == indexes[i] ) >= 2:\n                    indexes[i] += 1                    # ensure indexes are unique\n                if indexes[i] >= len(candidates):      # overflow to next buffer\n                    indexes[i]    = np.min(indexes)+1  # for triangular iteration\n                    indexes[i+1] += 1\n    return candidates","5a70425c":"combinations = 2\nfor size in [5, 25, 50, 100, 150]:\n    time_start = time.perf_counter()\n    hashable_primes = generate_hashable_primes(size=size, combinations=combinations)\n    time_taken = time.perf_counter() - time_start\n    print(f'combinations = {combinations} | size = {size} | time = {time_taken:.0f}s\\n', hashable_primes, '\\n')\n    if len(hashable_primes) == 0: break\n        \ncombinations = 3\nfor size in range(2,25):\n    time_start = time.perf_counter()\n    hashable_primes = generate_hashable_primes(size=size, combinations=combinations)\n    time_taken = time.perf_counter() - time_start\n    print(f'combinations = {combinations} | size = {size} | time = {time_taken:.0f}s\\n', hashable_primes, '\\n')\n    if len(hashable_primes) == 0: break","76d60e3b":"# Summable Primes\n\nGeometric Invariant Hash Functions are relevant to grid worlds experiencing wraparound ([closed manifolds](https:\/\/en.wikipedia.org\/wiki\/Closed_manifold)) in [Conway's Reverse Game of Life](https:\/\/www.kaggle.com\/c\/conway-s-reverse-game-of-life) and [Halite](https:\/\/www.kaggle.com\/c\/halite) and are also relevant to the [Abstraction and Reasoning Corpus](https:\/\/www.kaggle.com\/c\/abstraction-and-reasoning-challenge). They have the property of being invariant to `np.roll()` and optionally `np.flip()` and `np.rot90()`\n\nTo achieve this, we also need access to a set of Summable Prime Numbers. \n\nAccording to the [Unique Factorization Theorem](https:\/\/en.wikipedia.org\/wiki\/Fundamental_theorem_of_arithmetic) the product of any combination of primes results in a unique number. This is not guaranteed to be true for summation, but it is possible through search to find a subset of prime numbers for which this property holds true. This property is important for preventing hash collisions.\n\nHowever for the purpose of hashing functions, it may also be useful to have a set of summable prime numbers, such that the sum of any combination of them will also produce a unique number.\n\nThis notebook will use the [Z3 Theorm Prover](https:\/\/github.com\/Z3Prover\/z3) to prove that such a set exists.\n\nThis research is required for the following notebooks:  \n- https:\/\/www.kaggle.com\/jamesmcguigan\/geometric-invariant-hash-functions\n- https:\/\/www.kaggle.com\/jamesmcguigan\/game-of-life-hashmap-solver","438acd18":"# Z3 Prime Numbers\n\nThis can also be implemented in Z3 using first order logic.\n\nNote that Z3 only promises to return from the set of all primes, which are not always the first N primes. Z3 is also a couple of orders of magnitude slower than our simple loop solution.\n\nMany of the additional constraints added to this solver, such as `x % 1 == 0` (is int), `x % 2 != 0` (is even), and iteratively increasing the `domain` where required to improve the performance of the solver. \n\nIt is also much more performant, and less likely to produce `unsat`, to repeatedly solve for a single prime, and iteratively add constraints that exclude previously found primes, than it is to pass use a `z3.Distinct()` clause on an array of `Ints`.","b045b00b":"# Hashable Primes\n\nAs Z3 is very slow at generating large lists of Summable Primes, and that for [Geometric Invariant Hash Functions](https:\/\/www.kaggle.com\/jamesmcguigan\/geometric-invariant-hash-functions) we need a list at least twice as large as the board size (ie 50 to hash a 25x25 board), we need a quicker method to generate useful numbers.\n\nFor the purposes of this implemention, we reduce the constraint to that of being no pairwise sum collisions between numbers in the set, rather than requiring the sum of any combinations of numbers to be unique.","4b65e16d":"# Summable Primes\n\nThis generates a list of prime numbers, such that all combinations of the sum of these numbers produces a unique value.\n\nPrevious results:\n```\nsize =  2 | combinations = 2 | time =     0.0s |  [2, 3]\n\nsize =  3 | combinations = 2 | time =     0.0s |  [2, 3, 7]\nsize =  3 | combinations = 3 | time =     0.0s |  [2, 3, 7]\n\nsize =  4 | combinations = 2 | time =     0.0s |  [3, 7, 11, 13]\nsize =  4 | combinations = 3 | time =     0.0s |  [2, 3, 7, 13]\nsize =  4 | combinations = 4 | time =     0.0s |  [2, 3, 7, 13]\n\nsize =  5 | combinations = 2 | time =     0.1s |  [7, 17, 19, 23, 31]\nsize =  5 | combinations = 3 | time =     0.1s |  [7, 17, 23, 29, 31]\nsize =  5 | combinations = 4 | time =     0.2s |  [7, 13, 17, 19, 31]\nsize =  5 | combinations = 5 | time =     0.3s |  [2, 7, 19, 23, 31]\n\nsize =  6 | combinations = 2 | time =     0.1s |  [2, 3, 11, 19, 23, 29]\nsize =  6 | combinations = 3 | time =     0.1s |  [3, 13, 17, 23, 29, 31]\nsize =  6 | combinations = 4 | time =     0.1s |  [3, 13, 17, 23, 29, 31]\nsize =  6 | combinations = 5 | time =     0.1s |  [3, 13, 17, 23, 29, 31]\nsize =  6 | combinations = 6 | time =     0.2s |  [3, 13, 17, 23, 29, 31]\n\nsize =  7 | combinations = 2 | time =     1.1s |  [5, 7, 13, 17, 29, 43, 61]\nsize =  7 | combinations = 3 | time =     1.7s |  [3, 17, 31, 37, 41, 43, 59]\nsize =  7 | combinations = 4 | time =     3.1s |  [2, 13, 67, 103, 107, 113, 127]\nsize =  7 | combinations = 5 | time =     3.3s |  [2, 3, 23, 31, 79, 83, 127]\nsize =  7 | combinations = 6 | time =     3.4s |  [2, 5, 11, 29, 59, 103, 113]\nsize =  7 | combinations = 7 | time =     3.8s |  [3, 11, 13, 17, 29, 61, 113] \n\nsize =  8 | combinations = 2 | time =     0.3s |  [2, 3, 7, 17, 23, 29, 41, 59]\nsize =  8 | combinations = 3 | time =     1.9s |  [3, 5, 7, 11, 17, 53, 83, 109]\nsize =  8 | combinations = 4 | time =  1213.3s |  [3, 31, 53, 67, 71, 97, 103, 109]\nsize =  8 | combinations = 5 | time =  1221.1s |  [3, 29, 61, 71, 89, 101, 107, 113]\nsize =  8 | combinations = 6 | time =   492.7s |  [3, 31, 53, 71, 89, 97, 103, 109]\nsize =  8 | combinations = 7 | time =   355.4s |  [3, 31, 53, 71, 89, 97, 103, 109]\nsize =  8 | combinations = 8 | time =  4217.6s |  [3, 61, 71, 89, 101, 107, 113, 127]\n\nsize =  9 | combinations = 2 | time =     1.8s |  [11, 19, 23, 71, 73, 97, 107, 113, 127]\nsize =  9 | combinations = 3 | time =  2302.3s |  [3, 67, 71, 89, 97, 131, 197, 241, 251]\nsize =  9 | combinations = 4 | time =  8796.2s |  [2, 5, 37, 331, 337, 347, 359, 431, 509]\nsize =  9 | combinations = 5 | time =  5388.6s |  [2, 3, 11, 23, 89, 137, 307, 487, 491]\nsize =  9 | combinations = 6 | time =  3644.8s |  [2, 31, 43, 61, 163, 167, 263, 449, 509]\nsize =  9 | combinations = 7 | time =   732.5s |  [3, 5, 7, 43, 71, 277, 421, 503, 509]\nsize =  9 | combinations = 9 | time =    15.1s |  [2, 3, 223, 337, 367, 449, 491, 499, 503]\nsize =  9 | combinations = 9 | time = 10130.9s |  [2, 29, 37, 73, 97, 101, 149, 293, 487]\n```","4e576e5d":"# Generating Prime Numbers\n\nA simple but consise way of generating small prime numbers"}}