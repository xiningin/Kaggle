{"cell_type":{"980bef71":"code","61a54663":"code","9205d749":"code","7433918e":"code","3f051831":"code","2456b9dc":"code","42e7bf21":"code","bad15d22":"code","a04d2824":"code","ad36cb85":"code","7d8f64ba":"code","69fe74c6":"code","815a173a":"code","c5b299ce":"code","238d9380":"code","9732637a":"code","693329b7":"code","8aa037a7":"markdown","549dd321":"markdown","08fea05f":"markdown","68193324":"markdown"},"source":{"980bef71":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","61a54663":"pip install snap-stanford","9205d749":"import snap","7433918e":"erdosRenyi = None\nsmallWorld = None\ncollabNet = None","3f051831":"edges = 0\ndef genErdosRenyi(N=5242, E=14484):\n    \"\"\"\n    :param - N: number of nodes\n    :param - E: number of edges\n\n    return type: snap.PUNGraph\n    return: Erdos-Renyi graph with N nodes and E edges\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here!\n    Graph = snap.TUNGraph.New(N, E)\n    for i in range(N):\n        Graph.AddNode(i)\n        \n    edges = 0\n    Rnd = snap.TRnd(42)\n    Rnd.Randomize()\n    while edges < E:\n        SrcNId = Graph.GetRndNId(Rnd)\n        DstNId = Graph.GetRndNId(Rnd)\n        if SrcNId != DstNId and not Graph.IsEdge(SrcNId, DstNId): # check it's not self-loop and nonexistent edge\n            Graph.AddEdge(SrcNId, DstNId)\n            edges += 1\n    ############################################################################\n    return Graph","2456b9dc":"def genCircle(N=5242):\n    \"\"\"\n    :param - N: number of nodes\n\n    return type: snap.PUNGraph\n    return: Circle graph with N nodes and N edges. Imagine the nodes form a\n        circle and each node is connected to its two direct neighbors.\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here!\n    Graph = snap.TUNGraph.New(N, N)\n    for i in range(N):\n        Graph.AddNode(i)\n    \n    for i in range(1, N):\n        Graph.AddEdge(i-1, i)\n    Graph.AddEdge(N-1, 0)\n    ############################################################################\n    return Graph","42e7bf21":"def connectNbrOfNbr(Graph, N=5242):\n    \"\"\"\n    :param - Graph: snap.PUNGraph object representing a circle graph on N nodes\n    :param - N: number of nodes\n\n    return type: snap.PUNGraph\n    return: Graph object with additional N edges added by connecting each node\n        to the neighbors of its neighbors\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here!\n    for i in range(N):\n        Graph.AddEdge(i, (i + 2) % N)\n    ############################################################################\n    return Graph","bad15d22":"def connectRandomNodes(Graph, M=4000):\n    \"\"\"\n    :param - Graph: snap.PUNGraph object representing an undirected graph\n    :param - M: number of edges to be added\n\n    return type: snap.PUNGraph\n    return: Graph object with additional M edges added by connecting M randomly\n        selected pairs of nodes not already connected.\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here!\n    pairs = []\n    for i in range(Graph.GetNodes()):\n        for j in range(i+1, Graph.GetNodes()): # iterate from (i+1) for avoid self-loop\n            if not Graph.IsEdge(i, j): # check for nonexistense of edge\n                pairs.append((i, j))\n                \n    indexs = np.random.randint(0, len(pairs), M) # generate indexs for random pairs of nodes\n    pairs = np.array(pairs)\n    randPairs = pairs[indexs]\n    \n    for pair in randPairs:\n        Graph.AddEdge(int(pair[0]), int(pair[1])) # add picked-out edges\n    ############################################################################\n    return Graph","a04d2824":"def genSmallWorld(N=5242, E=14484):\n    \"\"\"\n    :param - N: number of nodes\n    :param - E: number of edges\n\n    return type: snap.PUNGraph\n    return: Small-World graph with N nodes and E edges\n    \"\"\"\n    Graph = genCircle(N)\n    Graph = connectNbrOfNbr(Graph, N)\n    Graph = connectRandomNodes(Graph, 4000)\n    return Graph","ad36cb85":"def loadCollabNet(path):\n    \"\"\"\n    :param - path: path to edge list file\n\n    return type: snap.PUNGraph\n    return: Graph loaded from edge list at `path and self edges removed\n\n    Do not forget to remove the self edges!\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here!\n    Graph = snap.LoadEdgeList(snap.PUNGraph, '\/kaggle\/input\/ml-in-graphs-hw1\/ca-GrQc.txt', 0, 1)\n    for node in Graph.Nodes(): # remove the self edges\n        if Graph.IsEdge(node.GetId(), node.GetId()):\n            Graph.DelEdge(node.GetId(), node.GetId())\n    ############################################################################\n    return Graph","7d8f64ba":"def getDataPointsToPlot(Graph):\n    \"\"\"\n    :param - Graph: snap.PUNGraph object representing an undirected graph\n\n    return values:\n    X: list of degrees\n    Y: list of frequencies: Y[i] = fraction of nodes with degree X[i]\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here!\n    X, Y = [], []\n    DegToCntV = snap.TIntPrV() # a vector of (degree, number of nodes of such degree) pairs\n    snap.GetDegCnt(Graph, DegToCntV) # computes a degree histogram: a vector of pairs (degree, number of nodes of such degree)\n    for item in DegToCntV:\n        X.append(item.GetVal1()) # list of degrees\n        Y.append(np.float(item.GetVal2()) \/ np.float(Graph.GetNodes())) # list of frequencies\n    ############################################################################\n    return X, Y","69fe74c6":"def Q1_1():\n    \"\"\"\n    Code for HW1 Q1.1\n    \"\"\"\n    global erdosRenyi, smallWorld, collabNet\n    erdosRenyi = genErdosRenyi(5242, 14484)\n    smallWorld = genSmallWorld(5242, 14484)\n    collabNet = loadCollabNet(\"ca-GrQc.txt\")\n    \n    plt.figure(figsize=(10,7))\n    \n    x_erdosRenyi, y_erdosRenyi = getDataPointsToPlot(erdosRenyi)\n    plt.loglog(x_erdosRenyi, y_erdosRenyi, color = 'y', label = 'Erdos Renyi Network')\n\n    x_smallWorld, y_smallWorld = getDataPointsToPlot(smallWorld)\n    plt.loglog(x_smallWorld, y_smallWorld, linestyle = 'dashed', color = 'r', label = 'Small World Network')\n\n    x_collabNet, y_collabNet = getDataPointsToPlot(collabNet)\n    plt.loglog(x_collabNet, y_collabNet, linestyle = 'dotted', color = 'b', label = 'Collaboration Network')\n    \n    plt.grid(True, which=\"both\", color=\"0.75\")\n    plt.xlabel('Node Degree (log)')\n    plt.ylabel('Proportion of Nodes with a Given Degree (log)')\n    plt.title('Degree Distribution of Erdos Renyi, Small World, and Collaboration Networks')\n    plt.legend()\n    plt.show()","815a173a":"# Execute code for Q1.1\nQ1_1()","c5b299ce":"def calcClusteringCoefficientSingleNode(Node, Graph):\n    \"\"\"\n    :param - Node: node from snap.PUNGraph object. Graph.Nodes() will give an\n                   iterable of nodes in a graph\n    :param - Graph: snap.PUNGraph object representing an undirected graph\n\n    return type: float\n    returns: local clustering coeffient of Node\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here!\n    C = 0.0\n    if Node.GetDeg() < 2: # if we have NodeDegree < 2 return 0\n        return C\n    \n    for i in range(Node.GetDeg()):\n        for j in range(i + 1, Node.GetDeg()):\n            if Graph.IsEdge(Node.GetNbrNId(i), Node.GetNbrNId(j)): \n                # check existense of edge between i-th and j-th neighboring node.\n                C += 1\n    \n    C = 2. * C \/ (Node.GetDeg() * (Node.GetDeg() - 1)) \n    #  = 2 * numbEdgesBetweenNeibors \/ (ki * (ki - 1)) for each node, ki - Node-i's degree\n    ############################################################################\n    return C","238d9380":"def calcClusteringCoefficient(Graph):\n    \"\"\"\n    :param - Graph: snap.PUNGraph object representing an undirected graph\n\n    return type: float\n    returns: clustering coeffient of Graph\n    \"\"\"\n    ############################################################################\n    # TODO: Your code here! If you filled out calcClusteringCoefficientSingleNode,\n    #       you'll probably want to call it in a loop here\n    C = 0.0\n    for node in Graph.Nodes():\n        C_ = calcClusteringCoefficientSingleNode(node, Graph)\n        C += C_\n    C = C \/ np.float(Graph.GetNodes()) # averaging for all nodes\n    ############################################################################\n    return C","9732637a":"def Q1_2():\n    \"\"\"\n    Code for Q1.2\n    \"\"\"\n    C_erdosRenyi = calcClusteringCoefficient(erdosRenyi)\n    C_smallWorld = calcClusteringCoefficient(smallWorld)\n    C_collabNet = calcClusteringCoefficient(collabNet)\n\n    print('Clustering Coefficient for Erdos Renyi Network: %f' % C_erdosRenyi)\n    print('Clustering Coefficient for Small World Network: %f' % C_smallWorld)\n    print('Clustering Coefficient for Collaboration Network: %f' % C_collabNet)","693329b7":"# Execute code for Q1.2\nQ1_2()","8aa037a7":"## 1 Network Characteristics","549dd321":"### 1.2 Clustering Coefficient","08fea05f":"Notebook was created with using [HW1-bundle](https:\/\/docs.google.com\/uc?export=download&id=1xoPFKf78PrdGEELQYtomXpkFD8QFj6sI) template by cs224w","68193324":"### 1.1 Degree Distribution"}}