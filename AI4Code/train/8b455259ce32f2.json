{"cell_type":{"b9fffe31":"code","d9469010":"code","ed61e948":"code","f85ff8b5":"code","4fceabd3":"code","263e5a3d":"code","f3c3e707":"code","ebfe880c":"code","eead3ff4":"code","56c151f4":"code","67485fe6":"code","c0d76c16":"code","2b529bd6":"code","942ec665":"code","f687f10f":"code","bcb6b6f5":"code","7012dfb9":"code","27323ea6":"markdown","96c39ba7":"markdown"},"source":{"b9fffe31":"import numpy as np \nimport pandas as pd \nfrom torch.utils.data import Dataset, DataLoader\nimport torchvision.transforms as transforms\nimport matplotlib.pyplot as plt\nimport torch\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\npd.set_option(\"display.max_columns\",None)\n\nimport torch.nn as nn\n","d9469010":"PATH = \"..\/input\/digit-recognizer\/\"","ed61e948":"train = pd.read_csv(PATH+\"train.csv\")\ntest = pd.read_csv(PATH+\"test.csv\")\nss = pd.read_csv(PATH+\"sample_submission.csv\")","f85ff8b5":"train.head()","4fceabd3":"test.head()","263e5a3d":"plt.imshow(np.array(train.iloc[4,1:]).reshape(-1,28),cmap=\"gray\")","f3c3e707":"input_size = 28*28\nlearning_rate = 0.001\nhidden_size = 100\nnum_classes = 10\nnum_epochs = 20\nbatch_size = 100","ebfe880c":"class TRAIN_DATASET(Dataset):\n    \n        \n    def __init__(self,csv_file,transform = None):\n        self.data = pd.read_csv(csv_file)\n        self.transform = transform\n        \n    def __len__(self):\n        return len(self.data)\n        \n    def __getitem__(self,index):\n        \n        ##reshaping\n        img = np.array(self.data.iloc[index,1:]).reshape((1,28*28))\n        label = np.array(self.data.iloc[index,0])\n        img = torch.from_numpy(img).float()\n        label = torch.from_numpy(label).type(torch.LongTensor)\n        \n        \n        sample = {\"image\":img,\"label\":label}\n        \n        return sample\n    ","eead3ff4":"class ToTensor(object):\n    \"\"\"Convert ndarrays in sample to Tensors.\"\"\"\n\n    def __call__(self, sample):\n        image, label = sample['image'], sample['label']\n\n        # swap color axis because\n        # numpy image: H x W x C\n        # torch image: C X H X W\n        return {'image': torch.from_numpy(image),\n                'label': torch.from_numpy(label)}","56c151f4":"train_dataset = TRAIN_DATASET(PATH+\"train.csv\",transform = None)\n","67485fe6":"class TEST_DATASET(Dataset):\n    \n        \n    def __init__(self,csv_file,transform = None):\n        self.data = pd.read_csv(csv_file)\n        self.transform = transform\n        \n    def __len__(self):\n        return len(self.data)\n        \n    def __getitem__(self,index):\n        \n        ##reshaping\n        img = np.array(self.data.iloc[index,:]).reshape((1,28*28))\n        img = torch.from_numpy(img).float()\n                       \n        return img\n    ","c0d76c16":"test_dataset = TEST_DATASET(PATH+\"test.csv\",transform = None)","2b529bd6":"train_loader = DataLoader(train_dataset, batch_size=100,\n                        shuffle=True, num_workers=4)\n                        \ntest_loader = DataLoader(test_dataset,batch_size = 100,shuffle=False,num_workers = 4) ","942ec665":"example = next(iter(train_loader))\nimage = example['image'].view(-1,28*28)\n","f687f10f":"class Net(nn.Module):\n    def __init__(self,input_size,hidden_size, num_classes):\n        super(Net, self).__init__()\n        self.l1 = nn.Linear(input_size,hidden_size)\n        self.relu = nn.ReLU()\n        self.l2 = nn.Linear(hidden_size,num_classes)\n        \n    def forward(self, x):\n        out  = self.l1(x)\n        out = self.relu(out)\n        out = self.l2(out)\n        \n        return out\n","bcb6b6f5":"model = Net(input_size,hidden_size,num_classes)\n\ncriterion  = nn.CrossEntropyLoss()\n\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)","7012dfb9":"n_total_steps = int(len(train_loader)\/100)\ncount = 0\nloss_list = []\niteration_list = []\naccuracy_list = []\n\nfor i in range(num_epochs):\n    for j,sample in enumerate(train_loader):\n        images = sample['image']\n     \n        labels = sample['label']\n        \n        images = images.view(-1,28*28)\n        \n        outputs = model(images)\n        loss = criterion(outputs,labels)\n        \n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        \n        \n        print(f'epoch {i+1} \/ {num_epochs} , step{j+1}\/ {n_total_steps},loss = {loss.item():.4f}')\n    \n    if i%4==0:\n        \n        torch.save(model.state_dict(),f'model{i}.pth')","27323ea6":"this is completed till our model .  evaluation on test set is remaining that i will do it soon or also you can go on your own do some research if you are facing any problem till that i will complete the next part      happy coding will appreciate an upvote if you like it ;)","96c39ba7":"DataLoader"}}