{"cell_type":{"a30164ff":"code","0c68e246":"code","8f214dfe":"code","b7980774":"code","633eaed8":"code","927b6468":"code","5485a940":"code","b779491b":"code","5e4b1962":"code","91217121":"code","aa501318":"code","a0da2c4a":"code","a2aa28f7":"code","e1bc4433":"code","c6dcb67f":"code","67cbda44":"code","7dfae673":"markdown","af6d9bbf":"markdown","45a5d900":"markdown","4ca6a6f4":"markdown","651a408b":"markdown","70a8187b":"markdown","bbb92914":"markdown","890e8397":"markdown","ae14d28c":"markdown","704048c7":"markdown","8d4b269d":"markdown"},"source":{"a30164ff":"!pip install pylandau","0c68e246":"import numpy as np\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport seaborn as sns\nimport scipy.optimize as so\nimport scipy.stats as ss\nfrom scipy.special import erfc, gamma\nimport pylandau\n\nmpl.rc('figure', figsize=(8, 5), dpi=150)","8f214dfe":"df = pd.read_csv('\/kaggle\/input\/rpc-event-charge\/rpc_data_kaggle.csv', index_col=0)\n# Voltage is a float but we like it int better\ndf['voltage'] = df.voltage.astype(int)\ndf.head()","b7980774":"axs = (df.query('is_detected and event_type == 1')\n       .groupby('voltage').event_charge\n       .plot\n       .hist(bins=np.arange(0, 10, 0.2), histtype='step', legend=True))\naxs.iloc[0].set_xlabel('Event charge [pC]');","633eaed8":"for ix, group in df.query('is_detected and event_type == 1').groupby('voltage'):\n    bins, edges = np.histogram(group.event_charge, bins=np.arange(0, 100, 0.1))\n    plt.plot(edges[:-1], bins, label=f'voltage={ix} V')\nplt.xlim(0, 20)\nplt.ylabel('Counts')\nplt.xlabel('Event Charge [pC]')\nplt.legend();","927b6468":"subset = df.query('is_detected and event_type == 1 and voltage == 9721')\nsubset.event_charge","5485a940":"k, loc, scale = ss.exponnorm.fit(subset.event_charge)\ndistribution = ss.exponnorm(k, loc, scale)\nx_generated = distribution.rvs(size=100_000)\nplt.hist(subset.event_charge, density=True, bins='auto', histtype='step', label='data')\nplt.hist(x_generated, density=True, bins='auto', histtype='step', label='fit')\nplt.title('Exponnorm')\nplt.legend()","b779491b":"# Use scipy.optimize.minimize with a SLSQP method\n# to solve the minimization problem\ndef optimizer(func, x0, args, disp=0):\n    res = so.minimize(func, x0, args, options={'disp': True}, method='SLSQP')\n    print(res.success)\n    print(res.message)\n    return res.x\n\na, loc, scale = ss.gamma.fit(subset.event_charge, optimizer=optimizer)\ndistribution = ss.gamma(a, loc, scale)\nx_generated = distribution.rvs(size=100_000)\nplt.hist(subset.event_charge, density=True, bins='auto', histtype='step', label='data')\nplt.hist(x_generated, density=True, bins='auto', histtype='step', label='fit')\nplt.title('Gamma')\nplt.legend()","5e4b1962":"# Use scipy.optimize.minimize with a SLSQP method\n# to solve the minimization problem\ndef optimizer(func, x0, args, disp=0):\n    res = so.minimize(func, x0, args, options={'disp': True}, method='Nelder-Mead')\n    print(res.success)\n    print(res.message)\n    return res.x\n\nm, b, loc, scale = ss.crystalball.fit(subset.event_charge, optimizer=optimizer)\ndistribution = ss.crystalball(m, b, loc, scale)\nx_generated = distribution.rvs(size=100_000)\nx_generated = x_generated[x_generated != -np.inf]\nplt.hist(subset.event_charge, density=True, bins='auto', histtype='step', label='data')\nplt.hist(x_generated, density=True, bins='auto', histtype='step', label='fit')\nplt.title('Crystall ball')\nplt.legend()","91217121":"# Use scipy.optimize.minimize with a SLSQP method\n# to solve the minimization problem\ndef optimizer(func, x0, args, disp=0):\n    res = so.minimize(func, x0, args, options={'disp': True}, method='Nelder-Mead')\n    print(res.success)\n    print(res.message)\n    return res.x\n\nm, b, loc, scale = pylandau.langau_pdf.fit(subset.event_charge, optimizer=optimizer)\ndistribution = ss.crystalball(m, b, loc, scale)\nx_generated = distribution.rvs(size=100_000)\nx_generated = x_generated[x_generated != -np.inf]\nplt.hist(subset.event_charge, density=True, bins='auto', histtype='step', label='data')\nplt.hist(x_generated, density=True, bins='auto', histtype='step', label='fit')\nplt.title('Crystall ball')\nplt.legend()","aa501318":"import warnings\nwarnings.simplefilter(\"ignore\")\n\ndef optimizer(func, x0, args, disp=0):\n    res = so.minimize(func, x0, args, options={'maxiter': 5000}, method='Powell')\n    return res.x\n\nfunctions = {\n    'gamma': [1],\n    'exponnorm': [1],\n    'crystalball': [],\n    'norm': [],\n}\nresults = {}\n\nfig, axs = plt.subplots(3, 3, figsize=(4*5, 4*4), dpi=120)\n\nfor ix, (voltage, group) in enumerate(df.query('is_detected and event_type == 1').groupby('voltage')):\n    results[voltage] = {}\n    ax = axs.flat[ix]\n    test_set = group.event_charge\n    ax.hist(test_set, density=True, bins='auto', alpha=0.3, histtype='stepfilled');\n    for function_name, params in functions.items():\n        function = ss.__dict__[function_name]\n        fit_results = function.fit(test_set, optimizer=optimizer)\n        kstest_results = ss.kstest(test_set, function_name, args=fit_results)\n        x = np.linspace(0, 20, 200)\n        y = function.pdf(x, *fit_results)\n        fit_results = [round(v, 2) for v in fit_results]\n        ax.plot(x, y, label=f'{function_name} params = {fit_results} k.s. stats = {kstest_results.statistic:.3f}')\n        results[voltage][function_name] = {\n            'kstest': kstest_results,\n        }\n    ax.legend()\n    ax.set_xlim(0, 20)","a0da2c4a":"functions = {\n    'gamma': (lambda x, a, b: b**a * x**(a-1) * np.exp(-b*x) \/  gamma(a), (1, 1)),\n    'exponnorm': (lambda x, h, m, s, t: h*s\/t * np.sqrt(np.pi\/2) * np.exp(1\/2*(s\/t)**2 - (x-m)\/t)*erfc(1\/np.sqrt(2) * (s\/t - (x-m)\/s)), (1, 1, 1, 1)),\n    #'norm': (lambda x, m, s: 1\/(s*np.sqrt(2*np.pi)) * np.exp(-1\/2 * ((x-m)\/2)**2), (1, 1))\n    # \"landau\": (pylandau.landau, (30, 5, 4, 1000)),\n    # \"langau\": (pylandau.langau, (5., 2, 0.1))\n}\nresults = {}\n\nfig, axs = plt.subplots(3, 3, figsize=(4*5, 4*4), dpi=120)\n\nfor ix, (voltage, group) in enumerate(df.query('is_detected and event_type == 1').groupby('voltage')):\n    results[voltage] = {}\n    ax = axs.flat[ix]\n    test_set = group.event_charge\n    ax.hist(test_set, density=True, bins='auto', alpha=0.3, histtype='stepfilled');\n    for function_name, (function, params) in functions.items():\n        y, x = np.histogram(test_set, bins='auto', density=True)\n        x = x[:-1]\n        popt, pcov = so.curve_fit(function, x, y, p0=params)\n        chi2 = np.sum((y - function(x, *popt)**2)) \/ (len(x) - len(params))\n        popt = [round(p, 2) for p in popt]\n        x = np.linspace(0, 20, 200)\n        y = function(x, *popt)\n        ax.plot(x, y, label=f'{function_name} params = {popt} chi2\/ndf = {chi2:.2e}')\n        results[voltage][function_name] = {\n            'chi2test': chi2\n        }\n    ax.legend()\n    ax.set_xlim(0, 20)\n    results","a2aa28f7":"np.percentile?","e1bc4433":"results = pd.DataFrame()\nfor ix, (voltage, group) in enumerate(df.query('is_detected and event_type == 1').groupby('voltage')):\n    data = group.event_charge\n\n    lower_err = np.median(data) - np.percentile(data, 5)\n    upper_err = np.percentile(data, 95) - np.median(data)\n    \n    median = data.quantile(0.5)\n    mean = data.mean()\n    mode_standard = ss.mode(data).mode[0]\n    counts, edges = np.histogram(data, bins='sqrt')\n    mode_binned = edges[counts.argmax()]\n    results = results.append([{\n        'voltage': voltage,\n        'lower_err': lower_err,\n        'upper_err': upper_err,\n        'median': median,\n        'mean': mean,\n        'mode_standard': mode_standard,\n        'mode_binned': mode_binned\n    }])\n    \nplt.errorbar(results.voltage, results['median'], yerr=(results.lower_err, results.upper_err), fmt='x', \n             capsize=5, elinewidth=2, markeredgewidth=2, label='median')\nplt.plot(results.voltage, results.mode_standard, '^', label='mode standard')\nplt.plot(results.voltage, results.mode_binned, '<', label='mode binned')\nplt.plot(results.voltage, results['mean'], 'v', label='mean')\nplt.legend()\nplt.ylim(0, 10)","c6dcb67f":"df.query('is_detected and event_type == 1').boxplot(column='event_charge', by='voltage', )\nplt.ylim(0, 10)","67cbda44":"sns.boxplot(data=df.query('is_detected and event_type == 1'), x='voltage', y='event_charge', showfliers=False, )\nplt.ylim(0, 10)","7dfae673":"As you can see the distribution of `event_charge` is changing when the `voltage` is changing. I would like to summarize the results by means of two estimators: one representing somehow the central or mean value and another one giving information about the spread or the variance of the samples.","af6d9bbf":"Let's try also with a crystall ball function","45a5d900":"Let's fit the function to a gamma one. This time we need to use a custom function to find the minimum as the default one is not able to locate the best initial parameters by itself","4ca6a6f4":"# Using percentiles to estimate the spread\n\nInstead of fitting data to a distribution we could use quartiles or some other percentiles to give information about the distribution. This can be done thanks to the fat that the distribution is resembling a skewed normal one, so there are no pathologies or weird features","651a408b":"Let's try to run all the functions over the different `event_charge` samples","70a8187b":"Here the same approach is taken but the data is binned into an histogram and the functions are fitted with `scipy.optimize.curve_fit`. The $\\chi^2$ is manually computed from the parameters.","bbb92914":"Let's fit the dataset to an exponentially modified normal distribution:","890e8397":"Here below we query for all the detected events of type `1` (i.e. `avalanche` signals). We groub by each voltage and make an histogram plot of the event_charge in the first 5 pC","ae14d28c":"# Fit statistical functions to data\n\nHere below few functions from [scipy stats](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/stats.html) will be used to fit the `event_charge` at different voltage. To evaluate the goodness of fit the [chi squared test](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.stats.chisquare.html#scipy.stats.chisquare) and the [Kolmogorv Smirnov test](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.stats.kstest.html#scipy.stats.kstest) will be used","704048c7":"# Are these distributions following some particular pdf?\n\nThe plot here below is similary to the histogram made before but it's expressed as a line plot","8d4b269d":"This notebook contains the analysis on Resistive Plate Chambers detectors. The data is in form of a pandas datframe where each row represent one event (i.e. an acquisition form the electronics that is triggered by an external source). For each row there is the stored the collected `event_charge`, the type of signal (`1=avalanche, 3=streamer, 0=noise, -1=uncategorized`), depending on the `event_charge` (expressed as `pC` units) and other parameters not relevant here. There is also one columns `is_detected` that states if the RPC detector has effectively recognized a particle and classifies the event as a 'detection event'.\n\nThe detector efficiency is defined as the number of `is_detected` event over the total number of events. This efficiency is a value that is generally increasing by increasing the voltage at which the RPC is operated.\n\nBy increasing the voltage you can see that the `event_charge` distribution is also changing. The goal is to find suitable estimators for the `event_charge` distribution at different `voltage` values."}}