{"cell_type":{"8d2966d2":"code","067cf6ab":"code","b97dbbef":"code","0a9aa636":"code","9e72f6e6":"code","9d891cfb":"code","5f0dc9a7":"code","2d543aef":"code","b3a9b44a":"code","8cc6ec0b":"code","6b81dea3":"code","0d137357":"code","56d8c7c1":"code","79649368":"code","638dbe27":"code","ece19de9":"code","be0176f1":"code","ed8cc331":"code","f07fe019":"code","615a9d8a":"code","a2fe3143":"code","ebc43770":"code","40904696":"code","19293f7e":"code","9fb7fa29":"code","55c06b82":"code","83286065":"code","c424eb8f":"code","06c26181":"markdown","8c99e97d":"markdown","b9310ca0":"markdown","b83cd263":"markdown","2f31744b":"markdown","806f61dc":"markdown","e1264c56":"markdown","f0942819":"markdown","7dbe424a":"markdown","852c4a70":"markdown","5c89466e":"markdown","9fe4ff23":"markdown","ef1368da":"markdown","a6008214":"markdown","91dcf21e":"markdown","459e8245":"markdown","ea009607":"markdown","ab67adf6":"markdown","de1560ce":"markdown","fe564adf":"markdown","3c1d5b26":"markdown","2c35f000":"markdown","bfb0ca3e":"markdown","e428513c":"markdown","5d9b3aeb":"markdown","250df317":"markdown","18b7dab1":"markdown","0a6ba30d":"markdown"},"source":{"8d2966d2":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom IPython.core.display import display, HTML\nimport plotly.graph_objects as go\nimport warnings\nimport datetime\nimport math\nfrom scipy.optimize import minimize\n","067cf6ab":"# Configure Jupyter Notebook\npd.set_option('display.max_columns', None) \npd.set_option('display.max_rows', 500) \npd.set_option('display.expand_frame_repr', False)\n# pd.set_option('max_colwidth', -1)\ndisplay(HTML(\"<style>div.output_scroll { height: 35em; }<\/style>\"))\n\n%matplotlib inline\n%config InlineBackend.figure_format ='retina'\n\nwarnings.filterwarnings('ignore')","b97dbbef":"# the number of days into the future for the forecast\ndays_forecast = 30","0a9aa636":"# download the latest data sets\nconf_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Confirmed.csv')\ndeaths_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Deaths.csv')\nrecv_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Recovered.csv')","9e72f6e6":"# create full table\ndates = conf_df.columns[4:]\n\nconf_df_long = conf_df.melt(id_vars=['Province\/State', 'Country\/Region', 'Lat', 'Long'], \n                            value_vars=dates, var_name='Date', value_name='Confirmed')\n\ndeaths_df_long = deaths_df.melt(id_vars=['Province\/State', 'Country\/Region', 'Lat', 'Long'], \n                            value_vars=dates, var_name='Date', value_name='Deaths')\n\nrecv_df_long = recv_df.melt(id_vars=['Province\/State', 'Country\/Region', 'Lat', 'Long'], \n                            value_vars=dates, var_name='Date', value_name='Recovered')\n\nfull_table = pd.concat([conf_df_long, deaths_df_long['Deaths'], recv_df_long['Recovered']], \n                       axis=1, sort=False)\n","9d891cfb":"# avoid double counting\nfull_table = full_table[full_table['Province\/State'].str.contains(',')!=True]","5f0dc9a7":"# cases \ncases = ['Confirmed', 'Deaths', 'Recovered', 'Active']\n\n# Active Case = confirmed - deaths - recovered\nfull_table['Active'] = full_table['Confirmed'] - full_table['Deaths'] - full_table['Recovered']\n\n# replacing Mainland china with just China\nfull_table['Country\/Region'] = full_table['Country\/Region'].replace('Mainland China', 'China')\n\n# filling missing values \nfull_table[['Province\/State']] = full_table[['Province\/State']].fillna('')","2d543aef":"# Display the number cases globally\ndf = full_table.groupby(['Country\/Region', 'Province\/State'])['Confirmed', 'Deaths', 'Recovered', 'Active'].max()\ndf = full_table.groupby('Date')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()\ndf =  df[df['Date']==max(df['Date'])].reset_index(drop=True)\ndf","b3a9b44a":"# count the number cases per country\ndf = full_table[full_table['Date'] == max(full_table['Date'])].reset_index()\ndf = df.groupby('Country\/Region')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()\ndf = df.sort_values(by='Confirmed', ascending=False)\ndf = df.reset_index(drop=True)\ndf.style.background_gradient(cmap='coolwarm')","8cc6ec0b":"# count the number of provinces\/states per country\ncountries = list(set(full_table['Country\/Region']))\ncountries.sort()\ndf_cluster_count = pd.DataFrame(countries,columns=['Countries'])\ndf_cluster_count['Clusters']=0\n\nfor country in countries:\n    df = full_table[(full_table['Country\/Region'] == country)]\n    clusters = len(set(df['Province\/State']))\n    df_cluster_count['Clusters'][df_cluster_count['Countries']==country]=clusters\n\ndf_cluster_count = df_cluster_count.sort_values(by=['Clusters'],ascending=False)\ndf_cluster_count.style.background_gradient(cmap='coolwarm')","6b81dea3":"countries = list(set(full_table['Country\/Region']))\ncountries.sort()\n\n# NOTE: the number of charts for all countries makes this notebook large. It is better to work with sub-sets\ncountries = ['South Africa', 'China','Italy','Korea, South', 'Iran', 'Germany', 'Spain', 'Australia']\n#countries = ['South Africa']\n\n\nfor country in countries:\n    def get_time_series(country):\n        df = full_table[(full_table['Country\/Region'] == country)]\n        df = df.groupby(['Date','Country\/Region']).sum().reset_index()\n        df['Date'] = pd.to_datetime(df['Date'])\n        df = df.sort_values(by=['Date'])\n        return df.set_index('Date')[['Confirmed']]\n\n    df = get_time_series(country)\n\n    # ensure that the model starts from when the first case is detected\n    df = df[df[df.columns[0]]>0]\n\n    # define the models to forecast the growth of cases\n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * (t))) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n\n    # create series to be plotted \n    x_actual = pd.to_datetime(df.reset_index().iloc[:,0])\n    x_actual =list(x_actual)\n    y_actual = list(df.reset_index().iloc[:,1])\n\n    start_date = pd.to_datetime(df.index[0])\n\n    x_model = []\n    y_model = []\n\n    # get the model values for the same time series as the actuals\n    for t in range(len(df) + days_forecast):\n        x_model.append(start_date + datetime.timedelta(days=t))\n        y_model.append(round(model(*opt,t)))\n\n    # instantiate the figure and add the two series - actual vs modelled    \n    fig = go.Figure()\n    fig.update_layout(title=country,\n                      xaxis_title='Date',\n                      yaxis_title=\"nr People\",\n                      autosize=False,\n                      width=700,\n                      height=500,\n                     )\n\n    fig.add_trace(go.Line(x=x_actual,\n                          y=y_actual,\n                          mode='markers',\n                          name='Actual',\n                          marker=dict(symbol='circle-open-dot', \n                                      size=9, \n                                      color='black', \n                                      line_width=1.5,\n                                     )\n                         ) \n                 )    \n\n    fig.add_trace(go.Line(x=x_model,\n                          y=y_model,\n                          mode='lines',\n                          name=\"Today's Prediction\",\n                          line=dict(color='blue', \n                                    width=2.5\n                                   )\n                         ) \n                 ) \n\n    \n    # drop the last row of dataframe to model yesterday's results\n    df.drop(df.tail(1).index,inplace=True)\n\n    # define the models to forecast the growth of cases\n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * (t))) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n\n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n    \n    try:\n        start_date = pd.to_datetime(df.index[0])\n\n        x_model = []\n        y_model = []\n\n        # get the model values for the same time series as the actuals\n        for t in range(len(df) + days_forecast):\n            x_model.append(start_date + datetime.timedelta(days=t))\n            y_model.append(round(model(*opt,t)))\n\n\n        # now plot the new series\n        fig.add_trace(go.Line(x=x_model,\n                              y=y_model,\n                              mode='lines',\n                              name=\"Yesterday's Prediction\",\n                              line=dict(color='Red', \n                                        width=1.5,\n                                        dash='dot'\n                                       )\n                             ) \n                     )\n    except:\n        pass\n    \n    fig.show()","0d137357":"country = 'China'","56d8c7c1":"clusters = list(set(full_table['Province\/State'][(full_table['Country\/Region'] == country)]))\nclusters.sort()\nprint('there are ' + str(len(clusters)) + ' clusters (provinces\/states) found for ' + country)","79649368":"# print the results of each cluster\n\n# first set up the country dataframe\ndf = full_table[(full_table['Country\/Region'] == country)]\ndf = df.groupby(['Date','Country\/Region']).sum().reset_index()\ndf['Date'] = pd.to_datetime(df['Date'])\ndf = df.sort_values(by=['Date'])\ndf_country = df.copy()\ndf_country = df_country[['Date','Confirmed']]\n\ndf_length = len(df_country) + days_forecast\n\n# then evaluate each cluster\nfor cluster in clusters:\n    df = full_table[(full_table['Country\/Region'] == country) & (full_table['Province\/State'] == cluster)]\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    df = df.set_index('Date')[['Confirmed']]\n    df = df[df[df.columns[0]]>0]\n    \n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * t)) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n\n#     opt = minimize(model_loss, x0=np.array([100000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n    \n    # create actual series to be plotted \n    x_actual = pd.to_datetime(df.reset_index().iloc[:,0])\n    x_actual = list(x_actual)\n    y_actual = list(df.reset_index().iloc[:,1])\n    \n    # create modelled series to be plotted\n    start_date = pd.to_datetime(df.index[0])\n    x_model = []\n    y_model = []\n    for t in range(len(df) + days_forecast):\n        x_model.append(start_date + datetime.timedelta(days=t))\n        y_model.append(round(model(*opt,t)))\n\n    # instantiate the figure and add the two series - actual vs modelled    \n    fig = go.Figure()\n    fig.update_layout(title=country + ' - ' + cluster,\n                      xaxis_title='Date',\n                      yaxis_title=\"nr People\",\n                      autosize=False,\n                      width=700,\n                      height=500,\n                     )\n\n    fig.add_trace(go.Line(x=x_actual,\n                          y=y_actual,\n                          mode='markers',\n                          name='Actual',\n                          marker=dict(symbol='circle-open-dot', \n                                      size=9, \n                                      color='black', \n                                      line_width=1.5,\n                                     )\n                         ) \n                 )    \n\n    fig.add_trace(go.Line(x=x_model,\n                          y=y_model,\n                          mode='lines',\n                          name='Modelled',\n                          line=dict(color='blue', \n                                    width=2\n                                   )\n                         ) \n                 ) \n\n    fig.show()\n    \n    # now add the results of the cluster to the country's prediction\n    df = pd.DataFrame(y_model,index=x_model,columns=[cluster])\n    df.index.name = 'Date'\n    df_country = pd.merge(df_country,\n                          df,\n                          how='outer',\n                          left_on=['Date'],\n                          right_on=['Date'])\n   ","638dbe27":"df_country['Predicted from Clusters']=0\nfor cluster in clusters:    \n    df_country[cluster].fillna(method='ffill',inplace=True)\n    df_country[cluster].fillna(method='bfill',inplace=True)\n    df_country['Predicted from Clusters'] = df_country['Predicted from Clusters'] + df_country[cluster]\n\ndf_country = df_country[['Date','Confirmed','Predicted from Clusters']]","ece19de9":"def get_time_series(country):\n    df = full_table[(full_table['Country\/Region'] == country)]\n    df = df.groupby(['Date','Country\/Region']).sum().reset_index()\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    return df.set_index('Date')[['Confirmed']]\n\ndf = get_time_series(country)\n\n# ensure that the model starts from when the first case is detected\ndf = df[df[df.columns[0]]>0]\n\n# define the models to forecast the growth of cases\ndef model(N, a, alpha, t):\n    # we enforce N, a and alpha to be positive numbers using min and max functions\n    return N * (1 - math.e ** (-a * t)) ** alpha\n    #return max(N, 0) * (1 - math.e ** (min(-a, 0) * t)) ** max(alpha, 0)\n\ndef model_loss(params):\n    N, a, alpha = params\n    global df\n    r = 0\n    for t in range(len(df)):\n        r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n    return r \n\ntry:\n    N = df['Confirmed'][-1]\nexcept:\n    N = 10000\nopt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n#     opt = minimize(model_loss, x0=np.array([500000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n\n# Plot the modelled vs actual - into the future\n\n# create series to be plotted \nx_actual = pd.to_datetime(df.reset_index().iloc[:,0])\nx_actual =list(x_actual)\ny_actual = list(df.reset_index().iloc[:,1])\n\nstart_date = pd.to_datetime(df.index[0])\n\nx_model = []\ny_model = []\n\n# get the model values for the same time series as the actuals\nfor t in range(len(df) + days_forecast):\n    x_model.append(start_date + datetime.timedelta(days=t))\n    y_model.append(round(model(*opt,t)))\n\n# now add the results of the cluster to the country's prediction\ndf = pd.DataFrame(y_model,index=x_model,columns=['Predicted Global'])\ndf.index.name = 'Date'\ndf_country = pd.merge(df_country,\n                      df,\n                      how='outer',\n                      left_on=['Date'],\n                      right_on=['Date'])","be0176f1":"df_country['Cluster error'] = (df_country['Confirmed']-df_country['Predicted from Clusters'])\/df_country['Confirmed']*100\ndf_country['Global error'] = (df_country['Confirmed']-df_country['Predicted Global'])\/df_country['Confirmed']*100\n\ndef highlight_max(s):\n    '''\n    highlight the absolute maximum value in a Series with red font.\n    '''\n    is_min = abs(s) == abs(s).max()\n    return ['color: red' if v else '' for v in is_min]\n\ndf_country.drop(df_country.tail(days_forecast).index,inplace=False).style.apply(highlight_max,axis=1,subset=['Cluster error', 'Global error'])\n","ed8cc331":"# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Predicted from Clusters'])\ny_model_glob = list(df_country['Predicted Global'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"nr People\",\n                  autosize=False,\n                  width=700,\n                  height=500,\n#                   yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_actual,\n                      y=y_actual,\n                      mode='markers',\n                      name='Actual',\n                      marker=dict(symbol='circle-open-dot', \n                                  size=9, \n                                  color='black', \n                                  line_width=1.5,\n                                 )\n                     ) \n             )    \n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster Prediction',\n                      line=dict(color='blue', \n                                width=2\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global Prediction',\n                      line=dict(color='red', \n                                width=1.5,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()","f07fe019":"# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Cluster error'])\ny_model_glob = list(df_country['Global error'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"% error\",\n                  autosize=False,\n                  width=700,\n                  height=500,\n                  #yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster error',\n                      line=dict(color='blue', \n                                width=1\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global error',\n                      line=dict(color='red', \n                                width=1.0,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()","615a9d8a":"country = 'Australia'","a2fe3143":"clusters = list(set(full_table['Province\/State'][(full_table['Country\/Region'] == country)]))\nclusters.sort()\nprint('there are ' + str(len(clusters)) + ' clusters (provinces\/states) found for ' + country)","ebc43770":"# print the results of each cluster\n\n# first set up the country dataframe\ndf = full_table[(full_table['Country\/Region'] == country)]\ndf = df.groupby(['Date','Country\/Region']).sum().reset_index()\ndf['Date'] = pd.to_datetime(df['Date'])\ndf = df.sort_values(by=['Date'])\ndf_country = df.copy()\ndf_country = df_country[['Date','Confirmed']]\n\ndf_length = len(df_country) + days_forecast\n\n# then evaluate each cluster\nfor cluster in clusters:\n    df = full_table[(full_table['Country\/Region'] == country) & (full_table['Province\/State'] == cluster)]\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    df = df.set_index('Date')[['Confirmed']]\n    df = df[df[df.columns[0]]>0]\n    \n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * t)) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n\n#     opt = minimize(model_loss, x0=np.array([100000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n    \n    # create actual series to be plotted \n    x_actual = pd.to_datetime(df.reset_index().iloc[:,0])\n    x_actual = list(x_actual)\n    y_actual = list(df.reset_index().iloc[:,1])\n    \n    # create modelled series to be plotted\n    start_date = pd.to_datetime(df.index[0])\n    x_model = []\n    y_model = []\n    for t in range(len(df) + days_forecast):\n        x_model.append(start_date + datetime.timedelta(days=t))\n        y_model.append(round(model(*opt,t)))\n\n    # instantiate the figure and add the two series - actual vs modelled    \n    fig = go.Figure()\n    fig.update_layout(title=country + ' - ' + cluster,\n                      xaxis_title='Date',\n                      yaxis_title=\"nr People\",\n                      autosize=False,\n                      width=700,\n                      height=500,\n                     )\n\n    fig.add_trace(go.Line(x=x_actual,\n                          y=y_actual,\n                          mode='markers',\n                          name='Actual',\n                          marker=dict(symbol='circle-open-dot', \n                                      size=9, \n                                      color='black', \n                                      line_width=1.5,\n                                     )\n                         ) \n                 )    \n\n    fig.add_trace(go.Line(x=x_model,\n                          y=y_model,\n                          mode='lines',\n                          name='Modelled',\n                          line=dict(color='blue', \n                                    width=2\n                                   )\n                         ) \n                 ) \n\n    fig.show()\n    \n    # now add the results of the cluster to the country's prediction\n    df = pd.DataFrame(y_model,index=x_model,columns=[cluster])\n    df.index.name = 'Date'\n    df_country = pd.merge(df_country,\n                          df,\n                          how='outer',\n                          left_on=['Date'],\n                          right_on=['Date'])\n   ","40904696":"df_country['Predicted from Clusters']=0\nfor cluster in clusters:    \n    df_country[cluster].fillna(method='ffill',inplace=True)\n    df_country[cluster].fillna(method='bfill',inplace=True)\n    df_country['Predicted from Clusters'] = df_country['Predicted from Clusters'] + df_country[cluster]\n\ndf_country = df_country[['Date','Confirmed','Predicted from Clusters']]","19293f7e":"def get_time_series(country):\n    df = full_table[(full_table['Country\/Region'] == country)]\n    df = df.groupby(['Date','Country\/Region']).sum().reset_index()\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    return df.set_index('Date')[['Confirmed']]\n\ndf = get_time_series(country)\n\n# ensure that the model starts from when the first case is detected\ndf = df[df[df.columns[0]]>0]\n\n# define the models to forecast the growth of cases\ndef model(N, a, alpha, t):\n    # we enforce N, a and alpha to be positive numbers using min and max functions\n    return N * (1 - math.e ** (-a * t)) ** alpha\n    #return max(N, 0) * (1 - math.e ** (min(-a, 0) * t)) ** max(alpha, 0)\n\ndef model_loss(params):\n    N, a, alpha = params\n    global df\n    r = 0\n    for t in range(len(df)):\n        r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n    return r \n\ntry:\n    N = df['Confirmed'][-1]\nexcept:\n    N = 10000\nopt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n#     opt = minimize(model_loss, x0=np.array([500000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n\n# Plot the modelled vs actual - into the future\n\n# create series to be plotted \nx_actual = pd.to_datetime(df.reset_index().iloc[:,0])\nx_actual =list(x_actual)\ny_actual = list(df.reset_index().iloc[:,1])\n\nstart_date = pd.to_datetime(df.index[0])\n\nx_model = []\ny_model = []\n\n# get the model values for the same time series as the actuals\nfor t in range(len(df) + days_forecast):\n    x_model.append(start_date + datetime.timedelta(days=t))\n    y_model.append(round(model(*opt,t)))\n\n# now add the results of the cluster to the country's prediction\ndf = pd.DataFrame(y_model,index=x_model,columns=['Predicted Global'])\ndf.index.name = 'Date'\ndf_country = pd.merge(df_country,\n                      df,\n                      how='outer',\n                      left_on=['Date'],\n                      right_on=['Date'])","9fb7fa29":"df_country['Cluster error'] = (df_country['Confirmed']-df_country['Predicted from Clusters'])\/df_country['Confirmed']*100\ndf_country['Global error'] = (df_country['Confirmed']-df_country['Predicted Global'])\/df_country['Confirmed']*100\n\ndef highlight_max(s):\n    '''\n    highlight the absolute maximum value in a Series with red font.\n    '''\n    is_min = abs(s) == abs(s).max()\n    return ['color: red' if v else '' for v in is_min]\n\ndf_country.drop(df_country.tail(days_forecast).index,inplace=False).style.apply(highlight_max,axis=1,subset=['Cluster error', 'Global error'])\n","55c06b82":"# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Predicted from Clusters'])\ny_model_glob = list(df_country['Predicted Global'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"nr People\",\n                  autosize=False,\n                  width=700,\n                  height=500,\n                  # yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_actual,\n                      y=y_actual,\n                      mode='markers',\n                      name='Actual',\n                      marker=dict(symbol='circle-open-dot', \n                                  size=9, \n                                  color='black', \n                                  line_width=1.5,\n                                 )\n                     ) \n             )    \n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster Prediction',\n                      line=dict(color='blue', \n                                width=2\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global Prediction',\n                      line=dict(color='red', \n                                width=1.5,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()","83286065":"# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Cluster error'])\ny_model_glob = list(df_country['Global error'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"% error\",\n                  autosize=False,\n                  width=700,\n                  height=500,\n                  #yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster error',\n                      line=dict(color='blue', \n                                width=1\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global error',\n                      line=dict(color='red', \n                                width=1.0,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()","c424eb8f":"<h1>Table of Contents<span class=\"tocSkip\"><\/span><\/h1>\n<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#Introduction\" data-toc-modified-id=\"Introduction-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;<\/span>Introduction<\/a><\/span><\/li><li><span><a href=\"#Import\" data-toc-modified-id=\"Import-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;<\/span>Import<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Python-Libraries\" data-toc-modified-id=\"Python-Libraries-2.1\"><span class=\"toc-item-num\">2.1&nbsp;&nbsp;<\/span>Python Libraries<\/a><\/span><\/li><li><span><a href=\"#Study-Settings\" data-toc-modified-id=\"Study-Settings-2.2\"><span class=\"toc-item-num\">2.2&nbsp;&nbsp;<\/span>Study Settings<\/a><\/span><\/li><li><span><a href=\"#Data\" data-toc-modified-id=\"Data-2.3\"><span class=\"toc-item-num\">2.3&nbsp;&nbsp;<\/span>Data<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#Explore\" data-toc-modified-id=\"Explore-3\"><span class=\"toc-item-num\">3&nbsp;&nbsp;<\/span>Explore<\/a><\/span><\/li><li><span><a href=\"#Model\" data-toc-modified-id=\"Model-4\"><span class=\"toc-item-num\">4&nbsp;&nbsp;<\/span>Model<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Global-view-only-(Country-level-analysis)\" data-toc-modified-id=\"Global-view-only-(Country-level-analysis)-4.1\"><span class=\"toc-item-num\">4.1&nbsp;&nbsp;<\/span>Global view only (Country level analysis)<\/a><\/span><\/li><li><span><a href=\"#Cluster-View-(by-Province\/State)\" data-toc-modified-id=\"Cluster-View-(by-Province\/State)-4.2\"><span class=\"toc-item-num\">4.2&nbsp;&nbsp;<\/span>Cluster View (by Province\/State)<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#China\" data-toc-modified-id=\"China-4.2.1\"><span class=\"toc-item-num\">4.2.1&nbsp;&nbsp;<\/span>China<\/a><\/span><\/li><li><span><a href=\"#Australia\" data-toc-modified-id=\"Australia-4.2.2\"><span class=\"toc-item-num\">4.2.2&nbsp;&nbsp;<\/span>Australia<\/a><\/span><\/li><\/ul><\/li><\/ul><\/li><li><span><a href=\"#Conclusion\" data-toc-modified-id=\"Conclusion-5\"><span class=\"toc-item-num\">5&nbsp;&nbsp;<\/span>Conclusion<\/a><\/span><\/li><\/ul><\/div>\n\n# Introduction\n\nThis study uses the work from the following source: https:\/\/www.kaggle.com\/alixmartin\/covid-19-predictions. The previous study applied a model at a country level to predict the growth of confirmed cases. \n\nThe previous approach could not adequately explain the odd behaviours of growth for countries like China. In the China data, the curve seems to grow exponentially, then tapers off, then picks up exponentially again, and then tapers off.  \n\nThis author reckons that this behaviour exists, because the growth is cluster-based. Each cluster should be treated as a newly infected 'country' and therefore modelled seperately with  their results rolled up to predict the growth at a country or global level.\n\nThe data does not identify the clusters per country explicitly (which is probably at a town or suburb level). Therefore the study will examine it by province\/state to see whether a significant improvement in accuracy can be obtained.\n\nIn future work, the study could estimate the number of clusters, and provide parameters in the model that could assist in identifying clusters that are managing the COVID-19 contagion well or poorly.  \n\n# Import\n\n## Python Libraries\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom IPython.core.display import display, HTML\nimport plotly.graph_objects as go\nimport warnings\nimport datetime\nimport math\nfrom scipy.optimize import minimize\n\n\nConfigure the notebook (see https:\/\/jupyter-notebook.readthedocs.io\/en\/stable\/config.html)\n\n# Configure Jupyter Notebook\npd.set_option('display.max_columns', None) \npd.set_option('display.max_rows', 500) \npd.set_option('display.expand_frame_repr', False)\n# pd.set_option('max_colwidth', -1)\ndisplay(HTML(\"<style>div.output_scroll { height: 35em; }<\/style>\"))\n\n%matplotlib inline\n%config InlineBackend.figure_format ='retina'\n\nwarnings.filterwarnings('ignore')\n\n## Study Settings\n\n# the number of days into the future for the forecast\ndays_forecast = 30\n\n## Data\n\n# download the latest data sets\nconf_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Confirmed.csv')\ndeaths_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Deaths.csv')\nrecv_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Recovered.csv')\n\n# create full table\ndates = conf_df.columns[4:]\n\nconf_df_long = conf_df.melt(id_vars=['Province\/State', 'Country\/Region', 'Lat', 'Long'], \n                            value_vars=dates, var_name='Date', value_name='Confirmed')\n\ndeaths_df_long = deaths_df.melt(id_vars=['Province\/State', 'Country\/Region', 'Lat', 'Long'], \n                            value_vars=dates, var_name='Date', value_name='Deaths')\n\nrecv_df_long = recv_df.melt(id_vars=['Province\/State', 'Country\/Region', 'Lat', 'Long'], \n                            value_vars=dates, var_name='Date', value_name='Recovered')\n\nfull_table = pd.concat([conf_df_long, deaths_df_long['Deaths'], recv_df_long['Recovered']], \n                       axis=1, sort=False)\n\n\n# avoid double counting\nfull_table = full_table[full_table['Province\/State'].str.contains(',')!=True]\n\n# cases \ncases = ['Confirmed', 'Deaths', 'Recovered', 'Active']\n\n# Active Case = confirmed - deaths - recovered\nfull_table['Active'] = full_table['Confirmed'] - full_table['Deaths'] - full_table['Recovered']\n\n# replacing Mainland china with just China\nfull_table['Country\/Region'] = full_table['Country\/Region'].replace('Mainland China', 'China')\n\n# filling missing values \nfull_table[['Province\/State']] = full_table[['Province\/State']].fillna('')\n\n# Explore\n\nThis section does a brief exploration of the latest data set.\n\nThe first table shows a global summary with the latest data. \n\n# Display the number cases globally\ndf = full_table.groupby(['Country\/Region', 'Province\/State'])['Confirmed', 'Deaths', 'Recovered', 'Active'].max()\ndf = full_table.groupby('Date')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()\ndf =  df[df['Date']==max(df['Date'])].reset_index(drop=True)\ndf\n\nThe table below shows the lastest values by country\n\n# count the number cases per country\ndf = full_table[full_table['Date'] == max(full_table['Date'])].reset_index()\ndf = df.groupby('Country\/Region')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()\ndf = df.sort_values(by='Confirmed', ascending=False)\ndf = df.reset_index(drop=True)\ndf.style.background_gradient(cmap='coolwarm')\n\nThe table below counts the number of provinces\/states for each country. These numbers will be the clusters used in Chapter 4.2. \n\n# count the number of provinces\/states per country\ncountries = list(set(full_table['Country\/Region']))\ncountries.sort()\ndf_cluster_count = pd.DataFrame(countries,columns=['Countries'])\ndf_cluster_count['Clusters']=0\n\nfor country in countries:\n    df = full_table[(full_table['Country\/Region'] == country)]\n    clusters = len(set(df['Province\/State']))\n    df_cluster_count['Clusters'][df_cluster_count['Countries']==country]=clusters\n\ndf_cluster_count = df_cluster_count.sort_values(by=['Clusters'],ascending=False)\ndf_cluster_count.style.background_gradient(cmap='coolwarm')\n\n# Model\n\nThe model is the same one as before (except with an 'offset'). The model is from a marketing paper by Emmanuelle Le Nagard and Alexandre Steyer, that attempts to reflect the social structure of a diffusion process. The paper is available (in French) [here](https:\/\/www.jstor.org\/stable\/40588987)\n\nThe model is also sensitive to when we define the origin of time for the epidemic process. I have added an offset to the original study so that the model ended up in the following form:\n\n$$N(1 - e^{-a(t-t_0)})^{\\alpha}$$\n\n\n## Global view only (Country level analysis)\n\nIn this section we start by building and displaying a model for a country (ignoring the clusters). The model is simple to compare with the previous day's results. In the cases where the COVID-19 spread is recent and the number of confirmed cases are few the model is not accurate. In these low-number cases the predictions from yesterday to today may fluctate significantly. With the countries that have cases in the 100s or 1000s however, the model is fairly stable.  \n\nThis will be important to know later on when we model by clusters. The smaller the number of confirmed cases per cluster, the poorer the model should perform. \n\ncountries = list(set(full_table['Country\/Region']))\ncountries.sort()\n\n# NOTE: the number of charts for all countries makes this notebook large. It is better to work with sub-sets\ncountries = ['South Africa', 'China','Italy','Korea, South', 'Iran', 'Germany', 'Spain', 'Australia']\n#countries = ['South Africa']\n\n\nfor country in countries:\n    def get_time_series(country):\n        df = full_table[(full_table['Country\/Region'] == country)]\n        df = df.groupby(['Date','Country\/Region']).sum().reset_index()\n        df['Date'] = pd.to_datetime(df['Date'])\n        df = df.sort_values(by=['Date'])\n        return df.set_index('Date')[['Confirmed']]\n\n    df = get_time_series(country)\n\n    # ensure that the model starts from when the first case is detected\n    df = df[df[df.columns[0]]>0]\n\n    # define the models to forecast the growth of cases\n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * (t))) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n\n    # create series to be plotted \n    x_actual = pd.to_datetime(df.reset_index().iloc[:,0])\n    x_actual =list(x_actual)\n    y_actual = list(df.reset_index().iloc[:,1])\n\n    start_date = pd.to_datetime(df.index[0])\n\n    x_model = []\n    y_model = []\n\n    # get the model values for the same time series as the actuals\n    for t in range(len(df) + days_forecast):\n        x_model.append(start_date + datetime.timedelta(days=t))\n        y_model.append(round(model(*opt,t)))\n\n    # instantiate the figure and add the two series - actual vs modelled    \n    fig = go.Figure()\n    fig.update_layout(title=country,\n                      xaxis_title='Date',\n                      yaxis_title=\"nr People\",\n                      autosize=False,\n                      width=900,\n                      height=500,\n                     )\n\n    fig.add_trace(go.Line(x=x_actual,\n                          y=y_actual,\n                          mode='markers',\n                          name='Actual',\n                          marker=dict(symbol='circle-open-dot', \n                                      size=9, \n                                      color='black', \n                                      line_width=1.5,\n                                     )\n                         ) \n                 )    \n\n    fig.add_trace(go.Line(x=x_model,\n                          y=y_model,\n                          mode='lines',\n                          name=\"Today's Prediction\",\n                          line=dict(color='blue', \n                                    width=2.5\n                                   )\n                         ) \n                 ) \n\n    \n    # drop the last row of dataframe to model yesterday's results\n    df.drop(df.tail(1).index,inplace=True)\n\n    # define the models to forecast the growth of cases\n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * (t))) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n\n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n    \n    try:\n        start_date = pd.to_datetime(df.index[0])\n\n        x_model = []\n        y_model = []\n\n        # get the model values for the same time series as the actuals\n        for t in range(len(df) + days_forecast):\n            x_model.append(start_date + datetime.timedelta(days=t))\n            y_model.append(round(model(*opt,t)))\n\n\n        # now plot the new series\n        fig.add_trace(go.Line(x=x_model,\n                              y=y_model,\n                              mode='lines',\n                              name=\"Yesterday's Prediction\",\n                              line=dict(color='Red', \n                                        width=1.5,\n                                        dash='dot'\n                                       )\n                             ) \n                     )\n    except:\n        pass\n    \n    fig.show()\n\n## Cluster View (by Province\/State)\n\nThis chapter treats each province\/state as a cluster, and simulates the spread of the Corona virus for each one. This is still not quite accurate enough (as seen in a couple of provinces of China). But it does better with others such as Australia. \n\n### China\n\ncountry = 'China'\n\nclusters = list(set(full_table['Province\/State'][(full_table['Country\/Region'] == country)]))\nclusters.sort()\nprint('there are ' + str(len(clusters)) + ' clusters (provinces\/states) found for ' + country)\n\n# print the results of each cluster\n\n# first set up the country dataframe\ndf = full_table[(full_table['Country\/Region'] == country)]\ndf = df.groupby(['Date','Country\/Region']).sum().reset_index()\ndf['Date'] = pd.to_datetime(df['Date'])\ndf = df.sort_values(by=['Date'])\ndf_country = df.copy()\ndf_country = df_country[['Date','Confirmed']]\n\ndf_length = len(df_country) + days_forecast\n\n# then evaluate each cluster\nfor cluster in clusters:\n    df = full_table[(full_table['Country\/Region'] == country) & (full_table['Province\/State'] == cluster)]\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    df = df.set_index('Date')[['Confirmed']]\n    df = df[df[df.columns[0]]>0]\n    \n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * t)) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n\n#     opt = minimize(model_loss, x0=np.array([100000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n    \n    # create actual series to be plotted \n    x_actual = pd.to_datetime(df.reset_index().iloc[:,0])\n    x_actual = list(x_actual)\n    y_actual = list(df.reset_index().iloc[:,1])\n    \n    # create modelled series to be plotted\n    start_date = pd.to_datetime(df.index[0])\n    x_model = []\n    y_model = []\n    for t in range(len(df) + days_forecast):\n        x_model.append(start_date + datetime.timedelta(days=t))\n        y_model.append(round(model(*opt,t)))\n\n    # instantiate the figure and add the two series - actual vs modelled    \n    fig = go.Figure()\n    fig.update_layout(title=country + ' - ' + cluster,\n                      xaxis_title='Date',\n                      yaxis_title=\"nr People\",\n                      autosize=False,\n                      width=900,\n                      height=500,\n                     )\n\n    fig.add_trace(go.Line(x=x_actual,\n                          y=y_actual,\n                          mode='markers',\n                          name='Actual',\n                          marker=dict(symbol='circle-open-dot', \n                                      size=9, \n                                      color='black', \n                                      line_width=1.5,\n                                     )\n                         ) \n                 )    \n\n    fig.add_trace(go.Line(x=x_model,\n                          y=y_model,\n                          mode='lines',\n                          name='Modelled',\n                          line=dict(color='blue', \n                                    width=2\n                                   )\n                         ) \n                 ) \n\n    fig.show()\n    \n    # now add the results of the cluster to the country's prediction\n    df = pd.DataFrame(y_model,index=x_model,columns=[cluster])\n    df.index.name = 'Date'\n    df_country = pd.merge(df_country,\n                          df,\n                          how='outer',\n                          left_on=['Date'],\n                          right_on=['Date'])\n   \n\n In the charts above we see that the model still fails with some provinces\/states such as Beijing, Gansu, Hong-Kong, Hubei (significant weight), Macau, Shandong, and Shanghai. These provinces\/states should be modelled as though they have more than one cluster to get better accuracy. The others are modelled with sufficient accuracy.   \n\ndf_country['Predicted from Clusters']=0\nfor cluster in clusters:    \n    df_country[cluster].fillna(method='ffill',inplace=True)\n    df_country[cluster].fillna(method='bfill',inplace=True)\n    df_country['Predicted from Clusters'] = df_country['Predicted from Clusters'] + df_country[cluster]\n\ndf_country = df_country[['Date','Confirmed','Predicted from Clusters']]\n\ndef get_time_series(country):\n    df = full_table[(full_table['Country\/Region'] == country)]\n    df = df.groupby(['Date','Country\/Region']).sum().reset_index()\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    return df.set_index('Date')[['Confirmed']]\n\ndf = get_time_series(country)\n\n# ensure that the model starts from when the first case is detected\ndf = df[df[df.columns[0]]>0]\n\n# define the models to forecast the growth of cases\ndef model(N, a, alpha, t):\n    # we enforce N, a and alpha to be positive numbers using min and max functions\n    return N * (1 - math.e ** (-a * t)) ** alpha\n    #return max(N, 0) * (1 - math.e ** (min(-a, 0) * t)) ** max(alpha, 0)\n\ndef model_loss(params):\n    N, a, alpha = params\n    global df\n    r = 0\n    for t in range(len(df)):\n        r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n    return r \n\ntry:\n    N = df['Confirmed'][-1]\nexcept:\n    N = 10000\nopt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n#     opt = minimize(model_loss, x0=np.array([500000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n\n# Plot the modelled vs actual - into the future\n\n# create series to be plotted \nx_actual = pd.to_datetime(df.reset_index().iloc[:,0])\nx_actual =list(x_actual)\ny_actual = list(df.reset_index().iloc[:,1])\n\nstart_date = pd.to_datetime(df.index[0])\n\nx_model = []\ny_model = []\n\n# get the model values for the same time series as the actuals\nfor t in range(len(df) + days_forecast):\n    x_model.append(start_date + datetime.timedelta(days=t))\n    y_model.append(round(model(*opt,t)))\n\n# now add the results of the cluster to the country's prediction\ndf = pd.DataFrame(y_model,index=x_model,columns=['Predicted Global'])\ndf.index.name = 'Date'\ndf_country = pd.merge(df_country,\n                      df,\n                      how='outer',\n                      left_on=['Date'],\n                      right_on=['Date'])\n\ndf_country['Cluster error'] = (df_country['Confirmed']-df_country['Predicted from Clusters'])\/df_country['Confirmed']*100\ndf_country['Global error'] = (df_country['Confirmed']-df_country['Predicted Global'])\/df_country['Confirmed']*100\n\ndef highlight_max(s):\n    '''\n    highlight the absolute maximum value in a Series with red font.\n    '''\n    is_min = abs(s) == abs(s).max()\n    return ['color: red' if v else '' for v in is_min]\n\ndf_country.drop(df_country.tail(days_forecast).index,inplace=False).style.apply(highlight_max,axis=1,subset=['Cluster error', 'Global error'])\n\n\nThe dataframe above shows that the prediction from clusters tend to outperform the predictions from a global pov (red is the worst error). \n\n# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Predicted from Clusters'])\ny_model_glob = list(df_country['Predicted Global'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"nr People\",\n                  autosize=False,\n                  width=900,\n                  height=500,\n#                   yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_actual,\n                      y=y_actual,\n                      mode='markers',\n                      name='Actual',\n                      marker=dict(symbol='circle-open-dot', \n                                  size=9, \n                                  color='black', \n                                  line_width=1.5,\n                                 )\n                     ) \n             )    \n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster Prediction',\n                      line=dict(color='blue', \n                                width=2\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global Prediction',\n                      line=dict(color='red', \n                                width=1.5,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()\n\nThe chart above shows that the cluster approach by province\/state has very little advantage over the global model for China. The error margins are compared more clearly in the figure below.\n\n# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Cluster error'])\ny_model_glob = list(df_country['Global error'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"% error\",\n                  autosize=False,\n                  width=900,\n                  height=500,\n                  #yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster error',\n                      line=dict(color='blue', \n                                width=1\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global error',\n                      line=dict(color='red', \n                                width=1.0,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()\n\n### Australia\n\ncountry = 'Australia'\n\nclusters = list(set(full_table['Province\/State'][(full_table['Country\/Region'] == country)]))\nclusters.sort()\nprint('there are ' + str(len(clusters)) + ' clusters (provinces\/states) found for ' + country)\n\n# print the results of each cluster\n\n# first set up the country dataframe\ndf = full_table[(full_table['Country\/Region'] == country)]\ndf = df.groupby(['Date','Country\/Region']).sum().reset_index()\ndf['Date'] = pd.to_datetime(df['Date'])\ndf = df.sort_values(by=['Date'])\ndf_country = df.copy()\ndf_country = df_country[['Date','Confirmed']]\n\ndf_length = len(df_country) + days_forecast\n\n# then evaluate each cluster\nfor cluster in clusters:\n    df = full_table[(full_table['Country\/Region'] == country) & (full_table['Province\/State'] == cluster)]\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    df = df.set_index('Date')[['Confirmed']]\n    df = df[df[df.columns[0]]>0]\n    \n    def model(N, a, alpha, t):\n        return N * (1 - math.e ** (-a * t)) ** alpha\n\n    def model_loss(params):\n        N, a, alpha = params\n        global df\n        r = 0\n        for t in range(len(df)):\n            r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n        return r \n\n#     opt = minimize(model_loss, x0=np.array([100000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n    try:\n        N = df['Confirmed'][-1]\n    except:\n        N = 10000\n    opt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n    \n    # create actual series to be plotted \n    x_actual = pd.to_datetime(df.reset_index().iloc[:,0])\n    x_actual = list(x_actual)\n    y_actual = list(df.reset_index().iloc[:,1])\n    \n    # create modelled series to be plotted\n    start_date = pd.to_datetime(df.index[0])\n    x_model = []\n    y_model = []\n    for t in range(len(df) + days_forecast):\n        x_model.append(start_date + datetime.timedelta(days=t))\n        y_model.append(round(model(*opt,t)))\n\n    # instantiate the figure and add the two series - actual vs modelled    \n    fig = go.Figure()\n    fig.update_layout(title=country + ' - ' + cluster,\n                      xaxis_title='Date',\n                      yaxis_title=\"nr People\",\n                      autosize=False,\n                      width=900,\n                      height=500,\n                     )\n\n    fig.add_trace(go.Line(x=x_actual,\n                          y=y_actual,\n                          mode='markers',\n                          name='Actual',\n                          marker=dict(symbol='circle-open-dot', \n                                      size=9, \n                                      color='black', \n                                      line_width=1.5,\n                                     )\n                         ) \n                 )    \n\n    fig.add_trace(go.Line(x=x_model,\n                          y=y_model,\n                          mode='lines',\n                          name='Modelled',\n                          line=dict(color='blue', \n                                    width=2\n                                   )\n                         ) \n                 ) \n\n    fig.show()\n    \n    # now add the results of the cluster to the country's prediction\n    df = pd.DataFrame(y_model,index=x_model,columns=[cluster])\n    df.index.name = 'Date'\n    df_country = pd.merge(df_country,\n                          df,\n                          how='outer',\n                          left_on=['Date'],\n                          right_on=['Date'])\n   \n\n In the charts above we see that the model fails with some provinces\/states that have low numbers.   \n\ndf_country['Predicted from Clusters']=0\nfor cluster in clusters:    \n    df_country[cluster].fillna(method='ffill',inplace=True)\n    df_country[cluster].fillna(method='bfill',inplace=True)\n    df_country['Predicted from Clusters'] = df_country['Predicted from Clusters'] + df_country[cluster]\n\ndf_country = df_country[['Date','Confirmed','Predicted from Clusters']]\n\ndef get_time_series(country):\n    df = full_table[(full_table['Country\/Region'] == country)]\n    df = df.groupby(['Date','Country\/Region']).sum().reset_index()\n    df['Date'] = pd.to_datetime(df['Date'])\n    df = df.sort_values(by=['Date'])\n    return df.set_index('Date')[['Confirmed']]\n\ndf = get_time_series(country)\n\n# ensure that the model starts from when the first case is detected\ndf = df[df[df.columns[0]]>0]\n\n# define the models to forecast the growth of cases\ndef model(N, a, alpha, t):\n    # we enforce N, a and alpha to be positive numbers using min and max functions\n    return N * (1 - math.e ** (-a * t)) ** alpha\n    #return max(N, 0) * (1 - math.e ** (min(-a, 0) * t)) ** max(alpha, 0)\n\ndef model_loss(params):\n    N, a, alpha = params\n    global df\n    r = 0\n    for t in range(len(df)):\n        r += (model(N, a, alpha, t) - df.iloc[t, 0]) ** 2\n    return r \n\ntry:\n    N = df['Confirmed'][-1]\nexcept:\n    N = 10000\nopt = minimize(model_loss, x0=np.array([N, 0.2, 30]), method='Nelder-Mead', tol=1e-6).x\n#     opt = minimize(model_loss, x0=np.array([500000, 0.2, 30]), method='Nelder-Mead', tol=1e-5).x\n\n# Plot the modelled vs actual - into the future\n\n# create series to be plotted \nx_actual = pd.to_datetime(df.reset_index().iloc[:,0])\nx_actual =list(x_actual)\ny_actual = list(df.reset_index().iloc[:,1])\n\nstart_date = pd.to_datetime(df.index[0])\n\nx_model = []\ny_model = []\n\n# get the model values for the same time series as the actuals\nfor t in range(len(df) + days_forecast):\n    x_model.append(start_date + datetime.timedelta(days=t))\n    y_model.append(round(model(*opt,t)))\n\n# now add the results of the cluster to the country's prediction\ndf = pd.DataFrame(y_model,index=x_model,columns=['Predicted Global'])\ndf.index.name = 'Date'\ndf_country = pd.merge(df_country,\n                      df,\n                      how='outer',\n                      left_on=['Date'],\n                      right_on=['Date'])\n\ndf_country['Cluster error'] = (df_country['Confirmed']-df_country['Predicted from Clusters'])\/df_country['Confirmed']*100\ndf_country['Global error'] = (df_country['Confirmed']-df_country['Predicted Global'])\/df_country['Confirmed']*100\n\ndef highlight_max(s):\n    '''\n    highlight the absolute maximum value in a Series with red font.\n    '''\n    is_min = abs(s) == abs(s).max()\n    return ['color: red' if v else '' for v in is_min]\n\ndf_country.drop(df_country.tail(days_forecast).index,inplace=False).style.apply(highlight_max,axis=1,subset=['Cluster error', 'Global error'])\n\n\nThe dataframe above shows that the prediction from clusters tend to outperform the predictions from a global pov (red is the worst error). \n\n# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Predicted from Clusters'])\ny_model_glob = list(df_country['Predicted Global'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"nr People\",\n                  autosize=False,\n                  width=900,\n                  height=500,\n                  # yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_actual,\n                      y=y_actual,\n                      mode='markers',\n                      name='Actual',\n                      marker=dict(symbol='circle-open-dot', \n                                  size=9, \n                                  color='black', \n                                  line_width=1.5,\n                                 )\n                     ) \n             )    \n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster Prediction',\n                      line=dict(color='blue', \n                                width=2\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global Prediction',\n                      line=dict(color='red', \n                                width=1.5,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()\n\nThe chart above shows that the cluster approach by province\/state has some advantage over the global model for Australia. The error margins are compared more clearly in the figure below.\n\n# now plot the prediction for the country\nx_actual = pd.to_datetime(df_country['Date'])\nx_actual = list(x_actual)\ny_actual = list(df_country['Confirmed'])\n\nx_model = x_actual\ny_model_clus = list(df_country['Cluster error'])\ny_model_glob = list(df_country['Global error'])\n\n# instantiate the figure and add the two series - actual vs modelled    \nfig = go.Figure()\n\nfig.update_layout(title=country,\n                  xaxis_title='Date',\n                  yaxis_title=\"% error\",\n                  autosize=False,\n                  width=900,\n                  height=500,\n                  #yaxis_type='log'\n                 )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_clus,\n                      mode='lines',\n                      name='Cluster error',\n                      line=dict(color='blue', \n                                width=1\n                               )\n                     ) \n             )\n\nfig.add_trace(go.Line(x=x_model,\n                      y=y_model_glob,\n                      mode='lines',\n                      name='Global error',\n                      line=dict(color='red', \n                                width=1.0,\n                                dash='dot'\n                               )\n                     ) \n             )\n\nfig.show()\n\n# Conclusion\n\nThe study has shown that there may be some advantage to the clustering approach using provinces\/states as clusters, but the benefit is not substantially greater or obvious. In some instances where the cluster populations are too small, the cluster approach does worse than the global view. When the model is applied to France for instance, the global approach outperforms the cluster-based approach. \n\nThe cluster-based approach is more sensitive to upticks or downticks (per cluster) in the data than the global model. The global model will not react and adjust as much to the latest data point.\n\nIf more clusters are introduced to the model, then the model will become even more sensitive to the latest data points. Also the model itself will have substantial errors with small populations, therefore the model might need a better optimization algorithm. \n\n ","06c26181":"The table below counts the number of provinces\/states for each country. These numbers will be the clusters used in Chapter 4.2. ","8c99e97d":"## Python Libraries","b9310ca0":"The model is the same one as before (except with an 'offset'). The model is from a marketing paper by Emmanuelle Le Nagard and Alexandre Steyer, that attempts to reflect the social structure of a diffusion process. The paper is available (in French) [here](https:\/\/www.jstor.org\/stable\/40588987)\n\nThe model is also sensitive to when we define the origin of time for the epidemic process. I have added an offset to the original study so that the model ended up in the following form:\n\n$$N(1 - e^{-a(t-t_0)})^{\\alpha}$$\n","b83cd263":"The study has shown that there may be some advantage to the clustering approach using provinces\/states as clusters, but the benefit is not substantially greater or obvious. In some instances where the cluster populations are too small, the cluster approach does worse than the global view. When the model is applied to France for instance, the global approach outperforms the cluster-based approach. \n\nThe cluster-based approach is more sensitive to upticks or downticks (per cluster) in the data than the global model. The global model will not react and adjust as much to the latest data point.\n\nIf more clusters are introduced to the model, then the model will become even more sensitive to the latest data points. Also the model itself will have substantial errors with small populations, therefore the model might need a better optimization algorithm. ","2f31744b":"# Introduction","806f61dc":"The chart above shows that the cluster approach by province\/state has very little advantage over the global model for China. The error margins are compared more clearly in the figure below.","e1264c56":"### China","f0942819":"# Import","7dbe424a":"## Data","852c4a70":"# Explore","5c89466e":"This chapter treats each province\/state as a cluster, and simulates the spread of the Corona virus for each one. This is still not quite accurate enough (as seen in a couple of provinces of China). But it does better with others such as Australia. ","9fe4ff23":"### Australia","ef1368da":"The chart above shows that the cluster approach by province\/state has some advantage over the global model for Australia. The error margins are compared more clearly in the figure below.","a6008214":"# Conclusion","91dcf21e":" In the charts above we see that the model still fails with some provinces\/states such as Beijing, Gansu, Hong-Kong, Hubei (significant weight), Macau, Shandong, and Shanghai. These provinces\/states should be modelled as though they have more than one cluster to get better accuracy. The others are modelled with sufficient accuracy.   ","459e8245":"## Study Settings","ea009607":"<h1>Table of Contents<span class=\"tocSkip\"><\/span><\/h1>\n<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#Introduction\" data-toc-modified-id=\"Introduction-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;<\/span>Introduction<\/a><\/span><\/li><li><span><a href=\"#Import\" data-toc-modified-id=\"Import-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;<\/span>Import<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Python-Libraries\" data-toc-modified-id=\"Python-Libraries-2.1\"><span class=\"toc-item-num\">2.1&nbsp;&nbsp;<\/span>Python Libraries<\/a><\/span><\/li><li><span><a href=\"#Study-Settings\" data-toc-modified-id=\"Study-Settings-2.2\"><span class=\"toc-item-num\">2.2&nbsp;&nbsp;<\/span>Study Settings<\/a><\/span><\/li><li><span><a href=\"#Data\" data-toc-modified-id=\"Data-2.3\"><span class=\"toc-item-num\">2.3&nbsp;&nbsp;<\/span>Data<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#Explore\" data-toc-modified-id=\"Explore-3\"><span class=\"toc-item-num\">3&nbsp;&nbsp;<\/span>Explore<\/a><\/span><\/li><li><span><a href=\"#Model\" data-toc-modified-id=\"Model-4\"><span class=\"toc-item-num\">4&nbsp;&nbsp;<\/span>Model<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Global-view-only-(Country-level-analysis)\" data-toc-modified-id=\"Global-view-only-(Country-level-analysis)-4.1\"><span class=\"toc-item-num\">4.1&nbsp;&nbsp;<\/span>Global view only (Country level analysis)<\/a><\/span><\/li><li><span><a href=\"#Cluster-View-(by-Province\/State)\" data-toc-modified-id=\"Cluster-View-(by-Province\/State)-4.2\"><span class=\"toc-item-num\">4.2&nbsp;&nbsp;<\/span>Cluster View (by Province\/State)<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#China\" data-toc-modified-id=\"China-4.2.1\"><span class=\"toc-item-num\">4.2.1&nbsp;&nbsp;<\/span>China<\/a><\/span><\/li><li><span><a href=\"#Australia\" data-toc-modified-id=\"Australia-4.2.2\"><span class=\"toc-item-num\">4.2.2&nbsp;&nbsp;<\/span>Australia<\/a><\/span><\/li><\/ul><\/li><\/ul><\/li><li><span><a href=\"#Conclusion\" data-toc-modified-id=\"Conclusion-5\"><span class=\"toc-item-num\">5&nbsp;&nbsp;<\/span>Conclusion<\/a><\/span><\/li><\/ul><\/div>","ab67adf6":"## Cluster View (by Province\/State)","de1560ce":"The dataframe above shows that the prediction from clusters tend to outperform the predictions from a global pov (red is the worst error). ","fe564adf":"The dataframe above shows that the prediction from clusters tend to outperform the predictions from a global pov (red is the worst error). ","3c1d5b26":"This section does a brief exploration of the latest data set.\n\nThe first table shows a global summary with the latest data. ","2c35f000":"Configure the notebook (see https:\/\/jupyter-notebook.readthedocs.io\/en\/stable\/config.html)","bfb0ca3e":"The table below shows the lastest values by country","e428513c":"# Model","5d9b3aeb":"This study uses the work from the following source: https:\/\/www.kaggle.com\/alixmartin\/covid-19-predictions. The previous study applied a model at a country level to predict the growth of confirmed cases. \n\nThe previous approach could not adequately explain the odd behaviours of growth for countries like China. In the China data, the curve seems to grow exponentially, then tapers off, then picks up exponentially again, and then tapers off.  \n\nThis author reckons that this behaviour exists, because the growth is cluster-based. Each cluster should be treated as a newly infected 'country' and therefore modelled seperately with  their results rolled up to predict the growth at a country or global level.\n\nThe data does not identify the clusters per country explicitly (which is probably at a town or suburb level). Therefore the study will examine it by province\/state to see whether a significant improvement in accuracy can be obtained.\n\nIn future work, the study could estimate the number of clusters, and provide parameters in the model that could assist in identifying clusters that are managing the COVID-19 contagion well or poorly.  ","250df317":"In this section we start by building and displaying a model for a country (ignoring the clusters). The model is simple to compare with the previous day's results. In the cases where the COVID-19 spread is recent and the number of confirmed cases are few the model is not accurate. In these low-number cases the predictions from yesterday to today may fluctate significantly. With the countries that have cases in the 100s or 1000s however, the model is fairly stable.  \n\nThis will be important to know later on when we model by clusters. The smaller the number of confirmed cases per cluster, the poorer the model should perform. ","18b7dab1":" In the charts above we see that the model fails with some provinces\/states that have low numbers.   ","0a6ba30d":"## Global view only (Country level analysis)"}}