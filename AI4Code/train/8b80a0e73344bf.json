{"cell_type":{"316f806a":"code","38a36de9":"code","677608f9":"code","ce689297":"code","55dee4ba":"code","b8cf62c1":"code","1a8d2ed8":"code","291b857b":"code","ef2f0adf":"code","08edb558":"code","f3ef54b0":"code","6be55d6f":"markdown","a6c070a8":"markdown","9e014d49":"markdown","ff6db0fb":"markdown"},"source":{"316f806a":"USE_COLAB, TRAIN_MODE = 0, 0","38a36de9":"import os, shutil, sys, time, gc\nimport logging, copy, multiprocessing\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom tqdm.auto import tqdm as tqdmauto\nfrom PIL import Image\nfrom collections import OrderedDict\n\nimport math, cv2, sklearn, albumentations\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch.utils import model_zoo\nfrom torch.utils.data import Dataset, DataLoader, RandomSampler\nfrom sklearn.model_selection import StratifiedKFold\n\nif not USE_COLAB:\n    print(os.listdir('..\/input\/'))\n    PATH = '..\/input\/plant-pathology-2020-fgvc7\/'\n    SAVE_PATH = '.\/'  # \u6a21\u578b\u8981\u4fdd\u5b58\u5230\u7684\u8def\u5f84\nelse:\n    from google.colab import drive\n\n    drive.mount('\/content\/drive', force_remount=True)\n    PATH = '.\/drive\/My Drive\/Competition\/plant-pathology-2020\/plant-pathology-2020\/'\n    SAVE_PATH = PATH\n    !git clone -q https:\/\/github.com\/welkin-feng\/ComputerVision.git\n    sys.path.append('.\/ComputerVision\/')\n    !git clone -q https:\/\/github.com\/rwightman\/pytorch-image-models.git\n    sys.path.append('.\/pytorch-image-models\/')\n\nprint(\"PATH: \", os.listdir(PATH))\nprint(\"SAVE_PATH: \", os.listdir(SAVE_PATH))\n\n# Gets the GPU if there is one, otherwise the cpu\nDEVICE = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nprint(DEVICE)\nrandom_seed = 644\nprint(f'random_state: {random_seed}')","677608f9":"DEVICE = DEVICE\nPATH = PATH\nSAVE_PATH = SAVE_PATH\n\nIMAGE_FILE_NAME = ['train_images_320x320.npy', 'test_images_320x320.npy']\nIMG_SHAPE = (1365, 2048, 3)\nINPUT_IMG_SHAPE = (320, 320, 3)\nIMG_MEAN = np.array([0])\nIMG_STD = np.array([1])\n\ntrain_transforms = {\n    'mix_prob': 1.0, 'mixup_prob': 0.2, 'cutmix_prob': 0.35, 'fmix_prob': 0, \n    'grid_prob': 0.2, 'erase_prob': 0, 'cutout_prob': 0, \n    'cutout_ratio': (0.1, 0.5), 'cut_size': int(INPUT_IMG_SHAPE[0] * 0.8), # (0.1, 0.3), \n    'brightness': (0.7, 1.1), 'noise_prob': 0, 'blur_prob': 0, 'drop_prob': 0, 'elastic_prob': 0,\n    'hflip_prob': 0.1, 'vflip_prob': 0, 'scale': (0.8, 1.1), \n    'shear': (-10, 10), 'translate_percent': (-0.15, 0.15), 'rotate': (-20, 20)\n}\n\nn_fold = 5\nfold = (0,) # (0, 1, 2, 3, 4)\nBATCH_SIZE = 64\nTEST_BATCH_SIZE = 16\naccumulation_steps = 1\nloss_weights = (1, 1)\n\nlearning_rate = 1e-3\nlr_ratio = np.sqrt(0.1)\nreduce_lr_metric = ['loss', 'score', 'both'][0]\npatience = 5\nnum_classes = 4\n\nn_epochs = 50\ntrain_epochs = 50\nresume = False\npretrained = not resume","ce689297":"df_train = pd.read_csv(PATH + 'train.csv')\ndf_train['class'] = np.argmax(df_train.iloc[:, 1:].values, axis=1)\n\nskf = StratifiedKFold(n_fold, shuffle = True, random_state = 644)\nfor i_fold, (train_idx, val_idx) in enumerate(skf.split(df_train, df_train['class'].values)):\n    df_train.loc[val_idx, 'fold'] = i_fold\ndf_train['fold'] = df_train['fold'].astype(int)\n\ndf_test = pd.read_csv(PATH + 'test.csv')\nsubmission = pd.read_csv(PATH + 'sample_submission.csv')","55dee4ba":"img_name = df_train['image_id'].iloc[0]\nimg = cv2.imread(PATH + 'images\/{}.jpg'.format(img_name))\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\nplt.imshow(img)\nplt.show()\nimg = cv2.resize(img, (512, 320), interpolation = cv2.INTER_AREA).astype('uint8')\nimg = cv2.rotate(img, rotateCode = cv2.ROTATE_90_CLOCKWISE)\nprint(img.shape)\nplt.imshow(img)\nplt.show()","b8cf62c1":"train_data1 = np.zeros((len(df_train), 320, 320, 3), 'uint8')\ntrain_data2 = np.zeros((len(df_train), 320, 512, 3), 'uint8')\nfor i in range(len(df_train)):\n    img_name = df_train['image_id'].iloc[i]\n    img = cv2.imread(PATH + 'images\/{}.jpg'.format(img_name))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    if img.shape != IMG_SHAPE:\n        print(img_name)\n        img = cv2.rotate(img, rotateCode = cv2.ROTATE_90_CLOCKWISE)\n    img1 = cv2.resize(img, (320, 320), interpolation = cv2.INTER_AREA).astype('uint8')\n    train_data1[i] = img1\n    img2 = cv2.resize(img, (512, 320), interpolation = cv2.INTER_AREA).astype('uint8')\n    train_data2[i] = img2\n\nnp.save(SAVE_PATH + 'train_images_320x320.npy', train_data1)\nnp.save(SAVE_PATH + 'train_images_320x512.npy', train_data2)","1a8d2ed8":"del train_data1, train_data2\ngc.collect()","291b857b":"test_data1 = np.zeros((len(df_test), 320, 320, 3), 'uint8')\ntest_data2 = np.zeros((len(df_test), 320, 512, 3), 'uint8')\n\nfor i in range(len(df_test)):\n    img_name = df_test['image_id'].iloc[i]\n    img = cv2.imread(PATH + 'images\/{}.jpg'.format(img_name))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    if img.shape != IMG_SHAPE:\n        print(img_name)\n        img = cv2.rotate(img, rotateCode = cv2.ROTATE_90_CLOCKWISE)\n    img1 = cv2.resize(img, (320, 320), interpolation = cv2.INTER_AREA).astype('uint8')\n    test_data1[i] = img1\n    img2 = cv2.resize(img, (512, 320), interpolation = cv2.INTER_AREA).astype('uint8')\n    test_data2[i] = img2\n\nnp.save(SAVE_PATH + 'test_images_320x320.npy', test_data1)\nnp.save(SAVE_PATH + 'test_images_320x512.npy', test_data2)","ef2f0adf":"shutil.copy(PATH + 'train.csv', SAVE_PATH)\nshutil.copy(PATH + 'test.csv', SAVE_PATH)\nshutil.copy(PATH + 'sample_submission.csv', SAVE_PATH)","08edb558":"class PlantPathologyDataset(Dataset):\n    def __init__(self, csv, idx, mode, transform = None, data = None):\n        self.csv = csv.reset_index(drop = True)\n        self.data = data\n        self.filepath_format = PATH + 'images\/{}.jpg'\n        self.idx = np.asarray(idx).astype('int')\n        self.mode = mode\n        self.transform = transform\n\n    def __len__(self):\n        return self.idx.shape[0]\n\n    def __getitem__(self, index):\n        index = self.idx[index]\n        if self.data is not None:\n            image = self.data[index]\n        else:\n            img_name = self.csv['image_id'].iloc[index]\n            image = cv2.imread(self.filepath_format.format(img_name))\n        if image.shape != INPUT_IMG_SHAPE:\n            image = cv2.resize(image, INPUT_IMG_SHAPE[:2], interpolation = cv2.INTER_AREA)\n\n        image_origin = image.astype('float32').copy()\n        image = self.transform(image).astype('float32') if self.transform is not None else image.astype('float32')\n        image, image_origin =  np.rollaxis(image, 2, 0) \/ 255, np.rollaxis(image_origin, 2, 0) \/ 255\n\n        if self.mode == 'test':\n            return torch.tensor(image)\n        else:\n            label = self.csv.iloc[index, 1:5].values.astype('float32') # len = 4\n            return torch.tensor(image), torch.tensor(image_origin), torch.tensor(label)\n\n# transforms\ntransforms_train = lambda image: albumentations.Compose([\n    albumentations.Cutout(max_h_size=train_transforms['cut_size'], max_w_size=train_transforms['cut_size'], num_holes=1, p=0.7),\n])(image=image)['image']\ntransforms_val = None\n\ndef get_train_val_dataloader(i_fold):\n    train_idx, valid_idx = np.where((df_train['fold'] != i_fold))[0], np.where((df_train['fold'] == i_fold))[0]\n    train_data = np.load(SAVE_PATH + 'train_images_320x320.npy')\n    dataset_train = PlantPathologyDataset(df_train, train_idx, 'train', transform=transforms_train, data = train_data)\n    dataset_valid = PlantPathologyDataset(df_train, valid_idx, 'val', transform=transforms_val, data = train_data)\n    train_loader = DataLoader(dataset_train, BATCH_SIZE, sampler=RandomSampler(dataset_train), num_workers=4, pin_memory=True)\n    valid_loader = DataLoader(dataset_valid, TEST_BATCH_SIZE, sampler=None, num_workers=4, pin_memory=True)\n\n    return train_loader, valid_loader\n\ndef get_test_dataloader():\n    test_data = np.load(SAVE_PATH + 'test_images_320x320.npy')\n    dataset_test = PlantPathologyDataset(df_test, np.arange(len(df_test)), 'test', data = test_data)\n    test_loader = DataLoader(dataset_test, TEST_BATCH_SIZE, sampler=None, num_workers=4)\n\n    return test_loader","f3ef54b0":"df_show = df_train.iloc[:100]\ndataset_show = PlantPathologyDataset(df_show, list(range(df_show.shape[0])), 'train', transform=None)\n\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 20,10\nfor i in range(2):\n    f, axarr = plt.subplots(1,5)\n    for p in range(5):\n        idx = np.random.randint(0, len(dataset_show))\n        t0 = time.time()\n        img, img_org, label = dataset_show[idx]\n        # print(f\"{time.time()-t0:.4f}\")\n        axarr[p].imshow(img.transpose(0, 1).transpose(1,2).squeeze())\n        axarr[p].set_title(idx)","6be55d6f":"# Dataset","a6c070a8":"read df_train & df_test","9e014d49":"convert train\/test images to .npy files","ff6db0fb":"# Config"}}