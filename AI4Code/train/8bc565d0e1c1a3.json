{"cell_type":{"d5eb22ff":"code","f771fa55":"code","f86e3312":"code","225f00b6":"code","7bd03536":"code","1d720669":"code","b89abac4":"code","d2d8ff7f":"code","ee77153b":"code","13ffe252":"code","ed04fe34":"code","a32b6819":"code","ade4d009":"code","2d1a22a4":"code","d101fc27":"code","e946d254":"code","620a21c7":"code","27994b71":"code","ac2b4563":"markdown","6d216dd2":"markdown","ae58e2c3":"markdown","1be4d527":"markdown","cd669e65":"markdown","e7268378":"markdown","0f3be7f7":"markdown","6a10078b":"markdown","a95b69ae":"markdown"},"source":{"d5eb22ff":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport geopandas as gpd\nimport re\nimport unidecode\nfrom shapely.ops import nearest_points\nfrom shapely.geometry import Point, LineString\n\ndef split_et(x, source):\n    if type(x[source]) == str and ' ET ' in x[source]:\n        split = x[source].split(' ET ')\n        x.RUE_ACCDN = split[0]\n        x.ACCDN_PRES_DE = split[1]\n    return x\n\ndef split_et_a(x):\n    return split_et(x, 'RUE_ACCDN')\n\ndef split_et_b(x):\n    return split_et(x, 'ACCDN_PRES_DE')\n\nsubstitution = {\n    '1300 4E AV': '4E AV',\n    '20335 BD HENRI BOURASSA': 'BD HENRI BOURASSA',\n    '2185 PERE LELIEVRE': 'PERE LELIEVRE',\n    '3E AV ANGLE 3E RUE': '3E AV',\n    '482 BD CHAMPLAIN': 'BD CHAMPLAIN',\n    'A L OPP': None,\n    'GDE AL E': 'GRANDE AL EST',\n    'GDE AL O': 'GRANDE AL OUEST',\n    'BD RENE LEVLESQUE': 'BD RENE LEVESQUE',\n    'COTE DE LA CANOLERIE': 'COTE DE LA CANOTERIE',\n    'ETIMAUVILLE': 'ESTIMAUVILLE'\n}\n\ndef substitute(a):\n    if substitution.get(a):\n        return substitution[a]\n    return a\n\n\nordinaux = {\n    '1E': '1RE',\n    '1ER': '1RE',\n    '1ERE': '1RE',\n}\n\ndef lookup_ordinaux(s):\n    if ordinaux.get(s):\n        return ordinaux[s]\n    return s\n\ndef correct_ordinaux(s):\n    s = ' '.join([lookup_ordinaux(m) for m in s.split(' ')])\n    s  = re.sub(r'([0-9]*)I?EME', r'\\1E', s)\n    return s\n    \ndef strip_accents(s):\n    return unidecode.unidecode(s)\n\nletters_numbers_only = re.compile('[^A-Z0-9]')\n\nabbreviations = [\n    ('SAINT-', 'ST-'),\n    ('SAINTE-', 'STE-'),\n    ('AUTOROUTE', 'AUT'),\n    ('BOULEVARD', 'BD'),\n    ('ROUTE', 'RTE'),\n    ('AVENUE', 'AV'),\n    ('CHEMIN', 'CH'),\n    ('ALLEE', 'AL'),\n    ('MONT', 'MT'),\n    ('MONSEIGNEUR', 'MGR')\n]\n\nliaisons_lowercase = [\n    \"de l'\", \n    \"d'\", \n    'des', \n    'du', \n    'de', \n    'de la',\n    'de l '\n    \"l'\", \n    '\u00e0', \n    'le',\n    'la'\n]\n\ninput_word_removal = [\n    'STAT'\n]\n\nliaisons = sorted([strip_accents(l).upper() for l in liaisons_lowercase], key=len, reverse=True)\n\ndef strip(s):\n    return s.strip()\n\ndef remove_input_word(s):\n    for a in input_word_removal:\n        s = re.sub(r'\\b%s\\b' % a, '', s)\n    return s\n\ndef suppress_liaisons(s):\n    s = ' '.join([m for m in s.replace(\"'\", ' ').split(' ') if m not in liaisons and m != 'L'])\n    return s\n\n\ndef abbreviate(s):\n    for a in abbreviations:\n        s = re.sub(r'\\b%s\\b' % a[0], a[1], s)\n    return s\n\ndef get_length(u):\n    if type(u) == LineString:\n        return u.length\n    else:\n        return len(u)\n\nimport fuzzywuzzy\n\nfrom fuzzywuzzy import fuzz\nfrom fuzzywuzzy import process\n\nvoies_unique = None\nfuzzy_cache = {}\ndef fuzzy_voies(search_street_name):\n    global voies_unique\n    global fuzzy_cache\n    if fuzzy_cache.get(search_street_name):\n        return fuzzy_cache.get(search_street_name)\n    if voies_unique is None:\n        voies_unique = voies.nom_saaq.unique()\n    (street_name, ratio) = process.extractOne(search_street_name, voies_unique)\n    if ratio < 80:\n        return None    \n    fuzzy_cache[search_street_name] = street_name\n    return street_name\n\ndef lookup_geometry(street_name):\n    if type(street_name) != str:\n        return None\n    \n    if street_name == 'LIONEL GROULX':\n        return Point(-71.3823807, 46.7434531)\n    if street_name == 'EUGENE LAMONTAGNE':\n        return Point(-71.2416112,1846.8289132, 46.8289132)\n    if street_name == 'RTE RACETTE':\n        return Point(-71.4645578,16.18, 46.7388829)\n    \n    street_name = convert_from_saaq(street_name)\n    selected_voies = voies[voies.nom_saaq.str.contains(street_name)]\n    \n    # if no result turn to fuzzy matching\n    if len(selected_voies) == 0:\n        street_name = fuzzy_voies(street_name)\n        if street_name is None:\n            return None\n        selected_voies = voies[voies.nom_saaq.str.contains(street_name)]\n    \n    voies_union = selected_voies.unary_union\n    if not get_length(voies_union) > 0.0:\n        return None\n    return voies_union\n\n\ndef geocode(a, b):\n    geometry_a = lookup_geometry(a)\n    geometry_b = lookup_geometry(b)\n    \n    valid_a = geometry_a is not None\n    valid_b = geometry_b is not None\n    \n    if not valid_a and valid_b:\n        p = geometry_b.representative_point()\n    elif not valid_b and valid_a:\n        p = geometry_a.representative_point()\n    elif valid_a and valid_b:\n        p_pair = nearest_points(geometry_a, geometry_b)\n        p = p_pair[0]\n    else:\n        return None\n    return p\n\n\nconversions_to_saaq = [\n    strip_accents,\n    lambda s: s.upper(),\n    abbreviate,\n    suppress_liaisons,\n    lambda s: re.sub(letters_numbers_only, ' ', s),\n    lambda s: s.replace('  ', ' ')\n]\n\nconversions_from_saaq = [\n    remove_input_word,\n    substitute,\n    suppress_liaisons,\n    correct_ordinaux,\n    strip\n]\n\ndef convert_to_saaq(s):\n    for c in conversions_to_saaq:\n        s = c(s)\n    return s\n\ndef convert_from_saaq(s):\n    for c in conversions_from_saaq:\n        s = c(s)\n    return s\n\n\nimport unittest \n  \nclass TestStringMethods(unittest.TestCase): \n    def test_suppress_liaisons1(self):\n        self.assertEqual(\"CH EGLISE\", suppress_liaisons(\"CH DE L'EGLISE\")) \n    def test_suppress_liaisons2(self):\n        self.assertEqual('BD CHAUDIERE', suppress_liaisons('BD DE LA CHAUDIERE'))\n    def test_correct_ordinaux1(self):\n        self.assertEqual('1RE AV', correct_ordinaux('1E AV'))\n    def test_remove_input_word(self):\n        self.assertEqual('AV CHAUVEAU ', remove_input_word('AV CHAUVEAU STAT'))\n    def test_fuzzy_voies(self):\n        self.assertEqual('AV MADELEINE DE VERCHERES', fuzzy_voies('AV MADELEINE DE VERCHERE'))\n    def test_correct_ordinaux2(self):\n        self.assertEqual('3E AV', correct_ordinaux('3IEME AV'))\n    def test_example1(self):\n        self.assertIn(convert_from_saaq('BD CHAUDIERE'), convert_to_saaq(\"Boulevard de la Chaudi\u00e8re\"))\n    def test_example2(self):\n        self.assertIn(convert_from_saaq('COTE DE LA CANOLERIE'), convert_to_saaq(\"C\u00f4te de la Canoterie\"))\n    def test_example3(self):\n        self.assertIn(convert_from_saaq('CH EGLISE'), convert_to_saaq(\"Chemin de l'\u00c9glise\"))\n    def test_example4(self):\n        self.assertIn(convert_from_saaq('CH CANARDIERE'), convert_to_saaq(\"Chemin de la Canardi\u00e8re\"))   \n    def test_example5(self):\n        self.assertIn(convert_from_saaq('MGR GAUTHIER'), convert_to_saaq(\"Boulevard Monseigneur-Gauthier\")) \n    def test_example6(self):\n        self.assertIn(convert_from_saaq('COTE CAP ROUGE'), convert_to_saaq(\"C\u00f4te de Cap-Rouge\")) \n    def test_example7(self):\n        self.assertIn(convert_from_saaq('DU COLISEE'), convert_to_saaq(\"Avenue du Colis\u00e9e\")) \n    def test_example8(self):\n        self.assertIn(convert_from_saaq('DE L AGRICULTURE'), convert_to_saaq(\"Rue de l'Agriculture\"))\n    def test_1re_avenue(self):\n         self.assertIn(convert_from_saaq('1E AV'), convert_to_saaq(\"1re Avenue\"))\n         self.assertIn(convert_from_saaq('1ER AV'), convert_to_saaq(\"1re Avenue\"))\n         self.assertIn(convert_from_saaq('1E AV'), convert_to_saaq(\"1re Avenue\"))\n    def test_3e_avenue(self):\n         self.assertIn(convert_from_saaq('3IEME AV'), convert_to_saaq(\"3e Avenue\"))\n         self.assertIn(convert_from_saaq('3EME AV'), convert_to_saaq(\"3e Avenue\"))\n    def test_estimauville(self):\n         self.assertIn(convert_from_saaq('D ESTIMAUVILLE'), convert_to_saaq(\"Avenue D'Estimauville\"))\n    def test_laurentienne(self):\n         self.assertIn(convert_from_saaq('AUT LAURENTIENNE'), convert_to_saaq(\"Autoroute Laurentienne\"))\n    def test_chauveau(self):\n         self.assertIn(convert_from_saaq('AV CHAUVEAU STAT'), convert_to_saaq(\"Avenue Chauveau\"))\n    def test_madeleine(self):\n         geocode('AV MADELEINE DE VERCHERE',None)\n        \n    \n\nif __name__ == '__main__': \n    unittest.main(argv=['first-arg-is-ignored'], exit=False) ","f771fa55":"voies = gpd.read_file('\/kaggle\/input\/vdq-voies-publiques\/vdq-voiepublique.shp')\nvoies['nom_saaq'] = voies.NOM_TOPOGR.apply(convert_to_saaq)\nvoies","f86e3312":"voies.LIAISON.unique()","225f00b6":"df = pd.read_csv('\/kaggle\/input\/extraction-quebec-city-bicycle-accidents-2013-2019\/saaq-vdq-cyclistes.csv')","7bd03536":"invalid = df[(df.RUE_ACCDN.isnull()) & (df.ACCDN_PRES_DE.isnull())]","1d720669":"invalid","b89abac4":"accidents = df.drop(invalid.index)","d2d8ff7f":"accidents = accidents.apply(split_et_a, axis=1)\naccidents = accidents.apply(split_et_b, axis=1)","ee77153b":"rues = set(accidents.RUE_ACCDN.unique()).union(accidents.ACCDN_PRES_DE.unique())\nrues_count = len(rues)\nlookup = [(r,lookup_geometry(r)) for r in rues]\nnot_found = sorted([r for (r,g) in lookup if not g][1:])\nnot_found_count = len(not_found)\n\nrecognition_rate = (rues_count - not_found_count)\/rues_count\nprint(f'Recognition rate: {int(recognition_rate*100)}% [{not_found_count} out of {rues_count} not found]')\nnot_found","13ffe252":"%%time\naccidents['geometry'] = accidents.apply(lambda x: geocode(x.RUE_ACCDN, x.ACCDN_PRES_DE), axis=1)\naccidents","ed04fe34":"invalid_lookup = accidents[accidents.geometry.isna()]\ninvalid_lookup","a32b6819":"accidents_valid = accidents[~accidents.geometry.isna()]\naccidents_valid","ade4d009":"bad_coordinates = accidents_valid[accidents_valid.geometry.apply(lambda p: (int(p.y) != 46) or (int(p.x) != -71))]\naccidents_valid.drop(bad_coordinates.index, inplace=True)\nbad_coordinates","2d1a22a4":"accidents_gpd = gpd.GeoDataFrame(accidents_valid)","d101fc27":"accidents_gpd.total_bounds","e946d254":"accidents_gpd.geometry = accidents_gpd.geometry.set_crs(4326)","620a21c7":"accidents_gpd.to_file('\/kaggle\/working\/saaq-vdq-cyclistes.shp')","27994b71":"import folium\nfrom folium import plugins\n\nmap = folium.Map(\n    tiles='Stamen Toner'\n)\nbounds = accidents_gpd.total_bounds\nconverted_bounds = [(bounds[1], bounds[0]), (bounds[3], bounds[2])]\nmap.fit_bounds(converted_bounds)\n# accidents_gpd.geometry.apply(lambda p: folium.Marker(location=[p.x, p.y]).add_to(map))\ndata = accidents_gpd.geometry.apply(lambda p: [p.y, p.x])\nmap.add_child(plugins.HeatMap(data, radius=25))\nmap","ac2b4563":"# D\u00e9claration et configuration globale","6d216dd2":"# G\u00e9ocodage","ae58e2c3":"# Conversion et \u00e9criture au disque","1be4d527":"# Introduction\n\nDe l'extraction originale des accidents cyclistes pour la Ville de Qu\u00e9bec, nous allons g\u00e9olocalis\u00e9 chaque accident.","cd669e65":"# Benchmark de la reconnaissance de l'ensemble des valeurs de rues","e7268378":"# Lecture et filtre de l'extraction cycliste","0f3be7f7":"# Reprojection des intersections combin\u00e9es (rue ET intersection)","6a10078b":"# Voies publiques\n\nnous utilisons les voies publiques de la Ville de Qu\u00e9bec","a95b69ae":"# Carte interactive"}}