{"cell_type":{"af05c56f":"code","d9b99925":"code","b862b77d":"code","98620600":"code","d95554e1":"code","e42c24d0":"code","c60a4bf5":"code","efd1b6d2":"code","8b98c36c":"code","a8a75343":"code","af158c13":"code","b37587af":"markdown","25d09428":"markdown","364bc6fd":"markdown","9a98e7fa":"markdown","5613d7b0":"markdown","a742df82":"markdown","b2aa6190":"markdown","c34ca73c":"markdown","18e36304":"markdown"},"source":{"af05c56f":"!pip install -U transformers","d9b99925":"import torch\nfrom transformers import AutoModel, AutoTokenizer, BertTokenizer\n\ntorch.set_grad_enabled(False)","b862b77d":"# Store the model we want to use\nMODEL_NAME = \"bert-base-cased\"\n\n# We need to create the model and tokenizer\nmodel = AutoModel.from_pretrained(MODEL_NAME)\ntokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)","98620600":"# Tokens comes from a process that splits the input into sub-entities with interesting linguistic properties. \ntokens = tokenizer.tokenize(\"This is an input example\")\nprint(\"Tokens: {}\".format(tokens))\n\n# This is not sufficient for the model, as it requires integers as input, \n# not a problem, let's convert tokens to ids.\ntokens_ids = tokenizer.convert_tokens_to_ids(tokens)\nprint(\"Tokens id: {}\".format(tokens_ids))\n\n# Add the required special tokens\ntokens_ids = tokenizer.build_inputs_with_special_tokens(tokens_ids)\n\n# We need to convert to a Deep Learning framework specific format, let's use PyTorch for now.\ntokens_pt = torch.tensor([tokens_ids])\nprint(\"Tokens PyTorch: {}\".format(tokens_pt))\n\n# Now we're ready to go through BERT with out input\noutputs, pooled = model(tokens_pt)\nprint(\"Tokenw   ise output: {}, Pooled output: {}\".format(outputs.shape, pooled.shape))","d95554e1":"# tokens = tokenizer.tokenize(\"This is an input example\")\n# tokens_ids = tokenizer.convert_tokens_to_ids(tokens)\n# tokens_pt = torch.tensor([tokens_ids])\n\n# This code can be factored into one-line as follow\ntokens_pt2 = tokenizer.encode_plus(\"This is an input example\", return_tensors=\"pt\")\n\nfor key, value in tokens_pt2.items():\n    print(\"{}:\\n\\t{}\".format(key, value))\n\noutputs2, pooled2 = model(**tokens_pt2)\nprint(\"Difference with previous code: ({}, {})\".format((outputs2 - outputs).sum(), (pooled2 - pooled).sum()))","e42c24d0":"# Single segment input\nsingle_seg_input = tokenizer.encode_plus(\"This is a sample input\")\n\n# Multiple segment input\nmulti_seg_input = tokenizer.encode_plus(\"This is segment A\", \"This is segment B\")\n\nprint(\"Single segment token (str): {}\".format(tokenizer.convert_ids_to_tokens(single_seg_input['input_ids'])))\nprint(\"Single segment token (int): {}\".format(single_seg_input['input_ids']))\nprint(\"Single segment type       : {}\".format(single_seg_input['token_type_ids']))\n\n# Segments are concatened in the input to the model, with \nprint()\nprint(\"Multi segment token (str): {}\".format(tokenizer.convert_ids_to_tokens(multi_seg_input['input_ids'])))\nprint(\"Multi segment token (int): {}\".format(multi_seg_input['input_ids']))\nprint(\"Multi segment type       : {}\".format(multi_seg_input['token_type_ids']))","c60a4bf5":"# Padding highlight\ntokens = tokenizer.batch_encode_plus(\n    [\"This is a sample\", \"This is another longer sample text\"], \n    pad_to_max_length=True  # First sentence will have some PADDED tokens to match second sequence length\n)\n\nfor i in range(2):\n    print(\"Tokens (int)      : {}\".format(tokens['input_ids'][i]))\n    print(\"Tokens (str)      : {}\".format([tokenizer.convert_ids_to_tokens(s) for s in tokens['input_ids'][i]]))\n    print(\"Tokens (attn_mask): {}\".format(tokens['attention_mask'][i]))\n    print()","efd1b6d2":"from transformers import TFBertModel, BertModel\n\n# Let's load a BERT model for TensorFlow and PyTorch\nmodel_tf = TFBertModel.from_pretrained('bert-base-cased')\nmodel_pt = BertModel.from_pretrained('bert-base-cased')","8b98c36c":"# transformers generates a ready to use dictionary with all the required parameters for the specific framework.\ninput_tf = tokenizer.encode_plus(\"This is a sample input\", return_tensors=\"tf\")\ninput_pt = tokenizer.encode_plus(\"This is a sample input\", return_tensors=\"pt\")\n\n# Let's compare the outputs\noutput_tf, output_pt = model_tf(input_tf), model_pt(**input_pt)\n\n# Models outputs 2 values (The value for each tokens, the pooled representation of the input sentence)\n# Here we compare the output differences between PyTorch and TensorFlow.\nfor name, o_tf, o_pt in zip([\"output\", \"pooled\"], output_tf, output_pt):\n    print(\"{} differences: {}\".format(name, (o_tf.numpy() - o_pt.numpy()).sum()))","a8a75343":"from transformers import DistilBertModel\n\nbert_distil = DistilBertModel.from_pretrained('distilbert-base-cased')\ninput_pt = tokenizer.encode_plus(\n    'This is a sample input to demonstrate performance of distiled models especially inference time', \n    return_tensors=\"pt\"\n)\n\n\n%time _ = bert_distil(input_pt['input_ids'])\n%time _ = model_pt(input_pt['input_ids'])","af158c13":"# Let's load German BERT from the Bavarian State Library\nde_bert = BertModel.from_pretrained(\"dbmdz\/bert-base-german-cased\")\nde_tokenizer = BertTokenizer.from_pretrained(\"dbmdz\/bert-base-german-cased\")\n\nde_input = de_tokenizer.encode_plus(\n    \"Hugging Face ist einen franz\u00f6sische Firma Mitarbeitern in New-York.\",\n    return_tensors=\"pt\"\n)\noutput_de, pooled_de = de_bert(**de_input)","b37587af":"## Want it lighter? Faster? Let's talk distillation! \n\nOne of the main concerns when using these Transformer based models is the computational power they require. All over this notebook we are using BERT model as it can be run on common machines but that's not the case for all of the models.\n\nFor example, Google released a few months ago **T5** an Encoder\/Decoder architecture based on Transformer and available in `transformers` with no more than 11 billions parameters. Microsoft also recently entered the game with **Turing-NLG** using 17 billions parameters. This kind of model requires tens of gigabytes to store the weights and a tremendous compute infrastructure to run such models which makes it impracticable for the common man !\n\n![transformers-parameters](https:\/\/lh5.googleusercontent.com\/NRdXzEcgZV3ooykjIaTm9uvbr9QnSjDQHHAHb2kk_Lm9lIF0AhS-PJdXGzpcBDztax922XAp386hyNmWZYsZC1lUN2r4Ip5p9v-PHO19-jevRGg4iQFxgv5Olq4DWaqSA_8ptep7)\n\nWith the goal of making Transformer-based NLP accessible to everyone we @huggingface developed models that take advantage of a training process called **Distillation** which allows us to drastically reduce the resources needed to run such models with almost zero drop in performances.\n\nGoing over the whole Distillation process is out of the scope of this notebook, but if you want more information on the subject you may refer to [this Medium article written by my colleague Victor SANH, author of DistilBERT paper](https:\/\/medium.com\/huggingface\/distilbert-8cf3380435b5), you might also want to directly have a look at the paper [(Sanh & al., 2019)](https:\/\/arxiv.org\/abs\/1910.01108)\n\nOf course, in `transformers` we have distilled some models and made them available directly in the library ! ","25d09428":"## Frameworks interoperability\n\nOne of the most powerfull feature of transformers is its ability to seamlessly move from PyTorch to Tensorflow\nwithout pain for the user.\n\nWe provide some convenient methods to load TensorFlow pretrained weight insinde a PyTorch model and opposite.","364bc6fd":"## Getting started with transformers\n\nFor the rest of this notebook, we will use the [BERT (Devlin & al., 2018)](https:\/\/arxiv.org\/abs\/1810.04805) architecture, as it's the most simple and there are plenty of content about it\nover the internet, it will be easy to dig more over this architecture if you want to.\n\nThe transformers library allows you to benefits from large, pretrained language models without requiring a huge and costly computational\ninfrastructure. Most of the State-of-the-Art models are provided directly by their author and made available in the library \nin PyTorch and TensorFlow in a transparent and interchangeable way. ","9a98e7fa":"As you can see above, the methode `encode_plus` provides a convenient way to generate all the required parameters\nthat will go through the model. \n\nMoreover, you might have noticed it generated some additional tensors: \n\n- token_type_ids: This tensor will map every tokens to their corresponding segment (see below).\n- attention_mask: This tensor is used to \"mask\" padded values in a batch of sequence with different lengths (see below).","5613d7b0":"As you can see, BERT outputs two tensors:\n - One with the generated representation for every token in the input `(1, NB_TOKENS, REPRESENTATION_SIZE)`\n - One with an aggregated representation for the whole input `(1, REPRESENTATION_SIZE)`\n \nThe first, token-based, representation can be leveraged if your task requires to keep the sequence representation and you\nwant to operate at a token-level. This is particularly useful for Named Entity Recognition and Question-Answering.\n\nThe second, aggregated, representation is especially useful if you need to extract the overall context of the sequence and don't\nrequire a fine-grained token-leven. This is the case for Sentiment-Analysis of the sequence or Information Retrieval.","a742df82":"## Introduction\nThe transformers library is an open-source, community-based repository to train, use and share models based on \nthe Transformer architecture [(Vaswani & al., 2017)](https:\/\/arxiv.org\/abs\/1706.03762) such as Bert [(Devlin & al., 2018)](https:\/\/arxiv.org\/abs\/1810.04805),\nRoberta [(Liu & al., 2019)](https:\/\/arxiv.org\/abs\/1907.11692), GPT2 [(Radford & al., 2019)](https:\/\/cdn.openai.com\/better-language-models\/language_models_are_unsupervised_multitask_learners.pdf),\nXLNet [(Yang & al., 2019)](https:\/\/arxiv.org\/abs\/1906.08237), etc. \n\nAlong with the models, the library contains multiple variations of each of them for a large variety of \ndownstream-tasks like **Named Entity Recognition (NER)**, **Sentiment Analysis**, \n**Language Modeling**, **Question Answering** and so on.\n\n## Before Transformer\n\nBack to 2017, most of the people using Neural Networks when working on Natural Language Processing were relying on \nsequential processing of the input through [Recurrent Neural Network (RNN)](https:\/\/en.wikipedia.org\/wiki\/Recurrent_neural_network).\n\n![rnn](http:\/\/colah.github.io\/posts\/2015-09-NN-Types-FP\/img\/RNN-general.png)   \n\nRNNs were performing well on large variety of tasks involving sequential dependency over the input sequence. \nHowever, this sequentially-dependent process had issues modeling very long range dependencies and \nwas not well suited for the kind of hardware we're currently leveraging due to bad parallelization capabilities. \n\nSome extensions were provided by the academic community, such as Bidirectional RNN ([Schuster & Paliwal., 1997](https:\/\/www.researchgate.net\/publication\/3316656_Bidirectional_recurrent_neural_networks), [Graves & al., 2005](https:\/\/mediatum.ub.tum.de\/doc\/1290195\/file.pdf)), \nwhich can be seen as a concatenation of two sequential process, one going forward, the other one going backward over the sequence input.\n\n![birnn](https:\/\/miro.medium.com\/max\/764\/1*6QnPUSv_t9BY9Fv8_aLb-Q.png)\n\n\nAnd also, the Attention mechanism, which introduced a good improvement over \"raw\" RNNs by giving \na learned, weighted-importance to each element in the sequence, allowing the model to focus on important elements.\n\n![attention_rnn](https:\/\/3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com\/wp-content\/uploads\/2017\/08\/Example-of-Attention.png)  \n\n## Then comes the Transformer  \n\nThe Transformers era originally started from the work of [(Vaswani & al., 2017)](https:\/\/arxiv.org\/abs\/1706.03762) who\ndemonstrated its superiority over [Recurrent Neural Network (RNN)](https:\/\/en.wikipedia.org\/wiki\/Recurrent_neural_network)\non translation tasks but it quickly extended to almost all the tasks RNNs were State-of-the-Art at that time.\n\nOne advantage of Transformer over its RNN counterpart was its non sequential attention model. Remember, the RNNs had to\niterate over each element of the input sequence one-by-one and carry an \"updatable-state\" between each hop. With Transformer, the model is able to look at every position in the sequence, at the same time, in one operation.\n\nFor a deep-dive into the Transformer architecture, [The Annotated Transformer](https:\/\/nlp.seas.harvard.edu\/2018\/04\/03\/attention.html#encoder-and-decoder-stacks) \nwill drive you along all the details of the paper.\n\n![transformer-encoder-decoder](https:\/\/nlp.seas.harvard.edu\/images\/the-annotated-transformer_14_0.png)","b2aa6190":"The code you saw in the previous section introduced all the steps required to do simple model invocation.\nFor more day-to-day usage, transformers provides you higher-level methods which will makes your NLP journey easier\nLet's improve our previous example","c34ca73c":"With only the above two lines of code, you're ready to use a BERT pre-trained model. \nThe tokenizers will allow us to map a raw textual input to a sequence of integers representing our textual input\nin a way the model can manipulate.","18e36304":"## Community provided models\n\nLast but not least, earlier in this notebook we introduced Hugging Face `transformers` as a repository for the NLP community to exchange pretrained models. We wanted to highlight this features and all the possibilities it offers for the end-user.\n\nTo leverage community pretrained models, just provide the organisation name and name of the model to `from_pretrained` and it will do all the magic for you ! \n\n\nWe currently have more 50 models provided by the community and more are added every day, don't hesitate to give it a try !"}}