{"cell_type":{"51c9c42d":"code","97a7d957":"code","54fe59b8":"code","f7507e32":"code","5b8963aa":"code","cc70defa":"code","789af0e6":"code","508424a0":"code","f1558b01":"code","01b0bc3b":"code","e3db96f3":"code","8d24dac9":"code","c044bd8f":"code","db3c680b":"code","cdd1b36c":"code","fc93f071":"code","c791fdef":"code","1fd4d34e":"code","bd1c3bcb":"markdown"},"source":{"51c9c42d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","97a7d957":"import tensorflow.keras.layers as Layers\nimport tensorflow.keras.activations as Actications\nimport tensorflow.keras.models as Models\nimport tensorflow.keras.optimizers as Optimizer\nimport tensorflow.keras.metrics as Metrics\nimport tensorflow.keras.utils as Utils\nfrom keras.utils.vis_utils import model_to_dot\nimport os\nimport matplotlib.pyplot as plot\nimport cv2\nimport numpy as np\nfrom sklearn.utils import shuffle\nfrom sklearn.metrics import confusion_matrix as CM\nfrom random import randint\nfrom IPython.display import SVG\nfrom tensorflow.keras.utils import  plot_model\nimport matplotlib.gridspec as gridspec\n\n\n\n\nimport pandas as pd\n\nfrom skimage.io import imread, imsave\nfrom tqdm import tqdm\n\n%matplotlib inline\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\nfrom skimage.transform import rotate\nfrom skimage.util import random_noise\nfrom skimage.filters import gaussian\nfrom scipy import ndimage","54fe59b8":"def get_images(directory):\n    Images = []\n    Labels = []  # 0 for not_almond , 1 for good_almond, 2 for bad_almond\n    label = 0\n    \n    for labels in os.listdir(directory): #Main Directory where each class label is present as folder name.\n        if labels == 'bad_almond': #Folder contain bad_almond Images get the '2' class label.\n            label = 2\n        elif labels == 'good_almond':\n            label = 1\n        elif labels == 'not_almond':\n            label = 0\n        \n        for image_file in os.listdir(directory+labels): #Extracting the file name of the image from Class Label folder\n            image = cv2.imread(directory+labels+r'\/'+image_file) #Reading the image (OpenCV)\n            image = cv2.resize(image,(150,150)) #Resize the image, Some images are different sizes. (Resizing is very Important)\n            Images.append(image)\n            Labels.append(label)\n    \n    return shuffle(Images,Labels,random_state=817328462) #Shuffle the dataset you just prepared.\n\ndef get_classlabel(class_code):\n    labels = {2:'bad_almond', 1:'good_almond', 0:'not_almond'}\n    \n    return labels[class_code]","f7507e32":"Images, Labels = get_images('..\/input\/almonddataset\/training\/training\/') #Extract the training images from the folders.\n\nImages = np.array(Images) #converting the list of images to numpy array.\nLabels = np.array(Labels)","5b8963aa":"print(\"Shape of Images:\",Images.shape)\nprint(\"Shape of Labels:\",Labels.shape)","cc70defa":"f,ax = plot.subplots(3,3) \nf.subplots_adjust(0,0,3,3)\nfor i in range(0,3,1):\n    for j in range(0,3,1):\n        rnd_number = randint(0,len(Images))\n        ax[i,j].imshow(Images[rnd_number])\n        ax[i,j].set_title(get_classlabel(Labels[rnd_number]))\n        ax[i,j].axis('off')","789af0e6":"model = Models.Sequential()\n\nmodel.add(Layers.Conv2D(200,kernel_size=(3,3),activation='relu',input_shape=(150,150,3)))\nmodel.add(Layers.Conv2D(180,kernel_size=(3,3),activation='relu'))\nmodel.add(Layers.MaxPool2D(5,5))\nmodel.add(Layers.Conv2D(180,kernel_size=(3,3),activation='relu'))\nmodel.add(Layers.Conv2D(140,kernel_size=(3,3),activation='relu'))\nmodel.add(Layers.Conv2D(100,kernel_size=(3,3),activation='relu'))\nmodel.add(Layers.Conv2D(50,kernel_size=(3,3),activation='relu'))\nmodel.add(Layers.MaxPool2D(5,5))\nmodel.add(Layers.Flatten())\nmodel.add(Layers.Dense(180,activation='relu'))\nmodel.add(Layers.Dense(100,activation='relu'))\nmodel.add(Layers.Dense(50,activation='relu'))\nmodel.add(Layers.Dropout(rate=0.5))\nmodel.add(Layers.Dense(6,activation='softmax'))\n\nmodel.compile(optimizer=Optimizer.Adam(lr=0.0001),loss='sparse_categorical_crossentropy',metrics=['accuracy'])\n\nmodel.summary()\n\nUtils.plot_model(model,to_file='model.png',show_shapes=True)","508424a0":"trained = model.fit(Images,Labels,epochs=35,validation_split=0.30)","f1558b01":"plot.plot(trained.history['accuracy'])\nplot.plot(trained.history['val_accuracy'])\nplot.title('Model accuracy')\nplot.ylabel('Accuracy')\nplot.xlabel('Epoch')\nplot.legend(['Train', 'Test'], loc='upper left')\nplot.show()\n\nplot.plot(trained.history['loss'])\nplot.plot(trained.history['val_loss'])\nplot.title('Model loss')\nplot.ylabel('Loss')\nplot.xlabel('Epoch')\nplot.legend(['Train', 'Test'], loc='upper left')\nplot.show()","01b0bc3b":"test_images,test_labels = get_images('..\/input\/almonddataset\/testing\/testing\/')\ntest_images = np.array(test_images)\ntest_labels = np.array(test_labels)\nmodel.evaluate(test_images,test_labels, verbose=1)","e3db96f3":"pred_images,no_labels = get_images('..\/input\/almonddataset\/validation\/validation\/')\npred_images = np.array(pred_images)\npred_images.shape","8d24dac9":"fig = plot.figure(figsize=(30, 30))\nouter = gridspec.GridSpec(5, 5, wspace=0.2, hspace=0.2)\n\nfor i in range(25):\n    inner = gridspec.GridSpecFromSubplotSpec(2, 1,subplot_spec=outer[i], wspace=0.1, hspace=0.1)\n    rnd_number = randint(0,len(pred_images))\n    pred_image = np.array([pred_images[rnd_number]])\n    pred_class = get_classlabel(model.predict_classes(pred_image)[0])\n    pred_prob = model.predict(pred_image).reshape(6)\n    for j in range(2):\n        if (j%2) == 0:\n            ax = plot.Subplot(fig, inner[j])\n            ax.imshow(pred_image[0])\n            ax.set_title(pred_class)\n            ax.set_xticks([])\n            ax.set_yticks([])\n            fig.add_subplot(ax)\n        else:\n            ax = plot.Subplot(fig, inner[j])\n            ax.bar([0,1,2,3,4,5],pred_prob)\n            fig.add_subplot(ax)\n\n\nfig.show()","c044bd8f":"def display_random_image(class_names, images, labels):\n    \"\"\"\n        Display a random image from the images array and its correspond label from the labels array.\n    \"\"\"\n    \n    index = np.random.randint(images.shape[0])\n    plt.figure()\n    plt.imshow(images[index])\n    plt.xticks([])\n    plt.yticks([])\n    plt.grid(False)\n    plt.title('Image #{} : '.format(index) + class_names[labels[index]])\n    plt.show()","db3c680b":"test_loss = model.evaluate(test_images, test_labels)","cdd1b36c":"predictions = model.predict(test_images)     # Vector of probabilities\npred_labels = np.argmax(predictions, axis = 1) # We take the highest probability\n\ndisplay_random_image(class_code, test_images, pred_labels)","fc93f071":"def print_mislabeled_images(class_names, test_images, test_labels, pred_labels):\n    \"\"\"\n        Print 25 examples of mislabeled images by the classifier, e.g when test_labels != pred_labels\n    \"\"\"\n    BOO = (test_labels == pred_labels)\n    mislabeled_indices = np.where(BOO == 0)\n    mislabeled_images = test_images[mislabeled_indices]\n    mislabeled_labels = pred_labels[mislabeled_indices]\n\n    title = \"Some examples of mislabeled images by the classifier:\"\n    display_examples(class_names,  mislabeled_images, mislabeled_labels)","c791fdef":"print_mislabeled_images(pred_class, test_images, test_labels, pred_labels)","1fd4d34e":"CM = confusion_matrix(test_labels, pred_labels)\nax = plt.axes()\nsn.heatmap(CM, annot=True, \n           annot_kws={\"size\": 10}, \n           xticklabels=class_names, \n           yticklabels=class_names, ax = ax)\nax.set_title('Confusion matrix')\nplt.show()","bd1c3bcb":"# Error analysis"}}