{"cell_type":{"da3f30e4":"code","e7bea5c3":"code","ff6abc49":"code","2b322c47":"code","2f1b66bb":"code","98881f1e":"code","c31a3edc":"code","38dfa0c9":"code","69a1cbda":"code","3ca675d8":"code","3c8b9bfa":"code","ccebf275":"code","acac7f62":"code","55c323b0":"code","2bf757a7":"code","c9fd755c":"code","086cee7a":"code","b8ecbe2e":"code","be847d95":"code","9020a934":"code","281561cc":"code","1bc85c16":"code","6edeceab":"code","114b3e3b":"code","d1206257":"code","9e3fdc57":"code","594462e8":"code","56f03881":"code","aeb7ea4d":"code","d4c4df3e":"code","efa0b206":"code","512bcafd":"code","76a877e5":"code","3f648993":"markdown","4c16f471":"markdown","2bea7e08":"markdown","fa0b6c52":"markdown","a820ff11":"markdown","53e5cc98":"markdown","376ec913":"markdown"},"source":{"da3f30e4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport scipy.ndimage\nfrom scipy.ndimage import rotate\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/\"))\nprint(os.listdir(\"..\/input\"))\n# Print the current path\nprint(os.path.abspath(os.curdir))\n\n\n# Any results you write to the current directory are saved as output.","e7bea5c3":"%matplotlib inline\nimport sys\nimport glob\n\n# third party\nimport tensorflow as tf\nimport scipy.io as sio\nfrom keras.backend.tensorflow_backend import set_session\nfrom scipy.interpolate import interpn\nimport matplotlib.pyplot as plt","ff6abc49":"vm_dir = \"..\/input\/voxelmorph-v3\/voxelmorph_3\/voxelmorph_3\/voxelmorph-master\/\"\nsys.path.append(os.path.join(vm_dir, 'src'))\nsys.path.append(os.path.join(vm_dir, 'ext', 'medipy-lib'))\nsys.path.append(os.path.join(vm_dir, 'ext', 'neuron'))\nsys.path.append(os.path.join(vm_dir, 'ext', 'pynd-lib'))\nsys.path.append(os.path.join(vm_dir, 'ext', 'pytool-lib'))\nprint(os.listdir('..\/input'))\nprint(os.listdir(vm_dir))\nimport medipy\nimport datagenerators\nfrom medipy.metrics import dice\nimport networks","2b322c47":"def print_image(vol):\n    depth, height, width = vol.shape\n    fig, ((ax1, ax2, ax3),(ax4, ax5, ax6)) = plt.subplots(2, 3, figsize=(20, 10))\n    ax1.imshow(np.mean(vol[:, :, :], axis=0))\n    ax2.imshow(np.mean(vol[:, :, :], axis=1))\n    ax3.imshow(np.mean(vol[:, :, :], axis=2))\n    ax4.imshow(vol[depth\/\/2, :, :])\n    ax5.imshow(vol[:, height\/\/2, :])\n    ax6.imshow(vol[:, :, width\/\/2])","2f1b66bb":"def print_slice(vol):\n    fig, (ax1, ax2, ax3) = ","98881f1e":"def compare_images(y_pred, X_vol, atlas_vol):\n    # show the mean of the input_test_data in each dimension\n    fig, ((ax1, ax2, ax3),(ax4, ax5, ax6),(ax7, ax8, ax9)) = plt.subplots(3, 3, figsize=(20,10))\n    ax1.imshow(np.mean(y_pred[0,:, :, :,0], axis=0))\n    ax1.set_title('pred')\n    ax2.imshow(np.mean(y_pred[0,:, :, :,0], axis=1))\n    ax2.set_title('pred')\n    ax3.imshow(np.mean(y_pred[0,:, :, :,0], axis=2))\n    ax3.set_title('pred')\n    ax4.imshow(np.mean(X_vol[0,:, :, :,0], axis=0))\n    ax4.set_title('moving-image')\n    ax5.imshow(np.mean(X_vol[0,:, :, :,0], axis=1))\n    ax5.set_title('moving-image')\n    ax6.imshow(np.mean(X_vol[0,:, :, :,0], axis=2))\n    ax6.set_title('moving-image')\n    ax7.imshow(np.mean(atlas_vol[0,:, :, :,0], axis=0))\n    ax7.set_title('atlas-image')\n    ax8.imshow(np.mean(atlas_vol[0,:, :, :,0], axis=1))\n    ax8.set_title('atlas-image')\n    ax9.imshow(np.mean(atlas_vol[0,:, :, :,0], axis=2))\n    ax9.set_title('atlas-image')\n\n    ","c31a3edc":"def meshgridnd_like(in_img,\n                    rng_func=range):\n    new_shape = list(in_img.shape)\n    all_range = [rng_func(i_len) for i_len in new_shape]\n    # np.swapaxes()\u4ea4\u6362\u5750\u6807\u8f74\uff1a\u7531(y, x, z)\u53d8\u4e3a(x, y, z)\n    return tuple([x_arr.swapaxes(0, 1) for x_arr in np.meshgrid(*all_range)])","38dfa0c9":"from mpl_toolkits.mplot3d import axes3d\ndef print_flow(vol_size, flow):\n    xx = np.arange(vol_size[1])\n    yy = np.arange(vol_size[0])\n    zz = np.arange(vol_size[2])\n    grid = np.rollaxis(np.array(np.meshgrid(xx, yy, zz)), 0, 4)\n    DS_FACTOR = 16\n    # c_xx, x_yy, c_zz are the x, y, z array for 10x12x14=1980 points\n    c_xx, c_yy, c_zz = [x.flatten()\n                        for x in \n                        meshgridnd_like(flow[::DS_FACTOR, ::DS_FACTOR, ::DS_FACTOR, 0])]\n\n    get_flow = lambda i: flow[::DS_FACTOR, ::DS_FACTOR, ::DS_FACTOR, i].flatten()\n\n    fig = plt.figure(figsize = (10, 10))\n    ax = fig.gca(projection='3d')\n\n    ax.quiver(c_xx,\n              c_yy,\n              c_zz,\n              get_flow(0),\n              get_flow(1), \n              get_flow(2), \n              length=0.9,\n              normalize=True)","69a1cbda":"# Set up the Network\n# We use the voxelmorph-2 here, with dec [32,32,32,32,32,16,16,3]\n# vol_size = (160, 192, 224) #(height, width, depth)\n# nf_enc = [16, 32, 32, 32]\n# nf_dec = [32, 32, 32, 32, 32, 16, 16, 3]\nvol_size=(160,192,224)\nnf_enc=[16,32,32,32]\nnf_dec=[32,32,32,32,32,16,16]","3ca675d8":"# load Atals data\nlabels = sio.loadmat(os.path.join(vm_dir, 'data', 'labels.mat'))['labels'][0]\ncvpr_atlas = np.load(os.path.join(vm_dir, 'data', 'atlas_norm.npz'))\n# Print what is inside the atlas\nfor key, value in cvpr_atlas.items():\n    print(key)\natlas_vol = cvpr_atlas['vol']\norigin_shape = atlas_vol.shape\nprint(atlas_vol.shape)","3c8b9bfa":"affine_atlats_testset = []\naffine_atlats_segs = []\n\n# 1. translation\natlas_trans = np.ndarray(shape=(origin_shape ),dtype=float)\nmatrix = np.array([[1, 0, 0, 5],[0, 1, 0, 10],[0, 0, 1, 15],[0, 0, 0, 1]])\natlas_trans = scipy.ndimage.affine_transform(input=atlas_vol, matrix=matrix)\n# Expand the dimension of the input: the first number is the number of the data, and the last one is the channel number\natlas_vol_p = np.reshape(atlas_vol, (1,)+atlas_vol.shape+(1,)) # 1x160x192x224x1\natlas_trans = np.reshape(atlas_trans, (1,)+atlas_trans.shape+(1,)) # 1x160x192x224x1\n\naffine_atlats_testset.append(atlas_trans)","ccebf275":"# 2. rotate\natlas_rot = np.ndarray(shape=(origin_shape),dtype=float)\natlas_rot = rotate(atlas_vol, 10, reshape=False)\n\n\n# atlas_seg = atlas['seg']\n# Expand the dimension of the input: the first number is the number of the data, and the last one is the channel number\natlas_rot = np.reshape(atlas_rot, (1,)+atlas_rot.shape+(1,)) # 1x160x192x224x1\nprint(atlas_rot.shape)\n\naffine_atlats_testset.append(atlas_rot)\n","acac7f62":"# 3. scale\natlas_sc = np.ndarray(shape=(origin_shape),dtype=float)\nmatrix = np.array([[1.1, 0, 0, 0],[0, 1.1, 0, 0],[0, 0, 1.1, 0],[0, 0, 0, 1]])\natlas_sc = scipy.ndimage.affine_transform(input=atlas_vol, matrix=matrix)\n\n\n# atlas_seg = atlas['seg']\n# Expand the dimension of the input: the first number is the number of the data, and the last one is the channel number\natlas_sc = np.reshape(atlas_sc, (1,)+atlas_sc.shape+(1,)) # 1x160x192x224x1\n\naffine_atlats_testset.append(atlas_sc)","55c323b0":"config = tf.ConfigProto()\nconfig.gpu_options.allow_growth = True\nconfig.allow_soft_placement = True\nset_session(tf.Session(config=config))","2bf757a7":"gpu = '\/gpu:0'\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = '0'\n# load weights of model\ncvpr_model = vm_dir + 'models\/cvpr2018_vm2_l2.h5'\nlocal_model = vm_dir + 'models\/255.h5'\nwith tf.device(gpu):\n    net = networks.cvpr2018_net(vol_size, nf_enc, nf_dec)\n    # net.load_weights('..\/models\/' + model_name + '\/' + str(iter_num) + '.h5')\n    net.load_weights(cvpr_model)\n    local_net = networks.cvpr2018_net(vol_size, nf_enc, nf_dec)\n    local_net.load_weights(local_model)","c9fd755c":"with tf.device(gpu):\n    pred = []\n    for i in range(len(affine_atlats_testset)):\n        print(affine_atlats_testset[i].shape,atlas_vol_p.shape)\n        pred.append(net.predict([affine_atlats_testset[i], atlas_vol_p]))\n\n    \n","086cee7a":"for i in range(len(affine_atlats_testset)):\n    compare_images(y_pred=pred[i][0], X_vol=affine_atlats_testset[i], atlas_vol=atlas_vol_p)\n    print_image(pred[i][0][0,:, :, :, 0 ])","b8ecbe2e":"local_atlas = np.load(os.path.join(vm_dir, 'data', 'test_affine_1.npz'))\n# Print what is inside the atlas\nfor key, value in local_atlas.items():\n    print(key)\natlas_vol = local_atlas['fixed']\norigin_shape = atlas_vol.shape\nprint(atlas_vol.shape)","be847d95":"affine_atlats_testset = []\n\n# 1. translation\natlas_trans = np.ndarray(shape=(origin_shape ),dtype=float)\nmatrix = np.array([[1, 0, 0, 5],[0, 1, 0, 10],[0, 0, 1, 15],[0, 0, 0, 1]])\natlas_trans = scipy.ndimage.affine_transform(input=atlas_vol, matrix=matrix)\n# atlas_seg = atlas['seg']\n# Expand the dimension of the input: the first number is the number of the data, and the last one is the channel number\natlas_vol_p = np.reshape(atlas_vol, (1,)+atlas_vol.shape+(1,)) # 1x160x192x224x1\natlas_trans = np.reshape(atlas_trans, (1,)+atlas_trans.shape+(1,)) # 1x160x192x224x1\n\naffine_atlats_testset.append(atlas_trans)\n\n# 2. rotate\natlas_rot = np.ndarray(shape=(origin_shape),dtype=float)\natlas_rot = rotate(atlas_vol, 10, reshape=False)\n\n\n# atlas_seg = atlas['seg']\n# Expand the dimension of the input: the first number is the number of the data, and the last one is the channel number\natlas_rot = np.reshape(atlas_rot, (1,)+atlas_rot.shape+(1,)) # 1x160x192x224x1\nprint(atlas_rot.shape)\n\naffine_atlats_testset.append(atlas_rot)\n\n# 3. scale\natlas_sc = np.ndarray(shape=(origin_shape),dtype=float)\nmatrix = np.array([[1.1, 0, 0, 0],[0, 1.1, 0, 0],[0, 0, 1.1, 0],[0, 0, 0, 1]])\natlas_sc = scipy.ndimage.affine_transform(input=atlas_vol, matrix=matrix)\n\n\n# atlas_seg = atlas['seg']\n# Expand the dimension of the input: the first number is the number of the data, and the last one is the channel number\natlas_sc = np.reshape(atlas_sc, (1,)+atlas_sc.shape+(1,)) # 1x160x192x224x1\n\naffine_atlats_testset.append(atlas_sc)\n","9020a934":"with tf.device(gpu):\n    pred = []\n    for i in range(len(affine_atlats_testset)):\n        print(affine_atlats_testset[i].shape,  atlas_vol_p.shape)\n        pred.append(local_net.predict([affine_atlats_testset[i], atlas_vol_p]))","281561cc":"for i in range(len(affine_atlats_testset)):\n    compare_images(y_pred=pred[i][0], X_vol=affine_atlats_testset[i], atlas_vol=atlas_vol_p)\n    print_image(pred[i][0][0, :, :, :, 0])","1bc85c16":"atlas = np.load(vm_dir + 'data\/test_affine_1.npz')\n# output = np.ndarray(shape=(atlas.shape),dtype=float)\n\nfor k, v in atlas.items():\n    print(k)\natlas_seg = atlas['seg']\natlas_vol = atlas['fixed']\nprint(atlas_seg.shape)\nprint_image(atlas_vol)\natlas_vol = np.reshape(atlas_vol, (1,)+atlas_vol.shape+(1,)) # 1x160x192x224x1","6edeceab":"import glob\ntest_affine_names = glob.glob(\"..\/input\/oasis-affine-with-seg\/oasis_affine_with_seg\/affine_transform_with_skull\/*.npz\")\ntest_affine_movings = []\ntest_affine_segs = []\nfor i in range(len(test_affine_names)):\n    test_affine_movings.append(np.load(test_affine_names[i])['moving'][np.newaxis,...,np.newaxis])\n    seg = np.load(test_affine_names[i])['seg']\n    test_affine_segs.append(seg[np.newaxis,...,np.newaxis])\n    \n# test_affine_movings = np.concatenate(test_affine_movings, axis=0)\n# test_affine_fixeds = np.concatenate(test_affine_fixeds, axis=0)","114b3e3b":"fig1, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize = (20, 10))\nax1.imshow(np.max(test_affine_segs[0][0, :, :, :, 0], 0))\nax2.imshow(np.max(test_affine_segs[0][0, :, :, :, 0], 1))\nax3.imshow(np.max(test_affine_segs[0][0, :, :, :, 0], 2))","d1206257":"fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize = (20, 10))\nax1.imshow(np.max(atlas_seg[np.newaxis,...,np.newaxis][0, :, :, :, 0], 0))\nax2.imshow(np.max(atlas_seg[np.newaxis,...,np.newaxis][0, :, :, :, 0], 1))\nax3.imshow(np.max(atlas_seg[np.newaxis,...,np.newaxis][0, :, :, :, 0], 2))","9e3fdc57":"X_vol = np.load(vm_dir + 'data\/test_affine_vol.npz')['vol_data']\nX_vol = X_vol[np.newaxis, ... , np.newaxis]\nprint(X_vol.shape)","594462e8":"with tf.device(gpu):\n    pred = []\n    for i in range(len(test_affine_movings)):\n        p = local_net.predict([test_affine_movings[i], atlas_vol])\n        pred.append(p)\n#     print(test_vol.shape, atlas_vol.shape)\n    \n#     p = net.predict([output, atlas_vol])","56f03881":"for i in range(len(pred)):\n    compare_images(y_pred=pred[i][0], X_vol=test_affine_movings[i], atlas_vol=atlas_vol)\n    print_image(pred[i][0][0, :, :, :, 0])","aeb7ea4d":"depth, height, width =pred[i][0].shape[1:4]\nprint(pred[0][0].shape)\nprint(pred[0][0][0, depth\/\/2, :, 100,0])","d4c4df3e":"for i in range(len(pred)):\n    print_flow(vol_size=vol_size, flow=pred[i][1][0])","efa0b206":"for i in range(len(pred)):\n    diff_ = np.abs(atlas_vol-pred[i][0])\n    print_image(diff_[0,:,:,:,0])","512bcafd":"xx = np.arange(vol_size[1])\nyy = np.arange(vol_size[0])\nzz = np.arange(vol_size[2])\ngrid = np.rollaxis(np.array(np.meshgrid(xx, yy, zz)), 0, 4)","76a877e5":"# flows = []\n# for i in range(len(pred)):\n#     flow = pred[i][1][0, :, :, :, :]\n#     flows.append(flow)\n#     sample = flow + grid\n#     sample = np.stack((sample[:, :, :, 1], sample[:, :, :, 0], sample[:, :, :, 2]), 3)\n#     seg = test_affine_segs[i]\n#     vol = test_affine_movings[i]\n#     warp_seg = interpn((yy, xx, zz), seg[0, :, :, :, 0], sample, method='nearest', bounds_error=False, fill_value=0)\n#     fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize = (20, 10))\n#     ax1.imshow(np.max(warp_seg[np.newaxis,...,np.newaxis][0, :, :, :, 0], 0))\n#     ax2.imshow(np.max(warp_seg[np.newaxis,...,np.newaxis][0, :, :, :, 0], 1))\n#     ax3.imshow(np.max(warp_seg[np.newaxis,...,np.newaxis][0, :, :, :, 0], 2))\n#     warp_vol = interpn((yy, xx, zz), vol[0, :, :, :, 0], sample, method='nearest', bounds_error=False, fill_value=0)\n#     vals, _ = dice(warp_seg, atlas_seg, labels=labels, nargout=2)\n#     print('DICE Scores for various labels:', np.mean(vals), np.std(vals))\n","3f648993":"### 2. 3 Predict and Test local transformed atlas test data","4c16f471":"### 1. 4 Predict affine generate test on cvpr model","2bea7e08":"## 1. Test performance of affine of cvpr model\n>### 1. 1 Load cvpr atlas data","fa0b6c52":"### 1. 3 Load cvpr model and local trained model","a820ff11":"## 2. Test performance of affine of local  model\n>### 2. 1  Load cvpr atlas data","53e5cc98":"> ### 2. 2 Generate local transformed atlas test data\n1. translation\n2. rotation\n3. scale","376ec913":"> ### 1. 2 Generate cvpr transformed atlas test data\n1. translation\n2. rotation\n3. scale\n"}}