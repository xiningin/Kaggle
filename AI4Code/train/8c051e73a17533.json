{"cell_type":{"b96b3ae9":"code","b8c3a3c8":"code","864659dc":"code","a31591ce":"code","1bf28d90":"code","8ae402a5":"code","3fb26f99":"code","b85eb18b":"code","917acc42":"code","d7a3031a":"code","ff9a34d8":"code","c43f4020":"code","470cda85":"code","f6d44c51":"code","6e872bfa":"code","dbf27624":"code","3a2c3f39":"code","2319ce97":"code","c1ee7db9":"code","f23ed3ad":"code","4c6d18eb":"code","bd0def1a":"code","f217836c":"code","2422673d":"code","c5af2247":"code","7ef90113":"code","1e872bfb":"code","41e57daf":"code","e6c766b2":"code","b72ce1d8":"code","bab7c073":"code","c691e831":"code","77434d6a":"code","ffdebece":"code","e9bf7a6e":"markdown","bdb659d0":"markdown","fa1f819d":"markdown","c6766752":"markdown","28d2f1d2":"markdown","f9b75728":"markdown","1991ff7a":"markdown","1119b9b7":"markdown","712a5b44":"markdown","de9c841e":"markdown","26b5e912":"markdown","99aeec40":"markdown","a6338798":"markdown","42e13658":"markdown"},"source":{"b96b3ae9":"import pandas as pd\nimport numpy as np\nimport os\n\nimport cv2\nimport shutil\n\n#from tqdm import tqdm\n# tqdm doesn't work well in colab.\n# This is the solution:\n# https:\/\/stackoverflow.com\/questions\/41707229\/tqdm-printing-to-newline\nimport tqdm.notebook as tq\n#for i in tq.tqdm(...):\n\nimport matplotlib.pyplot as plt\n%matplotlib inline","b8c3a3c8":"os.listdir('..\/input\/cifar100\/')","864659dc":"def unpickle(file):\n    \n    import pickle\n    with open(file, 'rb') as fo:\n        dict = pickle.load(fo, encoding='bytes')\n        \n    return dict","a31591ce":"path = '..\/input\/cifar100\/train'\n\ntrain_dict = unpickle(path)\n\ntrain_dict.keys()","1bf28d90":"path = '..\/input\/cifar100\/meta'\n\nnames_dict = unpickle(path)\n\nnames_dict.keys()","8ae402a5":"fine_labels_list = train_dict[b'fine_labels']\ncoarse_labels_list = train_dict[b'coarse_labels']\n\nfine_label_names_list = names_dict[b'fine_label_names']\ncoarse_label_names_list = names_dict[b'coarse_label_names']\n\nprint(len(fine_labels_list))\nprint(len(coarse_labels_list))\nprint(len(fine_label_names_list))\nprint(len(coarse_label_names_list))","3fb26f99":"# Create the df_train dataframe\ndf_train = pd.DataFrame(fine_labels_list, columns=['fine_labels'])\n\n# Create new columns\ndf_train['coarse_labels'] = coarse_labels_list\ndf_train['image_num'] = df_train.index + 100000\n\n# Create the image_id column\ndef create_imageid(row):\n    \n    image_id = str(row['fine_labels']) + '_' + str(row['coarse_labels']) + '_' + str(row['image_num']) +'.jpg'\n    \n    return image_id\n\ndf_train['image_id'] = df_train.apply(create_imageid, axis=1)\n\n\n# Create the fine and coarse label names columns\n\ndef create_finelabelname(x):\n    \n    # this returns bytes: b'apple'\n    name = fine_label_names_list[x]\n    \n    # convert bytes to string: 'apple'\n    name = name.decode(\"utf-8\") \n    \n    return name\n\n\ndef create_coarselabelname(x):\n    \n    # this returns bytes: b'apple'\n    name = coarse_label_names_list[x]\n    \n    # convert bytes to string: 'apple'\n    name = name.decode(\"utf-8\") \n    \n    return name\n\n\ndf_train['fine_label_names'] = df_train['fine_labels'].apply(create_finelabelname)\n\ndf_train['coarse_label_names'] = df_train['coarse_labels'].apply(create_coarselabelname)\n\n\n# Remove unnecessary columns\ndf_train = df_train.drop('image_num', axis=1)\n\n# Reorder the columns\ncols = ['image_id', 'fine_label_names', 'fine_labels', 'coarse_label_names', 'coarse_labels']\ndf_train = df_train[cols]\n\ndf_train.head()","b85eb18b":"path = '..\/input\/cifar100\/test'\n\ntest_dict = unpickle(path)\n\ntest_dict.keys()","917acc42":"fine_labels_list = test_dict[b'fine_labels']\ncoarse_labels_list = test_dict[b'coarse_labels']\n\nfine_label_names_list = names_dict[b'fine_label_names']\ncoarse_label_names_list = names_dict[b'coarse_label_names']\n\nprint(len(fine_labels_list))\nprint(len(coarse_labels_list))\nprint(len(fine_label_names_list))\nprint(len(coarse_label_names_list))","d7a3031a":"# Create the df_test dataframe\ndf_test = pd.DataFrame(fine_labels_list, columns=['fine_labels'])\n\n# Create new columns\ndf_test['coarse_labels'] = coarse_labels_list\ndf_test['image_num'] = df_test.index + 200000\n\n# Create the image_id column\ndef create_imageid(row):\n    \n    image_id = str(row['fine_labels']) + '_' + str(row['coarse_labels']) + '_' + str(row['image_num']) +'.jpg'\n    \n    return image_id\n\ndf_test['image_id'] = df_test.apply(create_imageid, axis=1)\n\n\n# Create the fine and coarse label names columns\n\ndef create_finelabelname(x):\n    \n    # this returns bytes: b'apple'\n    name = fine_label_names_list[x]\n    \n    # convert bytes to string: 'apple'\n    name = name.decode(\"utf-8\") \n    \n    return name\n\n\ndef create_coarselabelname(x):\n    \n    # this returns bytes: b'apple'\n    name = coarse_label_names_list[x]\n    \n    # convert bytes to string: 'apple'\n    name = name.decode(\"utf-8\") \n    \n    return name\n\n\ndf_test['fine_label_names'] = df_test['fine_labels'].apply(create_finelabelname)\n\ndf_test['coarse_label_names'] = df_test['coarse_labels'].apply(create_coarselabelname)\n\n\n# Remove unnecessary columns\ndf_test = df_test.drop('image_num', axis=1)\n\n# Reorder the columns\ncols = ['image_id', 'fine_label_names', 'fine_labels', 'coarse_label_names', 'coarse_labels']\ndf_test = df_test[cols]\n\ndf_test.head()","ff9a34d8":"df_train.to_csv('train.csv', index=False)\ndf_test.to_csv('test.csv', index=False)","c43f4020":"!ls","470cda85":"path = '..\/input\/cifar100\/train'\n\ntrain_dict = unpickle(path)\n\ntrain_dict.keys()","f6d44c51":"train_dict[b'data'].shape","6e872bfa":"# Display the first image in the numpy array\n\n# Get the numpy array that contains all the images\nmatrix = train_dict[b'data']\n\n# Select the first row in the array\nrow = matrix[0]\n\n# Extract each channel\n\n# Using numpy slicing:\n# Select all indices from 0 to 1024 (excl. 1024)\nch0 = row[0:1024] \n# Select all indices from 1024 to 2048 (excl. 2048)\nch1 = row[1024:2048]\n# Select all indices from 2048 to the end\nch2 = row[2048:]\n\n# Reshape to 32x32\nch0 = np.reshape(ch0, (32,32)) # red\nch1 = np.reshape(ch1, (32,32)) # green\nch2 = np.reshape(ch2, (32,32)) # blue\n\n# Stack the matrices along the channel axis\nimage = np.dstack((ch0, ch1, ch2))\n\nplt.imshow(image)\nplt.show()","dbf27624":"matrix.shape","3a2c3f39":"# Create the directory\n\nif os.path.isdir('train_images') == False:\n\n    train_images = 'train_images'\n    os.mkdir(train_images)","2319ce97":"# Prepare train images\n\nfor i in tq.tqdm(range(0, matrix.shape[0]), total=matrix.shape[0]):\n    \n    # Get the image_id from the df_train dataframe\n    image_id = df_train.loc[i, 'image_id']\n\n\n    # Select an image\n    row = matrix[i]\n\n    # Extract each channel\n    ch0 = row[0:1024] \n    ch1 = row[1024:2048]\n    ch2 = row[2048:]\n\n    # Reshape to 32x32\n    ch0 = np.reshape(ch0, (32,32)) # red\n    ch1 = np.reshape(ch1, (32,32)) # green\n    ch2 = np.reshape(ch2, (32,32)) # blue\n\n    # Stack the matrices along the channel axis\n    image = np.dstack((ch0, ch1, ch2))\n\n    \n    # Save the image in the folder\n    # that we created.\n    fname = image_id\n    dst = os.path.join(train_images, fname)\n    \n    # If cv2.COLOR_RGB2BGR is not used then the saved images appear blue.\n    cv2.imwrite(dst, image)\n\n    \n# Compress the folders so they can appear\n# in the notebook output.\n# Source: https:\/\/www.kaggle.com\/xhlulu\/vinbigdata-process-and-resize-to-image\n\n!tar -zcf train_images.tar.gz -C \"train_images\/\" .","c1ee7db9":"print(len(os.listdir('train_images')))","f23ed3ad":"# Load an image\n\nimage_list = os.listdir('train_images')\n\npath = 'train_images\/' + image_list[4]\n\nimage = plt.imread(path)\n\nprint(path)\nprint(image.shape)\nprint(image.min())\nprint(image.max())\n\nplt.imshow(image)\n\nplt.show()","4c6d18eb":"path = '..\/input\/cifar100\/test'\n\ntest_dict = unpickle(path)\n\ntest_dict.keys()","bd0def1a":"test_dict[b'data'].shape","f217836c":"# Display the first image in the numpy array\n\n# Get the numpy array that contains all the images\nmatrix = test_dict[b'data']\n\n# Select the first row in the array\nrow = matrix[0]\n\n# Extract each channel\nch0 = row[0:1024] \nch1 = row[1024:2048]\nch2 = row[2048:]\n\n# Reshape to 32x32\nch0 = np.reshape(ch0, (32,32)) # red\nch1 = np.reshape(ch1, (32,32)) # green\nch2 = np.reshape(ch2, (32,32)) # blue\n\n# Stack the matrices along the channel axis\nimage = np.dstack((ch0, ch1, ch2))\n\nplt.imshow(image)\nplt.show()","2422673d":"matrix.shape","c5af2247":"# Create the directory\n\nif os.path.isdir('test_images') == False:\n\n    test_images = 'test_images'\n    os.mkdir(test_images)","7ef90113":"# Prepare test images\n\nfor i in tq.tqdm(range(0, matrix.shape[0]), total=matrix.shape[0]):\n    \n    # Get the image_id from the df_test dataframe\n    image_id = df_test.loc[i, 'image_id']\n\n\n    # Select an image\n    row = matrix[i]\n\n    # Extract each channel\n    ch0 = row[0:1024] \n    ch1 = row[1024:2048]\n    ch2 = row[2048:]\n\n    # Reshape to 32x32\n    ch0 = np.reshape(ch0, (32,32)) # red\n    ch1 = np.reshape(ch1, (32,32)) # green\n    ch2 = np.reshape(ch2, (32,32)) # blue\n\n    # Stack the matrices along the channel axis\n    image = np.dstack((ch0, ch1, ch2))\n\n    \n    # Save the image in the folder\n    # that we created.\n    fname = image_id\n    dst = os.path.join(test_images, fname)\n    cv2.imwrite(dst,image)\n\n    \n    \n# Compress the folders so they can appear\n# in the notebook output.\n# Source: https:\/\/www.kaggle.com\/xhlulu\/vinbigdata-process-and-resize-to-image\n\n!tar -zcf test_images.tar.gz -C \"test_images\/\" .","1e872bfb":"print(len(os.listdir('test_images')))","41e57daf":"# Load an image\n\nimage_list = os.listdir('test_images')\n\npath = 'test_images\/' + image_list[1]\n\nimage = plt.imread(path)\n\nprint(path)\nprint(image.shape)\nprint(image.min())\nprint(image.max())\n\nplt.imshow(image)\n\nplt.show()","e6c766b2":"# Delete the folders to prevent a Kaggle error.\n\nif os.path.isdir('train_images') == True:\n    shutil.rmtree('train_images')\n    \nif os.path.isdir('test_images') == True:\n    shutil.rmtree('test_images')","b72ce1d8":"!ls","bab7c073":"# In this example we will extract the images.\n\n# https:\/\/www.pythoneasy.com\/learn\/python-how-to-read-and-extract-targz-file-in-python-16\n\n\nimport tarfile\n\n# Create a folder to store the extracted files\nimages_dir = 'images_dir'\nos.mkdir(images_dir)\n\n\npath = 'train_images.tar.gz'\nfilename = path\n\ntf = tarfile.open(filename)\n\n# 'images_dir' is path to the folder \n# where the extracted files will be stored.\ntf.extractall('images_dir') ","c691e831":"# Check how many files are in the extracted directory.\n\nlen(os.listdir('images_dir'))","77434d6a":"# Delete the folder to prevent a Kaggle error.\n\nif os.path.isdir('images_dir') == True:\n    shutil.rmtree('images_dir')","ffdebece":"!ls","e9bf7a6e":"## Delete the folders to prevent a Kaggle error\n\nKaggle allows a max of 500 files to be saved. If these image folders are not deleted then the notebook commit will fail.","bdb659d0":"## Create train csv file","fa1f819d":"## Introduction\n\n\nI found the CIFAR-100 data storage format to be a bit confusing at first. This notebook may help others get up and running quickly.\n\nThis notebook shows:\n- How to load the data.\n- How to create train and test csv files.\n- How to convert the images to jpg format and save them in the notebook output as tar.gz files.\n- How to extract the saved tar.gz files.\n\n### Notes \n\n1. For an overview of the class structure of CIFAR-100 please refer to Appendix D (Page 54) of the following paper:<br>\nhttps:\/\/www.cs.toronto.edu\/~kriz\/learning-features-2009-TR.pdf\n\n2. Each csv file contains both labels and their meanings.\n\n3. I assigned my own numbers to each image --> 100000 series for the train set and 200000 series for the test set. I used the following image naming format:\n\n> 35_14_100092.jpg<br>\n> fine-label_course-label_image-number.jpg\n\n","c6766752":"## Convert the train images to jpg and store them in a folder","28d2f1d2":"## Helper functions","f9b75728":"## Create the test csv file","1991ff7a":"## Load the numpy array containing the test images","1119b9b7":"## Save the train and test csv files","712a5b44":"## Convert the train images to jpg and store them in a folder","de9c841e":"## Load the train data","26b5e912":"## Load the test data","99aeec40":"https:\/\/www.cs.toronto.edu\/~kriz\/cifar.html\n\ndata -- a 50000x3072 numpy array of uint8s. Each row of the array stores a 32x32 colour image. The first 1024 entries contain the red channel values, the next 1024 the green, and the final 1024 the blue. The image is stored in row-major order, so that the first 32 entries of the array are the red channel values of the first row of the image.","a6338798":"## Load the numpy array containing the train images","42e13658":"## Example: How to extract the tar files"}}