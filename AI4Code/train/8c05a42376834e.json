{"cell_type":{"e7d228aa":"code","76876aca":"code","00c224ad":"code","9d9b93c0":"code","933af1cf":"code","78031dbc":"code","dacb8d78":"code","1d604a51":"code","d6238f06":"code","ad1e61cc":"code","04573f65":"code","43b9cfc2":"code","99c91bff":"code","02434ad9":"code","48c6b0e5":"code","df20ebb3":"code","e6a05288":"code","386ff4ec":"code","f4214e3e":"code","acd21393":"code","2ae49e8c":"code","43034589":"code","8e6fa916":"code","598a9f22":"code","351ce9c5":"code","cc99a8f1":"code","3fa6189d":"code","21159460":"code","4f6c701a":"code","bc9ee8d5":"code","8a3b442b":"code","2b89626a":"code","b1766544":"code","fae87300":"code","519462d3":"code","60c5ed11":"code","ac96ec65":"code","e52d1b84":"code","7b66e302":"code","45ab5f6e":"code","3903c274":"code","c4e42489":"code","bd75ebc9":"code","fe985e02":"code","5046f787":"code","9ce4de9a":"code","dba71b6e":"code","64e8f18a":"markdown","13cf932d":"markdown","a46ff504":"markdown","a5800d7b":"markdown","51668085":"markdown","f30de445":"markdown","24582ac5":"markdown","54c2d706":"markdown","a83c06d1":"markdown","ed3cc6c8":"markdown","7c8442c7":"markdown","c61a98c1":"markdown","75d6be65":"markdown","661e4008":"markdown","81e8f404":"markdown","c7c7fe34":"markdown"},"source":{"e7d228aa":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)","76876aca":"import sympy as sym\nfrom sympy.stats import P,  variance, Die, Normal, density, cdf # E,\nfrom sympy import Eq, simplify, Symbol","00c224ad":"x = ['x'+str(i) for i in range(3)]\nsum(Symbol(s) for s in x)","9d9b93c0":"xicmuj, xi, \u03bcj, \u03c3j, i, j, n, K = sym.symbols('x_{i}|\u03bc_j x_i  \u03bc_j  \u03c3_j i j n K')\nxicci, xiccimu, \u03bc, \u03c3, ci, cij, c = sym.symbols('x_{i}|c_{i} x_{i}|c_{i}\u03bc \u03bc \u03c3 c_i c_{ij} c')\nm, s, mj, sj = sym.symbols('m s m_j s_j') \n# Global: x|c,\u03bc \nxccmu = sym.symbols('x|c,\u03bc')\n# Functions\npi, p, pixiccimu = sym.symbols('p_i p p_{i}c_i', cls=sym.Function)\nqi, q = sym.symbols('q_i q', cls=sym.Function)","933af1cf":"xtest = ['x'+str(i) for i in range(3)]\nsum(Symbol(s) for s in xtest)","78031dbc":"# Density of a Normal\nNtest = Normal('Ntest', \u03bcj, \u03c3j)\npitest = lambda z: density(Ntest)(z)","dacb8d78":"piProd=pitest(Symbol(xtest[0]))\nfor i in range(1,3):\n    piProd*=pitest(Symbol(xtest[i])) #*pi(symbol[x[1]])*pi(symbol[x[2]])\npiProd","1d604a51":"pitest(xi)","d6238f06":"i = sym.symbols('i') # Something happen with the i when used by the for loop above.\n#sym.Sum(p(xicmu),(i,0,5))\n## i.i.d\np=sym.Product(pi(xi),(i,0,3)) #.doit()\np","ad1e61cc":"log_p=sym.log(p)\nlog_p","04573f65":"sym.expand_log(log_p, force=True) #.doit()","43b9cfc2":"# To use the symbol p and x again..\np = sym.symbols('p', cls=sym.Function)\nx = sym.symbols('x')\n\n# K is the number of Clusters\n# n is the number of data points.\n\n## Presenting the Joint Probability - \npxc\u03bc_SP1 = p(\u03bc)*p(c)*p(xccmu)\nlog_pxc\u03bc_SP1 = sym.log(pxc\u03bc_SP1)\n##\np\u03bc_SP = sym.Product(p(\u03bcj),(j,1,K))\npc_SP = sym.Product(p(ci),(i,1,n))\npxccmu_SP = sym.Product(p(xiccimu),(i,1,n))\n# compose\npxc\u03bc_SP = p\u03bc_SP*pc_SP*pxccmu_SP\n# The very common taking of Log \nlog_pxc\u03bc_SP = sym.log(pxc\u03bc_SP)\n# The common logarithm expansion \nlog_pxc\u03bc_SPx1 = sym.expand_log(log_pxc\u03bc_SP1, force=True)\nlog_pxc\u03bc_SPx = sym.expand_log(log_pxc\u03bc_SP, force=True)\n\n# We want to find this Joint Probability p(x,z) \n# -> to compute the E[log(p[x,z])], -> to compute the ELBO.\ndisplay(Eq(sym.log(p(x,c,\u03bc)),log_pxc\u03bc_SPx1))\ndisplay(Eq(sym.log(p(x,c,\u03bc)),log_pxc\u03bc_SPx))","99c91bff":"# Let's start by the first, args[0] - p(c)\ndisplay(log_pxc\u03bc_SPx.args[0])\n\n## Easy - K clusters\npci_SP = 1\/K\npc_SP = sym.Product(pci_SP,(j,1,K)) #.doit()\nlog_pc_SP = sym.log(pc_SP)\nlog_pc_SPx = sym.expand_log(log_pc_SP, force=True)\ndisplay(Eq(log_pxc\u03bc_SPx.args[0], log_pc_SPx))\n## Substitution\ndisplay(log_pxc\u03bc_SPx.subs(p(ci),pci_SP))","02434ad9":"# Let's continue with the second, args[2] - p(mu)\ndisplay(log_pxc\u03bc_SPx.args[2])\n\n# Density of a Normal(mu,\u03c3)\nN\u03bcj = Normal('N\u03bcj', \u03bcj, \u03c3)\np\u03bcj = lambda z: density(N\u03bcj)(z)\np\u03bcj_SP = p\u03bcj(0)\ndisplay(Eq(p(\u03bcj),p\u03bcj_SP))\n# Log to see\nlog_p\u03bcj_SP=sym.log(p\u03bcj_SP)\nlog_p\u03bcj_SPx=sym.expand_log(log_p\u03bcj_SP, force=True)\ndisplay(Eq(sym.log(p(\u03bcj)), log_p\u03bcj_SPx))\n\n## Not so Easy, but doable \np\u03bc_SP = sym.Product(p\u03bcj_SP,(j,1,K)) # asuming i.i.d\nlog_p\u03bc_SP = sym.log(p\u03bc_SP)\nlog_p\u03bc_SPx = sym.expand_log(log_p\u03bc_SP, force=True)\ndisplay(Eq(log_pxc\u03bc_SPx.args[2], log_p\u03bc_SP))\ndisplay(Eq(log_pxc\u03bc_SPx.args[2], log_p\u03bc_SPx))\n##\n## Substitution\n##\n# 1. p(c)\nlog_pxc\u03bc_SPx_sub1=log_pxc\u03bc_SPx.subs(sym.log(p(ci)), log_pc_SPx)\n# 2. p(\u03bc)\nlog_pxc\u03bc_SPx_sub2=log_pxc\u03bc_SPx_sub1.subs(sym.log(p(\u03bcj)), log_p\u03bcj_SPx)\n# printing\ndisplay(log_pxc\u03bc_SPx_sub2)","48c6b0e5":"# Let's cover the last term of our log p(x,z), args[1] - p(xi|ci,\u03bc)\ndisplay(log_pxc\u03bc_SPx.args[1])","df20ebb3":"# Here cij is a one-hot vector, using the Trick to exponent cij.. \npixiccimuj_SP=sym.Product(p(xicmuj),(i,1,cij)).doit()\ndisplay(pixiccimuj_SP)","e6a05288":"xiccimu","386ff4ec":"# It is important that is over j.\n# We Assume i.i.d (products of probabilities).\npxiccimu_SP=sym.Product(pixiccimuj_SP,(j,1,K)) #.doit()\ndisplay(Eq(p(xiccimu),pxiccimu_SP))","f4214e3e":"log_pxiccimu_SP = sym.log(pxiccimu_SP)\nlog_pxiccimu_SP","acd21393":"## Expand (with force=True) resolve the issue of \n## transforming the Product symbol into a Summation symbol.\nlog_pxiccimu_SPx = sym.expand_log(log_pxiccimu_SP, force=True)\ndisplay(Eq(sym.log(p(xiccimu)),log_pxiccimu_SPx))","2ae49e8c":"## Transforming functions into variables for the future \npixicmuj_SPv=pi(xicmuj)\n## Taking Logarithm\nlog_pixicmuj_SPv=sym.log(pixicmuj_SPv)\n## Printing both\ndisplay(pixicmuj_SPv, log_pixicmuj_SPv)","43034589":"# In this moment assume xi ~ Normal (Density of a Normal)\nN = Normal('N', \u03bcj, 1) # According to xi ~ N(\u03bcj,1), but it will change to \u03c3j in the future.\npi = lambda z: density(N)(z)","8e6fa916":"## Because we are in the definition of xi\npixicmuj_SP=pi(xi)\n## Taking Logarithm\nlog_pixicmuj_SP=sym.log(pixicmuj_SP)\n## Finally expanding\nlog_pixicmuj_SPx=sym.expand_log(log_pixicmuj_SP, force=True)\n## Printing both\ndisplay(Eq(pixicmuj_SPv,pixicmuj_SP), Eq(log_pixicmuj_SPv,log_pixicmuj_SP), Eq(log_pixicmuj_SPv,log_pixicmuj_SPx))","598a9f22":"sym.latex(log_pxiccimu_SPx)","351ce9c5":"Margin_over_mu=log_pxiccimu_SPx.subs(sym.log(p(xicmuj)),log_pixicmuj_SPx)\nMargin_over_mu","cc99a8f1":"log_pxcmu_Joint_SP=sym.Sum(Margin_over_mu,(i,1,n))\nlog_pxcmu_Joint_SP","3fa6189d":"## Substitution - and finally having p(x,z)\n# 1. p(c)\nlog_pxc\u03bc_SPx_sub1=log_pxc\u03bc_SPx.subs(sym.log(p(ci)), log_pc_SPx)\n# 2. p(\u03bc)\nlog_pxc\u03bc_SPx_sub2=log_pxc\u03bc_SPx_sub1.subs(sym.log(p(\u03bcj)), log_p\u03bcj_SPx)\n# 3. p(x|\u03bc)\nlog_pxc\u03bc_SPx_sub3=log_pxc\u03bc_SPx_sub2.subs(log_pxc\u03bc_SPx.args[1], log_pxcmu_Joint_SP)\n# printing\ndisplay(Eq(sym.log(p(x,c,\u03bc)),log_pxc\u03bc_SPx_sub3))","21159460":"mums = sym.symbols('\u03bc;m,s^2')\nmujmjsj = sym.symbols('\u03bc_{j};m_{j},s^2_j')\nc\ud835\udf19 = sym.symbols('c;\ud835\udf19')\nci\ud835\udf19i = sym.symbols('c_{i};\ud835\udf19_i')\n#\nciEqj\ud835\udf19i, \ud835\udf19ij = sym.symbols('c_{i}=j;\ud835\udf19_{i} \ud835\udf19_{ij}')\ndisplay(mujmjsj)","4f6c701a":"q(mums).args[0]","bc9ee8d5":"# q(mu)\nqimuj = q(mujmjsj)\nqmu = sym.Product(qimuj,(j,1,K))\nlog_qmu_SP = sym.log(qmu)\nlog_qmu_SPx = sym.expand_log(log_qmu_SP, force=True)\ndisplay(Eq(q(mums),qmu), log_qmu_SPx)","8a3b442b":"# q(c)\nqici = q(ci\ud835\udf19i)\nqc = sym.Product(qici,(i,1,n))\nlog_qc_SP = sym.log(qc)\nlog_qc_SPx = sym.expand_log(log_qc_SP, force=True)\ndisplay(Eq(q(c\ud835\udf19),qc), log_qc_SPx)","2b89626a":"# The probability q of the latent variables can be factorized:\n# [ Mean Field approximation ]\nq\u03bcc = qmu * qc\ndisplay(Eq(q(\u03bc,c),q(c)*q(\u03bc)))\ndisplay(Eq(q(\u03bc,c),q(c\ud835\udf19)*q(mums)))\ndisplay(Eq(q(\u03bc,c),q\u03bcc))","b1766544":"# In this moment assume \u03bcj ~ Normal (Density of a Normal)\nNmjsj = Normal('Nmjsj', mj, sj) #\npimjsj = lambda z: density(Nmjsj)(z)\n# Where q(\u03bc)\npi_mujmjsj_SP = pimjsj(\u03bcj)\n# And q(c) \npi_c\ud835\udf19_SP = p(ciEqj\ud835\udf19i)\npi_c\ud835\udf19_SPx = \ud835\udf19ij\np_c\ud835\udf19_SP = sym.Product(pi_c\ud835\udf19_SPx,(j,1,K))\nlog_p_c\ud835\udf19_SP = sym.log(p_c\ud835\udf19_SP)\nlog_p_c\ud835\udf19_SPx = sym.expand_log(log_p_c\ud835\udf19_SP, force=True)\n\n# Printing ...\ndisplay(Eq(qimuj,pi_mujmjsj_SP),pi_c\ud835\udf19_SP,Eq(p(ciEqj\ud835\udf19i),pi_c\ud835\udf19_SPx))\ndisplay(Eq(sym.log(p(ci\ud835\udf19i)),log_p_c\ud835\udf19_SPx))","fae87300":"log_q\u03bcc_SP = sym.log(q\u03bcc)\nlog_q\u03bcc_SPx = sym.expand_log(log_q\u03bcc_SP, force=True)\ndisplay(Eq(sym.log(q(\u03bc,c)),sym.log(q(c)*q(\u03bc))))\ndisplay(Eq(sym.log(q(\u03bc,c)),log_q\u03bcc_SP))\ndisplay(Eq(sym.log(q(\u03bc,c)),log_q\u03bcc_SPx))\n\n## Let's continue, we have it all..\nlog_q\u03bcc_SP1=log_q\u03bcc_SPx.subs(q(mujmjsj),pi_mujmjsj_SP)\nlog_q\u03bcc_SP1x = sym.expand_log(log_q\u03bcc_SP1, force=True)\ndisplay(log_q\u03bcc_SP1x)\n# q(c)\nlog_q\u03bcc_SP2=log_q\u03bcc_SPx.subs(q(ci\ud835\udf19i),pi_c\ud835\udf19_SP)\ndisplay(log_q\u03bcc_SP2)\n\n# Final substitutions - In Steps ...\nlog_q\u03bcc_SPx_Subs1 = log_q\u03bcc_SPx.subs(q(mujmjsj),pi_mujmjsj_SP)\nlog_q\u03bcc_SPx_Subs1x = sym.expand_log(log_q\u03bcc_SPx_Subs1, force=True) \nlog_q\u03bcc_SPx_Subs2 = log_q\u03bcc_SPx_Subs1x.subs(sym.log(q(ci\ud835\udf19i)),log_p_c\ud835\udf19_SPx)\n# We have log(q[z]) .. So \ndisplay(Eq(sym.log(q(\u03bc,c)),log_q\u03bcc_SPx_Subs2))","519462d3":"H, Hno, E , Eno= sym.symbols('H H_{no} \\mathbb{E}_q \\mathbb{E}_q^{no}', cls=sym.Function)","60c5ed11":"sym.Sum(E(log_q\u03bcc_SPx_Subs2.expand().args[0].args[0]),log_q\u03bcc_SPx_Subs2.expand().args[0].args[1])","ac96ec65":"log_q\u03bcc_SPx_Subs2.expand().args[6].args[2]","e52d1b84":"# The Entropy H(q): \nEntro_SP1=sym.Add(*[sym.Sum(E(term.args[0]),term.args[1]) for term in log_q\u03bcc_SPx_Subs2.expand().args if len(term.args)<3])\nEntro_SP2=sym.Add(*[sym.Sum(E(term.args[0]),term.args[1],term.args[2]) for term in log_q\u03bcc_SPx_Subs2.expand().args if len(term.args)>2])\nEntro_SP = Entro_SP1 + Entro_SP2\nEntro_SP_noEx=log_q\u03bcc_SPx_Subs2\n\n## Printing\ndisplay(Eq(H(q(\u03bc,c)),Entro_SP))\ndisplay(Eq(Hno(q(\u03bc,c)),Entro_SP_noEx))","7b66e302":"[E(term) for term in log_pxc\u03bc_SPx_sub3.expand().args]","45ab5f6e":"# \\mathbb{E}_q[log(p[x,z])]\nL_error1 = sym.Add(*[sym.Sum(E(term.args[0]),term.args[1]) for term in log_pxc\u03bc_SPx_sub3.expand().args if len(term.args)<3])\nL_error2 = sym.Add(*[sym.Sum(E(term.args[0]),term.args[1],term.args[2]) for term in log_pxc\u03bc_SPx_sub3.expand().args if len(term.args)>2])\nL_error = (L_error1+L_error2)\nL_error_noEx = log_pxc\u03bc_SPx_sub3\n#\ndisplay(Eq(E(-sym.log(p(x,\u03bc,c))), L_error))\ndisplay(Eq(Eno(-sym.log(p(x,\u03bc,c))), L_error_noEx))","3903c274":"ELBO, ELBOno =sym.symbols('ELBO ELBO_{no}')","c4e42489":"ELBO_final = (L_error - Entro_SP)\nELBO_final_noEx = sym.collect((L_error_noEx - Entro_SP_noEx),cij).subs(cij,\ud835\udf19ij)\ndisplay(Eq(ELBO,ELBO_final))\ndisplay(Eq(ELBOno,ELBO_final_noEx))","bd75ebc9":"## Without the sum\nELBO_final_noEx.args[1].args[1].args[0]","fe985e02":"## Without the sum and the constants - I take advantage and take E() here...\nNoctte\ud835\udf19ij=ELBO_final_noEx.args[4].args[0].args[0] * E(ELBO_final_noEx.args[4].args[0].args[1].args[0])\nNoctte\ud835\udf19ij","5046f787":"ExpLog\ud835\udf19ij = (-1)*sym.integrate(ELBO_final_noEx.args[1].args[1].args[0])\n##\ndisplay(ExpLog\ud835\udf19ij, sym.diff(ExpLog\ud835\udf19ij, \ud835\udf19ij) )","9ce4de9a":"# The operation with the d\/d\ud835\udf19ij of E\nELBO_final_noEx_But_E\ud835\udf19ij1= ELBO_final_noEx.subs(ELBO_final_noEx.args[1], ExpLog\ud835\udf19ij.args[1]) \n# No Sum signs\nELBO_final_noEx_But_E\ud835\udf19ij = ELBO_final_noEx_But_E\ud835\udf19ij1.subs(ELBO_final_noEx.args[4],Noctte\ud835\udf19ij)\nELBO_final_noEx_But_E\ud835\udf19ij","dba71b6e":"Eq(ELBO_final_noEx_But_E\ud835\udf19ij.diff(\ud835\udf19ij),0)","64e8f18a":"# We have to remember the derivative of an antiderivative (integral) which is the expectation value.","13cf932d":"# Now let's see p(x|mu) ","a46ff504":"# A little warming up here:","a5800d7b":"# Derivatives","51668085":"# Let's starting here. We want to compute is the joint probability of data (xi), produced from latent variables c and \u03bc, and classify them in K clusters. So this is a problem of classification!\n\n# $p(x,z) = p(x,c,\\mu)~~~~  ==>~~~~ log~p(x,z) =  log~p(x,c,\\mu)$","f30de445":"# Variables and symbols","24582ac5":"# This is Variational Inference on GMM (Gaussian Mixture Model):\n\nCentro de las Gaussianas (K gaussianas)    $\\mu_j \\sim \\mathcal{N}(0,\\sigma^2)$   $for~~j=1,...,K$\n\nSe combinan con esta distribuci\u00f3n uniforme     $c_i \\sim \\mathcal{U}(K)$  $for~~i=1,...,N$\n\nY los datos xi terminan saliendo de aqui    $x_i \\sim \\mathcal{N}(c^T _i \\mu_j,1)$  $for~~i=1,...,N$","54c2d706":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:110%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n\n### $ELBO = \\mathbb{E}_q[log(p[x,z])] - \\mathbb{E}_q[log(q[z])]$\n\n<\/div>","a83c06d1":"## After all this work the entropy H(q) is:\n\n## $H(q)= \\mathbb{E}[log~(q[z])] = \\mathbb{E}[log~(q[c,\\mu])]$\n## $This~ is~ why~ we~ needed~~ log~(q[c,\\mu])!$","ed3cc6c8":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n# Variational Inference (VI) \ud83d\udccc\n    \n<\/div>    ","7c8442c7":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\"> \n    \n# Let's work the third term of \n$\\log~p(x,c,\u03bc) $\n    \n<\/div>","c61a98c1":"# Great! we now can compute q(z) = q(\u03bc,c). \n# We will assume mean field: q(\u03bc,c) = q(\u03bc)q(c) ","75d6be65":"# I wanted to have a place where to organize these notes. Feel free to comment, so I can improve it. I will build derivatives in the near future.","661e4008":"## Now the entropy is:\n\n## $H(q)= \\mathbb{E}[log~(q[z])] = \\mathbb{E}[log~(q[c,\\mu])]$ (remember z => c, $\\mu$) \n## This is why we need log(q) and of course $q(c,\\mu)$, lets's write it down:","81e8f404":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:110%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n\n# Let's see the entropy of varitional distributions:\nIn a problem like this (Classification), usually we need an \"Objective Function\" to run \"The Optimization Problem\", because we are looking for some parameters to optimize and classify our objects.\n    \nIn Variational methodologies this \"Objective Function\" to optimize is called ELBO:\n    \n# $ ELBO = \\mathcal{L}^E + \\mathcal{L}^C = \\mathcal{L}^E + KL(q||p) $\n\n## The difference KL is:\n\n# $KL= \\mathbb{E}[-log(p[w])] - H(q)$\n\n## the last term is the entropy! let's look at it!!..\n\n<\/div>","c7c7fe34":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\"> \n    \n# Combining with \n$\\sum_{j=1}^{K} c_{ij} \\log{\\left[p{\\left(x_{i}|\u03bc_j \\right)} \\right]}$\n    \n<\/div>"}}