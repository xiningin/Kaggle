{"cell_type":{"00d96a3a":"code","bf1bc099":"code","84dad208":"code","4640a139":"code","93b80a9f":"code","b3de488b":"code","91ac1093":"code","6ec5ef76":"code","d76b2bf6":"code","dfacdd2b":"code","2c0365b2":"code","388033dc":"code","f39e5e8e":"code","e30da094":"code","0a7a4c0a":"code","6c252312":"code","afd29a66":"code","958a2bf1":"code","4d9654c1":"code","2db10601":"code","1dc552f3":"code","c931e4e6":"code","da2093b1":"code","d7d6dad7":"code","85dec00d":"code","3a88bd97":"code","74632ee0":"code","bff9c184":"code","8c788b7d":"code","054b84ff":"code","32da5642":"code","95e72daa":"code","fa67d248":"code","1780749a":"code","331ebe8b":"code","df6dcc19":"code","c8c9ad31":"code","e294aff4":"code","540727e7":"code","e6f8ac28":"code","f4232358":"code","920ce79b":"code","71ec9654":"code","81d0b445":"code","71b78d01":"code","dc56aafd":"code","558b8a76":"code","d6d3305c":"code","b92429b7":"code","57212be1":"code","ed594f33":"code","eb35381c":"code","c0278b4b":"code","990d48ee":"code","ace76386":"code","99d15d01":"markdown","6c122bfb":"markdown","0928d692":"markdown","9f55d9ed":"markdown","8c8d04c1":"markdown","d1131a20":"markdown","04a9c31a":"markdown","d50a39a3":"markdown"},"source":{"00d96a3a":"import pandas as pd\nimport seaborn as sns\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import train_test_split","bf1bc099":"import warnings\nwarnings.filterwarnings('ignore')","84dad208":"train=pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/train.csv')\ntest=pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/test.csv')","4640a139":"# Function to reduce memory\n\ndef reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.\n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                #if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                #    df[col] = df[col].astype(np.float16)\n                #el\n                if c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        else:\n            df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage of dataframe is {:.2f} MB --> {:.2f} MB (Decreased by {:.1f}%)'.format(\n        start_mem, end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","93b80a9f":"# Reducing memory usage\n\ntrain = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)","b3de488b":"train.columns","91ac1093":"train.corr()","6ec5ef76":"train.describe()","d76b2bf6":"#To replace the null values \ntrain.fillna(train.mean(),inplace=True)","dfacdd2b":"for i in train.columns:\n    x = train[i].value_counts()\n    print(\"Column name is:\",i,\"and it value is:\",x)\n#Here we can see that it has no null values, but has only 0's. Hence, this is of no use to us.","2c0365b2":"train.drop(['Soil_Type7','Soil_Type15'],axis=1,inplace=True)\n","388033dc":"#sns barplots plot the means\nf,ax=plt.subplots(5,2,figsize=(25,15))\nsns.barplot(x=train.Cover_Type,y='Elevation',data=train,ci=None,ax=ax[0,0])\n\nsns.barplot(x=train.Cover_Type,y='Aspect',data=train,ci=None,ax=ax[0,1])\n\nsns.barplot(x=train.Cover_Type,y='Slope',data=train,ci=None,ax=ax[1,0])\n\nsns.barplot(x=train.Cover_Type,y='Horizontal_Distance_To_Hydrology',data=train,ci=None,ax=ax[1,1])\nsns.barplot(x=train.Cover_Type,y='Vertical_Distance_To_Hydrology',data=train,ci=None,ax=ax[2,0])\nsns.barplot(x=train.Cover_Type,y='Horizontal_Distance_To_Roadways',data=train,ci=None,ax=ax[2,1])\n\nsns.barplot(x=train.Cover_Type,y='Hillshade_9am',data=train,ci=None,ax=ax[3,0])\n\nsns.barplot(x=train.Cover_Type,y='Hillshade_Noon',data=train,ci=None,ax=ax[3,1])\n\nsns.barplot(x=train.Cover_Type,y='Hillshade_3pm',data=train,ci=None,ax=ax[4,0])\nsns.barplot(x=train.Cover_Type,y='Horizontal_Distance_To_Fire_Points',data=train,ci=None,ax=ax[4,1])","f39e5e8e":"#extracting the columns with Wilderness_Area data in them\nWild_cols=[col for col in train.columns if 'Wilderness_Area' in col]\nWild_cols","e30da094":"#Wilderness Area columns are stored in another dataset\nWild_data=train[Wild_cols]","0a7a4c0a":"Wild_data=test[Wild_cols]","6c252312":"train['Wilderness_Area']=Wild_data.apply(lambda x:x.idxmax(),axis=1)","afd29a66":"test['Wilderness_Area']=Wild_data.apply(lambda x:x.idxmax(),axis=1)","958a2bf1":"train.drop(['Wilderness_Area1','Wilderness_Area2','Wilderness_Area3','Wilderness_Area4'],axis=1,inplace=True)","4d9654c1":"test.drop(['Wilderness_Area1','Wilderness_Area2','Wilderness_Area3','Wilderness_Area4'],axis=1,inplace=True)","2db10601":"train.Wilderness_Area.value_counts()","1dc552f3":"test.Wilderness_Area.value_counts()","c931e4e6":"soil_col=[col for col in train.columns if 'Soil_Type' in col]\nsoil_data=train[soil_col]","da2093b1":"train['Soil_data']=soil_data.apply(lambda x: x.idxmax(), axis=1)","d7d6dad7":"test['Soil_data']=soil_data.apply(lambda x: x.idxmax(), axis=1)","85dec00d":"train.drop(['Soil_Type1','Soil_Type2','Soil_Type3','Soil_Type4','Soil_Type5','Soil_Type6','Soil_Type8','Soil_Type9','Soil_Type10','Soil_Type11','Soil_Type12','Soil_Type13','Soil_Type14','Soil_Type16','Soil_Type17','Soil_Type18','Soil_Type19','Soil_Type20','Soil_Type21','Soil_Type22','Soil_Type23','Soil_Type24','Soil_Type25','Soil_Type26','Soil_Type27','Soil_Type28','Soil_Type29','Soil_Type30','Soil_Type31','Soil_Type32','Soil_Type33','Soil_Type34','Soil_Type35','Soil_Type36','Soil_Type37','Soil_Type38','Soil_Type39','Soil_Type40'],axis=1,inplace=True)","3a88bd97":"test.drop(['Soil_Type1','Soil_Type2','Soil_Type3','Soil_Type4','Soil_Type5','Soil_Type6','Soil_Type7','Soil_Type8','Soil_Type9','Soil_Type10','Soil_Type11','Soil_Type12','Soil_Type13','Soil_Type14','Soil_Type15','Soil_Type16','Soil_Type17','Soil_Type18','Soil_Type19','Soil_Type20','Soil_Type21','Soil_Type22','Soil_Type23','Soil_Type24','Soil_Type25','Soil_Type26','Soil_Type27','Soil_Type28','Soil_Type29','Soil_Type30','Soil_Type31','Soil_Type32','Soil_Type33','Soil_Type34','Soil_Type35','Soil_Type36','Soil_Type37','Soil_Type38','Soil_Type39','Soil_Type40'],axis=1,inplace=True)","74632ee0":"train.Soil_data.value_counts()","bff9c184":"train.head()","8c788b7d":"train=pd.get_dummies(train)","054b84ff":"test=pd.get_dummies(test)","32da5642":"\n\nX=train.drop(['Id','Cover_Type'],axis=1)\ny=train.Cover_Type\nX_train, X_test, y_train, y_test = train_test_split(\n             X, y, test_size = 0.4, random_state=42)\n \n\n","95e72daa":"#KNN Classification\nknn = KNeighborsClassifier(n_neighbors=7,metric='euclidean')\n \nknn.fit(X_train, y_train)","fa67d248":"y_pred_knn = knn.predict(X_test)","1780749a":"y_pred_knn=pd.DataFrame(y_pred_knn)\ny_pred_knn.value_counts()","331ebe8b":"knn.score(X_test, y_test)","df6dcc19":"from sklearn.metrics import confusion_matrix\nconfusion_matrix(y_test, y_pred_knn)","c8c9ad31":"# make predictions using Decision Tree for classification\n\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn import metrics","e294aff4":"# define the model\nmodel = DecisionTreeClassifier()\n","540727e7":"# fit the model on the whole dataset\nmodel.fit(X_train, y_train)","e6f8ac28":"y_pred = model.predict(X_test)\n","f4232358":"print(\"Accuracy:\",metrics.accuracy_score(y_test, y_pred))","920ce79b":"import xgboost as xgb\n\ndtrain = xgb.DMatrix(data=X_train, label=y_train)\n","71ec9654":"params = {\n    'max_depth': 3,\n    'objective': 'multi:softmax',  # error evaluation for multiclass training\n    'num_class': 8,\n    'n_gpus': 0\n}","81d0b445":"bst = xgb.train(params, dtrain)","71b78d01":"dtest = xgb.DMatrix(data=X_test)","dc56aafd":" pred = bst.predict(dtest)","558b8a76":"from sklearn.metrics import classification_report\n\nprint(classification_report(y_test, pred))","d6d3305c":"confusion_matrix(y_test, pred)","b92429b7":"from sklearn.ensemble import RandomForestClassifier #Random Forest\n# Random Forest\nmodel4=RandomForestClassifier(n_estimators=100)\nmodel4.fit(X_train,y_train.values.ravel())\nRF_prediction=model4.predict(X_test)\nprint('The accuracy of the Random Forests model is \\t\\t',metrics.accuracy_score(RF_prediction,y_test))","57212be1":"test.drop(['id'],axis=1,inplace=True)\npred_final=model4.predict(test)","ed594f33":"y_pred_new=pd.DataFrame(pred_final)\ny_pred_new.index=test.Id","eb35381c":"y_pred_new.rename({0:'Cover_Type'},axis=1,inplace=True)","c0278b4b":"y_pred_new['Cover_Type']=y_pred_new['Cover_Type'].astype(int)","990d48ee":"y_pred_new.to_csv('submission.csv')","ace76386":"from sklearn.naive_bayes import GaussianNB #Naive bayes\nfrom sklearn import metrics\n# Naive Bayes\nmodel2=GaussianNB()\nmodel2.fit(X_train,y_train)\nNB_prediction=model2.predict(X_test)\nprint('The accuracy of the NaiveBayes model is\\t\\t\\t',metrics.accuracy_score(NB_prediction,y_test))","99d15d01":"# KNN","6c122bfb":"Accuracy is much more in case of Decision Tree Classifier than KNN. Hence, we will use the Decision Tree Model.","0928d692":"We will create categorical columns for Wilderness Area and Soil Type so that these can be used for analysis.","9f55d9ed":"We can understand that Random Forest Classifier performs the best among all these models.","8c8d04c1":"# Random Forest","d1131a20":"# DECISION TREE CLASSIFICATION","04a9c31a":"Therefore, Soil_Type 7 and 15 can be removed because they only contain 0's.\n","d50a39a3":"# Naive Bayes"}}