{"cell_type":{"7ee13692":"code","06716278":"code","5d0b9b51":"code","a6e4e9bc":"code","e19b09f6":"code","79d752fd":"code","a3aa3218":"code","49479b8c":"code","e656b11f":"code","042e2d54":"code","ce5dd728":"code","a230d773":"code","e4b428fd":"code","2161070b":"code","fe0f5e92":"code","161ff7bd":"code","a0ed36b1":"code","60065712":"code","1c5d3c83":"code","f4dd65b0":"code","c86446ff":"code","cd157b8c":"markdown","32731945":"markdown","e8c6f437":"markdown","c0b99d73":"markdown","ed27ff30":"markdown","f5a94a8e":"markdown","99750f03":"markdown","de814270":"markdown","3358b8fc":"markdown","07bdc96f":"markdown","d25906bc":"markdown"},"source":{"7ee13692":"!pip install pytorch-lightning","06716278":"import numpy as np \nimport pandas as pd \n\nimport os\nimport gc \nimport sys\n\nfrom IPython.core.display import display\nfrom ipywidgets import IntSlider, interact\nfrom matplotlib import pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nimport torch\nfrom torch.nn import functional as F\nfrom torch.utils.data import DataLoader\nfrom torch.utils.data import Dataset\nfrom torchvision import transforms, models\nfrom torch.optim.lr_scheduler import ReduceLROnPlateau\nfrom torch.optim import Adam\n\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.logging import WandbLogger\nfrom pytorch_lightning.core import LightningModule\n\n\n# notebook params\n_ = plt.rcParams['figure.figsize'] = [15, 2]\nnp.random.seed(400)","5d0b9b51":"package_path = '..\/input\/efficientnet\/efficientnet-pytorch\/EfficientNet-PyTorch\/'\nsys.path.append(package_path)\nfrom efficientnet_pytorch import EfficientNet","a6e4e9bc":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input\/bengaliai-cv19'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","e19b09f6":"class_map_df = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/class_map.csv')\nprint(f'class map shape: ', class_map_df.shape)\nclass_map_df.sample(50).drop_duplicates(['component_type'])","79d752fd":"train_df = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/train.csv')\nprint(f'train data shape: ', train_df.shape)\nprint(f'unique graphemes: ', train_df['grapheme'].nunique())\nprint(f'unique grapheme_root: ', train_df['grapheme_root'].nunique())\nprint(f'unique vowel_diacritic: ', train_df['vowel_diacritic'].nunique())\nprint(f'unique consonant_diacritic: ', train_df['consonant_diacritic'].nunique())\n\ntrain_df.head()","a3aa3218":"test_df = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/test.csv')\nprint(f'test data shape: ', test_df.shape)\ntest_df.head(6)","49479b8c":"sample_sub_df = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/sample_submission.csv')\nsample_sub_df.head(6)","e656b11f":"# clean up\ndel train_df\ndel test_df\ndel class_map_df\n_ = gc.collect()","042e2d54":"def get_image_data(mode='val', debug=False):\n    '''\n    helper function for PyTorch Dataset class\n    \n    Arguments:\n        mode (str) -- reads the feather files with train in the filename for train and val,\n                      and reads files with test in their names.\n                           \n    Returns:\n        img_df (dataframe) -- training images if train = true, else test images\n    '''\n    \n    img_list = []\n    file_type = mode # to fetch files\n    if mode == 'val':\n        file_type = 'train'\n    for dirname, _, filenames in os.walk('\/kaggle\/input\/bengaliaicv19feather'):\n        for filename in filenames:\n            if file_type in filename:\n                img_list.append(pd.read_feather(os.path.join(dirname, filename)))\n                           \n    if mode == 'val':\n        img_df = pd.DataFrame(img_list[-1])\n    elif mode == 'train':\n        img_df = pd.concat(img_list[0:-1])\n    else:\n        img_df = pd.concat(img_list)\n        \n    print(f\"[Helper] {mode} image dataset: {img_df.shape}\")\n    \n    img_df = img_df[0:25]\n    \n    del img_list\n    _ = gc.collect()\n    \n    return img_df","ce5dd728":"def plot_images(rows, cols, img_df, train=True):\n    \"\"\"\n    Grid of images\n    \n    Arguments:\n        rows, cols (int, int) -- dimenstion of the image grid\n        img_df (dataframe) -- Dataframe of all the images\n        train (boolean) -- fetch meta data from the csv files accordingly\n    \"\"\"\n    \n    fig = plt.figure(figsize=(15., 12.))\n    grid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(rows, cols),  # creates 5x5 grid of axes\n                 axes_pad=0.3,  # pad between axes in inch.\n                 )\n    train_df = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/train.csv')\n    test_df = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/test.csv')\n\n    meta_df = train_df if train else test_df\n    \n    for ax, df_row in zip(grid, img_df.sample(rows*cols).values.tolist()):\n        # Iterating over the grid returns the Axes.\n        _ = ax.imshow(np.asarray(df_row[1:]).astype(int).reshape(137,236))\n        # fetch the sample's labels from the csv file\n        meta = meta_df[meta_df['image_id']==df_row[0]].values[0]\n        \n        if train:\n            title =  f'{df_row[0]}_{meta[1]}_{meta[2]}_{meta[3]}'\n        else: \n            title =  f'{df_row[0]}'\n            \n        _ = ax.set_title(title)\n        _ = ax.axis('off')\n   \n    _ = plt.show()\n    \n    del train_df\n    del test_df\n    del meta_df\n    _ = gc.collect()","a230d773":"%%time\n\n# get the data\nimg_df = get_image_data(mode='train', debug=True)\n# visualise few images \nplot_images(5, 5, img_df, train=True)","e4b428fd":"# clear the data after visualization\n# Since we will be loading the data using PyTorch Dataset class again in the later cells\ndel img_df\n_ = gc.collect()","2161070b":"class BengaliAI(Dataset):\n    \"\"\"Bengali AI dataset for training PyTorch models\"\"\"\n\n    def __init__(self, mode='val', transform=None, debug=False):\n        \"\"\"\n        Arguments:\n            mode (str) -- to fetch appr. meta data. Default to val since smaller size\n            transform (callable) -- Transform to be applied on each sample \n        \"\"\"\n        self.mode = mode\n        if self.mode == 'train' or self.mode == 'val':         \n            self.metadata = pd.read_csv(f'\/kaggle\/input\/bengaliai-cv19\/train.csv')\n        else:\n            self.metadata = pd.read_csv(f'\/kaggle\/input\/bengaliai-cv19\/test.csv')\n\n        self.data = get_image_data(mode, debug)\n        self.transform = transform\n        \n        if self.mode != 'test':\n            _categorical_columns = ['grapheme_root', 'vowel_diacritic', 'consonant_diacritic']\n            self.grapheme_root = self.metadata[_categorical_columns[0]]\n            self.vowel_diacritic = self.metadata[_categorical_columns[1]]\n            self.constant_diacritic = self.metadata[_categorical_columns[2]]\n                                                \n    def __len__(self):\n        return len(self.data)\n    \n    def __getitem__(self, idx):\n        \"\"\"\n        Arguments:\n            idx (int) -- Dataset class is a map-style dataset (https:\/\/pytorch.org\/docs\/stable\/data.html#map-style-datasets) \n                         where idx is the index of a specific sample in the map\n\n        Returns:\n            sample (dic) -- Each sample is a dic with keys as image_id, image, grapheme_root, vowel_diacritic, consonant_diacritic\n        \"\"\"\n        # we will disard the image id prefix 'Train_\/Test_' so its easy to format it as tensor\n        # data = image data\n        _data_at_idx = self.data.iloc[idx]\n        _image_id = int(_data_at_idx[0].split('_')[1])\n        _image = _data_at_idx[1:]\n        \n        if self.mode == 'test':\n            sample = {'image_id': _image_id,\n              'image': _image\n             }\n        \n        else:\n            _grapheme_root = self.grapheme_root.iloc[idx]\n            _vowel_diacritic = self.vowel_diacritic.iloc[idx]\n            _constant_diacritic = self.constant_diacritic.iloc[idx]\n\n            sample = {'image_id': _image_id,\n                      'image': _image,\n                      'grapheme_root': _grapheme_root,\n                      'vowel_diacritic': _vowel_diacritic,\n                      'consonant_diacritic': _constant_diacritic\n                     }\n\n        if self.transform:\n            sample = self.transform(sample)\n            \n        return sample","fe0f5e92":"class ToTensor(object):\n    \"\"\"Convert ndarrays in sample to Tensors. And also makes it 3 channel\"\"\"\n\n    def __call__(self, sample):\n        for key in sample.keys():\n            sample[key] = torch.tensor(sample[key], dtype=torch.float32)\n            if key == 'image':\n                sample[key] = sample[key].reshape(137, 236).repeat(3, 1, 1)\n        \n        return sample","161ff7bd":"%%time \nbengali_dataset= BengaliAI(mode='test', transform=ToTensor(), debug=True)\nsample = bengali_dataset[0]\nsample","a0ed36b1":"del bengali_dataset\ngc.collect()","60065712":"class ResNext3(LightningModule):\n\n    def __init__(self):\n        super(ResNext3, self).__init__()\n        # ResNext\n        # backbone_model = torch.hub.load('pytorch\/vision:v0.5.0', 'resnext50_32x4d', pretrained=False)\n        self.toy_data = True\n        backbone_model = EfficientNet.from_name('efficientnet-b7') \n        backbone_model.load_state_dict(torch.load('..\/input\/efficientnet-pytorch\/efficientnet-b7-dcc49843.pth'))\n        # Take the whole resnext except for the last layer\n        backbone_layers = torch.nn.ModuleList(backbone_model.children())[:-2]\n        # Unpack all layers to Sequential as list is not a valid parameter \n        self.features = torch.nn.Sequential(*backbone_layers)\n        in_features = backbone_model._fc.in_features\n        self.fc_grapheme_root = torch.nn.Linear(in_features, 168)\n        self.fc_vowel_diacritic = torch.nn.Linear(in_features, 11)\n        self.fc_consonant_diacritic = torch.nn.Linear(in_features, 7)\n\n    def forward(self, x):\n        x = self.features(x)\n        x = torch.flatten(x,1)\n        grapheme = self.fc_grapheme_root(x)\n        vowel = self.fc_vowel_diacritic(x)\n        consonant = self.fc_consonant_diacritic(x)    \n        return grapheme, vowel, consonant\n        \n    def training_step(self, batch, batch_idx):\n        print(batch)\n        grapheme, vowel, consonant = self.forward(batch['image'])\n        loss_grapheme = F.cross_entropy(grapheme, batch['grapheme_root'].long())\n        loss_vowel = F.cross_entropy(vowel, batch['vowel_diacritic'].long())\n        loss_consonant = F.cross_entropy(consonant, batch['consonant_diacritic'].long())\n        logger_logs = {\"tl_grapheme\": loss_grapheme, \n                       \"tl_vowel\": loss_vowel, \n                       \"tl_consonant\": loss_consonant}\n        \n        return {'loss': loss_grapheme+loss_vowel+loss_consonant, 'log': logger_logs}\n\n    def validation_step(self, batch, batch_idx):\n        print(batch)\n        grapheme, vowel, consonant = self.forward(batch['image'])\n        loss_grapheme = F.cross_entropy(grapheme, batch['grapheme_root'].long())\n        loss_vowel = F.cross_entropy(vowel, batch['vowel_diacritic'].long())\n        loss_consonant = F.cross_entropy(consonant, batch['consonant_diacritic'].long())\n        logger_logs = {\"vl_grapheme\": loss_grapheme, \n                       \"vl_vowel\": loss_vowel, \n                       \"vl_consonant\": loss_consonant}\n        return {'val_loss': loss_grapheme+loss_vowel+loss_consonant, 'log': logger_logs}\n                                                                                            \n    def validation_end(self, outputs):\n        logger_logs = {'avg_val_loss': torch.stack([x['val_loss'] for x in outputs]).mean(),\n                       \"avl_grapheme\": torch.stack([x['log']['vl_grapheme'] for x in outputs]).mean(), \n                       \"avl_vowel\": torch.stack([x['log']['vl_vowel'] for x in outputs]).mean(), \n                       \"avl_consonant\": torch.stack([x['log']['vl_consonant'] for x in outputs]).mean()\n                       }\n        # must return 'val_loss' as key\n        return {'val_loss': logger_logs['avg_val_loss'], 'log': logger_logs} \n    \n    def configure_optimizers(self):\n        optimizer = Adam(self.parameters(), lr=0.001)\n        scheduler = ReduceLROnPlateau(optimizer)\n        return [optimizer],[scheduler]\n\n    def train_dataloader(self):\n        return DataLoader(BengaliAI(mode='train', transform=ToTensor()), batch_size=64, pin_memory=True)\n    \n    def val_dataloader(self):\n        return DataLoader(BengaliAI(mode='val', transform=ToTensor()), batch_size=64, pin_memory=True)        \n\n    def test_dataloader(self):\n        return DataLoader(BengaliAI(mode='test', transform=ToTensor()), batch_size=64, pin_memory=True)        ","1c5d3c83":"model = ResNext3()\nwandb_logger = WandbLogger(name='The-run', project='bengali-ai')\ntrainer = Trainer(gpus=0, fast_dev_run=True, checkpoint_callback=None)","f4dd65b0":"trainer.fit(model)","c86446ff":"del trainer","cd157b8c":"## The Lightning Module\nThis is \"**The Juice**\", where all your research and creativity goes!    \nPyTorch Lightning also provides [research seed](https:\/\/github.com\/williamFalcon\/pytorch-lightning-conference-seed), cookie-cutter-like template for your project repository.\n\n<div class=\"alert alert-block alert-info\">\n<b>\ud83d\udca1<\/b>\nA [LightningModule](https:\/\/pytorch-lightning.readthedocs.io\/en\/latest\/lightning-module.html) is a strict superclass of torch.nn.Module but provides an interface to standardize the \u201cingredients\u201d for a research or production system. \n<\/div>","32731945":"### Reading The CSVs","e8c6f437":"#### Sanity Check","c0b99d73":"Some helper functions to handle and visualize the data","ed27ff30":"## Preparing PyTorch Dataset","f5a94a8e":"Importing libraries","99750f03":"### Data Overview","de814270":"## Introduction\nMotivation - We go through many kernels and repos and try to understand the what the model is doing. And as you know, apart from the fundemental differences in the architecture and training procedure we see lots of variation in the coding style like the way the training loop is, what happens at the end of each training or validation epoch. So you have to spend some time to understand things that does not really contribute to the fundemental approach. And even for the person developing the model, he spends a good time to write boilerplate code.  \n\nThis kernel is a quick introduction to [PyTorch Lightning](https:\/\/github.com\/PyTorchLightning\/pytorch-lightning#how-do-i-do-use-it) a PyTorch wrapper for ML researchers. This automates non essential procedures and enforces a good coding style to make machine learning solutions much more consistent and reproducible. \"More of a style guide than a framework\".  \n\n![lightning_logo.svg](attachment:lightning_logo.svg)\n\ntl;dr just jump into [The Lightning Module](#The-Lightning-Module) section which has the stuff I wanted to share!","3358b8fc":"### Reading The Image files\n\nSince loading the parquet files is a bit slow, we use another [public dataset](https:\/\/www.kaggle.com\/corochann\/bengaliaicv19feather) in [feather format](https:\/\/github.com\/wesm\/feather) which is around 30 times faster!","07bdc96f":"*This is a work in progress. Should I improve this, showing more features of PL or is it too late for example kernels for this competition?*","d25906bc":"- Pytorch Lightning supports many experiment tracking platforms like wandb, comet, test tube etc.   \n- The logger should be set to wandb_logger since it needs a key which can not be provided when commiting the kernel I set it to None.\n- Simply set gpus=1 or more to make it use gpus.  \n- Setting the fast_dev_run to True will run all steps of training once to make sure everything is in place.  \n\n  You have tons of these elegant abstractions, Isnt it cool?"}}