{"cell_type":{"6128d75c":"code","ac85c293":"code","b8dac5df":"code","f0c9c3d1":"code","af72fad9":"code","aa86dac9":"code","145d9dde":"code","4ddf108f":"code","0db85fdf":"code","e8e6f1e4":"code","3c4df45b":"code","c5da4e31":"code","db52e548":"code","7252891a":"code","50e38141":"code","46a0b7cb":"code","50c65c95":"code","36c9c1f0":"code","b56886cc":"code","2195ac2a":"code","03666760":"code","45142cf5":"code","7b2ccf0f":"code","9ce38e8a":"code","c0631797":"code","7674d959":"code","05733e52":"code","92bf4272":"code","eb4d4160":"code","b6c1f6f3":"code","bbef3d36":"code","c9fcbfa6":"code","7cd42df1":"code","9a89a7ed":"code","a00989a3":"code","77d6fdf7":"code","90695533":"code","01769909":"code","1f5b3d67":"code","eb3b0e97":"code","a57d3955":"code","75e614db":"code","3787ad76":"code","0500150f":"code","2ba37571":"code","8105bcbc":"code","baee6f32":"code","1164b08d":"code","c228deab":"code","ffd40805":"code","c8ece791":"code","32587ffb":"code","0040a99a":"code","099ee931":"code","67a73565":"code","3fe8f8a3":"code","1d982205":"code","8c1d5e83":"code","24bf51cb":"code","806806e5":"code","5e07ed0a":"code","7e367522":"code","2682171e":"code","f402d87b":"code","6bb2185f":"markdown","d0d8ac05":"markdown","04335d47":"markdown","7d3071e9":"markdown","3694591c":"markdown","94383345":"markdown","c86c7a1c":"markdown","722cbf6c":"markdown","e4f58f93":"markdown","fe91af15":"markdown","f0f535d9":"markdown","07e566a7":"markdown","db54451e":"markdown","9cd6c927":"markdown","0cf0f604":"markdown","7438e448":"markdown","ddf7f73f":"markdown","ad282486":"markdown"},"source":{"6128d75c":"folds = 5\n\ndebug = False\nnum_rounds=1000\n\nuse_ucf  = True  # use ucf data in train\nuse_sort = True # sort by month\ndel_2016 = True # delete site0 2016 from train\nucf_year = [2017, 2018] # ucf data year used in train ","ac85c293":"import gc\nimport os\nfrom pathlib import Path\nimport random\nimport sys\n\nfrom tqdm import tqdm_notebook as tqdm\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom IPython.core.display import display, HTML\n\n# --- plotly ---\nfrom plotly import tools, subplots\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.express as px\nimport plotly.figure_factory as ff\n\n# --- models ---\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import KFold\nimport lightgbm as lgb\nimport xgboost as xgb\nimport catboost as cb\n\nfrom sklearn.metrics import mean_squared_error","b8dac5df":"# Original code from https:\/\/www.kaggle.com\/gemartin\/load-data-reduce-memory-usage by @gemartin\n# Modified to support timestamp type, categorical type\n# Modified to add option to use float16 or not. feather format does not support float16.\nfrom pandas.api.types import is_datetime64_any_dtype as is_datetime\nfrom pandas.api.types import is_categorical_dtype\n\ndef reduce_mem_usage(df, use_float16=False):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.        \n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))\n    \n    for col in df.columns:\n        if is_datetime(df[col]) or is_categorical_dtype(df[col]):\n            # skip datetime type or categorical type\n            continue\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if use_float16 and c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        else:\n            df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n    \n    return df","f0c9c3d1":"!ls ..\/input\/ashrae-ucf-spider-and-eda-full-test-labels","af72fad9":"%%time\nroot = Path('..\/input\/ashrae-feather-format-for-fast-loading')\n\ntrain_df = pd.read_feather(root\/'train.feather')\nweather_train_df = pd.read_feather(root\/'weather_train.feather')\nweather_test_df = pd.read_feather(root\/'weather_test.feather')\nbuilding_meta_df = pd.read_feather(root\/'building_metadata.feather')","aa86dac9":"# load site 0 data\nucf_root = Path('..\/input\/ashrae-ucf-spider-and-eda-full-test-labels')\nleak_df = pd.read_pickle(ucf_root\/'site0.pkl') \nleak_df['meter_reading'] = leak_df.meter_reading_scraped\nleak_df.drop(['meter_reading_original','meter_reading_scraped'], axis=1, inplace=True)\nleak_df.fillna(0, inplace=True)\nleak_df.loc[leak_df.meter_reading < 0, 'meter_reading'] = 0\nleak_df = leak_df[leak_df.timestamp.dt.year > 2016]\nprint(len(leak_df))","145d9dde":"leak_df.head()","4ddf108f":"if use_ucf:\n    if del_2016:\n        print('delete all buildings site0 in 2016')\n        bids = leak_df.building_id.unique()\n        train_df = train_df[train_df.building_id.isin(bids) == False]\n\n    leak_df = leak_df[leak_df.timestamp.dt.year.isin(ucf_year)]\n    \n    train_df = pd.concat([train_df, leak_df])\n    train_df.reset_index(inplace=True)\n    weather_train_df = pd.concat([weather_train_df, weather_test_df])\n    weather_train_df.reset_index(inplace=True)","0db85fdf":"# # load site 0 building meta data\n# leak_meta_df = pd.read_pickle(ucf_root\/'building_metadata_external.pkl')\n# leak_meta_df.drop(['eui','leed'], axis=1, inplace=True)\n#building_meta_df = pd.concat([building_meta_df, leak_meta_df])\n#building_meta_df.reset_index(inplace=True)","e8e6f1e4":"del weather_test_df, leak_df, #leak_meta_df\ngc.collect()","3c4df45b":"train_df['date'] = train_df['timestamp'].dt.date\ntrain_df['meter_reading_log1p'] = np.log1p(train_df['meter_reading'])","c5da4e31":"def plot_date_usage(train_df, meter=0, building_id=0):\n    train_temp_df = train_df[train_df['meter'] == meter]\n    train_temp_df = train_temp_df[train_temp_df['building_id'] == building_id]    \n    train_temp_df_meter = train_temp_df.groupby('date')['meter_reading_log1p'].sum()\n    train_temp_df_meter = train_temp_df_meter.to_frame().reset_index()\n    fig = px.line(train_temp_df_meter, x='date', y='meter_reading_log1p')\n    fig.show()","db52e548":"plot_date_usage(train_df, meter=0, building_id=0)","7252891a":"building_meta_df[building_meta_df.site_id == 0]","50e38141":"train_df = train_df.query('not (building_id <= 104 & meter == 0 & timestamp <= \"2016-05-20\")')","46a0b7cb":"def preprocess(df):\n    df[\"hour\"] = df[\"timestamp\"].dt.hour\n#     df[\"day\"] = df[\"timestamp\"].dt.day\n    df[\"weekend\"] = df[\"timestamp\"].dt.weekday\n    df[\"month\"] = df[\"timestamp\"].dt.month\n    df[\"dayofweek\"] = df[\"timestamp\"].dt.dayofweek\n\n#     hour_rad = df[\"hour\"].values \/ 24. * 2 * np.pi\n#     df[\"hour_sin\"] = np.sin(hour_rad)\n#     df[\"hour_cos\"] = np.cos(hour_rad)","50c65c95":"preprocess(train_df)","36c9c1f0":"# sort train. i dont know it is best\nif use_ucf and use_sort:\n    train_df = train_df.sort_values('month')\n    train_df = train_df.reset_index()","b56886cc":"df_group = train_df.groupby('building_id')['meter_reading_log1p']\n#building_mean = df_group.mean().astype(np.float16)\nbuilding_median = df_group.median().astype(np.float16)\n#building_min = df_group.min().astype(np.float16)\n#building_max = df_group.max().astype(np.float16)\n#building_std = df_group.std().astype(np.float16)\n\n#train_df['building_mean'] = train_df['building_id'].map(building_mean)\ntrain_df['building_median'] = train_df['building_id'].map(building_median)\n#train_df['building_min'] = train_df['building_id'].map(building_min)\n#train_df['building_max'] = train_df['building_id'].map(building_max)\n#train_df['building_std'] = train_df['building_id'].map(building_std)\ndel df_group","2195ac2a":"#building_mean.head()","03666760":"weather_train_df.head()","45142cf5":"# weather_train_df.describe()","7b2ccf0f":"weather_train_df.isna().sum()","9ce38e8a":"weather_train_df.shape","c0631797":"weather_train_df.groupby('site_id').apply(lambda group: group.isna().sum())","7674d959":"weather_train_df = weather_train_df.groupby('site_id').apply(lambda group: group.interpolate(limit_direction='both'))","05733e52":"weather_train_df.groupby('site_id').apply(lambda group: group.isna().sum())","92bf4272":"def add_lag_feature(weather_df, window=3):\n    group_df = weather_df.groupby('site_id')\n    cols = ['air_temperature', 'cloud_coverage', 'dew_temperature', 'precip_depth_1_hr', 'sea_level_pressure', 'wind_direction', 'wind_speed']\n    rolled = group_df[cols].rolling(window=window, min_periods=0)\n    lag_mean = rolled.mean().reset_index().astype(np.float16)\n    lag_max = rolled.max().reset_index().astype(np.float16)\n    lag_min = rolled.min().reset_index().astype(np.float16)\n    lag_std = rolled.std().reset_index().astype(np.float16)\n    for col in cols:\n        weather_df[f'{col}_mean_lag{window}'] = lag_mean[col]\n        weather_df[f'{col}_max_lag{window}'] = lag_max[col]\n        weather_df[f'{col}_min_lag{window}'] = lag_min[col]\n        weather_df[f'{col}_std_lag{window}'] = lag_std[col]","eb4d4160":"# skip lag feature to save memory\n#add_lag_feature(weather_train_df, window=3)\n#add_lag_feature(weather_train_df, window=72)","b6c1f6f3":"weather_train_df.head()","bbef3d36":"weather_train_df.columns","c9fcbfa6":"# categorize primary_use column to reduce memory on merge...\n\nprimary_use_list = building_meta_df['primary_use'].unique()\nprimary_use_dict = {key: value for value, key in enumerate(primary_use_list)} \nprint('primary_use_dict: ', primary_use_dict)\nbuilding_meta_df['primary_use'] = building_meta_df['primary_use'].map(primary_use_dict)\n\ngc.collect()","7cd42df1":"train_df = reduce_mem_usage(train_df, use_float16=True)\nbuilding_meta_df = reduce_mem_usage(building_meta_df, use_float16=True)\nweather_train_df = reduce_mem_usage(weather_train_df, use_float16=True)","9a89a7ed":"building_meta_df.head()","a00989a3":"category_cols = ['building_id', 'site_id', 'primary_use']  # , 'meter'\nfeature_cols = ['square_feet', 'year_built'] + [\n    'hour', 'weekend', # 'month' , 'dayofweek'\n    'building_median'] + [\n    'air_temperature', 'cloud_coverage',\n    'dew_temperature', 'precip_depth_1_hr', 'sea_level_pressure',\n    'wind_direction', 'wind_speed', ]\n#     'air_temperature_mean_lag72',\n#     'air_temperature_max_lag72', 'air_temperature_min_lag72',\n#     'air_temperature_std_lag72', 'cloud_coverage_mean_lag72',\n#     'dew_temperature_mean_lag72', 'precip_depth_1_hr_mean_lag72',\n#     'sea_level_pressure_mean_lag72', 'wind_direction_mean_lag72',\n#     'wind_speed_mean_lag72', 'air_temperature_mean_lag3',\n#     'air_temperature_max_lag3',\n#     'air_temperature_min_lag3', 'cloud_coverage_mean_lag3',\n#     'dew_temperature_mean_lag3',\n#     'precip_depth_1_hr_mean_lag3', 'sea_level_pressure_mean_lag3',\n#     'wind_direction_mean_lag3', 'wind_speed_mean_lag3']","77d6fdf7":"def create_X_y(train_df, target_meter):\n    target_train_df = train_df[train_df['meter'] == target_meter]\n    target_train_df = target_train_df.merge(building_meta_df, on='building_id', how='left')\n    target_train_df = target_train_df.merge(weather_train_df, on=['site_id', 'timestamp'], how='left')\n    X_train = target_train_df[feature_cols + category_cols]\n    y_train = target_train_df['meter_reading_log1p'].values\n\n    del target_train_df\n    return X_train, y_train","90695533":"def fit_lgbm(train, val, devices=(-1,), seed=None, cat_features=None, num_rounds=1500, lr=0.1, bf=0.1):\n    \"\"\"Train Light GBM model\"\"\"\n    X_train, y_train = train\n    X_valid, y_valid = val\n    metric = 'l2'\n    params = {'num_leaves': 31,\n              'objective': 'regression',\n#               'max_depth': -1,\n              'learning_rate': lr,\n              \"boosting\": \"gbdt\",\n              \"bagging_freq\": 5,\n              \"bagging_fraction\": bf,\n              \"feature_fraction\": 0.9,\n              \"metric\": metric,\n#               \"verbosity\": -1,\n#               'reg_alpha': 0.1,\n#               'reg_lambda': 0.3\n              }\n    device = devices[0]\n    if device == -1:\n        # use cpu\n        pass\n    else:\n        # use gpu\n        print(f'using gpu device_id {device}...')\n        params.update({'device': 'gpu', 'gpu_device_id': device})\n\n    params['seed'] = seed\n\n    early_stop = 20\n    verbose_eval = 20\n\n    d_train = lgb.Dataset(X_train, label=y_train, categorical_feature=cat_features)\n    d_valid = lgb.Dataset(X_valid, label=y_valid, categorical_feature=cat_features)\n    watchlist = [d_train, d_valid]\n\n    print('training LGB:')\n    model = lgb.train(params,\n                      train_set=d_train,\n                      num_boost_round=num_rounds,\n                      valid_sets=watchlist,\n                      verbose_eval=verbose_eval,\n                      early_stopping_rounds=early_stop)\n\n    # predictions\n    y_pred_valid = model.predict(X_valid, num_iteration=model.best_iteration)\n    \n    print('best_score', model.best_score)\n    log = {'train\/mae': model.best_score['training']['l2'],\n           'valid\/mae': model.best_score['valid_1']['l2']}\n    return model, y_pred_valid, log","01769909":"#folds = 5\nseed = 666\nshuffle = False\nkf = KFold(n_splits=folds, shuffle=shuffle, random_state=seed)\noof_total = 0","1f5b3d67":"target_meter = 0\nX_train, y_train = create_X_y(train_df, target_meter=target_meter)\ny_valid_pred_total = np.zeros(X_train.shape[0])\ngc.collect()\nprint('target_meter', target_meter, X_train.shape)\n\ncat_features = [X_train.columns.get_loc(cat_col) for cat_col in category_cols]\nprint('cat_features', cat_features)\n\nmodels0 = []\nfor train_idx, valid_idx in kf.split(X_train, y_train):\n    train_data = X_train.iloc[train_idx,:], y_train[train_idx]\n    valid_data = X_train.iloc[valid_idx,:], y_train[valid_idx]\n\n    print('train', len(train_idx), 'valid', len(valid_idx))\n#     model, y_pred_valid, log = fit_cb(train_data, valid_data, cat_features=cat_features, devices=[0,])\n    model, y_pred_valid, log = fit_lgbm(train_data, valid_data, cat_features=category_cols,\n                                        num_rounds=num_rounds, lr=0.05, bf=0.7)\n    y_valid_pred_total[valid_idx] = y_pred_valid\n    models0.append(model)\n    gc.collect()\n    if debug:\n        break\n\nsns.distplot(y_train)\nsns.distplot(y_valid_pred_total)\n\noof0 = mean_squared_error(y_train, y_valid_pred_total)\noof_total += oof0 * len(y_train)\n\ndel X_train, y_train\ngc.collect()","eb3b0e97":"def plot_feature_importance(model):\n    importance_df = pd.DataFrame(model.feature_importance(),\n                                 index=feature_cols + category_cols,\n                                 columns=['importance']).sort_values('importance')\n    fig, ax = plt.subplots(figsize=(8, 8))\n    importance_df.plot.barh(ax=ax)\n    fig.show()","a57d3955":"target_meter = 1\nX_train, y_train = create_X_y(train_df, target_meter=target_meter)\ny_valid_pred_total = np.zeros(X_train.shape[0])\ngc.collect()\nprint('target_meter', target_meter, X_train.shape)\n\ncat_features = [X_train.columns.get_loc(cat_col) for cat_col in category_cols]\nprint('cat_features', cat_features)\n\nmodels1 = []\nfor train_idx, valid_idx in kf.split(X_train, y_train):\n    train_data = X_train.iloc[train_idx,:], y_train[train_idx]\n    valid_data = X_train.iloc[valid_idx,:], y_train[valid_idx]\n\n    print('train', len(train_idx), 'valid', len(valid_idx))\n#     model, y_pred_valid, log = fit_cb(train_data, valid_data, cat_features=cat_features, devices=[0,])\n    model, y_pred_valid, log = fit_lgbm(train_data, valid_data, cat_features=category_cols, num_rounds=num_rounds,\n                                       lr=0.05, bf=0.5)\n    y_valid_pred_total[valid_idx] = y_pred_valid\n    models1.append(model)\n    gc.collect()\n    if debug:\n        break\n\nsns.distplot(y_train)\nsns.distplot(y_valid_pred_total)\n\noof1 = mean_squared_error(y_train, y_valid_pred_total)\noof_total += oof1 * len(y_train)\n\ndel X_train, y_train\ngc.collect()","75e614db":"target_meter = 2\nX_train, y_train = create_X_y(train_df, target_meter=target_meter)\ny_valid_pred_total = np.zeros(X_train.shape[0])\n\ngc.collect()\nprint('target_meter', target_meter, X_train.shape)\n\ncat_features = [X_train.columns.get_loc(cat_col) for cat_col in category_cols]\nprint('cat_features', cat_features)\n\nmodels2 = []\nfor train_idx, valid_idx in kf.split(X_train, y_train):\n    train_data = X_train.iloc[train_idx,:], y_train[train_idx]\n    valid_data = X_train.iloc[valid_idx,:], y_train[valid_idx]\n\n    print('train', len(train_idx), 'valid', len(valid_idx))\n#     model, y_pred_valid, log = fit_cb(train_data, valid_data, cat_features=cat_features, devices=[0,])\n    model, y_pred_valid, log = fit_lgbm(train_data, valid_data, cat_features=category_cols,\n                                        num_rounds=num_rounds, lr=0.05, bf=0.8)\n    y_valid_pred_total[valid_idx] = y_pred_valid\n    models2.append(model)\n    gc.collect()\n    if debug:\n        break\n\nsns.distplot(y_train)\nsns.distplot(y_valid_pred_total)\n\noof2 = mean_squared_error(y_train, y_valid_pred_total)\noof_total += oof2 * len(y_train)\n\ndel X_train, y_train\ngc.collect()","3787ad76":"target_meter = 3\nX_train, y_train = create_X_y(train_df, target_meter=target_meter)\ny_valid_pred_total = np.zeros(X_train.shape[0])\n\ngc.collect()\nprint('target_meter', target_meter, X_train.shape)\n\ncat_features = [X_train.columns.get_loc(cat_col) for cat_col in category_cols]\nprint('cat_features', cat_features)\n\nmodels3 = []\nfor train_idx, valid_idx in kf.split(X_train, y_train):\n    train_data = X_train.iloc[train_idx,:], y_train[train_idx]\n    valid_data = X_train.iloc[valid_idx,:], y_train[valid_idx]\n\n    print('train', len(train_idx), 'valid', len(valid_idx))\n#     model, y_pred_valid, log = fit_cb(train_data, valid_data, cat_features=cat_features, devices=[0,])\n    model, y_pred_valid, log = fit_lgbm(train_data, valid_data, cat_features=category_cols, num_rounds=num_rounds,\n                                       lr=0.03, bf=0.9)\n    y_valid_pred_total[valid_idx] = y_pred_valid\n    models3.append(model)\n    gc.collect()\n    if debug:\n        break\n\nsns.distplot(y_train)\nsns.distplot(y_valid_pred_total)\n\noof3 = mean_squared_error(y_train, y_valid_pred_total)\noof_total += oof3 * len(y_train)\n\ndel X_train, y_train\ngc.collect()","0500150f":"print ('oof score meter0 =', np.sqrt(oof0))\nprint ('oof score meter1 =', np.sqrt(oof1))\nprint ('oof score meter2 =', np.sqrt(oof2))\nprint ('oof score meter3 =', np.sqrt(oof3))\nprint ('oof score total  =', np.sqrt(oof_total \/ len(train_df)))","2ba37571":"del train_df, weather_train_df, building_meta_df \ngc.collect()","8105bcbc":"print('loading...')\ntest_df = pd.read_feather(root\/'test.feather')\nweather_test_df = pd.read_feather(root\/'weather_test.feather')\nbuilding_meta_df = pd.read_feather(root\/'building_metadata.feather')\n\nprint('preprocessing building...')\ntest_df['date'] = test_df['timestamp'].dt.date\npreprocess(test_df)\n#test_df['building_mean'] = test_df['building_id'].map(building_mean)\ntest_df['building_median'] = test_df['building_id'].map(building_median)\n# test_df['building_min'] = test_df['building_id'].map(building_min)\n# test_df['building_max'] = test_df['building_id'].map(building_max)\n# test_df['building_std'] = test_df['building_id'].map(building_std)\n\nprint('preprocessing weather...')\nweather_test_df = weather_test_df.groupby('site_id').apply(lambda group: group.interpolate(limit_direction='both'))\nweather_test_df.groupby('site_id').apply(lambda group: group.isna().sum())\n\n#add_lag_feature(weather_test_df, window=3)\n#add_lag_feature(weather_test_df, window=72)\n\nprint('reduce mem usage...')\nreduce_mem_usage(test_df, use_float16=True)\nreduce_mem_usage(weather_test_df, use_float16=True)\n\ngc.collect()","baee6f32":"sample_submission = pd.read_feather(os.path.join(root, 'sample_submission.feather'))\nreduce_mem_usage(sample_submission)","1164b08d":"def create_X(test_df, target_meter):\n    target_test_df = test_df[test_df['meter'] == target_meter]\n    target_test_df = target_test_df.merge(building_meta_df, on='building_id', how='left')\n    target_test_df = target_test_df.merge(weather_test_df, on=['site_id', 'timestamp'], how='left')\n    X_test = target_test_df[feature_cols + category_cols]\n    return X_test","c228deab":"def pred(X_test, models, batch_size=1000000):\n    iterations = (X_test.shape[0] + batch_size -1) \/\/ batch_size\n    print('iterations', iterations)\n\n    y_test_pred_total = np.zeros(X_test.shape[0])\n    for i, model in enumerate(models):\n        print(f'predicting {i}-th model')\n        for k in tqdm(range(iterations)):\n            y_pred_test = model.predict(X_test[k*batch_size:(k+1)*batch_size], num_iteration=model.best_iteration)\n            y_test_pred_total[k*batch_size:(k+1)*batch_size] += y_pred_test\n\n    y_test_pred_total \/= len(models)\n    return y_test_pred_total\n","ffd40805":"%%time\nX_test = create_X(test_df, target_meter=0)\ngc.collect()\n\ny_test0 = pred(X_test, models0)\n\nsns.distplot(y_test0)\n\ndel X_test\ngc.collect()","c8ece791":"%%time\nX_test = create_X(test_df, target_meter=1)\ngc.collect()\n\ny_test1 = pred(X_test, models1)\nsns.distplot(y_test1)\n\ndel X_test\ngc.collect()","32587ffb":"%%time\nX_test = create_X(test_df, target_meter=2)\ngc.collect()\n\ny_test2 = pred(X_test, models2)\nsns.distplot(y_test2)\n\ndel X_test\ngc.collect()","0040a99a":"X_test = create_X(test_df, target_meter=3)\ngc.collect()\n\ny_test3 = pred(X_test, models3)\nsns.distplot(y_test3)\n\ndel X_test\ngc.collect()","099ee931":"sample_submission.loc[test_df['meter'] == 0, 'meter_reading'] = np.expm1(y_test0)\nsample_submission.loc[test_df['meter'] == 1, 'meter_reading'] = np.expm1(y_test1)\nsample_submission.loc[test_df['meter'] == 2, 'meter_reading'] = np.expm1(y_test2)\nsample_submission.loc[test_df['meter'] == 3, 'meter_reading'] = np.expm1(y_test3)","67a73565":"if not debug:\n    sample_submission.to_csv('submission.csv', index=False, float_format='%.4f')","3fe8f8a3":"leak_score = 0\n\nleak_df = pd.read_pickle(ucf_root\/'site0.pkl') \nleak_df['meter_reading'] = leak_df.meter_reading_scraped\nleak_df.drop(['meter_reading_original','meter_reading_scraped'], axis=1, inplace=True)\nleak_df.fillna(0, inplace=True)\nleak_df = leak_df[leak_df.timestamp.dt.year > 2016]\nleak_df.loc[leak_df.meter_reading < 0, 'meter_reading'] = 0 # remove large negative values\n\nsample_submission.loc[sample_submission.meter_reading < 0, 'meter_reading'] = 0\n\nfor bid in leak_df.building_id.unique():\n    temp_df = leak_df[(leak_df.building_id == bid)]\n    for m in temp_df.meter.unique():\n        v0 = sample_submission.loc[(test_df.building_id == bid)&(test_df.meter==m), 'meter_reading'].values\n        v1 = temp_df[temp_df.meter==m].meter_reading.values\n        \n        leak_score += mean_squared_error(np.log1p(v0), np.log1p(v1)) * len(v0)\n        \n        sample_submission.loc[(test_df.building_id == bid)&(test_df.meter==m), 'meter_reading'] = temp_df[temp_df.meter==m].meter_reading.values\n        ","1d982205":"if not debug:\n    sample_submission.to_csv('submission_ucf_replaced.csv', index=False, float_format='%.4f')","8c1d5e83":"sample_submission.head()","24bf51cb":"np.log1p(sample_submission['meter_reading']).hist(bins=100)","806806e5":"print ('UCF score = ', np.sqrt(leak_score \/ len(leak_df)))","5e07ed0a":"plot_feature_importance(models0[1])","7e367522":"plot_feature_importance(models1[1])","2682171e":"plot_feature_importance(models2[1])","f402d87b":"plot_feature_importance(models3[1])","6bb2185f":"# Fill Nan value in weather dataframe by interpolation\n\n\nweather data has a lot of NaNs!!\n\n![](http:\/\/)I tried to fill these values by **interpolating** data.","d0d8ac05":"# UCF score","04335d47":"# Train model\n\nTo win in kaggle competition, how to evaluate your model is important.\nWhat kind of cross validation strategy is suitable for this competition? This is time series data, so it is better to consider time-splitting.\n\nHowever this notebook is for simple tutorial, so I will proceed with KFold splitting without shuffling, so that at least near-term data is not included in validation.","7d3071e9":"# Data preprocessing\n\nNow, Let's try building GBDT (Gradient Boost Decision Tree) model to predict `meter_reading_log1p`. I will try using LightGBM in this notebook.","3694591c":"# Train model by each meter type","94383345":"Some features introduced in https:\/\/www.kaggle.com\/ryches\/simple-lgbm-solution by @ryches\n\nFeatures that are likely predictive:\n\n#### Weather\n\n- time of day\n- holiday\n- weekend\n- cloud_coverage + lags\n- dew_temperature + lags\n- precip_depth + lags\n- sea_level_pressure + lags\n- wind_direction + lags\n- wind_speed + lags\n\n#### Train\n\n- max, mean, min, std of the specific building historically\n\n\n\nHowever we should be careful of putting time feature, since we have only 1 year data in training,\nincluding `date` makes overfiting to training data.\n\nHow about `month`? It may be better to check performance by cross validation.\nI go not using this data in this kernel for robust modeling.","c86c7a1c":"# Replace to UCF data","722cbf6c":"## Removing weired data on site_id 0\n\nAs you can see above, this data looks weired until May 20. It is reported in [this discussion](https:\/\/www.kaggle.com\/c\/ashrae-energy-prediction\/discussion\/113054#656588) by @barnwellguy that **All electricity meter is 0 until May 20 for site_id == 0**. I will remove these data from training data.\n\nIt corresponds to `building_id <= 104`.","e4f58f93":"# OOF SCOREs","fe91af15":"# Leak Data loading and concat","f0f535d9":"# This Kernel will be a new starter kit for using UCF dataset\n\nThis Kernel are based on following great kernels:\n\n* [ASHRAE: Training LGBM by meter type](https:\/\/www.kaggle.com\/corochann\/ashrae-training-lgbm-by-meter-type)\n* [ASHRAE - UCF Spider and EDA (Full Test Labels)](https:\/\/www.kaggle.com\/gunesevitan\/ashrae-ucf-spider-and-eda-full-test-labels)\n\nThank you corochann and Gunes Evitan. You are Great Kagglers!!\n\nAnd also Thank you UCF to make great meter reading data public, I have no offence indeed \ud83d\ude05\n\n**\nI'm building new kernel [here ](https:\/\/www.kaggle.com\/yamsam\/ashrae-highway-kernel-route1) to add new data leak**","07e566a7":"Seems number of nan has reduced by `interpolate` but some property has never appear in specific `site_id`, and nan remains for these features.","db54451e":"## lags\n\nAdding some lag feature","9cd6c927":"# Prediction on test data","0cf0f604":"# Add time feature","7438e448":"# ASHRAE - Great Energy Predictor III\n\n\nOur aim in this competition is to predict energy consumption of buildings.\n\nThere are 4 types of energy to predict:\n\n - 0: electricity\n - 1: chilledwater\n - 2: steam\n - 3: hotwater\n\nElectricity and water consumption may have different behavior!\nSo I tried to separately train & predict the model.\n\nI moved previous [ASHRAE: Simple LGBM submission](https:\/\/www.kaggle.com\/corochann\/ashrae-simple-lgbm-submission) kernel.\n\n**[Update] I published \"[Optuna tutorial for hyperparameter optimization](https:\/\/www.kaggle.com\/corochann\/optuna-tutorial-for-hyperparameter-optimization)\" notebook.\nPlease also check it :)**","ddf7f73f":"# References\n\nThese kernels inspired me to write this kernel, thank you for sharing!\n\n - https:\/\/www.kaggle.com\/rishabhiitbhu\/ashrae-simple-eda\n - https:\/\/www.kaggle.com\/isaienkov\/simple-lightgbm\n - https:\/\/www.kaggle.com\/ryches\/simple-lgbm-solution","ad282486":"# Fast data loading\n\nThis kernel uses the preprocessed data from my previous kernel, [\nASHRAE: feather format for fast loading](https:\/\/www.kaggle.com\/corochann\/ashrae-feather-format-for-fast-loading), to accelerate data loading!"}}