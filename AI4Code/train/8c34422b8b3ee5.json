{"cell_type":{"4ec25352":"code","978cceaa":"code","81840727":"code","a09716e4":"code","ca7797ba":"code","a90822e6":"code","0818e291":"code","43efcdbb":"code","ffd35137":"code","86efaa03":"code","f51dd720":"code","a4246a9e":"code","90a3fe80":"code","76e33c59":"code","3db6d216":"code","fb011dc5":"code","412c3bc2":"code","bd500ead":"code","f354d983":"code","307fd845":"code","8fcfc8b7":"code","46674045":"code","73b44256":"code","ea25527a":"code","e72a73dd":"code","6d030d5f":"code","b737a2cb":"code","8ad88314":"code","f7070a9f":"code","68c8542f":"code","aa88df6d":"code","a0ea8371":"code","41360fa8":"code","52949835":"markdown","7a7654a5":"markdown","363c5ec4":"markdown","f1d987de":"markdown","81330326":"markdown","84a4aae6":"markdown","1464cda1":"markdown","77e878d9":"markdown","1189dc0c":"markdown","085bd1c2":"markdown","b4f584db":"markdown","5d537da3":"markdown","0b7b63e9":"markdown","d7a211d5":"markdown","67b811c7":"markdown","02f722b7":"markdown","a430fb11":"markdown","11d6a013":"markdown","db30ad4e":"markdown","a69d65b2":"markdown","065b4be2":"markdown","6d051019":"markdown","5605e73d":"markdown","19b62eea":"markdown","c4d87aec":"markdown","e38fb105":"markdown","8d9d5a98":"markdown","6b0db55b":"markdown"},"source":{"4ec25352":"import numpy as np\nimport matplotlib.pyplot as plt","978cceaa":"def spherical_lens(y,R,x0,k=0,A=0,B=0):\n    c=1\/R\n    z=c*np.power(y,2)\/(1+np.sqrt(1-(1+k)*np.power(c*y,2)))+x0+A*np.power(y,4)+B*np.power(y,6)\n    return z","81840727":"rs=np.linspace(-10,10,30)\nR=15","a09716e4":"z1=spherical_lens(rs,R,5)\nz2=spherical_lens(rs,R,5,k=-0.669032,A=0.22e-5,B=0.15e-8)","ca7797ba":"plt.plot(z1,rs)\nplt.plot(z2,rs)\nplt.ylim([-10,10])\nplt.xlim([4,8])\nplt.xlabel(\"z\")\nplt.ylabel(\"y\")","a90822e6":"from sympy import sin,cos,sqrt,power,latex,symbols,diff,ccode","0818e291":"z,y,c,k,zl,A,B,R_c=symbols('z y c k zl A B R_c')","43efcdbb":"spherical_expr=c*y**2\/(1+sqrt(1-(1+k)*(c*y)**2))-z+A*y**4+B*y**6+zl","ffd35137":"spherical_expr","86efaa03":"latex(spherical_expr)","f51dd720":"spherical_expr_prime=diff(spherical_expr,y)\nspherical_expr_prime","a4246a9e":"str(spherical_expr_prime)","90a3fe80":"ccode(spherical_expr_prime)","76e33c59":"theta,t=symbols('theta t')\nz0,y0=symbols('z0 y0')","3db6d216":"ray_z=z0+cos(theta)*t\nray_y=y0+sin(theta)*t","fb011dc5":"spherical_expr.subs(y,ray_y)\nspherical_expr.subs(z,ray_z)\nparam_spherical_expr=spherical_expr.subs(z,ray_z).subs(y,ray_y)\nparam_spherical_expr","412c3bc2":"print(latex(param_spherical_expr))","bd500ead":"str(param_spherical_expr)","f354d983":"ccode(param_spherical_expr)","307fd845":"param_spherical_expr_prime=diff(param_spherical_expr,t)\nparam_spherical_expr_prime","8fcfc8b7":"str(param_spherical_expr_prime)","46674045":"ccode(param_spherical_expr_prime)","73b44256":"def ray_param_eq(t,c,k,x0,y0,theta):\n    return c*(t*np.sin(theta) + y0)**2\/(np.sqrt(-c**2*(k + 1)*(t*np.sin(theta) + y0)**2 + 1) + 1) - t*np.cos(theta) - x0","ea25527a":"from scipy.interpolate import interp1d\nfrom matplotlib.axes import Axes\nfrom typing import Union,Callable\n\nimport os\nimport math","e72a73dd":"def _init_vec(x,y):\n    vec=np.empty(2)\n    vec[0]=x\n    vec[1]=y\n    return vec\n\ndef _fast_norm(x, y):\n    return math.sqrt(math.pow(x,2)+math.pow(y,2))\n\nclass Ray(object):\n    \"\"\"\n    The ray is a set of line segments. Each segment is represented by a vector v=[z,y]\n    Ray-tracing problem also requires parameterized expressions, i.e.,\n    z(t)=z_0+cos(theta)*t\n    y(t)=y_0+sin(theta)*t\n\n    z_0, y_0, theta are updated after an intersection with a surface occurs.\n    Lists are used to store the old values of z_0, y_0 and theta so that a figure renderer can plot all the segments\n\n\n    The ray data structure is:\n\n        |                         |                                 |\n        |                         |                                 |\n        |                         |                                 |\n        |                         |                                 |\n    starting point              surface 1                          surface 2\n\n       t_0                      t_1=                              t_2=\n                                t_end+t_0                         t_end+t_1\n\n     self.path: [v0,theta_0]      [[v_0,theta_0],[v_1,theta_1]]   [[v_0,theta_0],[v_1,theta_1],[v_2,theta_2]]\n     self.end_ts: [Inf]           [t_1,Inf]                       [t_1,t_2,Inf]\n     theta_x is raw angle from surface X, x=0 is starting point.\n    v_0 are the turning points of the ray vector. Every time a ray is intersected with a surface, the value of v_0 is updated\n    t_end is the ending \"time\" t of each line segment\n\n     Conventions of the coordinate:\n     z(right), y(up), x(forward). Same as the coordinate used in ZEMAX or other optics textbook\n\n\n    \"\"\"\n\n    def __init__(self, z_0, y_0, theta, wavelength=600):\n        \"\"\"\n        Initialize a beam\n\n        :param z_0: starting z position\n        :param y_0: starting y position\n        :param theta: traveling angle (theta)\n        :param wavelength: the wavelength of a ray in nanometer (not used in this implementation yet)\n        \"\"\"\n        self.z_0 = z_0\n        self.y_0 = y_0\n        self.theta = theta\n        self.dt = 0\n        self.v_0 = _init_vec(self.z_0, self.y_0)  # vector that stores the initial point of the ray\n        self.paths = [[np.copy(self.v_0), np.copy(self.theta)]]\n        self.end_ts = [float('Inf')]\n        self.k = _init_vec(np.cos(self.theta), np.sin(self.theta))\n        self.intensity = 1\n        self.wavelength = wavelength\n\n    def update_after_intersect(self, t_end, new_theta, end_beam=False):\n        \"\"\"\n        Update the state of a ray, including:\n        - a new starting point: [z_0,y_0]\n        - angle of directional cosine: theta\n\n        :param t_end:\n        :param new_theta: new traveling angle theta (radians)\n        :param attenu_coef: attenuation coefficient, assigned by the Surface object\n        :param end_beam: True if the ray will be stopped at this surface\n        :return: None\n        \"\"\"\n\n        self.v_0 += self.k * t_end\n\n        self.z_0 = self.v_0[0]\n        self.y_0 = self.v_0[1]\n\n        self.update_theta(new_theta)\n        next_t = t_end + self.dt\n        self.dt = next_t\n        self.end_ts[-1] = next_t\n\n        self.paths.append([np.copy(self.v_0), np.copy(self.theta)])\n\n        if not end_beam:\n            self.end_ts.append(float('Inf'))\n\n    def get_zy(self, delta_t):\n        \"\"\"\n        Get z and y positions from parameter t\n\n        :param delta_t:\n        :return: np.array [z,y]\n        \"\"\"\n        vv = self.v_0 + self.k * delta_t\n\n        return vv[0], vv[1]\n\n    def estimate_t(self, zp:float):\n        \"\"\"\n        Calculate t from a given z-position zp\n\n        :param zp: a value of z\n        :return: estimated t\n        \"\"\"\n\n        t = (zp - self.v_0[0]) \/ self.k[0]\n\n        return t\n\n    def update_theta(self, new_theta):\n        \"\"\"\n        Update the traveling angle theta\n\n        :param new_theta: new traveling angle theta of the ray\n        :return: None\n        \"\"\"\n        self.theta = new_theta\n        self.k = _init_vec(np.cos(self.theta), np.sin(self.theta))\n\n    def render(self, ax: Axes, time_of_fights, color='C0'):\n        \"\"\"\n        Render the ray start from the most recent reracted surface\n\n        :param ax: Matplotlib Axes to plot on\n        :param time_of_fights: the stopping time that the beam ends\n        :param color: matplotlib color\n        :return: None\n        \"\"\"\n        v_e = self.v_0 + time_of_fights * self.k\n\n        v_for_plots = np.vstack((self.v_0, v_e))\n        xs = v_for_plots[:, 0]\n        ys = v_for_plots[:, 1]\n\n        ax.plot(xs, ys, color=color)\n\n    def get_k_from_theta(self, theta):\n\n        k = _init_vec(np.cos(theta), np.sin(theta))\n\n        return k\n\n    def render_all(self, ax, time_of_flights, color=None):\n        \"\"\"\n        Plot all rays on the axes.\n\n        :param ax: axes to be plotted on\n        :param time_of_flights: end travel time of the ray\n        :param color: matplotlib color, such as 'C0', 'C1' or 'blue', 'red'. Set None for automatic colors.\n        :return:\n        \"\"\"\n\n        prev_t = 0\n        for idx in range(len(self.end_ts)):\n            v_0, theta = self.paths[idx]\n            end_t = self.end_ts[idx]\n            k = self.get_k_from_theta(theta)\n\n            if time_of_flights > end_t:\n                v_e = v_0 + (end_t - prev_t) * k\n            else:\n                v_e = v_0 + (time_of_flights - prev_t) * k\n            v_for_plots = np.vstack((v_0, v_e))\n            xs = v_for_plots[:, 0]\n            ys = v_for_plots[:, 1]\n            prev_t = end_t\n            if color is None:\n                plot_color = 'C{}'.format(idx)\n            else:\n                plot_color = color\n            ax.plot(xs, ys, color=plot_color, linewidth=0.5)","6d030d5f":"from scipy.optimize import newton\ndef surface_zr(y, c, z0, k=0, A=0, B=0):\n    z = c * np.power(y, 2) \/ (1 + np.sqrt(1 - (1 + k) * np.power(c * y, 2))) + z0 + A * np.power(y, 4) + B * np.power(y,\n                                                                                                                      6)\n    return z\n\n\nclass AsphericSurface(object):\n    def __init__(self, curvature, z_0, konic, aperture_radius=10, A=0, B=0,\n                 record_rays=False, material_nr=1.0, end_beam=False):\n        \"\"\"\n        Aspheric surface object.\n\n\n        :param curvature: curvature of the lens in (mm^-1)\n        :param z_0: center position of the lens on z-axis\n        :param konic: conic coefficient\n        :param aperture_radius: radius of the aperture\n        :param A: fourth order coefficient of the lens\n        :param B: sixth order coefficient of the lens\n        :param record_rays: True if the surface is a detector that records the ray that hit the surface\n        :param attenu_coef: attenuation coefficient  (1\/mm)\n        \"\"\"\n        self.c = curvature\n        self.k = konic\n        self.z_0 = z_0\n        self.A = A\n        self.B = B\n        self.aperture_radius = aperture_radius\n        self.ray_bins = []\n        self.record_rays = record_rays\n\n        # FUTURE improvement: this is temporary. Future version may have shifts in y\n        self.y_min = -aperture_radius\n        self.y_max = aperture_radius\n\n        self.constant_nr = material_nr\n        self.n_r = self._constant_nr\n\n        self.end_beam = end_beam\n\n    def _constant_nr(self, wavelength):\n        \"\"\"\n        function of wavelength dependent refractive index n_r(labmda)\n\n        :param wavelength: can be anything\n        :return: preset refractive index\n        \"\"\"\n\n        return self.constant_nr\n\n    def get_surface_zr(self, y):\n        z = surface_zr(y, self.c, self.z_0, self.k, self.A, self.B)\n        return z\n\n    def spherical_lens_prime(self, y, c, k, A, B):\n        return 4 * A * y ** 3 + 6 * B * y ** 5 + c ** 3 * y ** 3 * (k + 1) \/ (sqrt(-c ** 2 * y ** 2 * (k + 1) + 1) * (\n                sqrt(-c ** 2 * y ** 2 * (k + 1) + 1) + 1) ** 2) + 2 * c * y \/ (\n                       sqrt(-c ** 2 * y ** 2 * (k + 1) + 1) + 1)\n\n    def ray_param_eq(self, t, c, k, z0, y0, theta, A, B):\n        \"\"\"\n        Parametrized ray equation\n\n        :param t:\n        :param c:\n        :param k:\n        :param z0: starting point x0 of the ray\n        :param y0: starting point y0 of the ray\n        :param theta:\n        :param A: coefficients of higher order term (r**4)\n        :param B: coefficients of higher order term (r**6)\n        :return:\n        \"\"\"\n\n        return c * (t * np.sin(theta) + y0) ** 2 \/ (\n                np.sqrt(-c ** 2 * (k + 1) * (t * np.sin(theta) + y0) ** 2 + 1) + 1) - \\\n               t * np.cos(theta) - z0 + self.z_0 + A * (t * np.sin(theta) + y0) ** 4 + B * (t * np.sin(theta) + y0) ** 6\n\n    def ray_param_eq_prime(self, t, c, k, z0, y0, theta, A, B):\n        \"\"\"\n        First order derivative of parametrized ray equation\n\n        :param t:\n        :param c:\n        :param k:\n        :param z0: z0 is not used but was kept so that the parameters are the same as ray_param_eq(), for the use of newton raphson solver\n        :param y0:\n        :param theta:\n        :param A:\n        :param B:\n        :return:\n        \"\"\"\n\n        return 4 * A * (t * np.sin(theta) + y0) ** 3 * np.sin(theta) + 6 * B * (t * np.sin(theta) + y0) ** 5 * np.sin(\n            theta) + c ** 3 * (\n                       k + 1) * (t * np.sin(theta) + y0) ** 3 * np.sin(theta) \/ (\n                       np.sqrt(-c ** 2 * (k + 1) * (t * np.sin(theta) + y0) ** 2 + 1) * (\n                       np.sqrt(-c ** 2 * (k + 1) * (t * np.sin(theta) + y0) ** 2 + 1) + 1) ** 2) + 2 * c * (\n                       t * np.sin(theta) + y0) * np.sin(theta) \/ (\n                       np.sqrt(-c ** 2 * (k + 1) * (t * np.sin(theta) + y0) ** 2 + 1) + 1) - np.cos(theta)\n\n    def add_rays_into_bins(self, z, y, intensity, wavelength):\n        self.ray_bins.append((z, y, intensity, wavelength))\n\n    def get_tangent_vec(self, yp, normalize=True):\n        \"\"\"\n        Calculate the tangent vector of at the position y\n\n        :param yp: y-position of the tangent vector\n        :param normalize: normalize the norm ||v|| to unity\n        :return: a 2D np.array([z,y])\n        \"\"\"\n\n        xp_p = self.spherical_lens_prime(yp, self.c, self.k, self.A, self.B)\n        tangent_vec = np.empty(2)\n        tangent_vec[0] = xp_p\n        tangent_vec[1] = 1\n\n        if normalize:\n            tangent_vec = tangent_vec \/ _fast_norm(tangent_vec[0], tangent_vec[1])\n\n        return tangent_vec\n\n    def get_norm_vec(self, yp):\n        \"\"\"\n        Calculate the normal vector of at the position y\n\n        :param yp:\n        :return: a 2D np.array([z,y])\n        \"\"\"\n        tangent_vec = self.get_tangent_vec(yp, normalize=True)\n\n        normal_vec = np.empty(2)\n        normal_vec[0] = -tangent_vec[1]\n        normal_vec[1] = tangent_vec[0]\n\n        return normal_vec\n\n    def get_refraction(self, yp, ray: Ray, prev_n: float) -> np.ndarray:\n\n        n_r = self.n_r(ray.wavelength)\n        norm_vec = -self.get_norm_vec(yp)\n\n        # Calculate cosine from Snell's law\n        cos_I = norm_vec[0] * ray.k[0] + norm_vec[1] * ray.k[1]\n        sin_I = np.sqrt(1 - np.power(cos_I, 2))\n        sin_Ip = prev_n * sin_I \/ n_r\n        cos_Ip = np.sqrt(1 - np.power(sin_Ip, 2))\n\n        # Calculate the refractive vector\n        r_vec = ray.k\n        nprpn = n_r * cos_Ip - prev_n * cos_I\n\n        next_r = 1 \/ n_r * (prev_n * r_vec + nprpn * norm_vec)\n\n        return next_r\n\n    def intersect(self, ray: Ray, prev_n: Union[Callable[[float], float], None],\n                  t_min=0, t_max=10):\n\n        def unity_func(x):\n            return 1.0\n\n        if prev_n is None:\n            prev_n = unity_func\n\n        # Make a initial guess of t for newton-raphson solver\n        # the t could be either at the edge of a surface or the center of a surface\n        # depending on its shape\n        t_min_p_1 = ray.estimate_t(self.get_surface_zr(self.aperture_radius))\n        t_min_p_2 = ray.estimate_t(self.z_0)\n        t_min_p = min(t_min_p_1, t_min_p_2)\n\n        t_end = newton(self.ray_param_eq, (t_min_p + t_max) \/ 2,\n                       fprime=self.ray_param_eq_prime,\n                       args=(self.c, self.k, ray.z_0, ray.y_0, ray.theta, self.A, self.B))\n        # Calculate the intersected point between the ray and the surface\n        z_end, y_end = ray.get_zy(t_end)\n\n        # We have to check the point of intersection is within the boundary\n        if (y_end <= self.y_max) and (y_end >= self.y_min):\n            if self.record_rays:\n                self.add_rays_into_bins(z_end, y_end, ray.intensity, ray.wavelength)\n\n            next_r = self.get_refraction(y_end, ray, prev_n=prev_n(ray.wavelength))\n            new_theta = np.arctan2(next_r[1], next_r[0])\n\n            ray.update_after_intersect(t_end, new_theta=new_theta,\n                                       end_beam=self.end_beam)\n\n    def render(self, ax, point_num=1200):\n        rs = np.linspace(-self.aperture_radius, self.aperture_radius, point_num)\n        zs = self.get_surface_zr(rs)\n\n        ax.plot(zs, rs, color='black', linewidth=0.5)\n        ax.set_xlabel(\"z-position\")\n        ax.set_ylabel(\"y-position\")","b737a2cb":"lens_aperture_radius=5\nasf = AsphericSurface(curvature=1 \/ 20, konic=0.0,z_0=0, A=0.0,B=0.0,\n                aperture_radius=lens_aperture_radius, material_nr=2.0)\nbsf = AsphericSurface(curvature=-1 \/ 20, konic=0.0,z_0=15, A=0.0,B=0.0,\n                aperture_radius=lens_aperture_radius, material_nr=1.0)","8ad88314":"fig,ax=plt.subplots()\nasf.render(ax)\nbsf.render(ax)\nplt.show()","f7070a9f":"ray_number=10\ny_start = np.linspace(-lens_aperture_radius*0.9, lens_aperture_radius*0.9,\n                      num=ray_number)\nx_start = np.ones_like(y_start) * (-2.0)\ntheta = np.zeros_like(y_start)\nrays = []","68c8542f":"fig,ax=plt.subplots()\nasf.render(ax)\ntangent_vec_length=2.0\ny_pos_array = np.linspace(-lens_aperture_radius*0.9, lens_aperture_radius*0.9,\n                      num=ray_number)\nfor yp in y_pos_array:\n    # get tangent vector\n    t_v=asf.get_tangent_vec(yp,normalize=True)\n    t_v=t_v*0.1\n    n_v=asf.get_norm_vec(yp)\n    n_v=n_v*0.4\n    zp=asf.get_surface_zr(yp)\n    \n    # plot tangent vectors\n    ax.plot([zp-t_v[0],zp+t_v[0]],[yp-t_v[1],yp+t_v[1]],color=\"C2\",linewidth=2.0)\n    \n    # plot normal vectors\n    ax.plot([zp-n_v[0],zp+n_v[0]],[yp-n_v[1],yp+n_v[1]],color=\"C3\")\n\nax.set_xlim(left=-5,right=5)","aa88df6d":"asf.render(ax)\nfor i in range(y_start.shape[0]):\n    ray_wavelength=500\n    ray = Ray(x_start[i], y_start[i], theta[i], ray_wavelength)\n    rays.append(ray)\n\n    asf.intersect(ray, t_min=0, t_max=5, prev_n=None)\n    ray.render_all(ax,time_of_flights=50)\nfig","a0ea8371":"ax.set_xlim([-0.2,1.2])\nax.set_ylim([4,5])\nfig","41360fa8":"fig,ax=plt.subplots()\nasf.render(ax)\nbsf.render(ax)\nfor i in range(y_start.shape[0]):\n    ray_wavelength=500\n    ray = Ray(x_start[i], y_start[i], theta[i], ray_wavelength)\n    rays.append(ray)\n\n    asf.intersect(ray, t_min=0, t_max=100, prev_n=None)\n    bsf.intersect(ray, t_min=0, t_max=100, prev_n=asf.n_r)\n    ray.render_all(ax,time_of_flights=50)\nplt.show()","52949835":"### Define a bunch of rays\nSet the initial conditions of the rays","7a7654a5":"### Obtain the mathematical expressions of parametrized lens equation and their first-order derivatives\nWe will use sympy to do the symbolic maths.\nNote that we use the form\n$$\nf(z,y)=z(y)-z\n$$\nwhere\n$$\nz(y)=A y^{4} + B y^{6} + \\frac{c y^{2}}{\\sqrt{- c^{2} y^{2} \\left(k + 1\\right) + 1} + 1} +zl\n$$\n$zl$ is the coordinate of z of a lens when y=0\n","363c5ec4":"####  Get the first derivative","f1d987de":"Expression of lens equation $f(y,z)$","81330326":"# Ray-tracing in action","84a4aae6":"#### Parametrize the rays","1464cda1":"#### Calculate the first derivate $z(r)$","77e878d9":"Zoom to see the how the ray is refracted","1189dc0c":"$z'(y)$ as python code","085bd1c2":"### Visualize the aspherical surfaces\nNote that the convention of lens equation is **z->right, y->up, and x->inward**","b4f584db":"This notebook demonstrates a vanilla 2D ray-tracing algorithm.\nThe first part of this tutorial explains the algorithm, and the second part I write simple python code to demonstrate the ray-tracing in action.","5d537da3":"### Define a bunch of rays\nSet the initial conditions of the rays","0b7b63e9":"### Calculate the tangent and normal vectors of rays","d7a211d5":"#### Subsitute ```y(t)``` and ```z(t)``` into the surface equations","67b811c7":"### Implementation of ```AsphericSurface```\n\nSome key elements of this object:\n\n- ```get_tangent_vec(y_p)```: calculate the tangent vector $dS$ on $y_p$\n- ```get_tangent_vec(y_p)```: calculate the tangent vector $dN$ on $y_p$\n- ```get_refraction()```: calculate the new traveling vector of a ray using Snell's law\n- ```intersect()```: find the intersection between a ray and the surface, and then calcualte the refraction of the ray\n\n<img src=\"https:\/\/kanhua.github.io\/images\/ray_tracing_illustration.svg\" alt=\"Drawing\" style=\"width: 400px;\"\/>","02f722b7":"Expression in python","a430fb11":"## Introduction\n\nModeling light as rays is widely used in computer graphics and lens design. I encountered this problem when I tried to do some optical design but had no access to commercial ray-tracing software, such as ZEMAX OpticStudio or LightTools. During my attempt of implementing a ray-tracing program for my own research, I did not find a single article or book chapter that serves a one-stop manual that details the ray-tracing from theory to implementation. I therefore parepared this tutorial to fill this gap.\n\nThis article demonstrates a simple two-dimensional ray-tracing algorithms, with a focus on concnetrator lens design. For lens design with spherical lens surfaces, using ray transfer matrix would be easier to implement and computationally efficient.\n\n\n\n## Outline of ray-tracing algorithm\n\nIn a ray tracing simulation, light is thought of as a bunch of light rays. You can also think the light are a bunch of particles (i.e. photons), and the \u201crays\u201d are the trajectory of movements of these particles. When a light ray encouters a surface, some of its energy is refelcted, some is refracted and some are absorbed, and each of the splitted rays keeps going until they strike another surface. Since the focus of this article is lens design, we only deal with the case of refraction. In summary, a ray-tracing simulation iterates the following steps:\n\n-   Find the intersection between a ray and a surface\n\n-   Calculate the new traveling direction of a ray\n\nThe next sections show how we can do this.\n\n## Find the intersection between ray and the object\n\nIn geometry, a general way to find the intersections between a ray and a object is to parametrize them. Namely, we can express the vector of the light ray as $\\mathbf{r}(t)=(x(t),y(t),z(t))$ and the equation of the surface as $S(x,y,z)=0$. \nFind a $t$ such that $S(x(t),y(t),z(t))=0$ and $x(t),y(t)$ and $z(t)$ are within the boundary. Let\u2019s say the solution is $t'$, $x(t'),y(t')$ and $z(t')$ are then the intersecton point between the ray and the surface.\n\n$x(t)$, $y(t)$ and $z(t)$ are directional cosines. Geometrical optics often favors the following convention \n$$\n\\mathbf{r}(t) = (x_0+\\sin(\\phi)t, y_0+\\sin(\\theta)cos(\\phi)t ,z_0+\\cos(\\theta)cos(\\phi)t)\n$$ \nThe starting points of the rays $x_0$, $y_0$, $z_0$ and the initial directional angles $theta$ and $phi$ are set by the users as the initial conditions of the rays. These parameters are constant until the ray is reflected or refracted. We can think of $t$ as the \u201ctime of flight\u201d of the ray. The intersection point $t'$ can be thought of as the time that the ray and the surface intersected.\nFor two-dimensional simulation, we just set $\\phi=0$ and work on $y-z$ plane only.\n\n<img src=\"https:\/\/kanhua.github.io\/images\/ray_tracing_illustration.svg\" alt=\"Drawing\" style=\"width: 400px;\"\/>\n\n## Calculate the new traveling direction of a ray\n\n### Calculate the normal vector\n\nThe normal vector is the normal vector of the tangent vector on the surface $(x,y(x))$. Numerically, the tangent vector of this surface at $(x,y)$ is the first order derivative: $d\\mathbf{s}=(dx,dy)=dx(1,\\frac{dy}{dx})=dx(1,y'(x))$. In the case of 2D, the normal vector is $\\mathbf{n}=(dy,-dx)$.\n\n### General form of Snell\u2019s law\n\nFrom high school physics we know that we can calculate the ray defraction by using Snell\u2019s law: \n\n\\begin{equation}\nn_r'\\sin\\theta'=n_r \\sin \\theta ~~~~~(1)\n\\end{equation}\n \nThe above equation only describes the relation between the incident angle and refracted angle. \nTo deal with ray vectors incident on an artitrary surface in higher dimenional space, \nwe need a more general expression of Snell\u2019s law: \n$$\nn_r'\\mathbf{r}'\\times \\mathbf{n}=n_r \\mathbf{r}\\times \\mathbf{n}\n$$ \nwhere $\\mathbf{n}$ is the normal vector of the surface at the point of refraction, $n_r$ and $n_r'$ are the refractive index of the mediums, $\\mathbf{r}$ and $\\mathbf{r'}$ are the ray vectors before and after the refraction, respectively. $\\times$ is the vector cross product. Note that all the vector shown above are noramlzed unit vectors. The above equation can be rearranged to obtain a more useful expression for calculating the refracted vector $\\mathbf{r}'$: \n    \n$$\nn_r'\\mathbf{r}'=n_r\\mathbf{r}+(n'\\mathbf{r}'\\cdot\\mathbf{n}-n\\mathbf{r}\\cdot\\mathbf{n})\\mathbf{n}~~~~(2)\n$$\nand $\\mathbf{r}'\\cdot\\mathbf{n}$ at the right-hand side can be calculated by using Equation (1)\n$$\n\\begin{split}\n    \\mathbf{r}'\\cdot\\mathbf{n}&=\\cos\\theta' \\\n                              &=\\sqrt{1-\\sin^2\\theta'} \\\n                              &=\\sqrt{1-\\left(\\frac{n_r}{n_r'}\\sin\\theta\\right)^2}\n\\end{split}\n$$ \nSubstuting the known $\\mathbf{r}$, $\\mathbf{n}$, $n_r$, $n_r'$ and $\\mathbf{r}'\\cdot\\mathbf{n}$ into Equation (2), we can obtain the refracted vector $\\mathbf{r'}$.\n\n\n### References\n\n[1] Roland Winston, Juan C. Minano and Pablo Benitez, Nonimaging Optics. Academic Press, 2005.","11d6a013":"# Ray-tracing algorithm","db30ad4e":"### Implmentation of ```Ray``` object","a69d65b2":"$z'(y)$ as c\/c++ code","065b4be2":"Expression in c\/c++","6d051019":"## Implementation of ray tracing with Python\nWith the equations above, we can run run the ray-tracing algoritms\nWe use two class ```Ray``` and ```AsphericSurface``` as the main data structure.\n\n- A ```Ray``` object stores the vector of an ray $z(t)=z_0+\\cos\\theta t$ and $y(t)=y_0+\\sin\\theta t$. When a intersection of a ray and an interface occured, the values of $z_0$, $y_0$ and $t$ are updated. \n- An ```AsphericSurface``` object stores the parameters of a surface, calculate the intersection, update the ray vector using Snell's law ","5605e73d":"## Online version of this tutorial\nA online version of this tutorial: [Jupyter Notebook run by Kaggle Kernel](https:\/\/www.kaggle.com\/photunix\/ray-tracing-in-python).","19b62eea":"### Define a couple of surfaces","c4d87aec":"#### Calculate the parametrized lens equation\n\nThe surface equation is $z=z(y)$, which can be rearranged as $f(y,z)=z(y)-z$\n\nWe substitute the parameterized ray vectors into the lens equation $f(y,z)$:\n$$\nz(t)=z_0+\\cos\\theta t \\\\\ny(t)=y_0+\\cos\\theta t$$\n\nWe will then have a new parametrized function $g(t)=f(y(t),z(t))$.\nTo calculate the intersection between a ray and a surface, we just need to solve $g(t)=0$. Some numerical solver such as Newton-Raphson would need the first derivative $g'(t)$ as well. \nWe will calculate them as well.","e38fb105":"Get latex expression","8d9d5a98":"### Run the ray-tracing of two surfaces","6b0db55b":"## Aspherical lenses\nIn this tutorial, we use a [aspherical lenses](https:\/\/en.wikipedia.org\/wiki\/Aspheric_lens) as an example, but this algorithm should work with any type of surfaces."}}