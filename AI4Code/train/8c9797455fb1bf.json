{"cell_type":{"654c587a":"code","7b32ede5":"code","60a7966f":"code","052c148b":"code","bfc102ea":"code","9ead3afb":"code","d8d0c1f3":"code","996ff397":"code","383b48c4":"code","fb233151":"code","fe9d81a1":"code","2287e454":"code","66c35b43":"code","db0ae274":"code","20952664":"code","0788565a":"code","b03e28ad":"code","8a0e2832":"code","22b6808e":"code","4fae86f9":"code","1858ee4d":"code","4e353961":"code","7559885a":"code","32f5d8a3":"code","298c3c47":"code","e59650a9":"code","503937dc":"code","ab388767":"code","114341b3":"code","f0e2f579":"code","d87f36af":"code","a70b3c85":"code","8ec23ff8":"code","521f582a":"code","5f825dd9":"code","77f23e94":"code","ecf88719":"code","526722aa":"code","b1c17f7c":"code","4426b911":"code","65f21f2b":"code","b781dc1a":"code","69e1fb05":"code","d3d1ff1c":"code","909edb63":"code","ca5d20e9":"code","3ee15646":"code","f2bacee4":"code","46ae958c":"code","06e13ad4":"code","2976e2a8":"code","2b94b397":"code","62313a7f":"code","47b9b7ce":"code","1b5606ca":"code","05701861":"code","8c0d7d20":"code","20948170":"code","92522637":"code","85ba60c0":"code","51b09bd7":"code","94fad564":"code","bc7ecfb1":"code","b77e0776":"code","08f9ce52":"code","cf38c18c":"code","4b48ef98":"code","e128c683":"code","ad520a39":"code","4e260e13":"code","0559a8a3":"code","87a637b4":"code","1ae8256c":"code","b547c910":"code","49a6cde4":"code","a6da9dba":"code","d80c55f1":"code","9f65d758":"code","47617af3":"code","659b34ec":"code","9f33cc6e":"code","77d809d5":"code","b34be2e4":"code","4df8adfc":"code","8ded5423":"code","11b7ff99":"code","aea34926":"code","c7fc508f":"code","3dd6d785":"code","eaac7f20":"code","f4515352":"code","4298eb57":"code","b917fe5f":"code","7406e38c":"code","89eee17f":"code","e326dc2a":"code","85c8f010":"code","334fb235":"code","1eba7b87":"code","c681faa9":"code","b1d50d35":"code","49211e43":"code","f494644c":"code","bf202219":"code","3a1fc768":"code","0a3f14d5":"markdown","adf1a074":"markdown","02077941":"markdown","853e935a":"markdown"},"source":{"654c587a":"import seaborn as sns\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline","7b32ede5":"df= pd.read_csv('..\/input\/Pokemon.csv',encoding='unicode_escape')","60a7966f":"df.head()","052c148b":"df.describe()","bfc102ea":"## lmplot is used to plot Scatter Plot but it isn't purely a scatter plot .\nsns.lmplot(x='Attack',y='Defense',data=df)","9ead3afb":"## To make it look better we remove regression line and colors by evolution_stage\nsns.lmplot(x='Attack',y='Defense',data=df,fit_reg=True,hue='Stage')","d8d0c1f3":"plt.figure(figsize=(10,5))\nsns.boxplot(data=df)","996ff397":"plt.figure(figsize=(10,5))\nsns.boxplot(data=df[df.var().head().index])","383b48c4":"## To remove unnecessary column's that are appearing in boxplot\nnew_df=df.drop(['Total','Stage','Legendary'],axis=1)\nsns.boxplot(data=new_df)","fb233151":"## ViolinPlot are similar to box plot but are easy to understand \n## To define custom colors we can create a list and pass as an palette\n## by default color is darkgrid in Violin Plot so making it whitegrid\nsns.set_style('whitegrid')\npkmn_type_colors = ['#78C850',  # Grass\n                    '#F08030',  # Fire\n                    '#6890F0',  # Water\n                    '#A8B820',  # Bug\n                    '#A8A878',  # Normal\n                    '#A040A0',  # Poison\n                    '#F8D030',  # Electric\n                    '#E0C068',  # Ground\n                    '#EE99AC',  # Fairy\n                    '#C03028',  # Fighting\n                    '#F85888',  # Psychic\n                    '#B8A038',  # Rock\n                    '#705898',  # Ghost\n                    '#98D8D8',  # Ice\n                    '#7038F8',  # Dragon\n                   ]","fe9d81a1":"## Using matplotlib pyplot we can increase the size of figure\nfig,ax=plt.subplots()\nfig.set_size_inches(30,10)\nsns.violinplot(x='Type 1',y='Attack',data=df,ax=ax,palette=pkmn_type_colors)","2287e454":"## Swarm Plot\nfig,ax=plt.subplots()\nfig.set_size_inches(17.7,9.27)\nsns.swarmplot(x='Type 1',y='Attack',data=df,palette=pkmn_type_colors,ax=ax)","66c35b43":"fig,ax=plt.subplots()\nfig.set_size_inches(17.7,9.27)\nsns.violinplot(x='Type 1',y='Attack',data=df,inner=None,##inner is used to remove bars inside violinplot\n               palette=pkmn_type_colors)\n\nsns.swarmplot(x='Type 1',\n             y='Attack',\n             data=df,\n             color='k',## to make color black of dots\n             alpha=0.8)## to make transparent\nplt.title('Attack by Pokemon Type')","db0ae274":"## Combining many columns into one\nmelted_df=pd.melt(new_df,id_vars=['Name','Type 1','Type 2'],var_name='Ability')","20952664":"melted_df.head()","0788565a":"fig,ax=plt.subplots()\nfig.set_size_inches(12,7)\nsns.swarmplot(x='Ability',y='value',data=melted_df,hue='Type 1')","b03e28ad":"## Making it look more understandable\nfig,ax=plt.subplots()\nfig.set_size_inches(14,7)\nsns.swarmplot(x='Ability',y='value',data=melted_df,hue='Type 1',palette=pkmn_type_colors)\nplt.ylim(0,250)\nplt.legend(bbox_to_anchor=(1, 1), loc=2) ## To place legend box outside the plot","8a0e2832":"sns.distplot(df.Defense)","22b6808e":"plt.figure(figsize=(10,7))\nsns.countplot(x='Type 1',data=df,palette=pkmn_type_colors)\nplt.xticks(rotation=-45)","4fae86f9":"#factorplot name changed to catplot\nmy_plot=sns.catplot(x='Type 1',y='Defense',data=df,hue='Stage',col='Stage',palette=pkmn_type_colors,kind='swarm')\nmy_plot.set_xticklabels(rotation=-45)","1858ee4d":"plt.figure(figsize=(8,4))\nsns.lmplot(x='Attack',y='Speed',data=df,fit_reg=False,hue='Stage')\nsns.kdeplot(df.Attack,df.Speed,alpha=0.8)\nplt.ylim(0,160)\nplt.xlim(0,170) # Used to limit x and y co-ordinates","4e353961":"import matplotlib as mpl","7559885a":"# simple function to plot some offset sine waves\ndef sinplot(flip=1):\n    x=np.linspace(0,14,100)\n    for i in range(1,7):\n        plt.plot(x,np.sin(x+i*0.5)*(7-i)*flip)\n\ndata = np.random.normal(size=(20, 6)) + np.arange(6) \/ 2","32f5d8a3":"sinplot()\n# plot with matplotlib default","298c3c47":"sns.set()\n# to switch to seaborn defaults","e59650a9":"sinplot()\n# plot with seaborn set","503937dc":"# Seaborn splits matplotlib parameters into two independent groups.\n# The first group sets the aesthetic style of the plot, and the \n# second scales various elements of the figure so that it can be\n# easily incorporated into different contexts.\n\n# The interface for manipulating these parameters are two pairs of\n# functions. To control the style, use the axes_style() and \n# set_style() functions. To scale the plot, use the plotting_context() and set_context() functions. In both cases, the first function \n# returns a dictionary of parameters and the second sets the \n# matplotlib defaults.","ab388767":"# There are five preset seaborn themes: darkgrid, whitegrid, \n#  dark, white, and ticks\nsns.set_style('dark')\nsinplot()","114341b3":"sns.set_style('white')\nsinplot()","f0e2f579":"sns.set_style('darkgrid')\nsinplot()","d87f36af":"sns.set_style('whitegrid')\nsinplot()","a70b3c85":"sns.set_style('ticks')\nsinplot()","8ec23ff8":"# Removing axis spines\nsinplot()\nsns.despine()","521f582a":"fig,ax=plt.subplots()\nsns.violinplot(data=data)\nsns.despine(offset=10,trim=True)\n# when ticks don't cover the whole range of the axis,the trim\n# parameter will limit the range of the surviving spines","5f825dd9":"# you can also control which spines are to remove with additional\n# arguments\nsns.set_style('darkgrid')\nfig,ax=plt.subplots()\nsns.violinplot(data=data)\nsns.despine(left=True)","77f23e94":"# temporarily setting figure style\nwith sns.axes_style('dark'):\n    sinplot()   ","ecf88719":"sinplot()","526722aa":"# # Overriding elements of the seaborns style\n# if you want to customize the seaborn styles , you can pass a \n# dictionary of parameters to the rc argument of axes_style() and \n# set_style().Note that you can only override the parameters that are\n# part of the style definition through this method.(However the \n# higher level set() function takes a dictionary of any\n# matplotlib parameters)\n# If you want to see what parameters are included, you can just \n# call the function with no arguments,which will return the \n# current settings\nsns.axes_style()","b1c17f7c":"sns.set_style('dark',{'axes.facecolor':'0.9'})\nsinplot()","4426b911":"sns.axes_style()","65f21f2b":"# Scaling Plot Elements\n# A separate set of parameters control the scale of plot elements,\n# which should let you use the same code to make plots that are \n# suited for use in settings where larger or smaller plots are\n# appropriate.\n\n# First let\u2019s reset the default parameters by calling set():\nsns.set()","b781dc1a":"# The four preset contexts, in order of relative size, are paper, \n# notebook, talk, and poster. The notebook style is the default, \n# and was used in the plots above.\nsns.set_context('paper')\nsinplot()","69e1fb05":"sns.set_context('talk')\nsinplot()","d3d1ff1c":"sns.set_context('poster')\nsinplot()","909edb63":"sns.plotting_context()","ca5d20e9":"sns.set_context('notebook',rc={'lines.linewidth':'2.5'})\nsinplot()","3ee15646":"sns.plotting_context()","f2bacee4":"# CHOOSING COLOR PALETTES\n# The most important function for working with discrete \n# color palettes is color_palette(). This function provides an \n# interface to many (though not all) of the possible ways you can\n# generate colors in seaborn, and it\u2019s used internally by any function \n# that has a palette argument (and in some cases for a color\n# argument when multiple colors are needed).\n# color_palette() will accept the name of any seaborn palette or \n# matplotlib colormap (except jet, which you should never use).\n# It can also take a list of colors specified in any valid matplotlib \n# format (RGB tuples, hex color codes, or HTML color names). The \n# return value is always a list of RGB tuples.\n\n# Finally, calling color_palette() with no arguments will return the\n# current default color cycle.\n\n# A corresponding function, set_palette(), takes the same arguments\n# and will set the default color cycle for all plots. You can also\n# use color_palette() in a with statement to temporarily change the\n# default palette (see below).\n\n# It is generally not possible to know what kind of color palette or\n# colormap is best for a set of data without knowing about the\n# characteristics of the data. Following that, we\u2019ll break up \n# the different ways to use color_palette() and other seaborn\n# palette functions by the three general kinds of color palettes:\n\n# **************qualitative, sequential, and diverging***********\n\n# sns.color_palette()\n","46ae958c":"sns.choose_colorbrewer_palette('diverging')\n","06e13ad4":"# plotting univariate distribution\n# The most convenient way to take a quick look at a univariate \n# distribution in seaborn is the distplot() function.By default\n# this will draw a histogram and fit a kernel density estimate\nx=np.random.normal(size=100)\nsns.set()\nsns.distplot(x)","2976e2a8":"# histogram\n# histograms are likely familiar and a hist function already exists\n# in matplotlib.A histogram represents the distribution of data by \n# forming bins along the range of the data nd then drawing bars to \n# show the number of observations that fall in each bin\n# To illustrate this ,let's remove the desinty curve and add a rug\n# plot,which draws a small vertical tick t each observation.You can \n# make the rug plot itself with the rugplot function but it is also \n# available in distplot()\nsns.distplot(x,kde=False,rug=True)","2b94b397":"# when drawing histograms the main choice you have is the number of\n# bins to use and where to place them.Distplot() uses a simple rule\n# to make good guess for what the right number is the default,but\n# trying more or fewer bins might reveal other features in the data\nsns.distplot(x,bins=20,rug=True,kde=False)","62313a7f":"# KERNEL DENSITY ESTIMATION\n# the kernel density estimate may be less familiar but it can be a\n# useful tool for plotting the shape of a distribution.Like the\n# hsitogram,the KDE plots encodes the density of observations on one\n# axis with height along the other axis:\nsns.distplot(x,hist=False,rug=True)","47b9b7ce":"sns.kdeplot(x,shade=True)\nsns.rugplot(x)","1b5606ca":"# the bandwidth parameter of the KDE controls how tightly the \n# estiamtion is to fit to the data,much like the bin size in a \n# histogram.It corresponds to the width of the kernels.The default\n# behaviour tries to guess a good vlue using a common reference rule\n# ,but it my be helpful to try larger or smaller values\nsns.kdeplot(x)\nsns.kdeplot(x,bw=2,label='bw:2')\nsns.kdeplot(x,bw=0.2,label='bw:0.2')","05701861":"# Fitting parametric distributions\n# you can also use the distplot() to fit a parametric distribution\n# to a dataset and visually evaluate how closely it corresponds to\n# the observed data:\nx=np.random.gamma(6,size=200)\nfrom scipy import stats\nsns.distplot(x,kde=False,fit=stats.gamma)","8c0d7d20":"# Plotting Bivariate distributions\n# The easiest way to do this in seaborn is to just use the joinplot()\n# function,which creates a multi-panel figure that shows both the \n# bivariate(or joint) relationship between two variables along \n# with the univariate (or marginal) distributiob of each on separate\n# axis\nmean,cov=[0,1],[(1,0.5),(0.5,1)]\ndata=np.random.multivariate_normal(mean,cov,200)\ndf=pd.DataFrame(data,columns=['x','y'])\nprint(df)","20948170":"# Scatterplots\n# the most familiar way to visualize a bivariate distribution is\n# a scatterlpot,where each observation is shown with point at the \n# x and y values.This is analogous to rugplot on two dimesnions\n# .You can draw a Scatterplot with the matplotlib plt.scatter,and\n# it is also the default kind of plot shown by the jointplot()\n# function:\nsns.jointplot(x='x',y='y',data=df)","92522637":"# Hesxbin plots\n# the bivariate analogue of a histogram is known as a hexbin plot \n# because it shows the count of observations that fall within \n# hexagonal bins.this plot works best with relatively large datasets.\n# it's availble through the matplotlib plt.hexbin() function and as\n# a style in jointplot.it looks best with a white background\nx,y=np.random.multivariate_normal(mean,cov,1000).T\nwith sns.axes_style('white'):\n    sns.jointplot(x=x,y=y,kind='hex',color='k')","85ba60c0":"# kernel density estimation\n# it is also possible to use the kernel density estimation procedure\n# described above to visualoze a bivariate distribution.In seaborn,\n# this kind of plot is shown with a contour plot and is available\n# as a style in jointplot()\nsns.jointplot(x=x,y=y,kind='kde')","51b09bd7":"# you can also draw a 2d kernel density plot with the kdeplot()\n# function.This allows you to draw this kind of plot onto a specific\n# matplotlib axes,whereas the joint plot() function manages it's own\n# figure\nf,ax=plt.subplots()\nsns.kdeplot(df['x'],df['y'],ax=ax)\nsns.rugplot(df['x'],color='g',ax=ax)\nsns.rugplot(df['y'],color='b',ax=ax,vertical=True)","94fad564":"# if you wish to show the bivariate density more continously,you can\n# simply increase the number of contour levels:\ncmap = sns.cubehelix_palette(as_cmap=True, dark=0, light=1,\nreverse=True)\n\nsns.kdeplot(df['x'],df['y'],n_levels=60,shade=True,cmap=cmap)","bc7ecfb1":"# the jointplot function uses a jointgrid to manage the figure.For\n# more flexibility,you my want to draw your figure by using JointGrid\n# directly.Jointplot() return the JointGrid object after plotting\n# which you can use to add more layers or to tweak other aspects of\n# the visualization\ng=sns.jointplot(x='x',y='x',data=df,kind='kde',color='b')\ng.plot_joint(plt.scatter,c='w',s=30,linewidth=1,marker='+')\ng.ax_joint.collections[0].set_alpha(0)\ng.set_axis_labels('$x$','$y$')","b77e0776":"# visualising pairwise relationships in a dataset\n# To plot multiple pairwise bivariate distributions in a dataset,you\n# can use the pirplot() function.This creates a matrix of axes\n# and shows the relationship for each pair of columns in a DataFrame\n# By default,it also draws the univariate distribution of each\n# variable on the diagonal axes\niris=sns.load_dataset('iris')\nsns.pairplot(iris)","08f9ce52":"# Much like the relationship between jointplot() and JointGrid , \n# the pairplot() function is built on top of a PairGrid object,which\n# can be used directly for more flexibility:\ng=sns.pairplot(iris)\ng.map_diag(sns.kdeplot)\ng.map_offdiag(sns.kdeplot,cmap='Blues_d',n_levels=6)","cf38c18c":"# **************** Plotting with categorical data ***************\n\n# It\u2019s useful to divide seaborn\u2019s categorical plots into three groups:\n# those that show each observation at each level of the categorical \n# variable, those that show an abstract representation of each\n# distribution of observations, and those that apply a statistical \n# estimation to show a measure of central tendency and confidence\n# interval. The first includes the functions swarmplot() and \n# stripplot(), the second includes boxplot() and violinplot(), and \n# the third includes barplot() and pointplot(). These functions all \n# share a basic API for how they accept data, although each has\n# specific parameters that control the particulars of the\n# visualization that is applied to that data.\n\n# Much like the relationship between regplot() and lmplot(), in\n# seaborn there are both relatively low-level and relatively \n# high-level approaches for making categorical plots. The functions\n# named above are all low-level in that they plot onto a specific\n# matplotlib axes. There is also the higher-level factorplot(),\n# which combines these functions with a FacetGrid to apply a \n# categorical plot across a grid of figure panels\n\nsns.set(style='whitegrid',color_codes=True)","4b48ef98":"titanic=sns.load_dataset('titanic')\ntips=sns.load_dataset('tips')\niris=sns.load_dataset('iris')","e128c683":"# Categorical scatterplots\n# a simple way to show the values of some quantitative variable \n# across the levels of a categorical variable uses stripplot(),which\n# generalizes a scatterplot to the case where one of the variables\n# is categorical\nsns.stripplot(x='day',y='total_bill',data=tips)","ad520a39":"# in a strip plot the scatterplot points will usually overlap.this \n# makes it difficult to see the full distribution of data.One easy\n# solution is to adjust the positions (only along the categorical\n# axis) using some random jitter\nsns.stripplot(x='day',y='total_bill',data=tips,jitter=True)","4e260e13":"# a different approach would be to use the function swarmplot(),which\n# positions each scatterplot point on the categorical axis with\n# an algorithm that avoids overlapping points\nsns.swarmplot(x='day',y='total_bill',data=tips)","0559a8a3":"# It's also possible to add a nested categorical variable with the \n# hue parameter.Above the color and position on the categorical \n# axis are redundant,but now each provides info about one of the \n# two variables\nsns.swarmplot(x='day',y='total_bill',hue='sex',data=tips)","87a637b4":"# In general, the seaborn categorical plotting functions try to \n# infer the order of categories from the data. If your data have a \n# pandas Categorical datatype, then the default order of the \n# categories can be set there. For other datatypes, string-typed \n# categories will be plotted in the order they appear in the \n# DataFrame, but categories that look numerical will be sorted:\nsns.swarmplot(x='size',y='total_bill',data=tips)","1ae8256c":"# With these plots, it\u2019s often helpful to put the categorical variable\n# on the vertical axis (this is particularly useful when the category\n# names are relatively long or there are many categories). You can \n# force an orientation using the orient keyword, but usually plot \n# orientation can be inferred from the datatypes of the variables \n# passed to x and\/or y:\nsns.swarmplot(x='total_bill',y='day',hue='sex',data=tips)","b547c910":"# ***** Distribution of observations within categories ******\n# Boxplots\n\n# This kind of plot shows the three quartile values of the \n# distribution along with extreme values. The \u201cwhiskers\u201d extend to \n# points that lie within 1.5 IQRs of the lower and upper quartile,\n# and then observations that fall outside this range are displayed \n# independently. Importantly, this means that each value in the \n# boxplot corresponds to an actual observation in the data:\n\nsns.boxplot(x='day',y='total_bill',data=tips)","49a6cde4":"# For boxplots, the assumption when using a hue variable is that it \n# is nested within the x or y variable. This means that by default,\n# the boxes for different levels of hue will be offset, as you can see\n# above. If your hue variable is not nested, you can set the dodge\n# parameter to disable offsetting:\n\nsns.boxplot(x='day',y='total_bill',hue='time',data=tips)","a6da9dba":"tips['weekend']=tips['day'].isin(['Sat','Sun'])\nsns.boxplot(x='day',y='total_bill',hue='weekend',data=tips,\ndodge=False)","d80c55f1":"# ViolinPlots\n# A different approach is a violinplot(),which combines a boxplot \n# with the kernel density estimation procedure\n\nsns.violinplot(x='total_bill',y='day',data=tips,hue='time')","9f65d758":"# This approach uses the kernel density estimate to provide a better \n# description of the distribution of values. Additionally,\n# the quartile and whikser values from the boxplot are shown inside \n# the violin. Because the violinplot uses a KDE, there are some other \n# parameters that may need tweaking, adding some complexity relative \n# to the straightforward boxplot:\n\nsns.violinplot(x='total_bill',y='day',hue='time',data=tips,\nbw=0.1,scale='count',scale_hue=False)\n\n","47617af3":"# It\u2019s also possible to \u201csplit\u201d the violins when the hue parameter \n# has only two levels, which can allow for a more efficient use of \n# space:\nsns.violinplot(x='day',y='total_bill',hue='sex',data=tips,split=True)\n\n","659b34ec":"# Finally, there are several options for the plot that is drawn on \n# the interior of the violins, including ways to show each individual \n# observation instead of the summary boxplot values:\n\nsns.violinplot(x='day',y='total_bill',hue='sex',data=tips,\nsplit=True,inner='stick',palette='Set2')","9f33cc6e":"# It can also be useful to combine stripplot() or swarmplot() \n# with violinplot() or boxplot() to show each observation along \n# with a summary of the distribution:\n\nsns.violinplot(x='day',y='total_bill',data=tips)\nsns.swarmplot(x='day',y='total_bill',data=tips,color='w',alpha=0.5)","77d809d5":"# *********** Statistical Estimation Within Categories ***********\n\n# Often, rather than showing the distribution within each category,\n# you might want to show the central tendency of the values.\n\n# BAR PLOT:\n# In seaborn,the braplot() function operates on a full dataset and \n# shows an arbitrary estimate,using the mean by default.When there\n# are multiple obersvations in each category,it also uses\n# bootstrapping to compute a confidence interval around the estimate\n# and plots that using error bars\n\nsns.barplot(x='sex',y='survived',data=titanic)","b34be2e4":"sns.barplot(x='sex',y='survived',hue='class',data=titanic)","4df8adfc":"# A special case for the bar plot is when you want to show the number \n# of observations in each category rather than computing a statistic \n# for a second variable. This is similar to a histogram over a \n# categorical, rather than quantitative, variable. In seaborn, it\u2019s \n# easy to do so with the countplot() function:\n\nsns.countplot(x='deck',data=titanic)","8ded5423":"sns.countplot(x='deck',hue='class',data=titanic)","11b7ff99":"# POINT PLOTS:\n\n# An alternative style for visualizing the same information is \n# offered by the pointplot() function. This function also encodes\n# the value of the estimate with height on the other axis, but rather \n# than show a full bar it just plots the point estimate and confidence\n# interval. Additionally, pointplot connects points from the same hue \n# category. This makes it easy to see how the main relationship is \n# changing as a function of a second variable, because your eyes are\n# quite good at picking up on differences of slopes:\n\nsns.pointplot(x='sex',y='survived',data=titanic)","aea34926":"sns.pointplot(x='sex',y='survived',hue='class',data=titanic)","c7fc508f":"# To make figures that reproduce well in black and white, it can be \n# good to use different markers and line styles for the levels of \n# the hue category:\n\nsns.pointplot(x='class',y='survived',hue='sex',data=titanic,\npalette={'male':'g','female':'m'},markers=['o','^'],\nlinestyles=['--','-'])","3dd6d785":"# PLOTTING \" WIDE-FORM \" DATA\n\n# While using \u201clong-form\u201d or \u201ctidy\u201d data is preferred, these \n# functions can also by applied to \u201cwide-form\u201d data in a variety of\n# formats, including pandas DataFrames or two-dimensional numpy \n# arrays. These objects should be passed directly to the data \n# parameter:\n\nsns.boxplot(data=iris)\n","eaac7f20":"# Additionally, these functions accept vectors of Pandas or\n# numpy objects rather than variables in a DataFrame:\n\nsns.violinplot(x='species',y='sepal_length',data=iris)\n","f4515352":"# Drawing multi-panel categorical plots\n# As we mentioned above, there are two ways to draw categorical plots\n# in seaborn. Similar to the duality in the regression plots, you can\n# either use the functions introduced above, or the higher-level \n# function factorplot(), which combines these functions with a \n# FacetGrid() to add the ability to examine additional categories \n# through the larger structure of the figure. By default, \n# factorplot() produces a pointplot():\n\nsns.factorplot(x='day',y='total_bill',data=tips)","4298eb57":"sns.factorplot(x='day',y='total_bill',hue='smoker',data=tips)","b917fe5f":"# However, the kind parameter lets you chose any of the kinds of \n# plots discussed above:\n\nsns.factorplot(x='day',y='total_bill',data=tips,kind='bar',\n               hue='smoker')\n","7406e38c":"# The main advantage of using a factorplot() is that it is very easy\n# to \u201cfacet\u201d the plot and investigate the role of other categorical \n# variables:\n\nsns.factorplot(x='day',y='total_bill',hue='smoker',data=tips,\n              kind='swarm',col='time')","89eee17f":"# Any kind of plot can be drawn. Because of the way FacetGrid works,\n# to change the size and shape of the figure you need to specify \n# the size and aspect arguments, which apply to each facet:\n\nsns.factorplot(x='time',y='total_bill',hue='smoker',col='day',\n               data=tips,kind='box',size=4,aspect=0.5)","e326dc2a":"# It is important to note that you could also make this plot by\n# using boxplot() and FacetGrid directly. However, special care must\n# be taken to ensure that the order of the categorical variables is \n# enforced in each facet, either by using data with a Categorical \n# datatype or by passing order and hue_order.\n\n# Because of the generalized API of the categorical plots, they \n# should be easy to apply to other more complex contexts. For\n# example, they are easily combined with a PairGrid to show \n# categorical relationships across several different variables:\n\ng=sns.PairGrid(tips,x_vars=['smoker','time','sex'],\n              y_vars=['total_bill','tip'],aspect=0.75,size=3.5)\ng.map(sns.violinplot,palette='pastel')","85c8f010":"# # VISUALIZING LINEAR RELATIONSHIPS\n# the regression plots in seaborn are primarily intended to add a \n# visual guide that helps to emphasize patterns in a dataset during \n# exploratory data analyses. That is to say that seaborn is not itself\n# a package for statistical analysis. To obtain quantitative measures \n# related to the fit of regression models, you should use statsmodels.\n# The goal of seaborn, however, is to make exploring a dataset through\n# visualization quick and easy, as doing so is just as (if not more)\n# important than exploring a dataset through tables of statistics.\n\n# FUNCTIONS TO DRAW LINEAR REGRESSION MODELS\n# Two main functions in seaborn are used to visualize a linear \n# relationship as determined through regression. These functions, \n# regplot() and lmplot() are closely related, and share much of their \n# core functionality. It is important to understand the ways they\n# differ, however, so that you can quickly choose the correct tool \n# for particular job.\n\n# In the simplest invocation, both functions draw a scatterplot of \n# two variables, x and y, and then fit the regression model y ~ x \n# and plot the resulting regression line and a 95% confidence \n# interval for that regression:\n\nsns.regplot(x='total_bill',y='tip',data=tips)","334fb235":"sns.lmplot(x='total_bill',y='tip',data=tips)\n\n# You should note that the resulting plots are identical,\n# except that the figure shapes are different. We will explain\n# why this is shortly. For now, the other main difference to know\n# about is that regplot() accepts the x and y variables in a variety \n# of formats including simple numpy arrays, pandas Series objects,\n# or as references to variables in a pandas DataFrame object passed \n# to data. In contrast, lmplot() has data as a required parameter and \n# the x and y variables must be specified as strings. This data \n# format is called \u201clong-form\u201d or \u201ctidy\u201d data. Other than this input\n# flexibility, regplot() possesses a subset of lmplot()\u2018s features,\n# so we will demonstrate them using the latter.\n\n# It\u2019s possible to fit a linear regression when one of the variables\n# takes discrete values, however, the simple scatterplot produced by \n# this kind of dataset is often not optimal","1eba7b87":"sns.lmplot(x='size',y='tip',data=tips)","c681faa9":"# One option is to add some random noise (\u201cjitter\u201d) to the discrete\n# values to make the distribution of those values more clear. Note \n# that jitter is applied only to the scatterplot data and does not \n# influence the regression line fit itself:\n\nsns.lmplot(x='size',y='tip',data=tips,x_jitter=0.1)","b1d50d35":"# A second option is to collapse over the observations in each\n# discrete bin to plot an estimate of central tendency along with\n# a confidence interval:\n\nsns.lmplot(x='size',y='tip',data=tips,x_estimator=np.mean)","49211e43":"# CONDITIONING ON OTHER VARIABLES\n# The plots above show many ways to explore the relationship between\n# a pair of variables. Often, however, a more interesting question\n# is \u201chow does the relationship between these two variables change\n# as a function of a third variable?\u201d This is where the difference\n# between regplot() and lmplot() appears. While regplot() always\n# shows a single relationship, lmplot() combines regplot() with \n# FacetGrid to provide an easy interface to show a linear regression \n# on \u201cfaceted\u201d plots that allow you to explore interactions with up\n# to three additional categorical variables.\n\n# The best way to separate out a relationship is to plot both levels\n# on the same axes and to use color to distinguish them:\n\nsns.set(color_codes=True)\nsns.lmplot(x='total_bill',y='tip',hue='smoker',data=tips)","f494644c":"# In addition to color, it\u2019s possible to use different scatterplot\n# markers to make plots the reproduce to black and white better.\n# You also have full control over the colors used:\n\nsns.lmplot(x='total_bill',y='tip',hue='smoker',markers=['o','x'],\n          palette='Set1',data=tips)","bf202219":"# To add another variable, you can draw multiple \u201cfacets\u201d which \n# each level of the variable appearing in the rows or columns of the\n# grid:\n\nsns.lmplot(x='total_bill',y='tip',hue='smoker',col='time',data=tips)","3a1fc768":"sns.lmplot(x='total_bill',y='tip',hue='smoker',col='time',row='sex',\n          data=tips)","0a3f14d5":"# PART-2 PLOTTING FUNCTIONS\n## VISUALIZING THE DISTRIBUTION OF A DATASET","adf1a074":"# Seaborn Figure Styles","02077941":"# operation on iris dataset","853e935a":"# Style Management:\n## part-1 controlling figure aesthetics"}}