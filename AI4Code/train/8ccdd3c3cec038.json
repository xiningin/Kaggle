{"cell_type":{"06d22afb":"code","e6b0d1b7":"code","77fab7a7":"code","1be71d30":"code","859c40ee":"code","082fe486":"code","663afaa2":"code","b046fd07":"code","5b9cce9e":"code","6da06ceb":"code","4a9a800b":"code","3fe84971":"markdown","1a057233":"markdown","1cb96f69":"markdown","63ec6bfc":"markdown","de871055":"markdown"},"source":{"06d22afb":"from pandas import read_csv, DataFrame, to_datetime\nfrom numpy import radians, sin, cos, arcsin, sqrt, mean\nfrom sklearn import ensemble\nimport time\nfrom datetime import datetime\nimport xgboost as xgb\n\n","e6b0d1b7":"train_data = read_csv(\"..\/input\/train.csv\")\ntest = read_csv(\"..\/input\/test.csv\")\nsample_sub = read_csv(\"..\/input\/sample_submission.csv\")","77fab7a7":"# Since the training file is very large, I only use the first 1 million records\ntrain = train_data[:1000000]","1be71d30":"# Then we take all the values between the minimum and the maximum for each column\n\npickup_longitude_min = test.pickup_longitude.min()\npickup_longitude_max = test.pickup_latitude.max()\npickup_latitude_min = test.pickup_latitude.min()\npickup_latitude_max = test.pickup_latitude.max()\ndropoff_longitude_min = test.dropoff_longitude.min()\ndropoff_longitude_max = test.dropoff_longitude.max()\ndropoff_latitude_min = test.dropoff_latitude.min()\ndropoff_latitude_max = test.dropoff_latitude.max()\n\ntrain = train.loc[(train['fare_amount'] > 0) & (train['fare_amount'] < 300)]\ntrain = train.loc[(train['pickup_longitude'] > pickup_longitude_min) & (train['pickup_longitude'] < pickup_longitude_max)]\ntrain = train.loc[(train['pickup_latitude'] > pickup_latitude_min) & (train['pickup_latitude'] < pickup_latitude_max)]\ntrain = train.loc[(train['dropoff_longitude'] > dropoff_longitude_min) & (train['dropoff_longitude'] < dropoff_longitude_max)]\ntrain = train.loc[(train['dropoff_latitude'] > dropoff_latitude_min) & (train['dropoff_latitude'] < dropoff_latitude_max)]","859c40ee":"# Using the formulas of spherical trigonometry, we find the distance between points\n\ndef rasst(value1, value2, value3, value4):\n\n    longitude_1, latitude_1, longitude_2, latitude_2 = value1, value2, value3, value4\n    longitude_1, latitude_1, longitude_2, latitude_2 = map(radians, [longitude_1, latitude_1, longitude_2, latitude_2])\n\n    dlongitude = longitude_2 - longitude_1\n    dlatitude = latitude_2 - latitude_1\n\n    value = sin(dlatitude\/2.0)**2 + cos(latitude_1) * cos(latitude_2) * sin(dlongitude\/2.0)**2\n\n    c = 2 * arcsin(sqrt(value))\n    km = c * 6367\n    return km","082fe486":"# Sort the date by individual columns\n\ntrain['pickup_datetime'] = to_datetime(train['pickup_datetime'])\ntrain['hour_of_day'] = train.pickup_datetime.dt.hour.astype(float)\ntrain['day'] = train.pickup_datetime.dt.day.astype(float)\ntrain['week'] = train.pickup_datetime.dt.week.astype(float)\ntrain['month'] = train.pickup_datetime.dt.month.astype(float)\ntrain['day_of_year'] = train.pickup_datetime.dt.dayofyear.astype(float)\ntrain['week_of_year'] = train.pickup_datetime.dt.weekofyear.astype(float)\ntrain['passenger_count'] = train['passenger_count'].astype(float)\ntrain['rasst'] = rasst(train['pickup_longitude'], train['pickup_latitude'], train['dropoff_longitude'], train['dropoff_latitude'])\n\ntest['pickup_datetime'] = to_datetime(test['pickup_datetime'])\ntest['hour_of_day'] = test.pickup_datetime.dt.hour.astype(float)\ntest['day'] = test.pickup_datetime.dt.day.astype(float)\ntest['week'] = test.pickup_datetime.dt.week.astype(float)\ntest['month'] = test.pickup_datetime.dt.month.astype(float)\ntest['day_of_year'] = test.pickup_datetime.dt.dayofyear.astype(float)\ntest['week_of_year'] = test.pickup_datetime.dt.weekofyear.astype(float)\ntest['passenger_count'] = test['passenger_count'].astype(float)\ntest['rasst'] = rasst(test['pickup_longitude'], test['pickup_latitude'], test['dropoff_longitude'], test['dropoff_latitude'])","663afaa2":"train_y = train[\"fare_amount\"]\ntest_key = test['key']\ntrain_x = train.drop([\"fare_amount\", \"key\"], axis = 1)\ntrain_x = train_x.drop(['pickup_datetime'], axis = 1)\ntest = test.drop(['pickup_datetime', 'key'], axis = 1)","b046fd07":"train_xgb = xgb.DMatrix(train_x, train_y)\ntest_xgb = xgb.DMatrix(test)","5b9cce9e":"# Since there is a lot of data, we use the approximation in three-methods\n\nnum_round = 2\nparam = {'max_depth':12, 'eta':0.2,'min_child-weight':2, 'gamma':2, 'booster':'dart', 'three-method':'approx', 'normalize_type':'forest', 'rate_drop':0.3, 'eval_metric':'rmse'}\ntrain = xgb.train(param, train_xgb, num_round)\npredict = train.predict(test_xgb, ntree_limit = num_round)","6da06ceb":"res = DataFrame(test_key)","4a9a800b":"res.insert(1,'fare_amount', predict)\nres.to_csv('result.csv', index=False)","3fe84971":"\nSort the date by individual columns","1a057233":"Since the training file is very large, I only use the first 1 million records","1cb96f69":"Using the formulas of spherical trigonometry, we find the distance between points","63ec6bfc":"Then we take all the values between the minimum and the maximum for each column","de871055":"Since there is a lot of data, we use the approximation"}}