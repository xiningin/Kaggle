{"cell_type":{"4d43180e":"code","7ec853e8":"code","e4747d01":"code","791c0744":"code","fa313844":"code","be87dcc7":"code","ef3d46e9":"code","b39fc76c":"code","3dec4950":"code","91a03e18":"code","4d470a5a":"code","0939eb5c":"code","4a06f5b5":"code","79cc4c72":"code","394069cf":"code","b9ab66b2":"code","695bd2d3":"code","500507c4":"code","058dc88f":"code","517f35ba":"code","c106348b":"code","0357dc76":"code","699e219d":"code","5a66c59f":"code","942e9acc":"code","7c86873a":"code","32380f4b":"code","bb0fb7c3":"code","f2640fda":"code","87b2fcc9":"code","e4d9137f":"code","af351dd2":"code","cd88c569":"code","3f62c112":"markdown","22a7928a":"markdown","5e25cb84":"markdown","a69c70d3":"markdown","03501d06":"markdown","b1e194dd":"markdown","6eafd6f1":"markdown","d1f2c7e0":"markdown","2efc9f7b":"markdown","cb661187":"markdown","84c48725":"markdown","cd99d308":"markdown","e7e58935":"markdown","1ffd0561":"markdown","0c556537":"markdown","1632bb73":"markdown","1e003188":"markdown","430516d2":"markdown","99a1a7d9":"markdown","9729c402":"markdown","00716154":"markdown","f6c3d9d6":"markdown","cbafd771":"markdown","e55610f4":"markdown","6486a30d":"markdown","64953d98":"markdown","0cdae6b0":"markdown","c9738c6a":"markdown","0bbd58d5":"markdown","4961f8f9":"markdown","6ee26ce4":"markdown","188490f1":"markdown","19ee512c":"markdown","1f6d8d01":"markdown","dce3f881":"markdown","8f12404f":"markdown","adc26cd5":"markdown","7b3c86b2":"markdown","c4230fee":"markdown","85525aea":"markdown","4318fbfe":"markdown"},"source":{"4d43180e":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport Bio\nprint(\"Biopython v\" + Bio.__version__)","7ec853e8":"from Bio.Seq import Seq\nmy_seq = Seq(\"AGTACACTGGT\")\nprint(my_seq)\nmy_seq.alphabet","e4747d01":"print(my_seq + \" - Sequence\")\nprint(my_seq.complement() + \" - Complement\")\nprint(my_seq.reverse_complement() + \" - Reverse Complement\")","791c0744":"from Bio import SeqIO\ncount = 0\nsequences = [] # Here we are setting up an array to save our sequences for the next step\n\nfor seq_record in SeqIO.parse(\"..\/input\/genome.fa\", \"fasta\"):\n    if (count < 6):\n        sequences.append(seq_record)\n        print(\"Id: \" + seq_record.id + \" \\t \" + \"Length: \" + str(\"{:,d}\".format(len(seq_record))) )\n        print(repr(seq_record.seq) + \"\\n\")\n        count = count + 1","fa313844":"# Lets set these sequences up for easy access later\n\nchr2L = sequences[0].seq\nchr2R = sequences[1].seq\nchr3L = sequences[2].seq\nchr3R = sequences[3].seq\nchr4 = sequences[4].seq\nchrM = sequences[5].seq","be87dcc7":"print(len(chr2L))","ef3d46e9":"print(\"First Letter: \" + chr2L[0])\nprint(\"Third Letter: \" + chr2L[2])\nprint(\"Last Letter: \" + chr2L[-1])","b39fc76c":"print(\"AAAA\".count(\"AA\"))\nprint(Seq(\"AAAA\").count(\"AA\"))","3dec4950":"print(\"Length:\\t\" + str(len(chr2L)))\nprint(\"G Count:\\t\" + str(chr2L.count(\"G\")))","91a03e18":"print(\"GC%:\\t\\t\" + str(100 * float((chr2L.count(\"G\") + chr2L.count(\"C\")) \/ len(chr2L) ) ))","4d470a5a":"from Bio.SeqUtils import GC\nprint(\"GC% Package:\\t\" + str(GC(chr2L)))","0939eb5c":"print(\"GgCcSs%:\\t\" + str(100 * float((chr2L.count(\"G\") + chr2L.count(\"g\") + chr2L.count(\"C\") + chr2L.count(\"c\") + chr2L.count(\"S\") + chr2L.count(\"s\") ) \/ len(chr2L) ) ))\nprint(\"GC% Package:\\t\" + str(GC(chr2L)))","4a06f5b5":"print(chr2L[4:12])","79cc4c72":"chr2LSHORT = chr2L[0:20]\nprint(\"Short chr2L: \" + chr2LSHORT)\n\nprint(\"Codon Pos 1: \" + chr2LSHORT[0::3])\nprint(\"Codon Pos 2: \" + chr2LSHORT[1::3])\nprint(\"Codon Pos 3: \" + chr2LSHORT[2::3])","394069cf":"print(\"Reversed: \" + chr2LSHORT[::-1])","b9ab66b2":"chr2LSHORT = chr2L[0:20]\nprint(\"Short chr2L: \" + chr2LSHORT)\n\nchr2RSHORT = chr2R[0:20]\nprint(\"Short chr2R: \" + chr2RSHORT)\n\nconcat = chr2LSHORT + chr2RSHORT\nprint(\"Concat: \" + concat)","695bd2d3":"from Bio.Alphabet import IUPAC\nprotein_seq = Seq(\"EVRNAK\", IUPAC.protein)\ndna_seq = Seq(\"ACGT\", IUPAC.unambiguous_dna)\n\n# This will fail since they have different alphabets\n# print(protein_seq + dna_seq)\n\n# Error: Incompatible alphabets IUPACProtein() and IUPACUnambiguousDNA()\n\n# But if we give them the same generic alphabet it works\n\nfrom Bio.Alphabet import generic_alphabet\nprotein_seq.alphabet = generic_alphabet\ndna_seq.alphabet = generic_alphabet\nprint(protein_seq + dna_seq)","500507c4":"from Bio.Alphabet import generic_dna\n\nlist_of_seqs = [Seq(\"ACGT\", generic_dna), Seq(\"AACC\", generic_dna), Seq(\"GGTT\", generic_dna)]\nconcatenated = Seq(\"\", generic_dna)\nfor s in list_of_seqs:\n    concatenated += s\nprint(concatenated)","058dc88f":"list_of_seqs = [Seq(\"ACGT\", generic_dna), Seq(\"AACC\", generic_dna), Seq(\"GGTT\", generic_dna)]\nprint(sum(list_of_seqs, Seq(\"\", generic_dna)))","517f35ba":"dna_seq = Seq(\"acgtACGT\", generic_dna)\nprint(\"Original: \" + dna_seq)\nprint(\"Upper: \" + dna_seq.upper())\nprint(\"Lower: \" + dna_seq.lower())","c106348b":"print(\"GTAC\" in dna_seq)\nprint(\"GTAC\" in dna_seq.upper())","0357dc76":"print(\"Original: \" + chr2LSHORT)\nprint(\"Complement: \" + chr2LSHORT.complement())\nprint(\"Reverse Complement: \" + chr2LSHORT.reverse_complement())","699e219d":"print(\"Coding DNA: \" + chr2LSHORT)\ntemplate_dna = chr2LSHORT.reverse_complement()\nprint(\"Template DNA: \" + template_dna)","5a66c59f":"messenger_rna = chr2LSHORT.transcribe()\nprint(\"Messenger RNA: \" + messenger_rna)","942e9acc":"from Bio.Alphabet import IUPAC\nmessenger_rna = Seq(\"AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG\", IUPAC.unambiguous_rna)\nprint(\"Messenger RNA: \" + messenger_rna)\nprint(\"Protein Sequence: \" + messenger_rna.translate())","7c86873a":"coding_dna = Seq(\"ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\", IUPAC.unambiguous_dna)\nprint(\"Coding DNA: \" + coding_dna)\nprint(\"Protein Sequence: \" + coding_dna.translate())","32380f4b":"print(\"Vertebrate Mitochondrial Table Result: \" + coding_dna.translate(table=\"Vertebrate Mitochondrial\"))","bb0fb7c3":"print (\"Table 2 Result: \" + coding_dna.translate(table=2))","f2640fda":"print(\"Standard Translation: \" + coding_dna.translate())\nprint(\"Stop as in Biology: \" + coding_dna.translate(to_stop=True))\nprint(\"Table 2 Translation: \" + coding_dna.translate(table=2))\nprint(\"Table 2 Translation with Stop: \" + coding_dna.translate(table=2, to_stop=True))","87b2fcc9":"from Bio.Seq import Seq\nfrom Bio.Alphabet import generic_dna\ngene = Seq(\"GTGAAAAAGATGCAATCTATCGTACTCGCACTTTCCCTGGTTCTGGTCGCTCCCATGGCAGCACAGGCTGCGGAAATTACGTTAGTCCCGTCAGTAAAATTACAGATAGGCGATCGTGATAATCGTGGCTATTACTGGGATGGAGGTCACTGGCGCGACCACGGCTGGTGGAAACAACATTATGAATGGCGAGGCAATCGCTGGCACCTACACGGACCGCCGCCACCGCCGCGCCACCATAAGAAAGCTCCTCATGATCATCACGGCGGTCATGGTCCAGGCAAACATCACCGCTAA\", generic_dna)\nprint(gene)\nprint(\"Bacterial Translation With Stop: \" + gene.translate(table=\"Bacterial\", to_stop=True))","e4d9137f":"print (\"Bacterial Translation of CDS: \" + gene.translate(table=\"Bacterial\", cds=True))","af351dd2":"from Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\nseq1 = Seq(\"ACGT\", IUPAC.unambiguous_dna)\nseq2 = Seq(\"ACGT\", IUPAC.ambiguous_dna)\nprint(str(seq1) == str(seq2))\nprint(str(seq1) == str(seq1))","cd88c569":"print(seq1 == seq2)\nprint(seq1 == \"ACGT\")","3f62c112":"## 2.4  Parsing sequence file formats\n\nA large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers.\n\nFor this example, lets grab the first 6 sequences in the genomic data set","22a7928a":"You may often have many sequences to add together, which can be done with a for loop like this:","5e25cb84":"Notice that when you use the to_stop argument, the stop codon itself is not translated - and the stop symbol is not included at the end of your protein sequence.","a69c70d3":"## 3.6  Changing case","03501d06":"You can also translate directly from the coding strand DNA sequence:\n","b1e194dd":"## 2.2  Working with sequences\n\nDisputably (of course!), the central object in bioinformatics is the sequence. Thus, we\u2019ll start with a quick introduction to the Biopython mechanisms for dealing with sequences, the Seq object.\n\nMost of the time when we think about sequences we have in my mind a string of letters like \u2018AGTACACTGGT\u2019. You can create such Seq object with this sequence as follows:\n\n","6eafd6f1":"As you can see, all this does is switch T \u2192 U, and adjust the alphabet.","d1f2c7e0":"## 3.7  Nucleotide sequences and (reverse) complements\n\nFor nucleotide sequences, you can easily obtain the complement or reverse complement of a Seq object using its built-in methods:\n","2efc9f7b":"Lets count the number of G shown in the sequence","cb661187":"The next most important class is the SeqRecord or Sequence Record. This holds a sequence (as a Seq object) with additional annotation including an identifier, name and description. The Bio.SeqIO module for reading and writing sequence file formats works with SeqRecord objects.\n\nThis covers the basic features and uses of the Biopython sequence class. Now that you\u2019ve got some idea of what it is like to interact with the Biopython libraries, it\u2019s time to delve into the fun, fun world of dealing with biological file formats!","84c48725":"For some biological uses, you may actually want an overlapping count (i.e. 3 in this trivial example). When searching for single letters, this makes no difference.","cd99d308":"## 3.3  Slicing a sequence\n\nA more complicated example, let\u2019s get a slice of the sequence:","e7e58935":"Now, you may want to translate the nucleotides up to the first in frame stop codon, and then stop (as happens in nature):","1ffd0561":"Thats all for now, hope this tutorial run through was helpful! You can find lots more info about biopython here: http:\/\/biopython.org\/DIST\/docs\/tutorial\/Tutorial.html","0c556537":"But wait a minute! Why aren't those two numbers the name?\n\nThe answer lies in the sequence. We only used capital G\/C characters, but in the actual sequence there are lowercase g\/c characters. In addition, there are also S and s characters which represent an ambiguous G OR C character - but which are being counted for GC content by the package. Lets add those and check again:\n\n","1632bb73":"Another stride trick you might have seen with a Python string is the use of a -1 stride to reverse the string. You can do this with a Seq object too:","1e003188":"## 3.8  Transcription\n\nThe actual biological transcription process works from the template strand, doing a reverse complement (TCAG \u2192 CUGA) to give the mRNA. However, in Biopython and bioinformatics in general, we typically work directly with the coding strand because this means we can get the mRNA sequence just by switching T \u2192 U.","430516d2":"Biology Note: (remember by convention nucleotide sequences are normally read from the 5\u2019 to 3\u2019 direction)\n\nNow let\u2019s transcribe the coding strand into the corresponding mRNA, using the Seq object\u2019s built in transcribe method:\n","99a1a7d9":"So, what does Biopython do? Well, as of Biopython 1.65, sequence comparison only looks at the sequence, essentially ignoring the alphabet:","9729c402":"When you do a slice the first item is included (i.e. 4 in this case) and the last is excluded (12 in this case)\n\nThe second thing to notice is that the slice is performed on the sequence data string, but the new object produced is another Seq object which retains the alphabet information from the original Seq object.\n\nAlso like a Python string, you can do slices with a start, stop and stride (the step size, which defaults to one). For example, we can get the first, second and third codon positions of this DNA sequence:\n\nWe are using a short subset of chr2L since we don't want to go printing millions of characters","00716154":"In addition to telling Biopython to translate an alternative start codon as methionine, using this option also makes sure your sequence really is a valid CDS (you\u2019ll get an exception if not).","f6c3d9d6":"Much better!","cbafd771":"While you could use the above snippet of code to calculate a GC%, note that the Bio.SeqUtils module has several GC functions already built. For example:","e55610f4":"In the bacterial genetic code GTG is a valid start codon, and while it does normally encode Valine, if used as a start codon it should be translated as methionine. This happens if you tell Biopython your sequence is a complete CDS:","6486a30d":"In all of these operations, the alphabet property is maintained. This is very useful in case you accidentally end up trying to do something weird like take the (reverse)complement of a protein sequence (which will give an error)","64953d98":"You should notice in the above protein sequences that in addition to the end stop character, there is an internal stop as well. This was a deliberate choice of example, as it gives an excuse to talk about some optional arguments, including different translation tables (Genetic Codes).\n\nThe translation tables available in Biopython are based on those from the NCBI (see the next section of this tutorial). By default, translation will use the standard genetic code (NCBI table id 1). Suppose we are dealing with a mitochondrial sequence. We need to tell the translation function to use the relevant genetic code instead:\n\nNCBI Tables: http:\/\/www.ncbi.nlm.nih.gov\/Taxonomy\/Utils\/wprintgc.cgi","0cdae6b0":"Now, suppose you have a complete coding sequence CDS, which is to say a nucleotide sequence (e.g. mRNA \u2013 after any splicing) which is a whole number of codons (i.e. the length is a multiple of three), commences with a start codon, ends with a stop codon, and has no internal in-frame stop codons. In general, given a complete CDS, the default translate method will do what you want (perhaps with the to_stop option). However, what if your sequence uses a non-standard start codon? This happens a lot in bacteria \u2013 for example the gene yaaX in E. coli K12:","c9738c6a":"Unlike the Python string, the Biopython Seq does not (currently) have a .join method.","0bbd58d5":"You can also specify the table using the NCBI table number which is shorter, and often included in the feature annotation of GenBank files:","4961f8f9":"You can access elements of the sequence in the same way as for strings:","6ee26ce4":"The Seq object has a .count() method, just like a string. Note that this means that like a Python string, this gives a non-overlapping count:","188490f1":"The GC Content of a DNA sequence is important and relates to how stable the molecule will be. We can calculate it manually like this:","19ee512c":"What we have here is a sequence object with a generic alphabet - reflecting the fact we have not specified if this is a DNA or protein sequence (okay, a protein with a lot of Alanines, Glycines, Cysteines and Threonines!).\n\nIn addition to having an alphabet, the Seq object differs from the Python string in the methods it supports. You can\u2019t do this with a plain string:","1f6d8d01":"## 3.9  Translation\n\nUsing a new example, let\u2019s translate this mRNA into the corresponding protein sequence - again taking advantage of one of the Seq object\u2019s biological methods:\n\n","dce3f881":"These are useful for doing case insensitive matching:","8f12404f":"Or, a more elegant approach is to the use built in sum function with its optional start value argument (which otherwise defaults to zero):","adc26cd5":"## 3.11  Comparing Seq objects\n\nSequence comparison is actually a very complicated topic, and there is no easy way to decide if two sequences are equal. The basic problem is the meaning of the letters in a sequence are context dependent - the letter \u201cA\u201d could be part of a DNA, RNA or protein sequence. Biopython uses alphabet objects as part of each Seq object to try to capture this information - so comparing two Seq objects could mean considering both the sequence strings and the alphabets.\n\nFor example, you might argue that the two DNA Seq objects Seq(\"ACGT\", IUPAC.unambiguous_dna) and Seq(\"ACGT\", IUPAC.ambiguous_dna) should be equal, even though they do have different alphabets. Depending on the context this could be important.\n\nThis gets worse \u2013 suppose you think Seq(\"ACGT\", IUPAC.unambiguous_dna) and Seq(\"ACGT\") (i.e. the default generic alphabet) should be equal. Then, logically, Seq(\"ACGT\", IUPAC.protein) and Seq(\"ACGT\") should also be equal. Now, in logic if A=B and B=C, by transitivity we expect A=C. So for logical consistency we\u2019d require Seq(\"ACGT\", IUPAC.unambiguous_dna) and Seq(\"ACGT\", IUPAC.protein) to be equal \u2013 which most people would agree is just not right. This transitivity also has implications for using Seq objects as Python dictionary keys.\n\nNow, in everyday use, your sequences will probably all have the same alphabet, or at least all be the same type of sequence (all DNA, all RNA, or all protein). What you probably want is to just compare the sequences as strings \u2013 which you can do explicitly:","7b3c86b2":"#Getting Started with Biopython\n*Myles O'Neill - based on http:\/\/biopython.org\/DIST\/docs\/tutorial\/Tutorial.html*\n\nBiopython is a library we can use to analyze bioinformatic data. Lets have a look at some of the things we can do with it!\n\nThis script will go through a selection of tutorial excercises from the Biopython cookbook. I've tweaked them a bit to work with the Drosophila dataset we are using. This is an adapation of the tutorial with a bunch of tweaks, overall it should make it easier to get started with this data on Kaggle.\n\nFirst lets import numpy, pandas, and Bio (biopython):","c4230fee":"## 3.2  Sequences act like strings\n\nIn many ways, we can deal with Seq objects as if they were normal Python strings, for example getting the length, or iterating over the elements:\n\nLets start by printing the length of the first sequence we grabbed before:","85525aea":"If you really want to concat sequences from different alphabets, you\u2019d have to first give both sequences generic alphabets:","4318fbfe":"## 3.5  Concatenating or adding sequences\n\nNaturally, you can in principle add any two Seq objects together - just like you can with Python strings to concatenate them. However, you can\u2019t add sequences with incompatible alphabets, such as a protein sequence and a DNA sequence:"}}