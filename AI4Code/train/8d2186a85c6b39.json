{"cell_type":{"1ee397fa":"code","e2140b09":"code","9adc9f89":"code","36a07065":"code","c1cbe860":"code","dcfad8cf":"code","88ebf72f":"code","4e7ee0ae":"code","3a52fed2":"code","a6ff0903":"code","4ad9fd36":"code","b5ae70c1":"code","95c201dd":"code","c296232e":"code","b5b49468":"code","efb1b383":"markdown","981fa25a":"markdown","c3aec19d":"markdown","c8054373":"markdown","b15ab93c":"markdown","c93576b7":"markdown","d2afbfeb":"markdown","d5e3b539":"markdown","e4cd30c3":"markdown","f094cc79":"markdown","02575c2d":"markdown","28b68161":"markdown","48e41de5":"markdown","168b98bc":"markdown","ec441879":"markdown","880f2c47":"markdown","64455688":"markdown","2b1caa01":"markdown"},"source":{"1ee397fa":"import pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import OneHotEncoder\nfrom scipy.spatial import distance","e2140b09":"data = pd.read_csv(\"..\/input\/ultimate-spotify-tracks-db\/SpotifyFeatures.csv\")\ndata.head()","9adc9f89":"data.info()","36a07065":"data = data.drop([\"track_id\",\"key\",\"mode\",\"time_signature\"],1)\ndf = data.copy()\ndf = df.drop([\"artist_name\",\"track_name\"],1)","c1cbe860":"col = ['popularity', 'acousticness', 'danceability', 'duration_ms',\n       'energy', 'instrumentalness', 'liveness', 'loudness', 'speechiness',\n       'tempo', 'valence']\nscaler = StandardScaler()\ndf[col] = scaler.fit_transform(df[col])","dcfad8cf":"encoder = OneHotEncoder(sparse=False, handle_unknown=\"ignore\")\nenc = pd.DataFrame(encoder.fit_transform(np.array(df[\"genre\"]).reshape(-1,1)))\nenc.columns = df[\"genre\"].unique()","88ebf72f":"enc.head()","4e7ee0ae":"df[enc.columns] = enc\ndf = df.drop(\"genre\",1)\ndf.head()","3a52fed2":"df[\"name\"] = data[\"track_name\"]\ndf[\"artist\"] = data[\"artist_name\"]\n\ndf_2 = df.drop([\"artist\",\"name\"],1)","a6ff0903":"def find_song(word,artist):\n    a = 0\n    b = 0\n    for i in data[\"track_name\"]:\n        if word.lower() in i.lower() and artist.lower() in data[\"artist_name\"][a].lower():\n            print(\"Song Name: \",data[\"track_name\"][a],\", Artists: \",data[\"artist_name\"][a])\n            b+=1\n        a+=1\n    if b == 0:\n        print(\"Nothing found. Please try something else :)\")","4ad9fd36":"word = \"ocean eyes\"\nartist = \"billie\"\n\nfind_song(word,artist)","b5ae70c1":"def sim_track_find(word,artist):\n    a = 0\n    b = 0\n    song = []\n    indexes = []\n    for i in data[\"track_name\"]:\n        if word.lower() in i.lower() and artist.lower() in data[\"artist_name\"][a].lower():\n            song.append(df_2[a:a+1].values)\n            indexes.append(a)\n            b+=1\n        a+=1\n    if b == 0:\n        print(\"Nothing found. Please try something else :)\")\n        return 0\n        \n    return song[0][0], indexes[0]","95c201dd":"word = \"ocean eyes\"\nartist = \"billie\"\n\nsim_track_find(word,artist)","c296232e":"def similar_tracks(data,number,song = \"\",artist = \"\"):\n\n    if (sim_track_find(song,artist) == 0):\n        return 0\n    else:\n        x=sim_track_find(song,artist)[0]\n        index = sim_track_find(song,artist)[1]\n    p = []\n    count=0\n    for i in df_2.values:\n        p.append([distance.cosine(x,i),count])\n        count+=1\n    p.sort()\n    song_names = df[\"name\"]\n    artist_names = df[\"artist\"]\n\n    print(\"\\nSimilar songs to \",song_names[index],\" by \", artist_names[index],\"\\n\")\n    for i in range(1,number+1):\n        print(i,\"- \",song_names[p[i][1]],\", \",artist_names[p[i][1]])","b5b49468":"song = \"ocean eyes\"\nartist = \"billie\"\nnum = 5\n\nsimilar_tracks(df,int(num),song,artist)","efb1b383":"In this part we will normalize our data and apply one hot encoding to our genre column!","981fa25a":"Let's see how changed our data","c3aec19d":"I used cosine distance to measure the distances between songs in my dataset. There is multiple ways to do this but cosine distance is highly recommended.","c8054373":"### Normalization and One Hot Encoding","b15ab93c":"As you can see in the example, this function search the dataset and find the meaningfull song acording to the users input. And return that songs features as an array and the index of that song.","c93576b7":"## Song finder","d2afbfeb":"In the project if it cannot find any similar songs in the dataset, it will give you a message. It is important to handle errors. And in the function it takes some arguments. But if you don't want to enter a song name or an artist name, it takes none for that and find the closest song acording to your input.\n\nFinally, this was my project. You can improve it. Thanks for reading and checking here!","d5e3b539":"## Cosine Distance","e4cd30c3":"Hi, my name is Merve. Today i will tell you how to build a basic music recommendation system with python. First thing is importing the libraries that we will use in the project.","f094cc79":"## Building our system","02575c2d":"# Music Recommendation System with Python","28b68161":"Let me show you how the function works and tell the function after that example.","48e41de5":"Let's try our function!","168b98bc":"## Preprocessing","ec441879":"As you can see there is some categorical features, we will handle all of them. If you search your dataset well, you will see some of our features are in a different interval. We have to normalize our data.","880f2c47":"As you can see it will give you the recommendations! And you can get how many recommendations you want to get. ","64455688":"### Final Comments","2b1caa01":"In this part we will build a function. It will search the dataset and find the song name that the user will enter. "}}