{"cell_type":{"bb4c3b1d":"code","35f47a5d":"code","71b0b73d":"code","9540bfd9":"code","cd8289d1":"code","7a170cd9":"code","f98dd213":"code","ab02e994":"code","ac5ed69e":"code","5f9cce4f":"code","31db6c32":"code","750fee0c":"code","7bf22a79":"code","a47af96b":"code","8ff1c0a0":"code","89e54dff":"markdown","809b8699":"markdown","4bc02317":"markdown","2e2bd4cf":"markdown","87717233":"markdown","bf401d3a":"markdown","73ffa0d8":"markdown","78bf7f1b":"markdown","3a3b85b2":"markdown","8c526f28":"markdown","860e1be4":"markdown"},"source":{"bb4c3b1d":"# NumPy - math library for handling matrices and arrays\nimport numpy as np\n\n# Matplotlib's PyPlot - visualization library\nimport matplotlib.pyplot as plt\n\n# Util to load and display an image with Matplotlib\nfrom matplotlib import image as img\n\n# Seaborn - another visualization library (based on matplotlib)\nimport seaborn as sns\n\n# Pandas - Data Analysis library\nimport pandas as pd\n\n# Util for splitting data into train and test set\nfrom sklearn.model_selection import train_test_split\n\n#  Keras is Tensorflow's high level API for Deep Learning\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D\nfrom keras.layers import MaxPool2D\nfrom keras.layers import Dense\nfrom keras.layers import Activation\nfrom keras.layers import Flatten\nfrom keras.layers import Dropout\n\n# Util for One Hot Encoding\nfrom tensorflow.keras.utils import to_categorical","35f47a5d":"# Run this twice, to get rid of annyoing Tensorflow info message\n\nSequential()","71b0b73d":"with open('\/kaggle\/input\/dogsandcats\/images-dogs-cats-6000.npy', 'rb') as f:\n    data = np.load(f)\n    \nwith open('\/kaggle\/input\/labelsdogsandcats\/labels-dogs-cats-6000.npy', 'rb') as f:\n    targets = np.load(f)","9540bfd9":"# split into training and test sets\nX_train, X_test, y_train, y_test = train_test_split(data, targets, test_size=0.2, random_state=42)","cd8289d1":"random_index = np.random.randint(0, len(data))\nimage = data[random_index]\n\n# print label (target)\nprint(('Voff' if targets[random_index] == 1 else 'Mjau') + \" (label = \" + str(targets[random_index]) + \")\")\n\n# display the array of pixels as an image\nplt.imshow(image)\nplt.show()","7a170cd9":"print('X_train shape:     ' + str(X_train.shape))\nprint('X_test shape:      ' + str(X_test.shape))\nprint('y_train shape:     ' + str(y_train.shape))\nprint('y_test shape:      ' + str(y_test.shape))","f98dd213":"def visualize_distribution(data):\n    counts = pd.Series(data).value_counts()\n    sns.barplot(x=counts.index, y=counts.values)","ab02e994":"visualize_distribution(y_train)","ac5ed69e":"visualize_distribution(y_test)","5f9cce4f":"print(X_train.min())\nprint(X_train.max())","31db6c32":"model = Sequential() \n\nmodel.add(Conv2D(3, (3, 3), activation='relu', input_shape=(128, 128, 3)))\nmodel.add(Conv2D(4, (3, 3), activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dropout(0.3))\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))","750fee0c":"model.compile(\n    optimizer='adam',\n    loss='binary_crossentropy',\n    metrics=['accuracy']\n)","7bf22a79":"history = model.fit(\n    X_train,\n    y_train,\n    epochs=10,\n    batch_size=64,\n    verbose=1,\n    validation_split=0.1\n)","a47af96b":"# Visualize accuracy during training\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('Training')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Training set', 'Validation set'])\nplt.show()","8ff1c0a0":"loss, accuracy  = model.evaluate(X_test, y_test, verbose=True)\n\nprint(f'Test loss: {loss:.3}')\nprint(f'Test accuracy: {accuracy:.3}')\n","89e54dff":"## 4. Train model","809b8699":"### Tips","4bc02317":"**Things to think about**:\n* What is the shape of the data? What is the difference between coloured images and black and white images?\n* Do we need to normalize the data? Or not?\n* Do we need to One Hot Encode anything? If yes, features or labels or both?\n* When building the model:\n    * How many nodes in the output layer? What type of activation should be used?\n    * What type of loss should be used? Hint: check out the list of Keras' probabilistic loss functions at https:\/\/keras.io\/api\/losses\/\n    * Take a look at the imports for hints on what type of layers couldb be used\n    \nBruk google og mentorene!","2e2bd4cf":"### Import all the libraries and modules needed","87717233":"## 5. Evaluate model\nIn order to evaluate the model, we evaluate it on the test data","bf401d3a":"# Animal classification based on images\n### ...is it a cat or is it a dog?\n---\n\n**Dataset**\n* Images of animal faces (centralized)\n* Two classes: Cats (label = 0) and dogs (label = 1)\n\n*The data is taken from the* [Animal faces dataset](https:\/\/www.kaggle.com\/andrewmvd\/animal-faces)\n\n\n\nBy [Markus Malum Kim](https:\/\/github.com\/markusmkim)\n\n","73ffa0d8":"## 3. Build model","78bf7f1b":"One hot encoding: Not needed (only two classes --> one output node in model). Doing one hot encoding and softmax with two output nodes also OK\n\nNormalizing: Not needed (show that data is already normalized)","3a3b85b2":"## 1. Quick data exploration","8c526f28":"## 2. Feature engineering","860e1be4":"### Load data"}}