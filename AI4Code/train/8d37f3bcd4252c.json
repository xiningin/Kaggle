{"cell_type":{"6a6afc67":"code","eeb088cb":"code","eb0c64b0":"code","6954ea2a":"code","864b9b5d":"code","ccf8eeee":"code","166aa797":"code","72710552":"code","c5d81258":"code","a95a9c83":"code","faba5fe9":"markdown","8c61f863":"markdown","bf7ec8da":"markdown","e0802e93":"markdown","fec08e02":"markdown"},"source":{"6a6afc67":"startzustand = [3,3,1]\nzielzustand  = [0,0,0]\n\n# Erzeuge alle denkbaren Folgezust\u00e4nde, wir schauen nicht auf feasibility\n# Wir geben eine Liste von Listen (den Zust\u00e4nden) zur\u00fcck\ndef gib_folgezustaende(zustand):\n    result = []\n    m,k,b = zustand\n    b_new = 0 if b else 1    \n    # now try all potential operations\n    # Let's keep it simple for now:\n    if b:\n        if k > 0:\n            if m > 0:\n                result.append([m-1,k-1,b_new])\n            if k > 1:\n                result.append([m,k-2,b_new])\n            result.append([m,k-1,b_new])       \n        if m > 1:\n            result.append([m-2,k,b_new])\n        if m > 0:\n            result.append([m-1,k,b_new]) \n    if not b:\n        if k < 3:\n            if m < 3:\n                result.append([m+1,k+1,b_new])\n            if k < 2:\n                result.append([m,k+2,b_new])\n            result.append([m,k+1,b_new])       \n        if m < 2:\n            result.append([m+2,k,b_new])\n        if m < 3:\n            result.append([m+1,k,b_new])\n            \n    return result\n\n## Some tests\nprint(gib_folgezustaende([3,3,1]))            \nprint(gib_folgezustaende([2,2,0]))\nprint(gib_folgezustaende([2,2,1]))\nprint(gib_folgezustaende([1,1,0]))\nprint(gib_folgezustaende([1,1,1]))","eeb088cb":"## Jetzt checken wir noch, ob die Zust\u00e4nde valide sind!\ndef is_valid(zustand):\n    m,k,b = zustand\n    # es gibt im Westen mehr Kannibalen, als Missionare\n    if m < k and m > 0: return False \n    # es gibt im Osten mehr Kannibalen, als Missionare\n    if m > k and m < 3: return False\n    return True\n\ndef gib_valide_folgezustaende(zustand):\n    return [z for z in gib_folgezustaende(zustand) if is_valid(z)]\n\n# Some tests\nprint(gib_valide_folgezustaende([3,3,1]))            \nprint(gib_valide_folgezustaende([2,2,0]))\nprint(gib_valide_folgezustaende([2,2,1]))\nprint(gib_valide_folgezustaende([1,1,0]))\nprint(gib_valide_folgezustaende([1,1,1]))","eb0c64b0":"# Rekursive Suche in die Tiefe (depth-first search with chronolocigal backtracking)\nmax_incr = 0\ndef suche(zustand,history,all_solutions=False,level=0,debug=1):\n    global max_incr\n    if debug: print(level*' ',zustand,\" ->\",end=\"\")\n        \n    # if compare(zustand,zielzustand): return (True,history+[zustand])\n    if zustand == zielzustand: return (True,history+[zustand])\n    fzustaende = gib_valide_folgezustaende(zustand)\n    \n    if debug: print(\"  \",fzustaende)\n        \n    if not len(fzustaende): return (False,[])\n    for z in fzustaende:\n        if z not in history+zustand:\n            res1,res2 = suche(z,history+[zustand],all_solutions,level+1,debug)\n            if res1: \n                if all_solutions:\n                    max_incr+=1\n                    print(\"Solution found: \",res1,res2)\n                else:\n                    return (res1,res2) # Just stop\n        else:\n            if debug == 2: print((level+1)*' '+\"repeated\",z)\n    return (False,[])\n\nsuche(startzustand,[],debug=2) # One solution","6954ea2a":"# All solutions, debugging disabled\nsuche(startzustand,[],all_solutions=True,debug=0)","864b9b5d":"## Noch nicht besonders sch\u00f6n ist die Funktion f\u00fcr die Folgezust\u00e4nde\n## Gestalten wir die ein wenig knapper und sehen gleich einen\n### Maximalwert f\u00fcr die Anzahl vor\n### Um es sp\u00e4ter leichter verwenden zu k\u00f6nnen, geben wir den Wert\n### global vor\nmax_value = 3\n\ndef gib_folgezustaende(zustand):\n    global max_value\n    m,k,b = zustand\n    incr  = -1 if b else +1\n    b_new = 0 if b else 1\n    \n    fzustaende = [\n        [m+incr,k+incr,b_new],\n        [m+incr,k,b_new],\n        [m,k+incr,b_new],\n        [m+incr*2,k,b_new],\n        [m,k+incr*2,b_new]\n    ]\n    # Entferne alle, die f\u00fcr m bzw. k kleiner 0 oder gr\u00f6\u00dfer 3 sind\n    return [[k,m,b] for k,m,b in fzustaende \n                if k >= 0 and k <= max_value and m >= 0 and m <= max_value]\n\n## Some tests\nprint(gib_folgezustaende([3,3,1]))            \nprint(gib_folgezustaende([2,2,0]))\nprint(gib_folgezustaende([2,2,1]))\nprint(gib_folgezustaende([1,1,0]))\nprint(gib_folgezustaende([1,1,1]))","ccf8eeee":"# All solutions, debugging disabled\nsuche(startzustand,[],all_solutions=True,debug=0)","166aa797":"# Wir brauchen eine allgemeinere Version von is_valid:\ndef is_valid(zustand):\n    global max_value\n    m,k,b = zustand\n    # es gibt im Westen mehr Kannibalen, als Missionare\n    if m < k and m > 0: return False \n    # es gibt im Osten mehr Kannibalen, als Missionare\n    if m > k and m < max_value: return False\n    return True","72710552":"# Jetzt k\u00f6nnen wir schon suchen!\nmax_value = 4\nsuche([4,4,1],[],all_solutions=True,debug=2)","c5d81258":"## Hier ist Platz f\u00fcr ihre L\u00f6sung in ihrem eigenen Notebook, senden Sie mir ein korrekte ausgef\u00fchrtes Jupyter-Notebook, \n# per Link zu github oder zu einem \u00f6ffentlichen Kaggle-Kernel!\n\n## Noch nicht besonders sch\u00f6n ist die Funktion f\u00fcr die Folgezust\u00e4nde\n## Gestalten wir die ein wenig knapper und sehen gleich einen\n### Maximalwert f\u00fcr die Anzahl vor\n### Um es sp\u00e4ter leichter verwenden zu k\u00f6nnen, geben wir den Wert\n### global vor\nmax_value = 4\n\ndef gib_folgezustaende(zustand):\n    global max_value\n    m,k,b = zustand\n    incr  = -1 if b else +1\n    b_new = 0 if b else 1\n    \n    fzustaende = [\n        [m+incr,k+incr,b_new],\n        [m+incr,k,b_new],\n        [m,k+incr,b_new],\n        [m+incr*2,k,b_new],\n        [m,k+incr*2,b_new],\n        [m+incr*3,k,b_new],\n        [m,k+incr*3,b_new],\n        [m+incr*2,k+incr,b_new],\n        [m+incr,k+incr*2,b_new]\n    ]\n    # Entferne alle, die f\u00fcr m bzw. k kleiner 0 oder gr\u00f6\u00dfer 3 sind\n    return [[k,m,b] for k,m,b in fzustaende \n                if k >= 0 and k <= max_value and m >= 0 and m <= max_value]\n\n## Some tests\nprint(gib_folgezustaende([4,4,1]))\nprint(gib_valide_folgezustaende([4,4,1])) \n##print(gib_folgezustaende([2,2,0]))\n##print(gib_folgezustaende([2,2,1]))\n##print(gib_folgezustaende([1,1,0]))\n##print(gib_folgezustaende([1,1,1]))","a95a9c83":"# All solutions, debugging disabled\nsuche([4,4,1],[],all_solutions=True,debug=0)\nprint(max_incr)","faba5fe9":"## Simple Searching\n\nWir lernen eine ziemlich universelle Methoden kennen, um Probleme zu l\u00f6sen (nun ja, zumindest, es zu versuchen ;). Die grobe Idee ist einfach: Die Welt befindet sich zu jedem Betrachtungszeitpunkt (diskret, endlich viele!) in einem Zustand. Jeder Zustand l\u00e4\u00dft sich \u00fcber endlich viele Elemente und Beziehungen zwischen diesen Elementen beschreiben. Sehr oft reichen endlich viele Werte, um die Zust\u00e4nde der Elemente und Beziehungen zu beschreiben (Reality check: immer!). Es gibt Operationen, die Operatoren instantiieren, um von einem Zustand zu einem Folgezustand \u00fcberzugehen. Auch hier gehen wir von nur endlich vielen Operationen aus, die m\u00f6glich bzw. plausibel sind. Nun k\u00f6nnen wir einen Startzustand angeben und einen Endzustand (oder eine Menge von Endzust\u00e4nden). Die L\u00f6sung des Problems k\u00f6nnen wir nun durch Suche nach einem Weg vom Startzustand zu einem Endzustand finden.\n\n*Beispiel*: **Kannibalen\/Missionarsproblem**\n\nAuf der westlichen Seite eines Flusses, der von Norden nach S\u00fcden flie\u00dft, befinden sich 3 Missionare, 3 Kannibalen und ein Boot f\u00fcr 1-2 Personen. Das Boot ist nicht selbstfahrend, ohne Fahrer treibt es ab und ist verloren!\n\nIhre Aufgabe ist es nun, die 3 Missionare und die 3 Kannibalen mit dem Boot vollst\u00e4ndig auf die \u00f6stliche Seite \u00fcberzusetzen. Dabei m\u00fcssen Sie die folgende Nebenbedingung beachten: sollten auf irgendeiner Seite des Flusses (die Besatzung im Boot z\u00e4hlt mit, sobald dieses in Ufern\u00e4he ist!) die Kannibalen einmal in der \u00dcberzahl sein, so werden die Missionare dort gefressen! Das ist dann kein g\u00fcltiger L\u00f6sungsweg!\n\n*Problemrepr\u00e4sentierung*:\n\nWir beschreiben das Problem \u00fcber Zust\u00e4nde $(m,k,b)$. Hierbei gibt $m$ die Anzahl der Missionare und $k$ die der Kannibalen auf der westlichen Seite des Flusses an, $b = 1$ sagt: das Boot ist auf der westlichen Seite, $b = 0$ sagt: das Boot ist auf der \u00f6stlichen Seite des Flusses.\n\nDer Startzustand ist $(3,3,1)$ (Alles ist westlich), der gew\u00fcnschte Endzustand ist $(0,0,0)$ (Alles ist \u00f6stlich).\n\nWir k\u00f6nnen das Boot fahren lassen, in dem wir Kannibalen und\/oder Missionare ins Boot setzen. Wir gehen davon aus, dass die alle freiwillig zur anderen Seite fahren ;)\n\nZu einem Zustand $(m_1,k_1,b_1)$ ergeben sich denkbare Folgezust\u00e4nde durch die technisch m\u00f6glichen Fahroperation. Erkl\u00e4ren wir das per Beispiel (und zeigen es dann exakt als Programmcode):\n\n$(3,3,1)$ hat die \"denkbaren\" Folgezust\u00e4nde $(2,2,0)$, $(2,3,0)$, $(3,2,0)$, $(1,3,0)$, $(3,1,0)$. Hier entsteht z.B. $(2,2,0)$ aus der Operation \"Lasse 1 Missionar und 1 Kannibalen mit dem Boot auf die andere Seite fahren\" (die Richtung ergibt sich automatisch aus der Position des Bootes, deren Angabe k\u00f6nnen wir uns also sparen).\n\nManche der Folgezust\u00e4nde, die eintreten bzw. eintreten w\u00fcrden, sind nicht *valide*, oben sind es $(1,3,0)$ und $(2,3,0)$ (wir sollten also tunlichst nicht einen oder zwei Missionare allein auf die andere Seite schicken).\n\nGenerell darf westlich kein Zustand $(m,k,?)$ eintreten mit $0 < m < k$, und \u00f6stlich, also f\u00fcr $(m,k,?)$, keiner mit $k < m < 3$ (die Lage des Bootes ist hier egal, ob das nun gerade im Westen oder Osten liegt, ist irrelevant daf\u00fcr, ob der Zustand invalide ist, deshalb haben wir ein ? angegeben).\n\nDas Ganze m\u00fcssen wir jetzt noch mit einer systematischen Suche kombinieren, dann k\u00f6nnen wir das Problem l\u00f6sen! Machen wir das:","8c61f863":"Das geht nicht! Das ist auch nicht besonders \u00fcberraschend, weil eine wichtige Operation in der L\u00f6sung ist, dass wir, nachdem wir alle Kannibalen auf die andere Seite gebracht haben (was wir tun m\u00fcssen!), einen zur\u00fccksenden, und dann fahren 2 Missionare nach Osten, einer kommt mit einem Kannibalen zur\u00fcck und dann fahren alle Missionare hin\u00fcber und der letzte Kannibale holt dann nach und nach seine Kumpels aus dem Westen. Ein analoges Vorgehen mit 4 Kannibalen k\u00f6nnen wir nicht zum Erfolg f\u00fchren, s. oben!\n\nDas gilt so dann f\u00fcr jede Erh\u00f6hung der Anzahlen! Eine Variation w\u00fcrde sich ergeben, wenn wir das Boot auf 3 Pl\u00e4tze erh\u00f6hen w\u00fcrden - k\u00f6nnen wir dann das Problem mit 4 Kannibalen und 4 Missionaren l\u00f6sen?","bf7ec8da":"Erkl\u00e4ren wir das einmal ein wenig:\n\nDie \"denkbaren\" Folgezust\u00e4nde zu $[1,1,0]$ k\u00f6nnen wir wie folgt finden: das Boot liegt im Osten, wir haben im Westen 1 Missionar und 1 Kannibalen, im Osten 2 Missionare und 2 Kannibalen. Wir k\u00f6nnen also 1M1K, 2M, 2K, 1K und 1M von Osten nach Westen fahren lassen, insgesamt also:\n\n$[[2, 2, 1], [3, 1, 1], [2, 1, 1], [1, 3, 1], [1, 2, 1]]$\n\nLassen wir nur einen Missionar fahren, dann sind im Osten zuviele Kannibalen. \n\nLassen wir einen oder zwei Kannibalen fahren, dann sind im Westen zuviele Kannibalen.\n\nValide Folgezust\u00e4nde zu $[1,1,0]$ sind also $[[2, 2, 1], [3, 1, 1]]$.\n\nVerwenden wir das nun, um das Problem mit Suche zu l\u00f6sen. Wir versuchen hier zun\u00e4chst in die Tiefe zu laufen. Was wir noch tun sollten,  ist, Zust\u00e4nde zu vermeiden, die wir schon einmal auf dem bisher zur\u00fcckgelegten Weg besucht hatten (denken Sie dran: wir k\u00f6nnten beliebig oft hin und her fahren, wenn wir ein valide Operation gefunden haben...).","e0802e93":"Jetzt wollen wir pr\u00fcfen, ob wir auch f\u00fcr 4 Missionare und 4 Kannibalen einen Weg hin\u00fcber finden!","fec08e02":"**Aufgabe**: Testen Sie mit einer Variation des obigen Programms, ob es m\u00f6glich ist, das 4-Kannibalen, 4 Missionare, 3-Platz-Boot-Problem zu l\u00f6sen!\n\nJupyter-Notebook k\u00f6nnen Sie \u00fcber https:\/\/www.anaconda.com\/download\/ installieren!\nSie k\u00f6nnen auch bei https:\/\/www.kaggle.com einen Account anlegen und dort \"live\" Notebooks ausprobieren (mit gewissen Beschr\u00e4nkungen)."}}