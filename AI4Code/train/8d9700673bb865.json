{"cell_type":{"38636b97":"code","9d670282":"code","9e24456e":"code","40a5cdfa":"code","aeb72522":"code","faf33fc2":"code","531ab859":"code","6e231eaf":"code","40b0973a":"code","a76cdb02":"code","dc91e9f7":"code","12e52500":"code","d1c0d69a":"code","23767d3f":"code","1c94f232":"code","d078133e":"code","312ceb41":"code","2565ede8":"code","e244659e":"code","37eb1d2c":"markdown","a0ee032a":"markdown","1c6149c0":"markdown","78860013":"markdown","427fdfff":"markdown","7cea58dd":"markdown"},"source":{"38636b97":"#We have referred the material provided for Lab Week 11\nimport random\nimport time \nimport string\nimport matplotlib.pyplot as plt","9d670282":"#Brute Force Algorithm\ndef find_brute(T, P):\n    n, m = len(T), len(P)\n    count = 0\n    # every starting position\n    for i in range(n-m+1):\n        k = 0\n        count+=1\n        # conduct O(k) comparisons\n        while k < m and T[i+k] == P[k]:\n            k += 1\n            \n        if k == m:\n            return i,count\n    return -1,count","9e24456e":"#Boyer Moore Algorithm\ndef find_boyer_moore(T, P):\n    n, m = len(T), len(P)\n    count = 0\n    if m == 0: \n        return 0\n    last = {}\n    for k in range(m):\n        last[P[k]] = k\n    i = m-1\n    k = m-1\n    while i < n:\n        # If match, decrease i,k\n        count+=1\n        if T[i] == P[k]:\n            if k == 0:\n                return i,count\n            else:\n                i -= 1\n                k -= 1\n        # Not match, reset the positions\n        else:\n            j = last.get(T[i], -1)\n            i += m - min(k, j+1)\n            k = m-1\n    return -1,count","40a5cdfa":"# Kuth Morris Pratt Failure Function\ndef compute_kmp_fail(P):\n    m = len(P)\n    fail = [0] * m\n    j = 1\n    k = 0\n    while j < m:\n        if P[j] == P[k]:\n            fail[j] = k+1\n            j += 1\n            k += 1\n        elif k > 0:\n            k = fail[k-1]\n        else: \n            j += 1\n    return fail","aeb72522":"# Kuth Morris Pratt Algorithm\ndef find_kmp(T, P):\n    n, m = len(T), len(P)\n    count = 0\n    if m == 0:\n        return 0\n    fail = compute_kmp_fail(P)\n    \n    j = 0\n    k = 0\n    while j < n:\n        count+=1\n        if T[j] == P[k]:\n            if k == m-1:\n                return j-m+1,count\n            j += 1\n            k += 1\n        elif k > 0:\n            k = fail[k-1]\n        else:\n            j += 1\n    return -1,count","faf33fc2":"# Comparing the Count of the three given algorithms\ndef compare(T, P):\n    Count1 = []\n    Count2 = []\n    Count3 = []\n    for i in range(len(P)-1):\n        \n        startTime = time.time()\n        index,c1 = find_brute(T[i], P[i])\n        endTime = time.time()\n        Count1.append(c1)\n\n        startTime = time.time()\n        index,c2 = find_boyer_moore(T[i], P[i])\n        endTime = time.time()\n        Count2.append(c2)\n\n        startTime = time.time()\n        index,c3 = find_kmp(T[i], P[i])\n        endTime = time.time()\n        Count3.append(c3)\n    return Count1,Count2,Count3","531ab859":"def generate_random_strings(letters, size):\n    return ''.join(random.choice(letters) for i in range(size))","6e231eaf":"# set random seed so you will always get the same random_string\nrandom.seed(311299)\n\nletter_set = string.ascii_letters\n\nrandom_string = generate_random_strings(letter_set, 10**3)\n#print(random_string)","40b0973a":"m = []\nn = []\nk = []\npattern = []\ntest_string = []\nj = 0\nfor i in range(10,200,10):\n    pattern.append(generate_random_strings(\"SRNG\", i))\n    # append pattern to the end of string\n    test_string.append(random_string + pattern[j])\n    j+=1\nm,n,k = compare(test_string, pattern)\nprint(m)\nprint(n)\nprint(k)","a76cdb02":"I = []\nfor i in range(10,190,10):\n    I.append(i)\nplt.xlabel('Pattern size')\nplt.ylabel('No. of Comparisons')\nplt.title('No. of Comparisons versus Pattern size')\nplt.plot(I,m, color = 'b', label = 'Brute Force function')\nplt.plot(I,n, color = 'r', label = 'Boyer Moore function')\nplt.plot(I,k, color = 'g', label = 'KMP function')\nplt.legend()","dc91e9f7":"# Comparing the runtimes of the three given algorithms\ndef compare(T, P):\n    Time1 = []\n    Time2 = []\n    Time3 = []\n    for i in range(len(P)-1):\n        \n        startTime = time.time()\n        index,c1 = find_brute(T[i], P[i])\n        endTime = time.time()\n        Time1.append(endTime - startTime)\n\n        startTime = time.time()\n        index,c2 = find_boyer_moore(T[i], P[i])\n        endTime = time.time()\n        Time2.append(endTime - startTime)\n\n        startTime = time.time()\n        index,c3 = find_kmp(T[i], P[i])\n        endTime = time.time()\n        Time3.append(endTime - startTime)\n    return Time1,Time2,Time3","12e52500":"def generate_random_strings(letters, size):\n    return ''.join(random.choice(letters) for i in range(size))","d1c0d69a":"random.seed(311299)\n\nletter_set = string.ascii_letters\n\nrandom_string = generate_random_strings(letter_set, 10**7)\n","23767d3f":"m = []\nn = []\nk = []\npattern = []\ntest_string = []\nj = 0\nfor i in range(10,200,10):\n    pattern.append(generate_random_strings(\"SRNG\", i))\n    # append pattern to the end of string\n    test_string.append(random_string + pattern[j])\n    j+=1\nm,n,k = compare(test_string, pattern)","1c94f232":"I = []\nfor i in range(10,190,10):\n    I.append(i)\n#plt.xscale('log')\nplt.yscale('log')\nplt.xlabel('Pattern size')\nplt.ylabel('Running time per pattern size')\nplt.title('Running time visualization of each algorithm when the pattern is added at the last')\nplt.plot(I,m, color = 'b', label = 'Brute Force function')\nplt.plot(I,n, color = 'r', label = 'Boyer Moore function')\nplt.plot(I,k, color = 'g', label = 'KMP function')\nplt.legend()","d078133e":"m = []\nn = []\nk = []\npattern = []\ntest_string = []\nj = 0\nfor i in range(10,200,10):\n    pattern.append(generate_random_strings(\"SRNG\", i))\n    # append pattern to the end of string\n    test_string.append(pattern[j] + random_string)\n    j+=1\nm,n,k = compare(test_string, pattern)","312ceb41":"plt.yscale('log')\nplt.xlabel('Pattern size')\nplt.ylabel('Running time per pattern size')\nplt.title('Running time visualization of each algorithm when the pattern is added in the beginning')\nplt.plot(I,m, color = 'b', label = 'Brute Force function')\nplt.plot(I,n, color = 'r', label = 'Boyer Moore function')\nplt.plot(I,k, color = 'g', label = 'KMP function')\nplt.legend()","2565ede8":"m = []\nn = []\nk = []\npattern = []\ntest_string = []\nj = 0\nfor i in range(10,200,10):\n    pattern.append(generate_random_strings(\"SRNG\", i))\n    # append pattern to the end of string\n    test_string.append(random_string[:len(random_string)\/\/2] + pattern[j] + random_string[len(random_string)\/\/2:])\n    j+=1\nm,n,k = compare(test_string, pattern)","e244659e":"plt.yscale('log')\nplt.xlabel('Pattern size')\nplt.ylabel('Running time per pattern size')\nplt.title('Running time visualization of each algorithm when the pattern is added in the middle')\nplt.plot(I,m, color = 'b', label = 'Brute Force function')\nplt.plot(I,n, color = 'r', label = 'Boyer Moore function')\nplt.plot(I,k, color = 'g', label = 'KMP function')\nplt.legend()","37eb1d2c":"### Case 1: When pattern is added to the last of the random string ","a0ee032a":"### Case 3: When the pattern is added in the middle of the random string ","1c6149c0":"## Sub-question 1:","78860013":"# Problem 2","427fdfff":"\n## Sub-question 2:","7cea58dd":"### Case 2: When the pattern is added before the random string "}}