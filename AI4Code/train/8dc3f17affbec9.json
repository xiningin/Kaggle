{"cell_type":{"1158dc87":"code","4c689f20":"code","567f4ccf":"code","c53f6543":"code","b5c02429":"code","60d5af1d":"code","84460268":"code","595ae823":"code","b2079e44":"code","3245fc6e":"code","eb61b6bc":"code","22faac04":"code","065ff1e7":"code","d19f2070":"code","bf39afad":"code","441f5846":"code","effedb23":"code","6a4e37c4":"markdown","97ae79fb":"markdown"},"source":{"1158dc87":"import requests\nimport json\nimport pandas as pd\nimport numpy as np\nimport dateutil.parser\nimport datetime\nimport math\nimport psycopg2\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import model_selection\nfrom sklearn.metrics import confusion_matrix\nimport folium\nimport geopy\nfrom geopy.geocoders import Nominatim\nfrom geopy.exc import GeocoderTimedOut\nimport sys\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline","4c689f20":"df_stations = pd.read_csv('..\/input\/train_file.csv')","567f4ccf":"# EDA\n#Let's what we have..\n\ndf_stations.head(10)","c53f6543":"#Okay, some statistics for our quantitative data\ndf_stations.describe()","b5c02429":"df_stations.shape","60d5af1d":"#FEATURE ENGENEERING\n#We are goint to add some information to help us to undersatnd better the data\n#Format the datetime\n#Add day of week to see if there is any difference between weekday and weekend\n\ndef dateFormats(data):\n    ## convert the timestamp to a python date object and get the hour\n    data['timestamp'] = list(map(lambda v : dateutil.parser.isoparse(str(v)), data['timestamp']))\n    \n    ## add dedicated columns for day, hour and weekday \n    data['day'] = list(map(lambda v : v.day, data['timestamp']))\n    data['hour'] = list(map(lambda v : v.hour, data['timestamp']))\n    data['minute'] = list(map(lambda v : v.minute, data['timestamp']))\n    data['dayofweek'] = data['timestamp'].dt.weekday\n    \n    #Let's group the minutes each 5 to have a better distrubution\n    data['minute_c5'] = list(map(lambda v : round(v\/5)*5 , data['minute']))\n  \n    return data\n\n\ndf_stations= dateFormats(df_stations)","84460268":"#Getting the postal code, I'm using geopy\n#Lets get the coordinates apart, because it last some time...\n\ngeoLocs = pd.DataFrame(df_stations[['latitude','longitude']].copy())\ngeoLocs.sort_values('latitude', inplace=True) \ngeoLocs.drop_duplicates(keep='first' ,inplace=True, ignore_index= True) \n\ndef get_zipcode(df, geolocator, lat_field, lon_field):\n    try:\n        location = geolocator.reverse((df[lat_field], df[lon_field]))\n        return location.raw['address']['postcode']\n    except :\n        return [-1][-1]\n    \n\ngeolocator = geopy.Nominatim(user_agent='my-application')\n\n\nzipcodes = geoLocs.apply(get_zipcode, axis=1, geolocator=geolocator, lat_field='latitude', lon_field='longitude')\n\n#Joining the postalcode to the dataset\ngeoLocs['postcode'] = zipcodes[0:]\ndf_stations = pd.merge(df_stations , geoLocs, on=['latitude','longitude'], how='inner')\n\nprint(df_stations)","595ae823":"print(df_stations.head(10))","b2079e44":"#Let's check the quantitative varibles\nf = pd.melt(df_stations, value_vars=df_stations[['empty_slots','free_bikes','day','hour','minute','dayofweek']])\ng = sns.FacetGrid(f, col=\"variable\",  col_wrap=2, sharex=False, sharey=False)\ng = g.map(sns.distplot, \"value\")","3245fc6e":"#Qualitative variables time, let's see how do they behave with the free bikes\nfor c in df_stations[['day','hour','dayofweek','postcode']]:\n    df_stations[c] = df_stations[c].astype('category')\n    if df_stations[c].isnull().any():\n        df_stations[c] = df_stations[c].cat.add_categories(['MISSING'])\n        df_stations[c] = df_stations[c].fillna('MISSING')\n\ndef boxplot(x, y, **kwargs):\n    sns.boxplot(x=x, y=y)\n    x=plt.xticks(rotation=90)\nf = pd.melt(df_stations, id_vars=['free_bikes'], value_vars=df_stations[['day','hour','dayofweek','postcode']])\ng = sns.FacetGrid(f, col=\"variable\",  col_wrap=2, sharex=False, sharey=False, height=10)\ng = g.map(boxplot, \"value\", \"free_bikes\")","eb61b6bc":"#Changing the ID variable from categorical to numeric\n\ntry:\n    df_stations['id'] = df_stations['id'].astype('category')\n    if(df_stations['id_dwh']):\n        pass\nexcept:    \n    df_stations['id_dwh'] = df_stations['id'].cat.codes","22faac04":"#preparing training and testing data\n\n#Creating the dependents varibles\n\n#Setting dependient variable:  free_bike, change to  0,1 (0: no free bike, 1:At least one bike)  \n#Setting dependient variable:  empty_slot, change to  0,1 (0: no empty slot, 1:At least one empty slot) \n\ndf_stations['is_free_bike'] = [1 if x>0 else 0 for x in df_stations.free_bikes]\ndf_stations['is_free_slot'] = [1 if x>0 else 0 for x in df_stations.empty_slots]\n\ndf_bikes_X = df_stations.drop(['name','postcode','day','timestamp','id','minute','free_bikes','empty_slots', 'is_free_bike', 'is_free_slot'], axis = 1)\ndf_bikes_y = df_stations['is_free_bike']\n\n\ndf_slot_X = df_stations.drop(['name','postcode','day','timestamp','id','minute','free_bikes','empty_slots','is_free_bike', 'is_free_slot'], axis = 1)\ndf_slot_y = df_stations['is_free_slot']","065ff1e7":"#Building the regression model to free bikes\n#Building the regression model to free slots\n\n#Trainig the model for the slots\nX_train_bk, X_test_bk, y_train_bk, y_test_bk = model_selection.train_test_split(df_bikes_X, df_bikes_y ,test_size=0.2)\npred_bikes = []\n\nmodel_bk = LinearRegression()\nmodel_bk.fit(X_train_bk, y_train_bk)\npred_bikes = model_bk.predict(X_test_bk)\ncnf_matrix_bikes = confusion_matrix(y_test_bk,pred_bikes.round())\n\n#confusion matrix to see the how efficent is the model\nprint(X_train_bk.head)\n\ndef predicting_bikes(X):\n    model_bk = LinearRegression()\n    model_bk.fit(X_train_bk, y_train_bk)\n    y = model_bk.predict(X) \n    return y\n\n#Trainig the model for the slots\nX_train_sl, X_test_sl, y_train_sl, y_test_sl = model_selection.train_test_split(df_slot_X, df_slot_y ,test_size=0.2)\npred_slot = []\nmodel_sl = LinearRegression()\nmodel_sl.fit(X_train_sl, y_train_sl)\npred_slot = model_sl.predict(X_test_sl)\ncnf_matrix_slot =confusion_matrix(y_test_sl,pred_slot.round())\nprint(cnf_matrix_slot)\n\ndef predicting_slot(X):\n    model_sl = LinearRegression()\n    model_sl.fit(X_train_sl, y_train_sl)\n    y = model_sl.predict(X)\n    return y","d19f2070":"#Now we want to know if there are free bikes and free slots given 2 points, date and time\n#Let's see how our regression model predict the availability of the bikes\n#I've added a field day_of_week to help the model to do a better prediction\n#day_of_week: {0:'monday', 1:'thuesday', 2:'Wensday' , 3:'thursday', 4:'friday', 5:'saturday', 6:'sunday'}\ndef calculate_avalilability_pred(hour, minute, time_of_use_min, day_of_week, point_A, point_B):\n    #Let's search the ID of the station A\n    id_A = df_stations[df_stations['name'] == point_A] \n    id_dwh_A = df_stations[df_stations['id'] == id_A['id'].iloc[0]]\n    \n    #Let's round the minutes, for a better prediction we are grouping the data each 5 minutes\n    minute = round(minute\/5)*5\n    \n    #Preparing the data to predict the bikes\n    X_bike = pd.DataFrame({'latitude':[id_dwh_A.latitude.max()],'longitude':[id_dwh_A.longitude.max()], 'id_dwh':[id_dwh_A.id_dwh.max()],'hour':[hour],'minute':[minute], 'dayofweek':[day_of_week]})    \n    \n    y_bike = predicting_bikes(X_bike)\n    \n    #Let's search the ID of the station B\n    id_B = df_stations[df_stations['name'] == point_B]  \n    id_dwh_B = df_stations[df_stations['id'] == id_B['id'].iloc[0]]    \n    \n    #Calculating the ETA (estimate time of arrival) to predict the slots\n    min_B = minute+time_of_use_min\n    if min_B >59:\n        hour+=1\n        min_B= 60-min_B\n        \n    X_slot = pd.DataFrame({'latitude':[id_dwh_B.latitude.max()],'longitude':[id_dwh_B.longitude.max()], 'id_dwh':[id_dwh_B.id_dwh.max()],'hour':[hour],'minute':[min_B], 'dayofweek':[day_of_week]})\n    y_slot = predicting_slot(X_slot)\n    \n    print('We will find a free bike?: ' + 'Yes' if (y_bike>=1) else 'No' )\n\n    print('We will find a free slot?: '+ 'Yes' if (y_slot>=1) else 'No' )\n    ","bf39afad":"calculate_avalilability_pred(10,51,15,2,'C\/ DOCTOR AIGUADER, 2', 'C\/ SARDENYA, 292')","441f5846":"#Building searching functions to find the stations witn a distance x closer from a target (point_B)\n\n#Grouping the geoloc info and the name\ngeoLocs = df_stations.groupby(['latitude','longitude','name'], as_index= False)['id'].count()\n\n#Calculating the distance between the point_A and point_B\n#We are going to use this distance such a parameter to find the others station that are arround the same distance\ndef get_distance(point_A, point_B):\n    id_A = df_stations[df_stations['name'] == point_A] \n    latA = id_A['latitude'].iloc[0]\n    lonA = id_A['longitude'].iloc[0]\n    \n    id_B = df_stations[df_stations['name'] == point_B] \n    latB = id_B['latitude'].iloc[0]\n    lonB = id_B['longitude'].iloc[0]\n    \n    #dist_A = abs(latA) - abs(latB)\n    #dist_B = abs(lonA) - abs(lonB)\n    dist = distance(latA,latB,lonA,lonB)\n    \n    return dist #(abs(dist_A), abs(dist_B))\n\n#Having the distance and the target, let's find the station arround.\ndef get_geoLoc_target(point_B, dist):\n    id_B = df_stations[df_stations['name'] == point_B] \n    latB = id_B['latitude'].iloc[0]\n    lonB = id_B['longitude'].iloc[0]\n    \n    geoLocs['distance']= list(map(lambda v: distance(v[0],latB,v[1],lonB), zip(geoLocs['latitude'], geoLocs['longitude'])))\n\n    res = geoLocs[geoLocs['distance']<= dist]\n    \n    return res\n\ndef distance(x2,x1,y1,y2):\n    dist = math.sqrt( (abs(x2) - abs(x1))**2 + (abs(y2) - abs(y1))**2 )\n    return dist\n\ndef get_stations_arround(point_A, point_B, hour):\n    dist = get_distance(point_A, point_B)\n    res = get_geoLoc_target(point_B, dist)\n    \n    #lets list all the station that have free bikes in a time period (hr)\n    df= df_stations[df_stations['hour']== 9]\n    joined = pd.merge(df, res[['name', 'distance']], on=['name'], how='left')\n    return joined\n\n\n\n#Listing the station \n#This is the destination\nres_st = get_stations_arround('C\/ GOMBAU, 24', 'C\/ CASANOVAS, 67', 8)\nres_st = res_st.groupby(['name','latitude','longitude', 'distance'])['free_bikes'].mean().reset_index()\n\n# This are the 10 closer station from our destination with free bikes\n# We can see that the first values is the origin (distance 0)\nprint(res_st.sort_values(['distance']).head(10))\n\n# This are the 10 farest station fron our destination with free bikes\nprint(res_st.sort_values(['distance'], ascending=False).head(10))\n\n","effedb23":"#Building the map to visualize the stations\n#showing the closest 5\n#res = res_st.sort_values(['distance']).head(55)\n\n#showing the farest 5\nres = res_st.sort_values(['distance'], ascending=False).head(60)\n\n\ndf = res_st[res_st['distance'] == 0]\n\nworld_map = folium.Map(location=[df.iloc[0]['latitude'], df.iloc[0]['longitude']], tiles=\"cartodbpositron\", zoom_start=13,max_zoom=20,min_zoom=2)\nfor i in range(0,len(res)):\n    folium.Circle(\n        location=[res.iloc[i]['latitude'], res.iloc[i]['longitude']],\n        tooltip = \"<h5 style='text-align:center;font-weight: bold'>\"+res.iloc[i]['name']+\"<\/h5>\"+\n                    \"<hr style='margin:10px;'>\"+\n                    \"<ul style='color: #444;list-style-type:circle;align-item:left;padding-left:20px;padding-right:20px'>\"+\n        \"<li>Free bikes: \"+str(round(res.iloc[i]['free_bikes']))+\"<\/li>\"+\n        \"<\/ul>\"\n        ,\n        radius=(int((np.log(res.iloc[i]['free_bikes']+1.00001)))+0.2)*20,\n        #radius=(res.iloc[i]['free_bikes']),\n        color='#ff6600',\n        fill_color='#ff8533',\n        fill=True).add_to(world_map)\n    \n\nfolium.Circle(\nlocation=[df.iloc[0]['latitude'], df.iloc[0]['longitude']],\ntooltip = \"<h5 style='text-align:center;font-weight: bold'>\"+df.iloc[0]['name']+\"<\/h5>\"+\n                    \"<hr style='margin:10px;'>\",\nradius=(int((np.log(res.iloc[i]['free_bikes']+1.00001)))+0.2)*25,\ncolor='blue',\nfill_color='blue',\nfill=True).add_to(world_map)\n\nworld_map","6a4e37c4":"Here is easier to see identify that empty_slots free_bikes  variables have a normal distribution and the others more a categorical behaivour, of course date attributes are categorical, but it nice to notice it in the charts :)","97ae79fb":"Box plots are very useful to see the distribution between categories and its skewness and detect atipical values.\nHere we can see that data is very balanced and too many atipical values, this is due we only have data of 3 days. The free bikes by postal we can identify that there are some station more used, other a special use like the postalcode 08908, it has lo of free bikes all the most of the time, then the postal code 08031 has less free bikes."}}