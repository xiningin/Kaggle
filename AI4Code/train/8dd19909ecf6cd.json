{"cell_type":{"f47c6bdf":"code","31f90cb9":"code","269b3fef":"code","069448eb":"code","88df593f":"code","5bfa2edd":"code","ac8b7d1b":"code","8eb59ad1":"code","ef2d073b":"code","a4d145d9":"code","8ae2cae6":"code","be9b10f9":"code","5020280a":"code","182cef2b":"code","6af762e4":"code","6513214d":"code","2187b969":"code","3855cec5":"code","57b143fb":"code","c613a231":"code","6285797a":"code","a81ca7c1":"code","30ad798b":"code","10b4683c":"code","8b58b9b0":"code","7cd74686":"code","ae2fea62":"code","66518f8a":"code","d72c2ab6":"code","5aff77e6":"code","8bb0d54e":"code","97ffda77":"code","7b8907f5":"code","a2088ba6":"code","d33c6e10":"code","c41686b4":"code","5c9050f6":"code","dd857ee5":"code","b0ae3500":"code","604ae08e":"code","2ee7d132":"code","12b2f32f":"code","b98f1743":"code","9949a471":"code","a2da5928":"code","525ef994":"code","6bcbdd74":"code","a2ef7eb1":"code","67a18b5b":"code","2225aa33":"code","5962f842":"markdown","92efbd8b":"markdown","ce27a491":"markdown","14a9f552":"markdown","5176f51b":"markdown","adf14270":"markdown","15fbb856":"markdown","703b1911":"markdown","22674e99":"markdown","c5d9dec7":"markdown","78a0944e":"markdown","0598c90b":"markdown","c4762af1":"markdown","de227280":"markdown","78a0dc26":"markdown","101dcc6a":"markdown","98effcf3":"markdown","24b6a4d5":"markdown","4cec7e14":"markdown","46b2afba":"markdown","883b68fd":"markdown","81725b79":"markdown","f5bb7093":"markdown","1360b9d2":"markdown","5032e1d1":"markdown","7e205c35":"markdown","606d55fe":"markdown","c9a943f5":"markdown","ba4fa102":"markdown","7dd15001":"markdown","eee6a85c":"markdown","358fc585":"markdown","52da9fdb":"markdown","0345d1f6":"markdown","aae9bf23":"markdown","0ad940de":"markdown","c9356fd1":"markdown","717081d0":"markdown","ad0ce015":"markdown","163fcb77":"markdown","ef3b67dd":"markdown","3ebc2e0f":"markdown","fab0a940":"markdown","ceabbb01":"markdown","cd861901":"markdown","7d5ed6ee":"markdown","abe7df1d":"markdown","a5f436bb":"markdown","3e8af7b8":"markdown","3287f0ac":"markdown","d2712f1f":"markdown","ee0c78b9":"markdown","88f38528":"markdown","74f77fb5":"markdown","e81dd271":"markdown","80680d37":"markdown","bf55a24d":"markdown","35e65bad":"markdown","871b9a94":"markdown","58a95fa9":"markdown"},"source":{"f47c6bdf":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sklearn","31f90cb9":"%matplotlib inline","269b3fef":"data = pd.read_csv(\"\/kaggle\/input\/training_data.csv\")  # Store the contents of the csv file in the variable 'data'\ndata.head()","069448eb":"data.describe()","88df593f":"fig, ((ax1, ax2, ax3)) = plt.subplots(1, 3, sharey=True, figsize=(16,9))\nax1.scatter(data[\"qc [MPa]\"], data[\"z [m]\"], s=5)   # Create the cone tip resistance vs depth plot\nax2.scatter(data[\"Blowcount [Blows\/m]\"], data[\"z [m]\"], s=5)  # Create the Blowcount vs depth plot \nax3.scatter(data[\"Normalised ENTRHU [-]\"], data[\"z [m]\"], s=5) # Create the ENTHRU vs depth plot\n# Format the axes (position, labels and ranges)\nfor ax in (ax1, ax2, ax3):\n    ax.xaxis.tick_top()\n    ax.xaxis.set_label_position('top')\n    ax.grid()\n    ax.set_ylim(50, 0)\nax1.set_xlabel(r\"Cone tip resistance, $ q_c $ (MPa)\")\nax1.set_xlim(0, 120)\nax2.set_xlabel(r\"Blowcount (Blows\/m)\")\nax2.set_xlim(0, 200)\nax3.set_xlabel(r\"Normalised ENTRHU (-)\")\nax3.set_xlim(0, 1)\nax1.set_ylabel(r\"Depth below mudline, $z$ (m)\")\n# Show the plot\nplt.show()","5bfa2edd":"# Select the data where the column 'Location ID' is equal to the location name\nlocation_data = data[data[\"Location ID\"] == \"EK\"]","ac8b7d1b":"fig, ((ax1, ax2, ax3)) = plt.subplots(1, 3, sharey=True, figsize=(16,9))\n# All data\nax1.scatter(data[\"qc [MPa]\"], data[\"z [m]\"], s=5)\nax2.scatter(data[\"Blowcount [Blows\/m]\"], data[\"z [m]\"], s=5)\nax3.scatter(data[\"Normalised ENTRHU [-]\"], data[\"z [m]\"], s=5)\n# Location-specific data\nax1.plot(location_data[\"qc [MPa]\"], location_data[\"z [m]\"], color='red')\nax2.plot(location_data[\"Blowcount [Blows\/m]\"], location_data[\"z [m]\"], color='red')\nax3.plot(location_data[\"Normalised ENTRHU [-]\"], location_data[\"z [m]\"], color='red')\nfor ax in (ax1, ax2, ax3):\n    ax.xaxis.tick_top()\n    ax.xaxis.set_label_position('top')\n    ax.grid()\n    ax.set_ylim(50, 0)\nax1.set_xlabel(r\"Cone tip resistance (MPa)\")\nax1.set_xlim(0, 120)\nax2.set_xlabel(r\"Blowcount (Blows\/m)\")\nax2.set_xlim(0, 200)\nax3.set_xlabel(r\"Normalised ENTRHU (-)\")\nax3.set_xlim(0, 1)\nax1.set_ylabel(r\"Depth below mudline (m)\")\nplt.show()","8eb59ad1":"fig, ((ax1, ax2, ax3)) = plt.subplots(1, 3, figsize=(15,6))\n# All data\nax1.scatter(data[\"qc [MPa]\"], data[\"Blowcount [Blows\/m]\"], s=5)\nax2.scatter(data[\"Normalised ENTRHU [-]\"], data[\"Blowcount [Blows\/m]\"], s=5)\nax3.scatter(data[\"z [m]\"], data[\"Blowcount [Blows\/m]\"], s=5)\n# Location-specific data\nax1.scatter(location_data[\"qc [MPa]\"], location_data[\"Blowcount [Blows\/m]\"], color='red')\nax2.scatter(location_data[\"Normalised ENTRHU [-]\"], location_data[\"Blowcount [Blows\/m]\"], color='red')\nax3.scatter(location_data[\"z [m]\"], location_data[\"Blowcount [Blows\/m]\"], color='red')\nfor ax in (ax1, ax2, ax3):\n    ax.grid()\n    ax.set_ylim(0, 200)\n    ax.set_ylabel(r\"Blowcount (Blows\/m)\")\nax1.set_xlabel(r\"Cone tip resistance (MPa)\")\nax1.set_xlim(0, 120)\nax2.set_xlabel(r\"Normalised ENTRHU (-)\")\nax2.set_xlim(0, 1)\nax3.set_xlabel(r\"Depth below mudline (m)\")\nax3.set_xlim(0, 50)\nplt.show()","ef2d073b":"validation_ids = ['EL', 'CB', 'AV', 'BV', 'EF', 'DL', 'BM']\n# Training data - ID not in validation_ids\ntraining_data = data[~data['Location ID'].isin(validation_ids)]\n# Validation data - ID in validation_ids\nvalidation_data = data[data['Location ID'].isin(validation_ids)]","a4d145d9":"features = ['Normalised ENTRHU [-]']\ncleaned_training_data = training_data.dropna() # Remove NaN values\nX = cleaned_training_data[features]\ny = cleaned_training_data[\"Blowcount [Blows\/m]\"]","8ae2cae6":"from sklearn.linear_model import LinearRegression\nmodel_1 = LinearRegression().fit(X,y)","be9b10f9":"model_1.coef_, model_1.intercept_","5020280a":"plt.scatter(X, y)\nx = np.linspace(0.0, 1, 50)\nplt.plot(x, model_1.intercept_ + model_1.coef_ * x, color='red')\nplt.xlabel(\"Normalised ENTHRU (-)\")\nplt.ylabel(\"Blowcount (Blows\/m)\")\nplt.show()","182cef2b":"model_1.score(X,y)","6af762e4":"plt.scatter(training_data[\"Normalised ENTRHU [-]\"], training_data[\"Blowcount [Blows\/m]\"])\nx = np.linspace(0, 1, 100)\nplt.plot(x, 80 * np.tanh(5 * x - 0.5), color='red')\nplt.xlabel(\"Normalised ENTHRU (-)\")\nplt.ylabel(\"Blowcount (Blows\/m)\")\nplt.ylim([0.0, 175.0])\nplt.show()","6513214d":"Xlin = np.tanh(5 * cleaned_training_data[[\"Normalised ENTRHU [-]\"]] - 0.5)","2187b969":"plt.scatter(Xlin, y)\nplt.xlabel(r\"$ \\tanh(5 \\cdot ENTRHU_{norm} - 0.5) $\")\nplt.ylabel(\"Blowcount (Blows\/m)\")\nplt.ylim([0.0, 175.0])\nplt.show()","3855cec5":"model_2 = LinearRegression().fit(Xlin, y)","57b143fb":"model_2.coef_, model_2.intercept_","c613a231":"plt.scatter(X, y)\nx = np.linspace(0.0, 1, 50)\nplt.plot(x, model_2.intercept_ + model_2.coef_ * (np.tanh(5*x - 0.5)), color='red')\nplt.xlabel(\"Normalised ENTHRU (-)\")\nplt.ylabel(\"Blowcount (Blows\/m)\")\nplt.ylim([0.0, 175])\nplt.show()","6285797a":"model_2.score(Xlin, y)","a81ca7c1":"enhanced_data = pd.DataFrame() # Create a dataframe for the data enhanced with the shaft friction feature\nfor location in training_data['Location ID'].unique(): # Loop over all unique locations\n    locationdata = training_data[training_data['Location ID']==location].copy() # Select the location-specific data\n    # Calculate the shaft resistance feature\n    locationdata[\"Rs [kN]\"] = \\\n        (np.pi * locationdata[\"Diameter [m]\"] * locationdata[\"z [m]\"].diff() * locationdata[\"qc [MPa]\"]).cumsum()\n    enhanced_data = pd.concat([enhanced_data, locationdata]) # Combine data for the different locations in 1 dataframe","30ad798b":"fig, ((ax1, ax2)) = plt.subplots(1, 2, sharey=True, figsize=(12,6))\nax1.scatter(enhanced_data[\"qc [MPa]\"], enhanced_data[\"Blowcount [Blows\/m]\"])\nax2.scatter(enhanced_data[\"Rs [kN]\"], enhanced_data[\"Blowcount [Blows\/m]\"])\nx = np.linspace(0.0, 12000, 50)\nax2.plot(x, 85 * (np.tanh(0.001*x-1)), color='red')\nax1.set_xlabel(\"Cone tip resistance (MPa)\")\nax2.set_xlabel(\"Shaft resistance (kN)\")\nax1.set_ylabel(\"Blowcount (Blows\/m)\")\nax2.set_ylabel(\"Blowcount (Blows\/m)\")\nax1.set_ylim([0.0, 175])\nplt.show()","10b4683c":"features = [\"Rs [kN]\"]\nX = enhanced_data.dropna()[features]\ny = enhanced_data.dropna()[\"Blowcount [Blows\/m]\"]\nXlin = np.tanh((0.001 * X) - 1)","8b58b9b0":"model_3 = LinearRegression().fit(Xlin, y)","7cd74686":"model_3.intercept_, model_3.coef_","ae2fea62":"plt.scatter(X, y)\nx = np.linspace(0.0, 12000, 50)\nplt.plot(x, model_3.intercept_ + model_3.coef_ * (np.tanh(0.001*x - 1)), color='red')\nplt.xlabel(\"Shaft resistance (kN)\")\nplt.ylabel(\"Blowcount (Blows\/m)\")\nplt.ylim([0.0, 175])\nplt.show()","66518f8a":"model_3.score(Xlin, y)","d72c2ab6":"plt.scatter(data[\"z [m]\"], data[\"Blowcount [Blows\/m]\"])\nz = np.linspace(0,35,100)\nplt.plot(z, 100 * np.tanh(0.1 * z - 0.5), color='red')\nplt.ylim([0, 175])\nplt.xlabel(\"Depth (m)\")\nplt.ylabel(\"Blowcount (Blows\/m)\")\nplt.show()","5aff77e6":"enhanced_data[\"linearized ENTHRU\"] = np.tanh(5 * enhanced_data[\"Normalised ENTRHU [-]\"] - 0.5)\nenhanced_data[\"linearized Rs\"] = np.tanh(0.001 * enhanced_data[\"Rs [kN]\"] - 1)\nenhanced_data[\"linearized z\"] = np.tanh(0.1 * enhanced_data[\"z [m]\"] - 0.5)\nlinearized_features = [\"linearized ENTHRU\", \"linearized Rs\", \"linearized z\"]","8bb0d54e":"X = enhanced_data.dropna()[linearized_features]\ny = enhanced_data.dropna()[\"Blowcount [Blows\/m]\"]\nmodel_4 = LinearRegression().fit(X,y)","97ffda77":"model_4.score(X, y)","7b8907f5":"model_4.intercept_, model_4.coef_","a2088ba6":"predictions = model_4.predict(X)\npredictions","d33c6e10":"fig, ((ax1, ax2, ax3)) = plt.subplots(1, 3, figsize=(15,6))\n# Measurements\nax1.scatter(enhanced_data[\"Rs [kN]\"], enhanced_data[\"Blowcount [Blows\/m]\"], s=5)\nax2.scatter(enhanced_data[\"Normalised ENTRHU [-]\"], enhanced_data[\"Blowcount [Blows\/m]\"], s=5)\nax3.scatter(enhanced_data[\"z [m]\"], enhanced_data[\"Blowcount [Blows\/m]\"], s=5)\n# Predictions\nax1.scatter(enhanced_data.dropna()[\"Rs [kN]\"], predictions, color='red')\nax2.scatter(enhanced_data.dropna()[\"Normalised ENTRHU [-]\"], predictions, color='red')\nax3.scatter(enhanced_data.dropna()[\"z [m]\"], predictions, color='red')\nfor ax in (ax1, ax2, ax3):\n    ax.grid()\n    ax.set_ylim(0, 175)\n    ax.set_ylabel(r\"Blowcount (Blows\/m)\")\nax1.set_xlabel(r\"Shaft resistance (kN)\")\nax1.set_xlim(0, 12000)\nax2.set_xlabel(r\"Normalised ENTRHU (-)\")\nax2.set_xlim(0, 1)\nax3.set_xlabel(r\"Depth below mudline (m)\")\nax3.set_xlim(0, 50)\nplt.show()","c41686b4":"# Create a copy of the dataframe with location-specific data\nvalidation_data_CB = validation_data[validation_data[\"Location ID\"] == \"CB\"].copy()","5c9050f6":"# Calculate the shaft resistance feature and put it in the column 'Rs [kN]'\nvalidation_data_CB[\"Rs [kN]\"] = \\\n    (np.pi * validation_data_CB[\"Diameter [m]\"] * \\\n     validation_data_CB[\"z [m]\"].diff() * validation_data_CB[\"qc [MPa]\"]).cumsum()","dd857ee5":"# Calculate linearized ENTHRU, Rs and z\nvalidation_data_CB[\"linearized ENTHRU\"] = np.tanh(5 * validation_data_CB[\"Normalised ENTRHU [-]\"] - 0.5)\nvalidation_data_CB[\"linearized Rs\"] = np.tanh(0.001 * validation_data_CB[\"Rs [kN]\"] - 1)\nvalidation_data_CB[\"linearized z\"] = np.tanh(0.1 * validation_data_CB[\"z [m]\"] - 0.5)","b0ae3500":"# Create the matrix with n samples and 3 features\nX_validation = validation_data_CB.dropna()[linearized_features]\n# Create the vector with n observations of blowcount\ny_validation = validation_data_CB.dropna()[\"Blowcount [Blows\/m]\"]","604ae08e":"# Calculate the R2 score for the validation data\nmodel_4.score(X_validation, y_validation)","2ee7d132":"validation_predictions = model_4.predict(X_validation)","12b2f32f":"fig, ((ax1, ax2, ax3)) = plt.subplots(1, 3, figsize=(15,6))\n# All data\nax1.plot(validation_data_CB[\"qc [MPa]\"], validation_data_CB[\"z [m]\"])\nax2.plot(validation_data_CB[\"Normalised ENTRHU [-]\"], validation_data_CB[\"z [m]\"])\nax3.plot(validation_data_CB[\"Blowcount [Blows\/m]\"], validation_data_CB[\"z [m]\"])\n# Location-specific data\nax3.scatter(validation_predictions, validation_data_CB.dropna()[\"z [m]\"], color='red')\nfor ax in (ax1, ax2, ax3):\n    ax.grid()\n    ax.xaxis.tick_top()\n    ax.xaxis.set_label_position('top')\n    ax.set_ylim(30, 0)\n    ax.set_ylabel(r\"Depth below mudline (m)\")\nax1.set_xlabel(r\"Cone tip resistance (MPa)\")\nax1.set_xlim(0, 120)\nax2.set_xlabel(r\"Normalised ENTRHU (-)\")\nax2.set_xlim(0, 1)\nax3.set_xlabel(r\"Blowcount (Blows\/m)\")\nax3.set_xlim(0, 175)\nplt.show()","b98f1743":"final_data = pd.read_csv(\"\/kaggle\/input\/validation_data.csv\")\nfinal_data.head()","9949a471":"enhanced_final_data = pd.DataFrame() # Create a dataframe for the final data enhanced with the shaft friction feature\nfor location in final_data['Location ID'].unique(): # Loop over all unique locations\n    locationdata = final_data[final_data['Location ID']==location].copy() # Select the location-specific data\n    # Calculate the shaft resistance feature\n    locationdata[\"Rs [kN]\"] = \\\n        (np.pi * locationdata[\"Diameter [m]\"] * locationdata[\"z [m]\"].diff() * locationdata[\"qc [MPa]\"]).cumsum()\n    enhanced_final_data = pd.concat(\n        [enhanced_final_data, locationdata]) # Combine data for the different locations in 1 dataframe","a2da5928":"enhanced_final_data.dropna(inplace=True) # Drop the rows containing NaN values and overwrite the dataframe","525ef994":"enhanced_final_data[\"linearized ENTHRU\"] = np.tanh(5 * enhanced_final_data[\"Normalised ENTRHU [-]\"] - 0.5)\nenhanced_final_data[\"linearized Rs\"] = np.tanh(0.001 * enhanced_final_data[\"Rs [kN]\"] - 1)\nenhanced_final_data[\"linearized z\"] = np.tanh(0.1 * enhanced_final_data[\"z [m]\"] - 0.5)","6bcbdd74":"# Create the matrix with n samples and 3 features\nX = enhanced_final_data[linearized_features]","a2ef7eb1":"final_predictions = model_4.predict(X)","67a18b5b":"enhanced_final_data[\"Blowcount [Blows\/m]\"] = final_predictions","2225aa33":"enhanced_final_data[[\"ID\", \"Blowcount [Blows\/m]\"]].to_csv(\"sample_submission_linearmodel.csv\", index=False)","5962f842":"We can isolate the data for a single location by selecting this data from the dataframe with all data. As an example, we can do this for location <i>EK<\/i>.","92efbd8b":"### 2.2. Summary statistics\n\nWe can easily create summary statistics of each column using the ```describe()``` function on the data. This gives us the number of elements, mean, standard deviation, minimum, maximum and percentiles of each column of the data.\n\nWe can see that there are more PCPT data points than hammer data points. This makes sense as there is soil data available above the pile self-weight penetration and below the final pile penetration. The pile data is defined in the self-weight penetration part of the profile, so there are slightly more pile data points than hammer record data points.","ce27a491":"## 5. Prediction event submission\n\nWhile a number of locations are held out during the training process to check if the model generalises well, the model will have to be applied to unseen data and predictions will need to be submitted.\n\nThe validation data which will be used for the ranking of submissions is provided in the file ```validation_data.csv```.","14a9f552":"When plotting the linearized data against the blowcount, we can see that a linear relation is much more appropriate.","5176f51b":"In the following sections, we will explore ways to improve our model.","adf14270":"## 6. Conclusions\n\nThis tutorial shows how a basic machine learning model can be built up. The workflow shows the importance of integrating engineering knowledge and to ensure that the models make physical sense.\n\nA machine learning workflow is not fundamentally different from a conventional workflow for fitting a semi-empirical model. The methods available in scikit-learn make the process scaleable to large datasets with only a few lines of code.\n\nThe workflow will always consist of the following steps:\n\n   - Select features for the machine learning. Use engineering knowledge to construct features which have a better correlation with the target variable under consideration;\n   - Split the dataset in a training dataset and a validation dataset;\n   - Select the type of machine learning model you want to use (e.g. Linear regression, Support Vector Machines, Neural Nets, ...);\n   - Train the model using the training data;\n   - Validate the model on the validation data;\n\nIf the validation is successful, the model can be used for predictions on unseen data. These predictions can then be submitted as an entry in the competition.","15fbb856":"## 3. Basics of machine learning\n\nThe goal of the prediction exercise is to define a model relating the input (soil data, hammer energy, pile data) with the output (blowcount).\n\nIn ML terminology, we call the inputs (the columns of the dataset except for the blowcount) <i>features<\/i>. The blowcount is the <i>target variable<\/i>. Each row in the dataframe represents a <i>sample<\/i>, a combination of feature values for which the output is known. Data for which a value of the target variable is not yet available is called <i>unseen data<\/i>.\n\nBefore we dive into the code for generating ML models, let's discuss some of the concepts in more detail.","703b1911":"### 4.3. Using engineering knowledge\n\nWe know from engineering considerations on the pile driving problem that the soil resistance to driving (SRD) can be expressed as the sum of shaft friction and end bearing resistance. The shaft friction can be expressed as the integral of the unit shaft friction over the pile circumference and length.\n\nIf we make the simplifying assumption that there is a proportionality between the cone resistance and the unit shaft friction ($ f_s = \\alpha \\cdot q_c $), we can write the shaft resistance as follows:\n\n$$ R_s = \\int_{0}^{L} \\alpha \\cdot q_c \\cdot \\pi \\cdot D \\cdot dz \\approx \\alpha \\cdot \\pi \\cdot D \\cdot \\sum q_{c,i} \\cdot \\Delta z $$\n\nWe can create an additional feature for this. Creating features based on our engineering knowledge will often help us to introduce experience in a machine learning algorithm.\n\nTo achieve this, we will create a new dataframe using our training data. We will iteration over all locations in the training data and calculate the $ R_s $ feature using a cumulative sum function. We will then put this data together for all locations.","22674e99":"### 4.4. Using multiple features\n\nThe power of machine learning algorithms is that you can experiment with adding multiple features. Adding a feature can improve you model if it has a meaningful relation with the output.\n\nWe can use our linearized relation with normalised ENTHRU, shaft resistance and we can also linearize the variation of blowcount with depth:\n\n$$ BLCT = 100 \\cdot \\tanh \\left( \\frac{z}{10} - 0.5 \\right) $$","c5d9dec7":"We can extract the linearized features which are required for the predictions:","78a0944e":"At this point, our model has been trained with the data and the coefficients are known. $ a_0 $ is called the intercept and $ a_1 $ to $ a_n $ are stored in ```coef_```. Because we only have one feature, ```coef_``` only returns a single value.","0598c90b":"Our model with the combined features will take the following mathematical form:\n\n$$ BLCT = a_0 + a_1 \\cdot \\tanh \\left( 5 \\cdot \\text{ENTHRU}_{norm} - 0.5 \\right) + a_2 \\cdot \\tanh \\left( \\frac{R_s}{1000} - 1 \\right) + a_3 \\cdot \\tanh \\left( \\frac{z}{10} - 0.5 \\right) $$\n\nWe can create the necessary features in our dataframe:","c4762af1":"We can plot these predictions together with the data. We can see that the model follows the general trend of the data fairly well. There is still significant scatter around the trend.","de227280":"We can plot the data to see that the clustering of our SRD shaft resistance feature vs blowcount is much better than the clustering of $ q_c $ vs blowcount. We can also linearize the relation between shaft resistance and blowcount.\n\nWe can propose the following relation:\n\n$$ BLCT = 85 \\cdot \\tanh \\left( \\frac{R_s}{1000} - 1 \\right) $$","78a0dc26":"### 3.2. Model fitting\n\nMachine learning has disadvantages which can lead to problematic situations if the techniques are misused. One of these disadvantages is that the ML algorithm will always find a fit, even if it is a poor one.\n\nThe figure below shows an example with data showing a non-linear trend between input and output with some scatter around a trend. We can identify the following situations:\n\n   - Underfitting: If we use a linear model for this data, we are not capturing the trend. The model predictions will be poor;\n   - Good fit: If we formulate a model (quadratic in this case) which captures the general trend but allows variations around the trend, we obtain a good fit. In geotechnical problems, we will never get a perfect a fit but if we identify the influence of the input parameters in a consistent manner, we can build good-quality models;\n   - Overfitting: If we have a model which perfectly fits all known data points, the prediction for an unseen data point will be poor. The influence of each measurement on the model is too important. The model overfits the data and does not capture the general trends. It just represents the data on which it was trained.","101dcc6a":"### 3.3. Model metrics\n\nTo prevent misuse of ML models, we will look at certain model metrics to check the quality. There are several model metrics. Two of the more common ones are the <b>Mean Squared Error (MSE)<\/b> and the <b>coefficient of determination ($ R^2 $)<\/b>.\n\nThe MSE-value is the normalised sum of quadratic differences. The closer it is to 0, the better the fit.\n\n$$ \\text{MSE}(y, \\hat{y}) = \\frac{1}{n_\\text{samples}} \\sum_{i=0}^{n_\\text{samples} - 1} (y_i - \\hat{y}_i)^2. $$\n\n$ \\hat{y}_i $ is the predicted value of the i-th sample and $ y_i $ is the true (measured) value.\n\nThe coefficient of determination ($ R^2 $) is a measure for a measure of how well future samples are likely to be predicted by the model. A good model has an $ R^2 $-value which is close to 1.\n\n$$ R^2(y, \\hat{y}) = 1 - \\frac{\\sum_{i=0}^{n_{\\text{samples}} - 1} (y_i - \\hat{y}_i)^2}{\\sum_{i=0}^{n_\\text{samples} - 1} (y_i - \\bar{y})^2} \\quad \\text{where} \\ \\bar{y} =  \\frac{1}{n_{\\text{samples}}} \\sum_{i=0}^{n_{\\text{samples}} - 1} y_i$$\n\nIn the example, we will see how we can easily calculate these metrics from the data using the functions available in the ML Python package ```scikit-learn```.","98effcf3":"We can create a linearized feature:\n\n$$ (\\text{ENTHRU})_{lin} = \\tanh(5 \\cdot \\text{ENTHRU}_{norm} - 0.5) $$","24b6a4d5":"We then proceed to filter the NaN values from the data and fit a linear model.","4cec7e14":"However, we don't need to explicitly write down the mathematical shape of the model to use it in the code. We can make predictions using the fitted model straightaway.","46b2afba":"We can plot the data for this location on top of the general data cloud.","883b68fd":"We can see that pile driving started from 5m depth and continued until a depth of 30m, when the pile tip reached a sand layer with $ q_c $ > 60MPa.\n\nFeel free to investigate the soil profile and driving data for the other locations by changing the location ID.","81725b79":"For the purpose of the prediction event, we are interested in the variation of blowcount with $ q_c $, hammer energy, ... We can also generate plots to see the correlations. The data shows significant scatter and non-linear behaviour. We will take this into account for our machine learning model.","f5bb7093":"### 3.1. Machine learning techniques\n\nML combines several data science techniques under one general denominator. We can discern the following families:\n\n   - Classification: Predict the value of a discrete target variable of a data point based on its features\n   - Regression: Predict the value of a continuous target variable based on its features\n   - Clustering: Identify groups of similar data points based on their features\n   - Dimensionality reduction: Identify the features with the greatest influence on the data\n   \nThe first techniques are examples of <i>supervised learning<\/i>. We will use data where the output has been observed and use that to <i>train<\/i> the ML model. Training a model is essentially the optimisation of the coefficients of a mathematical model to minimise the difference between model predictions and observed values. Such a trained algorithm is then capable of making predictions for unseen data.\n\nThis concept is not fundamentally different from any other type of data-driven modelling. The main advantage of the ML approach is the speed at which the models can be trained and the many types of models available to the engineer.\n\nIn our example of pile driving, we have a <b>regression<\/b> problem where we are training a model to relate features (soil data, hammer energy and pile data) with a continuous target variable (blowcount).","1360b9d2":"### 4.4. Model predictions\n\nThe linear regression model always allows us to write down the mathematical form of the model. We can do so here by filling in the intercept ($ a_0 $) a coefficients $ a_1 $, $ a_2 $ and $ a_3 $ in the equation above.","5032e1d1":"We can plot the data with our trained fit. We can see that the fit follows a general trend but the quality is not great.","7e205c35":"We can fit another linear model using this linearized feature.","606d55fe":"### 2.3. Plotting\n\nWe can plot the cone tip resistance, blowcount and normalised ENTHRU energy for all locations to show how the data varies with depth. We can generate this plot using the ```Matplotlib``` package.","c9a943f5":"### 4.2. Linearizing features\n\nWhen using ENTRHU as our model feature, we can see that a linear model is not the most appropriate choice as the relation between blowcount and ENTRHU is clearly non-linear. However, we can <i>linearize<\/i> features.\n\nFor example, we can propose a relation using using a tangent hyperbolic law, which seems to fit better with the data.","ba4fa102":"We can check the intercept and the model coefficient:","7dd15001":"We can then linearize the features as before:","eee6a85c":"# ISFOG 2020 - Pile driving prediction event\n\nData science techniques are rapidly transforming businesses in a broad range of sectors. While marketing and social applications have received most attention to date, geotechnical engineering can also benefit from data science tools that are now readily available. \n\nIn the context of the ISFOG2020 conference in Austin, TX, a prediction event is launched which invites geotechnical engineers to share knowledge and gain hands-on experience with machine learning models.\n\nThis Jupyter notebook shows you how to get started with machine learning (ML) tools and creates a simple ML model for pile driveability. Participants are encouraged to work through this initial notebook to get familiar with the dataset and the basics of ML.","358fc585":"## 7. Can you do better?\n\nThis tutorial shows the creation of a simple linear model. This is only one possible model from the [many possible regression models available in scikit-learn](https:\/\/scikit-learn.org\/stable\/supervised_learning.html).\n\nAfter getting familiar with the basic concepts, participants are invited to suggest improved blowcount prediction models.","52da9fdb":"We can assign these predictions to the column ```Blowcount [Blows\/m]``` in our resulting dataframe.","0345d1f6":"We can now create a linear model. We need to import this type of model from the scikit-learn package. We can fit the linear model to the data using the ```fit()``` method.","aae9bf23":"The predictions (red dots) can be plotted against the actual observed blowcounts. The cone resistance and normalised ENTHRU are also plotted for information.\n\nThe predictions are reasonable and follow the general trend fairly well. In the layer with lower cone resistance below (10-15m depth), there is an overprediction of blowcount. This is due to the relatively limited amount of datapoints with low cone resistance in the training data. Further model refinement could address this issue. ","0ad940de":"The cone resistance data shows that the site mainly consists of sand of varying relative density. In certain profiles, clay is present below 10m. There are also locations with very high cone resistance (>70MPa).\n\nThe blowcount profile shows that blowcount is relatively well clustered around a generally increasing trend with depth. The normalised ENTHRU energy is also increasing with depth.","c9356fd1":"We can now fit a linear model with three features. The matrix $ X $ is now an $ n \\times 3 $ matrix ($ n $ samples and 3 features).","717081d0":"### 3.4. Model validation\n\nWhen building a ML model, we will only use a subset of the data for training the model. The other subset is deliberately excluded from the learning process and used to <i>validate<\/i> the model. The trained model is applied on the unseen data of the validation dataset and the accuracy of the predictions is checked, resulting in a validation score representing the accuracy of the model for the validation dataset.\n\nIf our trained model is of good quality, the predictions for the validation dataset will be close to the measured values.\n\nWe will partition our data in a training dataset and a validation dataset. For the validation data set, we use seven piles. The other piles will be used as the training dataset.","ad0ce015":"We can also calculate the $ R^2 $ score for our training data. The score is below 0.5 and it goes without saying that this model needs improvement.","163fcb77":"## 1. Importing packages\n\nThe Python programming language works with a number of packages. We will work with the ```Pandas``` package for data processing, ```Matplotlib``` for data visualisation and ```scikit-learn``` for the ML. We will also make use of the numerical package ```Numpy```. These package come pre-installed with the Anaconda distribution (see installation guide). Each package is extensively documented with online documentation, tutorials and examples. We can import the necessary packages with the following code.\n\n<b>Note<\/b>: Code cells can be executed with <i>Shift+Enter<\/i> or by using the run button in the toolbar at the top. Note that code cells need to be executed from top to bottom. The order of execution is important.","ef3b67dd":"During the prediction event, the goal is to fit a machine learning model which further refines the model developed above.","3ebc2e0f":"We can write this file to a csv file. For the submission, we only need the ```ID``` and ```Blowcount [Blows\/m]``` column. ","fab0a940":"### 4.5 Model validation\n\nAt the start of the exercise, we excluded a couple of locations from the fitting to check how well the model would perform for these unseen locations.\n\nWe can now perform this validation exercise by calculating the shaft resistance and linearizing the model features. We can then make predictions with our model developed above.\n\nWe will illustrate this for location CB.","ceabbb01":"## 4. Basic machine learning example: Linear modelling\n\nThe most basic type of ML model is a linear model. We are already using linear models in a variety of applications and often fit them without making use of ML techniques. The general equation for a linear model is given below for a model with $ N $ features:\n\n$$ y = a_0 + a_1 \\cdot x_1 + a_2 \\cdot x_2 + ... + a_N \\cdot x_N + \\epsilon $$\n\nwhere $ \\epsilon $ is the estimation error.\n\nBased on the training dataset, the value of the coefficients ($ a_0, a_1, ..., a_N $) is determined using optimisation techniques to minimise the difference between measured and predicted values. As the equation shows, a good fit will be obtained when the relation between output and inputs is truly linear. If there are non-linearities in the data, the fit will be less good.\n\nWe will illustrate how a linear regression machine learning model is generated from the available driving data.","cd861901":"## 2. Pile driving data\n\nThe dataset is kindly provided by [Cathie Group](http:\/\/www.cathiegroup.com).\n\n### 2.1. Importing data\n\nThe first step in any data science exercise is to get familiar with the data. The data is provided in a csv file (```training_data.csv```). We can import the data with Pandas and display the first five rows using the ```head()``` function.","7d5ed6ee":"We can print the coefficients of the linear model and visualise the fit.","abe7df1d":"The process of validation can be automated. The [scikit-learn documentation](https:\/\/scikit-learn.org\/stable\/modules\/cross_validation.html) has further details on this.","a5f436bb":"We can calculate the predicted blowcounts for our validation data.","3e8af7b8":"We can see that the target variable (```Blowcount [Blows\/m]```) is not provided and we need to predict it.\n\nSimilary to the previous process, we will calculate the shaft resistance to enhance our data.","3287f0ac":"### 4.1. Linear model based on normalised ENTHRU only\n\nThe simplest linear model depends on only one feature. We can select the normalised energy transmitted to the pile (ENTRHU) as the only feature for illustration purposes.\n\nThe mathematical form of the model can be written as:\n\n$$ BLCT = a_o + a_1 \\cdot \\text{ENTRHU}_{norm} + \\epsilon $$\n\nWe will create a dataframe $ X $ with only the normalised ENTHRU feature data and we will put the observed values of the target variable (blowcount) in the vector $ y $.\n\nNote that machine learning algorithms will raise errors when NaN values are provided. We need to ensure that we remove such values. We can creata a dataframe ```cleaned_training_data``` which only contains rows with no NaN values.","d2712f1f":"With these concepts in mind, we can start building up a simple ML model.","ee0c78b9":"The model with the linearized feature can then be written as:\n\n$$ BLCT = a_0 + a_1 \\cdot (\\text{ENTHRU})_{lin} $$ \n\nWe can visualize the fit.","88f38528":"We can calculate the $ R^2 $ score. The score is slightly better compared to our previous model. Given the scatter in the data, this score is already a reasonable value.","74f77fb5":"The data has 12 columns, containing PCPT data ($ q_c $, $ f_s $ and $ u_2 $), recorded hammer data (blowcount, normalised hammer energy, normalised ENTHRU and total number of blows), pile data (diameter, bottom wall thickness and pile final penetration). A unique ID identifies the location and $ z $ defines the depth below the mudline.\n\nThe data has already been resampled to a regular grid with 0.5m grid intervals to facilitate the further data handling.\n\nThe hammer energy has been normalised using the same reference energy for all piles in this prediction exercise.\n\nWe can see that there is no driving data in the first five rows (NaN values), this is because driving only started after a given self-weight penetration of the pile.","e81dd271":"Given our fitted model, we can now calculate the $ R^2 $ score for our validation data. The score is relatively high and we can conclude that the model generalises well. If this validation score would be low, we would have to re-evaluate our feature selection.","80680d37":"## 8. Further reading\n\nThe internet has a large amount of information available on machine learning. Here are a couple of suggestions to guide your reading:\n\n   - [scikit-learn documentation](https:\/\/scikit-learn.org\/stable\/tutorial\/basic\/tutorial.html): The scikit-learn package has extensive documentation and provides good general-purpose tutorials;\n   - [10 minutes to Pandas](http:\/\/pandas.pydata.org\/pandas-docs\/stable\/getting_started\/10min.html): The Pandas package is used extensively in this tutorial to facilitate the data processing. Getting to grips with Pandas is a good idea for every aspiring data enthousiast. The Pandas documentation is extensive and this guide provides you with a good overview of the capabilities of the package;\n   - [Towards data science](https:\/\/towardsdatascience.com\/): A blog with frequent posts on data science topics with contributions for the novice and advanced data scientist. ","bf55a24d":"We can check the $ R^2 $ model score. By linearizing the normalised ENTHRU energy, we have improved our $ R^2 $ score and are thus fitting a model which better describes our data.","35e65bad":"The fit looks reasonable and this is also reflected in the $ R^2 $ score which is just greater than 0.6. We have shown that using engineering knowledge can greatly improve model quality.","871b9a94":"A NaN value is generated at the pile top, we can remove any NaN values using the ```dropna``` method on the DataFrame.","58a95fa9":"We can make the predictions using our final model:"}}