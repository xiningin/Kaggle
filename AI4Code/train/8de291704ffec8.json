{"cell_type":{"44355b1a":"code","320c914c":"code","44be522c":"code","d9e3c943":"code","12d0e6f5":"code","5049776f":"code","208035bd":"code","416e5bde":"code","e077033f":"code","e9e45f7d":"code","e5fcf6a6":"code","f32b3b93":"code","2ebd4a33":"code","d858186e":"code","5b1589e3":"code","d8913189":"code","71c57740":"code","494caa85":"code","b9f4ef54":"code","7b33e611":"code","7ec9c91a":"code","796b5a76":"code","11926891":"code","d3e374ab":"code","64e13078":"markdown","cd380029":"markdown","dbbf118b":"markdown","b792c40a":"markdown","fef471fb":"markdown","cdffd0c1":"markdown","1e4ca3a7":"markdown","e2e1eb69":"markdown","165c5faa":"markdown","4ba0b3e8":"markdown","17e0dca3":"markdown","7511c979":"markdown","cff75412":"markdown","257037b1":"markdown","bd1b054e":"markdown","89cd7bc9":"markdown","cb7602c6":"markdown","5433cbab":"markdown"},"source":{"44355b1a":"import networkx as nx\nimport numpy as np\nfrom matplotlib import figure\nimport matplotlib.pyplot as plt\nimport random","320c914c":"G = nx.complete_graph(20)\nlen(G)","44be522c":"G.size()","d9e3c943":"nx.draw(G, with_labels=True, font_weight='bold')","12d0e6f5":"# Number of nodes\nNum_nodes = 30\n\n# Create graph\nH = nx.Graph()\n\nvotes = [+1,-1]\n\n# Create the nodes\nfor i in range(Num_nodes):\n    H.add_node(i, vote=random.choice(votes))","5049776f":"# Initialize nodes randomly and put different colors to each vote\ncolor_map = []\nfor node, data in H.nodes(data=True):\n    if data['vote'] == +1:\n        color_map.append(0.25)  # blue color\n    elif data['vote'] == -1:\n        color_map.append(0.9)  # red color\n\n# Draw the Graph\nnx.draw(H, vmin=0, vmax=1, cmap=plt.cm.jet, node_color=color_map, with_labels=True)\nplt.show()","208035bd":"# Add one and only one connection for each pair of nodes\nfor i in range(len(H)):\n    for j in range(i+1,len(H)):\n        H.add_edge(i,j)","416e5bde":"nx.draw(H, vmin=0, vmax=1, cmap=plt.cm.jet, node_color=color_map, with_labels=True)\nplt.show()","e077033f":"def repaint(H):\n    '''\n    It takes a network and it paints its nodes with different colors dependent on their votes\n    \n    Input:\n    - H (network): our network\n    \n    Output:\n    - color_map: The new artwork of our labels\n    '''\n    \n    # Initialize nodes randomly and put different colors to each vote\n    color_map = []\n    for node, data in H.nodes(data=True):\n        if data['vote'] == +1:\n            color_map.append(0.25)  # blue color\n        elif data['vote'] == -1:\n            color_map.append(0.9)  # red color\n            \n    return color_map","e9e45f7d":"# Initialization\nNsteps = 10000\nq = 7\nviz_step = 1000\nepsilon = 0.25\n\nNplus = 0\n    \nfor node, data in H.nodes(data=True):\n    if data['vote'] == +1:\n        Nplus = Nplus + 1\n\nc = Nplus \/ H.number_of_nodes()\n\nc_list=[c]\n\n# An array with all the possible nodes\nNodes = list(range(1,Num_nodes))\n\n# Simulation loop\nfor i in range(Nsteps):\n    qlobby = random.sample(Nodes, q)\n    voter = random.sample(Nodes, 1)\n    \n    # sum all votes in lobby\n    sum_votes = 0\n    for qs in qlobby:\n        sum_votes = sum_votes + H.nodes[qs]['vote']\n       \n    # If all the votes in lobby were the same, the voter changes his mind,\n    # If all the votes are not the same, our voter flips with probability -1\n    if abs(sum_votes) == q:\n        H.nodes[voter[0]]['vote'] = H.nodes[qs]['vote']\n    elif random.uniform(0, 1) < epsilon:\n        H.nodes[voter[0]]['vote'] = -H.nodes[voter[0]]['vote']\n        \n    Nplus = 0\n    \n    for node, data in H.nodes(data=True):\n        if data['vote'] == +1:\n            Nplus = Nplus + 1\n\n    c = Nplus \/ H.number_of_nodes()\n    \n    c_list.append(c)\n    \n    # show a snapshot of our system for every viz_step step\n    if i % viz_step == 0:\n        color_map = repaint(H)\n        nx.draw(H, vmin=0, vmax=1, cmap=plt.cm.jet, node_color=color_map, with_labels=True)\n        plt.show()\n        \nplt.figure(figsize=(20, 3))\nplt.plot(np.arange(len(c_list)),c_list,'r-')\nplt.xlabel('Monte Carlo Steps')\nplt.ylabel(r'$c=N_{+}\/N$')\nplt.title(r'steps={},$N=${},$\\epsilon=${},q={}'.format(Nsteps,Num_nodes,epsilon,q))\nplt.show()","e5fcf6a6":"def compute_c(H):\n    '''\n    Inputs:\n    \n    H (graph): our graph\n    \n    Output:\n    \n    c (float): the fraction N+\/N\n    '''\n    Nplus = 0\n    \n    for node, data in H.nodes(data=True):\n        if data['vote'] == +1:\n            Nplus = Nplus + 1\n    \n    c = Nplus \/ H.number_of_nodes()\n    \n    return c\n\ndef qVoter_indep(Num_nodes=200,Nsteps=100000, q=7, p=0.2,MC_step=1000, viz=False):\n    '''\n    Inputs:\n    \n    - Num_nodes (int): The number of our network nodes\n    - Nsteps (int): The number of steps of our integration\n    - q (int): The number of loggy's members\n    - p (float): The probability of choosing between independence and conformity\n    - MC_step (int): the step for which we compute the concentration of our system\n    - viz (logical): True if you want the plot of time dependence of c(t) and the final snapshot of the system\n    \n    Outputs:\n    - A vizualization of the network in the last state\n    - The time evolution of c(t)\n    - c_list (list): a list with the values of c(t) for each MC step \n    '''\n    # Create graph\n    H = nx.Graph()\n    \n    # The possible votes\n    votes = [+1,-1]\n    \n    # Create the nodes\n    for i in range(Num_nodes):\n        H.add_node(i, vote=random.choice(votes))\n        \n    # Initialize nodes randomly and put different colors to each vote\n    color_map = repaint(H)\n            \n    # Add one and only one connection for each pair of nodes\n    for i in range(len(H)):\n        for j in range(i+1,len(H)):\n            H.add_edge(i,j)\n\n    # An array with all the possible nodes\n    Nodes = list(range(1,Num_nodes))\n    \n    # A list with all cs\n    c_list = []\n    c_list.append(compute_c(H))\n    \n    # Simulation loop\n    for i in range(Nsteps):\n        # choose randomly a voter and a q-lobby\n        voter = random.sample(Nodes, 1)\n        new_list = Nodes[0:voter[0]]+Nodes[voter[0]+1:len(Nodes)] # the voter can't be in the q-lobby\n        qlobby = random.sample(new_list, q)\n        \n        # sum all votes in lobby\n        sum_votes = 0\n        for qs in qlobby:\n            sum_votes = sum_votes + H.nodes[qs]['vote']\n        \n        # with probability p, the voter behaves independently\n        # with probability 1-p behaves like a conformist\n        if random.uniform(0, 1)<p:\n            if random.uniform(0, 1)<0.5:\n                H.nodes[voter[0]]['vote'] = -H.nodes[voter[0]]['vote']\n        else:\n            if abs(sum_votes) == q:\n                H.nodes[voter[0]]['vote'] = H.nodes[qs]['vote']\n            \n        # show a snapshot of our system for every viz_step step\n        if i % MC_step == 0:\n            color_map = repaint(H)\n            \n            # Compute c\n            c_list.append(compute_c(H))\n            \n    if viz:        \n        nx.draw(H, vmin=0, vmax=1, cmap=plt.cm.jet, node_color=color_map, with_labels=True)\n        plt.title('Network for t={}'.format(i), fontsize=18)\n        plt.show()\n\n        plt.figure(figsize=(20, 3))\n        plt.plot(np.arange(len(c_list)),c_list,'r-')\n        plt.xlabel('Monte Carlo Steps')\n        plt.ylabel(r'$c=N_{+}\/N$')\n        plt.title(r'steps={},$N=${},$q=${}, $p=${}, MC_step={}'.format(Nsteps,Num_nodes,q,p,MC_step))\n        plt.show()\n    \n    return c_list","f32b3b93":"c = qVoter_indep(Num_nodes=200, Nsteps=5000000, q=7, p=0.111, MC_step=100, viz=True)","2ebd4a33":"c = qVoter_indep(Num_nodes=200, Nsteps=5000000, q=5, p=0.175, MC_step=100, viz=True)","d858186e":"def bst(c,k,q):\n    num = c*(1-c)*((1-c)**q-c**q)-q\/k*(1-2*c)*(c*(1-c)**q+(1-c)*c**q)\n    den = (1-c)**q-c**q-q\/k*(1-2*c)*((1-c)**q+c**q)\n    b = 2*num\/den\n    return b\n\ndef th_plus(c,k,q):\n    return bst(c,k,q)\/(2*c)\n\ndef th_min(c,k,q):\n    return bst(c,k,q)\/(2*(1-c))\n\ndef c_plus(c):\n    return c\n\ndef c_min(c):\n    return 1-c\n\ndef p(c,k,q):\n    num = c_min(c)*th_min(c,k,q)**q-c_plus(c)*th_plus(c,k,q)**q\n    den = c_min(c)*th_min(c,k,q)**q-c_plus(c)*th_plus(c,k,q)**q - (c_min(c)-c_plus(c))\/2\n    return num\/den","5b1589e3":"c = np.linspace(0.1,0.9,1000)\nq = 7\nk_range = np.arange(20,45,5)\n\nplt.figure(figsize=(7, 5))\n\nfor k in k_range:\n    plt.plot(p(c=c,k=k,q=q),c,'--',label=r'<k>={}'.format(k))\n    \nplt.xlabel(r'$p$')\nplt.ylabel(r'$c=N_{+}\/N$')\nplt.grid()\nplt.title(r'Bifurcation Diagram for q={}'.format(q))\nplt.legend()\n\nzeros1 = np.linspace(0.01,0.06,1000)\nplt.plot(zeros1,0.5*np.ones(len(zeros1)),'k--')\nzeros2 = np.linspace(0.06,0.13,1000)\nplt.plot(zeros2,0.5*np.ones(len(zeros2)),'k-')\n\nc = np.linspace(0.01,0.15,1000)\nfor k in k_range:\n    plt.plot(p(c=c,k=k,q=q),c,'b-')\n    \nc = np.linspace(0.85,0.99,1000)\nfor k in k_range:\n    plt.plot(p(c=c,k=k,q=q),c,'b-')\n\nplt.show()","d8913189":"c = np.linspace(0.01,0.99,1000)\nq = 2\nk_range = np.arange(10,45,5)\n\nplt.figure(figsize=(7, 5))\n\nfor k in k_range:    \n    plt.plot(p(c=c,k=k,q=q),c,'-',label=r'<k>={}'.format(k))\n    \nplt.xlabel(r'$p$')\nplt.ylabel(r'$c=N_{+}\/N$')\nplt.grid()\nplt.title(r'Bifurcation Diagram for q={}'.format(q))\nplt.legend()\nzeros1 = np.linspace(0.01,0.28,1000)\nplt.plot(zeros1,0.5*np.ones(len(zeros1)),'k--')\nzeros2 = np.linspace(0.28,0.4,1000)\nplt.plot(zeros2,0.5*np.ones(len(zeros2)),'k-')\nplt.show()","71c57740":"c = np.linspace(0.1,0.9,1000)\nq = 7\nk_range = [199]\n\nplt.figure(figsize=(7, 5))\n\nfor k in k_range:\n    plt.plot(p(c=c,k=k,q=q),c,'--',label=r'<k>={}'.format(k))\n    \nplt.xlabel(r'$p$')\nplt.ylabel(r'$c=N_{+}\/N$')\nplt.grid()\nplt.title(r'Bifurcation Diagram for q={}'.format(q))\nplt.legend()\n\nzeros1 = np.linspace(0.01,0.083,1000)\nplt.plot(zeros1,0.5*np.ones(len(zeros1)),'k--')\nzeros2 = np.linspace(0.083,0.13,1000)\nplt.plot(zeros2,0.5*np.ones(len(zeros2)),'k-')\n\nc = np.linspace(0.01,0.15,1000)\nfor k in k_range:\n    plt.plot(p(c=c,k=k,q=q),c,'b-')\n    \nc = np.linspace(0.85,0.99,1000)\nfor k in k_range:\n    plt.plot(p(c=c,k=k,q=q),c,'b-')\n\nplt.show()","494caa85":"c = np.linspace(0.01,0.99,1000)\nq = 2\nk_range = [199]\n\nplt.figure(figsize=(7, 5))\n\nfor k in k_range:    \n    plt.plot(p(c=c,k=k,q=q),c,'-',label=r'<k>={}'.format(k))\n    \nplt.xlabel(r'$p$')\nplt.ylabel(r'$c=N_{+}\/N$')\nplt.grid()\nplt.title(r'Bifurcation Diagram for q={}'.format(q))\nplt.legend()\nzeros1 = np.linspace(0.01,0.33,1000)\nplt.plot(zeros1,0.5*np.ones(len(zeros1)),'k--')\nzeros2 = np.linspace(0.33,0.4,1000)\nplt.plot(zeros2,0.5*np.ones(len(zeros2)),'k-')\nplt.show()","b9f4ef54":"p_range = np.linspace(0.01,0.2,500)\nc_list = []\n\nfor p in p_range:\n    c = qVoter_indep(Num_nodes=200, Nsteps=1000000, q=7, p=p, MC_step=10000, viz=False)\n    c_list.append(c[-1])\n\nplt.plot(p_range,c_list,'ko')\nzeros1 = np.linspace(0.01,0.2,1000)\nplt.plot(zeros1,0.5*np.ones(len(zeros1)),'k--')\nplt.xlabel(r'$p$')\nplt.ylabel(r'$c=N_{+}\/N$')\nplt.grid()\nplt.title(r'Bifurcation Diagram for q=7')\nplt.legend()","7b33e611":"p_range = np.linspace(0.01,0.6,500)\nc_list = []\n\nfor p in p_range:\n    c = qVoter_indep(Num_nodes=200, Nsteps=1000000, q=2, p=p, MC_step=10000, viz=False)\n    c_list.append(c[-1])\n    \nplt.plot(p_range,c_list,'ko')\nzeros1 = np.linspace(0.01,0.6,1000)\nplt.plot(zeros1,0.5*np.ones(len(zeros1)),'k--')\nplt.xlabel(r'$p$')\nplt.ylabel(r'$c=N_{+}\/N$')\nplt.grid()\nplt.title(r'Bifurcation Diagram for q=2')\nplt.legend()","7ec9c91a":"from scipy.integrate import odeint\nimport pylab as pl\nimport sympy as sym\nfrom scipy.optimize import fsolve\n\n\ndef derivative(init, t):\n    '''\n    define q-Voter with Independence Model\n    '''\n    global p, q, k\n    \n    # Initial conditions\n    c,b = init\n    \n    # Derivatives\n    dc = (1-p)*((1-c)*(b\/(2*(1-c)))**q-c*(b\/(2*c))**q)+p\/2*(1-2*c)\n    db = 2\/k*(c*((1-p)*(b\/(2*c))**q*(k-2*q-2*(k-q)*b\/(2*c))+p*k\/2*(1-b\/(2*c)))+\\\n             (1-c)*((1-p)*(b\/(2*(1-c)))**q*(k-2*q-2*(k-q)*b\/(2*(1-c)))+p*k\/2*(1-b\/(2*(1-c)))))\n    \n    # take the output in one list\n    output = np.hstack((dc,db))\n\n    return output","796b5a76":"q = 7\np = 0.111\nk = 199\n\nt_final = 2000.0\ndt = 0.01\nt = np.arange(0, t_final, dt)\n\nxrange = np.linspace(0.1,0.99,5)\nyrange = np.linspace(0.1,0.99,5)\n\nfor i in xrange:\n    for j in yrange:\n        \n        x0 = [i,j]\n        sol = odeint(derivative, x0, t)\n        c = sol[:,0]\n        b = sol[:,1]\n\n        pl.plot(c, b,lw=4)\n    \n    \npl.xlabel(r\"$c$\",fontsize=16)\npl.ylabel(r\"$b$\",fontsize=16)\npl.title('Phase Space',fontsize=16)\npl.grid()\npl.show()","11926891":"from pylab import *\n\nq = 7\np = 0.07\nk = 20\n\nc, b = meshgrid(arange(0.01, 0.99, 0.001), arange(0.01, 0.99, 0.001))\ncdot = (1-p)*((1-c)*(b\/(2*(1-c)))**q-c*(b\/(2*c))**q)+p\/2*(1-2*c)\nbdot = 2\/k*(c*((1-p)*(b\/(2*c))**q*(k-2*q-2*(k-q)*b\/(2*c))+p*k\/2*(1-b\/(2*c)))+\\\n             (1-c)*((1-p)*(b\/(2*(1-c)))**q*(k-2*q-2*(k-q)*b\/(2*(1-c)))+p*k\/2*(1-b\/(2*(1-c)))))\n\nstreamplot(c, b, cdot, bdot)\nxlabel('c'); ylabel('b')\ntitle('Phase Space for q={}, p={}, k={}'.format(q,p,k))\ngrid(); show()","d3e374ab":"q = 2\np = 0.25\nk = 20\n\nc, b = meshgrid(arange(0.01, 0.99, 0.001), arange(0.01, 0.99, 0.001))\ncdot = (1-p)*((1-c)*(b\/(2*(1-c)))**q-c*(b\/(2*c))**q)+p\/2*(1-2*c)\nbdot = 2\/k*(c*((1-p)*(b\/(2*c))**q*(k-2*q-2*(k-q)*b\/(2*c))+p*k\/2*(1-b\/(2*c)))+\\\n             (1-c)*((1-p)*(b\/(2*(1-c)))**q*(k-2*q-2*(k-q)*b\/(2*(1-c)))+p*k\/2*(1-b\/(2*(1-c)))))\n\nstreamplot(c, b, cdot, bdot)\nxlabel('c'); ylabel('b')\ntitle('Phase Space for q={}, p={}, k={}'.format(q,p,k))\ngrid(); show()","64e13078":"# q-Voter\n## A warm-up exercise in networkx\nFirst of all, we import the networkx library, which is the basic python library for network theory.","cd380029":"The first thing we need to do is to create a fully connected network with N nodes (individuals). Each one of these individuals is described from the binary variables $S=\\pm1$.\n\nWe choose to create a network with 20 nodes. Each of these nodes is linked with all the others. So the length of the network is the number of its nodes.","dbbf118b":"A more enlightening way to do that is by stream-plot. Basically, it is the same idea, but it also shows the direction of the trajectories in phase space.","b792c40a":"# q-Voter with independence model function\n\nHere we create a function that applies the q-Voter model with independence.\n\nThe algorithm is described on the paper \"Phase transitions in the q-voter model with two types of stochastic driving\" of Piotr Nyczka, Katarzyna Sznajd-Weron, and Jerzy Cis\u0142o. With probability $p$ the voter behaves independently and with $1-p$ like a conformist. In the case of the independent behavior an individual changes to the opposite state with probability $1\/2$.","fef471fb":"## Building a network with voters\nThe main problem we had before was that even if we created the network, we didn't succeed to put labels. How we can solve this problem?\n\nWe create an empty network. In our elections there are two canditates: (+1) and (-1). Initially, our voters they choose randomly one of these candidates.","cdffd0c1":"The next step we must do is the network vizualization. As we can see, we have a basic problem: the number are not binary. We must do something and change them.","1e4ca3a7":"# Biffurcation Diagrams\nFrom the previous two diagrams it is clear that a phase transition occurs in our system. To have a clearer picture of our phase transition, we must plot the bifurcation diagrams of our systems, which show us $c(t)$ as a function of $p$.\n\nOf course this will need more computational time due to the fact that we must run a Monte carlo simulation for each $p$. However, we can start from easy analytical results.\n\n## The Analytical Way\n\nThe easiest way to extract this diagram is by assuming stationary state\n\n\\begin{equation}\n\\dfrac{\\partial c}{\\partial t}=0 \\;\\wedge\\; \\dfrac{\\partial b}{\\partial t}=0\n\\end{equation}\n\nAnd then find find the formula for $p$,\n\n\\begin{equation}\np=\\dfrac{c_{-}\\theta^{q}_{-}-c_{+}\\theta^{q}_{+}}{c_{-}\\theta^{q}_{-}-c_{+}\\theta^{q}_{+}-(c_{-}-c_{+})\/2}\n\\end{equation}\n\nwhere\n\n\\begin{align}\nP(+)&=c_{+}=c\\\\\nP(-)&=c_{-}=1-c\n\\end{align}\n\nand\n\n\\begin{align}\n\\theta_{+}&=P(-|+)=\\dfrac{P(-+)}{P(+)}=\\dfrac{b}{2c}\\\\\n\\theta_{-}&=P(+|-)=\\dfrac{P(+-)}{P(-)}=\\dfrac{b}{2(1-c)}\n\\end{align}\n\nwhere $b=P(+-)+P(-+)$ or $P(+-)=P(-+)=b\/2$.\n\nWe have almost everything to find the depndence of concentration $c$ from $p$. The only problem we have is that we need the equation of stationary state for $b$. And this equation is the following,\n\n\\begin{equation}\nb_{\\mathrm{st}}=2 \\frac{c_{\\mathrm{st}}\\left(1-c_{\\mathrm{st}}\\right)\\left[\\left(1-c_{\\mathrm{st}}\\right)^{q}-c_{\\mathrm{st}}^{q}\\right]-\\frac{q}{\\langle k\\rangle}\\left(1-2 c_{\\mathrm{st}}\\right)\\left[c_{\\mathrm{st}}\\left(1-c_{\\mathrm{st}}\\right)^{q}+\\left(1-c_{\\mathrm{st}}\\right) c_{\\mathrm{st}}^{q}\\right]}{\\left(1-c_{\\mathrm{st}}\\right)^{q}-c_{\\mathrm{st}}^{q}-\\frac{q}{\\langle k\\rangle}\\left(1-2 c_{\\mathrm{st}}\\right)\\left[\\left(1-c_{\\mathrm{st}}\\right)^{q}+c_{\\mathrm{st}}^{q}\\right]}\n\\end{equation}\n\nwhere $<k>$ is the degree of our network. Here we work with a complete network, which means that each node is connected with all the others. So $<k>=N-1$.\n\nTherefore, we define our functions,","e2e1eb69":"The size of the network is the number of its connections.","165c5faa":"As we can see the phase transitions are clear from these diagrams. In the first diagram we have the coexistence of three states, whereas in the last diagram we have the coexistence of two states.","4ba0b3e8":"One way to do that is just by integrating our system and ploting our results. The problem is that our final diagram is not very helpful, so probably we should try for another method.","17e0dca3":"## The Computational Way\nHere we will run a Monte Carlo Simulation for each different value of $p$. This takes more time, but it is the best way to make sure that our results are valid and make sense.\n\nOur method is to keep the last point of each Monte Carlo simulation and then plot all points versus $p$.","7511c979":"And then we can plot our graph to see that all we did was correct!","cff75412":"The only problem we have now is that our network is not connected. Basically, we want it to be fully connected. So we can connect all the nodes in one loop","257037b1":"Here we also create bifurcation diagrams for $<k>=199$, which is the mean node degree of our system.","bd1b054e":"The next thing we can do is to color the nodes of our network depending on the voting preference of our individuals.","89cd7bc9":"# Trajectories in Phase Space\n\nAnother thing we can do is to create some stream-plots in our phase space, which will help us to undersatand the stability of our fixed points.\n\nTo do that we must integrate the master equations of our dynamical system, which are the following\n\n\\begin{align}\n\\dfrac{\\partial c}{\\partial t}&=(1-p)(c_{-}\\theta^{q}_{-}-c_{+}\\theta^{q}_{+})+\\dfrac{p}{2}(c_{-}-c_{+})\\\\\n\\dfrac{\\partial b}{\\partial t}&=\\dfrac{2}{<k>}\\sum_{j\\in\\{+,-\\}}c_{j}\\left\\lbrace (1-p)\\theta^{q}_{j}[<k>-2q-2(<k>-q)\\theta_{j}]+p\\dfrac{<k>}{2}(1-\\theta_{j})\\right\\rbrace \n\\end{align}\n    \nThus the only thing we need to do is to create a function that will integrate this system for different initial conditions. And having done that we will plot $c$ versus $b$.","cb7602c6":"## Iterating our q-Voter model\nPreviously, we created a graph with $N$ individuals, in which all the individuals were connected. We create a random variable $S_{i}=\\pm 1$.\n\nAt each step of our iteration we choose randomly q-individuals\/voters\/nodes, who form a group of influence, called q-lobby. Then we choose randomly another one individual that the group can influence.\n\nNow if all the members of the group have the same opinion (same state), then our voter changes his mind. If they don't have an unanimous opinion, still the voter can flip with a probability $\\epsilon$.","5433cbab":"And then we can create easily the plots of biffurcation diagrams by inverting the previous equations."}}