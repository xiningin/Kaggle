{"cell_type":{"eab0e45c":"code","053540c7":"code","eeb61ccb":"code","88a7c4aa":"code","7c2d682b":"code","38927c4c":"code","60e9f72e":"code","499cc824":"code","64557da5":"markdown","fe87b41a":"markdown","8e9434b3":"markdown","42c1fb01":"markdown","2c9cd309":"markdown","22de3c11":"markdown"},"source":{"eab0e45c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","053540c7":"import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport random as rm\n","eeb61ccb":"##P: Pass, R: Run, O: Option, i.e RPO play\nstates = [\"P\",\"R\",\"O\"]\n\n# Possible sequences \ntransitionName = [[\"PP\",\"PR\",\"PO\"],[\"RP\",\"RR\",\"RO\"],[\"OP\",\"OR\",\"OO\"]]\n\n# Probabilities matrix (transition matrix)\ntransitionMatrix = [[0.35,0.25,0.4],[0.4,0.3,0.3],[0.45,0.35,0.2]]","88a7c4aa":"def forecast(downs):\n    play = \"P\"\n    playbook = [play]\n    i = 0\n    prob = 1\n    while i != downs:\n        if play == \"P\":\n            change = np.random.choice(transitionName[0],replace=True,p=transitionMatrix[0])\n            if change == \"PP\":\n                prob = prob * 0.35\n                playbook.append(\"P\")\n                pass\n            elif change == \"PR\":\n                prob = prob * 0.25\n                play = \"R\"\n                playbook.append(\"R\")\n            elif change == \"PO\":\n                prob = prob * 0.4\n                play = \"O\"\n                playbook.append(\"O\")\n        elif play == \"R\":\n            change = np.random.choice(transitionName[1],replace=True,p=transitionMatrix[1])\n            if change == \"RR\":\n                prob = prob * 0.4\n                playbook.append(\"R\")\n                pass\n            elif change == \"RP\":\n                prob = prob * 0.3\n                play = \"P\"\n                playbook.append(\"P\")\n            elif change == \"RO\":\n                prob = prob * 0.3\n                play = \"O\"\n                playbook.append(\"O\")\n        elif play == \"O\":\n            change = np.random.choice(transitionName[2],replace=True,p=transitionMatrix[2])\n            if change == \"OO\":\n                prob = prob * 0.45\n                playbook.append(\"O\")\n                pass\n            elif change == \"OP\":\n                prob = prob * 0.35\n                play = \"P\"\n                playbook.append(\"P\")\n            elif change == \"OR\":\n                prob = prob * 0.2\n                play = \"R\"\n                playbook.append(\"R\")\n        i += 1       \n    return playbook\n\nfull_playbook = []\ncount = 0","7c2d682b":"##simulate 4 downs\nfor iterations in range(1,10000):\n        full_playbook.append(forecast(3))\n\n#See all plays called in a particular set of 4 downs\n##print(full_playbook)\n\n#Counts; so we can predict the probability of a given play \n##for example, in this case, the probability we call an RPO on 4th down\n\nfor plays in full_playbook:\n    if(plays[3] == \"O\"):\n        count += 1","38927c4c":"percentage = (count\/10000) * 100\nprint(\"The probability of starting at state:'P' and ending at state:'O'= \" + str(percentage))","60e9f72e":"def forecast(downs):\n    play = \"R\"\n    playbook = [play]\n    i = 0\n    prob = 1\n    while i != downs:\n        if play == \"P\":\n            change = np.random.choice(transitionName[0],replace=True,p=transitionMatrix[0])\n            if change == \"PP\":\n                prob = prob * 0.35\n                playbook.append(\"P\")\n                pass\n            elif change == \"PR\":\n                prob = prob * 0.25\n                play = \"R\"\n                playbook.append(\"R\")\n            elif change == \"PO\":\n                prob = prob * 0.4\n                play = \"O\"\n                playbook.append(\"O\")\n        elif play == \"R\":\n            change = np.random.choice(transitionName[1],replace=True,p=transitionMatrix[1])\n            if change == \"RR\":\n                prob = prob * 0.4\n                playbook.append(\"R\")\n                pass\n            elif change == \"RP\":\n                prob = prob * 0.3\n                play = \"P\"\n                playbook.append(\"P\")\n            elif change == \"RO\":\n                prob = prob * 0.3\n                play = \"O\"\n                playbook.append(\"O\")\n        elif play == \"O\":\n            change = np.random.choice(transitionName[2],replace=True,p=transitionMatrix[2])\n            if change == \"OO\":\n                prob = prob * 0.45\n                playbook.append(\"O\")\n                pass\n            elif change == \"OP\":\n                prob = prob * 0.35\n                play = \"P\"\n                playbook.append(\"P\")\n            elif change == \"OR\":\n                prob = prob * 0.2\n                play = \"R\"\n                playbook.append(\"R\")\n        i += 1       \n    return playbook\n\nfull_playbook = []\ncount = 0\n\n\nfor iterations in range(1,10000):\n        full_playbook.append(forecast(3))\n\n#See all plays called in a particular set of 4 downs\n##print(full_playbook)\n\n#Counts; so we can predict the probability of a given play \n##for example, in this case, the probability we call an RPO on 4th down\nfor plays in full_playbook:\n    if(plays[1] == \"P\"):\n        count += 1","499cc824":"percentage2 = (count\/10000) * 100\nprint(\"The probability of starting at state:'R' and running a passing play on 2nd down 'P'= \" + str(percentage2))","64557da5":"And so on; we could easily choose different probabilities to explore which I may add later (probability of running on first down? How about passing on 4th down?)\n\nI hope you learned a bit about Markov chains and how to implement them in python!","fe87b41a":"Next, preform many simulations","8e9434b3":"The idea is to similate the probabilities in the above state diagram using Markov chains. ","42c1fb01":"Disclaimer: I completely made up these numbers.\n\nThe idea is to simulate a \"smart\" football club; who rarely calls the same type of play (I considered \"pass\" plays, \"run\" plays and \"RPO\"-run pass option- plays) twice in a row. I created a state diagram (see image) which represents the probability of calling each type of play. For reference; like coloured lines are considered outward arrows. \n\n![Screen%20Shot%202020-06-05%20at%201.11.08%20AM.png](attachment:Screen%20Shot%202020-06-05%20at%201.11.08%20AM.png)","2c9cd309":"Calculate different probabilities","22de3c11":"Next we define the forecast function to simulate these events (plays)"}}