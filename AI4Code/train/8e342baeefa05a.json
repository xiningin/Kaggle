{"cell_type":{"29418460":"code","f9fc80b1":"code","4ef5f836":"code","bfbb57fb":"code","5dbdeea3":"code","f577076b":"code","ad9c2f2f":"code","44595e6c":"code","56a81b67":"code","53dc18a0":"code","50398d08":"code","d3cafaf2":"code","b3de5eee":"code","413e83e4":"code","dec519b9":"code","071d3064":"code","187a029b":"code","4a13dfbd":"code","7cdab3e4":"code","25d52f68":"code","60ec2cdc":"code","eccd1cf0":"code","43d6187f":"code","6cbbd9f3":"code","20ea94b1":"code","da2034da":"markdown","a5a12be3":"markdown","17597ae8":"markdown"},"source":{"29418460":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f9fc80b1":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns","4ef5f836":"train_df = pd.read_csv('\/kaggle\/input\/house-prices-advanced-regression-techniques\/train.csv')\ntest_df = pd.read_csv('\/kaggle\/input\/house-prices-advanced-regression-techniques\/test.csv')\ntrain_df.head()","bfbb57fb":"train_id = train_df['Id']\ntest_id = test_df['Id']\ntrain_df.drop('Id', axis = 1, inplace = True)\ntest_df.drop('Id', axis = 1, inplace = True)\ntrain_df.info()","5dbdeea3":"#Read from a public notebook that column GrLivArea have ouliers as it was mentioned in the original data documentation which isnt available anymore\nfig, ax = plt.subplots()\nax.scatter(x = train_df['GrLivArea'], y = train_df['SalePrice'])\nplt.show()","f577076b":"#We can see the two big outliers..lets delete them\ntrain_df.drop(train_df[(train_df['SalePrice'] < 200000) & (train_df['GrLivArea'] > 4500)].index, inplace = True)\nfig, ax = plt.subplots()\nax.scatter(x = train_df['GrLivArea'], y = train_df['SalePrice'])\nplt.show()","ad9c2f2f":"#Combining data\nall_data = pd.concat((train_df, test_df)).reset_index(drop = True)\nall_data.drop('SalePrice', axis = 1, inplace = True)\nprint(all_data.shape)","44595e6c":"all_miss_data = ((all_data.isnull().sum())\/len(all_data))* 100\nall_miss_data = all_miss_data.drop(all_miss_data[all_miss_data == 0].index).sort_values(ascending = False)\nprint(all_miss_data)","56a81b67":"plt.subplots(figsize = (12, 9))\nsns.heatmap(train_df.corr(), square = True)\n#nothing unexpected can be seen here","53dc18a0":"#lets fill the houses with no pool with none value\nall_data['PoolQC'] = all_data['PoolQC'].fillna('None')\n#house with no misc feauture\nall_data['MiscFeature'] = all_data['MiscFeature'].fillna('None')\n#house with no alley\nall_data['Alley'] = all_data['Alley'].fillna('None')\n#houses with no fence\nall_data['Fence'] = all_data['Fence'].fillna('None')\n#houses with no fire place\nall_data['FireplaceQu'] = all_data['FireplaceQu'].fillna('None')","50398d08":"'''For LotFrontage feature we assume that the houses in the same neighbourhood have similar frontage so for every missing \nvalue we replace it with the median frontage value of the neighbourhood'''\nall_data['LotFrontage'] = all_data.groupby('Neighborhood')['LotFrontage'].transform(lambda x : x.fillna(x.median()))\n\n","d3cafaf2":"# Filling the four 'garage' categorical variables with None\nfor col in ('GarageFinish', 'GarageQual', 'GarageCond', 'GarageType'):\n    all_data[col] = all_data[col].fillna('None')\n# Filling the three 'garage' continous variables with 0\nfor col in ('GarageYrBlt', 'GarageArea', 'GarageCars'):\n    all_data[col] = all_data[col].fillna(0)","b3de5eee":"#For basement categorical features\nfor col in ('BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2'):\n    all_data[col] = all_data[col].fillna('None')\n#For basement continous features\nfor col in ('BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF','TotalBsmtSF', 'BsmtFullBath', 'BsmtHalfBath'):\n    all_data[col] = all_data[col].fillna(0)","413e83e4":"#If the house has no masonary veneer\nall_data['MasVnrType'] = all_data['MasVnrType'].fillna('None')\nall_data['MasVnrArea'] = all_data['MasVnrArea'].fillna(0)","dec519b9":"print(all_data['MSZoning'].value_counts())\nall_data['MSZoning'] = all_data['MSZoning'].fillna(all_data['MSZoning'].mode()[0])","071d3064":"print(all_data['Utilities'].value_counts())\nall_data = all_data.drop(['Utilities'], axis=1)","187a029b":"#ames data description says NA in the functional column means typical\nprint(all_data['Functional'].value_counts())\nall_data['Functional'] = all_data[\"Functional\"].fillna(\"Typ\")","4a13dfbd":"print(all_data['Electrical'].value_counts())\nall_data['Electrical'] = all_data['Electrical'].fillna(all_data['Electrical'].mode()[0])","7cdab3e4":"print(all_data['KitchenQual'].value_counts())\nall_data['KitchenQual'] = all_data['KitchenQual'].fillna(all_data['KitchenQual'].mode()[0])","25d52f68":"#replacing with mode values\nall_data['Exterior1st'] = all_data['Exterior1st'].fillna(all_data['Exterior1st'].mode()[0])\nall_data['Exterior2nd'] = all_data['Exterior2nd'].fillna(all_data['Exterior2nd'].mode()[0])\nall_data['SaleType'] = all_data['SaleType'].fillna(all_data['SaleType'].mode()[0])","60ec2cdc":"#na in subclass means no class\nprint(all_data['MSSubClass'].value_counts())\nall_data['MSSubClass'] = all_data['MSSubClass'].fillna('None')","eccd1cf0":"all_miss_data = ((all_data.isnull().sum())\/len(all_data))* 100\nall_miss_data = all_miss_data.drop(all_miss_data[all_miss_data == 0].index).sort_values(ascending = False)\nprint(all_miss_data)","43d6187f":"print(all_data.info())","6cbbd9f3":"all_data['MSSubClass'] = all_data['MSSubClass'].astype(str)\n#print(all_data['OverallQual'].value_counts())\nall_data['OverallQual'] = all_data['OverallQual'].astype(str)\n#print(all_data['OverallCond'].value_counts())\nall_data['OverallCond'] = all_data['OverallCond'].astype(str)\nall_data['YearBuilt'] = all_data['YearBuilt'].astype(str)\n#print(all_data['YearRemodAdd'].value_counts())\nall_data['YearRemodAdd'] = all_data['YearRemodAdd'].astype(str)","20ea94b1":"from sklearn.preprocessing import LabelEncoder\ncols = ('FireplaceQu', 'BsmtQual', 'BsmtCond', 'GarageQual', 'GarageCond', \n        'ExterQual', 'ExterCond','HeatingQC', 'PoolQC', 'KitchenQual', 'BsmtFinType1', \n        'BsmtFinType2', 'Functional', 'Fence', 'BsmtExposure', 'GarageFinish', 'LandSlope',\n        'LotShape', 'PavedDrive', 'Street', 'Alley', 'CentralAir', 'MSSubClass', 'OverallCond', \n        'YrSold', 'MoSold')\n# process columns, apply LabelEncoder to categorical features\nfor c in cols:\n    lbl = LabelEncoder() \n    lbl.fit(list(all_data[c].values)) \n    all_data[c] = lbl.transform(list(all_data[c].values))","da2034da":"Some variables which should be categorical are int64. Lets transform them","a5a12be3":"Lets fill missing data","17597ae8":"Label encoding the variables"}}