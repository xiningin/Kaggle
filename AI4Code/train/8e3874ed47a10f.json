{"cell_type":{"6404bec8":"code","f2921483":"code","4924865c":"code","4fef4b3c":"code","5a268ad1":"code","2ad8e025":"code","1805f8ae":"code","ca8b7705":"code","720b10ff":"code","3ff85ad4":"code","0e651dc9":"code","94df6739":"code","4fe29cb9":"code","6853c8ea":"code","d6727989":"code","f7d8e625":"code","1dd8ebc4":"code","61e06dbb":"code","da7aea13":"code","f63c0ae7":"code","885d5096":"code","79e5f3ad":"code","8c1b7395":"markdown","017bcd69":"markdown","d7c16ee0":"markdown","18eff368":"markdown","5b27ca1f":"markdown","43a588dd":"markdown","cab4208d":"markdown","4eea6c75":"markdown","de15e697":"markdown","855071b7":"markdown","e057b31c":"markdown"},"source":{"6404bec8":"from IPython.display import Image\nImage(\"..\/input\/image-community\/Community.jpeg\") #https:\/\/healthcommcapacity.org\/","f2921483":"# Import libraries\nimport pandas as pd #For reading dataset files\nimport networkx as nx #For network creation\/analysis\nfrom networkx.algorithms import community\nimport community as community_louvain\nimport matplotlib.pyplot as plt #For plotting graphs\nimport igraph as ig\n%matplotlib inline","4924865c":"G = nx.karate_club_graph()","4fef4b3c":"nx.draw_networkx(G)","5a268ad1":"#Edge betweenness\nlst_b = nx.algorithms.community.girvan_newman(G)\ntype(lst_b)","2ad8e025":"#Print possible communities\nfor x in lst_b:\n  print(x)","1805f8ae":"#Community visualization\ncolors = [\"#00C98D\", \"#5030C0\", \"#50F0F0\"]\npos = nx.spring_layout(G)\nlst_b = community.girvan_newman(G)\ncolor_map_b = {}\nkeys = G.nodes()\nvalues = \"black\"\nfor i in keys:\n        color_map_b[i] = values\ncounter = 0\nfor x in lst_b:\n  print(1)\n  for c in x:\n    for n in c:\n      #print(n,counter)\n      color_map_b[n] = colors[counter]\n    counter = counter + 1\n  break\nnx.draw_networkx_edges(G, pos)\nnx.draw_networkx_nodes(G, pos, node_color=dict(color_map_b).values())\nnx.draw_networkx_labels(G, pos)\nplt.axis(\"off\")\nplt.show()","ca8b7705":"#Modularity for different communities\nmodularity = []\nfor x in lst_b:\n  modularity.append(community.modularity(G, x))\nmodularity","720b10ff":"#Plot modularity\nplt.plot(modularity, 'o')\nplt.xlabel('# of clusters')\nplt.ylabel('modularity')\nplt.show()","3ff85ad4":"#Extract the community with maximum modularity\nindex = modularity.index(max(modularity))\ni=0\nfor v in lst_b:\n    if i==index:\n        print(v)\n        temp = v\n    i+=1","0e651dc9":"#Community visualization (the community with maximum modularity)\ncolors = [\"#00C98D\", \"#5030C0\", \"#50F0F0\", 'red', 'blue']\npos = nx.spring_layout(G)\ncolor_map_b = {}\nkeys = G.nodes()\nvalues = \"black\"\nfor i in keys:\n        color_map_b[i] = values\ncounter = 0\nfor x in temp:\n  for n in x:\n    color_map_b[n] = colors[counter]\n  counter = counter + 1\n\nnx.draw_networkx_edges(G, pos)\nnx.draw_networkx_nodes(G, pos, node_color=dict(color_map_b).values())\nnx.draw_networkx_labels(G, pos)\nplt.axis(\"off\")\nplt.show()","94df6739":"community.greedy_modularity_communities(G)","4fe29cb9":"#Community visualization\ncolors = [\"#00C98D\", \"#5030C0\", \"#50F0F0\"]\npos = nx.spring_layout(G)\nlst_b = community.greedy_modularity_communities(G)\ncolor_map_b = {}\nkeys = G.nodes()\nvalues = \"black\"\nfor i in keys:\n        color_map_b[i] = values\ncounter = 0\nfor x in lst_b:\n  for n in x:\n    color_map_b[n] = colors[counter]\n  counter = counter + 1\n\nnx.draw_networkx_edges(G, pos)\nnx.draw_networkx_nodes(G, pos, node_color=dict(color_map_b).values())\nnx.draw_networkx_labels(G, pos)\nplt.axis(\"off\")\nplt.show()","6853c8ea":"colors = [\"#00C98D\", \"#5030C0\", \"#50F0F0\"]\npos = nx.spring_layout(G)\nlst_m = community.label_propagation_communities(G)\ncolor_map_b = {}\nkeys = G.nodes()\nvalues = \"black\"\nfor i in keys:\n        color_map_b[i] = values\ncounter = 0\nfor c in lst_m:\n  for n in c:\n    color_map_b[n] = colors[counter]\n  counter = counter + 1\nnx.draw_networkx_edges(G, pos)\nnx.draw_networkx_nodes(G, pos, node_color=dict(color_map_b).values())\nnx.draw_networkx_labels(G, pos)\nplt.axis(\"off\")\nplt.show()","d6727989":"colors = [\"#00C98D\", \"#5030C0\", \"#50F0F0\", 'yellow']\npos = nx.spring_layout(G)\nlst_m = community_louvain.best_partition(G)\ncolor_map_b = {}\nkeys = G.nodes()\nvalues = \"black\"\nfor i in keys:\n        color_map_b[i] = values\n\nfor n in dict(lst_m):\n  color_map_b[n] = colors[lst_m[n]]\n\nnx.draw_networkx_edges(G, pos)\nnx.draw_networkx_nodes(G, pos, node_color=dict(color_map_b).values())\nnx.draw_networkx_labels(G, pos)\nplt.axis(\"off\")\nplt.show()","f7d8e625":"g = ig.Graph.TupleList(G.edges(), directed=False)","1dd8ebc4":"wtrap = g.community_walktrap(steps = 4)\nclust = wtrap.as_clustering()\nig.plot(clust, mark_groups = True, bbox=(300,300), vertex_label=g.vs['name'])\n#Reference: https:\/\/towardsdatascience.com\/detecting-communities-in-a-language-co-occurrence-network-f6d9dfc70bab","61e06dbb":"def find_community(graph,k):\n    return list(community.k_clique_communities(graph,k))\n\nfor k in range(2,10):\n        print (\"############# k-Clique: %d ################\" % k)\n        rst_com = find_community(G,k)\n        print (\"Count of Community being found\uff1a%d\" % len(rst_com))\n        print(rst_com)","da7aea13":"colors = [\"#00C98D\", \"#5030C0\", \"#50F0F0\"]\npos = nx.spring_layout(G)\nlst_m = community.k_clique_communities(G, 3)\ncolor_map_b = {}\nkeys = G.nodes()\nvalues = \"black\"\nfor i in keys:\n        color_map_b[i] = values\ncounter = 0\nfor c in lst_m:\n  for n in c:\n    color_map_b[n] = colors[counter]\n  counter = counter + 1\nnx.draw_networkx_edges(G, pos)\nnx.draw_networkx_nodes(G, pos, node_color=dict(color_map_b).values())\nnx.draw_networkx_labels(G, pos)\nplt.axis(\"off\")\nplt.show()","f63c0ae7":"#Read nodes and edges datasets\nnodes = pd.read_csv('..\/input\/network-analysis-data-from-various-sources\/InputFileNodes.csv')\nedges = pd.read_csv('..\/input\/network-analysis-data-from-various-sources\/InputFileEdges.csv')\n#Collapse all edges of the same type between the same two nodes by summing their weights\nedges = edges.groupby(['from', 'to', 'type'])['weight'].sum().reset_index()","885d5096":"#Create undirected graph using edgelist\nG_undirected = nx.from_pandas_edgelist(edges, source='from', target='to',edge_attr=True)\nnx.draw(G_undirected)","79e5f3ad":"#Create directed graph using edgelist\nG_directed = nx.from_pandas_edgelist(edges, source='from', target='to',edge_attr=True, create_using=nx.DiGraph())\nnx.draw(G_directed)","8c1b7395":"## 5. Walktrap","017bcd69":"# Loading Datasets:","d7c16ee0":"## 6. k-clique community","18eff368":"## 2. Modularity maximization","5b27ca1f":"## 4. Fast community unfolding (Louvian)","43a588dd":"# Libraries needed:\n\n**We need following libraries: networkx**\n","cab4208d":"# Agenda:\n+ **Network Communities using networkx\/igraph**\n  1. Edge betweenness (Girvan\u2013Newman)\n  2. Modularity maximization\n  3. Label propagation\n  4. Fast community unfolding (Louvian)\n  5. Walktrap\n  6. k-clique community","4eea6c75":"## 3. Label propagation","de15e697":"## 1. Edge betweenness (Girvan\u2013Newman)","855071b7":"# Community Algorithms","e057b31c":"## Calculate and visualize community for graphs G_undirected and G_directed.\n  1. Edge betweenness (Girvan\u2013Newman)\n  2. Modularity maximization\n  3. Label propagation\n  4. Fast community unfolding (Louvian)\n  5. Walktrap\n  6. k-clique community\n\n"}}