{"cell_type":{"a5057197":"code","a18dfb34":"code","f70d7339":"code","fb699d60":"code","1e3944a3":"code","f25055a8":"code","9ba26958":"code","d30ebaa5":"code","b5b3f349":"code","efd17fcf":"code","6f70fcd1":"code","2f48660d":"code","2638ebc8":"code","2c65cda0":"code","66edb037":"code","8ebac63d":"code","a0021b0f":"code","1a6adac6":"code","b5807bff":"code","b8add898":"code","c63d7037":"code","a304b48c":"code","33488227":"code","b55df739":"code","066a69db":"code","e450e0af":"code","dd5c68eb":"code","e204706e":"code","998fbd29":"code","3a185e21":"markdown"},"source":{"a5057197":"import torch\nimport torch.nn as nn   \nimport pandas as pd\nimport numpy as np\nimport warnings\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\nwarnings.filterwarnings('ignore')\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\ndevice","a18dfb34":"## \u901a\u8fc7Pandas\u5bf9\u4e8e\u6570\u636e\u8fdb\u884c\u8bfb\u53d6 (pandas\u662f\u4e00\u4e2a\u5f88\u53cb\u597d\u7684\u6570\u636e\u8bfb\u53d6\u51fd\u6570\u5e93)\npath = '\/kaggle\/input\/dataset\/'\ntrain_data = pd.read_csv(path + 'used_car_train_20200313.csv', sep=' ')\ntest_data = pd.read_csv(path + 'used_car_testA_20200313.csv', sep=' ')\ntrain_data.drop(index=train_data.index[train_data['model'].isnull()], inplace=True) # \u5220\u9664model\u4e3aNone\u7684\u884c\n#train_label_ground = train_data['price']\n#train_data['price'] = np.log(train_data['price']) no change price\n## \u8f93\u51fa\u6570\u636e\u7684\u5927\u5c0f\u4fe1\u606f\nprint('train data shape:',train_data.shape)\nprint('test data shape:',test_data.shape)","f70d7339":"train_data['istrain'] = 1\ntest_data['istrain'] = 0\ndata = pd.concat([train_data, test_data], ignore_index=True)\ndata.drop(columns=['name', 'offerType', 'seller'], inplace=True) # \u5220\u9664\u610f\u4e49\u4e0d\u5927\u7684\u7279\u5f81\n#data.loc[:, data.columns != 'price']=data.loc[:, data.columns != 'price'].apply(lambda x:x.fillna(x.value_counts().index[0])) # fill NA with most frequent value\n# attention: mabe -1 is better\n#data.fillna({'bodyType': -1, 'brand': -1, 'gearbox': -1}, inplace=True)\n#data['power'][data['power'] > 600] = 0\n#data['power'].replace(0, mean_power, inplace=True)\ndate_features = ['regDate', 'creatDate'] # \u65e5\u671f\u7279\u5f81\ncat_features = ['kilometer',  'bodyType', 'brand', 'fuelType', 'gearbox', 'model', 'notRepairedDamage',  'regionCode'] # \u7c7b\u522b\u7279\u5f81\n#################attention power add\n######\n\nnum_features = ['v_' + str(i) for i in range(15)]  # power bin instead\n#data[cat_features].astype(object)\n#print(cat_features)\ndata.shape, data.columns","fb699d60":"data[\"regionCode\"] \/\/= 100","1e3944a3":"data[\"power\"] = np.log(data[\"power\"]  + 1)\nbin = [i\/10  for i in range(-1, 71)]\ndata['power_bin'] = pd.cut(data['power'], bin, labels=False)\ndata['power_bin'][data['power'] >= 7] = 71\ncat_features.append('power_bin')\ndata[['power_bin', 'power']].head()","f25055a8":"data[\"notRepairedDamage\"] = data[\"notRepairedDamage\"].replace(\"-\", \"0.0\").astype('float')","9ba26958":"def date_proc(x):\n    m = int(x[4:6])\n    if m == 0:\n        m = 1\n    return x[:4] + '-' + str(m) + '-' + x[6:]\n\n\ndata['regDate'] = pd.to_datetime(data['regDate'].astype('str').apply(date_proc)) \ndata['used_time'] = (pd.to_datetime(data['creatDate'], format='%Y%m%d', errors='coerce') - \n                    pd.to_datetime(data['regDate'], format='%Y%m%d', errors='coerce')).dt.days \/ 365","d30ebaa5":"data['regDate' + '_year'] = data['regDate'].dt.year # \u6dfb\u52a0\u6ce8\u518c\u5e74\u4efd\u7279\u5f81\ncat_features.append('regDate_year')","b5b3f349":"data[[col for col in data.columns if col != 'price']].isnull().sum().sum()","efd17fcf":"data.info()","6f70fcd1":"data = pd.get_dummies(data, columns=cat_features, dummy_na=True)","2f48660d":"data.shape","2638ebc8":"data.isnull().sum().sum()","2c65cda0":"data.drop(columns=['price']).isnull().sum().sum()","66edb037":"data.columns","8ebac63d":"all_features = [col for col in data.columns if col not in date_features]","a0021b0f":"train_data = data[all_features][data['istrain'] == 1].drop(columns='istrain')\ntest_data = data[all_features][data['istrain'] == 0].drop(columns='istrain')","1a6adac6":"train_data.columns","b5807bff":"n_train = train_data.shape[0]\ntrain_features = torch.tensor(train_data.drop(columns=['SaleID','price']).values, dtype=torch.float)\ntest_features = torch.tensor(test_data.drop(columns=['SaleID','price']).values, dtype=torch.float)\ntrain_labels = torch.tensor(train_data['price'].values, dtype=torch.float).view(-1, 1)","b8add898":"#loss = torch.nn.MSELoss()\nloss = torch.nn.L1Loss()\ndef get_net(feature_num):\n    \n    net = nn.Sequential(\n        nn.Linear(feature_num, 2048),\n        nn.ReLU(),\n        nn.Dropout(0.1),     \n        nn.Linear(2048, 4096),\n        nn.ReLU(),\n        nn.Dropout(0.2),\n        nn.Linear(4096, 4096),\n        nn.ReLU(),\n        nn.Dropout(0.2),  \n        nn.Linear(4096, 4096),\n        nn.ReLU(),\n        nn.Dropout(0.2),\n        nn.Linear(4096, 2048),\n        nn.ReLU(),\n        nn.Dropout(0.2),\n        nn.Linear(2048, 512),\n        nn.ReLU(),\n        nn.Dropout(0.1),\n        nn.Linear(512, 128),\n        nn.ReLU(),\n    \n        nn.Linear(128, 32),\n        nn.ReLU(),\n        nn.Linear(32, 1),\n        )\n    \n    for param in net.parameters():\n        nn.init.normal_(param, mean=0, std=0.01)\n    return net","c63d7037":"l1_loss = torch.nn.L1Loss()\ndef MAE(net, features, labels):\n    with torch.no_grad():\n        mae = l1_loss(net(features.to(device)), labels.to(device)).mean()\n    return mae","a304b48c":"def train(net, train_features, train_labels, test_features, test_labels,\n          num_epochs, learning_rate, weight_decay, batch_size, device='cpu'):\n    train_ls, test_ls = [], []\n    dataset = torch.utils.data.TensorDataset(train_features, train_labels)\n    train_iter = torch.utils.data.DataLoader(dataset, batch_size, shuffle=True)\n    # \u8fd9\u91cc\u4f7f\u7528\u4e86Adam\u4f18\u5316\u7b97\u6cd5\n    net = net.float()\n    net = net.to(device)\n    optimizer = torch.optim.Adam(params=net.parameters(), lr=learning_rate, weight_decay=weight_decay) \n    for epoch in range(num_epochs):\n        net.train()\n        for X, y in train_iter: \n            X, y = X.to(device), y.to(device)\n            l = loss(net(X.float()), y.float())\n            optimizer.zero_grad()\n            l.backward()\n            optimizer.step()\n        train_ls.append(MAE(net, train_features, train_labels))\n        if test_labels is not None:\n            net.eval()\n            test_ls.append(MAE(net, test_features, test_labels))\n    return train_ls, test_ls","33488227":"def get_k_fold_data(k, i, X, y):\n    # \u8fd4\u56de\u7b2ci\u6298\u4ea4\u53c9\u9a8c\u8bc1\u65f6\u6240\u9700\u8981\u7684\u8bad\u7ec3\u548c\u9a8c\u8bc1\u6570\u636e\n    assert k > 1\n    if k >=100:\n        return X, y, X, y\n    fold_size = X.shape[0] \/\/ k\n    X_train, y_train = None, None\n    for j in range(k):\n        idx = slice(j * fold_size, (j + 1) * fold_size)\n        X_part, y_part = X[idx, :], y[idx]\n        if j == i:\n            X_valid, y_valid = X_part, y_part\n        elif X_train is None:\n            X_train, y_train = X_part, y_part\n        else:\n            X_train = torch.cat((X_train, X_part), dim=0)\n            y_train = torch.cat((y_train, y_part), dim=0)\n    return X_train, y_train, X_valid, y_valid","b55df739":"def k_fold(net, k, X_train, y_train, num_epochs,\n           learning_rate, weight_decay, batch_size, device='cpu', val_num=0):\n    train_l_sum, valid_l_sum = 0, 0\n    for i in range(val_num, val_num + 1):\n        data = get_k_fold_data(k, i, X_train, y_train)\n        #net = get_net(X_train.shape[1])\n        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,\n                                   weight_decay, batch_size, device)\n        train_l_sum += train_ls[-1]\n        valid_l_sum += valid_ls[-1]\n        print('fold %d, train rmse %f, valid rmse %f' % (i, train_ls[-1], valid_ls[-1]))\n    return net, train_l_sum \/ 1, valid_l_sum \/ 1","066a69db":"# k, num_epochs, lr, weight_decay, batch_size = 5, 5, 0.001, 0, 1000\n# net, train_l, valid_l  = k_fold(net, k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size)\n# print('%d-fold validation: avg train rmse %f, avg valid rmse %f' % (k, train_l, valid_l))","e450e0af":"for val_num in range(5):\n    torch.cuda.empty_cache()\n    best_valid_l = 10000\n    best_model = None\n    for num in range(10):\n        print(num, 'loop')\n        if best_model:\n            net = best_model\n        else:\n            net = get_net(train_features.shape[1])\n        k, num_epochs, lr, weight_decay, batch_size = 5, 1, 1e-4, 0, 256\n        for i in range(25):\n            if i<=20 and i % 5 == 4:\n                lr *= 0.1\n                batch_size *= 2\n                net = best_model\n            print(str(i) + 'th train on', device)\n            net, train_l, valid_l  = k_fold(net, k, train_features, train_labels, \n                                            num_epochs, lr, weight_decay, batch_size, device, val_num\n                                           )\n\n            if valid_l < best_valid_l:\n                best_model = net\n                best_valid_l = valid_l \n                print(\"find best model, saving:\")\n                torch.save(net, str(val_num) + 'net.pkl')#\u6574\u4e2a\u7f51\u7edc\n                #torch.save(net.state_dict(),'net_params.pkl')#\u7f51\u7edc\u7684\u53c2\u6570\n                print('best model saved')\n        print('train complete')\n        \n    net = best_model.to('cpu')\n    preds = net(test_features).detach().numpy()\n    temp = pd.DataFrame(preds.reshape(1, -1)[0], columns=['price'])\n    sub = pd.DataFrame()\n    sub['SaleID'] = test_data['SaleID']\n    submission = sub.reset_index(drop = True)\n    submission['price'] = temp\n    submission.to_csv('\/kaggle\/working\/' + str(val_num) + 'submission.csv', index=False)\n    \n","dd5c68eb":"# net = best_model.to('cpu')\n# preds = net(test_features).detach().numpy()\n# temp = pd.DataFrame(preds.reshape(1, -1)[0], columns=['price'])\n# sub = pd.DataFrame()\n# sub['SaleID'] = test_data['SaleID']\n# submission = sub.reset_index(drop = True)\n# submission['price'] = temp\n# submission.to_csv('\/kaggle\/working\/' + str(val_num) + 'submission.csv', index=False)","e204706e":"from IPython.display import FileLink\nFileLink(str(4) + 'net.pkl')","998fbd29":"pd.read_csv('4submission.csv').describe()","3a185e21":"# build model"}}