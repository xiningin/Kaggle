{"cell_type":{"3aaa1ba2":"code","62639363":"code","b263006a":"code","9cbb8ed9":"code","e148b8df":"code","56480c6e":"code","20e2eb8b":"code","f972861c":"code","df9464d7":"code","32d758c5":"code","501ec364":"code","d1afc93d":"code","28968777":"code","4b8f3c4a":"code","f09392cf":"code","988d9a28":"code","7141d4b3":"code","fe6d11eb":"code","358d4a34":"code","8d6523a1":"code","ddc2e5cf":"markdown","0134f5bf":"markdown"},"source":{"3aaa1ba2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","62639363":"df = pd.read_csv(\"..\/input\/imdb-extensive-dataset\/IMDb movies.csv\")\ndf.columns","b263006a":"df = df[['title','genre', 'year', 'duration', 'avg_vote', 'votes']]\n\ndf.head()","9cbb8ed9":"df.info()","e148b8df":"df[\"year\"].unique()","56480c6e":"df = df.dropna()","20e2eb8b":"df[\"year\"].unique()","f972861c":"df[\"genre\"].unique()","df9464d7":"df[\"votes\"].unique()","32d758c5":"df[\"year\"]= df[\"year\"].str.replace(\"TV Movie 2019\", \"2019\", case = False) \n\n  ","501ec364":"df[\"year\"] = df[\"year\"].astype(float)\nmovies = df.copy()","d1afc93d":"df[\"year\"].unique()","28968777":"movies = df","4b8f3c4a":"def build_chart(df,percentile=0.9):\n    \n    print(\"Enter your preferred Genre type\")\n    genre= input()\n    print(\"Enter the minimum length of the movie\")\n    low_length = int(input())\n    print(\"Enter the maximum length of the movie\")\n    high_length = int(input())\n    print(\"Enter the earliest year  of the movie\")\n    low_year =int(input())\n    print(\"Enter the latest year of the movie\")\n    high_year =int(input())\n    movies = df.copy()\n    movies = movies[(movies['genre']==genre) &(movies['duration']>=low_length) &(movies['duration']<=high_length)&(movies['year']>=low_year)&(movies['year']<=high_year)]\n    c = movies['avg_vote']\n    m = movies['votes'].quantile(percentile)\n    \n    #Only consider movies that have higher than m votes. Save this in a new dataframe q_movies\n    q_movies = movies.copy().loc[movies['votes'] >= m]\n    \n    #Calculate score using the IMDB formula\n    q_movies['score']= q_movies['avg_vote']\n    q_movies['score'] = q_movies.apply(lambda x: (x['votes']\/(x['votes']+m) * x['avg_vote'])+ (m\/(m+x['votes']) * c),axis=1)\n\n    #Sort movies in descending order of their scores\n    q_movies = q_movies.sort_values('score', ascending=False)\n    \n    return q_movies","f09392cf":"movies","988d9a28":"def weighted_rating(x, m=m, C=c):\n    v = x['votes']\n    R = x['avg_vote']\n    # Compute the weighted score\n    return (v\/(v+m) * R) + (m\/(m+v) * C)","7141d4b3":"q_movies = build_chart(df,0.8)","fe6d11eb":"q_movies","358d4a34":"q_movies","8d6523a1":"len(q_movies)","ddc2e5cf":"The build_chart function","0134f5bf":"Need to handle NaN"}}