{"cell_type":{"c360224f":"code","93978436":"code","732987a9":"code","6f35914e":"code","b86b9d35":"code","6414a346":"code","eb4bdb1c":"code","3370a327":"code","91347b9d":"code","e371c788":"code","55274b8c":"code","eee8e734":"code","9e114ad0":"code","c889797b":"code","035ff5b3":"code","d3238375":"code","fc464b79":"code","bc0a5cab":"code","3f0a9024":"code","b02e35f1":"code","c496eaa3":"markdown","62561612":"markdown","adee1da8":"markdown","d4275dd8":"markdown","8de06fb2":"markdown","06a569c9":"markdown"},"source":{"c360224f":"# Data Wrangling\nimport numpy as np\nimport pandas as pd\nimport datetime as dt\n\n# Visualization\nimport seaborn as sns\nimport matplotlib.pyplot as plt","93978436":"# Import and wrangle with stock_ret dataset\nstock_ret = pd.read_csv('..\/input\/nifty50data\/Nifty 50 Historical Data.csv')\nstock_ret['Date'] = pd.to_datetime(stock_ret['Date'])\nstock_ret.head()\n\n# Calculate monthly Total Returns for the Nifty50 (excluding dividends)\nstock_ret['mth_return'] = stock_ret['Nifty50']\/stock_ret['Nifty50'].shift(1) - 1\n\n# Analysis 2008 onwards\nstock_ret = stock_ret.loc[5:].copy()\nstock_ret['cum_return'] = np.cumprod(stock_ret['mth_return']+1)\nstock_ret.info()\nstock_ret.head()","732987a9":"# Calculate the negative runs in the Nifty50 (i.e., from one peak to another)\n# Initialize an empty list for cumulative returns from one peak to another \nneg_run = []\n\n# Store the previous maximum cumulative return\nmax_cum_ret_now = stock_ret['cum_return'].iloc[0]   \n\n# enumerate() method adds counter (t) to an iterable (stock_ret['mth_return']) and \n# returns a tuple (t, stock_ret['mth_return'])\nfor t, val in enumerate(stock_ret['mth_return']):\n    \n    # First return in the monthly return series\n    if t == 0:\n        \n        # If monthly return is negative\n        if val < 0:\n            \n            # Append the negative return to neg_run list\n            neg_run.append(val)\n            \n        else:\n            \n            # Append a zero to neg_run list\n            neg_run.append(0)\n            \n    # Not the first return in the monthly return series\n    else:\n        \n        # If the cumulative return at time t is less than the previous maximum cumulative return\n        # i.e., the previous all time high\n        if stock_ret['cum_return'].iloc[t] < max_cum_ret_now:\n            \n            # cumulate\/compound the return at time t with the return at time t-1\n            # i.e., tally the loss\n            neg_run.append((1 + neg_run[t-1])*(1 + val) - 1) \n            \n        # If the cumulative return at time t is more than the previous maximum cumulative return\n        else:\n            \n            # stop the loss tally and append a zero to the negative run list\n            neg_run.append(0)                                \n            \n            # replace the previous all time high with the new high\n            max_cum_ret_now = stock_ret['cum_return'].iloc[t]\n\n# Add the variable to the dataframe stock_ret\nstock_ret['neg_run'] = neg_run","6f35914e":"# Plot the Nifty50 time series\nsns.lineplot(x='Date', y='Nifty50', data=stock_ret, color='red')","b86b9d35":"# Plot the peak-to-peak negative run\nsns.lineplot(x='Date', y='neg_run', data=stock_ret, color='red')","6414a346":"# Recap that a neg_run is the peak-to-peak run \n# Identify and label each neg_run sequentially (e.g., the 10th neg_run is tagged as 10)\n# The label serves as the groupby variable to examine the characteristics of each run\n\n# Initialize label value\nlabel = 1\n\n# Initialize the indicator value of whether stock_ret['neg_run'] (or loss tally) is within a peak-to-peak run\nwithin_negative_run = False\n\n# Initialize an empty list for negative run number\nneg_run_num = []\n\n# Identify and label each cycle of negative run, which ends with a zero\n# The cumulative return (or loss tally) during the cycle is negative\nfor i in stock_ret['neg_run']:\n    \n    # Loss tally is negative\n    if i < 0:\n        \n        # Append the label to neg_run_num list\n        neg_run_num.append(label)\n        \n        # Switch the state for within_negative_run\n        within_negative_run = True\n        \n    # Loss tally is zero - negative run ends\n    else:\n        \n        # Append a zero to neg_run_num list\n        neg_run_num.append(0)\n        \n        # Increment label value by 1 if within_negative_run is True\n        # This happens only for a 'new' cycle of negative run\n        # The label doesn't increment by 1 in market run-up after the exit from a negative run\n        # i.e., reaching new all-time highs after exiting from a cycle of negative run\n        if within_negative_run:\n            label += 1\n            within_negative_run = False\n            \nstock_ret['neg_run_num'] = neg_run_num","eb4bdb1c":"# Identify and label each peak (previous all time high) to trough (the lowest point) within each peak-to-peak run\n# This is also known as the maximum drawdown\n# The integer label runs sequentially (e.g., the 10th peak-to-trough is tagged as 10)\n\n# Initialize the label value\nlabel = 1\n\n# Initialize the search status of whether the lowest point within a negative run has been discovered\nis_neg_run_min = False\n\n# Initialize an empty list for peak-to-trough run number\npeak_trough_num = []\n\nfor t, val in enumerate(stock_ret['neg_run_num']):\n    \n    # Identify the lowest point (i.e., cumulated returns) within a negative run\n    trough = min(stock_ret[stock_ret['neg_run_num']==val]['neg_run'])\n    \n    # Recap that if the cumulative return at time t is more than the previous maximum cumulative return\n    # The loss tally will stop with a zero appended to the negative run list (i.e., the negative run has ended)\n    # neg_run_num will also be appended with a zero when neg_run is zero\n\n    # While still within a peak-to-peak negative run\n    if val > 0:\n        \n        # Append zero to peak_trough_num if the lowest point has been discovered\n        if is_neg_run_min:\n            peak_trough_num.append(0)\n            \n        # Lowest point within a negative run has not been discovered\n        else:\n            if stock_ret.iloc[t]['neg_run'] == trough:\n                is_neg_run_min = True\n                peak_trough_num.append(val)\n            else:\n                peak_trough_num.append(val)\n                \n    # Out of the peak-to-peak negative run\n    else:\n        is_neg_run_min = False\n        peak_trough_num.append(val)\n            \nstock_ret['peak_trough_num'] = peak_trough_num","3370a327":"# Groupby's to check out the durations and maximum loss or drawdown of each market decline identified\n# There are 82 peak-to-peak negative runs\n\n# By peak-to-peak run number, count the number of months \nrun_len = stock_ret[stock_ret['neg_run_num']>0].groupby('neg_run_num').count()['neg_run']\n\n# By peak-to-peak run number, count lowest cumulative returns (i.e., maximum drawdown)\nmaximum_drawdown = stock_ret[stock_ret['neg_run_num']>0].groupby('neg_run_num').min()['neg_run']\n\n# By peak-to-trough run number, count the number of months\npeak_trough_dur = stock_ret[stock_ret['peak_trough_num']>0].groupby('peak_trough_num').count()['neg_run']\n\nfig, ax = plt.subplots(3)\nax[0].plot(run_len.sort_values(ascending=False).reset_index(drop=True))\nax[0].set_title(\"Time between Two Peaks (Months)\")\nax[1].plot(peak_trough_dur.sort_values(ascending=False).reset_index(drop=True))\nax[1].set_title(\"Time to Maximum Drawdown (Months)\")\nax[2].plot(maximum_drawdown.sort_values(ascending=False).reset_index(drop=True))\nax[2].set_title(\"Maximum Drawdown (%)\")\nfig.tight_layout()","91347b9d":"# Store groupby results in a new dataframe with the 82 runs\ndeclines_df = pd.DataFrame()\n\ndeclines_df['run_len'] = run_len\ndeclines_df['maximum_drawdown'] = maximum_drawdown\ndeclines_df['peak_trough_dur'] = peak_trough_dur\n\ndeclines_df.tail(10)","e371c788":"# Create 6 buckets by the magnitude of drawdown\ndrawdown_bin = []\nfor i in maximum_drawdown:\n    if i >= 0.00:\n        drawdown_bin.append(0)\n    elif i >= -0.05:\n        drawdown_bin.append(1)\n    elif i >= -0.10:\n        drawdown_bin.append(2)\n    elif i >= -0.20:\n        drawdown_bin.append(3)\n    elif i >= -0.30:\n        drawdown_bin.append(4)\n    else:\n        drawdown_bin.append(5)\n\ndeclines_df['drawdown_bin'] = drawdown_bin","55274b8c":"# Overall means for drawdown metrics\nnp.mean(declines_df)","eee8e734":"# Count the number of drawdowns in each drawdown bucket\ndeclines_df.groupby('drawdown_bin').count()['run_len']","9e114ad0":"# Plot the number of declines in each magnitude bucket in probability term\n\n# Calculate the probability of being in a drawdown bin relative to all drawdown bins\nprob_bucket = declines_df.groupby('drawdown_bin').count()['run_len']\/sum(declines_df.groupby('drawdown_bin').count()['run_len'])\n\n# Plot the probabilities for each drawdown bin\nfig, ax = plt.subplots(figsize=(10,6))\nbin_names = ['-5% or Better','-5% to -10%','-10% to -20%','-20% to -30%','-30% or Worse']\nsns.barplot(x=prob_bucket, y=bin_names);\nax.set_xlabel(\"Probability\",fontsize=14)\nax.set_ylabel(\"Drawdown Bin\",fontsize=14)\n\n# Probability is between 0 and 1 - limit the range of possible value for x-axis\nax.set_xlim(0, 1)\n\nplt.tight_layout()","c889797b":"# What happens after the market has already dropped by 5%\n\n# Calculate the probability for \nworst_probs = prob_bucket[1:]\/sum(prob_bucket[1:])\n\n# probability of decline more than 10%\nprint(\"The probability of a further decline of more than 10% is\", sum(worst_probs[1:]))     \n\n# probability of decline being more than 20%\nprint(\"The probability of a further decline of more than 20% is\", sum(worst_probs[2:]))","035ff5b3":"# Calculate the mean maximum drawdown for each drawdown bucket of negative runs \ndeclines_df.groupby('drawdown_bin').mean()['maximum_drawdown']","d3238375":"# Calculate the metrics of each drawdown bucket and store in a dataframe for plots\n\n# Calculate the peak-to-peak and peak-to-trough duration for each run\nduration_df = declines_df.groupby('drawdown_bin').mean()[['peak_trough_dur','run_len']]\nduration_df.reset_index(inplace=True)\n\n# Time to recover (in months)\nduration_df['recover_dur'] = duration_df['run_len'] - duration_df['peak_trough_dur']\n\n# Time to recover relative to time to the trough\nduration_df['recover_to_peak_trough_ratio'] = duration_df['recover_dur'] \/ duration_df['peak_trough_dur']","fc464b79":"# Plot the metrics\nfig, ax = plt.subplots(figsize=(10,6))\nbin_names = ['-5% or Better','-5% to -10%','-10% to -20%','-20% to -30%','-30% or Worse']\nsns.barplot(x=bin_names, y=duration_df['recover_dur'])\nax.set_xlabel(\"Market Decline Bin\",fontsize=14)\nax.set_ylabel(\"Recovery Time in Months\",fontsize=14)\n\nplt.tight_layout()","bc0a5cab":"duration_df","3f0a9024":"# Calculate the Number and percentage of negative months\nprint(\"The number of negative monthly returns: \", len([i for i in stock_ret['mth_return'] if i<0]))\nprint(\"The number of monthly returns: \", stock_ret.shape[0])\nprint(\"The fraction of negative monthly returns: \", len([i for i in stock_ret['mth_return'] if i<0])\/stock_ret.shape[0])","b02e35f1":"# Calculate the Mean length of drawdown\nprint(\"The average length of peak-to-trough market downturn: \", np.mean(declines_df['peak_trough_dur']), \"months\")","c496eaa3":"<a id=\"section-five\"><\/a>\n# 5. REFERENCES\n\nThis notebook is adapted from works by [Yiuh Yuk](https:\/\/github.com\/yiuhyuk).","62561612":"<a id=\"section-four\"><\/a>\n# 4. CONCLUSION","adee1da8":"<a id=\"subsection-three-one\"><\/a>\n## 3.1 Question 1: How do we identify the negative runs (i.e., peak-to-peak) in the Nifty50?","d4275dd8":"<a id=\"subsection-three-two\"><\/a>\n## 3.2 Question 2: How do we label the negative runs (peak-to-peak) and their maximum drawdown (peak-to-trough)?","8de06fb2":"<a id=\"subsection-three-three\"><\/a>\n## 3.3 Question 3: How do we calculate the duration (peak-to-peak, peak-to-trough, and trough-to-peak) and maximum drawdown (loss) for each negative run?","06a569c9":"<a id=\"subsection-three-four\"><\/a>\n## 3.4 Question 4: How do the different types of market downturns (by severity) behave? "}}