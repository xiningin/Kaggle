{"cell_type":{"4679e982":"code","f6a1d171":"code","a5bc5243":"code","28597968":"code","63302a9d":"code","33f8221c":"code","1082a477":"code","12cd7930":"code","f94d3e61":"code","55f9db83":"code","f7046a26":"code","12388755":"code","69585ff4":"code","137b2dba":"code","a69a8d0d":"code","7e192aea":"code","a74835da":"code","37ff2702":"code","65e643b4":"code","f7737014":"code","47a42103":"markdown","5dbd3a7d":"markdown","fa85f0d5":"markdown","e2bf648a":"markdown","336099a0":"markdown","0eaaf62f":"markdown","de64eecc":"markdown","4a65c85a":"markdown","252a3705":"markdown","f8b0e864":"markdown","cbfd594d":"markdown","a723b5a2":"markdown","35586575":"markdown","3d5c0261":"markdown","1f63b43c":"markdown","8130de7f":"markdown"},"source":{"4679e982":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\n\n# Any results you write to the current directory are saved as output.","f6a1d171":"# Settings\n\npokemon_data = pd.read_csv('..\/input\/pokemon.csv')\ncombats_data = pd.read_csv('..\/input\/combats.csv')\n\n# Here, we will work only on legendary pokemons\nlegendary_data = pokemon_data[pokemon_data['Legendary']]\nnon_legendary_data = pokemon_data[pokemon_data['Legendary'] == False]\n\npokemon_data.head()","a5bc5243":"legendary_data.describe()","28597968":"non_legendary_data.describe()","63302a9d":"# storing combat statistics maximum values\natk_max = pokemon_data['Attack'].values.max()\ndef_max = pokemon_data['Defense'].values.max()\nsp_atk_max = pokemon_data['Sp. Atk'].values.max()\nsp_def_max = pokemon_data['Sp. Def'].values.max()\nspeed_max = pokemon_data['Speed'].values.max()","33f8221c":"winner = combats_data['Winner'].value_counts().idxmax()\npokemon_data.iloc[[winner]].Name","1082a477":"# Let's create two classes : the first wins, the second wins\nfirst_winner = combats_data[combats_data['First_pokemon'] == combats_data['Winner']]\nsecond_winner = combats_data[combats_data['First_pokemon'] != combats_data['Winner']]","12cd7930":"# What are the types of our pokemons ?\npokemon_data['Type 1'].value_counts()","f94d3e61":"# Here, we will create utilitaries to convert data from the pokemon data to usable values\ntype_dict = {\n    'Water' : 0,\n    'Normal': 1,\n    'Grass': 2,\n    'Bug': 3,\n    'Psychic': 4,\n    'Fire': 5,\n    'Rock': 6,\n    'Electric': 7,\n    'Ground': 8,\n    'Dragon': 9,\n    'Ghost': 10,\n    'Dark': 11,\n    'Poison': 12,\n    'Fighting': 13,\n    'Steel': 14,\n    'Ice': 15,\n    'Fairy': 16,\n    'Flying': 17\n}\n\ndef create_type_array(type1, type2=''):\n    res_arr = [0 for i in range(18)]\n    res_arr[type_dict[type1]] = 1\n    if type2 in type_dict.keys():\n        res_arr[type_dict[type2]] = 1\n    res_arr = np.array(res_arr)\n    res_arr = res_arr \/ np.linalg.norm(res_arr)\n    return res_arr.tolist()","55f9db83":"# Creation of a fonction that will generate our input from a match configuration\nfield_to_keep = ['Type 1', 'Type 2', 'Attack', 'Defense', 'Sp. Atk', 'Sp. Def', 'Speed']\ndef match_data(id1, id2):\n    data = []\n    \n    # looking at first pokemon data\n    first_pokemon = pokemon_data.loc[id1, field_to_keep].values.tolist()\n    arr_type = create_type_array(first_pokemon[0], first_pokemon[1])\n    atk = first_pokemon[2] \/ atk_max\n    def_ = first_pokemon[3] \/ def_max\n    sp_atk = first_pokemon[4] \/ sp_atk_max\n    sp_def = first_pokemon[5] \/ sp_def_max\n    speed = first_pokemon[6] \/ speed_max\n    data += arr_type + [atk, def_, sp_atk, sp_def, speed]\n    \n    # looking at second pokemon data\n    second_pokemon = pokemon_data.loc[id2, field_to_keep].values.tolist()\n    arr_type = create_type_array(second_pokemon[0], second_pokemon[1])\n    atk = second_pokemon[2] \/ atk_max\n    def_ = second_pokemon[3] \/ def_max\n    sp_atk = second_pokemon[4] \/ sp_atk_max\n    sp_def = second_pokemon[5] \/ sp_def_max\n    speed = second_pokemon[6] \/ speed_max\n    data += arr_type + [atk, def_, sp_atk, sp_def, speed]\n    \n    return data","f7046a26":"x_data = []\ny_data = []\nfor index, row in combats_data.iterrows():\n    x_data += [match_data(row['First_pokemon'] - 1, row['Second_pokemon'] - 1)]\n    if row['First_pokemon'] == row['Winner']:\n        y_data += [1]\n    else:\n        y_data += [-1]","12388755":"from sklearn.model_selection import train_test_split\nx_train, x_val, y_train, y_val = train_test_split(x_data, y_data, test_size=0.25)","69585ff4":"from sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.decomposition import PCA\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import LinearSVC\nfrom sklearn.ensemble import RandomForestClassifier\n\n# clf = LogisticRegression(penalty='l2', C=25, solver='liblinear')  # Acc: 0.88\n# clf = LinearSVC(penalty='l2', loss='hinge', dual=True, tol=0.00001, C=10.0, random_state=42, max_iter=5000)  #Acc: 0.908\n\nclf = RandomForestClassifier(n_estimators=250,\n                             criterion='gini',\n                             max_depth=None,\n                             min_samples_split=2,\n                             min_samples_leaf=1,\n                             max_features='sqrt')  #Acc: 0.94\nparam_dict = {\n    'n_estimators': [125, 250],\n    #'criterion': ['gini', 'entropy'],\n    #'max_depth': [None, 5, 8],\n    #'min_samples_leaf': [1, 2, 4],\n    #'max_features': ['sqrt', 'log2']\n}\n\ngrid_search = GridSearchCV(clf, param_dict, cv=3, verbose=2, n_jobs=4)\n\ngrid_search.fit(x_train, y_train)\n\nprint(grid_search.best_score_)    \nprint(grid_search.best_params_)\n","137b2dba":"from sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier(n_estimators=250,\n                             criterion='gini',\n                             max_depth=None,\n                             min_samples_split=2,\n                             min_samples_leaf=1,\n                             max_features='sqrt')  #Acc: 0.94\n\nclf.fit(x_train, y_train)\n\nprint(clf.score(x_val, y_val))","a69a8d0d":"# First, we will define a function that will test a pokemon during multiple fights to score him\ndef pokemon_test(pokemon_id, opponent_ids=None):\n    # pokemon_id is an id between 0 and 799\n    if opponent_ids is None:\n        opponents = [i for i in range(800) if i != pokemon_id]\n    else:\n        opponents = opponent_ids\n    \n    # We will predict 2*799 fights\n    victory_cpt = 0\n    for opp in opponents:\n        match_1 = match_data(pokemon_id, opp)\n        if clf.predict([match_1])[0] == 1:\n            victory_cpt += 1\n        \n        match_2 = match_data(opp, pokemon_id)\n        if clf.predict([match_2])[0] == -1:\n            victory_cpt += 1\n    \n    return victory_cpt \/ (2*799)","7e192aea":"print(pokemon_test(0))","a74835da":"def test_pokemon_subset(ids_to_test, verbose=True):\n    best_pokemon = ids_to_test[0]\n    best_winning_rate = -1\n    \n    test_cpt = 1\n    n_test = len(ids_to_test)\n    for pok_id in ids_to_test:\n        winning_rate = pokemon_test(pok_id)\n        \n        if verbose:\n            print(\"-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\")\n            print(\"Pokemon {} out of {}\".format(test_cpt, n_test))\n            print(\"{} winning rate : {}\".format(pokemon_data.loc[pok_id, \"Name\"], winning_rate))\n            print(\"-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\")\n        \n        if winning_rate > best_winning_rate:\n            best_winning_rate = winning_rate\n            best_pokemon = pok_id\n            \n        test_cpt += 1\n            \n    return best_pokemon, best_winning_rate","37ff2702":"def test_legendary_pokemons():\n    legendary_ids = legendary_data['#'].values - 1\n    return test_pokemon_subset(legendary_ids)\n\nb_legendary, win_rate = test_legendary_pokemons()","65e643b4":"print(\"{} with a winning rate of {:.3f}%\".format(pokemon_data.loc[b_legendary, \"Name\"], win_rate * 100.0))","f7737014":"# these are just examples\nice_subset = pokemon_data[pokemon_data['Type 1'] == 'Ice']\nfirst_generation = pokemon_data[pokemon_data['Generation'] == 1]\n\n# ['#'].values - 1 to get the ids\nbest_pokemon, win_rate = test_pokemon_subset(ice_subset['#'].values - 1, verbose=False)\nprint(\"Best ice pokemon: {} with a winning rate of {:.3f}%\".format(pokemon_data.loc[best_pokemon, \"Name\"], win_rate * 100.0))","47a42103":"## Prediction","5dbd3a7d":"Now, just for fun, let's find the pokemon which has the most victories in the dataset.","fa85f0d5":"Now, we could use this to choose the best Water, Fire, Flying, 1st generation, ... pokemon :)","e2bf648a":"First, let's create separate our data into a training set and a validation set","336099a0":"Bulbasaur has a 23% winning rate, it won't be our choice...\n\nNow, let's test only the legendary pokemons, to speed up a bit the calculation","0eaaf62f":"Now, we need to create the data we will feed to our machine learning algorithm. I have decided to translate the pokemon types to an array form, to which I will just concatenate the normalized combat statistics.","de64eecc":"## Data description\n\nLet's look at some statistics on legendary and non legendary pokemons. Legendary have better average stats but they don't have the better pokemon for each stat !!","4a65c85a":"With this new function, let's test Bulbasaur.","252a3705":"To choose a classifier, we will use a grid search. You don't need to run this grid search as the best classifier is defined in the next cell.","f8b0e864":"To normalize combat statistics (attack, defense, ...) in our training data creation, I store the maximum values of each one of these statistics.","cbfd594d":"To achieve this goal of choosing a pokemon, I will use 3 steps:\n1. Look at the dataset\n2. Create a machine learning algorithm to predict a combat output\n3. Use this algorithm as a way to mark a pokemon","a723b5a2":"AND THE WINNER IS:","35586575":"Now, we will parse the combat data to create our training data, with its labels.","3d5c0261":"From the combat data, Mega Mewtwo X is our winner.\nNow, we did not even check for the frequency of this pokemon fights against another so this is clearly not how we want to get a result.\n\nLet's prepare the data so we can train a classifier on it.","1f63b43c":"# How to choose a pokemon ?\n\nIn this kernel, I will try to choose the best legendary pokemon according to these combat stats. I just want to try it for fun !!\nSo first, I will look at the data, then I will try to create a good combat prediction, which will give me the name of the best pokemon ever !!","8130de7f":"## Pokemon choice\n\nNow, with our algorithm to predict a fight we can find the best fighting pokemon."}}