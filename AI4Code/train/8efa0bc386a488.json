{"cell_type":{"3db8d9bd":"code","ac92ad7b":"code","bf317d83":"code","e42ab213":"code","fe01deb8":"code","8d3f7c9e":"code","cf542f32":"code","c7f5e395":"code","108bd014":"code","731cfe56":"code","6de17ef6":"code","6bc33fc4":"code","d6248b88":"code","8c80f4b3":"code","128bb6fb":"code","7e2e76fb":"code","67d4835f":"code","30033eea":"code","cedc3bf9":"code","fd6560ac":"code","ef77a48c":"code","46b04cef":"code","722a77fe":"code","8fe8157f":"code","aeb6e3ff":"code","1c538d7e":"markdown","145a311b":"markdown","5c307789":"markdown","10203e3a":"markdown","2fd1df49":"markdown","6ed2f5f6":"markdown","ab813140":"markdown","cf707632":"markdown","8c91f9c9":"markdown","86e76030":"markdown","d9e9290a":"markdown","1604faf0":"markdown"},"source":{"3db8d9bd":"import torch.nn as nn\nimport torch\nimport matplotlib.pyplot as plt \nimport pandas as pd\n\nfrom sklearn.datasets import load_iris\nimport numpy as np","ac92ad7b":"torch.manual_seed(2)","bf317d83":"iris = load_iris()\nX = iris.data\nY = iris.target","e42ab213":"from sklearn.model_selection import train_test_split\nx, x_val, y, y_val = train_test_split(X, Y, test_size=0.33, random_state=42)","fe01deb8":"x.shape, y.shape, x_val.shape, y_val.shape","8d3f7c9e":"x_train = x.reshape(-1, x.shape[1]).astype('float32')\ny_train = y\n\nx_val = x_val.reshape(-1, x_val.shape[1]).astype('float32')\ny_val = y_val","cf542f32":"x_train.shape","c7f5e395":"x_val = torch.from_numpy(x_val)\ny_val = torch.from_numpy(y_val)","108bd014":"from torch.utils.data import Dataset, DataLoader\nclass Data(Dataset):\n    def __init__(self):\n        self.x=torch.from_numpy(x_train)\n        self.y=torch.from_numpy(y_train)\n        self.len=self.x.shape[0]\n    def __getitem__(self,index):      \n        return self.x[index], self.y[index]\n    def __len__(self):\n        return self.len","731cfe56":"data_set=Data()","6de17ef6":"trainloader=DataLoader(dataset=data_set,batch_size=64)","6bc33fc4":"data_set.x[1:10]","d6248b88":"data_set.y[1:10]","8c80f4b3":"data_set.x.shape, data_set.y.shape","128bb6fb":"class Net(nn.Module):\n    def __init__(self,D_in,H,D_out):\n        super(Net,self).__init__()\n        self.linear1=nn.Linear(D_in,H)\n        self.linear2=nn.Linear(H,D_out)\n\n        \n    def forward(self,x):\n        x=torch.sigmoid(self.linear1(x))  \n        x=self.linear2(x)\n        return x","7e2e76fb":"input_dim=4     # how many Variables are in the dataset\nhidden_dim = 25 # hidden layers\noutput_dim=3    # number of classes\ninput_dim","67d4835f":"# Instantiate model\nmodel=Net(input_dim,hidden_dim,output_dim)","30033eea":"print('W:',list(model.parameters())[0].size())\nprint('b',list(model.parameters())[1].size())","cedc3bf9":"criterion=nn.CrossEntropyLoss()","fd6560ac":"learning_rate=0.1\noptimizer=torch.optim.SGD(model.parameters(), lr=learning_rate)","ef77a48c":"n_epochs=1000\nloss_list=[]\n\n#n_epochs\nfor epoch in range(n_epochs):\n    for x, y in trainloader:\n      \n\n        #clear gradient \n        optimizer.zero_grad()\n        #make a prediction \n        z=model(x)\n        # calculate loss, da Cross Entropy benutzt wird muss ich in den loss Klassen vorhersagen, \n        # also Wahrscheinlichkeit pro Klasse. Das mach torch.max(y,1)[1])\n        loss=criterion(z,y)\n        # calculate gradients of parameters \n        loss.backward()\n        # update parameters \n        optimizer.step()\n        \n        loss_list.append(loss.data)\n        \n        \n        #print('epoch {}, loss {}'.format(epoch, loss.item()))","46b04cef":"z[0:10]","722a77fe":"z=model(x_val)","8fe8157f":"yhat=torch.max(z.data,1)\nyhat","aeb6e3ff":"y_val","1c538d7e":"Put Data through DataLoader, so we can use batches","145a311b":"View the size of the model parameters:","5c307789":"Define validation data as a Pytorch Tensor","10203e3a":"# Build Model and train it","2fd1df49":"# Load Iris Dataset","6ed2f5f6":"Build softmax Classifier","ab813140":"Check model on Validation Set","cf707632":"Optimizer","8c91f9c9":"Loss function","86e76030":"The full code can be found here: https:\/\/github.com\/lschmiddey\/PyTorch-Multiclass-Classification\/blob\/master\/Softmax_Regression_Deep_Learning_Iris_Dataset.ipynb","d9e9290a":"Use train_test_split to split data into train and validation set","1604faf0":"Each row represents a row from the original dataset. Each column represents a class. The first column represents the class 0, the second column class 1 and the third column class 2. The highest value for each row represents which class the model would put each row. For instance, the highest value in the first row is 9.3748, hence the predicted class is 0.  "}}