{"cell_type":{"1246d5fe":"code","f214acee":"code","9f9c6345":"code","2847477b":"code","bd341ba5":"code","9c17675d":"code","906651fd":"code","4aaaefc4":"code","7cfb5814":"code","f13dc1c4":"markdown","05ca39e8":"markdown"},"source":{"1246d5fe":"import numpy as np","f214acee":"np.bincount(np.arange(5))","9f9c6345":"np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))","2847477b":"import pandas as pd\n\ndf = pd.read_csv('https:\/\/archive.ics.uci.edu\/ml\/'\n                 'machine-learning-databases'\n                 '\/breast-cancer-wisconsin\/wdbc.data', header=None)","bd341ba5":"from sklearn.preprocessing import LabelEncoder\n\nX = df.loc[:, 2:].values\ny = df.loc[:, 1].values\nle = LabelEncoder()\ny = le.fit_transform(y)\nle.classes_","9c17675d":"le.transform(['M', 'B'])","906651fd":"from sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = \\\n    train_test_split(X, y, \n                     test_size=0.20,\n                     stratify=y,\n                     random_state=1)","4aaaefc4":"from sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import make_pipeline\n\npipe_lr = make_pipeline(StandardScaler(),\n                        PCA(n_components=2),\n                        LogisticRegression(random_state=1))\n\npipe_lr.fit(X_train, y_train)\ny_pred = pipe_lr.predict(X_test)\nprint('accuracy: %.3f' % pipe_lr.score(X_test, y_test))","7cfb5814":"import numpy as np\nfrom sklearn.model_selection import StratifiedKFold\n\nkfold = StratifiedKFold(n_splits=10).split(X_train, y_train)\n\nscores = []\nfor k, (train, test) in enumerate(kfold):\n    pipe_lr.fit(X_train[train], y_train[train])\n    score = pipe_lr.score(X_train[test], y_train[test])\n    scores.append(score)\n    print('folod: %2d, labels count: %s, accuracy: %.3f' % (k+1,\n          np.bincount(y_train[train]), score))\n    \nprint('\\nCV accuracy: %.3f +\/- %.3f' % (np.mean(scores), np.std(scores)))","f13dc1c4":"## np.bincount(y_train[train])\n\n## => label 0 count , label 1 count","05ca39e8":"**Count number of occurrences of each value in array of non-negative ints.**\n\nThe number of bins (of size 1) is one larger than the largest value in x. If minlength is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of x). Each bin gives the number of occurrences of its index value in x. If weights is specified the input array is weighted by it, i.e. if a value n is found at position i, out[n] += weight[i] instead of out[n] += 1."}}