{"cell_type":{"68f88886":"code","845b83cc":"code","6e0b618d":"code","b44645fa":"code","95f21292":"code","b6d1057a":"code","b50f1f99":"code","db2516cb":"code","ae4a0a5e":"code","6a5b002b":"markdown","39356e1a":"markdown","70a4d7f3":"markdown","996a8e39":"markdown"},"source":{"68f88886":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import train_test_split\nimport xgboost as xgb\nfrom xgboost import cv\nimport plotly.express as px","845b83cc":"df = pd.read_csv(\"..\/input\/red-wine-quality-cortez-et-al-2009\/winequality-red.csv\")","6e0b618d":"df.head()","b44645fa":"print(df.shape)","95f21292":"pip install atts","b6d1057a":"from atts.auto_test_splitter import atts ","b50f1f99":"k = ATTS(df, \"quality\" , 0.05, 0.50, 0.05)","db2516cb":"k.test_sizes_df()","ae4a0a5e":"k.test_sizes_plot(800,400)","6a5b002b":"## Python Package","39356e1a":"# ATTS \nATTS (Auto Train Test Splitter) splits the given dataframe to train and test taking into account the Concept Drift. It does this with xgboost running in the background. \n\nCalculates roc_auc scores for the given test size values. Creates a dataframe with these values.\nProvides easier change visibility with chart.","70a4d7f3":"Resources: https:\/\/pypi.org\/project\/atts\/ \n\nhttps:\/\/github.com\/alikula314\/att_split","996a8e39":"# What is Adversarial Validation?\nThe objective of any predictive modelling project is to create a model using the training data, and afterwards apply this model to the test data. However, for the best results it is essential that the training data is a representative sample of the data we intend to use it on (*i.e.* the test data), otherwise our model will, at best, under-perform, or at worst, be completely useless.   \n\n***Adversarial Validation*** is a very clever and very simple way to let us know if our test data and our training data are similar; we combine our `train` and `test` data, labeling them with say a `0` for the training data and a `1` for the test data, mix them up, then see if we are able to correctly re-identify them using a binary classifier.\n\nIf we cannot correctly classify them, *i.e.* we obtain an area under the [receiver operating characteristic curve](https:\/\/en.wikipedia.org\/wiki\/Receiver_operating_characteristic) (ROC) of 0.5 then they are indistinguishable and we are good to go.\n\nHowever, if we can classify them (ROC > 0.5) then we have a problem, either with the whole dataset or more likely with some features in particular, which are probably from  different distributions in the test and train datasets.\nIf we have a problem, we can look at the feature that was most out of place. The problem may be that there were values that were only seen in, say, training data, but not in the test data. If the contribution to the ROC is very high from one feature, it may well be a good idea to remove that feature from the model.\n\n\n## Adversarial Validation to reduce overfitting\nThe key to avoid overfitting is to create a situation where the local cross-vlidation (CV) score is representative of the competition score. When we have a ROC of 0.5 then your local data is representative of the test data, thus your local CV score should now be representative of the Public LB score.\n\nProcedure:\n\n* drop the training data target column \n* label the `test` and `train` data with `0` and `1` (it doesn't really matter which is which)\n* combine the training and test data into one big dataset\n* perform the binary classification, for example using XGboost\n* look at our AUC ROC score"}}