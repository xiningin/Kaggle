{"cell_type":{"e33e9566":"code","3cf275bf":"code","dfcb9e6d":"code","a612c77c":"code","e04bcbab":"code","0d284485":"code","e15fb914":"code","4ddcaeb0":"code","c3633be1":"code","2ef4873f":"code","0b02d410":"code","526b0038":"markdown","6f28798d":"markdown","77aaa686":"markdown","987a12ed":"markdown","d2b69b7f":"markdown","7692e076":"markdown","397864f0":"markdown","18c6291b":"markdown"},"source":{"e33e9566":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","3cf275bf":"# This is a 1 line comment\n\n\"\"\"\nThis is a multi-line comment\nWheeee\n\"\"\"\n\n# integer\na_index = 5\na_index += 1\n# or\na_index = a_index + 1\n# a_index++ is not currently supported\n\n# float\na_float = 3.141592654\n\n# strings\nname = \"Dave Sluiter\"\n# or\nname2 = 'Batman'\n\n# print() function\n#   note that a final \/nl character is added by print by default\n#   sep=\"\" says no space character between items\n#   FIXME \/nl override syntax?\nprint (\"Hello World\")\nprint (\"a_index=\", a_index, \" a_float=\", a_float, \" name=\", name, sep=\"\") ","dfcb9e6d":"# create a known list\na_list = ['Bob', 'Sheryl', 'Betty'] \nprint (a_list[1])\n\n# create an empty list and add array entries programmatically \nb_list = []\nb_list.append(5)\nb_list.append(\"Kangaroo\") # note each array entry can be a different data type\nb_list.append(7)\n\nprint (b_list[1], \" \", b_list[2], sep=\"\")\n\n# determine the length of a list\nm = len(b_list)\nprint (\"b_list is \", m, \" entires long\", sep=\"\")\n\n# Create a known dictionary. These are associative arrays with key:value pairs.\ndata_dict = {\n    # key     : value\n    \"students\": 10,\n    \"subject\":  20,\n    \"marks\":    30\n}\n\nprint (data_dict[\"marks\"])\n\n\n# empty dictionary and add entries programmatically\ndata2_dict = {}\ndata2_dict[\"A\"] = 100 # Create the dict entry\ndata2_dict[200] = \"B\" # Create the dict entry, keys do not have to be the same data type\ndata2_dict[\"C\"] = 300 # Create the dict entry\n\nprint (data2_dict[\"A\"])\nprint (data2_dict[200])\n\n","a612c77c":"a = 5\nb = 10\nc = 0\n\nif (a == 5): # note the \":\" character\n    c = 100\nelif (b == 10):\n    c = 200\nelse:\n    c = 300\nprint (\"c=\", c)\n\n# range function can be used to return a sequence of numbers\na_list = range(10) # 0 to 9, other options are available as well, this is the simple usage\n\n# For loop\n# this sequence can be iterated on using a for loop\n# Note: python uses indentation to define a block of code whereas C uses the { } characters\nfor a_number in range(10): # note the \":\" character\n    print (a_number)\n    # next statement in the for loop\n    \n# this statement is not in the for loop\nprint (\"Hello\")\n\n\n# While loop\na = 0\nwhile (a < 5):\n    a += 1\n    print (a)\n\n# this statement is not in the while loop\nprint (\"Hello\")","e04bcbab":"Ted = 1 # global variable\n\n# define a new function\ndef i_am_a_function(a, b, c):\n    \n    x = 10 # local variable to this function\n    \n    return (a * b * c) * (x + Ted)\n\n\nbob = i_am_a_function(1, 2, 3)\nprint (\"bob=\", bob, sep=\"\")\n\n\n\n# Not only can functions accept multiple input parameters, they can\n# return multiple results\ndef i_am_a_function2(a, b, c):\n    \n    x = 10 # local variable to this function\n    \n    return (a * b * c) * (x + Ted), (a * b * c)\n\nbob,dave = i_am_a_function2(2, 3, 4)\n\nprint (bob,dave)\n\n\n# For me there is some \"mystery\" when passing parameters to and from functions.\n# Based on experiements I've run, simple variables are passed by value and complex\n# variable \"objects\" are passed by reference (i.e. pointers). I'll leave it to you\n# to figure this out.","0d284485":"import numpy as np  # linear algebra\n\n# Create a known 1-d np array\na = np.array([1, 2, 3, 4, 5, 6]) # a row vector\nprint (\"shape of a=\", a.shape) # shape is a property of the object a\n\n# Create a known 2-d np array\nb = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n\n# this can be extended to n-dimensional arrays\nprint (a)\nprint (b)\n\na[2] = 100 # update an element\nprint (a[2])\n\nb[1][3] = 76 # update an element\nprint (b[1][3])\n\n\n# -------------------\n# Matrix operations\n# -------------------\n# Note the use of list syntax\ny = np.array( [ [1,], [2,], [3,]  ] ) # a column vector, 3 rows, 1 column\nprint (y)\n\nX = np.array( [ [1,2], [3,4], [5,6] ] ) # 2-d array, 3 rows, 2 columns\nprint(\"X=\\n\", X, \"shape of X=\", X.shape)\n# create the transpose of X\nXT = X.T\nprint(\"XT=\\n\", XT, \"shape of XT=\", XT.shape) # 2 rows, 3 columns\n\n# matrix multiplication, dot product\nbob = np.dot(XT, X) # a [2x3] dotted with a [3x2] yields a [2x2]\nprint (\"bob=\\n\", bob, \"shape of bob=\", bob.shape)\n\n# calculate the inverse of a matrix\n#bobinv = bob.inv()\nbobinv = np.linalg.inv(bob)  # .inv is an attribute (i.e. a function or method)\nprint (\"bob inv=\\n\", bobinv) # still [2x2]\n\nted = np.dot(bobinv, XT) # [2x2] dotted with a [2x3] yields a [2x3]\nprint (\"ted=\\n\", ted, \"shape of ted=\", ted.shape)\n\nfinal = np.dot(ted, y) # [2x3] dotted with a [3x1] yields a [2x1]\nprint(\"final=\\n\", final, \"shape of final=\", final.shape)","e15fb914":"import pandas as pd\n\n# create a data frame from 3 series\n\n# this function creates a series from the passed in list.\ndef createSeries (series_list):\n  # create a series\n  series_list = pd.Series(series_list)\n  return series_list\n\n\n# Create a series of students\nstudents = createSeries(['ABC', 'DEF',\n                         'GHI', 'JKL',\n                         'MNO', 'PQR',\n                         'STU'])  \n# Create a series of subjects\nsubject = createSeries(['C++', 'C#', \n                        'RUBY', 'SWIFT',\n                        'GO', 'PYTHON',\n                        'FORTH'])\n# Create a series of marks\nmarks = createSeries([90, 30, \n                      50, 70, \n                      80, 60,\n                      90])\n\n# Series have lots of methods available to explore the data.\n# See .min() .max() .mean() .var() .std() .skew()\n# You can count up the number of times that values occur in a series with \n# .value_counts()\nmark_counts = marks.value_counts() # returns a Series.\nprint (\"mark_counts:\\n\", mark_counts, sep=\"\") # see that 90 ocurred twice\n\n# Extract the first (top) 3 types from the Series\ntop_mark_counts = mark_counts[0:2]\n# We plot this below\n\n\n\n# Create a dictonary with text keys and pandas series as the values \ndata = {\"students\": students,\n        \"subject\": subject,\n        \"marks\": marks}\n\n# Create a DataFrame\n# Concatenating the series side by side as depicted by axis=1.\n# If you want to concatenate the series one below the other\n# change the axis to zero.\ndf = pd.concat(data,\n               axis = 1)\n  \n# show the dataframe\nprint(\"DataFrame:\\n\", df, sep=\"\")\nprint(\"DataFrame row[4]:\\n\", df.iloc[4], sep=\"\")\n\n# edit an element\ndf.at[2, \"marks\"] = 5\nprint (\"[2:marks=]\", df.at[2, \"marks\"])\n\nprint (\"length of df=\", len(df))\ndf\n\n\n\n# ---------------\n# File IO\n# ---------------\n\n# You can read and write CSV (comma separated value) files with Pandas.\n# If the CSV file's first row has column headings, this will read in the data\n# and create a DataFrame with the column headers from the CSV file, and the data,\n# with row indexes that default from 0 to n-1\n#\n# Read in a CSV file to a DataFrame\n### df = pd.read_csv(path_to_input_filename, header=0)\n\n# Write out a DataFrame to a CSV file\n### df.to_csv(path_to_output_filename, index=False)\n","4ddcaeb0":"# TensorFlow and tf.keras\nimport tensorflow as tf\nfrom   tensorflow import keras\nprint(\"tensorflow version=\", tf.__version__)\n\n\n# ----------------------------------------------------------\n# Build our model(s)\n# ----------------------------------------------------------\nnumber_of_input_features = 10 # number of features in each training sample\nnumber_of_categories     = 5  # number of categories\n\n\n# Instantiate a model with:\n#   An input layer with 10 inputs (10 nodes for the 10 features) using relu activation\n#   A hidden layer with 32 nodes using relu activation\n#   A hidden layer with 8 nodes using relu activation\n#   An output layer with 5 categories which are probabilities of\n#   correctness values from 0.0 to 1.0 via the softmax activation function\nmodel = keras.Sequential([\n    \n    keras.layers.Dense(number_of_input_features, activation=tf.nn.relu),\n    \n    keras.layers.Dense(32, activation=tf.nn.relu),\n    \n    keras.layers.Dense(8, activation=tf.nn.relu),\n    \n    # output layer with \"number_of_categories\" confidence levels (softmax) \n    keras.layers.Dense(number_of_categories, activation=tf.nn.softmax) \n    \n])\n\n# Instantiate an optimizer, Adam = Adaptive Moment Estimation\nadamOptimizer = keras.optimizers.Adam()\n\n\n# Compile the model with the optimizer\nmodel.compile(optimizer=adamOptimizer, \n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\n#print (\"Model metric names=\\n\", model.metrics_names) \n\nprint (\"Model constructed and compiled\")\n\n\n\n","c3633be1":"# -----------------------------------------\n# Training the model\n# -----------------------------------------\n\n# train_X is the cleaned up data with symbolic values mapped to numeric values, \n#    organized into a matrix, normalized, with duplicates removed (np array or a Pandas DataFrame).\n# train_y are the known target outcomes that have been mapped to numerical values\n#    (np column vector or a Pandas Series)\n# Epochs is the number of times the model is trained on the entire training dataset.\n\n### model.fit(train_X, train_y, epochs=3)\n\n","2ef4873f":"# -------------------------------------\n# Make predictions with the model\n# -------------------------------------\n\n# test_X is the cleaned up data that the model has never seen before and we\n# are trying to make predictions on.\n\n### predictions = model.predict(test_X)\n\n","0b02d410":"# -----------------------------------------------------------------------------\n# 8 Matplotlib \n#\n# See tutorials at:     https:\/\/www.tutorialspoint.com\/matplotlib\/index.htm\n#                   and https:\/\/www.w3schools.com\/python\/matplotlib_intro.asp\n# \n# -----------------------------------------------------------------------------\n\nimport matplotlib.pyplot as plt\nimport math\n\n# ---------------------\n# Simple plots\n# ---------------------\n# create x values from 0 to 2*pi stepping 0.05 as an ndarray\nx = np.arange(0, math.pi*2, 0.05)\n\n# create y values from the x values\ny = np.sin(x)\n\n# plot the values using the plot() function\nplt.plot(x,y)\n\n# You can set the plot title, and labels for x and y axes.\nplt.xlabel(\"angle (radians)\")\nplt.ylabel(\"sine\")\nplt.title('sine wave')\n\n# The Plot viewer window is invoked by the show() function\nplt.show()\n\n\n\n# plot y values with red dots\nx = np.linspace(-3, 3, 30)\ny = x**2\nplt.plot(x, y, 'r.')\n\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title('y=x**2')\n\nplt.show()\n\n# ------------------------------------------------------\n# plots can be overlaid, just use multiple plot commands\n# ------------------------------------------------------\n\n# create y values from the x values\ny1 = np.sin(x)\ny2 = np.cos(x)\n\n# plot the values using the plot() function\nplt.plot(x, y1, 'r-')\nplt.plot(x, y2, 'g--')\n\n# You can set the plot title, and labels for x and y axes.\nplt.xlabel(\"angle (radians)\")\nplt.ylabel(\"y\")\nplt.title('sine and cosine')\n\nplt.show()","526b0038":"## Tensorflow library\n\nKeras is a nice wrapper library around tensorflow that allows us to easily build and explore model topologies, activation functions, optimizers and a myriad of hyper-parameters for tuning our models. Multiple models can be built and explored in a single run.  \n\n**External Sources:** https:\/\/towardsdatascience.com\/building-our-first-neural-network-in-keras-bdc8abbc17f5","6f28798d":"## Lists","77aaa686":"## Numpy library\nnumpy implements matrix construction and operations  \n\nSee: https:\/\/numpy.org\/doc\/1.21\/\n     https:\/\/numpy.org\/doc\/1.21\/user\/absolute_beginners.html\n\nBoth sci-kit learn and tensor flow models can read np arrays.\n\nThe np library contains many methods for performing matrix operations so you don't have to spend time coding all those lower-level details, examples include matrix transpose, and matrix multiplication etc - yay!","987a12ed":"## Basic Data Types","d2b69b7f":"# Python Basics\nPython is an interpreted and compiled programming language. I call it a\nlanguage of convienience as many things are done for you behind the scene,\nexample: unlike C or C++ you don't have to declare variables, they pop into\nexistance when you first assign a value to a variable.  \n\nOne of python's strengths is the huge number of libraries that are available\nto you as the programmer. These libraries implement all kinds of functionality\nsuch that you can focus on writing your application code, though there is a\nlearning curve to use them effectively.  \n\n**External Sources:** https:\/\/www.programiz.com\/python-programming\/tutorial\n\nWe will cover:\n1. Basic data types\n2. Lists (arrays) and dictionaries (known as associative arrays, or hashes in perl or maps in C++)\n3. If\/else and for loops, iterators and while loops\n4. Functions\n5. Numpy library\n6. Pandas library, Series and DataFrames\n7. Tensorflow library, which includes the Keras library\n8. Matplotlib ","7692e076":"## If\/else and for loops, iterators and while loops","397864f0":"## Functions","18c6291b":"## Pandas library\nPandas implements a more sophisticated numpy library.  \nThe library functions much like Excel spreadsheets. Think \"np arrays\" but with column header values and row header values, typically text fields that describe the column or the row. Row headers are referred to as \"index\" values and column headers are referred to as \"column\" values. If you execute len(series_name), you'll get the number of rows in the Series. I think of this as the \"depth\" of the Series.  \n\n**External Sources:** https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/10min.html  \nSee docs at: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/frame.html  \n\nKey concepts:  \n\nFirst we have a data structure known as a Series. You can think of a Series as a\ncolumn vector of data. They operate much like a dictionary and indexed by the row index \"keys\".\nThe one difference with a series vs. a dictionary is that a Series has to contain element \nvalues that are all of the same data type - be aware.\n\nSecond, multiple Series can be arranged into a 2-d matrix of Series called a\nDataFrame. A 2-d data frame is a classic Excel Spreadhseet. The default row and\ncolumn header values are numbers that range from 0 to m-1, n-1, where m-1 is the number\nrows and n-1 is the number of columns. Here's the tricky bit that I found, each\nSeries (dictionary) in a data frame has to have the same key values, i.e. the same row index\nvalues. The index and column variables are not static, but can be updated programatically.\nOnce the index and column header values have been assigned (or not, i.e. using the\ndefault values), sorting or otherwise rearranging the rows and columns in a data frame\ndoes not result in changing the header values. So imagine a data frame:\n\n| 0 | A  | B  |  C |\n|---|----|----|----|\n| 0 | 5  | 6  | 7  |\n| 1 | 10 | 60 | 30 |\n| 2 | 50 | 20 | 70 |\n\nAnd you rearrange (sort) the data frame on column B values, say from largest to smallest,\nyou'd get:\n\n| 0 | A  | B  |  C |\n|---|----|----|----|\n| 1 | 10 | 60 | 30 |\n| 2 | 50 | 20 | 70 |\n| 0 | 5  | 6  | 7  |\n\nSee that those row index values (0, 1, 2) \"follow along\" with the data.\n\nTensor flow models can read pandas arrays. I haven't tried sci-kit learn models.\n\nSee: https:\/\/pythonhow.com\/accessing-dataframe-columns-rows-and-cells\/"}}