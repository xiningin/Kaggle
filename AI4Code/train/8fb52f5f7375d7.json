{"cell_type":{"f5d6729d":"code","843d1a45":"code","669b3904":"code","09199ff9":"code","55a4081c":"code","2b724e65":"code","b6fd4ff4":"code","217dfaa8":"code","3fa11ece":"code","bc551c4c":"code","c0969225":"code","6b1e67c2":"code","89b27692":"code","c8948ebe":"code","3487d845":"code","47175a19":"code","6ba50cde":"code","e4985873":"code","2e49b3dd":"code","19db2299":"code","35f51265":"code","8f095f13":"code","4e8d3a8f":"code","6eb879b6":"code","2bb41fdd":"code","4b988d09":"code","d6d227ba":"code","35dee49a":"code","6d7672cd":"code","a06e4bdb":"code","35c29fba":"code","f616024d":"code","1ea42028":"code","ef638b1e":"code","054da116":"code","6f4e93f3":"code","f8a28700":"code","0628099d":"code","6cdfccb8":"code","5025bbed":"code","295ad9c9":"code","a417ad3f":"code","efb4dd62":"code","5fbe8bec":"code","c671254c":"code","d4729e9a":"code","a612643f":"code","63d8044e":"code","e9a471ff":"code","177a0672":"code","881a4b46":"code","1c5c2d94":"code","69f03187":"code","670c551b":"code","3527e07c":"code","c11c6909":"code","f4bf2912":"code","bcbf1163":"code","b6060b25":"code","ed7d359e":"code","fd674066":"code","aaaf6796":"code","fe2d82a9":"code","e3878945":"code","fdf5228e":"code","60bb773d":"code","e171af34":"code","04140224":"code","beb07f93":"markdown","48f07296":"markdown","2b6668b2":"markdown","f13fa272":"markdown","d716d526":"markdown","341bab5e":"markdown","7e7b8ed1":"markdown","b8384427":"markdown","daeee27f":"markdown","47890ae0":"markdown","bbd1043f":"markdown","6776578f":"markdown","1676b0a3":"markdown","26e1ae2f":"markdown"},"source":{"f5d6729d":"#importing the libraries\nimport json\nimport csv","843d1a45":"#converting json to csv file\nwith open('..\/input\/loan-acceptance-dataset\/loan_data.json') as json_file:\n\tjsondata = json.load(json_file)\n\ndata_file = open('loan_data.csv', 'w', newline='')\ncsv_writer = csv.writer(data_file)\n\ncount = 0\nfor data in jsondata:\n\tif count == 0:\n\t\theader = data.keys()\n\t\tcsv_writer.writerow(header)\n\t\tcount += 1\n\tcsv_writer.writerow(data.values())\n\ndata_file.close()\n","669b3904":"#importing libraries for manipulating rows and columns\nimport numpy as np\nimport pandas as pd\npd.set_option('display.max_rows', 100)","09199ff9":"#reading csv file\ndata = pd.read_csv(\"loan_data.csv\")\ndata.head(10)","55a4081c":"data.shape","2b724e65":"# data preprocessing (no null value found)\ndata.isnull().sum()","b6fd4ff4":"data.info()","217dfaa8":"data.describe()","3fa11ece":"import seaborn as sns","bc551c4c":"# finding unique values in \"dependent\" feature \ndata['Dependents'].unique()","c0969225":"count = data['Dependents'].value_counts()\ncount","6b1e67c2":"val = data['Dependents'].value_counts(normalize=True)\nval","89b27692":"percentage = val.mul(100).round(1).astype(str) + '%'\npercentage","c8948ebe":"dq1 = pd.DataFrame({'dependents_count':count , 'per_count':val , 'percent':percentage})\ndq1\n","3487d845":"dq1.describe()","47175a19":"dq1.mean()","6ba50cde":"print('The average number of dependents per applicant is:', dq1.mean()[0])","e4985873":"data.head()","2e49b3dd":"# creating new dataframe\ndq3 = data[['Application_ID' , 'Self_Employed' , 'Application_Status']]\ndq3.head()","19db2299":"count_self_Employed = dq3['Self_Employed'].value_counts()\ncount_self_Employed","35f51265":"count_Application_Status = dq3['Application_Status'].value_counts()\ncount_Application_Status","8f095f13":"from pandas import DataFrame","4e8d3a8f":"# finding self employed people.\nSE_yes = dq3[dq3['Self_Employed'] == 'Yes']\nSE_yes.head()","6eb879b6":"SE_yes.shape","2bb41fdd":"cnt = SE_yes['Application_Status'].value_counts(normalize=True)\ncnt","4b988d09":"percentage_of_applications_approved_for_SEapplicants = cnt.mul(100).round(1).astype(str) + '%'\npercentage_of_applications_approved_for_SEapplicants","d6d227ba":"print('The percentage of applications approved for self-employed applicants is:', percentage_of_applications_approved_for_SEapplicants[0])","35dee49a":"data.head()","6d7672cd":"dq4 = data[['Application_ID' , 'Gender' ,'Married' , 'Application_Status']]\ndq4.head()","a06e4bdb":"Rejction_MM = dq4[ (dq4['Married'] == 'Yes' ) & (dq4['Gender'] == 'Male')]\nRejction_MM.head()","35c29fba":"cnt_MM_rejected = Rejction_MM['Application_Status'].value_counts(normalize=True)\ncnt_MM_rejected","f616024d":"percentage_of_applications_for_marriedMan_applicants = cnt_MM_rejected.mul(100).round(1).astype(str) + '%'\npercentage_of_applications_for_marriedMan_applicants","1ea42028":"print('The percentage of rejections for married male applicants is:', percentage_of_applications_for_marriedMan_applicants[1])","ef638b1e":"data.head()","054da116":"dq5 = data[['Application_ID' , 'Property_Area' , 'Application_Status']]\ndq5.head()","6f4e93f3":"cnt_PA_approved = dq5['Property_Area'].value_counts(normalize=True)\ncnt_PA_approved.head()","f8a28700":"cnt_PA_approved['Max'] = cnt_PA_approved[['Semiurban','Urban' , 'Rural']].idxmax(axis=0)\nprint('The property area that has the maximum approval ratio is: ', cnt_PA_approved['Max'])","0628099d":"data.head()","6cdfccb8":"dq6 = data[['Application_ID' , 'Dependents' ,'Income']]\ndq6.head()","5025bbed":"ohe_data = pd.get_dummies(dq6, columns = ['Income'])\nohe_data.head()","295ad9c9":"ohe_data.shape","a417ad3f":"val = ohe_data[['Income_high','Income_low','Income_medium']].sum(axis = 0, skipna = True)\nval","efb4dd62":"ohe_data.mean()","5fbe8bec":"print('The average dependents per income group is \\n',ohe_data.mean())","c671254c":"import matplotlib.pyplot as plt\nimport seaborn as sns","d4729e9a":"q7data = pd.read_csv('loan_data.csv')\ndata.head()","a612643f":"q7data.shape","63d8044e":"q7data.isnull().sum()","e9a471ff":"q7data.info()","177a0672":"q7data.describe(include=['O'])","881a4b46":"plt.figure(figsize=(8,5))\nsns.histplot(data['Application_Status'], kde=True)\nplt.title('Status of application being reported', fontsize=20)\nplt.show()","1c5c2d94":"print(\"Male   :\", q7data['Gender'].value_counts()[0])\nprint(\"Female :\", q7data['Gender'].value_counts()[1])\n\n# Visualization:\nplt.figure(figsize=(6,4))\nsns.countplot(q7data['Gender'])\nplt.title('Gender', fontsize=20)\nplt.show()","69f03187":"q7data.head()","670c551b":"q7data = q7data[['Self_Employed' , 'Credit_History' ,'Property_Area' , 'Income' ,'Married' ,\n                 'Dependents' , 'Education' , 'Gender' ,'Application_Status']]\nq7data.head()","3527e07c":"q7data = pd.get_dummies(q7data, drop_first=True)\nq7data.head()","c11c6909":"# Splitting Independent & Dependent Feature:\nX = q7data.iloc[:, :-1]\ny = q7data.iloc[:, -1]","f4bf2912":"X.head()","bcbf1163":"# Train Test Split:\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=48)","b6060b25":"# Importing Performance Metrics:\nfrom sklearn.metrics import mean_squared_error, r2_score","ed7d359e":"X.shape","fd674066":"# Linear Regression:\nfrom sklearn.linear_model import LinearRegression\nLinearRegression = LinearRegression()\nLinearRegression = LinearRegression.fit(X_train, y_train)\n\n# Prediction:\ny_pred = LinearRegression.predict(X_test)\n\n# Scores:\nprint(r2_score(y_test, y_pred))\nprint(mean_squared_error(y_test, y_pred))","aaaf6796":"# Ridge:\nfrom sklearn.linear_model import Ridge\nRidge = Ridge()\nRidge = Ridge.fit(X_train, y_train)\n\n# Prediction:\ny_pred = Ridge.predict(X_test)\n\n# Scores:\nprint(r2_score(y_test, y_pred))\nprint(mean_squared_error(y_test, y_pred))","fe2d82a9":"# Random Forest Regressor:\nfrom sklearn.ensemble import RandomForestRegressor\nRandomForestRegressor = RandomForestRegressor()\nRandomForestRegressor = RandomForestRegressor.fit(X_train, y_train)\n\n# Prediction:\ny_pred = RandomForestRegressor.predict(X_test)\n\n# Scores:\nprint(r2_score(y_test, y_pred))\nprint(mean_squared_error(y_test, y_pred))","e3878945":"import matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn import preprocessing\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nimport seaborn as sns\nfrom tensorflow.keras.layers import Dense, BatchNormalization, Dropout, LSTM\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras import regularizers\nfrom sklearn.metrics import precision_score, recall_score, confusion_matrix, classification_report, accuracy_score, f1_score\nfrom tensorflow.keras import callbacks\n\nnp.random.seed(0)","fdf5228e":"early_stopping = callbacks.EarlyStopping(\n    min_delta=0.001, \n    patience=20,\n    restore_best_weights=True,\n)","60bb773d":"# Initialising the NN\nmodel = Sequential()\n\n# layers\nmodel.add(Dense(units = 32, kernel_initializer = 'uniform', activation = 'relu', input_dim = 12))\nmodel.add(Dense(units = 32, kernel_initializer = 'uniform', activation = 'relu'))\nmodel.add(BatchNormalization())\nmodel.add(Dense(units = 64, kernel_initializer = 'uniform', activation = 'relu'))\nmodel.add(Dense(units = 64, kernel_initializer = 'uniform', activation = 'relu'))\nmodel.add(BatchNormalization())\nmodel.add(Dense(units = 1, kernel_initializer = 'uniform', activation = 'sigmoid'))\n\n# Compiling the ANN\nopt = Adam(learning_rate=0.00009)\nmodel.compile(optimizer = opt, loss = 'binary_crossentropy', metrics = ['accuracy'])\n\n# Train the ANN\nhistory = model.fit(X_train, y_train, batch_size = 32, epochs = 200, callbacks=[early_stopping], validation_split=0.2)","e171af34":"history_df = pd.DataFrame(history.history)\n\nplt.plot(history_df.loc[:, ['loss']], \"#BDE2E2\", label='Training loss')\nplt.plot(history_df.loc[:, ['val_loss']],\"#C2C4E2\", label='Validation loss')\nplt.title('Training and Validation loss')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend(loc=\"best\")\n\nplt.show()","04140224":"history_df = pd.DataFrame(history.history)\n\nplt.plot(history_df.loc[:, ['accuracy']], \"#BDE2E2\", label='Training accuracy')\nplt.plot(history_df.loc[:, ['val_accuracy']], \"#C2C4E2\", label='Validation accuracy')\n\nplt.title('Training and Validation accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Accuracy')\nplt.legend()\nplt.show()","beb07f93":"# ------------------------------Thanks--------------------------------","48f07296":"# 1. Percentage of total applicants for each unique value of dependents.","2b6668b2":"### Using Linear Regression","f13fa272":"# 2. The average number of dependents per applicant.","d716d526":"### Using Ridge","341bab5e":"# 4. The % of rejections for married male applicants","7e7b8ed1":"# 5. The property area which has the maximum approval ratio.","b8384427":"# 3. The % of applications approved for self-employed applicants.","daeee27f":"### Using Random Forest Regressor","47890ae0":"# The best model working here is ANN with:-\n 1. loss: 0.3257 \n 2. train accuracy: 0.8896 \n 3. validation loss: 0.5755\n 4. validation accuracy: 0.7683","bbd1043f":"# Model creation and evaluation","6776578f":"# 7. Creating a simple predictive model to assess whether a loan application will be approved or rejected and provide the accuracy score.","1676b0a3":"# 6. The average dependents per income group.","26e1ae2f":"## Using Artificial Neural Network "}}