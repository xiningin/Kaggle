{"cell_type":{"55b5c21b":"code","e57cedb7":"code","8c32d9e7":"code","1dc69bdb":"code","d79fc22f":"code","a36b4e32":"code","72bedeea":"code","32989916":"code","48dbaa6b":"code","e64ef3bf":"code","08762f85":"code","b52e9f8f":"code","657dfb08":"code","ee65ea62":"code","bfc657c5":"code","712edf46":"code","824f5d3f":"code","f9a6344e":"code","a520f653":"code","d8482850":"markdown","fd01f55c":"markdown","e9505cd8":"markdown","be902aef":"markdown","49f06045":"markdown","a0efe453":"markdown"},"source":{"55b5c21b":"pip install adjustText","e57cedb7":"#import modules\n\nfrom gensim.models import KeyedVectors\nimport gensim\nimport os\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport networkx as nx\nimport copy\nimport random\nfrom matplotlib import cm\nimport matplotlib as mpl\nimport json\n\n#data preprocessing\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import normalize, scale, MinMaxScaler\n\n\n#clustering modules\nfrom sklearn.datasets import make_blobs\nimport scipy.cluster.hierarchy as sch\nfrom sklearn.cluster import AgglomerativeClustering\nfrom sklearn.cluster import DBSCAN\n\n%matplotlib inline\n\n#Graph embeddings visualization \nfrom adjustText import adjust_text\n#https:\/\/stackoverflow.com\/questions\/19073683\/matplotlib-overlapping-annotations-text\n\n\n#utilities\nfrom IPython.core.display import display, HTML\nimport warnings\nwarnings.filterwarnings('ignore')","8c32d9e7":"#data directories\nembedding_vector_file = \"..\/input\/bibliometric-text-mining-for-building-energy\/data\/embedding_vec.emb\"\nvocabulary_file = \"..\/input\/bibliometric-text-mining-for-building-energy\/data\/vocabulary.txt\"\nbookmark_file = \"..\/input\/bibliometric-text-mining-for-building-energy\/data\/bookmark.json\"","1dc69bdb":"#keywords\n\nenergy_efficiency=[\n    \n     #design phase\n    [\"life_cycle_assessment\",\"lca\"],\n    [\"passive_design\", \"passive_strategies\",\"passive_cooling\"],\n    [\"ubem\",\"urban_building_energy_modeling\", \"urban_building_energy_models\"],\n    [\"parametric_design\"],\n    [\"hvac_optimization\",\"hvac_system_optimization\"],\n    [\"district_energy_system\"],\n#     \"thermal_comfort\",\n\n    \n    #construction phase\n    [\"measurement_and_verification\"],\n    [\"retro-commissioning\",\"ongoing_commissioning\", \"continuous_commissioning\"],\n    [\"energy_audit\"],\n\n\n    #operation phase\n    [\"model_predictive_control\"],\n    [\"demand_response\",\"demand_side_management\",\"load_management\"],\n    [\"energy_benchmarking\", \"building_energy_benchmarking\"],\n    [\"fault_detection_and_diagnosis\",\"fdd\",\"fault_detection\"],\n    [\"om\"],\n    [\"demand_controlled_ventilation\",\"dcv\",\"demand-controlled_ventilation\"],\n    [\"renewable_energy\",\"renewable_energy_sources\",\"renewable_energies\"],\n    \n    #retrofit\n    [\"retrofit_analysis\",\"retrofit\"],\n    \n]\n\nphase=[\n        \n#     #lifecycle phase\n    [\"design-stage\",\"early_design_stage\",'early_design_stages',\"preliminary_design\",\"conceptual_design\"],\n    [\"construction_stage\",\"construction_phase\"],\n    [\"building_commissioning\",\"commissioning\",\"commissioned\"],\n    [\"operation_and_maintenance\",\"building_operation\",\"operational\"],\n    [\"building_retrofit\"],\n    \n]\n\ndata_science = [\n     #Datascience_algorithm\n    #design phase\n    [\"energy_simulation\",\"building_energy_simulation\"],\n    [\"optimization\", \"optimize\", \"optimizing\"],\n    [\"multi-objective_optimization\", \"multi-objective\"],\n\n\n    #comissioinng\n    [\"data_collection\"],\n    [\"measurement\"],\n\n    #operation phase\n    [\"neural_networks\",\"deep_learning\", \"neural_networks\"],\n    [\"reinforcement_learning\", \"rl\", \"deep_reinforcement_learning\"],\n    [\"validation\", \"validate\"],\n    \n    [\"feature_extraction\", \"feature_selection\"],\n    [\"anomaly_detection\", \"outlier_detection\"],\n\n    [\"clustering\", \"clusters\"],\n    [\"dimensionality_reduction\", \"dimension_reduction\"],\n    [\"segmentation\"],\n    [\"classification\", \"classified\", \"classes\"],\n\n    [\"statistical_analysis\", \"statistical\", \"statistical_methods\"],\n    [\"regression\", \"regression_model\", \"regression_analysis\", \"regression_models\"],\n    [\"correlation\", \"correlated\"],\n\n    \n    \n    [\"data_visualization\",\"visualization\", \"visualisation\", \"dashboard\"],\n    [\"factor_analysis\",\"efa\", \"cfa\", \"confirmatory\"],\n    [\"generative_adversarial_networks\", \"generative_adversarial_network\"],\n\n]\ndata=[\n    #data\n    [\"baseline_models\"],\n    [\"ecm\",\"ecms\"],\n    [\"air_speed\",\"air_velocity\",\"airflow\",\"air_flow\"],\n    [\"wind_direction\",\"prevailing\"],\n    [\"wind_speed\",\"prevailing\"],\n    [\"indoor_air_temperature\",\"air_temperature\",\"temperature\"],\n    [\"outdoor_air_temperature\"],[\"outdoor_temperature\"],\n    [\"relative_humidity\",\"humidity\"],\n    [\"time-step\"],\n    [\"heat_balance\"],\n    [\"energy_balance\"],\n    [\"heat_transfer\"],\n    [\"carbon_dioxide\"],\n    [\"site\",\"location\"],\n    [\"weather_data\",\"weather_file\",\"weather_files\",\"weather_station\"],\n    [\"dry_bulb_temperature\",\"dry-bulb\"],\n    [\"dew_point\"],\n    [\"energy_consumption\", \"building_energy_use\", \"energy_consumption_data\"],\n    [\"schedule\",\"schedules\",\"scheduling\",\"occupancy_schedule\",\"occupancy_schedules\",\"occupancy\",\"occupancy_patterns\"],\n    [\"ahu\",\"air_handling_unit\",\"ahus\"],\n    [\"energy_price\",\"electricity_price\",\"electricity_prices\"],\n    [\"cost_savings\",\"cost_saving\"],\n    [\"building_envelope\",\"envelope\"],\n    [\"building_geometry\"],\n    [\"material_properties\",\"thermal_properties\"],\n    [\"glazing\",\"solar_heat_gain\",\"shgc\"],\n    [\"shading_devices\",\"shading\",\"blinds\"],\n    [\"building_orientation\",\"orientation\"],\n    [\"zone\",\"zones\",\"thermal_zones\"],\n    [\"surface\",\"surfaces\"],\n    [\"thermal_mass\",\"internal_mass\"],\n    [\"building_form\",\"building_shape\"],\n    [\"passive_design_strategies\", \"passive_strategies\"],\n    [\"natural_ventilation\",\"cross_ventilation\"],\n    [\"internal_heat_gains\",\"internal_gains\",\"heat_gain\"],\n    [\"lights\",\"lamps\",\"lighting\",\"artificial_lighting\"],\n    [\"equipment\",\"appliances\"],\n    [\"daylighting\",\"daylight\",\"illuminance\"],\n    [\"mass_flow_rate\"],\n    [\"inlet_temperature\"],\n    [\"outlet_temperature\"],\n    [\"cooling_load\",\"cooling_loads\",\"cooling_energy\"],\n    [\"heating_load\",\"heat_load\"],\n    [\"chilled_water\",\"chilled_water_temperature\"],\n    [\"chiller\",\"chillers\"],\n    [\"cop\",\"coefficient_of_performance\"],\n    [\"hot_water\"],\n    [\"compressor_power\"],\n    [\"condenser_fan_power\"],\n    [\"condensing_temperature\"],\n    [\"fan_power\",\"fan_power_consumption\"],[\"fan_speed\"],\n    [\"set_point\",\"set-point\",\"set_points\"],\n    [\"water_temperature\"],\n    [\"heating_load\",\"heating_energy\",\"heating_energy_consumption\",\"heating_demand\", \"heating_loads\"],\n    [\"cooling_load\",\"cooling_demand\", \"heating_loads\",\"cooling_energy\",\"cooling_energy_consumption\"],\n    [\"variable_air_volume\",\"vav\",\"variable-air-volume\"],\n    [\"constant_air_volume\", \"cav\"],\n    [\"static_pressure\"],[\"differential_pressure\"],\n    [\"thermal_comfort\"],\n    [\"damper\",\"dampers\"],\n    [\"air-to-air\"],\n    [\"air-to-water\"],\n    [\"heat_recovery\"],\n    [\"load_profile\",\"load_scheduling\"],\n    [\"time-of-use\",\"tou\"],\n    [\"household_appliances\"],\n    [\"energy_storage\"],\n    [\"smart_meters\",\"smart_metering\"],\n    [\"post-occupancy_evaluation\",\"post-occupancy\"],\n    [\"coefficient_of_variation\"],\n    [\"calibrated_model\"],\n    [\"electricity_pricing\",\"utility_bills\",\"energy_bills\"],\n    [\"cost_analysis\"],\n    [\"control_algorithms\"],\n    [\"pmv\",\"predicted_mean_vote\",\"thermal_comfort_index\"],\n    [\"ppd\",\"thermal_comfort_index\"],\n    [\"thermal_sensation\"],\n    [\"operative_temperature\"],\n    [\"mean_radiant_temperature\"],\n    [\"clothing_insulation\"],\n    [\"thermal_comfort_index\"],\n    [\"ashrae_guideline_14\"],\n    [\"calibrated_simulation\"],\n    [\"occupant_behavior\",\"occupant_behaviour\"],\n    [\"noise_level\"],\n    [\"eui\",\"energy_intensity\"],[\"historical_data\"],\n    [\"real-time\"],\n    [\"meter_readings\",\"meter_reading\",\"smart_meter_data\"],\n    [\"heating_degree_days\",\"hdd\",\"hdds\"],\n    [\"cooling_degree_days\",\"cdd\",\"cdds\"],\n    [\"performance_measurement_and_verification\",\"ipmvp\"] \n]\n","d79fc22f":"#Word2vec model\nmodel = gensim.models.KeyedVectors.load_word2vec_format(fname=embedding_vector_file, unicode_errors='strict')","a36b4e32":"#example: \nmodel.most_similar([\"regression\"], topn=5)","72bedeea":"#utility functions \ndef create_color_bar(min_v = 0, max_v = 5.0, color_map = cm.Blues, bounds = range(6)):\n    fig, ax = plt.subplots(figsize=(6, 1))\n    fig.subplots_adjust(bottom=0.5)\n\n    norm = mpl.colors.Normalize(min_v, max_v)\n    if bounds!= None:\n        cb1 = mpl.colorbar.ColorbarBase(ax, cmap=color_map,\n                                        norm=norm,\n                                        boundaries = bounds,\n                                        orientation='horizontal')\n    else:\n        cb1 = mpl.colorbar.ColorbarBase(ax, cmap=color_map,\n                                        norm=norm,\n                                        orientation='horizontal')\n        \n    cb1.set_label('relation_strength')\n    fig.show()\n    plt.show()\n    display(HTML(\"<hr>\"))","32989916":"#here we create a dictionary of pairs of relations\nrelations = {\n    \"data_science-phase\":(data_science,phase),\n    \n    \"data_science-data\":(data_science, data),\n    \n    \"energy_efficiency-data\":(energy_efficiency,data ),\n    \n    \"energy_efficiency-data_science\":(energy_efficiency, data_science),\n    \n    \"phase-energy_efficiency\":(phase, energy_efficiency),\n}","48dbaa6b":"# Usability ranked heatmap plots using N-gram method\n# this code also creates a graph network between each pair of words {Wa,Wb, \u0304S(Wa,Wb)}which\n# is then converted into a directed weighted graph (please refer to article:Section 2.5 )\n\n#1. we initiate the Network Graph\nG = nx.Graph()\ndisplay(HTML('''<h1>Usability ranked heatmap plots using N-gram method<\/h1>\n                <p> Please refer to Figures 8, 9, and 13 in the article<\/p>\n                <b> Colorbar indicating the range of relations strenght:\n                <\/b><br>0 = very week relation, 1.0 = very strong relation'''))\ncreate_color_bar()\nfor k2, rel in relations.items():\n    table ={}\n\n    for ds in rel[1]:\n        graph = [G.add_edge(ds[0], node_, weight=1.0) for node_ in ds]\n        d = model.most_similar(ds, topn=1000000)\n        this_one = {}\n\n        for j in rel[0]:\n            ef_sim = []\n            for i in d:\n                if i[0] in j:\n                    ef_sim.append(i[1])\n            this_one[j[0]] = np.max(ef_sim)\n        table[ds[0]] = this_one\n\n\n    table2={}\n    for k, v in table.items():\n        ut=[]\n        for d in rel[0]:\n            graph2 = [G.add_edge(d[0], node_2, weight=1.0) for node_2 in d]\n            \n            try:\n                if v[d[0]] > 0.05:\n                    ut.append(v[d[0]])\n                    G.add_edge(d[0], k, weight = v[d[0]])\n                else:\n                    ut.append(np.nan)\n            except Exception as e:\n                print(str(e))\n                ut.append(np.nan)\n        table2[k] = ut\n\n    table2[\"index\"]=[i[0] for i in rel[0]]\n\n    df = pd.DataFrame(table2)\n    df = df.set_index(\"index\")\n\n    df.to_csv(\"..\/input\/bibliometric-text-mining-for-building-energy\/code\/relations\/\"+k2+\".csv\")\n    viridis = cm.get_cmap('Blues', 5)\n    df_sorted = df.reindex(df.sum().sort_values(ascending=False).index, axis=1)\n    df_sorted['sum'] = df_sorted.sum(axis=1)\n    plt.figure(figsize=(float(len(rel[0])), float(len(rel[1]))))\n    df_sorted = df_sorted.sort_values(by=\"sum\", ascending=False)[df_sorted.columns[:-1]]\n    n = 2.2\n    plt.title(k2)\n    sns.heatmap(df_sorted, \n                cmap=\"Blues\", \n                vmin=0.0, \n                vmax=0.5,\n                square=True, \n                annot=False, \n                linewidths=0.1, \n                linecolor=\"#fff\",\n               cbar = False,\n               )    \n    plt.show()","e64ef3bf":"# This line shows the graph network edge weight uncomment to print\n# nx.get_edge_attributes(G, 'weight')","08762f85":"#1. preprocessing the words by extracting the embedding vector of each word for visualization\ndisplay(HTML('''<b> The following table shows each word, its correstponding 300 dimension vector, and its category<\/b>'''))\nvec = []\ndfdict = {}\nfor i in range(301):\n    if i ==0:\n        dfdict[\"word\"]=[]\n    else:\n        dfdict[i]=[]\ndfdict    \nfor i in list(G.nodes):\n    dfdict[\"word\"].append(i)\n    thisvec = list(model.get_vector(i))\n\n    for ix in range(300):\n        dfdict[ix+1].append(thisvec[ix])\n    \nembd = pd.DataFrame(dfdict).set_index(\"word\")\nembd.to_csv(\"..\/data\/embedding_matrix.tsv\", sep=\"\\t\", index = False)\n\ndef return_type(x):\n    categories = {\n        \"energy_efficiency\":energy_efficiency,\n        \"data\": data,\n        \"phase\":phase,\n        \"data_science\": data_science\n    }\n#     print(x)\n    for k , v in categories.items():\n        for i in v:\n            if x in i:\n                return k\n        \nembd = embd.reset_index()\nembd[\"category\"] = embd[\"word\"].apply(lambda x : return_type(x))\nembd = embd.set_index(\"word\")\nembd","b52e9f8f":"embd.reset_index()[[\"word\", \"category\"]].to_csv(\"..\/data\/labels.tsv\", sep=\"\\t\", index=False)","657dfb08":"#load all the realtion_dataframes\n\nfiles = os.listdir(\".\/relations\/\")\nall_dfs = {}\nfor f in files:\n    if \".csv\" in f:\n        all_dfs[f.replace(\".csv\", \"\")]=(pd.read_csv(\".\/relations\/\"+f))","ee65ea62":"display(HTML('''<b>Colorbar indicating the correlation value<\/b><br>\n                0.0 = weak correlation, 1.0 = strong correlation'''))\ncreate_color_bar(min_v = 0.0, max_v = 1.0, bounds=None)\nfigN = 1\nfor key,df in all_dfs.items():\n    display(HTML(str(figN)+\"- <b>\"+ key.split(\"-\")[1]+ \" category<\/b> HAC clustering.\"))\n    df = df.set_index(\"index\")\n    wordsHere = list(df.columns)\n    words_vectors = [model.get_vector(i) for i in wordsHere]\n    words_vec_df = pd.DataFrame({\"X\":words_vectors, \"y\":wordsHere})\n    \n    X = [list(x)[:] for x in words_vec_df['X']]\n    \n    labels_2 = list(words_vec_df['y'])#[w if w in scope else \"\" for w in dataset['word'].tolist()[:]]\n\n    fig = plt.figure(figsize=(len(X)\/5.0,1 ))\n    ax = fig.add_subplot(1, 1, 1)\n    dendogram = sch.dendrogram(sch.linkage(X[:], method = \"ward\"),\n                               color_threshold=10.,\n                               labels=labels_2,#dataset['word'].tolist()[:],\n                               orientation='top',\n                               ax=ax,\n                              leaf_rotation=90)\n    ax.tick_params(axis='x', which='major', labelsize=10)\n    ax.tick_params(axis='y', which='major', labelsize=8)\n    df = df.drop_duplicates()\n    dd = df[dendogram[\"ivl\"]]\n    plt.savefig(\".\/plots\/HAC\/\"+key+\"_clusterd.svg\")\n\n    \n    corr = dd.corr()\n    mask = np.triu(np.ones_like(corr, dtype=bool))\n    plt.figure(figsize=(len(X)\/3.0,len(X)\/3.5), dpi=300)\n    plt.title(key.split(\"-\")[1]+\" < -- >\"+key.split(\"-\")[1])\n\n    sns.heatmap(corr , \n                cmap=\"Blues\", \n                vmin=0.0, \n                vmax=1.0,\n               cbar=False,\n                square=True,\n#                 mask = mask,\n                linewidth=0.5,\n               )\n    dd = dd[dendogram[\"ivl\"]]\n    dd.to_csv(\"..\/data\/clustered_keywords_order\/\"+key+\".csv\")\n    plt.savefig(\".\/plots\/Correlation_matrix\/\"+key+\".svg\")\n    plt.show()\n    figN += 1\n    ","bfc657c5":"display(HTML('''<b>Colorbar indicating the cross realtion values between each two categories<\/b><br>\n                <p>These values are extracted from the cosine similarity metric <\/p>\n                0.0 = weak correlation, 0.5 = strong correlation'''))\n\nall_orders={}\ncreate_color_bar(min_v = 0.0, max_v = 0.5, bounds=list(np.array(range(6))\/10.))\nfigN = 1\nfor key, dd in all_dfs.items():\n    dd2 = pd.read_csv(\"..\/data\/clustered_keywords_order\/\"+key+\".csv\").set_index(\"index\")\n    all_orders[key.split(\"-\")[1]] = list(dd2.columns)\n\ncmap_ = cm.get_cmap(\"Blues\", 5)\nfor key, dd in all_dfs.items():\n    display(HTML(str(figN) + \"- \"+ key.replace(\"-\", \"< -- >\")))\n    dd2 = pd.read_csv(\"..\/data\/clustered_keywords_order\/\"+key+\".csv\").set_index(\"index\")\n    dd2 = dd2.reindex(all_orders[key.split(\"-\")[0]])\n    plt.figure(figsize=(len(dd2.columns)\/3.0,len(dd2.index)\/3.0), dpi=300)\n    plt.title(key.replace(\"-\", \"< -- >\"))\n    sns.heatmap(dd2,\n                cmap=\"Blues\",\n                square=True,\n                vmin=0.0,\n                vmax=0.5,\n                linewidth=0.5,\n               cbar= False\n               )\n    plt.savefig(\".\/plots\/Cross_realtion_matrix\/\"+key+\"_cross_rel.svg\")\n    plt.show()\n    figN +=1\n","712edf46":"with open(\"..\/data\/bookmark.json\", 'r') as bm:\n    bookmark = json.loads(bm.read())\n    \nword_pos = pd.DataFrame(bookmark[0]['projections'])\nword_pos[\"word\"] = embd.reset_index()[\"word\"]\nword_pos = word_pos.set_index(\"word\")\n\nembd_with_word_pos = pd.concat([embd, word_pos], axis=1)\nxy = embd_with_word_pos[[\"umap-0\",\"umap-1\", \"category\"]].rename({\"umap-0\":\"x\", \"umap-1\":\"y\"}, axis=1)#.plot(kind=\"scatter\")\nxy[\"color\"] = xy[\"category\"].apply(lambda x : float(list(xy[\"category\"].value_counts().index).index(x))+1.0)\n\npallete = {1: \"#F15A22\", 2:\"#6DC8BF\", 3:\"#B72467\", 4:\"#CBDB2A\"}\nxy[\"color_p\"] = xy[\"color\"].apply(lambda x : pallete[int(x)])\n# xy","824f5d3f":"node_degrees = nx.degree(G)\nnx.set_node_attributes(G, \"degree\", node_degrees)\n\n\ngraph_colors = xy[[\"color_p\"]].to_dict()[\"color_p\"]\nxy[\"pos\"] = xy.apply(lambda x : (x[\"x\"], x[\"y\"]), axis =1)\ngraph_pos = xy[\"pos\"].to_dict()\n","f9a6344e":"main_words = []\nfor k , v in G.degree():\n    if k in [i[0] for i in phase+data+data_science+energy_efficiency]:\n        main_words.append(k)\n    else:\n        main_words.append(\"\")","a520f653":"plt.figure(figsize=(20, 15), dpi=300)\nnx.draw_networkx_nodes(G, pos = graph_pos, \n        node_color = [v for k, v in graph_colors.items()],\n        node_size=[v*1.3 for k , v in dict(degree).items()],\n       width=0.0, \n       alpha = 0.6)\ntexts = []\nfor indx, i in enumerate(main_words[:]):\n    if i != \"\":\n        texts.append(plt.text(xy.reset_index().loc[indx][\"x\"], xy.reset_index().loc[indx][\"y\"], i))\nadjust_text(texts, only_move={'texts':'x'}, arrowprops=dict(arrowstyle=\"-\", color='k', lw=0.7))\nplt.savefig(\".\/plots\/graph_embeddings_projection.svg\")\n# nx.draw_networkx_labels(G, pos=graph_pos, labels=main_words)\nplt.plot()","d8482850":"## 2.1 pre-processing words' vectors","fd01f55c":"## 2.3. Cross realtion between different categories","e9505cd8":"# 3. Word embeddings 2d projection visualization (Figure 7)","be902aef":"# 2. *H*ierarchical *A*gglomerative *C*lustering (HAC) relation extraction","49f06045":"# Code example from the github repository","a0efe453":"## 2.2 Heirarchical Clustereing (HAC) and Correlation Matrices"}}