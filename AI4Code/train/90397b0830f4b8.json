{"cell_type":{"273507d6":"code","a69b6491":"code","52b81efb":"code","fbfbe8dd":"code","bb755532":"code","a4921308":"code","7683930d":"code","1bc5c59a":"code","683cf794":"code","e5bfd36b":"code","38bbd429":"code","91c4075c":"code","874ad7af":"code","e7e2f38e":"code","316835db":"code","e539c785":"code","e2b0394f":"code","c0c3c714":"code","f5eea9b1":"code","b20b8a94":"code","0f720013":"code","fe586660":"code","267e141f":"code","62f243c8":"code","e4190c9c":"code","3e2042c4":"code","1d486cf6":"code","f1aceea4":"code","7c27dce0":"code","1d3755f2":"code","7256611b":"code","b68457e4":"code","4053c7c3":"code","991c5d72":"code","0263e55a":"code","f26fade2":"code","48ad9c7d":"code","c2baa478":"code","bb6ad16d":"code","ca91b5a9":"code","a2c3264e":"code","19d4d0e2":"code","cc4d783a":"code","94ba28a5":"code","0a02721e":"code","b56f47c7":"code","bbc94f6e":"code","d055d110":"code","c082ab18":"markdown","0c65da73":"markdown","728b9ab7":"markdown","2aefec27":"markdown","b4152a99":"markdown","8bd2d872":"markdown","e6ae9baf":"markdown","7794a922":"markdown","27960440":"markdown","33a07e8d":"markdown","49a71e6c":"markdown","38d3053c":"markdown","cb04bf7e":"markdown","8eb34c4b":"markdown","fb99ce35":"markdown","1e8516df":"markdown","78ac8aa6":"markdown","21d3bfc6":"markdown","eed94adb":"markdown","89edc016":"markdown","22902a4f":"markdown","27539440":"markdown","30450f9d":"markdown","326fb950":"markdown","0fc6df28":"markdown","c95b4c34":"markdown","023731a1":"markdown","c568b358":"markdown","2b5d42e7":"markdown","7ef585e0":"markdown","5c908db4":"markdown","c4a73b1c":"markdown","7ece17c7":"markdown","db8662d0":"markdown","ddf9e37d":"markdown","8ef74f84":"markdown","c87cc80b":"markdown","e23c8384":"markdown","f6ebf416":"markdown","f2752914":"markdown","29638d28":"markdown","fed4ecda":"markdown","c7b34a63":"markdown","1e7d6cfe":"markdown","acf1fd22":"markdown","78d06191":"markdown","7a4b59ab":"markdown","89720ba6":"markdown","b3d70f61":"markdown"},"source":{"273507d6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\n\n#data processing\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a69b6491":"battle = pd.read_csv('\/kaggle\/input\/database-of-battles\/battles.csv')\ndisplay(battle.tail())\nprint(battle.columns)","52b81efb":"terrain = pd.read_csv('\/kaggle\/input\/database-of-battles\/terrain.csv')\ndisplay(terrain.tail())\nprint(terrain.columns)","fbfbe8dd":"weather = pd.read_csv('\/kaggle\/input\/database-of-battles\/weather.csv')\ndisplay(weather.tail())\nprint(weather.columns)","bb755532":"#The revised dataset that contains all information needed\n\ndf = pd.merge(battle, terrain , on=\"isqno\")\ndf = pd.merge(df, weather, on = \"isqno\")\ndf.set_index('isqno', inplace = True)\ndf = df[['surpa', 'post1', 'post2', 'wx1', 'wx2', 'wx3', 'wx4', 'wx5', 'terra1', 'terra2', 'terra3', 'aeroa' , 'wina']]\n\ndisplay(df.tail())","a4921308":"# Based on what I searched for, Nan datas in 'wina' are supposed to be -1.(attacker loss)\ndf['wina'] = df['wina'].fillna(-1)\ndisplay(df)","7683930d":"import missingno as msno\n#checking if there's any empty values on the chart.\n\n\n#checking if there's any empty values on the chart.\nsurprise = df[['surpa', 'wina']]\n\nmsno.matrix(surprise)\nplt.show()\n\nprint(surprise.isnull().sum())","1bc5c59a":"import missingno as msno\n#checking if there's any empty values on the chart.\n\n\n#checking if there's any empty values on the chart.\nterrain = df[['terra1', 'terra2', 'terra3', 'wina']]\n\nmsno.matrix(terrain)\nplt.show()\n\nprint(terrain.isnull().sum()) ","683cf794":"import missingno as msno\n#checking if there's any empty values on the chart.\n\n\n#checking if there's any empty values on the chart.\nweather = df[['wx1', 'wx2', 'wx3', 'wx4', 'wx5','wina']]\n\nmsno.matrix(weather)\nplt.show()\n\nprint(weather.isnull().sum())","e5bfd36b":"import missingno as msno\n#checking if there's any empty values on the chart.\nfortification = df[['post1', 'post2' ,'wina']]\nmsno.matrix(fortification)\nplt.show()\n\nprint(fortification.isnull().sum())","38bbd429":"aerial = df[['aeroa', 'wina']]\nmsno.matrix(aerial)\nplt.show()\nprint(aerial.isnull().sum())","91c4075c":"plt.figure(figsize = (12, 12))\nsns.set_style('whitegrid')\nsns.countplot(x='wina',hue='surpa',data= surprise ,palette='RdBu_r')","874ad7af":"plt.figure(figsize = (12, 12))\nsns.set_style('whitegrid')\nsns.countplot(x = 'wina', hue='terra1',data= terrain ,palette='RdBu_r')","e7e2f38e":"plt.figure(figsize = (12, 12))\nsns.set_style('whitegrid')\nsns.countplot(x = 'wina', hue='terra2',data= terrain ,palette='RdBu_r')","316835db":"plt.figure(figsize = (12, 12))\nsns.set_style('whitegrid')\nsns.countplot(x = 'wina', hue='terra3',data= terrain ,palette='RdBu_r')","e539c785":" for j in range(1, 6):\n        \n    plt.figure(figsize = (12, 12))\n    sns.set_style('whitegrid')\n    sns.countplot(x='wina', hue='wx{}'.format(j),data= weather ,palette='RdBu_r')\n","e2b0394f":"plt.figure(figsize = (12, 12))\nsns.set_style('whitegrid')\nsns.countplot(x='wina', hue='post1',data= fortification ,palette='RdBu_r')","c0c3c714":"plt.figure(figsize = (12, 12))\nsns.set_style('whitegrid')\nsns.countplot(x='wina', hue='post2',data= fortification ,palette='RdBu_r')","f5eea9b1":"plt.figure(figsize = (12, 12))\nsns.set_style('whitegrid')\nsns.countplot(x='wina',hue='aeroa',data= aerial ,palette='RdBu_r')","b20b8a94":"df_combined = df[['surpa', 'post1', 'wx1', 'wx2', 'wx3', 'wx4', 'wx5', 'terra1', 'terra2', 'aeroa', 'wina']]\n\ndisplay(df_combined)\n\nmsno.matrix(df_combined)\nplt.show()\nprint(df_combined.isnull().sum())","0f720013":"df_combined.columns\n\ndef asdf(*args):\n    bomb = []\n    for a in df_combined.columns:\n        if a != 'wx2':\n            bomb.append(a)\n        \n    return bomb\n\ncolumn_list = asdf(df_combined.columns)\nprint(column_list)","fe586660":"df_combined = df_combined[column_list].dropna()\ndisplay(df_combined) #926 datas left\nprint(df_combined.isnull().sum())","267e141f":"df_mask= df_combined['wina'] != 0\ndf_combined = df_combined[df_mask]\ndf_combined['wina']","62f243c8":"def check_post1():\n    global df_combined\n    \n    df_combined['post1'] = df_combined['post1'].map(lambda ca: ca[0])\n    #dummy encoding\n    post1_dummies = pd.get_dummies(df_combined['post1'], prefix='post1')\n    df_combined = pd.concat([df_combined, post1_dummies], axis=1)\n    df_combined.drop('post1', inplace=True, axis=1)\n    return df_combined","e4190c9c":"df_combined = check_post1()\ndisplay(df_combined)\n\nprint(df_combined['post1_D'].sum())\nprint(df_combined['post1_F'].sum())\nprint(df_combined['post1_H'].sum())\nprint(df_combined['post1_P'].sum())\nprint(df_combined['post1_W'].sum())","3e2042c4":"def check_wx1():\n    global df_combined\n    df_combined['wx1'] = df_combined['wx1'].map(lambda s: 1 if s == 'W' else 0)\n    return df_combined","1d486cf6":"df_combined = check_wx1()\ndisplay(df_combined)\nprint(df_combined['wx1'].sum())","f1aceea4":"def check_wx3():\n    global df_combined\n    \n    df_combined['wx3'] = df_combined['wx3'].map(lambda ca: ca[0])\n    #dummy encoding\n    wx3_dummies = pd.get_dummies(df_combined['wx3'], prefix='wx3')\n    df_combined = pd.concat([df_combined, wx3_dummies], axis=1)\n    df_combined.drop('wx3', inplace=True, axis=1)\n    return df_combined","7c27dce0":"df_combined = check_wx3()\ndisplay(df_combined)\nprint(df_combined['wx3_C'].sum())\nprint(df_combined['wx3_H'].sum())\nprint(df_combined['wx3_T'].sum())","1d3755f2":"def check_wx4():\n    global df_combined\n    \n    df_combined['wx4'] = df_combined['wx4'].map(lambda ca: ca[0])\n    #dummy encoding\n    wx4_dummies = pd.get_dummies(df_combined['wx4'], prefix='wx4')\n    df_combined = pd.concat([df_combined, wx4_dummies], axis=1)\n    df_combined.drop('wx4', inplace=True, axis=1)\n    return df_combined","7256611b":"df_combined = check_wx4()\ndisplay(df_combined)\nprint(df_combined['wx4_S'].sum())\nprint(df_combined['wx4_$'].sum())\nprint(df_combined['wx4_W'].sum())\nprint(df_combined['wx4_F'].sum())","b68457e4":"def check_wx5():\n    global df_combined\n    \n    df_combined['wx5'] = df_combined['wx5'].map(lambda ca: ca[0])\n    #dummy encoding\n    wx5_dummies = pd.get_dummies(df_combined['wx5'], prefix='wx5')\n    df_combined = pd.concat([df_combined, wx5_dummies], axis=1)\n    df_combined.drop('wx5', inplace=True, axis=1)\n    return df_combined","4053c7c3":"df_combined = check_wx5()\ndisplay(df_combined)\nprint(df_combined['wx5_E'].sum())\nprint(df_combined['wx5_D'].sum())\nprint(df_combined['wx5_T'].sum())","991c5d72":"#creating function for creating categories based on the cabin of passengers\ndef check_terra1():\n    global df_combined\n    df_combined['terra1'] = df_combined['terra1'].map(lambda ca: ca[0])\n    #dummy encoding\n    terra1_dummies = pd.get_dummies(df_combined['terra1'], prefix='terra1')\n    df_combined = pd.concat([df_combined, terra1_dummies], axis=1)\n    df_combined.drop('terra1', inplace=True, axis=1)\n    return df_combined","0263e55a":"df_combined = check_terra1()\ndisplay(df_combined)\nprint(df_combined['terra1_R'].sum())\nprint(df_combined['terra1_G'].sum())\nprint(df_combined['terra1_F'].sum())","f26fade2":"#creating function for creating categories based on the cabin of passengers\ndef check_terra2():\n    global df_combined\n\n\n    df_combined['terra2'] = df_combined['terra2'].map(lambda ca: ca[0])\n    #dummy encoding\n    terra2_dummies = pd.get_dummies(df_combined['terra2'], prefix='terra2')\n    df_combined = pd.concat([df_combined, terra2_dummies], axis=1)\n    df_combined.drop('terra2', inplace=True, axis=1)\n    return df_combined","48ad9c7d":"df_combined = check_terra2()\ndisplay(df_combined)\nprint(df_combined['terra2_B'].sum())\nprint(df_combined['terra2_M'].sum())\nprint(df_combined['terra2_D'].sum())\nprint(df_combined['terra2_W'].sum())","c2baa478":"df_combined['wina'] = df_combined['wina'].apply(lambda x: x+1 if x == -1 else x)\ndf_combined = df_combined.astype('int')\ndf_combined['wina'].unique()\n# 0: attacker loss,  1: attacker win ","bb6ad16d":"from sklearn.model_selection import train_test_split\n\nTrain, Test = train_test_split(df_combined, test_size=0.2, random_state=123)","ca91b5a9":"!pip install pycaret\nfrom pycaret.classification import *","a2c3264e":"clf = setup(data = Train, target = 'wina')\n# 'wina' is the target","19d4d0e2":"best_3 = compare_models(sort = 'AUC', n_select = 3)","cc4d783a":"blended = blend_models(estimator_list = best_3, fold = 5, method = 'soft')","94ba28a5":"pred_holdout = predict_model(blended)","0a02721e":"final_model = finalize_model(blended)","b56f47c7":"Predictions = predict_model(final_model, data = Test)\nPredictions","bbc94f6e":"Result = Predictions[['wina', 'Label']]\nResult = Result.astype('int')\nResult","d055d110":"model_score = sum(Result['wina'] == Result['Label'])\/len(Result)\nmodel_score","c082ab18":"The reason the amount of the datas increased is that each war consists of a few battles, and each battle has its own condition.\nBut it seems that the datas sharing same isqno have the same 'wina' value, so we don't need to set up the function to fix it.\n\n* Different condtions but same result! Need to think about it one day","0c65da73":"### Terrain reference\n\nterra 1:\n    \n    0 - None\n\n    R - Rolling\n    \n    G - Rugged\n    \n    F - Flat\n    \nterra 2:\n    \n    0 - None\n    \n    B - Bare\n    \n    M - Mixed\n    \n    D - Desert\n    \n    W - Heavily Wooded\n    \nterra 3 :\n    \n    0 - None\n    \n    M - Marsh or Swamp\n    \n    U - Urban\n    \n    D - Dunes","728b9ab7":"## History of Battle\nThis dataset is a cleaned-up and modernized version of \"CAA Database of Battles, Version 1990\", shortnamed \"CDB90\". It contains information on over 600 battles that were fought between 1600 AD and 1973 AD. Descriptive data include battle name, date, and location; the strengths and losses on each side; identification of the victor; temporal duration of the battle; and selected environmental and tactical environment descriptors (such as type of fortifications, type of tactical scheme, weather conditions, width of front, etc.).\n\n\n## Content\nThe data contained therein is split across several files. The most important of these is battles.csv, which is lists and gives information about the battles themselves. Files marked enum describe the keys used by specific fields. Other files provide additional context.\n\n## Inspiration\n-How often were battles fought in various weather conditions?\n\n-How often did an attacker or defender achieve the element of surprise?\n\n-Did it have a significant effect on the outcome?\n\n-Did prepared fortifications have a significant effect on outcomes?\n","2aefec27":"## 6. Creating categories based on terrain1\n\n* R-Rolling\n* G-Rugged\n* F-Flat","b4152a99":"As mentioned above, the first phase will be just using 4 features.\n\n-weather\n\n-terrain\n\n-the element of surprise\n\n-fortification\n\n\n\nAny other background knowledge will be used later on.\nBefore that, let us first overview the dataset.","8bd2d872":"### Formation of Defense","e6ae9baf":"### Weather","7794a922":"### Weather","27960440":"### Terrain","33a07e8d":"# Author's Comment\nThe Comments below is wrtten by the kaggle user, who uploaded this dataset.\nFirst thing I want to tell you is that the purpose of this notebook is to predict one's victory based on the conditions written on the datasets. And it'll be achieved by a classfication, and trendy XGboost model to get it better.\n\nThe second thing is that, I repeat these on my notebook just to let you know that I just followed the guidlines referred by the user.\nIf I continue to revise my model and work on it, it'd be much better to predict the victory of the battle.\n\n\n","49a71e6c":"### Element of Surprise reference\n\n-3 ~ -1 : surprise achieved by defender(-3: most, -2: substantial , -1: minor)\n    \n0 : Neither Side surprised\n    \n1 ~ 3 : surprise achieved by attacker(3: most, 2: substantial , 1: minor)","38d3053c":"## Prediction","cb04bf7e":"### Weather Reference\n\nwx1:\n    \n    D - Dry\n    W - Wet\n    \nwx2:\n    \n    H - Heavy Precipitatiion\n    S - Sunny (no precipitation)\n    L - Light Precipitation\n    O - Overcast (no precipitation)\n    \nwx3:\n    \n    H - Hot\n    C - Cold\n    T - Temparate\n    \nwx4:\n\n    S - Summer\n    $ - Spring\n    W - Winter\n    F - Fall\n    \nwx5 : \n    \n    E - Tropical (i.e., \"Equatorial\")\n    D - Desert\n    T - Temperate","8eb34c4b":"## Retraining on the dataset","fb99ce35":"There are only 4 features that we're interested in, so we are gonna merge these tables and have only the features left.\n\n-weather\n-terrain\n-fortification\n-element of surprise achieved or not","1e8516df":"### Aerial Superiority","78ac8aa6":"### Element of Surprise","21d3bfc6":"# Exploring Dataset","eed94adb":"### Formation of Defense","89edc016":"## Missing Data\n","22902a4f":"df_combined = check_FD()\ndisplay(df_combined)\nprint(df_combined['post1'].sum())","27539440":"## 2. Creating categories based on wx1\n\n * 'D':Dry \u2192 0\n * W':Wet \u2192 1","30450f9d":"## 1. Creating categories based on Defense Formation\n\n * DL - D - Delaying action adopted\n * WD - W - Withdrwal\n * FD - F - Fortified defense\n * HD - H - Hasty Defense\n * PD - P - Prepared Defense","326fb950":"### Wina Reference\n\n    * -1 : attacker loss\n    * 0 : draw\n    * 1 : attaccker win","0fc6df28":"### Aerial Superiority","c95b4c34":"## 5. Creating categories based on wx5\n\nEvery value is turned into a column including only 0 or 1 values.\n\n* E : Tropical (i.e., \"Equatorial\")\n* D : Desert\n* T : Temperate","023731a1":"## 8. Creating categories based on aeiral superiority","c568b358":"## 4. Creating categories based on wx4\n\nEvery value is turned into a column including only 0 or 1 values.\n\n* S : Summer\n* $ : Summer\n* W : Winter\n* F : Fall","2b5d42e7":"## Data Overview","7ef585e0":"## Model Ensemble","5c908db4":"## Tables","c4a73b1c":"## 7. Creating categories based on terrain2\n\n* B - Bare\n* M - Mixed\n* D - Desert\n* W - Heavily wooded","7ece17c7":"# Summary","db8662d0":"## 3. Creating categories based on wx3\n\nEvery value is turned into a column including only 0 or 1 values.\n\n* C : Cold\n* H : Hot\n* T : Temparate","ddf9e37d":"### Element of Surprise achieved or not","8ef74f84":"# Data Overview","c87cc80b":"# Importing Libraries","e23c8384":"## Model training and comparison","f6ebf416":"# **Building and Training the Models**","f2752914":"Though the model score was not high, I guess it attributes to the changing conditions of war, such as invention of aerial vehicle. Also the categorial differentiation with such climate, territorial conditions might not reflect the conditions perfectly. So my conclusion is that the dataset has some fundemental issues to deal with, and cannot be treated thoroughly with conventional machine learning.","29638d28":"Now we'll check missing data and se the tables in the form easy to analyse.","fed4ecda":"def check_FD():\n    global df_combined\n    df_combined['post1'] = df_combined['post1'].map(lambda s: 1 if s == 'FD' else 0)\n    return df_combined","c7b34a63":"# Features\n\nBefore we get to the project, I'll make a referrence of the features to make it easier to understand the table.\n\n-aeroa: air superitority\n\n-cea: how much the actor favors attack or defense\n\n-codead: total strength\n\n-crit: ???\n\n-post: how much defense prepared\n\n-postype: posture taken\n\n-pri: the form of tactics\n\n-wina: 0-draw\/1-attacker win\/ -1 - attacker loss\n\n-reso: result of the battle\n\n-surpa: how much surprise achieved by attacker\/defender\n\nfront_width: the features in it are unknown\n\n\n### Terrain\n-terra1 : None\/Rugged\/Rollig\/Flat\n\n-terra2 : Bare\/Desert\/Heavily Wooded\/Mixed\n\n-terra3 : None\/ Marsh or Swamp\/ Urban \/Dunes\n\n### Weather\n\n\n-wx1: Dry\/wet\n\n-wx2: Heavy Precipitatiion\/Sunny\/Light Precipitation\/Overcast\n\n-wx3: hot\/cold\/temperate\n\n-wx4: Spring\/Summer\/Fall\/Winter\n\n-wx5: Tropical\/Desert\/Temperate\n\n","1e7d6cfe":" Coz of asymmetry problem of the dataset, drop all wina values with 0.(draw)\nOur goal is to predict which side would win(attacker or defender), so dropping 'draw' values wouldn't be a problem.\n","acf1fd22":"## Prediction on Test set\n","78d06191":"Based on my assesment of the datasets, I'll make the following changes to the tables.\n\n    * If there are too many missing values for imputation, it will be excluded.(terra3, post2)\n    \n    \n    * We'll set the train and test datasets together, using Kfold.\n     \n    * We'll drop the columns with na values except for 'terra1':0, because we cannot manipulate the historical facts. \n    We fill in 'wx2' missing values with the most frequent values coz there's too much missing values there.\n    ","7a4b59ab":"## PyCaret installation**","89720ba6":"### Terrain","b3d70f61":"* None, coz the values are already converted into integer"}}