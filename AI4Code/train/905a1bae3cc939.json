{"cell_type":{"5ba9021d":"code","2d574b10":"code","0e9f8697":"code","e6839fde":"code","90442027":"code","7fd77c24":"code","c6a52407":"code","a9234cae":"code","d3b29cda":"code","2f388951":"code","57060ae7":"code","076ca9d2":"code","47e69798":"code","ad928001":"code","41303fc8":"code","718a3c56":"code","58a2508e":"code","a1f0c38f":"code","27cead57":"code","6baf47d9":"code","88d31b12":"code","15c3acdd":"code","8fd0b56a":"code","c13875e4":"code","9129c8ac":"code","892cd309":"code","385ce811":"code","4dd97b8c":"code","8bdb3cec":"code","e3f8396e":"code","03df1b62":"code","b44942d3":"code","2fc1e533":"code","75f7041b":"code","2a68db82":"code","2bda6a29":"code","b7bc41c8":"code","39777a03":"markdown","b3c86aa1":"markdown","1711fc4d":"markdown","ee37624f":"markdown","f1f6f56f":"markdown"},"source":{"5ba9021d":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport seaborn as sns","2d574b10":"!pip install iterative-stratification","0e9f8697":"from iterstrat.ml_stratifiers import MultilabelStratifiedKFold","e6839fde":"!pip install torch==1.6.0+cu101 torchvision==0.7.0+cu101 -f https:\/\/download.pytorch.org\/whl\/torch_stable.html","90442027":"# !pip install fastai==2\n\n!pip install -Uqq fastbook\nimport fastbook\nfastbook.setup_book()\n\n","7fd77c24":"import torch\ntorch.cuda.is_available()    # Just realized cuda is unavailable. What a waste of GPU.","c6a52407":"import fastai\nfastai.__version__","a9234cae":"# !pip install fastcore==1.0.0","d3b29cda":"from torchvision.models import densenet121\nimport os\nimport random\n\n\nfrom fastbook import *\nimport fastai\nfrom fastai.vision.widgets import *\nfrom sklearn.metrics import roc_auc_score","2f388951":"def seed_everything(seed):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True","57060ae7":"DATA_PATH = Path(\"..\/input\/plant-pathology-2020-fgvc7\")\nIMG_PATH = DATA_PATH\/\"images\"\nSEED = 42\nLABEL_COLS = [\"healthy\", \"multiple_diseases\", \"rust\", \"scab\"]\n\nIMG_SIZE = 512\nBATCH_SIZE = 16\nN_FOLDS = 5\n\nARCH = densenet121     # A smaller model than Resnet with good performance\n\nseed_everything(SEED)","076ca9d2":"train_df = pd.read_csv(DATA_PATH\/\"train.csv\")\ntest_df = pd.read_csv(DATA_PATH\/\"test.csv\")","47e69798":"train_df.shape, test_df.shape","ad928001":"train_df.head()","41303fc8":"train_df.info()       # No missing values","718a3c56":"train_df.iloc[:,1:].sum().plot.bar()","58a2508e":"train_df[['healthy', 'multiple_diseases', 'rust', 'scab']].sum(axis=1).unique()","a1f0c38f":"train_df[\"fold\"] = -1\n\nstrat_kfold = MultilabelStratifiedKFold(n_splits = N_FOLDS, random_state = SEED, shuffle = True)\nfor i, (_,test_index) in enumerate(strat_kfold.split(train_df[\"image_id\"].values, train_df.iloc[:, 1:].values)):\n    train_df.iloc[test_index, -1] = i\n    \ntrain_df[\"fold\"] = train_df[\"fold\"].astype('int')","27cead57":"train_df","6baf47d9":"fig, axes = plt.subplots(nrows=1, ncols = 5, constrained_layout = True, figsize=(15,3), sharey=True)\nfor ax, fold in zip(axes, range(5)):\n    train_df[train_df[\"fold\"] == fold].iloc[:,1:-1].sum().plot.bar(ax = ax)\n    ax.set_title(f'Fold {fold} label dist')","88d31b12":"# Next steps create DataBlocks, Oversampling, create learners, write metrics, training","15c3acdd":"train_df['label'] = train_df[LABEL_COLS].idxmax(axis = 1)\ntrain_df.head()","8fd0b56a":"train_df['label'].value_counts()","c13875e4":"# This function upsample the 'multiple_diseases' label\n\ndef upsample(fold):\n    train_df_no_val = train_df[train_df['fold'] != fold]     # This is the training data\n    train_df_just_val = train_df[train_df['fold'] == fold]   # This is the validation data. This method will prevent overfitting\n    \n    train_df_bal = pd.concat(\n                    [train_df_no_val[train_df_no_val['label'] != 'multiple_diseases'], train_df_just_val] + \n                    [train_df_no_val[train_df_no_val['label'] == 'multiple_diseases']] * 3).sample(frac = 1.0, random_state = SEED).reset_index(drop = True)\n        \n    return train_df_bal\n\nupsample(fold = 0)['label'].value_counts()","9129c8ac":"# This function returns a dataloader object\n\ndef get_data(fold):\n    data = upsample(fold = fold)\n    \n    datablock = DataBlock(\n                blocks = (ImageBlock, CategoryBlock(vocab = LABEL_COLS)),\n                getters = [\n                    ColReader('image_id', pref = IMG_PATH, suff = '.jpg'),\n                    ColReader('label')\n                ],\n                splitter = IndexSplitter(data.loc[data['fold'] == fold].index),\n                item_tfms = Resize(IMG_SIZE),\n                batch_tfms = aug_transforms(size = IMG_SIZE, max_rotate = 30., min_scale = 0.75, flip_vert = True, do_flip = True))\n    \n    return datablock.dataloaders(source = data, bs = BATCH_SIZE)\n    ","892cd309":"dls = get_data(fold = 0)","385ce811":"dls.show_batch()","4dd97b8c":"def comp_metrics(preds, targs, labels = range(len(LABEL_COLS))):\n    # Average of individual disease auc roc\n    targs = np.eye(4)[targs]     \n    return np.mean([roc_auc_score(targs[:,i], preds[:,i]) for i in labels])\n\ndef healthy_roc_auc(*args):\n    return comp_metrics(*args, labels = [0])\n\ndef multiple_diseases_roc_auc(*args):\n    return comp_metrics(*args, labels = [1])\n\ndef rust_roc_auc(*args):\n    return comp_metrics(*args, labels = [2])\n\n\ndef scab_roc_auc(*args):\n    return comp_metrics(*args, labels = [3])","8bdb3cec":"def get_learner(fold_num, lr = 1e-3):\n    opt_func = partial(Adam, lr = lr, wd = 0.01, eps = 1e-8)  # Optimizer... Not sure what is partial\n    \n    data = get_data(fold_num)\n    \n    learn = cnn_learner(\n            data, ARCH, opt_func = opt_func,\n            loss_func = LabelSmoothingCrossEntropy(),   # Helps the model to train around mislabeled data,better performance, robustness\n            metrics = [\n                AccumMetric(healthy_roc_auc, flatten = False),\n                AccumMetric(multiple_diseases_roc_auc, flatten = False),\n                AccumMetric(rust_roc_auc, flatten = False),\n                AccumMetric(scab_roc_auc, flatten = False),\n                AccumMetric(comp_metrics, flatten = False)\n            ]).to_fp16()                                  # Lower fixed precision, low memory, good performance\n    \n    return learn","e3f8396e":"get_learner(fold_num=0).lr_find()","03df1b62":"def print_metrics(val_preds, val_labels):\n    print(\"Comp Metric: \", comp_metrics(val_preds, val_labels))\n    print(\"Healthy Metric: \", healthy_roc_auc(val_preds, val_labels))\n    print(\"Multi diseases: \", multiple_diseases_roc_auc(val_preds, val_labels))\n    print(\"Rust Metric: \", rust_roc_auc(val_preds, val_labels))\n    print(\"Scab Metric: \", scab_roc_auc(val_preds, val_labels))","b44942d3":"all_val_preds = []\nall_val_labels = []\nall_test_preds = []\n\nfor i in range(N_FOLDS):\n    print(\"Fold {} RESULT\".format(i))\n    \n    learn = get_learner(i)\n    learn.fit_one_cycle(4)\n    learn.unfreeze()\n    learn.fit_one_cycle(6, slice(1e-5, 1e-4))\n    learn.recorder.plot_loss()\n    \n    learn.save(f\"model_fold_{i}\")\n    val_preds, val_labels = learn.get_preds()\n    print_metrics(val_preds, val_labels)\n    all_val_preds.append(val_preds)\n    all_val_labels.append(val_labels)\n    \n    test_dl = dls.test_dl(test_df)\n    test_preds, _ = learn.get_preds(dl=test_dl)\n    all_test_preds.append(test_preds)\n    \nplt.show()","2fc1e533":"print_metrics(np.concatenate(all_val_preds), np.concatenate(all_val_labels))","75f7041b":"# Identify images with top losses\n\ninterp = ClassificationInterpretation.from_learner(learn)","2a68db82":"interp.plot_confusion_matrix(normalize=True, figsize=(6, 6))","2bda6a29":"interp.plot_confusion_matrix(figsize=(6, 6))","b7bc41c8":"interp.plot_top_losses(9, figsize=(15, 10))","39777a03":"This is a multiclass classification and not a multi-label classification","b3c86aa1":"### Reading the csv file","1711fc4d":"We will oversample the multiple_diseases label by a factor of 3.","ee37624f":"### Create Folds","f1f6f56f":"### Model Training"}}