{"cell_type":{"af59f106":"code","028259d3":"code","83b526c6":"code","7270fd2c":"code","82b15c11":"code","6c18021d":"code","822a54ad":"code","b645fdc8":"code","94fc5deb":"code","a3b8bb63":"code","14301cdd":"code","c6a01a9b":"code","4754676c":"code","ec1e9b38":"code","d5cc321f":"code","7ff5a3e4":"markdown","d3b7a31d":"markdown","0bb0509e":"markdown","f1024974":"markdown","bd18bdfc":"markdown"},"source":{"af59f106":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","028259d3":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import display\npd.options.display.max_columns = None\npd.options.display.max_rows = None\nimport seaborn as sns","83b526c6":"df = pd.read_csv(\"\/kaggle\/input\/hourly-weather-surface-brazil-southeast-region\/sudeste.csv\")","7270fd2c":"df[\"mdct\"] = pd.to_datetime(df[\"mdct\"])","82b15c11":"df_1 = df[(df['wsid']==384) & (df['mdct'] > '2015-01-01 00:00:00')]","6c18021d":"df_1 = df_1.set_index(\"mdct\")","822a54ad":"import locale\nimport matplotlib as mpl\nfrom matplotlib import docstring\nimport numpy as np\nimport random\nfrom matplotlib.projections.polar import PolarAxes\nfrom numpy.lib.twodim_base import histogram2d\nimport matplotlib.pyplot as plt\n\nZBASE = -1000  # The starting zorder for all drawing, negative to have the grid on\nVAR_DEFAULT = \"speed\"\nDIR_DEFAULT = \"direction\"\nFIGSIZE_DEFAULT = (8, 8)\nDPI_DEFAULT = 80\nCALM_CIRCLE_COLOR = \"red\"\nCALM_CIRCLE_ALPHA = 0.4\n\n\nclass WindAxesFactory(object):\n    \"\"\"\n    Factory class to create WindroseAxes or WindAxes\n    \"\"\"\n\n    @staticmethod\n    def create(typ, ax=None, *args, **kwargs):\n        \"\"\"\n        Create\n        Mandatory:\n        Parameters\n        ----------\n        typ : string, 'windroseaxes' or 'windaxes'\n            Type of axes to create\n                * windroseaxes : a WindroseAxes axe\n                * windaxe : a WindAxes axe\n        ax : matplotlib.Axes, optional\n            A matplotlib axe\n        \"\"\"\n        typ = typ.lower()\n        d = {\"windroseaxes\": WindroseAxes, \"windaxes\": WindAxes}\n        if typ in d.keys():\n            cls = d[typ]\n            if isinstance(ax, cls):\n                return ax\n            else:\n                ax = cls.from_ax(ax, *args, **kwargs)\n                return ax\n        else:\n            raise NotImplementedError(\"typ=%r but it might be in %s\" % (typ, d.keys()))\n\n\nclass WindroseAxes(PolarAxes):\n    \"\"\"\n    Create a windrose axes\n    \"\"\"\n\n    name = \"windrose\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        See Axes base class for args and kwargs documentation\n        \"\"\"\n\n        # Uncomment to have the possibility to change the resolution directly\n        # when the instance is created\n        # self.RESOLUTION = kwargs.pop('resolution', 100)\n        self.rmax = kwargs.pop(\"rmax\", None)\n        PolarAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(\"equal\", adjustable=\"box\", anchor=\"C\")\n        self.radii_angle = 67.5\n        self.cla()\n\n    @staticmethod\n    def from_ax(ax=None, fig=None, rmax=None, *args, **kwargs):\n        \"\"\"\n        Return a WindroseAxes object for the figure `fig`.\n        \"\"\"\n        if ax is None:\n            if fig is None:\n                fig = plt.figure(\n                    figsize=FIGSIZE_DEFAULT,\n                    dpi=DPI_DEFAULT,\n                    facecolor=\"w\",\n                    edgecolor=\"w\",\n                )\n            rect = [0.1, 0.1, 0.8, 0.8]\n            ax = WindroseAxes(fig, rect, facecolor=\"w\", rmax=rmax, *args, **kwargs)\n            fig.add_axes(ax)\n            return ax\n        else:\n            return ax\n\n    def cla(self):\n        \"\"\"\n        Clear the current axes\n        \"\"\"\n        PolarAxes.cla(self)\n\n        self.theta_angles = np.arange(0, 360, 45)\n        self.theta_labels = [\"E\", \"N-E\", \"N\", \"N-W\", \"W\", \"S-W\", \"S\", \"S-E\"]\n        self.set_thetagrids(angles=self.theta_angles, labels=self.theta_labels)\n\n        self._info = {\"dir\": list(), \"bins\": list(), \"table\": list()}\n\n        self.patches_list = list()\n\n        self.calm_count = None\n\n    def _colors(self, cmap, n):\n        \"\"\"\n        Returns a list of n colors based on the colormap cmap\n        \"\"\"\n        return [cmap(i) for i in np.linspace(0.0, 1.0, n)]\n\n    def set_radii_angle(self, **kwargs):\n        \"\"\"\n        Set the radii labels angle\n        \"\"\"\n\n        kwargs.pop(\"labels\", None)\n        angle = kwargs.pop(\"angle\", None)\n        if angle is None:\n            angle = self.radii_angle\n        self.radii_angle = angle\n        N = 5\n        rmax = self.get_rmax()\n        radii = np.linspace(0, rmax, N + 1)\n        if rmax % N == 0:\n            fmt = \"%d\"\n        else:\n            fmt = \"%.1f\"\n        radii_labels = [fmt % r for r in radii]\n        # radii_labels[0] = \"\"  # Removing label 0\n        self.set_rgrids(\n            radii=radii[1:], labels=radii_labels[1:], angle=self.radii_angle, **kwargs\n        )\n\n    def _update(self):\n        if not self.rmax:\n            self.rmax = np.max(np.sum(self._info[\"table\"], axis=0))\n        calm_count = self.calm_count or 0\n        self.set_rmax(rmax=self.rmax + calm_count)\n        self.set_radii_angle(angle=self.radii_angle)\n\n    def legend(self, loc=\"lower left\", decimal_places=1, **kwargs):\n        \"\"\"\n        Sets the legend location and her properties.\n        Parameters\n        ----------\n        loc : int, string or pair of floats, default: 'lower left'\n            see :obj:`matplotlib.pyplot.legend`.\n        decimal_places : int, default 1\n            The decimal places of the formated legend\n        Other Parameters\n        ----------------\n        isaxes : boolean, default True\n            whether this is an axes legend\n        prop : FontProperties(size='smaller')\n            the font property\n        borderpad : float\n            the fractional whitespace inside the legend border\n        shadow : boolean\n            if True, draw a shadow behind legend\n        labelspacing : float, 0.005\n            the vertical space between the legend entries\n        handlelenght : float, 0.05\n            the length of the legend lines\n        handletextsep : float, 0.02\n            the space between the legend line and legend text\n        borderaxespad : float, 0.02\n            the border between the axes and legend edge\n        kwarg\n            Every other kwarg argument supported by\n            :obj:`matplotlib.pyplot.legend`\n        \"\"\"\n\n        def get_handles():\n            handles = list()\n            for p in self.patches_list:\n                if isinstance(p, mpl.patches.Polygon) or isinstance(\n                    p, mpl.patches.Rectangle\n                ):\n                    color = p.get_facecolor()\n                elif isinstance(p, mpl.lines.Line2D):\n                    color = p.get_color()\n                else:\n                    raise AttributeError(\"Can't handle patches\")\n                handles.append(\n                    mpl.patches.Rectangle(\n                        (0, 0), 0.2, 0.2, facecolor=color, edgecolor=\"black\"\n                    )\n                )\n            return handles\n\n        def get_labels(decimal_places=1):\n            _decimal_places = str(decimal_places)\n\n            fmt = \"[%.\" + _decimal_places + \"f \" + \": %0.\" + _decimal_places + \"f\"\n\n            labels = np.copy(self._info[\"bins\"])\n            if locale.getlocale()[0] in [\"fr_FR\"]:\n                fmt += \"[\"\n            else:\n                fmt += \")\"\n\n            labels = [fmt % (labels[i], labels[i + 1]) for i in range(len(labels) - 1)]\n            return labels\n\n        kwargs.pop(\"labels\", None)\n        kwargs.pop(\"handles\", None)\n\n        # decimal_places = kwargs.pop('decimal_places', 1)\n\n        handles = get_handles()\n        labels = get_labels(decimal_places)\n        self.legend_ = mpl.legend.Legend(self, handles, labels, loc, **kwargs)\n        return self.legend_\n\n    def set_legend(self, **pyplot_arguments):\n        if \"borderaxespad\" not in pyplot_arguments:\n            pyplot_arguments[\"borderaxespad\"] = -0.10\n        legend = self.legend(**pyplot_arguments)\n        plt.setp(legend.get_texts(), fontsize=8)\n        return legend\n\n    def _init_plot(self, direction, var, **kwargs):\n        \"\"\"\n        Internal method used by all plotting commands\n        Parameters\n        ----------\n        direction : 1D array,\n            directions the wind blows from, North centred\n        var : 1D array,\n            values of the variable to compute. Typically the wind speeds\n        Other Parameters\n        ----------------\n        normed : boolean, default False\n        blowto : boolean, default False\n        colors : str or list of str, default None\n            The colors of the plot.\n        cmap : color map, default `jet`\n            A :obj:`matplotlib.cm` colormap for the plot.\n            Warning! It overrides `colors`.\n        weibull_factors :\n        mean_values :\n        frequency :\n        kwarg\n            Any argument accepted by :obj:`matplotlib.pyplot.plot`.\n        \"\"\"\n\n        # if weibull factors are entered overwrite direction and var\n        if \"weibull_factors\" in kwargs or \"mean_values\" in kwargs:\n            if \"weibull_factors\" in kwargs and \"mean_values\" in kwargs:\n                raise TypeError(\"cannot specify both weibull_factors and mean_values\")\n            statistic_type = \"unset\"\n            if \"weibull_factors\" in kwargs:\n                statistic_type = \"weibull\"\n                val = kwargs.pop(\"weibull_factors\")\n            elif \"mean_values\" in kwargs:\n                statistic_type = \"mean\"\n                val = kwargs.pop(\"mean_values\")\n            if val:\n                if \"frequency\" not in kwargs:\n                    raise TypeError(\n                        \"specify 'frequency' argument for statistical input\"\n                    )\n                windFrequencies = kwargs.pop(\"frequency\")\n                if len(windFrequencies) != len(direction) or len(direction) != len(var):\n                    if len(windFrequencies) != len(direction):\n                        raise TypeError(\"len(frequency) != len(direction)\")\n                    elif len(direction) != len(var):\n                        raise TypeError(\"len(frequency) != len(direction)\")\n                windSpeeds = []\n                windDirections = []\n                for dbin in range(len(direction)):\n                    for _ in range(int(windFrequencies[dbin] * 10000)):\n                        if statistic_type == \"weibull\":\n                            windSpeeds.append(\n                                random.weibullvariate(var[dbin][0], var[dbin][1])\n                            )\n                        elif statistic_type == \"mean\":\n                            windSpeeds.append(\n                                random.weibullvariate(var[dbin] * 2 \/ np.sqrt(np.pi), 2)\n                            )\n                        windDirections.append(direction[dbin])\n                var, direction = windSpeeds, windDirections\n\n        # self.cla()\n        kwargs.pop(\"zorder\", None)\n\n        # Init of the bins array if not set\n        bins = kwargs.pop(\"bins\", None)\n        if bins is None:\n            bins = np.linspace(np.min(var), np.max(var), 6)\n        if isinstance(bins, int):\n            bins = np.linspace(np.min(var), np.max(var), bins)\n        bins = np.asarray(bins)\n        nbins = len(bins)\n\n        # Number of sectors\n        nsector = kwargs.pop(\"nsector\", None)\n        if nsector is None:\n            nsector = 16\n\n        # Sets the colors table based on the colormap or the \"colors\" argument\n        colors = kwargs.pop(\"colors\", None)\n        cmap = kwargs.pop(\"cmap\", None)\n        if colors is not None:\n            if isinstance(colors, str):\n                colors = [colors] * nbins\n            if isinstance(colors, (tuple, list)):\n                if len(colors) != nbins:\n                    raise ValueError(\"colors and bins must have same length\")\n        else:\n            if cmap is None:\n                cmap = mpl.cm.jet\n            colors = self._colors(cmap, nbins)\n\n        # Building the angles list\n        angles = np.arange(0, -2 * np.pi, -2 * np.pi \/ nsector) + np.pi \/ 2\n\n        normed = kwargs.pop(\"normed\", False)\n        blowto = kwargs.pop(\"blowto\", False)\n\n        # Calm condition\n        calm_limit = kwargs.pop(\"calm_limit\", None)\n        if calm_limit is not None:\n            mask = var > calm_limit\n            self.calm_count = len(var) - np.count_nonzero(mask)\n            if normed:\n                self.calm_count = self.calm_count * 100 \/ len(var)\n            var = var[mask]\n            direction = direction[mask]\n\n        # Set the global information dictionnary\n        self._info[\"dir\"], self._info[\"bins\"], self._info[\"table\"] = histogram(\n            direction, var, bins, nsector, normed, blowto\n        )\n\n        return bins, nbins, nsector, colors, angles, kwargs\n\n    def _calm_circle(self):\n        \"\"\"\n        Draw the calm centered circle\n        and return the initial offset for plots methods\n        \"\"\"\n        if self.calm_count and self.calm_count > 0:\n            circle = mpl.patches.Circle(\n                (0., 0.),\n                self.calm_count,\n                transform=self.transData._b,\n                color=CALM_CIRCLE_COLOR,\n                alpha=CALM_CIRCLE_ALPHA,\n            )\n            self.add_artist(circle)\n        return self.calm_count or 0\n\n    def contour(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in linear mode. For each var bins, a line will be\n        draw on the axes, a segment between each sector (center to center).\n        Each line can be formated (color, width, ...) like with standard plot\n        pylab command.\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds.\n        Other Parameters\n        ----------------\n        sector : integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6,\n            then bins=linspace(min(var), max(var), 6)\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n        others kwargs\n            Any supported argument of :obj:`matplotlib.pyplot.plot`\n        \"\"\"\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n\n        # closing lines\n        angles = np.hstack((angles, angles[-1] - 2 * np.pi \/ nsector))\n        vals = np.hstack(\n            (\n                self._info[\"table\"],\n                np.reshape(\n                    self._info[\"table\"][:, 0], (self._info[\"table\"].shape[0], 1)\n                ),\n            )\n        )\n\n        offset = self._calm_circle()\n        for i in range(nbins):\n            val = vals[i, :] + offset\n            offset += vals[i, :]\n            zorder = ZBASE + nbins - i\n            patch = self.plot(angles, val, color=colors[i], zorder=zorder, **kwargs)\n            self.patches_list.extend(patch)\n        self._update()\n\n    def contourf(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in filled mode. For each var bins, a line will be\n        draw on the axes, a segment between each sector (center to center).\n        Each line can be formated (color, width, ...) like with standard plot\n        pylab command.\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds\n        Other Parameters\n        ----------------\n        nsector: integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6,\n            then bins=linspace(min(`var`), max(`var`), 6)\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n        others kwargs\n            Any supported argument of :obj:`matplotlib.pyplot.plot`\n        \"\"\"\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(\"facecolor\", None)\n        kwargs.pop(\"edgecolor\", None)\n\n        # closing lines\n        angles = np.hstack((angles, angles[-1] - 2 * np.pi \/ nsector))\n        vals = np.hstack(\n            (\n                self._info[\"table\"],\n                np.reshape(\n                    self._info[\"table\"][:, 0], (self._info[\"table\"].shape[0], 1)\n                ),\n            )\n        )\n        offset = self._calm_circle()\n        for i in range(nbins):\n            val = vals[i, :] + offset\n            offset += vals[i, :]\n            zorder = ZBASE + nbins - i\n            patch = self.fill(np.append(angles, 0), np.append(val, 0),\n                              facecolor=colors[i], edgecolor=colors[i],\n                              zorder=zorder, **kwargs)\n            self.patches_list.extend(patch)\n        self._update()\n\n    def bar(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in bar mode. For each var bins and for each sector,\n        a colored bar will be draw on the axes.\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds.\n        Other Parameters\n        ----------------\n        nsector : integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6\n            between min(`var`) and max(`var`).\n        blowto : bool, optional.\n            if True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted\n            in different colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional.\n            if cmap == None and colors == None, a default Colormap is used.\n        edgecolor : string, optional\n            The string color each edge box will be plotted.\n            Default : no edgecolor\n        opening : float, optional\n            between 0.0 and 1.0, to control the space between each sector (1.0\n            for no space)\n        \"\"\"\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(\"facecolor\", None)\n        edgecolor = kwargs.pop(\"edgecolor\", None)\n        if edgecolor is not None:\n            if not isinstance(edgecolor, str):\n                raise ValueError(\"edgecolor must be a string color\")\n        opening = kwargs.pop(\"opening\", None)\n        if opening is None:\n            opening = 0.8\n        dtheta = 2 * np.pi \/ nsector\n        opening = dtheta * opening\n\n        offs = self._calm_circle()\n\n        for j in range(nsector):\n            offset = offs\n            for i in range(nbins):\n                if i > 0:\n                    offset += self._info[\"table\"][i - 1, j]\n                val = self._info[\"table\"][i, j]\n                zorder = ZBASE + nbins - i\n                patch = mpl.patches.Rectangle(\n                    (angles[j] - opening \/ 2, offset),\n                    opening,\n                    val,\n                    facecolor=colors[i],\n                    edgecolor=edgecolor,\n                    zorder=zorder,\n                    **kwargs\n                )\n                self.add_patch(patch)\n                if j == 0:\n                    self.patches_list.append(patch)\n        self._update()\n\n    def box(self, direction, var, **kwargs):\n        \"\"\"\n        Plot a windrose in proportional box mode. For each var bins and for\n        each sector, a colored box will be draw on the axes.\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds\n        Other Parameters\n        ----------------\n        nsector: integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360\/16=22.5\u00b0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6\n            between min(`var`) and max(`var`).\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color ('k' or 'black'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n        edgecolor : string, optional\n            The string color each edge bar will be plotted.  Default : no\n            edgecolor\n        \"\"\"\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(\"facecolor\", None)\n        edgecolor = kwargs.pop(\"edgecolor\", None)\n        if edgecolor is not None:\n            if not isinstance(edgecolor, str):\n                raise ValueError(\"edgecolor must be a string color\")\n        opening = np.linspace(0.0, np.pi \/ 16, nbins)\n\n        offs = self._calm_circle()\n\n        for j in range(nsector):\n            offset = offs\n            for i in range(nbins):\n                if i > 0:\n                    offset += self._info[\"table\"][i - 1, j]\n                val = self._info[\"table\"][i, j]\n                zorder = ZBASE + nbins - i\n                patch = mpl.patches.Rectangle(\n                    (angles[j] - opening[i] \/ 2, offset),\n                    opening[i],\n                    val,\n                    facecolor=colors[i],\n                    edgecolor=edgecolor,\n                    zorder=zorder,\n                    **kwargs\n                )\n                self.add_patch(patch)\n                if j == 0:\n                    self.patches_list.append(patch)\n        self._update()\n\n\nclass WindAxes(mpl.axes.Subplot):\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        See Axes base class for args and kwargs documentation\n        \"\"\"\n        super(WindAxes, self).__init__(*args, **kwargs)\n\n    @staticmethod\n    def from_ax(ax=None, fig=None, *args, **kwargs):\n        if ax is None:\n            if fig is None:\n                fig = plt.figure(figsize=FIGSIZE_DEFAULT, dpi=DPI_DEFAULT)\n            ax = WindAxes(fig, 1, 1, 1, *args, **kwargs)\n            fig.add_axes(ax)\n            return ax\n        else:\n            return ax\n\n    def pdf(\n        self,\n        var,\n        bins=None,\n        Nx=100,\n        bar_color=\"b\",\n        plot_color=\"g\",\n        Nbins=10,\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        Draw probability density function and return Weibull distribution\n        parameters\n        \"\"\"\n        import scipy.stats\n\n        if bins is None:\n            bins = np.linspace(0, np.max(var), Nbins)\n        hist, bins = np.histogram(var, bins=bins, normed=True)\n        width = 0.7 * (bins[1] - bins[0])\n        center = (bins[:-1] + bins[1:]) \/ 2\n        self.bar(center, hist, align=\"center\", width=width, color=bar_color)\n        params = scipy.stats.exponweib.fit(var, floc=0, f0=1)\n        x = np.linspace(0, bins[-1], Nx)\n        self.plot(x, scipy.stats.exponweib.pdf(x, *params), color=plot_color)\n        return (self, params)\n\n\ndef histogram(direction, var, bins, nsector, normed=False, blowto=False):\n    \"\"\"\n    Returns an array where, for each sector of wind\n    (centred on the north), we have the number of time the wind comes with a\n    particular var (speed, polluant concentration, ...).\n    Parameters\n    ----------\n    direction : 1D array\n        directions the wind blows from, North centred\n    var : 1D array\n        values of the variable to compute. Typically the wind speeds\n    bins : list\n        list of var category against we're going to compute the table\n    nsector : integer\n        number of sectors\n    Other Parameters\n    ----------------\n    normed : boolean, default False\n        The resulting table is normed in percent or not.\n    blowto : boolean, default False\n        Normaly a windrose is computed with directions as wind blows from. If\n        true, the table will be reversed (usefull for pollutantrose)\n    \"\"\"\n\n    if len(var) != len(direction):\n        raise ValueError(\"var and direction must have same length\")\n\n    angle = 360. \/ nsector\n\n    dir_bins = np.arange(-angle \/ 2, 360. + angle, angle, dtype=np.float)\n    dir_edges = dir_bins.tolist()\n    dir_edges.pop(-1)\n    dir_edges[0] = dir_edges.pop(-1)\n    dir_bins[0] = 0.\n\n    var_bins = bins.tolist()\n    var_bins.append(np.inf)\n\n    if blowto:\n        direction = direction + 180.\n        direction[direction >= 360.] = direction[direction >= 360.] - 360\n\n    table = histogram2d(x=var, y=direction, bins=[var_bins, dir_bins], normed=False)[0]\n    # add the last value to the first to have the table of North winds\n    table[:, 0] = table[:, 0] + table[:, -1]\n    # and remove the last col\n    table = table[:, :-1]\n    if normed:\n        table = table * 100 \/ table.sum()\n\n    return dir_edges, var_bins, table\n\n\n@docstring.copy(WindroseAxes.contour)\ndef wrcontour(direction, var, ax=None, rmax=None, **kwargs):\n    \"\"\"\n    Draw contour probability density function and return Weibull\n    distribution parameters.\n    \"\"\"\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.contour(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.contourf)\ndef wrcontourf(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.contourf(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.box)\ndef wrbox(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.box(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.bar)\ndef wrbar(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.bar(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindAxes.pdf)\ndef wrpdf(\n    var,\n    bins=None,\n    Nx=100,\n    bar_color=\"b\",\n    plot_color=\"g\",\n    Nbins=10,\n    ax=None,\n    rmax=None,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Draw probability density function and return Weitbull distribution\n    parameters\n    \"\"\"\n    ax = WindAxes.from_ax(ax)\n    ax, params = ax.pdf(var, bins, Nx, bar_color, plot_color, Nbins, *args, **kwargs)\n    return (ax, params)\n\n\ndef wrscatter(direction, var, ax=None, rmax=None, *args, **kwargs):\n    \"\"\"\n    Draw scatter plot\n    \"\"\"\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    direction = -np.array(direction) + np.radians(90)\n    ax.scatter(direction, var, *args, **kwargs)\n    return ax\n\n\n# def clean(direction, var):\n#     '''\n#     Remove masked values in the two arrays, where if a direction data is masked,\n#     the var data will also be removed in the cleaning process (and vice-versa)\n#     '''\n#     dirmask = direction.mask==False\n#     varmask = direction.mask==False\n#     mask = dirmask*varmask\n#     return direction[mask], var[mask]\n\n\ndef clean_df(df, var=VAR_DEFAULT, direction=DIR_DEFAULT):\n    \"\"\"\n    Remove nan and var=0 values in the DataFrame\n    if a var (wind speed) is nan or equal to 0, this row is\n    removed from DataFrame\n    if a direction is nan, this row is also removed from DataFrame\n    \"\"\"\n    return df[df[var].notnull() & df[var] != 0 & df[direction].notnull()]\n\n\ndef clean(direction, var, index=False):\n    \"\"\"\n    Remove nan and var=0 values in the two arrays\n    if a var (wind speed) is nan or equal to 0, this data is\n    removed from var array but also from dir array\n    if a direction is nan, data is also removed from both array\n    \"\"\"\n    dirmask = np.isfinite(direction)\n    varmask = var != 0 & np.isfinite(var)\n    mask = dirmask * varmask\n    if index is None:\n        index = np.arange(mask.sum())\n        return direction[mask], var[mask], index\n    elif not index:\n        return direction[mask], var[mask]\n    else:\n        index = index[mask]\n        return direction[mask], var[mask], index\n\n\nD_KIND_PLOT = {\n    \"contour\": wrcontour,\n    \"contourf\": wrcontourf,\n    \"box\": wrbox,\n    \"bar\": wrbar,\n    \"pdf\": wrpdf,\n    \"scatter\": wrscatter,\n}\n\n\ndef plot_windrose(\n    direction_or_df,\n    var=None,\n    kind=\"contour\",\n    var_name=VAR_DEFAULT,\n    direction_name=DIR_DEFAULT,\n    by=None,\n    rmax=None,\n    **kwargs\n):\n    if var is None:\n        # Assuming direction_or_df is a DataFrame\n        df = direction_or_df\n        var = df[var_name].values\n        direction = df[direction_name].values\n    else:\n        direction = direction_or_df\n    return plot_windrose_np(direction, var, kind=kind, by=by, rmax=rmax, **kwargs)\n\n\ndef plot_windrose_df(\n    df,\n    kind=\"contour\",\n    var_name=VAR_DEFAULT,\n    direction_name=DIR_DEFAULT,\n    by=None,\n    rmax=None,\n    **kwargs\n):\n    var = df[var_name].values\n    direction = df[direction_name].values\n    return plot_windrose_np(direction, var, by=by, rmax=rmax, **kwargs)\n\n\ndef plot_windrose_np(\n    direction, var, kind=\"contour\", clean_flag=True, by=None, rmax=None, **kwargs\n):\n    if kind in D_KIND_PLOT.keys():\n        f_plot = D_KIND_PLOT[kind]\n    else:\n        raise Exception(\"kind=%r but it must be in %r\" % (kind, D_KIND_PLOT.keys()))\n    # if f_clean is not None:\n    #     df = f_clean(df)\n    # var = df[var_name].values\n    # direction = df[direction_name].values\n    if clean_flag:\n        var, direction = clean(var, direction)\n    if by is None:\n        ax = f_plot(direction=direction, var=var, rmax=rmax, **kwargs)\n        if kind not in [\"pdf\"]:\n            ax.set_legend()\n        return ax\n    else:\n        raise NotImplementedError(\n            \"'by' keyword not supported for now \"\n            \"https:\/\/github.com\/scls19fr\/windrose\/issues\/10\"\n        )","b645fdc8":"df_1[['wdsp']].isnull().sum()","94fc5deb":"# zoom in \n\ndf_1[['wdsp']][0:100].plot(figsize = (40,10))","a3b8bb63":"df_1['wdsp'] = df_1['wdsp'].interpolate('linear',  limit_direction='both')\n\n# zoom in again\n\ndf_1[['wdsp']][0:100].plot(figsize = (40,10))","14301cdd":"ws = df_1[\"wdsp\"]\nwd = df_1[\"wdct\"]","c6a01a9b":"df_1.head()","4754676c":"ax = WindroseAxes.from_ax()\nax.bar(wd, ws, normed=True, opening=0.8, edgecolor='white')\nax.set_legend()","ec1e9b38":"ax = WindroseAxes.from_ax()\nax.box(wd, ws)\nax.set_legend()","d5cc321f":"\nwrscatter(wd, ws)\n","7ff5a3e4":"# Windroses \n\n* credit to https:\/\/github.com\/python-windrose ","d3b7a31d":"### Set index to the date","0bb0509e":"### Windrose plot","f1024974":"#### Interpolation of missing values","bd18bdfc":"### Select only one station to reduce data size for analysis"}}