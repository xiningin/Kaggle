{"cell_type":{"95dbbdea":"code","329d11b6":"code","13b5455b":"code","b6009f98":"code","826d5742":"code","4beada14":"code","821559ab":"code","e462d965":"code","581cb581":"code","3c753b2d":"code","88647b7b":"code","93ba1bb3":"code","c274de07":"code","fb7a31e5":"code","4e3221cc":"markdown","3a032fdd":"markdown","8b149c18":"markdown","513cd6f7":"markdown","437da434":"markdown"},"source":{"95dbbdea":"import sys\nIN_COLAB = 'google.colab' in sys.modules\n!nvidia-smi -L","329d11b6":"# colab\uc5d0\uc11c \uad6c\ub3d9\ud558\ub294 \uacbd\uc6b0 \uc11c\ubc84\uc758 \uad6c\uae00 \ub4dc\ub77c\uc774\ube0c \ud30c\uc77c\uc744 \ub2e4\uc6b4\ubc1b\ub294\ub2e4.\n\nimport os\n#input.zip : https:\/\/drive.google.com\/open?id=1Cb9kjJ40Sc7hs3TtDREGjdytH7479PKu\n#model.h5 : https:\/\/drive.google.com\/open?id=1CnF0Ailc2s8ob0JieXrhTK4u1YEr_HaD\n#model_predict_missing_mask.h5 : https:\/\/drive.google.com\/open?id=1Sr6D8utBeOEnQ3BUGEdCCwPkYiPfY_uM\n#fold_train.zip : https:\/\/drive.google.com\/open?id=1UqJaSbwpHhTcbM-zdSLljWMMlNnNZG_X\n\ndef download_file_gd(file_id, fpathname, unzip=False):\n    from google_drive_downloader import GoogleDriveDownloader as gdd\n    if os.path.exists(fpathname) == False:\n        gdd.download_file_from_google_drive(file_id=file_id, dest_path=fpathname, unzip=unzip, showsize=False)\n    else:\n        print(fpathname, \": already downloaded\")\n\nfiles = {\n    \"1Cb9kjJ40Sc7hs3TtDREGjdytH7479PKu\" : \".\/input\/severstal-steel-defect-detection\/input.zip\", \n    \"1CnF0Ailc2s8ob0JieXrhTK4u1YEr_HaD\" : \".\/model.h5\", \n    \"1Sr6D8utBeOEnQ3BUGEdCCwPkYiPfY_uM\" : \".\/input\/severstal-steel-defect-detection-data-files\/model_predict_missing_mask.h5\", \n    \"1UqJaSbwpHhTcbM-zdSLljWMMlNnNZG_X\" : \".\/input\/severstal-steel-defect-detection-data-files\/fold_train.zip\",\n\n}\n\nif IN_COLAB:\n    for f in files:\n        print(f, files[f])\n        download_file_gd(file_id=f, fpathname=files[f], unzip=(files[f].find(\".zip\") >= 0))\n        \n    # unzip train\/test zip file\n    import zipfile\n    zipfile.ZipFile(\".\/input\/severstal-steel-defect-detection\/train_images.zip\").extractall(\".\/input\/severstal-steel-defect-detection\/train_images\")\n    zipfile.ZipFile(\".\/input\/severstal-steel-defect-detection\/test_images.zip\").extractall(\".\/input\/severstal-steel-defect-detection\/test_images\")        \n\n","13b5455b":"import os\nimport json\nimport gc\n\nimport cv2\nimport keras\nfrom keras import backend as K\nfrom keras import layers\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.models import Model, load_model, Sequential\nfrom keras.layers import Input\nfrom keras.layers.convolutional import Conv2D, Conv2DTranspose\nfrom keras.layers.pooling import MaxPooling2D\nfrom keras.layers.merge import concatenate\nfrom keras.optimizers import Adam, Nadam\nfrom keras.callbacks import Callback, ModelCheckpoint\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\nfrom sklearn.model_selection import train_test_split","b6009f98":"from pathlib import Path\nimport shutil\n\nINPUT_PATH = \".\/input\"\nif IN_COLAB == False:\n    INPUT_PATH = \"..\/input\"\n\nDF_TRAIN_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/train.csv\")\nDF_TEST_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/sample_submission.csv\")\n\nTRAIN_IMAGE_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/train_images\")\nTEST_IMAGE_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/test_images\")\nDATA_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection-data-files\")\n\nGENERATE_WEIGHTS = True\n\nEPOCHS = 30\n\nUSE_CALLBACK = True\n\nCHANNELS = 3\n\nK_FOLDS = 4\n\nASSIGNED_FOLD_JOBS = [x for x in range(K_FOLDS)]\n    \nif IN_COLAB == False:    \n    data_dir_path = \"..\/input\/severstal-steel-defect-detection-data-files\"\n    if os.path.exists(data_dir_path):\n        for fname in os.listdir(data_dir_path):\n            filepath = os.path.join(data_dir_path, fname)\n            print(filepath)\n            if os.path.isfile(filepath):\n                if GENERATE_WEIGHTS == True:\n                    if fname.find(\"h5\") > 0:\n                        continue\n                destfilepath = os.path.join(\".\/\", fname)\n                print(\"copy file \", filepath, \" to \", destfilepath)\n                shutil.copy(filepath, destfilepath)\n                \n","826d5742":"train_df = pd.read_csv(DF_TRAIN_PATH)\n'''\nimage \ud30c\uc77c\uba85\uacfc ClassId\uac00 _\ub85c \uc5f0\uacb0\ub418\uc5b4 \uc788\uc5b4\uc11c \ubd84\ub9ac\ud574\uc11c \ubcc4\ub3c4 column\uc73c\ub85c \ub9cc\ub4e0\ub2e4.\n'''\ntrain_df['ImageId'] = train_df['ImageId_ClassId'].apply(lambda x: x.split('_')[0])\ntrain_df['ClassId'] = train_df['ImageId_ClassId'].apply(lambda x: x.split('_')[1])\ntrain_df['hasMask'] = ~ train_df['EncodedPixels'].isna()\ntrain_df['isNan'] = train_df['EncodedPixels'].isna()\ntrain_df.head()","4beada14":"train_nan_df = train_df.groupby(by='ImageId', axis=0).agg('sum')\ntrain_nan_df.reset_index(inplace=True)\ntrain_nan_df.rename(columns={'isNan' : 'missingCount'}, inplace=True)\ntrain_nan_df['missingCount'] = train_nan_df['missingCount'].astype(np.int32)\ntrain_nan_df['allMissing'] = (train_nan_df['missingCount'] == 4).astype(int)\n\ntrain_nan_df.head(16)","821559ab":"train_nan_df['missingCount'].hist()\ntrain_nan_df['missingCount'].value_counts()","e462d965":"import ssl\nfrom keras.models import model_from_json\nfrom sklearn.utils import shuffle\nfrom sklearn.model_selection import StratifiedKFold, KFold\n\ndef make_fold_csv(input_df):\n    #input_df.to_csv(\"train_nan_df.csv\")\n    skfold = StratifiedKFold(n_splits=K_FOLDS, random_state=2019, shuffle=True)\n\n    for fold_index, (train_idx, val_idx) in enumerate(skfold.split(X=input_df['ImageId'], y=input_df['allMissing'])):\n        \n        # train\/val \ub370\uc774\ud130 \ub098\ub214\n        dataframe_train = input_df.iloc[train_idx, :].reset_index()\n        dataframe_val = input_df.iloc[val_idx, :].reset_index()\n        \n        df_train_filename = (\"fold_%d_train.csv\" % (fold_index))\n        df_val_filename = (\"fold_%d_val.csv\" % (fold_index))\n\n        dataframe_train = shuffle(dataframe_train).reset_index(drop=True)\n        dataframe_val = shuffle(dataframe_val).reset_index(drop=True)\n\n        dataframe_train.to_csv(df_train_filename, index=False)\n        dataframe_val.to_csv(df_val_filename, index=False)    \n\n#make_fold_csv(train_nan_df)","581cb581":"BATCH_SIZE = 16\n\nINPUT_WIDTH = 800\nINPUT_HEIGHT = 128\n\ndef get_total_batch(num_samples, batch_size):    \n    if (num_samples % batch_size) > 0 :\n        return (num_samples \/\/ batch_size) + 1\n    else :\n        return num_samples \/\/ batch_size\n\ndef create_datagen():\n    return ImageDataGenerator(\n        zoom_range=0.1,  # set range for random zoom\n        # set mode for filling points outside the input boundaries\n        fill_mode='constant',\n        cval=0.,\n        rotation_range=10,\n        height_shift_range=0.1,\n        width_shift_range=0.1,\n        horizontal_flip=True,\n        vertical_flip=True,\n        rescale=1\/255.)\n\ndef create_flow(df, dir, datagen):\n    return datagen.flow_from_dataframe(\n        df,\n        directory=dir,\n        x_col='ImageId', \n        y_col='allMissing', \n        class_mode='raw',\n        target_size=(INPUT_HEIGHT, INPUT_WIDTH),\n        batch_size=BATCH_SIZE)\n    \n    ","3c753b2d":"# https:\/\/github.com\/titu1994\/keras-efficientnets\n\n! pip install keras_efficientnets","88647b7b":"from keras_efficientnets import EfficientNetB0, EfficientNetB4\n\ndef build_model():\n    efficientnet = EfficientNetB4((INPUT_HEIGHT, INPUT_WIDTH, 3), classes=1, include_top=False, weights='imagenet')\n    model = Sequential()\n    model.add(efficientnet)\n\n    model.add(layers.GlobalAveragePooling2D())\n    model.add(layers.BatchNormalization())\n    model.add(layers.Dropout(0.5))\n    model.add(layers.Dense(512, activation='relu'))\n    model.add(layers.BatchNormalization())\n    model.add(layers.Dropout(0.5))\n    model.add(layers.Dense(1, activation='sigmoid'))\n    \n    model.compile(\n        loss='binary_crossentropy',\n        optimizer=Nadam(),\n        metrics=['acc'])\n    \n    return model\n\n\n# model = build_model()\n# model.summary()","93ba1bb3":"from keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau, LambdaCallback\n\nfrom keras.backend import clear_session\nimport gc\n\n# Reset Keras Session\ndef clear_memory():\n    clear_session()\n    for i in range(20):\n        gc.collect()\n\n\ndef get_callbacks(model_save_filepath):    \n    checkpoint = ModelCheckpoint(\n        model_save_filepath,\n        monitor='val_acc',\n        verbose=1,\n        save_best_only=True,\n        save_weights_only=False,\n        mode='auto')\n    \n    es = EarlyStopping(monitor='val_acc', min_delta=0, patience = 3, verbose=1, mode='max')\n    rl = ReduceLROnPlateau(monitor = 'val_loss', factor = 0.5, patience = 2, min_lr=0.0000001, mode='min')\n\n    return [checkpoint, es, rl]\n","c274de07":"model = build_model()\nmodel_save_filename = (\"model_predict_missing_mask.h5\")\nmodel_save_filepath = os.path.join(\".\/\", model_save_filename)\n\ndata_generator = create_datagen()\ntrain_gen = create_flow(train_nan_df, TRAIN_IMAGE_PATH, data_generator)\nval_gen = create_flow(train_nan_df, TRAIN_IMAGE_PATH, data_generator)\n\nhistory = model.fit_generator(train_gen,\n                    validation_data=val_gen, \n                    epochs=10,\n                    callbacks=get_callbacks(model_save_filepath))\n\nhistory_df = pd.DataFrame(history.history)\nhistory_df[['val_loss']].plot()\nhistory_df[['val_acc']].plot()   \n\nclear_memory()","fb7a31e5":"from IPython.display import FileLinks\nFileLinks('.') # input argument is specified folder","4e3221cc":"# Severstal: Steel Defect Detection - Defect Classification Model","3a032fdd":"## END\n\n\uc0dd\uc131\ub41c model \ud30c\uc77c\uc744 \ud68c\uc218\ud55c\ub2e4.(1-pass \uc5d0\uc11c \uc0ac\uc6a9)","8b149c18":"Severstal: Steel Defect Detection competition\uc5d0\uc11c \uc774\ubbf8\uc9c0\uc5d0 defect\uc758 \uc874\uc7ac \uc720\ubb34\ub97c true\/false\ub85c \uc608\uce21\ud558\ub294 \ubaa8\ub378\uc744 \ub9cc\ub4dc\ub294 \ucee4\ub110. <br>\ndefect \uc874\uc7ac \ud655\uc778 \/ \ud310\ubcc4\ub41c \uc774\ubbf8\uc9c0\uc5d0 \ub300\ud574 segmentation\uc744 \uc218\ud589\ud558\ub294 2-step approach\ub97c \ud560 \ub54c \ud544\uc694\ud568.","513cd6f7":"## Modeling\n\n","437da434":"defect \ud310\ubcc4 \ubaa8\ub378\uc758 base\ub294 EfficientNet\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n\n\ucc38\uc870\ud55c \uc608\uc81c\uc5d0\uc11c\ub294 DenseNet\uc744 \uc0ac\uc6a9\ud558\uc600\uc73c\ub098 \uc785\ub825 \ud06c\uae30\uac00 \uc791\uc544\uc11c(224,224) \uc815\ubcf4 \uc190\uc2e4\uc774 \ub9ce\uc744 \uac83 \uac19\uc544\uc11c \uc785\ub825\uc774 \ud070 \ubaa8\ub378\ub85c \ubcc0\uacbd\ud558\uc600\ub2e4."}}