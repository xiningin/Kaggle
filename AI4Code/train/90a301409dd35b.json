{"cell_type":{"88d77221":"code","8cc365b7":"code","19849359":"code","bd23d694":"code","2399bb7e":"code","5c629c54":"code","6f4ef2be":"code","b589254c":"code","160ced10":"markdown","5751566d":"markdown","c88cfcfb":"markdown","7fb362d0":"markdown","f5eaa02b":"markdown","6fae2f19":"markdown","338a52c0":"markdown"},"source":{"88d77221":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","8cc365b7":"import cv2\nimport math\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\ndf = pd.read_csv('..\/input\/train_ship_segmentations.csv')\ndf.head()","19849359":"def rle_decode(mask_rle, shape=(768, 768)):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (height,width) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n\n    '''\n    s = mask_rle.split()\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]\n    starts -= 1\n    ends = starts + lengths\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    return img.reshape(shape).T  # Needed to align to RLE direction","bd23d694":"def read_image(img_name, type='train'):\n    if type=='train':\n        path = '..\/input\/train\/{}'\n    else:\n        path = '..\/input\/test\/{}'\n    img = cv2.imread(path.format(img_name))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    return img\n\ndef read_masks(img_name):\n    mask_list = df.loc[df['ImageId'] == img_name, 'EncodedPixels'].tolist()\n    all_masks = np.zeros((len(mask_list), 768,768))\n    for idx, mask in enumerate(mask_list):\n        if isinstance(mask, str):\n            all_masks[idx] = rle_decode(mask)\n    return all_masks\n\ndef read_flat_mask(img_name):\n    all_masks = read_masks(img_name)\n    return np.sum(all_masks, axis=0)\n\n\nimage_with_ships = '00021ddc3.jpg'\nimage_with_no_ships = '00003e153.jpg'\n_, axarr = plt.subplots(1, 2, figsize=(15, 40))\naxarr[0].axis('off')\naxarr[1].axis('off')\naxarr[0].imshow(read_image(image_with_ships))\naxarr[0].imshow(read_flat_mask(image_with_ships), alpha=0.4)\naxarr[1].imshow(read_image(image_with_no_ships))\naxarr[1].imshow(read_flat_mask(image_with_no_ships), alpha=0.4)","2399bb7e":"def iou(img_true, img_pred):\n    i = np.sum((img_true*img_pred) >0)\n    u = np.sum((img_true + img_pred) >0) + 0.0000000000000000001  # avoid division by zero\n    return i\/u\n\nm = read_flat_mask(image_with_ships)\nprint(iou(m, m), iou(0, np.zeros((768, 768))), iou(m, np.ones((768, 768))))\n\nm = read_flat_mask(image_with_no_ships)\nprint(iou(m, m), iou(m, np.zeros((768, 768))), iou(m, np.ones((768, 768))))","5c629c54":"thresholds = [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95]\n\ndef f2(masks_true, masks_pred):\n    # a correct prediction on no ships in image would have F2 of zero (according to formula),\n    # but should be rewarded as 1\n    if np.sum(masks_true) == np.sum(masks_pred) == 0:\n        return 1.0\n    \n    f2_total = 0\n    ious = {}\n    for t in thresholds:\n        tp,fp,fn = 0,0,0\n        for i,mt in enumerate(masks_true):\n            found_match = False\n            for j,mp in enumerate(masks_pred):\n                key = 100 * i + j\n                if key in ious.keys():\n                    miou = ious[key]\n                else:\n                    miou = iou(mt, mp)\n                    ious[key] = miou  # save for later\n                if miou >= t:\n                    found_match = True\n            if not found_match:\n                fn += 1\n                \n        for j,mp in enumerate(masks_pred):\n            found_match = False\n            for i, mt in enumerate(masks_true):\n                miou = ious[100*i+j]\n                if miou >= t:\n                    found_match = True\n                    break\n            if found_match:\n                tp += 1\n            else:\n                fp += 1\n        f2 = (5*tp)\/(5*tp + 4*fn + fp)\n        f2_total += f2\n    \n    return f2_total\/len(thresholds)\n\n\nm = read_masks(image_with_ships)\nprint(f2(m, m), f2(m, [np.zeros((768, 768))]), f2(m, [np.ones((768, 768))]))\n\nm = read_masks(image_with_no_ships)\nprint(f2(m, m), f2(m, [np.zeros((768, 768))]), f2(m, [np.ones((768, 768))]))","6f4ef2be":"subset_images = 2000\nrandom_files = df['ImageId'].unique()\nnp.random.shuffle(random_files)\n#print(random_files[:subset_images])\n#print(random_files)\nf2_sum = 0\nfor fname in random_files[:subset_images]:\n    mask = read_masks(fname)\n    score = f2(mask, [np.zeros((768,768))])\n    f2_sum += score\n    \nprint(f2_sum\/subset_images)","b589254c":"df['EncodedPixels'].isna().sum() \/ len(df['ImageId'].unique())","160ced10":"I now get a smaller value, which could mean:\n* a slightly different distribution of the train\/test datasets\n* subset is too small (due to kernel limitations) \n* my evaluation code is wrong :)\n\nAs @manuscrits very well pointed out, the expectation would be to get a value close to the ratio of images with no ship. That means 75000, but we need to take care when counting the images **with** ships, as in the training data we have a mask for each detected ship, hence an image can appear multiple times if it contains more ships. \n\nAs such, the ratio of images with no ships is ","5751566d":"I define some utility functions for:\n* reading an image\n* reading all masks for a given image (for training and validation purposes)\n* flattening all masks (ships) for an image into a single one (for visualisation and possible training purposes)","c88cfcfb":"Compute IOU for 2 given binary masks. We need to avoid division by zero when there are no ships in ground truth and prediction.\nWe look at values for an image against itslef, all zeros and all ones masks.","7fb362d0":"I compute the average F2 on a subset of ground-truths and and a single blank prediction to see if we get anywhere close to the 0.847","f5eaa02b":"RLE decoding \"borrowed\" from @inversion's [Run Length Decoding - Quick Start\n](https:\/\/www.kaggle.com\/inversion\/run-length-decoding-quick-start )","6fae2f19":"F2 score implementation, but treating the exceptional case of a correct prediction of no ship.\nAgain, we test against itself, and single predictions of ones or zeros.","338a52c0":"I am trying to implement the F2 scoring used for the LB, for local validation purposes. \nAny feedback is appreciated!"}}