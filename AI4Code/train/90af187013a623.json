{"cell_type":{"ffa7265f":"code","82f6e831":"code","ee6349e7":"code","656f3775":"code","8c7f2d84":"code","52973a87":"code","fa61e97f":"code","876c1ffc":"code","65c6ab76":"code","da4888b2":"code","0196b8cc":"code","88d55605":"code","173719c3":"code","8041a072":"code","7f7e257e":"markdown","ec62a0ac":"markdown","e649c094":"markdown","b75afdd6":"markdown","9ca1728a":"markdown","3ac10d59":"markdown","712e7000":"markdown","f1317df9":"markdown","b0be3160":"markdown","e94ef2de":"markdown","d8150734":"markdown"},"source":{"ffa7265f":"import numpy as np \nimport matplotlib.pyplot as plt","82f6e831":"np.random.seed(0)\n","ee6349e7":"t = np.arange(0,1500)\nx = np.sin(0.015*t) + np.random.uniform(low=-1, high=1, size=(1500,))\nx_actual = np.sin(0.015*t)\nplt.plot(x)\nplt.plot(x_actual)","656f3775":"from sklearn.preprocessing import MinMaxScaler\n","8c7f2d84":"normalizer = MinMaxScaler(feature_range=(0, 1))\nx = (np.reshape(x, (-1, 1)))\nx = normalizer.fit_transform(x)\nprint(x)","52973a87":"train = x[0:1000]\ntest = x[1000:]\nprint(train.shape)","fa61e97f":"def createDataset(data, step):\n    X, Y =[], []\n    for i in range(len(data)-step): \n        X.append(data[i:i+step])\n        Y.append(data[i+step])\n    return np.array(X), np.array(Y)\n \nstep = 10\ntrainX,trainY = createDataset(train,step)\ntestX,testY = createDataset(test,step)\nprint(trainX[0])","876c1ffc":"print(trainY[0])\nprint(trainX.shape)\n","65c6ab76":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, SimpleRNN","da4888b2":"model = Sequential()\nmodel.add(SimpleRNN(units=1, activation=\"tanh\"))\nmodel.add(Dense(1))\nmodel.compile(loss='mean_squared_error', optimizer='rmsprop')","0196b8cc":"history = model.fit(trainX,trainY, epochs=500, batch_size=16, verbose=2)\n","88d55605":"import matplotlib.pyplot as plt\n \nloss = history.history['loss']\n \nplt.plot(loss)","173719c3":"trainPredict = normalizer.inverse_transform(model.predict(trainX))\ntestPredict= normalizer.inverse_transform(model.predict(testX))\npredicted= np.concatenate((trainPredict,testPredict))\nx = normalizer.inverse_transform(x)","8041a072":"plt.plot(x)\nplt.plot(predicted)\nplt.axvline(len(trainX), c=\"r\")","7f7e257e":"**Seed**","ec62a0ac":"**Loss plot**","e649c094":"**Prediction**","b75afdd6":"**Import lib**","9ca1728a":"**Import libs**","3ac10d59":"**Create Model**","712e7000":"**Plot**","f1317df9":"**Final Plot**","b0be3160":"**Import libs**","e94ef2de":"**Create Dataset**","d8150734":"**Normalise**"}}