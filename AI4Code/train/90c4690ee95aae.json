{"cell_type":{"04c67004":"code","e11f4a7e":"code","ec2d2cc7":"code","19fc6fcc":"code","b2e90f72":"code","f9e9f967":"code","5d66738c":"code","95c7c663":"code","54659a70":"code","b7a1470d":"code","176cb60a":"code","8fe6c5c9":"code","bda73c02":"code","912f9e99":"code","d1b33027":"code","ce054970":"code","d3adc884":"code","24aa0f84":"markdown","9df2b461":"markdown","9c923ffa":"markdown","c2968d67":"markdown","ac68ab39":"markdown","92cb5670":"markdown","891033e0":"markdown","4ac6efd2":"markdown","d0324979":"markdown","d3d544bd":"markdown","28a10f0e":"markdown","5cb9b2c9":"markdown"},"source":{"04c67004":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","e11f4a7e":"champs = pd.read_csv(\"..\/input\/league-of-legends-ranked-matches\/champs.csv\")\nmatches = pd.read_csv(\"\/kaggle\/input\/league-of-legends-ranked-matches\/matches.csv\")\nparticipants = pd.read_csv(\"\/kaggle\/input\/league-of-legends-ranked-matches\/participants.csv\")\nstats1 = pd.read_csv(\"\/kaggle\/input\/league-of-legends-ranked-matches\/stats1.csv\")\nstats2 = pd.read_csv(\"\/kaggle\/input\/league-of-legends-ranked-matches\/stats2.csv\")\nteamstats = pd.read_csv(\"\/kaggle\/input\/league-of-legends-ranked-matches\/teamstats.csv\")","ec2d2cc7":"def bot_pos(row):\n    if row.position == \"BOT\":\n        if row.role == 'DUO_SUPPORT':\n            row.position = \"SUPP\"\n        else:\n            row.position = \"ADC\"\n    return row\n\nparticipants = participants.apply(bot_pos, axis = \"columns\")\nparticipants.loc[:,[\"position\",\"role\"]]","19fc6fcc":"participants[\"teamid\"] = participants.player.apply(lambda x: 100 if x<= 5 else 200)\nstats_merged = pd.concat([stats1,stats2])\ntrain_data = pd.merge(participants,stats_merged, on = \"id\")\ntrain_data = pd.merge(train_data, teamstats.drop([\"firstblood\"],axis=1), on = [\"matchid\",\"teamid\"])\n\ntrain_data = train_data.drop([\"id\",\"matchid\",\"teamid\",\"player\"], axis=1)\ntrain_data.head()\n\n# saves a copy of the merged dataset\ntrain_data.to_csv('merged_data.csv', index = False)","b2e90f72":"ChampionWinrate = train_data[[\"championid\",\"win\"]].groupby([\"championid\"], as_index = False).mean()\nChampionWinrate.plot(\"championid\",\"win\")\nprint(\"The correlation between ChampionID and its Winrate is \" + str(ChampionWinrate.corr().championid.win))\n","f9e9f967":"train_data[[\"position\",'win']].groupby([\"position\"], as_index = False).mean()\n","5d66738c":"train_data[[\"role\",'win']].groupby([\"role\"], as_index = False).mean()","95c7c663":"KillsWinrate = train_data[[\"position\",\"kills\",'win']].groupby([\"position\",\"kills\"], as_index = False).mean()\nKillsWinrate = KillsWinrate.pivot(index=\"kills\", columns='position', values='win')\nKillsWinrate.plot()\nKillsWinrate.corrwith(KillsWinrate.reset_index().kills)","54659a70":"DeathsWinrate = train_data[[\"position\",\"deaths\",'win']].groupby([\"position\",\"deaths\"], as_index = False).mean()\nDeathsWinrate = DeathsWinrate.pivot(index=\"deaths\", columns='position', values='win')\nDeathsWinrate.plot()\nDeathsWinrate.corrwith(DeathsWinrate.reset_index().deaths)","b7a1470d":"AssistsWinrate = train_data[[\"position\",\"assists\",'win']].groupby([\"position\",\"assists\"], as_index = False).mean()\nAssistsWinrate = AssistsWinrate.pivot(index=\"assists\", columns='position', values='win')\nAssistsWinrate.plot()\nAssistsWinrate.corrwith(AssistsWinrate.reset_index().assists)","176cb60a":"train_data[\"KDA\"] = train_data.apply(lambda x: (x.kills + x.assists) \/ max(x.deaths,1), axis = \"columns\")\n\nKDAWinrate = train_data[[\"position\",\"KDA\",'win']].groupby([\"position\",\"KDA\"], as_index = False).mean()\nKDAWinrate = KDAWinrate.pivot(index=\"KDA\", columns='position', values='win')\nKDAWinrate.corrwith(KDAWinrate.reset_index().KDA)","8fe6c5c9":"for feature in [\"firsttower\",\"firstbaron\",\"firstinhib\",\"firstdragon\",\"firstharry\"]:\n    print(train_data[[feature,'win']].groupby([feature], as_index = False).mean())\n","bda73c02":"features = [\"largestkillingspree\",\"kills\",\"deaths\",\"assists\",\"KDA\",\"firstblood\",\"firsttower\",\"firstbaron\",\"firstinhib\",\"firstdragon\",\"firstharry\"]\n\ntrain_data = train_data.loc[:,features + [\"win\"]]\ntrain_data.head()","912f9e99":"from sklearn.model_selection import train_test_split\n\nx_train, x_test, y_train, y_test = train_test_split(train_data.drop([\"win\"], axis=1), train_data[\"win\"], test_size=0.20, random_state=42)\n","d1b33027":"import tensorflow as tf\nx_train, x_test, y_train, y_test = map(tf.convert_to_tensor, [x_train, x_test, y_train, y_test])\n\nmodel = tf.keras.models.Sequential([\n    tf.keras.layers.Dense(20, activation = 'relu'),\n    tf.keras.layers.Dense(1, activation = None)\n])\n\nmodel.compile(\n    optimizer = tf.keras.optimizers.Adam(learning_rate=0.001),\n    loss = tf.keras.losses.BinaryCrossentropy(),\n    metrics = [\"accuracy\"]\n)\n\nmodel.fit(x_train, y_train, batch_size = 64, epochs = 5)\n\nprint(\"The accuary of this model is \" + str(model.evaluate(x_test,y_test)[1]) + \", while the loss is \" + str(model.evaluate(x_test,y_test)[0]))\n","ce054970":"# from sklearn.ensemble import RandomForestClassifier\n# from sklearn.metrics import accuracy_score\n\n# model = RandomForestClassifier(n_estimators = 100, max_depth = 10, random_state = 1)\n# model.fit(x_train,y_train)\n# predictions = model.predict(x_test)\n# accuracy_score(predictions,y_test)","d3adc884":"# from sklearn.svm import SVC\n# from sklearn.metrics import accuracy_score\n\n# model = SVC()\n# model.fit(x_train,y_train)\n# predictions = model.predict(x_test)\n# accuracy_score(predictions,y_test)","24aa0f84":"**Merging the datasets**  \n\nWe merge the various datasets together indexed by the participants. In particular, given a player, we will have the champion he\/she played, role, position etc; as well as his \/ her team stats, such as whether or not his \/ her got the first tower, first dragon etc. ","9df2b461":"**Splitting the Dataset**\n\nWe split the dataset into training sets and validation sets.","9c923ffa":"On the other hand, stats like kills, deaths and assists should have a strong correlation with winning. When the number of kills is \"too high\", it suggests that the game has gone on for a very long time. In a very long game, every player will be at \"full-build\", so the advantages of having a better scoreline is neglegible. Thus, we expect the winrate to have almost no correlation with kills if the kills are high. \n\nAdditionally, we should look at these stats separately for each position, since supports generally do not score many kills. We should see the exact same phenomenon for supports compared to other positions, except \"compressed\" along the x-axis. \n\nInterestingly, the kills have the highest correletation with winrate for junglers and midlaners. This makes sense because these are the two positions that have the highest agency and move around the map the most. That is, they are the roles that can most easily convert their advantages to victory. \n\nOn the contrary, it is expected that the correlation between kills support players have and winrate should be low. They are usually not the primary damage dealers, and the gold is better given to other roles. \n\nSurprisingly, toplane kills do not correlate with winning. One possible explanation is that many tanks and bruisers are played top, and are not the main carries of the team. Additionally, toplaners are usually in an isolated one vs one situation, which means that the kills they obtain may not be from big teamfights that lead to big objects and ultimately, the victory. We will need to divide the toplaners by champions played and divide them by style to get a better answer.","c2968d67":"In the provided dataset, both the adc position and the support position are grouped as \"BOT\". We will first separate these. ","ac68ab39":"**Picking Features for Machine Learning**\n\nHere, we pick some of the features that we analyzed above. ","92cb5670":"Adding all the data sets. ","891033e0":"In League of Legends, a common stat people care about: KDA (which is just kills + assists \/ deaths). We also explore this stat. \n\nIt is actually incredibly suprising that such a simple statistic has a similar correlation across all roles. ","4ac6efd2":"Here are some other team-wide objects that definitely correlates with winning:","d0324979":"For deaths, it makes sense for there to be a high anti-correlation with winrate for midlaners and ADCs, since they are the main carries on the team. It is surprising that support deaths are also so important to winrate. A possible explanation is that the ADC and the support are almost always together and the death of one correlates highly with the death of another as well. We will most likely not see this same phenomenon if the dataset is of professional games, where supports roam more often and are often the engagers of the team (and often die as a result). ","d3d544bd":"The strong correlation of toplaner's and support's assists with winning (in comparison to the same thing for kills) suggest that while it is good to get kills and assists, it is often better for their teammates to get the kills, as they are in a stronger carry position. In comparison, midlaners have a lower correlation between assists and winrate, because it is much better for them to get the kills instead. \n\nMeanwhile, junglers have high correlation for both kills and assists, because they are the most pro-active role. Any winning fights for junglers (be it kills or assists) is beneficial for the team. Kills and assists are good indicators of an active jungler. They can also easily snowball the lead to the rest of the map. ","28a10f0e":"Here is a simple neural network that attempts to predict the winrate of a given player, given the above features. We use binary crossentropy as the loss function because this is a simple binary classification problem. \n\nThe learning rate is kept low, because for higher learning rates, we are seeing the accuracy start out high, and decrease with more training sets. \n","5cb9b2c9":"**Analyzing some features**\n\nFirst, we look at some stats and see how well it correlates with winning. For example, we don't expect champions played to have any influence on winning, because the game is relatively balanced so any given champion should have a 50% win rate. Similarly for positions and role. Indeed: "}}