{"cell_type":{"6da9f7b0":"code","30dc034a":"code","4f2c7a1a":"code","fac69727":"code","a9125930":"code","0ecee727":"code","17809981":"code","ca6e6bee":"code","8b68c49b":"code","3a789f87":"code","c0efa88b":"code","b227982d":"code","fcc29c41":"markdown","c911c915":"markdown","3b4d1459":"markdown","db18ffcd":"markdown","f1cd1e79":"markdown","653d8a0c":"markdown","011566d6":"markdown","c7986d11":"markdown","a1b1e544":"markdown","404a3757":"markdown","3022a2b1":"markdown","5780cbd2":"markdown","05d46c59":"markdown"},"source":{"6da9f7b0":"class Operation:\n    \"\"\"Represents a graph node that performs a computation.\n\n    An `Operation` is a node in a `Graph` that takes zero or\n    more objects as input, and produces zero or more objects\n    as output.\n    \"\"\"\n\n    def __init__(self, input_nodes=[]):\n        \"\"\"Construct Operation\n        \"\"\"\n        self.input_nodes = input_nodes\n\n        # Initialize list of consumers (i.e. nodes that receive this operation's output as input)\n        self.consumers = []\n\n        # Append this operation to the list of consumers of all input nodes\n        for input_node in input_nodes:\n            input_node.consumers.append(self)\n\n        # Append this operation to the list of operations in the currently active default graph\n        _default_graph.operations.append(self)\n\n    def compute(self):\n        \"\"\"Computes the output of this operation.\n        \"\" Must be implemented by the particular operation.\n        \"\"\"\n        pass","30dc034a":"class add(Operation):\n    \"\"\"Returns x + y element-wise.\n    \"\"\"\n\n    def __init__(self, x, y):\n        \"\"\"Construct add\n\n        Args:\n          x: First summand node\n          y: Second summand node\n        \"\"\"\n        super().__init__([x, y])\n\n    def compute(self, x_value, y_value):\n        \"\"\"Compute the output of the add operation\n\n        Args:\n          x_value: First summand value\n          y_value: Second summand value\n        \"\"\"\n        return x_value + y_value","4f2c7a1a":"class mul(Operation):\n    \"\"\"Returns x + y element-wise.\n    \"\"\"\n\n    def __init__(self, x, y):\n        \"\"\"Construct add\n\n        Args:\n          x: First summand node\n          y: Second summand node\n        \"\"\"\n        super().__init__([x, y])\n\n    def compute(self, x_value, y_value):\n        \"\"\"Compute the output of the add operation\n\n        Args:\n          x_value: First summand value\n          y_value: Second summand value\n        \"\"\"\n        return x_value * y_value","fac69727":"class inv(Operation):\n    \"\"\"Returns x + y element-wise.\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Construct add\n\n        Args:\n          x: First summand node\n          y: Second summand node\n        \"\"\"\n        super().__init__([x])\n\n    def compute(self, x_value):\n        \"\"\"Compute the output of the add operation\n\n        Args:\n          x_value: First summand value\n          y_value: Second summand value\n        \"\"\"\n        return (1\/x_value)","a9125930":"class MAX(Operation):\n    \"\"\"Returns x + y element-wise.\n    \"\"\"\n\n    def __init__(self, x, y):\n        \"\"\"Construct add\n\n        Args:\n          x: First summand node\n          y: Second summand node\n        \"\"\"\n        super().__init__([x, y])\n\n    def compute(self, x_value, y_value):\n        \"\"\"Compute the output of the add operation\n\n        Args:\n          x_value: First summand value\n          y_value: Second summand value\n        \"\"\"\n        return max(x_value, y_value)","0ecee727":"class matmul(Operation):\n    \"\"\"Multiplies matrix a by matrix b, producing a * b.\n    \"\"\"\n\n    def __init__(self, a, b):\n        \"\"\"Construct matmul\n\n        Args:\n          a: First matrix\n          b: Second matrix\n        \"\"\"\n        super().__init__([a, b])\n\n    def compute(self, a_value, b_value):\n        \"\"\"Compute the output of the matmul operation\n\n        Args:\n          a_value: First matrix value\n          b_value: Second matrix value\n        \"\"\"\n        return a_value.dot(b_value)","17809981":"class placeholder:\n    \"\"\"Represents a placeholder node that has to be provided with a value\n       when computing the output of a computational graph\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Construct placeholder\n        \"\"\"\n        self.consumers = []\n\n        # Append this placeholder to the list of placeholders in the currently active default graph\n        _default_graph.placeholders.append(self)","ca6e6bee":"class Variable:\n    \"\"\"Represents a variable (i.e. an intrinsic, changeable parameter of a computational graph).\n    \"\"\"\n\n    def __init__(self, initial_value=None):\n        \"\"\"Construct Variable\n\n        Args:\n          initial_value: The initial value of this variable\n        \"\"\"\n        self.value = initial_value\n        self.consumers = []\n\n        # Append this variable to the list of variables in the currently active default graph\n        _default_graph.variables.append(self)","8b68c49b":"class Graph:\n    \"\"\"Represents a computational graph\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Construct Graph\"\"\"\n        self.operations = []\n        self.placeholders = []\n        self.variables = []\n\n    def as_default(self):\n        global _default_graph\n        _default_graph = self","3a789f87":"import numpy as np\n\n\nclass Session:\n    \"\"\"Represents a particular execution of a computational graph.\n    \"\"\"\n\n    def run(self, operation, feed_dict={}):\n        \"\"\"Computes the output of an operation\n\n        Args:\n          operation: The operation whose output we'd like to compute.\n          feed_dict: A dictionary that maps placeholders to values for this session\n        \"\"\"\n\n        # Perform a post-order traversal of the graph to bring the nodes into the right order\n        nodes_postorder = traverse_postorder(operation)\n\n        # Iterate all nodes to determine their value\n        for node in nodes_postorder:\n\n            if type(node) == placeholder:\n                # Set the node value to the placeholder value from feed_dict\n                node.output = feed_dict[node]\n            elif type(node) == Variable:\n                # Set the node value to the variable's value attribute\n                node.output = node.value\n            else:  # Operation\n                # Get the input values for this operation from the output values of the input nodes\n                node.inputs = [input_node.output for input_node in node.input_nodes]\n\n                # Compute the output of this operation\n                node.output = node.compute(*node.inputs)\n\n            # Convert lists to numpy arrays\n            if type(node.output) == list:\n                node.output = np.array(node.output)\n\n        # Return the requested node value\n        return operation.output\n\n\ndef traverse_postorder(operation):\n    \"\"\"Performs a post-order traversal, returning a list of nodes\n    in the order in which they have to be computed\n\n    Args:\n       operation: The operation to start traversal at\n    \"\"\"\n\n    nodes_postorder = []\n\n    def recurse(node):\n        if isinstance(node, Operation):\n            for input_node in node.input_nodes:\n                recurse(input_node)\n        nodes_postorder.append(node)\n\n    recurse(operation)\n    return nodes_postorder","c0efa88b":"# Create a new graph\nGraph().as_default()\n\n# Create variables\nA = Variable([[1, 0], [0, -1]])\nb = Variable([1, 1])\n\n# Create placeholder\nx = placeholder()\n\n# Create hidden node y\ny = matmul(A, x)\n\n# Create output node z\nz = add(y, b)","b227982d":"session = Session()\noutput = session.run(z, {\n    x: [1, 2]\n})\nprint(output)","fcc29c41":"# MAX Implementaion","c911c915":"# Operations\n\nEvery operation is characterized by three things:\n\n1. A compute function that computes the operation's output given values for the operation's inputs\n2. A list of input_nodes which can be variables or other operations\n3. A list of consumers that use the operation's output as their input","3b4d1459":"# Variables\n\nIn the affine transformation graph, there is a qualitative difference between x on the one hand and A and b on the other hand. While x is an input to the operation, A and b are parameters of the operation, i.e. they are intrinsic to the graph. We will refer to such parameters as Variables.","db18ffcd":"# Inverse Implementaion","f1cd1e79":"# Multiply Implementation","653d8a0c":"# ADD Implementation","011566d6":"# Placeholders\n\nNot all the nodes in a computational graph are operations. For example, in the affine transformation graph, **A, x and b** are not operations. Rather, they are inputs to the graph that have to be supplied with a value once we want to compute the output of the graph. To provide such values, we introduce placeholders.","c7986d11":"# Session\n\nNow that we are confident creating computational graphs, we can start to think about how to compute the output of an operation.\n\nLet's create a Session class that encapsulates an execution of an operation. We would like to be able to create a session instance and call a run method on this instance, passing the operation that we want to compute and a dictionary containing values for the placeholders:\n\nThis should compute the following value:\n\n![image.png](attachment:image.png)\n\nIn order to compute the function represented by an operation, we need to apply the computations in the right order. For example, we cannot compute **z** before we have computed **y** as an intermediate result. Therefore, we have to make sure that the operations are carried out in the right order, such that the values of every node that is an input to an operation **o** has been computed before **o** is computed. This can be achieved via post-order traversal.","a1b1e544":"# Matrix Multiplication","404a3757":"# Assignment (Week 8): Computation Graph\n\nA computational graph is a directed graph where the nodes correspond to operations or variables. Variables can feed their value into operations, and operations can feed their output into other operations. This way, every node in the graph defines a function of the variables. The values that are fed into the nodes and come out of the nodes are called tensors, which is just a fancy word for a multi-dimensional array. Hence, it subsumes scalars, vectors and matrices as well as tensors of a higher rank.","3022a2b1":"# The Graph Class\n\nFinally, we'll need a class that bundles all the operations, placeholders and variables together. When creating a new graph, we can call its as_default method to set the _default_graph to this graph. This way, we can create operations, placeholders and variables without having to pass in a reference to the graph everytime.","5780cbd2":"# Some elementary operations\n\n1. Add\n2. Multiply\n3. Inverse\n4. Max\n5. Matrix Multiplication","05d46c59":"# Example\n\nLet's now use the classes we have built to create a computational graph for the following affine transformation:\n\n![image.png](attachment:image.png)"}}