{"cell_type":{"d6cb72e7":"code","ce1f2fc4":"code","6ca33d85":"code","0b5155c2":"code","929ea947":"code","80e180b6":"code","3e268e0c":"code","22884d87":"code","211cc05f":"code","80dd1afb":"code","5c4d8dad":"code","f9146d51":"code","49270126":"code","44dd93c8":"code","5c5f37f1":"code","8b07548d":"code","0bd5c2c7":"code","71c7aef8":"code","1b3bb7c8":"code","dcf6dc47":"code","9eb7b3e9":"code","15932893":"code","21d0db83":"code","bb024999":"code","807a62e4":"code","4ea9561d":"code","de677462":"code","d114bff8":"code","e2b312fa":"code","89c52489":"code","57975bf3":"code","cb9fc94d":"code","b89e3afa":"code","f142c7f4":"code","cf364e90":"code","9a6246ca":"code","5a7e09da":"code","0d292038":"code","3c68adfb":"code","d6f6b91b":"code","746d9cb9":"code","388e9005":"code","86f4744e":"code","9da67a7b":"code","f9116352":"code","87142537":"markdown","490d0cc7":"markdown","b51382de":"markdown","17491d24":"markdown","f956eeb9":"markdown","80b7c2d3":"markdown","9a32a2fa":"markdown","416134e8":"markdown","bf92260f":"markdown","59a5f17e":"markdown"},"source":{"d6cb72e7":"import pandas as pd\nimport numpy as np\nimport os\nfrom glob import glob\nimport itertools\nimport fnmatch\nimport random\nimport matplotlib.pylab as plt\nimport seaborn as sns\nimport cv2\nfrom scipy.misc import imresize, imread\nimport sklearn\nfrom sklearn import model_selection\nfrom sklearn.model_selection import train_test_split, KFold, cross_val_score, StratifiedKFold, learning_curve, GridSearchCV\nfrom sklearn.metrics import confusion_matrix, make_scorer, accuracy_score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.svm import SVC, LinearSVC\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nimport keras\nfrom keras import backend as K\nfrom keras.callbacks import Callback, EarlyStopping, ReduceLROnPlateau, ModelCheckpoint\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.utils.np_utils import to_categorical\nfrom keras.models import Sequential, model_from_json\nfrom keras.optimizers import SGD, RMSprop, Adam, Adagrad, Adadelta\nfrom keras.layers import Dense, Dropout, Activation, Flatten, BatchNormalization, Conv2D, MaxPool2D, MaxPooling2D\n%matplotlib inline","ce1f2fc4":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","6ca33d85":"import os\nfiles = os.listdir('\/kaggle\/input\/')\nprint (files)","0b5155c2":"for path, dirs, files in os.walk('..\/input\/'):\n  for f in dirs:\n    print (f)","929ea947":"import os\nfiles = os.listdir('\/kaggle\/input\/IDC_regular_ps50_idx5\/')\nprint (files)","80e180b6":"import os\nfiles = os.listdir('\/kaggle\/input\/IDC_regular_ps50_idx5\/')\nfor file in files:\n   print (file)\n","3e268e0c":"import os\nfiles = os.listdir('\/kaggle\/input\/IDC_regular_ps50_idx5\/')\nprint (len(files))","22884d87":"files[0:10]","211cc05f":"import os\nfiles = os.listdir('\/kaggle\/input\/')\nprint (len(files))","80dd1afb":"files[0:10]","5c4d8dad":"patient_file = os.listdir(\"..\/input\/IDC_regular_ps50_idx5\/13459\")\npatient_file","f9146d51":"imagePatches = glob('\/kaggle\/input\/IDC_regular_ps50_idx5\/**\/*.png', recursive=True)\nprint(len(imagePatches))","49270126":"imagePatches = glob('\/kaggle\/input\/IDC_regular_ps50_idx5\/**\/*.png', recursive=True)\nfor filename in imagePatches[400:1000]:\n    print(filename)","44dd93c8":"len (imagePatches)","5c5f37f1":"image_name = \"\/kaggle\/input\/IDC_regular_ps50_idx5\/9135\/1\/9135_idx5_x1701_y1851_class1.png\" \ndef plotImage(image_location):\n    image = cv2.imread(image_name)\n    image = cv2.resize(image, (50,50))\n    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)); plt.axis('off')\n    return\nplotImage(image_name)","8b07548d":"image_name = \"\/kaggle\/input\/IDC_regular_ps50_idx5\/12935\/0\/12935_idx5_x601_y1151_class0.png\" \ndef plotImage(image_location):\n    image = cv2.imread(image_name)\n    image = cv2.resize(image, (50,50))\n    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)); plt.axis('off')\n    return\nplotImage(image_name)","0bd5c2c7":"# Plot Multiple Images\nbunchOfImages = imagePatches\ni_ = 0\nplt.rcParams['figure.figsize'] = (10.0, 10.0)\nplt.subplots_adjust(wspace=0, hspace=0)\nfor l in bunchOfImages[:25]:\n    im = cv2.imread(l)\n    im = cv2.resize(im, (50, 50)) \n    plt.subplot(5, 5, i_+1) #.set_title(l)\n    plt.imshow(cv2.cvtColor(im, cv2.COLOR_BGR2RGB)); plt.axis('off')\n    i_ += 1","71c7aef8":"def randomImages(a):\n    r = random.sample(a, 4)\n    plt.figure(figsize=(16,16))\n    plt.subplot(131)\n    plt.imshow(cv2.imread(r[0]))\n    plt.subplot(132)\n    plt.imshow(cv2.imread(r[1]))\n    plt.subplot(133)\n    plt.imshow(cv2.imread(r[2])); \nrandomImages(imagePatches)","1b3bb7c8":"patternZero = '*class0.png'\npatternOne = '*class1.png'\nclassZero = fnmatch.filter(imagePatches, patternZero)\nclassOne = fnmatch.filter(imagePatches, patternOne)\nprint(\"IDC(-)\\n\\n\",classZero[0:5],'\\n')\nprint(\"IDC(+)\\n\\n\",classOne[0:5])","dcf6dc47":"def proc_images(lowerIndex,upperIndex):\n    \"\"\"\n    Returns two arrays: \n        x is an array of resized images\n        y is an array of labels\n    \"\"\" \n    x = []\n    y = []\n    WIDTH = 50\n    HEIGHT = 50\n    for img in imagePatches[lowerIndex:upperIndex]:\n        full_size_image = cv2.imread(img)\n        x.append(cv2.resize(full_size_image, (WIDTH,HEIGHT), interpolation=cv2.INTER_CUBIC))\n        if img in classZero:\n            y.append(0)\n        elif img in classOne:\n            y.append(1)\n        else:\n            return\n    return x,y","9eb7b3e9":"X,Y = proc_images(0,100)\nprint (X)","15932893":"X,Y = proc_images(0,900)\ndf = pd.DataFrame()\ndf[\"images\"]=X\ndf[\"labels\"]=Y\nX2=df[\"images\"]\nY2=df[\"labels\"]\nX2=np.array(X2)\nimgs0=[]\nimgs1=[]\nimgs0 = X2[Y2==0] # (0 = no IDC, 1 = IDC)\nimgs1 = X2[Y2==1] ","21d0db83":"df[\"images\"]","bb024999":"print (X2)","807a62e4":"def describeData(a,b):\n    print('Total number of images: {}'.format(len(a)))\n    print('Number of IDC(-) Images: {}'.format(np.sum(b==0)))\n    print('Number of IDC(+) Images: {}'.format(np.sum(b==1)))\n    print('Percentage of positive images: {:.2f}%'.format(100*np.mean(b)))\n    print('Image shape (Width, Height, Channels): {}'.format(a[0].shape))\ndescribeData(X2,Y2)","4ea9561d":"dict_characters = {0: 'IDC(-)', 1: 'IDC(+)'}\nprint(df.head(5))\nprint(\"\")\nprint(dict_characters)","de677462":"def plotOne(a,b):\n    \"\"\"\n    Plot one numpy array\n    \"\"\"\n    plt.subplot(1,2,1)\n    plt.title('IDC (-)')\n    plt.imshow(a[0])\n    plt.subplot(1,2,2)\n    plt.title('IDC (+)')\n    plt.imshow(b[0])\nplotOne(imgs0, imgs1) ","d114bff8":"def plotTwo(a,b): \n    \"\"\"\n    Plot a bunch of numpy arrays sorted by label\n    \"\"\"\n    for row in range(3):\n        plt.figure(figsize=(20, 10))\n        for col in range(3):\n            plt.subplot(1,8,col+1)\n            plt.title('IDC (-)')\n            plt.imshow(a[0+row+col])\n            plt.axis('off')       \n            plt.subplot(1,8,col+4)\n            plt.title('IDC (+)')\n            plt.imshow(b[0+row+col])\n            plt.axis('off')\nplotTwo(imgs0, imgs1) ","e2b312fa":"def plotHistogram(a):\n    \"\"\"\n    Plot histogram of RGB Pixel Intensities\n    \"\"\"\n    plt.figure(figsize=(10,5))\n    plt.subplot(1,2,1)\n    plt.imshow(a)\n    plt.axis('off')\n    plt.title('IDC(+)' if Y[1] else 'IDC(-)')\n    histo = plt.subplot(1,2,2)\n    histo.set_ylabel('Count')\n    histo.set_xlabel('Pixel Intensity')\n    n_bins = 30\n    plt.hist(a[:,:,0].flatten(), bins= n_bins, lw = 0, color='r', alpha=0.5);\n    plt.hist(a[:,:,1].flatten(), bins= n_bins, lw = 0, color='g', alpha=0.5);\n    plt.hist(a[:,:,2].flatten(), bins= n_bins, lw = 0, color='b', alpha=0.5);\nplotHistogram(X2[100])","89c52489":"X=np.array(X)\nX=X\/255.0\n\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2)\n\n# Reduce Sample Size for DeBugging\n# X_train = X_train[0:300000] \n# Y_train = Y_train[0:300000]\n# X_test = X_test[0:300000] \n# Y_test = Y_test[0:300000]\n\nprint(\"Training Data Shape:\", X_train.shape)\nprint(\"Testing Data Shape:\", X_test.shape)","57975bf3":"plotHistogram(X_train[100])","cb9fc94d":"# Encode labels to hot vectors (ex : 2 -> [0,0,1,0,0,0,0,0,0,0])\nY_trainHot = to_categorical(Y_train, num_classes = 2)\nY_testHot = to_categorical(Y_test, num_classes = 2)","b89e3afa":"Y_trainHot","f142c7f4":"lab = df['labels']\ndist = lab.value_counts()\nsns.countplot(lab)\nprint(dict_characters)","cf364e90":"X_train.shape[1]","9a6246ca":"X_trainShape = X_train.shape[1]*X_train.shape[2]*X_train.shape[3]\nX_testShape = X_test.shape[1]*X_test.shape[2]*X_test.shape[3]\nX_trainFlat = X_train.reshape(X_train.shape[0], X_trainShape)","5a7e09da":"X_train.shape[0]","0d292038":"X_trainShape","3c68adfb":"X_train[0]","d6f6b91b":"X_trainFlat[0] ","746d9cb9":"# Deal with imbalanced class sizes below\n# Make Data 1D for compatability upsampling methods\nX_trainShape = X_train.shape[1]*X_train.shape[2]*X_train.shape[3]\nX_testShape = X_test.shape[1]*X_test.shape[2]*X_test.shape[3]\nX_trainFlat = X_train.reshape(X_train.shape[0], X_trainShape)\nX_testFlat = X_test.reshape(X_test.shape[0], X_testShape)\n#print(\"X_train Shape: \",X_train.shape)\n#print(\"X_test Shape: \",X_test.shape)\n#print(\"X_trainFlat Shape: \",X_trainFlat.shape)\n#print(\"X_testFlat Shape: \",X_testFlat.shape)\n\nfrom imblearn.over_sampling import RandomOverSampler\nfrom imblearn.under_sampling import RandomUnderSampler\n#ros = RandomOverSampler(ratio='auto')\nros = RandomUnderSampler(ratio='auto')\nX_trainRos, Y_trainRos = ros.fit_sample(X_trainFlat, Y_train)\nX_testRos, Y_testRos = ros.fit_sample(X_testFlat, Y_test)\n\n# Encode labels to hot vectors (ex : 2 -> [0,0,1,0,0,0,0,0,0,0])\nY_trainRosHot = to_categorical(Y_trainRos, num_classes = 2)\nY_testRosHot = to_categorical(Y_testRos, num_classes = 2)\n#print(\"X_train: \", X_train.shape)\n#print(\"X_trainFlat: \", X_trainFlat.shape)\n#print(\"X_trainRos Shape: \",X_trainRos.shape)\n#print(\"X_testRos Shape: \",X_testRos.shape)\n#print(\"Y_trainRosHot Shape: \",Y_trainRosHot.shape)\n#print(\"Y_testRosHot Shape: \",Y_testRosHot.shape)\n\nfor i in range(len(X_trainRos)):\n    height, width, channels = 50,50,3\n    X_trainRosReshaped = X_trainRos.reshape(len(X_trainRos),height,width,channels)\n#print(\"X_trainRos Shape: \",X_trainRos.shape)\n#print(\"X_trainRosReshaped Shape: \",X_trainRosReshaped.shape)\n\nfor i in range(len(X_testRos)):\n    height, width, channels = 50,50,3\n    X_testRosReshaped = X_testRos.reshape(len(X_testRos),height,width,channels)\n#print(\"X_testRos Shape: \",X_testRos.shape)\n#print(\"X_testRosReshaped Shape: \",X_testRosReshaped.shape)\n\ndfRos = pd.DataFrame()\ndfRos[\"labels\"]=Y_trainRos\nlabRos = dfRos['labels']\ndistRos = lab.value_counts()\nsns.countplot(labRos)\nprint(dict_characters)","388e9005":"from sklearn.utils import class_weight\nclass_weight = class_weight.compute_class_weight('balanced', np.unique(Y_train), Y_train)\nprint(\"Old Class Weights: \",class_weight)\nfrom sklearn.utils import class_weight\nclass_weight2 = class_weight.compute_class_weight('balanced', np.unique(Y_trainRos), Y_trainRos)\nprint(\"New Class Weights: \",class_weight2)","86f4744e":"# Helper Functions  Learning Curves and Confusion Matrix\n\nclass MetricsCheckpoint(Callback):\n    \"\"\"Callback that saves metrics after each epoch\"\"\"\n    def __init__(self, savepath):\n        super(MetricsCheckpoint, self).__init__()\n        self.savepath = savepath\n        self.history = {}\n    def on_epoch_end(self, epoch, logs=None):\n        for k, v in logs.items():\n            self.history.setdefault(k, []).append(v)\n        np.save(self.savepath, self.history)\n\ndef plotKerasLearningCurve():\n    plt.figure(figsize=(10,5))\n    metrics = np.load('logs.npy')[()]\n    filt = ['acc'] # try to add 'loss' to see the loss learning curve\n    for k in filter(lambda x : np.any([kk in x for kk in filt]), metrics.keys()):\n        l = np.array(metrics[k])\n        plt.plot(l, c= 'r' if 'val' not in k else 'b', label='val' if 'val' in k else 'train')\n        x = np.argmin(l) if 'loss' in k else np.argmax(l)\n        y = l[x]\n        plt.scatter(x,y, lw=0, alpha=0.25, s=100, c='r' if 'val' not in k else 'b')\n        plt.text(x, y, '{} = {:.4f}'.format(x,y), size='15', color= 'r' if 'val' not in k else 'b')   \n    plt.legend(loc=4)\n    plt.axis([0, None, None, None]);\n    plt.grid()\n    plt.xlabel('Number of epochs')\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize = (5,5))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=90)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n\ndef plot_learning_curve(history):\n    plt.figure(figsize=(8,8))\n    plt.subplot(1,2,1)\n    plt.plot(history.history['acc'])\n    plt.plot(history.history['val_acc'])\n    plt.title('model accuracy')\n    plt.ylabel('accuracy')\n    plt.xlabel('epoch')\n    plt.legend(['train', 'test'], loc='upper left')\n    plt.savefig('.\/accuracy_curve.png')\n    #plt.clf()\n    # summarize history for loss\n    plt.subplot(1,2,2)\n    plt.plot(history.history['loss'])\n    plt.plot(history.history['val_loss'])\n    plt.title('model loss')\n    plt.ylabel('loss')\n    plt.xlabel('epoch')\n    plt.legend(['train', 'test'], loc='upper left')\n    plt.savefig('.\/loss_curve.png')","9da67a7b":"def runKerasCNNAugment(a,b,c,d,e,f):\n    \"\"\"\n    Run Keras CNN: https:\/\/github.com\/fchollet\/keras\/blob\/master\/examples\/mnist_cnn.py\n    \"\"\"\n    batch_size = 128\n    num_classes = 2\n    epochs = 8\n#     img_rows, img_cols = a.shape[1],a.shape[2]\n    img_rows,img_cols=50,50\n    input_shape = (img_rows, img_cols, 3)\n    model = Sequential()\n    model.add(Conv2D(32, kernel_size=(3, 3),\n                     activation='relu',\n                     input_shape=input_shape,strides=e))\n    model.add(Conv2D(64, (3, 3), activation='relu'))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.25))\n    model.add(Flatten())\n    model.add(Dense(128, activation='relu'))\n    model.add(Dropout(0.5))\n    model.add(Dense(num_classes, activation='softmax'))\n    model.compile(loss=keras.losses.categorical_crossentropy,\n                  optimizer=keras.optimizers.Adadelta(),\n                  metrics=['accuracy'])\n    datagen = ImageDataGenerator(\n        featurewise_center=False,  # set input mean to 0 over the dataset\n        samplewise_center=False,  # set each sample mean to 0\n        featurewise_std_normalization=False,  # divide inputs by std of the dataset\n        samplewise_std_normalization=False,  # divide each input by its std\n        zca_whitening=False,  # apply ZCA whitening\n        rotation_range=20,  # randomly rotate images in the range (degrees, 0 to 180)\n        width_shift_range=0.2,  # randomly shift images horizontally (fraction of total width)\n        height_shift_range=0.2,  # randomly shift images vertically (fraction of total height)\n        horizontal_flip=True,  # randomly flip images\n        vertical_flip=True)  # randomly flip images\n    history = model.fit_generator(datagen.flow(a,b, batch_size=32),\n                        steps_per_epoch=len(a) \/ 32, epochs=epochs,class_weight=f, validation_data = [c, d],callbacks = [MetricsCheckpoint('logs')])\n    score = model.evaluate(c,d, verbose=0)\n    print('\\nKeras CNN #1C - accuracy:', score[1],'\\n')\n    y_pred = model.predict(c)\n    map_characters = {0: 'IDC(-)', 1: 'IDC(+)'}\n    print('\\n', sklearn.metrics.classification_report(np.where(d > 0)[1], np.argmax(y_pred, axis=1), target_names=list(map_characters.values())), sep='')    \n    Y_pred_classes = np.argmax(y_pred,axis=1) \n    Y_true = np.argmax(d,axis=1) \n    plotKerasLearningCurve()\n    plt.show()  \n    plot_learning_curve(history)\n    plt.show()\n    confusion_mtx = confusion_matrix(Y_true, Y_pred_classes) \n    plot_confusion_matrix(confusion_mtx, classes = list(dict_characters.values())) \n    plt.show()\nrunKerasCNNAugment(X_trainRosReshaped, Y_trainRosHot, X_testRosReshaped, Y_testRosHot,2,class_weight2)","f9116352":"#runKerasCNNAugment(X_train, Y_trainHot, X_test, Y_testHot,2,class_weight)","87142537":"*Step 1: Import Modules*","490d0cc7":"90+% accuracy is pretty good!  And it does not look too be to overfit or too biased based off of the learning curve and confusion matrix.  In the future, I will improve the score by optimizing the data augmentation step as well as the network architecture.","b51382de":"*Step 5: Evaluate Classification Models*","17491d24":"*Step 2: Explore Data*","f956eeb9":"*Step 4: Define Helper Functions for the Classification Task*","80b7c2d3":"In a previous kernel I evaluated a number of different classification algorithms while using an abbreviated form of this same dataset.  To see how and why I chose the model that I use below, please see the following link: https:\/\/www.kaggle.com\/paultimothymooney\/predicting-idc-in-breast-cancer-histology-images\/","9a32a2fa":"**Predicting IDC in Breast Cancer Histology Images** \n* Part One: https:\/\/www.kaggle.com\/paultimothymooney\/predicting-idc-in-breast-cancer-histology-images\/\n* * Model Selection (see link above)\n*  Part Two: Predict IDC in Breast Cancer\n* * Model Evaluation (see below)\n\nBreast cancer is the most common form of cancer in women, and invasive ductal carcinoma (IDC) is the most common form of breast cancer. Accurately identifying and categorizing breast cancer subtypes is an important clinical task, and automated methods can be used to save time and reduce error.\n\nThe goal of this script is to identify IDC when it is present in otherwise unlabeled histopathology images. The dataset consists of 277,524 50x50 pixel RGB digital image patches that were derived from 162 H&E-stained breast histopathology samples. These images are small patches that were extracted from digital images of breast tissue samples. The breast tissue contains many cells but only some of them are cancerous. Patches that are labeled \"1\" contain cells that are characteristic of invasive ductal carcinoma. For more information about the data, see https:\/\/www.ncbi.nlm.nih.gov\/pubmed\/27563488 and http:\/\/spie.org\/Publications\/Proceedings\/Paper\/10.1117\/12.2043872.","416134e8":"Next I will try one more time but without the undersampling step.","bf92260f":"*Step 3: Preprocess Data*","59a5f17e":"The data is scaled from 0 to 256 but we want it to be scaled from 0 to 1. This will make the data compatible with a wide variety of different classification algorithms.  We also want to set aside 20% of the data for testing. This will make the trained model less prone to overfitting.  And finally, we will use an oversampling strategy to deal with the imbalanced class sizes."}}