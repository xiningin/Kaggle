{"cell_type":{"ffbaa372":"code","2162dfb1":"code","e91fd5aa":"code","37f85d06":"code","28dfb9e1":"code","d298ddc3":"code","fdd39612":"code","8acc243d":"code","05f5f192":"code","1f01251a":"code","ebc017b9":"code","d861a7af":"markdown"},"source":{"ffbaa372":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","2162dfb1":"train = pd.read_csv('\/kaggle\/input\/competicao-dsa-machine-learning-sep-2019\/X_treino.csv'\n                            ,dtype = {\n                                'series_id': np.int16\n                               ,'measurement_number': np.int16\n                               ,'orientation_X': np.float32\n                               ,'orientation_X': np.float32\n                                ,'orientation_Y': np.float32\n                                ,'orientation_Z': np.float32\n                                ,'orientation_W': np.float32\n                                ,'angular_velocity_X': np.float32\n                                ,'angular_velocity_Y': np.float32\n                                ,'angular_velocity_Z': np.float32\n                                ,'linear_acceleration_X': np.float32\n                                ,'linear_acceleration_Y': np.float32\n                                ,'linear_acceleration_Z': np.float32\n                            })\n\ntest = pd.read_csv('\/kaggle\/input\/competicao-dsa-machine-learning-sep-2019\/X_teste.csv'\n                            ,dtype = {\n                                'series_id': np.int16\n                               ,'measurement_number': np.int16\n                               ,'orientation_X': np.float32\n                               ,'orientation_X': np.float32\n                                ,'orientation_Y': np.float32\n                                ,'orientation_Z': np.float32\n                                ,'orientation_W': np.float32\n                                ,'angular_velocity_X': np.float32\n                                ,'angular_velocity_Y': np.float32\n                                ,'angular_velocity_Z': np.float32\n                                ,'linear_acceleration_X': np.float32\n                                ,'linear_acceleration_Y': np.float32\n                                ,'linear_acceleration_Z': np.float32\n                            })\n\ny_train = pd.read_csv('\/kaggle\/input\/competicao-dsa-machine-learning-sep-2019\/y_treino.csv'\n                            ,dtype = {\n                                'series_id': np.int16\n                               ,'group_id': np.int16\n                            })\n\ntrain.shape, test.shape, y_train.shape","e91fd5aa":"full = pd.concat([train, test])\nX_treino = train.iloc[:,3:].values.reshape(-1,128,10)\nX_teste = test.iloc[:,3:].values.reshape(-1,128,10)\nprint('X_treino shape:', X_treino.shape, ', X_teste shape:', X_teste.shape)","37f85d06":"def sq_dist(a,b):\n    ''' the squared euclidean distance between two samples '''\n    \n    return np.sum((a-b)**2, axis=1)\n\n\ndef find_run_edges(data, edge):\n    ''' examine links between samples. left\/right run edges are those samples which do not have a link on that side. '''\n\n    if edge == 'left':\n        border1 = 0\n        border2 = -1\n    elif edge == 'right':\n        border1 = -1\n        border2 = 0\n    else:\n        return False\n    \n    edge_list = []\n    linked_list = []\n    \n    for i in range(len(data)):\n        dist_list = sq_dist(data[i, border1, :4], data[:, border2, :4]) # distances to rest of samples\n        min_dist = np.min(dist_list)\n        closest_i   = np.argmin(dist_list) # this is i's closest neighbor\n        if closest_i == i: # this might happen and it's definitely wrong\n            print('Sample', i, 'linked with itself. Next closest sample used instead.')\n            closest_i = np.argsort(dist_list)[1]\n        dist_list = sq_dist(data[closest_i, border2, :4], data[:, border1, :4]) # now find closest_i's closest neighbor\n        rev_dist = np.min(dist_list)\n        closest_rev = np.argmin(dist_list) # here it is\n        if closest_rev == closest_i: # again a check\n            print('Sample', i, '(back-)linked with itself. Next closest sample used instead.')\n            closest_rev = np.argsort(dist_list)[1]\n        if (i != closest_rev): # we found an edge\n            edge_list.append(i)\n        else:\n            linked_list.append([i, closest_i, min_dist])\n            \n    return edge_list, linked_list\n\n\ndef find_runs(data, left_edges, right_edges):\n    ''' go through the list of samples & link the closest neighbors into a single run '''\n    \n    data_runs = []\n\n    for start_point in left_edges:\n        i = start_point\n        run_list = [i]\n        while i not in right_edges:\n            tmp = np.argmin(sq_dist(data[i, -1, :4], data[:, 0, :4]))\n            if tmp == i: # self-linked sample\n                tmp = np.argsort(sq_dist(data[i, -1, :4], data[:, 0, :4]))[1]\n            i = tmp\n            run_list.append(i)\n        data_runs.append(np.array(run_list))\n    \n    return data_runs","28dfb9e1":"full = full.iloc[:,3:].values.reshape(-1,128,10)","d298ddc3":"train_left_edges, train_left_linked  = find_run_edges(full, edge='left')\ntrain_right_edges, train_right_linked = find_run_edges(full, edge='right')\nprint('Found', len(train_left_edges), 'left edges and', len(train_right_edges), 'right edges.')","fdd39612":"train_runs = find_runs(full, train_left_edges, train_right_edges)","8acc243d":"submission = pd.read_csv('\/kaggle\/input\/competicao-dsa-machine-learning-sep-2019\/sample_submission.csv')","05f5f192":"submission['surface'] = ''\ndf_surface = ''\n\nfor i in range(151):\n    x = train_runs[i]\n    x = np.sort(x)\n    if x[0]<3810:\n        df_surface = y_train['surface'][x[0]]\n        for j in range(len(train_runs[i])):\n            if train_runs[i][j]-3810>-1:\n                submission['surface'][train_runs[i][j]-3810] = df_surface","1f01251a":"submission.head()","ebc017b9":"submission.to_csv('cv70.csv',index = False)","d861a7af":"**Cr\u00e9ditos:** Markus F publicou um Kernel chamado Missing links: https:\/\/www.kaggle.com\/friedchips\/the-missing-link. L\u00e1 ir\u00e3o encontrar os detalhes com explica\u00e7\u00f5es"}}