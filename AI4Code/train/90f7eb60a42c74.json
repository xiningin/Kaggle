{"cell_type":{"080d5c7b":"code","0ddf173e":"code","32a97d8d":"code","fb30fe6b":"code","8f4fa311":"code","0651752c":"code","48b3a86f":"code","4b657345":"code","dc64bf78":"code","418704d2":"code","a47957e9":"code","f7dee533":"code","942adcc9":"code","b88b46c6":"code","31d126ed":"code","e3788299":"markdown","ae6b5e4f":"markdown","19954a38":"markdown","c81630ef":"markdown","8cf27799":"markdown","82255bb0":"markdown","c40c165a":"markdown","7505db49":"markdown","a28f6d5d":"markdown"},"source":{"080d5c7b":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tensorflow as tf\nfrom sklearn.model_selection import train_test_split # train\/test split\nfrom keras.models import Sequential # Model of Choice\nfrom keras.layers import Dense\nfrom sklearn.preprocessing import StandardScaler\nfrom keras.metrics import RootMeanSquaredError\nfrom sklearn.metrics import mean_squared_error\nfrom scipy.stats import reciprocal\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom keras.wrappers.scikit_learn import KerasRegressor\nfrom sklearn.model_selection import GridSearchCV\nfrom tensorflow.keras.layers import Normalization\n\n\nPrint = True","0ddf173e":"train_data = pd.read_csv('..\/input\/NNAssigment\/train.csv')\neval_data = pd.read_csv('..\/input\/NNAssigment\/eval.csv')","32a97d8d":"if Print:\n    print(train_data.head())","fb30fe6b":"if Print:\n    print(train_data.head())","8f4fa311":"if Print:\n    print(train_data.info())","0651752c":"if Print:\n    print(eval_data.info())","48b3a86f":"if Print:\n    print(train_data.isnull().sum())","4b657345":"X_train, X_test, y_train, y_test = train_test_split(train_data, train_data['Eat'])\nX_train = X_train.drop(['id', 'pubchem_id', 'Eat'], axis=1)\nX_test = X_test.drop(['id', 'pubchem_id', 'Eat'], axis=1)\n\neval_fixed = eval_data.drop(['id', 'pubchem_id'], axis=1)","dc64bf78":"model = Sequential()\nmodel.add(Dense(256,input_shape=X_train.shape[1:], activation='relu')) # Input Layer\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dense(1)) # Output Layer\n\noptimizer = tf.keras.optimizers.Adamax(learning_rate=1e-4)\nmodel.compile(loss='mean_squared_error', optimizer= optimizer, metrics=tf.keras.metrics.RootMeanSquaredError(name='rmse'))\nmodel.fit(X_train, y_train, epochs=128, batch_size=16)\n\noutput = pd.DataFrame({'name': ['Basic Model'],'output': [model.predict(eval_fixed)], 'score': [mean_squared_error(y_test, model.predict(X_test))]})","418704d2":"output","a47957e9":"def build_model(n_hidden=1, n_neurons=30, learning_rate=1e-4, input_shape=X_train.shape[1:]):\n    model = Sequential()\n    model.add(Dense(n_neurons, input_shape=input_shape)) \n\n    for layer in range(n_hidden):\n        model.add(Dense(n_neurons, activation=\"relu\"))\n    \n    optimizer = tf.keras.optimizers.Adamax(learning_rate=learning_rate)\n    model.add(Dense(1))\n    model.compile(loss=\"mean_squared_error\", optimizer=optimizer, metrics=tf.keras.metrics.RootMeanSquaredError(name='rmse'))\n\n    return model\n\nparam_grid = {\n \"n_hidden\": [0, 1, 2, 3],\n \"n_neurons\": np.arange(16, 256),\n}\n\nkeras_reg = KerasRegressor(build_model)\nsecond_model = RandomizedSearchCV(keras_reg, param_grid, n_iter=2, n_jobs=-1)\n\nsecond_model.fit(X_train, y_train, epochs=128, batch_size=16)\noutput = output.append( pd.DataFrame(\n        {'name': ['RandomSearch - Second Model'],\n         'output': [second_model.predict(eval_fixed)], \n         'score':[ mean_squared_error(y_test, second_model.predict(X_test))]}),ignore_index = True)","f7dee533":"def build_third_model(n_hidden=1, n_neurons=30, learning_rate=1e-4, input_shape=X_train.shape[1:]):\n    model = Sequential()\n    normal = Normalization()\n    normal.adapt(X_train)\n    \n    model.add(normal)\n    model.add(Dense(n_neurons, input_shape=input_shape))\n\n    for layer in range(n_hidden):\n        model.add(Dense(n_neurons, activation=\"relu\"))\n    \n    optimizer = tf.keras.optimizers.Adamax(learning_rate=learning_rate)\n    model.add(Dense(1))\n    model.compile(loss=\"mean_squared_error\", optimizer=optimizer, metrics=tf.keras.metrics.RootMeanSquaredError(name='rmse'))\n    third_model.fit(X_train, y_train, epochs=32, batch_size=16)\n    return model\n\nparam_grid = {\n \"n_hidden\": [0, 1, 2, 3],\n \"n_neurons\": np.arange(16, 256),\n}\n\nthird_model_build = KerasRegressor(build_model)\nthird_model = RandomizedSearchCV(third_model_build, param_grid, n_jobs=-1)\nthird_model.fit(X_train, y_train, epochs=128, batch_size=16)\n\noutput = output.append(pd.DataFrame({'name':'Random Search - With Normalization',\n                                     'output':  [third_model.predict(eval_fixed)], \n                                     'score': [mean_squared_error(y_test, third_model.predict(X_test))]}), ignore_index = True)","942adcc9":"max_row = output.loc[output['score'] == output['score'].min()]\nprint(max_row)\nprint(\"Selected Model: \", max_row['name'])\nprint(\"Model Score: \", max_row['score'])\nprint(max_row['output'])","b88b46c6":"output_p = pd.DataFrame(max_row['output'].array)\nfixed_array = output_p.T\nfixed_array","31d126ed":"output_preds = pd.DataFrame(\n{'id': eval_data.id, 'Eat': fixed_array.to_numpy().flatten()})\noutput_preds.to_csv('.\/submission.csv', index=False)","e3788299":"# Third Model - Grid Search + Normalization ","ae6b5e4f":"**Understanding our Data**","19954a38":"**Importing Data**","c81630ef":"# Checking for missing data","8cf27799":"# Model 2 - Random Search","82255bb0":"We do not need the id and pubchem_id columns so we can drop them from our training data","c40c165a":"# Deciding on Best Model","7505db49":"**Looking at datatypes**","a28f6d5d":"# First Model - Basic Model "}}