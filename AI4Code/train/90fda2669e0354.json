{"cell_type":{"5fdd9b56":"code","cfbbaee6":"code","d895777c":"code","a6f7c9ba":"code","760ef047":"code","b8c9adb6":"code","366d080f":"code","fbaaacae":"code","e27da5ca":"code","e188d08d":"code","18847d0d":"code","ad0688b8":"code","fe6993c8":"code","e4df60b3":"code","c7dc4cca":"code","68663bdd":"code","b3163289":"code","535e344f":"code","c68acb96":"code","0f0571c0":"code","32b37088":"code","ffcbe9b6":"code","bb4ed7ea":"code","afed5b1a":"code","bcee8faf":"code","55f15b09":"code","ea0122b8":"code","1fc9fdf9":"code","ba993479":"code","03dd6065":"code","50cde6fd":"code","0b45010c":"code","1f16b49c":"code","7cebdd23":"code","0d82acf6":"code","9524f569":"code","e6dd21ff":"code","ca1da7a8":"code","11cb0f3b":"code","ed75317f":"code","05690044":"code","c30e87cd":"code","65ddbe70":"code","279ea1ea":"code","816de4f5":"code","b32891c5":"code","f5c91414":"code","82a57f56":"code","a526ce7f":"code","66826993":"code","1f5fac8e":"code","6f9570ab":"code","87670236":"code","f329d709":"code","b32ed4ae":"code","ab762cbb":"code","e61a1024":"code","c0739349":"code","77204ea2":"code","26143422":"code","99406963":"code","7d130a61":"code","c4f5d0b4":"code","dad25352":"code","ec8de794":"code","765ef962":"code","76e7caf4":"markdown","41e2b1b5":"markdown","49400ca5":"markdown","ac96e1ac":"markdown","3fb2a9ec":"markdown","98c99b48":"markdown","1035b949":"markdown","2b28130a":"markdown","66c9e45b":"markdown","69253a30":"markdown","0e0ea65e":"markdown","d8a54b3d":"markdown","b4834bcf":"markdown","64c596a1":"markdown","d79a869b":"markdown","321ceb4b":"markdown","4232b841":"markdown","8743df57":"markdown","f1b0402f":"markdown","28047caf":"markdown","9b43f9e0":"markdown","13b85be5":"markdown","1e2a205b":"markdown","7a536538":"markdown","65bd050f":"markdown","536c257b":"markdown","3ac66864":"markdown","cdacedd0":"markdown","f576382b":"markdown","391c61fe":"markdown","bf2f244b":"markdown","d9309f15":"markdown","b21396b0":"markdown","229e6cc5":"markdown","043f2ed9":"markdown","e384b8bc":"markdown","cf3d38c0":"markdown"},"source":{"5fdd9b56":"import pandas as pd \nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline \nimport gc\nfrom datetime import datetime \nfrom sklearn.model_selection import train_test_split\nimport os\npd.set_option('display.max_columns', 100)","cfbbaee6":"PATH=\"..\/input\"\nprint(os.listdir(PATH))","d895777c":"ratings_df = pd.read_csv(os.path.join(PATH,\"ratings_small.csv\"), low_memory=False)","a6f7c9ba":"links_df = pd.read_csv(os.path.join(PATH,\"links_small.csv\"), low_memory=False)","760ef047":"movies_metadata_df = pd.read_csv(os.path.join(PATH,\"movies_metadata.csv\"), low_memory=False)","b8c9adb6":"credits_df = pd.read_csv(os.path.join(PATH,\"credits.csv\"), low_memory=False)","366d080f":"keywords_df = pd.read_csv(os.path.join(PATH,\"keywords.csv\"), low_memory=False)","fbaaacae":"print(\"Ratings data contains {} rows and {} columns\".format(ratings_df.shape[0], ratings_df.shape[1]))\nprint(\"Links data contains {} rows and {} columns\".format(links_df.shape[0], links_df.shape[1]))\nprint(\"Movie metadata contains {} rows and {} columns\".format(movies_metadata_df.shape[0], movies_metadata_df.shape[1]))\nprint(\"Credits data contains {} rows and {} columns\".format(credits_df.shape[0], credits_df.shape[1]))\nprint(\"Keywords data contains {} rows and {} columns\".format(keywords_df.shape[0], keywords_df.shape[1]))","e27da5ca":"ratings_df.head()","e188d08d":"links_df.head()","18847d0d":"movies_metadata_df.head()","ad0688b8":"keywords_df.head()","fe6993c8":"from ast import literal_eval\n# Returns the list top l elements or entire list; whichever is more.\ndef get_list(x, l=5):\n    if isinstance(x, list):\n        names = [i['name'] for i in x]\n        #Check if more than l elements exist. If yes, return only first three. If no, return entire list.\n        if len(names) > l:\n            names = names[:l]\n        return names\n\n    #Return empty list in case of missing\/malformed data\n    return []\n\nmovies_metadata_df['genres'] = movies_metadata_df['genres'].apply(literal_eval)\nmovies_metadata_df['genres'] = movies_metadata_df['genres'].apply(get_list)","e4df60b3":"pd.DataFrame({'feature':ratings_df.dtypes.index, 'dtype':ratings_df.dtypes.values})","c7dc4cca":"movies_metadata_df.head()","68663bdd":"pd.DataFrame({'feature':movies_metadata_df.dtypes.index, 'dtype':movies_metadata_df.dtypes.values})","b3163289":"ratings_df.describe()","535e344f":"import datetime\nmin_time = datetime.datetime.fromtimestamp(min(ratings_df.timestamp)).isoformat()\nmax_time = datetime.datetime.fromtimestamp(max(ratings_df.timestamp)).isoformat()\nprint('Timestamp for ratings from {} to {}:'.format(min_time, max_time))","c68acb96":"def check_missing(data_df):\n    total = data_df.isnull().sum().sort_values(ascending = False)\n    percent = (data_df.isnull().sum()\/data_df.isnull().count()*100).sort_values(ascending = False)\n    return pd.concat([total, percent], axis=1, keys=['Total', 'Percent']).transpose()\n\ncheck_missing(ratings_df)","0f0571c0":"check_missing(movies_metadata_df)","32b37088":"movies_metadata_df.dropna(subset=['title'], inplace=True)\ncheck_missing(movies_metadata_df)","ffcbe9b6":"movies_metadata_df['id'] = pd.to_numeric(movies_metadata_df['id'])","bb4ed7ea":"ratings_df.shape","afed5b1a":"ratings_df = ratings_df.merge(movies_metadata_df[['id']], left_on=['movieId'], right_on=['id'], how='inner')","bcee8faf":"ratings_df.shape","55f15b09":"ratings_df['time_dt'] = ratings_df['timestamp'].apply(lambda x: datetime.datetime.fromtimestamp(x))","ea0122b8":"ratings_df.head()","1fc9fdf9":"ratings_df['year'] = ratings_df['time_dt'].dt.year\nratings_df['month'] = ratings_df['time_dt'].dt.month\nratings_df['day'] = ratings_df['time_dt'].dt.day\nratings_df['dayofweek'] = ratings_df['time_dt'].dt.dayofweek","ba993479":"ratings_df[['year', 'month', 'day', 'dayofweek']].describe()","03dd6065":"fig, (ax1, ax2, ax3, ax4) = plt.subplots(ncols=4, figsize=(18,3))\ns = sns.boxplot(ax = ax1, y=\"year\", data=ratings_df, palette=\"Greens\",showfliers=True)\ns = sns.boxplot(ax = ax2, y=\"month\", data=ratings_df, palette=\"Blues\",showfliers=True)\ns = sns.boxplot(ax = ax3, y=\"day\", data=ratings_df, palette=\"Reds\",showfliers=True)\ns = sns.boxplot(ax = ax4, y=\"dayofweek\", data=ratings_df, palette=\"Reds\",showfliers=True)\nplt.show()","50cde6fd":"dt = ratings_df.groupby(['year'])['rating'].count().reset_index()\nfig, (ax) = plt.subplots(ncols=1, figsize=(12,6))\nplt.plot(dt['year'],dt['rating']); plt.xlabel('Year'); plt.ylabel('Number of votes'); plt.title('Number of votes per year')\nplt.show()","0b45010c":"dt = ratings_df.groupby(['year'])['rating'].mean().reset_index()\nfig, (ax) = plt.subplots(ncols=1, figsize=(12,6))\nplt.plot(dt['year'],dt['rating']); plt.xlabel('Year'); plt.ylabel('Average ratings'); plt.title('Average ratings per year')\nplt.show()","1f16b49c":"fig, (ax) = plt.subplots(ncols=1, figsize=(12,4))\ns = sns.boxplot(x='year', y=\"rating\", data=ratings_df, palette=\"Greens\",showfliers=True)\nplt.show()","7cebdd23":"fig, (ax) = plt.subplots(ncols=1, figsize=(10,4))\ns = sns.boxplot(x='month', y=\"rating\", data=ratings_df, palette=\"Blues\",showfliers=True)\nplt.show()","0d82acf6":"fig, (ax) = plt.subplots(ncols=1, figsize=(6,4))\ns = sns.boxplot(x='dayofweek', y=\"rating\", data=ratings_df, palette=\"Reds\",showfliers=True)\nplt.show()","9524f569":"print(\"There is a total of {} users, with an average number of {} votes.\".format(ratings_df.userId.nunique(), \\\n                                                round(ratings_df.shape[0]\/ratings_df.userId.nunique()),2))","e6dd21ff":"print(\"Top 5 voting users:\\n\")\ntmp = ratings_df.userId.value_counts()[:5]\npd.DataFrame({'Votes':tmp.values, 'Id':tmp.index})","ca1da7a8":"tmp = ratings_df.userId.value_counts()\ndf = pd.DataFrame({'Votes':tmp.values, 'Id':tmp.index})\nprint(\"There are {} users that voted only once.\".format(df[df['Votes']==1].nunique().values[0]))","11cb0f3b":"tmp = ratings_df.groupby(['userId'])['rating'].mean().reset_index()\ntmp['rating'] = tmp['rating'].apply(lambda x: round(x,3))\ndf_max = tmp[tmp['rating']==5]\ndf_min = tmp[tmp['rating']==0.5]\nprint(\"Users giving only '5': {}\\nUsers giving only '0.5':{}\".format(df_max.shape[0], df_min.shape[0]))","ed75317f":"mean_rating = round(ratings_df['rating'].mean(),3)\nprint(\"Average value of rating is {}.\".format(mean_rating))\nprint(\"There are {} users that have their average score with the overall average score (approx. with 3 decimals).\".format(\\\n                            tmp[tmp['rating']==mean_rating]['userId'].nunique()))","05690044":"print(\"There is a total of {} movies, with an average number of {} votes.\".format(ratings_df.movieId.nunique(), \\\n                                                round(ratings_df.shape[0]\/ratings_df.movieId.nunique()),2))","c30e87cd":"print(\"Top 10 voted movies:\\n\")\ntmp = ratings_df.movieId.value_counts()[:10]\npd.DataFrame({'Votes':tmp.values, 'id':tmp.index})","65ddbe70":"top_10 = pd.DataFrame({'Votes':tmp.values, 'id':tmp.index}).merge(movies_metadata_df)\ntop_10","279ea1ea":"tmp = ratings_df.movieId.value_counts()\ndf = pd.DataFrame({'Votes':tmp.values, 'Id':tmp.index})\nprint(\"There are {} movies that were voted only once.\".format(df[df['Votes']==1].nunique().values[0]))","816de4f5":"tmp = ratings_df.groupby(['movieId'])['rating'].mean().reset_index()\ntmp['rating'] = tmp['rating'].apply(lambda x: round(x,3))\ndf_max = tmp[tmp['rating']==5]\ndf_min = tmp[tmp['rating']==0.5]\nprint(\"Movies with only '5': {}\\nMovies with only '0.5':{}\".format(df_max.shape[0], df_min.shape[0]))","b32891c5":"mean_rating = round(ratings_df['rating'].mean(),3)\nprint(\"Average value of rating is {}.\".format(mean_rating))\nprint(\"There are {} movies that have their average score with the overall average score (approx. with 3 decimals).\".format(\\\n                            tmp[tmp['rating']==mean_rating]['movieId'].nunique()))","f5c91414":"from wordcloud import WordCloud, STOPWORDS\nimport matplotlib.pyplot as plt\nstopwords = set(STOPWORDS)\n\ndef show_wordcloud(data, title = None):\n    wordcloud = WordCloud(\n        background_color='white',\n        stopwords=stopwords,\n        max_words=17,\n        max_font_size=40, \n        scale=5,\n        random_state=1\n    ).generate(str(data))\n\n    fig = plt.figure(1, figsize=(10,10))\n    plt.axis('off')\n    if title: \n        fig.suptitle(title, fontsize=20)\n        fig.subplots_adjust(top=2.3)\n\n    plt.imshow(wordcloud)\n    plt.show()\n\nshow_wordcloud(movies_metadata_df['genres'], title = 'Movie Genres Prevalence in The Movie Dataset')","82a57f56":"tmp = ratings_df.groupby(['movieId'])['rating'].mean()\nR = pd.DataFrame({'id':tmp.index, 'R': tmp.values})\ntmp = ratings_df.groupby(['movieId'])['rating'].count()\nv = pd.DataFrame({'id':tmp.index, 'v': tmp.values})\nC = ratings_df['rating'].mean()","a526ce7f":"m_df = movies_metadata_df.merge(R, on=['id'])\nm_df = m_df.merge(v, on=['id'])\nm_df['C'] = C\nm= m_df['v'].quantile(0.9)\nm_df['m'] = m","66826993":"m_df.head()","1f5fac8e":"m_df['IMDB'] = (m_df['v'] \/ (m_df['v'] + m_df['m'])) * m_df['R'] + (m_df['m'] \/ (m_df['v'] + m_df['m'])) * m_df['C']","6f9570ab":"m_df.sort_values(by=['IMDB'], ascending=False).head(10)","87670236":"m_df[['title', 'IMDB']].sort_values(by=['IMDB'], ascending=False).head(10)","f329d709":"m_df['R_x_v'] = m_df['R'] * m_df['v']","b32ed4ae":"m_df[['title', 'v']].sort_values(by=['v'], ascending=False).head(10)","ab762cbb":"m_df[['title', 'R_x_v']].sort_values(by=['R_x_v'], ascending=False).head(10)","e61a1024":"del tmp, top_10\ngc.collect()","c0739349":"from sklearn.feature_extraction.text import TfidfVectorizer\ntfidf = TfidfVectorizer(stop_words='english',max_features=10000)\ntokens = m_df[['title']]\ntokens['title'] = tokens['title'].fillna('')\ntfidf_matrix = tfidf.fit_transform(tokens['title'])\nprint(tfidf_matrix.shape)\nfrom sklearn.metrics.pairwise import linear_kernel\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\nprint(cosine_sim.shape)\nindices = pd.Series(tokens.index, index=tokens['title']).drop_duplicates()\ndef get_recommendations(title, cosine_sim=cosine_sim):\n    # index of the movie that matches the title\n    idx = indices[title]\n\n    # similarity scores of all movies with that movie\n    sim_scores = list(enumerate(cosine_sim[idx]))\n\n    # sort the movies based on the similarity scores\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n    # scores of the 10 most similar movies\n    sim_scores = sim_scores[1:11]\n\n    # movie indices\n    movie_indices = [i[0] for i in sim_scores]\n\n    # top 10 most similar movies\n    return tokens['title'].iloc[movie_indices]\n","77204ea2":"get_recommendations('The Million Dollar Hotel')","26143422":"get_recommendations('Sleepless in Seattle')","99406963":"tfidf = TfidfVectorizer(stop_words='english',max_features=10000)\ntokens = m_df[['title']]\ntokens['title'] = tokens['title'].fillna('')\ntfidf_matrix = tfidf.fit_transform(tokens['title'])\nprint(tfidf_matrix.shape)\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\nprint(cosine_sim.shape)\nindices = pd.Series(tokens.index, index=tokens['title']).drop_duplicates()","7d130a61":"def get_imdb_score(df, indices):\n    # select the data from similarity indices\n    tmp = df[df.id.isin(indices)]\n    # sort the data by IMDB score\n    tmp = tmp.sort_values(by='IMDB', ascending=False)\n    # return title and IMDB score\n    return tmp[['title','IMDB']].head(10)","c4f5d0b4":"def get_10_recommendations_simpol(title, cosine_sim=cosine_sim):\n    # index of the movie that matches the title\n    idx = indices[title]\n\n    # similarity scores of all movies with that movie\n    sim_scores = list(enumerate(cosine_sim[idx]))\n\n    # sort the movies based on the similarity scores\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n    # scores of the 20 most similar movies\n    sim_scores = sim_scores[1:21]\n    \n    # movie indices\n    movie_indices = [i[0] for i in sim_scores]\n\n    # get popularity scores\n    pop_scores = get_imdb_score(m_df, movie_indices)\n    \n    return list(pop_scores['title'])\n","dad25352":"get_10_recommendations_simpol('The Million Dollar Hotel')","ec8de794":"get_10_recommendations_simpol('Judgment Night')","765ef962":"get_10_recommendations_simpol('Fahrenheit 9\/11')","76e7caf4":"## Glimpse the data\n\nLet's glimpse the data. We check the number of rows and columns, sample 5 rows and also run preliminary statistics (with *describe*) on the data.","41e2b1b5":"Let's check also the data types.","49400ca5":"# <a id=\"8\">References<\/a>  \n\nI took inspiration from several sources. \n\n[1] https:\/\/medium.com\/recombee-blog\/machine-learning-for-recommender-systems-part-1-algorithms-evaluation-and-cold-start-6f696683d0ed  \n[2] https:\/\/www.kaggle.com\/fabiendaniel\/film-recommendation-engine  \n[3] https:\/\/www.kaggle.com\/ibtesama\/getting-started-with-a-movie-recommendation-system\/data  \n\n\n<a href=\"#0\"><font size=\"1\">Go to top<\/font><\/a>","ac96e1ac":"<a href=\"#0\"><font size=\"1\">Go to top<\/font><\/a>\n\n\n# <a id=\"6\">Conclusion<\/a>  \n\nThree simple recommendation models were created, as following:\n\n* One model, user agnostic, based on ratings averages per movie and number of votes, it is basically the IMDB rating model; this model provide a top-10 list of movies recommendation, starting from a movie selected by a user;  \n* One model, depending on simmilarities of titles;\n* One model, depending on similarities of titles and IMDB rating.\n","3fb2a9ec":"Observations:\n* We are not observing a special behavior other than variation in time of the ratings averages, with a descending trend from 1995 to 2004, also with 2 peaks in 1997 and 1999 and ascending trend since 2004 to 2012, to start decreasing again.\n* Number of votes shows a lot of peaks and valleys, and also an ascendent trend to 2005, followed by a descending one from 2005, a sharp increase to 2015.\n* There are a number of outliers for each year, month and day of week. We observe a strange alignment of the rating distribution per year intervals 1996-2002, 2003-2011 and 2012-2017 which could prompt us to conclude that the selection used some artificial sampling.","98c99b48":"# <a id=\"1\">Introduction<\/a>  \n\n## Data\n\nWe are using only reduced data from the movie dataset, as following:\n*\t**ratings_small**\n*   **links_small**\n*\t**movies_metadata**  \n*   **credits**  \n*   **keywords**\n\nWe will create few recommendation models.\n\n<a href=\"#0\"><font size=\"1\">Go to top<\/font><\/a>","1035b949":"There are 6 movies without a title or 0.01%.\nLet's drop these rows.","2b28130a":"All features, `genre`, `id` and `title` are strings (or list of strings). ","66c9e45b":"All date and time looks fine, we will not need to eliminate or correct any value.","69253a30":"Let's extract also few date\/time attributes.","0e0ea65e":"\n<a href=\"#0\"><font size=\"1\">Go to top<\/font><\/a>","d8a54b3d":"## Read the data\n\nLet's read the data. In this exercise, we store the data in the current directory.","b4834bcf":"## Movie distribution\n\nLet's see what are the movies with the largest number of votes, with the biggest rating, with the lowest rating, how many movies have ratings close to average rating.","64c596a1":"<a href=\"#0\"><font size=\"1\">Go to top<\/font><\/a>\n\n\n# <a id=\"4\">Static rating model - top 10 movies<\/a>  \n\nLet's build now a baseline static rating model to create the top 10 movies.  \n\nWe use the formulas borrowed from two Kernels:\n* https:\/\/www.kaggle.com\/fabiendaniel\/film-recommendation-engine    \n* https:\/\/www.kaggle.com\/ibtesama\/getting-started-with-a-movie-recommendation-system\/data  \n\n\nWe will use for this the **IMDB** weighted rating formula, as following:\n\n$$IMDB = {\\frac{v}{v+m}}{R} + {\\frac{m}{v+m}}{C} $$\n\nwhere:\n* **IMDB** is weighted rating;  \n* **v** is the number of votes for the movie;\n* **m** is the minimum votes required to be included in the calculation;\n* **R** is the average rating of the movie; \n* **C** is the mean vote across the whole set.\n\nLet's calculate these values. For `m`, we consider quantile 0.9.","d79a869b":"Mean value for rating is ~3.5, min is 0.5 and max is 5. The ratings are given between Jan 1995 and Aug 2017.","321ceb4b":"## Check missing","4232b841":"## Memory cleanup","8743df57":"## <a id=\"5\">Recommendation simple models<\/a>\n\n\n## Simple model using similarities of movie title\n\nThe model will use similarities, calculated based on movie title.\n\nWe will use the already calculated `m_df` dataset.   \nThe methods to calculate cosine simmilarities are taken from:   \n* https:\/\/www.kaggle.com\/fabiendaniel\/film-recommendation-engine    \n* https:\/\/www.kaggle.com\/ibtesama\/getting-started-with-a-movie-recommendation-system\/data  ","f1b0402f":"Let's check now genres distribution.","28047caf":"Let's see what movies are those:","9b43f9e0":"The result: ","13b85be5":"## Users distribution\n\n\nLet's check if we have special users (users that give many votes, users that give preponderently high ratings, users that give mostly low ratings, users that are giving the perfect average value). Also, users with only one vote.","1e2a205b":"Observation: now all the movies in the `ratings_df` are present also in `movies_metadata_df` dataset.","7a536538":"## Check date\/time distribution\n\nLet's proceed now to check date\/time distribution. ","65bd050f":"## <font color=\"grey\">Top 10 by product of average rating and number of votes<\/font>","536c257b":"We will need to extract `genres` as lists of strings with movie genres.","3ac66864":"Let's compare this reference model with top 10 by only number of votes and by total value of votes.\n\n## <font color=\"grey\">Top 10 by number of votes<\/font>","cdacedd0":"## <font color=\"blue\">Static IMDB model: top 10<\/font>  \n\nThis is our reference model.","f576382b":"<h1><center><font size=\"6\">Movie Recommendation Model<\/font><\/center><\/h1>\n\n\n<img src=\"https:\/\/storage.googleapis.com\/kaggle-datasets-images\/3405\/5520\/155700dd4800b6486f19dcab0e0b0cb8\/dataset-card.jpg\" width=\"400\"><\/img>\n\n\n# <a id='0'>Content<\/a>\n\n- <a href='#1'>Introduction<\/a>  \n- <a href='#2'>Analysis preparation<\/a>  \n- <a href='#3'>Data preparation and exploration<\/a>  \n- <a href='#4'>Static rating model - top 10 movies<\/a>\n- <a href='#5'>Recommendation simple models<\/a>  \n- <a href='#6'>Conclusions<\/a>\n- <a href='#7'>References<\/a>","391c61fe":"We can confirm that we do not have missing data in `ratings_df`.\nLet's also check `movies_metadata_df`.","bf2f244b":"# <a id=\"3\">Data preparation<\/a>  \n\nLet's start to verify in more detail and curate the data.\n\n\n## Extract datetime","d9309f15":"## Combined model, using similarity and popularity\n\nThis model uses both similarity factor, based on movie title and popularity score, based on IMDB score.\n\nWe modify the `get_recommendation` function to return a number of 50 similar titles; we order the titles using popularity score. \n\nInspiration for the following functions are from:  \n\n* https:\/\/www.kaggle.com\/fabiendaniel\/film-recommendation-engine    \n* https:\/\/www.kaggle.com\/ibtesama\/getting-started-with-a-movie-recommendation-system\/data  ","b21396b0":"## Filter only votes to movies in movies metadata","229e6cc5":"We can show now the top 10 movies according to the IMDB score.","043f2ed9":"**Note**: these values should be interpreted considering that we only use a 20% sample from the ratings_df total data.","e384b8bc":"Let's also show the number and average value of ratings variation in time.","cf3d38c0":"# <a id=\"2\">Analysis preparation<\/a>  \n\nWe start by loading the packages needed for the analysis.\n\n## Load packages"}}