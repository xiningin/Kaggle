{"cell_type":{"174305e2":"code","aa7bdc34":"code","bc12ff0f":"code","5b09bc46":"code","baf7a577":"code","83d86005":"code","91cc4081":"code","b3f5408d":"code","8f80aa95":"code","7bc7ad6d":"code","ba6a76cc":"code","f2142ac7":"code","b12f5aeb":"code","d46e8613":"code","a3b7f522":"code","5a1d1f3b":"code","5058cb9c":"code","4374fef6":"code","c9f24497":"code","f818b502":"code","d4cf620c":"code","23d78410":"code","c2ff4477":"code","33020410":"code","09881ca4":"code","40014dd7":"code","28abaa45":"code","175fb4b0":"code","be13eafb":"code","6fbca200":"code","37bf36ab":"code","b224dbea":"code","3ceebefe":"code","23441e37":"code","bee36fe8":"code","92aea777":"code","7fe165f3":"code","69735513":"code","3e5ea90b":"code","62af290c":"code","551ccb81":"code","8d12448d":"code","a5dbd409":"code","b731239c":"code","7948e8bf":"code","6983ef26":"code","c70895b7":"code","2bac0ea7":"code","36b7b900":"code","15a5d13a":"code","44d8aae5":"code","5b215bf4":"code","d2daba99":"code","1219b65b":"code","61bd3115":"code","db739bd2":"code","a5986c9e":"code","4bf8aa2b":"code","3f338628":"code","73bfce45":"code","6ec40709":"code","3062b7f3":"code","472af22c":"code","62b1287b":"code","00b65fd8":"code","b6dccf63":"code","eb24ce7c":"code","7c55b346":"code","b1cefec1":"code","aafc4092":"code","b5fbd960":"code","41182759":"code","266b7149":"code","20e284b0":"code","1f79f64e":"code","5d4fb0ca":"code","31178cc2":"code","921ddf4c":"code","48c941fc":"code","0e48fd49":"code","e36c760f":"code","7e0fb93c":"code","ae3ba64f":"code","06ffea3c":"code","84d77b18":"code","908bb09a":"markdown","4a648bd5":"markdown","ce180a69":"markdown","5c0e66d9":"markdown","bd14adfe":"markdown","6e5d612d":"markdown","d585de05":"markdown","1a150776":"markdown","ad23acdf":"markdown","7a49d2c9":"markdown","4859e5e3":"markdown","e253e932":"markdown","3d53b46a":"markdown","6903f4a3":"markdown","4e68ca1c":"markdown"},"source":{"174305e2":"## import all libraries\nimport pandas as pd\nimport numpy as np\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.ensemble import RandomForestClassifier, VotingClassifier\nimport xgboost\nfrom sklearn.tree import DecisionTreeClassifier\nimport lightgbm as lgb\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import GridSearchCV \nfrom sklearn.model_selection import RandomizedSearchCV \nfrom sklearn.model_selection import StratifiedKFold, GridSearchCV, learning_curve, cross_val_score","aa7bdc34":"titanic = pd.read_csv(\"..\/input\/train.csv\")\ntitanic.head()","bc12ff0f":"## get the length and shape of train data\ndataframe_len = len(titanic)\ntitanic.shape","5b09bc46":"titanic.info()","baf7a577":"titanic_test = pd.read_csv(\"..\/input\/test.csv\")\ntest = titanic_test.copy()\ntitanic_test.head()","83d86005":"titanic.describe()","91cc4081":"### null check on train data\ntitanic.isnull().sum()","b3f5408d":"titanic_test.info()","8f80aa95":"#### null check on test data\ntitanic_test.isnull().sum()","7bc7ad6d":"print(\"Proportion of Survived:\",sum(titanic['Survived']==1)\/len(titanic['Survived']))","ba6a76cc":"print(\"Proportion of NOT Survived:\",sum(titanic['Survived']==0)\/len(titanic['Survived']))","f2142ac7":"titanic['Sex'].value_counts()","b12f5aeb":"titanic.groupby('Sex').Survived.value_counts()","d46e8613":"titanic['Pclass'].value_counts()","a3b7f522":"titanic.groupby('Pclass').Survived.value_counts()","5a1d1f3b":"titanic[['Pclass','Survived']].groupby('Pclass',as_index=False).mean()","5058cb9c":"titanic[['Sex','Survived']].groupby('Sex',as_index=False).mean()","4374fef6":"sns.barplot('Sex','Survived',data=titanic)","c9f24497":"sns.barplot('Pclass','Survived',data=titanic)","f818b502":"titanic['Embarked'].value_counts()","d4cf620c":"titanic.groupby('Embarked').Survived.value_counts()","23d78410":"titanic[['Embarked','Survived']].groupby('Embarked',as_index=False).mean()","c2ff4477":"sns.barplot('Embarked','Survived',data=titanic)","33020410":"titanic['Parch'].value_counts()","09881ca4":"titanic.groupby('Parch').Survived.value_counts()","40014dd7":"titanic[['Parch','Survived']].groupby('Parch',as_index=False).mean()","28abaa45":"sns.barplot('Parch','Survived',data=titanic,ci=None)","175fb4b0":"titanic['SibSp'].value_counts()","be13eafb":"titanic.groupby('SibSp').Survived.value_counts()","6fbca200":"titanic[['SibSp','Survived']].groupby('SibSp',as_index=False).mean()","37bf36ab":"sns.barplot('SibSp','Survived',data=titanic)","b224dbea":"plt.figure(figsize=(15,6))\nplt.subplot(1,3,1)\nsns.violinplot('Sex','Age',data=titanic,hue='Survived',split=True)\nplt.subplot(1,3,2)\nsns.violinplot('Pclass','Age',data=titanic,hue='Survived',split=True)\nplt.subplot(1,3,3)\nsns.violinplot('Embarked','Age',data=titanic,hue='Survived',split=True)","3ceebefe":"dataframe = pd.concat([titanic,titanic_test])","23441e37":"## map gender fields\ndataframe['Sex'] = dataframe['Sex'].map({'female':1,'male':0})\ndataframe.head()","bee36fe8":"dataframe['Embarked'].unique()","92aea777":"dataframe['Embarked'].value_counts()","7fe165f3":"### fill with mode value\ndataframe['Embarked'] = dataframe['Embarked'].fillna('S')","69735513":"dataframe['Embarked'].unique()","3e5ea90b":"### mapping \ndataframe['Embarked'] = dataframe['Embarked'].map({'S':0,'C':1,'Q':2})","62af290c":"dataframe.head()","551ccb81":"sns.boxplot(dataframe['Age'])","8d12448d":"sns.boxplot(dataframe['Fare'])","a5dbd409":"## extract title from name\ndataframe['Title'] = dataframe['Name'].str.extract('([A-Za-z]+\\.)')","b731239c":"dataframe.head()","7948e8bf":"dataframe['Title'].unique()","6983ef26":"### mapping\ndataframe['Title'] = dataframe['Title'].replace(['Don.','Major.','Sir.', 'Col.', 'Capt.','Jonkheer.'],'Mr.')\ndataframe['Title'] = dataframe['Title'].replace(['Dona.','Lady.', 'Countess.'],'Mrs.')\ndataframe['Title'] = dataframe['Title'].replace(['Ms.', 'Mlle.', 'Mme.'],'Miss.')\ndataframe['Title'].unique()","c70895b7":"### mapping\ndataframe['Title'] = dataframe['Title'].map({'Mr.':1,'Mrs.':2,'Miss.':3,'Master.':4,'Rev.':5,'Dr.':6})","2bac0ea7":"dataframe.isnull().sum()","36b7b900":"dataframe.head()","15a5d13a":"### new family size feature creation\ndataframe['FamilySize'] = dataframe['SibSp'] +  dataframe['Parch'] + 1\ndataframe.isnull().sum()","44d8aae5":"### new feature creation\ndataframe['Ticket_N'] = dataframe['Ticket'].apply(lambda x: 1 if x.isnumeric() else 0)\ndataframe['Ticket_L'] = dataframe['Ticket'].apply(lambda x: ''.join(x.split(' ')[:-1]).replace('.','').replace('\/','').lower() if len(x.split(' ')[:-1]) >0 else 0)\ndataframe.head()","5b215bf4":"### missing value treatment\ndataframe['Age']=dataframe['Age'].fillna(dataframe['Age'].median())","d2daba99":"### handling age columns and creating brackets\n\ndataframe.loc[(dataframe['Age']<=10),'Age'] = 0\ndataframe.loc[(dataframe['Age']>10) & (dataframe['Age']<=15) ,'Age'] = 1\ndataframe.loc[(dataframe['Age']>15) & (dataframe['Age']<=20) ,'Age'] = 2\ndataframe.loc[(dataframe['Age']>20) & (dataframe['Age']<=25) ,'Age'] = 3\ndataframe.loc[(dataframe['Age']>25) & (dataframe['Age']<=30) ,'Age'] = 4\ndataframe.loc[(dataframe['Age']>30) & (dataframe['Age']<=35) ,'Age'] = 5\ndataframe.loc[(dataframe['Age']>35) & (dataframe['Age']<=40) ,'Age'] = 6\ndataframe.loc[(dataframe['Age']>40) & (dataframe['Age']<=45) ,'Age'] = 7\ndataframe.loc[(dataframe['Age']>45),'Age'] = 8","1219b65b":"## handling fare column and creating brackets\ndataframe['Fare'] = dataframe['Fare'].fillna(dataframe['Fare'].median()).astype(int)\n\ndataframe.loc[(dataframe['Fare']<=2),'Fare'] = 0\ndataframe.loc[(dataframe['Fare']>2) & (dataframe['Fare']<=5) ,'Fare'] = 2\ndataframe.loc[(dataframe['Fare']>5) & (dataframe['Fare']<=8) ,'Fare'] = 3\ndataframe.loc[(dataframe['Fare']>8) & (dataframe['Fare']<=15) ,'Fare'] = 4\ndataframe.loc[(dataframe['Fare']>15) & (dataframe['Fare']<=50) ,'Fare'] = 5\ndataframe.loc[(dataframe['Fare']>50),'Fare'] = 6","61bd3115":"#handling cabin column for missing value\ndataframe['Cabin'] = dataframe['Cabin'].fillna('Missing')\ndataframe['Cabin'] = dataframe['Cabin'].str[:1]\n","db739bd2":"dataframe.head()","a5986c9e":"dataframe['Cabin'].unique()","4bf8aa2b":"### and creating brackets\nCabin_mapping = {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4,\"E\": 5,\"F\": 6,\"G\": 7,\"M\": 8,\"T\":9 }\ndataframe['Cabin'] = dataframe['Cabin'].map(Cabin_mapping)","3f338628":"#create IsAlone column\nfamily_map = {1: 'Alone', 2: 'Small', 3: 'Small', 4: 'Small', 5: 'Medium', 6: 'Medium', 7: 'Large', 8: 'Large', 11: 'Large'}\ndataframe['FamilySize_Bracket'] = dataframe['FamilySize'].map(family_map)\ndataframe['IsAlone'] = dataframe['FamilySize'].map(lambda s: 1 if s == 1 else 0)","73bfce45":"# Extracting surnames from Name\ndataframe['Last_Name'] = dataframe['Name'].apply(lambda x: str.split(x, \",\")[0])\ndataframe.head()","6ec40709":"DEFAULT_SURVIVAL_VALUE = 0.5\ndataframe['Family_Survival'] = DEFAULT_SURVIVAL_VALUE\n\nfor grp, grp_df in dataframe[['Survived','Name', 'Last_Name', 'Fare', 'Ticket', 'PassengerId',\n                           'SibSp', 'Parch', 'Age', 'Cabin']].groupby(['Last_Name', 'Fare']):\n    \n    if (len(grp_df) != 1):\n        # A Family group is found.\n        for ind, row in grp_df.iterrows():\n            smax = grp_df.drop(ind)['Survived'].max()\n            smin = grp_df.drop(ind)['Survived'].min()\n            passID = row['PassengerId']\n            if (smax == 1.0):\n                dataframe.loc[dataframe['PassengerId'] == passID, 'Family_Survival'] = 1\n            elif (smin==0.0):\n                dataframe.loc[dataframe['PassengerId'] == passID, 'Family_Survival'] = 0\n                \nfor _, grp_df in dataframe.groupby('Ticket'):\n    if (len(grp_df) != 1):\n        for ind, row in grp_df.iterrows():\n            if (row['Family_Survival'] == 0) | (row['Family_Survival']== 0.5):\n                smax = grp_df.drop(ind)['Survived'].max()\n                smin = grp_df.drop(ind)['Survived'].min()\n                passID = row['PassengerId']\n                if (smax == 1.0):\n                    dataframe.loc[dataframe['PassengerId'] == passID, 'Family_Survival'] = 1\n                elif (smin==0.0):\n                    dataframe.loc[dataframe['PassengerId'] == passID, 'Family_Survival'] = 0\n                        \n\nsns.catplot(x=\"FamilySize\",y=\"Survived\",data = dataframe.iloc[:dataframe_len],kind=\"bar\")","3062b7f3":"#### encoding \nencoder = LabelEncoder()\ndataframe.FamilySize_Bracket=encoder.fit_transform(dataframe.FamilySize_Bracket)","472af22c":"#remove unwanted columns from dataframe\ndataframe.drop(labels=['Name', 'PassengerId', 'Ticket', 'Last_Name','Ticket_L'], axis=1, inplace=True)","62b1287b":"### now time to separate train and test data\ntitanic = dataframe[:891]\ntitanic_test = dataframe[891:]","00b65fd8":"titanic_test.tail()","b6dccf63":"titanic.head()","eb24ce7c":"X_train = titanic.drop('Survived',axis=1)\ny_train = titanic['Survived']\nX_test = titanic_test.drop(['Survived'],axis=1).copy()","7c55b346":"print(X_train.shape)   \nprint(y_train.shape)    \nprint(X_test.shape)","b1cefec1":"from sklearn.linear_model import LogisticRegression\nlr = LogisticRegression()\nlr.fit(X_train,y_train)\ny_pred = lr.predict(X_test)\nscore = lr.score(X_train, y_train)\nscore","aafc4092":"from sklearn.svm import SVC, LinearSVC\nsvc = SVC()\nsvc.fit(X_train,y_train)\ny_pred_svc = svc.predict(X_test)\nscore = svc.score(X_train, y_train)\nscore","b5fbd960":"lnsvc = LinearSVC()\nlnsvc.fit(X_train,y_train)\ny_pred_lnsvc = lnsvc.predict(X_test)\nscore = lnsvc.score(X_train, y_train)\nscore","41182759":"dtc = DecisionTreeClassifier()\ndtc.fit(X_train,y_train)\ny_pred_dtc = dtc.predict(X_test)\nscore = dtc.score(X_train, y_train)\nscore","266b7149":"rfc = RandomForestClassifier(n_estimators=100)\nrfc.fit(X_train,y_train)\ny_pred_rfc = rfc.predict(X_test)\nscore = rfc.score(X_train, y_train)\nscore","20e284b0":"#simple performance reporting function\ndef clf_performance(classifier, model_name):\n    print(model_name)\n    print('Best Score: ' + str(classifier.best_score_))\n    print('Best Parameters: ' + str(classifier.best_params_))","1f79f64e":"rf = RandomForestClassifier(random_state = 1)\nkfold = StratifiedKFold(n_splits=8)\nparam_grid =  {'n_estimators': [100],\n               'criterion':['gini'],\n                                  'bootstrap': [True],\n                                  'max_depth': [4],\n                                  'max_features': ['sqrt'],\n                                  'min_samples_leaf': [4],\n                                  'min_samples_split': [2]}\n                                  \nclf_rf = GridSearchCV(rf, param_grid = param_grid, cv = kfold, verbose = True, n_jobs = -1)\nbest_clf_rf = clf_rf.fit(X_train,y_train)\ny_hat_rf_grid = best_clf_rf.best_estimator_.predict(X_test).astype(int)    ### predict\nclf_performance(best_clf_rf,'Random Forest')","5d4fb0ca":"import xgboost\nclassifier = xgboost.XGBClassifier(booster='gbtree',verbose=0,learning_rate=0.1,max_depth=10,objective='binary:logistic',\n                  n_estimators=1000,seed=2)\nclassifier.fit(X_train, y_train)\n# Predicting the Test set results\ny_pred_XGB = classifier.predict(X_test)\nacc_XGB = round( classifier.score(X_train, y_train) * 100, 2)\nprint (\"Train Accuracy: \" + str(acc_XGB) + '%')\ny_pred_XGB.shape","31178cc2":"#### using kfold gridserch\nfrom xgboost import XGBClassifier\nxgb = XGBClassifier(random_state =1)\nkfold = StratifiedKFold(n_splits=8)\n\nxgb_param_grid_best = {'learning_rate':[0.1], \n                  'reg_lambda':[0.3],\n                  'gamma': [1],\n                  'subsample': [0.8],\n                  'max_depth': [2],\n                  'n_estimators': [300]\n              }\n\ngs_xgb = GridSearchCV(xgb, param_grid = xgb_param_grid_best, cv=kfold, n_jobs= -1, verbose = 1)\n\ngs_xgb.fit(X_train,y_train)\ny_hat_gs_xgb = gs_xgb.predict(X_test).astype(int)   ## predict\n\nxgb_best = gs_xgb.best_estimator_\nprint(f'XGB GridSearch best params: {gs_xgb.best_params_}')\nprint(f'XGB GridSearch best score: {gs_xgb.best_score_}')","921ddf4c":"from lightgbm import LGBMClassifier\n\nLGB=LGBMClassifier(boosting_type='gbdt', max_depth=10, learning_rate=0.1, objective='binary', reg_alpha=0,\n                  reg_lambda=1, n_jobs=-1, random_state=100, n_estimators=1000)\n\nmodel = LGB.fit(X_train,y_train)\ny_pred_LGB = model.predict(X_test)\n#rounding the values\ny_pred_LGB = y_pred_LGB.round(0)\n#converting from float to integer\ny_pred_LGB = y_pred_LGB.astype(int)\nacc_LGB = round( model.score(X_train, y_train) * 100, 2)\nprint (\"Train Accuracy: \" + str(acc_LGB) + '%')","48c941fc":"from catboost import CatBoostClassifier\n\nCATB=CatBoostClassifier(learning_rate=0.05,depth=8,boosting_type='Plain',eval_metric='Accuracy',n_estimators=1000,random_state=294)\nCATB.fit(X_train,y_train)\n\n# Predicting the Test set results\ny_pred_CATB = CATB.predict(X_test)\nacc_CATB = round(CATB.score(X_train, y_train) * 100, 2)\nprint (\"Train Accuracy: \" + str(acc_CATB) + '%')","0e48fd49":"d=pd.DataFrame()\nd=pd.concat([d,pd.DataFrame(gs_xgb.predict(X_test).astype(int)),pd.DataFrame(best_clf_rf.best_estimator_.predict(X_test).astype(int)),pd.DataFrame(CATB.predict(X_test).astype(int))],axis=1)\nd.columns=['1','2','3']\n\nre=d.mode(axis=1)[0]\nre.head()","e36c760f":"submission = pd.DataFrame({\n        \"PassengerId\": test[\"PassengerId\"],\n        \"Survived\": y_hat_rf_grid              ### prediting using random forest model\n    })\n\nsubmission.to_csv('Titanic_submission.csv', index=False)","7e0fb93c":"submission.Survived.value_counts()","ae3ba64f":"# votingC = VotingClassifier(estimators=[('XGB_1',classifier1),('XGB_2',classifier2),('XGB_3',classifier3)], voting='soft', n_jobs=4)\n\n# votingC = votingC.fit(X_train, y_train)","06ffea3c":"# vote = votingC.predict(X_test)\n# submission_v = pd.DataFrame({\n#         \"PassengerId\": titanic_test[\"PassengerId\"],\n#         \"Survived\": vote\n#     })\n\n# submission_v.to_csv('Vote_submission.csv', index=False)","84d77b18":"# submission_v.Survived.value_counts()","908bb09a":"#### Load train data","4a648bd5":"### Lightboost","ce180a69":"### Random Forest Model","5c0e66d9":"### Tree Models","bd14adfe":"### CATBoost","6e5d612d":"###  Storing prediction for test data ","d585de05":"### Logistics Regression","1a150776":"### concatenate train and test data for easy imputation of missing values","ad23acdf":"#### Load test data","7a49d2c9":"## Titanic Disaster Survival Prediction - This Notebook will place you into TOP 4% of total submissions.","4859e5e3":"#### identifying survival rate","e253e932":"### SVM","3d53b46a":"### EDA","6903f4a3":"#### Ensemble of three models","4e68ca1c":"### Boosting models"}}