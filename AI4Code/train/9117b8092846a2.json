{"cell_type":{"d2a5f1c5":"code","aa413e7c":"code","1f667477":"code","0a8f955c":"code","e5f4614d":"code","8cdda201":"code","f30d4c61":"code","262af81f":"code","1db7f02e":"code","b8e3082b":"code","2891a992":"code","739546b6":"code","e11a0971":"code","6dadd844":"code","e58fba3b":"code","f77ff2cb":"code","5e87753f":"code","fa007a2d":"code","eb0a843f":"code","732c99a4":"code","123e3833":"code","310655a4":"code","9eda7464":"code","bd1f9d70":"code","b680a78b":"code","893a2d01":"code","275226a0":"code","b6411b54":"code","710a030b":"code","d3fb2a3e":"code","4de4eb95":"markdown","6edb89db":"markdown","c39c0ce8":"markdown","808df554":"markdown","5baa5cee":"markdown","b6fe2325":"markdown","00287364":"markdown","d6a02f3a":"markdown","0be8a23b":"markdown","4dc72c5d":"markdown","ebf7bbb2":"markdown","5f938814":"markdown","0dcec7ea":"markdown","a4d0a938":"markdown","1cde30fe":"markdown","2bbca8dd":"markdown","2cefe45e":"markdown","b1e6feee":"markdown","7333e379":"markdown","3e5bd259":"markdown"},"source":{"d2a5f1c5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","aa413e7c":"mit_test = pd.read_csv('\/kaggle\/input\/heartbeat\/mitbih_test.csv',header=None)\nmit_train = pd.read_csv('\/kaggle\/input\/heartbeat\/mitbih_train.csv', header=None)\nptb_abnormal = pd.read_csv('\/kaggle\/input\/heartbeat\/ptbdb_abnormal.csv', header=None)\nptb_normal = pd.read_csv('\/kaggle\/input\/heartbeat\/ptbdb_normal.csv', header=None)","1f667477":"mit_test.head()","0a8f955c":"mit_train.head()","e5f4614d":"ptb_abnormal.head()","8cdda201":"ptb_normal.head()","f30d4c61":"mit_test.rename(columns={187:\"Class\"}, inplace=True)\nmit_train.rename(columns={187:\"Class\"}, inplace=True)\nptb_abnormal.rename(columns={187:\"Class\"}, inplace=True)\nptb_normal.rename(columns={187:\"Class\"}, inplace=True)","262af81f":"print (\"MIT Train classes: \\n\", mit_train[\"Class\"].value_counts())\nprint (\"\\nMIT Test classes: \\n\", mit_test[\"Class\"].value_counts())\nprint (\"\\nPTB Abnormal classes: \\n\", ptb_abnormal[\"Class\"].value_counts())\nprint (\"\\nPTB Normal classes: \\n\", ptb_normal[\"Class\"].value_counts())","1db7f02e":"# Setting Dictionary to define the type of Heartbeat for both datasets\nMIT_Outcome = {0. : 'Normal Beat',\n               1. : 'Supraventricular premature beat',\n               2. : 'Premature ventricular contraction',\n               3. : 'Fusion of ventricular and normal beat',\n               4. : 'Unclassifiable beat'}\nPTB_Outcome = {0. : 'Normal',\n               1. : 'Abnormal'}","b8e3082b":"#Plotting 10 random samples from the MIT training dataset with their classification\nplt.figure(figsize=(25,10))\nnp_count = np.linspace(0,186,187)\nnp_time = np.tile(np_count,(10,1))\nrnd = np.random.randint(0,mit_train.shape[0],size=(10,))\n\n\nfor i in range(np_time.shape[0]):\n    ax = plt.subplot(2,5,i+1)\n    ax.plot(mit_train.iloc[rnd[i],np_time[i,:]])\n    ax.set_title(MIT_Outcome[mit_train.loc[rnd[i],'Class']])\n\nplt.show()\n","2891a992":"#Plotting 10 random samples from the PTB training dataset with their classification\nplt.figure(figsize=(25,10))\nrnd = np.random.randint(0,ptb_normal.shape[0],size=(5,))\nrnd1 = np.random.randint(0,ptb_abnormal.shape[0], size=(5,))\n\n\nfor i in range(np_time.shape[0]):\n    ax = plt.subplot(2,5,i+1)\n    if (i < 5):\n        ax.plot(ptb_normal.iloc[rnd[i],np_time[i,:]])\n        ax.set_title(PTB_Outcome[ptb_normal.loc[rnd[i],'Class']])\n    else:\n        ax.plot(ptb_abnormal.iloc[rnd1[i-5],np_time[i,:]])\n        ax.set_title(PTB_Outcome[ptb_abnormal.loc[rnd1[i-5],'Class']])\n\nplt.show()","739546b6":"from sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.preprocessing import normalize\nfrom sklearn.svm import SVC \nfrom sklearn.decomposition import PCA\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics import classification_report\n\nptb_full = pd.concat([ptb_normal, ptb_abnormal], axis=0).reset_index()\nptb_full.drop(columns='index', inplace=True)\nptb_full = ptb_full.sample(ptb_full.shape[0], random_state=42)\nlearn_ptb, test_ptb, out_learn_ptb, out_test_ptb = train_test_split(ptb_full.iloc[:,:187], ptb_full.iloc[:,-1], test_size=0.15, random_state=42)\ntrain_ptb, valid_ptb, out_train_ptb, out_valid_ptb = train_test_split(learn_ptb, out_learn_ptb, test_size=0.2, random_state=42 )","e11a0971":"print(\"Traing dataset size: \", train_ptb.shape)\nprint(\"Validation dataset size: \", valid_ptb.shape)\nprint(\"Test dataset size: \", test_ptb.shape)","6dadd844":"#Normalizing the training & test data \ntrain_ptb = normalize(train_ptb, axis=0, norm='max')\nvalid_ptb = normalize(valid_ptb, axis=0, norm='max')\ntest_ptb = normalize(test_ptb, axis=0, norm='max')","e58fba3b":"# validating that the training data has a sample from both classess\nnp.unique(out_train_ptb)","f77ff2cb":"#Looking at the plots we can see that there are a lot \"zero\" values which will not likely help our classification.  Eyeballing the data I chose 100 features to keep.\nsvc = SVC(kernel='rbf', class_weight='balanced')\n\nparam_grid = {'C': [1, 5, 10]}\ngrid_svc = GridSearchCV (svc, param_grid, verbose=2, scoring='f1_micro')\n\n# Train the grid of models. Time this process.\n%time grid_svc.fit(train_ptb, out_train_ptb)\n\n# Print the parameters which yield the best model performance\nprint (grid_svc.best_estimator_)","5e87753f":"# Selecting the best parameters from the previos GridSearchCV and predicting values on our validation set.\nsvc = grid_svc.best_estimator_\npred_svc = svc.predict(valid_ptb)\n\n\nprint(classification_report(out_valid_ptb, pred_svc, target_names=[PTB_Outcome[i] for i in PTB_Outcome]))","fa007a2d":"#validating that the predictions contained both classes\nnp.unique(pred_svc)","eb0a843f":"forest = ExtraTreesClassifier (criterion='entropy', max_samples=10, class_weight='balanced', random_state=42)\n\nparam_grid = {'n_estimators': [10, 20, 30],\n             'max_depth' : [5, 10, 15, 20]}\ngrid_forest = GridSearchCV(forest, param_grid, scoring='f1_micro', verbose=2)\n\ngrid_forest.fit(train_ptb, out_train_ptb)\n\nprint(grid_forest.best_params_)","732c99a4":"# loading the best estimator from the GridSearchCV into our model\nforest = grid_forest.best_estimator_\n\n# predicting the outcome by using the best model\npred_forest = forest.predict(valid_ptb)\nprint(classification_report(out_valid_ptb, pred_forest, target_names=[PTB_Outcome[i] for i in PTB_Outcome]))","123e3833":"# Validating that the model wasn't able to predict any record as normal\nnp.unique(pred_forest)","310655a4":"logistic = LogisticRegression(random_state=42, class_weight='balanced', max_iter=1000)\n#clf_log = make_pipeline(pca, logistic)\n\nlogistic.fit(train_ptb, out_train_ptb)\npred_log = logistic.predict(valid_ptb)\nprint(classification_report(out_valid_ptb, pred_log, target_names=[PTB_Outcome[i] for i in PTB_Outcome]))","9eda7464":"from sklearn.ensemble import GradientBoostingClassifier\n\ngradboost = GradientBoostingClassifier(learning_rate=0.5, max_depth=8, max_features=0.1, \n                                       min_samples_leaf=4, min_samples_split=15, n_estimators=100, \n                                       subsample=0.9000000000000001)\ngradboost.fit(train_ptb, out_train_ptb)\npred_gradboost = gradboost.predict(valid_ptb)\n\nprint(classification_report(out_valid_ptb, pred_gradboost, target_names=[PTB_Outcome[i] for i in PTB_Outcome]))","bd1f9d70":"# Since the MIT dataset already comes as a train set and test set, we just split 20% of the training set for validation\ntrain_mit, valid_mit, out_train_mit, out_valid_mit = train_test_split(mit_train.iloc[:,:187], mit_train.iloc[:,-1], test_size=0.20, random_state=42)\n\n#we remove the targets from the test set\ntest_mit, out_test_mit = mit_test.iloc[:,:187], mit_test.iloc[:,-1]\n\n#Normalizing the training & test data \ntrain_mit = normalize(train_mit, axis=0, norm='max')\nvalid_mit = normalize(valid_mit, axis=0, norm='max')\ntest_mit = normalize(test_ptb, axis=0, norm='max')","b680a78b":"#Looking at the plots we can see that there are a lot \"zero\" values which will not likely help our classification.  Eyeballing the data I chose 100 features to keep.\nsvc = SVC(kernel='rbf', class_weight='balanced')\n\nparam_grid = {'C': [1, 5, 10]}\ngrid_svc = GridSearchCV (svc, param_grid, verbose=2, scoring='f1_micro')\n\n# Train the grid of models. Time this process.\n%time grid_svc.fit(train_mit, out_train_mit)\n\n# Print the parameters which yield the best model performance\nprint (grid_svc.best_estimator_)","893a2d01":"# Selecting the best parameters from the previos GridSearchCV and predicting values on our validation set.\nsvc = grid_svc.best_estimator_\npred_svc_mit = svc.predict(valid_mit)\n\nprint(classification_report(out_valid_mit, pred_svc_mit, target_names=[MIT_Outcome[i] for i in MIT_Outcome]))","275226a0":"forest_mit = ExtraTreesClassifier (criterion='entropy', max_samples=10, class_weight='balanced', random_state=42)\n\nparam_grid = {'n_estimators': [10, 20, 30],\n             'max_depth' : [5, 10, 15, 20]}\ngrid_forest_mit = GridSearchCV(forest_mit, param_grid, scoring='f1_micro', verbose=2)\n\ngrid_forest_mit.fit(train_mit, out_train_mit)\n\nprint(grid_forest_mit.best_params_)","b6411b54":"# loading the best estimator from the GridSearchCV into our model\nforest_mit = grid_forest_mit.best_estimator_\n\n# predicting the outcome by using the best model\npred_forest_mit = forest_mit.predict(valid_mit)\nprint(classification_report(out_valid_mit, pred_forest_mit, target_names=[MIT_Outcome[i] for i in MIT_Outcome]))","710a030b":"logistic_mit = LogisticRegression(random_state=42, class_weight='balanced', max_iter=10000)\n#clf_log = make_pipeline(pca, logistic)\n\nlogistic_mit.fit(train_mit, out_train_mit)\npred_log_mit = logistic_mit.predict(valid_mit)\nprint(classification_report(out_valid_mit, pred_log_mit, target_names=[MIT_Outcome[i] for i in MIT_Outcome]))","d3fb2a3e":"from sklearn.ensemble import GradientBoostingClassifier\n\ngradboost_mit = GradientBoostingClassifier(learning_rate=0.5, max_depth=8, max_features=0.1, \n                                       min_samples_leaf=4, min_samples_split=15, n_estimators=100, \n                                       subsample=0.9000000000000001)\ngradboost_mit.fit(train_mit, out_train_mit)\npred_gradboost_mit = gradboost_mit.predict(valid_mit)\n\nprint(classification_report(out_valid_mit, pred_gradboost_mit, target_names=[MIT_Outcome[i] for i in MIT_Outcome]))","4de4eb95":"### GradientBoostingClassifier:\n\nAutoML has recommeded a very high performing model. It would be very difficult to beat, Deep Learning might be able to produce a better performing model but would the minimal gains in results come with an acceptable performance hit?","6edb89db":"## SVM observations:\n\nThe SVM model performed quite well with F1 score of 0.91 (for Normal) and 0.96 (for Abnormal) considering that the data was imblalanced.  The overall accuracy was 95% which is also impressive.  I don't believe there is anything tha would stop us from using such a model but lets see if other models can outperform it.","c39c0ce8":"# Generating Plots of some of the samples in the dataset","808df554":"# Running SVM\n\nWe use a GridSearchCV to find the bets parameters for SVM model with F1 micro scoring (F1 score \"weighted\" based on the data, so that the imbalanced data doesn't skew it towards the more abundant class)","5baa5cee":"########  PTB_Data_Classifier.Py File content ########\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.model_selection import train_test_split\n\n#NOTE: Make sure that the outcome column is labeled 'target' in the data file\ntpot_data = pd.read_csv('PATH\/TO\/DATA\/FILE', sep='COLUMN_SEPARATOR', dtype=np.float64)\nfeatures = tpot_data.drop('target', axis=1)\ntraining_features, testing_features, training_target, testing_target = train_test_split(features, tpot_data['target'], random_state=42)\n\n#Average CV score on the training set was: 0.9780697321879737\nexported_pipeline = GradientBoostingClassifier(learning_rate=0.5, max_depth=8, max_features=0.1, min_samples_leaf=4, min_samples_split=15, n_estimators=100, subsample=0.9000000000000001)\n\n#Fix random state in exported estimator\nif hasattr(exported_pipeline, 'random_state'):\n    setattr(exported_pipeline, 'random_state', 42)\n\nexported_pipeline.fit(training_features, training_target)\n\nresults = exported_pipeline.predict(testing_features)\n\n\n########  End of File content ########","b6fe2325":"# Running GradientBoostingClassifier\n\nThis time we're not going to run AutoML as its very time consuming and specially with 5 classes so we're just going to run it as the PTB dataset and see how it fares.","00287364":"# Running SVM\n\nWe use a GridSearchCV to find the bets parameters for SVM model with F1 micro scoring (F1 score \"weighted\" based on the data, so that the imbalanced data doesn't skew it towards the more abundant class)","d6a02f3a":"# Experimenting with Classifiers for PTB Dataset","0be8a23b":"# Running Logistic Regression\n\nNow we run the standard Logistic Regression model, our intuition is that it would perform well since it will take the data as is (without randomization) and just try to predict an outcome.  The results should be comparable to SVM","4dc72c5d":"# Running TPOTClassifier to determine best algorithm\n### This part of the code takes roughly 3.5-4 hours to run, it has been commented out to avoid the long run times.  \n#The results are below, you can convert this cell from markdown to code to run it if desired\n\n#===================    Begin Code here ======================================\nfrom tpot import TPOTClassifier\n\ntpot = TPOTClassifier (generations=5, population_size=40, verbosity=2, random_state=42, scoring='f1_micro')\ntpot.fit(train_ptb, out_train_ptb)\n\n#evaluate the classifier against the validation set\nprint(tpot.score(valid_ptb, out_valid_ptb))\n\n#export the model to a file\ntpot.export('PTB_Data_Classifier.py')\n\n#===================   End Code here ==========================================","ebf7bbb2":"### Logistic Regression observation:\n\nThe Logistic Regression model so far has been the poorest performing model out of the 3 evaluated so far.\n","5f938814":"# Running GradientBosstingClassifier\n\nFinally lets run the GradientBosstingClassifier that AutoML has recommended for us and see what we observer.  We're expecting this to be our best performing model so far.","0dcec7ea":"Looking at how many classes are there in each dataset\nThe MIT dataset has 5 clases:\n* 0 = N  (Normal Beat)\n* 1 = S  (Supraventricular premature beat)\n* 2 = V  (Premature ventricular contraction)\n* 3 = F  (Fusion of ventricular and normal beat)\n* 4 = Q  (Unclassifiable beat)\n\nCompared to the PTB dataset which is 1 for abnormal and 0 for normal\n","a4d0a938":"# Running ExtraTreesClassifier\n\nConsidering that this is a time series dataset and how the prior value impacts the current value our intuition is that this model would perform badly as \"randomly\" selecting features and making decisions based on these values would make for an archiac model.","1cde30fe":"======================== OUTPUT =============================\n\nGeneration 1 - Current best internal CV score: 0.9667508842849925\n\nGeneration 2 - Current best internal CV score: 0.9710965133906013\n\nGeneration 3 - Current best internal CV score: 0.9751389590702374\n\nGeneration 4 - Current best internal CV score: 0.9755432036382011\n\nGeneration 5 - Current best internal CV score: 0.9780697321879737\n\n\nBest pipeline: GradientBoostingClassifier(input_matrix, learning_rate=0.5, max_depth=8, max_features=0.1, min_samples_leaf=4, min_samples_split=15, n_estimators=100, subsample=0.9000000000000001)\n\n0.9773645917542442\n\n\n\n\n\n================== END OF OUTPUT =============================","2bbca8dd":"# Loading the data and exploring its shape and values","2cefe45e":"# Analayzing the MIT Heartbeat Data\nNow we repeat the same analysis with the different dataset and tweak accordingly","b1e6feee":"# Running Logistic Regression\n\u200b\nNow we run the standard Logistic Regression model, our intuition is that it would perform well since it will take the data as is (without randomization) and just try to predict an outcome.  The results should be comparable to SVM","7333e379":"# Running ExtraTreesClassifier\n\nConsidering that this is a time series dataset and how the prior value impacts the current value our intuition is that this model would perform badly as \"randomly\" selecting features and making decisions based on these values would make for an archiac model.","3e5bd259":"## ExtraTreesClassifier Observation\n\nOut intution was quite off and the model did even better than SVM.  The resuls are even more impressive with an F1 score of 0.94 (for Normal) and 0.98 (for Abnormal), this is setting the bar quite high so lets see if any other model can outperform it."}}