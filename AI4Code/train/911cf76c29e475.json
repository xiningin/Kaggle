{"cell_type":{"64ce26b5":"code","fab3171f":"code","1118b57a":"code","3506997f":"code","e39df70a":"code","38f0da33":"code","273b1998":"code","a9a31531":"code","00f26f28":"code","e9f97c34":"code","e5eafd62":"code","fbee6096":"code","9a9a21de":"code","f0bc0d33":"code","6aaffebf":"code","ec3ead68":"code","57d8e444":"code","75062cb6":"code","2d65ee9b":"markdown","7165435e":"markdown","4fd84566":"markdown","b8bff652":"markdown","6a13612a":"markdown","9222cc23":"markdown"},"source":{"64ce26b5":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nfrom tensorflow.keras.layers import Input,Conv2D,Dense,Flatten,Dropout\nfrom tensorflow.keras.models import Model","fab3171f":"cifar_10=tf.keras.datasets.cifar10","1118b57a":"(x_train,y_train),(x_test,y_test)=cifar_10.load_data()","3506997f":"x_train.shape,y_train.shape,x_test.shape,y_test.shape","e39df70a":"##AS WE KNOW THAT EACH PIXEL PRESENT IN THE IMAGE HAS A VALUE BETWEEN 0-255 THERE WHAT WE ARE DOING IS THAT WE DIVIDE IT BY 255.0 AND THEREBY WE NORMALIZE IT","38f0da33":"x_train,x_test=x_train\/255.0,x_test\/255.0","273b1998":"x_train.shape","a9a31531":"x_train","00f26f28":"y_train,y_test=y_train.flatten(),y_test.flatten()\n","e9f97c34":"y_train.shape","e5eafd62":"K=len(set(y_train))\nprint(\"The no of unique classes:\",K)","fbee6096":"i=Input(shape=x_train[0].shape)\nx=Conv2D(32,(3,3),strides=2,activation='relu')(i)\nx=Conv2D(64,(3,3),strides=2,activation='relu')(x)\nx=Conv2D(128,(3,3),strides=2,activation='relu')(x)\nx=Flatten()(x)\nx=Dropout(0.2)(x)\nx=Dense(1024,activation='relu')(x)\nx=Dropout(0.2)(x)\nx=Dense(K,activation='softmax')(x)\n\nmodel=Model(i,x)\n","9a9a21de":"model.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\nr=model.fit(x_train,y_train,validation_data=(x_test,y_test),epochs=15)","f0bc0d33":"from sklearn.metrics import confusion_matrix\nimport itertools\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n  if normalize:\n      cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n      print(\"Normalized confusion matrix\")\n  else:\n      print('Confusion matrix, without normalization')\n\n  print(cm)\n\n  plt.imshow(cm, interpolation='nearest', cmap=cmap)\n  plt.title(title)\n  plt.colorbar()\n  tick_marks = np.arange(len(classes))\n  plt.xticks(tick_marks, classes, rotation=45)\n  plt.yticks(tick_marks, classes)\n\n  fmt = '.2f' if normalize else 'd'\n  thresh = cm.max() \/ 2.\n  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n      plt.text(j, i, format(cm[i, j], fmt),\n               horizontalalignment=\"center\",\n               color=\"white\" if cm[i, j] > thresh else \"black\")\n\n  plt.tight_layout()\n  plt.ylabel('True label')\n  plt.xlabel('Predicted label')\n  plt.show()\n\n\np_test = model.predict(x_test).argmax(axis=1)\ncm = confusion_matrix(y_test, p_test)\nplot_confusion_matrix(cm, list(range(10)))","6aaffebf":"misclassified_idx = np.where(p_test != y_test)[0]\ni = np.random.choice(misclassified_idx)\nplt.imshow(x_test[i], cmap='gray')\nplt.title(\"True label: %s Predicted: %s\" % (y_test[i], p_test[i]));","ec3ead68":"misclassified_idx = np.where(p_test != y_test)[0]\ni = np.random.choice(misclassified_idx)\nplt.imshow(x_test[i], cmap='gray')\nplt.title(\"True label: %s Predicted: %s\" % (y_test[i], p_test[i]));","57d8e444":"misclassified_idx = np.where(p_test != y_test)[0]\ni = np.random.choice(misclassified_idx)\nplt.imshow(x_test[i], cmap='gray')\nplt.title(\"True label: %s Predicted: %s\" % (y_test[i], p_test[i]));","75062cb6":"misclassified_idx = np.where(p_test != y_test)[0]\ni = np.random.choice(misclassified_idx)\nplt.imshow(x_test[i], cmap='gray')\nplt.title(\"True label: %s Predicted: %s\" % (y_test[i], p_test[i]));","2d65ee9b":"**Here are some of the misclassified images**","7165435e":"Now the most interesting step comes which is bulding the model I used the softmax activation function to predict the output because it predicts a multinomial probability distribution ,it also maps the output such that the sum of all outputs is 1, which is very obvious as we have to predict the probability.\n![image.png](attachment:fb834dbc-a345-4275-9e10-13823ff6b23c.png)![image.png](attachment:a289cac4-4e05-4d03-99a0-77e24035ee78.png)\n![image.png](attachment:e053e726-3c1b-4626-97ad-74e8eaf4f186.png)![image.png](attachment:81ca277f-3716-41ed-b543-60a493edbb38.png)","4fd84566":"**AS YOU CAN THE SHAPE OF THE DATASET REMAINS THE SAME BUT THE DATA GETS NORMALIZED AFTER DIVIDING IT BY 255.0**","b8bff652":"**for cnn it accepts a 3d matrix for the cnn operation to work ,it is a black and white image then you should add one dimension at the last position**","6a13612a":"\n**CNN**\n\nHello guys this is my  second  kaggle notebook and consider myself to be a complete beginner in data science and machine learning\n\nThis is a multiclass classifation ( CIFAR-10) and my model has accuracy 90% .\n\n\nThe dataset is already present in the tensorflow library , so there is no need of uploading the file.\n\nSteps involved are:\n\n1.Load in the data cifar10  *it is already included in tensorflow\n\n2.Build the model *convulation and sequential dense layers ending with multiclass logistic regression\n\n3.train the model\n![image.png](attachment:bf6e3eff-adef-4a5c-a75f-0f7910a0b317.png)![image.png](attachment:0a70a210-324b-4151-bb37-c1a768b6ea14.png)","9222cc23":"**CONFUSION MATRIX**"}}