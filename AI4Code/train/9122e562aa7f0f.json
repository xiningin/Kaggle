{"cell_type":{"fe54ca95":"code","99dc22f9":"code","cc4808ed":"code","febcc1f4":"code","b082a073":"code","9ae66ab4":"code","e9b02d12":"code","aeb21991":"code","17b174b1":"code","bdbfcf91":"code","4aa7e920":"code","d7eb197d":"code","68ff131c":"code","f9be6a90":"code","693445ab":"code","0320057d":"code","22c03f8c":"code","84a67b4e":"code","9fe3e1d4":"code","2a563d29":"code","889e44a5":"code","f0e2fe84":"code","39b7fef0":"code","03188027":"code","ac2a6998":"code","d5ff9122":"code","fc337647":"code","ba721ff8":"code","7a36f5eb":"code","b41e234d":"code","9452e645":"code","2d5c3a12":"code","ac601173":"code","bcdf1348":"code","47b568e5":"code","b311814d":"code","919d8b0b":"code","064cf655":"code","7b4ddb63":"code","aa5aa983":"code","a9add59b":"code","5f94ad8f":"code","f9c402f3":"markdown","cfe5f20c":"markdown","5a92dd82":"markdown","24696ce0":"markdown","81e6da0b":"markdown","77e90ca9":"markdown","99badefd":"markdown","a2aa4920":"markdown","9855f631":"markdown","3fcb58fc":"markdown","82fd4032":"markdown","705a8b85":"markdown","f37aabdc":"markdown","2d14195c":"markdown","23d23485":"markdown"},"source":{"fe54ca95":"# Bibliotecas necess\u00e1rias\n# Manipula\u00e7\u00e3o de dados\nimport pandas as pd\n# Redes Neurais\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\nfrom tensorflow.keras.optimizers import RMSprop\n# Plot\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# Avalia\u00e7\u00e3o\nfrom sklearn.metrics import classification_report, confusion_matrix\n","99dc22f9":"# Lendo o dataset Kaggle\ntrain = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\n\n#Alternativa ler do pr\u00f3prio keras\n#(x_train, y_train), (x_test, y_test) = mnist.load_data()\n","cc4808ed":"# Analisando o dataset\nprint(\"Quantidade de elementos de treino: {}\". format(len(train)))\nprint(train.head())","febcc1f4":"# Separando x_train e y_train\nY = train[\"label\"]\nX = train.drop(labels = [\"label\"],axis = 1)\nprint(X.head())\n# Em formato numpy array de imagens 28 x 28\n#x = X.values.reshape(-1,28,28,1)\n#print(x[0])","b082a073":"print(X.shape)","9ae66ab4":"# Numtendi nada!\n# Bora ver com matplotlib\nplt.imshow(X.values[0].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Label: {}'.format(Y[0]))","e9b02d12":"# Transformando a imagem 2d em um numpy array (imagem 28*28)\nx = X.values.reshape(42000, 28, 28, 1)\n\n#Normalizando para valores entre 0 e 1\nx = x.astype('float32')\nx \/= 255\n\n#print(x[0])","aeb21991":"# Vamos ajustar o formato da saida\nnum_classes = 10\n\n# Convertendo para um vetor de saida com 10 dimensoes\n# ex. 8 => [0,0,0,0,0,0,0,0,1,0]\ny = keras.utils.to_categorical(Y, num_classes)\nprint(y[0])","17b174b1":"# Separando uma parte para treino (90%) e outra para valida\u00e7\u00e3o (10%)\nfrom sklearn.model_selection import train_test_split\nx_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.1, random_state=5)\nprint('Qtde de treino: {}'.format(len(x_train)))\nprint('Qtde de valida\u00e7\u00e3o: {}'.format(len(x_val)))","bdbfcf91":"# Criando o modelo Sequential\n# Sequential: Modelo Keras de ir adicionando camadas (como um lego)\n# Conv2D: Camada com kernels (filtros) que percorrem a imagem extraindo caracter\u00edsitcas (mapas de caracte\u00edsticas)\n# MaxPooling2D: Camada que reduz a dimensionalidade dos mapas de caracter\u00edsticas 2D\n# Flatten: Camada que transforma um mapa de caracter\u00edsticas 2D num vetor para classficador final\n# Dense: Camada onde todas as entradas est\u00e3o conectadas em cada neur\u00f4nio (totalmente conectada)\n# Dropout: Camada usa durante treino que descarta aleatoriamente um percentual de conex\u00f5es (reduz overfitting)\n\nmodel = Sequential()\nmodel.add(Conv2D(20, kernel_size=(3, 3),\n                 activation='relu',\n                 input_shape=(28,28,1)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(40, kernel_size=(3,3), activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dense(50, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(num_classes, activation='softmax'))\nmodel.summary()","4aa7e920":"# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy'])","d7eb197d":"# Treina com os parte dos dados\nbatch_size = 32\nepochs = 20\n\n#Salvar o melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n]\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    callbacks = callbacks_list,\n                    verbose=1,\n                    validation_data=(x_val, y_val))","68ff131c":"#Vamos ver como foi o treino?\n\nfig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","f9be6a90":"from tensorflow.keras.models import load_model\n# Load the best saved model\nmodel = load_model('model.h5')","693445ab":"# Testa\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","0320057d":"# Testando uma entrada qualquer\nprint(y_train[10])\nprint(model.predict(x_train[10].reshape((1,28,28,1))))\nprint(model.predict_classes(x_train[10].reshape((1,28,28,1))))","22c03f8c":"import itertools\n\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","84a67b4e":"# Vendo alguns reports# Vendo alguns reports\n# Usando sklearn\nimport numpy as np\n\n# Classificando toda base de teste\ny_pred = model.predict_classes(x_val)\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Confution Matrix\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","9fe3e1d4":"# Gerando sa\u00edda para dataset de teste\n\n#Carrega dataset de teste\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Qtde de testes: {}\".format(len(test)))\n# Bota no formato numpy e normaliza\nx_test = test.values.reshape(len(test),28,28,1)\nx_test = x_test.astype('float32')\nx_test \/= 255\n\n# Faz classifica\u00e7\u00e3o para dataset de teste\ny_pred = model.predict_classes(x_test)\n\n# Verficando algum exemplo\ni = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Previsto: {}'.format(y_pred[i]))\n\n# Botando no formato de sa\u00edda (competi\u00e7\u00e3o Kaggle)\nresults = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(submission.head(10))\n#Salvando Arquivo\nsubmission.to_csv(\"mlp_mnist_v1.csv\",index=False)","2a563d29":"#introduzindo ruido\nimport numpy as np\nmean = 0.\nstddev = 0.2\nnoise = np.random.normal(mean, stddev, (4200, 28, 28,1))\nx_te = x_val + noise\nx_te = np.clip(x_te, 0., 1.)\n\nplt.imshow(x_te.reshape(4200, 28,28)[0], cmap=plt.cm.binary)\nplt.show()\n\n# Testa\nscore = model.evaluate(x_te, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","889e44a5":"# Fixa a semente aleat\u00f3ria para garantir consist\u00eancia dos resultados entre execu\u00e7\u00f5es\nfrom numpy.random import seed\nseed(33)\nimport tensorflow as tf\ntf.random.set_seed(33)","f0e2fe84":"# Criando o modelo Sequential\n# Sequential: Modelo Keras de ir adicionando camadas (como um lego)\n# Conv2D: Camada com kernels (filtros) que percorrem a imagem extraindo caracter\u00edsitcas (mapas de caracte\u00edsticas)\n# MaxPooling2D: Camada que reduz a dimensionalidade dos mapas de caracter\u00edsticas 2D\n# Flatten: Camada que transforma um mapa de caracter\u00edsticas 2D num vetor para classficador final\n# Dense: Camada onde todas as entradas est\u00e3o conectadas em cada neur\u00f4nio (totalmente conectada)\n# Dropout: Camada usa durante treino que descarta aleatoriamente um percentual de conex\u00f5es (reduz overfitting)\n\nmodel = Sequential()\nmodel.add(Conv2D(20, kernel_size=(3, 3),\n                 activation='relu',\n                 input_shape=(28,28,1)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(40, kernel_size=(3,3), activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dense(50, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(num_classes, activation='softmax'))\nmodel.summary()\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy', 'AUC'])\n\n# Treina com os parte dos dados\nbatch_size = 32\nepochs = 20\n\n#Salvar o melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.bruno',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=0,verbose=1)\n]\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    callbacks = callbacks_list,\n                    verbose=1,\n                    validation_data=(x_val, y_val))\n\n# Testa\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","39b7fef0":"BATCH_SIZE = 32\nMAX_EPOCHS = 20\nMODEL_ID = \"model.bruno2\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 7, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 7, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=(2,2)))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=(2,2)))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Flatten())\nmodel.add(Dense(256, activation = \"relu\"))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                           monitor='val_loss', \n                                                           save_best_only=True, \n                                                           verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=2,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    verbose=1,\n                    validation_data=(x_val, y_val))\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","03188027":"BATCH_SIZE = 100\nMAX_EPOCHS = 20\nMODEL_ID = \"model.bruno3\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 7, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 7, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\n\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\n\nmodel.add(Flatten())\nmodel.add(Dense(256, activation = \"relu\"))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                           monitor='val_loss', \n                                                           save_best_only=True, \n                                                           verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=4,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    verbose=1,\n                    validation_data=(x_val, y_val))\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","ac2a6998":"BATCH_SIZE = 100\nMAX_EPOCHS = 20\nMODEL_ID = \"model.bruno4\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 7, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 7, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\n\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\n\nmodel.add(Flatten())\nmodel.add(Dense(128, activation = \"relu\"))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                     monitor='val_loss', \n                                                     save_best_only=True, \n                                                     verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=2,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    validation_data=(x_val, y_val),\n                    verbose=1)\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","d5ff9122":"BATCH_SIZE = 100\nMAX_EPOCHS = 20\nMODEL_ID = \"model.bruno5\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 7, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 7, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(AvgPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\n\nmodel.add(Flatten())\nmodel.add(Dense(256, activation = \"relu\"))\nmodel.add(Dropout(0.25))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                     monitor='val_loss', \n                                                     save_best_only=True, \n                                                     verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=2,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    validation_data=(x_val, y_val),\n                    verbose=1)\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","fc337647":"x_train.shape","ba721ff8":"BATCH_SIZE = 100\nMAX_EPOCHS = 20\nMODEL_ID = \"model.bruno6\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 5, \n                 kernel_size = 3, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 5, \n                 kernel_size = 3, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(100, activation = \"relu\"))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(50, activation = \"relu\"))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(20, activation = \"relu\"))\nmodel.add(Dropout(0.1))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\nmodel.summary()\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                     monitor='val_loss', \n                                                     save_best_only=True, \n                                                     verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=2,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    validation_data=(x_val, y_val),\n                    verbose=1)\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","7a36f5eb":"BATCH_SIZE = 100\nMAX_EPOCHS = 30\nMODEL_ID = \"model.bruno7\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(60, activation = \"relu\"))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(20, activation = \"relu\"))\nmodel.add(Dropout(0.1))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\nmodel.summary()\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                     monitor='val_loss', \n                                                     save_best_only=True, \n                                                     verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=4,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    validation_data=(x_val, y_val),\n                    verbose=1)\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","b41e234d":"BATCH_SIZE = 100\nMAX_EPOCHS = 30\nMODEL_ID = \"model.bruno8\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\nmodel.add(Conv2D(filters = 40, \n                 kernel_size = 1,\n                 activation ='elu'))\nmodel.add(Conv2D(filters = 40, \n                 kernel_size = 1,\n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(40, activation = \"relu\"))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(20, activation = \"relu\"))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(10, activation = \"relu\"))\nmodel.add(Dropout(0.1))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\nmodel.summary()\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                     monitor='val_loss', \n                                                     save_best_only=True, \n                                                     verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=4,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    validation_data=(x_val, y_val),\n                    verbose=1)\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","9452e645":"BATCH_SIZE = 100\nMAX_EPOCHS = 30\nMODEL_ID = \"model.bruno9\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3, \n                 activation ='elu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 10, \n                 kernel_size = 3, \n                 activation ='elu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\n\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='elu'))\nmodel.add(Conv2D(filters = 20, \n                 kernel_size = 2,\n                 activation ='elu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\nmodel.add(Conv2D(filters = 40, \n                 kernel_size = 1,\n                 activation ='elu'))\nmodel.add(Conv2D(filters = 40, \n                 kernel_size = 1,\n                 activation ='elu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.1))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(40, activation = \"elu\"))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(20, activation = \"elu\"))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(10, activation = \"elu\"))\nmodel.add(Dropout(0.1))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\nmodel.summary()\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                     monitor='val_loss', \n                                                     save_best_only=True, \n                                                     verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=4,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    validation_data=(x_val, y_val),\n                    verbose=1)\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","2d5c3a12":"BATCH_SIZE = 100\nMAX_EPOCHS = 20\nMODEL_ID = \"model.bruno10\"\n\n# Baseado, em: https:\/\/www.kaggle.com\/takahiroyoshida012\/cnn-tensorflow-keras-vs-randomforest-acc-99\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D\nfrom tensorflow.keras.optimizers import Adam, Adagrad, RMSprop, SGD\nfrom tensorflow.keras.models import load_model\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 7, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 56, \n                 kernel_size = 7, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 3, \n                 activation ='relu'))\nmodel.add(Conv2D(filters = 112, \n                 kernel_size = 3, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Flatten())\nmodel.add(Dense(256, activation = \"sigmoid\"))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=\"adam\",\n              metrics=['accuracy', 'AUC'])\n\nmodel.summary()\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                           monitor='val_loss', \n                                                           save_best_only=True, \n                                                           verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=4,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    verbose=1,\n                    validation_data=(x_val, y_val))\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","ac601173":"BATCH_SIZE = 50\nMAX_EPOCHS = 30\nMODEL_ID = \"model.bruno11\"\n\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 100, \n                 kernel_size = 7, \n                 activation ='relu', \n                 input_shape = (28,28,1)))\nmodel.add(Conv2D(filters = 100, \n                 kernel_size = 7, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(filters = 200, \n                 kernel_size = 3, \n                 activation ='relu'))\nmodel.add(Conv2D(filters = 200, \n                 kernel_size = 3, \n                 activation ='relu'))\nmodel.add(MaxPool2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Flatten())\nmodel.add(Dense(256, activation = \"sigmoid\"))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(num_classes, activation = \"softmax\"))\n\n# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=\"adam\",\n              metrics=['accuracy', 'AUC'])\n\n# Salva o melhor modelo\ncb_save_best_model = keras.callbacks.ModelCheckpoint(filepath=MODEL_ID,\n                                                           monitor='val_loss', \n                                                           save_best_only=True, \n                                                           verbose=1)\n\n# Encerra o treino antecipadamente se n\u00e3o houver evolu\u00e7\u00e3o\ncb_early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', \n                                              patience=4,\n                                              verbose=1)\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=BATCH_SIZE,\n                    epochs=MAX_EPOCHS,\n                    callbacks = [\n                        cb_save_best_model,\n                        cb_early_stop],\n                    verbose=1,\n                    validation_data=(x_val, y_val))\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","bcdf1348":"#Vamos ver como foi o treino?\n\nfig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","47b568e5":"MODEL_ID = \"model.bruno3\"\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","b311814d":"MODEL_ID = \"model.bruno10\"\n\n# Carrega o melhor modelo\nmodel = load_model(MODEL_ID)\n\n# Avalia o melhor modelo\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","919d8b0b":"model.summary()","064cf655":"import itertools\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","7b4ddb63":"import numpy as np\n\n# Classificando toda base de teste\ny_pred = model.predict_classes(x_val)\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Confution Matrix\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","aa5aa983":"#introduzindo ruido\nimport numpy as np\nmean = 0.\nstddev = 0.2\nnoise = np.random.normal(mean, stddev, (4200, 28, 28,1))\nx_te = x_val + noise\nx_te = np.clip(x_te, 0., 1.)\n\nplt.imshow(x_te.reshape(4200, 28,28)[0], cmap=plt.cm.binary)\nplt.show()\n\n# Testa\nscore = model.evaluate(x_te, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nprint('Test ROC AUC:', score[2])","a9add59b":"!pip3 install keras-visualizer","5f94ad8f":"from keras_visualizer import visualizer \n\nvisualizer(model, format='png', view=True)","f9c402f3":"# Visualizando o modelo","cfe5f20c":"## Matriz de Confus\u00e3o","5a92dd82":"# Resultado do melhor modelo","24696ce0":"# Avaliando o Modelo","81e6da0b":"**Resumo:**\n\nO exemplo aqui desenvolvido tem como objetivo apresentar conceitos iniciais de implementa\u00e7\u00e3o de redes neurais com python e tensorflow\/keras. Esse modelo apresenta um modelo de Rede Neural Convolucional (CNN) b\u00e1sico que pode ser expandido mudando o n\u00famero de neur\u00f4nios e camadas. Em adapta\u00e7\u00f5es mais avan\u00e7adas, pode-se estudar possibilidade de otimiza\u00e7\u00e3o de hyperpar\u00e2metros e outras t\u00e9cnincas como aumento de dados.\n\n**N\u00e3o \u00e9 objetivo nosso desenvolver e otimizar o modelo de classifica\u00e7\u00e3o**. O exemplo tem objetivo meramente did\u00e1tico.\n\n---\n\n**Para saber mais:**\n* [Palestras e cursos do Ocean](http:\/\/www.oceanbrasil.com\/)\n* Fran\u00e7ois Chollet. Deep Learning with Python. Manning Publications, 2017.\n* Ian Goodfellow and Yoshua Bengio and Aaron Courville. [Deep Learning](https:\/\/www.deeplearningbook.org\/). MIT Press, 2016.","77e90ca9":"# Criando e treinando o Modelo","99badefd":"# Teste Adicional: Com ru\u00eddo","a2aa4920":"# Bibliotecas e Dados","9855f631":"Com ru\u00eddo, percebemos que a acur\u00e1cia dos exemplos de valida\u00e7\u00e3o caiu, mas muito menos que o modelo MLP cl\u00e1ssico (ver exemplo de MLP).\nUm modelo Convolucional (CNN) captura melhor regi\u00f5es, ou padr\u00f5es espaciais de pixels, tornando o modelo mais robusto.","3fcb58fc":"# Atividade 2: Experimenta\u00e7\u00e3o para melhoria do resultado do modelo\nAluno: Bruno Mendes","82fd4032":"O melhor resultado com MLP sobre o dataset original, foi:\n```\nTest loss: 0.1159505842040692\nTest accuracy: 0.9640476\nTest roc auc: 0.9978843\n```\n\nJ\u00e1 o melhor resuiltado com CNN sobre o dataset original, foi:\n```\nTest loss: 0.032700711501474\nTest accuracy: 0.9909524\nTest ROC AUC: 0.9991975\n```","705a8b85":"O melhor resultado com MLP sobre o dataset com ru\u00eddo, foi:\n```\nTest loss: 0.9104807124819074\nTest accuracy: 0.7469048\nTest roc auc: 0.7469048\n```\n\nAgora com CNN sobre o dataset com ru\u00eddo, foi:\n```\nTest loss: 0.041150492092794075\nTest accuracy: 0.98785716\nTest ROC AUC: 0.9991571\n```","f37aabdc":"## Teste com Ru\u00eddo","2d14195c":"# Gerando Sa\u00edda","23d23485":"# Introdu\u00e7\u00e3o"}}