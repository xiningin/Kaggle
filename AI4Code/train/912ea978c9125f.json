{"cell_type":{"ec7c26fb":"code","0121ef1a":"code","7a28cbc0":"code","b893214d":"code","d740f975":"code","f40d8d9c":"code","b40a0f17":"code","9511918d":"code","e53f209a":"code","e379d91c":"code","38f89e92":"code","15cfff84":"code","c9be69cb":"code","567b853a":"code","195ebe6a":"code","33d43829":"code","2b6e63b2":"code","91de7778":"code","1efe1a74":"code","c5fac9fb":"code","1f0a6c84":"markdown","f36f566f":"markdown","bab11e03":"markdown","3ea8e486":"markdown"},"source":{"ec7c26fb":"1+1","0121ef1a":"# install packages\n!rsync -a ..\/input\/mmdetectionv280\/mmdetection ..\/\n!pip install ..\/input\/mmdetectionv280\/src\/src\/mmdet-2.8.0\/mmdet-2.8.0\/\n!pip install ..\/input\/mmdetectionv280\/src\/src\/mmpycocotools-12.0.3\/mmpycocotools-12.0.3\/\n!pip install ..\/input\/mmdetectionv280\/src\/src\/addict-2.4.0-py3-none-any.whl\n!pip install ..\/input\/mmdetectionv280\/src\/src\/yapf-0.30.0-py2.py3-none-any.whl\n!pip install ..\/input\/mmdetectionv280\/src\/src\/mmcv_full-1.2.6-cp37-cp37m-manylinux1_x86_64.whl\n#!pip install mmcv_full","7a28cbc0":"from itertools import groupby\nfrom pycocotools import mask as mutils\nimport numpy as np\nfrom tqdm import tqdm\nimport pandas as pd\nimport os\nimport pickle\nimport cv2\nfrom multiprocessing import Pool\nimport matplotlib.pyplot as plt","b893214d":"exp_name = \"v3\"\nconf_name = \"mask_rcnn_s101_fpn_syncbn-backbone+head_mstrain_1x_coco\"\ncell_mask_dir = '..\/input\/hpa-mask\/hpa_cell_mask'    \nROOT = '..\/input\/hpa-single-cell-image-classification\/'\ntrain_or_test = 'train'\nimg_dir = f'..\/work\/mmdet_{exp_name}_{train_or_test}'\n!mkdir -p {img_dir}\ndf = pd.read_csv(os.path.join(ROOT, 'train.csv'))\n\n# this script takes more than 9hours for full data.\ndebug = True\nif debug:\n    df = df[:4]","d740f975":"# convert segmentation mask image to run length encoding\nMAX_GREEN = 64 # filter out dark green cells\ndef get_rles_from_mask(image_id, class_id):\n    mask = np.load(f'{cell_mask_dir}\/{image_id}.npz')['arr_0']\n    if class_id != '18':\n        green_img = read_img(image_id, 'green')\n    rle_list = []\n    mask_ids = np.unique(mask)\n    for val in mask_ids:\n        if val == 0:\n            continue\n        binary_mask = np.where(mask == val, 1, 0).astype(bool)\n        if class_id != '18':\n            masked_img = green_img * binary_mask\n            #print(val, green_img.max(),masked_img.max())\n            if masked_img.max() < MAX_GREEN:\n                continue\n        rle = coco_rle_encode(binary_mask)\n        rle_list.append(rle)\n    return rle_list, mask.shape[0], mask.shape[1]\n\ndef coco_rle_encode(mask):\n    rle = {'counts': [], 'size': list(mask.shape)}\n    counts = rle.get('counts')\n    for i, (value, elements) in enumerate(groupby(mask.ravel(order='F'))):\n        if i == 0 and value == 1:\n            counts.append(0)\n        counts.append(len(list(elements)))\n    return rle\n\n# mmdet custom dataset generator\ndef mk_mmdet_custom_data(image_id, class_id):\n    rles, height, width = get_rles_from_mask(image_id, class_id)\n    if len(rles) == 0:\n        return {\n            'filename': image_id+'.jpg',\n            'width': width,\n            'height': height,\n            'ann': {}\n        }\n    rles = mutils.frPyObjects(rles, height, width)\n    bboxes = mutils.toBbox(rles)\n    bboxes[:, 2] += bboxes[:, 0]\n    bboxes[:, 3] += bboxes[:, 1]\n    return {\n        'filename': image_id+'.jpg',\n        'width': width,\n        'height': height,\n        'ann':\n            {\n                'bboxes': np.array(bboxes, dtype=np.float32),\n                'labels': np.zeros(len(bboxes)), # dummy data.(will be replaced later)\n                'masks': rles\n            }\n    }\n\n# print utility from public notebook\ndef print_masked_img(image_id, mask):\n    img = load_RGBY_image(image_id, train_or_test)\n    \n    plt.figure(figsize=(15, 15))\n    plt.subplot(1, 3, 1)\n    plt.imshow(img)\n    plt.title('Image')\n    plt.axis('off')\n    \n    plt.subplot(1, 3, 2)\n    plt.imshow(mask)\n    plt.title('Mask')\n    plt.axis('off')\n    \n    plt.subplot(1, 3, 3)\n    plt.imshow(img)\n    plt.imshow(mask, alpha=0.6)\n    plt.title('Image + Mask')\n    plt.axis('off')\n    plt.show()\n    \n# image loader, using rgb only here\ndef load_RGBY_image(image_id, train_or_test='train', image_size=None):\n    red = read_img(image_id, \"red\", train_or_test, image_size)\n    green = read_img(image_id, \"green\", train_or_test, image_size)\n    blue = read_img(image_id, \"blue\", train_or_test, image_size)\n    #yellow = read_img(image_id, \"yellow\", train_or_test, image_size)\n    stacked_images = np.transpose(np.array([red, green, blue]), (1,2,0))\n    return stacked_images\n\n# \ndef read_img(image_id, color, train_or_test='train', image_size=None):\n    filename = f'{ROOT}\/{train_or_test}\/{image_id}_{color}.png'\n    assert os.path.exists(filename), f'not found {filename}'\n    img = cv2.imread(filename, cv2.IMREAD_UNCHANGED)\n    if image_size is not None:\n        img = cv2.resize(img, (image_size, image_size))\n    if img.max() > 255:\n        img_max = img.max()\n        img = (img\/255).astype('uint8')\n    return img\n\n# make annotation helper called multi processes\ndef mk_ann(idx):\n    image_id = df.iloc[idx].ID\n    class_id = df.iloc[idx].Label\n    anno = mk_mmdet_custom_data(image_id, class_id)\n    img = load_RGBY_image(image_id, train_or_test)\n    cv2.imwrite(f'{img_dir}\/{image_id}.jpg', img)\n    return anno, idx, image_id","f40d8d9c":"cell_mask_dir = '..\/input\/hpa-mask\/hpa_cell_mask'    \nfor idx in range(3):\n    image_id = df.iloc[idx].ID\n    cell_mask = np.load(f'{cell_mask_dir}\/{image_id}.npz')['arr_0']\n    print_masked_img(image_id, cell_mask)","b40a0f17":"# this part would take several hours, depends on your CPU power.\nMAX_THRE = 4 # set your avarable CPU count.\np = Pool(processes=MAX_THRE)\nannos = []\nlen_df = len(df)\nfor anno, idx, image_id in p.imap(mk_ann, range(len(df))):\n    if len(anno['ann']) > 0:\n        annos.append(anno)\n    print(f'{idx+1}\/{len_df}, {image_id}')","9511918d":"lbl_cnt_dict = df.set_index('ID').to_dict()['Label']\ntrn_annos = []\nval_annos = []\nval_len = int(len(annos)*0.01)\nfor idx in range(len(annos)):\n    ann = annos[idx]\n    filename = ann['filename'].replace('.jpg','').replace('.png','')\n    label_ids = lbl_cnt_dict[filename]\n    len_ann = len(ann['ann']['bboxes'])\n    bboxes = ann['ann']['bboxes']\n    masks = ann['ann']['masks']\n    # asign image level labels to each cells\n    for cnt, label_id in enumerate(label_ids.split('|')):\n        label_id = int(label_id)\n        if cnt == 0:\n            ann['ann']['labels'] = np.full(len_ann, label_id)\n        else:\n            ann['ann']['bboxes'] = np.concatenate([ann['ann']['bboxes'],bboxes])\n            ann['ann']['labels'] = np.concatenate([ann['ann']['labels'],np.full(len_ann, label_id)])\n            ann['ann']['masks'] = ann['ann']['masks'] + masks    \n    if idx < val_len:\n        val_annos.append(ann)\n    else:\n        trn_annos.append(ann)","e53f209a":"with open(f'..\/work\/mmdet_{exp_name}_full.pkl', 'wb') as f:\n    pickle.dump(annos, f)\nwith open(f'..\/work\/mmdet_{exp_name}_trn.pkl', 'wb') as f:\n    pickle.dump(trn_annos, f)\nwith open(f'..\/work\/mmdet_{exp_name}_val.pkl', 'wb') as f:\n    pickle.dump(val_annos, f)","e379d91c":"# I just made following config files based on default mask_rcnn.\n# The main changes are CustomDataset, num_classes, data path, etc.\n# Other than that, I used it as is for mmdetection.\n!ls -l ..\/mmdetection\/mmdetection\/configs\/hpa_{exp_name}\/","38f89e92":"#conf_name += '_coco'","15cfff84":"config = f'configs\/hpa_{exp_name}\/{conf_name}.py'\n# using --no-validate to avoid some errors for custom dataset metrics\nadditional_conf = '--no-validate --cfg-options'\nadditional_conf += f' work_dir=..\/working\/work_dir'\nadditional_conf += f' optimizer.lr=0.0025'\ncmd = f'bash -x tools\/dist_train.sh {config} 1 {additional_conf}'\n!cd ..\/mmdetection\/mmdetection; {cmd}","c9be69cb":"import os\nos.listdir()","567b853a":"os.listdir('..\/work\/')","195ebe6a":"from shutil import copy, copytree, copyfile","33d43829":"copytree('..\/input\/mmdetectionv280','work-mmdet\/')","2b6e63b2":"copytree('..\/input\/mmdetectionv280\/mmdetection\/mmdetection\/configs','configs\/')","91de7778":"copytree('..\/input\/hpa-mask','hpa-mask\/')","1efe1a74":"config = f'configs\/hpa_v3\/ade_reasoning_rcnn_r101_fpn_1x_coco.py'\n!bash -x .\/work-mmdet\/mmdetection\/mmdetection\/tools\/dist_train.sh {config} 1 {additional_conf}","c5fac9fb":"os.listdir('work_dir')","1f0a6c84":"# training","f36f566f":"# checking segment mask\nTo extract the each cells, [CellSegmentator](https:\/\/github.com\/CellProfiling\/HPA-Cell-Segmentation) can be used.\nAnd The extracted segment masks are stored in [this dataset](https:\/\/www.kaggle.com\/its7171\/hpa-mask).\n\nThis mask files are made as follows:\n<pre>\nnucl_mask, cell_mask = segmentCell(im, segmentator)\nnp.savez_compressed(f'{cell_dir}\/{image_id}', cell_mask)\nnp.savez_compressed(f'{nucl_dir}\/{image_id}', nucl_mask)\n<\/pre>\nSo you can load the mask as follows:\n<pre>\ncell_mask = np.load(f'{cell_dir}\/{image_id}.npz')['arr_0']\nnucl_mask = np.load(f'{nucl_dir}\/{image_id}.npz')['arr_0']\n<\/pre>\n","bab11e03":"# generate data for mmdetection training","3ea8e486":"# helper funcs"}}