{"cell_type":{"dfb8954f":"code","aaa29267":"code","8b233b85":"markdown","ea2a21a1":"markdown","a10880eb":"markdown"},"source":{"dfb8954f":"%%writefile greedy-goose.py\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import Observation, Configuration, Action, row_col, translate, adjacent_positions, min_distance\nimport random as rand\nfrom enum import Enum, auto\n\n\ndef opposite(action):\n    if action == Action.NORTH:\n        return Action.SOUTH\n    if action == Action.SOUTH:\n        return Action.NORTH\n    if action == Action.EAST:\n        return Action.WEST\n    if action == Action.WEST:\n        return Action.EAST\n    raise TypeError(str(action) + \" is not a valid Action.\")\n\n    \n\n#Enconding of cell content to build states from observations\nclass CellState(Enum):\n    EMPTY = 0\n    FOOD = auto()\n    GOOSE = auto()\n\n\n#This class encapsulates mos of the low level Hugry Geese stuff    \nclass BornToNotMedalv2:    \n    def __init__(self):\n        self.DEBUG=True\n        self.rows, self.columns = -1, -1        \n        self.my_index = -1\n        self.my_head, self.my_tail = -1, -1\n        self.geese = []\n        self.heads = []\n        self.tails = []\n        self.food = []\n        self.cell_states = []\n        self.actions = [action for action in Action]\n        self.previous_action = None\n        self.step = 1\n\n        \n    def _adjacent_positions(self, position):\n        return adjacent_positions(position, self.columns, self.rows)\n \n\n    def _min_distance_to_food(self, position, food=None):\n        food = food if food!=None else self.food\n        return min_distance(position, food, self.columns)\n\n    \n    def _row_col(self, position):\n        return row_col(position, self.columns)\n    \n    \n    def _translate(self, position, direction):\n        return translate(position, direction, self.columns, self.rows)\n        \n        \n    def preprocess_env(self, observation, configuration):\n        observation = Observation(observation)\n        configuration = Configuration(configuration)\n        \n        self.rows, self.columns = configuration.rows, configuration.columns        \n        self.my_index = observation.index\n        self.hunger_rate = configuration.hunger_rate\n        self.min_food = configuration.min_food\n\n        self.my_head, self.my_tail = observation.geese[self.my_index][0], observation.geese[self.my_index][-1]        \n        self.my_body = [pos for pos in observation.geese[self.my_index][1:-1]]\n\n        \n        self.geese = [g for i,g in enumerate(observation.geese) if i!=self.my_index  and len(g) > 0]\n        self.geese_cells = [pos for g in self.geese for pos in g if len(g) > 0]\n        \n        self.occupied = [p for p in self.geese_cells]\n        self.occupied.extend([p for p in observation.geese[self.my_index]])\n        \n        \n        self.heads = [g[0] for i,g in enumerate(observation.geese) if i!=self.my_index and len(g) > 0]\n        self.bodies = [pos  for i,g in enumerate(observation.geese) for pos in g[1:-1] if i!=self.my_index and len(g) > 2]\n        self.tails = [g[-1] for i,g in enumerate(observation.geese) if i!=self.my_index and len(g) > 1]\n        self.food = [f for f in observation.food]\n        \n        self.adjacent_to_heads = [pos for head in self.heads for pos in self._adjacent_positions(head)]\n        self.adjacent_to_bodies = [pos for body in self.bodies for pos in self._adjacent_positions(body)]\n        self.adjacent_to_tails = [pos for tail in self.tails for pos in self._adjacent_positions(tail)]\n        self.adjacent_to_geese = self.adjacent_to_heads + self.adjacent_to_bodies\n        self.danger_zone = self.adjacent_to_geese\n        \n        #Cell occupation\n        self.cell_states = [CellState.EMPTY.value for _ in range(self.rows*self.columns)]\n        for g in self.geese:\n            for pos in g:\n                self.cell_states[pos] = CellState.GOOSE.value\n        for pos in self.heads:\n                self.cell_states[pos] = CellState.GOOSE.value\n        for pos in self.my_body:\n            self.cell_states[pos] = CellState.GOOSE.value\n                \n        #detect dead-ends\n        self.dead_ends = []\n        for pos_i,_ in enumerate(self.cell_states):\n            if self.cell_states[pos_i] != CellState.EMPTY.value:\n                continue\n            adjacent = self._adjacent_positions(pos_i)\n            adjacent_states = [self.cell_states[adj_pos] for adj_pos in adjacent if adj_pos!=self.my_head]\n            num_blocked = sum(adjacent_states)\n            if num_blocked>=(CellState.GOOSE.value*3):\n                self.dead_ends.append(pos_i)\n        \n        #check for extended dead-ends\n        new_dead_ends = [pos for pos in self.dead_ends]\n        while new_dead_ends!=[]:\n            for pos in new_dead_ends:\n                self.cell_states[pos]=CellState.GOOSE.value\n                self.dead_ends.append(pos)\n            \n            new_dead_ends = []\n            for pos_i,_ in enumerate(self.cell_states):\n                if self.cell_states[pos_i] != CellState.EMPTY.value:\n                    continue\n                adjacent = self._adjacent_positions(pos_i)\n                adjacent_states = [self.cell_states[adj_pos] for adj_pos in adjacent if adj_pos!=self.my_head]\n                num_blocked = sum(adjacent_states)\n                if num_blocked>=(CellState.GOOSE.value*3):\n                    new_dead_ends.append(pos_i)                                    \n        \n                \n    def strategy_random(self, observation, configuration):\n        if self.previous_action!=None:\n            action = rand.choice([action for action in Action if action!=opposite(self.previous_action)])\n        else:\n            action = rand.choice([action for action in Action])\n        self.previous_action = action\n        return action.name\n                        \n                        \n    def safe_position(self, future_position):\n        return (future_position not in self.occupied) and (future_position not in self.adjacent_to_heads) and (future_position not in self.dead_ends)\n    \n    \n    def valid_position(self, future_position):\n        return (future_position not in self.occupied) and (future_position not in self.dead_ends)    \n\n    \n    def free_position(self, future_position):\n        return (future_position not in self.occupied) \n    \n                        \n    def strategy_random_avoid_collision(self, observation, configuration):\n        dead_end_cell = False\n        free_cell = True\n        actions = [action \n                   for action in Action \n                   for future_position in [self._translate(self.my_head, action)]\n                   if self.valid_position(future_position)] \n        if self.previous_action!=None:\n            actions = [action for action in actions if action!=opposite(self.previous_action)] \n        if actions==[]:\n            dead_end_cell = True\n            actions = [action \n                       for action in Action \n                       for future_position in [self._translate(self.my_head, action)]\n                       if self.free_position(future_position)]\n            if self.previous_action!=None:\n                actions = [action for action in actions if action!=opposite(self.previous_action)] \n            #no alternatives\n            if actions==[]:\n                free_cell = False\n                actions = self.actions if self.previous_action==None else [action for action in self.actions if action!=opposite(self.previous_action)] \n\n        action = rand.choice(actions)\n        self.previous_action = action\n        if self.DEBUG:\n            aux_pos = self._row_col(self._translate(self.my_head, self.previous_action))\n            dead_ends = \"\" if not dead_end_cell else f', dead_ends={[self._row_col(p1) for p1 in self.dead_ends]}, occupied={[self._row_col(p2) for p2 in self.occupied]}'\n            if free_cell:\n                print(f'{id(self)}({self.step}): Random_ac_move {action.name} to {aux_pos} dead_end={dead_end_cell}{dead_ends}', flush=True)\n            else:\n                print(f'{id(self)}({self.step}): Random_ac_move {action.name} to {aux_pos} free_cell={free_cell}', flush=True)\n        return action.name\n    \n    \n    def strategy_greedy_avoid_risk(self, observation, configuration):        \n        actions = {  \n            action: self._min_distance_to_food(future_position)\n            for action in Action \n            for future_position in [self._translate(self.my_head, action)]\n            if self.safe_position(future_position)\n        }\n  \n        if self.previous_action!=None:\n            actions.pop(opposite(self.previous_action), None)\n        if any(actions):\n            action = min(actions.items(), key=lambda x: x[1])[0]\n            self.previous_action = action\n            if self.DEBUG:\n                aux_pos = self._row_col(self._translate(self.my_head, self.previous_action))\n                print(f'{id(self)}({self.step}): Greedy_ar_move {action.name} to {aux_pos}', flush=True)\n            self.previous_action = action\n            return action.name\n        else:\n            return self.strategy_random_avoid_collision(observation, configuration)\n    \n    \n    #Redefine this method\n    def agent_strategy(self, observation, configuration):\n        action = self.strategy_greedy_avoid_risk(observation, configuration)\n        return action\n    \n    \n    def agent_do(self, observation, configuration):\n        self.preprocess_env(observation, configuration)\n        move = self.agent_strategy(observation, configuration)\n        self.step += 1\n        #if self.DEBUG:\n        #    aux_pos = self._translate(self.my_head, self.previous_action), self._row_col(self._translate(self.my_head, self.previous_action))\n        #    print(f'{id(self)}({self.step}): Move {move} to {aux_pos} internal_vars->{vars(self)}', flush=True)\n        return move\n\n    \n    \ndef agent_singleton(observation, configuration):\n    global gus    \n    \n    try:\n        gus\n    except NameError:\n        gus = BornToNotMedalv2()\n            \n    action = gus.agent_do(observation, configuration)\n\n    \n    return action","aaa29267":"import kaggle_environments\nfrom kaggle_environments import make, evaluate, utils\n\nenv = make(\"hungry_geese\", debug=False) #set debug to True to see agent internals each step\n\nenv.reset()\nenv.run([\n        \"greedy-goose.py\", \n        \"greedy-goose.py\", \n        ])\nenv.render(mode=\"ipython\", width=800, height=700)","8b233b85":"# Greedy risk averse with improved dead-end detection \n\nThis hopes to serve as a base template class or opponent to train your reinforcement learning agents against ;-)\n\nHope this template helps someone to get started with the competition, added decorators for the basic methods to get, at least I hope, and easier to read code. Comment includes reference of configuration an observation structures.\n\nStrategies implemented:\n* Random with collision avoidance\n* Risk averse greedy\n\nFeatures:\n* Includes board wrapping\n* Forbidden moves avoided\n* Avoidance of dead-ends, now the agent extends the dead end detection to avoid blocked corridors :-)\n\n\n### Changelog\n* v38: improved dead end detection**\n* v34: minor bugfixes\n* v31: fixed bug on dead-end cell detection (so far only a cell with 3 blocked sides, not including the one where my head is, no recursion), improved logging info\n* v29: improved strategy random avoid collision to search only for free cells when all that's left are dead-ends\n* v28: improved risk avoidance to not include cells surrounding tails, fixed bug on occupied cell accounting","ea2a21a1":"Now just to check it's working.","a10880eb":"# *Enjoy!*"}}