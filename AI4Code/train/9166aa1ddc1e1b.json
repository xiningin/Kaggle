{"cell_type":{"ab6fdec2":"code","1ba18247":"code","8bd27bc0":"code","a9784c85":"code","47776f26":"code","f18d7f83":"code","d84dc68c":"code","4541933d":"code","3eace9db":"code","83f22766":"code","03bcc34c":"code","d9365848":"code","37de428a":"code","c8ef4a55":"code","d91f4a24":"code","fedad6be":"code","fccf817d":"code","70ed5e66":"code","0be41ed1":"code","d6f95528":"code","dbbb21e6":"code","8e3b95eb":"code","b4635096":"code","f99bcd46":"markdown","e96e97a2":"markdown","05a1f716":"markdown","400b51d8":"markdown","e4434520":"markdown","f12c40f6":"markdown","4c5b0674":"markdown","869db0d8":"markdown","7921fdcd":"markdown","0d51c22f":"markdown","4e57f9f7":"markdown","e00223bd":"markdown","a41ba808":"markdown","9e9e5e2f":"markdown"},"source":{"ab6fdec2":"import os\nimport folium \nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.preprocessing import StandardScaler","1ba18247":"bournemouth_venues_dataset = \"\/kaggle\/input\/bournemouth-venues\/bournemouth_venues.csv\"\nassert os.path.exists(bournemouth_venues_dataset), \"Path to Bournemouth dataset needs fixing\"\n\nbournemouth_venues = pd.read_csv(bournemouth_venues_dataset)\nbournemouth_venues.head()","8bd27bc0":"bournemouth_uk_map = folium.Map(location=[50.719166, -1.880769], zoom_start=14)\n\n# Create city markers and add them to map object\nfor index, row in bournemouth_venues.iterrows():\n    folium.Marker(location=[row[\"Venue Latitude\"], row[\"Venue Longitude\"]], \n                  popup=\"Person at:<strong>\"+ row[\"Venue Name\"] +\"<\/strong>\",\n                  icon=folium.Icon(color=\"red\", icon=\"user\")).add_to(bournemouth_uk_map)\n\nbournemouth_uk_map","a9784c85":"features = bournemouth_venues[[\"Venue Latitude\", \"Venue Longitude\"]].to_numpy()\nscaler = StandardScaler()\nscaled_features = scaler.fit_transform(features)","47776f26":"kmeans = KMeans(\n    init=\"random\",\n    n_clusters=7,\n    n_init=10,\n    max_iter=300,\n    random_state=42\n)","f18d7f83":"kmeans.fit(scaled_features)","d84dc68c":"cluster_centers = scaler.inverse_transform(kmeans.cluster_centers_) # For display purposes\n\n\n# Create city markers and add them to map object\nfor lat, long in cluster_centers:\n    folium.Marker(location=[lat, long], \n                  popup=\"<strong>\"+ \"Bus Stop from K-Means \"+\"<\/strong>\",\n                  icon=folium.Icon(color=\"cadetblue\", icon=\"bus\" , prefix='fa')).add_to(bournemouth_uk_map)\n\nbournemouth_uk_map","4541933d":"kmeans_kwargs = {\n    \"init\": \"random\",\n    \"n_init\": 10,\n    \"max_iter\": 300,\n    \"random_state\": 42,\n}\n\n# A list holds the SSE values for each k\nsse = []\nfor k in range(1, 11):\n    kmeans = KMeans(n_clusters=k, **kmeans_kwargs)\n    kmeans.fit(scaled_features)\n    sse.append(kmeans.inertia_)","3eace9db":"plt.style.use(\"fivethirtyeight\")\nplt.plot(range(1, 11), sse)\nplt.xticks(range(1, 11))\nplt.xlabel(\"Number of Clusters\")\nplt.ylabel(\"SSE\")\nplt.show()","83f22766":"# A list holds the silhouette coefficients for each k\nsilhouette_coefficients = []\n\n# Notice you start at 2 clusters for silhouette coefficient\nfor k in range(2, 11):\n    kmeans = KMeans(n_clusters=k, **kmeans_kwargs)\n    kmeans.fit(scaled_features)\n    score = silhouette_score(scaled_features, kmeans.labels_)\n    silhouette_coefficients.append(score)","03bcc34c":"plt.style.use(\"fivethirtyeight\")\nplt.plot(range(2, 11), silhouette_coefficients)\nplt.xticks(range(2, 11))\nplt.xlabel(\"Number of Clusters\")\nplt.ylabel(\"Silhouette Coefficient\")\nplt.show()","d9365848":"import plotly.express as px","37de428a":"airbnb_seattle_listings = \"..\/input\/seattle-airbnb-listings\/seattle_01.csv\"\nassert os.path.exists(airbnb_seattle_listings), \"Path to Airbnb Seattle dataset needs fixing\"\n\nairbnb_seattle = pd.read_csv(airbnb_seattle_listings)[[\"address\", \"latitude\", \"longitude\"]]\nairbnb_seattle.head()","c8ef4a55":"seattle_us_map = folium.Map(location=[47.606209, -122.332069], zoom_start=14)\n\n# Create city markers and add them to map object\nfor index, row in airbnb_seattle.iterrows():\n    folium.Marker(location=[row[\"latitude\"], row[\"longitude\"]], \n                  popup=\"Person at:<strong>\"+ row[\"address\"] +\"<\/strong>\",\n                  icon=folium.Icon(color=\"red\", icon=\"user\")).add_to(seattle_us_map)\n\n#seattle_us_map","d91f4a24":"features = airbnb_seattle[[\"latitude\", \"longitude\"]].to_numpy()\nscaler = StandardScaler()\nscaled_features = scaler.fit_transform(features)","fedad6be":"kmeans_kwargs = {\n    \"init\": \"k-means++\",\n    \"n_init\": 10,\n    \"max_iter\": 300,\n    \"random_state\": 42,\n}\n\n# A list holds the SSE values for each k\nk_min = 1\nk_max = 20\nsse = []\nfor k in range(k_min, k_max):\n    kmeans = KMeans(n_clusters=k, **kmeans_kwargs)\n    kmeans.fit(scaled_features)\n    sse.append(kmeans.inertia_)\n","fccf817d":"data = {\n    \"clusters\":list(range(k_min, k_max)),\n    \"sse\":sse}\n\ndf = pd.DataFrame (data, columns = ['clusters','sse'])\n\n# plotting the line chart\nfig = px.line(df,x=\"clusters\", y=\"sse\")\n\n# showing the plot\nfig.show()","70ed5e66":"kmeans_kwargs = {\n    \"init\": \"k-means++\",\n    \"n_init\": 10,\n    \"max_iter\": 300,\n    \"random_state\": 42,\n}\n\n\n# A list holds the silhouette coefficients for each k\nsilhouette_coefficients = []\n\nk_min = 2\nk_max = 50\n\n# Notice you start at 2 clusters for silhouette coefficient\nfor k in range(k_min, k_max):\n    kmeans = KMeans(n_clusters=k, **kmeans_kwargs)\n    kmeans.fit(scaled_features)\n    score = silhouette_score(scaled_features, kmeans.labels_)\n    silhouette_coefficients.append(score)\n\n","0be41ed1":"data = {\n    \"clusters\":list(range(k_min, k_max)),\n    \"silhouette_coefficients\":silhouette_coefficients}\n\ndf = pd.DataFrame (data, columns = ['clusters','silhouette_coefficients'])\n\n# plotting the line chart\nfig = px.line(df, y=\"silhouette_coefficients\")\n\n# showing the plot\nfig.show()","d6f95528":"decided_cluster = 350","dbbb21e6":"kmeans = KMeans(\n    init=\"k-means++\",\n    n_clusters=decided_cluster,\n    n_init=10,\n    max_iter=300,\n    random_state=42\n)","8e3b95eb":"kmeans.fit(scaled_features)","b4635096":"cluster_centers = scaler.inverse_transform(kmeans.cluster_centers_) # For display purposes\n\n\n# Create city markers and add them to map object\nfor lat, long in cluster_centers:\n    folium.Marker(location=[lat, long], \n                  popup=\"<strong>\"+ \"Bus Stop from K-Means \"+\"<\/strong>\",\n                  icon=folium.Icon(color=\"cadetblue\", icon=\"bus\" , prefix='fa')).add_to(seattle_us_map)\n\nseattle_us_map","f99bcd46":"The model can be evaluated visually. The results look plausible. ","e96e97a2":"# Airbnb Seattle Listing: Another Dataset\nHere we assume the listed appartment\/house is a user.","05a1f716":"![Centroid Iteration](https:\/\/files.realpython.com\/media\/centroids_iterations.247379590275.gif)","400b51d8":"## Next Step\nTry other clustering techniques like: Density-Based Clustering. Those are resistent to outliers.","e4434520":"We see some of our proposed Bus Stops are close to actual bus stops. This is a good sign despite having only a 100 users in our city. \n\nNotice, however, some bus stops are placed on impossible locations. This was well expected. The fasted route between two points is a straight line but our highways still have rounds, junctions and detours because the roads are designed for generic destinations not for one person. AI was meant to augment human ability anyway. It is perhaps too soon for a complete solution.","f12c40f6":"The number of clusters to use should be guided by a combination of domain knowledge and clustering evaluation metrics.","4c5b0674":"### References\n1. [K-means-clustering](https:\/\/realpython.com\/k-means-clustering-python\/) \n2. [Python - Create Maps with Folium and Leaflet](https:\/\/youtu.be\/QpBmO35pmVE) \n","869db0d8":"These plots are interactive. Unfortunately, evualting on a large number of clusters is time consuming and for this purpose a small cluster has been shown. ","7921fdcd":"### Model","0d51c22f":"### Finding the right number of clusters\nAppropriate Number of Clusters through \n* **Elbow method**: Choose when it bends\n* **silhouette coefficient**: Highest score","4e57f9f7":"### Preprocessing\nThe features (latitude and longitude) need to be normalized. Improves learning in model among other things.","e00223bd":"![Kmeans Algorithm](https:\/\/files.realpython.com\/media\/kmeans-algorithm.a94498a7ecd2.png)","a41ba808":"#### Partitional Clustering\nPartitional clustering divides data objects into nonoverlapping groups. In other words, no object can be a member of more than one cluster, and every cluster must have at least one object.\n\nThese techniques require the user to specify the number of clusters, indicated by the variable **k**. Many partitional clustering algorithms work through an iterative process to assign subsets of data points into k clusters. Two examples of partitional clustering algorithms are **k-means** and k-medoids.\n\nThese algorithms are both nondeterministic, meaning they could produce different results from two separate runs even if the runs were based on the same input.\n\nPartitional clustering methods have several strengths:\n\n* They work well when clusters have a spherical shape.\n* They\u2019re **scalable** with respect to algorithm complexity.\n\nThey also have several weaknesses:\n\n* They\u2019re not well suited for clusters with complex shapes and different sizes.\n* They break down when used with clusters of different densities.","9e9e5e2f":"### We will simulate users by considering them venues in Bournemouth UK. Our goal is optimal Bus Stop discovery."}}