{"cell_type":{"f211c349":"code","e7b05f1f":"code","027d3afe":"code","5ed92ddd":"code","386abe2f":"code","71b87258":"code","5719c010":"code","d8737e0b":"code","b73d0aa0":"code","3c44f166":"code","b95e3880":"code","d83b5918":"code","5bb8dd0b":"markdown","2da043f7":"markdown","b4594724":"markdown","e0e203f1":"markdown","f052363a":"markdown"},"source":{"f211c349":"from pathlib import Path\nimport numpy as np\nimport cv2\nimport pydicom\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nDATASET = 'train'\nscan_types = ['FLAIR','T1w','T1wCE','T2w']\ndata_root = Path(\"..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\")","e7b05f1f":"# https:\/\/www.kaggle.com\/arnabs007\/part-1-rsna-miccai-btrc-understanding-the-data\n# https:\/\/www.kaggle.com\/davidbroberts\/determining-mr-image-planes\ndef get_image_plane(data):\n    x1, y1, _, x2, y2, _ = [round(j) for j in data.ImageOrientationPatient]\n    cords = [x1, y1, x2, y2]\n\n    if cords == [1, 0, 0, 0]:\n        return 'Coronal'\n    elif cords == [1, 0, 0, 1]:\n        return 'Axial'\n    elif cords == [0, 1, 0, 0]:\n        return 'Sagittal'\n    else:\n        return 'Unknown'","027d3afe":"def get_voxel(study_id, scan_type):\n    imgs = []\n    dcm_dir = data_root.joinpath(DATASET, study_id, scan_type)\n    dcm_paths = sorted(dcm_dir.glob(\"*.dcm\"), key=lambda x: int(x.stem.split(\"-\")[-1]))\n    positions = []\n    \n    for dcm_path in dcm_paths:\n        img = pydicom.dcmread(str(dcm_path))\n        imgs.append(img.pixel_array)\n        positions.append(img.ImagePositionPatient)\n    \n    dfp = pd.DataFrame(data=positions)\n    print(dfp.head(10)   )\n     \n    plane = get_image_plane(img)\n    voxel = np.stack(imgs)\n    \n    # reorder planes if needed and rotate voxel\n    if plane == \"Coronal\":\n        if positions[0][1] < positions[-1][1]:\n            voxel = voxel[::-1]\n            print(f\"{study_id} {scan_type} {plane} reordered\")\n        voxel = voxel.transpose((1, 0, 2))\n    elif plane == \"Sagittal\":\n        if positions[0][0] < positions[-1][0]:\n            voxel = voxel[::-1]\n            print(f\"{study_id} {scan_type} {plane} reordered\")\n        voxel = voxel.transpose((1, 2, 0))\n        voxel = np.rot90(voxel, 2, axes=(1, 2))\n    elif plane == \"Axial\":\n        if positions[0][2] > positions[-1][2]:\n            voxel = voxel[::-1]\n            print(f\"{study_id} {scan_type} {plane} reordered\")\n        voxel = np.rot90(voxel, 2)\n    else:\n        raise ValueError(f\"Unknown plane {plane}\")\n    return voxel, plane","5ed92ddd":"def normalize_contrast(voxel):\n    if voxel.sum() == 0:\n        return voxel\n    voxel = voxel - np.min(voxel)\n    voxel = voxel \/ np.max(voxel)\n    voxel = (voxel * 255).astype(np.uint8)\n    return voxel","386abe2f":"def crop_voxel(voxel):\n    if voxel.sum() == 0:\n        return voxel\n    keep = (voxel.mean(axis=(0, 1)) > 0)\n    voxel = voxel[:, :, keep]\n    keep = (voxel.mean(axis=(0, 2)) > 0)\n    voxel = voxel[:, keep]\n    keep = (voxel.mean(axis=(1, 2)) > 0)\n    voxel = voxel[keep]\n    return voxel","71b87258":"def resize_voxel(voxel, sz=64):\n    output = np.zeros((sz, sz, sz), dtype=np.uint8)\n\n    if np.argmax(voxel.shape) == 0:\n        for i, s in enumerate(np.linspace(0, voxel.shape[0] - 1, sz)):\n            output[i] = cv2.resize(voxel[int(s)], (sz, sz))\n    elif np.argmax(voxel.shape) == 1:\n        for i, s in enumerate(np.linspace(0, voxel.shape[1] - 1, sz)):\n            output[:, i] = cv2.resize(voxel[:, int(s)], (sz, sz))\n    elif np.argmax(voxel.shape) == 2:\n        for i, s in enumerate(np.linspace(0, voxel.shape[2] - 1, sz)):\n            output[:, :, i] = cv2.resize(voxel[:, :, int(s)], (sz, sz))\n\n    return output","5719c010":"for study_path in list(data_root.joinpath(DATASET).glob(\"*\"))[:5]:\n    study_id = study_path.name\n    \n    if not study_path.is_dir():\n        continue\n\n    fig = plt.figure(figsize=(12, 9))\n    fig.suptitle(f\"study id: {study_id}\", fontsize=24)\n\n    for i, scan_type in enumerate(scan_types):\n        voxel, plane = get_voxel(study_id, scan_type)\n        voxel = normalize_contrast(voxel)\n        voxel = crop_voxel(voxel)\n        voxel = resize_voxel(voxel)\n        ax = fig.add_subplot(3, 4, i + 1)\n        ax.set_title(f\"{scan_type}, {plane}\")\n        ax.imshow(voxel[voxel.shape[0] \/\/ 2], cmap='gray')\n        ax = fig.add_subplot(3, 4, i + 1 + 4)\n        ax.imshow(voxel[:, voxel.shape[1] \/\/ 2], cmap='gray')\n        ax = fig.add_subplot(3, 4, i + 1 + 8)\n        ax.imshow(voxel[:, :, voxel.shape[2] \/\/ 2], cmap='gray')\n    \n    fig.show()","d8737e0b":"! ls ..\/input","b73d0aa0":"def load_voxel(study_id, scan_type=\"FLAIR\", split=\"train\", sz=256):\n    assert sz in (64, 128, 256)\n    data_root = Path(f\"..\/input\/rsna-miccai-voxel-{sz}-dataset\")\n    npy_path = Path(data_root).joinpath(\"voxel\", split, study_id, f\"{scan_type}.npy\")\n    voxel = np.load(str(npy_path))\n    return voxel","3c44f166":"voxel = load_voxel(\"00000\", \"FLAIR\", \"train\", 64)\n","b95e3880":"voxel = load_voxel(\"00003\", \"FLAIR\", \"train\", 64)\n","d83b5918":"voxel = load_voxel(\"00006\", \"FLAIR\", \"train\", 64)\n","5bb8dd0b":"# Normalized Voxel Datasets\nThe normalized voxels created the above procedure were stored as a dataset:\n\n- [64x64x64 voxel](https:\/\/www.kaggle.com\/ren4yu\/rsna-miccai-voxel-64-dataset)\n- [128x128x128 voxel](https:\/\/www.kaggle.com\/ren4yu\/rsna-miccai-voxel-128-dataset)\n- [256x256x256 voxel](https:\/\/www.kaggle.com\/ren4yu\/rsna-miccai-voxel-256-dataset)\n\nThe directory structure is as follows:\n\n```\nvoxel\n\u251c\u2500\u2500 train\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00000\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 FLAIR.npy\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 T1w.npy\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 T1wCE.npy\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 T2w.npy\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00002\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 FLAIR.npy\n...\n\u251c\u2500\u2500 test\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00001\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 FLAIR.npy\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 T1w.npy\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 T1wCE.npy\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 T2w.npy\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00013\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 FLAIR.npy\n```\n\nSome voxels do not exist because all images belonging to these scans are completely black:\n\n- ('train', '00109', 'FLAIR.npy')\n- ('train', '00123', 'T1w.npy')\n- ('train', '00123', 'T2w.npy')\n- ('train', '00709', 'FLAIR.npy')\n\nLet's get one voxel and visualize it.","2da043f7":"Sample planes along the longest axis and resize the sampled planes.\nBy sampling along the longest axis, the degradation due to sampling is minimized.\nThe best way is to resize twice (e.g. (x, y) axis then (y, z) axis) but it is computationally expensive.","b4594724":"# We can see that the intervals vary from one to another, and some of them are rotary scanning.","e0e203f1":"# We can see that the intervals vary from one to another, and some of them are rotary scanning.","f052363a":"# Normalized Voxels: Align Planes, Adjust Contrast, and Crop\n\nAs shown in several notebooks, MRI plane type (Axial, Coronal, and Sagittal) is not consistent among patients or MRI scan types (FLAIR, T1w, T1wCE, T2w).\nWhile augmentations might alleviate this inconsistency, it is better to train models using MRI voxels that are consistent in terms of plane type.\nThis notebook shows we can obtain normalized voxels by appropriately rotating MRI voxels.\nI found that simply rotating MRI voxels is not enough because the order of planes is also inconsistent in some cases.\nFor example, even with the same Sagittal type, some of scans were in left-to-right order, while others were the other way around.\nAs Instance Number does not help, Image Position (Patient) is used in this notebook to reorder stacked images.\nAfter normalized voxels with respect to planes, contrast is adjusted and then voxels are cropped.\nFinally, the voxel is resized to arbitrary fixed size.\n\n## Normalized Voxel Datasets\n\nThe normalized voxels created the above procedure were stored as a dataset. Please refer to the second half of this notebook."}}