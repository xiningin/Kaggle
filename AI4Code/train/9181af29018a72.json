{"cell_type":{"aec0f02a":"code","4f2ce754":"code","725a9874":"code","139fdb7b":"code","ad9a431d":"code","b13ed548":"code","a5a97227":"code","e4f642cd":"code","f1678208":"code","b38ad42b":"code","f925fba3":"code","6ba88720":"code","74a74b4e":"code","f21eb231":"code","71091772":"code","5440f740":"code","0ca7549e":"code","6247d7c6":"code","6ee02456":"markdown","956100e5":"markdown"},"source":{"aec0f02a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","4f2ce754":"import torch\nimport torchvision\nfrom torchvision import transforms\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch.nn as nn\nimport os","725a9874":"batch_size=100\ndevice=torch.device('cuda' if torch.cuda.is_available() else 'cpu')","139fdb7b":"transform=transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize((0.5,),(0.5,))\n])","ad9a431d":"mnist=torchvision.datasets.MNIST(root='datasets\/',train=True,transform=transform,download=True)","b13ed548":"!ls","a5a97227":"mnist_loader=torch.utils.data.DataLoader(mnist,shuffle=True,batch_size=batch_size)","e4f642cd":"img,labels=iter(mnist_loader).next()","f1678208":"labels","b38ad42b":"grid=torchvision.utils.make_grid(img)\ngrid=grid.detach().numpy()\ngrid=np.transpose(grid,(1,2,0))\nplt.imshow(grid)","f925fba3":"#latent size is the latent variable vector used in generator\nlatent_size=64\n#hidden size in discriminator and generator\nhidden_size=256\nimage_size=28*28\nepochs=100","6ba88720":"#Discriminator\nD=nn.Sequential(\n    nn.Linear(image_size,hidden_size),\n    nn.LeakyReLU(0.2),\n    nn.Dropout(0.5),\n    nn.Linear(hidden_size,hidden_size),\n    nn.LeakyReLU(0.2),\n    nn.Dropout(0.5),\n    nn.Linear(hidden_size,1),\n    nn.Sigmoid()\n)","74a74b4e":"#Generator\nG=nn.Sequential(\n    nn.Linear(latent_size,hidden_size),\n    nn.ReLU(),\n    nn.Linear(hidden_size,hidden_size),\n    nn.ReLU(),\n    nn.Linear(hidden_size,image_size),\n    nn.Tanh()\n)","f21eb231":"D=D.to(device)\nG=G.to(device)","71091772":"bce_loss=nn.BCELoss()","5440f740":"d_optimizer=torch.optim.Adam(D.parameters(),lr=0.0002)\ng_optimizer=torch.optim.Adam(G.parameters(),lr=0.0002)","0ca7549e":"for epoch in range(epochs):\n    for i ,(images,_) in enumerate(mnist_loader):\n        img=images.reshape(batch_size,-1).to(device)\n        real_labels=torch.ones(batch_size,1).to(device)\n        fake_labels=torch.zeros(batch_size,1).to(device)\n        \n        outputs=D(img)\n        \n        d_loss_real=bce_loss(outputs,real_labels)\n        real_score=outputs\n        \n        z=torch.randn(batch_size,latent_size).to(device)\n        fake_images=G(z)\n        \n        outputs=D(fake_images)\n        d_loss_fake=bce_loss(outputs,fake_labels)\n        fake_score=outputs\n        \n        d_loss=d_loss_fake+d_loss_real\n        d_optimizer.zero_grad()\n        g_optimizer.zero_grad()\n        \n        d_loss.backward()\n        d_optimizer.step()\n        \n        #now updating generator\n        z=torch.randn(batch_size,latent_size).to(device)\n        fake_images=G(z)\n        \n        outputs=D(fake_images)\n        g_loss=bce_loss(outputs,real_labels)\n        \n        d_optimizer.zero_grad()\n        g_optimizer.zero_grad()\n        g_loss.backward()\n        g_optimizer.step()\n        \n        if i % 200==0:\n            print(f'Epoch {i} d_loss {d_loss.item()} g_loss {g_loss.item()}')\n            \n    fake_images=fake_images.reshape(fake_images.size(0),1,28,28)","6247d7c6":"img=torchvision.utils.make_grid(fake_images)\nimg=img.detach().cpu().numpy()\nimg=img.clip(0,1)\nplt.figure(figsize=(15,15))\nplt.imshow(np.transpose(img,(1,2,0)))\n","6ee02456":"![Screenshot%20from%202020-09-07%2012-16-19.png](attachment:Screenshot%20from%202020-09-07%2012-16-19.png)","956100e5":"![Screenshot%20from%202020-09-07%2012-16-48.png](attachment:Screenshot%20from%202020-09-07%2012-16-48.png)"}}