{"cell_type":{"c46ab884":"code","1828940f":"code","37767039":"code","79b70f60":"code","4763a162":"code","f34a6018":"code","e3d3fcfa":"code","d245b710":"code","61cd191a":"code","a69b475b":"code","c5b9211e":"code","4df62c3c":"code","1aa4a8aa":"code","eaf0437e":"code","8a9f47e6":"code","91cfbea6":"code","5bcdafb8":"code","4354d8a4":"code","1f4c7fd8":"code","e52c242f":"code","119ace87":"code","3add8db2":"code","26485ea2":"code","c152a3ff":"code","024d133a":"code","49dc4941":"code","e0383d23":"code","bf5a3f3c":"code","f8cb09ed":"code","8c7a0994":"code","9ee6882a":"code","673983d7":"code","a7c7b529":"code","5b13f961":"code","969d2d37":"code","25f8c9c7":"code","ba03bf14":"code","326c5bb5":"code","28d669f7":"code","17db8c21":"code","d10daf73":"code","a721164b":"code","9280ff66":"code","b4c46d5b":"code","7dcdfb31":"code","23da38c6":"code","13c6183e":"code","6040728e":"code","835d8e59":"code","29ca9904":"code","daeb0464":"code","1225304f":"code","a6f64283":"code","2a1b5679":"markdown","1ec5da6b":"markdown","528adf72":"markdown","b5910300":"markdown","afac1408":"markdown","83b26852":"markdown","ea1bc280":"markdown","ca945a34":"markdown","3a668f95":"markdown","ec15056d":"markdown","3c1b4285":"markdown","f29e0a0d":"markdown","09e7ee25":"markdown","c351fd1d":"markdown","7329acfa":"markdown","8cec1c90":"markdown","a9c78ad4":"markdown","1de1cdb0":"markdown","1c857b73":"markdown","5c0b804e":"markdown","6bc19731":"markdown"},"source":{"c46ab884":"\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        \n\n#Data Analysis and Processing\n\nimport numpy as np \nimport pandas as pd \n\n\n# Visualization \nimport seaborn as sns\nimport matplotlib.pyplot as plt \nplt.rcParams.update({'font.size': 14})\nimport branca.colormap as cm\n\n\n# Machine Learning\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nimport torch\nimport torch.nn as nn\nfrom sklearn import preprocessing \nfrom sklearn.preprocessing import LabelEncoder","1828940f":"df = pd.read_csv('..\/input\/breast-cancer\/breast-cancer.csv')\ndf.head()","37767039":"df.dtypes","79b70f60":"df.info()","4763a162":"df.shape","f34a6018":"df.duplicated().sum()","e3d3fcfa":"df.isnull().sum()","d245b710":"df.isna().sum()","61cd191a":"df.drop(['id','Unnamed: 32'],axis=1,inplace=True)","a69b475b":"df.head()","c5b9211e":"df.describe()","4df62c3c":"sns.set_style(\"white\")\nsns.set_palette(\"spring\")\nplt.figure(figsize = (8,4))\nsns.countplot(df['diagnosis']);\n","1aa4a8aa":"# Values of 'Benign' and 'Malignant' cancer cells\ndf.diagnosis.value_counts()","eaf0437e":"#sns.set_palette(\"pink\")\n#plt.rcParams.update({'font.size': 12})\nsns.set_style(\"whitegrid\")\ndf.hist(bins=40, figsize=(30, 30), color='hotpink');","8a9f47e6":"plt.figure(figsize=(35, 25))\nsns.heatmap(df.corr(),annot=True);","91cfbea6":"df.head(5)","5bcdafb8":"lab ={'B':0,'M':1}\ndf = df.replace({'diagnosis':lab})\ndf.head()","4354d8a4":"predictors = df.iloc[:, 2:31]\npredictors","1f4c7fd8":"labels = df.iloc[:, 0:1]\nlabels","e52c242f":"predictors_train, predictors_test, labels_train, labels_test = train_test_split(predictors,labels,test_size = 0.20)","119ace87":"print('Dimensions of the Predictors training dataset {}'.format(predictors_train.shape))\nprint('Dimensions of the Labels training dataset {}'.format(labels_train.shape))\nprint('Dimensions of the Predictors test dataset {}'.format(predictors_test.shape))\nprint('Dimensions of the Labels test dataset {}'.format(labels_test.shape))","3add8db2":"type(predictors_train)","26485ea2":"type(np.array(predictors_train))","c152a3ff":"type(np.array(labels_train))","024d133a":"predictors_train = torch.tensor(np.array(predictors_train), dtype=torch.float)","49dc4941":"labels_train = torch.tensor(np.array(labels_train), dtype = torch.float)","e0383d23":"df_tf = torch.utils.data.TensorDataset(predictors_train, labels_train)\ntype(df_tf)","bf5a3f3c":"train_loader = torch.utils.data.DataLoader(df_tf, batch_size=15, shuffle=True)","f8cb09ed":"classifier = nn.Sequential(\n  \n    nn.Linear(in_features=29, out_features=15),\n    nn.ReLU(),\n    nn.Linear(15, 15),\n    nn.ReLU(),\n    nn.Linear(15, 1),\n    nn.Sigmoid()\n)","8c7a0994":"#To visualize the structure of the neural network:\nclassifier.parameters","9ee6882a":"#Binary cross entropy calculation (after weights adjustment)\ncriterion = nn.BCELoss()","673983d7":"#Using Adam optimizer \noptimizer = torch.optim.Adam(classifier.parameters(), lr=0.001, weight_decay=0.0001)","a7c7b529":"for epoch in range(100):\n  run_loss = 0.\n\n  for data in train_loader:\n    inputs, labels = data\n    #print(inputs)\n    #print('-----')\n    #print(labels)\n    optimizer.zero_grad()\n\n    outputs = classifier(inputs) # classificador.forward(inputs)\n    error = criterion(outputs, labels)\n    error.backward()\n    optimizer.step() #gradient descent and updating weights\n\n    run_loss += error.item()\n  print('Epoch %3d: loss %.5f' % (epoch+1, run_loss\/len(train_loader)))","5b13f961":"#Visualizing the weights\nparams = list(classifier.parameters())\n#params","969d2d37":"#Weights in zero position - from input layer to the first internal layer\nw0 = params[0]\nw0.shape","25f8c9c7":"#print(w0)","ba03bf14":"#Bias between both internal layers\nbias0 = params[1]\nbias0.shape","326c5bb5":"bias1 = params[3]\nbias1.shape","28d669f7":"classifier.eval()","17db8c21":"type(predictors_test)","d10daf73":"predictors_test = torch.tensor(np.array(predictors_test), dtype=torch.float)","a721164b":"type(predictors_test)","9280ff66":"predictions = classifier.forward(predictors_test)","b4c46d5b":"predictions = np.array(predictions> 0.5)\npredictions","7dcdfb31":"labels_test","23da38c6":"acc_rate = accuracy_score(labels_test, predictions)\nacc_rate","13c6183e":"mat = confusion_matrix(labels_test, predictions)\nmat","6040728e":"sns.heatmap(mat, annot=True);","835d8e59":"!apt-get update && apt-get install tensorflow-model-server ","29ca9904":"!echo \"deb [arch=amd64] http:\/\/storage.googleapis.com\/tensorflow-serving-apt stable tensorflow-model-server tensorflow-model-server-universal\" | sudo tee \/etc\/apt\/sources.list.d\/tensorflow-serving.list && curl https:\/\/storage.googleapis.com\/tensorflow-serving-apt\/tensorflow-serving.release.pub.gpg | sudo apt-key add -","daeb0464":"!pip install tensorflow-gpu==2.0","1225304f":"!pip install requests","a6f64283":"import os\nimport json\nimport randomde\nimport requests\nimport subprocess","2a1b5679":"# Breast cancer prediction \n\n## The problem\nWe have several data on breast tumors with labels of malignant and benign. We want to predict the classification of a tumor using a set of data to accelarate the diagnosis and treatment of patients. \n\n## The solution\nTo solve this, the dataset will be analysed and a neural network model will be built to predict if a tumor is malignant or benign. \n\n## The Methodology\nTensorFlow api is the technology of choice to solve this problem. Torch library is going to be used to train the model and TensorFlow Serving will be used for deployment. ","1ec5da6b":"#### Deleting unnecessary data","528adf72":"Checking the correlation between the variables:","b5910300":"## Loading the Data and EDA","afac1408":"#### Defining data for prediction labels\n\nThe values we want to predict are in the column 'diagnosis' - these are the labels. We want to predict whether a tumor is malignant ('M') or benign ('B). All the other columns in the dataframe are the predictors for the model:","83b26852":"## ToDo: Model Deployment with TensorFlow Serving","ea1bc280":"## Train\/Test data and transformation to tensors","ca945a34":"##  Importing the Libraries","3a668f95":"## Implementing and Training the Model","ec15056d":"So far, the data is stored in a pandas dataframe:","3c1b4285":"## Preparing the data for Machine Learning","f29e0a0d":"### The dataset\n\nThe dataset contains 33 variables describing several information regarding breast tumours. The diagnosis is given as a binary variable in which M means malignant tumor and B means benign tumor.","09e7ee25":"#### Checking for null data and duplicates","c351fd1d":"Pytorch trains the models in mini-batches. There is a class named DataLoader to perform the iterations on the dataset. The batch_size parameter gives the number of samples considered when adjusting the weights of the model.  ","7329acfa":"## Adding libraries necessary for Deployment","8cec1c90":"We must transform it into an array:","a9c78ad4":"## Model Evalutation","1de1cdb0":"* There were 76 correct estimations for benign tumor and 4 wrong estimates\n* There were 31 correct estimations for malignant tumor and 3 wrong estimates","1c857b73":"#### Training the model","5c0b804e":"Changing the labels for diagnosis:\n","6bc19731":"Now, defining the nn model the following way:\n* Input features = 29 (we have 29 features in the predictors dataset). \n* Hidden (internal) layers with 15 neurons each\n* Output with one neuron, having output labels 0 (benign tumor) and 1 (malignant tumor)\n* (29+1)\/2 = 15\n* ReLU activation function for the internal layers\n* Sigmoid activation function for the output layer, returning a probability between 0 and 1"}}