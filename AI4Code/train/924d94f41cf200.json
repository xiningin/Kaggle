{"cell_type":{"399ae0d2":"code","cf3b5cc1":"code","a76edc9e":"code","f3e89b4f":"code","14dcd9d0":"code","275cd263":"code","9d5b7c4e":"code","e5e516d6":"code","8a46b0dd":"code","7cf82894":"code","30b71655":"code","74228b40":"code","f62fa931":"code","a0651cbc":"code","3f12684f":"code","c987d3ef":"code","8a8c0d25":"code","6c504264":"code","e4482a02":"code","b35a0cb4":"code","411231d0":"code","4bbb4ef9":"code","9793b1aa":"code","baa6627b":"code","2c3b2128":"code","b248b8e7":"code","df9f9f22":"code","01e7d8b5":"code","f30294c6":"code","b40e007f":"code","78d583f4":"code","8000e6a3":"code","38c8fbdc":"code","e87014d7":"code","313a04e7":"code","5c3396b2":"code","6bc7f3ac":"code","95ff4fe7":"code","ccf1141d":"code","5430ca3f":"code","509110d1":"code","06703261":"code","8435d53c":"code","e281ef02":"code","d985c6fa":"code","b22d4577":"code","af717fa0":"code","5a47353c":"code","3347c13b":"code","5351e4e7":"code","0ce567ed":"code","e146c99a":"code","76b29ee0":"code","5fbf6e21":"code","306feb9c":"code","584af2f7":"code","5fc25436":"code","5e95175d":"code","53f669f4":"code","d1536fb5":"code","c59c1469":"markdown","606e8f44":"markdown","26917038":"markdown","3e5b46de":"markdown","de206a1f":"markdown","c2031c30":"markdown","760b59d1":"markdown","1369724e":"markdown","36e00cd4":"markdown","c4b09789":"markdown","7ff965b2":"markdown","d1a5eb02":"markdown","da79e59a":"markdown","d734a03c":"markdown","a1136be8":"markdown","d9b0fa51":"markdown","ce74a7c6":"markdown","9661ebfc":"markdown","e4b57ec7":"markdown","2672d0cc":"markdown","80db8a77":"markdown","cf443e91":"markdown","0a384126":"markdown","f2ee9ec8":"markdown","d4ce104b":"markdown","178891dd":"markdown","3653447f":"markdown","c60ed7c0":"markdown","11c90c15":"markdown","e56b11f5":"markdown","7f1370d0":"markdown","625375a6":"markdown","6080340b":"markdown","1dfa3f04":"markdown","651439a5":"markdown","ec3627cc":"markdown","bdd5d26a":"markdown","9baf4f83":"markdown","2470a3c5":"markdown","a1762129":"markdown","dfbac3d3":"markdown","34c5b528":"markdown","1a5aa97a":"markdown","b0653c0a":"markdown","44cb3950":"markdown","bc6dfa49":"markdown","9d430499":"markdown","0539e36d":"markdown","519441e1":"markdown","55ce80de":"markdown","5ebcfa86":"markdown","8a15014a":"markdown","f99a05e6":"markdown","32e72906":"markdown","650b5c49":"markdown","2932920e":"markdown","5b154a80":"markdown","dda71f64":"markdown","819e7cc7":"markdown","182832bf":"markdown","078a50ef":"markdown","40e97531":"markdown","b99d9887":"markdown","8b664a80":"markdown","ae24cedf":"markdown","55c854f6":"markdown","8532ac94":"markdown","2890b4e7":"markdown","349ade1c":"markdown","b33f6869":"markdown","c7d1b281":"markdown","c6f54b79":"markdown","f3a9ffe4":"markdown","bbc39345":"markdown"},"source":{"399ae0d2":"import warnings\nwarnings.filterwarnings('ignore')\nimport numpy as np\nimport pandas as pd\nimport pandas_profiling \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_color_codes()\nsns.set(style=\"whitegrid\")\n%matplotlib inline\nfrom scipy.stats import zscore\nfrom sklearn import metrics\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\nfrom math import sqrt\n\nimport requests\nfrom io import StringIO\n\n#setting up for customized printing\nfrom IPython.display import Markdown, display\nfrom IPython.display import HTML\ndef printmd(string, color=None):\n    colorstr = \"<span style='color:{}'>{}<\/span>\".format(color, string)\n    display(Markdown(colorstr))\n    \n#function to display dataframes side by side    \nfrom IPython.display import display_html\ndef display_side_by_side(args):\n    html_str=''\n    for df in args:\n        html_str+=df.to_html()\n    display_html(html_str.replace('table','table style=\"display:inline;margin-left:50px !important;margin-right: 40px !important\"'),raw=True)","cf3b5cc1":"def distplot(figRows,figCols,xSize, ySize, data, features, colors, kde=True, bins=None):\n    f, axes = plt.subplots(figRows, figCols, figsize=(xSize, ySize))\n    \n    features = np.array(features).reshape(figRows, figCols)\n    colors = np.array(colors).reshape(figRows, figCols)\n    \n    for row in range(figRows):\n        for col in range(figCols):\n            if (figRows == 1 and figCols == 1) :\n                axesplt = axes\n            elif (figRows == 1 and figCols > 1) :\n                axesplt = axes[col]\n            elif (figRows > 1 and figCols == 1) :\n                axesplt = axes[row]\n            else:\n                axesplt = axes[row][col]\n            plot = sns.distplot(data[features[row][col]], color=colors[row][col], bins=bins, ax=axesplt, kde=kde, hist_kws={\"edgecolor\":\"k\"})\n            plot.set_xlabel(features[row][col],fontsize=20)","a76edc9e":"def scatterplot(rowFeature, colFeature, data):\n    f, axes = plt.subplots(1, 1, figsize=(10, 8))\n        \n    plot=sns.scatterplot(x=rowFeature, y=colFeature, data=data, ax=axes)\n    plot.set_xlabel(rowFeature,fontsize=20)\n    plot.set_ylabel(colFeature,fontsize=20)            ","f3e89b4f":"# orig_url='https:\/\/drive.google.com\/file\/d\/1ClBptsK3V5KgKXtK2GSRzFNAW7GnTPDW\/view?usp=sharing'\n# file_id = orig_url.split('\/')[-2]\n# file_id","14dcd9d0":"# dwn_url='http:\/\/drive.google.com\/uc?export=download&confirm=pAkV&id=' + file_id\n# url = requests.get(dwn_url)\n# url.text","275cd263":"electronics = pd.read_csv('..\/input\/ratings_Electronics.csv', names=['userId', 'productId', 'Rating','timestamp'], header=None)","9d5b7c4e":"electronics.head()","e5e516d6":"electronics.drop('timestamp', axis=1, inplace=True)","8a46b0dd":"electronics_groupby_users_Ratings = electronics.groupby('userId')['Rating']\nelectronics_groupby_users_Ratings = pd.DataFrame(electronics_groupby_users_Ratings.count())","7cf82894":"user_list_min50_ratings = electronics_groupby_users_Ratings[electronics_groupby_users_Ratings['Rating'] >= 50].index\nelectronics =  electronics[electronics['userId'].isin(user_list_min50_ratings)]","30b71655":"print('The total number of rows :', electronics.shape[0])\nprint('The total number of columns :', electronics.shape[1])","74228b40":"electronics.info()","f62fa931":"display(electronics.isna().sum().sort_values())\nprint('===================')\nprintmd('**CONCLUSION**: As seen from the data above, we conclude there are **\"No Missing\"** values in the data', color=\"blue\")","a0651cbc":"display(electronics[['Rating']].describe().transpose())","3f12684f":"print('Total unique users in the dataset', electronics['userId'].nunique())\nprint('Total unique products in the dataset', electronics['productId'].nunique())","c987d3ef":"pal = sns.color_palette(palette='Set1', n_colors=16)","8a8c0d25":"distplot(1, 1, 10, 7, data=electronics, features=['Rating'], colors=['blue'])","6c504264":"distplot(1, 1, 10, 7, data=electronics, features=['Rating'], colors=['red'], kde=False)","e4482a02":"electronics_groupby_products_Ratings = electronics.groupby('productId')['Rating']","b35a0cb4":"electronics_groupby_products_Ratings.count().clip(upper=30).unique()","411231d0":"ratings_products = pd.DataFrame(electronics_groupby_products_Ratings.count().clip(upper=30))\nratings_products.rename(columns={\"Rating\": \"Rating_Count\"}, inplace=True)","4bbb4ef9":"distplot(1, 1, 10, 7, data=ratings_products, features=['Rating_Count'], colors=['green'], kde=False)","9793b1aa":"electronics_groupby_users_Ratings = electronics.groupby('userId')['Rating']","baa6627b":"electronics_groupby_users_Ratings.count().clip(lower=50).unique()","2c3b2128":"rating_users = pd.DataFrame(electronics_groupby_users_Ratings.count().clip(lower=50, upper=300))\nrating_users.rename(columns={\"Rating\": \"Rating_Count\"}, inplace=True)","b248b8e7":"distplot(1, 1, 10, 7, data=rating_users, features=['Rating_Count'], colors=['orange'], kde=False, bins=50)","df9f9f22":"ratings = pd.DataFrame(electronics.groupby('productId')['Rating'].mean())\nratings.rename(columns={\"Rating\": \"Rating_Mean\"}, inplace=True)","01e7d8b5":"distplot(1, 1, 10, 7, data=ratings, features=['Rating_Mean'], colors=['brown'], kde=False, bins=50)","f30294c6":"ratings['Rating_Count'] = electronics.groupby('productId')['Rating'].count()","b40e007f":"scatterplot('Rating_Mean', 'Rating_Count', data=ratings)","78d583f4":"ratings = pd.DataFrame(electronics.groupby('userId')['Rating'].mean())\nratings.rename(columns={\"Rating\": \"Rating_Mean\"}, inplace=True)\ndistplot(1, 1, 10, 7, data=ratings, features=['Rating_Mean'], colors=['brown'], kde=False, bins=50)","8000e6a3":"ratings['Rating_Count'] = electronics.groupby('userId')['Rating'].count()\nscatterplot('Rating_Mean', 'Rating_Count', data=ratings)","38c8fbdc":"train_data, test_data = train_test_split(electronics, test_size =.30, random_state=10)\nprintmd('**Training and Testing Set Distribution**', color='brown')\n\nprint(f'Training set has {train_data.shape[0]} rows and {train_data.shape[1]} columns')\nprint(f'Testing set has {test_data.shape[0]} rows and {test_data.shape[1]} columns')\n","e87014d7":"class popularity_based_recommender_model():\n    def __init__(self, train_data, test_data, user_id, item_id):\n        self.train_data = train_data\n        self.test_data = test_data\n        self.user_id = user_id\n        self.item_id = item_id\n        self.popularity_recommendations = None\n        \n    #Create the popularity based recommender system model\n    def fit(self):\n        #Get a count of user_ids for each unique product as recommendation score\n        train_data_grouped = train_data.groupby([self.item_id]).agg({self.user_id: 'count'}).reset_index()\n        train_data_grouped.rename(columns = {'userId': 'score'},inplace=True)\n    \n        #Sort the products based upon recommendation score\n        train_data_sort = train_data_grouped.sort_values(['score', self.item_id], ascending = [0,1])\n    \n        #Generate a recommendation rank based upon score\n        train_data_sort['Rank'] = train_data_sort['score'].rank(ascending=0, method='first')\n        \n        #Get the top 10 recommendations\n        self.popularity_recommendations = train_data_sort.head(20)\n\n    #Use the popularity based recommender system model to make recommendations\n    def recommend(self, user_id, n=5):    \n        user_recommendations = self.popularity_recommendations\n        \n        #Filter products that are not rated by the user\n        products_already_rated_by_user = self.train_data[self.train_data[self.user_id] == user_id][self.item_id]        \n        user_recommendations = user_recommendations[~user_recommendations[self.item_id].isin(products_already_rated_by_user)]\n        \n        #Add user_id column for which the recommendations are being generated\n        user_recommendations['user_id'] = user_id\n    \n        #Bring user_id column to the front\n        cols = user_recommendations.columns.tolist()\n        cols = cols[-1:] + cols[:-1]\n        user_recommendations = user_recommendations[cols].head(n)     \n        self.plot(user_recommendations)\n        return user_recommendations\n    \n    def plot(self, user_recommendations):\n        f, axes = plt.subplots(1, 2, figsize=(20, 8))\n        cplot1 = sns.barplot(x='Rank', y='score', data=user_recommendations, hue='Rank', ax=axes[0])\n        cplot1.set_xlabel('Rank',fontsize=20)\n        cplot1.set_ylabel('score',fontsize=20)            \n        cplot2 = sns.pointplot(x='Rank', y='score', data=user_recommendations, hue='Rank', ax=axes[1])\n        cplot2.set_xlabel('Rank',fontsize=20)\n        cplot2.set_ylabel('score',fontsize=20)\n        \n    def predict_evaluate(self):        \n        ratings = pd.DataFrame(self.train_data.groupby(self.item_id)['Rating'].mean())\n        \n        pred_ratings = [];            \n        for data in self.test_data.values:\n            if(data[1] in (ratings.index)):\n                pred_ratings.append(ratings.loc[data[1]])\n            else:\n                pred_ratings.append(0)\n        \n        mse = mean_squared_error(self.test_data['Rating'], pred_ratings)\n        rmse = sqrt(mse)\n        return rmse\n        \n        ","313a04e7":"pr = popularity_based_recommender_model(train_data=train_data, test_data=test_data, user_id='userId', item_id='productId')","5c3396b2":"pr.fit()","6bc7f3ac":"result_pop_user1 = pr.recommend('ANTN61S4L7WG9')\nresult_pop_user1","95ff4fe7":"result_pop_user2 = pr.recommend('AYNAH993VDECT')\nresult_pop_user2","ccf1141d":"result_pop_user3 = pr.recommend('A18YMFFJW974QS')\nresult_pop_user3","5430ca3f":"display_side_by_side([result_pop_user1, result_pop_user2, result_pop_user3])","509110d1":"pr.predict_evaluate()","06703261":"from surprise import accuracy\nfrom surprise.model_selection.validation import cross_validate\nfrom surprise.dataset import Dataset\nfrom surprise.reader import Reader\nfrom surprise import SVD\nfrom surprise import KNNBasic\nfrom surprise import KNNWithMeans\nreader = Reader()\nsurprise_data = Dataset.load_from_df(electronics, reader)","8435d53c":"from surprise.model_selection import train_test_split\ntrainset, testset = train_test_split(surprise_data, test_size=.3, random_state=10)","e281ef02":"from collections import defaultdict\n\ndef get_top_n(predictions, n=10):\n    # First map the predictions to each user.\n    top_n = defaultdict(list)\n    for uid, iid, true_r, est, _ in predictions:\n        top_n[uid].append((iid, est))\n\n    # Then sort the predictions for each user and retrieve the k highest ones.\n    for uid, user_ratings in top_n.items():\n        user_ratings.sort(key=lambda x: x[1], reverse=True)\n        top_n[uid] = user_ratings[:n]\n\n    return top_n","d985c6fa":"class collab_filtering_based_recommender_model():\n    def __init__(self, model, trainset, testset, data):\n        self.model = model\n        self.trainset = trainset\n        self.testset = testset\n        self.data = data\n        self.pred_test = None\n        self.recommendations = None\n        self.top_n = None\n        self.recommenddf = None\n\n    def fit_and_predict(self):        \n        printmd('**Fitting the train data...**', color='brown')\n        self.model.fit(self.trainset)       \n\n        printmd('**Predicting the test data...**', color='brown')\n        self.pred_test = self.model.test(self.testset)        \n        rmse = round(accuracy.rmse(self.pred_test), 3)\n        printmd('**RMSE for the predicted result is ' + str(rmse) + '**', color='brown')   \n        \n        self.top_n = get_top_n(self.pred_test)\n        self.recommenddf = pd.DataFrame(columns=['userId', 'productId', 'Rating'])\n        for item in self.top_n:\n            subdf = pd.DataFrame(self.top_n[item], columns=['productId', 'Rating'])\n            subdf['userId'] = item\n            cols = subdf.columns.tolist()\n            cols = cols[-1:] + cols[:-1]\n            subdf = subdf[cols]        \n            self.recommenddf = pd.concat([self.recommenddf, subdf], axis = 0)        \n        return rmse\n        \n    def cross_validate(self):\n        printmd('**Cross Validating the data...**', color='brown')\n        cv_result = cross_validate(self.model, self.data, n_jobs=-1)\n        cv_result = round(cv_result['test_rmse'].mean(),3)\n        printmd('**Mean CV RMSE is ' + str(cv_result)  + '**', color='brown')\n        return cv_result\n\n    def recommend(self, user_id, n=5):\n        printmd('**Recommending top ' + str(n)+ ' products for userid : ' + user_id + ' ...**', color='brown')\n        \n        #df = pd.DataFrame(self.top_n[user_id], columns=['productId', 'Rating'])\n        #df['UserId'] = user_id\n        #cols = df.columns.tolist()\n        #cols = cols[-1:] + cols[:-1]\n        #df = df[cols].head(n)\n        df = self.recommenddf[self.recommenddf['userId'] == user_id].head(n)\n        display(df)\n        return df\n        ","b22d4577":"from surprise.model_selection import RandomizedSearchCV\n\ndef find_best_model(model, parameters,data):\n    clf = RandomizedSearchCV(model, parameters, n_jobs=-1, measures=['rmse'])\n    clf.fit(data)             \n    print(clf.best_score)\n    print(clf.best_params)\n    print(clf.best_estimator)\n    return clf","af717fa0":"sim_options = {\n    \"name\": [\"msd\", \"cosine\", \"pearson\", \"pearson_baseline\"],\n    \"min_support\": [3, 4, 5],\n    \"user_based\": [True],\n}\nparams = { 'k': range(30,50,1), 'sim_options': sim_options}\nclf = find_best_model(KNNWithMeans, params, surprise_data)","5a47353c":"knnwithmeans = clf.best_estimator['rmse']\ncol_fil_knnwithmeans = collab_filtering_based_recommender_model(knnwithmeans, trainset, testset, surprise_data)","3347c13b":"knnwithmeans_rmse = col_fil_knnwithmeans.fit_and_predict()","5351e4e7":"knnwithmeans_cv_rmse = col_fil_knnwithmeans.cross_validate()","0ce567ed":"result_knn_user1 = col_fil_knnwithmeans.recommend(user_id='ANTN61S4L7WG9', n=5)\nresult_knn_user2 = col_fil_knnwithmeans.recommend(user_id='AYNAH993VDECT', n=5)\nresult_knn_user3 = col_fil_knnwithmeans.recommend(user_id='A18YMFFJW974QS', n=5)","e146c99a":"params= {\n    \"n_epochs\": [5, 10, 15, 20],\n    \"lr_all\": [0.002, 0.005],\n    \"reg_all\": [0.4, 0.6]\n}\nclf = find_best_model(SVD, params, surprise_data)","76b29ee0":"svd = clf.best_estimator['rmse']\ncol_fil_svd = collab_filtering_based_recommender_model(svd, trainset, testset, surprise_data)","5fbf6e21":"svd_rmse = col_fil_svd.fit_and_predict()","306feb9c":"svd_cv_rmse = col_fil_svd.cross_validate()","584af2f7":"result_svd_user1 = col_fil_svd.recommend(user_id='ANTN61S4L7WG9', n=5)\nresult_svd_user2 = col_fil_svd.recommend(user_id='AYNAH993VDECT', n=5)\nresult_svd_user3 = col_fil_svd.recommend(user_id='A18YMFFJW974QS', n=5)","5fc25436":"from surprise import NMF\nfrom surprise import KNNBaseline\nfrom surprise import KNNBasic\nfrom surprise import KNNWithZScore\nfrom surprise import BaselineOnly\nfrom surprise import CoClustering\nbenchmark = []\n# Iterate over all algorithms\nfor algorithm in [NMF(), KNNBaseline(), KNNBasic(), KNNWithZScore(), BaselineOnly(), CoClustering()]:\n    # Perform cross validation\n    results = cross_validate(algorithm, surprise_data, measures=['RMSE'], cv=5, verbose=False)\n    \n    # Get results & append algorithm name\n    tmp = pd.DataFrame.from_dict(results).mean(axis=0)\n    tmp = tmp.append(pd.Series([str(algorithm).split(' ')[0].split('.')[-1]], index=['Algorithm']))\n    benchmark.append(tmp)\n    \npd.DataFrame(benchmark).set_index('Algorithm').sort_values('test_rmse') ","5e95175d":"display_side_by_side([result_pop_user1, result_pop_user2, result_pop_user3])","53f669f4":"display_side_by_side([result_knn_user1, result_knn_user2, result_knn_user3])","d1536fb5":"display_side_by_side([result_svd_user1, result_svd_user2, result_svd_user3])","c59c1469":"### Observations\n\n**Rating** : This is can be considered as categorical attribute with values of (1,2,3,4,5). The mean rating is 4.26 which means most of the users have given very good ratings for the products i.e. many records with ratings above 4. This can be seen from the median (Q2), 75% (Q3) and max values as 5. Even 25% (Q1) value is 4.0. ","606e8f44":"**SVD** is better model compared to KNN or Popularity with a better RMSE value of **0.981**. We can also see the products that are recommended in SVD is different to that of KNNWithMeans as SVD uses matrix factorization. This is more useful when the data is sparse with many missing ratings. ","26917038":"**User-User Collaborative Filtering**\n\nTo find the rating R that a user U would give to an item I, the approach includes:\n\n1. Finding users similar to U who have rated the item I<br>\n2. Calculating the rating R based the ratings of users found in the previous step\n\nHere we are using KNN with means to remove the bias by taking into account the mean ratings of each user.","3e5b46de":"<a id=\"a7b3c\"><\/a>\n#### Fit and Predict","de206a1f":"<a id=\"a5d\"><\/a>\n## d. Mean Rating Distribution grouped by Products","c2031c30":"<a id=\"a4f\"><\/a>\n## f. 5 point summary of numerical attributes","760b59d1":"<a id=\"a8b2\"><\/a>\n### SVD Model","1369724e":"<a id=\"a7b3a\"><\/a>\n#### Find optimal model using RandomizedSearchCV","36e00cd4":"<a id=\"a4b\"><\/a>\n## b. Create subset of the original dataset","c4b09789":"The **Singular-Value Decomposition, or SVD** for short, is a matrix decomposition method for reducing a matrix to its constituent parts in order to make certain subsequent matrix calculations simpler. It provides another way to factorize a matrix, into singular vectors and singular values.\n\n$A = U . Sigma . V^T$","7ff965b2":"### Observations\n\n1. Many users have rated 5 as it is shown with the huge spike\n2. This is followed by rating 4 which also has high number\n3. Ratings 1, 2, 3 are comparatively less.","d1a5eb02":"<a id=\"a7b4f\"><\/a>\n#### Observations\n\nSVD (Singular Value Decomposition) model has an test RMSE value of **0.99** and cross validation RMSE value of **0.981**. Using this model we have a reduced RMSE value compared to KNNWithMeans.\n\nAS for the recommendations, **each user will have different products recommended to them** as they are infered by filling out missing entries in the matrix during matrix factorization using SVD.","da79e59a":"Popularity based recommendation system uses the items that are in trend right now. It ranks products based on its popularity i.e. the rating count. If a product is highly rated then it is most likely to be ranked higher and hence will be recommended. As it is based on the products popularity, this can not be personalized and hence same set of products will be recommended for all the users.","d734a03c":"<h1>Table of Contents<span class=\"tocSkip\"><\/span><\/h1>\n<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#Import-the-necessary-libraries\" data-toc-modified-id=\"Import-the-necessary-libraries-1\">Import the necessary libraries<\/a><\/span><\/li><li><span><a href=\"#Read-the-data-as-a-data-frame\" data-toc-modified-id=\"Read-the-data-as-a-data-frame-2\">Read the data as a data frame<\/a><\/span><\/li><li><span><a href=\"#Attributes-and-Information\" data-toc-modified-id=\"Attributes-and-Information-3\">Attributes and Information<\/a><\/span><\/li><li><span><a href=\"#Perform-basic-EDA\" data-toc-modified-id=\"Perform-basic-EDA-4\">Perform basic EDA<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#a.-Drop-'timestamp'-attribute\" data-toc-modified-id=\"a.-Drop-'timestamp'-attribute-4.1\">a. Drop 'timestamp' attribute<\/a><\/span><\/li><li><span><a href=\"#b.-Create-subset-of-the-original-dataset\" data-toc-modified-id=\"b.-Create-subset-of-the-original-dataset-4.2\">b. Create subset of the original dataset<\/a><\/span><\/li><li><span><a href=\"#c.-Shape-of-the-data\" data-toc-modified-id=\"c.-Shape-of-the-data-4.3\">c. Shape of the data<\/a><\/span><\/li><li><span><a href=\"#d.-Data-type-of-each-attribute\" data-toc-modified-id=\"d.-Data-type-of-each-attribute-4.4\">d. Data type of each attribute<\/a><\/span><\/li><li><span><a href=\"#e.-Checking-the-presence-of-missing-values\" data-toc-modified-id=\"e.-Checking-the-presence-of-missing-values-4.5\">e. Checking the presence of missing values<\/a><\/span><\/li><li><span><a href=\"#f.-5-point-summary-of-numerical-attributes\" data-toc-modified-id=\"f.-5-point-summary-of-numerical-attributes-4.6\">f. 5 point summary of numerical attributes<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-4.6.1\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#g.-Unique-Users-and-Products-Count\" data-toc-modified-id=\"g.-Unique-Users-and-Products-Count-4.7\">g. Unique Users and Products Count<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#Data-Analysis-and-Visualization\" data-toc-modified-id=\"Data-Analysis-and-Visualization-5\">Data Analysis and Visualization<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#a.-Rating-Distribution\" data-toc-modified-id=\"a.-Rating-Distribution-5.1\">a. Rating Distribution<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.1.1\">Observations<\/a><\/span><\/li><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.1.2\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#b.-Top-Rating-Count-Distribution-grouped-by-Products\" data-toc-modified-id=\"b.-Top-Rating-Count-Distribution-grouped-by-Products-5.2\">b. Top Rating Count Distribution grouped by Products<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.2.1\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#c.-Top-Rating-Count-Distribution-grouped-by-Users\" data-toc-modified-id=\"c.-Top-Rating-Count-Distribution-grouped-by-Users-5.3\">c. Top Rating Count Distribution grouped by Users<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.3.1\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#d.-Mean-Rating-Distribution-grouped-by-Products\" data-toc-modified-id=\"d.-Mean-Rating-Distribution-grouped-by-Products-5.4\">d. Mean Rating Distribution grouped by Products<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.4.1\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#e.-Mean-Rating---Rating-Count-Distribution-grouped-by-Products\" data-toc-modified-id=\"e.-Mean-Rating---Rating-Count-Distribution-grouped-by-Products-5.5\">e. Mean Rating - Rating Count Distribution grouped by Products<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.5.1\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#f.-Mean-Rating-Distribution-grouped-by-Users\" data-toc-modified-id=\"f.-Mean-Rating-Distribution-grouped-by-Users-5.6\">f. Mean Rating Distribution grouped by Users<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.6.1\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#g.-Mean-Rating---Rating-Count-Distribution-grouped-by-Users\" data-toc-modified-id=\"g.-Mean-Rating---Rating-Count-Distribution-grouped-by-Users-5.7\">g. Mean Rating - Rating Count Distribution grouped by Users<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-5.7.1\">Observations<\/a><\/span><\/li><\/ul><\/li><\/ul><\/li><li><span><a href=\"#Split-the-data-into-training-and-test-set-in-the-ratio-of-70:30-respectively\" data-toc-modified-id=\"Split-the-data-into-training-and-test-set-in-the-ratio-of-70:30-respectively-6\">Split the data into training and test set in the ratio of 70:30 respectively<\/a><\/span><\/li><li><span><a href=\"#Recommender-Systems\" data-toc-modified-id=\"Recommender-Systems-7\">Recommender Systems<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#a.-Popularity-Based-Recommender-Model\" data-toc-modified-id=\"a.-Popularity-Based-Recommender-Model-7.1\">a. Popularity Based Recommender Model<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Initialize\" data-toc-modified-id=\"Initialize-7.1.1\">Initialize<\/a><\/span><\/li><li><span><a href=\"#Fit\" data-toc-modified-id=\"Fit-7.1.2\">Fit<\/a><\/span><\/li><li><span><a href=\"#Recommend\" data-toc-modified-id=\"Recommend-7.1.3\">Recommend<\/a><\/span><\/li><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-7.1.4\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#b.-Collaborative-Filtering-Recommender-Model-using-SURPRISE-Library\" data-toc-modified-id=\"b.-Collaborative-Filtering-Recommender-Model-using-SURPRISE-Library-7.2\">b. Collaborative Filtering Recommender Model using SURPRISE Library<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Load-Surprise-Data-from-DataFrame\" data-toc-modified-id=\"Load-Surprise-Data-from-DataFrame-7.2.1\">Load Surprise Data from DataFrame<\/a><\/span><\/li><li><span><a href=\"#Split-the-data-into-training-and-test-set-in-the-ratio-of-70:30-respectively\" data-toc-modified-id=\"Split-the-data-into-training-and-test-set-in-the-ratio-of-70:30-respectively-7.2.2\">Split the data into training and test set in the ratio of 70:30 respectively<\/a><\/span><\/li><li><span><a href=\"#KNN-With-Means---Memory-Based-Collaborative-Filtering\" data-toc-modified-id=\"KNN-With-Means---Memory-Based-Collaborative-Filtering-7.2.3\">KNN With Means - Memory Based Collaborative Filtering<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Find-optimal-model-using-RandomizedSearchCV\" data-toc-modified-id=\"Find-optimal-model-using-RandomizedSearchCV-7.2.3.1\">Find optimal model using RandomizedSearchCV<\/a><\/span><\/li><li><span><a href=\"#Initialize\" data-toc-modified-id=\"Initialize-7.2.3.2\">Initialize<\/a><\/span><\/li><li><span><a href=\"#Fit-and-Predict\" data-toc-modified-id=\"Fit-and-Predict-7.2.3.3\">Fit and Predict<\/a><\/span><\/li><li><span><a href=\"#Cross-Validate\" data-toc-modified-id=\"Cross-Validate-7.2.3.4\">Cross Validate<\/a><\/span><\/li><li><span><a href=\"#Recommend\" data-toc-modified-id=\"Recommend-7.2.3.5\">Recommend<\/a><\/span><\/li><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-7.2.3.6\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#SVD---Model-Based-Collaborative-Filtering\" data-toc-modified-id=\"SVD---Model-Based-Collaborative-Filtering-7.2.4\">SVD - Model Based Collaborative Filtering<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Find-optimal-model-using-RandomizedSearchCV\" data-toc-modified-id=\"Find-optimal-model-using-RandomizedSearchCV-7.2.4.1\">Find optimal model using RandomizedSearchCV<\/a><\/span><\/li><li><span><a href=\"#Initialize\" data-toc-modified-id=\"Initialize-7.2.4.2\">Initialize<\/a><\/span><\/li><li><span><a href=\"#Fit-and-Predict\" data-toc-modified-id=\"Fit-and-Predict-7.2.4.3\">Fit and Predict<\/a><\/span><\/li><li><span><a href=\"#Cross-Validate\" data-toc-modified-id=\"Cross-Validate-7.2.4.4\">Cross Validate<\/a><\/span><\/li><li><span><a href=\"#Recommend\" data-toc-modified-id=\"Recommend-7.2.4.5\">Recommend<\/a><\/span><\/li><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-7.2.4.6\">Observations<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#Other-SURPRISE-algorithms\" data-toc-modified-id=\"Other-SURPRISE-algorithms-7.2.5\">Other SURPRISE algorithms<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Observations\" data-toc-modified-id=\"Observations-7.2.5.1\">Observations<\/a><\/span><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li><span><a href=\"#Conclusion\" data-toc-modified-id=\"Conclusion-8\">Conclusion<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Popularity-Based-Recommendation-Model\" data-toc-modified-id=\"Popularity-Based-Recommendation-Model-8.1\">Popularity Based Recommendation Model<\/a><\/span><\/li><li><span><a href=\"#Collaborative-Filtering-Recommendation-Model\" data-toc-modified-id=\"Collaborative-Filtering-Recommendation-Model-8.2\">Collaborative Filtering Recommendation Model<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#KNNWithMeans-Model\" data-toc-modified-id=\"KNNWithMeans-Model-8.2.1\">KNNWithMeans Model<\/a><\/span><\/li><li><span><a href=\"#SVD-Model\" data-toc-modified-id=\"SVD-Model-8.2.2\">SVD Model<\/a><\/span><\/li><\/ul><\/li><\/ul><\/li><li><span><a href=\"#END\" data-toc-modified-id=\"END-9\">END<\/a><\/span><\/li><\/ul><\/div>","a1136be8":"<a id=\"a7b5\"><\/a>\n### Other SURPRISE algorithms","d9b0fa51":"<a id=\"a7b3b\"><\/a>\n#### Initialize","ce74a7c6":"### Observations\n\nThis is a joint plot between Mean rating distribution and Rating Count grouped by all the Users. As shown in the plot, data is clustered between 3.5 to 5. There are many data points when the Rating count is less than 100 and the mean rating for the users is between 3.5 and 5","9661ebfc":"**Recommender systems** are algorithms aimed at suggesting relevant items to users (items being movies to watch, text to read, products to buy or anything else depending on industries). Recommender systems are really critical in some industries as they can generate a huge amount of income when they are efficient or also be a way to stand out significantly from competitors.\n\nWe have used 2 different types here,\n\n1. Popularity Based Recommender System\n2. Collaborative Filtering Recommender System\n\nBelow are the recommended results of same 3 users picked at random for all the models,","e4b57ec7":"<a id=\"a4d\"><\/a>\n## d. Data type of each attribute","2672d0cc":"<a id=\"a5\"><\/a>\n# Data Analysis and Visualization","80db8a77":"### Observations\n\nThis is a ratings count distribution grouped by all the Users. For the plot perspective, I have clipped the count limit between 50 to 300 which means any value below 50 or above 300 will be set to the respective values. \n\nAs it can been seen from the plot, there are many users which have rated 50 times or below. Ratings count by users gradually decreases which means few users have rated many products. ","cf443e91":"<a id=\"a7b4b\"><\/a>\n#### Initialize","0a384126":"<a id=\"a7a2\"><\/a>\n### Fit","f2ee9ec8":"<a id=\"a4c\"><\/a>\n## c. Shape of the data","d4ce104b":"Being popularity based recommender model, we have got the same result for all three users i.e. **the model is recommending same products for all the users** as shown below,","178891dd":"<a id=\"a7b4a\"><\/a>\n#### Find optimal model using RandomizedSearchCV","3653447f":"### Observations\n\nThis is a joint plot between Mean rating distribution and Rating Count grouped by all the Products. As shown in the plot, data is clustered between mean rating of 3.5 to 5. ","c60ed7c0":"<a id=\"a8b1\"><\/a>\n### KNNWithMeans Model","11c90c15":"<a id=\"a1\"><\/a>\n# Import the necessary libraries","e56b11f5":"<a id=\"a3\"><\/a>\n# Attributes and Information","7f1370d0":"1. **userId** : Every user identified with a unique id<br>\n2. **productId** : Every product identified with a unique id<br>\n3. **Rating** : Rating of the corresponding product by the corresponding user<br>\n4. **timestamp** : Time of the rating","625375a6":"<a id=\"a7b3e\"><\/a>\n#### Recommend","6080340b":"<a id=\"a7a3\"><\/a>\n### Recommend","1dfa3f04":"<a id=\"a7b5a\"><\/a>\n#### Observations\n\nLooking at the above result, we can say BaselineOnly model works well with the data as it is having the least RMSE score of 0.979.","651439a5":"**Filtering the users who has given 50 or more number of ratings**","ec3627cc":"Collaborative filtering is a method of making predictions about the interests of user by analysing the taste of users which are similar to the said user. The idea of filtering patterns by collaborating multiple viewpoints is why it is called collaborative filtering.","bdd5d26a":"<a id=\"a4\"><\/a>\n# Perform basic EDA","9baf4f83":"<a id=\"a4g\"><\/a>\n## g. Unique Users and Products Count","2470a3c5":"<a id=\"a6\"><\/a>\n# Split the data into training and test set in the ratio of 70:30 respectively","a1762129":"<a id=\"a7b4e\"><\/a>\n#### Recommend","dfbac3d3":"<a id=\"a7b4d\"><\/a>\n#### Cross Validate","34c5b528":"<a id=\"a8b\"><\/a>\n## Collaborative Filtering Recommendation Model","1a5aa97a":"<a id=\"a7b2\"><\/a>\n### Split the data into training and test set in the ratio of 70:30 respectively","b0653c0a":"<a id=\"a5a\"><\/a>\n## a. Rating Distribution","44cb3950":"<a id=\"a7b3f\"><\/a>\n#### Observations\n\n**KNN (K-Nearest Neighbours) With Means** model has an test RMSE value of **1.04** and cross validation RMSE value of **1.037**. \n\nAS for the recommendations, **each user will have different products recommended to them** as they are infered based on the ratings provided by the similar users. To find the similar users, KNN model uses **cosine similarity or Pearson's correlation** to find the nerghbours. ","bc6dfa49":"<a id=\"a4e\"><\/a>\n## e. Checking the presence of missing values","9d430499":"<a id=\"a5b\"><\/a>\n## b. Top Rating Count Distribution grouped by Products","0539e36d":"<a id=\"a7b3d\"><\/a>\n#### Cross Validate","519441e1":"**SVD (Singular Value Decomposition) model** has an test RMSE value of **0.99** and cross validation RMSE value of **0.981**. Each user will have different products recommended to them.","55ce80de":"### Observations\n\nThis is a mean rating distribution grouped by all the Users. This looks like slightly left skewed normal distribution.\n\nData is uniformly distribution from rating 3 to 5 with many around 4 to 4.5. Many users have an average rating of around 4.5. ","5ebcfa86":"<a id=\"a7a\"><\/a>\n## a. Popularity Based Recommender Model","8a15014a":"<a id=\"a5f\"><\/a>\n## f. Mean Rating Distribution grouped by Users","f99a05e6":"<a id=\"a7\"><\/a>\n# Recommender Systems","32e72906":"<a id=\"a7a1\"><\/a>\n### Initialize","650b5c49":"<a id=\"a2\"><\/a>\n# Read the data as a data frame","2932920e":"<a id=\"a5g\"><\/a>\n## g. Mean Rating - Rating Count Distribution grouped by Users","5b154a80":"<a id=\"a7b3\"><\/a>\n### KNN With Means - Memory Based Collaborative Filtering","dda71f64":"**Trying with three different Users**","819e7cc7":"A recommender system is a simple algorithm whose aim is to provide the most relevant information to a user by discovering patterns in a dataset. The algorithm rates the items and shows the user the items that they would rate highly.","182832bf":"<a id=\"a7b4c\"><\/a>\n#### Fit and Predict","078a50ef":"<a id=\"a4a\"><\/a>\n## a. Drop 'timestamp' attribute","40e97531":"### Observations\n\nThis is a mean rating distribution grouped by all the Products.\n\nAs it can been seen from the plot, there are many products which were given a Rating of 4 or 5. Hence the plot shows lot of bins between 4 and 5. ","b99d9887":"<a id=\"a8a\"><\/a>\n## Popularity Based Recommendation Model","8b664a80":"### Observations\n\n1. Many users have rated 5 as it is shown with the huge spike with a value of more than 70k records.\n2. This is followed by rating 4 which also has high number with a value of mroe than 30k records.\n3. More than 10k users have rated 3.\n4. Rating 1 and 2 have been rated below 10k records.","ae24cedf":"<a id=\"a7b4\"><\/a>\n### SVD - Model Based Collaborative Filtering","55c854f6":"<a id=\"a5c\"><\/a>\n## c. Top Rating Count Distribution grouped by Users","8532ac94":"# END","2890b4e7":"<a id=\"a7a4\"><\/a>\n### Observations\n\nSince this is a popularity based recommender model, we are getting same result for all three users i.e. **the model is recommending same products for all the users**.","349ade1c":"<a id=\"a7b1\"><\/a>\n### Load Surprise Data from DataFrame","b33f6869":"<a id=\"a8\"><\/a>\n# Conclusion","c7d1b281":"<a id=\"a7b\"><\/a>\n## b. Collaborative Filtering Recommender Model using SURPRISE Library","c6f54b79":"**KNN (K-Nearest Neighbours) With Means** model has an test RMSE value of **1.04** and cross validation RMSE value of **1.037. Each user will have different products recommended to them** as they are infered based on the ratings provided by the similar users.","f3a9ffe4":"### Observations\n\nThis is a ratings count distribution grouped by all the Products. For the plot perspective, I have clipped the upper limit to 30 which means any value above 30 will be set to it. \n\nAs it can been seen from the plot, there are many products which were rated only once i.e. only one user have rated. And then the count decreases.","bbc39345":"<a id=\"a5e\"><\/a>\n## e. Mean Rating - Rating Count Distribution grouped by Products"}}