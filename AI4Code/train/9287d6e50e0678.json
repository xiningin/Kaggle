{"cell_type":{"1f6beb0c":"code","c97461ff":"code","00bca669":"code","c0509dab":"code","a663eb05":"markdown","ebd4231f":"markdown","822249b2":"markdown"},"source":{"1f6beb0c":"import os\nimport glob\nimport pydicom\nimport numpy as np\nimport cv2\nfrom tqdm import tqdm\nimport math\nimport pandas as pd","c97461ff":"def load_slices(patient, mri_type='FLAIR'):\n    sorted_imgs = sorted(glob.glob('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/'+patient+'\/'+ mri_type + '\/*.dcm'))\n    slices = [pydicom.read_file(s) for s in sorted_imgs]\n    return slices\n\ndef get_pixels_hu(slices):\n    '''\n    Convert pixels to hounsfield units (IMPLEMENTATION SPECIFIC)\n    '''\n    image = np.stack([s.pixel_array for s in slices])\n    image = image.astype(np.int16)\n    image[image == -2000] = 0\n    for slice_number in range(len(slices)):\n        intercept = slices[slice_number].RescaleIntercept\n        slope = slices[slice_number].RescaleSlope\n        if slope != 1:\n            image[slice_number] = slope * image[slice_number].astype(np.float64)\n            image[slice_number] = image[slice_number].astype(np.int16)\n        image[slice_number] += np.int16(intercept)\n    return np.array(image, dtype=np.int16)\n\ndef remove_blanks(hu_images):\n    blanked_images = []\n    for i in range(hu_images.shape[0]):\n        if np.min(hu_images[i]) != np.max(hu_images[i]):\n            blanked_images.append(hu_images[i])\n    return np.array(blanked_images, dtype=np.int16)","00bca669":"# loading labels\nmri_type = 'FLAIR'\nlabels_df = pd.read_csv('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train_labels.csv', converters={'BraTS21ID': lambda x: str(x)})\nlabels_df = labels_df.set_index('BraTS21ID')\npatients = os.listdir('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train')\n\nfor patient in tqdm(patients):\n    output = []\n    slices = load_slices(patient)\n    if len(slices) < 10:\n        continue\n    images = get_pixels_hu(slices)\n    images = remove_blanks(images)\n    im = []\n    for j in range(images.shape[0]):\n        im.append(cv2.resize(images[j], (256, 256)))\n    images = np.array(im)\n    # DO PREPROCESSING AUGMENTATION CALLS HERE\n    \n    label = labels_df._get_value(patient, 'MGMT_value')\n    # Change label shape depending on your loss function\n    if label == 1:\n        label = np.array(1)\n    elif label == 0:\n        label = np.array(0)\n        \n    output.append([images, label])\n    all_data_numpy = np.array(output)\n    filename = patient + '.npy'\n    np.save(filename, all_data_numpy)","c0509dab":"from torch.utils.data import Dataset\nclass NpData(Dataset):\n    def __init__(self, test=False):\n        self.patients = os.listdir('.') \n        if test == True:\n            self.patients = self.patients[-50:]\n        else:\n            self.patients = self.patients[:-50]\n        \n    def __len__(self):\n        return len(self.patients)\n    \n    def __getitem__(self, x):\n        patient = self.patients[x]\n        # Images in data directory\n        filename = '.\/data\/'+ patient\n        image = np.load(filename, allow_pickle=True)\n        \n        images = image[0][0]\n        \n        images = torch.from_numpy(images)\n        \n        images = torch.reshape(images, (1, 64, 256, 256))\n        \n        label = image[0][1].item()\n        label = torch.tensor(abs(label), dtype=torch.float)\n        \n        return images, label","a663eb05":"# Move these to a directory ","ebd4231f":"# Preprocessing and saving images as numpy(.npy) for training models faster \nFor those who're still loading dcm images in the DataLoader\n\n\nSave preprocessed numpy images","822249b2":"### Saving loop"}}