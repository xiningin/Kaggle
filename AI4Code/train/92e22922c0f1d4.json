{"cell_type":{"1a28f42d":"code","f75d88d4":"code","a2055360":"code","2a7df789":"code","835d1e86":"code","7ce0ed7e":"code","1dccc3c4":"code","2bb15259":"code","c0517eb8":"code","1efa5645":"code","d1597ae1":"code","e59f2134":"code","18561eb6":"code","a0463b24":"markdown","f596d37d":"markdown","3b7aa661":"markdown","aeeb3552":"markdown","ec4d089d":"markdown","ae9c7e96":"markdown","30c3e16b":"markdown","c2338117":"markdown","4ba317fe":"markdown","5ec074a2":"markdown","25ae6cce":"markdown","7756ce91":"markdown","ebe1497a":"markdown","dcced4a1":"markdown","f75f2f19":"markdown","02439286":"markdown"},"source":{"1a28f42d":"# Install required packages \n! pip install pyjanitor configparser\n","f75d88d4":"import numpy as np\nimport pandas as pd \nimport time\nfrom datetime import datetime, date, time, timedelta\nfrom IPython.display import display, HTML\nimport matplotlib.dates as mdates\nfrom sklearn.model_selection import GridSearchCV,ParameterGrid\nfrom IPython.display import display, HTML\nimport configparser\nimport janitor\nimport warnings\nwarnings.filterwarnings('ignore')\npd.set_option('display.max_rows',100)\n\nINITIAL_RECOVERED_PEOPLE = 1\nprevalencia = 0 \nR0 = 5.7\nDIAS_EN_REINFECTAR=5\n\n","a2055360":"# Calculate capacity of the health system - how many people could get medical care before national health system collapses.\n\n\"\"\"\n\"Antes de la crisis sanitaria, Espa\u00f1a dispon\u00eda de unas 4.500 camas UCI, capacidad que aument\u00f3 hasta las 8.000\"\nMadrid cuenta con 1.750 camas\nCatalu\u00f1a tiene 1.722 camas\nAndaluc\u00eda con 1.200 camas.\nCanarias cuenta con 595 camas.\nEuskadi con capacidad para 550 camas. \nCastilla-Le\u00f3n tiene 500 camas.\nArag\u00f3n con 300 camas.\nCastilla-La Mancha cuenta con 300 camas.\nGalicia tiene 274 camas.\nComunidad Valenciana con 254 plazas libres.\nNavarra con 156 camas. \nMurcia tiene 123 camas. \nBaleares con 120 camas.\nExtremadura cuenta con 100 camas.\nCantabria con 64 camas.\nAsturias cuenta con 61 camas. \nLa Rioja tiene 23 plazas. \nTOTAL = 8092\n\"\"\"\n\n\"De los 11.424 pacientes de Covid-19 ingresados en Madrid, seg\u00fan datos del Ministerio de Sanidad, 1.332 est\u00e1n en la UCI, un 11,7%.\"\n\"Si para una prevalencia de 10% (750000 personas para la comunidad de madrid)\"\n\n\nUCI_BEDS=8092 \n\n\nNEED_HOSPITAL_PERCENTAGE = 0.088 # from https:\/\/www.redaccionmedica.com\/secciones\/sanidad-hoy\/coronavirus-en-personal-sanitario-hospitalizacion-en-el-8-8-de-casos-9925\nNEED_UCI_PERCENTAGE = 0.05  # from https:\/\/www.elperiodico.com\/es\/sociedad\/20200316\/coronavirus-hospitalizados-graves-contagio-7891866\n\nHEALT_SYSTEM_CAPACITY = UCI_BEDS \/ NEED_HOSPITAL_PERCENTAGE \/ NEED_UCI_PERCENTAGE\nHEALT_SYSTEM_CAPACITY = int(HEALT_SYSTEM_CAPACITY)\n\nprint (\" health system capacity\" , HEALT_SYSTEM_CAPACITY ) \n","2a7df789":"def Get_Header(GENERACIONES,df,INITIAL_DATE = '2020-02-01'):\n    array_fechas = []\n    FECHA_INICIAL = datetime.strptime(INITIAL_DATE, \"%Y-%m-%d\")\n    modified_date = FECHA_INICIAL\n    NUM_GENERACIONES = range(1,GENERACIONES)\n    for generacion in NUM_GENERACIONES:\n        modified_date += timedelta(days=DIAS_EN_REINFECTAR)\n        array_fechas.append(datetime.strftime(modified_date, \"%Y-%m-%d\"))\n    df.columns = array_fechas\n    return df\n\ndef Calcular_Cuadro_Prevalencias( R0,\n                                 GENERACIONES,\n                                 ARRAY_PREVALENCIAS, \n                                 INITIAL_RECOVERED_PEOPLE=1,\n                                 INITIAL_DATE = '2020-02-01',\n                                 outbreaks_detection_thresold = 0  , \n                                 outbreaks_detection_efectivity_porcentage = 0, \n                                 INCREMENTO_SEMANAL = 0 ,\n                                 DEBUG=False):\n    if DEBUG : \n        print (f\"\"\" Calcular_Cuadro_Prevalencias infectados_en_esta_generacion {R0},{GENERACIONES},{ARRAY_PREVALENCIAS}, {INITIAL_RECOVERED_PEOPLE}, {INITIAL_DATE} ,{INCREMENTO_SEMANAL}\"\"\")\n    diccionario_prevalencias = {}\n    array=[]\n\n    for prevalencia in ARRAY_PREVALENCIAS : \n        infectados_en_esta_generacion = INITIAL_RECOVERED_PEOPLE\n        NUM_GENERACIONES = range(1,GENERACIONES)\n        array=[]\n        for generacion in NUM_GENERACIONES:\n            prevalencia_esta_iteracion =  min(45000000,np.sum(array)) \/ 45000000\n            if DEBUG : print (\"infectados_en_esta_generacion\",infectados_en_esta_generacion,R0,prevalencia,prevalencia_esta_iteracion)\n            # Si estamos por debajo del umbral de deteccion de brotes, aplicamos el outbreaks_detection_efectivity_porcentage, \n            # que disminuye efectivamente el R0\n            R0_esta_iteracion = R0 * ( 1 - outbreaks_detection_efectivity_porcentage) if infectados_en_esta_generacion < outbreaks_detection_thresold else R0\n            infectados_en_esta_generacion = int(infectados_en_esta_generacion * R0_esta_iteracion * max(0,( 1 - (prevalencia + prevalencia_esta_iteracion)) ) )\n            # Incrementos importados\n            infectados_en_esta_generacion += int (INCREMENTO_SEMANAL * DIAS_EN_REINFECTAR \/ 7 )\n            # A esta cantidad sumamos el incremento en esta generacion\n            array.append(infectados_en_esta_generacion)\n        diccionario_prevalencias['prevalencia ' + str(\"{:.1f}\".format(prevalencia)) + ' y R0 ' + str(R0)] = array\n    df = pd.DataFrame.from_dict(diccionario_prevalencias,'index')    \n    df = Get_Header(GENERACIONES,df,INITIAL_DATE)\n    df = df.astype(np.int64)\n    return df.T\n\n# Auxiliary functions\ndef interpolate_dataframe(df,freq):\n    if freq == 'H':\n        rng = pd.date_range(df.index.min(), df.index.max() + pd.Timedelta(23, 'H'), freq='H')\n    elif freq == 'D' :  \n        rng = pd.date_range(\n            datetime.strptime(str(df.index.min())[:10]+' 00:00:00', \"%Y-%m-%d %H:%M:%S\") ,\n            datetime.strptime(str(df.index.max())[:10]+' 00:00:00', \"%Y-%m-%d %H:%M:%S\"), \n            freq='D')\n        df.index = pd.to_datetime(df.index)  \n    df2 = df.reindex(rng)\n    df = df2\n    for column in df.columns :\n        s = pd.Series(df[column])\n        s.interpolate(method=\"quadratic\", inplace =True)\n        df[column] = pd.DataFrame([s]).T\n    df.index.name = 'Fecha'\n    return df\n\n\n# first execution\nGENERACIONES=8\nARRAY_PREVALENCIAS = np.linspace(0,0.70,8)\nARRAY_PREVALENCIAS\n\nfrom matplotlib import pyplot as plt    \nimport pandas as pd\nimport numpy as np\n\ndef Get_Chart(df, title=\"default\", xlabel=\"\" ):\n    fig = plt.figure(figsize=(8, 6), dpi=80)\n\n    for ca in df.columns:\n        plt.plot(df[ca])\n        plt.legend(df.columns)\n        fig.suptitle(title, fontsize=20)\n    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%b-%d'))\n    plt.gca().xaxis.set_major_locator(mdates.DayLocator(interval=7))\n    plt.xticks(rotation=45)\n    plt.gca().set_xlabel(xlabel)\n    return plt\n\ndef debug_Calcular_Cuadro_Prevalencias():\n# DEBUG\n    INITIAL_RECOVERED_PEOPLE  = 1000\n    R0_min             = 1.702 \n    GENERACIONES_BAJADA= 30 \n    ARRAY_PREVALENCIAS = [0.1]  \n    INITIAL_DATE  = '2020-07-01'\n    INCREMENTO_SEMANAL = 50\n\n    df_temp =  Calcular_Cuadro_Prevalencias( \n        R0                 = R0_min,\n        GENERACIONES       = GENERACIONES_BAJADA,\n        ARRAY_PREVALENCIAS = ARRAY_PREVALENCIAS,\n        INITIAL_RECOVERED_PEOPLE  = INITIAL_RECOVERED_PEOPLE,\n        INITIAL_DATE  = INITIAL_DATE    ,\n        DEBUG              = False, \n        INCREMENTO_SEMANAL = INCREMENTO_SEMANAL\n    )\n    return df_temp\n\n##debug_Calcular_Cuadro_Prevalencias()\nfrom datetime import date\nGENERACIONES=15\n\ndef calcular_prevision(**kwargs) :\n    \"\"\"Calcula la prevision en ciclos de subida y bajada\"\"\"\n    \"\"\"FINAL_DATE,\n    INITIAL_DATE,\n    INITIAL_RECOVERED_PEOPLE,\n    INITIAL_INFECTED_PEOPLE,\n    R0_max,\n    R0_min,\n    max_lockdown_thresold,\n    min_unlockdown_thresold):\n\"\"\"\n    FINAL_DATE                   = kwargs.pop('FINAL_DATE')\n    INITIAL_DATE                 = kwargs.pop('INITIAL_DATE')\n    INITIAL_RECOVERED_PEOPLE                 = kwargs.pop('INITIAL_RECOVERED_PEOPLE')\n    INITIAL_INFECTED_PEOPLE       = kwargs.pop('INITIAL_INFECTED_PEOPLE')\n    R0_max                            = kwargs.pop('R0_max')\n    R0_min                            = kwargs.pop('R0_min')\n    RO_calor                          = kwargs.pop('RO_calor',1.702 )\n    max_lockdown_thresold                        = kwargs.pop('max_lockdown_thresold')\n    min_unlockdown_thresold                        = kwargs.pop('min_unlockdown_thresold')\n    GENERACIONES_SUBIDA               = kwargs.pop('GENERACIONES_SUBIDA',16)\n    GENERACIONES_BAJADA               = kwargs.pop('GENERACIONES_BAJADA',22)\n    outbreaks_detection_thresold           = kwargs.pop('outbreaks_detection_thresold',7200)\n    outbreaks_detection_efectivity_porcentage       = kwargs.pop('outbreaks_detection_efectivity_porcentage',.25)\n    imported_cases_lockdown_weekly    = kwargs.pop('imported_cases_lockdown_weekly',20)\n    imported_cases_unlockdown_weekly = kwargs.pop('imported_cases_unlockdown_weekly',50)\n    DEBUG                             = kwargs.pop('DEBUG',False)\n\n\n\n    #DEBUG=True\n    \n    if DEBUG:  print(  f\"\"\"FINAL_DATE={FINAL_DATE},\n        INITIAL_DATE={INITIAL_DATE},\n        INITIAL_RECOVERED_PEOPLE={INITIAL_RECOVERED_PEOPLE},\n        INITIAL_INFECTED_PEOPLE={INITIAL_INFECTED_PEOPLE},\n        R0_max={R0_max},\n        R0_min={R0_min},\n        max_lockdown_thresold={max_lockdown_thresold},\n        min_unlockdown_thresold={min_unlockdown_thresold},\n        imported_cases_lockdown_weekly={imported_cases_lockdown_weekly},\n        imported_cases_unlockdown_weekly={imported_cases_unlockdown_weekly}\"\"\")\n    df_temp = pd.DataFrame()\n    df = pd.DataFrame(columns = ['Infected'])    \n    \n    #\n    while INITIAL_DATE < FINAL_DATE :\n\n        df_temp = pd.DataFrame()\n        PREVALENCIA = (INITIAL_INFECTED_PEOPLE + df.iloc[:,0].sum()) \/45000000\n        ARRAY_PREVALENCIAS = []\n        ARRAY_PREVALENCIAS.append(PREVALENCIA)\n\n        # Subida\n        # En verano cambian los par\u00e1metros\n        PERIODO_CALOR = ( INITIAL_DATE[5:] > '06-15' ) & ( INITIAL_DATE[5:] <  '09-15' )\n        R0_DESCONTADO_CALOR = min(R0_max,RO_calor) if PERIODO_CALOR else R0_max\n        #GENERACIONES_SUBIDA = 30       if PERIODO_CALOR else kwargs.pop('GENERACIONES_SUBIDA',16)\n\n        if DEBUG:  print(f\"\"\" subida INITIAL_RECOVERED_PEOPLE={INITIAL_RECOVERED_PEOPLE},\n            R0                 = {R0_DESCONTADO_CALOR} ,\n            GENERACIONES       = {GENERACIONES_SUBIDA} ,\n            ARRAY_PREVALENCIAS = {ARRAY_PREVALENCIAS}  ,\n            INITIAL_DATE  = {INITIAL_DATE} ,\n            df_shape           = {df.shape[0]}   \"\"\")\n        df_temp =  Calcular_Cuadro_Prevalencias( \n            DEBUG = False,\n            INITIAL_RECOVERED_PEOPLE                 = INITIAL_RECOVERED_PEOPLE                 ,\n            R0                                = R0_DESCONTADO_CALOR               ,\n            GENERACIONES                      = GENERACIONES_SUBIDA               ,\n            ARRAY_PREVALENCIAS                = ARRAY_PREVALENCIAS                ,\n            INITIAL_DATE                 = INITIAL_DATE                 ,\n            outbreaks_detection_thresold           = outbreaks_detection_thresold           ,\n            outbreaks_detection_efectivity_porcentage       = outbreaks_detection_efectivity_porcentage       ,\n            INCREMENTO_SEMANAL                = imported_cases_unlockdown_weekly  )  \n\n        # Borramos las siguientes\n        \n        df_temp['Infected'] = df_temp.iloc[:,0]\n        df_temp = df_temp[['Infected']]\n\n        HACEMOS_LA_BAJADA =df_temp['Infected'].max() > max_lockdown_thresold\n        if  df_temp[(df_temp['Infected'] > (max_lockdown_thresold*1) )].size > 0  :\n            FECHA_DESDE_LA_QUE_BORRAR = df_temp[(df_temp['Infected'] > (max_lockdown_thresold*1) )].index[0]\n            otro_index = [fecha for fecha in df_temp.index if fecha < FECHA_DESDE_LA_QUE_BORRAR ]\n            df_temp = df_temp.head(len(otro_index))\n\n            df_temp.dropna()\n            df_temp = df_temp.loc[~df_temp.index.duplicated(keep='last')]\n            df_temp = pd.DataFrame(df_temp)\n\n        df = pd.concat([df_temp,df])\n        df = df.sort_index()\n\n        INITIAL_RECOVERED_PEOPLE = df.iloc[-1]['Infected']\n        #df.Infected.iat[-1] += imported_cases_unlockdown_weekly\n        \n        # Bajada        \n        if HACEMOS_LA_BAJADA :           \n            PREVALENCIA = (INITIAL_INFECTED_PEOPLE + df.iloc[:,0].sum()) \/45000000\n            ARRAY_PREVALENCIAS = []\n            ARRAY_PREVALENCIAS.append(PREVALENCIA)\n            INITIAL_DATE = df.index[-1]\n            df_temp = pd.DataFrame()\n\n            if DEBUG:  print(f\"\"\" bajada INITIAL_RECOVERED_PEOPLE={INITIAL_RECOVERED_PEOPLE},\n                R0                 = {R0_min} ,\n                GENERACIONES       = {GENERACIONES_BAJADA} ,\n                ARRAY_PREVALENCIAS = {ARRAY_PREVALENCIAS}  ,\n                INITIAL_DATE  = {INITIAL_DATE} ,\n                df_shape           = {df.shape[0]}   \"\"\")\n            df_temp =  Calcular_Cuadro_Prevalencias(\n                DEBUG                        = False,\n                INITIAL_RECOVERED_PEOPLE            = INITIAL_RECOVERED_PEOPLE,\n                R0                           = R0_min,\n                GENERACIONES                 = GENERACIONES_BAJADA,\n                ARRAY_PREVALENCIAS           = ARRAY_PREVALENCIAS,\n                INITIAL_DATE            = INITIAL_DATE ,\n                outbreaks_detection_thresold      = outbreaks_detection_thresold ,\n                outbreaks_detection_efectivity_porcentage  = outbreaks_detection_efectivity_porcentage,\n                INCREMENTO_SEMANAL           = imported_cases_lockdown_weekly  )  \n\n            # Borramos las siguientes\n            df_temp['Infected'] = df_temp.iloc[:,0]\n            df_temp = df_temp[['Infected']]\n            if  df_temp[(df_temp['Infected'] < (min_unlockdown_thresold*1) )].size > 0  :\n                FECHA_DESDE_LA_QUE_BORRAR = df_temp[(df_temp['Infected'] < (min_unlockdown_thresold*1) )].index[0]\n                otro_index = [fecha for fecha in df_temp.index if fecha < FECHA_DESDE_LA_QUE_BORRAR ]\n                df_temp = df_temp.head(len(otro_index))\n                \n\n            df_temp = pd.DataFrame(df_temp)\n            df = pd.concat([df_temp,df])\n            df = df.sort_index()\n            INITIAL_RECOVERED_PEOPLE = df.iloc[-1]['Infected']\n            #return df,df_temp\n        INITIAL_DATE = df.index[-1]\n        #df.Infected.iat[-1] += imported_cases_unlockdown_weekly\n        if DEBUG:  print(f\"\"\" iteracion :  df_shape= {df.shape[0]}  ,INITIAL_DATE={INITIAL_DATE} , FINAL_DATE={FINAL_DATE}\"\"\")\n\n\n            \n    FECHA_DESDE_LA_QUE_BORRAR = FINAL_DATE\n    otro_index = [fecha for fecha in df.index if fecha <= FECHA_DESDE_LA_QUE_BORRAR ]\n    df = df.head(len(otro_index))\n\n    df = df[df > 0].dropna()\n    df = df.dropna()\n    df = df.loc[~df.index.duplicated(keep='last')]\n    if DEBUG:  print(f\"\"\" final :  df_shape= {df.shape[0]}  ,INITIAL_DATE={INITIAL_DATE} , FINAL_DATE={FINAL_DATE}\"\"\")\n    return df \n    \n\ndef debug_calcular_prevision():\n    \"\"\" Solo para depurar calcular_prevision()\"\"\"\n    \"\"\"\n    INITIAL_RECOVERED_PEOPLE           = 1000\n    INITIAL_INFECTED_PEOPLE = 4500000\n    R0_max                      = 5.7 \n    R0_min                      = 0.5\n    max_lockdown_thresold                  = HEALT_SYSTEM_CAPACITY \n    min_unlockdown_thresold                  = 10000\n    INITIAL_DATE           = '2020-07-01'\n    FINAL_DATE             = '2021-01-01'\n    \"\"\"\n    INITIAL_RECOVERED_PEOPLE =10000\n    INITIAL_INFECTED_PEOPLE=4500000\n    R0_max=5.7\n    R0_min=0.5\n    max_lockdown_thresold=30000\n    min_unlockdown_thresold=5000\n    FINAL_DATE   ='2020-07-25'\n    INITIAL_DATE ='2020-07-01'\n    imported_cases_lockdown_weekly=30\n    imported_cases_unlockdown_weekly=60\n\n    df = calcular_prevision(\n        FINAL_DATE = FINAL_DATE,\n        INITIAL_DATE = INITIAL_DATE,\n        INITIAL_RECOVERED_PEOPLE = INITIAL_RECOVERED_PEOPLE,\n        INITIAL_INFECTED_PEOPLE =  INITIAL_INFECTED_PEOPLE,\n        R0_max = R0_max,\n        R0_min =  R0_min,\n        max_lockdown_thresold =  max_lockdown_thresold,\n        min_unlockdown_thresold =  min_unlockdown_thresold,\n        imported_cases_lockdown_weekly    = imported_cases_lockdown_weekly,\n        imported_cases_unlockdown_weekly = imported_cases_unlockdown_weekly,\n        DEBUG=False)\n    return df\nmin_unlockdown_thresold=10000\n\n","835d1e86":"import pickle\nfrom tqdm.notebook import tqdm\n\n\narray_parametros = [\n    { \"descripcion\" : \"First wave prevalence, R0=5.7\"             , 'R0' : 5.7   , 'INITIAL_INFECTED_PEOPLE' : 0} ,\n    { \"descripcion\" : \"Current 10% prevalence, R0=5.13\"           , 'R0' : 5.7   , 'INITIAL_INFECTED_PEOPLE' : 4500000} ,\n    { \"descripcion\" : \"the above + social distancing , R0=3.590\"  , 'R0' : 3.989 , 'INITIAL_INFECTED_PEOPLE' : 4500000} ,\n    { \"descripcion\" : \"the above + face masks , R0=2.082\"         , 'R0' : 2.314 , 'INITIAL_INFECTED_PEOPLE' : 4500000} ,\n]\n\ndefault_grid_thresolds ={\"max_lockdown_thresold\": [\n                                                    2500000,\n                                                    1800000, \n                                                    1000000,\n                                                    750000,\n                                                    500000,\n                                                    250000,\n                                                    125000 ],\n                          \"min_unlockdown_thresold\": [20000,50000,100000,200000] } \n\n\ndf_array = []\n\ndict_default_values = {\n    \"INITIAL_RECOVERED_PEOPLE\"                  : 10000                        ,\n    \"R0_min\"                                    :     0.5                      ,\n    \"max_lockdown_thresold\"                     :  HEALT_SYSTEM_CAPACITY       , \n    \"min_unlockdown_thresold\"                   :  5000                        ,\n    \"INITIAL_DATE\"                              : '2020-07-01'                 ,\n    \"FINAL_DATE\"                                : '2021-07-01'                 ,\n    \"outbreaks_detection_thresold\"              :  7200                        , \n    \"outbreaks_detection_efectivity_porcentage\" :  .25                         , \n    \"imported_cases_unlockdown_weekly\"          :  50                          ,\n    \"imported_cases_lockdown_weekly\"            :  20         \n}\n\n \n        \ndef get_lockdown_days(df_temp,min_unlockdown_thresold):\n    df_interpolated=interpolate_dataframe(df_temp,'D')\n    #return df_interpolated.shape[0] - (df_interpolated['Infected'] - df_interpolated['Infected'].shift(1) > 0).sum()  \n    return ((df_interpolated['Infected'] - df_interpolated['Infected'].shift(1) < 0) & (df_interpolated['Infected'] > min_unlockdown_thresold)).sum()\nmax_lockdown_thresold = HEALT_SYSTEM_CAPACITY\n\nfor dict_escenario in array_parametros:\n    ## Juntamos los valores por defecto, y los que cambian cada vez.\n    param = {**dict_escenario, ** dict_default_values}\n    #print(param)\n\n    df_temp = pd.DataFrame()\n    df_temp = calcular_prevision(\n        FINAL_DATE                   = param['FINAL_DATE'                   ], \n        INITIAL_DATE                 = param['INITIAL_DATE'                 ], \n        INITIAL_RECOVERED_PEOPLE                 = param['INITIAL_RECOVERED_PEOPLE'                 ], \n        INITIAL_INFECTED_PEOPLE       = param['INITIAL_INFECTED_PEOPLE'       ],\n        R0_max                            = param['R0'                                ], \n        R0_min                            = param['R0_min'                            ], \n        max_lockdown_thresold                        = param['max_lockdown_thresold'                        ], \n        min_unlockdown_thresold                        = param['min_unlockdown_thresold'                        ],\n        imported_cases_lockdown_weekly    = param['imported_cases_lockdown_weekly'    ],\n        imported_cases_unlockdown_weekly = param['imported_cases_unlockdown_weekly' ],\n        DEBUG = False\n    )\n    df_temp\n    \n    df_temp = df_temp.astype(np.int64)\n    df_temp = df_temp.loc[~df_temp.index.duplicated(keep='last')]\n    infected_people = int(df_temp.astype(int).sum(axis=0))\n    #print(param['descripcion'], df_temp.tail(1).index[-1],\"suma: \" , suma)\n    df_array.append(df_temp) \n    DIAS_CONFINAMIENTO = get_lockdown_days(df_temp,param['min_unlockdown_thresold'])\n\n    plt = Get_Chart(df=interpolate_dataframe(df_temp,'D'), \n                    title = param['descripcion'] +\" \\n, \"+ str(infected_people\/1000000)[:4] + \"M infected \" +  str(DIAS_CONFINAMIENTO) + \", lockdown days.\" ) \n    plt.gca().xaxis.set_major_locator(mdates.DayLocator(interval=30))\n\n    ax = plt.gca()\n    ax.set_ylim([0,max_lockdown_thresold*2])\n    param = {}\n    \ndf  =  pd.concat(df_array)\n#df_temp","7ce0ed7e":"import matplotlib.pyplot as plt\nimport pandas as pd \nimport matplotlib.dates as mdates\n\ndef Get_Chart2(df, title=\"default\", xlabel=\"\", ax=None,f=None, color='r'):\n    if ax is None:\n        ax = plt.gca()\n    plt.axes(ax)\n    for ca in df.columns:\n        plt.plot(df[ca],color=color)\n        plt.legend(df.columns)\n        f.suptitle(title, fontsize=20)\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%b-%d'))\n    ax.xaxis.set_major_locator(mdates.DayLocator(interval=30))\n    plt.xticks(rotation=45)\n    plt.gca().set_xlabel(xlabel,horizontalalignment='center')\n    return plt\n\n\ndef get_results_multichart_simulacion2(f, axes,results_array,criterio,puesto,mejores_resultados=True,color='r'):\n    \"\"\" Obtiene los n puestos mejores por un criterio.\n    Selecciona los df y genera el array de graficos aosciado\"\"\"\n    df_results = pd.DataFrame(results_array)\n    for puesto in range(puesto): \n        df_results.sort_values(criterio, inplace=True,ascending=mejores_resultados)\n        row     = df_results.iloc[puesto]\n\n        ### Get Parameters from simulation\n        df_temp            = pd.DataFrame(row.df)\n        suma               = row.infected_people\n        lockdown_days      = row.lockdown_days\n        infected_people    = '%.2f' % ( row.infected_people \/1000000)\n        waves              = row['waves']\n        descripcion        = row['descripcion']\n        umbral_maximo      = row['max_lockdown_thresold']\n        umbral_minimo      = row['min_unlockdown_thresold']\n    \n        lugar = int(puesto) + int(1)\n\n\n        plt = Get_Chart2( ax=axes[puesto],f=f, df=interpolate_dataframe(df_temp,'D'), color=color,\n                    title  = f\"\"\"Scenario: {descripcion}. Top {lugar} results by: {criterio}\"\"\",\n                    xlabel = f\"\"\"infected: {infected_people} M.,  waves {waves}\nlockdown days: {lockdown_days},\nlock\/unlock thresolds:\n({umbral_maximo},{umbral_minimo})\"\"\")\n\n    return plt\n\ndef debug_get_results_multichart_simulacion2():\n    for criterio in ['lockdown_days','waves','infected_people']:\n        f, axes = plt.subplots(1 , 4 ,figsize=(16, 4), sharex=True)\n\n        get_results_multichart_simulacion2(f=f, axes=axes,results_array=results_array,\n                                 criterio =criterio,\n                                puesto=4\n                                )\nimport pickle\nfrom tqdm.notebook import tqdm\n\ndefault_grid_thresolds ={\"max_lockdown_thresold\": [\n                                                    2500000,\n                                                    1800000, \n                                                    1000000,\n                                                    750000,\n                                                    500000,\n                                                    250000,\n                                                    125000 ],\n                          \"min_unlockdown_thresold\": [20000,50000,100000,200000] } \n\ndef generate_results_simlation(dict_escenario, dict_default_values,parameter_grid = default_grid_thresolds) :\n    df_array = []\n\n    \n\n    grid = ParameterGrid(parameter_grid)\n\n     \n\n    results_array = [ ]\n\n    for grid_params in  tqdm(grid, desc= dict_escenario['descripcion']) : \n        params = {**grid_params, **dict_escenario, ** dict_default_values}\n        \n        if  params['max_lockdown_thresold'] <  params['min_unlockdown_thresold']          : continue\n        if (params['max_lockdown_thresold'] \/ params['min_unlockdown_thresold']) <= 2.50  : continue\n        if (params['max_lockdown_thresold'] - params['min_unlockdown_thresold']) < 25000  : continue        \n        # Si hay una situacion donde no puedas ir ni hacia arriba ni hacia abajo\n        if (params['max_lockdown_thresold'] \/ params['min_unlockdown_thresold']) <  params['R0'] \/ params['R0_min']   : continue\n        ## Juntamos los valores por defecto, y los que cambian cada vez.\n        this_iteration_result = {}\n        df_temp = pd.DataFrame()\n        df_temp = calcular_prevision(\n            INITIAL_DATE                      = params['INITIAL_DATE'                    ], \n            FINAL_DATE                        = params['FINAL_DATE'                      ], \n            INITIAL_RECOVERED_PEOPLE          = params['INITIAL_RECOVERED_PEOPLE'        ], \n            INITIAL_INFECTED_PEOPLE           = params['INITIAL_INFECTED_PEOPLE'         ],\n            R0_max                            = params['R0'                              ], \n            R0_min                            = params['R0_min'                          ], \n            max_lockdown_thresold             = params['max_lockdown_thresold'           ], \n            min_unlockdown_thresold           = params['min_unlockdown_thresold'         ],\n            imported_cases_lockdown_weekly    = params['imported_cases_lockdown_weekly'  ],  \n            imported_cases_unlockdown_weekly  = params['imported_cases_unlockdown_weekly']  \n            \n        )\n        # Prepare results\n        # Dataframe level\n        df_temp = df_temp.astype(np.int64)\n        df_temp = df_temp.loc[~df_temp.index.duplicated(keep='last')]\n        # Calculate results\n        infected_people = int(df_temp.astype(int).sum(axis=0))\n        df_temp['Diferencia'] =  df_temp['Infected'] - df_temp['Infected'].shift(1)\n\n        lockdown_days = get_lockdown_days(df_temp,params['min_unlockdown_thresold'])\n\n        waves = (( df_temp['Diferencia'] < 0) & (df_temp['Diferencia'].shift(1) > 0 )  ).sum()   \n        # Store results\n        this_iteration_result['escenario']                         = dict_escenario[\"escenario\"]\n        this_iteration_result['descripcion']                       = dict_escenario[\"descripcion\"]\n        this_iteration_result['max_lockdown_thresold']             = params['max_lockdown_thresold']\n        this_iteration_result['min_unlockdown_thresold']           = params['min_unlockdown_thresold']\n        this_iteration_result['lockdown_days']                     = lockdown_days\n        this_iteration_result['waves'    ]                         = waves\n        this_iteration_result['infected_people']                   = infected_people\n        this_iteration_result['R0']                                = params['R0']\n        this_iteration_result['R0_min']                            = params['R0_min']\n        this_iteration_result['INITIAL_DATE']                      = params['INITIAL_DATE']\n        this_iteration_result['FINAL_DATE']                        = params['FINAL_DATE']\n        this_iteration_result['INITIAL_RECOVERED_PEOPLE']          = params['INITIAL_RECOVERED_PEOPLE']\n        this_iteration_result['INITIAL_INFECTED_PEOPLE']           = params['INITIAL_INFECTED_PEOPLE']\n        this_iteration_result['imported_cases_lockdown_weekly']    = params['imported_cases_lockdown_weekly']\n        this_iteration_result['imported_cases_unlockdown_weekly']  = params['imported_cases_unlockdown_weekly']\n        this_iteration_result['df']                                = df_temp['Infected']\n          \n        #print(this_iteration_result)\n        results_array.append(this_iteration_result) \n    return results_array\n\ndef simulation_save_to_file(objeto,nombre_fichero):\n    pickle.dump(objeto, open(nombre_fichero, 'wb'))\n\n\n\ndef Generar_Datos_Conjunto_Escenarios(array_parametros,dict_default_values,title):\n    #display(HTML(f\"\"\"<h1 id='{title}'>{title}<\/h1>\"\"\"))\n    \n    all_results_array=[]\n    # Por cada escenario, generamos las respuestas, y obtenemos las mejores por     lockdown_days','waves','infected_people'\n    for i,escenario in  tqdm(enumerate(array_parametros), desc=\"Processing scenarios\") :\n        results_array = []    \n        results_array = generate_results_simlation(escenario,dict_default_values)\n        all_results_array += results_array\n        #print(\" Escenario: \"+ escenario['descripcion'])\n        simulation_save_to_file(results_array,\"\/tmp\/simulacion_\"+str(i)+\".pickle\")\n    simulation_save_to_file(all_results_array,\"\/tmp\/\"+title+\"last_scenary_all.pickle\")\n    \n\n    return all_results_array\n\n\ndef Generar_Graficos(results_array,escenario,criterio,color):\n    f, axes = plt.subplots(1 , 4 ,figsize=(16, 4), sharex=True)\n\n    get_results_multichart_simulacion2(f=f, axes=axes,results_array=results_array,\n                             criterio =criterio,\n                            puesto=4,color=color\n                            )\n\ndef Extraer_Escenario_From_Resultados(all_results_array,escenario,criterio,elementos=5):\n    \"\"\"Extraer los resultados de un escenario y un criterio\"\"\"\n    all_results_df   = pd.DataFrame(all_results_array)\n    df_escenario     = all_results_df.filter_on(f\"\"\"descripcion == '{escenario}'\"\"\"  )\n    array_criterios  = [ ]\n    criterios_order  = [ ]\n    if criterio == 'infected_people' :\n        array_criterios      =  [ 'infected_people', 'waves']\n        array_criterio_order =  [ True, True ]\n    elif  criterio == 'lockdown_days' :\n        array_criterios      =  [ 'lockdown_days' ,'infected_people' ]\n        array_criterio_order =  [ True, True]\n    elif criterio == 'waves' :\n        array_criterios      =  [ 'waves', 'infected_people' ]\n        array_criterio_order =  [ True, True] \n    df_escenario.sort_values(by = array_criterios,ascending=array_criterio_order ,inplace=True)\n    return df_escenario.head(elementos)    \n\nfrom matplotlib import cm,colors\ndef Mostrar_Resultados_Conjunto_Escenarios(all_results_array, ordenar='criterio'):\n    # Extraemos resultados\n    cmap = colors.ListedColormap(['tab:blue','tab:green','tab:brown'])    \n    lista_escenarios = pd.DataFrame(all_results_array).descripcion.unique()\n    if  ordenar == 'criterio': \n        ARRAY_CRITERIO=['infected_people','lockdown_days','waves']\n        for i,criterio in enumerate(ARRAY_CRITERIO):\n            color = cmap(i)\n            for escenario in  lista_escenarios:\n                escenario_results_array = Extraer_Escenario_From_Resultados(all_results_array,escenario,criterio,elementos=5)  \n                Generar_Graficos(escenario_results_array,escenario,criterio,color=color)\n    else :\n        for escenario in  lista_escenarios:\n            ARRAY_CRITERIO=['infected_people','lockdown_days','waves']\n            for i,criterio in enumerate( ARRAY_CRITERIO):\n                color = cmap(i)\n                escenario_results_array = Extraer_Escenario_From_Resultados(all_results_array,escenario,criterio,elementos=5)  \n                Generar_Graficos(escenario_results_array,escenario,criterio,color=color)       \n\n","1dccc3c4":"\nfacemasks_parameter_array = [\n    { \"escenario\": \"facemask\" , \"descripcion\" : \"First wave prevalence, R0=5.7\"             , 'R0' : 5.7   , 'INITIAL_INFECTED_PEOPLE' : 0} ,\n    { \"escenario\": \"facemask\" , \"descripcion\" : \"Current 10% prevalence, R0=5.13\"           , 'R0' : 5.7   , 'INITIAL_INFECTED_PEOPLE' : 4500000} ,\n    { \"escenario\": \"facemask\" , \"descripcion\" : \"the above + social distancing , R0=3.590\"  , 'R0' : 3.989 , 'INITIAL_INFECTED_PEOPLE' : 4500000} ,\n    { \"escenario\": \"facemask\" , \"descripcion\" : \"the above + face masks , R0=2.082\"         , 'R0' : 2.314 , 'INITIAL_INFECTED_PEOPLE' : 4500000} ,\n]\n\n\ndict_default_values ={\n    'FINAL_DATE'                                : '2021-07-01',\n    'INITIAL_DATE'                              : '2020-07-01',\n    \"R0_min\"                                    :  0.43       ,\n    \"INITIAL_RECOVERED_PEOPLE\"                  :  25000      ,\n    \"outbreaks_detection_thresold\"              :  7200       , \n    \"outbreaks_detection_efectivity_porcentage\" :  .25        ,    \n    \"imported_cases_lockdown_weekly\"            :  25         , \n    \"imported_cases_unlockdown_weekly\"          :  50 \n    }\n\nmascarillas = Generar_Datos_Conjunto_Escenarios(facemasks_parameter_array,dict_default_values,\"Facemask hypothesis\")\nMostrar_Resultados_Conjunto_Escenarios(mascarillas)\n","2bb15259":"array_parametros_airborne = [\n    { \"escenario\": \"airborne\" , \"descripcion\" : \"Airborne, 33% people wearing face masks, R0=1.84\" , 'R0' : 1.84 } ,\n    { \"escenario\": \"airborne\" , \"descripcion\" : \"Airborne, 50% people wearing face masks, R0=1.35\" , 'R0' : 1.35 } ,\n    { \"escenario\": \"airborne\" , \"descripcion\" : \"Airborne, 66% people wearing face masks, R0=1.07\" , 'R0' : 1.07 } ,\n    \n]\ndict_default_values ={\n 'FINAL_DATE'                   : '2021-07-01' ,\n 'INITIAL_DATE'                 : '2020-07-01' ,\n 'INITIAL_INFECTED_PEOPLE'       : 4500000      ,\n 'R0_min'                            : 0.43         ,\n 'INITIAL_RECOVERED_PEOPLE'                 : 25000        ,\n 'GENERACIONES_SUBIDA'               : 1           , \n 'GENERACIONES_BAJADA'               : 1           ,\n \"outbreaks_detection_thresold\"           :  7200        , \n \"outbreaks_detection_efectivity_porcentage\"       :  .25        , \n \"imported_cases_lockdown_weekly\"    :  25          , \n \"imported_cases_unlockdown_weekly\" :  50 }\n\nairborne = Generar_Datos_Conjunto_Escenarios(array_parametros_airborne,dict_default_values,\"Airbone transmission hypothesis\")\nMostrar_Resultados_Conjunto_Escenarios(airborne)\n","c0517eb8":"ESTIMACION_CASOS_ESPA\u00d1A_EN_UNA_GENERACION_INFECCION=26400\narray_parametros_estudio_vacaciones = [ \n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.1\" ,\"RO_calor\" : 1.10 ,  \"R0\" : 1.1} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.2\" ,\"RO_calor\" : 1.20  , \"R0\" : 1.2} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.3\" ,\"RO_calor\" : 1.30  , \"R0\" : 1.3} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.4\" ,\"RO_calor\" : 1.40  , \"R0\" : 1.4} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.5\" ,\"RO_calor\" : 1.50  , \"R0\" : 1.5} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.6\" ,\"RO_calor\" : 1.60  , \"R0\" : 1.6} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.7\" ,\"RO_calor\" : 1.70  , \"R0\" : 1.7} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.8\" ,\"RO_calor\" : 1.80  , \"R0\" : 1.8} ,\n { \"escenario\": \"vacations\" , \"descripcion\" : \"vacations R0=1.9\" ,\"RO_calor\" : 1.90  , \"R0\" : 1.9} \n]\n\ndict_default_values = {\n    \"R0_min\" : 0.5,\n    \"INITIAL_RECOVERED_PEOPLE\" : ESTIMACION_CASOS_ESPA\u00d1A_EN_UNA_GENERACION_INFECCION  ,\n    \"INITIAL_DATE\" : '2020-06-20'  ,\n    \"FINAL_DATE\"   : '2020-09-20'  ,\n    'GENERACIONES_SUBIDA' : 1 , 'GENERACIONES_BAJADA' : 1,\n    'INITIAL_INFECTED_PEOPLE' : 4500000  ,\n    'imported_cases_unlockdown_weekly' : 50,\n     \"imported_cases_lockdown_weekly\"    :  20     ,\n    \"outbreaks_detection_thresold\"           :  7200                         , \n    \"outbreaks_detection_efectivity_porcentage\"      :  .25                          \n    }\n        \nvacations = Generar_Datos_Conjunto_Escenarios(array_parametros_estudio_vacaciones,dict_default_values,\"Vacations\")\nMostrar_Resultados_Conjunto_Escenarios(vacations)\n","1efa5645":"# Caso Datos de Madrid\nCALCULATED_CURRENT_CASES_SPAIN=4500\n\narray_parametros_estudio_back_to_school = [ \n { \"escenario\"        : \"Back to school\" , \n  \"descripcion\"       : \"Back to school R0=1.5735\" ,\n  \"RO_calor\"          : 1.1  ,\n  \"INITIAL_RECOVERED_PEOPLE\" : CALCULATED_CURRENT_CASES_SPAIN,\n  \"R0\"                : 1.5735740836023167,\n  \"R0_min\" : 0.8059191283028387,\n} \n]\n\ndict_default_values = {\n    \"INITIAL_DATE\" : '2020-09-04'  ,\n    \"FINAL_DATE\"   : '2021-06-28'  ,\n    'GENERACIONES_SUBIDA' : 1 , 'GENERACIONES_BAJADA' : 1,\n    'INITIAL_INFECTED_PEOPLE' : 4500000  ,\n    \"outbreaks_detection_thresold\"           :  7200                         , \n    \"outbreaks_detection_efectivity_porcentage\"       :  .21                        , \n    \"imported_cases_unlockdown_weekly\" :  100                           ,\n    \"imported_cases_lockdown_weekly\"    :  30   \n    }\n\n        \ndefault_grid_thresolds ={\"max_lockdown_thresold\": [\n                                                    2500000,\n                                                    1800000, \n                                                    1000000,\n                                                    750000,\n                                                    500000,\n                                                    250000,\n                                                    125000 ],\n                          \"min_unlockdown_thresold\": [100000,200000,300000] } \n\nback_to_school = Generar_Datos_Conjunto_Escenarios(array_parametros_estudio_back_to_school,dict_default_values,\"Back to school\")\nMostrar_Resultados_Conjunto_Escenarios(back_to_school)\n","d1597ae1":"# Imported cases hypothesis\nCALCULATED_CURRENT_CASES_SPAIN=26400\n\narray_parametros_estudio_importacion = [ \n { \"escenario\" : \"Import\" ,   \"descripcion\" : \"Import 50 cases\/week R0=1.5\" ,\n    \"imported_cases_unlockdown_weekly\" : 50 ,  \"imported_cases_lockdown_weekly\"    :  20    } ,\n { \"escenario\" : \"Import\" ,   \"descripcion\" : \"Import 100 cases\/week R0=1.5\" ,\n  \"imported_cases_unlockdown_weekly\" : 100 ,   \"imported_cases_lockdown_weekly\" : 40 ,   }, \n { \"escenario\" : \"Import\" ,   \"descripcion\" : \"Import 500 cases\/week R0=1.5\" ,\n    \"imported_cases_unlockdown_weekly\" : 500 ,  \"imported_cases_lockdown_weekly\"    :  200  }, \n { \"escenario\" : \"Import\" ,   \"descripcion\" : \"Import 1000 cases\/week R0=1.5\" ,\n   \"imported_cases_unlockdown_weekly\" : 1000 ,   \"imported_cases_lockdown_weekly\" : 400}\n]\n      \n\n\ndict_default_values = {\n    \"R0_min\" : 0.5,\n    \"INITIAL_DATE\" : '2020-06-20'  ,\n    \"FINAL_DATE\"   : '2021-06-20'  ,\n    'GENERACIONES_SUBIDA' : 7 ,\n    'GENERACIONES_BAJADA' : 7,\n    'INITIAL_INFECTED_PEOPLE' : 4500000  ,    \n    \"outbreaks_detection_thresold\"           :  7200                         , \n    \"outbreaks_detection_efectivity_porcentage\"      :  .25                          , \n    \"RO_calor\"          : 1.23  , \n    \"INITIAL_RECOVERED_PEOPLE\" : CALCULATED_CURRENT_CASES_SPAIN,  \n    \"R0\"  : 1.4952 ,\n    }\n\n        \nimportacion = Generar_Datos_Conjunto_Escenarios(array_parametros_estudio_importacion,dict_default_values,\"Import\")\nMostrar_Resultados_Conjunto_Escenarios(importacion)\n\n","e59f2134":"# We keep best results only\nimport janitor\ndf = pd.concat([pd.DataFrame(mascarillas),pd.DataFrame(back_to_school),pd.DataFrame(airborne)])\ndf = df.drop('df', axis=1)\narray_results = []\nmedian_array = []\ndf_escenario=pd.DataFrame()\nfor escenario in df.descripcion.unique():\n    df_escenario = df.filter_on(f\"\"\"descripcion == '{escenario}'\"\"\"  )\n    criterio = ['infected_people', 'max_lockdown_thresold']\n    criterio_order = [True, True]\n    df_escenario.sort_values(by = criterio,ascending=criterio_order ,inplace=True)\n    df_escenario=df_escenario.head(3)\n    iter_dict=df_escenario[['lockdown_days','waves','infected_people','R0','max_lockdown_thresold','min_unlockdown_thresold']].median()\n    iter_dict['escenario'] = escenario\n    median_array.append(iter_dict)\n    \n    array_results.append(df_escenario)\n    \ndf =pd.concat(array_results)\nmedian_df = pd.DataFrame(median_array)\n\nmedian_df = median_df.set_index('escenario')\nmedian_df.sort_values(['R0'], inplace=True,ascending=[False])\n\n\nimport seaborn as sns\ndisplay(HTML(\"<h2>We study how much a parameter varies when we increases R0 <\/h2>\"))\n\nfig, ax = plt.subplots(1, 3, figsize=(16, 4))\ncolor='tab:cyan'\nsns.lineplot(ax=ax.flatten()[0] , x=\"R0\" ,  y=\"infected_people\", data=median_df,color=color )\nsns.lineplot(ax=ax.flatten()[1] , x=\"R0\" ,  y=\"lockdown_days\", data=median_df,color=color )\nsns.lineplot(ax=ax.flatten()[2] , x=\"R0\" ,  y=\"waves\", data=median_df ,color=color)\n\nfig, ax = plt.subplots(1, 2, figsize=(16, 4))\nsns.lineplot(ax=ax.flatten()[0] , x=\"R0\" ,  y=\"max_lockdown_thresold\", data=median_df ,color=color)\nsns.lineplot(ax=ax.flatten()[1] , x=\"R0\" ,  y=\"min_unlockdown_thresold\", data=median_df ,color=color)\n","18561eb6":"display(HTML(\"<h2>Summary chart<\/h2>\"))\n\nmedian_df[[   'R0',\n    'lockdown_days',\n    'waves',\n    'infected_people','max_lockdown_thresold','min_unlockdown_thresold']].style.format ({  c : \"{:20,.0f}\" for c in [\n    'lockdown_days',\n    'waves',\n    'infected_people','max_lockdown_thresold','min_unlockdown_thresold'] }).format ({ 'R0':  \"{:20,.3f}\"}).background_gradient(cmap='Blues')\n\n\n","a0463b24":"* # Hypothesis: Back to school numbers.\n<a id=\"6\"><\/a>\n\nThis hypothesis uses calculated data from Madrid and applies it to Spain size.\n\n","f596d37d":"# 3. Hypothesis: Wearing masks\n <a id=\"3\"><\/a>\n\nWe use the same R0 parameters from the last hypothesis, except that now we use lockdown policies.\n","3b7aa661":"## Computing grid of results\n\nFor each given scenario, we calculate it against a grid search parameter with n different thresolds for lockdown\/unlockdown.\n\n> Then, we select for each scenario, those thresolds that minimizes infected people, days of confinement, and number of waves .\n\n> ","aeeb3552":"# Hypothesis: Vacations. Is a second wave coming this summer ? \n<a id=\"5\"><\/a>\n \nWe extrapolate data regardings deaths in Madrid, agains an array of R0 values for summer temperature, to find out if there will be a second wave happening this summer, or holidays will be possible in Spain.\n\n","ec4d089d":"# Aggregate data\n<a id=\"8\"><\/a>\n\nWe use data from previous analisis, to draw conclussions.","ae9c7e96":"# COVID19 Second wave generator for Spain\n\nWe are going to buid a second wave generator for testing hypothesis. \n\nWe would like to clarify what is going to happen in Spain. \n\nWill be there more lockdowns ? Can we avoid it ?\n\n\n\n<div class=\"alert alert-block alert-info\">\nAn hypothesis has several scenarios. Every one of them has a diferent parameter set\n<\/div>\n<br>\n\nTable of contents:\n* [1. Calculate health system capacity](#1)   \n* [2. Calculate infected people for the next 12 months, without lockdown policies](#2)\n* [3. Hypothesis: Using face masks](#3)\n* [4. Hypothesis: Airborne virus](#4)\n    - [4.1 Remarks](#4.1)\n* [5. Hypothesis: Is a second wave coming this summer?](#5)\n    - [5.1 Remarks](#5.1)\n* [6. Hypothesis: Madrid numbers](#6)\n    - [6.1 Remarks](#6.1)\n* [7. Hypothesis: Imported cases. Can we re-open the airports](#7)\n    - [7.1 Remarks](#7.1)\n* [8. Hypothesis: Aggregated data](#8)\n* [9. Hypothesis: Final remarks](#9)\n","30c3e16b":"# 2. Calculate infected people for the next 12 months, without lockdown policies \n <a id=\"2\"><\/a>\n\nWe calculate a base line with the worst scenarios - null policy.\nWe just do a confinement when the number of infected people hits health system capacity. Then we keep the lockdown until we reach 5.000 infected people.\n\nWe have 4 R0 scenarios, no prevalence, facemask, social distancing...\n\nBy doing this we can measure the benefits of having lockdown policies vs this hypothesis.\n\n","c2338117":"## Simulation parameters\n\n\n\n| Parameter | meaning\n|---\t|---\t\t\n| INITIAL_DATE \t| Initial date \n| FINAL_DATE \t| Final date\n| INITIAL_RECOVERED_PEOPLE \t| Already recovered people\n| INITIAL_INFECTED_PEOPLE \t| Already infected people\n| R0_max \t| R0 with lockdown restrictions\n| R0_min \t| R0 without lockdown restrictions\n| R0_summer \t| R0 during summer\n| max_lockdown_thresold \t| Max infected people thresold that triggers lockdown measures.\n| min_unlockdown_thresold \t| Minimun infected people thresold that ends lockdown measures\n| outbreaks_detection_thresold \t| Maximun infected people thresold, for reaching their contacts and avoid local transmission.\n| outbreaks_detection_efectivity_porcentage | Percentage of infected contacts of an infected person that could be detected.\n| imported_cases_lockdown_weekly \t| Cases imported from other countries when there is a lockdown,  weekly rate. \n| imported_cases_unlockdown_weekly \t| Cases imported from other countries when not a lockdown,  weekly rate.\n\nOther non configurable parameters.\n\n - Begining\/end dates for holiday season .\n - People living in spain.\n - UCI beds\n","4ba317fe":"## Vacations. Is a second wave coming this summer ? - Remarks\n<a id=\"5.1\"><\/a>\n\nThis hypothesis has a great sensitivity in its input parameters.\n\n- When the temperature rises.\n\n- Facemask use\n\n- New outbreaks detection capacity.\n\n- Imported cases\n\n\nEven when we couldnt keep the R0 low, if we do a lockdown, we could keep low the number of infected people.\n","5ec074a2":"# Airbone hypothesis\n> <a id=\"4\"><\/a>\nThe hypothesis to consider here is that the dominant route for spreading the virus is airborne transmission.\n\nIt this hypothesis is true, then wearing facemaks would be a major factor.\n\nWe are following this article. https:\/\/www.pnas.org\/content\/early\/2020\/06\/10\/2009637117. \nR0's are calculated from the equations described there.\n\n\n","25ae6cce":"# Hypothesis: Imported cases.\n<a id=\"7\"><\/a>\n\nWe measure the impact of having different numbers of imported cases from other countries.\n\nAs tourism is the first income source for Spain, to decide wether we should re-open the airports or not is a critical issue.\n\n","7756ce91":"## Hypothesis: Imported cases - remarks\n<a id=\"7.1\"><\/a>\n\n\nThe number of infected people does not seem to be affected too much, when we modify the number of imported cases.\n\nBut the higher the imported cases, there will be more lockdown days. This would have great economic impact.\n\nAn obvious conclussion is that we should strengthen detection of new cases in airports.\n","ebe1497a":"* ## Hypothesis: Back to school numbers. Remarks \n<a id=\"6.1\"><\/a>\n\nDuring the next year we will probably see five or five additional waves. We should keep on wearing facemasks and having social distance measures. \n\nIt is unclear how many people get protected without antibodies, wich could improve the prevalence variation, changing the overall scene.\n\nAditionally, it is expected that new technological advances will be publicy available in the second part of the 12 month period, so final numbers could be actually lower than this prediction.\n","dcced4a1":"## Hypothesis Airborne - remarks\n<a id=\"4.1\"><\/a>\n\nIn this scenary, R0 is lower than in the previous ones. \n\nIt highlights the importance of wearing facemasks rather than doing home confinements.\n\n1. A mere +16% people wearing facemask, from 50% to 66%, would make the difference between a self extinguishing spread, or a second wave scenario.\n\n","f75f2f19":"# Final remarks\n<a id=\"9\"><\/a>\n\n- A **good lockdown policy** would be to prevents new outbreaks as soon as posible, by **having a low lockdown thresold**.\n\n- **Many small waves** scenarios are **prefereable**, to keep a low number of infected people.\n\n- With a sensible lockdown policy, the **\"damage\" could be taken in the lockdown days** dimension, **rather than in the infected people** dimension.\n\n- In most situations, **increasing the infectivity means more lockdown days**, but **not linearly more deaths**.\n\n- Different areas will have **different evolutions and paces**. In some counties a second wave could be avoided.\n\n- Maybe a \"**monthly lockdown**\" would be advisable. Eg: Last week of the month. A **foreseeable lockdown would help local bussiness** to anticipate and minimize the economic impact.\n","02439286":"# 1. Calculate health system capacity.\n<a id=\"1\">\n    \nWe calculate how many people could get infected witouh collapsing the health system.\n"}}