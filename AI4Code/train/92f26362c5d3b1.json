{"cell_type":{"59a6ea40":"code","ad3e77d7":"code","74b3b452":"code","fa801070":"code","a32f4253":"code","be821b7c":"code","69ad17c3":"code","90a16cd6":"code","69e83001":"code","5d2e531a":"code","a8bbddc3":"code","13bbb247":"code","7e188605":"code","754f031c":"code","48cd06c0":"code","592f4b8e":"code","8cf64389":"code","9173a8dc":"code","fd307797":"code","3669cca8":"code","63d0067d":"markdown","430f7b56":"markdown","4b19501a":"markdown","d438594d":"markdown","82e6840d":"markdown","835f5282":"markdown","95a78f75":"markdown","9d24e4f4":"markdown","b9a53766":"markdown","f740ba7f":"markdown","fd0bebb4":"markdown","dd5f92cf":"markdown"},"source":{"59a6ea40":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom numpy.linalg import norm\nfrom collections import Counter\nfrom time import time\nfrom matplotlib import collections  as mc\n\nsns.set_style('whitegrid')","ad3e77d7":"df = pd.read_csv(\"..\/input\/cities.csv\")  #dd for running on kaggle\n##df = pd.read_csv(\".\/input\/cities.csv\")  #dd my local location","74b3b452":"##dd df.head()","fa801070":"##dd plt.figure(figsize=(15, 10))\n##dd plt.scatter(df.X, df.Y, s=1)\n##dd plt.scatter(df.iloc[0: 1, 1], df.iloc[0: 1, 2], s=10, c=\"red\")\n##dd plt.grid(False)\n##dd plt.show()","a32f4253":"nb_cities = max(df.CityId)\nprint(\"Number of cities to visit : \", nb_cities)","be821b7c":"##dd df.tail()","69ad17c3":"#dd: change primes to prime_flags\ndef sieve_eratosthenes(n):\n    prime_flags = [False, False] + [True for i in range(n-1)]\n    p = 2\n    while (p * p <= n):\n        if (prime_flags[p] == True):\n            for i in range(p * 2, n + 1, p):\n                prime_flags[i] = False\n        p += 1\n    return prime_flags","90a16cd6":"prime_flags = np.array(sieve_eratosthenes(nb_cities)).astype(int)\ndf['Prime'] = prime_flags","69e83001":"#dd This is what Santa wants, but it is only applied to stepNumber % 10 == 0 cities ?!\n#dd  \"Not acceptable!\" - R'deer\n#dd This variable is only used in dist_matrix() below if penalize=True\npenalization = 0.1 * (1 - prime_flags) + 1","5d2e531a":"df.head()","a8bbddc3":"#dd Shows 179967 non-primes and 17802 primes\n##dd plt.figure(figsize=(15, 10))\n##dd sns.countplot(df.Prime)\n##dd plt.title(\"Prime repartition : \" + str(Counter(df.Prime)))\n##dd plt.show()","13bbb247":"#dd Change colors to green, red, and black(NP)\nplt.figure(figsize=(15, 10))\nplt.scatter(df[df['Prime'] == 0].X, df[df['Prime'] == 0].Y, s=1, alpha=0.3, c='green')\nplt.scatter(df[df['Prime'] == 1].X, df[df['Prime'] == 1].Y, s=1, alpha=0.7, c='red')\nplt.scatter(df.iloc[0: 1, 1], df.iloc[0: 1, 2], s=10, c=\"black\")\nplt.grid(False)\nplt.title('Visualisation of cities')\nplt.show()","7e188605":"# Put all the city corrdinates in an np array\ncoordinates = np.array([df.X, df.Y])","754f031c":"# Various routines\n\n# Assign a distance measure from city i to all others\ndef dist_array(coords_in, i, RightLeft=False):\n    begin = np.array([df.X[i], df.Y[i]])[:, np.newaxis]\n    # if RightLeft then scale\/reduce x,y coords\/distances\n    # that are more than some distance to the right of city i.\n    # This encourages not leaving cities far behind (on the right)\n    # and once on the right the path will have a general trend to the left.\n    if RightLeft:\n        # scale the X,Y values to be smaller if to the right of city i\n        coords_mod = coords_in.copy()\n        # Different values tried: 500.0, 700.0, 900.0, 600.0, 400.0, 250.0, 160.0, 40.0, 16.0, 20.0, 100.0\n        x_width = 600.0  # 600 is best so far\n        bound_right = begin[0] + x_width\n        x_far_right = 1.0*((coords_in[0] - bound_right) > 0.0)\n        coords_mod[0] = bound_right + (coords_mod[0]-bound_right)*(1.0-0.75*x_far_right)\n        coords_mod[1] = begin[1] + (coords_mod[1]-begin[1])*(1.0-0.50*x_far_right)\n        mat = coords_mod - begin\n    else:\n        mat =  coords_in - begin\n    return np.linalg.norm(mat, ord=2, axis=0)\n\n# return the index of the nearest available city\ndef get_next_city(dist, avail):\n    return avail[np.argmin(dist[avail])]\n\ndef plot_path(path, coordinates):\n    # Plot tour\n    lines = [[coordinates[: ,path[i-1]], coordinates[:, path[i]]] for i in range(1, len(path))]\n    lc = mc.LineCollection(lines, linewidths=2)\n    fig, ax = plt.subplots(figsize=(20,20))\n    ax.set_aspect('equal')\n    plt.grid(False)\n    ax.add_collection(lc)\n    ax.autoscale()\n    # add the North Pole location\n    plt.scatter(coordinates[0][0], coordinates[1][0], s=150, c=\"red\", marker=\"*\", linewidth=3)\n    # and first cities on the path\n    plt.scatter(coordinates[0][path[1:10]], coordinates[1][path[1:10]], s=15, c=\"black\")\n    plt.show()\n    \n# Calculate the Score, Carrots, Length (RR=True to select the Reindeer Rebellion scoring)\ndef get_score(path, coords, prime_flags, RR=False):\n    # RR=True calculates the Reindeer preferred scoring\n    score = 0\n    carrots = 0 \n    length = 0\n    steps_since_carrot = 0\n    for i in range(1, len(path)):\n        begin = path[i-1]\n        end = path[i]\n        distance = np.linalg.norm(coords[:, end] - coords[:, begin], ord=2)\n        length += distance\n        # Choose the scoring method:\n        if not RR:\n            # Usual scoring, is this one of the 10th-city steps?\n            if i % 10 == 0:\n                # if the starting city is prime then a carrot and no penalties\n                if prime_flags[begin]:\n                    carrots += 1\n                # if not prime, no carrot and a penalty\n                else:\n                    distance *= 1.1\n            score += distance\n        else:\n            # RR scoring\n            steps_since_carrot += 1\n            if prime_flags[end]:\n                # got carrots here!\n                carrots += 1\n                steps_since_carrot = 0\n            # any penalty?\n            if steps_since_carrot > 10:\n                distance *= (1.0 + 0.05*(steps_since_carrot - 10))\n            score += distance\n    return score, carrots, length","48cd06c0":"# Initialize the left_cities\n\n# All cities:\nNth = 1;  city_start = 1\n\n# Can use only every Nth city for quicker testing\n##Nth = 37; city_start = 1\n# primes: 1-0.09, 1+0.03\n#    Rudolph Score: 242742  Penalty frac:  0.79 %  Carrots: 57   Length: 240818 .\n#   Reindeer Score: 286664  Penalty frac: 19.03 %  Carrots: 492   Length: 240818 .\n# No prime considerations\n#    Rudolph Score: 243210 Penalty frac:  0.88 %  Carrots: 61  \n#   Reindeer Score: 287413 Penalty frac: 19.22 %  Carrots: 492 (all of them)\n\n# All odd cities - about twice as many carrots !\n##Nth = 50;  city_start = 1\n# All even cities - no carrots :(\n##Nth = 50;  city_start = 4\n\n# Select the cities desired\nleft_cities = np.array(df.CityId)[city_start: :Nth]\n\n# Or put in a know set of cities to test scoring\n# \"The carrot run\"\n##left_cities = np.array([2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67])\n# \"No carrots\"\n##left_cities = 2*np.array(list(range(1,20)))\n\nprint(\"Number of cities besides the NP: \", len(left_cities), \"  Total primes:\",\n      sum(prime_flags[left_cities]))","592f4b8e":"# Initialize the path, etc.\npath = [0]\ncurrent_city = 0\nstepNumber = 1\nt0 = time()\n\nif len(left_cities) < 15000:\n    show_every = 1000\nelse:\n    show_every = 10000\n\n# For Rudolph scoring:\n# factor to reduce prime distance to account for prime's no-penalty advantage\nprime_reduce = (1.0 - 0.09*prime_flags)\n# factor to increase prime distance when a prime doesn't matter (save them for when it matters)\nprime_increase = (1.0 + 0.03*prime_flags)\n\n# And loop though the cities\nwhile left_cities.size > 0:\n    if stepNumber % show_every == 0: # We print the progress of the algorithm\n        print(f\"Time elapsed : {time() - t0} - Number of cities left : {left_cities.size}\")\n    # Compute the distance matrix\n    ##distances = dist_array(coordinates, current_city, RightLeft=False) # same as Viel's\n    distances = dist_array(coordinates, current_city, RightLeft=True) # modified distances\n    # Encourage a prime every 10th city (%10==9) by reducing prime's distances\n    if stepNumber % 10 == 9:\n        distances = distances * prime_reduce  # reduce distance for primes\n    else:\n        distances = distances * prime_increase  # increase distance for primes\n    # Get the closest city and go to it\n    current_city = get_next_city(distances, left_cities)\n    # Update the list of not visited cities\n    left_cities = np.setdiff1d(left_cities, np.array([current_city]))\n    # Append the city to the path\n    path.append(current_city)\n    # Add one step\n    stepNumber += 1\n    \n# Add the North Pole and we're done\npath.append(0)\nprint(f\"Loop lasted {(time() - t0) \/\/ 60} minutes \")","8cf64389":"# Show the path\nplot_path(path, coordinates)","9173a8dc":"# Show the Rudolph Score results\nscore, carrots, length = get_score(path, coordinates, prime_flags, RR=False)\n# and without going back to the NP\nscore_noNP, dummy1, dummy2 = get_score(path[:-1], coordinates, prime_flags, RR=False)\n\nprint(\"Rudolph Score:\", int(score), \"   Carrots:\", carrots, \"   Length:\", int(length), \".\\n\" +\n      \" Penalty frac:\", int(10000*(score-length)\/length)\/100,\n      \"%   Final step to NP has distance \", int(score - score_noNP))\n","fd307797":"# Show the *** Reindeer Rebellion *** Score results\nscore, carrots, length = get_score(path, coordinates, prime_flags, RR=True)\n# and without going back to the NP\nscore_noNP, dummy1, dummy2 = get_score(path[:-1], coordinates, prime_flags, RR=True)\n\nprint(\"Reindeer Score:\", int(score), \"  Carrots:\", int(carrots), \"  Length:\", int(length), \".\\n\" +\n      \" Penalty frac:\", int(10000*(score-length)\/length)\/100,\n      \"%   Final step to NP has distance \", int(score - score_noNP))","3669cca8":"# Output the path to a file that we can submit\nif True:\n    submission = pd.DataFrame({\"Path\": path})\n    submission.to_csv(\"submission.csv\", index=None)","63d0067d":"# Reindeer Rebellion: Traveling Santa 2018\n### A Scoring change to avert a Reindeer strike\nThe Rudolph-proposed scoring method, while well-intentioned, gives too little weight to the Reindeer getting their prime-city-carrots, and so the Reindeer are proposing the following alternate scoring (with some talk of going on strike if it is not approved):\n\nAfter receiving carrots (at the North Pole and then at any Prime City regardless of step number) the Reindeer are happy and efficient for up to 10 steps; after that the Reindeer impose a penalty starting at 5% percent and increasing by 5% with each step until the Reindeer visit a prime city.\n[as suggested by **Ole Kr\u00f6ger** at https:\/\/www.kaggle.com\/c\/traveling-santa-2018-prime-paths\/discussion\/72389 ]\n\nFor example, if Reindeer leave the North Pole and encounter no Prime Cities they will take 10 steps arriving in the 10th city and then charge a 5% penalty to go to the 11th city, a 10% penalty to contune to the 12th city, a 15% penalty to the 13th, etc. Arriving at the 15th city (having charged a 25% penalty) if that City is Prime, then they will make the next 10 steps without penalty, arriving at city 25.\n\n### Why the Reindeer want the scoring changed\n\nThe new scoring is implemented below by: `get_score(path, coords, prime_flags, RR=False)` <br>\nThe `RR=False` gives the usual Rudolph scoring, and `RR=True` uses the Reindeer-proposed scoring. <br>\nTaking the path generated by the basic greedy algorithm (ignoring primeness) and scoring it with these gives: <br>\n* Rudolph Score: 1812602. ;    Carrots: 1786 ;    Length: 1796336.   Penalty\/Length ~ 0.91 % <br>\nThe overall penalty is a very small fraction of the length even though the Reindeer are getting very few carrots and will have to go large stretches with no carrots.\n* Reindeer Score: 2140304. ;  Carrots: 17802 ;  Length: 1796336.   Penalty\/Length ~ 19.1 % <br>\nHere the Reindeer get all their carrots but there are still long streches without carrots, as significantly indicated by the 19% penalty. Optimizing this score will put emphasis on giving the Reindeer their carrots uniformly thoughout the trip. \n\n","430f7b56":"## Now to the Algorithm\nThe contents of this section have been compacted and used below.","4b19501a":"### Summary of versions and outputs: <br>\n\n* Recommended Version:\n* **version 7**: include distance adjustments to primes based on `stepNumber % 10 == 9`. This is similar to (and a very slight improvement over) what Viel's result using penalization. <br>\nRudolph Score: 1811546 ;    Carrots: 2751 ;    Length: 1796014.   Penalty\/Length ~ 0.86 % <br>\nReindeer Score: 2125349. ;  Carrots: 17802 ;  Length: 1796014.   Penalty\/Length ~ 18.3 % <br>\n<br>\n* Other versions:\n* version 1 <br>\nSolution scored  1811964. <br>\nFinal step to NP has distance  4259 <br>\n* version 4 (same as Viel's but without any penalization in path selection, increased by 700ish): <br>\nSolution scored  1812602. with a length of  1796336 . <br>\nFinal step to NP has distance  2189. <br>\n* version 5,6: same path solution; comparing the scoring of the Rudolph and Reindeer methods: <br>\nRudolph Score: 1812602. ;    Carrots: 1786 ;    Length: 1796336.   Penalty\/Length ~ 0.9 % <br>\nReindeer Score: 2140304. ;  Carrots: 17802 ;  Length: 1796336.   Penalty\/Length ~ 19.1 % <br>\n<br>\n* versions 8-11: `dist_array()` is modified so that points that are more than X_width units to the right of city i have their x,y values (and hence distances) scaled w.r.t. city i by 0.25x, 0.50y to encourage not leaving points far to the right. This is supposed to cause the path to get to the right and then generally wander to the left where the NP is. <br>\n<br>\n   x_width: +++  Rudolph Score: 1811546    Carrots: 2751    Length: 1796014   Penalty\/Length ~ 0.86 % <br>\n   x_width: 900  Rudolph Score: 1811543    Carrots: 2751    Length: 1796012   Penalty\/Length ~ 0.86 % <br>\n   x_width: 700  Rudolph Score: 1810758    Carrots: 2760    Length: 1795395   Penalty\/Length ~ 0.85 % <br>\n   **x_width: 600 Rudolph Score: 1810034    Carrots: 2749    Length: 1794670   Penalty\/Length ~ 0.85 %** <br>\n   x_width: 500  Rudolph Score: 1812581    Carrots: 2755    Length: 1797040   Penalty\/Length ~ 0.86 % <br>\n   x_width: 400  Rudolph Score: 1810903    Carrots: 2761    Length: 1795567   Penalty\/Length ~ 0.85 % <br>\n   x_width: 250  Rudolph Score: 1811318    Carrots: 2749    Length: 1795979   Penalty\/Length ~ 0.85 % <br>\n   x_width: 160  Rudolph Score: 1813114    Carrots: 2741    Length: 1797953   Penalty\/Length ~ 0.84 % <br>\n   x_width: 100  Rudolph Score: 1811804    Carrots: 2674    Length: 1796233   Penalty\/Length ~ 0.86 % <br>\n   x_width: _40  Rudolph Score: 1816430    Carrots: 2688    Length: 1800851   Penalty\/Length ~ 0.86 % <br>\n   x_width: _20  Rudolph Score: 1815703    Carrots: 2757    Length: 1800129   Penalty\/Length ~ 0.86 % <br>\n   x_width: _16  Rudolph Score: 1817859    Carrots: 2676    Length: 1802083   Penalty\/Length ~ 0.87 % <br>\n<br>\n   x_width: +++  Reindeer Score: 2125349   Carrots: 17802   Length: 1796014   Penalty\/Length ~ 18.33 % <br>\n   x_width: 900  Reindeer Score: 2125370   Carrots: 17802   Length: 1796012   Penalty\/Length ~ 18.33 % <br>\n   x_width: 700  Reindeer Score: 2128203   Carrots: 17802   Length: 1795395   Penalty\/Length ~ 18.53 % <br>\n   **x_width: 600 Reindeer Score: 2125915   Carrots: 17802   Length: 1794670   Penalty\/Length ~ 18.45 %** <br>\n   x_width: 500  Reindeer Score: 2126214   Carrots: 17802   Length: 1797040   Penalty\/Length ~ 18.31 % <br>\n   x_width: 400  Reindeer Score: 2123749   Carrots: 17802   Length: 1795567   Penalty\/Length ~ 18.27 % <br>\n   x_width: 250  Reindeer Score: 2123493   Carrots: 17802   Length: 1795979   Penalty\/Length ~ 18.23 % <br>\n   X_width: 160  Reindeer Score: 2122414   Carrots: 17802   Length: 1797953   Penalty\/Length ~ 18.04 % <br>\n   X_width: 100  Reindeer Score: 2119948   Carrots: 17802   Length: 1796233   Penalty\/Length ~ 18.02 % <br>\n   X_width: _40  Reindeer Score: 2141576   Carrots: 17802   Length: 1800851   Penalty\/Length ~ 18.92 % <br>\n   X_width: _20  Reindeer Score: 2133879   Carrots: 17802   Length: 1800129   Penalty\/Length ~ 18.54 % <br>\n   X_width: _16  Reindeer Score: 2132361   Carrots: 17802   Length: 1802083   Penalty\/Length ~ 18.32 % <br>\n","d438594d":"# - - - - - - - End of Forked Kernel - - - - - - -","82e6840d":"This kernel was forked from the Viel's 'Greedy Reindeer', the beginning of which is left largely intact with deletions (\"##dd) and modifications ( \"#dd\") described in comments.  The later \"Now to the Algorithm\" and \"Results\" sections have been extensively borrowed from and made more compact.<br>\n\n###Notes\/Diary:  (some more details in version notes at end)<br>\n\n* 30 Nov 2018: Forked Viel's kernel, added intro, ran and tested submission(v1).<br>\nCompactified the code(v4). Implemented RR option for scoring (v5) and compared scores (v6).  <br>\n* 1 Dec 2018: (v7) Include distance adjustments for primes depending on stepNumber (only slightly different from Viel's penalization implementation). <br>\n* 1-2 Dec 2018: Try to improve the TSP (even slightly) by encouraging an overall right-to-left \"sweep\". Do this by reducing `dist_array()` distances that are more to the right of city i... Not very promising and wish I hadn't committed versions 8 to 10 ;-) Commit version 11 with the best (slight) improvement this scheme made, and take a time-out to learn more about TSP.<br>\n","835f5282":"## Getting Prime Cities","95a78f75":"## Loading Data","9d24e4f4":"## Results\nThe contents of this section have been compacted and used below.","b9a53766":"# - - - - - - - Greedy Reindeer - A Starter code... - Theo Viel - - - - - - -\n### Using a greedy algorithm to solve the problem\n\nPrime cities are taken into account","f740ba7f":"## More compact implementation of the path creation","fd0bebb4":"There are prime cities approximately all around the map. Which is a good thing as well.","dd5f92cf":"Almost a tenth of the cities is prime, which is a good because we want to visit prime a prime city every 10 cities."}}