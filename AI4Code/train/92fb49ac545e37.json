{"cell_type":{"ce68059a":"code","e2d3f2b6":"code","c5a8844d":"code","bfc1c318":"code","5e1848fa":"code","d4c2dd7e":"code","58545b04":"code","541844fb":"code","a77092b2":"code","0b1c28c2":"code","b89a1f07":"code","fce6a467":"code","537cccf6":"code","5dd5d129":"code","73328472":"code","c685bbee":"code","9edb1000":"code","95926f6e":"code","701f56d5":"code","7a118608":"code","638b2b5b":"code","e2675914":"code","20b3644c":"code","f19c38b8":"code","7f3b2cb4":"code","4d0dcdf7":"code","5ace15f5":"code","b662e0b1":"code","246924ff":"code","8eddae55":"code","a54959bf":"code","24cbb60f":"code","7269fa2b":"code","b7ac2b04":"code","a3df5ae7":"code","a282ada1":"code","431ba368":"code","34203faf":"code","ed00a4a9":"code","71d403e6":"code","82bb1369":"code","443df2d8":"code","a0fbf619":"code","54c10077":"code","6c586a86":"code","6ae47429":"code","fbe89060":"code","ed7c90ae":"code","26b59c36":"code","b73d55d8":"code","fdcdffe9":"code","68651866":"markdown","46f61f05":"markdown","007fa6b8":"markdown","97ef0488":"markdown","6c048ff3":"markdown","94b039e3":"markdown","8f75ee86":"markdown","b7f01b10":"markdown","55a21c2e":"markdown","7b35f488":"markdown","05628eda":"markdown","f80923f2":"markdown","1c18bc34":"markdown","311ae567":"markdown","c4854b71":"markdown","6f30348f":"markdown","f2e1aea4":"markdown","4a1d7c89":"markdown","f8e1ee02":"markdown","8a6fa78d":"markdown","d208b38d":"markdown","63534116":"markdown","d4f4ee6c":"markdown","6438be1b":"markdown","bc30dac2":"markdown","8cbabe46":"markdown","2b62f421":"markdown","284e48fe":"markdown","f5f8ef3e":"markdown","8ae38e9b":"markdown","d123be46":"markdown","b2c8c091":"markdown","270f38ea":"markdown","57a0c660":"markdown","90b543c8":"markdown","ac2000c2":"markdown","8da9ac55":"markdown","178b711c":"markdown","5974b1d9":"markdown","dc613110":"markdown","86a09e31":"markdown","ea69f316":"markdown","87881397":"markdown","ec36fb1c":"markdown"},"source":{"ce68059a":"!pip install selenium\n!pip install tweepy","e2d3f2b6":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport re\nimport time\nimport string\nimport warnings\n\n# for all NLP related operations on text\nimport nltk\nfrom nltk.corpus import stopwords\nfrom nltk.tokenize import sent_tokenize, word_tokenize\nfrom nltk.sentiment.vader import SentimentIntensityAnalyzer\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk.stem.porter import *\nfrom nltk.classify import NaiveBayesClassifier\nfrom wordcloud import WordCloud\n\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import f1_score, confusion_matrix, accuracy_score\nfrom sklearn.svm import SVC\nfrom sklearn.naive_bayes import GaussianNB\n\n\n# To consume Twitter's API\nimport tweepy\nfrom tweepy import OAuthHandler \n\n# To identify the sentiment of text\nfrom textblob import TextBlob\nfrom textblob.sentiments import NaiveBayesAnalyzer\nfrom textblob.np_extractors import ConllExtractor\n\n# For Deploy\nimport pickle\nfrom sklearn.feature_extraction.text import CountVectorizer \nfrom sklearn.pipeline import make_pipeline\nfrom nltk.tokenize import RegexpTokenizer\n\n# ignoring all the warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\n# downloading stopwords corpus\nnltk.download('stopwords')\nnltk.download('wordnet')\nnltk.download('vader_lexicon')\nnltk.download('averaged_perceptron_tagger')\nnltk.download('movie_reviews')\nnltk.download('punkt')\nnltk.download('conll2000')\nnltk.download('brown')\nstopwords = set(stopwords.words(\"english\"))\n\n# for showing all the plots inline\n%matplotlib inline","c5a8844d":"# keys and tokens from the Twitter Dev Console\nconsumer_key = 'Sec3MvclRIx2RVlgu9l0SJX6D'\nconsumer_secret = 'ayoPNWtBm7fWpMBoK6EwRmegu3SW8Rw9mzJkottkv97quPe941'\naccess_token = '736550752760406018-so5CPJrEbJKb3c3Pq8va3VFr0yk4S0E'\naccess_token_secret = 'Cgr8tz0h6FTU7kxAjDzpHnjffNTHxWsBytXnu4Ihd1TFb'","bfc1c318":"class TwitterClient(object): \n    def __init__(self): \n        #Initialization method. \n        try: \n            # create OAuthHandler object \n            auth = OAuthHandler(consumer_key, consumer_secret) \n            # set access token and secret \n            auth.set_access_token(access_token, access_token_secret) \n            # create tweepy API object to fetch tweets \n            # add hyper parameter 'proxy' if executing from behind proxy \"proxy='http:\/\/172.22.218.218:8085'\"\n            self.api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True)\n            \n        except tweepy.TweepError as e:\n            print(f\"Error: Tweeter Authentication Failed - \\n{str(e)}\")\n\n    def get_tweets(self, query, maxTweets = 1000):\n        #Function to fetch tweets. \n        # empty list to store parsed tweets \n        tweets = [] \n        sinceId = None\n        max_id = -1\n        tweetCount = 0\n        tweetsPerQry = 100\n\n        while tweetCount < maxTweets:\n            try:\n                if (max_id <= 0):\n                    if (not sinceId):\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry)\n                    else:\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry,\n                                                since_id=sinceId)\n                else:\n                    if (not sinceId):\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry,\n                                                max_id=str(max_id - 1))\n                    else:\n                        new_tweets = self.api.search(q=query, count=tweetsPerQry,\n                                                max_id=str(max_id - 1),\n                                                since_id=sinceId)\n                if not new_tweets:\n                    print(\"No more tweets found\")\n                    break\n\n                for tweet in new_tweets:\n                    parsed_tweet = {} \n                    parsed_tweet['tweets'] = tweet.text \n\n                    # appending parsed tweet to tweets list \n                    if tweet.retweet_count > 0: \n                        # if tweet has retweets, ensure that it is appended only once \n                        if parsed_tweet not in tweets: \n                            tweets.append(parsed_tweet) \n                    else: \n                        tweets.append(parsed_tweet) \n                        \n                tweetCount += len(new_tweets)\n                print(\"Downloaded {0} tweets\".format(tweetCount))\n                max_id = new_tweets[-1].id\n\n            except tweepy.TweepError as e:\n                # Just exit if any error\n                print(\"Tweepy error : \" + str(e))\n                break\n        \n        return pd.DataFrame(tweets)","5e1848fa":"twitter_client = TwitterClient()\n\n# calling function to get tweets\ntweets_df = twitter_client.get_tweets('Elon Musk', maxTweets=100000)\nprint(f'tweets_df Shape - {tweets_df.shape}')\ntweets_df.head(10)","d4c2dd7e":"# 1 way\ndef fetch_sentiment_using_SIA(text):\n    sid = SentimentIntensityAnalyzer()\n    polarity_scores = sid.polarity_scores(text)\n    return 'neg' if polarity_scores['neg'] > polarity_scores['pos'] else 'pos'\n\n# 2 way\ndef fetch_sentiment_using_textblob(text):\n    analysis = TextBlob(text)\n    return 'pos' if analysis.sentiment.polarity >= 0 else 'neg'","58545b04":"sentiments_using_SIA = tweets_df.tweets.apply(lambda tweet: fetch_sentiment_using_SIA(tweet))\npd.DataFrame(sentiments_using_SIA.value_counts())","541844fb":"sentiments_using_textblob = tweets_df.tweets.apply(lambda tweet: fetch_sentiment_using_textblob(tweet))\npd.DataFrame(sentiments_using_textblob.value_counts())","a77092b2":"tweets_df['sentiment'] = sentiments_using_SIA\ntweets_df.head()","0b1c28c2":"def remove_pattern(text, pattern_regex):\n    r = re.findall(pattern_regex, text)\n    for i in r:\n        text = re.sub(i, '', text)\n    \n    return text ","b89a1f07":"# We are keeping cleaned tweets in a new column called 'tidy_tweets'\ntweets_df['tidy_tweets'] = np.vectorize(remove_pattern)(tweets_df['tweets'], \"@[\\w]*: | *RT*\")\ntweets_df.head(10)","fce6a467":"cleaned_tweets = []\n\nfor index, row in tweets_df.iterrows():\n    # Here we are filtering out all the words that contains link\n    words_without_links = [word for word in row.tidy_tweets.split() if 'http' not in word]\n    cleaned_tweets.append(' '.join(words_without_links))\n\ntweets_df['tidy_tweets'] = cleaned_tweets\ntweets_df.head(10)","537cccf6":"tweets_df = tweets_df[tweets_df['tidy_tweets']!='']\ntweets_df.head()","5dd5d129":"tweets_df.drop_duplicates(subset=['tidy_tweets'], keep=False)\ntweets_df.head()","73328472":"tweets_df = tweets_df.reset_index(drop=True)\ntweets_df.head()","c685bbee":"tweets_df['absolute_tidy_tweets'] = tweets_df['tidy_tweets'].str.replace(\"[^a-zA-Z# ]\", \"\")","9edb1000":"stopwords_set = set(stopwords)\ncleaned_tweets = []\n\nfor index, row in tweets_df.iterrows():\n    \n    # filerting out all the stopwords \n    words_without_stopwords = [word for word in row.absolute_tidy_tweets.split() if not word in stopwords_set and '#' not in word.lower()]\n    \n    # finally creating tweets list of tuples containing stopwords(list) and sentimentType \n    cleaned_tweets.append(' '.join(words_without_stopwords))\n    \ntweets_df['absolute_tidy_tweets'] = cleaned_tweets\ntweets_df.head(10)","95926f6e":"tokenized_tweet = tweets_df['absolute_tidy_tweets'].apply(lambda x: x.split())\ntokenized_tweet.head()","701f56d5":"word_lemmatizer = WordNetLemmatizer()\n\ntokenized_tweet = tokenized_tweet.apply(lambda x: [word_lemmatizer.lemmatize(i) for i in x])\ntokenized_tweet.head()","7a118608":"for i, tokens in enumerate(tokenized_tweet):\n    tokenized_tweet[i] = ' '.join(tokens)\n\ntweets_df['absolute_tidy_tweets'] = tokenized_tweet\ntweets_df.head(10)","638b2b5b":"class PhraseExtractHelper(object):\n    def __init__(self):\n        self.lemmatizer = nltk.WordNetLemmatizer()\n        self.stemmer = nltk.stem.porter.PorterStemmer()\n    \n    def leaves(self, tree):\n        \"\"\"Finds NP (nounphrase) leaf nodes of a chunk tree.\"\"\"\n        for subtree in tree.subtrees(filter = lambda t: t.label()=='NP'):\n            yield subtree.leaves()\n\n    def normalise(self, word):\n        \"\"\"Normalises words to lowercase and stems and lemmatizes it.\"\"\"\n        word = word.lower()\n        # word = self.stemmer.stem_word(word) # We will loose the exact meaning of the word \n        word = self.lemmatizer.lemmatize(word)\n        return word\n\n    def acceptable_word(self, word):\n        \"\"\"Checks conditions for acceptable word: length, stopword. We can increase the length if we want to consider large phrase\"\"\"\n        accepted = bool(3 <= len(word) <= 40\n            and word.lower() not in stopwords\n            and 'https' not in word.lower()\n            and 'http' not in word.lower()\n            and '#' not in word.lower()\n            )\n        return accepted\n\n    def get_terms(self, tree):\n        for leaf in self.leaves(tree):\n            term = [ self.normalise(w) for w,t in leaf if self.acceptable_word(w) ]\n            yield term","e2675914":"sentence_re = r'(?:(?:[A-Z])(?:.[A-Z])+.?)|(?:\\w+(?:-\\w+)*)|(?:\\$?\\d+(?:.\\d+)?%?)|(?:...|)(?:[][.,;\"\\'?():-_`])'\ngrammar = r\"\"\"\n    NBAR:\n        {<NN.*|JJ>*<NN.*>}  # Nouns and Adjectives, terminated with Nouns\n        \n    NP:\n        {<NBAR>}\n        {<NBAR><IN><NBAR>}  # Above, connected with in\/of\/etc...\n\"\"\"\nchunker = nltk.RegexpParser(grammar)","20b3644c":"key_phrases = []\nphrase_extract_helper = PhraseExtractHelper()\n\nfor index, row in tweets_df.iterrows(): \n    toks = nltk.regexp_tokenize(row.tidy_tweets, sentence_re)\n    postoks = nltk.tag.pos_tag(toks)\n    tree = chunker.parse(postoks)\n\n    terms = phrase_extract_helper.get_terms(tree)\n    tweet_phrases = []\n\n    for term in terms:\n        if len(term):\n            tweet_phrases.append(' '.join(term))\n    \n    key_phrases.append(tweet_phrases)\n    \nkey_phrases[:10]","f19c38b8":"textblob_key_phrases = []\nextractor = ConllExtractor()\n\nfor index, row in tweets_df.iterrows():\n    # filerting out all the hashtags\n    words_without_hash = [word for word in row.tidy_tweets.split() if '#' not in word.lower()]\n    \n    hash_removed_sentence = ' '.join(words_without_hash)\n    \n    blob = TextBlob(hash_removed_sentence, np_extractor=extractor)\n    textblob_key_phrases.append(list(blob.noun_phrases))\n\ntextblob_key_phrases[:10]","7f3b2cb4":"tweets_df['key_phrases'] = textblob_key_phrases\ntweets_df.head(10)","4d0dcdf7":"def generate_wordcloud(all_words):\n    wordcloud = WordCloud(width=800, height=500, random_state=21, max_font_size=100, relative_scaling=0.5, colormap='Dark2').generate(all_words)\n\n    plt.figure(figsize=(14, 10))\n    plt.imshow(wordcloud, interpolation=\"bilinear\")\n    plt.axis('off')\n    plt.show()","5ace15f5":"all_words = ' '.join([text for text in tweets_df['absolute_tidy_tweets'][tweets_df.sentiment == 'pos']])\ngenerate_wordcloud(all_words)","b662e0b1":"all_words = ' '.join([text for text in tweets_df['absolute_tidy_tweets'][tweets_df.sentiment == 'neg']])\ngenerate_wordcloud(all_words)","246924ff":"# function to collect hashtags\ndef hashtag_extract(text_list):\n    hashtags = []\n    # Loop over the words in the tweet\n    for text in text_list:\n        ht = re.findall(r\"#(\\w+)\", text)\n        hashtags.append(ht)\n\n    return hashtags\n\ndef generate_hashtag_freqdist(hashtags):\n    a = nltk.FreqDist(hashtags)\n    d = pd.DataFrame({'Hashtag': list(a.keys()),\n                      'Count': list(a.values())})\n    # selecting top 15 most frequent hashtags     \n    d = d.nlargest(columns=\"Count\", n = 25)\n    plt.figure(figsize=(16,7))\n    ax = sns.barplot(data=d, x= \"Hashtag\", y = \"Count\")\n    plt.xticks(rotation=80)\n    ax.set(ylabel = 'Count')\n    plt.show()","8eddae55":"hashtags = hashtag_extract(tweets_df['tidy_tweets'])\nhashtags = sum(hashtags, [])","a54959bf":"generate_hashtag_freqdist(hashtags)","24cbb60f":"# For sake of consistency, we are going to discard the records which contains no phrases i.e where tweets_df['key_phrases'] contains []\ntweets_df2 = tweets_df[tweets_df['key_phrases'].str.len()>0]","7269fa2b":"# BOW features\nbow_word_vectorizer = CountVectorizer(max_df=0.90, min_df=2, stop_words='english')\n# bag-of-words feature matrix\nbow_word_feature = bow_word_vectorizer.fit_transform(tweets_df2['absolute_tidy_tweets'])\n\n# TF-IDF features\ntfidf_word_vectorizer = TfidfVectorizer(max_df=0.90, min_df=2, stop_words='english')\n# TF-IDF feature matrix\ntfidf_word_feature = tfidf_word_vectorizer.fit_transform(tweets_df2['absolute_tidy_tweets'])","b7ac2b04":"phrase_sents = tweets_df2['key_phrases'].apply(lambda x: ' '.join(x))\n\n# BOW phrase features\nbow_phrase_vectorizer = CountVectorizer(max_df=0.90, min_df=2)\nbow_phrase_feature = bow_phrase_vectorizer.fit_transform(phrase_sents)\n\n# TF-IDF phrase feature\ntfidf_phrase_vectorizer = TfidfVectorizer(max_df=0.90, min_df=2)\ntfidf_phrase_feature = tfidf_phrase_vectorizer.fit_transform(phrase_sents)","a3df5ae7":"target_variable = tweets_df2['sentiment'].apply(lambda x: 0 if x=='neg' else 1)","a282ada1":"def plot_confusion_matrix(matrix):\n    plt.clf()\n    plt.imshow(matrix, interpolation='nearest', cmap=plt.cm.Set2_r)\n    classNames = ['Positive', 'Negative']\n    plt.title('Confusion Matrix')\n    plt.ylabel('Predicted')\n    plt.xlabel('Actual')\n    tick_marks = np.arange(len(classNames))\n    plt.xticks(tick_marks, classNames)\n    plt.yticks(tick_marks, classNames)\n    s = [['TP','FP'], ['FN', 'TN']]\n\n    for i in range(2):\n        for j in range(2):\n            plt.text(j,i, str(s[i][j])+\" = \"+str(matrix[i][j]))\n    plt.show()","431ba368":"def naive_model(X_train, X_test, y_train, y_test):\n    naive_classifier = GaussianNB()\n    naive_classifier.fit(X_train.toarray(), y_train)\n\n    # predictions over test set\n    predictions = naive_classifier.predict(X_test.toarray())\n\n    # calculating Accuracy Score\n    print(f'Accuracy Score - {accuracy_score(y_test, predictions)}')\n    conf_matrix = confusion_matrix(y_test, predictions, labels=[True, False])\n    plot_confusion_matrix(conf_matrix)","34203faf":"X_train, X_test, y_train, y_test = train_test_split(bow_word_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","ed00a4a9":"X_train, X_test, y_train, y_test = train_test_split(tfidf_word_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","71d403e6":"X_train, X_test, y_train, y_test = train_test_split(bow_phrase_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","82bb1369":"X_train, X_test, y_train, y_test = train_test_split(tfidf_phrase_feature, target_variable, test_size=0.3, random_state=272)\nnaive_model(X_train, X_test, y_train, y_test)","443df2d8":"tweets_df2['sentiment'] = tweets_df2['sentiment'].apply(lambda x: 0 if x=='neg' else 1)","a0fbf619":"pipeline_ls = make_pipeline(CountVectorizer(max_df=0.90, min_df=2, tokenizer = RegexpTokenizer(r'[A-Za-z]+').tokenize,stop_words='english'), LogisticRegression())","54c10077":"X_train, X_test, y_train, y_test = train_test_split(tweets_df2.tweets, tweets_df2.sentiment)","6c586a86":"pipeline_ls.fit(X_train, y_train)","6ae47429":"pipeline_ls.score(X_test,y_test) ","fbe89060":"pickle.dump(pipeline_ls,open('sentiment_analysis.pkl','wb'))","ed7c90ae":"loaded_model = pickle.load(open('sentiment_analysis.pkl', 'rb'))\nresult = loaded_model.score(X_test,y_test)\nprint(result)","26b59c36":"p = ['RT @chubiei: After his divorce, Kanye West is the richest black American with an estimated net worth of $6.6billion. Elon Musk &amp; Jeff Bezos\u2026']\nresult = loaded_model.predict(p)","b73d55d8":"print(result)","fdcdffe9":"tweets_df['tweets'][2]","68651866":"#### <a id='3Aj'>j. Joining all tokens into sentences<\/a>","46f61f05":"#### <a id='3Bb'>b. Grammatical rule to identify phrases<\/a>","007fa6b8":"#### <a id='2Ba'>a. Using NLTK's SentimentIntensityAnalyzer<\/a>","97ef0488":"#### <a id='6Bb'>b. TF-IDF Phrase features<\/a>","6c048ff3":"## <a id='4'>4. Story Generation and Visualization<\/a>","94b039e3":"As expected, AI, DeepLearning and MachineLearning are most common hashtags.","8f75ee86":"*NLTK* gives us more negative sentiments than TexBlob, so we will prefer NLTK, since classfication seems better.","b7f01b10":"## <a id='5'>5. Feature Extraction<\/a>\n\nWe need to convert textual representation in the form on numeric features. We have two popular techniques to perform feature extraction:\n\n1. __Bag of words (Simple vectorization)__\n2. __TF-IDF (Term Frequency - Inverse Document Frequency)__\n\nWe will use extracted features from both one by one to perform sentiment analysis and will compare the result at last.\n","55a21c2e":"<img src = 'https:\/\/github.com\/taruntiwarihp\/raw_images\/blob\/master\/Musk.jpeg?raw=true'>","7b35f488":"## <a id='3'>3. Text Pre-processing<\/a> \n### <a id='3A'>A. Pre-processing 'Key Words'<\/a>\n#### <a id='3Aa'>a. Removing '@names'<\/a>\nHere we can see that at many places we have '@names', which is of no use, since it don't have any meaning, So needs to be removed.","05628eda":"### <a id='3B'>B. Pre-processing 'Key Phrases'<\/a> ","f80923f2":"In obtained key phrases, we can see words like 'year', 'talk', 'appl', 'compan' etc. are present which should never be considered as key phrases. There is one other simple way to extract key phrases, by using TextBlob (ConllExtractor).","1c18bc34":"#### Map target variables to  {0, 1}","311ae567":"# Sentiment Analysis on Elon Musk Tweets","c4854b71":"## <a id='1'>1. Import Libraries<\/a>","6f30348f":"Text is everywhere in the form of openions, complaints, news and information; each of us are contributing in generating this text throughout the internet. This large amount of text which is present in the unstructured format can be used for welfare of the society and businesses by analysing the sentiments and trends. A part of NLP deals with Text processing and analysis. Commonly available text can not be directly used for analysis, it needs to pre-processed first, and that is where NLTK, the most popular library for text processing in Python, comes into the picture.\n\n\nIn this notebook, I am going to perform Sentiment Analysis on tweets on any desired topic. Instead of fetching tweets from and CSV I am going to scrap these tweets from the internet. So, get ready for a crash course on Scraping (using Selenium) and Twitter Sentiment Analysis.","f2e1aea4":"### Actions I am going to perform are:\n\n\n1. __<a href='#1' target='_self'>Import Libraries<\/a>__\n1. __<a href='#2' target='_self'>Fetch Tweets & Sentiments<\/a>__\n    1. __<a href='#2A' target='_self'>Fetch Tweets<\/a>__\n        1. <a href='#2Aa' target='_self'>Using Selenium<\/a>\n        1. <a href='#2Ab' target='_self'>Using tweepy<\/a>\n    1. __<a href='#2B' target='_self'>Fetch sentiments<\/a>__\n        1. <a href='#2Ba' target='_self'>Using NLTK's SentimentIntensityAnalyzer<\/a>\n        1. <a href='#2Bb' target='_self'>Using TextBlob<\/a>\n1. __<a href='#3' target='_self'>Text Pre-processing<\/a>__\n    1. __<a href='#3A' target='_self'>Pre-processing 'Key Words'<\/a>__\n        1. <a href='#3Aa' target='_self'>Removing '@names'<\/a>\n        1. <a href='#3Ab' target='_self'>Removing links (http | https)<\/a>\n        1. <a href='#3Ac' target='_self'>Removing tweets with empty text<\/a>\n        1. <a href='#3Ad' target='_self'>Dropping duplicate rows<\/a>\n        1. <a href='#3Ae' target='_self'>Removing Punctuations, Numbers and Special characters<\/a>\n        1. <a href='#3Af' target='_self'>Removing Stop words<\/a>\n        1. <a href='#3Ag' target='_self'>Tokenizing<\/a>\n        1. <a href='#3Ah' target='_self'>Converting words to Lemma <\/a>\n        1. <a href='#3i' target='_self'>Joining all tokens into sentences<\/a>\n    1. __<a href='#3B' target='_self'>Pre-processing 'Key Phrases'<\/a>__\n        1. <a href='#3Ba' target='_self'>Setting Grammatical rule to identify phrases<\/a>\n        1. <a href='#3Bb' target='_self'>Creating new feature called 'key_phrases', will contain phrases for corresponding tweet<\/a>\n1. __<a href='#4' target='_self'>Story Generation and Visualization<\/a>__\n    1. __<a href='#4A' target='_self'>Most common words in positive tweets<\/a>__\n    1. __<a href='#4B' target='_self'>Most common words in negative tweets<\/a>__\n    1. __<a href='#4C' target='_self'>Most commonly used Hashtags<\/a>__\n1. __<a href='#5' target='_self'>Feature Extraction<\/a>__\n    1. __<a href='#5A' target='_self'>Feature Extraction for 'Key Words'<\/a>__\n    1. __<a href='#5B' target='_self'>Feature Extraction for 'Key Phrases'<\/a>__\n1. __<a href='#6' target='_self'>Model Building: Sentiment Analysis<\/a>__\n    1. __<a href='#6A' target='_self'>Predictions on 'key words' based features<\/a>__\n        1. <a href='#6Aa' target='_self'> BOW word features<\/a>\n        1. <a href='#6Ab' target='_self'>TF-IDF word features<\/a>\n    1. __<a href='#6B' target='_self'>Predictions on 'key phrases' based features<\/a>__\n        1. <a href='#6Ba' target='_self'>BOW phrase features<\/a>\n        1. <a href='#6Bb' target='_self'>TF-IDF phrase features<\/a>\n       ","4a1d7c89":"These key phrases seems better, let's consider these key phrase only.","f8e1ee02":"#### <a id='3Ai'>i. Converting words to Lemma<\/a>","8a6fa78d":"#### <a id='2Bb'>b. Using TextBlob<\/a>","d208b38d":"## <a id='6'>6. Model Building: Sentiment Analysis<\/a>","63534116":"#### <a id='3Ad'>d. Dropping duplicate rows<\/a>","d4f4ee6c":"#### <a id='4C'>C. Most commonly used Hashtags<\/a>","6438be1b":"### <a id='6B'>B. Predictions on 'key phrases' based features<\/a>","bc30dac2":"### <a id='5A'>A. Feature Extraction for 'Key Words'<\/a>","8cbabe46":"#### <a id='3Ac'>c. Removing tweets with empty text<\/a>","2b62f421":"#### <a id='3Ae'>e. Resetting index<\/a>\nIt seems that our index needs to be reset, since after removal of some rows, some index values are missing, which may cause problem in future operations.","284e48fe":"#### <a id='3Ag'>g. Removing Stop words<\/a>\nWith the same reason we mentioned above, we won't perform this on 'tidy_tweets' column, because it needs to be used for __key_phrases__ sentiment analysis.","f5f8ef3e":"#### <a id='3Bc'>c. New feature called 'key_phrases', will contain phrases for corresponding tweet<\/a>","8ae38e9b":"Seems good, now we don't have '@name' values\n#### <a id='3Ab'>b. Removing links (http | https)<\/a>","d123be46":"#### <a id='4A'>A. Most common words in positive tweets<\/a>\nAnswer can be best found using WordCloud","b2c8c091":"#### <a id='2Ab'>b. Using 'tweepy'<\/a>","270f38ea":"### <a id='5B'>B. Feature Extraction for 'Key Phrases'<\/a>","57a0c660":"#### <a id='6Ba'>a. BOW Phrase features<\/a>","90b543c8":"#### <a id='6Aa'>a. BOW word features<\/a>","ac2000c2":"#### <a id='3Ah'>h. Tokenize *'absolute_tidy_tweets'*<\/a>  ","8da9ac55":"Features extracted from 'key words' helps model in performing better. They have better positive predictions than the later one. However, using 'key-phrase' based features improves the negative predictions.<br\/><br\/>\n\n__Now i Will make Sklearn Pipline using Logistic Regression__","178b711c":"#### <a id='6Ab'>b. TF-IDF word features<\/a>","5974b1d9":"### <a id='6A'>A. Predictions on 'key words' based features<\/a>","dc613110":"#### <a id='3Ba'>a. Helper class, will help in preprocessing phrase terms<\/a>","86a09e31":"#### <a id='4B'>B. Most common words in negative tweets<\/a>","ea69f316":"#### <a id='3Af'>f. Removing Punctuations, Numbers and Special characters<\/a>\nThis step should not be followed if we also want to do sentiment analysis on __key phrases__ as well, because semantic meaning in a sentence needs to be present. So here we will create one additional column 'absolute_tidy_tweets' which will contain absolute tidy words which can be further used for sentiment analysis on __key words__.","87881397":"- One thing to notice here is that word _'deep learning'_ has been used more than _'Machine Learning', 'AI', 'Artificial Intelligence', 'BigData'_ and _'DataScience'_, which shows the buzz of deep learning these days.\n\n- AI, DeepLearning and MachineLearning have clearly been used in both positive and negative tweets, which is very obvious.\nHowever, in negative tweets we can also see negative words as well like *stop, wrong, Unfortunately, fall, Cancer, shit, Greed, pressure, problem, complex, biased, never etc.*","ec36fb1c":"### <a id='2B'>B. Fetch sentiments<\/a>\nTo proceed further, we need to know the sentiment type of every tweet, that can be done using two ways: <br\/>\n    __a. Using NLTK's SentimentIntensityAnalyzer (We'll refer as SIA)<br\/>__\n    __b. Using TextBlob<br\/>__"}}