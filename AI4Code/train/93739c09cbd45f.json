{"cell_type":{"ae6c6468":"code","f85f5938":"code","462d0cbd":"code","887a7f08":"code","6864c3ef":"code","c1f0f335":"code","386406c1":"code","69b11102":"code","582aed9e":"markdown","c68409bf":"markdown","26b00382":"markdown","377b04ae":"markdown","36c1dd81":"markdown","fff0b07a":"markdown","d42d4327":"markdown","dbbbe191":"markdown","000dd1c5":"markdown","90989592":"markdown","8994cec3":"markdown","69d35ae4":"markdown","5179121d":"markdown"},"source":{"ae6c6468":"from PIL import Image \nImage.open(\"..\/input\/arl-arl\/market.png\")","f85f5938":"# Installing required libraries\n\n!pip install mlxtend\n!pip install openpyxl\nimport pandas as pd\nfrom mlxtend.frequent_patterns import apriori, association_rules\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Making the appearance settings of the printouts\n\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.float_format', lambda x: '%.5f' % x)","462d0cbd":"# Load data into pandas dataframe..\n\ndf = pd.read_excel(\"\/kaggle\/input\/online\/online_retail.xlsx\", sheet_name=\"Year 2010-2011\")\ndf.head()","887a7f08":"def outlier_thresholds(dataframe, variable):\n    \"\"\"\n    It allows us to catch outliers.\n    It determines the upper and lower limits over the quarterly values.\n    \n    Parameters\n    ------\n    dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n    variable: variable\n                The variable from which has outlier value\n                    \n    Returns\n    ------\n    low limit: low limit\n                It subtracts 1.5 times the interquartile range from quantile(0.01)\n    \n    up_limit:  up limit: \n                It adds up 1.5 times the interquartile value from quantile(0.99)\n                \n    Notes\n    ------\n    It alone is not enough to get rid of outliers. It works with replace_with_thresholds.\n    \n    \"\"\"\n    quartile1 = dataframe[variable].quantile(0.01)\n    quartile3 = dataframe[variable].quantile(0.99)\n    interquantile_range = quartile3 - quartile1\n    up_limit = quartile3 + 1.5 * interquantile_range\n    low_limit = quartile1 - 1.5 * interquantile_range\n    return low_limit, up_limit\n\ndef replace_with_thresholds(dataframe, variable):\n    \"\"\"\n    Replaces captured outliers according to the defined upper and lower limit\n    \n    Parameters\n    ------\n    dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n    variable: variable\n                The variable from which has outlier value\n                    \n    Returns\n    ------\n    None\n                \n    Notes\n    ------\n    It alone is not enough to get rid of outliers. It works with outlier_thresholds.\n    \n    \"\"\"\n    low_limit, up_limit = outlier_thresholds(dataframe, variable)\n    # dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit\n    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit\n    \n    \ndef data_prep(dataframe):\n    dataframe.dropna(axis=0, inplace=True)\n    dataframe = dataframe[~dataframe[\"Invoice\"].str.startswith(\"C\", na=False)]\n    dataframe = dataframe[dataframe[\"Quantity\"] > 0]\n    replace_with_thresholds(dataframe, \"Quantity\")\n    replace_with_thresholds(dataframe, \"Price\")\n    dataframe[\"TotalPrice\"] = dataframe[\"Quantity\"] * dataframe[\"Price\"]\n    return dataframe\n\ndf = data_prep(df)\ndf.head()","6864c3ef":"# For this analysis, we wanted to work only for Germany customers.\ndf_de = df[df['Country'] == \"Germany\"]\n\n# Function is defined for all the steps.\ndef create_invoice_product_df(dataframe, id=False):\n    \"\"\"\n    We define a function to calculate the relationship between Invoice and StockCode.\n    \n    Parameters\n    ------\n    dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n    id: boolen\n                We will be selecting the table we want to see according to the relevant selection.\n                    \n    Returns\n    ------\n    for True: StockCode appears\n                Returns 1 and 0 according to invoice and stokcode variable\n    \n    for False:  Description appears \n                Returns 1 and 0 according to invoice and description variable\n                \n    Notes\n    ------\n    If the names of the products are needed, selection should be description(False), if not selection should be stockcode(True).\n    \n    \"\"\"\n    if id:\n        return dataframe.groupby(['Invoice', \"StockCode\"])['Quantity'].sum().unstack().fillna(0).\\\n            applymap(lambda x: 1 if x > 0 else 0)\n    else:\n        return dataframe.groupby(['Invoice', 'Description'])['Quantity'].sum().unstack().fillna(0).\\\n            applymap(lambda x: 1 if x > 0 else 0)\n\n\nde_inv_pro_df = create_invoice_product_df(df_de, id=True)\nde_inv_pro_df.head()","c1f0f335":"# We will need this step more than once so that function is defined.\n\ndef check_id(dataframe, stock_code):\n    \"\"\"\n    Prints names according to stock code.\n    \n    Parameters\n    ------\n    dataframe: Dataframe\n               The dataframe from which variable names are to be retrieved\n                \n    stock_code: Stockcode id\n                Stockcode in related dataset\n  \n                    \n    Returns\n    ------\n    None\n\n    \"\"\"\n    product_name = dataframe[dataframe[\"StockCode\"] == stock_code][[\"Description\"]].values[0].tolist()\n    print(product_name)\n\ncheck_id(df_de,21987)\ncheck_id(df_de, 23235)\ncheck_id(df_de, 22747)","386406c1":"frequent_itemsets = apriori(de_inv_pro_df, min_support=0.01, use_colnames=True)\nfrequent_itemsets.sort_values(\"support\", ascending=False).head(50)\n\nrules = association_rules(frequent_itemsets, metric=\"support\", min_threshold=0.01)\nrules.sort_values(\"support\", ascending=False).head()\n\nrules.sort_values(\"lift\", ascending=False).head(10)","69b11102":"def arl_recommender(rules_df, product_id, rec_count=1):\n\n    sorted_rules = rules_df.sort_values(\"lift\", ascending=False)\n\n    recommendation_list = []\n\n    for i, product in sorted_rules[\"antecedents\"].items():\n        for j in list(product):\n            if j == product_id:\n                recommendation_list.append(list(sorted_rules.iloc[i][\"consequents\"]))\n\n    recommendation_list = list({item for item_list in recommendation_list for item in item_list})\n\n    return recommendation_list[:rec_count]\n\ncheck_id(df_de, 23235) \narl_recommender(rules, 23235, 1)\narl_recommender(rules, 23235, 2) ","582aed9e":"# Association Rule Learning - ARL","c68409bf":"# Definitions of Variables","26b00382":"# Data Preprocessing","377b04ae":"# ARL Preparing the Data Structure (Invoice-Product Matrix)","36c1dd81":"# Determination of Association Rules","fff0b07a":"# Business Problem","d42d4327":"# What is the Association Rule Learning ?","dbbbe191":"* **antecedents**: first product\n* **consequents**: second product\n* **antecedent support**: probability of first being observed alone\n* **consequent support**: probability of second being observed alone\n* **support**: probability of observing the first and second product together\n* **confidence**: probability of getting the second product when the first product is bought\n* **lift** : At what rate the probability of getting the second item increases when the first item is bought?","000dd1c5":"# Making Product Suggestions to Users at the Basket Stag","90989592":"* The dataset named Online Retail II is a UK-based online sale.Store's sales between 01\/12\/2009 - 09\/12\/2011.The product catalog of this company includes souvenirs.Promotion can be considered as products.There is also information that most of its customers are wholesalers.\n\nWe would like to make recommendations to customers at the basket stage.There are 5 steps for this analysis.\n1. Data Preprocessing\n2. ARL Preparing the Data Structure (Invoice-Product Matrix)\n3. Determination of Association Rules\n4. Preparing the Script of the Project\n5. Making Product Suggestions to Users at the Basket Stage\n","8994cec3":"> Association rule learning is a rule-based machine learning method for discovering interesting relations between variables in large databases. \n> It is intended to identify strong rules discovered in databases using some measures of interestingness.\n> Association theory responds to the needs of many sectors. This system is used from large supermarket chains to the applications we use to watch movies.\n\n> To explain through market chains, I would like to share a real-life example with you. \n> Walmart, located in the USA, analyzed that alcohol products and diaper products have a significant relationship with each other in their analysis and arranged their aisles accordingly.\n","69d35ae4":"# Determination of Association Rules\n\t\n* Apriori is an algorithm for frequent item set mining and association rule learning over relational databases. It proceeds by identifying the frequent individual items in the database and extending them to larger and larger item sets as long as those item sets appear sufficiently often in the database. The frequent item sets determined by Apriori can be used to determine association rules which highlight general trends in the database: this has applications in domains such as market basket analysis.","5179121d":"**Thank you for taking the time.**"}}