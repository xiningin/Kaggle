{"cell_type":{"c7c39983":"code","8dcd02e1":"code","a5c6ad02":"code","de67f650":"code","115ae82a":"code","055e749c":"code","a89f7892":"code","d73025c8":"code","099c366b":"code","16493012":"code","3f0a2813":"markdown","0558a0a2":"markdown","bf6fdab2":"markdown","de3ba718":"markdown","2b3c508b":"markdown","cf15413b":"markdown","2a8882c6":"markdown","e5ac360b":"markdown","ffd850c4":"markdown","c5cf1214":"markdown","d6beeb1e":"markdown"},"source":{"c7c39983":"# -*- coding: utf-8 -*-\n\n# Created on Wed Jun 9 2021\n\n# @author: mbadal1996\n\n\n# ====================================================\n# CNN + MLP Model for Image + Numeric Data \n# ====================================================\n\n# Comments:\n# The following Python code is a hybrid CNN + MLP \n# classifier for combined image data + numeric features \n# (meta-data) which further describe the images.The \n# output of the model is a continuous float value in the \n# range [0,1] which is due to normalization of the \n# training label. In that sense it is a regression as \n# opposed to a classification. The original purpose of \n# the code was to make predictions on housing prices \n# (see So-Cal Housing in Kaggle) but this kind of hybrid\n# model is useful for various other problems where \n# both images and numeric features are combined. In the \n# event that a binary or multi-class output is desired \n# (instead of a float value regression), then the final \n# output layer of the CNN+MLP should be modified for the \n# number of classes and then passed through a softmax \n# function.\n\n# As an example, the house features (numeric data) CSV \n# file is also included in the repository so that the \n# user can see the format. House images are not included\n# since they are too many and can be easily downloaded \n# from Kaggle at:\n\n# https:\/\/www.kaggle.com\/ted8080\/house-prices-and-images-socal\n\n# Useful content at PyTorch forum is acknowledged for \n# combining images and numeric data features. \n\n# -----------------------------------------------------\n\n# IMPORTANT NOTE:\n# When organizing data in folders to be input to \n# dataloader, it is important to keep in mind the \n# following for correct loading:\n\n# 1) The train and validation data were separated into \n# their own folders by hand by class (one class: house) c\n# alled 'socal_pics\/train' and 'socal_pics\/val'. That \n# means the sub-folder 'train' contains one folder: house.\n# The same is true for the val data held in the folder \n# 'socal_pics\/val'. So the organization looks like:\n\n# socal_pics > train > house\n# socal_pics > val > house\n\n# Place the metadat CSV file in same folder as Python \n# script\n\n# 2) The test data is organized differently since there \n# are no labels for those images. Instead, the test data\n# are held in the folder 'socal_pics\/test' where the \n# sub-folder here 'test' just contains one folder called\n# 'test'. This is instead of the 'house' folder. So the\n# organization looks like:\n\n# socal_pics > test > test\n\n# ======================================================","8dcd02e1":"# ====================================================\n\n# Python\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport time\n\n# Pytorch\nimport torch\nfrom torchvision import datasets\nimport torchvision.transforms as transforms\nimport torch.nn.functional as F\n\n# Choose Device (GPU or CPU)\ndev = 'cuda'\n# dev = 'cpu'\n\n# =====================================================\n# Parameters\n\n# Image Parameters\nCH = 3  # number of channels\nratio = 1.5625  # width\/height ratio to resize images\nimagewidth = 157  # square dimension (size x size) \nimageheight = int(np.floor(imagewidth\/ratio))\ncropsize = imageheight\n#cropsize = imagewidth\n\n\n# Neural Net Parameters\nlearn_rate = 1e-3  \nnum_epochs = 20  # At least 20 epochs for 100x100 images\nbatch_size = 100  \n\n\n# Seed for reproduceable random numbers (eg weights \n# and biases). NOTE: Seed will be overidden by using\n# image transforms like random flip or setting \n# shuffle = True in data loader.\ntorch.manual_seed(1234)\n\n\n# Start Timing Code  (only approximate)\ntic = time.perf_counter()\n\n# ======================================================","a5c6ad02":"# ======================================================\n\n# Image Transforms:\n# Create transforms for training data augmentation. \n# In each epoch, random transforms will be applied \n# according to the Compose function. They are random \n# since we are explicitly choosing \"Random\" versions \n# of the transforms. To \"increase the dataset\" one \n# should run more epochs, since each epoch has new \n# random data.\n# NOTE: Augmentation should only be for train data.\n# NOTE: For augmentation transforms, best to use \n# larger batches\n\n# Transform for training data\ntransform_train = transforms.Compose([\n        transforms.Resize([imageheight, imagewidth]),\n        transforms.CenterCrop(cropsize),\n        #transforms.RandomHorizontalFlip(p=0.5),\n        #transforms.RandomRotation(degrees = (-20,20)), \n        #transforms.RandomVerticalFlip(p=0.5),\n        transforms.ToTensor()])\n\n# Transform for validation data\ntransform_val = transforms.Compose([\n        transforms.Resize([imageheight, imagewidth]),\n        transforms.CenterCrop(cropsize),\n        transforms.ToTensor()])\n\n# Transform for test data\n#transform_test = transforms.Compose([\n#        transforms.Resize([imageheight, imagewidth]),\n#        transforms.CenterCrop(cropsize),\n#        transforms.ToTensor()])","de67f650":"# ====================================================\n# DATA IMPORT\n\n# Import train,val, and test data and set up data \n# loader. Note that ImageFolder will organize data \n# according to class labels of the folders \"house, \n# etc\" as found in the train and val data folder.\n# NOTE: When calling a specific image (such as 135) \n# from train data, the first XXX images are class 0,\n# then the next YYY are class 1, and etc. if more \n# than one class existed (which is not the case here).\n\n# Import CSV of Housing Data\n# Read Data from File; Create Tensors for train,test,val\nrawdata = \\\npd.read_csv('..\/input\/subset-of-house-prices-and-images-socal\/socal2_cleaned_mod.csv')\n\n#  Import all columns in CSV\nXraw = np.column_stack((rawdata['image_id'].values,\n                        rawdata['n_citi'].values,\n                        rawdata['bed'].values,\n                        rawdata['bath'].values,\n                        rawdata['sqft'].values,\n                        rawdata['price'].values))\n\n# ====================================================\n# Prepare Training Data\n\n# ====================================================\n# NOTE: Normalization was done after splitting data.\n# ====================================================\n\nXraw_train = Xraw[0:2000,:]  # Get required train data\n#city_data_train = Xraw_train[:,1]  # import city data\nbdrm_data_train = Xraw_train[:,2]  # import bdrm data\nbath_data_train = Xraw_train[:,3]  # import bath data\nsqft_data_train = Xraw_train[:,4]  # import sqft data\nyraw_true_train = Xraw_train[:,5]  # import price\n\n# NORMALIZE DATA (COULD STANDARDIZE INSTEAD)\n# Normalize data based to scale [0,1]. Could also \n# standardize as z = (x - mean)\/stddev\n#city_train_norm = city_data_train\/np.max(city_data_train)\nbdrm_train_norm = bdrm_data_train\/np.max(bdrm_data_train)\nbath_train_norm = bath_data_train\/np.max(bath_data_train)\nsqft_train_norm = sqft_data_train\/np.max(sqft_data_train)\ny_true_train_norm = yraw_true_train\/np.max(yraw_true_train)\n\n# Convert to torch tensor\n#city_train = torch.from_numpy(city_train_norm).float()\nbdrm_train = torch.from_numpy(bdrm_train_norm).float()\nbath_train = torch.from_numpy(bath_train_norm).float()\nsqft_train = torch.from_numpy(sqft_train_norm).float()\ny_train = torch.from_numpy(y_true_train_norm).float()\n\n# Combine sqft, bdrm, etc into one meta_data\nmeta_train = torch.stack((bdrm_train,bath_train,\n                          sqft_train),dim=1)\n\n# ===================================================\n# Prepare Validation Data\n\n# ===================================================\n# NOTE: Normalization was done after splitting data. \n# ===================================================\n\nXraw_val = Xraw[2000:3000,:]  # Get required val data\n#city_data_val = Xraw_val[:,1]  # import city data\nbdrm_data_val = Xraw_val[:,2]  # import bdrm data\nbath_data_val = Xraw_val[:,3]  # import bath data\nsqft_data_val = Xraw_val[:,4]  # import sqft data\nyraw_true_val = Xraw_val[:,5]  # import price data\n\n# NORMALIZE DATA (COULD STANDARDIZE INSTEAD)\n# Normalize data based to scale [0,1]. Could also \n# standardize as z = (x - mean)\/stddev\n#city_val_norm = city_data_val\/np.max(city_data_val)\nbdrm_val_norm = bdrm_data_val\/np.max(bdrm_data_val)\nbath_val_norm = bath_data_val\/np.max(bath_data_val)\nsqft_val_norm = sqft_data_val\/np.max(sqft_data_val)\ny_true_val_norm = yraw_true_val\/np.max(yraw_true_val)\n\n# Convert to torch tensor\n#city_val = torch.from_numpy(city_val_norm).float()\nbdrm_val = torch.from_numpy(bdrm_val_norm).float()\nbath_val = torch.from_numpy(bath_val_norm).float()\nsqft_val = torch.from_numpy(sqft_val_norm).float()\ny_val = torch.from_numpy(y_true_val_norm).float()\n\n# Combine sqft, bdrm, etc into one meta_data\nmeta_val = torch.stack((bdrm_val,bath_val,\n                        sqft_val),dim=1)\n\n# ================================================","115ae82a":"# ================================================\n# Generate batches of meta_data (house features)\n\n# Metadata (House Feaures) Training Batches\ndef get_batch_train(batch_size,which_batch,\n                    array_len=len(y_train)):\n        \n    num_batches = int(np.floor(array_len\/batch_size))\n    \n    # Initialize lists\n    batch_y = []\n    batch_meta = []\n    for i in range(num_batches+1):\n        batch_y_train = \\\n            y_train[i*batch_size:(i+1)*batch_size]\n        batch_meta_train = \\\n            meta_train[i*batch_size:(i+1)*batch_size,:]\n        # NOTE: batch_y_train and batch_meta_train should\n        # be enough to pull out batches directly. No need\n        # to append to lists as below, but is convenient.\n        batch_y.append(batch_y_train)\n        batch_meta.append(batch_meta_train)\n        \n    # Call each batch from ydata_train and metadata_train\n    ydata_train = torch.FloatTensor(batch_y[which_batch]) \n    metadata_train = torch.FloatTensor(batch_meta[which_batch])\n    return ydata_train,metadata_train\n\n\n# Metadata Validation Batches\ndef get_batch_val(batch_size,which_batch,\n                  array_len=len(y_val)):\n        \n    num_batches = int(np.floor(array_len\/batch_size))\n    \n    # Re-initialize lists\n    batch_y = []\n    batch_meta = []\n    for i in range(num_batches+1):\n        batch_y_val = \\\n            y_val[i*batch_size:(i+1)*batch_size]        \n        batch_meta_val = \\\n            meta_val[i*batch_size:(i+1)*batch_size,:]\n        # NOTE: batch_y_val and batch_meta_val should\n        # be enough to pull out batches directly. No need\n        # to append to lists as below, but is convenient.\n        batch_y.append(batch_y_val)\n        batch_meta.append(batch_meta_val)\n        \n    # Call each batch from ydata_val and metadata_val\n    ydata_val = torch.FloatTensor(batch_y[which_batch]) \n    metadata_val = torch.FloatTensor(batch_meta[which_batch])\n    return ydata_val,metadata_val\n\n\n# ====================================================","055e749c":"# ====================================================\n# Create Image Data Loader for Train,Validation,Test\n\n# Training Data\nimages_train = \\\ndatasets.ImageFolder('..\/input\/subset-of-house-prices-and-images-socal\/socal_pics\/train',\n                     transform=transform_train)\nloader_train = \\\ntorch.utils.data.DataLoader(images_train, shuffle=False, \n                            batch_size=batch_size)\n\n# Validation Data\nimages_val = \\\ndatasets.ImageFolder('..\/input\/subset-of-house-prices-and-images-socal\/socal_pics\/val',\n                     transform=transform_val)\nloader_val = \\\ntorch.utils.data.DataLoader(images_val, shuffle=False, \n                            batch_size=batch_size)\n\n# Testing Data\n# Can add testing data loader as well if desired","a89f7892":"# ==================================================\n# CNN + MLP Model Architecture\n# ==================================================\n\n# Here we have used a combined CNN + MLP. The CNN \n# processes image data and the MLP is employed for \n# input\/learning of numeric data\/features. The \n# outputs of each are concatenated to form one \n# stream of data.\n\n# NOTE NOTE NOTE: The CNN used in this problem \n# takes images of 100x100 pixels if linear input\n# layer is X * 22 * 22 or 200x200 pixels \n# with X * 47 * 47.\n\n# Two convolution network    \nclass Net(torch.nn.Module):\n    def __init__(self):\n        super(Net,self).__init__()\n        # Image CNN\n        self.pool = torch.nn.MaxPool2d(2, 2)\n        self.conv1 = torch.nn.Conv2d(3, 10, 5)\n        self.conv2 = torch.nn.Conv2d(10, 10, 5)\n        self.fc1 = torch.nn.Linear(10 * 22 * 22, 120)\n        self.fc2 = torch.nn.Linear(120, 60)\n        \n        # Data MLP\n        # 3 inputs (eg bdrm,bath,sqft) to MLP\n        self.fc3 = torch.nn.Linear(3, 120)  \n        self.fc4 = torch.nn.Linear(120, 60)\n\n        # Cat outputs from CNN + MLP\n        self.fc5 = torch.nn.Linear(60 + 60, 120)\n        # 1 output (price) from CNN+MLP\n        self.fc6 = torch.nn.Linear(120, 1)  \n        # NOTE: output is trained as a regression value\n        # (continuous), in the range [0,1].\n        \n    def forward(self, x1, x2):\n        # Image CNN\n        x1 = self.pool(F.relu(self.conv1(x1)))\n        x1 = self.pool(F.relu(self.conv2(x1)))\n        x1 = x1.view(-1, 10 * 22 * 22)\n        x1 = F.relu(self.fc1(x1))\n        x1 = F.relu(self.fc2(x1))\n        \n        # Data MLP\n        x2 = x2.view(-1, 3) \n        x2 = F.relu(self.fc3(x2))\n        x2 = F.relu(self.fc4(x2))\n        \n        # Cat outputs from CNN + MLP\n        x3 = torch.cat((x1, x2), dim=1)\n        x3 = F.relu(self.fc5(x3))\n        x3 = self.fc6(x3)\n        \n        return x3","d73025c8":"    \n# ==============================================\n# ==============================================\n\n# Call instance of CNN+MLP NN class\nmodel = Net().to(dev)\n\n# MSE loss func since NN output is contin. in [0,1]\nloss_fn = torch.nn.MSELoss(reduction='mean')\n\n# Optimizer used to train parameters\noptimizer = torch.optim.Adam(model.parameters(), \n                             lr=learn_rate)\n\n# ===============================================","099c366b":"# ===============================================\n\n# Initialize tensor to store loss values\nresult_vals = torch.zeros(num_epochs,4)\ncount_train = 0  # Initialize Counter\ncount_val = 0\n#X_test,y_true_test = loader_test\n\nprint(' ')\nprint('epoch  | loss_train  | loss_val  | err_train  | err_val')\nprint('-------------------------------------------------------')\n\nerror_train = torch.zeros(batch_size)\nerror_val = torch.zeros(batch_size)\n\nfor epoch in range(num_epochs):\n    # New epoch begins\n    running_loss_train = 0\n    running_loss_val = 0\n    running_error_train = 0\n    running_error_val = 0\n    num_batches_train = 0\n    num_batches_val = 0\n    count_train = 0\n    count_val = 0\n    j = 0  # Initialize batch counter\n    k = 0  # Initialize batch counter\n    \n    model.train() # Set torch to train\n    for X_train,_ in loader_train:\n        X_train = X_train.to(dev) \n        # (X,y) is a mini-batch:\n        # X size Nx3xHxW (N: batch_size, 3: three ch )\n        # y size N\n        \n        # Get metadata in batches from function \n        ydata_train,metadata_train = \\\n            get_batch_train(batch_size,j)\n        ydata_train,metadata_train = \\\n            ydata_train.to(dev),metadata_train.to(dev) \n        \n        # reset gradients to zero\n        optimizer.zero_grad()\n        \n        # run model and compute loss\n        N,C,nX,nY = X_train.size()\n        y_pred_train = model(X_train.view(N,C,nX,nY),\n                             metadata_train)\n        loss_train = loss_fn(y_pred_train.squeeze(),\n                             ydata_train)\n        \n        # Back propagation\n        loss_train.backward()\n        \n        # Update the parameters\n        optimizer.step()\n        \n        # Compute and update loss for entire training set\n        running_loss_train += \\\n            loss_train.cpu().detach().numpy()\n        num_batches_train += 1 \n       \n        for i in range(len(ydata_train)):\n            error_train[i] = \\\n            abs(ydata_train[i].item() - \\\n            y_pred_train.squeeze()[i].item())\/ydata_train[i].item()\n        \n        error_train_sum = sum(error_train)\n        running_error_train = running_error_train + \\\n            error_train_sum\n        \n        j = j+1 # Step batch counter\n    \n        \n    k = 0  # Re-initialize batch counter for validation\n    model.eval()  # Set torch for evaluation\n    for X_val,_ in loader_val:\n        X_val = X_val.to(dev) \n        # (X,y) is a mini-batch:\n        # X size Nx3xHxW (N: batch_size, 3: three ch )\n        # y size N\n        \n        # Get metadata in batches from function\n        ydata_val,metadata_val = \\\n            get_batch_val(batch_size,k)\n        ydata_val,metadata_val = \\\n            ydata_val.to(dev),metadata_val.to(dev) \n        \n        # run model and compute loss\n        N,C,nX,nY = X_val.size()\n        y_pred_val = model(X_val.view(N,C,nX,nY),\n                           metadata_val)\n        loss_val = loss_fn(y_pred_val.squeeze(),\n                           ydata_val)\n        \n        # Compute and update loss for entire val set\n        running_loss_val += \\\n            loss_val.cpu().detach().numpy()\n        num_batches_val += 1 \n        \n        for i in range(len(ydata_val)):\n            error_val[i] = \\\n            abs(ydata_val[i].item() - \\\n            y_pred_val.squeeze()[i].item())\/ydata_val[i].item()\n        \n        \n        error_val_sum = sum(error_val)\n        running_error_val = running_error_val + \\\n            error_val_sum\n        \n        k = k+1  # Step batch counter\n\n    ave_loss_train = running_loss_train\/num_batches_train\n    ave_loss_val = running_loss_val\/num_batches_val\n    ave_error_train = \\\n        (running_error_train.item()\/len(y_train))*100\n    ave_error_val = \\\n        (running_error_val.item()\/len(y_val))*100\n\n\n# ============================================\n\n    \n    # Store loss to tensor for plotting\n    result_vals[epoch, 0] = ave_loss_train\n    result_vals[epoch, 1] = ave_loss_val\n    result_vals[epoch, 2] = ave_error_train\n    result_vals[epoch, 3] = ave_error_val\n    \n    # Print loss every N epochs\n    #if epoch % 2 == 1:\n    print(epoch, '      ', round(ave_loss_train.item(),5), \n          '     ', round(ave_loss_val.item(),5), \n          '   ', round(ave_error_train,5),'  ', \n          round(ave_error_val,5))\n\n# =================================================    ","16493012":"    \n# =================================================    \n# End Timing Code\ntoc = time.perf_counter()\n\n# Measure Time\nruntime = toc - tic\n\nprint(' ')\nprint('Computing Time')\nprint(runtime)\n\n\n# ==============================================\n# Plot Loss and Accuracy for train and val sets\n# ==============================================\n\nxvals = torch.linspace(0, num_epochs, num_epochs+1)\nplt.plot(xvals[0:num_epochs].cpu().numpy(), \n         result_vals[:,0].cpu().detach().numpy())\nplt.plot(xvals[0:num_epochs].cpu().numpy(), \n         result_vals[:,1].cpu().detach().numpy())\nplt.legend(['loss_train', 'loss_val'], \n           loc='upper right')\n#plt.xticks(xvals[0:num_epochs])\nplt.title('Loss (CNN + MLP Model)')\nplt.xlabel('epochs')\nplt.ylabel('loss')\nplt.tick_params(right=True, labelright=True)\n# plt.savefig('loss.pdf', bbox_inches='tight', dpi=2400)\nplt.show()\n#\n#\n# For plotting percent error (which needs to be added above)\nplt.plot(xvals[0:num_epochs].cpu().numpy(), \n         result_vals[:,2].cpu().detach().numpy())\nplt.plot(xvals[0:num_epochs].cpu().numpy(), \n         result_vals[:,3].cpu().detach().numpy())\nplt.legend(['error_train', 'error_val'], \n           loc='upper right')\n#plt.xticks(xvals[0:num_epochs])\nplt.title('Percent Error (CNN + MLP Model)')\nplt.xlabel('epochs')\nplt.ylabel('ave_error')\nplt.tick_params(right=True, labelright=True)\n# plt.ylim(-0.15, 1.0)\nplt.show()\n\n## ==============================================","3f0a2813":"### **Imports and Parameters**\n\nBelow we perform standard imports, choose computing device, define parameters, and set a seed for reproducible results. Note that due to this, the shuffle feature in the data loader is chosen as False to prevent overriding seed. This also ensures that the numeric data loader (defined below) will be in step with the image loader. Approximate timer is also initialized.  ","0558a0a2":"### **Introduction**\n\nThe following model is intended for predicting house prices based on input images and corresponding numeric data such as beds, baths, etc. There are a few options for achieving this, and here we have chosen to use a hybrid CNN + MLP model. The CNN routinely handles the images, and the numeric data is handled by the MLP. The outputs of the MLP and the fully connected (FC) layers of the CNN are concatenated into another set of FC layers, which have a final output of a price prediction in the continuous range of $[0,1]$. The model is purposely lightweight in order to run efficiently with the goal of squeezing as much performance as possible out of the system, without large computational demands. Due to the small model size, a 2X performance improvement is obtained with GPU, but not much more. Note that 20 epochs takes about 4 minutes on GPU.\n\n![CNN_MLP_Hybrid_Arch.png](attachment:1c2f12b3-d64b-4aa4-9bf2-545e1f562abb.png)","bf6fdab2":"### **Import Numeric Data**\n\nBelow we import the CSV numeric data into a dataframe and then extract the needed values into appropriate tensors. Following this, the data is normalized on a scale of $[0,1]$. One can also standardize the data instead using e.g. the z-norm. Writing a function to handle the repetitive operations below would be a  useful modification to the code.","de3ba718":"### **CNN + MLP Model in PyTorch**","2b3c508b":"### **CNN + MLP Hybrid Model**\n\nBelow we define the CNN+MLP model architecture. This particular model is set up for images of size 100x100. It was found that larger images were not necessarily helpful in improving performance.","cf15413b":"### **Numeric Data Loaders**\n\nBelow we have created data loader functions for pulling out and storing batches of numeric data for train and validation. These batches will be of the same size as the image batches and correspond to the appropriate houses. It is fairly easy to combine into one function but here, for readability, there are two. ","2a8882c6":"### **Image Transforms**\n\nBelow we set up transforms for the housing images which may or may not be of equal size (which they must be for the CNN). They also need to be reduced in resolution and cropped. Simply for convenience, a size of 100x100 pixels is chosen according to the parameters above. Note that 157\/1.5625 = 100.\n\nThe images are not color normalized but this is a potentially useful addition that can be employed to improve model learning.","e5ac360b":"### **Conclusion and Plotting Results**\n\nBelow, the computing time is obtained, followed by plotting the loss and percent error in house prediction. Note that with the given (relatively small) data set and limited features (beds, baths, and rooms), this model reaches about 49 percent error (train) and 40 percent error (validation). Obviously this result can be improved, but it is a reasonable starting point. To interpret, if a house costs 200K dollars, the error is about +\/- 80K dollars. A better estimate (and better agreement between train and val) can be achieved with k-fold cross validation due to the small size of data set. More images\/data can improve the overall accuracy as well if overfitting are kept under control. The CNN+MLP model may also benefit from employing batch-norm and drop-out. Finally, one important data feature which was not included in the CSV file is the house addresses. If these are converted to numeric GPS coordinates and used for training, it should have a significant impact on prediction accuracy since house price is well-known to be influenced by location. This update to the data is forthcoming.","ffd850c4":"### **Image Data Loaders**\n\nBelow we create data loaders for the images with shuffle = False, to maintain order with the numeric data loader above.","c5cf1214":"### **Training Loop**\n\nBelow is the model training loop as well as the validation loop in each epoch. The average loss values and percent error are computed per epoch and stored in tensors for later plotting after training. ","d6beeb1e":"### **Loss Function and Optimizer**\n\nBelow we define an instance of the model class 'Net', choose the loss function, and the optimizer. The particular choice of MSE loss is due to the requirement of a regression (continuous) output from the model, which is the price prediction. "}}