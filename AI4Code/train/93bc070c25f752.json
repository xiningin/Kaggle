{"cell_type":{"c365822d":"code","6534b603":"code","309df956":"code","30cca3a4":"code","8a02fdde":"code","3f5b705c":"code","c00ccfa5":"code","6de93597":"code","b3be2fae":"code","3103bdbc":"markdown","cd374eb5":"markdown","175851f2":"markdown","f2be74b4":"markdown","c3b6ef59":"markdown","eb3a9091":"markdown","7951bba9":"markdown","eed755d6":"markdown","4f7453ab":"markdown"},"source":{"c365822d":"##### LIBRARIES\n\nimport numpy as np \nimport pandas as pd \nfrom tqdm import tqdm ","6534b603":"##### BASE MODELS\n\nmodel_list = ['\/kaggle\/input\/bms-norm-v22\/submission_norm.csv',\n              '\/kaggle\/input\/bms-norm-v17\/submission_norm.csv',\n              '\/kaggle\/input\/bms-normalization-v21\/submission_norm.csv',\n              '\/kaggle\/input\/bms-normalization-v2733\/submission_norm.csv',\n              '\/kaggle\/input\/bms-normalization-v20\/submission_norm.csv',\n              '\/kaggle\/input\/bms-normalization-v6\/submission_norm.csv',\n              '\/kaggle\/input\/bms-normalization-public\/submission_norm.csv']","309df956":"##### PREPARE MODEL PREDICTIONS\n\nmodels = []\n\nfor model in model_list:\n    sub = pd.read_csv(model)\n    sub = sub.sort_values('image_id').reset_index(drop = True)\n    print('- {}: {}'.format(model, sub.shape))\n    models.append(sub)","30cca3a4":"##### IMPORT PARTIAL PREDICTIONS\n\npart_sub = pd.read_csv('\/kaggle\/input\/bms-normalization-bad-27\/submission_norm.csv')\npart_sub = part_sub.sort_values('image_id').reset_index(drop = True)\nprint(part_sub.shape)","8a02fdde":"##### CHECK PREDICTION FORMAT\n\nsub = models[0].copy()\ndisplay(sub.head())\nprint('\\nEvents:')\ndisplay(sub['event'].value_counts())","3f5b705c":"##### ENSEMBLING\n\n# placeholders\nnum_equals  = []\nmodel_preds = []\n\n# loop through test molecules\nfor i in tqdm(range(len(sub))):\n    \n    # extract base model predictions and mode\n    preds     = [model.iloc[i]['InChI'] for model in models]\n    mode      = max(set(preds), key = preds.count)\n    num_equal = preds.count(mode)\n    num_equals.append(num_equal)\n    \n    # set prediction to mode\n    if num_equal >= 4:\n        sub.loc[i, 'InChI'] = mode\n        model_preds.append('mode')\n        \n    else:\n        \n        # look for valid pred from all models\n        valid_pred = False\n        for m in range(len(models)):\n            if models[m].loc[i, 'event'] == 'valid':\n                sub.loc[i, 'InChI'] = models[m].loc[i, 'InChI']\n                model_preds.append(model_list[m])\n                valid_pred = True\n                break\n                \n        # set preds to lowest-CV model\n        if not valid_pred:\n            sub.loc[i, 'InChI'] = models[0].loc[i, 'InChI']\n            model_preds.append(model_list[0])\n                \n        # set preds to better model if possible\n        if not valid_pred:\n            image_id = sub.loc[i, 'image_id']\n            if image_id in list(part_sub['image_id'].values):\n                if part_sub.loc[part_sub['image_id'] == image_id]['event'].item() == 'valid':\n                    sub.loc[i, 'InChI'] = part_sub.loc[part_sub['image_id'] == image_id, 'InChI'].item()\n                    model_preds.append('part_model')","c00ccfa5":"##### CHECK NO. EQUAL PREDS DISTRIBUTION\n\npd.Series(num_equals).value_counts()","6de93597":"##### CHECK MODEL PREDS DISTRIBUTION\n\npd.Series(model_preds).value_counts()","b3be2fae":"##### EXPORT SUBMISSION\n\nsub = sub[['image_id', 'InChI']]\nsub.to_csv('submission.csv', index = False)\nsub.head()","3103bdbc":"I also import another model that produces partial predictions for 273k molecules that proved to be more challenging to translate in my previous experiments. The predictions are done using a beam search with a larger `k`.","cd374eb5":"# ENSEMBLING\n\nThe ensembling is done in the following way:\n1. If 4\/7 models have the same output, set the final prediction to this mode value.\n2. Else:\n    - go through each model starting from the best-performing one and set prediction to a first model with valid output\n    - if there are now valid outputs, set prediction to the output of the lowest-CV model\n    - if output of the partial model is available and valid, overwrite prediction for this molecule","175851f2":"Following the idea of @nofreewill, I store three possible events in the process of InChI normalization: `['valid', 'none', 'error']`. Value `valid` means that RDKit was able to convert prediction to a valid InChI string.  ","f2be74b4":"In many cases, our models agree quite well with each other.","c3b6ef59":"As expected, most predictions are coming from model `v22`. Very few molecules are translated by the last models in a row, suggesting that usually at least one of the models is able to provide valid edictions.","eb3a9091":"# SUMMARY\n\nThis notebook reproduces my submission that scores **1.31** on the private LB and reaches the **47th place**. The notebook implements ensemble of CNN-LSTM models using model predictions saved as Kaggle datasets. \n- solution summary is published [in this discussion topic](https:\/\/www.kaggle.com\/c\/bms-molecular-translation\/discussion\/243845)\n- complete training codes are available [in this GitHub repo](https:\/\/github.com\/kozodoi\/BMS_Molecular_Translation)\n\nThe table with the main model parameters and CV performance (before beam searchg and normalization) is provided below.\n![models](https:\/\/i.postimg.cc\/cLrTp1Pc\/Screen-2021-06-04-at-10-17-02.jpg)","7951bba9":"# PREPARATIONS","eed755d6":"# SUBMISSION","4f7453ab":"Below we define a list with seven base models. For each of these models, test molecule predictions are stored as Kaggle datasets after beam-search with `k = 5` (thanks @tugstugi) and `RDKit`-based normalization (thanks @nofreewill). The models are sorted by their performance after beam search and normalization in the ascending order (the first model performs best)."}}