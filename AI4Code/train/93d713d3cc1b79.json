{"cell_type":{"07688619":"code","84186669":"code","fee54b87":"code","1a733647":"code","c7c0664e":"code","856f546d":"code","0d5f6264":"code","02f27dd9":"code","15d509d6":"code","fd39455e":"code","879706c3":"code","89f6a79a":"code","840da8f8":"code","5e5f56ac":"code","b07c6972":"code","9c93f2bc":"code","76416279":"code","c8acc768":"code","23aeddb6":"code","03417e50":"code","891d0ace":"code","00c811b1":"code","e1a6d3f3":"code","c6fea8e3":"code","8f83cb17":"code","d18f9647":"code","9020fc9d":"code","6376e5e5":"code","2da6aac2":"code","934ada9d":"code","254e39c8":"markdown","74e0085c":"markdown","8ffe4e78":"markdown","3402f6bc":"markdown","4188281b":"markdown","e1505941":"markdown","81849e2b":"markdown","5026125f":"markdown","dc522951":"markdown","8299459f":"markdown","efd3bc6d":"markdown","b1a74a64":"markdown"},"source":{"07688619":"#loading libraries \nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom numpy import asarray\nimport tensorflow as tf\nimport cv2   #import comp vision library\nimport os    #import directory and related lib\nimport math\nfrom skimage import transform \nimport cv2\nimport random\nimport seaborn as sns","84186669":"#function for image transforming in order to add augmented image to the dataset\ndef brightness(img, low, high):                  \n    value = random.uniform(low, high)\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    hsv = np.array(hsv, dtype = np.float64)\n    hsv[:,:,1] = hsv[:,:,1]*value\n    hsv[:,:,1][hsv[:,:,1]>255]  = 255\n    hsv[:,:,2] = hsv[:,:,2]*value \n    hsv[:,:,2][hsv[:,:,2]>255]  = 255\n    hsv = np.array(hsv, dtype = np.uint8)\n    img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)\n    return img\n\n#function to load images, indices, and file_names from the input image folder\ndef load_images_from_folder(folder, start, end, augment=0):\n    \n    i = 0\n    ht_max, wd_max, cc_max = 0, 0, 0\n    ht_min, wd_min, cc_min = 0, 0, 0\n    images = []\n    files = []\n    index = []\n    \n    for filename in os.listdir(folder):    #loop for each file present in the folder        \n        img = cv2.imread(os.path.join(folder,filename))        \n        if img is not None and i <= end and i >= start:            \n            img = asarray(img)            \n            files.append(str(filename))\n            index.append(i)            \n            if (i == math.floor(start + (end-start)\/4)):\n                print(\"--------> (25%) Processing for record:\", i)\n            if (i == math.floor(start + (end-start)\/2)):\n                print(\"--------> (50%) Processing for record:\", i)                \n            ht, wd, cc= img.shape\n            top_pad, bottom_pad, left_pad, right_pad = 256-ht, 0, 256-wd, 0\n            img_padded = cv2.copyMakeBorder(img, top_pad, bottom_pad, left_pad, right_pad, cv2.BORDER_DEFAULT)\n            if i == 0:     #base case    \n                images.append(img_padded)\n                print('-------> Staring collecting images')\n            else:          #other cases\n                if ht > ht_max :\n                    ht_max = ht\n                if wd > wd_max :\n                    wd_max = wd\n                if cc > cc_max :\n                    cc_max = cc\n                if ht < ht_min :\n                    ht_min = ht\n                if wd < wd_min :\n                    wd_max = wd\n                if cc < cc_min :\n                    cc_min = cc\n                images.append(img_padded)                \n            if augment==1:\n                for j in range(15):\n                    new_img = brightness(img_padded, 0.1, 1)\n                    i = i+1\n                    index.append(i)\n                    images.append(new_img)\n                    files.append(str(filename).split('.')[0]+'a'+str(i)+'.jpg')   \n                \n        i = i + 1        \n        if i == end:        #breaking condition\n            break\n    print('------> Loading images ..........  Done')\n    return images, files, index","fee54b87":"#location of Cross-class input folder\ncross_test_folder=\"..\/input\/cross-test\/Cross_test\/\"\ncross_train_folder=\"..\/input\/cross-training\/Cross_Training\/\"\n\n#loading images and other variables for \"cross\" class\ncross_train_images, cross_train_files, cross_train_index = load_images_from_folder(cross_train_folder, 0, 100)\ncross_train_images = asarray(cross_train_images)\nct_df_metadata = pd.DataFrame(list(zip(cross_train_files, cross_train_index)))\nct_df_metadata.columns=['FileName', 'Index']\nct_df_metadata['class']=1             #label: 1 for Cross, 0 for T\ndel cross_train_files, cross_train_index\n\nct_df_metadata","1a733647":"ct_df_metadata.shape","c7c0664e":"#location of T-class input folder\nT_train_folder=\"..\/input\/t-train\/T_Training\/\"\nT_test_folder=\"..\/input\/t-test\/T_test\/\"\n\n#loading images and other variables for \"T\" class and add augmented images\nT_train_images, T_train_files, T_train_index = load_images_from_folder(T_train_folder, 0, 100, 1)\nT_train_images = asarray(T_train_images)\nT_df_metadata = pd.DataFrame(list(zip(T_train_files, T_train_index)))\nT_df_metadata.columns=['FileName', 'Index']\nT_df_metadata['class']=0             #label: 1 for Cross, 0 for T\ndel T_train_files, T_train_index\n\n#print(images.shape)\nT_df_metadata.Index=T_df_metadata.Index+ct_df_metadata.shape[0]\nT_df_metadata\n\n# concatenating the metadata of both the classes\ntrain_df_metadata = pd.concat([ct_df_metadata, T_df_metadata], axis=0)","856f546d":"T_df_metadata","0d5f6264":"# generating the training set with the samples of cross and t-classes\ntrain_images = np.concatenate((cross_train_images,T_train_images), axis=0)","02f27dd9":"print(train_df_metadata['class'].value_counts())\n# plot value_counts of Series\nax = train_df_metadata['class'].value_counts().plot(kind='barh')","15d509d6":"train_df_metadata","fd39455e":"#setting up input to the model, \nX_all = asarray(train_images)\n\ny_all = (train_df_metadata['class']).to_numpy()","879706c3":"X = X_all\ny = y_all","89f6a79a":"# CNN model designed as classifier\nimport sys\nfrom numpy import load\nfrom matplotlib import pyplot\nfrom sklearn.model_selection import train_test_split\nfrom keras import backend\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D\nfrom keras.layers import MaxPooling2D\nfrom keras.layers import Dense\nfrom keras.layers import Flatten\nfrom tensorflow.keras.optimizers import SGD\nfrom tensorflow.keras.optimizers import Adam\nfrom keras import metrics\n\nin_shape=(X.shape[1], X.shape[2], 3)\n# out_shape = y.shape[1]\nout_shape = 1\n\nmodel = Sequential()    \n    \n#filter size is 3*3*volume; number of filters = 32; activation=relu; \nmodel.add(Conv2D(32, (3, 3), activation='relu', padding='same', input_shape=in_shape))    \nmodel.add(Conv2D(32, (3, 3), activation='relu', padding='same'))\nmodel.add(MaxPooling2D((2, 2)))\nmodel.add(Conv2D(64, (3, 3), activation='relu', padding='same'))\n#model.add(Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same'))\nmodel.add(MaxPooling2D((2, 2)))\n\n#fully connected layer\nmodel.add(Flatten())\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dense(out_shape, activation='sigmoid'))\n \n# compile model\nopt = Adam(learning_rate=0.01)\nmodel.compile(optimizer=opt, loss='binary_crossentropy', metrics=['accuracy'])\n# model.compile(optimizer=opt, loss='mean_squared_error', metrics=[metrics.mse])","840da8f8":"# summary of model with trainable parameters\nmodel.summary()","5e5f56ac":"# labels for training data\ny","b07c6972":"trainX, valX, trainY, valY = train_test_split(X, y, test_size=0.2)\n\nhistory = model.fit(trainX, trainY, epochs=50, validation_data=(valX, valY), verbose=2)\n","9c93f2bc":"pyplot.subplot(211)\npyplot.title('accuracy')\npyplot.plot(history.history['accuracy'], color='blue', label='train')\npyplot.plot(history.history['val_accuracy'], color='orange', label='test')\n# Function add a legend  \npyplot.legend([\"training\", \"validation\"], loc =\"lower right\")","76416279":"all_test = '..\/input\/all-test-folder\/All_testing\/'\ntest_images, test_files, test_index = load_images_from_folder(all_test, 0, 100)\ntest_images = asarray(test_images)\ntest_df_metadata = pd.DataFrame(list(zip(test_files, test_index)))\ntest_df_metadata.columns=['FileName', 'Index']\n\n#print(images.shape)\ntest_df_metadata","c8acc768":"test_images.shape","23aeddb6":"pred_y = model.predict(test_images)\ntest_df_metadata['prediction']=pred_y","03417e50":"pred_y = pred_y.round()","891d0ace":"pred_y","00c811b1":"test_df_metadata['class'] = test_df_metadata.apply(lambda x: 'Cross' if x['prediction']==1 else 'T', axis=1)\ntest_df_metadata['new_image'] = test_df_metadata.apply(lambda x: (str(x['FileName'])).split('.')[0]+'_'+ str(x['class']) + '.jpg', axis=1 )","e1a6d3f3":"test_df_metadata","c6fea8e3":"import shutil\nimport os\nfolder = '..\/input\/mask-output-without-classification\/'\nsave_maske_images_dir = 'masks'\nos.mkdir(save_maske_images_dir)\n\nfor filename in os.listdir(folder):    #loop for each file present in the folder\n    original = os.path.join(folder,filename)\n    newname = ((test_df_metadata.loc[test_df_metadata.FileName == str(filename)]).new_image).iloc[0]\n    target = '.\/masks\/'+ str(newname)\n    shutil.copyfile(original, target)","8f83cb17":"mask_info = pd.read_csv('..\/input\/mask-csv-without-classification\/mask_csv.csv', index_col=False)","d18f9647":"df_mask_with_class = mask_info.merge(test_df_metadata, left_on='imageid', right_on='FileName')","9020fc9d":"df_mask_with_class['list_coordinate']= list(zip(df_mask_with_class.pred_xmin, df_mask_with_class.pred_ymin,  df_mask_with_class.pred_xmax,  df_mask_with_class.pred_ymax))","6376e5e5":"df_final = df_mask_with_class[['imageid', 'class', 'list_coordinate']]","2da6aac2":"#writing into a csv file\ndf_final.to_csv('pred_with_class.csv')","934ada9d":"df_final","254e39c8":"### Training set for modelling the classifier","74e0085c":"### Ploting training vs validation accuracy","8ffe4e78":"### Config file specifying file directory and performing loading of the image files ","3402f6bc":"### CNN-based classifier model","4188281b":"### Functions for image loading and augmentation ","e1505941":"### Asserting the input image and label for training","81849e2b":"### Spliting into train and validation set and fitting the model","5026125f":"### Predicting the class-label for test-images","dc522951":"### Creating the final dataframe with columns as: \n##### ['image-id', 'predicted_class', 'boundary co-ordinate for identified intersection area']","8299459f":"### Reading the test-images for classifying using the trained model","efd3bc6d":"### Importing the libraries","b1a74a64":"### Writing the class-label with the test-image masks"}}