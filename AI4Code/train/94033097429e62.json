{"cell_type":{"f62a3afa":"code","c33f975d":"code","ddd2da3f":"code","604d851b":"code","e9a795e3":"code","1f0542f9":"code","de2ef007":"code","676fd94b":"code","190febda":"code","43058b75":"code","50de7113":"code","f992f4e5":"code","fadf1130":"code","ac69edd8":"code","6c613aad":"code","b85e62fd":"code","c55267c1":"code","be3e9ad3":"code","adce9455":"code","57c10eb9":"code","9e51a642":"code","6b42d32e":"code","df985654":"code","c6b4eed2":"code","67df4d4a":"code","43da0824":"code","f318f2ce":"code","c6e883d4":"code","c455615d":"code","2aaef7e0":"code","85a68ccd":"code","738eeac7":"code","b238dc5e":"code","6d3e37a3":"markdown","5476f7fc":"markdown","b543478c":"markdown","5c89afc5":"markdown","dc00e501":"markdown","b6072157":"markdown","8c8e6e9a":"markdown","ab36d48c":"markdown","0f2baa78":"markdown","c4858e7e":"markdown","2db21195":"markdown","10a5d30a":"markdown","222fc5af":"markdown","04c65e5e":"markdown","9e9ce89a":"markdown","9f37483d":"markdown","6c0f4c7d":"markdown","7f4d8a0d":"markdown","bdef404c":"markdown","abd25635":"markdown","9c3461d5":"markdown","db3ba0a6":"markdown","59d5c923":"markdown","d0897f18":"markdown","b2067c71":"markdown","5bfe38df":"markdown","93e69320":"markdown","5c038206":"markdown","40a910b4":"markdown","11442e05":"markdown","20a5ca6f":"markdown","7b6e011f":"markdown","cf09b055":"markdown","050d0602":"markdown","46d2e70f":"markdown","436d3047":"markdown","343fdb92":"markdown","ad13e449":"markdown","f4e0bf48":"markdown","c13ce8dc":"markdown","f6715f3d":"markdown","202df6b7":"markdown","05aaf9b9":"markdown","2d9c9c85":"markdown"},"source":{"f62a3afa":"%%javascript\n$.getScript('https:\/\/kmahelona.github.io\/ipython_notebook_goodies\/ipython_notebook_toc.js')","c33f975d":"import sys, os\n\nfrom plotly.offline import init_notebook_mode, iplot\nimport plotly.graph_objs as go\nimport plotly.figure_factory as ff\ninit_notebook_mode()\n\n# use plotly cufflinks\nimport plotly.tools as tls\ntls.embed('https:\/\/plot.ly\/~cufflinks\/8')\nimport cufflinks as cf\n# ensure offline mode\ncf.go_offline()\ncf.set_config_file(world_readable=False,offline=True, theme='ggplot')\n\nfrom scipy.stats import spearmanr\nimport numpy as np\nimport pandas as pd\nfrom pandas_summary import DataFrameSummary\n\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import roc_auc_score, roc_curve, auc\nfrom sklearn.model_selection import StratifiedKFold, train_test_split\n\n\nimport tensorflow as tf\n\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras import regularizers\n\nfrom keras import backend as K\nfrom keras import regularizers\nfrom keras.layers import Dropout\nfrom keras.constraints import max_norm\nfrom keras.wrappers.scikit_learn import KerasClassifier","ddd2da3f":"id_col = 'ID_code'\ntarget_col = 'target'\ndf_play = pd.read_csv('..\/input\/train.csv', index_col=id_col, low_memory=False)\ndf_comp = pd.read_csv('..\/input\/test.csv', index_col=id_col, low_memory=False)","604d851b":"train_df, test_df = train_test_split(df_play, test_size=.1, train_size=.1, stratify=df_play.target, shuffle=True, random_state=0)","e9a795e3":"# prepare training and validation dataset\nX = train_df.drop(target_col, axis=1)\ny = train_df[target_col]\nX_val = test_df.drop(target_col, axis=1)\ny_val = test_df[target_col]","1f0542f9":"# limit the columns that are returned from summarize\n# restricted to numeric by difference of values in compare_dataframes \nmain_cols = ['std', 'min', 'mean', 'max', 'counts', 'missing', 'uniques']\n\n\ndef summarize(df, sample_size=0):\n    \"sumamrize a dataframe for quality assesment\"\n    dtypes = pd.DataFrame(df.dtypes, columns=['dtype'])\n    stats = DataFrameSummary(df).summary().T\n    summary = dtypes.merge(stats, left_index=True, right_index=True)\n    summary = summary.merge(dtypes.rename({'dtype':'dtype2'}, axis=1), left_index=True, right_index=True).rename({'dtype':'dtype1'}, axis=1).sort_values('dtype1')\n    if sample_size:\n        samples = df.sample(sample_size).T\n        summary = samples.merge(summary, left_index=True, right_index=True).rename({'dtype':'dtype1'}, axis=1).sort_values('dtype1')\n        return summary \n    else:\n        return summary[main_cols]\n    \ndef display_all(df):\n    \"display the entirity of a dataframe in the cell with scroll bars\"\n    with pd.option_context(\"display.max_rows\", 1000, \"display.max_columns\", 1000):\n        display(df)\n\n\ndef compare_dataframes(train_df, test_df, target_col):\n    \"compare the summaries for 2 dataframes\"\n    # make summaries for the train and test data sets and join them together\n    test_summary = summarize(test_df)\n    train_summary = summarize(train_df.drop(target_col, axis=1))\n    summary = train_summary.merge(test_summary, left_index=True, right_index=True, suffixes=('_train', '_test'))\n    # take the differnce of summary values and make a dataframe of them and return it \n    train_test_diff_df = pd.DataFrame(test_summary.values - train_summary.values, index=test_summary.index, columns=[c + '_diff' for c in main_cols])\n    summary = summary.merge(train_test_diff_df, left_index=True, right_index=True)\n    return summary","de2ef007":"summary = compare_dataframes(df_play, df_comp, target_col)","676fd94b":"display_all(summary.sort_index(axis=1, ascending=False).sort_values('std_diff', ascending=False))","190febda":"inspect_col = 'std_train'\nsummary[inspect_col].iplot(kind='hist', bins=100, title=f'Frequency Histogram for {inspect_col}', \n                          yTitle=f'Number of times value appeared', xTitle=f'Value for {inspect_col}')","43058b75":"hist_data = [list(summary[inspect_col].values - summary[inspect_col].values.mean())]\nlabels = [inspect_col]    \n\nfig = ff.create_distplot(hist_data, labels)\n\n# update the plot titles\nfig.layout.xaxis.update(title=f'Value for {inspect_col}')\nfig.layout.yaxis.update(title=f'Probability that value appeared')\nfig.layout.update(title=f'Distribution Plot for {inspect_col}');\n\niplot(fig)","50de7113":"corr = np.round(spearmanr(train_df).correlation, 4)\ndf_corr = pd.DataFrame(data=corr, index=train_df.columns, columns=train_df.columns)","f992f4e5":"keep = np.triu(np.ones(df_corr.shape)).astype('bool').reshape(df_corr.size)\nc = df_corr.stack()[keep]","fadf1130":"c = c.loc[c.index.get_level_values(1)!=c.index.get_level_values(0),]\nc = c.loc[c.index.get_level_values(0)!='target',]","ac69edd8":"N_corr = 20\nc.sort_values()[-N_corr:]","6c613aad":"c.sort_values()[:N_corr]","b85e62fd":"def dist_plots(var_name='var_1', sample_size=5000):\n    \"Make a distribution plot for a single variable from the dataset\"\n    hist_data = [df_play[var_name].sample(sample_size).values, df_comp[var_name].sample(sample_size).values]\n    group_labels = ['train', 'test']\n    fig = ff.create_distplot(hist_data, group_labels, show_hist=False, show_rug=False)\n    return fig","c55267c1":"offset = 50\nplots = [dist_plots(f'var_{i+offset}') for i in range(25)]\n\nfor ix, plot in enumerate(plots, 1):\n    plot.layout.update(title=f'var {ix+offset}')\n    for trace in plot.data:\n        trace.showlegend = False","be3e9ad3":"iplot(cf.subplots(plots, shape=(5, 5), \n                  subplot_titles=[f'var_{i+offset}' for i in range(25)]))","adce9455":"from sklearn.preprocessing import StandardScaler\nsc = StandardScaler()\nX_sc = sc.fit_transform(X)\nX_val_sc = sc.transform(X_val)","57c10eb9":"roc_data = {}\nroc_auc_scores = {}\nprediction_df = y_val.to_frame('ground_truth')","9e51a642":"def make_roc_fig(roc_data=None):\n    \"Takes a list of roc_curve results and plots each of the items on the same figure\"\n    if not roc_data: roc_data = {}\n    data = []\n    # plot the line for random chance comparison\n    trace = go.Scatter(x=[0, 1], y=[0, 1], \n                       mode='lines', \n                       line=dict(width=2, color='black', dash='dash'),\n                       name='Luck')\n    data.append(trace)\n    # plot each of the roc curves given in arg\n    for clf_name, roc in roc_data.items():\n        fpr, tpr, thresholds = roc\n        roc_auc = auc(fpr, tpr)\n        trace = go.Scatter(x=fpr, y=tpr, \n                           mode='lines', \n                           line=dict(width=2),\n                           name=f'{clf_name} ROC AUC (area = {roc_auc:0.2f})')\n        data.append(trace)\n    # add layout\n    layout = go.Layout(title='Receiver Operating Characteristic',\n                       xaxis=dict(title='False Positive Rate', showgrid=False,\n                                  range=[-0.05, 1.05]),\n                       yaxis=dict(title='True Positive Rate', showgrid=False,\n                                  range=[-0.05, 1.05]))\n    # create fig then return\n    fig = go.Figure(data=data, layout=layout)\n    return fig\n\ndef score_model(clf_name ,y_pred):\n    \"collect data from the models prediction for final analysis and model comparison. Return the roc curve data for immediate plotting\"\n    # Make predictions and add to df for final summary\n    prediction_df[clf_name] = y_pred\n    # Store score for final judegment\n    score = roc_auc_score(y_val, y_pred)\n    roc_auc_scores[clf_name] = score\n    # Make the ROCs for plotting\n    roc = roc_curve(y_val, y_pred)\n    roc_data[clf_name] = roc\n    print(f'The {clf_name} model has ROC AUC: {score}')\n    return roc","6b42d32e":"rf_param = {\n 'min_samples_leaf': 10,\n 'max_features': .5,\n 'n_estimators': 100}","df985654":"rfm = RandomForestClassifier(**rf_param, n_jobs=-1, random_state=0)\nrfm.fit(X, y)","c6b4eed2":"clf_name = 'rf'\n\ny_pred = rfm.predict_proba(X_val)[:,1]\n\nroc = score_model(clf_name, y_pred.tolist())\n\niplot(make_roc_fig({clf_name: roc}))","67df4d4a":"rfm = RandomForestClassifier(**rf_param, n_jobs=-1, random_state=0)\nrfm.fit(X_sc, y)","43da0824":"clf_name = 'rf_sc'\n\ny_pred = rfm.predict_proba(X_val_sc)[:,1]\n\nroc = score_model(clf_name, y_pred)\n\niplot(make_roc_fig({clf_name: roc}))","f318f2ce":"def dnn_auc(y_true, y_pred):\n    auc = tf.metrics.auc(y_true, y_pred)[1]\n    K.get_session().run(tf.local_variables_initializer())\n    return auc","c6e883d4":"def create_dnn():\n    model = Sequential()\n    model.add(Dense(200, input_dim=200, kernel_initializer='normal', activation='relu'))\n    model.add(Dense(1, kernel_initializer='normal', activation='sigmoid'))\n    # Compile model\n    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[dnn_auc])\n    return model\n\nmodel = create_dnn()","c455615d":"model.fit(X, y, batch_size = 10000, epochs = 200, validation_data = (X_val, y_val), )","2aaef7e0":"clf_name = 'dnn'\n\ny_pred = model.predict(X_val)\n\nroc = score_model(clf_name, y_pred)\n\niplot(make_roc_fig({clf_name: roc}))","85a68ccd":"model = create_dnn()\nmodel.fit(X_sc, y, batch_size = 10000, epochs = 200, validation_data = (X_val_sc, y_val), )","738eeac7":"clf_name = 'dnn_sc'\n\ny_pred = model.predict(X_val_sc)\n\nroc = score_model(clf_name, y_pred)\n\niplot(make_roc_fig({clf_name: roc}))","b238dc5e":"iplot(make_roc_fig(roc_data))","6d3e37a3":"Without any missing values for any features we do not need any kind of imputation. We can perfrom standard scaling on the features to see if that improves the model's performance. ","5476f7fc":"### Separate features from targert variable","b543478c":"From this we can visual inspect the difference in distributions for our trainable dataset version the competition dataset.","5c89afc5":"Then we can remove the rows showing correlation between a feature and itself. Also we can remove the correlation between features and the target variable.","dc00e501":"Here is a comparison of two models, Random Forest and a simple DNN Feed Forward Network. Most of the ways to improve the models have yet to be implemented, but they still have a reasonably good skill. Examples of such are otpimizing other hyperparameters, experiment with these ones further, training the models on the full dataset etc...\n\nFor comparison the model is fitted to both the scaled and unscaled data and the Receiver Operator Characteristic curve will be plotted. Afterwards all curves are shown on a single plot and models are judged by the sum of the area under its ROC curve, calculated with `roc_auc_score` and `dnn_auc`.","b6072157":"# Model Performance Indicator","8c8e6e9a":"We can see see that scaling the features has increased NN's score, whereas it stayed exactly the same for the random forest. This is the expected behavior for each of the models, and the both have given OK results for a start.","ab36d48c":"This notebook is published as part of a coursera course challenge assignment https:\/\/www.coursera.org\/learn\/advanced-data-science-capstone\/home\/welcome","0f2baa78":"All values are quite low and do not require specific treatment at this point.","c4858e7e":"https:\/\/machinelearningmastery.com\/roc-curves-and-precision-recall-curves-for-classification-in-python\/\n\nhttps:\/\/machinelearningmastery.com\/binary-classification-tutorial-with-the-keras-deep-learning-library\/","2db21195":"# Data Visualization","10a5d30a":"# Model Building","222fc5af":"or the most negatively correlated values.","04c65e5e":"The competition test data set in `test.csv` is loaded into `df_comp`. This data will be held aside until after the EDA and then be used for a submission file.\n\nThen we can split the training data, in `train.csv`, into actual training and validation data.","9e9ce89a":"<h1 id=\"tocheading\">Table of Contents<\/h1>\n<div id=\"toc\"><\/div>","9f37483d":"Here we can make distribution plots for a number of variables in a single figure. I find batches of 25 to be manageable to look at once. \n\nThe following code will show 25 variables from the dataset at time, beginning from `var_N` where `N` is the `offset` value defined in the next variable assignment. ","6c0f4c7d":"# Data Quality Assessment","7f4d8a0d":"Here we can choose a column to inspect more closely in the next two cells. This should be a column name from the summary dataframe (as opposed to the feature column names).","bdef404c":"Using `pandas_summary` we can get an easy idea of our dataset's null-count along with other standard descriptive statisics. The `summarize` function collects this info along with the pandas dtypes and possibly some samples if intersted. `compare_dataframes` uses summarize on both and merges the summaries into a single dataframe. It also shows the difference in value for each statistic and feature in a third column.   ","abd25635":"# Feature Engineering","9c3461d5":"To look at the top N most correlated values","db3ba0a6":"Using `display_all` we can investigate the full dataframe. It can be seen already from here that there are not any missing values in any column. Also the difference in the given datasets `train.csv` and `test.csv` do not seem to be anything remarkable.   ","59d5c923":"# Imports and Dependencies","d0897f18":"# Data Exploration","b2067c71":"## Deep Learning Model","5bfe38df":"# References","93e69320":"This notebook is part of a final challenge assignment for the following course.","5c038206":"#### Fit and score the scaled values","40a910b4":"Run the following cell to generate the Table of Contents","11442e05":"# Load Data","20a5ca6f":"### Random Forest","7b6e011f":"https:\/\/www.coursera.org\/learn\/advanced-data-science-capstone\/home\/welcome","cf09b055":"To check more in depth than the general descriptive statistics above here we can consider column correlation using Spearman's rank correlation.\n\nWe can build a correlation matrix here and check the max values for each feature.","050d0602":"The next transforms the matrix to remove duplicate info in the bottom left half of the matrix and also ends with a singele series for the correlataion value and a multiindex for the two features it arises from.   ","46d2e70f":"#### Scale Features","436d3047":"The score function used in the competiton is the Area Under the Reciever Operator Characteristic Curve.\n\nAfter training each model to compare, we can save the roc plot data in the folowing `roc_data` variable in order to plot all results together at the end.","343fdb92":"Here we create some shorthand convenience variables for later use in model exploration and comparision.","ad13e449":"While working through completing this notebook I found the folling pages very useful.","f4e0bf48":"There is lots to be done to improve these models and explore other algorithms, but we can see here  that `dnn_sc`, the simple DNN with feature scaling, seems to have the best curve out of these models, but it ties to the Random Forest overall (under current conditions) with a score of `0.81`. ","c13ce8dc":"#### Fit the model with the scaled data","f6715f3d":"Now we can plot the four curves altogether and see which has the best score.","202df6b7":"### Split data into local train and local test sets","05aaf9b9":"We shuffle and split training and test sets and are currently taking only a 10% stratified sample for both train and test sets.\n\nThis train size can be increased after model improvements are made in order to improve overall score.","2d9c9c85":"# Model Performance"}}