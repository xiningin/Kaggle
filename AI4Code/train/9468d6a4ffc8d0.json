{"cell_type":{"27351432":"code","80af52c3":"code","fe28b0ff":"code","1045c018":"code","370b5efe":"code","35d68626":"code","5de908ed":"code","a6f10e9f":"code","e0b3f58d":"code","5eccc96d":"code","50146cd8":"code","38283c93":"code","cf27911e":"code","bf45544e":"code","269ba0ee":"code","a771fd81":"code","06c3b037":"code","6ed3d9f6":"code","5e19235b":"code","9e4b571d":"code","c5e57f69":"code","05b02488":"code","e76890c9":"code","aace3238":"code","13e648e2":"code","4c25d75f":"code","7d899ae7":"code","36dc698b":"code","26e4b409":"code","2fcec0f3":"code","7c9076b7":"markdown","69eb5c2c":"markdown","95d0158b":"markdown","a623b835":"markdown","7c02aae4":"markdown","70451311":"markdown","8b72ace5":"markdown","fda90a32":"markdown","b4057d88":"markdown","d4df278d":"markdown","27f03aa1":"markdown","21d501e1":"markdown","137f0234":"markdown","df5b7101":"markdown","d7a06781":"markdown","6a5a3369":"markdown","500d5652":"markdown","26922595":"markdown"},"source":{"27351432":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scipy.stats as stats\n%matplotlib inline\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","80af52c3":"# Reading the data \ngoog_filepath = '..\/input\/google-playstore-apps\/Google-Playstore-32K.csv'\ngoog_data = pd.read_csv(goog_filepath)","fe28b0ff":"# Initial look at the data\ngoog_data","1045c018":"# Size of the data\ngoog_data.shape","370b5efe":"# Columns\ngoog_data.columns","35d68626":"# Types of each feature\ngoog_data.dtypes","5de908ed":"#check for duplicates\nprint('The number of duplicated apps are {:n}'.format(goog_data.duplicated(keep='first').sum()))","a6f10e9f":"# what is the duplicate\ndup_app = goog_data[goog_data.duplicated(keep='first')]['App Name']\nprint('The duplicate app is {}'.format(dup_app.iloc[0]))","e0b3f58d":"# remove duplicate from data\ng_data = goog_data.drop_duplicates(keep='first').reset_index().drop('index',axis=1)","5eccc96d":"#check\ng_data.duplicated().sum()","50146cd8":"# Categories\ng_data['Category'].value_counts()","38283c93":"# Find the 3 odd data points\nodd_cat = [' Channel 2 News', ')',' Podcasts']\ntest = g_data['Category'].isin(odd_cat)\nodd_cat_ind = []\nfor i in range(len(test)):\n    if test[i] == True : \n        odd_cat_ind.append(i)\ng_data.iloc[odd_cat_ind]","cf27911e":"# correcting the false 3 data points\ng_data.iloc[odd_cat_ind[0],1:7] = list(g_data.iloc[odd_cat_ind[0],4:10])\ng_data.iloc[odd_cat_ind[0],7:] = np.nan\ng_data.iloc[odd_cat_ind[1],1:9] = list(g_data.iloc[odd_cat_ind[1],2:10])\ng_data.iloc[odd_cat_ind[1],9:] = np.nan\ng_data.iloc[odd_cat_ind[2],1:9] = list(g_data.iloc[odd_cat_ind[2],2:10])\ng_data.iloc[odd_cat_ind[2],9:] = np.nan\ng_data.iloc[odd_cat_ind]","bf45544e":"# Price data type\ng_data['Price'].value_counts(normalize=True)","269ba0ee":"# Append a new feature (Free\/Paid) to the dataset\nif g_data['Price'].dtype == 'object' : \n    g_data['Price'] = g_data['Price'].apply(lambda x : x.strip('$')).astype(float)\nfree_paid = ['Free' if i == 0 else 'Paid' for i in g_data['Price']]\nfree_paid_ser = pd.Series(free_paid,name = 'Free\/Paid')\ng_data['Free\/Paid'] = free_paid_ser\ng_data","a771fd81":"# Dropping 'Last Updated', 'Minimum Version', and 'Latest Version'\ng_data = g_data.drop(['Last Updated','Minimum Version','Latest Version'],axis=1)","06c3b037":"# Changing the 'Rating' and 'Reviews' data types\ng_data['Rating'] = g_data['Rating'].astype(float)\ng_data['Reviews'] = g_data['Reviews'].astype(int)","6ed3d9f6":"# Plot of the ratings\nplt.figure(figsize=(8,8))\nplt.title('Ratings distribution')\nsns.distplot(g_data['Rating'],kde=True,color='orange',fit=stats.norm)\nplt.legend(['Normal Distribution','Ratings',])","5e19235b":"# Normality check for ratings distribution\nratings = g_data['Rating']\nnorm_rating = (ratings-ratings.mean())\/ratings.std() # Normalize the ratings first\nprint('The p-value for Kolmogorov-Smirnov Test is {}'.format(stats.kstest(norm_rating,'norm',N = len(norm_rating)).pvalue))","9e4b571d":"# Check if data fits lognormal distribution\nsns.distplot(np.log(ratings),fit=stats.norm,kde=False)","c5e57f69":"# dropping data with < 1000 reviews in an attempt if it has an effect on normality of ratings\nmore_1000_reviews_ind = [i for i,x in enumerate(g_data['Reviews'] >= 1000) if x]\ndata = g_data.loc[more_1000_reviews_ind].reset_index().drop('index',axis=1)\nplt.title('Ratings Distribution (> 1000 Reviews)')\nsns.distplot(data['Rating'],fit=stats.norm,color='orange')","05b02488":"# Categories\ndata['Category'].value_counts()","e76890c9":"# Change all game categories into 'GAME'\ngame_ind = [i for i,x in enumerate(data['Category'].str.contains('GAME')) if x]\ndata_2 = data.copy()\ndata_2.loc[game_ind,'Category'] = 'GAME'","aace3238":"# Boxplot of the ratings for each category\nplt.figure(figsize=(13,8)); \nplt.title('Boxplot of the Ratings of each Category');\nsns.boxplot(x=data_2['Category'],y=data['Rating'],showmeans=True)\nplt.xticks(rotation=90);","13e648e2":"# Group the dataset by Category and sort the values by their average rating\ngroup_cat = data_2.groupby('Category')\nsorted_rating_by_cat = group_cat['Rating'].mean().sort_values(ascending=False)\nsorted_rating_by_cat","4c25d75f":"# Taking the top 5 categories and the bottom 5 categories\ntop_5_cat = sorted_rating_by_cat.index[0:5]\nbot_5_cat = sorted_rating_by_cat.index[-5:]\nprint('The top 5 rated categories are {},{},{},{},and {}'.format(*list(top_5_cat)))\nprint('The bottom 5 rated categories are {},{},{},{}, and {}'.format(*list(bot_5_cat)))","7d899ae7":"# Making a dataset consisting of only apps from the top 5 and bottom 5 categories\ntop_5_cat_ind = [i for i,x in enumerate(data_2['Category'].isin(top_5_cat)) if x]\nbot_5_cat_ind = [i for i,x in enumerate(data_2['Category'].isin(bot_5_cat)) if x]\ntop_5_cat_data = data_2.iloc[top_5_cat_ind].reset_index().drop('index',axis=1)\nbot_5_cat_data = data_2.iloc[bot_5_cat_ind].reset_index().drop('index',axis=1)\ntop_bot_cat_data = pd.concat([top_5_cat_data,bot_5_cat_data],axis=0)\ntop_bot_cat_data","36dc698b":"# Boxplot of these categories' ratings\nplt.figure(figsize=(13,8))\nplt.title('Boxplots of Top 5 and Bottom 5 Categories\\' Ratings')\nsns.boxplot(x='Category',y='Rating',data=top_bot_cat_data,showmeans=True)\nplt.xticks(rotation=90);","26e4b409":"# Group the data according to Free\/Paid Apps\ngroup_price = data_2.groupby('Free\/Paid')\nprint('The average rating for the Free apps are {}.'.format(group_price['Rating'].mean().loc['Free']))\nprint('The average rating for the Paid For apps are {}'.format(group_price['Rating'].mean().loc['Paid']))","2fcec0f3":"# Boxplot of free vs paid apps\nplt.figure(figsize=(8,5))\nplt.title('Boxplot of Ratings of Free and Paid for Apps')\nsns.boxplot(x='Free\/Paid',y='Rating',data=data_2,showmeans=True)","7c9076b7":"It doesn't seem as if our data follows a lognormal distribution, this will limit us as we cannot use any parametric methods to do any statistical inference on our data. Although, we could still look at some trends in the data.","69eb5c2c":"It can be seen from the boxplots, that from almost all the categories, the rating distribution are left-skewed. There are a lot of outliers from each category, consisting of a lot of apps rated much lower than the median rating, resulting in a left-skewed distribution.\n\nSeeing from the boxplots, it seems that some categories rate higher than others (on average). Although we can't say it with some level of certainty (because the rating distribution is not normal), we can look at some tendencies from the categories.","95d0158b":"It seems that the **Paid For apps have a higher average rating than the Free apps**.\n\nThis could be attributed to the larger amount of people who rated the Free apps as oppose to the Paid ones. The larger amount of people might account for the bigger spread of the rating, as more people could have rated the apps with a low rating","a623b835":"Okay, there are no longer any duplicate apps in the dataset. Now let's check the categories of apps in the dataset","7c02aae4":"There are a lot of **game categories** that are divided into several subgroups. To simplify, we'll group all the game categories into one **GAME** category","70451311":"It looks like there are **3 categories** which seems odd :  **Channel 2 News, ) , and Podcasts**.\n\nLet's analyze the 3 data points corresponding to the 3 odd categories","8b72ace5":"**First look at the features**\n\nLet's focus on the features **Rating, Category, Reviews, Installs, and Price** to see :\n1. Which categories are rated best?\n2. Do the categories affect the ratings?\n3. Do price affect the ratings, reviews, or number of installs of the app?","fda90a32":"Now let's take a look at the *price* feature","b4057d88":"**Data Cleaning**\n\nBefore doing any EDA, it's good to check for any errors in the data, whether it be NaN entries or unexpected entries.","d4df278d":"Now let's take a look at the different ratings the apps get depending on the price of the app (Are priced apps rated differently from free apps?)","27f03aa1":"It seems that the inputs are shifted by a number of columns\n\nFor the first app (index : 6941), the *Installs* column should be in the *Category* column, the *Size* column should've been in the *Rating* column and so forth. \n\nFor the second and third app, the *Rating* column should be in the *Category* column, the *Reviews* column should be in the *Rating*, so on and so forth.\n\nSo, let's correct that, and make the remaining columns NaN","21d501e1":"Even though it looks as if there are some differences between the ratings of these top 5 and bottom 5 categories' ratings, they don't seem to differ by much.","137f0234":"Seeing as the number of apps that are free (price of USD 0) takes up 93.59% of the apps in the dataset, a reasonable way of looking at the effect of price might be to divide the apps into 2 groups, **Free** and **Paid**","df5b7101":"**Conclusion** : Ratings are not normally distributed, this may be attributed to the negative skew and high kurtosis\n\nIt could also be seen from the data that there are significant amounts of low rating, dragging the mean towards a lower value than the median","d7a06781":"Now let's take a look at the **different categories and their ratings**","6a5a3369":"That looks much better compared to the distribution before, though it still doesn't approximately follow the normal distribution.\n\nWe will be focusing on this dataset as it filters out apps with low number of reviews (We assume that the number of reviews are the number of people who gave ratings for the apps).","500d5652":"Let's take a look at the **Ratings** distribution","26922595":"As we are not going to focus on the features **Last Updated, Minimum Version, and Latest Version**, we'll drop that from our dataset"}}