{"cell_type":{"a7f52d99":"code","55538ded":"code","3fa7b854":"code","4cfb897e":"code","15f2a217":"code","b518fa82":"code","86680a95":"code","5de0cde7":"code","ba300de9":"code","78d33c2e":"code","8e304d00":"code","da758457":"code","c3e81f61":"markdown","cf8280f2":"markdown","fc9d89ac":"markdown","f67bf4b0":"markdown","e78ccc66":"markdown","2f496040":"markdown","beac092d":"markdown","030d61dc":"markdown","0ddb8243":"markdown","aca7d1a9":"markdown","df85e031":"markdown","50701956":"markdown","fbb0cdec":"markdown","71c5bfe2":"markdown","4ddad5d2":"markdown","30871575":"markdown"},"source":{"a7f52d99":"import os\nimport numpy as np\nimport pandas as pd \nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nimport scipy.misc\nimport skimage.segmentation\nimport skimage.feature\n\nfrom tqdm import tqdm\nimport imageio\n\nfrom copy import copy","55538ded":"def image_segmentation(img, scale = 1.0, sigma = 0.8, min_size = 50):\n        \n        img_normalize = skimage.util.img_as_float(img) # Convert an image to floating point format, with values in [0, 1].\n        im_mask = skimage.segmentation.felzenszwalb(\n                        img_normalize, \n                        scale = scale, \n                        sigma = sigma,\n                        min_size = min_size)\n        img_seg = np.dstack([img,im_mask])\n        \n        return(img_seg) #output: shape = (height, width, 4) 4-L label of region","3fa7b854":"img_dir = os.listdir('..\/input\/pascal-voc-2012\/VOC2012\/JPEGImages\/')\nNumber_of_plots = 3\n\nfor imgnumer in (img_dir[2:Number_of_plots]):\n\n    img = imageio.imread(os.path.join('..\/input\/pascal-voc-2012\/VOC2012\/JPEGImages\/',imgnumer)) #read image\n    img_seg = image_segmentation(img = img, min_size = 1000) #get segmentation\n    \n    #Show plot\n    figure = plt.figure(figsize=(20,40))\n    ax = figure.add_subplot(1,2,1)\n    ax.imshow(img)\n    ax.set_title(\"original\")\n    ax = figure.add_subplot(1,2,2)\n    ax.imshow(img_seg[:,:,3])\n    ax.set_title(\"Felzenszwalb\u2019s efficient graph based segmentation\".format(len(np.unique(img_seg[:,:,3]))))\n    plt.show()","4cfb897e":"def get_regions_dictionaray(img):\n    \n    #input img : (height, width, 4) 4 - number of chanels [R,G,B,L] L - label\n    #only L channel use in this method\n    \n    #output is dictionaray Regions\n    #{0: {'labels': [0], 'max_x': 131, 'max_y': 74, 'min_x': 0,   'min_y': 0},\n    # 1: {'labels': [1], 'max_x': 189, 'max_y': 37, 'min_x': 75,  'min_y': 0}\n    \n    \n    # get segmentation output\n    img_seg = img[:,:,3]\n    Regions = {}\n    for y, i in enumerate(img_seg): # get y axis \n\n        for x, l in enumerate(i): # get x axis\n            # add new region\n            if l not in Regions:\n                Regions[l] = {\"min_x\": np.Inf, \n                        \"min_y\": np.Inf,\n                        \"max_x\": 0, \n                        \"max_y\": 0, \n                        \"labels\": [l]}\n\n            # bounding box\n            if Regions[l][\"min_x\"] > x:\n                Regions[l][\"min_x\"] = x\n            if Regions[l][\"min_y\"] > y:\n                Regions[l][\"min_y\"] = y\n            if Regions[l][\"max_x\"] < x:\n                Regions[l][\"max_x\"] = x\n            if Regions[l][\"max_y\"] < y:\n                Regions[l][\"max_y\"] = y\n    ## drop region if x<0 or y<0\n    \n    Region_copy = copy(Regions)\n    for key in Regions.keys():\n        r = Regions[key]\n        if (r[\"min_x\"] == r[\"max_x\"]) or (r[\"min_y\"] == r[\"max_y\"]):\n            del Region_copy[key]\n    return(Region_copy)\n\nRegions = get_regions_dictionaray(img_seg)\nprint(f\"Regions was found: {len(Regions)}\")","15f2a217":"def plt_rectangle(plt,label,x1,y1,x2,y2,color = \"yellow\", alpha=0.5):\n    linewidth = 3\n    if type(label) == list:\n        linewidth = len(label)*3 + 2\n        label = \"\"\n        \n    plt.text(x1,y1,label,fontsize=20,backgroundcolor=color,alpha=alpha)\n    plt.plot([x1,x1],[y1,y2], linewidth=linewidth,color=color, alpha=alpha)\n    plt.plot([x2,x2],[y1,y2], linewidth=linewidth,color=color, alpha=alpha)\n    plt.plot([x1,x2],[y1,y1], linewidth=linewidth,color=color, alpha=alpha)\n    plt.plot([x1,x2],[y2,y2], linewidth=linewidth,color=color, alpha=alpha)\n\n#Show original image\nfigure = plt.figure(figsize=(20,40))\nax = figure.add_subplot(1,2,1)\nax.imshow(img_seg[:,:,:3]\/2**8)\nax.set_title(\"original\")\n\n#Original image add lables\nfor item, color in zip(Regions.values(),sns.xkcd_rgb.values()):#use seaborn color palette\n    x1 = item[\"min_x\"]\n    y1 = item[\"min_y\"]\n    x2 = item[\"max_x\"]\n    y2 = item[\"max_y\"]\n    label = item[\"labels\"][0]\n    plt_rectangle(plt,label,x1,y1,x2,y2,color=color)\n\n#Show segmented image\nax = figure.add_subplot(1,2,2)\nax.imshow(img_seg[:,:,3])\nax.set_title(\"Felzenszwalb\u2019s efficient graph based segmentation\".format(len(np.unique(img_seg[:,:,3]))))\n\n#Segmentation image add labels\nfor item, color in zip(Regions.values(),sns.xkcd_rgb.values()):#use seaborn color palette\n    x1 = item[\"min_x\"]\n    y1 = item[\"min_y\"]\n    x2 = item[\"max_x\"]\n    y2 = item[\"max_y\"]\n    label = item[\"labels\"][0]\n    plt_rectangle(plt,label,x1,y1,x2,y2,color=color)\nplt.show()","b518fa82":"def get_texture_gradient(img):\n    \"\"\"\n        calculate texture gradient for entire image\n\n        output will be [height(*)][width(*)]\n    \"\"\"\n    ret = np.zeros(img.shape[:3])\n    for colour_channel in (0, 1, 2):\n        ret[:, :, colour_channel] = skimage.feature.local_binary_pattern(\n            img[:, :, colour_channel], 50, 1.0)#8\n\n    return ret\n\ndef plot_image_with_min_max(img,nm):\n    img = img[:,:,:3]\n    plt.figure(figsize=(10,10))\n    plt.imshow(img)\n    plt.title(\"{} min={:5.3f}, max={:5.3f}\".format(nm,\n                                                   np.min(img),\n                                                   np.max(img)))\n    plt.show()\n\ntex_grad = get_texture_gradient(img)   \nplot_image_with_min_max(tex_grad,nm=\"tex_grad\")","86680a95":"def calc_hsv(img):\n    hsv = skimage.color.rgb2hsv(img[:,:,:3])\n    return(hsv)\nhsv = calc_hsv(img)\nplot_image_with_min_max(hsv,nm=\"hsv\")","5de0cde7":"def get_hist(img, minhist=0, maxhist=1):\n   \n    BINS = 25\n    hist = np.array([])\n\n    for colour_channel in range(3): # For rgb\n\n        # get one color channel \n        c = img[:, colour_channel]\n\n        # calculate histogram for each colour and join to the result\n        hist = np.concatenate(\n            [hist] + [np.histogram(c, BINS, \n                                   # The lower and upper range of the bins. \n                                   (minhist, maxhist))[0]])\n\n    # L1 normalize\n    hist = hist \/ len(img)\n    return hist\n\ndef get_regions_with_histogram_info(tex_grad, img_seg, Regions,hsv,tex_trad):#img\n    \n    for k, v in list(Regions.items()):\n\n        masked_pixels  = hsv[img_seg[:, :, 3] == k] \n        Regions[k][\"size\"]   = len(masked_pixels \/ 4)\n        Regions[k][\"hist_c\"] = get_hist(masked_pixels,minhist=0, maxhist=1)\n\n        # texture histogram\n        Regions[k][\"hist_t\"] = get_hist(tex_grad[img_seg[:, :, 3] == k],minhist=0, maxhist=2**8-1)\n    return(Regions)\n\nRegions = get_regions_with_histogram_info(tex_grad, img_seg,Regions,hsv,tex_grad)","ba300de9":"def extract_neighbours(regions):\n\n    def intersectiom_of_regions(a, b):#check if two regions intersect\n        if (a[\"min_x\"] < b[\"min_x\"] < a[\"max_x\"] and a[\"min_y\"] < b[\"min_y\"] < a[\"max_y\"]) or\\\n           (a[\"min_x\"] < b[\"max_x\"] < a[\"max_x\"] and a[\"min_y\"] < b[\"max_y\"] < a[\"max_y\"]) or\\\n           (a[\"min_x\"] < b[\"min_x\"] < a[\"max_x\"] and a[\"min_y\"] < b[\"max_y\"] < a[\"max_y\"]) or\\\n           (a[\"min_x\"] < b[\"max_x\"] < a[\"max_x\"] and a[\"min_y\"] < b[\"min_y\"] < a[\"max_y\"]):\n            return True\n        return False\n\n    Regions = list(regions.items())\n    neighbours = []\n    for cur, a in enumerate(Regions[:-1]):\n        for b in Regions[cur + 1:]:\n            if intersectiom_of_regions(a[1], b[1]):\n                neighbours.append((a, b))\n\n    return neighbours\n\nneighbours = extract_neighbours(Regions)\nprint(f\"Out of {len(Regions)} regions, was found {len(neighbours)} neighbours\")","78d33c2e":"#calculate the sum of histogram intersection of colour\ndef simularity_of_colour(r1, r2): \n    return sum([min(a, b) for a, b in zip(r1[\"hist_c\"], r2[\"hist_c\"])])\n\n#calculate the sum of histogram intersection of texture\ndef simularity_of_texture(r1, r2):\n    return sum([min(a, b) for a, b in zip(r1[\"hist_t\"], r2[\"hist_t\"])])\n\n#calculate the size similarity over the image\ndef simularity_of_size(r1, r2, imsize):\n    return 1.0 - (r1[\"size\"] + r2[\"size\"]) \/ imsize\n\n#calculate the fill similarity over the image\ndef simularity_of_fill(r1, r2, imsize):\n    bbsize = (\n        (max(r1[\"max_x\"], r2[\"max_x\"]) - min(r1[\"min_x\"], r2[\"min_x\"]))\n        * (max(r1[\"max_y\"], r2[\"max_y\"]) - min(r1[\"min_y\"], r2[\"min_y\"]))\n    )\n    return 1.0 - (bbsize - r1[\"size\"] - r2[\"size\"]) \/ imsize\n\n#return sum of simularity of two regions\ndef calculate_sum_sim(r1, r2, imsize):\n    return (simularity_of_colour(r1, r2)       +\\\n            simularity_of_texture(r1, r2)      +\\\n            simularity_of_size(r1, r2, imsize) +\\\n            simularity_of_fill(r1, r2, imsize))\n\n#calculate simularity of all regions\ndef calculate_similarlity(img,neighbours,verbose=False):\n    imsize = img.shape[0] * img.shape[1]\n    Simularity = {}\n    for (ai, ar), (bi, br) in neighbours:\n        Simularity[(ai, bi)] = calculate_sum_sim(ar, br, imsize)\n        if verbose:\n            print(\"S[({:2.0f}, {:2.0f})]={:3.2f}\".format(ai,bi,Simularity[(ai, bi)]))\n    return(Simularity)\n\nprint(\"S[(Pair of the intersecting regions)] = Similarity index\")\nSimularity = calculate_similarlity(img,neighbours,verbose=True)","8e304d00":"#Merge two regions base on compare of x1 and x2\ndef merge_regions(r1, r2):\n    \n    new_size = r1[\"size\"] + r2[\"size\"]\n    rt = {\n        \"min_x\": min(r1[\"min_x\"], r2[\"min_x\"]),\n        \"min_y\": min(r1[\"min_y\"], r2[\"min_y\"]),\n        \"max_x\": max(r1[\"max_x\"], r2[\"max_x\"]),\n        \"max_y\": max(r1[\"max_y\"], r2[\"max_y\"]),\n        \"size\": new_size,\n        \"hist_c\": (r1[\"hist_c\"] * r1[\"size\"] + r2[\"hist_c\"] * r2[\"size\"]) \/ new_size,\n        \"hist_t\": (r1[\"hist_t\"] * r1[\"size\"] + r2[\"hist_t\"] * r2[\"size\"]) \/ new_size,\n        \"labels\": r1[\"labels\"] + r2[\"labels\"]\n    }\n    return rt\n\ndef merge_regions_in_order(Simularity,Regions,imsize, verbose=False):\n \n    # hierarchal search\n    while Simularity != {}:\n        \n        #Sort dictionary by simularity \n        i, j = sorted(Simularity.items(), key=lambda i: i[1])[-1][0] \n\n        #Marge the regions and add to the region dictionary\n        t = max(Regions.keys()) + 1.0\n        Regions[t] = merge_regions(Regions[i], Regions[j])\n\n       \n        #remove all the pair of regions where one of the regions was selected in sort \n        key_to_delete = []\n        for k, v in list(Simularity.items()):\n            if (i in k) or (j in k):\n                key_to_delete.append(k)\n        for k in key_to_delete:\n            del Simularity[k]\n\n        #calculate similarity of new merged region and the regions and its intersecting region (intersecting region is the region that are to be deleted)\n        for k in key_to_delete:\n            if k != (i,j):\n                if k[0] in (i, j):\n                    n = k[1]\n                else:\n                    n = k[0]\n                Simularity[(t, n)] = calculate_sum_sim(Regions[t], Regions[n], imsize)\n    if verbose:\n        print(\"{} regions\".format(len(Regions)))\n\n    # return list of regions\n    regions = []\n    for k, r in list(Regions.items()):\n            regions.append({\n                'rect': (\n                    r['min_x'],              # min x\n                    r['min_y'],              # min y\n                    r['max_x'] - r['min_x'], # width \n                    r['max_y'] - r['min_y']),# height\n                'size': r['size'],\n                'labels': r['labels']\n            })\n    return(regions)\n\n\n\nregions = merge_regions_in_order(Simularity,Regions,img.shape[0]*img.shape[1],verbose=True)","da758457":"plt.figure(figsize=(20,20))    \nplt.imshow(img_seg[:,:,:3]\/2**8)\nfor item, color in zip(regions,sns.xkcd_rgb.values()):\n    x1, y1, width, height = item[\"rect\"]\n    label = item[\"labels\"][:5]\n    plt_rectangle(plt,label,x1,y1,x2 = x1 + width,y2 = y1 + height, color = color)\nplt.show()\n\nplt.figure(figsize=(20,20))    \nplt.imshow(img_seg[:,:,3])\nfor item, color in zip(regions,sns.xkcd_rgb.values()):\n    x1, y1, width, height = item[\"rect\"]\n    label = item[\"labels\"][:5]\n    plt_rectangle(plt,label,\n                  x1,\n                  y1,\n                  x2 = x1 + width,\n                  y2 = y1 + height, color= color)\nplt.show()","c3e81f61":"## Step 1: Efficient graph based segmentation","cf8280f2":"The HSV representation models the way paints of different colors mix together, with the saturation dimension resembling various tints of brightly colored paint, and the value dimension resembling the mixture of those paints with varying amounts of black or white paint.","fc9d89ac":"### **Reference:**\n1. Rich feature hierarchies for accurate object detection and semantic segmentation: https:\/\/arxiv.org\/pdf\/1311.2524.pdf\n2. Selective Search for Object Recognition: http:\/\/www.huppelen.nl\/publications\/selectiveSearchDraft.pdf","f67bf4b0":"As we can see after segmentation we have a lot of useless lables or labels which belong to one object. In next step I will group labels that belong to one object.","e78ccc66":"Result of Felzenszwalb efficient graph based segmentation:","2f496040":"Final result plot:","beac092d":"Next I will be merge regions and then delete already merged regions and calculate new similarity.","030d61dc":"Below we can find Felzenszwalb efficient graph based segmentation function that implement via skimage library","0ddb8243":"# **Efficient graph based segmentation algorithm step by step**","aca7d1a9":"\n### **Steps of selective search:**\n1. Create initial regions by Felzenszwalb\u2019s efficient graph based segmentation algorithm\n2. Group regions based on various criteria (Local Binary Pattern features and HSV)","df85e031":"Below I calculate histogram for each region. The output histogram will be BINS * COLOUR_CHANNELS(3).Number of bins is 25 as uijlings_ijcv2013_draft.pdf. And hen calculate histogram for each region","50701956":"Get list of regions that intersect each other ","fbb0cdec":"Visualization of labels output after Felzenszwalb segmentation","71c5bfe2":"# Step 2: group regions\nIn this step I will group the most similar regions. For this grouping I will implement LBP(Local Binary Pattern)","4ddad5d2":"For each pair of neighbours regions, calculate similarities of the two regions and then return sum of similarity of regions.","30871575":"Next step is add labels to segmentet regions of image:"}}