{"cell_type":{"15f5d6ef":"code","300bdcce":"code","d5aa4259":"markdown","6e6655b6":"markdown","aa1ad62a":"markdown","2a24490c":"markdown"},"source":{"15f5d6ef":"INF = 9999\n\nv=5\n\ng = [[0,9,75,0,0],\n     [9,0,95,19,42],\n     [75,95,0,51,66],\n     [0,19,51,0,31],\n     [0,42,66,31,0]]\n\nselected = [0,0,0,0,0]\n\nno_edge = 0\n\nselected[0]= True\n\nprint('Edge : Weight\\n')\n\nwhile (no_edge< v-1):\n    minimum = INF\n    x = 0\n    y = 0\n    for i in range(v):\n        if selected[i]:\n            for j in range(v):\n                if (g[i][j] and not selected[j]):\n                    if minimum > g[i][j]:\n                        \n                        minimum = g[i][j]\n                        x = i\n                        y = j\n    \n    print(str(x), '-', str(y), ':', str(g[x][y]))\n    selected[y] = True\n    no_edge += 1","300bdcce":"class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph= []\n        \n    def add_edge(self, u, v, w):\n        self.graph.append([u, v, w])\n        \n    # Search function\n    \n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n        \n    def apply_union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n            \n            \n     #  Applying Kruskal algorithm\n    def kruskal_algo(self):\n        result = []\n        i, e = 0, 0\n        self.graph = sorted(self.graph, key=lambda item: item[2])\n        parent = []\n        rank = []\n        for node in range(self.V):\n            parent.append(node)\n            rank.append(0)\n        while e < self.V - 1:\n            u, v, w = self.graph[i]\n            i = i + 1\n            x = self.find(parent, u)\n            y = self.find(parent, v)\n            if x != y:\n                e = e + 1\n                result.append([u, v, w])\n                self.apply_union(parent, rank, x, y)\n        for u, v, weight in result:\n            print(\"%d - %d: %d\" % (u, v, weight))\n\n\ng = Graph(6)\ng.add_edge(0, 1, 4)\ng.add_edge(0, 2, 4)\ng.add_edge(1, 2, 2)\ng.add_edge(1, 0, 4)\ng.add_edge(2, 0, 4)\ng.add_edge(2, 1, 2)\ng.add_edge(2, 3, 3)\ng.add_edge(2, 5, 2)\ng.add_edge(2, 4, 4)\ng.add_edge(3, 2, 3)\ng.add_edge(3, 4, 3)\ng.add_edge(4, 2, 4)\ng.add_edge(4, 3, 3)\ng.add_edge(5, 2, 2)\ng.add_edge(5, 4, 3)\ng.kruskal_algo()","d5aa4259":"## These are the 2 algorithms in graph theory","6e6655b6":"## Kruskal's algorithm\n### Kruskal's algorithm finds a minimum spanning forest of an undirected edge-weighted graph. If the graph is connected, it finds a minimum spanning tree. It is a greedy algorithm in graph theory as in each step it adds the next lowest-weight edge that will not form a cycle to the minimum spanning forest.","aa1ad62a":"## Prim's Algorithm\n#### Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized.","2a24490c":"### Prim's Algorithm grows a solution from a random vertex by adding the next cheapest vertex to the existing tree. Kruskal's Algorithm grows a solution from the cheapest edge by adding the next cheapest edge to the existing tree \/ forest. Prim's Algorithm is faster for dense graphs.\n"}}