{"cell_type":{"067a7ac3":"code","ca829403":"code","16508aab":"code","ba03c140":"code","66910562":"code","91ea43f9":"code","1000da41":"code","4987b1a0":"code","7e5693bb":"code","07bfa621":"code","79d5c0e3":"code","b0606a61":"code","7e38beda":"code","ffad9505":"code","5a286697":"code","e82ff20d":"code","96526d41":"code","0d919317":"code","c6221e27":"code","169e1fdb":"code","fdbe534a":"code","87516798":"code","0af5a0db":"code","9aacae01":"code","47b004a2":"code","1ce91233":"code","1965c82f":"code","24c24687":"code","4179fdad":"code","d7c27986":"code","235c6c27":"code","40d8b1f8":"code","8727b09c":"code","72a2c3af":"code","0db9cd2f":"code","b643e644":"markdown","5f333788":"markdown","05b9a560":"markdown","7884b2ea":"markdown","e9be476f":"markdown","9e90c3b7":"markdown","88fe9950":"markdown","1b0bc8f2":"markdown","52243bcd":"markdown","d446f879":"markdown","87a6035d":"markdown","f65796b1":"markdown","a0293033":"markdown","a22e1307":"markdown","89e8dc48":"markdown","b6144ea7":"markdown","97087e04":"markdown","1855b400":"markdown","10740919":"markdown","21d62149":"markdown","ccab80c9":"markdown","1b624460":"markdown","1273252d":"markdown","a7789d1e":"markdown","6836cf56":"markdown","84231882":"markdown","cc6530de":"markdown","9713a8f3":"markdown","e595e1a6":"markdown","4788d849":"markdown","700d6b9a":"markdown","9d874e27":"markdown"},"source":{"067a7ac3":"import ee \nimport numpy as np \nimport webbrowser\nimport os \nimport matplotlib.pyplot as plt \nfrom matplotlib.colors import ListedColormap\nimport folium\nimport pickle\nimport pandas as pd\nfrom PIL import Image\nimport IPython.display as disp\n%matplotlib inline\n","ca829403":"# setup to add ee layer to folium\n\ndef add_ee_layer(self, ee_image_object, vis_params, name,opacity=0.75):\n    '''function to add GEE layer to folium,\n    Source : GEE'''\n    map_id_dict = ee.Image(ee_image_object).getMapId(vis_params)\n    folium.raster_layers.TileLayer(\n          tiles=map_id_dict['tile_fetcher'].url_format,\n          attr='Map Data &copy; <a href=\"https:\/\/earthengine.google.com\/\">Google Earth Engine<\/a>',\n          name=name,\n          opacity=opacity,\n          overlay=True,\n          control=True\n      ).add_to(self)\n\nfolium.Map.add_ee_layer = add_ee_layer\n\n\ndef get_best_image(image_collection,\n                   year,\n                   area_of_interest,\n                   month=10):\n    '''filter the best image( with the least cloud cover value) for the given year and given month'''\n\n    start_date = ee.Date.fromYMD(**{\n        'day':1 ,\n        'month': month,\n        'year' : year})\n    end_date = ee.Date.fromYMD(**{\n        'day':30 ,\n        'month': month,\n        'year' : year})\n    \n    print(image_collection.filterDate(start_date,end_date).size().getInfo())\n    \n    if not area_of_interest:\n        # sort image by asc order of cloud pixel values\n        img = image_collection.filterDate(start_date,end_date).sort('CLOUD_COVER').first()\n    else:\n        img = image_collection.filterDate(start_date,end_date).sort('CLOUD_COVER').first().clip(area_of_interest)\n        \n    \n    return img \n\n\n#from https:\/\/climada-python.readthedocs.io\/en\/stable\/tutorial\/climada_util_earth_engine.html\ndef get_url(name, image, scale, region):\n    \"\"\"It will open and download automatically a zip folder containing Geotiff data of 'image'.\n    If additional parameters are needed, see also:\n    https:\/\/github.com\/google\/earthengine-api\/blob\/master\/python\/ee\/image.py\n\n    Parameters:\n        name (str): name of the created folder\n        image (ee.image.Image): image to export\n        scale (int): resolution of export in meters (e.g: 30 for Landsat)\n        region (list): region of interest\n\n    Returns:\n        path (str)\n     \"\"\"\n    path = image.getDownloadURL({\n        'name':(name),\n        'scale': scale,\n        'region':(region)\n        })\n\n    webbrowser.open_new_tab(path)\n    return path","16508aab":"# Authenticate (generate a authentication token and authenticate)\nee.Authenticate()","ba03c140":"#Initialize\nee.Initialize()","66910562":"# Area of Interest \n\nwith open('..\/input\/pune-coordinates\/bounding_polygons.pkl','rb') as f:\n    pune_cr = pickle.load(f)\n\n    \n#converting into polygon object with a buffer of 30 kms around it \naoi = ee.geometry.Geometry.Polygon(list(pune_cr['pune_urban'].values())).buffer(30000)\n\n# mean latitude and longitude\nmean_cr=list(pd.DataFrame(pune_cr['pune_urban'].values()).mean())","91ea43f9":"#the dataset with boundaries info\nbounds= ee.FeatureCollection(\"FAO\/GAUL_SIMPLIFIED_500m\/2015\/level2\")\n\n#get geometry for Pune\npune_dist = bounds.filter(ee.Filter.eq('ADM2_NAME', 'Pune')).geometry()\n\npune_dist_area=ee.Number(pune_dist.area()).divide(1e+6).round().getInfo() \n\nprint(f'Total Administrative boundary area of Pune is {pune_dist_area} Sq-Km')","1000da41":"# Landsat 7 image collection surface reflectance  (1999- 2021) Level -2 - tier 1\nL7=ee.ImageCollection(\"LANDSAT\/LE07\/C01\/T1_SR\").filterBounds(aoi)\n\n# first image of the collection \nimage = L7.filter(ee.Filter.calendarRange(1999,2003,'year')).sort('CLOUDY_PIXEL_PERCENTAGE').first().clip(aoi)\n\n\n\nprint('Number of Images in the collection is ',L7.size().getInfo())\n# checking the date when image was ingested \nprint('Date of Ingestion for sample Image :'  ,ee.Date(image.get('system:time_start')).format().getInfo())","4987b1a0":"# Define the visualization parameters.\n# B1 is Blue,B2 is Green ,B3 is Red\n\nimage_viz_params = {\n    'bands': ['B3', 'B2', 'B1'],\n    'min': 0,\n    'max': 2000,\n    'gamma': [0.95, 1.1, 1]\n}\n\n\n# Define a map centered on AOI.\nmap_l8 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n\n\n# Add the image layer to the map and display it.\nmap_l8.add_ee_layer(image, image_viz_params, 'color composite')\nmap_l8.add_child(folium.LayerControl())\ndisplay(map_l8)","7e5693bb":"#check the image \n\nprint('Color Composite Raster')\nurl_im = image.select(['B3', 'B2', 'B1']).getThumbUrl(image_viz_params,)\ndisp.Image(url=url_im,width=800)\n","07bfa621":"\n# calculating normalized diffrence\nndvi = image.normalizedDifference(['B4','B3'])\n\n\n#mask regions with NDVI <0.25\nmask_ndvi = ndvi.gte(0.25)\nndvi1 = ndvi.updateMask(mask_ndvi)\n\n# map\nmap_3 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n \n# palette = ListedColormap([\"white\", \"tan\", \"springgreen\", \"darkgreen\"])\nndvi_viz = {'min': 0.17, 'max': 1, 'palette': ['#8c564b','#D6A896','#A2C177','#75A82C','5F9A0B']}\n\n# Add the image layer to the map and display it.\nmap_3.add_ee_layer(ndvi1,ndvi_viz,'NDVI')\nmap_3.add_child(folium.LayerControl())\nprint('Normalized Difference Vegetative Index')\ndisplay(map_3)","79d5c0e3":"#check the image \nprint('Vegetation Index Raster')\nurl_im = ndvi1.getThumbUrl(ndvi_viz)\ndisp.Image(url=url_im,width=800)","b0606a61":"\n# calculating normalized diffrence\nmndwi = image.normalizedDifference(['B3','B5'])\n\n\n#mask \nmask = mndwi.gte(-0.01)\nmndwi = mndwi.updateMask(mask)\n\n# map\nmap_2 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n \nmndwi_viz = {'min': -0.2, 'max': 0.5, 'palette': ['lightblue','blue']}\n\nprint('Normalized Difference Water Index')\n# Add the image layer to the map and display it.\nmap_2.add_ee_layer(mndwi,mndwi_viz,'NWDI')\nmap_2.add_child(folium.LayerControl())\ndisplay(map_2)","7e38beda":"print('Water Index Raster')\nurl_im = mndwi.getThumbUrl(mndwi_viz)\ndisp.Image(url=url_im,width=800)","ffad9505":"\n# calculating normalized diffrence\nndbi = image.normalizedDifference(['B6','B4'])\n\n\n#taking values greater than 0.2 and less than 0.5\nndbi_mask = ndbi.gte(0.25).And(ndbi.lte(0.45))\n\nndbi=ndbi.updateMask(ndbi_mask)\n# map\nmap_3 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n \ncolormap = ['yellow','orange','brown']\nndbi_viz = {'min': 0.2, 'max': 0.5, 'palette': colormap}\n\n\nprint('Normalized Difference BuiltUp Index')\n# Add the image layer to the map and display it.\nmap_3.add_ee_layer(ndbi,ndbi_viz,'NDBI')\nmap_3.add_child(folium.LayerControl())\ndisplay(map_3)","5a286697":"print('Built Up Raster')\nurl_im = ndbi.getThumbUrl(ndbi_viz)\ndisp.Image(url=url_im,width=800)","e82ff20d":"\ndef get_df(img_collection_info,\n           bands):\n    '''get a dataframe of values for the given Bands'''\n    \n    \n    df = pd.DataFrame(img_collection_info)\n\n    # Rearrange the header.\n    headers = df.iloc[0]\n    df = pd.DataFrame(df.values[1:], columns=headers)\n\n    # Remove rows without data inside.\n    df = df[['longitude', 'latitude', 'time', *bands]].dropna()\n\n    # Convert the data to numeric values.\n    for band in bands:\n        df[band] = pd.to_numeric(df[band], errors='coerce')\n\n    # Convert the time field into a datetime.\n    df['datetime'] = pd.to_datetime(df['time'], unit='ms')\n\n    #lat-long of point as location\n    df['location']=df.apply(lambda x : (x['latitude'],x['longitude']),axis=1)\n    \n    \n    # Keep the columns of interest.\n    df = df[['time','datetime','location',  *bands]]\n\n    return df\n\n\ndef get_setl_stats(img,\n                   total_area=pune_dist_area):\n    \n    '''get settlement type stats for an Global HUman Settlements layer'''\n    \n    area = ee.Image.pixelArea()\n    #to calculate sum of Area\n    reducer_dict = {\n                  'reducer': ee.Reducer.sum(),\n                  'geometry': img.geometry(),\n                  'scale': 1000,#scale in meters\n                  'maxPixels': 1e9\n                }\n    \n    \n    #high density\n    high = round(img.updateMask(img.eq(3)).multiply(area).reduceRegion(**reducer_dict).get('smod_code').getInfo() \/ 1e+6,\n                 3)\n    #medium density\n    medium = round(img.updateMask(img.eq(2)).multiply(area).reduceRegion(**reducer_dict).get('smod_code').getInfo() \/ 1e+6,\n                   3)\n\n    #low denisty\n    low = round(img.updateMask(img.eq(1)).multiply(area).reduceRegion(**reducer_dict).get('smod_code').getInfo() \/ 1e+6,\n                3)\n    \n     \n    for typ in ['high','medium','low']:\n        val=eval(typ)\n        print(f'Area is Sq-km of {typ} density settlements is {val}, {round(100*(val\/total_area),3)} % of total area')\n        print('.'*20,'-'*20,'.'*20)\n        \n    return high,medium,low\n\n\ndef save_image(image,title,path='.\/'):\n    try:\n        im = Image.fromarray(image)\n        im.save(os.path.join(path,title,'.jpg'))\n        print(f'{title}.jpg saved ')\n    except Exception as e:\n        print('Error saving Image \\n',e)\n        \n        \ndef show_image(arr,title,save=True):\n    \n    \n#     cmap = ListedColormap(['green','yellow','orange','brown'])\n    ax=plt.figure(figsize=(12,12))\n    \n    plt.imshow(arr)\n    plt.axis('off')\n    plt.colorbar(orientation='horizontal')\n    plt.title(f'{title}')\n    plt.show()\n    \n    if save:\n        plt.imsave(arr=arr,fname=f'{title}.png')\n        ","96526d41":"#get the Human Settlements layer \nhuman_settlements = ee.ImageCollection(\"JRC\/GHSL\/P2016\/SMOD_POP_GLOBE_V1\").filterBounds(pune_dist)\n#list of images\nhs_list = human_settlements.toList(4)\n\n#get each Image of the Human setttlements layer\nhs1 = ee.Image(hs_list.get(0)).clip(pune_dist)   # 1975\nhs2 = ee.Image(hs_list.get(1)).clip(pune_dist)   #1990\nhs3 = ee.Image(hs_list.get(2)).clip(pune_dist)   #2000\nhs4 = ee.Image(hs_list.get(3)).clip(pune_dist)   #2015","0d919317":"# Dataset Human Settlements Layer-band name: smod_codes\n\n#what value of this band means\nsmod_code_dict = {0:'un-inhabited region',\n                  1: 'rural grid cells',\n                  2: 'low density clusters',\n                  3: 'high density clusters'}","c6221e27":"year = 1975\nprint(f'For Year {year}')\nsts1=get_setl_stats(hs1)","169e1fdb":"#get the image as an array\narr1 = np.array(ee.Image(hs_list.get(0)).sampleRectangle(region=pune_dist).get('smod_code').getInfo())\n\n#show image and save\nshow_image(arr1,'Settlements_1975',True)","fdbe534a":"# map\nmap_4 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n \nhs_viz = {'min': 0,\n            'max': 3,\n            'palette': ['green','yellow','orange','brown']}\n\n\nprint('Settlements in 1975')\n# Add the image layer to the map and display it.\nmap_4.add_ee_layer(hs1,hs_viz,'Builtup Area')\nmap_4.add_child(folium.LayerControl())\ndisplay(map_4)","87516798":"year = 1990\nprint(f'For Year {year}')\nsts2=get_setl_stats(hs2)","0af5a0db":"#get the image as an array\narr2 = np.array(ee.Image(hs_list.get(1)).sampleRectangle(region=pune_dist).get('smod_code').getInfo())\n\n#show image and save\nshow_image(arr2,'Settlements_1990',True)","9aacae01":"# map\nmap_5 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n \n\nprint(f'Settlements in {year}')\n# Add the image layer to the map and display it.\nmap_5.add_ee_layer(hs2,hs_viz,'Builtup Area')\nmap_5.add_child(folium.LayerControl())\ndisplay(map_5)","47b004a2":"year = 2000\nprint(f'For Year {year}')\nsts3=get_setl_stats(hs3)","1ce91233":"#get the image as an array\narr3 = np.array(ee.Image(hs_list.get(2)).sampleRectangle(region=pune_dist).get('smod_code').getInfo())\n\n#show image and save\nshow_image(arr3,'Settlements_2000',True)","1965c82f":"# map\nmap_6 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n \nhs_viz = {'min': 0,\n            'max': 3,\n            'palette': ['green','yellow','orange','brown']}\n\n\nprint(f'Settlements in {year}')\n# Add the image layer to the map and display it.\nmap_6.add_ee_layer(hs3,hs_viz,'Builtup Area')\nmap_6.add_child(folium.LayerControl())\ndisplay(map_6)","24c24687":"year = 2015\nprint(f'For Year {year}')\nsts4=get_setl_stats(hs4)","4179fdad":"#get the image as an array\narr4 = np.array(ee.Image(hs_list.get(3)).sampleRectangle(region=pune_dist).get('smod_code').getInfo())\n\n#show image and save\nshow_image(arr4,'Settlements_2015',True)","d7c27986":"# map\nmap_7 = folium.Map(location=[mean_cr[1],mean_cr[0]], zoom_start=10)\n \nhs_viz = {'min': 0,\n            'max': 3,\n            'palette': ['green','yellow','orange','brown']}\n\n\nprint(f'Settlements in {year}')\n# Add the image layer to the map and display it.\nmap_7.add_ee_layer(hs4,hs_viz,'Builtup Area')\nmap_7.add_child(folium.LayerControl())\ndisplay(map_7)","235c6c27":"#get data saved Earlier\nyears = [1975,1990,2000,2015]\nstats = [sts1,sts2,sts3,sts4]\nhigh_den= [i[0] for i in stats]\nmed_den= [i[1] for i in stats]\nlow_den= [i[2] for i in stats]\n\n\n\n#plot\n\nplt.style.use('Solarize_Light2')\nax=plt.figure(figsize=(14,7))\n\nplt.title('Growth in Settlement')\nplt.plot(years,high_den,label='High Density Settlements',color='r')\nplt.plot(years,med_den,label='Medium Density Settlements',color='b')\nplt.plot(years,low_den,label='Low Density Settlements',color='g')\nplt.xlim(left=1975)\nplt.xlabel('Year')\nplt.ylabel('Area in Sq-Km')\nplt.legend()\n\nplt.savefig('growth.png')\nplt.show()","40d8b1f8":"\n#show image and save\nshow_image(arr2-arr1,'growth_1975-1990',True)","8727b09c":"\n#show image and save\nshow_image(arr3-arr2,'growth_1990-2000',True)","72a2c3af":"#show image and save\nshow_image(arr4-arr3,'growth_2000-2015',True)","0db9cd2f":"def ndvi_stats(ndvi):\n    \n    # converting the value of image pixels into area\n    areaImage = ndvi.multiply(ee.Image.pixelArea())\n    \n    # calculate the sum of ndvi values \n    ndvi_sum = areaImage.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: ndvi.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n    \n    #sparse vegetation \n    ndvi_sparse = areaImage.lt(0.4).And(areaImage.gt(0.2))\n    #calculate stats\n    ndvi_sparse = ndvi_sparse.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: ndvi.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n    \n    \n    #med dense\n    ndvi_med_dense=areaImage.lt(0.6).And(areaImage.gt(0.4))\n    #calculate stats\n    ndvi_med_dense = ndvi_med_dense.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: ndvi.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n    \n    \n    # dense vegetation \n    ndvi_dense = areaImage.lt(1).And(areaImage.gt(0.6))\n    #calculate stats\n    ndvi_dense = ndvi_dense.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: ndvi.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n    \n    \n    return ndvi_sum,ndvi_sparse,ndvi_med_dense,ndvi_dense\n\ndef buildup_stats(built_up_0):\n    \n    # converting the value of image pixels into area\n    areaImage = built_up_0.multiply(ee.Image.pixelArea())\n    \n    # calculate the sum of builtup values \n    built_up_sum = built_up.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: built_up_0.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n    \n    #sparse \n    built_up_sparse = built_up.lt(0.4).And(built_up.gt(0.2))\n    \n    # cal stats \n    built_up_sparse=built_up_sparse.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: built_up_0.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n       \n    #med \n    built_up_med_dense=built_up.lt(0.6).And(built_up.gt(0.4))\n    \n    # cal stats \n    built_up_med_dense=built_up_med_dense.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: built_up_0.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n    \n    \n    \n    # dense \n    built_up_dense = built_up.lt(1).And(built_up.gt(0.6))\n    \n    # cal stats \n    built_up_dense=built_up_dense.reduceRegion({\n                  reducer: ee.Reducer.sum(),\n                  geometry: built_up_0.geometry(),\n                  scale: 30,\n                  maxPixels: 1e9\n                })\n    \n    \n    return built_up_sum,built_up_sparse,built_up_med_dense,built_up_dense\ndef get_image_stats(image,parent_df=None,return_img=False):\n    '''get  zonal statistics from given image, and append them to the parent dataframe,otherwise return the image with added ndvi,ndbi and bu bands'''\n    \n    # calc ndvi\n    ndvi = image.normalizedDifference(['B4','B3'])\n    \n    # mask the non ndvi pixels\n    mask_ndvi = ndvi.lt(0.2).And(ndvi.lt(0))\n    \n    # apply mask \n    ndvi = ndvi.updateMask(mask_ndvi).rename('NDVI')\n    \n    \n    \n    # calc ndbi\n    ndbi = image.normalizedDifference(['B5','B4'])\n    \n    # mask the non ndvi pixels\n    mask_ndbi = ndvi.lt(0.2).And(ndvi.lt(0))\n    \n    ndbi = ndbi.updateMask(mask_ndbi).rename('NDBI')\n    \n    # calc buildup \n    built_up = ndbi.subtract(ndvi).rename('BU')\n    \n    \n    \n    if return_img:\n        image.addBands([ndvi,ndbi,built_up])\n        \n        return image\n    \n    \n    \n    return parent_df\n\n# def cloud_mask(image):\n    '''Remove cloudy pixels and remove pixels which donot exit in all the images for Landsat7 \n    Source: https:\/\/developers.google.com\/earth-engine\/datasets\/catalog\/LANDSAT_LE07_C01_T1_SR\n    Input : Image (map onto the gee image collection\n    ex: modified = Image_collection.map(cloud_mask)'''\n#     qa = image.select('pixel_qa')\n    \n    # If the cloud bit (5) is set and the cloud confidence (7) is high\n    # or the cloud shadow bit is set (3), then it's a bad pixel.\n    \n#     cloud = qa.bitwiseAnd(1 << 5).And(qa.bitwiseAnd(1 << 7)).Or(qa.bitwiseAnd(1 << 3))\n#     #     Remove edge pixels that don't occur in all bands\n#     mask2 = image.mask().reduce(ee.Reducer.min());\n    \n#     return image.updateMask(cloud.not()).updateMask(mask2)\n    ","b643e644":"# References and Resources:\n* Paper: Normalized Buildup Urban Area. [ https:\/\/is.muni.cz\/el\/1431\/podzim2012\/Z8114\/um\/35399132\/35460312\/ndbi.pdf ]\n* Paper : Buildup Area and Vegetation Area Extraction [ http:\/\/article.sapub.org\/10.5923.j.ijaf.20130307.04.html ]\n* Paper : Estimating Urban Greeness . [ https:\/\/www.sciencedirect.com\/science\/article\/pii\/S1110982319304211 ]\n* Paper : Improving NDBI .[ https:\/\/www.tandfonline.com\/doi\/pdf\/10.1080\/01431161.2010.481681 ]\n* Paper : Urban Sprawl: Lucknow City [ http:\/\/www.ijhssi.org\/papers\/v4(5)\/Version-2\/B0452011020.pdf ]\n* Paper : [ https:\/\/www.researchgate.net\/publication\/355979192_Assessment_of_Change_in_Urban_Green_Spaces_Using_Sentinel_2_MSI_Data_and_GIS_Techniques_A_Case_Study_in_Thanh_Hoa_City_Vietnam ]\n* Paper : Enhanced Built up index [ https:\/\/www.researchgate.net\/publication\/258710455_Enhanced_Built-Up_and_Bareness_Index_EBBI_for_Mapping_Built-Up_and_Bare_Land_in_an_Urban_Area ]\n* Tutorial GEE: Calculating image statistics [ https:\/\/developers.google.com\/earth-engine\/guides\/reducers_reduce_region ]\n* Blog  : Landcover detection [ https:\/\/spatialthoughts.com\/2020\/06\/19\/calculating-area-gee\/ ]\n* Blog  : Image Analysis and mapping using NDVI [ https:\/\/www.analyticsvidhya.com\/blog\/2021\/05\/image-analysis-and-mapping-in-earth-engine-using-ndvi\/ ]\n* Tutorial GEE: Quantifying Forest change [ https:\/\/developers.google.com\/earth-engine\/tutorials\/tutorial_forest_03 ]\n* Tutorial Landuse Clustering: [ https:\/\/examples.pyviz.org\/landsat_clustering\/landuse_clustering.html ]\n* Tutorial Earth DS   : [ https:\/\/www.earthdatascience.org\/courses\/scientists-guide-to-plotting-data-in-python\/plot-spatial-data\/customize-vector-plots\/python-customize-map-legends-geopandas\/ ]\n* Conv ee tiles to np arrays: https:\/\/gis.stackexchange.com\/questions\/350771\/earth-engine-simplest-way-to-move-from-ee-image-to-array-for-use-in-sklearn\n* folium cloropleth map: https:\/\/rsandstroem.github.io\/GeoMapsFoliumDemo.html\n* GEEMAP : https:\/\/pythonawesome.com\/a-python-package-for-interactive-mapping-with-google-earth-engine\/","5f333788":"# **Note:**\n* The Google Earth Engine Tiles on top of Folium Maps dissapear after a couple of days, please rerun the notebook if you wish to see them on folium maps.","05b9a560":"# Charting growth ","7884b2ea":"**HTML color generator : [  https:\/\/www.computerhope.com\/tips\/tip143.htm ]**","e9be476f":"# Checking various Indices","9e90c3b7":"# Visualizing areas of growth ","88fe9950":"# Area of Interest","1b0bc8f2":"# Period : 1975-1990","52243bcd":"# Year : 1975","d446f879":"# Period 2000:2015","87a6035d":"# Visualizing First Image of the collection in RGB","f65796b1":"# Methodlogy (Rough) \n\n1) Using Preprocessed LANDSAT 7 satellite images available on google earth engine for visualization of some Indices.\n\n**Some Useful Formulas**\n * Normallized Difference Vegetative Index :  NDVI = NIR - RED \/ (NIR + RED) \n * Normallized Difference Built Up Index   :  NDBI = SWIR- NIR \/ (SWIR + NIR) \n * Built Up                                :  BU   = Max(0,NDBI)*255 - Max(0,NDVI)*255, BU = BU>107\n * Normalized Difference Water Index       :  NDWI =  NIR - SWIR\/(NIR + SWIR)\n * Modified NDWI :                            MNDWI = Green - SWIR\/ (SWIR + Green)\n\n\n2) Using Human settlements layer for Analysis of settlement area change over the region of Pune,India.\n ","a0293033":"# Normalized Difference Vegetative Index","a22e1307":"# Getting the Image collection for visualization","89e8dc48":"**Getting the district boundaries(will be used for analysis)**","b6144ea7":"**The following geometry is used for only Visualization Landsat Images. It is not the district boundry geometry**","97087e04":"# Imports","1855b400":"# Objective:\n* **To get a overview of settlements change around the geographical region of Pune,India using Human Settlements Layer Dataset hosted on Google Earth Engine.**","10740919":"# Year : 1990","21d62149":"**FUNCTIONS FOR CALCULATING IMAGE STATS, BUT NOT USED IN THIS NOTEBOOK**","ccab80c9":"# Authenticating and Initializing earth engine","1b624460":"# Visualizing Settlements Layer ","1273252d":"# Global Human Settlements Layer\n* **ABOUT:** \n\nThe GHSL relies on the design and implementation of new spatial data mining technologies allowing to automatically process and extract analytics and knowledge from large amount of heterogeneous data including: global, fine-scale satellite image data streams, census data, and crowd sources or volunteered geographic information sources.\n\nThe GHS-SMOD is the rural-urban Settlement classification MODel adopted by the GHSL. It is the representation of the degree of urbanization (DEGURBA) concept into the GHSL data scenario. Each grid in the GHS-SMOD has been generated by integrating the GHSL built-up areas and GHSL population grids data for reference epochs: 1975, 1990, 2000, 2015.\n\nThe DEGURBA classification schema is a people-based definition of cities and settlements: it operates using as main input a 1 km\u00b2 grid cell accounting for population at a given point in time. The DEGURBA discriminates the population grid cells in three main classes: 'urban centers' (cities), 'urban clusters' (towns and suburbs), and 'rural grid cells'. (base). These class abstractions translate to 'high density clusters (HDC)', 'low density clusters (LDC)', and 'rural grid cells (RUR)', respectively, in the GHS-SMOD implementation.\n\nThe 'HDC' differ from the DEGURBA 'urban centers' in that they account for the over-fragmentation of cities in regions with large low-density residential development by integrating the built-up layer. In the GHS-SMOD representation, the 'HDC' are the spatial generalization of contiguous population grid cells (4-connectivity, gap-filling) with a density of at least 1500 inhabitants per km\u00b2 or a density of built-up surface > 50%, and a minimum total resident population of 50000. The 'LDC' are continuous grid cells with a density of at least 300 inhabitants per km\u00b2 and a minimum total population of 5000. The 'RUR' are grid cells outside 'HDC' and 'LDC' with population > 0 and < 300. Everything else is classified as inhabited areas where population = 0.\n\nThis dataset was produced in the World Mollweide projection (EPSG:54009).\n* source: https:\/\/developers.google.com\/earth-engine\/datasets\/catalog\/JRC_GHSL_P2016_SMOD_POP_GLOBE_V1?hl=en","a7789d1e":"# End","6836cf56":"# Google earth Engine Helper functions","84231882":"# Year : 2000","cc6530de":"# Year 2015","9713a8f3":"**Calculating NDBI**","e595e1a6":"**Helper Functions**","4788d849":"# ","700d6b9a":"# ","9d874e27":"# Modified Normalized Water Index"}}