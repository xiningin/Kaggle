{"cell_type":{"ffe414c7":"code","3781ccff":"code","0a27f6dd":"code","bac0fa39":"code","98905df2":"code","20839982":"code","6f673b1b":"code","4e4051f9":"code","ccedefb8":"code","e4491948":"code","a4d0b60d":"code","6b0851d0":"code","6e1643cd":"code","c35a281f":"code","571bfa08":"code","e883a3bb":"code","2e604148":"code","130b1007":"code","8da37d65":"code","d1635b74":"code","ca530952":"code","275f6472":"code","902501ec":"markdown","958b74f7":"markdown","9da2b6f3":"markdown","624e369d":"markdown","8f155eee":"markdown","91762b6d":"markdown","2025cbbe":"markdown","0b3ebe0a":"markdown","5770f578":"markdown","aeaf61f5":"markdown"},"source":{"ffe414c7":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\nprint(os.listdir(\"..\/input\"))\n\nimport matplotlib\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Circle\nfrom matplotlib.colors import ListedColormap\n\nfrom xgboost import XGBRegressor\nfrom sklearn.multioutput import MultiOutputRegressor\n\nfrom tensorflow import keras\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, BatchNormalization, InputLayer, Flatten\n\nfrom sklearn.model_selection import cross_validate","3781ccff":"md = pd.read_csv(\"..\/input\/dataset.csv\", index_col = 'UID')\nmd.head(3)","0a27f6dd":"players = md.drop(['Name', 'NationID', 'Born', 'IntCaps', 'IntGoals', 'U21Caps', 'U21Goals', 'PositionsDesc',\n                   'Consistency', 'Dirtiness', 'ImportantMatches', 'Versatility', 'Adaptability', 'Ambition',\n                   'Loyalty', 'Pressure', 'Professional', 'Sportsmanship', 'Temperament', 'Controversy',\n                   'Age', 'Weight', 'Height', 'InjuryProness'\n            ], axis=1)\nplayers.head(3)","bac0fa39":"X = players.loc[:,:'Strength'].drop(['RightFoot', 'LeftFoot'], axis=1)\nX_foot = players.loc[:, ['RightFoot', 'LeftFoot']]\ny = players.loc[:,'Goalkeeper':]","98905df2":"X.head(3)","20839982":"X_foot.head(3)","6f673b1b":"y.head(3)","4e4051f9":"from sklearn import preprocessing\nscaler = preprocessing.MinMaxScaler()\nvectors = X.values\nscaled_rows = scaler.fit_transform(vectors.T).T\nX_normalized = pd.DataFrame(data = scaled_rows, columns = X.columns)","ccedefb8":"fig, axes = plt.subplots(len(X_normalized.columns)\/\/3, 3, figsize=(12, 48))\n\ni = 0\nfor triaxis in axes:\n    for axis in triaxis:\n        X.hist(column = X_normalized.columns[i], bins = 100, ax=axis)\n        i = i+1","e4491948":"for col in y.columns.unique():\n    print(col, y[col][y[col] == 20].count())","a4d0b60d":"XGRegModel = MultiOutputRegressor(XGBRegressor(objective='reg:squarederror'))\ncv_results_XGRegModel = cross_validate(XGRegModel, X, y, cv=5, verbose=1)\nplt.plot(cv_results_XGRegModel['test_score'])","6b0851d0":"XGRegModel.fit(X, y)","6e1643cd":"NNetModel = Sequential()\n\nNNetModel.add(Dense(len(X.columns), activation='relu', input_dim=len(X.columns)))\nNNetModel.add(BatchNormalization())\nNNetModel.add(Dropout(0.2))\nNNetModel.add(Dense((len(X.columns) + len(y.columns)) \/\/ 2, activation='relu'))\nNNetModel.add(Flatten())\nNNetModel.add(Dense(len(y.columns), activation='relu'))\n\nNNetModel.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n\nNNetModel.fit(X.values, y.values, batch_size=128, epochs=50, verbose=1, validation_split=0.2)","c35a281f":"def predict_player_position(uid, model):\n    player_id = uid\n\n    positions = model.predict(X.loc[[player_id]])[0]\n\n    R_scaler = preprocessing.MinMaxScaler(feature_range=(1, 20))\n    vectors = pd.DataFrame(positions.reshape(1,15), columns=y.columns).values\n    scaled_rows = R_scaler.fit_transform(vectors.T).T\n\n    results = pd.DataFrame({'Position':y.columns, 'Real':y.loc[player_id], 'Predicted':scaled_rows[0], 'Difference':y.loc[player_id]-scaled_rows[0]})\n    results.sort_values('Real', ascending=False)\n    \n    accuracy = abs(results['Difference']).median()\n    \n    return results, accuracy","571bfa08":"def draw_positions(results, p_name=''):\n\n    fig, ax = plt.subplots(1,2)\n\n    x_coords = [10,10,10,10,-45,65,10,-45,65,10,10,-45,65,-45,65]\n    y_coords = [-85,-55,95,65,65,65,-25,-25,-25,5,35,35,35,5,5]\n    size = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\n    patches = []\n    for x1,y1,r in zip(x_coords, y_coords, size):\n        circle = Circle((x1,y1), r)\n        patches.append(circle)\n\n    colors1 = results['Predicted']\n    colors2 = results['Real']\n    newcmp = ListedColormap(['red', 'orange', 'yellow', 'green'])\n    p1 = PatchCollection(patches, cmap=newcmp, alpha=1)\n    p2 = PatchCollection(patches, cmap=newcmp, alpha=1)\n    p1.set_array(colors1)\n    p2.set_array(colors2)\n\n    ax[0].set_ylim((-110,120))\n    ax[0].set_xlim((-70,90))\n    ax[0].add_collection(p1)\n    ax[0].set_title('Predicted')\n\n    ax[1].set_ylim((-110,120))\n    ax[1].set_xlim((-70,90))\n    ax[1].add_collection(p2)\n    ax[1].set_title('Real')\n\n    fig.suptitle(p_name)","e883a3bb":"# to see where mistakes were made:\ndef show_predictions(predicted_pos, true_pos):\n    return pred_test_table[pred_test_table['True_position'] == true_pos][pred_test_table[pred_test_table['True_position'] == true_pos]['Pred_position'] == predicted_pos]\n\n# to get specific attributes using player UID:\ndef get_attribute(UID, attribute):\n    return md[md.index == UID][attribute].tolist()[0]\n\n# to get data using names:\ndef search_by_name(name):\n    return md[md['Name'].str.contains(name)]","2e604148":"# to get attributes for FM-like shapes for players:\ndef get_shape_attributes(UID):\n    shape_attributes = {}\n    shape_attributes['Speed'] = (get_attribute(UID, 'Acceleration') + get_attribute(UID, 'Pace')) \/ 2\n    shape_attributes['Physical'] = (get_attribute(UID, 'Agility') + get_attribute(UID, 'Balance')\n                    + get_attribute(UID, 'Stamina') + get_attribute(UID, 'Strength')) \/ 4\n    shape_attributes['Defence'] = (get_attribute(UID, 'Tackling') + get_attribute(UID, 'Marking') + get_attribute(UID, 'Positioning')) \/ 3\n    shape_attributes['Mental'] = (get_attribute(UID, 'Anticipation') + get_attribute(UID, 'Bravery')\n                + get_attribute(UID, 'Concentration') + get_attribute(UID, 'Decisions') + get_attribute(UID, 'Determination') + get_attribute(UID, 'Teamwork')) \/ 6\n    shape_attributes['Aerial'] = (get_attribute(UID, 'Heading') + get_attribute(UID, 'Jumping')) \/ 2\n    shape_attributes['Technique'] = (get_attribute(UID, 'Dribbling') + get_attribute(UID, 'FirstTouch') + get_attribute(UID, 'Technique')) \/ 3\n    shape_attributes['Attack'] = (get_attribute(UID, 'Finishing') + get_attribute(UID, 'Composure') + get_attribute(UID, 'OffTheBall')) \/ 3\n    shape_attributes['Vision'] = (get_attribute(UID, 'Passing') + get_attribute(UID, 'Flair') + get_attribute(UID, 'Vision')) \/ 3\n      \n    return shape_attributes\n\n# same for keepers:\ndef get_shape_attributes_GK(UID):\n    shape_attributes = {}\n    shape_attributes['Speed'] = (get_attribute(UID, 'Acceleration') + get_attribute(UID, 'Pace')) \/ 2\n    shape_attributes['Physical'] = (get_attribute(UID, 'Agility') + get_attribute(UID, 'Balance')\n                + get_attribute(UID, 'Stamina') + get_attribute(UID, 'Strength')) \/ 4\n    shape_attributes['ShotStopping'] = (get_attribute(UID, 'Handling') + get_attribute(UID, 'OneOnOnes')\n                + get_attribute(UID, 'Reflexes') + get_attribute(UID, 'Positioning')) \/ 4\n    shape_attributes['Distribution'] = (get_attribute(UID, 'FirstTouch') + get_attribute(UID, 'Throwing')) \/ 2\n    shape_attributes['Aerial_GK'] = (get_attribute(UID, 'Jumping') + get_attribute(UID, 'AerialAbility')) \/ 2\n    shape_attributes['Eccentricity'] = (get_attribute(UID, 'Eccentricity'))\n    shape_attributes['Communication'] = (get_attribute(UID, 'Communication') + get_attribute(UID, 'RushingOut') + get_attribute(UID, 'CommandOfArea')) \/ 3\n    shape_attributes['Mental'] = (get_attribute(UID, 'Anticipation') + get_attribute(UID, 'Bravery')\n                + get_attribute(UID, 'Concentration') + get_attribute(UID, 'Decisions') + get_attribute(UID, 'Determination') + get_attribute(UID, 'Teamwork')) \/ 6\n    \n    return shape_attributes","130b1007":"# to draw FM-like shapes for players:\ndef draw_shape(UID):\n    \n    values_dict = get_shape_attributes(UID)\n\n    labels = np.array(list(values_dict.keys()))\n    stats = list(values_dict.values())\n    name = get_attribute(UID, 'Name')\n    \n    angles = np.linspace(0, 2*np.pi, len(labels), endpoint=False)\n    stats.append(stats[0])\n    angles = np.concatenate((angles,[angles[0]]))\n\n    fig= plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n    ax.plot(angles, stats, 'o-', linewidth=2)\n    ax.fill(angles, stats, alpha=0.25)\n    ax.set_thetagrids(angles * 180\/np.pi, labels)\n    ax.set_title(name)\n    ax.set_yticks(np.arange(0,25,10))\n\n    plt.show()\n\n# Same for keepers:\ndef draw_shape_GK(UID):\n    \n    values_dict = get_shape_attributes_GK(UID)\n\n    labels = np.array(list(values_dict.keys()))\n    stats = list(values_dict.values())\n    name = get_attribute(UID, 'Name') + ' - GK'\n    \n    angles = np.linspace(0, 2*np.pi, len(labels), endpoint=False)\n    stats.append(stats[0])\n    angles = np.concatenate((angles,[angles[0]]))\n\n    fig= plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n    ax.plot(angles, stats, 'o-', linewidth=2)\n    ax.fill(angles, stats, alpha=0.25)\n    ax.set_thetagrids(angles * 180\/np.pi, labels)\n    ax.set_title(name)\n    ax.set_yticks(np.arange(0,25,10))\n\n    plt.show()","8da37d65":"# to make a prediction for a player using UID:\ndef predict_and_show(uid, model, p_name=''):\n    results = predict_player_position(uid, model)\n    print('MAD =', results[1])\n    draw_positions(results[0], p_name)\n    draw_shape(uid)\n    draw_shape_GK(uid)","d1635b74":"search_by_name('Mohamed Salah')","ca530952":"predict_and_show(98028755, NNetModel, 'Mohamed Salah')","275f6472":"predict_and_show(98028755, XGRegModel, 'Mohamed Salah')","902501ec":"Attributes were used without combining for training and predicting, however for visualization purposes they were combined into groups:\n\n**Speed group:**\n* Acceleration\n* Pace\n\n**Defence group:**\n* Tackling\n* Marking\n* Positioning\n\n**Mental group:**\n* Anticipation\n* Bravery\n* Concentration\n* Decisions\n* Determination\n* Teamwork\n\n**Aerial group:**\n* Heading\n* Jumping\n\n**Technique group:**\n* Dribbling\n* FirstTouch\n* Technique\n\n**Attack group:**\n* Finishing\n* Composure\n* OffTheBall\n\n**Vision group:**\n* Passing\n* Flair\n* Vision\n\nThis was also done for Goalkeepers, but I am not sure if correctly","958b74f7":"Let's see some predictions","9da2b6f3":"Ok, now we have our variables, let's visualise them","624e369d":"# **Predicting Player Position using Football Manager data**\nUsing attributes from [Football Manager 2017 data](https:\/\/www.kaggle.com\/ajinkyablaze\/football-manager-data) we predict player position.\n\nOnly 1 position for each player was selected. This is a limitation, as some players are highly versatile and would have more than just 1 optimal position.\n\nThese positions were used:\n* GK\n* CB\n* WB (both right \/ left, both WB and FB)\n* WM (both right \/ left, both WM and AWM)\n* DM\n* CM\n* AM\n* ST\n","8f155eee":"We can see that there are way too many data here. Let's drop unnecessary columns","91762b6d":"Some Models","2025cbbe":"Ok, that's better. We kept most of the attributes and the positions. Some mental attributes were removed,because they are not that important for player position and are not even visible in the game itself\n\nNext, we split the dataframe into **X** (attributes) and **y** (scores for each position out of 20). We also separate 'RightFoot' and 'LeftFoot' into a **X_foot** dataframe, which will be used later","0b3ebe0a":"There is no need to scale columns because all data are in the same scale (0-20). However, it might be a good idea to scale rows, because we are not interested in player overall level to be a factor in position prediction. For example, Eden Hazard might be a better striker than Emile Heskey, but we want Heskey's predicted ST level to be higher. Having said that, we need to exclude 'RightFoot' and 'LeftFoot' from this, as at least one of these values would always be 20","5770f578":"Some attributes are very goalkeeper-speciffic, but other attributes are relatively normally distributed","aeaf61f5":"First, we import libraries and load the data"}}