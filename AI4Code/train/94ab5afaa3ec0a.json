{"cell_type":{"71cdff88":"code","2aa12a63":"code","c12a4297":"code","e376ab92":"code","1355c558":"code","785e75b8":"code","e90da25f":"code","c1b29b7a":"code","d2b9dd9a":"code","4e85afe6":"code","bfd9b787":"code","8d34afa6":"code","e1783680":"code","b6ceeedf":"code","83617d79":"code","1c3731f7":"code","57f260d0":"code","a4776db6":"code","9c776768":"code","1a89dacf":"code","106ade92":"code","2cd6275c":"code","4d46f222":"code","b62dedab":"markdown","e46eeb31":"markdown","0e844c26":"markdown","c7bcdcbe":"markdown","74de128b":"markdown","7471ee44":"markdown","678ff9c4":"markdown","2e7bc8d1":"markdown","f6d683d9":"markdown"},"source":{"71cdff88":"import cv2\nimport numpy as np","2aa12a63":"# Changing to directory contains classes of fruits","c12a4297":"cd \/kaggle\/input\/fruits\/fruits-360\/Training     ","e376ab92":"  # Can chose any fruits for clustering","1355c558":"ls                                         ","785e75b8":"lists_fruit = ['Apple Red 1','Banana','Lychee','Watermelon','Kohlrabi','Tomato not Ripened']      # Creating lists of fruits","e90da25f":"\nimport os\ndef feature_gen(lists_fruits):\n    my_lists = {key:[] for key in lists_fruits}\n    for file in lists_fruits:\n        list_files = os.listdir(file)\n        os.chdir(file)\n        for files in list_files:\n            my_lists[str(file)].append(cv2.imread(files))\n            \n        os.chdir('..')       \n    return my_lists\n\nlis = feature_gen(lists_fruit)\n\nlists_n = [*lis]\nfor file in lists_n:\n    val = []\n    for fil in lis[file]:\n        rgb = [np.average(fil[:,:,2]),np.average(fil[:,:,1]),np.average(fil[:,:,0])]\n        val.append(rgb)\n    lis[file] = val","c1b29b7a":"lis[\"Apple Red 1\"]               # average value od r,g and b channels of each image","d2b9dd9a":"lists=list(lis.values())","4e85afe6":"lower_bound = []\nupper_bound= []\nlower = 0\nupper = 0\nfor num in lists:\n    upper  = (len(num))+upper\n    lower_bound.append(lower)\n    upper_bound.append(upper)\n    lower = (len(num))+lower","bfd9b787":"lower_bound","8d34afa6":"upper_bound","e1783680":"import itertools\nlists\nlists = list(itertools.chain.from_iterable(lists))\nlists = np.array(lists)\nlists.shape\n\nx = []\ny = []\nz = []\nfor i in range(0,lists.shape[0]):\n    x.append(lists[i][0])\n    y.append(lists[i][1])\n    z.append(lists[i][2])","b6ceeedf":"lower_bound[1]","83617d79":"import plotly.offline as py\nimport plotly.graph_objs as go\npy.init_notebook_mode(connected=True)\n\ndata = []\nfor i in range(0, len(lists_fruit)):\n    data.append(go.Scatter3d(\n        x=x[lower_bound[i]:upper_bound[i]-1],\n        y=y[lower_bound[i]:upper_bound[i]-1],\n        z=z[lower_bound[i]:upper_bound[i]-1],\n        mode='markers',\n        marker=dict(\n            size=12,\n            line=dict(\n                color='rgba(217, 217, 217, 0.14)',\n                width=0.5\n            ),\n            opacity=1\n        ),\n        name = lists_fruit[i]\n    ))\n\nlayout = go.Layout(\n    margin=dict(\n        l=0,\n        r=0,\n        b=0,\n        t=0\n    )\n)\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)","1c3731f7":"X = lists","57f260d0":"from scipy.stats import multivariate_normal\n\n\n\nclass Expectation_Maximization:\n    def __init__(self, num_cluster, max_iter=5):\n        self.num_cluster = num_cluster\n        self.max_iter = int(max_iter)\n\n    def initialize(self, X):\n        self.shape = X.shape\n        self.n, self.m = self.shape\n\n        self.phi = np.full(shape=self.num_cluster, fill_value=1\/self.num_cluster)              # Initializing scales for all clusters\n        self.weights = np.full( shape=self.shape, fill_value=1\/self.num_cluster)               # Initializing weights for all points\n        \n        random_row = np.random.randint(low=0, high=self.n, size=self.num_cluster)              # Setting the size of initial clusters randomly      \n        self.mu = [  X[row_index,:] for row_index in random_row ]                              # Initializing the mean \n        self.sigma = [ np.cov(X.T) for _ in range(self.num_cluster) ]                          # Initializing the variance\n\n    def e_step(self, X):\n        self.weights = self.predict_proba(X)                                                   # Updadting weights\n        self.phi = self.weights.mean(axis=0)                                                   # Updating phi\n        # here mu and sigma is constant\n    \n    def m_step(self, X):\n        # Updating mu and sigma but weight and phi is constant\n        for i in range(self.num_cluster):                      \n            weight = self.weights[:, [i]]\n            total_weight = weight.sum()\n            self.mu[i] = (X * weight).sum(axis=0) \/ total_weight\n            self.sigma[i] = np.cov(X.T, \n                aweights=(weight\/total_weight).flatten(), \n                bias=True)\n     \n    def fit(self, X):                                                                         # fit the model\n        self.initialize(X)\n        \n        for iteration in range(self.max_iter):\n            self.e_step(X)\n            self.m_step(X)\n            \n    def predict_proba(self, X):                                                               # Function for calculating pdf\n        likelihood = np.zeros( (self.n, self.num_cluster) )\n        for i in range(self.num_cluster):\n            distribution = multivariate_normal(\n                mean=self.mu[i], \n                cov=self.sigma[i])\n            likelihood[:,i] = distribution.pdf(X)\n        \n        numerator = likelihood * self.phi\n        denominator = numerator.sum(axis=1)[:, np.newaxis]\n        weights = numerator \/ denominator\n        return weights\n    \n    def predict(self, X):                                                                     # Predict the cluster\n        weights = self.predict_proba(X)\n        return np.argmax(weights, axis=1)","a4776db6":"np.random.seed(42)\nexpm = Expectation_Maximization(num_cluster=6, max_iter=10)\nexpm.fit(X)","9c776768":"# Pedicting cluster number custom\n\nnum = np.unique(expm.predict([[180,212,178]]))\nprint(num)","1a89dacf":"lists_new = list(lis.values())","106ade92":"import itertools\nlists_new = list(itertools.chain.from_iterable(lists_new))\nlists_new = np.array(lists)\nlists_new.shape","2cd6275c":"dicts = {}\n\nfor i in range(0,lists_new.shape[0]):\n        dicts.setdefault(int(np.unique(expm.predict(lists[i]))),[]).append(lists[i])","4d46f222":"import plotly.offline as py\nimport plotly.graph_objs as go\npy.init_notebook_mode(connected=True)\n\ndata = []\nfor j in range(0,6):\n    x=[]\n    y=[]\n    z=[]\n    for i in range(0, len(dicts[j])):\n        \n        x.append(dicts[j][i][0])\n        y.append(dicts[j][i][1])\n        z.append(dicts[j][i][2])\n    data.append(go.Scatter3d(\n        x=x,\n        y=y,\n        z=z,\n        mode='markers',\n        marker=dict(\n            size=12,\n            line=dict(\n                color='rgba(217, 217, 217, 0.14)',\n                width=0.5\n                ),\n            opacity=1\n            ),\n            name = j\n            ))\n\nlayout = go.Layout(\n    margin=dict(\n        l=0,\n        r=0,\n        b=0,\n        t=0\n    )\n)\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)","b62dedab":"# Creating lists of r , g and b for plotting from dictionary\n","e46eeb31":"# Creating a dictionary of predicted cluster and points","0e844c26":"# Reading all images of listed class and taking average value of r , g and b channels of every image\n","c7bcdcbe":"# Plotting predicted clusters","74de128b":"# Importing Open CV for extracting feature and Numpy for mathematical manipulation","7471ee44":"# Creating 3-D cluster predicted by EM model","678ff9c4":"# Plotting the clusters before applying Expectation Maximization","2e7bc8d1":"# Finding all the interval for divide classes which will help in plotting","f6d683d9":"#  Creating Expectation maximization model"}}