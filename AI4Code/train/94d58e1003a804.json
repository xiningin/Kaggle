{"cell_type":{"3c84cb23":"code","bbfd2173":"code","441995ac":"code","b007b039":"code","995577c8":"code","18d0c873":"code","3ff09b0f":"code","36ecf5be":"code","c88eae51":"code","dd417d49":"code","86af581f":"code","55a6d9da":"code","df65de67":"markdown","c70dd274":"markdown","c2625b9f":"markdown","705f60e6":"markdown","81580b9d":"markdown","5e01b42b":"markdown","d8846978":"markdown","41467e64":"markdown","94e5863d":"markdown","015ba260":"markdown"},"source":{"3c84cb23":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","bbfd2173":"# import pytorch modules\nimport torch\nfrom torch import nn, optim\nimport torch.nn.functional as F\nfrom torch.utils.data import DataLoader\nfrom torchvision import models, transforms, datasets\nfrom torchvision.datasets import ImageFolder\n\n# path\ntrain_path = '..\/input\/seg_train\/seg_train'\ntest_path = '..\/input\/seg_test\/seg_test'\nvalid_path = '..\/input\/seg_pred\/seg_pred'\n\n\ntransforms = transforms.Compose([\n    transforms.Resize((150, 150)),\n    transforms.ToTensor(),\n    transforms.Normalize([0.5, 0.5, 0.5],\n                         [0.5, 0.5, 0.5])\n])\n\n\n\ntrain_data = datasets.ImageFolder(train_path, transform=transforms)\ntest_data = datasets.ImageFolder(test_path, transform=transforms)\n\ntrainloader = torch.utils.data.DataLoader(train_data, batch_size=300, shuffle=True)\ntestloader = torch.utils.data.DataLoader(test_data, batch_size=300)\n\nlen(trainloader)","441995ac":"classes = [\"buildings\", \"forest\", \"glacier\", \"mountain\", \"sea\", \"street\"]","b007b039":"import numpy as np\nimport matplotlib.pyplot as plt\n\ndata_iter = iter(testloader)\nimages, labels = data_iter.next()\n\nfig = plt.figure(figsize=(25, 5))\nfor idx in range(2):\n    ax = fig.add_subplot(1, 5, idx + 1, xticks=[], yticks=[])\n    # unnormolaize first\n    img = images[idx] \/ 2 + 0.5\n    npimg = img.numpy()\n    img = np.transpose(npimg, (1, 2, 0)) #transpose\n    ax.imshow(img, cmap='gray')\n    ax.set_title(classes[labels[idx]])","995577c8":"model = models.vgg16(pretrained=True)\nmodel.classifier","18d0c873":"for pram in model.parameters():\n    pram.requires_grad = False","3ff09b0f":"import torch.nn as nn\n\nclasiifier = nn.Sequential(\n  nn.Linear(in_features=25088, out_features=4096),\n  nn.ReLU(),\n  nn.Dropout(p=0.2),\n  nn.Linear(in_features=4096, out_features=4096),\n  nn.ReLU(),\n  nn.Dropout(p=0.5),\n  nn.Linear(in_features=4096, out_features=6),\n  nn.LogSoftmax(dim=1)  \n)\n\nmodel.classifier = clasiifier","36ecf5be":"import torch.optim as optim\nimport torch\n\ncriterion = nn.NLLLoss()\noptimizer = optim.Adam(model.classifier.parameters(), lr=0.003)\n#gpu\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel.to(device)","c88eae51":"!pip install tqdm","dd417d49":"# from tqdm import tqdm\n\nepochs = 3\nsteps = 0\nrunning_loss = 0\nprint_every = 10\nfor epoch in range(epochs):\n    for inputs, labels in trainloader:\n        steps += 1\n        # Move input and label tensors to the default device\n        inputs, labels = inputs.to(device), labels.to(device)\n        \n        optimizer.zero_grad()\n        \n        logps = model.forward(inputs)\n        loss = criterion(logps, labels)\n        loss.backward()\n        optimizer.step()\n\n        running_loss += loss.item()\n        \n        if steps % print_every == 0:\n            test_loss = 0\n            accuracy = 0\n            model.eval()\n            with torch.no_grad():\n                for inputs, labels in testloader:\n                    inputs, labels = inputs.to(device), labels.to(device)\n                    logps = model.forward(inputs)\n                    batch_loss = criterion(logps, labels)\n                    \n                    test_loss += batch_loss.item()\n                    \n                    # Calculate accuracy\n                    ps = torch.exp(logps)\n                    top_p, top_class = ps.topk(1, dim=1)\n                    equals = top_class == labels.view(*top_class.shape)\n                    accuracy += torch.mean(equals.type(torch.FloatTensor)).item()\n                    \n            print(f\"Epoch {epoch+1}\/{epochs}.. \"\n                  f\"Train loss: {running_loss\/print_every:.3f}.. \"\n                  f\"Test loss: {test_loss\/len(testloader):.3f}.. \"\n                  f\"Test accuracy: {accuracy\/len(testloader):.3f}\")\n            running_loss = 0\n            model.train()","86af581f":"# track test loss\nclasses = [\"buildings\", \"forest\", \"glacier\", \"mountain\", \"sea\", \"street\"]\n\ntest_loss = 0.0\nclass_correct = list(0. for i in range(6))\nclass_total = list(0. for i in range(6))\n\nwith torch.no_grad():\n  model.eval()\n  # iterate over test data\n  for data, target in testloader:\n      # move tensors to GPU if CUDA is available\n      data, target = data.to(device), target.to(device)\n      # forward pass: compute predicted outputs by passing inputs to the model\n      output = model(data)\n      # calculate the batch loss\n      loss = criterion(output, target)\n      # update test loss \n      test_loss += loss.item()*data.size(0)\n      # convert output probabilities to predicted class\n      _, pred = torch.max(output, 1)    \n      # compare predictions to true label\n      correct = np.squeeze(pred.eq(target.data.view_as(pred)))\n      # calculate test accuracy for each object class\n      for i in range(38):\n          label = target.data[i]\n          class_correct[label] += correct[i].item()\n          class_total[label] += 1\n\n# average test loss\ntest_loss = test_loss\/len(testloader.dataset)\nprint('Test Loss: {:.6f}\\n'.format(test_loss))\n\nfor i in range(6):\n    if class_total[i] > 0:\n        print('Test Accuracy of %5s: %2d%% (%2d\/%2d)' % (\n            classes[i], 100 * class_correct[i] \/ class_total[i],\n            np.sum(class_correct[i]), np.sum(class_total[i])))\n    else:\n        print('Test Accuracy of %5s: N\/A (no training examples)' % (classes[i]))\n\nprint('\\nTest Accuracy (Overall): %2d%% (%2d\/%2d)' % (\n    100. * np.sum(class_correct) \/ np.sum(class_total),\n    np.sum(class_correct), np.sum(class_total)))","55a6d9da":"import numpy as np # linear algebra\nfrom matplotlib import pyplot as plt\nfrom PIL import Image\nfrom glob import glob\nimport os\nfrom os import path\n\nclasses = trainloader.dataset.class_to_idx\n\nfile = glob(os.path.join(valid_path, '*.jpg'))\n\nfor i in file[:5]:\n    with Image.open(i) as f:\n        img = transformer(f).unsqueeze(0)\n        with torch.no_grad():\n            out = model(img.to(device)).cpu().numpy()\n            for key, value in classes.items():\n                if value == np.argmax(out):\n                    print(key)\n            plt.imshow(np.array(f))\n            plt.show()","df65de67":"# Prepare Data","c70dd274":"Load Pretrined Model","c2625b9f":"Freeze the parameters","705f60e6":"Loss funcation and optimizer","81580b9d":"Replace Classifier","5e01b42b":"Visualize data","d8846978":"Train model","41467e64":"Calculate Accuracy","94e5863d":"Test Network","015ba260":"Create a list of Classes"}}