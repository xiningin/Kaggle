{"cell_type":{"2afe0ee7":"code","76eb4fb2":"code","c1bd77ab":"markdown","3d222063":"markdown","044ff5b8":"markdown"},"source":{"2afe0ee7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport gym # for environment\nfrom collections import deque\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import Adam # adaptive momentum \nimport random\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory","76eb4fb2":"class DQLAgent(): \n    \n    def __init__(self, env):\n        # parameters and hyperparameters\n        \n        # this part is for neural network or build_model()\n        self.state_size = env.observation_space.shape[0] # this is for input of neural network node size\n        self.action_size = env.action_space.n # this is for out of neural network node size\n        \n        # this part is for replay()\n        self.gamma = 0.95\n        self.learning_rate = 0.001\n        \n        # this part is for adaptiveEGreedy()\n        self.epsilon = 1 # initial exploration rate\n        self.epsilon_decay = 0.995\n        self.epsilon_min = 0.01\n        \n        self.memory = deque(maxlen = 1000) # a list with 1000 memory, if it becomes full first inputs will be deleted\n        \n        self.model = self.build_model()\n    \n    def build_model(self):\n        # neural network for deep Q learning\n        model = Sequential()\n        model.add(Dense(48, input_dim = self.state_size, activation = 'tanh')) # first hidden layer\n        model.add(Dense(self.action_size, activation = 'linear')) # output layer\n        model.compile(loss = 'mse', optimizer = Adam(lr = self.learning_rate))\n        return model\n    \n    def remember(self, state, action, reward, next_state, done):\n        # storage\n        self.memory.append((state, action, reward, next_state, done))\n    \n    def act(self, state):\n        # acting, exploit or explore\n        if random.uniform(0,1) <= self.epsilon:\n            return env.action_space.sample()\n        else:\n            act_values = self.model.predict(state)\n            return np.argmax(act_values[0])\n            \n    \n    def replay(self, batch_size):\n        # training\n        \n        if len(self.memory) < batch_size:\n            return # memory is still not full\n        \n        minibatch = random.sample(self.memory, batch_size) # take 16 (batch_size) random samples from memory\n        for state, action, reward, next_state, done in minibatch:\n            if done: # if the game is over, I dont have next state, I just have reward \n                target = reward\n            else:\n                target = reward + self.gamma * np.amax(self.model.predict(next_state)[0]) \n                # target = R(s,a) + gamma * max Q`(s`,a`)\n                # target (max Q` value) is output of Neural Network which takes s` as an input \n                # amax(): flatten the lists (make them 1 list) and take max value\n            train_target = self.model.predict(state) # s --> NN --> Q(s,a)=train_target\n            train_target[0][action] = target\n            self.model.fit(state, train_target, verbose = 0) # verbose: dont show loss and epoch\n    \n    def adaptiveEGreedy(self):\n        if self.epsilon > self.epsilon_min:\n            self.epsilon *= self.epsilon_decay\n            \n\nif __name__ == \"__main__\":\n    \n    # initialize gym environment and agent\n    env = gym.make('CartPole-v0')\n    agent = DQLAgent(env)\n\n    batch_size = 16\n    episodes = 50\n    for e in range(episodes):\n        \n        # initialize environment\n        state = env.reset()\n        state = np.reshape(state, [1,4])\n        \n        time = 0 # each second I will get reward, because I want to sustain a balance forever\n        while True:\n            \n            # act\n            action = agent.act(state)\n            \n            # step\n            next_state, reward, done, _ = env.step(action)\n            next_state = np.reshape(next_state, [1,4])\n            \n            # remember \/ storage\n            agent.remember(state, action, reward, next_state, done)\n            \n            # update state\n            state = next_state\n            \n            # replay\n            agent.replay(batch_size)\n            \n            # adjust epsilon\n            agent.adaptiveEGreedy()\n            \n            time += 1\n            \n            if done:\n                print('episode: {}, time: {}'.format(e, time))\n                break\n    ","c1bd77ab":"**if time = 200, it means that I have 100% success because after 200 times the game resets**","3d222063":"**Test Part**","044ff5b8":"# change this cell to code \nimport time\n\ntrained_model = agent # Now I have trained agent\nstate = env.reset() # Game will start with inital random state\nstate = np.reshape(state, [1,4])\ntime_t = 0\n\nwhile True:\n    env.render()\n    action = trained_model.act(state)\n    next_state, reward, done, _ = env.step(action)\n    next_state = np.reshape(next_state, [1,4])\n    state = next_state\n    time_t += 1\n    print(time_t)\n    time.sleep(0.01)\n    if done:\n        break\n\nprint('Done')            "}}