{"cell_type":{"2b8c05a3":"code","a71e43aa":"code","5414db9d":"code","fe54a397":"code","1c2f2ddc":"code","f947e1ea":"code","c2a44922":"code","5e8e0963":"code","267c223e":"code","5012c730":"code","0dbebda5":"code","035bd63f":"code","720f2d46":"code","f48376cd":"code","d025aa59":"code","3559d1d3":"code","34d67bb8":"code","42b8703f":"code","69f6fc10":"code","746fa45c":"code","2eb65bd3":"code","d08955ed":"code","0c28b3a8":"code","8cb5f3d3":"code","624ce2ea":"code","d9321562":"code","2a601a21":"code","29c9542a":"code","151f018d":"code","a0ef009c":"code","0ba48551":"code","11a528fa":"code","543685b5":"code","d0f1a74f":"code","23ed45d7":"code","50c424d9":"code","cda9ac4e":"code","c93ad2fd":"code","aeb33f1b":"code","b979e985":"code","255b50fc":"code","fe3a1412":"code","97245dc4":"code","d6398a9b":"markdown","98996091":"markdown","7b707c7c":"markdown","b0f74141":"markdown","c6f5f13d":"markdown","eeeb276f":"markdown"},"source":{"2b8c05a3":"# Importing the libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n%matplotlib inline\nimport time\nimport random\n\nrandom.seed(100)","a71e43aa":"# Read in track metadata with genre labels\ntracks = pd.read_csv(\"..\/input\/fma-rock-vs-hiphop.csv\")\n\n","5414db9d":"tracks.head()","fe54a397":"# Read in track metrics with the features\nechonest_metrics = pd.read_json(\"..\/input\/echonest-metrics.json\", precise_float=True)\nechonest_metrics.head()\n","1c2f2ddc":"# Merge the relevant columns of tracks and echonest_metrics\necho_tracks = pd.merge(echonest_metrics, tracks[[\"track_id\", \"genre_top\"]], on=\"track_id\")\necho_tracks.head()\n","f947e1ea":"# Inspect the resultant dataframe\necho_tracks.info()","c2a44922":"display(echo_tracks[\"genre_top\"].value_counts())","5e8e0963":"# Create a correlation matrix\ncorr_metrics = echo_tracks.corr()\ncorr_metrics.style.background_gradient()","267c223e":"echo_tracks.drop([\"track_id\"], axis=1).describe()","5012c730":"# Define our features \nfeatures = echo_tracks.drop([\"genre_top\",\"track_id\"], axis=1)\nfeatures.head()","0dbebda5":"# Define our labels\nlabels = echo_tracks[\"genre_top\"]\nlabels.head()","035bd63f":"# Scale the features and set the values to a new variable\nfrom sklearn.preprocessing import StandardScaler\nsc_X = StandardScaler()\nfeatures = sc_X.fit_transform(features)\npd.DataFrame(features).head()\n","720f2d46":"Cat=echo_tracks.drop([\"track_id\"], axis=1)\nCat.head()","f48376cd":"Cat.shape","d025aa59":"# Encoding categorical data\n# Encoding the Independent Variable\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\nlabelencoder_X = LabelEncoder()\nCat['genre_top'] = labelencoder_X.fit_transform(Cat['genre_top'])\nCat.head()\n\n","3559d1d3":"pd.DataFrame(Cat['genre_top']).info()","34d67bb8":"## Correlation Matrix\nsns.set(style=\"white\")\n\n# Compute the correlation matrix\ncorr = Cat.corr()","42b8703f":"# Generate a mask for the upper triangle\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n# Set up the matplotlib figure\nf, ax = plt.subplots(figsize=(18, 15))\n\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})","69f6fc10":"#Correlation with Quality with respect to attributes\nCat.corrwith(Cat.genre_top).plot.bar(\n        figsize = (20, 10), title = \"Correlation with quality\", fontsize = 15,\n        rot = 45, grid = True)","746fa45c":"#Assigning and dividing the dataset\nX = Cat.drop('genre_top',axis=1)\ny=Cat['genre_top']","2eb65bd3":"Cat.shape","d08955ed":"features_label = Cat.columns[:9]","0c28b3a8":"#Fitting Random Forest Classification to the Training set\nfrom sklearn.ensemble import RandomForestClassifier\nclassifier = RandomForestClassifier(n_estimators = 200, criterion = 'entropy', random_state = 0)\nclassifier.fit(X, y)\nimportances = classifier.feature_importances_\nindices = np. argsort(importances)[::-1]\nfor i in range(X.shape[1]):\n    print (\"%2d) %-*s %f\" % (i + 1, 30, features_label[i],importances[indices[i]]))","8cb5f3d3":"plt.title('Feature Importances')\nplt.bar(range(X.shape[1]),importances[indices], color=\"green\", align=\"center\")\nplt.xticks(range(X.shape[1]),features_label, rotation=90)\nplt.xlim([-1, X.shape[1]])\nplt.show()","624ce2ea":"\n# Splitting the dataset into the Training set and Test set\nfrom sklearn.model_selection  import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state = 5)","d9321562":"# Feature Scaling\nfrom sklearn.preprocessing import StandardScaler\nsc = StandardScaler()\nX_train2 = pd.DataFrame(sc.fit_transform(X_train))\nX_test2 = pd.DataFrame(sc.transform(X_test))\nX_train2.columns = X_train.columns.values\nX_test2.columns = X_test.columns.values\nX_train2.index = X_train.index.values\nX_test2.index = X_test.index.values\nX_train = X_train2\nX_test = X_test2","2a601a21":"#Using Principal Dimensional Reduction\nfrom sklearn.decomposition import PCA\npca = PCA(n_components = None )\nX_train = pca.fit_transform(X_train)\nX_test = pca.transform(X_test)\nexplained_variance = pca.explained_variance_ratio_\nprint(pd.DataFrame(explained_variance))","29c9542a":"# plot the explained variance using a barplot\nfig, ax = plt.subplots()\nax.bar(range(8), explained_variance)\nax.set_xlabel('Principal Component #')","151f018d":"# Import numpy\nimport numpy as np\n\n# Calculate the cumulative explained variance\ncum_exp_variance = np.cumsum(explained_variance)\n\n# Plot the cumulative explained variance and draw a dashed line at 0.90.\nfig, ax = plt.subplots()\nax.plot(range(8), cum_exp_variance)\nax.axhline(y=0.9, linestyle='--')\nn_components = 6\n\n# Perform PCA with the chosen number of components and project data onto components\npca = PCA(n_components, random_state=10)\npca.fit(features)\npca_projection = pca.transform(features)","a0ef009c":"#### Model Building ####\n\n### Comparing Models\n\n## Logistic Regression\nfrom sklearn.linear_model import LogisticRegression\nclassifier = LogisticRegression(random_state = 0, penalty = 'l1')\nclassifier.fit(X_train, y_train)\n\n# Predicting Test Set\ny_pred = classifier.predict(X_test)\nfrom sklearn.metrics import confusion_matrix, accuracy_score, f1_score, precision_score, recall_score\nacc = accuracy_score(y_test, y_pred)\nprec = precision_score(y_test, y_pred)\nrec = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\n\nresults = pd.DataFrame([['Logistic Regression', acc, prec, rec, f1]],\n               columns = ['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])\nprint(results)","0ba48551":"## Randomforest\nfrom sklearn.ensemble import RandomForestClassifier\nclassifier = RandomForestClassifier(random_state = 0, n_estimators = 100,\n                                    criterion = 'entropy')\nclassifier.fit(X_train, y_train)\n\n# Predicting Test Set\ny_pred = classifier.predict(X_test)\nacc = accuracy_score(y_test, y_pred)\nprec = precision_score(y_test, y_pred)\nrec = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\n\nmodel_results = pd.DataFrame([['Random Forest (n=100)', acc, prec, rec, f1]],\n               columns = ['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])\n\nresults = results.append(model_results, ignore_index = True)\nprint(results)","11a528fa":"## Decision Tree\nfrom sklearn.tree import DecisionTreeClassifier\nclassifier = DecisionTreeClassifier(criterion = 'entropy', random_state = 0)\nclassifier.fit(X_train, y_train)\n\n# Predicting Test Set\ny_pred = classifier.predict(X_test)\nacc = accuracy_score(y_test, y_pred)\nprec = precision_score(y_test, y_pred)\nrec = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\n\nmodel_results = pd.DataFrame([['Decision Tree ', acc, prec, rec, f1]],\n               columns = ['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])\n\nresults = results.append(model_results, ignore_index = True)\nprint(results)","543685b5":"## SVM (Linear)\nfrom sklearn.svm import SVC\nclassifier = SVC(random_state = 0, kernel = 'linear')\nclassifier.fit(X_train, y_train)\n\n# Predicting Test Set\ny_pred = classifier.predict(X_test)\nacc = accuracy_score(y_test, y_pred)\nprec = precision_score(y_test, y_pred)\nrec = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\n\nmodel_results = pd.DataFrame([['SVM (Linear)', acc, prec, rec, f1]],\n               columns = ['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])\n\nresults = results.append(model_results, ignore_index = True)\nprint(results)","d0f1a74f":"# Fitting K-NN to the Training set\nfrom sklearn.neighbors import KNeighborsClassifier\nclassifier = KNeighborsClassifier(n_neighbors = 5, metric = 'minkowski', p = 2)\nclassifier.fit(X_train, y_train)\n# Predicting Test Set\ny_pred = classifier.predict(X_test)\nacc = accuracy_score(y_test, y_pred)\nprec = precision_score(y_test, y_pred)\nrec = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\n\nmodel_results = pd.DataFrame([['KNN', acc, prec, rec, f1]],\n               columns = ['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])\n\nresults = results.append(model_results, ignore_index = True)\nprint(results)\n","23ed45d7":"## SVM (rbf)\nfrom sklearn.svm import SVC\nclassifier = SVC(random_state = 0, kernel = 'rbf')\nclassifier.fit(X_train, y_train)\n\n# Predicting Test Set\ny_pred = classifier.predict(X_test)\nacc = accuracy_score(y_test, y_pred)\nprec = precision_score(y_test, y_pred)\nrec = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\n\nmodel_results = pd.DataFrame([['SVM (RBF)', acc, prec, rec, f1]],\n               columns = ['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])\n\nresults = results.append(model_results, ignore_index = True)\nprint(results)","50c424d9":"## K-fold Cross Validation\nfrom sklearn.model_selection import cross_val_score\naccuracies = cross_val_score(estimator = classifier, X= X_train, y = y_train,\n                             cv = 10)\nprint(\"SVM Classifier Accuracy: %0.2f (+\/- %0.2f)\"  % (accuracies.mean(), accuracies.std() * 2))","cda9ac4e":"\nparameters = {\"C\": [0.1,0.3,1,3,10,30],\n              \n              'gamma': [.001,.01,.1,.3,1],\n             }\n\n     \n\n\n\nfrom sklearn.model_selection import GridSearchCV\ngrid_search = GridSearchCV(  estimator = classifier, # Make sure classifier points to the SVM RBF model\n                           param_grid = parameters,\n                           scoring = \"accuracy\",\n                           cv = 5,\n                           n_jobs = -1\n                          ,verbose=1)\n\nt0 = time.time()\ngrid_search = grid_search.fit(X_train, y_train)\nt1 = time.time()\nprint(\"Took %0.2f seconds\" % (t1 - t0))\n\nrf_best_accuracy = grid_search.best_score_\nrf_best_parameters = grid_search.best_params_\nrf_best_accuracy, rf_best_parameters\n","c93ad2fd":"rf_best_accuracy, rf_best_parameters","aeb33f1b":"# Predicting Test Set\ny_pred = grid_search.predict(X_test)\nacc = accuracy_score(y_test, y_pred)\nprec = precision_score(y_test, y_pred)\nrec = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\n\nmodel_results = pd.DataFrame([['SVM RBF Grid results', acc, prec, rec, f1]],\n               columns = ['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])\n\nresults = results.append(model_results, ignore_index = True)\nresults","b979e985":"# Create the classification report for both models\nfrom sklearn.metrics import classification_report\nprint(classification_report(y_test, y_pred))\n","255b50fc":"import matplotlib.pyplot as plt\nimport itertools\n\nfrom sklearn import svm, datasets\nfrom sklearn.metrics import confusion_matrix\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    plt.tight_layout()\n","fe3a1412":"# Making the Confusion Matrix \nfrom sklearn.metrics import confusion_matrix\ncm = confusion_matrix(y_test, y_pred)\nnp.set_printoptions(precision=2)\n\n# Plot normalized confusion matrix\nplot_confusion_matrix(cm,classes=[0,1])\nsns.set(rc={'figure.figsize':(6,6)})\nplt.show()\n","97245dc4":"#so the model accuracy is 90%","d6398a9b":"## 1. Preparing our dataset\n<p><em>These recommendations are so on point! How does this playlist know me so well?<\/em><\/p>\n<p><img src=\"https:\/\/s3.amazonaws.com\/assets.datacamp.com\/production\/project_449\/img\/iphone_music.jpg\" alt=\"Project Image Record\" width=\"600px\"><\/p>\n<p>Over the past few years, streaming services with huge catalogs have become the primary means through which most people listen to their favorite music. But at the same time, the sheer amount of music on offer can mean users might be a bit overwhelmed when trying to look for newer music that suits their tastes.<\/p>\n<p>For this reason, streaming services have looked into means of categorizing music to allow for personalized recommendations. One method involves direct analysis of the raw audio information in a given song, scoring the raw data on a variety of metrics. Today, we'll be examining data compiled by a research group known as The Echo Nest. Our goal is to look through this dataset and classify songs as being either 'Hip-Hop' or 'Rock' - all without listening to a single one ourselves. In doing so, we will learn how to clean our data, do some exploratory data visualization, and use feature reduction towards the goal of feeding our data through some simple machine learning algorithms, such as decision trees and logistic regression.<\/p>\n<p>To begin with, let's load the metadata about our tracks alongside the track metrics compiled by The Echo Nest. A song is about more than its title, artist, and number of listens. We have another dataset that has musical features of each track such as <code>danceability<\/code> and <code>acousticness<\/code> on a scale from -1 to 1. These exist in two different files, which are in different formats - CSV and JSON. While CSV is a popular file format for denoting tabular data, JSON is another common file format in which databases often return the results of a given query.<\/p>\n<p>Let's start by creating two pandas <code>DataFrames<\/code> out of these files that we can merge so we have features and labels (often also referred to as <code>X<\/code> and <code>y<\/code>) for the classification later on.<\/p>","98996091":"##  Pairwise relationships between continuous variables\n<p>We typically want to avoid using variables that have strong correlations with each other -- hence avoiding feature redundancy -- for a few reasons:<\/p>\n<ul>\n<li>To keep the model simple and improve interpretability (with many features, we run the risk of overfitting).<\/li>\n<li>When our datasets are very large, using fewer features can drastically speed up our computation time.<\/li>\n<\/ul>\n<p>To get a sense of whether there are any strongly correlated features in our data, we will use built-in functions in the <code>pandas<\/code> package.<\/p>","7b707c7c":"##  Normalizing the feature data and Model Training\n<p>As mentioned earlier, it can be particularly useful to simplify our models and use as few features as necessary to achieve the best result. Since we didn't find any particular strong correlations between our features, we can instead use a common approach to reduce the number of features called <strong>principal component analysis (PCA)<\/strong>. <\/p>\n<p>It is possible that the variance between genres can be explained by just a few features in the dataset. PCA rotates the data along the axis of highest variance, thus allowing us to determine the relative contribution of each feature of our data towards the variance between classes. <\/p>\n<p>However, since PCA uses the absolute variance of a feature to rotate the data, a feature with a broader range of values will overpower and bias the algorithm relative to the other features. To avoid this, we must first normalize our data. There are a few methods to do this, but a common way is through <em>standardization<\/em>, such that all features have a mean = 0 and standard deviation = 1 (the resultant is a z-score).<\/p>","b0f74141":"# Feature Selection ","c6f5f13d":"# EDA","eeeb276f":"So the SVM kernal is the highest accuracy model"}}