{"cell_type":{"a1565fa3":"code","cad62a3c":"code","df8b2516":"code","fa3b8475":"code","effb67aa":"code","4166e2d0":"code","033e566d":"code","9f923556":"code","0d4f5a37":"code","560eebfd":"code","60ebce78":"code","8a8f5993":"markdown","034ef3c4":"markdown","cf782e92":"markdown","2e38906f":"markdown"},"source":{"a1565fa3":"%%capture\n!pip install --upgrade wandb","cad62a3c":"import wandb\nfrom wandb.keras import WandbCallback\nwandb.login()","df8b2516":"import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import Input, Model\nfrom tensorflow.keras.layers import Conv2D, BatchNormalization, MaxPool2D, ReLU, ELU, LeakyReLU, Flatten, Dense, Add, AveragePooling2D, GlobalAveragePooling2D\nimport pprint\npp = pprint.PrettyPrinter(indent=4)\n\nimport numpy as np\nnp.random.seed(666)\ntf.random.set_seed(666)","fa3b8475":"# Which GPU is being used?\n!nvidia-smi","effb67aa":"# Load the training and testing set of CIFAR10\n(X_train, y_train), (X_test, y_test) = tf.keras.datasets.cifar10.load_data()\n\nX_train = X_train.astype('float32')\nX_train = X_train\/255.\n\nX_test = X_test.astype('float32')\nX_test = X_test\/255.\n\ny_train = tf.reshape(tf.one_hot(y_train, 10), shape=(-1, 10))\ny_test = tf.reshape(tf.one_hot(y_test, 10), shape=(-1, 10))\n\n# Create TensorFlow dataset\nBATCH_SIZE = 256\nAUTOTUNE = tf.data.experimental.AUTOTUNE\n\ntrain_ds = tf.data.Dataset.from_tensor_slices((X_train, y_train))\ntrain_ds = train_ds.shuffle(1024).cache().batch(BATCH_SIZE).prefetch(AUTOTUNE)\n\ntest_ds = tf.data.Dataset.from_tensor_slices((X_test, y_test))\ntest_ds = test_ds.cache().batch(BATCH_SIZE).prefetch(AUTOTUNE)","4166e2d0":"options_phase0 = {\n    'a_filter_size': [(1,1), (3,3), (5,5), (7,7), (9,9)],\n    'a_include_BN': [True, False],\n    'a_output_channels': [8, 16, 32, 64, 128, 256, 512],\n    'activation_type': [ReLU, ELU, LeakyReLU],\n    'b_filter_size': [(1,1), (3,3), (5,5), (7,7), (9,9)],\n    'b_include_BN': [True, False],\n    'b_output_channels': [8, 16, 32, 64, 128, 256, 512],\n    'include_pool': [True, False],\n    'pool_type': [MaxPool2D, AveragePooling2D],\n    'include_skip': [True, False]\n}\n\noptions = {\n    'include_layer': [True, False],\n    'a_filter_size': [(1,1), (3,3), (5,5), (7,7), (9,9)],\n    'a_include_BN': [True, False],\n    'a_output_channels': [8, 16, 32, 64, 128, 256, 512],\n    'b_filter_size': [(1,1), (3,3), (5,5), (7,7), (9,9)],\n    'b_include_BN': [True, False],\n    'b_output_channels': [8, 16, 32, 64, 128, 256, 512],\n    'include_pool': [True, False],\n    'pool_type': [MaxPool2D, AveragePooling2D],\n    'include_skip': [True, False]\n}","033e566d":"class Organism:\n    def __init__(self,\n                 chromosome={},\n                 phase=0,\n                 prevBestOrganism=None):\n        '''\n        chromosome is a dictionary of genes\n        phase is the phase that the individual belongs to\n        prevBestOrganism is the best organism of the previous phase\n        '''\n        self.phase = phase\n        self.chromosome = chromosome\n        self.prevBestOrganism=prevBestOrganism\n        if phase != 0:\n            # In a later stage, the model is made by\n            # attaching new layers to the prev best model\n            self.last_model = prevBestOrganism.model\n    \n    def build_model(self):\n        '''\n        This is the function to build the keras model\n        '''\n        keras.backend.clear_session()\n        inputs = Input(shape=(32,32,3))\n        if self.phase != 0:\n            # Slice the prev best model\n            # Use the model as a layer\n            # Attach new layer to the sliced model\n            intermediate_model = Model(inputs=self.last_model.input,\n                                       outputs=self.last_model.layers[-3].output)\n            for layer in intermediate_model.layers:\n                # To make the iteration efficient\n                layer.trainable = False\n            inter_inputs = intermediate_model(inputs)\n            x = Conv2D(filters=self.chromosome['a_output_channels'],\n                       padding='same',\n                       kernel_size=self.chromosome['a_filter_size'],\n                       use_bias=self.chromosome['a_include_BN'])(inter_inputs)\n            # This is to ensure that we do not randomly chose anothere activation\n            self.chromosome['activation_type'] = self.prevBestOrganism.chromosome['activation_type']\n        else:\n            # For PHASE 0 only\n            # input layer\n            x = Conv2D(filters=self.chromosome['a_output_channels'],\n                       padding='same',\n                       kernel_size=self.chromosome['a_filter_size'],\n                       use_bias=self.chromosome['a_include_BN'])(inputs)\n        if self.chromosome['a_include_BN']:\n            x = BatchNormalization()(x)\n        x = self.chromosome['activation_type']()(x)\n        if self.chromosome['include_pool']:\n            x = self.chromosome['pool_type'](strides=(1,1),\n                                             padding='same')(x)\n        if self.phase != 0 and self.chromosome['include_layer'] == False:\n            # Except for PHASE0, there is a choice for\n            # the number of layers that the model wants\n            if self.chromosome['include_skip']:\n                y = Conv2D(filters=self.chromosome['a_output_channels'],\n                           kernel_size=(1,1),\n                           padding='same')(inter_inputs)\n                x = Add()([y,x])\n            x = GlobalAveragePooling2D()(x)\n            x = Dense(10, activation='softmax')(x)\n        else:\n            # PHASE0 or no skip\n            # in the tail\n            x = Conv2D(filters=self.chromosome['b_output_channels'],\n                       padding='same',\n                       kernel_size=self.chromosome['b_filter_size'],\n                       use_bias=self.chromosome['b_include_BN'])(x)\n            if self.chromosome['b_include_BN']:\n                x = BatchNormalization()(x)\n            x = self.chromosome['activation_type']()(x)\n            if self.chromosome['include_skip']:\n                y = Conv2D(filters=self.chromosome['b_output_channels'],\n                           padding='same',\n                           kernel_size=(1,1))(inputs)\n                x = Add()([y,x])\n            x = GlobalAveragePooling2D()(x)\n            x = Dense(10, activation='softmax')(x)\n        self.model = Model(inputs=[inputs], outputs=[x])\n        self.model.compile(optimizer='adam',\n                           loss='categorical_crossentropy',\n                           metrics=['accuracy'])\n    def fitnessFunction(self,\n                        train_ds,\n                        test_ds,\n                        generation_number):\n        '''\n        This function is used to calculate the\n        fitness of an individual.\n        '''\n        wandb.init(entity=\"authors\",\n                   project=\"vlga\",\n                   group='KAGp{}'.format(self.phase),\n                   job_type='g{}'.format(generation_number))\n        self.model.fit(train_ds,\n                       epochs=3,\n                       callbacks=[WandbCallback()],\n                       verbose=0)\n        _, self.fitness = self.model.evaluate(test_ds,\n                                              verbose=0)\n    def crossover(self,\n                  partner,\n                  generation_number):\n        '''\n        This function helps in making children from two\n        parent individuals.\n        '''\n        child_chromosome = {}\n        endpoint = np.random.randint(low=0, high=len(self.chromosome))\n        for idx, key in enumerate(self.chromosome):\n            if idx <= endpoint:\n                child_chromosome[key] = self.chromosome[key]\n            else:\n                child_chromosome[key] = partner.chromosome[key]\n        child = Organism(chromosome= child_chromosome, phase=self.phase, prevBestOrganism=self.prevBestOrganism)\n        child.build_model()\n        child.fitnessFunction(train_ds,\n                              test_ds,\n                              generation_number=generation_number)\n        return child\n    \n    def mutation(self, generation_number):\n        '''\n        One of the gene is to be mutated.\n        '''\n        index = np.random.randint(0, len(self.chromosome))\n        key = list(self.chromosome.keys())[index]\n        if  self.phase != 0:\n            self.chromosome[key] = options[key][np.random.randint(len(options[key]))]\n        else:\n            self.chromosome[key] = options_phase0[key][np.random.randint(len(options_phase0[key]))]\n        self.build_model()\n        self.fitnessFunction(train_ds,\n                             test_ds,\n                             generation_number=generation_number)\n    \n    def show(self):\n        '''\n        Util function to show the individual's properties.\n        '''\n        pp.pprint(self.chromosome)","9f923556":"def random_hyper(phase):\n    if phase == 0:\n        return {\n        'a_filter_size': options_phase0['a_filter_size'][np.random.randint(len(options_phase0['a_filter_size']))],\n        'a_include_BN': options_phase0['a_include_BN'][np.random.randint(len(options_phase0['a_include_BN']))],\n        'a_output_channels': options_phase0['a_output_channels'][np.random.randint(len(options_phase0['a_output_channels']))],\n        'activation_type': options_phase0['activation_type'][np.random.randint(len(options_phase0['activation_type']))],\n        'b_filter_size': options_phase0['b_filter_size'][np.random.randint(len(options_phase0['b_filter_size']))],\n        'b_include_BN': options_phase0['b_include_BN'][np.random.randint(len(options_phase0['b_include_BN']))],\n        'b_output_channels': options_phase0['b_output_channels'][np.random.randint(len(options_phase0['b_output_channels']))],\n        'include_pool': options_phase0['include_pool'][np.random.randint(len(options_phase0['include_pool']))],\n        'pool_type': options_phase0['pool_type'][np.random.randint(len(options_phase0['pool_type']))],\n        'include_skip': options_phase0['include_skip'][np.random.randint(len(options_phase0['include_skip']))]\n        }\n    else:\n        return {\n        'a_filter_size': options['a_filter_size'][np.random.randint(len(options['a_filter_size']))],\n        'a_include_BN': options['a_include_BN'][np.random.randint(len(options['a_include_BN']))],\n        'a_output_channels': options['a_output_channels'][np.random.randint(len(options['a_output_channels']))],\n        'b_filter_size': options['b_filter_size'][np.random.randint(len(options['b_filter_size']))],\n        'b_include_BN': options['b_include_BN'][np.random.randint(len(options['b_include_BN']))],\n        'b_output_channels': options['b_output_channels'][np.random.randint(len(options['b_output_channels']))],\n        'include_pool': options['include_pool'][np.random.randint(len(options['include_pool']))],\n        'pool_type': options['pool_type'][np.random.randint(len(options['pool_type']))],\n        'include_layer': options['include_layer'][np.random.randint(len(options['include_layer']))],\n        'include_skip': options['include_skip'][np.random.randint(len(options['include_skip']))]\n        }","0d4f5a37":"def softmax(x):\n    e_x = np.exp(x - np.max(x))\n    return e_x \/ e_x.sum()","560eebfd":"class Generation:\n    def __init__(self,\n                 fitSurvivalRate,\n                 unfitSurvivalProb,\n                 mutationRate,\n                 phase,\n                 population_size,\n                 prevBestOrganism):\n        self.population_size = population_size\n        self.population = []\n        self.generation_number = 0\n        self.mutationRate = mutationRate\n        self.fitSurvivalRate = fitSurvivalRate\n        self.unfitSurvivalProb = unfitSurvivalProb\n        self.prevBestOrganism = prevBestOrganism\n        self.phase = phase\n        # creating the first population: GENERATION_0\n        # can be thought of as the setup function\n        for idx in range(self.population_size):\n            org = Organism(chromosome=random_hyper(self.phase), phase=self.phase, prevBestOrganism=self.prevBestOrganism)\n            org.build_model()\n            org.fitnessFunction(train_ds,\n                                test_ds,\n                                generation_number=self.generation_number)\n            self.population.append(org)\n\n        # sorts the population according to fitness (high to low)\n        self.sortModel()\n        self.generation_number += 1\n\n    def sortModel(self):\n        '''\n        sort the models according to the \n        fitness in descending order.\n        '''\n        fitness = [ind.fitness for ind in self.population]\n        sort_index = np.argsort(fitness)[::-1]\n        self.population = [self.population[index] for index in sort_index]\n\n    def generate(self):\n        '''\n        Generate a new generation in the same phase\n        '''\n        number_of_fit = int(self.population_size * self.fitSurvivalRate)\n        new_pop = self.population[:number_of_fit]\n        for individual in self.population[number_of_fit:]:\n            if np.random.rand() <= self.unfitSurvivalProb:\n                new_pop.append(individual)\n        for index, individual in enumerate(new_pop):\n            if np.random.rand() <= self.mutationRate:\n                new_pop[index].mutation(generation_number=self.generation_number)\n        fitness = [ind.fitness for ind in new_pop]\n        children=[]\n        for idx in range(self.population_size-len(new_pop)):\n            parents = np.random.choice(new_pop, replace=False, size=(2,), p=softmax(fitness))\n            A=parents[0]\n            B=parents[1]\n            child=A.crossover(B, generation_number=self.generation_number)\n            children.append(child)\n        self.population = new_pop+children\n        self.sortModel()\n        self.generation_number+=1\n\n    def evaluate(self, last=False):\n        '''\n        Evaluate the generation\n        '''\n        fitness = [ind.fitness for ind in self.population]\n        wandb.log({'Best fitness': fitness[0]})\n        wandb.log({'Average fitness': sum(fitness)\/len(fitness)})\n        self.population[0].show()\n        if last:\n            return self.population[0]","60ebce78":"population_size = 10\nnumber_generation = 3\n\nfitSurvivalRate = 0.5\nunfitSurvivalProb = 0.2\nmutationRate = 0.1\nnumber_of_phases = 5\n\nprevBestOrganism = None\n\nfor phase in range(number_of_phases):\n    # print(\"PHASE {}\".format(phase))\n    generation = Generation(fitSurvivalRate=fitSurvivalRate,\n                            unfitSurvivalProb=unfitSurvivalProb,\n                            mutationRate=mutationRate,\n                            population_size=population_size,\n                            phase=phase,\n                            prevBestOrganism=prevBestOrganism)\n    while generation.generation_number < number_generation:\n        generation.generate()\n        if generation.generation_number == number_generation:\n            # Last generation is the phase\n            # print('I AM THE BEST IN THE PHASE')\n            prevBestOrganism = generation.evaluate(last=True)\n            keras.utils.plot_model(prevBestOrganism.model, to_file='best.png')\n            wandb.log({\"best_model\": [wandb.Image('best.png', caption=\"Best Model\")]})\n        else:\n            generation.evaluate()","8a8f5993":"# Organism\nAn organism contains the following:\n1. phase - This denotes which phase does the organism belong to\n2. chromosome - A dictionary of genes (hyperparameters)\n3. model - The `tf.keras` model corresponding to the chromosome\n4. prevBestOrganism - The best organism in the previous **phase**","034ef3c4":"# Imports\nThe following packages will be used:\n1. tensorflow\n2. numpy\n3. pprint","cf782e92":"# Data\nThe data that is being used for this experiment is the CIFAR10.\n\nThe dataset has 60,000 images of dimensions 32,32,3. ","2e38906f":"# Generation\nThis is a class that hold generations of models.\n1. fitSurvivalRate - The amount of fit individuals we want in the next generation.\n2. unfitSurvivalProb - The probability of sending unfit individuals\n3. mutationRate - The mutation rate to change genes in an individual.\n4. phase - The phase that the generation belongs to.\n5. population_size - The amount of individuals that the generation consists of.\n6. prevBestOrganism - The best organism (individual) is the last phase"}}