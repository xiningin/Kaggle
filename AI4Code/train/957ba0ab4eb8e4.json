{"cell_type":{"7e0e4b27":"code","49cc1786":"code","a0a829b5":"code","acdcf141":"code","64f9c474":"code","eb12d10c":"code","22d3cc69":"code","654847fb":"code","d548794d":"code","e19d4b05":"code","ab4862c1":"code","f96a88dc":"code","505dae1a":"code","feb74ff4":"code","4cb2a13d":"code","ce9e3572":"code","27d890ad":"code","c58f2cad":"code","c780f258":"code","a923e8a3":"code","babbc54f":"code","9297d522":"code","1eb60868":"code","8c0c4e58":"code","d858f2f6":"code","1cdb99c9":"code","950fa5d1":"code","a1046702":"code","9a2d6f08":"code","87633aaf":"code","f61b7ea8":"code","bb7026c1":"code","55a195d8":"code","e7fcce92":"code","a4fceaa3":"code","3b9c438f":"code","6c1e8bd2":"code","8ee69ed9":"code","e48b9151":"code","4161dbfa":"code","b811d96b":"code","5c9d864c":"code","5c69b5b2":"code","ec5c4e87":"code","cedc7e58":"code","90b07bfc":"code","845780fa":"code","269939f5":"code","fe372184":"code","08814792":"code","b13d0231":"code","a0fd9e42":"code","03a45c68":"code","435e96ba":"code","98326419":"code","9693f375":"code","adcf696d":"code","b7e3542e":"code","bb515520":"code","56e77e76":"code","bef93007":"code","080c1fd8":"code","a894e727":"code","e5cb7bac":"code","141019e4":"code","ed7ff8ce":"code","743eba46":"code","190b07b0":"code","b58a58c9":"code","4d40ce50":"code","c8282f3d":"code","b5e1e0aa":"code","96d468b8":"code","ed60f227":"code","cad3225c":"code","97f9e232":"code","9612946a":"code","a64c93c1":"code","2d4b26bc":"code","565396d2":"code","b5abb92f":"code","ff408d92":"markdown","e4ebf765":"markdown","feceeda4":"markdown","7eedbfe0":"markdown","688c7b13":"markdown","e7feb3f2":"markdown","5e3edd11":"markdown","52585a46":"markdown","265b4ff7":"markdown","895f9e02":"markdown","69b99993":"markdown","d6779899":"markdown","499fe327":"markdown"},"source":{"7e0e4b27":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns","49cc1786":"data = pd.read_csv(\"..\/input\/mushroom-classification\/mushrooms.csv\")","a0a829b5":"data.info()","acdcf141":"data.head()","64f9c474":"overview=data.describe()\ndata.describe()","eb12d10c":"overview[overview==1].loc[\"unique\"]\n# veil-type feature is useless, we can drop it","22d3cc69":"sns.countplot(x=\"class\",data=data)\n# fairly even split between classes","654847fb":"sns.countplot(x=\"class\",data=data,hue=\"cap-shape\")\n# very few conical or sunken cap shapes\n# very few poisonous mushrooms have a sunken shape\n# very few edible mushrooms have a conical shape","d548794d":"sns.countplot(x=\"class\",hue=\"cap-color\",data=data)\n# very few purple, cinnamon, green mushroom caps","e19d4b05":"sns.countplot(x=\"class\",hue=\"bruises\",data=data)\n# poisononous mushrooms are less likely to have bruises","ab4862c1":"sns.countplot(x=\"class\",hue=\"odor\",data=data)\n# edible mushrooms only seem to have an almond, anise or no odour\n# very few poisonous mushrooms have almond or anise odour","f96a88dc":"sns.countplot(x=\"class\",hue=\"gill-size\",data=data)","505dae1a":"fig, axes = plt.subplots(1, 2, figsize=(15,5))\nsns.countplot(ax=axes[0],x=\"gill-attachment\",data=data)\nsns.countplot(ax=axes[1],x=\"class\", hue=\"gill-attachment\",data=data)\n# almost all instances have no gill attachment, CONSIDER REMOVING FEATURE\n# when gills are attached, they are more likely to be edible","feb74ff4":"fig, axes = plt.subplots(1, 2, figsize=(15,5))\nsns.countplot(ax=axes[0],x=\"gill-spacing\",data=data)\nsns.countplot(x=\"class\",hue=\"gill-spacing\",data=data)\n# the majority of instances have close gill spacing, no \"distant\" instances at all, consider removing\n# if mushroom has crowded gill spacing, more likely to be edible","4cb2a13d":"sns.countplot(x=\"class\",hue=\"gill-color\",data=data)\n# the vast majority of mushrooms with buff gills are poisonous","ce9e3572":"sns.countplot(x=\"class\",hue=\"stalk-shape\",data=data)\n# fairly even split","27d890ad":"fig, axes = plt.subplots(2, 2, figsize=(15,10))\nsns.countplot(ax=axes[0,0],x=\"stalk-surface-above-ring\",data=data)\nsns.countplot(ax=axes[0,1],x=\"class\",hue=\"stalk-surface-above-ring\",data=data)\nsns.countplot(ax=axes[1,0],x=\"stalk-surface-below-ring\",data=data)\nsns.countplot(ax=axes[1,1],x=\"class\",hue=\"stalk-surface-below-ring\",data=data)\n# fairly mixed\n# very few yellow above-stalk instances","c58f2cad":"sns.countplot(x=\"veil-color\",data=data)\n# vast majority of veils are white, CONSIDER REMOVING","c780f258":"fig, axes = plt.subplots(2, 2, figsize=(15,10))\nsns.countplot(ax=axes[0,0],x=\"ring-number\",data=data)\nsns.countplot(ax=axes[0,1],x=\"class\", hue=\"ring-number\",data=data)\nsns.countplot(ax=axes[1,0],x=\"ring-type\",data=data)\nsns.countplot(ax=axes[1,1],x=\"class\", hue=\"ring-type\",data=data)\n# majority of instances have one ring, possibly worth removing - test\n# edible mushrooms more likely to have two rings\n# poisonous mushrooms more likely to have no rings\n# fairly mixed ring types, quite few flairing and none types","a923e8a3":"fig, axes = plt.subplots(1, 2, figsize=(15,5))\nsns.countplot(ax=axes[0],x=\"spore-print-color\",data=data)\nsns.countplot(ax=axes[1],x=\"class\", hue=\"spore-print-color\",data=data)\n#fairly mixed","babbc54f":"fig, axes = plt.subplots(1, 2, figsize=(15,5))\nsns.countplot(ax=axes[0],x=\"population\",data=data)\nsns.countplot(ax=axes[1],x=\"class\", hue=\"population\",data=data)\n# fairly mixed populations, numerous and abundant populations seem to indicate edible","9297d522":"fig, axes = plt.subplots(1, 2, figsize=(15,5))\nsns.countplot(ax=axes[0],x=\"habitat\",data=data)\nsns.countplot(ax=axes[1],x=\"class\", hue=\"habitat\",data=data)\n# fairly mixed habitats","1eb60868":"from sklearn.model_selection import train_test_split","8c0c4e58":"data.columns","d858f2f6":"# Removed gill-attachment and veil-type features\nX = data[['cap-shape', 'cap-surface', 'cap-color', 'bruises', 'odor',\n       'gill-spacing', 'gill-size', 'gill-color',\n       'stalk-shape', 'stalk-root', 'stalk-surface-above-ring',\n       'stalk-surface-below-ring', 'stalk-color-above-ring',\n       'stalk-color-below-ring', 'veil-color', 'ring-number',\n       'ring-type', 'spore-print-color', 'population', 'habitat']]\ny = data['class']","1cdb99c9":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)","950fa5d1":"# experimenting with different encoding methods\nfrom sklearn.preprocessing import OrdinalEncoder\nordinal_encoder = OrdinalEncoder()","a1046702":"# transforming X using ordinal encoding\nordarray_train = ordinal_encoder.fit_transform(X_train)\norddata_train = pd.DataFrame(np.array(ordarray_train),columns=X.columns)\nordarray_test = ordinal_encoder.fit_transform(X_test)\norddata_test = pd.DataFrame(np.array(ordarray_test),columns=X.columns)","9a2d6f08":"# transforming X using one hot encoding\nhotdata_train = pd.get_dummies(X_train,X_train.columns,drop_first = False)\nhotdata_test = pd.get_dummies(X_test,X_test.columns,drop_first = False)","87633aaf":"from sklearn.linear_model import LogisticRegression","f61b7ea8":"log_reg_ord = LogisticRegression(max_iter=500)\nlog_reg_hot = LogisticRegression(max_iter=500)\nlog_reg_ord.fit(orddata_train,y_train)\nlog_reg_hot.fit(hotdata_train,y_train)","bb7026c1":"predict_ord = log_reg_ord.predict(orddata_test)\npredict_hot = log_reg_hot.predict(hotdata_test)","55a195d8":"from sklearn.metrics import classification_report,confusion_matrix","e7fcce92":"# from context, we should prioritise\nprint(classification_report(y_test,predict_ord))","a4fceaa3":"# One hot encoder achieves 100% accuracy on this set, possibly overfitting\nprint(classification_report(y_test,predict_hot))","3b9c438f":"log_reg_hot.classes_","6c1e8bd2":"# if no labels are given to confusion matrix, matrix indices represent existing classes sorted in order (same as classes_ attribute) \n# positive class is \"poisonous\"\n# from context, we should aim to minimise False Negatives (labeling a poisonous mushroom as edible)\nconfusion_matrix(y_test,predict_ord)\n# predicted 69 mushrooms were edible that were poisonous","8ee69ed9":"confusion_matrix(y_test,predict_hot)","e48b9151":"from sklearn.model_selection import cross_val_score, cross_val_predict","4161dbfa":"# using cross validation on 20 folds to determine whether model is over fitting\n# seems neither model overfits to training split\nord_scores = cross_val_score(log_reg_ord, orddata_train, y_train, cv=20, scoring=\"accuracy\")\nord_scores","b811d96b":"# a logistic regression model with one hot encoding seems to be an extremely good model\nhot_scores = cross_val_score(log_reg_hot, hotdata_train, y_train, cv=20, scoring=\"accuracy\")\nhot_scores","5c9d864c":"hot_log_reg_predict = cross_val_predict(log_reg_hot, hotdata_train, y_train, cv=20)","5c69b5b2":"log_reg_hot.classes_","ec5c4e87":"print(confusion_matrix(hot_log_reg_predict,y_train))","cedc7e58":"print(classification_report(hot_log_reg_predict,y_train))","90b07bfc":"from sklearn.tree import DecisionTreeClassifier","845780fa":"# one hot encoding led to better results with Logistic regression so try this first\nhot_tree = DecisionTreeClassifier(max_depth=3)\nhot_tree.fit(hotdata_train, y_train)","269939f5":"hot_tree_scores = cross_val_score(hot_tree, hotdata_train, y_train, cv=20)\nhot_tree_scores","fe372184":"ord_tree = DecisionTreeClassifier(max_depth=3)\nord_tree.fit(orddata_train, y_train)","08814792":"# ordinal encoding again generally lead to lower scores\nord_tree_scores = cross_val_score(ord_tree, orddata_train, y_train, cv=20)\nord_tree_scores","b13d0231":"ord_tree_predict = cross_val_predict(ord_tree, orddata_train, y_train, cv=20)\nhot_tree_predict = cross_val_predict(hot_tree, hotdata_train, y_train, cv=20)","a0fd9e42":"print(confusion_matrix(ord_tree_predict,y_train))","03a45c68":"print(classification_report(y_train,ord_tree_predict))","435e96ba":"# again one hot encoding produces a better classifier\nprint(confusion_matrix(hot_tree_predict,y_train))","98326419":"print(classification_report(y_train,hot_tree_predict))","9693f375":"# use a grid search to find an optimised tree depth\nfrom sklearn.model_selection import GridSearchCV","adcf696d":"tree_grid = [\n    {'max_depth':[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]},\n]\n\ngrid_search = GridSearchCV(hot_tree, tree_grid,cv=5,return_train_score=True)","b7e3542e":"grid_search.fit(hotdata_train,y_train)","bb515520":"grid_search.best_estimator_","56e77e76":"# decision tree with depth of 8 and one hot encoding has similar accuracy to log_reg_hot\nopt_scores = cross_val_score(DecisionTreeClassifier(max_depth=8), hotdata_train, y_train, cv=20, scoring=\"accuracy\")\nopt_scores","bef93007":"opt_tree_predict = cross_val_predict(DecisionTreeClassifier(max_depth=8), hotdata_train, y_train, cv=20)","080c1fd8":"print(confusion_matrix(opt_tree_predict,y_train))","a894e727":"print(classification_report(opt_tree_predict,y_train))","e5cb7bac":"from sklearn.ensemble import RandomForestClassifier","141019e4":"rnd_hot = RandomForestClassifier(n_estimators=500,max_leaf_nodes=16)\nrnd_hot.fit(hotdata_train,y_train)","ed7ff8ce":"rnd_hot_predict = rnd_hot.predict(hotdata_test)","743eba46":"print(confusion_matrix(rnd_hot_predict,y_test))","190b07b0":"print(classification_report(y_test,rnd_hot_predict))","b58a58c9":"# gridsearch to optimise hyperparameters\nforest_grid = [\n    {'n_estimators':[30,40,50,70,80,90,100],'max_leaf_nodes':[15,20,30,40]},\n]\nforest_search = GridSearchCV(rnd_hot, forest_grid,cv=5,return_train_score=True)","4d40ce50":"forest_search.fit(hotdata_train,y_train)","c8282f3d":"forest_search.best_params_","b5e1e0aa":"opt_rnd_hot = RandomForestClassifier(n_estimators=50,max_leaf_nodes=20)\nopt_rnd_hot.fit(hotdata_train,y_train)","96d468b8":"opt_rnd_hot_predict = opt_rnd_hot.predict(hotdata_test)","ed60f227":"opt_rnd_hot_predict = cross_val_predict(opt_rnd_hot, hotdata_train, y_train, cv=20)","cad3225c":"print(confusion_matrix(y_train,opt_rnd_hot_predict))","97f9e232":"print(classification_report(y_train,opt_rnd_hot_predict))","9612946a":"final_pred = opt_rnd_hot.predict(hotdata_test)","a64c93c1":"print(confusion_matrix(final_pred,y_test))","2d4b26bc":"print(classification_report(final_pred,y_test))","565396d2":"means = []\nbig_index = 0\nfor index,count in enumerate(X.describe().loc['unique']):\n    means.append(np.mean(opt_rnd_hot.feature_importances_[big_index:big_index+count]))\n    big_index+=count","b5abb92f":"feature_importances = pd.DataFrame(list(zip(X_train.columns,means)),columns=['col', 'importance'])\nfeature_importances.sort_values(by='importance', ascending=False)","ff408d92":"8124 instances, no missing\/null data","e4ebf765":"# Summary","feceeda4":"# Data Preparation and Splitting","7eedbfe0":"# Models","688c7b13":"Useless features: gill-attachment, veil-type  #WRONG gill-attachment was useful, look at skewing in the data\n\nLess useful features: veil-color\n\nConsider for both: gill-spacing","e7feb3f2":"Gill-size seems to be the most important feature in determining if a mushroom is poisonous, followed by bruises and odor.","5e3edd11":"# Exploratory Analysis","52585a46":"**Model 1 - Logistic Regression**","265b4ff7":"All columns are descriptive - no numerical data at all\n","895f9e02":"# Mushrooms!","69b99993":"After transforming the data via One-Hot Encoding, there are various algorithms that produce a near perfect performance. However, from the context of the data, we should prioritise recall over precision which means aiming to minimise False Negatives. As a result, the Random Forest model seems to be the best.","d6779899":"**Model 2 - Decision Tree and Random Forest**","499fe327":"Data source: https:\/\/www.kaggle.com\/uciml\/mushroom-classification\n\nAttempting to \n - build a classification model to determine if mushrooms are edible\n - determine which machine learning algorithm models the data best\n - determine which feature in the data is most important in determining whether a mushroom is poisonous "}}