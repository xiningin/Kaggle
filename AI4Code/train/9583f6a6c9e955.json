{"cell_type":{"1e813ad8":"code","a2a8bc70":"code","a274fc79":"code","2decedf3":"code","1cee981d":"code","4b1b97b5":"code","9193a037":"code","70d013e0":"code","7f477ac4":"code","8900d2cb":"code","ce684a5b":"markdown","f9e7b49b":"markdown","68eccfea":"markdown","7acfd055":"markdown"},"source":{"1e813ad8":"!pip install git+https:\/\/github.com\/qubvel\/segmentation_models.pytorch -qq","a2a8bc70":"import os\nimport glob\nfrom pathlib import Path\nimport time\nimport math\nfrom random import randint\nimport glob\nimport numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mtc\nfrom PIL import Image\nfrom tqdm import tqdm\nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2\nimport cv2\nfrom sklearn.model_selection import KFold\nimport seaborn as sns\nimport segmentation_models_pytorch as smp\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader\nimport torchvision\nimport torchvision.transforms as T\n\ndef timeSince(since):\n    now = time.time()\n    s = now - since\n    m = math.floor(s \/ 60)\n    s -= m * 60\n    return '%dm %ds' % (m, s)\n\n\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#    for filename in filenames:\n#        print(os.path.join(dirname, filename))\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nprint(device)\n\nmodel_path = 'unet_model.pth'","a274fc79":"data_path = '..\/input\/lane-detection-for-carla-driving-simulator\/'\n\ntesttransform = A.Compose([\n    A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n    ToTensorV2()\n])\n\nclass LaneDetection(Dataset):\n    def __init__(self, path, val=False, transforms=None):\n        self.transforms = transforms\n        if not val:\n            self.img_path = path+'train\/'\n            self.mask_path = path+'train_label\/'\n        else:\n            self.img_path = path+'val\/'\n            self.mask_path = path+'val_label\/'\n        self.img_names = [i.split('\/')[-1] for i in glob.glob(self.img_path+'*.png')]\n        \n    def __getitem__(self, idx):\n        img_name = self.img_names[idx]\n        mask_name = img_name[:-4]+'_label'+img_name[-4:]\n        img = cv2.imread(self.img_path+img_name)\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        mask = cv2.imread(self.mask_path+mask_name, cv2.IMREAD_UNCHANGED)\n        if self.transforms:\n            transformed = self.transforms(image=img, mask=mask)\n            img = transformed['image']\n            mask = transformed['mask'].long()\n        return img, mask\n    \n    def __len__(self):\n        return len(self.img_names)","2decedf3":"val_dataset = LaneDetection(data_path, val=False, transforms=testtransform)\nimg, mask = val_dataset[200]\nprint(img.shape, mask.shape)\n\nprint(len(val_dataset))","1cee981d":"# Test dataset is working and see some samples\ndef sample(dataset, num_samples):\n    samples = []\n    for i in range(num_samples):\n        n = randint(0, len(dataset))\n        img, mask = dataset[n]\n        samples.append((img.squeeze(), mask.squeeze()))\n    return samples\n\nnum_imgs = 4\n\ndataset = LaneDetection(data_path, val=True, transforms=testtransform)\nimgs = sample(dataset, num_imgs)\nfig, axs = plt.subplots(num_imgs, 2, figsize=(10, 5*num_imgs))\nfor i in range(num_imgs):    \n    # Image\n    axs[i, 0].imshow(imgs[i][0].permute(1, 2, 0))\n    \n    # Original Mask\n    axs[i, 1].imshow(imgs[i][1])\n    \nplt.show()","4b1b97b5":"def init_model(from_scratch=True, path='unet_model.pth', best=False):\n    model = smp.UnetPlusPlus(encoder_name='resnet34',\n                   encoder_weights='imagenet',\n                   in_channels=3,\n                   classes=3).to(device)\n    if from_scratch:\n        print('Model initialised from Scratch.')\n        return model \n    elif best:\n        path = path.split('.')\n        path[0] += '_best'\n        path = '.'.join(path)\n        model.load_state_dict(torch.load(path))\n        print('Loaded saved model at: ', path)\n        return model\n    else:\n        model.load_state_dict(torch.load(path))\n        print('Loaded saved model at: ', path)\n        return model","9193a037":"model = init_model(from_scratch=True)\noptimizer = torch.optim.Adam(model.parameters(), lr=0.01)\nloss = smp.losses.DiceLoss('multiclass')\nloss.__name__ = 'DiceLoss'","70d013e0":"batch_size = 4\n\ntrain_epoch = smp.utils.train.TrainEpoch(\n    model,\n    loss=loss,\n    metrics=[],\n    optimizer=optimizer,\n    device=device,\n    verbose=True\n)\n\nval_epoch = smp.utils.train.ValidEpoch(\n    model,\n    loss=loss,\n    metrics=[],\n    device=device,\n    verbose=True\n)\n\n\ntrain_dataset = LaneDetection(data_path, val=False, transforms=testtransform)\nval_dataset = LaneDetection(data_path, val=True, transforms=testtransform)\ntrainloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)\nvalloader = DataLoader(val_dataset, batch_size=batch_size, shuffle=True)","7f477ac4":"num_epochs = 2\nfor i in range(1, num_epochs+1):\n    print('Epoch[{}\/{}]'.format(i, num_epochs))\n    train_log = train_epoch.run(trainloader)\n    val_log = val_epoch.run(valloader)\n    print(train_log, val_log)\n    \ntorch.save(model.cpu().state_dict(), model_path)\nprint('model saved to:', model_path)","8900d2cb":"# Test model is working and see some samples\nnum_imgs = 10\n\ndataset = LaneDetection(data_path, val=True, transforms=testtransform)\nimgs = sample(dataset, num_imgs)\nfig, axs = plt.subplots(num_imgs, 3, figsize=(15, 5*num_imgs))\nfor i in range(num_imgs):\n    pred_mask = model(imgs[i][0].unsqueeze(0).to(device))\n    pred_mask = torch.argmax(pred_mask.squeeze(), axis=0)\n    \n    # Image\n    axs[i, 0].imshow(imgs[i][0].permute(1, 2, 0))\n    \n    # Original Mask\n    axs[i, 1].imshow(imgs[i][1])\n    \n    # Predicted Mask\n    axs[i, 2].imshow(pred_mask.cpu())\n    \nplt.show()","ce684a5b":"# Data","f9e7b49b":"# Training","68eccfea":"# Predictions","7acfd055":"# Model"}}