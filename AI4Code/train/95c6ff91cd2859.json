{"cell_type":{"5d23fded":"code","69fe8c5e":"code","ea89328b":"code","e7251573":"code","5d853154":"code","594ba94b":"code","44fc5603":"code","1626458c":"code","5e21cf9c":"code","cc11421c":"code","55f64ce0":"code","20bc051f":"code","5ac35e93":"code","59f3c6f0":"code","4b6f193d":"code","8c42729e":"code","bd1b6f4e":"code","5a800c12":"code","352a5a5d":"code","4fb86d03":"code","bcd07473":"code","edc0ebff":"code","1242e264":"code","74624d80":"code","81bc31c4":"code","ee97522b":"code","1a75ad1a":"code","ba40cfc5":"code","200fc22c":"code","22180e7b":"code","c5d6751e":"code","41da3fa7":"code","2296a3e6":"code","2b325a97":"code","9340be7e":"code","33ce2b9d":"code","84c5c74f":"code","3dd871bc":"code","761bed7e":"code","ddea8780":"code","96482220":"code","9dfecb0d":"code","ca426e68":"code","3a59bb0c":"code","0d20692c":"code","4e031044":"code","d662cb5b":"code","870c69c7":"code","724592e7":"code","015f339d":"code","b2c522d4":"code","005176c0":"markdown","b1220a09":"markdown","d4f16247":"markdown","15abb5d5":"markdown","dd59efce":"markdown","90a25166":"markdown","a86c584e":"markdown","e43d6198":"markdown","5e38650c":"markdown","cd741046":"markdown","b5e6dfbe":"markdown","a9913a74":"markdown","8d27489e":"markdown","a365b559":"markdown","162b5b15":"markdown","899ad0e8":"markdown","432799a5":"markdown"},"source":{"5d23fded":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport nltk\nimport yaml\nimport matplotlib.pyplot as plt\nimport missingno as msno\n\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier, StackingClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.svm import LinearSVC, SVC\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.linear_model import LogisticRegression\nfrom collections import Counter\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.preprocessing import OneHotEncoder, LabelEncoder\nfrom sklearn.manifold import TSNE\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, plot_confusion_matrix\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","69fe8c5e":"SHOW_DATA = 15                \nPERCISION = 5                \nSEED = 42\n\ndef cm_to_inch(value):\n    return value\/2.54\n\ndef nan_elements(df:pd.DataFrame):\n    \"info about NaN elements, in every column (in percentage)\"\n    return df.isna().sum()\/df.shape[0]*100\n\nSTOP_WORDS = nltk.corpus.stopwords.words()\nplt.rcParams[\"figure.figsize\"]=(cm_to_inch(15),cm_to_inch(10))\nDROP = False\npalette = [\"#ff0000\",\"#853939\",\"#4f0202\"]\ncolor_palette = sns.color_palette(palette)\ncolor_palette.as_hex()","ea89328b":"train_data = pd.read_csv(\"\/kaggle\/input\/mymusicalprefrences\/train.csv\").set_index(\"Id\", drop=True)\ntest_data = pd.read_csv(\"\/kaggle\/input\/mymusicalprefrences\/test.csv\")\n\ndf_train = train_data.copy(deep=True) \ndf_test = pd.read_csv(\"\/kaggle\/input\/mymusicalprefrences\/test.csv\").set_index(\"Id\", drop=True)\n\ndf = pd.concat([df_train, df_test], axis=0)\n\ntrain_data.head(5)","e7251573":"display(df.info())\ndisplay(df.shape)","5d853154":"msno.matrix(df,color=color_palette[-1])","594ba94b":"COL_ID = \"Id\"                 \nCOL_CATEGORY = \"Category\"          \nCOL_ARTIST = \"Artists\"         \nCOL_TRACK = \"Track\"               \nCOL_VERSION = \"Version\"            \nCOL_DURATION = \"Duration\"            \nCOL_ARTISTS_GENRES = \"Artists_Genres\"     \nCOL_ALBUM = \"Album\"              \nCOL_RELEASE_YEAR = \"Release_year\"       \nCOL_ALBUM_TYPE = \"Album_type\"        \nCOL_LABELS = \"Labels\"             \nCOL_KEY = \"Key\"                 \nCOL_BPM = \"BPM\"                \nCOL_VOCAL = \"Vocal \"              \nCOL_COUNTRY = \"Country\"            \nCOL_ENERGY = \"Energy\"             \nCOL_DANCEBILITY = \"Dancebility\"        \nCOL_HAPPINESS = \"Happiness\"     ","44fc5603":"BLACK_LIST = []","1626458c":"df[COL_CATEGORY] = df[COL_CATEGORY].fillna(\"None\").replace({0:\"Dislike\",1:\"Like\"})","5e21cf9c":"categorical_features = {COL_ARTIST,COL_TRACK,COL_VERSION,COL_ARTISTS_GENRES,COL_ALBUM,COL_ALBUM_TYPE,COL_LABELS,COL_VOCAL,COL_COUNTRY,COL_KEY}\nnumerical_features = {COL_DURATION,COL_RELEASE_YEAR,COL_BPM,COL_ENERGY,COL_DANCEBILITY,COL_HAPPINESS}\ndisplay(df[categorical_features].head())\ndisplay(df[numerical_features].head())\ndisplay(df[numerical_features].describe())","cc11421c":"feature = \"Artists\"\ndd = df[feature].value_counts(dropna=False)\nprint(dd)","55f64ce0":"def many_to_several(feature, min_percent):\n    genres_dict = {}\n    for obj in df[feature]:\n        genres = [\"other\"]\n        if '|' in obj:\n            genres = obj.split(\"|\")\n        else:\n            genres[0] = obj\n        for genre in genres:\n            if \" \" in genre and feature == \"Labels\":\n                genre = genre.split(\" \")[0]\n            genres_dict[genre] = genres_dict.setdefault(genre, 0) + 1\n    \n    all_gen = 0\n    for key,value in genres_dict.items():\n        all_gen = all_gen + value\n    for key,value in genres_dict.items():\n        genres_dict[key] = (value\/all_gen)*100.0\n\n    genres_mas = []\n    for key,value in genres_dict.items():\n        if value > min_percent:\n            genres_mas.append(key)\n\n    genres_dict_tr = {}\n    for obj in df_train[feature]:\n        genres = [\"other\"]\n        if '|' in obj:\n            genres = obj.split(\"|\")\n        else:\n            genres[0] = obj\n        for genre in genres:\n            if \" \" in genre and feature == \"Labels\":\n                genre = genre.split(\" \")[0]\n            genres_dict_tr[genre] = genres_dict_tr.setdefault(genre, 0) + 1\n\n    genres_mas_tr = []        \n    for key,value in genres_dict_tr.items():\n            genres_mas_tr.append(key)\n\n    genres_dict_ts = {}\n    for obj in df_test[feature]:\n        genres = [\"other\"]\n        if '|' in obj:\n            genres = obj.split(\"|\")\n        else:\n            genres[0] = obj\n        for genre in genres:\n            if \" \" in genre and feature == \"Labels\":\n                genre = genre.split(\" \")[0]\n            genres_dict_ts[genre] = genres_dict_ts.setdefault(genre, 0) + 1\n\n    genres_mas_ts = []\n    for key,value in genres_dict_ts.items():\n            genres_mas_ts.append(key)\n\n\n    for genre in genres_mas:\n        if genre not in genres_mas_tr or genre not in genres_mas_ts:\n            genres_mas.pop(genres_mas.index(genre))\n\n    print(genres_mas)\n    \n    return genres_mas","20bc051f":"genres_mas = many_to_several(\"Artists_Genres\", 4.9)","5ac35e93":"feature = \"Labels\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\nlabel_mas = many_to_several(\"Labels\", 1)","59f3c6f0":"feature = \"Artists\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\nartists_mas = many_to_several(\"Artists\", 1.4)","4b6f193d":"feature = \"Album\"\ndf[feature] = df[feature].replace(np.nan,\"N\/A\")\ndf_train[feature] = df_train[feature].replace(np.nan,\"N\/A\")\ndf_test[feature] = df_test[feature].replace(np.nan,\"N\/A\")\nalbum_mas = many_to_several(\"Album\", 0.7)","8c42729e":"def modif_column_string(feature, lfun):\n    df_train[feature] = df_train[feature].replace(np.nan,\"other\")\n    df_train[feature] = df_train[feature].map(lambda obj: lfun(obj))\n    df_test[feature] = df_test[feature].replace(np.nan,\"other\")\n    df_test[feature] = df_test[feature].map(lambda obj: lfun(obj))","bd1b6f4e":"def modif_column_float(feature, lfun):\n    new_feature = feature + \"_Classes\"\n    \n    df_train[new_feature] = df_train[feature].replace(np.nan, df[feature].mean())\n    df_train[new_feature] = df_train[new_feature].map(lambda obj: lfun(obj))\n    df_test[new_feature] = df_test[feature].replace(np.nan, df[feature].mean())\n    df_test[new_feature] = df_test[new_feature].map(lambda obj: lfun(obj))","5a800c12":"def ret_bounds(value, bounds_l, bounds_r, parts, rets):\n    for part in range(0, len(parts), 1):\n        patch = (bounds_r[part] - bounds_l[part])\/parts[part]\n        for i in range(0, parts[part], 1):\n            if value > bounds_l[part] and value <= bounds_l[part]+patch:\n                return rets[part] + \"_\" + str(i)\n            else:\n                bounds_l[part] = bounds_l[part] + patch\n    return \"other\"","352a5a5d":"def artists_to_classes(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n    \n    temp = 0\n    final_genre = \"\"\n    for ar_ge in artists_genres_split:\n        if ar_ge in artists_mas:\n            return ar_ge\n            \n    if final_genre == \"\":\n        return \"other\"\n    else:\n        return final_genre","4fb86d03":"modif_column_string(feature=\"Artists\", lfun=artists_to_classes)\ndf_test[\"Artists\"].value_counts()","bcd07473":"def duration_to_classes(num):\n    bounds_l = [100000.0, 170000.0, 240000.0, 300000.0, 350000.0]\n    bounds_r = [170000.0, 240000.0, 300000.0, 350000.0, 1000000.0]\n    parts = [1,4,3,1,1]\n    rets = [\"low\",\"not_so_low\",\"middle\",\"not_so_high\",\"high\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","edc0ebff":"modif_column_float(feature=\"Duration\", lfun=duration_to_classes)\ndf_test[\"Duration_Classes\"].value_counts(normalize=True) * 100","1242e264":"def artists_genres_diffraction(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n    \n    temp = 0\n    final_genre = \"\"\n    for ar_ge in artists_genres_split:\n        if ar_ge in genres_mas:\n            return ar_ge\n            \n    if final_genre == \"\":\n        return \"other\"\n    else:\n        return final_genre","74624d80":"modif_column_string(feature=\"Artists_Genres\", lfun=artists_genres_diffraction)\ndf_train[\"Artists_Genres\"].value_counts()","81bc31c4":"df_test[\"Artists_Genres\"].value_counts()","ee97522b":"def album_to_classes(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n        \n    for ar_ge in artists_genres_split:\n        if ar_ge in album_mas:\n            return ar_ge     \n    return \"other\"","1a75ad1a":"modif_column_string(feature=\"Album\", lfun=album_to_classes)\ndf_test[\"Album\"].value_counts()","ba40cfc5":"def year_to_classes(num):\n    if num <= 2005.0:\n        return \"old\"\n    elif num > 2005.0 and num <= 2009.0:\n        return \"old_middle\"\n    elif num > 2009.0 and num <= 2013.0:\n        return \"old_middle\"\n    elif num > 2013.0 and num <= 2015.0:\n        return \"new_1\"\n    elif num > 2015.0 and num <= 2017.0:\n        return \"new_2\"\n    elif num > 2017.0 and num <= 2019.0:\n        return \"new_3\"\n    elif num > 2019.0:\n        return \"new_4\"","200fc22c":"modif_column_float(feature=\"Release_year\", lfun=year_to_classes)\ndf_test[\"Release_year_Classes\"].value_counts(normalize=True) * 100","22180e7b":"def labels_to_classes(artists_genres):\n    artists_genres_split = [\"other\"]\n    if '|' in artists_genres:\n        artists_genres_split = artists_genres.split(\"|\")\n    else:\n        artists_genres_split[0] = artists_genres\n    \n    temp = 0\n    final_genre = \"\"\n    for ar_ge in artists_genres_split:\n        if ar_ge in label_mas:\n            return ar_ge\n            \n    if final_genre == \"\":\n        return \"other\"\n    else:\n        return final_genre","c5d6751e":"modif_column_string(feature=\"Labels\", lfun=labels_to_classes)\ndf_test[\"Labels\"].value_counts()","41da3fa7":"def key_diffraction(obj):\n    return obj[0]","2296a3e6":"modif_column_string(feature=\"Key\", lfun=key_diffraction)\ndf_test[\"Key\"].value_counts()","2b325a97":"def bpm_to_classes(num):\n    bounds_l = [0.0, 100.0, 125.2]\n    bounds_r = [100.0, 125.2, 200.0]\n    parts = [1,2,2]\n    rets = [\"low\",\"middle\",\"high\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","9340be7e":"modif_column_float(feature=\"BPM\", lfun=bpm_to_classes)\ndf_test[\"BPM_Classes\"].value_counts()","33ce2b9d":"def country_diffraction(obj):\n    countries = [\"other\"]\n    if '|' in obj:\n        countries = obj.split(\"|\")\n    else:\n        countries[0] = obj\n        \n    for country in countries:\n        if country == \"USA\" or country == \"RUS\" or country == \"GB\":\n            return country\n    return \"other\"","84c5c74f":"modif_column_string(feature=\"Country\", lfun=country_diffraction)\ndf_test[\"Country\"].value_counts()","3dd871bc":"def energy_to_classes(num):\n    if num <= 40.0:\n        return \"1\"\n    elif num > 40.0 and num <= 60.0:\n        return \"2\"\n    elif num > 60.0 and num <= 80.0:\n        return \"3\"\n    elif num > 80.0:\n        return \"4\"","761bed7e":"modif_column_float(feature=\"Energy\", lfun=energy_to_classes)\ndf_train[\"Energy_Classes\"].value_counts(normalize=True) * 100","ddea8780":"def dancebility_to_classes(num):\n    bounds_l = [0.0, 40.0, 61.47, 72.4, 81.6]\n    bounds_r = [40.0, 61.47, 72.4, 81.6, 100]\n    parts = [1,2,2,2,1]\n    rets = [\"pancake\",\"wormy\",\"slicy\",\"wiggly\",\"dance_revolution\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","96482220":"modif_column_float(feature=\"Dancebility\", lfun=dancebility_to_classes)\ndf_train[\"Dancebility_Classes\"].value_counts(normalize=True) * 100","9dfecb0d":"def happiness_to_classes(num):\n    bounds_l = [0.0, 100\/3, 200\/3]\n    bounds_r = [100\/3, 200\/3, 100]\n    parts = [1,2,1]\n    rets = [\"bad\",\"so_so\",\"good\"]\n    return ret_bounds(num, bounds_l, bounds_r, parts, rets)","ca426e68":"modif_column_float(feature=\"Happiness\", lfun=happiness_to_classes)\ndf_test[\"Happiness_Classes\"].value_counts()","3a59bb0c":"# Agreed features\n\nfeatures = [\n            \"Happiness_Classes\",\n            \"Dancebility_Classes\",\n            \"Energy_Classes\",\n            \"Country\",\n            \"Key\",\n            \"Artists_Genres\",\n            \"Release_year_Classes\",\n            \"Duration_Classes\",\n            \"BPM_Classes\",\n#             \"Labels,\"\n#             \"Artists,\"\n#             \"Version,\"\n#             \"Album\"\n           ]\n\n# Accuracy is dropping if we use Labels, Artists, Version, Album","0d20692c":"y = df_train[\"Category\"]\n\nX = pd.get_dummies(df_train[features])\nX_test = pd.get_dummies(df_test[features])","4e031044":"df_test.columns","d662cb5b":"model = RandomForestClassifier(n_estimators=100, max_depth=10, random_state=1)\n# model = SVC()\n# model = CatBoostClassifier()\n\nmodel.fit(X, y)\npredictions = model.predict(X_test)\n\noutput = pd.DataFrame({'Id': test_data.Id, 'Category': predictions})\noutput.to_csv('submission.csv', index=False)","870c69c7":"X_train, Xtest, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=0)","724592e7":"model.fit(X_train, y_train)\npredictions = model.predict(Xtest)\n\nCM = confusion_matrix(y_test,predictions)\nCM","015f339d":"plot_confusion_matrix(model, Xtest, y_test)","b2c522d4":"ACC = (CM[0][0]+CM[1][1])\/((CM[0][0]+CM[0][1])+(CM[1][0]+CM[1][1]))\nACC","005176c0":"4-Album","b1220a09":"5-Release_year","d4f16247":"9-Country","15abb5d5":"Model\nFinal stage: fit model with features we created","dd59efce":"1- Artists","90a25166":"12-Happiness","a86c584e":"To check results we construct confusion matrix","e43d6198":"7-Key","5e38650c":"1.Import Data ","cd741046":"DataFrame creation","b5e6dfbe":"8-BMP","a9913a74":"Also we calculate accuracy","8d27489e":"6-Labels","a365b559":"2-Duration","162b5b15":"11-Dancebility","899ad0e8":"10-Energy","432799a5":"3-Artists_Genres"}}