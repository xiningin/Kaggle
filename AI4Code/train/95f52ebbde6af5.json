{"cell_type":{"46182808":"code","264d586f":"code","b97a8541":"code","9a85e7a3":"code","a863cc57":"code","40702704":"code","f55b4ae3":"code","6160d928":"code","f76d3aa0":"code","012a8a3b":"code","e1d782a5":"code","01c766a5":"code","49d42018":"code","b833184b":"code","963e673e":"code","74f5407f":"code","1509a71b":"code","32c8992a":"code","41137483":"code","fd0e8ac4":"code","d6510e0a":"code","5b109edb":"code","bd2fb6f6":"code","b3d2f10e":"code","eda8070f":"code","d23b8582":"code","b4c22c3b":"code","bf79a523":"code","383df1b9":"code","e141b5b2":"code","412ec392":"code","b094f647":"code","55bfa6e5":"code","3d133fe2":"code","6c6528c4":"code","b953adc0":"code","6a996280":"code","6cb0cfff":"code","787da774":"code","ccb48b18":"code","82493309":"code","2b8437a5":"code","875589c3":"code","d8291160":"code","d7dd1c91":"code","5a7e9901":"code","4f25ab50":"code","ab57d081":"code","2a3bc24e":"code","c0d32b4d":"code","89c75110":"code","e9f1b565":"code","ac9ea890":"code","9ffd54b9":"markdown","e4ecb523":"markdown","2e079faf":"markdown","a7e51944":"markdown","c77117db":"markdown","9b0aec45":"markdown","18e906e4":"markdown","83924eef":"markdown","01ff0e95":"markdown"},"source":{"46182808":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","264d586f":"!pip install sweetviz","b97a8541":"!pip install dexplot","9a85e7a3":"import pandas as pd\nimport numpy as np \n\n# Data Visualization Libraries\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport plotly\nimport plotly.express as px\nimport plotly.offline as py\nimport plotly.graph_objs as go\nfrom IPython.display import display, Markdown\nimport sweetviz as sv\nimport dexplot as dxp\n\n#hide warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n#display max columns of pandas dataframe\npd.set_option('display.max_columns', None)\n\nfrom sklearn.model_selection import train_test_split \nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import RandomizedSearchCV","a863cc57":"df_battle = pd.read_csv(\"..\/input\/game-of-thrones\/battles.csv\")\ndf_death = pd.read_csv(\"..\/input\/game-of-thrones\/character-deaths.csv\")\ndf_pred_1 = pd.read_csv(\"..\/input\/game-of-thrones\/character-predictions.csv\")\ndf_pred = df_pred_1.copy()","40702704":"df_battle.head(2)","f55b4ae3":"df_death.head(2)","6160d928":"df_pred.head(2)","f76d3aa0":"# Helper Function - Missing data check\ndef missing_data(data):\n    missing = data.isnull().sum()\n    available = data.count()\n    total = (missing + available)\n    percent = (data.isnull().sum()\/data.isnull().count()*100).round(4)\n    return pd.concat([missing, available, total, percent], axis=1, keys=['Missing', 'Available', 'Total', 'Percent']).sort_values(['Missing'], ascending=False)","012a8a3b":"missing_data(df_battle)","e1d782a5":"# Year-wise battles\nsns.countplot(df_battle['year'])\nplt.title('Yearwise battle summary')\nplt.show()","01c766a5":"# Win - Lose distribution\nsns.countplot(x='attacker_outcome',data = df_battle)\nplt.title('Win-Loss Distribution')\nplt.show()","49d42018":"dxp.count(val='attacker_king', data=df_battle, split = 'attacker_outcome', stacked=True,title='King w\/ most attacks')","b833184b":"dxp.count(val='defender_king', data=df_battle, split = 'attacker_outcome', stacked=True,title='King who defended the most')","963e673e":"# new column to count the alliance during an attack\ndf_battle['alliance_count'] = (4 - df_battle[[\"attacker_1\", \"attacker_2\", \"attacker_3\", \"attacker_4\"]].isnull().sum(axis = 1))","74f5407f":"dxp.count(val='alliance_count', data=df_battle, split = 'attacker_outcome', stacked=True,title='Alliance Count vs Battle Outcome')","1509a71b":"dxp.count(val='attacker_king', data=df_battle, split = 'alliance_count', stacked=True,title='Alliance Count vs Attacker King')","32c8992a":"# new column to count the alliance while defending\ndf_battle['alliance_count_defend'] = (4 - df_battle[[\"defender_1\", \"defender_2\", \"defender_3\", \"defender_4\"]].isnull().sum(axis = 1))","41137483":"dxp.count(val='alliance_count_defend', data=df_battle, split = 'attacker_outcome', stacked=True,title='Alliance Count vs Battle Outcome')","fd0e8ac4":"dxp.count(val='defender_king', data=df_battle, split = 'alliance_count', stacked=True,title='Alliance Count vs Defender King')","d6510e0a":"dxp.count(val='battle_type', data=df_battle, split = 'attacker_outcome', stacked=True,title='Battle Type vs Battle Outcome')","5b109edb":"dxp.count(val='battle_type', data=df_battle, split = 'attacker_king',title='Battle Type vs Attacked King')","bd2fb6f6":"dxp.count(val='battle_type', data=df_battle, split = 'summer',title='Battle Type vs Season', stacked=True)","b3d2f10e":"dxp.count(val='summer', data=df_battle, split = 'attacker_outcome',title='Battle Outcome vs Season', stacked=True)","eda8070f":"fig = px.bar(df_battle, \n             x=df_battle['attacker_king'].fillna(\"Other\"),\n             y=df_battle['attacker_size'].fillna(0),\n             orientation='v',\n             height=800,\n             title='Battle outcome vs Army size',\n            color=df_battle['attacker_outcome'].fillna(\"Unknown\"))\nfig.show()","d23b8582":"#No of deaths vs Year\nplt.figure(figsize=(15,10))\nplt.subplot(2,1,1)\nsns.countplot(df_battle['year'])\nplt.xticks(fontsize=16)\nplt.yticks(fontsize=16)\nplt.xlabel('Year', fontsize=18)\nplt.ylabel('Count', fontsize=18)\nplt.title('No of deaths vs Year',fontsize=20)\nplt.show()\n\n#No of deaths vs Gender\nplt.figure(figsize=(15,10))\nplt.subplot(2,1,2)\nsns.countplot(df_death['Gender'])\nplt.title('Gender vs Death', fontsize=20)\nplt.xlabel('Gender', fontsize=18)\nplt.ylabel('Count', fontsize=18)\nplt.xticks(np.arange(2),('Female','Male'),fontsize=16)\nplt.yticks(fontsize=16)\nplt.show()","b4c22c3b":"#No of deaths vs Year\nplt.figure(figsize=(15,10))\nplt.subplot(2,1,1)\nsns.countplot(df_death['Death Year'])\nplt.xticks(fontsize=16)\nplt.yticks(fontsize=16)\nplt.xlabel('Year', fontsize=18)\nplt.ylabel('Count', fontsize=18)\nplt.title('No of deaths vs Year',fontsize=20)\nplt.show()\n\n#No of deaths vs Gender\nplt.figure(figsize=(15,10))\nplt.subplot(2,1,2)\nsns.countplot(df_death['Gender'])\nplt.title('Gender vs Death', fontsize=20)\nplt.xlabel('Gender', fontsize=18)\nplt.ylabel('Count', fontsize=18)\nplt.xticks(np.arange(2),('Female','Male'),fontsize=16)\nplt.yticks(fontsize=16)\nplt.show()","bf79a523":"# Data cleaning for character predictions dataset\ncult = {\n    'Summer Islands': ['summer islands', 'summer islander', 'summer isles'],\n    'Ghiscari': ['ghiscari', 'ghiscaricari',  'ghis'],\n    'Asshai': [\"asshai'i\", 'asshai'],\n    'Lysene': ['lysene', 'lyseni'],\n    'Andal': ['andal', 'andals'],\n    'Braavosi': ['braavosi', 'braavos'],\n    'Dornish': ['dornishmen', 'dorne', 'dornish'],\n    'Myrish': ['myr', 'myrish', 'myrmen'],\n    'Westermen': ['westermen', 'westerman', 'westerlands'],\n    'Westerosi': ['westeros', 'westerosi'],\n    'Stormlander': ['stormlands', 'stormlander'],\n    'Norvoshi': ['norvos', 'norvoshi'],\n    'Northmen': ['the north', 'northmen'],\n    'Free Folk': ['wildling', 'first men', 'free folk'],\n    'Qartheen': ['qartheen', 'qarth'],\n    'Reach': ['the reach', 'reach', 'reachmen'],\n}\n\ndef get_cult(value):\n    value = value.lower()\n    v = [k for (k, v) in cult.items() if value in v]\n    return v[0] if len(v) > 0 else value.title()","383df1b9":"from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\ninit_notebook_mode(connected=True)\ndf_pred.loc[:, \"culture\"] = [get_cult(x) for x in df_pred.culture.fillna(\"\")]\ndata = df_pred.groupby([\"culture\", \"isAlive\"]).count()[\"S.No\"].unstack().copy(deep = True)\ndata.loc[:, \"total\"]= data.sum(axis = 1)\np = data[data.index != \"\"].sort_values(\"total\")[[0, 1]]\np.reset_index(level=0, inplace=True)\np.rename(columns={0: 'dead', 1: 'alive'}, inplace=True)\np = p.fillna(0)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(x=p['culture'],\n                     y=p['dead'],\n                     name=\"Dead\"))\nfig.add_trace(go.Bar(x=p['culture'],\n                     y=p['alive'],\n                     name=\"Alive\"))\n\nfig.update_layout(\n    xaxis = dict(\n        tickmode = 'array',\n        tickvals = p['culture'])\n)","e141b5b2":"df_pred.columns","412ec392":"#Data prep\n\ndf_pred.loc[:, \"culture\"] = [get_cult(x) for x in df_pred.culture.fillna(\"\")]\ndf_pred.loc[:, \"title\"] = pd.factorize(df_pred.title)[0]\ndf_pred.loc[:, \"culture\"] = pd.factorize(df_pred.culture)[0]\ndf_pred.loc[:, \"mother\"] = pd.factorize(df_pred.mother)[0]\ndf_pred.loc[:, \"father\"] = pd.factorize(df_pred.father)[0]\ndf_pred.loc[:, \"heir\"] = pd.factorize(df_pred.heir)[0]\ndf_pred.loc[:, \"house\"] = pd.factorize(df_pred.house)[0]\ndf_pred.loc[:, \"spouse\"] = pd.factorize(df_pred.spouse)[0]","b094f647":"df_pred['houseSize'] = df_pred['house'].map(df_pred['house'].value_counts())\ndf_pred['houseAlive'] = df_pred['house'].map(df_pred['house'].value_counts())\ndf_pred['houseDead'] = df_pred['house'].map(df_pred['house'].value_counts())\ndf_pred['houseDeathRate'] = df_pred['houseDead']\/df_pred['houseSize']","55bfa6e5":"df_pred.drop([\"name\", \"alive\", \"pred\", \"plod\", \"isAlive\", \"dateOfBirth\", \"DateoFdeath\",\"S.No\"], 1, inplace = True)\ndf_pred.columns = map(lambda x: x.replace(\".\", \"\").replace(\"_\", \"\"), df_pred.columns)\ndf_pred.fillna(value = -1, inplace = True)","3d133fe2":"df_pred.head()","6c6528c4":"fig = go.Figure(\n    data=[go.Bar(x=df_pred['actual'].unique(), y=df_pred['actual'].value_counts())],\n    layout=go.Layout(\n        title=go.layout.Title(text=\"Class Distribution\")\n    )\n)\n\nfig.show()","b953adc0":"fig = go.Figure(data=[go.Pie(labels=['Alive','Dead'], values=df_pred['actual'].value_counts())])\nfig.update_layout(\n    title_text=\"Class Distribution\")\nfig.show()","6a996280":"# Helper function for ROC curve and dataset\n\ndef plot_roc_curve(fpr, tpr):\n    plt.plot(fpr, tpr, color='orange', label='ROC')\n    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('ROC Curve - ' + str_1)\n    plt.legend()\n    plt.show()\n\ndef plot_data(X,Y):\n    plt.scatter(X[Y == 0,0], X[Y == 0, 1], label=\"Class 0-Non Fraud\", alpha=0.4, c='b')\n    plt.scatter(X[Y == 1,0], X[Y == 1, 1], label=\"Class 1-Fraud\", alpha=0.4, c='g')\n    plt.legend()\n    \n    return plt.show()","6cb0cfff":"df_pred.describe()","787da774":"y = df_pred.actual.values\nX = df_pred.copy(deep=True)\nX.drop([\"actual\"], 1, inplace = True)","ccb48b18":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 0)","82493309":"from sklearn.feature_selection import mutual_info_classif\nmutual_infos = pd.Series(data=mutual_info_classif(X, y, discrete_features=False, random_state=1), index=X.columns)\nmutual_infos.sort_values(ascending=False).plot(kind='bar',figsize = (12,6))","2b8437a5":"# logistic regression w\/o handling class imbalance\n\nfrom sklearn.linear_model import LogisticRegression \nfrom sklearn.metrics import confusion_matrix, classification_report \nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score\n\nstr_1 = 'Logistic Regression w\/o handling class imbalance'\n\nlr = LogisticRegression() \n\n# train the model on train set \nlr.fit(X_train, y_train.ravel()) \n  \npredictions = lr.predict(X_test) \n  \n# print classification report \nprint(classification_report(y_test, predictions))","875589c3":"# Predict probabilities for test data\nprobs_lr = lr.predict_proba(X_test)\n# Probabilities of the positive class\nprobs_lr_pos = probs_lr[:, 1]\n# AUC Score\nauc = roc_auc_score(y_test, probs_lr_pos)\nprint('AUC: %.2f' % auc)\n# ROC Curve\nfpr, tpr, thresholds = roc_curve(y_test, probs_lr_pos)\n# Plot ROC Curve \nplot_roc_curve(fpr, tpr)","d8291160":"from sklearn.metrics import f1_score, matthews_corrcoef\nmathews_corr_lr = matthews_corrcoef(y_test, predictions) \nprint(\"Matthews correlation coefficient for LR model is {:.3f}\".format(mathews_corr_lr))","d7dd1c91":"# Random forest model  w\/o handling class imbalance\nfrom sklearn.ensemble import RandomForestClassifier \nrfc = RandomForestClassifier()\n\n#fit the model\nrfc.fit(X_train, y_train.ravel()) \n\npredictions_rfc = rfc.predict(X_test)\n\n# print classification report \nprint(classification_report(y_test, predictions_rfc))","5a7e9901":"# Predict probabilities for test data\nprobs_rfc = rfc.predict_proba(X_test)\n# Probabilities of the positive class\nprobs_rfc_pos = probs_rfc[:, 1]\n# AUC Score\nauc_rfc = roc_auc_score(y_test, probs_rfc_pos)\nprint('AUC: %.2f' % auc_rfc )\n# ROC Curve\nfpr_rfc, tpr_rfc, thresholds_rfc = roc_curve(y_test, probs_rfc_pos)\n# Plot ROC Curve \nplot_roc_curve(fpr_rfc, tpr_rfc)","4f25ab50":"mathews_corr_rfc = matthews_corrcoef(y_test, predictions_rfc) \nprint(\"Matthews correlation coefficient for RF model is {:.3f}\".format(mathews_corr_rfc))","ab57d081":"import keras\nfrom keras.models import Sequential\nfrom keras import backend as K\nfrom keras.layers import Activation\nfrom keras.layers import BatchNormalization\nfrom keras.layers.core import Dense\nfrom keras.layers import Dropout\nfrom keras.optimizers import Adam\nfrom keras.metrics import categorical_crossentropy\n\nn_inputs = X_train.shape[1]\n\n\n# define model\nmodel= Sequential()\nmodel.add(Dense(n_inputs, input_shape=(n_inputs, ), activation='relu'))\nmodel.add(Dense(32, activation='relu'))\nmodel.add(BatchNormalization())\nmodel.add(Dropout(0.25))\nmodel.add(Dense(2, activation='softmax'))","2a3bc24e":"model.summary()","c0d32b4d":"model.compile(Adam(lr=0.0001), loss='sparse_categorical_crossentropy', metrics=['sparse_categorical_accuracy'])","89c75110":"history = model.fit(X_train, y_train, validation_split=0.2, batch_size=10, epochs=50, shuffle=True, verbose=2)","e9f1b565":"# summarize history for accuracy\nplt.plot(history.history['sparse_categorical_accuracy'])\nplt.plot(history.history['val_sparse_categorical_accuracy'])\nplt.title('model accuracy - BS= 10')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","ac9ea890":"# summarize history for loss\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss - BS=10')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'validation'], loc='upper left')\nplt.show()","9ffd54b9":"### Insights:\n* Alliance during defence certainly helps to win","e4ecb523":"### Evaluation Metrics:-\n* Accuracy - The percent of samples that are correctly classified\n* Precision - The percent of predictions that were correct. Formula = TP\/(TP + FP)\n* Recall - The percent of the positive fraud cases that were caught. Formula = TP\/(TP+FN)\n* Precidion and Recall are inversely proportional.As precsion increases recall drops\n* F1-score - The harmonic mean of the precision and recall. F1 = 2((PrecisionRecall)\/(Precision+Recall))\n* TP = True Positives | FP = False Positives | FN = False Negatives | TN = true Negatives\n* Matthews Correlation Coefficient (MCC) is the correlation coefficient between true class and predicted class.\n* MCC = TPxTN-FPxFN \/ SQRT[(TP+FP)(TP+FN)(TN+FP)(TN+FN)]\n* Higher the correlation between true and predicted values the better the prediction will be\n* Reference:\n* https:\/\/en.wikipedia.org\/wiki\/Matthews_correlation_coefficient\n* https:\/\/towardsdatascience.com\/the-best-classification-metric-youve-never-heard-of-the-matthews-correlation-coefficient-3bf50a2f3e9a","2e079faf":"### Insights:\n* Mutual information between two random variables is a non-negative value, which measures the dependency between the variables\n* It is equal to zero if and only if two random variables are independent and higher values mean higher dependency\n* Top three most correlated features are house, popularity and numDeadRelations ","a7e51944":"# Loading Dataset","c77117db":"# EDA","9b0aec45":"### Insights:\n* Winning chances are high with ambust and siege type battles\n* All ambush battles are organised in summer\n* Most number of battles are won during summer\n* Army size is not directly related with winning but strategy, attack type and strong defence matters","18e906e4":"### Insights:\n* Alliances while attacking has an advantage but not significant","83924eef":"### Insights:\n* Year 299 had seen the highest number of deaths\n* Most dead population are male","01ff0e95":"### Insights:\n* Joffrey\/Tommen Baratheon is the king who had attacked the most and has highest ratio of win when attacks\n* Robb Stark is the king who had defended the most and has highest ratio of win when defends"}}