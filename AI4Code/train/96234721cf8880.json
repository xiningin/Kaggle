{"cell_type":{"6d243e3c":"code","5d414944":"code","ed188f52":"code","e72247e9":"code","1c1eff9f":"code","55fa93dc":"code","3041ec03":"code","f51823b6":"code","8099d68c":"code","d1412bc5":"code","40c81a23":"code","e0f12bb0":"code","93f1b406":"code","84f2e105":"code","ed33f28a":"code","a050ad45":"code","f56080e3":"code","5c95189e":"code","dad6f188":"code","74c60b7e":"code","29b93e8d":"code","5afac38b":"code","4077391e":"code","32c11ee2":"code","b1b7358f":"code","1637ebf4":"code","81bb7dfd":"code","e1c4e055":"code","b5ec180b":"code","096cfa0a":"code","da50439d":"code","6c95915c":"code","66facced":"code","d2e23eda":"code","0d6ac7ba":"code","0cbf399a":"code","5fc8b264":"code","3fd346c9":"code","c300265c":"code","49f904ba":"code","7e3a2434":"code","0d9266f8":"code","40a6aad3":"code","aa2b888a":"code","cac26510":"code","c2bd690c":"code","10f3c4dd":"markdown","b81fd18e":"markdown","7833d0cf":"markdown","472cc535":"markdown","931c32fc":"markdown","eaf789c7":"markdown","dc2f6b98":"markdown","faec6d8f":"markdown","8cd43646":"markdown","024e9b6c":"markdown","fcd0e187":"markdown","64348215":"markdown","f64d517c":"markdown","ccf7448e":"markdown","06538102":"markdown","97adbabf":"markdown","8060b8f4":"markdown","3b7dd94b":"markdown","87f4e1e5":"markdown","18115b22":"markdown","ff034d4a":"markdown","1c33143d":"markdown","bd69fa1a":"markdown","5ce99a8c":"markdown","c40068b4":"markdown","e842ce16":"markdown","e55c9237":"markdown","726682a6":"markdown","eb33ba14":"markdown","83084a3a":"markdown","56035155":"markdown","f2def54f":"markdown","c6277252":"markdown","13fefda2":"markdown","a9f1cd96":"markdown"},"source":{"6d243e3c":"import numpy as np\nimport pandas as pd\n\nimport seaborn as sns\nsns.set()\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'svg' \n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","5d414944":"def my_confusion_matrix(y_test, y_pred, title):\n    from sklearn.metrics import confusion_matrix, accuracy_score\n    cm_df = pd.DataFrame(data=confusion_matrix(y_test, y_pred),\n                         index=['Alliance', 'Horde'], \n                         columns=['Alliance', 'Horde'])\n    plt.figure(figsize=(5.5,4))\n    sns.heatmap(cm_df, annot=True, cmap='Blues')\n    plt.title(title + '\\nAccuracy:{:1.1f}%'.format(accuracy_score(y_test, y_pred) * 100))\n    plt.ylabel('True winner')\n    plt.xlabel('Predicted winner')\n    plt.show()\n    \ndef my_bar_plot(ax, name, data, x, y, xlabel='', ylabel='', orientation='horizontal',\n                palette='icefire', format_spec='{:1.2f}%'):\n    ax.set_title(name)\n    sns.barplot(x=x, y=y, data=data, ax=ax, palette=palette)\n    ax.set(xlabel=xlabel, ylabel=ylabel)\n    \n    if orientation == 'horizontal':\n        for p in ax.patches:\n            text = p.get_width()\n            ax.text(x=p.get_x() + p.get_width() \/ 2., \n                y=p.get_y() + p.get_height() * 0.75,\n                s=format_spec.format(text),\n                ha=\"center\",\n                size=\"small\",\n                color='white')\n        for tick in ax.get_yticklabels():\n            tick.set_color(class_colormap[tick.get_text()])\n    \n    elif orientation == 'vertical':\n        for p in ax.patches:\n            text = p.get_height()\n            ax.text(x=p.get_x() + p.get_width() \/ 2., \n                y=p.get_y() + p.get_height() \/ 2.,\n                s=format_spec.format(text),\n                ha=\"center\",\n                size=\"small\",\n                color='white')\n        for tick in ax.get_xticklabels():\n            tick.set_color(class_colormap[tick.get_text()])\n        ax.set_xticklabels(ax.get_xticklabels(), rotation=90)","ed188f52":"import os\nprint('%-32s %d' % ('Input files available:', len(os.listdir('..\/input'))))\nfor i in range(32 + len(str(len(os.listdir('..\/input'))))):\n    print('-',end='')\nprint('-')\nfor file in os.listdir(\"..\/input\/\"):\n    unit = 'MB'\n    size = os.stat('..\/input\/' + file).st_size\n    size = round(size \/ 1024, 2)\n    unit = 'KB'\n    print('%-25s %6.2f %2s' % (file, size, unit))","e72247e9":"wowbgs = pd.read_csv('..\/input\/wowbgs2.csv')\nwowgil = pd.read_csv('..\/input\/wowgil2.csv')\nwowtk = pd.read_csv('..\/input\/wowtk2.csv')\nwowsm = pd.read_csv('..\/input\/wowsm2.csv')\nwowwg = pd.read_csv('..\/input\/wowwg2.csv')","1c1eff9f":"wowbgs.fillna(0, inplace=True)\nwowbgs.drop(['Lose'], axis=1, inplace=True)\nwowbgs.rename(columns={'Rol': 'Role'}, inplace=True)\n\nwowgil.fillna(0, inplace=True)\nwowgil.drop(['Lose'], axis=1, inplace=True)\nwowbgs.rename(columns={'Rol': 'Role'}, inplace=True)\n\nwowtk.fillna(0, inplace=True)\nwowtk.drop(['Lose'], axis=1, inplace=True)\nwowbgs.rename(columns={'Rol': 'Role'}, inplace=True)\n\nwowsm.fillna(0, inplace=True)\nwowsm.drop(['Lose'], axis=1, inplace=True)\nwowbgs.rename(columns={'Rol': 'Role'}, inplace=True)\n\nwowwg.fillna(0, inplace=True)\nwowwg.drop(['Lose'], axis=1, inplace=True)\nwowbgs.rename(columns={'Rol': 'Role'}, inplace=True)\n\nbgs_dict = {'AB': 'Arathi Basin',\n            'BG': 'Battle for Gilneas',\n            'DG': 'Deepwind Gorge',\n            'ES': 'Eye of the Storm',\n            'SA': 'Strand of the Ancients',\n            'SM': 'Silvershard Mines',\n            'SS': 'Seething Shore',\n            'TK': 'Temple of Kotmogu',\n            'TP': 'Twin Peaks',\n            'WG': 'Warsong Gulch'}\nwowbgs['Battleground'].replace(bgs_dict, inplace=True)\n","55fa93dc":"class_names = sorted(wowbgs['Class'].unique())\nmatches_num = len(wowbgs['Code'].unique())\n\nprint('Dataframe shape:', wowbgs.shape)\nprint('Information on', matches_num, 'matches available.')\nwowbgs.head()","3041ec03":"faction_class_mix = wowbgs.pivot_table(values='Honor',\n                                       index='Faction',\n                                       columns='Class',\n                                       aggfunc=lambda x: x.value_counts().count()).astype(int)\nfaction_class_mix.rename({'Death Knight': 'Death\\nKnight', 'Demon Hunter': 'Demon\\nHunter'}, axis=1, inplace=True)\n_, ax = plt.subplots(1, 1, figsize=(16.5, 2.25))\nsns.heatmap(faction_class_mix, annot=True, cmap='Blues', fmt='g', ax=ax)\nplt.title('Faction\/Class Comparison')\nax.set_xticklabels(ax.get_xticklabels(), rotation=0)\nax.set_yticklabels(ax.get_yticklabels(), va='center')\nax.set(ylabel='', xlabel='')\nplt.show()","f51823b6":"_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nax.set_title(\"Roles Popularity\")\nsns.countplot(x='Role',\n              data=wowbgs,\n              ax=ax,\n              palette='icefire_r',\n              order = wowbgs['Role'].value_counts().index)\nax.set(xlabel='', ylabel='Frequency')\n\n#Adding percentage to the patches\ntotal = float(len(wowbgs))\nfor p in ax.patches:\n    width = p.get_height()\n    ax.text(x=p.get_x() + p.get_width()\/2., \n              y=p.get_y() + p.get_height()*0.45,\n              s='{:1.2f}%'.format(width\/total* 100),\n              ha=\"center\",\n              size=\"small\",\n              color='white')   \nplt.show()","8099d68c":"heal_classes = sorted(list(wowbgs[wowbgs['Role'] == 'heal']['Class'].unique()))\ndps_classes = sorted(list(wowbgs[wowbgs['Role'] == 'dps']['Class'].unique()))\n\nprint('Healer classes:', *(heal_classes), sep='\\n')\nprint('-' * 12)\nprint('DPS classes:', *(dps_classes), sep='\\n')","d1412bc5":"_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nax.set_title(\"Classes Popularity\")\nsns.countplot(y='Class',\n              data=wowbgs,\n              ax=ax,\n              palette='icefire',\n              order = wowbgs['Class'].value_counts().index)\nax.set(ylabel='', xlabel='Frequency')\n\n#Adding percentage to the patches\ntotal = float(len(wowbgs))\nfor p in ax.patches:\n    width = p.get_width()\n    ax.text(x=p.get_x() + p.get_width() \/ 2., \n              y=p.get_y() + p.get_height() * 0.75,\n              s='{:1.2f}%'.format(width\/total * 100),\n              ha=\"center\",\n              size=\"small\",\n              color='white')\n\n#Classes names color map\nheal_dict, dps_dict = {x: 'darkblue' for x in heal_classes}, {x: 'darkred' for x in dps_classes}\nclass_colormap = {**dps_dict, **heal_dict}\n\nfor tick in ax.get_yticklabels():\n    tick.set_color(class_colormap[tick.get_text()])\nplt.show()","40c81a23":"class_winrate = round(wowbgs.groupby(['Class'], as_index=False)['Win'].mean().sort_values(by=['Win'], ascending=False), 4)\nclass_winrate['Win'] *= 100\n\n_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nmy_bar_plot(ax, name=\"Classes Win Rate\", data=class_winrate, x='Win',\n            y='Class', orientation='horizontal', format_spec='{:1.2f}%')\nplt.show()","e0f12bb0":"_, ax = plt.subplots(1, 1, figsize=(8, 2.5))\nax.set_title(\"Heal\/DPS Classes\")\nsns.countplot(x='Class',\n              hue='Role',\n              data=wowbgs[wowbgs['Class'].isin(heal_classes)],\n              ax=ax,\n              palette='icefire',\n              order=wowbgs[wowbgs['Class'].isin(heal_classes)]['Class'].value_counts().index)\nax.set(ylabel='Frequency', xlabel='')\n\ndps_patches = ax.patches[:5]\nheal_patches = ax.patches[5:]\npatches = list(zip(dps_patches, heal_patches ))\n\nfor p in patches:\n    height = [p[i].get_height() for i in range(2)]\n    total = sum(height)\n    for i in range(2):\n        ax.text(x=p[i].get_x() + p[i].get_width() \/ 2., \n              y=p[i].get_y() + p[i].get_height() * 0.45,\n              s='{:1.1f}%'.format(height[i] \/ total * 100),\n              ha=\"center\",\n              size=\"small\",\n              color='white')\n    \nplt.show()","93f1b406":"mean_dd = round(wowbgs.groupby(['Class'], as_index=False)['DD'].mean().sort_values(by=['DD'], ascending=False))\n\n_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nmy_bar_plot(ax, name=\"Average Damage Dealt\/Match by Classes\", data=mean_dd, x='DD',\n            y='Class', orientation='horizontal', format_spec='{:1.0f}')\nplt.show()","84f2e105":"median_kb = round(wowbgs.groupby(['Class'], as_index=False)['KB'].median().sort_values(by=['KB'], ascending=False))\nmedian_hk = round(wowbgs.groupby(['Class'], as_index=False)['HK'].median().sort_values(by=['HK'], ascending=False))\n\n_, axs = plt.subplots(1, 2, figsize=(11, 2.5))\nmy_bar_plot(axs[0], name=\"Average Kills\/Match by Class\", data=median_kb, x='Class',\n            y='KB', ylabel='Median Kills', orientation='vertical', format_spec='{:1.0f}')\nmy_bar_plot(axs[1], name=\"Average Assists\/Match by Class\", data=median_hk, x='Class',\n            y='HK', ylabel='Median Assists', orientation='vertical', format_spec='{:1.0f}')\nplt.show()","ed33f28a":"median_d = round(wowbgs.groupby(['Class'], as_index=False)['D'].median().sort_values(by=['D'], ascending=False))\n\n_, ax = plt.subplots(1, 1, figsize=(5.5, 2.5))\nmy_bar_plot(ax, name=\"Average Deaths\/Match by Class\", data=median_d, x='Class',\n            y='D', ylabel='Median Deaths', orientation='vertical', format_spec='{:1.0f}')\nplt.show()","a050ad45":"mean_hd = round(wowbgs.groupby(['Class'], as_index=False)['HD'].mean().sort_values(by=['HD'], ascending=False))\n\n_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nmy_bar_plot(ax, name=\"Average Healing Done\/Match by Classes\", data=mean_hd, x='HD',\n            y='Class', orientation='horizontal', format_spec='{:1.0f}')\nplt.show()","f56080e3":"from scipy.stats import norm\n_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nax.set_title(\"Damage Dealt\/Match Distribution\")\nsns.distplot(wowbgs['DD'],\n             fit=norm,\n             ax=ax,\n             kde_kws={'label': 'KDE'},\n             fit_kws={'label': 'Normalized'})\nax.set(ylabel='', xlabel='')\nplt.legend()\nplt.show()","5c95189e":"_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nax.set_title(\"Healing Done\/Match Distribution\")\nsns.distplot(wowbgs['HD'],\n             fit=norm,\n             ax=ax,\n             kde_kws={'label': 'KDE'},\n             fit_kws={'label': 'Normalized'})\nax.set(ylabel='', xlabel='')\nplt.legend()\nplt.show()","dad6f188":"corr = wowbgs.corr(method='pearson')\n\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n_, ax = plt.subplots(figsize=(10,7))\nax.set_title(\"Player Stats Correlation\")\nsns.heatmap(corr, mask=mask, vmax=1, center=0, annot=True, fmt='.1f',\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5});\nplt.show()","74c60b7e":"honor_df = wowbgs.groupby(['Honor'], as_index=False)['Win'].mean()\nhonor_df['Size'] = np.array(wowbgs.groupby(['Honor'])['Win'].count())\n\n_, ax = plt.subplots(1, 1, figsize=(7, 7))\nax.set_title(\"Honor\/Win Rate Dependance\")\nsns.scatterplot(x=\"Honor\", y=\"Win\", data=honor_df, ax=ax, hue=\"Size\", size=\"Size\")\nplt.show()","29b93e8d":"team_stats = ['DPS', 'Healers', 'Kills', 'Deaths', 'Assists', 'Damage', 'Healing']\nwowbgs.rename(columns={'KB': 'Kills', 'D': 'Deaths', 'HK': 'Assists', 'DD': 'Damage', 'HD': 'Healing'}, inplace=True)\nwowbgs['DPS'] = (wowbgs['Role'] == 'dps').astype(int)\nwowbgs['Healers'] = (wowbgs['Role'] == 'heal').astype(int)\nwowbgs.drop(['Role', 'Honor', 'BE'], axis=1, inplace=True)\nwowbgs = pd.get_dummies(wowbgs, columns=['Class'])\nfor name in class_names:\n    wowbgs.rename(columns={'Class_' + name: name}, inplace=True)\n\nmatches_columns = ['Battleground']\nfor faction in ['Alliance', 'Horde']:\n    matches_columns += [faction + ' ' + name for name in class_names]\n    matches_columns += [faction + ' ' + stat for stat in team_stats]\n\nmatches = pd.DataFrame(columns=matches_columns, index=range(matches_num))\n\nmatches['Battleground'] = np.array(wowbgs.groupby(['Code'])['Battleground'].first())\nmatches['Alliance Won'] = np.array(wowbgs[wowbgs['Faction'] == 'Alliance'].groupby(['Code'])['Win'].first().astype(int))\nfor faction in ['Alliance', 'Horde']:\n    for stat in team_stats:\n        matches[faction +' '+ stat] = np.array(wowbgs[wowbgs['Faction'] == faction].groupby(['Code'])[stat].sum())\n    for name in class_names:\n        matches[faction +' '+ name] = np.array(wowbgs[(wowbgs['Faction'] == faction)].groupby(['Code'])[name].sum())\nmatches.iloc[:,1:] = matches.iloc[:,1:].astype(int)\n\nprint('New dataset size:', matches.shape)\nprint('-'*27)\nprint('New features list:', *(matches.columns), sep='\\n')\nmatches.head()","5afac38b":"print('Is Alliance Kills number always equal to Horde Deaths number?',\n      (matches['Alliance Kills'] == matches['Horde Deaths']).all())\nprint('Is Horde Kills number always equal to Alliance Deaths number?',\n      (matches['Alliance Kills'] == matches['Horde Deaths']).all())","4077391e":"_, axs = plt.subplots(1, 2, figsize=(11, 5.5))\nsns.scatterplot(ax=axs[0], x=\"Alliance Deaths\", y=\"Horde Kills\",\n                hue=\"Alliance Won\", data=matches, palette='icefire_r')\ny = x = np.linspace(0, 95)\nsns.lineplot(x=x, y=x, ax=axs[0])\nsns.scatterplot(ax=axs[1], x=\"Horde Deaths\", y=\"Alliance Kills\",\n                hue=\"Alliance Won\", data=matches, palette=\"icefire_r\", legend=False)\nsns.lineplot(x=x, y=x, ax=axs[1])\nplt.show()","32c11ee2":"_, ax = plt.subplots(1, 1, figsize=(6.5, 3.5))\nax.set_title(\"Factions Win Rate\")\nsns.countplot(x='Alliance Won',\n              data=matches,\n              ax=ax,\n              palette='icefire')\nax.set(xlabel='', ylabel='Matches Won')\n\ntotal = float(len(matches))\nfor p in ax.patches:\n    width = p.get_height()\n    ax.text(x=p.get_x() + p.get_width() \/ 2., \n              y=p.get_y() + p.get_height() * 0.45,\n              s='{:1.2f}%'.format(width\/total * 100),\n              ha=\"center\",\n              size=\"small\",\n              color='white')\nplt.xticks(range(2), ('Alliance', 'Horde'))\nplt.show()","b1b7358f":"bgs_matches = pd.DataFrame(columns=['Battleground, Matches'])\nbgs_matches['Battleground'] = matches.groupby(['Battleground']).count().iloc[:,0].sort_values(ascending=False).index\nbgs_matches['Matches'] = np.array(matches.groupby(['Battleground']).count().iloc[:,0].sort_values(ascending=False))\n\n_, ax = plt.subplots(1, 1, figsize=(4.5, 3))\nax.set_title('Matches\/Battleground')\nsns.barplot(x='Matches',\n            y='Battleground',\n            data=bgs_matches,\n            ax=ax,\n            palette='icefire')\nax.set(xlabel='', ylabel='')\nfor p in ax.patches:\n    width = p.get_width()\n    ax.text(x=p.get_x() + p.get_width() \/ 2., \n    y=p.get_y() + p.get_height() * 0.75,\n    s='{:.0f}'.format(width),\n    ha=\"center\",\n    size=\"small\",\n    color='white')\nplt.show()","1637ebf4":"class_columns = []\nfor faction in ['Alliance', 'Horde']:\n    for name in class_names:\n        class_columns += [faction + ' ' + name]\n        \nclasses_corr = matches[class_columns]\ncorr = classes_corr.corr(method='pearson')\n\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n_, ax = plt.subplots(figsize=(12,11.5))\nax.set_title(\"Faction-Class Correlation\")\ncmap = sns.diverging_palette(220, 10, as_cmap = True )\nsns.heatmap(corr, cmap = cmap, mask=mask, vmax=1, center=0,\n            annot=True, fmt='.1f', square=True, linewidths=.5,\n            cbar_kws={\"shrink\": .5});\nplt.show()","81bb7dfd":"matches['Battleground'] = pd.factorize(matches['Battleground'])[0]\nnp.random.seed(42)\nmatches = matches.sample(frac=1, random_state=42)\nsplit = (0.7, 0.8)\nrand_idx = np.random.randint(round(split[0] * (matches_num - 1)), round(split[1] * (matches_num - 1)))\ndf_train = matches[:rand_idx]\ndf_test = matches[rand_idx:]\n\nprint('Dataset divided')\nprint('Train sample size:', len(df_train), 'matches |', '{:d}%'.format(round(len(df_train) \/ len(matches) * 100)))\nprint('Train sample size:', len(df_test), 'matches  |', '{:d}%'.format(round(len(df_test) \/ len(matches) * 100)))","e1c4e055":"X_train = df_train.drop(['Alliance Won'], axis=1)\ny_train = df_train['Alliance Won'].values\nX_test = df_test.drop(['Alliance Won'], axis=1)\ny_test = df_test['Alliance Won'].values","b5ec180b":"from xgboost import XGBClassifier\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.model_selection import RandomizedSearchCV\n\nxgb = XGBClassifier(tree_method='gpu_hist')\n\nparam_grid = {\n    'n_estimators': [50, 100, 200, 500, 1000],\n    'max_depth': [1, 3, 5, 7, 12, 15],\n    'learning_rate': [1e-1, 1e-2, 1e-3, 1e-4],\n    'gamma': [0, 0.5, 1, 5],\n    'reg_alpha': [0.1, 0.25, 0.5],\n    'reg_lambda': [0.1, 0.25, 0.5]\n}\n\nfolds = 3\nparam_comb = 5\nskf = StratifiedKFold(n_splits=folds, shuffle = True, random_state = 42)","096cfa0a":"#Randomized Search log in hidden cell\nrandom_search = RandomizedSearchCV(xgb, param_distributions=param_grid,\n                                   n_iter=param_comb, scoring='roc_auc',\n                                   n_jobs=-1, cv=skf.split(X_train,y_train),\n                                   verbose=3, random_state=42)\nrandom_search.fit(X_train, y_train)","da50439d":"print('XGB model best hyperparameters:')\nprint(random_search.best_params_)\nprint('XGB model best cross-validation score:')\nprint(random_search.best_score_)","6c95915c":"y_pred = random_search.predict(X_test)\nmy_confusion_matrix(y_test, y_pred, 'XGB+RandomizedSearch')","66facced":"from hyperopt import fmin, hp, tpe, Trials, space_eval\nfrom sklearn.model_selection import KFold, cross_val_score\n\nspace={\n       'n_estimators': hp.quniform('n_estimators', 1, 500, 50),\n       'max_depth' : hp.quniform('max_depth', 2, 20, 1),\n       'reg_alpha':  hp.uniform('reg_alpha', 0.01, 0.9),\n       'reg_lambda': hp.uniform('reg_lambda', 0.1, 1.0),\n       'learning_rate': hp.loguniform('learning_rate', 1e-4, 0.3),\n       'colsample_bytree': hp.uniform('colsample_bytree', 0.3, 1.0),\n       'gamma': hp.uniform('gamma', 0.0, 5.0),\n       'num_leaves': hp.choice('num_leaves', list(range(2, 15))),       \n       'min_child_samples': hp.choice('min_child_samples', list(range(2, 10))),\n       'feature_fraction': hp.choice('feature_fraction', [.5, .6, .7, .8, .9]),\n       'bagging_fraction': hp.choice('bagging_fraction', [.5, .6, .7, .8, .9])\n      }\n\n# trials will contain logging information\ntrials = Trials()\nnum_folds=5\nkf = KFold(n_splits=num_folds, random_state=42)","d2e23eda":"from sklearn.model_selection import cross_val_score\ndef xgb_cv(params, random_state=42, cv=kf, X=X_train, y=y_train):\n    params = {\n        'n_estimators': int(params['n_estimators']),\n        'max_depth': int(params['max_depth']),\n        'gamma': \"{:.3f}\".format(params['gamma']),\n        'reg_alpha': \"{:.3f}\".format(params['reg_alpha']),\n        'learning_rate': \"{:.3f}\".format(params['learning_rate']),\n        'gamma': \"{:.3f}\".format(params['gamma']),\n        'num_leaves': '{:.3f}'.format(params['num_leaves']),\n        'min_child_samples': '{:.3f}'.format(params['min_child_samples']),\n        'feature_fraction': '{:.3f}'.format(params['feature_fraction']),\n        'bagging_fraction': '{:.3f}'.format(params['bagging_fraction'])\n    }\n    model = XGBClassifier(**params, tree_method='gpu_hist', random_state=42)\n    score = -cross_val_score(model, X, y, cv=cv, scoring=\"roc_auc\", n_jobs=-1).mean()\n    return score","0d6ac7ba":"%%time\nbest=fmin(fn=xgb_cv,\n          space=space, \n          algo=tpe.suggest,\n          max_evals=35,\n          trials=trials,\n          rstate=np.random.RandomState(42)\n         )\nbest['max_depth'] = int(best['max_depth'])\nbest['n_estimators'] = int(best['max_depth'])","0cbf399a":"#Hyperopt log in hidden cell\nprint(*(trials.results), sep='\\n')","5fc8b264":"print('Best model parameters found with Hyperopt:\\n', best)","3fd346c9":"model_2 = XGBClassifier(**best, tree_method='gpu_hist')\nmodel_2.fit(X_train, y_train)\ny_pred_2 = model_2.predict(X_test)\nmy_confusion_matrix(y_test, y_pred_2, 'XGB+Hyperopt')","c300265c":"feature_importances = pd.DataFrame(columns=['Feature', 'Importance'])\nfeature_importances['Feature'] = df_train.iloc[:,:-1].columns\nfeature_importances['Importance'] = np.array(model_2.feature_importances_)\nfeature_importances = feature_importances.sort_values(by=['Importance'], ascending=False).reset_index(drop=True)\n\n_, ax = plt.subplots(1, 1, figsize=(9.5, 11))\nax.set_title('Feature Importances')\nsns.barplot(x='Importance',\n            y='Feature',\n            data=feature_importances,\n            ax=ax,\n            palette='icefire')\nax.set(xlabel='', ylabel='')\nfor p in ax.patches:\n    width = p.get_width()\n    if width < 0.01:\n        continue\n    ax.text(x=p.get_x() + p.get_width() \/ 2., \n    y=p.get_y() + p.get_height() * 0.75,\n    s='{:.2f}'.format(width),\n    ha=\"center\",\n    size=\"small\",\n    color='white')\nplt.show()","49f904ba":"_, axs = plt.subplots(3, 2, figsize=(13, 19.5))\n\nsns.scatterplot(ax=axs[0, 0], x=\"Alliance Kills\", y=\"Horde Kills\",\n                hue=\"Alliance Won\", data=matches, palette='icefire_r')\ny = x = np.linspace(0, 95)\nsns.lineplot(x=x, y=x, ax=axs[0, 0])\n\nsns.scatterplot(ax=axs[0, 1], x=\"Alliance Assists\", y=\"Horde Assists\",\n                hue=\"Alliance Won\", data=matches, palette=\"icefire_r\", legend=False)\ny = x = np.linspace(0, 1200)\nsns.lineplot(x=x, y=x, ax=axs[0, 1])\n\nsns.scatterplot(ax=axs[1, 0], x=\"Alliance Damage\", y=\"Horde Damage\",\n                hue=\"Alliance Won\", data=matches, palette='icefire_r')\ny = x = np.linspace(0, 1.5 * (10 ** 6))\nsns.lineplot(x=x, y=x, ax=axs[1, 0])\nxlabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 0].get_xticks() \/ 1000]\nylabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 0].get_yticks() \/ 1000]\naxs[1, 0].set_xticklabels(xlabels)\naxs[1, 0].set_yticklabels(ylabels)\n\nsns.scatterplot(ax=axs[1, 1], x=\"Alliance Healing\", y=\"Horde Healing\",\n                hue=\"Alliance Won\", data=matches, palette=\"icefire_r\", legend=False)\ny = x = np.linspace(0, 1e6)\nsns.lineplot(x=x, y=x, ax=axs[1, 1])\nxlabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 1].get_xticks() \/ 1000]\nylabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 1].get_yticks() \/ 1000]\naxs[1, 1].set_xticklabels(xlabels)\naxs[1, 1].set_yticklabels(ylabels)\n\nsns.scatterplot(ax=axs[2, 0], x=\"Alliance Damage\", y=\"Horde Healing\",\n                hue=\"Alliance Won\", data=matches, palette=\"icefire_r\", legend=False)\ny = x = np.linspace(0, 1.5 * 10**6)\nsns.lineplot(x=x, y=0.7 * x, ax=axs[2, 0])\nxlabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 1].get_xticks() \/ 1000]\nylabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 1].get_yticks() \/ 1000]\naxs[2, 0].set_xticklabels(xlabels)\naxs[2, 0].set_yticklabels(ylabels)\n\nsns.scatterplot(ax=axs[2, 1], x=\"Horde Damage\", y=\"Alliance Healing\",\n                hue=\"Alliance Won\", data=matches, palette=\"icefire_r\", legend=False)\ny = x = np.linspace(0, 1.5 * 10**6)\nsns.lineplot(x=x, y=0.7 * x - 0.5 * 10**5, ax=axs[2, 1])\nxlabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 1].get_xticks() \/ 1000]\nylabels = ['{:,.0f}'.format(x) + 'K' for x in axs[1, 1].get_yticks() \/ 1000]\naxs[2, 1].set_xticklabels(xlabels)\naxs[2, 1].set_yticklabels(ylabels)\n\nplt.show()","7e3a2434":"import plotly.express as px\n\ndiff = pd.DataFrame(columns=['Kills Diff', 'Assists Diff', 'Damage Diff', 'Alliance Won'])\ndiff['Kills Diff'] = matches['Alliance Kills'] - matches['Horde Kills']\ndiff['Damage Diff'] = matches['Alliance Damage'] - matches['Horde Damage']\ndiff['Assists Diff'] = matches['Alliance Assists'] - matches['Horde Assists']\ndiff['Alliance Won'] = matches['Alliance Won']\n\nfig = px.scatter_3d(diff, x='Kills Diff', y='Assists Diff', z='Damage Diff',\n                    color='Alliance Won', opacity=0.75, color_continuous_scale='magma')\nfig.show()","0d9266f8":"print('Matches Battlegrounds:', *(wowbgs['Battleground'].unique()), sep='\\n')","40a6aad3":"gil_matches = wowgil.pivot_table(values=['BA', 'BD'], index='Code', columns=['Faction'], aggfunc=lambda x: x.sum())\ngil_matches.columns = [(col[1] + ' ' + col[0]) for col in gil_matches.columns]\ngil_matches['Alliance Won'] = np.array(wowgil[wowgil['Faction'] == 'Alliance'].groupby(['Code'])['Win'].first())\n\n_, axs = plt.subplots(1, 2, figsize=(13, 6.5))\n\nsns.scatterplot(ax=axs[0], x=\"Alliance BA\", y=\"Horde BA\",\n                hue=\"Alliance Won\", data=gil_matches, palette='icefire_r')\ny = x = np.linspace(0, 8)\nsns.lineplot(x=x, y=x, ax=axs[0])\n\nsns.scatterplot(ax=axs[1], x=\"Alliance BD\", y=\"Horde BD\",\n                hue=\"Alliance Won\", data=gil_matches, palette=\"icefire_r\", legend=False)\ny = x = np.linspace(0, 4)\nsns.lineplot(x=x, y=x, ax=axs[1])\n\nplt.show()","aa2b888a":"sm_matches = wowsm.pivot_table(values='CC', index='Code', columns='Faction', aggfunc=lambda x: x.sum())\nsm_matches['Alliance Won'] = wowsm[wowsm['Faction'] == 'Alliance'].groupby(['Code'])['Win'].first().astype(int)\nsm_matches.rename({'Alliance': 'Alliance CC', 'Horde': 'Horde CC'}, axis=1, inplace=True)\n\n_, ax = plt.subplots(1, 1, figsize=(6.5, 6.5))\n\nsns.scatterplot(ax=ax, x=\"Alliance CC\", y=\"Horde CC\",\n                hue=\"Alliance Won\", data=sm_matches, palette='icefire_r')\ny = x = np.linspace(0, 45)\nsns.lineplot(x=x, y=x, ax=ax)\n\nplt.show()","cac26510":"tk_matches = wowtk.pivot_table(values=['OP', 'VP'], index='Code', columns=['Faction'], aggfunc=lambda x: x.sum())\ntk_matches.columns = [(col[1] + ' ' + col[0]) for col in tk_matches.columns]\ntk_matches['Alliance Won'] = np.array(wowtk[wowtk['Faction'] == 'Alliance'].groupby(['Code'])['Win'].first())\n\n_, axs = plt.subplots(1, 2, figsize=(13, 6.5))\n\nsns.scatterplot(ax=axs[0], x=\"Alliance OP\", y=\"Horde OP\",\n                hue=\"Alliance Won\", data=tk_matches, palette='icefire_r')\ny = x = np.linspace(0, 25)\nsns.lineplot(x=x, y=x, ax=axs[0])\n\nsns.scatterplot(ax=axs[1], x=\"Alliance VP\", y=\"Horde VP\",\n                hue=\"Alliance Won\", data=tk_matches, palette=\"icefire_r\", legend=False)\ny = x = np.linspace(0, 1600)\nsns.lineplot(x=x, y=x, ax=axs[1])\n\nplt.show()","c2bd690c":"wg_matches = wowwg.pivot_table(values=['FC', 'FR'], index='Code', columns=['Faction'], aggfunc=lambda x: x.sum())\nwg_matches.columns = [(col[1] + ' ' + col[0]) for col in wg_matches.columns]\nwg_matches['Alliance Won'] = np.array(wowwg[wowwg['Faction'] == 'Alliance'].groupby(['Code'])['Win'].first())\n\n_, axs = plt.subplots(1, 2, figsize=(13, 6.5))\n\nsns.scatterplot(ax=axs[0], x=\"Alliance FC\", y=\"Horde FC\",\n                hue=\"Alliance Won\", data=wg_matches, palette='icefire_r')\ny = x = np.linspace(0, 8)\nsns.lineplot(x=x, y=x, ax=axs[0])\n\nsns.scatterplot(ax=axs[1], x=\"Alliance FR\", y=\"Horde FR\",\n                hue=\"Alliance Won\", data=wg_matches, palette=\"icefire_r\", legend=False)\ny = x = np.linspace(0, 7)\nsns.lineplot(x=x, y=x, ax=axs[1])\n\nplt.show()","10f3c4dd":"Now we can clearly see the matches that are likely to get missclassified. But what happens? How do we get more kills and still lose? Well, you see, battleground isn't your classic team deathmatch and you have focus on specific tactical goals to achieve victory. Unfortunately, we don't have the information on *each* match game mode and specific details related to it, e.g., number of flags each team captures in **Capture the Flag** match, so there is a distinct limit to our prediction ability.\n\nHere's also a 3D visualization for Alliance-Horde team stats **difference** as another look at missclassification case.","b81fd18e":"Note that this correlation map is for **individual player** perfomance, not the team one. So, as we can see, your personal damage or heal output itself is not a determining factor for the match outcome - but your **Kills** and **Assists**, obviously, depend on it. **Assists** (**HK**), as already mentioned, represent the team work here and they contribute to the victory more than your personal killstreak.\n\nYou can also get the idea of how the **Honor** system works. Match outcome is **crucial** for the amount of points you are going to get. Check the chart below, and you will clearly see the actual threshold between 100% lose and 100% win based on the amount of Honor you've gained. This border will be even more dramatic if we sum up the Honor per match for each team. With this in mind, we will have to drop **Honor**, because it leaves no room for research, more or less telling the result.","7833d0cf":"**Monk** and **Priest** heal the most despite the fact that they are not the most played healer classes nor the most winning. **Paladin** being on the bottom of healers list pretty much explains why the DPS role is way more preferred for him.\n\nSee the distributions for **Damage Dealt** (**DD**) and **Healing Done** (**HD**) for the average damage\/healing output overall.","472cc535":"**Silvershard Mines** is a race for resource Battleground, where you have to escort as many **Captured Carts** (**CC**) to your base as you can to pile up Silvershard diamonds. Note that **Captured Cart** itself doesn't instanly reward you with the resources until you get it to your faction depot. As we can see from the plot, we can divide match outcome classes quite precisely with just one hyperplane, but it won't guarantee 100% accuracy (in case you *capture* more carts, than your enemy, but fail to actually *get* of them to your base).","931c32fc":"### Additional Match Information <a id=\"11\"><\/a>","eaf789c7":"And finally, **Warsong Gulch** is your classic **Capture the Flag**. **Flags Captures** (**FC**) is the objective it self, so this metric is naturally 100% accurate; **Flags Returned** (**FR**) isn't bad though, showing just a few outliners.","dc2f6b98":"What knowledge can we gain from this large table? Well, let's say you are playing as **Horde Paladin**. Then you aren't likely to fight side by side with **Horde Priest**, who is a mainly healer class just like you. However, be ready to face **Alliance Mage** and **Alliance Druid**.\n\nGenerally speaking, we should be cautious with our conclusion as the sample we are given is quite small and we got information on merely 250 matches.","faec6d8f":"In **Battle for Gilneas** teams are fighting over strategic capture points on the map to accumulate resources; the first team to gather specific amount of resources wins. Now, all we can extract is **Base Assaults** (**BA**)\/**Base Defences** (**BD**) statistics. As we can see, **BA** metric accuracy is somewhat around 80%; as for **BD**, it gives us almost no information. The reason for this is that it's very hard to actually defend the base. In the most likely scenario your whole team is killed on the base, then enemy team captures it with no resistance as you respawn quite far from the contested point and don't have time to regroup and repel the attack.","8cd43646":"First of all, let's get the general information on roles and classes. Here's faction\/class numerical relation (we'll explore this subject further a bit later).","024e9b6c":"In **Temple of Kotmogu** you are fighting over magic orbs (**OP**) awarding their carriers with **Victory Points** (**VP**) over time, as well giving them specific buffs and debuffs; your ultimate goal is to get more points. **OP** metric proves to be completely unreliable, while **VP** shows unusual behavior. In most cases, winner's advantage is overwhelming, meaning this metric would give us incredible accuracy, requiring just one hyperplane to divide two classes.","fcd0e187":"Note that in *World of Warcraft* you can play as DPS on every class, but you got only five options for the healer role. In other words, you can turn your classic healer **Paladin** into damage dealer one, however, you definitely won't heal your party as a **Demon Hunter**. Let's check what role is actually preferred on each of the healer classes.","64348215":"### Meet the Hyperopt <a id=\"9\"><\/a>\n\n84% accuracy is not that bad for a random search, but what about more meaningful approach? Well, there is one, called **Hyperopt**. If you are not familiar with it, be sure to check [this great tutorial](https:\/\/www.kaggle.com\/fanvacoolt\/tutorial-on-hyperopt) first.","f64d517c":"You actually shouldn't consider **Kills** or, to be more precise, **Killing Blows** way too serious. Keep in mind that we are talking about large teamfights where your mates could do 95% of the work only to have you land the final blow and take all the glory. **Assists**, or **HK**, on the contrary, is an important feature showing your overall participation in the match. Also, as we can see that **Assists** values are distributed rather equally. What this probably means is that healers get assists from healing their teammates getting the **Killing Blows**.","ccf7448e":"### Team Statistics <a id=\"6\"><\/a>\n\nNow, let's reconstruct our dataset for the match outcome prediction problem we want to solve.","06538102":"# Table of Contents\n\n* [Part \u00d8: Preparing the Data](#1)\n  * [Input Files Report](#2)\n  * [Data Cleaning](#3)\n* [Part I: Exploratory Data Analysis](#4)\n  * [General Faction\/Class\/Player Statistics](#5)\n  * [Team Statistics](#6)\n* [Part II: Winner Prediction](#7)\n  * [First Try](#8)\n  * [Meet the Hyperopt](#9)\n* [Part III: Model Analysis](#10)\n  * [Additional Match Information](#11)","97adbabf":"### Input Files Report <a id=\"2\"><\/a>","8060b8f4":"![title](https:\/\/www.scifibloggers.com\/wp-content\/uploads\/wow-horde-alliance-logo.png)","3b7dd94b":"*Please upvote if you liked this kernel ;)*\n\n*And be sure to check my [general WoW EDA](https:\/\/www.kaggle.com\/mandaloreultimate\/world-of-warcraft-exploratory-analysis-wip\/) as well*","87f4e1e5":"# Part \u00d8: Preparing the Data <a id=\"1\"><\/a>","18115b22":"### Data Cleaning <a id=\"3\"><\/a>","ff034d4a":"Interestingly enough, when it comes to Battlegrounds, there isn't really a highly specialized healer class since DPS role is quite popular among them as well. However, as we'll see later, your actual perfomance on \"non-native\" role won't be astounding. What this basically means is that you are more of less *forced* to switch to DPS as a healer class to get more **Honor**. Moving on to class perfomance statistics...","1c33143d":"Surprisingly, **Paladin** and **Priest** deal more damage than **Rogue** on the average. I suppose the reason is that **Rogue** isn't that type of guy who's always in the middle of the fight but rather prefers sneaking behind the enemy lines hunting for healers and range damage dealers. Let's compare damage output with **Kills** and **Assists** statistics.","bd69fa1a":"No dramatic difference in terms of **Deaths** of classes, though you'd probably feel abit safer on **Priest** and **Druid**. Now, what about healing? Who's the best on this role?","5ce99a8c":"# Part III: Model Analysis <a id=\"10\"><\/a>\n\nAlright, so **XGBoost** has given us rather decent result, and we got a slight increase in accuracy with **Hyperopt**. If we compare our **prediction accuracy** to **CV accuracy**, we'll see that they correlate quite well with each other, which is a reassuring observation. Nevertheless, the errors pattern remains. There are some matches which consistently get missclassified, and I bet these are some special cases that we have to investigate. First of all, let's check the feature importances judged by **XGBClassifier**.","c40068b4":"Thank you for your attention, hope you found this kernel somewhat insightful and discovered something new with it. Stay tuned for more EDA notebooks.","e842ce16":"# Part I: Exploratory Data Analysis <a id=\"4\"><\/a>\n\n### General Faction\/Class\/Player Statistics <a id=\"5\"><\/a>","e55c9237":"# Part II: Winner Prediction <a id=\"7\"><\/a>","726682a6":"And finally, let's have a look at the correlation for all player's statistics.","eb33ba14":"Here is one curious observation.","83084a3a":"**Kills** being of the top of the list is no surprise, what's interesting is that our model deemed some **Faction-Class** features to be very important, in fact, more important than overall team **Damage** of **Healing** output, or the team composition (**DPS** \/ **Healers**). And those classes themselves  - **Mage**, **Priest** or **Paladin** - aren't the greatest healers of damage dealers (see the above charts on classes perfomance). You'd expect team **Kills**\/**Assists**\/**Damage**\/**Healing** to have the most weight. Let's explore them.","56035155":"Let's find out if class **popularity** correlates with its **win rate**.","f2def54f":"As already mentioned above, we aren't provided with the full matches information related to Battleground specifics. What we've got is four additional datasets for **Battle for Gilneas**, **Silvershard Mines**,\n**Temple of Kotmogu** and **Warsong Gulch** matches. Let's see what can we learn about match outcome from new features.","c6277252":"### First Try <a id=\"8\"><\/a>\n\nNow, what model should we pick? There are so many to choose from... But do we really need to think about it, when we got that nice XGBoost? It will surely handle this task with no extra work required from us. That's how Data Science works, right?\n\nWell, there is still one nasty problem called 'hyperparameters optimization'. **GridSearch** is an option, of course, but I bet you don't want to wait forever, so let's try **RandomizedSearch** instead.","13fefda2":"So, **Faction A Deaths** > **Faction B Kills** would make some sense, as you could've died jumping from the cliff as well, but **Faction A Deaths** < **Faction B Kills** is really weird. More importantly, the data is very unbalanced in terms of these two features, so we can't just drop a few outliners or even drop **Deaths** columns for each side assuming that it more or less equals other side's **Kills**. Unfortunately, I'm not familiar with *WoW* Battlegrounds mechanics, so the only explanation I could come up with is the situation where you are killed, your kiler got his **Killing Blow** counted, however, your healer resurrects you, so you actually don't get your **Death** counted.\n\nSome general matches statistics:","a9f1cd96":"Check the hidden cell for custom functions."}}