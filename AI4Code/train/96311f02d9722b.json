{"cell_type":{"0e769073":"code","8cb16f48":"code","66539b93":"code","62389d64":"code","87924095":"code","f63cc85c":"code","dae3d1de":"code","2d433e02":"code","bdff10bf":"code","e3748059":"code","074f8541":"code","75cdaa08":"code","23b34835":"markdown","bb82ff98":"markdown","b9d65f25":"markdown","6b330555":"markdown","55e747fe":"markdown","b1d485bd":"markdown","ca64c44b":"markdown","93ff3cc2":"markdown","7c94cf75":"markdown"},"source":{"0e769073":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","8cb16f48":"# Create zero and one states\nstate_zero = np.array([[1.0],\n                       [0.0]])\nstate_one = np.array([[0.0],\n                      [1.0]])","66539b93":"# Superposition\nc1 = 1.0 \/ 2**0.5\nc2 = 1.0 \/ 2**0.5\nstate_super = c1 * state_zero + c2 * state_one\nprint(state_super)","62389d64":"# Assembling qunatum states\nstate_three = np.kron(np.kron(state_zero, state_one), state_one)\nprint(state_three)\n\ndef multi_kron(*args):\n    ret = np.array([[1.0]])\n    for q in args:\n        ret = np.kron(ret, q)\n    return ret\n\nstate_multi = multi_kron(state_zero, state_one, state_one, \n                         state_one, state_zero, state_one)\n\nprint(state_multi)\nprint(state_multi.shape)","87924095":"# Qunatum gates\ngate_H = 1.0 \/ 2**0.5 * np.array([[1, 1],\n                             [1, -1]])\n    \nstate_new = np.dot(gate_H, state_zero)\nprint(state_new)","f63cc85c":"gate_SWAP = np.array([[1,0,0,0],\n                      [0,0,1,0],\n                      [0,1,0,0],\n                      [0,0,0,1]])\n    \nstate_t0 = multi_kron(state_zero, state_one)\nstate_t1 = np.dot(gate_SWAP, state_t0)\nprint(state_t1)","dae3d1de":"gate_I = np.eye(2)\nstate_t0 = multi_kron(state_zero, state_one)\nstate_t1 = np.dot(multi_kron(gate_H, gate_I), state_t0)\nprint(state_t1)","2d433e02":"# Prepare state\nstate = np.dot(multi_kron(gate_H, gate_H), multi_kron(state_zero, state_zero))","bdff10bf":"# Projectors\nP0 = np.dot(state_zero, state_zero.T)\nP1 = np.dot(state_one, state_one.T)","e3748059":"# Probability of first qubit being in state 0\nrho = np.dot(state, state.T)\nprob0 = np.trace(np.dot(multi_kron(P0, gate_I), rho))","074f8541":"# Simulate\nif np.random.rand() < prob0:\n    ret = 0\n    state_ret = np.dot(multi_kron(P0, gate_I), state)\nelse:\n    ret = 1\n    state_ret = np.dot(multi_kron(P1, gate_I), state) ","75cdaa08":"# Normalize\nfrom scipy import linalg\nstate_ret \/= linalg.norm(state_ret)\n\nprint(\"Qubit Measured: \\n {} \\n After-Measurment State: \\n {}\".format(ret, state_ret))","23b34835":"## Quantum Gates\n![](https:\/\/cdn-images-1.medium.com\/max\/1600\/1*POeoWmy78HJDZRPgp8pVIA.png)\nWe successfully created single and multi qubit states in Python. Now, we would like to find out how to perform various transformation of these states. The quantum gates are a way of qubits manipulation. A state enters a gate in quantum circuit and exits as another state, thus quantum gates represent time evolution of a state describing qubits and must satisfy following criteria:\n\n* **must preserve norms i.e. norm squared probability amplitudes sum to one after application of gate,**\n* **must be reversible i.e. evolution of each not measured quantum state must be reversible.**\n\nIt turns out that unitary matrices meet the conditions and a trivial example is just identity matrix:\n\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-2f317569ee0c99935023e17bcbe18f4e_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n\nAnother example of quantum gate, this time more interesting, is Hadamard gate:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-4c69760f054bedd43c0d9446ab12b60e_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n![](https:\/\/www.researchgate.net\/profile\/Francois_Impens\/publication\/3409658\/figure\/fig1\/AS:394692047982605@1471113325853\/Basic-quantum-gates-and-their-matrix-representations.png)","bb82ff98":"## Quantum Computing In Python\n\n![](http:\/\/www.lgcnsblog.com\/wp-content\/uploads\/2015\/06\/computer_03.png)\n![](https:\/\/d2r55xnwy6nx47.cloudfront.net\/uploads\/2016\/06\/qubit_615x344-520x291.jpg)\n\n* ***The aim of this Notebook  is to show that we can successfully simulate simple quantum computation on classical computers. Well, it is not a peculiar thing, as quantum computation in its simplest form can be represented by just a bunch of vector and matrix operations. Hopefully, after reading this post you will be ready to code simple quantum circuit in Python without any background in quantum physics.***\n\n## Qubit\n![](https:\/\/www.autodesk.com\/products\/eagle\/blog\/wp-content\/uploads\/2017\/05\/qubit.png)\n![](http:\/\/homework.uoregon.edu\/pub\/class\/155\/q1.jpg)\n\n* ***The de\ufb01nition of qubit lies in the center of quantum computation theory. Before we dive into the explanation of qubit, let us recall the de\ufb01nition of classical bit. The state of classical bit can be in two states represented by column vectors:***\n\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-bf3537e27e958d50f7fdeb10396e6af7_l3.svg\" alt=\"Smiley face\" height=\"100\" width=\"400\">\n\n\nIn Python they can be represented by two numpy arrays:","b9d65f25":"We can also apply a quantum gate selectively on a subsystem using identity matrix (or matrices) on remainder. Two quantum gates represented by 2\u00d72 matrices and acting on two-qubit state must be merged with tensor product. Let\u2019s apply Hadamard gate on the first qubit only in \\ket{01} state. The operation H \\otimes I \\ket{01} can be coded as:","6b330555":"## Assembling qubits\n\nQuantum computer built by IBM is made up of 16 qubits1. How to describe a system composed of more than one qubit? The answer comes with the concept of tensor product and allows us to correctly describe a multi-particle quantum state. The tensor product between two states is denoted by symbol \\otimes and we can write an example of multi-qubit state using \\ket{011} or  \\ket{0} \\otimes \\ket{1} \\otimes \\ket{1} notation. Mathematically\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-2b2475ecc276827f9d210ac1061c1391_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n\nTensor product that deals with vectors and matrices is also called Kronecker product and has been implemented in Numpy. Let\u2019s build a state \\ket{011}:","55e747fe":"## References\n* IBM Builds Its Most Powerful Universal Quantum Computing Processors, https:\/\/www-03.ibm.com\/press\/us\/en\/pressrelease\/52403.wss (2017).\n* N. S. Yanofsky and M. A. Mannucci, Quantum Computing for Computer Scientists, Cambridge University press (2008).","b1d485bd":"## Measurement\n\nTo get an information from quantum computer we need to perform measurement. Unfortunately (or fortunately, this philosophical issue I am leaving for the readers) the universe works in such a way that a qubit after measurement collapses to state \\ket{0} or \\ket{1} with given probability corresponding to probability amplitude. Remember parameters c_1 and c_2 from Eq.(2)?.\n\nTo simulate measurement in Python, we will need objects called projectors defined as:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-49a5e1a40c1fdd0d3ee79bdaa2e37ccb_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n\nNote that \\bra{\\phi} is just a complex conjugate of \\ket{\\phi}. The projector P_0 applied on state \\ket{0} gives back state \\ket{0}:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-1e7766091dd65d8ec80b85050435084b_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\nwhereas applied on state \\ket{1} returns 0:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-a80c82656d2bc48227185146751789ef_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\ndue to the fact that states \\ket{0} and \\ket{1} are orthogonal, so that \\braket{0 \\vert 1} vanishes. The projector P_0 applied on an arbitrary qubit state would give:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-1bd9a6d31374b14811161594e164ed4d_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\nso intuitively we can say that projector P_0 has something to do with checking the fraction of \\ket{0} in an arbitrary state. Indeed, the probability that qubit i of an arbitrary multi-qubit state \\ket{\\psi} when measured is in state \\ket{0} can be expressed as:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-e371d387c7d662ad0e855dd5973d4644_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n\nIf we measure that the qubit i is in state \\ket{0} then the system just after the measurement would be in a state:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-ce0ec8ef89f5cbe3c6bd4b63e6c5181b_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\nwhere ||P_0^i\\ket{\\psi}||_2 is just a normalization factor thanks to which probabilities add to one.\n\nLet\u2019s assume we have prepared following state:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-5ce1e429e531db28038aa8e82611a390_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\nand want to simulate in Python the measurement of first qubit.","ca64c44b":"* ***However, quantum mechanics is not so boring! Qubit can be in superposition of two states defined in Eq.(1):***\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-6b29717806a32429f6008459053b6e02_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n\n* Parameters c_1 and c_2 are called probability amplitudes and are complex numbers. Their norm squares |c_1|^2 and |c_2|^2 are probabilities that as a result of measurement a qubit would be found in state \\ket{0} and \\ket{1}, respectively. As we deal with probabilities, it is straightforward that sum of these norm squares for a given state must sum to one, in our case this will be expressed as:\n\n\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-ab025cd81091d26c1a98a65ad958635f_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n***A state in superposition:***\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-e7e1a2544c21c18f7faa67ef642bc920_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n![](https:\/\/www.ias.edu\/sites\/default\/files\/styles\/grid_feature_teaser\/public\/images\/featured-thumbnails\/ideas\/dt_c120417.jpg)\n\n","93ff3cc2":"The  state_multi  is 2^6=64 dimensional vector and the dimensionality of an assembled state grows exponentially with number of qubits in a system.  This illustrates the overwhelming di\ufb00erence between quantum and classical computers. In order to simulate 64 qubit system 2^{64}=18,446,744,073,709,551,616 complex numbers are required. Do not try to emulate this system on your classical computer :).","7c94cf75":"A 2\u00d72 matrix is acting on a single qubit state, 4\u00d74 matrix on 2-qubit state, and so on. To see what is the action of Hadamard gate on \\ket{0} we need to use matrix multiplication,  np.dot  in Python:\n\n\ngate_H = 1.0 \/ 2 ** 0.5 * np.array([[1, 1],\n                             [1, -1]])\n    \n**state_new = np.dot(gate_H, state_zero)**\n\nBy careful examination we notice that  state_new  is just a superposition  state_super  from Eq.(4):\n\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-b30de54cbe99c2edd232093aaa74597d_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n\nso that the role of Hadamard gate is to create a superposition of states!\n\nQuantum gates can be also performed on multi-qubit states, for instance \\textit{SWAP} gate represented by a matrix:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-94964473b1451d7e6fb328ea9e27d825_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\nIt swaps two qubits so that an example state \\ket{01} is evolved into state \\ket{10}:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-2560282243561f175908098004e28cd8_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">"}}