{"cell_type":{"f1f59a03":"code","c48f6eb4":"code","e641ea66":"code","2be2a533":"code","f5ecf437":"code","e8216a94":"code","0c71e258":"code","26ac9376":"code","c15310ef":"code","95964623":"code","f1add106":"code","7aa973ae":"code","80e687d1":"code","43dcd28b":"code","ea9c60e1":"code","09f72d5d":"code","8ce16d6e":"code","766aa51b":"markdown","811aa0b1":"markdown","00bdf1e5":"markdown","7d5da02c":"markdown","f49e2a6e":"markdown"},"source":{"f1f59a03":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c48f6eb4":"# Adding imports that will be used\nfrom collections import namedtuple\nimport networkx as nx\nimport math","e641ea66":"# Definition of the tuples that will be read from the input files. These tuples of two positions represent the coordinates of the cities\nPoint = namedtuple(\"Point\", ['x', 'y'])\n\ndef distance(point1, point2):\n    \"\"\" Function to compute the euclidean distance between two points (two cities) \"\"\"\n    return math.sqrt((point1.x - point2.x)**2 + (point1.y - point2.y)**2)","2be2a533":"def readPoints(input_data):\n    \"\"\" This function takes all lines in a input data (coming from a file) and transforms it into a points array \"\"\"\n    lines = input_data.split('\\n')\n    nodeCount = int(lines[0])\n    points = []\n    for i in range(1, nodeCount+1):\n        line = lines[i]\n        parts = line.split()\n        points.append(Point(float(parts[0]), float(parts[1])))\n    return nodeCount, points","f5ecf437":"def complete_graph(points):\n    \"\"\" This code must be completed to finish the notebook. In this code, using the points given in the argument a graph must be created using NetworkX. As hint, it is recommended to first create all nodes and then define all edges between nodes, using the distance function. Once it is finished, change this documentation to document the implementation. \"\"\"\n    \n    # Create graph\n    graph = None\n    # Define nodes in the graph\n    # Define edges in the graph\n    return graph","e8216a94":"with open('\/kaggle\/input\/ap-algoritmos-y-programacin-2020-v2\/', 'r') as input_data_file:\n    input_data = input_data_file.read()\n    nodeCount, points = readPoints(input_data)\n    graph = complete_graph(points)\n    if graph != None:\n        print(\"Nodes in graph: \", graph.nodes(data=True))\n        print(\"Edges in graph: \", graph.edges(data=True))\n    \n# Expected answers for this example:\n# Nodes in graph:  [(0, {}), (1, {}), (2, {}), (3, {}), (4, {})]\n# Edges in graph:  [(0, 1, {'weight': 0.5}), (0, 2, {'weight': 1.0}), (0, 3, {'weight': 1.4142135623730951}), (0, 4, {'weight': 1.0}), (1, 2, {'weight': 0.5}), (1, 3, {'weight': 1.118033988749895}), (1, 4, {'weight': 1.118033988749895}), (2, 3, {'weight': 1.0}), (2, 4, {'weight': 1.4142135623730951}), (3, 4, {'weight': 1.0})]","0c71e258":"def calculate_distance_tour(solution, points):\n    \"\"\" Given the solution and the points, here it is computed the cost by summing all distances between the cities considering the order of the solution \"\"\"\n    cost = distance(points[solution[-1]], points[solution[0]])\n    for index in range(0, len(solution) - 1):\n        cost += distance(points[solution[index]], points[solution[index+1]])\n    return cost\n","26ac9376":"def check_solution(solution, points):\n    \"\"\" This method checks that the solution is a valid solution. It is checked that a city is not visited twice. If it's correct, it returns the distance of the journey \"\"\"\n    if len(solution) != len(points) or len(set(solution)) != len(points):\n        print('Soluci\u00f3n Incorrecta: No pasa por todos los nodos una \u00fanica vez')\n        return 0\n    \n    return calculate_distance_tour(solution, points)","c15310ef":"def solve_2_approx(points, flag_nx_MST= False):\n    \"\"\" This function must be defined to complete the practice. To fulfill all steps, NetworkX must be used. Modify this documentation to describe the implementation you did. \"\"\"\n    \n    solution = None\n    # 1.Create graph using the previous implemented function complete graph\n    # 2.Find minimun spanning tree, T\n    # 3.Duplicate T edges, G*\n    # 4.Find C, Eulerian chain of G*\n    # 5.Skip duplicates of C to find the Hamiltonian Path \n    return solution","95964623":"def solve_it(input_data):\n    \"\"\" This function takes input data that describes a specific problem of TSP and solve it. This is how it does:\n        1 - Parse the input and transform the content of each lines into Points\n        2 - If the list of cities is very big (> 1000)\n        2a - It is not solved\n        2b - Otherwise the previous implemented method is called.\n        3 - Prepare the solution in the specified output format\n        \n    \"\"\"\n    nodeCount, points = readPoints(input_data)\n    \n    if nodeCount>1000:\n        solution = range(0, nodeCount)\n    else:\n        solution = solve_2_approx(points, flag_nx_MST= True)\n        \n    cost = calculate_distance_tour(solution, points)\n    output_data = '%.2f' % cost + ' ' + str(0) + '\\n'\n    output_data += ' '.join(map(str, solution))\n\n    return output_data, check_solution(solution, points)","f1add106":"# Let's check the solution of the same example\nwith open('\/kaggle\/input\/ap-algoritmos-y-programacin-2020-v2\/', 'r') as input_data_file:\n    input_data = input_data_file.read()\n    example_output, example_distance = solve_it(input_data)\n    print(example_distance)\n    \n# Expected distance for this example: 5.03224755112299","7aa973ae":"# This code iterates over all files in put directory and send the problem definitions to the solve it function\nimport time\n\ntotal_time = 0\nimport gc\nstr_output_kaggle = [[\"Filename\",\"Value\"]]\nstr_output_moodle = [[\"Filename\",\"Value\", \"Solution\"]]\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        full_name = dirname+'\/'+filename\n        with open(full_name, 'r') as input_data_file:\n            input_data = input_data_file.read()\n            \n            start = time.time()\n                \n            output, value = solve_it(input_data)\n            gc.collect()\n            str_output_kaggle.append([filename,str(value)])\n            str_output_moodle.append([filename,str(value), output.split('\\n')[1]])\n                \n            end = time.time()\n                \n            print(filename, '(', value, ') time:', end - start)\n            total_time += end-start\n                \nprint('total time: ', total_time)","80e687d1":"# This function generates the submission file that must be upload to the competition\nfrom IPython.display import FileLink\nimport sys\nimport csv\ncsv.field_size_limit(sys.maxsize)\ndef submission_generation(filename, str_output):\n    os.chdir(r'\/kaggle\/working')\n    with open(filename, 'w', newline='') as file:\n        writer = csv.writer(file)\n        for item in str_output:\n            writer.writerow(item)\n    return  FileLink(filename)","43dcd28b":"submission_generation('algorithm_2_approx_unsorted_kaggle.csv', str_output_kaggle)","ea9c60e1":"# The file generated by this method must be uploaded in the task of the \"campus virtual\". The file to upload in the \"campus virtual\" must be the one related to one submitted to Kaggle. That is, both submitted files must be generated in the same run\nsubmission_generation('algorithm_2_approx_unsorted_moodle.csv', str_output_moodle)","09f72d5d":"reader = csv.reader(open(\"algorithm_2_approx_unsorted.csv\"))\nsortedlist = sorted(reader, key=lambda row: row[0], reverse=False)","8ce16d6e":"# This file must be submitted in the competition of Kaggle\nsubmission_generation('algorithm_2_approx_kaggle.csv', sortedlist)","766aa51b":"La funci\u00f3n que se muestra a continuaci\u00f3n debe ser completada siguiendo las pautas definidas en los comentarios","811aa0b1":"Ejemplo del paso 4 al 5:\n\n![imagen.png](attachment:imagen.png)","00bdf1e5":"El problema del agente viajero (Travel Salesman Problem - TSP) consiste en encontrar la ruta m\u00e1s corta que permita al agente visitar todas las ciudades regresando a la ciudad de origen. Este problema es f\u00e1cilmente resoluble haciendo una comprobaci\u00f3n de todas las posibles rutas que se pueden realizar y tomando la m\u00e1s corta de todas ellas. Sin embargo, estos m\u00e9todos basados en la fuerza bruta son imposibles de aplicar cuando la lista de ciudades que el agente tiene que visitar crece mucho.\n\nEn esta pr\u00e1ctica se trabajar\u00e1 el problema del agente viajero, teniendo como objetivo alcanzar una soluci\u00f3n que permita calcular rutas cortas para un n\u00famero peque\u00f1o de ciudades. Para ello, y siguiendo este notebook, se tendr\u00e1 que hacer uso del lenguaje de programaci\u00f3n Python y de la librer\u00eda NetworkX. La librer\u00eda NetworkX est\u00e1 orientada al tratamiento de grafos, permitiendo realizar operaciones sobre \u00e9stos. El uso de estas operaciones ser\u00e1 necesario para poder alcanzar el objetivo de esta pr\u00e1ctica.\n\nEn este notebook se han incluido distintos datasets que representan diferentes configuraciones del problema del TSP, con distintas distancias y n\u00famero de ciudades. El c\u00f3digo que acompa\u00f1a a este notebook permite realizar la lectura de estos ficheros para su procesamiento. Existen varios c\u00f3digos a lo largo del notebook que deben ser completados para terminar esta practica. Concretamente, se debe hacer uso de la API que ofrece la librer\u00eda NetworkX para:\n\nConvertir el contenido del fichero en un grafo de NetworkX\nCalcular el \u00e1rbol de expansi\u00f3n m\u00ednima de ese grafo con NetworkX\nCrear el multigrafo, a\u00f1adiendo nuevos v\u00e9rtices\nCalcular la cadena Euleriana\nEliminar de la cadena las ciudades que est\u00e9n duplicadas\nA continuaci\u00f3n se muestran diversas piezas de c\u00f3digo con comentarios. Algunas de estas piezas son las que se deben rellenar para terminar la pr\u00e1ctica. Se recomienda mirar la documentaci\u00f3n de NetworkX para poder completar la pr\u00e1ctica\n\nNOTA: se deben documentar las funciones implementadas por el alumno describiendo qu\u00e9 hace y, a grosso modo, c\u00f3mo lo hace. Pueden tomar como ejemplo la documentaci\u00f3n que traen las otras funciones de este notebook o inspirarse en esta web:\nhttp:\/\/edupython.blogspot.com\/2013\/12\/documentando-programas-en-python.html","7d5da02c":"La funci\u00f3n que se muestra a continuaci\u00f3n debe ser completada siguiendo las pautas definidas en los comentarios","f49e2a6e":"Ejemplo del Paso 3: Duplicate T edges, G*\n\n![imagen.png](attachment:imagen.png)\n"}}