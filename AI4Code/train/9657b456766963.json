{"cell_type":{"d30d02d4":"code","cc008bac":"code","0204e958":"code","aa21b287":"code","feebadf5":"code","58946f55":"code","68b30d16":"code","d3546469":"code","a9fa78a7":"code","14f2075c":"code","0aff2228":"code","3f9e9acc":"code","70544aa2":"code","36c33bee":"code","b02ab8ba":"code","a6050dc3":"code","9ffb97ab":"code","7b4e113f":"code","e76bf740":"code","4e19edf7":"code","bfe6e6cc":"code","6d85cc70":"code","d235d908":"code","4cf970a2":"code","3614cb59":"code","103539bb":"markdown","0ed0ed78":"markdown","b2740867":"markdown","1b3b804d":"markdown","f3a51c22":"markdown","dd358c30":"markdown","223a5475":"markdown","a21a0265":"markdown","124daf75":"markdown","9896171b":"markdown","45ad3fd2":"markdown","716d4e0b":"markdown","b36b6b90":"markdown","b58007ce":"markdown","7b709cc2":"markdown","8d9ea23d":"markdown","a7a89ee1":"markdown","9118d565":"markdown","932d329d":"markdown","8d816140":"markdown","e073cab4":"markdown","513b51cd":"markdown","ebe1a89a":"markdown","501a6877":"markdown"},"source":{"d30d02d4":"#coding: utf-8\n\nimport numpy as np\nfrom graphviz import Digraph, Graph\nimport random\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom PIL import Image, ImageEnhance, ImageFilter","cc008bac":"def melange(L, n = -1):\n    if (n == -1):\n        for i in range(len(L)):\n            indice1 = random.randint(0, len(L)-1)\n            indice2 = random.randint(0, len(L)-1)\n            tmp = L[indice1]\n            L[indice1] = L[indice2]\n            L[indice2] = tmp\n        return L\n    else:\n        res=[]\n        tmp = L.copy()\n        for i in range(n):\n            indice = random.randint(0, len(tmp)-1)\n            res.append(tmp[indice])\n            tmp.remove(tmp[indice])\n        return res","0204e958":"#tests de la fonction melange\nliste = [0,1,2,3,4,5,6,7,8,9]\nL = melange(liste, -1)\nprint(L)\nL2 = melange(liste, 4)\nprint(L2)\nprint(liste)","aa21b287":"class PartitionEntiers:\n    def __init__(self, n=0):\n        self.representants = list(range(n))\n        self.nbElements = n\n    \n    def ajouter(self):\n        self.representants.append(self.nbElements)\n        self.nbElements += 1\n    \n    def representant(self, i):\n        return self.representants[i]\n    \n    def fusion(self, i, j):\n        reprI = self.representant(i)\n        reprJ = self.representant(j)\n        self.representants = [m if m != reprJ else reprI for m in self.representants]\n        \n    def classe(self, i):\n        return [m for m in range(self.nbElements) if self.representant(i) == self.representant(m)]\n    \n    def part(self):\n        liste_classes = [[] for _ in range(self.nbElements)]\n        for i in range(self.nbElements):\n            liste_classes[self.representant(i)].append(i)\n        return [l for l in liste_classes if len(l) != 0]\n    \n    def dessine(self):\n        dot = Digraph()\n        for i in range(self.nbElements):\n            dot.node(str(i))\n        for i in range(self.nbElements):\n            dot.edge(str(i), str(self.representant(i)))\n        display(dot)","feebadf5":"tmp=PartitionEntiers(10)\norder = melange(list(range(10)))\nprint(order)\nfor i in range(1,10):\n    tmp.fusion(i-1,i)\n    #print(tmp)\n    #print(order[i-1],\" --> \",order[i])\n    #print(tmp.view())\n    tmp.dessine()\n    print(tmp.part())\nprint(tmp.classe(4))","58946f55":"class PartitionEntiers2:\n    def __init__(self, n=0):\n        self.peres = list(range(n))\n        self.hauteurs = [ 0 for _ in self.peres]\n        self.nbElements = n\n    \n    def ajouter(self):\n        self.peres.append(self.nbElements)\n        self.hauteur.append(0)\n        self.nbElements += 1\n    \n    def representant(self, i):\n        while i != self.peres[i]:\n            i = self.peres[i]\n        return i\n    \n    def fusion(self, i, j):\n        reprI = self.representant(i)\n        reprJ = self.representant(j)\n        if reprI == reprJ :\n            return False # Il n'y a pas eu de fusion\/besoin de fusionner\n        hI = self.hauteurs[i]\n        hJ = self.hauteurs[j]\n        if hI < hJ :\n            self.peres[reprI] = reprJ\n        elif hJ < hI:\n            self.peres[reprJ] = reprI\n        else:\n            self.peres[reprJ] = reprI\n            self.hauteurs[reprI] += 1\n        return True\n        \n    def classe(self, i):\n        reprI = self.representant(i)\n        return [m for m in range(self.nbElements) if reprI == self.representant(m)]\n    \n    def part(self):\n        liste_classes = [[] for _ in range(self.nbElements)]\n        for i in range(self.nbElements):\n            liste_classes[self.representant(i)].append(i)\n        return [l for l in liste_classes if len(l) != 0]\n    \n    def dessine(self):\n        dot = Digraph()\n        for i in range(self.nbElements):\n            dot.node(str(i))\n        for i in range(self.nbElements):\n            dot.edge(str(i), str(self.peres[i]))\n        display(dot)","68b30d16":"[6,1,1,1,3,4,6,6,7,7]\ntmp = PartitionEntiers2(11)\ntmp.dessine()\ntmp.fusion(1,2)\ntmp.dessine()\ntmp.fusion(4,5)\ntmp.dessine()\ntmp.fusion(3,10)\ntmp.dessine()\ntmp.fusion(3,4)\ntmp.dessine()\ntmp.fusion(3,1)\ntmp.dessine()\ntmp.fusion(7,8)\ntmp.dessine()\ntmp.fusion(8,9)\ntmp.dessine()\ntmp.fusion(6,0)\ntmp.dessine()\nprint(tmp.classe(4))\nprint(tmp.part())","d3546469":"def graph(nbVertices, nbEdges):\n    if nbVertices < 27:\n        mot = \"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\"\n        vertices = mot.split(\" \")\n        vertices= vertices[:nbVertices]\n    else:\n        vertices = [\"A\"+str(i) for i in range(nbVertices)]\n\n    edges = [(j,i) for i in range(nbVertices) for j in range(i)]\n    melange(edges)\n    edges = edges[:nbEdges]\n\n    return (vertices,edges)","a9fa78a7":"def drawGraph(g):\n        dot = Graph()\n        vertices, edges = g\n        for v in vertices:\n            dot.node(v)\n        for e in edges:  \n            startIndex,endIndex = e\n            start = vertices[startIndex]\n            end = vertices[endIndex]\n            dot.edge(str(start), str(end))\n        display(dot)","14f2075c":"g = graph(8,12)\ndrawGraph(g)","0aff2228":"def valuedGraph(nbVertices, nbEdges):\n    if nbVertices < 27:\n        mot = \"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\"\n        vertices = mot.split(\" \")\n        vertices= vertices[:nbVertices]\n    else:\n        vertices = [\"A\"+str(i) for i in range(nbVertices)]\n\n    edges = [(j,i,k) for i in range(nbVertices) for j in range(i) for k in range(1,10)]\n    melange(edges)\n    edges = edges[:nbEdges]\n\n    return (vertices,edges)","3f9e9acc":"def drawValuedGraph(g):\n    dot = Graph()\n    vertices, edges = g\n    for v in vertices:\n        dot.node(v)\n    for e in edges:  \n        startIndex,endIndex, value = e\n        start = vertices[startIndex]\n        end = vertices[endIndex]\n        dot.edge(str(start), str(end), str(value))\n    display(dot)","70544aa2":"g = valuedGraph(8,12)\ndrawValuedGraph(g)","36c33bee":"def composantesConnexes(g):\n    sommets, aretes = g\n    p = PartitionEntiers2(len(sommets))\n    for (i, j) in aretes:\n        p.fusion(i, j)\n    return [[sommets[i] for i in c] for c in p.part()]","b02ab8ba":"g = graph(25,14)\nprint(g)\ndrawGraph(g)\nprint(composantesConnexes(g))","a6050dc3":"def minimumSpanningTree(g):\n    sommets, aretes = g\n    #Rajout du sommet virtuel\n    sommets.append(\"VI\")\n    for s in sommets:\n        if s != sommets[-1]:\n            aretes.append((sommets[-1], s, 1000))\n    p = PartitionEntiers2(len(sommets))\n    print(p.dessine())\n    \n    ","9ffb97ab":"g= valuedGraph(8, 10)\nminimumSpanningTree(g)","7b4e113f":"def createLab(nbRows = 10, nbColumns = 30):\n    #1\n    g=graph(nbRows*nbColumns, 0)\n    sommets, aretes = g\n    #2\n    aretes_possibles = []\n    for i in range(len(sommets)):\n        if i == 0:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+10][1:])))\n        elif i == len(sommets)-1:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-10][1:])))\n        \n        elif i == 9 :\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+10][1:])))\n            \n        elif i == len(sommets)-10:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-10][1:])))\n        \n        elif i < 10:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+10][1:])))\n            \n        elif i > 290:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-10][1:])))\n        \n        elif i%10 == 0:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-10][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+10][1:])))\n        \n        elif i%10 == 9:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-10][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+10][1:])))\n        \n        else:\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-1][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i+10][1:])))\n            aretes_possibles.append((int(sommets[i][1:]), int(sommets[i-10][1:])))\n            \n        \n    \n    #3\n    p = PartitionEntiers2(len(g[0]))\n        \n    #4\n    aretes_possibles_M = melange(aretes_possibles)\n    \n    #5\n    composantes = composantesConnexes(g)\n    for (u,v) in aretes_possibles:\n        for c in composantes:\n            if (\"A\" + str(u) in c and \"A\" + str(v) in c):\n                pass\n            elif ((\"A\" + str(u) in c and not(\"A\" + str(v) in c)) or (not(\"A\" + str(u) in c) and \"A\" + str(v) in c)):\n                p.fusion(u,v)\n                g[1].append((\"A\" + str(u), \"A\" + str(v)))\n    return g","e76bf740":"def drawLab(lab, nbRows, nbColumns):\n    ","4e19edf7":"def formesConnexes(im):\n    pass","bfe6e6cc":"def composanteVersImage(dim, component):\n    pass","6d85cc70":"def afficheImages(listeImages,  nb_max_images = 9, figsize = (20,12)):\n  pass","d235d908":"def treatment(im):\n    out = im.filter(ImageFilter.SMOOTH_MORE)\n    return out","4cf970a2":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom PIL import Image, ImageEnhance, ImageFilter\n\noriginalImage = Image.open(\"..\/input\/borges2\/lab.png\")\nwidth, height = originalImage.size\nmyOriginalImage = originalImage.getdata()\nmyOriginalImage = np.asarray(myOriginalImage).reshape([height, width, 4])\nmyOriginalImage = np.array([[pixel[:3] for pixel in line] for line in myOriginalImage], dtype = np.uint8)\n\nfig, ax = plt.subplots(figsize=(20, 15))\nax.imshow(myOriginalImage,cmap='gray')","3614cb59":"myWorkImage = Image.open(\"..\/input\/borges2\/lab.png\")\n# ICI, on peut placer des traitements de PIL sur l'image myWorkImage\nmyWorkImage = treatment(myWorkImage)\n\nmyImage = myWorkImage.getdata()\nmyImage = np.asarray(myImage).reshape([height, width, 4])\nluminosity = np.array([[np.mean(pixel[:3]) for pixel in line] for line in myImage], dtype = np.uint8)","103539bb":"---\n# Composantes connexes d'un graphe non orient\u00e9\nCalculer les composantes connexes d'un graphe non orient\u00e9.","0ed0ed78":"### Cr\u00e9ation du graphe valu\u00e9\nEcrire une fonction qui renvoie un graphe valu\u00e9 al\u00e9atoire de $n$ noeuds et $p$ ar\u00eates. Les valuations seront des entiers al\u00e9toires dans $[1..10]$.","b2740867":"# Test m\u00e9thode 2","1b3b804d":"### Cr\u00e9ation d'un graphe al\u00e9atoire\nEcrire une fonction qui renvoie un graphe non orient\u00e9 al\u00e9atoire de $n$ noeuds et $p$ ar\u00eates.","f3a51c22":"---\n# Segmentation d'image (Partie 1)\n","dd358c30":"##  Graphe non orient\u00e9","223a5475":"# Test m\u00e9thode 1","a21a0265":"---\n# Type de donn\u00e9es Partition\n---\nNB : Les diff\u00e9rentes applications devront mettre en valeur le type 'partition'.\n","124daf75":"# Impl\u00e9mentation des types Partition M\u00e9thode 2","9896171b":"---\n# Outil : graphes","45ad3fd2":"# Impl\u00e9mentation du type Partition M\u00e9thode 1","716d4e0b":"---\n# Arbre couvrant de poids minimal\nCalculer un arbre couvrant de poids minimal d'un graphe valu\u00e9.\n\nOn pourra consid\u00e9rer qu'il existe un sommet virtuel, reli\u00e9 \u00e0 tous les autres sommets par un arc de poids gigantesque (ce qui r\u00e9soud le probl\u00e8me d'absence d'arbre couvrant dans le graphe de d\u00e9part).","b36b6b90":"# utf8 et imports","b58007ce":"## Graphe valu\u00e9\nUn graphe valu\u00e9 sera ici repr\u00e9sent\u00e9 par un couple :\n- liste des sommets\n- liste des arcs valu\u00e9es \n\nL'ar\u00eate valu\u00e9 reliant A et B avec une valuation v est le triplet (i, j, v) o\u00f9 i et j sont respectivement les indices de A et B dans la liste des sommets. Avec i < j.","7b709cc2":"## 1. fonction ```formesConnexes```\n*Synopsis*\n- Une image en noir et blanc \u00e9tant donn\u00e9e, construire les images des composantes connexes par arc extraites de cette image.\n\n*Vocabulaire*\n- une forme est connexe par arc ssi pour tout couple de points u,v \u00e0 l'int\u00e9rieur de la forme, il existe un arc ne quittant pas la forme reliant u et v\n- une composante connexe d'une image est une forme connexe maximale\n\n*Entr\u00e9s \/ Sorties*\n- **Entr\u00e9e**\n    - une matrice 2D dont les valeurs sont dans {0, 1}  \n- **Sortie**\n    - une liste de composantes connexes, une composante connexe \u00e9tant une liste des coordonn\u00e9es des points qui la composent\n    \n*NB*\n- On se placera en 4-connexit\u00e9, c'est \u00e0 dire que les points jouxtant $(i,j)$ sont $(i+1, j), (i-1, j), (i, j+1), (i, j-1)$, c'est \u00e0 dire que l'on ne consid\u00e9rera pas les diagonales.","8d9ea23d":"### Repr\u00e9sentation du graphe\nEcrire une fonction qui repr\u00e9sente, gr\u00e2ce au module *graphviz*, un graphe non orient\u00e9.","a7a89ee1":"## 2. fonction ```composanteVersImage```\n*Entr\u00e9es*\n- $(n,p)$ un couple d'entiers non nuls\n- $L$ une liste de couples d'entiers, o\u00f9 pour $\\forall (i, j) \\in L, 0\\leq i<n, \\text{ et } 0\\leq j<p$\n\n*Sortie*\n- $im$ une matrice 2D de dimensions $(n,p)$ d'\u00e9l\u00e9m\u00e9nts dans {0, 1} tel que $\\forall (i, j) \\in [0..n-1]\\times[0..p-1], t[i,j] =0 \\text{ ssi } (i,j) \\in L$","9118d565":"## 4. Segmentation d'une image : isoler les mots\n- Charger l'image de la base de donn\u00e9es 'borges2',\n- lui appliquer un flou, (biblioth\u00e8que PIL) ; la force du flou est \u00e0 r\u00e8gler par tatonnement,\n- seuiller l'image (choisir par tatonnement un seuil, puis pour tout pixel si sa luminosit\u00e9 est inf\u00e9rieure au seuil, 1, sinon 0),\n- calculer les formes connexes de l'image seuill\u00e9e,\n- utiliser les images correspondant \u00e0 ses composantes comme filtres de s\u00e9lection sur l'image de d\u00e9part,  \n--> avec les bons seuils, on obtient (dans un monde id\u00e9al) autant d'images qu'il y a de mots dans le texte de l'image, avec sur chaque image exactement un mot.\n\nNB : il est possible d'am\u00e9liorer le r\u00e9sultat en am\u00e9liorant les traitements r\u00e9alis\u00e9s sur l'image avant le calcul des composantes connexes.  \nNB2 : les composantes connexes de trop petites taille sont peu int\u00e9ressantes.","932d329d":"---\n# Segmentation dune image (Partie 2), non demand\u00e9e\nCette application a pour but de r\u00e9aliser une segmentation multi \u00e9chelle d'une image. A une \u00e9chelle donn\u00e9e, l'image est segment\u00e9e en classes. Les pixels sont les \u00e9l\u00e9ments \u00e0 ranger dans les classes, les pixels \u00e9tant d\u00e9finis par des couples (position, couleur). Au d\u00e9part, chaque classe correspond exactement \u00e0 un pixel. Au fur et \u00e0 mesure de l'algorithme, les classes sont fusionn\u00e9es. Une fois les classes finales calcul\u00e9es, une couleur est associ\u00e9e \u00e0 chaque classe (par exemple la moyenne ou la m\u00e9diane des couleurs de la classe), et l'image est affich\u00e9e avec ces nouvelles couleurs.\n\nIl existe plusieurs fa\u00e7ons classiques de proc\u00e9der \u00e0 la fusion des classes\n1) D\u00e9cider de la fonction de distance entre deux pixels ; par exemple choisir la somme des valeurs absolues des \u00e9carts sur chacune des trois composantes - Rouge, Vert, Bleu -\n2) D\u00e9cider de la fonction de voisinage ; par exemple, deux classes sont voisinnes ssi elles ont au moins un pixel qui se 'touche' en 4-connexit\u00e9\n2) D\u00e9cider de la r\u00e8gle de fusion\n- min : une classe fusionne avec une classe voisinne ssi la distance minimale entre les pixels de chaque classe est inf\u00e9rieure \u00e0 un seuil\n- max : une classe fusionne avec une classe voisinne ssi la distance maximale entre les pixels de chaque classe est inf\u00e9rieure \u00e0 un seuil\n- moyen : une classe fusionne avec une classe voisinne ssi la distance entre les moyennes des pixels de chaque classe est inf\u00e9rieure \u00e0 un seuil\n\nAu lieu de proc\u00e9der en utilisant un seuil, il est possible de r\u00e9aliser les fusions de fa\u00e7on it\u00e9rative, en choisissant \u00e0 chaque it\u00e9ration une fusion de co\u00fbt minimale.","8d816140":"# Une fonction qui renvoie un m\u00e9lange d'une liste\nLa fonction m\u00e9lange prend une liste $L$ en entr\u00e9e, et un entier $n$ optionnel.\n\nElle renvoie un m\u00e9lange \u00e9quiprobable de $L$ si $n$ n'est pas pr\u00e9cis\u00e9, et une liste de $n$ \u00e9l\u00e9ments distincts pris dans $L$ de fa\u00e7on al\u00e9atoire sinon.\n\nNB : le but n'est pas d'appeler une fonction d'une biblioth\u00e8que mais de trouver un algorithme r\u00e9pondant \u00e0 cette question, le seul outil al\u00e9atoire autoris\u00e9 est la fonction `random.randint`","e073cab4":"---\n# Cr\u00e9ation d'un labyrynthe\nSoit un rectangle de dimensions enti\u00e8res n x p. Construire un labyrinthe al\u00e9atoire respectant la contrainte : pour tout couple de case (u,v), il existe un et un seul chemin menant de u \u00e0 v.\n\nLe c\u00f4t\u00e9 al\u00e9atoire devra, sans preuve demand\u00e9e, g\u00e9n\u00e9rer un labyrynthe de fa\u00e7on \u00e9quiprobable parmi tous les labyrynthes respectant la contrainte impos\u00e9e.\n\nLe labyrynthe devra \u00eatre repr\u00e9sent\u00e9 graphiquement.\n\nAvant de commencer : comment appelle-t-on un graphe non orient\u00e9 v\u00e9rifiant \"pour tout couple de sommets (u,v), il existe un et un seul chemin reliant u et v\"\nNB : La solution propos\u00e9e doit mettre en oeuvre le type Partition.\n\n\n### Id\u00e9e\n- On consid\u00e8re le graphe non orient\u00e9 dont les sommets sont les cases du rectangle, ce graphe est sans aucune ar\u00eate.\n- On construit la liste des ar\u00eates possibles, c'est \u00e0 dire la liste des couples de sommets $u$ et $v$ tels que  $u$ et $v$ sont voisins sur la carte (4-connexit\u00e9).\n- On cr\u00e9e une partition des sommets, o\u00f9 chaque classe ne contient qu'un sommet.\n- On m\u00e9lange la liste des ar\u00eates possibles.\n- On consid\u00e8re successivement chacune des ar\u00eates $(u,v)$ de la liste m\u00e9lang\u00e9e ; si $u$ et $v$ sont dans la m\u00eame composante connexe, alors on ne fait rien, sinon on  fusionne la classe de $u$ et la classe de $v$ et on ajoute l'ar\u00eate $(u,v)$ au graphe.","513b51cd":"Un graphe non orient\u00e9 sera ici repr\u00e9sent\u00e9 par un couple :\n- liste des sommets\n- liste des arr\u00e8tes  \n\nL'arr\u00eate qui relie les sommets A et B est le couple $(i, j)$ o\u00f9 $i$ et $j$ sont respectivement les indices de A et B dans la liste des sommets. Le fait que le graphe soit non orient\u00e9 sera impl\u00e9ment\u00e9 en ne consid\u00e9rant que des ar\u00eates $(i, j)$ avec $j <i$.","ebe1a89a":"* ### Repr\u00e9sentation d'un graphe valu\u00e9\nEcrire une fonction qui repr\u00e9sente, gr\u00e2ce au module *graphviz*, un graphe valu\u00e9.","501a6877":"# 3. Procedure ```afficheImages```\nEcrire une proc\u00e9dure prenant en entr\u00e9e une liste d'images et qui en r\u00e9alise un affichage propre, sous forme d'un tableau d'images."}}