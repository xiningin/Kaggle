{"cell_type":{"73e1777e":"code","ca5e7767":"code","dbdda1a9":"code","572a14c3":"code","b80c8e76":"code","4825107e":"code","a4867d4d":"code","4245dc48":"code","14194bd5":"code","4d6cb119":"code","60af979d":"code","3340ab73":"code","370edc9d":"code","2b458283":"code","f2ed1cf8":"code","d8b033ec":"code","38c60502":"code","7fefd9df":"code","17e03dde":"code","8db9e567":"code","6389303d":"code","a60c4cf6":"code","d0123f00":"code","3dada931":"code","188864da":"code","fb925faa":"code","4faca6a2":"code","0aa63531":"code","cd565f66":"code","7878bc45":"code","ad5bbd88":"code","c989c2c8":"code","eb0aa21f":"code","b1c519f1":"code","b950d7b6":"code","67aa984e":"code","160cd437":"code","b2b151dc":"code","7c6b8f6c":"code","0a92dd14":"code","e5a66a51":"code","80958f60":"code","1df37b24":"code","d89aa14f":"code","aa323c0e":"code","7bc893d5":"markdown","8e9922c0":"markdown","f3636542":"markdown","ddaebdfa":"markdown","8aa706f5":"markdown","63a2334e":"markdown","66ac87d1":"markdown","1d40679b":"markdown","ac1ea990":"markdown","a1b9a311":"markdown","359d6166":"markdown","c3552538":"markdown","a87c220c":"markdown","2e002d70":"markdown","4692d50e":"markdown"},"source":{"73e1777e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport datetime\nimport os\n\nfrom matplotlib import pyplot as plt\n#  option for print all columns in the dataframes\npd.set_option('display.max_rows', 20)\npd.set_option('display.max_columns', 500)\npd.set_option('display.width', 1000)\n# end for options\nimport copy\nfrom datetime import datetime, timedelta\nfrom scipy import stats\n\nimport plotly.express as px\ntemplate = 'plotly_dark'\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.\nimport warnings\nwarnings.filterwarnings('ignore')","ca5e7767":"df = pd.read_excel(\"..\/input\/tunisa-regions-cov19\/RegioCov-19.xlsx\",sheet_name=\"RegioTime\")\ndf.dtypes\ndf2 = df.copy()\n#df1.rename(columns={'DateConf':'date',\n #                         'Confirmed':'confirmed',\n  #                'Gouvernorat':'region'}, inplace=True)\ndf2.rename(columns={'DateConf':'date',\n                          'Confirmed':'confirmed',\n                  'Gouvernorat':'region'}, inplace=True)\n\n# convert date in the target format for plotting the map\ndf2['date'] = df2['date'].dt.strftime('%d\/%m\/%Y')","dbdda1a9":"fig = px.scatter_mapbox(df2, \n                     lat = df2[\"Latitude\"], lon = df2[\"Longitude\"],\n                     color=\"confirmed\", size=\"confirmed\", hover_name=\"region\", \n                     range_color= [0, max(df2['confirmed'])+2],  color_continuous_scale='Bluered',\n                      animation_frame=\"date\", height = 720, size_max  = 50,zoom=5,\n                     # template = template,\n                     title='Spread in Tunisia over time: Region')\n\nfig.update_layout(mapbox_style=\"open-street-map\")\n\nfig.show()","572a14c3":"#df_covid_19 = pd.read_csv('..\/input\/corona-virus-report\/covid_19_clean_complete.csv')\ndf_covid_19 = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv\")\ndf_covid_19['Date'] = pd.to_datetime(df_covid_19['ObservationDate'])\ndf_covid_19['Outbreak'] = 'COVID_2019'\ndf_covid_19.columns","b80c8e76":"df_sars_03 = pd.read_csv(\"..\/input\/sars-outbreak-2003-complete-dataset\/sars_2003_complete_dataset_clean.csv\")\ndf_sars_03['Date'] = pd.to_datetime(df_sars_03['Date'])\ndf_sars_03['Province\/State'] = None\ndf_sars_03['Outbreak'] = 'SARS_2003'\nprint(df_sars_03.columns)\ndf_sars_03.rename({'Cumulative number of case(s)':'Confirmed', 'Number of deaths':'Deaths', 'Number recovered':'Recovered', 'Country':'Country\/Region'},axis=1,inplace=True)","4825107e":"templ_cols = ['Outbreak', 'Province\/State', 'Country\/Region', 'Date', 'Confirmed', 'Deaths', 'Recovered']\ndf = pd.concat([df_covid_19[templ_cols], df_sars_03[templ_cols]])\ndf = df.reset_index(drop=True)","a4867d4d":"df['Confirmed'] = df['Confirmed'].fillna(0)\ndf['Province\/State'] = df['Province\/State'].fillna('Others')\ndf = df.sort_values(['Country\/Region','Province\/State','Date'])","4245dc48":"df = df.groupby(['Outbreak','Country\/Region','Province\/State','Date']).agg({'Confirmed':'sum'}).reset_index()\ndf['Province\/State'] = 'all'","14194bd5":"t = df.groupby(['Outbreak','Country\/Region','Province\/State']).agg({'Confirmed':'max'})\nt = t.loc[t['Confirmed'] > 2]\ndf = pd.merge(df,t[[]],left_on=['Outbreak','Country\/Region','Province\/State'], right_index=True)","4d6cb119":"df['Country\/Region'].value_counts()","60af979d":"country_data = pd.read_csv(\"..\/input\/countries-of-the-world\/countries of the world.csv\")\ncountry_data['Country'] = country_data['Country'].str.strip()\ncountry_data","3340ab73":"df.loc[df['Country\/Region']=='US','Country\/Region'] = 'United States'\ndf.loc[df['Country\/Region']=='Mainland China','Country\/Region'] = 'China'\ndf.loc[df['Country\/Region']=='Viet Nam','Country\/Region'] = 'Vietnam'\ndf.loc[df['Country\/Region']=='UK','Country\/Region'] = 'United Kingdom'\ndf.loc[df['Country\/Region']=='South Korea','Country\/Region'] = 'Korea, South'\ndf.loc[df['Country\/Region']=='Taiwan, China','Country\/Region'] = 'Taiwan'\ndf.loc[df['Country\/Region']=='Hong Kong SAR, China','Country\/Region'] = 'Hong Kong'\n\ndf = pd.merge(df, country_data, how='left', left_on=['Country\/Region'], right_on=['Country'])\ndf['Date'] = pd.to_datetime(df['Date'])","370edc9d":"df.loc[df['Country'].isnull()]['Country\/Region'].value_counts()","2b458283":"df.loc[df['Region'].isnull(), 'Region'] = 'Others'\ndf.loc[df['Country'].isnull(), 'Country'] = 'Undefined'","f2ed1cf8":"df['Country'].value_counts()","d8b033ec":"fix, ax = plt.subplots(figsize=(16,6), ncols=2)\ns0 = df['Confirmed']\ns0.plot.hist(ax=ax[0])\n\n# BoxCox\n#from sklearn.preprocessing import PowerTransformer\n#transformer = PowerTransformer(method='box-cox', standardize=True)\n#s0 = s0+1\n\n# Normalise and reshape\n#from sklearn.preprocessing import FunctionTransformer\n#transformer = FunctionTransformer(np.log1p, inverse_func=np.expm1, validate=True)\n\nfrom sklearn.preprocessing import MinMaxScaler\ntransformer = MinMaxScaler(feature_range=(0,1)).fit(np.asarray([0, 2E5]).reshape(-1,1)) # df['Confirmed'].values.reshape(-1,1)\n\ns1 = pd.Series(transformer.transform(s0.values.reshape(-1,1)).reshape(-1))\ns1.plot.hist(ax=ax[1])\ndf['Confirmed_transformed'] = s1 # make sure that every value is positive","38c60502":"df['Month'] = df['Date'].dt.month\ndf['Week'] = df['Date'].dt.week","7fefd9df":"n_lags = 15\nfor k,v in df.groupby(['Outbreak','Country\/Region','Province\/State']):    \n    for d in range(n_lags,0,-1):                \n        df.loc[v.index, f'Confirmed_Lag_{d}'] = v['Confirmed'].shift(d)\n        #df.loc[v.index, f'Confirmed_Rolling_Mean_Lag{d}'] = v['Confirmed'].shift(d).rolling(n_lags).mean()\n        df.loc[v.index, f'Confirmed_Transformed_Lag_{d}'] = v['Confirmed_transformed'].shift(d)\n\nX_mask_lags = [c for c in df.columns if 'Confirmed_Lag_' in c]# + [c for c in df.columns if 'Confirmed_Rolling_Mean_Lag' in c]\nX_mask_lags_transformed = [c for c in df.columns if 'Confirmed_Transformed_Lag_' in c]\n\ndf[X_mask_lags] = df[X_mask_lags].fillna(0)\ndf[X_mask_lags_transformed] = df[X_mask_lags_transformed].fillna(0)\n\nprint(f'Dataframe shape {df.shape}')","17e03dde":"from sklearn.preprocessing import LabelEncoder\nenc_outb = LabelEncoder().fit(df['Outbreak'])\ndf['Outbreak_enc'] = enc_outb.transform(df['Outbreak'])\n\nenc_ctry = LabelEncoder().fit(df['Country\/Region'])\ndf['Country_enc'] = enc_ctry.transform(df['Country\/Region'])\n\nenc_region = LabelEncoder().fit(df['Region'])\ndf['Region_enc'] = enc_region.transform(df['Region'])","8db9e567":"from sklearn.model_selection import train_test_split\n\nX_mask_cat = ['Outbreak_enc','Region_enc', 'Month','Week']\ntrain_test = df.loc[df['Confirmed'] > 2].copy()\ns_unique_values = train_test[X_mask_lags].apply(lambda r: len(np.unique(r.values)), axis=1)\ntrain_test = train_test.loc[s_unique_values > 1].copy()\nprint(f'Train\/Test shape {train_test.shape}')\n\ntrain, valid = train_test_split(train_test, test_size=0.3, shuffle=True, random_state=231321)","6389303d":"from lightgbm import LGBMRegressor    \nmodel_lgbm = LGBMRegressor(n_estimators=100000, metric='rmse', random_state=1234, min_child_samples=5, min_child_weight=0.00000001,application = 'regression'\n                          , boosting = 'dart',num_leaves = 51, device = 'gpu',learning_rate = 0.003, max_bin = 63, num_iterations = 500 )\n\nprint(f'Fitting on data with shape {train[X_mask_cat+X_mask_lags].shape} with validation of shape {valid[X_mask_cat+X_mask_lags].shape}')\n\nmodel_lgbm.fit(X=train[X_mask_cat+X_mask_lags], y=train['Confirmed'], \n               eval_set=(valid[X_mask_cat+X_mask_lags], valid['Confirmed']),\n               early_stopping_rounds=100, verbose=5000)\n","a60c4cf6":"from datetime import timedelta\npred_steps = 10\n\nhistory = df.loc[(df['Outbreak']=='COVID_2019') & (df['Confirmed'] > 2) & (df['Country\/Region']=='Tunisia')]\nhistory0 = history.iloc[-1]\n\ndt_rng = pd.date_range(start=history0['Date']+timedelta(days=1), \n                       end=history0['Date']+timedelta(days=pred_steps),freq='D').values\ndt_rng = pd.to_datetime(dt_rng)\n\npred_months = pd.Series(dt_rng).apply(lambda dt: dt.month)\npred_weeks = pd.Series(dt_rng).apply(lambda dt: dt.week)\n\npred_cat = history0[X_mask_cat].values\npred_lags = history0[X_mask_lags].values\ny = history0['Confirmed']\n\nprint('History 0: ', pred_lags)\npred_lags[:n_lags] = np.roll(pred_lags[:n_lags], -1)\npred_lags[n_lags-1] = y  # Lag\n#pred_lags[n_lags:] = np.roll(pred_lags[n_lags:], -1)\n#pred_lags[-1] = np.mean(pred_lags[:n_lags]) # rolling_mean\nprint('Pred 0: ', pred_lags)\n\npred = np.zeros(pred_steps)\nfor d in range(pred_steps):     \n    pred_cat[1] = pred_months[d]\n    pred_cat[2] = pred_weeks[d]    \n    \n    y = model_lgbm.predict(np.hstack([pred_cat, pred_lags]).reshape(1,-1))[0]\n    #print(f'Prediction body: ', np.hstack([pred_cat, pred_lags]).reshape(1,-1))\n    print(f'Step {d}, predicted for {dt_rng[d].strftime(\"%Y-%m-%d\")} is: {y}')\n    \n    pred_lags[:n_lags] = np.roll(pred_lags[:n_lags], -1)\n    pred_lags[n_lags-1] = y  # Lag    \n #   pred_lags[n_lags:] = np.roll(pred_lags[n_lags:], -1)\n #   pred_lags[-1] = np.mean(pred_lags[n_lags:]) # rolling_mean\n\n    pred[d] = y\n    \npreds = pd.Series(data=pred, index=dt_rng, name='LGBM predicted')","d0123f00":"from tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import Dense, LSTM, Dropout, TimeDistributed, RepeatVector, Input, Concatenate, Flatten, Reshape, Embedding\nfrom tensorflow.keras.backend import clear_session\nimport keras\nclear_session()\n\ninp_outbreak = Input(shape=(1,1))\ninp_country = Input(shape=(1,1))\ninp_lags = Input(shape=(n_lags,1))\n\nemb_outbreak = Embedding(input_dim=2, output_dim=1)(inp_outbreak)\nemb_country = Embedding(input_dim=200, output_dim=2)(inp_country)\n\nlstm1 = LSTM(64, activation='linear', return_sequences=True)(inp_lags)\nlstm2 = LSTM(32, activation='linear', return_sequences=False)(lstm1)\n\nconcat1 = Reshape(target_shape=(1,3))(Concatenate(axis=3)([emb_outbreak, emb_country]))\nconcat2 = Concatenate(axis=1)([Flatten()(concat1), lstm2])\ndense1 = Dense(32, activation='linear')(concat2)\ndense2 = Dense(1, activation='linear')(dense1)\n\nmodel_keras = Model(inputs=[inp_outbreak, inp_country, inp_lags], outputs=[dense2])\nmodel_keras.compile(loss='mean_squared_error', optimizer='adam')\nmodel_keras.summary()\n\n\ndef prepare_keras_input(data):\n    lags = data[X_mask_lags_transformed].values.reshape(-1, 15, 1)\n    y = data['Confirmed_transformed'].values.reshape(-1,1)    \n    \n    return [data['Outbreak_enc'].values.reshape(-1,1,1), \n            data['Country_enc'].values.reshape(-1,1,1), lags], y\n    \ntrain_X, train_y = prepare_keras_input(train)\nmodel_keras.fit(train_X, train_y, validation_data=(prepare_keras_input(valid)), epochs=50, verbose=0,validation_steps=10,use_multiprocessing=True)\n","3dada931":"from datetime import timedelta\nfrom tensorflow import convert_to_tensor\n\npred_steps = 10\n\nhistory = df.loc[(df['Outbreak']=='COVID_2019') & (df['Confirmed'] > 2) & (df['Country\/Region']=='Tunisia')]\nhistory0 = history.iloc[-1]\n\npred_cat_outbreak = convert_to_tensor(history0['Outbreak_enc'].reshape(-1,1,1), np.int32)\npred_cat_country = convert_to_tensor(history0['Country_enc'].reshape(-1,1,1), np.int32)\n\npred_lags = history0[X_mask_lags_transformed].values\ny = history0['Confirmed_transformed']\n\n#print('History 0: ', pred_lags)\npred_lags = np.roll(pred_lags, -1)\npred_lags[-1] = y\n\n#print('Pred 0: ', pred_lags)\npred = np.zeros(pred_steps)\n\ndt_rng = pd.date_range(start=history0['Date']+timedelta(days=1), \n                       end=history0['Date']+timedelta(days=pred_steps),freq='D').values\ndt_rng = pd.to_datetime(dt_rng)\n# Scale\nfor d in range(pred_steps):    \n    y = model_keras.predict([pred_cat_outbreak, pred_cat_country, convert_to_tensor(pred_lags.reshape(-1,15,1), np.float32)])[0][0]\n    #print(f'Pred body: {pred_lags}')\n    print(f'Step {d}, predicted for {dt_rng[d].strftime(\"%Y-%m-%d\")} is: {transformer.inverse_transform(y.reshape(-1,1)).reshape(-1)}')\n    \n    pred_lags = np.roll(pred_lags, -1)\n    pred_lags[-1] = y    \n    pred[d] = y\n    \npred = transformer.inverse_transform(pred.reshape(-1,1)).reshape(-1)\npreds_keras = pd.Series(data=pred, index=dt_rng, name='Keras predicted')","188864da":"from matplotlib import pyplot as plt\nfig, ax = plt.subplots(figsize=(16,7))\n\nhist = history.set_index(['Date'])['Confirmed'].plot(ax=ax, marker='o')\npreds.plot(ax=ax, marker='o', linewidth=2)\npreds_keras.plot(ax=ax, marker='*')\nplt.legend()\nplt.tight_layout()","fb925faa":"import datetime\nts = datetime.datetime.now().strftime('%Y%m%d')\ndf_out = pd.DataFrame([preds, preds_keras]).T\ndf_out.to_csv(f'{ts}_prediction.csv')","4faca6a2":"from matplotlib import pyplot\nfrom pandas.plotting import autocorrelation_plot\ndf_ser = df[df['Country\/Region']=='Tunisia']\ndf_ser","0aa63531":"import numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()\n\nseries = df_ser.loc[:,['Date','Confirmed']]\nseries['Date'] = pd.to_datetime(series['Date'])\ndates = np.asarray(series['Date'])\nseries.reset_index()\nseries = df_ser.loc[:,['Confirmed']]\n\n\n\n#conf = np.asarray(series['confirmed'])\n#series = pd.Series(conf, index=dates,columns = ['confirmed'])\n#series['confirmed'].values().index(dates)\n#parse_dates\nseries = series.set_index(dates)\nseries","cd565f66":"autocorrelation_plot(series)\npyplot.show()","7878bc45":"from statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfig = plt.figure(figsize=(10, 10))\nax1 = fig.add_subplot(311)\nfig = plot_acf(series, ax=ax1,\n               title=\"Autocorrelation on Original Series\") \nax2 = fig.add_subplot(312)\nfig = plot_acf(series.diff().dropna(), ax=ax2, \n               title=\"1st Order Differencing\")\nax3 = fig.add_subplot(313)\nfig = plot_acf(series.diff().diff().dropna(), ax=ax3, \n               title=\"2nd Order Differencing\")","ad5bbd88":"plot_pacf(series.diff().dropna(), lags=10)","c989c2c8":"plot_acf(series.diff().dropna())","eb0aa21f":"from statsmodels.tsa.arima_model import ARIMA\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\nmodel = ARIMA(series, order=(0,1,1))\nmodel_fit = model.fit(start_ar_lags=1 ,transparams=False)\nprint(model_fit.summary())\n# plot residual errors\nresiduals = pd.DataFrame(model_fit.resid)\nresiduals.plot()\npyplot.show()\nresiduals.plot(kind='kde')\npyplot.show()\nprint(residuals.describe())","b1c519f1":"fig, ax = plt.subplots(figsize=(10, 10))\nax = series.loc['2020-03-04':].plot(ax=ax)\nmodel_fit.plot_predict('2020-04-01','2020-04-12',ax=ax,plot_insample=False)\nplt.show()\n","b950d7b6":"X = series.values\nsize = int(len(X) * 0.5)\ntrain, test = X[0:size], X[size:len(X)]\nhistory = [x for x in train]\npredictions = list()\nfor t in range(len(test)):\n    model = SARIMAX(history, order=(0,2,1))\n    model_fit = model.fit(maxiter=200)\n    output = model_fit.forecast()\n    yhat = output[0]\n    predictions.append(yhat)\n    obs = test[t]\n    history.append(obs)\n    print('predicted=%f, expected=%f' % (yhat, obs))\n   # print(model_fit.mle_retvals)\nfrom sklearn.metrics import mean_squared_error\nerror = mean_squared_error(test, predictions)\nprint('Test MSE: %.3f' % error)\n\n","67aa984e":"# plot\npyplot.plot(test)\npyplot.plot(predictions, color='red')\npyplot.show()","160cd437":"\n\n#divide into train and validation set\ntrain = series[:int(0.7*(len(series)))]\nvalid = series[int(0.7*(len(series))):]\n\n\n\n\n#plotting the data\ntrain['Confirmed'].plot()\nvalid['Confirmed'].plot()","b2b151dc":"!pip install pyramid-arima","7c6b8f6c":"\n#building the model\nfrom pyramid.arima import auto_arima\nmodel = auto_arima(train, error_action='ignore', suppress_warnings=False,seasonal=False)\nmodel.fit(train)\n\nforecast = model.predict(n_periods=len(valid))\nforecast = pd.DataFrame(forecast,index = valid.index,columns=['Prediction'])\n\n#plot the predictions for validation set\nplt.plot(train, label='Train')\nplt.plot(valid, label='Valid')\nplt.plot(forecast, label='Prediction')\nplt.show()","0a92dd14":"from statsmodels.tsa.stattools import adfuller\ndef adf_test(timeseries):\n    #Perform Dickey-Fuller test:\n    print ('Results of Dickey-Fuller Test:')\n    dftest = adfuller(timeseries, autolag='AIC')\n    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\n    for key,value in dftest[4].items():\n       dfoutput['Critical Value (%s)'%key] = value\n    print (dfoutput)\n\n#apply adf test on the series\nprint(adf_test(train['Confirmed']))","e5a66a51":"from math import sqrt\nrms = sqrt(mean_squared_error(valid,forecast))\nprint(rms)","80958f60":"import tensorflow as tf\ntfk = tf.keras\ntf.keras.backend.set_floatx(\"float64\")\nimport tensorflow_probability as tfp\ntfd = tfp.distributions\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import IsolationForest\n# Define helper functions.\nscaler = StandardScaler()\ndetector = IsolationForest(n_estimators=1000, behaviour=\"deprecated\", contamination=\"auto\", random_state=0)\nneg_log_likelihood = lambda x, rv_x: -rv_x.log_prob(x)","1df37b24":"data = series\n# Scale data to zero mean and unit variance.\nX_t = scaler.fit_transform(data)","d89aa14f":"# Restore frame.\ndataset = pd.DataFrame(X_t, columns =['Confirmed'])\ndataset = dataset.set_index(dates)\ndataset","aa323c0e":"# Define some hyperparameters.\nn_epochs = 50\nn_samples = dataset.shape[0]\nn_batches = 10\nbatch_size = np.floor(n_samples\/n_batches)\nbuffer_size = n_samples\n# Define training and test data sizes.\nn_train = int(0.7*dataset.shape[0])\n\n# Define dataset instance.\ndata = tf.data.Dataset.from_tensor_slices((dataset['Confirmed'].values))\ndata = data.shuffle(n_samples, reshuffle_each_iteration=True)\n\n# Define train and test data instances.\ndata_train = data.take(n_train).batch(batch_size).repeat(n_epochs)\ndata_test = data.skip(n_train).batch(1).repeat(n_epochs)\n","7bc893d5":"![](data:image\/jpeg;base64,\/9j\/4AAQSkZJRgABAQAAAQABAAD\/2wCEAAkGBxISEhUTEhIWFhUXFhYYGBUVFRUXFhUYHxgWFhcVFxMYHSgiGBsnGxUXIzEhJSkrLi4uFx8zODMtNygtMSsBCgoKDg0OGhAQGy0lICUtLS8tLS0tLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLf\/AABEIAOEA4QMBEQACEQEDEQH\/xAAcAAEAAgIDAQAAAAAAAAAAAAAABgcEBQECAwj\/xABHEAABAwEDCAYHBwEGBgMAAAABAAIDEQQFIQYSMUFRYXGBBxMiMlKRI0JicqGxwRQzgpKiwtFDU3OTs+HwFRYkVLLSY2TD\/8QAGwEBAAIDAQEAAAAAAAAAAAAAAAMEAQIFBgf\/xAA9EQACAQIDBAgGAQEHBAMAAAAAAQIDEQQhMQUSQVETYXGBkaGx0QYiMsHh8BTxFSMzQlJiciRTgtKSssL\/2gAMAwEAAhEDEQA\/ALxQBAEAQBAEAQBACUBHr1y0sUFQZescK9mIZ5rsLh2QdxIUUq0I8Tp4fZGKrZqNlzeX58ERS8Ok6Q4QQNbsdK4uP5G0\/wDIqGWJfBHXo\/DsFnVm32Zeb9jWvygvefumRo2MjaxvJ7hX4rXpKrLSwOzaOqT7W2\/Bex4G7LzkxfLL+O0OPwDiFjdqP+pJ\/IwEMoxXdFex5OyUtbu89h96R5\/aVjopG62lho6J+C9wMkbUND4xwe8ftTopD+1MO9U\/Be53FzXizuTP\/BaJB8yE3Jria\/y8DP6oLvivyerL3viD15SBqc1koPE0J+KzvVUavC7MrcIrvcfZGdYuk60MObPBG\/bml0bhxBzqnyWyxMlqivV+HaMlelNrts19vuSm6+kCxTUDnmF2yUUH+ICWjmQpo14PqORiNh4ulnFby\/2+2vkSmOQOAc0gg6CDUHgQpjkSi4uzWZ2QwEAQBAEAQBAEAQBAEAQBAEAQHDjTE6ECVyG3\/wBIMEVWWcdc\/wAQNIh+P1\/w4bwoJ10tMzu4PYVar81X5V5+HDv8CGzT3hePec4xnV93AOXr884qBudQ7cYYLAaL5vGX48jaXfkTG3GV5efC3st89J8wto0VxKlba83\/AIat25v29SQWS64ovu42t3gCvN2kqVRS0ObUxNSp9cmzK6pZsRbw6pLDeHVJYbx1MSGd46mNDO8dDGsG28Y1qsMcgpIxrh7QB+aw0nqS0604O8W12Ggt+R8LsYy6M7O83yOPkVG6Seh0aO1ascpq\/k\/3uNMyz2+7yXwvcG6SYznMO98RHxI5qO04aF51MHjVu1Er9eT7n+e4lmT\/AEmMdRtrZmH+1jqWH3mYlvKvJTQxHCRxsZ8PSjeWHd+p69z0fl3k\/s87JGh7HBzXCoc0ggjaCNKsppq6POThKEnGSs1wZ6LJqEAQBAEAQBAEAQBAEAQGsv6\/YbIzPldie6xuL3nY0fU4BaTmorMt4TBVcVPdprtfBdv7crC9L7tl5P6tgIj\/ALJh7IG2V\/rc8MMBVVJTlUdkesw+Dw2z4b8n83N6\/wDiuHrzdjeXLkdFHR01JH7Kejbwb63E+QUkKSWpz8VtWpUyp\/KvP8d3iSZsSlscpyO4iWbGu8d2wpYw5Hs2xOOqnFZsRutFHoLuOsjyWd016fqO3\/Dh4j5JumP5D5A3a3afgm6P5D5HR117HfD\/AFTdNlieo8JLrfqoVrus3WJjxMOayubpaR8vNYaJ41Iy0ZjOYsEqZ5OasG6Zob4ybhmq4Dq3+JowJ9pug8cDvUcqaZ0MNtCrSyea5P7MjtktlsuuSrTRpOIxdDJxGp1OBw2KJOdN5HTqUsLtGHzarukvx4rvLRyVyugtooOxMBV0TjjvLHeu34jWArdOqp9p5PaGy6uEd3nHg\/fk\/wBRIVKcwIAgCAIAgCAIAgCAjeV+VkdjbmNo+dw7LNTR4300DYNJ8yIqlVQ7TqbO2ZPFveeUFq+fUv3LyK9uy6p7wlM0z3ZpPakOk09SMaAB5DeaqtGMqjuz0tfE0cDTVKms+X3f7dk\/u+744WBkbQ1o8ydpOs71YjFJWR5ytXnVlvTd2ZrWLYrtnvFCToCzY0lNIyo7IBpxW1iF1XwMhrQNAWSNts5QwEAQBAEAQBAY09hjdpFDtGCw4pksK048TU2u6ntxb2hu0+WtaOJcp4mMsnkat4WhcRi2mFr2lrmhzTpBFQVq0SwnKL3ouzIVfNwvs7hNZy7Naa4E58Z2gjEjfpGvaq8obuaO9hsbCuujqpXfgyc5DZci0ZsFpIbNoa\/ANl5aGv3aDq2KxRr73yy1PP7V2M6F6tHOHFcY\/j048ycqyefCAIAgCAIAgCAjWWmVDbHHmso6d47DToaNHWO3bBrPAkRVam4us6mzNnPFzvLKC1fPqX7l4EByduJ9reZ7QXFhcSST2pXa8dTdVRsoN1aEHJ3Z6PG4yOGiqVJZ+UV7\/wBWWFDGGgBoAAFAAKADUAFZPNSk27s92hZI2Z0Fl1u8lskV51OCMsCi2ITlAEAQBAEAQBAEAQBAEBh267mSacHeIfXatXFMnpV5U+wjNvsj4jRw4EaCopJo6tKrGorxMF5WpYREMo7ipWWEb3MGrXnN\/jyUE4cUdrBYy\/8Ad1O5\/Zkz6PMs\/tAFmtDvTAdh5\/qgaj7YHmMdqno1r\/LLU4W2dk9A3Wor5eK\/0\/j0J4rJ54IAgCAIAgNZlFfTLJC6V+J0MbXF7zoaPKpOoArSc1FXLeCwk8VVVOPe+S5\/vEqq6bFJb53TTuJbnVe7RU6o27BSnAbyqcYubuz1+IrQwVFU6Sz4e7\/c2WDC0NAAAAAAAGAA1ABWkebk23dmRHjgFkieRtrLZs3E6fkt0inUqb2S0MlZIggCAIDo+Vo0lLmyi2eTrWNQWLm6pM8zbDsCxc2VI6G3HYPim8Z6FD\/iO1vxTeM9B1noy8WHTUcR\/CbyNHQmtDJY8HEEHgtiJprU7IYCAIDznha9pa4VB1LDVzaE3B3iRC+bsdCajFh0O2bjvUMo2O1hsQqqtxNQ5yjLqREb\/u0xOE0VWioJzcDG6tQ5p1Y+R+EM42zR2sHiFUj0VTPt4rk\/3MtHITKcW2Gj6CeOgkGjO2SNGw\/Ag7lbo1d9Z6nkdrbOeEq\/L9D06uru9CTqY5QQBAEBw40xOhAlcp3KK833law2M+jaS2PYG+tKeNK8A0aVRnJ1JZHuMFh44DDXn9TzfbwXd63ZLrBZmxMbGwUa0cztJ3kqZJJWRxa1SVWbnLVmY1y2IGje3fZMwVPePw3KRKxz61XedloZi2IAgCA8J7U1uGk7P5WGySFNyMGS1k6+QWtyeNJI8usWDfdODIhndOhkQ23ToZFgyonm6RDdRPN0iwbJHRs5aatJB3Jc2cE1Zmwsl+UwkH4h9R\/C2U+ZVqYPjDwNzFIHAFpBB1hSFGUXF2Z3QwEB0mia9pa4VBwIKNXNoycXdakDv27TA+mlh7rvod4Vacd1nocJiFWj1rU08tCCCKg4EHQRsUZejdO6I1ZLVJd9qbLHiBqr32HvMP8AvSGlRJuEro6lSnDHYd05\/wBHwf71ovS77ayeJksZqx7Q5p3HaNR1ELoxkpK6Pn1ajOjUdOazTsZCyRhAEBDOk2++qgEDD25qh26Md783d4Z2xQV52VuZ3dhYPpa3Sy0j\/wDbh4a+BHck7B1cfWOHaf8ABuoc9PlsUVONlc6e0K\/ST3FovUkDXqQ5rRu7jslfSO0er\/KkguJQxVW3yLvN0pCgEAQGrtt5eqw8Xfx\/K0cuRbpYfjI13WLUtbo6xBunHWIN04MiwZ3TvBE9\/dFd+rzWUmzWcow+pmfFdHjdyb\/J\/hbbpWliv9KMpl2xD1a8SVndRE8RUfE7\/YYvA3yWd1GOmqczzfdcJ9TyJHyKxuo2WJqLiYVouBp7jyOOI+i1cCeGNkvqVzX9VaLKc4DObrpi08RpHFa\/NEs71DEqzyfmb+7reyZucw8Rrad6ljJM51ajKlK0jKWSEIDFvKxNmjMbteg62nU4LEldWJaFaVKanErG3wuie6N4o5pofoRuIx5qm1Z2PWUpxqQU46M1N6WfrGEaxi3js5rSSui5Qn0cr8OJveiS\/S1zrHIcDV8VdTh94zmO1Tc9SYadnus5\/wARYK8ViY8MpdnB\/bwLRVw8kEAJQFK3javt9uc\/THWjf7puA\/Np4vKoSe\/O57ujS\/hYNR48f+T9vsShr1MclozLuhMrwwa9J2DWVmKu7EFaapwcmTRjAAABQAUAVg4TbbuzshgIDS3zeWJjYfeP7f5UcpcC\/hsP\/nl3GoEi0Lu6OsS5jdHWIN04z0M7purBdPrSfl\/n+FJGPMoVsTwh4m3a0DACgW5TbvqcoYCAIAgCAIDW2i7KP62GjJNY9R42OA0cR8Vo48UWoYi8dypmvNdnsZ0MmcK0IOsHSDsWyK8o7rseiyahARTLy686MTtHaZg7ezbyJ8idihrRyudjZOJ3Z9FLR6dv5K9c9VT0qRp55nQTsnjwc1wePeBqQdx18StHdO6LsIRrUXSno1bu\/Bfl221s8UcrO69rXDgRWh3rpRkpJNHzqtSlRqSpy1TsZKyREey9vLqLFIQaOk9E3Ghq7AkHaGZx5KKtLdgzp7Iw\/TYqKeizfd+bIrjJmHNY5+txoOA\/1r5KrTXE9Pjp70lHkb0SKQ57iS7JSy0jMh0vwHuj+TXyCnprK5xdoVLz3Fw9TeqQ54QGuvu8OpZh3nYN3bXcvqFrOVkWcLQ6Weei1Il1qgO1unPWoY3R1qDdHWIN0k9y3ZmAPeO2dA8I\/lTRjbNnJxWI33ux09TbLcphAdXnA8EMrUwblvITx19YUDhv28CtYyuixisO6M7cOBsFsVggCAIAgCAIAgOssYcC1wqCCCDrBwIQzGTi01qil76shs80kR9V1AdrTi0+RCoTW67HusLVVelGouK8+Pmaa3jOad2P++SjZeo\/LIsbohvPPs0kBOML6t9x9XD9Qf5hWsNK6ceR5j4jw+5XjVX+Zea\/FieqyedKz6W7dWSCAHutdIRvJzGH9L\/NVMTLNI9V8O0bQnVfFpeGb+xrbIMxjW7ABz1\/FaLJFup80nIy4AXOa0aXEAcSaBbLMhnaKcnwLPs8IY1rBoaAByFFbSseSnJzk5PieiyahAV\/f16tfK5xcA0dltSBgNfM1KrTldnpMJhnCmklnqzUvveIeuOVT8lpvouLC1HwPJ1\/xDRnHgP5Kxvo3WCqPkeTsom6mO5kBY6Q2WAlxaJTkM02gumcyjGGjamuc\/STSmgYczuU1L5szk7VaoJUk7t69S\/Pp2k3Vg4AQBAdJj2TwPyRmY6oqW58rmwvbIGvpTtN7PabrGnSqUatnc9nidlurFwbXV2lrWG1smjbJG7OY8Ag7uGo7tSuJpq6PH1aUqU3Cas0e6yRhAEAQBAEAQBAV10q2LNdFOPWrG7iKvZ8M\/yCq4iOjPT\/AA\/Wup0nwzXo\/sV6+RVT0qibzovt3VXg1mqVr491QM9p\/RT8SkoStO3M5+3qPSYNy4xaf2fr5F1roHgymMtbR1t5SbGuYwcGtaSPzFyoVXeoe52XDo8DHrTfi\/ax2EiDdN7kbF1lqb7Ac\/y7I+LgpaSvI5205bmHfXZfvgWQrR5cIDS5ZXiYLHK8Gji3MaRpDnHNBHCpPJR1ZbsWy\/syh02JhF6avsWfnoUqFQPdnNUMHKA7RRlzg1oq5xDWjaSaAeZWVmayainJ6LMvS57vbZ4Y4W6GNArtOlzuZJPNdCMd1WPn+JruvVlUlxf9F3IzFsQBAEB0n7ruB+SwzaP1I+eI9A4Bcw+ly1ZMujzKX7PJ9nlPopHdkk4RyH5NdoOw0OslT0Km67M4e2dn9PDpoL5o69a916dxbCunjjDvG9YIBWaVkezOcATwbpPJayko6sno4atWdqcW+xERvTpMs7KiCN8p8TvRs+Izv0qGWIitDs0Ph6tLOrJR837eZ3yOvi22+QyyFsdnYaZsbSOsfqbnkkkDSSKVwG2ilOc3d6GNpYXCYKChC8pvi3ouduvhrz5E3Vg4AQBAEBHOkGydZYJtrAJBuzCHO\/TnDmoqyvBnT2PV6PGQ68vHJedij3SLnnv1E9bptfVWiGWtMyWNx4BwJ+FUi7NM0xFLpKE6fNNeR9HLqnzAoK8rTW1TSHGs0x83up8FzZP5mz6LQp\/9PCC\/0x9EeUluedGHDT5rF2bqjFak46JISZLRIdTY2gneXlw\/S1WcMs2zgfEUrQpwXNv0t6sspWjywQEA6WbVRkEXic95\/CA0f5h8lWxDySPR\/D1O8qlTkkvHP7FcgqqenOaoAgJH0f2PrbbHXRGHSHkM1v6nNPJS0VeZy9sVejwkrcbL7+iZcKvHiQgCAIDpP3XcD8lhm0fqR87x90cAuYfTJasFAjdz5XW10bY\/tDmta0N7NGvcBgC6TvV3ghSOrO1rlCOy8JGbnuJtu+enctPI0b3EkuJJJ0kmpPEnSoy+lZWWhnXBc8lrnbDHhXFztTGDvOPnQDWSFtCDk7Ir4vFQwtJ1Jdy5vl79Ret3WGOCJkUTaMYKAfMk6yTUk6yV0YxUVZHz6tWnWqOpN3bMlZIggCAIDwt1nEkb4zoexzTwIIPzWGrqxJSm6c4zXBp+B82DQuSfUmdX6CjzMotL\/nYeP4q30x5D+yHyK+lfnOJ2knzNVXZ6WKskjgIZLQ6I2+gnP\/zAeTGH9yuYb6WeS+In\/fQX+37v2J4rB54ICrelaWtqjbshB\/M94\/YFTxH1I9d8Pxth5S5y9EvchagO6KoYOaoCd9E0dZbQ7W1kY\/MXH9gVjDrNs898QytTprm35W9yylbPLBAa287+s1n++mY0+GtX8mNq4+S1lOMdWWqGCr1\/8ODfXw8dCJ3n0lxios8Ln+1IcxvENFSedFBLELgjs0Ph6bzqzS6lm\/b1IlemWFtnqHTFjT6sQzB+bvcs5QyrTfE7NDZWFo5qN3zln+PI0CiOicIZOpQHLGFxDWglxIAA0kk0AA2kokG1FNvRF15F5OCxQUNDM+hkcNupgPhbXmSTrV+lT3F1ng9p494urdfStF9+1\/gkKlOaEAQBAEAQHzferM2eZuyWQeT3Bcp6s+oYd71GD\/2r0RiLBMcIZM97aEjYSFsVk7q4WDJafRGf+mm\/vz\/lxK7hvpZ5D4i\/x4f8fuydKwefCAqfpUH\/AFrT\/wDXZ\/mSqniPqPY7Af8A0r\/5P0iQ9QHbOaoYCAsDojPbtXuwfOb+VZw3E858RfTS\/wDL\/wDJY6tHlzUZQXK60toLTNDujcA0+8AASN1QtJw3uJdweLWHld04y7de7h5FdXn0fWuKpjzJh7JzX7yWOw8nFVZUJLTM9NQ25hqmU7xfXmvFeyIva7M+J2bIxzHbHtLSeAOkb1C01qdenUhUW9BprqdzxJWDc4QycEoDhYMm0yXvRtltUcz2BzWkg4VLQRQvb7Q+VRrUlOSjK7KmPw0sRh5U4uzfnbg+pl7Qyte0OaQ5rgCHDEEEVBB2UXRTufPZRcZOMlZo7oahAEAQBAEB85X6a2m0f383+Y5cqWr7X6n07Cf4FP8A4x9EYJWCycIDb3tHm2iZvhmlb5PcPot5ZSZSw73qMHzjH0RjBakpZnRBMMy0M1h7HfmaW\/8A5q3hnk0eV+I4fPTl1NeD\/JYStHmggKy6W4aSwPp3mPbX3XNP7yqmJWaZ6v4dnenUjyafjf2IHVVj0RyhgICadFVpzbVIzxxE82uFB5Od5Kxh381jhfEFO+HjPlL1X4RaiuHkAgCA8rTZmSNLZGNe06WuaHA8QVhpPU3hUlTe9BtPmsiLXvkBY5AXMDoXYn0Z7J\/A6oA4UUUqEXodfDbcxUGlK0l16+K+9yoGuqAdoVE9q1Z2CwDgrIOFgyWB0ZZT5jhY5Xdlx9C46naTHXYdI31GsKzQqW+Vnm9u7O3l\/JprNfV2c+7j1Z8yz1cPJhAEAQBAcEoD5ptM2e9z\/E5zvMk\/Vcm98z6pCG5FR5JLwPJxWGbonX\/JO4\/FWOhPPf2w+Zr8urN1dvtApgXB435zWuJ\/MT5LWsrTZa2TU38HTfJW8G16GiUZ0CcdE1qzbVJH44q82OFB5Pd5Kzh381jgfENPew8Z8peq\/CLXVw8cEBDelOxZ9kEg0xSNJ911WH4uaeSgxCvG53NgVtzEuD\/zJ+Kz+zKmVI9ic1QCqA2WTl4\/Z7VDMTRrXjO9xwLHnk1xPJb05bskyrjaHT4edNatZdqzXmXwuifPAgCAIDzn7ruB+SwzaP1I+c4u6OA+S5Z9OlqzMuy75LRKyGIVe80GwDW524DFbRi5OyIa9eFCm6k9F+27WWnN0cWN0bWgyNeGgGRrsXHW5zHVbidgCufx42PIx2\/iozcnZp8GtO9WZFr16NbUypheyYbD6N\/AAktPHOChlh5LTM62H+IMPPKonHzXv5MiV4XfNZzSaN8RrgXAtFdPZfoJ3gqCUXHU7VGvSrq9OSl2fde5b2QWU32yHNefTxgB\/tjVIBv17DuIV6jU31nqeK2vs\/8Ai1d6P0S06ur26u8lKmOQEAQBAa3KW2dTZJ5NbYnke9mkN+NFpUluwbLWBpdLiacOcl4XzPnYBcs+mntd9m62WOL+0kYz8zg36rNruxHWqdHTlPkm\/BXPpLqm7AurY+W7zKt6XLFm2iGYaHxlh2VY6o5kSfpVTErNM9d8O1r0Z0+Tv4\/08yCKsehNtkpb+otkEhOAeGu911WEncA6vJb05bskyntCj02GqQ42y7Vn9rF9LpHzsVQGLedjbPDJE7Q9jmndUUqN40rEldWJaFV0akakdU0ygbRA6N7o3ijmOLXDeDQ\/ELmPJ2Po8JxnFTjo813nSqGQgCGS4uj2+\/tFlDHH0kNGO2lvqP5gUrtaVeoz3o9h4fbOE6DEOSXyyzXbxX7waJTVTHJFUAqgPOfuu4H5LDNo\/Uj5yi7o4Bcs+ny1ZcvR\/k19ki6yQenkAzq\/026RHx1nfhqCvUae6rvU8PtjaP8AJqbkH8kdOt8\/bq7SWVU5xhVAdZGBwIcAQdIIqDxCGU2ndGmiyWssczZ4Y+pkbriOa1w1tdH3SDwroxqAo+iinvLIvS2liJ0nSqS3ovnm+1PXzN3VSFAVQCqAVQEH6XLwzLGIgcZpGinst7ZP5gwc1WxMrRtzO\/8ADtDfxTqcIrzeXpcpsqke3JR0aWHrbwi2Rh0h5DNb+pzVLQV6iOVtyt0eCl\/usv3uTL0XRPnxFOku7uusTnAdqEiUcBUP\/Q5x5BQ4iN4dh19iV+ixSi9JZe3nYppc89vcEVWRcvTJC9ftNkikJq6ma\/329lx50rwcF0act6KZ8+2jh\/4+JlBaarsensbmq3KIqgKw6UbkzJBamDsyUbJTU8CjXHi0U4tG1VMRDPeR6zYOM3oPDyeazXZxXc\/XqIKqx6G4QXCC5s8nL6fZJ2ytqRoezxsOkcdY3jZVbwnuO5UxuFjiqLpy7nyf7qXfYLayaNssbs5jxUH6EaiNBGohdBSTV0eCrUp0puE1Zo96rJEKoDpOey7gfkjNo\/UirujDJrrS21St7DKdUD67x6\/Bp0e17qp0Kd\/mZ63b20ejvh6bzf1dS5d\/Hq7S1Kq4eQFUAqgFUAqgFUAqgFUAqgKW6UL16+2FjTVkDcwbM89qQ+dG\/gXPxE7ztyPdbBw\/Q4Xfes8+7h795EFCdu5anQ3dmbHNaCO+4Rt91uLiOLnU\/ArmFjk5HkfiTEb04UVwV32vTy9Sx1bPMnWWMOBa4VBBBB0EHAhDMZOLTWp8\/X3drrNPJA6vYcQCdbdLHc2kc6rlTjuyaPoeGxCr0Y1VxXnx8zCWpPcmvRhfPVTus7j2JsW7pAP3Nw4taNasYednu8zg7dwvSUlWjrHXsfs\/Vlq1V08gKoDHvCxsnjfFIKseKEfUHUQcQdoWrSasySjWnRmqkHmikb9uiSyTOik1YtdqezU4fUaiCqE4uLsz32ExcMTSVSHeuT5e3Ua9aFkIAguSDJHKh9ifQ1fC49pmsHxsrr3a\/ipadXcfUc3aOzo4uN1lNaP7Pq9C3rvt8c8YkieHsdoI+II0gjYcVdUk1dHi61GpRm4VFZoyKrYiOHYgjbgsGU7O50s0LY2NYwBrWgNa0aAAKAIrJWRmdSU5OUndvU9Koa3FVkCqAVWAdXyAAkkAAVJOAA1knUEuZSbdkdLNaA9oc3unuk4Zw1OpsOpE7m04OD3XqetUNBVAarKa+RZLNJMdIFGDxPODR54ncCtak9yNy3gcK8TXjTWnHqXEoKR5cS5xq4kkk6SSaknmuYfRkklZaHEUTnuDWCrnENaBrcTQDmSE7BKainKWizfYfRVw3Y2y2eKBvqNAJ2u0udzcSea6sI7sUj5xi8Q8RWlVfF+XBdyM9blcICvele5M5jLWwYsoySngJ7DuTiR+PcqmJhlvI9FsLF7snQlxzXbxXevTrKxVI9Nc7MeQQWkggggjSCDUEbwQsmHZqz0LtyUvwWyztkwDx2ZG7HjWBsOkcdy6FOe\/G54PaGDeFrOHDVdnutGbiq3KIqgNTlLcUdsizH9lwqWSUqWO+rTrH1AK0nBTVi7gcbPCVN6Oa4rmvfkym70u6WzyGKZua4c2uGpzXa2nb8jgqMouLsz29DEU68FOm7r06n1mKtSa4QXOEFzPua+Z7K\/PhfSveacWP95uvjgd63jNxeRXxOFpYmO7UV+viux\/qLIuTL+zSgNm9A\/2jWM8JPV\/FTiVahXi9cjy+K2JXpZ0\/mXVr4e1yWRyBwBaQQdBBBB4EKa5xmmnZnaqXMCqXAqlwKoCPX5lpZLNUF\/WPH9OKjiD7Tu63ma7io51oxOlhdk4nEZpbq5vLwWrNfc8VpvAtntY6uzAh0dmFfSHSHyk4uaNIBoDgaU72kd6pnLTkWcTOhgU6WHe9U0c+XVHk+fLnfSYVU5xBVAKoCnekbKH7TP1UZrFCSBTQ+TQ5+8Dujmdao16m9Ky0R7fYuC\/j0d+a+aXkuC+77uRESoDs3J10T3F1s5tLx2IcG7DKR+1prxc1WcLC8t58DhbdxnR0lRjrLXs\/L9GXAugePCAIDztMDZGOY9oc1wLXNOggihB5LDSaszaE5QkpRdmihspLmfY7Q6F1SBixx9dh7p46jvB3Ll1IOErHusJio4mkqi71yf7p1GsWhZubfJi\/HWOYSDFho2RnibtHtDSOY1renPcdynj8HHFUtx6rR8n7Pj+C6LLamSMbJG4OY4AtcNBCvppq6PC1KcqcnCSs0etVk0FUBrr8ueG1x9XK33XDB7DtafpoOtazipKzLOFxdXDT36b7VwfaVXlFktPZCXEZ8WqVowHvj1D8N6pTpuPYewwW0qOKVllLk\/tz9eo0VVGdC4QXCC5wguZFht80JrDK+PX2HEA8WjA81lSa0ZFVo06qtUin2o3tmy8tzBQyMf78bf2ZqkVeaOfPY2Dk8otdj97mUOki2eCz\/kk+XWLb+RPqIv7BwvOXiv\/AFPCbpCtzhgYmb2R4\/rc5Y6eZJHYeEX+p9r9kjUT3nbLW4Rulllc7ARtJoeMbaNpvIwUblOeVy7HD4XCx31GMUuP5eZN8lMgmxFstqo54xbEMWMOou8bt2gb8CrFOhbOR5\/aG23UvToZLi+L7OS8+wndVZPPnFUAqgIX0iZUdQw2eF3pnjtOB+6Yd+p7ho2DHZWvXq7q3Vqd3Y2zumn01RfKtOt+y4+HMqeipHsbnvYLE+eVkUQq97s1o37TsAFSTsBW0YuTsjSrWhSg5z0R9BXBdLLJAyCPQ0YnW5xxc47ySV1YQUI2R4DFYiWIqupLj5LgjYLcrhAEAQEey1ycFtgo2gmZUxOO3WwnwuoOBAOpQ1qW\/HrL+z8a8NUu\/pevv2r8FJyxuY4tcC1zSQ5pwIIwII21XMeWTPZRkpJNO6OqGbklyNyodZHZklTA44jSYz42jZtbzGOmWlV3MnocvaWzlio70Mprz6n9n3PLS2IZ2vaHMcHNcAQ4GoIOgg61dTueOlGUW4yVmjvVDUVQHBQXItfWQ1mmq6P0Lz4BVhO+PV+EhQzoxemR18NtqvSyn8y69fH3uQ28sibZF3WCVu2M1PNhoa8KqCVGaO5Q2xhqmr3X1++noR+0QujNJGOYdj2lp8nBRPLU6UJxmrwafY7+h51Q2CC51LhtS5nM2NhuK1Tfd2eQjaW5rfzvoPitlCT0RVq43D0vrmvG78Fdkquno5eaG0yho8EWJPGRwoOQPFTRw\/8AqZyMRt+Kyoxv1v2XuuwnN1XTBZm5sMYYDpOlzveecXc1YjFR0PP4jFVcRLeqyv6LsWhm1WxAKoBVARvLHKttjZmMo6dw7LdTB437tg18KlRVaqgus6mzdmyxUt6WUFq+fUvu+BT88znuc97i5ziS5x0knSSqLd82e1hGMIqMVZLRHkSsG5cHRpkqbPH9ombSaRvZaRjFHpoRqc7AnZQDaujhqO6t56s8ntfaHTS6KD+Veb9lw8eROVaOIEAQBAEAQEH6Qcj\/ALQDaIG+mA7bB\/VaNY9sDRtGGoKriKG980dfU7OzNo9F\/dVH8vB8vx6a8yqFzz09wgub\/JfKiSxnNNXwk1LK4tOtzCdB3aDu0qWnVcOw5uP2dDFK6ylz+z99V5Fp3beUVoYJInhzT5g7HDSDuKuRkpK6PI16FSjPcqKz\/dDKqskIqgFUAqgOHgEUIqNhxHkhlNrNGBNclleaus0JO0xMr50WrhF8EWI43ERVo1JeLPMZO2P\/ALWD\/CYfosdHDkjb+fiv+5LxZm2exxR\/dxMZ7jGt+QWySWhBOtUn9cm+1tnvVZIxVAKoBVAKoCH5WZbMgrFZyHy4gu0sj4+J27QNewwVKyWUdTt7P2RKtapWyjy4v2XX4cyr55nPcXvcXOcauc41JO0lU2282esjGMIqMVZLRHmUNrlh9HGRueW2u0N7Ao6GM+udUrh4fCNenRStzDUL\/PLuODtXaW6nQpPPi+XV28\/AtRXzzQQBAEAQBAEAQEFy5yI6\/OtFmAE2l8eAEu8ag\/4HXtVSvh975o6nZ2ftLorU6v08Hy\/HoVU9hBIcCCCQQQQQRpBB0HcqB6NSTV0cLBm5l3ZeMtnfnwvLXa9jhsc3QQtoycXdENehTrx3KiuvTsLCuLLqGWjZ6RP8X9N34vU54b1ZhXT1yPNYvY9Wn81L5l5\/nu8CWNeCKg1B0EaDzU9zjPLJnNUAqgFUAqgFUAqgOKoBVAKoDX3vfcFmFZpA06mjF7uDBjz0LSU1HUs4fCVsQ7U436+HiV1lFltNaKsirDEdND6R49pw7o3DzKqzrOWSPTYLZFKh80\/ml5LsXHtfgiK0UJ17nBKGSxMhcgi\/NtFsbRmBZC4Yv2OkGpvs69eGBu0MNf5p+Bw9obV3b06Lz4vl2dfX4FphXzzYQBAEAQBAEAQBAEBGcrMjobYM8ejmAwkAwdsbIPWG\/SOGCgrUI1M9GX8HtCeH+XWPL2Kkvi557K\/q52Fp1HSx42sdr+Y1gLmzhKDtI9LRxFOtHeg7+q7TAWhNcILmwuq+rRZvupC0eA4sP4DgOIoVtGco6FbEYSjX\/wASN3z4+JLbu6QxgJ4fxRGo\/I44eZU8cRzRxq2w+NKXc\/dexIbHlTY5NE7WnZJWM\/rpXkpVVg+JzKmzsTT1g32Z+hto5Q4VaQRtBBHmFvcpyTjk0dqoYFUBzVDFzDtd6wRfeTRs3Oe0HyrUrVzS1ZPTw9ap9EW+40Vvy8srMGZ8p9lua3m59PgCo3XitDoUtjYif1Wj25+hFb0y6tUuEebC32MX\/nP0AUMq8npkdehsfD085\/M+vTw92yMyPLiXOJJOkkkk7yTiVFc6yslZaHRYM3Pew2KSZ4jhY57zoa0Y8TqA3nBbRi5OyNJ1Y04703ZFrZH5AMs5E1ppJMKFrdMcR2ivedvOjUNa6FHDKOcs2edxu1JVfkp5R837InCtnICAIAgCAIAgCAIAgCAIDHt9hjmYY5WNew6WuFRxGw7wsSipKzN6dSVOW9B2ZXOUPRq5tX2N2cP7KQ0cNzJDgeDqcSqFXCPWHgdvD7WTyrLvX3Xt4EDtlkkicWSscxw9V4IPEV0jeMFTacXZnXhUjNb0XdHisG1wgucILnLCWmoNDtGB8wgburMyW3nONE8w4SyD5FZ3nzZC6FF6wj4L2Oxva0\/9zP8A40n\/ALJvy5vxH8ah\/wBuP\/xXseE1qkf35Hu957nfMrF2bxhCP0xS7EjwAWCTeCC5wgudoo3OcGtaXOOhrQS47g0YlZV27IOSSu9Ca5P9G88tHWk9SzwihlP0Zzqdyt08JKWcsvU5eI2tThlT+Z+X5\/cyzbmuWCyszIIw0azpc47XOOJV+FOMFaKODWxFStLem7mwW5CEAQBAEAQBAEAQBAEAQBAEAQGNb7BFO3MmjbI3Y5oPMV0HetZRUlZo3p1J03eDsyG3r0ZWd9TBI+I+E+kZ8TnD8xVWeDi\/pdjp0trVI5TV\/J+3kRS8Oj63R91jZRtjeK03tfQ8hVVpYWotMy\/T2nQlq7dv4uR613bPF97DIymt7HNHmRQqCUJR1TLkK0J\/TJPvMQOG1aXJDlZMXOEFzglYuZPay2SSX7qN8nuMc\/8A8QVsoylojWVSMfqaXa7G\/sGQlvl\/oiMeKVwb+kVd8FPHC1ZcLdpUntHDw\/zX7P2xKrq6LoxQ2idz\/YjGY3gXGpI4UVmGCS+plCrteTypxt25\/vmTW6rls9mFIIms2kCrj7zzi7mVahTjD6UcyrXqVXebuZ63IQgCAIAgCAIAgCAIAgCAIAgCAIAgCAIAgCArPL31uf0VLEaM7OB4FcrmnZCGSYZDaRx\/hXcNoc3HFvw90cAuijz71O6yYCAIAgCAIAgCAIAgCAID\/9k=)","8e9922c0":"SARS in 2003 outbreak seems to have much in common with current COVID-19 outbreak. Hence, use additional SARS data for training.","f3636542":"# Encoding","ddaebdfa":"#### Lags\n  We use a 10-day-lag window to estimate the future development","8aa706f5":"Out-of-sample prediction with 5-steps (days)","63a2334e":"# Bayesian Neural network","66ac87d1":"Use a model which is comprising some categorical informations (via embedding layers) and a LSTM structure to learn the time-dependent behavior.","1d40679b":"# Saving the output","ac1ea990":"* Out-of-sample prediction with 3-steps (days)","a1b9a311":"# Estimate the confirmed covid-19-cases in Tunisia for up to 2 weeks in future with LGBM and Keras\n* based on global (country\/region-wise) developments of confirmation rates including covid_19 and sars_03 outbreaks\n* Updated daily\n\n","359d6166":"# Feature engineering","c3552538":"### Remove countries with minor confirmation numbers","a87c220c":"# LGBM","2e002d70":"# Neural network (KERAS-based)","4692d50e":"# Seeing things in a simple way\n* Visualisation"}}