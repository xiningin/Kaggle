{"cell_type":{"9a66137c":"code","a0901280":"code","dacc230f":"code","eea6282c":"code","298d529b":"code","f7e0fa7d":"code","8be847eb":"code","8859bf65":"code","6bf9ca9e":"code","a5c72e3a":"code","9a64390f":"code","daa89975":"code","1f55ae6a":"code","a0a40274":"code","24f5403e":"code","7294796e":"code","46eda569":"code","e4ddf93d":"code","643dbdb8":"code","1600fc5b":"code","d59173aa":"code","0bf937ee":"code","de74c872":"code","3e0e5b28":"code","ce45fa68":"code","8eb144f6":"code","88c66bad":"code","4ca91ca6":"code","781632e8":"markdown","b5768b7d":"markdown","73926db7":"markdown","7c43c4cf":"markdown","24f8b2f3":"markdown","8787a9d5":"markdown","6a2b5c0b":"markdown","a7e8b1e1":"markdown","fb536ab2":"markdown","cbe75c56":"markdown","2664953d":"markdown","551cfcca":"markdown","cc2ba1d4":"markdown","f2373217":"markdown","e79c5837":"markdown","07c82700":"markdown","45acaa0c":"markdown","b39a2e0c":"markdown","81153c97":"markdown","9b4f631b":"markdown","6e3f2485":"markdown","060424e7":"markdown","74d11a44":"markdown"},"source":{"9a66137c":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport matplotlib\nimport matplotlib.style\nimport matplotlib as mpl\nmpl.style.use('classic')\nfrom mpl_toolkits.mplot3d import Axes3D","a0901280":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","dacc230f":"train = pd.read_csv(\"\/kaggle\/input\/ventilator-pressure-prediction\/train.csv\")\ntest = pd.read_csv(\"\/kaggle\/input\/ventilator-pressure-prediction\/test.csv\")\nsubmission = pd.read_csv(\"\/kaggle\/input\/ventilator-pressure-prediction\/sample_submission.csv\")","eea6282c":"train","298d529b":"test","f7e0fa7d":"submission","8be847eb":"sns.displot(train['pressure'])","8859bf65":"target = train['pressure']\nprint(\"Minimum value: \", target.min())\nprint(\"Maximum value: \", target.max())\nprint(\"Average value: \", target.mean())\nprint(\"Standard deviation: \", target.std())","6bf9ca9e":"combi = train.drop(['pressure'], axis=1).append(test)\ncombi","a5c72e3a":"combi.drop(['id'],axis=1, inplace=True)\ncombi","9a64390f":"corrmat = combi.corr()\nf, ax = plt.subplots(figsize=(12, 9))\nsns.heatmap(corrmat, vmax=.8, square=True);","daa89975":"combi.isnull().sum()","1f55ae6a":"#combi = (combi - combi.min()) \/ (combi.max() - combi.min())\n#combi","a0a40274":"combi = (combi - combi.mean()) \/ np.std(combi)\ncombi","24f5403e":"y = target\nX = combi[: len(train)]\nX_test = combi[len(train) :]\n\ny = np.array(y, dtype=np.float32)\nX = np.array(X, dtype=np.float32)\nX_test = np.array(X_test, dtype=np.float32)\nX.shape, y.shape, X_test.shape","7294796e":"# Visualize our data\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = X[:,3]\ny = y\n\nplt.scatter(x, y)\nplt.show()","46eda569":"#try:- https:\/\/www.analyticsvidhya.com\/blog\/2020\/10\/perform-regression-analysis-with-pytorch-seamlessly\/\nimport torch\nimport torch.nn as nn ","e4ddf93d":"X_tensor = torch.from_numpy(X.reshape(X.shape[0],X.shape[1]))\nX_test_tensor = torch.from_numpy(X_test.reshape(X_test.shape[0],X_test.shape[1]))\ny_tensor = torch.from_numpy(y.reshape(y.shape[0],1))\n\nX_tensor.shape, y_tensor.shape, X_test_tensor.shape","643dbdb8":"input_size = 6\noutput_size = 1","1600fc5b":"model = nn.Linear(input_size , output_size)","d59173aa":"learning_rate = 0.0001\nl = nn.MSELoss()\noptimizer = torch.optim.SGD(model.parameters(), lr =learning_rate )","0bf937ee":"num_epochs = 10000\n\nfor epoch in range(num_epochs):\n    #forward feed\n    y_pred = model(X_tensor.requires_grad_())\n\n    #calculate the loss\n    loss= l(y_pred, y_tensor)\n\n    #backward propagation: calculate gradients\n    loss.backward()\n\n    #update the weights\n    optimizer.step()\n\n    #clear out the gradients from the last step loss.backward()\n    optimizer.zero_grad()\n    \n    if (epoch+1)%100 == 0:\n        print('epoch:', epoch+1,',loss=',loss.item())\n","de74c872":"prediction = model(X_tensor).detach().numpy()\nprediction","3e0e5b28":"plt.scatter(X_tensor[:,3].detach().numpy()[:100] , y_tensor.detach().numpy()[:100])\nplt.plot(X_tensor[:, 3].detach().numpy()[:100] , prediction[:100] , \"red\")\nplt.xlabel(\"X\")\nplt.ylabel(\"y\")\nplt.show()","ce45fa68":"from sklearn.metrics import mean_squared_error\n\nrmse = mean_squared_error(y_tensor.detach().numpy(), prediction, squared=False)\nrmse","8eb144f6":"compare = pd.DataFrame({'actual': y, 'predicted': prediction.ravel()})\ncompare","88c66bad":"test_prediction = model(X_test_tensor).detach().numpy()\ntest_prediction","4ca91ca6":"submission['pressure'] = test_prediction\nsubmission.to_csv('submission.csv',index=False) # writing data to a CSV file\nsubmission = pd.read_csv(\"submission.csv\")\nsubmission\n","781632e8":"Graph","b5768b7d":"Import Pytorch","73926db7":"Graph","7c43c4cf":"Define layer","24f8b2f3":"Problem statement\n\nIn this competition, you\u2019ll simulate a ventilator connected to a sedated patient's lung. The best submissions will take lung attributes compliance and resistance into account.\n\nIf successful, you'll help overcome the cost barrier of developing new methods for controlling mechanical ventilators. This will pave the way for algorithms that adapt to patients and reduce the burden on clinicians during these novel times and beyond. As a result, ventilator treatments may become more widely available to help patients breathe.","8787a9d5":"Reshape","6a2b5c0b":"Predict on X","a7e8b1e1":"Combine","fb536ab2":"Normalise","cbe75c56":"Prepare submission","2664953d":"Read","551cfcca":"Heatmap","cc2ba1d4":"Drop id","f2373217":"Load","e79c5837":"Import","07c82700":"Training","45acaa0c":"Analyse target","b39a2e0c":"Linear regression","81153c97":"Predict on X_test","9b4f631b":"Define X and y","6e3f2485":"Check for missing values","060424e7":"Standardise","74d11a44":"Define loss and optimizer"}}