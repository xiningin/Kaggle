{"cell_type":{"7e934add":"code","4f220408":"code","9850ddce":"code","d44a26c1":"code","c61f3581":"code","8b654a03":"code","66bebf99":"code","ce79336e":"code","e90e1865":"code","bbd800a3":"code","51f70d59":"markdown","8d5eaa7e":"markdown","d79b2a0c":"markdown","d7e59ffe":"markdown","1ff9452b":"markdown","d3f87fff":"markdown","e070b9b3":"markdown"},"source":{"7e934add":"import os\nimport numpy as np\nimport pandas as pd\nfrom tqdm.auto import tqdm\ntqdm.pandas()\nimport Levenshtein\nimport cv2\nfrom PIL import Image\nfrom matplotlib import pyplot as plt\nimport seaborn as sns","4f220408":"%%time\n\ntrain = pd.read_csv('..\/input\/bms-molecular-translation\/train_labels.csv')\ntest = pd.read_csv('..\/input\/bms-molecular-translation\/sample_submission.csv')\n\ndef get_train_file_path(image_id):\n    return \"..\/input\/bms-molecular-translation\/train\/{}\/{}\/{}\/{}.png\".format(\n        image_id[0], image_id[1], image_id[2], image_id \n    )\n\ndef get_test_file_path(image_id):\n    return \"..\/input\/bms-molecular-translation\/test\/{}\/{}\/{}\/{}.png\".format(\n        image_id[0], image_id[1], image_id[2], image_id \n    )\n\ntrain['file_path'] = train['image_id'].progress_apply(get_train_file_path)\ntest['file_path'] = test['image_id'].progress_apply(get_test_file_path)\n\nprint(f'train.shape: {train.shape}  test.shape: {test.shape}')\ndisplay(train.head())\ndisplay(test.head())","9850ddce":"for i in range(5):\n    image = cv2.imread(train.loc[i, 'file_path'])\n    label = train.loc[i, 'InChI']\n    print(image.shape)\n    plt.imshow(image)\n    plt.title(label)\n    plt.show()","d44a26c1":"# 1 channel will be better for fast training\nimage = cv2.imread(test.loc[0, 'file_path'])\n# image = cv2.imread(test['file_path'])\n# image = Image.fromarray(np.uint8(image)).convert(\"L\")\nimage = Image.fromarray(np.uint8(image)).convert(\"RGB\")\n\nimage = 255 - np.asarray(image)\n# image = image[:, :, np.newaxis]\nprint(image.shape)\nplt.imshow(image)\nplt.show()","c61f3581":"%%time\n\ntrain['InChI_list'] = train['InChI'].progress_apply(lambda x: x.split('\/'))\ntrain['InChI_length'] = train['InChI_list'].progress_apply(len)\nInChI_df = train['InChI_list'].progress_apply(pd.Series)\ntrain = pd.concat([train, InChI_df.add_prefix('InChI_')], axis=1)\ndisplay(train)","8b654a03":"train.to_pickle('train.pkl')\ntest.to_pickle('test.pkl')","66bebf99":"def get_score(y_true, y_pred):\n    scores = []\n    for true, pred in zip(y_true, y_pred):\n        score = Levenshtein.distance(true, pred)\n        scores.append(score)\n    avg_score = np.mean(scores)\n    return avg_score","ce79336e":"# sample submission baseline\ny_true = train['InChI'].values\ny_pred = test['InChI'].values\nscore = get_score(y_true, y_pred)\nprint(score)","e90e1865":"# mode baseline\n\nmode_concat_string = ''\nfor i in range(11):\n    mode_string = train[f'InChI_{i}'].fillna('nan').mode()[0]\n    if mode_string != 'nan':\n        if i == 0:\n            mode_concat_string += mode_string\n        else:\n            mode_concat_string += '\/' + mode_string\nprint(mode_concat_string)\n\ny_true = train['InChI'].values\ny_pred = [mode_concat_string] * len(train)\nscore = get_score(y_true, y_pred)\nprint(score)","bbd800a3":"test['InChI'] = mode_concat_string\noutput_cols = ['image_id', 'InChI']\ndisplay(test[output_cols])\ntest[output_cols].to_csv('submission.csv', index=False)","51f70d59":"# Naive baseline","8d5eaa7e":"# Scoring function","d79b2a0c":"# Library","d7e59ffe":"# Submission","1ff9452b":"# Data Loading","d3f87fff":"# Preprocessing","e070b9b3":"# Quick EDA"}}