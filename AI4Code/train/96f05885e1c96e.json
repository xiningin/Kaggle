{"cell_type":{"0a3d12a8":"code","19750f3e":"code","cc346f54":"code","d75693cd":"code","5c00e89c":"code","6a2057a6":"code","d085be1a":"code","b6267ec0":"code","f9bfe6f4":"code","e56e5978":"code","e14e2878":"code","bdafe637":"code","ef90e8a9":"code","77c5b88c":"code","c3898a2f":"code","94ff20c2":"code","89bf15f2":"code","d98c29a5":"code","af69212e":"code","c50004e3":"code","13647d94":"code","41551086":"code","aabcc5f6":"code","96f541a9":"markdown","c388c50c":"markdown","b3c06708":"markdown","ef927a41":"markdown","075c66e1":"markdown","540f0e9e":"markdown","4c5e3510":"markdown","06c19d41":"markdown","880af0fb":"markdown","b71c619d":"markdown","8b8c691d":"markdown","c3cd9ef5":"markdown","5dc9289d":"markdown","90d82886":"markdown","fbad7b7a":"markdown","900b4473":"markdown","4a40b6b5":"markdown","74f25fcf":"markdown","13a5e0c4":"markdown","cc47f555":"markdown","084b3a39":"markdown"},"source":{"0a3d12a8":"import pandas as pd\nimport numpy as np  \nimport matplotlib.pyplot as plt  \n#import seaborn as seabornInstance \n#from sklearn.model_selection import train_test_split \nfrom tpot import TPOTClassifier\nimport sklearn.metrics as metrics\n%matplotlib inline","19750f3e":"#flightdata = pd.read_csv(\"https:\/\/introtomlsampledata.blob.core.windows.net\/data\/flightdelays\/flightdelays.csv\")\nflightdata = pd.read_csv(r\"..\/input\/flightdelays\/flightdelays.csv\")","cc346f54":"print(flightdata.shape)\nflightdata.columns","d75693cd":"flightdata.dtypes","5c00e89c":"flightdata.head(10)","6a2057a6":"#flightdata.describe()\ncarrierlist = list(flightdata.Carrier.unique())\ncarrierlist.sort()","d085be1a":"carrierdict = {carrierlist[i]: list(range(len(carrierlist)))[i] for i in range(len(carrierlist))} \nflightdata[\"Carrier\"] = flightdata[\"Carrier\"].replace(carrierdict) \nflightdata.Carrier.unique()","b6267ec0":"train = flightdata[flightdata[\"Month\"] < 10]\ntest = flightdata[flightdata[\"Month\"] >= 10]\nprint(train.shape, test.shape)","f9bfe6f4":"train = train.drop(\n    [\"Month\", \"Year\", \"Year_R\", \"Timezone\", \"Timezone_R\"], axis=1)\ntest = test.drop([\"Month\", \"Year\", \"Year_R\", \"Timezone\", \"Timezone_R\"], axis=1)\nprint(train.shape, test.shape)","e56e5978":"trainX = train.drop([\"ArrDel15\"],axis = 1)\ntrainy = train[\"ArrDel15\"]\nprint(trainX.shape,trainy.shape)","e14e2878":"testX = test.drop([\"ArrDel15\"],axis = 1)\ntesty = test[\"ArrDel15\"]\nprint(testX.shape,testy.shape)","bdafe637":"pipeline_optimizer = TPOTClassifier(generations=100, population_size=20, cv=5,\n                                    random_state=42, verbosity=2, max_time_mins = 60)\n\npipeline_optimizer.fit(trainX, trainy)","ef90e8a9":"predicted_classes = pipeline_optimizer.predict(testX)\naccuracy = metrics.accuracy_score(testy,predicted_classes)","77c5b88c":"accuracy","c3898a2f":"confusion = metrics.confusion_matrix(testy, pipeline_optimizer.predict(testX))\nprint(confusion)\n#[row, column]\nTP = confusion[1, 1]\nTN = confusion[0, 0]\nFP = confusion[0, 1]\nFN = confusion[1, 0]","94ff20c2":"# use float to perform true division, not integer division\nprint((TP + TN) \/ float(TP + TN + FP + FN))\nprint(metrics.accuracy_score(testy, pipeline_optimizer.predict(testX)))","89bf15f2":"classification_error = (FP + FN) \/ float(TP + TN + FP + FN)\n\nprint(classification_error)\nprint(1 - metrics.accuracy_score(testy, pipeline_optimizer.predict(testX)))","d98c29a5":"sensitivity = TP \/ float(FN + TP)\n\nprint(sensitivity)\nprint(metrics.recall_score(testy, pipeline_optimizer.predict(testX)))","af69212e":"specificity = TN \/ (TN + FP)\n\nprint(specificity)","c50004e3":"false_positive_rate = FP \/ float(TN + FP)\n\nprint(false_positive_rate)\nprint(1 - specificity)","13647d94":"precision = TP \/ float(TP + FP)\n\nprint(precision)\nprint(metrics.precision_score(testy, pipeline_optimizer.predict(testX)))","41551086":"# calculate the fpr and tpr for all thresholds of the classification\nprobs = pipeline_optimizer.predict_proba(testX)\npreds = probs[:,1]\nfpr, tpr, threshold = metrics.roc_curve(testy, preds)\nroc_auc = metrics.auc(fpr, tpr)\n\nplt.title('Receiver Operating Characteristic')\nplt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],'r--')\nplt.xlim([0, 1])\nplt.ylim([0, 1])\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')\nplt.show()","aabcc5f6":"# IMPORTANT: first argument is true values, second argument is predicted probabilities\nprint(metrics.roc_auc_score(testy, preds))","96f541a9":"Calculating the accuracy using the confusion matrix.","c388c50c":"Predicting, calculating the Accuracy and taking a look at the model coefficients.","b3c06708":"Calculating the sensitivity using the confusion matrix.","ef927a41":"Initialising our classifier and fitting.","075c66e1":"Calculating the precision using the confusion matrix.","540f0e9e":"Splitting into test and train dataset.","4c5e3510":"Creating a dictionary using dictionary comprehension.\n\nParsing the dictionary to replace() method to find and replace \"keys\" with \"values\".\n\nMore on Dictionary Comprehensions: https:\/\/www.programiz.com\/python-programming\/dictionary-comprehension","06c19d41":"Looking at the top 10 records in the dataset.","880af0fb":"Plotting the ROC curve","b71c619d":"Here, we are encoding the \"Carrier\" categorical column.\n\nunique() is used to find out the unique values in a DataFrame column.\n\nsort() is used to sort the list.","8b8c691d":"Calculating the specificity using the confusion matrix.","c3cd9ef5":"Using a predownloaded dataset instead of the link as the dataset is huge and there has been some download issues","5dc9289d":"Calculating the roc_auc_score\n","90d82886":"Calculating the confusion matrix.","fbad7b7a":"Dropping the \"Month\", \"Year\", \"Year_R\", \"Timezone\", \"Timezone_R\" columns from the test and train datasets.\n","900b4473":"Importing the required libraries:\n\n\n* pandas: For reading and manipulating our dataset\n* numpy: Used for working on arrays\n* matplotlib: For plotting\n* TPOT: An Automated ML Library.\n* sklearn.metrics: Importing this will enable us to use different metrics for evaluating our model","4a40b6b5":"Calculating the false positive rate using the confusion matrix.","74f25fcf":"Having a first glance at the data. shape, columns and dtypes attributes are used.","13a5e0c4":"Calculating the classification error using the confusion matrix.","cc47f555":"<h1>Lab7: Train a simple classifier with Automated ML<\/h1>\n\nIn this lab, we will be using the Flight Delays data set that is enhanced with the weather data. Based on the enriched dataset, we will learn to use the Python and Jupyter Notebook to process data, build, train, score, and evaluate a classification model to predict if a particular flight will be delayed by 15 minutes or more.\n\nAutomated machine learning picks an algorithm and hyperparameters for you and generates a model ready for deployment. We are using TPOT which is an ensemble based Automated ML library which uses genetic algorithms for optimisation.\n\nMore on TPOT: http:\/\/epistasislab.github.io\/tpot\/\n","084b3a39":"Creating trainX, trainy, textX and testy."}}