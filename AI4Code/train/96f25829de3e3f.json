{"cell_type":{"2f4ae04f":"code","d399eae5":"code","f292c792":"code","59afdc2f":"code","794b946f":"code","81bea7d0":"code","9bc75333":"code","0c24f5cf":"code","3e0ac074":"code","9e2c02e3":"code","d1a9a9ee":"code","ea146336":"code","cd91d47b":"code","c0038776":"code","8d7ccb62":"code","7cab862f":"code","e9c07d01":"code","fda077e0":"code","3a2a7af5":"code","77afe614":"code","51f27626":"code","de33a7e1":"code","fc193c86":"code","6241c3ec":"code","cc5a5941":"markdown","e10dc22c":"markdown","a2c95de1":"markdown","46628517":"markdown","b021571d":"markdown","bb9d05f0":"markdown","181dd7cb":"markdown","5760e44e":"markdown","20fe7d55":"markdown"},"source":{"2f4ae04f":"import numpy as np\nimport pandas as pd\nimport os\nfrom scipy import stats\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\n# Importing Classifier Modules\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC, LinearSVC\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import Perceptron\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.metrics import precision_recall_fscore_support\nimport joblib\n\nimport warnings\nwarnings.filterwarnings('ignore')","d399eae5":"# Loading data\ndf=pd.read_csv(\"..\/input\/run-or-walk\/dataset.csv\")","f292c792":"new_df = pd.DataFrame()\nnew_df = df.copy()\n\nnew_df = new_df.drop(\"date\", axis = 1)\nnew_df = new_df.drop(\"time\", axis = 1)\nnew_df = new_df.drop(\"username\", axis=1)\nnew_df.head()","59afdc2f":"new_df.shape","794b946f":"new_df.info()","81bea7d0":"new_df = new_df.drop(\"activity\", axis=1)\nnew_df[\"label\"] = df[\"activity\"]\nnew_df.head()","9bc75333":"#Split training and testing dataset\ny = new_df[\"label\"]\nx = new_df.iloc[:,0:7]\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, \n                                                    train_size=0.7, \n                                                    random_state=42)\n\nprint(f\"Train labels:\\n{y_train}\")\nprint(f\"Test labels:\\n{y_test}\")","0c24f5cf":"df_a = x_train\ndf_b = y_train\ntraining_data = pd.concat([df_a,df_b],axis = 1, join = \"inner\")\ntraining_data","3e0ac074":"testing_data = pd.concat([x_test,y_test], axis = 1, join = \"inner\")\ntesting_data","9e2c02e3":"training_data.to_csv(os.getcwd() + \"\/training.csv\", index = False)\ntesting_data.to_csv(os.getcwd() + \"\/testing.csv\", index = False)","d1a9a9ee":"#reload training data\n\ntrain_df=pd.read_csv(os.getcwd() + '\/training.csv')\ntrain_df.head()","ea146336":"#new_train_df = train_df.copy()\nnt_df = train_df.copy()\n\n# split training and testing data in the training set for model training process\nY = nt_df[\"label\"]\nX = nt_df.iloc[:,0:7]\n\ntrain_x, test_x, train_y, test_y = train_test_split(X, Y, \n                                                    train_size=0.7, \n                                                    random_state=42)","cd91d47b":"#Training models\n\ndef fit_model (model):\n    classifier = model()  #train with default model parameters\n    classifier.fit(train_x, train_y)\n    print(\"training accuracy is:\",classifier.score(train_x, train_y))\n    print(\"testing accuracy is:\",classifier.score(test_x, test_y))   \n    return classifier\n\n# the fit_model function will return the mean accuracy of given test data and labels","c0038776":"# calculate precision, recall, fscore, and support score for the model\ndef prfs (trained_model):\n    pred_label = trained_model.predict(test_x)\n    print(\"When positive class refers to \\\"running\\\", the precision, recall, f_measure and support for the model is :\",\n          precision_recall_fscore_support(test_y, pred_label, average = \"binary\"))","8d7ccb62":"#SVC\nsvc = fit_model(SVC)\nprfs(svc)","7cab862f":"#decision tree\ndt = fit_model(DecisionTreeClassifier)\nprfs(dt)","e9c07d01":"#random forest\nrf = fit_model(RandomForestClassifier)\nprfs(rf)","fda077e0":"#logistic regression\nlr = fit_model(LogisticRegression)\nprfs(lr)","3a2a7af5":"#gradient boosting model\ngb = fit_model(GradientBoostingClassifier)\nprfs(gb)","77afe614":"#stochastic gradient decient model\nsgd = fit_model(SGDClassifier)\nprfs(sgd)","51f27626":"#perceptron classifier\nperceptron = fit_model(Perceptron)\nprfs(perceptron)","de33a7e1":"#naive baysian classifier:\nnb = fit_model(GaussianNB)\nprfs(nb)","fc193c86":"#!\/usr\/bin\/env python3\n\nimport socket\nimport threading\nimport csv\nimport json\nimport argparse\nimport sys\nimport time\nimport datetime\n\n\nclass ThreadedServer(object):\n    def __init__(self, host, opt):\n        self.device = {}\n        self.device['NoMode'] = {'points': 0}\n        self.device['label'] = {'label': 0, 'points': 0}\n        self.host = host\n        self.port = opt.port\n        self.opt = opt\n        self.state = self.device[opt.mode if opt.mode else 'NoMode']\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.sock.bind((self.host, self.port))\n        self.lock = threading.Lock()\n        self.check = -1\n\n    def listen(self):\n        self.sock.listen(5) # server prepares a queue of 5\n        while True:\n            client, address = self.sock.accept()\n            print(f'Connection from {address} has been established! ')\n            client.settimeout(500)\n            threading.Thread(target=self.listenToClient, args=(client, address)).start()\n            threading.Thread(target=self.sendStreamToClient, args=\n            (client, self.sendCSVfile())).start()\n\n    def handle_client_answer(self, obj):\n        if self.opt.mode is not None and self.opt.mode == 'label':\n\n            if 'label' not in obj:\n                return\n            self.lock.acquire()\n            if self.state['label'] == int(obj['label']):\n                self.state['points'] += 1\n                self.check = 1\n            else:\n                self.check = 0\n            self.lock.release()\n        return\n\n    def listenToClient(self, client, address):\n        size = 1024\n        total = 0\n        while True:\n            try:\n                data = client.recv(size).decode()\n\n                if data:\n                    # Set the response to echo back the recieved data\n\n                    a = json.loads(data.rstrip('\\n\\r '))\n                    self.handle_client_answer(a)\n                    total += 1\n                    print(f\"Correctly predicted: {self.state['points']} records.\")\n                    print(f\"Accuracy rate: {self.state['points']\/total*100}%\")\n                    # client.send(response)\n                else:\n                    print('Client disconnected')\n                    return False\n            except:\n                print(f\"so far we have {self.state['points']} points\")\n                print('Client closed the connection')\n                print(\"Unexpected error:\", sys.exc_info()[0])\n                client.close()\n                return False\n\n    def handleCustomData(self, buffer):\n        if self.opt.mode is not None and self.opt.mode == 'label':\n            self.lock.acquire()\n            #buffer['date'] = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            self.state['label'] = int(buffer['label'])\n            buffer['label'] = self.check   # send check result\n            self.lock.release()\n\n    def sendStreamToClient(self, client, buffer):\n        for i in buffer:\n            print(i)\n            self.handleCustomData(i)\n            try:\n                client.send((self.convertStringToJSON(i) + '\\n').encode('utf-8'))\n                time.sleep(self.opt.interval)\n            except:\n                print('End of stream')\n                return False\n        client.send((self.convertStringToJSON(self.state) + '\\n').encode('utf-8'))\n        return False\n\n    def convertStringToJSON(self, st):\n        return json.dumps(st)\n\n    def sendCSVfile(self):\n        out = []\n        for f in self.opt.files:\n            print('reading file %s...' % f)\n            csvfile = open(f, 'r')\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                out += [row]\n        return out\n\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser(usage='python tcp_server_project.py -p 9998 -f testing.csv -t 1 -m label')\n    #parser = argparse.ArgumentParser(usage='usage: tcp_server -p port [-f -m]')\n    #parser = argparse.ArgumentParser(usage='usage: tcp_server.py -p 9998 -f occupancy\/censortraining.csv -t 1')\n    parser.add_argument('-f', '--files', nargs='+')\n    parser.add_argument(\"-m\", \"--mode\", action=\"store\", dest=\"mode\")\n    parser.add_argument(\"-p\", \"--port\", action=\"store\", dest=\"port\", type=int)\n    parser.add_argument(\"-t\", \"--time-interval\", action=\"store\",\n                        dest=\"interval\", type=int, default=1)\n\n\n    opt = parser.parse_args()\n    #host = opt.host\n    #port = opt.port\n    if not opt.port:\n        parser.error('Port not given')\n    ThreadedServer('localhost', opt).listen()\n\n'''\n{\"wrist\": \"0\", \"acceleration_x\": \"0.265\", \"acceleration_y\": \"-0.7814\", \"acceleration_z\": \"-0.0076\",\n\"gyro_x\": \"-0.059\", \"gyro_y\": \"0.0325\", \"gyro_z\": \"-2.9296\", \"label\": \"0\"}\n\n{\"CO2\": \"760.4\", \"Temperature\": \"23.718\", \"Light\": \"578.4\", \"Number\": \"141\",\n\"Occupancy\": \"1\", \"Humidity\": \"26.29\", \"HumidityRatio\": \"0.00477266099212519\",\n\"date\": \"2015-02-02 14:19:59\"}\n\n'''","6241c3ec":"import socket\nimport sys\nimport json\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier\nimport os\n\n# train the model\ntrain_df=pd.read_csv(os.getcwd() + '\/training.csv')\nnt_df = train_df.copy()\nY = nt_df[\"label\"]\nX = nt_df.iloc[:,0:7]\n\ndef fit_model (model):\n    classifier = model(n_estimators=100)  #train with default model parameters\n    classifier.fit(X, Y)\n    return classifier\n\nrf = fit_model(RandomForestClassifier)\n\nHOST, PORT = \"localhost\", 9998\n# data = \" \".join(sys.argv[1:])\n#list_numbers=[]\n\npredict_list = []\ncurrent_act = 0\ntimes = 0\ncorrect = 0\n# Create function to handle the received dictionary\ndef handle_dict_predcit(dct):\n    values = list(dct.values())\n    col = list(dct.keys())\n    predict_df = pd.DataFrame([values])\n    predict_df.columns = col\n    return predict_df\n\ndef predict_rf(df, model):\n    pred_cols = list(df.columns.values)[:-1]\n    pred = model.predict(df[pred_cols])\n    return int(pred)\n\ndef correct_error(indication):\n    global correct\n    global predict_list\n    if indication == 0:\n        old = predict_list[-1]\n        predict_list[-1] = abs(old-1)\n        print('Your previous prediction is wrong')\n    else:\n        correct += 1\n        print('Your previous prediction is correct')\n\ndef action_warning():\n    global predict_list\n    global current_act\n    global times\n    if current_act == predict_list[-1]:\n        times += 1\n    else:\n        current_act = predict_list[-1]\n        times = 1\n    if times >= 5:\n        if current_act == 1:\n            print('Healthy Warning: You run over 5 times, you should try to walk instead.')\n        else:\n            print('Healthy Warning: You walk over 5 times, you should try to run instead.')\n\ndef current_action(result):\n    if result == 1:\n        print('You might be running right now')\n    else:\n        print('You might be walking right now')\n\n# Create a socket (SOCK_STREAM means a TCP socket)\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n    sock.connect((HOST, PORT))\n    cnt = 0\n    n = 50\n    while cnt<n:\n\n        print(cnt)\n        received = str(sock.recv(1024), \"utf-8\")\n        received = json.loads(received)\n\n        predict_df = handle_dict_predcit(received)\n        result = predict_rf(predict_df, rf)\n        current_action(result)\n        # correct previous predict result if wrong and give healthy warnings\n        if cnt > 0:\n            indication = list(received.values())[-1]\n            correct_error(indication)\n            action_warning()\n        predict_list.append(result)\n        if cnt == n-1:\n            print('Prediction Accuracy rate:', (correct \/ (n-1)) * 100, '%')\n        predict_result = {'label': result}\n        sock.send(json.dumps(predict_result).encode(\"utf-8\"))\n        cnt += 1\n    #sock.close()\n    #list_numbers.append(int(received))\n    #print(sum(list_numbers)\/len(list_numbers))\n","cc5a5941":"Overall, random forest is the best with best accuracy score and f_score; all models don't have overfitting problem.","e10dc22c":"# 1. Introduction\n\nIn this project, we are developing a streaming analytics system which aims to detect whether the person is running or walking and to prevent the person from repeating the same action for multipletimes by sending health warnings.\n\nWe will firstly have a predictive analysis and select the optimal model among multiple classifiers.\n\nThen we will create a TCP socket connection between the server and client, so that streaming data could be exchanged and implemented in each side.","a2c95de1":"# 4. TCP Client","46628517":"### Step 1: \nReceived predictor data as a dictionary\n\n### Step 2: \nUse the random forest model to predict current action and print out the result\n\n### Step 3: \nStarting from the second received information, the client will adjust the previous prediction according to the server response for the previous prediction, and the global variable *correct* will count accurate predictions.\n\n### Step 4:\nIn the meantime, \n*action_warning* function and global variable *current_act* and *times* will track if the user repeats the same action more than 5 times. If yes, the client will print out the healthy warning message to notify the user.\n\n### Step 5:\nFinally, after finishing the last prediction, the client will calculate the accuracy rate of all predictions and print it out. This will be a crucial indication of our model\u2019s performance.\n\n\n\n\n","b021571d":"# 2. Modeling\n\n","bb9d05f0":"The following [tcp_client_project] python script could be executed in the terminal by typing the command: \n\n***python3 tcp_client_project.py***","181dd7cb":"### Step 1: \nWe first load testing dataset from model preparation. Each row in the dataset is loaded into dictionary format like shown on the right.  \n\n### Step 2:\nWe store the actual run\/walk status into variable *state[\u2018label\u2019]*. We will use this to check if the prediction returned by client is valid in the future steps. \n\n### Step 3:\nWe encoded the streaming data as JSON format and send it to the client one row by a time. The server will print \u2018*End of stream*\u2018 when all data had been sent. \n\n### Step 4:\nWe use the *ListenToClient* function to receive the predictions returned by the client side. At the meantime, we show how many records we correctly predicted and the accuracy rate so far. \n\n### Step 5:\nThe *check* variable stores if previous prediction is correct\/incorrect. The server will send back this information to client on the next stream.\n\n\n\n","5760e44e":"The following [tcp_server_project] python script could be executed in the terminal by typing the command: \n\n***tcp_server_project.py -p 9998 -f training.csv -t 1 -m label***","20fe7d55":"# 3. TCP Server"}}