{"cell_type":{"2f10413d":"code","5a495bc6":"code","d2c6dcb0":"code","469ab0d9":"code","8ce121b9":"code","0b275dfd":"code","15261600":"code","25e46c98":"code","d6162f1c":"code","43cddfff":"code","7789fb38":"code","ea41f102":"code","ccc6c55f":"code","c9d02a18":"code","c71eb12a":"code","e69bcd86":"code","aaa6bb73":"code","4ca99c4a":"code","09f6bd2d":"code","4eaacf6a":"code","66b7f47c":"code","f846adf8":"markdown","d72e3927":"markdown","2680fe99":"markdown","f902ee40":"markdown","bac5beb7":"markdown","628f758d":"markdown","ccd8b3d9":"markdown","2062dee0":"markdown","608d45b1":"markdown"},"source":{"2f10413d":"%%time\n# installing ffmpeg so that animation module can work\n!apt-get -y install ffmpeg > \/dev\/null\n\nimport secrets  # python 3.6 necessary\nimport random\nimport numpy as np\nimport pandas as pd  # we try not to depend on pandas, to better translate later?\nfrom copy import deepcopy\nfrom IPython.display import display, HTML\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt  # for viz\n\nDEATH_RATE = 0.05\npd.set_option('display.max_rows', 100)","5a495bc6":"# defining utility functions which forms the basis of housing valuation\ndef utility_general(house):\n    '''\n    Every person considers a house to have a certain utility.\n    This is not based on personal perferences.\n    '''\n    utility_due_to_location = 2\/(1 + (house[\"location\"][0] - 5.3)**2 \n                                   + (house[\"location\"][1] - 5.3)**2)\n    return utility_due_to_location + house[\"amenities\"][\"fengshui\"]\n\ndef utility_function(person, house):\n    '''\n    A person considers each house to have a different utility.\n    This assigns an additional utility of each house based on personal preferences.\n    '''\n    utility_due_to_person = 1\/(1 + (house[\"location\"][0] - person[\"idio\"][\"preferred_location\"][0])**2 \n                                 + (house[\"location\"][1] - person[\"idio\"][\"preferred_location\"][1])**2)\n    return utility_general(house) + utility_due_to_person\n\n### Weets' Vectorised Utility Functions (works with pd.Series) ###\n# mere translation of above functions\n# its quite hardcoded so not comfortable rofl\n\ndef utility_general_vectorised(house):\n    '''\n    Every person considers a house to have a certain utility.\n    This is not based on personal perferences.\n    '''\n    utility_due_to_location = 2\/(1 + (house[\"location\"].apply(lambda tup: tup[0]) - 5.3)**2 \n                                   + (house[\"location\"].apply(lambda tup: tup[1]) - 5.3)**2)\n    return utility_due_to_location + house[\"amenities\"].apply(lambda amen_dt: amen_dt[\"fengshui\"])\n\ndef utility_function_vectorised(person, house):\n    '''\n    A person considers each house to have a different utility.\n    This assigns an additional utility of each house based on personal preferences.\n    Input\n        person: a dict or pandas df row\n    '''\n    # print(house[\"location\"])\n    # print(house[\"location\"].apply(lambda tup: tup[0]))\n    \n    xloc = (house[\"location\"].apply(lambda tup: tup[0]) - person[\"idio\"][\"preferred_location\"][0])\n    yloc = (house[\"location\"].apply(lambda tup: tup[1]) - person[\"idio\"][\"preferred_location\"][1])\n    \n    utility_due_to_person = 1\/(1 + xloc**2 + yloc**2)\n    return utility_general_vectorised(house) + utility_due_to_person","d2c6dcb0":"# defining a template person and generate persons\ndef generate_person():\n    person = {\n        \"age\": 20,\n        \"income\": 10,\n        \"wealth\": 400*np.random.uniform(),\n        \"house_staying\": np.NaN,\n        \"house_selling\": np.NaN,\n        \"utility\": 0, # WEETS: utility here is person's 'score'. Every decision person makes must immediately result in increase of 0 or more, never decrease.\n        \"idio\": {\"preferred_location\": (10*np.random.uniform(), 10*np.random.uniform())}\n    }\n    return person\n\npersons = {}\nfor _ in range(10):\n    persons[secrets.token_hex(4)] = generate_person()\npersons = pd.DataFrame.from_dict(persons, orient='index')\n\npersons['house_staying'] = persons['house_staying'].astype(object)\npersons['house_selling'] = persons['house_selling'].astype(object)\n\npersons.head()","469ab0d9":"# defining a template house and generate houses\nhouses = {}\nfor x in range(10):\n    for y in range(10):\n        houses[(x,y)] = {\n            \"location\": (x,y),  # also the key \n            \"last_bought_price\": 400*np.random.uniform(),\n            \"status\": \"empty\",  # \"empty\", \"occupied\", \"selling\" \n            \"amenities\": {\"fengshui\" : np.random.uniform()},\n            \"occupant\": np.NaN,\n            \"last_updated\": 0\n        }\n        houses[(x,y)][\"market_price\"] = houses[(x,y)][\"last_bought_price\"]\n\nhouses = pd.DataFrame.from_dict(houses, orient='index')\n\ndef status_to_float(status):\n    if status == \"empty\": return 0 \n    if status == \"occupied\": return 1 \n    if status == \"selling\": return 2\n    \nhouses.head()","8ce121b9":"def aging(verbose = False): # change this a function of age\n    persons[\"age\"] += 1\n    persons[\"wealth\"] += persons[\"income\"]\n    houses[\"last_updated\"] += 1","0b275dfd":"def dying_prob_function(age):\n    return 1.\/(1.+np.exp(-(0.2*(age-50))))\nplt.figure(figsize = (14,2))\nplt.plot([dying_prob_function(age) for age in np.arange(100)])\nplt.title(\"death probability over age\")\nplt.show()","15261600":"def dying(verbose = False): # change this a function of age\n    persons_id_dead = []\n    for person_id in persons.index:\n        if np.random.uniform() < dying_prob_function(persons.loc[person_id,\"age\"]):\n            if verbose: print(person_id, \" died\")\n            dead_person = persons.loc[person_id]\n            if dead_person[\"house_staying\"] != None:\n                if verbose: print(\"vacated \", dead_person[\"house_staying\"])\n                houses.loc[dead_person[\"house_staying\"],\"status\"] = \"empty\"\n                houses.loc[dead_person[\"house_staying\"],\"occupant\"] = None\n            persons_id_dead.append(person_id)\n    persons.drop(persons_id_dead, inplace=True)","25e46c98":"def birth(verbose = False):\n    born = np.random.binomial(10, 0.2)\n    for _ in range(born):\n        persons.loc[secrets.token_hex(4)] = generate_person()","d6162f1c":"from collections import defaultdict\nhistory = defaultdict(list)\n\ndef update_history(verbose = False):\n    history[\"popn_with_zero_house\"].append((persons.house_staying.values == None).sum())\n    history[\"popn_with_one_house\"].append((persons.house_staying.values != None).sum())\n    history[\"popn_with_two_house\"].append((persons.house_selling.values != None).sum())\n    history[\"average_wealth\"].append(np.mean(persons[\"wealth\"]))\n    return None","43cddfff":"def choose(person_id):\n    candidates = []\n    if persons.loc[person_id,\"house_staying\"] != None:\n        return None\n    for addr,house in houses.to_dict('index').items():\n        if house[\"market_price\"] > persons.loc[person_id,\"wealth\"]:\n            continue\n        if house[\"status\"] != \"empty\":\n            continue\n        candidates.append((addr,house))\n    \n    best = 0\n    best_option = None\n    for addr,house in candidates:\n        user_utility_on_house = persons.loc[person_id,\"utility\"](persons.loc[person_id], house)\n        if user_utility_on_house > best:\n            best = user_utility_on_house\n            best_option = addr,house\n    return best_option","7789fb38":"def allocation():\n    for person_id,v in persons.to_dict('index').items():\n        decision = choose(person_id)\n        if not decision:\n            continue\n        addr, house = decision\n        persons.loc[person_id,\"wealth\"] -= house[\"market_price\"]\n        persons.at[person_id,\"house_staying\"] = addr\n        houses.loc[addr,\"last_bought_price\"] = house[\"market_price\"]\n        houses.loc[addr,\"status\"] = \"occupied\"\n        houses.loc[addr,\"occupant\"] = person_id\n        houses.loc[addr,\"last_updated\"] = 0","ea41f102":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n# this is meant to be ran just once at the start\nask_df = pd.DataFrame(columns = ['location','occupant_id','amenities', 'ask_price']) # init empty ask_df with col\n            \ndef gen_asks():\n    ''' phase 2 bid-ask\n    1. Refresh ask_df pd.DataFrame()\n    2. Add empty houses from `houses` to ask_df\n    3. Add more listings from persons who can and want to sell houses\n    '''\n    global ask_df # may not be necessary\n    ask_df_columns = ask_df.columns.to_list() # ['house_pos','current_occupant_id','amenities', 'ask_price']\n    \n    # 1. Refresh ask_df pd.DataFrame()\n    ask_df.drop(ask_df.index, inplace=True) # drops all rows\n    \n    # 2. Add empty houses from `houses` to ask_df\n    empty_houses = houses[houses['status']=='empty']\n    \n    ## 2.1 Rename, reorder into ask_df column mold\n    ## ask_df column order: ['house_pos','current_occupant_id','amenities', 'ask_price']\n    empty_houses_listing = empty_houses.rename(columns={\n        'occupant':'occupant_id',\n        'last_bought_price':'ask_price',\n    })\n    empty_houses_listing = empty_houses_listing[ask_df_columns] # reorder\n    \n    ask_df = ask_df.append(empty_houses_listing, ignore_index=True) # TODO: optimise\n    \n    # 3. Add more listings from `persons` who can and want to sell houses\n    ## 3.1 get sub df of persons who have a second house to sell\n    COND_have_house_selling = persons['house_selling'] != None\n    potential_sellers = persons[COND_have_house_selling] # a persons sub df\n    \n    ## 3.2 Get sellable houses that have market price >= cost price\n    potential_house_selling_loc = potential_sellers['house_selling']\n    potential_house_selling = houses[houses['location'].isin(potential_house_selling_loc.values)]\n    COND_market_greater_or_equal_cost_price = potential_house_selling['market_price'] >= potential_house_selling['last_bought_price'] \n    no_loss_house_selling = potential_house_selling[COND_market_greater_or_equal_cost_price] # a houses subdf\n    \n    ## 3.3 Random decide if want to sell or not\n    PROBA_SELL = 0.4 # arbitrary threshold; TODO: turn into adjustable param\n    COND_want_sell = no_loss_house_selling['status'].apply(lambda runif: np.random.uniform()) <= PROBA_SELL\n    want_sell_houses = no_loss_house_selling[COND_want_sell]\n    want_sell_houses_loc = want_sell_houses['location']\n    actual_house_selling = potential_house_selling[potential_house_selling['location'].isin(want_sell_houses_loc.values)]\n    \n    ## 3.4 Rename, reorder actual_house_selling into ask_df column mold\n    ## ask_df column order: ['house_pos','current_occupant_id','amenities', 'ask_price']\n    main_listing = actual_house_selling.rename(columns={'market_price':'ask_price',\n                                               'occupant':'occupant_id'})\n    main_listing = main_listing[ask_df_columns]\n    \n    ask_df = ask_df.append(main_listing, ignore_index=True)\n    \n    # strangely, there's a row with nan value in location appearing\n    # this chunk fixes that\n    if any(ask_df['location'].apply(lambda loc: type(loc)!=tuple)):\n        # print('Missing location in ask_df, applying fix')\n        ori_len = len(ask_df)\n        ask_df = ask_df[~ask_df['location'].isna()]\n        # print('Change in len', len(ask_df)-ori_len)\n    \n    \n# test run\n# gen_asks()\n# ask_df.sample(10)","ccc6c55f":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n# init empty ask_df with col\nbid_df = pd.DataFrame(columns = ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price'])\n    \ndef gen_bids():\n    ''' phase 2 bid-ask\n    1. Refresh bid_df pd.DataFrame()\n    2. Generate subdf of persons who can and want to buy houses\n    3. For each eligible person, iterate over ask, grow person_bids list of dict\n    4. Merge \n    '''\n    global bid_df # may not be necessary\n    bid_df_columns = bid_df.columns.to_list() # ['location', 'bidder_id', 'utility', 'bid_price']\n    \n    # 1. Refresh bid_df pd.DataFrame()\n    bid_df.drop(bid_df.index, inplace=True) # drops all rows\n    \n    # 2. Screen viable bidders\n    ## 2.1 Does not own a second house (can have 1 or 0 houses)\n    COND_only_one_house = persons['house_selling'].isna() # NOTE: do not use `persons['house_selling'] == None` to check\n    potential_buyers = persons[COND_only_one_house]\n    \n    ## 2.2 Random decide if want to seek or not\n    PROBA_BUY = 0.8 # arbitrary threshold; TODO: turn into adjustable param\n    COND_want_buy = potential_buyers['age'].apply(lambda runif: np.random.uniform()) <= PROBA_BUY\n    eligible_and_seeking_buyers = potential_buyers[COND_want_buy] # these are the eligible people who want to buy houses\n    \n    # 3. Each eligible buyer makes a bid for each house on sale\n    list_of_bid_sets = [] # to be populated with df corr. to each person's bids\n    \n    ## 3.1 Define helper fn\n    def _gen_bid_price(listing_row):\n        max_bid_price = listing_row['max_bid_price']\n        ask_price = listing_row['ask_price']\n        if  max_bid_price >= ask_price:\n            surplus = max_bid_price - ask_price\n            return ask_price + np.random.uniform() * surplus\n        else:\n            return max_bid_price\n    \n    ## 3.2 Iterate over buyers\n    for idx, buyer in eligible_and_seeking_buyers.iterrows():\n        buyer_view_of_ask_df = ask_df.copy()\n        \n        ###  3.2.1 Calculate each listing's utility to buyer\n        buyer_view_of_ask_df['bidder_id'] = idx\n        buyer_view_of_ask_df['utility_to_buyer'] = utility_function_vectorised(buyer, buyer_view_of_ask_df)\n        # NOTE: utility_to_buyer is partial -- it only consider's a houses's general and locational utility and buyer idio\n        \n        ### 3.2.2 Calculate bid_price\n        buyer_view_of_ask_df['max_bid_price'] = buyer['wealth'] - buyer['utility'] + buyer_view_of_ask_df['utility_to_buyer'] # TODO: double check if this is a good rule\n        # NOTE: WEETS suspects above formula may be wrong since it does not compare the differential in utility DUE TO HOUSE only\n        # test: what if utility to buyer is negative? Would you still bid (and spend money)?\n        buyer_view_of_ask_df['max_bid_price'] = buyer_view_of_ask_df['max_bid_price'].apply(lambda mbp: min(mbp, buyer['wealth']))\n        # mbp must be capped at buyer's wealth\n        buyer_view_of_ask_df['max_bid_price'] = buyer_view_of_ask_df['max_bid_price'].apply(lambda mbp: max(0,mbp))\n        # mbp must be non-negative\n        \n        bid_price = buyer_view_of_ask_df.apply(_gen_bid_price, axis=1)\n        buyer_view_of_ask_df['bid_price'] = bid_price\n        \n        ### 3.2.3 Append specific columns of buyer_view_of_ask_df to list_of_bid_sets\n        select_columns = ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price']\n        list_of_bid_sets.append(buyer_view_of_ask_df[select_columns])\n    \n    # 4. Concatenate list of dataframes into one dataframe\n    if list_of_bid_sets: # possible that no bids take place\n        bid_df = pd.concat(list_of_bid_sets)\n    return bid_df\n\n# bid_df = gen_bids()\n# # print(bid_df['bidder_id'].nunique())\n# bid_df.head()","c9d02a18":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n\ndef match_ask_bid():\n    '''\n    1. Create a container list to store dicts of info relating to bidding for each listing\n    2. Iterate over listings in ask_df, find best bid - is successful match\n    3. For each successful match\n        1. Create and append dict of info relating to bids for the listing\n        2. Remove all bids for same listing\n        3. Remove all other bids by same bidder\n        4. Update asker and bidder\n    4. For each unsuccessful match\n        1. Create and append dict of info relating to bids for the listing\n        2. Remove all bids for same listing\n    5. Make match_df\n    '''\n    global bid_df, persons, houses\n    # 1. Create a container list to store dicts of info relating to bidding for each listing\n    list_of_matches = [] # contains info on winning bid\n    \n    # 2. Iterate over listings in ask_df, find best bid - is successful match\n    for idx, listing in ask_df.iterrows():\n        match_info_dict = {} # stats for each listing match\n        \n        ## 2.1 Get general data\n        listing_loc = listing['location']\n        match_info_dict['location'] = listing_loc\n        \n        match_info_dict['ask_price'] = listing['ask_price']\n        \n        relevant_bids = bid_df[bid_df['location']==listing_loc]\n        match_info_dict['num_bids'] = len(relevant_bids) # expect 0 or more\n        \n        highest_bid_value = relevant_bids['bid_price'].max()\n        match_info_dict['highest_bid_value'] = highest_bid_value\n        \n        match_info_dict['mean_bid_value'] = relevant_bids['bid_price'].mean()\n        \n        # 3. Found winning bid(s)\n        if highest_bid_value >= listing['ask_price']: # there exists a successful match\n            ## 3.1 Create and append dict of info relating to bids for the listing\n            ### 3.1.1 Check for ties among highest bid\n            highest_bids = relevant_bids[relevant_bids['bid_price']==highest_bid_value]\n            num_highest_bid = len(highest_bids) # expect at least 1, rarely more\n            assert num_highest_bid >= 1, 'ERR: num_highest_bid must be >= 1'\n            \n            ### 3.1.2 Get the winner\n            winning_bid = highest_bids.sample(1) # tie-breaker: randomly choose one highest bidder to win\n            \n            winning_bidder_id = winning_bid['bidder_id'].iloc[0]\n            match_info_dict['winning_bidder_id'] = winning_bidder_id\n            match_info_dict['winning_bid_value'] = highest_bid_value # obviously; stated explicitly as highest_bid_value may not win for the `else` case\n            \n            ### 3.1.3 Append match info\n            list_of_matches.append(match_info_dict)\n            \n            ## 3.2 Remove all corresponding bids, 3.3 Remove all other bids by same bidder\n            bid_df = bid_df.drop(relevant_bids.index, axis=0)\n            bid_df = bid_df[~(bid_df['bidder_id']==winning_bidder_id)]\n            \n            ## 3.4 Update asker and bidder\n            asker_id = listing['occupant_id']\n            \n            ### 3.4.1 Update asker\n            if type(asker_id) is str: # if str, then not empty house\n                persons['wealth'].loc[asker_id] += highest_bid_value\n                persons['house_selling'].iloc[asker_id] = np.NaN # potential problem here?\n                # TODO: check where to update 'utility' (person's simulation score) -- here or elsewhere?\n                # ENSURE: asker['utility'] increase or stay the same\n                \n            ### 3.4.2 Update bidder\n            winning_bidder = persons.loc[winning_bidder_id]\n            persons['wealth'].loc[winning_bidder_id] -= highest_bid_value\n            \n            #### Additional updates for bidder if second house buyer\n            if type(winning_bidder['house_staying']) is tuple: # first house exists, buyer is buying second house\n                persons['house_selling'].loc[winning_bidder_id] = winning_bidder['house_staying'] # set current house_staying to be house_selling\n                houses['status'].loc[winning_bidder['house_staying']] = 'selling' # set that same current house to 'selling' status\n            persons['house_staying'].loc[winning_bidder_id] = listing_loc\n            # TODO: check where to update 'utility' (person's simulation score) -- here or elsewhere?\n            # ENSURE: asker['utility'] increase or stay the same\n            \n            ### 3.4.3 Update house\n            houses['last_bought_price'].loc[listing_loc] = highest_bid_value\n            houses['status'].loc[listing_loc] = 'occupied'\n            # Note: for second house buyers, their first house's status has already been updated\n            houses['occupant'].loc[listing_loc] = winning_bidder_id\n            houses['last_updated'].loc[listing_loc] = 0\n            # TODO: update houses['market_price'] at the end of each time step, somewhere else perhaps\n            \n        # 4. No successful match   \n        else:\n            ## 4.1 Create and append dict of info relating to bids for the listing\n            match_info_dict['winning_bidder_id'] = np.NaN\n            match_info_dict['winning_bid_value'] = np.NaN\n            list_of_matches.append(match_info_dict)\n            \n            ## 4.2 Remove all bids for same listing\n            bid_df = bid_df.drop(relevant_bids.index, axis=0)\n            \n    # 5. Make match_df\n    match_df = pd.DataFrame(list_of_matches)\n    return match_df\n\n# gen_asks()\n# bid_df = gen_bids()\n# match_df = match_ask_bid() # Note: changes bid_df each time it is called\n# match_df.head(10)","c71eb12a":"persons","e69bcd86":"houses","aaa6bb73":"%%time\nfig, ax = plt.subplots(2,5,figsize=(12,7))\nplt.subplots_adjust(wspace=0.4)\nim0 = ax[0,0].imshow(np.random.randn(10,10), vmin=0, vmax=2)\nim1 = ax[0,1].imshow(np.random.randn(10,10), vmin=0, vmax=400)\nim2 = ax[0,2].imshow(np.random.randn(10,10), vmin=0, vmax=400)\nim3 = ax[0,3].imshow(np.random.randn(10,10), vmin=0, vmax=100)\nim4 = ax[0,4].imshow(np.random.randn(10,10), vmin=0, vmax=1)\nax[0,0].set_title(\"utility_general\")\nax[0,1].set_title(\"market_price\")\nax[0,2].set_title(\"last_bought_price\")\nax[0,3].set_title(\"last_updated\")\nax[0,4].set_title(\"status\")\n\nline_pop_0, = ax[1,0].plot([], lw=3)\nline_pop_1, = ax[1,0].plot([], lw=3)\nline_pop_2, = ax[1,0].plot([], lw=3)\nax[1,0].set_ylim((0, 60))\nax[1,0].set_xlim((-20, 0))\nax[1,0].set_title(\"population\")\n\nline_wealth_0, = ax[1,1].plot(range(len(history[\"average_wealth\"][-20:])), \n                              history[\"average_wealth\"][-20:], lw=3)\nax[1,1].set_ylim((0, 600))\nax[1,1].set_xlim((-20, 0))\nax[1,1].set_title(\"average wealth\")\n\nscat_income_age = ax[1,2].scatter([], [], s=20)\nax[1,2].set_ylim((0, 600))\nax[1,2].set_xlim((20, 60))\nax[1,2].set_title(\"wealth against age\")\n\npatches = [im0, im1, im2, im3, im4]\n\na1 = np.random.randn(10,10)\na2 = np.random.randn(10,10)\na3 = np.random.randn(10,10)\na4 = np.random.randn(10,10)\na5 = np.random.randn(10,10)\n\ndef update_plot():\n    for x in range(10):\n        for y in range(10):\n            a1[x,y] = utility_general(houses.loc[(x,y)])\n            a2[x,y] = houses.loc[(x,y),\"market_price\"]\n            a3[x,y] = houses.loc[(x,y),\"last_bought_price\"]\n            a4[x,y] = houses.loc[(x,y),\"last_updated\"]\n            a5[x,y] = status_to_float(houses.loc[(x,y),\"status\"])\n    im0.set_data(a1)\n    im1.set_data(a2)\n    im2.set_data(a3)\n    im3.set_data(a4)\n    im4.set_data(a5)\n    line_pop_0.set_data(range(0,-len(history[\"popn_with_zero_house\"][-20:]),-1), \n                        history[\"popn_with_zero_house\"][-20:])\n    line_pop_1.set_data(range(0,-len(history[\"popn_with_one_house\"][-20:]),-1), \n                        history[\"popn_with_one_house\"][-20:])\n    line_pop_2.set_data(range(0,-len(history[\"popn_with_two_house\"][-20:]),-1), \n                        history[\"popn_with_two_house\"][-20:])\n    line_wealth_0.set_data(range(0,-len(history[\"average_wealth\"][-20:]),-1), \n                           history[\"average_wealth\"][-20:])\n    scat_income_age.set_offsets(np.transpose((persons[\"age\"], persons[\"wealth\"])))\n\ndef init():\n    return patches\n\ndef next_time_step(i):\n    aging()\n    birth()\n    dying()\n    # allocation()\n    gen_asks()\n    gen_bids()\n    match_ask_bid()\n    update_history()\n    update_plot()\n    return patches\n\n# call the animator. blit=True means only re-draw the parts that have changed.\nanim = animation.FuncAnimation(fig, next_time_step, init_func=init,\n                               frames=100, interval=100, blit=True)\n\nvid = anim.to_html5_video()\nplt.close()","4ca99c4a":"HTML(vid)","09f6bd2d":"# def next_time_step(i):\n#     aging()\n#     birth()\n#     dying()\n#     # allocation()\n#     gen_asks()\n#     gen_bids()\n#     match_ask_bid()\n#     update_history()\n#     update_plot()\n#     return patches\n\n# for i in range(100):\n#     print('>>>>>>TIME STEP<<<<<<',i)\n#     next_time_step(i)","4eaacf6a":"persons","66b7f47c":"houses","f846adf8":"# Activities in timestep\nIn every time step, people age, people die, and people get born.","d72e3927":"# Transactions\nPeople without a house will try and buy the best house available to them.","2680fe99":"lifecycle of a person\n- born with a certain wealth\n- buys a house immediately\n- dies and goes nowhere (probability of death) \n\ncharacterisitics of a person\n- age\n- net income\n- wealth (which changes with purchases and net income)\n- satisfaction (an indicator which cumulates)\n- probability of death\n\nobjective of a person\n- maximise satisfaction\n\nobjective of the government\n- maximise satisfaction of all the people\n\nlifecycle of a house\n- empty initially\n- bought by a person\n- vacated when it is empty\n\ncharacteristics of a house\n- location and coordinates \n- occupancy\n- amentities\n\npricing mechanism\n- ???\n\nprocess of purchase\n- each person only know a limited number of choices\n- each person will get the option that is \n  - possible (house is empty and they have the money)\n  - best utility (x-factor for now)","f902ee40":"### Birth","bac5beb7":"# Initial state","628f758d":"# Begin simulation","ccd8b3d9":"### Death","2062dee0":"### Aging","608d45b1":"### Update history"}}