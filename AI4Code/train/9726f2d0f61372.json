{"cell_type":{"72a7afb2":"code","cf07f2e6":"code","cc0b42fd":"code","fd27b5fa":"code","7dbc6b6a":"code","49e2d77c":"code","d8442238":"code","ed9a27a9":"code","aabdad7f":"code","68c41027":"code","125e516e":"code","ba111111":"code","1fc682a4":"code","f80a927a":"code","7e29bd1e":"code","a16a16a3":"code","5998900e":"code","bfa1c8ec":"code","4a3439dc":"code","e5ff2a41":"code","cd394ecc":"code","e51221ef":"code","c892f3e5":"code","3c65706e":"code","f9f2fe16":"code","058add5f":"code","33d2e2eb":"code","08b5ec0d":"code","80b3f55c":"code","1a14b362":"code","7efb3f64":"code","6dc5e853":"code","d7c2afba":"code","bc639501":"code","ebc8fd72":"code","681d3b8c":"code","48ce4e51":"code","14302a2e":"code","971b1fb9":"code","1a8a2e5b":"code","8ab46f34":"code","035b520f":"code","f4c279e5":"markdown","10b47aca":"markdown","c2e8f3f4":"markdown","3a32e80d":"markdown","63278f9d":"markdown","c3fc73b9":"markdown","b2dbd6e6":"markdown","45c8c908":"markdown","5585f8a0":"markdown","91a5e190":"markdown","3cbd4b91":"markdown"},"source":{"72a7afb2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nfrom plotly import tools\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport plotly.plotly as py\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.graph_objs as go\n\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","cf07f2e6":"train = pd.read_csv(\"..\/input\/train.csv\")\nprint(train.shape)\ntrain.head()","cc0b42fd":"test = pd.read_csv(\"..\/input\/test.csv\")\nprint(test.shape)\ntest.head()","fd27b5fa":"\nmissing = train.isnull().sum().to_frame().sort_values(0, ascending = False)\nmissing.head()","7dbc6b6a":"def plot_pie(col,name):\n    levels = train[col].unique()\n    values = []\n    labels = []\n    for level in levels:\n        labels.append(level)\n        temp = train.loc[train[col] == level]\n        val = temp.Target.value_counts().sum()\n        values.append(val)\n        \n    \n    fig = {\n      \"data\": [\n        {\n          \"values\": values,\n          \"labels\": labels,\n#           \"domain\": {\"x\": [0,0]},\n          \"name\": name,\n          \"hoverinfo\":\"label+percent+name\",\n          \"hole\": .4,\n          \"type\": \"pie\"\n        }],\n      \"layout\": {\n            \"title\":name,\n            \"annotations\": [\n                {\n                    \"font\": {\n                        \"size\": 20\n                    },\n                    \"showarrow\": False,\n                    \"text\": col,\n                    \"x\": 0.5,\n                    \"y\": 0.5\n                }\n            ]\n        }\n    }\n    iplot(fig, filename='donut')\n#     return values,labels","49e2d77c":"plot_pie(\"Target\",\"Levels of Poverty\")","d8442238":"train.head()","ed9a27a9":"# train.drop([\"r4m3\",\"r4h3\",\"tamhog\",\"tamviv\",\"hhsize\",\"r4t1\",\"r4t2\",\"r4t3\",\"SQBescolari\",\"SQBage\",\"SQBhogar_total\",\"SQBedjefe\",\"SQBhogar_nin\",\"SQBovercrowding\",\"SQBdependency\",\"SQBmeaned\",\"agesq\"],axis=1,inplace=True)\n# train.shape","aabdad7f":"# test.drop([\"r4m3\",\"r4h3\",\"tamhog\",\"tamviv\",\"hhsize\",\"r4t1\",\"r4t2\",\"r4t3\",\"SQBage\",\"SQBhogar_total\",\"SQBedjefe\",\"SQBhogar_nin\",\"SQBovercrowding\",\"SQBdependency\",\"SQBmeaned\",\"agesq\"],axis=1,inplace=True)\n# test.shape","68c41027":"extreme = train.loc[train.Target == 1]\nmoderate = train.loc[train.Target == 2]\nvulnerable = train.loc[train.Target == 3]\nnon_vulnerable = train.loc[train.Target == 4]\n\ndef get_data(col):\n    extremes = extreme[col].value_counts().to_dict()\n    moderates = moderate[col].value_counts().to_dict()\n    vulnerables = vulnerable[col].value_counts().to_dict()\n    non_vulnerables = non_vulnerable[col].value_counts().to_dict()\n    y = [extremes[0],moderates[0],vulnerables[0],non_vulnerables[0]]\n    y2 = [extremes[1],moderates[1],vulnerables[1],non_vulnerables[1]]\n    return y,y2\n\ndef plot_bar(x,y,y2,name1,name2):\n    \n    trace1 = go.Bar(\n        x=x,\n        y=y,\n        text=y,\n        textposition = 'auto',\n        name=name1,\n        marker=dict(\n            color='rgb(158,202,225)',\n            line=dict(\n                color='rgb(8,48,107)',\n                width=1.5),\n            ),\n        opacity=0.6\n    )\n\n    trace2 = go.Bar(\n        x=x,\n        y=y2,\n        text=y2,\n        name = name2,\n        textposition = 'auto',\n        marker=dict(\n            color='rgb(58,200,225)',\n            line=dict(\n                color='rgb(8,48,107)',\n                width=1.5),\n            ),\n        opacity=0.8\n    )\n\n    data = [trace1,trace2]\n\n    iplot(data, filename='grouped-bar-direct-labels')\n    \n","125e516e":"x = ['extreme poverty ', 'moderate poverty ', 'vulnerable households ','non-vulnerable households']\ny ,y2= get_data(\"male\")  #\nplot_bar(x,y,y2,\"female\",\"male\")","ba111111":"y ,y2= get_data(\"dis\")  #\nplot_bar(x,y,y2,\"Not Disabled\",\"Disabled\")","1fc682a4":"\ndef single_bar(y,name):\n    trace0 = go.Bar(\n    x=x,\n    y=y,\n    marker=dict(\n        color='rgb(158,202,225)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5,\n        )\n    ),\n        opacity=0.6\n    )\n\n#     data = [trace0]\n#     layout = go.Layout(\n#         title=name,\n#     )\n\n#     fig = go.Figure(data=data)#, layout=layout)\n    return trace0\n    #     py.iplot(fig, filename='text-hover-bar')\n    \n# edu_feats = [\"instlevel1\",\"instlevel2\",\"instlevel3\",\"instlevel4\",\"instlevel5\",\"instlevel6\",\"instlevel7\",\"instlevel8\"]#,\"instlevel9\"]\n# figs = []\n# i = 0\n# for feat in edu_feats:\n#         print(i)\n#         y,y1 = get_data(feat)\n#         fig = single_bar(y,feat)\n#         figs.append(fig)\n#         i = i +1","f80a927a":"def pair_plots(col):\n    y = extreme[col].value_counts().to_dict()\n    y1 = moderate[col].value_counts().to_dict()\n    y2 = vulnerable[col].value_counts().to_dict()\n    y3 = non_vulnerable[col].value_counts().to_dict()\n    \n    trace1 = go.Bar(y=[y[0], y1[0], y2[0], y3[0]],\n                    name=\"Does Not Own\", \n                    x=x,\n                    marker=dict(\n                        color=\"rgb(158,202,225)\",\n                        opacity=0.6))\n    trace2 = go.Bar(y=[y[1], y1[1], y2[1], y3[1]],\n                    name=\"Owns\",\n                    x=x, \n                    marker=dict(\n                        color=\"rgb(58,200,225)\",\n                        opacity=0.6))\n    \n    return trace1, trace2 \n    \ntrace1, trace2 = pair_plots(\"v18q\")\ntrace3, trace4 = pair_plots(\"refrig\")\ntrace5, trace6 = pair_plots(\"computer\")\ntrace7, trace8 = pair_plots(\"television\")\ntrace9, trace10 = pair_plots(\"mobilephone\")\ntitles = [\"Tablet\", \"Refrigirator\", \"Computer\", \"Television\", \"MobilePhone\"]\n\nfig = tools.make_subplots(rows=3, cols=2, print_grid=False, subplot_titles=titles)\nfig.append_trace(trace1, 1, 1)\nfig.append_trace(trace2, 1, 1)\nfig.append_trace(trace3, 1, 2)\nfig.append_trace(trace4, 1, 2)\nfig.append_trace(trace5, 2, 1)\nfig.append_trace(trace6, 2, 1)\nfig.append_trace(trace7, 2, 2)\nfig.append_trace(trace8, 2, 2)\nfig.append_trace(trace9, 3, 1)\nfig.append_trace(trace10, 3, 1)\n\nfig['layout'].update(height=1000, title=\"Ammenities for each division\", showlegend=False)\niplot(fig)","7e29bd1e":"import matplotlib_venn as venn\n# plt.subplot(121)\n\ndef return_sets(x,col):\n    temp = x.loc[x[col]==1]\n    idss = []\n    for ids in temp.Id:\n        idss.append(ids)\n    return idss\n\ndef make_sets(computer,tv,tablet):\n    computer=list(set([a for a in computer]))\n    tv=list(set([a for a in tv]))\n    tablet= list(set([a for a in tablet]))\n\n    comp_tv=list(set(computer).intersection(tv))\n    comp_tablet=list(set(computer).intersection(tablet))\n    tv_tablet=list(set(tv).intersection(tablet))\n\n    all_intersect = list(set(computer).intersection(tv).intersection(tablet))\n    return computer,tv,tablet,comp_tv,comp_tablet,tv_tablet,all_intersect\n\ndef make_venn3(set1,set2,set3,l1,l2,l3):\n    \n    plt.figure(figsize=(22,12))\n    plt.subplot(141)\n\n    computer = return_sets(extreme,set1)\n    tv = return_sets(extreme,set2)\n    tablet = return_sets(extreme,set3)\n    computer,tv,tablet,comp_tv,comp_tablet,tv_tablet,all_intersect = make_sets(computer,tv,tablet)\n    v = venn.venn3(subsets=(len(computer),len(tv),len(comp_tv),len(tablet),len(comp_tablet),len(tv_tablet),len(all_intersect)),set_labels=(l1,l2,l3))\n    plt.title(\"Ammenities of extreme\")\n    plt.subplot(142)\n\n\n    computer = return_sets(moderate,set1)\n    tv = return_sets(moderate,set2)\n    tablet = return_sets(moderate,set3)\n    computer,tv,tablet,comp_tv,comp_tablet,tv_tablet,all_intersect = make_sets(computer,tv,tablet)\n    v = venn.venn3(subsets=(len(computer),len(tv),len(comp_tv),len(tablet),len(comp_tablet),len(tv_tablet),len(all_intersect)),set_labels=(l1,l2,l3))\n    plt.title(\"Ammenities of Moderate\")\n    plt.subplot(143)\n\n    computer = return_sets(vulnerable,set1)\n    tv = return_sets(vulnerable,set2)\n    tablet = return_sets(vulnerable,set3)\n    computer,tv,tablet,comp_tv,comp_tablet,tv_tablet,all_intersect = make_sets(computer,tv,tablet)\n    v = venn.venn3(subsets=(len(computer),len(tv),len(comp_tv),len(tablet),len(comp_tablet),len(tv_tablet),len(all_intersect)),set_labels=(l1,l2,l3))\n    plt.title(\"Ammenities of Vulnerable\")\n    plt.subplot(144)\n\n    computer = return_sets(non_vulnerable,set1)\n    tv = return_sets(non_vulnerable,set2)\n    tablet = return_sets(non_vulnerable,set3)\n    computer,tv,tablet,comp_tv,comp_tablet,tv_tablet,all_intersect = make_sets(computer,tv,tablet)\n    v = venn.venn3(subsets=(len(computer),len(tv),len(comp_tv),len(tablet),len(comp_tablet),len(tv_tablet),len(all_intersect)),set_labels=(l1,l2,l3))\n    plt.title(\"Ammenities of non_vulnerable\")\n\n    plt.show()\n    print(extreme.shape) \n    print(moderate.shape)\n    print(vulnerable.shape) \n    print(non_vulnerable.shape)\n","a16a16a3":"make_venn3(\"refrig\",\"television\",\"mobilephone\",\"Fridge\",\"TV\",\"Mobile\")","5998900e":"make_venn3(\"refrig\",\"computer\",\"mobilephone\",\"Fridge\",\"Computer\",\"Mobile\")","bfa1c8ec":"\nmake_venn3(\"computer\",\"television\",\"v18q\",\"Computer\",\"TV\",\"Tablet\")","4a3439dc":"def target_name(x):\n    if x == 1:\n        return \"Extreme\"\n    if x == 2:\n        return \"Moderate\"\n    if x == 3:\n        return \"Vulnerable\"\n    if x == 4:\n        return \"Non Vulnerable\"\ntrain[\"Target_name\"]= train.Target.apply(lambda x: target_name(x))","e5ff2a41":"train[\"tablets_total\"] = train.apply(lambda x:x.v18q1\/x.hogar_total,axis=1)\ntrain[\"phones_total\"] = train.apply(lambda x:x.qmobilephone\/x.hogar_total,axis=1)\ntrain.drop([\"v18q1\",\"qmobilephone\"],axis=1,inplace=True)\n\ntest[\"tablets_total\"] = test.apply(lambda x:x.v18q1\/x.hogar_total,axis=1)\ntest[\"phones_total\"] = test.apply(lambda x:x.qmobilephone\/x.hogar_total,axis=1)\ntest.drop([\"v18q1\",\"qmobilephone\"],axis=1,inplace=True)\n\ntrain.head()","cd394ecc":"extreme = train.loc[train.Target == 1]\nmoderate = train.loc[train.Target == 2]\nvulnerable = train.loc[train.Target == 3]\nnon_vulnerable = train.loc[train.Target == 4]\n","e51221ef":"def plot_violin(col,name):\n    data = []\n    for i in range(0,len(pd.unique(train['Target']))):\n        trace = {\n                \"type\": 'violin',\n                \"x\": train['Target'][train['Target'] == pd.unique(train['Target'])[i]],\n                \"y\": train[col][train['Target'] == pd.unique(train['Target'])[i]],\n                \"name\": pd.unique(train['Target_name'])[i],\n                \"box\": {\n                    \"visible\": True\n                },\n                \"meanline\": {\n                    \"visible\": True\n                }\n            }\n        data.append(trace)\n\n\n    fig = {\n        \"data\": data,\n        \"layout\" : {\n            \"title\": name,\n            \"yaxis\": {\n                \"zeroline\": False,\n            }\n        }\n    }\n\n\n    iplot(fig, filename='violin\/multiple', validate = False)","c892f3e5":"plot_violin(\"tablets_total\",\"tablets vs houshold_members\")\nplot_violin(\"phones_total\",\"Phones vs Household members\")","3c65706e":"def get_data1(col):\n    extremes = extreme.loc[extreme[col] ==1]\n    moderates = moderate.loc[moderate[col] ==1]\n    vulnerables = vulnerable.loc[vulnerable[col] ==1]\n    non_vulnerables = non_vulnerable.loc[non_vulnerable[col] ==1]\n    extremes = extremes[col].value_counts().to_dict()\n    moderates = moderates[col].value_counts().to_dict()\n    vulnerables = vulnerables[col].value_counts().to_dict()\n    non_vulnerables = non_vulnerables[col].value_counts().to_dict()\n    y = [extremes[0],moderates[0],vulnerables[0],non_vulnerables[0]]\n    y2 = [extremes[1],moderates[1],vulnerables[1],non_vulnerables[1]]\n    return y,y2\n\nedu_feats = [\"abastaguano\",\"sanitario1\",\"energcocinar1\",\"epared1\",\"etecho1\",\"eviv1\"]#,\"instlevel9\"]\nfigs = []\ni = 0\nfor feat in edu_feats:\n        print(i)\n        y,y2 = get_data(feat)\n        fig = single_bar(y2,feat)\n        figs.append(fig)\n        i = i +1\n\ntitles = [\"Water Supply\", \"Sanitation\", \"Fuel Energy\", \"Walls\",\"Roof\",\"Floor\"]\n\nfig = tools.make_subplots(rows=3, cols=2, print_grid=False, subplot_titles=titles)\nfig.append_trace(figs[0], 1, 1)\nfig.append_trace(figs[1], 1, 2)\nfig.append_trace(figs[2], 2, 1)\nfig.append_trace(figs[3], 2, 2)\nfig.append_trace(figs[4], 3, 1)\nfig.append_trace(figs[5], 3, 2)\n# fig.append_trace(tr9, 3, 1)\n# fig.append_trace(tr10, 3, 1)\n\nfig['layout'].update(height=1000, title=\"Available Facilities\", showlegend=False)\niplot(fig)","f9f2fe16":"x = ['extreme poverty ', 'moderate poverty ', 'vulnerable households ','non-vulnerable households']\ny ,y2= get_data(\"area1\")  #\nplot_bar(x,y,y2,\"Urban\",\"Rural\")","058add5f":"plot_violin(\"v2a1\",\"Monthly Rent\")","33d2e2eb":"plot_violin(\"dependency\",\"Dependancy\")","08b5ec0d":"plot_violin(\"meaneduc\",\"Mean Years of Education of all Adults in a Household\")","80b3f55c":"plot_violin(\"edjefe\",\"Years of Education of Male Head of Household\")","1a14b362":"plot_violin(\"edjefa\",\"Years of Education of Female Head of Household\")","7efb3f64":"from sklearn import preprocessing\nle = preprocessing.LabelEncoder()\ntrain.Target = le.fit_transform(train.Target_name)\ntrain.drop([\"Target_name\"],axis=1,inplace=True)","6dc5e853":"# train.to_csv(\"train.csv\",index=False)\n# test.to_csv(\"test.csv\",index=False)\ndepend = []\nfor dependency, children, olds, total in zip(train['dependency'], train['hogar_nin'], train['hogar_mayor'], train['hogar_total']):\n    calc_depend = False\n    if depend != depend:\n        calc_depend = True\n    elif (dependency == \"yes\" or dependency == \"no\"):\n        calc_depend = True\n\n    #Dependency rate, calculated = (number of members of the household younger than 19 or older than 64)\/(number of member of household between 19 and 64)\n    if calc_depend:\n        i = (children + olds) \/ (total - children - olds)\n    else:\n        i = float(dependency)\n\n    depend += [i]\n\ntrain['dependency'] = depend\n\nchw = []\nfor nin, adul in zip(train['hogar_nin'], train['hogar_adul']):\n    if adul == 0:\n        chw += [nin * 2]\n    else:\n        chw += [nin \/ adul]\n\ntrain['child_weight'] = (train['hogar_nin'] + train['hogar_mayor']) \/ train['hogar_total']\ntrain['child_weight2'] = chw\ntrain['child_weight3'] = train['r4t1'] \/ train['r4t3']\ntrain['work_power'] = train['dependency'] * train['hogar_adul']\ntrain['SQBworker'] = train['hogar_adul'] ** 2\ntrain['rooms_per_person'] = train['rooms'] \/ (train['tamviv'])\ntrain['bedrooms_per_room'] = train['bedrooms'] \/ train['rooms']\ntrain['female_weight'] = train['r4m3'] \/ train['r4t3']\n\n\ndepend = []\nfor dependency, children, olds, total in zip(test['dependency'], test['hogar_nin'], test['hogar_mayor'], test['hogar_total']):\n    calc_depend = False\n    if depend != depend:\n        calc_depend = True\n    elif (dependency == \"yes\" or dependency == \"no\"):\n        calc_depend = True\n\n    #Dependency rate, calculated = (number of members of the household younger than 19 or older than 64)\/(number of member of household between 19 and 64)\n    if calc_depend:\n        i = (children + olds) \/ (total - children - olds)\n    else:\n        i = float(dependency)\n\n    depend += [i]\n\ntest['dependency'] = depend\n\nchw = []\nfor nin, adul in zip(test['hogar_nin'], test['hogar_adul']):\n    if adul == 0:\n        chw += [nin * 2]\n    else:\n        chw += [nin \/ adul]\n\n\n\n\ntest['child_weight'] = (test['hogar_nin'] + test['hogar_mayor']) \/ test['hogar_total']\ntest['child_weight2'] = chw\ntest['child_weight3'] = test['r4t1'] \/ test['r4t3']\ntest['work_power'] = test['dependency'] * test['hogar_adul']\ntest['SQBworker'] = test['hogar_adul'] ** 2\ntest['rooms_per_person'] = test['rooms'] \/ (test['tamviv'])\ntest['bedrooms_per_room'] = test['bedrooms'] \/ test['rooms']\ntest['female_weight'] = test['r4m3'] \/ test['r4t3']","d7c2afba":"categorical_feats = [\n    f for f in train.columns if len(train[f].value_counts()) == 2\n]\n\n\ntrain_cat = train[categorical_feats]\ntrain_cat = train_cat.fillna('XNA')\nprint(train_cat.shape)\ntrain_cat.head()","bc639501":"\nfrom contextlib import contextmanager\nimport time\n\ntimer_depth = -1\n@contextmanager\ndef timer(name):\n    t0 = time.time()\n    global timer_depth\n    timer_depth += 1\n    yield\n    pid = os.getpid()\n    py = psutil.Process(pid)\n    memoryUse = py.memory_info()[0] \/ 2. ** 30\n    print('----'*timer_depth + f'>>[{name}] done in {time.time() - t0:.0f} s ---> memory used: {memoryUse:.4f} GB', '')\n    if(timer_depth == 0):\n        print('\\n')\n    timer_depth -= 1","ebc8fd72":"\n\nimport psutil\n\ndef cal_woe(app_train, app_train_target):\n    num_events = app_train_target.sum()\n    num_non_events = app_train_target.shape[0] - app_train_target.sum()\n\n    feature_list = []\n    feature_iv_list = []\n    for col in app_train.columns:\n        if app_train[col].unique().shape[0] == 1:\n            del app_train[col]\n            print('remove constant col', col)\n\n        with timer('cope with %s' % col):\n            feature_list.append(col)\n\n            woe_df = pd.DataFrame()\n            woe_df[col] = app_train[col]\n            woe_df['target'] = app_train_target\n            events_df = woe_df.groupby(col)['target'].sum().reset_index().rename(columns={'target' : 'events'})\n            events_df['non_events'] = woe_df.groupby(col).count().reset_index()['target'] - events_df['events']\n            def cal_woe(x):\n                return np.log( ((x['non_events']+0.5)\/num_non_events) \/ ((x['events']+0.5)\/num_events)  )\n            events_df['WOE_'+col] = events_df.apply(cal_woe, axis=1)\n\n            def cal_iv(x):\n                return x['WOE_'+col]*(x['non_events'] \/ num_non_events - x['events'] \/ num_events)\n            events_df['IV_'+col] = events_df.apply(cal_iv, axis=1)\n\n            feature_iv = events_df['IV_'+col].sum()\n            feature_iv_list.append(feature_iv)\n\n            events_df = events_df.drop(['events', 'non_events', 'IV_'+col], axis=1)\n            app_train = app_train.merge(events_df, how='left', on=col)\n    iv_df = pd.DataFrame()\n    iv_df['feature'] = feature_list\n    iv_df['IV'] = feature_iv_list\n    iv_df = iv_df.sort_values(by='IV', ascending=False)\n    return app_train, iv_df\ntrain_cat_target = train.Target\nwith timer('calculate WOE and IV'):\n    train_cat, iv_df = cal_woe(train_cat, train_cat_target)","681d3b8c":"selected_cats =iv_df.loc[iv_df['IV']>0.001]\nselected_cats = selected_cats.feature.tolist()","48ce4e51":"iv_df = iv_df.feature.tolist()\nexcluded_feats = [\"Target\"]\nId = test.Id\ny = train.Target\nfeatures = [f_ for f_ in train.columns if f_ not in excluded_feats]\nfeatures = [f_ for f_ in features if f_ not in iv_df ]\nfor f in selected_cats:\n    features.append(f)\nlen(features)","14302a2e":"train = train[features]\n\ntrain.head()","971b1fb9":"test = test[features]\ntest.head()","1a8a2e5b":"\nmerged = pd.concat([train,test])\nmerged.shape\nmerged.idhogar = le.fit_transform(merged.idhogar)\nmerged.Id = le.fit_transform(merged.Id)\nmerged.dependency = le.fit_transform(merged.dependency)\nmerged.edjefe = le.fit_transform(merged.edjefe)\nmerged.edjefa = le.fit_transform(merged.edjefa)\ntrain = merged.iloc[:train.shape[0],:]\ntest = merged.iloc[train.shape[0]:,:]","8ab46f34":"print(test.shape)\ntrain.shape","035b520f":"\ntrain.to_csv(\"train.csv\",index=False)\ntest.to_csv(\"test.csv\",index=False)\n# news = pd.read_csv(\"newFinal.csv\")\n# news","f4c279e5":"From the above violin plot we can easily infer that the better off households are paying a larger amount of monthly rent","10b47aca":"## 2. EDA on Ammenities\n\nHypothesis : Poor households will only have basic ammenities","c2e8f3f4":"### Inference\nFrom the above three violin plots, we can agree that the hypothesis holds","3a32e80d":"From the above venn Diagrams we can infer the following :-\n1.  Almost all households have a Fridge and a mobilephone irrespective of their poverty status\n2. The following is the number of households in each level that posses all ammenities:-\n      1. Extreme = 4 (0.53%)\n      2. Moderate = 3 (0.187%)\n      3. Vulnerable = 6 (0.49%)\n      4. Non Vulnerable = 243 (4%)\n      \n      The above listed finidings are based on the fact that all the households that have a computer also posses a fridge and mobilephone\n      \n      Note: the venn diagram package does not support the superset-subset relation","63278f9d":"## EDA\nNow the dataset will be explored.\n### 1 Levels of Poverty based on the \n1. dis, =1 if disable person\n1. male, =1 if male\n1. female, =1 if female","c3fc73b9":"To check the relationship between the number of phones, tablets with poverty level, two new features are introduced\n1. tablets_total = v18q1\/hogar_total\n1. phones_total = qmobilephone\/hogar_total\n\nand the original features (v18q1,qmobilephone) are dropped","b2dbd6e6":"## EDA on dependacy\nHypothesis : In poor households, greater number of individuals will be dependant ","45c8c908":"## EDA on Education\nHypothesis: Members of well off households will be well educated ","5585f8a0":"### Inference\nThe hypothesis holds true","91a5e190":"## EDA on House Rent\nHypothesis : If a household is paying a larger sum as monthly rent it must imply that they are better off to afford such a costly quaters","3cbd4b91":"### Inference \nNo obvious split in data"}}