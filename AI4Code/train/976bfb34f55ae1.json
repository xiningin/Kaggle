{"cell_type":{"3a987852":"code","fba0cac2":"code","d8067af6":"code","d3212c8c":"code","cb3d973a":"code","139a720a":"code","331b3c6a":"code","44f48ae2":"code","d6bf65da":"code","89e64e11":"code","92879262":"code","4b46b713":"code","5c2afbde":"code","e137d2a1":"code","ab32cf0f":"code","2bcc0ece":"code","7e0942b8":"code","df117f12":"code","a82c039b":"code","374b741c":"code","c98b8eb4":"code","2ad5b513":"code","6639739e":"code","01152c54":"code","41019023":"code","5e44e7ee":"code","6142c327":"code","23995226":"code","e1e00568":"markdown","4d2cfb6a":"markdown","0ccf91f7":"markdown"},"source":{"3a987852":"# Put these at the top of every notebook, to get automatic reloading and inline plotting\n%reload_ext autoreload\n%autoreload 2\n%matplotlib inline\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt # showing and rendering figures\n# io related\nfrom skimage.io import imread\nimport os\nfrom glob import glob\n\nfrom fastai.imports import *\nfrom fastai.transforms import *\nfrom fastai.conv_learner import *\nfrom fastai.model import *\nfrom fastai.dataset import *\nfrom fastai.sgdr import *\nfrom fastai.plots import *\n","fba0cac2":"from subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\/dr_data\/DR_data\/\"]).decode(\"utf8\"))","d8067af6":"PATH =\"..\/input\/dr_data\/DR_data\/\"\nTMP_PATH = \"\/tmp\/tmp\"\nMODEL_PATH = \"\/tmp\/model\/\"\narch=resnet34\nsz=224\ntfms=tfms_from_model(arch, sz)\n","d3212c8c":"torch.cuda.is_available()","cb3d973a":"torch.backends.cudnn.enabled","139a720a":"fnames = np.array([f'train\/{f}' for f in sorted(os.listdir(f'{PATH}train'))])\n","331b3c6a":"img = plt.imread(f'{PATH}{fnames[0]}')\nplt.imshow(img);","44f48ae2":"img.shape","d6bf65da":"img[2000:2004,1500:1504]","89e64e11":"# Uncomment the below if you need to reset your precomputed activations\n# shutil.rmtree(f'{PATH}tmp', ignore_errors=True)","92879262":"data= ImageClassifierData.from_csv(path=PATH,\n                                      folder='train', \n                                      csv_fname='..\/input\/trainLabels_3.csv'\n                                      , tfms=tfms, test_name='test', \n                                       suffix='.jpeg')\nlearn = ConvLearner.pretrained(arch, data, precompute=True, tmp_name=TMP_PATH, models_name=MODEL_PATH)\nlearn.fit(0.01, 2)","4b46b713":"data","5c2afbde":"# This is the label for a val data\ndata.val_y","e137d2a1":"# from here we know that 'cats' is label 0 and 'dogs' is label 1.\ndata.classes","ab32cf0f":"# this gives prediction for validation set. Predictions are in log scale\nlog_preds = learn.predict()\nlog_preds.shape","2bcc0ece":"log_preds[:10]","7e0942b8":"preds = np.argmax(log_preds, axis=1)  # from log probabilities to 0 or 1\nprobs = np.exp(log_preds[:,0])        # pr(no DR)","df117f12":"def rand_by_mask(mask): return np.random.choice(np.where(mask)[0], 4, replace=False)\ndef rand_by_correct(is_correct): return rand_by_mask((preds == data.val_y)==is_correct)","a82c039b":"def plots(ims, figsize=(12,6), rows=1, titles=None):\n    f = plt.figure(figsize=figsize)\n    for i in range(len(ims)):\n        sp = f.add_subplot(rows, len(ims)\/\/rows, i+1)\n        sp.axis('Off')\n        if titles is not None: sp.set_title(titles[i], fontsize=16)\n        plt.imshow(ims[i])","374b741c":"def load_img_id(ds, idx): return np.array(PIL.Image.open(PATH+ds.fnames[idx]))\n\ndef plot_val_with_title(idxs, title):\n    imgs = [load_img_id(data.val_ds,x) for x in idxs]\n    title_probs = [probs[x] for x in idxs]\n    print(title)\n    return plots(imgs, rows=1, titles=title_probs, figsize=(16,8))","c98b8eb4":"# 1. A few correct labels at random\nplot_val_with_title(rand_by_correct(True), \"Correctly classified\")","2ad5b513":"# 2. A few incorrect labels at random\nplot_val_with_title(rand_by_correct(False), \"Incorrectly classified\")","6639739e":"def most_by_mask(mask, mult):\n    idxs = np.where(mask)[0]\n    return idxs[np.argsort(mult * probs[idxs])[:4]]\n\ndef most_by_correct(y, is_correct): \n    mult = -1 if (y==1)==is_correct else 1\n    return most_by_mask(((preds == data.val_y)==is_correct) & (data.val_y == y), mult)","01152c54":"plot_val_with_title(most_by_correct(0, True), \"Most correct No Retinopathy\")","41019023":"plot_val_with_title(most_by_correct(4, True), \"Most correct Retinopathy\")","5e44e7ee":"plot_val_with_title(most_by_correct(0, False), \"Most incorrect No Retinopathy\")","6142c327":"plot_val_with_title(most_by_correct(1, False), \"Most incorrect Retinopathy\")","23995226":"most_uncertain = np.argsort(np.abs(probs -0.5))[:4]\nplot_val_with_title(most_uncertain, \"Most uncertain predictions\")","e1e00568":"Here is how the raw data looks like","4d2cfb6a":"## Analyzing results: looking at pictures","0ccf91f7":"## Our first model: quick start"}}