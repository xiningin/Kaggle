{"cell_type":{"89b919bd":"code","5fc5758d":"code","9ee2df0b":"code","9dc046ca":"code","66c65c06":"code","1d4943dd":"code","a2cc31f5":"code","cad0ffff":"code","e1e60ec7":"code","a9766f21":"code","08ffadaa":"code","a4992851":"code","c854aadf":"code","3ffee000":"code","ede127f8":"code","14a9d01b":"code","a593d6af":"code","fa7b77e0":"code","6306b741":"code","79757973":"code","e0a00907":"code","f58a6c39":"code","06726760":"code","63788eec":"code","6881dd9c":"code","c45172f3":"markdown","bbeb7899":"markdown","c7f5f4ff":"markdown","4782570f":"markdown","4d2fbc1f":"markdown","f4be75df":"markdown","2f6bd17f":"markdown","06a736c9":"markdown","2f91725e":"markdown","259bf101":"markdown","8eb548bf":"markdown","9399ae87":"markdown","a22f91e5":"markdown","b7109386":"markdown","6d598789":"markdown","2c8503a0":"markdown","5e359449":"markdown","f742fa98":"markdown","3936640f":"markdown","9e5070b1":"markdown","8a0cf89d":"markdown"},"source":{"89b919bd":"\nimport numpy as np\nimport scipy as sp\nimport scipy.integrate as integrate\nimport re\nimport decimal\n\n# For example, to create an array filled with random values between 0 and 1, use random function.\n# This is particularly useful for problems where you need a random state to get started.\n# But here the elements will be decimals\n\nA = np.random.rand(2,3)\nprint(A)\n\n\"\"\" Output of above\n[[0.62857547 0.14598864 0.93991874]\n [0.65560569 0.29442998 0.3354452 ]] \"\"\"\n\n\nA = np.random.random([2,3]) # Or this is also equivalent\nprint(A)\n\n'''\nnumpy.random.random like many of the other numpy.random methods accept shapes, i.e. N-tuples. So really the outside parenthesis represent calling the method numpy.random.random(), and the inside parenthesis are syntactic sugar for instantiating the tuple (3, 3) that is passed into the function.\n'''\n\n# Create Matrix (2,3) with random between 0 and 1 and INTEGER (i.e. NOT decimal)\nB = np.random.randint(10, size=(3,2))\n# print(B)\nprint(B.T)\n\n# Dot product\nprint(np.dot(A, B))\n\n# transpose\n# print(np.dot(A, B).T)\n","5fc5758d":"# I have following x values\n\n'''\nx = [2600.2 2601.2 2602.2 2603.1 2604.1 2605.1 2606.  2607.  2607.9 2608.9\n     2609.9 2610.8 2611.8 2612.8 2613.7 2614.7 2615.7 2616.6 2617.6 2618.6\n     2619.5 2620.5 2621.4 2622.4 2623.4 2624.3 2625.3 2626.3 2627.2 2628.2\n     2995.7 2996.6 2997.6 2998.6 2999.5 3000.5 3001.5 3002.4 3003.4 3004.3\n     3005.3 3006.3 3007.2 3008.2 3009.2 3010.1 3011.1 3012.1 3013.  3014.2\n     ]\n'''\n\n# First delte all the line breaks and make as a string\n\nx_str = '[2600.2 2601.2 2602.2 2603.1 2604.1 2605.1 2606.  2607.  2607.9 2608.9 2609.9 2610.8 2611.8 2612.8 2613.7 2614.7 2615.7 2616.6 2617.6 2618.6 2619.5 2620.5 2621.4 2622.4 2623.4 2624.3 2625.3 2626.3 2627.2 2628.2 2995.7 2996.6 2997.6 2998.6 2999.5 3000.5 3001.5 3002.4 3003.4 3004.3 3005.3 3006.3 3007.2 3008.2 3009.2 3010.1 3011.1 3012.1 3013. 3014.2]'\n\nnp_array = np.array(re.split(\"\\s+\", x_str.replace('[', '').replace(']', '')), dtype=float)\nnp_array","9ee2df0b":"# If I want to make a list and add comma between each item\npython_list = list(np_array)","9dc046ca":"# Here are my x-values:\n\nx = [2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014]\n\n# and y-values:\n\ny = [9, 3, 8, 6, 2, 0, 3, 2, 7, 0, 9, 5, 1, 7, 2, 9, 5, 5, 9, 2, 7, 1,\n       6, 8, 0, 3, 4, 6, 0, 8, 7, 5, 8, 3, 6, 6, 4, 6, 8, 1, 3, 1, 0, 1,\n       8, 9, 0, 1, 1, 3]\n\n# How would you integrate the curve from x = 2672.6 to 3005.3 ?\n\n# Now extract the ranges\nidx = np.where(( np.array(x) >= 2672.6 ) & (np.array(x) <= 3005.3))[0]\n\n# And then either using np.trapz to integrate using the trapezoidal rule:\nnp.trapz(x = np.array(x)[idx], y = np.array(y)[idx] )\n\n# or I could also use from scipy's integration methods for integrating with fixed samples:\n# https:\/\/docs.scipy.org\/doc\/scipy\/reference\/tutorial\/integrate.html\n\n\n# same as numpy.trapz\nintegrate.trapz(x=np.array(x)[idx],y=np.array(y)[idx])\n# example using simpson's rule\nintegrate.simps(x=np.array(x)[idx],y=np.array(y)[idx])","66c65c06":"x = np.array([[1, 2, 3], [4,5,6],[7,8,9]], np.int32)\nprint(x)\n'''\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]], dtype=int32)\n'''\n\ns0 = x.sum(axis=0)  # sum the columns [1,4,7] = 12, [2,5,8] = 15 [3,6,9] = 18\ns0","1d4943dd":"s1 = x.sum(axis=1)    # sum the rows [1,2,3] = 6, [4,5,6] = 15 [7,8,9] = 24\ns1","a2cc31f5":"x = np.array((((1,2), (3,4) ), ((5,6),(7,8))))\nx\n\n'''\n  array([[[1, 2],\n          [3, 4]],\n         [[5, 6],\n          [7, 8]]])\n'''","cad0ffff":"x.shape # dimensions of the array\n# (2, 2, 2)\n\nx.sum(axis=0)\n\n'''\narray([[ 6,  8],   #  [1,5] = 6 [2,6] = 8 [3,7] = 10 [4, 8] = 12\n      [10, 12]])\n'''\nx.sum(axis=1)\n\n'''\narray([[ 4,  6],   # [1,3] = 4 [2,4] = 6 [5, 7] = 12 [6, 8] = 14\n      [12, 14]])\n'''\n\nx.sum(axis=2) # [1, 2] = 3 [3, 4] = 7 [5, 6] = 11 [7, 8] = 15\n'''\narray([[ 3,  7],\n      [11, 15]])\n'''\n\nx.ndim # number of dimensions of the array\n# 3","e1e60ec7":"# Now finally, considering a four dimensions array, how to get sum over the last two axis at once?\n\narray_4_d = np.random.randint(0, 10, (2, 4, 2, 4))\nprint(array_4_d)\nprint('shape of above array_4_d ', array_4_d.shape)\n\n\"\"\"\nSyntax of random.randint : numpy.random.randint(low, high=None, size=None, dtype=\u2019l\u2019)\n\n It returns an array of specified shape and fills it with random integers from low (inclusive) to high (exclusive), i.e. in the interval [low, high).\n\nsize is the third optional parameter - in above its withing the parenthesis. It takes a size int or tuple of ints.\n\nThis determines output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.\n\n\"\"\"\n\n# Solution-alternate-1 - by passing a tuple of axes\n\nsum_1 = array_4_d.sum(axis=(-2, -1))\nsum_1","a9766f21":"# Solution alternative 2 - by flattening the last two dimensions into one\n# (useful for functions that don't accept tuples for axis argument)\n\nsum_2 = array_4_d.reshape(array_4_d.shape[:-2] + (-1,)).sum(axis=-1)\nsum_2\n","08ffadaa":"a = np.array([1, 2,3])\nb = np.array([5, 6,7])\n\nz = np.concatenate((a, b))\n# In above line, need to pass the arrays as an iterable (a tuple or list)\n# otherwise will be below error\n# TypeError: only integer scalar arrays can be converted to a scalar index \n\nc = np.stack([a,b]).reshape(-1)\nd = np.hstack([a,b])\n\nprint(z)\nprint(c)\nprint(d)\n# all three will print [1 2 3 5 6 7]","a4992851":"a = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6]])\n\nx = np.concatenate((a, b), axis=0)\nprint(x)\n'''\n[[1 2]\n [3 4]\n [5 6]]\n'''\n","c854aadf":"a = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6]])\n\nv = np.vstack((a, b))\nprint(v)\n\n'''\n[[1 2]\n [3 4]\n [5 6]]\n'''","3ffee000":"a = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6]])\n\ny = np.concatenate((a, b.T), axis=1)\nprint(y)\n\n'''\n[[1 2 5]\n [3 4 6]]\n'''","ede127f8":"x = np.array([[2,3,4], [5,6,7]])      \nnp.reshape(x, (3, 2))","14a9d01b":"a = np.array([[2,3,4], [5,6,7]])\n\nprint(np.reshape(a, 6))\n\nprint(np.reshape(a, 6, order='F'))\n\nprint(np.reshape(a, (3,-1)))\n# the unspecified value is inferred to be 2","a593d6af":"a = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\nb = np.reshape(a, -1)\nb","fa7b77e0":"a = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\nb = np.reshape(a, (1, -1))\nb","6306b741":"a = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\nb = np.reshape(a, (-1, 1))\nb","79757973":"a = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\nb = np.reshape(a, (-1, 1))\nb","e0a00907":"from sklearn.preprocessing import Normalizer\nimport numpy as np\n\na = np.array([1, 2, 3])\n\nb = np.reshape(a, (-1, 1))\n\nc = np.reshape(a, (1, -1))\n\nprint('Afer reshaping with (-1, 1) \\n', b)\nprint('After reshaping with (1, -1) \\n', c)","f58a6c39":"normalizer = Normalizer()\n\na_transformed_not_useful = normalizer.transform(b)\nc_transformed = normalizer.transform(c)\n\nprint(\"a_transformed_not_useful \\n \\n\", a_transformed_not_useful)\nprint(\"c_transformed \\n \\n\", c_transformed)","06726760":"\nA = np.matrix([[]])\n\nA = np.matrix([[1, 2, 3, 33], [4, 5, 6, 66], [7, 8, 9, 99]])\n\nprint(np.argmax(A))\n# 11, which is the position of 99\n\nprint(np.argmax(A[:, :]))\n# 11, which is the position of 99\n\nprint(np.argmax(A[:1]))\n# 3, which is the position of 33\n\nprint(np.argmax(A[:, 2]))\n# 2, which is the position of 9\n\nnp.argmax(A[1:, 2])\n# 1, which is the position of 9\n\"\"\" A[1:, 2] it will first fetch the values from 1st row on wards and the only 2nd column value from those rows, then it will find the index of max value from into the resulted matrix. \"\"\"\n\n\na = [[1, 2, 3], [4, 5, 6]]\nprint(np.argmax(a))\n\"\"\"\n# 5\n\nthe array is 2 dimensional, with shape (2,3). Since no axis parameter is specified in the function, the numpy library flattens the array to a 1 dimensional array and then returns the index of the maximum value. In this case the array is transformed to [[1,2,3,4,5,6]] and then returns the index of 6, which is 5.\n\n\"\"\"","63788eec":"\na = [[1,2,3],[4,5,6]]\nnp.argmax(a, axis=0)\n# array([1, 1, 1])","6881dd9c":"a = [[1,2,3],[4,5,6]]\nnp.argmax(a, axis=1)\n# array([2, 2])","c45172f3":"## Generate a random matrix of array and dot product","bbeb7899":"#### When parameter is axis = 0 in argmax()","c7f5f4ff":"#### In the last line above, we wanted a 3 rows, but we did not know how many columns the resultant matrix should have, and so we kept it at -1. Hence numpy decided the unspecified value - which was inferred to be 2","4782570f":"### What does -1 mean in numpy reshape() ?\n\nThe \"-1\" stands for \"unknown dimension\" which can and should be infered from another dimension.\n\n#### Main Rule is - when we don't how many columns the resultant matrix should have (set it to -1!), but if we know that we want a 1-dimensional array(set the first parameter to 1!).\n","4d2fbc1f":"## Integrate curve from vectorized data with numpy.trapz()\n\nFirst find out the indices of x array that are within the above integral limits:","f4be75df":"### numpy allow us to give one of new shape parameter as -1 (eg: (2,-1) or (-1,3) but not (-1, -1)). It simply means that it is an unknown dimension and we want numpy to figure it out. And numpy will figure this by looking at the 'length of the array and remaining dimensions' and making sure it satisfies the above mentioned criteria\n\n\nfor the below example the output explains the resultant vector to be a single row.(-1) indicates the number of rows to be 1.\nif the \n\n    a = numpy.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\n    b = numpy.reshape(a, -1)\n\noutput:\n\n    matrix([[1, 2, 3, 4, 5, 6, 7, 8]])\n\n The \"-1\" stands for \"unknown dimension\" which can should be infered from another dimension.\n","2f6bd17f":"### Numpy Concatenate 2D arrays\n\n![Imgur](https:\/\/imgur.com\/n5pmWGo.png)","06a736c9":"## The reshape() function in Numpy\n\n#### The reshape() function is used to give a new shape to an array without changing its data.\n\n`numpy.reshape(a, newshape, order='C')`\n\n[Doc](https:\/\/numpy.org\/doc\/stable\/reference\/generated\/numpy.reshape.html#numpy-reshape)\n\n#### newshape\tThe new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.\n\nThe below example\n\n![Imgur](https:\/\/imgur.com\/fbjyxqd.png)\n","2f91725e":"And finally, if we try to provide both dimension as unknown i.e new shape as (-1,-1). It will throw an error\n\n```python\na.reshape(-1, -1)\nValueError: can only specify one unknown dimension\n```","259bf101":"## A note on numpy.trapz() function\n\n#### numpy.trapz() function integrate along the given axis using the composite [trapezoidal rule](https:\/\/en.wikipedia.org\/wiki\/Trapezoidal_rule).\n\n![Imgur](https:\/\/imgur.com\/kKX9G5R.png)\n\n![Imgur](https:\/\/imgur.com\/6zwXG8w.png)\n\nYou specify the integration range when you pass the x array to the np.trapz function.\n\n\nInternally, trapz uses np.diff() to calculate dx. This makes the assumption that the x values are increasing monotonically. This leads to wrong values when x does not have this property:\n\n```python\nx = array([0, 1, 2])\n\ny = array([0, 2, 4])\n\ntrapz(y, x) # 4, correct value\n\ntrapz(y[::-1], x[::-1]) # -4, incorrect value\n\nidx = random.permutation(arange(3))\n\nx_shuffled = x[idx]\n\ny_shuffled = y[idx]\n\ntrapz(y_shuffled, x_shuffled) # 1, incorrect value\n```\n\nThis limitation of trapz can be fixed by sorting both y, x values before proceeding.\n\nNumpy repo's maintainers have explicitly retained this, opining this as a feature rather than a defect. See [here](https:\/\/github.com\/numpy\/numpy\/issues\/4601#issuecomment-88697254)\n\n\n\"It seems nearly all of the scipy community sees the sensitivity to x-array ordering as a feature rather than a defect. While I believe this position has an equally valid point of view (the disagreement is over who has to keep track of their minus signs explicitly) it seems that changing the behavior will cause far more upset than molification.\"\n\n### When can I get a negative value from numpy.trapz()\n\n#### If the $x_i$ in the call to trapz() are not in increasing order, then you will get negative results. So if you want a positive number from this function when it returns a negative, Try re-ordering x in ascending order (and y-values accordingly):\n\n```python\nx_order = x(end:-1:1); %fliplr\ny_order = y(end:-1:1); %fliplr\ntrapz(x_order, y_order)\n```\n\n In essence, I will get negative result, when I am integrating the function represented by the y data from x = 1 to x = 0, not from x = 0 to x = 1. If I flip my x vector so that I am integrating from x = 0 to x = 1 (essentially swapping the limits of integration) then the area will be positive.\n\nIn `trapz(x,y)` differentiation of x is applied through diff(x,1,1), i.e. `[x(2:n,:) - x(1:n-1,:)].` If your x is descending this will give negative dx. It doesn't matter if it is positive or negative. However, in `plot` the curve will appear positive-definite (you don't actually see the order of points, just pairs from two vectors on a plane).\n\n**Example** (compare the following):\n\n```python\nx = [-1 -0.5 0]; y = 0.5-x;\nfigure; plot(x,y); hold on; plot(-x, y,'r')\ntrapz(x, y)\ntrapz(-x, y)\nfigure; plot(x, y); hold on; plot(fliplr(-x), fliplr(y),'r')\ntrapz(fliplr(-x), fliplr(y))\n```\n\n\nThink of it like this. The integral of a function that is always positive, if the limits are inverted, will still be negative. Thus we know that\n\n    int(x^2,-1,1) = 2\/3\n\nBut\n\n    int(x^2,1,-1) = -2\/3\n\nClearly x^2 is always a positive number, but here the limits of integration were not increasing, but decreasing.\n\nIf the $x_i$ in the call to trapz are not in increasing order, then you will get negative results. This is reflected by trapz. Trapz sees the order of the points as presented to it.\n\n    x = -1:.1:1;\n    trapz(x,x.^2)\n    ans =\n             0.67\n\n    xrev = fliplr(x);\n    trapz(xrev,xrev.^2)\n    ans =\n            -0.67\n\nThe plot shows only that the function is positive, not the order of the points.\n\n---\n\n## Considering a four dimensions array, how to get sum over the last two axis at once?\n\nFirst a quick refresher on axis in Numpy\n\n### Axis 0 will act on all the ROWS in each COLUMN\n\n### Axis 1 will act on all the COLUMNS in each ROW\n\n### So a `mean` on axis 0 will be the mean of all the rows in each column, and a mean on axis 1 will be a mean of all the columns in each row.\n","8eb548bf":"### numpy vstack\n\nIt Stack arrays in sequence vertically i.e row wise\n\nYou can concatenate the above 2D arrays using vstack and will get the same result as concatenate with axis =0","9399ae87":"## Reshaping Numpy Array Numerical Column\/Features before Normalization\n\n##### The main Principle that I am going to discuss with example below is this\n\n### For normalizing numerical data, we got to use reshape(1, -1) and NOT reshape(-1, 1) and then apply Normalize() function. Ofcourse after the Normalization is done we can rehape it back with (-1, 1) if thats what we need.\n\nHere is how normalizer works and why you should use reshape(1, -1) instead of (-1, 1)\n\n### Normalizer by default normalizes on each sample(row) while StandardScaler standardises on each feature(column)\n\n---\n\n### What does -1 mean in numpy reshape() ?\n\nThe \"-1\" stands for \"unknown dimension\" which can and should be infered from another dimension.\n\n#### Main Rule is - when we don't how many columns the resultant matrix should have (set it to -1!), but if we know that we want a 1-dimensional array(set the first parameter to 1!).\n\n---\n\nLets take an example where my array is `np.array([1, 2, 3])`\n\n### Noting the mechanism of reshape() - that numpy allow us to give one of new shape parameter as -1 (eg: (2,-1) or (-1,3) but not (-1, -1)). It simply means that it is an unknown dimension and we want numpy to figure it out. And numpy will figure this by looking at the 'length of the array and remaining dimensions' and making sure it satisfies the above mentioned criteria\n\nHere if I use (-1, 1) it means any number of rows, which is the responsibility of numpy to figure out, while I am specifying that I need to have one column. \n\nRememeber -1 lets numpy to calculate the unknown dimension for the resultant that will match with the original matrix.\n\nAnd vice versa, if I do reshape(1, -1) means, that I am specifying row to be 1 while leaving column numbers to be calculated by Numpy.\n\nSo for the case, that I use (-1, 1) => i.e. Rows are unknows while columns required is 1\n\n![Imgur](https:\/\/imgur.com\/vv8tAQK.png)\n\nNormalizer() will go each sample wise i.e. row wise and calculate the Normalizer formulae for that row.\n\n\nLets do actual example","a22f91e5":"### sum() function for a three dimensional array:","b7109386":"## Numpy Concatenate vs hstack\n","6d598789":"Same concept as above but now index of the column is returned at which the maximum value is available. In this example the maximum value 6 is in the 3rd column, index 2. The column of the original matrix with shape (2,3) will be removed, transforming to (2,) and so the return array will display two elements, each showing the index of the column in which the maximum value was found.","2c8503a0":"But \n\n```python\na = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\nb = np.reshape(a, (-1, 1))\n```\n\nGives a column vector. \n\n#### Trying to reshape with (-1, 1) . We have provided column as 1 but rows as unknown . So we get result new shape as (8, 1).again compatible with original shape(2,4)\n\n#### The above is consistent with numpy advice\/error message, to use reshape(-1,1) for a single feature; i.e. single column\n\nReshape your data using `array.reshape(-1, 1)` if your data has a single feature","5e359449":"## Add a comma between the elements of a numpy array","f742fa98":"### Let\u2019s merge the above two arrays along the axis =1\n\n`y = np.concatenate((a, b), axis=1)`\n\nOutput: ValueError: all the input array dimensions for the concatenation axis must match exactly\n\nBut why it\u2019s throwing an error, because both the arrays doesn\u2019t have the same dimensions along 0 to concatenate\n\nSo how do we change the dimension for this concatenation\n\nTranspose the array B and then concatenate along axis = 1\n\n![Imgur](https:\/\/imgur.com\/AvZEtPK.png)\n\n","3936640f":"But \n\n```python\na = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\nb = np.reshape(a, (-1, 1))\n```\n\nGives a column vector","9e5070b1":"As we can see the result of the reshape `a_transformed_not_useful` is a column vector with each value of 1 which in most cases is not useful for our modelling. Beause Normalizer() will go each sample wise i.e. row wise and calculate the Normalizer formulae for that row.\n\n---\n\n## How argmax() function works in Numpy\n\n### argmax is a function which gives the index of the greatest number in the given row or column and the row or column can be decided using axis attribute of argmax funcion. \n\n### If we give axis=0 then the function will now try to find the maximum value along the rows of the matrix. And  give the index from rows. If the maximum value is in the 2-nd row (i.e. index of 1), then 1 will be returned.\n\n### If we give axis=1 then it will give the index from column. If the maximum value is in the 3rd column, index 2 then that index number will be returned.\n\n","8a0cf89d":"The result here is a bit confusing at first. \n\n#### First repeating the original rule -  \n\n### If we give axis=0 then the function will now try to find the maximum value along the rows of the matrix. And  give the index from rows. If the maximum value is in the 2-nd row (i.e. index of 1), then 1 will be returned.\n\n### If we give axis=1 then it will give the index from column. If the maximum value is in the 3rd column, index 2 then that index number will be returned.\n\nSince the axis is defined to be 0, the function will now try to find the maximum value along the rows of the matrix. \n\nThe maximum value, 6, is in the second row of the matrix. The index of the second row is 1. According to the documentation https:\/\/docs.scipy.org\/doc\/numpy-1.15.0\/reference\/generated\/numpy.argmax.html the dimension specified in the axis parameter will be removed. Since the shape of the original matrix was (2,3) and axis specified as 0, the returned matrix will have a shape of(3,) instead, since the 2 in the original shape(2,3) is removed.The row in which the maximum value was found is now repeated for the same number of elements as the columns in the original matrix i.e. 3.\n\n\n### When parameter is axis = 1 in argmax()"}}