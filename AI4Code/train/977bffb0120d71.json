{"cell_type":{"57a9b5e5":"code","c52c5f0c":"code","08271761":"code","aed7bb94":"code","67ce71dd":"code","5296df35":"code","59b96589":"code","cb118671":"code","3e7f08e9":"code","6f6e7333":"code","22f6d798":"code","88824000":"code","6c01ca3f":"code","43a5bb0e":"code","fa3e7ee8":"code","9e7aa9a7":"code","75c4d381":"code","75e61025":"code","68a49ac4":"code","daf87cc3":"code","3f8c3190":"code","9ac6d1df":"markdown","0e1fb605":"markdown","428b1495":"markdown","02faf98d":"markdown"},"source":{"57a9b5e5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c52c5f0c":"import os\nimport pydicom\nimport glob\nfrom PIL import Image\n\ninputdir = '..\/input\/sample images\/'\noutdir = '.\/'\n\ntest_list = [os.path.basename(x) for x in glob.glob(inputdir + '.\/*.dcm')]\nfor f in test_list:  \n    ds = pydicom.read_file( inputdir + f) # read dicom image\n    img = ds.pixel_array # get image array\n    img_mem = Image.fromarray(img) # Creates an image memory from an object exporting the array interface\n    \n#   There is an exception in Kaggle kernel about \"encoder jpeg2k not available\", please test following code on your local workstation\n#   img_mem.save(outdir + f.replace('.dcm','.jp2'))","08271761":"outdir","aed7bb94":"import os\nimport pydicom\nimport glob\nimport imageio\n\ninputdir = '..\/input\/'\noutdir = '.\/shukla1'\nos.mkdir(outdir)\ntest_list = [os.path.basename(x) for x in glob.glob(inputdir + '.\/*.dcm')]\nfor f in test_list:  \n    ds = pydicom.read_file(inputdir + f) # read dicom image\n    img = ds.pixel_array # get image array\n    \n#   There is an exception in Kaggle kernel about \"encoder jpeg2k not available\", please test following code on your local workstation\n#   imageio.imwrite(outdir + f.replace('.dcm','.jp2'), img)","67ce71dd":"outdir","5296df35":"import matplotlib.pyplot as plt\nimport numpy as np\n\nimport tensorflow as tf","59b96589":"pip install -q tensorflow-io","cb118671":"import tensorflow_io as tfio\n\nimage_bytes = tf.io.read_file('\/kaggle\/input\/osic-pulmonary-fibrosis-progression\/train\/ID00136637202224951350618\/253.dcm')\n\nimage = tfio.image.decode_dicom_image(image_bytes, dtype=tf.uint16)\n\nskipped = tfio.image.decode_dicom_image(image_bytes, on_error='skip', dtype=tf.uint8)\n\nlossy_image = tfio.image.decode_dicom_image(image_bytes, scale='auto', on_error='lossy', dtype=tf.uint8)\n\n\nfig, axes = plt.subplots(1,2, figsize=(10,10))\naxes[0].imshow(np.squeeze(image.numpy()), cmap='gray')\naxes[0].set_title('image')\naxes[1].imshow(np.squeeze(lossy_image.numpy()), cmap='gray')\naxes[1].set_title('lossy image');","3e7f08e9":"lossy_image","6f6e7333":"#%reload_ext signature\n%matplotlib inline\n\nimport numpy as np\nimport pydicom\nimport os\nimport matplotlib.pyplot as plt\nfrom glob import glob\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\nimport scipy.ndimage\nfrom skimage import morphology\nfrom skimage import measure\nfrom skimage.transform import resize\nfrom sklearn.cluster import KMeans\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom plotly.tools import FigureFactory as FF\nfrom plotly.graph_objs import *\ninit_notebook_mode(connected=True) ","22f6d798":"data_path = \"\/kaggle\/input\/osic-pulmonary-fibrosis-progression\/train\/ID00136637202224951350618\/\"\n#os.mkdir(output_path)\noutput_path = working_path = \"\/image\/\"\n#os.mkdir(output_path)\ng = glob(data_path + '\/*.dcm')\n\n# Print out the first 5 file names to verify we're in the right folder.\nprint (\"Total of %d DICOM images.\\nFirst 5 filenames:\" % len(g))\nprint('\\n'.join(g[:5]))","88824000":"def load_scan(path):\n    slices = [pydicom.read_file(path + '\/' + s) for s in os.listdir(path)]\n    slices.sort(key = lambda x: int(x.InstanceNumber))\n    try:\n        slice_thickness = np.abs(slices[0].ImagePositionPatient[2] - slices[1].ImagePositionPatient[2])\n    except:\n        slice_thickness = np.abs(slices[0].SliceLocation - slices[1].SliceLocation)\n        \n    for s in slices:\n        s.SliceThickness = slice_thickness\n        \n    return slices\n\ndef get_pixels_hu(scans):\n    image = np.stack([s.pixel_array for s in scans])\n    # Convert to int16 (from sometimes int16), \n    # should be possible as values should always be low enough (<32k)\n    image = image.astype(np.int16)\n\n    # Set outside-of-scan pixels to 1\n    # The intercept is usually -1024, so air is approximately 0\n    image[image == -2000] = 0\n    \n    # Convert to Hounsfield units (HU)\n    intercept = scans[0].RescaleIntercept\n    slope = scans[0].RescaleSlope\n    \n    if slope != 1:\n        image = slope * image.astype(np.float64)\n        image = image.astype(np.int16)\n        \n    image += np.int16(intercept)\n    \n    return np.array(image, dtype=np.int16)\n\nid=0\npatient = load_scan(data_path)\nimgs = get_pixels_hu(patient)","6c01ca3f":"os.mkdir('\/image1\/')","43a5bb0e":"np.save(output_path + \"fullimages_%d.npy\" % (id), imgs)","fa3e7ee8":"file_used=output_path+\"fullimages_%d.npy\" % id\nimgs_to_process = np.load(file_used).astype(np.float64) \n\nplt.hist(imgs_to_process.flatten(), bins=50, color='c')\nplt.xlabel(\"images data \")\nplt.ylabel(\"Frequency\")\nplt.show()","9e7aa9a7":"id = 0\nimgs_to_process = np.load(output_path+'fullimages_{}.npy'.format(id))\n\ndef sample_stack(stack, rows=6, cols=6, start_with=10, show_every=3):\n    fig,ax = plt.subplots(rows,cols,figsize=[12,12])\n    for i in range(rows*cols):\n        ind = start_with + i*show_every\n        ax[int(i\/rows),int(i % rows)].set_title('slice %d' % ind)\n        ax[int(i\/rows),int(i % rows)].imshow(stack[ind],cmap='gray')\n        ax[int(i\/rows),int(i % rows)].axis('off')\n    plt.show()\n\nsample_stack(imgs_to_process)","75c4d381":"print(\"Slice Thickness: %f\" % patient[0].SliceThickness)\nprint(\"Pixel Spacing (row, col): (%f, %f) \" % (patient[0].PixelSpacing[0], patient[0].PixelSpacing[1]))","75e61025":"patient[0].SliceThickness","68a49ac4":"#spacing = np.array([slices[0].SliceThickness, slices[0].PixelSpacing[0], slices[0].PixelSpacing[1]], dtype=np.float32)\n#np.array([patient[0].SliceThickness , patient[0].PixelSpacing[0])","daf87cc3":"#return np.array(image, dtype=np.int16), np.array([slices[0].SliceThickness, slices[0].PixelSpacing[0], slices[0].PixelSpacing[1]], dtype=np.float32)","3f8c3190":"#img = imgs_after_resamp[260]\n#make_lungmask(img, display=True)","9ac6d1df":"# 3D Plotting","0e1fb605":"FOR MORE DETAIL PLEASE MOVE TO SECOND NOTEBOOK\nhttps:\/\/www.kaggle.com\/shubham9455999082\/read-dicom-images-plotting-and-analysis?scriptVersionId=38404981","428b1495":"This means we have 2.5 mm slices, and each voxel represents 0.7 mm.\n\nBecause a CT slice is typically reconstructed at 512 x 512 voxels, each slice represents approximately 370 mm of data in length and width.\n\nUsing the metadata from the DICOM we can figure out the size of each voxel as the slice thickness. In order to display the CT in 3D isometric form (which we will do below), and also to compare between different scans, it would be useful to ensure that each slice is resampled in 1x1x1 mm pixels and slices.","02faf98d":"## convert dicom imgaes to jpeg"}}