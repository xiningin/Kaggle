{"cell_type":{"21f5bdcd":"code","334f3f97":"code","706056bc":"code","c15a4db5":"code","148e268e":"code","bd192077":"code","853b216a":"code","f649854f":"code","2ab78ba4":"code","3690f228":"code","70b75036":"code","ab956974":"code","bae01fb5":"code","821c7cae":"code","cb0b4dca":"code","cabc82f1":"code","3745b144":"code","ec6a58eb":"code","e7f112c2":"code","052b03b9":"code","055f4c1b":"code","263905ab":"code","061c5879":"code","9c7fe373":"code","88face15":"code","630c470b":"code","ddff4d48":"code","549de94a":"code","d7ab54a8":"code","f9a5af34":"code","d69850ee":"code","e8ce2170":"code","bbdaee18":"code","76f1e08d":"code","4fc6dffe":"code","6501da63":"code","c693cfb9":"code","252a864c":"code","069c610f":"code","5b6d0df9":"markdown","cc3c567c":"markdown","c29a56eb":"markdown","0643d514":"markdown","dc67167f":"markdown","c56a00ac":"markdown","e891774c":"markdown","95fa7101":"markdown","972d9cff":"markdown","0a628c8d":"markdown","734c5834":"markdown","b240b8b5":"markdown","3b459987":"markdown","c3ee9517":"markdown","eea6de5a":"markdown","7ff07e2b":"markdown","3c6dfa69":"markdown"},"source":{"21f5bdcd":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","334f3f97":"from pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('white')\nimport time\nimport itertools\nimport warnings\nimport statsmodels.api as sm\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.tsa.arima_model import ARIMA","706056bc":"df = pd.read_csv('\/kaggle\/input\/datos-ibex35-a-072020\/DatosIbex2020.csv', encoding='utf-8')","c15a4db5":"df.head()","148e268e":"df['Fecha']=pd.to_datetime(df['Fecha'],format='%d.%m.%Y')","bd192077":"df.head()","853b216a":"df.tail()","f649854f":"ibex=df[['Fecha','\u00daltimo']]\nibex.columns=['Fecha','Ibex']","2ab78ba4":"ibex.info()","3690f228":"ibex['Ibex']=ibex['Ibex'].str.replace('.','')\nibex['Ibex']=ibex['Ibex'].str.replace(',','.')\nibex['Ibex']=ibex['Ibex'].astype('float')","70b75036":"ibex.head()","ab956974":"ibex=ibex[ibex['Fecha'] > '2020-04-01']","bae01fb5":"ibex.sort_values(by='Fecha',ascending=True,inplace=True)","821c7cae":"ibex.head()","cb0b4dca":"ibex.set_index('Fecha',inplace=True)","cabc82f1":"ibex['Ibex'].plot()","3745b144":"ibex['Ibex_log']=np.log(ibex['Ibex'])","ec6a58eb":"ibex['Ibex_log'].plot()","e7f112c2":"ibex['Ibex_log_diff']=ibex['Ibex_log'].diff()","052b03b9":"ibex['Ibex_log_diff'].plot()","055f4c1b":"y = ibex[\"Ibex\"]\nibex['Ibex_mean']=ibex['Ibex'].mean()\ny_media=ibex['Ibex_mean']\n\ny_log=ibex[\"Ibex_log\"]\nibex['Ibex_log_mean']=ibex['Ibex_log'].mean()\ny_log_media=ibex['Ibex_log_mean']\n\ny_log_diff=ibex[\"Ibex_log_diff\"]\nibex['Ibex_log_diff_mean']=ibex['Ibex_log_diff'].mean()\ny_log_diff_media=ibex['Ibex_log_diff_mean']\n","263905ab":"x=ibex.index","061c5879":"# visualizaci\u00f3n de los datos anteriores a los largo de los a\u00f1os\nfig = plt.figure(figsize = (10, 10))\nax1, ax2, ax3 = fig.subplots(3, 1)\n\nax1.plot(x, y, label = \"Serie Original\")\nax1.plot(x, y_media, label = \"Media de la Serie Original\")\nax1.set_ylim(0, np.max(y)*1.3)\nax1.legend(loc = \"upper left\")\n\nax2.plot(x, y_log, label = \"Serie Log.\")\nax2.plot(x, y_log_media, label = \"Media de la Serie Log.\")\nax2.set_ylim(0, np.max(y_log)*1.3)\nax2.legend(loc = \"lower left\")\n\nax3.plot(x, y_log_diff, label = \"Serie Logar\u00edtmica diferenciada\")\nax3.plot(x, y_log_diff_media, label = \"Media de la Serie. Log. Diff\")\nax3.set_ylim(np.min(y_log_diff)*1.5, np.max(y_log_diff)*1.3)\nax3.legend(loc = \"lower left\")\n\nfig.suptitle(\"Capturaci\u00f3n de Pieles de Lince y sus transformaciones a lo largo de los a\u00f1os a lo largo de los a\u00f1os\");","9c7fe373":"ibex['Ibex_log_diff'].isnull().sum()","88face15":"ibex.dropna(axis=0, inplace=True)","630c470b":"LAGS = 24\n\nfig = plt.figure(figsize = (10, 10))\n\n((ax1, ax2), (ax3, ax4), (ax5, ax6)) = fig.subplots(3, 2)\n\n# ----------------------------------------------------------------------------------------------------\n# plot the data using the built in plots from the stats module\nplot_acf(y, ax = ax1, lags = LAGS, title = \"Autocorrelaci\u00f3n\")\nplot_pacf(y, ax = ax2, lags = LAGS, title = \"Autocorrelaci\u00f3n Parcial\")\n\nplot_acf(y_log, ax = ax3, lags = LAGS, title = \"Autocorrelaci\u00f3n\")\nplot_pacf(y_log, ax = ax4, lags = LAGS, title = \"Autocorrelaci\u00f3n Parcial\")\n\nplot_acf(y_log_diff, ax = ax5, lags = LAGS, title = \"Autocorrelaci\u00f3n\")\nplot_pacf(y_log_diff, ax = ax6, lags = LAGS, title = \"Autocorrelaci\u00f3n Parcial\")\n\nfig.tight_layout()","ddff4d48":"serie_a_predecir = y","549de94a":"y_index = serie_a_predecir.index\n\ndate_train = int(len(y_index)*0.9)\n\ny_train = serie_a_predecir[y_index[:date_train]]\ny_test = serie_a_predecir[y_index[date_train:len(y_index)]]","d7ab54a8":"y_train.tail()","f9a5af34":"y_test.head()","d69850ee":"p = d = q = range(0, 6)\npdq = list(itertools.product(p, d, q))\nseasonal_pdq = [(0, 0, 0, 0)]\nst = time.time()\n\nbest_score = 0\nbest_params = None\nbest_seasonal_params = None\n\nfor param in pdq:\n    for param_seasonal in seasonal_pdq:\n        try:\n            \n            mod = sm.tsa.statespace.SARIMAX(y_train,\n                                            order=param,\n                                            seasonal_order=param_seasonal,\n                                            enforce_stationarity = False,\n                                            enforce_invertibility = False)\n\n            results = mod.fit()\n\n            print('ARIMA{}x{}12 - AIC:{}'.format(param, param_seasonal, results.aic))\n            \n            # guardamos el mejor resultado\n            if best_score == 0:\n                best_score = results.aic\n                best_params = param\n                best_seasonal_params = param_seasonal\n                \n            elif abs(results.aic) < abs(best_score):\n                best_score = results.aic\n                best_params = param\n                best_seasonal_params = param_seasonal\n            \n        # alguna combinaci\u00f3n de par\u00e1metros en SARIMAX, no son v\u00e1lidos\n        # y los vamos a cazar con un except\n        except:\n            continue\n\net = time.time()\nprint(\"La b\u00fasqueda de par\u00e1metros no ha llevado {} minutos!\".format((et - st)\/60))\n","e8ce2170":"print(\"El mejor modelo es {}, \\nCon un AIC de {}\".format(best_params, best_score))","bbdaee18":"mod = sm.tsa.statespace.SARIMAX(y_train,\n                                order = best_params,\n                                seasonal_order = param_seasonal,\n                                enforce_stationarity = False,\n                                enforce_invertibility = False)\n\nresults = mod.fit()","76f1e08d":"results = mod.fit()\n\nprint(results.summary().tables[1])","4fc6dffe":"# Para hacer una predicci\u00f3n es suficiente con especificar el n\u00famero de steps\/pasos futuros a estimar.\npred_uc = results.get_forecast(steps = len(y_test))\n\n# Calcula el intervalo de confianza de la predicci\u00f3n.\npred_ci = pred_uc.conf_int()","6501da63":"pred_ci","c693cfb9":"predicted_values = pred_uc.predicted_mean.values","252a864c":"predicted_values","069c610f":"ax = serie_a_predecir.plot(label = 'Valores reales', figsize = (10, 10))\nax.plot(y_test.index, predicted_values, label = \"Predicci\u00f3n\")\n\nax.fill_between(y_test.index,\n                pred_ci.iloc[:, 0],\n                pred_ci.iloc[:, 1], color = 'k', alpha = .25)\n\nax.set_xlabel('Dia')\nax.set_ylabel('Ibex 35')\n\nplt.legend()\nplt.show()","5b6d0df9":"Pintamos nuestra Serie","cc3c567c":"Pintamos la transformacion logaritmica","c29a56eb":"Nos quedamos solo , desde el uno de Abril","0643d514":"Nos quedamos solo con la Fecha y el valor del ibex","dc67167f":"Preparamos los dataset de train y test","c56a00ac":"Calculamos el valor de los parametros:","e891774c":"Vamos a pintgra las series y ver si son estacionarias:","95fa7101":"Hacemos la transformacion por diferencias","972d9cff":"Cargamos el Dataset con los datos del Ibex de este a\u00f1o","0a628c8d":"La serie de diferencias tiene nulos","734c5834":"Ordenamos bien las fechas, de menor a mayor","b240b8b5":"Da un error con los tipo date que le hemos dado y no logra devolvernos las predicciones indexadas con una fecha","3b459987":"Vemos que la serie directa puede ser tratada como estacionaria con unos valores de P=5 y Q=5","c3ee9517":"Vamos a pintar las autocorrelaciones, totales y parciales de estas series para ver si son estacionarias o no","eea6de5a":"Cuando trato de covertir el valor del \u00edndice Ibex a n\u00famero, me da un error, seguramemte porque viene con formato espa\u00f1ol '.,' y no el americano ',.', asi que manipulo los avlores para dejar solo el ' como separador decimal.","7ff07e2b":"Pero como tenemos el index de test , vamos a usarlo como el indice de las predicciones","3c6dfa69":"\u00d1Ponemos la fecha como fecha"}}