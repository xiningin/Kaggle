{"cell_type":{"1841701e":"code","508d2f93":"code","419a6487":"code","95b37562":"code","cb1ab82f":"code","e97f87eb":"code","ebe2b225":"code","72558d2f":"code","4ffc2a04":"code","cb55676e":"markdown","b2731bbc":"markdown","be4be34f":"markdown","59b92e72":"markdown","f0c8bc25":"markdown","fd924df5":"markdown","0f62bdc9":"markdown","91de069c":"markdown"},"source":{"1841701e":"import numpy as np # linear algebra\nimport numba\nfrom numba import njit, jit\nfrom typing import Tuple, List\nimport sys\nimport os\n\nsys_maxsize = 2**24 if os.environ.get('KAGGLE_KERNEL_RUN_TYPE','') == 'Batch' else 2**16","508d2f93":"@njit\ndef collatz_sequence(N: int) -> List:\n    \"\"\" Generate a the 3N+1 Collatz Sequence \"\"\"\n    n       = N\n    history = [N]\n    cache   = set()\n    while True:\n        if n % 2 == 0: n = n \/\/ 2\n        else:          n = 3 * n + 1            \n        history.append(n)\n        \n        if n in cache: break\n        cache.add(n)\n        \n    return history","419a6487":"{ N: str(collatz_sequence(N)) for N in range(-16, 16+1) }","95b37562":"@njit\ndef rotate_loop(loop: np.array) -> np.array:\n    \"\"\" Roll an array such that the smallest number is at the end \"\"\"\n    min_value = min(np.abs(loop))\n    min_index = np.abs(loop).argmin()\n    return np.roll(loop, len(loop)-min_index-1)\n        \n# print( [4,2,1], '->', rotate_loop(np.array([4,2,1])) ) \n# print( [1,4,2], '->', rotate_loop(np.array([1,4,2])) ) \n# print( [2,1,4], '->', rotate_loop(np.array([2,1,4])) ) \n\n\n@njit\ndef collatz_loop(N: int) -> np.array:\n    \"\"\" Generate a the 3N+1 Collatz Sequence but only return the final looping sequence \"\"\"\n    history    = collatz_sequence(N)\n    last_n     = history[-1]\n    last_index = history.index(last_n)\n    loop       = history[last_index : -1]\n    loop_rot   = rotate_loop(np.array(loop, dtype=np.int32))\n    return loop_rot\n    \n# print( 'collatz_loop(32)', collatz_loop(32) )\n\n@njit\ndef unique_collatz_loops(min_N: int, max_N: int):\n    \"\"\" Brute force search for unique Collatz Sequence loops \"\"\"\n    output = []\n    for N in range(min_N, max_N+1):\n        loop = collatz_loop(N)\n        \n        for item in output:\n            if np.array_equal(loop, item): break\n        else:\n            output.append(loop)      \n    return list(map(list, output))","cb1ab82f":"# %%time\nunique_collatz_loops(1, sys_maxsize)","e97f87eb":"# %%time\nunique_collatz_loops(-sys_maxsize, -1)","ebe2b225":"@njit\ndef collatz_sequence_maximum(N: int) -> List:\n    \"\"\" Return the maximum number generated by the 3N+1 Collatz Sequence \"\"\"\n    history = np.array( collatz_sequence(N) )\n    max_value = np.max(history)\n    min_value = np.min(history)\n    if np.abs(max_value) > np.abs(min_value): return max_value \n    else:                                     return min_value\n\ndef collatz_sequence_maximums(max_value: int) -> List:\n    max_values = np.arange(0, max_value+1, dtype=np.int32)\n    output = np.vectorize(collatz_sequence_maximum)(max_values)\n    return output","72558d2f":"from matplotlib.pyplot import figure\nimport matplotlib.pyplot as plt\nfrom humanize import intcomma\n\nnumber_line      = np.arange(0, sys_maxsize+1)\ncollatz_maximums = collatz_sequence_maximums(sys_maxsize)\n\nfigure(figsize=(12, 6), dpi=80)\nplt.plot( collatz_maximums )\nplt.plot( number_line, number_line**2 \/ 10)\nplt.plot( number_line, number_line**0.5 * 5e5)\n\nprint('N', intcomma(collatz_maximums.argmax()), '= max', intcomma(collatz_maximums.max()))\nprint('Fit Green:  y(x) = sqrt(x) * 1e5')\nprint('Fit Orange: y(x) = x^2 \/ 10')","4ffc2a04":"fit_1   = np.polyfit(number_line, collatz_maximums, 1)\nfit_2   = np.polyfit(number_line, collatz_maximums, 2)\nfit_log = np.polyfit(np.log(number_line+1), np.log(collatz_maximums+1), 1)\n\nprint(f'Fit: y = {fit_2[0]:.2f}x^2 + {fit_2[1]:.2f}x + {fit_2[2]:.0f}')\nprint(f'Fit: y = {fit_1[0]:.2f}x + {fit_1[1]:.0f}')\nprint(f'Fit: y = exp( {fit_log[0]:.6f} log(x) + {fit_log[1]:.2f} )')","cb55676e":"## Maximum Numbers\n\nWe can plot the maximum value of each sequence.\n- The majority of values remain small, but there are some outliers","b2731bbc":"# Collatz Conjecture: 3N + 1\n\nThis notebook explores the unsolved Collatz Conjecture: 3N + 1 \n- https:\/\/www.youtube.com\/watch?v=094y1Z2wpJg\n- https:\/\/en.wikipedia.org\/wiki\/Collatz_conjecture\n\n> The Collatz conjecture in mathematics asks whether repeating certain simple arithmetic operations will eventually transform every positive integer into one. It concerns sequences of integers in which each term is obtained from the previous term as follows: if the previous term is even, the next term is one half of the previous term. If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that these sequences always reach 1, no matter which positive integer is chosen to start the sequence.","be4be34f":"## Example Sequences\n\nHere is a sample of Collatz Sequences\n- All the early positve examples end in the [1, 4, 2, 1] loop\n- Most of the negative examples end in [-1,-2,-1] loop, but there are some exceptions\n- Zero is a special case ","59b92e72":"## Unique Loops\n\nWe can perform a brute force search to verify the conjecture for computable numbers, that all sequences end the [4,2,1] loop, which contains the number 1","f0c8bc25":"## Code","fd924df5":"For positive numbers, we only get 1 terminal loop [4,2,1]","0f62bdc9":"For negative numbers we 3 distinct terminal loops","91de069c":"## Lines of Best Fit\n\n"}}