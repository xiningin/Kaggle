{"cell_type":{"39047f07":"code","c1531674":"code","16b864ef":"code","ff51e6d6":"code","932c3a7d":"code","e63fd44e":"code","bb64709f":"code","ea13b07b":"code","603cad52":"code","5441d364":"code","9d945372":"code","023a41bd":"code","17848734":"code","405160da":"code","640253ae":"code","46f8c13f":"code","de26b564":"code","61ee6c3f":"code","090bbbf9":"code","245bba8e":"code","4b1f0c73":"code","9ed34847":"code","eabdafe1":"code","fc8d0d0c":"code","c35df3b2":"code","b3bd6586":"code","8ba1b1d3":"code","fe6d8e7f":"code","04ec892c":"code","4ea3b201":"code","30b689e3":"code","54739d31":"markdown","38e8d060":"markdown","3f24116c":"markdown","7a6f276e":"markdown","bde8aa8e":"markdown","cd274bde":"markdown","b3d531ca":"markdown"},"source":{"39047f07":"import numpy as np\nimport pandas as pd\nimport os\n%matplotlib inline","c1531674":"PATH = '..\/input'","16b864ef":"os.listdir(PATH)","ff51e6d6":"train_df = pd.read_csv(f'{PATH}\/train.csv', nrows=10000000)","932c3a7d":"print(train_df.isnull().sum())\nprint('Old size %d'% len(train_df))\ntrain_df = train_df.dropna(how='any',axis='rows')\nprint('New size %d' % len(train_df))","e63fd44e":"train_df[:5]","bb64709f":"def add_travel_vector_features(df):\n    df['abs_diff_longitude'] = (df.dropoff_longitude - df.pickup_longitude).abs()\n    df['abs_diff_latitude'] = (df.dropoff_latitude - df.pickup_latitude).abs()\nadd_travel_vector_features(train_df)","ea13b07b":"train_df.iloc[:2000].plot.scatter('abs_diff_longitude', 'abs_diff_latitude')","603cad52":"train_df = train_df[(train_df.abs_diff_longitude<5) & (train_df.abs_diff_latitude<5)]\nprint(len(train_df))","5441d364":"import torch\nimport torch.nn as nn\nfrom torch.autograd import Variable","9d945372":"model = nn.Sequential(nn.Linear(2, 10),\n                     nn.Linear(10, 5),\n                      nn.Linear(5, 1))\n                    \n","023a41bd":"criterion = torch.nn.MSELoss()\noptimizer = torch.optim.SGD(model.parameters(), lr=0.01)\n","17848734":"X = np.stack((train_df.abs_diff_latitude.values,train_df.abs_diff_longitude.values)).T\nX = torch.from_numpy(X)\nX = X.type(torch.FloatTensor)","405160da":"y = torch.from_numpy(train_df.fare_amount.values.T)\ny = y.type(torch.FloatTensor)\ny.unsqueeze_(-1)","640253ae":"for epoch in range(90):\n    # Forward Propagation\n    y_pred = model(X)\n    # Compute and print loss\n    loss = criterion(y_pred, y)\n    print('epoch: ', epoch,' loss: ', loss.item())\n    # Zero the gradients\n    optimizer.zero_grad()\n    \n    # perform a backward pass (backpropagation)\n    loss.backward()\n    \n    # Update the parameters\n    optimizer.step()","46f8c13f":"optimizer = torch.optim.SGD(model.parameters(), lr=0.001)","de26b564":"for epoch in range(700):\n    # Forward Propagation\n    y_pred = model(X)\n    # Compute and print loss\n    loss = criterion(y_pred, y)\n    print('epoch: ', epoch,' loss: ', loss.item())\n    # Zero the gradients\n    optimizer.zero_grad()\n    \n    # perform a backward pass (backpropagation)\n    loss.backward()\n    \n    # Update the parameters\n    optimizer.step()","61ee6c3f":"y[:10]","090bbbf9":"y_pred[:10]","245bba8e":"test_df = pd.read_csv(f'{PATH}\/test.csv')","4b1f0c73":"test_df\n","9ed34847":"add_travel_vector_features(test_df)","eabdafe1":"X_test = np.stack((test_df.abs_diff_latitude.values,test_df.abs_diff_longitude.values)).T\nX_test = torch.from_numpy(X_test)\nX_test = X_test.type(torch.FloatTensor)","fc8d0d0c":"y_test = model(X_test)","c35df3b2":"y_test[:20]","b3bd6586":"test_df.key","8ba1b1d3":"y_test = y_test.detach().numpy()","fe6d8e7f":"y_test = y_test.reshape(-1)","04ec892c":"y_test","4ea3b201":"submission = pd.DataFrame(\n    {'key': test_df.key, 'fare_amount': y_test},\n    columns = ['key', 'fare_amount'])\nsubmission.to_csv('submission.csv', index = False)\n","30b689e3":"print(os.listdir('.'))\n","54739d31":"## Conclusion\n\nThis approach give me the score about 5.76538 and top 80%. \n\n**Improvement**\nFirst improvement I think is adding the nonlinear layer in the network. I tried to use RELU after each linear layer except the last layer but the result is worst. I'm very appreciate if someone can point out how to add some nonlinear activate function to improve the score.\n","38e8d060":"**Initial training with high learning rate 0.01**","3f24116c":"**Add new features: travelling distance**","7a6f276e":"**Remove null data from the dataframe**","bde8aa8e":"## This is a simple neural network to solve NYC Taxi Fare Challenge using Pytorch\n\nMost of the data preprocessing code is taken from this kernel [Simple Linear Model\n](https:\/\/www.kaggle.com\/dster\/nyc-taxi-fare-starter-kernel-simple-linear-model)\n\nInput of the network, similar to the Simple Linear Model kernel, is just the traveling distance of the taxi\n\nThe network used:\nmodel = nn.Sequential(nn.Linear(2, 10),\n                     nn.Linear(10, 5),\n                      nn.Linear(5, 1))","cd274bde":"**Further training with lower learning rate lr=0.001**","b3d531ca":"**Remove the bizzare travelling distance **"}}