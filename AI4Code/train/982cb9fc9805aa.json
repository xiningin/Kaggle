{"cell_type":{"1f92f7f3":"code","7d0b62f2":"code","b95c4b23":"code","e87416d6":"markdown","48ba65d1":"markdown","83e2afd3":"markdown"},"source":{"1f92f7f3":"import numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nimport re\nfrom kaggle_datasets import KaggleDatasets\n\nBATCH_SIZE = 64\nIMAGE_SIZE = [224, 224]\nGCS_PATH = KaggleDatasets().get_gcs_path('oxford-pets-dataset-tfrecords')\nAUTO = tf.data.experimental.AUTOTUNE\nTRAIN_FILENAMES = tf.io.gfile.glob([GCS_PATH + '\/train%.2i*.tfrec'%(x) for x in range(15)])\nTEST_FILENAMES = tf.io.gfile.glob([GCS_PATH + '\/test%.2i*.tfrec'%(x) for x in range(15)])","7d0b62f2":"def decode_image(image_data):\n    image = tf.image.decode_jpeg(image_data, channels=3)\n    image = tf.reverse(image, [-1])\n    image = tf.cast(image, tf.float32) \/ 255.0  # convert image to floats in [0, 1] range\n    image = tf.reshape(image, [*IMAGE_SIZE, 3]) # explicit size needed for TPU\n    return image\n\n\ndef read_labeled_tfrecord(example):\n    LABELED_TFREC_FORMAT = {\n        \"image\": tf.io.FixedLenFeature([], tf.string), # tf.string means bytestring\n        \"target\": tf.io.FixedLenFeature([], tf.int64),  # shape [] means single element\n    }\n    \n    example = tf.io.parse_single_example(example, LABELED_TFREC_FORMAT)\n    image = decode_image(example['image'])\n    label = tf.cast(example['target'], tf.int32)\n    return image, label # returns a dataset of (image, label) pairs\n\n\ndef load_dataset(filenames, ordered=False):\n    # Read from TFRecords. For optimal performance, reading from multiple files at once and\n    # disregarding data order. Order does not matter since we will be shuffling the data anyway.\n\n    ignore_order = tf.data.Options()\n    if not ordered:\n        ignore_order.experimental_deterministic = False # disable order, increase speed\n\n    dataset = tf.data.TFRecordDataset(filenames, num_parallel_reads=AUTO) # automatically interleaves reads from multiple files\n    dataset = dataset.with_options(ignore_order) # uses data as soon as it streams in, rather than in its original order\n    dataset = dataset.map(read_labeled_tfrecord, num_parallel_calls=AUTO)\n    # returns a dataset of (image, label) pairs if labeled=True or (image, id) pairs if labeled=False\n    return dataset\n  \n\ndef get_dataset(filenames):\n    dataset = load_dataset(filenames)\n    dataset = dataset.repeat() # the training dataset must repeat for several epochs\n    dataset = dataset.shuffle(2048)\n    dataset = dataset.batch(BATCH_SIZE)\n    dataset = dataset.prefetch(AUTO) # prefetch next batch while training (autotune prefetch buffer size)\n    return dataset\n\n\ndef count_data_items(filenames):\n    # the number of data items is written in the name of the .tfrec files, i.e. flowers00-230.tfrec = 230 data items\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) for filename in filenames]\n    return np.sum(n)\n\n\nNUM_TRAINING_IMAGES = count_data_items(TRAIN_FILENAMES)\nNUM_TEST_IMAGES = count_data_items(TEST_FILENAMES)\nprint('Dataset: {} training images, {} test images'.format(NUM_TRAINING_IMAGES, NUM_TEST_IMAGES))","b95c4b23":"row = 6; col = 4;\nrow = min(row,BATCH_SIZE\/\/col)\nall_elements = get_dataset(TRAIN_FILENAMES)\n\nfor (img,label) in all_elements:\n    plt.figure(figsize=(15,int(15*row\/col)))\n    for j in range(row*col):\n        plt.subplot(row,col,j+1)\n        plt.axis('off')\n        plt.imshow(img[j,])\n    plt.show()\n    break","e87416d6":"We are building a TFRecords pipeline which can be used to train CNNs. \nEdited code from [this](https:\/\/www.kaggle.com\/khoongweihao\/siim-isic-multiple-model-training-stacking) notebook:","48ba65d1":"### Display images\n\nEdited code from [here](https:\/\/www.kaggle.com\/cdeotte\/cutmix-and-mixup-on-gpu-tpu):","83e2afd3":"### Lets take a look at the images in TFRecords!"}}