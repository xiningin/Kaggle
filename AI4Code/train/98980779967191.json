{"cell_type":{"ae24c72f":"code","d5208629":"code","c2f7658f":"code","d60124d8":"code","b588b500":"code","7d2c4806":"code","6cb9dde7":"code","ce86ba9d":"code","dcb5a808":"code","8061dc12":"code","94c6e4ff":"code","d4318c08":"code","7db9c9aa":"code","4320e284":"code","d82d763b":"code","740e7c4d":"code","08e85c69":"markdown","4788aa3d":"markdown","8075ff87":"markdown","b1fa2109":"markdown","585d37ce":"markdown","9d985304":"markdown"},"source":{"ae24c72f":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report,confusion_matrix\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.ensemble import ExtraTreesClassifier\nimport seaborn as sns\nimport numpy as np\nfrom scipy.stats import norm\nfrom sklearn.metrics import accuracy_score\nfrom sklearn import preprocessing\nfrom scipy import stats\nimport warnings\n\nwarnings.filterwarnings('ignore')\n%matplotlib inline","d5208629":"bcell_data = pd.read_csv(r'\/kaggle\/input\/epitope-prediction\/input_bcell.csv')\nsars_data = pd.read_csv(r'\/kaggle\/input\/epitope-prediction\/input_sars.csv')","c2f7658f":"bcell_data.head()","d60124d8":"bcell_data['peptide_length'] = bcell_data.end_position - bcell_data.start_position \nsars_data['peptide_length'] = sars_data.end_position - sars_data.start_position\n\nbcell_data['protein_length'] = bcell_data['protein_seq'].astype(str).map(len)\nsars_data['protein_length'] = sars_data['protein_seq'].astype(str).map(len)\n\nbcell_data['parent_protein_length'] = bcell_data['parent_protein_id'].astype(str).map(len)\nsars_data['parent_protein_length'] = sars_data['parent_protein_id'].astype(str).map(len)\n\nbcell_data['peptide_position_inprotein'] = bcell_data['start_position'] \/ bcell_data['protein_seq'].astype(str).map(len)\nsars_data['peptide_position_inprotein'] = sars_data['start_position'] \/ sars_data['protein_seq'].astype(str).map(len)","b588b500":"bcell_data_train, bcell_data_test = train_test_split(bcell_data, test_size=0.2, random_state=None)","7d2c4806":"features = ['chou_fasman', 'kolaskar_tongaonkar', 'parker',\n       'isoelectric_point', 'aromaticity', 'hydrophobicity', 'stability',\n       'peptide_length']","6cb9dde7":"X_train = bcell_data_train[features]\ny_train = bcell_data_train.target\nX_val = bcell_data_test[features]\ny_val = bcell_data_test.target\n\nsars_X = sars_data[features]\nsars_y = sars_data.target","ce86ba9d":"params = {\n    \"n_estimators\" : 1000,\n    \"n_jobs\" : 4,\n    \"verbose\" : 1,\n    \"criterion\" : \"entropy\",\n    \"random_state\" : None,\n    \"min_samples_split\" : 8,\n    \"min_weight_fraction_leaf\" : 0.0,\n    \"max_features\" : \"sqrt\",\n    \"bootstrap\" : True,\n    \"oob_score\" : True,\n    \"class_weight\" : \"balanced\"\n}","dcb5a808":"model = RandomForestClassifier(**params)","8061dc12":"model.fit(X_train, y_train)","94c6e4ff":"bcell_predictions = model.predict(X_val)\nsars_predictions = model.predict(sars_data[features])","d4318c08":"#confusion matrix\nplt.figure(figsize = (10,10))\ncm = confusion_matrix(y_val, bcell_predictions)\nsns.heatmap(cm,cmap= \"Blues\", linecolor = 'black', linewidth = 1, annot = True, fmt='', \n            xticklabels = ['False', 'True'], yticklabels = ['False', 'True'])\nplt.xlabel(\"Predicted\")\nplt.ylabel(\"Actual\")","7db9c9aa":"#confusion matrix\nplt.figure(figsize = (10,10))\ncm = confusion_matrix(sars_data.target, sars_predictions)\nsns.heatmap(cm,cmap= \"Blues\", linecolor = 'black', linewidth = 1, annot = True, fmt='', \n            xticklabels = ['False', 'True'], yticklabels = ['False', 'True'])\nplt.xlabel(\"Predicted\")\nplt.ylabel(\"Actual\")","4320e284":"sars_data['status'] = 'NoStatus'\nsars_data['status'][(sars_data.target == sars_predictions) & (sars_data.target == 1)] = 'True_Positive'\nsars_data['status'][(sars_data.target != sars_predictions) & (sars_data.target == 1)] = 'False_Positive' \nsars_data['status'][(sars_data.target == sars_predictions) & (sars_data.target == 0)] = 'True_Negative'\nsars_data['status'][(sars_data.target != sars_predictions) & (sars_data.target == 0)] = 'False_Negative'\n\nconfusionMatrixCols = ['True_Positive', 'False_Negative', 'True_Negative', 'False_Positive']","d82d763b":"#Some features are excluded here because all values are the same.\n\nfor feature in features:\n    if sars_data[feature].min() != sars_data[feature].max():\n        try: \n            plt.figure(figsize=(16,5))\n\n            for cm in confusionMatrixCols:\n                \n                subset = sars_data[sars_data['status'] == cm]\n\n                sns.distplot(subset[feature], hist = False, kde = True,\n                             kde_kws = {'linewidth': 2},\n                             label = cm)\n                \n            plt.legend(prop={'size': 16}, title = 'status')\n            plt.xlabel(feature)\n            plt.ylabel('Density')\n        except:\n            pass","740e7c4d":"print(f\"Bcell prediction accuracy score: {accuracy_score(bcell_predictions, y_val)}\")\nprint(f\"SARS prediction accuracy score: {accuracy_score(sars_predictions, sars_data.target)}\")","08e85c69":"# Model Building","4788aa3d":"# Conclusion\n\nIn conclusion, without too much effort and the right features a nice accuracy is easily achievable.\nThis is my first submission\/notebook on this topic. The next problem I'll have too solve is the great amout of false positives,\nany tips are welcome! If anyone is interested in how I selected my features leave a comment please.\n","8075ff87":"# Simple feature engineering","b1fa2109":"# Preprocessing","585d37ce":"# Changelog:\n\n* 14 september 2020: Submitted notebook\n* 15 september 2020: Changed title and minor fix. (notebook re-runned)\n* 15 september 2020: Improved confusion matrix graphs to exclude invalid features","9d985304":"# Post-prediction analysis"}}