{"cell_type":{"04c356ef":"code","ea902e4e":"code","d12dcbef":"code","678e1591":"code","e9d72270":"code","bf58438f":"code","0addd14d":"code","0d4dcf09":"code","92c3d829":"code","3dc335c1":"code","e38901d0":"code","b6c8d86f":"code","08d3a8b4":"code","1ebe26eb":"code","2275f4a2":"code","9484abe8":"code","ef0a2104":"code","674f2703":"markdown","1359059c":"markdown","175962ef":"markdown","d50dcf20":"markdown","8ea56a91":"markdown","5b511465":"markdown","f1070299":"markdown","aae153a3":"markdown","78eb7f5f":"markdown","5356b99a":"markdown","72a8bfcf":"markdown","65d591c4":"markdown","73a47495":"markdown","f95e6347":"markdown","1c173728":"markdown","844f0220":"markdown"},"source":{"04c356ef":"#@title Install all dependencies and import all modules\n!pip install pyFluidSynth\n!apt install fluidsynth #Pip does not work for some reason. Only apt works\n!pip install midi2audio\n!pip install pretty_midi\n!pip install pypianoroll\n!pip install mir_eval\n!pip install keras_self_attention\nfrom midi2audio import FluidSynth\nfrom google.colab import output\nfrom IPython.display import display, Javascript, HTML, Audio\n\n\n# Imports\nfrom music21 import converter, instrument, note, chord, stream, midi\nimport glob\nimport time\nimport numpy as np\nimport keras.utils as utils\nimport pandas as pd\nimport tensorflow as tf\nimport os","ea902e4e":"#@title Define all functions and variables\n# Melody-RNN Format is a sequence of 8-bit integers indicating the following:\n# MELODY_NOTE_ON = [0, 127] # (note on at that MIDI pitch)\nMELODY_NOTE_OFF = 128 # (stop playing all previous notes)\nMELODY_NO_EVENT = 129 # (no change from previous event)\n# Each element in the sequence lasts for one sixteenth note.\n# This can encode monophonic music only.\n\ndef streamToNoteArray(stream):\n    \"\"\"\n    Convert a Music21 sequence to a numpy array of int8s into Melody-RNN format:\n        0-127 - note on at specified pitch\n        128   - note off\n        129   - no event\n    \"\"\"\n    # Part one, extract from stream\n    total_length = np.int(np.round(stream.flat.highestTime \/ 0.25)) # in semiquavers\n    stream_list = []\n    for element in stream.flat:\n        if isinstance(element, note.Note):\n            stream_list.append([np.round(element.offset \/ 0.25), np.round(element.quarterLength \/ 0.25), element.pitch.midi])\n        elif isinstance(element, chord.Chord):\n            stream_list.append([np.round(element.offset \/ 0.25), np.round(element.quarterLength \/ 0.25), element.sortAscending().pitches[-1].midi])\n    np_stream_list = np.array(stream_list, dtype=np.int)\n    df = pd.DataFrame({'pos': np_stream_list.T[0], 'dur': np_stream_list.T[1], 'pitch': np_stream_list.T[2]})\n    df = df.sort_values(['pos','pitch'], ascending=[True, False]) # sort the dataframe properly\n    df = df.drop_duplicates(subset=['pos']) # drop duplicate values\n    # part 2, convert into a sequence of note events\n    output = np.zeros(total_length+1, dtype=np.int16) + np.int16(MELODY_NO_EVENT)  # set array full of no events by default.\n    # Fill in the output list\n    for i in range(total_length):\n        if not df[df.pos==i].empty:\n          try:\n            n = df[df.pos==i].iloc[0] # pick the highest pitch at each semiquaver\n            output[i] = n.pitch # set note on\n            output[i+n.dur] = MELODY_NOTE_OFF\n          except:\n              print('Bad note. Skipping...')\n    return output\n\n\ndef noteArrayToDataFrame(note_array):\n    \"\"\"\n    Convert a numpy array containing a Melody-RNN sequence into a dataframe.\n    \"\"\"\n    df = pd.DataFrame({\"code\": note_array})\n    df['offset'] = df.index\n    df['duration'] = df.index\n    df = df[df.code != MELODY_NO_EVENT]\n    df.duration = df.duration.diff(-1) * -1 * 0.25  # calculate durations and change to quarter note fractions\n    df = df.fillna(0.25)\n    return df[['code','duration']]\n\n\ndef noteArrayToStream(note_array):\n    \"\"\"\n    Convert a numpy array containing a Melody-RNN sequence into a music21 stream.\n    \"\"\"\n    df = noteArrayToDataFrame(note_array)\n    melody_stream = stream.Stream()\n    for index, row in df.iterrows():\n        if row.code == MELODY_NO_EVENT:\n            new_note = note.Rest() # bit of an oversimplification, doesn't produce long notes.\n        elif row.code == MELODY_NOTE_OFF:\n            new_note = note.Rest()\n        else:\n            new_note = note.Note(row.code)\n        new_note.quarterLength = row.duration\n        melody_stream.append(new_note)\n    return melody_stream\n\n#wm_mid = converter.parse(\"\/content\/seed.mid\")\n#wm_mid.show()\n#wm_mel_rnn = streamToNoteArray(wm_mid)\n#print(wm_mel_rnn)\n#noteArrayToStream(wm_mel_rnn)\n","d12dcbef":"#@title Alex Piano Only Drafts Original 1500 MIDIs \n%cd \/content\/Performance-RNN-PyTorch\/dataset\/midi\n!wget 'https:\/\/github.com\/asigalov61\/AlexMIDIDataSet\/raw\/master\/AlexMIDIDataSet-CC-BY-NC-SA-All-Drafts-Piano-Only.zip'\n!unzip -j 'AlexMIDIDataSet-CC-BY-NC-SA-All-Drafts-Piano-Only.zip'","678e1591":"#@title Execute this cell to upload your MIDIs Data Set. Do not upload a lot and make sure that the files are not broken or have unusual configuration\/settings.\nfrom google.colab import files\n\nuploaded = files.upload()\n\nfor fn in uploaded.keys():\n  print('User uploaded file \"{name}\" with length {length} bytes'.format(\n      name=fn, length=len(uploaded[fn])))","e9d72270":"#@title Parse the uploaded MIDI DataSet into a special Numpy Array of notes\nimport time\nmidi_files = glob.glob(\"\/content\/*.mid\") # this won't work, no files there.\n\ntraining_arrays = []\nfor f in midi_files:\n    try:\n        start = time.clock()\n        s = converter.parse(f)\n        print(\"Parsed:\", f, \"it took\", time.clock() - start)\n    except:\n        continue\n    for p in s.parts:\n        start = time.clock()\n        arr = streamToNoteArray(p)\n        training_arrays.append(arr)\n        print(\"Converted:\", f, \"it took\", time.clock() - start)\n\ntraining_dataset = np.array(training_arrays)\nnp.savez('melody_training_dataset.npz', train=training_dataset)","bf58438f":"#@title Training Hyperparameters { run: \"auto\" }\ngenerated_sequence_length = 128 #@param {type:\"slider\", min:0, max:256, step:8}\nhidden_layer_size = 256 #@param {type:\"slider\", min:0, max:512, step:16}\nnumber_of_training_epochs = 60 #@param {type:\"slider\", min:0, max:200, step:1}\ntraining_batch_size = 2048 #@param {type:\"number\"}\n\nVOCABULARY_SIZE = 130 # known 0-127 notes + 128 note_off + 129 no_event\nSEQ_LEN = generated_sequence_length\nBATCH_SIZE = training_batch_size\nHIDDEN_UNITS = hidden_layer_size\nEPOCHS = number_of_training_epochs\nSEED = 2345  # 2345 seems to be good.\nnp.random.seed(SEED)\n\nwith np.load('.\/melody_training_dataset.npz', allow_pickle=True) as data:\n    train_set = data['train']\n\nprint(\"Training melodies:\", len(train_set))","0addd14d":"#@title Defining additional Conversion Functions\ndef slice_sequence_examples(sequence, num_steps):\n    \"\"\"Slice a sequence into redundant sequences of lenght num_steps.\"\"\"\n    xs = []\n    for i in range(len(sequence) - num_steps - 1):\n        example = sequence[i: i + num_steps]\n        xs.append(example)\n    return xs\n\ndef seq_to_singleton_format(examples):\n    \"\"\"\n    Return the examples in seq to singleton format.\n    \"\"\"\n    xs = []\n    ys = []\n    for ex in examples:\n        xs.append(ex[:-1])\n        ys.append(ex[-1])\n    return (xs,ys)\n\n# Prepare training data as X and Y.\n# This slices the melodies into sequences of length SEQ_LEN+1.\n# Then, each sequence is split into an X of length SEQ_LEN and a y of length 1.\n\n# Slice the sequences:\nslices = []\nfor seq in train_set:\n    slices +=  slice_sequence_examples(seq, SEQ_LEN+1)\n\n# Split the sequences into Xs and ys:\nX, y = seq_to_singleton_format(slices)\n# Convert into numpy arrays.\nX = np.array(X)\ny = np.array(y)\n\n# Look at the size of the training corpus:\nprint(\"Total Training Corpus:\")\nprint(\"X:\", X.shape)\nprint(\"y:\", y.shape)\nprint()\n\n# Have a look at one example:\nprint(\"Looking at one example:\")\nprint(\"X:\", X[95])\nprint(\"y:\", y[95])\n# Note: Music data is sparser than text, there's lots of 129s (do nothing)\n# and few examples of any particular note on.\n# As a result, it's a bit harder to train a melody-rnn.","0d4dcf09":"#@title Uploaded MIDIs Statitics\n# Do some stats on the corpus.\nall_notes = np.concatenate(train_set)\nprint(\"Number of notes:\")\nprint(all_notes.shape)\nall_notes_df = pd.DataFrame(all_notes)\nprint(\"Notes that do appear:\")\nunique, counts = np.unique(all_notes, return_counts=True)\nprint(unique)\nprint(\"Notes that don't appear:\")\nprint(np.setdiff1d(np.arange(0,129),unique))\n\nprint(\"Plot the relative occurences of each note:\")\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n#plt.style.use('dark_background')\nplt.bar(unique, counts)\nplt.yscale('log')\nplt.xlabel('melody RNN value')\nplt.ylabel('occurences (log scale)')","92c3d829":"#@title Import needed modules and build the model\nimport keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Activation\nfrom keras.layers import LSTM, Dropout, Bidirectional, Flatten\nfrom keras.layers.embeddings import Embedding\nfrom keras.optimizers import RMSprop\nfrom keras.utils.data_utils import get_file\nfrom keras.models import load_model\nfrom keras_self_attention import SeqSelfAttention\n# build the model: 2-layer LSTM network.\n# Using Embedding layer and sparse_categorical_crossentropy loss function \n# to save some effort in preparing data.\nprint('Building model...')\nmodel_train = Sequential()\nmodel_train.add(Embedding(VOCABULARY_SIZE, HIDDEN_UNITS, input_length=SEQ_LEN))\n\n# LSTM part\nmodel_train.add(LSTM(HIDDEN_UNITS, return_sequences=True))\nmodel_train.add(Dropout(0.3))\nmodel_train.add(LSTM(HIDDEN_UNITS))\nmodel_train.add(Dropout(0.3))\nmodel_train.add(Flatten())\n# Project back to vocabulary\nmodel_train.add(Dense(VOCABULARY_SIZE, activation='softmax'))\nmodel_train.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodel_train.summary()","3dc335c1":"#@title Train the model (this takes time, 50 epochs min recommended) and plot the results\n\nimport matplotlib.pyplot as plt\n\nhistory = model_train.fit(X, y, validation_split=0.33, batch_size=BATCH_SIZE, epochs=EPOCHS)\n\nprint(history.history.keys())\n# summarize history for accuracy\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()\n# summarize history for loss\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()\nmodel_train.save(\"noobiano-pre-trained-model.h5\")","e38901d0":"#@title SAVE\nmodel_train.save(\"noobiano-pre-trained-model.h5\")","b6c8d86f":"#@title LOAD\n# Load if necessary - don't need to do this.\nmodel_train = keras.models.load_model(\"noobiano-pre-trained-model.h5\")","08d3a8b4":"#@title Build a decoding model (input length 1, batch size 1, stateful)\n# Build a decoding model (input length 1, batch size 1, stateful)\nmodel_dec = Sequential()\nmodel_dec.add(Embedding(VOCABULARY_SIZE, HIDDEN_UNITS, input_length=1, batch_input_shape=(1,1)))\n# LSTM part\nmodel_dec.add(LSTM(HIDDEN_UNITS, stateful=True, return_sequences=True))\nmodel_dec.add(Dropout(0.3))\nmodel_dec.add(LSTM(HIDDEN_UNITS, stateful=True))\nmodel_dec.add(Dropout(0.3))\nmodel_dec.add(Flatten())\n# project back to vocabulary\nmodel_dec.add(Dense(VOCABULARY_SIZE, activation='softmax'))\nmodel_dec.compile(loss='sparse_categorical_crossentropy', optimizer='adam')\nmodel_dec.summary()\n# set weights from training model\n#model_dec.set_weights(model_train.get_weights())\nmodel_dec.load_weights(\"noobiano-pre-trained-model.h5\")","1ebe26eb":"#@title Define Sampling\/Generation Functions\ndef sample(preds, temperature=1.0):\n    \"\"\" helper function to sample an index from a probability array\"\"\"\n    preds = np.asarray(preds).astype('float64')\n    preds = np.log(preds) \/ temperature\n    exp_preds = np.exp(preds)\n    preds = exp_preds \/ np.sum(exp_preds)\n    probas = np.random.multinomial(1, preds, 1)\n    return np.argmax(probas)\n\n## Sampling function\n\ndef sample_model(seed, model_name, length=400, temperature=1.0):\n    '''Samples a musicRNN given a seed sequence.'''\n    generated = []  \n    generated.append(seed)\n    next_index = seed\n    for i in range(length):\n        x = np.array([next_index])\n        x = np.reshape(x,(1,1))\n        preds = model_name.predict(x, verbose=0)[0]\n        next_index = sample(preds, temperature)        \n        generated.append(next_index)\n    return np.array(generated)","2275f4a2":"#@title Generate some Music from your model :) Play with parameters below until you get what you like\nprimer_length = 16 #@param {type:\"slider\", min:1, max:128, step:1}\ndesired_composition_length_in_tokens = 512 #@param {type:\"slider\", min:0, max:1024, step:8}\ncreativity_temperature = 0.7 #@param {type:\"slider\", min:0, max:4, step:0.1}\nmodel_dec.reset_states() # Start with LSTM state blank\no = sample_model(primer_length, model_dec, length=desired_composition_length_in_tokens, temperature=creativity_temperature) # generate 8 bars of melody\n\nmelody_stream = noteArrayToStream(o) # turn into a music21 stream\n#melody_stream.show() # show the score.\nfp = melody_stream.write('midi', fp='output_midi.mid')","9484abe8":"#@title Plot and Graph the Output :)\ngraphs_length_inches = 18 #@param {type:\"slider\", min:0, max:20, step:1}\nnotes_graph_height = 6 #@param {type:\"slider\", min:0, max:20, step:1}\nhighest_displayed_pitch = 90 #@param {type:\"slider\", min:1, max:128, step:1}\nlowest_displayed_pitch = 40 #@param {type:\"slider\", min:1, max:128, step:1}\npr_color_map = \"Blues\"\nrendered_wav_graph_height = 3\nimport librosa\nimport numpy as np\nimport pretty_midi\nimport pypianoroll\nfrom pypianoroll import Multitrack, Track\nimport matplotlib\nimport matplotlib.pyplot as plt\n#matplotlib.use('SVG')\n# For plotting\nimport mir_eval.display\nimport librosa.display\n%matplotlib inline\n\n\nmidi_data = pretty_midi.PrettyMIDI('\/content\/output_midi.mid')\n\ndef plot_piano_roll(pm, start_pitch, end_pitch, fs=100):\n    # Use librosa's specshow function for displaying the piano roll\n    librosa.display.specshow(pm.get_piano_roll(fs)[start_pitch:end_pitch],\n                             hop_length=1, sr=fs, x_axis='time', y_axis='cqt_note',\n                             fmin=pretty_midi.note_number_to_hz(start_pitch))\n\n\n\nroll = np.zeros([int(graphs_length_inches), 128])\n# Plot the output\n\n#track = Multitrack('\/content\/output_midi.mid', name='track')\n#plt.figure(figsize=[graphs_length_inches, notes_graph_height])\n#fig, ax = track.plot()\n#fig.set_size_inches(graphs_length_inches, notes_graph_height)\nplt.figure(figsize=[graphs_length_inches, notes_graph_height])\nax2 = plot_piano_roll(midi_data, lowest_displayed_pitch, highest_displayed_pitch)\nplt.show(block=False)\n\n## Play a melody stream\n\n\n!cp \/usr\/share\/sounds\/sf2\/FluidR3_GM.sf2 \/content\/font.sf2\n\n\nFluidSynth(\"\/content\/font.sf2\").midi_to_audio('output_midi.mid','output_wav.wav')\n# set the src and play\nAudio(\"output_wav.wav\")\n\n","ef0a2104":"from google.colab import drive\ndrive.mount('\/content\/drive')","674f2703":"# Sampling from the Model\n\n- We need define two functions for sampling:\n    - `sample`: samples from the categorical distribution output by the model, with a diversity adjustment procedure.\n    - `sample_model`: samples number of notes from the model using a one-note seed.","1359059c":"Save the resulting trained model","175962ef":"# Decoding Model\n\nNow we build a 1-in, 1-out model for encoding. This is the same model as for training, just with a input length of 1, and LSTM statefulness turned on.\n\n- Much faster to use the network with this model!\n- The weights are loaded directly from the saved `train_model` file.","d50dcf20":"# Training\n\n- I trained this model on Google's Colaboratory system (free online Python machine learning environment, including GPU).\n- Good to train for lots of epochs, I tried for 100: less is possible.\n- Takes around 3 minutes per epoch on an NVidia K80 GPU = 5 hours to train.\n\nHere's the training diagram:\n\n<img src=\"https:\/\/github.com\/cpmpercussion\/creative-prediction\/blob\/master\/notebooks\/figures\/training_melody_rnn.png?raw=1\" style=\"width: 600px;\"\/>\n\nProbably could have stopped after about 50 epochs to save some time!\n\nThis trained model is included in the repo, so you can go ahead and load that, or train again with your own dataset.","8ea56a91":"Load the saved model (if you need to restore\/reload the model)","5b511465":"#Congratulations !!! You did it :)))","f1070299":"# Load Training Data and Create RNN\n\nIn the following we load in the training dataset, slice the melodies into example sequences and build our Melody RNN.","aae153a3":"# Noobiano 2\n\n## A Beginner Introduction to Music Generation with Artificial Intelligence (Neural Networks)\n## Huge thanks and all credit for this beautiful colab go out to Charles Martin https:\/\/github.com\/cpmpercussion\/creative-prediction\n\n- Music is a complex phenomenon with many representations (e.g., digital audio, musical scores, lead sheets)\n- A simple representation of music is as a sequence of notes and rests:\n    - (equivalent to one line of melody)\n- This can be one-hot encoded and applied to a CharRNN!\n\n### A simple music representation\n\n- Our musical representation is going be a sequence of integers between 0 and 129.\n- Each integer represents a musical instruction lasting for one sixteenth note (one semiquaver) of duration.\n    - This is a typical level of detail for electronic music sequencers.\n- MIDI is a standard way of encoding instructions for synthesised instruments and can represent whole musical scores.\n    - Standard MIDI allows 128 pitches (there are only 88 on a piano keyboard) where number 60 is 'middle C'.\n    \n#### Melody-RNN Encoding\n\n- 0-127 play a note at that MIDI note number. (`MELODY_NOTE_ON`)\n- 128 stop whatever note was playing. (`MELODY_NOTE_OFF`)\n- 129 do nothing. (`MELODY_NO_EVENT`)\n    \nThis encoding should allow long notes (a note-on followed by one or more no-change events, then a note-off), and rests (a note-off followed by one or more no-change events).\n\nHere's a standard melody converted into this format:\n\n![](https:\/\/github.com\/cpmpercussion\/creative-prediction\/blob\/master\/notebooks\/figures\/wm_score_example.png?raw=1)\n\nNB: Google's [Magenta project](https:\/\/magenta.tensorflow.org\/) have created some really great musical RNNs, with lots of advanced features. This script focusses on simplicity and clarity instead!","78eb7f5f":"# Let's sample some music!\n\n- Generate 127 notes + the starting note 60 (middle C) - this corresponds to 8 bars of melody\n- Turn the sequence back into a music21 stream\n- Show as musial score, play it back, or save as a MIDI file!\n\n","5356b99a":"<a href=\"https:\/\/colab.research.google.com\/github\/asigalov61\/Noobiano\/blob\/master\/Noobiano.ipynb\" target=\"_parent\"><img src=\"https:\/\/colab.research.google.com\/assets\/colab-badge.svg\" alt=\"Open In Colab\"\/><\/a>","72a8bfcf":"#Plot and Play generated Melody :)","65d591c4":"## Construct a dataset of popular melodies\n\nOpen some midi files and extract the melodies as numpy note sequence arrays.","73a47495":"### Convert between MIDI files and numpy arrays in melody format\n\n- Music is more complex than text (e.g., more than one note might happen at once). \n- We use the Music21 library to read MIDI music filescand then convert to our Melody-RNN format.\n- The functions below turn a Music21 \"stream\" (of notes) into a numpy array of 8-bit integers.\n- All complex rhythms are simplified to sixteenth note versions.\n- Chords are simplified to the highest note.\n\n","f95e6347":"#Setup the environment and install\/import all dependencies","1c173728":"# Define the Training RNN\n\n- The training RNN will be more complex than in the text examples.\n- Using 2 layers of LSTM 256 LSTM cells each.\n- Using an Embedding layer on the input (saves some effort in creating one-hot examples)\n- Using sparse categorical cross entropy for loss (so that ys don't have to be one-hot)","844f0220":"You can upload or download everything to your Google Drive here (standard GD connect code)"}}