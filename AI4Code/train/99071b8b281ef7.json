{"cell_type":{"79e00c6d":"code","80b2f5af":"code","7656d684":"code","780640eb":"code","743849a5":"code","ca52f1a7":"code","cadfcc33":"code","4ef74e43":"code","f7f2f186":"code","d8adc8f5":"code","d6f36084":"code","478b1a90":"code","ba132a8a":"code","0fee8398":"code","6a0cc606":"code","f4d443ba":"code","bd2fae63":"code","0dac7800":"code","e960d71c":"code","6fc0d390":"code","2c785090":"code","04c2b090":"code","ccf8772c":"code","4bb15cbb":"code","37ab4336":"code","55409107":"code","89d49c7a":"code","75442afe":"code","21606d5a":"code","5220c6a5":"code","45d084f0":"code","79bb1e96":"code","28b95fdf":"code","568299a7":"code","59341b2f":"code","28ed55d8":"markdown","f0ca30d2":"markdown","6a4b48bf":"markdown","77249bf1":"markdown","807939e4":"markdown","1e5f942f":"markdown","5eb88a6f":"markdown","fa876472":"markdown","c0a22698":"markdown","184338bf":"markdown","9514b22a":"markdown","c474812a":"markdown","f7963341":"markdown","9931b362":"markdown","fb549f8b":"markdown","ef434577":"markdown","e8d00c45":"markdown","31aff358":"markdown","db7b4229":"markdown","acbe7bcc":"markdown","1b815196":"markdown","357ea8e2":"markdown","a62e6dd8":"markdown","ebf380c1":"markdown","8ff2da63":"markdown","df24cccb":"markdown","45e430e0":"markdown","85fea96d":"markdown","135e1bdd":"markdown","5f11dc64":"markdown","3b22f0f2":"markdown","4a75bd66":"markdown","a3509478":"markdown","0ed439c9":"markdown","ed602950":"markdown","3fa4bdea":"markdown","504ba849":"markdown","f7d64d41":"markdown","c8edff78":"markdown","036d9dc7":"markdown","eee3f40e":"markdown","78f81a72":"markdown","1bbb89f2":"markdown","fe3984f9":"markdown","483062e1":"markdown","487c862f":"markdown","b2918adf":"markdown","43e8ee91":"markdown","eeca2540":"markdown","cd67884e":"markdown","a80eb10a":"markdown","89767065":"markdown","b2c8c23d":"markdown","85d52666":"markdown","3a22ceae":"markdown","33b58d65":"markdown","f0699df4":"markdown","1abf0ed8":"markdown","c7348042":"markdown","26100482":"markdown","292739fc":"markdown","e20e5698":"markdown","18a4d556":"markdown","d9e4f8b8":"markdown","8f65c4c3":"markdown","2116164a":"markdown","75c190c9":"markdown","b2f23fcf":"markdown","c5fc2c83":"markdown","8c91e884":"markdown","4a13ce03":"markdown","1e0a0679":"markdown","bed55404":"markdown","d8d09550":"markdown","5942c315":"markdown","7ef759ca":"markdown","5eb518a0":"markdown","cbf8332c":"markdown","7799f409":"markdown","7d698f1c":"markdown","80eb0c88":"markdown","22c9a079":"markdown","6fb48061":"markdown","6178ff8a":"markdown","484783c6":"markdown","4ecd7e1c":"markdown","212cab1b":"markdown"},"source":{"79e00c6d":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense,Activation,Flatten,Conv2D,MaxPooling2D,BatchNormalization,Dropout,ZeroPadding2D\n","80b2f5af":"mnist_train=pd.read_csv('..\/input\/digit-recognizer\/train.csv')\ninputs_test=pd.read_csv('..\/input\/digit-recognizer\/test.csv')","7656d684":"mnist_train.head()","780640eb":"mnist_train.shape","743849a5":"inputs_train=mnist_train.drop('label',axis=1)","ca52f1a7":"target_train=mnist_train['label']","cadfcc33":"inputs_train.head()","4ef74e43":"target_train.head()","f7f2f186":"type(inputs_train)","d8adc8f5":"type(target_train)","d6f36084":"inputs_train=np.array(inputs_train)\ntarget_train=np.array(target_train)\ninputs_test=np.array(inputs_test)","478b1a90":"figure,subplot1=plt.subplots(10,5)\nfigure.set_figheight(30)\nfigure.set_figwidth(15)\ncurr_num=0\nnum_count=0\nsub1=0\nsub2=0\nfor x in range(len(target_train)):\n    if target_train[x]==curr_num:\n        subplot1[sub1][sub2].imshow(inputs_train[x].reshape(28,28),cmap=plt.cm.binary)\n        sub2+=1\n        num_count+=1\n        if num_count==5:\n            if curr_num==9:\n                break\n            else:\n                curr_num+=1\n                num_count=0\n    if sub2==5:\n        sub2=0\n        sub1+=1\n    if sub1==10:\n        break","ba132a8a":"scalar=MinMaxScaler(feature_range=(0,1))","0fee8398":"inputs_train=scalar.fit_transform(inputs_train)","6a0cc606":"inputs_test=scalar.fit_transform(inputs_test)","f4d443ba":"inputs_train.shape","bd2fae63":"inputs_test.shape","0dac7800":"inputs_train=inputs_train.reshape(inputs_train.shape[0],28,28,1)\ninputs_test=inputs_test.reshape(inputs_test.shape[0],28,28,1)","e960d71c":"model=Sequential()","6fc0d390":"model.add(ZeroPadding2D(padding=(1,1)))\nmodel.add(Dropout(0.2))\nmodel.add(Conv2D(100,(5,5),input_shape=inputs_train.shape[1:]))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))","2c785090":"model.add(ZeroPadding2D(padding=(1,1)))\nmodel.add(Dropout(0.2))\nmodel.add(Conv2D(100,(5,5)))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))","04c2b090":"model.add(ZeroPadding2D(padding=(1,1)))\nmodel.add(Dropout(0.2))\nmodel.add(Conv2D(100,(5,5)))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))","ccf8772c":"model.add(Flatten())","4bb15cbb":"model.add(Dropout(0.2))\nmodel.add(Dense(10))\nmodel.add(Activation('softmax'))","37ab4336":"model.compile(optimizer='adam',loss='sparse_categorical_crossentropy',metrics=['accuracy'])","55409107":"model.fit(inputs_train,target_train,batch_size=100,epochs=10,validation_split=0.1)","89d49c7a":"pred=model.predict_classes(inputs_test)","75442afe":"my_submission=pd.DataFrame({'ImageId':[],'Label':[]},dtype=int)","21606d5a":"for x in range(len(pred)):\n    my_submission=my_submission.append({'ImageId':x+1,'Label':pred[x]},ignore_index=True)","5220c6a5":"my_submission.head()","45d084f0":"my_submission.to_csv('my_submission.csv',index=False)","79bb1e96":"def rgb2gray(rgb):\n    return np.dot(rgb[...,:3], [0.2989, 0.5870, 0.1140])","28b95fdf":"digitlst=['digit0.png','digit1.png','digit2.png','digit3.png','digit4.png','digit5.png','digit6.png','digit7.png','digit8.png','digit9.png']","568299a7":"predarr=np.empty(0,dtype='int8')\nfigure,subplot=plt.subplots(2,5)\nsub1=0\nsub2=0\ncount=0\n\nfor y in digitlst:\n    path='..\/input\/digittestfreehand\/'+y\n    digit=plt.imread(path)\n    digit=rgb2gray(digit)\n    subplot[sub1][sub2].imshow(digit,cmap=plt.cm.binary)\n    zeros=0\n    ones=0\n    digit=digit.reshape(784)\n    for x in range(len(digit)):\n        if digit[x]==0:\n            zeros+=1\n            digit[x]=0.999\n        elif x>0.999:\n            ones+=1\n            digit[x]=0\n    digit=digit.reshape(1,28,28,1)\n    pred=model.predict_classes(digit)\n    predarr=np.append(predarr,pred)\n    sub2+=1\n    if sub2%5==0:\n        sub1+=1\n        sub2=0","59341b2f":"for x in np.nditer(predarr):\n    print(x)","28ed55d8":"### The next step after compiling our model is training our model with the data that we have. We are gonna train our model using model.fit","f0ca30d2":" ## 6. Making Predictions & Creating The Submission File!","6a4b48bf":"![CNN2.png](attachment:CNN2.png)","77249bf1":"![Max_Pooling_Img%205.png](attachment:Max_Pooling_Img%205.png)","807939e4":"### This is a function which is used to convert RGB images to Grayscale images. This is used because the digits in my dataset were RGB images and they should be converted to grayscale images for better accuracy.","1e5f942f":"### I know that this looks confusing, so let me explain each and every parameter in detail.\n* ZeroPadding2D -- This adds an extra layer of zeros to each side of the image. For example, an image with dimensions of 8x8 will change to 10x10 after using a zero padding of size (1,1). This is done to prevent data loss.\n* Dropout -- Randomly deactivates the specified percentage of neurons during each iteration (20% in our case). This is done to prevent overfitting.\n* Conv2D -- Creates a Conv2D layer with the specified number of neurons (100 in our case), with the specified filter size (5,5 in our case) and the shape of the input (this is usually var[1:]). The filter moves pixel by pixel, detecting patterns as it moves.\n* Activation -- The activation function decides whether a neuron should be activated or not according to the sum of the weight and the bias.\n* MaxPooling2D -- Identifies the maximum pixel value in the given filter size (2,2 in our case), so that patterns in the image can be identified.","5eb88a6f":"### This table shows that our training data has 785 columns, out of which one column (the first column) contains the label and rest of the columns (784 columns) contain the pixel values of the number.","fa876472":"### Below is a huge chunk of code, which converts my RGB images to grayscale images, displays those images, makes predictions and saves them to an array called predarr.","c0a22698":"### We are gonna use a max pooling filter size of (2,2) for this image. This is how this process will happen:","184338bf":"### The red square is our filter. When this filter is placed on the image, our model does a small calculation. It multiplies the filter value with the corresponding image value. The first filter value is 1 and the first image value is 0. So our model finds the product of these 2 numbers, which is 0. Then the product of all the numbers are found and all the products are added together. When this filter is placed, this is what will happen:\n### (0x1)+(1x0)+(0x1)+(1x0)=0+0+0+0=0\n### Then, the value is placed in our output image.","9514b22a":"### It's time to prepare the predictions for submission. I'm first gonna create an empty Pandas DataFrame, after which I will update my predictions in it. Our final CSV File should have 2 Columns -- ImageId and Label.","c474812a":"### All the predictions made by our model are absolutely correct. This shows that our model performs exceptionally well.","f7963341":"### The drop function is used to remove a row or a column from a dataframe.","9931b362":"### After this, a max pooling layer is added to our model. This layer dentifies the maximum pixel value in the given filter size, so that patterns in the image can be identified. Imagine that this is the image that is passed to the max pooling layer:","fb549f8b":"![Max_Pooling_Img%203.png](attachment:Max_Pooling_Img%203.png)","ef434577":"### This is how our model looks now:","e8d00c45":"![cnn_network.png](attachment:cnn_network.png)","31aff358":"### This shows that our model does not have an output layer. So let's add an output layer.","db7b4229":"### I guess that you would have got a brief idea about how pixel values make up an image. Let's now move on to the most important stage -- data preprocessing.","acbe7bcc":"### This is how our training data looks like:","1b815196":"### This shows that our training data has 42000 rows and 785 columns. ","357ea8e2":"### When a zero padding of (1,1) is added to our input image, this is how our input image looks like:","a62e6dd8":"## 3. Visualize the data","ebf380c1":"### When this is normalized, this is how our final output will look like:","8ff2da63":"### A CNN model is a model that uses filters to detect patterns in an image. Let's imagine that this is our image:","df24cccb":"![Max_Pooling_Img%202.png](attachment:Max_Pooling_Img%202.png)","45e430e0":"![Max_Pooling_Img.png](attachment:Max_Pooling_Img.png)","85fea96d":"### Our model can identify patterns in the image using this method","135e1bdd":"## 5. Create and train a CNN model","5f11dc64":"### Since we have 10 possible outcomes (0,1,2,3,4,5,6,7,8,9), we have added a dense layer of 10 neurons. The activation function added here is softmax, because we are classifying the data here and softmax performs good at classifying.","3b22f0f2":"### Voila! We have completed this project! But wait a minute. Why don't we give numbers written by us to our model and check its accuracy? For doing this, I have created my own dataset which has handwritten digits from 0 to 9. Let's see how our model predicts the numbers written by me.","4a75bd66":"![Max_Pooling_Final.png](attachment:Max_Pooling_Final.png)","a3509478":"### The maximum value in the filter is identified. In this case, the maximum value is 0.6, so this value is placed in a separate image.","0ed439c9":"### We are now clear with the theory behind CNN Models, so let's implement this model in our code.","ed602950":"### Let's now add the final layer of our model.","3fa4bdea":"### In this stage, I am gonna normalize the data. For people who do not know what data normalization is, this is a process in which the data is scaled down to a smaller range. In our case, each and every pixel value ranges from 0 to 255, which is a very big range. Our aim is to scale them down to a value between 0 and 1. Data normalization improves our model's accuracy. Hence, it is performed. We are gonna perform data normalization on inputs_train and inputs_test.","504ba849":"### As you can see above, both the variables are 2D arrays. But, a CNN model only accepts a 4D array, where\n* The first value is the number of samples.\n* The second value is the number of pixels in the y axis.\n* The third value is the number of pixels in the x axis.\n* The fourth value is the channel of the image (1 if the image is a grayscale image, 3 if an image is an rgb image).","f7d64d41":"### I have just drawn 3 neurons in each hidden layer, but it is actually 100 in our case. This diagram shows that all the neurons are connected to each other. I think that this diagram would have made you more clear about our model.","c8edff78":"### Let's take a look at the type of variable that these variables belong to:","036d9dc7":"### This is just an example of how a filter looks like. In a Convolutional Neural Network, the filter values are randomly selected at first. The model will update the filter values after each iteration. By doing this, the model will arrive at the most suitable filter values after many iterations.","eee3f40e":"### Let's convert inputs_train and inputs_test to a 4D array:","78f81a72":"## 1. Import Required Libraries","1bbb89f2":"### This is how our final image would look like:","fe3984f9":"![Max_Pooling_Img%204.png](attachment:Max_Pooling_Img%204.png)","483062e1":"### This process is repeated again, but remember one thing: max pooling uses a stride of 2. This is where our filter will be placed next:","487c862f":"### Let's load the training and test data using Pandas.","b2918adf":"### Now, let's take a look at inputs_train and target_train:","43e8ee91":"### After a padding is added, the filters are applied to our image.","eeca2540":"### Now, we have to place the filter on the image. This is how it is done:","cd67884e":"### As I mentioned before, inputs_train contains the pixel values for different numbers. But have you ever wondered how these pixel values make up the image of a number? Now, let's view these pixel values as images using matplotlib. I am gonna display 5 images of each number.","a80eb10a":"### Let's now compile our model.","89767065":"### We have created a submission file! Submit this file to check ur model's accuracy.","b2c8c23d":"## Theory:","85d52666":"### Let's save the data in our DataFrame to a CSV File.","3a22ceae":"# **MNIST Prediction Using CNN(99.257% Accuracy) - Fully Explained**","33b58d65":"### I have used a CNN (Convolution Neural Network) Model to make predicitions on the MNIST dataset. I would be explaining each and every step in detail. Let's jump into the code without further ado!","f0699df4":"### We have reached the end of this notebook. This is my first Kaggle Notebook and I hope that this helps you. After all, I am just a middle-schooler, so show your support by hitting the upvote button. Please leave your suggestions and queries below. Thank you for patiently reading my notebook until the end! ","1abf0ed8":"### Let's add the first layer of our model:","c7348042":"### This is a 3x3 image, where the 0s represent white and the 1s represent black. We will be using something called ****FILTERS**** to detect patterns in this image. The size of the filter should be mentioned in the code. This is how a 2x2 filter looks like:","26100482":"### All our predictions are stored in an array called predarr. Let's iterate over this array to display the predictions.","292739fc":"### More the number of layers, higher the accuracy. So let's add few more layers to our CNN model.","e20e5698":"## 4. Data Preprocessing","18a4d556":"### Making predictions with our model is not a big deal. Predictions can be made just with a single line of code, where you have to pass the test data to a function called predict_classes.","d9e4f8b8":"![CNN_Filter.png](attachment:CNN_Filter.png)","8f65c4c3":"### Let's import the libraries that we will be using.","2116164a":"### Predicted values are updated here. Don't forget to include ignore_index = True when updating the DataFrame.","75c190c9":"![CNN1.png](attachment:CNN1.png)","b2f23fcf":"### This is how our DataFrame looks like:","c5fc2c83":"### That's it! We have made predictions with our model and these predictions are stored in a variable called pred.","8c91e884":"![Padding.png](attachment:Padding.png)","4a13ce03":"## 2. Load the data","1e0a0679":"### This is what a stride length of 2 means. Let me show you the next two moves of the filter:","bed55404":"### We have completed preprocessing our data! Now, let's go on to create our model.","d8d09550":"![Filter_output.png](attachment:Filter_output.png)","5942c315":"![CNN_With_Filter.png](attachment:CNN_With_Filter.png)","7ef759ca":"### Now, let's split our training data into two parts: inputs_train and target_train, where inputs_train contains all the 784 pixel values of the number and target_train contains the number that the pixel values denote.","5eb518a0":"### I hope that you would have got a basic idea about CNN models. If you are still not clear with it, I would suggest you to watch few YouTube videos that explain the theory behind CNN models.","cbf8332c":"### Then, our filter moves 1 step to the right and does the same process. After this process has been done for all the values, this is how our output will look like:","7799f409":"### Let's create an empty Pandas DataFrame with the Columns ImageId and Label.","7d698f1c":"### All our hidden layers were Conv2D layers, but our output layer can't be one, because Conv2D layers are used for processing the data. Our output layer is gonna be a Dense layer. This layer only accepts a 1D array as an input, so we have to convert our input to the dense layer to a 1D array. Let's do this by adding a Flatten layer to our model.","80eb0c88":"### We are done with data normalization! Now, let's take a look at the shape of inputs_train and inputs_test.","22c9a079":"### As you can see above, inputs_train is a pandas DataFrame and target_train is a pandas Series. But these variable types are not ideal for data preprocessing. Numpy arrays are ideal for data preprocessing, so let's convert these variables to numpy arrays.","6fb48061":"### You can see that our input image size was 3x3, but our output image size is just 2x2. This shows that there is some data loss. To prevent this, a zero padding is added. A zero padding adds an extra layer of zeros to each side of the image. For example, an image with dimensions of 8x8 will change to 10x10 after using a zero padding of size (1,1).","6178ff8a":"## Implementation:","484783c6":"## Content:\n*  Import required libraries\n*  Load the data\n*  Visualize the data\n*  Preprocess the data\n*  Create and train a CNN model\n*  Make predictions using the model\n*  Additional Testing","4ecd7e1c":"### We have finished adding layers to our model. But remember one thing -- these layers are just hidden layers, which means that these layers are responsible for processing the data. I will give you a real-life example, so that you will be able to understand what I mean. A computer can be split into 3 major sections: input, CPU and output. Let's now relate these 3 major sections to our model:\n\n### The input of our model -- The test data (because the test data will only be given as the input data to predict the results for to our model)\n### The CPU of our model -- The layers that we have added above (because they process the data).\n### The output of our model -- ???","212cab1b":"## 7. Additional Testing"}}