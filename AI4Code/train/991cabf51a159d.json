{"cell_type":{"2f7fec00":"code","d6981082":"code","af6c6a69":"code","3638297e":"code","39a0e228":"code","a905daf0":"code","9b8f34b7":"code","8036d881":"code","2f3bcae0":"code","18f3ee35":"markdown","68ea3743":"markdown"},"source":{"2f7fec00":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d6981082":"import igraph","af6c6a69":"!pip install scikit-hubness\n","3638297e":"from skhubness.data import load_dexter\nX , y = load_dexter ()","39a0e228":"X.shape, (X==0).sum() , (X==0).sum() \/ (X.shape[0]*X.shape[1])  ","a905daf0":"#from sklearn.neighbors import NearestNeighbors\n#nbrs = NearestNeighbors(n_neighbors=5).fit(X) #  algorithm='ball_tree' #  {\u2018mutual_proximity\u2019, \u2018local_scaling\u2019, \u2018dis_sim_local\u2019, None}, \nfrom skhubness.neighbors import NearestNeighbors\nnbrs = NearestNeighbors(n_neighbors=5,hubness = 'mutual_proximity' ).fit(X) #  algorithm='ball_tree' #  {\u2018mutual_proximity\u2019, \u2018local_scaling\u2019, \u2018dis_sim_local\u2019, None}, \ndistances, indices = nbrs.kneighbors(X)\nindices\ni = 1\nedges = np.zeros( (0,2), dtype= int ) \nfor i in range(1,5):\n    ed = indices[:,[0,i]]\n    edges = np.concatenate( (edges,ed), axis = 0 )\n\ng = igraph.Graph( directed = True )\ng.add_vertices(range(len(X)))\ng.add_edges(edges )\n    \nl2 = (np.sign(y+1)).astype(int)\nl3 = [int(t) for t in l2 ]\ng.to_undirected(mode = 'collapse')\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity( l3 )#, weights=graph.es['weight'])\nprint(\"The modularity for partition is {}\".format(modularity1))\n\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity( louvain_partition.membership)#, weights=graph.es['weight'])\n\nprint(\"The modularity for Louvain partition is {}\".format(modularity1))\n\n# For standard KNN \n# The modularity for partition is 0.26619381976429707\n# The modularity for Louvain partition is 0.5151309642839581\n\n# For 'mutual_proximity'\n#The modularity for partition is 0.30429951595876115\n#The modularity for Louvain partition is 0.5947172401787921","9b8f34b7":"#igraph.plot(g)\n#by igraph \nd = {-1.:'red',1.:'green'}\nl = [d[y[i]] for i in range(len(y))]\nl\nvisual_style = {}\nvisual_style[\"vertex_color\"] =l# [dict_colors[k]  for k in range(g.vcount() )]\n#visual_style[\"vertex_label\"] = range(g.vcount()) \nigraph.plot(g, **visual_style, bbox = (800,800) ) # layout = layout,","8036d881":"from sklearn.neighbors import NearestNeighbors as NearestNeighbors_sklearn \nnbrs = NearestNeighbors_sklearn(n_neighbors=5).fit(X) #  algorithm='ball_tree' #  {\u2018mutual_proximity\u2019, \u2018local_scaling\u2019, \u2018dis_sim_local\u2019, None}, \n#from skhubness.neighbors import NearestNeighbors\n#nbrs = NearestNeighbors(n_neighbors=5,hubness = 'mutual_proximity' ).fit(X) #  algorithm='ball_tree' #  {\u2018mutual_proximity\u2019, \u2018local_scaling\u2019, \u2018dis_sim_local\u2019, None}, \ndistances, indices = nbrs.kneighbors(X)\nindices\ni = 1\nedges = np.zeros( (0,2), dtype= int ) \nfor i in range(1,5):\n    ed = indices[:,[0,i]]\n    edges = np.concatenate( (edges,ed), axis = 0 )\n\ng = igraph.Graph( directed = True )\ng.add_vertices(range(len(X)))\ng.add_edges(edges )\n    \nl2 = (np.sign(y+1)).astype(int)\nl3 = [int(t) for t in l2 ]\ng.to_undirected(mode = 'collapse')\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity( l3 )#, weights=graph.es['weight'])\nprint(\"The modularity for partition is {}\".format(modularity1))\n\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity( louvain_partition.membership)#, weights=graph.es['weight'])\n\nprint(\"The modularity for Louvain partition is {}\".format(modularity1))\n\n# For standard KNN \n# The modularity for partition is 0.26619381976429707\n# The modularity for Louvain partition is 0.5151309642839581\n\n# For 'mutual_proximity'\n#The modularity for partition is 0.30429951595876115\n#The modularity for Louvain partition is 0.5947172401787921","2f3bcae0":"#igraph.plot(g)\n#by igraph \nd = {-1.:'red',1.:'green'}\nl = [d[y[i]] for i in range(len(y))]\nl\nvisual_style = {}\nvisual_style[\"vertex_color\"] =l# [dict_colors[k]  for k in range(g.vcount() )]\n#visual_style[\"vertex_label\"] = range(g.vcount()) \nigraph.plot(g, **visual_style, bbox = (800,800) ) # layout = layout,","18f3ee35":"# Plot from 'mutual_proximity' KNN ","68ea3743":"# Plot from standard KNN "}}