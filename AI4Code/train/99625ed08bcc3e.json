{"cell_type":{"70fb651d":"code","a93f3d20":"code","da16cae8":"code","764803c3":"code","1fcdff84":"code","4bdf90c6":"code","0bbf9b7e":"code","aa00e625":"code","600a28e3":"code","2a771356":"code","da36c6dd":"code","78eca2e6":"code","b0ca595a":"code","d6f38c06":"code","e3ee9f0f":"code","c4afb65c":"code","13743fc5":"code","883af3e8":"code","0230f0c5":"code","d6f5c906":"code","f19dfff1":"code","524c96ea":"code","fa881cb4":"code","cba459a1":"code","71c3f33d":"markdown","5e825481":"markdown","7cb99057":"markdown","8ec7cd2b":"markdown","7af10f08":"markdown","2ef15048":"markdown","30cbcc58":"markdown","3f271340":"markdown","71161994":"markdown","e34098a0":"markdown","e40ef44a":"markdown","23382ec2":"markdown","d5eb9011":"markdown","e72152df":"markdown","5a6f4f73":"markdown","1eaa257b":"markdown","61bd7754":"markdown","ee8effa3":"markdown","de63a585":"markdown","1744469c":"markdown","a41727a7":"markdown","b1156470":"markdown","eb8c89cc":"markdown","f5ad95ce":"markdown","97295436":"markdown","9700e685":"markdown","944e4a7b":"markdown","58f4a72b":"markdown","99384830":"markdown","182f97b0":"markdown","84788518":"markdown","05f5485e":"markdown"},"source":{"70fb651d":"import numpy as np # linear algebra","a93f3d20":"# Initializing from Python List\nv = np.array([1,4,9,3,2])\nprint ('1D array in numpy is %s\\n'%v)\nprint ('dtype of the numpy array is %s\\n'%str(v.dtype))\nprint ('shape of the numpy array is %s\\n'%v.shape)","da16cae8":"v1 = np.arange(5)\nprint ('Creating a numpy array via arange (stop=5) : %s\\n'%v1)\nv2 = np.arange(2,5)\nprint ('Creating a numpy array via arange (start=2,stop=5) : %s\\n'%v2)\nv3 = np.arange(0,-10,-2)\nprint ('Creating a numpy array via arange (start=0,stop=-10,step=-2) : %s\\n'%v3)","764803c3":"pymat = [[1,2,3],[4,5,6]]\nnpmat = np.array(pymat)\nprint ('numpy matrix is \\n%s\\n'%npmat)\nprint ('Flattened version of numpy matrix is %s\\n'%npmat.flatten())\n# By flatten the matrix becomes row major 1D vector (This is the way in which a matrix is stored in memory).","1fcdff84":"mat_zeros = np.zeros(shape=(3,5))\nprint ('Zeros Matris of shape %s is \\n%s\\n'%(mat_zeros.shape,mat_zeros))\nmat_ones = np.ones(shape=(2,3))\nprint ('Ones Matris of shape %s is \\n%s\\n'%(mat_ones.shape,mat_ones))","4bdf90c6":"#Using numpy.random.random\nmat1 = np.random.randint(10, size=6)\nprint ('matrix generated from numpy.random.random is \\n%s\\n'%mat1)\nmat2 = np.random.randint(10, size=(3, 4))\nprint ('matrix generated from numpy.random.random is \\n%s\\n'%mat2)\nmat3 = np.random.randint(10, size=(3, 4, 5))\nprint ('matrix generated from numpy.random.randn is \\n%s\\n'%mat3)","0bbf9b7e":"print(\"mat3 ndim: \", mat3.ndim)\nprint(\"mat3 shape:\", mat3.shape)\nprint(\"mat3 size: \", mat3.size)","aa00e625":"print(\"itemsize:\", mat3.itemsize, \"bytes\")\nprint(\"nbytes:\", mat3.nbytes, \"bytes\")","600a28e3":"print(\"dtype:\", mat3.dtype)","2a771356":"vec = np.arange(10)\nvec1 = vec[:-3]\nprint ('Result of removing last 3 elements from range(10) : \\n%s\\n'%vec1)","da36c6dd":"vec1 = np.arange(0,20,3)\nprint ('Original array is %s\\n'%vec1)\nvec2 = vec1[::2]\nprint ('Elements at even indices are %s\\n'%vec2)","78eca2e6":"mat3","b0ca595a":"mat3[:2, :3]  # two rows, three columns","d6f38c06":"mat3[:3, ::2]  # all rows, every other column","e3ee9f0f":"mat3[::-1, ::-1]","c4afb65c":"print(mat3[:, 0])  # first column of x2","13743fc5":"mat3.sum()","883af3e8":"mat3.min(axis=0)","0230f0c5":"mat3.max(axis=1)","d6f5c906":"arr1 = np.array([[2, -7, 5], [-6, 2, 0]]) \narr2 = np.array([[5, 8, -5], [3, 6, 9]]) \n   \nprint (\"1st Input array : \", arr1)  \nprint (\"2nd Input array : \", arr2)  \n    \nresult = np.add(arr1, arr2)  \nprint (\"output added array : \", result)  ","f19dfff1":"result = np.subtract(arr1, arr2)  \nprint(result)","524c96ea":"result = np.multiply(arr1, arr2) \nprint(result)","fa881cb4":"result = np.divide(arr1, arr2) \nprint(result)","cba459a1":"# Makeup a numpy array within [-2, 2] and 5 elements\nprint(np.linspace(-2, 2, num=5))\n#The value of pi\n# Makeup a numpy array within [0, 2\u03c0] and 10 elementsx = np.linspace(0, 2*np.pi, num=10)\nprint(np.linspace(0, 2*np.pi, num=10))","71c3f33d":"### Accessing array rows and columns\nOne commonly needed routine is accessing of single rows or columns of an array. This can be done by combining indexing and slicing, using an empty slice marked by a single colon (:):","5e825481":"When we talk about 2D array, it is important to note that Numpy stores Matrix is Row Major Format. Row major format means that the the complete row will be stored first and then the next row will be stored and so on. You can choose to store a matrix in colum major format by mentioning order='F' on ndarray creation, which means Column Major Format or Fortran Style Format.","7cb99057":"Another useful attribute is the dtype, the data type of the array (which we discussed previously in Understanding Data Types in Python):","8ec7cd2b":"# Addition in Numpy Arrays\nIn numpy arrays the addition can be done only if arr1.shape == arr2.shape . If shape of two arrays are not same, that is arr1.shape != arr2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).","7af10f08":"# Multi-dimensional subarrays\nMulti-dimensional slices work in the same way, with multiple slices separated by commas. For example:","2ef15048":"Numpy is a Library in python that specializes in dealing with multidimensional Arrays. The cool features of Numpy are\n\n- Automatic Checking : Numpy ndArrays automatically check the consistancy of data. For instance, it is not possible to have 1st row with 2 elements and 2nd row with 3 elements\n- Contiguous Storage : Unlike Python Lists, Numpy stores the data in contiguous Memory Locations, leading to lesser Space\n- Faster Vector Arithmatics : Because of contiguous storage, the operations are performed faster as compared to default Python Execution for Lists","30cbcc58":"# Introduction to Numpy","3f271340":"# Aggregations: Min, Max, and Everything In Between\nOften when faced with a large amount of data, a first step is to compute summary statistics for the data in question. Perhaps the most common summary statistics are the mean and standard deviation, which allow you to summarize the \"typical\" values in a dataset, but other aggregates are useful as well (the sum, product, median, minimum and maximum, quantiles, etc.).\n\nNumPy has fast built-in aggregation functions for working on arrays; we'll discuss and demonstrate some of them here.","71161994":"# Initialization of 2D array in Python","e34098a0":"# Initialization of 1D array in Python\nA numpy array comes with 2 important state variables. Just like Python, it automatically detects dtype (if not mentioned)\n\n- dtype\n- shape","e40ef44a":"### Subtraction","23382ec2":"### Division","d5eb9011":"# Initialization via arange\nnumpy.arange([start, ]stop, [step, ] dtype=None)","e72152df":"# Remove n elements\n- vec[:-n]","5a6f4f73":"Other attributes include itemsize, which lists the size (in bytes) of each array element, and nbytes, which lists the total size (in bytes) of the array:","1eaa257b":"- numpy.zeros(shape, dtype=float)\n- numpy.ones(shape, dtype=float)","61bd7754":"Aggregation functions take an additional argument specifying the axis along which the aggregate is computed. For example, we can find the minimum value within each column by specifying axis=0:","ee8effa3":"Just like python, numpy also has 0 indexing. Let us see some of the commonly used slicing techniques .\n\n- Generic Slicing Operation : [start]:[end]:[jump]\n- Only jump ::2\n- Only end :5\n- Start and jump 2::-1\n- End and Jump :5:2\n- Start, end and jump 2:7:3","de63a585":"# Access elements at even indices in a 1D array\n- vec[::2]","1744469c":"# Initialization with zero\/ones","a41727a7":"The syntax is quite similar to that of NumPy's sum function, and the result is the same in the simplest case:","b1156470":"Similarly, we can find the maximum value within each row:","eb8c89cc":"# Slicing and Indexing in Numpy","f5ad95ce":"A lot to come ..","97295436":"# Initialization with Random Values","9700e685":"### multiplication","944e4a7b":"# NumPy Array Attributes\nFirst let's discuss some useful array attributes. We'll start by defining three random arrays, a one-dimensional, two-dimensional, and three-dimensional array. We'll use NumPy's random number generator, which we will seed with a set value in order to ensure that the same random arrays are generated each time this code is run:","58f4a72b":"Finally, subarray dimensions can even be reversed together:","99384830":"### Linspace: \nA useful function for plotting mathematical functions is \u201clinespace\u201d. Linespace returns evenly spaced numbers over a specified interval. We specify the starting point of the sequence and the ending point of the sequence, num no.of elements are returned.","182f97b0":"# Multi dimensional aggregates\nOne common type of aggregation operation is an aggregate along a row or column. Say you have some data stored in a two-dimensional array:","84788518":"- numpy.random.random(size=None,)\n- numpy.random.randint(low, high, size=None, dtype='I') : The value of matrix lies between low and high-1\n- numpy.random.randn($d_0,d_1,\\cdots,d_n$)","05f5485e":"### Please UpVote The Kernel , It's Free..."}}