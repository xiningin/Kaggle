{"cell_type":{"c0d00a39":"code","ac58f432":"code","324045a4":"code","914a6e85":"code","32c88d10":"code","80ff85d4":"code","4ecef47b":"code","0ee987a9":"code","d01385a9":"code","132ea82f":"code","b5732780":"code","b3e00bf0":"code","241658f9":"code","a71eda88":"code","1d831677":"code","477f93db":"markdown","4984c025":"markdown"},"source":{"c0d00a39":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline","ac58f432":"yelp = pd.read_csv('..\/input\/yelp.csv')","324045a4":"yelp['text_length'] = yelp['text'].apply(len)","914a6e85":"yelp.head(2)","32c88d10":"sns.set_style('white')\ns = sns.FacetGrid(yelp,col='stars')\ns.map(plt.hist,'text_length',bins=50)","80ff85d4":"Distribution is same in case of all star ratings","4ecef47b":"sns.boxplot(x='stars',y='text_length',data= yelp,palette='rainbow')","0ee987a9":"sns.countplot(x='stars',data= yelp,palette='rainbow')","d01385a9":"stars = yelp.groupby('stars').mean()\nstars","132ea82f":"sns.heatmap(stars.corr(),annot=True)","b5732780":"yelp_class = yelp[(yelp['stars']==1) | (yelp['stars']==5)]\nyelp_class.info()","b3e00bf0":"X = yelp_class['text']\ny = yelp_class['stars']","241658f9":"from sklearn.feature_extraction.text import CountVectorizer\ncv = CountVectorizer()\nX = cv.fit_transform(X)\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=101)\n\nfrom sklearn.naive_bayes import MultinomialNB\nnb = MultinomialNB()\nnb.fit(X_train,y_train)","a71eda88":"predictions = nb.predict(X_test)\nfrom sklearn.metrics import classification_report\nprint(classification_report(y_test,predictions))","1d831677":"from sklearn.feature_extraction.text import TfidfTransformer\nfrom sklearn.pipeline import Pipeline\n\npipeline = Pipeline([\n    ('bow',CountVectorizer()),\n    ('tfidf',TfidfTransformer()),\n    ('classifier',MultinomialNB())\n])\n\nX = yelp_class['text']\ny = yelp_class['stars']\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=101)\n\npipeline.fit(X_train,y_train)\n\npredictionsTF = pipeline.predict(X_test)\n\nprint(classification_report(y_test,predictionsTF))","477f93db":">** TF-IDF made things worse !!**\n>","4984c025":"Lets see what happens if we include TF-IDF to this process using a pipeline.\n"}}