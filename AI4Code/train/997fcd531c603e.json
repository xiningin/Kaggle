{"cell_type":{"c91e6d50":"code","51696634":"code","e31e87e7":"code","f3900241":"markdown","118e52b1":"markdown"},"source":{"c91e6d50":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","51696634":"%%writefile submission.py\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import Observation, Configuration,Action, row_col\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import adjacent_positions,min_distance\nfrom pprint import pprint\nralph_last_action = [\n    'SOUTH',\n    'SOUTH',\n    'SOUTH',\n    'SOUTH'\n]\nclass Goose:\n    def __init__(self,goose,config):\n        self._goose = goose\n        self._configuration = config\n        if(len(self._goose)>0):\n            self._r, self._c = row_col(self._goose[0], self._configuration.columns)\n        else:\n            self._r = -1\n            self._c = -1\n        self._possible_moves = [\n            'SOUTH',\n            'NORTH',\n            'WEST',\n            'EAST'\n        ]\n    def get_body_len(self):\n        return len(self._goose)\n    def get_head(self):\n        if(len(self._goose)>0):\n            return self._goose[0]\n        else:\n            return -1\n    def get_head_pos(self):\n        if(len(self._goose)>0):\n            return row_col(self._goose[0], self._configuration.columns)\n        else:\n            return -1,-1\n    def get_neck_pos(self):\n        if(len(self._goose)>1):\n            return row_col(self._goose[1], self._configuration.columns)\n        else:\n            return -1,-1\n    def am_i_there(self,row,col):\n        achou = False\n        for i in range(0,len(self._goose)):\n            m_row,m_col = row_col(self._goose[i], self._configuration.columns)\n            if m_row == row and m_col == col:\n                achou = True\n        return achou\n    def get_next_position(self,move):\n        if(self._r == -1 or self._c == -1):\n            return -1,-1\n        move_r,move_c = to_row_col(move)\n        n_r = self._r + move_r\n        n_c = self._c +move_c\n        if(n_r > self._configuration.rows-1):\n            n_r = n_r % self._configuration.rows\n        if(n_r < 0):\n            n_r = self._configuration.rows - abs(n_r) % self._configuration.rows\n\n        if(n_c > self._configuration.columns-1):\n            n_c = n_c % self._configuration.columns\n        if(n_c < 0):\n            n_c = self._configuration.columns - abs(n_c) % self._configuration.columns\n        return n_r,n_c\n\ndef to_row_col(action):\n    if action == Action.NORTH.name:\n        return -1,0\n    if action == Action.SOUTH.name:\n        return 1,0\n    if action == Action.EAST.name:\n        return 0,1\n    if action == Action.WEST.name:\n        return 0,-1\ndef opposite(action):\n    if action == Action.NORTH.name:\n        return Action.SOUTH.name\n    if action == Action.SOUTH.name:\n        return Action.NORTH.name\n    if action == Action.EAST.name:\n        return Action.WEST.name\n    if action == Action.WEST.name:\n        return Action.EAST.name\n    \ndef will_be_any_enemy_there(enemies_geese,row,col):\n    achou = False\n    for enemy in enemies_geese:\n        for move in enemy._possible_moves:\n            n_r,n_c = enemy.get_next_position(move)\n            if(n_r == row and col == n_c):\n                achou = True\n    return achou\n\ndef is_any_enemy_there(enemies_geese,row,col):\n    achou = False\n    for enemy in enemies_geese:\n        if enemy.am_i_there(row,col):\n            achou = True\n    return achou\n\ndef get_distance(x,y,x1,y1):\n    return abs(x - x1) + abs(y - y1)\n\ndef get_min_distance_food_pos(position, foodList,columns):\n    row, column = row_col(position, columns)\n     \n    distances = []\n    for food_position in foodList:\n        food_row, food_column = row_col(food_position, columns)\n        distances.append(get_distance(row,column,food_row,food_column))\n    min_d = None\n    for i in range(0,len(distances)):\n        if min_d == None:\n            min_d = i\n            continue\n        if(distances[min_d]>distances[i]):\n            min_d = i\n        \n    return row_col(foodList[i], columns)\n    \n\ndef agent(obs_dict, config_dict):\n    global ralph_last_action\n    observation = Observation(obs_dict)\n    configuration = Configuration(config_dict)\n    \n    print(\"Player\")\n    # Define my player\n    player_index = observation.index\n    my_goose = Goose(observation.geese[player_index],configuration)\n    player_row, player_column = my_goose.get_head_pos()\n    \n    print(\"Enemies\")\n    # Define the enemies players\n    enemies_indexes = []\n    for i in range (0,len(observation.geese)):\n        if i != player_index:\n            enemies_indexes.append(i)\n    \n    enemies_geese = []\n    for enemy in enemies_indexes:\n        enemies_geese.append(Goose(observation.geese[enemy],configuration))\n    \n    \n    print(\"Food\")\n    # Get the nearest food position\n    food_row, food_column = get_min_distance_food_pos(my_goose.get_head(),observation.food,configuration.columns)\n    \n    \n    print(\"Possible Moves\")\n    # List the possible moves\n    possible_moves = [\n        'SOUTH',\n        'NORTH',\n        'WEST',\n        'EAST'\n    ]\n    if(ralph_last_action[player_index] in possible_moves):\n        possible_moves.remove(ralph_last_action[player_index])\n    \n    \n    print(\"Possible Moves and colisions\")\n    moves = []\n    for i in range(0,len(possible_moves)):\n        move = possible_moves[i]\n        n_r,n_c = my_goose.get_next_position(move)\n        if( not is_any_enemy_there(enemies_geese,n_r,n_c) and not my_goose.am_i_there(n_r,n_c) and not will_be_any_enemy_there(enemies_geese,n_r,n_c) ):\n            moves.append(move)\n            \n    \n    print(\"Possible Moves by food\")\n    # From the remaining possible moves, wich one get me nearest to the food?\n    min_food_move = 0\n    if(len(moves)>0):\n        for i in range(0,len(moves)):\n            n_r1,n_c1 = my_goose.get_next_position(moves[i])\n            n_r2,n_c2 = my_goose.get_next_position(moves[min_food_move])\n            if(get_distance(food_row,food_column,n_r1,n_c1) < get_distance(food_row,food_column,n_r2,n_c2)):\n                min_food_move = i\n\n    \n    \n    print(\"Select Move\")\n    if(len(moves)>0 and min_food_move is not None):\n        return_action = moves[min_food_move]\n    else:\n        return_action = 'NORTH'\n   \n    print(\"Last Move\")\n    # Refresh the last move\n    ralph_last_action[player_index] = opposite(return_action)\n    print(return_action)\n    print()\n    return return_action","e31e87e7":"import kaggle_environments\nfrom kaggle_environments import make, evaluate, utils\n\nenv = make(\"hungry_geese\", debug=False) #set debug to True to see agent internals each step\n\nenv.reset()\nenv.run([\".\/submission.py\",\".\/submission.py\", \".\/submission.py\",\".\/submission.py\"])\nenv.render(mode=\"ipython\",width=700, height=600)","f3900241":"# C\u00f3digo para subimiss\u00e3o","118e52b1":"# Teste com o ambiente da Competi\u00e7\u00e3o"}}