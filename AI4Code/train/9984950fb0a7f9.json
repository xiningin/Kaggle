{"cell_type":{"e510deca":"code","1e433ee3":"code","74240270":"code","57b81dfd":"code","e3828352":"code","c50d42ed":"code","27e3b5ea":"code","3f530da9":"code","24b8eed8":"code","e3b450cb":"code","1b609744":"code","b79453d9":"code","04c6a989":"code","fdea0bce":"code","7b2b3674":"code","0a0543ee":"code","169125b4":"code","3c97fb84":"code","f0439ae9":"markdown"},"source":{"e510deca":"import numpy as np # linear algebra\nimport numpy.linalg as linalg\nfrom numpy.random import randn","1e433ee3":"dt1 = 0.1 \/ 3 # was 0.05\nt1_i = 0\nt1_f = 3\nt1_range = np.arange(t1_i, t1_f, dt1)\nt2 = 1.0\ngam = 4\/3\nN = 40","74240270":"def create_matrix(t1, t2, gam, N, disorder=0):\n    assert type(N) is int\n    np.random.seed(0)\n    \n    gams = [gam] * N\n    gams = np.insert(gams, np.arange(N - 1) + 1, 0)\n    gams = np.diag(gams, k=1)\n    \n    t1s = t1 * np.ones(N)\n    t1s = tuple(t1s * (1 + disorder * randn(N)) for i in range(2))\n    t1s = tuple(np.insert(that, np.arange(N - 1) + 1, 0) for that in t1s)\n    t1s = np.diag(t1s[0], k=1) + np.diag(t1s[1], k=-1)\n    \n    t2s = t2 * np.ones(N - 1)\n    t2s = tuple(t2s * (1 + disorder * randn(N-1)) for i in range(2))\n    t2s = tuple(np.insert(that, np.arange(N), 0) for that in t2s)\n    t2s = np.diag(t2s[0], k=1) + np.diag(t2s[1], k=-1)\n    \n    return t1s + t2s + (gams - gams.T) \/ 2","57b81dfd":"create_matrix(1, -1, 0, 2, 0)","e3828352":"eigvals = []\neigvecs = []\nrandom_part = randn(2*N, 2*N)\/20\nfor t1 in t1_range:\n    matrix = create_matrix(t1, t2, gam, N, 0.01)\n    if np.isclose(t1, -2.50):\n        print(matrix)\n    w, v = linalg.eig(matrix)\n    eigvals.append(w)\n    eigvecs.append(v)","c50d42ed":"import matplotlib.pyplot as plt","27e3b5ea":"fig = plt.figure(figsize=(10, 10))\nfor t1, spectrum in zip(t1_range, eigvals):\n    plt.plot([t1]* (2 * N), np.real(spectrum), \"k,\")\nfig.show()","3f530da9":"fig = plt.figure(figsize=(10, 10))\nfor t1, spectrum in zip(t1_range, eigvals):\n    plt.plot([t1]* 2 * N, np.imag(spectrum), \"k,\")\nfig.show()","24b8eed8":"fig = plt.figure(figsize=(10, 10))\nfor t1, spectrum in zip(t1_range, eigvals):\n    plt.plot([t1]* 2 * N, np.abs(spectrum), \"k,\")\nfig.show()","e3b450cb":"np.array(eigvals).shape\n# 120 (t1) by 80 (eigenvalues) by 2 (re\/im parts)","1b609744":"import pandas as pd\ndf = []\nfor t1, spectrum in zip(t1_range, eigvals):\n    for energy in spectrum:\n        df.append([t1, np.real(energy), np.imag(energy)])\n        \ndf = pd.DataFrame(df, columns=[\"t1\", \"real\", \"imag\"])\ndf","b79453d9":"import plotly.express as px\nfig = px.scatter_3d(df, \n                    x='real', \n                    z='imag',\n                    y=\"t1\",\n                   size_max=2)\nfig.show()","04c6a989":"# Get the 4 smallest amplitude eigenvalues and plot them\n\nfig = plt.figure(figsize=(10, 10))\n\ndf_small = []\nfor t1, spectrum in zip(t1_range, eigvals):\n    spectrum = spectrum[np.argsort(np.abs(spectrum))][:4] # select 4 smallest |E|'s\n    for energy in spectrum:\n        df_small.append([t1, np.abs(energy)])\n        \n        plt.plot(t1, np.abs(energy), \"k,\")\n        \ndf_small = pd.DataFrame(df_small, columns=[\"t1\", \"abs\"])\n\nfig.show()","fdea0bce":"# NOTE: something very strange happens to eigenvectors for t1 < 0\n\n# Get the 2 smallest amplitude eigenvalues and plot their first unit cell amplitudes\n\nfig = plt.figure(figsize=(10, 10))\n\nfor t1, spectrum, eigvec in zip(t1_range, eigvals, eigvecs):\n    argsort_by_absE = np.argsort(np.abs(spectrum))\n    for order, i in enumerate(argsort_by_absE[:2]):\n        A, B = np.abs(eigvec.T[i,:2])\n        if order is 0:\n            markers = (\"b.\", \"r.\")\n        else:\n            markers = (\"c+\", \"m+\")\n        plt.plot(t1, A, markers[0])\n        plt.plot(t1, B, markers[1])\n        \nfig.show()","7b2b3674":"# Get the 2 smallest amplitude eigenvalues and plot their first unit cell amplitudes\n\nfig = plt.figure(figsize=(10, 10))\n\nfor t1, spectrum, eigvec in zip(t1_range, eigvals, eigvecs):\n    if t1 <= 0:\n        continue\n    argmin_absE = np.argsort(np.abs(spectrum))[1] # using second eigen\n    \n    vec = np.abs(eigvec.T[argmin_absE,:10])\n    \n    color = (1-t1\/1.2, 1-t1\/1.2, 1) if t1 < 1.2 else (1, (t1-1.2)\/(3-1.2), 0) # cyan if topological else purple\n    plt.plot(np.arange(len(vec)), vec, marker='.', color=color) # 0 is black\n\n\nax = plt.gca()\nax.set_facecolor('black')\nfig.show()","0a0543ee":"# Actually get a list of the same eigenvector as t1 changes\n\nfirst_zero_mode_profiles = []\nsecond_zero_mode_profiles = []\n\nfor mode_i, zero_mode_profiles in enumerate([first_zero_mode_profiles, second_zero_mode_profiles]):\n    for t1, spectrum, eigvec in zip(t1_range, eigvals, eigvecs):\n        if t1 <= 0: # this is a bad way of only looking at positive t1's for the time being\n            continue\n        argmin_absE = np.argsort(np.abs(spectrum))[mode_i]\n\n        vec = eigvec.T[argmin_absE,:]\n        vec \/= (vec[0] \/ np.abs(vec[0])) # set phase: first entry is always along the positive real axis.\n        zero_mode_profiles.append(vec)","169125b4":"import numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nplt.style.use('seaborn-pastel')\n\nzero_mode_profile = first_zero_mode_profiles\nzero_mode_profile = second_zero_mode_profiles\n\n\nfig = plt.figure()\nax = plt.axes(xlim=(-0.2, 80.2), ylim=(-1.2, 1.2))\nline, = ax.plot([], [], lw=3)\nline2, = ax.plot([], [], lw=3)\n\ndef init():\n    line.set_data([], [])\n    line2.set_data([], [])\n    return line, line2\ndef animate(i):\n    vec = zero_mode_profiles[i]\n    x = np.arange(len(vec))\n    y = vec\n    line.set_data(x, np.real(y))\n    line2.set_data(x, np.imag(y))\n    return line, line2\n\nanim = FuncAnimation(fig, animate, init_func=init,\n                               frames=59, interval=20, blit=True)\n\nfrom IPython.display import HTML\nHTML(anim.to_jshtml())","3c97fb84":"import numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nplt.style.use('seaborn-pastel')\n\nrange_ = (0, 19)\n\nfig = plt.figure()\nax = plt.axes(xlim=range_, ylim=(-1, 1))\nline, = ax.plot([], [], lw=3)\nline2, = ax.plot([], [], lw=3)\n\ndef init():\n    line.set_data([], [])\n    line2.set_data([], [])\n    return line, line2\ndef animate(i):\n    vec1 = first_zero_mode_profiles[i]\n    vec2 = second_zero_mode_profiles[i]\n    x = np.arange(len(vec))\n    line.set_data(x, np.real(vec1))\n    line2.set_data(x, np.real(vec2))\n    return line, line2\n\nanim = FuncAnimation(fig, animate, init_func=init,\n                     frames=len(first_zero_mode_profiles), \n                     interval=100, \n                     blit=True)\n\nfrom IPython.display import HTML\nHTML(anim.to_jshtml())","f0439ae9":"The profile of the topological state has zeros in the same place.\n\nInterestingly, the state profile seems to be *completely localized* somewhere around t1 = 2\/3, or half gamma."}}