{"cell_type":{"0e40d7bb":"code","d9b15fa4":"code","e56c0111":"code","187f6a5e":"code","b7d2d639":"code","5853686d":"code","67abe454":"code","c0a95b6b":"code","98b12957":"code","c700f73d":"code","5da0809b":"code","0a755415":"code","e09f37b2":"code","5a4b1670":"code","e6ca60fa":"code","6a1b13bf":"code","4a951caf":"code","0bc25121":"code","4a549bb9":"code","21e463ef":"code","cce10b38":"code","0cf55c37":"code","e6e2f24f":"code","5b9f1ee9":"markdown","2c29ff0a":"markdown","7132e876":"markdown","99b4d8a3":"markdown","532b05d6":"markdown","9476aa2e":"markdown","dd4bc4e5":"markdown","f8b02e18":"markdown","bb789287":"markdown"},"source":{"0e40d7bb":"#___________________________________________\n\n# Creator Emmanuel Pintelas\n#___________________________________________\n\n# https:\/\/www.kaggle.com\/c\/deepfake-detection-challenge\/discussion\/128954\nimport gc\nimport os\n\nimport zipfile\nimport numpy as np\nimport tensorflow as tf\nfrom keras.layers import Dense,Conv2D,MaxPooling2D,Dropout,BatchNormalization,Lambda,Activation,Input,Flatten,Reshape,Conv2DTranspose\nimport skimage\nfrom skimage.exposure import rescale_intensity\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom skimage.transform import rescale, resize, downscale_local_mean\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.preprocessing import OneHotEncoder\nimport skimage\nfrom PIL import Image\nfrom skimage.io import imread, imshow, imread_collection, concatenate_images\nfrom skimage.transform import resize\nfrom skimage.util import crop, pad\nfrom skimage.morphology import label\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau, Callback\nfrom keras import optimizers\nfrom tensorflow.keras.layers import Dense, GlobalAveragePooling2D, BatchNormalization, GlobalMaxPooling2D\nimport psutil\nimport multiprocessing as mp\nfrom keras.applications import ResNet50, DenseNet201, Xception, VGG16, InceptionV3, InceptionResNetV2, MobileNetV2, NASNetMobile\nimport copy\nmp.cpu_count()\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nimport sys\nfrom  skimage.feature import greycoprops\n#%matplotlib inline\nimport keras\nfrom keras.models import load_model\nfrom keras.models import Model,Sequential\nfrom keras.layers import Dense,Conv2D,MaxPooling2D,Dropout,BatchNormalization,Lambda,Activation,Input,Flatten,Reshape,Conv2DTranspose, LeakyReLU\nimport keras.backend as K\nfrom keras.layers.merge import add\nfrom sklearn.model_selection import train_test_split\nimport os\nimport glob\nfrom time import time,asctime\nfrom random import randint as r\nimport random\nfrom skimage import io\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom numpy import save, load\nfrom   sklearn.metrics           import f1_score, accuracy_score, classification_report, confusion_matrix\nfrom sklearn import metrics\nfrom numpy import load\nimport pandas as pd\nimport skimage\nfrom skimage.transform import resize\nimport math\nfrom sklearn.svm import SVC\nfrom keras.layers import Input, Dense, UpSampling2D, Flatten, Reshape\nfrom itertools import combinations_with_replacement\nimport itertools\nimport numpy as np\nfrom skimage import filters, feature\nfrom skimage import img_as_float32\nfrom concurrent.futures import ThreadPoolExecutor\nimport scipy.stats\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ VIDEO 3D CNN CLASSIFICATION FUNCTIONS _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\nclass Video_Generator_3D_CNN(tf.keras.utils.Sequence):\n    'Generates data for Keras'\n    def __init__(self,mode='',\n                 batch_size=1, depth='', width='', heigth='', paths = '', labels = '', n_channels=3, shuffle=False):\n\n        'Initialization'\n        self.mode = mode\n        self.batch_size = batch_size\n        self.paths = paths   # video paths of jpg frame images\n        self.labels = labels # video labels\n        self.depth = depth   # Number of frames\n        self.width = width\n        self.heigth = heigth\n        self.n_channels = n_channels\n        #self.shuffle = shuffle\n        #self.augment = augmentations\n        self.on_epoch_end()\n        self.cnt = 0\n\n\n    def __len__(self):\n        'Denotes the number of batches per epoch'\n        return int(np.ceil(len(self.paths) \/ self.batch_size))\n\n    def __getitem__(self, index):\n        'Generate one batch of data'\n        # Generate indexes of the batch\n        indexes = self.indexes[index*self.batch_size:min((index+1)*self.batch_size,len(self.paths))]\n        # Find list of IDs\n        list_IDs_im = [self.paths[k] for k in indexes]\n\n        Y = np.empty((len(list_IDs_im),2))\n        j=-1\n        for i in indexes:\n            j+=1\n            Y[j,] = self.labels[i] \n            #print(i)\n\n        # Generate data\n        \u03a7   = self.data_generation(list_IDs_im)\n        \n        \n\n        \n\n        self.cnt +=1\n        #print (self.cnt)\n\n        if self.mode == 'predict':\n               return \u03a7   \n        elif self.mode == 'train_C': \n            return \u03a7, Y      \n        elif self.mode == 'train_AE': \n            \u03a71 = \u03a7\n            \u03a72 = np.copy(\u03a71)\n            return \u03a71, \u03a72  \n\n    def on_epoch_end(self):\n        'Updates indexes after each epoch'\n        self.indexes = np.arange(len(self.paths))\n        # if self.shuffle == True:\n        #     np.random.shuffle(self.indexes)\n\n    def data_generation(self, list_IDs_im):\n        'Generates data containing batch_size samples' # X : (n_samples, *dim, n_channels)\n        # Initialization\n        X = np.empty((len(list_IDs_im),self.depth,self.width,self.heigth,self.n_channels))\n\n        # Generate data\n        for i, vid_path in enumerate(list_IDs_im):  \n            vid_path = vid_path[0]\n            Frames_id = os.listdir(vid_path)\n\n            Frames_id_int = []\n            for fr in Frames_id:\n                    if '_' not in fr:    \n                                fr = int (fr.replace('.jpg',''))\n                                Frames_id_int.append (fr)\n            Frames_id_int = np.array(Frames_id_int)\n            Frames_id_int = np.sort(Frames_id_int) \n\n            signal = 0\n            while signal != 1:\n                    try:\n                        for fr_int in Frames_id_int:\n                            fr_str = str(fr_int)+'.jpg'\n                            img_path = vid_path+'\/'+fr_str\n                            img = io.imread(img_path) # all frames must be of same size\n                            img = img.astype(float)\n                            Frames_per_Instance.append(img)  \n                        Frames_per_Instance = np.array(Frames_per_Instance)\n                        signal = 1\n                    except:  \n                        Frames_per_Instance = []\n\n\n            #Frames_per_Instance = resize (Frames_per_Instance,(self.depth,self.width,self.heigth,self.n_channels))\n            Frames_per_Instance_Sampled = np.zeros((self.depth,self.width,self.heigth,self.n_channels))\n            init_depth = Frames_per_Instance.shape[0]\n            sampling_Ratio = int (init_depth\/self.depth)\n            j=-1\n            for _i in range(300):\n                    if _i % sampling_Ratio == 0:\n                        j+=1\n                        Frames_per_Instance_Sampled[j] = cv2.resize(Frames_per_Instance[_i],(self.width,self.heigth)).astype(float)\/255.\n                        # plt.figure()\n                        # plt.imshow(Frames_per_Instance_Sampled[j])\n                        # plt.show()\n\n            X[i,] = Frames_per_Instance_Sampled\n\n        \n\n        return X\n\n\n\ndef Build_Classifier_3D_CNN (depth, width, heigth):\n\n                    inputs = keras.Input((depth, width, heigth, 3))\n\n                    x = layers.Conv3D(filters=32, kernel_size=3, activation=\"relu\")(inputs)\n                    x = layers.MaxPool3D(pool_size=(1,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.Conv3D(filters=64, kernel_size=3, activation=\"relu\")(x)\n                    x = layers.MaxPool3D(pool_size=(2,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.Conv3D(filters=128, kernel_size=3, activation=\"relu\")(x)\n                    x = layers.MaxPool3D(pool_size=(2,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.Conv3D(filters=256, kernel_size=3, activation=\"relu\")(x)\n                    x = layers.MaxPool3D(pool_size=(2,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.GlobalAveragePooling3D()(x)\n                    # FC Layer ___________\n                    x = layers.Dense(units=64, activation=\"relu\")(x)\n                    x = layers.Dropout(0.2)(x)\n\n                    outputs = layers.Dense(units=2, activation=\"sigmoid\")(x)\n\n                    # Define the model.\n                    model3d = keras.Model(inputs, outputs, name=\"Classifier_3D_CNN\")\n\n                    return model3d\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ CNN Feature Extractor _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\ndef Build_CNN_F_Extr (CNN,layer_id):\n        layer =  CNN.layers[layer_id]\n        layer_name = layer.name\n        CNN_F_Extr = Model(inputs=CNN.input, outputs=CNN.get_layer(layer_name).output)\n        model = Sequential()\n        model.add(CNN_F_Extr)\n        model.add(Flatten())\n        CNN_F_Extr = model\n        return CNN_F_Extr\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ VIDEO 2D CNN FUNCTIONS _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n \ndef Build_R2D_Classifier (width, heigth):\n\n    R2D = ResNet50(include_top=False, weights='imagenet',  input_shape=(width, heigth,3))\n    model = Sequential()\n    model.add(R2D)\n    model.add(GlobalAveragePooling2D())\n    # FC Layer ___________\n    model.add(Dense(units=64, activation=\"relu\"))\n    model.add(Dropout(0.2))\n    model.add(layers.Dense(units=1, activation=\"sigmoid\"))\n    R2D_Classifier = model\n    R2D_Classifier.summary()\n    return R2D_Classifier\n\n\ndef Video_2D_CNN_FE (CNN2D_FE,depth,width,heigth,n_channels,paths):\n    FEATURES = np.zeros(((paths.shape[0]), depth, CNN2D_FE.output.shape[1]))\n    index = -1\n    for vid_path in paths:  \n                index+=1\n                vid_path = vid_path[0]\n                _,__,name = vid_path.split('\/')\n                Frames_id = os.listdir(vid_path)\n\n                Frames_id_int = []\n                for fr in Frames_id:\n                        if '_' not in fr:    \n                                    fr = int (fr.replace('.jpg',''))\n                                    Frames_id_int.append (fr)\n                Frames_id_int = np.array(Frames_id_int)\n                Frames_id_int = np.sort(Frames_id_int) \n\n                Frames_per_Instance = []\n                for fr_int in Frames_id_int:\n                                fr_str = str(fr_int)+'.jpg'\n                                img_path = vid_path+'\/'+fr_str\n                                img = io.imread(img_path) # all frames must be of same size\n                                img = img.astype(float)\n                                Frames_per_Instance.append(img)  \n                Frames_per_Instance = np.array(Frames_per_Instance)\n\n                Frames_per_Instance_Sampled = np.zeros((depth,width,heigth,n_channels))\n                init_depth = Frames_per_Instance.shape[0]\n                sampling_Ratio = int (init_depth\/depth)\n                j=-1\n                for _i in range(300):\n                        if _i % sampling_Ratio == 0:\n                            j+=1\n                            Frames_per_Instance_Sampled[j] = cv2.resize(Frames_per_Instance[_i],(width,heigth)).astype(float)\/255.\n                            # plt.figure()\n                            # plt.imshow(Frames_per_Instance_Sampled[j])\n                            # plt.show()\n                \n                features_per_instance = CNN2D_FE.predict(Frames_per_Instance_Sampled)\n                FEATURES[index] = features_per_instance\n    return FEATURES\n\n\n\n\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n\n\n\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ HC FEATURES 1 _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n \ndef Co_Oc_Features (img):\n    img = np.uint8(img)\n    if img.shape[-1] == 3:\n                    matrix0 = skimage.feature.texture.greycomatrix(img[:,:,0], [1,2], [0, np.pi\/2],  normed=True, symmetric=True)\n                    matrix1 = skimage.feature.texture.greycomatrix(img[:,:,1], [1,2], [0, np.pi\/2],  normed=True, symmetric=True)\n                    matrix2 = skimage.feature.texture.greycomatrix(img[:,:,2], [1,2], [0, np.pi\/2],  normed=True, symmetric=True)\n                    con0,dis0,hom0,ASM0,en0,cor0 = greycoprops(matrix0, 'contrast'), greycoprops(matrix0, 'dissimilarity'), greycoprops(matrix0, 'homogeneity'),greycoprops(matrix0, 'ASM'),greycoprops(matrix0, 'energy'),greycoprops(matrix0, 'correlation')\n                    con1,dis1,hom1,ASM1,en1,cor1 = greycoprops(matrix1, 'contrast'), greycoprops(matrix1, 'dissimilarity'), greycoprops(matrix1, 'homogeneity'),greycoprops(matrix1, 'ASM'),greycoprops(matrix1, 'energy'),greycoprops(matrix1, 'correlation')\n                    con2,dis2,hom2,ASM2,en2,cor2 = greycoprops(matrix2, 'contrast'), greycoprops(matrix2, 'dissimilarity'), greycoprops(matrix2, 'homogeneity'),greycoprops(matrix2, 'ASM'),greycoprops(matrix2, 'energy'),greycoprops(matrix2, 'correlation')\n                    con0,dis0,hom0,ASM0,en0,cor0, con1,dis1,hom1,ASM1,en1,cor1, con2,dis2,hom2,ASM2,en2,cor2 = con0.reshape(1,4),dis0.reshape(1,4),hom0.reshape(1,4),ASM0.reshape(1,4),en0.reshape(1,4),cor0.reshape(1,4), con1.reshape(1,4),dis1.reshape(1,4),hom1.reshape(1,4),ASM1.reshape(1,4),en1.reshape(1,4),cor1.reshape(1,4), con2.reshape(1,4),dis2.reshape(1,4),hom2.reshape(1,4),ASM2.reshape(1,4),en2.reshape(1,4),cor2.reshape(1,4)\n                    \n                    mean0,std0, mean1,std1, mean2,std2 = np.array(np.mean(img[:,:,0])).reshape(-1,1),np.array(np.std(img[:,:,0])).reshape(-1,1), np.array(np.mean(img[:,:,1])).reshape(-1,1),np.array(np.std(img[:,:,1])).reshape(-1,1), np.array(np.mean(img[:,:,2])).reshape(-1,1),np.array(np.std(img[:,:,2])).reshape(-1,1)\n                    \n                    co_oc = np.concatenate((mean0,std0, mean1,std1, mean2,std2, con0,dis0,hom0,ASM0,en0,cor0, con1,dis1,hom1,ASM1,en1,cor1, con2,dis2,hom2,ASM2,en2,cor2),axis = 1) \n                    return co_oc\n    else:\n        matrix0 = skimage.feature.texture.greycomatrix(img, [1,2], [0, np.pi\/2],  levels=256, normed=True, symmetric=True)\n        con0,dis0,hom0,ASM0,en0,cor0 = greycoprops(matrix0, 'contrast'), greycoprops(matrix0, 'dissimilarity'), greycoprops(matrix0, 'homogeneity'),greycoprops(matrix0, 'ASM'),greycoprops(matrix0, 'energy'),greycoprops(matrix0, 'correlation')\n        co_oc = np.concatenate((con0.reshape(1,4),dis0.reshape(1,4),hom0.reshape(1,4),ASM0.reshape(1,4),en0.reshape(1,4),cor0.reshape(1,4)),axis = 1) \n        return co_oc\n        \n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ CNN Compile and Train _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\nimport tensorflow_addons as tfa\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom keras import backend as K\n\n# Compatible with tensorflow backend\ndef focal_loss(gamma=2., alpha=.25):\n\tdef focal_loss_fixed(y_true, y_pred):\n\t\tpt_1 = tf.where(tf.equal(y_true, 1), y_pred, tf.ones_like(y_pred))\n\t\tpt_0 = tf.where(tf.equal(y_true, 0), y_pred, tf.zeros_like(y_pred))\n\t\treturn -K.mean(alpha * K.pow(1. - pt_1, gamma) * K.log(pt_1+K.epsilon())) - K.mean((1 - alpha) * K.pow(pt_0, gamma) * K.log(1. - pt_0 + K.epsilon()))\n\treturn focal_loss_fixed\n\n\ndef Compile_CNN(model,lr):\n                    # Compile model.\n                    initial_learning_rate = lr \n                    lr_schedule = keras.optimizers.schedules.ExponentialDecay(\n                        initial_learning_rate, decay_steps=100000, decay_rate=0.96, staircase=True\n                    )\n                    model.compile(\n                        loss='binary_crossentropy',#focal_loss(),  # 'binary_crossentropy'   'categorical_crossentropy', 'sparse_categorical_crossentropy',\n                        optimizer=keras.optimizers.Adam(learning_rate=lr_schedule),   # 0.001\n                        metrics=['accuracy'] # Geometric_Mean\n                    )\n\n                    # Define callbacks.\n                    checkpoint_cb = keras.callbacks.ModelCheckpoint(\n                        \"CNN_Classifier.h5\",\n                        mode='max',\n                        monitor=['val_acc'], # Geometric_Mean\n                        save_best_only=True\n                    )\n                    early_stopping_cb = keras.callbacks.EarlyStopping(monitor=['val_acc'], patience=3)\n                    return model, checkpoint_cb, early_stopping_cb\n\n\ndef Train_CNN(model, epochs, train_video_g, test_video_g, checkpoint_cb, early_stopping_cb):\n                    model.fit(train_video_g,\n                                                    verbose=1,\n                                                    epochs=epochs,\n                                                    #############################callbacks=[checkpoint_cb, early_stopping_cb],\n                                                    #validation_data=test_video_g,\n                                                    shuffle=False)\n                    return model\n\n\n\ndef Evaluation(preds, labels):\n\n                    test_y = labels\n                    pr_t = preds\n\n                    Acc = accuracy_score(test_y, pr_t) \n                    F1 = f1_score(test_y, pr_t)\n                    tn, fp, fn, tp = confusion_matrix(test_y, pr_t).ravel()\n                    GM = (tp*tn)**(0.5)\n                    sensitivity =  tp \/ (tp + fn) # sensitivity, recall\n                    specificity = tn \/ (tn+fp) # specificity, selectivity\n                    #ROC_AUC = metrics.roc_auc_score(test_y, probs)  # [:,1]\n\n\n                    print ('CM = ')\n                    print(np.round (confusion_matrix(test_y, preds), 3))                    \n                    print ('Acc = ')\n                    print(str(np.round (Acc, 3)*100) + '%')\n                    print ('GM = ')\n                    print(np.round (GM, 1))\n                    print ('F1 = ')\n                    print(np.round (F1, 3))\n                    print ('Sen = ')\n                    print(np.round (sensitivity, 3))\n                    print ('Spe = ')\n                    print(np.round (specificity, 3))\n                    # print ('ROC_AUC = ')\n                    # print(np.round (ROC_AUC, 3))\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ General Functions _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\ndef decode_labels (labels):\n    int_labels = []\n    for lb in labels:\n        if lb == 'FAKE':\n            int_labels.append(1)\n        else:\n            int_labels.append(0)\n    int_labels = np.array(int_labels)\n    return int_labels\n\ndef create_paths (folder_name,filenames):\n    paths = []\n    for f in filenames:\n        f,_ = f.split('.mp4')\n        path = folder_name+f\n        paths.append(path)\n    paths = pd.DataFrame(paths).values\n    return  paths\n\n\n\ndef Balance_Data (X,Y):\n\n    cnt_label1, cnt_label0 = 0, 0\n    X0,X1 = [],[]\n    for x,y in zip (X,Y):\n        if y == 1:\n            cnt_label1+=1\n            X1.append(x)\n        else:\n            cnt_label0+=1\n            X0.append(x)\n\n    if cnt_label0>cnt_label1:\n        final_N = cnt_label1\n    else:\n        final_N = cnt_label0\n\n    s1 = int(cnt_label1 \/ final_N)\n    s0 = int(cnt_label0 \/ final_N)\n\n    X1_b = []\n    for i in range (cnt_label1):\n        if i % s1  == 0:\n            X1_b.append(X1[i])\n    X0_b = []\n    for i in range (cnt_label0):\n        if i % s0  == 0:\n            X0_b.append(X0[i])\n    X0_b = np.array(X0_b)\n    X1_b = np.array(X1_b)\n    Y0_b = np.zeros((X0_b.shape[0],1))\n    Y1_b = np.ones((X1_b.shape[0],1))\n\n    X = np.concatenate((X0_b, X1_b),axis=0)\n    Y = np.concatenate((Y0_b, Y1_b),axis=0)\n    return X,Y\n\n\n\ndef Create_2D_Dataset (depth,width,heigth,n_channels,train_paths,Labels_train):\n    for vid_path, lbl in zip(train_paths,Labels_train):  \n                vid_path = vid_path[0]\n                _,__,name = vid_path.split('\/')\n                Frames_id = os.listdir(vid_path)\n\n                Frames_id_int = []\n                for fr in Frames_id:\n                        if '_' not in fr:    \n                                    fr = int (fr.replace('.jpg',''))\n                                    Frames_id_int.append (fr)\n                Frames_id_int = np.array(Frames_id_int)\n                Frames_id_int = np.sort(Frames_id_int) \n\n                Frames_per_Instance = []\n                for fr_int in Frames_id_int:\n                                fr_str = str(fr_int)+'.jpg'\n                                img_path = vid_path+'\/'+fr_str\n                                img = io.imread(img_path) # all frames must be of same size\n                                img = img.astype(float)\n                                Frames_per_Instance.append(img)  \n                Frames_per_Instance = np.array(Frames_per_Instance)\n\n                Frames_per_Instance_Sampled = np.zeros((depth,width,heigth,n_channels))\n                init_depth = Frames_per_Instance.shape[0]\n                sampling_Ratio = int (init_depth\/depth)\n                j=-1\n                for _i in range(300):\n                        if _i % sampling_Ratio == 0:\n                            j+=1\n                            Frames_per_Instance_Sampled[j] = cv2.resize(Frames_per_Instance[_i],(width,heigth))#.astype(float)\/255.\n                            # plt.figure()\n                            # plt.imshow(Frames_per_Instance_Sampled[j])\n                            # plt.show()\n\n                _cnt = -1\n                for fr_s in Frames_per_Instance_Sampled:\n                    _cnt+=1\n                    skimage.io.imsave ('Dataset\/Test_Dataset_2D\/'+str(int(lbl))+'\/'+str(_cnt)+name+'.jpg',fr_s)    \n                    # Train_Dataset_2D   # lbl[0]\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n\n\n","d9b15fa4":"\n\n\n    \"\"\"Inception-v1 Inflated 3D ConvNet used for Kinetics CVPR paper.\n\n    The model is introduced in:\n\n    Quo Vadis, Action Recognition? A New Model and the Kinetics Dataset\n    Joao Carreira, Andrew Zisserman\n    https:\/\/arxiv.org\/abs\/1705.07750v1\n    \"\"\"\n\n    from __future__ import print_function\n    from __future__ import absolute_import\n\n    import warnings\n\n    import numpy as np\n\n    from keras.models import Model\n    from keras import layers\n    from keras.layers import Activation\n    from keras.layers import Dense\n    from keras.layers import Input\n    from keras.layers import BatchNormalization\n    from keras.layers import Conv3D\n    from keras.layers import MaxPooling3D\n    from keras.layers import AveragePooling3D\n    from keras.layers import Dropout\n    from keras.layers import Reshape\n    from keras.layers import Lambda\n    from keras.layers import GlobalAveragePooling3D\n\n    from keras.engine.topology import get_source_inputs\n    from keras.utils import layer_utils\n    from keras.utils.data_utils import get_file\n    from keras import backend as K\n\n\n\n    WEIGHTS_NAME = ['rgb_kinetics_only', 'flow_kinetics_only', 'rgb_imagenet_and_kinetics', 'flow_imagenet_and_kinetics']\n\n    # path to pretrained models with top (classification layer)\n    WEIGHTS_PATH = {\n        'rgb_kinetics_only' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/rgb_inception_i3d_kinetics_only_tf_dim_ordering_tf_kernels.h5',\n        'flow_kinetics_only' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/flow_inception_i3d_kinetics_only_tf_dim_ordering_tf_kernels.h5',\n        'rgb_imagenet_and_kinetics' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/rgb_inception_i3d_imagenet_and_kinetics_tf_dim_ordering_tf_kernels.h5',\n        'flow_imagenet_and_kinetics' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/flow_inception_i3d_imagenet_and_kinetics_tf_dim_ordering_tf_kernels.h5'\n    }\n\n    # path to pretrained models with no top (no classification layer)\n    WEIGHTS_PATH_NO_TOP = {\n        'rgb_kinetics_only' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/rgb_inception_i3d_kinetics_only_tf_dim_ordering_tf_kernels_no_top.h5',\n        'flow_kinetics_only' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/flow_inception_i3d_kinetics_only_tf_dim_ordering_tf_kernels_no_top.h5',\n        'rgb_imagenet_and_kinetics' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/rgb_inception_i3d_imagenet_and_kinetics_tf_dim_ordering_tf_kernels_no_top.h5',\n        'flow_imagenet_and_kinetics' : 'https:\/\/github.com\/dlpbc\/keras-kinetics-i3d\/releases\/download\/v0.2\/flow_inception_i3d_imagenet_and_kinetics_tf_dim_ordering_tf_kernels_no_top.h5'\n    }\n\n\n\n\n\n\n    def _obtain_input_shape(input_shape,\n                            default_frame_size,\n                            min_frame_size,\n                            default_num_frames,\n                            min_num_frames,\n                            data_format,\n                            require_flatten,\n                            weights=None):\n        \"\"\"Internal utility to compute\/validate the model's input shape.\n        (Adapted from `keras\/applications\/imagenet_utils.py`)\n        # Arguments\n            input_shape: either None (will return the default network input shape),\n                or a user-provided shape to be validated.\n            default_frame_size: default input frames(images) width\/height for the model.\n            min_frame_size: minimum input frames(images) width\/height accepted by the model.\n            default_num_frames: default input number of frames(images) for the model.\n            min_num_frames: minimum input number of frames accepted by the model.\n            data_format: image data format to use.\n            require_flatten: whether the model is expected to\n                be linked to a classifier via a Flatten layer.\n            weights: one of `None` (random initialization)\n                or 'kinetics_only' (pre-training on Kinetics dataset).\n                or 'imagenet_and_kinetics' (pre-training on ImageNet and Kinetics datasets).\n                If weights='kinetics_only' or weights=='imagenet_and_kinetics' then\n                input channels must be equal to 3.\n        # Returns\n            An integer shape tuple (may include None entries).\n        # Raises\n            ValueError: in case of invalid argument values.\n        \"\"\"\n        if weights != 'kinetics_only' and weights != 'imagenet_and_kinetics' and input_shape and len(input_shape) == 4:\n            if data_format == 'channels_first':\n                if input_shape[0] not in {1, 3}:\n                    warnings.warn(\n                        'This model usually expects 1 or 3 input channels. '\n                        'However, it was passed an input_shape with ' +\n                        str(input_shape[0]) + ' input channels.')\n                default_shape = (input_shape[0], default_num_frames, default_frame_size, default_frame_size)\n            else:\n                if input_shape[-1] not in {1, 3}:\n                    warnings.warn(\n                        'This model usually expects 1 or 3 input channels. '\n                        'However, it was passed an input_shape with ' +\n                        str(input_shape[-1]) + ' input channels.')\n                default_shape = (default_num_frames, default_frame_size, default_frame_size, input_shape[-1])\n        else:\n            if data_format == 'channels_first':\n                default_shape = (3, default_num_frames, default_frame_size, default_frame_size)\n            else:\n                default_shape = (default_num_frames, default_frame_size, default_frame_size, 3)\n        if (weights == 'kinetics_only' or weights == 'imagenet_and_kinetics') and require_flatten:\n            if input_shape is not None:\n                if input_shape != default_shape:\n                    raise ValueError('When setting`include_top=True` '\n                                     'and loading `imagenet` weights, '\n                                     '`input_shape` should be ' +\n                                     str(default_shape) + '.')\n            return default_shape\n\n        if input_shape:\n            if data_format == 'channels_first':\n                if input_shape is not None:\n                    if len(input_shape) != 4:\n                        raise ValueError(\n                            '`input_shape` must be a tuple of four integers.')\n                    if input_shape[0] != 3 and (weights == 'kinetics_only' or weights == 'imagenet_and_kinetics'):\n                        raise ValueError('The input must have 3 channels; got '\n                                         '`input_shape=' + str(input_shape) + '`')\n\n                    if input_shape[1] is not None and input_shape[1] < min_num_frames:\n                        raise ValueError('Input number of frames must be at least ' +\n                                         str(min_num_frames) + '; got '\n                                         '`input_shape=' + str(input_shape) + '`')\n\n                    if ((input_shape[2] is not None and input_shape[2] < min_frame_size) or\n                       (input_shape[3] is not None and input_shape[3] < min_frame_size)):\n                        raise ValueError('Input size must be at least ' +\n                                         str(min_frame_size) + 'x' + str(min_frame_size) + '; got '\n                                         '`input_shape=' + str(input_shape) + '`')\n            else:\n                if input_shape is not None:\n                    if len(input_shape) != 4:\n                        raise ValueError(\n                            '`input_shape` must be a tuple of four integers.')\n                    if input_shape[-1] != 3 and (weights == 'kinetics_only' or weights == 'imagenet_and_kinetics'):\n                        raise ValueError('The input must have 3 channels; got '\n                                         '`input_shape=' + str(input_shape) + '`')\n\n                    if input_shape[0] is not None and input_shape[0] < min_num_frames:\n                        raise ValueError('Input number of frames must be at least ' +\n                                         str(min_num_frames) + '; got '\n                                         '`input_shape=' + str(input_shape) + '`')\n\n                    if ((input_shape[1] is not None and input_shape[1] < min_frame_size) or\n                       (input_shape[2] is not None and input_shape[2] < min_frame_size)):\n                        raise ValueError('Input size must be at least ' +\n                                         str(min_frame_size) + 'x' + str(min_frame_size) + '; got '\n                                         '`input_shape=' + str(input_shape) + '`')\n        else:\n            if require_flatten:\n                input_shape = default_shape\n            else:\n                if data_format == 'channels_first':\n                    input_shape = (3, None, None, None)\n                else:\n                    input_shape = (None, None, None, 3)\n        if require_flatten:\n            if None in input_shape:\n                raise ValueError('If `include_top` is True, '\n                                 'you should specify a static `input_shape`. '\n                                 'Got `input_shape=' + str(input_shape) + '`')\n        return input_shape\n\n\n    def conv3d_bn(x,\n                  filters,\n                  num_frames,\n                  num_row,\n                  num_col,\n                  padding='same',\n                  strides=(1, 1, 1),\n                  use_bias = False,\n                  use_activation_fn = True,\n                  use_bn = True,\n                  name=None):\n        \"\"\"Utility function to apply conv3d + BN.\n        # Arguments\n            x: input tensor.\n            filters: filters in `Conv3D`.\n            num_frames: frames (time depth) of the convolution kernel.\n            num_row: height of the convolution kernel.\n            num_col: width of the convolution kernel.\n            padding: padding mode in `Conv3D`.\n            strides: strides in `Conv3D`.\n            use_bias: use bias or not  \n            use_activation_fn: use an activation function or not.\n            use_bn: use batch normalization or not.\n            name: name of the ops; will become `name + '_conv'`\n                for the convolution and `name + '_bn'` for the\n                batch norm layer.\n        # Returns\n            Output tensor after applying `Conv3D` and `BatchNormalization`.\n        \"\"\"\n        if name is not None:\n            bn_name = name + '_bn'\n            conv_name = name + '_conv'\n        else:\n            bn_name = None\n            conv_name = None\n\n        x = Conv3D(\n            filters, (num_frames, num_row, num_col),\n            strides=strides,\n            padding=padding,\n            use_bias=use_bias,\n            name=conv_name)(x)\n\n        if use_bn:\n            if K.image_data_format() == 'channels_first':\n                bn_axis = 1\n            else:\n                bn_axis = 4\n            x = BatchNormalization(axis=bn_axis, scale=False, name=bn_name)(x)\n\n        if use_activation_fn:\n            x = Activation('relu', name=name)(x)\n\n        return x\n\n\n\n    def Inception_Inflated3d(include_top=True,\n                    weights=None,\n                    input_tensor=None,\n                    input_shape=None,\n                    dropout_prob=0.0,\n                    endpoint_logit=True,\n                    classes=400):\n        \"\"\"Instantiates the Inflated 3D Inception v1 architecture.\n        Optionally loads weights pre-trained\n        on Kinetics. Note that when using TensorFlow,\n        for best performance you should set\n        `image_data_format='channels_last'` in your Keras config\n        at ~\/.keras\/keras.json.\n        The model and the weights are compatible with both\n        TensorFlow and Theano. The data format\n        convention used by the model is the one\n        specified in your Keras config file.\n        Note that the default input frame(image) size for this model is 224x224.\n        # Arguments\n            include_top: whether to include the the classification \n                layer at the top of the network.\n            weights: one of `None` (random initialization)\n                or 'kinetics_only' (pre-training on Kinetics dataset only).\n                or 'imagenet_and_kinetics' (pre-training on ImageNet and Kinetics datasets).\n            input_tensor: optional Keras tensor (i.e. output of `layers.Input()`)\n                to use as image input for the model.\n            input_shape: optional shape tuple, only to be specified\n                if `include_top` is False (otherwise the input shape\n                has to be `(NUM_FRAMES, 224, 224, 3)` (with `channels_last` data format)\n                or `(NUM_FRAMES, 3, 224, 224)` (with `channels_first` data format).\n                It should have exactly 3 inputs channels.\n                NUM_FRAMES should be no smaller than 8. The authors used 64\n                frames per example for training and testing on kinetics dataset\n                Also, Width and height should be no smaller than 32.\n                E.g. `(64, 150, 150, 3)` would be one valid value.\n            dropout_prob: optional, dropout probability applied in dropout layer\n                after global average pooling layer. \n                0.0 means no dropout is applied, 1.0 means dropout is applied to all features.\n                Note: Since Dropout is applied just before the classification\n                layer, it is only useful when `include_top` is set to True.\n            endpoint_logit: (boolean) optional. If True, the model's forward pass\n                will end at producing logits. Otherwise, softmax is applied after producing\n                the logits to produce the class probabilities prediction. Setting this parameter \n                to True is particularly useful when you want to combine results of rgb model\n                and optical flow model.\n                - `True` end model forward pass at logit output\n                - `False` go further after logit to produce softmax predictions\n                Note: This parameter is only useful when `include_top` is set to True.\n            classes: optional number of classes to classify images\n                into, only to be specified if `include_top` is True, and\n                if no `weights` argument is specified.\n        # Returns\n            A Keras model instance.\n        # Raises\n            ValueError: in case of invalid argument for `weights`,\n                or invalid input shape.\n        \"\"\"\n        if not (weights in WEIGHTS_NAME or weights is None or os.path.exists(weights)):\n            raise ValueError('The `weights` argument should be either '\n                             '`None` (random initialization) or %s' % \n                             str(WEIGHTS_NAME) + ' ' \n                             'or a valid path to a file containing `weights` values')\n\n        if weights in WEIGHTS_NAME and include_top and classes != 400:\n            raise ValueError('If using `weights` as one of these %s, with `include_top`'\n                             ' as true, `classes` should be 400' % str(WEIGHTS_NAME))\n\n        # Determine proper input shape\n        input_shape = _obtain_input_shape(\n            input_shape,\n            default_frame_size=224, \n            min_frame_size=32, \n            default_num_frames=64,\n            min_num_frames=8,\n            data_format=K.image_data_format(),\n            require_flatten=include_top,\n            weights=weights)\n\n        if input_tensor is None:\n            img_input = Input(shape=input_shape)\n        else:\n            if not K.is_keras_tensor(input_tensor):\n                img_input = Input(tensor=input_tensor, shape=input_shape)\n            else:\n                img_input = input_tensor\n\n        if K.image_data_format() == 'channels_first':\n            channel_axis = 1\n        else:\n            channel_axis = 4\n\n        # Downsampling via convolution (spatial and temporal)\n        x = conv3d_bn(img_input, 64, 7, 7, 7, strides=(2, 2, 2), padding='same', name='Conv3d_1a_7x7')\n\n        # Downsampling (spatial only)\n        x = MaxPooling3D((1, 3, 3), strides=(1, 2, 2), padding='same', name='MaxPool2d_2a_3x3')(x)\n        x = conv3d_bn(x, 64, 1, 1, 1, strides=(1, 1, 1), padding='same', name='Conv3d_2b_1x1')\n        x = conv3d_bn(x, 192, 3, 3, 3, strides=(1, 1, 1), padding='same', name='Conv3d_2c_3x3')\n\n        # Downsampling (spatial only)\n        x = MaxPooling3D((1, 3, 3), strides=(1, 2, 2), padding='same', name='MaxPool2d_3a_3x3')(x)\n\n        # Mixed 3b\n        branch_0 = conv3d_bn(x, 64, 1, 1, 1, padding='same', name='Conv3d_3b_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 96, 1, 1, 1, padding='same', name='Conv3d_3b_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 128, 3, 3, 3, padding='same', name='Conv3d_3b_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 16, 1, 1, 1, padding='same', name='Conv3d_3b_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 32, 3, 3, 3, padding='same', name='Conv3d_3b_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_3b_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 32, 1, 1, 1, padding='same', name='Conv3d_3b_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_3b')\n\n        # Mixed 3c\n        branch_0 = conv3d_bn(x, 128, 1, 1, 1, padding='same', name='Conv3d_3c_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 128, 1, 1, 1, padding='same', name='Conv3d_3c_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 192, 3, 3, 3, padding='same', name='Conv3d_3c_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 32, 1, 1, 1, padding='same', name='Conv3d_3c_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 96, 3, 3, 3, padding='same', name='Conv3d_3c_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_3c_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 64, 1, 1, 1, padding='same', name='Conv3d_3c_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_3c')\n\n\n        # Downsampling (spatial and temporal)\n        x = MaxPooling3D((3, 3, 3), strides=(2, 2, 2), padding='same', name='MaxPool2d_4a_3x3')(x)\n\n        # Mixed 4b\n        branch_0 = conv3d_bn(x, 192, 1, 1, 1, padding='same', name='Conv3d_4b_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 96, 1, 1, 1, padding='same', name='Conv3d_4b_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 208, 3, 3, 3, padding='same', name='Conv3d_4b_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 16, 1, 1, 1, padding='same', name='Conv3d_4b_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 48, 3, 3, 3, padding='same', name='Conv3d_4b_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_4b_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 64, 1, 1, 1, padding='same', name='Conv3d_4b_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_4b')\n\n        # Mixed 4c\n        branch_0 = conv3d_bn(x, 160, 1, 1, 1, padding='same', name='Conv3d_4c_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 112, 1, 1, 1, padding='same', name='Conv3d_4c_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 224, 3, 3, 3, padding='same', name='Conv3d_4c_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 24, 1, 1, 1, padding='same', name='Conv3d_4c_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 64, 3, 3, 3, padding='same', name='Conv3d_4c_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_4c_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 64, 1, 1, 1, padding='same', name='Conv3d_4c_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_4c')\n\n        # Mixed 4d\n        branch_0 = conv3d_bn(x, 128, 1, 1, 1, padding='same', name='Conv3d_4d_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 128, 1, 1, 1, padding='same', name='Conv3d_4d_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 256, 3, 3, 3, padding='same', name='Conv3d_4d_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 24, 1, 1, 1, padding='same', name='Conv3d_4d_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 64, 3, 3, 3, padding='same', name='Conv3d_4d_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_4d_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 64, 1, 1, 1, padding='same', name='Conv3d_4d_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_4d')\n\n        # Mixed 4e\n        branch_0 = conv3d_bn(x, 112, 1, 1, 1, padding='same', name='Conv3d_4e_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 144, 1, 1, 1, padding='same', name='Conv3d_4e_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 288, 3, 3, 3, padding='same', name='Conv3d_4e_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 32, 1, 1, 1, padding='same', name='Conv3d_4e_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 64, 3, 3, 3, padding='same', name='Conv3d_4e_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_4e_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 64, 1, 1, 1, padding='same', name='Conv3d_4e_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_4e')\n\n        # Mixed 4f\n        branch_0 = conv3d_bn(x, 256, 1, 1, 1, padding='same', name='Conv3d_4f_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 160, 1, 1, 1, padding='same', name='Conv3d_4f_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 320, 3, 3, 3, padding='same', name='Conv3d_4f_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 32, 1, 1, 1, padding='same', name='Conv3d_4f_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 128, 3, 3, 3, padding='same', name='Conv3d_4f_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_4f_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 128, 1, 1, 1, padding='same', name='Conv3d_4f_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_4f')\n\n\n        # Downsampling (spatial and temporal)\n        x = MaxPooling3D((2, 2, 2), strides=(2, 2, 2), padding='same', name='MaxPool2d_5a_2x2')(x)\n\n        # Mixed 5b\n        branch_0 = conv3d_bn(x, 256, 1, 1, 1, padding='same', name='Conv3d_5b_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 160, 1, 1, 1, padding='same', name='Conv3d_5b_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 320, 3, 3, 3, padding='same', name='Conv3d_5b_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 32, 1, 1, 1, padding='same', name='Conv3d_5b_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 128, 3, 3, 3, padding='same', name='Conv3d_5b_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_5b_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 128, 1, 1, 1, padding='same', name='Conv3d_5b_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_5b')\n\n        # Mixed 5c\n        branch_0 = conv3d_bn(x, 384, 1, 1, 1, padding='same', name='Conv3d_5c_0a_1x1')\n\n        branch_1 = conv3d_bn(x, 192, 1, 1, 1, padding='same', name='Conv3d_5c_1a_1x1')\n        branch_1 = conv3d_bn(branch_1, 384, 3, 3, 3, padding='same', name='Conv3d_5c_1b_3x3')\n\n        branch_2 = conv3d_bn(x, 48, 1, 1, 1, padding='same', name='Conv3d_5c_2a_1x1')\n        branch_2 = conv3d_bn(branch_2, 128, 3, 3, 3, padding='same', name='Conv3d_5c_2b_3x3')\n\n        branch_3 = MaxPooling3D((3, 3, 3), strides=(1, 1, 1), padding='same', name='MaxPool2d_5c_3a_3x3')(x)\n        branch_3 = conv3d_bn(branch_3, 128, 1, 1, 1, padding='same', name='Conv3d_5c_3b_1x1')\n\n        x = layers.concatenate(\n            [branch_0, branch_1, branch_2, branch_3],\n            axis=channel_axis,\n            name='Mixed_5c')\n\n        if include_top:\n            # Classification block\n            x = AveragePooling3D((2, 7, 7), strides=(1, 1, 1), padding='valid', name='global_avg_pool')(x)\n            x = Dropout(dropout_prob)(x)\n\n            x = conv3d_bn(x, classes, 1, 1, 1, padding='same', \n                    use_bias=True, use_activation_fn=False, use_bn=False, name='Conv3d_6a_1x1')\n\n            num_frames_remaining = int(x.shape[1])\n            x = Reshape((num_frames_remaining, classes))(x)\n\n            # logits (raw scores for each class)\n            x = Lambda(lambda x: K.mean(x, axis=1, keepdims=False),\n                       output_shape=lambda s: (s[0], s[2]))(x)\n\n            if not endpoint_logit:\n                x = Activation('softmax', name='prediction')(x)\n        else:\n            h = int(x.shape[2])\n            w = int(x.shape[3])\n            x = AveragePooling3D((2, h, w), strides=(1, 1, 1), padding='valid', name='global_avg_pool')(x)\n\n\n\n        inputs = img_input\n        # create model\n        model = Model(inputs, x, name='i3d_inception')\n\n        # load weights\n        if weights in WEIGHTS_NAME:\n            if weights == WEIGHTS_NAME[0]:   # rgb_kinetics_only\n                if include_top:\n                    weights_url = WEIGHTS_PATH['rgb_kinetics_only']\n                    model_name = 'i3d_inception_rgb_kinetics_only.h5'\n                else:\n                    weights_url = WEIGHTS_PATH_NO_TOP['rgb_kinetics_only']\n                    model_name = 'i3d_inception_rgb_kinetics_only_no_top.h5'\n\n            elif weights == WEIGHTS_NAME[1]: # flow_kinetics_only\n                if include_top:\n                    weights_url = WEIGHTS_PATH['flow_kinetics_only']\n                    model_name = 'i3d_inception_flow_kinetics_only.h5'\n                else:\n                    weights_url = WEIGHTS_PATH_NO_TOP['flow_kinetics_only']\n                    model_name = 'i3d_inception_flow_kinetics_only_no_top.h5'\n\n            elif weights == WEIGHTS_NAME[2]: # rgb_imagenet_and_kinetics\n                if include_top:\n                    weights_url = WEIGHTS_PATH['rgb_imagenet_and_kinetics']\n                    model_name = 'i3d_inception_rgb_imagenet_and_kinetics.h5'\n                else:\n                    weights_url = WEIGHTS_PATH_NO_TOP['rgb_imagenet_and_kinetics']\n                    model_name = 'i3d_inception_rgb_imagenet_and_kinetics_no_top.h5'\n\n            elif weights == WEIGHTS_NAME[3]: # flow_imagenet_and_kinetics\n                if include_top:\n                    weights_url = WEIGHTS_PATH['flow_imagenet_and_kinetics']\n                    model_name = 'i3d_inception_flow_imagenet_and_kinetics.h5'\n                else:\n                    weights_url = WEIGHTS_PATH_NO_TOP['flow_imagenet_and_kinetics']\n                    model_name = 'i3d_inception_flow_imagenet_and_kinetics_no_top.h5'\n\n            downloaded_weights_path = get_file(model_name, weights_url, cache_subdir='models')\n            model.load_weights(downloaded_weights_path)\n\n            if K.backend() == 'theano':\n                layer_utils.convert_all_kernels_in_model(model)\n\n            if K.image_data_format() == 'channels_first' and K.backend() == 'tensorflow':\n                warnings.warn('You are using the TensorFlow backend, yet you '\n                              'are using the Theano '\n                              'image data format convention '\n                              '(`image_data_format=\"channels_first\"`). '\n                              'For best performance, set '\n                              '`image_data_format=\"channels_last\"` in '\n                              'your keras config '\n                              'at ~\/.keras\/keras.json.')\n\n        elif weights is not None:\n            model.load_weights(weights)\n\n        return model\n\n    from keras.models import Sequential\n    def Build_ID3_Classifier (depth, width, heigth):\n        ID3 = Inception_Inflated3d(\n                        include_top=False,\n                        weights='rgb_imagenet_and_kinetics',  # rgb_kinetics_only  rgb_imagenet_and_kinetics   flow_imagenet_and_kinetics   None\n                        input_shape=(depth, width, heigth, 3),\n                        classes=2)\n        model = Sequential()\n        model.add(ID3)\n        model.add(GlobalAveragePooling3D())\n        # FC Layer ___________\n        model.add(Dense(units=64, activation=\"relu\"))\n        model.add(Dropout(0.2))\n        model.add(layers.Dense(units=2, activation=\"sigmoid\"))\n        ID3_Classifier = model\n        #ID3_Classifier.summary()\n        return ID3_Classifier","e56c0111":"activate = 2  # 1 for activation","187f6a5e":"if 1 == 1:\n    filenames_train,  filenames_test = np.load('..\/input\/deepfake-videos\/filenames_train.npy', allow_pickle=True), np.load('..\/input\/deepfake-videos\/filenames_test.npy', allow_pickle=True)\n    train_paths = create_paths ('..\/input\/deepfake-videos\/Train_Videos_Raw_JPG\/Train_Videos_Raw_JPG\/',filenames_train) #\n    test_paths = create_paths ('..\/input\/deepfake-videos\/Test_Videos_Raw_JPG\/Test_Videos_Raw_JPG\/',filenames_test) #\n    Labels_train,  Labels_test = np.load('..\/input\/deepfake-videos\/Labels_train.npy', allow_pickle=True), np.load('..\/input\/deepfake-videos\/Labels_test.npy', allow_pickle=True)\n    Labels_train, Labels_test = decode_labels (Labels_train), decode_labels (Labels_test)\n    train_paths,Labels_train = Balance_Data (train_paths,Labels_train)\n    from sklearn.preprocessing import OneHotEncoder\n    onehot_encoder = OneHotEncoder()\n    Labels_train_oh = onehot_encoder.fit_transform(Labels_train.reshape(-1,1)).toarray()#.astype(int)\n    Labels_test_oh = onehot_encoder.fit_transform(Labels_test.reshape(-1,1)).toarray()#.astype(int)\n\n\n\nif 1 == 1:\n    from random import shuffle\n    ind_list = [_r_ for _r_ in range(len(train_paths))]\n    shuffle(ind_list)\n    train_paths  = train_paths[ind_list]\n    Labels_train_oh  = Labels_train_oh[ind_list]\n    Labels_train  = Labels_train[ind_list]","b7d2d639":"if 1 == 1:\n\n    depth, width, heigth = 300, 160, 160 \n    train_g = Video_Generator_3D_CNN(mode='train_AE', batch_size=1, depth=depth, width=width, heigth=heigth, paths = train_paths, labels = Labels_train_oh, n_channels=3, shuffle=False)\n    val_g = Video_Generator_3D_CNN(mode='train_AE', batch_size=1,  depth=depth, width=width, heigth=heigth, paths = test_paths, labels = Labels_test_oh, n_channels=3, shuffle=False)#\n","5853686d":"            \ndef Build_AE3D_EE(depth, width, heigth):\n                    inputs = keras.Input((depth, width, heigth, 3)) # init 300,150,150\n\n                    x = layers.Conv3D(filters=16, kernel_size=(3,3,3), strides=(1,1,1), padding='same')(inputs)\n                    x = layers.LeakyReLU()(x)\n                    x = layers.MaxPool3D(pool_size=(3,2,2))(x)\n                    \n                    x = layers.Conv3D(filters=3, kernel_size=(3,3,3), strides=(4,2,2), padding='same')(x)\n                    x = layers.LeakyReLU()(x)\n            \n    \n    \n                    x = tf.keras.layers.Conv3DTranspose (filters=32, kernel_size=(3,3,3), strides=(4,2,2), padding='same')(x) \n                    x = layers.LeakyReLU()(x)\n                    x = tf.keras.layers.Conv3DTranspose (filters=16, kernel_size=(3,3,3), strides=(3,2,2), padding='same')(x) \n                    x = layers.LeakyReLU()(x)\n                    \n                    outputs =  layers.Conv3DTranspose(filters=3, kernel_size=(3,3,3), strides=(1,1,1), activation=\"sigmoid\", padding='same')(x)\n\n                    # Define the model.\n                    ae3d = keras.Model(inputs, outputs, name=\"ae_3D\")\n                    \n                    return ae3d\n\n","67abe454":"if 1 == activate:\n    CAE = Build_AE3D_EE(depth, width, heigth)\n    CAE.summary()","c0a95b6b":"#CAE = load_model('..\/input\/ddddddddd\/CAE_50.h5')","98b12957":"if 1 == activate:\n    lr = 0.001    # 0.001  0.0005   0.0001 0.00005\n    CAE, checkpoint_cb, early_stopping_cb = Compile_CNN (CAE, lr)\n\n            # Training  (Very Slow)\n    if 1==1:    \n                epochs = 5\n                CAE = Train_CNN(CAE, epochs, train_g, val_g, checkpoint_cb, early_stopping_cb)  ","c700f73d":"#CAE.save('CAE_25_40.h5')","5da0809b":"if 1 == activate:\n    depth, width, heigth = 300, 160, 160 \n    train_g = Video_Generator_3D_CNN(mode='train_C', batch_size=1, depth=depth, width=width, heigth=heigth, paths = train_paths, labels = Labels_train_oh, n_channels=3, shuffle=False)\n    val_g = Video_Generator_3D_CNN(mode='train_C', batch_size=1,  depth=depth, width=width, heigth=heigth, paths = test_paths, labels = Labels_test_oh, n_channels=3, shuffle=False)#\n","0a755415":"if 1 == activate:\n    layer =  CAE.layers [5]  # [3]\n    layer_name = layer.name\n    encoder_3d = Model(inputs=CAE.input, outputs=CAE.get_layer(layer_name).output)\n    encoder_3d.summary()","e09f37b2":"if 1 == activate:\n    for layer in encoder_3d.layers:\n                            layer.trainable = False\n    encoder_3d.summary()","5a4b1670":"if 1 == activate:\n    ID3 = Inception_Inflated3d(\n                            include_top=False,\n                            weights='rgb_imagenet_and_kinetics',  # rgb_kinetics_only  rgb_imagenet_and_kinetics   flow_imagenet_and_kinetics   None\n                            input_shape=(25, 160, 160, 3),\n                            classes=2)\n    model = Sequential()\n    model.add(encoder_3d)\n    model.add(ID3)\n    model.add(GlobalAveragePooling3D())\n            # FC Layer ___________\n    model.add(Dense(units=64, activation=\"relu\"))\n    model.add(Dropout(0.2))\n    model.add(layers.Dense(units=2, activation=\"sigmoid\"))\n\n    CAE3D_I3D = model\n    CAE3D_I3D.summary()","e6ca60fa":"if 1 == activate:\n    # CAE3D_I3D = load_model('')\n    lr = 0.0001\n    CAE3D_I3D, checkpoint_cb, early_stopping_cb = Compile_CNN (CAE3D_I3D, lr)\n\n            # Training  (Very Slow)\n    if 1==1:    \n                epochs = 3\n                CAE3D_I3D = Train_CNN(CAE3D_I3D, epochs, train_g, val_g, checkpoint_cb, early_stopping_cb)\n\n","6a1b13bf":"if 1 == activate:\n    layer =  CAE3D_I3D.layers [2]  # [3]\n    layer_name = layer.name\n    CAE_I3D_FE = Model(inputs=CAE3D_I3D.input, outputs=CAE3D_I3D.get_layer(layer_name).output)\n    CAE_I3D_FE.summary()","4a951caf":"if 1 == activate:\n    f_train = CAE_I3D_FE.predict(train_g)\n    f_test = CAE_I3D_FE.predict(val_g)","0bc25121":"if 1 == activate:\n    ML = LogisticRegression(C=4, max_iter=12).fit(f_train, Labels_train) # DecisionTreeClassifier(max_depth=5)SVC(C=1,kernel='rbf').fit(probs_CAE_CNN_tr, Labels_train) #\n    preds = ML.predict(f_test)\n    Evaluation(preds, Labels_test)","4a549bb9":"if 1 == activate:\n    CAE3D_I3D.save('CAE_25_I3D_E-E.h5')\n    CAE_I3D_FE.save('CAE_25_I3D_FE.h5')\n    np.save('CAE_25_I3D_Features_tr',f_train)\n    np.save('CAE_25_I3D_Features_ts',f_test)\n    np.save('Labels_train',Labels_train)\n    np.save('Labels_test',Labels_test)\n\n    # 150  C=100000, max_iter=50    30.4\n    # 100  C=1, max_iter=15         29.4\n    # 50   C=100, max_iter=21       29.4\n    # 25   C=4, max_iter=12         26.0","21e463ef":"CAE = load_model('..\/input\/ae3d-deepfake\/CAE_25_40.h5')\n\n\nlayer =  CAE.layers [5]  # [3]\nlayer_name = layer.name\n\u0395\u0395ncoder_3d = Model(inputs=CAE.input, outputs=CAE.get_layer(layer_name).output)\n\u0395\u0395ncoder_3d.summary()\n#encoder_3d.save('encoder_3d_Cascade.h5',encoder_3d)\n\n\ntrial = val_g[0][0]\nReconstructed = CAE.predict(trial)\nencoded = \u0395\u0395ncoder_3d.predict(trial)\nencoded = encoded [0]\nReconstructed = Reconstructed [0]\ntrial = trial [0]","cce10b38":"        en_video = trial\n        en_video.shape\n        fig=plt.figure(figsize=(12,12))\n        columns = 20#6\n        rows = 15#8\n        for i in range(1,  columns*rows+1):  # 48\n                    img = en_video[i-1,:,:,:] #en_video[:,:,i-1]\n                    fig.add_subplot(rows, columns, i)\n                    plt.axis('off')\n                    plt.imshow(img)\n        plt.show()","0cf55c37":"        en_video = encoded\n        en_video.shape\n        fig=plt.figure(figsize=(12,12))\n        columns = 5#6\n        rows = 5#8\n        for i in range(1,  columns*rows+1):  # 48\n                    img = en_video[i-1,:,:,:] #en_video[:,:,i-1]\n                    fig.add_subplot(rows, columns, i)\n                    plt.axis('off')\n                    plt.imshow(img)\n        plt.show()","e6e2f24f":"        en_video = Reconstructed\n        en_video.shape\n        fig=plt.figure(figsize=(12,12))\n        columns = 20#6\n        rows = 15#8\n        for i in range(1,  columns*rows+1):  # 48\n                    img = en_video[i-1,:,:,:] #en_video[:,:,i-1]\n                    fig.add_subplot(rows, columns, i)\n                    plt.axis('off')\n                    plt.imshow(img)\n        plt.show()","5b9f1ee9":"**RECONSTRUCTED**","2c29ff0a":"**DATA PATHS CREATION**","7132e876":"CAE-I3D Training","99b4d8a3":"**ENCODED\/COMPRESSED**","532b05d6":"**INITIAL**","9476aa2e":"CAE Training","dd4bc4e5":"**LIBRARIES and FUNCTIONS**","f8b02e18":"**MAIN PROGRAM**","bb789287":"CAE3D OUTPUT VIZUALIZATION"}}