{"cell_type":{"dc5ada58":"code","164c9be1":"code","ee056cec":"code","2c0afbb5":"code","fcece4d0":"code","5a5c2e92":"code","cb3f0008":"code","30c4a1dc":"code","80a92df1":"code","c0bfc466":"code","f8d8ccdb":"code","9395a3c0":"code","547b4e6d":"code","5dd9a861":"code","9e0503da":"code","87a9a9aa":"code","9cf99c9d":"code","9c0d3360":"code","fe0ee298":"code","7635bc69":"code","0b0975c6":"code","41b82cbd":"code","4c4ce1a9":"code","7d97e24e":"markdown","81d5ad80":"markdown","1f5d4c1b":"markdown","b662e7ea":"markdown","d8b40b3b":"markdown","b7aad1ee":"markdown","2a800c43":"markdown","9e57b961":"markdown","a0d048c0":"markdown","e4cdde20":"markdown","63449be7":"markdown","a4852e07":"markdown","dcbd6b19":"markdown","0e8097f6":"markdown","e6843877":"markdown","5b8d4404":"markdown","24a287f9":"markdown","9205b21f":"markdown"},"source":{"dc5ada58":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","164c9be1":"df1=pd.read_csv('..\/input\/tmdb-movie-metadata\/tmdb_5000_movies.csv')\ndf2=pd.read_csv('..\/input\/tmdb-movie-metadata\/tmdb_5000_credits.csv')\nprint(\"Importing the data sets and verifying the columns\")","ee056cec":"df1.head()","2c0afbb5":"df2.head()","fcece4d0":"#Adding 'cast' column to first data frame\ndf1['cast']=df2['cast']\ndf1['crew']=df2['crew']","5a5c2e92":"#Verifying added columns in data frame\ndf1.columns","cb3f0008":"features=['keywords','cast','crew','genres']","30c4a1dc":"# Parse the stringified features into their corresponding python objects\nfrom ast import literal_eval\n\nfor feature in features:\n    df1[feature] = df1[feature].apply(literal_eval)","80a92df1":"#Fetching director's name from the crew feature , if not listed then return NaN\ndef get_director(x):\n    for i in x:\n        if i['job'] == 'Director':\n            return i['name']\n    return np.nan\n\n#Return list top 3 elements or entire list , which ever is more\ndef get_list(x):\n    if isinstance(x,list):\n        names = [i['name'] for i in x]\n        #Check if more than 3 elements exist. If yes, return only first three. If no, return entire list.\n        if len(names) > 3:\n            names=names[:3]\n        return names\n    #Return empty list in case of missing\/malformed data\n    return []","c0bfc466":"#Apply get_director function to 'crew' feature\ndf1['director'] = df1['crew'].apply(get_director)\n#defining list of feature again to apply get_list function\nfeatures = ['cast', 'keywords', 'genres']\nfor feature in features:\n    df1[feature] = df1[feature].apply(get_list)","f8d8ccdb":"df1[['title','director','keywords','cast','genres']]","9395a3c0":"# Function to convert all strings to lower case and strip names of spaces\ndef clean_data(x):\n    if isinstance(x, list):\n        return [str.lower(i.replace(\" \", \"\")) for i in x]\n    else:\n        #Check if director exists. If not, return empty string\n        if isinstance(x, str):\n            return str.lower(x.replace(\" \", \"\"))\n        else:\n            return ''","547b4e6d":"#Apply clean_data function to our features\nfeatures = ['cast', 'keywords', 'genres','director']\n\nfor feature in features:\n    df1[feature]=df1[feature].apply(clean_data)\n","5dd9a861":"df1[['title','director','keywords','cast','genres']]","9e0503da":"def combine_features(x):\n    return ' '.join(x['keywords']) + ' ' + ' '.join(x['cast']) + ' ' + x['director'] + ' ' + ' '.join(x['genres'])\n\ndf1['combine_feature'] = df1.apply(combine_features,axis=1)","87a9a9aa":"df1[['title','combine_feature']]","9cf99c9d":"from sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nprint(\"Importing Sckit learn libraries for calculating Cosine Similarity\")","9c0d3360":"cv = CountVectorizer(stop_words='english') #creating new CountVectorizer() object\ncount_matrix = cv.fit_transform(df1[\"combine_feature\"]) #feeding combined strings(movie contents) to CountVectorizer() object\ncosine_sim = cosine_similarity(count_matrix,count_matrix)","fe0ee298":"# Reset index of our main DataFrame\ndf1 = df1.reset_index()\nindices = pd.Series(df1.index, index=df1['title'])","7635bc69":"# Function that takes in movie title as input and outputs most similar movies\ndef get_recommendations(title, cosine_sim=cosine_sim):\n    # Get the index of the movie that matches the title\n    idx = indices[title]\n\n    # Get the pairwsie similarity scores of all movies with that movie\n    sim_scores = list(enumerate(cosine_sim[idx]))\n\n    # Sort the movies based on the similarity scores\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n    # Get the scores of the 10 most similar movies\n    sim_scores = sim_scores[1:11]\n\n    # Get the movie indices\n    movie_indices = [i[0] for i in sim_scores]\n\n    # Return the top 10 most similar movies\n    return df1['title'].iloc[movie_indices]","0b0975c6":"get_recommendations('The Dark Knight Rises', cosine_sim)","41b82cbd":"get_recommendations('Avatar', cosine_sim)","4c4ce1a9":"get_recommendations('The Godfather', cosine_sim)","7d97e24e":"\nNow that we have obtained the combined feature\/string, we can now feed these strings to a CountVectorizer() object for getting the count matrix and getting Cosine Similarity.\n\nBefore going further let's understand the concept behind cosine similarity and how it is related to Content Based Recommendation Engine.\n\nIn this type of recommendation engine we need to find similar movies to a given movie and then recommend those similar movies to the user. The logic is pretty straightforward but the bigger question is how can we find out which movies are similar to the given movie in the first place? How can we find out how much similar(or dissimilar) two movies are?\n\nLet us start with something simple and easy to understand. \n\nSuppose, you are given the following two texts:\n\nText A: London Paris London\n\nText B: Paris Paris London\n\nHow would you find the similarity between Text A and Text B?\n\nLet\u2019s analyze these texts\u2026.\n\nText A: Contains the word \u201cLondon\u201d 2 times and the word \u201cParis\u201d 1 time.\nText B: Contains the word \u201cLondon\u201d 1 time and the word \u201cParis\u201d 2 times.\nNow, what will happen if we try to represent these two texts in a 2D plane (with \u201cLondon\u201d in X axis and \u201cParis\u201d in Y axis)? Let\u2019s try to do this.\n\nIt will look like this-\n\n![image.png](attachment:image.png)\n\nHere, the red vector represents \u201cText A\u201d and the blue vector represents \u201cText B\u201d.\n\nNow we have graphically represented these two texts in another words we can say that these two texts are represented as vectors.So, we can say that two vectors are similar if the distance between them is small. By distance, we mean the angular distance between two vectors, which is represented by \u03b8 (theta). By thinking further from the machine learning perspective, we can understand that the value of cos \u03b8 makes more sense to us rather than the value of \u03b8 (theta) because, the cosine(or \u201ccos\u201d) function will map the value of \u03b8 in the first quadrant between 0 to 1 (Remember? cos 90\u00b0 = 0 and cos 0\u00b0 = 1 ).\n\nAnd from high school maths, we can remember that there is actually a formula for finding out cos \u03b8 between two vectors. \n\n![image.png](attachment:image.png)\n","81d5ad80":"Acording to [wikipedia](https:\/\/en.wikipedia.org\/wiki\/Recommender_system#:~:text=A%20recommender%20system%2C%20or%20a,would%20give%20to%20an%20item.) : A  recommendation system , is a subclass of information filtering system that seeks to predict the \"rating\" or \"preference\" a user would give to an item.They are primarily used in commercial applications.\n\nRecommendation systems are utilized in a variety of areas and are most commonly recognized as playlist generators for video and music services like Netflix, YouTube and Spotify, product recommenders for services such as Amazon, or content recommenders for social media platforms such as Facebook and Twitter.These systems can operate using a single input, like music, or multiple inputs within and across platforms like news, books, and search queries. There are also popular recommender systems for specific topics like restaurants and online dating. Recommender systems have also been developed to explore research articles and experts,collaborators,and financial services\n\nThere are basically three types of recommender systems:\n\n* Content based recommendation engine\n* Popularity based recommendation engine or Demographic Filtering\n* Collaborative filtering based recommendation engine\n\nLet's understand the differences between different recommendation engines\n\n**Content based recommendation engine:**\nThis type of recommendation systems, takes in a movie that a user currently likes as input. Then it analyzes the contents (storyline, genre, cast, director etc.) of the movie to find out other movies which have similar content. Then it ranks similar movies according to their similarity scores and recommends the most relevant movies to the user\n\n**Popularity based recommendation engine:**\nThis is the simplest kind of recommendation engine that you will come across. The trending list you see in YouTube or Netflix is based on this algorithm. It keeps a track of view counts for each movie\/video and then lists movies based on views in descending order(highest view count to lowest view count).\nThey offer generalized recommendations to every user, based on movie popularity and\/or genre. The System recommends the same movies to users with similar demographic features. Since each user is different , this approach is considered to be too simple. The basic idea behind this system is that movies that are more popular and critically acclaimed will have a higher probability of being liked by the average audience\n\n**Collaborative filtering based recommendation engine:**\nThis algorithm at first tries to find similar users based on their activities and preferences (for example, both the users watch same type of movies or movies directed by the same director). Now, between these users(say, A and B) if user A has seen a movie that user B has not seen yet, then that movie gets recommended to user B and vice-versa. In other words, the recommendations get filtered based on the collaboration between similar user\u2019s preferences (thus, the name \u201cCollaborative Filtering\u201d). One typical application of this algorithm can be seen in the Amazon e-commerce platform, where you get to see the \u201cCustomers who viewed this item also viewed\u201d and \u201cCustomers who bought this item also bought\u201d list.\n\nWe will start with **Contet Based Recommendation Engine**","1f5d4c1b":"# What is Recommendation Systems ?","b662e7ea":"Now , we will create a funciton to fetch Director's name  and top 3 elements present in name atribute from 'Cast' , 'Keyword' and 'Genres' columns for each movie","d8b40b3b":"We will write get_recommendation function to get recommended movie . This recomendation function will perform following actions\n\n* Get the index of the movie given its title.\n* Get the list of cosine similarity scores for that particular movie with all movies. Convert it into a list of tuples where the first element is its position and the second is the similarity score.\n* Sort the aforementioned list of tuples based on the similarity scores; that is, the second element.\n* Get the top 10 elements of this list. Ignore the first element as it refers to self (the movie most similar to a particular movie is the movie itself).\n* Return the titles corresponding to the indices of the top elements.","b7aad1ee":"# Data Extraction and Cleansing","2a800c43":"The next step would be to convert the names and keyword instances into lowercase and strip all the spaces between them. \n\nThis is required so that our vectorizer doesn't count the Johnny of \"Johnny Depp\" and \"Johnny Galecki\" as the same.","9e57b961":"# Resources\n\n* https:\/\/www.kaggle.com\/ibtesama\/getting-started-with-a-movie-recommendation-system\n* https:\/\/github.com\/codeheroku\/Introduction-to-Machine-Learning\/tree\/master\/Building%20a%20Movie%20Recommendation%20Engine\n","a0d048c0":"Verifying columns and top five records from both data sets","e4cdde20":"Verifying the clean up data","63449be7":"Now , we are done with all coding  let's call recommendation engine fucntion to get similar movies","a4852e07":"For cotent based recommendation engine we need to get metadata about a movie , which we can get from 'keywords' , 'cast' ,'crew' and 'genres' columns.\n\nLet's pull out these columns as 'features'","dcbd6b19":"For further analysis let's add 'cast' and 'crew' columns from second to first data frame","0e8097f6":"We can see that our recommender has been successful recommendending similar movies , it can be further improved by adding multiple features in movie metadata","e6843877":"These columns consist of following attributes and not all attributes are required for creating metadata \n\n**Keywords** : \n1. id\n2. name\n\n**Cast** :\n1. cast_id\n2. character\n3. credit_id\n4. gender\n5. id\n6. name\n7. order\n\n**Crews** :\n1. credit_id\n2. department\n3. gender\n4. id\n5. job\n6. name\n \n**Genres** :\n1. id\n2. name\n\nWe can drop all numerical\/identifer attributes from all four columns. \nIn 'Crew' we can only keep name of **'Director'** from 'department' attribute.Similarly , in 'Cast' ,'keywords' and 'Genres' we can only keep **'name'** attribute","5b8d4404":"# Building the Recommendation Engine","24a287f9":"We can create combine features function now , which will be a string that contains all metadata(Keywords,Cast,Director and Genres) about movie that we want to feed our vectorizer","9205b21f":"Appyling this function to each row of data set and displaying the data frame"}}