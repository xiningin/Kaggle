{"cell_type":{"5ae79807":"code","d987f7d5":"code","b0e3113e":"code","600adcb2":"code","f19b20dd":"code","69f5f7d7":"code","a83d0dca":"code","58b05320":"code","754b4c30":"code","dacfd69c":"code","ec30c70a":"code","7afe2727":"code","f14cc6c3":"code","33c26d12":"code","f41b452e":"code","016d1e77":"code","637cc4e1":"code","793eb674":"code","5737f566":"markdown","9312a01b":"markdown","e7b3587d":"markdown","36e45272":"markdown","ed90331e":"markdown","5684327b":"markdown","a9b1c2f3":"markdown","1684c14e":"markdown","37520b91":"markdown","3c0126de":"markdown","0fda9f63":"markdown","05e77c01":"markdown"},"source":{"5ae79807":"!pip install --upgrade kneed","d987f7d5":"import numpy as np\nimport numpy.matlib\nimport matplotlib.pyplot as plt\n\nfrom collections import Counter\nfrom sklearn.datasets import make_blobs\nfrom sklearn.cluster import KMeans\n\nfrom yellowbrick.cluster import distortion_score","b0e3113e":"# pip install kneed or conda install kneed\nfrom kneed import KneeLocator, DataGenerator","600adcb2":"x, y = DataGenerator.figure2()\n\nprint([round(i, 3) for i in x])\nprint([round(i, 3) for i in y])","f19b20dd":"kneedle = KneeLocator(x, y, S=1.0, curve='concave', direction='increasing')\n\nprint(round(kneedle.knee, 3))\nprint(round(kneedle.elbow, 3))","69f5f7d7":"# Normalized data, normalized knee, and normalized distance curve.\nplt.style.use('ggplot')\nkneedle.plot_knee_normalized()","a83d0dca":"# Raw data and knee\nkneedle.plot_knee()","58b05320":"ng_knees = []\nn_simulations = 100\n\nfor _ in range(n_simulations):\n    x, y = DataGenerator.noisy_gaussian(mu=50, sigma=10, N=1000)\n    kl = KneeLocator(x, y, direction='increasing', curve='concave', S=1.0, interp_method='polynomial', online=True)\n    ng_knees.append(kl.knee)","754b4c30":"np.mean(ng_knees)","dacfd69c":"kl.plot_knee_normalized()","ec30c70a":"kl.plot_knee()","7afe2727":"np.random.seed(23)","f14cc6c3":"# Loop over these S values to identify knees after S number of flat points.\nsensitivity = [1, 3, 5, 10, 100, 200, 400]\n\n# hold knee points for each sensitivity\nknees = []\nnorm_knees = []\n\n# S should be chosen as a function of how many points are in the system (n)\nn = 1000\nx = range(1, n + 1)\ny = sorted(np.random.gamma(0.5, 1.0, n), reverse=True)\nfor s in sensitivity:\n    kl = KneeLocator(x, y, curve='convex', direction='decreasing', S=s)\n    knees.append(kl.knee)\n    norm_knees.append(kl.norm_knee)\n\nprint(f'Knees: {knees}')\n\nprint(f'Normalized Knees: {[nk.round(2) for nk in norm_knees]}')","33c26d12":"plt.style.use('ggplot');\nplt.figure(figsize=(8, 6));\nplt.plot(kl.x_normalized, kl.y_normalized);\nplt.plot(kl.x_difference, kl.y_difference);\ncolors = ['r', 'g', 'k', 'm', 'c', 'orange']\nfor k, c, s in zip(norm_knees, colors, sensitivity):\n    plt.vlines(k, 0, 1, linestyles='--', colors=c, label=f'S = {s}');\nplt.legend();","f41b452e":"kl_online = KneeLocator(x, y, curve='convex', direction='decreasing', online=True)\nkl_offline = KneeLocator(x, y, curve='convex', direction='decreasing', online=False)\n\nplt.figure(figsize=(8, 6));\nplt.plot(kl_online.x_normalized, kl_online.y_normalized);\nplt.plot(kl_online.x_difference, kl_online.y_difference);\ncolors = ['r', 'g']\nfor k, c, o in zip([kl_online.norm_knee, kl_offline.norm_knee], ['r', 'g'], ['online', 'offline']):\n    plt.vlines(k, 0, 1, linestyles='--', colors=c, label=o);\nplt.legend();","016d1e77":"x = list(range(90))\ny = [\n    7304, 6978, 6666, 6463, 6326, 6048, 6032, 5762, 5742,\n    5398, 5256, 5226, 5001, 4941, 4854, 4734, 4558, 4491,\n    4411, 4333, 4234, 4139, 4056, 4022, 3867, 3808, 3745,\n    3692, 3645, 3618, 3574, 3504, 3452, 3401, 3382, 3340,\n    3301, 3247, 3190, 3179, 3154, 3089, 3045, 2988, 2993,\n    2941, 2875, 2866, 2834, 2785, 2759, 2763, 2720, 2660,\n    2690, 2635, 2632, 2574, 2555, 2545, 2513, 2491, 2496,\n    2466, 2442, 2420, 2381, 2388, 2340, 2335, 2318, 2319,\n    2308, 2262, 2235, 2259, 2221, 2202, 2184, 2170, 2160,\n    2127, 2134, 2101, 2101, 2066, 2074, 2063, 2048, 2031\n]\n\n# the default spline fit, `interp_method='interp1d'`\nkneedle = KneeLocator(x, y, S=1.0, curve='convex', direction='decreasing', interp_method='interp1d')\nkneedle.plot_knee_normalized()","637cc4e1":"# The same data, only using a polynomial fit this time.\nkneedle = KneeLocator(x, y, S=1.0, curve='convex', direction='decreasing', interp_method='polynomial')\nkneedle.plot_knee_normalized()","793eb674":"found_knees = []\n# number of simulations to run\nfor _ in range(100):\n    \n    # Create synthetic dataset with 8 random clusters\n    X, y = make_blobs(centers=8, n_features=12, shuffle=True)\n\n    distortion_scores = []\n    for k in range(4, 13):\n        model = KMeans(n_clusters=k)\n        model.fit_transform(X)\n        distortion_scores.append(distortion_score(X, model.labels_))\n        \n    # Find the knee point in the curve.\n    kl = KneeLocator(x=range(4, 13), \n                     y=distortion_scores, \n                     curve='convex', \n                     direction='decreasing', \n                     S=1\n                    )\n    found_knees.append(kl.knee)\n    \nprint(Counter(found_knees))","5737f566":"# Applications where finding a knee point is useful","9312a01b":"# Visualize","e7b3587d":"# Sensitivity Parameter\nThe knee point selected is tunable by setting the sensitivity parameter **S**. From the manuscript:\n\n>The sensitivity parameter allows us to adjust how aggressive we want Kneedle to be when detecting knees. Smaller values for S detect knees quicker, while larger values are more conservative. Put simply, S is a measure of how many \u201cflat\u201d points we expect to see in the unmodified data curve before declaring a knee.","36e45272":"Notice in this graph any `S` greater than ~200 will all result in the same knee point.","ed90331e":"# Introduction\nThis kernel explores the implementation of a published algorithm for finding the knee (or elbow) point of a curve. The knee point is loosely defined as the point of maximum curvature in a system. Identifying this location can be useful in many instances, but in machine learning it can be used for assiting with selection of an appropriate value of `k` in K-means clustering. I created a Python package, [kneed](https:\/\/github.com\/arvkevi\/kneed), that can be used to detect the knee or elbow point by attempting an implmentation of the [Kneedle algorithm](https:\/\/www1.icsi.berkeley.edu\/~barath\/papers\/kneedle-simplex11.pdf). I thought the Kaggle community might find the package useful and who better to hear feedback on the implementation than from data scientists.\n![](https:\/\/raw.githubusercontent.com\/arvkevi\/kneed\/master\/images\/functions_args_summary.png)\n\n# Table of Contents\n1. [Usage](#Usage)\n2. [Visualize](#Visualize)  \n3. [Evaluate](#Evaluate)  \n4. [Sensitivity Parameter](#Sensitivity-Parameter)  \n5. [Polynomial Fit](#Polynomial-fit)\n6. [Applications](## Applications where finding a knee point is useful)\n    1. [Select k clusters for KMeans](#Select-k-clusters-for-KMeans)","5684327b":"The knee (or elbow) point is calculated simply by instantiating the KneeLocator class with `x`, `y` and the appropriate `curve` and `direction`.\nHere, `kneedle.knee` and\/or `kneedle.elbow` store the point of maximum curvature. ","a9b1c2f3":"# Usage\n\nRecreating Figure 2 from the kneedle manuscript is a good place to start learning the `kneed` API. At the minimum `kneed` requires equal length `x` and `y` input arrays. There are a few methods to help generate datasets in the `DataGenerator` class.","1684c14e":"# Evaluate\nThe `noisy_gaussian` method, developed by the authors of the manuscript, has a closed-form solution which represents the \"correct\" knee: $x\\approx\\mu + \\sigma$  \n\nTherefore, we can evaluate the `Kneedle` algorithm by simulating `x` and `y` from a `NoisyGaussian` distribution.\nHere, $\\mu=50$ and $\\sigma=10$ meaning, the `knee` should be detected at approximately `60.0`. Compare the mean `knee` found from `n` simulations -- it should be close to `60.0`.","37520b91":"## Online vs Offline Detection\nThe knee point can be corrected if the parameter `online` is `True` (default). This mode will step through each element in `x`. In contrast, if `online` is `False`, kneed will run in offline mode and return the first knee point identified.\n\nUsing the `x` and `y` from the Sensitivity example above, this time, let's keep `S=1` but modify `online`.","3c0126de":"# Polynomial Fit\nHere is an example of a \"bumpy\" or \"noisy\" line where the default `scipy.interpolate.interp1d` spline fitting method does not provide the best estimate for the point of maximum curvature.\nThis example demonstrates that setting the parameter `interp_method='polynomial'` will choose a more accurate point by smoothing the line.  \nThe argument for `interp_method` parameter is a string of either `'interp1d'` or `'polynomial'`.","0fda9f63":"# Select k clusters for KMeans\nOne of the most relevant use cases for `kneed` is to help select `k` in K-means clustering. Using this [example from yellowbrick](https:\/\/www.scikit-yb.org\/en\/latest\/api\/cluster\/elbow.html#) documentation, we can take it a bit further and simulate 100 (or more) synthetic datasets with `make_blobs`.","05e77c01":"Thank you for reading the kernel. All comments are welcome, but feedback is especially encouraged if you have suggestions to improve the algorithm implemnation or for alternative methods to benchmark. If you are interested in learning more, the [GitHub repo's](https:\/\/github.com\/arvkevi\/kneed) README documents many features and there are more details in the [notebooks](https:\/\/github.com\/arvkevi\/kneed\/tree\/master\/notebooks)."}}