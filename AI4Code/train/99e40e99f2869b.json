{"cell_type":{"495883d7":"code","04259486":"code","d34821e6":"code","38d2a657":"code","f98d4058":"code","9e398cf3":"code","505c2545":"code","a0cfac84":"markdown","c6db7ca3":"markdown","50389f1d":"markdown","ed9442fd":"markdown","a5f970b4":"markdown"},"source":{"495883d7":"%%writefile submission.py","04259486":"%%writefile submission.py\n#!\/usr\/bin\/env python3\n\n##### \n##### ..\/..\/kaggle_compile.py agents\/MontyCarlo\/MontyCarloPure.py\n##### \n##### 2020-08-26 16:45:21+01:00\n##### \n##### origin\tgit@github.com:JamesMcGuigan\/ai-games.git (fetch)\n##### origin\tgit@github.com:JamesMcGuigan\/ai-games.git (push)\n##### \n##### * master 247327a [ahead 6] ConnectX | reduce safety_time to 0.25s\n##### \n##### 247327afa97dfaa0c87ea36321e7be3deaa9d8d4\n##### \n\n#####\n##### START core\/ConnectXBBNN.py\n#####\n\n# This is a functional implementation of ConnectX that has been optimized using both numpy and numba\n\nfrom collections import namedtuple\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\n\nimport numba\nimport numpy as np\n\n# Hardcode for simplicity\n# observation   = {'mark': 1, 'board': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}\n# configuration = {'columns': 7, 'rows': 6, 'inarow': 4, 'steps': 1000, 'timeout': 8}\n\nbitboard_type = numba.typeof(np.ndarray((2,), dtype=np.int64))\nConfiguration = namedtuple('configuration', ['rows', 'columns', 'inarow'])\nconfiguration = Configuration(\n    rows=6,\n    columns=7,\n    inarow=4\n)\n\n\n\n### Conversions\n\ndef cast_configuration(configuration):\n    return Configuration(\n        rows    = configuration.rows,\n        columns = configuration.columns,\n        inarow  = configuration.inarow\n    )\n\n\ndef is_bitboard(bitboard) -> bool:\n    if isinstance(bitboard, np.ndarray) and bitboard.dtype == np.int64 and bitboard.shape == (2,):\n        return True\n    else:\n        return False\n\n#@njit\ndef list_to_bitboard(listboard: Union[np.ndarray,List[int]]) -> np.ndarray:\n    # bitboard[0] = played, is a square filled             | 0 = empty, 1 = filled\n    # bitboard[1] = player, who's token is this, if filled | 0 = empty, 1 = filled\n    bitboard_played = 0  # 42 bit number for if board square has been played\n    bitboard_player = 0  # 42 bit number for player 0=p1 1=p2\n    if isinstance(listboard, np.ndarray): listboard = listboard.flatten()\n    for n in range(len(listboard)):  # prange\n        if listboard[n] != 0:\n            bitboard_played |= (1 << n)        # is a square filled (0 = empty | 1 = filled)\n            if listboard[n] == 2:\n                bitboard_player |= (1 << n)    # mark as player 2 square, else assume p1=0 as default\n    bitboard = np.array([bitboard_played, bitboard_player], dtype=np.int64)\n    return bitboard\n\n\n#@njit(int8[:,:](int64[:]))\ndef bitboard_to_numpy2d(bitboard: np.ndarray) -> np.ndarray:\n    global configuration\n    rows    = configuration.rows\n    columns = configuration.columns\n    size    = rows * columns\n    output  = np.zeros((size,), dtype=np.int8)\n    for i in range(size):  # prange\n        is_played = (bitboard[0] >> i) & 1\n        if is_played:\n            player = (bitboard[1] >> i) & 1\n            output[i] = 1 if player == 0 else 2\n    return output.reshape((rows, columns))\n\n\n### Bitboard Operations\n\n#@njit\ndef empty_bitboard() -> np.ndarray:\n    return np.array([0, 0], dtype=np.int64)\n\n\ndef bitboard_from_actions(actions: List[Union[int, Tuple[int]]]) -> np.ndarray:\n    bitboard  = empty_bitboard()\n    player_id = 1\n    for action in actions:\n        if isinstance(action, tuple): action, player_id = action\n        bitboard  = result_action(bitboard, action, player_id=player_id % 2)\n        player_id = next_player_id(player_id)\n    return bitboard\n\n\n#@njit\ndef hash_bitboard( bitboard: np.ndarray ) -> Tuple[int,int]:\n    \"\"\" Create a tupleised mirror hash, the minimum value of the bitboard and its mirrored reverse \"\"\"\n    if bitboard[0] == 0:\n        return ( bitboard[0], bitboard[1] )\n\n    global configuration\n    mirror_0 = mirror_bitstring(bitboard[0])\n    if bitboard[0] < mirror_0:\n        return ( bitboard[0], bitboard[1] )\n    else:\n        mirror_1 = mirror_bitstring(bitboard[1])\n        if bitboard[0] == mirror_0 and bitboard[1] <= mirror_1:\n            return ( bitboard[0], bitboard[1] )\n        else:\n            return ( mirror_0, mirror_1 )\n\n\n# Use string reverse to create mirror bit lookup table: mirror_bits[ 0100000 ] == 0000010\nmirror_bits = np.array([\n    int( \"\".join(reversed(f'{n:07b}')), 2 )\n    for n in range(2**configuration.columns)\n], dtype=np.int64)\n\n#@njit\ndef mirror_bitstring( bitstring: int ) -> int:\n    \"\"\" Return the mirror view of the board for hashing:  0100000 -> 0000010 \"\"\"\n    global configuration\n\n    if bitstring == 0:\n        return 0  # short-circuit for empty board\n\n    bitsize     = configuration.columns * configuration.rows        # total number of bits to process\n    unit_size   = configuration.columns                             # size of each row in bits\n    unit_mask   = (1 << unit_size) - 1                              # == 0b1111111 | 0x7f\n    offsets     = np.arange(0, bitsize, unit_size, dtype=np.int64)  # == [ 0, 7, 14, 21, 28, 35 ]\n\n    # row_masks   = unit_mask               << offsets  # create bitmasks for each row\n    # bits        = (bitstring & row_masks) >> offsets  # extract out the bits for each row\n    # stib        = mirror_bits[ bits ]     << offsets  # lookup mirror bits for each row and shift back into position\n    # output      = np.sum(stib)                        # np.sum() will bitwise AND the array assuming no overlapping bits\n\n    # This can technically be done as a one liner:\n    output = np.sum( mirror_bits[ (bitstring & (unit_mask << offsets)) >> offsets ] << offsets )\n\n    ### Old Loop Implementation\n    # output = 0\n    # for row in range(configuration.rows):\n    #     offset = row * configuration.columns\n    #     mask   = unit_mask          << offset\n    #     bits   = (bitstring & mask) >> offset\n    #     if bits == 0: continue\n    #     stib   = mirror_bits[ bits ]\n    #     output = output | (stib << offset)\n\n    return int(output)\n\n\n#@njit\ndef mirror_bitboard( bitboard: np.ndarray ) -> np.ndarray:\n    return np.array([\n        mirror_bitstring(bitboard[0]),\n        mirror_bitstring(bitboard[1]),\n    ], dtype=bitboard.dtype)\n\n\n\n### Player Id\n\n#@njit\ndef current_player_id( bitboard: np.ndarray ) -> int:\n    \"\"\" Returns next player to move: 1 = p1, 2 = p2 \"\"\"\n    move_number = get_move_number(bitboard)\n    next_player = 1 if move_number % 2 == 0 else 2  # player 1 has the first move on an empty board\n    return next_player\n\ndef current_player_index( bitboard: np.ndarray ) -> int:\n    \"\"\" Returns next player to move: 0 = p1, 1 = p2 \"\"\"\n    move_number = get_move_number(bitboard)\n    next_player = 0 if move_number % 2 == 0 else 1  # player 1 has the first move on an empty board\n    return next_player\n\n\n#@njit(int8(int8))\ndef next_player_id(player_id: int) -> int:\n    # assert player_id in [1,2]\n    return 1 if player_id == 2 else 2\n\n\n\n### Coordinates\n\n#@njit\ndef index_to_coords(index: int) -> Tuple[int,int]:\n    global configuration\n    row    = index \/\/ configuration.columns\n    column = index - row * configuration.columns\n    return (row, column)\n\n\n#@njit\ndef coords_to_index(row: int, column: int) -> int:\n    global configuration\n    return column + row * configuration.columns\n\n\n\n### Moves\n\n#@njit(int64[:](int8))\ndef get_bitcount_mask(size: int = configuration.columns * configuration.rows) -> np.ndarray:\n    # return np.array([1 << index for index in range(0, size)], dtype=np.int64)\n    return 1 << np.arange(0, size, dtype=np.int64)\n\nbitcount_mask = get_bitcount_mask()\n\n\n#@njit(int8(int64[:]))\ndef get_move_number(bitboard: np.ndarray) -> int:\n    global configuration\n    if bitboard[0] == 0: return 0\n    size          = configuration.columns * configuration.rows\n    mask_bitcount = get_bitcount_mask(size)\n    move_number   = np.count_nonzero(bitboard[0] & mask_bitcount)\n    return move_number\n\n\nmask_board       = (1 << configuration.columns * configuration.rows) - 1\nmask_legal_moves = (1 << configuration.columns) - 1\n\n#@njit\ndef has_no_illegal_moves( bitboard: np.ndarray ) -> int:\n    \"\"\"If any the squares on the top row have been played, then there are illegal moves\"\"\"\n    are_all_moves_legal = ((bitboard[0] & mask_legal_moves) == 0)\n    return 1 if are_all_moves_legal else 0\n\n\n#@njit\ndef has_no_more_moves(bitboard: np.ndarray) -> bool:\n    \"\"\"If all the squares on the top row have been played, then there are no more moves\"\"\"\n    return bitboard[0] & mask_legal_moves == mask_legal_moves\n\n\n_is_legal_move_mask  = ((1 << configuration.columns) - 1)\n_is_legal_move_cache = np.array([\n    [\n        int( (bits >> action) & 1 == 0 )\n        for action in range(configuration.columns)\n    ]\n    for bits in range(2**configuration.columns)\n], dtype=np.int8)\n\n#@njit\ndef is_legal_move(bitboard: np.ndarray, action: int) -> int:\n    bits = bitboard[0] & _is_legal_move_mask   # faster than: int( (bitboard[0] >> action) & 1 == 0 )\n    return _is_legal_move_cache[bits, action]  # NOTE: [bits,action] is faster than [bits][action]\n\n#@njit\ndef get_legal_moves(bitboard: np.ndarray) -> np.ndarray:\n    # First 7 bytes represent the top row. Moves are legal if the sky is unplayed\n    global configuration\n    bits = bitboard[0] & _is_legal_move_mask  # faster than: int( (bitboard[0] >> action) & 1 == 0 )\n    if bits == 0:\n        return actions  # get_all_moves()\n    else:\n        return np.array([\n            action\n            for action in range(configuration.columns)\n            if _is_legal_move_cache[bits, action]\n        ], dtype=np.int8)\n\n\nactions = np.array([ action for action in range(configuration.columns) ], dtype=np.int64)\n#@njit\ndef get_all_moves() -> np.ndarray:\n    # First 7 bytes represent the top row. Moves are legal if the sky is unplayed\n    return actions\n    # global configuration\n    # return np.array([ action for action in range(configuration.columns) ])\n\n\n#@njit\ndef get_random_move(bitboard: np.ndarray) -> int:\n    \"\"\" This is slightly quicker than random.choice(get_all_moves())\"\"\"\n    # assert not has_no_more_moves(bitboard)\n\n    global configuration\n    while True:\n        action = np.random.randint(0, configuration.columns)\n        if is_legal_move(bitboard, action):\n            return action\n\n\n\n# Actions + Results\n\n#@njit\ndef get_next_index(bitboard: np.ndarray, action: int) -> int:\n    global configuration\n    # assert is_legal_move(bitboard, action)\n\n    # Start at the ground, and return first row that contains a 0\n    for row in range(configuration.rows-1, -1, -1):\n        index = action + (row * configuration.columns)\n        value = (bitboard[0] >> index) & 1\n        if value == 0:\n            return index\n    return action  # this should never happen - implies not is_legal_move(action)\n\n#@njit\ndef get_next_row(bitboard: np.ndarray, action: int) -> int:\n    global configuration\n    index = get_next_index(bitboard, action)\n    row   = index \/\/ configuration.columns\n    return row\n\n\n#@njit\ndef result_action(bitboard: np.ndarray, action: int, player_id: int) -> np.ndarray:\n    # assert is_legal_move(bitboard, action)\n    index    = get_next_index(bitboard, action)\n    mark     = 0 if player_id == 1 else 1\n    output = np.array([\n        bitboard[0] | 1    << index,\n        bitboard[1] | mark << index\n    ], dtype=bitboard.dtype)\n    return output\n\n\n### Simulations\n\n#@njit\ndef run_random_simulation( bitboard: np.ndarray, player_id: int ) -> float:\n    \"\"\" Returns +1 = victory | 0.5 = draw | 0 = loss \"\"\"\n    move_number = get_move_number(bitboard)\n    next_player = 1 if move_number % 2 == 0 else 2  # player 1 has the first move on an empty board\n    while not is_gameover(bitboard):\n        actions     = get_legal_moves(bitboard)\n        action      = np.random.choice(actions)\n        bitboard    = result_action(bitboard, action, next_player)\n        next_player = next_player_id(next_player)\n        # print( bitboard_to_numpy2d(bitboard) )  # DEBUG\n    score = get_utility_zero_one(bitboard, player_id)\n    return score\n\n\n### Endgame\n\n#@njit(int64[:]())\ndef get_gameovers() -> np.ndarray:\n    \"\"\"Creates a list of all winning board positions, over 4 directions: horizontal, vertical and 2 diagonals\"\"\"\n    global configuration\n\n    rows    = configuration.rows\n    columns = configuration.columns\n    inarow  = configuration.inarow\n\n    gameovers = []\n\n    mask_horizontal  = 0\n    mask_vertical    = 0\n    mask_diagonal_dl = 0\n    mask_diagonal_ul = 0\n    for n in range(inarow):  # prange\n        mask_horizontal  |= 1 << n\n        mask_vertical    |= 1 << n * columns\n        mask_diagonal_dl |= 1 << n * columns + n\n        mask_diagonal_ul |= 1 << n * columns + (inarow - 1 - n)\n\n    row_inner = rows    - inarow\n    col_inner = columns - inarow\n    for row in range(rows):  # prange\n        for col in range(columns):  # prange\n            offset = col + row * columns\n            if col <= col_inner:\n                gameovers.append( mask_horizontal << offset )\n            if row <= row_inner:\n                gameovers.append( mask_vertical << offset )\n            if col <= col_inner and row <= row_inner:\n                gameovers.append( mask_diagonal_dl << offset )\n                gameovers.append( mask_diagonal_ul << offset )\n\n    _get_gameovers_cache = np.array(gameovers, dtype=np.int64)\n    return _get_gameovers_cache\n\ngameovers = get_gameovers()\n\n\n#@njit\ndef is_gameover(bitboard: np.ndarray) -> bool:\n    if has_no_more_moves(bitboard):  return True\n    if get_winner(bitboard) != 0:    return True\n    return False\n\n\n#@njit\ndef get_winner(bitboard: np.ndarray) -> int:\n    \"\"\" Endgame get_winner: 0 for no get_winner, 1 = player 1, 2 = player 2\"\"\"\n    global gameovers\n    # gameovers = get_gameovers()\n    p2_wins = (bitboard[0] &  bitboard[1]) & gameovers == gameovers\n    if np.any(p2_wins): return 2\n    p1_wins = (bitboard[0] & ~bitboard[1]) & gameovers == gameovers\n    if np.any(p1_wins): return 1\n    return 0\n\n    # NOTE: above implementation is 2x faster than this original attempt\n    # gameovers_played = gameovers[ gameovers & bitboard[0] == gameovers ]  # exclude any unplayed squares\n    # if np.any(gameovers_played):                                          # have 4 tokens been played in a row yet\n    #     p1_wins = gameovers_played & ~bitboard[1] == gameovers_played\n    #     if np.any(p1_wins): return 1\n    #     p2_wins = gameovers_played &  bitboard[1] == gameovers_played\n    #     if np.any(p2_wins): return 2\n    # return 0\n\n\n### Utility Scores\n\n#@njit\ndef get_utility_one(bitboard: np.ndarray, player_id: int) -> int:\n    \"\"\" Like get_utility_inf but returns: 1 for victory, -1 for loss, 0 for draw \"\"\"\n    winning_player = get_winner(bitboard)\n    if winning_player == 0: return 0\n    return 1 if winning_player == player_id else -1\n\n\n#@njit\ndef get_utility_zero_one(bitboard: np.ndarray, player_id: int) -> float:\n    \"\"\" Like get_utility_one but returns: 1 for victory, 0 for loss, 0.5 for draw \"\"\"\n    winning_player = get_winner(bitboard)\n    if winning_player == 0: return 0.5\n    return 1.0 if winning_player == player_id else 0.0\n\n\n#@njit\ndef get_utility_inf(bitboard: np.ndarray, player_id: int) -> float:\n    \"\"\" Like get_utility_one but returns: +inf for victory, -inf for loss, 0 for draw \"\"\"\n    winning_player = get_winner(bitboard)\n    if winning_player == 0: return 0\n    return +np.inf if winning_player == player_id else -np.inf\n\n\n#####\n##### END   core\/ConnectXBBNN.py\n#####\n\n#####\n##### START util\/base64_file.py\n#####\n\nimport base64\nimport gzip\nimport os\nimport pickle\nimport re\nimport time\nfrom typing import Any, Union\nimport humanize\n\n# _base64_file__test_base64_static_import = \"\"\"\n# H4sIAPx9LF8C\/2tgri1k0IjgYGBgKCxNLS7JzM8rZIwtZNLwZvBm8mYEkjAI4jFB2KkRbED1iXnF\n# 5alFhczeWqV6AEGfwmBHAAAA\n# \"\"\"\n\n\ndef base64_file_varname(filename: str) -> str:\n    # ..\/data\/AntColonyTreeSearchNode.pickle.zip.base64 -> _base64_file__AntColonyTreeSearchNode__pickle__zip__base64\n    varname = re.sub(r'^.*\/',   '',   filename)  # remove directories\n    varname = re.sub(r'[.\\W]+', '__', varname)   # convert dots and non-ascii to __\n    varname = f\"_base64_file__{varname}\"\n    return varname\n\n\ndef base64_file_var_wrap(base64_data: Union[str,bytes], varname: str) -> str:\n    return f'{varname} = \"\"\"\\n{base64_data.strip()}\\n\"\"\"'                    # add varname = \"\"\"\\n\\n\"\"\" wrapper\n\n\ndef base64_file_var_unwrap(base64_data: str) -> str:\n    output = base64_data.strip()\n    output = re.sub(r'^\\w+ = \"\"\"|\"\"\"$', '', output)  # remove varname = \"\"\" \"\"\" wrapper\n    output = output.strip()\n    return output\n\n\ndef base64_file_encode(data: Any) -> str:\n    encoded = pickle.dumps(data)\n    encoded = gzip.compress(encoded)\n    encoded = base64.encodebytes(encoded).decode('utf8').strip()\n    return encoded\n\n\ndef base64_file_decode(encoded: str) -> Any:\n    data = base64.b64decode(encoded)\n    data = gzip.decompress(data)\n    data = pickle.loads(data)\n    return data\n\n\ndef base64_file_save(data: Any, filename: str, vebose=True) -> float:\n    \"\"\"\n        Saves a base64 encoded version of data into filename, with a varname wrapper for importing via kaggle_compile.py\n        # Doesn't create\/update global variable.\n        Returns filesize in bytes\n    \"\"\"\n    varname    = base64_file_varname(filename)\n    start_time = time.perf_counter()\n    try:\n        os.makedirs(os.path.dirname(filename), exist_ok=True)\n        with open(filename, 'wb') as file:\n            encoded = base64_file_encode(data)\n            output  = base64_file_var_wrap(encoded, varname)\n            output  = output.encode('utf8')\n            file.write(output)\n            file.close()\n        if varname in globals(): globals()[varname] = encoded  # globals not shared between modules, but update for saftey\n\n        filesize = os.path.getsize(filename)\n        if vebose:\n            time_taken = time.perf_counter() - start_time\n            print(f\"base64_file_save(): {filename:40s} | {humanize.naturalsize(filesize)} in {time_taken:4.1f}s\")\n        return filesize\n    except Exception as exception:\n        pass\n    return 0.0\n\n\ndef base64_file_load(filename: str, vebose=True) -> Union[Any,None]:\n    \"\"\"\n        Performs a lookup to see if the global variable for this file alread exists\n        If not, reads the base64 encoded file from filename, with an optional varname wrapper\n        # Doesn't create\/update global variable.\n        Returns decoded data\n    \"\"\"\n    varname    = base64_file_varname(filename)\n    start_time = time.perf_counter()\n    try:\n        # Hard-coding PyTorch weights into a script - https:\/\/www.kaggle.com\/c\/connectx\/discussion\/126678\n        encoded = None\n\n        if varname in globals():\n            encoded = globals()[varname]\n\n        if encoded is None and os.path.exists(filename):\n            with open(filename, 'rb') as file:\n                encoded = file.read().decode('utf8')\n                encoded = base64_file_var_unwrap(encoded)\n                # globals()[varname] = encoded  # globals are not shared between modules\n\n        if encoded is not None:\n            data = base64_file_decode(encoded)\n\n            if vebose:\n                filesize = os.path.getsize(filename)\n                time_taken = time.perf_counter() - start_time\n                print(f\"base64_file_load(): {filename:40s} | {humanize.naturalsize(filesize)} in {time_taken:4.1f}s\")\n            return data\n    except Exception as exception:\n        print(f'base64_file_load({filename}): Exception:', exception)\n    return None\n\n\n#####\n##### END   util\/base64_file.py\n#####\n\n#####\n##### START agents\/MontyCarlo\/MontyCarloPure.py\n#####\n\n# This is a LinkedList implementation of MontyCarlo Tree Search\n# Inspired by https:\/\/www.kaggle.com\/matant\/monte-carlo-tree-search-connectx\nimport atexit\nimport time\nfrom struct import Struct\nfrom typing import Callable\n\n# from core.ConnectXBBNN import *\n# from util.base64_file import base64_file_load\n# from util.base64_file import base64_file_save\n\nHyperparameters = namedtuple('hyperparameters', [])\n\nclass MontyCarloNode:\n    persist   = True\n    save_node = {}                                                        # save_node[cls.__name__] = cls(empty_bitboard(), 1)\n    root_nodes: List[Union['MontyCarloNode', None]] = [None, None, None]  # root_nodes[observation.mark]\n\n    def __init__(\n            self,\n            bitboard:      np.ndarray,\n            player_id:     int,\n            parent:        Union['MontyCarloNode', None] = None,\n            parent_action: Union[int,None]       = None,\n            exploration:   float = 1.0,\n            **kwargs\n    ):\n        self.bitboard      = bitboard\n        self.player_id     = player_id\n        self.next_player   = 3 - player_id\n\n        self.exploration   = exploration\n        self.kwargs        = kwargs\n\n        # self.mirror_hash   = hash_bitboard(bitboard)  # BUG: using mirror hashes causes get_best_action() to return invalid moves\n        self.legal_moves   = get_legal_moves(bitboard)\n        self.is_gameover   = is_gameover(bitboard)\n        self.winner        = get_winner(bitboard) if self.is_gameover else 0\n        self.utility       = 1 if self.winner == self.player_id else 0  # Scores in range 0-1\n\n        self.parent        = parent\n        self.parent_action = parent_action\n        self.is_expanded   = False\n        self.children: List[Union[MontyCarloNode, None]] = [None for action in get_all_moves()]  # include illegal moves to preserve indexing\n        self.total_score   = 0.0\n        self.total_visits  = 0\n        self.ucb1_score    = self.get_ucb1_score(self)\n\n\n\n    def __hash__(self):\n        return tuple(self.bitboard)\n        # return self.mirror_hash  # BUG: using mirror hashes causes get_best_action() to return invalid moves\n\n\n\n    ### Loading and Saving\n\n    @classmethod\n    def prune(cls, node: 'MontyCarloNode', min_visits=7, pruned_count=0, total_count=0):\n        for n, child in enumerate(node.children):\n            if child is None: continue\n            if child.total_visits < min_visits:\n                pruned_count    += child.total_visits  # excepting terminal states, this equals the number of grandchildren\n                total_count     += child.total_visits  # excepting terminal states, this equals the number of grandchildren\n                node.children[n] = None\n                node.is_expanded = False  # Use def expand(self) to reinitalize state\n            else:\n                total_count += 1\n                pruned_count, total_count = cls.prune(child, min_visits, pruned_count, total_count)\n        return pruned_count, total_count\n\n\n    @classmethod\n    def filename(cls):\n        return f\"data\/{cls.__name__}_base64.py\"\n\n    @classmethod\n    def load(cls):\n        filename = cls.filename()\n        loaded   = base64_file_load(filename)\n        if loaded is not None:\n            cls.save_node[cls.__name__] = loaded\n            return loaded\n        else:\n            return None\n\n\n    @classmethod\n    def save(cls) -> Union[str,None]:\n        if cls.persist == True and cls.save_node.get(cls.__name__, None) is not None:\n            save_node    = cls.save_node[cls.__name__]\n\n            start_time   = time.perf_counter()\n            pruned_count, total_count = cls.prune(save_node)  # This reduces a 47MB base64 file down to 5Mb\n            print(f'{cls.__name__}.save() - pruned {pruned_count:.0f}\/{total_count:.0f} nodes leaving {total_count-pruned_count:.0f} in {time.perf_counter() - start_time:.2f}s')\n\n            filename = cls.filename()\n            filesize = base64_file_save(save_node, filename)\n            return filename\n        return None\n\n    ### Constructors and Lookups\n\n    def create_child( self, action: int ) -> 'MontyCarloNode':\n        result = result_action(self.bitboard, action, self.player_id)\n        child  = None  # self.find_mirror_child(result, depth=1)  # BUG: using mirror hashes causes get_best_action() to return invalid moves\n        if child is None:\n            child = self.__class__(\n                bitboard      = result,\n                player_id     = next_player_id(self.player_id),\n                parent        = self,\n                parent_action = action,\n                exploration   = self.exploration,\n                **self.kwargs\n            )\n        self.children[action] = child\n        self.is_expanded      = self._is_expanded()\n        if self.is_expanded:\n            self.on_expanded()\n        return child\n\n\n    def find_child( self, bitboard: np.array, depth=2 ) -> Union['MontyCarloNode', None]:\n        # assert 0 <= depth <= 2\n\n        if depth >= 0:\n            if np.all( self.bitboard == bitboard ):\n                return self\n        if depth >= 1:\n            for child in self.children:\n                if child is None: continue\n                if np.all( child.bitboard == bitboard ):\n                    return child\n        if depth >= 2:\n            # Avoid recursion to prevent duplicate calls to hash_bitboard()\n            for child in self.children:\n                if child is None: continue\n                for grandchild in child.children:\n                    if grandchild is None: continue\n                    if np.all( grandchild.bitboard == bitboard ):\n                        return grandchild\n        return None\n\n    # # BUG: using mirror hashes causes get_best_action() to return invalid moves\n    # def find_mirror_child( self, bitboard: np.array, depth=2 ) -> Union['MontyCarloNode', None]:\n    #     # assert 0 <= depth <= 2\n    #     mirror_hash = hash_bitboard(bitboard)\n    #\n    #     if depth >= 0:\n    #         if self.mirror_hash == mirror_hash:\n    #             return self\n    #     if depth >= 1:\n    #         for child in self.children:\n    #             if child is None: continue\n    #             if child.mirror_hash == mirror_hash:\n    #                 return child\n    #     if depth >= 2:\n    #         # Avoid recursion to prevent duplicate calls to hash_bitboard()\n    #         for child in self.children:\n    #             if child is None: continue\n    #             for grandchild in child.children:\n    #                 if grandchild is None: continue\n    #                 if grandchild.mirror_hash == mirror_hash:\n    #                     return grandchild\n    #     return None\n\n\n\n    ### Properties\n\n    def _is_expanded(self) -> bool:\n        is_expanded = True\n        for action in self.legal_moves:\n            if self.children[action] is None:\n                is_expanded = False\n                break\n        return is_expanded\n\n\n    def get_unexpanded(self) -> List[int]:\n        return [\n            action\n            for action in self.legal_moves\n            if self.children[action] is None\n        ]\n\n\n    ### Action Selection\n\n    def get_best_action(self) -> int:\n        scores = [\n            self.children[action].total_score\n            if self.children[action] is not None else 0\n            for action in self.legal_moves\n        ]\n        index  = np.argmax(scores)\n        action = self.legal_moves[index]\n        return action\n\n\n    def get_exploration_action(self) -> int:\n        scores = [\n            self.children[action].ucb1_score\n            if self.children[action] is not None else 0\n            for action in self.legal_moves\n        ]\n        index  = np.argmax(scores)\n        action = self.legal_moves[index]\n        return action\n\n\n\n    ### Scores\n\n    def get_ucb1_score(self, node: 'MontyCarloNode') -> float:\n        if node is None or node.total_visits == 0:\n            return np.inf\n        else:\n            score = node.total_score \/ node.total_visits\n            if node.parent is not None and node.parent.total_visits > 0:\n                score += (\n                    node.exploration * np.sqrt(2)\n                    * np.log(node.parent.total_visits) \/ node.total_visits\n                )\n            return score\n\n\n    @staticmethod\n    def opponents_score(score: float):\n        # assert 0 <= score <= 1\n        return 1 - score\n\n\n\n    ### Training and Backpropagation\n\n    def single_run(self):\n        if self.is_gameover:\n            self.backpropagate(self.utility)\n        elif not self.is_expanded:\n            child = self.expand()\n            score = child.simulate()    # score from the perspective of the other player\n            child.backpropagate(score)\n        else:\n            # Recurse down tree, until a gameover or not expanded node is found\n            action = self.get_exploration_action()\n            child  = self.children[action]\n            child.single_run()\n\n\n    def expand(self) -> 'MontyCarloNode':\n        # assert not self.is_gameover\n        # assert not self.is_expanded\n\n        unexpanded = self.get_unexpanded()\n        # assert len(unexpanded)\n\n        action     = np.random.choice(unexpanded)\n        child      = self.create_child(action)\n        return child\n\n    def on_expanded(self) -> None:\n        # Callback placeholder for any subclass hooks\n        pass\n\n    def simulate(self) -> float:\n        return run_random_simulation(self.bitboard, self.player_id)\n\n\n    def backpropagate(self, score: float):\n        # child.simulate()  returns score for the player 2\n        # child.total_score is accessed via the parent node, so score on this node is from the perspective of player 1\n        node = self\n        while node is not None:\n            score = self.opponents_score(score)\n            node.total_score  += score\n            node.total_visits += 1\n            node = node.parent      # when we reach the root: node.parent == None which terminates\n\n        # get_ucb1_score() gets called 4x less often if we cache the value after backpropagation\n        # get_ucb1_score() depends on parent.total_visits, so needs to be called after updating scores\n        node = self\n        while node is not None:\n            node.ucb1_score = node.get_ucb1_score(node)\n            node = node.parent      # when we reach the root: node.parent == None which terminates\n\n\n\n    ### Agent\n    @classmethod\n    def agent(cls, **kwargs) -> Callable[[Struct, Struct],int]:\n        def kaggle_agent( observation: Struct, _configuration_: Struct ):\n            first_move_time = 0\n            safety_time     = kwargs.get('safety_time', 0.25)\n            start_time      = time.perf_counter()\n            # configuration   = cast_configuration(_configuration_)\n\n            player_id     = int(observation.mark)\n            listboard     = np.array(observation.board, dtype=np.int8)\n            bitboard      = list_to_bitboard(listboard)\n            move_number   = get_move_number(bitboard)\n            is_first_move = int(move_number < 2)\n            endtime       = start_time + _configuration_.timeout - safety_time - (first_move_time * is_first_move)\n\n            if cls.persist == True and cls.save_node.get(cls.__name__, None) is None:\n                atexit.register(cls.save)\n                cls.save_node[cls.__name__] = cls.load() or cls(empty_bitboard(), player_id=1)\n                cls.root_nodes[1] = cls.root_nodes[2] = cls.save_node[cls.__name__]  # implement shared state\n\n            root_node = cls.root_nodes[player_id]\n            if root_node is None or root_node.find_child(bitboard, depth=2) is None:\n                root_node = cls.root_nodes[player_id] = cls(\n                    bitboard      = bitboard,\n                    player_id     = player_id,\n                    parent        = None,\n                    # configuration = configuration,\n                    **kwargs\n                )\n            else:\n                root_node = cls.root_nodes[player_id] = cls.root_nodes[player_id].find_child(bitboard)\n            # assert root_node is not None\n\n            count = 0\n            while time.perf_counter() < endtime:\n                count += 1\n                root_node.single_run()\n\n            action     = root_node.get_best_action()\n            time_taken = time.perf_counter() - start_time\n            print(f'{cls.__name__}: p{player_id} action = {action} after {count} simulations in {time_taken:.3f}s')\n            return int(action)\n\n        kaggle_agent.__name__ = cls.__name__\n        return kaggle_agent\n\ndef MontyCarloPure(**kwargs):\n    # observation   = {'mark': 1, 'board': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}\n    # configuration = {'columns': 7, 'rows': 6, 'inarow': 4, 'steps': 1000, 'timeout': 8}\n    def MontyCarloPure(observation: Struct, configuration: Struct) -> int:\n        return MontyCarloNode.agent(**kwargs)(observation, configuration)\n    return MontyCarloPure\n\ndef MontyCarloPureKaggle(observation, configuration):\n    return MontyCarloPure()(observation, configuration)\n\n\n#####\n##### END   agents\/MontyCarlo\/MontyCarloPure.py\n#####\n\n##### \n##### ..\/..\/kaggle_compile.py agents\/MontyCarlo\/MontyCarloPure.py\n##### \n##### 2020-08-26 16:45:21+01:00\n##### \n##### origin\tgit@github.com:JamesMcGuigan\/ai-games.git (fetch)\n##### origin\tgit@github.com:JamesMcGuigan\/ai-games.git (push)\n##### \n##### * master 247327a [ahead 6] ConnectX | reduce safety_time to 0.25s\n##### \n##### 247327afa97dfaa0c87ea36321e7be3deaa9d8d4\n##### \n","d34821e6":"%run submission.py","38d2a657":"from kaggle_environments import evaluate, make, utils\n\n%load_ext autoreload\n%autoreload 2","f98d4058":"### Play against yourself without an ERROR or INVALID.\n### Note: The first episode in the competition will run this to weed out erroneous agents.\n\nenv = make(\"connectx\", debug=True)\nenv.run([\"\/kaggle\/working\/submission.py\", \"\/kaggle\/working\/submission.py\"])\nprint(\"\\nEXCELLENT SUBMISSION!\" if env.toJSON()[\"statuses\"] == [\"DONE\", \"DONE\"] else \"MAYBE BAD SUBMISSION?\")\nenv.render(mode=\"ipython\", width=500, height=450)","9e398cf3":"env = make(\"connectx\", debug=True)\nenv.run([\"\/kaggle\/working\/submission.py\", \"negamax\"])\nprint(\"\\nEXCELLENT SUBMISSION!\" if env.toJSON()[\"statuses\"] == [\"DONE\", \"DONE\"] else \"MAYBE BAD SUBMISSION?\")\nenv.render(mode=\"ipython\", width=500, height=450)\n","505c2545":"env = make(\"connectx\", debug=True)\nenv.play([None, \"\/kaggle\/working\/submission.py\"], width=500, height=450)","a0cfac84":"## Versus Negamax","c6db7ca3":"# Versus Human","50389f1d":"# ConnectX - Monty Carlo Tree Search\n\nMonty Carlo Tree Search using an Object Oriented Tree with Numpy Bitboard Bitshifting","ed9442fd":"# Test your Agent","a5f970b4":"## Versus Self"}}