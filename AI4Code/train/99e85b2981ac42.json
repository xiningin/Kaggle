{"cell_type":{"8147701a":"code","077dffab":"code","1eb9c526":"code","de40990c":"code","9d1ed180":"code","29dab5ed":"code","4475736c":"code","abbff4db":"code","481282b6":"code","4923a8a1":"code","9ba6170d":"code","d4c8c638":"code","2600a7b1":"code","ba2a3393":"code","ed32be9b":"code","99f6078e":"code","9d1a0c4f":"code","f07e2ed3":"code","64e72bb3":"code","ff474334":"code","5c535e52":"code","67d4f4f2":"code","47f84904":"code","ec55d174":"code","2b01091a":"code","0c6b458e":"code","6cc3f59b":"code","71c4c8d9":"code","b6c832bb":"code","334d30c6":"code","3495749b":"code","2e6a177e":"code","a82ef53e":"code","f03d63d9":"code","9ca9b120":"code","bf48d37c":"markdown","2d0d41ae":"markdown","cdaa08c6":"markdown","0f8f2139":"markdown","2391e157":"markdown","ce159bd4":"markdown","ba21d968":"markdown","e82c87f0":"markdown","fc59445b":"markdown","486c2446":"markdown","ffdac142":"markdown","1a9d317f":"markdown","742db189":"markdown","24c07339":"markdown","08ab7939":"markdown","03315235":"markdown","324ea592":"markdown","eb61f062":"markdown","ae51c8fa":"markdown","d47becf2":"markdown","cb120a98":"markdown","2dc6d01e":"markdown","18b9ccef":"markdown","29a92125":"markdown","99d3e5ac":"markdown","c4373faa":"markdown"},"source":{"8147701a":"!pip install neurokit2","077dffab":"import neurokit2 as nk\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.signal import find_peaks\nfrom scipy import signal\nfrom scipy.integrate import trapz\nfrom scipy.interpolate import interp1d\nimport seaborn as sns\nfrom matplotlib.patches import Ellipse\n\nppg_simulated=nk.ppg_simulate(duration=300, sampling_rate=500, heart_rate=60)\nplt.plot(ppg_simulated)\nplt.show()","1eb9c526":"def timedomain(rr):\n    results = {}\n\n    hr = 60000\/rr\n    \n    results['Mean RR (ms)'] = np.mean(rr)\n    results['STD RR\/SDNN (ms)'] = np.std(rr)\n    results['Mean HR (Kubios\\' style) (beats\/min)'] = 60000\/np.mean(rr)\n    results['Mean HR (beats\/min)'] = np.mean(hr)\n    results['STD HR (beats\/min)'] = np.std(hr)\n    results['Min HR (beats\/min)'] = np.min(hr)\n    results['Max HR (beats\/min)'] = np.max(hr)\n    results['RMSSD (ms)'] = np.sqrt(np.mean(np.square(np.diff(rr))))\n    results['NNxx'] = np.sum(np.abs(np.diff(rr)) > 50)*1\n    results['pNNxx (%)'] = 100 * np.sum((np.abs(np.diff(rr)) > 50)*1) \/ len(rr)\n    return results","de40990c":"def frequency_domain(rri, fs=4):\n    # Estimate the spectral density using Welch's method\n    fxx, pxx = signal.welch(x=rr_interpolated, fs=fs)\n    \n    '''\n    Segement found frequencies in the bands \n     - Very Low Frequency (VLF): 0-0.04Hz \n     - Low Frequency (LF): 0.04-0.15Hz \n     - High Frequency (HF): 0.15-0.4Hz\n    '''\n    cond_vlf = (fxx >= 0) & (fxx < 0.04)\n    cond_lf = (fxx >= 0.04) & (fxx < 0.15)\n    cond_hf = (fxx >= 0.15) & (fxx < 0.4)\n    \n    # calculate power in each band by integrating the spectral density \n    vlf = trapz(pxx[cond_vlf], fxx[cond_vlf])\n    lf = trapz(pxx[cond_lf], fxx[cond_lf])\n    hf = trapz(pxx[cond_hf], fxx[cond_hf])\n    \n    # sum these up to get total power\n    total_power = vlf + lf + hf\n\n    # find which frequency has the most power in each band\n    peak_vlf = fxx[cond_vlf][np.argmax(pxx[cond_vlf])]\n    peak_lf = fxx[cond_lf][np.argmax(pxx[cond_lf])]\n    peak_hf = fxx[cond_hf][np.argmax(pxx[cond_hf])]\n\n    # fraction of lf and hf\n    lf_nu = 100 * lf \/ (lf + hf)\n    hf_nu = 100 * hf \/ (lf + hf)\n    \n    results = {}\n    results['Power VLF (ms2)'] = vlf\n    results['Power LF (ms2)'] = lf\n    results['Power HF (ms2)'] = hf   \n    results['Power Total (ms2)'] = total_power\n\n    results['LF\/HF'] = (lf\/hf)\n    results['Peak VLF (Hz)'] = peak_vlf\n    results['Peak LF (Hz)'] = peak_lf\n    results['Peak HF (Hz)'] = peak_hf\n\n    results['Fraction LF (nu)'] = lf_nu\n    results['Fraction HF (nu)'] = hf_nu\n    return results, fxx, pxx","9d1ed180":"def plot_poincare(rr):\n    rr_n = rr[:-1]\n    rr_n1 = rr[1:]\n\n    sd1 = np.sqrt(0.5) * np.std(rr_n1 - rr_n)\n    sd2 = np.sqrt(0.5) * np.std(rr_n1 + rr_n)\n\n    m = np.mean(rr)\n    min_rr = np.min(rr)\n    max_rr = np.max(rr)\n    \n    plt.figure(figsize=(10, 10))\n    plt.title(\"Poincare plot\")\n\n    sns.scatterplot(x=rr_n, y=rr_n1, color=\"#51A6D8\")\n\n    plt.xlabel(r'$RR_n (ms)$')\n    plt.ylabel(r'$RR_{n+1} (ms)$')\n\n    e1 = Ellipse((m, m), 2*sd1, 2*sd2, angle=-45, linewidth=1.2, fill=False, color=\"k\")\n    plt.gca().add_patch(e1)\n\n    plt.arrow(m, m, (max_rr-min_rr)*0.4, (max_rr-min_rr)*0.4, color=\"k\", linewidth=0.8, head_width=5, head_length=5)\n    plt.arrow(m, m, (min_rr-max_rr)*0.4, (max_rr-min_rr)*0.4, color=\"k\", linewidth=0.8, head_width=5, head_length=5)\n\n    plt.arrow(m, m, sd2 * np.sqrt(0.5), sd2 * np.sqrt(0.5), color=\"green\", linewidth=5)\n    plt.arrow(m, m, -sd1 * np.sqrt(0.5), sd1 * np.sqrt(0.5), color=\"red\", linewidth=5)\n\n    plt.text(max_rr, max_rr, \"SD2\", fontsize=20, color=\"green\")\n    plt.text(m-(max_rr-min_rr)*0.4-20, max_rr, \"SD1\", fontsize=20, color=\"red\")\n    \n    return sd1, sd2","29dab5ed":"ppg_and_ecg=nk.data(dataset=\"bio_resting_5min_100hz\")","4475736c":"plt.plot(ppg_and_ecg['PPG'][0:500])\nplt.plot(ppg_and_ecg['ECG'][0:500])\nplt.title(\"PPG and ECG\", color = \"black\")\nplt.tick_params(axis=\"both\", colors = \"black\")","abbff4db":"diff_sig_2=np.diff(ppg_and_ecg['PPG'])","481282b6":"# HR will probably not go below 30 bpm : distance=500*(30\/60))\n# prominence found experimentally\npeaks_2, _ = find_peaks(diff_sig_2, distance=100*(30\/60), prominence=0.01)","4923a8a1":"plt.figure(figsize=(20,8))\nplt.subplot(2,1,1)\nplt.plot(ppg_and_ecg['PPG'])\nplt.scatter(peaks_2, ppg_and_ecg['PPG'][peaks_2], color=\"red\")\nplt.gca().set_xlim(0, 1000)\nplt.subplot(2,1,2)\nplt.plot(diff_sig_2)\nplt.scatter(peaks_2, diff_sig_2[peaks_2], color=\"red\")\nplt.gca().set_xlim(0, 1000)\nplt.show()\n","9ba6170d":"rr_2 = np.diff(peaks_2)\ncorr_rr_2 = rr_2*10","d4c8c638":"timedomain(corr_rr_2)","2600a7b1":"x_2 = np.cumsum(rr_2)\/ 100.0\nf_2 = interp1d(x_2, rr_2, kind='cubic',fill_value=\"extrapolate\")\n\n# sample rate for interpolation\nfs = 4.0\nsteps = 1 \/ fs\n\n# now we can sample from interpolation function\nxx_2 = np.arange(1, np.max(x_2), steps)\n\nrr_interpolated = f_2(xx_2)\n\nplt.figure(figsize=(20, 15))\n\nplt.subplot(211)\nplt.title(\"RR intervals\")\nplt.plot(x_2, rr_2, color=\"k\", markerfacecolor=\"#A651D8\", markeredgewidth=0, marker=\"o\", markersize=8)\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"RR-interval (ms)\")\nplt.title(\"Interpolated\")\nplt.gca().set_xlim(0, 300)\n\nplt.subplot(212)\nplt.title(\"RR-Intervals (cubic interpolation)\")\nplt.plot(xx_2, rr_interpolated_2, color=\"k\", markerfacecolor=\"#51A6D8\", markeredgewidth=0, marker=\"o\", markersize=8)\nplt.gca().set_xlim(0, 300)\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"RR-interval (ms)\")\nplt.show()","ba2a3393":"print(\"Frequency domain metrics:\")\nresults_2, fxx_2, pxx_2 = frequency_domain(rr_interpolated)\n\nfor k, v in results_2.items():\n    print(\"- %s: %.2f\" % (k, v))","ed32be9b":"plt.figure(figsize=(20, 7))\nplt.plot(fxx_2, pxx_2, color=\"k\", linewidth=0.3)\nplt.title(\"FFT Spectrum (Welch's periodogram)\")\n\n# create interpolation function for plotting frequency bands\npsd_f = interp1d(fxx_2, pxx_2)\n\n# setup frequency bands for plotting\nx_vlf = np.linspace(0, 0.04, 100)\nx_lf = np.linspace(0.04, 0.15, 100)\nx_hf = np.linspace(0.15, 0.4, 100)\n\nplt.gca().fill_between(x_vlf, psd_f(x_vlf), alpha=0.2, color=\"#A651D8\", label=\"VLF\")\nplt.gca().fill_between(x_lf, psd_f(x_lf), alpha=0.2, color=\"#51A6D8\", label=\"LF\")\nplt.gca().fill_between(x_hf, psd_f(x_hf), alpha=0.2, color=\"#D8A651\", label=\"HF\")\n\nplt.gca().set_xlim(0, 0.5)\nplt.gca().set_ylim(0)\nplt.xlabel(\"Frequency (Hz)\")\nplt.ylabel(\"Density\")\nplt.legend()\nplt.show()","99f6078e":"import seaborn as sns\nfrom matplotlib.patches import Ellipse\nsd1_2, sd2_2 = plot_poincare(rr_2)\nprint(\"SD1: %.3f ms\" % sd1_2)\nprint(\"SD2: %.3f ms\" % sd2_2)","9d1a0c4f":"ecg_signals, info  = nk.ecg_process(ppg_and_ecg[\"ECG\"], sampling_rate=100)","f07e2ed3":"plt.plot(ppg_and_ecg[\"ECG\"])\nplt.scatter(info['ECG_R_Peaks'], ppg_and_ecg[\"ECG\"][info['ECG_R_Peaks']], color=\"red\")\nplt.gca().set_xlim(0, 1000)\nplt.show()","64e72bb3":"rr_ecg = np.diff(info['ECG_R_Peaks'])\ncorr_rr_ecg = rr_ecg*10","ff474334":"timedomain(corr_rr_ecg)","5c535e52":"x_ecg = np.cumsum(rr_ecg)\/ 100.0\nf_ecg = interp1d(x_ecg, rr_ecg, kind='cubic',fill_value=\"extrapolate\")\n\n# sample rate for interpolation\nfs = 4.0\nsteps = 1 \/ fs\n\n# now we can sample from interpolation function\nxx_ecg = np.arange(1, np.max(x_ecg), steps)\nxx_ecg.shape\n\nrr_interpolated_ecg = f_ecg(xx_ecg)\n\nplt.figure(figsize=(20, 15))\n\nplt.subplot(211)\nplt.title(\"RR intervals\")\nplt.plot(x_ecg, rr_ecg, color=\"k\", markerfacecolor=\"#A651D8\", markeredgewidth=0, marker=\"o\", markersize=8)\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"RR-interval (ms)\")\nplt.title(\"Interpolated\")\nplt.gca().set_xlim(0, 300)\n\nplt.subplot(212)\nplt.title(\"RR-Intervals (cubic interpolation)\")\nplt.plot(xx_ecg, rr_interpolated_ecg, color=\"k\", markerfacecolor=\"#51A6D8\", markeredgewidth=0, marker=\"o\", markersize=8)\nplt.gca().set_xlim(0, 300)\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"RR-interval (ms)\")\nplt.show()","67d4f4f2":"print(\"Frequency domain metrics:\")\nresults_ecg, fxx_ecg, pxx_ecg = frequency_domain(rr_interpolated_ecg)\n\nfor k_e, v_e in results_ecg.items():\n    print(\"- %s: %.2f\" % (k_e, v_e))","47f84904":"plt.figure(figsize=(20, 7))\nplt.plot(fxx_ecg, pxx_ecg, color=\"k\", linewidth=0.3)\nplt.title(\"FFT Spectrum (Welch's periodogram)\")\n\n# create interpolation function for plotting frequency bands\npsd_f = interp1d(fxx_ecg, pxx_ecg)\n\n# setup frequency bands for plotting\nx_vlf = np.linspace(0, 0.04, 100)\nx_lf = np.linspace(0.04, 0.15, 100)\nx_hf = np.linspace(0.15, 0.4, 100)\n\nplt.gca().fill_between(x_vlf, psd_f(x_vlf), alpha=0.2, color=\"#A651D8\", label=\"VLF\")\nplt.gca().fill_between(x_lf, psd_f(x_lf), alpha=0.2, color=\"#51A6D8\", label=\"LF\")\nplt.gca().fill_between(x_hf, psd_f(x_hf), alpha=0.2, color=\"#D8A651\", label=\"HF\")\n\nplt.gca().set_xlim(0, 0.5)\nplt.gca().set_ylim(0)\nplt.xlabel(\"Frequency (Hz)\")\nplt.ylabel(\"Density\")\nplt.legend()\nplt.show()","ec55d174":"sd1_ecg, sd2_ecg = plot_poincare(rr_ecg)\nprint(\"SD1: %.3f ms\" % sd1_ecg)\nprint(\"SD2: %.3f ms\" % sd2_ecg)","2b01091a":"!pip install hrv-analysis","0c6b458e":"!pip install pyhrv","6cc3f59b":"from hrvanalysis import remove_outliers, remove_ectopic_beats, interpolate_nan_values","71c4c8d9":"rr_intervals_list = info['ECG_R_Peaks']","b6c832bb":"import pyhrv.tools as tools","334d30c6":"import pyhrv.frequency_domain as fd\nnni = tools.nn_intervals(rr_intervals_list)\nresult = fd.welch_psd(nni=nni)\n# Access peak frequencies using the key 'fft_peak'\nprint(result['fft_peak'])","3495749b":"nni_2 = tools.nn_intervals(peaks_2)\nresult = fd.welch_psd(nni=nni_2)\n# Access peak frequencies using the key 'fft_peak'\nprint(result['fft_peak'])","2e6a177e":"import pyhrv.nonlinear as nl\nresult = nl.poincare(nni)\nprint(result['sd1'])","a82ef53e":"result = nl.sample_entropy(nni)\nprint(result['sampen'])","f03d63d9":"result = nl.poincare(nni_2)\nprint(result['sd1'])","9ca9b120":"result = nl.sample_entropy(nni_2)\nprint(result['sampen'])","bf48d37c":"### First 10 seconds of PPG measurements ","2d0d41ae":"# <center>Heart Rate Variability (HRV) analysis using time domain, frequency domain and non-linear methods<\/center>","cdaa08c6":"# From NeuroKit 2 we import a 5min PPG and ECG-recording ([https:\/\/github.com\/neuropsychology\/NeuroKit\/blob\/master\/data\/bio_resting_5min_100hz.csv](https:\/\/github.com\/neuropsychology\/NeuroKit\/blob\/master\/data\/bio_resting_5min_100hz.csv))","0f8f2139":"## Time Domain analysis","2391e157":"## Poincare analysis (non-linear)","ce159bd4":"## Welch diagram - PPG signal","ba21d968":"# Welch diagram for ECG signal","e82c87f0":"## Interpolated ECG signal","fc59445b":"## To be able to do frequency analysis we have to interpolate the RR-interval curve (PPG)","486c2446":"# Analysis ECG signal","ffdac142":"### Poincare analysis ECG","1a9d317f":"## Timedomain analysis of ECG","742db189":"## We wil use now use [PyHRV](https:\/\/pypi.org\/project\/pyhrv\/) to analyze the data","24c07339":"## Poincare analysis of ECG signal","08ab7939":"### Sample Entropy PPG","03315235":"<section data-markdown>\n    <img src=\"https:\/\/d1a0efioav7lro.cloudfront.net\/wp-content\/uploads\/2020\/02\/07020753\/Heart-Rate-Variability1.png\"\/>\n<\/section>","324ea592":"### Plot the first 5 seconds of the data","eb61f062":"## Poincare diagram (PPG)","ae51c8fa":"### Plot first 10 seconds of ECG signal","d47becf2":"# Non-linear analysis using PyHRV\n### Poincare analysis PPG","cb120a98":"- Makowski, D., Pham, T., Lau, Z. J., Brammer, J. C., Lesspinasse, F., Pham, H.,\n  Sch\u00f6lzel, C., & S H Chen, A. (2020). NeuroKit2: A Python Toolbox for Neurophysiological\n  Signal Processing. Retrieved May 07, 2020, from https:\/\/github.com\/neuropsychology\/NeuroKit\n- https:\/\/www.kaggle.com\/stetelepta\/exploring-heart-rate-variability-using-python","2dc6d01e":"## Welch diagram - ECG signal","18b9ccef":"## We wil use [Neurokit](https:\/\/pypi.org\/project\/neurokit2\/) and [PyHRV](https:\/\/pypi.org\/project\/pyhrv\/) to analyze data from ECG and PPG","29a92125":"## Frequenzy domain analysis off ECG signal","99d3e5ac":"## Welch periodogram (PPG)","c4373faa":"## Frequency Domain analysis"}}