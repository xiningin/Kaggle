{"cell_type":{"2d8beded":"code","15f53d18":"code","18bc7012":"code","6e0cf8f7":"code","31e6c083":"code","1c40d16f":"code","36c99d14":"code","a1c01a42":"code","430eae59":"code","29bd90c9":"code","c614ff09":"code","57ea552f":"code","b189dfd4":"code","3667b81c":"code","a7a8624f":"code","db2e39e5":"code","e6d0b945":"code","22ea8c74":"code","8787d118":"code","9ec61113":"code","cbc829b2":"code","0c3b6098":"code","3b93cbe8":"code","7148e811":"markdown","915fd985":"markdown","75b53bab":"markdown","7f6d7901":"markdown","6301cfb9":"markdown","b007516b":"markdown","89c7ebf4":"markdown","d53c2732":"markdown"},"source":{"2d8beded":"import pandas as pd\nimport numpy as np\nimport datetime\nimport time\n\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import davies_bouldin_score\n\nimport plotly.offline as py\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Dropout\nfrom tensorflow.keras.losses import MSE","15f53d18":"Case = pd.read_csv(\"..\/input\/coronavirusdataset\/Case.csv\")\nPatientInfo = pd.read_csv(\"..\/input\/coronavirusdataset\/PatientInfo.csv\")\nPatientRoute = pd.read_csv(\"..\/input\/coronavirusdataset\/PatientRoute.csv\")\nRegion = pd.read_csv(\"..\/input\/coronavirusdataset\/Region.csv\")\nSearchTrend = pd.read_csv(\"..\/input\/coronavirusdataset\/SearchTrend.csv\")\nSeoulFloating = pd.read_csv(\"..\/input\/coronavirusdataset\/SeoulFloating.csv\")\nTime = pd.read_csv(\"..\/input\/coronavirusdataset\/Time.csv\")\nTimeAge = pd.read_csv(\"..\/input\/coronavirusdataset\/TimeAge.csv\")\nTimeGender = pd.read_csv(\"..\/input\/coronavirusdataset\/TimeGender.csv\")\nTimeProvince = pd.read_csv(\"..\/input\/coronavirusdataset\/TimeProvince.csv\")\nWeather = pd.read_csv(\"..\/input\/coronavirusdataset\/Weather.csv\")","18bc7012":"p_info = PatientInfo[['patient_id', 'sex', 'age','country',\n                      'province', 'city', 'infection_case', 'infection_order',\n                      'confirmed_date', 'state']]\n\np_info = p_info.fillna(method = 'ffill')\n#Calculatiing exact year of patients\np_info['age'] = PatientInfo['birth_year'].apply(lambda x: 2020 - x)\n\n#Assigning numerical value to all string columns\nsexes = {}\ncountries = {}\nprovinces = {}\ncities = {}\ninfection_cases = {}\nstates = {}\n\n\nfor i in p_info['sex'].unique():\n  key = list(p_info['sex'].unique()).index(i)\n  sexes[key] = i\n\nfor i in p_info['country'].unique():\n  key = list(p_info['country'].unique()).index(i)\n  countries[key] = i\n\nfor i in p_info['province'].unique():\n  key = list(p_info['province'].unique()).index(i)\n  provinces[key] = i\n\nfor i in p_info['city'].unique():\n  key = list(p_info['city'].unique()).index(i)\n  cities[key] = i\n\nfor i in p_info['infection_case'].unique():\n  key = list(p_info['infection_case'].unique()).index(i)\n  infection_cases[key] = i\n\nfor i in p_info['state'].unique():\n  key = list(p_info['state'].unique()).index(i)\n  states[key] = i\n\nfor i in range(0, len(p_info)):\n  p_info.loc[i,'sex'] = (list(sexes.keys())[list(sexes.values()).index(p_info.iloc[i]['sex'])])\n  p_info.loc[i,'country'] = (list(countries.keys())[list(countries.values()).index(p_info.iloc[i]['country'])])\n  p_info.loc[i,'province'] = (list(provinces.keys())[list(provinces.values()).index(p_info.iloc[i]['province'])])\n  p_info.loc[i,'city'] = (list(cities.keys())[list(cities.values()).index(p_info.iloc[i]['city'])])\n  p_info.loc[i,'infection_case'] = (list(infection_cases.keys())[list(infection_cases.values()).index(p_info.iloc[i]['infection_case'])])\n  p_info.loc[i,'state'] = (list(states.keys())[list(states.values()).index(p_info.iloc[i]['state'])])\n\n\np_info['confirmed_date'] = p_info['confirmed_date'].apply(\n    lambda x: time.mktime(\n        datetime.datetime.strptime(str(x), \"%Y-%m-%d\").timetuple()))\n\np_info['age'] = p_info['age'].fillna(method = 'ffill')\n\np_info = p_info.set_index('patient_id')","6e0cf8f7":"#Take a look to our new dataset\np_info.head()","31e6c083":"#Perform a clustering on our new dataset\nscaler = MinMaxScaler()\nscaler.fit(p_info)\np_info_scaled = scaler.transform(p_info)\n\nkmeans = KMeans(n_clusters=3)\nkmeans.fit(p_info_scaled)\nlabels = kmeans.predict(p_info_scaled)\nprint(\"Davies-Bouldin score for clustering is :{}\".format(davies_bouldin_score(p_info, labels)))","1c40d16f":"p_info['cluster'] = labels\n# Make the plot\nfig1 = px.parallel_coordinates(p_info, color=\"cluster\")\npy.offline.iplot(fig1)","36c99d14":"from pandas.plotting import scatter_matrix\nscatter_matrix(p_info, alpha=0.2, figsize=(15, 15), diagonal='kde')","a1c01a42":"#Plotting based on cluster\np_new = PatientInfo[['patient_id', 'sex', 'age','country',\n                      'province', 'city', 'infection_case', 'infection_order',\n                      'confirmed_date', 'state']]\np_new['cluster'] = labels\n","430eae59":"temp = p_new[['sex', 'cluster']]\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=3,\n                     specs=[[{'type':'domain'}, {'type':'domain'},\n                             {'type':'domain'}]])\ncol = 1\nfor item in p_new['cluster'].unique():\n  grp = temp[temp['cluster'] == item].groupby(['sex'])\n  print(grp.size())\n  vals = dict(grp.size())\n  sum_val = 0\n  to_plot = {}\n  for key in vals:\n    sum_val += vals[key]\n  for key in vals:\n    to_plot[key] = (vals[key]\/sum_val) * 100\n    \n  fig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                       values=list(to_plot.values()),\n                        name=\"Cluster \" + str(item)),\n                  row=1, col=col)\n  col += 1\n\nfig1.update_layout(title_text=\"Sexes Based on cluster\")\npy.offline.iplot(fig1)","29bd90c9":"temp = p_new[['age', 'cluster']]\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=3,\n                     specs=[[{'type':'domain'}, {'type':'domain'},\n                             {'type':'domain'}]])\ncol = 1\nfor item in p_new['cluster'].unique():\n  grp = temp[temp['cluster'] == item].groupby(['age'])\n  print(grp.size())\n  vals = dict(grp.size())\n  sum_val = 0\n  to_plot = {}\n  for key in vals:\n    sum_val += vals[key]\n  for key in vals:\n    to_plot[key] = (vals[key]\/sum_val) * 100\n    \n  fig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                       values=list(to_plot.values()),\n                        name=\"Cluster \" + str(item)),\n                  row=1, col=col)\n  col += 1\n\nfig1.update_layout(title_text=\"Age Based on cluster\")\npy.offline.iplot(fig1)","c614ff09":"temp = p_new[['country', 'cluster']]\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=3,\n                     specs=[[{'type':'domain'}, {'type':'domain'},\n                             {'type':'domain'}]])\ncol = 1\nfor item in p_new['cluster'].unique():\n  grp = temp[temp['cluster'] == item].groupby(['country'])\n  print(grp.size())\n  vals = dict(grp.size())\n  sum_val = 0\n  to_plot = {}\n  for key in vals:\n    sum_val += vals[key]\n  for key in vals:\n    to_plot[key] = (vals[key]\/sum_val) * 100\n    \n  fig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                       values=list(to_plot.values()),\n                        name=\"Cluster \" + str(item)),\n                  row=1, col=col)\n  col += 1\n\nfig1.update_layout(title_text=\"Countries Based on cluster\")\npy.offline.iplot(fig1)","57ea552f":"temp = p_new[['province', 'cluster']]\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=3,\n                     specs=[[{'type':'domain'}, {'type':'domain'},\n                             {'type':'domain'}]])\ncol = 1\nfor item in p_new['cluster'].unique():\n  grp = temp[temp['cluster'] == item].groupby(['province'])\n  print(grp.size())\n  vals = dict(grp.size())\n  sum_val = 0\n  to_plot = {}\n  for key in vals:\n    sum_val += vals[key]\n  for key in vals:\n    to_plot[key] = (vals[key]\/sum_val) * 100\n    \n  fig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                       values=list(to_plot.values()),\n                        name=\"Cluster \" + str(item)),\n                  row=1, col=col)\n  col += 1\n\nfig1.update_layout(title_text=\"Provinces Based on cluster\")\npy.offline.iplot(fig1)","b189dfd4":"temp = p_new[['state', 'cluster']]\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=3,\n                     specs=[[{'type':'domain'}, {'type':'domain'},\n                             {'type':'domain'}]])\ncol = 1\nfor item in p_new['cluster'].unique():\n  grp = temp[temp['cluster'] == item].groupby(['state'])\n  print(grp.size())\n  vals = dict(grp.size())\n  sum_val = 0\n  to_plot = {}\n  for key in vals:\n    sum_val += vals[key]\n  for key in vals:\n    to_plot[key] = (vals[key]\/sum_val) * 100\n    \n  fig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                       values=list(to_plot.values()),\n                        name=\"Cluster \" + str(item)),\n                  row=1, col=col)\n  col += 1\n\nfig1.update_layout(title_text=\"States Based on cluster\")\npy.offline.iplot(fig1)","3667b81c":"temp = p_new[['city', 'cluster']]\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=3,\n                     specs=[[{'type':'domain'}, {'type':'domain'},\n                             {'type':'domain'}]])\ncol = 1\nfor item in p_new['cluster'].unique():\n  grp = temp[temp['cluster'] == item].groupby(['city'])\n  print(grp.size())\n  vals = dict(grp.size())\n  sum_val = 0\n  to_plot = {}\n  for key in vals:\n    sum_val += vals[key]\n  for key in vals:\n    to_plot[key] = (vals[key]\/sum_val) * 100\n    \n  fig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                       values=list(to_plot.values()),\n                        name=\"Cluster \" + str(item)),\n                  row=1, col=col)\n  col += 1\n\nfig1.update_layout(title_text=\"Cities Based on cluster\")\npy.offline.iplot(fig1)","a7a8624f":"temp = PatientInfo\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=1,\n                     specs=[[{'type':'domain'}]])\ncol = 1\n\ngrp = temp.groupby(['city'])\nprint(grp.size())\nvals = dict(grp.size())\nsum_val = 0\nto_plot = {}\nfor key in vals:\n  sum_val += vals[key]\nfor key in vals:\n  to_plot[key] = (vals[key]\/sum_val) * 100\n    \nfig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                      values=list(to_plot.values()),\n                      name=\"Cities\"),\n                row=1, col=col)\n\nfig1.update_layout(title_text=\"Cities\")\npy.offline.iplot(fig1)","db2e39e5":"temp = PatientInfo\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=1,\n                     specs=[[{'type':'domain'}]])\ncol = 1\n\ngrp = temp.groupby(['province'])\nprint(grp.size())\nvals = dict(grp.size())\nsum_val = 0\nto_plot = {}\nfor key in vals:\n  sum_val += vals[key]\nfor key in vals:\n  to_plot[key] = (vals[key]\/sum_val) * 100\n    \nfig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                      values=list(to_plot.values()),\n                      name=\"Provinces\"),\n                row=1, col=col)\n\nfig1.update_layout(title_text=\"Provinces\")\npy.offline.iplot(fig1)","e6d0b945":"temp = PatientInfo\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=1,\n                     specs=[[{'type':'domain'}]])\ncol = 1\n\ngrp = temp.groupby(['state'])\nprint(grp.size())\nvals = dict(grp.size())\nsum_val = 0\nto_plot = {}\nfor key in vals:\n  sum_val += vals[key]\nfor key in vals:\n  to_plot[key] = (vals[key]\/sum_val) * 100\n    \nfig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                      values=list(to_plot.values()),\n                      name=\"States\"),\n                row=1, col=col)\n\nfig1.update_layout(title_text=\"States\")\npy.offline.iplot(fig1)","22ea8c74":"temp = PatientInfo\ntemp = temp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=1,\n                     specs=[[{'type':'domain'}]])\ncol = 1\n\ngrp = temp.groupby(['sex'])\nprint(grp.size())\nvals = dict(grp.size())\nsum_val = 0\nto_plot = {}\nfor key in vals:\n  sum_val += vals[key]\nfor key in vals:\n  to_plot[key] = (vals[key]\/sum_val) * 100\n    \nfig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                      values=list(to_plot.values()),\n                      name=\"Sexes\"),\n                row=1, col=col)\n\nfig1.update_layout(title_text=\"Sexes\")\npy.offline.iplot(fig1)","8787d118":"sizes = list(\n    PatientRoute[['longitude', 'latitude']].groupby(\n        ['longitude', 'latitude']).size())\nfig = go.Figure(data=go.Scattergeo(\n        lon = PatientRoute['longitude'],\n        lat = PatientRoute['latitude'],\n        mode = 'markers'\n        ))\nfig.update_layout(\n        title = 'Infected cordinates',\n        geo_scope='asia'\n    )\npy.offline.iplot(fig)","9ec61113":"fp = SeoulFloating[['city', 'fp_num']]\nfp = fp.fillna('Unknown')\nfig1 = make_subplots(rows=1, cols=1,\n                     specs=[[{'type':'domain'}]])\ncol = 1\n\ngrp = fp.groupby(['city'])\nvals = pd.DataFrame(grp.sum().reset_index())\nsum_val = 0\nto_plot = {}\nfor item in vals['fp_num']:\n  sum_val += item\nkey = vals['city']\nfor item in range(len(vals['fp_num'])):\n  key = vals['city'].iloc[item]\n  to_plot[key] = (int(vals['fp_num'].iloc[item])\/sum_val) * 100\n    \nfig1.add_trace(go.Pie(labels=list(to_plot.keys()),\n                      values=list(to_plot.values()),\n                      name=\"Cities\"),\n                row=1, col=col)\n\nfig1.update_layout(title_text=\"Cities\")\npy.offline.iplot(fig1)","cbc829b2":"time_df = Time[['test', 'negative', 'released',\n       'deceased', 'confirmed']]\n\ndef create_dataset(dataset, look_back=1):\n    dataX, dataY = [], []\n    for i in range(len(dataset) - look_back - 1):\n        a = dataset[i:(i + look_back), :]\n        dataX.append(a)\n        dataY.append(dataset[i + look_back, 2])\n    return np.array(dataX), np.array(dataY)\n\ndataset = time_df.values\nscaler = MinMaxScaler(feature_range=(0, 1))\ndataset = scaler.fit_transform(dataset)\ntrain_size = int(len(dataset) * 0.7) \ntest_size = len(dataset) - train_size\ntrain, test = dataset[0:train_size, :], dataset[train_size:len(dataset), :]\n\n\nlook_back = 10\ntrainX, trainY = create_dataset(train, look_back)  \ntestX, testY = create_dataset(test, look_back)\n\ntrainX = np.reshape(trainX, (trainX.shape[0], look_back, 5))\ntestX = np.reshape(testX, (testX.shape[0],look_back, 5))\n\n\nmodel = Sequential()\nmodel.add(LSTM(5, return_sequences=True, input_shape=(look_back, 5)))\nmodel.add(LSTM(5, return_sequences=True, input_shape=(look_back, 5)))\nmodel.add(LSTM(5, return_sequences=True, input_shape=(look_back, 5)))\nmodel.add(LSTM(5, return_sequences=True, input_shape=(look_back, 5)))\nmodel.add(LSTM(5, input_shape=(look_back, 5)))\nmodel.add(Dense(1))\nmodel.compile(loss='mean_squared_error', optimizer='sgd')\nhistory= model.fit(trainX, trainY, validation_split=0.33, nb_epoch=200,\n                   batch_size=32)","0c3b6098":"#Make new prediction\nlook_back = 10\nx, y = create_dataset(dataset, look_back)\nx = np.reshape(x, (x.shape[0], look_back, 5))\n\npredicted = model.predict(x)","3b93cbe8":"fig = go.Figure()\nfig.add_trace(go.Scatter(x=Time['date'], y=y,\n                    mode='lines',\n                    name='Original'))\nfig.add_trace(go.Scatter(x=Time['date'], y=predicted.reshape(y.shape),\n                    mode='lines',\n                    name='Predicted'))\npy.offline.iplot(fig)","7148e811":"# First we take a look at patients data\nRemove some not-needed columns then perform our analysis","915fd985":"We see that the predition is very unstable and wrong. It can be improved by changing lstm layers, adding activation and especially more samples. Here, we just wanted to make a simple prediction.","75b53bab":"Alright, now we want to perform some time series analysis.\n\nWe should define our look back, out lstm and then train it.","7f6d7901":"Now we want to perform some analysis on floating population","6301cfb9":"Now we are going to plot some columns based on each cluster","b007516b":"Now we performed some analysis on Patient Info dataset. \n\nThese graphs shows the statistics of patients.\n\nNow we are going to next dataset for analysis.","89c7ebf4":"Now we have floating population percentage of whole floating population.","d53c2732":"**Now we want to visualize original Patient info dataset**\n\nThese visualizations are not based on clusters."}}