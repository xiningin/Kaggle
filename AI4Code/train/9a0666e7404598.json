{"cell_type":{"47586070":"code","e213c674":"code","ed8c4f7e":"code","3eef877e":"code","bf39d441":"markdown","0d9c7394":"markdown","03bae591":"markdown"},"source":{"47586070":"# Input your groups of people, Each group (e.g. family) as one list\n# e.g. \n# groups_of_people = [[\"Amy\",\"Anthony\"],[\"Bob\",\"Betty\",\"Bill\"],[\"Carly\",\"Charlie\",\"Colin\",\"Cooper\"],[\"David\"]]\ngroups_of_people = [[\"Amy\",\"Anthony\"],[\"Bob\",\"Betty\",\"Bill\"],[\"Carly\",\"Charlie\",\"Colin\",\"Cooper\"],[\"David\"]]","e213c674":"#Initialise some variables\npeople = []\ngroup_dict = {} \ngroup_number =-1\n\n#Pull out names of the people in groups and create a dictionary to store group membership\nfor group in groups_of_people:\n    group_number += 1\n    for person in group:\n        people.append(person)\n        if person not in group_dict.keys():\n            group_dict[person]= group_number\n        else:\n            print (\"ERROR - Duplicate name found in input: \" + person)\n            break\n            \n#Create a copy of your list of people to randomise\ncopy_people = people[:]                   ","ed8c4f7e":"#Keep shuffling copy_people until a possible match is found, \n#The code settles on the first permutation where \n# - Each person is matched with one other that is not in their group \n# and \n# - There are no symmetric matches (i.e. two people buying for each other)\n\nimport random\n\npossible_match = False\n\nbuying_dict = {}\n\nwhile possible_match != True:\n    \n    random.shuffle(copy_people)\n    \n    for i in range(len(people)):\n        buying_dict[people[i]]=copy_people[i]\n    \n    \n    #assume a match until conflict found\n    possible_match = True\n     \n    for person in buying_dict.keys():\n        \n        #Check that people don't get matched with themselves or anyone else in their group, e.g. buying for siblings that they would already buy for\n        if group_dict[person] == group_dict[buying_dict[person]]:\n            possible_match = False\n            buying_dict = {}\n            break\n            \n        #Check that there are no symmetric relationships, i.e. a->b and b->a \n        if buying_dict[person] == buying_dict[buying_dict[person]]:\n            possible_match = False\n            buying_dict = {}\n            break\n\n","3eef877e":"#Put results into a table\nimport pandas as pd\n\ndf = pd.DataFrame()\ndf[\"Buyer\"] = people\ndf[\"Buying_for\"] = copy_people\ndf","bf39d441":"![](https:\/\/media1.giphy.com\/media\/3ofT5EtPNBpIjC8jTy\/giphy.gif?cid=ecf05e471j5lpo88aiyejuby8m4tyupc9lfthjoab4tz7yjc&rid=giphy.gif&ct=g)","0d9c7394":"![](https:\/\/media1.giphy.com\/media\/2IfqRSy8jfOVO\/giphy.gif?cid=ecf05e47gi7bfiv7ulnnq6ds229zg1jxvighb3t8j9bvd5pc&rid=giphy.gif&ct=g)","03bae591":"<h2>Secret Santa Draw<\/h2>\n<p>The Notebooks allows you to enter a list of people into a secret santa draw who come from existing groups (e.g. families, households) that you do not want to get matched with one another (usually because they are buying for each other already). You can use it for a simple list of friends by having one person in each group.<\/p>\n<p>Start by defining the groups_of_people variable by typing in the names of individuals in groups as a list of lists. If you have any duplicate names be sure to add initials or nicknames so they can be distinguished.<\/p>\n<p>Once you've entered all the names, run all the cells to get to the output table.<\/p>"}}