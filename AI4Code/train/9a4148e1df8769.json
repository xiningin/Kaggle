{"cell_type":{"761d1507":"code","e6ea69e0":"code","99fcfcc6":"code","ca122ef7":"code","14d04484":"code","a2aa2229":"code","2bfc8cfd":"code","0e6af594":"code","cc20be64":"code","13464e35":"markdown"},"source":{"761d1507":"from tqdm import tqdm\nimport numpy as np\nimport itertools\nfrom collections import defaultdict\nimport math\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nimport warnings\nwarnings.filterwarnings('ignore')","e6ea69e0":"np.random.seed(42)","99fcfcc6":"# Read our input\nwith open('..\/input\/hashcode-photo-slideshow\/d_pet_pictures.txt', 'r') as ifp:\n    lines = ifp.readlines()\n\nphotos = []\nall_tags = list()\nphotos_per_tag = defaultdict(list)\nfor i, line in enumerate(lines[1:]):\n    orient, _, *tags = line.strip().split()\n    photos.append((orient, set(tags)))\n    for tag in tags:\n        photos_per_tag[tag].append(i)","ca122ef7":"def cost(tags1, tags2):\n    intersect = len(tags1.intersection(tags2))\n    return min(len(tags1) - intersect, len(tags2) - intersect, intersect)\n\ndef cost2(photo1, photo2):\n    if isinstance(photo1, tuple):\n        tags1 = photos[photo1[0]][1].union(photos[photo1[1]][1])\n    else:\n        tags1 = photos[photo1][1]\n        \n    if isinstance(photo2, tuple):\n        tags2 = photos[photo2[0]][1].union(photos[photo2[1]][1])\n    else:\n        tags2 = photos[photo2][1]\n        \n    return cost(tags1, tags2)\n\ndef sequence_cost(sequence):\n    total_cost = 0\n    for i in range(len(sequence) - 1):\n        if sequence[i + 1] == -1:\n            break\n            \n        if isinstance(sequence[i], tuple):\n            old_tags = photos[sequence[i][0]][1].union(photos[sequence[i][1]][1])\n        else:\n            old_tags = photos[sequence[i]][1]\n            \n        if isinstance(sequence[i + 1], tuple):\n            new_tags = photos[sequence[i + 1][0]][1].union(photos[sequence[i + 1][1]][1])\n        else:\n            new_tags = photos[sequence[i + 1]][1]\n            \n        total_cost += cost(old_tags, new_tags)\n    return total_cost","14d04484":"# Read our submission\nwith open('..\/input\/hashcode-greedy-solution-415k\/submission.txt', 'r') as ifp:\n    lines = ifp.readlines()\n\nsequence = []\nfor i, line in enumerate(lines[1:]):\n    if ' ' in line:\n        sequence.append(tuple(map(int, line.strip().split())))\n    else:\n        sequence.append(int(line.strip()))\n        \nprint(sequence_cost(sequence))","a2aa2229":"SUBSEQ_LEN = 5000\nTIME_LIMIT = 300\n\nnew_sequence = sequence[:]\nfor i in range(len(sequence) \/\/ SUBSEQ_LEN):\n    print('Swapping in block {}\/{}'.format(i + 1, len(sequence) \/\/ SUBSEQ_LEN))\n    subsequence = sequence[i*SUBSEQ_LEN:(i + 1)*SUBSEQ_LEN]\n    COSTS = {}\n    for r in range(len(subsequence)):\n        COSTS[r + 1] = {}\n        for c in range(len(subsequence)):\n            # TSP will minimize costs, but we want to maximize. This is a simple hack\n            COSTS[r + 1][c + 1] = 1000-cost2(subsequence[r], subsequence[c])\n            \n    # 0 will be a dummy starting location. We use the last element of the previous\n    # subsequence as starting point to determine the costs and the first element\n    # of the next subsequence as ending point.\n    COSTS[0] = {}\n    COSTS[0][0] = 0\n    for c in range(len(subsequence)):\n        COSTS[0][c + 1] = 0\n        COSTS[c + 1][0] = 0\n    if i == 0:\n        for c in range(len(subsequence)):\n            COSTS[c + 1][0] = cost2(subsequence[c], new_sequence[(i + 1)*SUBSEQ_LEN])\n    elif i == len(sequence) \/\/ SUBSEQ_LEN - 1:\n        for c in range(len(subsequence)):\n            COSTS[0][c + 1] = cost2(new_sequence[i*SUBSEQ_LEN - 1], subsequence[c])\n    else:\n        for c in range(len(subsequence)):\n            COSTS[0][c + 1] = cost2(new_sequence[i*SUBSEQ_LEN - 1], subsequence[c])\n            COSTS[c + 1][0] = cost2(subsequence[c], new_sequence[(i + 1)*SUBSEQ_LEN])\n        \n    old_score = sequence_cost(subsequence)\n    print('Old score = {}'.format(old_score))\n            \n    \"\"\"Entry point of the program.\"\"\"\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(len(subsequence), 1, [0], [0])\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    distance_matrix = COSTS\n\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return distance_matrix[from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting initial solution (the order is just 1 until SUBSEQ_LEN (included))\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    initial_solution = routing.ReadAssignmentFromRoutes([list(range(1, SUBSEQ_LEN + 1))], True)\n    search_parameters.time_limit.seconds = TIME_LIMIT\n\n    # Solve the problem.\n    solution = routing.SolveFromAssignmentWithParameters(initial_solution, search_parameters)\n    \n    indices = [routing.Start(0)]\n    while not routing.IsEnd(indices[-1]):\n        indices.append(solution.Value(routing.NextVar(indices[-1])))\n\n    # i - 1 because our 0 corresponds to the dummy and 1 corresponds to sequence[0]\n    new_sub_sequence = [subsequence[i - 1] for i in indices[1:]]   \n    new_score = sequence_cost(new_sub_sequence)\n    print('New score = {}'.format(new_score))\n    \n    # The swapping could reduce the score due to the transitions of the\n    # beginning and ending of the subsequence in the total sequence\n    if new_score > old_score:\n        new_sequence = new_sequence[:i*SUBSEQ_LEN] + new_sub_sequence + new_sequence[(i + 1)*SUBSEQ_LEN:]\n    \n    total_score = sequence_cost(new_sequence)\n    print('Current score = {}'.format(total_score))","2bfc8cfd":"print(sequence_cost(new_sequence))","0e6af594":"with open('submission.txt', 'w+') as ofp:\n    ofp.write('{}\\n'.format(sum(np.array(new_sequence) != -1)))\n    for p in new_sequence:\n        if p == -1:\n            break\n            \n        if isinstance(p, tuple):\n            ofp.write('{} {}\\n'.format(p[0], p[1]))\n        else:\n            ofp.write('{}\\n'.format(p))","cc20be64":"# CHECKS:\n# 1) We dont want duplicates\n# 2) We want vertical pictures to always be paired with another vertical picture\n# 3) We don't want horizontal pictures to be paired\n# 4) Preferably, we assign all of the pictures to slides\n# 5) We cannot assign a picture to two different slides\ndone = set()\nfor i, p in enumerate(new_sequence):\n    if p == -1:\n        break\n    if isinstance(p, tuple):\n        assert p[0] != p[1]\n        assert p[0] not in done\n        assert photos[p[0]][0] == 'V'\n        done.add(p[0])\n        \n        assert p[1] not in done\n        assert photos[p[1]][0] == 'V'\n        done.add(p[1])\n    else:\n        assert p not in done\n        assert photos[p][0] == 'H'\n        done.add(p)\nprint(i, len(done))\nprint(set(range(len(photos))) - done)","13464e35":"# Local neighborhood search (swapping) by solving the Traveling Salesman Problem\n\nIn this notebook, I show how we can iteratively improve our solution by taking subsequences and then solving the TSP (using Google OR-Tools) on that subsequence. This already improves a strong greedy solution, but is still not yet optimal due to the fact that I only swap the order of (subsequences of) slides around. I will not look for better pairs of vertical photos to put on a slide.\n\nYou can play around with the hyper-parameters `SUBSEQ_LEN` and `TIME_LIMIT` to get a better score.\n\nThe initial greedy solution was generated in [this notebook](https:\/\/www.kaggle.com\/group16\/greedy-solution-lb-400k).\n\n**If you like the notebook, or you use it for your submission, please do not forget to upvote it! I do not like to ask for this, but apparently it is needed in this competition... (My previous notebook has more forks than upvotes)**"}}