{"cell_type":{"649ef473":"code","2e1d9289":"code","b83023ed":"code","7b699a2e":"code","1ed21337":"code","3b604b19":"code","b56113b3":"code","19a22096":"code","b47828d7":"code","40b67e28":"code","0331db29":"code","8cd6213c":"code","91fabe3d":"code","c4816d1b":"code","c947d6f3":"code","f92227bc":"code","6928a812":"code","f0dbb747":"code","b24f1238":"code","b4b379e3":"code","7c70635e":"code","60d25eac":"code","ec1198d1":"code","1a606ef9":"markdown","bc6c8ae2":"markdown","905a56da":"markdown","7088a5f7":"markdown","f0ff6867":"markdown","b65d31fe":"markdown","2301aa53":"markdown","a8de903f":"markdown","03dcd3f2":"markdown","daa80eaa":"markdown","487104a9":"markdown","da8f4990":"markdown","4db248f9":"markdown","b6f265fb":"markdown","09ec1df5":"markdown","4550faae":"markdown","667db1ce":"markdown","ba4c6f1b":"markdown","1c1c38c7":"markdown","d2218319":"markdown","afe4f931":"markdown","bf9d395c":"markdown","4c6a1ece":"markdown","626c5a07":"markdown","0acfce6b":"markdown","255a903c":"markdown","efe97f40":"markdown","d960a0d8":"markdown","a670bfb4":"markdown","70c44db7":"markdown","d5a1cfa8":"markdown","85bee93a":"markdown","261ae533":"markdown","7d8aa05f":"markdown"},"source":{"649ef473":"import numpy as np\nimport pandas as pd ","2e1d9289":"def create_user_movie_df():\n    movie = pd.read_csv('..\/input\/movielens-20m-dataset\/movie.csv')\n    rating = pd.read_csv('..\/input\/movielens-20m-dataset\/rating.csv')\n    df = movie.merge(rating, how=\"left\", on=\"movieId\")\n    comment_counts = pd.DataFrame(df[\"title\"].value_counts())\n    rare_movies = comment_counts[comment_counts[\"title\"] <= 1000].index\n    common_movies = df[~df[\"title\"].isin(rare_movies)]\n    user_movie_df = common_movies.pivot_table(index=[\"userId\"], columns=[\"title\"], values=\"rating\")\n    return user_movie_df","b83023ed":"user_movie_df = create_user_movie_df()\nuser_movie_df.head()","7b699a2e":"def get_movies_df_by_userId(dataframe, userId):\n    random_user_df = dataframe[dataframe.index == userId]\n    return random_user_df.columns[random_user_df.notna().any()].tolist()","1ed21337":"random_user = 108170\n\nmovies_watched = get_movies_df_by_userId(user_movie_df, random_user)","3b604b19":"len(movies_watched)","b56113b3":"movies_watched_df = user_movie_df[movies_watched]","19a22096":"user_movie_count = movies_watched_df.T.notnull().sum()\nuser_movie_count = user_movie_count.reset_index()\nuser_movie_count.columns = [\"userId\", \"movie_count\"]\nuser_movie_count.head()","b47828d7":"perc = len(movies_watched) * 60 \/ 100\nusers_same_movies = user_movie_count[user_movie_count[\"movie_count\"] > perc][\"userId\"]\nusers_same_movies.head()","40b67e28":"len(users_same_movies)","0331db29":"final_df = movies_watched_df[movies_watched_df.index.isin(users_same_movies)]","8cd6213c":"final_df.head()","91fabe3d":"corr_df = final_df.T.corr().unstack().sort_values()\ncorr_df = pd.DataFrame(corr_df, columns=[\"corr\"])\ncorr_df.index.names = ['user_id_1', 'user_id_2']\ncorr_df = corr_df.reset_index()","c4816d1b":"corr_df.head()","c947d6f3":"top_users = corr_df[(corr_df[\"user_id_1\"] == random_user) & (corr_df[\"corr\"] >= 0.65)][\n    [\"user_id_2\", \"corr\"]].reset_index(drop=True)","f92227bc":"top_users = top_users.sort_values(by='corr', ascending=False)","6928a812":"top_users.head()","f0dbb747":"top_users.rename(columns={\"user_id_2\": \"userId\"}, inplace=True)","b24f1238":"rating = pd.read_csv('..\/input\/movielens-20m-dataset\/rating.csv')\ntop_users_ratings = top_users.merge(rating[[\"userId\", \"movieId\", \"rating\"]], how='inner')\ntop_users_ratings = top_users_ratings[top_users_ratings[\"userId\"] != random_user]\ntop_users_ratings.head()","b4b379e3":"top_users_ratings['weighted_rating'] = top_users_ratings['corr'] * top_users_ratings['rating']\ntop_users_ratings.head()","7c70635e":"recommendation_df = top_users_ratings.groupby('movieId').agg({\"weighted_rating\": \"mean\"})\nrecommendation_df = recommendation_df.reset_index()\nrecommendation_df.head()","60d25eac":"movies_to_be_recommend = recommendation_df[recommendation_df[\"weighted_rating\"] > 3.5].sort_values(\"weighted_rating\",\n                                                                                                 ascending=False).head()\nmovies_to_be_recommend.head()","ec1198d1":"movie = pd.read_csv('..\/input\/movielens-20m-dataset\/movie.csv')\nmovies_to_be_recommend.merge(movie[[\"movieId\", \"title\"]]).index\n\nmovies_to_be_recommend.merge(movie[[\"movieId\", \"title\"]])[\"title\"]","1a606ef9":"We have made a user-based collaborative filtering method according to both the correlation between customers and the rates given to the movies. \n\nCollaborative filtering approaches are commonly classified into two main categories: model-based approaches and memory-based approaches. Model-based approaches build statistical models of user\/item rating patterns that provide automatic rating predictions. Memory-based approaches, in turn, can be user-based or item-based.[3]\n\nUser-based algorithms are built on the principle that a particular user\u2018s rating records are not equally useful to all other users as input to provide them with item suggestions.\n\nThe first step in UbCF is to find the set of users that are most similar to the target user. Target user\u2019s rating for the target item is then predicted using the ratings given to the target item by these nearest\/most similar neighbours\/users.[4]\n\nAlthough we have reached a very satisfactory conclusion here, in some cases all collaborative methods alone cannot be sufficient. There may be instances where all methods produce particularly beneficial results. For this reason, each recommendation system can be optimized according to the ideal situation and used in a hybrid way.","bc6c8ae2":"User-based filtering is a system that takes into account the similarity of user tastes. If two users have bought joint products, it is based on the probability that the other user will also receive a product purchased later. According to the scores of the users, the prediction is made as a result of the pearson correlation or cosine similarity methods.","905a56da":"![image.png](attachment:818d68a9-eba6-4f6c-8afe-3aac63f285b0.png)","7088a5f7":"**Similarity of Users**","f0ff6867":"We rank movies according to their weighted rating.","b65d31fe":"# CONCLUSION","2301aa53":"**We examine the correlation between all users in this final_df where users are located according to the thereshold we have determined. So we can find the user most similar to random_user.**","a8de903f":"# Calculating the Weighted Average Recommendation Score","03dcd3f2":"# USER-BASED COLLABORATIVE FILTERING","daa80eaa":"We just get the Transpose of this df which consists of movies random_user watched. Thus, we bring in how many of these movies other users have watched.","487104a9":"To focus on the movies that the user has watched, we just select those movies from user_movie_df","da8f4990":"# STEP - 2","4db248f9":"We got a matrix with the user numbers in the rows and all the movies in the columns. The values in this matrix are the **ratings** given to that user if he has watched the movie. If there is no score, the user has not watched that movie.","b6f265fb":"# STEP - 1","09ec1df5":"Advantages:\n\n* Easy to implement.\n\n* Context independent.\n\n* Compared to other techniques, such as content-based, it is more accurate.\n\n\nDisadvantages:\n\n* Sparsity: The percentage of people who rate items is really low.\n\n* Scalability: The more K neighbors we consider (under a certain threshold), the better my classification should be.\n\n* Nevertheless, the more users there are in the system, the greater the cost of finding the nearest K neighbors will be.\n\n* Cold-start: New users will have no to little information about them to be compared with other users.\n\n* New item: Just like the last point, new items will lack of ratings to create a solid ranking","4550faae":"Movies watched by 2326 users with random_user are at least 60 percent identical","667db1ce":"I set the similarity rate limit to random_user at 60 percent. I want to bring users who watch the same movies at least 60 percent of the time.","ba4c6f1b":"**Creating User Movie DF**","1c1c38c7":"Step 1: Find people who watch 60 percent or more of the same movies with target user.\n\nStep 2: Choose the ones closest to to target user according to his\/her likes.\n\nStep 3: Suggest the movies according to weighted movie rating.","d2218319":"[1] https:\/\/www.geeksforgeeks.org\/user-based-collaborative-filtering\/\n\n[2] Thakkar, P., Varma, K., Ukani, V., Mankad, S., & Tanwar, S. (2019). Combining user-based and item-based collaborative filtering using machine learning. In Information and Communication Technology for Intelligent Systems (pp. 173-180). Springer, Singapore.\n\n[3] Bellog\u00edn, A., Castells, P., & Cantador, I. (2014). Neighbor selection and weighting in user-based collaborative filtering: a performance prediction approach. ACM Transactions on the Web (TWEB), 8(2), 1-30.\n\n[4] Thakkar, P., Varma, K., Ukani, V., Mankad, S., & Tanwar, S. (2019). Combining user-based and item-based collaborative filtering using machine learning. In Information and Communication Technology for Intelligent Systems (pp. 173-180). Springer, Singapore.\n\n","afe4f931":"Let's examine the first 5 rows of the table, including the correlation values between the two users.","bf9d395c":"Let's choose a random user number that we want to suggest a movie. For example, user 108170.\n\nThen we will bring the movies watched by the random_user using the function we defined.","4c6a1ece":"I also set the lower limit of the correlation value between two users as 65 percent. And I rank all users according to their correlation with random_user.","626c5a07":"We turn movies_watched_df to the final_df which contains the users who are at least 60 percent similar users to random_user, which is a more customized version of the original user_movie_df, where only the movies random_user watched.","0acfce6b":"# REFERENCES","255a903c":"# Determining the Users to be Suggested and Most Similar Users","efe97f40":"From the length of the returned list, we see that random_user has rated 186 movies.","d960a0d8":"User-Based Collaborative Filtering is a technique used to predict the items that a user might like on the basis of ratings given to that item by the other users who have similar taste with that of the target user.\nMany websites use collaborative filtering for building their recommendation system. [1]","a670bfb4":"In order to see the names of the recommended movies, we merge the movies_to_be_recommended df with the movie df and list 5 of the movies.","70c44db7":"![image.png](attachment:6e37a7c3-ab2d-4179-bbec-7edfd84218b5.png)","d5a1cfa8":"# STEP - 3","85bee93a":"**We brought users with high correlation, but here is another critical point:**\n\n**If we only bring the users based on user similarity, however there is also a probability of recommending a movie that a is disliked by the user who is very similar to random_user. That's why we have to take movie ratings into account here. Thus, high-rated movies will also affect the recommendation here. We will multiply the Movie Rating and Correlation columns and use the weights of both to make a ranking. We will be recommending the movies with that calculated new weighted_ratings.**","261ae533":"    Previously, we performed movie recommendation with item-based collaborative filtering considering only the ratings of the movies rated by the users. In this notebook, we will recommend movies to users-based method on the ratings they have given to movies.\n\nCollaborative filtering can work on websites where there is not much information about the items and it is difficult for a computer system to analyze the content, such as views. It can also suggest items relevant to a user, even if the user's profile does not contain content. Recommendation systems have been popular in many industries such as movies, music, e-commerce and even banking. They are useful for helping customers find products they want to buy, launch new products, drive insights and innovations, build customer loyalty and growth, increase customer lifetime value, reshape human behavior, and more.","7d8aa05f":"Similar customers are tried to be associated and products are presented based on the products that customers choose. It is quite effective but takes time and resources. This type of filtering requires analyzing the information of both types of customers. Therefore, it is difficult to implement this algorithm for large platforms."}}