{"cell_type":{"1bc718eb":"code","4ab0c8db":"code","61d9c9dc":"code","a60aeaab":"code","58aa14a0":"code","6069466b":"code","f0516e12":"code","b47ade76":"code","d4f9875f":"code","949a8490":"code","636c8f7a":"code","77e1522a":"code","b02275af":"code","92cc01b0":"code","02470dd4":"code","0b0b595b":"code","f1a21bf1":"code","272fe7e6":"markdown","0b4af895":"markdown","7b382f78":"markdown","bef2a8f4":"markdown","edf214c9":"markdown","a2af5254":"markdown","a89e458c":"markdown","409dec8d":"markdown","3851c6c6":"markdown","e6e962b5":"markdown"},"source":{"1bc718eb":"# numpy for numerical representations\nimport numpy as np\n# pyplot for plotting and image showing\nfrom matplotlib import pyplot as plt","4ab0c8db":"# Now we define a function to perform linear transformation.\ndef linear_transformation(src, a):\n    '''\n    linear transformation of a matrix is simply a mutation of PLACES in that matrix.\n    \n    '''\n    # get shape of input images\n    M, N = src.shape\n    # get points as matrix of LOCATION in the images\n    points = np.mgrid[0:N, 0:M].reshape((2, M*N))\n    # use the dot product to transform the LOCATION of values in image\n    new_points = np.linalg.inv(a).dot(points).round().astype(int)\n\n    # get x,y as the new location on x axis and y axis\n    x, y = new_points.reshape((2, M, N), order='F')\n    # transform x,y to 1-D indices\n    indices = x + N*y\n    # put each value to its new place\n    return np.take(src, indices, mode='wrap')","61d9c9dc":"# create a image\n# start with size 200x200\nimages = np.ndarray(shape=(200,200))\n# for easy illustration, this image will be images with a different color in each quarter\n# so we assign a different value for each quarter of the images\n# first quarter\nimages[:100, :100] = 1\n# second quarter\nimages[:100, 101:] = 2\n# third quarter\nimages[101:, :100] = 3\n# forth quarter\nimages[101:, 101:] = 4\n\n# convert image to range 0-255 (natural representation of single channel images)\nimages = ((images \/ np.max(images)) * 255).astype(np.uint8)","a60aeaab":"# use plt.imshow() function to show image\n# i choose summer colormap because i like it\nplt.imshow(images, cmap='summer')","58aa14a0":"# define a transformation matrix\n# this matrix will dilate the images by 1.5 in x axis\ntransformation_matrix = np.array([[1.5, 0],\n                                  [0, 1]])","6069466b":"# call function to perform transformation\ntransformed_image = linear_transformation(images, transformation_matrix)","f0516e12":"# show the transformed image\nplt.imshow(transformed_image, cmap='summer')","b47ade76":"# call function to perform transformation\ntransformed_image = linear_transformation(transformed_image, np.linalg.inv(transformation_matrix))","d4f9875f":"# show the transformed image\nplt.imshow(transformed_image, cmap='summer')","949a8490":"transformation_matrix = np.array([[1, 0],\n                                  [0, 1.5]])","636c8f7a":"transformation_matrix = np.array([[1.5, 0],\n                                  [0, 1.5]])","77e1522a":"transformation_matrix = np.array([[0.5, 0],\n                                  [0, 0.5]])","b02275af":"transformation_matrix = np.array([[1, 1],\n                                  [0, 1]])","92cc01b0":"transformation_matrix = np.array([[1, 0],\n                                  [1, 1]])","02470dd4":"transformation_matrix = np.array([[-1, 0],\n                                  [0, 1]])","0b0b595b":"transformation_matrix = np.array([[1, 0],\n                                  [0, -1]])","f1a21bf1":"transformation_matrix = np.array([[-1, 0],\n                                  [0, -1]])","272fe7e6":"### Dilate y-axis","0b4af895":"First we import some library we are going to use.","7b382f78":"### Vertical flip matrix","bef2a8f4":"### Horizontal flip matrix","edf214c9":"### Diagonal flip matrix","a2af5254":"### Shrink both axis","a89e458c":"### Upper triangular matrix","409dec8d":"### Dilate both axis","3851c6c6":"# Some other transformation matrices","e6e962b5":"### Lower triangular matrix"}}