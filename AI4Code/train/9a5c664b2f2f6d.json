{"cell_type":{"11f8e0d7":"code","e82dda9f":"code","dc9067cb":"code","da325878":"code","a40fa1f3":"code","a1cba70d":"code","11629fdd":"code","c11104bc":"code","e293a66f":"code","b44f13f2":"code","d3f35074":"markdown","2a2aee19":"markdown","c787ce78":"markdown","c14753fa":"markdown","6ea70b81":"markdown","b41ff51b":"markdown","f113da83":"markdown","9df48e94":"markdown","10a875a8":"markdown","c97b65e1":"markdown"},"source":{"11f8e0d7":"\n\"\"\"\nCode based on resorces from:\nhttps:\/\/inst.eecs.berkeley.edu\/~ee123\/sp16\/Sections\/JPEG_DCT_Demo.html\nhttps:\/\/github.com\/gk7huki\/pydct\/blob\/master\/dct.py\nhttps:\/\/www.nayuki.io\/page\/fast-discrete-cosine-transform-algorithms\nhttps:\/\/www.youtube.com\/watch?v=mGWSbGoMrI4\nhttps:\/\/stackoverflow.com\/questions\/13171329\/dct-2d-without-fft\nhttps:\/\/cs.stanford.edu\/people\/eroberts\/courses\/soco\/projects\/data-compression\/lossy\/jpeg\/dct.htm\n\"\"\"\n# Import all relevant libraries here:\n\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy\nfrom scipy import misc\nimport math\nfrom numpy import r_\nfrom skimage import io\nfrom math import cos","e82dda9f":"# Load in the image\nf = io.imread('..\/input\/zelda.png', as_gray=True)\nprint('image matrix size: ', f.shape )\n\n# Sample smaller size. NOTE, you can comment this out if you want to process the entire image\npos = 175\nsize = 256\nf = f[pos:pos+size,pos:pos+size]\n\n# Let's see how she looks!\nplt.imshow(f, cmap=plt.cm.gray)\nplt.axis('off')\nplt.show()\n","dc9067cb":"# Initialize some parameters \n\nn = 8  # This will be the window in which we perform our DCT\nsumd = 0 # INI value\n\n# Create some blank matrices to store our data\n\ndctmatrix = np.zeros(np.shape(f)) # Create a DCT matrix in which to plug our values :)\nf = f.astype(np.int16) # Convert so we can subtract 128 from each pixel\nf = f-128 # As said above\nf2 = np.zeros(np.shape(f)) # This will be where the compressed image goes\n\n# Let's preview our f values\nf","da325878":"def cosp(i,j,n): # This is the funky cos function inside the DCT\n    output = 0\n    output = cos(((2*i)+1)*j*math.pi\/(2*n))\n    return output","a40fa1f3":"def convolveDCT(f,n,u,v,a,b): # This convolve function compute DCT for nxn @ axb location\n    sumd = 0                               #INI value\n    for x in r_[0:n]:\n        for y in r_[0:n]:\n            u = u%n\n            v = v%n\n            sumd += f[x+a,y+b]*cosp(x,u,n)*cosp(y,v,n)\n    # Now, need to perform the functions outside of the sum values    \n    if u == 0: sumd *= 1\/math.sqrt(2) \n    else: sumd *= 1\n    if v == 0: sumd *= 1\/math.sqrt(2)\n    else: sumd *= 1\n    sumd *= 1\/math.sqrt(2*n)\n\n    return sumd","a1cba70d":"# First we need to take into account our multiple nxn windows that jump across the image\nfor a in r_[0:np.shape(f)[0]:n]:\n    for b in r_[0:np.shape(f)[1]:n]:\n        # Below, compute the DCT for a given uxv location in the DCT Matrix\n        for u in r_[a:a+n]:\n            for v in r_[b:b+n]:\n                dctmatrix[u,v] = convolveDCT(f,n,u,v,a,b)\n# Let's take our first peek at the DCT \nnp.around(dctmatrix)","11629fdd":"# Display entire DCT\nplt.figure()\nplt.imshow(dctmatrix,cmap='gray',vmax = np.max(dctmatrix)*0.01,vmin = 0)\nplt.title(\"8x8 DCTs of the image\")","c11104bc":"# Now, let's manipulate stuff a bit. Here, we will use a standard quant table to compress image\nQuant = np.array([\n  [16, 11, 10, 16, 24, 40, 51, 61],\n  [12, 12, 14, 19, 26, 58, 60, 55],\n  [14, 13, 16, 24, 40, 57, 69, 56],\n  [14, 17, 22, 29, 51, 87, 80, 62],\n  [18, 22, 37, 56, 68, 109, 103, 77],\n  [24, 35, 55, 64, 81, 104, 113, 92],\n  [49, 64, 78, 87, 103, 121, 120, 101],\n  [72, 92, 95, 98, 112, 100, 103, 99]\n])\n\n# Convolve nxn sections across entire image to return    \n# As factor variable increases, the image will compress even more\nfactor = 4\nfor a in r_[0:np.shape(f)[0]:n]:\n    for b in r_[0:np.shape(f)[1]:n]:\n        dctmatrix[a:a+n,b:b+n] = dctmatrix[a:a+n,b:b+n]\/Quant*factor\n\n        \n# Let's take a look at how much it compressed the DCT...\n# Display entire DCT\nplt.figure()\nplt.imshow(dctmatrix,cmap='gray',vmax = np.max(dctmatrix)*0.01,vmin = 0)\nplt.title(\"8x8 DCTs of the image\")","e293a66f":"# Now we need to invert everything we have just accomplished! \n# Let's define our inverse function\n\ndef convolveIDCT(dctmatrix,n,x,y,a,b): # This convolve function compute DCT for nxn @ axb location\n    sumd = 0                               #INI value\n    for u in r_[0:n]:\n        for v in r_[0:n]:\n            val1 = 1\n            val2 = 1\n            x = x%n\n            y = y%n\n            if u == 0: val1 = 1\/math.sqrt(2)\n            if v == 0: val2 = 1\/math.sqrt(2)\n            sumd += dctmatrix[u+a,v+b]*val1*val2*cosp(x,u,n)*cosp(y,v,n)\n    # Now, need to perform the functions outside of the sum values    \n    sumd *= 2\/n\n    return sumd","b44f13f2":"# And re run it to get our new compressed image! :)\n# First we need to take into account our multiple nxn windows that jump across the image\nfor a in r_[0:np.shape(dctmatrix)[0]:n]:\n    for b in r_[0:np.shape(dctmatrix)[1]:n]:\n        # Below, compute the IDCT for a given x,y location in the Image Matrix\n        for x in r_[a:a+n]:\n            for y in r_[b:b+n]:\n                f2[x,y] = convolveIDCT(dctmatrix,n,x,y,a,b)\n\nf2 = f2 + 128 # Scale our values back to 0-255 so we can see it!\n\n# Let's see how she looks AFTER Quantization!\nplt.imshow(f2, cmap=plt.cm.gray)\nplt.axis('off')\nplt.show()\n","d3f35074":"Now we need to initialize some parameters. The \"n\" value will determine the size of our DCT window that convolves across the image (analogous to the \"k\" value for filters).\n\nAlso, we will need to change the data type, as DCT is designed for pixel values from -128 to 127. At first I didn't use this 128 scale, and it really only affects the 1st value in the matrix (where cos(0) = 1). Nonetheless, it's important. If you are curious, you can try for yourself and see!","2a2aee19":"This kernel is an implementation of the 2-Dimensional DCTII and DCTIII algorithims, and was assigned as homework for my Digital Image Processing course at Taiwan Tech, Fall of 2018. I have listed all sources, and all images are the work and right of their respective owners. I am simply providing the code to manually implement \"the DCT\" for image compression.\n\nNote, DCTII is simply referred to as DCT from here, and DCTIII is referred to as IDCT\n\n","c787ce78":"And now let's get a visual perspective of our implementation...","c14753fa":"This is where the compression comes in. I used a standard quantization table. \n\nThe amount of compression can be adjusted by changing the \"f\" value in the for loop. Increasing \"f\" will increase the amount of compression. Thus, with a high value of f, the DCT representation should appear darker.","6ea70b81":"To move forward, now we need to define the cosine function that will be plugged into both the DCT and IDCT functions","b41ff51b":"Now we are going to run our DCT across the entire image in nxn intervals! Note the for loops are setup to use a spacing factor based on n.\n\n***This may take a bit to run depending on the size of the image. Please be patient :)","f113da83":"And run it through to get our old image back! Pay close attention because there are several steps going on in this block:\n\n1] We convolve back across the entire image, returning a new matrix we define as f2...\n\n2] Then, this f2 matrix is scaled back up 128 into the range of 0-255 so that we can print the image properly\n\n3] Image is printed :)","9df48e94":"Now it's time to define our IDCT","10a875a8":"This will be the function we use to convolve across the entire image. \n\nNote, we will need to use seperate convolve fucntions for DCT and IDCT since the equations vary slightly.","c97b65e1":"Now, let's load in the image and subsample so we don't have to wait forever to run the DCT."}}