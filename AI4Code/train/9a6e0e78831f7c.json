{"cell_type":{"7e7bbcac":"code","4dd8c35a":"code","6983caa2":"code","3487b0e6":"code","03ddcf17":"code","9c63da9a":"code","b448b0c7":"code","a5e95df3":"code","e692c82d":"code","0857ea02":"code","b61b0e83":"code","90c7be43":"code","9db23b2d":"code","28d4f4eb":"code","b0cde5a9":"code","77aa1942":"code","da94a840":"code","32ca1808":"code","475a7de6":"code","c33ce008":"code","fb9d8e6b":"code","6f0b7137":"code","f4f077d6":"code","13be9275":"code","645bc418":"code","36e416d2":"code","af89266b":"code","f7ed7576":"code","0fb5baa6":"code","130c390e":"code","26c0efd0":"code","46760904":"code","41ec4b7b":"code","1c41410a":"code","b42f5dbb":"code","ccc1c8e8":"code","57f4f2a3":"code","c819859d":"code","57d670f0":"code","68a91104":"code","df251b24":"code","5462993a":"code","3b50df28":"code","a3fc889b":"code","9693551f":"code","777d7aae":"code","36e3620f":"code","a78f0f49":"code","285e247a":"code","e3720ca0":"code","d9877acb":"code","0e0777d1":"code","8481d84e":"code","bf1455ca":"code","355f1dac":"code","d60d375e":"code","f7bdabdd":"code","7176b446":"code","9d4033a3":"code","4c92360d":"code","3810d0d1":"code","377f8038":"code","b1c0b758":"code","18130e45":"markdown","c6ccbb1b":"markdown","97416325":"markdown","f1f2e8cf":"markdown","88885907":"markdown","ae965e5c":"markdown","35d67579":"markdown","e3ca7865":"markdown","58242c66":"markdown","1db67b1a":"markdown","957440c1":"markdown","f8a28aa4":"markdown","7ccc994e":"markdown","30082ed9":"markdown","6455c073":"markdown","9cd09ad0":"markdown","dbc97068":"markdown","22b8d1e2":"markdown","cca5f616":"markdown","1a9fc5ce":"markdown","35de9ea7":"markdown","5920e15e":"markdown","f488ff32":"markdown","1b9cc3b7":"markdown","522cff13":"markdown","6810ed23":"markdown","e7d4944d":"markdown","67acbd22":"markdown","cbec30e2":"markdown","16748949":"markdown","ad92379b":"markdown","a0052923":"markdown","9e5b0932":"markdown","9a2cc878":"markdown"},"source":{"7e7bbcac":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    print(os.path.join(dirname))","4dd8c35a":"import re\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.graph_objects as go\nimport cv2\nimport tensorflow as tf\nfrom kaggle_datasets import KaggleDatasets\nfrom functools import partial\nimport sklearn\nfrom tqdm import tqdm_notebook as tqdm\nimport gc\n%matplotlib inline","6983caa2":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nexcept:\n    strategy = tf.distribute.get_strategy()","3487b0e6":"print('Device:', tpu.master())\nprint('Number of replicas:', strategy.num_replicas_in_sync)\nprint(\"Version of Tensorflow used : \", tf.__version__)","03ddcf17":"AUTOTUNE = tf.data.experimental.AUTOTUNE\nGCS_PATH = KaggleDatasets().get_gcs_path()\nBATCH_SIZE = 16 * strategy.num_replicas_in_sync\nIMAGE_SIZE = [1024, 1024]\nSHAPE = [256, 256]","9c63da9a":"print(\"Batch Size = \", BATCH_SIZE)\nprint(\"GCS Path = \", GCS_PATH)","b448b0c7":"train = pd.DataFrame(pd.read_csv(\"..\/input\/siim-isic-melanoma-classification\/train.csv\"))\ntrain.head()","a5e95df3":"test = pd.DataFrame(pd.read_csv(\"..\/input\/siim-isic-melanoma-classification\/test.csv\"))\ntest.head()","e692c82d":"train.info()","0857ea02":"test.info()","b61b0e83":"train_dir = \"\/kaggle\/input\/siim-isic-melanoma-classification\/jpeg\/train\/\"","90c7be43":"image_names = train[\"image_name\"].values + \".jpg\"\nrandom_images = [np.random.choice(image_names) for i in range(4)] # Generates a random sample from a given 1-D array\nrandom_images ","9db23b2d":"sample_images = []","28d4f4eb":"plt.figure(figsize = (12, 8))\nfor i in range(4) : \n    plt.subplot(2, 2, i + 1) \n    image = cv2.imread(os.path.join(train_dir, random_images[i]))\n    # cv2 reads images in BGR format. Hence we convert it to RGB\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    sample_images.append(image)\n    plt.imshow(image, cmap = \"gray\")\n    plt.grid(True)\n# Automatically adjust subplot parameters to give specified padding.\nplt.tight_layout()","b0cde5a9":"def non_local_means_denoising(image) : \n    denoised_image = cv2.fastNlMeansDenoisingColored(image, None, 10, 10, 7, 21)\n    return denoised_image","77aa1942":"sample_image = cv2.imread(os.path.join(train_dir, random_images[0]))\n# cv2 reads images in BGR format. Hence we convert it to RGB\nsample_image = cv2.cvtColor(sample_image, cv2.COLOR_BGR2RGB)\ndenoised_image = non_local_means_denoising(sample_image)\n\n\nplt.figure(figsize = (12, 8))\nplt.subplot(1,2,1)\nplt.imshow(sample_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"Normal Image\")\n\nplt.subplot(1,2,2)  \nplt.imshow(denoised_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"Denoised image\")    \n# Automatically adjust subplot parameters to give specified padding.\nplt.tight_layout() ","da94a840":"def histogram_equalization(image) : \n    image_ycrcb = cv2.cvtColor(image, cv2.COLOR_RGB2YCR_CB)\n    y_channel = image_ycrcb[:,:,0] # apply local histogram processing on this channel\n    cr_channel = image_ycrcb[:,:,1]\n    cb_channel = image_ycrcb[:,:,2]\n    \n    # Local histogram equalization\n    clahe = cv2.createCLAHE(clipLimit = 2.0, tileGridSize=(8,8))\n    equalized = clahe.apply(y_channel)\n    equalized_image = cv2.merge([equalized, cr_channel, cb_channel])\n    equalized_image = cv2.cvtColor(equalized_image, cv2.COLOR_YCR_CB2RGB)\n    return equalized_image","32ca1808":"equalized_image = histogram_equalization(denoised_image)","475a7de6":"plt.figure(figsize = (12, 8))\nplt.subplot(1,3,1)\nplt.imshow(sample_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"Normal Image\", fontsize = 14)\n\nplt.subplot(1,3,2)  \nplt.imshow(denoised_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"denoised image after histogram processing\", fontsize = 14)\n\nplt.subplot(1,3,3)  \nplt.imshow(equalized_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"Histogram equalized image\", fontsize = 14)\n# Automatically adjust subplot parameters to give specified padding.\nplt.tight_layout()","c33ce008":"def segmentation(image, k, attempts) : \n    vectorized = np.float32(image.reshape((-1, 3)))\n    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 20, 1.0)\n    res , label , center = cv2.kmeans(vectorized, k, None, criteria, attempts, cv2.KMEANS_PP_CENTERS)\n    center = np.uint8(center)\n    res = center[label.flatten()]\n    segmented_image = res.reshape((image.shape))\n    return segmented_image","fb9d8e6b":"plt.figure(figsize = (12, 8))\nplt.subplot(1,1,1)\nplt.imshow(denoised_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"de Noised Image\")","6f0b7137":"plt.figure(figsize = (12, 8))\nsegmented_image = segmentation(denoised_image, 3, 10) # k = 3, attempt = 10\nplt.subplot(1,3,1)\nplt.imshow(segmented_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"Segmented Image with k = 3\")\n\nsegmented_image = segmentation(denoised_image, 4, 10) # k = 4, attempt = 10\nplt.subplot(1,3,2)\nplt.imshow(segmented_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"Segmented Image with k = 4\")\n\nsegmented_image = segmentation(denoised_image, 5, 10) # k = 5, attempt = 10\nplt.subplot(1,3,3)\nplt.imshow(segmented_image, cmap = \"gray\")\nplt.grid(False)\nplt.title(\"Segmented Image with k = 5\")","f4f077d6":"from sklearn.model_selection import train_test_split \ntraining_files, validation_files = train_test_split(tf.io.gfile.glob(GCS_PATH + \"\/tfrecords\/train*.tfrec\"),\n                                                   test_size = 0.1, random_state = 42)\n\ntesting_files = tf.io.gfile.glob(GCS_PATH + \"\/tfrecords\/test*.tfrec\")\n\nprint(\"Number of training files = \", len(training_files))\nprint(\"Number of validation files = \", len(validation_files))\nprint(\"Number of test files = \", len(testing_files))","13be9275":"def decode_image(image) : \n    image = tf.image.decode_jpeg(image, channels = 3)\n    image = tf.cast(image, tf.float32)\n    image = image \/ 255.0\n    image = tf.reshape(image, [IMAGE_SIZE[0], IMAGE_SIZE[1], 3])\n    return image","645bc418":"sample_images[0].shape","36e416d2":"training_files","af89266b":"sample_picked = training_files[0]\nsample_picked","f7ed7576":"file = tf.data.TFRecordDataset(sample_picked)\nfile","0fb5baa6":"feature_description = {\"image\" : tf.io.FixedLenFeature([], tf.string), \n                      \"target\" : tf.io.FixedLenFeature([], tf.int64)}","130c390e":"def parse_function(example) : \n    # The example supplied is parsed based on the feature_description above.\n    return tf.io.parse_single_example(example, feature_description)","26c0efd0":"parsed_dataset = file.map(parse_function)\nparsed_dataset","46760904":"def read_tfrecord(example, labeled) : \n    if labeled == True : \n        tfrecord_format = {\"image\" : tf.io.FixedLenFeature([], tf.string),\n                           \"target\" : tf.io.FixedLenFeature([], tf.int64)}\n    else:\n        tfrecord_format = {\"image\" : tf.io.FixedLenFeature([], tf.string),\n                          \"image_name\" : tf.io.FixedLenFeature([], tf.string)}\n    \n    example = tf.io.parse_single_example(example, tfrecord_format)\n    image = decode_image(example[\"image\"])\n    if labeled == True : \n        label = tf.cast(example[\"target\"], tf.int32)\n        return image, label\n    else:\n        image_name = example[\"image_name\"]\n        return image, image_name     ","41ec4b7b":"def load_dataset(filenames, labeled, ordered):\n    ignore_order = tf.data.Options()\n    if ordered == False: # dataset is unordered, so we ignore the order to load data quickly.\n        ignore_order.experimental_deterministic = False # This disables the order and enhances the speed\n    dataset = tf.data.TFRecordDataset(filenames, num_parallel_reads=AUTOTUNE) \n    dataset = dataset.with_options(ignore_order) \n    dataset = dataset.map(partial(read_tfrecord, labeled=labeled), num_parallel_calls=AUTOTUNE)\n    return dataset","1c41410a":"def image_augmentation(image, label) :     \n    image = tf.image.resize(image, SHAPE)\n    image = tf.image.random_flip_left_right(image)\n    return image, label","b42f5dbb":"def get_training_dataset() : \n    dataset = load_dataset(training_files, labeled = True, ordered = False)\n    dataset = dataset.map(image_augmentation, num_parallel_calls=AUTOTUNE)\n    dataset = dataset.repeat()\n    dataset = dataset.batch(BATCH_SIZE)\n    dataset = dataset.prefetch(AUTOTUNE) \n    return dataset","ccc1c8e8":"def get_validation_dataset() : \n    dataset = load_dataset(validation_files, labeled = True, ordered = False)\n    dataset = dataset.map(image_augmentation, num_parallel_calls=AUTOTUNE)\n    dataset = dataset.batch(BATCH_SIZE)\n    dataset = dataset.cache()\n    dataset = dataset.prefetch(AUTOTUNE) \n    return dataset","57f4f2a3":"def get_test_dataset() : \n    dataset = load_dataset(testing_files, labeled = False, ordered = True)\n    dataset = dataset.map(image_augmentation, num_parallel_calls=AUTOTUNE)\n    dataset = dataset.batch(BATCH_SIZE)\n    dataset = dataset.cache()\n    dataset = dataset.prefetch(AUTOTUNE) \n    return dataset","c819859d":"training_dataset = get_training_dataset()","57d670f0":"validation_dataset = get_validation_dataset()","68a91104":"def count_data_items(filenames):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) for filename in filenames]\n    return np.sum(n)\n\nnum_training_images = count_data_items(training_files)\nnum_validation_images = count_data_items(validation_files)\nnum_testing_images = count_data_items(testing_files)\n\nSTEPS_PER_EPOCH_TRAIN = num_training_images \/\/ BATCH_SIZE\nSTEPS_PER_EPOCH_VAL = num_validation_images \/\/ BATCH_SIZE\n\nprint(\"Number of Training Images = \", num_training_images)\nprint(\"Number of Validation Images = \", num_validation_images)\nprint(\"Number of Testing Images = \", num_testing_images)\nprint(\"\\n\")\nprint(\"Numer of steps per epoch in Train = \", STEPS_PER_EPOCH_TRAIN)\nprint(\"Numer of steps per epoch in Validation = \", STEPS_PER_EPOCH_VAL)","df251b24":"image_batch, label_batch = next(iter(training_dataset))","5462993a":"def show_batch(image_batch, label_batch) :\n    plt.figure(figsize = (20, 20))\n    for n in range(8) : \n        ax = plt.subplot(2,4,n+1)\n        plt.imshow(image_batch[n])\n        if label_batch[n] == 0 : \n            plt.title(\"BENIGN\")\n        else:\n            plt.title(\"MALIGNANT\")\n    plt.grid(False)\n    plt.tight_layout()       ","3b50df28":"show_batch(image_batch.numpy(), label_batch.numpy())","a3fc889b":"del image_batch\ndel label_batch\ngc.collect()","9693551f":"malignant = len(train[train[\"target\"] == 1])\nbenign = len(train[train[\"target\"] == 0 ])\ntotal = len(train) \n\nprint(\"Malignant Cases in Train Data = \", malignant)\nprint(\"Benign Cases In Train Dataset = \",benign)\nprint(\"Total Cases In Train Dataset = \",total)\nprint(\"Ratio of Malignant to Benign = \",malignant\/benign)","777d7aae":"weight_malignant = (total\/malignant)\/2.0\nweight_benign = (total\/benign)\/2.0\n\nclass_weight = {0 : weight_benign , 1 : weight_malignant}\n\nprint(\"Weight for benign cases = \", class_weight[0])\nprint(\"Weight for malignant cases = \", class_weight[1])","36e3620f":"callback_early_stopping = tf.keras.callbacks.EarlyStopping(patience = 15, verbose = 0, restore_best_weights = True)\n\ncallbacks_lr_reduce = tf.keras.callbacks.ReduceLROnPlateau(monitor = \"val_auc\", factor = 0.1, patience = 10, \n                                                          verbose = 0, min_lr = 1e-6)\n\ncallback_checkpoint = tf.keras.callbacks.ModelCheckpoint(\"melanoma_weights.h5\",\n                                                         save_weights_only=True, monitor='val_auc',\n                                                         mode='max', save_best_only = True)","a78f0f49":"with strategy.scope() : \n    bias = np.log(malignant\/benign)\n    bias = tf.keras.initializers.Constant(bias)\n    base_model = tf.keras.applications.MobileNetV2(input_shape = (SHAPE[0], SHAPE[1], 3), include_top = False,\n                                               weights = \"imagenet\")\n    base_model.trainable = False\n    model = tf.keras.Sequential([base_model,\n                                 tf.keras.layers.GlobalAveragePooling2D(),\n                                 tf.keras.layers.Dense(20, activation = \"relu\"),\n                                 tf.keras.layers.Dropout(0.4),\n                                 tf.keras.layers.Dense(10, activation = \"relu\"),\n                                 tf.keras.layers.Dropout(0.3),\n                                 tf.keras.layers.Dense(1, activation = \"sigmoid\", bias_initializer = bias)                                     \n                                ])\n    model.compile(optimizer = tf.keras.optimizers.Adam(lr = 1e-2), loss = \"binary_crossentropy\", metrics = [tf.keras.metrics.AUC(name = 'auc')])\n    model.summary()\n    \n    EPOCHS = 500\n    history = model.fit(training_dataset, epochs = EPOCHS, steps_per_epoch = STEPS_PER_EPOCH_TRAIN,\n                       validation_data = validation_dataset, validation_steps = STEPS_PER_EPOCH_VAL,\n                       callbacks = [callback_early_stopping, callbacks_lr_reduce, callback_checkpoint],\n                       class_weight = class_weight)","285e247a":"n_epochs_it_ran_for = len(history.history['loss'])\nn_epochs_it_ran_for","e3720ca0":"X = np.arange(0,n_epochs_it_ran_for,1)\nplt.figure(1, figsize = (20, 12))\nplt.subplot(1,2,1)\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Loss\")\nplt.plot(X, history.history[\"loss\"], label = \"Training Loss\")\nplt.plot(X, history.history[\"val_loss\"], label = \"Validation Loss\")\nplt.grid(True)\nplt.legend()\n\nplt.subplot(1,2,2)\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Accuracy\")\nplt.plot(X, history.history[\"auc\"], label = \"Training Accuracy\")\nplt.plot(X, history.history[\"val_auc\"], label = \"Validation Accuracy\")\nplt.grid(True)\nplt.legend()","d9877acb":"testing_dataset = get_test_dataset()\ntesting_dataset_images = testing_dataset.map(lambda image, image_name : image)\ntesting_image_names = testing_dataset.map(lambda image, image_name : image_name)","0e0777d1":"resulting_probabilities = model.predict(testing_dataset_images, verbose = 1)","8481d84e":"len(resulting_probabilities)","bf1455ca":"sample_submission_file = pd.read_csv(\"..\/input\/siim-isic-melanoma-classification\/sample_submission.csv\")\nsample_submission_file.head()","355f1dac":"del sample_submission_file[\"target\"]\nsample_submission_file.head()","d60d375e":"testing_image_names","f7bdabdd":"testing_image_names = np.concatenate([x for x in testing_image_names], axis=0)\ntesting_image_names = np.array(testing_image_names)","7176b446":"decoded_test_names = []\nfor names in testing_image_names : \n    names = names.decode('utf-8')\n    decoded_test_names.append(names)\ndecoded_test_names = np.array(decoded_test_names)\ndel testing_image_names","9d4033a3":"len(decoded_test_names), type(decoded_test_names), decoded_test_names.shape","4c92360d":"decoded_test_names","3810d0d1":"testing_image_names = pd.DataFrame(decoded_test_names, columns=[\"image_name\"])\ntesting_image_names.head()","377f8038":"pred_dataframe = pd.DataFrame({\"image_name\" : decoded_test_names, \n                               \"target\" : np.concatenate(resulting_probabilities)})\npred_dataframe","b1c0b758":"sample_submission_file = sample_submission_file.merge(pred_dataframe, on = \"image_name\")\nsample_submission_file.to_csv(\"submission.csv\", index = False)\nsample_submission_file.head()","18130e45":"For test images, we will return the image name instead of the label.","c6ccbb1b":"## Setting Evaluation Metric: \n\n*This is taken from Amy Jang's notebook as mentioned earlier.*\n\n*Notebook : https:\/\/www.kaggle.com\/amyjang\/tensorflow-transfer-learning-melanoma*\n\nWhen we compile our model, we do not want our metric to be accuracy. If we run the model, with an accuracy metric, it will give us false confidence in our model. If we look at the dataset, we see that 98% of the images are classifed as benign, 0. Now, if accuracy was the sole determinant of our model, a model that always outputs 0 will achieve a high accuracy although the model is not good.\n\nThe competition scores the model by finding the area under the ROC curve, which is why our metric will be set to keras.metrics.AUC.","97416325":"## Image Denoising :\n\nMany image smoothing techniques like Gaussian Blurring, Median Blurring etc were good to some extent in removing small quantities of noise. In those techniques, we took a small neighbourhood around a pixel and performed some operations like gaussian weighted average, median of the values etc to replace the central element. In short, noise removal at a pixel was local to its neighbourhood.\n\nThere is a property of noise. **Noise is generally considered to be a random variable with zero mean.**\n\nSuppose we hold a static camera to a certain location for a couple of seconds. This will give us plenty of frames, or a lot of images of the same scene. Then averaging all the frames, we compare the final result and first frame. Reduction in noise would be easily observed.\n\nSo idea is simple, we need a set of similar images to average out the noise. Considering a small window (say 5x5 window) in the image, chance is large that the same patch may be somewhere else in the image. Sometimes in a small neighbourhood around it. Hence, using these similar patches together averaging them can lead to an efficient denoised image.\n\nThis method is **Non-Local Means Denoising. It takes more time compared to blurring techniques, but the result are very satisfying.**\n\nDenoising illustration :\n![image.png](attachment:image.png) ","f1f2e8cf":"## Image Segmentation :\n\nIs the technique of dividing or partitioning an image into parts, called segments. It is mostly useful for applications like image compression or object recognition, because for these types of applications, it is inefficient to process the whole image.\n\nWe will use **K-means clustering algorithm** to segment the images.\n\nK-Means Segmentation Approach Using OpenCV\n\n* `samples` : It should be of np.float32 data type, and each feature should be put in a single column. Here we have 3 channels, so every channel features have to be in one column. So, total columns we have are 3, while we don't care about the number of rows, hence -1. So, shape : (-1, 3).\n\n* `nclusters(K)` : Number of clusters required at end.\n\n* `criteria` : It is the iteration termination criteria. When this criteria is satisfied, algorithm iteration stops. Actually, it should be a tuple of 3 parameters. They are `( type, max_iter, epsilon )`:\n\nType of termination criteria. It has 3 flags as below:\n\n1. `cv.TERM_CRITERIA_EPS` - stop the algorithm iteration if specified accuracy, epsilon, is reached.\n2. `cv.TERM_CRITERIA_MAX_ITER` - stop the algorithm after the specified number of iterations, max_iter.\n3. `cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER` - stop the iteration when any of the above condition is met.\n\n*max_iter - An integer specifying maximum number of iterations. epsilon - Required accuracy*\n\n* `attempts` : Flag to specify the number of times the algorithm is executed using different initial labellings. The algorithm returns the labels that yield the best compactness. This compactness is returned as output.\n\n* `flags` : This flag is used to specify how initial centers are taken. Normally two flags are used for this : cv.KMEANS_PP_CENTERS and cv.KMEANS_RANDOM_CENTERS.\n\n****\n\nOutput parameters :\n\n* `compactness` : It is the sum of squared distance from each point to their corresponding centers.\n* `labels` : This is the label array (same as 'code' in previous article) where each element marked '0','1'.....\n* `centers` : This is array of centers of clusters.","88885907":"## Defining CallBacks : \n\nA callback is a powerful tool to customize the behavior of a Keras model during training, evaluation, or inference. Callbacks are useful to get a view on internal states and statistics of the model during training.\n\nThis can be used to stop predictions when there is no change in the desired metric over a certain epoch range. This is amazingly useful in order to avoid `overfitting`. \n\nHere we use : \n\n* ModelCheckPoint : Callback to save the Keras model or model weights at some frequency.\n* EarlyStopping : Stop training when a monitored metric has stopped improving.","ae965e5c":"Due to callbacks, best weights are automatically restored!","35d67579":"Note below we have a condition for disabling the order. This will come in handy, as for training and validation purposes, we don't need to take care of the order. However, for test images we have to submit the predictions and they have to be in order. Hence, for them `experimental_deterministic will remain true`. The role of `experimental_deterministic` setting is to `disable data order reinforcement.`\n\nMore detail can be found at : **https:\/\/www.kaggle.com\/docs\/tpu**","e3ca7865":"## Tensorflow Records : \n\nMany folks don't really understand this! So let's have some insight before we actually dive into creating our model.\n\n**What is Tensorflow Record?**\n\nIt's Tensorflow's binary storage format for your data. \n\n![image.png](attachment:image.png)\n\n**Okay, so what's the endgame? Aren't JPEG, PNG also storage formats? What makes this one special ?**\n\nWell, short answer : It's Google's.\nUmmm.. a little longer answer would be that binary storage data takes up relatively low space on your disk, and hence it takes less time to copy and can be read much more efficiently! Moreover, the *tensorflow* framework is optimized to handle tfrecords amazingly well. \n\nThe datasets that are too large to be stored fully in memory, this is an advantage as only the data that is required at the time (e.g. a batch) is loaded from disk and then processed. \n\nAnother major advantage of TFRecords is that it is possible to store sequence data \u2014 for instance, a time series or word encodings \u2014 in a way that allows for very efficient and (from a coding perspective) convenient import of this type of data.\n\n*In a nutshell, it's cool !*","58242c66":"*Before going any further, this would not have been possible without the Kaggle community support. Loads of doubts were cleared during discussions and reading public kernels.*\n\n*Thank you all!! Please do consider upvoting in case you find this useful. By no means, I'm done. Loads and fine tuning and incorporating preprocessing in tf.data inspired pipeline remains*.","1db67b1a":"* **map( )** : This transformation applies map_func to each element of this dataset, and returns a new dataset containing the transformed elements\n\n* **repeat( )** : Repeats this dataset so each original value is seen count times.\n\n* **shuffle( )** : Randomly shuffles the elements of this dataset.\n\n* **batch( )** : Combines consecutive elements of this dataset into batches.\n\n* **prefetch( )** : Most dataset input pipelines should end with a call to prefetch. This allows later elements to be prepared while the current element is being processed. prefetch( ) doesn\u2019t allow CPU stand idle. When model is training prefetch continue prepare data while GPU is busy.\n\n* **cache( )** : The first time the dataset is iterated over, its elements will be cached either in the specified file or in memory. Subsequent iterations will use the cached data. When caching to a file, the cached data will persist across runs. Even the first iteration through the data will read from the cache file. ","957440c1":"## Bias Initialization : \n\nSince the dataset is heavily imbalanced, we may want to assign different weights to different classes. Setting an initial bias is important in such cases.","f8a28aa4":"# Model Construction : ","7ccc994e":"## Let's look at the libraries we need : \n\n* Numpy : For working on ndarrays. It's a base library in any Machine Learning application.\n* Pandas : Handling csvs'. It's dataframe data structure allows us to quickly derieve insights from our csv data.\n* Matplotlib, Seaborn and Plotly : Plotting libraries for Python3.\n* cv2 : Open source library for Image Processing and Computer Vision.\n* Tensorflow : A deep learning framework for designing models and input data pipelines.\n* partial : Basically used when there are cases of optional arguments. This keeps the pipeline intact. \n* sklearn : This is for yet another beautifully optimized ML library having off-the-shelf ML algorithms implemented. \n* tqdm : For visualizing progress during a loop or any iteration for that matters.\n* gc : Garbage collection. This is for freeing the underlying memory from temporary variables and references.","30082ed9":"## Local Histogram Pre-Processing\n\nFirst of all, why can't we apply histogram equalization directly to an RGB image?\nHistogram equalization is a non-linear process. Channel splitting and equalizing each channel separately is incorrect. *Equalization involves intensity values of the image, not the color components*. \n\nSo for a simple RGB color image, histogram equalization cannot be applied directly on the channels.*It needs to be applied in such a way that the intensity values are equalized without disturbing the color balance of the image. So, the first step is to convert the color space of the image from RGB into one of the color spaces that separates intensity values from color components. Some of the possible options are HSV\/HLS, YUV, YCbCr, etc. YCbCr is preferred as it is designed for digital images. Perform histogram equalization on the intensity plane Y. Now convert the resultant YCbCr image back to RGB.*\n\n(Excerpt taken from :\n\nhttps:\/\/prateekvjoshi.com\/2013\/11\/22\/histogram-equalization-of-rgb-images\/ )\n\nAn illustration of histogram equalization : **Observe the intensity difference**\n![image.png](attachment:image.png) \n\nHere the third one is actually local histogram equalization, where we equalize intensities inside a rolling window of certain dimension instead of the whole image at once.","6455c073":"# Melanoma Classification : Preprocessing cum Model Development\n\n![image.png](attachment:image.png)\n\n## Notebook III of III\n\nThis notebook is the III one in my series of work in this competition. As always shout out to amazing kernel authors present here at kaggle!! I got loads of inspiration from them. I believe this is the best thing about the ML community. The extent of collaboration and guidance one can seek here is inexplicable!!\n\n## Previous works : \n* Dataset preparation(Notebook I) : \n**https:\/\/www.kaggle.com\/fireheart7\/melanoma-a-story-in-3-parts-part-one**\n\n* Exploratory Data Analysis(Notebook II) : \n**https:\/\/www.kaggle.com\/fireheart7\/melanoma-a-story-in-3-parts-part-two?scriptVersionId=38737733**","9cd09ad0":"## Viewing Our Training Images : \n\nLet's plot some of our training images : ","dbc97068":"## TFRecord = Array of Examples : \n\nA TFRecord file contains an array of `Examples`. `Example` is a data structure for representing a record, like an observation in a training or test dataset. A record is represented as a set of features, each of which has a name and can be an array of bytes, floats, or 64-bit integers. \n\nTo summarize:\n\n* An Example contains Features.\n* Features is a mapping from the feature names stored as strings to Features.\n\nThese relations are defined in `example.proto` and `feature.proto` in the TensorFlow's source code, along with extensive comments. As the extension `.proto` suggests, these definitions are based on `protocol buffers`.\n\n## Why Protocol Buffers?\n\n![image.png](attachment:image.png) \n\nGoogle\u2019s Protocol buffers are a serialization scheme for structured data. In other words, protocol buffers are used for serializing structured data into a byte array, so that they can be sent over the network or stored as a file. In this sense, it is similar to JSON, XML.\n\n**Protocol buffers can offer a lot faster processing speed compared to text-based formats like JSON or XML.**","22b8d1e2":"## Class Weights Initialization : \n\nWe saw earlier that malignant cases happen to be far less than the benign ones. Hence, we ought to set relatively heavy weights for malignant cases compared to the benign ones. This will encourage the model to pay more attention to malignant ones.\n\n`According to official Tensorflow documentation : `\n\n*Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class*.","cca5f616":"Upload the updated training and test csv obtained in the EDA notebook. There we filled the missing values and saved them in our custom dataset folder.\n\n**Dataset : https:\/\/www.kaggle.com\/fireheart7\/melanoma-image-insights**","1a9fc5ce":"# Load The Datasets : ","35de9ea7":"**Please consider upvoting if you find the overall series of notebooks useful! I have tried explaining the steps performed in profound details.**\n\nThank you! \nLet's begin!!~~","5920e15e":"TFRecord files of training and testing are mixed. Therefore we don't know whether the file being input has a label of malignant\/benign associated with it or not! Hence, we will supply both example and label to it, and simply set the label to False in the function call stack; in case label is absent. ","f488ff32":"Let's free up some memory","1b9cc3b7":"Let's observe the number of epochs our model ran for before callbacks stopped the execution due to no further significant improvement in validation_accuracy.","522cff13":"We observe our training_files object stores all tfrecord files. Let's pick one to analyze. ","6810ed23":"*This means that it is composed of a tensors and we need to parse it in order to make some meaning of it. For that very purpose it becomes mandatory to define a feature_description as tensorflow TFRecord datasets use Tensorflow's graph execution instead of Eager execution**. \n\nBasically : \n\n* Eager execution is what has been done so far. You write a statement and execute it. The results appear instantaneously. This imperative way of programming is inspired from Python3.\n\n* On the other hand, Graph execution is another way of defining control flow where we construct a structure in which we define how a tensor flows( hence the name tensorflow, I guess). This means say at the first node there has to be addition of two tensors, at the second rescaling, third divison and in the final node an activation function is there to return the final answer. \n\n* Graph execution is extremely useful in areas where Python interpreter is absent like in Android applications, and so on. Here, due to computational graphs, tensorflow models can still be deployed. This makes tensorflow an amazing tool for model deployment. However, that's a story for another day.","e7d4944d":"## Model Design : MobileNetV2\n\nA supercool resource : **https:\/\/machinethink.net\/blog\/mobilenet-v2\/**","67acbd22":"* At this point the dataset contains serialized **tf.train.Example** messages. When iterated over it returns these as scalar string tensors. ","cbec30e2":"## The journey continues!!\n\nThe pre-processing we did earlier, I'll soon share the dataset of denoised, histogram equalized images. Then using the approach here in this notebook, we will use tf.data API to directly train on them!!\n\nStay Tuned!~~\n\nIn the meantime, you can view my other works in the SIIM ISIC Melanoma Challenge : \n\n* **https:\/\/www.kaggle.com\/fireheart7\/melanoma-a-story-in-3-parts-part-one**\n* **https:\/\/www.kaggle.com\/fireheart7\/melanoma-a-story-in-3-parts-part-two**","16748949":"## Malignant VS Benign Imbalance Analysis ","ad92379b":"A TFRecord file can be read using **tf.data.TFRecordDataset** class.","a0052923":"Some key modules used :\n\n* **tf.data.Options()** : An Options object can be, for instance, used to control which graph optimizations to apply. \n\n* **.experiemental_deterministic** : `experiemntal_deterministic` refers to whether the outputs need to be produced in deterministic order. If None, defaults to True. Here, the data is unordered, hence we don't need to process it in an order which may slow down our speed. \n\n* **TFRecordDataset** : A Dataset comprising records from one or more TFRecord files.\n\n* **num_parallel_reads** argument in TFRecordDataset : A tf.int64 scalar representing the number of files to read in parallel.","9e5b0932":"## OpenCV implementation of the aforementioned approach :\ncv2.fastNlMeansDenoisingColored() - Works on Colored images cv2.fastNlMeansDenoising() - Works on graysacle images\n\nCommon arguments are:\n\n* h : parameter deciding filter strength. Higher h value removes noise better, but removes details of image also. (10 is ok)\n* hForColorComponents : same as h, but for color images only. (normally same as h)\n* templateWindowSize : should be odd. (recommended 7)\n* searchWindowSize : should be odd. (recommended 21)","9a2cc878":"Let's initialize our TPU !!"}}