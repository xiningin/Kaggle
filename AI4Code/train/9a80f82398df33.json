{"cell_type":{"a977dd57":"code","8dc88363":"code","2d4bf55e":"code","02f66792":"code","7823b7f9":"code","6b504a97":"code","3baec576":"code","ed8ddcc3":"code","752ca8a7":"code","30b97bee":"code","d1484a87":"code","83648f7f":"code","9812dbb8":"code","0ebce66a":"code","ba4fabea":"code","5b2852cf":"code","a8062a1e":"code","00a4db54":"code","52c6e6b9":"markdown","88500deb":"markdown","95db1d65":"markdown"},"source":{"a977dd57":"# imports\nfrom pathlib import Path\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom sklearn.model_selection import train_test_split","8dc88363":"input_path = Path('\/kaggle\/input\/tabular-playground-series-nov-2021\/')\nlist(input_path.iterdir())","2d4bf55e":"train_df = pd.read_csv(input_path\/'train.csv')\ntest_df = pd.read_csv(input_path\/'test.csv')\nsubmission_df = pd.read_csv(input_path\/'sample_submission.csv')\n\ntrain_df.shape, test_df.shape","02f66792":"submission_df.head(3)","7823b7f9":"train_df.head(3)","6b504a97":"# null values\ntrain_df.isnull().sum().sum(), test_df.isnull().sum().sum()","3baec576":"# duplicates check\nlen(train_df) - len(train_df.drop(['id', 'target'], axis=1).drop_duplicates())","ed8ddcc3":"test_id = test_df.loc[:, 'id']\ntrain_target = train_df.loc[:, 'target']\ntrain_df.drop(['id', 'target'], axis=1, inplace=True)","752ca8a7":"train_target_counts = train_target.value_counts()\nlabels = train_target_counts.index\ncounts = train_target_counts.values\n\nplt.bar(labels, counts)\nplt.xticks(labels)\nplt.show()","30b97bee":"# Scaling the data\nfrom sklearn.preprocessing import StandardScaler, Normalizer\nscaler = StandardScaler()\nnormalizer = Normalizer()","d1484a87":"import catboost\nimport optuna\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler, Normalizer\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import classification_report, auc, roc_auc_score","83648f7f":"X_train, X_test, y_train, y_test = train_test_split(train_df, train_target, test_size=0.25, stratify=train_target,\n                                                    shuffle=True, random_state=13)\nX_train.shape, X_test.shape","9812dbb8":"def objective(trial):\n    \"\"\"\n    Objective function to tune XGBoost classifier\n    \"\"\"\n    params = {\n        'task_type': 'GPU',\n        'iterations': trial.suggest_int('iterations', 50, 300),\n        'learning_rate': trial.suggest_loguniform('learning_rate', 0.01, 0.3),\n        'depth': trial.suggest_int('depth', 4, 10),\n    }\n    \n    # KFold split\n    skf = StratifiedKFold(n_splits=5, random_state=13, shuffle=True)\n    cv_scores = []\n    \n    for train_ix, test_ix in skf.split(X_train, y_train):\n        X_train_k, X_test_k = X_train.iloc[train_ix], X_train.iloc[test_ix]\n        y_train_k, y_test_k = y_train.iloc[train_ix], y_train.iloc[test_ix]\n        \n        # Scale data\n        # X_train_k = scaler.fit_transform(X_train_k)\n        # X_test_k = scaler.transform(X_test_k)\n    \n        booster = catboost.CatBoostClassifier(**params, loss_function='Logloss', eval_metric='AUC')\n        booster.fit(X_train_k, y_train_k, eval_set=[(X_test_k, y_test_k)], verbose=0)\n        preds = booster.predict_proba(X_test)\n        preds = preds[:, 1]\n        cv_scores.append(preds)\n    cv_score = np.mean(cv_scores, axis=0)\n    return roc_auc_score(y_test, cv_score)","0ebce66a":"study = optuna.create_study(direction='maximize')\nstudy.optimize(objective, n_trials=50, timeout=600)","ba4fabea":"study.best_trial, study.best_params","5b2852cf":"test_df_preds = []\nskf = StratifiedKFold(n_splits=5, random_state=13, shuffle=True)\nfor train_ix, test_ix in skf.split(train_df, train_target):\n    X_train, X_test = train_df.iloc[train_ix], train_df.iloc[test_ix]\n    y_train, y_test = train_target.iloc[train_ix], train_target.iloc[test_ix]\n    # xgb model\n    cat_model = catboost.CatBoostClassifier(**study.best_params, task_type='GPU', loss_function='Logloss', eval_metric='AUC')\n    cat_model.fit(X_train, y_train, verbose=0, eval_set=[(X_test, y_test)])\n    print(cat_model.best_score_)\n    test_preds = cat_model.predict_proba(test_df.drop('id', axis=1))\n    test_preds = test_preds[:, 1]\n    test_df_preds.append(test_preds)","a8062a1e":"submission_df.target = np.mean(test_df_preds, axis=0)","00a4db54":"submission_df.to_csv('submission.csv', index=False)","52c6e6b9":"## Model building","88500deb":"## Data sanity check","95db1d65":"## EDA\n\n1. It is said that, all the variables are continuous\n2. Target variable is binary"}}