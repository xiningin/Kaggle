{"cell_type":{"151308a0":"code","f976f0b1":"code","4c0ffebd":"code","88dc2266":"code","7c267597":"code","6fde1db1":"code","a85aacc1":"code","5121cc89":"code","8e7f8355":"code","17e2785f":"code","76b28c13":"code","09956610":"code","753a7cb6":"markdown","3a58510d":"markdown","46ca6010":"markdown","3c96cba7":"markdown","82ce3049":"markdown","a400a59b":"markdown","6dbc2f92":"markdown","f8423239":"markdown","2b6e7ed3":"markdown"},"source":{"151308a0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f976f0b1":"import zipfile\nimport h5py\nimport cv2\nimport glob, os\nfrom matplotlib import pyplot as plt\nimport h5py\nimport numpy as np\nfrom tqdm import tqdm\nlbl=[]\nimg=np.zeros((3064,224,224))\nfor i in range(1,3065):\n    try:\n        path='\/kaggle\/input\/brain-tumour-1\/brainTumorDataPublic_1766\/'\n        with h5py.File(path+str(i)+'.mat') as f:\n          images = f['cjdata']\n          resized = cv2.resize(images['image'][:,:], (224,224), interpolation = cv2.INTER_CUBIC )\n          x=np.asarray(resized)\n          x=(x-np.min(x))\/(np.max(x)-np.min(x))\n          x=x.reshape((1,224,224))\n          img[i-1]=x\n          lbl.append(int(images['label'][0]))\n    except:\n        try:\n          path='\/kaggle\/input\/brain-tumour-1\/brainTumorDataPublic_22993064\/'\n          with h5py.File(path+str(i)+'.mat') as f:\n              images = f['cjdata']\n              resized = cv2.resize(images['image'][:,:], (224,224), interpolation = cv2.INTER_CUBIC )\n              x=np.asarray(resized)\n              x=(x-np.min(x))\/(np.max(x)-np.min(x))\n              x=x.reshape((1,224,224))\n              img[i-1]=x\n              lbl.append(int(images['label'][0]))\n        except:\n            try:\n              path='\/kaggle\/input\/brain-tumour-1\/brainTumorDataPublic_15332298\/'\n              with h5py.File(path+str(i)+'.mat') as f:\n                  images = f['cjdata']\n                  resized = cv2.resize(images['image'][:,:], (224,224), interpolation = cv2.INTER_CUBIC )\n                  x=np.asarray(resized)\n                  x=(x-np.min(x))\/(np.max(x)-np.min(x))\n                  x=x.reshape((1,224,224))\n                  img[i-1]=x\n                  lbl.append(int(images['label'][0]))\n            except:\n              path='\/kaggle\/input\/brain-tumour-1\/brainTumorDataPublic_7671532\/'\n              with h5py.File(path+str(i)+'.mat') as f:\n                  images = f['cjdata']\n                  resized = cv2.resize(images['image'][:,:], (224,224), interpolation = cv2.INTER_CUBIC )\n                  x=np.asarray(resized)\n                  x=(x-np.min(x))\/(np.max(x)-np.min(x))\n                  x=x.reshape((1,224,224))\n                  img[i-1]=x\n                  lbl.append(int(images['label'][0]))\n","4c0ffebd":"import zipfile\nimport h5py\nfrom keras.optimizers import Adam\nimport cv2\nfrom keras.utils import to_categorical\nfrom matplotlib import pyplot as plt\nimport glob, os\nfrom matplotlib import pyplot as plt\nimport h5py\nfrom sklearn.metrics import accuracy_score\nimport numpy as np\nfrom tqdm import tqdm\nimport time\nimport gc\nfrom keras.applications import *\nfrom keras.layers import *\nfrom keras import backend as K\nfrom keras.models import Model\n","88dc2266":"path='\/kaggle\/input\/brain-tumour\/cvind (2).mat'\n\nwith h5py.File(path) as f:\n      data=f['cvind']\n      idx=data[0]\nimport scipy.io\nobj_arr = {}\nobj_arr['images'] = img\nobj_arr['label'] = lbl\nobj_arr['fold']=idx\nnp.save('check.npy', obj_arr)","7c267597":"\npath = F\"check.npy\" \ndf=np.load(path,allow_pickle=True)\ndf=df.item()\ndf['images']=df['images'].astype(np.float32)\n","6fde1db1":"#shuffle samples\ndef unison_shuffled_copies(a, b):\n    assert len(a) == len(b)\n    p = np.random.permutation(len(a))\n    return a[p], b[p]\n\n\n\n#change targets\ndef change(img):\n    dimension=224\n    resized = cv2.resize(img, (dimension,dimension), interpolation = cv2.INTER_AREA )\n    return resized\n\n\n\n\n#get train and test splits\ndef get_trn_tst(df,tst_fold):\n  dimension=224\n  idx=np.asarray(df['fold'])\n  y=np.asarray(df['label'])\n  y-=1\n  img=np.asarray(df['images'])\n  img1=[]\n  for i in range(len(img)):\n        img1.append(change(img[i]))\n  img1=np.asarray(img1)\n  del([img])\n  gc.collect()\n  trn_y=np.asarray(y[(idx!=tst_fold)])\n  trn_img=np.asarray(img1[(idx!=tst_fold)])\n  tst_y=np.asarray(y[(idx==tst_fold)])\n  tst_img=img1[idx==tst_fold]\n  dimension=224\n  trn_img=np.repeat(trn_img.reshape((trn_img.shape[0],dimension,dimension,1)),3,axis=3)\n  tst_img=np.repeat(tst_img.reshape((tst_img.shape[0],dimension,dimension,1)),3,axis=3)\n  return (trn_img.copy(),trn_y.copy()),(tst_img.copy(),tst_y.copy())","a85aacc1":"def load_model(last=True):   \n  K.clear_session() \n  #loading model\n  mod=ResNet50(include_top=True, weights='imagenet')\n  out_1=mod.layers[-2]\n  out=Dense(3,activation='softmax')(out_1.output)\n  model=Model(inputs=mod.input,outputs=out)\n\n  if last:\n    for i in range(len(model.layers)):\n        model.layers[i].trainable = False\n  model.layers[-1].trainable=True\n  return model","5121cc89":"best_accuracy_last={}\nfinal_accuracy_last={}\nhistory_last={}\nanswers_last={}\npredictions_last={}\npredictions_last_best={}\ntimes_last={}\n","8e7f8355":"\nimport keras\nimport pandas as pd\nfrom keras.applications.nasnet import NASNetMobile, preprocess_input\nimport imgaug as ia\nfrom imgaug import augmenters as iaa\n\ndef rotate_image(image, angle):\n  image_center = tuple(np.array(image.shape[1::-1]) \/ 2)\n  rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n  result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n  return result\ndef Hflip( images):\n\t\tseq = iaa.Sequential([iaa.Fliplr(1.0)])\n\t\treturn seq.augment_images(images)\ndef Vflip( images):\n\t\tseq = iaa.Sequential([iaa.Flipud(1.0)])\n\t\treturn seq.augment_images(images)\ndef noise(images):\n    ls=[]\n    for i in images:\n        x = np.random.normal(loc=0, scale=0.05, size=(dimension,dimension,3))\n        ls.append(i+x)\n    return ls\ndef rotate(images):\n    ls=[]\n    for angle in range(-15,20,5):\n        for image in images:\n            ls.append(rotate_image(image,angle))\n    return ls\n\nclass DataGenerator(keras.utils.Sequence):\n  def __init__(self, images, labels, batch_size=64, image_dimensions = (96 ,96 ,3), shuffle=False, augment=False):\n    self.labels       = labels              # array of labels\n    self.images = images        # array of image paths\n    self.batch_size   = batch_size          # batch size\n    self.on_epoch_end()\n\n  def __len__(self):\n    return int(np.floor(self.labels.shape[0] \/ self.batch_size))\n\n  def on_epoch_end(self):\n    self.indexes = np.arange(self.labels.shape[0])\n\n  def __getitem__(self, index):\n\t\t# selects indices of data for next batch\n    indexes = self.indexes[index * self.batch_size : (index + 1) * self.batch_size]\n    # select data and load images\n    labels = self.labels.loc[indexes]\n    img = [self.images[k].astype(np.float32) for k in indexes]\n    imgH=Hflip(img)\n    imgV=Vflip(img)\n    imgR=rotate(img)\n    images=[]\n    images.extend(imgH)\n    images.extend(imgV)\n    images.extend(imgR)\n    lbl=labels.copy()\n    labels=pd.DataFrame()\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    labels=pd.concat([labels,lbl],0)\n    #images = np.array([preprocess_input(img) for img in images])\n    return np.asarray(images), labels\n","17e2785f":"  from keras.callbacks import *\n  es=EarlyStopping(monitor='loss',patience=5,mode='min')\n  def upd(dk,data):\n    if dk==0:\n        dk=data\n    else:\n        for ky in data.keys():\n            dk[ky].extend(data[ky])\n    return dk\n  index=2\n  epoch=50\n  pre_acc=0\n  best=0\n  fold='fold_'+str(index)\n  trn,tst=get_trn_tst(df,index)\n  history_last[fold]=0\n\n\n\n  plt.imshow(trn[0][0])\n  plt.show()\n  plt.imshow(tst[0][0])\n  plt.show()\n\n\n\n  trn_x,trn_y=unison_shuffled_copies(trn[0],trn[1])\n  tst_x,tst_y=unison_shuffled_copies(tst[0],tst[1])\n\n\n\n  model=load_model(last=False)\n\n\n  \n  #compiling the model\n  model.compile(optimizer=Adam(6e-5,decay=0,clipnorm=1.0), \n                     loss='categorical_crossentropy', \n                     metrics=['accuracy'])\n  train_data = DataGenerator(trn_x,pd.get_dummies(trn_y), batch_size=4, augment=True)\n\n  \n  #fitting the model\n  #timing\n  start=time.time()\n  history_last=model.fit_generator(train_data,epochs=epoch,validation_data=[tst_x,to_categorical(tst_y)],steps_per_epoch=len(trn_x)\/\/4,callbacks=[es])\n  pre=model.predict(tst_x)\n  pre=np.argmax(pre,1)\n  \n  end=time.time()\n  times_last[fold]=end-start\n\n  #getting the prediction \n  pre=model.predict(tst_x)\n  \n\n\n\n  #select the maximum position\n  pre=np.argmax(pre,1)\n  predictions_last[fold]=pre\n\n  \n  \n  \n  #getting the accuracy\n  new_acc=accuracy_score(pre,tst_y)\n\n  \n\n\n  #storing the predictions\n  final_accuracy_last[fold]=new_acc\n\n\n\n\n\n\n\n\n  #storing the answers\n  answers_last[fold]=tst_y\n    \n    \n    \n    \n  #freeing memory\n  del([trn,tst,trn_x,trn_y,tst_x,tst_y])\n  gc.collect()\n\n","76b28c13":"\nnp.save('best_accuracy_last_fold3.npy',best_accuracy_last)\nnp.save('final_accuracy_last_fold3.npy',final_accuracy_last)\nnp.save('history_last_fold3.npy',history_last)\nnp.save('answers_last_fold3.npy',answers_last)\nnp.save('predictions_last_fold3.npy',predictions_last)\nnp.save('predictions_last_best_fold3.npy',predictions_last_best)\nnp.save('times_last_fold3.npy',times_last)","09956610":"plt.imshow(history_last.history['loss'])","753a7cb6":"Function to load model\n\n","3a58510d":"Function to shuffle data in fold and load each fold\n\n","46ca6010":"Loading the data\n\n","3c96cba7":"saving data","82ce3049":"Verfying model stricture\n\n","a400a59b":"Importing libraries\n\n","6dbc2f92":"Make Prediction\n\n","f8423239":"Preparing data\n\n","2b6e7ed3":"Dictionaries to store results\n\n"}}