{"cell_type":{"45dd6a44":"code","6bd6d449":"code","07ac920f":"code","3c670b51":"code","655aaaab":"code","66f74a82":"code","b30bac1b":"code","b7ec8b01":"code","38040cd5":"code","45501b28":"code","debaefa7":"code","2285b0c2":"code","2a91c2e1":"code","38e06f98":"code","4a178b32":"code","f70203a6":"code","4139851a":"code","9a484bcd":"code","2cd22356":"code","88867155":"code","6b838c16":"markdown","bcdf9bda":"markdown","f91b588b":"markdown","93908df2":"markdown","bf5f6fb8":"markdown","ff56b1fe":"markdown","1ea9f4e1":"markdown","eab7d8bd":"markdown","2c32c90c":"markdown","77d2060c":"markdown","d55bea8a":"markdown"},"source":{"45dd6a44":"!pip install python-ternary","6bd6d449":"import os\nimport ternary\nimport numpy as np\nimport cmath\nimport math\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom dataclasses import dataclass\n\n%config InlineBackend.figure_format = 'retina'","07ac920f":"%%writefile geo.py\nimport operator\nimport numpy as np\nimport cmath\nfrom typing import List\nfrom collections import namedtuple\nimport traceback\nimport sys\n\nbasis = np.array(\n    [1, cmath.exp(2j * cmath.pi * 1 \/ 3), cmath.exp(2j * cmath.pi * 2 \/ 3)]\n)\n\nHistMatchResult = namedtuple(\"HistMatchResult\", \"idx length\")\noutput = None\nprobs = None\n\ndef find_all_longest(seq, max_len=None) -> List[HistMatchResult]:\n    \"\"\"\n    Find all indices where end of `seq` matches some past.\n    \"\"\"\n    result = []\n\n    i_search_start = len(seq) - 2\n\n    while i_search_start > 0:\n        i_sub = -1\n        i_search = i_search_start\n        length = 0\n\n        while i_search >= 0 and seq[i_sub] == seq[i_search]:\n            length += 1\n            i_sub -= 1\n            i_search -= 1\n\n            if max_len is not None and length > max_len:\n                break\n\n        if length > 0:\n            result.append(HistMatchResult(i_search_start + 1, length))\n\n        i_search_start -= 1\n\n    result = sorted(result, key=operator.attrgetter(\"length\"), reverse=True)\n\n    return result\n\n\ndef probs_to_complex(p):\n    return p @ basis\n\n\ndef _fix_probs(probs):\n    \"\"\"\n    Put probs back into triangle. Sometimes this happens due to rounding errors or if you\n    use complex numbers which are outside the triangle.\n    \"\"\"\n    if min(probs) < 0:\n        probs -= min(probs)\n\n    probs \/= sum(probs)\n\n    return probs\n\n\ndef complex_to_probs(z):\n    probs = (2 * (z * basis.conjugate()).real + 1) \/ 3\n    probs = _fix_probs(probs)\n    return probs\n\n\ndef z_from_action(action):\n    return basis[action]\n\n\ndef sample_from_z(z):\n    probs = complex_to_probs(z)\n    return np.random.choice(3, p=probs)\n\n\ndef bound(z):\n    return probs_to_complex(complex_to_probs(z))\n\n\ndef norm(z):\n    return bound(z \/ abs(z))\n\n\nclass Pred:\n    def __init__(self, *, alpha):\n        self.offset = 0\n        self.alpha = alpha\n        self.last_feat = None\n\n    def train(self, target):\n        if self.last_feat is not None:\n            offset = target * self.last_feat.conjugate()  # fixed\n\n            self.offset = (1 - self.alpha) * self.offset + self.alpha * offset\n\n    def predict(self, feat):\n        \"\"\"\n        feat is an arbitrary feature with a probability on 0,1,2\n        anything which could be useful anchor to start with some kind of sensible direction\n        \"\"\"\n        feat = norm(feat)\n\n        # offset = mean(target - feat)\n        # so here we see something like: result = feat + mean(target - feat)\n        # which seems natural and accounts for the correlation between target and feat\n        # all RPSContest bots do no more than that as their first step, just in a different way\n\n        result = feat * self.offset\n\n        self.last_feat = feat\n\n        return result\n\n\nclass BaseAgent:\n    def __init__(self):\n        self.my_hist = []\n        self.opp_hist = []\n        self.my_opp_hist = []\n        self.outcome_hist = []\n        self.step = None\n\n    def __call__(self, obs, conf):\n        global output\n        try:\n            if obs.step == 0:\n                output = np.random.choice(3)\n                return output\n\n            self.step = obs.step\n\n            opp = int(obs.lastOpponentAction)\n            self.my_hist.append(output)\n            self.my_opp_hist.append((output, opp))\n            self.opp_hist.append(opp)\n\n            outcome = {0: 0, 1: 1, 2: -1}[(output - opp) % 3]\n            self.outcome_hist.append(outcome)\n\n            output = self.action()\n            return output\n        except Exception:\n            traceback.print_exc(file=sys.stderr)\n            raise\n\n    def action(self):\n        pass\n\n\nclass Agent(BaseAgent):\n    def __init__(self, alpha=0.01):\n        super().__init__()\n        self.pred = None\n\n        self.predictor = Pred(alpha=alpha)\n\n    def action(self):\n        global probs\n        self.train()\n\n        pred = self.preds()\n\n        return_action = sample_from_z(pred)\n        probs = complex_to_probs(pred)\n\n        return return_action\n\n    def train(self):\n        last_beat_opp = z_from_action((self.opp_hist[-1] + 1) % 3)\n        self.predictor.train(last_beat_opp)\n\n    def preds(self):\n        hist_match = find_all_longest(self.my_opp_hist, max_len=20)\n\n        if not hist_match:\n            return 0\n\n        feat = z_from_action(self.opp_hist[hist_match[0].idx])\n\n        pred = self.predictor.predict(feat)\n\n        return pred\n\n\nagent = Agent()\n\n\ndef call_agent(obs, conf):\n    return agent(obs, conf)","3c670b51":"%%writefile geo_beater.py\nimport operator\nimport numpy as np\nimport cmath\nfrom collections import namedtuple\n\nbasis = np.array([1, cmath.exp(2j * cmath.pi * 1 \/ 3), cmath.exp(2j * cmath.pi * 2 \/ 3)])\nHistMatchResult = namedtuple(\"HistMatchResult\", \"idx length\")\n\n\ndef find_all_longest(seq, max_len=None):\n    result = []\n    i_search_start = len(seq) - 2\n    while i_search_start > 0:\n        i_sub = -1\n        i_search = i_search_start\n        length = 0\n        while i_search >= 0 and seq[i_sub] == seq[i_search]:\n            length += 1\n            i_sub -= 1\n            i_search -= 1\n            if max_len is not None and length > max_len: break\n        if length > 0: result.append(HistMatchResult(i_search_start + 1, length))\n        i_search_start -= 1\n\n    return sorted(result, key=operator.attrgetter(\"length\"), reverse=True)\n\n\ndef complex_to_probs(z):\n    probs = (2 * (z * basis.conjugate()).real + 1) \/ 3\n    if min(probs) < 0: probs -= min(probs)\n    return probs \/ sum(probs)\n\n\nopp_hist = []\nmy_opp_hist = []\noffset = 0\nlast_feat = None\noutput = None\nprobs = None\nphase_shift = 1\/9\n\n\ndef agent(obs, conf):\n    global output, opp_hist, my_opp_hist, offset, last_feat, probs\n\n    if obs.step == 0:\n        output = np.random.choice(3)\n    else:\n        my_opp_hist.append((obs.lastOpponentAction, output))\n        opp_hist.append(output)\n\n        if last_feat is not None:\n            this_offset = (basis[(opp_hist[-1] + 1) % 3]) * last_feat.conjugate()\n            offset = (1 - .01) * offset + .01 * this_offset\n\n        hist_match = find_all_longest(my_opp_hist, 20)\n        if not hist_match:\n            pred = 0\n        else:\n            feat = basis[opp_hist[hist_match[0].idx]]\n            last_feat = complex_to_probs(feat \/ abs(feat)) @ basis\n            pred = last_feat * offset * cmath.exp(2j * cmath.pi * phase_shift)\n\n        probs = complex_to_probs(pred)\n        output = (int(np.argmax(probs)) + 1) % 3\n\n    return output\n","655aaaab":"%%writefile otm.py\n\nimport numpy as np\nimport pandas as pd\nimport random\n\nT = np.zeros((3, 3))\nP = np.zeros((3, 3))\n\n# a1 is the action of the opponent 1 step ago\n# a2 is the action of the opponent 2 steps ago\na1, a2 = None, None\nprobs = None\n\ndef transition_agent(observation, configuration):\n    global T, P, a1, a2, probs\n    if observation.step > 1:\n        a1 = observation.lastOpponentAction\n        T[a2, a1] += 1\n        P = np.divide(T, np.maximum(1, T.sum(axis=1)).reshape(-1, 1))\n        a2 = a1\n        probs = P[a1, :]\n        if np.sum(P[a1, :]) == 1:\n            return int((np.random.choice(\n                [0, 1, 2],\n                p=P[a1, :]\n            ) + 1) % 3)\n        else:\n            return int(np.random.randint(3))\n    else:\n        if observation.step == 1:\n            a2 = observation.lastOpponentAction\n        return int(np.random.randint(3))","66f74a82":"%%writefile otm_beater.py\n\nimport numpy as np\nimport pandas as pd\nimport random\n\nT = np.zeros((3, 3))\nP = np.zeros((3, 3))\n\na1, a2 = None, None\nlast_action = None # track my action.\nprobs = None\nphase_shift = 1\/9\n\n\n# Some helper functions to do probability calculations with complex numbers\nimport cmath\n\nbasis = np.exp(2j * cmath.pi * np.arange(3) \/ 3)\n\n\ndef probs_to_complex(p):\n    return p @ basis\n\n\ndef _fix_probs(probs):\n    \"\"\"\n    Put probs back into triangle. Sometimes this happens due to rounding errors or if you\n    use complex numbers which are outside the triangle.\n    \"\"\"\n    if min(probs) < 0:\n        probs -= min(probs)\n    probs \/= sum(probs)\n    return probs\n\n\ndef complex_to_probs(z):\n    probs = (2 * (z * basis.conjugate()).real + 1) \/ 3\n    probs = _fix_probs(probs)\n    return probs\n\n\n###########################################\n# Original agent with modifications marked ->\n###########################################\n\ndef anti_transition_agent(observation, configuration):\n    global T, P, a1, a2, last_action, probs\n    if observation.step > 1:\n        a1 = last_action   # on me only; take mirrored view on game\n        T[a2, a1] += 1\n        P = np.divide(T, np.maximum(1, T.sum(axis=1)).reshape(-1, 1))\n        a2 = a1\n        if np.sum(P[a1, :]) == 1:\n            probs = P[a1,:]\n            \n            ### add phase and remove random mixin\n            z = probs_to_complex(probs)\n            \n            z *= cmath.exp(2j * cmath.pi * phase_shift)\n            \n            if z != 0:\n                z \/= abs(z)\n                \n            probs=complex_to_probs(z)\n            ###\n            \n            result = int((np.random.choice(3, p=probs) + 1) % 3)\n        else:\n            result = int(np.random.randint(3))\n    else:\n        if observation.step == 1:\n            a2 = last_action    # on me only\n        result = int(np.random.randint(3))\n        \n    result = (result + 1) % 3  # beat what he would have done\n        \n    last_action = result\n        \n    return result","b30bac1b":"%%writefile otm_beater_constant.py\n\nprobs = None\n\nmoves = [1, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 1, 0, 1, 0, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 2, 1, 0, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0]\n\ndef agent(o, c):\n    return moves[o.step]","b7ec8b01":"%%writefile statistical.py\nimport numpy as np\n\naction_histogram = np.zeros(3)\nprobs = None\n\n\ndef statistical(observation, configuration):\n    global action_histogram, probs\n    if observation.step == 0:\n        return 0\n    action = observation.lastOpponentAction\n    action_histogram[action] += 1\n    probs = action_histogram \/ action_histogram.sum()\n\n    return (action_histogram.argmax() + 1) % 3","38040cd5":"%%writefile statistical_beater.py\n\nprobs = None\n\nmoves = [0, 0, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n 1]\n\ndef agent(o, c):\n    return moves[o.step]","45501b28":"@dataclass\nclass Observation:\n    lastOpponentAction: int\n    step: int\n\n\n@dataclass\nclass Configuration:\n    episode_steps: int = 1000\n    signs: int = 3\n\nREWARDS = [[0, -1, 1], [1, 0, -1], [-1, 1, 0]]\n\nclass Bot:\n    def __init__(self, path, name=None):\n        self.path = path\n        self.step = 0\n        if name is not None:\n            self.name = name\n        else:\n            self.name = os.path.splitext(os.path.basename(path))[0]\n        self._load(path)\n\n    def _load(self, path):\n        with open(path) as f:\n            code = f.read()\n        self.context = {}\n        code = compile(code, \"<string>\", \"exec\")\n        exec(code, self.context)\n        self.bot_method = [v for v in self.context.values() if callable(v)][-1]\n\n    def move(self, prev):\n        c = Configuration()\n        o = Observation(lastOpponentAction=prev, step=self.step)\n        self.step += 1\n        return self.bot_method(o, c)\n\ndef play_match(bot1, bot2, rounds, quiet=True):\n    rewards = [0]\n    moves = []\n    prev = [None, None]\n    probs1 = []\n    probs2 = []\n    for step in range(rounds):\n        prev = [bot1.move(prev[1]), bot2.move(prev[0])]\n        if bot1.context['probs'] is not None:\n            probs1.append(bot1.context['probs'])\n        if bot2.context['probs'] is not None:\n            probs2.append(bot2.context['probs'])\n        rewards.append(rewards[-1] + REWARDS[prev[0]][prev[1]])\n        moves.append(prev)\n\n    return moves, rewards, probs1, probs2\n\nbasis = np.array(\n    [1, cmath.exp(2j * cmath.pi * 1 \/ 3), cmath.exp(2j * cmath.pi * 2 \/ 3)]\n)\n\ndef probs_to_complex(p):\n    return p @ basis\n\ndef plot_rewards(df_rewards, title):\n    df_rewards.plot(figsize=(15, 5), title=title, legend=False)\n    plt.show()\n\ndef plot_probs_area(df_probs, title):\n    if (len(df_probs)) > 0:\n        df_probs.plot(figsize=(15, 5), kind='area', title=title, linewidth=0)\n        plt.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))\n        plt.show()\n    \ndef plot_probs_ternary(df_probs, title):\n    if (len(df_probs)) > 0:\n        figure, tax = ternary.figure(scale=1)\n        figure.set_size_inches(7, 7)\n\n        tax.gridlines(multiple=0.1)\n\n        tax.right_corner_label('P', fontsize=20)\n        tax.top_corner_label('S', fontsize=20)\n        tax.left_corner_label('R', fontsize=20)\n        tax.scatter(df_probs.values, linewidth=.5, s=3, c=np.arange(len(df_probs)) \/ len(df_probs))\n        tax.ticks(axis='lbr', multiple=0.1, linewidth=1, tick_formats=\"%.1f\", offset=0.02)\n\n        tax.get_axes().axis('off')\n        tax.clear_matplotlib_ticks()\n        plt.title(title, pad=50, fontsize=16)\n        tax.boundary(linewidth=0.5)\n        tax.show()\n    \ndef plot_probs_product(df_probs_original, df_probs_beater, original_bot_name, beater_bot_name):\n    df_probs_original.eval('R * P * S').plot(figsize=(15, 5), title='Product of action probabilities (R*P*S)')\n    if (len(df_probs_beater)) > 0:\n        df_probs_beater.eval('R * P * S').plot()\n    plt.legend([original_bot_name, beater_bot_name], loc='center left', bbox_to_anchor=(1.0, 0.5))\n    plt.show()\n    \ndef make_plots(original_bot, beater_bot, num_rounds, plot_original=True, plot_beater=True):\n    moves, rewards, probs_beater, probs_original = play_match(beater_bot, original_bot, num_rounds)\n    df_probs_original = pd.DataFrame(probs_original, columns=list('RPS'))\n    df_probs_beater = pd.DataFrame(probs_beater, columns=list('RPS'))\n    df_rewards = pd.DataFrame(rewards, columns=['rewards'])\n    plot_rewards(df_rewards, f'{beater_bot.name} reward')\n    plot_probs_area(df_probs_original, f'{original_bot.name} action probabilities distribution')\n    plot_probs_area(df_probs_beater, f'{beater_bot.name} action probabilities distribution')\n    plot_probs_ternary(df_probs_original, f'{original_bot.name} action probabilities distribution')\n    plot_probs_ternary(df_probs_beater, f'{beater_bot.name} action probabilities distribution')\n    plot_probs_product(df_probs_original, df_probs_beater, original_bot.name, beater_bot.name)","debaefa7":"PHASE_SHIFT = 0\noriginal_bot = Bot('geo.py')\nbeater_bot = Bot('geo_beater.py', name=f'geo_beater with {PHASE_SHIFT:+.3f}')\nbeater_bot.context['phase_shift'] = PHASE_SHIFT\nmake_plots(original_bot, beater_bot, 1000)","2285b0c2":"PHASE_SHIFT = 1\/9\noriginal_bot = Bot('geo.py')\nbeater_bot = Bot('geo_beater.py', name=f'geo_beater with {PHASE_SHIFT:+.3f}')\nbeater_bot.context['phase_shift'] = PHASE_SHIFT\nmake_plots(original_bot, beater_bot, 1000)","2a91c2e1":"PHASE_SHIFT = 1\/7\noriginal_bot = Bot('geo.py')\nbeater_bot = Bot('geo_beater.py', name=f'geo_beater with {PHASE_SHIFT:+.3f}')\nbeater_bot.context['phase_shift'] = PHASE_SHIFT\nmake_plots(original_bot, beater_bot, 1000)","38e06f98":"PHASE_SHIFT = 1\/11\noriginal_bot = Bot('geo.py')\nbeater_bot = Bot('geo_beater.py', name=f'geo_beater with {PHASE_SHIFT:+.3f}')\nbeater_bot.context['phase_shift'] = PHASE_SHIFT\nmake_plots(original_bot, beater_bot, 1000)","4a178b32":"PHASE_SHIFT = 1\/6\noriginal_bot = Bot('geo.py')\nbeater_bot = Bot('geo_beater.py', name=f'geo_beater with {PHASE_SHIFT:+.3f}')\nbeater_bot.context['phase_shift'] = PHASE_SHIFT\nmake_plots(original_bot, beater_bot, 1000)","f70203a6":"PHASE_SHIFT = 0\noriginal_bot = Bot('otm.py')\nbeater_bot = Bot('otm_beater.py', name=f'otm_beater with {PHASE_SHIFT:+.3f}')\nbeater_bot.context['phase_shift'] = PHASE_SHIFT\nmake_plots(original_bot, beater_bot, 1000)","4139851a":"PHASE_SHIFT = 1\/9\noriginal_bot = Bot('otm.py')\nbeater_bot = Bot('otm_beater.py', name=f'otm_beater with {PHASE_SHIFT:+.3f} phase shift')\nbeater_bot.context['phase_shift'] = PHASE_SHIFT\nmake_plots(original_bot, beater_bot, 1000)","9a484bcd":"original_bot = Bot('otm.py')\nbeater_bot = Bot('otm_beater_constant.py')\nmake_plots(original_bot, beater_bot, 999)","2cd22356":"bot1 = Bot('otm.py')\nbot2 = Bot('geo.py')\nmake_plots(bot1, bot2, 1000)","88867155":"original_bot = Bot('statistical.py')\nbeater_bot = Bot('statistical_beater.py')\nmake_plots(original_bot, beater_bot, 1000)","6b838c16":"## otm vs otm_beater without phase shift","bcdf9bda":"## geo vs geo_beater with +1\/7 phase shift","f91b588b":"## geo vs geo_beater with +1\/9 phase shift","93908df2":"## otm vs otm_beater_constant","bf5f6fb8":"## otm vs geo","ff56b1fe":"## geo vs geo_beater without phase shift","1ea9f4e1":"## geo vs geo_beater with +1\/11 phase shift","eab7d8bd":"## statistical vs statistical_beater","2c32c90c":"<img src=\"https:\/\/image.freepik.com\/free-vector\/all-seeing-eye-pyramid-symbol-engraving-tattoo-style-freemason-spiritual-illuminati-religion-triangle-magic_1284-41377.jpg\" width=\"300\">\n\nMaybe looking at distributions of action probabilities for geo and geo beater with and without 1\/9 phase shift can give us some insights. What is clearly seen that 1\/9 shift somehow perturbs probabilities quite a lot, while without it they are almost flat. Another interesting pattern is that in ternary space those probabilities lie in a smaller rotated triangle. Actually looks like there are many triangle orbits. Moreover the rotation angle is the same from game to game for original bot and its beater.\n\nSome questions for further exploration:\n- How different phase shifts change distribution look\n- Why 1\/9 performs best?\n- Can we do better?\n- Can this trick be applied to other bots?","77d2060c":"## otm vs otm_beater with +1\/9 phase shift","d55bea8a":"## geo vs geo_beater with +1\/6 phase shift"}}