{"cell_type":{"b0b44cfa":"code","b1f1ca94":"code","692888c4":"code","f7494c3f":"code","a30c7244":"code","9a9c9c2f":"code","6a6c645d":"code","957ce675":"code","51871077":"code","ff1d06f5":"code","5b71758b":"code","af9fb745":"code","81050fad":"code","a4c1e6bd":"markdown","2b0749c3":"markdown","51710e05":"markdown","3d824057":"markdown","23744d8b":"markdown","cb9b6744":"markdown","c5bd0661":"markdown","2c2fa854":"markdown","1aaa456f":"markdown","7e07c7b1":"markdown","e80dd72c":"markdown","35204f9b":"markdown","74b74933":"markdown"},"source":{"b0b44cfa":"import pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot","b1f1ca94":"def timeseries(min_date, max_date):\n    time_index = pd.date_range(min_date, max_date)\n    dates = (pd.DataFrame({'ds': pd.to_datetime(time_index.values)},\n                          index=range(len(time_index))))\n    y = np.random.random_sample(len(dates))*10\n    dates['y'] = y\n    return dates","692888c4":"s = timeseries('2019-01-01','2020-12-30')","f7494c3f":"series = [timeseries('2019-01-01','2020-12-30') for x in range(0,500)]","a30c7244":"series[1].plot(x = 'ds', y = 'y')","9a9c9c2f":"from fbprophet import Prophet","6a6c645d":"def run_prophet(timeserie):\n    model = Prophet(yearly_seasonality=False,daily_seasonality=False)\n    model.fit(timeserie)\n    forecast = model.make_future_dataframe(periods=200, include_history=False)\n    forecast = model.predict(forecast)\n    return forecast","957ce675":"x = run_prophet(series[0])","51871077":"x.head()","ff1d06f5":"import time\nfrom tqdm import tqdm","5b71758b":"start_time = time.time()\nresult = list(map(lambda timeserie: run_prophet(timeserie), tqdm(series)))\nprint(\"--- %s seconds ---\" % (time.time() - start_time))","af9fb745":"from multiprocessing import Pool, cpu_count","81050fad":"start_time2 = time.time()\np = Pool(cpu_count())\npredictions = list(tqdm(p.imap(run_prophet, series), total=len(series)))\np.close()\np.join()\nprint(\"--- %s seconds ---\" % (time.time() - start_time2))","a4c1e6bd":"Adding multiprocessing to our code, Here we will launch a process for each time-serie forecast, so we can run our run_prophet function in parallel while we do the map of the list.","2b0749c3":"We can see our forecasted results for that serie","51710e05":"A random time-series","3d824057":"The code took: `20.8641842` minutes to run","23744d8b":"### So we got a speedup of `12.60157522`","cb9b6744":"## Generating time-series","c5bd0661":"Let\u2019s create a simple Prophet model, for this we define a function that takes a time-series and fits a model with the data, then we can use that model to predict the next 200 days.","2c2fa854":"With the previous code, we launch N processes depending of how many CPUs our machine has\nThe code took `8.26260898` minutes to run","1aaa456f":"## Conclusion\nWe could see that using multiprocessing is a great way to forecasting multiple time-series faster, in many problems multiprocessing could help to reduce the execution time of our code.","7e07c7b1":"## Forecasting using Prophet","e80dd72c":"We are going to generate 500 random time-series, the purpose of this notebook is not to evaluate the effectiveness of Prophet prediction, but the time required to do accomplish this.","35204f9b":"if we want to run this faster, we could use a machine with more CPUs","74b74933":"## Running 500 time-series:"}}