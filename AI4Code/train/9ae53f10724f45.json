{"cell_type":{"f7776a2e":"code","fc79e812":"code","29bcf1ed":"code","3754b12a":"code","35718624":"code","c444e101":"code","f0191f88":"code","31ff6560":"code","43da4f34":"code","9e336b7e":"code","560f9b55":"code","28de5e33":"code","f1165123":"code","0de22e31":"code","080bb293":"code","3ea7b8cc":"code","b0ec8703":"code","32178bfd":"code","4dff3e6e":"code","e20e1000":"code","ce5cc744":"code","6ae7bdb6":"code","deeab56f":"code","b1c7cd7d":"code","f8c2c7bf":"code","47aad21a":"code","54d213e8":"code","4f2a5097":"code","e339f61d":"code","802ffab8":"code","7fee8f02":"code","78721a97":"code","d65759df":"code","f6fcce2c":"code","34fa2d96":"code","aa90db57":"code","306eb020":"code","3a7160e1":"code","b8bbfd58":"code","cec79e33":"code","57f661d8":"code","b1818e52":"code","5c67d51b":"code","801bd771":"code","122c3cb2":"code","136a7abe":"code","b77ceb9f":"code","81bd1269":"code","fc255505":"code","b2b17772":"code","07b40db2":"code","024ae706":"code","bec6354f":"code","0bc86998":"code","3c3ddd28":"code","f077291d":"code","35bae023":"code","eb3c56dd":"markdown","80d43fe3":"markdown","2c8f24c8":"markdown","ef00d504":"markdown","55bd385e":"markdown","c83e0b6e":"markdown","d87f8375":"markdown","0f148f69":"markdown","ac3a7f2d":"markdown","095c0615":"markdown","5197c435":"markdown"},"source":{"f7776a2e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","fc79e812":"!pip install dash","29bcf1ed":"import numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.offline as po\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport dash\nimport plotly.express as px\nimport random\nimport plotly.figure_factory as ff\nfrom plotly import tools\nfrom plotly.subplots import make_subplots\nfrom plotly.offline import iplot\nimport warnings\nwarnings.filterwarnings(\"ignore\")\npd.set_option(\"display.max_rows\",None)\nfrom sklearn import preprocessing \n%matplotlib inline\n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom imblearn.combine import SMOTEENN #resampling\nfrom sklearn import datasets, linear_model, metrics\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\n","3754b12a":"df = pd.read_csv('..\/input\/diabetes-health-indicators-dataset\/diabetes_binary_health_indicators_BRFSS2015.csv')\ndf.head()","35718624":"df.shape","c444e101":"df.info()","f0191f88":"df['Diabetes_binary'].value_counts()","31ff6560":"df.isnull().sum()","43da4f34":"df.columns","9e336b7e":"colors = px.colors.cyclical.Twilight\nfig = make_subplots(rows=1,cols=2,\n                    subplot_titles=('Countplot',\n                                    'Percentages'),\n                    specs=[[{\"type\": \"xy\"},\n                            {'type':'domain'}]])\nfig.add_trace(go.Bar(y = df['Age'].value_counts().values.tolist(), \n                      x = df['Age'].value_counts().index, \n                      text=df['Age'].value_counts().values.tolist(),\n              textfont=dict(size=15),\n                      textposition = 'outside',\n                      showlegend=False,\n              marker = dict(color = colors,\n                            line_color = 'black',\n                            line_width=3)),row = 1,col = 1)\nfig.add_trace((go.Pie(labels=df['Age'].value_counts().keys(),\n                             values=df['Age'].value_counts().values,textfont = dict(size = 12),\n                     hole = .5,\n                     marker=dict(colors=colors),\n                     textinfo='label+percent',\n                     hoverinfo='label')), row = 1, col = 2)\nfig.update_yaxes(range=[0,40000])\nfig.update_xaxes(range=[0,15])\n#Changing plot & figure background \nfig.update_layout(\n                    paper_bgcolor= '#FFFDE7',\n                    plot_bgcolor= '#FFFDE7',\n                    title=dict(text = \"Age Distribution\",x=0.5,y=0.95),\n                    title_font_size=30,\n                    width=1000,\n                    height=600\n                  )\niplot(fig)","560f9b55":"df['Age'].value_counts()","28de5e33":"df['Sex'].value_counts()","f1165123":"colors = px.colors.cyclical.Twilight\nfig = make_subplots(rows=1,cols=2,\n                    subplot_titles=('Countplot',\n                                    'Percentages'),\n                    specs=[[{\"type\": \"xy\"},\n                            {'type':'domain'}]])\nfig.add_trace(go.Bar(y = df['Sex'].map({0:'F',1:'M'}).value_counts().values.tolist(), \n                      x = df['Sex'].map({0:'F',1:'M'}).value_counts().index, \n                      text=df['Sex'].map({0:'F',1:'M'}).value_counts().values.tolist(),\n              textfont=dict(size=15),\n                      textposition = 'outside',\n                      showlegend=False,\n              marker = dict(color = colors,\n                            line_color = 'black',\n                            line_width=3)),row = 1,col = 1)\nfig.add_trace((go.Pie(labels=df['Sex'].map({0:'F',1:'M'}).value_counts().keys(),\n                             values=df['Sex'].map({0:'F',1:'M'}).value_counts().values,textfont = dict(size = 16),\n                     hole = .4,\n                     marker=dict(colors=colors),\n                     textinfo='label+percent',\n                     hoverinfo='label')), row = 1, col = 2)\nfig.update_yaxes(range=[0,150000])\n#Changing plot & figure background \nfig.update_layout(\n                    paper_bgcolor= '#FFFDE7',\n                    plot_bgcolor= '#FFFDE7',\n                    title=dict(text = \"Gender Distribution\",x=0.5,y=0.95),\n                    title_font_size=30,\n                    width=1000,\n                    height=600\n                  )\niplot(fig)","0de22e31":"df.corr().sort_values('Diabetes_binary')","080bb293":"colors = px.colors.cyclical.Twilight\nfig = make_subplots(rows=1,cols=2,\n                    subplot_titles=('Countplot',\n                                    'Percentages'),\n                    specs=[[{\"type\": \"xy\"},\n                            {'type':'domain'}]])\nfig.add_trace(go.Bar(y = df['Income'].map({1:'< $10,000',5:'< $35,000',8:'> $75,000'}).value_counts().values.tolist(), \n                      x = df['Income'].map({1:'< $10,000',5:'< $35,000',8:'> $75,000'}).value_counts().index, \n                      text=df['Income'].map({1:'< $10,000',5:'< $35,000',8:'> $75,000'}).value_counts().values.tolist(),\n              textfont=dict(size=15),\n                      textposition = 'outside',\n                      showlegend=False,\n              marker = dict(color = colors,\n                            line_color = 'black',\n                            line_width=3)),row = 1,col = 1)\nfig.add_trace((go.Pie(labels=df['Income'].map({1:'< $10,000',5:'< $35,000',8:'> $75,000'}).value_counts().keys(),\n                             values=df['Income'].map({1:'< $10,000',5:'< $35,000',8:'> $75,000'}).value_counts().values,textfont = dict(size = 16),\n                     hole = .4,\n                     marker=dict(colors=colors),\n                     textinfo='label+percent',\n                     hoverinfo='label')), row = 1, col = 2)\nfig.update_yaxes(range=[0,150000])\n#Changing plot & figure background \nfig.update_layout(\n                    paper_bgcolor= '#FFFDE7',\n                    plot_bgcolor= '#FFFDE7',\n                    title=dict(text = \"Income Distribution\",x=0.5,y=0.95),\n                    title_font_size=30,\n                    width=1000,\n                    height=600\n                  )\niplot(fig)","3ea7b8cc":"edu = {1:'Never attended school',2:'Elementary',3:'Some high school',\n4:'High school graduate',5:'Some college or technical school',6:'College graduate'}","b0ec8703":"edu","32178bfd":"colors = px.colors.cyclical.Twilight\nfig = make_subplots(rows=1,cols=2,\n                    subplot_titles=('Countplot',\n                                    'Percentages'),\n                    specs=[[{\"type\": \"xy\"},\n                            {'type':'domain'}]])\nfig.add_trace(go.Bar(y = df['Education'].map(edu).value_counts().values.tolist(), \n                      x = df['Education'].map(edu).value_counts().index, \n                      text=df['Education'].map(edu).value_counts().values.tolist(),\n              textfont=dict(size=15),\n                      textposition = 'outside',\n                      showlegend=False,\n              marker = dict(color = colors,\n                            line_color = 'black',\n                            line_width=3)),row = 1,col = 1)\nfig.add_trace((go.Pie(labels=df['Education'].map(edu).value_counts().keys(),\n                             values=df['Education'].map(edu).value_counts().values,textfont = dict(size = 16),\n                     hole = .4,\n                     marker=dict(colors=colors),\n                     textinfo='label+percent',\n                     hoverinfo='label')), row = 1, col = 2)\nfig.update_yaxes(range=[0,120000])\n#Changing plot & figure background \nfig.update_layout(\n                    paper_bgcolor= '#FFFDE7',\n                    plot_bgcolor= '#FFFDE7',\n                    title=dict(text = \"Education Distribution\",x=0.5,y=0.95),\n                    title_font_size=30,\n                    width=1000,\n                    height=600\n                  )\niplot(fig)","4dff3e6e":"df.columns","e20e1000":"colors = px.colors.cyclical.Twilight\nfig = make_subplots(rows=1,cols=2,\n                    subplot_titles=('Countplot',\n                                    'Percentages'),\n                    specs=[[{\"type\": \"xy\"},\n                            {'type':'domain'}]])\nfig.add_trace(go.Bar(y = df['PhysActivity'].map({0:'No',1:'Yes'}).value_counts().values.tolist(), \n                      x = df['PhysActivity'].map({0:'No',1:'Yes'}).value_counts().index, \n                      text=df['PhysActivity'].map({0:'No',1:'Yes'}).value_counts().values.tolist(),\n              textfont=dict(size=15),\n                      textposition = 'outside',\n                      showlegend=False,\n              marker = dict(color = colors,\n                            line_color = 'black',\n                            line_width=3)),row = 1,col = 1)\nfig.add_trace((go.Pie(labels=df['PhysActivity'].map({0:'No',1:'Yes'}).value_counts().keys(),\n                             values=df['PhysActivity'].map({0:'No',1:'Yes'}).value_counts().values,textfont = dict(size = 16),\n                     hole = .4,\n                     marker=dict(colors=colors),\n                     textinfo='label+percent',\n                     hoverinfo='label')), row = 1, col = 2)\nfig.update_yaxes(range=[0,220000])\n#Changing plot & figure background \nfig.update_layout(\n                    paper_bgcolor= '#FFFDE7',\n                    plot_bgcolor= '#FFFDE7',\n                    title=dict(text = \"PhysActivity Distribution\",x=0.5,y=0.95),\n                    title_font_size=30,\n                    width=1000,\n                    height=600\n                  )\niplot(fig)","ce5cc744":"df.columns","6ae7bdb6":"categorical_cols = ['HighBP','HighChol','CholCheck','Smoker','Stroke','HeartDiseaseorAttack',\n'PhysActivity','Fruits', 'Veggies','HvyAlcoholConsump','AnyHealthcare','NoDocbcCost','GenHlth',\n'DiffWalk','Sex','Education','Income']\nnumerical_cols=['BMI','MentHlth', 'PhysHlth']","deeab56f":"sns.set_theme(rc = {'figure.dpi': 220, 'axes.labelsize': 6, \n                    'axes.facecolor': '#FFFDE7', 'grid.color': '#fffdfa', \n                    'figure.facecolor': '#FFFDE7'}, font_scale = 0.55)\nfig, ax = plt.subplots(9, 2, figsize = (6, 25))\nfor indx, (column, axes) in list(enumerate(list(zip(categorical_cols, ax.flatten())))):\n    if column not in 'Diabetes_binary':\n        sns.countplot(ax = axes, x = df[column], hue = df['Diabetes_binary'], palette = {'#f0b0d2','#56b4fa'}, alpha = 1)  \nelse:\n    [axes.set_visible(False) for axes in ax.flatten()[indx + 1:]]   \naxes_legend = ax.flatten()\naxes_legend[1].legend(title = 'Diabetes_binary', loc = 'upper right')\naxes_legend[2].legend(title = 'Diabetes_binary', loc = 'upper right')\nplt.show()","b1c7cd7d":"sns.set_theme(rc = {'figure.dpi': 250, 'axes.labelsize': 6, \n                    'axes.facecolor': '#FFFDE7', 'grid.color': '#fffdfa', \n                    'figure.facecolor': '#FFFDE7'}, font_scale = 0.55)\nfig, ax = plt.subplots(9, 2, figsize = (6, 25))\ncat2 = []\nfor i in categorical_cols:\n    if i not in 'Income':\n        cat2.append(i)\nfor indx, (column, axes) in list(enumerate(list(zip(cat2, ax.flatten())))):\n    sns.countplot(ax = axes, x = df[column], hue = df['Income'].map({1:'< $10,000',5:'< $35,000',8:'> $75,000'})\n    , palette = colors, alpha = 1)  \nelse:\n    [axes.set_visible(False) for axes in ax.flatten()[indx + 1:]]   \naxes_legend = ax.flatten()\naxes_legend[1].legend(title = 'Income', loc = 'upper right')\naxes_legend[2].legend(title = 'Income', loc = 'upper right')\nplt.show()","f8c2c7bf":"sns.set_theme(rc = {'figure.dpi': 250, 'axes.labelsize': 6, \n                    'axes.facecolor': '#FFFDE7', 'grid.color': '#fffdfa', \n                    'figure.facecolor': '#FFFDE7'}, font_scale = 0.3)\nfig, ax = plt.subplots(9, 2, figsize = (6, 25))\ncat2 = []\nfor i in categorical_cols:\n    if i not in 'Education':\n        cat2.append(i)\nfor indx, (column, axes) in list(enumerate(list(zip(cat2, ax.flatten())))):\n    sns.countplot(ax = axes, x = df[column], hue = df['Education'].map(edu), palette = colors, alpha = 1)  \nelse:\n    [axes.set_visible(False) for axes in ax.flatten()[indx + 1:]]   \naxes_legend = ax.flatten()\naxes_legend[1].legend(title = 'Education', loc = 'upper right')\naxes_legend[2].legend(title = 'Education', loc = 'upper right')\nplt.show()","47aad21a":"sns.set_theme(rc = {'figure.dpi': 250, 'axes.labelsize': 6, \n                    'axes.facecolor': '#FFFDE7', 'grid.color': '#fffdfa', \n                    'figure.facecolor': '#FFFDE7'}, font_scale = 0.4)\nfig, ax = plt.subplots(9, 2, figsize = (6, 25))\ncat2 = []\nfor i in categorical_cols:\n    if i not in 'GenHlth':\n        cat2.append(i)\nfor indx, (column, axes) in list(enumerate(list(zip(cat2, ax.flatten())))):\n    sns.countplot(ax = axes, x = df[column], \n    hue = df['GenHlth'].map({1:'excellent',2:'very good',3:'good',4:'fair',5:'poor'}), palette = colors, alpha = 1)  \nelse:\n    [axes.set_visible(False) for axes in ax.flatten()[indx + 1:]]   \naxes_legend = ax.flatten()\naxes_legend[1].legend(title = 'GenHelth', loc = 'upper right')\naxes_legend[2].legend(title = 'GenHelth', loc = 'upper right')\nplt.show()","54d213e8":"numerical_cols","4f2a5097":"px.histogram(df, x=df['BMI'], title='BMI vs. Diabetes', color='Diabetes_binary')","e339f61d":"px.histogram(df, x=df['MentHlth'], title='MentHlth vs. Diabetes', color='Diabetes_binary')","802ffab8":"px.histogram(df, x=df['PhysHlth'], title='PhysHlth vs. Diabetes', color='Diabetes_binary')","7fee8f02":"def corrMat(df):\n    \n    corr_mat = df.corr().round(2)\n    f, ax = plt.subplots(figsize=(8,7))\n    mask = np.triu(np.ones_like(corr_mat, dtype=bool))\n    mask = mask[1:,:-1]\n    corr = corr_mat.iloc[1:,:-1].copy()\n    sns.heatmap(corr,mask=mask,vmin=-0.5,vmax=0.5,center=0, \n                cmap='RdPu_r',square=False,lw=2,annot=True,cbar=False)\n    ax.set_title('Correlation Matrix')\n    \ncorrMat(df)","78721a97":"df.shape","d65759df":"def count_outliers(data,col):\n    \n    q1 = data[col].quantile(0.25,interpolation='nearest')\n    q2 = data[col].quantile(0.5,interpolation='nearest')\n    q3 = data[col].quantile(0.75,interpolation='nearest')\n    q4 = data[col].quantile(1,interpolation='nearest')\n\n    IQR = q3 -q1\n    Lower_Bound = q1 - 1.5*IQR\n    Upper_Bound = q3 + 1.5*IQR\n\n    if data[col].min() > Lower_Bound and data[col].max() < Upper_Bound:\n        print(\"No outliers in\",i)\n    else:\n        print(\"There are outliers in\",i)\n        x = data[data[col]<Lower_Bound][col].size\n        y = data[data[col]>Upper_Bound][col].size\n        a.append(i)\n        print('Count of outliers are:',x+y)\n\na = []\nfor i in numerical_cols:\n    count_outliers(df,i)","f6fcce2c":"x = df.drop(['Diabetes_binary'],axis=1)\ny = df['Diabetes_binary']","34fa2d96":"scaler = StandardScaler()\nscaler.fit(x)","aa90db57":"scaled_features = scaler.transform(x)\nx = pd.DataFrame(scaled_features,columns=df.columns[1:])\nx.head()","306eb020":"x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=42)","3a7160e1":"knn = KNeighborsClassifier(n_neighbors = 5)\nknn.fit(x_train,y_train)","b8bbfd58":"y_pred = knn.predict(x_test)","cec79e33":"y_pred","57f661d8":"df['Diabetes_binary'].value_counts()","b1818e52":"print(classification_report(y_test,y_pred))","5c67d51b":"print(confusion_matrix(y_test,y_pred))","801bd771":"sm = SMOTEENN()\nx_resampled, y_resampled = sm.fit_resample(x,y)","122c3cb2":"xre_train,xre_test,yre_train,yre_test = train_test_split(x_resampled, y_resampled, test_size=0.3, random_state=42)","136a7abe":"knn_smote = KNeighborsClassifier(n_neighbors = 5)\nknn_smote.fit(xre_train,yre_train)","b77ceb9f":"yre_pred = knn_smote.predict(xre_test)","81bd1269":"print(classification_report(yre_test,yre_pred, labels=[0,1]))","fc255505":"print(\"Accuracy:\",metrics.accuracy_score(yre_test,yre_pred))","b2b17772":"# error_rate= []\n# for i in range(1,40):\n#     knn_smote = KNeighborsClassifier(n_neighbors = i)\n#     knn_smote.fit(xre_train,yre_train)\n#     yre_pred_i = knn_smote.predict(xre_test)\n#     error_rate.append(np.mean(yre_pred_i != yre_test))","07b40db2":"# plt.figure(figsize = (10,6))\n# plt.plot(range(1,40),error_rate,color = 'blue',linestyle = '--',marker = 'o',markerfacecolor='red',markersize = 10)\n# plt.title('Error Rate vs. n_neighbors')\n# plt.xlabel('n_neighbors')\n# plt.ylabel('Error Rate')","024ae706":"model_rf = RandomForestClassifier(n_jobs=-1, random_state=42,n_estimators=150)","bec6354f":"model_rf.fit(xre_train,yre_train)","0bc86998":"yrf_pred = model_rf.predict(xre_test)\nyrf_pred","3c3ddd28":"print(classification_report(yre_test,yrf_pred, labels=[0,1]))","f077291d":"importance_rf = pd.DataFrame({\n    'feature': xre_train.columns,\n    'score': model_rf.feature_importances_\n}).sort_values('score', ascending=False)\n\nimportance_rf.head(10)","35bae023":"# Income, Education, PhysActivity --> Negative correlation\n# GenHlth, HighBP, DiffWalk,BMI --> Positive correlation\nplt.figure(figsize = (15,5))\nsns.set(font_scale = 1)\nplt.title('Feature Importance')\nax = sns.barplot(data=importance_rf.head(10), x='score', y='feature')\nax.set(xlabel='Score', ylabel='Feature')","eb3c56dd":"## Bivariate Analysis","80d43fe3":"**Income, Education, PhysActivity --> Negative correlation**<br>\n**GenHlth, HighBP, DiffWalk,BMI  --> Positive correlation**","2c8f24c8":"## Univariate Analysis","ef00d504":"**Income, Education, PhysActivity --> Negative correlation**<br>\n**GenHlth, HighBP, DiffWalk,BMI  --> Positive correlation**","55bd385e":"## Scaling Data","c83e0b6e":"### Plot a Shifted Correlation Matrix","d87f8375":"### Due to imbalanced data the accuracy predition about diabates are low so we will fix it with **SMOTE + ENN**<br><br>\n### `SMOTE` --> `Synthetic Minority Oversampling Technique`\n### **SMOTE + ENN** is technique where more no. of observations are removed from the sample space. ENN is undersampling technique where the nearest neighbors of each of the majority class is estimated. If the nearest neighbors misclassify that particular instance of the majority class, then that instance gets deleted.<br><br>\n### Integrating this technique with oversampled data done by **SMOTE** helps in doing extensive data cleaning. Here on misclassification by NN\u2019s samples from both the classes are removed. This results in a more clear and concise class separation.","0f148f69":"## Training and Testing Data","ac3a7f2d":"### Calculate Num. of Outliers","095c0615":"## Random Forest Technique","5197c435":"Now we see that there are huge differenece before and after **resampling data**"}}