{"cell_type":{"80317dcc":"code","470fc7bb":"code","3b3cd23d":"code","21d84a28":"code","143e38ef":"code","448e7e5c":"code","9c6b3f1d":"code","80ba4b27":"code","cfaa6a7d":"code","670d2aed":"code","64e0809c":"code","137a7ed4":"code","50012a35":"code","a5db82bb":"code","d765a5d4":"code","0fbbf2fe":"code","30e2a540":"code","2d9fd107":"code","00ac152a":"code","7f596881":"code","98d4d71f":"code","f6b7f4f1":"markdown","3139c418":"markdown","e6d43d28":"markdown","e63d7017":"markdown","ef2b7df9":"markdown"},"source":{"80317dcc":"import pandas as pd\nimport numpy as np\nfrom matplotlib.pyplot import *\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import cm\nfrom sklearn.cluster import KMeans\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom dateutil import parser\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom tqdm import tqdm\nimport io # \nimport base64 # \nfrom imblearn.under_sampling import RandomUnderSampler\nfrom subprocess import check_output\nprint(check_output(['ls', '..\/input\/nyc-taxi-trip-duration\/']).decode('utf8'))","470fc7bb":"# use zipfile to unzip, open the train.csv\nimport os\nimport zipfile\nfile_pass = '..\/input\/nyc-taxi-trip-duration\/'\nfile_list = os.listdir('..\/input\/nyc-taxi-trip-duration\/')\n\nfor i in file_list:\n    if i == 'train.zip':\n        zf = zipfile.ZipFile(file_pass + i)\n        df = pd.read_csv(zf.open('train.csv'))","3b3cd23d":"# URL: https:\/\/stackoverflow.com\/questions\/26942476\/reading-csv-zipped-files-in-python\n# just same way, no need to unzip\ndf = pd.read_csv('..\/input\/nyc-taxi-trip-duration\/train.zip')","21d84a28":"df.head()","143e38ef":"# Remove rides to and from far away areas\u00b6\n\nxlim = [-74.03, -73.77]\nylim = [40.63, 40.85]\ndf = df[(df.pickup_longitude> xlim[0]) & (df.pickup_longitude < xlim[1])]\ndf = df[(df.dropoff_longitude> xlim[0]) & (df.dropoff_longitude < xlim[1])]\ndf = df[(df.pickup_latitude> ylim[0]) & (df.pickup_latitude < ylim[1])]\ndf = df[(df.dropoff_latitude> ylim[0]) & (df.dropoff_latitude < ylim[1])]","448e7e5c":"longitude = list(df.pickup_longitude) + list(df.dropoff_longitude)\nlatitude = list(df.pickup_latitude) + list(df.dropoff_latitude)\nplt.figure(figsize = (10,10))\nplt.plot(longitude,latitude,'.', alpha = 0.4, markersize = 0.05)\nplt.show()","9c6b3f1d":"loc_df = pd.DataFrame()\nloc_df['longitude'] = longitude\nloc_df['latitude'] = latitude","80ba4b27":"kmeans = KMeans(n_clusters = 15, # number of clusters\n                random_state = 2,\n                # Number of time the k-means algorithm will be run with different centroid seeds.\n                n_init = 10).fit(loc_df)\nloc_df['label'] = kmeans.labels_ # cluster results from individual datas\n\nloc_df = loc_df.sample(200000)\nplt.figure(figsize = (10, 10))\nfor label in loc_df.label.unique():\n    plt.plot(loc_df.longitude[loc_df.label == label], \n             loc_df.latitude[loc_df.label == label],\n             '.', alpha = 0.3, markersize = 0.3)\n    \nplt.title('clusters of new york')\nplt.show()","cfaa6a7d":"fig, ax = plt.subplots(figsize = (10, 10))\nfor label in loc_df.label.unique():\n    ax.plot(loc_df.longitude[loc_df.label == label],\n            loc_df.latitude[loc_df.label == label], '.', alpha = 0.4, markersize = 0.1, color = 'grey')\n    ax.plot(kmeans.cluster_centers_[label, 0], kmeans.cluster_centers_[label, 1],\n            'o', color = 'r')\n    ax.annotate(label, (kmeans.cluster_centers_[label, 0], kmeans.cluster_centers_[label, 1]),\n                        color = 'blue', fontsize = 20)\nax.set_title('cluster centers')\nplt.show()    ","670d2aed":"df['pickup_cluster'] = kmeans.predict(df[['pickup_longitude', 'pickup_latitude']])\ndf['dropoff_cluster'] = kmeans.predict(df[['dropoff_longitude', 'dropoff_latitude']])\n\n# parser :\n# This module offers a generic date\/time string parser which is able to parse most known formats to represent a date and\/or time.\ndf['pickup_hour'] = df.pickup_datetime.apply(lambda x:parser.parse(x).hour)","64e0809c":"clusters = pd.DataFrame()\nclusters['x'] = kmeans.cluster_centers_[:, 0]\nclusters['y'] = kmeans.cluster_centers_[:, 1]\nclusters['label'] = range(len(clusters))","137a7ed4":"loc_df = loc_df.sample(5000)","50012a35":"neighborhood = {-74.0019368351: 'Chelsea',-73.837549761: 'Queens',-73.7854240738: 'JFK',-73.9810421975:'Midtown-North-West',-73.9862336241: 'East Village',\n                -73.971273324:'Midtown-North-East',-73.9866739677: 'Brooklyn-parkslope',-73.8690098118: 'LaGuardia',-73.9890572967:'Midtown',-74.0081765545: 'Downtown'\n                ,-73.9213024854: 'Queens-Astoria',-73.9470256923: 'Harlem',-73.9555565018: 'Uppe East Side',\n               -73.9453487097: 'Brooklyn-Williamsburgt',-73.9745967889:'Upper West Side'}","a5db82bb":"rides_df = pd.DataFrame(columns = neighborhood.values())\nrides_df['name'] = neighborhood.values()\n\nneigh = KNeighborsClassifier(n_neighbors=1)\nneigh.fit(np.array(list(neighborhood.keys())).reshape(-1, 1), list(neighborhood.values()))","d765a5d4":"# This extracts a numpy array with the values of your pandas Series object and then reshapes it to a 2D array.\ndf['pickup_neighborhood'] = neigh.predict(df.pickup_longitude.values.reshape(-1,1))\ndf['dropoff_neighborhood'] = neigh.predict(df.dropoff_longitude.values.reshape(-1,1))\n\nfor col in tqdm(rides_df.columns[:-1]):\n    rides_df[col] = rides_df.name.apply(lambda x: len(df[(df.pickup_neighborhood == x) & (df.dropoff_neighborhood == col)]))","0fbbf2fe":"rides_df.head()","30e2a540":"import plotly.offline as py\nimport plotly.graph_objs as go\npy.init_notebook_mode(connected = True)\n\ntrace = go.Heatmap(z = np.array(rides_df.values),\n                   x = rides_df.columns[:-1],\n                   y = rides_df.columns)\n\nlayout = dict(title = ' <b>Neighborhoods Interaction<\/b>',\n              titlefont = dict(size = 30,\n                               color = ('rgb(100, 100, 100)')),\n              margin = dict(t=100, r=100, b=100, l=100),\n              yaxis = dict(title = '<b> From <\/b>'),\n              xaxis = dict(title = '<b> To <\/b>'))\ndata = [trace]\nfig = go.Figure(data = data, layout = layout)\npy.iplot(fig, filename = 'labelled-heatmap')","2d9fd107":"rides_df.index = rides_df.name\nrides_df = rides_df.drop('name', axis = 1)","00ac152a":"fig, ax = plt.subplots(figsize = (12, 12))\nfor i in range(len(rides_df)):\n    ax.plot(rides_df.sum(axis = 1)[i], rides_df.sum(axis = 0)[i], 'o',\n            color = 'b')\n    ax.annotate(rides_df.index.tolist()[i], (rides_df.sum(axis=1)[i],\n                                             rides_df.sum(axis=0)[i]),\n                color = 'b', fontsize = 12)\n    \nax.plot([0,250000],[0,250000], color = 'r', linewidth = 1)\nax.grid('off')\nax.set_xlim([0,250000])\nax.set_ylim([0,250000])\nax.set_xlabel('Outbound Taxis')\nax.set_ylabel('Inbound Taxis')\nax.set_title('Inbound and Outbound rides for each cluster')","7f596881":"df['pickup_month'] = df.pickup_datetime.apply(lambda x: parser.parse(x).month)","98d4d71f":"fig, ax = plt.subplots(2, figsize = (12, 12))\n\nrides_df = pd.DataFrame(columns = neighborhood.values())\nrides_df['name'] = neighborhood.values()\nrides_df.index = rides_df.name\n\nfor col in tqdm(rides_df.columns[:-1]):\n    rides_df[col] = rides_df.name.apply(lambda x: len(df[(df.pickup_neighborhood == x) &\n                                                         (df.dropoff_neighborhood == col) &\n                                                         (df.pickup_month == 6)]))\nfor i in range(len(rides_df)):\n    ax[0].plot(rides_df.sum(axis=1)[i], rides_df.sum(axis=0)[i], 'o', color = 'b')\n    ax[0].annotate(rides_df.index.tolist()[i], (rides_df.sum(axis = 1)[i],\n                                                rides_df.sum(axis = 0)[i]), \n                   color = 'b', fontsize = 12)\n\nax[0].grid('off')\nax[0].set_xlabel('Outbound Taxis')\nax[0].set_ylabel('Inbound Taxis')\nax[0].set_title('Inbound and Outbound rides for each cluster - June')\nax[0].set_xlim([0,40000])\nax[0].set_ylim([0,40000])\nax[0].plot([0,40000],[0,40000])\n\nfor col in tqdm(rides_df.columns[:-1]):\n    rides_df[col] = rides_df.name.apply(lambda x: len(df[(df.pickup_neighborhood == x) & (df.dropoff_neighborhood == col) & (df.pickup_month == 1)]))\nrides_df = rides_df.drop('name', axis = 1)\nfor i in range(len(rides_df)):  \n    ax[1].plot(rides_df.sum(axis = 1)[i],rides_df.sum(axis = 0)[i],'o', color = 'b')\n    ax[1].annotate(rides_df.index.tolist()[i], (rides_df.sum(axis = 1)[i],rides_df.sum(axis = 0)[i]), color = 'b', fontsize = 12)\n\nax[1].grid('off')\nax[1].set_xlabel('Outbound Taxis')\nax[1].set_ylabel('Inbound Taxis')\nax[1].set_title('Inbound and Outbound rides for each cluster - January')\nax[1].set_xlim([0,40000])\nax[1].set_ylim([0,40000])\nax[1].plot([0,40000],[0,40000])","f6b7f4f1":"### Winter vs Summer","3139c418":"##### This kernel used dataset from the New York City Taxi Trip Duration and copied from the 'Dynamics of New York city - Animation' written by Omri Goldstein.\n##### Introduction to 'Dynamics of New York city - Animation' : **[URL](https:\/\/www.kaggle.com\/drgilermo\/dynamics-of-new-york-city-animation\/notebook)**\n\n##### Thanks for sharing kernel, Omri Goldstein","e6d43d28":"#### Neighborhood Analysis\nLet manually assign the neighborhood name to each cluster","e63d7017":"#### Cluster\ncluster New York City based on the pick-up and drop-off points of each taxi ride","ef2b7df9":"As we can see, the patterns are almost identical regardless of the month. snowy January vs humid and touristic June produce very similar Taxi patterns"}}