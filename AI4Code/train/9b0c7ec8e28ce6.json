{"cell_type":{"81707bf7":"code","d72fed22":"code","ebb11bed":"code","98377787":"code","0e36be7a":"code","b484a6fd":"code","3a168522":"code","f1073e01":"code","2fd48f81":"code","371d2015":"code","cd7eba2a":"code","45e9e4ec":"code","4a5e14f4":"code","d9b530dc":"code","31fe2c41":"code","3e2167d0":"code","8666ff27":"code","94ab8494":"code","2731e7fc":"code","ae9a0675":"code","72efcd97":"code","8602fba2":"code","fd98cd29":"code","5c02814f":"code","72603d15":"code","e739d129":"code","72b0ef80":"code","f2e76501":"code","6239ad26":"code","b9e012e4":"code","0f00e935":"code","d5afecae":"code","36ebebb5":"code","23bf050d":"code","5b193083":"code","cdf40ac7":"code","ccd31517":"code","8bae4739":"code","2321454d":"code","fd4ed9c5":"code","ed215caa":"code","70719004":"code","5ae3aebd":"code","23538cae":"code","6c695462":"code","fbe625b9":"code","ee102bab":"code","2f465223":"code","53b17b1c":"code","1ce0428e":"code","4ee573cd":"code","ed9eea0a":"code","713ffb2e":"markdown","75c06006":"markdown","1345b80b":"markdown","5197f0d1":"markdown","cab01fc1":"markdown","b5465ce5":"markdown","a856d5a2":"markdown"},"source":{"81707bf7":"import pandas as pd\nimport numpy as np\nfrom pathlib import Path\nfrom datetime import datetime\nimport time\nimport matplotlib.pyplot as plt\nplt.rcParams[\"figure.figsize\"]=(20,8)\nINPUT=Path(\"..\/input\/g-research-crypto-forecasting\")","d72fed22":"def ResidualizeMarket(df, mktColumn, window):\n    if mktColumn not in df.columns:\n        return df\n\n    mkt = df[mktColumn]\n\n    num = df.multiply(mkt.values, axis=0).rolling(window).mean().values  #numerator of linear regression coefficient\n    denom = mkt.multiply(mkt.values, axis=0).rolling(window).mean().values  #denominator of linear regression coefficient\n    beta = np.nan_to_num( num.T \/ denom, nan=0., posinf=0., neginf=0.)  #if regression fell over, use beta of 0\n\n    resultRet = df - (beta * mkt.values).T  #perform residualization\n    resultBeta = 0.*df + beta.T  #shape beta \n\n    return resultRet.drop(columns=[mktColumn]), resultBeta.drop(columns=[mktColumn])\n\ndef reduce_memory(df):\n    before = df.memory_usage().sum()  \n    for col in df.columns:        \n        dtype = df[col].dtype\n        if dtype == 'float64':\n            c_min = df[col].min()\n            c_max = df[col].max()        \n            if c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                df[col] = df[col].astype(np.float32)\n            else:\n                df[col] = df[col].astype(np.float64)\n\n    df['Asset_ID'] = df['Asset_ID'].astype('int8')\n    df['Count'] = df['Count'].astype('int32')\n    df['timestamp'] = df['timestamp'].astype('uint32')\n                    \n    after = df.memory_usage().sum()\n    \n    print('Memory taken before transformation : ', before)\n    print('Memory taken after transformation : ', after)\n    print('Memory taken reduced by : ',( before - after) * 100\/ before, '%')\n    \n    return df","ebb11bed":"# Function log_return_ahead computes R_t = log(P_{t+16} \/ P_{t+1})\ndef log_return_ahead(series, periods=1): \n    return -np.log(series).diff(periods=-periods).shift(-1)","98377787":"train_df = reduce_memory(pd.read_csv(INPUT\/\"train.csv\"))\ntrain_df.head()","0e36be7a":"sub_train_df = reduce_memory(pd.read_csv(INPUT\/\"supplemental_train.csv\"))\nsub_train_df.head()","b484a6fd":"# continuous\nsub_train_df.timestamp.min()","3a168522":"train_df.timestamp.max()","f1073e01":"train_df = train_df.append(sub_train_df)","2fd48f81":"assets = pd.read_csv(INPUT\/\"asset_details.csv\")\nassets = assets.set_index(\"Asset_ID\")","371d2015":"# drop some data\ntrain_df[\"datetime\"] = train_df[\"timestamp\"].map(lambda x: datetime.fromtimestamp(x))","cd7eba2a":"prices = train_df.pivot(index=[\"timestamp\"], columns=[\"Asset_ID\"], values=[\"Close\"])\nprices = prices.droplevel(0, 1)\nasset_names = assets[\"Asset_Name\"].to_dict()\nprices = prices.rename(columns=asset_names)","45e9e4ec":"prices = prices.reindex(range(prices.index[0], int(prices.index[-1]+60),60), method='ffill')","4a5e14f4":"# fillna automatically\n# prices = prices.fillna(method=\"ffill\")","d9b530dc":"# prices.index = prices.index.map(lambda x: datetime.fromtimestamp(x))","31fe2c41":"prices.sort_index(inplace=True)\nprices.head()","3e2167d0":"log_returns_15min = log_return_ahead(prices, periods=15)","8666ff27":"assets_df = pd.read_csv(INPUT\/\"asset_details.csv\", index_col = \"Asset_ID\")\nassets_df.sort_index(inplace=True)","94ab8494":"weights = assets_df.Weight.values\nweights","2731e7fc":"weighted_avg_market_log_returns = log_returns_15min.mul(weights, axis='columns').mean(axis=1)","ae9a0675":"# log_returns_15min.mul(weights, axis='columns')[-200:].plot()\n# weighted_avg_market_log_returns[-200:].plot(style=\"k8\", grid=True)","72efcd97":"log_returns_15min[\"market\"] = weighted_avg_market_log_returns\nresidualized_market_returns, beta = ResidualizeMarket(log_returns_15min, \"market\", window=3750)","8602fba2":"# residualized_market_returns[-200:].plot(grid=True)","fd98cd29":"target = train_df.pivot(index=[\"timestamp\"], columns=[\"Asset_ID\"], values=[\"Target\"])\ntarget = target.droplevel(0, 1)\ntarget = target.rename(columns=asset_names)\ntarget = target.reindex(range(target.index[0], int(target.index[-1]+60),60), method='pad')\n# target.index = target.index.map(lambda x: datetime.fromtimestamp(x))\ntarget.sort_index(inplace=True)","5c02814f":"residualized_market_returns[\"Bitcoin\"][-500:].plot(grid=True)\ntarget[\"Bitcoin\"][-500:].plot(style='r--', grid=True)","72603d15":"residualized_market_returns[\"Bitcoin Cash\"][-500:].plot()\ntarget[\"Bitcoin Cash\"][-500:].plot(style='r--',grid=True)","e739d129":"target_diffs = np.abs(residualized_market_returns - target)","72b0ef80":"plt.hist(target_diffs.values.reshape(-1), bins=1000)\nplt.xlim((-0.01,0.01))\nplt.grid()\nplt.show()","f2e76501":"plt.hist(target_diffs.iloc[-100000:].values.reshape(-1), bins=1000)\nplt.xlim((-0.01,0.01))\nplt.grid()\nplt.show()","6239ad26":"for c in target.columns:\n    print(c)\n    if c in residualized_market_returns.columns:\n        print(residualized_market_returns[c].corr(target[c]))","b9e012e4":"residualized_market_returns[\"Maker\"][-500:].plot()\ntarget[\"Maker\"][-500:].plot(style='r--',grid=True)","0f00e935":"features = train_df.pivot(index=[\"timestamp\"], columns=[\"Asset_ID\"], values=[\"Close\", \"Count\", \"Open\", \"High\", \"Low\", \"Volume\", \"VWAP\"])","d5afecae":"residualized_market_returns.head()","36ebebb5":"features = features.rename(columns=asset_names)","23bf050d":"features = features.reindex(range(features.index[0], int(features.index[-1]+60),60), method='ffill')\n# features.index = features.index.map(lambda x: datetime.fromtimestamp(x))","5b193083":"non_fill_price = features[\"Close\"].copy()\nnon_fill_price.columns = pd.MultiIndex.from_tuples(((\"CloseN\", a) for a in non_fill_price.columns))","cdf40ac7":"features = features.fillna(method=\"ffill\")","ccd31517":"residualized_market_returns.columns = pd.MultiIndex.from_tuples(((\"Target\", a) for a in residualized_market_returns.columns))","8bae4739":"train_df = pd.concat([features, residualized_market_returns, non_fill_price], axis=1)","2321454d":"train_df.head()","fd4ed9c5":"train_df[(\"Close\", \"Maker\")].corr(train_df[(\"CloseN\", \"Maker\")])","ed215caa":"# train_df[(\"Close\", \"Maker\")].corr(train_df[(\"CloseN\", \"Maker\")])","70719004":"train_df[(\"CloseN\", \"Maker\")]","5ae3aebd":"# del features\n# del residualized_market_returns\n# del prices\n# del target","23538cae":"import gc\ngc.collect()","6c695462":"# train_df.index = train_df.index.values.astype(int) \/\/ int(1e9)\n# train_df.index.name = \"timestamp\"","fbe625b9":"train_df = train_df.stack(level=1, dropna=False)","ee102bab":"train_df = train_df.reset_index(drop=False)","2f465223":"# drop data before \"2020-08-04\" for Maker\ntrain_df.drop(train_df.loc[(train_df[\"timestamp\"] <= 1596513600) & (train_df[\"Asset_ID\"] == \"Maker\")].index, inplace=True)\n# drop data before \"xxx\" for Monero\ntrain_df.drop(train_df.loc[(train_df[\"timestamp\"] <= 1541394000) & (train_df[\"Asset_ID\"] == \"Monero\")].index, inplace=True)\n# drop data before \"2018-07-14\" for Stellar\ntrain_df.drop(train_df.loc[(train_df[\"timestamp\"] <= 1531540800) & (train_df[\"Asset_ID\"] == \"Stellar\")].index, inplace=True)","53b17b1c":"train_df = train_df.reset_index(drop=True)\ntrain_df.to_feather(\".\/train.feather\")","1ce0428e":"train_df","4ee573cd":"maker = train_df[train_df.Asset_ID == \"Maker\"].set_index(\"timestamp\")","ed9eea0a":"maker.dropna()","713ffb2e":"# Conclusion\n\nSublement file is used to construct some rolling features.","75c06006":"### Weighted Average Market Returns\n\n$$M(t) = \\frac{\\sum_a w^a R^a(t)}{\\sum_a w^a}  $$","1345b80b":"## Target Computation\n\nThis notebook attempts to compute target as described here:\n\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/286778\n\nVersion 2.0 improves readability by avoiding some unnecessary shift operations.","5197f0d1":"### Log Returns over 15 Minutes\n\n$$R^a(t) = log (P^a(t+16)\\ \/\\ P^a(t+1))$$\n","cab01fc1":"### Compare computed with provided target","b5465ce5":"### Price of assets\n$$P^a$$","a856d5a2":"# Now we replicate the Target and re-construct the datasets for easy access."}}