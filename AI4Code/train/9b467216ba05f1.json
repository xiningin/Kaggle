{"cell_type":{"2f7ab8de":"code","0a0ea9ad":"code","e4353990":"code","87767ecd":"code","0296ac53":"code","2b0a683e":"code","92b76722":"code","aa2e6581":"code","64f73331":"code","8a7c1beb":"code","ad83f84d":"code","fbfd1d99":"code","57f7ca88":"code","6aaa60d6":"code","fc71d6c8":"code","8f364da8":"code","8bd284e5":"code","db2f73cd":"code","02ed27c8":"code","ce0b2874":"code","36339019":"code","1856ce14":"code","3c92e17d":"code","eecbe163":"code","82967e2e":"code","aee2a1ae":"code","bf94e7a2":"code","5a0e3988":"code","7aa302b8":"code","00272fe4":"code","80170719":"code","9a0d6e32":"code","d6ce6b5c":"code","797cf31b":"code","0c6b6bbb":"code","16df7188":"code","280cff7c":"code","e59485ab":"code","5f9b60bd":"code","172e4986":"code","10cd79c8":"code","e392b3df":"code","167b7584":"code","0bcb8c57":"markdown","ce766b70":"markdown","c9bce183":"markdown","51ca1712":"markdown","3f0ad9da":"markdown","f4e865f4":"markdown","7fe7be13":"markdown","abdd31da":"markdown","7c47da1c":"markdown","29b98fd8":"markdown","57d937d4":"markdown","f0ae5935":"markdown","8cdac679":"markdown","ef7ff1f9":"markdown","fa56648a":"markdown","c53b3593":"markdown","9e5a2918":"markdown","34fd9cfb":"markdown","7666bdd2":"markdown","2f4c1293":"markdown","1b67492b":"markdown","a581a947":"markdown","e8777fef":"markdown","535a455c":"markdown"},"source":{"2f7ab8de":"import numpy as np\nimport pandas as pd\n\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\n\nfrom kaggle.competitions import twosigmanews\n\npd.options.mode.chained_assignment = None\npd.options.display.max_columns = 999\n\n# Get 2Sigma environment\nenv = twosigmanews.make_env()","0a0ea9ad":"# Get the data\nmt_df, nt_df = env.get_training_data()","e4353990":"mt_df.head()","87767ecd":"print(\"We have {:,} market samples in the training dataset.\".format(mt_df.shape[0]))","0296ac53":"mt_df.dtypes","2b0a683e":"mt_df.isna().sum()","92b76722":"mt_df.nunique()","aa2e6581":"asset1Code = 'AAPL.O'\nasset1_df = mt_df[(mt_df['assetCode'] == asset1Code) & (mt_df['time'] > '2015-01-01') & (mt_df['time'] < '2017-01-01')]","64f73331":"# Create a trace\ntrace1 = go.Scatter(\n    x = asset1_df['time'].dt.strftime(date_format='%Y-%m-%d').values,\n    y = asset1_df['close'].values\n)\n\nlayout = dict(title = \"Closing prices of {}\".format(asset1Code),\n              xaxis = dict(title = 'Month'),\n              yaxis = dict(title = 'Price (USD)'),\n              )\ndata = [trace1]\n\npy.iplot(dict(data=data, layout=layout), filename='basic-line')","8a7c1beb":"asset1_df['high'] = asset1_df['open']\nasset1_df['low'] = asset1_df['close']\n\nfor ind, row in asset1_df.iterrows():\n    if row['close'] > row['open']:\n        asset1_df.loc[ind, 'high'] = row['close']\n        asset1_df.loc[ind, 'low'] = row['open']\n\ntrace1 = go.Candlestick(\n    x = asset1_df['time'].dt.strftime(date_format='%Y-%m-%d').values,\n    open = asset1_df['open'].values,\n    low = asset1_df['low'].values,\n    high = asset1_df['high'].values,\n    close = asset1_df['close'].values\n)\n\nlayout = dict(title = \"Candlestick chart for {}\".format(asset1Code),\n              xaxis = dict(\n                  title = 'Month',\n                  rangeslider = dict(visible = False)\n              ),\n              yaxis = dict(title = 'Price (USD)')\n             )\ndata = [trace1]\n\npy.iplot(dict(data=data, layout=layout), filename='basic-line')","ad83f84d":"mt_df['time'].dt.date.describe()","fbfd1d99":"print(\"There are {} missing values in the `time` column\".format(mt_df['time'].isna().sum()))","57f7ca88":"mt_df['time'].dt.time.describe()","6aaa60d6":"assetsByTradingDay = mt_df.groupby(mt_df['time'].dt.date)['assetCode'].nunique()","fc71d6c8":"# Create a trace\ntrace1 = go.Bar(\n    x = assetsByTradingDay.index, # asset1_df['time'].dt.strftime(date_format='%Y-%m-%d').values,\n    y = assetsByTradingDay.values\n)\n\nlayout = dict(title = \"# of assets by trading days\",\n              xaxis = dict(title = 'Year'),\n              yaxis = dict(title = '# of assets'),\n              )\ndata = [trace1]\n\npy.iplot(dict(data=data, layout=layout), filename='basic-line')","8f364da8":"print(\"There are {:,} unique assets in the training set\".format(mt_df['assetCode'].nunique()))","8bd284e5":"print(\"There are {} missing values in the `assetCode` column\".format(mt_df['time'].isna().sum()))","db2f73cd":"volumeByAssets = mt_df.groupby(mt_df['assetCode'])['volume'].sum()\nhighestVolumes = volumeByAssets.sort_values(ascending=False)[0:10]","02ed27c8":"# Create a trace\ntrace1 = go.Pie(\n    labels = highestVolumes.index,\n    values = highestVolumes.values\n)\n\nlayout = dict(title = \"Highest trading volumes\")\ndata = [trace1]\n\npy.iplot(dict(data=data, layout=layout), filename='basic-line')","ce0b2874":"mt_df['assetName'].describe()","36339019":"print(\"There are {:,} records with assetName = `Unknown` in the training set\".format(mt_df[mt_df['assetName'] == 'Unknown'].size))","1856ce14":"assetNameGB = mt_df[mt_df['assetName'] == 'Unknown'].groupby('assetCode')\nunknownAssets = assetNameGB.size().reset_index('assetCode')","3c92e17d":"print(\"There are {} unique assets without assetName in the training set\".format(unknownAssets.shape[0]))","eecbe163":"unknownAssets","82967e2e":"mt_df['universe'].nunique()","aee2a1ae":"print(\"There are {:,} missing values in the `universe` column\".format(mt_df['universe'].isna().sum()))","bf94e7a2":"print(\"There are {:,} missing values in the `volume` column\".format(mt_df['volume'].isna().sum()))","5a0e3988":"mt_df['volume'].describe()","7aa302b8":"zeroVolume = mt_df[mt_df['volume'] == 0]","00272fe4":"print(\"There are {:,} sample in the training set with zero trading volumes\".format(len(zeroVolume)))","80170719":"print(\"The scoring function will consider {:,} out of {:,} 'zero trading' training samples\".format(len(zeroVolume[zeroVolume['universe'] == 1]), len(zeroVolume)))","9a0d6e32":"volumesByTradingDay = mt_df.groupby(mt_df['time'].dt.date)['volume'].sum()","d6ce6b5c":"# Create a trace\ntrace1 = go.Bar(\n    x = volumesByTradingDay.index,\n    y = volumesByTradingDay.values\n)\n\nlayout = dict(title = \"Trading volumes by date\",\n              xaxis = dict(title = 'Year'),\n              yaxis = dict(title = 'Volume'),\n              )\ndata = [trace1]\n\npy.iplot(dict(data=data, layout=layout), filename='basic-line')","797cf31b":"print(\"There are {:,} missing values in the `open` column\".format(mt_df['open'].isna().sum()))","0c6b6bbb":"mt_df['open'].describe()","16df7188":"print(\"There are {:,} missing values in the `close` column\".format(mt_df['close'].isna().sum()))","280cff7c":"mt_df['close'].describe()","e59485ab":"print(\"There are {} missing `returnsOpenNextMktres10` values in the training set.\".format(mt_df['returnsOpenNextMktres10'].isna().sum()))","5f9b60bd":"# No growth, no decrease\nprint(len(mt_df[mt_df['returnsOpenNextMktres10'] == 0]))","172e4986":"mt_df['returnsOpenNextMktres10'].describe()","10cd79c8":"outliers = mt_df[(mt_df['returnsOpenNextMktres10'] > 1) |  (mt_df['returnsOpenNextMktres10'] < -1)]\noutliers['returnsOpenNextMktres10'].describe()","e392b3df":"# returnsOpenNextMktres10 data without outliers\nwoOutliers = mt_df[(mt_df['returnsOpenNextMktres10'] < 1) &  (mt_df['returnsOpenNextMktres10'] > -1)]\nwoOutliers['returnsOpenNextMktres10'].describe()","167b7584":"# Create a trace\ntrace1 = go.Histogram(\n    x = woOutliers.sample(n=10000)['returnsOpenNextMktres10'].values\n)\n\nlayout = dict(title = \"returnsOpenNextMktres10 (random 10.000 sample; without outliers)\")\ndata = [trace1]\n\npy.iplot(dict(data=data, layout=layout), filename='basic-line')","0bcb8c57":"In this notebook I'll try to explore the basic information about the dataset to help us build our models \/ features.\n\n\n# Data description\n> Each asset is identified by an `assetCode` *(note that a single company may have multiple assetCodes)*. Depending on what you wish to do, you may use the `assetCode`, `assetName`, or `time` as a way to join the market data to news data.\n>\n> The marketdata contains a variety of returns calculated over different timespans. All of the returns in this set of marketdata have these properties:\n* Returns are always calculated either open-to-open (from the opening time of one trading day to the open of another) or close-to-close (from the closing time of one trading day to the open of another).\n* Returns are either raw, meaning that the data is not adjusted against any benchmark, or market-residualized (Mktres), meaning that the movement of the market as a whole has been accounted for, leaving only movements inherent to the instrument.\n* Returns can be calculated over any arbitrary interval. Provided here are 1 day and 10 day horizons.\n* Returns are tagged with 'Prev' if they are backwards looking in time, or 'Next' if forwards looking.","ce766b70":"# `time` column","c9bce183":"# `universe` column\n> a boolean indicating whether or not the instrument on that day will be included in scoring. This value is not provided outside of the training data time period. The trading universe on a given date is the set of instruments that are avilable for trading (the scoring function will not consider instruments that are not in the trading universe). The trading universe changes daily.","51ca1712":"# `assetName` column\n> the name that corresponds to a group of `assetCodes`. These may be \"Unknown\" if the corresponding `assetCode` does not have any rows in the news data.","3f0ad9da":"------------------\n**More to come. Stay tuned!**\n\nPlease upvote if you like the notebook :)","f4e865f4":"Let's start with importing the necessary libraries.","7fe7be13":"There are 0 trading volumes, let's examine those.","abdd31da":"# `returns` columns\n> The marketdata contains a variety of returns calculated over different timespans. All of the returns in this set of marketdata have these properties:\n>\n> * Returns are always calculated either open-to-open (from the opening time of one trading day to the open of another) or close-to-close (from the closing time of one trading day to the open of another).\n* Returns are either raw, meaning that the data is not adjusted against any benchmark, or market-residualized (Mktres), meaning that the movement of the market as a whole has been accounted for, leaving only movements inherent to the instrument.\n* Returns can be calculated over any arbitrary interval. Provided here are 1 day and 10 day horizons.\n* Returns are tagged with 'Prev' if they are backwards looking in time, or 'Next' if forwards looking.","7c47da1c":"**returnsOpenNextMktres10**\nMarket-residualized open-to-open returns in the next 10 days.\n> This is the target variable used in competition scoring. The market data **has been filtered** such that `returnsOpenNextMktres10` is **always not null**.","29b98fd8":"*Please note: we don't have `high` and `low` data in the dataset*","57d937d4":"I just realized that the trading volumes are shares not currency values, so the chart above shows the trading volumes per day in shares. Trading volume in USD would be more interesting. I'll fix it later.","f0ae5935":"# `volume` column\n> trading volume in shares for the day","8cdac679":"According to the data description:\n> The data is stored and retrieved as Pandas dataframes in the Kernels environment. Columns types are optimized to minimize space in memory.\n\nI think the `assetCode` could be `category` dtype too.\n> *universe(float64)* - a boolean indicating whether or not the instrument on that day will be included in scoring. This value is not provided outside of the training data time period. The trading universe on a given date is the set of instruments that are avilable for trading (the scoring function will not consider instruments that are not in the trading universe). The trading universe changes daily.\n\nWhy we need a `float64` for a boolean? Do I missing something?","ef7ff1f9":"# `assetCode` column\n> a unique id of an asset","fa56648a":"**Number of unique values**","c53b3593":"# `open` column\n> the open price for the day (not adjusted for splits or dividends)","9e5a2918":"Ok, so we have more than 4M samples. The mean is 0.014 and the std is 7.24 but we have -1375 and 9761 minimum and maximum values. We should examine those outliers.","34fd9cfb":"# `close` column\n> the close price for the day (not adjusted for splits or dividends)","7666bdd2":"# Example Asset - Apple Inc","2f4c1293":"According to the competition's data description:\n> all rows are taken at 22:00 UTC\n\nLet's see...","1b67492b":"How many of them are included in the scoring calculation?","a581a947":"**dtype**","e8777fef":"# Market data","535a455c":"**NaN**"}}