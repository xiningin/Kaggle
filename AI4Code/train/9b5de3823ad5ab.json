{"cell_type":{"c8990743":"code","ab129411":"code","9516332d":"code","f0199917":"code","1462816f":"code","104e8f8d":"code","3080ca9e":"code","dacd8eff":"code","c3f7b634":"code","3749cd5b":"code","a0b93ef6":"code","99ac6020":"code","40f5c8ca":"code","27260403":"code","f74a0882":"code","d2baaacd":"code","5eee260d":"code","269c1232":"code","262a6c23":"code","6f960cb8":"code","b02f732c":"code","c48015a4":"code","b737595d":"code","578d1cd5":"code","61932605":"code","77dbabe8":"code","6e488a90":"markdown","8fe36b1e":"markdown","f72b87f3":"markdown","8a05d723":"markdown","3cbea2f6":"markdown","8717b7c8":"markdown","ddfdf07e":"markdown","2f1b9033":"markdown","7236d79b":"markdown","5fab70a8":"markdown","a844bc83":"markdown","5054a11d":"markdown","636b6364":"markdown","6777bada":"markdown","3b8e0997":"markdown","da3a692e":"markdown","1f229094":"markdown","32a3b33f":"markdown","f2f3b600":"markdown","7c47e0b5":"markdown"},"source":{"c8990743":"import glob\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport tensorflow as  tf\nimport tensorflow_addons as tfa\n\nfrom keras import backend as K\nfrom sklearn.metrics import classification_report\nfrom sklearn.model_selection import train_test_split\n\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom tensorflow.keras.applications import EfficientNetB0\nfrom tensorflow.keras.metrics import CategoricalAccuracy\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator","ab129411":"# Open train dataframe and print it\n# train_df = pd.read_csv(r\"..\/input\/recursion-cellular-image-classification\/train.csv\")\n\n# train_df","9516332d":"# # Set path to get training images\n# path = r\"..\/input\/recursion-cellular-image-classification\/train\/*\/*\/*.png\"\n\n# # Save path to all training images in a Pandas dataframe using glob\n# df = pd.DataFrame(glob.glob(path), columns=[\"image_path\"])\n\n# # Print dataframe\n# df","f0199917":"# # Get EXPERIMENT from image's path - according to the documentation\n# df['experiment'] = df['image_path'].str.split(\"\/\").str[4]\n\n# # Get PLATE from image's path\n# df['plate'] = df['image_path'].str.split(\"\/\").str[5].str.split(\"Plate\").str[1]\n\n# # Cast 'plate' values to int\n# df['plate'] = df['plate'].astype(int)\n\n# # Get WELL from image's path\n# df['well'] = df['image_path'].str.split(\"\/\").str[6].str.split(\"_\").str[0]\n\n# # Print dataframe to check if process went well\n# df","1462816f":"# # Create an empty list to save the labels\n# sirna_list = []\n\n# # Iterate through the dataframe using 'itertuples' and search on the training dataframe\n# # for each image's label\n# for t in df.itertuples(index=False):\n#     sirna_list.append(train_df.loc[(t[1] == train_df['experiment']) &\n#                                 (t[2] == train_df['plate']) &\n#                                 (t[3] == train_df['well'])]['sirna'].values)\n\n# # Add new column to dataframe containing the labels accquired\n# df['sirna'] = sirna_list\n\n# # The labels acquired come in the form of a series, we're getting the labels themselves\n# # or, if the image is not labeled, we get an empty list, so we're replacing it with NaN\n# df['sirna'] = df['sirna'].apply(lambda x: np.nan if len(x) == 0 else x[0])\n\n# # Print the dataframe with the labels\n# df","104e8f8d":"# # Check for NaNs\n# print(df.info(), end=\"\\n\\n\")\n\n# # Remove NaNs\n# df.dropna(inplace=True)\n\n# # Check final product\n# df.info()","3080ca9e":"# Plot labels count\n# df['sirna'].value_counts().plot(kind='bar', figsize=(14, 7))","dacd8eff":"# Save dataframe for later use and to avoid the costly method of acquiring the labels\n# df.to_csv(r\"\/kaggle\/working\/train_dataframe.csv\", index=False)","c3f7b634":"# Open the dataframe with the images' path and labels\ndf = pd.read_csv(r\"..\/input\/rcic-edited-dataframe\/train_dataframe.csv\")\n\ndf","3749cd5b":"x_train, x_test, y_train, y_test = train_test_split(df, df['sirna'], test_size=0.1,\n                                                    random_state=31415,\n                                                    stratify=df['sirna'])\n\nx_val, x_test, y_val, y_test = train_test_split(x_test, x_test['sirna'], test_size=0.5,\n                                                random_state=31415,\n                                                stratify=x_test['sirna'])\n\nprint(\"Train data's shape:      {}; {}\".format(x_train.shape, y_train.shape))\nprint(\"Validation data's shape: {}; {}\".format(x_val.shape, y_val.shape))\nprint(\"Test data's shape:       {}; {}\".format(x_test.shape, y_test.shape))","a0b93ef6":"# Multiclass F1-score MICRO Avg.\nmicro_f1 = tfa.metrics.F1Score(\n    num_classes=1108,\n    average='micro',\n    name=\"Micro F1\",\n)\n\n# Multiclass F1-score MACRO Avg.\nmacro_f1 = tfa.metrics.F1Score(\n    num_classes=1108,\n    average='macro',\n    name=\"Macro F1\",\n)","99ac6020":"IMG_SIZE = 224\nBATCH_SIZE = 512\n\ntrain_dataGen = ImageDataGenerator(\n    rescale=1.\/255, rotation_range=90, horizontal_flip=True, vertical_flip=True)\n\ntrain_generator = train_dataGen.flow_from_dataframe(\n    dataframe=x_train, x_col='image_path', class_mode='categorical', seed=31415,\n    y_col='sirna', target_size=(IMG_SIZE, IMG_SIZE), batch_size=BATCH_SIZE)\n\nval_generator = train_dataGen.flow_from_dataframe(\n    dataframe=x_val, x_col='image_path', class_mode='categorical', seed=31415,\n    y_col='sirna', target_size=(IMG_SIZE, IMG_SIZE), batch_size=BATCH_SIZE)\n\ntest_generator = train_dataGen.flow_from_dataframe(\n    dataframe=x_test, x_col='image_path', class_mode='categorical', seed=31415,\n    y_col='sirna', target_size=(IMG_SIZE, IMG_SIZE), batch_size=BATCH_SIZE)","40f5c8ca":"# # Load EfficientNet pre-trained w\/ ImageNet\n# base_model = EfficientNetB0(include_top=False, weights=\"imagenet\")\n\n# # Rebuild top\n# avg = layers.GlobalAveragePooling2D(name=\"avg_pool\")(base_model.output)\n# norm = layers.BatchNormalization()(avg)\n# dropout = layers.Dropout(0.3, name=\"top_dropout\")(norm)\n# output = layers.Dense(1108, activation=\"softmax\", name=\"pred\")(dropout)\n\n# model = tf.keras.Model(base_model.input, output, name=\"EfficientNet-B0\")\n\n# # Freeze the pretrained weights\n# for layer in base_model.layers:\n#     layer.trainable = False\n\n# # Optimizer setup\n# optimizer = tf.keras.optimizers.Adam(learning_rate=1e-3)\n\n# # Metrics\n# metrics = [CategoricalAccuracy(name='Categorical Accuracy'),\n#            micro_f1, macro_f1]\n\n# # Compile model\n# model.compile(optimizer=optimizer, loss=\"categorical_crossentropy\",\n#               metrics=metrics)","27260403":"# # Checkpoint to save network's best weights\n# checkpoint = tf.keras.callbacks.ModelCheckpoint(\n#     \".\/effNet-B0_{epoch:02d}\",\n#     monitor='val_loss', verbose=1, save_best_only=True,\n#     save_weights_only=True, mode='min')","f74a0882":"# # Top layers training\n\n# # Epochs to train the top layers: min:8; max:80\n# history = model.fit(train_generator, validation_data=val_generator, epochs=3,\n#                     callbacks=[checkpoint])","d2baaacd":"# # Save model's current weights\n# model.save_weights(r\".\/effNetB0_topTrained_weights\")\n\n# # Save whole model\n# model.save(r\".\/effNetB0_topTrained_model\")","5eee260d":"# Unfreeze all layer's pretrained weights\n# for layer in model.layers:\n#     layer.trainable = True","269c1232":"# Load whole model previously trained\n# model = keras.models.load_model(r\"..\/input\/rcictfmodel-final\/effNet-B0_13\")\n\n# Change optimizer's parameters (if needed)\n# K.set_value(model.optimizer.learning_rate, 1e-3)\n# K.set_value(model.optimizer.beta_1, 0.9)\n\n# Verify changes to optimizer's parameters\n# print(model.optimizer.learning_rate)\n# print(model.optimizer.beta_1)","262a6c23":"# Checkpoint to save model after each epoch of training\n# checkpoint = tf.keras.callbacks.ModelCheckpoint(\n#     \".\/effNet-B0_{epoch:02d}\",\n#     monitor='val_loss', verbose=1, save_best_only=False,\n#     save_weights_only=False, mode='min')","6f960cb8":"# Train the whole model\n# history = model.fit(train_generator, validation_data=val_generator, epochs=13,\n#                     callbacks=[checkpoint], initial_epoch=10)","b02f732c":"# Open dataframes containing previous training results\nhistory_df1 = pd.read_csv(r\"..\/input\/rcictfmodel-te02\/effNetB0_history.csv\")\nhistory_df2 = pd.read_csv(r\"..\/input\/rcictf-modelte04\/effNetB0_history.csv\")\nhistory_df3 = pd.read_csv(r\"..\/input\/rcictfmodelte07\/effNetB0_history.csv\")\nhistory_df4 = pd.read_csv(r\"..\/input\/rcictfmodelte10\/effNetB0_history.csv\")\nhistory_df5 = pd.read_csv(r\"..\/input\/rcictfmodel-final\/effNetB0_history.csv\")\n\n# Append newer epochs training values to 1st dataframe\nhistory_df1 = history_df1.append(history_df2, ignore_index=True)\nhistory_df1 = history_df1.append(history_df3, ignore_index=True)\nhistory_df1 = history_df1.append(history_df4, ignore_index=True)\nhistory_df1 = history_df1.append(history_df5, ignore_index=True)\n\n# Save metrics' history as a CSV file\nhistory_df1.to_csv(\".\/effNetB0_history.csv\", index=False)","c48015a4":"history_df1.to_csv(\".\/effNetB0_history.csv\", index=False)","b737595d":"history_df1","578d1cd5":"# summarize history for accuracy\nplt.plot(history_df1['Categorical Accuracy'])\nplt.plot(history_df1['val_Categorical Accuracy'])\nplt.title('Model accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()\n\n# summarize history for loss\nplt.plot(history_df1['loss'])\nplt.plot(history_df1['val_loss'])\nplt.title('Model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()\n\n# summarize history for MICRO F1-score\nplt.plot(history_df1['Micro F1'])\nplt.plot(history_df1['val_Micro F1'])\nplt.title('Model F1-Score (micro avg.)')\nplt.ylabel('F1-Score (micro avg.)')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()\n\n# summarize history for MACRO F1-score\nplt.plot(history_df1['Macro F1'])\nplt.plot(history_df1['val_Macro F1'])\nplt.title('Model F1-score (macro avg.)')\nplt.ylabel('F1-score (macro avg.)')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()","61932605":"# Load whole model previously trained\nmodel = keras.models.load_model(r\"..\/input\/rcictfmodel-final\/effNet-B0_13\")","77dbabe8":"# Predicts labels\ntest_predictions = model.predict(test_generator, verbose=1)\n\nprint(classification_report(test_generator.labels,\n                            test_predictions.argmax(1), zero_division=0))","6e488a90":"### Dependencies\n#### Metrics\n\nSince Keras\/TensorFlow don't have the necessary metrics to evaluate a multiclass task (such as precision, recall and specificity), we're going to use both **micro** and **macro** averaged F1-score and categorical accuracy (available in TF\/Keras) as our metrics. For micro\/macro F1, we're using [TensorFlow Addons](https:\/\/www.tensorflow.org\/addons) library.","8fe36b1e":"### Top layers' training","f72b87f3":"### Image data generators\nGiven the time available for the task, I didn't considered using data augmentation (DA), because I didn't know much about the underlying details of the problem and what methods were appropriate. So, the top layers were trained without DA.\n\nI added DA. after peeking the work of the competition's winner, so I'm using almost the same method as them. This means that I'm using DA in the training of all layers (just to be clear, this step wasn't taken for the top layers' training).\n\nThe images are resized to 224x224 px because it's the input size for EfficientNet-B0. Batch size is 512 in order to try and accelerate training and also because there is enough memory for the task (1024 works, but raises warnings). Once again we're seeding the RNG, so experiments should be consistent between runs.","8a05d723":"We can see that we have a lot of classes (1108, to be precise) but the data is mostly balanced, with around 400 instances for each class.","3cbea2f6":"# Recursion Cellular Image Classification\n\n---\n### Universidade de Bras\u00edlia\n\nCIC0193 - Fundamentos de Sistemas Inteligentes\n\nProf.: Vinicius Borges\n\nAluno: Pedro Lucas Silva Haga Torres\n\nMatr\u00edcula: 16\/0141575\n\n##### Atividade IV - Redes Neurais Convolucionais\n\n---\nThis is an assignment for the *Fundamentos de Sistemas Inteligentes* (Fundaments of Inteligent Systems) course at Universidade de Bras\u00edlia (University of Bras\u00edlia). All of the code and documentation is in english, the only exception being the header above, which identifies myself as an student undertaking the course mentioned previously.","8717b7c8":"### Stratified split between train, validation and test\nWe're going to use transfer learning, so, for training the top layers, I used the more common split of 70-20-10 (training, validation and test, respectively, in percentage). But, after consideration, since there are more than 400k images, I choose a split of 90-5-5 to train the whole model.\n\nSince `random_state` is defined, we can repeat the experiment any number of times and get the same results. I also stratified the split according to the labels' distribution.","ddfdf07e":"## Imports","2f1b9033":"## Classification task","7236d79b":"### Getting the data we need\n\nSince the directory structure don't give us much beyond labeling the images as train and test, we'll start by getting the path to all images using `glob` and saving it to a Pandas dataframe.","5fab70a8":"## Conclusion\n\nGiven both validation and test results, I'm not going to bother submitting mine, as it would be just a waste of computer cycles. I'll just leave here what I would have done if I had the time to start over:\n\n1. I would have done a better job with image preprocessing (I'd resize instead of just crop with Keras) and data augmentation (I'd increase the number of training instances 3 or 4 fold.\n2. I'd have used EfficientNet-B2, at the very least, but I would try using B3 or higher with a smaller batch size (128, at most).\n3. Of course, I would train the model for more epochs and using SGD with Nesterov, to compare with Adam.\n\nWith this 3 steps, I think I could have done a better job, without the need to go overboard with ensemble, for instance (remember, this is an undergrad assingment). I'm not satisfied with this results, but it is what I could do with the time I had.","a844bc83":"### Labeling the images\n\nThis is probably not the most efficient way to do this, but we're going to get the labels by searching the training dataframe using the experiment, plate and well that we got from the images' path. This will be saved on a list, first, and then it'll be added on the dataframe with the images' path.","5054a11d":"### Network instatiation\n\nThe chosen architecture was EfficientNet-B0. Since I'm submitting this work as an assignment for an university course, it was chosen in order to minimize training time (as I only had a week to dedicate to this assignment). This means that EfficientNet-B0 is the smallest network of its family and should not have a great classification performance.\n\nIn summary, the EfficientNet architecture was proposed by Tan and Le who are (or were) both researchers at Google. Its idea was to study the growth of a CNN parameters (number of layers, filters and input size) as an optimization problem. This can be used with more traditional architectures such as ResNet, Inception, GoogLeNet, etc. in order to optimize them, or, to create a brand new architecture - EfficientNet - and scale its growth towards better performance with a reduced number of trainable parameters. For more information, check the link to the paper hosted in arXiv below:\n\nhttps:\/\/arxiv.org\/abs\/1905.11946\n\ntl;dr: EfficientNet-B0's performance is close to DenseNet-201 and ResNet-152 in ImageNet, while having way less parameters (about half of DenseNet's, and 1\/6 of ResNet's).","636b6364":"### Save dataframe containing the images' path and label","6777bada":"### Testing the model\nI don't expect much from it, I'm just hoping it's on par with the validation metrics.","3b8e0997":"As we can see, the only usefull information in the training dataframe are the labels (`sirna`). We can't get to the images using this dataframe, so we'll have to use the information in the images'path to get to their labels. What identifies a label in this dataframe is the experiment, plate and well, so we'll use this information (which, according to the documentation is also in the image path) to label the images.","da3a692e":"### Check number of classes and data distribuition","1f229094":"## Data analysis","32a3b33f":"### All layers' training","f2f3b600":"### Removing images without a label\n\nWe can see that we have a few unlabeled images, so we're going to remove them using Pandas' `dropna()`.","7c47e0b5":"### Getting images' info based on their path\n\nAccording to the documentation, we can find the experiment, plate and well in the path or in the image's name, so we're going to use this in order to properly label the images."}}